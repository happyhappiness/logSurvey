@@ -53,6 +53,11 @@ rfc2186.txt
 rfc2187.txt
 	Internet Cache Protocol (ICP), version 2
 
+rfc2181.txt
+	Clarifications to the DNS Specification
+	Squid uses a number of constants from the DNS and Host specifications
+	(RFC 1035, RFC 1123) this defines details on their correct usage.
+
 rfc2227.txt
 	Simple Hit-Metering and Usage-Limiting for HTTP
 
@@ -0,0 +1,842 @@
+
+
+
+
+
+
+Network Working Group                                             R. Elz
+Request for Comments: 2181                       University of Melbourne
+Updates: 1034, 1035, 1123                                        R. Bush
+Category: Standards Track                                    RGnet, Inc.
+                                                               July 1997
+
+
+                Clarifications to the DNS Specification
+
+Status of this Memo
+
+   This document specifies an Internet standards track protocol for the
+   Internet community, and requests discussion and suggestions for
+   improvements.  Please refer to the current edition of the "Internet
+   Official Protocol Standards" (STD 1) for the standardization state
+   and status of this protocol.  Distribution of this memo is unlimited.
+
+1. Abstract
+
+   This document considers some areas that have been identified as
+   problems with the specification of the Domain Name System, and
+   proposes remedies for the defects identified.  Eight separate issues
+   are considered:
+
+     + IP packet header address usage from multi-homed servers,
+     + TTLs in sets of records with the same name, class, and type,
+     + correct handling of zone cuts,
+     + three minor issues concerning SOA records and their use,
+     + the precise definition of the Time to Live (TTL)
+     + Use of the TC (truncated) header bit
+     + the issue of what is an authoritative, or canonical, name,
+     + and the issue of what makes a valid DNS label.
+
+   The first six of these are areas where the correct behaviour has been
+   somewhat unclear, we seek to rectify that.  The other two are already
+   adequately specified, however the specifications seem to be sometimes
+   ignored.  We seek to reinforce the existing specifications.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Elz & Bush                  Standards Track                     [Page 1]
+
+RFC 2181        Clarifications to the DNS Specification        July 1997
+
+
+
+
+Contents
+
+    1  Abstract  ...................................................   1
+    2  Introduction  ...............................................   2
+    3  Terminology  ................................................   3
+    4  Server Reply Source Address Selection  ......................   3
+    5  Resource Record Sets  .......................................   4
+    6  Zone Cuts  ..................................................   8
+    7  SOA RRs  ....................................................  10
+    8  Time to Live (TTL)  .........................................  10
+    9  The TC (truncated) header bit  ..............................  11
+   10  Naming issues  ..............................................  11
+   11  Name syntax  ................................................  13
+   12  Security Considerations  ....................................  14
+   13  References  .................................................  14
+   14  Acknowledgements  ...........................................  15
+   15  Authors' Addresses  .........................................  15
+
+
+
+
+2. Introduction
+
+   Several problem areas in the Domain Name System specification
+   [RFC1034, RFC1035] have been noted through the years [RFC1123].  This
+   document addresses several additional problem areas.  The issues here
+   are independent.  Those issues are the question of which source
+   address a multi-homed DNS server should use when replying to a query,
+   the issue of differing TTLs for DNS records with the same label,
+   class and type, and the issue of canonical names, what they are, how
+   CNAME records relate, what names are legal in what parts of the DNS,
+   and what is the valid syntax of a DNS name.
+
+   Clarifications to the DNS specification to avoid these problems are
+   made in this memo.  A minor ambiguity in RFC1034 concerned with SOA
+   records is also corrected, as is one in the definition of the TTL
+   (Time To Live) and some possible confusion in use of the TC bit.
+
+
+
+
+
+
+
+
+
+
+
+
+Elz & Bush                  Standards Track                     [Page 2]
+
+RFC 2181        Clarifications to the DNS Specification        July 1997
+
+
+3. Terminology
+
+   This memo does not use the oft used expressions MUST, SHOULD, MAY, or
+   their negative forms.  In some sections it may seem that a
+   specification is worded mildly, and hence some may infer that the
+   specification is optional.  That is not correct.  Anywhere that this
+   memo suggests that some action should be carried out, or must be
+   carried out, or that some behaviour is acceptable, or not, that is to
+   be considered as a fundamental aspect of this specification,
+   regardless of the specific words used.  If some behaviour or action
+   is truly optional, that will be clearly specified by the text.
+
+4. Server Reply Source Address Selection
+
+   Most, if not all, DNS clients, expect the address from which a reply
+   is received to be the same address as that to which the query
+   eliciting the reply was sent.  This is true for servers acting as
+   clients for the purposes of recursive query resolution, as well as
+   simple resolver clients.  The address, along with the identifier (ID)
+   in the reply is used for disambiguating replies, and filtering
+   spurious responses.  This may, or may not, have been intended when
+   the DNS was designed, but is now a fact of life.
+
+   Some multi-homed hosts running DNS servers generate a reply using a
+   source address that is not the same as the destination address from
+   the client's request packet.  Such replies will be discarded by the
+   client because the source address of the reply does not match that of
+   a host to which the client sent the original request.  That is, it
+   appears to be an unsolicited response.
+
+4.1. UDP Source Address Selection
+
+   To avoid these problems, servers when responding to queries using UDP
+   must cause the reply to be sent with the source address field in the
+   IP header set to the address that was in the destination address
+   field of the IP header of the packet containing the query causing the
+   response.  If this would cause the response to be sent from an IP
+   address that is not permitted for this purpose, then the response may
+   be sent from any legal IP address allocated to the server.  That
+   address should be chosen to maximise the possibility that the client
+   will be able to use it for further queries.  Servers configured in
+   such a way that not all their addresses are equally reachable from
+   all potential clients need take particular care when responding to
+   queries sent to anycast, multicast, or similar, addresses.
+
+
+
+
+
+
+
+Elz & Bush                  Standards Track                     [Page 3]
+
+RFC 2181        Clarifications to the DNS Specification        July 1997
+
+
+4.2. Port Number Selection
+
+   Replies to all queries must be directed to the port from which they
+   were sent.  When queries are received via TCP this is an inherent
+   part of the transport protocol.  For queries received by UDP the
+   server must take note of the source port and use that as the
+   destination port in the response.  Replies should always be sent from
+   the port to which they were directed.  Except in extraordinary
+   circumstances, this will be the well known port assigned for DNS
+   queries [RFC1700].
+
+5. Resource Record Sets
+
+   Each DNS Resource Record (RR) has a label, class, type, and data.  It
+   is meaningless for two records to ever have label, class, type and
+   data all equal - servers should suppress such duplicates if
+   encountered.  It is however possible for most record types to exist
+   with the same label, class and type, but with different data.  Such a
+   group of records is hereby defined to be a Resource Record Set
+   (RRSet).
+
+5.1. Sending RRs from an RRSet
+
+   A query for a specific (or non-specific) label, class, and type, will
+   always return all records in the associated RRSet - whether that be
+   one or more RRs.  The response must be marked as "truncated" if the
+   entire RRSet will not fit in the response.
+
+5.2. TTLs of RRs in an RRSet
+
+   Resource Records also have a time to live (TTL).  It is possible for
+   the RRs in an RRSet to have different TTLs.  No uses for this have
+   been found that cannot be better accomplished in other ways.  This
+   can, however, cause partial replies (not marked "truncated") from a
+   caching server, where the TTLs for some but not all the RRs in the
+   RRSet have expired.
+
+   Consequently the use of differing TTLs in an RRSet is hereby
+   deprecated, the TTLs of all RRs in an RRSet must be the same.
+
+   Should a client receive a response containing RRs from an RRSet with
+   differing TTLs, it should treat this as an error.  If the RRSet
+   concerned is from a non-authoritative source for this data, the
+   client should simply ignore the RRSet, and if the values were
+   required, seek to acquire them from an authoritative source.  Clients
+   that are configured to send all queries to one, or more, particular
+   servers should treat those servers as authoritative for this purpose.
+   Should an authoritative source send such a malformed RRSet, the
+
+
+
+Elz & Bush                  Standards Track                     [Page 4]
+
+RFC 2181        Clarifications to the DNS Specification        July 1997
+
+
+   client should treat the RRs for all purposes as if all TTLs in the
+   RRSet had been set to the value of the lowest TTL in the RRSet.  In
+   no case may a server send an RRSet with TTLs not all equal.
+
+5.3. DNSSEC Special Cases
+
+   Two of the record types added by DNS Security (DNSSEC) [RFC2065]
+   require special attention when considering the formation of Resource
+   Record Sets.  Those are the SIG and NXT records.  It should be noted
+   that DNS Security is still very new, and there is, as yet, little
+   experience with it.  Readers should be prepared for the information
+   related to DNSSEC contained in this document to become outdated as
+   the DNS Security specification matures.
+
+5.3.1. SIG records and RRSets
+
+   A SIG record provides signature (validation) data for another RRSet
+   in the DNS.  Where a zone has been signed, every RRSet in the zone
+   will have had a SIG record associated with it.  The data type of the
+   RRSet is included in the data of the SIG RR, to indicate with which
+   particular RRSet this SIG record is associated.  Were the rules above
+   applied, whenever a SIG record was included with a response to
+   validate that response, the SIG records for all other RRSets
+   associated with the appropriate node would also need to be included.
+   In some cases, this could be a very large number of records, not
+   helped by their being rather large RRs.
+
+   Thus, it is specifically permitted for the authority section to
+   contain only those SIG RRs with the "type covered" field equal to the
+   type field of an answer being returned.  However, where SIG records
+   are being returned in the answer section, in response to a query for
+   SIG records, or a query for all records associated with a name
+   (type=ANY) the entire SIG RRSet must be included, as for any other RR
+   type.
+
+   Servers that receive responses containing SIG records in the
+   authority section, or (probably incorrectly) as additional data, must
+   understand that the entire RRSet has almost certainly not been
+   included.  Thus, they must not cache that SIG record in a way that
+   would permit it to be returned should a query for SIG records be
+   received at that server.  RFC2065 actually requires that SIG queries
+   be directed only to authoritative servers to avoid the problems that
+   could be caused here, and while servers exist that do not understand
+   the special properties of SIG records, this will remain necessary.
+   However, careful design of SIG record processing in new
+   implementations should permit this restriction to be relaxed in the
+   future, so resolvers do not need to treat SIG record queries
+   specially.
+
+
+
+Elz & Bush                  Standards Track                     [Page 5]
+
+RFC 2181        Clarifications to the DNS Specification        July 1997
+
+
+   It has been occasionally stated that a received request for a SIG
+   record should be forwarded to an authoritative server, rather than
+   being answered from data in the cache.  This is not necessary - a
+   server that has the knowledge of SIG as a special case for processing
+   this way would be better to correctly cache SIG records, taking into
+   account their characteristics.  Then the server can determine when it
+   is safe to reply from the cache, and when the answer is not available
+   and the query must be forwarded.
+
+5.3.2. NXT RRs
+
+   Next Resource Records (NXT) are even more peculiar.  There will only
+   ever be one NXT record in a zone for a particular label, so
+   superficially, the RRSet problem is trivial.  However, at a zone cut,
+   both the parent zone, and the child zone (superzone and subzone in
+   RFC2065 terminology) will have NXT records for the same name.  Those
+   two NXT records do not form an RRSet, even where both zones are
+   housed at the same server.  NXT RRSets always contain just a single
+   RR.  Where both NXT records are visible, two RRSets exist.  However,
+   servers are not required to treat this as a special case when
+   receiving NXT records in a response.  They may elect to notice the
+   existence of two different NXT RRSets, and treat that as they would
+   two different RRSets of any other type.  That is, cache one, and
+   ignore the other.  Security aware servers will need to correctly
+   process the NXT record in the received response though.
+
+5.4. Receiving RRSets
+
+   Servers must never merge RRs from a response with RRs in their cache
+   to form an RRSet.  If a response contains data that would form an
+   RRSet with data in a server's cache the server must either ignore the
+   RRs in the response, or discard the entire RRSet currently in the
+   cache, as appropriate.  Consequently the issue of TTLs varying
+   between the cache and a response does not cause concern, one will be
+   ignored.  That is, one of the data sets is always incorrect if the
+   data from an answer differs from the data in the cache.  The
+   challenge for the server is to determine which of the data sets is
+   correct, if one is, and retain that, while ignoring the other.  Note
+   that if a server receives an answer containing an RRSet that is
+   identical to that in its cache, with the possible exception of the
+   TTL value, it may, optionally, update the TTL in its cache with the
+   TTL of the received answer.  It should do this if the received answer
+   would be considered more authoritative (as discussed in the next
+   section) than the previously cached answer.
+
+
+
+
+
+
+
+Elz & Bush                  Standards Track                     [Page 6]
+
+RFC 2181        Clarifications to the DNS Specification        July 1997
+
+
+5.4.1. Ranking data
+
+   When considering whether to accept an RRSet in a reply, or retain an
+   RRSet already in its cache instead, a server should consider the
+   relative likely trustworthiness of the various data.  An
+   authoritative answer from a reply should replace cached data that had
+   been obtained from additional information in an earlier reply.
+   However additional information from a reply will be ignored if the
+   cache contains data from an authoritative answer or a zone file.
+
+   The accuracy of data available is assumed from its source.
+   Trustworthiness shall be, in order from most to least:
+
+     + Data from a primary zone file, other than glue data,
+     + Data from a zone transfer, other than glue,
+     + The authoritative data included in the answer section of an
+       authoritative reply.
+     + Data from the authority section of an authoritative answer,
+     + Glue from a primary zone, or glue from a zone transfer,
+     + Data from the answer section of a non-authoritative answer, and
+       non-authoritative data from the answer section of authoritative
+       answers,
+     + Additional information from an authoritative answer,
+       Data from the authority section of a non-authoritative answer,
+       Additional information from non-authoritative answers.
+
+   Note that the answer section of an authoritative answer normally
+   contains only authoritative data.  However when the name sought is an
+   alias (see section 10.1.1) only the record describing that alias is
+   necessarily authoritative.  Clients should assume that other records
+   may have come from the server's cache.  Where authoritative answers
+   are required, the client should query again, using the canonical name
+   associated with the alias.
+
+   Unauthenticated RRs received and cached from the least trustworthy of
+   those groupings, that is data from the additional data section, and
+   data from the authority section of a non-authoritative answer, should
+   not be cached in such a way that they would ever be returned as
+   answers to a received query.  They may be returned as additional
+   information where appropriate.  Ignoring this would allow the
+   trustworthiness of relatively untrustworthy data to be increased
+   without cause or excuse.
+
+   When DNS security [RFC2065] is in use, and an authenticated reply has
+   been received and verified, the data thus authenticated shall be
+   considered more trustworthy than unauthenticated data of the same
+   type.  Note that throughout this document, "authoritative" means a
+   reply with the AA bit set.  DNSSEC uses trusted chains of SIG and KEY
+
+
+
+Elz & Bush                  Standards Track                     [Page 7]
+
+RFC 2181        Clarifications to the DNS Specification        July 1997
+
+
+   records to determine the authenticity of data, the AA bit is almost
+   irrelevant.  However DNSSEC aware servers must still correctly set
+   the AA bit in responses to enable correct operation with servers that
+   are not security aware (almost all currently).
+
+   Note that, glue excluded, it is impossible for data from two
+   correctly configured primary zone files, two correctly configured
+   secondary zones (data from zone transfers) or data from correctly
+   configured primary and secondary zones to ever conflict.  Where glue
+   for the same name exists in multiple zones, and differs in value, the
+   nameserver should select data from a primary zone file in preference
+   to secondary, but otherwise may choose any single set of such data.
+   Choosing that which appears to come from a source nearer the
+   authoritative data source may make sense where that can be
+   determined.  Choosing primary data over secondary allows the source
+   of incorrect glue data to be discovered more readily, when a problem
+   with such data exists.  Where a server can detect from two zone files
+   that one or more are incorrectly configured, so as to create
+   conflicts, it should refuse to load the zones determined to be
+   erroneous, and issue suitable diagnostics.
+
+   "Glue" above includes any record in a zone file that is not properly
+   part of that zone, including nameserver records of delegated sub-
+   zones (NS records), address records that accompany those NS records
+   (A, AAAA, etc), and any other stray data that might appear.
+
+5.5. Sending RRSets (reprise)
+
+   A Resource Record Set should only be included once in any DNS reply.
+   It may occur in any of the Answer, Authority, or Additional
+   Information sections, as required.  However it should not be repeated
+   in the same, or any other, section, except where explicitly required
+   by a specification.  For example, an AXFR response requires the SOA
+   record (always an RRSet containing a single RR) be both the first and
+   last record of the reply.  Where duplicates are required this way,
+   the TTL transmitted in each case must be the same.
+
+6. Zone Cuts
+
+   The DNS tree is divided into "zones", which are collections of
+   domains that are treated as a unit for certain management purposes.
+   Zones are delimited by "zone cuts".  Each zone cut separates a
+   "child" zone (below the cut) from a "parent" zone (above the cut).
+   The domain name that appears at the top of a zone (just below the cut
+   that separates the zone from its parent) is called the zone's
+   "origin".  The name of the zone is the same as the name of the domain
+   at the zone's origin.  Each zone comprises that subset of the DNS
+   tree that is at or below the zone's origin, and that is above the
+
+
+
+Elz & Bush                  Standards Track                     [Page 8]
+
+RFC 2181        Clarifications to the DNS Specification        July 1997
+
+
+   cuts that separate the zone from its children (if any).  The
+   existence of a zone cut is indicated in the parent zone by the
+   existence of NS records specifying the origin of the child zone.  A
+   child zone does not contain any explicit reference to its parent.
+
+6.1. Zone authority
+
+   The authoritative servers for a zone are enumerated in the NS records
+   for the origin of the zone, which, along with a Start of Authority
+   (SOA) record are the mandatory records in every zone.  Such a server
+   is authoritative for all resource records in a zone that are not in
+   another zone.  The NS records that indicate a zone cut are the
+   property of the child zone created, as are any other records for the
+   origin of that child zone, or any sub-domains of it.  A server for a
+   zone should not return authoritative answers for queries related to
+   names in another zone, which includes the NS, and perhaps A, records
+   at a zone cut, unless it also happens to be a server for the other
+   zone.
+
+   Other than the DNSSEC cases mentioned immediately below, servers
+   should ignore data other than NS records, and necessary A records to
+   locate the servers listed in the NS records, that may happen to be
+   configured in a zone at a zone cut.
+
+6.2. DNSSEC issues
+
+   The DNS security mechanisms [RFC2065] complicate this somewhat, as
+   some of the new resource record types added are very unusual when
+   compared with other DNS RRs.  In particular the NXT ("next") RR type
+   contains information about which names exist in a zone, and hence
+   which do not, and thus must necessarily relate to the zone in which
+   it exists.  The same domain name may have different NXT records in
+   the parent zone and the child zone, and both are valid, and are not
+   an RRSet.  See also section 5.3.2.
+
+   Since NXT records are intended to be automatically generated, rather
+   than configured by DNS operators, servers may, but are not required
+   to, retain all differing NXT records they receive regardless of the
+   rules in section 5.4.
+
+   For a secure parent zone to securely indicate that a subzone is
+   insecure, DNSSEC requires that a KEY RR indicating that the subzone
+   is insecure, and the parent zone's authenticating SIG RR(s) be
+   present in the parent zone, as they by definition cannot be in the
+   subzone.  Where a subzone is secure, the KEY and SIG records will be
+   present, and authoritative, in that zone, but should also always be
+   present in the parent zone (if secure).
+
+
+
+
+Elz & Bush                  Standards Track                     [Page 9]
+
+RFC 2181        Clarifications to the DNS Specification        July 1997
+
+
+   Note that in none of these cases should a server for the parent zone,
+   not also being a server for the subzone, set the AA bit in any
+   response for a label at a zone cut.
+
+7. SOA RRs
+
+   Three minor issues concerning the Start of Zone of Authority (SOA)
+   Resource Record need some clarification.
+
+7.1. Placement of SOA RRs in authoritative answers
+
+   RFC1034, in section 3.7, indicates that the authority section of an
+   authoritative answer may contain the SOA record for the zone from
+   which the answer was obtained.  When discussing negative caching,
+   RFC1034 section 4.3.4 refers to this technique but mentions the
+   additional section of the response.  The former is correct, as is
+   implied by the example shown in section 6.2.5 of RFC1034.  SOA
+   records, if added, are to be placed in the authority section.
+
+7.2. TTLs on SOA RRs
+
+   It may be observed that in section 3.2.1 of RFC1035, which defines
+   the format of a Resource Record, that the definition of the TTL field
+   contains a throw away line which states that the TTL of an SOA record
+   should always be sent as zero to prevent caching.  This is mentioned
+   nowhere else, and has not generally been implemented.
+   Implementations should not assume that SOA records will have a TTL of
+   zero, nor are they required to send SOA records with a TTL of zero.
+
+7.3. The SOA.MNAME field
+
+   It is quite clear in the specifications, yet seems to have been
+   widely ignored, that the MNAME field of the SOA record should contain
+   the name of the primary (master) server for the zone identified by
+   the SOA.  It should not contain the name of the zone itself.  That
+   information would be useless, as to discover it, one needs to start
+   with the domain name of the SOA record - that is the name of the
+   zone.
+
+8. Time to Live (TTL)
+
+   The definition of values appropriate to the TTL field in STD 13 is
+   not as clear as it could be, with respect to how many significant
+   bits exist, and whether the value is signed or unsigned.  It is
+   hereby specified that a TTL value is an unsigned number, with a
+   minimum value of 0, and a maximum value of 2147483647.  That is, a
+   maximum of 2^31 - 1.  When transmitted, this value shall be encoded
+   in the less significant 31 bits of the 32 bit TTL field, with the
+
+
+
+Elz & Bush                  Standards Track                    [Page 10]
+
+RFC 2181        Clarifications to the DNS Specification        July 1997
+
+
+   most significant, or sign, bit set to zero.
+
+   Implementations should treat TTL values received with the most
+   significant bit set as if the entire value received was zero.
+
+   Implementations are always free to place an upper bound on any TTL
+   received, and treat any larger values as if they were that upper
+   bound.  The TTL specifies a maximum time to live, not a mandatory
+   time to live.
+
+9. The TC (truncated) header bit
+
+   The TC bit should be set in responses only when an RRSet is required
+   as a part of the response, but could not be included in its entirety.
+   The TC bit should not be set merely because some extra information
+   could have been included, but there was insufficient room.  This
+   includes the results of additional section processing.  In such cases
+   the entire RRSet that will not fit in the response should be omitted,
+   and the reply sent as is, with the TC bit clear.  If the recipient of
+   the reply needs the omitted data, it can construct a query for that
+   data and send that separately.
+
+   Where TC is set, the partial RRSet that would not completely fit may
+   be left in the response.  When a DNS client receives a reply with TC
+   set, it should ignore that response, and query again, using a
+   mechanism, such as a TCP connection, that will permit larger replies.
+
+10. Naming issues
+
+   It has sometimes been inferred from some sections of the DNS
+   specification [RFC1034, RFC1035] that a host, or perhaps an interface
+   of a host, is permitted exactly one authoritative, or official, name,
+   called the canonical name.  There is no such requirement in the DNS.
+
+10.1. CNAME resource records
+
+   The DNS CNAME ("canonical name") record exists to provide the
+   canonical name associated with an alias name.  There may be only one
+   such canonical name for any one alias.  That name should generally be
+   a name that exists elsewhere in the DNS, though there are some rare
+   applications for aliases with the accompanying canonical name
+   undefined in the DNS.  An alias name (label of a CNAME record) may,
+   if DNSSEC is in use, have SIG, NXT, and KEY RRs, but may have no
+   other data.  That is, for any label in the DNS (any domain name)
+   exactly one of the following is true:
+
+
+
+
+
+
+Elz & Bush                  Standards Track                    [Page 11]
+
+RFC 2181        Clarifications to the DNS Specification        July 1997
+
+
+     + one CNAME record exists, optionally accompanied by SIG, NXT, and
+       KEY RRs,
+     + one or more records exist, none being CNAME records,
+     + the name exists, but has no associated RRs of any type,
+     + the name does not exist at all.
+
+10.1.1. CNAME terminology
+
+   It has been traditional to refer to the label of a CNAME record as "a
+   CNAME".  This is unfortunate, as "CNAME" is an abbreviation of
+   "canonical name", and the label of a CNAME record is most certainly
+   not a canonical name.  It is, however, an entrenched usage.  Care
+   must therefore be taken to be very clear whether the label, or the
+   value (the canonical name) of a CNAME resource record is intended.
+   In this document, the label of a CNAME resource record will always be
+   referred to as an alias.
+
+10.2. PTR records
+
+   Confusion about canonical names has lead to a belief that a PTR
+   record should have exactly one RR in its RRSet.  This is incorrect,
+   the relevant section of RFC1034 (section 3.6.2) indicates that the
+   value of a PTR record should be a canonical name.  That is, it should
+   not be an alias.  There is no implication in that section that only
+   one PTR record is permitted for a name.  No such restriction should
+   be inferred.
+
+   Note that while the value of a PTR record must not be an alias, there
+   is no requirement that the process of resolving a PTR record not
+   encounter any aliases.  The label that is being looked up for a PTR
+   value might have a CNAME record.  That is, it might be an alias.  The
+   value of that CNAME RR, if not another alias, which it should not be,
+   will give the location where the PTR record is found.  That record
+   gives the result of the PTR type lookup.  This final result, the
+   value of the PTR RR, is the label which must not be an alias.
+
+10.3. MX and NS records
+
+   The domain name used as the value of a NS resource record, or part of
+   the value of a MX resource record must not be an alias.  Not only is
+   the specification clear on this point, but using an alias in either
+   of these positions neither works as well as might be hoped, nor well
+   fulfills the ambition that may have led to this approach.  This
+   domain name must have as its value one or more address records.
+   Currently those will be A records, however in the future other record
+   types giving addressing information may be acceptable.  It can also
+   have other RRs, but never a CNAME RR.
+
+
+
+
+Elz & Bush                  Standards Track                    [Page 12]
+
+RFC 2181        Clarifications to the DNS Specification        July 1997
+
+
+   Searching for either NS or MX records causes "additional section
+   processing" in which address records associated with the value of the
+   record sought are appended to the answer.  This helps avoid needless
+   extra queries that are easily anticipated when the first was made.
+
+   Additional section processing does not include CNAME records, let
+   alone the address records that may be associated with the canonical
+   name derived from the alias.  Thus, if an alias is used as the value
+   of an NS or MX record, no address will be returned with the NS or MX
+   value.  This can cause extra queries, and extra network burden, on
+   every query.  It is trivial for the DNS administrator to avoid this
+   by resolving the alias and placing the canonical name directly in the
+   affected record just once when it is updated or installed.  In some
+   particular hard cases the lack of the additional section address
+   records in the results of a NS lookup can cause the request to fail.
+
+11. Name syntax
+
+   Occasionally it is assumed that the Domain Name System serves only
+   the purpose of mapping Internet host names to data, and mapping
+   Internet addresses to host names.  This is not correct, the DNS is a
+   general (if somewhat limited) hierarchical database, and can store
+   almost any kind of data, for almost any purpose.
+
+   The DNS itself places only one restriction on the particular labels
+   that can be used to identify resource records.  That one restriction
+   relates to the length of the label and the full name.  The length of
+   any one label is limited to between 1 and 63 octets.  A full domain
+   name is limited to 255 octets (including the separators).  The zero
+   length full name is defined as representing the root of the DNS tree,
+   and is typically written and displayed as ".".  Those restrictions
+   aside, any binary string whatever can be used as the label of any
+   resource record.  Similarly, any binary string can serve as the value
+   of any record that includes a domain name as some or all of its value
+   (SOA, NS, MX, PTR, CNAME, and any others that may be added).
+   Implementations of the DNS protocols must not place any restrictions
+   on the labels that can be used.  In particular, DNS servers must not
+   refuse to serve a zone because it contains labels that might not be
+   acceptable to some DNS client programs.  A DNS server may be
+   configurable to issue warnings when loading, or even to refuse to
+   load, a primary zone containing labels that might be considered
+   questionable, however this should not happen by default.
+
+   Note however, that the various applications that make use of DNS data
+   can have restrictions imposed on what particular values are
+   acceptable in their environment.  For example, that any binary label
+   can have an MX record does not imply that any binary name can be used
+   as the host part of an e-mail address.  Clients of the DNS can impose
+
+
+
+Elz & Bush                  Standards Track                    [Page 13]
+
+RFC 2181        Clarifications to the DNS Specification        July 1997
+
+
+   whatever restrictions are appropriate to their circumstances on the
+   values they use as keys for DNS lookup requests, and on the values
+   returned by the DNS.  If the client has such restrictions, it is
+   solely responsible for validating the data from the DNS to ensure
+   that it conforms before it makes any use of that data.
+
+   See also [RFC1123] section 6.1.3.5.
+
+12. Security Considerations
+
+   This document does not consider security.
+
+   In particular, nothing in section 4 is any way related to, or useful
+   for, any security related purposes.
+
+   Section 5.4.1 is also not related to security.  Security of DNS data
+   will be obtained by the Secure DNS [RFC2065], which is mostly
+   orthogonal to this memo.
+
+   It is not believed that anything in this document adds to any
+   security issues that may exist with the DNS, nor does it do anything
+   to that will necessarily lessen them.  Correct implementation of the
+   clarifications in this document might play some small part in
+   limiting the spread of non-malicious bad data in the DNS, but only
+   DNSSEC can help with deliberate attempts to subvert DNS data.
+
+13. References
+
+   [RFC1034]   Mockapetris, P., "Domain Names - Concepts and Facilities",
+               STD 13, RFC 1034, November 1987.
+
+   [RFC1035]   Mockapetris, P., "Domain Names - Implementation and
+               Specification", STD 13, RFC 1035, November 1987.
+
+   [RFC1123]   Braden, R., "Requirements for Internet Hosts - application
+               and support", STD 3, RFC 1123, January 1989.
+
+   [RFC1700]   Reynolds, J., Postel, J., "Assigned Numbers",
+               STD 2, RFC 1700, October 1994.
+
+   [RFC2065]   Eastlake, D., Kaufman, C., "Domain Name System Security
+               Extensions", RFC 2065, January 1997.
+
+
+
+
+
+
+
+
+
+Elz & Bush                  Standards Track                    [Page 14]
+
+RFC 2181        Clarifications to the DNS Specification        July 1997
+
+
+14. Acknowledgements
+
+   This memo arose from discussions in the DNSIND working group of the
+   IETF in 1995 and 1996, the members of that working group are largely
+   responsible for the ideas captured herein.  Particular thanks to
+   Donald E. Eastlake, 3rd, and Olafur Gudmundsson, for help with the
+   DNSSEC issues in this document, and to John Gilmore for pointing out
+   where the clarifications were not necessarily clarifying.  Bob Halley
+   suggested clarifying the placement of SOA records in authoritative
+   answers, and provided the references.  Michael Patton, as usual, and
+   Mark Andrews, Alan Barrett and Stan Barber provided much assistance
+   with many details.  Josh Littlefield helped make sure that the
+   clarifications didn't cause problems in some irritating corner cases.
+
+15. Authors' Addresses
+
+   Robert Elz
+   Computer Science
+   University of Melbourne
+   Parkville, Victoria, 3052
+   Australia.
+
+   EMail: kre@munnari.OZ.AU
+
+
+   Randy Bush
+   RGnet, Inc.
+   5147 Crystal Springs Drive NE
+   Bainbridge Island, Washington,  98110
+   United States.
+
+   EMail: randy@psg.com
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Elz & Bush                  Standards Track                    [Page 15]
@@ -30,17 +30,22 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *  
  */
-
 #ifndef SQUID_ARRAY_H
 #define SQUID_ARRAY_H
 
+/**
+ \todo CLEANUP: this file should be called Vector.h at least, and probably be replaced by STL Vector<C>
+ */
+
 #include "fatal.h"
 #include "util.h"
 
+/* users of this template also need assert() */
+#include "assert.h"
+
 /* iterator support */
 
 template <class C>
-
 class VectorIteratorBase
 {
 
@@ -72,7 +77,6 @@ class VectorIteratorBase
 };
 
 template<class E>
-
 class Vector
 {
 
@@ -118,7 +122,7 @@ template<class E>
 void *
 Vector<E>::operator new(size_t size)
 {
-    return xmalloc (size);
+    return xmalloc(size);
 }
 
 template<class E>
@@ -1,10 +1,11 @@
 /*
  * $Id: GNUregex.h,v 1.9 2003/08/03 22:53:47 hno Exp $
  */
-
 #ifndef SQUID_REGEXP_LIBRARY_H
 #define SQUID_REGEXP_LIBRARY_H
 
+#include "config.h"
+
 /* Definitions for data structures and routines for the regular
  * expression library, version 0.12.
  * 
@@ -35,10 +35,15 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef _INC_IPADDRESS_H
 #define _INC_IPADDRESS_H
 
+#include "getaddrinfo.h"
+#include "getnameinfo.h"
+#include "inet_ntop.h"
+#include "inet_pton.h"
+
+
 #if HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
@@ -56,14 +61,9 @@
 #include <netdb.h>
 #endif
 
-
 #include <iosfwd>
 #include <ostream>
 
-#include "getaddrinfo.h"
-#include "getnameinfo.h"
-#include "inet_ntop.h"
-#include "inet_pton.h"
 
 /* FreeBSD hack:
  *   This OS has at least one version that defines these as private
@@ -402,6 +402,7 @@ class IPAddress
 #endif
 };
 
+
 inline std::ostream &
 operator << (std::ostream &os, const IPAddress &ipa)
 {
@@ -1,4 +1,3 @@
-
 /*
  * $Id: List.h,v 1.8 2008/02/26 21:49:33 amosjeffries Exp $
  *
@@ -34,7 +33,8 @@
 #ifndef SQUID_LIST_H
 #define SQUID_LIST_H
 
-#include "cbdata.h"
+/** \todo FUBAR: cbdata.h is over in src/ */
+#include "../src/cbdata.h"
 
 /// \ingroup POD
 template <class C>
@@ -1,4 +1,3 @@
-
 #ifndef _MEM_POOLS_H_
 #define _MEM_POOLS_H_
 
@@ -30,17 +30,19 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *  
  */
-
 #ifndef SQUID_NEW_H
 #define SQUID_NEW_H
 
+#include "util.h"
+
 /* Any code using libstdc++ must have externally resolvable overloads
  * for void * operator new - which means in the .o for the binary,
  * or in a shared library. static libs don't propogate the symbol
  * so, look in the translation unit containing main() in squid
  * for the extern version in squid
  */
 #include <new>
+
 _SQUID_EXTERNNEW_ void *operator new(size_t size) throw (std::bad_alloc)
 {
     return xmalloc(size);
@@ -57,4 +59,5 @@ _SQUID_EXTERNNEW_ void operator delete[] (void *address) throw()
 {
     xfree (address);
 }
+
 #endif /* SQUID_NEW_H */
@@ -1,6 +1,8 @@
 #ifndef SQUID_SNMP_ASN1_H
 #define SQUID_SNMP_ASN1_H
 
+#include "config.h"
+
 /*
  * Definitions for Abstract Syntax Notation One, ASN.1
  * As defined in ISO/IS 8824 and ISO/IS 8825
@@ -33,7 +35,7 @@
  **********************************************************************/
 
 #ifndef EIGHTBIT_SUBIDS
-typedef u_int oid;
+typedef u_int8_t oid;
 #define MAX_SUBID   0xFFFFFFFF
 #else
 typedef u_char oid;
@@ -1,4 +1,3 @@
-
 /*
  * $Id: assert.h,v 1.3 2006/05/12 21:52:24 hno Exp $
  *
@@ -31,7 +30,6 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_ASSERT_H
 #define SQUID_ASSERT_H
 
@@ -1,7 +1,6 @@
 /*
  * $Id: cache_snmp.h,v 1.30 2007/12/14 23:11:44 amosjeffries Exp $
  */
-
 #ifndef SQUID_CACHE_SNMP_H
 #define SQUID_CACHE_SNMP_H
 
@@ -19,7 +18,9 @@
 
 #include "snmp.h"
 #include "snmp_impl.h"
+#if 0
 #include "asn1.h"
+#endif
 #include "snmp_api.h"
 
 #include "snmp_vars.h"
@@ -0,0 +1,11 @@
+/*
+ * $Id$
+ */
+#ifndef _SQUID_GETFULLHOSTNAME_H
+#define _SQUID_GETFULLHOSTNAME_H
+
+#include "config.h"
+
+SQUIDCEXTERN const char *getfullhostname(void);
+
+#endif /* _SQUID_GETFULLHOSTNAME_H */
@@ -1,10 +1,11 @@
 /*
  * $Id: hash.h,v 1.8 2003/01/23 00:36:47 robertc Exp $
  */
-
 #ifndef SQUID_HASH_H
 #define SQUID_HASH_H
 
+#include "config.h"
+
 typedef void HASHFREE(void *);
 typedef int HASHCMP(const void *, const void *);
 typedef unsigned int HASHHASH(const void *, unsigned int);
@@ -40,10 +40,12 @@
  * the top of the heap (as in the smallest object key value).  Child nodes
  * are larger than their parent.
  ****************************************************************************/
-
 #ifndef	SQUID_HEAP_H
 #define	SQUID_HEAP_H
 
+/* Squid autoconf definitions */
+#include "config.h"
+
 /*
  * Function for generating heap keys.  The first argument will typically be
  * a dws_md_p passed in as a void *.  Should find a way to get type safety
@@ -1,6 +1,8 @@
 #ifndef _INC_INET_NTOP_H
 #define _INC_INET_NTOP_H
 
+#include "config.h"
+
 #if HAVE_INET_NTOP
 
 /* Use the system provided version where possible */
@@ -1,6 +1,8 @@
 #ifndef _INC_INET_PTON_H
 #define _INC_INET_PTON_H
 
+#include "config.h"
+
 #if HAVE_INET_PTON
 
 /* Use the system provided version where possible */
@@ -4,6 +4,8 @@
 #ifndef SQUID_INITGROUPS_H
 #define SQUID_INITGROUPS_H
 
+#include "config.h"
+
 /* if you have configure you can use this */
 #if defined(HAVE_CONFIG_H)
 #include "config.h"
@@ -14,4 +16,5 @@
 #endif
 
 SQUIDCEXTERN int initgroups(const char *user, gid_t group);
+
 #endif /* SQUID_INITGROPS_H */
@@ -1,6 +1,8 @@
 #ifndef SQUID_MD5_H
 #define SQUID_MD5_H
 
+#include "config.h"
+
 /*
  * This is the header file for the MD5 message-digest algorithm.
  * The algorithm is due to Ron Rivest.  This code was
@@ -1,7 +1,11 @@
-
+/*
+ * $Id$
+ */
 #ifndef _MEM_METER_H_
 #define _MEM_METER_H_
 
+#include "config.h"
+
 /* object to track per-action memory usage (e.g. #idle objects) */
 class MemMeter {
   public:
@@ -1,7 +1,6 @@
 /*
  * $Id: parse.h,v 1.12 2003/01/23 00:36:47 robertc Exp $
  */
-
 #ifndef SQUID_PARSE_H
 #define SQUID_PARSE_H
 
@@ -26,11 +25,12 @@ WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
 ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
 SOFTWARE.
 ******************************************************************/
-/*
- * parse.h
- */
 
-/*
+/* NP: we only need struct variable_list and typedef oid from SNMP library     */
+/*     we use as ptrs. If this was true C++ we could pre-define their classes. */
+#include "snmp_vars.h"
+
+/**
  * A linked list of tag-value pairs for enumerated integers.
  */
 struct enum_list {
@@ -39,7 +39,7 @@ struct enum_list {
     char *label;
 };
 
-/*
+/**
  * A tree in the format of the tree structure of the MIB.
  */
 struct snmp_mib_tree {
@@ -63,7 +63,7 @@ struct snmp_mib_tree {
 #define TYPE_COUNTER	    6
 #define TYPE_GAUGE	    7
 #define TYPE_TIMETICKS	    8
-#define TYPE_OPAQUE	            9
+#define TYPE_OPAQUE	    9
 #define TYPE_NULL	    10
 
 #ifdef __cplusplus
@@ -1,10 +1,11 @@
 /*
  * $Id: radix.h,v 1.18 2003/10/20 12:33:03 robertc Exp $
  */
-
 #ifndef SQUID_RADIX_H
 #define	SQUID_RADIX_H
 
+#include "config.h"
+
 /*
  * Copyright (c) 1988, 1989, 1993
  *      The Regents of the University of California.  All rights reserved.
@@ -30,11 +30,11 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *  
  */
-
 #ifndef SQUID_RFC1035_H
 #define SQUID_RFC1035_H
 
 #include "config.h"
+
 #if HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
@@ -45,8 +45,19 @@
 #include <arpa/inet.h>
 #endif
 
-/* rfc1035 - DNS */
-#define RFC1035_MAXHOSTNAMESZ 256
+#include "rfc2181.h"
+
+/**
+ \par RFC 1035 Section 3.1:
+ *  To simplify implementations, the total length of a domain name (i.e.,
+ *  label octets and label length octets) is restricted to 255 octets or
+ *  less.
+ *\par
+ *  Clarified by RFC 2181 Section 11. (RFC2181_MAXHOSTNAMELEN)
+ */
+#define RFC1035_MAXHOSTNAMESZ RFC2181_MAXHOSTNAMELEN
+
+
 typedef struct _rfc1035_rr rfc1035_rr;
 struct _rfc1035_rr {
     char name[RFC1035_MAXHOSTNAMESZ];
@@ -56,12 +67,14 @@ struct _rfc1035_rr {
     unsigned short rdlength;
     char *rdata;
 };
+
 typedef struct _rfc1035_query rfc1035_query;
 struct _rfc1035_query {
     char name[RFC1035_MAXHOSTNAMESZ];
     unsigned short qtype;
     unsigned short qclass;
 };
+
 typedef struct _rfc1035_message rfc1035_message;
 struct _rfc1035_message {
     unsigned short id;
@@ -0,0 +1,27 @@
+/*
+ * $Id$
+ */
+#ifndef _SQUID_INCLUDE_RFC1123_H
+#define _SQUID_INCLUDE_RFC1123_H
+
+/**
+ \par RFC 2181 section 11:
+ *  A full domain name is limited to 255 octets (including the separators).
+ *
+ \par RFC 1123 section 2.1:
+ *  Host software MUST handle host names of up to 63 characters and
+ *  SHOULD handle host names of up to 255 characters.
+ *
+ *\par
+ *  Also Ref: RFC 1035 Section 3.1  (RFC1035_MAXHOSTNAMESZ)
+ *
+ \par
+ *  Squid accepts up to 255 character Hostname and Fully-Qualified Domain Names.
+ *  Squid still NULL-terminates its FQDN and hotsname strings.
+ */
+#define RFC2181_MAXHOSTNAMELEN	256
+
+ /// Back-port macro for old squid code still using SQUIDHOSTNAMELEN without RFC reference.
+#define SQUIDHOSTNAMELEN	RFC2181_MAXHOSTNAMELEN
+
+#endif /* _SQUID_INCLUDE_RFC1123_H */
@@ -46,10 +46,11 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_RFC2617_H
 #define SQUID_RFC2617_H
 
+#include "config.h"
+
 #define HASHLEN 16
 typedef char HASH[HASHLEN];
 #define HASHHEXLEN 32
@@ -39,7 +39,9 @@
 #endif
 
 /* These come first */
+#if 0
 #include "asn1.h"
+#endif
 #include "snmp_error.h"
 #if 0
 #include "mibii.h"
@@ -1,10 +1,12 @@
 /*
  * $Id: snmp_api_util.h,v 1.5 2003/01/23 00:36:47 robertc Exp $
  */
-
 #ifndef SQUID_SNMP_API_UTIL_H
 #define SQUID_SNMP_API_UTIL_H
 
+/* NP: required for typedef ipaddr and indirect config.h */
+#include "snmp_pdu.h"
+
 /***********************************************************
 	Copyright 1997 by Carnegie Mellon University
 
@@ -1,23 +1,15 @@
 /*
  * $Id: snmp_debug.h,v 1.13 2003/01/23 00:36:47 robertc Exp $
  */
-
 #ifndef SQUID_SNMP_DEBUG_H
 #define SQUID_SNMP_DEBUG_H
 
-#ifdef __cplusplus
-extern "C" {
-#endif
+#include "config.h"
 
 #if STDC_HEADERS
-extern void 
-snmplib_debug(int, const char *,...) PRINTF_FORMAT_ARG2;
+SQUIDCEXTERN void snmplib_debug(int, const char *,...) PRINTF_FORMAT_ARG2;
 #else
-extern void snmplib_debug (va_alist);
-#endif
-
-#ifdef __cplusplus
-};
+SQUIDCEXTERN void snmplib_debug(va_alist);
 #endif
 
 #endif /* SQUID_SNMP_DEBUG_H */
@@ -1,10 +1,11 @@
 /*
  * $Id: snmp_impl.h,v 1.15 2003/01/23 00:36:48 robertc Exp $
  */
-
 #ifndef SQUID_SNMP_IMPL_H
 #define SQUID_SNMP_IMPL_H
 
+#include "asn1.h"
+
 /*
  * Definitions for SNMP (RFC 1067) implementation.
  *
@@ -46,6 +47,8 @@ SOFTWARE.
 
 #define SID_MAX_LEN	64
 
+#if 0 /* defines performed globally by config.h */
+
 #ifndef NULL
 #define NULL 0
 #endif
@@ -56,6 +59,7 @@ SOFTWARE.
 #ifndef FALSE
 #define FALSE	0
 #endif
+#endif /* dead code. */
 
 #define READ	    1
 #define WRITE	    0
@@ -2,6 +2,8 @@
 #ifndef SQUID_SNMP_MSG_H
 #define SQUID_SNMP_MSG_H
 
+#include "config.h"
+
 /**********************************************************************
  *
  *           Copyright 1997 by Carnegie Mellon University
@@ -37,10 +39,8 @@
 extern "C" {
 #endif
 
-    u_char *snmp_msg_Encode(u_char *, int *, u_char *,
-	int, int, struct snmp_pdu *);
-    u_char *snmp_msg_Decode(u_char *, int *, u_char *,
-	int *, int *, struct snmp_pdu *);
+u_char *snmp_msg_Encode(u_char *, int *, u_char *, int, int, struct snmp_pdu *);
+u_char *snmp_msg_Decode(u_char *, int *, u_char *, int *, int *, struct snmp_pdu *);
 
 #ifdef __cplusplus
 }
@@ -1,6 +1,15 @@
 #ifndef SQUID_SNMP_PDU_H
 #define SQUID_SNMP_PDU_H
 
+#include "config.h"
+/* required for oid typedef */
+#include "asn1.h"
+
+#if HAVE_NETINET_IN_H
+/* required for sockaddr_in definition */
+#include <netinet/in.h>
+#endif
+
 /**********************************************************************
  *
  *           Copyright 1997 by Carnegie Mellon University
@@ -2,6 +2,8 @@
 #ifndef SQUID_SNMP_SESSION_H
 #define SQUID_SNMP_SESSION_H
 
+#include "config.h"
+
 /**********************************************************************
  *
  *           Copyright 1997 by Carnegie Mellon University
@@ -31,7 +33,6 @@
 struct snmp_session {
     int Version;		/* SNMP Version for this session */
 
-
     u_char *community;		/* community for outgoing requests. */
     int community_len;		/* Length of community name. */
     int retries;		/* Number of retries before timeout. */
@@ -1,10 +1,11 @@
 /*
  * $Id: snmp_util.h,v 1.10 2003/01/23 00:36:48 robertc Exp $
  */
-
 #ifndef SQUID_SNMP_UTIL_H
 #define SQUID_SNMP_UTIL_H
 
+#include "config.h"
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -29,6 +29,8 @@
  * 
  **********************************************************************/
 
+#include "asn1.h"
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -31,6 +31,12 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
+#ifndef _INC_SQUID_MSWIN_H
+#define _INC_SQUID_MSWIN_H
+
+#include "config.h"
+
+#ifdef _SQUID_WIN32_
 
 #define ACL WindowsACL
 #if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
@@ -738,3 +744,8 @@ struct rusage {
 };
 
 #undef ACL
+
+
+#endif /* _SQUID_WIN32_ */
+
+#endif /* _INC_SQUID_MSWIN_H */
@@ -30,6 +30,12 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
+#ifndef _INC_SQUID_WINDOWS_H
+#define _INC_SQUID_WINDOWS_H
+
+#include "config.h"
+
+#ifdef _SQUID_WIN32_
 
 #ifndef ACL
 #define ACL WindowsACL
@@ -40,3 +46,7 @@
 #undef ACL
 #undef _MSWIN_ACL_WAS_NOT_DEFINED
 #endif
+
+#endif /* _SQUID_WIN32_ */
+
+#endif /* _INC_SQUID_WINDOWS_H */
@@ -1,4 +1,3 @@
-
 /*
  * $Id: sspwin32.h,v 1.2 2006/09/09 15:29:59 serassio Exp $
  *
@@ -32,9 +31,11 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef _LIBSSPWIN32_H_
 #define _LIBSSPWIN32_H_
+
+#ifdef _SQUID_WIN32_
+
 #define SECURITY_WIN32
 #define NTLM_PACKAGE_NAME "NTLM"
 #define NEGOTIATE_PACKAGE_NAME "Negotiate"
@@ -74,4 +75,7 @@ const char * WINAPI SSP_MakeNegotiateBlob(PVOID, int, PBOOL, int *, char *);
 
 extern BOOL Use_Unicode;
 extern BOOL NTLM_LocalCall;
+
+#endif /* _SQUID_WIN32_ */
+
 #endif /* LIBSSPWIN32_H_ */
@@ -16,38 +16,43 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
  * USA.
  */
-
 #ifndef GNULIB_STRSEP_H_
 #define GNULIB_STRSEP_H_
 
+#include "config.h"
+
 #if HAVE_STRSEP
 
 /*
  * Get strsep() declaration.
  */
+#if HAVE_STRING_H
 #include <string.h>
+#endif
 
 #else
 
-/* Searches the next delimiter (char listed in DELIM) starting at *STRINGP.
-   If one is found, it is overwritten with a NUL, and *STRINGP is advanced
+/**
+\par
+   Searches the next delimiter (char listed in DELIM) starting at *STRINGP.
+   If one is found, it is overwritten with a NULL, and *STRINGP is advanced
    to point to the next char after it.  Otherwise, *STRINGP is set to NULL.
    If *STRINGP was already NULL, nothing happens.
    Returns the old value of *STRINGP.
-
+\par
    This is a variant of strtok() that is multithread-safe and supports
    empty fields.
 
-   Caveat: It modifies the original string.
-   Caveat: These functions cannot be used on constant strings.
-   Caveat: The identity of the delimiting character is lost.
-   Caveat: It doesn't work with multibyte strings unless all of the delimiter
-           characters are ASCII characters < 0x30.
+\note   Caveat: It modifies the original string.
+\note   Caveat: These functions cannot be used on constant strings.
+\note   Caveat: The identity of the delimiting character is lost.
+\note   Caveat: It doesn't work with multibyte strings unless all of the delimiter
+                characters are ASCII characters < 0x30.
 
-   See also strtok_r().  */
-
-SQUIDCEXTERN char *strsep (char **stringp, const char *delim);
+   See also strtok_r().
+ */
+SQUIDCEXTERN char *strsep(char **stringp, const char *delim);
 
-#endif
+#endif /* HAVE_STRSEP */
 
 #endif /* GNULIB_STRSEP_H_ */
@@ -1,19 +1,31 @@
+/*
+ * $Id$
+ */
+#ifndef _SQUIDINC_STRTOLL_H
+#define _SQUIDINC_STRTOLL_H
+
+#include "config.h"
+
 #if HAVE_STRTOLL
 
 /*
  * Get strtoll() declaration.
  */
+#if HAVE_STDLIB_H
 #include <stdlib.h>
+#endif
 
 #else
 
-/*
+/**
+ \par
  * Convert a string to a int64 integer.
- *
+ \par
  * Ignores `locale' stuff.  Assumes that the upper and lower case
  * alphabets and digits are each contiguous.
  */
+SQUIDCEXTERN int64_t strtoll(const char *nptr, char **endptr, int base);
 
-SQUIDCEXTERN int64_t strtoll (const char *nptr, char **endptr, int base);
+#endif /* !HAVE_STRTOLL */
 
-#endif
+#endif /* _SQUIDINC_STRTOLL_H */
@@ -49,15 +49,10 @@
 #include <arpa/inet.h>
 #endif
 
-#if !defined(SQUIDHOSTNAMELEN)
-#define SQUIDHOSTNAMELEN 256
-#endif
-
 #if defined(_SQUID_FREEBSD_)
 #define _etext etext
 #endif
 
-SQUIDCEXTERN const char *getfullhostname(void);
 SQUIDCEXTERN const char *mkhttpdlogtime(const time_t *);
 SQUIDCEXTERN const char *mkrfc1123(time_t);
 SQUIDCEXTERN char *uudecode(const char *);
@@ -1 +1,11 @@
+/*
+ * $Id$
+ */
+#ifndef _INC_XUSLEEP_H
+#define _INC_XUSLEEP_H
+
+#include "config.h"
+
 SQUIDCEXTERN int xusleep(unsigned int);
+
+#endif /* _INC_XUSLEEP_H */
@@ -96,7 +96,14 @@ INCLUDES	= -I$(top_builddir)/include -I$(top_srcdir)/include @SQUID_CPPUNIT_INC@
 ##FIXME - set these in configure.in and reuse
 
 TESTS=$(check_PROGRAMS)
-check_PROGRAMS=tests/testAll
+check_PROGRAMS= \
+	testHeaders \
+	tests/testAll
+
+## Special Universal .h dependency test script
+## aborts if error encountered
+testHeaders: $(top_srcdir)/include/*.h
+	$(top_srcdir)/test-suite/testheaders.sh "$(CXXCOMPILE)" "$(top_srcdir)/include" || exit 1
 
 tests_testAll_SOURCES= \
 	tests/testArray.h \
@@ -114,3 +121,4 @@ tests_testAll_SOURCES= \
 tests_testAll_LDADD= @SQUID_CPPUNIT_LA@ @SQUID_CPPUNIT_LIBS@
 
 tests_testAll_LDFLAGS = $(LIBADD_DL)
+
@@ -1,4 +1,3 @@
-
 /*
  * $Id: getfullhostname.c,v 1.20 2003/01/23 00:37:01 robertc Exp $
  *
@@ -32,9 +31,9 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
+#include "getfullhostname.h"
 
-#include "config.h"
-
+#if 0 /* we SHOULD NOT need ALL these here. */
 #if HAVE_LIBC_H
 #include <libc.h>
 #endif
@@ -62,30 +61,43 @@
 #if HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
+
+#endif // 0
+
+
+#if HAVE_UNISTD_H
+/* for gethostname() function */
+#include <unistd.h>
+#endif
 #if HAVE_NETDB_H && !defined(_SQUID_NETDB_H_)	/* protect on NEXTSTEP */
 #define _SQUID_NETDB_H_
+/* for gethostbyname() */
 #include <netdb.h>
 #endif
-#if HAVE_UNISTD_H
-#include <unistd.h>
-#endif
 
+/* for RFC 2181 constants */
+#include "rfc2181.h"
+
+/* for xstrncpy() - may need breakign out of there. */
 #include "util.h"
 
-/*
- *  getfullhostname() - Returns the fully qualified name of the current 
- *  host, or NULL on error.  Pointer is only valid until the next call
- *  to the gethost*() functions.
+/**
+ \retval NULL  An error occured.
+ \retval *    The fully qualified name (FQDN) of the current host.
+ *            Pointer is only valid until the next call to the gethost*() functions.
+ *
+ \todo Make this a squid String result so the duration limit is flexible.
  */
 const char *
 getfullhostname(void)
 {
     const struct hostent *hp = NULL;
-    static char buf[SQUIDHOSTNAMELEN + 1];
+    static char buf[RFC2181_MAXHOSTNAMELEN + 1];
 
-    if (gethostname(buf, SQUIDHOSTNAMELEN) < 0)
+    if (gethostname(buf, RFC2181_MAXHOSTNAMELEN) < 0)
 	return NULL;
+    /** \todo convert this to a xgetaddrinfo() call */
     if ((hp = gethostbyname(buf)) != NULL)
-	xstrncpy(buf, hp->h_name, SQUIDHOSTNAMELEN);
+	xstrncpy(buf, hp->h_name, RFC2181_MAXHOSTNAMELEN);
     return buf;
 }
@@ -64,10 +64,10 @@ SQUIDCEXTERN int aclIsProxyAuth(const char *name);
 SQUIDCEXTERN err_type aclGetDenyInfoPage(acl_deny_info_list ** head, const char *name, int redirect_allowed);
 
 /// \ingroup ACLAPI
-SQUIDCEXTERN void aclParseDenyInfoLine(struct _acl_deny_info_list **);
+SQUIDCEXTERN void aclParseDenyInfoLine(struct acl_deny_info_list **);
 
 /// \ingroup ACLAPI
-SQUIDCEXTERN void aclDestroyDenyInfoList(struct _acl_deny_info_list **);
+SQUIDCEXTERN void aclDestroyDenyInfoList(struct acl_deny_info_list **);
 /// \ingroup ACLAPI
 SQUIDCEXTERN wordlist *aclDumpGeneric(const ACL *);
 /// \ingroup ACLAPI
@@ -31,10 +31,11 @@
  *
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
-
 #ifndef SQUID_ACLDATA_H
 #define SQUID_ACLDATA_H
 
+class wordlist;
+
 /// \ingroup ACLAPI
 template <class M>
 class ACLData
@@ -31,11 +31,20 @@
  *
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
-
 #ifndef SQUID_ACLHTTPHEADERDATA_H
 #define SQUID_ACLHTTPHEADERDATA_H
 
+class HttpHeader;
+class wordlist;
+
+/* becaue we inherit from it */
 #include "ACLData.h"
+/* for String field */
+#include "SquidString.h"
+/* for http_hdr_type field */
+#include "HttpHeader.h"
+/* because weuse its MEMPROXY_CLASS() macros */
+#include "MemPool.h"
 
 /// \ingroup ACLAPI
 class ACLHTTPHeaderData : public ACLData<HttpHeader*>
@@ -53,11 +62,11 @@ class ACLHTTPHeaderData : public ACLData<HttpHeader*>
     virtual ACLData<HttpHeader*> *clone() const;
 
 private:
-    http_hdr_type hdrId; // set if header is known
-    String hdrName; // always set
+    http_hdr_type hdrId;                /**< set if header is known */
+    String hdrName;                     /**< always set */
     ACLData<char const *> * regex_rule;
 };
 
-MEMPROXY_CLASS_INLINE(ACLHTTPHeaderData)          /**DOCS_NOSEMI*/
+MEMPROXY_CLASS_INLINE(ACLHTTPHeaderData);
 
 #endif /* SQUID_ACLHTTPHEADERDATA_H */
@@ -57,16 +57,16 @@ class acl_ip_data
 
     IPAddress addr2;
 
-    IPAddress mask; /* This should perhapse be stored as a CIDR range now instead of a full IP mask. */
+    IPAddress mask; /**< \todo This should perhapse be stored as a CIDR range now instead of a full IP mask. */
 
-    acl_ip_data *next;		/* used for parsing, not for storing */
+    acl_ip_data *next;		/**< used for parsing, not for storing */
 
 private:
 
     static bool DecodeMask(const char *asc, IPAddress &mask, int string_format_type);
 };
 
-MEMPROXY_CLASS_INLINE(acl_ip_data)		/**DOCS_NOSEMI*/
+MEMPROXY_CLASS_INLINE(acl_ip_data);
 
 /// \ingroup ACLAPI
 class ACLIP : public ACL
@@ -35,9 +35,7 @@
 #ifndef SQUID_ACLIDENT_H
 #define SQUID_ACLIDENT_H
 
-#include "ACL.h"
 #include "ACLChecklist.h"
-#include "ACLData.h"
 
 /// \ingroup ACLAPI
 class IdentLookup : public ACLChecklist::AsyncState
@@ -52,6 +50,10 @@ class IdentLookup : public ACLChecklist::AsyncState
     static void LookupDone(const char *ident, void *data);
 };
 
+
+#include "ACL.h"
+#include "ACLData.h"
+
 /// \ingroup ACLAPI
 class ACLIdent : public ACL
 {
@@ -82,6 +84,6 @@ class ACLIdent : public ACL
     char const *type_;
 };
 
-MEMPROXY_CLASS_INLINE(ACLIdent)          /**DOCS_NOSEMI*/
+MEMPROXY_CLASS_INLINE(ACLIdent);
 
 #endif /* SQUID_ACLIDENT_H */
@@ -31,10 +31,14 @@
  *
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
-
 #ifndef SQUID_ACLREGEXDATA_H
 #define SQUID_ACLREGEXDATA_H
+
 #include "ACLData.h"
+#include "MemPool.h"
+
+/** \todo CLEANUP: break out relist, we don't need the rest. */
+#include "structs.h"
 
 class ACLRegexData : public ACLData<char const *>
 {
@@ -53,6 +57,6 @@ class ACLRegexData : public ACLData<char const *>
     relist *data;
 };
 
-MEMPROXY_CLASS_INLINE(ACLRegexData)          /**DOCS_NOSEMI*/
+MEMPROXY_CLASS_INLINE(ACLRegexData);
 
 #endif /* SQUID_ACLREGEXDATA_H */
@@ -1,4 +1,3 @@
-
 /*
  * $Id: ACLReplyHeaderStrategy.h,v 1.9 2006/05/06 22:13:18 wessels Exp $
  *
@@ -32,17 +31,18 @@
  *
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
-
 #ifndef SQUID_ACLREPLYHEADERSTRATEGY_H
 #define SQUID_ACLREPLYHEADERSTRATEGY_H
+
+class ACLChecklist;
+
 #include "ACL.h"
 #include "ACLData.h"
 #include "ACLStrategy.h"
 #include "ACLChecklist.h"
 #include "HttpReply.h"
 
 template <http_hdr_type header>
-
 class ACLReplyHeaderStrategy : public ACLStrategy<char const *>
 {
 
@@ -1,4 +1,3 @@
-
 /*
  * $Id: ACLReplyMIMEType.h,v 1.8 2006/05/06 22:13:18 wessels Exp $
  *
@@ -32,15 +31,11 @@
  *
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
-
 #ifndef SQUID_ACLREPLYMIMETYPE_H
 #define SQUID_ACLREPLYMIMETYPE_H
+
 #include "ACL.h"
-#include "ACLData.h"
-#include "ACLReplyHeaderStrategy.h"
 #include "ACLStrategised.h"
-#include "ACLChecklist.h"
-#include "HttpReply.h"
 
 class ACLReplyMIMEType
 {
@@ -52,9 +47,13 @@ class ACLReplyMIMEType
 
 /* partial specialisation */
 
+#include "ACLData.h"
+#include "ACLReplyHeaderStrategy.h"
+#include "ACLChecklist.h"
+
 template <>
-int
-ACLReplyHeaderStrategy<HDR_CONTENT_TYPE>::match (ACLData<char const *> * &data, ACLChecklist *checklist)
+inline int
+ACLReplyHeaderStrategy<HDR_CONTENT_TYPE>::match(ACLData<char const *> * &data, ACLChecklist *checklist)
 {
     char const *theHeader = checklist->reply->header.getStr(HDR_CONTENT_TYPE);
 
@@ -1,4 +1,3 @@
-
 /*
  * $Id: ACLRequestMIMEType.h,v 1.4 2006/05/06 22:13:18 wessels Exp $
  *
@@ -32,14 +31,11 @@
  *
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
-
 #ifndef SQUID_ACLREQUESTMIMETYPE_H
 #define SQUID_ACLREQUESTMIMETYPE_H
+
 #include "ACL.h"
-#include "ACLData.h"
-#include "ACLRequestHeaderStrategy.h"
 #include "ACLStrategised.h"
-#include "ACLChecklist.h"
 
 class ACLRequestMIMEType
 {
@@ -51,8 +47,12 @@ class ACLRequestMIMEType
 
 /* partial specialisation */
 
+#include "ACLData.h"
+#include "ACLRequestHeaderStrategy.h"
+#include "ACLChecklist.h"
+
 template <>
-int
+inline int
 ACLRequestHeaderStrategy<HDR_CONTENT_TYPE>::match (ACLData<char const *> * &data, ACLChecklist *checklist)
 {
     char const *theHeader = checklist->request->header.getStr(HDR_CONTENT_TYPE);
@@ -32,10 +32,15 @@
  *
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
-
 #ifndef SQUID_ACLSOURCEASN_H
 #define SQUID_ACLSOURCEASN_H
+
+#if 0
 #include "ACLASN.h"
+#endif
+
+class ACLChecklist;
+
 #include "ACLStrategy.h"
 #include "IPAddress.h"
 
@@ -1,4 +1,3 @@
-
 /*
  * $Id: AccessLogEntry.h,v 1.9 2008/02/26 00:15:48 rousskov Exp $
  *
@@ -31,18 +30,19 @@
  *
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
-
 #ifndef SQUID_HTTPACCESSLOGENTRY_H
 #define SQUID_HTTPACCESSLOGENTRY_H
 
 #include "HttpVersion.h"
 #include "HttpRequestMethod.h"
 #include "HierarchyLogEntry.h"
 #include "IPAddress.h"
+#include "HttpRequestMethod.h"
 
 /* forward decls */
-
 class CacheManager;
+class HttpReply;
+class HttpRequest;
 
 class AccessLogEntry
 {
@@ -127,6 +127,8 @@ class AccessLogEntry
 
     headers;
 
+    // Why is this a sub-class and not a set of real "private:" fields?
+    // It looks like its duplicating HTTPRequestMethod anyway!
     class Private
     {
 
@@ -142,6 +144,10 @@ class AccessLogEntry
     HttpRequest *request;
 };
 
+class ACLChecklist;
+class StoreEntry;
+class logformat_token;
+
 /* Should be in 'AccessLog.h' as the driver */
 extern void accessLogLog(AccessLogEntry *, ACLChecklist * checklist);
 extern void accessLogRotate(void);
@@ -1,4 +1,3 @@
-
 /*
  * $Id: AuthConfig.h,v 1.5 2008/02/26 21:49:34 amosjeffries Exp $
  *
@@ -30,24 +29,30 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_AUTHCONFIG_H
 #define SQUID_AUTHCONFIG_H
 
-/*
+class AuthUserRequest;
+class StoreEntry;
+class HttpReply;
+class HttpRequest;
+class CacheManager;
+
+/* for http_hdr_type parameters-by-value */
+#include "HttpHeader.h"
+
+
+/**
+ \ingroup AuthAPI
+ \par
  * I am the configuration for an auth scheme.
  * Currently each scheme has only one instance of me,
  * but this may change.
- */
-
-/* This class is treated like a ref counted class.
+ \par
+ * This class is treated like a ref counted class.
  * If the children ever stop being singletons, implement the
  * ref counting...
  */
-
-class AuthUserRequest;
-
-/// \ingroup AuthAPI
 class AuthConfig
 {
 
@@ -157,7 +157,7 @@ AuthUser::CachedACLsReset()
      * This must complete all at once, because we are ensuring correctness.
      */
     AuthUserHashPointer *usernamehash;
-    auth_user_t *auth_user;
+    AuthUser *auth_user;
     char const *username = NULL;
     debugs(29, 3, "AuthUser::CachedACLsReset: Flushing the ACL caches for all users.");
     hash_first(proxy_auth_username_cache);
@@ -182,7 +182,7 @@ AuthUser::cacheCleanup(void *datanotused)
      * entries at a time. Lets see how it flys first.
      */
     AuthUserHashPointer *usernamehash;
-    auth_user_t *auth_user;
+    AuthUser *auth_user;
     char const *username = NULL;
     debugs(29, 3, "AuthUser::cacheCleanup: Cleaning the user cache now");
     debugs(29, 3, "AuthUser::cacheCleanup: Current time: " << current_time.tv_sec);
@@ -1,4 +1,3 @@
-
 /*
  * $Id: AuthUser.cci,v 1.3 2007/05/09 15:26:12 wessels Exp $
  *
@@ -34,6 +33,11 @@
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
 
+/* for assert() */
+#include "assert.h"
+/* for xstrdup() */
+#include "util.h"
+
 char const *
 AuthUser::username () const
 {
@@ -1,4 +1,3 @@
-
 /*
  * $Id: AuthUser.h,v 1.7 2008/02/26 21:49:34 amosjeffries Exp $
  *
@@ -35,9 +34,15 @@
 #ifndef SQUID_AUTHUSER_H
 #define SQUID_AUTHUSER_H
 
-#include "IPAddress.h"
-
 class AuthUserRequest;
+class AuthConfig;
+class AuthUserHashPointer;
+
+/* for auth_type_t */
+#include "enums.h"
+
+#include "IPAddress.h"
+#include "dlink.h"
 
 /**
  *  \ingroup AuthAPI
@@ -60,7 +65,7 @@ class AuthUser
     /** the config for this user */
     AuthConfig *config;
     /** we only have one username associated with a given auth_user struct */
-    auth_user_hash_pointer *usernamehash;
+    AuthUserHashPointer *usernamehash;
     /** we may have many proxy-authenticate strings that decode to the same user */
     dlink_list proxy_auth_list;
     dlink_list proxy_match_cache;
@@ -72,21 +77,19 @@ class AuthUser
      * but how many requests will a single username have in parallel? */
     dlink_list requests;
 
-    static void cacheInit ();
+    static void cacheInit();
     static void CachedACLsReset();
 
     void absorb(AuthUser *from);
-    virtual ~AuthUser ();
+    virtual ~AuthUser();
     _SQUID_INLINE_ char const *username() const;
     _SQUID_INLINE_ void username(char const *);
     void clearIp();
     void removeIp(IPAddress);
     void addIp(IPAddress);
     _SQUID_INLINE_ void addRequest(AuthUserRequest *);
 
-    void lock()
-
-        ;
+    void lock();
     void unlock();
 
     void addToNameCache();
@@ -202,7 +202,7 @@ AuthUserRequest::denyMessage(char const * const default_message)
 static void
 authenticateAuthUserRequestSetIp(AuthUserRequest * auth_user_request, IPAddress &ipaddr)
 {
-    auth_user_t *auth_user = auth_user_request->user();
+    AuthUser *auth_user = auth_user_request->user();
 
     if (!auth_user)
         return;
@@ -213,7 +213,7 @@ authenticateAuthUserRequestSetIp(AuthUserRequest * auth_user_request, IPAddress
 void
 authenticateAuthUserRequestRemoveIp(AuthUserRequest * auth_user_request, IPAddress const &ipaddr)
 {
-    auth_user_t *auth_user = auth_user_request->user();
+    AuthUser *auth_user = auth_user_request->user();
 
     if (!auth_user)
         return;
@@ -328,7 +328,6 @@ authTryGetUser (AuthUserRequest **auth_user_request, ConnStateData * conn, HttpR
  * Caller is responsible for locking and unlocking their *auth_user_request!
  */
 auth_acl_t
-
 AuthUserRequest::authenticate(AuthUserRequest ** auth_user_request, http_hdr_type headertype, HttpRequest * request, ConnStateData * conn, IPAddress &src_addr)
 {
     const char *proxy_auth;
@@ -66,7 +66,7 @@ class AuthUserRequest
      * it has request specific data, and links to user specific data
      * the user
      */
-    auth_user_t *_auth_user;
+    AuthUser *_auth_user;
 
     /**
      *  Used by squid to determine what the next step in performing authentication for a given scheme is.
@@ -107,29 +107,29 @@ class AuthUserRequest
 
     virtual const AuthUser *user() const {return _auth_user;}
 
-    virtual void user (AuthUser *aUser) {_auth_user=aUser;}
+    virtual void user(AuthUser *aUser) {_auth_user=aUser;}
 
     static auth_acl_t tryToAuthenticateAndSetAuthUser(AuthUserRequest **, http_hdr_type, HttpRequest *, ConnStateData *, IPAddress &);
     static void addReplyAuthHeader(HttpReply * rep, AuthUserRequest * auth_user_request, HttpRequest * request, int accelerated, int internal);
 
     AuthUserRequest();
 
     virtual ~AuthUserRequest();
-    void *operator new (size_t byteCount);
-    void operator delete (void *address);
+    void *operator new(size_t byteCount);
+    void operator delete(void *address);
 
-    void start ( RH * handler, void *data);
-    char const * denyMessage (char const * const default_message = NULL);
+    void start( RH * handler, void *data);
+    char const * denyMessage(char const * const default_message = NULL);
 
     /** Possibly overrideable in future */
-    void setDenyMessage (char const *);
+    void setDenyMessage(char const *);
 
     /** Possibly overrideable in future */
-    char const * getDenyMessage ();
+    char const * getDenyMessage();
 
     size_t refCount() const;
-    void _lock ();		// please use AUTHUSERREQUESTLOCK()
-    void _unlock ();		// please use AUTHUSERREQUESTUNLOCK()
+    void _lock();		// please use AUTHUSERREQUESTLOCK()
+    void _unlock();		// please use AUTHUSERREQUESTUNLOCK()
 
     /**
      * Squid does not make assumptions about where the username is stored.
@@ -1,4 +1,3 @@
-
 /*
  * $Id: ChunkedCodingParser.h,v 1.1 2007/12/26 22:33:32 hno Exp $
  * 
@@ -29,18 +28,27 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_CHUNKEDCODINGPARSER_H
 #define SQUID_CHUNKEDCODINGPARSER_H
 
-#include "RefCount.h"
-
-// ChunkedCodingParser is an incremental parser for chunked transfer coding
-// used by HTTP and ICAP. The parser shovels content bytes from the raw
-// input buffer into the content output buffer, both caller-supplied.
-// Ignores chunk extensions except for ICAP's ieof.
-// Has a trailer-handling placeholder.
+class MemBuf;
 
+#if 0
+#include "RefCount.h"
+#endif
+
+/* for size_t */
+#include "config.h"
+
+/**
+ \ingroup ChunkEncodingAPI Chunked Encoding API
+ \par
+ * ChunkedCodingParser is an incremental parser for chunked transfer coding
+ * used by HTTP and ICAP. The parser shovels content bytes from the raw
+ * input buffer into the content output buffer, both caller-supplied.
+ * Ignores chunk extensions except for ICAP's ieof.
+ * Has a trailer-handling placeholder.
+ */
 class ChunkedCodingParser
 {
 
@@ -49,8 +57,12 @@ class ChunkedCodingParser
 
     void reset();
 
-    // true = complete success; false == needs more data
-    bool parse(MemBuf *rawData, MemBuf *parsedContent); // throws on error
+    /**
+     \retval true    complete success
+     \retval false   needs more data
+     \throws ??      error.
+     */
+    bool parse(MemBuf *rawData, MemBuf *parsedContent);
 
     bool needsMoreData() const;
     bool needsMoreSpace() const;
@@ -1,3 +1,15 @@
+#ifndef SQUID_CLIENTREQUESTCONTEXT_H
+#define SQUID_CLIENTREQUESTCONTEXT_H
+
+class ACLChecklist;
+class ClientHttpRequest;
+
+#include "config.h"
+/* for RefCountable */
+#include "RefCount.h"
+/* for CBDATA_CLASS() */
+#include "cbdata.h"
+
 #if ICAP_CLIENT
 #include "ICAP/ICAPServiceRep.h"
 #endif
@@ -44,3 +56,4 @@ class ClientRequestContext : public RefCountable
     CBDATA_CLASS(ClientRequestContext);
 };
 
+#endif /* SQUID_CLIENTREQUESTCONTEXT_H */
@@ -29,12 +29,15 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_CONFIGOPTION_H
 #define SQUID_CONFIGOPTION_H
 
+class StoreEntry;
+
+/* for Vector<> */
 #include "Array.h"
 
+
 /* cache option parsers */
 
 class ConfigOption
@@ -58,12 +61,11 @@ class ConfigOptionVector : public ConfigOption
 };
 
 template <class C>
-
 class ConfigOptionAdapter : public ConfigOption
 {
 
 public:
-    ConfigOptionAdapter (C& theObject, bool (C::*parseFP)(char const *option, const char *value, int reconfiguring), void (C::*dumpFP) (StoreEntry * e) const) : object(theObject), parser (parseFP), dumper(dumpFP) {}
+    ConfigOptionAdapter(C& theObject, bool (C::*parseFP)(char const *option, const char *value, int reconfiguring), void (C::*dumpFP) (StoreEntry * e) const) : object(theObject), parser (parseFP), dumper(dumpFP) {}
 
     bool parse(char const *option, const char *value, int reconfiguring)
     {
@@ -73,7 +75,7 @@ class ConfigOptionAdapter : public ConfigOption
         return false;
     }
 
-    void dump (StoreEntry * e) const
+    void dump(StoreEntry * e) const
     {
         if (dumper)
             (object.*dumper) (e);
@@ -31,9 +31,8 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
-#ifndef SQUID_DEBUG
-#define SQUID_DEBUG
+#ifndef SQUID_DEBUG_H
+#define SQUID_DEBUG_H
 
 #include <iostream>
 #undef assert
@@ -52,6 +51,9 @@
 #define assert(EX)  ((EX)?((void)0):xassert("EX", __FILE__, __LINE__))
 #endif
 
+/* defined debug section limits */
+#define MAX_DEBUG_SECTIONS 100
+
 /* defined names for Debug Levels */
 #define DBG_CRITICAL	0	/**< critical messages always shown when they occur */
 #define DBG_IMPORTANT	1	/**< important messages always shown when their section is being checked */
@@ -97,4 +99,4 @@ inline std::ostream& operator <<(std::ostream &os, const uint8_t d) {
     return (os << (int)d);
 }
 
-#endif /* SQUID_DEBUG */
+#endif /* SQUID_DEBUG_H */
@@ -31,11 +31,12 @@
  *
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
-
 #ifndef SQUID_DELAYBUCKET_H
 #define SQUID_DELAYBUCKET_H
 
 class DelaySpec;
+class StoreEntry;
+
 /* don't use remote storage for these */
 
 /// \ingroup DelayPoolsAPI
@@ -33,10 +33,10 @@
  *
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
-
 #ifndef SQUID_DELAYCONFIG_H
 #define SQUID_DELAYCONFIG_H
 
+class StoreEntry;
 class ConfigParser;
 
 /// \ingroup DelayPoolsAPI
@@ -31,7 +31,6 @@
  *
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
-
 #ifndef SQUID_DELAYPOOLS_H
 #define SQUID_DELAYPOOLS_H
 
@@ -40,11 +39,6 @@
  \ingroup Components
  */
 
-/* forward decls */
-class CacheManager;
-
-#include "Array.h"
-
 /// \ingroup DelayPoolsAPI
 class Updateable
 {
@@ -55,7 +49,14 @@ class Updateable
     virtual void update(int) = 0;
 };
 
+/* forward decls */
+class CacheManager;
 class DelayPool;
+class Updateable;
+class StoreEntry;
+
+/* for Vector<> */
+#include "Array.h"
 
 /// \ingroup DelayPoolsAPI
 class DelayPools
@@ -29,18 +29,19 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_DELAYSPEC_H
 #define SQUID_DELAYSPEC_H
 
+class StoreEntry;
+
 /// \ingroup DelyPoolsAPI
 class DelaySpec
 {
 
 public:
     DelaySpec();
-    void stats (StoreEntry * sentry, char const *) const;
-    void dump (StoreEntry *) const;
+    void stats(StoreEntry * sentry, char const *) const;
+    void dump(StoreEntry *) const;
     void parse();
     int restore_bps;
     int max_bytes;
@@ -29,14 +29,20 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_ESICUSTOMPARSER_H
 #define SQUID_ESICUSTOMPARSER_H
 
+class Trie;
+
+/* inherits from */
 #include "ESIParser.h"
 
-class Trie;
+/* for String variables */
+#include "SquidString.h"
 
+/**
+ \ingroup ESIAPI
+ */
 class ESICustomParser : public ESIParser
 {
 
@@ -29,32 +29,41 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_ESIPARSER_H
 #define SQUID_ESIPARSER_H
 
+/* for size_t */
+#include "config.h"
+
 class ESIParserClient
 {
-
 public:
     virtual void start(const char *el, const char **attr, size_t attrCount) = 0;
     virtual void end(const char *el) = 0;
     virtual void parserDefault (const char *s, int len) =0;
     virtual void parserComment (const char *s) = 0;
     virtual ~ESIParserClient() {};
-
 };
 
+
+/* for RefCountable */
+#include "RefCount.h"
+
 class ESIParser : public RefCountable
 {
-
 public:
     typedef RefCount<ESIParser> Pointer;
+
     static void registerParser(const char *name, Pointer (*new_func)(ESIParserClient *aClient));
     static Pointer NewParser(ESIParserClient *aClient);
     static char *Type;
-    /* true on success */
+
+    /**
+     \retval true      on success
+     \retval false     on what?
+     */
     virtual bool parse(char const *dataToParse, size_t const lengthOfData, bool const endOfStream) = 0;
+
     virtual long int lineNumber() const =0;
     virtual char const * errorString() const =0;
 
@@ -95,4 +104,6 @@ class ESIParser::Register
 #define ESI_PARSER_TYPE \
     static ESIParser::Pointer NewParser(ESIParserClient *aClient); \
     static ESIParser::Register thisParser
+
+
 #endif /* SQUID_ESIPARSER_H */
@@ -1,4 +1,3 @@
-
 /*
  * $Id: ExternalACL.h,v 1.10 2008/02/26 21:49:34 amosjeffries Exp $
  *
@@ -32,10 +31,9 @@
  *
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
-
 #ifndef SQUID_EXTERNALACL_H
 #define SQUID_EXTERNALACL_H
-#include "ACL.h"
+
 #include "ACLChecklist.h"
 
 class external_acl;
@@ -52,8 +50,11 @@ class ExternalACLLookup : public ACLChecklist::AsyncState
     static void LookupDone(void *data, void *result);
 };
 
+/** \todo CLEANUP: kill this typedef. */
 typedef struct _external_acl_data external_acl_data;
 
+#include "ACL.h"
+
 class ACLExternal : public ACL
 {
 
@@ -89,7 +90,7 @@ class ACLExternal : public ACL
     char const *class_;
 };
 
-MEMPROXY_CLASS_INLINE(ACLExternal)		/**DOCS_NOSEMI*/
+MEMPROXY_CLASS_INLINE(ACLExternal);
 
 extern void externalAclRegisterWithCacheManager(CacheManager & manager);
 
@@ -1,4 +1,3 @@
-
 /*
  * $Id: Generic.h,v 1.7 2004/12/20 16:30:32 robertc Exp $
  *
@@ -30,12 +29,15 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_GENERIC_H
 #define SQUID_GENERIC_H
 
-template <class _Arg, class _Result>
+/** \todo CLEANUP: checks towrap this header properly */
+#include <ostream>
+
+#include "dlink.h"
 
+template <class _Arg, class _Result>
 struct unary_function
 {
     typedef _Arg argument_type;
@@ -61,7 +63,6 @@ T& for_each(dlink_list const &collection, T& visitor)
 }
 
 template <class S>
-
 class Stack;
 
 template <class E, class T>
@@ -78,7 +79,6 @@ T& for_each(Stack<E> const &collection, T& visitor)
  */
 
 template <class C>
-
 class InstanceToSingletonAdapter : public C
 {
 
@@ -119,7 +119,6 @@ Visitor& for_each(InputIterator from, InputIterator to, Visitor& visitor)
 
 /* generic ostream printer */
 template <class Pointer>
-
 struct PointerPrinter
 {
     PointerPrinter(std::ostream &astream, std::string aDelimiter) : os(astream), delimiter (aDelimiter) {}
@@ -1,4 +1,3 @@
-
 /*
  * $Id: HierarchyLogEntry.h,v 1.1 2003/10/16 21:40:16 robertc Exp $
  *
@@ -35,8 +34,12 @@
 #ifndef SQUID_HTTPHIERARCHYLOGENTRY_H
 #define SQUID_HTTPHIERARCHYLOGENTRY_H
 
+#include "rfc2181.h"
 #include "PingData.h"
 
+/** todo Cleanup: break hier_code type out. We don't need the rest. */
+#include "enums.h"
+
 class HierarchyLogEntry
 {
 
@@ -1,4 +1,3 @@
-
 /*
  * $Id: HttpHdrContRange.h,v 1.4 2007/08/13 17:20:51 hno Exp $
  *
@@ -30,34 +29,37 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_HTTPHDRCONTRANGE_H
 #define SQUID_HTTPHDRCONTRANGE_H
 
-#include "HttpHeaderRange.h"
+class HttpHeader;
 
-/* http content-range header field */
+/* for SQUIDCEXTERN */
+#include "config.h"
 
+/* for HttpHdrRangeSpec */
+#include "HttpHeaderRange.h"
+
+/** HTTP Content-Range: header field */
 class HttpHdrContRange
 {
 
 public:
     HttpHdrRangeSpec spec;
-    int64_t elength;		/* entity length, not content length */
+    int64_t elength;		/**< entity length, not content length */
 };
 
-/* Http Content Range Header Field */
+/** \todo CLEANUP: Move httpHdrContRange* functions into the class methods */
+
 SQUIDCEXTERN HttpHdrContRange *httpHdrContRangeCreate(void);
 SQUIDCEXTERN HttpHdrContRange *httpHdrContRangeParseCreate(const char *crange_spec);
-/* returns true if range is valid; inits HttpHdrContRange */
+/** returns true if range is valid; inits HttpHdrContRange */
 SQUIDCEXTERN int httpHdrContRangeParseInit(HttpHdrContRange * crange, const char *crange_spec);
 SQUIDCEXTERN void httpHdrContRangeDestroy(HttpHdrContRange * crange);
 SQUIDCEXTERN HttpHdrContRange *httpHdrContRangeDup(const HttpHdrContRange * crange);
 SQUIDCEXTERN void httpHdrContRangePackInto(const HttpHdrContRange * crange, Packer * p);
-/* inits with given spec */
+/** inits with given spec */
 SQUIDCEXTERN void httpHdrContRangeSet(HttpHdrContRange *, HttpHdrRangeSpec, int64_t);
-;
 SQUIDCEXTERN void httpHeaderAddContRange(HttpHeader *, HttpHdrRangeSpec, int64_t);
 
-
 #endif /* SQUID_HTTPHDRCONTRANGE_H */
@@ -1,4 +1,3 @@
-
 /*
  * $Id: HttpHdrScTarget.h,v 1.3 2007/05/29 13:31:37 amosjeffries Exp $
  *
@@ -30,17 +29,22 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_HTTPHDRSURROGATECONTROLTARGET_H
 #define SQUID_HTTPHDRSURROGATECONTROLTARGET_H
 
-#include "dlink.h"
+class Packer;
+class StoreEntry;
 
-/* http surogate control header field */
+/* for MEMPROXY_CLASS() macros */
+#include "MemPool.h"
+/* for dlink_node */
+#include "dlink.h"
+/* for String */
+#include "SquidString.h"
 
+/** HTTP Surogate-Control: header field */
 class HttpHdrScTarget
 {
-
 public:
     MEMPROXY_CLASS(HttpHdrScTarget);
     dlink_node node;
@@ -59,9 +63,14 @@ extern void httpHdrScTargetDestroy(HttpHdrScTarget *);
 extern HttpHdrScTarget *httpHdrScTargetDup(const HttpHdrScTarget *);
 extern void httpHdrScTargetPackInto(const HttpHdrScTarget *, Packer *);
 extern void httpHdrScTargetSetMaxAge(HttpHdrScTarget *, int);
-extern void httpHdrScTargetUpdateStats(const HttpHdrScTarget *, StatHist *);
 extern void httpHdrScTargetJoinWith(HttpHdrScTarget *, const HttpHdrScTarget *);
 extern void httpHdrScTargetMergeWith(HttpHdrScTarget *, const HttpHdrScTarget *);
 extern void httpHdrScTargetStatDumper(StoreEntry * sentry, int idx, double val, double size, int count);
 
+/* for StatHist */
+#include "typedefs.h"
+
+extern void httpHdrScTargetUpdateStats(const HttpHdrScTarget *, StatHist *);
+
+
 #endif /* SQUID_HTTPHDRSURROGATECONTROLTARGET_H */
@@ -36,6 +36,7 @@
 /* forward decls */
 
 class CacheManager;
+
 /* because we pass a spec by value */
 #include "HttpHeaderRange.h"
 /* HttpHeader holds a HttpHeaderMask */
@@ -167,8 +168,10 @@ typedef ssize_t HttpHeaderPos;
 
 /* these two are defined in  structs.h */
 
+/// \todo CLEANUP: Kill this.
 typedef struct _TimeOrTag TimeOrTag;
 
+/// \todo CLEANUP: Kill this.
 typedef struct _ETag ETag;
 
 class HttpHeaderEntry
@@ -1,4 +1,3 @@
-
 /*
  * $Id: HttpHeaderMask.h,v 1.1 2006/04/22 13:08:39 robertc Exp $
  *
@@ -30,12 +29,15 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_HTTPHEADERMASK_H
 #define SQUID_HTTPHEADERMASK_H
 
+/* for SQUIDCEXTERN */
+#include "config.h"
+
 /* big mask for http headers */
 typedef char HttpHeaderMask[12];
 
 SQUIDCEXTERN void httpHeaderMaskInit(HttpHeaderMask * mask, int value);
+
 #endif /* SQUID_HTTPHEADERMASK_H */
@@ -72,9 +72,6 @@ enum _method_t {
     METHOD_ENUM_END  // MUST be last, (yuck) this is used as an array-initialization index constant!
 };
 
-/* forward decls */
-typedef struct _SquidConfig SquidConfig;
-
 
 /**
  * This class represents an HTTP Request METHOD
@@ -1,4 +1,3 @@
-
 /*
  * $Id: HttpStatusLine.h,v 1.4 2007/05/29 13:31:38 amosjeffries Exp $
  *
@@ -31,10 +30,19 @@
  *
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
-
 #ifndef SQUID_HTTPSTATUSLINE_H
 #define SQUID_HTTPSTATUSLINE_H
 
+class Packer;
+class String;
+
+/* for SQUIDCEXTERN */
+#include "config.h"
+
+/* for http_status */
+#include "enums.h"
+
+/* for class variables */
 #include "HttpVersion.h"
 
 class HttpStatusLine
@@ -43,7 +51,7 @@ class HttpStatusLine
 public:
     /* public, read only */
     HttpVersion version;
-    const char *reason;		/* points to a _constant_ string (default or supplied), never free()d */
+    const char *reason;		/**< points to a _constant_ string (default or supplied), never free()d */
     http_status status;
 };
 
@@ -409,6 +409,7 @@ libsquid_la_SOURCES = \
 	IPInterception.h \
         ICAP/AsyncJob.cc \
         ICAP/AsyncJob.h \
+	SquidConfig.cc \
         TextException.cc \
         TextException.h
 
@@ -479,6 +480,7 @@ squid_SOURCES = \
 	disk.cc \
 	$(DISKIO_SOURCE) \
 	dlink.h \
+	dlink.cc \
 	$(DNSSOURCE) \
 	enums.h \
 	errorpage.cc \
@@ -816,6 +818,8 @@ ufsdump_SOURCES = \
 	defines.h \
 	$(DELAY_POOL_SOURCE) \
 	disk.cc \
+	dlink.h \
+	dlink.cc \
 	$(DNSSOURCE) \
 	enums.h \
 	errorpage.cc \
@@ -1155,17 +1159,16 @@ TEST_CALL_SOURCES = \
 	event.cc \
 	AsyncCallQueue.cc \
 	AsyncCall.cc
-	
 
-check_PROGRAMS+= \
+
+check_PROGRAMS+= testHeaders \
 	tests/testAuth \
 	tests/testACLMaxUserIP \
 	tests/testBoilerplate \
 	tests/testCacheManager \
 	tests/testDiskIO \
 	tests/testEvent \
 	tests/testEventLoop \
-	tests/testHeaders \
 	tests/test_http_range \
 	tests/testHttpRequest \
 	tests/testICMP \
@@ -1174,6 +1177,15 @@ check_PROGRAMS+= \
 	tests/testURL \
 	@STORE_TESTS@
 
+## Special Universal .h dependency test script
+## aborts if error encountered
+testHeaders: *.h DiskIO/*.h ICAP/*.h
+	../test-suite/testheaders.sh "$(CXXCOMPILE)" "." || exit 1
+	../test-suite/testheaders.sh "$(CXXCOMPILE)" "DiskIO" || exit 1
+	../test-suite/testheaders.sh "$(CXXCOMPILE)" "ICAP" || exit 1
+## src/repl/ has no .h files and its own makefile.
+
+
 ### Template for new Unit Test Program
 ## - add tests/testX to check_PROGRAMS above.
 ## - copy template below and substitue X for class name
@@ -1361,6 +1373,8 @@ tests_testCacheManager_SOURCES = \
 	ConfigParser.cc \
 	$(DELAY_POOL_SOURCE) \
 	disk.cc \
+	dlink.h \
+	dlink.cc \
 	$(DNSSOURCE) \
 	errorpage.cc \
 	$(ESI_SOURCE) \
@@ -1480,6 +1494,7 @@ tests_testDiskIO_SOURCES= \
 	tests/testMain.cc
 tests_testDiskIO_LDADD= \
 	$(SWAP_TEST_LDADD) \
+	libsquid.la \
 	@SSLLIB@
 tests_testDiskIO_LDFLAGS = $(LIBADD_DL)
 tests_testDiskIO_DEPENDENCIES = $(top_builddir)/lib/libmiscutil.a \
@@ -1529,6 +1544,8 @@ tests_testEvent_SOURCES = \
 	ConfigParser.cc \
 	$(DELAY_POOL_SOURCE) \
 	disk.cc \
+	dlink.h \
+	dlink.cc \
 	$(DNSSOURCE) \
 	errorpage.cc \
 	$(ESI_SOURCE) \
@@ -1683,6 +1700,8 @@ tests_testEventLoop_SOURCES = \
 	ConfigParser.cc \
 	$(DELAY_POOL_SOURCE) \
 	disk.cc \
+	dlink.h \
+	dlink.cc \
 	$(DNSSOURCE) \
 	errorpage.cc \
 	$(ESI_SOURCE) \
@@ -1794,43 +1813,6 @@ tests_testEventLoop_DEPENDENCIES =  $(top_builddir)/lib/libmiscutil.a \
 	@SQUID_CPPUNIT_LA@ \
 	@ICAP_LIBS@
 
-## test headers checks that individual headers can be parsed with no dependencies.
-## as such, it needs a new .cc file for each header it parses, so that they
-## can be #included with no baggage. If the binary links, the test passed.
-## We could write a script to pull out the compiler configuration from autoconf,
-## but this is easier to understand and more robust against changes in autoconf.
-## RBC 20060422.
-HEADERS_TO_TEST = \
-	tests/testHeader_ACL.cc \
-	tests/testHeader_AsyncEngine.cc \
-	tests/testHeader_cbdata.cc \
-	tests/testHeader_CompletionDispatcher.cc \
-	tests/testHeader_ConfigParser.cc \
-	tests/testHeader_client_side_request.cc \
-	tests/testHeader_comm.cc \
-	tests/testHeader_dlink.cc \
-	tests/testHeader_errorpage.cc \
-	tests/testHeader_event.cc \
-	tests/testHeader_EventLoop.cc \
-	tests/testHeader_HttpHeader.cc \
-	tests/testHeader_HttpHeaderRange.cc \
-	tests/testHeader_HttpReply.cc \
-	tests/testHeader_HttpRequestMethod.cc \
-	tests/testHeader_RemovalPolicy.cc \
-	tests/testHeader_SquidTime.cc \
-	tests/testHeader_Store.cc \
-	tests/testHeader_StoreEntryStream.cc \
-	tests/testHeader_URL.cc \
-	tests/testHeader_URLScheme.cc \
-	tests/testHeader_wordlist.cc
-tests_testHeaders_SOURCES= tests/testMain.cc $(HEADERS_TO_TEST)
-tests_testHeaders_LDADD= \
-	@SQUID_CPPUNIT_LIBS@ \
-	@SSLLIB@
-tests_testHeaders_LDFLAGS = $(LIBADD_DL)
-tests_testHeaders_DEPENDENCIES = \
-	@SQUID_CPPUNIT_LA@
-
 tests_test_http_range_SOURCES = \
 	tests/test_http_range.cc \
 	access_log.cc \
@@ -1862,6 +1844,8 @@ tests_test_http_range_SOURCES = \
 	debug.cc \
 	$(DELAY_POOL_SOURCE) \
 	disk.cc \
+	dlink.h \
+	dlink.cc \
 	$(DNSSOURCE) \
 	errorpage.cc \
 	$(ESI_SOURCE) \
@@ -2022,6 +2006,8 @@ tests_testHttpRequest_SOURCES = \
 	ConfigParser.cc \
 	$(DELAY_POOL_SOURCE) \
 	disk.cc \
+	dlink.h \
+	dlink.cc \
 	$(DNSSOURCE) \
 	errorpage.cc \
 	$(ESI_SOURCE) \
@@ -2240,6 +2226,7 @@ tests_testString_SOURCES= \
 	time.cc 
 
 tests_testString_LDADD= \
+	libsquid.la \
 	-L../lib -lmiscutil \
 	@REGEXLIB@ \
 	@SQUID_CPPUNIT_LIBS@ \
@@ -2305,6 +2292,7 @@ tests_testUfs_SOURCES= tests/testUfs.cc \
 	tests/testUfs.h \
 	$(SWAP_TEST_SOURCES)
 tests_testUfs_LDADD= \
+	libsquid.la \
 	$(SWAP_TEST_LDADD) \
 	@SSLLIB@
 tests_testUfs_LDFLAGS = $(LIBADD_DL)
@@ -2379,6 +2367,8 @@ tests_testURL_SOURCES = \
 	ConfigParser.cc \
 	$(DELAY_POOL_SOURCE) \
 	disk.cc \
+	dlink.h \
+	dlink.cc \
 	$(DNSSOURCE) \
 	errorpage.cc \
 	$(ESI_SOURCE) \
@@ -31,15 +31,16 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_MEM
 #define SQUID_MEM
 
-/* forward decls */
-
 class CacheManager;
+class StoreEntry;
+class MemPoolStats;
+class MemPoolMeter;
 
-#include <iosfwd>
+/** \todo CLEANUP: protection to wrap this system include */
+#include <ostream>
 
 class Mem
 {
@@ -1,4 +1,3 @@
-
 /*
  * $Id: Packer.h,v 1.2 2006/05/03 14:04:44 robertc Exp $
  *
@@ -30,19 +29,21 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_PACKER_H
 #define SQUID_PACKER_H
 
+/* for SQUIDCEXTERN */
 #include "config.h"
 
 /* see Packer.cc for description */
-
 class Packer;
 
 /* a common objPackInto interface; used by debugObj */
 typedef void (*ObjPackMethod) (void *obj, Packer * p);
 
+#if HAVE_STDIO_H
+#include <stdio.h>
+#endif
 /* append/vprintf's for Packer */
 typedef void (*append_f) (void *, const char *buf, int size);
 #if STDC_HEADERS
@@ -71,5 +72,4 @@ packerPrintf(Packer * p, const char *fmt,...) PRINTF_FORMAT_ARG2;
 SQUIDCEXTERN void packerPrintf();
 #endif
 
-
 #endif /* SQUID_PACKER_H */
@@ -95,24 +95,17 @@ class PeerDigest
     void *operator new (size_t);
     void operator delete(void *);
 
-    struct _peer *peer;         /* pointer back to peer structure, argh */
-    CacheDigest *cd;            /* actual digest structure */
-    String host;                /* copy of peer->host */
-    const char *req_result;     /* text status of the last request */
+    struct peer *peer;          /**< pointer back to peer structure, argh */
+    CacheDigest *cd;            /**< actual digest structure */
+    String host;                /**< copy of peer->host */
+    const char *req_result;     /**< text status of the last request */
 
     struct
     {
-
-unsigned int needed:
-        1;	/* there were requests for this digest */
-
-unsigned int usable:
-        1;	/* can be used for lookups */
-
-unsigned int requested:
-        1;	/* in process of receiving [fresh] digest */
+        unsigned int needed:1;          /**< there were requests for this digest */
+        unsigned int usable:1;          /**< can be used for lookups */
+        unsigned int requested:1;       /**< in process of receiving [fresh] digest */
     }
-
     flags;
 
     struct
@@ -127,7 +120,6 @@ unsigned int requested:
         time_t received;	/* received the current copy of a digest */
         time_t disabled;	/* disabled for good */
     }
-
     times;
 
     struct
@@ -143,14 +135,14 @@ unsigned int requested:
 
         sent, recv;
     }
-
     stats;
 
 private:
     CBDATA_CLASS(PeerDigest);
 };
 
 extern const Version CacheDigestVer;
-#endif
+
+#endif /* USE_CACHE_DIGESTS */
 
 #endif /* SQUID_PEERDIGEST_H */
@@ -1,4 +1,3 @@
-
 /*
  * $Id: PingData.h,v 1.1 2003/10/16 21:40:16 robertc Exp $
  *
@@ -31,10 +30,15 @@
  *
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
-
 #ifndef SQUID_PINGDATA_H
 #define SQUID_PINGDATA_H
 
+#include "config.h"
+
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+
 class ping_data
 {
 
@@ -0,0 +1,10 @@
+/*
+ * $Id$
+ */
+
+// just for the global definition of Config and Config2
+#include "structs.h"
+
+struct SquidConfig Config;
+
+struct SquidConfig2 Config2;
@@ -41,6 +41,10 @@
 
 class CacheManager;
 
+/** todo checks to wrap this include properly */
+#include <ostream>
+
+
 #define DEBUGSTRINGS 0
 #if DEBUGSTRINGS
 #include "splay.h"
@@ -29,7 +29,6 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_STORE_H
 #define SQUID_STORE_H
 
@@ -55,15 +54,13 @@
 #endif
 
 class AsyncCall;
-
 class StoreClient;
-
 class MemObject;
-
 class Store;
-
 class StoreSearch;
 
+typedef unsigned int ping_status_t;
+
 /**
  \ingroup StoreAPI
  */
@@ -143,24 +140,18 @@ class StoreEntry : public hash_link
     u_short flags;
     /* END OF ON-DISK STORE_META_STD */
 
-sfileno swap_filen:
-    25;
+    sfileno swap_filen:25;
 
-sdirno swap_dirn:
-    7;
+    sdirno swap_dirn:7;
     u_short lock_count;		/* Assume < 65536! */
 
-mem_status_t mem_status:
-    3;
+    mem_status_t mem_status:3;
 
-ping_status_t ping_status:
-    3;
+    ping_status_t ping_status:3;
 
-store_status_t store_status:
-    3;
+    store_status_t store_status:3;
 
-swap_status_t swap_status:
-    3;
+    swap_status_t swap_status:3;
 
 public:
     static size_t inUseCount();
@@ -373,6 +364,7 @@ SQUIDCEXTERN void storeAppendVPrintf(StoreEntry *, const char *, va_list ap);
 /// \ingroup StoreAPI
 SQUIDCEXTERN int storeTooManyDiskFilesOpen(void);
 
+class SwapDir;
 /// \ingroup StoreAPI
 SQUIDCEXTERN void storeHeapPositionUpdate(StoreEntry *, SwapDir *);
 
@@ -41,6 +41,8 @@
 
 class CacheManager;
 
+class SwapDir;
+
 class StoreFileSystem
 {
 
@@ -52,7 +54,7 @@ class StoreFileSystem
     static Vector<StoreFileSystem*> const &FileSystems();
     typedef Vector<StoreFileSystem*>::iterator iterator;
     typedef Vector<StoreFileSystem*>::const_iterator const_iterator;
-    StoreFileSystem() : initialised (false) {}
+    StoreFileSystem() : initialised(false) {}
 
     virtual ~StoreFileSystem(){}
 
@@ -1,4 +1,3 @@
-
 /*
  * $Id: StoreMeta.h,v 1.3 2003/08/04 22:14:41 robertc Exp $
  *
@@ -30,24 +29,125 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_TYPELENGTHVALUE_H
 #define SQUID_TYPELENGTHVALUE_H
 
 class StoreEntry;
 
+// WTF?
 typedef class StoreMeta tlv;
 
+/* for size_t, SQUIDCEXTERN */
+#include "config.h"
+
+/**
+ \ingroup SwapStoreAPI
+ \todo AYJ: for critical lists like this we should use A=64,B=65 etc to enforce and reserve values.
+ \note NOTE!  We must preserve the order of this list!
+ *
+ \section StoreSwapMeta Store "swap meta" Description
+ \par
+ * "swap meta" refers to a section of meta data stored at the beginning
+ * of an object that is stored on disk.  This meta data includes information
+ * such as the object's cache key (MD5), URL, and part of the StoreEntry
+ * structure.
+ *
+ \par
+ * The meta data is stored using a TYPE-LENGTH-VALUE format.  That is,
+ * each chunk of meta information consists of a TYPE identifier, a
+ * LENGTH field, and then the VALUE (which is LENGTH octets long).
+ */
+enum {
+    /**
+     * Just a placeholder for the zeroth value. It is never used on disk.
+     */
+    STORE_META_VOID,
+
+    /**
+     \deprecated
+     * This represents the case when we use the URL as the cache
+     * key, as Squid-1.1 does.  Currently we don't support using
+     * a URL as a cache key, so this is not used.
+     */
+    STORE_META_KEY_URL,
+
+    /**
+     \deprecated
+     * For a brief time we considered supporting SHA (secure
+     * hash algorithm) as a cache key.  Nobody liked it, and
+     * this type is not currently used.
+     */
+    STORE_META_KEY_SHA,
+
+    /**
+     * This represents the MD5 cache key that Squid currently uses.
+     * When Squid opens a disk file for reading, it can check that
+     * this MD5 matches the MD5 of the user's request.  If not, then
+     * something went wrong and this is probably the wrong object.
+     */
+    STORE_META_KEY_MD5,
+
+    /**
+     * The object's URL.  This also may be matched against a user's
+     *  request for cache hits to make sure we got the right object.
+     */
+    STORE_META_URL,
+
+    /**
+     * This is the "standard metadata" for an object.
+     * Really its just this middle chunk of the StoreEntry structure:
+     \code
+        time_t timestamp;
+        time_t lastref;
+        time_t expires;
+        time_t lastmod;
+        size_t swap_file_sz;
+        u_short refcount;
+        u_short flags;
+     \endcode
+     */
+    STORE_META_STD,
+
+    /**
+     * Reserved for future hit-metering (RFC 2227) stuff
+     */
+    STORE_META_HITMETERING,
+
+    /// \todo DOCS: document.
+    STORE_META_VALID,
+
+    /**
+     * Stores Vary request headers
+     */
+    STORE_META_VARY_HEADERS,
+
+    /**
+     * Updated version of STORE_META_STD, with support for  >2GB objects.
+     * As STORE_META_STD except that the swap_file_sz is a 64-bit integer instead of 32-bit.
+     */
+    STORE_META_STD_LFS,
+
+    /**
+     \deprecated
+     * Object size, not implemented, squid26 compatibility
+     */
+    STORE_META_OBJSIZE,
+
+    STORE_META_STOREURL,	/* the store url, if different to the normal URL */
+    STORE_META_VARY_ID,		/* Unique ID linking variants */
+    STORE_META_END
+};
+
+/// \ingroup SwapStoreAPI
 class StoreMeta
 {
-
 public:
     static bool validType(char);
     static int const MaximumTLVLength;
     static int const MinimumTLVLength;
-    static StoreMeta *Factory (char type, size_t len, void const *value);
+    static StoreMeta *Factory(char type, size_t len, void const *value);
     static StoreMeta **Add(StoreMeta **tail, StoreMeta *aNode);
-    static void FreeList (StoreMeta **head);
+    static void FreeList(StoreMeta **head);
 
     virtual char getType() const = 0;
     virtual bool validLength(int) const;
@@ -57,15 +157,13 @@ class StoreMeta
     int length;
     void *value;
     tlv *next;
-
-private:
 };
 
-/*
- * store_swapmeta.c
- */
+/// \ingroup SwapStoreAPI
 SQUIDCEXTERN char *storeSwapMetaPack(tlv * tlv_list, int *length);
+/// \ingroup SwapStoreAPI
 SQUIDCEXTERN tlv *storeSwapMetaBuild(StoreEntry * e);
+/// \ingroup SwapStoreAPI
 SQUIDCEXTERN void storeSwapTLVFree(tlv * n);
 
 #endif /* SQUID_TYPELENGTHVALUE_H */
@@ -1,4 +1,3 @@
-
 /*
  * $Id: StoreMetaMD5.h,v 1.5 2008/02/26 21:49:34 amosjeffries Exp $
  *
@@ -30,11 +29,15 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_STOREMETAMD5_H
 #define SQUID_STOREMETAMD5_H
 
+/* for inheritance */
 #include "StoreMeta.h"
+/* for MEMPROXY_CLASS() macros */
+#include "MemPool.h"
+/* for STORE_META_KEY_MD5 */
+#include "enums.h"
 
 class StoreMetaMD5 : public StoreMeta
 {
@@ -51,6 +54,6 @@ class StoreMetaMD5 : public StoreMeta
     static int md5_mismatches;
 };
 
-MEMPROXY_CLASS_INLINE(StoreMetaMD5)		/**DOCS_NOSEMI*/
+MEMPROXY_CLASS_INLINE(StoreMetaMD5);
 
 #endif /* SQUID_STOREMETAMD5_H */
@@ -1,4 +1,3 @@
-
 /*
  * $Id: StoreMetaObjSize.h,v 1.1 2007/09/19 08:54:51 hno Exp $
  *
@@ -30,11 +29,11 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_STOREMETAOBJSIZE_H
 #define SQUID_STOREMETAOBJSIZE_H
 
 #include "StoreMeta.h"
+#include "MemPool.h"
 
 class StoreMetaObjSize : public StoreMeta
 {
@@ -45,6 +44,6 @@ class StoreMetaObjSize : public StoreMeta
     char getType() const {return STORE_META_OBJSIZE;}
 };
 
-MEMPROXY_CLASS_INLINE(StoreMetaObjSize)
+MEMPROXY_CLASS_INLINE(StoreMetaObjSize);
 
 #endif /* SQUID_STOREMETAOBJSIZE_H */
@@ -1,4 +1,3 @@
-
 /*
  * $Id: StoreMetaSTD.h,v 1.5 2008/02/26 21:49:34 amosjeffries Exp $
  *
@@ -30,11 +29,12 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_STOREMETASTD_H
 #define SQUID_STOREMETASTD_H
 
 #include "StoreMeta.h"
+/* for MEMPROXY_CLASS() macros */
+#include "MemPool.h"
 
 class StoreMetaSTD : public StoreMeta
 {
@@ -48,6 +48,6 @@ class StoreMetaSTD : public StoreMeta
     //    bool checkConsistency(StoreEntry *) const;
 };
 
-MEMPROXY_CLASS_INLINE(StoreMetaSTD)		/**DOCS_NOSEMI*/
+MEMPROXY_CLASS_INLINE(StoreMetaSTD);
 
 #endif /* SQUID_STOREMETASTD_H */
@@ -1,4 +1,3 @@
-
 /*
  * $Id: StoreMetaSTDLFS.h,v 1.2 2008/02/26 21:49:34 amosjeffries Exp $
  *
@@ -30,15 +29,16 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_STOREMETASTDLFS_H
 #define SQUID_STOREMETASTDLFS_H
 
+/* for inheritance */
 #include "StoreMeta.h"
+/* for MEMPROXY() macros */
+#include "MemPool.h"
 
 class StoreMetaSTDLFS : public StoreMeta
 {
-
 public:
     MEMPROXY_CLASS(StoreMetaSTDLFS);
 
@@ -48,6 +48,6 @@ class StoreMetaSTDLFS : public StoreMeta
     //    bool checkConsistency(StoreEntry *) const;
 };
 
-MEMPROXY_CLASS_INLINE(StoreMetaSTDLFS)		/**DOCS_NOSEMI*/
+MEMPROXY_CLASS_INLINE(StoreMetaSTDLFS);
 
 #endif /* SQUID_STOREMETASTDLFS_H */
@@ -1,4 +1,3 @@
-
 /*
  * $Id: StoreMetaURL.h,v 1.5 2008/02/26 21:49:34 amosjeffries Exp $
  *
@@ -30,15 +29,16 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_STOREMETAURL_H
 #define SQUID_STOREMETAURL_H
 
+/* for inheritance */
 #include "StoreMeta.h"
+/* for MEMPROXY_CLASS() macros */
+#include "MemPool.h"
 
 class StoreMetaURL : public StoreMeta
 {
-
 public:
     MEMPROXY_CLASS(StoreMetaURL);
 
@@ -47,6 +47,6 @@ class StoreMetaURL : public StoreMeta
     bool checkConsistency(StoreEntry *) const;
 };
 
-MEMPROXY_CLASS_INLINE(StoreMetaURL)		/**DOCS_NOSEMI*/
+MEMPROXY_CLASS_INLINE(StoreMetaURL);
 
 #endif /* SQUID_STOREMETAURL_H */
@@ -1,4 +1,3 @@
-
 /*
  * $Id: StoreMetaUnpacker.h,v 1.3 2008/01/07 17:12:28 hno Exp $
  *
@@ -30,11 +29,14 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_TYPELENGTHVALUEUNPACKER_H
 #define SQUID_TYPELENGTHVALUEUNPACKER_H
 
 class StoreMeta;
+class StoreEntry;
+
+/* for ssize_t, SQUIDCEXTERN */
+#include "config.h"
 
 class StoreMetaUnpacker
 {
@@ -1,4 +1,3 @@
-
 /*
  * $Id: StoreMetaVary.h,v 1.5 2008/02/26 21:49:34 amosjeffries Exp $
  *
@@ -30,15 +29,16 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_STOREMETAVARY_H
 #define SQUID_STOREMETAVARY_H
 
+/* for inheritance */
 #include "StoreMeta.h"
+/* for MEMPROXY_CLASS() macros */
+#include "MemPool.h"
 
 class StoreMetaVary : public StoreMeta
 {
-
 public:
     MEMPROXY_CLASS(StoreMetaVary);
 
@@ -47,6 +47,6 @@ class StoreMetaVary : public StoreMeta
     bool checkConsistency(StoreEntry *) const;
 };
 
-MEMPROXY_CLASS_INLINE(StoreMetaVary)		/**DOCS_NOSEMI*/
+MEMPROXY_CLASS_INLINE(StoreMetaVary);
 
 #endif /* SQUID_STOREMETAVARY_H */
@@ -160,7 +160,9 @@ String::cut(size_t newLength)
 
     len_ = newLength;
 
-    if(len_ == 0 && buf_ == NULL) return; // buf_ may be NULL on zero-length strings.
+    // buf_ may be NULL on zero-length strings.
+    if(len_ == 0 && buf_ == NULL) return;
+
     buf_[newLength] = '\0';
 }
 
@@ -1,4 +1,3 @@
-
 /*
  * $Id: SwapDir.h,v 1.15 2007/09/28 00:22:37 hno Exp $
  *
@@ -30,7 +29,6 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_SWAPDIR_H
 #define SQUID_SWAPDIR_H
 
@@ -92,8 +90,8 @@ class StoreController : public Store
 };
 
 /* migrating from the Config based list of swapdirs */
-extern void allocate_new_swapdir(_SquidConfig::_cacheSwap *);
-extern void free_cachedir(_SquidConfig::_cacheSwap * swap);
+extern void allocate_new_swapdir(SquidConfig::_cacheSwap *);
+extern void free_cachedir(SquidConfig::_cacheSwap * swap);
 SQUIDCEXTERN OBJH storeDirStats;
 SQUIDCEXTERN char *storeDirSwapLogFile(int, const char *);
 SQUIDCEXTERN char *storeSwapFullPath(int, char *);
@@ -1,4 +1,3 @@
-
 /*
  * $Id: access_log.cc,v 1.130 2008/01/20 08:54:28 amosjeffries Exp $
  *
@@ -396,8 +395,10 @@ enum log_quote {
     LOG_QUOTE_RAW
 };
 
-struct _logformat_token
+/* FIXME: public class so we can pre-define its type. */
+class logformat_token
 {
+public:
     logformat_bcode_t type;
     union {
         char *string;
@@ -416,14 +417,11 @@ struct _logformat_token
 
     enum log_quote quote;
 
-unsigned int left:
-    1;
+unsigned int left:1;
 
-unsigned int space:
-    1;
+unsigned int space:1;
 
-unsigned int zero:
-    1;
+unsigned int zero:1;
     int divisor;
     logformat_token *next;	/* todo: move from linked list to array */
 };
@@ -32,11 +32,19 @@
  *
  */
 
+#if 0
 #include "squid.h"
+#include "HttpRequest.h"
+#endif
+
 #include "ACL.h"
 #include "ACLChecklist.h"
 #include "ConfigParser.h"
-#include "HttpRequest.h"
+#include "dlink.h"
+/* for special-case PURGE test */
+#include "HttpRequestMethod.h"
+/* for Vector<> Instances */
+#include "assert.h"
 
 const char *AclMatchedName = NULL;
 
@@ -285,7 +285,7 @@ aclDestroyAccessList(acl_access ** list)
 }
 
 /* maex@space.net (06.09.1996)
- *    destroy an _acl_deny_info_list */
+ *    destroy an acl_deny_info_list */
 
 void
 aclDestroyDenyInfoList(acl_deny_info_list ** list)
@@ -19,3 +19,14 @@ libnegotiate_a_SOURCES	= negotiate/auth_negotiate.cc negotiate/auth_negotiate.h
 
 INCLUDES      = -I. -I$(top_builddir)/include -I$(top_srcdir)/include \
 	-I$(top_srcdir)/src
+
+check_PROGRAMS= testHeaders
+
+## Special Universal .h dependency test script
+## aborts if error encountered
+testHeaders: basic/*.h digest/*.h ntlm/*.h negotiate/*.h
+	../../test-suite/testheaders.sh "$(CXXCOMPILE)" "basic" || exit 1
+	../../test-suite/testheaders.sh "$(CXXCOMPILE)" "digest" || exit 1
+	../../test-suite/testheaders.sh "$(CXXCOMPILE)" "ntlm" || exit 1
+	../../test-suite/testheaders.sh "$(CXXCOMPILE)" "negotiate" || exit 1
+## ./ has no .h files
@@ -360,11 +360,11 @@ authenticateBasicStats(StoreEntry * sentry)
 
 CBDATA_TYPE(AuthenticateStateData);
 
-static auth_user_t *
+static AuthUser *
 authBasicAuthUserFindUsername(const char *username)
 {
     AuthUserHashPointer *usernamehash;
-    debugs(29, 9, "authBasicAuthUserFindUsername: Looking for user '" << username << "'");
+    debugs(29, 9, HERE << "Looking for user '" << username << "'");
 
     if (username && (usernamehash = static_cast<AuthUserHashPointer *>(hash_lookup(proxy_auth_username_cache, username)))) {
         while (usernamehash) {
@@ -570,7 +570,7 @@ AuthBasicConfig::decode(char const *proxy_auth)
     /* now lookup and see if we have a matching auth_user structure in
      * memory. */
 
-    auth_user_t *auth_user;
+    AuthUser *auth_user;
 
     if ((auth_user = authBasicAuthUserFindUsername(local_basic.username())) == NULL) {
         auth_user = local_basic.makeCachedFrom();
@@ -456,12 +456,12 @@ authDigestNoncePurge(digest_nonce_h * nonce)
 }
 
 /* USER related functions */
-static auth_user_t *
+static AuthUser *
 authDigestUserFindUsername(const char *username)
 {
-    auth_user_hash_pointer *usernamehash;
-    auth_user_t *auth_user;
-    debugs(29, 9, "authDigestUserFindUsername: Looking for user '" << username << "'");
+    AuthUserHashPointer *usernamehash;
+    AuthUser *auth_user;
+    debugs(29, 9, HERE << "Looking for user '" << username << "'");
 
     if (username && (usernamehash = static_cast < auth_user_hash_pointer * >(hash_lookup(proxy_auth_username_cache, username)))) {
         while ((usernamehash->user()->auth_type != AUTH_DIGEST) &&
@@ -483,11 +483,9 @@ authDigestUserFindUsername(const char *username)
 static void
 authDigestUserShutdown(void)
 {
-    /*
-     * Future work: the auth framework could flush it's cache 
-     */
-    auth_user_hash_pointer *usernamehash;
-    auth_user_t *auth_user;
+    /** \todo Future work: the auth framework could flush it's cache */
+    AuthUserHashPointer *usernamehash;
+    AuthUser *auth_user;
     hash_first(proxy_auth_username_cache);
 
     while ((usernamehash = ((auth_user_hash_pointer *) hash_next(proxy_auth_username_cache)))) {
@@ -498,11 +496,11 @@ authDigestUserShutdown(void)
     }
 }
 
-/* delete the digest request structure. Does NOT delete related structures */
+/** delete the digest request structure. Does NOT delete related structures */
 void
 digestScheme::done()
 {
-    /* TODO: this should be a Config call. */
+    /** \todo this should be a Config call. */
 
     if (digestauthenticators)
         helperShutdown(digestauthenticators);
@@ -570,12 +568,12 @@ AuthDigestUserRequest::authenticated() const
     return 0;
 }
 
-/* log a digest user in
+/** log a digest user in
  */
 void
 AuthDigestUserRequest::authenticate(HttpRequest * request, ConnStateData * conn, http_hdr_type type)
 {
-    auth_user_t *auth_user;
+    AuthUser *auth_user;
     AuthDigestUserRequest *digest_request;
     digest_user_h *digest_user;
 
@@ -1301,7 +1299,7 @@ AuthDigestConfig::decode(char const *proxy_auth)
     /* find the user */
     digest_user_h *digest_user;
 
-    auth_user_t *auth_user;
+    AuthUser *auth_user;
 
     if ((auth_user = authDigestUserFindUsername(username)) == NULL) {
         /* the user doesn't exist in the username cache yet */
@@ -1380,28 +1378,24 @@ AuthDigestUserRequest::module_start(RH * handler, void *data)
 DigestUser::DigestUser (AuthConfig *config) : AuthUser (config), HA1created (0)
 {}
 
-auth_user_t *
+AuthUser *
 AuthDigestUserRequest::authUser() const
 {
     return const_cast<AuthUser *>(user());
 }
 
 void
-AuthDigestUserRequest::authUser(auth_user_t *aUser)
+AuthDigestUserRequest::authUser(AuthUser *aUser)
 {
-    assert (!authUser());
+    assert(!authUser());
     user(aUser);
-
-    user()->lock()
-
-    ;
+    user()->lock();
 }
 
 AuthDigestUserRequest::CredentialsState
 AuthDigestUserRequest::credentials() const
 {
     return credentials_ok;
-
 }
 
 void
@@ -1417,7 +1411,7 @@ AuthDigestUserRequest::AuthDigestUserRequest() : nonceb64(NULL) ,cnonce(NULL) ,r
         credentials_ok (Unchecked)
 {}
 
-/* delete the digest request structure. Does NOT delete related structures */
+/** delete the digest request structure. Does NOT delete related structures */
 AuthDigestUserRequest::~AuthDigestUserRequest()
 {
     safe_free (nonceb64);
@@ -44,7 +44,7 @@ class DigestUser : public AuthUser
 
 };
 
-MEMPROXY_CLASS_INLINE(DigestUser)		/**DOCS_NOSEMI*/
+MEMPROXY_CLASS_INLINE(DigestUser);
 
 typedef class DigestUser digest_user_h;
 
@@ -74,13 +74,13 @@ class AuthDigestUserRequest : public AuthUserRequest
 
     virtual const AuthUser *user() const {return _theUser;}
 
-    virtual void user (AuthUser *aUser) {_theUser=dynamic_cast<DigestUser *>(aUser);}
+    virtual void user(AuthUser *aUser) {_theUser=dynamic_cast<DigestUser *>(aUser);}
 
     CredentialsState credentials() const;
     void credentials(CredentialsState);
 
-    void authUser(auth_user_t *);
-    auth_user_t *authUser() const;
+    void authUser(AuthUser *);
+    AuthUser *authUser() const;
 
     char *nonceb64;		/* "dcd98b7102dd2f0e8b11d0f600bfb0c093" */
     char *cnonce;		/* "0a4f113b" */
@@ -479,8 +479,8 @@ authenticateNegotiateHandleReply(void *data, void *lastserver, char *reply)
         debugs(29, 4, "AuthNegotiateUserRequest::authenticate: authenticated user " << negotiate_user->username());
         /* see if this is an existing user with a different proxy_auth
          * string */
-        auth_user_hash_pointer *usernamehash = static_cast<AuthUserHashPointer *>(hash_lookup(proxy_auth_username_cache, negotiate_user->username()));
-	auth_user_t *local_auth_user = negotiate_request->user();
+        AuthUserHashPointer *usernamehash = static_cast<AuthUserHashPointer *>(hash_lookup(proxy_auth_username_cache, negotiate_user->username()));
+	AuthUser *local_auth_user = negotiate_request->user();
         while (usernamehash && (usernamehash->user()->auth_type != AUTH_NEGOTIATE || strcmp(usernamehash->user()->username(), negotiate_user->username()) != 0))
             usernamehash = static_cast<AuthUserHashPointer *>(usernamehash->next);
         if (usernamehash) {
@@ -556,14 +556,14 @@ authenticateNegotiateStats(StoreEntry * sentry)
 }
 
 
-/* send the initial data to a stateful negotiate authenticator module */
+/** send the initial data to a stateful negotiate authenticator module */
 void
 AuthNegotiateUserRequest::module_start(RH * handler, void *data)
 {
     authenticateStateData *r = NULL;
     static char buf[8192];
     negotiate_user_t *negotiate_user;
-    auth_user_t *auth_user = user();
+    AuthUser *auth_user = user();
 
     assert(data);
     assert(handler);
@@ -678,8 +678,8 @@ AuthNegotiateUserRequest::authenticate(HttpRequest * request, ConnStateData * co
 {
     const char *proxy_auth, *blob;
 
-    /* TODO: rename this!! */
-    auth_user_t *local_auth_user;
+    /** \todo rename this!! */
+    AuthUser *local_auth_user;
     negotiate_user_t *negotiate_user;
 
     local_auth_user = user();
@@ -688,7 +688,7 @@ AuthNegotiateUserRequest::authenticate(HttpRequest * request, ConnStateData * co
     negotiate_user = dynamic_cast<negotiate_user_t *>(local_auth_user);
     assert (this);
 
-    /* Check that we are in the client side, where we can generate
+    /** Check that we are in the client side, where we can generate
      * auth challenges */
 
     if (conn == NULL) {
@@ -414,7 +414,7 @@ authenticateNTLMHandleReply(void *data, void *lastserver, char *reply)
         /* see if this is an existing user with a different proxy_auth
          * string */
         auth_user_hash_pointer *usernamehash = static_cast<AuthUserHashPointer *>(hash_lookup(proxy_auth_username_cache, ntlm_user->username()));
-	auth_user_t *local_auth_user = ntlm_request->user();
+	AuthUser *local_auth_user = ntlm_request->user();
         while (usernamehash && (usernamehash->user()->auth_type != AUTH_NTLM || strcmp(usernamehash->user()->username(), ntlm_user->username()) != 0))
             usernamehash = static_cast<AuthUserHashPointer *>(usernamehash->next);
         if (usernamehash) {
@@ -485,7 +485,7 @@ AuthNTLMUserRequest::module_start(RH * handler, void *data)
     authenticateStateData *r = NULL;
     static char buf[8192];
     ntlm_user_t *ntlm_user;
-    auth_user_t *auth_user = user();
+    AuthUser *auth_user = user();
 
     assert(data);
     assert(handler);
@@ -601,7 +601,7 @@ AuthNTLMUserRequest::authenticate(HttpRequest * request, ConnStateData * conn, h
     const char *proxy_auth, *blob;
 
     /* TODO: rename this!! */
-    auth_user_t *local_auth_user;
+    AuthUser *local_auth_user;
     ntlm_user_t *ntlm_user;
 
     local_auth_user = user();
@@ -113,41 +113,41 @@ authenticateShutdown(void)
     }
 }
 
+/**
+ \retval 0 not in use
+ \retval ? in use
+ */
 int
-authenticateAuthUserInuse(auth_user_t * auth_user)
-/* returns 0 for not in use */
+authenticateAuthUserInuse(AuthUser * auth_user)
 {
     assert(auth_user != NULL);
     return auth_user->references;
 }
 
 void
-authenticateAuthUserMerge(auth_user_t * from, auth_user_t * to)
+authenticateAuthUserMerge(AuthUser * from, AuthUser * to)
 {
     to->absorb (from);
 }
 
-/*
- * authenticateUserCacheRestart() cleans all config-dependent data from the 
- * auth_user cache. It DOES NOT Flush the user cache.
+/**
+ * Cleans all config-dependent data from the auth_user cache.
+ \note It DOES NOT Flush the user cache.
  */
-
 void
 authenticateUserCacheRestart(void)
 {
     AuthUserHashPointer *usernamehash;
-    auth_user_t *auth_user;
-    debugs(29, 3, "authenticateUserCacheRestart: Clearing config dependent cache data.");
+    AuthUser *auth_user;
+    debugs(29, 3, HERE << "Clearing config dependent cache data.");
     hash_first(proxy_auth_username_cache);
 
     while ((usernamehash = ((AuthUserHashPointer *) hash_next(proxy_auth_username_cache)))) {
         auth_user = usernamehash->user();
         debugs(29, 5, "authenticateUserCacheRestat: Clearing cache ACL results for user: " << auth_user->username());
     }
-
 }
 
-/* _auth_user_hash_pointe */
 
 void
 AuthUserHashPointer::removeFromCache(void *usernamehash_p)
@@ -165,14 +165,14 @@ AuthUserHashPointer::removeFromCache(void *usernamehash_p)
      */
 }
 
-AuthUserHashPointer::AuthUserHashPointer (AuthUser * anAuth_user):
-        auth_user (anAuth_user)
+AuthUserHashPointer::AuthUserHashPointer(AuthUser * anAuth_user):
+        auth_user(anAuth_user)
 {
     key = (void *)anAuth_user->username();
     next = NULL;
     hash_join(proxy_auth_username_cache, (hash_link *) this);
-    /* lock for presence in the cache */
 
+    /** lock for presence in the cache */
     auth_user->lock();
 }
 
@@ -181,5 +181,3 @@ AuthUserHashPointer::user() const
 {
     return auth_user;
 }
-
-
@@ -54,15 +54,15 @@ struct AuthUserHashPointer : public hash_link
     static void removeFromCache (void *anAuthUserHashPointer);
     MEMPROXY_CLASS(AuthUserHashPointer);
 
-    AuthUserHashPointer (AuthUser *);
+    AuthUserHashPointer(AuthUser *);
 
     AuthUser *user() const;
 
 private:
     AuthUser *auth_user;
 };
 
-MEMPROXY_CLASS_INLINE(AuthUserHashPointer)			/**DOCS_NOSEMI*/
+MEMPROXY_CLASS_INLINE(AuthUserHashPointer);
 
 class ConnStateData;
 
@@ -79,7 +79,7 @@ typedef void AUTHSSTATS(StoreEntry *);
  * subsumed by the C++ interface
  \todo does 'subsumed' mean deprecated use a C++ API call?
  */
-extern void authenticateAuthUserMerge(auth_user_t *, auth_user_t *);
+extern void authenticateAuthUserMerge(AuthUser *, AuthUser *);
 
 /// \ingroup AuthAPI
 extern void authenticateInit(authConfig *);
@@ -88,7 +88,7 @@ extern void authenticateRegisterWithCacheManager(authConfig * config, CacheManag
 /// \ingroup AuthAPI
 extern void authenticateShutdown(void);
 /// \ingroup AuthAPI
-extern int authenticateAuthUserInuse(auth_user_t * auth_user);
+extern int authenticateAuthUserInuse(AuthUser * auth_user);
 
 /// \ingroup AuthAPI
 extern void authenticateFreeProxyAuthUserACLResults(void *data);
@@ -1378,7 +1378,7 @@ free_http_header_replace(header_mangler header[])
 #endif
 
 static void
-dump_cachedir(StoreEntry * entry, const char *name, _SquidConfig::_cacheSwap swap)
+dump_cachedir(StoreEntry * entry, const char *name, SquidConfig::_cacheSwap swap)
 {
     SwapDir *s;
     int i;
@@ -1465,7 +1465,7 @@ find_fstype(char *type)
 }
 
 static void
-parse_cachedir(_SquidConfig::_cacheSwap * swap)
+parse_cachedir(SquidConfig::_cacheSwap * swap)
 {
     char *type_str;
     char *path_str;
@@ -1,4 +1,3 @@
-
 /*
  * $Id: client_side_reply.cc,v 1.154 2008/02/16 17:42:27 rousskov Exp $
  *
@@ -33,6 +32,10 @@
  *
  */
 
+/* for ClientActiveRequests global */
+#include "dlink.h"
+
+/* old includes without reasons given. */
 #include "squid.h"
 #include "client_side_reply.h"
 #include "errorpage.h"
@@ -41,7 +44,6 @@
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "forward.h"
-
 #include "clientStream.h"
 #include "AuthUserRequest.h"
 #if USE_SQUID_ESI
@@ -31,12 +31,17 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
+#if 0
 #include "squid.h"
+#endif
+
 #include "Debug.h"
 #include "SquidTime.h"
 #include <sstream>
 
+/* for Config */
+#include "structs.h"
+
 int Debug::Levels[MAX_DEBUG_SECTIONS];
 int Debug::level;
 
@@ -1,4 +1,3 @@
-
 /*
  * $Id: defines.h,v 1.123 2007/12/14 23:11:46 amosjeffries Exp $
  *
@@ -30,7 +29,6 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_DEFINES_H
 #define SQUID_DEFINES_H
 
@@ -41,6 +39,10 @@
 #define FALSE 0
 #endif
 
+#ifndef BUFSIZ
+#define BUFSIZ  4096            /* make unreasonable guess */
+#endif
+
 #define ACL_NAME_SZ 32
 #define BROWSERNAMELEN 128
 
@@ -59,7 +61,6 @@
 /* Select types. */
 #define COMM_SELECT_READ   (0x1)
 #define COMM_SELECT_WRITE  (0x2)
-#define MAX_DEBUG_SECTIONS 100
 
 #define COMM_NONBLOCKING	0x01
 #define COMM_NOCLOEXEC		0x02
@@ -0,0 +1,101 @@
+/*
+ * $Id$
+ */
+#include "dlink.h"
+
+/* dlink are Mem-pooled */
+#include "MemPool.h"
+/* for xstrdup() */
+#include "util.h"
+
+
+dlink_list ClientActiveRequests;
+
+MemAllocator *dlink_node_pool = NULL;
+
+dlink_node *
+dlinkNodeNew()
+{
+    if (dlink_node_pool == NULL)
+        dlink_node_pool = memPoolCreate("Dlink list nodes", sizeof(dlink_node));
+
+    /* where should we call delete dlink_node_pool;dlink_node_pool = NULL; */
+    return (dlink_node *)dlink_node_pool->alloc();
+}
+
+/** The node needs to be unlinked FIRST */
+void
+dlinkNodeDelete(dlink_node * m)
+{
+    if (m == NULL)
+        return;
+
+    dlink_node_pool->free(m);
+}
+
+void
+dlinkAdd(void *data, dlink_node * m, dlink_list * list)
+{
+    m->data = data;
+    m->prev = NULL;
+    m->next = list->head;
+
+    if (list->head)
+        list->head->prev = m;
+
+    list->head = m;
+
+    if (list->tail == NULL)
+        list->tail = m;
+}
+
+void
+dlinkAddAfter(void *data, dlink_node * m, dlink_node * n, dlink_list * list)
+{
+    m->data = data;
+    m->prev = n;
+    m->next = n->next;
+
+    if (n->next)
+        n->next->prev = m;
+    else {
+        assert(list->tail == n);
+        list->tail = m;
+    }
+
+    n->next = m;
+}
+
+void
+dlinkAddTail(void *data, dlink_node * m, dlink_list * list)
+{
+    m->data = data;
+    m->next = NULL;
+    m->prev = list->tail;
+
+    if (list->tail)
+        list->tail->next = m;
+
+    list->tail = m;
+
+    if (list->head == NULL)
+        list->head = m;
+}
+
+void
+dlinkDelete(dlink_node * m, dlink_list * list)
+{
+    if (m->next)
+        m->next->prev = m->prev;
+
+    if (m->prev)
+        m->prev->next = m->next;
+
+    if (m == list->head)
+        list->head = m->next;
+
+    if (m == list->tail)
+        list->tail = m->prev;
+
+    m->next = m->prev = NULL;
+}
@@ -1,4 +1,3 @@
-
 /*
  * $Id: dlink.h,v 1.1 2006/04/22 13:07:36 robertc Exp $
  *
@@ -30,7 +29,6 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_DLINK_H
 #define SQUID_DLINK_H
 
@@ -47,14 +45,22 @@ class dlink_node
     dlink_node *next;
 };
 
-struct _dlink_list
+struct dlink_list
 {
     dlink_node *head;
     dlink_node *tail;
 };
 
-class dlink_node;
+/* mported form globals.h */
+extern dlink_list ClientActiveRequests;
+
+/* imported directly from protos.h */
 
-typedef struct _dlink_list dlink_list;
+SQUIDCEXTERN void dlinkAdd(void *data, dlink_node *, dlink_list *);
+SQUIDCEXTERN void dlinkAddAfter(void *, dlink_node *, dlink_node *, dlink_list *);
+SQUIDCEXTERN void dlinkAddTail(void *data, dlink_node *, dlink_list *);
+SQUIDCEXTERN void dlinkDelete(dlink_node * m, dlink_list * list);
+SQUIDCEXTERN void dlinkNodeDelete(dlink_node * m);
+SQUIDCEXTERN dlink_node *dlinkNodeNew(void);
 
 #endif /* SQUID_DLINK_H */
@@ -429,104 +429,6 @@ typedef enum {
     MEM_MAX
 } mem_type;
 
-/**
- \ingroup SwapStoreAPI
- \todo AYJ: for critical lists like this we should use A=64,B=65 etc to enforce and reserve values.
- \note NOTE!  We must preserve the order of this list!
- *
- \section StoreSwapMeta Store "swap meta" Description
- \par
- * "swap meta" refers to a section of meta data stored at the beginning
- * of an object that is stored on disk.  This meta data includes information
- * such as the object's cache key (MD5), URL, and part of the StoreEntry
- * structure.
- *
- \par
- * The meta data is stored using a TYPE-LENGTH-VALUE format.  That is,
- * each chunk of meta information consists of a TYPE identifier, a
- * LENGTH field, and then the VALUE (which is LENGTH octets long).
- */
-enum {
-    /**
-     * Just a placeholder for the zeroth value. It is never used on disk.
-     */
-    STORE_META_VOID,
-
-    /**
-     \deprecated
-     * This represents the case when we use the URL as the cache
-     * key, as Squid-1.1 does.  Currently we don't support using
-     * a URL as a cache key, so this is not used.
-     */
-    STORE_META_KEY_URL,
-
-    /**
-     \deprecated
-     * For a brief time we considered supporting SHA (secure
-     * hash algorithm) as a cache key.  Nobody liked it, and
-     * this type is not currently used.
-     */
-    STORE_META_KEY_SHA,
-
-    /**
-     * This represents the MD5 cache key that Squid currently uses.
-     * When Squid opens a disk file for reading, it can check that
-     * this MD5 matches the MD5 of the user's request.  If not, then
-     * something went wrong and this is probably the wrong object.
-     */
-    STORE_META_KEY_MD5,
-
-    /**
-     * The object's URL.  This also may be matched against a user's
-     *  request for cache hits to make sure we got the right object.
-     */
-    STORE_META_URL,
-
-    /**
-     * This is the "standard metadata" for an object.
-     * Really its just this middle chunk of the StoreEntry structure:
-     \code
-        time_t timestamp;
-        time_t lastref;
-        time_t expires;
-        time_t lastmod;
-        size_t swap_file_sz;
-        u_short refcount;
-        u_short flags;
-     \endcode
-     */
-    STORE_META_STD,
-
-    /**
-     * Reserved for future hit-metering (RFC 2227) stuff
-     */
-    STORE_META_HITMETERING,
-
-    /// \todo DOCS: document.
-    STORE_META_VALID,
-
-    /**
-     * Stores Vary request headers
-     */
-    STORE_META_VARY_HEADERS,
-
-    /**
-     * Updated version of STORE_META_STD, with support for  >2GB objects.
-     * As STORE_META_STD except that the swap_file_sz is a 64-bit integer instead of 32-bit.
-     */
-    STORE_META_STD_LFS,
-
-    /**
-     \deprecated
-     * Object size, not implemented, squid26 compatibility
-     */
-    STORE_META_OBJSIZE,
-
-    STORE_META_STOREURL,	/* the store url, if different to the normal URL */
-    STORE_META_VARY_ID,		/* Unique ID linking variants */
-    STORE_META_END
-};
-
 enum {
     STORE_LOG_CREATE,
     STORE_LOG_SWAPIN,
@@ -32,6 +32,18 @@ EXTRA_DIST = \
 INCLUDES      = -I. -I$(top_builddir)/include -I$(top_srcdir)/include \
 	-I$(top_srcdir)/src
 
+check_PROGRAMS=testHeaders
+
+## Special Universal .h dependency test script
+## aborts if error encountered
+testHeaders: ufs/*.h coss/*.h
+	../../test-suite/testheaders.sh "$(CXXCOMPILE)" "ufs" || exit 1
+	../../test-suite/testheaders.sh "$(CXXCOMPILE)" "coss" || exit 1
+## diskd/ has no .h files
+## aufs/ has no .h files
+## ./ has no .h files
+
+
 ## targets below to emulate distributed makefiles
 coss/all: libcoss.a
 coss/clean: clean
@@ -1,4 +1,3 @@
-
 /*
  * $Id: StoreFSaufs.cc,v 1.3 2008/02/26 21:49:43 amosjeffries Exp $
  *
@@ -34,10 +33,16 @@
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
 
+#if 0
 #include "squid.h"
 #include "StoreFileSystem.h"
-#include "fs/ufs/StoreFSufs.h"
 #include "DiskIO/DiskIOModule.h"
+#endif
+
+#include "fs/ufs/StoreFSufs.h"
+
+/** \todo FIXME: break UFSSwapDir out so we don't need all the guff */
+#include "fs/ufs/ufscommon.h"
 
 /**
  \defgroup AUFS AUFS Storage Filesystem (UFS Based)
@@ -1,8 +1,20 @@
+/*
+ * $Id$
+ */
 #ifndef __COSSSWAPDIR_H__
 #define __COSSSWAPDIR_H__
 
+class StoreEntry;
+class CossSwapDir;
+class CossMemBuf;
+class DiskIOStrategy;
+class DiskIOModule;
+class ConfigOptionVector;
+class DiskFile;
+
 #include "SwapDir.h"
-#include "StoreSearch.h"
+#include "DiskIO/IORequestor.h"
+
 
 #ifndef COSS_MEMBUF_SZ
 #define	COSS_MEMBUF_SZ	1048576
@@ -14,18 +26,6 @@
 #define COSS_ALLOC_ALLOCATE		1
 #define COSS_ALLOC_REALLOC		2
 
-class CossSwapDir;
-
-
-class CossMemBuf;
-
-class DiskIOStrategy;
-
-class DiskIOModule;
-
-class ConfigOptionVector;
-#include "DiskIO/DiskFile.h"
-#include "DiskIO/IORequestor.h"
 
 /// \ingroup COSS
 class CossSwapDir : public SwapDir, public IORequestor
@@ -100,6 +100,9 @@ extern void storeCossRemove(CossSwapDir *, StoreEntry *);
 /// \ingroup COSS
 extern void storeCossStartMembuf(CossSwapDir * SD);
 
+
+#include "StoreSearch.h"
+
 /// \ingroup COSS
 class StoreSearchCoss : public StoreSearch
 {
@@ -1,4 +1,3 @@
-
 /*
  * $Id: StoreFScoss.h,v 1.4 2008/02/26 21:49:43 amosjeffries Exp $
  *
@@ -30,11 +29,10 @@
  *
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
-
 #ifndef SQUID_STOREFSCOSS_H
 #define SQUID_STOREFSCOSS_H
 
-#include "StoreFileSystem.h"
+class StoreEntry;
 
 /**
  \defgroup COSS COSS Storage Filesystem
@@ -72,6 +70,11 @@ class CossStats
     open, create, close, unlink, read, write, stripe_write;
 };
 
+
+class CacheManager;
+
+#include "StoreFileSystem.h"
+
 /// \ingroup COSS, FileSystems
 class StoreFScoss : public StoreFileSystem
 {
@@ -1,4 +1,3 @@
-
 /*
  * $Id: StoreFSdiskd.cc,v 1.3 2008/02/26 21:49:44 amosjeffries Exp $
  *
@@ -34,10 +33,15 @@
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
 
-
+#if 0
 #include "StoreFileSystem.h"
-#include "fs/ufs/StoreFSufs.h"
 #include "DiskIO/DiskIOModule.h"
+#endif
+
+#include "fs/ufs/StoreFSufs.h"
+
+/** \todo FIXME: break UFSSwapDir out so we don;t need all the extras */
+#include "fs/ufs/ufscommon.h"
 
 /**
  \defgroup diskd diskd Storage Filesystem (UFS Based)
@@ -1,5 +1,3 @@
-
-
 /*
  * $Id: StoreFSufs.cc,v 1.2 2004/12/20 16:30:45 robertc Exp $
  *
@@ -35,10 +33,18 @@
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
 
-
+#if 0
 #include "StoreFileSystem.h"
+#endif
+
 #include "fs/ufs/StoreFSufs.h"
+
+#if 0
 #include "DiskIO/DiskIOModule.h"
+#endif
+
+/** \todo FIXME: break UFSSwapDir out so we don't build all the extras */
+#include "fs/ufs/ufscommon.h"
 
 static StoreFSufs<UFSSwapDir> UfsInstance("Blocking", "ufs");
 
@@ -1,4 +1,3 @@
-
 /*
  * $Id: StoreFSufs.h,v 1.6 2008/02/26 21:49:45 amosjeffries Exp $
  *
@@ -30,19 +29,18 @@
  *
  * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
-
 #ifndef SQUID_STOREFSUFS_H
 #define SQUID_STOREFSUFS_H
 
-#include "squid.h"
-#include "ufscommon.h"
-#include "DiskIO/DiskIOModule.h"
-
 /**
  \defgroup UFS	UFS Storage Filesystem
  \ingroup FileSystems
  */
 
+class DiskIOModule;
+
+#include "StoreFileSystem.h"
+
 /**
  \ingroup UFS, FileSystems
  *
@@ -1,4 +1,3 @@
-
 /*
  * $Id: ufscommon.h,v 1.13 2008/02/26 21:49:45 amosjeffries Exp $
  *
@@ -29,26 +28,20 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_UFSCOMMON_H
 #define SQUID_UFSCOMMON_H
 
-#include "squid.h"
-#include "event.h"
 
-#define DefaultLevelOneDirs     16
-#define DefaultLevelTwoDirs     256
-#define STORE_META_BUFSZ 4096
-
-/* Common UFS routines */
-#include "SwapDir.h"
-#include "StoreSearch.h"
+#define DefaultLevelOneDirs	16
+#define DefaultLevelTwoDirs	256
+#define STORE_META_BUFSZ	4096
 
 class UFSStrategy;
-
 class ConfigOptionVector;
-
 class DiskIOModule;
+class StoreSearch;
+
+#include "SwapDir.h"
 
 /// \ingroup UFS
 class UFSSwapDir : public SwapDir
@@ -293,8 +286,12 @@ class UFSStoreState : public StoreIOState, public IORequestor
     void doWrite();
 };
 
-MEMPROXY_CLASS_INLINE(UFSStoreState::_queued_read)		/**DOCS_NOSEMI*/
-MEMPROXY_CLASS_INLINE(UFSStoreState::_queued_write)		/**DOCS_NOSEMI*/
+MEMPROXY_CLASS_INLINE(UFSStoreState::_queued_read);
+MEMPROXY_CLASS_INLINE(UFSStoreState::_queued_write);
+
+
+
+#include "StoreSearch.h"
 
 /// \ingroup UFS
 class StoreSearchUFS : public StoreSearch
@@ -334,6 +331,7 @@ class StoreSearchUFS : public StoreSearch
     bool _done;
 };
 
+
 class StoreSwapLogData;
 
 /// \ingroup UFS
@@ -362,6 +360,7 @@ class UFSSwapLogParser
     }
 };
 
+
 /// \ingroup UFS
 class RebuildState : public RefCountable
 {
@@ -1,4 +1,3 @@
-
 /*
  * $Id: globals.h,v 1.143 2008/02/11 22:36:52 rousskov Exp $
  *
@@ -30,26 +29,38 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_GLOBALS_H
 #define SQUID_GLOBALS_H
 
+#if HAVE_STDIO_H
+#include <stdio.h>
+#endif
+
+#include "rfc2181.h"
+
+/* for ERROR_BUF_SZ, BUFSIZ, MAXHTTPPORTS */
+#include "defines.h"
+
+/* for iostats, StatCounters */
+#include "structs.h"
+
+
 #ifdef __cplusplus
 extern "C"
 {
 #endif
 
     extern FILE *debug_log;		/* NULL */
-    extern SquidConfig Config;
-    extern SquidConfig2 Config2;
+//MOVED:structs.h    extern SquidConfig Config;
+//MOVED:structs.h    extern SquidConfig2 Config2;
     extern char *ConfigFile;	/* NULL */
     extern char *IcpOpcodeStr[];
     extern const char *dns_error_message;	/* NULL */
     extern const char *log_tags[];
     extern char tmp_error_buf[ERROR_BUF_SZ];
     extern char *volatile debug_options;	/* NULL */
-    extern char ThisCache[SQUIDHOSTNAMELEN << 1];
-    extern char ThisCache2[SQUIDHOSTNAMELEN << 1];
+    extern char ThisCache[RFC2181_MAXHOSTNAMELEN << 1];
+    extern char ThisCache2[RFC2181_MAXHOSTNAMELEN << 1];
     extern char config_input_line[BUFSIZ];
     extern const char *DefaultConfigFile;	/* DEFAULT_CONFIG_FILE */
     extern const char *cfg_filename;	/* NULL */
@@ -67,6 +78,7 @@ extern "C"
     extern const char *pingStatusStr[];
     extern const char *storeStatusStr[];
     extern const char *swapStatusStr[];
+    class fde;
     extern fde *fd_table;		/* NULL */
     extern int Biggest_FD;		/* -1 */
     extern int Number_FD;		/* 0 */
@@ -79,7 +91,7 @@ extern "C"
     extern int config_lineno;	/* 0 */
     extern int do_mallinfo;		/* 0 */
     extern int opt_reuseaddr;	/* 1 */
-    extern int icmp_sock;		/* -1 */
+//DEAD    extern int icmp_sock;		/* -1 */
     extern int neighbors_do_private_keys;	/* 1 */
     extern int opt_catch_signals;	/* 1 */
     extern int opt_debug_stderr;	/* -1 */
@@ -109,11 +121,10 @@ extern "C"
     extern int n_disk_objects;	/* 0 */
     extern iostats IOStats;
 
-    extern struct _acl_deny_info_list *DenyInfoList;	/* NULL */
-
-    extern IPAddress theOutICPAddr;
+    extern struct acl_deny_info_list *DenyInfoList;	/* NULL */
 
-    extern IPAddress theOutSNMPAddr;
+//MOVED:icp_v2.cc    extern IPAddress theOutICPAddr;
+//MOVED:snmp_core.cc    extern IPAddress theOutSNMPAddr;
 
     extern struct timeval squid_start;
     extern int shutting_down;	/* 0 */
@@ -128,7 +139,7 @@ extern "C"
     extern double request_failure_ratio;	/* 0.0 */
     extern int store_hash_buckets;	/* 0 */
     extern hash_table *store_table;	/* NULL */
-    extern dlink_list ClientActiveRequests;
+//MOVED:dlink.h    extern dlink_list ClientActiveRequests;
     extern int hot_obj_count;	/* 0 */
     extern const int CacheDigestHashFuncCount;	/* 4 */
     extern CacheDigest *store_digest;	/* NULL */
@@ -48,6 +48,7 @@
 #include "wordlist.h"
 #include "SquidTime.h"
 #include "SwapDir.h"
+#include "IPAddress.h"
 
 /// \ingroup ServerProtocolICPInternal2
 static void icpLogIcp(const IPAddress &, log_type, int, const char *, int);
@@ -67,6 +68,9 @@ static icpUdpData *IcpQueueHead = NULL;
 /// \ingroup ServerProtocolICPInternal2
 static icpUdpData *IcpQueueTail = NULL;
 
+/// \ingroup ServerProtocolICPInternal2
+IPAddress theOutICPAddr;
+
 /* icp_common_t */
 _icp_common_t::_icp_common_t() : opcode(ICP_INVALID), version(0), length(0), reqnum(0), flags(0), pad(0), shostid(0)
 {}
@@ -1,19 +1,35 @@
-
+/*
+ * $Id$
+ */
 #ifndef SQUID_PCONN_H
 #define SQUID_PCONN_H
 
-/* forward decls */
+/**
+ \defgroup PConnAPI Persistent Connection API
+ \ingroup Component
+ *
+ \todo CLEANUP: Break multiple classes out of the generic pconn.h header
+ */
 
 class CacheManager;
-
 class PconnPool;
 
+/* for CBDATA_CLASS2() macros */
+#include "cbdata.h"
+/* for hash_link */
+#include "hash.h"
+/* for IOCB */
+#include "comm.h"
+
+/// \ingroup PConnAPI
 #define MAX_NUM_PCONN_POOLS 10
+
+/// \ingroup PConnAPI
 #define PCONN_HIST_SZ (1<<16)
 
+/// \ingroup PConnAPI
 class IdleConnList
 {
-
 public:
     IdleConnList(const char *key, PconnPool *parent);
     ~IdleConnList();
@@ -30,7 +46,7 @@ class IdleConnList
     static PF timeout;
 
 public:
-    hash_link hash;             /* must be first */
+    hash_link hash;             /** must be first */
 
 private:
     int *fds;
@@ -41,6 +57,15 @@ class IdleConnList
     CBDATA_CLASS2(IdleConnList);
 };
 
+
+class IPAddress;
+class StoreEntry;
+class IdleConnLimit;
+
+/* for hash_table */
+#include "hash.h"
+
+/// \ingroup PConnAPI
 class PconnPool
 {
 
@@ -64,22 +89,27 @@ class PconnPool
 
 };
 
+
+class CacheManager;
+class StoreEntry;
+class PconnPool;
+
+/// \ingroup PConnAPI
 class PconnModule
 {
 
 public:
-    /* the module is a singleton until we have instance based cachemanager
+    /** the module is a singleton until we have instance based cachemanager
      * management
      */
     static PconnModule * GetInstance();
-    /* A thunk to the still C like CacheManager callback api. */
+    /** A thunk to the still C like CacheManager callback api. */
     static void DumpWrapper(StoreEntry *e);
 
     PconnModule();
     void registerWithCacheManager(CacheManager & manager);
 
-    void add
-        (PconnPool *);
+    void add(PconnPool *);
 
     OBJH dump;
 
@@ -29,7 +29,6 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_PROTOS_H
 #define SQUID_PROTOS_H
 
@@ -39,7 +38,10 @@
 #include "Packer.h"
 /* for routines still in this file that take CacheManager parameters */
 #include "IPAddress.h"
-
+/* for parameters that still need these */
+#include "enums.h"
+/* some parameters stil need this */
+#include "wordlist.h"
 
 class CacheManager;
 class HttpRequestMethod;
@@ -59,6 +61,7 @@ SQUIDCEXTERN int logTypeIsATcpHit(log_type);
  * cache_cf.c
  */
 SQUIDCEXTERN void configFreeMemory(void);
+class MemBuf;
 SQUIDCEXTERN void wordlistCat(const wordlist *, MemBuf * mb);
 SQUIDCEXTERN void self_destruct(void);
 SQUIDCEXTERN void add_http_port(char *portspec);
@@ -185,6 +188,8 @@ class FwdState;
 /// \ingroup ServerProtocolFTPAPI
 SQUIDCEXTERN void ftpStart(FwdState *);
 
+class HttpRequest;
+
 /// \ingroup ServerProtocolFTPAPI
 SQUIDCEXTERN const char *ftpUrlWith2f(HttpRequest *);
 
@@ -211,6 +216,8 @@ SQUIDCEXTERN void whoisStart(FwdState *);
 
 
 /* http.c */
+/* for http_hdr_type field */
+#include "HttpHeader.h"
 SQUIDCEXTERN int httpCachable(const HttpRequestMethod&);
 SQUIDCEXTERN void httpStart(FwdState *);
 SQUIDCEXTERN mb_size_t httpBuildRequestPrefix(HttpRequest * request,
@@ -255,6 +262,7 @@ SQUIDCEXTERN void httpHdrCcUpdateStats(const HttpHdrCc * cc, StatHist * hist);
 SQUIDCEXTERN void httpHdrCcStatDumper(StoreEntry * sentry, int idx, double val, double size, int count);
 
 /* Http Header Tools */
+class HttpHeaderFieldInfo;
 SQUIDCEXTERN HttpHeaderFieldInfo *httpHeaderBuildFieldsInfo(const HttpHeaderFieldAttrs * attrs, int count);
 SQUIDCEXTERN void httpHeaderDestroyFieldsInfo(HttpHeaderFieldInfo * info, int count);
 SQUIDCEXTERN http_hdr_type httpHeaderIdByName(const char *name, int name_len, const HttpHeaderFieldInfo * attrs, int end);
@@ -433,6 +441,7 @@ SQUIDCEXTERN void peerSelect(HttpRequest *, StoreEntry *, PSC *, void *data);
 SQUIDCEXTERN void peerSelectInit(void);
 
 /* peer_digest.c */
+class PeerDigest;
 SQUIDCEXTERN PeerDigest *peerDigestCreate(peer * p);
 SQUIDCEXTERN void peerDigestNeeded(PeerDigest * pd);
 SQUIDCEXTERN void peerDigestNotePeerGone(PeerDigest * pd);
@@ -579,6 +588,7 @@ SQUIDCEXTERN void storeRebuildProgress(int sd_index, int total, int sofar);
 /*
  * store_swapin.c
  */
+class store_client;
 SQUIDCEXTERN void storeSwapInStart(store_client *);
 
 /*
@@ -667,12 +677,13 @@ SQUIDCEXTERN void refererCloseLog(void);
 SQUIDCEXTERN peer_t parseNeighborType(const char *s);
 
 /* tools.c */
-SQUIDCEXTERN void dlinkAdd(void *data, dlink_node *, dlink_list *);
-SQUIDCEXTERN void dlinkAddAfter(void *, dlink_node *, dlink_node *, dlink_list *);
-SQUIDCEXTERN void dlinkAddTail(void *data, dlink_node *, dlink_list *);
-SQUIDCEXTERN void dlinkDelete(dlink_node * m, dlink_list * list);
-SQUIDCEXTERN void dlinkNodeDelete(dlink_node * m);
-SQUIDCEXTERN dlink_node *dlinkNodeNew(void);
+//UNUSED	#include "dlink.h"
+//UNUSED	SQUIDCEXTERN void dlinkAdd(void *data, dlink_node *, dlink_list *);
+//UNUSED	SQUIDCEXTERN void dlinkAddAfter(void *, dlink_node *, dlink_node *, dlink_list *);
+//UNUSED	SQUIDCEXTERN void dlinkAddTail(void *data, dlink_node *, dlink_list *);
+//UNUSED	SQUIDCEXTERN void dlinkDelete(dlink_node * m, dlink_list * list);
+//UNUSED	SQUIDCEXTERN void dlinkNodeDelete(dlink_node * m);
+//UNUSED	SQUIDCEXTERN dlink_node *dlinkNodeNew(void);
 
 SQUIDCEXTERN void kb_incr(kb_t *, size_t);
 SQUIDCEXTERN int stringHasWhitespace(const char *);
@@ -798,14 +809,15 @@ SQUIDCEXTERN DWORD WIN32_IpAddrChangeMonitorInit();
 #endif
 
 /* external_acl.c */
+class external_acl;
 SQUIDCEXTERN void parse_externalAclHelper(external_acl **);
 
 SQUIDCEXTERN void dump_externalAclHelper(StoreEntry * sentry, const char *name, const external_acl *);
 
 SQUIDCEXTERN void free_externalAclHelper(external_acl **);
 
 typedef void EAH(void *data, void *result);
-
+class ACLChecklist;
 SQUIDCEXTERN void externalAclLookup(ACLChecklist * ch, void *acl_data, EAH * handler, void *data);
 
 SQUIDCEXTERN void externalAclInit(void);
@@ -18,3 +18,11 @@ libheap_a_SOURCES = heap/store_heap_replacement.h heap/store_heap_replacement.cc
 INCLUDES      = -I. -I$(top_builddir)/include -I$(top_srcdir)/include \
 	-I$(top_srcdir)/src
 
+check_PROGRAMS= testHeaders
+
+## Special Universal .h dependency test script
+## aborts if error encountered
+testHeaders: heap/*.h
+	$(top_srcdir)/test-suite/testheaders.sh "$(CXXCOMPILE)" "heap" || exit 1
+## ./ has no .h files.
+## ./lru/ has no .h files.
@@ -1,3 +1,13 @@
+/*
+ * $Id$
+ */
+#ifndef _SQUIDINC_STORE_HEAP_REPLACEMENT_H
+#define _SQUIDINC_STORE_HEAP_REPLACEMENT_H
+
+#include "heap.h"
+
 extern heap_key HeapKeyGen_StoreEntry_LFUDA(void *entry, double age);
 extern heap_key HeapKeyGen_StoreEntry_GDSF(void *entry, double age);
 extern heap_key HeapKeyGen_StoreEntry_LRU(void *entry, double age);
+
+#endif /* _SQUIDINC_STORE_HEAP_REPLACEMENT_H */
@@ -1,4 +1,3 @@
-
 /*
  * $Id: snmp_core.cc,v 1.82 2008/01/22 21:07:19 rousskov Exp $
  *
@@ -36,10 +35,13 @@
 #include "comm.h"
 #include "cache_snmp.h"
 #include "ACLChecklist.h"
+#include "IPAddress.h"
 
 #define SNMP_REQUEST_SIZE 4096
 #define MAX_PROTOSTAT 5
 
+IPAddress theOutSNMPAddr;
+
 typedef struct _mib_tree_entry mib_tree_entry;
 typedef oid *(instance_Fn) (oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn);
 
@@ -255,7 +255,9 @@ using namespace Squid;
 #include <math.h>
 #endif
 
+#if 0  // moved to include/rfc2181.h - RFC defined constants
 #define SQUIDHOSTNAMELEN 256
+#endif
 
 #define SQUID_MAXPATHLEN 256
 #ifndef MAXPATHLEN
@@ -299,11 +301,6 @@ struct rusage
 SQUIDCEXTERN size_t getpagesize(void);
 #endif /* _SQUID_MSWIN_ */
 
-#ifndef BUFSIZ
-#define BUFSIZ  4096		/* make reasonable guess */
-#endif
-
-
 #ifndef SA_RESTART
 #define SA_RESTART 0
 #endif
@@ -612,7 +612,7 @@ storeDirGetUFSStats(const char *path, int *totl_kb, int *free_kb, int *totl_in,
 }
 
 void
-allocate_new_swapdir(_SquidConfig::_cacheSwap * swap)
+allocate_new_swapdir(SquidConfig::_cacheSwap * swap)
 {
     if (swap->swapDirs == NULL) {
         swap->n_allocated = 4;
@@ -630,7 +630,7 @@ allocate_new_swapdir(_SquidConfig::_cacheSwap * swap)
 }
 
 void
-free_cachedir(_SquidConfig::_cacheSwap * swap)
+free_cachedir(SquidConfig::_cacheSwap * swap)
 {
     int i;
     /* DON'T FREE THESE FOR RECONFIGURE */
@@ -1,4 +1,3 @@
-
 /*
  * $Id: structs.h,v 1.575 2008/02/11 22:28:47 rousskov Exp $
  *
@@ -30,7 +29,6 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_STRUCTS_H
 #define SQUID_STRUCTS_H
 
@@ -43,13 +41,13 @@
 /* needed for the global config */
 #include "HttpHeader.h"
 
-struct _acl_name_list
+struct acl_name_list
 {
     char name[ACL_NAME_SZ];
     acl_name_list *next;
 };
 
-struct _acl_deny_info_list
+struct acl_deny_info_list
 {
     err_type err_page_id;
     char *err_page_name;
@@ -66,6 +64,8 @@ struct _header_mangler
     char *replacement;
 };
 
+class ACLChecklist;
+
 #if SQUID_SNMP
 
 struct _snmp_request_t
@@ -88,36 +88,37 @@ struct _snmp_request_t
 
 #endif
 
+class ACLList;
 
-struct _acl_address
+struct acl_address
 {
     acl_address *next;
     ACLList *aclList;
 
     IPAddress addr;
 };
 
-struct _acl_tos
+struct acl_tos
 {
     acl_tos *next;
     ACLList *aclList;
     int tos;
 };
 
-struct _acl_size_t
+struct acl_size_t
 {
     acl_size_t *next;
     ACLList *aclList;
     int64_t size;
 };
 
-struct _ushortlist
+struct ushortlist
 {
     u_short i;
     ushortlist *next;
 };
 
-struct _relist
+struct relist
 {
     char *pattern;
     regex_t regex;
@@ -135,13 +136,10 @@ struct _relist
 /* forward decl for SquidConfig, see RemovalPolicy.h */
 
 class RemovalPolicySettings;
-
-
 class external_acl;
-
 class Store;
 
-struct _SquidConfig
+struct SquidConfig
 {
 
     struct
@@ -694,9 +692,10 @@ struct _SquidConfig
     char *accept_filter;
 };
 
-struct _SquidConfig2
-{
+SQUIDCEXTERN SquidConfig Config;
 
+struct SquidConfig2
+{
     struct
     {
         int enable_purge;
@@ -708,6 +707,8 @@ struct _SquidConfig2
     gid_t effectiveGroupID;
 };
 
+SQUIDCEXTERN SquidConfig2 Config2;
+
 struct _close_handler
 {
     PF *handler;
@@ -917,7 +918,9 @@ struct _cd_guess_stats
 
 #endif
 
-struct _peer
+class PeerDigest;
+
+struct peer
 {
     u_int index;
     char *name;
@@ -1594,6 +1597,8 @@ struct _Logfile
     int syslog_priority;
 };
 
+class logformat_token;
+
 struct _logformat
 {
     char *name;
@@ -1,11 +1,14 @@
+#if 0
 #include "squid.h"
+#endif
+
 #include <cppunit/TestAssert.h>
 
-#include "CapturingStoreEntry.h"
-#include "AsyncCallQueue.h"
-#include "Mem.h"
 #include "testEvent.h"
 #include "event.h"
+#include "AsyncCallQueue.h"
+#include "CapturingStoreEntry.h"
+#include "Mem.h"
 
 
 CPPUNIT_TEST_SUITE_REGISTRATION( testEvent );
@@ -1,13 +1,18 @@
+#if 0
 #include "squid.h"
+#endif
+
 #include <cppunit/TestAssert.h>
 
-#include "AsyncEngine.h"
-#include "AsyncCallQueue.h"
-#include "Mem.h"
 #include "testEventLoop.h"
 #include "EventLoop.h"
-#include "event.h"
+#include "Mem.h"
 
+#if 0
+#include "AsyncEngine.h"
+#include "AsyncCallQueue.h"
+#include "event.h"
+#endif
 
 CPPUNIT_TEST_SUITE_REGISTRATION( testEventLoop );
 
@@ -1,4 +0,0 @@
-/* This test tests that the header below can be processed on its own with
- * no other #includes. Dont add any!
- */
-#include "ACL.h"
@@ -1,4 +0,0 @@
-/* This test tests that the header below can be processed on its own with
- * no other #includes. Dont add any!
- */
-#include "AsyncEngine.h"
@@ -1,4 +0,0 @@
-/* This test tests that the header below can be processed on its own with
- * no other #includes. Dont add any!
- */
-#include "CompletionDispatcher.h"
@@ -1,4 +0,0 @@
-/* This test tests that the header below can be processed on its own with
- * no other #includes. Dont add any!
- */
-#include "ConfigParser.h"
@@ -1,4 +0,0 @@
-/* This test tests that the header below can be processed on its own with
- * no other #includes. Dont add any!
- */
-#include "EventLoop.h"
@@ -1,4 +0,0 @@
-/* This test tests that the header below can be processed on its own with
- * no other #includes. Dont add any!
- */
-#include "HttpHeader.h"
@@ -1,4 +0,0 @@
-/* This test tests that the header below can be processed on its own with
- * no other #includes. Dont add any!
- */
-#include "HttpHeaderRange.h"
@@ -1,4 +0,0 @@
-/* This test tests that the header below can be processed on its own with
- * no other #includes. Dont add any!
- */
-#include "HttpReply.h"
@@ -1,4 +0,0 @@
-/* This test tests that the header below can be processed on its own with
- * no other #includes. Dont add any!
- */
-#include "HttpRequestMethod.h"
@@ -1,4 +0,0 @@
-/* This test tests that the header below can be processed on its own with
- * no other #includes. Dont add any!
- */
-#include "RemovalPolicy.h"
@@ -1,4 +0,0 @@
-/* This test tests that the header below can be processed on its own with
- * no other #includes. Dont add any!
- */
-#include "SquidTime.h"
@@ -1,4 +0,0 @@
-/* This test tests that the header below can be processed on its own with
- * no other #includes. Dont add any!
- */
-#include "Store.h"
@@ -1,4 +0,0 @@
-/* This test tests that the header below can be processed on its own with
- * no other #includes. Dont add any!
- */
-#include "StoreEntryStream.h"
@@ -1,4 +0,0 @@
-/* This test tests that the header below can be processed on its own with
- * no other #includes. Dont add any!
- */
-#include "URL.h"
@@ -1,4 +0,0 @@
-/* This test tests that the header below can be processed on its own with
- * no other #includes. Dont add any!
- */
-#include "URLScheme.h"
@@ -1,4 +0,0 @@
-/* This test tests that the header below can be processed on its own with
- * no other #includes. Dont add any!
- */
-#include "cbdata.h"
@@ -1,4 +0,0 @@
-/* This test tests that the header below can be processed on its own with
- * no other #includes. Dont add any!
- */
-#include "client_side_request.h"
@@ -1,4 +0,0 @@
-/* This test tests that the header below can be processed on its own with
- * no other #includes. Dont add any!
- */
-#include "comm.h"
@@ -1,4 +0,0 @@
-/* This test tests that the header below can be processed on its own with
- * no other #includes. Dont add any!
- */
-#include "dlink.h"
@@ -1,4 +0,0 @@
-/* This test tests that the header below can be processed on its own with
- * no other #includes. Dont add any!
- */
-#include "errorpage.h"
@@ -1,4 +0,0 @@
-/* This test tests that the header below can be processed on its own with
- * no other #includes. Dont add any!
- */
-#include "event.h"
@@ -1,4 +0,0 @@
-/* This test tests that the header below can be processed on its own with
- * no other #includes. Dont add any!
- */
-#include "wordlist.h"
@@ -1,9 +1,12 @@
+#if 0
 #include "squid.h"
+#endif
+
 #include <cppunit/TestAssert.h>
 
-#include "Mem.h"
 #include "testHttpRequest.h"
 #include "HttpRequest.h"
+#include "Mem.h"
 
 
 CPPUNIT_TEST_SUITE_REGISTRATION( testHttpRequest );
@@ -6,7 +6,6 @@
 #include <cppunit/TestResultCollector.h>
 #include <cppunit/TestRunner.h>
 
-
 int
 main( int argc, char* argv[] )
 {
@@ -34,5 +33,3 @@ main( int argc, char* argv[] )
 
     return result.wasSuccessful() ? 0 : 1;
 }
-
-
@@ -1,8 +1,11 @@
+#if 0
 #include "squid.h"
-#include "event.h"
-#include "Mem.h"
-#include "SquidString.h"
+#endif
+
 #include "testString.h"
+#include "SquidString.h"
+#include "Mem.h"
+#include "event.h"
 
 CPPUNIT_TEST_SUITE_REGISTRATION( testString );
 
@@ -1,11 +1,13 @@
+#if 0
 #include "squid.h"
+#endif
+
 #include <sstream>
 #include <cppunit/TestAssert.h>
 
-#include "Mem.h"
 #include "testURL.h"
 #include "URL.h"
-
+#include "Mem.h"
 
 CPPUNIT_TEST_SUITE_REGISTRATION( testURL );
 
@@ -1,4 +1,7 @@
+#if 0
 #include "squid.h"
+#endif
+
 #include <stdexcept>
 
 #include "testUfs.h"
@@ -1,4 +1,3 @@
-
 /*
  * $Id: test_http_range.cc,v 1.3 2007/05/29 13:31:48 amosjeffries Exp $
  *
@@ -33,12 +32,21 @@
  *
  */
 
+#if 0
 #include "squid.h"
-#include "Mem.h"
 //#include "Store.h"
-#include "HttpHeaderRange.h"
 //#include "client_side_request.h"
+#endif
+
+/** \todo CLEANUP: This file shoudl be called something_stub.cc */
+
+#include "HttpHeaderRange.h"
+#include "HttpHeader.h"
+#include "Mem.h"
+
+#if 0
 #include "ACLChecklist.h"
+#endif
 
 /* Stub routines */
 void
@@ -84,8 +84,6 @@ SQUIDCEXTERN int setresuid(uid_t, uid_t, uid_t);
 
 SQUIDCEXTERN void (*failure_notify) (const char *);
 
-MemAllocator *dlink_node_pool = NULL;
-
 void
 releaseServerSockets(void)
 {
@@ -1056,93 +1054,6 @@ logsFlush(void)
         fflush(debug_log);
 }
 
-dlink_node *
-dlinkNodeNew()
-{
-    if (dlink_node_pool == NULL)
-        dlink_node_pool = memPoolCreate("Dlink list nodes", sizeof(dlink_node));
-
-    /* where should we call delete dlink_node_pool;dlink_node_pool = NULL; */
-    return (dlink_node *)dlink_node_pool->alloc();
-}
-
-/* the node needs to be unlinked FIRST */
-void
-dlinkNodeDelete(dlink_node * m)
-{
-    if (m == NULL)
-        return;
-
-    dlink_node_pool->free(m);
-}
-
-void
-dlinkAdd(void *data, dlink_node * m, dlink_list * list)
-{
-    m->data = data;
-    m->prev = NULL;
-    m->next = list->head;
-
-    if (list->head)
-        list->head->prev = m;
-
-    list->head = m;
-
-    if (list->tail == NULL)
-        list->tail = m;
-}
-
-void
-dlinkAddAfter(void *data, dlink_node * m, dlink_node * n, dlink_list * list)
-{
-    m->data = data;
-    m->prev = n;
-    m->next = n->next;
-
-    if (n->next)
-        n->next->prev = m;
-    else {
-        assert(list->tail == n);
-        list->tail = m;
-    }
-
-    n->next = m;
-}
-
-void
-dlinkAddTail(void *data, dlink_node * m, dlink_list * list)
-{
-    m->data = data;
-    m->next = NULL;
-    m->prev = list->tail;
-
-    if (list->tail)
-        list->tail->next = m;
-
-    list->tail = m;
-
-    if (list->head == NULL)
-        list->head = m;
-}
-
-void
-dlinkDelete(dlink_node * m, dlink_list * list)
-{
-    if (m->next)
-        m->next->prev = m->prev;
-
-    if (m->prev)
-        m->prev->next = m->next;
-
-    if (m == list->head)
-        list->head = m->next;
-
-    if (m == list->tail)
-        list->tail = m->prev;
-
-    m->next = m->prev = NULL;
-}
-
 void
 kb_incr(kb_t * k, size_t v)
 {
@@ -37,7 +37,7 @@
 #define SQUID_TYPEDEFS_H
 
 typedef unsigned int store_status_t;
-typedef unsigned int ping_status_t;
+//MOVED src/Store.h (only use)		typedef unsigned int ping_status_t;
 typedef unsigned int swap_status_t;
 typedef signed int sfileno;
 typedef signed int sdirno;
@@ -47,18 +47,13 @@ typedef struct
     size_t bytes;
     size_t kb;
 }
-
 kb_t;
 
-typedef struct _acl_time_data acl_time_data;
-
-typedef struct _acl_name_list acl_name_list;
+//UNUSED		typedef struct _acl_time_data acl_time_data;
+//UNUSED		typedef struct _acl_name_list acl_name_list;
+//UNUSED		typedef struct _acl_deny_info_list acl_deny_info_list;
+//UNUSED		typedef class AuthUser auth_user_t;
 
-typedef struct _acl_deny_info_list acl_deny_info_list;
-
-/// \ingroup AuthAPI
-/// \deprecated Use AuthUser instead.
-typedef class AuthUser auth_user_t;
 
 /// \ingroup AuthAPI
 /// \deprecated Use AuthUserHashPointer instead.
@@ -74,28 +69,20 @@ typedef struct AuthUserIP auth_user_ip_t;
 class AuthConfig;
 typedef Vector<AuthConfig *> authConfig;
 
-typedef struct _acl_snmp_comm acl_snmp_comm;
-
-typedef class ACLList acl_list;
-
-typedef struct _acl_address acl_address;
-
-typedef struct _acl_tos acl_tos;
-
-typedef struct _acl_size_t acl_size_t;
-
-class ACLChecklist;
-
-typedef struct _ushortlist ushortlist;
-
-typedef struct _relist relist;
+//UNUSED		typedef struct _acl_snmp_comm acl_snmp_comm;
+//UNUSED		typedef class ACLList acl_list;
+//UNUSED		typedef struct _acl_address acl_address;
+//UNUSED		typedef struct _acl_tos acl_tos;
+//UNUSED		typedef struct _acl_size_t acl_size_t;
+//UNUSED		class ACLChecklist;
+//UNUSED		typedef struct _ushortlist ushortlist;
+//UNUSED		typedef struct _relist relist;
 
 struct http_port_list;
 struct https_port_list;
 
-typedef struct _SquidConfig SquidConfig;
-
-typedef struct _SquidConfig2 SquidConfig2;
+//UNUSED	typedef struct _SquidConfig SquidConfig;
+//UNUSED	typedef struct _SquidConfig2 SquidConfig2;
 
 typedef struct _close_handler close_handler;
 
@@ -105,27 +92,25 @@ typedef struct _dwrite_q dwrite_q;
 
 typedef struct _ETag ETag;
 
-class fde;
+//UNUSED		class fde;
 
 typedef struct _fileMap fileMap;
 
 typedef struct _HttpHeaderFieldAttrs HttpHeaderFieldAttrs;
 
-class HttpHeaderFieldInfo;
-
-class HttpHeader;
-
-class HttpHdrCc;
+//UNUSED		class HttpHeaderFieldInfo;
+//UNUSED		class HttpHeader;
+//UNUSED		class HttpHdrCc;
 
 typedef struct _TimeOrTag TimeOrTag;
 
-class HttpHeaderFieldStat;
+//UNUSED		class HttpHeaderFieldStat;
 
 typedef struct _HttpHeaderStat HttpHeaderStat;
 
 typedef struct _HttpBody HttpBody;
 
-class HttpReply;
+//UNUSED		class HttpReply;
 
 typedef struct _ConnCloseHelperData ConnCloseHelperData;
 
@@ -139,9 +124,9 @@ typedef struct _DynPool DynPool;
 
 typedef struct _DigestFetchState DigestFetchState;
 
-class PeerDigest;
+//UNUSED		class PeerDigest;
 
-typedef struct _peer peer;
+//UNUSED typedef struct _peer peer;
 
 typedef struct _net_db_name net_db_name;
 
@@ -155,21 +140,19 @@ typedef struct _Meta_data Meta_data;
 
 typedef struct _iostats iostats;
 
-class MemBuf;
+//UNUSED		class MemBuf;
 
-class store_client;
+//UNUSED		class store_client;
 
-class StoreEntry;
-
-class SwapDir;
+//UNUSED		class SwapDir;
 
 typedef struct _http_state_flags http_state_flags;
 
 typedef struct _header_mangler header_mangler;
 
 typedef struct _body_size body_size;
 
-class HttpRequest;
+//UNUSED		class HttpRequest;
 
 typedef struct _cachemgr_passwd cachemgr_passwd;
 
@@ -196,8 +179,6 @@ typedef struct _link_list link_list;
 
 typedef struct _Logfile Logfile;
 
-typedef struct _logformat_token logformat_token;
-
 typedef struct _logformat logformat;
 
 typedef struct _customlog customlog;
@@ -225,7 +206,7 @@ typedef void DTCB(int errflag, void *data);	/* disk trunc CB */
 typedef void FQDNH(const char *, void *);
 typedef void IDCB(const char *ident, void *data);
 typedef void IPH(const ipcache_addrs *, void *);
-typedef void IRCB(peer *, peer_t, protocol_t, void *, void *data);
+typedef void IRCB(struct peer *, peer_t, protocol_t, void *, void *data);
 
 class FwdServer;
 typedef void PSC(FwdServer *, void *);
@@ -240,6 +221,7 @@ typedef int WRITE_HANDLER(int, const char *, int);
 typedef int QS(const void *, const void *);	/* qsort */
 typedef void STABH(void *);
 typedef void ERCB(int fd, void *, size_t);
+class StoreEntry;
 typedef void OBJH(StoreEntry *);
 typedef void SIGHDLR(int sig);
 typedef void STVLDCB(void *, int, int);
@@ -1,4 +1,3 @@
-
 /*
  * $Id: wordlist.h,v 1.1 2006/04/23 11:10:32 robertc Exp $
  *
@@ -30,7 +29,6 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-
 #ifndef SQUID_WORDLIST_H
 #define SQUID_WORDLIST_H
 
@@ -17,11 +17,15 @@
 #include <unistd.h>
 #endif
 
+#if 0
 #define assert(X) {if (!(X)) exit (1);}
 #include "splay.h"
 #undef assert
-#include "util.h"
+#else
+#include "splay.h"
+#endif
 
+#include "util.h"
 
 class intnode
 {
@@ -1,4 +1,3 @@
-
 /*
  * $Id: test_tools.cc,v 1.11 2008/02/26 18:52:54 rousskov Exp $
  */
@@ -0,0 +1,44 @@
+#!/bin/bash
+#
+# test all header files (.h) for dependancy issues.
+#
+# Ideally this test should be performed twice before any code is accepted.
+# With or without inline enabled.  This is needed because the .cci files
+#  are only included into the .h files when inline mode is enabled.
+#
+# This script should be run from the makefile with the directory path and ccflags
+#
+cc="${1}"
+
+if [ "${2}" == "" ]; then
+	dir="."
+else
+	dir="${2}"
+fi
+
+for f in `cd ${dir} && ls -1 *.h 2>/dev/null`; do
+	echo -n "Testing ${dir}/${f} ..."
+	if [[ "${f}" == "cf_gen_defines.h" || "${f}" == "cf_parser.h" ]]; then
+		echo " IGNORED!"
+		continue
+	fi
+	if [ ${dir}/${f} -nt ./testHeaderDeps_${f/.h/}.o ]; then
+		(	echo "/* This file is AUTOMATICALLY GENERATED. DO NOT ALTER IT */"
+			echo "#include \"${dir}/${f}\" "
+			echo "int main( int argc, char* argv[] ) { return 0; } "
+		) >./testHeaderDeps_${f/.h/}.cc
+
+		# run compile test on the new file.
+		# DEBUG: echo "TRY: ${cc} -o testHeaderDeps.o ./testHeaderDeps_${f/.h/}.cc"
+		${cc} -o testHeaderDeps_${f/.h/}.o ./testHeaderDeps_${f/.h/}.cc
+		rm ./testHeaderDeps_${f/.h/}.cc
+	fi
+	if [ ! -f testHeaderDeps_${f/.h/}.o ]; then
+		rm testHeaders
+		exit 1
+	fi
+	echo "OK."
+	# unit-tests require an app to run.
+	# our most-recent object suits this purpose
+	cp ./testHeaderDeps_${f/.h/}.o ./testHeaders
+done
@@ -13,7 +13,11 @@ INCLUDES        = -I. -I$(srcdir) -I$(top_builddir)/include -I$(top_srcdir)/incl
 INCLUDES	+= @SQUID_CPPUNIT_INC@
 
 TESTS=$(check_PROGRAMS)
-check_PROGRAMS=
+#check_PROGRAMS= testHeaders
+
+### Special Universal .h dependency test script
+#testHeaders: *.h
+# ./ has no .h files
 
 SUBDIRS		= 
 
@@ -1,4 +1,3 @@
-
 /*
  * $Id: cachemgr.cc,v 1.6 2007/12/14 23:11:53 amosjeffries Exp $
  *
@@ -135,6 +134,7 @@ extern "C"
 #include "assert.h"
 #include "util.h"
 #include "IPAddress.h"
+#include "getfullhostname.h"
 
 #ifndef DEFAULT_CACHEMGR_CONFIG
 #define DEFAULT_CACHEMGR_CONFIG "/etc/squid/cachemgr.conf"