@@ -21,6 +21,61 @@ Changes to Squid-2.1 ():
 	  potentially causing under-utilized cache digests
 	- Maintain refreshCheck statistics on per-protocol basis so we
 	  can tell why ICP or Digests return too many misses, etc.
+	- Fixed delay_pools.c class2/class3 typo (Simon Woods).
+	- Changed squid.conf's default access controls to deny all
+	  HTTP requests.  Admins must write ACL rules to specifically
+	  allow their local clients.
+	- Patched French error messages (Mathias HERBERTS).
+	- NextStep porting fixes by Mike Laster:
+		- use xstrdup() in cf_gen.c
+		- check for putenv() in configure
+		- #define S_ISDIR macro
+	- Added --disable-poll configure option (Henrik Nordstrom).
+	- Fixed internal URL hostname case bugs (Henrik Nordstrom).
+	- Patched ftp.c so we never cache autenticated FTP requests
+	  (Henrik Nordstrom).
+	- Fixed FTP authentication. We tried to unescape authentication
+	  given by basic authentication which is not URL escaped
+	  (Henrik Nordstrom).
+	- Fixed HTTP version for common logfile format (Henrik Nordstrom).
+	- Added 'redirect_rewrites_host_header' option to disable rewriting
+	  of Host header for redirector responses (Henrik Nordstrom).
+	- Allow semi-customized error message signatures (Henrik Nordstrom).
+	- Fixed bug with errors for unsupported requests (Henrik Nordstrom).
+	- Fixed handling of blank lines in ACL input files (Henrik
+	  Nordstrom).
+	- Changed proxy_auth ACL type to consist of a list of valid
+	  users. REQUIRED == any (same as ident ACL). ACL type user
+	  changed to ident since this is what it really is.
+	  (Henrik Nordstrom).
+	- Fixed long URL bugs; make sure 'log_uri' never exceeds
+	  MAX_URL bytes.
+	- Allow comments in external ACL files (Gerhard Wiesinger).
+	- Added 'range_offset_limit' configuration option.  Requests
+	  with ranges that start after this value will be passed
+	  on unmodified, and Squid will not cache the response
+	  (Henrik Nordstrom).
+	- Added Client HTTP Hit byte counters to 'counters' output
+	  (Douglas Swarin).
+	- Got Squid to compile with --enable-async-io on FreeBSD.
+	- Fixed infinite loop bug for cachemgr 'config' option.
+	- Fixed cachability bugs for replies with Pragma: no-cache.
+	- Made content-type multipart/x-mixed-replace uncachable.
+	- Y2K fix for parsing dates in "Wed Jun  9 01:29:59 1993 GMT"
+	  format (Richard Kettlewell).
+	- Fixed passing -s option to dnsserver processes (Alvaro Jose
+	  Fernandez Lago).
+	- Changed proxy_auth to work on internal objects and when in
+	  accelerator mode. (Henrik Nordstrom)
+	- Added login=user:password option to cache_peer directive to
+	  be used from a dial-up cache where the parent requires proxy
+	  authentication. (Henrik Nordstrom)
+	- If you want to "auto-login", then use a URL on the form
+	  http://username:password@server/.... Squid now picks this up
+	  when going direct, and turns it into basic WWW
+	  authentication.  It is also possible to do automatic login to
+	  certain servers by using a redirector to add the needed
+	  authentication information.  (Henrik Nordstrom)
 
 Changes to Squid-2.0 (October 2, 1998):
 
@@ -1,5 +1,8 @@
 Our Todo List
 
+()	dont re-sibling requests which came from a sibling
+()
+
 (1) is high priority, (5) is low priority
 (**) Means we need this for the real 1.2 release
 ==============================================================================
@@ -64,17 +64,15 @@ ac_help="$ac_help
                           is broken on some platforms.  If you think you are
                           smarter than the configure script, you may enable
                           poll with this option.
-"
+  --disable-poll          Disable the use of poll()."
 ac_help="$ac_help
   --disable-http-violations
                           This allows you to remove code which is known to
-                          violate the HTTP protocol specification.
-"
+                          violate the HTTP protocol specification."
 ac_help="$ac_help
   --enable-ipf-transparent
                           Enable Transparent Proxy support for systems
-                          using IP-Filter network address redirection.
-"
+                          using IP-Filter network address redirection."
 
 # Initialize some variables set by options.
 # The variables have the same names as the options, with
@@ -583,7 +581,7 @@ fi
 
 
 
-# From configure.in Revision: 1.158 
+# From configure.in Revision: 1.159.2.7 
 ac_aux_dir=
 for ac_dir in cfgaux $srcdir/cfgaux; do
   if test -f $ac_dir/install-sh; then
@@ -611,7 +609,7 @@ else { echo "configure: error: can not run $ac_config_sub" 1>&2; exit 1; }
 fi
 
 echo $ac_n "checking host system type""... $ac_c" 1>&6
-echo "configure:615: checking host system type" >&5
+echo "configure:613: checking host system type" >&5
 
 host_alias=$host
 case "$host_alias" in
@@ -679,7 +677,7 @@ PRESET_CFLAGS="$CFLAGS"
 # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:683: checking for $ac_word" >&5
+echo "configure:681: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -708,7 +706,7 @@ if test -z "$CC"; then
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:712: checking for $ac_word" >&5
+echo "configure:710: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -756,7 +754,7 @@ fi
 fi
 
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:760: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
+echo "configure:758: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
 
 ac_ext=c
 # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
@@ -766,11 +764,11 @@ ac_link='${CC-cc} -o conftest $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS
 cross_compiling=$ac_cv_prog_cc_cross
 
 cat > conftest.$ac_ext <<EOF
-#line 770 "configure"
+#line 768 "configure"
 #include "confdefs.h"
 main(){return(0);}
 EOF
-if { (eval echo configure:774: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:772: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   ac_cv_prog_cc_works=yes
   # If we can't run a trivial program, we are probably using a cross compiler.
   if (./conftest; exit) 2>/dev/null; then
@@ -790,12 +788,12 @@ if test $ac_cv_prog_cc_works = no; then
   { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
 fi
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
-echo "configure:794: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "configure:792: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
 echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
 cross_compiling=$ac_cv_prog_cc_cross
 
 echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
-echo "configure:799: checking whether we are using GNU C" >&5
+echo "configure:797: checking whether we are using GNU C" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -804,7 +802,7 @@ else
   yes;
 #endif
 EOF
-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:808: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:806: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
   ac_cv_prog_gcc=yes
 else
   ac_cv_prog_gcc=no
@@ -819,7 +817,7 @@ if test $ac_cv_prog_gcc = yes; then
   ac_save_CFLAGS="$CFLAGS"
   CFLAGS=
   echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
-echo "configure:823: checking whether ${CC-cc} accepts -g" >&5
+echo "configure:821: checking whether ${CC-cc} accepts -g" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1085,13 +1083,23 @@ if test "${enable_async_io+set}" = set; then
   enableval="$enable_async_io"
    if test "$enableval" = "yes" ; then
     echo "Async I/O enabled"
+    async_io=yes
     cat >> confdefs.h <<\EOF
 #define USE_ASYNC_IO 1
 EOF
 
     ASYNC_OBJS='$(ASYNC_OBJS)'
     SQUID_PTHREAD_LIB='$(PTHREADLIB)'
     CFLAGS="$CFLAGS -D_REENTRANT"
+    case "$host" in
+    i386-unknown-freebsd*)
+    	if test "$GCC" = "yes" ; then
+	    if test -z "$PRESET_LDFLAGS"; then
+		LDFLAGS="$LDFLAGS -pthread"
+	    fi
+	fi
+	;;
+    esac
   fi
 
 fi
@@ -1319,10 +1327,17 @@ fi
 # Check whether --enable-poll or --disable-poll was given.
 if test "${enable_poll+set}" = set; then
   enableval="$enable_poll"
-   if test "$enableval" = "yes" ; then
+   
+  case "$enableval" in
+  yes)
     echo "Forcing poll() to be enabled"
     ac_cv_func_poll='yes'
-  fi
+    ;;
+  no)
+    echo "Forcing poll() to be disabled"
+    ac_cv_func_poll='no'
+    ;;
+  esac
 
 fi
 
@@ -1371,10 +1386,17 @@ case "$host" in
 		ac_cv_prog_CC="$CC"
 	fi
 	;;
+    *-hp-hpux*)
+	if test "$ac_cv_prog_CC" = "cc" ; then
+		echo "adding '-Ae' to cc args for $host"
+		CC="cc -Ae";
+		ac_cv_prog_CC="$CC"
+	fi
+	;;
 esac
 
 echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
-echo "configure:1378: checking how to run the C preprocessor" >&5
+echo "configure:1400: checking how to run the C preprocessor" >&5
 # On Suns, sometimes $CPP names a directory.
 if test -n "$CPP" && test -d "$CPP"; then
   CPP=
@@ -1389,13 +1411,13 @@ else
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp.
   cat > conftest.$ac_ext <<EOF
-#line 1393 "configure"
+#line 1415 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1399: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1421: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   :
@@ -1406,13 +1428,13 @@ else
   rm -rf conftest*
   CPP="${CC-cc} -E -traditional-cpp"
   cat > conftest.$ac_ext <<EOF
-#line 1410 "configure"
+#line 1432 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1416: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1438: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   :
@@ -1445,7 +1467,7 @@ echo "$ac_t""$CPP" 1>&6
 # SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
 # ./install, which can be erroneously created by make from ./install.sh.
 echo $ac_n "checking for a BSD compatible install""... $ac_c" 1>&6
-echo "configure:1449: checking for a BSD compatible install" >&5
+echo "configure:1471: checking for a BSD compatible install" >&5
 if test -z "$INSTALL"; then
 if eval "test \"`echo '$''{'ac_cv_path_install'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -1497,7 +1519,7 @@ test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
 # Extract the first word of "ranlib", so it can be a program name with args.
 set dummy ranlib; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1501: checking for $ac_word" >&5
+echo "configure:1523: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1524,7 +1546,7 @@ else
 fi
 
 echo $ac_n "checking whether ln -s works""... $ac_c" 1>&6
-echo "configure:1528: checking whether ln -s works" >&5
+echo "configure:1550: checking whether ln -s works" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_LN_S'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1547,7 +1569,7 @@ fi
 # Extract the first word of "sh", so it can be a program name with args.
 set dummy sh; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1551: checking for $ac_word" >&5
+echo "configure:1573: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_SH'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1579,7 +1601,7 @@ fi
 # Extract the first word of "false", so it can be a program name with args.
 set dummy false; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1583: checking for $ac_word" >&5
+echo "configure:1605: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_FALSE'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1611,7 +1633,7 @@ fi
 # Extract the first word of "true", so it can be a program name with args.
 set dummy true; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1615: checking for $ac_word" >&5
+echo "configure:1637: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_TRUE'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1643,7 +1665,7 @@ fi
 # Extract the first word of "rm", so it can be a program name with args.
 set dummy rm; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1647: checking for $ac_word" >&5
+echo "configure:1669: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_RM'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1675,7 +1697,7 @@ fi
 # Extract the first word of "mv", so it can be a program name with args.
 set dummy mv; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1679: checking for $ac_word" >&5
+echo "configure:1701: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_MV'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1707,7 +1729,7 @@ fi
 # Extract the first word of "mkdir", so it can be a program name with args.
 set dummy mkdir; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1711: checking for $ac_word" >&5
+echo "configure:1733: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_MKDIR'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1739,7 +1761,7 @@ fi
 # Extract the first word of "ln", so it can be a program name with args.
 set dummy ln; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1743: checking for $ac_word" >&5
+echo "configure:1765: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_LN'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1771,7 +1793,7 @@ fi
 # Extract the first word of "perl", so it can be a program name with args.
 set dummy perl; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1775: checking for $ac_word" >&5
+echo "configure:1797: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_PERL'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1803,7 +1825,7 @@ fi
 # Extract the first word of "makedepend", so it can be a program name with args.
 set dummy makedepend; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1807: checking for $ac_word" >&5
+echo "configure:1829: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_MAKEDEPEND'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1835,7 +1857,7 @@ fi
 # Extract the first word of "ar", so it can be a program name with args.
 set dummy ar; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1839: checking for $ac_word" >&5
+echo "configure:1861: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_AR'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1885,20 +1907,20 @@ for ac_hdr in dirent.h sys/ndir.h sys/dir.h ndir.h
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr that defines DIR""... $ac_c" 1>&6
-echo "configure:1889: checking for $ac_hdr that defines DIR" >&5
+echo "configure:1911: checking for $ac_hdr that defines DIR" >&5
 if eval "test \"`echo '$''{'ac_cv_header_dirent_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1894 "configure"
+#line 1916 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <$ac_hdr>
 int main() {
 DIR *dirp = 0;
 ; return 0; }
 EOF
-if { (eval echo configure:1902: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1924: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   eval "ac_cv_header_dirent_$ac_safe=yes"
 else
@@ -1923,15 +1945,15 @@ done
 # Two versions of opendir et al. are in -ldir and -lx on SCO Xenix.
 if test $ac_header_dirent = dirent.h; then
 echo $ac_n "checking for opendir in -ldir""... $ac_c" 1>&6
-echo "configure:1927: checking for opendir in -ldir" >&5
+echo "configure:1949: checking for opendir in -ldir" >&5
 ac_lib_var=`echo dir'_'opendir | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-ldir  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1935 "configure"
+#line 1957 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -1942,7 +1964,7 @@ int main() {
 opendir()
 ; return 0; }
 EOF
-if { (eval echo configure:1946: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:1968: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -1964,15 +1986,15 @@ fi
 
 else
 echo $ac_n "checking for opendir in -lx""... $ac_c" 1>&6
-echo "configure:1968: checking for opendir in -lx" >&5
+echo "configure:1990: checking for opendir in -lx" >&5
 ac_lib_var=`echo x'_'opendir | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lx  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1976 "configure"
+#line 1998 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -1983,7 +2005,7 @@ int main() {
 opendir()
 ; return 0; }
 EOF
-if { (eval echo configure:1987: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2009: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -2006,20 +2028,20 @@ fi
 fi
 
 echo $ac_n "checking for ANSI C header files""... $ac_c" 1>&6
-echo "configure:2010: checking for ANSI C header files" >&5
+echo "configure:2032: checking for ANSI C header files" >&5
 if eval "test \"`echo '$''{'ac_cv_header_stdc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2015 "configure"
+#line 2037 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 #include <stdarg.h>
 #include <string.h>
 #include <float.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2023: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2045: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -2036,7 +2058,7 @@ rm -f conftest*
 if test $ac_cv_header_stdc = yes; then
   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 2040 "configure"
+#line 2062 "configure"
 #include "confdefs.h"
 #include <string.h>
 EOF
@@ -2054,7 +2076,7 @@ fi
 if test $ac_cv_header_stdc = yes; then
   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 2058 "configure"
+#line 2080 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 EOF
@@ -2075,7 +2097,7 @@ if test "$cross_compiling" = yes; then
   :
 else
   cat > conftest.$ac_ext <<EOF
-#line 2079 "configure"
+#line 2101 "configure"
 #include "confdefs.h"
 #include <ctype.h>
 #define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
@@ -2086,7 +2108,7 @@ if (XOR (islower (i), ISLOWER (i)) || toupper (i) != TOUPPER (i)) exit(2);
 exit (0); }
 
 EOF
-if { (eval echo configure:2090: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2112: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   :
 else
@@ -2141,6 +2163,7 @@ for ac_hdr in \
 	pwd.h \
 	regex.h \
 	resolv.h \
+	sched.h \
 	signal.h \
 	stdarg.h \
 	stddef.h \
@@ -2170,17 +2193,17 @@ for ac_hdr in \
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:2174: checking for $ac_hdr" >&5
+echo "configure:2197: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2179 "configure"
+#line 2202 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2184: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2207: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -2208,12 +2231,12 @@ done
 
 
 echo $ac_n "checking for working const""... $ac_c" 1>&6
-echo "configure:2212: checking for working const" >&5
+echo "configure:2235: checking for working const" >&5
 if eval "test \"`echo '$''{'ac_cv_c_const'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2217 "configure"
+#line 2240 "configure"
 #include "confdefs.h"
 
 int main() {
@@ -2262,7 +2285,7 @@ ccp = (char const *const *) p;
 
 ; return 0; }
 EOF
-if { (eval echo configure:2266: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2289: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_c_const=yes
 else
@@ -2283,14 +2306,14 @@ EOF
 fi
 
 echo $ac_n "checking whether byte ordering is bigendian""... $ac_c" 1>&6
-echo "configure:2287: checking whether byte ordering is bigendian" >&5
+echo "configure:2310: checking whether byte ordering is bigendian" >&5
 if eval "test \"`echo '$''{'ac_cv_c_bigendian'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_cv_c_bigendian=unknown
 # See if sys/param.h defines the BYTE_ORDER macro.
 cat > conftest.$ac_ext <<EOF
-#line 2294 "configure"
+#line 2317 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/param.h>
@@ -2301,11 +2324,11 @@ int main() {
 #endif
 ; return 0; }
 EOF
-if { (eval echo configure:2305: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2328: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   # It does; now see whether it defined to BIG_ENDIAN or not.
 cat > conftest.$ac_ext <<EOF
-#line 2309 "configure"
+#line 2332 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/param.h>
@@ -2316,7 +2339,7 @@ int main() {
 #endif
 ; return 0; }
 EOF
-if { (eval echo configure:2320: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2343: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_c_bigendian=yes
 else
@@ -2336,7 +2359,7 @@ if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 2340 "configure"
+#line 2363 "configure"
 #include "confdefs.h"
 main () {
   /* Are we little or big endian?  From Harbison&Steele.  */
@@ -2349,7 +2372,7 @@ main () {
   exit (u.c[sizeof (long) - 1] == 1);
 }
 EOF
-if { (eval echo configure:2353: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2376: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_c_bigendian=no
 else
@@ -2374,20 +2397,20 @@ fi
 
 
 echo $ac_n "checking if ANSI prototypes work""... $ac_c" 1>&6
-echo "configure:2378: checking if ANSI prototypes work" >&5
+echo "configure:2401: checking if ANSI prototypes work" >&5
 if eval "test \"`echo '$''{'ac_cv_have_ansi_prototypes'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 2384 "configure"
+#line 2407 "configure"
 #include "confdefs.h"
 int foo(char *); int foo (char *bar) {return 1;}
 int main() {
 foo("bar")
 ; return 0; }
 EOF
-if { (eval echo configure:2391: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2414: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_have_ansi_prototypes="yes"
 else
@@ -2409,13 +2432,13 @@ EOF
 fi
 
 echo $ac_n "checking for tm->tm_gmtoff""... $ac_c" 1>&6
-echo "configure:2413: checking for tm->tm_gmtoff" >&5
+echo "configure:2436: checking for tm->tm_gmtoff" >&5
 if eval "test \"`echo '$''{'ac_cv_have_tm_gmoff'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 2419 "configure"
+#line 2442 "configure"
 #include "confdefs.h"
 #include <time.h>
 #include <sys/time.h>
@@ -2424,7 +2447,7 @@ struct tm foo;
       foo.tm_gmtoff = 0;
 ; return 0; }
 EOF
-if { (eval echo configure:2428: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2451: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_have_tm_gmoff="yes"
 else
@@ -2446,13 +2469,13 @@ EOF
 fi
 
 echo $ac_n "checking for extended mallinfo""... $ac_c" 1>&6
-echo "configure:2450: checking for extended mallinfo" >&5
+echo "configure:2473: checking for extended mallinfo" >&5
 if eval "test \"`echo '$''{'ac_cv_have_ext_mallinfo'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 2456 "configure"
+#line 2479 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <malloc.h>
@@ -2461,7 +2484,7 @@ struct mallinfo foo;
       foo.mxfast = 0;
 ; return 0; }
 EOF
-if { (eval echo configure:2465: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2488: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_have_ext_mallinfo="yes"
 else
@@ -2483,13 +2506,13 @@ EOF
 fi
 
 echo $ac_n "checking for struct rusage""... $ac_c" 1>&6
-echo "configure:2487: checking for struct rusage" >&5
+echo "configure:2510: checking for struct rusage" >&5
 if eval "test \"`echo '$''{'ac_cv_have_struct_rusage'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 2493 "configure"
+#line 2516 "configure"
 #include "confdefs.h"
 
 #if HAVE_SYS_TIME_H
@@ -2502,7 +2525,7 @@ int main() {
 struct rusage R;
 ; return 0; }
 EOF
-if { (eval echo configure:2506: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2529: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_have_struct_rusage="yes"
 else
@@ -2524,13 +2547,13 @@ EOF
 fi
 
 echo $ac_n "checking for ip->ip_hl""... $ac_c" 1>&6
-echo "configure:2528: checking for ip->ip_hl" >&5
+echo "configure:2551: checking for ip->ip_hl" >&5
 if eval "test \"`echo '$''{'ac_cv_have_ip_hl'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 2534 "configure"
+#line 2557 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <netinet/in.h>
@@ -2547,7 +2570,7 @@ struct iphdr ip;
       ip.ip_hl= 0;
 ; return 0; }
 EOF
-if { (eval echo configure:2551: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2574: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_have_ip_hl="yes"
 else
@@ -2569,15 +2592,15 @@ EOF
 fi
 
 echo $ac_n "checking size of int""... $ac_c" 1>&6
-echo "configure:2573: checking size of int" >&5
+echo "configure:2596: checking size of int" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_int'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 2581 "configure"
+#line 2604 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
@@ -2588,7 +2611,7 @@ main()
   exit(0);
 }
 EOF
-if { (eval echo configure:2592: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2615: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_int=`cat conftestval`
 else
@@ -2608,15 +2631,15 @@ EOF
 
 
 echo $ac_n "checking size of long""... $ac_c" 1>&6
-echo "configure:2612: checking size of long" >&5
+echo "configure:2635: checking size of long" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_long'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 2620 "configure"
+#line 2643 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
@@ -2627,7 +2650,7 @@ main()
   exit(0);
 }
 EOF
-if { (eval echo configure:2631: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2654: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_long=`cat conftestval`
 else
@@ -2650,19 +2673,19 @@ EOF
 # The Ultrix 4.2 mips builtin alloca declared by alloca.h only works
 # for constant arguments.  Useless!
 echo $ac_n "checking for working alloca.h""... $ac_c" 1>&6
-echo "configure:2654: checking for working alloca.h" >&5
+echo "configure:2677: checking for working alloca.h" >&5
 if eval "test \"`echo '$''{'ac_cv_header_alloca_h'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2659 "configure"
+#line 2682 "configure"
 #include "confdefs.h"
 #include <alloca.h>
 int main() {
 char *p = alloca(2 * sizeof(int));
 ; return 0; }
 EOF
-if { (eval echo configure:2666: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2689: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   ac_cv_header_alloca_h=yes
 else
@@ -2683,12 +2706,12 @@ EOF
 fi
 
 echo $ac_n "checking for alloca""... $ac_c" 1>&6
-echo "configure:2687: checking for alloca" >&5
+echo "configure:2710: checking for alloca" >&5
 if eval "test \"`echo '$''{'ac_cv_func_alloca_works'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2692 "configure"
+#line 2715 "configure"
 #include "confdefs.h"
 
 #ifdef __GNUC__
@@ -2711,7 +2734,7 @@ int main() {
 char *p = (char *) alloca(1);
 ; return 0; }
 EOF
-if { (eval echo configure:2715: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2738: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   ac_cv_func_alloca_works=yes
 else
@@ -2743,12 +2766,12 @@ EOF
 
 
 echo $ac_n "checking whether alloca needs Cray hooks""... $ac_c" 1>&6
-echo "configure:2747: checking whether alloca needs Cray hooks" >&5
+echo "configure:2770: checking whether alloca needs Cray hooks" >&5
 if eval "test \"`echo '$''{'ac_cv_os_cray'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2752 "configure"
+#line 2775 "configure"
 #include "confdefs.h"
 #if defined(CRAY) && ! defined(CRAY2)
 webecray
@@ -2773,12 +2796,12 @@ echo "$ac_t""$ac_cv_os_cray" 1>&6
 if test $ac_cv_os_cray = yes; then
 for ac_func in _getb67 GETB67 getb67; do
   echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:2777: checking for $ac_func" >&5
+echo "configure:2800: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2782 "configure"
+#line 2805 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -2801,7 +2824,7 @@ $ac_func();
 
 ; return 0; }
 EOF
-if { (eval echo configure:2805: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:2828: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -2828,15 +2851,15 @@ done
 fi
 
 echo $ac_n "checking stack direction for C alloca""... $ac_c" 1>&6
-echo "configure:2832: checking stack direction for C alloca" >&5
+echo "configure:2855: checking stack direction for C alloca" >&5
 if eval "test \"`echo '$''{'ac_cv_c_stack_direction'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
   ac_cv_c_stack_direction=0
 else
   cat > conftest.$ac_ext <<EOF
-#line 2840 "configure"
+#line 2863 "configure"
 #include "confdefs.h"
 find_stack_direction ()
 {
@@ -2855,7 +2878,7 @@ main ()
   exit (find_stack_direction() < 0);
 }
 EOF
-if { (eval echo configure:2859: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2882: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_c_stack_direction=1
 else
@@ -2878,12 +2901,12 @@ fi
 
 
 echo $ac_n "checking for pid_t""... $ac_c" 1>&6
-echo "configure:2882: checking for pid_t" >&5
+echo "configure:2905: checking for pid_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_pid_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2887 "configure"
+#line 2910 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -2911,12 +2934,12 @@ EOF
 fi
 
 echo $ac_n "checking for size_t""... $ac_c" 1>&6
-echo "configure:2915: checking for size_t" >&5
+echo "configure:2938: checking for size_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_size_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2920 "configure"
+#line 2943 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -2944,12 +2967,12 @@ EOF
 fi
 
 echo $ac_n "checking for ssize_t""... $ac_c" 1>&6
-echo "configure:2948: checking for ssize_t" >&5
+echo "configure:2971: checking for ssize_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_ssize_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2953 "configure"
+#line 2976 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -2977,12 +3000,12 @@ EOF
 fi
 
 echo $ac_n "checking for off_t""... $ac_c" 1>&6
-echo "configure:2981: checking for off_t" >&5
+echo "configure:3004: checking for off_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_off_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2986 "configure"
+#line 3009 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -3010,12 +3033,12 @@ EOF
 fi
 
 echo $ac_n "checking for mode_t""... $ac_c" 1>&6
-echo "configure:3014: checking for mode_t" >&5
+echo "configure:3037: checking for mode_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_mode_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3019 "configure"
+#line 3042 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -3043,12 +3066,12 @@ EOF
 fi
 
 echo $ac_n "checking for fd_mask""... $ac_c" 1>&6
-echo "configure:3047: checking for fd_mask" >&5
+echo "configure:3070: checking for fd_mask" >&5
 if eval "test \"`echo '$''{'ac_cv_type_fd_mask'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3052 "configure"
+#line 3075 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
@@ -3077,13 +3100,13 @@ fi
 
 
 echo $ac_n "checking for socklen_t""... $ac_c" 1>&6
-echo "configure:3081: checking for socklen_t" >&5
+echo "configure:3104: checking for socklen_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_socklen_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 3087 "configure"
+#line 3110 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/socket.h>
@@ -3114,22 +3137,22 @@ EOF
 fi
 
 echo $ac_n "checking for main in -lnsl""... $ac_c" 1>&6
-echo "configure:3118: checking for main in -lnsl" >&5
+echo "configure:3141: checking for main in -lnsl" >&5
 ac_lib_var=`echo nsl'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lnsl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3126 "configure"
+#line 3149 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3133: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3156: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3157,22 +3180,22 @@ else
 fi
 
 echo $ac_n "checking for main in -lsocket""... $ac_c" 1>&6
-echo "configure:3161: checking for main in -lsocket" >&5
+echo "configure:3184: checking for main in -lsocket" >&5
 ac_lib_var=`echo socket'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3169 "configure"
+#line 3192 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3176: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3199: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3204,22 +3227,22 @@ if test "x$ac_cv_enabled_dlmalloc" = "xyes" ; then
   echo "skipping libmalloc check (--enable-dlmalloc specified)"
 else
   echo $ac_n "checking for main in -lgnumalloc""... $ac_c" 1>&6
-echo "configure:3208: checking for main in -lgnumalloc" >&5
+echo "configure:3231: checking for main in -lgnumalloc" >&5
 ac_lib_var=`echo gnumalloc'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lgnumalloc  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3216 "configure"
+#line 3239 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3223: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3246: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3262,22 +3285,22 @@ fi
 			*)
   
 				echo $ac_n "checking for main in -lmalloc""... $ac_c" 1>&6
-echo "configure:3266: checking for main in -lmalloc" >&5
+echo "configure:3289: checking for main in -lmalloc" >&5
 ac_lib_var=`echo malloc'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lmalloc  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3274 "configure"
+#line 3297 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3281: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3304: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3310,22 +3333,22 @@ fi
 fi
 
 echo $ac_n "checking for main in -lbsd""... $ac_c" 1>&6
-echo "configure:3314: checking for main in -lbsd" >&5
+echo "configure:3337: checking for main in -lbsd" >&5
 ac_lib_var=`echo bsd'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lbsd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3322 "configure"
+#line 3345 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3329: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3352: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3353,22 +3376,22 @@ else
 fi
 
 echo $ac_n "checking for main in -lregex""... $ac_c" 1>&6
-echo "configure:3357: checking for main in -lregex" >&5
+echo "configure:3380: checking for main in -lregex" >&5
 ac_lib_var=`echo regex'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lregex  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3365 "configure"
+#line 3388 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3372: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3395: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3389,15 +3412,15 @@ else
 fi
 
 echo $ac_n "checking for gethostbyname in -lbind""... $ac_c" 1>&6
-echo "configure:3393: checking for gethostbyname in -lbind" >&5
+echo "configure:3416: checking for gethostbyname in -lbind" >&5
 ac_lib_var=`echo bind'_'gethostbyname | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lbind  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3401 "configure"
+#line 3424 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3408,7 +3431,7 @@ int main() {
 gethostbyname()
 ; return 0; }
 EOF
-if { (eval echo configure:3412: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3435: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3442,15 +3465,15 @@ if test $ac_cv_lib_bind_gethostbyname = "no" ; then
 		;;
 	*)
 		echo $ac_n "checking for inet_aton in -lresolv""... $ac_c" 1>&6
-echo "configure:3446: checking for inet_aton in -lresolv" >&5
+echo "configure:3469: checking for inet_aton in -lresolv" >&5
 ac_lib_var=`echo resolv'_'inet_aton | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lresolv  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3454 "configure"
+#line 3477 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3461,7 +3484,7 @@ int main() {
 inet_aton()
 ; return 0; }
 EOF
-if { (eval echo configure:3465: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3488: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3477,15 +3500,15 @@ fi
 if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
   echo "$ac_t""yes" 1>&6
   echo $ac_n "checking for inet_aton in -l44bsd""... $ac_c" 1>&6
-echo "configure:3481: checking for inet_aton in -l44bsd" >&5
+echo "configure:3504: checking for inet_aton in -l44bsd" >&5
 ac_lib_var=`echo 44bsd'_'inet_aton | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-l44bsd  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3489 "configure"
+#line 3512 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3496,7 +3519,7 @@ int main() {
 inet_aton()
 ; return 0; }
 EOF
-if { (eval echo configure:3500: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3523: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3528,22 +3551,22 @@ else
 fi
 
 		echo $ac_n "checking for main in -lresolv""... $ac_c" 1>&6
-echo "configure:3532: checking for main in -lresolv" >&5
+echo "configure:3555: checking for main in -lresolv" >&5
 ac_lib_var=`echo resolv'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lresolv  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3540 "configure"
+#line 3563 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3547: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3570: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3574,22 +3597,22 @@ fi
     esac
 fi
 echo $ac_n "checking for main in -lm""... $ac_c" 1>&6
-echo "configure:3578: checking for main in -lm" >&5
+echo "configure:3601: checking for main in -lm" >&5
 ac_lib_var=`echo m'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lm  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3586 "configure"
+#line 3609 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3593: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3616: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3618,15 +3641,15 @@ fi
 
 
 echo $ac_n "checking for crypt in -lcrypt""... $ac_c" 1>&6
-echo "configure:3622: checking for crypt in -lcrypt" >&5
+echo "configure:3645: checking for crypt in -lcrypt" >&5
 ac_lib_var=`echo crypt'_'crypt | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lcrypt  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3630 "configure"
+#line 3653 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3637,7 +3660,7 @@ int main() {
 crypt()
 ; return 0; }
 EOF
-if { (eval echo configure:3641: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3664: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3670,22 +3693,22 @@ fi
 
 
 echo $ac_n "checking for main in -lpthread""... $ac_c" 1>&6
-echo "configure:3674: checking for main in -lpthread" >&5
+echo "configure:3697: checking for main in -lpthread" >&5
 ac_lib_var=`echo pthread'_'main | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lpthread  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3682 "configure"
+#line 3705 "configure"
 #include "confdefs.h"
 
 int main() {
 main()
 ; return 0; }
 EOF
-if { (eval echo configure:3689: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3712: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -3735,6 +3758,11 @@ case "$host" in
 	*-ibm-aix*)
 		echo "Removing -lbsd for AIX..."
 		LIBS=`echo $LIBS | sed -e s/-lbsd//`
+		echo "disabling snprintf/vsnprintf for $host"
+		ac_cv_func_snprintf=no
+		ac_cv_func_vsnprintf=no
+		echo "disabling seteuid for $host"
+		ac_cv_func_seteuid=no
 		;;
 	*m88k*)
 		CFLAGS="$CFLAGS -D_SQUID_MOTOROLA_"
@@ -3788,6 +3816,11 @@ if test -z "$ac_cv_func_poll"; then
 			echo "disabling poll for $host..."
 			ac_cv_func_poll='no'
 			;;
+		powerpc-ibm-aix4.1.*)
+			# Mike Laster (mlaster@metavillage.com) 19981021
+			echo "disabling poll for $host..."
+			ac_cv_func_poll='no'
+			;;
 	esac
 fi
 
@@ -3810,6 +3843,7 @@ for ac_func in \
 	mktime \
 	mstats \
 	poll \
+	putenv \
 	random \
 	regcomp \
 	regexec \
@@ -3833,12 +3867,73 @@ for ac_func in \
 
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:3837: checking for $ac_func" >&5
+echo "configure:3871: checking for $ac_func" >&5
+if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 3876 "configure"
+#include "confdefs.h"
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func(); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+/* We use char because int might match the return type of a gcc2
+    builtin and then its argument prototype would still apply.  */
+char $ac_func();
+
+int main() {
+
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+$ac_func();
+#endif
+
+; return 0; }
+EOF
+if { (eval echo configure:3899: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  eval "ac_cv_func_$ac_func=no"
+fi
+rm -f conftest*
+fi
+
+if eval "test \"`echo '$ac_cv_func_'$ac_func`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+    ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
+  cat >> confdefs.h <<EOF
+#define $ac_tr_func 1
+EOF
+ 
+else
+  echo "$ac_t""no" 1>&6
+fi
+done
+
+
+if test "$async_io" = "yes" ; then
+	for ac_func in \
+		pthread_attr_setscope \
+		pthread_setschedparam \
+		pthread_attr_setschedparam \
+	
+do
+echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
+echo "configure:3932: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3842 "configure"
+#line 3937 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -3861,7 +3956,7 @@ $ac_func();
 
 ; return 0; }
 EOF
-if { (eval echo configure:3865: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:3960: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -3885,17 +3980,18 @@ else
 fi
 done
 
+fi
 
 echo $ac_n "checking if setresuid is implemented""... $ac_c" 1>&6
-echo "configure:3891: checking if setresuid is implemented" >&5
+echo "configure:3987: checking if setresuid is implemented" >&5
 if eval "test \"`echo '$''{'ac_cv_func_setresuid'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
     { echo "configure: error: can not run test program while cross compiling" 1>&2; exit 1; }
 else
   cat > conftest.$ac_ext <<EOF
-#line 3899 "configure"
+#line 3995 "configure"
 #include "confdefs.h"
 
 #include <stdlib.h>
@@ -3908,7 +4004,7 @@ else
   }
   
 EOF
-if { (eval echo configure:3912: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4008: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   ac_cv_func_setresuid="yes"
 else
@@ -3933,7 +4029,7 @@ fi
 
 if test "$IPF_TRANSPARENT" ; then
     echo $ac_n "checking if IP-Filter header files are installed""... $ac_c" 1>&6
-echo "configure:3937: checking if IP-Filter header files are installed" >&5
+echo "configure:4033: checking if IP-Filter header files are installed" >&5
     if test "$ac_cv_header_ip_compat_h" = "no" ||
        test "$ac_cv_header_ip_fil_h" = "no" ||
        test "$ac_cv_header_ip_nat_h" = "no" ; then
@@ -3968,21 +4064,21 @@ if test -z "$USE_GNUREGEX" ; then
     esac
 fi
 echo $ac_n "checking if GNUregex needs to be compiled""... $ac_c" 1>&6
-echo "configure:3972: checking if GNUregex needs to be compiled" >&5
+echo "configure:4068: checking if GNUregex needs to be compiled" >&5
 if test -z "$USE_GNUREGEX"; then
 if test "$ac_cv_func_regcomp" = "no" || test "$USE_GNUREGEX" = "yes" ; then
 	USE_GNUREGEX="yes"
 else
 	cat > conftest.$ac_ext <<EOF
-#line 3978 "configure"
+#line 4074 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <regex.h>
 int main() {
 regex_t t; regcomp(&t,"",0);
 ; return 0; }
 EOF
-if { (eval echo configure:3986: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:4082: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   USE_GNUREGEX="no"
 else
@@ -4013,12 +4109,12 @@ for ac_func in \
 
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:4017: checking for $ac_func" >&5
+echo "configure:4113: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4022 "configure"
+#line 4118 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -4041,7 +4137,7 @@ $ac_func();
 
 ; return 0; }
 EOF
-if { (eval echo configure:4045: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:4141: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -4069,12 +4165,12 @@ done
 
 
 echo $ac_n "checking Default FD_SETSIZE value""... $ac_c" 1>&6
-echo "configure:4073: checking Default FD_SETSIZE value" >&5
+echo "configure:4169: checking Default FD_SETSIZE value" >&5
 if test "$cross_compiling" = yes; then
   DEFAULT_FD_SETSIZE=256
 else
   cat > conftest.$ac_ext <<EOF
-#line 4078 "configure"
+#line 4174 "configure"
 #include "confdefs.h"
 
 #if HAVE_STDIO_H
@@ -4098,7 +4194,7 @@ main() {
 }
 
 EOF
-if { (eval echo configure:4102: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4198: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   DEFAULT_FD_SETSIZE=`cat conftestval`
 else
@@ -4117,12 +4213,12 @@ EOF
 
 
 echo $ac_n "checking Maximum number of filedescriptors we can open""... $ac_c" 1>&6
-echo "configure:4121: checking Maximum number of filedescriptors we can open" >&5
+echo "configure:4217: checking Maximum number of filedescriptors we can open" >&5
 if test "$cross_compiling" = yes; then
   SQUID_MAXFD=256
 else
   cat > conftest.$ac_ext <<EOF
-#line 4126 "configure"
+#line 4222 "configure"
 #include "confdefs.h"
 
 #include <stdio.h>
@@ -4181,7 +4277,7 @@ main() {
 }
 
 EOF
-if { (eval echo configure:4185: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4281: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   SQUID_MAXFD=`cat conftestval`
 else
@@ -4207,12 +4303,12 @@ if test "$SQUID_MAXFD" -lt 512 ; then
 fi
 
 echo $ac_n "checking Default UDP send buffer size""... $ac_c" 1>&6
-echo "configure:4211: checking Default UDP send buffer size" >&5
+echo "configure:4307: checking Default UDP send buffer size" >&5
 if test "$cross_compiling" = yes; then
   SQUID_UDP_SO_SNDBUF=16384
 else
   cat > conftest.$ac_ext <<EOF
-#line 4216 "configure"
+#line 4312 "configure"
 #include "confdefs.h"
 
 #include <stdlib.h>
@@ -4231,7 +4327,7 @@ main ()
 }
 
 EOF
-if { (eval echo configure:4235: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4331: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   SQUID_UDP_SO_SNDBUF=`cat conftestval`
 else
@@ -4250,12 +4346,12 @@ EOF
 
 
 echo $ac_n "checking Default UDP receive buffer size""... $ac_c" 1>&6
-echo "configure:4254: checking Default UDP receive buffer size" >&5
+echo "configure:4350: checking Default UDP receive buffer size" >&5
 if test "$cross_compiling" = yes; then
   SQUID_UDP_SO_RCVBUF=16384
 else
   cat > conftest.$ac_ext <<EOF
-#line 4259 "configure"
+#line 4355 "configure"
 #include "confdefs.h"
 
 #include <stdlib.h>
@@ -4274,7 +4370,7 @@ main ()
 }
 
 EOF
-if { (eval echo configure:4278: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4374: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   SQUID_UDP_SO_RCVBUF=`cat conftestval`
 else
@@ -4293,12 +4389,12 @@ EOF
 
 
 echo $ac_n "checking Default TCP send buffer size""... $ac_c" 1>&6
-echo "configure:4297: checking Default TCP send buffer size" >&5
+echo "configure:4393: checking Default TCP send buffer size" >&5
 if test "$cross_compiling" = yes; then
   SQUID_TCP_SO_SNDBUF=16384
 else
   cat > conftest.$ac_ext <<EOF
-#line 4302 "configure"
+#line 4398 "configure"
 #include "confdefs.h"
 
 #include <stdlib.h>
@@ -4317,7 +4413,7 @@ main ()
 }
 
 EOF
-if { (eval echo configure:4321: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4417: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   SQUID_TCP_SO_SNDBUF=`cat conftestval`
 else
@@ -4336,12 +4432,12 @@ EOF
 
 
 echo $ac_n "checking Default TCP receive buffer size""... $ac_c" 1>&6
-echo "configure:4340: checking Default TCP receive buffer size" >&5
+echo "configure:4436: checking Default TCP receive buffer size" >&5
 if test "$cross_compiling" = yes; then
   SQUID_TCP_SO_RCVBUF=16384
 else
   cat > conftest.$ac_ext <<EOF
-#line 4345 "configure"
+#line 4441 "configure"
 #include "confdefs.h"
 
 #include <stdlib.h>
@@ -4360,7 +4456,7 @@ main ()
 }
 
 EOF
-if { (eval echo configure:4364: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4460: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   SQUID_TCP_SO_RCVBUF=`cat conftestval`
 else
@@ -4379,19 +4475,19 @@ EOF
 
 
 echo $ac_n "checking if sys_errlist is already defined""... $ac_c" 1>&6
-echo "configure:4383: checking if sys_errlist is already defined" >&5
+echo "configure:4479: checking if sys_errlist is already defined" >&5
 if eval "test \"`echo '$''{'ac_cv_needs_sys_errlist'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4388 "configure"
+#line 4484 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 int main() {
 char *s = sys_errlist0;
 ; return 0; }
 EOF
-if { (eval echo configure:4395: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:4491: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_needs_sys_errlist="no"
 else
@@ -4413,16 +4509,16 @@ EOF
 fi
 
 echo $ac_n "checking for libresolv _dns_ttl_ hack""... $ac_c" 1>&6
-echo "configure:4417: checking for libresolv _dns_ttl_ hack" >&5
+echo "configure:4513: checking for libresolv _dns_ttl_ hack" >&5
 cat > conftest.$ac_ext <<EOF
-#line 4419 "configure"
+#line 4515 "configure"
 #include "confdefs.h"
 extern int _dns_ttl_;
 int main() {
 return _dns_ttl_;
 ; return 0; }
 EOF
-if { (eval echo configure:4426: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
+if { (eval echo configure:4522: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then
   rm -rf conftest*
   echo "$ac_t""yes" 1>&6
 cat >> confdefs.h <<\EOF
@@ -4438,12 +4534,12 @@ fi
 rm -f conftest*
 
 echo $ac_n "checking if inet_ntoa() actually works""... $ac_c" 1>&6
-echo "configure:4442: checking if inet_ntoa() actually works" >&5
+echo "configure:4538: checking if inet_ntoa() actually works" >&5
 if test "$cross_compiling" = yes; then
   INET_NTOA_RESULT="broken"
 else
   cat > conftest.$ac_ext <<EOF
-#line 4447 "configure"
+#line 4543 "configure"
 #include "confdefs.h"
 
 #include <stdlib.h>
@@ -4460,7 +4556,7 @@ main ()
 }
 
 EOF
-if { (eval echo configure:4464: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4560: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null
 then
   INET_NTOA_RESULT=`cat conftestval`
 else
@@ -4482,6 +4578,140 @@ else
 	sleep 10
 fi
 
+if test "$ac_cv_func_statvfs" = "yes" ; then
+echo $ac_n "checking for working statvfs() interface""... $ac_c" 1>&6
+echo "configure:4584: checking for working statvfs() interface" >&5
+cat > conftest.$ac_ext <<EOF
+#line 4586 "configure"
+#include "confdefs.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/statvfs.h>
+
+int main() {
+
+struct statvfs sfs;
+sfs.f_blocks = sfs.f_bfree = sfs.f_frsize = 
+sfs.f_files = sfs.f_ffree = 0;
+statvfs("/tmp", &sfs);
+
+; return 0; }
+EOF
+if { (eval echo configure:4603: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_func_statvfs=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_func_statvfs=no
+fi
+rm -f conftest*
+echo "$ac_t""$ac_cv_func_statvfs" 1>&6
+fi
+
+echo $ac_n "checking for _res.nsaddr_list""... $ac_c" 1>&6
+echo "configure:4617: checking for _res.nsaddr_list" >&5
+if eval "test \"`echo '$''{'ac_cv_have_res_nsaddr_list'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 4622 "configure"
+#include "confdefs.h"
+
+#if HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_ARPA_INET_H
+#include <arpa/inet.h>
+#endif
+#if HAVE_ARPA_NAMESER_H
+#include <arpa/nameser.h>
+#endif
+#if HAVE_RESOLV_H
+#include <resolv.h>
+#endif
+
+int main() {
+_res.nsaddr_list[0];
+; return 0; }
+EOF
+if { (eval echo configure:4645: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_have_res_nsaddr_list="yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_have_res_nsaddr_list="no"
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$ac_cv_have_res_nsaddr_list" 1>&6
+if test $ac_cv_have_res_nsaddr_list = "yes" ; then
+  cat >> confdefs.h <<\EOF
+#define HAVE_RES_NSADDR_LIST 1
+EOF
+
+fi
+
+if test $ac_cv_have_res_nsaddr_list = "no" ; then
+echo $ac_n "checking for _res.ns_list""... $ac_c" 1>&6
+echo "configure:4667: checking for _res.ns_list" >&5
+if eval "test \"`echo '$''{'ac_cv_have_res_ns_list'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 4672 "configure"
+#include "confdefs.h"
+
+#if HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_ARPA_INET_H
+#include <arpa/inet.h>
+#endif
+#if HAVE_ARPA_NAMESER_H
+#include <arpa/nameser.h>
+#endif
+#if HAVE_RESOLV_H
+#include <resolv.h>
+#endif
+
+int main() {
+_res.ns_list[0].addr;
+; return 0; }
+EOF
+if { (eval echo configure:4695: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  rm -rf conftest*
+  ac_cv_have_res_ns_list="yes"
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -rf conftest*
+  ac_cv_have_res_ns_list="no"
+fi
+rm -f conftest*
+fi
+
+echo "$ac_t""$ac_cv_have_res_ns_list" 1>&6
+if test $ac_cv_have_res_ns_list = "yes" ; then
+  cat >> confdefs.h <<\EOF
+#define HAVE_RES_NS_LIST 1
+EOF
+
+fi
+fi
+
 XTRA_OBJS=''
 if test "$ac_cv_lib_malloc_main" = "yes" ; then
 	if test -r /usr/lib/debug/malloc.o ; then
@@ -3,13 +3,13 @@ dnl  Configuration input file for Squid
 dnl
 dnl  Duane Wessels, wessels@nlanr.net, February 1996 (autoconf v2.9)
 dnl
-dnl  $Id: configure.in,v 1.159 1998/10/17 05:08:16 wessels Exp $
+dnl  $Id: configure.in,v 1.160 1998/11/12 06:29:26 wessels Exp $
 dnl
 dnl
 dnl
 AC_INIT(src/main.c)
 AC_CONFIG_HEADER(include/autoconf.h)
-AC_REVISION($Revision: 1.159 $)dnl
+AC_REVISION($Revision: 1.160 $)dnl
 AC_PREFIX_DEFAULT(/usr/local/squid)
 AC_CONFIG_AUX_DIR(cfgaux)
 
@@ -271,10 +271,20 @@ AC_ARG_ENABLE(async_io,
 [  --enable-async-io       Do ASYNC disk I/O using threads],
 [ if test "$enableval" = "yes" ; then
     echo "Async I/O enabled"
+    async_io=yes
     AC_DEFINE(USE_ASYNC_IO)
     ASYNC_OBJS='$(ASYNC_OBJS)'
     SQUID_PTHREAD_LIB='$(PTHREADLIB)'
     CFLAGS="$CFLAGS -D_REENTRANT"
+    case "$host" in
+    i386-unknown-freebsd*)
+    	if test "$GCC" = "yes" ; then
+	    if test -z "$PRESET_LDFLAGS"; then
+		LDFLAGS="$LDFLAGS -pthread"
+	    fi
+	fi
+	;;
+    esac
   fi
 ])
 AC_SUBST(ASYNC_OBJS)
@@ -429,19 +439,25 @@ AC_ARG_ENABLE(poll,
                           is broken on some platforms.  If you think you are
                           smarter than the configure script, you may enable
                           poll with this option.
-],
-[ if test "$enableval" = "yes" ; then
+  --disable-poll          Disable the use of poll().],
+[ 
+  case "$enableval" in
+  yes)
     echo "Forcing poll() to be enabled"
     ac_cv_func_poll='yes'
-  fi
+    ;;
+  no)
+    echo "Forcing poll() to be disabled"
+    ac_cv_func_poll='no'
+    ;;
+  esac
 ])
 
 dnl Disable HTTP violations
 AC_ARG_ENABLE(http-violations,
 [  --disable-http-violations
                           This allows you to remove code which is known to
-                          violate the HTTP protocol specification.
-],
+                          violate the HTTP protocol specification.],
 [ if test "$enableval" = "no" ; then
     echo "Disabling HTTP Violations"
     AC_DEFINE(HTTP_VIOLATIONS, 0)
@@ -454,8 +470,7 @@ dnl Enable IP-Filter Transparent Proxy
 AC_ARG_ENABLE(ipf-transparent,
 [  --enable-ipf-transparent
                           Enable Transparent Proxy support for systems
-                          using IP-Filter network address redirection.
-],
+                          using IP-Filter network address redirection.],
 [ if test "$enableval" = "yes" ; then
 	echo "IP-Filter Transparent Proxy enabled"
 	AC_DEFINE(IPF_TRANSPARENT)
@@ -473,6 +488,13 @@ case "$host" in
 		ac_cv_prog_CC="$CC"
 	fi
 	;;
+    *-hp-hpux*)
+	if test "$ac_cv_prog_CC" = "cc" ; then
+		echo "adding '-Ae' to cc args for $host"
+		CC="cc -Ae";
+		ac_cv_prog_CC="$CC"
+	fi
+	;;
 esac
 
 dnl Check for programs
@@ -542,6 +564,7 @@ AC_CHECK_HEADERS( \
 	pwd.h \
 	regex.h \
 	resolv.h \
+	sched.h \
 	signal.h \
 	stdarg.h \
 	stddef.h \
@@ -755,6 +778,15 @@ dnl Please change your configure script.  AIX doesn't need -lbsd.
 	*-ibm-aix*)
 		echo "Removing -lbsd for AIX..."
 		LIBS=`echo $LIBS | sed -e s/-lbsd//`
+dnl From: mlaster@metavillage.com (Mike Laster)
+dnl AIX 4.1.4.x does not have header files for snprintf/vsnprintf
+dnl So using the internal versions generates a load of warnings
+dnl during compile.
+		echo "disabling snprintf/vsnprintf for $host"
+		ac_cv_func_snprintf=no
+		ac_cv_func_vsnprintf=no
+		echo "disabling seteuid for $host"
+		ac_cv_func_seteuid=no
 		;;
 	*m88k*)
 		CFLAGS="$CFLAGS -D_SQUID_MOTOROLA_"
@@ -800,6 +832,11 @@ if test -z "$ac_cv_func_poll"; then
 			echo "disabling poll for $host..."
 			ac_cv_func_poll='no'
 			;;
+		[powerpc-ibm-aix4.1.*])
+			# Mike Laster (mlaster@metavillage.com) 19981021
+			echo "disabling poll for $host..."
+			ac_cv_func_poll='no'
+			;;
 	esac
 fi
 
@@ -823,6 +860,7 @@ AC_CHECK_FUNCS(\
 	mktime \
 	mstats \
 	poll \
+	putenv \
 	random \
 	regcomp \
 	regexec \
@@ -845,6 +883,14 @@ AC_CHECK_FUNCS(\
 	vsnprintf \
 )
 
+if test "$async_io" = "yes" ; then
+	AC_CHECK_FUNCS(\
+		pthread_attr_setscope \
+		pthread_setschedparam \
+		pthread_attr_setschedparam \
+	)
+fi
+
 dnl Yay!  Another Linux brokenness.  Its not good enough
 dnl to know that setresuid() exists, because RedHat 5.0 declares
 dnl setresuid() but doesn't implement it.
@@ -1162,6 +1208,77 @@ else
 	sleep 10
 fi
 
+if test "$ac_cv_func_statvfs" = "yes" ; then
+AC_MSG_CHECKING(for working statvfs() interface)
+AC_TRY_COMPILE([
+#include <stdlib.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/statvfs.h>
+],
+[
+struct statvfs sfs;
+sfs.f_blocks = sfs.f_bfree = sfs.f_frsize = 
+sfs.f_files = sfs.f_ffree = 0;
+statvfs("/tmp", &sfs);
+],
+  ac_cv_func_statvfs=yes,
+  ac_cv_func_statvfs=no)
+AC_MSG_RESULT($ac_cv_func_statvfs)
+fi
+
+AC_CACHE_CHECK(for _res.nsaddr_list, ac_cv_have_res_nsaddr_list,
+AC_TRY_COMPILE([
+#if HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_ARPA_INET_H
+#include <arpa/inet.h>
+#endif
+#if HAVE_ARPA_NAMESER_H
+#include <arpa/nameser.h>
+#endif
+#if HAVE_RESOLV_H
+#include <resolv.h>
+#endif
+],
+[_res.nsaddr_list[[0]];],
+ac_cv_have_res_nsaddr_list="yes",
+ac_cv_have_res_nsaddr_list="no"))
+if test $ac_cv_have_res_nsaddr_list = "yes" ; then
+  AC_DEFINE(HAVE_RES_NSADDR_LIST)
+fi
+
+if test $ac_cv_have_res_nsaddr_list = "no" ; then
+AC_CACHE_CHECK(for _res.ns_list, ac_cv_have_res_ns_list,
+AC_TRY_COMPILE([
+#if HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if HAVE_ARPA_INET_H
+#include <arpa/inet.h>
+#endif
+#if HAVE_ARPA_NAMESER_H
+#include <arpa/nameser.h>
+#endif
+#if HAVE_RESOLV_H
+#include <resolv.h>
+#endif
+],
+[_res.ns_list[[0]].addr;],
+ac_cv_have_res_ns_list="yes",
+ac_cv_have_res_ns_list="no"))
+if test $ac_cv_have_res_ns_list = "yes" ; then
+  AC_DEFINE(HAVE_RES_NS_LIST)
+fi
+fi
+
 dnl Need the debugging version of malloc if available
 XTRA_OBJS=''
 if test "$ac_cv_lib_malloc_main" = "yes" ; then
@@ -5,7 +5,7 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -15,9 +15,8 @@ tekkis j&auml;rgnev viga:
 Juurdep&auml;&auml;s keelatud.
 </STRONG>
 <P>
-Juurdep&auml;&auml;su kontrolli konfiguratsioon blokeeris teie p&auml;ringu.
-Palun kontakteeruge oma teenusepakkujaga, kui te arvate, et blokeerimine
-pole &otilde;ige.
+Juurdep&auml;&auml;su kontrolli konfiguratsioon blokeerib teie p&auml;ringut.
+Kui te arvate, et blokeering pole &otilde;ige, kontakteeruge palun teenuse pakkujaga.
 </UL>
 </P>
 
@@ -6,7 +6,7 @@
 <H2>Cache kasutamine keelatud</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -6,7 +6,7 @@
 <H2>Cache haldaja kasutamine blokeeritud</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -5,7 +5,7 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -1,26 +1,26 @@
-<HTML><HEAD>
-<TITLE>VIGA: P&auml;ring URLile ei saa vastust</TITLE>
-</HEAD><BODY>
-<H1>VIGA</H1>
-<H2>P&auml;ring URLile ei saa vastust</H2>
-<HR>
-<P>
-Sooritades p&auml;ringut URLile:
-<A HREF="%U">%U</A>
-<P>
-tekkis j&auml;rgnev viga:
-<UL>
-<LI>
-<STRONG>
-&Uuml;hendus eba&otilde;nnestus.
-</STRONG>
-</UL>
-
-<P>
-S&uuml;steem vastas:
-<PRE><I>    %E</I></PRE>
-
-<P>
-Server v&otilde;i arvutiv&otilde;rk ei t&ouml;&ouml;ta. Palun korrake
-p&auml;ringut.
-</P>
+<HTML><HEAD>
+<TITLE>VIGA: P&auml;ring URLile ei saa vastust</TITLE>
+</HEAD><BODY>
+<H1>VIGA</H1>
+<H2>P&auml;ring URLile ei saa vastust</H2>
+<HR>
+<P>
+Sooritades p&auml;ringut URLile
+<A HREF="%U">%U</A>
+<P>
+tekkis j&auml;rgnev viga:
+<UL>
+<LI>
+<STRONG>
+&Uuml;hendus eba&otilde;nnestus.
+</STRONG>
+</UL>
+
+<P>
+S&uuml;steem vastas:
+<PRE><I>    %E</I></PRE>
+
+<P>
+Server v&otilde;i arvutiv&otilde;rk ei t&ouml;&ouml;ta. Palun korrake
+p&auml;ringut.
+</P>
@@ -4,7 +4,7 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -5,7 +5,7 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -17,6 +17,6 @@ Edastamine keelatud.
 </UL>
 
 <P>
-See cache ei edasta teie p&auml;ringut, kuna ta kasutab ainult naaber cache
-meetodit. Ilmselt on klient %i cache, mis on vigaselt konfigureeritud.
+Meie cache ei edasta teie p&auml;ringut, kuna ta kasutab andmete edastamisel
+ainult naaber cache meetodit. Ilmselt on %i vigaselt konfigureeritud cache.
 </P>
@@ -5,7 +5,7 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -5,7 +5,7 @@
 <H2>FTP PUT eba&otilde;nnestus</H2>
 <HR>
 <P>
-PUT operatsioon URLil:
+PUT operatsioon URLil
 <A HREF="%U">%U</A>
 <P>
 Squid saatis j&auml;rgneva FTP k&auml;su:
@@ -5,7 +5,7 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut:
+Sooritades p&auml;ringut
 <PRE>
 %R
 </PRE>
@@ -5,7 +5,7 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -5,7 +5,7 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -5,7 +5,7 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -17,6 +17,6 @@ Wais edastaja puudub
 </UL>
 
 <P>
-Selles Caches on WAISi edastav host kirjeldamata!  Karju natuke administraatori
-peale.
+Selles Caches on WAISi edastav host kirjeldamata!  Kontakteeruge
+administraatoriga.
 </P>
@@ -5,7 +5,7 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -5,7 +5,7 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -5,7 +5,7 @@
 <H2>P&auml;ringule ei saabunud vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -21,6 +21,6 @@ S&uuml;steem vastas:
 <PRE><I>    %E</I></PRE>
 
 <P>
-Lugejal katkes v&otilde;rgust andmete lugemisel kannatus. V&otilde;rk v&otilde;i
+Lugejal katkes v&otilde;rgust andmeid lugedes kannatus. V&otilde;rk v&otilde;i
 server v&otilde;ib olla maas v&otilde;i umbes. Proovige uuesti.
 </P>
@@ -5,7 +5,7 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -5,7 +5,7 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -5,7 +5,7 @@
 <H2>P&auml;ring URNile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URNile:
+Sooritades p&auml;ringut URNile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -5,14 +5,14 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
 <UL>
 <LI>
 <STRONG>
-Kirjutamise viga
+Viga kirjutamisel
 </STRONG>
 </UL>
 
@@ -5,7 +5,7 @@
 <H2>P&auml;ring URLile ei saa vastust</H2>
 <HR>
 <P>
-Sooritades p&auml;ringut URLile:
+Sooritades p&auml;ringut URLile
 <A HREF="%U">%U</A>
 <P>
 tekkis j&auml;rgnev viga:
@@ -17,5 +17,5 @@ Null pikkusega vastus
 </UL>
 
 <P>
-Squid ei saanud sugugi andmeid selle p&auml;ringu vastuseks...
+Squid ei saanud selle p&auml;ringu vastuseks midagi...
 </P>
@@ -1,23 +1,23 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
 Acc&egrave;s interdit.
 </STRONG>
 <P>
-La configuration du controle d'acc&egrave;s interdit votre requete d'etre
+La configuration du contr&ocirc;le d'acc&egrave;s interdit &agrave; votre requ&ecirc;te d'&ecirc;tre
 accept&eacute;e &agrave; cette heure-ci. Veuillez contacter votre
-prestataire de service si vous pensez que ceci n'a pas lieu d'etre.
+prestataire de service si vous pensez que ceci n'a pas lieu d'&ecirc;tre.
 </UL>
 </P>
 
@@ -1,27 +1,27 @@
 <HTML><HEAD>
-<TITLE>ERREUR: Acc&egrave;s interdit au cache</TITLE>
+<TITLE>ERREUR&nbsp;: Acc&egrave;s au cache interdit</TITLE>
 </HEAD>
 <BODY>
 <H1>ERREUR</H1>
-<H2>Acc&egrave;s interdit au cache</H2>
+<H2>Acc&egrave;s au cache interdit</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
-Acc&egrave;s interdit au cache.
+Acc&egrave;s au cache interdit.
 </STRONG>
 </UL>
 </P>
 
-<P>D&eacute;sol&eacute;, vous n'etes actuellement pas autoris&eacute;
+<P>D&eacute;sol&eacute;, vous n'&ecirc;tes actuellement pas autoris&eacute;
 &agrave; demander
 <PRE>    %U</PRE>
-&agrave; ce cache tant que vous ne vous etes pas identifi&eacute;.
+&agrave; ce cache tant que vous ne vous &ecirc;tes pas identifi&eacute;.
 </P>
 
 <P>
@@ -1,32 +1,32 @@
 <HTML><HEAD>
-<TITLE>ERREUR: Acc&egrave;s interdit au gestionnaire de cache</TITLE>
+<TITLE>ERREUR&nbsp;: Acc&egrave;s au gestionnaire de cache interdit</TITLE>
 </HEAD>
 <BODY>
 <H1>ERREUR</H1>
-<H2>Cache Manager Acc&egrave;s interdit</H2>
+<H2>Acc&egrave;s au gestionnaire de cache interdit</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
-Acc&egrave;s interdit au gestionnaire de cache.
+Acc&egrave;s au gestionnaire de cache interdit.
 </STRONG>
 </UL>
 </P>
 
-<P>D&eacute;sol&eacute, vous n'etes pas autoris&eacute;s &agrave; acc&eacute;der
+<P>D&eacute;sol&eacute, vous n'&ecirc;tes pas autoris&eacute; &agrave; acc&eacute;der &agrave;
 <PRE>    %U</PRE>
-&agrave; ce cache sans vous etre identifi&eacute;.
+au travers de ce gestionnaire de cache sans vous &ecirc;tre identifi&eacute;.
 </P>
 
 <P> Vous avez besoin de Netscape version 2.0 ou sup&eacute;rieure, ou
 Microsoft Internet Explorer 3.0, ou un navigateur conforme &agrave; HTTP/1.1
 pour que ceci fonctionne. Veuillez contacter l'<A HREF="mailto:%w">administrateur du cache</a>
 si vous avez des difficult&eacute;s &agrave; vous authentifier ou, si vous
-<em>etes</em> l'administrateur, lisez la documentation de Squid sur
+<em>&ecirc;tes</em> l'administrateur, lisez la documentation de Squid sur
 l'interface du gestionnaire de cache, et v&eacute;rifiez l'historique du
 cache pour des messages d'erreur plus d&eacute;taill&eacute;s.</P>
@@ -1,24 +1,24 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
-Impossible de relayer &agrave; cette heure.
+Impossible de relayer cette requ&ecirc;te en ce moment.
 </STRONG>
 </UL>
 
 <P>
-Cette requete n'a pu etre transmise au serveur d'origine ou &agrave; l'un
-des caches parents. La cause de cette erreur la plus probable est:
+Cette requ&ecirc;te n'a pu &ecirc;tre transmise au serveur d'origine ou &agrave; l'un
+des caches parents. La cause la plus probable de cette erreur est&nbsp;:
 <UL>
 <LI>L'administrateur du cache a interdit &agrave; ce cache de faire des
     connexions directes aux serveurs d'origine, et
@@ -1,26 +1,26 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
-La connexion a &eacute;chou&eacute
+La connexion a &eacute;chou&eacute;
 </STRONG>
 </UL>
 
 <P>
-Le syst&egrave;me retourna:
+Le syst&egrave;me a retourn&eacute;&nbsp;:
 <PRE><I>    %E</I></PRE>
 
 <P>
-La machine distante ou le r&eacute;seau peuvent etre hors service. Veuillez
-r&eacute;it&eacute;rer votre requete.
+La machine distante ou le r&eacute;seau sont peut-&ecirc;tre hors service. Veuillez
+r&eacute;it&eacute;rer votre requ&ecirc;te.
 </P>
@@ -1,27 +1,27 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <BLOCKQUOTE>
 Impossible d'associer une adresse IP &agrave; la machine
-<I>%H</I>
+<I>%H</I>.
 </BLOCKQUOTE>
 </UL>
 
 <P>
-Le serveur de noms retourna:
+Le serveur de noms a retourn&eacute;&nbsp;:
 <BLOCKQUOTE>
 %z
 </BLOCKQUOTE>
 
 <P>
-En d'autres termes:
+En d'autres termes&nbsp;:
 <PRE>
  Le cache n'a pas &eacute;t&eacute; en mesure de r&eacute;soudre le nom de
 machine pr&eacute;sent&eacute; dans l'URL.
@@ -1,22 +1,22 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
-Relayage interdit.
+Relais interdit.
 </STRONG>
 </UL>
 
 <P>
-Ce cache ne fera pas suivre votre requete car il devrait violer une relation
-hi&eacute;rarchique. Le client %i est peut-etre un cache mal configur&eacute.
+Ce cache ne fera pas suivre votre requ&ecirc;te car il tente de respecter une relation
+de voisinage. Le client %i est peut-&ecirc;tre un cache mal configur&eacute;.
 </P>
@@ -1,21 +1,21 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
-Le FTP est d&eacute;sactiv&eacute;
+Le FTP est d&eacute;sactiv&eacute;.
 </STRONG>
 </UL>
 
 <P>
-Ce cache ne supporte pas le FTP.
+Ce cache ne prend pas en compte le protocole FTP.
 </P>
@@ -1,25 +1,25 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
 Une erreur du protocole FTP est survenue
-en essayant de charger l'URL suivante:
+en essayant de charger l'URL suivante&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-Squid a envoy&eacute; la commande FTP suivante:
+Squid a envoy&eacute; la commande FTP suivante&nbsp;:
 <PRE><STRONG>
 	%f
 </STRONG></PRE>
-et recut alors la r&eacute;ponse
+et a re&ccedil;u la r&eacute;ponse&nbsp;:
 <PRE><STRONG>
 	%F
 </STRONG></PRE>
 <P>
-Ceci pourrait etre caus&eacute; par une URL FTP avec un chemin absolu (ce
-qui est en contradiction avec le RFC 1738). Si il s'agit bien de cette
-cause, alors le fichier peut etre trouv&eacute; &agrave; <A HREF="%B">%B</A>.
+Ceci pourrait &ecirc;tre d&ucirc; &agrave; une URL FTP contenant un chemin absolu&nbsp;(ce
+qui est en contradiction avec la RFC 1738). Dans ce cas,
+ le fichier peut &ecirc;tre r&eacute;cup&eacute;r&eacute; &agrave; l'URL&nbsp;: <A HREF="%B">%B</A>.
 </P>
 
@@ -1,8 +1,8 @@
 <HTML><HEAD>
-<TITLE>FTP PUT r&eacute;ussi: Fichier cr&eacute;e</TITLE>
+<TITLE>FTP PUT r&eacute;ussi&nbsp;: Fichier cr&eacute;&eacute;</TITLE>
 </HEAD><BODY>
-<H1>Operation r&eacute;ussie</H1>
-<H2>Fichier cr&eacute;e</H2>
+<H1>Op&eacute;ration r&eacute;ussie</H1>
+<H2>Fichier cr&eacute;&eacute;</H2>
 <HR>
 <P>
 </P>
@@ -1,23 +1,23 @@
 <HTML><HEAD>
-<TITLE>ERREUR: envoi FTP d&eacute;fectueux</TITLE>
+<TITLE>ERREUR&nbsp;: envoi FTP d&eacute;fectueux</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
 <H2>FTP PUT/envoi d&eacute;fectueux</H2>
 <HR>
 <P>
-En essayant d'envoyer (PUT) l'URL suivante:
+En essayant d'envoyer (PUT) l'URL suivante&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-Squid a envoy&eacute; la commande FTP suivante:
+Squid a envoy&eacute; la commande FTP suivante&nbsp;:
 <PRE><STRONG>
         %f
 </STRONG></PRE>
-et recut alors cette r&eacute;ponse
+et a re&ccedil;u la r&eacute;ponse&nbsp;:
 <PRE><STRONG>
         %F
 </STRONG></PRE>
 <P>
-En d'autres termes:
+En d'autres termes&nbsp;:
 <PRE>
 V&eacute;rifiez le chemin, les droits, l'espace disque et essayez &agrave; nouveau.
 </PRE>
@@ -1,7 +1,7 @@
 <HTML><HEAD>
-<TITLE>FTP PUT r&eacute;ussi: Fichier mis &agrave; jour</TITLE>
+<TITLE>FTP PUT r&eacute;ussi&nbsp;: Fichier mis &agrave; jour</TITLE>
 </HEAD><BODY>
-<H1>Operation r&eacute;ussie</H1>
+<H1>Op&eacute;ration r&eacute;ussie</H1>
 <H2>Fichier mis &agrave; jour</H2>
 <HR>
 <P>
@@ -1,31 +1,31 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de traiter la requete:
+En essayant de traiter la requ&ecirc;te&nbsp;:
 <PRE>
 %R
 </PRE>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
-Requete invalide
+Requ&ecirc;te invalide
 </STRONG>
 </UL>
 
 <P>
-Quelque chose est invalide dans la requete HTTP. Probl&egrave;mes envisageables:
+Quelque chose est invalide dans la requ&eacute;te HTTP. Probl&egrave;mes envisageables&nbsp;:
 <UL>
-<LI>M&eacute;thode de requete absente ou inconnue (GET, POST)
+<LI>M&eacute;thode de requ&ecirc;te absente ou inconnue (GET, POST)
 <LI>Absence d'URL
 <LI>Absence d'identifiant HTTP (HTTP/1.0)
-<LI>La requete est peut etre trop volumineuse
-<LI>Content-Length absent pour les requetes POST ou PUT
-<LI>Caract&egrave;re ill&eacute;gal dans le nom de la machine; les underscores ne sont pas autoris&eacute;s.
+<LI>La requ&ecirc;te est peut-&ecirc;tre trop volumineuse
+<LI>Champ <code>Content-Length</code> absent pour les requ&ecirc;tes POST ou PUT
+<LI>Caract&egrave;re ill&eacute;gal dans le nom de la machine, les soulign&eacute;s (underscores) ne sont pas autoris&eacute;s.
 </UL>
 </P>
@@ -1,14 +1,14 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
@@ -17,11 +17,11 @@ URL invalide
 </UL>
 
 <P>
-Quelque chose dans l'URL est incorrect.  Probl&egrave;mes envisageables:
+Quelque chose dans l'URL est incorrect.  Probl&egrave;mes envisageables&nbsp;:
 <UL>
-<LI>Protocole d'acc&egrave;s absent ou incorrect (il devrait etre de la forme `http://')
+<LI>Protocole d'acc&egrave;s absent ou incorrect (il devrait &ecirc;tre de la forme `http://')
 <LI>Nom de machine absent
 <LI>Double &eacute;chappement ill&eacute;gal dans le chemin de l'URL
-<LI>Caract&egrave;re ill&eacute;gal dans le nom de la machine; les underscores ne sont pas autoris&eacute;s
+<LI>Caract&egrave;re ill&eacute;gal dans le nom de la machine, les soulign&eacute;s (underscores) ne sont pas autoris&eacute;s
 </UL>
 </P>
@@ -1,22 +1,22 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
-Dur&eacute;e de vie de la connexion expir&eacute;e
+Dur&eacute;e de vie de la connexion d&eacute;pass&eacute;e
 </STRONG>
 </UL>
 
 <P>
-Squid a mit fin &agrave; cette requete car elle a exc&eacute;d&eacute; la
+Squid a mis fin &agrave; cette requ&ecirc;te car elle a exc&eacute;d&eacute; la
 dur&eacute;e de vie maximale.
 </P>
@@ -1,22 +1,22 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
-Pas de relai WAIS
+Pas de relais WAIS
 </STRONG>
 </UL>
 
 <P>
-Il n'y a pas de machine d&eacute;finie comme relai WAIS sur ce cache !
+Il n'y a pas de machine d&eacute;finie comme relais WAIS sur ce cache&nbsp;!
 Adressez-vous &agrave; votre administrateur.
 </P>
@@ -1,14 +1,14 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
@@ -19,7 +19,7 @@ Aucun document valide n'a &eacute;t&eacute; trouv&eacute; dans le cache et la di
 
 <P>
 
-Vous avez formul&eacute; une requete avec la directive de controle
+Vous avez formul&eacute; une requ&ecirc;te avec la directive de contr&ocirc;le
 <code>only-if-cached</code>. Le document n'a pas &eacute;t&eacute; trouv&eacute; dans le cache,
 <em>ou</em> il n&eacute;cessite une revalidation, interdite par la directive
 <code>only-if-cached</code>.
@@ -1,14 +1,14 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
@@ -17,10 +17,10 @@ Erreur de lecture
 </UL>
 
 <P>
-Le syst&egrave;me retourna:
+Le syst&egrave;me a retourn&eacute;&nbsp;:
 <PRE><I>    %E</I></PRE>
 
 <P>
 Une erreur est survenue en essayant d'acc&eacute;der au r&eacute;seau.
-Veuillez r&eacute;it&eacute;rer votre requete.
+Veuillez r&eacute;it&eacute;rer votre requ&ecirc;te.
 </P>
@@ -1,28 +1,28 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
-D&eacute;lai de lecture &eacute;coul&eacute;
+D&eacute;lai de lecture d&eacute;pass&eacute;
 </STRONG>
 </UL>
 
 <P>
-Le syst&egrave;me retourna:
+Le syst&egrave;me a retourn&eacute;&nbsp;:
 <PRE><I>    %E</I></PRE>
 
 <P>
 Un d&eacute;lai critique s'est &eacute;coul&eacute; en attendant des
 donn&eacute;es du r&eacute;seau. Le r&eacute;seau ou le serveur sont
-peut-etre hors service ou d&eacute;faillants. Veuillez r&eacute;it&eacute;rer
-votre requete.
+peut-&ecirc;tre hors service ou d&eacute;faillants. Veuillez r&eacute;it&eacute;rer
+votre requ&ecirc;te.
 </P>
@@ -1,14 +1,14 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
@@ -17,11 +17,11 @@ Erreur de socket
 </UL>
 
 <P>
-Le syst&egrave;me retourna:
+Le syst&egrave;me a retourn&eacute;:
 <PRE><I>    %E</I></PRE>
 
 <P>
 Squid n'est pas en mesure de cr&eacute;er une socket TCP, probablement
 &agrave; cause d'une charge excessive. Veuillez r&eacute;it&eacute;rer votre
-requete.
+requ&ecirc;te.
 </P>
@@ -1,23 +1,23 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
-M&eacute;thode et protocole de la requete non g&eacute;r&eacute;s
+Combinaison de m&eacute;thode et de protocole non g&eacute;r&eacute;e
 </STRONG>
 </UL>
 
 <P>
-Squid ne supporte pas toutes les m&eacute;thodes de requetes pour tous les
-protocoles. Par exemple, vous ne pouvez pas POSTer une requete Gopher.
+Squid ne permet pas toutes les m&eacute;thodes de requ&ecirc;tes pour tous les
+protocoles. Vous ne pouvez par exemple pas utiliser le protocole POST dans une requ&ecirc;te Gopher.
 </P>
 
@@ -1,14 +1,14 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URN suivante n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URN suivante n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>Une URL de l'URN n'a pu etre charg&eacute;e</H2>
+<H2>Une URL de l'URN n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URN:
+En essayant de charger l'URN&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
@@ -17,5 +17,5 @@ Impossible de r&eacute;soudre l'URN
 </UL>
 
 <P>
-H&eacute; ! N'en esp&eacute;rez pas trop des URNs de %T :)
+H&eacute;&nbsp;! N'esp&eacute;rez pas trop des URNs de %T :)
 </P>
@@ -1,14 +1,14 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
@@ -17,10 +17,10 @@ Erreur d'&eacute;criture
 </UL>
 
 <P>
-Le syst&egrave;me retourna:
+Le syst&egrave;me a retourn&eacute;&nbsp;:
 <PRE><I>    %E</I></PRE>
 
 <P>
-Une erreur s'est produite en acc&eacute;dant au r&eacute;seau. Veuillez
-r&eacute;it&eacute;rer votre requete.
+Une erreur s'est produite lors de l'acc&egrave;s au r&eacute;seau. Veuillez
+r&eacute;it&eacute;rer votre requ&ecirc;te.
 </P>
@@ -1,14 +1,14 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
@@ -17,5 +17,5 @@ R&eacute;ponse de taille nulle
 </UL>
 
 <P>
-Squid n'a recu aucune donn&eacute;e pour cette requete.
+Squid n'a re&ccedil;u aucune donn&eacute;e pour cette requ&ecirc;te.
 </P>
@@ -1,14 +1,14 @@
 <HTML><HEAD>
-<TITLE>ERREUR: L'URL demand&eacute;e n'a pu etre charg&eacute;e</TITLE>
+<TITLE>ERREUR&nbsp;: L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</TITLE>
 </HEAD><BODY>
 <H1>ERREUR</H1>
-<H2>L'URL demand&eacute;e n'a pu etre charg&eacute;e</H2>
+<H2>L'URL demand&eacute;e n'a pu &ecirc;tre charg&eacute;e</H2>
 <HR>
 <P>
-En essayant de charger l'URL:
+En essayant de charger l'URL&nbsp;:
 <A HREF="%U">%U</A>
 <P>
-L'erreur suivante fut rencontr&eacute;e:
+L'erreur suivante a &eacute;t&eacute; rencontr&eacute;e&nbsp;:
 <UL>
 <LI>
 <STRONG>
@@ -17,11 +17,11 @@ L'erreur suivante fut rencontr&eacute;e:
 </UL>
 
 <P>
-Le syst&egrave;me retourna:
+Le syst&egrave;me a retourn&eacute;&nbsp;:
 <PRE><I>    %E</I></PRE>
 
 <P>
-En d'autres termes:
+En d'autres termes&nbsp;:
 <PRE>
     @LONG_DESCRIPTION@
 </PRE>
@@ -19,4 +19,4 @@ Las reglas de control de acceso impiden que su petici
 permitida en este momento. Contacte con su proveedor de servicios
 si cree que esto es incorrecto.
 </UL>
-
+</P>
@@ -12,7 +12,7 @@ Ha ocurrido el siguiente problema:
 <UL>
 <LI>
 <STRONG>
-Imposibilidad de env�ar la petici�n en este momento.
+Imposibilidad de enviar la petici�n en este momento.
 </STRONG>
 </UL>
 
@@ -24,6 +24,6 @@ este error son:
 <LI>El administrador de la cach� no permite que esta
     cach� realice conexiones directas a los servidores
     origen, y
-<LI>Todas las cach�s configuradas como padres est�n siendo
-    inalcanzables.
+<LI>Todas las cach�s configuradas como padres son inalcanzables
+en este momento.
 </UL>
@@ -22,4 +22,4 @@ El sistema ha devuelto el siguiente mensaje:
 
 <P>
 El equipo remoto o la red pueden estar fuera de servicio.
-Por favor, int�nte de nuevo la petici�n.
+Por favor, intente de nuevo la petici�n en otro momento.
@@ -22,10 +22,11 @@ El programa dnsserver ha devuelto el siguiente mensaje:
 </BLOCKQUOTE>
 
 <P>
-Esto quiere decir que:
+Esto significa que:
 <PRE>
  La cach� no ha sido capaz de resolver el nombre de m�quina
  presente en la URL.
- Compruebe que la direcci�n es correcta.
+ Compruebe que la direcci�n sea correcta.
 </PRE>
+</P>
 
@@ -12,11 +12,12 @@ Ha ocurrido el siguiente problema:
 <UL>
 <LI>
 <STRONG>
-Tramitaci�n denegada.
+Reenv�o denegado.
 </STRONG>
 </UL>
 
 <P>
-Esta cach� no permitir� hacer seguir su petici�n porque trata de obligar a
+Esta cach� no permite reenviar su petici�n porque trata de obligar a
 mantener una relaci�n de hermandad.
 Quiz�s el cliente en %i es una cach� que ha sido mal configurada.
+</P>
@@ -12,9 +12,10 @@ Ha ocurrido el siguiente problema:
 <UL>
 <LI>
 <STRONG>
-Servicio FTP deshabilitado.
+Servicio FTP deshabilitado
 </STRONG>
 </UL>
 
 <P>
-Esta cach� no soporta el protocolo FTP.
+Esta cach� no proporciona servicio cach� para el protocolo FTP.
+</P>
@@ -7,18 +7,15 @@
 <P>
 Ha ocurrido un error de protocolo FTP:
 
-Mientras se intentaba traer el URL:
+mientras se intentaba traer el documento con URL:
 <A HREF="%U">%U</A>
 <P>
-Squid orden� el siguiente comando FTP:
-<PRE><STRONG>
-	%f
-</STRONG></PRE>
+Squid envi� la siguiente orden FTP:
+<BLOCKQUOTE><PRE><STRONG>%f</STRONG></PRE></BLOCKQUOTE>
 y recibi� la siguiente respuesta:
-<PRE><STRONG>
-	%F
-</STRONG></PRE>
+<BLOCKQUOTE><PRE><STRONG>%F</STRONG></PRE></BLOCKQUOTE>
+<BLOCKQUOTE><PRE><STRONG>%g</STRONG></PRE></BLOCKQUOTE>
 <P>
-Esto puede ser causado por una URL de protocolo FTP con un camino
+Esto puede ser causado por una URL de protocolo FTP con una ruta
 de directorios absoluto(que no cumple el RFC 1738). Si esta es la
 causa, el fichero podr�a encontrarse en <A HREF="%B">%B</A>.
@@ -14,18 +14,19 @@ Ha ocurrido el siguiente problema:
 <UL>
 <LI>
 <STRONG>
-Petici�n no valida.
+Petici�n no v�lida.
 </STRONG>
 </UL>
 
 <P>
 Alg�n aspecto de la petici�n HTTP no es v�lido. Posibles problemas:
 <UL>
-<LI>El m�todo de la petici�n falta o es desconocido
-   (no es GET o POST)
+<LI>Falta o es desconocido el m�todo de la petici�n (no es GET ni POST)
 <LI>Falta el URL
 <LI>Falta el identificador HTTP (HTTP/1.0)
-<LI>La petici�n puede ser demasiado grande.
-<LI>Hay caracteres ilegales en el nombre de m�quina.
-    Los subrayados no est�n permitidos en dicha secci�n.
+<LI>La petici�n es demasiado grande.
+<LI>Hay caracteres ilegales en el nombre de m�quina;
+    el car�cter  subrayado (_) no est� permitido.
 </UL>
+</P>
+
@@ -20,7 +20,9 @@ URL incorrecta.
 Alg�n aspecto del URL solicitado es incorrecto. Posibles problemas:
 <UL>
 <LI>Falta o es incorrecto el protocolo de acceso (debe ser `http://'' o similar)
-<LI>Falta el nombre de la m�quina.
-<LI>Hay caracteres ilegales en el nombre de m�quina.
-    Los subrayados no est�n permitidos en dicha secci�n.
+<LI>Falta el nombre de la m�quina
+<LI>Hay un doble-escape ilegas en la ruta de la URL
+<LI>Hay caracteres ilegales en el nombre de m�quina;
+    el caracter de subrayado no est� permitido
 </UL>
+</P>
@@ -12,10 +12,12 @@ Ha ocurrido el siguiente problema:
 <UL>
 <LI>
 <STRONG>
-Ha expirado el tiempo de vida de la conexi�n.
+Ha expirado el tiempo de vida de la conexi�n
 </STRONG>
 </UL>
 
 <P>
-Squid ha dado por terminada una petici�n porque se ha excedido
-el m�ximo tiempo de conexi�n permitido.
+Squid ha dado por terminada la petici�n porque se ha excedido
+el tiempo de vida m�ximo para una conexi�n.
+</P>
+
@@ -12,10 +12,10 @@ Ha ocurrido el siguiente problema:
 <UL>
 <LI>
 <STRONG>
-No hay un retransmisor de protocolo Wais.
+No hay una pasarela para protocolo Wais.
 </STRONG>
 </UL>
 
 <P>
-Esta cach� no tiene definido ning�n retransmisor para el protocolo WAIS !!
-Gr�teselo al administrador de la cach� !!
+Esta cach� no tiene definido ninguna pasarela para el protocolo WAIS !!
+�Gr�teselo al administrador de la cach� !
@@ -12,14 +12,16 @@ Ha ocurrido el siguiente problema:
 <UL>
 <LI>
 <STRONG>
-Error de lectura.
+Error de lectura
 </STRONG>
 </UL>
 
 <P>
 El sistema ha devuelto el siguiente mensaje:
 <PRE><I>    %E</I></PRE>
+</P>
 
 <P>
-Alg�n problema ocurri� mientras se intentaba leer los datos de la red.
-Por favor int�ntelo de nuevo.
+Ha ocurrido alg�n problema mientras se le�an datos de la red.
+Por favor, int�ntelo de nuevo.
+</P>
@@ -12,7 +12,7 @@ Ha ocurrido el siguiente problema:
 <UL>
 <LI>
 <STRONG>
-Ha saltado la alarma de tiempo excesivo en la lectura.
+Se acab� el tiempo m�ximo para lectura de datos de la red.
 </STRONG>
 </UL>
 
@@ -21,7 +21,6 @@ El sistema ha devuelto el siguiente mensaje:
 <PRE><I>    %E</I></PRE>
 
 <P>
-Mientras se esperaba a leer datos de la red ha saltado una alarma
-avisansdo de un exceso en el tiempo transcurrido para la lectura.
-La red o el servidor pueden estar congestionados.
-Por favor, int�ntelo de nuevo.
+Se acab� el tiempo m�ximo de lectura mientras se le�an datos de la red.
+La red o el servidor pueden estar congestionados. Por favor, int�ntelo de nuevo
+</P>
@@ -12,7 +12,7 @@ Ha ocurrido el siguiente problema:
 <UL>
 <LI>
 <STRONG>
-Fallo en el puerto (socket):
+Fallo en el puerto (socket)
 </STRONG>
 </UL>
 
@@ -18,4 +18,4 @@ M
 
 <P>
 Squid no admite todos los m�todos para todos los protocolos de acceso.
-Por ejemplo, Usted no puede hacer un POST a un servidor Gopher.
+Por ejemplo, no se puede hacer un POST a un servidor Gopher.
@@ -2,10 +2,10 @@
 <TITLE>ERROR: El URN solicitado no se ha podido conseguir</TITLE>
 </HEAD><BODY>
 <H1>ERROR</H1>
-<H2>No se ha podido obtener un URL para el URN solicitado</H2>
+<H2>No se ha podido obtener una URL para el URN solicitado</H2>
 <HR>
 <P>
-Mientras se trataba de obtener el URN:
+Mientras se intentaba obtener el URN:
 <A HREF="%U">%U</A>
 <P>
 Ha ocurrido el siguiente problema:
@@ -17,4 +17,5 @@ No se puede resolver el URN
 </UL>
 
 <P>
-No espere mucho sobre URNs en 1998 :)
+Hey, no espere mucho sobre URNs en %T :)
+</P>
@@ -21,5 +21,5 @@ El sistema ha devuelto el siguiente mensaje:
 <PRE><I>    %E</I></PRE>
 
 <P>
-Se ha producido un error mientras se intentaba escribir datos en la red.
+Se ha producido un error mientras se escrib�an datos en la red.
 Por favor, int�ntelo de nuevo.
@@ -17,4 +17,5 @@ Respuesta vac
 </UL>
 
 <P>
-Squid no ha recibido  ninguna informaci�n en respuesta a esta petici�n.
+Squid no ha recibido ninguna informaci�n en respuesta a esta petici�n.
+</P>
@@ -1,4 +1,5 @@
-Thank you to Javier Puche <javier.puche@rediris.es> for 
-creating these error pages in Spanish!
+Thanks to Javier Puche <javier.puche@rediris.es>,
+and Roberto Lumbreras <rover-squid@lander.es>
+for creating these error pages in Spanish!
 
 Note: character set is ISO-LATIN-1
@@ -21,8 +21,8 @@ El sistema ha devuelto el siguiente mensaje:
 <PRE><I>    %E</I></PRE>
 
 <P>
-Que significa que:
+Esto significa que:
 <PRE>
     @LONG_DESCRIPTION@
 </PRE>
-
+</P>
@@ -242,6 +242,16 @@
  */
 #undef fd_mask
 
+/*
+ * If _res structure has nsaddr_list member
+ */
+#undef HAVE_RES_NSADDR_LIST
+
+/*
+ * If _res structure has ns_list member
+ */
+#undef HAVE_RES_NS_LIST
+
 /* The number of bytes in a int.  */
 #undef SIZEOF_INT
 
@@ -302,6 +312,18 @@
 /* Define if you have the poll function.  */
 #undef HAVE_POLL
 
+/* Define if you have the pthread_attr_setschedparam function.  */
+#undef HAVE_PTHREAD_ATTR_SETSCHEDPARAM
+
+/* Define if you have the pthread_attr_setscope function.  */
+#undef HAVE_PTHREAD_ATTR_SETSCOPE
+
+/* Define if you have the pthread_setschedparam function.  */
+#undef HAVE_PTHREAD_SETSCHEDPARAM
+
+/* Define if you have the putenv function.  */
+#undef HAVE_PUTENV
+
 /* Define if you have the random function.  */
 #undef HAVE_RANDOM
 
@@ -461,6 +483,9 @@
 /* Define if you have the <resolv.h> header file.  */
 #undef HAVE_RESOLV_H
 
+/* Define if you have the <sched.h> header file.  */
+#undef HAVE_SCHED_H
+
 /* Define if you have the <signal.h> header file.  */
 #undef HAVE_SIGNAL_H
 
@@ -1,5 +1,5 @@
 /*
- * $Id: util.h,v 1.51 1998/07/22 20:36:31 wessels Exp $
+ * $Id: util.h,v 1.52 1998/11/12 06:30:12 wessels Exp $
  *
  * AUTHOR: Harvest Derived
  *
@@ -62,6 +62,7 @@ extern const char *mkhttpdlogtime(const time_t *);
 extern const char *mkrfc1123(time_t);
 extern char *uudecode(const char *);
 extern char *xstrdup(const char *);
+extern char *xstrndup(const char *, size_t);
 extern const char *xstrerror(void);
 extern const char *xbstrerror(int);
 extern int tvSubMsec(struct timeval, struct timeval);
@@ -1,10 +1,10 @@
 /*
- * $Id: version.h,v 1.120 1998/10/01 22:57:11 wessels Exp $
+ * $Id: version.h,v 1.121 1998/11/12 06:30:13 wessels Exp $
  *
  *  SQUID_VERSION - String for version id of this distribution
  */
 #ifndef SQUID_VERSION
-#define SQUID_VERSION	"2.1.PRE1"
+#define SQUID_VERSION	"2.1.PRE4"
 #endif
 
 #ifndef SQUID_RELEASE_TIME
@@ -1,5 +1,5 @@
 /*
- * $Id: radix.c,v 1.8 1998/09/23 17:14:22 wessels Exp $
+ * $Id: radix.c,v 1.9 1998/11/12 06:30:14 wessels Exp $
  *
  * DEBUG: section 53     Radix tree data structure implementation
  * AUTHOR: NetBSD Derived
@@ -118,7 +118,7 @@ struct radix_mask *rn_mkfreelist;
 struct radix_node_head *mask_rnhead;
 static char *addmask_key;
 static unsigned char normal_chars[] =
-{0, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, -1};
+{0, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xFF};
 static char *rn_zeros, *rn_ones;
 
 #define rn_masktop (mask_rnhead->rnh_treetop)
@@ -1,6 +1,6 @@
 
 /*
- * $Id: rfc1123.c,v 1.20 1998/07/22 20:36:37 wessels Exp $
+ * $Id: rfc1123.c,v 1.21 1998/11/12 06:30:15 wessels Exp $
  *
  * DEBUG: 
  * AUTHOR: Harvest Derived
@@ -43,6 +43,9 @@
 #if HAVE_STDIO_H
 #include <stdio.h>
 #endif
+#if HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
 #if HAVE_STRING_H
 #include <string.h>
 #endif
@@ -152,7 +155,8 @@ parse_rfc1123(const char *str)
 	    return -1;
 	tm.tm_mday = make_num(s + 8);
 	tm.tm_mon = make_month(s + 4);
-	tm.tm_year = make_num(s + 22);
+	/* Y2K fix, richard.kettlewell@kewill.com */
+	tm.tm_year = atoi(s + 20) - 1900;
 	tm.tm_hour = make_num(s + 11);
 	tm.tm_min = make_num(s + 14);
 	tm.tm_sec = make_num(s + 17);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: util.c,v 1.64 1998/09/15 07:17:50 wessels Exp $
+ * $Id: util.c,v 1.65 1998/11/12 06:30:16 wessels Exp $
  *
  * DEBUG: 
  * AUTHOR: Harvest Derived
@@ -63,6 +63,9 @@
 #if HAVE_MATH_H
 #include <math.h>
 #endif
+#if HAVE_ASSERT_H
+#include <assert.h>
+#endif
 
 #include "util.h"
 #include "snprintf.h"
@@ -563,9 +566,7 @@ xcalloc(int n, size_t sz)
 char *
 xstrdup(const char *s)
 {
-    char *p = NULL;
     size_t sz;
-
     if (s == NULL) {
 	if (failure_notify) {
 	    (*failure_notify) ("xstrdup: tried to dup a NULL pointer!\n");
@@ -574,10 +575,24 @@ xstrdup(const char *s)
 	}
 	exit(1);
     }
+    /* copy string, including terminating character */
+    sz = strlen(s) + 1;
+    return memcpy(xmalloc(sz), s, sz);
+}
+
+/*
+ *  xstrndup() - string dup with length limit.
+ */
+char *
+xstrndup(const char *s, size_t n)
+{
+    size_t sz;
+    assert(s);
+    assert(n);
     sz = strlen(s) + 1;
-    p = xmalloc(sz);
-    memcpy(p, s, sz);		/* copy string, including terminating character */
-    return p;
+    if (sz > n)
+	sz = n;
+    return xstrncpy(xmalloc(sz), s, sz);
 }
 
 /*
@@ -647,13 +662,14 @@ tvSubDsec(struct timeval t1, struct timeval t2)
 char *
 xstrncpy(char *dst, const char *src, size_t n)
 {
+    char *r = dst;
     if (!n || !dst)
 	return dst;
     if (src)
 	while (--n != 0 && *src != '\0')
 	    *dst++ = *src++;
     *dst = '\0';
-    return dst;
+    return r;
 }
 
 /* returns the number of leading white spaces in str; handy in skipping ws */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: CacheDigest.cc,v 1.25 1998/07/22 20:36:40 wessels Exp $
+ * $Id: CacheDigest.cc,v 1.26 1998/11/12 06:27:48 wessels Exp $
  *
  * DEBUG: section 70    Cache Digest
  * AUTHOR: Alex Rousskov
@@ -35,6 +35,8 @@
 
 #include "squid.h"
 
+#if USE_CACHE_DIGESTS
+
 /* local types */
 typedef struct {
     int bit_count;		/* total number of bits */
@@ -316,3 +318,5 @@ cacheDigestHashKey(const CacheDigest * cd, const cache_key * key)
 	storeKeyText(key), bit_count,
 	hashed_keys[0], hashed_keys[1], hashed_keys[2], hashed_keys[3]);
 }
+
+#endif
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpHdrRange.cc,v 1.15 1998/09/29 16:33:39 wessels Exp $
+ * $Id: HttpHdrRange.cc,v 1.16 1998/11/12 06:27:49 wessels Exp $
  *
  * DEBUG: section 64    HTTP Range Header
  * AUTHOR: Alex Rousskov
@@ -409,6 +409,21 @@ httpHdrRangeWillBeComplex(const HttpHdrRange * range)
     return 0;
 }
 
+/* hack: returns offset of first range spec */
+size_t
+httpHdrRangeFirstOffset(const HttpHdrRange * range)
+{
+    HttpHdrRangePos pos = HttpHdrRangeInitPos;
+    const HttpHdrRangeSpec *spec;
+    assert(range);
+    while ((spec = httpHdrRangeGetSpec(range, &pos))) {
+	if (!known_spec(spec->offset))	/* ignore unknowns */
+	    continue;
+	return spec->offset;
+    }
+    return 0;
+}
+
 /* generates a "unique" boundary string for multipart responses
  * the caller is responsible for cleaning the string */
 String
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpHeader.cc,v 1.57 1998/09/29 16:33:40 wessels Exp $
+ * $Id: HttpHeader.cc,v 1.58 1998/11/12 06:27:50 wessels Exp $
  *
  * DEBUG: section 55    HTTP Header
  * AUTHOR: Alex Rousskov
@@ -89,7 +89,9 @@ static const HttpHeaderFieldAttrs HeadersAttrs[] =
     {"Expires", HDR_EXPIRES, ftDate_1123},
     {"From", HDR_FROM, ftStr},
     {"Host", HDR_HOST, ftStr},
+    {"If-Match", HDR_IF_MATCH, ftStr},	/* for now */
     {"If-Modified-Since", HDR_IF_MODIFIED_SINCE, ftDate_1123},
+    {"If-None-Match", HDR_IF_NONE_MATCH, ftStr},	/* for now */
     {"If-Range", HDR_IF_RANGE, ftDate_1123_or_ETag},
     {"Last-Modified", HDR_LAST_MODIFIED, ftDate_1123},
     {"Link", HDR_LINK, ftStr},
@@ -137,7 +139,7 @@ static http_hdr_type ListHeadersArr[] =
     HDR_CONTENT_ENCODING,
     HDR_CONTENT_LANGUAGE,
     HDR_CONNECTION,
-    /*  HDR_IF_MATCH, HDR_IF_NONE_MATCH, */
+    HDR_IF_MATCH, HDR_IF_NONE_MATCH,
     HDR_LINK, HDR_PRAGMA,
     /* HDR_TRANSFER_ENCODING, */
     HDR_UPGRADE,
@@ -185,7 +187,8 @@ static http_hdr_type ReplyHeadersArr[] =
 static HttpHeaderMask RequestHeadersMask;	/* set run-time using RequestHeaders */
 static http_hdr_type RequestHeadersArr[] =
 {
-    HDR_AUTHORIZATION, HDR_FROM, HDR_HOST, HDR_IF_MODIFIED_SINCE,
+    HDR_AUTHORIZATION, HDR_FROM, HDR_HOST,
+    HDR_IF_MATCH, HDR_IF_MODIFIED_SINCE, HDR_IF_NONE_MATCH,
     HDR_IF_RANGE, HDR_MAX_FORWARDS, HDR_PROXY_CONNECTION,
     HDR_PROXY_AUTHORIZATION, HDR_RANGE, HDR_REFERER, HDR_REQUEST_RANGE,
     HDR_USER_AGENT, HDR_X_FORWARDED_FOR
@@ -308,15 +311,15 @@ httpHeaderClean(HttpHeader * hdr)
     HttpHeaderStats[hdr->owner].destroyedCount++;
     HttpHeaderStats[hdr->owner].busyDestroyedCount += hdr->entries.count > 0;
     while ((e = httpHeaderGetEntry(hdr, &pos))) {
-	statHistCount(&HttpHeaderStats[hdr->owner].fieldTypeDistr, e->id);
-	/* tmp hack to avoid coredumps */
-	if (e->id < 0 || e->id >= HDR_ENUM_END)
+	/* tmp hack to try to avoid coredumps */
+	if (e->id < 0 || e->id >= HDR_ENUM_END) {
 	    debug(55, 0) ("httpHeaderClean BUG: entry[%d] is invalid (%d). Ignored.\n",
 		pos, e->id);
-	else
-	    /* end of hack */
+	} else {
+	    statHistCount(&HttpHeaderStats[hdr->owner].fieldTypeDistr, e->id);
 	    /* yes, this destroy() leaves us in an incosistent state */
 	    httpHeaderEntryDestroy(e);
+	}
     }
     arrayClean(&hdr->entries);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: HttpReply.cc,v 1.32 1998/10/15 23:40:04 wessels Exp $
+ * $Id: HttpReply.cc,v 1.33 1998/11/12 06:27:51 wessels Exp $
  *
  * DEBUG: section 58    HTTP Reply (Response)
  * AUTHOR: Alex Rousskov
@@ -266,7 +266,8 @@ httpReplyUpdateOnNotModified(HttpReply * rep, HttpReply * freshRep)
     /* clean cache */
     httpReplyHdrCacheClean(rep);
     /* update raw headers */
-    httpHeaderUpdate(&rep->header, &freshRep->header, &Denied304HeadersMask);
+    httpHeaderUpdate(&rep->header, &freshRep->header,
+	(const HttpHeaderMask *) &Denied304HeadersMask);
     /* init cache */
     httpReplyHdrCacheInit(rep);
 }
@@ -1,7 +1,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.162 1998/11/11 20:04:09 glenn Exp $
+#  $Id: Makefile.in,v 1.163 1998/11/12 06:27:51 wessels Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -173,7 +173,7 @@ OBJS	 	= \
 
 SNMP_OBJS	= \
 		snmp_core.o \
-                snmp_agent.o
+		snmp_agent.o
 
 HTCP_OBJS	= htcp.o
 
@@ -234,7 +234,7 @@ squid.conf cf_parser.c: cf.data cf_gen
 	./cf_gen cf.data
 
 cf_gen: cf_gen.o
-	$(CC) -o $@ cf_gen.o
+	$(CC) -o $@ cf_gen.o $(STD_APP_LIBS)
 
 cf.data: cf.data.pre Makefile
 	sed "\
@@ -248,7 +248,7 @@ cf.data: cf.data.pre Makefile
 	s%@DEFAULT_PID_FILE@%$(DEFAULT_PID_FILE)%g;\
 	s%@DEFAULT_SWAP_DIR@%$(DEFAULT_SWAP_DIR)%g;\
 	s%@DEFAULT_ICON_DIR@%$(DEFAULT_ICON_DIR)%g;\
-        s%@DEFAULT_MIB_PATH@%$(DEFAULT_MIB_PATH)%g;\
+	s%@DEFAULT_MIB_PATH@%$(DEFAULT_MIB_PATH)%g;\
 	s%@DEFAULT_ERROR_DIR@%$(DEFAULT_ERROR_DIR)%g;\
 	s%@DEFAULT_PREFIX@%$(DEFAULT_PREFIX)%g;"\
 	< $(srcdir)/cf.data.pre >$@
@@ -1,6 +1,6 @@
 
 /*
- * $Id: StatHist.cc,v 1.18 1998/10/19 22:36:56 wessels Exp $
+ * $Id: StatHist.cc,v 1.19 1998/11/12 06:27:52 wessels Exp $
  *
  * DEBUG: section 62    Generic Histogram
  * AUTHOR: Duane Wessels
@@ -273,7 +273,7 @@ statHistEnumDumper(StoreEntry * sentry, int idx, double val, double size, int co
 void
 statHistIntInit(StatHist * H, int n)
 {
-    statHistInit(H, n, Null, Null, 0, n - 1);
+    statHistInit(H, n, Null, Null, (double) 0, (double) n - 1);
 }
 
 void
@@ -1,7 +1,7 @@
 
 
 /*
- * $Id: access_log.cc,v 1.43 1998/09/30 02:53:17 wessels Exp $
+ * $Id: access_log.cc,v 1.44 1998/11/12 06:27:53 wessels Exp $
  *
  * DEBUG: section 46    Access Log
  * AUTHOR: Duane Wessels
@@ -192,12 +192,13 @@ accessLogCommon(AccessLogEntry * al, MemBuf * mb)
 	client = fqdncache_gethostbyaddr(al->cache.caddr, 0);
     if (client == NULL)
 	client = inet_ntoa(al->cache.caddr);
-    memBufPrintf(mb, "%s %s - [%s] \"%s %s\" %d %d %s:%s",
+    memBufPrintf(mb, "%s %s - [%s] \"%s %s HTTP/%.1f\" %d %d %s:%s",
 	client,
 	al->cache.ident,
 	mkhttpdlogtime(&squid_curtime),
 	al->private.method_str,
 	al->url,
+	al->http.version,
 	al->http.code,
 	al->cache.size,
 	log_tags[al->cache.code],
@@ -1,6 +1,6 @@
 
 /*
- * $Id: acl.cc,v 1.186 1998/11/11 20:04:10 glenn Exp $
+ * $Id: acl.cc,v 1.187 1998/11/12 06:27:54 wessels Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -38,6 +38,7 @@
 
 static int aclFromFile = 0;
 static FILE *aclFile;
+static hash_table *proxy_auth_cache = NULL;
 
 static void aclParseDomainList(void *curlist);
 static void aclParseIpList(void *curlist);
@@ -50,13 +51,12 @@ static void aclParseIntRange(void *curlist);
 static char *strtokFile(void);
 static void aclDestroyAclList(acl_list * list);
 static void aclDestroyTimeList(acl_time_data * data);
-static void aclDestroyProxyAuth(acl_proxy_auth * p);
 static void aclDestroyIntRange(intrange *);
 static FREE aclFreeProxyAuthUser;
 static int aclMatchAcl(struct _acl *, aclCheck_t *);
 static int aclMatchIntegerRange(intrange * data, int i);
 static int aclMatchTime(acl_time_data * data, time_t when);
-static int aclMatchIdent(wordlist * data, const char *ident);
+static int aclMatchUser(wordlist * data, const char *ident);
 static int aclMatchIp(void *dataptr, struct in_addr c);
 static int aclMatchDomainList(void *dataptr, const char *);
 static int aclMatchIntegerRange(intrange * data, int i);
@@ -69,7 +69,8 @@ static IPH aclLookupDstIPDone;
 static IPH aclLookupDstIPforASNDone;
 static FQDNH aclLookupSrcFQDNDone;
 static FQDNH aclLookupDstFQDNDone;
-static void aclProxyAuthDone(void *data, char *result);
+static void aclLookupProxyAuthStart(aclCheck_t * checklist);
+static void aclLookupProxyAuthDone(void *data, char *result);
 static wordlist *aclDumpIpList(void *);
 static wordlist *aclDumpDomainList(void *data);
 static wordlist *aclDumpTimeSpecList(acl_time_data *);
@@ -78,12 +79,12 @@ static wordlist *aclDumpIntlistList(intlist * data);
 static wordlist *aclDumpIntRangeList(intrange * data);
 static wordlist *aclDumpProtoList(intlist * data);
 static wordlist *aclDumpMethodList(intlist * data);
-static wordlist *aclDumpProxyAuthList(acl_proxy_auth * data);
 static SPLAYCMP aclIpNetworkCompare;
 static SPLAYCMP aclHostDomainCompare;
 static SPLAYCMP aclDomainCompare;
 static SPLAYWALKEE aclDumpIpListWalkee;
 static SPLAYWALKEE aclDumpDomainListWalkee;
+static SPLAYFREE aclFreeIpData;
 
 #if USE_ARP_ACL
 static void aclParseArpList(void *curlist);
@@ -129,6 +130,12 @@ strtokFile(void)
 	/* skip leading and trailing white space */
 	t += strspn(buf, w_space);
 	t[strcspn(t, w_space)] = '\0';
+	/* skip comments */
+	if (*t == '#')
+	    goto strtok_again;
+	/* skip blank lines */
+	if (!*t)
+	    goto strtok_again;
 	return t;
     }
 }
@@ -160,8 +167,8 @@ aclStrToType(const char *s)
 	return ACL_URL_REGEX;
     if (!strcmp(s, "port"))
 	return ACL_URL_PORT;
-    if (!strcmp(s, "user"))
-	return ACL_USER;
+    if (!strcmp(s, "ident"))
+	return ACL_IDENT;
     if (!strncmp(s, "proto", 5))
 	return ACL_PROTO;
     if (!strcmp(s, "method"))
@@ -210,8 +217,8 @@ aclTypeToStr(squid_acl type)
 	return "url_regex";
     if (type == ACL_URL_PORT)
 	return "port";
-    if (type == ACL_USER)
-	return "user";
+    if (type == ACL_IDENT)
+	return "ident";
     if (type == ACL_PROTO)
 	return "proto";
     if (type == ACL_METHOD)
@@ -255,7 +262,7 @@ aclParseIntlist(void *curlist)
     char *t = NULL;
     for (Tail = curlist; *Tail; Tail = &((*Tail)->next));
     while ((t = strtokFile())) {
-	q = xcalloc(1, sizeof(intlist));
+	q = memAllocate(MEM_INTLIST);
 	q->i = atoi(t);
 	*(Tail) = q;
 	Tail = &q->next;
@@ -290,7 +297,7 @@ aclParseProtoList(void *curlist)
     char *t = NULL;
     for (Tail = curlist; *Tail; Tail = &((*Tail)->next));
     while ((t = strtokFile())) {
-	q = xcalloc(1, sizeof(intlist));
+	q = memAllocate(MEM_INTLIST);
 	q->i = (int) urlParseProtocol(t);
 	*(Tail) = q;
 	Tail = &q->next;
@@ -305,7 +312,7 @@ aclParseMethodList(void *curlist)
     char *t = NULL;
     for (Tail = curlist; *Tail; Tail = &((*Tail)->next));
     while ((t = strtokFile())) {
-	q = xcalloc(1, sizeof(intlist));
+	q = memAllocate(MEM_INTLIST);
 	q->i = (int) urlParseMethod(t);
 	if (q->i == METHOD_PURGE)
 	    Config.onoff.enable_purge = 1;
@@ -372,7 +379,7 @@ aclParseIpData(const char *t)
     LOCAL_ARRAY(char, addr1, 256);
     LOCAL_ARRAY(char, addr2, 256);
     LOCAL_ARRAY(char, mask, 256);
-    acl_ip_data *q = xcalloc(1, sizeof(acl_ip_data));
+    acl_ip_data *q = memAllocate(MEM_ACL_IP_DATA);
     acl_ip_data *r;
     acl_ip_data **Q;
     struct hostent *hp;
@@ -408,7 +415,7 @@ aclParseIpData(const char *t)
 	Q = &q;
 	for (x = hp->h_addr_list; x != NULL && *x != NULL; x++) {
 	    if ((r = *Q) == NULL)
-		r = *Q = xcalloc(1, sizeof(struct _acl_ip_data));
+		r = *Q = memAllocate(MEM_ACL_IP_DATA);
 	    xmemcpy(&r->addr1.s_addr, *x, sizeof(r->addr1.s_addr));
 	    r->addr2.s_addr = 0;
 	    r->mask.s_addr = no_addr.s_addr;	/* 255.255.255.255 */
@@ -478,7 +485,7 @@ aclParseTimeSpec(void *curlist)
     int h1, m1, h2, m2;
     char *t = NULL;
     for (Tail = curlist; *Tail; Tail = &((*Tail)->next));
-    q = xcalloc(1, sizeof(acl_time_data));
+    q = memAllocate(MEM_ACL_TIME_DATA);
     while ((t = strtokFile())) {
 	if (*t < '0' || *t > '9') {
 	    /* assume its day-of-week spec */
@@ -575,7 +582,7 @@ aclParseRegexList(void *curlist)
 		t, errbuf);
 	    continue;
 	}
-	q = xcalloc(1, sizeof(relist));
+	q = memAllocate(MEM_RELIST);
 	q->pattern = xstrdup(t);
 	q->regex = comp;
 	*(Tail) = q;
@@ -586,16 +593,9 @@ aclParseRegexList(void *curlist)
 static void
 aclParseWordList(void *curlist)
 {
-    wordlist **Tail;
-    wordlist *q = NULL;
     char *t = NULL;
-    for (Tail = curlist; *Tail; Tail = &((*Tail)->next));
-    while ((t = strtokFile())) {
-	q = xcalloc(1, sizeof(wordlist));
-	q->key = xstrdup(t);
-	*(Tail) = q;
-	Tail = &q->next;
-    }
+    while ((t = strtokFile()))
+	wordlistAdd(curlist, t);
 }
 
 /**********************/
@@ -676,7 +676,7 @@ aclParseAclLine(acl ** head)
     }
     if ((A = aclFindByName(aclname)) == NULL) {
 	debug(28, 3) ("aclParseAclLine: Creating ACL '%s'\n", aclname);
-	A = xcalloc(1, sizeof(acl));
+	A = memAllocate(MEM_ACL);
 	xstrncpy(A->name, aclname, ACL_NAME_SZ);
 	A->type = acltype;
 	A->cfgline = xstrdup(config_input_line);
@@ -715,7 +715,7 @@ aclParseAclLine(acl ** head)
     case ACL_URL_PORT:
 	aclParseIntRange(&A->data);
 	break;
-    case ACL_USER:
+    case ACL_IDENT:
 	Config.onoff.ident_lookup = 1;
 	aclParseWordList(&A->data);
 	break;
@@ -729,13 +729,13 @@ aclParseAclLine(acl ** head)
 	aclParseRegexList(&A->data);
 	break;
     case ACL_PROXY_AUTH:
-	aclParseProxyAuth(&A->data);
-	break;
-#if SQUID_SNMP
-    case ACL_SNMP_COMMUNITY:
 	aclParseWordList(&A->data);
+	if (!proxy_auth_cache) {
+	    /* First time around, 7921 should be big enough */
+	    proxy_auth_cache = hash_create((HASHCMP *) strcmp, 7921, hash_string);
+	    assert(proxy_auth_cache);
+	}
 	break;
-#endif
 #if USE_ARP_ACL
     case ACL_SRC_ARP:
 	aclParseArpList(&A->data);
@@ -851,7 +851,7 @@ aclParseAccessLine(acl_access ** head)
 	debug(28, 0) ("aclParseAccessLine: missing 'allow' or 'deny'.\n");
 	return;
     }
-    A = xcalloc(1, sizeof(acl_access));
+    A = memAllocate(MEM_ACL_ACCESS);
 
     if (!strcmp(t, "allow"))
 	A->allow = 1;
@@ -869,7 +869,7 @@ aclParseAccessLine(acl_access ** head)
      * by '!' for negation */
     Tail = &A->acl_list;
     while ((t = strtok(NULL, w_space))) {
-	L = xcalloc(1, sizeof(acl_list));
+	L = memAllocate(MEM_ACL_LIST);
 	L->op = 1;		/* defaults to non-negated */
 	if (*t == '!') {
 	    /* negated ACL */
@@ -901,7 +901,7 @@ aclParseAccessLine(acl_access ** head)
     for (B = *head, T = head; B; T = &B->next, B = B->next);
     *T = A;
     /* We lock _acl_access structures in aclCheck() */
-    cbdataAdd(A, MEM_NONE);
+    cbdataAdd(A, MEM_ACL_ACCESS);
 }
 
 /**************/
@@ -963,109 +963,159 @@ aclMatchRegex(relist * data, const char *word)
 }
 
 static int
-aclMatchIdent(wordlist * data, const char *ident)
+aclMatchUser(wordlist * data, const char *user)
 {
-    if (ident == NULL)
+    if (user == NULL)
 	return 0;
-    debug(28, 3) ("aclMatchIdent: checking '%s'\n", ident);
+    debug(28, 3) ("aclMatchUser: checking '%s'\n", user);
     while (data) {
-	debug(28, 3) ("aclMatchIdent: looking for '%s'\n", data->key);
-	if (strcmp(data->key, "REQUIRED") == 0 && *ident != '\0')
+	debug(28, 3) ("aclMatchUser: looking for '%s'\n", data->key);
+	if (strcmp(data->key, "REQUIRED") == 0 && *user != '\0')
 	    return 1;
-	if (strcmp(data->key, ident) == 0)
+	if (strcmp(data->key, user) == 0)
 	    return 1;
 	data = data->next;
     }
     return 0;
 }
 
-/* aclMatchProxyAuth can return three exit codes:
- * 0 : No such user; invalid Proxy-authorization: header;
- * ask for Proxy-Authorization: header
- * 1 : user validated OK
- * -1 : check the password for this user via an external authenticator
- */
-
 static int
-aclMatchProxyAuth(acl_proxy_auth * p, aclCheck_t * checklist)
+aclDecodeProxyAuth(const char *proxy_auth, char **user, char **password, char *buf, size_t bufsize)
 {
-    LOCAL_ARRAY(char, sent_user, USER_IDENT_SZ);
-    const char *s;
-    char *cleartext;
     char *sent_auth;
-    char *passwd = NULL;
-    acl_proxy_auth_user *u;
-    s = httpHeaderGetStr(&checklist->request->header, HDR_PROXY_AUTHORIZATION);
-    if (s == NULL)
+    char *cleartext;
+
+    if (proxy_auth == NULL)
 	return 0;
-    if (strlen(s) < SKIP_BASIC_SZ)
+    if (strlen(proxy_auth) < SKIP_BASIC_SZ)
 	return 0;
-    s += SKIP_BASIC_SZ;
-    sent_auth = xstrdup(s);	/* username and password */
+    proxy_auth += SKIP_BASIC_SZ;
+    sent_auth = xstrdup(proxy_auth);	/* username and password */
     /* Trim trailing \n before decoding */
     strtok(sent_auth, "\n");
+    /* Trim leading whitespace before decoding */
+    while (isspace(*proxy_auth))
+	proxy_auth++;
     cleartext = uudecode(sent_auth);
     xfree(sent_auth);
-    debug(28, 6) ("aclMatchProxyAuth: cleartext = '%s'\n", cleartext);
-    xstrncpy(sent_user, cleartext, USER_IDENT_SZ);
+    debug(28, 6) ("aclDecodeProxyAuth: cleartext = '%s'\n", cleartext);
+    xstrncpy(buf, cleartext, bufsize);
     xfree(cleartext);
-    if ((passwd = strchr(sent_user, ':')) != NULL)
-	*passwd++ = '\0';
-    if (passwd == NULL) {
-	debug(28, 1) ("aclMatchProxyAuth: no passwd in proxy authorization header\n");
+    *user = buf;
+    if ((*password = strchr(*user, ':')) != NULL)
+	*(*password)++ = '\0';
+    if (password == NULL) {
+	debug(28, 1) ("aclDecodeProxyAuth: no password in proxy authorization header\n");
 	return 0;
     }
-    debug(28, 5) ("aclMatchProxyAuth: checking user '%s'\n", sent_user);
-    /* copy username to checklist for logging on client-side */
-    xstrncpy(checklist->request->user_ident, sent_user, USER_IDENT_SZ);
+    return 1;
+}
 
-    /* see if we already know this user */
-    u = hash_lookup(p->hash, sent_user);
-    if (NULL == u) {
-	/* user not yet known, ask external authenticator */
-	debug(28, 4) ("aclMatchProxyAuth: user '%s' not yet known\n", sent_user);
-    } else {
-	/* user already known, check password with the cached one */
-	if ((0 == strcmp(u->passwd, passwd)) &&
-	    (u->expiretime > current_time.tv_sec)) {
+/* aclMatchProxyAuth can return three exit codes:
+ * 0 : No such user; invalid Proxy-authorization: header;
+ * ask for Proxy-Authorization: header
+ * 1 : user validated OK
+ * -1 : check the password for this user via an external authenticator
+ */
+
+static int
+aclMatchProxyAuth(const char *proxy_auth, acl_proxy_auth_user * auth_user, aclCheck_t * checklist)
+{
+    /* checklist is used to register user name when identified, nothing else */
+    LOCAL_ARRAY(char, login_buf, USER_IDENT_SZ);
+    char *user, *password;
+
+    if (!aclDecodeProxyAuth(proxy_auth, &user, &password, login_buf, sizeof(login_buf)))
+	/* No or invalid Proxy-Auth header */
+	return 0;
+
+    debug(28, 5) ("aclMatchProxyAuth: checking user '%s'\n", user);
+
+    if (!auth_user) {
+	/* see if we already know this user */
+	auth_user = hash_lookup(proxy_auth_cache, user);
+	if (!auth_user) {
+	    /* user not yet known, ask external authenticator */
+	    debug(28, 4) ("aclMatchProxyAuth: user '%s' not yet known\n", user);
+	    return -1;
+	} else if ((0 == strcmp(auth_user->passwd, password)) &&
+	    (auth_user->expiretime > current_time.tv_sec)) {
+	    /* user already known and valid */
 	    debug(28, 5) ("aclMatchProxyAuth: user '%s' previously validated\n",
-		sent_user);
+		user);
+	    /* copy username to request for logging on client-side */
+	    xstrncpy(checklist->request->user_ident, user, USER_IDENT_SZ);
 	    return 1;
+	} else {
+	    /* password mismatch/timeout */
+	    debug(28, 4) ("aclMatchProxyAuth: user '%s' password mismatch/timeout\n",
+		user);
+	    /* remove this user from the hash, making him unknown */
+	    hash_remove_link(proxy_auth_cache, (hash_link *) auth_user);
+	    aclFreeProxyAuthUser(auth_user);
+	    /* copy username to request for logging on client-side unless ident
+	     * is known (do not override ident with false proxy auth names) */
+	    if (!*checklist->request->user_ident)
+		xstrncpy(checklist->request->user_ident, user, USER_IDENT_SZ);
+	    return -1;
 	}
-	/* password mismatch/timeout */
-	debug(28, 4) ("aclMatchProxyAuth: user '%s' password mismatch/timeout\n",
-	    sent_user);
-	/* remove this user from the hash, making him unknown */
-	hash_remove_link(p->hash, (hash_link *) u);
-	aclFreeProxyAuthUser(u);
-    }
-
-    /* we've got an unknown user now */
-    if (checklist->auth_user == NULL) {
-	/* we must still check this user's password */
-	u = memAllocate(MEM_ACL_PROXY_AUTH_USER);
-	u->user = xstrdup(sent_user);
-	u->passwd = xstrdup(passwd);
-	u->passwd_ok = 0;
-	u->expiretime = 0;
-	checklist->auth_user = u;
-	debug(28, 4) ("aclMatchProxyAuth: going to ask authenticator\n");
-	return -1;
+	/* NOTREACHED */
+    } else {
+	/* Check result from external validation */
+	if (checklist->auth_user->passwd_ok != 1) {
+	    /* password was checked but did not match */
+	    assert(checklist->auth_user->passwd_ok == 0);
+	    debug(28, 4) ("aclMatchProxyAuth: authentication failed for user '%s'\n",
+		user);
+	    return 0;
+	}
+	debug(28, 4) ("aclMatchProxyAuth: user '%s' validated OK\n", user);
+	/* store validated user in hash, after filling in expiretime */
+	checklist->auth_user->expiretime = current_time.tv_sec + Config.authenticateTTL;
+	hash_join(proxy_auth_cache, (hash_link *) checklist->auth_user);
+
+	return 1;
     }
-    /* checklist->auth_user has just been checked, check result */
-    if (checklist->auth_user->passwd_ok == -1) {
-	/* password was checked but did not match */
-	debug(28, 4) ("aclMatchProxyAuth: authentication failed for user '%s'\n",
-	    sent_user);
-	return 0;
+
+    /* NOTREACHED */
+
+}
+
+static void
+aclLookupProxyAuthStart(aclCheck_t * checklist)
+{
+    LOCAL_ARRAY(char, login_buf, USER_IDENT_SZ);
+    const char *proxy_auth;
+    char *user, *password;
+    int ok;
+    acl_proxy_auth_user *auth_user;
+
+    assert(!checklist->auth_user);
+
+    if (!checklist->request->flags.accelerated) {
+	/* Proxy auth on proxy requests */
+	proxy_auth = httpHeaderGetStr(&checklist->request->header,
+	    HDR_PROXY_AUTHORIZATION);
+    } else {
+	/* WWW auth on accelerated requests */
+	proxy_auth = httpHeaderGetStr(&checklist->request->header,
+	    HDR_AUTHORIZATION);
     }
-    /* checklist->auth_user->passwd_ok == 1, passwd check OK */
-    debug(28, 4) ("aclMatchProxyAuth: user '%s' validated OK\n", sent_user);
-    /* store validated user in hash, after filling in expiretime */
-    checklist->auth_user->expiretime = current_time.tv_sec + p->timeout;
-    hash_join(p->hash, (hash_link *) checklist->auth_user);
+    ok = aclDecodeProxyAuth(proxy_auth, &user, &password, login_buf,
+	sizeof(login_buf));
+    assert(ok);			/* We should never get here unless the above succeeds in aclMatchProxyAuth */
 
-    return 1;
+    debug(28, 4) ("aclLookupProxyAuthStart: going to ask authenticator on %s\n", user);
+    /* we must still check this user's password */
+    auth_user = memAllocate(MEM_ACL_PROXY_AUTH_USER);
+    auth_user->user = xstrdup(user);
+    auth_user->passwd = xstrdup(password);
+    auth_user->passwd_ok = -1;
+    auth_user->expiretime = -1;
+    checklist->auth_user = auth_user;
+
+    authenticateStart(checklist->auth_user, aclLookupProxyAuthDone,
+	checklist);
 }
 
 static int
@@ -1140,12 +1190,12 @@ aclMatchTime(acl_time_data * data, time_t when)
 }
 
 static int
-aclMatchWordList(wordlist * w, const char *community)
+aclMatchWordList(wordlist * w, const char *word)
 {
-    debug(28, 3) ("aclMatchWordList: looking for '%s'\n", community);
+    debug(28, 3) ("aclMatchWordList: looking for '%s'\n", word);
     while (w != NULL) {
 	debug(28, 3) ("aclMatchWordList: checking '%s'\n", w->key);
-	if (!strcmp(w->key, community))
+	if (!strcmp(w->key, word))
 	    return 1;
 	w = w->next;
     }
@@ -1256,8 +1306,8 @@ aclMatchAcl(acl * ae, aclCheck_t * checklist)
     case ACL_URL_PORT:
 	return aclMatchIntegerRange(ae->data, r->port);
 	/* NOTREACHED */
-    case ACL_USER:
-	return aclMatchIdent(ae->data, checklist->ident);
+    case ACL_IDENT:
+	return aclMatchUser(ae->data, checklist->ident);
 	/* NOTREACHED */
     case ACL_PROTO:
 	return aclMatchInteger(ae->data, r->protocol);
@@ -1269,19 +1319,51 @@ aclMatchAcl(acl * ae, aclCheck_t * checklist)
 	return aclMatchRegex(ae->data, checklist->browser);
 	/* NOTREACHED */
     case ACL_PROXY_AUTH:
-	k = aclMatchProxyAuth(ae->data, checklist);
+	if (!r->flags.accelerated) {
+	    /* Proxy authorization on proxy requests */
+	    k = aclMatchProxyAuth(httpHeaderGetStr(&checklist->request->header,
+		    HDR_PROXY_AUTHORIZATION),
+		checklist->auth_user,
+		checklist);
+	} else if (r->flags.internal) {
+	    /* WWW authorization on accelerated internal requests */
+	    k = aclMatchProxyAuth(httpHeaderGetStr(&checklist->request->header,
+		    HDR_AUTHORIZATION),
+		checklist->auth_user,
+		checklist);
+	} else {
+#if AUTH_ON_ACCELERATION
+	    /* WWW authorization on accelerated requests */
+	    k = aclMatchProxyAuth(httpHeaderGetStr(&checklist->request->header,
+		    HDR_AUTHORIZATION),
+		checklist->auth_user,
+		checklist);
+#else
+	    debug(28, 1) ("aclMatchAcl: proxy_auth %s not applicable on accelerated requests.\n", ae->name);
+	    return -1;
+#endif
+	}
 	if (k == 0) {
 	    /* no such user OR we need a proxy authentication header */
 	    checklist->state[ACL_PROXY_AUTH] = ACL_PROXY_AUTH_NEEDED;
+	    /*
+	     * XXX This is a bit oddly done.. should perhaps use different
+	     * return codes here
+	     */
 	    return 0;
 	} else if (k == 1) {
-	    /* register that we used the proxy authentication header */
-	    checklist->state[ACL_PROXY_AUTH] = ACL_PROXY_AUTH_USED;
+	    /*
+	     * Authentication successful. Register that we used the proxy
+	     * authentication header so that it is not forwarded to the
+	     * next proxy
+	     */
 	    r->flags.used_proxy_auth = 1;
 	    return 1;
 	} else if (k == -1) {
-	    /* register that we need to check the password */
-	    checklist->state[ACL_PROXY_AUTH] = ACL_PROXY_AUTH_CHECK;
+	    /*
+	     * we need to validate the password
+	     */
+	    checklist->state[ACL_PROXY_AUTH] = ACL_LOOKUP_NEEDED;
 	    return 0;
 	}
 	/* NOTREACHED */
@@ -1372,7 +1454,6 @@ aclCheck(aclCheck_t * checklist)
 	debug(28, 3) ("aclCheck: checking '%s'\n", A->cfgline);
 	allow = A->allow;
 	match = aclMatchAclList(A->acl_list, checklist);
-
 	if (checklist->state[ACL_DST_IP] == ACL_LOOKUP_NEEDED) {
 	    checklist->state[ACL_DST_IP] = ACL_LOOKUP_PENDING;
 	    ipcache_nbgethostbyname(checklist->request->host,
@@ -1403,26 +1484,29 @@ aclCheck(aclCheck_t * checklist)
 		aclLookupDstFQDNDone,
 		checklist);
 	    return;
-	}
-	/* extra case for proxy_auth */
-	if (checklist->state[ACL_PROXY_AUTH] == ACL_PROXY_AUTH_CHECK) {
+	} else if (checklist->state[ACL_PROXY_AUTH] == ACL_LOOKUP_NEEDED) {
 	    debug(28, 3) ("aclCheck: checking password via authenticator\n");
-	    authenticateStart(checklist->auth_user, aclProxyAuthDone,
-		checklist);
+	    aclLookupProxyAuthStart(checklist);
+	    checklist->state[ACL_PROXY_AUTH] = ACL_LOOKUP_PENDING;
+	    return;
+	} else if (checklist->state[ACL_PROXY_AUTH] == ACL_PROXY_AUTH_NEEDED) {
+	    /* Special case. Client is required to resend the request
+	     * with authentication. The request is denied.
+	     */
+	    allow = ACCESS_REQ_PROXY_AUTH;
+	    match = -1;
+	} else if (checklist->state[ACL_IDENT] == ACL_LOOKUP_NEEDED) {
+	    debug(28, 3) ("aclCheck: Doing ident lookup\n");
+	    /* XXX how to do ident lookup? */
+	    checklist->state[ACL_IDENT] = ACL_LOOKUP_PENDING;
 	    return;
 	}
 	/*
 	 * We are done with this _acl_access entry.  Either the request
-	 * is allowed, denied, or we move on to the next entry.
+	 * is allowed, denied, requires authentication, or we move on to
+	 * the next entry.
 	 */
 	cbdataUnlock(A);
-	if (checklist->state[ACL_PROXY_AUTH] == ACL_PROXY_AUTH_NEEDED) {
-	    allow = ACCESS_REQ_PROXY_AUTH;
-	    debug(28, 3) ("aclCheck: match pending, returning %d\n", allow);
-	    aclCheckCallback(checklist, allow);
-	    return;
-	}
-	/* checklist->state[ACL_PROXY_AUTH] == ACL_PROXY_AUTH_USED */
 	if (match) {
 	    debug(28, 3) ("aclCheck: match found, returning %d\n", allow);
 	    aclCheckCallback(checklist, allow);
@@ -1499,15 +1583,16 @@ aclLookupDstFQDNDone(const char *fqdn, void *data)
 }
 
 static void
-aclProxyAuthDone(void *data, char *result)
+aclLookupProxyAuthDone(void *data, char *result)
 {
     aclCheck_t *checklist = data;
     checklist->state[ACL_PROXY_AUTH] = ACL_LOOKUP_DONE;
-    debug(28, 4) ("aclProxyAuthDone: result = %s\n", result);
+    debug(28, 4) ("aclLookupProxyAuthDone: result = %s\n",
+	result ? result : "NULL");
     if (result && (strncasecmp(result, "OK", 2) == 0))
 	checklist->auth_user->passwd_ok = 1;
     else
-	checklist->auth_user->passwd_ok = -1;
+	checklist->auth_user->passwd_ok = 0;
     aclCheck(checklist);
 }
 
@@ -1519,8 +1604,8 @@ aclChecklistCreate(const acl_access * A,
     const char *ident)
 {
     int i;
-    aclCheck_t *checklist = xcalloc(1, sizeof(aclCheck_t));
-    cbdataAdd(checklist, MEM_NONE);
+    aclCheck_t *checklist = memAllocate(MEM_ACLCHECK_T);
+    cbdataAdd(checklist, MEM_ACLCHECK_T);
     checklist->access_list = A;
     /*
      * aclCheck() makes sure checklist->access_list is a valid
@@ -1565,7 +1650,7 @@ aclDestroyTimeList(acl_time_data * data)
     acl_time_data *next = NULL;
     for (; data; data = next) {
 	next = data->next;
-	safe_free(data);
+	memFree(MEM_ACL_TIME_DATA, data);
     }
 }
 
@@ -1577,7 +1662,7 @@ aclDestroyRegexList(relist * data)
 	next = data->next;
 	regfree(&data->regex);
 	safe_free(data->pattern);
-	safe_free(data);
+	memFree(MEM_RELIST, data);
     }
 }
 
@@ -1591,12 +1676,9 @@ aclFreeProxyAuthUser(void *data)
 }
 
 static void
-aclDestroyProxyAuth(acl_proxy_auth * p)
+aclFreeIpData(void *p)
 {
-    hashFreeItems(p->hash, aclFreeProxyAuthUser);
-    hashFreeMemory(p->hash);
-    p->hash = NULL;
-    safe_free(p);
+    memFree(MEM_ACL_IP_DATA, p);
 }
 
 void
@@ -1610,17 +1692,18 @@ aclDestroyAcls(acl ** head)
 	switch (a->type) {
 	case ACL_SRC_IP:
 	case ACL_DST_IP:
-	case ACL_SRC_ARP:
-	    splay_destroy(a->data, xfree);
+	    splay_destroy(a->data, aclFreeIpData);
 	    break;
+	case ACL_SRC_ARP:
 	case ACL_DST_DOMAIN:
 	case ACL_SRC_DOMAIN:
 	    splay_destroy(a->data, xfree);
 	    break;
-	case ACL_USER:
 #if SQUID_SNMP
 	case ACL_SNMP_COMMUNITY:
 #endif
+	case ACL_IDENT:
+	case ACL_PROXY_AUTH:
 	    wordlistDestroy((wordlist **) & a->data);
 	    break;
 	case ACL_TIME:
@@ -1640,16 +1723,13 @@ aclDestroyAcls(acl ** head)
 	case ACL_URL_PORT:
 	    aclDestroyIntRange(a->data);
 	    break;
-	case ACL_PROXY_AUTH:
-	    aclDestroyProxyAuth(a->data);
-	    break;
 	case ACL_NONE:
 	default:
 	    assert(0);
 	    break;
 	}
 	safe_free(a->cfgline);
-	safe_free(a);
+	memFree(MEM_ACL, a);
     }
     *head = NULL;
 }
@@ -1660,7 +1740,7 @@ aclDestroyAclList(acl_list * list)
     acl_list *next = NULL;
     for (; list; list = next) {
 	next = list->next;
-	safe_free(list);
+	memFree(MEM_ACL_LIST, list);
     }
 }
 
@@ -1813,16 +1893,13 @@ aclDumpIpListWalkee(void *node, void *state)
     acl_ip_data *ip = node;
     MemBuf mb;
     wordlist **W = state;
-    while (*W != NULL)
-	W = &(*W)->next;
     memBufDefInit(&mb);
     memBufPrintf(&mb, "%s", inet_ntoa(ip->addr1));
     if (ip->addr2.s_addr != any_addr.s_addr)
 	memBufPrintf(&mb, "-%s", inet_ntoa(ip->addr2));
     if (ip->mask.s_addr != no_addr.s_addr)
 	memBufPrintf(&mb, "/%s", inet_ntoa(ip->mask));
-    *W = xcalloc(1, sizeof(wordlist));
-    (*W)->key = xstrdup(mb.buf);
+    wordlistAdd(W, mb.buf);
     memBufClean(&mb);
 }
 
@@ -1838,11 +1915,7 @@ static void
 aclDumpDomainListWalkee(void *node, void *state)
 {
     char *domain = node;
-    wordlist **W = state;
-    while (*W != NULL)
-	W = &(*W)->next;
-    *W = xcalloc(1, sizeof(wordlist));
-    (*W)->key = xstrdup(domain);
+    wordlistAdd(state, domain);
 }
 
 static wordlist *
@@ -1857,10 +1930,8 @@ static wordlist *
 aclDumpTimeSpecList(acl_time_data * t)
 {
     wordlist *W = NULL;
-    wordlist **T = &W;
     char buf[128];
     while (t != NULL) {
-	wordlist *w = xcalloc(1, sizeof(wordlist));
 	snprintf(buf, sizeof(buf), "%c%c%c%c%c%c%c %02d:%02d-%02d:%02d",
 	    t->weekbits & ACL_SUNDAY ? 'S' : '-',
 	    t->weekbits & ACL_MONDAY ? 'M' : '-',
@@ -1873,9 +1944,7 @@ aclDumpTimeSpecList(acl_time_data * t)
 	    t->start % 60,
 	    t->stop / 60,
 	    t->stop % 60);
-	w->key = xstrdup(buf);
-	*T = w;
-	T = &w->next;
+	wordlistAdd(&W, buf);
 	t = t->next;
     }
     return W;
@@ -1885,13 +1954,8 @@ static wordlist *
 aclDumpRegexList(relist * data)
 {
     wordlist *W = NULL;
-    wordlist **T = &W;
-    wordlist *w;
     while (data != NULL) {
-	w = xcalloc(1, sizeof(wordlist));
-	w->key = xstrdup(data->pattern);
-	*T = w;
-	T = &w->next;
+	wordlistAdd(&W, data->pattern);
 	data = data->next;
     }
     return W;
@@ -1901,14 +1965,10 @@ static wordlist *
 aclDumpIntlistList(intlist * data)
 {
     wordlist *W = NULL;
-    wordlist **T = &W;
     char buf[32];
     while (data != NULL) {
-	wordlist *w = xcalloc(1, sizeof(wordlist));
 	snprintf(buf, sizeof(buf), "%d", data->i);
-	w->key = xstrdup(buf);
-	*T = w;
-	T = &w->next;
+	wordlistAdd(&W, buf);
 	data = data->next;
     }
     return W;
@@ -1918,17 +1978,13 @@ static wordlist *
 aclDumpIntRangeList(intrange * data)
 {
     wordlist *W = NULL;
-    wordlist **T = &W;
     char buf[32];
     while (data != NULL) {
-	wordlist *w = xcalloc(1, sizeof(wordlist));
 	if (data->i == data->j)
 	    snprintf(buf, sizeof(buf), "%d", data->i);
 	else
 	    snprintf(buf, sizeof(buf), "%d-%d", data->i, data->j);
-	w->key = xstrdup(buf);
-	*T = w;
-	T = &w->next;
+	wordlistAdd(&W, buf);
 	data = data->next;
     }
     return W;
@@ -1938,13 +1994,8 @@ static wordlist *
 aclDumpProtoList(intlist * data)
 {
     wordlist *W = NULL;
-    wordlist **T = &W;
-    wordlist *w;
     while (data != NULL) {
-	w = xcalloc(1, sizeof(wordlist));
-	w->key = xstrdup(ProtocolStr[data->i]);
-	*T = w;
-	T = &w->next;
+	wordlistAdd(&W, ProtocolStr[data->i]);
 	data = data->next;
     }
     return W;
@@ -1954,47 +2005,29 @@ static wordlist *
 aclDumpMethodList(intlist * data)
 {
     wordlist *W = NULL;
-    wordlist **T = &W;
-    wordlist *w;
     while (data != NULL) {
-	w = xcalloc(1, sizeof(wordlist));
-	w->key = xstrdup(RequestMethodStr[data->i]);
-	*T = w;
-	T = &w->next;
+	wordlistAdd(&W, RequestMethodStr[data->i]);
 	data = data->next;
     }
     return W;
 }
 
-static wordlist *
-aclDumpProxyAuthList(acl_proxy_auth * data)
-{
-    wordlist *W = NULL;
-    wordlist **T = &W;
-    char buf[MAXPATHLEN];
-    wordlist *w = xcalloc(1, sizeof(wordlist));
-    assert(data != NULL);
-    snprintf(buf, sizeof(buf), "%d\n", data->timeout);
-    w->key = xstrdup(buf);
-    *T = w;
-    T = &w->next;
-    return W;
-}
-
 wordlist *
 aclDumpGeneric(const acl * a)
 {
+    debug(28, 3) ("aclDumpGeneric: %s type %d\n", a->name, a->type);
     switch (a->type) {
     case ACL_SRC_IP:
     case ACL_DST_IP:
 	return aclDumpIpList(a->data);
 	break;
     case ACL_SRC_DOMAIN:
     case ACL_DST_DOMAIN:
-    case ACL_USER:
 #if SQUID_SNMP
     case ACL_SNMP_COMMUNITY:
 #endif
+    case ACL_IDENT:
+    case ACL_PROXY_AUTH:
 	return aclDumpDomainList(a->data);
 	break;
     case ACL_TIME:
@@ -2018,9 +2051,6 @@ aclDumpGeneric(const acl * a)
     case ACL_METHOD:
 	return aclDumpMethodList(a->data);
 	break;
-    case ACL_PROXY_AUTH:
-	return aclDumpProxyAuthList(a->data);
-	break;
 #if USE_ARP_ACL
     case ACL_SRC_ARP:
 	return aclDumpArpList(a->data);
@@ -2252,8 +2282,7 @@ aclDumpArpListWalkee(void *node, void *state)
     snprintf(buf, sizeof(buf), "%02x:%02x:02x:02x:02x:02x",
 	arp->eth[0], arp->eth[1], arp->eth[2], arp->eth[3],
 	arp->eth[4], arp->eth[5]);
-    *W = xcalloc(1, sizeof(wordlist));
-    (*W)->key = xstrdup(buf);
+    wordlistAdd(state, buf);
 }
 
 static wordlist *
@@ -1,5 +1,5 @@
 /*
- * $Id: asn.cc,v 1.50 1998/10/21 06:54:18 wessels Exp $
+ * $Id: asn.cc,v 1.51 1998/11/12 06:27:55 wessels Exp $
  *
  * DEBUG: section 53    AS Number handling
  * AUTHOR: Duane Wessels, Kostas Anagnostakis
@@ -151,7 +151,7 @@ asnInit(void)
     static int inited = 0;
     max_keylen = 40;
     if (0 == inited++)
-        rn_init();
+	rn_init();
     rn_inithead((void **) &AS_tree_head, 8);
     asnAclInitialize(Config.aclList);
     cachemgrRegister("asndb", "AS Number Database", asnStats, 0, 1);
@@ -300,7 +300,7 @@ asnAddNet(char *as_string, int as_number)
     char dbg1[32], dbg2[32];
     intlist **Tail = NULL;
     intlist *q = NULL;
-    as_info *as_info = NULL;
+    as_info *asinfo = NULL;
     struct in_addr in_a, in_m;
     long mask, addr;
     char *t;
@@ -332,34 +332,34 @@ asnAddNet(char *as_string, int as_number)
     store_m_int(mask, e->e_mask);
     rn = rn_lookup(e->e_addr, e->e_mask, AS_tree_head);
     if (rn != NULL) {
-	as_info = ((rtentry *) rn)->e_info;
-	if (intlistFind(as_info->as_number, as_number)) {
+	asinfo = ((rtentry *) rn)->e_info;
+	if (intlistFind(asinfo->as_number, as_number)) {
 	    debug(53, 3) ("asnAddNet: Ignoring repeated network '%s/%d' for AS %d\n",
 		dbg1, bitl, as_number);
 	} else {
 	    debug(53, 3) ("asnAddNet: Warning: Found a network with multiple AS numbers!\n");
-	    for (Tail = &as_info->as_number; *Tail; Tail = &(*Tail)->next);
+	    for (Tail = &asinfo->as_number; *Tail; Tail = &(*Tail)->next);
 	    q = xcalloc(1, sizeof(intlist));
 	    q->i = as_number;
 	    *(Tail) = q;
-	    e->e_info = as_info;
+	    e->e_info = asinfo;
 	}
     } else {
 	q = xcalloc(1, sizeof(intlist));
 	q->i = as_number;
-	as_info = xmalloc(sizeof(as_info));
-	as_info->as_number = q;
+	asinfo = xmalloc(sizeof(asinfo));
+	asinfo->as_number = q;
 	rn = rn_addroute(e->e_addr, e->e_mask, AS_tree_head, e->e_nodes);
 	rn = rn_match(e->e_addr, AS_tree_head);
 	assert(rn != NULL);
-	e->e_info = as_info;
+	e->e_info = asinfo;
     }
     if (rn == 0) {
 	xfree(e);
 	debug(53, 3) ("asnAddNet: Could not add entry.\n");
 	return 0;
     }
-    e->e_info = as_info;
+    e->e_info = asinfo;
     return 1;
 }
 
@@ -409,17 +409,18 @@ printRadixNode(struct radix_node *rn, void *w)
     StoreEntry *sentry = w;
     rtentry *e = (rtentry *) rn;
     intlist *q;
-    as_info *as_info;
+    as_info *asinfo;
     struct in_addr addr;
     struct in_addr mask;
     assert(e);
+    assert(e->e_info);
     (void) get_m_int(addr.s_addr, e->e_addr);
     (void) get_m_int(mask.s_addr, e->e_mask);
     storeAppendPrintf(sentry, "%15s/%d\t",
 	inet_ntoa(addr), mask_len(ntohl(mask.s_addr)));
-    assert(as_info = e->e_info);
-    assert(as_info->as_number);
-    for (q = as_info->as_number; q; q = q->next)
+    asinfo = e->e_info;
+    assert(asinfo->as_number);
+    for (q = asinfo->as_number; q; q = q->next)
 	storeAppendPrintf(sentry, " %d", q->i);
     storeAppendPrintf(sentry, "\n");
     return 0;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: authenticate.cc,v 1.8 1998/10/19 22:36:57 wessels Exp $
+ * $Id: authenticate.cc,v 1.9 1998/11/12 06:27:56 wessels Exp $
  *
  * DEBUG: section 29    Authenticator
  * AUTHOR: Duane Wessels
@@ -51,11 +51,13 @@ authenticateHandleReply(void *data, char *reply)
     authenticateStateData *r = data;
     int valid;
     char *t = NULL;
-    debug(29, 5) ("authenticateHandleReply: {%s}\n", reply);
-    if ((t = strchr(reply, ' ')))
-	*t = '\0';
-    if (*reply == '\0')
-	reply = NULL;
+    debug(29, 5) ("authenticateHandleReply: {%s}\n", reply ? reply : "<NULL>");
+    if (reply) {
+	if ((t = strchr(reply, ' ')))
+	    *t = '\0';
+	if (*reply == '\0')
+	    reply = NULL;
+    }
     valid = cbdataValid(r->data);
     cbdataUnlock(r->data);
     if (valid)
@@ -95,6 +97,7 @@ authenticateStart(acl_proxy_auth_user * auth_user, RH * handler, void *data)
     r = xcalloc(1, sizeof(authenticateStateData));
     cbdataAdd(r, MEM_NONE);
     r->handler = handler;
+    cbdataLock(data);
     r->data = data;
     r->auth_user = auth_user;
     snprintf(buf, 8192, "%s %s\n", r->auth_user->user, r->auth_user->passwd);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: cache_cf.cc,v 1.309 1998/11/11 20:04:12 glenn Exp $
+ * $Id: cache_cf.cc,v 1.310 1998/11/12 06:27:57 wessels Exp $
  *
  * DEBUG: section 3     Configuration File Parsing
  * AUTHOR: Harvest Derived
@@ -87,31 +87,20 @@ wordlistDestroy(wordlist ** list)
     while ((w = *list) != NULL) {
 	*list = w->next;
 	safe_free(w->key);
-	safe_free(w);
+	memFree(MEM_WORDLIST, w);
     }
     *list = NULL;
 }
 
-void
+wordlist *
 wordlistAdd(wordlist ** list, const char *key)
 {
-    wordlist *p = NULL;
-    wordlist *q = NULL;
-
-    if (!(*list)) {
-	/* empty list */
-	*list = xcalloc(1, sizeof(wordlist));
-	(*list)->key = xstrdup(key);
-	(*list)->next = NULL;
-    } else {
-	p = *list;
-	while (p->next)
-	    p = p->next;
-	q = xcalloc(1, sizeof(wordlist));
-	q->key = xstrdup(key);
-	q->next = NULL;
-	p->next = q;
-    }
+    while (*list)
+	list = &(*list)->next;
+    *list = memAllocate(MEM_WORDLIST);
+    (*list)->key = xstrdup(key);
+    (*list)->next = NULL;
+    return *list;
 }
 
 void
@@ -130,7 +119,7 @@ intlistDestroy(intlist ** list)
     intlist *n = NULL;
     for (w = *list; w; w = n) {
 	n = w->next;
-	safe_free(w);
+	memFree(MEM_INTLIST, w);
     }
     *list = NULL;
 }
@@ -417,8 +406,10 @@ dump_acl(StoreEntry * entry, const char *name, acl * ae)
     wordlist *w;
     wordlist *v;
     while (ae != NULL) {
+	debug(3, 3) ("dump_acl: %s %s\n", name, ae->name);
 	v = w = aclDumpGeneric(ae);
 	while (v != NULL) {
+	    debug(3, 3) ("dump_acl: %s %s %s\n", name, ae->name, v->key);
 	    storeAppendPrintf(entry, "%s %s %s %s\n",
 		name,
 		ae->name,
@@ -538,7 +529,7 @@ parse_cachedir(cacheSwap * swap)
     int size;
     int l1;
     int l2;
-    int readonly = 0;
+    int read_only = 0;
     SwapDir *tmp = NULL;
     if ((path = strtok(NULL, w_space)) == NULL)
 	self_destruct();
@@ -556,7 +547,7 @@ parse_cachedir(cacheSwap * swap)
 	fatal("parse_cachedir: invalid level 2 directories value");
     if ((token = strtok(NULL, w_space)))
 	if (!strcasecmp(token, "read-only"))
-	    readonly = 1;
+	    read_only = 1;
     for (i = 0; i < swap->n_configured; i++) {
 	tmp = swap->swapDirs + i;
 	if (!strcmp(path, tmp->path)) {
@@ -568,10 +559,10 @@ parse_cachedir(cacheSwap * swap)
 		debug(3, 1) ("Cache dir '%s' size changed to %d KB\n",
 		    path, size);
 	    tmp->max_size = size;
-	    if (tmp->read_only != readonly)
+	    if (tmp->read_only != read_only)
 		debug(3, 1) ("Cache dir '%s' now %s\n",
-		    readonly ? "Read-Only" : "Read-Write");
-	    tmp->read_only = readonly;
+		    path, read_only ? "Read-Only" : "Read-Write");
+	    tmp->read_only = read_only;
 	    return;
 	}
     }
@@ -591,7 +582,7 @@ parse_cachedir(cacheSwap * swap)
     tmp->max_size = size;
     tmp->l1 = l1;
     tmp->l2 = l2;
-    tmp->read_only = readonly;
+    tmp->read_only = read_only;
     tmp->swaplog_fd = -1;
     swap->n_configured++;
 }
@@ -745,6 +736,8 @@ parse_peer(peer ** head)
 	} else if (!strcasecmp(token, "no-delay")) {
 	    p->options.no_delay = 1;
 #endif
+	} else if (!strncasecmp(token, "login=", 6)) {
+	    p->login = xstrdup(token + 6);
 	} else {
 	    debug(3, 0) ("parse_peer: token='%s'\n", token);
 	    self_destruct();
@@ -1,6 +1,6 @@
 
 #
-# $Id: cf.data.pre,v 1.123 1998/11/11 20:04:12 glenn Exp $
+# $Id: cf.data.pre,v 1.124 1998/11/12 06:27:57 wessels Exp $
 #
 #
 # SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -213,6 +213,7 @@ DOC_START
 		     no-digest
 		     no-netdb-exchange
 		     no-delay
+		     login=user:password
 
 		     use 'proxy-only' to specify that objects fetched
 		     from this cache should not be saved locally.
@@ -258,6 +259,9 @@ DOC_START
 		     use 'no-delay' to prevent access to this neighbor
 		     from influencing the delay pools.
 
+		     use 'login=user:password' if this is a personal/workgroup
+		     proxy and your parent requires proxy authentication.
+
 	NOTE: non-ICP neighbors must be specified as 'parent'.
 
 cache_peer hostname type 3128 3130
@@ -944,6 +948,18 @@ DOC_START
 redirect_children 5
 DOC_END
 
+NAME: redirect_rewrites_host_header
+TYPE: onoff
+DEFAULT: on
+LOC: Config.onoff.redir_rewrites_host
+DOC_START
+	By default Squid rewrites any Host: header in redirected requests.
+	If you are running a accelerator then this may not be a wanted effect
+	of a redirector.
+redirect_rewrites_host_header on
+DOC_END
+
+
 NAME: authenticate_program
 TYPE: wordlist
 LOC: Config.Program.authenticate
@@ -982,6 +998,19 @@ DOC_START
 authenticate_children 5
 DOC_END
 
+NAME: authenticate_ttl
+TYPE: int
+DEFAULT: 3600
+LOC: Config.authenticateTTL
+DOC_START
+	The time a checked username/password combination remains cached
+	(default 3600). If a wrong password is given for a cached user,
+	the user gets removed from the username/password cache forcing
+	a revalidation.
+
+authenticate_ttl 3600
+DOC_END
+
 COMMENT_START
  OPTIONS FOR TUNING THE CACHE
  -----------------------------------------------------------------------------
@@ -1103,21 +1132,21 @@ DOC_END
 NAME: quick_abort_min
 COMMENT: (KB)
 TYPE: kb_size_t
-DEFAULT: -1 kb
+DEFAULT: 16 KB
 LOC: Config.quickAbort.min
 DOC_NONE
 
 NAME: quick_abort_max
 COMMENT: (KB)
 TYPE: kb_size_t
-DEFAULT: 0 kb
+DEFAULT: 16 kb
 LOC: Config.quickAbort.max
 DOC_NONE
 
 NAME: quick_abort_pct
 COMMENT: (percent)
 TYPE: int
-DEFAULT: 0
+DEFAULT: 95
 LOC: Config.quickAbort.pct
 DOC_START
 	The cache can be configured to continue downloading aborted
@@ -1140,9 +1169,9 @@ DOC_START
 	If more than 'quick_abort_pct' of the transfer has completed,
 	it will finish the retrieval.
 
-quick_abort_min -1 KB
-quick_abort_max 0 KB
-quick_abort_pct 0
+quick_abort_min 16 KB
+quick_abort_max 16 KB
+quick_abort_pct 95
 DOC_END
 
 
@@ -1187,6 +1216,31 @@ DOC_START
 negative_dns_ttl 5 minutes
 DOC_END
 
+NAME: range_offset_limit
+COMMENT: (bytes)
+TYPE: b_size_t
+LOC: Config.rangeOffsetLimit
+DEFAULT: 0 KB
+DOC_START
+	Sets a upper limit on how far into the the file a Range request
+	may be to cause Squid to prefetch the whole file. If beyond this
+	limit then Squid forwards the Range request as it is and the result
+	is NOT cached.
+
+	This is to stop a far ahead range request (lets say start at 17MB)
+	from making Squid fetch the whole object up to that point before
+	sending anything to the client.
+
+	A value of -1 causes Squid to always fetch the object from the
+	beginning so that it may cache the result. (2.0 style)
+
+	A value of 0 causes Squid to never fetch more than the client
+	client requested. (default)
+
+range_offset_limit 0 KB
+DOC_END
+
+
 COMMENT_START
  TIMEOUTS
  -----------------------------------------------------------------------------
@@ -1363,9 +1417,9 @@ DOC_START
 	acl aclname proto    HTTP FTP ...
 	acl aclname method   GET POST ...
 	acl aclname browser  regexp
-	acl aclname user     username ...	# string match on ident output.
-						# use REQUIRED to accept any
-						# non-null ident.
+	acl aclname ident    username ...
+	  # string match on ident output.
+	  # use REQUIRED to accept any non-null ident.
 	acl aclname src_as   number ... 
 	acl aclname dst_as   number ...
 	  # Except for access control, AS numbers can be used for
@@ -1376,36 +1430,41 @@ DOC_START
 	  # cache_peer_access mycache.mydomain.net allow asexample
 	  # cache_peer_access mycache_mydomain.net deny all
 
-	acl aclname proxy_auth [ refresh ]
-	  # Use an EXTERNAL authentication program to check username/password
-	  # combinations (see authenticate_program).
-	  #
-	  # 'timeout' is the time a checked username/password combination
-	  # remains cached (default = 3600 secs). If a wrong password
-	  # is given for a cached user, the user gets removed from the
-	  # username/password cache forcing a revalidation.
-	  #
-	  # When using a proxy_auth ACL in an http_access rule, make sure
-	  # it is the *last* in the list and the only proxy_auth ACL in
-	  # the list.
+	acl aclname proxy_auth username ...
+	  # list of valid usernames
+	  # use REQUIRED to accept any valid username.
 	  #
 	  # NOTE: when a Proxy-Authentication header is sent but it is not
 	  # needed during ACL checking the username is NOT logged
 	  # in access.log.
+	  #
+	  # NOTE: proxy_auth requires a EXTERNAL authentication program
+	  # to check username/password combinations (see
+	  # authenticate_program).
+	  #
+	  # WARNING: proxy_auth can't be used in a transparent proxy. It
+	  # collides with any authentication done by origin servers. It may
+	  # seem like it works at first, but it doesn't.
 
 	acl aclname snmp_community string ...
 	  # Example:
 	  # 
 	  #	acl snmppublic snmp_community public
 
+
+Examples:
+acl myexample dst_as 1241
+acl password proxy_auth 300
+
+Defaults:
+NOCOMMENT_START
+acl all src 0.0.0.0/0.0.0.0
 acl manager proto cache_object
 acl localhost src 127.0.0.1/255.255.255.255
-acl all src 0.0.0.0/0.0.0.0
-acl myexample dst_as 1241
 acl SSL_ports port 443 563
 acl Safe_ports port 80 21 70 1025-65535
 acl CONNECT method CONNECT
-acl password proxy_auth 300
+NOCOMMENT_END
 DOC_END
 
 NAME: http_access
@@ -1433,14 +1492,17 @@ DOC_START
 	good idea to have an "deny all" or "allow all" entry at the end
 	of your access lists to avoid potential confusion.
 
-
-	Only allow access to the cache manager functions from the local host.
-http_access deny manager !localhost
-http_access deny CONNECT !SSL_ports
+Default configuration:
+NOCOMMENT_START
+http_access allow manager localhost
+http_access deny manager
 http_access deny !Safe_ports
-
-	Allow everything else
-http_access allow  all
+http_access deny CONNECT !SSL_ports
+#
+# INSERT YOUR OWN RULE(S) HERE TO ALLOW ACCESS FROM YOUR CLIENTS
+#
+http_access deny all
+NOCOMMENT_END
 DOC_END
 
 
@@ -1451,7 +1513,9 @@ DEFAULT: none
 DOC_START
 	Reply to all ICP queries we receive
 
-icp_access  allow  all
+NOCOMMENT_START
+icp_access allow all
+NOCOMMENT_END
 DOC_END
 
 
@@ -1472,8 +1536,9 @@ DOC_START
 
 	By default, allow all clients who passed the http_access rules
 	to fetch MISSES from us.
-
-miss_access allow  all
+NOCOMMENT_START
+miss_access allow all
+NOCOMMENT_END
 DOC_END
 
 
@@ -2616,4 +2681,16 @@ DOC_START
 uri_whitespace deny
 DOC_END
 
+NAME: persistent_client_posts
+TYPE: onoff
+LOC: Config.onoff.persistent_client_posts
+DEFAULT: on
+DOC_START
+	Turn this 'off' to disable persistent connections for POST
+	requests.  When you disable this, Squid reads all bytes
+	from the client request and sends them to the server.  This
+	makes Squid work with broken HTTP servers which expect the
+	additional CRLF pair from broken web clients.
+persistent_client_posts on
+DOC_END
 EOF
@@ -1,5 +1,5 @@
 /*
- * $Id: cf_gen.cc,v 1.28 1998/11/11 20:04:13 glenn Exp $
+ * $Id: cf_gen.cc,v 1.29 1998/11/12 06:27:58 wessels Exp $
  *
  * DEBUG: none
  * AUTHOR: Max Okumoto
@@ -65,6 +65,8 @@
 #include <assert.h>
 #endif
 
+#include "util.h"
+
 #define MAX_LINE	1024	/* longest configuration line */
 #define _PATH_PARSER		"cf_parser.c"
 #define _PATH_SQUID_CONF	"squid.conf"
@@ -73,6 +75,7 @@ enum State {
     sSTART,
     s1,
     sDOC,
+    sNOCOMMENT,
     sEXIT
 };
 
@@ -90,6 +93,7 @@ typedef struct Entry {
     char *comment;
     char *ifdef;
     Line *doc;
+    Line *nocomment;
     struct Entry *next;
 } Entry;
 
@@ -146,14 +150,14 @@ main(int argc, char *argv[])
 		    exit(1);
 		}
 		curr = calloc(1, sizeof(Entry));
-		curr->name = strdup(name);
+		curr->name = xstrdup(name);
 		state = s1;
 	    } else if (!strcmp(buff, "EOF")) {
 		state = sEXIT;
 	    } else if (!strcmp(buff, "COMMENT_START")) {
 		curr = calloc(1, sizeof(Entry));
-		curr->name = strdup("comment");
-		curr->loc = strdup("none");
+		curr->name = xstrdup("comment");
+		curr->loc = xstrdup("none");
 		state = sDOC;
 	    } else {
 		printf("Error on line %d\n", linenum);
@@ -170,35 +174,35 @@ main(int argc, char *argv[])
 		ptr = buff + 8;
 		while (isspace(*ptr))
 		    ptr++;
-		curr->comment = strdup(ptr);
+		curr->comment = xstrdup(ptr);
 	    } else if (!strncmp(buff, "DEFAULT:", 8)) {
 		ptr = buff + 8;
 		while (isspace(*ptr))
 		    ptr++;
-		curr->default_value = strdup(ptr);
+		curr->default_value = xstrdup(ptr);
 	    } else if (!strncmp(buff, "DEFAULT_IF_NONE:", 16)) {
 		ptr = buff + 16;
 		while (isspace(*ptr))
 		    ptr++;
-		curr->default_if_none = strdup(ptr);
+		curr->default_if_none = xstrdup(ptr);
 	    } else if (!strncmp(buff, "LOC:", 4)) {
 		if ((ptr = strtok(buff + 4, WS)) == NULL) {
 		    printf("Error on line %d\n", linenum);
 		    exit(1);
 		}
-		curr->loc = strdup(ptr);
+		curr->loc = xstrdup(ptr);
 	    } else if (!strncmp(buff, "TYPE:", 5)) {
 		if ((ptr = strtok(buff + 5, WS)) == NULL) {
 		    printf("Error on line %d\n", linenum);
 		    exit(1);
 		}
-		curr->type = strdup(ptr);
+		curr->type = xstrdup(ptr);
 	    } else if (!strncmp(buff, "IFDEF:", 6)) {
 		if ((ptr = strtok(buff + 6, WS)) == NULL) {
 		    printf("Error on line %d\n", linenum);
 		    exit(1);
 		}
-		curr->ifdef = strdup(ptr);
+		curr->ifdef = xstrdup(ptr);
 	    } else if (!strcmp(buff, "DOC_START")) {
 		state = sDOC;
 	    } else if (!strcmp(buff, "DOC_NONE")) {
@@ -229,14 +233,38 @@ main(int argc, char *argv[])
 		curr->next = entries;
 		entries = curr;
 		state = sSTART;
+	    } else if (!strcmp(buff, "NOCOMMENT_START")) {
+		state = sNOCOMMENT;
 	    } else {
 		Line *line = calloc(1, sizeof(Line));
-		line->data = strdup(buff);
+		line->data = xstrdup(buff);
 		line->next = curr->doc;
 		curr->doc = line;
 	    }
 	    break;
 
+	case sNOCOMMENT:
+	    if (!strcmp(buff, "NOCOMMENT_END")) {
+		Line *head = NULL;
+		Line *line = curr->nocomment;
+		/* reverse order of lines */
+		while (line != NULL) {
+		    Line *tmp;
+		    tmp = line->next;
+		    line->next = head;
+		    head = line;
+		    line = tmp;
+		}
+		curr->nocomment = head;
+		state = sDOC;
+	    } else {
+		Line *line = calloc(1, sizeof(Line));
+		line->data = xstrdup(buff);
+		line->next = curr->nocomment;
+		curr->nocomment = line;
+	    }
+	    break;
+
 	case sEXIT:
 	    assert(0);		/* should never get here */
 	    break;
@@ -327,6 +355,7 @@ gen_default(Entry * head, FILE * fp)
 	);
     for (entry = head; entry != NULL; entry = entry->next) {
 	assert(entry->name);
+	assert(entry != entry->next);
 
 	if (!strcmp(entry->name, "comment"))
 	    continue;
@@ -497,14 +526,19 @@ gen_conf(Entry * head, FILE * fp)
     for (entry = head; entry != NULL; entry = entry->next) {
 	Line *line;
 
-	if (strcmp(entry->name, "comment"))
+	if (!strcmp(entry->name, "comment"))
+	    (void) 0;
+	else
 	    fprintf(fp, "#  TAG: %s", entry->name);
 	if (entry->comment)
 	    fprintf(fp, "\t%s", entry->comment);
 	fprintf(fp, "\n");
 	for (line = entry->doc; line != NULL; line = line->next) {
 	    fprintf(fp, "#%s\n", line->data);
 	}
+	for (line = entry->nocomment; line != NULL; line = line->next) {
+	    fprintf(fp, "%s\n", line->data);
+	}
 	if (entry->doc != NULL) {
 	    fprintf(fp, "\n");
 	}
@@ -1,9 +1,8 @@
 
 
 
-
 /*
- * $Id: client.cc,v 1.77 1998/10/19 22:36:58 wessels Exp $
+ * $Id: client.cc,v 1.78 1998/11/12 06:27:59 wessels Exp $
  *
  * DEBUG: section 0     WWW Client
  * AUTHOR: Harvest Derived
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side.cc,v 1.421 1998/11/11 20:04:14 glenn Exp $
+ * $Id: client_side.cc,v 1.422 1998/11/12 06:28:00 wessels Exp $
  *
  * DEBUG: section 33    Client-side Routines
  * AUTHOR: Duane Wessels
@@ -80,6 +80,7 @@ static int checkAccelOnly(clientHttpRequest *);
 static int clientOnlyIfCached(clientHttpRequest * http);
 static STCB clientSendMoreData;
 static STCB clientCacheHit;
+static void clientSetKeepaliveFlag(clientHttpRequest *);
 static void clientInterpretRequestHeaders(clientHttpRequest *);
 static void clientProcessRequest(clientHttpRequest *);
 static void clientProcessExpired(void *data);
@@ -146,13 +147,29 @@ clientOnlyIfCached(clientHttpRequest * http)
 static HttpReply *
 clientConstructProxyAuthReply(clientHttpRequest * http)
 {
-    ErrorState *err = errorCon(ERR_CACHE_ACCESS_DENIED, HTTP_PROXY_AUTHENTICATION_REQUIRED);
+    ErrorState *err;
     HttpReply *rep;
+    if (!http->flags.accel) {
+	/* Proxy authorisation needed */
+	err = errorCon(ERR_CACHE_ACCESS_DENIED,
+	    HTTP_PROXY_AUTHENTICATION_REQUIRED);
+    } else {
+	/* WWW authorisation needed */
+	err = errorCon(ERR_CACHE_ACCESS_DENIED, HTTP_UNAUTHORIZED);
+    }
     err->request = requestLink(http->request);
     rep = errorBuildReply(err);
     errorStateFree(err);
     /* add Authenticate header */
-    httpHeaderPutStrf(&rep->header, HDR_PROXY_AUTHENTICATE, proxy_auth_challenge_fmt, Config.proxyAuthRealm);
+    if (!http->flags.accel) {
+	/* Proxy authorisation needed */
+	httpHeaderPutStrf(&rep->header, HDR_PROXY_AUTHENTICATE,
+	    proxy_auth_challenge_fmt, Config.proxyAuthRealm);
+    } else {
+	/* WWW Authorisation needed */
+	httpHeaderPutStrf(&rep->header, HDR_WWW_AUTHENTICATE,
+	    proxy_auth_challenge_fmt, Config.proxyAuthRealm);
+    }
     return rep;
 }
 
@@ -171,7 +188,8 @@ clientCreateStoreEntry(clientHttpRequest * h, method_t m, request_flags flags)
 #if DELAY_POOLS
     delaySetStoreClient(e, h, h->request->delay_id);
 #endif
-    storeClientCopy(e, 0, 0, CLIENT_SOCK_SZ, memAllocate(MEM_CLIENT_SOCK_BUF), clientSendMoreData, h);
+    storeClientCopy(e, 0, 0, CLIENT_SOCK_SZ,
+	memAllocate(MEM_CLIENT_SOCK_BUF), clientSendMoreData, h);
     return e;
 }
 
@@ -192,7 +210,8 @@ clientAccessCheckDone(int answer, void *data)
 	redirectStart(http, clientRedirectDone, http);
     } else if (answer == ACCESS_REQ_PROXY_AUTH) {
 	http->log_type = LOG_TCP_DENIED;
-	http->entry = clientCreateStoreEntry(http, http->request->method, null_request_flags);
+	http->entry = clientCreateStoreEntry(http, http->request->method,
+	    null_request_flags);
 	/* create appropriate response */
 	http->entry->mem_obj->reply = clientConstructProxyAuthReply(http);
 	httpReplySwapOut(http->entry->mem_obj->reply, http->entry);
@@ -202,7 +221,8 @@ clientAccessCheckDone(int answer, void *data)
 	debug(33, 5) ("AclMatchedName = %s\n",
 	    AclMatchedName ? AclMatchedName : "<null>");
 	http->log_type = LOG_TCP_DENIED;
-	http->entry = clientCreateStoreEntry(http, http->request->method, null_request_flags);
+	http->entry = clientCreateStoreEntry(http, http->request->method,
+	    null_request_flags);
 	page_id = aclGetDenyInfoPage(&Config.denyInfoList, AclMatchedName);
 	/* NOTE: don't use HTTP_UNAUTHORIZED because then the
 	 * stupid browser wants us to authenticate */
@@ -652,6 +672,7 @@ httpRequestFree(void *data)
 	    packerToMemInit(&p, &mb);
 	    httpHeaderPackInto(&request->header, &p);
 	    http->al.http.method = request->method;
+	    http->al.http.version = request->http_ver;
 	    http->al.headers.request = xstrdup(mb.buf);
 	    http->al.hier = request->hier;
 	    packerClean(&p);
@@ -762,15 +783,12 @@ clientInterpretRequestHeaders(clientHttpRequest * http)
 	request->flags.auth = 1;
     if (request->login[0] != '\0')
 	request->flags.auth = 1;
-    if (httpMsgIsPersistent(request->http_ver, req_hdr))
-	request->flags.proxy_keepalive = 1;
     if (httpHeaderHas(req_hdr, HDR_VIA)) {
 	String s = httpHeaderGetList(req_hdr, HDR_VIA);
 	/* ThisCache cannot be a member of Via header, "1.0 ThisCache" can */
 	if (strListIsSubstr(&s, ThisCache, ',')) {
-	    debug(33, 1) ("WARNING: Forwarding loop detected for '%s'\n",
-		http->uri);
-	    debug(33, 1) ("--> %s\n", strBuf(s));
+	    debugObj(33, 1, "WARNING: Forwarding loop detected for:\n",
+		request, (ObjPackMethod) & httpRequestPack);
 	    request->flags.loopdetect = 1;
 	}
 #if FORW_VIA_DB
@@ -812,6 +830,28 @@ clientInterpretRequestHeaders(clientHttpRequest * http)
 	request->flags.hierarchical ? "SET" : "NOT SET");
 }
 
+/*
+ * clientSetKeepaliveFlag() sets request->flags.proxy_keepalive.
+ * This is the client-side persistent connection flag.  We need
+ * to set this relatively early in the request processing
+ * to handle hacks for broken servers and clients.
+ */
+static void
+clientSetKeepaliveFlag(clientHttpRequest * http)
+{
+    request_t *request = http->request;
+    const HttpHeader *req_hdr = &request->header;
+    debug(33, 3) ("clientSetKeepaliveFlag: http_ver = %3.1f\n",
+	request->http_ver);
+    debug(33, 3) ("clientSetKeepaliveFlag: method = %s\n",
+	RequestMethodStr[request->method]);
+    if (httpMsgIsPersistent(request->http_ver, req_hdr))
+	request->flags.proxy_keepalive = 1;
+    if (request->method == METHOD_POST || request->method == METHOD_PUT)
+	if (!Config.onoff.persistent_client_posts)
+	    request->flags.proxy_keepalive = 0;
+}
+
 static int
 clientCheckContentLength(request_t * r)
 {
@@ -1087,10 +1127,12 @@ clientBuildReplyHeader(clientHttpRequest * http, HttpReply * rep)
 	http->lookup_type ? http->lookup_type : "NONE",
 	getMyHostname(), Config.Port.http->i);
 #endif
-    /* Only replies with valid Content-Length can be sent with keep-alive */
-    if (request->method != METHOD_HEAD &&
-	http->entry->mem_obj->reply->content_length < 0)
-	request->flags.proxy_keepalive = 0;
+    /*
+     * Clear keepalive for NON-HEAD requests with invalid content length
+     */
+    if (request->method != METHOD_HEAD)
+	if (http->entry->mem_obj->reply->content_length < 0)
+	    request->flags.proxy_keepalive = 0;
     /* Signal keep-alive if needed */
     httpHeaderPutStr(hdr,
 	http->flags.accel ? HDR_CONNECTION : HDR_PROXY_CONNECTION,
@@ -1856,7 +1898,7 @@ parseHttpRequestAbort(ConnStateData * conn, const char *uri)
     http->start = current_time;
     http->req_sz = conn->in.offset;
     http->uri = xstrdup(uri);
-    http->log_uri = xstrdup(uri);
+    http->log_uri = xstrndup(uri, MAX_URL);
     http->range_iter.boundary = StringNull;
     return http;
 }
@@ -1884,33 +1926,37 @@ parseHttpRequest(ConnStateData * conn, method_t * method_p, int *status,
     size_t header_sz;		/* size of headers, not including first line */
     size_t prefix_sz;		/* size of whole request (req-line + headers) */
     size_t url_sz;
+    size_t req_sz;
     method_t method;
     clientHttpRequest *http = NULL;
 #if IPF_TRANSPARENT
     struct natlookup natLookup;
     static int natfd = -1;
 #endif
 
-    /* Make sure a complete line has been received */
-    if ((t = strchr(conn->in.buf, '\n')) == NULL) {
-	debug(33, 5) ("Incomplete request line, waiting for more data\n");
+    if ((req_sz = headersEnd(conn->in.buf, conn->in.offset)) == 0) {
+	debug(33, 5) ("Incomplete request, waiting for end of headers\n");
 	*status = 0;
 	*prefix_p = NULL;
 	*method_p = METHOD_NONE;
 	return NULL;
     }
-    *req_line_sz_p = t - conn->in.buf;
-    /* Use xmalloc/xmemcpy instead of xstrdup because inbuf might
-     * contain NULL bytes; especially for POST data  */
-    inbuf = xmalloc(conn->in.offset + 1);
-    xmemcpy(inbuf, conn->in.buf, conn->in.offset);
-    *(inbuf + conn->in.offset) = '\0';
+    assert(req_sz <= conn->in.offset);
+    /* Use memcpy, not strdup! */
+    inbuf = xmalloc(req_sz + 1);
+    xmemcpy(inbuf, conn->in.buf, req_sz);
+    *(inbuf + req_sz) = '\0';
 
     /* pre-set these values to make aborting simpler */
     *prefix_p = inbuf;
     *method_p = METHOD_NONE;
     *status = -1;
 
+    /* Barf on NULL characters in the headers */
+    if (strlen(inbuf) != req_sz) {
+	debug(33, 1) ("parseHttpRequest: Requestheader contains NULL characters\n");
+	return parseHttpRequestAbort(conn, "error:invalid-request");
+    }
     /* Look for request method */
     if ((mstr = strtok(inbuf, "\t ")) == NULL) {
 	debug(33, 1) ("parseHttpRequest: Can't get request method\n");
@@ -1925,10 +1971,12 @@ parseHttpRequest(ConnStateData * conn, method_t * method_p, int *status,
     *method_p = method;
 
     /* look for URL+HTTP/x.x */
-    if ((url = strtok(NULL, "\r\n")) == NULL) {
+    if ((url = strtok(NULL, "\n")) == NULL) {
 	debug(33, 1) ("parseHttpRequest: Missing URL\n");
 	return parseHttpRequestAbort(conn, "error:missing-url");
     }
+    while (isspace(*url))
+	url++;
     t = url + strlen(url);
     assert(*t == '\0');
     token = NULL;
@@ -1950,27 +1998,19 @@ parseHttpRequest(ConnStateData * conn, method_t * method_p, int *status,
 	return parseHttpRequestAbort(conn, "error:missing-http-ident");
 #endif
     } else {
-debug(0, 0) ("parseHttpRequest: VER is {%s}\n", token);
 	http_ver = (float) atof(token + 5);
     }
 
-    /* Check if headers are received */
-    req_hdr = t;
-    header_sz = headersEnd(req_hdr, conn->in.offset - (req_hdr - inbuf));
+    /*
+     * Process headers after request line
+     */
+    req_hdr = strtok(NULL, null_string);
+    header_sz = req_sz - (req_hdr - inbuf);
     if (0 == header_sz) {
 	debug(33, 3) ("parseHttpRequest: header_sz == 0\n");
 	*status = 0;
 	return NULL;
     }
-    /*
-     * Skip whitespace at the end of the first line, up to the
-     * first newline.
-     */
-    while (isspace(*req_hdr)) {
-	header_sz--;
-	if (*(req_hdr++) == '\n')
-	    break;
-    }
     assert(header_sz > 0);
     debug(33, 3) ("parseHttpRequest: req_hdr = {%s}\n", req_hdr);
     end = req_hdr + header_sz;
@@ -1995,11 +2035,6 @@ debug(0, 0) ("parseHttpRequest: VER is {%s}\n", token);
     *(*prefix_p + prefix_sz) = '\0';
 
     debug(33, 5) ("parseHttpRequest: Request Header is\n%s\n", (*prefix_p) + *req_line_sz_p);
-    /* Assign http->uri */
-    if ((t = strchr(url, '\n')))	/* remove NL */
-	*t = '\0';
-    if ((t = strchr(url, '\r')))	/* remove CR */
-	*t = '\0';
     if ((t = strchr(url, '#')))	/* remove HTML anchors */
 	*t = '\0';
 
@@ -2008,6 +2043,7 @@ debug(0, 0) ("parseHttpRequest: VER is {%s}\n", token);
 	/* prepend our name & port */
 	http->uri = xstrdup(internalLocalUri(NULL, url));
 	http->flags.internal = 1;
+	http->flags.accel = 1;
     }
     /* see if we running in Config2.Accel.on, if so got to convert it to URL */
     else if (Config2.Accel.on && *url == '/') {
@@ -2083,9 +2119,9 @@ debug(0, 0) ("parseHttpRequest: VER is {%s}\n", token);
 	http->flags.accel = 0;
     }
     if (!stringHasWhitespace(http->uri))
-	http->log_uri = xstrdup(http->uri);
+	http->log_uri = xstrndup(http->uri, MAX_URL);
     else
-	http->log_uri = xstrdup(rfc1738_escape(http->uri));
+	http->log_uri = xstrndup(rfc1738_escape(http->uri), MAX_URL);
     debug(33, 5) ("parseHttpRequest: Complete request received\n");
     if (free_request)
 	safe_free(url);
@@ -2231,18 +2267,20 @@ clientReadRequest(int fd, void *data)
 			http->uri, prefix);
 		/* continue anyway? */
 	    }
+	    request->flags.accelerated = http->flags.accel;
 	    if (!http->flags.internal) {
 		if (internalCheck(strBuf(request->urlpath))) {
-		    if (0 == strcasecmp(request->host, getMyHostname())) {
+		    if (0 == strcasecmp(request->host, internalHostname())) {
 			if (request->port == Config.Port.http->i)
 			    http->flags.internal = 1;
 		    } else if (internalStaticCheck(strBuf(request->urlpath))) {
-			xstrncpy(request->host, getMyHostname(), SQUIDHOSTNAMELEN);
+			xstrncpy(request->host, internalHostname(), SQUIDHOSTNAMELEN);
 			request->port = Config.Port.http->i;
 			http->flags.internal = 1;
 		    }
 		}
 	    }
+	    request->flags.internal = http->flags.internal;
 	    safe_free(prefix);
 	    safe_free(http->log_uri);
 	    http->log_uri = xstrdup(urlCanonicalClean(request));
@@ -2267,14 +2305,22 @@ clientReadRequest(int fd, void *data)
 		break;
 	    }
 	    http->request = requestLink(request);
+	    /*
+	     * We need to set the keepalive flag before doing some
+	     * hacks for POST/PUT requests below.  Maybe we could
+	     * set keepalive flag even earlier.
+	     */
+	    clientSetKeepaliveFlag(http);
 	    /*
 	     * break here for NON-GET because most likely there is a
 	     * reqeust body following and we don't want to parse it
 	     * as though it was new request
 	     */
 	    if (request->method != METHOD_GET) {
 		int cont_len = httpHeaderGetInt(&request->header, HDR_CONTENT_LENGTH);
-		int copy_len = XMIN(cont_len, conn->in.offset);
+		int copy_len = conn->in.offset;
+		if (cont_len < copy_len && request->flags.proxy_keepalive)
+		    copy_len = cont_len;
 		if (copy_len > 0) {
 		    assert(conn->in.offset >= copy_len);
 		    request->body_sz = copy_len;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: comm_select.cc,v 1.21 1998/10/19 22:36:58 wessels Exp $
+ * $Id: comm_select.cc,v 1.22 1998/11/12 06:28:01 wessels Exp $
  *
  * DEBUG: section 5     Socket Functions
  *
@@ -744,10 +744,10 @@ examine_select(fd_set * readfds, fd_set * writefds)
     int fd = 0;
     fd_set read_x;
     fd_set write_x;
-    int num;
     struct timeval tv;
     close_handler *ch = NULL;
     fde *F = NULL;
+    struct stat sb;
     debug(5, 0) ("examine_select: Examining open file descriptors...\n");
     for (fd = 0; fd < Squid_MaxFD; fd++) {
 	FD_ZERO(&read_x);
@@ -760,8 +760,8 @@ examine_select(fd_set * readfds, fd_set * writefds)
 	else
 	    continue;
 	Counter.syscalls.selects++;
-	num = select(Squid_MaxFD, &read_x, &write_x, NULL, &tv);
-	if (num > -1) {
+	errno = 0;
+	if (!fstat(fd, &sb)) {
 	    debug(5, 5) ("FD %d is valid.\n", fd);
 	    continue;
 	}
@@ -1,6 +1,6 @@
 
 /*
- * $Id: delay_pools.cc,v 1.5 1998/09/30 04:34:07 wessels Exp $
+ * $Id: delay_pools.cc,v 1.6 1998/11/12 06:28:02 wessels Exp $
  *
  * DEBUG: section 77    Delay Pools
  * AUTHOR: David Luyer <luyer@ucs.uwa.edu.au>
@@ -405,7 +405,7 @@ delayBytesIn(delay_id d, int qty)
     }
     if (class == 2) {
 	delay_data.class2_aggregate -= qty;
-	delay_data.class3_individual[position] -= qty;
+	delay_data.class2_individual[position] -= qty;
 	return;
     }
     if (class == 3) {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: dns.cc,v 1.71 1998/10/19 22:36:59 wessels Exp $
+ * $Id: dns.cc,v 1.72 1998/11/12 06:28:03 wessels Exp $
  *
  * DEBUG: section 34    Dnsserver interface
  * AUTHOR: Harvest Derived
@@ -59,10 +59,9 @@ dnsInit(void)
     wordlistAdd(&dnsservers->cmdline, Config.Program.dnsserver);
     if (Config.onoff.res_defnames)
 	wordlistAdd(&dnsservers->cmdline, "-D");
-    if (Config.dns_nameservers) {
+    for (w = Config.dns_nameservers; w != NULL; w = w->next) {
 	wordlistAdd(&dnsservers->cmdline, "-s");
-	for (w = Config.dns_nameservers; w != NULL; w = w->next)
-	    wordlistAdd(&dnsservers->cmdline, w->key);
+	wordlistAdd(&dnsservers->cmdline, w->key);
     }
     helperOpenServers(dnsservers);
     if (!init) {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: dnsserver.cc,v 1.52 1998/07/22 20:37:15 wessels Exp $
+ * $Id: dnsserver.cc,v 1.53 1998/11/12 06:28:03 wessels Exp $
  *
  * DEBUG: section 0     DNS Resolver
  * AUTHOR: Harvest Derived
@@ -289,7 +289,12 @@ main(int argc, char *argv[])
 		_res.options |= RES_INIT;
 		opt_s = 1;
 	    }
+#if HAVE_RES_NSADDR_LIST
 	    safe_inet_addr(optarg, &_res.nsaddr_list[_res.nscount++].sin_addr);
+#elif HAVE_RES_NS_LIST
+	    safe_inet_addr(optarg, &_res.ns_list[_res.nscount++].addr.sin_addr);
+#endif
+	    fprintf(stderr, "-s is not supported on this resolver\n");
 #else
 	    fprintf(stderr, "-s is not supported on this resolver\n");
 #endif /* HAVE_RES_INIT */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: enums.h,v 1.136 1998/11/11 20:04:15 glenn Exp $
+ * $Id: enums.h,v 1.137 1998/11/12 06:28:04 wessels Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -97,7 +97,7 @@ typedef enum {
     ACL_URLPATH_REGEX,
     ACL_URL_REGEX,
     ACL_URL_PORT,
-    ACL_USER,
+    ACL_IDENT,
     ACL_PROTO,
     ACL_METHOD,
     ACL_BROWSER,
@@ -115,9 +115,7 @@ typedef enum {
     ACL_LOOKUP_NEEDED,
     ACL_LOOKUP_PENDING,
     ACL_LOOKUP_DONE,
-    ACL_PROXY_AUTH_NEEDED,
-    ACL_PROXY_AUTH_USED,
-    ACL_PROXY_AUTH_CHECK
+    ACL_PROXY_AUTH_NEEDED
 } acl_lookup_state;
 
 enum {
@@ -200,7 +198,9 @@ typedef enum {
     HDR_EXPIRES,
     HDR_FROM,
     HDR_HOST,
+    HDR_IF_MATCH,
     HDR_IF_MODIFIED_SINCE,
+    HDR_IF_NONE_MATCH,
     HDR_IF_RANGE,
     HDR_LAST_MODIFIED,
     HDR_LINK,
@@ -473,84 +473,91 @@ enum {
 
 typedef enum {
     MEM_NONE,
-    MEM_DONTFREE,
-    MEM_DISK_BUF,
-    MEM_STMEM_BUF,
     MEM_2K_BUF,
     MEM_4K_BUF,
     MEM_8K_BUF,
-    MEM_CLIENT_SOCK_BUF,
-    MEM_ACL_IP_DATA,
-    MEM_ACL_TIME_DATA,
-    MEM_ACL_NAME_LIST,
-    MEM_ACL_DENY_INFO_LIST,
+    MEM_ACCESSLOGENTRY,
     MEM_ACL,
-    MEM_ACL_LIST,
+    MEM_ACLCHECK_T,
     MEM_ACL_ACCESS,
+    MEM_ACL_DENY_INFO_LIST,
+    MEM_ACL_IP_DATA,
+    MEM_ACL_LIST,
+    MEM_ACL_NAME_LIST,
     MEM_ACL_PROXY_AUTH_USER,
-    MEM_ACLCHECK_T,
+    MEM_ACL_TIME_DATA,
     MEM_AIO_RESULT_T,
-    MEM_WORDLIST,
-    MEM_INTLIST,
-    MEM_USHORTLIST,
-    MEM_RELIST,
-    MEM_SQUIDCONFIG,
-    MEM_SQUIDCONFIG2,
+    MEM_CACHEMGR_PASSWD,
+#if USE_CACHE_DIGESTS
+    MEM_CACHE_DIGEST,
+#endif
+    MEM_CLIENTHTTPREQUEST,
+    MEM_CLIENT_INFO,
+    MEM_CLIENT_SOCK_BUF,
     MEM_CLOSE_HANDLER,
-    MEM_DREAD_CTRL,
+    MEM_COMMWRITESTATEDATA,
+    MEM_CONNSTATEDATA,
+#if USE_CACHE_DIGESTS
+    MEM_DIGEST_FETCH_STATE,
+#endif
+    MEM_DISK_BUF,
+    MEM_DLINK_LIST,
+    MEM_DLINK_NODE,
     MEM_DNSSERVER_T,
     MEM_DNSSTATDATA,
+    MEM_DOMAIN_PING,
+    MEM_DOMAIN_TYPE,
+    MEM_DONTFREE,
+    MEM_DREAD_CTRL,
     MEM_DWRITE_Q,
+    MEM_ERRORSTATE,
     MEM_FILEMAP,
     MEM_FQDNCACHE_ENTRY,
     MEM_FQDNCACHE_PENDING,
-    MEM_FWD_STATE,
     MEM_FWD_SERVER,
+    MEM_FWD_STATE,
     MEM_HASH_LINK,
     MEM_HASH_TABLE,
-    MEM_HTTP_REPLY,
-    MEM_HTTP_HDR_ENTRY,
+    MEM_HELPER,
+    MEM_HELPER_REQUEST,
+    MEM_HELPER_SERVER,
+    MEM_HIERARCHYLOGENTRY,
     MEM_HTTP_HDR_CC,
-    MEM_HTTP_HDR_RANGE_SPEC,
-    MEM_HTTP_HDR_RANGE,
     MEM_HTTP_HDR_CONTENT_RANGE,
+    MEM_HTTP_HDR_ENTRY,
+    MEM_HTTP_HDR_RANGE,
+    MEM_HTTP_HDR_RANGE_SPEC,
+    MEM_HTTP_REPLY,
     MEM_HTTP_STATE_DATA,
     MEM_ICPUDPDATA,
-    MEM_CLIENTHTTPREQUEST,
-    MEM_CONNSTATEDATA,
-    MEM_IPCACHE_PENDING,
+    MEM_ICP_COMMON_T,
+    MEM_ICP_PING_DATA,
+    MEM_INTLIST,
+    MEM_IOSTATS,
     MEM_IPCACHE_ENTRY,
-    MEM_DOMAIN_PING,
-    MEM_DOMAIN_TYPE,
-    MEM_DIGEST_FETCH_STATE,
-    MEM_PEER,
+    MEM_IPCACHE_PENDING,
+    MEM_MD5_DIGEST,
+    MEM_MEMOBJECT,
+    MEM_MEM_NODE,
+    MEM_NETDBENTRY,
     MEM_NET_DB_NAME,
     MEM_NET_DB_PEER,
-    MEM_NETDBENTRY,
-    MEM_ICP_PING_DATA,
-    MEM_PS_STATE,
-    MEM_HIERARCHYLOGENTRY,
+    MEM_PEER,
     MEM_PINGERECHODATA,
     MEM_PINGERREPLYDATA,
-    MEM_ICP_COMMON_T,
-    MEM_IOSTATS,
-    MEM_MEM_NODE,
-    MEM_STORE_CLIENT,
-    MEM_MEMOBJECT,
-    MEM_STOREENTRY,
-    MEM_SWAPDIR,
-    MEM_REQUEST_T,
-    MEM_ACCESSLOGENTRY,
-    MEM_CACHE_DIGEST,
-    MEM_CACHEMGR_PASSWD,
+    MEM_PS_STATE,
     MEM_REFRESH_T,
-    MEM_COMMWRITESTATEDATA,
-    MEM_ERRORSTATE,
-    MEM_DLINK_NODE,
-    MEM_DLINK_LIST,
+    MEM_RELIST,
+    MEM_REQUEST_T,
+    MEM_SQUIDCONFIG,
+    MEM_SQUIDCONFIG2,
     MEM_STATCOUNTERS,
-    MEM_CLIENT_INFO,
-    MEM_MD5_DIGEST,
+    MEM_STMEM_BUF,
+    MEM_STOREENTRY,
+    MEM_STORE_CLIENT,
+    MEM_SWAPDIR,
+    MEM_USHORTLIST,
+    MEM_WORDLIST,
     MEM_MAX
 } mem_type;
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: errorpage.cc,v 1.142 1998/09/14 22:17:57 wessels Exp $
+ * $Id: errorpage.cc,v 1.143 1998/11/12 06:28:05 wessels Exp $
  *
  * DEBUG: section 4     Error Generation
  * AUTHOR: Duane Wessels
@@ -81,6 +81,8 @@ static int error_page_count = 0;
 static char *errorTryLoadText(const char *page_name, const char *dir);
 static char *errorLoadText(const char *page_name);
 static const char *errorFindHardText(err_type type);
+static ErrorDynamicPageInfo *errorDynamicPageInfoCreate(int id, const char *page_name);
+static void errorDynamicPageInfoDestroy(ErrorDynamicPageInfo * info);
 static MemBuf errorBuildContent(ErrorState * err);
 static const char *errorConvert(char token, ErrorState * err);
 static CWCB errorSendComplete;
@@ -106,12 +108,11 @@ errorInitialize(void)
 	/* hard-coded ? */
 	if ((text = errorFindHardText(i)))
 	    error_text[i] = xstrdup(text);
-	else
+	else if (i < ERR_MAX) {
 	    /* precompiled ? */
-	if (i < ERR_MAX)
 	    error_text[i] = errorLoadText(err_type_str[i]);
-	/* dynamic */
-	else {
+	} else {
+	    /* dynamic */
 	    ErrorDynamicPageInfo *info = ErrorDynamicPages.items[i - ERR_MAX];
 	    assert(info && info->id == i && info->page_name);
 	    error_text[i] = errorLoadText(info->page_name);
@@ -120,6 +121,20 @@ errorInitialize(void)
     }
 }
 
+void
+errorClean(void)
+{
+    if (error_text) {
+	int i;
+	for (i = ERR_NONE + 1; i < error_page_count; i++)
+	    safe_free(error_text[i]);
+	safe_free(error_text);
+    }
+    while (ErrorDynamicPages.count)
+	errorDynamicPageInfoDestroy(stackPop(&ErrorDynamicPages));
+    error_page_count = 0;
+}
+
 static const char *
 errorFindHardText(err_type type)
 {
@@ -169,7 +184,8 @@ errorTryLoadText(const char *page_name, const char *dir)
 	text = NULL;
     }
     file_close(fd);
-    strcat(text, "%S");		/* add signature */
+    if (strstr(text, "%s") == NULL)
+	strcat(text, "%S");	/* add signature */
     return text;
 }
 
@@ -199,16 +215,15 @@ errorReservePageId(const char *page_name)
     return info->id;
 }
 
-void
-errorFree(void)
+static const char *
+errorPageName(int pageId)
 {
-    int i;
-    for (i = ERR_NONE + 1; i < error_page_count; i++)
-	safe_free(error_text[i]);
-    while (ErrorDynamicPages.count)
-	errorDynamicPageInfoDestroy(stackPop(&ErrorDynamicPages));
-    safe_free(error_text);
-    error_page_count = 0;
+    if (pageId >= ERR_NONE && pageId < ERR_MAX)		/* common case */
+	return err_type_str[pageId];
+    if (pageId >= ERR_MAX && pageId - ERR_MAX < ErrorDynamicPages.count)
+	return ((ErrorDynamicPageInfo *) ErrorDynamicPages.
+	    items[pageId - ERR_MAX])->page_name;
+    return "ERR_UNKNOWN";	/* should not happen */
 }
 
 /*
@@ -530,7 +545,7 @@ errorBuildReply(ErrorState * err)
      * X-CACHE-MISS entry should tell us who.
      */
     httpHeaderPutStrf(&rep->header, HDR_X_SQUID_ERROR, "%s %d",
-	err_type_str[err->page_id], err->xerrno);
+	errorPageName(err->page_id), err->xerrno);
     httpBodySet(&rep->body, &content);
     /* do not memBufClean() the content, it was absorbed by httpBody */
     return rep;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: forward.cc,v 1.30 1998/09/23 20:13:48 wessels Exp $
+ * $Id: forward.cc,v 1.31 1998/11/12 06:28:05 wessels Exp $
  *
  * DEBUG: section 17    Request Forwarding
  * AUTHOR: Duane Wessels
@@ -255,7 +255,6 @@ fwdDispatch(FwdState * fwdState)
     peer *p;
     request_t *request = fwdState->request;
     StoreEntry *entry = fwdState->entry;
-    ErrorState *err;
     debug(17, 5) ("fwdDispatch: FD %d: Fetching '%s %s'\n",
 	fwdState->client_fd,
 	RequestMethodStr[request->method],
@@ -299,9 +298,8 @@ fwdDispatch(FwdState * fwdState)
 	default:
 	    debug(17, 1) ("fwdDispatch: Cannot retrieve '%s'\n",
 		storeUrl(entry));
-	    err = errorCon(ERR_UNSUP_REQ, HTTP_BAD_REQUEST);
-	    err->request = requestLink(request);
-	    errorAppendEntry(entry, err);
+	    fwdFail(fwdState, ERR_UNSUP_REQ, HTTP_BAD_REQUEST, -1);
+	    comm_close(fwdState->server_fd);
 	    break;
 	}
     }
@@ -1,7 +1,7 @@
 
 
 /*
- * $Id: fqdncache.cc,v 1.121 1998/10/10 14:57:39 wessels Exp $
+ * $Id: fqdncache.cc,v 1.122 1998/11/12 06:28:06 wessels Exp $
  *
  * DEBUG: section 35    FQDN Cache
  * AUTHOR: Harvest Derived
@@ -233,6 +233,10 @@ fqdncacheParse(const char *inbuf)
     memset(&f, '\0', sizeof(f));
     f.expires = squid_curtime;
     f.status = FQDN_NEGATIVE_CACHED;
+    if (inbuf == NULL) {
+	debug(35, 1) ("fqdncacheParse: Got <NULL> reply\n");
+	return &f;
+    }
     token = strtok(buf, w_space);
     if (NULL == token) {
 	debug(35, 1) ("fqdncacheParse: Got <NULL>, expecting '$name'\n");
@@ -275,24 +279,22 @@ fqdncacheHandleReply(void *data, char *reply)
     generic_cbdata *c = data;
     fqdncache_entry *f = c->data;
     fqdncache_entry *x = NULL;
-    n = ++FqdncacheStats.replies;
     assert(f->status == FQDN_DISPATCHED);
     assert(f->locks);
     cbdataFree(c);
     c = NULL;
+    n = ++FqdncacheStats.replies;
     statHistCount(&Counter.dns.svc_time,
 	tvSubMsec(f->request_time, current_time));
-    if ((x = fqdncacheParse(reply)) == NULL) {
-	debug(35, 0) ("fqdncache_dnsHandleRead: fqdncacheParse failed?!\n");
-    } else {
-	f->name_count = x->name_count;
-	for (n = 0; n < (int) f->name_count; n++)
-	    f->names[n] = x->names[n];
-	f->error_message = x->error_message;
-	f->status = x->status;
-	f->expires = x->expires;
-	fqdncache_call_pending(f);
-    }
+    x = fqdncacheParse(reply);
+    assert(x);
+    f->name_count = x->name_count;
+    for (n = 0; n < (int) f->name_count; n++)
+	f->names[n] = x->names[n];
+    f->error_message = x->error_message;
+    f->status = x->status;
+    f->expires = x->expires;
+    fqdncache_call_pending(f);
     fqdncacheUnlockEntry(f);	/* unlock from FQDN_DISPATCHED */
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ftp.cc,v 1.253 1998/09/23 20:13:49 wessels Exp $
+ * $Id: ftp.cc,v 1.254 1998/11/12 06:28:07 wessels Exp $
  *
  * DEBUG: section 9     File Transfer Protocol (FTP)
  * AUTHOR: Harvest Derived
@@ -138,14 +138,17 @@ typedef struct {
 
 typedef void (FTPSM) (FtpStateData *);
 
+#define FTP_LOGIN_ESCAPED 1
+#define FTP_LOGIN_NOT_ESCAPED 0
+
 /* Local functions */
 static CNCB ftpPasvCallback;
 static PF ftpDataRead;
 static PF ftpStateFree;
 static PF ftpTimeout;
 static PF ftpReadControlReply;
 static CWCB ftpWriteCommandCallback;
-static void ftpLoginParser(const char *, FtpStateData *);
+static void ftpLoginParser(const char *, FtpStateData *, int escaped);
 static wordlist *ftpParseControlReply(char *, size_t, int *, int *);
 static void ftpAppendSuccessHeader(FtpStateData * ftpState);
 static void ftpAuthRequired(HttpReply * reply, request_t * request, const char *realm);
@@ -287,18 +290,20 @@ ftpStateFree(int fdnotused, void *data)
 }
 
 static void
-ftpLoginParser(const char *login, FtpStateData * ftpState)
+ftpLoginParser(const char *login, FtpStateData * ftpState, int escaped)
 {
     char *s = NULL;
     xstrncpy(ftpState->user, login, MAX_URL);
     if ((s = strchr(ftpState->user, ':'))) {
 	*s = 0;
 	xstrncpy(ftpState->password, s + 1, MAX_URL);
-	rfc1738_unescape(ftpState->password);
+	if (escaped)
+	    rfc1738_unescape(ftpState->password);
     } else {
 	xstrncpy(ftpState->password, null_string, MAX_URL);
     }
-    rfc1738_unescape(ftpState->user);
+    if (escaped)
+	rfc1738_unescape(ftpState->user);
     if (ftpState->user[0] || ftpState->password[0])
 	return;
     xstrncpy(ftpState->user, "anonymous", MAX_URL);
@@ -869,7 +874,7 @@ ftpCheckAuth(FtpStateData * ftpState, const HttpHeader * req_hdr)
 {
     char *orig_user;
     const char *auth;
-    ftpLoginParser(ftpState->request->login, ftpState);
+    ftpLoginParser(ftpState->request->login, ftpState, FTP_LOGIN_ESCAPED);
     if (ftpState->user[0] && ftpState->password[0])
 	return 1;		/* name and passwd both in URL */
     if (!ftpState->user[0] && !ftpState->password[0])
@@ -879,8 +884,9 @@ ftpCheckAuth(FtpStateData * ftpState, const HttpHeader * req_hdr)
     /* URL has name, but no passwd */
     if (!(auth = httpHeaderGetAuth(req_hdr, HDR_AUTHORIZATION, "Basic")))
 	return 0;		/* need auth header */
+    ftpState->flags.authenticated = 1;
     orig_user = xstrdup(ftpState->user);
-    ftpLoginParser(auth, ftpState);
+    ftpLoginParser(auth, ftpState, FTP_LOGIN_NOT_ESCAPED);
     if (!strcmp(orig_user, ftpState->user)) {
 	xfree(orig_user);
 	return 1;		/* same username */
@@ -953,6 +959,8 @@ ftpStart(request_t * request, StoreEntry * entry, int fd)
     const char *url = storeUrl(entry);
     FtpStateData *ftpState = xcalloc(1, sizeof(FtpStateData));
     HttpReply *reply;
+    StoreEntry *pe = NULL;
+    const cache_key *key = NULL;
     cbdataAdd(ftpState, MEM_NONE);
     debug(9, 3) ("FtpStart: '%s'\n", url);
     Counter.server.all.requests++;
@@ -975,6 +983,10 @@ ftpStart(request_t * request, StoreEntry * entry, int fd)
 	    snprintf(realm, 8192, "ftp %s port %d",
 		ftpState->user, request->port);
 	}
+	/* eject any old cached object */
+	key = storeKeyPublic(entry->mem_obj->url, entry->mem_obj->method);
+	if ((pe = storeGet(key)) != NULL)
+	    storeRelease(pe);
 	/* create reply */
 	reply = entry->mem_obj->reply;
 	assert(reply != NULL);
@@ -1097,7 +1109,7 @@ ftpParseControlReply(char *buf, size_t len, int *codep, int *used)
 	if (linelen > 3)
 	    if (*s >= '0' && *s <= '9' && (*(s + 3) == '-' || *(s + 3) == ' '))
 		offset = 4;
-	list = xcalloc(1, sizeof(wordlist));
+	list = memAllocate(MEM_WORDLIST);
 	list->key = xmalloc(linelen - offset);
 	xstrncpy(list->key, s + offset, linelen - offset);
 	debug(9, 7) ("%d %s\n", code, list->key);
@@ -1333,20 +1345,14 @@ static void
 ftpReadType(FtpStateData * ftpState)
 {
     int code = ftpState->ctrl.replycode;
-    wordlist *w;
-    wordlist **T;
     char *path;
     char *d;
     debug(9, 3) ("This is ftpReadType\n");
     if (code == 200) {
 	path = xstrdup(strBuf(ftpState->request->urlpath));
-	T = &ftpState->pathcomps;
 	for (d = strtok(path, "/"); d; d = strtok(NULL, "/")) {
 	    rfc1738_unescape(d);
-	    w = xcalloc(1, sizeof(wordlist));
-	    w->key = xstrdup(d);
-	    *T = w;
-	    T = &w->next;
+	    wordlistAdd(&ftpState->pathcomps, d);
 	}
 	xfree(path);
 	if (ftpState->pathcomps)
@@ -2195,6 +2201,7 @@ ftpAppendSuccessHeader(FtpStateData * ftpState)
     const char *filename = NULL;
     const char *t = NULL;
     StoreEntry *e = ftpState->entry;
+    StoreEntry *pe = NULL;
     http_reply *reply = e->mem_obj->reply;
     if (ftpState->flags.http_header_sent)
 	return;
@@ -2230,8 +2237,20 @@ ftpAppendSuccessHeader(FtpStateData * ftpState)
     storeBufferFlush(e);
     reply->hdr_sz = e->mem_obj->inmem_hi;
     storeTimestampsSet(e);
-    if (EBIT_TEST(e->flags, ENTRY_CACHABLE))
+    if (ftpState->flags.authenticated) {
+	/*
+	 * Authenticated requests can't be cached. Eject any old cached
+	 * object
+	 */
+	pe = storeGetPublic(e->mem_obj->url, e->mem_obj->method);
+	if (pe)
+	    storeRelease(pe);
+	storeRelease(e);
+    } else if (EBIT_TEST(e->flags, ENTRY_CACHABLE)) {
 	storeSetPublicKey(e);
+    } else {
+	storeRelease(e);
+    }
 }
 
 static void
@@ -1,6 +1,6 @@
 
 /*
- * $Id: globals.h,v 1.69 1998/10/17 04:53:40 rousskov Exp $
+ * $Id: globals.h,v 1.70 1998/11/12 06:28:08 wessels Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -132,12 +132,11 @@ extern const int CacheDigestHashFuncCount;	/* 4 */
 extern CacheDigest *store_digest;	/* NULL */
 extern const char *StoreDigestUrlPath;	/* "store_digest" */
 extern const char *StoreDigestMimeStr;	/* "application/cache-digest" */
+#if USE_CACHE_DIGESTS
 extern const Version CacheDigestVer;	/* { 4, 3 } */
+#endif
 extern const char *MultipartMsgBoundaryStr;	/* "Unique-Squid-Separator" */
 extern icpUdpData *IcpQueueHead;	/* NULL */
-#if DELAY_POOLS
-extern time_t delay_pools_last_update;	/* 0 */
-#endif
 #if HTTP_VIOLATIONS
 extern int refresh_nocache_hack;	/* 0 */
 #endif
@@ -45,6 +45,7 @@ helperOpenServers(helper * hlp)
     args[nargs++] = NULL;
     assert(nargs <= HELPER_MAX_ARGS);
     for (k = 0; k < hlp->n_to_start; k++) {
+	getCurrentTime();
 	rfd = wfd = -1;
 	x = ipcCreate(hlp->ipc_type,
 	    progname,
@@ -57,8 +58,8 @@ helperOpenServers(helper * hlp)
 	    continue;
 	}
 	hlp->n_running++;
-	srv = xcalloc(1, sizeof(*srv));
-	cbdataAdd(srv, MEM_NONE);
+	srv = memAllocate(MEM_HELPER_SERVER);
+	cbdataAdd(srv, MEM_HELPER_SERVER);
 	srv->flags.alive = 1;
 	srv->index = k;
 	srv->rfd = rfd;
@@ -91,7 +92,7 @@ helperOpenServers(helper * hlp)
 void
 helperSubmit(helper * hlp, const char *buf, HLPCB * callback, void *data)
 {
-    helper_request *r = xcalloc(1, sizeof(*r));
+    helper_request *r = memAllocate(MEM_HELPER_REQUEST);
     helper_server *srv;
     if (hlp == NULL) {
 	debug(29, 3) ("helperSubmit: hlp == NULL\n");
@@ -154,10 +155,11 @@ helperStats(StoreEntry * sentry, helper * hlp)
 void
 helperShutdown(helper * hlp)
 {
-    dlink_node *link;
+    dlink_node *link = hlp->servers.head;
     helper_server *srv;
-    for (link = hlp->servers.head; link; link = link->next) {
+    while (link) {
 	srv = link->data;
+	link = link->next;
 	if (!srv->flags.alive) {
 	    debug(34, 3) ("helperShutdown: %s #%d is NOT ALIVE.\n",
 		hlp->id_name, srv->index + 1);
@@ -182,8 +184,8 @@ helperShutdown(helper * hlp)
 helper *
 helperCreate(const char *name)
 {
-    helper *hlp = xcalloc(1, sizeof(*hlp));
-    cbdataAdd(hlp, MEM_NONE);
+    helper *hlp = memAllocate(MEM_HELPER);
+    cbdataAdd(hlp, MEM_HELPER);
     hlp->id_name = name;
     return hlp;
 }
@@ -273,16 +275,17 @@ helperHandleRead(int fd, void *data)
 	    hlp->stats.replies, REDIRECT_AV_FACTOR);
 	if (srv->flags.shutdown)
 	    comm_close(srv->wfd);
+	else
+	    helperKickQueue(hlp);
     } else {
 	commSetSelect(srv->rfd, COMM_SELECT_READ, helperHandleRead, srv, 0);
     }
-    helperKickQueue(hlp);
 }
 
 static void
 Enqueue(helper * hlp, helper_request * r)
 {
-    dlink_node *link = xcalloc(1, sizeof(*link));
+    dlink_node *link = memAllocate(MEM_DLINK_NODE);
     dlinkAddTail(r, link, &hlp->queue);
     hlp->stats.queue_size++;
     if (hlp->stats.queue_size < hlp->n_running)
@@ -307,7 +310,7 @@ Dequeue(helper * hlp)
     if ((link = hlp->queue.head)) {
 	r = link->data;
 	dlinkDelete(link, &hlp->queue);
-	safe_free(link);
+	memFree(MEM_DLINK_NODE, link);
 	hlp->stats.queue_size--;
     }
     return r;
@@ -374,5 +377,5 @@ helperRequestFree(helper_request * r)
 {
     cbdataUnlock(r->data);
     xfree(r->buf);
-    xfree(r);
+    memFree(MEM_HELPER_REQUEST, r);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: http.cc,v 1.331 1998/10/19 22:37:01 wessels Exp $
+ * $Id: http.cc,v 1.332 1998/11/12 06:28:10 wessels Exp $
  *
  * DEBUG: section 11    Hypertext Transfer Protocol (HTTP)
  * AUTHOR: Harvest Derived
@@ -175,6 +175,7 @@ httpCachableReply(HttpStateData * httpState)
     HttpReply *rep = httpState->entry->mem_obj->reply;
     HttpHeader *hdr = &rep->header;
     const int cc_mask = (rep->cache_control) ? rep->cache_control->mask : 0;
+    const char *v;
     if (EBIT_TEST(cc_mask, CC_PRIVATE))
 	return 0;
     if (EBIT_TEST(cc_mask, CC_NO_CACHE))
@@ -196,6 +197,23 @@ httpCachableReply(HttpStateData * httpState)
      */
     if (httpHeaderHas(hdr, HDR_VARY))
 	return 0;
+    /* Pragma: no-cache in _replies_ is not documented in HTTP,
+     * but servers like "Active Imaging Webcast/2.0" sure do use it */
+    if (httpHeaderHas(hdr, HDR_PRAGMA)) {
+	String s = httpHeaderGetList(hdr, HDR_PRAGMA);
+	const int no_cache = strListIsMember(&s, "no-cache", ',');
+	stringClean(&s);
+	if (no_cache)
+	    return 0;
+    }
+    /*
+     * The "multipart/x-mixed-replace" content type is used for
+     * continuous push replies.  These are generally dynamic and
+     * probably should not be cachable
+     */
+    if ((v = httpHeaderGetStr(hdr, HDR_CONTENT_TYPE)))
+	if (!strncasecmp(v, "multipart/x-mixed-replace", 25))
+	    return 0;
     switch (httpState->entry->mem_obj->reply->sline.status) {
 	/* Responses that are cacheable */
     case HTTP_OK:
@@ -592,7 +610,7 @@ httpBuildRequestHeader(request_t * request,
      *  the server and fetch only the requested content) 
      */
     we_do_ranges =
-	orig_request->range && orig_request->flags.cachable && !httpHdrRangeWillBeComplex(orig_request->range);
+	orig_request->range && orig_request->flags.cachable && !httpHdrRangeWillBeComplex(orig_request->range) && (Config.rangeOffsetLimit == -1 || httpHdrRangeFirstOffset(orig_request->range) <= Config.rangeOffsetLimit);
     debug(11, 8) ("httpBuildRequestHeader: range specs: %p, cachable: %d; we_do_ranges: %d\n",
 	orig_request->range, orig_request->flags.cachable, we_do_ranges);
 
@@ -604,13 +622,20 @@ httpBuildRequestHeader(request_t * request,
 	    continue;
 	switch (e->id) {
 	case HDR_PROXY_AUTHORIZATION:
-	    /* If we're not going to do proxy auth, then it must be passed on */
+	    /* If we're not doing proxy auth, then it must be passed on */
 	    if (!request->flags.used_proxy_auth)
 		httpHeaderAddEntry(hdr_out, httpHeaderEntryClone(e));
 	    break;
+	case HDR_AUTHORIZATION:
+	    /* If we're not doing www auth, then it must be passed on */
+	    if (!request->flags.accelerated || !request->flags.used_proxy_auth)
+		httpHeaderAddEntry(hdr_out, httpHeaderEntryClone(e));
+	    else
+		request->flags.auth = 0;	/* We have used the authentication */
+	    break;
 	case HDR_HOST:
 	    /* Don't use client's Host: header for redirected requests */
-	    if (!request->flags.redirected)
+	    if (!request->flags.redirected || !Config.onoff.redir_rewrites_host)
 		httpHeaderAddEntry(hdr_out, httpHeaderEntryClone(e));
 	    break;
 	case HDR_IF_MODIFIED_SINCE:
@@ -676,6 +701,20 @@ httpBuildRequestHeader(request_t * request,
 		orig_request->host, (int) orig_request->port);
 	}
     }
+    /* append Authorization if known in URL, not in header and going direct */
+    if (!httpHeaderHas(hdr_out, HDR_AUTHORIZATION)) {
+	if (!request->flags.proxying && *request->login) {
+	    httpHeaderPutStrf(hdr_out, HDR_AUTHORIZATION, "Basic %s",
+		base64_encode(request->login));
+	}
+    }
+    /* append Proxy-Authorization if configured for peer, and proxying */
+    if (!httpHeaderHas(hdr_out, HDR_PROXY_AUTHORIZATION)) {
+	if (request->flags.proxying && request->peer_login) {
+	    httpHeaderPutStrf(hdr_out, HDR_PROXY_AUTHORIZATION, "Basic %s",
+		base64_encode(request->peer_login));
+	}
+    }
     /* append Cache-Control, add max-age if not there already */
     {
 	HttpHdrCc *cc = httpHeaderGetCc(hdr_in);
@@ -800,6 +839,7 @@ httpStart(FwdState * fwdState, int fd)
 	xstrncpy(proxy_req->host, httpState->peer->host, SQUIDHOSTNAMELEN);
 	proxy_req->port = httpState->peer->http_port;
 	proxy_req->flags = orig_req->flags;
+	proxy_req->peer_login = httpState->peer->login;
 	httpState->request = requestLink(proxy_req);
 	httpState->orig_request = requestLink(orig_req);
 	proxy_req->flags.proxying = 1;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: internal.cc,v 1.14 1998/08/20 15:30:22 wessels Exp $
+ * $Id: internal.cc,v 1.15 1998/11/12 06:28:11 wessels Exp $
  *
  * DEBUG: section 76    Internal Squid Object handling
  * AUTHOR: Duane, Alex, Henrik
@@ -101,3 +101,12 @@ internalLocalUri(const char *dir, const char *name)
 {
     return internalRemoteUri(getMyHostname(), Config.Port.http->i, dir, name);
 }
+
+const char *
+internalHostname(void)
+{
+    LOCAL_ARRAY(char, host, SQUIDHOSTNAMELEN + 1);
+    xstrncpy(host, getMyHostname(), SQUIDHOSTNAMELEN);
+    Tolower(host);
+    return host;
+}
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ipc.cc,v 1.11 1998/08/18 19:14:03 wessels Exp $
+ * $Id: ipc.cc,v 1.12 1998/11/12 06:28:12 wessels Exp $
  *
  * DEBUG: section 54    Interprocess Communication
  * AUTHOR: Duane Wessels
@@ -68,7 +68,9 @@ ipcCreate(int type, const char *prog, char *const args[], const char *name, int
     int fd;
     socklen_t len;
     int tmp_s;
+#if HAVE_PUTENV
     char *env_str;
+#endif
     int x;
 
 #if HAVE_POLL && defined(_SQUID_OSF_)
@@ -237,9 +239,11 @@ ipcCreate(int type, const char *prog, char *const args[], const char *name, int
 	    _exit(1);
 	}
     }
+#if HAVE_PUTENV
     env_str = xcalloc((tmp_s = strlen(Config.debugOptions) + 32), 1);
     snprintf(env_str, tmp_s, "SQUID_DEBUG=%s", Config.debugOptions);
     putenv(env_str);
+#endif
     dup2(crfd, 0);
     dup2(cwfd, 1);
     dup2(fileno(debug_log), 2);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ipcache.cc,v 1.205 1998/10/19 04:44:38 wessels Exp $
+ * $Id: ipcache.cc,v 1.206 1998/11/12 06:28:13 wessels Exp $
  *
  * DEBUG: section 14    IP Cache
  * AUTHOR: Harvest Derived
@@ -265,11 +265,15 @@ ipcacheParse(const char *inbuf)
     int ipcount = 0;
     int ttl;
     char A[32][16];
-    xstrncpy(buf, inbuf, DNS_INBUF_SZ);
-    debug(14, 5) ("ipcacheParse: parsing:%s\n", buf);
     memset(&i, '\0', sizeof(i));
     i.expires = squid_curtime;
     i.status = IP_NEGATIVE_CACHED;
+    if (inbuf == NULL) {
+	debug(14, 1) ("ipcacheParse: Got <NULL> reply\n");
+	return &i;
+    }
+    xstrncpy(buf, inbuf, DNS_INBUF_SZ);
+    debug(14, 5) ("ipcacheParse: parsing:%s\n", buf);
     token = strtok(buf, w_space);
     if (NULL == token) {
 	debug(14, 1) ("ipcacheParse: Got <NULL>, expecting '$addr'\n");
@@ -332,15 +336,13 @@ ipcacheHandleReply(void *data, char *reply)
     c = NULL;
     n = ++IpcacheStats.replies;
     statHistCount(&Counter.dns.svc_time, tvSubMsec(i->request_time, current_time));
-    if ((x = ipcacheParse(reply)) == NULL) {
-	debug(14, 0) ("ipcache_dnsHandleRead: ipcacheParse failed?!\n");
-    } else {
-	i->status = x->status;
-	i->addrs = x->addrs;
-	i->error_message = x->error_message;
-	i->expires = x->expires;
-	ipcache_call_pending(i);
-    }
+    x = ipcacheParse(reply);
+    assert(x);
+    i->status = x->status;
+    i->addrs = x->addrs;
+    i->error_message = x->error_message;
+    i->expires = x->expires;
+    ipcache_call_pending(i);
     ipcacheUnlockEntry(i);	/* unlock from IP_DISPATCHED */
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: main.cc,v 1.275 1998/11/11 20:04:16 glenn Exp $
+ * $Id: main.cc,v 1.276 1998/11/12 06:28:14 wessels Exp $
  *
  * DEBUG: section 1     Startup and Main Loop
  * AUTHOR: Harvest Derived
@@ -318,7 +318,7 @@ mainReconfigure(void)
     redirectShutdown();
     authenticateShutdown();
     storeDirCloseSwapLogs();
-    errorFree();
+    errorClean();
     parseConfigFile(ConfigFile);
     _db_init(Config.Log.log, Config.debugOptions);
     ipcache_restart();		/* clear stuck entries */
@@ -416,7 +416,6 @@ mainInitialize(void)
 #ifdef SQUID_SNMP
     snmpInit();
 #endif
- 
 
 #if MALLOC_DBG
     malloc_debug(0, malloc_debug_level);
@@ -715,7 +714,6 @@ SquidShutdown(void *unused)
 #if PURIFY || XMALLOC_TRACE
     configFreeMemory();
     storeFreeMemory();
-    dnsFreeMemory();
     /*stmemFreeMemory(); */
     netdbFreeMemory();
     ipcacheFreeMemory();
@@ -725,6 +723,8 @@ SquidShutdown(void *unused)
     httpHeaderCleanModule();
     statFreeMemory();
     eventFreeMemory();
+    mimeFreeMemory();
+    errorClean();
 #endif
     memClean();
 #if !XMALLOC_TRACE
@@ -1,6 +1,6 @@
 
 /*
- * $Id: mem.cc,v 1.34 1998/08/30 05:21:42 wessels Exp $
+ * $Id: mem.cc,v 1.35 1998/11/12 06:28:14 wessels Exp $
  *
  * DEBUG: section 13    High Level Memory Pool Management
  * AUTHOR: Harvest Derived
@@ -207,7 +207,9 @@ memInit(void)
     memDataInit(MEM_AIO_RESULT_T, "aio_result_t", sizeof(aio_result_t), 0);
     memDataInit(MEM_CACHEMGR_PASSWD, "cachemgr_passwd",
 	sizeof(cachemgr_passwd), 0);
+#if USE_CACHE_DIGESTS
     memDataInit(MEM_CACHE_DIGEST, "CacheDigest", sizeof(CacheDigest), 0);
+#endif
     memDataInit(MEM_CLIENTHTTPREQUEST, "clientHttpRequest",
 	sizeof(clientHttpRequest), 0);
     memDataInit(MEM_CLOSE_HANDLER, "close_handler", sizeof(close_handler), 0);
@@ -255,7 +257,9 @@ memInit(void)
     memDataInit(MEM_NETDBENTRY, "netdbEntry", sizeof(netdbEntry), 0);
     memDataInit(MEM_NET_DB_NAME, "net_db_name", sizeof(net_db_name), 0);
     memDataInit(MEM_NET_DB_PEER, "net_db_peer", sizeof(net_db_peer), 0);
+#if USE_CACHE_DIGESTS
     memDataInit(MEM_DIGEST_FETCH_STATE, "DigestFetchState", sizeof(DigestFetchState), 0);
+#endif
     memDataInit(MEM_PEER, "peer", sizeof(peer), 0);
     memDataInit(MEM_PINGERECHODATA, "pingerEchoData",
 	sizeof(pingerEchoData), 0);
@@ -278,6 +282,11 @@ memInit(void)
     memDataInit(MEM_WORDLIST, "wordlist", sizeof(wordlist), 0);
     memDataInit(MEM_CLIENT_INFO, "ClientInfo", sizeof(ClientInfo), 0);
     memDataInit(MEM_MD5_DIGEST, "MD5 digest", MD5_DIGEST_CHARS, 0);
+    memDataInit(MEM_HELPER, "helper", sizeof(helper), 0);
+    memDataInit(MEM_HELPER_REQUEST, "helper_request",
+	sizeof(helper_request), 0);
+    memDataInit(MEM_HELPER_SERVER, "helper_server",
+	sizeof(helper_server), 0);
     /* test that all entries are initialized */
     for (t = MEM_NONE, t++; t < MEM_MAX; t++) {
 	if (MEM_DONTFREE == t)
@@ -1,6 +1,6 @@
 
 /*
- * $Id: mime.cc,v 1.81 1998/09/21 06:52:17 wessels Exp $
+ * $Id: mime.cc,v 1.82 1998/11/12 06:28:15 wessels Exp $
  *
  * DEBUG: section 25    MIME Parsing
  * AUTHOR: Harvest Derived
@@ -365,6 +365,22 @@ mimeInit(char *filename)
     debug(25, 1) ("Loaded Icons.\n");
 }
 
+void
+mimeFreeMemory(void)
+{
+    mimeEntry *m;
+    while ((m = MimeTable)) {
+	MimeTable = m->next;
+	safe_free(m->pattern);
+	safe_free(m->content_type);
+	safe_free(m->icon);
+	safe_free(m->content_encoding);
+	regfree(&m->compiled_pattern);
+	safe_free(m);
+    }
+    MimeTableTail = &MimeTable;
+}
+
 static void
 mimeLoadIconFile(const char *icon)
 {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: neighbors.cc,v 1.258 1998/10/12 21:40:59 wessels Exp $
+ * $Id: neighbors.cc,v 1.259 1998/11/12 06:28:16 wessels Exp $
  *
  * DEBUG: section 15    Neighbor Routines
  * AUTHOR: Harvest Derived
@@ -1116,6 +1116,8 @@ dump_peer_options(StoreEntry * sentry, peer * p)
     if (p->options.no_delay)
 	storeAppendPrintf(sentry, " no-delay");
 #endif
+    if (p->login)
+	storeAppendPrintf(sentry, " login=%s", p->login);
     if (p->mcast.ttl > 0)
 	storeAppendPrintf(sentry, " ttl=%d", p->mcast.ttl);
     storeAppendPrintf(sentry, "\n");
@@ -1,6 +1,6 @@
 
 /*
- * $Id: net_db.cc,v 1.131 1998/10/13 23:33:34 wessels Exp $
+ * $Id: net_db.cc,v 1.132 1998/11/12 06:28:17 wessels Exp $
  *
  * DEBUG: section 38    Network Measurement Database
  * AUTHOR: Duane Wessels
@@ -75,7 +75,6 @@ static void netdbExchangeDone(void *);
  * remain persisitent, so _net_db_peer->peername points into this
  * linked list */
 static wordlist *peer_names = NULL;
-static wordlist **peer_names_tail = &peer_names;
 
 static void
 netdbHashInsert(netdbEntry * n, struct in_addr addr)
@@ -474,10 +473,7 @@ netdbPeerName(const char *name)
 	if (!strcmp(w->key, name))
 	    return w->key;
     }
-    w = xcalloc(1, sizeof(wordlist));
-    w->key = xstrdup(name);
-    *peer_names_tail = w;
-    peer_names_tail = &w->next;
+    w = wordlistAdd(&peer_names, name);
     return w->key;
 }
 
@@ -691,7 +687,6 @@ netdbFreeMemory(void)
     host_table = NULL;
     wordlistDestroy(&peer_names);
     peer_names = NULL;
-    peer_names_tail = &peer_names;
 #endif
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: peer_digest.cc,v 1.56 1998/09/29 16:33:48 wessels Exp $
+ * $Id: peer_digest.cc,v 1.57 1998/11/12 06:28:18 wessels Exp $
  *
  * DEBUG: section 72    Peer Digest Routines
  * AUTHOR: Alex Rousskov
@@ -47,10 +47,10 @@ static void peerDigestDisable(peer * p);
 static void peerDigestDelay(peer * p, int disable, time_t delay);
 static EVH peerDigestValidate;
 static void peerDigestRequest(peer * p);
-static void peerDigestFetchReply(void *data, char *buf, ssize_t size);
+static STCB peerDigestFetchReply;
 static void peerDigestRequest(peer * p);
-static void peerDigestSwapInHeaders(void *data, char *buf, ssize_t size);
-static void peerDigestSwapInCBlock(void *data, char *buf, ssize_t size);
+static STCB peerDigestSwapInHeaders;
+static STCB peerDigestSwapInCBlock;
 static STCB peerDigestSwapInMask;
 static int peerDigestFetchedEnough(DigestFetchState * fetch, char *buf, ssize_t size, const char *step_name);
 static void peerDigestFetchFinish(DigestFetchState * fetch, char *buf, const char *err_msg);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: peer_select.cc,v 1.88 1998/10/13 23:33:35 wessels Exp $
+ * $Id: peer_select.cc,v 1.89 1998/11/12 06:28:19 wessels Exp $
  *
  * DEBUG: section 44    Peer Selection Algorithm
  * AUTHOR: Duane Wessels
@@ -306,8 +306,11 @@ peerSelectFoo(ps_state * psstate)
 	return;
     }
     if ((p = getSingleParent(request))) {
-	psstate->single_parent = p->in_addr;
-	debug(44, 3) ("peerSelect: found single parent, skipping ICP query\n");
+	code = SINGLE_PARENT;
+	debug(44, 3) ("peerSelectFoo: %s/%s\n", hier_strings[code], p->host);
+	hierarchyNote(&request->hier, code, &psstate->ping, p->host);
+	peerSelectCallback(psstate, p);
+	return;
     }
     if (!request->flags.hierarchical && direct != DIRECT_NO) {
 	debug(44, 3) ("peerSelectFoo: DIRECT for non-hierarchical request\n");
@@ -381,11 +384,6 @@ peerSelectFoo(ps_state * psstate)
 	debug(44, 3) ("peerSelect: %s/%s\n", hier_strings[code], p->host);
 	hierarchyNote(&request->hier, code, &psstate->ping, p->host);
 	peerSelectCallback(psstate, p);
-    } else if ((p = whichPeer(&psstate->single_parent))) {
-	code = SINGLE_PARENT;
-	debug(44, 3) ("peerSelect: %s/%s\n", hier_strings[code], p->host);
-	hierarchyNote(&request->hier, code, &psstate->ping, p->host);
-	peerSelectCallback(psstate, p);
     } else if (direct != DIRECT_NO) {
 	code = DIRECT;
 	debug(44, 3) ("peerSelect: %s/%s\n", hier_strings[code], request->host);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: protos.h,v 1.284 1998/11/11 20:04:17 glenn Exp $
+ * $Id: protos.h,v 1.285 1998/11/12 06:28:20 wessels Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -89,7 +89,7 @@ extern void aioCheckCallbacks(void);
 extern int parseConfigFile(const char *file_name);
 extern void intlistDestroy(intlist **);
 extern int intlistFind(intlist * list, int i);
-extern void wordlistAdd(wordlist **, const char *);
+extern wordlist *wordlistAdd(wordlist **, const char *);
 extern void wordlistDestroy(wordlist **);
 extern void configFreeMemory(void);
 extern void wordlistCat(const wordlist *, MemBuf * mb);
@@ -329,6 +329,8 @@ extern int httpHdrRangeCanonize(HttpHdrRange * range, size_t clen);
 extern String httpHdrRangeBoundaryStr(clientHttpRequest * http);
 extern int httpHdrRangeIsComplex(const HttpHdrRange * range);
 extern int httpHdrRangeWillBeComplex(const HttpHdrRange * range);
+extern size_t httpHdrRangeFirstOffset(const HttpHdrRange * range);
+
 
 /* Http Content Range Header Field */
 extern HttpHdrContRange *httpHdrContRangeCreate();
@@ -483,7 +485,7 @@ extern void snmpConnectionShutdown(void);
 extern void snmpConnectionClose(void);
 extern void snmpDebugOid(int lvl, oid * Name, snint Len);
 extern void addr2oid(struct in_addr addr, oid * Dest);
-extern struct in_addr* oid2addr(oid * id); 
+extern struct in_addr *oid2addr(oid * id);
 variable_list *snmp_basicFn(variable_list *, snint *);
 variable_list *snmp_confFn(variable_list *, snint *);
 variable_list *snmp_sysFn(variable_list *, snint *);
@@ -555,6 +557,7 @@ extern size_t headersEnd(const char *, size_t);
 extern const char *mime_get_auth(const char *hdr, const char *auth_scheme, const char **auth_field);
 
 extern void mimeInit(char *filename);
+extern void mimeFreeMemory(void);
 extern char *mimeGetContentEncoding(const char *fn);
 extern char *mimeGetContentType(const char *fn);
 extern char *mimeGetIcon(const char *fn);
@@ -987,13 +990,13 @@ extern void useragentRotateLog(void);
 extern void logUserAgent(const char *, const char *);
 extern peer_t parseNeighborType(const char *s);
 
+extern void errorInitialize(void);
+extern void errorClean(void);
 extern HttpReply *errorBuildReply(ErrorState * err);
 extern void errorSend(int fd, ErrorState *);
 extern void errorAppendEntry(StoreEntry *, ErrorState *);
 extern void errorStateFree(ErrorState * err);
-extern void errorInitialize(void);
 extern int errorReservePageId(const char *page_name);
-extern void errorFree(void);
 extern ErrorState *errorCon(err_type type, http_status);
 
 extern void pconnPush(int, const char *host, u_short port);
@@ -1072,6 +1075,7 @@ extern int internalCheck(const char *urlpath);
 extern int internalStaticCheck(const char *urlpath);
 extern char *internalLocalUri(const char *dir, const char *name);
 extern char *internalRemoteUri(const char *, u_short, const char *, const char *);
+extern const char *internalHostname(void);
 
 #if USE_CARP
 extern void carpInit(void);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: redirect.cc,v 1.75 1998/10/19 22:37:02 wessels Exp $
+ * $Id: redirect.cc,v 1.76 1998/11/12 06:28:22 wessels Exp $
  *
  * DEBUG: section 29    Redirector
  * AUTHOR: Duane Wessels
@@ -55,12 +55,13 @@ redirectHandleReply(void *data, char *reply)
     redirectStateData *r = data;
     int valid;
     char *t;
-    assert(cbdataValid(data));
-    debug(29, 5) ("redirectHandleRead: {%s}\n", reply);
-    if ((t = strchr(reply, ' ')))
-	*t = '\0';
-    if (*reply == '\0')
-	reply = NULL;
+    debug(29, 5) ("redirectHandleRead: {%s}\n", reply ? reply : "<NULL>");
+    if (reply) {
+	if ((t = strchr(reply, ' ')))
+	    *t = '\0';
+	if (*reply == '\0')
+	    reply = NULL;
+    }
     valid = cbdataValid(r->data);
     cbdataUnlock(r->data);
     if (valid)
@@ -1,7 +1,7 @@
 
 
 /*
- * $Id: refresh.cc,v 1.43 1998/10/19 22:37:02 wessels Exp $
+ * $Id: refresh.cc,v 1.44 1998/11/12 06:28:23 wessels Exp $
  *
  * DEBUG: section 22    Refresh Calculation
  * AUTHOR: Harvest Derived
@@ -267,7 +267,10 @@ refreshCheckICP(const StoreEntry * entry, request_t * request)
 int
 refreshCheckDigest(const StoreEntry * entry, time_t delta)
 {
-    return refreshCheck(entry, NULL, delta, &refreshCounts[rcCDigest]);
+    return refreshCheck(entry,
+	entry->mem_obj ? entry->mem_obj->request : NULL,
+	delta,
+	&refreshCounts[rcCDigest]);
 }
 
 time_t
@@ -1,5 +1,5 @@
 /*
- * $Id: snmp_core.cc,v 1.13 1998/11/11 20:04:19 glenn Exp $
+ * $Id: snmp_core.cc,v 1.14 1998/11/12 06:28:23 wessels Exp $
  *
  * DEBUG: section 49    SNMP support
  * AUTHOR: Glenn Chisholm
@@ -38,12 +38,12 @@
 #define MAX_PROTOSTAT 5
 
 struct _mib_tree_entry {
-	oid	*name;
-	int	len;
-	oid_ParseFn *parsefunction;
-	int	children;
-	struct _mib_tree_entry **leaves;
-	struct _mib_tree_entry *parent;
+    oid *name;
+    int len;
+    oid_ParseFn *parsefunction;
+    int children;
+    struct _mib_tree_entry **leaves;
+    struct _mib_tree_entry *parent;
 };
 
 struct _snmpUdpData {
@@ -64,19 +64,19 @@ extern void (*snmplib_debug_hook) (int, char *);
 
 static void snmpDecodePacket(snmp_request_t * rq);
 static void snmpConstructReponse(snmp_request_t * rq, struct snmp_session *Session);
-static struct snmp_pdu* snmpAgentResponse(struct snmp_pdu *PDU);
+static struct snmp_pdu *snmpAgentResponse(struct snmp_pdu *PDU);
 
 static void snmpUdpSend(int, const struct sockaddr_in *, void *, int);
 static void snmpUdpReply(int, void *);
 static void snmpAppendUdp(snmpUdpData *);
 
 
-static mib_tree_entry* snmpAddNode(oid *name, int len, oid_ParseFn *parsefunction, int children, ...);
-static oid_ParseFn *snmpTreeNext(oid *Current, snint CurrentLen, oid **Next, snint *NextLen);
-static mib_tree_entry* snmpTreeEntry(oid entry, snint len, mib_tree_entry *current);
+static mib_tree_entry *snmpAddNode(oid * name, int len, oid_ParseFn * parsefunction, int children,...);
+static oid_ParseFn *snmpTreeNext(oid * Current, snint CurrentLen, oid ** Next, snint * NextLen);
+static mib_tree_entry *snmpTreeEntry(oid entry, snint len, mib_tree_entry * current);
 
-static oid* snmpCreateOid(int length, ...);
-static oid* snmpOidDup(oid * A, snint ALen);                       
+static oid *snmpCreateOid(int length,...);
+static oid *snmpOidDup(oid * A, snint ALen);
 static void snmpSnmplibDebug(int lvl, char *buf);
 
 
@@ -89,8 +89,8 @@ static void snmpSnmplibDebug(int lvl, char *buf);
  */
 
 /*
-	Turns the MIB into a Tree structure. Called during the startup process.
-*/
+ * Turns the MIB into a Tree structure. Called during the startup process.
+ */
 void
 snmpInit(void)
 {
@@ -348,64 +348,64 @@ snmpConnectionOpen(void)
     socklen_t len;
     int x;
 
-	debug(49, 5) ("snmpConnectionOpen: Called\n");
+    debug(49, 5) ("snmpConnectionOpen: Called\n");
     if ((port = Config.Port.snmp) > (u_short) 0) {
-        enter_suid();
-        theInSnmpConnection = comm_open(SOCK_DGRAM,
-            0,
-            Config.Addrs.snmp_incoming,
-            port,
-            COMM_NONBLOCKING,
-            "SNMP Port");
-        leave_suid();
-        if (theInSnmpConnection < 0)
-            fatal("Cannot open snmp Port");
-        commSetSelect(theInSnmpConnection, COMM_SELECT_READ, snmpHandleUdp, NULL, 0);
-        debug(1, 1) ("Accepting SNMP messages on port %d, FD %d.\n",
-            (int) port, theInSnmpConnection);
-        if (Config.Addrs.snmp_outgoing.s_addr != no_addr.s_addr) {
-            enter_suid();
-            theOutSnmpConnection = comm_open(SOCK_DGRAM,
-                0,
-                Config.Addrs.snmp_outgoing,
-                port,
-                COMM_NONBLOCKING,
-                "SNMP Port");
-            leave_suid();
-            if (theOutSnmpConnection < 0)
-                fatal("Cannot open Outgoing SNMP Port");
-            commSetSelect(theOutSnmpConnection,
-                COMM_SELECT_READ,
-                snmpHandleUdp,
-                NULL, 0);
-            debug(1, 1) ("Outgoing SNMP messages on port %d, FD %d.\n",
-                (int) port, theOutSnmpConnection);
-            fd_note(theOutSnmpConnection, "Outgoing SNMP socket");
-            fd_note(theInSnmpConnection, "Incoming SNMP socket");
-        } else {
-            theOutSnmpConnection = theInSnmpConnection;
-        }
-        memset(&theOutSNMPAddr, '\0', sizeof(struct in_addr));
-        len = sizeof(struct sockaddr_in);
-        memset(&xaddr, '\0', len);
-        x = getsockname(theOutSnmpConnection,
-            (struct sockaddr *) &xaddr, &len);
-        if (x < 0)
-            debug(51, 1) ("theOutSnmpConnection FD %d: getsockname: %s\n",
-                theOutSnmpConnection, xstrerror());
-        else 
-            theOutSNMPAddr = xaddr.sin_addr;
+	enter_suid();
+	theInSnmpConnection = comm_open(SOCK_DGRAM,
+	    0,
+	    Config.Addrs.snmp_incoming,
+	    port,
+	    COMM_NONBLOCKING,
+	    "SNMP Port");
+	leave_suid();
+	if (theInSnmpConnection < 0)
+	    fatal("Cannot open snmp Port");
+	commSetSelect(theInSnmpConnection, COMM_SELECT_READ, snmpHandleUdp, NULL, 0);
+	debug(1, 1) ("Accepting SNMP messages on port %d, FD %d.\n",
+	    (int) port, theInSnmpConnection);
+	if (Config.Addrs.snmp_outgoing.s_addr != no_addr.s_addr) {
+	    enter_suid();
+	    theOutSnmpConnection = comm_open(SOCK_DGRAM,
+		0,
+		Config.Addrs.snmp_outgoing,
+		port,
+		COMM_NONBLOCKING,
+		"SNMP Port");
+	    leave_suid();
+	    if (theOutSnmpConnection < 0)
+		fatal("Cannot open Outgoing SNMP Port");
+	    commSetSelect(theOutSnmpConnection,
+		COMM_SELECT_READ,
+		snmpHandleUdp,
+		NULL, 0);
+	    debug(1, 1) ("Outgoing SNMP messages on port %d, FD %d.\n",
+		(int) port, theOutSnmpConnection);
+	    fd_note(theOutSnmpConnection, "Outgoing SNMP socket");
+	    fd_note(theInSnmpConnection, "Incoming SNMP socket");
+	} else {
+	    theOutSnmpConnection = theInSnmpConnection;
+	}
+	memset(&theOutSNMPAddr, '\0', sizeof(struct in_addr));
+	len = sizeof(struct sockaddr_in);
+	memset(&xaddr, '\0', len);
+	x = getsockname(theOutSnmpConnection,
+	    (struct sockaddr *) &xaddr, &len);
+	if (x < 0)
+	    debug(51, 1) ("theOutSnmpConnection FD %d: getsockname: %s\n",
+		theOutSnmpConnection, xstrerror());
+	else
+	    theOutSNMPAddr = xaddr.sin_addr;
     }
 }
 
 void
 snmpConnectionShutdown(void)
 {
     if (theInSnmpConnection < 0)
-        return;
+	return;
     if (theInSnmpConnection != theOutSnmpConnection) {
-        debug(49, 1) ("FD %d Closing SNMP socket\n", theInSnmpConnection);
-        comm_close(theInSnmpConnection);
+	debug(49, 1) ("FD %d Closing SNMP socket\n", theInSnmpConnection);
+	comm_close(theInSnmpConnection);
     }
     /*
      * Here we set 'theInSnmpConnection' to -1 even though the SNMP 'in'
@@ -428,14 +428,14 @@ snmpConnectionClose(void)
 {
     snmpConnectionShutdown();
     if (theOutSnmpConnection > -1) {
-        debug(49, 1) ("FD %d Closing SNMP socket\n", theOutSnmpConnection);
-        comm_close(theOutSnmpConnection);
+	debug(49, 1) ("FD %d Closing SNMP socket\n", theOutSnmpConnection);
+	comm_close(theOutSnmpConnection);
     }
 }
 
 /*
-	Functions for handling the requests.
-*/
+ * Functions for handling the requests.
+ */
 
 /*
  * Accept the UDP packet
@@ -572,7 +572,7 @@ snmpAgentResponse(struct snmp_pdu *PDU)
 	    int NextOidNameLen = 0;
 
 	    ParseFn = snmpTreeNext(PDU->variables->name, PDU->variables->name_length,
-		&(NextOidName), (snint *) &NextOidNameLen);
+		&(NextOidName), (snint *) & NextOidNameLen);
 
 	    if (ParseFn == NULL) {
 		Answer->errstat = SNMP_ERR_NOSUCHNAME;
@@ -582,7 +582,7 @@ snmpAgentResponse(struct snmp_pdu *PDU)
 		xfree(PDU->variables->name);
 		PDU->variables->name = NextOidName;
 		PDU->variables->name_length = NextOidNameLen;
-		VarNew = (*ParseFn) (PDU->variables, (snint *) &Answer->errstat);
+		VarNew = (*ParseFn) (PDU->variables, (snint *) & Answer->errstat);
 	    }
 
 	    /* Was there an error? */
@@ -596,9 +596,9 @@ snmpAgentResponse(struct snmp_pdu *PDU)
 		Answer->variables = VarNew;
 	    }
 
-	}else{
-		snmp_free_pdu(Answer);
-		Answer = NULL;
+	} else {
+	    snmp_free_pdu(Answer);
+	    Answer = NULL;
 	}
     }
     return (Answer);
@@ -620,33 +620,33 @@ snmpTreeNext(oid * Current, snint CurrentLen, oid ** Next, snint * NextLen)
     if (Current[count] == mibTreeEntry->name[count]) {
 	count++;
 	while ((mibTreeEntry) && (count < CurrentLen)) {
-	    mibTreeEntry = snmpTreeEntry(Current[count], count , mibTreeEntry);
+	    mibTreeEntry = snmpTreeEntry(Current[count], count, mibTreeEntry);
 	    count++;
 	}
 	debug(49, 5) ("snmpTreeNext: Past first\n");
 
 	if (mibTreeEntry->parsefunction) {
-	    while(!new_oid){
-		new_oid = snmpTreeEntry(Current[count]+1, count , mibTreeEntry->parent);
-		if(!new_oid){
+	    while (!new_oid) {
+		new_oid = snmpTreeEntry(Current[count] + 1, count, mibTreeEntry->parent);
+		if (!new_oid) {
 		    mibTreeEntry = mibTreeEntry->parent;
 		    count--;
 		}
 	    }
-	} 
+	}
 	debug(49, 5) ("snmpTreeNext: Past Second\n");
 
 	if ((!mibTreeEntry->parsefunction) && (mibTreeEntry)) {
 	    while (!mibTreeEntry->parsefunction) {
-		mibTreeEntry = snmpTreeEntry(1, count , mibTreeEntry);
+		mibTreeEntry = snmpTreeEntry(1, count, mibTreeEntry);
 		count++;
 	    }
 	}
 	debug(49, 5) ("snmpTreeNext: Past Third\n");
     }
-    if(mibTreeEntry){
-        *Next = snmpOidDup(mibTreeEntry->name, mibTreeEntry->len);
-        *NextLen = mibTreeEntry->len;
+    if (mibTreeEntry) {
+	*Next = snmpOidDup(mibTreeEntry->name, mibTreeEntry->len);
+	*NextLen = mibTreeEntry->len;
 	Fn = mibTreeEntry->parsefunction;
     }
     debug(49, 5) ("snmpTreeNext: return\n");
@@ -661,7 +661,7 @@ snmpTreeEntry(oid entry, snint len, mib_tree_entry * current)
 
     debug(49, 5) ("snmpTreeEntry: Called\n");
 
-    debug(49, 6) ("snmpTreeEntry: Oid: %d, Len: %d, Current : \n",entry, len);
+    debug(49, 6) ("snmpTreeEntry: Oid: %d, Len: %d, Current : \n", entry, len);
     snmpDebugOid(6, current->name, current->len);
 
     while ((!next) && (count < current->children)) {
@@ -672,22 +672,22 @@ snmpTreeEntry(oid entry, snint len, mib_tree_entry * current)
 	}
 	count++;
     }
-    if(next){
-    	debug(49, 6) ("snmpTreeEntry: Returned : \n");
-    	snmpDebugOid(6, next->name, next->len);
+    if (next) {
+	debug(49, 6) ("snmpTreeEntry: Returned : \n");
+	snmpDebugOid(6, next->name, next->len);
     }
     return (next);
 }
 
 /*
-	Send the UDP reply.
-*/
+ * Send the UDP reply.
+ */
 void
 snmpUdpSend(int fd, const struct sockaddr_in *to, void *msg, int len)
 {
     snmpUdpData *data = xcalloc(1, sizeof(snmpUdpData));
     debug(49, 5) ("snmpUdpSend: Queueing response for %s\n",
-        inet_ntoa(to->sin_addr));
+	inet_ntoa(to->sin_addr));
     data->address = *to;
     data->msg = msg;
     data->len = len;
@@ -704,29 +704,29 @@ snmpUdpReply(int fd, void *data)
     /* Disable handler, in case of errors. */
     commSetSelect(fd, COMM_SELECT_WRITE, NULL, NULL, 0);
     while ((queue = snmpUdpHead) != NULL) {
-        debug(49, 5) ("snmpUdpReply: FD %d sending %d bytes to %s port %d\n",
-            fd,
-            queue->len,
-            inet_ntoa(queue->address.sin_addr),
-            ntohs(queue->address.sin_port));
-        x = comm_udp_sendto(fd,
-            &queue->address,
-            sizeof(struct sockaddr_in),
-            queue->msg,
-            queue->len);
-        if (x < 0) {
-            if (ignoreErrno(errno))
-                break;          /* don't de-queue */
-        }
-        snmpUdpHead = queue->next;
-        debug(49, 3) ("snmpUdpReply: freeing %p\n", queue->msg);
-        safe_free(queue->msg);
-        debug(49, 3) ("snmpUdpReply: freeing %p\n", queue);
-        safe_free(queue);
+	debug(49, 5) ("snmpUdpReply: FD %d sending %d bytes to %s port %d\n",
+	    fd,
+	    queue->len,
+	    inet_ntoa(queue->address.sin_addr),
+	    ntohs(queue->address.sin_port));
+	x = comm_udp_sendto(fd,
+	    &queue->address,
+	    sizeof(struct sockaddr_in),
+	    queue->msg,
+	    queue->len);
+	if (x < 0) {
+	    if (ignoreErrno(errno))
+		break;		/* don't de-queue */
+	}
+	snmpUdpHead = queue->next;
+	debug(49, 3) ("snmpUdpReply: freeing %p\n", queue->msg);
+	safe_free(queue->msg);
+	debug(49, 3) ("snmpUdpReply: freeing %p\n", queue);
+	safe_free(queue);
     }
     /* Reinstate handler if needed */
     if (snmpUdpHead) {
-        commSetSelect(fd, COMM_SELECT_WRITE, snmpUdpReply, snmpUdpHead, 0);
+	commSetSelect(fd, COMM_SELECT_WRITE, snmpUdpReply, snmpUdpHead, 0);
     }
 }
 
@@ -735,114 +735,112 @@ snmpAppendUdp(snmpUdpData * item)
 {
     item->next = NULL;
     if (snmpUdpHead == NULL) {
-        snmpUdpHead = item;
-        snmpUdpTail = item;
+	snmpUdpHead = item;
+	snmpUdpTail = item;
     } else if (snmpUdpTail == snmpUdpHead) {
-        snmpUdpTail = item;
-        snmpUdpHead->next = item;
+	snmpUdpTail = item;
+	snmpUdpHead->next = item;
     } else {
-        snmpUdpTail->next = item;
-        snmpUdpTail = item;
+	snmpUdpTail->next = item;
+	snmpUdpTail = item;
     }
 
 }
 
 /*
-        Utility functions
-*/
+ * Utility functions
+ */
 
 /*
-        Tree utility functions. 
-*/
+ * Tree utility functions. 
+ */
 
 /*
-        Adds a node to the MIB tree structure and adds the appropriate children
-*/
-mib_tree_entry*
-snmpAddNode(oid *name, int len, oid_ParseFn *parsefunction, int children,  ...)
+ * Adds a node to the MIB tree structure and adds the appropriate children
+ */
+mib_tree_entry *
+snmpAddNode(oid * name, int len, oid_ParseFn * parsefunction, int children,...)
 {
-        va_list args;
-        int loop;
-        mib_tree_entry *entry = NULL;
-
-        debug(49, 6) ("snmpAddNode: Children : %d, Oid : \n", children);
-        snmpDebugOid(6, name, len);
-
-        va_start(args, children);
-        entry = xmalloc(sizeof(mib_tree_entry));
-        entry->name = snmpOidDup(name, len);
-        entry->len = len;
-        entry->parsefunction = parsefunction;
-        entry->children = children;
-
-        if(children > 0){
-                entry->leaves = xmalloc(sizeof(mib_tree_entry*)*children);
-                for(loop = 0;loop < children;loop++){
-                        entry->leaves[loop] = va_arg(args, mib_tree_entry*);
-			entry->leaves[loop]->parent = entry;
-                }
-        }
-        return(entry);
+    va_list args;
+    int loop;
+    mib_tree_entry *entry = NULL;
+
+    debug(49, 6) ("snmpAddNode: Children : %d, Oid : \n", children);
+    snmpDebugOid(6, name, len);
+
+    va_start(args, children);
+    entry = xmalloc(sizeof(mib_tree_entry));
+    entry->name = snmpOidDup(name, len);
+    entry->len = len;
+    entry->parsefunction = parsefunction;
+    entry->children = children;
+
+    if (children > 0) {
+	entry->leaves = xmalloc(sizeof(mib_tree_entry *) * children);
+	for (loop = 0; loop < children; loop++) {
+	    entry->leaves[loop] = va_arg(args, mib_tree_entry *);
+	    entry->leaves[loop]->parent = entry;
+	}
+    }
+    return (entry);
 }
 /* End of tree utility functions */
 
 /* 
-        Returns the list of parameters in an oid[]
-*/
-oid*
-snmpCreateOid(int length, ...)
+ * Returns the list of parameters in an oid[]
+ */
+oid *
+snmpCreateOid(int length,...)
 {
-        va_list args;
-        oid     *new_oid;
-        int     loop;
-
-        va_start(args, length);
-        new_oid = xmalloc(sizeof(oid)*length);
-
-        if(length > 0){
-                for(loop = 0;loop < length;loop++){
-                        new_oid[loop] = va_arg(args, int);
-                }
-        }
-        return(new_oid);
+    va_list args;
+    oid *new_oid;
+    int loop;
+
+    va_start(args, length);
+    new_oid = xmalloc(sizeof(oid) * length);
+
+    if (length > 0) {
+	for (loop = 0; loop < length; loop++) {
+	    new_oid[loop] = va_arg(args, int);
+	}
+    }
+    return (new_oid);
 }
 
 /*
-        Allocate space for, and copy, an OID.  Returns new oid, or NULL.
+ * Allocate space for, and copy, an OID.  Returns new oid, or NULL.
  */
 oid *
 snmpOidDup(oid * A, snint ALen)
 {
     oid *Ans;
- 
-    Ans = (oid *) xmalloc(sizeof(oid) * ALen); 
+
+    Ans = (oid *) xmalloc(sizeof(oid) * ALen);
     if (Ans)
-        memcpy(Ans, A, (sizeof(oid) * ALen));
+	memcpy(Ans, A, (sizeof(oid) * ALen));
     return (Ans);
 }
 
 /*
-        Debug calls, prints out the OID for debugging purposes.
-*/
+ * Debug calls, prints out the OID for debugging purposes.
+ */
 void
 snmpDebugOid(int lvl, oid * Name, snint Len)
-{   
+{
     char mbuf[16], objid[1024];
     int x;
     objid[0] = '\0';
 
     for (x = 0; x < Len; x++) {
-        snprintf(mbuf, sizeof(mbuf), ".%u", (unsigned int) Name[x]);
-        strncat(objid, mbuf, sizeof(objid));
+	snprintf(mbuf, sizeof(mbuf), ".%u", (unsigned int) Name[x]);
+	strncat(objid, mbuf, sizeof(objid));
     }
-    
+
     debug(49, lvl) ("   oid = %s\n", objid);
 }
 
-static void     
+static void
 snmpSnmplibDebug(int lvl, char *buf)
-{           
+{
     debug(49, lvl) ("%s", buf);
-}           
-
-
+}
@@ -1,6 +1,8 @@
 
+
+
 /*
- * $Id: squid.h,v 1.177 1998/08/17 23:00:41 wessels Exp $
+ * $Id: squid.h,v 1.178 1998/11/12 06:28:24 wessels Exp $
  *
  * AUTHOR: Duane Wessels
  *
@@ -222,6 +224,9 @@
 
 /* Make sure syslog goes after stdarg/varargs */
 #ifdef HAVE_SYSLOG_H
+#ifdef _SQUID_AIX_
+#define _XOPEN_EXTENDED_SOURCE
+#endif
 #include <syslog.h>
 #endif
 
@@ -300,6 +305,10 @@ struct rusage {
 #define cbdataAdd(a,b)	cbdataAddDbg(a,b,__FILE__,__LINE__)
 #endif
 
+#if defined(_SQUID_NEXT_) && !defined(S_ISDIR)
+#define S_ISDIR(mode) (((mode) & (_S_IFMT)) == (_S_IFDIR))
+#endif
+
 #ifdef USE_GNUREGEX
 #include "GNUregex.h"
 #elif HAVE_REGEX_H
@@ -1,6 +1,6 @@
 
 /*
- * $Id: stat.cc,v 1.297 1998/10/19 22:37:03 wessels Exp $
+ * $Id: stat.cc,v 1.298 1998/11/12 06:28:25 wessels Exp $
  *
  * DEBUG: section 18    Cache Manager Statistics
  * AUTHOR: Harvest Derived
@@ -1009,6 +1009,8 @@ statCountersDump(StoreEntry * sentry)
 	(int) f->client_http.kbytes_in.kb);
     storeAppendPrintf(sentry, "client_http.kbytes_out = %d\n",
 	(int) f->client_http.kbytes_out.kb);
+    storeAppendPrintf(sentry, "client_http.hit_kbytes_out = %d\n",
+	(int) f->client_http.hit_kbytes_out.kb);
 
     storeAppendPrintf(sentry, "server.all.requests = %d\n",
 	(int) f->server.all.requests);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store.cc,v 1.469 1998/10/16 19:18:16 wessels Exp $
+ * $Id: store.cc,v 1.470 1998/11/12 06:28:27 wessels Exp $
  *
  * DEBUG: section 20    Storage Manager
  * AUTHOR: Harvest Derived
@@ -1007,8 +1007,10 @@ storeFreeMemory(void)
     hashFreeItems(store_table, destroy_StoreEntry);
     hashFreeMemory(store_table);
     store_table = NULL;
+#if USE_CACHE_DIGEST
     if (store_digest)
 	cacheDigestDestroy(store_digest);
+#endif
     store_digest = NULL;
 }
 
@@ -1,5 +1,5 @@
 /*
- * $Id: store_digest.cc,v 1.30 1998/10/19 22:37:04 wessels Exp $
+ * $Id: store_digest.cc,v 1.31 1998/11/12 06:28:28 wessels Exp $
  *
  * DEBUG: section 71    Store Digest Manager
  * AUTHOR: Alex Rousskov
@@ -180,25 +180,60 @@ storeDigestReport(StoreEntry * e)
 
 #if USE_CACHE_DIGESTS
 
+/* should we digest this entry? used by storeDigestAdd() */
+static int
+storeDigestAddable(const StoreEntry * e)
+{
+    /* add some stats! XXX */
+
+    debug(71, 6) ("storeDigestAddable: checking entry, key: %s\n",
+	storeKeyText(e->key));
+
+    /* check various entry flags (mimics storeCheckCachable XXX) */
+    if (!EBIT_TEST(e->flags, ENTRY_CACHABLE)) {
+	debug(71, 6) ("storeDigestAddable: NO: not cachable\n");
+	return 0;
+    }
+    if (EBIT_TEST(e->flags, KEY_PRIVATE)) {
+	debug(71, 6) ("storeDigestAddable: NO: private key\n");
+	return 0;
+    }
+    if (EBIT_TEST(e->flags, ENTRY_NEGCACHED)) {
+	debug(71, 6) ("storeDigestAddable: NO: negative cached\n");
+	return 0;
+    }
+    if (EBIT_TEST(e->flags, RELEASE_REQUEST)) {
+	debug(71, 6) ("storeDigestAddable: NO: release requested\n");
+	return 0;
+    }
+    if (e->store_status == STORE_OK && EBIT_TEST(e->flags, ENTRY_BAD_LENGTH)) {
+	debug(71, 6) ("storeDigestAddable: NO: wrong content-length\n");
+	return 0;
+    }
+    /* do not digest huge objects */
+    if (e->swap_file_sz > Config.Store.maxObjectSize) {
+	debug(71, 6) ("storeDigestAddable: NO: too big\n");
+	return 0;
+    }
+    /* still here? check staleness */
+    /* Note: We should use the time of the next rebuild, not (cur_time+period) */
+    if (refreshCheckDigest(e, StoreDigestRebuildPeriod)) {
+	debug(71, 6) ("storeDigestAdd: entry expires within %d secs, ignoring\n",
+	    StoreDigestRebuildPeriod);
+	return 0;
+    }
+    /* idea: how about also skipping very fresh (thus, potentially unstable) 
+     * entries? Should be configurable through cd_refresh_pattern, of course */
+
+    return 1;
+}
+
 static void
 storeDigestAdd(const StoreEntry * entry)
 {
-    int good_entry = 0;
     assert(entry && store_digest);
-    debug(71, 6) ("storeDigestAdd: checking entry, key: %s\n",
-	storeKeyText(entry->key));
-    /* only public entries are digested */
-    if (!EBIT_TEST(entry->flags, KEY_PRIVATE)) {
-	/* if expires too soon, ignore */
-	/* Note: We should use the time of the next rebuild, not (cur_time+period) */
-	if (refreshCheckDigest(entry, StoreDigestRebuildPeriod)) {
-	    debug(71, 6) ("storeDigestAdd: entry expires within %d secs, ignoring\n",
-		StoreDigestRebuildPeriod);
-	} else {
-	    good_entry = 1;
-	}
-    }
-    if (good_entry) {
+
+    if (storeDigestAddable(entry)) {
 	sd_stats.add_count++;
 	if (cacheDigestTest(store_digest, entry->key))
 	    sd_stats.add_coll_count++;
@@ -1,7 +1,6 @@
 
-
 /*
- * $Id: structs.h,v 1.246 1998/11/11 20:04:20 glenn Exp $
+ * $Id: structs.h,v 1.247 1998/11/12 06:28:29 wessels Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -57,11 +56,6 @@ struct _acl_name_list {
     acl_name_list *next;
 };
 
-struct _acl_proxy_auth {
-    int timeout;		/* timeout value for cached usercode:password entries */
-    hash_table *hash;
-};
-
 struct _acl_proxy_auth_user {
     /* first two items must be same as hash_link */
     char *user;
@@ -259,6 +253,7 @@ struct _SquidConfig {
     int dnsChildren;
     int redirectChildren;
     int authenticateChildren;
+    int authenticateTTL;
     struct {
 	char *host;
 	u_short port;
@@ -341,6 +336,8 @@ struct _SquidConfig {
 	int reload_into_ims;
 #endif
 	int offline;
+	int redir_rewrites_host;
+	int persistent_client_posts;
     } onoff;
     acl *aclList;
     struct {
@@ -407,6 +404,7 @@ struct _SquidConfig {
     } comm_incoming;
     int max_open_disk_fds;
     int uri_whitespace;
+    size_t rangeOffsetLimit;
 };
 
 struct _SquidConfig2 {
@@ -729,6 +727,7 @@ struct _AccessLogEntry {
 	method_t method;
 	int code;
 	const char *content_type;
+	float version;
     } http;
     struct {
 	icp_opcode opcode;
@@ -887,6 +886,7 @@ struct _domain_type {
     domain_type *next;
 };
 
+#if USE_CACHE_DIGESTS
 struct _Version {
     short int current;		/* current version */
     short int required;		/* minimal version that can safely handle current version */
@@ -947,6 +947,8 @@ struct _PeerDigest {
     } stats;
 };
 
+#endif
+
 struct _peer {
     char *host;
     peer_t type;
@@ -1007,7 +1009,9 @@ struct _peer {
 	    unsigned int counting:1;
 	} flags;
     } mcast;
+#if USE_CACHE_DIGESTS
     PeerDigest digest;
+#endif
     int tcp_up;			/* 0 if a connect() fails */
     time_t last_fail_time;
     struct in_addr addresses[10];
@@ -1022,6 +1026,7 @@ struct _peer {
 	float load_factor;
     } carp;
 #endif
+    char *login;		/* Proxy authorization */
 };
 
 struct _net_db_name {
@@ -1073,7 +1078,6 @@ struct _ps_state {
      */
     struct sockaddr_in first_parent_miss;
     struct sockaddr_in closest_parent_miss;
-    struct sockaddr_in single_parent;
     ping_data ping;
     aclCheck_t *acl_checklist;
 };
@@ -1234,6 +1238,8 @@ struct _request_flags {
 #if HTTP_VIOLATIONS
     unsigned int nocache_hack:1;	/* for changing/ignoring no-cache requests */
 #endif
+    unsigned int accelerated:1;
+    unsigned int internal:1;
 };
 
 struct _request_t {
@@ -1263,6 +1269,7 @@ struct _request_t {
 #if DELAY_POOLS
     delay_id delay_id;
 #endif
+    char *peer_login;		/* Configured peer login:password */
 };
 
 struct _cachemgr_passwd {
@@ -1400,7 +1407,9 @@ struct _StatCounters {
 	kb_t memory;
 	int msgs_sent;
 	int msgs_recv;
+#if USE_CACHE_DIGESTS
 	cd_guess_stats guess;
+#endif
 	StatHist on_xition_count;
     } cd;
     struct {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: typedefs.h,v 1.81 1998/11/11 20:04:21 glenn Exp $
+ * $Id: typedefs.h,v 1.82 1998/11/12 06:28:30 wessels Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -204,7 +204,7 @@ typedef void StatHistBinDumper(StoreEntry *, int idx, double val, double size, i
 /* append/vprintf's for Packer */
 typedef void (*append_f) (void *, const char *buf, int size);
 #ifdef __STDC__
-typedef void (*vprintf_f) (void *, const char *fmt,...);
+typedef void (*vprintf_f) (void *, const char *fmt, va_list args);
 #else
 typedef void (*vprintf_f) ();
 #endif