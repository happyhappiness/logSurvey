----++++src/HttpRequest.cc
@@ -44,13 +44,13 @@ HttpRequest::HttpRequest() :
     init();
 }
 
-HttpRequest::HttpRequest(const HttpRequestMethod&amp; aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath) :
+HttpRequest::HttpRequest(const HttpRequestMethod&amp; aMethod, AnyP::ProtocolType aProtocol, const char *aSchemeImg, const char *aUrlpath) :
     HttpMsg(hoRequest)
 {
     static unsigned int id = 1;
     debugs(93,7, HERE &lt;&lt; &quot;constructed, this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; ++id);
     init();
-    initHTTP(aMethod, aProtocol, aUrlpath);
+    initHTTP(aMethod, aProtocol, aSchemeImg, aUrlpath);
 }
 
 HttpRequest::~HttpRequest()
@@ -60,10 +60,10 @@ HttpRequest::~HttpRequest()
 }
 
 void
-HttpRequest::initHTTP(const HttpRequestMethod&amp; aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath)
+HttpRequest::initHTTP(const HttpRequestMethod&amp; aMethod, AnyP::ProtocolType aProtocol, const char *aSchemeImg, const char *aUrlpath)
 {
     method = aMethod;
-    url.setScheme(aProtocol);
+    url.setScheme(aProtocol, aSchemeImg);
     url.path(aUrlpath);
 }
 
@@ -180,11 +180,7 @@ HttpRequest::clone() const
     copy-&gt;pstate = pstate; // TODO: should we assert a specific state here?
     copy-&gt;body_pipe = body_pipe;
 
-    copy-&gt;url.setScheme(url.getScheme());
-    copy-&gt;url.userInfo(url.userInfo());
-    copy-&gt;url.host(url.host());
-    copy-&gt;url.port(url.port());
-    copy-&gt;url.path(url.path());
+    copy-&gt;url = url;
 
     // range handled in hdrCacheInit()
     copy-&gt;ims = ims;
----++++src/HttpRequest.h
@@ -49,11 +49,11 @@ class HttpRequest: public HttpMsg
     typedef RefCount&lt;HttpRequest&gt; Pointer;
 
     HttpRequest();
-    HttpRequest(const HttpRequestMethod&amp; aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath);
+    HttpRequest(const HttpRequestMethod&amp; aMethod, AnyP::ProtocolType aProtocol, const char *schemeImage, const char *aUrlpath);
     ~HttpRequest();
     virtual void reset();
 
-    void initHTTP(const HttpRequestMethod&amp; aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath);
+    void initHTTP(const HttpRequestMethod&amp; aMethod, AnyP::ProtocolType aProtocol, const char *schemeImage, const char *aUrlpath);
 
     virtual HttpRequest *clone() const;
 
----++++src/PeerPoolMgr.cc
@@ -61,7 +61,7 @@ PeerPoolMgr::start()
 
     // ErrorState, getOutgoingAddress(), and other APIs may require a request.
     // We fake one. TODO: Optionally send this request to peers?
-    request = new HttpRequest(Http::METHOD_OPTIONS, AnyP::PROTO_HTTP, "*");
+    request = new HttpRequest(Http::METHOD_OPTIONS, AnyP::PROTO_HTTP, "http", "*");
     request-&gt;url.host(peer-&gt;host);
 
     checkpoint(&quot;peer initialized&quot;);
----++++src/URL.h
@@ -28,6 +28,20 @@ class URL
 public:
     URL() : hostIsNumeric_(false), port_(0) {*host_=0;}
     URL(AnyP::UriScheme const &amp;aScheme);
+    URL(const URL &amp;other) {
+        this-&gt;operator =(other);
+    }
+    URL &amp;operator =(const URL &amp;o) {
+        scheme_ = o.scheme_;
+        userInfo_ = o.userInfo_;
+        memcpy(host_, o.host_, sizeof(host_));
+        hostIsNumeric_ = o.hostIsNumeric_;
+        hostAddr_ = o.hostAddr_;
+        port_ = o.port_;
+        path_ = o.path_;
+        touch();
+        return *this;
+    }
 
     void clear() {
         scheme_=AnyP::PROTO_NONE;
@@ -42,7 +56,10 @@ class URL
     AnyP::UriScheme const &amp; getScheme() const {return scheme_;}
 
     /// convert the URL scheme to that given
-    void setScheme(const AnyP::ProtocolType &amp;p) {scheme_=p; touch();}
+    void setScheme(const AnyP::ProtocolType &amp;p, const char *str) {
+        scheme_ = AnyP::UriScheme(p, str);
+        touch();
+    }
 
     void userInfo(const SBuf &amp;s) {userInfo_=s; touch();}
     const SBuf &amp;userInfo() const {return userInfo_;}
@@ -131,9 +148,17 @@ class URL
 inline std::ostream &amp;
 operator &lt;&lt;(std::ostream &amp;os, const URL &amp;url)
 {
-    if (const char *sc = url.getScheme().c_str())
-        os &lt;&lt; sc &lt;&lt; &quot;:&quot;;
-    os &lt;&lt; &quot;//&quot; &lt;&lt; url.authority() &lt;&lt; url.path();
+    // none means explicit empty string for scheme.
+    if (url.getScheme() != AnyP::PROTO_NONE)
+        os &lt;&lt; url.getScheme().image();
+    os &lt;&lt; &quot;:&quot;;
+
+    // no authority section on URN
+    if (url.getScheme() != AnyP::PROTO_URN)
+        os &lt;&lt; &quot;//&quot; &lt;&lt; url.authority();
+
+    // path is what it is - including absent
+    os &lt;&lt; url.path();
     return os;
 }
 
----++++src/anyp/UriScheme.cc
@@ -11,22 +11,24 @@
 #include &quot;squid.h&quot;
 #include &quot;anyp/UriScheme.h&quot;
 
-char const *
-AnyP::UriScheme::c_str() const
+AnyP::UriScheme::UriScheme(AnyP::ProtocolType const aScheme, const char *img) :
+    theScheme_(aScheme)
 {
-    if (theScheme_ == AnyP::PROTO_UNKNOWN)
-        return &quot;(unknown)&quot;;
-
-    static char out[BUFSIZ];
-    int p = 0;
-
-    if (theScheme_ &gt; AnyP::PROTO_NONE &amp;&amp; theScheme_ &lt; AnyP::PROTO_MAX) {
-        const char *in = AnyP::ProtocolType_str[theScheme_];
-        for (; p &lt; (BUFSIZ-1) &amp;&amp; in[p] != &#39;\0&#39;; ++p)
-            out[p] = xtolower(in[p]);
+    if (img)
+        // image could be provided explicitly (case-sensitive)
+        image_ = img;
+
+    else if (theScheme_ == AnyP::PROTO_UNKNOWN)
+        // image could be actually unknown and not provided
+        image_ = &quot;(unknown)&quot;;
+
+    else if (theScheme_ &gt; AnyP::PROTO_NONE &amp;&amp; theScheme_ &lt; AnyP::PROTO_MAX) {
+        // image could be implied by a registered transfer protocol
+        // which use upper-case labels, so down-case for scheme image
+        image_ = AnyP::ProtocolType_str[theScheme_];
+        image_.toLower();
     }
-    out[p] = &#39;\0&#39;;
-    return out;
+    // else, image is an empty string (&quot;://example.com/&quot;)
 }
 
 unsigned short
----++++src/anyp/UriScheme.h
@@ -10,6 +10,7 @@
 #define SQUID_ANYP_URISCHEME_H
 
 #include &quot;anyp/ProtocolType.h&quot;
+#include &quot;sbuf/SBuf.h&quot;
 
 #include &lt;iosfwd&gt;
 
@@ -23,35 +24,43 @@ class UriScheme
 {
 public:
     UriScheme() : theScheme_(AnyP::PROTO_NONE) {}
-    UriScheme(AnyP::ProtocolType const aScheme) : theScheme_(aScheme) {}
+    UriScheme(AnyP::ProtocolType const aScheme, const char *img = nullptr);
+    UriScheme(const AnyP::UriScheme &amp;o) : theScheme_(o.theScheme_), image_(o.image_) {}
+    UriScheme(AnyP::UriScheme &amp;&amp;) = default;
     ~UriScheme() {}
 
-    operator AnyP::ProtocolType() const { return theScheme_; }
+    AnyP::UriScheme&amp; operator=(const AnyP::UriScheme &amp;o) {
+        theScheme_ = o.theScheme_;
+        image_ = o.image_;
+        return *this;
+    }
+    AnyP::UriScheme&amp; operator=(AnyP::UriScheme &amp;&amp;) = default;
 
+    operator AnyP::ProtocolType() const { return theScheme_; }
+    // XXX: does not account for comparison of unknown schemes (by image)
     bool operator != (AnyP::ProtocolType const &amp; aProtocol) const { return theScheme_ != aProtocol; }
 
     /** Get a char string representation of the scheme.
-     * Does not include the &#39;:&#39; or &#39;://&quot; terminators.
-     *
-     * An upper bound length of BUFSIZ bytes converted. Remainder will be truncated.
-     * The result of this call will remain usable only until any subsequest call
-     * and must be copied if persistence is needed.
+     * Does not include the &#39;:&#39; or &quot;://&quot; terminators.
      */
-    char const *c_str() const;
+    SBuf image() const {return image_;}
 
     unsigned short defaultPort() const;
 
 private:
     /// This is a typecode pointer into the enum/registry of protocols handled.
     AnyP::ProtocolType theScheme_;
+
+    /// the string representation
+    SBuf image_;
 };
 
 } // namespace AnyP
 
 inline std::ostream &amp;
 operator &lt;&lt; (std::ostream &amp;os, AnyP::UriScheme const &amp;scheme)
 {
-    os &lt;&lt; scheme.c_str();
+    os &lt;&lt; scheme.image();
     return os;
 }
 
----++++src/cache_cf.cc
@@ -3381,7 +3381,7 @@ parsePortSpecification(const AnyP::PortCfgPointer &amp;s, char *token)
     s-&gt;name = xstrdup(token);
     s-&gt;connection_auth_disabled = false;
 
-    const char *portType = AnyP::UriScheme(s-&gt;transport.protocol).c_str();
+    const SBuf &amp;portType = AnyP::UriScheme(s-&gt;transport.protocol).image();
 
     if (*token == &#39;[&#39;) {
         /* [ipv6]:port */
@@ -3780,7 +3780,7 @@ parsePortCfg(AnyP::PortCfgPointer *head, const char *optionName)
         // clone the port options from *s to *(s-&gt;next)
         s-&gt;next = s-&gt;clone();
         s-&gt;next-&gt;s.setIPv4();
-        debugs(3, 3, AnyP::UriScheme(s-&gt;transport.protocol).c_str() &lt;&lt; "_port: clone wildcard address for split-stack: " &lt;&lt; s-&gt;s &lt;&lt; " and " &lt;&lt; s-&gt;next-&gt;s);
+        debugs(3, 3, AnyP::UriScheme(s-&gt;transport.protocol).image() &lt;&lt; "_port: clone wildcard address for split-stack: " &lt;&lt; s-&gt;s &lt;&lt; " and " &lt;&lt; s-&gt;next-&gt;s);
     }
 
     while (*head != NULL)
@@ -3824,7 +3824,7 @@ dump_generic_port(StoreEntry * e, const char *n, const AnyP::PortCfgPointer &amp;s)
 
         // TODO: compare against prefix of &#39;n&#39; instead of assuming http_port
         if (s-&gt;transport.protocol != AnyP::PROTO_HTTP)
-            storeAppendPrintf(e, " protocol=%s", AnyP::UriScheme(s-&gt;transport.protocol).c_str());
+            storeAppendPrintf(e, " protocol=%s", AnyP::ProtocolType_str[s-&gt;transport.protocol]);
 
         if (s-&gt;allow_direct)
             storeAppendPrintf(e, &quot; allow-direct&quot;);
----++++src/carp.cc
@@ -167,7 +167,7 @@ carpSelectParent(HttpRequest * request)
             // this code follows URI syntax pattern.
             // corner cases should use the full effective request URI
             if (tp-&gt;options.carp_key.scheme) {
-                key.append(request-&gt;url.getScheme().c_str());
+                key.append(request-&gt;url.getScheme().image());
                 if (key.length()) //if the scheme is not empty
                     key.append(&quot;://&quot;);
             }
----++++src/client_side.cc
@@ -1221,7 +1221,8 @@ prepareAcceleratedURL(ConnStateData * conn, ClientHttpRequest *http, const Http1
         } // else nothing to alter port-wise.
         const int url_sz = hp-&gt;requestUri().length() + 32 + Config.appendDomainLen + strlen(host);
         http-&gt;uri = (char *)xcalloc(url_sz, 1);
-        snprintf(http-&gt;uri, url_sz, &quot;%s://%s&quot; SQUIDSBUFPH, AnyP::UriScheme(conn-&gt;transferProtocol.protocol).c_str(), host, SQUIDSBUFPRINT(url));
+        const SBuf &amp;scheme = AnyP::UriScheme(conn-&gt;transferProtocol.protocol).image();
+        snprintf(http-&gt;uri, url_sz, SQUIDSBUFPH &quot;://%s&quot; SQUIDSBUFPH, SQUIDSBUFPRINT(scheme), host, SQUIDSBUFPRINT(url));
         debugs(33, 5, &quot;ACCEL VHOST REWRITE: &quot; &lt;&lt; http-&gt;uri);
     } else if (conn-&gt;port-&gt;defaultsite /* &amp;&amp; !vhost */) {
         debugs(33, 5, &quot;ACCEL DEFAULTSITE REWRITE: defaultsite=&quot; &lt;&lt; conn-&gt;port-&gt;defaultsite &lt;&lt; &quot; + vport=&quot; &lt;&lt; vport);
@@ -1233,18 +1234,19 @@ prepareAcceleratedURL(ConnStateData * conn, ClientHttpRequest *http, const Http1
         if (vport &gt; 0) {
             snprintf(vportStr, sizeof(vportStr),&quot;:%d&quot;,vport);
         }
-        snprintf(http-&gt;uri, url_sz, &quot;%s://%s%s&quot; SQUIDSBUFPH,
-                 AnyP::UriScheme(conn-&gt;transferProtocol.protocol).c_str(), conn-&gt;port-&gt;defaultsite, vportStr, SQUIDSBUFPRINT(url));
+        const SBuf &amp;scheme = AnyP::UriScheme(conn-&gt;transferProtocol.protocol).image();
+        snprintf(http-&gt;uri, url_sz, SQUIDSBUFPH &quot;://%s%s&quot; SQUIDSBUFPH,
+                 SQUIDSBUFPRINT(scheme), conn-&gt;port-&gt;defaultsite, vportStr, SQUIDSBUFPRINT(url));
         debugs(33, 5, &quot;ACCEL DEFAULTSITE REWRITE: &quot; &lt;&lt; http-&gt;uri);
     } else if (vport &gt; 0 /* &amp;&amp; (!vhost || no Host:) */) {
         debugs(33, 5, &quot;ACCEL VPORT REWRITE: *_port IP + vport=&quot; &lt;&lt; vport);
         /* Put the local socket IP address as the hostname, with whatever vport we found  */
         const int url_sz = hp-&gt;requestUri().length() + 32 + Config.appendDomainLen;
         http-&gt;uri = (char *)xcalloc(url_sz, 1);
         http-&gt;getConn()-&gt;clientConnection-&gt;local.toHostStr(ipbuf,MAX_IPSTRLEN);
-        snprintf(http-&gt;uri, url_sz, "%s://%s:%d" SQUIDSBUFPH,
-                 AnyP::UriScheme(conn-&gt;transferProtocol.protocol).c_str(),
-                 ipbuf, vport, SQUIDSBUFPRINT(url));
+        const SBuf &amp;scheme = AnyP::UriScheme(conn-&gt;transferProtocol.protocol).image();
+        snprintf(http-&gt;uri, url_sz, SQUIDSBUFPH "://%s:%d" SQUIDSBUFPH,
+                 SQUIDSBUFPRINT(scheme), ipbuf, vport, SQUIDSBUFPRINT(url));
         debugs(33, 5, &quot;ACCEL VPORT REWRITE: &quot; &lt;&lt; http-&gt;uri);
     }
 }
@@ -1262,17 +1264,19 @@ prepareTransparentURL(ConnStateData * conn, ClientHttpRequest *http, const Http1
         const int url_sz = hp-&gt;requestUri().length() + 32 + Config.appendDomainLen +
                            strlen(host);
         http-&gt;uri = (char *)xcalloc(url_sz, 1);
-        snprintf(http-&gt;uri, url_sz, &quot;%s://%s&quot; SQUIDSBUFPH,
-                 AnyP::UriScheme(conn-&gt;transferProtocol.protocol).c_str(), host, SQUIDSBUFPRINT(hp-&gt;requestUri()));
+        const SBuf &amp;scheme = AnyP::UriScheme(conn-&gt;transferProtocol.protocol).image();
+        snprintf(http-&gt;uri, url_sz, SQUIDSBUFPH &quot;://%s&quot; SQUIDSBUFPH,
+                 SQUIDSBUFPRINT(scheme), host, SQUIDSBUFPRINT(hp-&gt;requestUri()));
         debugs(33, 5, &quot;TRANSPARENT HOST REWRITE: &quot; &lt;&lt; http-&gt;uri);
     } else {
         /* Put the local socket IP address as the hostname.  */
         const int url_sz = hp-&gt;requestUri().length() + 32 + Config.appendDomainLen;
         http-&gt;uri = (char *)xcalloc(url_sz, 1);
         static char ipbuf[MAX_IPSTRLEN];
         http-&gt;getConn()-&gt;clientConnection-&gt;local.toHostStr(ipbuf,MAX_IPSTRLEN);
-        snprintf(http-&gt;uri, url_sz, &quot;%s://%s:%d&quot; SQUIDSBUFPH,
-                 AnyP::UriScheme(http-&gt;getConn()-&gt;transferProtocol.protocol).c_str(),
+        const SBuf &amp;scheme = AnyP::UriScheme(http-&gt;getConn()-&gt;transferProtocol.protocol).image();
+        snprintf(http-&gt;uri, url_sz, SQUIDSBUFPH &quot;://%s:%d&quot; SQUIDSBUFPH,
+                 SQUIDSBUFPRINT(scheme),
                  ipbuf, http-&gt;getConn()-&gt;clientConnection-&gt;local.port(), SQUIDSBUFPRINT(hp-&gt;requestUri()));
         debugs(33, 5, &quot;TRANSPARENT REWRITE: &quot; &lt;&lt; http-&gt;uri);
     }
@@ -1679,7 +1683,7 @@ clientProcessRequest(ConnStateData *conn, const Http1::RequestParserPointer &amp;hp,
             http-&gt;flags.internal = true;
         } else if (Config.onoff.global_internal_static &amp;&amp; internalStaticCheck(request-&gt;url.path())) {
             debugs(33, 2, &quot;internal URL found: &quot; &lt;&lt; request-&gt;url.getScheme() &lt;&lt; &quot;://&quot; &lt;&lt; request-&gt;url.authority(true) &lt;&lt; &quot; (global_internal_static on)&quot;);
-            request-&gt;url.setScheme(AnyP::PROTO_HTTP);
+            request-&gt;url.setScheme(AnyP::PROTO_HTTP, "http");
             request-&gt;url.host(internalHostname());
             request-&gt;url.port(getMyPort());
             http-&gt;flags.internal = true;
@@ -3445,7 +3449,7 @@ static void
 clientHttpConnectionsOpen(void)
 {
     for (AnyP::PortCfgPointer s = HttpPortList; s != NULL; s = s-&gt;next) {
-        const char *scheme = AnyP::UriScheme(s-&gt;transport.protocol).c_str();
+        const SBuf &amp;scheme = AnyP::UriScheme(s-&gt;transport.protocol).image();
 
         if (MAXTCPLISTENPORTS == NHttpSockets) {
             debugs(1, DBG_IMPORTANT, &quot;WARNING: You have too many &#39;&quot; &lt;&lt; scheme &lt;&lt; &quot;_port&#39; lines.&quot;);
----++++src/client_side_reply.cc
@@ -2259,7 +2259,7 @@ clientReplyContext::createStoreEntry(const HttpRequestMethod&amp; m, RequestFlags re
      */
 
     if (http-&gt;request == NULL) {
-        http-&gt;request = new HttpRequest(m, AnyP::PROTO_NONE, null_string);
+        http-&gt;request = new HttpRequest(m, AnyP::PROTO_NONE, "http", null_string);
         HTTPMSGLOCK(http-&gt;request);
     }
 
----++++src/errorpage.cc
@@ -946,7 +946,8 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
 
     case &#39;P&#39;:
         if (request) {
-            p = request-&gt;url.getScheme().c_str();
+            const SBuf &amp;m = request-&gt;url.getScheme().image();
+            mb.append(m.rawContent(), m.length());
         } else if (!building_deny_info_url) {
             p = &quot;[unknown protocol]&quot;;
         }
----++++src/format/Format.cc
@@ -996,7 +996,9 @@ Format::Format::assemble(MemBuf &amp;mb, const AccessLogEntry::Pointer &amp;al, int logS
 
         case LFT_CLIENT_REQ_URLSCHEME:
             if (al-&gt;request) {
-                out = al-&gt;request-&gt;url.getScheme().c_str();
+                const SBuf s(al-&gt;request-&gt;url.getScheme().image());
+                sb.append(s.rawContent(), s.length());
+                out = sb.termedBuf();
                 quote = 1;
             }
             break;
@@ -1075,7 +1077,9 @@ Format::Format::assemble(MemBuf &amp;mb, const AccessLogEntry::Pointer &amp;al, int logS
 
         case LFT_SERVER_REQ_URLSCHEME:
             if (al-&gt;adapted_request) {
-                out = al-&gt;adapted_request-&gt;url.getScheme().c_str();
+                const SBuf s(al-&gt;adapted_request-&gt;url.getScheme().image());
+                sb.append(s.rawContent(), s.length());
+                out = sb.termedBuf();
                 quote = 1;
             }
             break;
----++++src/tests/stub_HttpRequest.cc
@@ -16,10 +16,10 @@
 // void httpRequestPack(void *obj, Packable *p);
 
 HttpRequest::HttpRequest() : HttpMsg(hoRequest) {STUB}
-HttpRequest::HttpRequest(const HttpRequestMethod &amp;, AnyP::ProtocolType, const char *) : HttpMsg(hoRequest) {STUB}
+HttpRequest::HttpRequest(const HttpRequestMethod &amp;, AnyP::ProtocolType, const char *, const char *) : HttpMsg(hoRequest) {STUB}
 HttpRequest::~HttpRequest() STUB
 void HttpRequest::reset() STUB
-void HttpRequest::initHTTP(const HttpRequestMethod &amp;, AnyP::ProtocolType, const char *) STUB
+void HttpRequest::initHTTP(const HttpRequestMethod &amp;, AnyP::ProtocolType, const char *, const char *) STUB
 HttpRequest * HttpRequest::clone() const STUB_RETVAL(NULL)
 bool HttpRequest::maybeCacheable() STUB_RETVAL(false)
 bool HttpRequest::conditional() const STUB_RETVAL(false)
----++++src/tests/testUriScheme.cc
@@ -112,9 +112,9 @@ testUriScheme::testConstructprotocol_t()
 void
 testUriScheme::testC_str()
 {
-    String lhs("wais");
+    SBuf lhs("wais");
     AnyP::UriScheme wais(AnyP::PROTO_WAIS);
-    String rhs(wais.c_str());
+    SBuf rhs(wais.image());
     CPPUNIT_ASSERT_EQUAL(lhs, rhs);
 }
 
----++++GitHub