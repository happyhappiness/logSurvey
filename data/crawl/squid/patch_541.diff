@@ -262,6 +262,7 @@ dnl checks the maximum number of filedescriptor we can open
 dnl sets shell var squid_filedescriptors_num
 
 AC_DEFUN([SQUID_CHECK_MAXFD],[
+AC_CHECK_FUNCS(setrlimit)
 AC_MSG_CHECKING(Maximum number of filedescriptors we can open)
 dnl damn! FreeBSD pthreads break dup2().
 SQUID_STATE_SAVE(maxfd)
@@ -3177,7 +3177,6 @@ AC_CHECK_FUNCS(\
 	seteuid \
 	setgroups \
 	setpgrp \
-	setrlimit \
 	setsid \
 	sigaction \
 	snprintf \
@@ -899,9 +899,13 @@ logformat icap_squid %ts.%03tu %6icap::tr %>a %icap::to/%03icap::Hs %icap::<size
         RFC2475, and RFC3260.
 
         The TOS/DSCP byte must be exactly that - octet value 0x00-0xFF.
-        Note that in practice often only values up to 0x3F are usable
-        as the two highest bits have been redefined for use by ECN
-        (RFC3168).
+        Note that in practice often only multiples of 4 is usable as the
+        two rightmost bits have been redefined for use by ECN (RFC 3168
+        section 23.1).
+
+        Note that in practice often only values up to 0xFC are usable,
+        and only in multiple of 4, as the two rightmost bits have been
+        redefined for use by ECN (RFC3168).
 
         This setting is configured by setting the source TOS values:
 
@@ -82,6 +82,10 @@ This directive is optional.
 .if !'po4a'hide' .BI "port " portnumber
 Specifies the port number or service name where the helper should connect.
 .
+.if !'po4a'hide' .TP
+.if !'po4a'hide' .BI "timeout " seconds
+Specifies the RADIUS request timeout.
+.
 .SH AUTHOR
 This program is written by 
 .if !'po4a'hide' .I Marc van Selm <selm@cistron.nl>
@@ -116,7 +116,7 @@ static int nasport = 111;
 static int nasporttype = 0;
 static uint32_t nas_ipaddr;
 static uint32_t auth_ipaddr;
-static int retries = 30;
+static int retries = 10;
 
 char progname[] = "basic_radius_auth";
 
@@ -249,6 +249,8 @@ rad_auth_config(const char *cfname)
             sscanf(line, "service %s", svc_name);
         if (!memcmp(line, "port", 4))
             sscanf(line, "port %s", svc_name);
+        if (!memcmp(line, "timeout", 7))
+            sscanf(line, "timeout %d", &retries);
     }
     fclose(cf);
     if (srv && crt)
@@ -280,7 +282,7 @@ urldecode(char *dst, const char *src, int size)
     *dst = '\0';
 }
 
-static int
+static void
 authenticate(int socket_fd, const char *username, const char *passwd)
 {
     AUTH_HDR *auth;
@@ -445,16 +447,20 @@ authenticate(int socket_fd, const char *username, const char *passwd)
                 continue;
 
             rc = result_recv(saremote.sin_addr.s_addr, saremote.sin_port, recv_buffer, len);
-            if (rc == 0)
-                return 1;
-            if (rc == 1)
-                return 0;
+            if (rc == 0) {
+                SEND_OK("");
+                return;
+            }
+            if (rc == 1) {
+                SEND_ERR("");
+                return;
+            }
         }
     }
 
     fprintf(stderr, "%s: No response from RADIUS server\n", progname);
-
-    return 0;
+    SEND_ERR("No response from RADIUS server");
+    return;
 }
 
 int
@@ -596,10 +602,7 @@ main(int argc, char **argv)
             ++ptr;
         urldecode(passwd, ptr, MAXPASS);
 
-        if (authenticate(sockfd, username, passwd))
-            SEND_OK("");
-        else
-            SEND_ERR("");
+        authenticate(sockfd, username, passwd);
     }
     close(sockfd);
     exit(1);
@@ -31,8 +31,6 @@
 #ifndef SQUID_RANGE_H
 #define SQUID_RANGE_H
 
-#include "Debug.h"
-
 #if HAVE_IOSFWD
 #include <iosfwd>
 #endif
@@ -65,8 +65,11 @@ CpuAffinitySet::undo()
 }
 
 bool
-CpuAffinitySet::applied() const
+CpuAffinitySet::applied()
 {
+    // NOTE: cannot be const.
+    // According to CPU_SET(3) and, apparently, on some systems (e.g.,
+    // OpenSuSE 10.3) CPU_COUNT macro expects a non-const argument.
     return (CPU_COUNT(&theOrigCpuSet) > 0);
 }
 
@@ -19,7 +19,7 @@ class CpuAffinitySet
     void undo();
 
     /// whether apply() was called and was not undone
-    bool applied() const;
+    bool applied();
 
     /// set CPU affinity mask
     void set(const cpu_set_t &aCpuSet);
@@ -305,5 +305,4 @@ HttpHeader::chunked() const
 extern void httpHeaderInitModule(void);
 extern void httpHeaderCleanModule(void);
 
-
 #endif /* SQUID_HTTPHEADER_H */
@@ -181,8 +181,6 @@ httpHeaderHasConnDir(const HttpHeader * hdr, const char *directive)
     return res;
 }
 
-
-
 /** handy to printf prefixes of potentially very long buffers */
 const char *
 getStringPrefix(const char *str, const char *end)
@@ -112,5 +112,4 @@ extern const char *getStringPrefix(const char *str, const char *end);
 
 extern void httpHdrMangleList(HttpHeader *, HttpRequest *, int req_or_rep);
 
-
 #endif
@@ -44,8 +44,4 @@ extern pid_t ipcCreate(int type,
                              int *wfd,
                              void **hIpc);
 
-
-
-
-
 #endif /* SQUID_SQUIDIPC_H_ */
@@ -125,13 +125,11 @@ class store_client
     CBDATA_CLASS(store_client);
 };
 
-
 extern void storeClientCopy(store_client *, StoreEntry *, StoreIOBuffer, STCB *, void *);
 extern store_client* storeClientListAdd(StoreEntry * e, void *data);
 extern int storeClientCopyPending(store_client *, StoreEntry * e, void *data);
 extern int storeUnregister(store_client * sc, StoreEntry * e, void *data);
 extern int storePendingNClients(const StoreEntry * e);
 extern int storeClientIsThisAClient(store_client * sc, void *someClient);
 
-
 #endif /* SQUID_STORECLIENT_H */
@@ -47,7 +47,4 @@ inline void WIN32_InstallService(void) {} /* NOP */
 inline  void WIN32_RemoveService(void) {} /* NOP */
 #endif /* _SQUID_WINDOWS_ */
 
-
-
-
 #endif /* WINSVC_H_ */
@@ -86,6 +86,8 @@ ACLFilledChecklist::conn() const
 void
 ACLFilledChecklist::conn(ConnStateData *aConn)
 {
+    if (conn() == aConn)
+        return;
     assert (conn() == NULL);
     conn_ = cbdataReference(aConn);
 }
@@ -181,6 +183,9 @@ ACLFilledChecklist::ACLFilledChecklist(const acl_access *A, HttpRequest *http_re
 #endif /* FOLLOW_X_FORWARDED_FOR */
             src_addr = request->client_addr;
         my_addr = request->my_addr;
+
+        if (request->clientConnectionManager.valid())
+            conn(request->clientConnectionManager.get());
     }
 
 #if USE_IDENT
@@ -2,6 +2,7 @@
 #include "adaptation/Config.h"
 #include "adaptation/History.h"
 #include "base/TextException.h"
+#include "Debug.h"
 #include "globals.h"
 #include "SquidTime.h"
 
@@ -96,20 +96,6 @@ AnyP::PortCfg::clone() const
 #if USE_SSL
 void AnyP::PortCfg::configureSslServerContext()
 {
-    staticSslContext.reset(
-        sslCreateServerContext(cert, key,
-                               version, cipher, options, sslflags, clientca,
-                               cafile, capath, crlfile, dhfile,
-                               sslContextSessionId));
-
-    if (!staticSslContext) {
-        char buf[128];
-        fatalf("%s_port %s initialization error", protocol,  s.ToURL(buf, sizeof(buf)));
-    }
-
-    if (!sslBump)
-        return;
-
     if (cert)
         Ssl::readCertChainAndPrivateKeyFromFiles(signingCert, signPkey, certsToChain, cert, key);
 
@@ -128,6 +114,35 @@ void AnyP::PortCfg::configureSslServerContext()
         char buf[128];
         fatalf("Unable to generate  signing SSL certificate for untrusted sites for %s_port %s", protocol, s.ToURL(buf, sizeof(buf)));
     }
+
+    if (crlfile)
+        clientVerifyCrls.reset(Ssl::loadCrl(crlfile, sslContextFlags));
+
+    if (clientca) {
+        clientCA.reset(SSL_load_client_CA_file(clientca));
+        if (clientCA.get() == NULL) {
+            fatalf("Unable to read client CAs! from %s", clientca);
+        }
+    }
+
+    contextMethod = Ssl::contextMethod(version);
+    if (!contextMethod)
+        fatalf("Unable to compute context method to use");
+
+    if (dhfile)
+        dhParams.reset(Ssl::readDHParams(dhfile));
+
+    if (sslflags)
+        sslContextFlags = Ssl::parse_flags(sslflags);
+
+    sslOptions = Ssl::parse_options(options);
+
+    staticSslContext.reset(sslCreateServerContext(*this));
+
+    if (!staticSslContext) {
+        char buf[128];
+        fatalf("%s_port %s initialization error", protocol,  s.ToURL(buf, sizeof(buf)));
+    }
 }
 #endif
 
@@ -76,6 +76,13 @@ struct PortCfg {
     Ssl::X509_STACK_Pointer certsToChain; ///<  x509 certificates to send with the generated cert
     Ssl::X509_Pointer untrustedSigningCert; ///< x509 certificate for signing untrusted generated certificates
     Ssl::EVP_PKEY_Pointer untrustedSignPkey; ///< private key for signing untrusted generated certificates
+
+    Ssl::X509_CRL_STACK_Pointer clientVerifyCrls; ///< additional CRL lists to use when verifying the client certificate
+    Ssl::X509_NAME_STACK_Pointer clientCA; ///< CA certificates to use when verifying client certificates
+    Ssl::DH_Pointer dhParams; ///< DH parameters for temporary/ephemeral DH key exchanges
+    Ssl::ContextMethod contextMethod; ///< The context method (SSL_METHOD) to use when creating certificates
+    long sslContextFlags; ///< flags modifying the use of SSL
+    long sslOptions; ///< SSL engine options
 #endif
 
     CBDATA_CLASS2(PortCfg); // namespaced
@@ -47,7 +47,7 @@
 #include "mgr/Forwarder.h"
 #include "mgr/FunAction.h"
 #include "mgr/QueryParams.h"
-#include "protos.h" /* rotate_logs() */
+#include "protos.h"
 #include "tools.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
@@ -123,6 +123,12 @@ DOC_START
 	Remove this line. Configure FTP page display using the CSS controls in errorpages.css instead.
 DOC_END
 
+NAME: maximum_single_addr_tries
+TYPE: obsolete
+DOC_START
+	Replaced by connect_retries. The behaviour has changed, please read the documentation before altering.
+DOC_END
+
 NAME: url_rewrite_concurrency
 TYPE: obsolete
 DOC_START
@@ -3700,7 +3700,7 @@ ConnStateData::sslCrtdHandleReply(const char * reply)
                 debugs(33, 5, HERE << "Certificate for " << sslConnectHostOrIp << " cannot be generated. ssl_crtd response: " << reply_message.getBody());
             } else {
                 debugs(33, 5, HERE << "Certificate for " << sslConnectHostOrIp << " was successfully recieved from ssl_crtd");
-                SSL_CTX *ctx = Ssl::generateSslContextUsingPkeyAndCertFromMemory(reply_message.getBody().c_str());
+                SSL_CTX *ctx = Ssl::generateSslContextUsingPkeyAndCertFromMemory(reply_message.getBody().c_str(), *port);
                 getSslContextDone(ctx, true);
                 return;
             }
@@ -3734,7 +3734,6 @@ void ConnStateData::buildSslCertGenerationParams(Ssl::CertificateProperties &cer
 
         ACLFilledChecklist checklist(NULL, sslServerBump->request,
                                      clientConnection != NULL ? clientConnection->rfc931 : dash_str);
-        checklist.conn(this);
         checklist.sslErrors = cbdataReference(sslServerBump->sslErrors);
 
         for (sslproxy_cert_adapt *ca = Config.ssl_client.cert_adapt; ca != NULL; ca = ca->next) {
@@ -3845,7 +3844,7 @@ ConnStateData::getSslContextStart()
 #endif // USE_SSL_CRTD
 
         debugs(33, 5, HERE << "Generating SSL certificate for " << certProperties.commonName);
-        dynCtx = Ssl::generateSslContext(certProperties);
+        dynCtx = Ssl::generateSslContext(certProperties, *port);
         getSslContextDone(dynCtx, true);
         return;
     }
@@ -4240,16 +4239,6 @@ clientAclChecklistCreate(const acl_access * acl, ClientHttpRequest * http)
      * the ident result on persistent connections...
      */
     /* connection oriented auth also needs these two lines for it's operation. */
-    /*
-     * Internal requests do not have a connection reference, because: A) their
-     * byte count may be transformed before being applied to an outbound
-     * connection B) they are internal - any limiting on them should be done on
-     * the server end.
-     */
-
-    if (conn != NULL)
-        ch->conn(conn);	/* unreferenced in FilledCheckList.cc */
-
     return ch;
 }
 
@@ -652,9 +652,8 @@ clientReplyContext::processMiss()
         return;
     }
 
-    /// Deny loops for accelerator and interceptor. TODO: deny in all modes?
-    if (r->flags.loopdetect &&
-            (http->flags.accel || http->flags.intercepted)) {
+    /// Deny loops
+    if (r->flags.loopdetect) {
         http->al->http.code = HTTP_FORBIDDEN;
         err = clientBuildError(ERR_ACCESS_DENIED, HTTP_FORBIDDEN, NULL, http->getConn()->clientConnection->remote, http->request);
         createStoreEntry(r->method, request_flags());
@@ -46,11 +46,8 @@ struct dlink_list {
     dlink_node *tail;
 };
 
-/* mported form globals.h */
 extern dlink_list ClientActiveRequests;
 
-/* imported directly from protos.h */
-
 SQUIDCEXTERN void dlinkAdd(void *data, dlink_node *, dlink_list *);
 SQUIDCEXTERN void dlinkAddAfter(void *, dlink_node *, dlink_node *, dlink_list *);
 SQUIDCEXTERN void dlinkAddTail(void *data, dlink_node *, dlink_list *);
@@ -328,8 +328,7 @@ enum {
 
 #if USE_HTCP
 /*
- * This should be in htcp.h but because neighborsHtcpClear is defined in
- * protos.h it has to be here.
+ * TODO: This should be in htcp.h
  */
 typedef enum {
     HTCP_CLR_PURGE,
@@ -204,17 +204,6 @@ peerAllowedToUse(const CachePeer * p, HttpRequest * request)
     checklist.src_addr = request->client_addr;
     checklist.my_addr = request->my_addr;
 
-#if 0 && USE_IDENT
-    /*
-     * this is currently broken because 'request->user_ident' has been
-     * moved to conn->rfc931 and we don't have access to the parent
-     * ConnStateData here.
-     */
-    if (request->user_ident[0])
-        xstrncpy(checklist.rfc931, request->user_ident, USER_IDENT_SZ);
-
-#endif
-
     return (checklist.fastCheck() == ACCESS_ALLOWED);
 }
 
@@ -423,9 +412,10 @@ peerClearRRLoop(void *data)
 void
 peerClearRRStart(void)
 {
-    static int event_added = 0;
+    static bool event_added = false;
     if (!event_added) {
         peerClearRRLoop(NULL);
+        event_added=true;
     }
 }
 
@@ -37,5 +37,4 @@
 SQUIDCEXTERN char *peer_proxy_negotiate_auth(char *principal_name, char *proxy);
 #endif
 
-
 #endif /* SQUID_PEER_PROXY_NEGOTIATE_AUTH_H_ */
@@ -29,21 +29,8 @@
 #ifndef SQUID_PROTOS_H
 #define SQUID_PROTOS_H
 
-/* for routines still in this file that take CacheManager parameters */
-#include "ip/Address.h"
-/* for parameters that still need these */
-#include "enums.h"
-/* some parameters stil need this */
-#include "wordlist.h"
-#include "anyp/ProtocolType.h"
-
-#include "comm/forward.h"
-
 extern void shut_down(int);
 extern void rotate_logs(int);
 extern void reconfigure(int);
 
-
-
-
 #endif /* SQUID_PROTOS_H */
@@ -5,6 +5,7 @@
 
 #include "squid.h"
 #include "base/TextException.h"
+#include "Debug.h"
 #include "ipc/TypedMsgHdr.h"
 #include "snmp/Var.h"
 #include "tools.h"
@@ -48,5 +48,4 @@ extern const char * snmpDebugOid(oid * Name, snint Len, MemBuf &outbuf);
 extern void addr2oid(Ip::Address &addr, oid *Dest);
 extern void oid2addr(oid *Dest, Ip::Address &addr, u_int code);
 
-
 #endif /* SQUID_SNMP_CORE_H */
@@ -26,6 +26,12 @@ namespace Ssl
  because they are used by ssl_crtd.
  */
 
+#if OPENSSL_VERSION_NUMBER < 0x00909000L
+typedef SSL_METHOD * ContextMethod;
+#else
+typedef const SSL_METHOD * ContextMethod;
+#endif
+
 /**
    \ingroup SslCrtdSslAPI
   * Add SSL locking (a.k.a. reference counting) to TidyPointer
@@ -55,15 +61,23 @@ class LockingPointer: public TidyPointer<T, DeAllocator>
             function(a); \
         }
 
+// Macro to be used to define the C++ wrapper function of a sk_*_pop_free
+// openssl family functions. The C++ function suffixed with the _free_wrapper
+// extension
+#define sk_free_wrapper(sk_object, argument, freefunction) \
+        extern "C++" inline void sk_object ## _free_wrapper(argument a) { \
+            sk_object ## _pop_free(a, freefunction); \
+        }
+
 /**
  \ingroup SslCrtdSslAPI
  * TidyPointer typedefs for  common SSL objects
  */
 CtoCpp1(X509_free, X509 *)
 typedef LockingPointer<X509, X509_free_cpp, CRYPTO_LOCK_X509> X509_Pointer;
 
-CtoCpp1(sk_X509_free, STACK_OF(X509) *)
-typedef TidyPointer<STACK_OF(X509), sk_X509_free_cpp> X509_STACK_Pointer;
+sk_free_wrapper(sk_X509, STACK_OF(X509) *, X509_free)
+typedef TidyPointer<STACK_OF(X509), sk_X509_free_wrapper> X509_STACK_Pointer;
 
 CtoCpp1(EVP_PKEY_free, EVP_PKEY *)
 typedef LockingPointer<EVP_PKEY, EVP_PKEY_free_cpp, CRYPTO_LOCK_EVP_PKEY> EVP_PKEY_Pointer;
@@ -95,6 +109,15 @@ typedef TidyPointer<SSL_CTX, SSL_CTX_free_cpp> SSL_CTX_Pointer;
 CtoCpp1(SSL_free, SSL *)
 typedef TidyPointer<SSL, SSL_free_cpp> SSL_Pointer;
 
+CtoCpp1(DH_free, DH *);
+typedef TidyPointer<DH, DH_free_cpp> DH_Pointer;
+
+sk_free_wrapper(sk_X509_CRL, STACK_OF(X509_CRL) *, X509_CRL_free)
+typedef TidyPointer<STACK_OF(X509_CRL), sk_X509_CRL_free_wrapper> X509_CRL_STACK_Pointer;
+
+sk_free_wrapper(sk_X509_NAME, STACK_OF(X509_NAME) *, X509_NAME_free)
+typedef TidyPointer<STACK_OF(X509_NAME), sk_X509_NAME_free_wrapper> X509_NAME_STACK_Pointer;
+
 /**
  \ingroup SslCrtdSslAPI
  * Create 1024 bits rsa key.
@@ -39,6 +39,7 @@
 #if USE_SSL
 
 #include "acl/FilledChecklist.h"
+#include "anyp/PortCfg.h"
 #include "fde.h"
 #include "globals.h"
 #include "SquidConfig.h"
@@ -449,8 +450,8 @@ ssl_options[] = {
 };
 
 /// \ingroup ServerProtocolSSLInternal
-static long
-ssl_parse_options(const char *options)
+long
+Ssl::parse_options(const char *options)
 {
     long op = 0;
     char *tmp;
@@ -543,8 +544,8 @@ ssl_parse_options(const char *options)
 #define SSL_FLAG_VERIFY_CRL_ALL		(1<<6)
 
 /// \ingroup ServerProtocolSSLInternal
-static long
-ssl_parse_flags(const char *flags)
+long
+Ssl::parse_flags(const char *flags)
 {
     long fl = 0;
     char *tmp;
@@ -703,99 +704,71 @@ ssl_load_crl(SSL_CTX *sslContext, const char *CRLfile)
     return count;
 }
 
-SSL_CTX *
-sslCreateServerContext(const char *certfile, const char *keyfile, int version, const char *cipher, const char *options, const char *flags, const char *clientCA, const char *CAfile, const char *CApath, const char *CRLfile, const char *dhfile, const char *context)
+STACK_OF(X509_CRL) *
+Ssl::loadCrl(const char *CRLFile, long &flags)
 {
-    int ssl_error;
-#if OPENSSL_VERSION_NUMBER < 0x00909000L
-    SSL_METHOD *method;
-#else
-    const SSL_METHOD *method;
-#endif
-    SSL_CTX *sslContext;
-    long fl = ssl_parse_flags(flags);
-
-    ssl_initialize();
-
-    if (!keyfile)
-        keyfile = certfile;
-
-    if (!certfile)
-        certfile = keyfile;
-
-    if (!CAfile)
-        CAfile = clientCA;
-
-    if (!certfile) {
-        debugs(83, DBG_CRITICAL, "ERROR: No certificate file");
+    X509_CRL *crl;
+    BIO *in = BIO_new_file(CRLFile, "r");
+    if (!in) {
+        debugs(83, 2, "WARNING: Failed to open CRL file '" << CRLFile << "'");
         return NULL;
     }
 
-    switch (version) {
-
-    case 2:
-#ifndef OPENSSL_NO_SSL2
-        debugs(83, 5, "Using SSLv2.");
-        method = SSLv2_server_method();
-#else
-        debugs(83, DBG_IMPORTANT, "SSLv2 is not available in this Proxy.");
+    STACK_OF(X509_CRL) *CRLs = sk_X509_CRL_new_null();
+    if (!CRLs) {
+        debugs(83, 2, "WARNING: Failed to allocate X509_CRL stack  to load file '" << CRLFile << "'");
         return NULL;
-#endif
-        break;
-
-    case 3:
-        debugs(83, 5, "Using SSLv3.");
-        method = SSLv3_server_method();
-        break;
+    }
 
-    case 4:
-        debugs(83, 5, "Using TLSv1.");
-        method = TLSv1_server_method();
-        break;
+    int count = 0;
+    while ((crl = PEM_read_bio_X509_CRL(in,NULL,NULL,NULL))) {
+        if (!sk_X509_CRL_push(CRLs, crl))
+            debugs(83, 2, "WARNING: Failed to add CRL from file '" << CRLFile << "'");
+        else
+            ++count;
+    }
+    BIO_free(in);
 
-    case 5:
-#if OPENSSL_VERSION_NUMBER >= 0x10001000L  // NP: not sure exactly which sub-version yet.
-        debugs(83, 5, "Using TLSv1.1.");
-        method = TLSv1_1_server_method();
-#else
-        debugs(83, DBG_IMPORTANT, "TLSv1.1 is not available in this Proxy.");
-        return NULL;
-#endif
-        break;
+    if (count)
+        flags |= SSL_FLAG_VERIFY_CRL;
 
-    case 6:
-#if OPENSSL_VERSION_NUMBER >= 0x10001000L // NP: not sure exactly which sub-version yet.
-        debugs(83, 5, "Using TLSv1.2");
-        method = TLSv1_2_server_method();
-#else
-        debugs(83, DBG_IMPORTANT, "TLSv1.2 is not available in this Proxy.");
-        return NULL;
-#endif
-        break;
+    return CRLs;
+}
 
-    case 1:
+DH *
+Ssl::readDHParams(const char *dhfile)
+{
+    FILE *in = fopen(dhfile, "r");
+    DH *dh = NULL;
+    int codes;
 
-    default:
-        debugs(83, 5, "Using SSLv2/SSLv3.");
-        method = SSLv23_server_method();
-        break;
+    if (in) {
+        dh = PEM_read_DHparams(in, NULL, NULL, NULL);
+        fclose(in);
     }
 
-    sslContext = SSL_CTX_new(method);
-
-    if (sslContext == NULL) {
-        ssl_error = ERR_get_error();
-        debugs(83, DBG_CRITICAL, "ERROR: Failed to allocate SSL context: " << ERR_error_string(ssl_error, NULL));
-        return NULL;
+    if (!dh)
+        debugs(83, DBG_IMPORTANT, "WARNING: Failed to read DH parameters '" << dhfile << "'");
+    else if (dh && DH_check(dh, &codes) == 0) {
+        if (codes) {
+            debugs(83, DBG_IMPORTANT, "WARNING: Failed to verify DH parameters '" << dhfile  << "' (" << std::hex << codes  << ")");
+            DH_free(dh);
+            dh = NULL;
+        }
     }
+    return dh;
+}
 
-    SSL_CTX_set_options(sslContext, ssl_parse_options(options));
+static bool
+configureSslContext(SSL_CTX *sslContext, AnyP::PortCfg &port)
+{
+    int ssl_error;
+    SSL_CTX_set_options(sslContext, port.sslOptions);
 
-    if (context && *context) {
-        SSL_CTX_set_session_id_context(sslContext, (const unsigned char *)context, strlen(context));
-    }
+    if (port.sslContextSessionId)
+        SSL_CTX_set_session_id_context(sslContext, (const unsigned char *)port.sslContextSessionId, strlen(port.sslContextSessionId));
 
-    if (fl & SSL_FLAG_NO_SESSION_REUSE) {
+    if (port.sslContextFlags & SSL_FLAG_NO_SESSION_REUSE) {
         SSL_CTX_set_session_cache_mode(sslContext, SSL_SESS_CACHE_OFF);
     }
 
@@ -805,128 +778,153 @@ sslCreateServerContext(const char *certfile, const char *keyfile, int version, c
         SSL_CTX_set_quiet_shutdown(sslContext, 1);
     }
 
-    if (cipher) {
-        debugs(83, 5, "Using chiper suite " << cipher << ".");
+    if (port.cipher) {
+        debugs(83, 5, "Using chiper suite " << port.cipher << ".");
 
-        if (!SSL_CTX_set_cipher_list(sslContext, cipher)) {
+        if (!SSL_CTX_set_cipher_list(sslContext, port.cipher)) {
             ssl_error = ERR_get_error();
-            debugs(83, DBG_CRITICAL, "ERROR: Failed to set SSL cipher suite '" << cipher << "': " << ERR_error_string(ssl_error, NULL));
-            SSL_CTX_free(sslContext);
-            return NULL;
+            debugs(83, DBG_CRITICAL, "ERROR: Failed to set SSL cipher suite '" << port.cipher << "': " << ERR_error_string(ssl_error, NULL));
+            return false;
         }
     }
 
-    debugs(83, DBG_IMPORTANT, "Using certificate in " << certfile);
-
-    if (!SSL_CTX_use_certificate_chain_file(sslContext, certfile)) {
-        ssl_error = ERR_get_error();
-        debugs(83, DBG_CRITICAL, "ERROR: Failed to acquire SSL certificate '" << certfile << "': " << ERR_error_string(ssl_error, NULL));
-        SSL_CTX_free(sslContext);
-        return NULL;
-    }
-
-    debugs(83, DBG_IMPORTANT, "Using private key in " << keyfile);
-    ssl_ask_password(sslContext, keyfile);
-
-    if (!SSL_CTX_use_PrivateKey_file(sslContext, keyfile, SSL_FILETYPE_PEM)) {
-        ssl_error = ERR_get_error();
-        debugs(83, DBG_CRITICAL, "ERROR: Failed to acquire SSL private key '" << keyfile << "': " << ERR_error_string(ssl_error, NULL));
-        SSL_CTX_free(sslContext);
-        return NULL;
-    }
-
-    debugs(83, 5, "Comparing private and public SSL keys.");
-
-    if (!SSL_CTX_check_private_key(sslContext)) {
-        ssl_error = ERR_get_error();
-        debugs(83, DBG_CRITICAL, "ERROR: SSL private key '" << certfile << "' does not match public key '" <<
-               keyfile << "': " << ERR_error_string(ssl_error, NULL));
-        SSL_CTX_free(sslContext);
-        return NULL;
-    }
-
     debugs(83, 9, "Setting RSA key generation callback.");
     SSL_CTX_set_tmp_rsa_callback(sslContext, ssl_temp_rsa_cb);
 
     debugs(83, 9, "Setting CA certificate locations.");
 
-    if ((CAfile || CApath) && !SSL_CTX_load_verify_locations(sslContext, CAfile, CApath)) {
+    const char *cafile = port.cafile ? port.cafile : port.clientca;
+    if ((cafile || port.capath) && !SSL_CTX_load_verify_locations(sslContext, cafile, port.capath)) {
         ssl_error = ERR_get_error();
         debugs(83, DBG_IMPORTANT, "WARNING: Ignoring error setting CA certificate locations: " << ERR_error_string(ssl_error, NULL));
     }
 
-    if (!(fl & SSL_FLAG_NO_DEFAULT_CA) &&
+    if (!(port.sslContextFlags & SSL_FLAG_NO_DEFAULT_CA) &&
             !SSL_CTX_set_default_verify_paths(sslContext)) {
         ssl_error = ERR_get_error();
         debugs(83, DBG_IMPORTANT, "WARNING: Ignoring error setting default CA certificate location: " << ERR_error_string(ssl_error, NULL));
     }
 
-    if (clientCA) {
-        STACK_OF(X509_NAME) *cert_names;
-        debugs(83, 9, "Set client certifying authority list.");
-        cert_names = SSL_load_client_CA_file(clientCA);
-
-        if (cert_names == NULL) {
-            debugs(83, DBG_IMPORTANT, "ERROR: loading the client CA certificates from '" << clientCA << "\': " << ERR_error_string(ERR_get_error(),NULL));
-            SSL_CTX_free(sslContext);
-            return NULL;
-        }
-
+    if (port.clientCA.get()) {
         ERR_clear_error();
-        SSL_CTX_set_client_CA_list(sslContext, cert_names);
+        SSL_CTX_set_client_CA_list(sslContext, port.clientCA.get());
 
-        if (fl & SSL_FLAG_DELAYED_AUTH) {
+        if (port.sslContextFlags & SSL_FLAG_DELAYED_AUTH) {
             debugs(83, 9, "Not requesting client certificates until acl processing requires one");
             SSL_CTX_set_verify(sslContext, SSL_VERIFY_NONE, NULL);
         } else {
             debugs(83, 9, "Requiring client certificates.");
             SSL_CTX_set_verify(sslContext, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, ssl_verify_cb);
         }
 
-        if (CRLfile) {
-            ssl_load_crl(sslContext, CRLfile);
-            fl |= SSL_FLAG_VERIFY_CRL;
+        if (port.clientVerifyCrls.get()) {
+            X509_STORE *st = SSL_CTX_get_cert_store(sslContext);
+            for (int i = 0; i < sk_X509_CRL_num(port.clientVerifyCrls.get()); ++i) {
+                X509_CRL *crl = sk_X509_CRL_value(port.clientVerifyCrls.get(), i);
+                if (!X509_STORE_add_crl(st, crl))
+                    debugs(83, 2, "WARNING: Failed to add CRL");
+            }
         }
 
 #if X509_V_FLAG_CRL_CHECK
-        if (fl & SSL_FLAG_VERIFY_CRL_ALL)
+        if (port.sslContextFlags & SSL_FLAG_VERIFY_CRL_ALL)
             X509_STORE_set_flags(SSL_CTX_get_cert_store(sslContext), X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL);
-        else if (fl & SSL_FLAG_VERIFY_CRL)
+        else if (port.sslContextFlags & SSL_FLAG_VERIFY_CRL)
             X509_STORE_set_flags(SSL_CTX_get_cert_store(sslContext), X509_V_FLAG_CRL_CHECK);
-
 #endif
 
     } else {
         debugs(83, 9, "Not requiring any client certificates");
         SSL_CTX_set_verify(sslContext, SSL_VERIFY_NONE, NULL);
     }
 
-    if (dhfile) {
-        FILE *in = fopen(dhfile, "r");
-        DH *dh = NULL;
-        int codes;
+    if (port.dhParams.get()) {
+        SSL_CTX_set_tmp_dh(sslContext, port.dhParams.get());
+    }
 
-        if (in) {
-            dh = PEM_read_DHparams(in, NULL, NULL, NULL);
-            fclose(in);
+    if (port.sslContextFlags & SSL_FLAG_DONT_VERIFY_DOMAIN)
+        SSL_CTX_set_ex_data(sslContext, ssl_ctx_ex_index_dont_verify_domain, (void *) -1);
+
+    return true;
+}
+
+SSL_CTX *
+sslCreateServerContext(AnyP::PortCfg &port)
+{
+    int ssl_error;
+    SSL_CTX *sslContext;
+    const char *keyfile, *certfile;
+    certfile = port.cert;
+    keyfile = port.key;
+
+    ssl_initialize();
+
+    if (!keyfile)
+        keyfile = certfile;
+
+    if (!certfile)
+        certfile = keyfile;
+
+    sslContext = SSL_CTX_new(port.contextMethod);
+
+    if (sslContext == NULL) {
+        ssl_error = ERR_get_error();
+        debugs(83, DBG_CRITICAL, "ERROR: Failed to allocate SSL context: " << ERR_error_string(ssl_error, NULL));
+        return NULL;
+    }
+
+    if (!SSL_CTX_use_certificate(sslContext, port.signingCert.get())) {
+        ssl_error = ERR_get_error();
+        debugs(83, DBG_CRITICAL, "ERROR: Failed to acquire SSL certificate '" << certfile << "': " << ERR_error_string(ssl_error, NULL));
+        SSL_CTX_free(sslContext);
+        return NULL;
+    }
+
+    if (!SSL_CTX_use_PrivateKey(sslContext, port.signPkey.get())) {
+        ssl_error = ERR_get_error();
+        debugs(83, DBG_CRITICAL, "ERROR: Failed to acquire SSL private key '" << keyfile << "': " << ERR_error_string(ssl_error, NULL));
+        SSL_CTX_free(sslContext);
+        return NULL;
+    }
+
+    Ssl::addChainToSslContext(sslContext, port.certsToChain.get());
+
+    /* Alternate code;
+        debugs(83, DBG_IMPORTANT, "Using certificate in " << certfile);
+
+        if (!SSL_CTX_use_certificate_chain_file(sslContext, certfile)) {
+            ssl_error = ERR_get_error();
+            debugs(83, DBG_CRITICAL, "ERROR: Failed to acquire SSL certificate '" << certfile << "': " << ERR_error_string(ssl_error, NULL));
+            SSL_CTX_free(sslContext);
+            return NULL;
         }
 
-        if (!dh)
-            debugs(83, DBG_IMPORTANT, "WARNING: Failed to read DH parameters '" << dhfile << "'");
-        else if (dh && DH_check(dh, &codes) == 0) {
-            if (codes) {
-                debugs(83, DBG_IMPORTANT, "WARNING: Failed to verify DH parameters '" << dhfile  << "' (" << std::hex << codes  << ")");
-                DH_free(dh);
-                dh = NULL;
-            }
+        debugs(83, DBG_IMPORTANT, "Using private key in " << keyfile);
+        ssl_ask_password(sslContext, keyfile);
+
+        if (!SSL_CTX_use_PrivateKey_file(sslContext, keyfile, SSL_FILETYPE_PEM)) {
+            ssl_error = ERR_get_error();
+            debugs(83, DBG_CRITICAL, "ERROR: Failed to acquire SSL private key '" << keyfile << "': " << ERR_error_string(ssl_error, NULL));
+            SSL_CTX_free(sslContext);
+            return NULL;
         }
 
-        if (dh)
-            SSL_CTX_set_tmp_dh(sslContext, dh);
-    }
+        debugs(83, 5, "Comparing private and public SSL keys.");
 
-    if (fl & SSL_FLAG_DONT_VERIFY_DOMAIN)
-        SSL_CTX_set_ex_data(sslContext, ssl_ctx_ex_index_dont_verify_domain, (void *) -1);
+        if (!SSL_CTX_check_private_key(sslContext)) {
+            ssl_error = ERR_get_error();
+            debugs(83, DBG_CRITICAL, "ERROR: SSL private key '" << certfile << "' does not match public key '" <<
+                   keyfile << "': " << ERR_error_string(ssl_error, NULL));
+            SSL_CTX_free(sslContext);
+            return NULL;
+        }
+    */
+
+    if (!configureSslContext(sslContext, port)) {
+        debugs(83, DBG_CRITICAL, "ERROR: Configuring static SSL context");
+        SSL_CTX_free(sslContext);
+        return NULL;
+    }
 
     return sslContext;
 }
@@ -941,7 +939,7 @@ sslCreateClientContext(const char *certfile, const char *keyfile, int version, c
     const SSL_METHOD *method;
 #endif
     SSL_CTX *sslContext;
-    long fl = ssl_parse_flags(flags);
+    long fl = Ssl::parse_flags(flags);
 
     ssl_initialize();
 
@@ -1009,7 +1007,7 @@ sslCreateClientContext(const char *certfile, const char *keyfile, int version, c
                ERR_error_string(ssl_error, NULL));
     }
 
-    SSL_CTX_set_options(sslContext, ssl_parse_options(options));
+    SSL_CTX_set_options(sslContext, Ssl::parse_options(options));
 
     if (cipher) {
         debugs(83, 5, "Using chiper suite " << cipher << ".");
@@ -1297,21 +1295,84 @@ sslGetUserCertificateChainPEM(SSL *ssl)
     return str;
 }
 
+Ssl::ContextMethod
+Ssl::contextMethod(int version)
+{
+    Ssl::ContextMethod method;
+
+    switch (version) {
+
+    case 2:
+#ifndef OPENSSL_NO_SSL2
+        debugs(83, 5, "Using SSLv2.");
+        method = SSLv2_server_method();
+#else
+        debugs(83, DBG_IMPORTANT, "SSLv2 is not available in this Proxy.");
+        return NULL;
+#endif
+        break;
+
+    case 3:
+        debugs(83, 5, "Using SSLv3.");
+        method = SSLv3_server_method();
+        break;
+
+    case 4:
+        debugs(83, 5, "Using TLSv1.");
+        method = TLSv1_server_method();
+        break;
+
+    case 5:
+#if OPENSSL_VERSION_NUMBER >= 0x10001000L  // NP: not sure exactly which sub-version yet.
+        debugs(83, 5, "Using TLSv1.1.");
+        method = TLSv1_1_server_method();
+#else
+        debugs(83, DBG_IMPORTANT, "TLSv1.1 is not available in this Proxy.");
+        return NULL;
+#endif
+        break;
+
+    case 6:
+#if OPENSSL_VERSION_NUMBER >= 0x10001000L // NP: not sure exactly which sub-version yet.
+        debugs(83, 5, "Using TLSv1.2");
+        method = TLSv1_2_server_method();
+#else
+        debugs(83, DBG_IMPORTANT, "TLSv1.2 is not available in this Proxy.");
+        return NULL;
+#endif
+        break;
+
+    case 1:
+
+    default:
+        debugs(83, 5, "Using SSLv2/SSLv3.");
+        method = SSLv23_server_method();
+        break;
+    }
+    return method;
+}
+
 /// \ingroup ServerProtocolSSLInternal
 /// Create SSL context and apply ssl certificate and private key to it.
-static SSL_CTX * createSSLContext(Ssl::X509_Pointer & x509, Ssl::EVP_PKEY_Pointer & pkey)
+static SSL_CTX *
+createSSLContext(Ssl::X509_Pointer & x509, Ssl::EVP_PKEY_Pointer & pkey, AnyP::PortCfg &port)
 {
-    Ssl::SSL_CTX_Pointer sslContext(SSL_CTX_new(SSLv23_server_method()));
+    Ssl::SSL_CTX_Pointer sslContext(SSL_CTX_new(port.contextMethod));
 
     if (!SSL_CTX_use_certificate(sslContext.get(), x509.get()))
         return NULL;
 
     if (!SSL_CTX_use_PrivateKey(sslContext.get(), pkey.get()))
         return NULL;
+
+    if (!configureSslContext(sslContext.get(), port))
+        return NULL;
+
     return sslContext.release();
 }
 
-SSL_CTX * Ssl::generateSslContextUsingPkeyAndCertFromMemory(const char * data)
+SSL_CTX *
+Ssl::generateSslContextUsingPkeyAndCertFromMemory(const char * data, AnyP::PortCfg &port)
 {
     Ssl::X509_Pointer cert;
     Ssl::EVP_PKEY_Pointer pkey;
@@ -1321,10 +1382,11 @@ SSL_CTX * Ssl::generateSslContextUsingPkeyAndCertFromMemory(const char * data)
     if (!cert || !pkey)
         return NULL;
 
-    return createSSLContext(cert, pkey);
+    return createSSLContext(cert, pkey, port);
 }
 
-SSL_CTX * Ssl::generateSslContext(CertificateProperties const &properties)
+SSL_CTX *
+Ssl::generateSslContext(CertificateProperties const &properties, AnyP::PortCfg &port)
 {
     Ssl::X509_Pointer cert;
     Ssl::EVP_PKEY_Pointer pkey;
@@ -1337,7 +1399,7 @@ SSL_CTX * Ssl::generateSslContext(CertificateProperties const &properties)
     if (!pkey)
         return NULL;
 
-    return createSSLContext(cert, pkey);
+    return createSSLContext(cert, pkey, port);
 }
 
 bool Ssl::verifySslCertificate(SSL_CTX * sslContext, CertificateProperties const &properties)
@@ -1430,6 +1492,12 @@ void Ssl::readCertChainAndPrivateKeyFromFiles(X509_Pointer & cert, EVP_PKEY_Poin
 {
     if (keyFilename == NULL)
         keyFilename = certFilename;
+
+    if (certFilename == NULL)
+        certFilename = keyFilename;
+
+    debugs(83, DBG_IMPORTANT, "Using certificate in " << certFilename);
+
     if (!chain)
         chain.reset(sk_X509_new_null());
     if (!chain)
@@ -62,6 +62,11 @@
 #define SQUID_SSL_ERROR_MIN SQUID_X509_V_ERR_CERT_CHANGE
 #define SQUID_SSL_ERROR_MAX INT_MAX
 
+namespace AnyP
+{
+class PortCfg;
+};
+
 namespace Ssl
 {
 /// Squid defined error code (<0),  an error code returned by SSL X509 api, or SSL_ERROR_NONE
@@ -72,7 +77,7 @@ typedef CbDataList<Ssl::ssl_error_t> Errors;
 } //namespace Ssl
 
 /// \ingroup ServerProtocolSSLAPI
-SSL_CTX *sslCreateServerContext(const char *certfile, const char *keyfile, int version, const char *cipher, const char *options, const char *flags, const char *clientCA, const char *CAfile, const char *CApath, const char *CRLfile, const char *dhpath, const char *context);
+SSL_CTX *sslCreateServerContext(AnyP::PortCfg &port);
 
 /// \ingroup ServerProtocolSSLAPI
 SSL_CTX *sslCreateClientContext(const char *certfile, const char *keyfile, int version, const char *cipher, const char *options, const char *flags, const char *CAfile, const char *CApath, const char *CRLfile);
@@ -127,6 +132,36 @@ inline const char *bumpMode(int bm)
     return (0 <= bm && bm < Ssl::bumpEnd) ? Ssl::BumpModeStr[bm] : NULL;
 }
 
+/**
+ \ingroup ServerProtocolSSLAPI
+ * Parses the SSL flags.
+ */
+long parse_flags(const char *flags);
+
+/**
+ \ingroup ServerProtocolSSLAPI
+ * Parses the SSL options.
+ */
+long parse_options(const char *options);
+
+/**
+ \ingroup ServerProtocolSSLAPI
+ * Load a CRLs list stored in a file
+ */
+STACK_OF(X509_CRL) *loadCrl(const char *CRLFile, long &flags);
+
+/**
+ \ingroup ServerProtocolSSLAPI
+ * Load DH params from file
+ */
+DH *readDHParams(const char *dhfile);
+
+/**
+ \ingroup ServerProtocolSSLAPI
+ * Compute the Ssl::ContextMethod (SSL_METHOD) from SSL version
+ */
+ContextMethod contextMethod(int version);
+
 /**
   \ingroup ServerProtocolSSLAPI
   * Generate a certificate to be used as untrusted signing certificate, based on a trusted CA
@@ -137,7 +172,7 @@ bool generateUntrustedCert(X509_Pointer & untrustedCert, EVP_PKEY_Pointer & untr
   \ingroup ServerProtocolSSLAPI
   * Decide on the kind of certificate and generate a CA- or self-signed one
 */
-SSL_CTX * generateSslContext(CertificateProperties const &properties);
+SSL_CTX * generateSslContext(CertificateProperties const &properties, AnyP::PortCfg &port);
 
 /**
   \ingroup ServerProtocolSSLAPI
@@ -153,7 +188,7 @@ bool verifySslCertificate(SSL_CTX * sslContext,  CertificateProperties const &pr
   * Read private key and certificate from memory and generate SSL context
   * using their.
  */
-SSL_CTX * generateSslContextUsingPkeyAndCertFromMemory(const char * data);
+SSL_CTX * generateSslContextUsingPkeyAndCertFromMemory(const char * data, AnyP::PortCfg &port);
 
 /**
   \ingroup ServerProtocolSSLAPI
@@ -56,6 +56,4 @@ extern bool storeRebuildParseEntry(MemBuf &buf, StoreEntry &e, cache_key *key, S
 /// checks whether the loaded entry should be kept; updates counters
 extern bool storeRebuildKeepEntry(const StoreEntry &e, const cache_key *key, StoreRebuildData &counts);
 
-
-
 #endif /* SQUID_STORE_REBUILD_H_ */
@@ -4,5 +4,4 @@
 #define STUB_API "ipc.cc"
 #include "tests/STUB.h"
 
-
 pid_t ipcCreate(int, const char *, const char *const [], const char *, Ip::Address &, int *, int *, void **) STUB_RETVAL(-1)
@@ -42,7 +42,7 @@ Ssl::ErrorDetail::ErrorDetail(ErrorDetail const &) STUB
 const String & Ssl::ErrorDetail::toString() const STUB_RETSTATREF(String)
 
 #include "ssl/support.h"
-SSL_CTX *sslCreateServerContext(const char *certfile, const char *keyfile, int version, const char *cipher, const char *options, const char *flags, const char *clientCA, const char *CAfile, const char *CApath, const char *CRLfile, const char *dhpath, const char *context) STUB_RETVAL(NULL)
+SSL_CTX *sslCreateServerContext(AnyP::PortCfg &) STUB_RETVAL(NULL)
 SSL_CTX *sslCreateClientContext(const char *certfile, const char *keyfile, int version, const char *cipher, const char *options, const char *flags, const char *CAfile, const char *CApath, const char *CRLfile) STUB_RETVAL(NULL)
 int ssl_read_method(int, char *, int) STUB_RETVAL(0)
 int ssl_write_method(int, const char *, int) STUB_RETVAL(0)
@@ -53,8 +53,8 @@ const char *sslGetUserEmail(SSL *ssl) STUB_RETVAL(NULL)
 // SSLGETATTRIBUTE sslGetCAAttribute;
 const char *sslGetUserCertificatePEM(SSL *ssl) STUB_RETVAL(NULL)
 const char *sslGetUserCertificateChainPEM(SSL *ssl) STUB_RETVAL(NULL)
-SSL_CTX * Ssl::generateSslContext(CertificateProperties const &properties) STUB_RETVAL(NULL)
-SSL_CTX * Ssl::generateSslContextUsingPkeyAndCertFromMemory(const char * data) STUB_RETVAL(NULL)
+SSL_CTX * Ssl::generateSslContext(CertificateProperties const &properties, AnyP::PortCfg &) STUB_RETVAL(NULL)
+SSL_CTX * Ssl::generateSslContextUsingPkeyAndCertFromMemory(const char * data, AnyP::PortCfg &) STUB_RETVAL(NULL)
 int Ssl::matchX509CommonNames(X509 *peer_cert, void *check_data, int (*check_func)(void *check_data,  ASN1_STRING *cn_data)) STUB_RETVAL(0)
 int Ssl::asn1timeToString(ASN1_TIME *tm, char *buf, int len) STUB_RETVAL(0)
 
@@ -1,5 +1,4 @@
 #include "squid.h"
-// tool functions still defined in protos.h
 #include "tools.h"
 
 #define STUB_API "tools.cc"
@@ -33,7 +33,6 @@
  * 
  */
 
-
 #if _SQUID_MSWIN_
 
 #if HAVE_SYS_TIME_H
@@ -59,6 +58,4 @@ extern DWORD WIN32_IpAddrChangeMonitorInit();
 
 #endif
 
-
-
 #endif /* SQUID_WIN32_H_ */