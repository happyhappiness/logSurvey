@@ -1,3 +1,9 @@
+Changes to squid-3.3.0.2 (03 Dec 2012):
+
+	- Support matching empty header field values using req_header and rep_header
+	- ... and some minor code polish and input vaidations
+	- ... and all changes from squid 3.2.4
+
 Changes to squid-3.3.0.1 (21 Oct 2012):
 
 	- Bug 3610: Add peername_regex ACL
@@ -17,6 +23,18 @@ Changes to squid-3.3.0.1 (21 Oct 2012):
 	- ... and many compile error fixes
 	- ... and a very large amount of code polish for faster compilation
 
+Changes to squid-3.2.4 (03 Dec 2012):
+
+	- Ported: urllogin ACL from squid 2.7
+	- Bug 3688: Lots of Orphan Comm:Connections to ICAP server
+	- Bug 3677: Port un-pinning logic changes from squid 3.3
+	- Bug 3405: ssl_crtd crashes failing to remove certificate
+	- ... and major bugs fixed in squid 3.1.22
+	- Fix accept_filter on Linux
+	- Remove 'Bungled' warning on missing component directives
+	- ... and many buffer and memory leak issues in the bundled helpers
+	- ... and a small amount of code polishing
+
 Changes to squid-3.2.3 (21 Oct 2012):
 
 	- Regression: SMP crashes on startup with workers > 1
@@ -454,6 +472,14 @@ Changes to squid-3.2.0.1 (03 Aug 2010):
 	- ... and a great many testing improvements
 	- ... and many documentation updates
 
+Changes to squid-3.1.22 (03 Dec 2012):
+
+	- Bug 3685: Squid hangs in Delay Pools ClassCBucket::update
+	- Bug 3659: read_timeout problem with HTTPS
+	- Bug 3654: Fix IPv6 enabled squidclient
+	- Bug 3189: AIO thread race on pipe() initialization
+	- cachemgr.cgi: Memory Leaks and DoS Vulnerability
+
 Changes to squid-3.1.21 (23 Sep 2012):
 
 	- Bug 3622: peerClearRRStart scheduling multiple events
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.1.21 release notes</title>
+<title>Squid 3.1.22 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.1.21
+The Squid Team are pleased to announce the release of Squid-3.1.22
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.1/"> or the <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
 
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.2.3 release notes</title>
+<title>Squid 3.2.4 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.2.3 for testing.
+The Squid Team are pleased to announce the release of Squid-3.2.4 for testing.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.2/"> or the <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
 
@@ -412,9 +412,10 @@ Most user-facing changes are reflected in squid.conf (see below).
 <p>The cache manager is available under the path prefix /squid-internal-mgr/. For example
    the URL http://example/com/squid-internal-mgr/menu will bring up the manager menu. This
    means there are some configuration changes required to lock down manager access.
-   The <em>manager</em> ACL needs changing to:
+   The <em>manager</em> ACL needs changing. A built-in definition is now used, equivalent
+   to the following regex pattern:
 <verb>
-	acl manager url_regex -i ^cache_object:// ^https?://[^/]+/squid-internal-mgr/
+	^(cache_object://|https?://[^/]+/squid-internal-mgr/)
 </verb>
 
 <p>The manager prefix /squid-internal-mgr/ with no action attempts to load an optional
@@ -423,6 +424,13 @@ Most user-facing changes are reflected in squid.conf (see below).
    cache manager applications as their front page embedding all scripts, accessors or
    redirects required for their initial GUI display.
 
+<p>MGR_INDEX file
+<itemize>
+   <item>should contain a complete HTML page, with optional client-side scripting.
+   <item>must not contain server-side scripting. 
+   <item>will have macro substitution performed on it using the same macros as used by the error page tempates.
+</itemize>
+
 <p>Version 3.2 of the CGI cache manager tool now presents XHR scripted probes to detect
    proxies presenting these manager index pagess and provides direct HTTP/HTTPS web links
    to those managers.
@@ -592,10 +600,12 @@ This section gives a thorough account of those changes in three categories:
 	<p>The <em>localip</em>/<em>localport</em> differ from earlier releases where they matched a mix of
 	   of an invalid IP and port 0, the client destination IP/port or the Squid listening IP/port.
 	   This definition is now consistent across all modes of traffic received by Squid.
-	<p>The <em>manager</em> ACL requires adjustment to cover new cache manager access:
+	<p>The <em>manager</em> ACL requires adjustment to cover new cache manager access. So it has now been
+	  built-in as a predefined ACL name matching URLs equivalent to the following regular expression:
         <verb>
-		acl manager url_regex -i ^cache_object:// ^https?://[^/]+/squid-internal-mgr/
+		^(cache_object://|https?://[^/]+/squid-internal-mgr/)
         </verb>
+	  squid.conf containing the old manager definition can expect to see ACL type collisions.
 
 	<tag>auth_param</tag>
 	<p>New options for Basic, Digest, NTLM, Negotiate <em>children</em> settings.
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.3.0.1 release notes</title>
+<title>Squid 3.3.0.2 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.3.0.1 for testing.
+The Squid Team are pleased to announce the release of Squid-3.3.0.2 for testing.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.3/"> or the <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
 
@@ -65,7 +65,7 @@ static void
 read_passwd_file(const char *passwdfile)
 {
     FILE *f;
-    char buf[8192];
+    char buf[HELPER_INPUT_BUFFER];
     user_data *u;
     char *user;
     char *passwd;
@@ -84,11 +84,18 @@ read_passwd_file(const char *passwdfile)
         fprintf(stderr, "FATAL: %s: %s\n", passwdfile, xstrerror());
         exit(1);
     }
-    while (fgets(buf, 8192, f) != NULL) {
+    unsigned int lineCount = 0;
+    buf[HELPER_INPUT_BUFFER-1] = '\0';
+    while (fgets(buf, sizeof(buf)-1, f) != NULL) {
+        ++lineCount;
         if ((buf[0] == '#') || (buf[0] == ' ') || (buf[0] == '\t') ||
                 (buf[0] == '\n'))
             continue;
         user = strtok(buf, ":\n\r");
+        if (user == NULL) {
+            fprintf(stderr, "ERROR: Missing user name at %s line %d\n", passwdfile, lineCount);
+            continue;
+        }
         passwd = strtok(NULL, ":\n\r");
         if ((strlen(user) > 0) && passwd) {
             u = static_cast<user_data*>(xmalloc(sizeof(*u)));
@@ -258,8 +258,7 @@ main(int argc, char *argv[])
         /* Authentication */
         retval = PAM_SUCCESS;
         if (ttl != 0) {
-            if (retval == PAM_SUCCESS)
-                retval = pam_set_item(pamh, PAM_USER, user);
+            retval = pam_set_item(pamh, PAM_USER, user);
             if (retval == PAM_SUCCESS)
                 retval = pam_set_item(pamh, PAM_CONV, &conv);
         }
@@ -276,12 +275,11 @@ main(int argc, char *argv[])
         /* cleanup */
         retval = PAM_SUCCESS;
 #if defined(PAM_AUTHTOK)
-        if (ttl != 0) {
-            if (retval == PAM_SUCCESS)
-                retval = pam_set_item(pamh, PAM_AUTHTOK, NULL);
+        if (ttl != 0 && pamh) {
+            retval = pam_set_item(pamh, PAM_AUTHTOK, NULL);
         }
 #endif
-        if (ttl == 0 || retval != PAM_SUCCESS) {
+        if (pamh && (ttl == 0 || retval != PAM_SUCCESS)) {
             retval = pam_end(pamh, retval);
             if (retval != PAM_SUCCESS) {
                 debug("WARNING: failed to release PAM authenticator\n");
@@ -321,7 +321,7 @@ authenticate(int socket_fd, const char *username, const char *passwd)
         length = MAXPWNAM;
     }
     *ptr = length + 2;
-    ++ptr;
+    ptr = (unsigned char*)send_buffer + sizeof(AUTH_HDR);
     memcpy(ptr, username, length);
     ptr += length;
     total_length += length + 2;
@@ -424,7 +424,13 @@ authenticate(int socket_fd, const char *username, const char *passwd)
          *    Send the request we've built.
          */
         gettimeofday(&sent, NULL);
-        send(socket_fd, (char *) auth, total_length, 0);
+        if (send(socket_fd, (char *) auth, total_length, 0) < 0) {
+            // EAGAIN is expected at high traffic, just retry
+            // TODO: block/sleep a few ms to let the apparently full buffer drain ?
+            if (errno != EAGAIN && errno != EWOULDBLOCK)
+                fprintf(stderr,"ERROR: RADIUS send() failure: %s\n", xstrerror());
+            continue;
+        }
         while ((time_spent = time_since(&sent)) < 1000000) {
             struct timeval tv;
             int rc, len;
@@ -488,16 +494,20 @@ main(int argc, char **argv)
             cfname = optarg;
             break;
         case 'h':
-            strcpy(server, optarg);
+            strncpy(server, optarg, sizeof(server)-1);
+            server[sizeof(server)-1] = '\0';
             break;
         case 'p':
-            strcpy(svc_name, optarg);
+            strncpy(svc_name, optarg, sizeof(svc_name)-1);
+            svc_name[sizeof(svc_name)-1] = '\0';
             break;
         case 'w':
-            strcpy(secretkey, optarg);
+            strncpy(secretkey, optarg, sizeof(secretkey)-1);
+            secretkey[sizeof(secretkey)-1] = '\0';
             break;
         case 'i':
-            strcpy(identifier, optarg);
+            strncpy(identifier, optarg, sizeof(identifier)-1);
+            identifier[sizeof(identifier)-1] = '\0';
             break;
         case 't':
             retries = atoi(optarg);
@@ -565,7 +575,10 @@ main(int argc, char **argv)
         exit(1);
     }
 #ifdef O_NONBLOCK
-    fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL, 0) | O_NONBLOCK);
+    if (fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL, 0) | O_NONBLOCK) < 0) {
+        fprintf(stderr,"%s| ERROR: fcntl() failure: %s\n", argv[0], xstrerror());
+        exit(1);
+    }
 #endif
     nas_ipaddr = ntohl(salocal.sin_addr.s_addr);
     while (fgets(buf, HELPER_INPUT_BUFFER, stdin) != NULL) {
@@ -82,7 +82,11 @@ print_esc(FILE * p, char *s)
     int i = 0;
 
     for (t = s; *t != '\0'; ++t) {
-        if (i > HELPER_INPUT_BUFFER-2) {
+        /*
+         * NP: The shell escaping permits 'i' to jump up to 2 octets per loop,
+         *     so ensure we have at least 3 free.
+         */
+        if (i > HELPER_INPUT_BUFFER-3) {
             buf[i] = '\0';
             (void) fputs(buf, p);
             i = 0;
@@ -64,10 +64,10 @@ OutputHHA1(RequestData * requestData)
     requestData->error = 0;
     GetHHA1(requestData);
     if (requestData->error) {
-        SEND_ERR("No such user");
+        SEND_ERR("message=\"No such user\"");
         return;
     }
-    printf("%s\n", requestData->HHA1);
+    printf("OK ha1=\"%s\"\n", requestData->HHA1);
 }
 
 static void
@@ -76,7 +76,7 @@ DoOneRequest(char *buf)
     RequestData requestData;
     ParseBuffer(buf, &requestData);
     if (!requestData.parsed) {
-        SEND_ERR("");
+        SEND_BH("message=\"Invalid line received\"");
         return;
     }
     OutputHHA1(&requestData);
@@ -263,7 +263,8 @@ getpassword(char *login, char *realm)
             value = values;
             while (*value) {
                 if (encrpass) {
-                    if (strcmp(strtok(*value, delimiter), realm) == 0) {
+                    const char *t = strtok(*value, delimiter);
+                    if (t && strcmp(t, realm) == 0) {
                         password = strtok(NULL, delimiter);
                         break;
                     }
@@ -64,10 +64,10 @@ OutputHHA1(RequestData * requestData)
     requestData->error = 0;
     GetHHA1(requestData);
     if (requestData->error) {
-        SEND_ERR("No such user");
+        SEND_ERR("message=\"No such user\"");
         return;
     }
-    printf("%s\n", requestData->HHA1);
+    printf("OK ha1=\"%s\"\n", requestData->HHA1);
 }
 
 static void
@@ -76,7 +76,7 @@ DoOneRequest(char *buf)
     RequestData requestData;
     ParseBuffer(buf, &requestData);
     if (!requestData.parsed) {
-        SEND_ERR("");
+        SEND_BH("message=\"Invalid line received\"");
         return;
     }
     OutputHHA1(&requestData);
@@ -286,7 +286,8 @@ getpassword(char *login, char *realm)
             value = values;
             while (*value) {
                 if (encrpass) {
-                    if (strcmp(strtok(*value, delimiter), realm) == 0) {
+                    const char *t = strtok(*value, delimiter);
+                    if (t && strcmp(t, realm) == 0) {
                         password = strtok(NULL, delimiter);
                         break;
                     }
@@ -38,8 +38,6 @@
 #include "helpers/defines.h"
 #include "text_backend.h"
 
-#define PROGRAM_NAME "digest_file_auth"
-
 static void
 GetHHA1(RequestData * requestData)
 {
@@ -68,10 +66,10 @@ OutputHHA1(RequestData * requestData)
     requestData->error = 0;
     GetHHA1(requestData);
     if (requestData->error) {
-        SEND_ERR("No such user");
+        SEND_ERR("message=\"No such user\"");
         return;
     }
-    printf("%s\n", requestData->HHA1);
+    printf("OK ha1=\"%s\"\n", requestData->HHA1);
 }
 
 static void
@@ -80,7 +78,7 @@ DoOneRequest(char *buf)
     RequestData requestData;
     ParseBuffer(buf, &requestData);
     if (!requestData.parsed) {
-        SEND_ERR("");
+        SEND_BH("message=\"Invalid line received\"");
         return;
     }
     OutputHHA1(&requestData);
@@ -56,7 +56,6 @@ my_free(void *p)
 static void
 read_passwd_file(const char *passwordFile, int isHa1Mode)
 {
-    FILE *f;
     char buf[8192];
     user_data *u;
     char *user;
@@ -73,12 +72,22 @@ read_passwd_file(const char *passwordFile, int isHa1Mode)
         fprintf(stderr, "digest_file_auth: cannot create hash table\n");
         exit(1);
     }
-    f = fopen(passwordFile, "r");
-    while (fgets(buf, 8192, f) != NULL) {
+    FILE *f = fopen(passwordFile, "r");
+    if (!f) {
+        fprintf(stderr, "digest_file_auth: cannot open password file: %s\n", xstrerror());
+        exit(1);
+    }
+    unsigned int lineCount = 0;
+    while (fgets(buf, sizeof(buf), f) != NULL) {
+        ++lineCount;
         if ((buf[0] == '#') || (buf[0] == ' ') || (buf[0] == '\t') ||
                 (buf[0] == '\n'))
             continue;
         user = strtok(buf, ":\n");
+        if (!user) {
+            fprintf(stderr, "digest_file_auth: missing user name at line %u in '%s'\n", lineCount, passwordFile);
+            continue;
+        }
         realm = strtok(NULL, ":\n");
         passwd = strtok(NULL, ":\n");
         if (!passwd) {
@@ -151,10 +151,10 @@ while (<>) {
 
     print(stderr "Received: Channel=".$cid.", UID='".$uid."'\n") if ($debug);
 
-    $status = $cid . " ERR database error";
+    $status = $cid . " ERR message=\"database error\"";
     my $sth = query_db($uid) || next;
     print(stderr "Rows: ". $sth->rows()."\n") if ($debug);
-    $status = $cid . " ERR unknown UID '".$uid."'";
+    $status = $cid . " ERR message=\"unknown UID '".$uid."'\"";
     my $row = $sth->fetchrow_hashref() || next;
     $status = $cid . " OK" . ($row->{'user'} ne "" ? " user=" . $row->{'user'} : "" ) . ($row->{'tag'} ne "" ? " tag=" . $row->{'tag'} : "" );
     $sth->finish();
@@ -1178,10 +1178,7 @@ SearchLDAP(edui_ldap_t *l, int scope, char *filter, char **attrs)
     if (l->lm != NULL)
         ldap_msgfree(l->lm);						/* Make sure l->lm is empty */
 
-    if (filter == NULL)							/* if filter is NULL, then return ALL networkAddress */
-        xstrncpy(ft, "(&(objectClass=User)(networkAddress=*))", sizeof(ft));
-    else
-        xstrncpy(ft, filter, sizeof(ft));
+    xstrncpy(ft, filter, sizeof(ft));
 
     /* We have a binded connection, with a free l->lm, so let's get this done */
     switch (scope) {
@@ -1408,14 +1405,6 @@ SearchIPLDAP(edui_ldap_t *l)
         ldap_value_free_len(l->val);
         l->val = NULL;
     }
-    if (ber != NULL) {
-        ldap_value_free_len(ber);
-        ber = NULL;
-    }
-    if (ent != NULL) {
-        ldap_msgfree(ent);
-        ent = NULL;
-    }
     if (l->lm != NULL) {
         ldap_msgfree(l->lm);
         l->lm = NULL;
@@ -1776,7 +1765,7 @@ MainSafe(int argc, char **argv)
         /* No space given, but group string is required --> ERR */
         if ((edui_conf.mode & EDUI_MODE_GROUP) && (p == NULL)) {
             debug("while() -> Search group is missing. (required)\n");
-            local_printfx("ERR (Search Group Required)\n");
+            local_printfx("ERR message=\"(Search Group Required)\"\n");
             continue;
         }
         x = 0;
@@ -1819,7 +1808,7 @@ MainSafe(int argc, char **argv)
             if (x != LDAP_ERR_SUCCESS) {
                 /* Unable to bind */
                 debug("BindLDAP() -> %s (LDAP: %s)\n", ErrLDAP(x), ldap_err2string(edui_ldap.err));
-                local_printfx("ERR (BindLDAP: %s - %s)\n", ErrLDAP(x), ldap_err2string(edui_ldap.err));
+                local_printfx("ERR message=\"(BindLDAP: %s - %s)\"\n", ErrLDAP(x), ldap_err2string(edui_ldap.err));
                 continue;
             } else
                 debug("BindLDAP(-, %s, %s, (LDAP_AUTH_TLS)) -> %s\n", edui_conf.dn, edui_conf.passwd, ErrLDAP(x));
@@ -1830,7 +1819,7 @@ MainSafe(int argc, char **argv)
                 if (x != LDAP_ERR_SUCCESS) {
                     /* Unable to bind */
                     debug("BindLDAP() -> %s (LDAP: %s)\n", ErrLDAP(x), ldap_err2string(edui_ldap.err));
-                    local_printfx("ERR (BindLDAP: %s - %s)\n", ErrLDAP(x), ldap_err2string(edui_ldap.err));
+                    local_printfx("ERR message=\"(BindLDAP: %s - %s)\"\n", ErrLDAP(x), ldap_err2string(edui_ldap.err));
                     continue;
                 } else
                     debug("BindLDAP(-, %s, %s, (LDAP_AUTH_SIMPLE)) -> %s\n", edui_conf.dn, edui_conf.passwd, ErrLDAP(x));
@@ -1840,7 +1829,7 @@ MainSafe(int argc, char **argv)
                 if (x != LDAP_ERR_SUCCESS) {
                     /* Unable to bind */
                     debug("BindLDAP() -> %s (LDAP: %s)\n", ErrLDAP(x), ldap_err2string(edui_ldap.err));
-                    local_printfx("ERR (BindLDAP: %s - %s)\n", ErrLDAP(x), ldap_err2string(edui_ldap.err));
+                    local_printfx("ERR message=\"(BindLDAP: %s - %s)\"\n", ErrLDAP(x), ldap_err2string(edui_ldap.err));
                     continue;
                 } else
                     debug("BindLDAP(-, -, -, (LDAP_AUTH_NONE)) -> %s\n", ErrLDAP(x));
@@ -1859,7 +1848,7 @@ MainSafe(int argc, char **argv)
             /* Everything failed --> ERR */
             debug("while() -> %s (LDAP: %s)\n", ErrLDAP(x), ldap_err2string(edui_ldap.err));
             CloseLDAP(&edui_ldap);
-            local_printfx("ERR (General Failure: %s)\n", ErrLDAP(x));
+            local_printfx("ERR message=\"(General Failure: %s)\"\n", ErrLDAP(x));
             continue;
         }
         edui_ldap.err = -1;
@@ -1874,29 +1863,29 @@ MainSafe(int argc, char **argv)
                 x = ConvertIP(&edui_ldap, bufb);
                 if (x < 0) {
                     debug("ConvertIP() -> %s\n", ErrLDAP(x));
-                    local_printfx("ERR (ConvertIP: %s)\n", ErrLDAP(x));
+                    local_printfx("ERR message=\"(ConvertIP: %s)\"\n", ErrLDAP(x));
                 } else {
                     edui_ldap.err = -1;
                     debug("ConvertIP(-, %s) -> Result[%d]: %s\n", bufb, x, edui_ldap.search_ip);
                     x = SearchFilterLDAP(&edui_ldap, bufa);
                     if (x < 0) {
                         debug("SearchFilterLDAP() -> %s\n", ErrLDAP(x));
-                        local_printfx("ERR (SearchFilterLDAP: %s)\n", ErrLDAP(x));
+                        local_printfx("ERR message=\"(SearchFilterLDAP: %s)\"\n", ErrLDAP(x));
                     } else {
                         /* Do Search */
                         edui_ldap.err = -1;
                         debug("SearchFilterLDAP(-, %s) -> Length: %u\n", bufa, x);
                         x = SearchLDAP(&edui_ldap, edui_ldap.scope, edui_ldap.search_filter, (char **) &search_attrib);
                         if (x != LDAP_ERR_SUCCESS) {
                             debug("SearchLDAP() -> %s (LDAP: %s)\n", ErrLDAP(x), ldap_err2string(edui_ldap.err));
-                            local_printfx("ERR (SearchLDAP: %s)\n", ErrLDAP(x));
+                            local_printfx("ERR message=\"(SearchLDAP: %s)\"\n", ErrLDAP(x));
                         } else {
                             edui_ldap.err = -1;
                             debug("SearchLDAP(-, %d, %s, -) -> %s\n", edui_conf.scope, edui_ldap.search_filter, ErrLDAP(x));
                             x = SearchIPLDAP(&edui_ldap);
                             if (x != LDAP_ERR_SUCCESS) {
                                 debug("SearchIPLDAP() -> %s (LDAP: %s)\n", ErrLDAP(x), ldap_err2string(edui_ldap.err));
-                                local_printfx("ERR (SearchIPLDAP: %s)\n", ErrLDAP(x));
+                                local_printfx("ERR message=\"(SearchIPLDAP: %s)\"\n", ErrLDAP(x));
                             } else {
                                 debug("SearchIPLDAP(-, %s) -> %s\n", edui_ldap.userid, ErrLDAP(x));
                                 local_printfx("OK user=%s\n", edui_ldap.userid);			/* Got userid --> OK user=<userid> */
@@ -1908,35 +1897,35 @@ MainSafe(int argc, char **argv)
                 }
             } else {
                 debug("StringSplit() -> Error: %" PRIuSIZE "\n", i);
-                local_printfx("ERR (StringSplit Error %" PRIuSIZE ")\n", i);
+                local_printfx("ERR message=\"(StringSplit Error %" PRIuSIZE ")\"\n", i);
             }
         } else {
             /* No group to match against, only an IP */
             x = ConvertIP(&edui_ldap, bufa);
             if (x < 0) {
                 debug("ConvertIP() -> %s\n", ErrLDAP(x));
-                local_printfx("ERR (ConvertIP: %s)\n", ErrLDAP(x));
+                local_printfx("ERR message=\"(ConvertIP: %s)\"\n", ErrLDAP(x));
             } else {
                 debug("ConvertIP(-, %s) -> Result[%d]: %s\n", bufa, x, edui_ldap.search_ip);
                 /* Do search */
                 x = SearchFilterLDAP(&edui_ldap, NULL);
                 if (x < 0) {
                     debug("SearchFilterLDAP() -> %s\n", ErrLDAP(x));
-                    local_printfx("ERR (SearchFilterLDAP: %s)\n", ErrLDAP(x));
+                    local_printfx("ERR message=\"(SearchFilterLDAP: %s)\"\n", ErrLDAP(x));
                 } else {
                     edui_ldap.err = -1;
                     debug("SearchFilterLDAP(-, NULL) -> Length: %u\n", x);
                     x = SearchLDAP(&edui_ldap, edui_ldap.scope, edui_ldap.search_filter, (char **) &search_attrib);
                     if (x != LDAP_ERR_SUCCESS) {
                         debug("SearchLDAP() -> %s (LDAP: %s)\n", ErrLDAP(x), ldap_err2string(x));
-                        local_printfx("ERR (SearchLDAP: %s)\n", ErrLDAP(x));
+                        local_printfx("ERR message=\"(SearchLDAP: %s)\"\n", ErrLDAP(x));
                     } else {
                         edui_ldap.err = -1;
                         debug("SearchLDAP(-, %d, %s, -) -> %s\n", edui_conf.scope, edui_ldap.search_filter, ErrLDAP(x));
                         x = SearchIPLDAP(&edui_ldap);
                         if (x != LDAP_ERR_SUCCESS) {
                             debug("SearchIPLDAP() -> %s (LDAP: %s)\n", ErrLDAP(x), ldap_err2string(edui_ldap.err));
-                            local_printfx("ERR (SearchIPLDAP: %s)\n", ErrLDAP(x));
+                            local_printfx("ERR message=\"(SearchIPLDAP: %s)\"\n", ErrLDAP(x));
                         } else {
                             debug("SearchIPLDAP(-, %s) -> %s\n", edui_ldap.userid, ErrLDAP(x));
                             local_printfx("OK user=%s\n", edui_ldap.userid);				/* Got a userid --> OK user=<userid> */
@@ -75,27 +75,35 @@ load_dict(FILE * FH) {
 						   linked list */
     char line[DICT_BUFFER_SIZE]; /* the buffer for the lines read
 				   from the dict file */
-    char *cp;			/* a char pointer used to parse
-				   each line */
-    char *username;		/* for the username */
     char *tmpbuf;			/* for the address before the
 				   bitwise AND */
 
     /* the pointer to the first entry in the linked list */
     first_entry = (struct ip_user_dict*)malloc(sizeof(struct ip_user_dict));
     current_entry = first_entry;
 
-    while ((cp = fgets (line, DICT_BUFFER_SIZE, FH)) != NULL) {
+    unsigned int lineCount = 0;
+    while (fgets(line, sizeof(line), FH) != NULL) {
+        ++lineCount;
         if (line[0] == '#') {
             continue;
         }
+
+        char *cp; // a char pointer used to parse each line.
         if ((cp = strchr (line, '\n')) != NULL) {
             /* chop \n characters */
             *cp = '\0';
         }
-        if ((cp = strtok (line, "\t ")) != NULL) {
+        if (strtok(line, "\t ") != NULL) {
+            // NP: line begins with IP/mask. Skipped to the end of it with this strtok()
+
             /* get the username */
-            username = strtok (NULL, "\t ");
+            char *username;
+            if ((username = strtok(NULL, "\t ")) == NULL) {
+                debug("Missing username on line %u of dictionary file\n", lineCount);
+                continue;
+            }
+
             /* look for a netmask */
             if ((cp = strtok (line, "/")) != NULL) {
                 /* store the ip address in a temporary buffer */
@@ -209,7 +217,6 @@ usage(const char *program_name)
 int
 main (int argc, char *argv[])
 {
-    FILE *FH;
     char *filename = NULL;
     char *program_name = argv[0];
     char *cp;
@@ -241,7 +248,11 @@ main (int argc, char *argv[])
         usage(program_name);
         exit(1);
     }
-    FH = fopen(filename, "r");
+    FILE *FH = fopen(filename, "r");
+    if (!FH) {
+        fprintf(stderr, "%s: FATAL: Unable to open file '%s': %s", program_name, filename, xstrerror());
+        exit(1);
+    }
     current_entry = load_dict(FH);
 
     while (fgets(line, HELPER_INPUT_BUFFER, stdin)) {
@@ -24,6 +24,7 @@ ext_kerberos_ldap_group_acl_SOURCES = \
 
 ext_kerberos_ldap_group_acl_LDFLAGS =
 ext_kerberos_ldap_group_acl_LDADD = \
+	$(top_builddir)/lib/libmiscencoding.la \
 	$(COMPAT_LIB) \
 	$(LDAPLIB) \
 	$(LBERLIB) \
@@ -32,6 +32,7 @@
 #include "squid.h"
 #include "helpers/defines.h"
 #include "util.h"
+#include "rfc1738.h"
 
 #ifdef HAVE_LDAP
 
@@ -226,7 +227,8 @@ int
 main(int argc, char *const argv[])
 {
     char buf[6400];
-    char *user, *domain;
+    char *user, *domain, *group;
+    char *up=NULL, *dp=NULL, *np=NULL;
     char *nuser, *nuser8 = NULL, *netbios;
     char *c;
     int opt;
@@ -334,11 +336,17 @@ main(int argc, char *const argv[])
     }
 
     debug((char *) "%s| %s: INFO: Starting version %s\n", LogTime(), PROGRAM, KERBEROS_LDAP_GROUP_VERSION);
+    int gopt = 0;
     if (create_gd(&margs)) {
-        debug((char *) "%s| %s: FATAL: Error in group list: %s\n", LogTime(), PROGRAM, margs.glist ? margs.glist : "NULL");
-        SEND_ERR("");
-        clean_args(&margs);
-        exit(1);
+        if ( margs.glist != NULL ) {
+            debug((char *) "%s| %s: FATAL: Error in group list: %s\n", LogTime(), PROGRAM, margs.glist ? margs.glist : "NULL");
+            SEND_ERR("");
+            clean_args(&margs);
+            exit(1);
+        } else {
+            debug((char *) "%s| %s: INFO: no group list given expect it from stdin\n", LogTime(), PROGRAM);
+            gopt = 1;
+        }
     }
     if (create_nd(&margs)) {
         debug((char *) "%s| %s: FATAL: Error in netbios list: %s\n", LogTime(), PROGRAM, margs.nlist ? margs.nlist : "NULL");
@@ -370,12 +378,18 @@ main(int argc, char *const argv[])
         if (c) {
             *c = '\0';
         } else {
-            SEND_ERR("");
+            SEND_ERR("Invalid input. CR missing");
             debug((char *) "%s| %s: ERR\n", LogTime(), PROGRAM);
             continue;
         }
 
-        user = buf;
+        user = strtok(buf, " \n");
+        if (!user) {
+            debug((char *) "%s| %s: INFO: No Username given\n", LogTime(), PROGRAM);
+            SEND_ERR("Invalid request. No Username");
+            continue;
+        }
+        rfc1738_unescape(user);
         nuser = strchr(user, '\\');
         if (!nuser)
             nuser8 = strstr(user, "%5C");
@@ -391,33 +405,62 @@ main(int argc, char *const argv[])
                 nuser = nuser8 + 3;
             }
             netbios = user;
+            up = xstrdup(rfc1738_escape(nuser));
+            np = xstrdup(rfc1738_escape(netbios));
             if (debug_enabled)
-                debug((char *) "%s| %s: INFO: Got User: %s Netbios Name: %s\n", LogTime(), PROGRAM, nuser, netbios);
+                debug((char *) "%s| %s: INFO: Got User: %s Netbios Name: %s\n", LogTime(), PROGRAM, up, np);
             else
-                log((char *) "%s| %s: INFO: Got User: %s Netbios Name: %s\n", LogTime(), PROGRAM, nuser, netbios);
+                log((char *) "%s| %s: INFO: Got User: %s Netbios Name: %s\n", LogTime(), PROGRAM, up, np);
             domain = get_netbios_name(&margs, netbios);
             user = nuser;
+            xfree(up);
+            xfree(np);
         } else if (domain) {
             strup(domain);
             *domain = '\0';
             ++domain;
         }
+        up = xstrdup(rfc1738_escape(user));
+        if (domain)
+            dp = xstrdup(rfc1738_escape(domain));
         if (!domain && margs.ddomain) {
             domain = xstrdup(margs.ddomain);
             if (debug_enabled)
-                debug((char *) "%s| %s: INFO: Got User: %s set default domain: %s\n", LogTime(), PROGRAM, user, domain);
+                debug((char *) "%s| %s: INFO: Got User: %s set default domain: %s\n", LogTime(), PROGRAM, up, dp);
             else
-                log((char *) "%s| %s: INFO: Got User: %s set default domain: %s\n", LogTime(), PROGRAM, user, domain);
+                log((char *) "%s| %s: INFO: Got User: %s set default domain: %s\n", LogTime(), PROGRAM, up, dp);
         }
         if (debug_enabled)
-            debug((char *) "%s| %s: INFO: Got User: %s Domain: %s\n", LogTime(), PROGRAM, user, domain ? domain : "NULL");
+            debug((char *) "%s| %s: INFO: Got User: %s Domain: %s\n", LogTime(), PROGRAM, up, domain ? dp : "NULL");
         else
-            log((char *) "%s| %s: INFO: Got User: %s Domain: %s\n", LogTime(), PROGRAM, user, domain ? domain : "NULL");
+            log((char *) "%s| %s: INFO: Got User: %s Domain: %s\n", LogTime(), PROGRAM, up, domain ? dp : "NULL");
 
+        xfree(up);
+        xfree(dp);
         if (!strcmp(user, "QQ") && domain && !strcmp(domain, "QQ")) {
             clean_args(&margs);
             exit(-1);
         }
+        if (gopt) {
+            if ((group = strtok(NULL, " \n")) != NULL) {
+                debug((char *) "%s| %s: INFO: Read group list %s from stdin\n", LogTime(), PROGRAM, group);
+                rfc1738_unescape(group);
+                if (margs.groups) {
+                    clean_gd(margs.groups);
+                    margs.groups = NULL;
+                }
+                margs.glist = xstrdup(group);
+                if (create_gd(&margs)) {
+                    SEND_ERR("Error in group list");
+                    debug((char *) "%s| %s: FATAL: Error in group list: %s\n", LogTime(), PROGRAM, margs.glist ? margs.glist : "NULL");
+                    continue;
+                }
+            } else {
+                SEND_ERR("No group list received on stdin");
+                debug((char *) "%s| %s: FATAL: No group list received on stdin\n", LogTime(), PROGRAM);
+                continue;
+            }
+        }
         if (check_memberof(&margs, user, domain)) {
             SEND_OK("");
             debug((char *) "%s| %s: DEBUG: OK\n", LogTime(), PROGRAM);
@@ -42,6 +42,18 @@ init_gd(void) {
     return gdsp;
 }
 
+void
+free_gd(struct gdstruct *gdsp)
+{
+    while (gdsp) {
+        struct gdstruct *gdspn = gdsp->next;
+        xfree(gdsp->group);
+        xfree(gdsp->domain);
+        xfree(gdsp);
+        gdsp = gdspn;
+    }
+}
+
 char *utf8dup(struct main_args *margs);
 
 char *
@@ -101,35 +113,24 @@ char *hex_utf_char(struct main_args *margs, int flag);
 char *
 hex_utf_char(struct main_args *margs, int flag)
 {
-    char *up;
-    char *upd;
-    char *ul;
-    int a, n, nl, ival, ichar;
+    int ival, ichar;
     int iUTF2, iUTF3, iUTF4;
 
-    if (flag) {
-        up = margs->ulist;
-    } else {
-        up = margs->tlist;
-    }
-
+    char *up = (flag ? margs->ulist : margs->tlist);
     if (!up)
         return NULL;
 
-    upd = strrchr(up, '@');
-    if (upd)
-        a = upd - up;
-    else
-        a = strlen(up);
+    char *upd = strrchr(up, '@');
+    size_t a = (upd ? (upd - up) : strlen(up) );
 
-    ul = (char *) xmalloc(strlen(up));
-    n = 0;
-    nl = 0;
+    char *ul = (char *) xmalloc(strlen(up)+1);
+    size_t n = 0;
+    int nl = 0;
     iUTF2 = 0;
     iUTF3 = 0;
     iUTF4 = 0;
 
-    while (n < (int) strlen(up)) {
+    while (n < strlen(up)) {
         if (flag && n == a)
             break;
         if (up[n] == '@') {
@@ -147,15 +148,13 @@ hex_utf_char(struct main_args *margs, int flag)
             ichar = (ival - 48) * 16;
         else {
             debug((char *) "%s| %s: WARNING: Invalid Hex value %c\n", LogTime(), PROGRAM, ival);
-            if (ul)
-                xfree(ul);
+            xfree(ul);
             return NULL;
         }
 
         if (n == a - 1) {
             debug((char *) "%s| %s: WARNING: Invalid Hex UTF-8 string %s\n", LogTime(), PROGRAM, up);
-            if (ul)
-                xfree(ul);
+            xfree(ul);
             return NULL;
         }
         ++n;
@@ -168,8 +167,7 @@ hex_utf_char(struct main_args *margs, int flag)
             ichar = ichar + ival - 48;
         else {
             debug((char *) "%s| %s: WARNING: Invalid Hex value %c\n", LogTime(), PROGRAM, ival);
-            if (ul)
-                xfree(ul);
+            xfree(ul);
             return NULL;
         }
 
@@ -189,8 +187,7 @@ hex_utf_char(struct main_args *margs, int flag)
                 ul[nl] = ichar;
                 ul[nl + 1] = '\0';
                 debug((char *) "%s| %s: WARNING: Invalid UTF-8 sequence for Unicode %s\n", LogTime(), PROGRAM, ul);
-                if (ul)
-                    xfree(ul);
+                xfree(ul);
                 return NULL;
             }
         } else if (iUTF3) {
@@ -219,8 +216,7 @@ hex_utf_char(struct main_args *margs, int flag)
                 ul[nl] = ichar;
                 ul[nl + 1] = '\0';
                 debug((char *) "%s| %s: WARNING: Invalid UTF-8 sequence for Unicode %s\n", LogTime(), PROGRAM, ul);
-                if (ul)
-                    xfree(ul);
+                xfree(ul);
                 return NULL;
             }
         } else if (iUTF4) {
@@ -248,8 +244,7 @@ hex_utf_char(struct main_args *margs, int flag)
                 ul[nl] = ichar;
                 ul[nl + 1] = '\0';
                 debug((char *) "%s| %s: WARNING: Invalid UTF-8 sequence for Unicode %s\n", LogTime(), PROGRAM, ul);
-                if (ul)
-                    xfree(ul);
+                xfree(ul);
                 return NULL;
             }
         } else if (ichar < 0x80) {
@@ -275,8 +270,7 @@ hex_utf_char(struct main_args *margs, int flag)
             ul[nl] = ichar;
             ul[nl + 1] = '\0';
             debug((char *) "%s| %s: WARNING: Invalid UTF-8 sequence for Unicode %s\n", LogTime(), PROGRAM, ul);
-            if (ul)
-                xfree(ul);
+            xfree(ul);
             return NULL;
         }
         ++n;
@@ -286,8 +280,7 @@ hex_utf_char(struct main_args *margs, int flag)
     if (iUTF2 || iUTF3 || iUTF4) {
         debug((char *) "%s| %s: INFO: iUTF2: %d iUTF3: %d iUTF4: %d\n", LogTime(), PROGRAM, iUTF2, iUTF3, iUTF4);
         debug((char *) "%s| %s: WARNING: Invalid UTF-8 sequence for Unicode %s\n", LogTime(), PROGRAM, ul);
-        if (ul)
-            xfree(ul);
+        xfree(ul);
         return NULL;
     }
     if (flag && upd)
@@ -299,7 +292,6 @@ int
 create_gd(struct main_args *margs)
 {
     char *gp, *dp;
-    char *hp1, *hp2, *up;
     char *p;
     struct gdstruct *gdsp = NULL, *gdspn = NULL;
     /*
@@ -321,28 +313,43 @@ create_gd(struct main_args *margs)
      *
      *
      */
-    hp1 = hex_utf_char(margs, 0);
-    hp2 = hex_utf_char(margs, 1);
-    up = utf8dup(margs);
+    char *hp1 = hex_utf_char(margs, 0);
+    char *hp2 = hex_utf_char(margs, 1);
+    char *up = utf8dup(margs);
+
+    // NP: will point to the start of a temporary assembly buffer used by 'p' and 'gp'
+    //     for catenation of the hp1, hp2, and up buffer contents from above.
+    //     necessary for xfree() because both p and gp move over the assembly area
+    char *gpbuf = NULL;
+
+    // release the allocated UTF decoding buffers
+#define cleanup() { \
+    xfree(gpbuf); \
+    xfree(hp1); \
+    xfree(hp2); \
+    xfree(up); \
+    free_gd(gdsp); \
+ }
+
     p = up;
     if (hp1) {
         if (hp2) {
             if (up) {
-                p = (char *) xmalloc(strlen(up) + strlen(hp1) + strlen(hp2) + 2);
+                gpbuf = p = (char *) xmalloc(strlen(up) + strlen(hp1) + strlen(hp2) + 2);
                 strcpy(p, up);
                 strcat(p, ":");
                 strcat(p, hp1);
                 strcat(p, ":");
                 strcat(p, hp2);
             } else {
-                p = (char *) xmalloc(strlen(hp1) + strlen(hp2) + 1);
+                gpbuf = p = (char *) xmalloc(strlen(hp1) + strlen(hp2) + 1);
                 strcpy(p, hp1);
                 strcat(p, ":");
                 strcat(p, hp2);
             }
         } else {
             if (up) {
-                p = (char *) xmalloc(strlen(up) + strlen(hp1) + 1);
+                gpbuf = p = (char *) xmalloc(strlen(up) + strlen(hp1) + 1);
                 strcpy(p, up);
                 strcat(p, ":");
                 strcat(p, hp1);
@@ -352,7 +359,7 @@ create_gd(struct main_args *margs)
     } else {
         if (hp2) {
             if (up) {
-                p = (char *) xmalloc(strlen(up) + strlen(hp2) + 1);
+                gpbuf = p = (char *) xmalloc(strlen(up) + strlen(hp2) + 1);
                 strcpy(p, up);
                 strcat(p, ":");
                 strcat(p, hp2);
@@ -367,6 +374,7 @@ create_gd(struct main_args *margs)
 
     if (!p) {
         debug((char *) "%s| %s: ERROR: No groups defined.\n", LogTime(), PROGRAM);
+        cleanup();
         return (1);
     }
     while (*p) {		/* loop over group list */
@@ -377,18 +385,19 @@ create_gd(struct main_args *margs)
         if (*p == '@') {	/* end of group name - start of domain name */
             if (p == gp) {	/* empty group name not allowed */
                 debug((char *) "%s| %s: ERROR: No group defined for domain %s\n", LogTime(), PROGRAM, p);
+                cleanup();
                 return (1);
             }
             *p = '\0';
             ++p;
             gdsp = init_gd();
-            gdsp->group = gp;
-            if (gdspn)		/* Have already an existing structure */
-                gdsp->next = gdspn;
+            gdsp->group = xstrdup(gp);
+            gdsp->next = gdspn;
             dp = p;		/* after @ starts new domain name */
         } else if (*p == ':') {	/* end of group name or end of domain name */
             if (p == gp) {	/* empty group name not allowed */
                 debug((char *) "%s| %s: ERROR: No group defined for domain %s\n", LogTime(), PROGRAM, p);
+                cleanup();
                 return (1);
             }
             *p = '\0';
@@ -398,9 +407,8 @@ create_gd(struct main_args *margs)
                 dp = NULL;
             } else {		/* end of group name and no domain name */
                 gdsp = init_gd();
-                gdsp->group = gp;
-                if (gdspn)	/* Have already an existing structure */
-                    gdsp->next = gdspn;
+                gdsp->group = xstrdup(gp);
+                gdsp->next = gdspn;
             }
             gdspn = gdsp;
             gp = p;		/* after : starts new group name */
@@ -410,19 +418,22 @@ create_gd(struct main_args *margs)
     }
     if (p == gp) {		/* empty group name not allowed */
         debug((char *) "%s| %s: ERROR: No group defined for domain %s\n", LogTime(), PROGRAM, p);
+        cleanup();
         return (1);
     }
     if (dp) {			/* end of domain name */
         gdsp->domain = xstrdup(dp);
     } else {			/* end of group name and no domain name */
         gdsp = init_gd();
-        gdsp->group = gp;
+        gdsp->group = xstrdup(gp);
         if (gdspn)		/* Have already an existing structure */
             gdsp->next = gdspn;
     }
     debug((char *) "%s| %s: INFO: Group %s  Domain %s\n", LogTime(), PROGRAM, gdsp->group, gdsp->domain ? gdsp->domain : "NULL");
 
     margs->groups = gdsp;
+    gdsp = NULL; // prevent the cleanup() deallocating it.
+    cleanup();
     return (0);
 }
 #endif
@@ -369,19 +369,18 @@ search_group_tree(struct main_args *margs, LDAP * ld, char *bindp, char *ldap_gr
     search_exp = (char *) xmalloc(strlen(filter) + strlen(ldap_filter_esc) + 1);
     snprintf(search_exp, strlen(filter) + strlen(ldap_filter_esc) + 1, filter, ldap_filter_esc);
 
-    if (ldap_filter_esc)
-        xfree(ldap_filter_esc);
+    xfree(ldap_filter_esc);
 
     if (depth > margs->mdepth) {
         debug((char *) "%s| %s: DEBUG: Max search depth reached %d>%d\n", LogTime(), PROGRAM, depth, margs->mdepth);
+        xfree(search_exp);
         return 0;
     }
     debug((char *) "%s| %s: DEBUG: Search ldap server with bind path %s and filter : %s\n", LogTime(), PROGRAM, bindp, search_exp);
     rc = ldap_search_ext_s(ld, bindp, LDAP_SCOPE_SUBTREE,
                            search_exp, NULL, 0,
                            NULL, NULL, &searchtime, 0, &res);
-    if (search_exp)
-        xfree(search_exp);
+    xfree(search_exp);
 
     if (rc != LDAP_SUCCESS) {
         error((char *) "%s| %s: ERROR: Error searching ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
@@ -673,22 +672,16 @@ tool_ldap_open(struct main_args * margs, char *host, int port, char *ssl)
     rc = ldap_url_parse(ldapuri, &url);
     if (rc != LDAP_SUCCESS) {
         error((char *) "%s| %s: ERROR: Error while parsing url: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
-        if (ldapuri)
-            xfree(ldapuri);
-        if (url)
-            xfree(url);
+        xfree(ldapuri);
+        xfree(url);
         return NULL;
     }
 #else
 #error "No URL parsing function"
 #endif
-    if (url) {
-        xfree(url);
-        url = NULL;
-    }
+    safe_free(url);
     rc = ldap_initialize(&ld, ldapuri);
-    if (ldapuri)
-        xfree(ldapuri);
+    xfree(ldapuri);
     if (rc != LDAP_SUCCESS) {
         error((char *) "%s| %s: ERROR: Error while initialising connection to ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
         ldap_unbind(ld);
@@ -744,22 +737,16 @@ tool_ldap_open(struct main_args * margs, char *host, int port, char *ssl)
             rc = ldap_url_parse(ldapuri, &url);
             if (rc != LDAP_SUCCESS) {
                 error((char *) "%s| %s: ERROR: Error while parsing url: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
-                if (ldapuri)
-                    xfree(ldapuri);
-                if (url)
-                    xfree(url);
+                xfree(ldapuri);
+                xfree(url);
                 return NULL;
             }
 #else
 #error "No URL parsing function"
 #endif
-            if (url) {
-                xfree(url);
-                url = NULL;
-            }
+            safe_free(url);
             rc = ldap_initialize(&ld, ldapuri);
-            if (ldapuri)
-                xfree(ldapuri);
+            xfree(ldapuri);
             if (rc != LDAP_SUCCESS) {
                 error((char *) "%s| %s: ERROR: Error while initialising connection to ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
                 ldap_unbind(ld);
@@ -897,7 +884,7 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
                 continue;
             }
             lcreds = (ldap_creds *) xmalloc(sizeof(struct ldap_creds));
-            lcreds->dn = bindp ? xstrdup(bindp) : NULL;
+            lcreds->dn = NULL;
             lcreds->pw = margs->ssl ? xstrdup(margs->ssl) : NULL;
             ldap_set_rebind_proc(ld, ldap_sasl_rebind, (char *) lcreds);
             if (ld != NULL) {
@@ -938,9 +925,7 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
             port = atoi(p);
         }
         nhosts = get_hostname_list(margs, &hlist, 0, host);
-        if (host)
-            xfree(host);
-        host = NULL;
+        safe_free(host);
         for (i = 0; i < nhosts; ++i) {
 
             ld = tool_ldap_open(margs, hlist[i].host, port, ssl);
@@ -967,8 +952,7 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
 
         }
         nhosts = free_hostname_list(&hlist, nhosts);
-        if (bindp)
-            xfree(bindp);
+        xfree(bindp);
         if (margs->lbind) {
             bindp = xstrdup(margs->lbind);
         } else {
@@ -1005,15 +989,13 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
     search_exp = (char *) xmalloc(strlen(filter) + strlen(ldap_filter_esc) + 1);
     snprintf(search_exp, strlen(filter) + strlen(ldap_filter_esc) + 1, filter, ldap_filter_esc);
 
-    if (ldap_filter_esc)
-        xfree(ldap_filter_esc);
+    xfree(ldap_filter_esc);
 
     debug((char *) "%s| %s: DEBUG: Search ldap server with bind path %s and filter : %s\n", LogTime(), PROGRAM, bindp, search_exp);
     rc = ldap_search_ext_s(ld, bindp, LDAP_SCOPE_SUBTREE,
                            search_exp, NULL, 0,
                            NULL, NULL, &searchtime, 0, &res);
-    if (search_exp)
-        xfree(search_exp);
+    xfree(search_exp);
 
     if (rc != LDAP_SUCCESS) {
         error((char *) "%s| %s: ERROR: Error searching ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
@@ -1121,15 +1103,13 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
         search_exp = (char *) xmalloc(strlen(filter) + strlen(ldap_filter_esc) + 1);
         snprintf(search_exp, strlen(filter) + strlen(ldap_filter_esc) + 1, filter, ldap_filter_esc);
 
-        if (ldap_filter_esc)
-            xfree(ldap_filter_esc);
+        xfree(ldap_filter_esc);
 
         debug((char *) "%s| %s: DEBUG: Search ldap server with bind path %s and filter: %s\n", LogTime(), PROGRAM, bindp, search_exp);
         rc = ldap_search_ext_s(ld, bindp, LDAP_SCOPE_SUBTREE,
                                search_exp, NULL, 0,
                                NULL, NULL, &searchtime, 0, &res);
-        if (search_exp)
-            xfree(search_exp);
+        xfree(search_exp);
 
         debug((char *) "%s| %s: DEBUG: Found %d ldap entr%s\n", LogTime(), PROGRAM, ldap_count_entries(ld, res), ldap_count_entries(ld, res) > 1 || ldap_count_entries(ld, res) == 0 ? "ies" : "y");
 
@@ -1147,15 +1127,13 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
             search_exp = (char *) xmalloc(strlen(filter) + strlen(ldap_filter_esc) + 1);
             snprintf(search_exp, strlen(filter) + strlen(ldap_filter_esc) + 1, filter, ldap_filter_esc);
 
-            if (ldap_filter_esc)
-                xfree(ldap_filter_esc);
+            xfree(ldap_filter_esc);
 
             debug((char *) "%s| %s: DEBUG: Search ldap server with bind path %s and filter: %s\n", LogTime(), PROGRAM, bindp, search_exp);
             rc = ldap_search_ext_s(ld, bindp, LDAP_SCOPE_SUBTREE,
                                    search_exp, NULL, 0,
                                    NULL, NULL, &searchtime, 0, &res);
-            if (search_exp)
-                xfree(search_exp);
+            xfree(search_exp);
 
             max_attr_2 = get_attributes(margs, ld, res, ATTRIBUTE, &attr_value_2);
             /*
@@ -1212,16 +1190,11 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
         krb5_cleanup();
 #endif
     if (lcreds) {
-        if (lcreds->dn)
-            xfree(lcreds->dn);
-        if (lcreds->pw)
-            xfree(lcreds->pw);
+        xfree(lcreds->dn);
+        xfree(lcreds->pw);
         xfree(lcreds);
     }
-    if (bindp)
-        xfree(bindp);
-    bindp = NULL;
+    xfree(bindp);
     return (retval);
-
 }
 #endif
@@ -40,6 +40,18 @@ init_ls(void) {
     return lssp;
 }
 
+void
+free_ls(struct lsstruct *lssp)
+{
+    while (lssp) {
+        struct lsstruct *lsspn = lssp->next;
+        xfree(lssp->lserver);
+        xfree(lssp->domain);
+        xfree(lssp);
+        lssp = lsspn;
+    }
+}
+
 int
 create_ls(struct main_args *margs)
 {
@@ -73,18 +85,19 @@ create_ls(struct main_args *margs)
         if (*p == '@') {	/* end of group name - start of domain name */
             if (p == np) {	/* empty group name not allowed */
                 debug((char *) "%s| %s: DEBUG: No ldap servers defined for domain %s\n", LogTime(), PROGRAM, p);
+                free_ls(lssp);
                 return (1);
             }
             *p = '\0';
             ++p;
             lssp = init_ls();
             lssp->lserver = xstrdup(np);
-            if (lsspn)		/* Have already an existing structure */
-                lssp->next = lsspn;
+            lssp->next = lsspn;
             dp = p;		/* after @ starts new domain name */
         } else if (*p == ':') {	/* end of group name or end of domain name */
             if (p == np) {	/* empty group name not allowed */
                 debug((char *) "%s| %s: DEBUG: No ldap servers defined for domain %s\n", LogTime(), PROGRAM, p);
+                free_ls(lssp);
                 return (1);
             }
             *p = '\0';
@@ -95,8 +108,7 @@ create_ls(struct main_args *margs)
             } else {		/* end of group name and no domain name */
                 lssp = init_ls();
                 lssp->lserver = xstrdup(np);
-                if (lsspn)	/* Have already an existing structure */
-                    lssp->next = lsspn;
+                lssp->next = lsspn;
             }
             lsspn = lssp;
             np = p;		/* after : starts new group name */
@@ -106,6 +118,7 @@ create_ls(struct main_args *margs)
     }
     if (p == np) {		/* empty group name not allowed */
         debug((char *) "%s| %s: DEBUG: No ldap servers defined for domain %s\n", LogTime(), PROGRAM, p);
+        free_ls(lssp);
         return (1);
     }
     if (dp) {			/* end of domain name */
@@ -41,6 +41,18 @@ init_nd(void) {
     return ndsp;
 }
 
+void
+free_nd(struct ndstruct *ndsp)
+{
+    while (ndsp) {
+        struct ndstruct *ndspn = ndsp->next;
+        xfree(ndsp->netbios);
+        xfree(ndsp->domain);
+        xfree(ndsp);
+        ndsp = ndspn;
+    }
+}
+
 int
 create_nd(struct main_args *margs)
 {
@@ -74,18 +86,19 @@ create_nd(struct main_args *margs)
         if (*p == '@') {	/* end of group name - start of domain name */
             if (p == np) {	/* empty group name not allowed */
                 debug((char *) "%s| %s: DEBUG: No netbios name defined for domain %s\n", LogTime(), PROGRAM, p);
+                free_nd(ndsp);
                 return (1);
             }
             *p = '\0';
             ++p;
             ndsp = init_nd();
             ndsp->netbios = xstrdup(np);
-            if (ndspn)		/* Have already an existing structure */
-                ndsp->next = ndspn;
+            ndsp->next = ndspn;
             dp = p;		/* after @ starts new domain name */
         } else if (*p == ':') {	/* end of group name or end of domain name */
             if (p == np) {	/* empty group name not allowed */
                 debug((char *) "%s| %s: DEBUG: No netbios name defined for domain %s\n", LogTime(), PROGRAM, p);
+                free_nd(ndsp);
                 return (1);
             }
             *p = '\0';
@@ -96,13 +109,13 @@ create_nd(struct main_args *margs)
             } else {		/* end of group name and no domain name */
                 ndsp = init_nd();
                 ndsp->netbios = xstrdup(np);
-                if (ndspn)	/* Have already an existing structure */
-                    ndsp->next = ndspn;
+                ndsp->next = ndspn;
             }
             ndspn = ndsp;
             np = p;		/* after : starts new group name */
             if (!ndsp->domain || !strcmp(ndsp->domain, "")) {
                 debug((char *) "%s| %s: DEBUG: No domain defined for netbios name %s\n", LogTime(), PROGRAM, ndsp->netbios);
+                free_nd(ndsp);
                 return (1);
             }
             debug((char *) "%s| %s: DEBUG: Netbios name %s  Domain %s\n", LogTime(), PROGRAM, ndsp->netbios, ndsp->domain);
@@ -111,18 +124,19 @@ create_nd(struct main_args *margs)
     }
     if (p == np) {		/* empty group name not allowed */
         debug((char *) "%s| %s: DEBUG: No netbios name defined for domain %s\n", LogTime(), PROGRAM, p);
+        free_nd(ndsp);
         return (1);
     }
     if (dp) {			/* end of domain name */
         ndsp->domain = xstrdup(dp);
     } else {			/* end of group name and no domain name */
         ndsp = init_nd();
         ndsp->netbios = xstrdup(np);
-        if (ndspn)		/* Have already an existing structure */
-            ndsp->next = ndspn;
+        ndsp->next = ndspn;
     }
     if (!ndsp->domain || !strcmp(ndsp->domain, "")) {
         debug((char *) "%s| %s: DEBUG: No domain defined for netbios name %s\n", LogTime(), PROGRAM, ndsp->netbios);
+        free_nd(ndsp);
         return (1);
     }
     debug((char *) "%s| %s: DEBUG: Netbios name %s  Domain %s\n", LogTime(), PROGRAM, ndsp->netbios, ndsp->domain);
@@ -264,21 +264,28 @@ static void readConfig(const char *filename)
     FH = fopen(filename, "r");
     if ( FH ) {
         /* the pointer to the first entry in the linked list */
-        while ((cp = fgets (line, sizeof(line), FH)) != NULL) {
+        unsigned int lineCount = 0;
+        while (fgets(line, sizeof(line), FH)) {
+            ++lineCount;
             if (line[0] == '#') {
                 continue;
             }
             if ((cp = strchr (line, '\n')) != NULL) {
                 /* chop \n characters */
                 *cp = '\0';
             }
-            log_debug("read config line \"%s\".\n", line);
-            if ((cp = strtok (line, "\t ")) != NULL) {
-                username = cp;
+            log_debug("read config line %u: \"%s\".\n", lineCount, line);
+            if ((username = strtok(line, "\t ")) != NULL) {
 
                 /* get the time budget */
-                budget = strtok (NULL, "/");
-                period = strtok (NULL, "/");
+                if ((budget = strtok(NULL, "/")) == NULL) {
+                    fprintf(stderr, "ERROR: missing 'budget' field on line %u of '%s'.\n", lineCount, filename);
+                    continue;
+                }
+                if ((period = strtok(NULL, "/")) == NULL) {
+                    fprintf(stderr, "ERROR: missing 'period' field on line %u of '%s'.\n", lineCount, filename);
+                    continue;
+                }
 
                 parseTime(budget, &budgetSecs, &start);
                 parseTime(period, &periodSecs, &start);
@@ -437,10 +444,12 @@ int main(int argc, char **argv)
 
     log_info("Waiting for requests...\n");
     while (fgets(request, HELPER_INPUT_BUFFER, stdin)) {
-        // we expect the following line syntax: "%LOGIN
-        const char *user_key = NULL;
-        user_key = strtok(request, " \n");
-
+        // we expect the following line syntax: %LOGIN
+        const char *user_key = strtok(request, " \n");
+        if (!user_key) {
+            SEND_BH("message=\"User name missing\"");
+            continue;
+        }
         processActivity(user_key);
     }
     log_info("Ending %s\n", __FILE__);
@@ -57,16 +57,24 @@ rotate(const char *path, int rotate_count)
         snprintf(from, MAXPATHLEN, "%s.%d", path, i - 1);
         snprintf(to, MAXPATHLEN, "%s.%d", path, i);
 #if _SQUID_OS2_ || _SQUID_WINDOWS_
-        remove(to);
+        if (remove(to) < 0) {
+            fprintf(stderr, "WARNING: remove '%s' failure: %s\n", to, xstrerror());
+        }
 #endif
-        rename(from, to);
+        if (rename(path, to) < 0 && errno != ENOENT) {
+            fprintf(stderr, "WARNING: rename '%s' to '%s' failure: %s\n", path, to, xstrerror());
+        }
     }
     if (rotate_count > 0) {
         snprintf(to, MAXPATHLEN, "%s.%d", path, 0);
 #if _SQUID_OS2_ || _SQUID_WINDOWS_
-        remove(to);
+        if (remove(to) < 0) {
+            fprintf(stderr, "WARNING: remove '%s' failure: %s\n", to, xstrerror());
+        }
 #endif
-        rename(path, to);
+        if (rename(path, to) < 0 && errno != ENOENT) {
+            fprintf(stderr, "WARNING: rename %s to %s failure: %s\n", path, to, xstrerror());
+        }
     }
 }
 
@@ -119,7 +127,7 @@ main(int argc, char *argv[])
                      * out of device space - recover by rotating and hoping that rotation count drops a big one.
                      */
                     if (err == EFBIG || err == ENOSPC) {
-                        fprintf(stderr, "WARNING: %s writing %s. Attempting to recover via a log rotation.\n",strerror(err),argv[1]);
+                        fprintf(stderr, "WARNING: %s writing %s. Attempting to recover via a log rotation.\n",xstrerr(err),argv[1]);
                         fclose(fp);
                         rotate(argv[1], rotate_count);
                         fp = fopen(argv[1], "a");
@@ -30,6 +30,7 @@
  * Hosted at http://sourceforge.net/projects/squidkerbauth
  */
 #include "squid.h"
+#include "rfc1738.h"
 #include "compat/getaddrinfo.h"
 #include "compat/getnameinfo.h"
 
@@ -119,7 +120,7 @@ gethost_name(void)
     struct addrinfo *hres = NULL, *hres_list;
     int rc, count;
 
-    rc = gethostname(hostname, sysconf(_SC_HOST_NAME_MAX));
+    rc = gethostname(hostname, sizeof(hostname)-1);
     if (rc) {
         fprintf(stderr, "%s| %s: ERROR: resolving hostname '%s' failed\n",
                 LogTime(), PROGRAM, hostname);
@@ -148,7 +149,7 @@ gethost_name(void)
         return NULL;
     }
     freeaddrinfo(hres);
-    hostname[sysconf(_SC_HOST_NAME_MAX) - 1] = '\0';
+    hostname[sizeof(hostname)-1] = '\0';
     return (xstrdup(hostname));
 }
 
@@ -458,10 +459,10 @@ main(int argc, char *const argv[])
                 *p = '\0';
             }
             fprintf(stdout, "AF %s %s\n", token, user);
-            debug((char *) "%s| %s: DEBUG: AF %s %s\n", LogTime(), PROGRAM, token, user);
+            debug((char *) "%s| %s: DEBUG: AF %s %s\n", LogTime(), PROGRAM, token, rfc1738_escape(user));
             if (log)
                 fprintf(stderr, "%s| %s: INFO: User %s authenticated\n", LogTime(),
-                        PROGRAM, user);
+                        PROGRAM, rfc1738_escape(user));
             goto cleanup;
         } else {
             if (check_gss_err(major_status, minor_status, "gss_accept_sec_context()", log))
@@ -493,10 +494,10 @@ main(int argc, char *const argv[])
                 *p = '\0';
             }
             fprintf(stdout, "AF %s %s\n", "AA==", user);
-            debug((char *) "%s| %s: DEBUG: AF %s %s\n", LogTime(), PROGRAM, "AA==", user);
+            debug((char *) "%s| %s: DEBUG: AF %s %s\n", LogTime(), PROGRAM, "AA==", rfc1738_escape(user));
             if (log)
                 fprintf(stderr, "%s| %s: INFO: User %s authenticated\n", LogTime(),
-                        PROGRAM, user);
+                        PROGRAM, rfc1738_escape(user));
 
         }
 cleanup:
@@ -213,14 +213,13 @@ squid_kerb_proxy_auth(char *proxy)
 int
 main(int argc, char *argv[])
 {
-
     const char *Token;
     int count;
 
     if (argc < 2) {
         fprintf(stderr, "%s| %s: Error: No proxy server name given\n",
                 LogTime(), PROGRAM);
-        exit(99);
+        return 99;
     }
     if (argc == 3) {
         count = atoi(argv[2]);
@@ -235,15 +234,15 @@ main(int argc, char *argv[])
         fprintf(stdout, "Token: %s\n", Token ? Token : "NULL");
     }
 
-    exit(0);
+    return 0;
 }
 
 #else
 #include <stdlib.h>
 int
 main(int argc, char *argv[])
 {
-    exit(-1);
+    return -1;
 }
 
 #endif /* HAVE_GSSAPI */
@@ -84,14 +84,14 @@
 #endif
 
 /* A couple of harmless helper macros */
-#define SEND(X) debug("sending '%s' to squid\n",X); printf(X "\n");
+#define SEND(X) {debug("sending '%s' to squid\n",X); printf(X "\n");}
 #ifdef __GNUC__
-#define SEND2(X,Y...) debug("sending '" X "' to squid\n",Y); printf(X "\n",Y);
-#define SEND4(X,Y...) debug("sending '" X "' to squid\n",Y); printf(X "\n",Y);
+#define SEND2(X,Y...) {debug("sending '" X "' to squid\n",Y); printf(X "\n",Y);}
+#define SEND4(X,Y...) {debug("sending '" X "' to squid\n",Y); printf(X "\n",Y);}
 #else
 /* no gcc, no debugging. varargs macros are a gcc extension */
-#define SEND2(X,Y) debug("sending '" X "' to squid\n",Y); printf(X "\n",Y);
-#define SEND4(X,Y,Z,W) debug("sending '" X "' to squid\n",Y,Z,W); printf(X "\n",Y,Z,W);
+#define SEND2(X,Y) {debug("sending '" X "' to squid\n",Y); printf(X "\n",Y);}
+#define SEND4(X,Y,Z,W) {debug("sending '" X "' to squid\n",Y,Z,W); printf(X "\n",Y,Z,W);}
 #endif
 
 const char *authenticate_ntlm_domain = "WORKGROUP";
@@ -183,8 +183,11 @@ make_challenge(char *domain, char *domain_controller)
 {
     /* trying to circumvent some strange problem wih pointers in SMBLib */
     /* Ugly as hell, but the lib is going to be dropped... */
-    strcpy(my_domain,domain);
-    strcpy(my_domain_controller,domain_controller);
+    strncpy(my_domain, domain, sizeof(my_domain)-1);
+    my_domain[sizeof(my_domain)-1] = '\0';
+    strncpy(my_domain_controller, domain_controller, sizeof(my_domain_controller)-1);
+    my_domain_controller[sizeof(my_domain_controller)-1] = '\0';
+
     if (init_challenge(my_domain, my_domain_controller) > 0) {
         return NULL;
     }
@@ -56,7 +56,6 @@ class MemPoolChunked : public MemImplementingAllocator
 
     size_t chunk_size;
     int chunk_capacity;
-    int memPID;
     int chunkCount;
     void *freeCache;
     MemChunk *nextFreeChunk;
@@ -15,6 +15,7 @@ typedef enum {
     XPROF_InvokeHandlers,
     XPROF_MemBuf_append,
     XPROF_MemBuf_consume,
+    XPROF_MemBuf_consumeWhitespace,
     XPROF_MemBuf_grow,
     XPROF_MemObject_write,
     XPROF_PROF_OVERHEAD,
@@ -425,6 +425,7 @@ RFCNB_Session_Req(struct RFCNB_Con *con,
     char resp[16];
     int len;
     struct RFCNB_Pkt *pkt, res_pkt;
+    int result = 0;
 
     /* We build and send the session request, then read the response */
 
@@ -450,7 +451,7 @@ RFCNB_Session_Req(struct RFCNB_Con *con,
 #endif
 
     if ((len = RFCNB_Put_Pkt(con, pkt, RFCNB_Pkt_Sess_Len)) < 0) {
-
+        RFCNB_Free_Pkt(pkt);
         return (RFCNBE_Bad);    /* Should be able to write that lot ... */
 
     }
@@ -463,7 +464,7 @@ RFCNB_Session_Req(struct RFCNB_Con *con,
     res_pkt.next = NULL;
 
     if ((len = RFCNB_Get_Pkt(con, &res_pkt, sizeof(resp))) < 0) {
-
+        RFCNB_Free_Pkt(pkt);
         return (RFCNBE_Bad);
 
     }
@@ -497,12 +498,12 @@ RFCNB_Session_Req(struct RFCNB_Con *con,
             break;
         }
 
-        return (RFCNBE_Bad);
+        result = (RFCNBE_Bad);
         break;
 
     case RFCNB_SESSION_ACK:     /* Got what we wanted ...      */
 
-        return (0);
+        result = (0);
         break;
 
     case RFCNB_SESSION_RETARGET:        /* Go elsewhere                */
@@ -512,13 +513,16 @@ RFCNB_Session_Req(struct RFCNB_Con *con,
         memcpy(Dest_IP, (resp + RFCNB_Pkt_IP_Offset), sizeof(struct in_addr));
         *port = SVAL(resp, RFCNB_Pkt_Port_Offset);
 
-        return (0);
+        result = (0);
         break;
 
     default:                    /* A protocol error */
 
         RFCNB_errno = RFCNBE_ProtErr;
-        return (RFCNBE_Bad);
+        result = (RFCNBE_Bad);
         break;
     }
+
+    RFCNB_Free_Pkt(pkt);
+    return result;
 }
@@ -22,7 +22,7 @@ AccessLogEntry::getLogClientIp(char *buf, size_t bufsz) const
         if (tcpClient != NULL)
             tcpClient->remote.NtoA(buf, bufsz);
         else if (cache.caddr.IsNoAddr()) // e.g., ICAP OPTIONS lack client
-            strncpy(buf, "-", 1);
+            strncpy(buf, "-", bufsz);
         else
             cache.caddr.NtoA(buf, bufsz);
 }
@@ -231,7 +231,9 @@ class AccessLogEntry: public RefCountable
     HttpReply *reply;
     HttpRequest *request; //< virgin HTTP request
     HttpRequest *adapted_request; //< HTTP request after adaptation and redirection
-    /// key:value pairs set by note and adaptation_meta
+
+    /// key:value pairs set by note and adaptation_meta directives
+    /// plus key=value pairs returned from URL rewrite/redirect helper
     NotePairs notes;
 
 #if ICAP_CLIENT
@@ -56,6 +56,14 @@ class ClientRequestContext : public RefCountable
     ACLChecklist *acl_checklist;        /* need ptr back so we can unreg if needed */
     int redirect_state;
 
+    /**
+     * URL-rewrite/redirect helper may return BH for internal errors.
+     * We attempt to recover by trying the lookup again, but limit the
+     * number of retries to prevent lag and lockups.
+     * This tracks the number of previous failures for the current context.
+     */
+    uint8_t redirect_fail_count;
+
     bool host_header_verify_done;
     bool http_access_done;
     bool adapted_http_access_done;
@@ -15,7 +15,7 @@
 
 DiskdActionData::DiskdActionData()
 {
-    xmemset(this, 0, sizeof(*this));
+    memset(this, 0, sizeof(*this));
 }
 
 DiskdActionData&
@@ -407,7 +407,8 @@ DiskdIOStrategy::SEND(diomsg *M, int mtype, int id, size_t size, off_t offset, s
     } else {
         debugs(79, DBG_IMPORTANT, "storeDiskdSend: msgsnd: " << xstrerror());
         cbdataReferenceDone(M->callback_data);
-        assert(++send_errors < 100);
+        ++send_errors;
+        assert(send_errors < 100);
         if (shm_offset > -1)
             shm.put(shm_offset);
     }
@@ -360,7 +360,8 @@ DiskThreadsDiskFile::writeDone(int rvfd, int errflag, size_t len, RefCount<Write
 
     debugs(79, 3, "DiskThreadsDiskFile::writeDone: FD " << fd << ", len " << len << ", err=" << errflag);
 
-    assert(++loop_detect < 10);
+    ++loop_detect;
+    assert(loop_detect < 10);
 
     --inProgressIOs;
 
@@ -1,10 +1,23 @@
+/*
+ * DEBUG: section 84    Helper process maintenance
+ * AUTHOR: Amos Jeffries
+ */
 #include "squid.h"
+#include "ConfigParser.h"
 #include "HelperReply.h"
 #include "helper.h"
+#include "rfc1738.h"
+#include "SquidString.h"
 
-HelperReply::HelperReply(const char *buf, size_t len) :
+HelperReply::HelperReply(char *buf, size_t len) :
         result(HelperReply::Unknown),
         whichServer(NULL)
+{
+    parse(buf,len);
+}
+
+void
+HelperReply::parse(char *buf, size_t len)
 {
     // check we have something to parse
     if (!buf || len < 1) {
@@ -14,7 +27,7 @@ HelperReply::HelperReply(const char *buf, size_t len) :
         return;
     }
 
-    const char *p = buf;
+    char *p = buf;
 
     // optimization: do not consider parsing result code if the response is short.
     // URL-rewriter may return relative URLs or empty response for a large portion
@@ -35,13 +48,50 @@ HelperReply::HelperReply(const char *buf, size_t len) :
             // NTLM challenge token
             result = HelperReply::TT;
             p+=3;
+            // followed by an auth token
+            char *w1 = strwordtok(NULL, &p);
+            if (w1 != NULL) {
+                MemBuf authToken;
+                authToken.init();
+                authToken.append(w1, strlen(w1));
+                notes.add("token",authToken.content());
+            } else {
+                // token field is mandatory on this response code
+                result = HelperReply::BrokenHelper;
+                notes.add("message","Missing 'token' data");
+            }
+
         } else if (!strncmp(p,"AF ",3)) {
-            // NTLM OK response
-            result = HelperReply::AF;
+            // NTLM/Negotate OK response
+            result = HelperReply::Okay;
             p+=3;
+            // followed by:
+            //  an optional auth token and user field
+            // or, an optional username field
+            char *w1 = strwordtok(NULL, &p);
+            char *w2 = strwordtok(NULL, &p);
+            if (w2 != NULL) {
+                // Negotiate "token user"
+                MemBuf authToken;
+                authToken.init();
+                authToken.append(w1, strlen(w1));
+                notes.add("token",authToken.content());
+
+                MemBuf user;
+                user.init();
+                user.append(w2,strlen(w2));
+                notes.add("user",user.content());
+
+            } else if (w1 != NULL) {
+                // NTLM "user"
+                MemBuf user;
+                user.init();
+                user.append(w1,strlen(w1));
+                notes.add("user",user.content());
+            }
         } else if (!strncmp(p,"NA ",3)) {
             // NTLM fail-closed ERR response
-            result = HelperReply::NA;
+            result = HelperReply::Error;
             p+=3;
         }
 
@@ -54,6 +104,48 @@ HelperReply::HelperReply(const char *buf, size_t len) :
 
     // NULL-terminate so the helper callback handlers do not buffer-overrun
     other_.terminate();
+
+    parseResponseKeys();
+
+    // Hack for backward-compatibility: BH used to be a text message...
+    if (other().hasContent() && result == HelperReply::BrokenHelper) {
+        notes.add("message",other().content());
+        modifiableOther().clean();
+    }
+}
+
+void
+HelperReply::parseResponseKeys()
+{
+    // parse a "key=value" pair off the 'other()' buffer.
+    while (other().hasContent()) {
+        char *p = modifiableOther().content();
+        while (*p && *p != '=' && *p != ' ') ++p;
+        if (*p != '=')
+            return; // done. Not a key.
+
+        // whitespace between key and value is prohibited.
+        // workaround strwordtok() which skips whitespace prefix.
+        if (xisspace(*(p+1)))
+            return; // done. Not a key.
+
+        *p = '\0';
+        ++p;
+
+        const String key(other().content());
+
+        // the value may be a quoted string or a token
+        const bool urlDecode = (*p != '"'); // check before moving p.
+        char *v = strwordtok(NULL, &p);
+        if (v != NULL && urlDecode && (p-v) > 2) // 1-octet %-escaped requires 3 bytes
+            rfc1738_unescape(v);
+        const String value(v?v:""); // value can be empty, but must not be NULL
+
+        notes.add(key, value);
+
+        modifiableOther().consume(p - other().content());
+        modifiableOther().consumeWhitespacePrefix();
+    }
 }
 
 std::ostream &
@@ -73,17 +165,22 @@ operator <<(std::ostream &os, const HelperReply &r)
     case HelperReply::TT:
         os << "TT";
         break;
-    case HelperReply::AF:
-        os << "AF";
-        break;
-    case HelperReply::NA:
-        os << "NA";
-        break;
     case HelperReply::Unknown:
         os << "Unknown";
         break;
     }
 
+    // dump the helper key=pair "notes" list
+    if (r.notes.notes.size() > 0) {
+        os << ", notes={";
+        for (Notes::NotesList::const_iterator m = r.notes.notes.begin(); m != r.notes.notes.end(); ++m) {
+            for (Note::Values::iterator v = (*m)->values.begin(); v != (*m)->values.end(); ++v) {
+                os << ',' << (*m)->key << '=' << ConfigParser::QuoteString((*v)->value);
+            }
+        }
+        os << "}";
+    }
+
     if (r.other().hasContent())
         os << ", other: \"" << r.other().content() << '\"';
 
@@ -3,6 +3,7 @@
 
 #include "base/CbcPointer.h"
 #include "MemBuf.h"
+#include "Notes.h"
 
 #if HAVE_OSTREAM
 #include <ostream>
@@ -23,8 +24,14 @@ class HelperReply
     HelperReply &operator =(const HelperReply &r);
 
 public:
+    HelperReply() : result(HelperReply::Unknown), notes(), whichServer(NULL) {
+        other_.init(1,1);
+        other_.terminate();
+    }
+
     // create/parse details from the msg buffer provided
-    HelperReply(const char *buf, size_t len);
+    // XXX: buf should be const but parse() needs non-const for now
+    HelperReply(char *buf, size_t len);
 
     const MemBuf &other() const { return other_; }
 
@@ -34,28 +41,38 @@ class HelperReply
     /// and by token blob/arg parsing in Negotiate auth handler
     MemBuf &modifiableOther() const { return *const_cast<MemBuf*>(&other_); }
 
+    /** parse a helper response line format:
+     *   line     := [ result ] *#( kv-pair )
+     *   kv-pair := OWS token '=' ( quoted-string | token )
+     *
+     * token are URL-decoded.
+     * quoted-string are \-escape decoded and the quotes are stripped.
+     */
+    // XXX: buf should be const but we may need strwordtok() and rfc1738_unescape()
+    void parse(char *buf, size_t len);
+
 public:
     /// The helper response 'result' field.
     enum Result_ {
         Unknown,      // no result code received, or unknown result code
         Okay,         // "OK" indicating success/positive result
-        Error,        // "ERR" indicating failure/negative result
+        Error,        // "ERR" indicating success/negative result
         BrokenHelper, // "BH" indicating failure due to helper internal problems.
 
-        // some result codes for backward compatibility with NTLM/Negotiate
-        // TODO: migrate these into variants of the above results with key-pair parameters
-        TT,
-        AF,
-        NA
+        // result codes for backward compatibility with NTLM/Negotiate
+        // TODO: migrate to a variant of the above results with kv-pair parameters
+        TT
     } result;
 
-// TODO other key=pair values. when the callbacks actually use this object.
-// for now they retain their own parsing routines handling other()
+    // list of key=value pairs the helper produced
+    Notes notes;
 
     /// for stateful replies the responding helper 'server' needs to be preserved across callbacks
     CbcPointer<helper_stateful_server> whichServer;
 
 private:
+    void parseResponseKeys();
+
     /// the remainder of the line
     MemBuf other_;
 };
@@ -1020,10 +1020,19 @@ HttpHeader::getStrOrList(http_hdr_type id) const
 }
 
 /*
- * Returns the value of the specified header.
+ * Returns the value of the specified header and/or an undefined String.
  */
 String
 HttpHeader::getByName(const char *name) const
+{
+    String result;
+    // ignore presence: return undefined string if an empty header is present
+    (void)getByNameIfPresent(name, result);
+    return result;
+}
+
+bool
+HttpHeader::getByNameIfPresent(const char *name, String &result) const
 {
     http_hdr_type id;
     HttpHeaderPos pos = HttpHeaderInitPos;
@@ -1034,19 +1043,23 @@ HttpHeader::getByName(const char *name) const
     /* First try the quick path */
     id = httpHeaderIdByNameDef(name, strlen(name));
 
-    if (id != -1)
-        return getStrOrList(id);
-
-    String result;
+    if (id != -1) {
+        if (!has(id))
+            return false;
+        result = getStrOrList(id);
+        return true;
+    }
 
     /* Sorry, an unknown header name. Do linear search */
+    bool found = false;
     while ((e = getEntry(&pos))) {
         if (e->id == HDR_OTHER && e->name.caseCmp(name) == 0) {
+            found = true;
             strListAdd(&result, e->value.termedBuf(), ',');
         }
     }
 
-    return result;
+    return found;
 }
 
 /*
@@ -247,6 +247,8 @@ class HttpHeader
     bool getList(http_hdr_type id, String *s) const;
     String getStrOrList(http_hdr_type id) const;
     String getByName(const char *name) const;
+    /// sets value and returns true iff a [possibly empty] named field is there
+    bool getByNameIfPresent(const char *name, String &value) const;
     String getByNameListMember(const char *name, const char *member, const char separator) const;
     String getListMember(http_hdr_type id, const char *member, const char separator) const;
     int has(http_hdr_type id) const;
@@ -57,12 +57,16 @@
 #include "adaptation/icap/icap_log.h"
 #endif
 
-HttpRequest::HttpRequest() : HttpMsg(hoRequest)
+HttpRequest::HttpRequest() :
+        HttpMsg(hoRequest),
+        helperNotes(NULL)
 {
     init();
 }
 
-HttpRequest::HttpRequest(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath) : HttpMsg(hoRequest)
+HttpRequest::HttpRequest(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath) :
+        HttpMsg(hoRequest),
+        helperNotes(NULL)
 {
     static unsigned int id = 1;
     debugs(93,7, HERE << "constructed, this=" << this << " id=" << ++id);
@@ -163,6 +167,11 @@ HttpRequest::clean()
 
     myportname.clean();
 
+    if (helperNotes) {
+        delete helperNotes;
+        helperNotes = NULL;
+    }
+
     tag.clean();
 #if USE_AUTH
     extacl_user.clean();
@@ -221,6 +230,10 @@ HttpRequest::clone() const
     // XXX: what to do with copy->peer_domain?
 
     copy->myportname = myportname;
+    if (helperNotes) {
+        copy->helperNotes = new Notes;
+        copy->helperNotes->notes = helperNotes->notes;
+    }
     copy->tag = tag;
 #if USE_AUTH
     copy->extacl_user = extacl_user;
@@ -37,6 +37,7 @@
 #include "HierarchyLogEntry.h"
 #include "HttpMsg.h"
 #include "HttpRequestMethod.h"
+#include "Notes.h"
 #include "RequestFlags.h"
 
 #if USE_AUTH
@@ -199,6 +200,8 @@ class HttpRequest: public HttpMsg
 
     String myportname; // Internal tag name= value from port this requests arrived in.
 
+    Notes *helperNotes;         ///< collection of meta notes associated with this request by helper lookups.
+
     String tag;			/* Internal tag for this request */
 
     String extacl_user;		/* User name returned by extacl lookup */
@@ -43,7 +43,7 @@ InstanceIdDefinitions(MemBlob, "blob");
 
 /* MemBlobStats */
 
-MemBlobStats::MemBlobStats(): alloc(0), live(0), append(0)
+MemBlobStats::MemBlobStats(): alloc(0), live(0), append(0), liveBytes(0)
 {}
 
 std::ostream&
@@ -220,6 +220,20 @@ void MemBuf::consume(mb_size_t shiftSize)
     PROF_stop(MemBuf_consume);
 }
 
+/// removes all whitespace prefix bytes and "packs" by moving content left
+void MemBuf::consumeWhitespacePrefix()
+{
+    PROF_start(MemBuf_consumeWhitespace);
+    if (contentSize() > 0) {
+        const char *end = buf + contentSize();
+        const char *p = buf;
+        for (; p<end && xisspace(*p); ++p);
+        if (p-buf > 0)
+            consume(p-buf);
+    }
+    PROF_stop(MemBuf_consumeWhitespace);
+}
+
 // removes last tailSize bytes
 void MemBuf::truncate(mb_size_t tailSize)
 {
@@ -81,6 +81,8 @@ class MemBuf
     /// \note there is currently no stretch() method to grow without appending
 
     void consume(mb_size_t sz);  // removes sz bytes, moving content left
+    void consumeWhitespacePrefix();    ///< removes all prefix whitespace, moving content left
+
     void append(const char *c, mb_size_t sz); // grows if needed and possible
     void appended(mb_size_t sz); // updates content size after external append
     void truncate(mb_size_t sz);  // removes sz last bytes
@@ -73,19 +73,59 @@ Note::match(HttpRequest *request, HttpReply *reply)
 }
 
 Note::Pointer
-Notes::add(const String &noteKey)
+Notes::find(const String &noteKey) const
 {
-    typedef Notes::NotesList::iterator AMLI;
+    typedef Notes::NotesList::const_iterator AMLI;
     for (AMLI i = notes.begin(); i != notes.end(); ++i) {
         if ((*i)->key == noteKey)
             return (*i);
     }
 
-    Note::Pointer note = new Note(noteKey);
-    notes.push_back(note);
+    return Note::Pointer();
+}
+
+void
+Notes::add(const String &noteKey, const String &noteValue)
+{
+    Note::Pointer key = add(noteKey);
+    key->addValue(noteValue);
+}
+
+Note::Pointer
+Notes::add(const String &noteKey)
+{
+    Note::Pointer note = find(noteKey);
+    if (note == NULL) {
+        note = new Note(noteKey);
+        notes.push_back(note);
+    }
     return note;
 }
 
+void
+Notes::add(const Notes &src)
+{
+    typedef Notes::NotesList::const_iterator AMLI;
+    typedef Note::Values::iterator VLI;
+
+    for (AMLI i = src.notes.begin(); i != src.notes.end(); ++i) {
+
+        // ensure we have a key by that name to fill out values for...
+        // NP: not sharing pointers at the key level since merging other helpers
+        // details later would affect this src objects keys, which is a bad idea.
+        Note::Pointer ourKey = add((*i)->key);
+
+        // known key names, merge the values lists...
+        for (VLI v = (*i)->values.begin(); v != (*i)->values.end(); ++v ) {
+            // 2012-11-29: values are read-only and Pointer can safely be shared
+            // for now we share pointers to save memory and gain speed.
+            // If that ever ceases to be true, convert this to a full copy.
+            ourKey->values.push_back(*v);
+            // TODO: prune/skip duplicates ?
+        }
+    }
+}
+
 Note::Pointer
 Notes::parse(ConfigParser &parser)
 {
@@ -48,6 +48,12 @@ class Note: public RefCountable
      * or NULL if none matches.
      */
     const char *match(HttpRequest *request, HttpReply *reply);
+
+    /**
+     * Returns the first value for this key or an empty string.
+     */
+    const char *firstValue() const { return (values.size()>0&&values[0]->value.defined()?values[0]->value.termedBuf():""); }
+
     String key; ///< The note key
     Values values; ///< The possible values list for the note
 };
@@ -61,6 +67,7 @@ class Notes
 public:
     typedef Vector<Note::Pointer> NotesList;
     typedef NotesList::iterator iterator; ///< iterates over the notes list
+    typedef NotesList::const_iterator const_iterator; ///< iterates over the notes list
 
     Notes(const char *aDescr, const char **metasBlacklist): descr(aDescr), blacklisted(metasBlacklist) {}
     Notes(): descr(NULL), blacklisted(NULL) {}
@@ -83,9 +90,33 @@ class Notes
     /// return true if the notes list is empty
     bool empty() { return notes.empty(); }
 
+    /**
+     * Adds a note key and value to the notes list.
+     * If the key name already exists in list, add the given value to its set of values.
+     */
+    void add(const String &noteKey, const String &noteValue);
+
+    /**
+     * Adds a set of notes from another notes list to this set.
+     * Creating entries for any new keys needed.
+     * If the key name already exists in list, add the given value to its set of values.
+     *
+     * WARNING:
+     * The list entries are all of shared Pointer type. Altering the src object(s) after
+     * using this function will update both Notes lists. Likewise, altering this
+     * destination NotesList will affect any relevant copies of src still in use.
+     */
+    void add(const Notes &src);
+
+    /**
+     * Returns a pointer to an existing Note with given key name or nil.
+     */
+    Note::Pointer find(const String &noteKey) const;
+
     NotesList notes; ///< The Note::Pointer objects array list
     const char *descr; ///< A short description for notes list
     const char **blacklisted; ///< Null terminated list of blacklisted note keys
+
 private:
     /**
      * Adds a note to the notes list and returns a pointer to the
@@ -99,6 +130,18 @@ class NotePairs : public HttpHeader
 {
 public:
     NotePairs() : HttpHeader(hoNote) {}
+
+    /// convert a NotesList into a NotesPairs
+    /// appending to any existing entries already present
+    void append(const Notes::NotesList &src) {
+        for (Notes::NotesList::const_iterator m = src.begin(); m != src.end(); ++m)
+            for (Note::Values::iterator v =(*m)->values.begin(); v != (*m)->values.end(); ++v)
+                putExt((*m)->key.termedBuf(), (*v)->value.termedBuf());
+    }
+
+    void append(const NotePairs *src) {
+        HttpHeader::append(dynamic_cast<const HttpHeader*>(src));
+    }
 };
 
 #endif
@@ -11,7 +11,7 @@
 
 StoreInfoStats::StoreInfoStats()
 {
-    xmemset(this, 0, sizeof(*this));
+    memset(this, 0, sizeof(*this));
 }
 
 StoreInfoStats &
@@ -52,6 +52,6 @@ StoreInfoStats::operator +=(const StoreInfoStats &stats)
 
 StoreIoStats::StoreIoStats()
 {
-    xmemset(this, 0, sizeof(*this));
+    memset(this, 0, sizeof(*this));
 }
 
@@ -80,7 +80,12 @@ ACL::Factory (char const *type)
     return result;
 }
 
-ACL::ACL () :cfgline(NULL) {}
+ACL::ACL() :
+        cfgline(NULL),
+        next(NULL)
+{
+    *name = 0;
+}
 
 bool ACL::valid () const
 {
@@ -509,8 +509,6 @@ destroyRadixNodeInfo(as_info * e_info)
         data = data->next;
         delete prev;
     }
-
-    delete data;
 }
 
 static int
@@ -320,7 +320,8 @@ ACLChecklist::ACLChecklist() :
         async_(false),
         finished_(false),
         allow_(ACCESS_DENIED),
-        state_(NullState::Instance())
+        state_(NullState::Instance()),
+        checking_(false)
 {
 }
 
@@ -54,8 +54,7 @@ ACLDestinationIP::match(ACLChecklist *cl)
     // Bypass of browser same-origin access control in intercepted communication
     // To resolve this we will force DIRECT and only to the original client destination.
     // In which case, we also need this ACL to accurately match the destination
-    if (Config.onoff.client_dst_passthru && checklist->request &&
-            (checklist->request->flags.intercepted || checklist->request->flags.spoofClientIp)) {
+    if (Config.onoff.client_dst_passthru && (checklist->request->flags.intercepted || checklist->request->flags.spoofClientIp)) {
         assert(checklist->conn() && checklist->conn()->clientConnection != NULL);
         return ACLIP::match(checklist->conn()->clientConnection->local);
     }
@@ -65,9 +65,23 @@ ACLHTTPHeaderData::match(HttpHeader* hdr)
 
     debugs(28, 3, "aclHeaderData::match: checking '" << hdrName << "'");
 
-    String value = hdrId != HDR_BAD_HDR ? hdr->getStrOrList(hdrId) : hdr->getByName(hdrName.termedBuf());
+    String value;
+    if (hdrId != HDR_BAD_HDR) {
+        if (!hdr->has(hdrId))
+            return false;
+        value = hdr->getStrOrList(hdrId);
+    } else {
+        if (!hdr->getByNameIfPresent(hdrName.termedBuf(), value))
+            return false;
+    }
 
-    return regex_rule->match(value.termedBuf());
+    // By now, we know the header is present, but:
+    // HttpHeader::get*() return an undefined String for empty header values;
+    // String::termedBuf() returns NULL for undefined Strings; and
+    // ACLRegexData::match() always fails on NULL strings.
+    // This makes it possible to detect an empty header value using regex:
+    const char *cvalue = value.defined() ? value.termedBuf() : "";
+    return regex_rule->match(cvalue);
 }
 
 wordlist *
@@ -409,15 +409,6 @@ acl_ip_data::FactoryParse(const char *t)
 
         memset(&hints, 0, sizeof(struct addrinfo));
 
-        if ( iptype != AF_UNSPEC ) {
-            hints.ai_flags |= AI_NUMERICHOST;
-        }
-
-#if 0
-        if (Ip::EnableIpv6&IPV6_SPECIAL_V4MAPPING)
-            hints.ai_flags |= AI_V4MAPPED | AI_ALL;
-#endif
-
         int errcode = getaddrinfo(addr1,NULL,&hints,&hp);
         if (hp == NULL) {
             debugs(28, DBG_CRITICAL, "aclIpParseIpData: Bad host/IP: '" << addr1 <<
@@ -85,8 +85,15 @@ ACLMaxConnection::parse()
     limit = (atoi (t));
 
     /* suck out file contents */
-
+    // ignore comments
+    bool ignore = false;
     while ((t = strtokFile())) {
+        ignore |= (*t != '#');
+
+        if (ignore)
+            continue;
+
+        debugs(89, DBG_CRITICAL, "WARNING: max_conn only accepts a single limit value.");
         limit = 0;
     }
 }
@@ -72,6 +72,12 @@ ACLRandom::empty () const
     return data == 0.0;
 }
 
+bool
+ACLRandom::valid() const
+{
+    return !empty();
+}
+
 /*******************/
 /* aclParseRandomList */
 /*******************/
@@ -82,6 +88,9 @@ ACLRandom::parse()
     char bufa[256], bufb[256];
 
     t = strtokFile();
+    if (!t)
+        return;
+
     debugs(28, 5, "aclParseRandomData: " << t);
 
     // seed random generator ...
@@ -91,23 +100,23 @@ ACLRandom::parse()
         int a = xatoi(bufa);
         int b = xatoi(bufb);
         if (a == 0 || b == 0) {
-            debugs(28, DBG_CRITICAL, "aclParseRandomData: Bad Pattern: '" << t << "'");
-            self_destruct();
+            debugs(28, DBG_CRITICAL, "ERROR: ACL random with bad pattern: '" << t << "'");
+            return;
         } else
             data = a / (double)(a+b);
     } else if (sscanf(t, "%[0-9]/%[0-9]", bufa, bufb) == 2) {
         int a = xatoi(bufa);
         int b = xatoi(bufb);
         if (a == 0 || b == 0) {
-            debugs(28, DBG_CRITICAL, "aclParseRandomData: Bad Pattern: '" << t << "'");
-            self_destruct();
+            debugs(28, DBG_CRITICAL, "ERROR: ACL random with bad pattern: '" << t << "'");
+            return;
         } else
             data = (double) a / (double) b;
     } else if (sscanf(t, "0.%[0-9]", bufa) == 1) {
         data = atof(t);
     } else {
-        debugs(28, DBG_CRITICAL, "aclParseRandomData: Bad Pattern: '" << t << "'");
-        self_destruct();
+        debugs(28, DBG_CRITICAL, "ERROR: ACL random with bad pattern: '" << t << "'");
+        return;
     }
 
     // save the exact input pattern. so we can display it later.
@@ -53,6 +53,7 @@ class ACLRandom : public ACL
     virtual int match(ACLChecklist *checklist);
     virtual wordlist *dump() const;
     virtual bool empty () const;
+    virtual bool valid() const;
 
 protected:
     static Prototype RegistryProtoype;
@@ -205,8 +205,11 @@ void Adaptation::Icap::Options::TransferList::parse(const String &buf, bool &fou
     while (strListGetItem(&buf, ',', &item, &ilen, &pos)) {
         if (ilen == 1 && *item == '*')
             foundStar = true;
-        else
-            add(xstrndup(item, ilen+1));
+        else {
+            const char *tmp = xstrndup(item, ilen+1);
+            add(tmp);
+            xfree(tmp);
+        }
     }
 }
 
@@ -45,7 +45,8 @@ Adaptation::Icap::Xaction::Xaction(const char *aTypeName, Adaptation::Icap::Serv
         ignoreLastWrite(false),
         connector(NULL), reader(NULL), writer(NULL), closer(NULL),
         alep(new AccessLogEntry),
-        al(*alep)
+        al(*alep),
+        cs(NULL)
 {
     debugs(93,3, typeName << " constructed, this=" << this <<
            " [icapx" << id << ']'); // we should not call virtual status() here
@@ -170,7 +171,7 @@ Adaptation::Icap::Xaction::dnsLookupDone(const ipcache_addrs *ia)
     // TODO: service bypass status may differ from that of a transaction
     typedef CommCbMemFunT<Adaptation::Icap::Xaction, CommConnectCbParams> ConnectDialer;
     connector = JobCallback(93,3, ConnectDialer, this, Adaptation::Icap::Xaction::noteCommConnected);
-    Comm::ConnOpener *cs = new Comm::ConnOpener(connection, connector, TheConfig.connect_timeout(service().cfg().bypass));
+    cs = new Comm::ConnOpener(connection, connector, TheConfig.connect_timeout(service().cfg().bypass));
     cs->setHost(s.cfg().host.termedBuf());
     AsyncJob::Start(cs);
 }
@@ -225,6 +226,8 @@ void Adaptation::Icap::Xaction::closeConnection()
 // connection with the ICAP service established
 void Adaptation::Icap::Xaction::noteCommConnected(const CommConnectCbParams &io)
 {
+    cs = NULL;
+
     if (io.flag == COMM_TIMEOUT) {
         handleCommTimedout();
         return;
@@ -508,6 +511,12 @@ void Adaptation::Icap::Xaction::setOutcome(const Adaptation::Icap::XactOutcome &
 void Adaptation::Icap::Xaction::swanSong()
 {
     // kids should sing first and then call the parent method.
+    if (cs) {
+        debugs(93,6, HERE << id << " about to notify ConnOpener!");
+        CallJobHere(93, 3, cs, Comm::ConnOpener, noteAbort);
+        cs = NULL;
+        service().noteConnectionFailed("abort");
+    }
 
     closeConnection(); // TODO: rename because we do not always close
 
@@ -42,6 +42,10 @@
 #include "ipcache.h"
 
 class CommConnectCbParams;
+namespace Comm
+{
+class ConnOpener;
+}
 
 namespace Adaptation
 {
@@ -188,6 +192,7 @@ class Xaction: public Adaptation::Initiate
     timeval icap_tio_finish;   /*time when the last byte of the ICAP responsewas received*/
 
 private:
+    Comm::ConnOpener *cs;
     //CBDATA_CLASS2(Xaction);
 };
 
@@ -280,33 +280,69 @@ Auth::Digest::UserRequest::HandleReply(void *data, const HelperReply &reply)
     assert(replyData->auth_user_request != NULL);
     Auth::UserRequest::Pointer auth_user_request = replyData->auth_user_request;
 
+    static bool oldHelperWarningDone = false;
     switch (reply.result) {
-    case HelperReply::Error: {
-        /* allow this because the digest_request pointer is purely local */
-        Auth::Digest::UserRequest *digest_request = dynamic_cast<Auth::Digest::UserRequest *>(auth_user_request.getRaw());
-        assert(digest_request);
+    case HelperReply::Unknown: {
+        // Squid 3.3 and older the digest helper only returns a HA1 hash (no "OK")
+        // the HA1 will be found in content() for these responses.
+        if (!oldHelperWarningDone) {
+            debugs(29, DBG_IMPORTANT, "WARNING: Digest auth helper returned old format HA1 response. It needs to be upgraded.");
+            oldHelperWarningDone=true;
+        }
 
-        digest_request->user()->credentials(Auth::Failed);
-        digest_request->flags.invalid_password = 1;
+        /* allow this because the digest_request pointer is purely local */
+        Auth::Digest::User *digest_user = dynamic_cast<Auth::Digest::User *>(auth_user_request->user().getRaw());
+        assert(digest_user != NULL);
 
-        if (reply.other().hasContent())
-            digest_request->setDenyMessage(reply.other().content());
+        CvtBin(reply.other().content(), digest_user->HA1);
+        digest_user->HA1created = 1;
     }
     break;
 
-    case HelperReply::Unknown: // Squid 3.2 and older the digest helper only returns a HA1 hash (no "OK")
     case HelperReply::Okay: {
         /* allow this because the digest_request pointer is purely local */
         Auth::Digest::User *digest_user = dynamic_cast<Auth::Digest::User *>(auth_user_request->user().getRaw());
         assert(digest_user != NULL);
 
-        CvtBin(reply.other().content(), digest_user->HA1);
-        digest_user->HA1created = 1;
+        Note::Pointer ha1Note = reply.notes.find("ha1");
+        if (ha1Note != NULL) {
+            CvtBin(ha1Note->firstValue(), digest_user->HA1);
+            digest_user->HA1created = 1;
+        } else {
+            debugs(29, DBG_IMPORTANT, "ERROR: Digest auth helper did not produce a HA1. Using the wrong helper program? received: " << reply);
+        }
     }
     break;
 
-    default:
-        ; // XXX: handle other states properly.
+    case HelperReply::TT:
+        debugs(29, DBG_IMPORTANT, "ERROR: Digest auth does not support the result code received. Using the wrong helper program? received: " << reply);
+        // fall through to next case. Handle this as an ERR response.
+
+    case HelperReply::BrokenHelper:
+        // TODO retry the broken lookup on another helper?
+        // fall through to next case for now. Handle this as an ERR response silently.
+
+    case HelperReply::Error: {
+        /* allow this because the digest_request pointer is purely local */
+        Auth::Digest::UserRequest *digest_request = dynamic_cast<Auth::Digest::UserRequest *>(auth_user_request.getRaw());
+        assert(digest_request);
+
+        digest_request->user()->credentials(Auth::Failed);
+        digest_request->flags.invalid_password = 1;
+
+        Note::Pointer msgNote = reply.notes.find("message");
+        if (msgNote != NULL) {
+            digest_request->setDenyMessage(msgNote->firstValue());
+        } else if (reply.other().hasContent()) {
+            // old helpers did send ERR result but a bare message string instead of message= key name.
+            digest_request->setDenyMessage(reply.other().content());
+            if (!oldHelperWarningDone) {
+                debugs(29, DBG_IMPORTANT, "WARNING: Digest auth helper returned old format ERR response. It needs to be upgraded.");
+                oldHelperWarningDone=true;
+            }
+        }
+    }
+    break;
     }
 
     void *cbdata = NULL;
@@ -262,48 +262,38 @@ Auth::Negotiate::UserRequest::HandleReply(void *data, const HelperReply &reply)
     else
         assert(reply.whichServer == lm_request->authserver);
 
-    /* seperate out the useful data */
-    char *modifiableBlob = reply.modifiableOther().content();
-    char *arg = NULL;
-    if (modifiableBlob && *modifiableBlob != '\0') {
-        arg = strchr(modifiableBlob + 1, ' ');
-        if (arg) {
-            *arg = '\0';
-            ++arg;
-        }
-    }
-    const char *blob = modifiableBlob;
-
     switch (reply.result) {
     case HelperReply::TT:
         /* we have been given a blob to send to the client */
         safe_free(lm_request->server_blob);
         lm_request->request->flags.mustKeepalive = 1;
         if (lm_request->request->flags.proxyKeepalive) {
-            lm_request->server_blob = xstrdup(blob);
+            Note::Pointer tokenNote = reply.notes.find("token");
+            lm_request->server_blob = xstrdup(tokenNote->firstValue());
             auth_user_request->user()->credentials(Auth::Handshake);
             auth_user_request->denyMessage("Authentication in progress");
-            debugs(29, 4, HERE << "Need to challenge the client with a server blob '" << blob << "'");
+            debugs(29, 4, HERE << "Need to challenge the client with a server token: '" << tokenNote->firstValue() << "'");
         } else {
             auth_user_request->user()->credentials(Auth::Failed);
-            auth_user_request->denyMessage("NTLM authentication requires a persistent connection");
+            auth_user_request->denyMessage("Negotiate authentication requires a persistent connection");
         }
         break;
 
-    case HelperReply::AF:
     case HelperReply::Okay: {
-        if (arg == NULL) {
+        Note::Pointer userNote = reply.notes.find("user");
+        Note::Pointer tokenNote = reply.notes.find("token");
+        if (userNote == NULL || tokenNote == NULL) {
             // XXX: handle a success with no username better
             /* protocol error */
             fatalf("authenticateNegotiateHandleReply: *** Unsupported helper response ***, '%s'\n", reply.other().content());
             break;
         }
 
         /* we're finished, release the helper */
-        auth_user_request->user()->username(arg);
+        auth_user_request->user()->username(userNote->firstValue());
         auth_user_request->denyMessage("Login successful");
         safe_free(lm_request->server_blob);
-        lm_request->server_blob = xstrdup(blob);
+        lm_request->server_blob = xstrdup(tokenNote->firstValue());
         lm_request->releaseAuthServer();
 
         /* connection is authenticated */
@@ -332,45 +322,53 @@ Auth::Negotiate::UserRequest::HandleReply(void *data, const HelperReply &reply)
          * existing user or a new user */
         local_auth_user->expiretime = current_time.tv_sec;
         auth_user_request->user()->credentials(Auth::Ok);
-        debugs(29, 4, HERE << "Successfully validated user via Negotiate. Username '" << arg << "'");
+        debugs(29, 4, HERE << "Successfully validated user via Negotiate. Username '" << auth_user_request->user()->username() << "'");
     }
     break;
 
-    case HelperReply::NA:
-    case HelperReply::Error:
-        if (arg == NULL) {
+    case HelperReply::Error: {
+        Note::Pointer messageNote = reply.notes.find("message");
+        Note::Pointer tokenNote = reply.notes.find("token");
+        if (tokenNote == NULL) {
             /* protocol error */
             fatalf("authenticateNegotiateHandleReply: *** Unsupported helper response ***, '%s'\n", reply.other().content());
             break;
         }
+
         /* authentication failure (wrong password, etc.) */
-        auth_user_request->denyMessage(arg);
+        auth_user_request->denyMessage(messageNote->firstValue());
         auth_user_request->user()->credentials(Auth::Failed);
         safe_free(lm_request->server_blob);
-        lm_request->server_blob = xstrdup(blob);
+        lm_request->server_blob = xstrdup(tokenNote->firstValue());
         lm_request->releaseAuthServer();
         debugs(29, 4, HERE << "Failed validating user via Negotiate. Error returned '" << reply << "'");
-        break;
+    }
+    break;
 
     case HelperReply::Unknown:
         debugs(29, DBG_IMPORTANT, "ERROR: Negotiate Authentication Helper '" << reply.whichServer << "' crashed!.");
-        blob = "Internal error";
         /* continue to the next case */
 
-    case HelperReply::BrokenHelper:
+    case HelperReply::BrokenHelper: {
         /* TODO kick off a refresh process. This can occur after a YR or after
          * a KK. If after a YR release the helper and resubmit the request via
          * Authenticate Negotiate start.
          * If after a KK deny the user's request w/ 407 and mark the helper as
          * Needing YR. */
-        auth_user_request->denyMessage(blob);
+        Note::Pointer errNote = reply.notes.find("message");
+        if (reply.result == HelperReply::Unknown)
+            auth_user_request->denyMessage("Internal Error");
+        else if (errNote != NULL)
+            auth_user_request->denyMessage(errNote->firstValue());
+        else
+            auth_user_request->denyMessage("Negotiate Authentication failed with no reason given");
         auth_user_request->user()->credentials(Auth::Failed);
         safe_free(lm_request->server_blob);
         lm_request->releaseAuthServer();
         debugs(29, DBG_IMPORTANT, "ERROR: Negotiate Authentication validating user. Error returned " << reply);
+    } // break;
     }
 
-    xfree(arg);
     if (lm_request->request) {
         HTTPMSGUNLOCK(lm_request->request);
         lm_request->request = NULL;
@@ -255,34 +255,32 @@ Auth::Ntlm::UserRequest::HandleReply(void *data, const HelperReply &reply)
     else
         assert(reply.whichServer == lm_request->authserver);
 
-    /* seperate out the useful data */
-    const char *blob = reply.other().content();
-
     switch (reply.result) {
     case HelperReply::TT:
         /* we have been given a blob to send to the client */
         safe_free(lm_request->server_blob);
         lm_request->request->flags.mustKeepalive = 1;
         if (lm_request->request->flags.proxyKeepalive) {
-            lm_request->server_blob = xstrdup(blob);
+            Note::Pointer serverBlob = reply.notes.find("token");
+            lm_request->server_blob = xstrdup(serverBlob->firstValue());
             auth_user_request->user()->credentials(Auth::Handshake);
             auth_user_request->denyMessage("Authentication in progress");
-            debugs(29, 4, HERE << "Need to challenge the client with a server blob '" << blob << "'");
+            debugs(29, 4, HERE << "Need to challenge the client with a server token: '" << serverBlob->firstValue() << "'");
         } else {
             auth_user_request->user()->credentials(Auth::Failed);
             auth_user_request->denyMessage("NTLM authentication requires a persistent connection");
         }
         break;
 
-    case HelperReply::AF:
     case HelperReply::Okay: {
         /* we're finished, release the helper */
-        auth_user_request->user()->username(blob);
+        Note::Pointer userLabel = reply.notes.find("user");
+        auth_user_request->user()->username(userLabel->firstValue());
         auth_user_request->denyMessage("Login successful");
         safe_free(lm_request->server_blob);
         lm_request->releaseAuthServer();
 
-        debugs(29, 4, HERE << "Successfully validated user via NTLM. Username '" << blob << "'");
+        debugs(29, 4, HERE << "Successfully validated user via NTLM. Username '" << userLabel->firstValue() << "'");
         /* connection is authenticated */
         debugs(29, 4, HERE << "authenticated user " << auth_user_request->user()->username());
         /* see if this is an existing user with a different proxy_auth
@@ -309,37 +307,47 @@ Auth::Ntlm::UserRequest::HandleReply(void *data, const HelperReply &reply)
          * existing user or a new user */
         local_auth_user->expiretime = current_time.tv_sec;
         auth_user_request->user()->credentials(Auth::Ok);
-        debugs(29, 4, HERE << "Successfully validated user via NTLM. Username '" << blob << "'");
+        debugs(29, 4, HERE << "Successfully validated user via NTLM. Username '" << auth_user_request->user()->username() << "'");
     }
     break;
 
-    case HelperReply::NA:
-    case HelperReply::Error:
+    case HelperReply::Error: {
         /* authentication failure (wrong password, etc.) */
-        auth_user_request->denyMessage(blob);
+        Note::Pointer errNote = reply.notes.find("message");
+        if (errNote != NULL)
+            auth_user_request->denyMessage(errNote->firstValue());
+        else
+            auth_user_request->denyMessage("NTLM Authentication denied with no reason given");
         auth_user_request->user()->credentials(Auth::Failed);
         safe_free(lm_request->server_blob);
         lm_request->releaseAuthServer();
-        debugs(29, 4, HERE << "Failed validating user via NTLM. Error returned '" << blob << "'");
-        break;
+        debugs(29, 4, HERE << "Failed validating user via NTLM. Error returned '" << errNote->firstValue() << "'");
+    }
+    break;
 
     case HelperReply::Unknown:
         debugs(29, DBG_IMPORTANT, "ERROR: NTLM Authentication Helper '" << reply.whichServer << "' crashed!.");
-        blob = "Internal error";
         /* continue to the next case */
 
-    case HelperReply::BrokenHelper:
+    case HelperReply::BrokenHelper: {
         /* TODO kick off a refresh process. This can occur after a YR or after
          * a KK. If after a YR release the helper and resubmit the request via
          * Authenticate NTLM start.
          * If after a KK deny the user's request w/ 407 and mark the helper as
          * Needing YR. */
-        auth_user_request->denyMessage(blob);
+        Note::Pointer errNote = reply.notes.find("message");
+        if (reply.result == HelperReply::Unknown)
+            auth_user_request->denyMessage("Internal Error");
+        else if (errNote != NULL)
+            auth_user_request->denyMessage(errNote->firstValue());
+        else
+            auth_user_request->denyMessage("NTLM Authentication failed with no reason given");
         auth_user_request->user()->credentials(Auth::Failed);
         safe_free(lm_request->server_blob);
         lm_request->releaseAuthServer();
         debugs(29, DBG_IMPORTANT, "ERROR: NTLM Authentication validating user. Error returned '" << reply << "'");
-        break;
+    }
+    break;
     }
 
     if (lm_request->request) {
@@ -17,7 +17,7 @@ TextException::TextException(const TextException& right) :
 }
 
 TextException::TextException(const char *aMsg, const char *aFileName, int aLineNo, unsigned int anId):
-        message(xstrdup(aMsg)), theFileName(aFileName), theLineNo(aLineNo), theId(anId)
+        message(aMsg?xstrdup(aMsg):NULL), theFileName(aFileName), theLineNo(aLineNo), theId(anId)
 {}
 
 TextException::~TextException() throw()
@@ -594,6 +594,7 @@ parseOneConfigFile(const char *file_name, unsigned int depth)
     cfg_filename = orig_cfg_filename;
     config_lineno = orig_config_lineno;
 
+    xfree(tmp_line);
     return err_count;
 }
 
@@ -242,9 +242,22 @@ DOC_START
 
 	"program" cmdline
 	Specify the command for the external authenticator.  Such a program
-	reads a line containing "username password" and replies "OK" or
-	"ERR" in an endless loop. "ERR" responses may optionally be followed
-	by a error description available as %m in the returned error page.
+	reads a line containing "username password" and	replies with one of
+	three results:
+
+	  OK
+		the user exists.
+
+	  ERR
+		the user does not exist.
+
+	  BH
+		An internal error occured in the helper, preventing
+		a result being identified.
+
+	"ERR" and "BH" results may optionally be followed by message="..."
+	containing a description available as %m in the returned error page.
+
 	If you use an authenticator, make sure you have 1 acl of type
 	proxy_auth.
 
@@ -315,11 +328,22 @@ DOC_START
 	"program" cmdline
 	Specify the command for the external authenticator.  Such
 	a program reads a line containing "username":"realm" and
-	replies with the appropriate H(A1) value hex encoded or
-	ERR if the user (or his H(A1) hash) does not exists.
-	See rfc 2616 for the definition of H(A1).
-	"ERR" responses may optionally be followed by a error description
-	available as %m in the returned error page.
+	replies with one of three results:
+
+	  OK ha1="..."
+		the user exists. The ha1= key is mandatory and
+		contains the appropriate H(A1) value, hex encoded.
+		See rfc 2616 for the definition of H(A1).
+
+	  ERR
+		the user does not exist.
+
+	  BH
+		An internal error occured in the helper, preventing
+		a result being identified.
+
+	"ERR" and "BH" results may optionally be followed by message="..."
+	containing a description available as %m in the returned error page.
 
 	By default, the digest authentication scheme is not used unless a
 	program is specified.
@@ -401,7 +425,7 @@ DOC_START
 	Such a program reads exchanged NTLMSSP packets with
 	the browser via Squid until authentication is completed.
 	If you use an NTLM authenticator, make sure you have 1 acl
-	of type proxy_auth.  By default, the NTLM authenticator_program
+	of type proxy_auth.  By default, the NTLM authenticator program
 	is not used.
 
 	auth_param ntlm program @DEFAULT_PREFIX@/bin/ntlm_auth
@@ -441,7 +465,7 @@ DOC_START
 	using the Kerberos mechanisms.
 	If you use a Negotiate authenticator, make sure you have at least
 	one acl of type proxy_auth active. By default, the negotiate
-	authenticator_program is not used.
+	authenticator program is not used.
 	The only supported program for this role is the ntlm_auth
 	program distributed as part of Samba, version 4 or later.
 
@@ -619,40 +643,87 @@ DOC_START
 	  %%		The percent sign. Useful for helpers which need
 			an unchanging input format.
 
-	In addition to the above, any string specified in the referencing
-	acl will also be included in the helper request line, after the
-	specified formats (see the "acl external" directive)
 
-	The helper receives lines per the above format specification,
-	and returns lines starting with OK or ERR indicating the validity
-	of the request and optionally followed by additional keywords with
-	more details.
+	General request syntax:
+
+	  [channel-ID] FORMAT-values [acl-values ...]
+
+
+	FORMAT-values consists of transaction details expanded with
+	whitespace separation per the config file FORMAT specification
+	using the FORMAT macros listed above.
+
+	acl-values consists of any string specified in the referencing
+	config 'acl ... external' line. see the "acl external" directive.
+
+	Request values sent to the helper are URL escaped to protect
+	each value in requests against whitespaces.
+
+	If using protocol=2.5 then the request sent to the helper is not
+	URL escaped to protect against whitespace.
+
+	NOTE: protocol=3.0 is deprecated as no longer necessary.
+
+	When using the concurrency= option the protocol is changed by
+	introducing a query channel tag in front of the request/response.
+	The query channel tag is a number between 0 and concurrency-1.
+	This value must be echoed back unchanged to Squid as the first part
+	of the response relating to its request.
+
+
+	The helper receives lines expanded per the above format specification
+	and for each input line returns 1 line starting with OK/ERR/BH result
+	code and optionally followed by additional keywords with more details.
+
 
 	General result syntax:
 
-	  OK/ERR keyword=value ...
+	  [channel-ID] result keyword=value ...
+
+	Result consists of one of the codes:
+
+	  OK
+		the ACL test produced a match.
+
+	  ERR
+		the ACL test does not produce a match.
+
+	  BH
+		An internal error occured in the helper, preventing
+		a result being identified.
+
+	The meaning of 'a match' is determined by your squid.conf
+	access control configuration. See the Squid wiki for details.
 
 	Defined keywords:
 
 	  user=		The users name (login)
+
 	  password=	The users password (for login= cache_peer option)
-	  message=	Message describing the reason. Available as %o
-	  		in error pages
-	  tag=		Apply a tag to a request (for both ERR and OK results)
-	  		Only sets a tag, does not alter existing tags.
+
+	  message=	Message describing the reason for this response.
+			Available as %o in error pages.
+			Useful on (ERR and BH results).
+
+	  tag=		Apply a tag to a request. Only sets a tag once,
+			does not alter existing tags.
+
 	  log=		String to be logged in access.log. Available as
-	  		%ea in logformat specifications
+	  		%ea in logformat specifications.
 
-	If protocol=3.0 (the default) then URL escaping is used to protect
-	each value in both requests and responses.
+	Any keywords may be sent on any response whether OK, ERR or BH.
 
-	If using protocol=2.5 then all values need to be enclosed in quotes
-	if they may contain whitespace, or the whitespace escaped using \.
-	And quotes or \ characters within the keyword value must be \ escaped.
+	All response keyword values need to be a single token with URL
+	escaping, or enclosed in double quotes (") and escaped using \ on
+	any double quotes or \ characters within the value. The wrapping
+	double quotes are removed before the value is interpreted by Squid.
+	\r and \n are also replace by CR and LF.
 
-	When using the concurrency= option the protocol is changed by
-	introducing a query channel tag infront of the request/response.
-	The query channel tag is a number between 0 and concurrency-1.
+	Some example key values:
+
+		user=John%20Smith
+		user="John Smith"
+		user="J. \"Bob\" Smith"
 DOC_END
 
 NAME: acl
@@ -4117,19 +4188,54 @@ DOC_START
 
 	For each requested URL, the rewriter will receive on line with the format
 
-	URL <SP> client_ip "/" fqdn <SP> user <SP> method [<SP> kvpairs]<NL>
+	  [channel-ID <SP>] URL <SP> client_ip "/" fqdn <SP> user <SP> method [<SP> kv-pairs]<NL>
+
 
-	In the future, the rewriter interface will be extended with
-	key=value pairs ("kvpairs" shown above).  Rewriter programs
+	After processing the request the helper must reply using the following format:
+
+	  [channel-ID <SP>] result [<SP> kv-pairs]
+
+	The result code can be:
+
+	  OK status=30N url="..."
+		Redirect the URL to the one supplied in 'url='.
+		'status=' is optional and contains the status code to send
+		the client in Squids HTTP response. It must be one of the
+		HTTP redirect status codes: 301, 302, 303, 307, 308.
+		When no status is given Squid will use 302.
+
+	  OK rewrite-url="..."
+		Rewrite the URL to the one supplied in 'rewrite-url='.
+		The new URL is fetched directly by Squid and returned to
+		the client as the response to its request.
+
+	  ERR
+		Do not change the URL.
+
+	  BH
+		An internal error occured in the helper, preventing
+		a result being identified.
+
+
+	In the future, the interface protocol will be extended with
+	key=value pairs ("kv-pairs" shown above).  Helper programs
 	should be prepared to receive and possibly ignore additional
 	whitespace-separated tokens on each input line.
 
-	And the rewriter may return a rewritten URL. The other components of
-	the request line does not need to be returned (ignored if they are).
+	When using the concurrency= option the protocol is changed by
+	introducing a query channel tag in front of the request/response.
+	The query channel tag is a number between 0 and concurrency-1.
+	This value must be echoed back unchanged to Squid as the first part
+	of the response relating to its request.
+
+	WARNING: URL re-writing ability should be avoided whenever possible.
+		 Use the URL redirect form of response instead.
 
-	The rewriter can also indicate that a client-side redirect should
-	be performed to the new URL. This is done by prefixing the returned
-	URL with "301:" (moved permanently) or 302: (moved temporarily), etc.
+	Re-write creates a difference in the state held by the client
+	and server. Possibly causing confusion when the server response
+	contains snippets of its view state. Embeded URLs, response
+	and content Location headers, etc. are not re-written by this
+	interface.
 
 	By default, a URL rewriter is not used.
 DOC_END
@@ -615,6 +615,8 @@ prepareLogWithRequestDetails(HttpRequest * request, AccessLogEntry::Pointer &aLo
     aLogEntry->http.method = request->method;
     aLogEntry->http.version = request->http_ver;
     aLogEntry->hier = request->hier;
+    if (request->helperNotes)
+        aLogEntry->notes.append(request->helperNotes->notes);
     if (request->content_length > 0) // negative when no body or unknown length
         aLogEntry->cache.requestSize += request->content_length;
     aLogEntry->cache.extuser = request->extacl_user.termedBuf();
@@ -3698,8 +3700,10 @@ ConnStateData::sslCrtdHandleReplyWrapper(void *data, const HelperReply &reply)
 void
 ConnStateData::sslCrtdHandleReply(const HelperReply &reply)
 {
-    if (!reply.other().hasContent()) {
-        debugs(1, DBG_IMPORTANT, HERE << "\"ssl_crtd\" helper return <NULL> reply");
+    if (reply.result == HelperReply::BrokenHelper) {
+        debugs(33, 5, HERE << "Certificate for " << sslConnectHostOrIp << " cannot be generated. ssl_crtd response: " << reply);
+    } else if (!reply.other().hasContent()) {
+        debugs(1, DBG_IMPORTANT, HERE << "\"ssl_crtd\" helper returned <NULL> reply.");
     } else {
         Ssl::CrtdMessage reply_message(Ssl::CrtdMessage::REPLY);
         if (reply_message.parse(reply.other().content(), reply.other().contentSize()) != Ssl::CrtdMessage::OK) {
@@ -156,6 +156,7 @@ ClientRequestContext::ClientRequestContext(ClientHttpRequest *anHttp) : http(cbd
 {
     http_access_done = false;
     redirect_done = false;
+    redirect_fail_count = 0;
     no_cache_done = false;
     interpreted_req_hdrs = false;
 #if USE_SSL
@@ -902,7 +903,7 @@ clientRedirectAccessCheckDone(allow_t answer, void *data)
     if (answer == ACCESS_ALLOWED)
         redirectStart(http, clientRedirectDoneWrapper, context);
     else {
-        HelperReply nilReply(NULL,0);
+        HelperReply nilReply;
         context->clientRedirectDone(nilReply);
     }
 }
@@ -1203,57 +1204,104 @@ ClientRequestContext::clientRedirectDone(const HelperReply &reply)
     assert(redirect_state == REDIRECT_PENDING);
     redirect_state = REDIRECT_DONE;
 
-    if (reply.other().hasContent()) {
-        /* 2012-06-28: This cast is due to urlParse() truncating too-long URLs itself.
-         * At this point altering the helper buffer in that way is not harmful, but annoying.
-         * When Bug 1961 is resolved and urlParse has a const API, this needs to die.
-         */
-        char * result = const_cast<char*>(reply.other().content());
-        http_status status = (http_status) atoi(result);
+    // copy the URL rewriter response Notes to the HTTP request for logging
+    // do it early to ensure that no matter what the outcome the notes are present.
+    // TODO put them straight into the transaction state record (ALE?) eventually
+    if (!old_request->helperNotes)
+        old_request->helperNotes = new Notes;
+    old_request->helperNotes->add(reply.notes);
+
+    switch (reply.result) {
+    case HelperReply::Unknown:
+    case HelperReply::TT:
+        // Handler in redirect.cc should have already mapped Unknown
+        // IF it contained valid entry for the old URL-rewrite helper protocol
+        debugs(85, DBG_IMPORTANT, "ERROR: URL rewrite helper returned invalid result code. Wrong helper? " << reply);
+        break;
+
+    case HelperReply::BrokenHelper:
+        debugs(85, DBG_IMPORTANT, "ERROR: URL rewrite helper: " << reply << ", attempt #" << (redirect_fail_count+1) << " of 2");
+        if (redirect_fail_count < 2) { // XXX: make this configurable ?
+            ++redirect_fail_count;
+            // reset state flag to try redirector again from scratch.
+            redirect_done = false;
+        }
+        break;
+
+    case HelperReply::Error:
+        // no change to be done.
+        break;
 
-        if (status == HTTP_MOVED_PERMANENTLY
-                || status == HTTP_MOVED_TEMPORARILY
-                || status == HTTP_SEE_OTHER
-                || status == HTTP_PERMANENT_REDIRECT
-                || status == HTTP_TEMPORARY_REDIRECT) {
-            char *t = NULL;
+    case HelperReply::Okay: {
+        // #1: redirect with a specific status code    OK status=NNN url="..."
+        // #2: redirect with a default status code     OK url="..."
+        // #3: re-write the URL                        OK rewrite-url="..."
+
+        Note::Pointer statusNote = reply.notes.find("status");
+        Note::Pointer urlNote = reply.notes.find("url");
+
+        if (urlNote != NULL) {
+            // HTTP protocol redirect to be done.
+
+            // TODO: change default redirect status for appropriate requests
+            // Squid defaults to 302 status for now for better compatibility with old clients.
+            // HTTP/1.0 client should get 302 (HTTP_MOVED_TEMPORARILY)
+            // HTTP/1.1 client contacting reverse-proxy should get 307 (HTTP_TEMPORARY_REDIRECT)
+            // HTTP/1.1 client being diverted by forward-proxy should get 303 (HTTP_SEE_OTHER)
+            http_status status = HTTP_MOVED_TEMPORARILY;
+            if (statusNote != NULL) {
+                const char * result = statusNote->firstValue();
+                status = (http_status) atoi(result);
+            }
 
-            if ((t = strchr(result, ':')) != NULL) {
+            if (status == HTTP_MOVED_PERMANENTLY
+                    || status == HTTP_MOVED_TEMPORARILY
+                    || status == HTTP_SEE_OTHER
+                    || status == HTTP_PERMANENT_REDIRECT
+                    || status == HTTP_TEMPORARY_REDIRECT) {
                 http->redirect.status = status;
-                http->redirect.location = xstrdup(t + 1);
+                http->redirect.location = xstrdup(urlNote->firstValue());
                 // TODO: validate the URL produced here is RFC 2616 compliant absolute URI
             } else {
-                debugs(85, DBG_CRITICAL, "ERROR: URL-rewrite produces invalid " << status << " redirect Location: " << result);
+                debugs(85, DBG_CRITICAL, "ERROR: URL-rewrite produces invalid " << status << " redirect Location: " << urlNote->firstValue());
             }
-        } else if (strcmp(result, http->uri)) {
-            // XXX: validate the URL properly *without* generating a whole new request object right here.
-            // XXX: the clone() should be done only AFTER we know the new URL is valid.
-            HttpRequest *new_request = old_request->clone();
-            if (urlParse(old_request->method, result, new_request)) {
-                debugs(61,2, HERE << "URL-rewriter diverts URL from " << urlCanonical(old_request) << " to " << urlCanonical(new_request));
-
-                // update the new request to flag the re-writing was done on it
-                new_request->flags.redirected = 1;
-
-                // unlink bodypipe from the old request. Not needed there any longer.
-                if (old_request->body_pipe != NULL) {
-                    old_request->body_pipe = NULL;
-                    debugs(61,2, HERE << "URL-rewriter diverts body_pipe " << new_request->body_pipe <<
-                           " from request " << old_request << " to " << new_request);
-                }
+        } else {
+            // URL-rewrite wanted. Ew.
+            urlNote = reply.notes.find("rewrite-url");
+
+            // prevent broken helpers causing too much damage. If old URL == new URL skip the re-write.
+            if (urlNote != NULL && strcmp(urlNote->firstValue(), http->uri)) {
+                // XXX: validate the URL properly *without* generating a whole new request object right here.
+                // XXX: the clone() should be done only AFTER we know the new URL is valid.
+                HttpRequest *new_request = old_request->clone();
+                if (urlParse(old_request->method, const_cast<char*>(urlNote->firstValue()), new_request)) {
+                    debugs(61,2, HERE << "URL-rewriter diverts URL from " << urlCanonical(old_request) << " to " << urlCanonical(new_request));
+
+                    // update the new request to flag the re-writing was done on it
+                    new_request->flags.redirected = 1;
+
+                    // unlink bodypipe from the old request. Not needed there any longer.
+                    if (old_request->body_pipe != NULL) {
+                        old_request->body_pipe = NULL;
+                        debugs(61,2, HERE << "URL-rewriter diverts body_pipe " << new_request->body_pipe <<
+                               " from request " << old_request << " to " << new_request);
+                    }
 
-                // update the current working ClientHttpRequest fields
-                safe_free(http->uri);
-                http->uri = xstrdup(urlCanonical(new_request));
-                HTTPMSGUNLOCK(old_request);
-                http->request = HTTPMSGLOCK(new_request);
-            } else {
-                debugs(85, DBG_CRITICAL, "ERROR: URL-rewrite produces invalid request: " <<
-                       old_request->method << " " << result << " " << old_request->http_ver);
-                delete new_request;
+                    // update the current working ClientHttpRequest fields
+                    safe_free(http->uri);
+                    http->uri = xstrdup(urlCanonical(new_request));
+                    HTTPMSGUNLOCK(old_request);
+                    http->request = HTTPMSGLOCK(new_request);
+                } else {
+                    debugs(85, DBG_CRITICAL, "ERROR: URL-rewrite produces invalid request: " <<
+                           old_request->method << " " << urlNote->firstValue() << " " << old_request->http_ver);
+                    delete new_request;
+                }
             }
         }
     }
+    break;
+    }
 
     /* FIXME PIPELINE: This is innacurate during pipelining */
 
@@ -21,6 +21,8 @@ class ConnOpener : public AsyncJob
     virtual void swanSong();
 
 public:
+    void noteAbort() { mustStop("externally aborted"); }
+
     typedef CbcPointer<ConnOpener> Pointer;
 
     virtual bool doneAll() const;
@@ -53,11 +53,12 @@
 #if HAVE_ERRNO_H
 #include <errno.h>
 #endif
+#ifdef HAVE_NETINET_TCP_H
+// required for accept_filter to build.
+#include <netinet/tcp.h>
+#endif
 
-namespace Comm
-{
-CBDATA_CLASS_INIT(TcpAcceptor);
-};
+CBDATA_NAMESPACED_CLASS_INIT(Comm, TcpAcceptor);
 
 Comm::TcpAcceptor::TcpAcceptor(const Comm::ConnectionPointer &newConn, const char *note, const Subscription::Pointer &aSub) :
         AsyncJob("Comm::TcpAcceptor"),
@@ -368,7 +368,7 @@ ClassCBucket::update (DelaySpec const &rate, int incr)
     /* If we aren't active, don't try to update us ! */
     assert (rate.restore_bps != -1);
 
-    for (unsigned char j = 0; j < individuals.size(); ++j)
+    for (unsigned int j = 0; j < individuals.size(); ++j)
         individuals.values[j].update (rate, incr);
 }
 
@@ -131,7 +131,13 @@ dnsSubmit(const char *lookup, HLPCB * callback, void *data)
         debugs(34, DBG_IMPORTANT, "dnsSubmit: queue overload, rejecting " << lookup);
 
         const char *t = "$fail Temporary network problem, please retry later";
-        HelperReply failReply(t, strlen(t));
+        HelperReply failReply;
+        /* XXX: upgrade the ipcache and fqdn cache handlers to new syntax
+        failReply.result= HelperReply::BrokenHelper;
+        failReply.notes.add("message","Temporary network problem, please retry later");
+        failReply.notes.add("message","DNS lookup queue overloaded");
+        */
+        failReply.modifiableOther().append(t, strlen(t));
         callback(data, failReply);
         return;
     }
@@ -333,7 +333,8 @@ idnsAddPathComponent(const char *buf)
     }
 
     assert(npc < npc_alloc);
-    strcpy(searchpath[npc].domain, buf);
+    strncpy(searchpath[npc].domain, buf, sizeof(searchpath[npc].domain)-1);
+    searchpath[npc].domain[sizeof(searchpath[npc].domain)-1] = '\0';
     Tolower(searchpath[npc].domain);
     debugs(78, 3, "idnsAddPathComponent: Added domain #" << npc << ": " << searchpath[npc].domain);
     ++npc;
@@ -50,7 +50,22 @@ class ESIContext : public esiTreeParent, public ESIParserClient
     typedef RefCount<ESIContext> Pointer;
     void *operator new (size_t byteCount);
     void operator delete (void *address);
-    ESIContext():reading_(true) {}
+    ESIContext() :
+            thisNode(NULL),
+            http(NULL),
+            errorpage(ERR_NONE),
+            errorstatus(HTTP_STATUS_NONE),
+            errormessage(NULL),
+            rep(NULL),
+            outbound_offset(0),
+            readpos(0),
+            pos(0),
+            varState(NULL),
+            cachedASTInUse(false),
+            reading_(true),
+            processing(false) {
+        memset(&flags, 0, sizeof(flags));
+    }
 
     ~ESIContext();
 
@@ -68,7 +68,9 @@ ESICustomParser::GetTrie()
     return SearchTrie;
 }
 
-ESICustomParser::ESICustomParser(ESIParserClient *aClient) : theClient (aClient)
+ESICustomParser::ESICustomParser(ESIParserClient *aClient) :
+        theClient(aClient),
+        lastTag(ESITAG)
 {}
 
 ESICustomParser::~ESICustomParser()
@@ -190,7 +192,14 @@ ESICustomParser::parse(char const *dataToParse, size_t const lengthOfData, bool
                 }
 
                 char *value = equals + 1;
-                char *end = strchr (value, sep);
+                char *end = strchr(value, sep);
+
+                if (!end) {
+                    error = "Missing attribute ending separator (";
+                    error.append(sep);
+                    error.append(")");
+                    return false;
+                }
                 attributes.push_back(value);
                 *end = '\0';
                 attribute = end + 1;
@@ -968,7 +968,10 @@ ESIContext::ParserState::top()
     return stack[stackdepth-1];
 }
 
-ESIContext::ParserState::ParserState() : inited_ (false)
+ESIContext::ParserState::ParserState() :
+        stackdepth(0),
+        parsing(0),
+        inited_(false)
 {}
 
 bool
@@ -1554,6 +1557,7 @@ esiLiteral::finish()
 esiLiteral::esiLiteral(ESIContext *context, const char *s, int numberOfCharacters)
 {
     assert (s);
+    flags.donevars = 0;
     buffer = new ESISegment;
     ESISegment::Pointer local = buffer;
     size_t start = 0;
@@ -1570,7 +1574,7 @@ esiLiteral::esiLiteral(ESIContext *context, const char *s, int numberOfCharacter
         remainingCharacters -= len;
     }
 
-    varState = cbdataReference (context->varState);
+    varState = cbdataReference(context->varState);
 }
 
 void
@@ -1705,11 +1709,15 @@ esiTry::~esiTry()
     debugs(86, 5, "esiTry::~esiTry " << this);
 }
 
-esiTry::esiTry(esiTreeParentPtr aParent) : parent (aParent) , exceptbuffer(NULL)
-{}
+esiTry::esiTry(esiTreeParentPtr aParent) :
+        parent(aParent),
+        exceptbuffer(NULL)
+{
+    memset(&flags, 0, sizeof(flags));
+}
 
 void
-esiTry::render (ESISegment::Pointer output)
+esiTry::render(ESISegment::Pointer output)
 {
     /* Try renders from it's children */
     assert (this);
@@ -2087,8 +2095,8 @@ esiChoose::selectElement()
         return;
 
     for (size_t counter = 0; counter < elements.size(); ++counter) {
-        if ((dynamic_cast<esiWhen *>(elements[counter].getRaw()))->
-                testsTrue()) {
+        const esiWhen *el = dynamic_cast<esiWhen *>(elements[counter].getRaw());
+        if (el && el->testsTrue()) {
             chosenelement = counter;
             debugs (86,3, "esiChooseAdd: Chose element " << counter + 1);
             return;
@@ -2325,9 +2333,12 @@ ElementList::size() const
 }
 
 /* esiWhen */
-esiWhen::esiWhen (esiTreeParentPtr aParent, int attrcount, const char **attr,ESIVarState *aVar) : esiSequence (aParent)
+esiWhen::esiWhen(esiTreeParentPtr aParent, int attrcount, const char **attr,ESIVarState *aVar) :
+        esiSequence(aParent),
+        testValue(false),
+        unevaluatedExpression(NULL),
+        varState(NULL)
 {
-    varState = NULL;
     char const *expression = NULL;
 
     for (int loopCounter = 0; loopCounter < attrcount && attr[loopCounter]; loopCounter += 2) {
@@ -2370,7 +2381,7 @@ esiWhen::evaluate()
     if (!unevaluatedExpression)
         return;
 
-    assert (varState);
+    assert(varState);
 
     varState->feedData(unevaluatedExpression, strlen (unevaluatedExpression));
 
@@ -2381,14 +2392,14 @@ esiWhen::evaluate()
     safe_free (expression);
 }
 
-esiWhen::esiWhen(esiWhen const &old) : esiSequence (old)
+esiWhen::esiWhen(esiWhen const &old) :
+        esiSequence(old),
+        testValue(false),
+        unevaluatedExpression(NULL),
+        varState(NULL)
 {
-    unevaluatedExpression = NULL;
-
     if (old.unevaluatedExpression)
         unevaluatedExpression = xstrdup(old.unevaluatedExpression);
-
-    varState = NULL;
 }
 
 ESIElement::Pointer
@@ -293,10 +293,6 @@ evalor(stackmember * stack, int *depth, int whereAmI, stackmember * candidate)
 
     rv = stack[whereAmI - 1].value.integral || stack[whereAmI + 1].value.integral;
 
-    if (rv == -2)
-        /* invalid comparison */
-        return 1;
-
     stackpop(stack, depth);      /* arg rhs */
 
     stackpop(stack, depth);      /* me */
@@ -344,10 +340,6 @@ evaland(stackmember * stack, int *depth, int whereAmI, stackmember * candidate)
 
     rv = stack[whereAmI - 1].value.integral && stack[whereAmI + 1].value.integral;
 
-    if (rv == -2)
-        /* invalid comparison */
-        return 1;
-
     stackpop(stack, depth);      /* arg rhs */
 
     stackpop(stack, depth);      /* me */
@@ -299,9 +299,15 @@ ESIInclude::makeUsable(esiTreeParentPtr newParent, ESIVarState &newVarState) con
     return result;
 }
 
-ESIInclude::ESIInclude(ESIInclude const &old) : parent (NULL), started (false), sent (false)
+ESIInclude::ESIInclude(ESIInclude const &old) :
+        varState(NULL),
+        srcurl(NULL),
+        alturl(NULL),
+        parent(NULL),
+        started(false),
+        sent(false)
 {
-    varState = NULL;
+    memset(&flags, 0, sizeof(flags));
     flags.onerrorcontinue = old.flags.onerrorcontinue;
 
     if (old.srcurl)
@@ -343,12 +349,18 @@ ESIInclude::Start (ESIStreamContext::Pointer stream, char const *url, ESIVarStat
     tempheaders.clean();
 }
 
-ESIInclude::ESIInclude (esiTreeParentPtr aParent, int attrcount, char const **attr, ESIContext *aContext) : parent (aParent), started (false), sent (false)
+ESIInclude::ESIInclude(esiTreeParentPtr aParent, int attrcount, char const **attr, ESIContext *aContext) :
+        varState(NULL),
+        srcurl(NULL),
+        alturl(NULL),
+        parent(aParent),
+        started(false),
+        sent(false)
 {
-    int i;
     assert (aContext);
+    memset(&flags, 0, sizeof(flags));
 
-    for (i = 0; i < attrcount && attr[i]; i += 2) {
+    for (int i = 0; i < attrcount && attr[i]; i += 2) {
         if (!strcmp(attr[i],"src")) {
             /* Start a request for thisNode url */
             debugs(86, 5, "ESIIncludeNew: Requesting source '" << attr[i+1] << "'");
@@ -52,8 +52,19 @@ esiSequence::~esiSequence ()
     debugs(86, 5, "esiSequence::~esiSequence " << this);
 }
 
-esiSequence::esiSequence(esiTreeParentPtr aParent, bool incrementalFlag) : elements(), parent (aParent), mayFail_(true), failed (false), provideIncrementalData (incrementalFlag), processing (false), processingResult (ESI_PROCESS_COMPLETE), nextElementToProcess_ (0)
-{}
+esiSequence::esiSequence(esiTreeParentPtr aParent, bool incrementalFlag) :
+        elements(),
+        processedcount(0),
+        parent(aParent),
+        mayFail_(true),
+        failed(false),
+        provideIncrementalData(incrementalFlag),
+        processing(false),
+        processingResult(ESI_PROCESS_COMPLETE),
+        nextElementToProcess_(0)
+{
+    memset(&flags, 0, sizeof(flags));
+}
 
 size_t
 esiSequence::nextElementToProcess() const
@@ -329,11 +340,17 @@ esiSequence::fail (ESIElement *source, char const *anError)
     parent = NULL;
 }
 
-esiSequence::esiSequence(esiSequence const &old)
-        : processedcount (0), mayFail_(old.mayFail_), failed (old.failed), provideIncrementalData (old.provideIncrementalData), processing (false), nextElementToProcess_ (0)
+esiSequence::esiSequence(esiSequence const &old) :
+        processedcount(0),
+        parent(NULL),
+        mayFail_(old.mayFail_),
+        failed(old.failed),
+        provideIncrementalData(old.provideIncrementalData),
+        processing(false),
+        processingResult(ESI_PROCESS_COMPLETE),
+        nextElementToProcess_(0)
 {
     flags.dovars = old.flags.dovars;
-    parent = NULL;
 }
 
 void
@@ -291,9 +291,12 @@ ESIVariableQuery::~ESIVariableQuery()
     safe_free (query_string);
 }
 
-ESIVarState::ESIVarState (HttpHeader const *aHeader, char const *uri)
-        : output (NULL), hdr(hoReply)
+ESIVarState::ESIVarState(HttpHeader const *aHeader, char const *uri) :
+        output(NULL),
+        hdr(hoReply)
 {
+    memset(&flags, 0, sizeof(flags));
+
     /* TODO: only grab the needed headers */
     /* Note that as we pass these through to included requests, we
      * cannot trim them */
@@ -173,6 +173,11 @@ Eui::Eui48::lookup(const Ip::Address &c)
 
     /* IPv6 builds do not provide the first http_port as an IPv4 socket for ARP */
     int tmpSocket = socket(AF_INET,SOCK_STREAM,0);
+    if (tmpSocket < 0) {
+        debugs(28, DBG_IMPORTANT, "Attempt to open socket for EUI retrieval failed: " << xstrerror());
+        clear();
+        return false;
+    }
 
     /*
      * The linux kernel 2.2 maintains per interface ARP caches and
@@ -312,6 +317,11 @@ Eui::Eui48::lookup(const Ip::Address &c)
 
     /* IPv6 builds do not provide the first http_port as an IPv4 socket for ARP */
     int tmpSocket = socket(AF_INET,SOCK_STREAM,0);
+    if (tmpSocket < 0) {
+        debugs(28, DBG_IMPORTANT, "Attempt to open socket for EUI retrieval failed: " << xstrerror());
+        clear();
+        return false;
+    }
 
     /* Set up structures for ARP lookup with blank interface name */
     struct arpreq arpReq;
@@ -361,10 +361,13 @@ parse_externalAclHelper(external_acl ** list)
         } else if (strcmp(token, "protocol=2.5") == 0) {
             a->quote = external_acl::QUOTE_METHOD_SHELL;
         } else if (strcmp(token, "protocol=3.0") == 0) {
+            debugs(3, DBG_PARSE_NOTE(2), "WARNING: external_acl_type option protocol=3.0 is deprecated. Remove this from your config.");
             a->quote = external_acl::QUOTE_METHOD_URL;
         } else if (strcmp(token, "quote=url") == 0) {
+            debugs(3, DBG_PARSE_NOTE(2), "WARNING: external_acl_type option quote=url is deprecated. Remove this from your config.");
             a->quote = external_acl::QUOTE_METHOD_URL;
         } else if (strcmp(token, "quote=shell") == 0) {
+            debugs(3, DBG_PARSE_NOTE(2), "WARNING: external_acl_type option quote=shell is deprecated. Use protocol=2.5 if still needed.");
             a->quote = external_acl::QUOTE_METHOD_SHELL;
 
             /* INET6: allow admin to configure some helpers explicitly to
@@ -549,6 +552,9 @@ dump_externalAclHelper(StoreEntry * sentry, const char *name, const external_acl
         if (node->cache)
             storeAppendPrintf(sentry, " cache=%d", node->cache_size);
 
+        if (node->quote == external_acl::QUOTE_METHOD_SHELL)
+            storeAppendPrintf(sentry, " protocol=2.5");
+
         for (format = node->format; format; format = format->next) {
             switch (format->type) {
 
@@ -1302,16 +1308,14 @@ free_externalAclState(void *data)
  *
  * Other keywords may be added to the protocol later
  *
- * value needs to be enclosed in quotes if it may contain whitespace, or
- * the whitespace escaped using \ (\ escaping obviously also applies to
- * any " characters)
+ * value needs to be URL-encoded or enclosed in double quotes (")
+ * with \-escaping on any whitespace, quotes, or slashes (\).
  */
 static void
 externalAclHandleReply(void *data, const HelperReply &reply)
 {
     externalAclState *state = static_cast<externalAclState *>(data);
     externalAclState *next;
-    char *t = NULL;
     ExternalACLEntryData entryData;
     entryData.result = ACCESS_DENIED;
     external_acl_entry *entry = NULL;
@@ -1322,41 +1326,29 @@ externalAclHandleReply(void *data, const HelperReply &reply)
         entryData.result = ACCESS_ALLOWED;
     // XXX: handle other non-DENIED results better
 
-    if (reply.other().hasContent()) {
-        char *temp = reply.modifiableOther().content();
-        char *token = strwordtok(temp, &t);
+    // XXX: make entryData store a proper HelperReply object instead of copying.
 
-        while ((token = strwordtok(NULL, &t))) {
-            char *value = strchr(token, '=');
+    Note::Pointer label = reply.notes.find("tag");
+    if (label != NULL && label->values[0]->value.size() > 0)
+        entryData.tag = label->values[0]->value;
 
-            if (value) {
-                *value = '\0';	/* terminate the token, and move up to the value */
-                ++value;
+    label = reply.notes.find("message");
+    if (label != NULL && label->values[0]->value.size() > 0)
+        entryData.message = label->values[0]->value;
 
-                if (state->def->quote == external_acl::QUOTE_METHOD_URL)
-                    rfc1738_unescape(value);
+    label = reply.notes.find("log");
+    if (label != NULL && label->values[0]->value.size() > 0)
+        entryData.log = label->values[0]->value;
 
-                if (strcmp(token, "message") == 0)
-                    entryData.message = value;
-                else if (strcmp(token, "error") == 0)
-                    entryData.message = value;
-                else if (strcmp(token, "tag") == 0)
-                    entryData.tag = value;
-                else if (strcmp(token, "log") == 0)
-                    entryData.log = value;
 #if USE_AUTH
-                else if (strcmp(token, "user") == 0)
-                    entryData.user = value;
-                else if (strcmp(token, "password") == 0)
-                    entryData.password = value;
-                else if (strcmp(token, "passwd") == 0)
-                    entryData.password = value;
-                else if (strcmp(token, "login") == 0)
-                    entryData.user = value;
+    label = reply.notes.find("user");
+    if (label != NULL && label->values[0]->value.size() > 0)
+        entryData.user = label->values[0]->value;
+
+    label = reply.notes.find("password");
+    if (label != NULL && label->values[0]->value.size() > 0)
+        entryData.password = label->values[0]->value;
 #endif
-            }
-        }
-    }
 
     dlinkDelete(&state->list, &state->def->queue);
 
@@ -34,6 +34,7 @@
 #include "cbdata.h"
 #include "DnsLookupDetails.h"
 #include "event.h"
+#include "helper.h"
 #include "HelperReply.h"
 #include "Mem.h"
 #include "mgr/Registration.h"
@@ -802,27 +802,26 @@ Fs::Ufs::UFSSwapDir::rebuild()
 void
 Fs::Ufs::UFSSwapDir::closeTmpSwapLog()
 {
-    char *swaplog_path = xstrdup(logFile(NULL));
-    char *new_path = xstrdup(logFile(".new"));
+    char *swaplog_path = xstrdup(logFile(NULL)); // where the swaplog should be
+    char *tmp_path = xstrdup(logFile(".new")); // the temporary file we have generated
     int fd;
     file_close(swaplog_fd);
 
-    if (xrename(new_path, swaplog_path) < 0) {
-        debugs(50, DBG_IMPORTANT, HERE << "ERROR: " << swaplog_path << ": " << xstrerror());
-        fatalf("Failed to rename log file %s to %s.new", swaplog_path, swaplog_path);
+    if (xrename(tmp_path, swaplog_path) < 0) {
+        fatalf("Failed to rename log file %s to %s", tmp_path, swaplog_path);
     }
 
     fd = file_open(swaplog_path, O_WRONLY | O_CREAT | O_BINARY);
 
     if (fd < 0) {
-        debugs(50, DBG_IMPORTANT, HERE << "ERROR: " << swaplog_path << ": " << xstrerror());
+        debugs(50, DBG_IMPORTANT, "ERROR: " << swaplog_path << ": " << xstrerror());
         fatalf("Failed to open swap log %s", swaplog_path);
     }
 
-    safe_free(swaplog_path);
-    safe_free(new_path);
+    xfree(swaplog_path);
+    xfree(tmp_path);
     swaplog_fd = fd;
-    debugs(47, 3, HERE << "Cache Dir #" << index << " log opened on FD " << fd);
+    debugs(47, 3, "Cache Dir #" << index << " log opened on FD " << fd);
 }
 
 FILE *
@@ -839,7 +838,7 @@ Fs::Ufs::UFSSwapDir::openTmpSwapLog(int *clean_flag, int *zero_flag)
     int fd;
 
     if (::stat(swaplog_path, &log_sb) < 0) {
-        debugs(47, DBG_IMPORTANT, HERE << "Cache Dir #" << index << ": No log file");
+        debugs(47, DBG_IMPORTANT, "Cache Dir #" << index << ": No log file");
         safe_free(swaplog_path);
         safe_free(clean_path);
         safe_free(new_path);
@@ -857,7 +856,7 @@ Fs::Ufs::UFSSwapDir::openTmpSwapLog(int *clean_flag, int *zero_flag)
 
     if (fd < 0) {
         debugs(50, DBG_IMPORTANT, "ERROR: while opening swap log" << new_path << ": " << xstrerror());
-        fatal("UFSSwapDir::openTmpSwapLog: Failed to open swap log.");
+        fatalf("Failed to open swap log %s", new_path);
     }
 
     swaplog_fd = fd;
@@ -879,7 +878,7 @@ Fs::Ufs::UFSSwapDir::openTmpSwapLog(int *clean_flag, int *zero_flag)
 
     if (fp == NULL) {
         debugs(50, DBG_CRITICAL, "ERROR: while opening " << swaplog_path << ": " << xstrerror());
-        fatal("Failed to open swap log for reading");
+        fatalf("Failed to open swap log for reading %s", swaplog_path);
     }
 
     memset(&clean_sb, '\0', sizeof(struct stat));
@@ -398,7 +398,7 @@ helperSubmit(helper * hlp, const char *buf, HLPCB * callback, void *data)
 {
     if (hlp == NULL) {
         debugs(84, 3, "helperSubmit: hlp == NULL");
-        HelperReply nilReply(NULL, 0);
+        HelperReply nilReply;
         callback(data, nilReply);
         return;
     }
@@ -424,7 +424,7 @@ helperStatefulSubmit(statefulhelper * hlp, const char *buf, HLPCB * callback, vo
 {
     if (hlp == NULL) {
         debugs(84, 3, "helperStatefulSubmit: hlp == NULL");
-        HelperReply nilReply(NULL, 0);
+        HelperReply nilReply;
         callback(data, nilReply);
         return;
     }
@@ -758,7 +758,7 @@ helperServerFree(helper_server *srv)
             void *cbdata;
 
             if (cbdataReferenceValidDone(r->data, &cbdata)) {
-                HelperReply nilReply(NULL, 0);
+                HelperReply nilReply;
                 r->callback(cbdata, nilReply);
             }
 
@@ -824,7 +824,7 @@ helperStatefulServerFree(helper_stateful_server *srv)
         void *cbdata;
 
         if (cbdataReferenceValidDone(r->data, &cbdata)) {
-            HelperReply nilReply(NULL,0);
+            HelperReply nilReply;
             nilReply.whichServer = srv;
             r->callback(cbdata, nilReply);
         }
@@ -942,7 +942,6 @@ helperHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t len, com
             t[-1] = '\0';
 
         *t = '\0';
-        ++t;
 
         if (hlp->childs.concurrency) {
             i = strtol(msg, &msg, 10);
@@ -952,6 +951,8 @@ helperHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t len, com
         }
 
         helperReturnBuffer(i, srv, hlp, msg, t);
+        // only skip off the \0 _after_ passing its location to helperReturnBuffer
+        ++t;
     }
 
     if (Comm::IsConnOpen(srv->readPipe)) {
@@ -1023,10 +1024,16 @@ helperStatefulHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t
     if ((t = strchr(srv->rbuf, hlp->eom))) {
         /* end of reply found */
         int called = 1;
+        int skip = 1;
         debugs(84, 3, "helperStatefulHandleRead: end of reply found");
 
-        if (t > srv->rbuf && t[-1] == '\r' && hlp->eom == '\n')
-            t[-1] = '\0';
+        if (t > srv->rbuf && t[-1] == '\r' && hlp->eom == '\n') {
+            *t = '\0';
+            // rewind to the \r octet which is the real terminal now
+            // and remember that we have to skip forward 2 places now.
+            skip = 2;
+            --t;
+        }
 
         *t = '\0';
 
@@ -1038,6 +1045,8 @@ helperStatefulHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t
             debugs(84, DBG_IMPORTANT, "StatefulHandleRead: no callback data registered");
             called = 0;
         }
+        // only skip off the \0's _after_ passing its location in HelperReply above
+        t += skip;
 
         srv->flags.busy = 0;
         srv->roffset = 0;
@@ -1366,7 +1375,7 @@ helperStatefulDispatch(helper_stateful_server * srv, helper_stateful_request * r
         /* a callback is needed before this request can _use_ a helper. */
         /* we don't care about releasing this helper. The request NEVER
          * gets to the helper. So we throw away the return code */
-        HelperReply nilReply(NULL,0);
+        HelperReply nilReply;
         nilReply.whichServer = srv;
         r->callback(r->data, nilReply);
         /* throw away the placeholder */
@@ -396,25 +396,28 @@ HttpStateData::cacheableReply()
             return 0;
         }
 
-        // HTTPbis pt7 section 4.1 clause 3: a response CC:public is present
         bool mayStore = false;
+        // HTTPbis pt6 section 3.2: a response CC:public is present
         if (rep->cache_control->Public()) {
             debugs(22, 3, HERE << "Authenticated but server reply Cache-Control:public");
             mayStore = true;
 
-            // HTTPbis pt7 section 4.1 clause 2: a response CC:must-revalidate is present
+            // HTTPbis pt6 section 3.2: a response CC:must-revalidate is present
         } else if (rep->cache_control->mustRevalidate() && !REFRESH_OVERRIDE(ignore_must_revalidate)) {
             debugs(22, 3, HERE << "Authenticated but server reply Cache-Control:public");
             mayStore = true;
 
-#if 0 // waiting on HTTPbis WG agreement before we do this
+#if USE_HTTP_VIOLATIONS
             // NP: given the must-revalidate exception we should also be able to exempt no-cache.
-        } else if (rep->cache_control->noCache()) {
-            debugs(22, 3, HERE << "Authenticated but server reply Cache-Control:no-cache");
+            // HTTPbis WG verdict on this is that it is omitted from the spec due to being 'unexpected' by
+            // some. The caching+revalidate is not exactly unsafe though with Squids interpretation of no-cache
+            // as equivalent to must-revalidate in the reply.
+        } else if (rep->cache_control->noCache() && !REFRESH_OVERRIDE(ignore_must_revalidate)) {
+            debugs(22, 3, HERE << "Authenticated but server reply Cache-Control:no-cache (equivalent to must-revalidate)");
             mayStore = true;
 #endif
 
-            // HTTPbis pt7 section 4.1 clause 1: a response CC:s-maxage is present
+            // HTTPbis pt6 section 3.2: a response CC:s-maxage is present
         } else if (rep->cache_control->sMaxAge()) {
             debugs(22, 3, HERE << " Authenticated but server reply Cache-Control:s-maxage");
             mayStore = true;
@@ -179,8 +179,18 @@ main(int argc, char *argv[])
     }
     max_fd = max(max_fd, squid_link);
 
-    setgid(getgid());
-    setuid(getuid());
+    if (setgid(getgid()) < 0) {
+        debugs(42, DBG_CRITICAL, "FATAL: pinger: setgid(" << getgid() << ") failed: " << xstrerror());
+        icmp4.Close();
+        icmp6.Close();
+        exit (1);
+    }
+    if (setuid(getuid()) < 0) {
+        debugs(42, DBG_CRITICAL, "FATAL: pinger: setuid(" << getuid() << ") failed: " << xstrerror());
+        icmp4.Close();
+        icmp6.Close();
+        exit (1);
+    }
 
     last_check_time = squid_curtime;
 
@@ -45,7 +45,7 @@ AddToMap(const PendingOpenRequest &por)
 
 Ipc::OpenListenerParams::OpenListenerParams()
 {
-    xmemset(this, 0, sizeof(*this));
+    memset(this, 0, sizeof(*this));
 }
 
 bool
@@ -270,8 +270,8 @@ Ipc::StoreMap::freeLocked(Slot &s, bool keepLocked)
 
 Ipc::StoreMapSlot::StoreMapSlot(): state(Empty)
 {
-    xmemset(&key, 0, sizeof(key));
-    xmemset(&basics, 0, sizeof(basics));
+    memset(&key, 0, sizeof(key));
+    memset(&basics, 0, sizeof(basics));
 }
 
 void
@@ -12,7 +12,7 @@
 
 Ipc::TypedMsgHdr::TypedMsgHdr()
 {
-    xmemset(this, 0, sizeof(*this));
+    memset(this, 0, sizeof(*this));
     sync();
 }
 
@@ -204,7 +204,7 @@ Ipc::TypedMsgHdr::getFd() const
 void
 Ipc::TypedMsgHdr::prepForReading()
 {
-    xmemset(this, 0, sizeof(*this));
+    memset(this, 0, sizeof(*this));
     allocName();
     allocData();
     allocControl();
@@ -541,6 +541,7 @@ mainParseOptions(int argc, char *argv[])
             /** \par l
              * Stores the syslog facility name in global opt_syslog_facility
              * then performs actions for -s option. */
+            xfree(opt_syslog_facility); // ignore any previous options sent
             opt_syslog_facility = xstrdup(optarg);
 
         case 's':
@@ -17,7 +17,7 @@ void DumpCountersStats(Mgr::CountersActionData& stats, StoreEntry* sentry);
 
 Mgr::CountersActionData::CountersActionData()
 {
-    xmemset(this, 0, sizeof(*this));
+    memset(this, 0, sizeof(*this));
 }
 
 Mgr::CountersActionData&
@@ -25,7 +25,7 @@ void DumpMallocStatistics(StoreEntry* sentry);
 
 Mgr::InfoActionData::InfoActionData()
 {
-    xmemset(this, 0, sizeof(*this));
+    memset(this, 0, sizeof(*this));
 }
 
 Mgr::InfoActionData&
@@ -17,7 +17,7 @@ void DumpAvgStat(Mgr::IntervalActionData& stats, StoreEntry* sentry);
 
 Mgr::IntervalActionData::IntervalActionData()
 {
-    xmemset(this, 0, sizeof(*this));
+    memset(this, 0, sizeof(*this));
 }
 
 Mgr::IntervalActionData&
@@ -18,7 +18,7 @@ void DumpIoStats(Mgr::IoActionData& stats, StoreEntry* sentry);
 
 Mgr::IoActionData::IoActionData()
 {
-    xmemset(this, 0, sizeof(*this));
+    memset(this, 0, sizeof(*this));
 }
 
 Mgr::IoActionData&
@@ -16,7 +16,7 @@ void DumpServiceTimesStats(Mgr::ServiceTimesActionData& stats, StoreEntry* sentr
 
 Mgr::ServiceTimesActionData::ServiceTimesActionData()
 {
-    xmemset(this, 0, sizeof(*this));
+    memset(this, 0, sizeof(*this));
 }
 
 Mgr::ServiceTimesActionData&
@@ -13,7 +13,7 @@
 
 Mgr::StoreIoActionData::StoreIoActionData()
 {
-    xmemset(this, 0, sizeof(*this));
+    memset(this, 0, sizeof(*this));
 }
 
 Mgr::StoreIoActionData&
@@ -846,7 +846,7 @@ peerNoteDigestLookup(HttpRequest * request, CachePeer * p, lookup_t lookup)
 {
 #if USE_CACHE_DIGESTS
     if (p)
-        strncpy(request->hier.cd_host, p->host, sizeof(request->hier.cd_host));
+        strncpy(request->hier.cd_host, p->host, sizeof(request->hier.cd_host)-1);
     else
         *request->hier.cd_host = '\0';
 
@@ -78,8 +78,9 @@ redirectHandleReply(void *data, const HelperReply &reply)
     redirectStateData *r = static_cast<redirectStateData *>(data);
     debugs(61, 5, HERE << "reply=" << reply);
 
-    // XXX: This funtion is now kept only to check for and display this garbage use-case
-    // it can be removed when the helpers are all updated to the normalized "OK/ERR key-pairs" format
+    // XXX: This function is now kept only to check for and display the garbage use-case
+    // and to map the old helper response format(s) into new format result code and key=value pairs
+    // it can be removed when the helpers are all updated to the normalized "OK/ERR kv-pairs" format
 
     if (reply.result == HelperReply::Unknown) {
         // BACKWARD COMPATIBILITY 2012-06-15:
@@ -99,6 +100,51 @@ redirectHandleReply(void *data, const HelperReply &reply)
             }
             if (reply.other().hasContent() && *res == '\0')
                 reply.modifiableOther().clean(); // drop the whole buffer of garbage.
+
+            // if we still have anything in other() after all that
+            // parse it into status=, url= and rewrite-url= keys
+            if (reply.other().hasContent()) {
+                /* 2012-06-28: This cast is due to urlParse() truncating too-long URLs itself.
+                 * At this point altering the helper buffer in that way is not harmful, but annoying.
+                 * When Bug 1961 is resolved and urlParse has a const API, this needs to die.
+                 */
+                const char * result = reply.other().content();
+                const http_status status = (http_status) atoi(result);
+
+                HelperReply newReply;
+                newReply.result = reply.result;
+                newReply.notes = reply.notes;
+
+                if (status == HTTP_MOVED_PERMANENTLY
+                        || status == HTTP_MOVED_TEMPORARILY
+                        || status == HTTP_SEE_OTHER
+                        || status == HTTP_PERMANENT_REDIRECT
+                        || status == HTTP_TEMPORARY_REDIRECT) {
+
+                    if (const char *t = strchr(result, ':')) {
+                        char statusBuf[4];
+                        snprintf(statusBuf, sizeof(statusBuf),"%3u",status);
+                        newReply.notes.add("status", statusBuf);
+                        ++t;
+                        // TODO: validate the URL produced here is RFC 2616 compliant URI
+                        newReply.notes.add("url", t);
+                    } else {
+                        debugs(85, DBG_CRITICAL, "ERROR: URL-rewrite produces invalid " << status << " redirect Location: " << result);
+                    }
+                } else {
+                    // status code is not a redirect code (or does not exist)
+                    // treat as a re-write URL request
+                    // TODO: validate the URL produced here is RFC 2616 compliant URI
+                    newReply.notes.add("rewrite-url", reply.other().content());
+                }
+
+                void *cbdata;
+                if (cbdataReferenceValidDone(r->data, &cbdata))
+                    r->handler(cbdata, newReply);
+
+                redirectStateFree(r);
+                return;
+            }
         }
     }
 
@@ -151,8 +197,10 @@ redirectStart(ClientHttpRequest * http, HLPCB * handler, void *data)
     if (Config.onoff.redirector_bypass && redirectors->stats.queue_size) {
         /* Skip redirector if there is one request queued */
         ++n_bypassed;
-        HelperReply nilReply(NULL,0);
-        handler(data, nilReply);
+        HelperReply bypassReply;
+        bypassReply.result = HelperReply::Okay;
+        bypassReply.notes.add("message","URL rewrite/redirect queue too long. Bypassed.");
+        handler(data, bypassReply);
         return;
     }
 
@@ -41,7 +41,7 @@ Snmp::Pdu::operator = (const Pdu& pdu)
 void
 Snmp::Pdu::init()
 {
-    xmemset(this, 0, sizeof(*this));
+    memset(this, 0, sizeof(*this));
     errstat = SNMP_DEFAULT_ERRSTAT;
     errindex = SNMP_DEFAULT_ERRINDEX;
 }
@@ -35,7 +35,7 @@ Snmp::Session::operator = (const Session& session)
 void
 Snmp::Session::clear()
 {
-    xmemset(this, 0, sizeof(*this));
+    memset(this, 0, sizeof(*this));
 }
 
 void
@@ -40,7 +40,7 @@ Snmp::Var::operator = (const Var& var)
 void
 Snmp::Var::init()
 {
-    xmemset(this, 0, sizeof(*this));
+    memset(this, 0, sizeof(*this));
 }
 
 Snmp::Var&
@@ -94,8 +94,9 @@ void Ssl::Helper::sslSubmit(CrtdMessage const & message, HLPCB * callback, void
         if (squid_curtime - first_warn > 3 * 60)
             fatal("SSL servers not responding for 3 minutes");
         debugs(34, DBG_IMPORTANT, HERE << "Queue overload, rejecting");
-        const char *errMsg = "BH error 45 Temporary network problem, please retry later"; // XXX: upgrade to message=""
-        HelperReply failReply(errMsg,strlen(errMsg));
+        HelperReply failReply;
+        failReply.result = HelperReply::BrokenHelper;
+        failReply.notes.add("message", "error 45 Temporary network problem, please retry later");
         callback(data, failReply);
         return;
     }
@@ -66,10 +66,3 @@ void setUmask(mode_t mask) STUB
 void strwordquote(MemBuf * mb, const char *str) STUB
 void keepCapabilities(void) STUB
 void restoreCapabilities(int keep) STUB
-
-void*
-xmemset(void* dst, int val, size_t sz)
-{
-    assert(dst);
-    return memset(dst, val, sz);
-}
@@ -703,10 +703,10 @@ leave_suid(void)
 void
 enter_suid(void)
 {
-    debugs(21, 3, "enter_suid: PID " << getpid() << " taking root priveleges");
+    debugs(21, 3, "enter_suid: PID " << getpid() << " taking root privileges");
 #if HAVE_SETRESUID
-
-    setresuid((uid_t)-1, 0, (uid_t)-1);
+    if (setresuid((uid_t)-1, 0, (uid_t)-1) < 0)
+        debugs (21, 3, "enter_suid: setresuid failed: " << xstrerror ());
 #else
 
     setuid(0);
@@ -731,10 +731,11 @@ no_suid(void)
     uid = geteuid();
     debugs(21, 3, "no_suid: PID " << getpid() << " giving up root priveleges forever");
 
-    setuid(0);
+    if (setuid(0) < 0)
+        debugs(50, DBG_IMPORTANT, "WARNING: no_suid: setuid(0): " << xstrerror());
 
     if (setuid(uid) < 0)
-        debugs(50, DBG_IMPORTANT, "no_suid: setuid: " << xstrerror());
+        debugs(50, DBG_IMPORTANT, "ERROR: no_suid: setuid(" << uid << "): " << xstrerror());
 
     restoreCapabilities(0);
 
@@ -1174,8 +1175,9 @@ parseEtcHosts(void)
             /* For IPV6 addresses also check for a colon */
             if (Config.appendDomain && !strchr(lt, '.') && !strchr(lt, ':')) {
                 /* I know it's ugly, but it's only at reconfig */
-                strncpy(buf2, lt, 512);
-                strncat(buf2, Config.appendDomain, 512 - strlen(lt) - 1);
+                strncpy(buf2, lt, sizeof(buf2)-1);
+                strncat(buf2, Config.appendDomain, sizeof(buf2) - strlen(lt) - 1);
+                buf2[sizeof(buf2)-1] = '\0';
                 host = buf2;
             } else {
                 host = lt;
@@ -1331,13 +1333,3 @@ restoreCapabilities(int keep)
     Ip::Interceptor.StopTransparency("Missing needed capability support.");
 #endif /* HAVE_SYS_CAPABILITY_H */
 }
-
-void *
-xmemset(void *dst, int val, size_t sz)
-{
-    // do debugs output
-    debugs(63, 9, "memset: dst=" << dst << ", val=" << val << ", bytes=" << sz);
-
-    // call the system one to do the actual work ~safely.
-    return memset(dst, val, sz);
-}
@@ -91,7 +91,6 @@ int NumberOfKids();
 String ProcessRoles();
 
 void debug_trap(const char *);
-void *xmemset(void *dst, int, size_t);
 
 void logsFlush(void);
 
@@ -77,9 +77,11 @@ main(int argc, char *argv[])
     setbuf(stdin, NULL);
     setbuf(stdout, NULL);
     close(2);
-    open(_PATH_DEVNULL, O_RDWR);
+    if (open(_PATH_DEVNULL, O_RDWR) < 0) {
+        ; // the irony of having to close(2) earlier is that we cannot report this failure.
+    }
 
-    while (fgets(buf, UNLINK_BUF_LEN, stdin)) {
+    while (fgets(buf, sizeof(buf), stdin)) {
         if ((t = strchr(buf, '\n')))
             *t = '\0';
         x = unlink(buf);
@@ -313,10 +313,12 @@ urlParse(const HttpRequestMethod& method, char *url, HttpRequest *request)
         /* Is there any login information? (we should eventually parse it above) */
         t = strrchr(host, '@');
         if (t != NULL) {
-            strcpy((char *) login, (char *) host);
+            strncpy((char *) login, (char *) host, sizeof(login)-1);
+            login[sizeof(login)-1] = '\0';
             t = strrchr(login, '@');
             *t = 0;
-            strcpy((char *) host, t + 1);
+            strncpy((char *) host, t + 1, sizeof(host)-1);
+            host[sizeof(host)-1] = '\0';
         }
 
         /* Is there any host information? (we should eventually parse it above) */
@@ -605,7 +605,7 @@ wccp2_update_md5_security(char *password, char *ptr, char *packet, int len)
 
     SquidMD5Init(&M);
 
-    SquidMD5Update(&M, pwd, 8);
+    SquidMD5Update(&M, pwd, sizeof(pwd));
 
     SquidMD5Update(&M, packet, len);
 
@@ -650,7 +650,6 @@ wccp2_check_security(struct wccp2_service_list_t *srv, char *security, char *pac
 
     /* The password field, for the MD5 hash, needs to be 8 bytes and NUL padded. */
     memset(pwd, 0, sizeof(pwd));
-
     strncpy(pwd, srv->wccp_password, sizeof(pwd));
 
     /* Take a copy of the challenge: we need to NUL it before comparing */
@@ -660,7 +659,7 @@ wccp2_check_security(struct wccp2_service_list_t *srv, char *security, char *pac
 
     SquidMD5Init(&M);
 
-    SquidMD5Update(&M, pwd, 8);
+    SquidMD5Update(&M, pwd, sizeof(pwd));
 
     SquidMD5Update(&M, packet, len);
 
@@ -594,12 +594,15 @@ munge_action_line(const char *_buf, cachemgr_request * req)
     if ((p = strchr(x, '\n')))
         *p = '\0';
     action = xstrtok(&x, '\t');
+    if (!action) {
+        xfree(buf);
+        return "";
+    }
     description = xstrtok(&x, '\t');
     if (!description)
         description = action;
-    if (!action)
-        return "";
     snprintf(html, sizeof(html), " <a href=\"%s\">%s</a>", menu_url(req, action), description);
+    xfree(buf);
     return html;
 }
 
@@ -828,7 +831,7 @@ process_request(cachemgr_request * req)
     }
 
     if (!check_target_acl(req->hostname, req->port)) {
-        snprintf(buf, 1024, "target %s:%d not allowed in cachemgr.conf\n", req->hostname, req->port);
+        snprintf(buf, sizeof(buf), "target %s:%d not allowed in cachemgr.conf\n", req->hostname, req->port);
         error_html(buf);
         return 1;
     }
@@ -840,7 +843,7 @@ process_request(cachemgr_request * req)
     } else if ((S = req->hostname))
         (void) 0;
     else {
-        snprintf(buf, 1024, "Unknown host: %s\n", req->hostname);
+        snprintf(buf, sizeof(buf), "Unknown host: %s\n", req->hostname);
         error_html(buf);
         return 1;
     }
@@ -854,17 +857,19 @@ process_request(cachemgr_request * req)
 #else
     if ((s = socket(PF_INET, SOCK_STREAM, 0)) < 0) {
 #endif
-        snprintf(buf, 1024, "socket: %s\n", xstrerror());
+        snprintf(buf, sizeof(buf), "socket: %s\n", xstrerror());
         error_html(buf);
+        S.FreeAddrInfo(AI);
         return 1;
     }
 
     if (connect(s, AI->ai_addr, AI->ai_addrlen) < 0) {
-        snprintf(buf, 1024, "connect %s: %s\n",
+        snprintf(buf, sizeof(buf), "connect %s: %s\n",
                  S.ToURL(ipbuf,MAX_IPSTRLEN),
                  xstrerror());
         error_html(buf);
         S.FreeAddrInfo(AI);
+        close(s);
         return 1;
     }
 
@@ -952,8 +957,6 @@ static char *
 read_post_request(void)
 {
     char *s;
-    char *buf;
-    int len;
 
     if ((s = getenv("REQUEST_METHOD")) == NULL)
         return NULL;
@@ -964,15 +967,34 @@ read_post_request(void)
     if ((s = getenv("CONTENT_LENGTH")) == NULL)
         return NULL;
 
-    if ((len = atoi(s)) <= 0)
+    if (*s == '-') // negative length content huh?
         return NULL;
 
-    buf = (char *)xmalloc(len + 1);
+    uint64_t len;
 
-    if (fread(buf, len, 1, stdin) == 0)
+    char *endptr = s+ strlen(s);
+    if ((len = strtoll(s, &endptr, 10)) <= 0)
         return NULL;
 
-    buf[len] = '\0';
+    // limit the input to something reasonable.
+    // 4KB should be enough for the GET/POST data length, but may be extended.
+    size_t bufLen = (len >= 4096 ? len : 4095);
+    char *buf = (char *)xmalloc(bufLen + 1);
+
+    size_t readLen = fread(buf, bufLen, 1, stdin);
+    if (readLen == 0) {
+        xfree(buf);
+        return NULL;
+    }
+    buf[readLen] = '\0';
+    len -= readLen;
+
+    // purge the remainder of the request entity
+    while (len > 0) {
+        char temp[65535];
+        readLen = fread(temp, 65535, 1, stdin);
+        len -= readLen;
+    }
 
     return buf;
 }
@@ -1118,37 +1140,49 @@ decode_pub_auth(cachemgr_request * req)
     debug("cmgr: length ok\n");
 
     /* parse ( a lot of memory leaks, but that is cachemgr style :) */
-    if ((host_name = strtok(buf, "|")) == NULL)
+    if ((host_name = strtok(buf, "|")) == NULL) {
+        xfree(buf);
         return;
+    }
 
     debug("cmgr: decoded host: '%s'\n", host_name);
 
-    if ((time_str = strtok(NULL, "|")) == NULL)
+    if ((time_str = strtok(NULL, "|")) == NULL) {
+        xfree(buf);
         return;
+    }
 
     debug("cmgr: decoded time: '%s' (now: %d)\n", time_str, (int) now);
 
-    if ((user_name = strtok(NULL, "|")) == NULL)
+    if ((user_name = strtok(NULL, "|")) == NULL) {
+        xfree(buf);
         return;
+    }
 
     debug("cmgr: decoded uname: '%s'\n", user_name);
 
-    if ((passwd = strtok(NULL, "|")) == NULL)
+    if ((passwd = strtok(NULL, "|")) == NULL) {
+        xfree(buf);
         return;
+    }
 
     debug("cmgr: decoded passwd: '%s'\n", passwd);
 
     /* verify freshness and validity */
-    if (atoi(time_str) + passwd_ttl < now)
+    if (atoi(time_str) + passwd_ttl < now) {
+        xfree(buf);
         return;
+    }
 
-    if (strcasecmp(host_name, req->hostname))
+    if (strcasecmp(host_name, req->hostname)) {
+        xfree(buf);
         return;
+    }
 
     debug("cmgr: verified auth. info.\n");
 
     /* ok, accept */
-    xfree(req->user_name);
+    safe_free(req->user_name);
 
     req->user_name = xstrdup(user_name);
 
@@ -1190,6 +1224,7 @@ make_auth_header(const cachemgr_request * req)
 
     snprintf(&buf[stringLength], sizeof(buf) - stringLength, "Proxy-Authorization: Basic %s\r\n", str64);
 
+    xfree(str64);
     return buf;
 }
 
@@ -208,7 +208,8 @@ concat( const char* start, ... )
     // first run: determine size
     unsigned size = strlen(start)+1;
     va_start( ap, start );
-    while ( (s=va_arg(ap,const char*)) != NULL ) size += strlen(s ? s : "");
+    while ( (s=va_arg(ap,const char*)) != NULL )
+        size += strlen(s);
     va_end(ap);
 
     // allocate
@@ -489,7 +490,8 @@ filelevel( const char* directory, const REList* list )
     if ( ::iamalive ) {
         static char alivelist[4][3] = { "\\\b", "|\b", "/\b", "-\b" };
         static unsigned short alivecount = 0;
-        assert( write( STDOUT_FILENO, alivelist[alivecount++ & 3], 2 ) == 2 );
+        const int write_success = write(STDOUT_FILENO, alivelist[alivecount++ & 3], 2);
+        assert(write_success == 2);
     }
 
     bool flag = true;
@@ -627,13 +629,15 @@ parseCommandline( int argc, char* argv[], REList*& head,
         case 'C':
             if ( optarg && *optarg ) {
                 if ( copydir ) xfree( (void*) copydir );
-                assert( (copydir = xstrdup(optarg)) );
+                copydir = xstrdup(optarg);
+                assert(copydir);
             }
             break;
         case 'c':
             if ( optarg && *optarg ) {
-                if ( *conffile ) xfree((void*) conffile );
-                assert( (conffile = xstrdup(optarg)) );
+                if ( *conffile ) xfree((void*) conffile);
+                conffile = xstrdup(optarg);
+                assert(conffile);
             }
             break;
 
@@ -265,27 +265,23 @@ main(int argc, char *argv[])
                 break;
 
             case 'A':
-                if (optarg != NULL)
-                    useragent = optarg;
+                useragent = optarg;
                 break;
 
             case 'h':		/* remote host */
-                if (optarg != NULL)
-                    hostname = optarg;
+                hostname = optarg;
                 break;
 
             case 'j':
                 host = optarg;
                 break;
 
             case 'V':
-                if (optarg != NULL)
-                    version = optarg;
+                version = optarg;
                 break;
 
             case 'l':		/* local host */
-                if (optarg != NULL)
-                    localhost = optarg;
+                localhost = optarg;
                 break;
 
             case 's':		/* silent */
@@ -418,7 +414,9 @@ main(int argc, char *argv[])
         setmode(put_fd, O_BINARY);
 #endif
 
-        fstat(put_fd, &sb);
+        if (fstat(put_fd, &sb) < 0) {
+            fprintf(stderr, "%s: can't identify length of file (%s)\n", argv[0], xstrerror());
+        }
     }
 
     if (!host) {