@@ -2,6 +2,18 @@
 	* The `battery' plugin should work on many Apple computers now.
 	* The `traffic' plugin can now ignore certain interfaces. Also,
 	  statistics for sent/received packets and errors have been added.
+	* A plugin to monitor APC UPSes using `apcupsd' has been added. Thanks
+	  to Anthony Gialluca for contributing this plugin and providing me
+	  with a test environment :)
+	* A plugin for moniroting an NTP instance and the local clock drift
+	  has been added.
+
+2006-06-01, Version 3.9.3
+	* Fixed the ping-plugin under FreeBSD and Mac OS X. Potentially other
+	  operating systems also profit from the changes, but I wasn't able to
+	  check that.
+	* Changed the build system to find the netinet-includes under FreeBSD
+	  and therefore successfully build the `liboping' library there.
 
 2006-05-09, Version 3.9.2
 	* Applied a patch to the `liboping' library. Due to a bug in the
@@ -1,4 +1,5 @@
 SUBDIRS = libltdl src
+
 INCLUDES = $(LTDLINCL)
 
 EXTRA_DIST = collectd.spec contrib debian
@@ -1,6 +1,6 @@
 Summary:	Statistics collection daemon for filling RRD files.
 Name:           collectd
-Version:	3.9.0
+Version:	3.9.3
 Release:	1
 Source:		http://collectd.org/files/%{name}-%{version}.tar.gz
 License:	GPL
@@ -71,6 +71,7 @@ rm -rf $RPM_BUILD_ROOT
 %attr(0444,root,root) %{_mandir}/man1/*
 %attr(0444,root,root) %{_mandir}/man5/*
 %attr(0444,root,root) %{_libdir}/%{name}/apple_sensors.so*
+%attr(0444,root,root) %{_libdir}/%{name}/apcups.so*
 %attr(0444,root,root) %{_libdir}/%{name}/battery.so*
 %attr(0444,root,root) %{_libdir}/%{name}/cpu.so*
 %attr(0444,root,root) %{_libdir}/%{name}/cpufreq.so*
@@ -101,6 +102,9 @@ rm -rf $RPM_BUILD_ROOT
 %attr(0444,root,root) %{_libdir}/%{name}/sensors.so*
 
 %changelog
+* Tue Jun 01 2006 Florian octo Forster <octo@verplant.org> 3.9.3-1
+- New upstream version
+
 * Tue May 09 2006 Florian octo Forster <octo@verplant.org> 3.9.2-1
 - New upstream version
 
@@ -1,5 +1,5 @@
 dnl Process this file with autoconf to produce a configure script.
-AC_INIT(collectd, 3.9.2)
+AC_INIT(collectd, 3.10.0-alpha3)
 AC_CONFIG_SRCDIR(src/collectd.c)
 AC_CONFIG_HEADERS(src/config.h)
 AM_INIT_AUTOMAKE(dist-bzip2)
@@ -44,6 +44,7 @@ AC_CHECK_HEADERS(assert.h)
 AC_CHECK_HEADERS(sys/types.h)
 AC_CHECK_HEADERS(sys/socket.h)
 AC_CHECK_HEADERS(sys/select.h)
+AC_CHECK_HEADERS(sys/poll.h)
 AC_CHECK_HEADERS(netdb.h)
 AC_CHECK_HEADERS(arpa/inet.h)
 AC_CHECK_HEADERS(sys/resource.h)
@@ -54,11 +55,17 @@ AC_CHECK_HEADERS(netinet/in_systm.h, [], [],
 [#if HAVE_STDINT_H
 # include <stdint.h>
 #endif
+#if HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
 ])
 AC_CHECK_HEADERS(netinet/in.h, [], [],
 [#if HAVE_STDINT_H
 # include <stdint.h>
 #endif
+#if HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
 #if HAVE_NETINET_IN_SYSTM_H
 # include <netinet/in_systm.h>
 #endif
@@ -67,6 +74,9 @@ AC_CHECK_HEADERS(netinet/ip.h, [], [],
 [#if HAVE_STDINT_H
 # include <stdint.h>
 #endif
+#if HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
 #if HAVE_NETINET_IN_SYSTM_H
 # include <netinet/in_systm.h>
 #endif
@@ -78,6 +88,9 @@ AC_CHECK_HEADERS(netinet/ip_icmp.h, [], [],
 [#if HAVE_STDINT_H
 # include <stdint.h>
 #endif
+#if HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
 #if HAVE_NETINET_IN_SYSTM_H
 # include <netinet/in_systm.h>
 #endif
@@ -92,6 +105,9 @@ AC_CHECK_HEADERS(netinet/ip_var.h, [], [],
 [#if HAVE_STDINT_H
 # include <stdint.h>
 #endif
+#if HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
 #if HAVE_NETINET_IN_SYSTM_H
 # include <netinet/in_systm.h>
 #endif
@@ -711,6 +727,59 @@ AC_DEFINE_UNQUOTED(COLLECT_LIBMYSQL, [$collect_libmysql],
 	[Wether or not to use mysql library])
 AM_CONDITIONAL(BUILD_WITH_LIBMYSQL, test "x$with_libmysql" = "xyes")
 
+#with_liboping="yes"
+with_own_liboping="no"
+liboping_LDFLAGS="$LDFLAGS"
+liboping_CPPFLAGS="$CPPFLAGS"
+AC_ARG_WITH(liboping, [AS_HELP_STRING([--with-liboping@<:@=PREFIX@:>@], [Path to liboping.])],
+[
+	if test "x$withval" != "xno" && test "x$withval" != "xyes"
+	then
+		if test -d "$withval/lib"
+		then
+			liboping_LDFLAGS="$LDFLAGS -L$withval/lib"
+		fi
+		if test -d "$withval/include"
+		then
+			liboping_CPPFLAGS="$CPPFLAGS -I$withval/include"
+		fi
+	fi
+	if test "x$withval" = "xno"
+	then
+		with_liboping="no"
+		with_own_liboping="no"
+	fi
+],
+[
+ 	#753
+	with_liboping="yes"
+])
+
+if test "x$with_liboping" = "xyes"
+then
+	save_LDFLAGS="$LDFLAGS"
+	save_CPPFLAGS="$CPPFLAGS"
+	LDFLAGS="$liboping_LDFLAGS"
+	CPPFLAGS="$liboping_CPPFLAGS"
+	AC_CHECK_LIB(oping, ping_construct,
+	[
+		with_liboping="yes"
+		with_own_liboping="no"
+	],
+	[
+		with_liboping="yes"
+		with_own_liboping="yes"
+		LDFLAGS="$save_LDFLAGS"
+		CPPFLAGS="$save_CPPFLAGS"
+	])
+fi
+AM_CONDITIONAL(BUILD_WITH_LIBOPING, test "x$with_liboping" = "xyes")
+AM_CONDITIONAL(BUILD_WITH_OWN_LIBOPING, test "x$with_own_liboping" = "xyes")
+if test "x$with_liboping" = "xyes" -a "x$with_own_liboping" = "xyes"
+then
+	with_liboping="yes (shipped version)"
+fi
+
 # Define `step' and `hearbeat' values..
 declare -i collectd_step=10
 declare -i collectd_heartbeat=25
@@ -833,6 +902,7 @@ AC_COLLECTD([load],      [disable], [module], [system load statistics])
 AC_COLLECTD([memory],    [disable], [module], [memory statistics])
 AC_COLLECTD([mysql],     [disable], [module], [mysql statistics])
 AC_COLLECTD([nfs],       [disable], [module], [nfs statistics])
+AC_COLLECTD([ntpd],      [disable], [module], [nfs statistics])
 AC_COLLECTD([ping],      [disable], [module], [ping statistics])
 AC_COLLECTD([processes], [disable], [module], [processes statistics])
 AC_COLLECTD([sensors],   [disable], [module], [lm_sensors statistics])
@@ -844,14 +914,15 @@ AC_COLLECTD([users],     [disable], [module], [user count statistics])
 AC_COLLECTD([vserver],   [disable], [module], [vserver statistics])
 AC_COLLECTD([wireless],  [disable], [module], [wireless link statistics])
 
-AC_OUTPUT(Makefile src/libconfig/Makefile src/liboping/Makefile src/Makefile)
+AC_OUTPUT(Makefile src/Makefile src/libconfig/Makefile src/liboping/Makefile)
 
 cat <<EOF;
 
 Configuration:
   Libraries:
     libcurl . . . . . . $with_libcurl
     libiokit  . . . . . $with_libiokit
+    liboping  . . . . . $with_liboping
     librrd  . . . . . . $with_rrdtool
     lm_sensors  . . . . $with_lm_sensors
     libstatgrab . . . . $with_libstatgrab
@@ -878,6 +949,7 @@ Configuration:
     memory  . . . . . . $enable_memory
     mysql . . . . . . . $enable_mysql
     nfs . . . . . . . . $enable_nfs
+    ntpd  . . . . . . . $enable_ntpd
     ping  . . . . . . . $enable_ping
     processes . . . . . $enable_processes
     sensors . . . . . . $enable_sensors
@@ -247,6 +247,18 @@ our $GraphDefs;
 			'GPRINT:temp_max:MAX:%4.1lf Max,',
 			'GPRINT:temp_avg:LAST:%4.1lf Last\l'
 		],
+		frequency_offset => [ # NTPd
+			'DEF:ppm_avg={file}:ppm:AVERAGE',
+			'DEF:ppm_min={file}:ppm:MIN',
+			'DEF:ppm_max={file}:ppm:MAX',
+			"AREA:ppm_max#$HalfBlue",
+			"AREA:ppm_min#$Canvas",
+			"LINE1:ppm_avg#$FullBlue:{inst}",
+			'GPRINT:ppm_min:MIN:%5.2lf Min,',
+			'GPRINT:ppm_avg:AVERAGE:%5.2lf Avg,',
+			'GPRINT:ppm_max:MAX:%5.2lf Max,',
+			'GPRINT:ppm_avg:LAST:%5.2lf Last'
+		],
 		hddtemp => [
 			'DEF:temp_avg={file}:value:AVERAGE',
 			'DEF:temp_min={file}:value:MIN',
@@ -703,6 +715,21 @@ our $GraphDefs;
 			'GPRINT:temp_max:MAX:%4.1lf Max,',
 			'GPRINT:temp_avg:LAST:%4.1lf Last\l'
 		],
+		time_offset => [ # NTPd
+			'DEF:ms_avg={file}:ms:AVERAGE',
+			'DEF:ms_min={file}:ms:MIN',
+			'DEF:ms_max={file}:ms:MAX',
+			'CDEF:s_avg=ms_avg,1000,/',
+			'CDEF:s_min=ms_min,1000,/',
+			'CDEF:s_max=ms_max,1000,/',
+			"AREA:s_max#$HalfBlue",
+			"AREA:s_min#$Canvas",
+			"LINE1:s_avg#$FullBlue:{inst}",
+			'GPRINT:s_min:MIN:%7.3lf%s Min,',
+			'GPRINT:s_avg:AVERAGE:%7.3lf%s Avg,',
+			'GPRINT:s_max:MAX:%7.3lf%s Max,',
+			'GPRINT:s_avg:LAST:%7.3lf%s Last'
+		],
 		traffic => ['DEF:out_min_raw={file}:outgoing:MIN',
 			'DEF:out_avg_raw={file}:outgoing:AVERAGE',
 			'DEF:out_max_raw={file}:outgoing:MAX',
@@ -774,6 +801,93 @@ our $GraphDefs;
 			'GPRINT:max:MAX:%5.1lf%sV Max,',
 			'GPRINT:avg:LAST:%5.1lf%sV Last\l'
 		],
+		apcups_volt => [
+			'DEF:line_avg={file}:linev:AVERAGE',
+			'DEF:line_min={file}:linev:MIN',
+			'DEF:line_max={file}:linev:MAX',
+			'DEF:out_avg={file}:outputv:AVERAGE',
+			'DEF:out_min={file}:outputv:MIN',
+			'DEF:out_max={file}:outputv:MAX',
+			#"AREA:line_max#$HalfBlue",
+			#"AREA:line_min#$Canvas",
+			#"AREA:out_avg#$HalfGreen",
+			"LINE1:line_avg#$FullBlue:Line Volt",
+			'GPRINT:line_min:MIN:%5.1lf%sV Min,',
+			'GPRINT:line_avg:AVERAGE:%5.1lf%sV Avg,',
+			'GPRINT:line_max:MAX:%5.1lf%sV Max,',
+			'GPRINT:line_avg:LAST:%5.1lf%sV Last\l',
+			"LINE2:out_avg#$FullGreen:Out  Volt",
+			'GPRINT:out_min:MIN:%5.1lf%sV Min,',
+			'GPRINT:out_avg:AVERAGE:%5.1lf%sV Avg,',
+			'GPRINT:out_max:MAX:%5.1lf%sV Max,',
+			'GPRINT:out_avg:LAST:%5.1lf%sV Last\l'
+		],
+		apcups_bvolt => [
+			'DEF:bvolt_avg={file}:battv:AVERAGE',
+			'DEF:bvolt_min={file}:battv:MIN',
+			'DEF:bvolt_max={file}:battv:MAX',
+			"AREA:bvolt_max#$HalfBlue",
+			"LINE1:bvolt_avg#$FullBlue:Batt Volt",
+			'GPRINT:bvolt_min:MIN:%5.1lf%sV Min,',
+			'GPRINT:bvolt_avg:AVERAGE:%5.1lf%sV Avg,',
+			'GPRINT:bvolt_max:MAX:%5.1lf%sV Max,',
+			'GPRINT:bvolt_avg:LAST:%5.1lf%sV Last\l',
+		],
+		apcups_load => [
+			'DEF:load_avg={file}:loadpct:AVERAGE',
+			'DEF:load_min={file}:loadpct:MIN',
+			'DEF:load_max={file}:loadpct:MAX',
+			"AREA:load_max#$HalfBlue",
+			"LINE1:load_avg#$FullBlue:Batt load",
+			'GPRINT:load_min:MIN:%5.1lf%s%% Min,',
+			'GPRINT:load_avg:AVERAGE:%5.1lf%s%% Avg,',
+			'GPRINT:load_max:MAX:%5.1lf%s%% Max,',
+			'GPRINT:load_avg:LAST:%5.1lf%s%% Last\l',
+		],
+		apcups_charge => [
+			'DEF:charge_avg={file}:bcharge:AVERAGE',
+			'DEF:charge_min={file}:bcharge:MIN',
+			'DEF:charge_max={file}:bcharge:MAX',
+			"AREA:charge_max#$HalfBlue",
+			"LINE1:charge_avg#$FullBlue:Batt Charge",
+			'GPRINT:charge_min:MIN:%5.1lf%s%% Min,',
+			'GPRINT:charge_avg:AVERAGE:%5.1lf%s%% Avg,',
+			'GPRINT:charge_max:MAX:%5.1lf%s%% Max,',
+			'GPRINT:charge_avg:LAST:%5.1lf%s%% Last\l',
+		],
+		apcups_time => [
+			'DEF:time_avg={file}:timeleft:AVERAGE',
+			'DEF:time_min={file}:timeleft:MIN',
+			'DEF:time_max={file}:timeleft:MAX',
+			"AREA:time_max#$HalfBlue",
+			"LINE1:time_avg#$FullBlue:Time Avail",
+			'GPRINT:time_min:MIN:%5.1lf%smin Min,',
+			'GPRINT:time_avg:AVERAGE:%5.1lf%smin Avg,',
+			'GPRINT:time_max:MAX:%5.1lf%smin Max,',
+			'GPRINT:time_avg:LAST:%5.1lf%smin Last\l',
+		],
+		apcups_temp => [
+			'DEF:temp_avg={file}:itemp:AVERAGE',
+			'DEF:temp_min={file}:itemp:MIN',
+			'DEF:temp_max={file}:itemp:MAX',
+			"AREA:temp_max#$HalfBlue",
+			"LINE1:temp_avg#$FullBlue:Temp Avail",
+			'GPRINT:temp_min:MIN:%5.1lf%s� Min,',
+			'GPRINT:temp_avg:AVERAGE:%5.1lf%s� Avg,',
+			'GPRINT:temp_max:MAX:%5.1lf%s� Max,',
+			'GPRINT:temp_avg:LAST:%5.1lf%s� Last\l',
+		],
+		apcups_freq => [
+			'DEF:freq_avg={file}:linefreq:AVERAGE',
+			'DEF:freq_min={file}:linefreq:MIN',
+			'DEF:freq_max={file}:linefreq:MAX',
+			"AREA:freq_max#$HalfBlue",
+			"LINE1:freq_avg#$FullBlue:Line Freq",
+			'GPRINT:freq_min:MIN:%5.1lf%sHz Min,',
+			'GPRINT:freq_avg:AVERAGE:%5.1lf%sHz Avg,',
+			'GPRINT:freq_max:MAX:%5.1lf%sHz Max,',
+			'GPRINT:freq_avg:LAST:%5.1lf%sHz Last\l',
+		],
 		vs_threads => [
 			"DEF:total_avg={file}:total:AVERAGE",
 			"DEF:total_min={file}:total:MIN",
@@ -858,6 +972,9 @@ our $GraphDefs;
 	$GraphDefs->{'disk'} = $GraphDefs->{'partition'};
 	$GraphDefs->{'meminfo'} = $GraphDefs->{'memory'};
 	$GraphDefs->{'sensors'} = $GraphDefs->{'temperature'};
+
+	$GraphDefs->{'delay'}           = $GraphDefs->{'time_offset'};
+	$GraphDefs->{'time_dispersion'} = $GraphDefs->{'time_offset'};
 }
 
 our $GraphArgs =
@@ -870,9 +987,11 @@ our $GraphArgs =
 	cpufreq => ['-t', '{host} cpu{inst} usage', '-v', 'Mhz'],
 	current => ['-t', '{host} current', '-v', 'Ampere'],
 	#disk => ['-t', '{host} disk {inst} IO wait', '-v', 'Seconds'],
+	delay => ['-t', 'NTPd peer delay ({inst})', '-v', 'Seconds'],
 	df => ['-t', '{host}:{inst} usage', '-v', 'Percent', '-l', '0'],
 	disk => ['-t', '{host} disk {inst} usage', '-v', 'Byte/s'],
 	fanspeed => ['-t', '{host} fanspeed {inst}', '-v', 'rpm'],
+	frequency_offset => ['-t', 'NTPd frequency offset ({inst})', '-v', 'Parts per million'],
 	hddtemp => ['-t', '{host} hdd temperature {inst}', '-v', '�Celsius'],
 	load => ['-t', '{host} load average', '-v', 'System load', '-X', '0'],
 	mails   => ['-t', '{host} mail count', '-v', 'Amount', '-X', '0'],
@@ -888,9 +1007,18 @@ our $GraphArgs =
 	sensors => ['-t', '{host} sensor {inst}', '-v', '�Celsius'],
 	swap => ['-t', '{host} swap usage', '-v', 'Bytes', '-b', '1024', '-l', '0'],
 	temperature => ['-t', '{host} temperature {inst}', '-v', '�Celsius'],
+	time_offset => ['-t', 'NTPd time offset ({inst})', '-v', 'Seconds'],
+	time_dispersion => ['-t', 'NTPd time dispersion ({inst})', '-v', 'Seconds'],
 	traffic => ['-t', '{host} {inst} traffic', '-v', 'Bit/s'],
 	users => ['-t', '{host} users', '-v', 'Users'],
 	voltage => ['-t', '{host} voltage', '-v', 'Volts'],
+	apcups_volt => ['-t', '{host} APC voltage {inst}', '-v', 'Volts AC'],
+	apcups_bvolt => ['-t', '{host} APC Batt voltage {inst}', '-v', 'Volts DC'],
+	apcups_load => ['-t', '{host} APC Load {inst}', '-v', 'Percent'],
+	apcups_charge => ['-t', '{host} APC Batt Charge {inst}', '-v', 'Percent'],
+	apcups_time => ['-t', '{host} APC Time Left {inst}', '-v', 'Minutes'],
+	apcups_temp => ['-t', '{host} APC Internal Temp {inst}', '-v', '�Celsius'],
+	apcups_freq => ['-t', '{host} APC Line Freq {inst}', '-v', 'Hz'],
 	vs_threads => ['-t', '{host} threads', '-v', 'Threads'],
 	vs_memory => ['-t', '{host} memory usage', '-v', 'Bytes'],
 	vs_processes => ['-t', '{host} processes', '-v', 'Processes'],
@@ -902,6 +1030,13 @@ our $GraphMulti =
 	cpu	=> \&output_graph_cpu,
 	cpufreq => 1,
 	disk	=> 1,
+	apcups_volt => 1,
+	apcups_bvolt => 1,
+	apcups_load => 1,
+	apcups_charge => 1,
+	apcups_time => 1,
+	apcups_temp => 1,
+	apcups_freq => 1,
 	load	=> 0,
 	mails	=> 0,
 	memory	=> 0,
@@ -1,3 +1,9 @@
+collectd (3.9.3) unstable; urgency=low
+
+  * New upstream version 
+
+ -- Florian Forster <octo@leeloo.home.verplant.org>  Thu,  1 Jun 2006 22:41:55 +0200
+
 collectd (3.9.2-1) unstable; urgency=low
 
   * New upstream version
@@ -1,5 +1,5 @@
 SUBDIRS = libconfig
-if BUILD_MODULE_PING
+if BUILD_WITH_OWN_LIBOPING
 SUBDIRS += liboping
 endif
 
@@ -236,12 +236,29 @@ collectd_LDADD += "-dlopen" nfs.la
 collectd_DEPENDENCIES += nfs.la
 endif
 
+if BUILD_MODULE_NTPD
+pkglib_LTLIBRARIES += ntpd.la
+ntpd_la_SOURCES = ntpd.c
+ntpd_la_LDFLAGS = -module -avoid-version
+if BUILD_WITH_LIBSOCKET
+ntpd_la_LDFLAGS += -lsocket
+endif
+collectd_LDADD += "-dlopen" ntpd.la
+collectd_DEPENDENCIES += ntpd.la
+endif
+
 if BUILD_MODULE_PING
 pkglib_LTLIBRARIES += ping.la
 ping_la_SOURCES = ping.c
 ping_la_LDFLAGS = -module -avoid-version
+if BUILD_WITH_LIBOPING
+if BUILD_WITH_OWN_LIBOPING
 ping_la_LIBADD  = liboping/liboping.la
 ping_la_DEPENDENCIES = liboping/liboping.la
+else
+ping_la_LDFLAGS += -loping
+endif
+endif
 collectd_LDADD += "-dlopen" ping.la
 collectd_DEPENDENCIES += ping.la
 endif
@@ -22,110 +22,91 @@
  *   Anthony Gialluca <tonyabg at charter.net>
  **/
 
+/*
+ * FIXME: Don't know why but without this here atof() was not returning
+ * correct values for me. This is behavior that I don't understand and
+ * should be examined in closer detail.
+ */
+#include <stdlib.h>
+
 #include "collectd.h"
-#include "common.h" /* rrd_update_file */
-#include "plugin.h" /* plugin_register, plugin_submit */
-#include "configfile.h" /* cf_register */
-
-/* FIXME: Check defines before including anything! */
-#include <stdarg.h>
-#include <unistd.h>
-#include <string.h>
-#include <strings.h>
-#include <signal.h>
-#include <ctype.h>
-#include <syslog.h>
-#include <limits.h>
-#include <pwd.h>
-#include <time.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <setjmp.h>
-#include <termios.h>
-#include <netdb.h>
-#include <sys/ioctl.h>
-#include <sys/ipc.h>
-#include <sys/sem.h>
-#include <sys/shm.h>
-#include <sys/socket.h>
-#include <sys/types.h>
-#include <sys/time.h>
-#include <time.h>
-#include <sys/wait.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
+#include "common.h"      /* rrd_update_file */
+#include "plugin.h"      /* plugin_register, plugin_submit */
+#include "configfile.h"  /* cf_register */
+#include "utils_debug.h"
+
+#if HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+#if HAVE_SYS_SOCKET_H
+# include <sys/socket.h>
+#endif
+#if HAVE_NETDB_H
+# include <netdb.h>
+#endif
+
+#if HAVE_NETINET_IN_H
+# include <netinet/in.h>
+#endif
+
+#ifndef APCMAIN
+# define APCMAIN 0
+#endif
 
 #define NISPORT 3551
-#define _(String) (String)
-#define N_(String) (String)
 #define MAXSTRING               256
 #define MODULE_NAME "apcups"
 
-
-/* Prototypes */
-static void generic_error_out(const char *, int , const char *, ...);
+#define APCUPS_DEFAULT_HOST "localhost"
 
 /* Default values for contacting daemon */
-static char *host = "localhost";
-static int port = NISPORT;
-
-static struct sockaddr_in tcp_serv_addr;  /* socket information */
-static char *net_errmsg = NULL;           /* pointer to error message */
-static char net_errbuf[256];              /* error message buffer for messages */
+static char *global_host = NULL;
+static int   global_port = NISPORT;
 
 /* 
  * The following are only if not compiled to test the module with its own main.
 */
-/* FIXME: Rename DSes to be more generic and follow established conventions. */
-#ifndef APCMAIN
-static char *volt_file_template = "apcups_volt-%s.rrd";
-static char *volt_ds_def[] = 
-{
-	"DS:linev:GAUGE:"COLLECTD_HEARTBEAT":0:250",
-	"DS:outputv:GAUGE:"COLLECTD_HEARTBEAT":0:250",
-	NULL
-};
-static int volt_ds_num = 2;
-
-static char *bvolt_file_template = "apcups_bvolt-%s.rrd";
+#if !APCMAIN
+static char *bvolt_file_template = "apcups/voltage-%s.rrd";
 static char *bvolt_ds_def[] = 
 {
-	"DS:battv:GAUGE:"COLLECTD_HEARTBEAT":0:100",
+	"DS:voltage:GAUGE:"COLLECTD_HEARTBEAT":0:U",
 };
 static int bvolt_ds_num = 1;
 
-static char *load_file_template = "apcups_load-%s.rrd";
+static char *load_file_template = "apcups/load_percent.rrd";
 static char *load_ds_def[] = 
 {
-	"DS:loadpct:GAUGE:"COLLECTD_HEARTBEAT":0:120",
+	"DS:percent:GAUGE:"COLLECTD_HEARTBEAT":0:110",
 };
 static int load_ds_num = 1;
 
-static char *charge_file_template = "apcups_charge-%s.rrd";
+static char *charge_file_template = "apcups/charge_percent.rrd";
 static char *charge_ds_def[] = 
 {
-	"DS:bcharge:GAUGE:"COLLECTD_HEARTBEAT":0:100",
+	"DS:percent:GAUGE:"COLLECTD_HEARTBEAT":0:110",
 };
 static int charge_ds_num = 1;
 
-static char *time_file_template = "apcups_time-%s.rrd";
+static char *time_file_template = "apcups/timeleft.rrd";
 static char *time_ds_def[] = 
 {
 	"DS:timeleft:GAUGE:"COLLECTD_HEARTBEAT":0:100",
 };
 static int time_ds_num = 1;
 
-static char *temp_file_template = "apcups_temp-%s.rrd";
+static char *temp_file_template = "apcups/temperature.rrd";
 static char *temp_ds_def[] = 
 {
-	"DS:itemp:GAUGE:"COLLECTD_HEARTBEAT":0:100",
+	/* -273.15 is absolute zero */
+	"DS:value:GAUGE:"COLLECTD_HEARTBEAT":-274:U",
 };
 static int temp_ds_num = 1;
 
-static char *freq_file_template = "apcups_freq-%s.rrd";
+static char *freq_file_template = "apcups/frequency-%s.rrd";
 static char *freq_ds_def[] = 
 {
-	"DS:linefreq:GAUGE:"COLLECTD_HEARTBEAT":0:65",
+	"DS:frequency:GAUGE:"COLLECTD_HEARTBEAT":0:U",
 };
 static int freq_ds_num = 1;
 
@@ -137,90 +118,96 @@ static char *config_keys[] =
 };
 static int config_keys_num = 2;
 
-#endif /* ifndef APCMAIN */
+#endif /* if APCMAIN */
 
 struct apc_detail_s
 {
-	float linev;
-	float loadpct;
-	float bcharge;
-	float timeleft;
-	float outputv;
-	float itemp;
-	float battv;
-	float linefreq;
+	double linev;
+	double loadpct;
+	double bcharge;
+	double timeleft;
+	double outputv;
+	double itemp;
+	double battv;
+	double linefreq;
 };
 
 #define BIG_BUF 4096
 
-/*
- * Subroutine normally called by macro error_abort() to print
- * FATAL ERROR message and supplied error message
- */
-static void generic_error_out(const char *file, int line, const char *fmt, ...)
-{
-	char buf[256];
-	va_list arg_ptr;
-	int i;
-
-	snprintf(buf, sizeof(buf), _("FATAL ERROR in %s at line %d\n"), file, line);
-	i = strlen(buf);
-	va_start(arg_ptr, fmt);
-	vsnprintf((char *)&buf[i], sizeof(buf) - i, (char *)fmt, arg_ptr);
-	va_end(arg_ptr);
-	fprintf(stdout, "%s", buf);
-
-	exit(1);
-}
-
 /*
  * Read nbytes from the network.
  * It is possible that the total bytes require in several
  * read requests
  */
-static int read_nbytes(int fd, char *ptr, int nbytes)
+static int read_nbytes (int *fd, char *ptr, int nbytes)
 {
-	int nleft, nread;
+	int nleft;
+	int nread;
 
 	nleft = nbytes;
+	nread = -1;
 
-	while (nleft > 0) {
-		do {
-			nread = read(fd, ptr, nleft);
-		} while (nread == -1 && (errno == EINTR || errno == EAGAIN));
+	assert (*fd >= 0);
+
+	while ((nleft > 0) && (nread != 0))
+	{
+		nread = read (*fd, ptr, nleft);
+
+		if ((nread < 0) && (errno == EINTR || errno == EAGAIN))
+			continue;
+
+		if (nread < 0)
+		{
+			*fd = -1;
+			DBG ("Reading from socket failed failed: %s; *fd = -1;", strerror (errno));
+			syslog (LOG_ERR, "apcups plugin: Reading from socket failed failed: %s", strerror (errno));
+			return (-1);
+		}
 
-		if (nread <= 0) {
-			return (nread);           /* error, or EOF */
+		if (nread == 0)
+		{
+			DBG ("Received EOF. Closing socket %i.", *fd);
+			close (*fd);
+			*fd = -1;
+			return (nbytes - nleft);
 		}
 
 		nleft -= nread;
 		ptr += nread;
 	}
 
-	return (nbytes - nleft);        /* return >= 0 */
+	return (nbytes - nleft);
 }
 
 /*
  * Write nbytes to the network.
  * It may require several writes.
  */
-static int write_nbytes(int fd, void *buf, int buflen)
+static int write_nbytes (int *fd, void *buf, int buflen)
 {
 	int nleft;
 	int nwritten;
 	char *ptr;
 
+	assert (buflen > 0);
+	assert (*fd >= 0);
+
 	ptr = (char *) buf;
 
 	nleft = buflen;
 	while (nleft > 0)
 	{
-		nwritten = write(fd, ptr, nleft);
+		nwritten = write (*fd, ptr, nleft);
 
-		if (nwritten <= 0)
+		if ((nwritten < 0) && ((errno == EAGAIN) || (errno == EINTR)))
+			continue;
+
+		if (nwritten < 0)
 		{
-			syslog (LOG_ERR, "Writing to socket failed: %s", strerror (errno));
-			return (nwritten);
+			*fd = -1;
+			DBG ("Writing to socket failed: %s; *fd = -1;", strerror (errno));
+			syslog (LOG_ERR, "apcups plugin: Writing to socket failed: %s", strerror (errno));
+			return (-1);
 		}
 
 		nleft -= nwritten;
@@ -231,79 +218,87 @@ static int write_nbytes(int fd, void *buf, int buflen)
 	return (buflen);
 }
 
+#if APCMAIN
 /* Close the network connection */
-static void net_close (int sockfd)
+static void net_close (int *fd)
 {
 	short pktsiz = 0;
 
+	assert (*fd >= 0);
+
+	DBG ("Gracefully shutting down socket %i.", *fd);
+
 	/* send EOF sentinel */
-	write_nbytes (sockfd, &pktsiz, sizeof(short));
-	close (sockfd);
-}
+	write_nbytes (fd, &pktsiz, sizeof (short));
 
+	close (*fd);
+	*fd = -1;
+}
+#endif /* APCMAIN */
 
 /*     
  * Open a TCP connection to the UPS network server
  * Returns -1 on error
  * Returns socket file descriptor otherwise
  */
-static int net_open(char *host, char *service, int port)
+static int net_open (char *host, char *service, int port)
 {
-	int sockfd;
-	struct hostent *hp;
-	unsigned int inaddr; /* Careful here to use unsigned int for */
-	                     /* compatibility with Alpha */
-
-	/* 
-	 * Fill in the structure serv_addr with the address of the server that
-	 * we want to connect with.
-	 */
-	memset((char *)&tcp_serv_addr, 0, sizeof(tcp_serv_addr));
-	tcp_serv_addr.sin_family = AF_INET;
-	tcp_serv_addr.sin_port = htons(port);
-
-	if ((inaddr = inet_addr(host)) != INADDR_NONE) {
-		tcp_serv_addr.sin_addr.s_addr = inaddr;
-	} else {
-		if ((hp = gethostbyname(host)) == NULL) {
-			net_errmsg = "tcp_open: hostname error\n";
-			return -1;
-		}
+	int              sd;
+	int              status;
+	char             port_str[8];
+	struct addrinfo  ai_hints;
+	struct addrinfo *ai_return;
+	struct addrinfo *ai_list;
 
-		if (hp->h_length != sizeof(inaddr) || hp->h_addrtype != AF_INET) {
-			net_errmsg = "tcp_open: funny gethostbyname value\n";
-			return -1;
-		}
+	assert ((port > 0x00000000) && (port <= 0x0000FFFF));
+
+	/* Convert the port to a string */
+	snprintf (port_str, 8, "%i", port);
+	port_str[7] = '\0';
 
-		tcp_serv_addr.sin_addr.s_addr = *(unsigned int *)hp->h_addr;
+	/* Resolve name */
+	memset ((void *) &ai_hints, '\0', sizeof (ai_hints));
+	ai_hints.ai_family   = AF_INET; /* XXX: Change this to `AF_UNSPEC' if apcupsd can handle IPv6 */
+	ai_hints.ai_socktype = SOCK_STREAM;
+
+	status = getaddrinfo (host, port_str, &ai_hints, &ai_return);
+	if (status != 0)
+	{
+		DBG ("getaddrinfo failed: %s", status == EAI_SYSTEM ? strerror (errno) : gai_strerror (status));
+		return (-1);
 	}
 
-	/* Open a TCP socket */
-	if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
-		net_errmsg = "tcp_open: cannot open stream socket\n";
-		return -1;
+	/* Create socket */
+	sd = -1;
+	for (ai_list = ai_return; ai_list != NULL; ai_list = ai_list->ai_next)
+	{
+		sd = socket (ai_list->ai_family, ai_list->ai_socktype, ai_list->ai_protocol);
+		if (sd >= 0)
+			break;
 	}
+	/* `ai_list' still holds the current description of the socket.. */
 
-	/* connect to server */
-#if defined HAVE_OPENBSD_OS || defined HAVE_FREEBSD_OS
-	/* 
-	 * Work around a bug in OpenBSD & FreeBSD userspace pthreads
-	 * implementations. Rationale is the same as described above.
-	 */
-	fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL));
-#endif
+	if (sd < 0)
+	{
+		DBG ("Unable to open a socket");
+		freeaddrinfo (ai_return);
+		return (-1);
+	}
+
+	status = connect (sd, ai_list->ai_addr, ai_list->ai_addrlen);
+
+	freeaddrinfo (ai_return);
 
-	if (connect(sockfd, (struct sockaddr *)&tcp_serv_addr, sizeof(tcp_serv_addr)) < 0) {
-		snprintf(net_errbuf, sizeof(net_errbuf),
-				_("tcp_open: cannot connect to server %s on port %d.\n"
-					"ERR=%s\n"), host, port, strerror(errno));
-		net_errmsg = net_errbuf;
-		close(sockfd);
-		return -1;
+	if (status != 0) /* `connect(2)' failed */
+	{
+		DBG ("connect failed: %s", strerror (errno));
+		return (-1);
 	}
 
-	return sockfd;
-} /* int net_open(char *host, char *service, int port) */
+	DBG ("Done opening a socket %i", sd);
+
+	return (sd);
+} /* int net_open (char *host, char *service, int port) */
 
 /* 
  * Receive a message from the other end. Each message consists of
@@ -314,39 +309,37 @@ static int net_open(char *host, char *service, int port)
  * Returns -1 on hard end of file (i.e. network connection close)
  * Returns -2 on error
  */
-static int net_recv(int sockfd, char *buff, int maxlen)
+static int net_recv (int *sockfd, char *buf, int buflen)
 {
-	int nbytes;
+	int   nbytes;
 	short pktsiz;
 
 	/* get data size -- in short */
-	if ((nbytes = read_nbytes(sockfd, (char *)&pktsiz, sizeof(short))) <= 0) {
-		/* probably pipe broken because client died */
-		return -1;                   /* assume hard EOF received */
-	}
-	if (nbytes != sizeof(short))
-		return -2;
+	if ((nbytes = read_nbytes (sockfd, (char *) &pktsiz, sizeof (short))) <= 0)
+		return (-1);
 
-	pktsiz = ntohs(pktsiz);         /* decode no. of bytes that follow */
-	if (pktsiz > maxlen) {
-		net_errmsg = "net_recv: record length too large\n";
-		return -2;
+	if (nbytes != sizeof (short))
+		return (-2);
+
+	pktsiz = ntohs (pktsiz);
+	if (pktsiz > buflen)
+	{
+		DBG ("record length too large");
+		return (-2);
 	}
+
 	if (pktsiz == 0)
-		return 0;                    /* soft EOF */
+		return (0);
 
 	/* now read the actual data */
-	if ((nbytes = read_nbytes(sockfd, buff, pktsiz)) <= 0) {
-		net_errmsg = "net_recv: read_nbytes error\n";
-		return -2;
-	}
-	if (nbytes != pktsiz) {
-		net_errmsg = "net_recv: error in read_nbytes\n";
-		return -2;
-	}
+	if ((nbytes = read_nbytes (sockfd, buf, pktsiz)) <= 0)
+		return (-2);
 
-	return (nbytes);                /* return actual length of message */
-}
+	if (nbytes != pktsiz)
+		return (-2);
+
+	return (nbytes);
+} /* static int net_recv (int sockfd, char *buf, int buflen) */
 
 /*
  * Send a message over the network. The send consists of
@@ -355,16 +348,19 @@ static int net_recv(int sockfd, char *buff, int maxlen)
  * Returns zero on success
  * Returns non-zero on error
  */
-static int net_send(int sockfd, char *buff, int len)
+static int net_send (int *sockfd, char *buff, int len)
 {
 	int rc;
 	short packet_size;
 
+	assert (len > 0);
+	assert (*sockfd >= 0);
+
 	/* send short containing size of data packet */
 	packet_size = htons ((short) len);
 
-	rc = write_nbytes(sockfd, &packet_size, sizeof (packet_size));
-	if (rc != sizeof(packet_size))
+	rc = write_nbytes (sockfd, &packet_size, sizeof (packet_size));
+	if (rc != sizeof (packet_size))
 		return (-1);
 
 	/* send data packet */
@@ -376,361 +372,281 @@ static int net_send(int sockfd, char *buff, int len)
 }
 
 /* Get and print status from apcupsd NIS server */
-static int do_pthreads_status(char *host, int port, struct apc_detail_s *apcups_detail)
+static int apc_query_server (char *host, int port,
+		struct apc_detail_s *apcups_detail)
 {
-	int     sockfd;
 	int     n;
-	char    recvline[MAXSTRING + 1];
+	char    recvline[1024];
 	char   *tokptr;
 	char   *key;
 	double  value;
+
+	static int sockfd   = -1;
+	static unsigned int complain = 0;
+
 #if APCMAIN
 # define PRINT_VALUE(name, val) printf("  Found property: name = %s; value = %f;\n", name, val)
 #else
 # define PRINT_VALUE(name, val) /**/
 #endif
 
-	/* TODO: Keep the socket open, if possible */
-	if ((sockfd = net_open (host, NULL, port)) < 0)
+	if (sockfd < 0)
 	{
-		syslog (LOG_ERR, "apcups plugin: Connecting to the apcupsd failed.");
-		return (-1);
+		if ((sockfd = net_open (host, NULL, port)) < 0)
+		{
+			/* Complain once every six hours. */
+			int complain_step = 21600 / atoi (COLLECTD_STEP);
+
+			if ((complain % complain_step) == 0)
+				syslog (LOG_ERR, "apcups plugin: Connecting to the apcupsd failed.");
+			complain++;
+
+			return (-1);
+		}
+		else if (complain > 1)
+		{
+			syslog (LOG_NOTICE, "apcups plugin: Connection re-established to the apcupsd.");
+			complain = 0;
+		}
 	}
 
-	net_send (sockfd, "status", 6);
+	if (net_send (&sockfd, "status", 6) < 0)
+	{
+		syslog (LOG_ERR, "apcups plugin: Writing to the socket failed.");
+		return (-1);
+	}
 
-	while ((n = net_recv (sockfd, recvline, sizeof (recvline))) > 0)
+	while ((n = net_recv (&sockfd, recvline, sizeof (recvline) - 1)) > 0)
 	{
+		assert (n < sizeof (recvline));
 		recvline[n] = '\0';
 #if APCMAIN
 		printf ("net_recv = `%s';\n", recvline);
 #endif /* if APCMAIN */
 
-		tokptr = strtok (recvline, ":");
+		tokptr = strtok (recvline, " :\t");
 		while (tokptr != NULL)
 		{
 			key = tokptr;
-			if ((tokptr = strtok (NULL, " \t")) == NULL)
+			if ((tokptr = strtok (NULL, " :\t")) == NULL)
 				continue;
 			value = atof (tokptr);
+
 			PRINT_VALUE (key, value);
 
 			if (strcmp ("LINEV", key) == 0)
 				apcups_detail->linev = value;
-			else if (strcmp ("BATTV", tokptr) == 0)
+			else if (strcmp ("BATTV", key) == 0) 
 				apcups_detail->battv = value;
-			else if (strcmp ("ITEMP", tokptr) == 0)
+			else if (strcmp ("ITEMP", key) == 0)
 				apcups_detail->itemp = value;
-			else if (strcmp ("LOADPCT", tokptr) == 0)
+			else if (strcmp ("LOADPCT", key) == 0)
 				apcups_detail->loadpct = value;
-			else if (strcmp ("BCHARGE", tokptr) == 0)
+			else if (strcmp ("BCHARGE", key) == 0)
 				apcups_detail->bcharge = value;
-			else if (strcmp ("OUTPUTV", tokptr) == 0)
+			else if (strcmp ("OUTPUTV", key) == 0)
 				apcups_detail->outputv = value;
-			else if (strcmp ("LINEFREQ", tokptr) == 0)
+			else if (strcmp ("LINEFREQ", key) == 0)
 				apcups_detail->linefreq = value;
-			else if (strcmp ("TIMELEFT", tokptr) == 0)
+			else if (strcmp ("TIMELEFT", key) == 0)
 				apcups_detail->timeleft = value;
-			else
-			{
-				syslog (LOG_WARNING, "apcups plugin: Received unknown property from apcupsd: `%s' = %f",
-						key, value);
-			}
 
 			tokptr = strtok (NULL, ":");
 		} /* while (tokptr != NULL) */
 	}
-
-	net_close (sockfd);
-
+	
 	if (n < 0)
 	{
 		syslog (LOG_WARNING, "apcups plugin: Error reading from socket");
 		return (-1);
 	}
+#if APCMAIN
+	else
+	{
+		/* close the opened socket */
+		net_close (&sockfd);
+	}
+#endif /* APCMAIN */
 
 	return (0);
 }
 
-#ifdef APCMAIN
-int main(int argc, char **argv)
+#if APCMAIN
+/*
+ * This is used for testing apcups in a standalone mode.
+ * Usefull for debugging.
+ */
+int main (int argc, char **argv)
 {
 	/* we are not really going to use this */
 	struct apc_detail_s apcups_detail;
 
-	if (!*host || strcmp(host, "0.0.0.0") == 0)
-		host = "localhost";
+	openlog ("apcups", LOG_PID | LOG_NDELAY | LOG_LOCAL1, LOG_USER);
+
+	if (global_host == NULL || strcmp (global_host, "0.0.0.0") == 0)
+		global_host = "localhost";
 
-	do_pthreads_status(host, port, &apcups_detail);
+	if(apc_query_server (global_host, global_port, &apcups_detail) < 0)
+	{
+		printf("apcups: Failed...\n");
+		return(-1);
+	}
 
 	return 0;
 }
 #else
-static void apcups_init (void)
-{
-	return;
-}
-
 static int apcups_config (char *key, char *value)
 {
-  static char lhost[126];
-  
-  if (strcasecmp (key, "host") == 0)
-    {
-      lhost[0] = '\0';
-      strcpy(lhost,key);
-      host = lhost;
-    }
-  else if (strcasecmp (key, "Port") == 0)
-    {
-      int port_tmp = atoi (value);
-      if(port_tmp < 1 || port_tmp > 65535) {
-	syslog (LOG_WARNING, "apcups: `port' failed: %s",
-		value);
-	return (1);
-      } else {
-	port = port_tmp;
-      }
-    }
-  else
-    {
-      return (-1);
-    }
-  return(0);
+	if (strcasecmp (key, "host") == 0)
+	{
+		if (global_host != NULL)
+		{
+			free (global_host);
+			global_host = NULL;
+		}
+		if ((global_host = strdup (value)) == NULL)
+			return (1);
+	}
+	else if (strcasecmp (key, "Port") == 0)
+	{
+		int port_tmp = atoi (value);
+		if (port_tmp < 1 || port_tmp > 65535)
+		{
+			syslog (LOG_WARNING, "apcups plugin: Invalid port: %i", port_tmp);
+			return (1);
+		}
+		global_port = port_tmp;
+	}
+	else
+	{
+		return (-1);
+	}
+	return (0);
 }
 
-#define BUFSIZE 256
-static void apcups_submit (char *host,
-			   struct apc_detail_s *apcups_detail)
+static void apcups_init (void)
 {
-	char buf[BUFSIZE];
-
-	if (snprintf (buf, BUFSIZE, "%u:%f:%f",
-		      (unsigned int) curtime,
-		      apcups_detail->linev,
-		      apcups_detail->outputv) >= BUFSIZE)
-	  return;
-	
-	plugin_submit (MODULE_NAME, host, buf);
+	return;
 }
 
-static void apc_bvolt_submit (char *host,
-			   struct apc_detail_s *apcups_detail)
+static void apc_write_voltage (char *host, char *inst, char *val)
 {
-	char buf[BUFSIZE];
-
-	if (snprintf (buf, BUFSIZE, "%u:%f",
-		      (unsigned int) curtime,
-		      apcups_detail->battv) >= BUFSIZE)
-	  return;
-	
-	plugin_submit ("apcups_bvolt", host, buf);
-}
+	char file[512];
+	int  status;
 
-static void apc_load_submit (char *host,
-			   struct apc_detail_s *apcups_detail)
-{
-	char buf[BUFSIZE];
+	status = snprintf (file, 512, bvolt_file_template, inst);
+	if ((status < 1) || (status >= 512))
+		return;
 
-	if (snprintf (buf, BUFSIZE, "%u:%f",
-		      (unsigned int) curtime,
-		      apcups_detail->loadpct) >= BUFSIZE)
-	  return;
-	
-	plugin_submit ("apcups_load", host, buf);
+	rrd_update_file (host, file, val, bvolt_ds_def, bvolt_ds_num);
 }
 
-static void apc_charge_submit (char *host,
-			   struct apc_detail_s *apcups_detail)
+static void apc_write_charge (char *host, char *inst, char *val)
 {
-	char buf[BUFSIZE];
-
-	if (snprintf (buf, BUFSIZE, "%u:%f",
-		      (unsigned int) curtime,
-		      apcups_detail->bcharge) >= BUFSIZE)
-	  return;
-	
-	plugin_submit ("apcups_charge", host, buf);
+	rrd_update_file (host, charge_file_template, val, charge_ds_def, charge_ds_num);
 }
 
-static void apc_temp_submit (char *host,
-			   struct apc_detail_s *apcups_detail)
+static void apc_write_percent (char *host, char *inst, char *val)
 {
-	char buf[BUFSIZE];
-
-	if (snprintf (buf, BUFSIZE, "%u:%f",
-		      (unsigned int) curtime,
-		      apcups_detail->itemp) >= BUFSIZE)
-	  return;
-	
-	plugin_submit ("apcups_temp", host, buf);
+	rrd_update_file (host, load_file_template, val, load_ds_def, load_ds_num);
 }
 
-static void apc_time_submit (char *host,
-			   struct apc_detail_s *apcups_detail)
+static void apc_write_timeleft (char *host, char *inst, char *val)
 {
-	char buf[BUFSIZE];
-
-	if (snprintf (buf, BUFSIZE, "%u:%f",
-		      (unsigned int) curtime,
-		      apcups_detail->timeleft) >= BUFSIZE)
-	  return;
-	
-	plugin_submit ("apcups_time", host, buf);
+	rrd_update_file (host, time_file_template, val, time_ds_def, time_ds_num);
 }
 
-static void apc_freq_submit (char *host,
-			   struct apc_detail_s *apcups_detail)
+static void apc_write_temperature (char *host, char *inst, char *val)
 {
-	char buf[BUFSIZE];
-
-	if (snprintf (buf, BUFSIZE, "%u:%f",
-		      (unsigned int) curtime,
-		      apcups_detail->linefreq) >= BUFSIZE)
-	  return;
-	
-	plugin_submit ("apcups_freq", host, buf);
+	rrd_update_file (host, temp_file_template, val, temp_ds_def, temp_ds_num);
 }
-#undef BUFSIZE
 
-static void apcups_read (void)
+static void apc_write_frequency (char *host, char *inst, char *val)
 {
-  struct apc_detail_s apcups_detail;
-	
-  apcups_detail.linev = 0.0;
-  apcups_detail.loadpct = 0.0;
-  apcups_detail.bcharge = 0.0;
-  apcups_detail.timeleft = 0.0;
-  apcups_detail.outputv = 0.0;
-  apcups_detail.itemp = 0.0;
-  apcups_detail.battv = 0.0;
-  apcups_detail.linefreq = 0.0;
-
-  
-  if (!*host || strcmp(host, "0.0.0.0") == 0)
-    host = "localhost";
-  
-  do_pthreads_status(host, port, &apcups_detail);
- 
-  apcups_submit (host, &apcups_detail);
-  apc_bvolt_submit (host, &apcups_detail);
-  apc_load_submit (host, &apcups_detail);
-  apc_charge_submit (host, &apcups_detail);
-  apc_temp_submit (host, &apcups_detail);
-  apc_time_submit (host, &apcups_detail);
-  apc_freq_submit (host, &apcups_detail);
-}
+	char file[512];
+	int  status;
 
+	status = snprintf (file, 512, freq_file_template, inst);
+	if ((status < 1) || (status >= 512))
+		return;
 
-static void apcups_write (char *host, char *inst, char *val)
-{
-  char file[512];
-  int status;
-  
-  status = snprintf (file, 512, volt_file_template, inst);
-  if (status < 1)
-    return;
-  else if (status >= 512)
-    return;
-  
-  rrd_update_file (host, file, val, volt_ds_def, volt_ds_num);
+	rrd_update_file (host, file, val, freq_ds_def, freq_ds_num);
 }
 
-static void apc_bvolt_write (char *host, char *inst, char *val)
+static void apc_submit_generic (char *type, char *inst,
+		double value)
 {
-  char file[512];
-  int status;
-  
-  status = snprintf (file, 512, bvolt_file_template, inst);
-  if (status < 1)
-    return;
-  else if (status >= 512)
-    return;
-  
-  rrd_update_file (host, file, val, bvolt_ds_def, bvolt_ds_num);
-}
+	char buf[512];
+	int  status;
 
-static void apc_load_write (char *host, char *inst, char *val)
-{
-  char file[512];
-  int status;
-  
-  status = snprintf (file, 512, load_file_template, inst);
-  if (status < 1)
-    return;
-  else if (status >= 512)
-    return;
-  
-  rrd_update_file (host, file, val, load_ds_def, load_ds_num);
-}
+	status = snprintf (buf, 512, "%u:%f",
+			(unsigned int) curtime, value);
+	if ((status < 1) || (status >= 512))
+		return;
 
-static void apc_charge_write (char *host, char *inst, char *val)
-{
-  char file[512];
-  int status;
-  
-  status = snprintf (file, 512, charge_file_template, inst);
-  if (status < 1)
-    return;
-  else if (status >= 512)
-    return;
-  
-  rrd_update_file (host, file, val, charge_ds_def, charge_ds_num);
+	DBG ("plugin_submit (%s, %s, %s);", type, inst, buf);
+	plugin_submit (type, inst, buf);
 }
 
-static void apc_temp_write (char *host, char *inst, char *val)
+static void apc_submit (struct apc_detail_s *apcups_detail)
 {
-  char file[512];
-  int status;
-  
-  status = snprintf (file, 512, temp_file_template, inst);
-  if (status < 1)
-    return;
-  else if (status >= 512)
-    return;
-  
-  rrd_update_file (host, file, val, temp_ds_def, temp_ds_num);
+	apc_submit_generic ("apcups_voltage",    "input",   apcups_detail->linev);
+	apc_submit_generic ("apcups_voltage",    "output",  apcups_detail->outputv);
+	apc_submit_generic ("apcups_voltage",    "battery", apcups_detail->battv);
+	apc_submit_generic ("apcups_charge",     "-",       apcups_detail->bcharge);
+	apc_submit_generic ("apcups_charge_pct", "-",       apcups_detail->loadpct);
+	apc_submit_generic ("apcups_timeleft",   "-",       apcups_detail->timeleft);
+	apc_submit_generic ("apcups_temp",       "-",       apcups_detail->itemp);
+	apc_submit_generic ("apcups_frequency",  "input",   apcups_detail->linefreq);
 }
 
-static void apc_time_write (char *host, char *inst, char *val)
+static void apcups_read (void)
 {
-  char file[512];
-  int status;
-  
-  status = snprintf (file, 512, time_file_template, inst);
-  if (status < 1)
-    return;
-  else if (status >= 512)
-    return;
+	struct apc_detail_s apcups_detail;
+	int status;
+
+	apcups_detail.linev    =   -1.0;
+	apcups_detail.outputv  =   -1.0;
+	apcups_detail.battv    =   -1.0;
+	apcups_detail.loadpct  =   -1.0;
+	apcups_detail.bcharge  =   -1.0;
+	apcups_detail.timeleft =   -1.0;
+	apcups_detail.itemp    = -300.0;
+	apcups_detail.linefreq =   -1.0;
   
-  rrd_update_file (host, file, val, time_ds_def, time_ds_num);
-}
+	status = apc_query_server (global_host == NULL
+			? APCUPS_DEFAULT_HOST
+			: global_host,
+			global_port, &apcups_detail);
+ 
+	/*
+	 * if we did not connect then do not bother submitting
+	 * zeros. We want rrd files to have NAN.
+	 */
+	if (status != 0)
+	{
+		DBG ("apc_query_server (%s, %i) = %i",
+				global_host == NULL
+				? APCUPS_DEFAULT_HOST
+				: global_host,
+				global_port, status);
+		return;
+	}
 
-static void apc_freq_write (char *host, char *inst, char *val)
-{
-  char file[512];
-  int status;
-  
-  status = snprintf (file, 512, freq_file_template, inst);
-  if (status < 1)
-    return;
-  else if (status >= 512)
-    return;
-  
-  rrd_update_file (host, file, val, freq_ds_def, freq_ds_num);
-}
+	apc_submit (&apcups_detail);
+} /* apcups_read */
 
 void module_register (void)
 {
-	plugin_register (MODULE_NAME, apcups_init, apcups_read, apcups_write);
-	plugin_register ("apcups_bvolt", NULL, NULL, apc_bvolt_write);
-	plugin_register ("apcups_load", NULL, NULL, apc_load_write);
-	plugin_register ("apcups_charge", NULL, NULL, apc_charge_write);
-	plugin_register ("apcups_temp", NULL, NULL, apc_temp_write);
-	plugin_register ("apcups_time", NULL, NULL, apc_time_write);
-	plugin_register ("apcups_freq", NULL, NULL, apc_freq_write);
+	plugin_register (MODULE_NAME, apcups_init, apcups_read, NULL);
+	plugin_register ("apcups_voltage",    NULL, NULL, apc_write_voltage);
+	plugin_register ("apcups_charge",     NULL, NULL, apc_write_charge);
+	plugin_register ("apcups_charge_pct", NULL, NULL, apc_write_percent);
+	plugin_register ("apcups_timeleft",   NULL, NULL, apc_write_timeleft);
+	plugin_register ("apcups_temp",       NULL, NULL, apc_write_temperature);
+	plugin_register ("apcups_frequency",  NULL, NULL, apc_write_frequency);
 	cf_register (MODULE_NAME, apcups_config, config_keys, config_keys_num);
 }
 
-#endif /* ifdef APCMAIN */
+#endif /* if APCMAIN */
 #undef MODULE_NAME
@@ -125,6 +125,61 @@ void sfree (void **ptr)
 }
 #endif
 
+ssize_t sread (int fd, void *buf, size_t count)
+{
+	char    *ptr;
+	size_t   nleft;
+	ssize_t  status;
+
+	ptr   = (char *) buf;
+	nleft = count;
+
+	while (nleft > 0)
+	{
+		status = read (fd, (void *) ptr, nleft);
+
+		if ((status < 0) && ((errno == EAGAIN) || (errno == EINTR)))
+			continue;
+
+		if (status < 0)
+			return (status);
+
+		assert (nleft >= status);
+
+		nleft = nleft - status;
+		ptr   = ptr   + status;
+	}
+
+	return (0);
+}
+
+
+ssize_t swrite (int fd, const void *buf, size_t count)
+{
+	const char *ptr;
+	size_t      nleft;
+	ssize_t     status;
+
+	ptr   = (const char *) buf;
+	nleft = count;
+
+	while (nleft > 0)
+	{
+		status = write (fd, (const void *) ptr, nleft);
+
+		if ((status < 0) && ((errno == EAGAIN) || (errno == EINTR)))
+			continue;
+
+		if (status < 0)
+			return (status);
+
+		nleft = nleft - status;
+		ptr   = ptr   + status;
+	}
+
+	return (0);
+}
+
 int strsplit (char *string, char **fields, size_t size)
 {
 	size_t i;
@@ -37,6 +37,44 @@ void sstrncpy(char *d, const char *s, int len);
 char *sstrdup(const char *s);
 void *smalloc(size_t size);
 
+/*
+ * NAME
+ *   sread
+ *
+ * DESCRIPTION
+ *   Reads exactly `n' bytes or failes. Syntax and other behavior is analogous
+ *   to `read(2)'.
+ *
+ * PARAMETERS
+ *   `fd'          File descriptor to write to.
+ *   `buf'         Buffer that is to be written.
+ *   `count'       Numver of bytes in the buffer.
+ *
+ * RETURN VALUE
+ *   Zero upon success or non-zero if an error occured. `errno' is set in this
+ *   case.
+ */
+ssize_t sread (int fd, void *buf, size_t count);
+
+/*
+ * NAME
+ *   swrite
+ *
+ * DESCRIPTION
+ *   Writes exactly `n' bytes or failes. Syntax and other behavior is analogous
+ *   to `write(2)'.
+ *
+ * PARAMETERS
+ *   `fd'          File descriptor to write to.
+ *   `buf'         Buffer that is to be written.
+ *   `count'       Numver of bytes in the buffer.
+ *
+ * RETURN VALUE
+ *   Zero upon success or non-zero if an error occured. `errno' is set in this
+ *   case.
+ */
+ssize_t swrite (int fd, const void *buf, size_t count);
+
 /*
  * NAME
  *   strsplit
@@ -158,6 +158,10 @@ static int hddtemp_query_daemon (char *buffer, int buffer_size)
 			fd = -1;
 			continue;
 		}
+
+		/* A socket could be opened and connecting succeeded. We're
+		 * done. */
+		break;
 	}
 
 	freeaddrinfo (ai_list);
@@ -970,6 +970,7 @@ int ping_host_add (pingobj_t *obj, const char *host)
 			continue;
 		}
 
+#if 0
 		if (bind (ph->fd, (struct sockaddr *) &sockaddr, sockaddr_len) == -1)
 		{
 			dprintf ("bind: %s\n", strerror (errno));
@@ -978,6 +979,7 @@ int ping_host_add (pingobj_t *obj, const char *host)
 			ph->fd = -1;
 			continue;
 		}
+#endif
 
 		assert (sizeof (struct sockaddr_storage) >= ai_ptr->ai_addrlen);
 		memset (ph->addr, '\0', sizeof (struct sockaddr_storage));
@@ -36,7 +36,7 @@
 #ifdef HAVE_MACH_HOST_PRIV_H
 # include <mach/host_priv.h>
 #endif
-#ifdef MACH_VM_STATISTICS_H
+#ifdef HAVE_MACH_VM_STATISTICS_H
 # include <mach/vm_statistics.h>
 #endif
 
@@ -0,0 +1,999 @@
+/**
+ * collectd - src/ntpd.c
+ * Copyright (C) 2006  Florian octo Forster
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; only version 2 of the License is applicable.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+ *
+ * Authors:
+ *   Florian octo Forster <octo at verplant.org>
+ **/
+
+#include "collectd.h"
+#include "common.h"
+#include "plugin.h"
+#include "configfile.h"
+#include "utils_debug.h"
+
+#define MODULE_NAME "ntpd"
+
+#if HAVE_SYS_SOCKET_H
+# define NTPD_HAVE_READ 1
+#else
+# define NTPD_HAVE_READ 0
+#endif
+
+#if HAVE_STDINT_H
+# include <stdint.h>
+#endif
+#if HAVE_NETDB_H
+# include <netdb.h>
+#endif
+#if HAVE_SYS_SOCKET_H
+# include <sys/socket.h>
+#endif
+#if HAVE_NETINET_IN_H
+# include <netinet/in.h>
+#endif
+#if HAVE_ARPA_INET_H
+# include <arpa/inet.h> /* inet_ntoa */
+#endif
+#if HAVE_NETINET_TCP_H
+# include <netinet/tcp.h>
+#endif
+#if HAVE_SYS_POLL_H
+# include <sys/poll.h>
+#endif
+
+static char *config_keys[] =
+{
+	"Host",
+	"Port",
+	NULL
+};
+static int config_keys_num = 2;
+
+/* drift */
+static char *time_offset_file     = "ntpd/time_offset-%s.rrd";
+static char *time_dispersion_file = "ntpd/time_dispersion-%s.rrd";
+static char *time_delay_file      = "ntpd/delay-%s.rrd";
+
+/* used for `time_offset', `time_dispersion', and `delay' */
+static char *sec_ds_def[] =
+{
+	"DS:seconds:GAUGE:"COLLECTD_HEARTBEAT":-1000000:1000000",
+	NULL
+};
+static int sec_ds_num = 1;
+
+static char *frequency_offset_file = "ntpd/frequency_offset-%s.rrd";
+static char *frequency_offset_ds_def[] =
+{
+	"DS:ppm:GAUGE:"COLLECTD_HEARTBEAT":-1000000:1000000",
+	NULL
+};
+static int frequency_offset_ds_num = 1;
+
+#if NTPD_HAVE_READ
+# define NTPD_DEFAULT_HOST "localhost"
+# define NTPD_DEFAULT_PORT "123"
+static int   sock_descr = -1;
+static char *ntpd_host = NULL;
+static char *ntpd_port = NULL;
+#endif
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * The following definitions were copied from the NTPd distribution  *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+#define MAXFILENAME 128
+#define MAXSEQ  127
+#define MODE_PRIVATE 7
+#define NTP_OLDVERSION ((u_char) 1) /* oldest credible version */
+#define IMPL_XNTPD 3
+#define FP_FRAC 65536.0
+
+#define REFCLOCK_ADDR 0x7f7f0000 /* 127.127.0.0 */
+#define REFCLOCK_MASK 0xffff0000 /* 255.255.0.0 */
+
+/* This structure is missing the message authentication code, since collectd
+ * doesn't use it. */
+struct req_pkt
+{
+	uint8_t  rm_vn_mode;
+	uint8_t  auth_seq;
+	uint8_t  implementation;		/* implementation number */
+	uint8_t  request;			/* request number */
+	uint16_t err_nitems;		/* error code/number of data items */
+	uint16_t mbz_itemsize;		/* item size */
+	char     data[MAXFILENAME + 48];	/* data area [32 prev](176 byte max) */
+					/* struct conf_peer must fit */
+};
+#define REQ_LEN_NOMAC (sizeof(struct req_pkt))
+
+/*
+ * A response packet.  The length here is variable, this is a
+ * maximally sized one.  Note that this implementation doesn't
+ * authenticate responses.
+ */
+#define	RESP_HEADER_SIZE	(8)
+#define	RESP_DATA_SIZE		(500)
+
+struct resp_pkt
+{
+	uint8_t  rm_vn_mode;           /* response, more, version, mode */
+	uint8_t  auth_seq;             /* key, sequence number */
+	uint8_t  implementation;       /* implementation number */
+	uint8_t  request;              /* request number */
+	uint16_t err_nitems;           /* error code/number of data items */
+	uint16_t mbz_itemsize;         /* item size */
+	char     data[RESP_DATA_SIZE]; /* data area */
+};
+
+/*
+ * Bit setting macros for multifield items.
+ */
+#define	RESP_BIT	0x80
+#define	MORE_BIT	0x40
+
+#define	ISRESPONSE(rm_vn_mode)	(((rm_vn_mode)&RESP_BIT)!=0)
+#define	ISMORE(rm_vn_mode)	(((rm_vn_mode)&MORE_BIT)!=0)
+#define INFO_VERSION(rm_vn_mode) ((u_char)(((rm_vn_mode)>>3)&0x7))
+#define	INFO_MODE(rm_vn_mode)	((rm_vn_mode)&0x7)
+
+#define	RM_VN_MODE(resp, more, version)		\
+				((u_char)(((resp)?RESP_BIT:0)\
+				|((more)?MORE_BIT:0)\
+				|((version?version:(NTP_OLDVERSION+1))<<3)\
+				|(MODE_PRIVATE)))
+
+#define	INFO_IS_AUTH(auth_seq)	(((auth_seq) & 0x80) != 0)
+#define	INFO_SEQ(auth_seq)	((auth_seq)&0x7f)
+#define	AUTH_SEQ(auth, seq)	((u_char)((((auth)!=0)?0x80:0)|((seq)&0x7f)))
+
+#define	INFO_ERR(err_nitems)	((u_short)((ntohs(err_nitems)>>12)&0xf))
+#define	INFO_NITEMS(err_nitems)	((u_short)(ntohs(err_nitems)&0xfff))
+#define	ERR_NITEMS(err, nitems)	(htons((u_short)((((u_short)(err)<<12)&0xf000)\
+				|((u_short)(nitems)&0xfff))))
+
+#define	INFO_MBZ(mbz_itemsize)	((ntohs(mbz_itemsize)>>12)&0xf)
+#define	INFO_ITEMSIZE(mbz_itemsize)	((u_short)(ntohs(mbz_itemsize)&0xfff))
+#define	MBZ_ITEMSIZE(itemsize)	(htons((u_short)(itemsize)))
+
+/* negate a long float type */
+#define M_NEG(v_i, v_f) \
+	do { \
+		if ((v_f) == 0) \
+		(v_i) = -((uint32_t)(v_i)); \
+		else { \
+			(v_f) = -((uint32_t)(v_f)); \
+			(v_i) = ~(v_i); \
+		} \
+	} while(0)
+/* l_fp to double */
+#define M_LFPTOD(r_i, r_uf, d) \
+	do { \
+		register int32_t  i; \
+		register uint32_t f; \
+		\
+		i = (r_i); \
+		f = (r_uf); \
+		if (i < 0) { \
+			M_NEG(i, f); \
+			(d) = -((double) i + ((double) f) / 4294967296.0); \
+		} else { \
+			(d) = (double) i + ((double) f) / 4294967296.0; \
+		} \
+	} while (0)
+
+#define REQ_PEER_LIST_SUM 1
+struct info_peer_summary
+{
+	uint32_t dstadr;         /* local address (zero for undetermined) */
+	uint32_t srcadr;         /* source address */
+	uint16_t srcport;        /* source port */
+	uint8_t stratum;         /* stratum of peer */
+	int8_t hpoll;            /* host polling interval */
+	int8_t ppoll;            /* peer polling interval */
+	uint8_t reach;           /* reachability register */
+	uint8_t flags;           /* flags, from above */
+	uint8_t hmode;           /* peer mode */
+	int32_t  delay;          /* peer.estdelay; s_fp */
+	int32_t  offset_int;     /* peer.estoffset; integral part */
+	int32_t  offset_frc;     /* peer.estoffset; fractional part */
+	uint32_t dispersion;     /* peer.estdisp; u_fp */
+	uint32_t v6_flag;        /* is this v6 or not */
+	uint32_t unused1;        /* (unused) padding for dstadr6 */
+	struct in6_addr dstadr6; /* local address (v6) */
+	struct in6_addr srcadr6; /* source address (v6) */
+};
+
+#define REQ_SYS_INFO 4
+struct info_sys
+{
+	uint32_t peer;           /* system peer address (v4) */
+	uint8_t  peer_mode;      /* mode we are syncing to peer in */
+	uint8_t  leap;           /* system leap bits */
+	uint8_t  stratum;        /* our stratum */
+	int8_t   precision;      /* local clock precision */
+	int32_t  rootdelay;      /* distance from sync source */
+	uint32_t rootdispersion; /* dispersion from sync source */
+	uint32_t refid;          /* reference ID of sync source */
+	uint64_t reftime;        /* system reference time */
+	uint32_t poll;           /* system poll interval */
+	uint8_t  flags;          /* system flags */
+	uint8_t  unused1;        /* unused */
+	uint8_t  unused2;        /* unused */
+	uint8_t  unused3;        /* unused */
+	int32_t  bdelay;         /* default broadcast offset */
+	int32_t  frequency;      /* frequency residual (scaled ppm)  */
+	uint64_t authdelay;      /* default authentication delay */
+	uint32_t stability;      /* clock stability (scaled ppm) */
+	int32_t  v6_flag;        /* is this v6 or not */
+	int32_t  unused4;        /* unused, padding for peer6 */
+	struct in6_addr peer6;   /* system peer address (v6) */
+};
+
+#define REQ_GET_KERNEL 38
+struct info_kernel
+{
+	int32_t  offset;
+	int32_t  freq;
+	int32_t  maxerror;
+	int32_t  esterror;
+	uint16_t status;
+	uint16_t shift;
+	int32_t  constant;
+	int32_t  precision;
+	int32_t  tolerance;
+	/* pps stuff */
+	int32_t  ppsfreq;
+	int32_t  jitter;
+	int32_t  stabil;
+	int32_t  jitcnt;
+	int32_t  calcnt;
+	int32_t  errcnt;
+	int32_t  stbcnt;
+};
+
+/* List of reference clock names */
+static char *refclock_names[] =
+{
+	"UNKNOWN",    "LOCAL",        "GPS_TRAK",   "WWV_PST",     /*  0- 3 */
+	"SPECTRACOM", "TRUETIME",     "IRIG_AUDIO", "CHU_AUDIO",   /*  4- 7 */
+	"GENERIC",    "GPS_MX4200",   "GPS_AS2201", "GPS_ARBITER", /*  8-11 */
+	"IRIG_TPRO",  "ATOM_LEITCH",  "MSF_EES",    "GPSTM_TRUE",  /* 12-15 */
+	"GPS_BANC",   "GPS_DATUM",    "ACTS_NIST",  "WWV_HEATH",   /* 16-19 */
+	"GPS_NMEA",   "GPS_VME",      "PPS",        "ACTS_PTB",    /* 20-23 */
+	"ACTS_USNO",  "TRUETIME",     "GPS_HP",     "MSF_ARCRON",  /* 24-27 */
+	"SHM",        "GPS_PALISADE", "GPS_ONCORE", "GPS_JUPITER", /* 28-31 */
+	"CHRONOLOG",  "DUMBCLOCK",    "ULINK_M320", "PCF",         /* 32-35 */
+	"WWV_AUDIO",  "GPS_FG",       "HOPF_S",     "HOPF_P",      /* 36-39 */
+	"JJY",        "TT_IRIG",      "GPS_ZYFER",  "GPS_RIPENCC", /* 40-43 */
+	"NEOCLK4X",   NULL                                         /* 44    */
+};
+static int refclock_names_num = 45;
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * End of the copied stuff..                                         *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+static int ntpd_config (char *key, char *value)
+{
+	if (strcasecmp (key, "host") == 0)
+	{
+		if (ntpd_host != NULL)
+			free (ntpd_host);
+		if ((ntpd_host = strdup (value)) == NULL)
+			return (1);
+	}
+	else if (strcasecmp (key, "port") == 0)
+	{
+		if (ntpd_port != NULL)
+			free (ntpd_port);
+		if ((ntpd_port = strdup (value)) == NULL)
+			return (1);
+	}
+	else
+	{
+		return (-1);
+	}
+
+	return (0);
+}
+
+static void ntpd_init (void)
+{
+	return;
+}
+
+static void ntpd_write_sec (char *host, char *inst, char *val, char *file)
+{
+	char buf[256];
+	int  status;
+
+	status = snprintf (buf, 256, file, inst);
+	if ((status < 1) || (status >= 256))
+		return;
+
+	rrd_update_file (host, buf, val,
+			sec_ds_def, sec_ds_num);
+}
+
+static void ntpd_write_time_offset (char *host, char *inst, char *val)
+{
+	ntpd_write_sec (host, inst, val, time_offset_file);
+}
+
+static void ntpd_write_time_dispersion (char *host, char *inst, char *val)
+{
+	ntpd_write_sec (host, inst, val, time_dispersion_file);
+}
+
+static void ntpd_write_delay (char *host, char *inst, char *val)
+{
+	ntpd_write_sec (host, inst, val, time_delay_file);
+}
+
+static void ntpd_write_frequency_offset (char *host, char *inst, char *val)
+{
+	char buf[256];
+	int  status;
+
+	status = snprintf (buf, 256, frequency_offset_file, inst);
+	if ((status < 1) || (status >= 256))
+		return;
+
+	rrd_update_file (host, buf, val,
+			frequency_offset_ds_def, frequency_offset_ds_num);
+}
+
+#if NTPD_HAVE_READ
+static void ntpd_submit (char *type, char *inst, double value)
+{
+	char buf[256];
+
+	if (snprintf (buf, 256, "%u:%.8f", (unsigned int) curtime, value) >= 256)
+		return;
+
+	DBG ("type = %s; inst = %s; value = %s;",
+			type, inst, buf);
+
+	plugin_submit (type, inst, buf);
+}
+
+/* returns `tv0 - tv1' in milliseconds or 0 if `tv1 > tv0' */
+static int timeval_sub (const struct timeval *tv0, const struct timeval *tv1)
+{
+	int sec;
+	int usec;
+
+	if ((tv0->tv_sec < tv1->tv_sec)
+			|| ((tv0->tv_sec == tv1->tv_sec) && (tv0->tv_usec < tv1->tv_usec)))
+		return (0);
+
+	sec  = tv0->tv_sec  - tv1->tv_sec;
+	usec = tv0->tv_usec - tv1->tv_usec;
+
+	while (usec < 0)
+	{
+		usec += 1000000;
+		sec  -= 1;
+	}
+
+	if (sec < 0)
+		return (0);
+
+	return ((sec * 1000) + ((usec + 500) / 1000));
+}
+
+static int ntpd_connect (void)
+{
+	char *host;
+	char *port;
+
+	struct addrinfo  ai_hints;
+	struct addrinfo *ai_list;
+	struct addrinfo *ai_ptr;
+	int              status;
+
+	if (sock_descr >= 0)
+		return (sock_descr);
+
+	DBG ("Opening a new socket");
+
+	host = ntpd_host;
+	if (host == NULL)
+		host = NTPD_DEFAULT_HOST;
+
+	port = ntpd_port;
+	if (port == NULL)
+		port = NTPD_DEFAULT_PORT;
+
+	memset (&ai_hints, '\0', sizeof (ai_hints));
+	ai_hints.ai_flags    = AI_ADDRCONFIG;
+	ai_hints.ai_family   = PF_UNSPEC;
+	ai_hints.ai_socktype = SOCK_DGRAM;
+	ai_hints.ai_protocol = IPPROTO_UDP;
+
+	if ((status = getaddrinfo (host, port, &ai_hints, &ai_list)) != 0)
+	{
+		DBG ("getaddrinfo (%s, %s): %s",
+				host, port,
+				status == EAI_SYSTEM ? strerror (errno) : gai_strerror (status));
+		syslog (LOG_ERR, "ntpd plugin: getaddrinfo (%s, %s): %s",
+				host, port,
+				status == EAI_SYSTEM ? strerror (errno) : gai_strerror (status));
+		return (-1);
+	}
+
+	for (ai_ptr = ai_list; ai_ptr != NULL; ai_ptr = ai_ptr->ai_next)
+	{
+		/* create our socket descriptor */
+		if ((sock_descr = socket (ai_ptr->ai_family,
+						ai_ptr->ai_socktype,
+						ai_ptr->ai_protocol)) < 0)
+			continue;
+
+		/* connect to the ntpd */
+		if (connect (sock_descr, ai_ptr->ai_addr, ai_ptr->ai_addrlen))
+		{
+			close (sock_descr);
+			sock_descr = -1;
+			continue;
+		}
+
+		break;
+	}
+
+	freeaddrinfo (ai_list);
+
+	if (sock_descr < 0)
+	{
+		DBG ("Unable to connect to server.");
+		syslog (LOG_ERR, "ntpd plugin: Unable to connect to server.");
+	}
+
+	return (sock_descr);
+}
+
+/* For a description of the arguments see `ntpd_do_query' below. */
+static int ntpd_receive_response (int req_code, int *res_items, int *res_size,
+		char **res_data, int res_item_size)
+{
+	int              sd;
+	struct pollfd    poll_s;
+	struct resp_pkt  res;
+	int              status;
+	int              done;
+	int              i;
+
+	char            *items;
+	size_t           items_num;
+
+	struct timeval   time_end;
+	struct timeval   time_now;
+	int              timeout;
+
+	int              pkt_item_num;        /* items in this packet */
+	int              pkt_item_len;        /* size of the items in this packet */
+	int              pkt_sequence;
+	char             pkt_recvd[MAXSEQ+1]; /* sequence numbers that have been received */
+	int              pkt_recvd_num;       /* number of packets that have been received */
+	int              pkt_lastseq;         /* the last sequence number */
+	ssize_t          pkt_padding;         /* Padding in this packet */
+
+	if ((sd = ntpd_connect ()) < 0)
+		return (-1);
+
+	items = NULL;
+	items_num = 0;
+
+	memset (pkt_recvd, '\0', sizeof (pkt_recvd));
+	pkt_recvd_num = 0;
+	pkt_lastseq   = -1;
+
+	*res_items = 0;
+	*res_size  = 0;
+	*res_data  = NULL;
+
+	if (gettimeofday (&time_end, NULL) < 0)
+	{
+		syslog (LOG_ERR, "ntpd plugin: gettimeofday failed: %s",
+				strerror (errno));
+		return (-1);
+	}
+	time_end.tv_sec++; /* wait for a most one second */
+
+	done = 0;
+	while (done == 0)
+	{
+		if (gettimeofday (&time_now, NULL) < 0)
+		{
+			syslog (LOG_ERR, "ntpd plugin: gettimeofday failed: %s",
+					strerror (errno));
+			return (-1);
+		}
+
+		/* timeout reached */
+		if ((timeout = timeval_sub (&time_end, &time_now)) == 0)
+			break;
+
+		poll_s.fd      = sd;
+		poll_s.events  = POLLIN | POLLPRI;
+		poll_s.revents = 0;
+		
+		DBG ("Polling for %ims", timeout);
+		status = poll (&poll_s, 1, timeout);
+
+		if ((status < 0) && ((errno == EAGAIN) || (errno == EINTR)))
+			continue;
+
+		if (status < 0)
+		{
+			DBG ("poll failed: %s", strerror (errno));
+			syslog (LOG_ERR, "ntpd plugin: poll failed: %s",
+					strerror (errno));
+			return (-1);
+		}
+
+		if (status == 0) /* timeout */
+		{
+			DBG ("timeout reached.");
+			break;
+		}
+
+		memset ((void *) &res, '\0', sizeof (res));
+		status = recv (sd, (void *) &res, sizeof (res), 0 /* no flags */);
+
+		if ((status < 0) && ((errno == EAGAIN) || (errno == EINTR)))
+			continue;
+
+		if (status < 0)
+		{
+			DBG ("recv(2) failed: %s", strerror (errno));
+			DBG ("Closing socket #%i", sd);
+			close (sd);
+			sock_descr = sd = -1;
+			return (-1);
+		}
+
+		DBG ("recv'd %i bytes", status);
+
+		/* 
+		 * Do some sanity checks first
+		 */
+		if (status < RESP_HEADER_SIZE)
+		{
+			syslog (LOG_WARNING, "ntpd plugin: Short (%i bytes) packet received",
+					(int) status);
+			continue;
+		}
+		if (INFO_MODE (res.rm_vn_mode) != MODE_PRIVATE)
+		{
+			syslog (LOG_NOTICE, "ntpd plugin: Packet received with mode %i",
+					INFO_MODE (res.rm_vn_mode));
+			continue;
+		}
+		if (INFO_IS_AUTH (res.auth_seq))
+		{
+			syslog (LOG_NOTICE, "ntpd plugin: Encrypted packet received");
+			continue;
+		}
+		if (!ISRESPONSE (res.rm_vn_mode))
+		{
+			syslog (LOG_NOTICE, "ntpd plugin: Received request packet, "
+					"wanted response");
+			continue;
+		}
+		if (INFO_MBZ (res.mbz_itemsize))
+		{
+			syslog (LOG_WARNING, "ntpd plugin: Received packet with nonzero "
+					"MBZ field!");
+			continue;
+		}
+		if (res.implementation != IMPL_XNTPD)
+		{
+			syslog (LOG_WARNING, "ntpd plugin: Asked for request of type %i, "
+					"got %i", (int) IMPL_XNTPD, (int) res.implementation);
+			continue;
+		}
+
+		/* Check for error code */
+		if (INFO_ERR (res.err_nitems) != 0)
+		{
+			syslog (LOG_ERR, "ntpd plugin: Received error code %i",
+					(int) INFO_ERR(res.err_nitems));
+			return ((int) INFO_ERR (res.err_nitems));
+		}
+
+		/* extract number of items in this packet and the size of these items */
+		pkt_item_num = INFO_NITEMS (res.err_nitems);
+		pkt_item_len = INFO_ITEMSIZE (res.mbz_itemsize);
+		DBG ("pkt_item_num = %i; pkt_item_len = %i;",
+				pkt_item_num, pkt_item_len);
+
+		/* Check if the reported items fit in the packet */
+		if ((pkt_item_num * pkt_item_len) > (status - RESP_HEADER_SIZE))
+		{
+			syslog (LOG_ERR, "ntpd plugin: %i items * %i bytes > "
+					"%i bytes - %i bytes header",
+					(int) pkt_item_num, (int) pkt_item_len,
+					(int) status, (int) RESP_HEADER_SIZE);
+			continue;
+		}
+
+		/* If this is the first packet (time wise, not sequence wise),
+		 * set `res_size'. If it's not the first packet check if the
+		 * items have the same size. Discard invalid packets. */
+		if (items_num == 0) /* first packet */
+		{
+			DBG ("*res_size = %i", pkt_item_len);
+			*res_size = pkt_item_len;
+		}
+		else if (*res_size != pkt_item_len)
+		{
+			DBG ("Error: *res_size = %i; pkt_item_len = %i;",
+					*res_size, pkt_item_len);
+			syslog (LOG_ERR, "Item sizes differ.");
+			continue;
+		}
+
+		/* Calculate the padding. No idea why there might be any padding.. */
+		pkt_padding = 0;
+		if (res_item_size > pkt_item_len)
+			pkt_padding = res_item_size - pkt_item_len;
+		DBG ("res_item_size = %i; pkt_padding = %i;",
+				res_item_size, pkt_padding);
+
+		/* Extract the sequence number */
+		pkt_sequence = INFO_SEQ (res.auth_seq);
+		if ((pkt_sequence < 0) || (pkt_sequence > MAXSEQ))
+		{
+			syslog (LOG_ERR, "ntpd plugin: Received packet with sequence %i",
+					pkt_sequence);
+			continue;
+		}
+
+		/* Check if this sequence has been received before. If so, discard it. */
+		if (pkt_recvd[pkt_sequence] != '\0')
+		{
+			syslog (LOG_NOTICE, "ntpd plugin: Sequence %i received twice",
+					pkt_sequence);
+			continue;
+		}
+
+		/* If `pkt_lastseq != -1' another packet without `more bit' has
+		 * been received. */
+		if (!ISMORE (res.rm_vn_mode))
+		{
+			if (pkt_lastseq != -1)
+			{
+				syslog (LOG_ERR, "ntpd plugin: Two packets which both "
+						"claim to be the last one in the "
+						"sequence have been received.");
+				continue;
+			}
+			pkt_lastseq = pkt_sequence;
+			DBG ("Last sequence = %i;", pkt_lastseq);
+		}
+
+		/*
+		 * Enough with the checks. Copy the data now.
+		 * We start by allocating some more memory.
+		 */
+		DBG ("realloc (%p, %i)", (void *) *res_data,
+				(items_num + pkt_item_num) * res_item_size);
+		items = realloc ((void *) *res_data,
+				(items_num + pkt_item_num) * res_item_size);
+		if (items == NULL)
+		{
+			items = *res_data;
+			syslog (LOG_ERR, "ntpd plugin: realloc failed.");
+			continue;
+		}
+		*res_data = items;
+
+		for (i = 0; i < pkt_item_num; i++)
+		{
+			void *dst = (void *) (*res_data + ((*res_items) * res_item_size));
+			void *src = (void *) (((char *) res.data) + (i * pkt_item_len));
+
+			/* Set the padding to zeros */
+			if (pkt_padding != 0)
+				memset (dst, '\0', res_item_size);
+			memcpy (dst, src, (size_t) pkt_item_len);
+
+			(*res_items)++;
+		}
+
+		pkt_recvd[pkt_sequence] = (char) 1;
+		pkt_recvd_num++;
+
+		if ((pkt_recvd_num - 1) == pkt_lastseq)
+			done = 1;
+	} /* while (done == 0) */
+
+	return (0);
+}
+
+/* For a description of the arguments see `ntpd_do_query' below. */
+static int ntpd_send_request (int req_code, int req_items, int req_size, char *req_data)
+{
+	int             sd;
+	struct req_pkt  req;
+	size_t          req_data_len;
+	int             status;
+
+	assert (req_items >= 0);
+	assert (req_size  >= 0);
+
+	if ((sd = ntpd_connect ()) < 0)
+		return (-1);
+
+	memset ((void *) &req, '\0', sizeof (req));
+	req.rm_vn_mode = RM_VN_MODE(0, 0, 0);
+	req.auth_seq   = AUTH_SEQ (0, 0);
+	req.implementation = IMPL_XNTPD;
+	req.request = (unsigned char) req_code;
+
+	req_data_len = (size_t) (req_items * req_size);
+
+	assert (((req_data != NULL) && (req_data_len > 0))
+			|| ((req_data == NULL) && (req_items == 0) && (req_size == 0)));
+
+	req.err_nitems   = ERR_NITEMS (0, req_items);
+	req.mbz_itemsize = MBZ_ITEMSIZE (req_size);
+	
+	if (req_data != NULL)
+		memcpy ((void *) req.data, (const void *) req_data, req_data_len);
+
+	DBG ("req_items = %i; req_size = %i; req_data = %p;",
+			req_items, req_size, (void *) req_data);
+
+	status = swrite (sd, (const char *) &req, REQ_LEN_NOMAC);
+	if (status < 0)
+	{
+		DBG ("`swrite' failed. Closing socket #%i", sd);
+		close (sd);
+		sock_descr = sd = -1;
+		return (status);
+	}
+
+	return (0);
+}
+
+/*
+ * ntpd_do_query:
+ *
+ * req_code:      Type of request packet
+ * req_items:     Numver of items in the request
+ * req_size:      Size of one item in the request
+ * req_data:      Data of the request packet
+ * res_items:     Pointer to where the number returned items will be stored.
+ * res_size:      Pointer to where the size of one returned item will be stored.
+ * res_data:      This is where a pointer to the (allocated) data will be stored.
+ * res_item_size: Size of one returned item. (used to calculate padding)
+ *
+ * returns:       zero upon success, non-zero otherwise.
+ */
+static int ntpd_do_query (int req_code, int req_items, int req_size, char *req_data,
+		int *res_items, int *res_size, char **res_data, int res_item_size)
+{
+	int status;
+
+	status = ntpd_send_request (req_code, req_items, req_size, req_data);
+	if (status != 0)
+		return (status);
+
+	status = ntpd_receive_response (req_code, res_items, res_size, res_data,
+			res_item_size);
+	return (status);
+}
+
+static double ntpd_read_fp (int32_t val_int)
+{
+	double val_double;
+
+	val_int = ntohl (val_int);
+	val_double = ((double) val_int) / FP_FRAC;
+
+	return (val_double);
+}
+
+static void ntpd_read (void)
+{
+	struct info_kernel *ik;
+	int                 ik_num;
+	int                 ik_size;
+
+	struct info_peer_summary *ps;
+	int                       ps_num;
+	int                       ps_size;
+
+	int status;
+	int i;
+
+	ik      = NULL;
+	ik_num  = 0;
+	ik_size = 0;
+
+	status = ntpd_do_query (REQ_GET_KERNEL,
+			0, 0, NULL, /* request data */
+			&ik_num, &ik_size, (char **) ((void *) &ik), /* response data */
+			sizeof (struct info_kernel));
+
+	if (status != 0)
+	{
+		DBG ("ntpd_do_query failed with status %i", status);
+		return;
+	}
+	if ((ik == NULL) || (ik_num == 0) || (ik_size == 0))
+	{
+		DBG ("ntpd_do_query returned: ik = %p; ik_num = %i; ik_size = %i;",
+				(void *) ik, ik_num, ik_size);
+		return;
+	}
+
+	/* kerninfo -> estimated error */
+
+	DBG ("info_kernel:\n"
+			"  pll offset    = %.8f\n"
+			"  pll frequency = %.8f\n" /* drift compensation */
+			"  est error     = %.8f\n",
+			ntpd_read_fp (ik->offset),
+			ntpd_read_fp (ik->freq),
+			ntpd_read_fp (ik->esterror));
+
+	ntpd_submit ("ntpd_frequency_offset", "loop",  ntpd_read_fp (ik->freq));
+	ntpd_submit ("ntpd_time_offset",      "loop",  ntpd_read_fp (ik->offset));
+	ntpd_submit ("ntpd_time_offset",      "error", ntpd_read_fp (ik->esterror));
+
+	free (ik);
+	ik = NULL;
+
+	status = ntpd_do_query (REQ_PEER_LIST_SUM,
+			0, 0, NULL, /* request data */
+			&ps_num, &ps_size, (char **) ((void *) &ps), /* response data */
+			sizeof (struct info_peer_summary));
+	if (status != 0)
+	{
+		DBG ("ntpd_do_query failed with status %i", status);
+		return;
+	}
+	if ((ps == NULL) || (ps_num == 0) || (ps_size == 0))
+	{
+		DBG ("ntpd_do_query returned: ps = %p; ps_num = %i; ps_size = %i;",
+				(void *) ps, ps_num, ps_size);
+		return;
+	}
+
+	for (i = 0; i < ps_num; i++)
+	{
+		struct info_peer_summary *ptr;
+		double offset;
+
+		char peername[512];
+		int refclock_id;
+		
+		ptr = ps + i;
+		refclock_id = 0;
+
+		/*
+		if (((ntohl (ptr->dstadr) & 0xFFFFFF00) == 0x7F000000) || (ptr->dstadr == 0))
+			continue;
+			*/
+
+		/* Convert the `long floating point' offset value to double */
+		M_LFPTOD (ntohl (ptr->offset_int), ntohl (ptr->offset_frc), offset);
+
+		if (ptr->v6_flag)
+		{
+			status = getnameinfo ((const struct sockaddr *) &ptr->srcadr6,
+					sizeof (ptr->srcadr6),
+					peername, sizeof (peername),
+					NULL, 0, 0 /* no flags */);
+			if (status != 0)
+			{
+				syslog (LOG_ERR, "ntpd plugin: getnameinfo failed: %s",
+						status == EAI_SYSTEM
+						? strerror (errno)
+						: gai_strerror (status));
+				continue;
+			}
+		}
+		else if ((ntohl (ptr->srcadr) & REFCLOCK_MASK) == REFCLOCK_ADDR)
+		{
+			struct in_addr  addr_obj;
+			char *addr_str;
+
+			refclock_id = (ntohl (ptr->srcadr) >> 8) & 0x000000FF;
+
+			if (refclock_id < refclock_names_num)
+			{
+				strncpy (peername, refclock_names[refclock_id],
+						sizeof (peername));
+			}
+			else
+			{
+				memset ((void *) &addr_obj, '\0', sizeof (addr_obj));
+				addr_obj.s_addr = ptr->srcadr;
+				addr_str = inet_ntoa (addr_obj);
+
+				strncpy (peername, addr_str, sizeof (peername));
+			}
+		}
+		else /* IPv4 */
+		{
+			struct in_addr  addr_obj;
+			struct hostent *addr_he;
+			char           *addr_str;
+
+			memset ((void *) &addr_obj, '\0', sizeof (addr_obj));
+			addr_obj.s_addr = ptr->srcadr;
+			addr_str = inet_ntoa (addr_obj);
+
+			addr_he = gethostbyaddr ((const void *) &addr_obj,
+					sizeof (addr_obj), AF_INET);
+			if (addr_he != NULL)
+			{
+				strncpy (peername, addr_he->h_name, sizeof (peername));
+			}
+			else
+			{
+				strncpy (peername, addr_str, sizeof (peername));
+			}
+		}
+
+		DBG ("peer %i:\n"
+				"  peername   = %s\n"
+				"  srcadr     = 0x%08x\n"
+				"  delay      = %f\n"
+				"  offset_int = %i\n"
+				"  offset_frc = %i\n"
+				"  offset     = %f\n"
+				"  dispersion = %f\n",
+				i,
+				peername,
+				ntohl (ptr->srcadr),
+				ntpd_read_fp (ptr->delay),
+				ntohl (ptr->offset_int),
+				ntohl (ptr->offset_frc),
+				offset,
+				ntpd_read_fp (ptr->dispersion));
+
+		if (refclock_id != 1) /* not the system clock (offset will always be zero.. */
+			ntpd_submit ("ntpd_time_offset", peername, offset);
+		ntpd_submit ("ntpd_time_dispersion", peername, ntpd_read_fp (ptr->dispersion));
+		if (refclock_id == 0) /* not a reference clock */
+			ntpd_submit ("ntpd_delay", peername, ntpd_read_fp (ptr->delay));
+	}
+
+	free (ps);
+	ps = NULL;
+
+	return;
+}
+#else
+# define ntpd_read NULL
+#endif /* NTPD_HAVE_READ */
+
+void module_register (void)
+{
+	plugin_register (MODULE_NAME, ntpd_init, ntpd_read, NULL);
+	plugin_register ("ntpd_time_offset", NULL, NULL, ntpd_write_time_offset);
+	plugin_register ("ntpd_time_dispersion", NULL, NULL, ntpd_write_time_dispersion);
+	plugin_register ("ntpd_delay", NULL, NULL, ntpd_write_delay);
+	plugin_register ("ntpd_frequency_offset", NULL, NULL, ntpd_write_frequency_offset);
+	cf_register (MODULE_NAME, ntpd_config, config_keys, config_keys_num);
+}
+
+#undef MODULE_NAME