@@ -14,7 +14,7 @@
 @SET_MAKE@
 
 #
-# $Id: Makefile.in,v 1.25 2002/09/15 05:41:26 robertc Exp $
+# $Id: Makefile.in,v 1.26 2002/09/15 06:40:27 robertc Exp $
 #
 
 SHELL = @SHELL@
@@ -73,6 +73,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -3,15 +3,15 @@ dnl  Configuration input file for Squid
 dnl
 dnl  Duane Wessels, wessels@nlanr.net, February 1996 (autoconf v2.9)
 dnl
-dnl  $Id: configure.in,v 1.282 2002/09/01 15:13:08 hno Exp $
+dnl  $Id: configure.in,v 1.283 2002/09/15 06:40:28 robertc Exp $
 dnl
 dnl
 dnl
 AC_INIT(src/main.c)
 AC_CONFIG_AUX_DIR(cfgaux)
 AM_INIT_AUTOMAKE(squid, 2.6-DEVEL)
 AM_CONFIG_HEADER(include/autoconf.h)
-AC_REVISION($Revision: 1.282 $)dnl
+AC_REVISION($Revision: 1.283 $)dnl
 AC_PREFIX_DEFAULT(/usr/local/squid)
 AM_MAINTAINER_MODE
 
@@ -24,6 +24,8 @@ PRESET_CFLAGS="$CFLAGS"
 
 dnl Check for GNU cc
 AC_PROG_CC
+AC_LANG_CPLUSPLUS
+AC_PROG_CXX
 AM_PROG_CC_C_O
 AC_CANONICAL_HOST
 
@@ -74,6 +74,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -16,7 +16,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.10 2002/09/15 05:41:27 robertc Exp $
+#  $Id: Makefile.in,v 1.11 2002/09/15 06:40:29 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -77,6 +77,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -14,7 +14,7 @@
 @SET_MAKE@
 
 #
-# $Id: Makefile.in,v 1.25 2002/09/15 05:41:29 robertc Exp $
+# $Id: Makefile.in,v 1.26 2002/09/15 06:40:29 robertc Exp $
 #
 
 SHELL = @SHELL@
@@ -73,6 +73,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -69,6 +69,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -16,7 +16,7 @@
 #
 #  Makefile for the Squid LDAP authentication helper
 #
-#  $Id: Makefile.in,v 1.19 2002/09/15 05:41:30 robertc Exp $
+#  $Id: Makefile.in,v 1.20 2002/09/15 06:40:31 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -77,6 +77,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -16,7 +16,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.22 2002/09/15 05:41:31 robertc Exp $
+#  $Id: Makefile.in,v 1.23 2002/09/15 06:40:32 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -77,6 +77,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -15,7 +15,7 @@
 
 #  Makefile for storage modules in the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.17 2002/09/15 05:41:30 robertc Exp $
+#  $Id: Makefile.in,v 1.18 2002/09/15 06:40:31 robertc Exp $
 #
 
 SHELL = @SHELL@
@@ -74,6 +74,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -16,7 +16,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.17 2002/09/15 05:41:32 robertc Exp $
+#  $Id: Makefile.in,v 1.18 2002/09/15 06:40:33 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -77,6 +77,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -16,7 +16,7 @@
 #
 #  Makefile for the Squid PAM authentication helper
 #
-#  $Id: Makefile.in,v 1.18 2002/09/15 05:41:34 robertc Exp $
+#  $Id: Makefile.in,v 1.19 2002/09/15 06:40:34 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -77,6 +77,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -16,7 +16,7 @@
 #
 #  Makefile for the Squid SASL authentication helper
 #
-#  $Id: Makefile.in,v 1.15 2002/09/15 05:41:35 robertc Exp $
+#  $Id: Makefile.in,v 1.16 2002/09/15 06:40:35 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -77,6 +77,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -16,7 +16,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.18 2002/09/15 05:41:36 robertc Exp $
+#  $Id: Makefile.in,v 1.19 2002/09/15 06:40:36 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -82,6 +82,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -16,7 +16,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.19 2002/09/15 05:41:37 robertc Exp $
+#  $Id: Makefile.in,v 1.20 2002/09/15 06:40:37 robertc Exp $
 #
 #
 
@@ -76,6 +76,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -16,7 +16,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.17 2002/09/15 05:41:39 robertc Exp $
+#  $Id: Makefile.in,v 1.18 2002/09/15 06:40:37 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -77,6 +77,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -16,7 +16,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.15 2002/09/15 05:41:40 robertc Exp $
+#  $Id: Makefile.in,v 1.16 2002/09/15 06:40:38 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -77,6 +77,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -16,7 +16,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.9 2002/09/15 05:41:41 robertc Exp $
+#  $Id: Makefile.in,v 1.10 2002/09/15 06:40:39 robertc Exp $
 #
 
 SHELL = @SHELL@
@@ -75,6 +75,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -15,7 +15,7 @@
 
 #  Makefile for digest auth helpers in the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.14 2002/09/15 05:41:42 robertc Exp $
+#  $Id: Makefile.in,v 1.15 2002/09/15 06:40:40 robertc Exp $
 #
 
 SHELL = @SHELL@
@@ -74,6 +74,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -16,7 +16,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.16 2002/09/15 05:41:42 robertc Exp $
+#  $Id: Makefile.in,v 1.17 2002/09/15 06:40:41 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -77,6 +77,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -15,7 +15,7 @@
 
 #  Makefile for storage modules in the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.4 2002/09/15 05:41:43 robertc Exp $
+#  $Id: Makefile.in,v 1.5 2002/09/15 06:40:42 robertc Exp $
 #
 
 SHELL = @SHELL@
@@ -74,6 +74,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -16,7 +16,7 @@
 #
 #  Makefile for the ip_user external_acl helper by Rodrigo Campos
 #
-#  $Id: Makefile.in,v 1.4 2002/09/15 05:41:44 robertc Exp $
+#  $Id: Makefile.in,v 1.5 2002/09/15 06:40:43 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -77,6 +77,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -16,7 +16,7 @@
 #
 #  Makefile for the Squid LDAP authentication helper
 #
-#  $Id: Makefile.in,v 1.4 2002/09/15 05:41:45 robertc Exp $
+#  $Id: Makefile.in,v 1.5 2002/09/15 06:40:44 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -77,6 +77,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -16,7 +16,7 @@
 #
 #  Makefile for the Squid LDAP authentication helper
 #
-#  $Id: Makefile.in,v 1.4 2002/09/15 05:41:45 robertc Exp $
+#  $Id: Makefile.in,v 1.5 2002/09/15 06:40:44 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -77,6 +77,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -16,7 +16,7 @@
 #
 #  Makefile for the Squid LDAP authentication helper
 #
-#  $Id: Makefile.in,v 1.3 2002/09/15 05:41:46 robertc Exp $
+#  $Id: Makefile.in,v 1.4 2002/09/15 06:40:45 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -77,6 +77,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -16,7 +16,7 @@
 #
 #  Makefile for the wb_group external_acl helper
 #
-#  $Id: Makefile.in,v 1.4 2002/09/15 05:41:47 robertc Exp $
+#  $Id: Makefile.in,v 1.5 2002/09/15 06:40:46 robertc Exp $
 #
 
 SHELL = @SHELL@
@@ -75,6 +75,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -15,7 +15,7 @@
 
 #  Makefile for storage modules in the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.17 2002/09/15 05:41:48 robertc Exp $
+#  $Id: Makefile.in,v 1.18 2002/09/15 06:40:47 robertc Exp $
 #
 
 SHELL = @SHELL@
@@ -74,6 +74,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -16,7 +16,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.17 2002/09/15 05:41:49 robertc Exp $
+#  $Id: Makefile.in,v 1.18 2002/09/15 06:40:47 robertc Exp $
 #
 
 SHELL = @SHELL@
@@ -75,6 +75,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -71,6 +71,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -16,7 +16,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.16 2002/09/15 05:41:50 robertc Exp $
+#  $Id: Makefile.in,v 1.17 2002/09/15 06:40:49 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -77,6 +77,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -16,7 +16,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.18 2002/09/15 05:41:51 robertc Exp $
+#  $Id: Makefile.in,v 1.19 2002/09/15 06:40:50 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -77,6 +77,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -16,7 +16,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.9 2002/09/15 05:41:53 robertc Exp $
+#  $Id: Makefile.in,v 1.10 2002/09/15 06:40:51 robertc Exp $
 #
 
 SHELL = @SHELL@
@@ -75,6 +75,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -13,7 +13,7 @@
 
 @SET_MAKE@
 
-# $Id: Makefile.in,v 1.28 2002/09/15 05:41:54 robertc Exp $
+# $Id: Makefile.in,v 1.29 2002/09/15 06:40:52 robertc Exp $
 #
 
 SHELL = @SHELL@
@@ -72,6 +72,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -1,5 +1,5 @@
 /*
- * $Id: rfc1035.h,v 1.6 2001/10/08 16:18:31 hno Exp $
+ * $Id: rfc1035.h,v 1.7 2002/09/15 06:40:53 robertc Exp $
  *
  * AUTHOR: Duane Wessels
  *
@@ -51,7 +51,7 @@ typedef struct _rfc1035_rr rfc1035_rr;
 struct _rfc1035_rr {
     char name[RFC1035_MAXHOSTNAMESZ];
     unsigned short type;
-    unsigned short class;
+    unsigned short _class;
     unsigned int ttl;
     unsigned short rdlength;
     char *rdata;
@@ -14,7 +14,7 @@
 @SET_MAKE@
 
 #
-#  $Id: Makefile.in,v 1.64 2002/09/15 05:41:55 robertc Exp $
+#  $Id: Makefile.in,v 1.65 2002/09/15 06:40:54 robertc Exp $
 #
 
 SHELL = @SHELL@
@@ -73,6 +73,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -1,6 +1,6 @@
 
 /*
- * $Id: rfc1035.c,v 1.26 2002/04/10 21:16:17 hno Exp $
+ * $Id: rfc1035.c,v 1.27 2002/09/15 06:40:54 robertc Exp $
  *
  * Low level DNS protocol routines
  * AUTHOR: Duane Wessels
@@ -211,15 +211,15 @@ rfc1035QuestionPack(char *buf,
     size_t sz,
     const char *name,
     unsigned short type,
-    unsigned short class)
+    unsigned short _class)
 {
     off_t off = 0;
     unsigned short s;
     off += rfc1035NamePack(buf + off, sz - off, name);
     s = htons(type);
     memcpy(buf + off, &s, sizeof(s));
     off += sizeof(s);
-    s = htons(class);
+    s = htons(_class);
     memcpy(buf + off, &s, sizeof(s));
     off += sizeof(s);
     assert(off <= sz);
@@ -386,7 +386,7 @@ rfc1035RRUnpack(const char *buf, size_t sz, off_t * off, rfc1035_rr * RR)
     RR->type = ntohs(s);
     memcpy(&s, buf + (*off), sizeof(s));
     (*off) += sizeof(s);
-    RR->class = ntohs(s);
+    RR->_class = ntohs(s);
     memcpy(&i, buf + (*off), sizeof(i));
     (*off) += sizeof(i);
     RR->ttl = ntohl(i);
@@ -74,6 +74,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -69,6 +69,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -1,7 +1,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.am,v 1.29 2002/09/15 05:41:56 robertc Exp $
+#  $Id: Makefile.am,v 1.30 2002/09/15 06:40:56 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -228,6 +228,7 @@ squid_LDADD = \
 	@SSLLIB@ \
 	-lmiscutil \
 	@XTRA_LIBS@
+squid_DEPENDENCIES = $(top_builddir)/lib/libmiscutil.a
 
 unlinkd_SOURCES = 
 unlinkd_LDADD = unlinkd-daemon.o
@@ -16,7 +16,7 @@
 #
 #  Makefile for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.241 2002/09/15 05:41:56 robertc Exp $
+#  $Id: Makefile.in,v 1.242 2002/09/15 06:40:56 robertc Exp $
 #
 #  Uncomment and customize the following to suit your needs:
 #
@@ -77,6 +77,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -331,6 +332,7 @@ squid_LDADD = \
 	-lmiscutil \
 	@XTRA_LIBS@
 
+squid_DEPENDENCIES = $(top_builddir)/lib/libmiscutil.a
 
 unlinkd_SOURCES = 
 unlinkd_LDADD = unlinkd-daemon.o
@@ -500,7 +502,6 @@ nodist_squid_OBJECTS = repl_modules.$(OBJEXT) auth_modules.$(OBJEXT) \
 	store_modules.$(OBJEXT) globals.$(OBJEXT) \
 	string_arrays.$(OBJEXT)
 squid_OBJECTS = $(am_squid_OBJECTS) $(nodist_squid_OBJECTS)
-squid_DEPENDENCIES =
 squid_LDFLAGS =
 am_squidclient_OBJECTS = client.$(OBJEXT)
 squidclient_OBJECTS = $(am_squidclient_OBJECTS)
@@ -1,6 +1,6 @@
 
 /*
- * $Id: access_log.cc,v 1.74 2002/06/16 11:24:00 hno Exp $
+ * $Id: access_log.cc,v 1.75 2002/09/15 06:40:56 robertc Exp $
  *
  * DEBUG: section 46    Access Log
  * AUTHOR: Duane Wessels
@@ -250,7 +250,7 @@ accessLogSquid(AccessLogEntry * al)
 	log_tags[al->cache.code],
 	al->http.code,
 	(long int) al->cache.size,
-	al->private.method_str,
+	al->_private.method_str,
 	al->url,
 	user && *user ? user : dash_str,
 	al->hier.ping.timedout ? "TIMEOUT_" : "",
@@ -276,7 +276,7 @@ accessLogCommon(AccessLogEntry * al)
 	user2 ? user2 : dash_str,
 	user1 ? user1 : dash_str,
 	mkhttpdlogtime(&squid_curtime),
-	al->private.method_str,
+	al->_private.method_str,
 	al->url,
 	al->http.version.major, al->http.version.minor,
 	al->http.code,
@@ -297,9 +297,9 @@ accessLogLog(AccessLogEntry * al)
     if (!al->http.content_type || *al->http.content_type == '\0')
 	al->http.content_type = dash_str;
     if (al->icp.opcode)
-	al->private.method_str = icp_opcode_str[al->icp.opcode];
+	al->_private.method_str = icp_opcode_str[al->icp.opcode];
     else
-	al->private.method_str = RequestMethodStr[al->http.method];
+	al->_private.method_str = RequestMethodStr[al->http.method];
     if (al->hier.host[0] == '\0')
 	xstrncpy(al->hier.host, dash_str, SQUIDHOSTNAMELEN);
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: acl.cc,v 1.284 2002/09/07 15:12:55 hno Exp $
+ * $Id: acl.cc,v 1.285 2002/09/15 06:40:56 robertc Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -949,8 +949,8 @@ aclParseAccessLine(acl_access ** head)
 	cbdataFree(A);
 	return;
     }
-    aclParseAclList(&A->acl_list);
-    if (A->acl_list == NULL) {
+    aclParseAclList(&A->aclList);
+    if (A->aclList == NULL) {
 	debug(28, 0) ("%s line %d: %s\n",
 	    cfg_filename, config_lineno, config_input_line);
 	debug(28, 0) ("aclParseAccessLine: Access line contains no ACL's, skipping\n");
@@ -991,7 +991,7 @@ aclParseAclList(acl_list ** head)
 	    memFree(L, MEM_ACL_LIST);
 	    continue;
 	}
-	L->acl = a;
+	L->_acl = a;
 	*Tail = L;
 	Tail = &L->next;
     }
@@ -1683,10 +1683,10 @@ int
 aclMatchAclList(const acl_list * list, aclCheck_t * checklist)
 {
     while (list) {
-	AclMatchedName = list->acl->name;
+	AclMatchedName = list->_acl->name;
 	debug(28, 3) ("aclMatchAclList: checking %s%s\n",
-	    list->op ? null_string : "!", list->acl->name);
-	if (aclMatchAcl(list->acl, checklist) != list->op) {
+	    list->op ? null_string : "!", list->_acl->name);
+	if (aclMatchAcl(list->_acl, checklist) != list->op) {
 	    debug(28, 3) ("aclMatchAclList: returning 0\n");
 	    return 0;
 	}
@@ -1712,7 +1712,7 @@ aclCheckFast(const acl_access * A, aclCheck_t * checklist)
     debug(28, 5) ("aclCheckFast: list: %p\n", A);
     while (A) {
 	allow = A->allow;
-	if (aclMatchAclList(A->acl_list, checklist)) {
+	if (aclMatchAclList(A->aclList, checklist)) {
 	    aclCheckCleanup(checklist);
 	    return allow == ACCESS_ALLOWED;
 	}
@@ -1733,19 +1733,19 @@ aclCheck(aclCheck_t * checklist)
     /* NOTE: This holds a cbdata reference to the current access_list
      * entry, not the whole list.
      */
-    while ((A = checklist->access_list) != NULL) {
+    while ((A = checklist->accessList) != NULL) {
 	/*
 	 * If the _acl_access is no longer valid (i.e. its been
 	 * freed because of a reconfigure), then bail on this
 	 * access check.  For now, return ACCESS_DENIED.
 	 */
 	if (!cbdataReferenceValid(A)) {
-	    cbdataReferenceDone(checklist->access_list);
+	    cbdataReferenceDone(checklist->accessList);
 	    break;
 	}
 	debug(28, 3) ("aclCheck: checking '%s'\n", A->cfgline);
 	allow = A->allow;
-	match = aclMatchAclList(A->acl_list, checklist);
+	match = aclMatchAclList(A->aclList, checklist);
 	if (checklist->state[ACL_DST_IP] == ACL_LOOKUP_NEEDED) {
 	    checklist->state[ACL_DST_IP] = ACL_LOOKUP_PENDING;
 	    ipcache_nbgethostbyname(checklist->request->host,
@@ -1815,14 +1815,14 @@ aclCheck(aclCheck_t * checklist)
 	 */
 	if (match) {
 	    debug(28, 3) ("aclCheck: match found, returning %d\n", allow);
-	    cbdataReferenceDone(checklist->access_list);	/* A */
+	    cbdataReferenceDone(checklist->accessList);		/* A */
 	    aclCheckCallback(checklist, allow);
 	    return;
 	}
 	/*
 	 * Reference the next _acl_access entry
 	 */
-	checklist->access_list = cbdataReference(A->next);
+	checklist->accessList = cbdataReference(A->next);
 	cbdataReferenceDone(A);
     }
     debug(28, 3) ("aclCheck: NO match found, returning %d\n", allow != ACCESS_DENIED ? ACCESS_DENIED : ACCESS_ALLOWED);
@@ -1954,7 +1954,7 @@ aclChecklistCreate(const acl_access * A, request_t * request, const char *ident)
     int i;
     aclCheck_t *checklist;
     checklist = cbdataAlloc(aclCheck_t);
-    checklist->access_list = cbdataReference(A);
+    checklist->accessList = cbdataReference(A);
     if (request != NULL) {
 	checklist->request = requestLink(request);
 	checklist->src_addr = request->client_addr;
@@ -2127,7 +2127,7 @@ aclDestroyAccessList(acl_access ** list)
     for (l = *list; l; l = next) {
 	debug(28, 3) ("aclDestroyAccessList: '%s'\n", l->cfgline);
 	next = l->next;
-	aclDestroyAclList(&l->acl_list);
+	aclDestroyAclList(&l->aclList);
 	safe_free(l->cfgline);
 	cbdataFree(l);
     }
@@ -2530,10 +2530,10 @@ aclPurgeMethodInUse(acl_access * a)
 {
     acl_list *b;
     for (; a; a = a->next) {
-	for (b = a->acl_list; b; b = b->next) {
-	    if (ACL_METHOD != b->acl->type)
+	for (b = a->aclList; b; b = b->next) {
+	    if (ACL_METHOD != b->_acl->type)
 		continue;
-	    if (aclMatchInteger(b->acl->data, METHOD_PURGE))
+	    if (aclMatchInteger(b->_acl->data, METHOD_PURGE))
 		return 1;
 	}
     }
@@ -15,7 +15,7 @@
 
 #  Makefile for authentication modules in the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.13 2002/09/15 05:41:59 robertc Exp $
+#  $Id: Makefile.in,v 1.14 2002/09/15 06:41:05 robertc Exp $
 #
 
 SHELL = @SHELL@
@@ -74,6 +74,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -69,6 +69,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -69,6 +69,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -69,6 +69,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -1,6 +1,6 @@
 
 /*
- * $Id: cache_cf.cc,v 1.414 2002/09/07 15:12:56 hno Exp $
+ * $Id: cache_cf.cc,v 1.415 2002/09/15 06:40:57 robertc Exp $
  *
  * DEBUG: section 3     Configuration File Parsing
  * AUTHOR: Harvest Derived
@@ -453,11 +453,11 @@ configDoConfigure(void)
 	debug(22, 1) ("WARNING: HTTP requires the use of Via\n");
 #endif
     if (Config.Wais.relayHost) {
-	if (Config.Wais.peer)
-	    cbdataFree(Config.Wais.peer);
-	Config.Wais.peer = cbdataAlloc(peer);
-	Config.Wais.peer->host = xstrdup(Config.Wais.relayHost);
-	Config.Wais.peer->http_port = Config.Wais.relayPort;
+	if (Config.Wais._peer)
+	    cbdataFree(Config.Wais._peer);
+	Config.Wais._peer = cbdataAlloc(peer);
+	Config.Wais._peer->host = xstrdup(Config.Wais.relayHost);
+	Config.Wais._peer->http_port = Config.Wais.relayPort;
     }
     if (aclPurgeMethodInUse(Config.accessList.http))
 	Config2.onoff.enable_purge = 1;
@@ -634,7 +634,7 @@ dump_acl_list(StoreEntry * entry, acl_list * head)
     for (l = head; l; l = l->next) {
 	storeAppendPrintf(entry, " %s%s",
 	    l->op ? null_string : "!",
-	    l->acl->name);
+	    l->_acl->name);
     }
 }
 
@@ -646,7 +646,7 @@ dump_acl_access(StoreEntry * entry, const char *name, acl_access * head)
 	storeAppendPrintf(entry, "%s %s",
 	    name,
 	    l->allow ? "Allow" : "Deny");
-	dump_acl_list(entry, l->acl_list);
+	dump_acl_list(entry, l->aclList);
 	storeAppendPrintf(entry, "\n");
     }
 }
@@ -702,7 +702,7 @@ dump_acl_address(StoreEntry * entry, const char *name, acl_address * head)
 	    storeAppendPrintf(entry, "%s %s", name, inet_ntoa(l->addr));
 	else
 	    storeAppendPrintf(entry, "%s autoselect", name);
-	dump_acl_list(entry, l->acl_list);
+	dump_acl_list(entry, l->aclList);
 	storeAppendPrintf(entry, "\n");
     }
 }
@@ -711,7 +711,7 @@ static void
 freed_acl_address(void *data)
 {
     acl_address *l = data;
-    aclDestroyAclList(&l->acl_list);
+    aclDestroyAclList(&l->aclList);
 }
 
 static void
@@ -722,7 +722,7 @@ parse_acl_address(acl_address ** head)
     CBDATA_INIT_TYPE_FREECB(acl_address, freed_acl_address);
     l = cbdataAlloc(acl_address);
     parse_address(&l->addr);
-    aclParseAclList(&l->acl_list);
+    aclParseAclList(&l->aclList);
     while (*tail)
 	tail = &(*tail)->next;
     *tail = l;
@@ -749,7 +749,7 @@ dump_acl_tos(StoreEntry * entry, const char *name, acl_tos * head)
 	    storeAppendPrintf(entry, "%s 0x%02X", name, l->tos);
 	else
 	    storeAppendPrintf(entry, "%s none", name);
-	dump_acl_list(entry, l->acl_list);
+	dump_acl_list(entry, l->aclList);
 	storeAppendPrintf(entry, "\n");
     }
 }
@@ -758,7 +758,7 @@ static void
 freed_acl_tos(void *data)
 {
     acl_tos *l = data;
-    aclDestroyAclList(&l->acl_list);
+    aclDestroyAclList(&l->aclList);
 }
 
 static void
@@ -778,7 +778,7 @@ parse_acl_tos(acl_tos ** head)
     CBDATA_INIT_TYPE_FREECB(acl_tos, freed_acl_tos);
     l = cbdataAlloc(acl_tos);
     l->tos = tos;
-    aclParseAclList(&l->acl_list);
+    aclParseAclList(&l->aclList);
     while (*tail)
 	tail = &(*tail)->next;
     *tail = l;
@@ -2068,10 +2068,10 @@ dump_body_size_t(StoreEntry * entry, const char *name, dlink_list bodylist)
 	while (head != NULL) {
 	    storeAppendPrintf(entry, "%s %ld %s", name, (long int) bs->maxsize,
 		head->allow ? "Allow" : "Deny");
-	    for (l = head->acl_list; l != NULL; l = l->next) {
+	    for (l = head->aclList; l != NULL; l = l->next) {
 		storeAppendPrintf(entry, " %s%s",
 		    l->op ? null_string : "!",
-		    l->acl->name);
+		    l->_acl->name);
 	    }
 	    storeAppendPrintf(entry, "\n");
 	    head = head->next;
@@ -2519,4 +2519,3 @@ strtokFile(void)
 	return t;
     }
 }
-
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side.cc,v 1.591 2002/09/15 05:41:56 robertc Exp $
+ * $Id: client_side.cc,v 1.592 2002/09/15 06:40:57 robertc Exp $
  *
  * DEBUG: section 33    Client-side Routines
  * AUTHOR: Duane Wessels
@@ -228,13 +228,13 @@ clientUpdateCounters(clientHttpRequest * http)
     ping_data *i;
     HierarchyLogEntry *H;
     statCounter.client_http.requests++;
-    if (isTcpHit(http->log_type))
+    if (isTcpHit(http->logType))
 	statCounter.client_http.hits++;
-    if (http->log_type == LOG_TCP_HIT)
+    if (http->logType == LOG_TCP_HIT)
 	statCounter.client_http.disk_hits++;
-    else if (http->log_type == LOG_TCP_MEM_HIT)
+    else if (http->logType == LOG_TCP_MEM_HIT)
 	statCounter.client_http.mem_hits++;
-    if (http->request->err_type != ERR_NONE)
+    if (http->request->errType != ERR_NONE)
 	statCounter.client_http.errors++;
     statHistCount(&statCounter.client_http.all_svc_time, svc_time);
     /*
@@ -243,7 +243,7 @@ clientUpdateCounters(clientHttpRequest * http)
      * LOG_TCP_REFRESH_FAIL_HIT because its not really a cache hit
      * (we *tried* to validate it, but failed).
      */
-    switch (http->log_type) {
+    switch (http->logType) {
     case LOG_TCP_REFRESH_HIT:
 	statHistCount(&statCounter.client_http.nh_svc_time, svc_time);
 	break;
@@ -303,10 +303,10 @@ httpRequestFree(void *data)
 	/* the ICP check here was erroneous - storeReleaseRequest was always called if entry was valid 
 	 */
     }
-    assert(http->log_type < LOG_TYPE_MAX);
+    assert(http->logType < LOG_TYPE_MAX);
     if (http->entry)
 	mem = http->entry->mem_obj;
-    if (http->out.size || http->log_type) {
+    if (http->out.size || http->logType) {
 	http->al.icp.opcode = ICP_INVALID;
 	http->al.url = http->log_uri;
 	debug(33, 9) ("httpRequestFree: al.url='%s'\n", http->al.url);
@@ -316,7 +316,7 @@ httpRequestFree(void *data)
 	}
 	http->al.cache.caddr = conn ? conn->log_addr : no_addr;
 	http->al.cache.size = http->out.size;
-	http->al.cache.code = http->log_type;
+	http->al.cache.code = http->logType;
 	http->al.cache.msec = tvSubMsec(http->start, current_time);
 	if (request) {
 	    Packer p;
@@ -343,11 +343,11 @@ httpRequestFree(void *data)
 	accessLogLog(&http->al);
 	clientUpdateCounters(http);
 	if (conn)
-	    clientdbUpdate(conn->peer.sin_addr, http->log_type, PROTO_HTTP,
+	    clientdbUpdate(conn->peer.sin_addr, http->logType, PROTO_HTTP,
 		http->out.size);
     }
     if (request)
-	checkFailureRatio(request->err_type, http->al.hier.code);
+	checkFailureRatio(request->errType, http->al.hier.code);
     safe_free(http->uri);
     safe_free(http->log_uri);
     safe_free(http->al.headers.request);
@@ -656,7 +656,7 @@ clientWriteComplete(int fd, char *bufnotused, size_t size, int errflag, void *da
 	fd, (long int) size, errflag, (long int) http->out.size, entry ? objectLen(entry) : 0);
     if (size > 0 && fd > -1) {
 	kb_incr(&statCounter.client_http.kbytes_out, size);
-	if (isTcpHit(http->log_type))
+	if (isTcpHit(http->logType))
 	    kb_incr(&statCounter.client_http.hit_kbytes_out, size);
     }
     if (errflag) {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side_reply.cc,v 1.1 2002/09/15 05:41:56 robertc Exp $
+ * $Id: client_side_reply.cc,v 1.2 2002/09/15 06:40:57 robertc Exp $
  *
  * DEBUG: section 88    Client-side Reply Routines
  * AUTHOR: Robert Collins (Originally Duane Wessels in client_side.c)
@@ -128,7 +128,7 @@ clientSetReplyToError(void *data,
     if (status == HTTP_NOT_IMPLEMENTED && context->http->request)
 	/* prevent confusion over whether we default to persistent or not */
 	context->http->request->flags.proxy_keepalive = 0;
-    context->http->al.http.code = errstate->http_status;
+    context->http->al.http.code = errstate->httpStatus;
 
     context->http->entry =
 	clientCreateStoreEntry(context, method, null_request_flags);
@@ -342,7 +342,7 @@ clientHandleIMSReply(void *data, char *buf, ssize_t size)
 	debug(88, 3) ("clientHandleIMSReply: ABORTED '%s'\n", url);
 	/* We have an existing entry, but failed to validate it */
 	/* Its okay to send the old one anyway */
-	http->log_type = LOG_TCP_REFRESH_FAIL_HIT;
+	http->logType = LOG_TCP_REFRESH_FAIL_HIT;
 	clientRemoveStoreReference(context, &context->sc, &entry);
 	/* Get the old request back */
 	clientReplyContextRestoreState(context, http);
@@ -358,7 +358,7 @@ clientHandleIMSReply(void *data, char *buf, ssize_t size)
 		("clientHandleIMSReply: Reply is too large '%s', using old entry\n",
 		url);
 	    /* use old entry, this repeats the code abovez */
-	    http->log_type = LOG_TCP_REFRESH_FAIL_HIT;
+	    http->logType = LOG_TCP_REFRESH_FAIL_HIT;
 	    clientRemoveStoreReference(context, &context->sc, &entry);
 	    entry = http->entry = http->old_entry;
 	    /* Get the old request back */
@@ -379,7 +379,7 @@ clientHandleIMSReply(void *data, char *buf, ssize_t size)
 	 * headers have been loaded from disk. */
 	clientStreamNode *next = context->http->client_stream.head->next->data;
 	oldentry = http->old_entry;
-	http->log_type = LOG_TCP_REFRESH_HIT;
+	http->logType = LOG_TCP_REFRESH_HIT;
 	if (oldentry->mem_obj->request == NULL) {
 	    oldentry->mem_obj->request = requestLink(mem->request);
 	    unlink_request = 1;
@@ -404,12 +404,12 @@ clientHandleIMSReply(void *data, char *buf, ssize_t size)
 	clientSendMoreData(context, next->readbuf, context->reqsize);
     } else {
 	/* the client can handle this reply, whatever it is */
-	http->log_type = LOG_TCP_REFRESH_MISS;
+	http->logType = LOG_TCP_REFRESH_MISS;
 	if (HTTP_NOT_MODIFIED == mem->reply->sline.status) {
 	    httpReplyUpdateOnNotModified(http->old_entry->mem_obj->reply,
 		mem->reply);
 	    storeTimestampsSet(http->old_entry);
-	    http->log_type = LOG_TCP_REFRESH_HIT;
+	    http->logType = LOG_TCP_REFRESH_HIT;
 	}
 	clientRemoveStoreReference(context, &context->old_sc, &http->old_entry);
 	/* here the data to send is the data we just recieved */
@@ -446,7 +446,7 @@ clientCacheHit(void *data, char *buf, ssize_t size)
     } else if (size < 0) {
 	/* swap in failure */
 	debug(88, 3) ("clientCacheHit: swapin failure for %s\n", http->uri);
-	http->log_type = LOG_TCP_SWAPFAIL_MISS;
+	http->logType = LOG_TCP_SWAPFAIL_MISS;
 	clientRemoveStoreReference(context, &context->sc, &http->entry);
 	clientProcessMiss(context);
 	return;
@@ -483,7 +483,7 @@ clientCacheHit(void *data, char *buf, ssize_t size)
     /*
      * Got the headers, now grok them
      */
-    assert(http->log_type == LOG_TCP_HIT);
+    assert(http->logType == LOG_TCP_HIT);
     switch (varyEvaluateMatch(e, r)) {
     case VARY_NONE:
 	/* No variance detected. Continue as normal */
@@ -517,7 +517,7 @@ clientCacheHit(void *data, char *buf, ssize_t size)
 	return;
     }
     if (storeCheckNegativeHit(e)) {
-	http->log_type = LOG_TCP_NEGATIVE_HIT;
+	http->logType = LOG_TCP_NEGATIVE_HIT;
 	clientSendMoreData(context, buf, size);
     } else if (r->method == METHOD_HEAD) {
 	/*
@@ -526,7 +526,7 @@ clientCacheHit(void *data, char *buf, ssize_t size)
 	 * request, nor can we return 304.
 	 */
 	if (e->mem_status == IN_MEMORY)
-	    http->log_type = LOG_TCP_MEM_HIT;
+	    http->logType = LOG_TCP_MEM_HIT;
 	clientSendMoreData(context, buf, size);
     } else if (refreshCheckHTTP(e, r) && !http->flags.internal) {
 	debug(88, 5) ("clientCacheHit: in refreshCheck() block\n");
@@ -546,28 +546,28 @@ clientCacheHit(void *data, char *buf, ssize_t size)
 	     * Previous reply didn't have a Last-Modified header,
 	     * we cannot revalidate it.
 	     */
-	    http->log_type = LOG_TCP_MISS;
+	    http->logType = LOG_TCP_MISS;
 	    clientProcessMiss(context);
 	} else if (r->flags.nocache) {
 	    /*
 	     * This did not match a refresh pattern that overrides no-cache
 	     * we should honour the client no-cache header.
 	     */
-	    http->log_type = LOG_TCP_CLIENT_REFRESH_MISS;
+	    http->logType = LOG_TCP_CLIENT_REFRESH_MISS;
 	    clientProcessMiss(context);
 	} else if (r->protocol == PROTO_HTTP) {
 	    /*
 	     * Object needs to be revalidated
 	     * XXX This could apply to FTP as well, if Last-Modified is known.
 	     */
-	    http->log_type = LOG_TCP_REFRESH_MISS;
+	    http->logType = LOG_TCP_REFRESH_MISS;
 	    clientProcessExpired(context);
 	} else {
 	    /*
 	     * We don't know how to re-validate other protocols. Handle
 	     * them as if the object has expired.
 	     */
-	    http->log_type = LOG_TCP_MISS;
+	    http->logType = LOG_TCP_MISS;
 	    clientProcessMiss(context);
 	}
     } else if (r->flags.ims) {
@@ -577,16 +577,16 @@ clientCacheHit(void *data, char *buf, ssize_t size)
 	if (mem->reply->sline.status != HTTP_OK) {
 	    debug(88, 4) ("clientCacheHit: Reply code %d != 200\n",
 		mem->reply->sline.status);
-	    http->log_type = LOG_TCP_MISS;
+	    http->logType = LOG_TCP_MISS;
 	    clientProcessMiss(context);
 	} else if (modifiedSince(e, http->request)) {
-	    http->log_type = LOG_TCP_IMS_HIT;
+	    http->logType = LOG_TCP_IMS_HIT;
 	    clientSendMoreData(context, buf, size);
 	} else {
 	    clientStreamNode *next;
 	    time_t timestamp = e->timestamp;
 	    MemBuf mb = httpPacked304Reply(e->mem_obj->reply);
-	    http->log_type = LOG_TCP_IMS_HIT;
+	    http->logType = LOG_TCP_IMS_HIT;
 	    clientRemoveStoreReference(context, &context->sc, &http->entry);
 	    http->entry = e =
 		clientCreateStoreEntry(context, http->request->method,
@@ -616,9 +616,9 @@ clientCacheHit(void *data, char *buf, ssize_t size)
 	 * plain ol' cache hit
 	 */
 	if (e->mem_status == IN_MEMORY)
-	    http->log_type = LOG_TCP_MEM_HIT;
+	    http->logType = LOG_TCP_MEM_HIT;
 	else if (Config.onoff.offline)
-	    http->log_type = LOG_TCP_OFFLINE_HIT;
+	    http->logType = LOG_TCP_OFFLINE_HIT;
 	clientSendMoreData(context, buf, size);
     }
 }
@@ -643,7 +643,7 @@ clientProcessMiss(clientReplyContext * context)
 	if (EBIT_TEST(http->entry->flags, ENTRY_SPECIAL)) {
 	    debug(88, 0) ("clientProcessMiss: miss on a special object (%s).\n",
 		url);
-	    debug(88, 0) ("\tlog_type = %s\n", log_tags[http->log_type]);
+	    debug(88, 0) ("\tlog_type = %s\n", log_tags[http->logType]);
 	    storeEntryDump(http->entry, 1);
 	}
 	clientRemoveStoreReference(context, &context->sc, &http->entry);
@@ -684,7 +684,7 @@ clientProcessMiss(clientReplyContext * context)
 	if (http->redirect.status) {
 	    HttpReply *rep = httpReplyCreate();
 #if LOG_TCP_REDIRECTS
-	    http->log_type = LOG_TCP_REDIRECT;
+	    http->logType = LOG_TCP_REDIRECT;
 #endif
 	    storeReleaseRequest(http->entry);
 	    httpRedirectReply(rep, http->redirect.status,
@@ -743,7 +743,7 @@ clientPurgeRequest(clientReplyContext * context)
 	Config2.onoff.enable_purge);
     next = http->client_stream.head->next->data;
     if (!Config2.onoff.enable_purge) {
-	http->log_type = LOG_TCP_DENIED;
+	http->logType = LOG_TCP_DENIED;
 	err =
 	    clientBuildError(ERR_ACCESS_DENIED, HTTP_FORBIDDEN, NULL,
 	    &http->conn->peer.sin_addr, http->request);
@@ -775,15 +775,15 @@ clientPurgeRequest(clientReplyContext * context)
 	    storeCreateMemObject(http->entry, http->uri, http->log_uri);
 	    http->entry->mem_obj->method = http->request->method;
 	    context->sc = storeClientListAdd(http->entry, context);
-	    http->log_type = LOG_TCP_HIT;
+	    http->logType = LOG_TCP_HIT;
 	    context->reqofs = 0;
 	    storeClientCopy(context->sc, http->entry,
 		http->out.offset,
 		next->readlen, next->readbuf, clientCacheHit, context);
 	    return;
 	}
     }
-    http->log_type = LOG_TCP_MISS;
+    http->logType = LOG_TCP_MISS;
     /* Release the cached URI */
     entry = storeGetPublicByRequestMethod(http->request, METHOD_GET);
     if (entry) {
@@ -1059,7 +1059,7 @@ static void
 clientBuildReplyHeader(clientHttpRequest * http, HttpReply * rep)
 {
     HttpHeader *hdr = &rep->header;
-    int is_hit = isTcpHit(http->log_type);
+    int is_hit = isTcpHit(http->logType);
     request_t *request = http->request;
 #if DONT_FILTER_THESE
     /* but you might want to if you run Squid as an HTTP accelerator */
@@ -1288,9 +1288,9 @@ clientGetMoreData(clientStreamNode * this, clientHttpRequest * http)
 	    return;
 	}
 	/* continue forwarding, not finished yet. */
-	http->log_type = LOG_TCP_MISS;
+	http->logType = LOG_TCP_MISS;
     } else
-	http->log_type = clientIdentifyStoreObject(http);
+	http->logType = clientIdentifyStoreObject(http);
     /* We still have to do store logic processing - vary, cache hit etc */
     if (context->http->entry != NULL) {
 	/* someone found the object in the cache for us */
@@ -1312,14 +1312,14 @@ clientGetMoreData(clientStreamNode * this, clientHttpRequest * http)
 #if DELAY_POOLS
 	delaySetStoreClient(context->http->sc, delayClient(context->http));
 #endif
-	assert(context->http->log_type == LOG_TCP_HIT);
+	assert(context->http->logType == LOG_TCP_HIT);
 	context->reqofs = 0;
 	assert(http->out.offset == http->out.size && http->out.offset == 0);
 	storeClientCopy(context->sc, http->entry,
 	    context->reqofs,
 	    next->readlen, next->readbuf, clientCacheHit, context);
     } else {
-	/* MISS CASE, http->log_type is already set! */
+	/* MISS CASE, http->logType is already set! */
 	clientProcessMiss(context);
     }
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side_request.cc,v 1.1 2002/09/15 05:41:57 robertc Exp $
+ * $Id: client_side_request.cc,v 1.2 2002/09/15 06:40:57 robertc Exp $
  *
  * DEBUG: section 85    Client-side Request Routines
  * AUTHOR: Robert Collins (Originally Duane Wessels in client_side.c)
@@ -263,7 +263,7 @@ clientAccessCheckDone(int answer, void *data)
 	 * just below.  Pedro Ribeiro <pribeiro@isel.pt>
 	 */
 	page_id = aclGetDenyInfoPage(&Config.denyInfoList, AclMatchedName);
-	http->log_type = LOG_TCP_DENIED;
+	http->logType = LOG_TCP_DENIED;
 	if (answer == ACCESS_REQ_PROXY_AUTH || aclIsProxyAuth(AclMatchedName)) {
 	    if (!http->flags.accel) {
 		/* Proxy authorisation needed */
@@ -582,14 +582,14 @@ clientProcessRequest(clientHttpRequest * http)
     debug(85, 4) ("clientProcessRequest: %s '%s'\n",
 	RequestMethodStr[r->method], http->uri);
     if (r->method == METHOD_CONNECT) {
-	http->log_type = LOG_TCP_MISS;
+	http->logType = LOG_TCP_MISS;
 	sslStart(http, &http->out.size, &http->al.http.code);
 	return;
     } else {
-	http->log_type = LOG_TAG_NONE;
+	http->logType = LOG_TAG_NONE;
     }
     debug(85, 4) ("clientProcessRequest: %s for '%s'\n",
-	log_tags[http->log_type], http->uri);
+	log_tags[http->logType], http->uri);
     /* no one should have touched this */
     assert(http->out.offset == 0);
     /* Use the Stream Luke */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: comm.cc,v 1.333 2002/09/15 06:23:28 adrian Exp $
+ * $Id: comm.cc,v 1.334 2002/09/15 06:40:57 robertc Exp $
  *
  * DEBUG: section 5     Socket Functions
  * AUTHOR: Harvest Derived
@@ -563,8 +563,8 @@ commCallCloseHandlers(int fd)
     fde *F = &fd_table[fd];
     close_handler *ch;
     debug(5, 5) ("commCallCloseHandlers: FD %d\n", fd);
-    while ((ch = F->close_handler) != NULL) {
-	F->close_handler = ch->next;
+    while ((ch = F->closeHandler) != NULL) {
+	F->closeHandler = ch->next;
 	debug(5, 5) ("commCallCloseHandlers: ch->handler=%p\n", ch->handler);
 	if (cbdataReferenceValid(ch->data))
 	    ch->handler(fd, ch->data);
@@ -704,12 +704,12 @@ comm_add_close_handler(int fd, PF * handler, void *data)
     close_handler *c;
     debug(5, 5) ("comm_add_close_handler: FD %d, handler=%p, data=%p\n",
 	fd, handler, data);
-    for (c = fd_table[fd].close_handler; c; c = c->next)
+    for (c = fd_table[fd].closeHandler; c; c = c->next)
 	assert(c->handler != handler || c->data != data);
     new->handler = handler;
     new->data = cbdataReference(data);
-    new->next = fd_table[fd].close_handler;
-    fd_table[fd].close_handler = new;
+    new->next = fd_table[fd].closeHandler;
+    fd_table[fd].closeHandler = new;
 }
 
 void
@@ -720,15 +720,15 @@ comm_remove_close_handler(int fd, PF * handler, void *data)
     /* Find handler in list */
     debug(5, 5) ("comm_remove_close_handler: FD %d, handler=%p, data=%p\n",
 	fd, handler, data);
-    for (p = fd_table[fd].close_handler; p != NULL; last = p, p = p->next)
+    for (p = fd_table[fd].closeHandler; p != NULL; last = p, p = p->next)
 	if (p->handler == handler && p->data == data)
 	    break;		/* This is our handler */
     assert(p != NULL);
     /* Remove list entry */
     if (last)
 	last->next = p->next;
     else
-	fd_table[fd].close_handler = p->next;
+	fd_table[fd].closeHandler = p->next;
     cbdataReferenceDone(p->data);
     memPoolFree(conn_close_pool, p);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: comm_poll.cc,v 1.4 2002/09/15 06:23:28 adrian Exp $
+ * $Id: comm_poll.cc,v 1.5 2002/09/15 06:40:57 robertc Exp $
  *
  * DEBUG: section 5     Socket Functions
  *
@@ -475,15 +475,15 @@ comm_select(int msec)
 		    F->timeout_handler,
 		    F->read_handler,
 		    F->write_handler);
-		for (ch = F->close_handler; ch; ch = ch->next)
+		for (ch = F->closeHandler; ch; ch = ch->next)
 		    debug(5, 0) (" close handler: %p\n", ch->handler);
-		if (F->close_handler) {
+		if (F->closeHandler) {
 		    commCallCloseHandlers(fd);
 		} else if (F->timeout_handler) {
 		    debug(5, 0) ("comm_poll: Calling Timeout Handler\n");
 		    F->timeout_handler(fd, F->timeout_data);
 		}
-		F->close_handler = NULL;
+		F->closeHandler = NULL;
 		F->timeout_handler = NULL;
 		F->read_handler = NULL;
 		F->write_handler = NULL;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: errorpage.cc,v 1.176 2002/09/15 06:23:28 adrian Exp $
+ * $Id: errorpage.cc,v 1.177 2002/09/15 06:40:57 robertc Exp $
  *
  * DEBUG: section 4     Error Generation
  * AUTHOR: Duane Wessels
@@ -266,7 +266,7 @@ errorCon(err_type type, http_status status)
     err = cbdataAlloc(ErrorState);
     err->page_id = type;	/* has to be reset manually if needed */
     err->type = type;
-    err->http_status = status;
+    err->httpStatus = status;
     return err;
 }
 
@@ -358,7 +358,7 @@ errorSend(int fd, ErrorState * err)
      * the client side for logging and error tracking.
      */
     if (err->request)
-	err->request->err_type = err->type;
+	err->request->errType = err->type;
     /* moved in front of errorBuildBuf @?@ */
     err->flags.flag_cbdata = 1;
     rep = errorBuildReply(err);
@@ -681,10 +681,10 @@ errorBuildReply(ErrorState * err)
 	char *quoted_url = rfc1738_escape_part(errorConvert('u', err));
 	httpReplySetHeaders(rep, version, HTTP_MOVED_TEMPORARILY, NULL, "text/html", 0, 0, squid_curtime);
 	httpHeaderPutStrf(&rep->header, HDR_LOCATION, name, quoted_url);
-	httpHeaderPutStrf(&rep->header, HDR_X_SQUID_ERROR, "%d %s\n", err->http_status, "Access Denied");
+	httpHeaderPutStrf(&rep->header, HDR_X_SQUID_ERROR, "%d %s\n", err->httpStatus, "Access Denied");
     } else {
 	MemBuf content = errorBuildContent(err);
-	httpReplySetHeaders(rep, version, err->http_status, NULL, "text/html", content.size, 0, squid_curtime);
+	httpReplySetHeaders(rep, version, err->httpStatus, NULL, "text/html", content.size, 0, squid_curtime);
 	/*
 	 * include some information for downstream caches. Implicit
 	 * replaceable content. This isn't quite sufficient. xerrno is not
@@ -1,6 +1,6 @@
 
 /*
- * $Id: forward.cc,v 1.86 2002/09/15 06:23:29 adrian Exp $
+ * $Id: forward.cc,v 1.87 2002/09/15 06:40:57 robertc Exp $
  *
  * DEBUG: section 17    Request Forwarding
  * AUTHOR: Duane Wessels
@@ -66,13 +66,13 @@ fwdStateServerPeer(FwdState * fwdState)
 	return NULL;
     if (NULL == fwdState->servers)
 	return NULL;
-    return fwdState->servers->peer;
+    return fwdState->servers->_peer;
 }
 
 static void
 fwdServerFree(FwdServer * fs)
 {
-    cbdataReferenceDone(fs->peer);
+    cbdataReferenceDone(fs->_peer);
     memFree(fs, MEM_FWD_SERVER);
 }
 
@@ -159,7 +159,7 @@ fwdServerClosed(int fd, void *data)
 	    FwdServer **T, *T2 = NULL;
 	    fwdState->servers = fs->next;
 	    for (T = &fwdState->servers; *T; T2 = *T, T = &(*T)->next);
-	    if (T2 && T2->peer) {
+	    if (T2 && T2->_peer) {
 		/* cycle */
 		*T = fs;
 		fs->next = NULL;
@@ -193,47 +193,47 @@ fwdConnectDone(int server_fd, comm_err_t status, void *data)
 	 * a direct connection.  If DNS lookup fails when trying
 	 * a neighbor cache, we may want to retry another option.
 	 */
-	if (NULL == fs->peer)
+	if (NULL == fs->_peer)
 	    fwdState->flags.dont_retry = 1;
 	debug(17, 4) ("fwdConnectDone: Unknown host: %s\n",
 	    request->host);
 	err = errorCon(ERR_DNS_FAIL, HTTP_SERVICE_UNAVAILABLE);
 	err->dnsserver_msg = xstrdup(dns_error_message);
 	err->request = requestLink(request);
 	fwdFail(fwdState, err);
-	if (fs->peer)
-	    fs->peer->stats.conn_open--;
+	if (fs->_peer)
+	    fs->_peer->stats.conn_open--;
 	comm_close(server_fd);
     } else if (status != COMM_OK) {
 	assert(fs);
 	err = errorCon(ERR_CONNECT_FAIL, HTTP_SERVICE_UNAVAILABLE);
 	err->xerrno = errno;
-	if (fs->peer) {
-	    err->host = xstrdup(fs->peer->host);
-	    err->port = fs->peer->http_port;
+	if (fs->_peer) {
+	    err->host = xstrdup(fs->_peer->host);
+	    err->port = fs->_peer->http_port;
 	} else {
 	    err->host = xstrdup(request->host);
 	    err->port = request->port;
 	}
 	err->request = requestLink(request);
 	fwdFail(fwdState, err);
-	if (fs->peer) {
-	    peerConnectFailed(fs->peer);
-	    fs->peer->stats.conn_open--;
+	if (fs->_peer) {
+	    peerConnectFailed(fs->_peer);
+	    fs->_peer->stats.conn_open--;
 	}
 	comm_close(server_fd);
     } else {
 	debug(17, 3) ("fwdConnectDone: FD %d: '%s'\n", server_fd, storeUrl(fwdState->entry));
-	if (fs->peer)
-	    hierarchyNote(&fwdState->request->hier, fs->code, fs->peer->host);
+	if (fs->_peer)
+	    hierarchyNote(&fwdState->request->hier, fs->code, fs->_peer->host);
 	else if (Config.onoff.log_ip_on_direct)
 	    hierarchyNote(&fwdState->request->hier, fs->code, fd_table[server_fd].ipaddr);
 	else
 	    hierarchyNote(&fwdState->request->hier, fs->code, request->host);
 	fd_note(server_fd, storeUrl(fwdState->entry));
 	fd_table[server_fd].uses++;
-	if (fs->peer)
-	    peerConnectSucceded(fs->peer);
+	if (fs->_peer)
+	    peerConnectSucceded(fs->_peer);
 	fwdDispatch(fwdState);
     }
     current = NULL;
@@ -257,8 +257,8 @@ fwdConnectTimeout(int fd, void *data)
 	 * This marks the peer DOWN ... 
 	 */
 	if (fwdState->servers)
-	    if (fwdState->servers->peer)
-		peerConnectFailed(fwdState->servers->peer);
+	    if (fwdState->servers->_peer)
+		peerConnectFailed(fwdState->servers->_peer);
     }
     if (p)
 	p->stats.conn_open--;
@@ -271,7 +271,7 @@ aclMapAddr(acl_address * head, aclCheck_t * ch)
     acl_address *l;
     struct in_addr addr;
     for (l = head; l; l = l->next) {
-	if (aclMatchAclList(l->acl_list, ch))
+	if (aclMatchAclList(l->aclList, ch))
 	    return l->addr;
     }
     addr.s_addr = INADDR_ANY;
@@ -283,7 +283,7 @@ aclMapTOS(acl_tos * head, aclCheck_t * ch)
 {
     acl_tos *l;
     for (l = head; l; l = l->next) {
-	if (aclMatchAclList(l->acl_list, ch))
+	if (aclMatchAclList(l->aclList, ch))
 	    return l->tos;
     }
     return 0;
@@ -333,10 +333,10 @@ fwdConnectStart(void *data)
     assert(fs);
     assert(fwdState->server_fd == -1);
     debug(17, 3) ("fwdConnectStart: %s\n", url);
-    if (fs->peer) {
-	host = fs->peer->host;
-	port = fs->peer->http_port;
-	ctimeout = fs->peer->connect_timeout > 0 ? fs->peer->connect_timeout
+    if (fs->_peer) {
+	host = fs->_peer->host;
+	port = fs->_peer->http_port;
+	ctimeout = fs->_peer->connect_timeout > 0 ? fs->_peer->connect_timeout
 	    : Config.Timeout.peer_connect;
     } else if (fwdState->request->flags.accelerated &&
 	Config.Accel.single_host && Config.Accel.host) {
@@ -388,8 +388,8 @@ fwdConnectStart(void *data)
      * based on the max-conn option.  We need to increment here,
      * even if the connection may fail.
      */
-    if (fs->peer)
-	fs->peer->stats.conn_open++;
+    if (fs->_peer)
+	fs->_peer->stats.conn_open++;
     comm_add_close_handler(fd, fwdServerClosed, fwdState);
     commSetTimeout(fd,
 	ctimeout,
@@ -445,7 +445,7 @@ fwdDispatch(FwdState * fwdState)
      * is closed.
      */
     assert(fwdState->server_fd > -1);
-    if (fwdState->servers && (p = fwdState->servers->peer)) {
+    if (fwdState->servers && (p = fwdState->servers->_peer)) {
 	p->stats.fetches++;
 	fwdState->request->peer_login = p->login;
 	httpStart(fwdState);
@@ -655,7 +655,7 @@ fwdFail(FwdState * fwdState, ErrorState * errorState)
     assert(EBIT_TEST(fwdState->entry->flags, ENTRY_FWD_HDR_WAIT));
     debug(17, 3) ("fwdFail: %s \"%s\"\n\t%s\n",
 	err_type_str[errorState->type],
-	httpStatusString(errorState->http_status),
+	httpStatusString(errorState->httpStatus),
 	storeUrl(fwdState->entry));
     if (fwdState->err)
 	errorStateFree(fwdState->err);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: fqdncache.cc,v 1.150 2002/04/13 23:07:50 hno Exp $
+ * $Id: fqdncache.cc,v 1.151 2002/09/15 06:40:57 robertc Exp $
  *
  * DEBUG: section 35    FQDN Cache
  * AUTHOR: Harvest Derived
@@ -296,7 +296,7 @@ fqdncacheParse(rfc1035_rr * answers, int nr)
     for (k = 0; k < nr; k++) {
 	if (answers[k].type != RFC1035_TYPE_PTR)
 	    continue;
-	if (answers[k].class != RFC1035_CLASS_IN)
+	if (answers[k]._class != RFC1035_CLASS_IN)
 	    continue;
 	na++;
 	f.flags.negcached = 0;
@@ -15,7 +15,7 @@
 
 #  Makefile for storage modules in the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.16 2002/09/15 05:42:00 robertc Exp $
+#  $Id: Makefile.in,v 1.17 2002/09/15 06:41:09 robertc Exp $
 #
 
 SHELL = @SHELL@
@@ -74,6 +74,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -69,6 +69,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -69,6 +69,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -16,7 +16,7 @@
 #
 #  Makefile for the DISKD storage driver for the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.13 2002/09/15 05:42:01 robertc Exp $
+#  $Id: Makefile.in,v 1.14 2002/09/15 06:41:13 robertc Exp $
 #
 
 SHELL = @SHELL@
@@ -75,6 +75,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -69,6 +69,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -69,6 +69,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -1,6 +1,6 @@
 
 /*
- * $Id: http.cc,v 1.391 2002/09/15 06:23:29 adrian Exp $
+ * $Id: http.cc,v 1.392 2002/09/15 06:40:57 robertc Exp $
  *
  * DEBUG: section 11    Hypertext Transfer Protocol (HTTP)
  * AUTHOR: Harvest Derived
@@ -271,7 +271,7 @@ httpCachableReply(HttpStateData * httpState)
 	    return 1;
 	else if (rep->last_modified > -1)
 	    return 1;
-	else if (!httpState->peer)
+	else if (!httpState->_peer)
 	    return 1;
 	/* @?@ (here and 302): invalid expires header compiles to squid_curtime */
 	else if (rep->expires > -1)
@@ -464,12 +464,12 @@ httpProcessReplyHeader(HttpStateData * httpState, const char *buf, int size)
 	    EBIT_SET(entry->flags, ENTRY_REVALIDATE);
     }
     if (httpState->flags.keepalive)
-	if (httpState->peer)
-	    httpState->peer->stats.n_keepalives_sent++;
+	if (httpState->_peer)
+	    httpState->_peer->stats.n_keepalives_sent++;
     if (reply->keep_alive)
-	if (httpState->peer)
-	    httpState->peer->stats.n_keepalives_recv++;
-    if (reply->date > -1 && !httpState->peer) {
+	if (httpState->_peer)
+	    httpState->_peer->stats.n_keepalives_recv++;
+    if (reply->date > -1 && !httpState->_peer) {
 	int skew = abs(reply->date - squid_curtime);
 	if (skew > 86400)
 	    debug(11, 3) ("%s's clock is skewed by %d seconds!\n",
@@ -929,7 +929,7 @@ httpSendRequest(HttpStateData * httpState)
     request_t *req = httpState->request;
     StoreEntry *entry = httpState->entry;
     int cfd;
-    peer *p = httpState->peer;
+    peer *p = httpState->_peer;
     CWCB *sendHeaderDone;
 
     debug(11, 5) ("httpSendRequest: FD %d: httpState %p.\n", httpState->fd, httpState);
@@ -961,9 +961,9 @@ httpSendRequest(HttpStateData * httpState)
 	httpState->flags.keepalive = 1;
     else if ((double) p->stats.n_keepalives_recv / (double) p->stats.n_keepalives_sent > 0.50)
 	httpState->flags.keepalive = 1;
-    if (httpState->peer)
-	if (neighborType(httpState->peer, httpState->request) == PEER_SIBLING &&
-	    !httpState->peer->options.allow_miss)
+    if (httpState->_peer)
+	if (neighborType(httpState->_peer, httpState->request) == PEER_SIBLING &&
+	    !httpState->_peer->options.allow_miss)
 	    httpState->flags.only_if_cached = 1;
     memBufDefInit(&mb);
     httpBuildRequestPrefix(req,
@@ -992,12 +992,12 @@ httpStart(FwdState * fwd)
     httpState->entry = fwd->entry;
     httpState->fd = fd;
     if (fwd->servers)
-	httpState->peer = fwd->servers->peer;	/* might be NULL */
-    if (httpState->peer) {
+	httpState->_peer = fwd->servers->_peer;		/* might be NULL */
+    if (httpState->_peer) {
 	proxy_req = requestCreate(orig_req->method,
 	    PROTO_NONE, storeUrl(httpState->entry));
-	xstrncpy(proxy_req->host, httpState->peer->host, SQUIDHOSTNAMELEN);
-	proxy_req->port = httpState->peer->http_port;
+	xstrncpy(proxy_req->host, httpState->_peer->host, SQUIDHOSTNAMELEN);
+	proxy_req->port = httpState->_peer->http_port;
 	proxy_req->flags = orig_req->flags;
 	proxy_req->lastmod = orig_req->lastmod;
 	httpState->request = requestLink(proxy_req);
@@ -1008,11 +1008,11 @@ httpStart(FwdState * fwd)
 	 * We might end up getting the object from somewhere else if,
 	 * for example, the request to this neighbor fails.
 	 */
-	if (httpState->peer->options.proxy_only)
+	if (httpState->_peer->options.proxy_only)
 	    storeReleaseRequest(httpState->entry);
 #if DELAY_POOLS
 	assert(delayIsNoDelay(fd) == 0);
-	if (httpState->peer->options.no_delay)
+	if (httpState->_peer->options.no_delay)
 	    delaySetNoDelay(fd);
 #endif
     } else {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ipcache.cc,v 1.237 2002/04/13 23:07:50 hno Exp $
+ * $Id: ipcache.cc,v 1.238 2002/09/15 06:40:57 robertc Exp $
  *
  * DEBUG: section 14    IP Cache
  * AUTHOR: Harvest Derived
@@ -325,7 +325,7 @@ ipcacheParse(rfc1035_rr * answers, int nr)
     for (j = 0, k = 0; k < nr; k++) {
 	if (answers[k].type != RFC1035_TYPE_A)
 	    continue;
-	if (answers[k].class != RFC1035_CLASS_IN)
+	if (answers[k]._class != RFC1035_CLASS_IN)
 	    continue;
 	na++;
     }
@@ -341,7 +341,7 @@ ipcacheParse(rfc1035_rr * answers, int nr)
     for (j = 0, k = 0; k < nr; k++) {
 	if (answers[k].type != RFC1035_TYPE_A)
 	    continue;
-	if (answers[k].class != RFC1035_CLASS_IN)
+	if (answers[k]._class != RFC1035_CLASS_IN)
 	    continue;
 	if (j == 0)
 	    i.expires = squid_curtime + answers[k].ttl;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: peer_select.cc,v 1.122 2002/06/23 14:50:07 hno Exp $
+ * $Id: peer_select.cc,v 1.123 2002/09/15 06:40:57 robertc Exp $
  *
  * DEBUG: section 44    Peer Selection Algorithm
  * AUTHOR: Duane Wessels
@@ -421,7 +421,7 @@ peerGetSomeDirect(ps_state * ps)
 	return;
     if (ps->request->protocol == PROTO_WAIS)
 	/* Its not really DIRECT, now is it? */
-	peerAddFwdServer(&ps->servers, Config.Wais.peer, DIRECT);
+	peerAddFwdServer(&ps->servers, Config.Wais._peer, DIRECT);
     else
 	peerAddFwdServer(&ps->servers, NULL, DIRECT);
 }
@@ -657,7 +657,7 @@ peerAddFwdServer(FwdServer ** FS, peer * p, hier_code code)
     debug(44, 5) ("peerAddFwdServer: adding %s %s\n",
 	p ? p->host : "DIRECT",
 	hier_strings[code]);
-    fs->peer = cbdataReference(p);
+    fs->_peer = cbdataReference(p);
     fs->code = code;
     while (*FS)
 	FS = &(*FS)->next;
@@ -15,7 +15,7 @@
 
 #  Makefile for storage modules in the Squid Object Cache server
 #
-#  $Id: Makefile.in,v 1.15 2002/09/15 05:42:02 robertc Exp $
+#  $Id: Makefile.in,v 1.16 2002/09/15 06:41:17 robertc Exp $
 #
 
 SHELL = @SHELL@
@@ -74,6 +74,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -69,6 +69,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -69,6 +69,7 @@ CC = @CC@
 CGIEXT = @CGIEXT@
 CPP = @CPP@
 CRYPTLIB = @CRYPTLIB@
+CXX = @CXX@
 DEPDIR = @DEPDIR@
 DIGEST_AUTH_HELPERS = @DIGEST_AUTH_HELPERS@
 ERR_DEFAULT_LANGUAGE = @ERR_DEFAULT_LANGUAGE@
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ssl.cc,v 1.121 2002/09/15 06:23:29 adrian Exp $
+ * $Id: ssl.cc,v 1.122 2002/09/15 06:40:57 robertc Exp $
  *
  * DEBUG: section 26    Secure Sockets Layer Proxy
  * AUTHOR: Duane Wessels
@@ -386,9 +386,9 @@ sslConnectDone(int fdnotused, comm_err_t status, void *data)
     SslStateData *sslState = data;
     request_t *request = sslState->request;
     ErrorState *err = NULL;
-    if (sslState->servers->peer)
+    if (sslState->servers->_peer)
 	hierarchyNote(&sslState->request->hier, sslState->servers->code,
-	    sslState->servers->peer->host);
+	    sslState->servers->_peer->host);
     else if (Config.onoff.log_ip_on_direct)
 	hierarchyNote(&sslState->request->hier, sslState->servers->code,
 	    fd_table[sslState->server.fd].ipaddr);
@@ -415,7 +415,7 @@ sslConnectDone(int fdnotused, comm_err_t status, void *data)
 	err->callback_data = sslState;
 	errorSend(sslState->client.fd, err);
     } else {
-	if (sslState->servers->peer)
+	if (sslState->servers->_peer)
 	    sslProxyConnected(sslState->server.fd, sslState);
 	else
 	    sslConnected(sslState->server.fd, sslState);
@@ -578,18 +578,18 @@ sslPeerSelectComplete(FwdServer * fs, void *data)
 	return;
     }
     sslState->servers = fs;
-    sslState->host = fs->peer ? fs->peer->host : request->host;
-    if (fs->peer == NULL) {
+    sslState->host = fs->_peer ? fs->_peer->host : request->host;
+    if (fs->_peer == NULL) {
 	sslState->port = request->port;
-    } else if (fs->peer->http_port != 0) {
-	sslState->port = fs->peer->http_port;
-    } else if ((g = peerFindByName(fs->peer->host))) {
+    } else if (fs->_peer->http_port != 0) {
+	sslState->port = fs->_peer->http_port;
+    } else if ((g = peerFindByName(fs->_peer->host))) {
 	sslState->port = g->http_port;
     } else {
 	sslState->port = CACHE_HTTP_PORT;
     }
-    if (fs->peer) {
-	sslState->request->peer_login = fs->peer->login;
+    if (fs->_peer) {
+	sslState->request->peer_login = fs->_peer->login;
 	sslState->request->flags.proxying = 1;
     } else {
 	sslState->request->peer_login = NULL;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: stat.cc,v 1.356 2002/04/07 22:16:47 hno Exp $
+ * $Id: stat.cc,v 1.357 2002/09/15 06:40:58 robertc Exp $
  *
  * DEBUG: section 18    Cache Manager Statistics
  * AUTHOR: Harvest Derived
@@ -1439,7 +1439,7 @@ statClientRequests(StoreEntry * s)
 		conn->defer.n, (long int) conn->defer.until);
 	}
 	storeAppendPrintf(s, "uri %s\n", http->uri);
-	storeAppendPrintf(s, "log_type %s\n", log_tags[http->log_type]);
+	storeAppendPrintf(s, "logType %s\n", log_tags[http->logType]);
 	storeAppendPrintf(s, "out.offset %ld, out.size %lu\n",
 	    (long int) http->out.offset, (unsigned long int) http->out.size);
 	storeAppendPrintf(s, "req_sz %ld\n", (long int) http->req_sz);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: structs.h,v 1.429 2002/09/15 05:41:57 robertc Exp $
+ * $Id: structs.h,v 1.430 2002/09/15 06:40:58 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -249,31 +249,31 @@ struct _acl {
 
 struct _acl_list {
     int op;
-    acl *acl;
+    acl *_acl;
     acl_list *next;
 };
 
 struct _acl_access {
     int allow;
-    acl_list *acl_list;
+    acl_list *aclList;
     char *cfgline;
     acl_access *next;
 };
 
 struct _acl_address {
     acl_address *next;
-    acl_list *acl_list;
+    acl_list *aclList;
     struct in_addr addr;
 };
 
 struct _acl_tos {
     acl_tos *next;
-    acl_list *acl_list;
+    acl_list *aclList;
     int tos;
 };
 
 struct _aclCheck_t {
-    const acl_access *access_list;
+    const acl_access *accessList;
     struct in_addr src_addr;
     struct in_addr dst_addr;
     struct in_addr my_addr;
@@ -378,7 +378,7 @@ struct _SquidConfig {
     struct {
 	char *relayHost;
 	u_short relayPort;
-	peer *peer;
+	peer *_peer;
     } Wais;
     struct {
 	size_t min;
@@ -792,7 +792,7 @@ struct _fde {
     time_t timeout;
     void *timeout_data;
     void *lifetime_data;
-    close_handler *close_handler;	/* linked list */
+    close_handler *closeHandler;	/* linked list */
     DEFER *defer_check;		/* check if we should defer read */
     void *defer_data;
     CommWriteStateData *rwstate;	/* State data for comm_write */
@@ -974,7 +974,7 @@ struct _HttpStateData {
     char *reply_hdr;
     size_t reply_hdr_size;
     int reply_hdr_state;
-    peer *peer;			/* peer request made to */
+    peer *_peer;		/* peer request made to */
     int eof;			/* reached end-of-object? */
     request_t *orig_request;
     int fd;
@@ -1044,7 +1044,7 @@ struct _AccessLogEntry {
     } headers;
     struct {
 	const char *method_str;
-    } private;
+    } _private;
     HierarchyLogEntry hier;
 };
 
@@ -1074,7 +1074,7 @@ struct _clientHttpRequest {
     size_t req_sz;		/* raw request size on input, not current request size */
     StoreEntry *entry;
     StoreEntry *old_entry;
-    log_type log_type;
+    log_type logType;
     struct timeval start;
     http_version_t http_ver;
     AccessLogEntry al;
@@ -1677,7 +1677,7 @@ struct _request_t {
     ConnStateData *body_connection;	/* used by clientReadBody() */
     int content_length;
     HierarchyLogEntry hier;
-    err_type err_type;
+    err_type errType;
     char *peer_login;		/* Configured peer login:password */
     time_t lastmod;		/* Used on refreshes */
     const char *vary_headers;	/* Used when varying entities are detected. Changes how the store key is calculated */
@@ -1719,7 +1719,7 @@ struct _CommWriteStateData {
 struct _ErrorState {
     err_type type;
     int page_id;
-    http_status http_status;
+    http_status httpStatus;
     auth_user_request_t *auth_user_request;
     request_t *request;
     char *url;
@@ -1942,7 +1942,7 @@ struct _CacheDigest {
 };
 
 struct _FwdServer {
-    peer *peer;			/* NULL --> origin server */
+    peer *_peer;		/* NULL --> origin server */
     hier_code code;
     FwdServer *next;
 };
@@ -1,6 +1,6 @@
 
 /*
- * $Id: tunnel.cc,v 1.121 2002/09/15 06:23:29 adrian Exp $
+ * $Id: tunnel.cc,v 1.122 2002/09/15 06:40:57 robertc Exp $
  *
  * DEBUG: section 26    Secure Sockets Layer Proxy
  * AUTHOR: Duane Wessels
@@ -386,9 +386,9 @@ sslConnectDone(int fdnotused, comm_err_t status, void *data)
     SslStateData *sslState = data;
     request_t *request = sslState->request;
     ErrorState *err = NULL;
-    if (sslState->servers->peer)
+    if (sslState->servers->_peer)
 	hierarchyNote(&sslState->request->hier, sslState->servers->code,
-	    sslState->servers->peer->host);
+	    sslState->servers->_peer->host);
     else if (Config.onoff.log_ip_on_direct)
 	hierarchyNote(&sslState->request->hier, sslState->servers->code,
 	    fd_table[sslState->server.fd].ipaddr);
@@ -415,7 +415,7 @@ sslConnectDone(int fdnotused, comm_err_t status, void *data)
 	err->callback_data = sslState;
 	errorSend(sslState->client.fd, err);
     } else {
-	if (sslState->servers->peer)
+	if (sslState->servers->_peer)
 	    sslProxyConnected(sslState->server.fd, sslState);
 	else
 	    sslConnected(sslState->server.fd, sslState);
@@ -578,18 +578,18 @@ sslPeerSelectComplete(FwdServer * fs, void *data)
 	return;
     }
     sslState->servers = fs;
-    sslState->host = fs->peer ? fs->peer->host : request->host;
-    if (fs->peer == NULL) {
+    sslState->host = fs->_peer ? fs->_peer->host : request->host;
+    if (fs->_peer == NULL) {
 	sslState->port = request->port;
-    } else if (fs->peer->http_port != 0) {
-	sslState->port = fs->peer->http_port;
-    } else if ((g = peerFindByName(fs->peer->host))) {
+    } else if (fs->_peer->http_port != 0) {
+	sslState->port = fs->_peer->http_port;
+    } else if ((g = peerFindByName(fs->_peer->host))) {
 	sslState->port = g->http_port;
     } else {
 	sslState->port = CACHE_HTTP_PORT;
     }
-    if (fs->peer) {
-	sslState->request->peer_login = fs->peer->login;
+    if (fs->_peer) {
+	sslState->request->peer_login = fs->_peer->login;
 	sslState->request->flags.proxying = 1;
     } else {
 	sslState->request->peer_login = NULL;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: typedefs.h,v 1.136 2002/09/15 06:23:29 adrian Exp $
+ * $Id: typedefs.h,v 1.137 2002/09/15 06:40:58 robertc Exp $
  *
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
@@ -65,12 +65,12 @@ typedef struct _authScheme authScheme;
 typedef struct _acl_user_data acl_user_data;
 typedef struct _acl_user_ip_data acl_user_ip_data;
 typedef struct _acl_arp_data acl_arp_data;
-typedef struct _acl acl;
 typedef struct _acl_snmp_comm acl_snmp_comm;
 typedef struct _acl_list acl_list;
 typedef struct _acl_access acl_access;
 typedef struct _acl_address acl_address;
 typedef struct _acl_tos acl_tos;
+typedef struct _acl acl;
 typedef struct _aclCheck_t aclCheck_t;
 typedef struct _wordlist wordlist;
 typedef struct _intlist intlist;