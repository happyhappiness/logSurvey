@@ -20,7 +20,7 @@
 #include "DelayId.h"
 #include "DelayPool.h"
 #include "DelayPools.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpRequest.h"
 #include "SquidConfig.h"
 
@@ -31,7 +31,7 @@
 #include "gopher.h"
 #include "hier_code.h"
 #include "http.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "icmp/net_db.h"
@@ -10,7 +10,7 @@
 
 #include "squid.h"
 #include "client_side_request.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpHeaderRange.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
@@ -20,7 +20,7 @@
 #include "fde.h"
 #include "globals.h"
 #include "http/RegisteredHeaders.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpHdrContRange.h"
 #include "HttpHeader.h"
 #include "HttpHeaderFieldInfo.h"
@@ -19,7 +19,7 @@
 #include "gopher.h"
 #include "http.h"
 #include "http/one/RequestParser.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpHdrCc.h"
 #include "HttpHeaderRange.h"
 #include "HttpRequest.h"
@@ -13,7 +13,7 @@
 #include "client_side.h"
 #include "ConfigParser.h"
 #include "globals.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "SquidConfig.h"
@@ -13,23 +13,23 @@
 #include "anyp/PortCfg.h"
 #include "client_side.h"
 #include "Debug.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "Pipeline.h"
 
 void
-Pipeline::add(const Http::StreamContextPointer &c)
+Pipeline::add(const Http::StreamPointer &c)
 {
     requests.push_back(c);
     ++nrequests;
     debugs(33, 3, "Pipeline " << (void*)this << " add request " << nrequests << ' ' << c);
 }
 
-Http::StreamContextPointer
+Http::StreamPointer
 Pipeline::front() const
 {
     if (requests.empty()) {
         debugs(33, 3, "Pipeline " << (void*)this << " empty");
-        return Http::StreamContextPointer();
+        return Http::StreamPointer();
     }
 
     debugs(33, 3, "Pipeline " << (void*)this << " front " << requests.front());
@@ -40,7 +40,7 @@ void
 Pipeline::terminateAll(int xerrno)
 {
     while (!requests.empty()) {
-        Http::StreamContextPointer context = requests.front();
+        Http::StreamPointer context = requests.front();
         debugs(33, 3, "Pipeline " << (void*)this << " notify(" << xerrno << ") " << context);
         context->noteIoError(xerrno);
         context->finished();  // cleanup and self-deregister
@@ -49,7 +49,7 @@ Pipeline::terminateAll(int xerrno)
 }
 
 void
-Pipeline::popMe(const Http::StreamContextPointer &which)
+Pipeline::popMe(const Http::StreamPointer &which)
 {
     if (requests.empty())
         return;
@@ -41,10 +41,10 @@ class Pipeline
     ~Pipeline() = default;
 
     /// register a new request context to the pipeline
-    void add(const Http::StreamContextPointer &);
+    void add(const Http::StreamPointer &);
 
     /// get the first request context in the pipeline
-    Http::StreamContextPointer front() const;
+    Http::StreamPointer front() const;
 
     /// how many requests are currently pipelined
     size_t count() const {return requests.size();}
@@ -56,15 +56,15 @@ class Pipeline
     void terminateAll(const int xerrno);
 
     /// deregister the front request from the pipeline
-    void popMe(const Http::StreamContextPointer &);
+    void popMe(const Http::StreamPointer &);
 
     /// Number of requests seen in this pipeline (so far).
     /// Includes incomplete transactions.
     uint32_t nrequests;
 
 private:
     /// requests parsed from the connection but not yet completed.
-    std::list<Http::StreamContextPointer> requests;
+    std::list<Http::StreamPointer> requests;
 };
 
 #endif /* SQUID_SRC_PIPELINE_H */
@@ -14,7 +14,7 @@
 #include "acl/AtStepData.h"
 #include "acl/Checklist.h"
 #include "client_side.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "ssl/ServerBump.h"
 
 int
@@ -21,7 +21,7 @@
 #include "client_side.h"
 #include "fde.h"
 #include "globals.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpRequest.h"
 
 int
@@ -13,7 +13,7 @@
 #include "acl/FilledChecklist.h"
 #include "client_side.h"
 #include "comm/Connection.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpRequest.h"
 #include "SquidConfig.h"
 
@@ -17,7 +17,7 @@
 #include "acl/RegexData.h"
 #include "acl/UserData.h"
 #include "client_side.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 
 ACLExtUser::~ACLExtUser()
 {
@@ -12,7 +12,7 @@
 #include "comm/Connection.h"
 #include "comm/forward.h"
 #include "ExternalACLEntry.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "SquidConfig.h"
@@ -12,7 +12,7 @@
 #include "acl/StringData.h"
 #include "anyp/PortCfg.h"
 #include "client_side.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpRequest.h"
 
 int
@@ -15,7 +15,7 @@
 #include "acl/ServerCertificate.h"
 #include "client_side.h"
 #include "fde.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "ssl/ServerBump.h"
 
 int
@@ -15,7 +15,7 @@
 #include "acl/ServerName.h"
 #include "client_side.h"
 #include "fde.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpRequest.h"
 #include "ipcache.h"
 #include "SquidString.h"
@@ -14,7 +14,7 @@
 #include "auth/UserRequest.h"
 #include "client_side.h"
 #include "fatal.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpRequest.h"
 
 /**
@@ -18,7 +18,7 @@
 #include "auth/User.h"
 #include "auth/UserRequest.h"
 #include "client_side.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpRequest.h"
 
 ACLProxyAuth::~ACLProxyAuth()
@@ -28,7 +28,7 @@
 #include "auth/UserRequest.h"
 #include "client_side.h"
 #include "globals.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 
@@ -21,7 +21,7 @@
 #include "comm/Connection.h"
 #include "fatal.h"
 #include "format/Format.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "MemBuf.h"
@@ -22,7 +22,7 @@
 #include "cache_cf.h"
 #include "client_side.h"
 #include "helper.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -20,7 +20,7 @@
 #include "globals.h"
 #include "helper.h"
 #include "helper/Reply.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -22,7 +22,7 @@
 #include "cache_cf.h"
 #include "client_side.h"
 #include "helper.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -20,7 +20,7 @@
 #include "globals.h"
 #include "helper.h"
 #include "helper/Reply.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpMsg.h"
 #include "HttpRequest.h"
 #include "MemBuf.h"
@@ -11,7 +11,7 @@
 #include "squid.h"
 #include "client_side_request.h"
 #include "clientStream.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 
@@ -87,7 +87,7 @@
 #include "http.h"
 #include "http/one/RequestParser.h"
 #include "http/one/TeChunkedParser.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpHdrContRange.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
@@ -189,7 +189,7 @@ static void clientUpdateStatCounters(const LogTags &logType);
 static void clientUpdateHierCounters(HierarchyLogEntry *);
 static bool clientPingHasFinished(ping_data const *aPing);
 void prepareLogWithRequestDetails(HttpRequest *, AccessLogEntry::Pointer &);
-static void ClientSocketContextPushDeferredIfNeeded(Http::StreamContextPointer deferredRequest, ConnStateData * conn);
+static void ClientSocketContextPushDeferredIfNeeded(Http::StreamPointer deferredRequest, ConnStateData * conn);
 
 char *skipLeadingSpace(char *aString);
 
@@ -807,7 +807,7 @@ clientSocketRecipient(clientStreamNode * node, ClientHttpRequest * http,
      */
     assert(cbdataReferenceValid(node));
     assert(node->node.next == NULL);
-    Http::StreamContextPointer context = dynamic_cast<Http::StreamContext *>(node->data.getRaw());
+    Http::StreamPointer context = dynamic_cast<Http::Stream *>(node->data.getRaw());
     assert(context != NULL);
 
     /* TODO: check offset is what we asked for */
@@ -840,7 +840,7 @@ clientSocketDetach(clientStreamNode * node, ClientHttpRequest * http)
     /* Set null by ContextFree */
     assert(node->node.next == NULL);
     /* this is the assert discussed above */
-    assert(NULL == dynamic_cast<Http::StreamContext *>(node->data.getRaw()));
+    assert(NULL == dynamic_cast<Http::Stream *>(node->data.getRaw()));
     /* We are only called when the client socket shutsdown.
      * Tell the prev pipeline member we're finished
      */
@@ -866,7 +866,7 @@ ConnStateData::readNextRequest()
 }
 
 static void
-ClientSocketContextPushDeferredIfNeeded(Http::StreamContextPointer deferredRequest, ConnStateData * conn)
+ClientSocketContextPushDeferredIfNeeded(Http::StreamPointer deferredRequest, ConnStateData * conn)
 {
     debugs(33, 2, HERE << conn->clientConnection << " Sending next");
 
@@ -955,7 +955,7 @@ ConnStateData::kick()
      * then look at processing it. If not, simply kickstart
      * another read.
      */
-    Http::StreamContextPointer deferredRequest = pipeline.front();
+    Http::StreamPointer deferredRequest = pipeline.front();
     if (deferredRequest != nullptr) {
         debugs(33, 3, clientConnection << ": calling PushDeferredIfNeeded");
         ClientSocketContextPushDeferredIfNeeded(deferredRequest, this);
@@ -1007,14 +1007,14 @@ ConnStateData::afterClientWrite(size_t size)
     ctx->writeComplete(size);
 }
 
-Http::StreamContext *
+Http::Stream *
 ConnStateData::abortRequestParsing(const char *const uri)
 {
     ClientHttpRequest *http = new ClientHttpRequest(this);
     http->req_sz = inBuf.length();
     http->uri = xstrdup(uri);
     setLogUri (http, uri);
-    auto *context = new Http::StreamContext(clientConnection, http);
+    auto *context = new Http::Stream(clientConnection, http);
     StoreIOBuffer tempBuffer;
     tempBuffer.data = context->reqbuf;
     tempBuffer.length = HTTP_REQBUF_SZ;
@@ -1290,9 +1290,9 @@ prepareTransparentURL(ConnStateData * conn, ClientHttpRequest *http, const Http1
  *          parsing failure
  *  \param[out] http_ver will be set as a side-effect of the parsing
  *  \return NULL on incomplete requests,
- *          a Http::StreamContext on success or failure.
+ *          a Http::Stream on success or failure.
  */
-Http::StreamContext *
+Http::Stream *
 parseHttpRequest(ConnStateData *csd, const Http1::RequestParserPointer &hp)
 {
     /* Attempt to parse the first line; this will define where the method, url, version and header begin */
@@ -1360,7 +1360,7 @@ parseHttpRequest(ConnStateData *csd, const Http1::RequestParserPointer &hp)
     ClientHttpRequest *http = new ClientHttpRequest(csd);
 
     http->req_sz = hp->messageHeaderSize();
-    Http::StreamContext *result = new Http::StreamContext(csd->clientConnection, http);
+    Http::Stream *result = new Http::Stream(csd->clientConnection, http);
 
     StoreIOBuffer tempBuffer;
     tempBuffer.data = result->reqbuf;
@@ -1471,7 +1471,7 @@ ConnStateData::quitAfterError(HttpRequest *request)
 }
 
 #if USE_OPENSSL
-bool ConnStateData::serveDelayedError(Http::StreamContext *context)
+bool ConnStateData::serveDelayedError(Http::Stream *context)
 {
     ClientHttpRequest *http = context->http;
 
@@ -1561,7 +1561,7 @@ bool ConnStateData::serveDelayedError(Http::StreamContext *context)
  * or false otherwise
  */
 bool
-clientTunnelOnError(ConnStateData *conn, Http::StreamContext *context, HttpRequest *request, const HttpRequestMethod& method, err_type requestError, Http::StatusCode errStatusCode, const char *requestErrorBytes)
+clientTunnelOnError(ConnStateData *conn, Http::Stream *context, HttpRequest *request, const HttpRequestMethod& method, err_type requestError, Http::StatusCode errStatusCode, const char *requestErrorBytes)
 {
     if (conn->port->flags.isIntercepted() &&
             Config.accessList.on_unsupported_protocol && conn->pipeline.nrequests <= 1) {
@@ -1578,7 +1578,7 @@ clientTunnelOnError(ConnStateData *conn, Http::StreamContext *context, HttpReque
                 // The below may leak client streams BodyPipe objects. BUT, we need
                 // to check if client-streams detatch is safe to do here (finished() will detatch).
                 assert(conn->pipeline.front() == context); // XXX: still assumes HTTP/1 semantics
-                conn->pipeline.popMe(Http::StreamContextPointer(context));
+                conn->pipeline.popMe(Http::StreamPointer(context));
             }
             Comm::SetSelect(conn->clientConnection->fd, COMM_SELECT_READ, NULL, NULL, 0);
             conn->fakeAConnectRequest("unknown-protocol", conn->preservedClientData);
@@ -1619,7 +1619,7 @@ clientProcessRequestFinished(ConnStateData *conn, const HttpRequest::Pointer &re
 }
 
 void
-clientProcessRequest(ConnStateData *conn, const Http1::RequestParserPointer &hp, Http::StreamContext *context)
+clientProcessRequest(ConnStateData *conn, const Http1::RequestParserPointer &hp, Http::Stream *context)
 {
     ClientHttpRequest *http = context->http;
     bool chunked = false;
@@ -2155,7 +2155,7 @@ ConnStateData::clientParseRequests()
         if (needProxyProtocolHeader_ && !parseProxyProtocolHeader())
             break;
 
-        if (Http::StreamContext *context = parseOneRequest()) {
+        if (Http::Stream *context = parseOneRequest()) {
             debugs(33, 5, clientConnection << ": done parsing a request");
 
             AsyncCall::Pointer timeoutCall = commCbCall(5, 4, "clientLifetimeTimeout",
@@ -2326,7 +2326,7 @@ ConnStateData::abortChunkedRequestBody(const err_type error)
     // but if we fail when the server connection is used already, the server may send
     // us its response too, causing various assertions. How to prevent that?
 #if WE_KNOW_HOW_TO_SEND_ERRORS
-    Http::StreamContextPointer context = pipeline.front();
+    Http::StreamPointer context = pipeline.front();
     if (context != NULL && !context->http->out.offset) { // output nothing yet
         clientStreamNode *node = context->getClientReplyContext();
         clientReplyContext *repContext = dynamic_cast<clientReplyContext*>(node->data.getRaw());
@@ -3273,7 +3273,7 @@ ConnStateData::splice()
         transferProtocol = Http::ProtocolVersion();
         // inBuf still has the "CONNECT ..." request data, reset it to SSL hello message
         inBuf.append(rbuf.content(), rbuf.contentSize());
-        Http::StreamContextPointer context = pipeline.front();
+        Http::StreamPointer context = pipeline.front();
         ClientHttpRequest *http = context->http;
         tunnelStart(http);
     }
@@ -3721,7 +3721,7 @@ ConnStateData::finishDechunkingRequest(bool withSuccess)
         Must(!bodyPipe); // we rely on it being nil after we are done with body
         if (withSuccess) {
             Must(myPipe->bodySizeKnown());
-            Http::StreamContextPointer context = pipeline.front();
+            Http::StreamPointer context = pipeline.front();
             if (context != NULL && context->http && context->http->request)
                 context->http->request->setContentLength(myPipe->bodySize());
         }
@@ -53,7 +53,7 @@ class ServerBump;
  * processed.
  *
  * Performs HTTP message processing to kick off the actual HTTP request
- * handling objects (Http::StreamContext, ClientHttpRequest, HttpRequest).
+ * handling objects (Http::Stream, ClientHttpRequest, HttpRequest).
  *
  * Performs SSL-Bump processing for switching between HTTP and HTTPS protocols.
  *
@@ -251,7 +251,7 @@ class ConnStateData : public Server, public HttpControlMsgSink, public Registere
     /// Returns false if no [delayed] error should be written to the client.
     /// Otherwise, writes the error to the client and returns true. Also checks
     /// for SQUID_X509_V_ERR_DOMAIN_MISMATCH on bumped requests.
-    bool serveDelayedError(Http::StreamContext *);
+    bool serveDelayedError(Http::Stream *);
 
     Ssl::BumpMode sslBumpMode; ///< ssl_bump decision (Ssl::bumpEnd if n/a).
 
@@ -267,7 +267,7 @@ class ConnStateData : public Server, public HttpControlMsgSink, public Registere
     virtual void writeControlMsgAndCall(HttpReply *rep, AsyncCall::Pointer &call) = 0;
 
     /// ClientStream calls this to supply response header (once) and data
-    /// for the current Http::StreamContext.
+    /// for the current Http::Stream.
     virtual void handleReply(HttpReply *header, StoreIOBuffer receivedData) = 0;
 
     /// remove no longer needed leading bytes from the input buffer
@@ -276,7 +276,7 @@ class ConnStateData : public Server, public HttpControlMsgSink, public Registere
     /* TODO: Make the methods below (at least) non-public when possible. */
 
     /// stop parsing the request and create context for relaying error info
-    Http::StreamContext *abortRequestParsing(const char *const errUri);
+    Http::Stream *abortRequestParsing(const char *const errUri);
 
     /// generate a fake CONNECT request with the given payload
     /// at the beginning of the client I/O buffer
@@ -308,10 +308,10 @@ class ConnStateData : public Server, public HttpControlMsgSink, public Registere
     /// parse input buffer prefix into a single transfer protocol request
     /// return NULL to request more header bytes (after checking any limits)
     /// use abortRequestParsing() to handle parsing errors w/o creating request
-    virtual Http::StreamContext *parseOneRequest() = 0;
+    virtual Http::Stream *parseOneRequest() = 0;
 
     /// start processing a freshly parsed request
-    virtual void processParsedRequest(Http::StreamContext *) = 0;
+    virtual void processParsedRequest(Http::Stream *) = 0;
 
     /// returning N allows a pipeline of 1+N requests (see pipeline_prefetch)
     virtual int pipelinePrefetchMax() const;
@@ -398,8 +398,8 @@ CSCB clientSocketRecipient;
 CSD clientSocketDetach;
 
 /* TODO: Move to HttpServer. Warning: Move requires large code nonchanges! */
-Http::StreamContext *parseHttpRequest(ConnStateData *, const Http1::RequestParserPointer &);
-void clientProcessRequest(ConnStateData *, const Http1::RequestParserPointer &, Http::StreamContext *);
+Http::Stream *parseHttpRequest(ConnStateData *, const Http1::RequestParserPointer &);
+void clientProcessRequest(ConnStateData *, const Http1::RequestParserPointer &, Http::Stream *);
 void clientPostHttpsAccept(ConnStateData *);
 
 #endif /* SQUID_CLIENTSIDE_H */
@@ -21,7 +21,7 @@
 #include "FwdState.h"
 #include "globals.h"
 #include "globals.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -37,7 +37,7 @@
 #include "helper.h"
 #include "helper/Reply.h"
 #include "http.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpHdrCc.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -19,7 +19,7 @@
 #include "errorpage.h"
 #include "fd.h"
 #include "ftp/Parsing.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "ip/tools.h"
 #include "SquidConfig.h"
 #include "SquidString.h"
@@ -15,7 +15,7 @@
 #include "clients/FtpClient.h"
 #include "ftp/Elements.h"
 #include "ftp/Parsing.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpHdrCc.h"
 #include "HttpRequest.h"
 #include "SBuf.h"
@@ -30,7 +30,7 @@
 #include "DelayUser.h"
 #include "DelayVector.h"
 #include "event.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "ip/Address.h"
 #include "MemObject.h"
 #include "mgr/Registration.h"
@@ -17,7 +17,7 @@
 
 #include "client_side_request.h"
 #include "esi/Context.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "Store.h"
 
 void
@@ -30,7 +30,7 @@
 #include "esi/Segment.h"
 #include "esi/VarState.h"
 #include "fatal.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpHdrSc.h"
 #include "HttpHdrScTarget.h"
 #include "HttpReply.h"
@@ -17,7 +17,7 @@
 #include "esi/Include.h"
 #include "esi/VarState.h"
 #include "fatal.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpReply.h"
 #include "log/access_log.h"
 
@@ -22,7 +22,7 @@
 #include "format/Token.h"
 #include "helper.h"
 #include "helper/Reply.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -17,7 +17,7 @@
 #include "format/Quoting.h"
 #include "format/Token.h"
 #include "fqdncache.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpRequest.h"
 #include "MemBuf.h"
 #include "rfc1738.h"
@@ -32,7 +32,7 @@
 #include "http.h"
 #include "http/one/ResponseParser.h"
 #include "http/one/TeChunkedParser.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpControlMsg.h"
 #include "HttpHdrCc.h"
 #include "HttpHdrContRange.h"
@@ -27,8 +27,8 @@ libsquid_http_la_SOURCES = \
 	StatusCode.h \
 	StatusLine.cc \
 	StatusLine.h \
-	StreamContext.cc \
-	StreamContext.h
+	Stream.cc \
+	Stream.h
 
 libsquid_http_la_LIBADD= one/libhttp1.la
 
@@ -8,13 +8,13 @@
 
 #include "squid.h"
 #include "client_side_request.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpHdrContRange.h"
 #include "HttpHeaderTools.h"
 #include "Store.h"
 #include "TimeOrTag.h"
 
-Http::StreamContext::StreamContext(const Comm::ConnectionPointer &aConn, ClientHttpRequest *aReq) :
+Http::Stream::Stream(const Comm::ConnectionPointer &aConn, ClientHttpRequest *aReq) :
     clientConnection(aConn),
     http(aReq),
     reply(nullptr),
@@ -30,10 +30,10 @@ Http::StreamContext::StreamContext(const Comm::ConnectionPointer &aConn, ClientH
     deferredparams.rep = nullptr;
 }
 
-Http::StreamContext::~StreamContext()
+Http::Stream::~Stream()
 {
     if (auto node = getTail()) {
-        if (auto ctx = dynamic_cast<Http::StreamContext *>(node->data.getRaw())) {
+        if (auto ctx = dynamic_cast<Http::Stream *>(node->data.getRaw())) {
             /* We are *always* the tail - prevent recursive free */
             assert(this == ctx);
             node->data = nullptr;
@@ -43,22 +43,22 @@ Http::StreamContext::~StreamContext()
 }
 
 void
-Http::StreamContext::registerWithConn()
+Http::Stream::registerWithConn()
 {
     assert(!connRegistered_);
     assert(getConn());
     connRegistered_ = true;
-    getConn()->pipeline.add(Http::StreamContextPointer(this));
+    getConn()->pipeline.add(Http::StreamPointer(this));
 }
 
 bool
-Http::StreamContext::startOfOutput() const
+Http::Stream::startOfOutput() const
 {
     return http->out.size == 0;
 }
 
 void
-Http::StreamContext::writeComplete(size_t size)
+Http::Stream::writeComplete(size_t size)
 {
     const StoreEntry *entry = http->storeEntry();
     debugs(33, 5, clientConnection << ", sz " << size <<
@@ -99,12 +99,12 @@ Http::StreamContext::writeComplete(size_t size)
         return;
 
     default:
-        fatal("Hit unreachable code in Http::StreamContext::writeComplete\n");
+        fatal("Hit unreachable code in Http::Stream::writeComplete\n");
     }
 }
 
 void
-Http::StreamContext::pullData()
+Http::Stream::pullData()
 {
     debugs(33, 5, reply << " written " << http->out.size << " into " << clientConnection);
 
@@ -120,13 +120,13 @@ Http::StreamContext::pullData()
 }
 
 bool
-Http::StreamContext::multipartRangeRequest() const
+Http::Stream::multipartRangeRequest() const
 {
     return http->multipartRangeRequest();
 }
 
 int64_t
-Http::StreamContext::getNextRangeOffset() const
+Http::Stream::getNextRangeOffset() const
 {
     debugs (33, 5, "range: " << http->request->range <<
             "; http offset " << http->out.offset <<
@@ -182,7 +182,7 @@ Http::StreamContext::getNextRangeOffset() const
  * \retval false
  */
 bool
-Http::StreamContext::canPackMoreRanges() const
+Http::Stream::canPackMoreRanges() const
 {
     /** first update iterator "i" if needed */
     if (!http->range_iter.debt()) {
@@ -204,7 +204,7 @@ Http::StreamContext::canPackMoreRanges() const
 
 /// Adapt stream status to account for Range cases
 clientStream_status_t
-Http::StreamContext::socketState()
+Http::Stream::socketState()
 {
     switch (clientStreamStatus(getTail(), http)) {
 
@@ -256,7 +256,7 @@ Http::StreamContext::socketState()
 }
 
 void
-Http::StreamContext::sendStartOfMessage(HttpReply *rep, StoreIOBuffer bodyData)
+Http::Stream::sendStartOfMessage(HttpReply *rep, StoreIOBuffer bodyData)
 {
     prepareReply(rep);
     assert(rep);
@@ -289,7 +289,7 @@ Http::StreamContext::sendStartOfMessage(HttpReply *rep, StoreIOBuffer bodyData)
 }
 
 void
-Http::StreamContext::sendBody(StoreIOBuffer bodyData)
+Http::Stream::sendBody(StoreIOBuffer bodyData)
 {
     if (!multipartRangeRequest() && !http->request->flags.chunkedReply) {
         size_t length = lengthToSend(bodyData.range());
@@ -312,7 +312,7 @@ Http::StreamContext::sendBody(StoreIOBuffer bodyData)
 }
 
 size_t
-Http::StreamContext::lengthToSend(Range<int64_t> const &available) const
+Http::Stream::lengthToSend(Range<int64_t> const &available) const
 {
     // the size of available range can always fit into a size_t type
     size_t maximum = available.size();
@@ -335,7 +335,7 @@ Http::StreamContext::lengthToSend(Range<int64_t> const &available) const
 }
 
 void
-Http::StreamContext::noteSentBodyBytes(size_t bytes)
+Http::Stream::noteSentBodyBytes(size_t bytes)
 {
     debugs(33, 7, bytes << " body bytes");
     http->out.offset += bytes;
@@ -391,7 +391,7 @@ clientIfRangeMatch(ClientHttpRequest * http, HttpReply * rep)
 // seems to be something better suited to Server logic
 /** adds appropriate Range headers if needed */
 void
-Http::StreamContext::buildRangeHeader(HttpReply *rep)
+Http::Stream::buildRangeHeader(HttpReply *rep)
 {
     HttpHeader *hdr = rep ? &rep->header : nullptr;
     const char *range_err = nullptr;
@@ -504,7 +504,7 @@ Http::StreamContext::buildRangeHeader(HttpReply *rep)
 }
 
 clientStreamNode *
-Http::StreamContext::getTail() const
+Http::Stream::getTail() const
 {
     if (http->client_stream.tail)
         return static_cast<clientStreamNode *>(http->client_stream.tail->data);
@@ -513,21 +513,21 @@ Http::StreamContext::getTail() const
 }
 
 clientStreamNode *
-Http::StreamContext::getClientReplyContext() const
+Http::Stream::getClientReplyContext() const
 {
     return static_cast<clientStreamNode *>(http->client_stream.tail->prev->data);
 }
 
 ConnStateData *
-Http::StreamContext::getConn() const
+Http::Stream::getConn() const
 {
     assert(http && http->getConn());
     return http->getConn();
 }
 
 /// remembers the abnormal connection termination for logging purposes
 void
-Http::StreamContext::noteIoError(const int xerrno)
+Http::Stream::noteIoError(const int xerrno)
 {
     if (http) {
         http->logType.err.timedout = (xerrno == ETIMEDOUT);
@@ -537,7 +537,7 @@ Http::StreamContext::noteIoError(const int xerrno)
 }
 
 void
-Http::StreamContext::finished()
+Http::Stream::finished()
 {
     ConnStateData *conn = getConn();
 
@@ -546,19 +546,19 @@ Http::StreamContext::finished()
 
     assert(connRegistered_);
     connRegistered_ = false;
-    conn->pipeline.popMe(Http::StreamContextPointer(this));
+    conn->pipeline.popMe(Http::StreamPointer(this));
 }
 
 /// called when we encounter a response-related error
 void
-Http::StreamContext::initiateClose(const char *reason)
+Http::Stream::initiateClose(const char *reason)
 {
     debugs(33, 4, clientConnection << " because " << reason);
     getConn()->stopSending(reason); // closes ASAP
 }
 
 void
-Http::StreamContext::deferRecipientForLater(clientStreamNode *node, HttpReply *rep, StoreIOBuffer receivedData)
+Http::Stream::deferRecipientForLater(clientStreamNode *node, HttpReply *rep, StoreIOBuffer receivedData)
 {
     debugs(33, 2, "Deferring request " << http->uri);
     assert(flags.deferred == 0);
@@ -569,7 +569,7 @@ Http::StreamContext::deferRecipientForLater(clientStreamNode *node, HttpReply *r
 }
 
 void
-Http::StreamContext::prepareReply(HttpReply *rep)
+Http::Stream::prepareReply(HttpReply *rep)
 {
     reply = rep;
     if (http->request->range)
@@ -581,7 +581,7 @@ Http::StreamContext::prepareReply(HttpReply *rep)
  * Packs the last-chunk if bodyData is empty.
  */
 void
-Http::StreamContext::packChunk(const StoreIOBuffer &bodyData, MemBuf &mb)
+Http::Stream::packChunk(const StoreIOBuffer &bodyData, MemBuf &mb)
 {
     const uint64_t length =
         static_cast<uint64_t>(lengthToSend(bodyData.range()));
@@ -597,7 +597,7 @@ Http::StreamContext::packChunk(const StoreIOBuffer &bodyData, MemBuf &mb)
  * all offsets and such.
  */
 void
-Http::StreamContext::packRange(StoreIOBuffer const &source, MemBuf *mb)
+Http::Stream::packRange(StoreIOBuffer const &source, MemBuf *mb)
 {
     HttpHdrRangeIter * i = &http->range_iter;
     Range<int64_t> available(source.range());
@@ -659,7 +659,7 @@ Http::StreamContext::packRange(StoreIOBuffer const &source, MemBuf *mb)
 }
 
 void
-Http::StreamContext::doClose()
+Http::Stream::doClose()
 {
     clientConnection->close();
 }
@@ -6,8 +6,8 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-#ifndef SQUID_SRC_HTTP_STREAMCONTEXT_H
-#define SQUID_SRC_HTTP_STREAMCONTEXT_H
+#ifndef SQUID_SRC_HTTP_STREAM_H
+#define SQUID_SRC_HTTP_STREAM_H
 
 #include "http/forward.h"
 #include "mem/forward.h"
@@ -56,20 +56,20 @@ namespace Http
  * to the deferred state.
  *
  *
- * XXX: If an async call ends the ClientHttpRequest job, Http::StreamContext
+ * XXX: If an async call ends the ClientHttpRequest job, Http::Stream
  * (and ConnStateData) may not know about it, leading to segfaults and
  * assertions. This is difficult to fix
  * because ClientHttpRequest lacks a good way to communicate its ongoing
- * destruction back to the Http::StreamContext which pretends to "own" *http.
+ * destruction back to the Http::Stream which pretends to "own" *http.
  */
-class StreamContext : public RefCountable
+class Stream : public RefCountable
 {
-    MEMPROXY_CLASS(StreamContext);
+    MEMPROXY_CLASS(Stream);
 
 public:
     /// construct with HTTP/1.x details
-    StreamContext(const Comm::ConnectionPointer &aConn, ClientHttpRequest *aReq);
-    ~StreamContext();
+    Stream(const Comm::ConnectionPointer &aConn, ClientHttpRequest *aReq);
+    ~Stream();
 
     /// register this stream with the Server
     void registerWithConn();
@@ -161,5 +161,5 @@ class StreamContext : public RefCountable
 
 } // namespace Http
 
-#endif /* SQUID_SRC_HTTP_STREAMCONTEXT_H */
+#endif /* SQUID_SRC_HTTP_STREAM_H */
 
@@ -14,8 +14,8 @@
 namespace Http
 {
 
-class StreamContext;
-typedef RefCount<Http::StreamContext> StreamContextPointer;
+class Stream;
+typedef RefCount<Http::Stream> StreamPointer;
 
 } // namespace Http
 
@@ -18,7 +18,7 @@
 #include "client_side.h"
 #include "comm/Connection.h"
 #include "globals.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "ident/AclIdent.h"
 #include "ident/Ident.h"
 
@@ -37,7 +37,7 @@
 #include "FwdState.h"
 #include "globals.h"
 #include "htcp.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpHeader.h"
 #include "HttpReply.h"
 #include "icmp/IcmpSquid.h"
@@ -20,7 +20,7 @@
 #include "globals.h"
 #include "hier_code.h"
 #include "htcp.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpRequest.h"
 #include "icmp/net_db.h"
 #include "ICP.h"
@@ -20,7 +20,7 @@
 #include "globals.h"
 #include "helper.h"
 #include "helper/Reply.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpRequest.h"
 #include "mgr/Registration.h"
 #include "redirect.h"
@@ -26,7 +26,7 @@
 #include "ftp/Parsing.h"
 #include "globals.h"
 #include "http/one/RequestParser.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpHdrCc.h"
 #include "ip/tools.h"
 #include "ipc/FdNotes.h"
@@ -126,7 +126,7 @@ Ftp::Server::doProcessRequest()
 {
     // zero pipelinePrefetchMax() ensures that there is only parsed request
     Must(pipeline.count() == 1);
-    Http::StreamContextPointer context = pipeline.front();
+    Http::StreamPointer context = pipeline.front();
     Must(context != nullptr);
 
     ClientHttpRequest *const http = context->http;
@@ -150,7 +150,7 @@ Ftp::Server::doProcessRequest()
 }
 
 void
-Ftp::Server::processParsedRequest(Http::StreamContext *)
+Ftp::Server::processParsedRequest(Http::Stream *)
 {
     Must(pipeline.count() == 1);
 
@@ -289,7 +289,7 @@ void
 Ftp::Server::notePeerConnection(Comm::ConnectionPointer conn)
 {
     // find request
-    Http::StreamContextPointer context = pipeline.front();
+    Http::StreamPointer context = pipeline.front();
     Must(context != nullptr);
     ClientHttpRequest *const http = context->http;
     Must(http != NULL);
@@ -549,7 +549,7 @@ Ftp::CommandHasPathParameter(const SBuf &cmd)
 }
 
 /// creates a context filled with an error message for a given early error
-Http::StreamContext *
+Http::Stream *
 Ftp::Server::earlyError(const EarlyErrorKind eek)
 {
     /* Default values, to be updated by the switch statement below */
@@ -603,7 +603,7 @@ Ftp::Server::earlyError(const EarlyErrorKind eek)
         // no default so that a compiler can check that we have covered all cases
     }
 
-    Http::StreamContext *context = abortRequestParsing(errUri);
+    Http::Stream *context = abortRequestParsing(errUri);
     clientStreamNode *node = context->getClientReplyContext();
     Must(node);
     clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
@@ -617,9 +617,9 @@ Ftp::Server::earlyError(const EarlyErrorKind eek)
 }
 
 /// Parses a single FTP request on the control connection.
-/// Returns a new Http::StreamContext on valid requests and all errors.
+/// Returns a new Http::Stream on valid requests and all errors.
 /// Returns NULL on incomplete requests that may still succeed given more data.
-Http::StreamContext *
+Http::Stream *
 Ftp::Server::parseOneRequest()
 {
     flags.readMore = false; // common for all but one case below
@@ -697,7 +697,7 @@ Ftp::Server::parseOneRequest()
 
         // process USER request now because it sets FTP peer host name
         if (cmd == cmdUser()) {
-            if (Http::StreamContext *errCtx = handleUserRequest(cmd, params))
+            if (Http::Stream *errCtx = handleUserRequest(cmd, params))
                 return errCtx;
         }
     }
@@ -741,8 +741,8 @@ Ftp::Server::parseOneRequest()
     http->req_sz = tok.parsedSize();
     http->uri = newUri;
 
-    Http::StreamContext *const result =
-        new Http::StreamContext(clientConnection, http);
+    Http::Stream *const result =
+        new Http::Stream(clientConnection, http);
 
     StoreIOBuffer tempBuffer;
     tempBuffer.data = result->reqbuf;
@@ -762,7 +762,7 @@ void
 Ftp::Server::handleReply(HttpReply *reply, StoreIOBuffer data)
 {
     // the caller guarantees that we are dealing with the current context only
-    Http::StreamContextPointer context = pipeline.front();
+    Http::StreamPointer context = pipeline.front();
     assert(context != nullptr);
 
     if (context->http && context->http->al != NULL &&
@@ -870,7 +870,7 @@ Ftp::Server::handleFeatReply(const HttpReply *reply, StoreIOBuffer)
 void
 Ftp::Server::handlePasvReply(const HttpReply *reply, StoreIOBuffer)
 {
-    const Http::StreamContextPointer context(pipeline.front());
+    const Http::StreamPointer context(pipeline.front());
     assert(context != nullptr);
 
     if (context->http->request->errType != ERR_NONE) {
@@ -1228,7 +1228,7 @@ Ftp::Server::wroteEarlyReply(const CommIoCbParams &io)
         return;
     }
 
-    Http::StreamContextPointer context = pipeline.front();
+    Http::StreamPointer context = pipeline.front();
     if (context != nullptr && context->http) {
         context->http->out.size += io.size;
         context->http->out.headers_sz += io.size;
@@ -1250,7 +1250,7 @@ Ftp::Server::wroteReply(const CommIoCbParams &io)
         return;
     }
 
-    Http::StreamContextPointer context = pipeline.front();
+    Http::StreamPointer context = pipeline.front();
     assert(context->http);
     context->http->out.size += io.size;
     context->http->out.headers_sz += io.size;
@@ -1340,7 +1340,7 @@ Ftp::Server::handleRequest(HttpRequest *request)
 
 /// Called to parse USER command, which is required to create an HTTP request
 /// wrapper. W/o request, the errors are handled by returning earlyError().
-Http::StreamContext *
+Http::Stream *
 Ftp::Server::handleUserRequest(const SBuf &, SBuf &params)
 {
     if (params.isEmpty())
@@ -1666,7 +1666,7 @@ Ftp::Server::connectedForData(const CommConnectCbParams &params)
         if (params.conn != NULL)
             params.conn->close();
         setReply(425, "Cannot open data connection.");
-        Http::StreamContextPointer context = pipeline.front();
+        Http::StreamPointer context = pipeline.front();
         Must(context->http);
         Must(context->http->storeEntry() != NULL);
     } else {
@@ -1681,7 +1681,7 @@ Ftp::Server::connectedForData(const CommConnectCbParams &params)
 void
 Ftp::Server::setReply(const int code, const char *msg)
 {
-    Http::StreamContextPointer context = pipeline.front();
+    Http::StreamPointer context = pipeline.front();
     ClientHttpRequest *const http = context->http;
     assert(http != NULL);
     assert(http->storeEntry() == NULL);
@@ -81,8 +81,8 @@ class Server: public ConnStateData
     };
 
     /* ConnStateData API */
-    virtual Http::StreamContext *parseOneRequest();
-    virtual void processParsedRequest(Http::StreamContext *context);
+    virtual Http::Stream *parseOneRequest();
+    virtual void processParsedRequest(Http::Stream *context);
     virtual void notePeerConnection(Comm::ConnectionPointer conn);
     virtual void clientPinnedConnectionClosed(const CommCloseCbParams &io);
     virtual void handleReply(HttpReply *header, StoreIOBuffer receivedData);
@@ -112,7 +112,7 @@ class Server: public ConnStateData
 
     void calcUri(const SBuf *file);
     void changeState(const Ftp::ServerState newState, const char *reason);
-    Http::StreamContext *handleUserRequest(const SBuf &cmd, SBuf &params);
+    Http::Stream *handleUserRequest(const SBuf &cmd, SBuf &params);
     bool checkDataConnPost() const;
     void replyDataWritingCheckpoint();
     void maybeReadUploadData();
@@ -126,7 +126,7 @@ class Server: public ConnStateData
     void writeForwardedReplyAndCall(const HttpReply *reply, AsyncCall::Pointer &call);
     void writeReply(MemBuf &mb);
 
-    Http::StreamContext *earlyError(const EarlyErrorKind eek);
+    Http::Stream *earlyError(const EarlyErrorKind eek);
     bool handleRequest(HttpRequest *);
     void setDataCommand();
     bool checkDataConnPre();
@@ -15,7 +15,7 @@
 #include "client_side_request.h"
 #include "comm/Write.h"
 #include "http/one/RequestParser.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpHeaderTools.h"
 #include "profiler/Profiler.h"
 #include "servers/Http1Server.h"
@@ -71,7 +71,7 @@ Http::One::Server::noteMoreBodySpaceAvailable(BodyPipe::Pointer)
     readSomeData();
 }
 
-Http::StreamContext *
+Http::Stream *
 Http::One::Server::parseOneRequest()
 {
     PROF_start(HttpServer_parseOneRequest);
@@ -83,17 +83,17 @@ Http::One::Server::parseOneRequest()
         parser_ = new Http1::RequestParser();
 
     /* Process request */
-    Http::StreamContext *context = parseHttpRequest(this, parser_);
+    Http::Stream *context = parseHttpRequest(this, parser_);
 
     PROF_stop(HttpServer_parseOneRequest);
     return context;
 }
 
 void clientProcessRequestFinished(ConnStateData *conn, const HttpRequest::Pointer &request);
-bool clientTunnelOnError(ConnStateData *conn, Http::StreamContext *context, HttpRequest *request, const HttpRequestMethod& method, err_type requestError, Http::StatusCode errStatusCode, const char *requestErrorBytes);
+bool clientTunnelOnError(ConnStateData *conn, Http::Stream *context, HttpRequest *request, const HttpRequestMethod& method, err_type requestError, Http::StatusCode errStatusCode, const char *requestErrorBytes);
 
 bool
-Http::One::Server::buildHttpRequest(Http::StreamContext *context)
+Http::One::Server::buildHttpRequest(Http::Stream *context)
 {
     HttpRequest::Pointer request;
     ClientHttpRequest *http = context->http;
@@ -180,14 +180,14 @@ Http::One::Server::buildHttpRequest(Http::StreamContext *context)
 }
 
 void
-Http::One::Server::proceedAfterBodyContinuation(Http::StreamContextPointer context)
+Http::One::Server::proceedAfterBodyContinuation(Http::StreamPointer context)
 {
     debugs(33, 5, "Body Continuation written");
     clientProcessRequest(this, parser_, context.getRaw());
 }
 
 void
-Http::One::Server::processParsedRequest(Http::StreamContext *context)
+Http::One::Server::processParsedRequest(Http::Stream *context)
 {
     if (!buildHttpRequest(context))
         return;
@@ -222,8 +222,8 @@ Http::One::Server::processParsedRequest(Http::StreamContext *context)
                 HttpReply::Pointer rep = new HttpReply;
                 rep->sline.set(Http::ProtocolVersion(), Http::scContinue);
 
-                typedef UnaryMemFunT<Http1::Server, Http::StreamContextPointer> CbDialer;
-                const AsyncCall::Pointer cb = asyncCall(11, 3,  "Http1::Server::proceedAfterBodyContinuation", CbDialer(this, &Http1::Server::proceedAfterBodyContinuation, Http::StreamContextPointer(context)));
+                typedef UnaryMemFunT<Http1::Server, Http::StreamPointer> CbDialer;
+                const AsyncCall::Pointer cb = asyncCall(11, 3,  "Http1::Server::proceedAfterBodyContinuation", CbDialer(this, &Http1::Server::proceedAfterBodyContinuation, Http::StreamPointer(context)));
                 sendControlMsg(HttpControlMsg(rep, cb));
                 return;
             }
@@ -243,7 +243,7 @@ void
 Http::One::Server::handleReply(HttpReply *rep, StoreIOBuffer receivedData)
 {
     // the caller guarantees that we are dealing with the current context only
-    Http::StreamContextPointer context = pipeline.front();
+    Http::StreamPointer context = pipeline.front();
     Must(context != nullptr);
     const ClientHttpRequest *http = context->http;
     Must(http != NULL);
@@ -29,8 +29,8 @@ class Server: public ConnStateData
 
 protected:
     /* ConnStateData API */
-    virtual Http::StreamContext *parseOneRequest();
-    virtual void processParsedRequest(Http::StreamContext *context);
+    virtual Http::Stream *parseOneRequest();
+    virtual void processParsedRequest(Http::Stream *context);
     virtual void handleReply(HttpReply *rep, StoreIOBuffer receivedData);
     virtual void writeControlMsgAndCall(HttpReply *rep, AsyncCall::Pointer &call);
     virtual time_t idleTimeout() const;
@@ -42,17 +42,17 @@ class Server: public ConnStateData
     /* AsyncJob API */
     virtual void start();
 
-    void proceedAfterBodyContinuation(Http::StreamContextPointer context);
+    void proceedAfterBodyContinuation(Http::StreamPointer context);
 
 private:
-    void processHttpRequest(Http::StreamContext *const context);
+    void processHttpRequest(Http::Stream *const context);
     void handleHttpRequestData();
 
     /// Handles parsing results. May generate and deliver an error reply
     /// to the client if parsing is failed, or parses the url and build the
     /// HttpRequest object using parsing results.
     /// Return false if parsing is failed, true otherwise.
-    bool buildHttpRequest(Http::StreamContext *context);
+    bool buildHttpRequest(Http::Stream *context);
 
     Http1::RequestParserPointer parser_;
     HttpRequestMethod method_; ///< parsed HTTP method
@@ -14,7 +14,7 @@
 #include "Debug.h"
 #include "fd.h"
 #include "fde.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "MasterXaction.h"
 #include "servers/Server.h"
 #include "SquidConfig.h"
@@ -18,7 +18,7 @@
 #include "fde.h"
 #include "globals.h"
 #include "helper/ResultCode.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpRequest.h"
 #include "neighbors.h"
 #include "security/NegotiationHistory.h"
@@ -12,7 +12,7 @@
 
 #include "client_side.h"
 #include "FwdState.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "ssl/ServerBump.h"
 #include "Store.h"
 #include "StoreClient.h"
@@ -19,7 +19,7 @@
 #include "fde.h"
 #include "format/Token.h"
 #include "globals.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpRequest.h"
 #include "IoStats.h"
 #include "mem/Pool.h"
@@ -8,7 +8,7 @@
 
 #include "squid.h"
 #include "client_side_request.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 
 #define STUB_API "client_side.cc"
 #include "tests/STUB.h"
@@ -47,7 +47,7 @@ void ConnStateData::sslCrtdHandleReplyWrapper(void *, const Helper::Reply &) STU
 void ConnStateData::sslCrtdHandleReply(const Helper::Reply &) STUB
 void ConnStateData::switchToHttps(HttpRequest *, Ssl::BumpMode) STUB
 void ConnStateData::buildSslCertGenerationParams(Ssl::CertificateProperties &) STUB
-bool ConnStateData::serveDelayedError(Http::StreamContext *) STUB_RETVAL(false)
+bool ConnStateData::serveDelayedError(Http::Stream *) STUB_RETVAL(false)
 #endif
 
 void setLogUri(ClientHttpRequest *, char const *, bool) STUB
@@ -8,7 +8,7 @@
 
 #include "squid.h"
 #include "client_side_request.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "Store.h"
 
 #if !_USE_INLINE_
@@ -17,7 +17,7 @@
 #include "fqdncache.h"
 #include "fs_io.h"
 #include "htcp.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "ICP.h"
 #include "ip/Intercept.h"
 #include "ip/QosConfig.h"
@@ -25,7 +25,7 @@
 #include "FwdState.h"
 #include "globals.h"
 #include "http.h"
-#include "http/StreamContext.h"
+#include "http/Stream.h"
 #include "HttpRequest.h"
 #include "HttpStateFlags.h"
 #include "ip/QosConfig.h"
@@ -1241,7 +1241,7 @@ switchToTunnel(HttpRequest *request, Comm::ConnectionPointer &clientConn, Comm::
     tunnelState = new TunnelStateData;
     tunnelState->url = SBufToCstring(url);
     tunnelState->request = request;
-    tunnelState->server.size_ptr = NULL; //Set later if Http::StreamContext is available
+    tunnelState->server.size_ptr = NULL; //Set later if Http::Stream is available
 
     // Temporary static variable to store the unneeded for our case status code
     static int status_code = 0;
@@ -1250,7 +1250,7 @@ switchToTunnel(HttpRequest *request, Comm::ConnectionPointer &clientConn, Comm::
 
     ConnStateData *conn;
     if ((conn = request->clientConnectionManager.get())) {
-        Http::StreamContextPointer context = conn->pipeline.front();
+        Http::StreamPointer context = conn->pipeline.front();
         if (context != nullptr && context->http != nullptr) {
             tunnelState->logTag_ptr = &context->http->logType;
             tunnelState->server.size_ptr = &context->http->out.size;