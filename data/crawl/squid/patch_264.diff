@@ -44,30 +44,34 @@
 #serial 4
 
 m4_define([_AX_CXX_COMPILE_STDCXX_11_testbody], [[
-  template <typename T>
+    template <typename T>
     struct check
     {
-      static_assert(sizeof(int) <= sizeof(T), "not big enough");
+      static_assert(sizeof(int) <= sizeof(T), "not big enough"); // GCC 4.3+
     };
 
+#if WHEN_SQUID_HAS_MANDATORY_GCC_4_789_SUPPORT
     struct Base {
     virtual void f() {}
     };
     struct Child : public Base {
-    virtual void f() override {}
+    virtual void f() override {} // GCC 4.7+
     };
+#endif
 
-    typedef check<check<bool>> right_angle_brackets;
+    typedef check<check<bool>> right_angle_brackets; // GCC 4.3+
 
     int a;
-    decltype(a) b;
+    decltype(a) b; // GCC 4.3+
 
     typedef check<int> check_type;
     check_type c;
-    check_type&& cr = static_cast<check_type&&>(c);
+    check_type&& cr = static_cast<check_type&&>(c); // GCC 4.3+
 
-    auto d = a;
-    auto l = [](){};
+    auto d = a;      // GCC 4.4+
+#if WHEN_SQUID_HAS_MANDATORY_GCC_4_789_SUPPORT
+    auto l = [](){}; // GCC 4.5+ (void lambda seems not to be documented)
+#endif
 ]])
 
 AC_DEFUN([AX_CXX_COMPILE_STDCXX_11], [dnl
@@ -414,7 +414,9 @@ typedef struct {
 #define _pioinfo(i) ( __pioinfo[(i) >> IOINFO_L2E] + ((i) & (IOINFO_ARRAY_ELTS - 1)) )
 #define _osfile(i)  ( _pioinfo(i)->osfile )
 #define _osfhnd(i)  ( _pioinfo(i)->osfhnd )
+#if !defined(FOPEN)
 #define FOPEN           0x01    /* file handle open */
+#endif
 
 #if defined(_MSC_VER)
 SQUIDCEXTERN _CRTIMP ioinfo * __pioinfo[];
@@ -24,7 +24,7 @@ <H2><A NAME="toc1">1.</A> <A HREF="#s1">Notice</A></H2>
 <H2><A NAME="toc2">2.</A> <A HREF="#s2">Major new features since Squid-3.5</A></H2>
 
 <UL>
-<LI><A NAME="toc2.1">2.1</A> <A HREF="#ss2.1">BLAH</A>
+<LI><A NAME="toc2.1">2.1</A> <A HREF="#ss2.1">Configurable helper queue size</A>
 </UL>
 <P>
 <H2><A NAME="toc3">3.</A> <A HREF="#s3">Changes to squid.conf since Squid-3.5</A></H2>
@@ -91,12 +91,11 @@ <H2><A NAME="s2">2.</A> <A HREF="#toc2">Major new features since Squid-3.5</A></
 <P>Most user-facing changes are reflected in squid.conf (see below).</P>
 
 
-<H2><A NAME="ss2.1">2.1</A> <A HREF="#toc2.1">BLAH</A>
+<H2><A NAME="ss2.1">2.1</A> <A HREF="#toc2.1">Configurable helper queue size</A>
 </H2>
 
-<P>Details at 
-<A HREF="http://wiki.squid-cache.org/Features/BLAH">http://wiki.squid-cache.org/Features/BLAH</A>.</P>
-
+<P>The new queue-size=N option to helpers configuration, allows users 
+to configure the maximum number of queued requests to busy helpers.</P>
 
 <H2><A NAME="s3">3.</A> <A HREF="#toc3">Changes to squid.conf since Squid-3.5</A></H2>
 
@@ -128,7 +127,29 @@ <H2><A NAME="modifiedtags"></A> <A NAME="ss3.2">3.2</A> <A HREF="#toc3.2">Change
 
 <P>
 <DL>
+<DT><B> auth_param </B><DD>
+<P> New parameter <EM>queue-size=</EM> to set the maximum number
+of queued requests.</P>
+
+<DT><B>external_acl_type</B><DD>
+
+<DT><B></B><DD>
+<P> New parameter <EM>queue-size=</EM> to set the maximum number
+of queued requests.</P>
+
+<DT><B>url_rewrite_children</B><DD>
+
+<DT><B></B><DD>
+<P> New parameter <EM>queue-size=</EM> to set the maximum number
+of queued requests.</P>
+
+<DT><B>sslcrtd_children</B><DD>
+<P> New parameter <EM>queue-size=</EM> to set the maximum number
+of queued requests.</P>
 
+<DT><B>sslcrtvalidator_children</B><DD>
+<P> New parameter <EM>queue-size=</EM> to set the maximum number
+of queued requests.</P>
 </DL>
 </P>
 
@@ -44,9 +44,9 @@ The 3.6 change history can be <url url="http://www.squid-cache.org/Versions/v3/3
 Most user-facing changes are reflected in squid.conf (see below).
 
 
-<sect1>BLAH
-<p>Details at <url url="http://wiki.squid-cache.org/Features/BLAH">.
-
+<sect1>Configurable helper queue size
+<p>The new queue-size=N option to helpers configuration, allows users 
+to configure the maximum number of queued requests to busy helpers.
 
 <sect>Changes to squid.conf since Squid-3.5
 <p>
@@ -70,7 +70,25 @@ This section gives a thorough account of those changes in three categories:
 <sect1>Changes to existing tags<label id="modifiedtags">
 <p>
 <descrip>
+         <tag> auth_param </tag>
+         <p> New parameter <em>queue-size=</em> to set the maximum number
+             of queued requests.
+
+         <tag>external_acl_type<tag>
+         <p> New parameter <em>queue-size=</em> to set the maximum number
+             of queued requests.
+
+         <tag>url_rewrite_children<tag>
+         <p> New parameter <em>queue-size=</em> to set the maximum number
+             of queued requests.
+
+         <tag>sslcrtd_children</tag>
+         <p> New parameter <em>queue-size=</em> to set the maximum number
+             of queued requests.
 
+         <tag>sslcrtvalidator_children</tag>
+         <p> New parameter <em>queue-size=</em> to set the maximum number
+             of queued requests.
 </descrip>
 
 <sect1>Removed tags<label id="removedtags">
@@ -14,8 +14,8 @@
 #include "comm/Connection.h"
 #include "HierarchyLogEntry.h"
 #include "http/ProtocolVersion.h"
-#include "HttpHeader.h"
 #include "http/RequestMethod.h"
+#include "HttpHeader.h"
 #include "icp_opcode.h"
 #include "ip/Address.h"
 #include "LogTags.h"
@@ -41,19 +41,31 @@ DelaySpec::dump (StoreEntry *entry) const
 void
 DelaySpec::parse()
 {
-    int r;
-    char *token;
-    token = strtok(NULL, "/");
-
+    // get the token.
+    char *token = ConfigParser::NextToken();
     if (token == NULL)
         self_destruct();
 
-    if (sscanf(token, "%d", &r) != 1)
-        self_destruct();
+    // no-limit value
+    if (strcmp(token, "none") == 0 || token[0] == '-') {
+        restore_bps = -1;
+        max_bytes = -1;
+        return;
+    }
 
-    restore_bps = r;
+    // parse the first digits into restore_bps
+    const char *p = NULL;
+    if (!StringToInt(token, restore_bps, &p, 10) && *p != '/') {
+        debugs(77, DBG_CRITICAL, "ERROR: invalid delay rate '" << token << "'. Expecting restore/max or 'none'.");
+        self_destruct();
+    }
+    p++; // increment past the '/'
 
-    max_bytes = GetInteger64();
+    // parse the rest into max_bytes
+    if (!StringToInt64(p, max_bytes, NULL, 10)) {
+        debugs(77, DBG_CRITICAL, "ERROR: restore rate in '" << token << "' is not a number.");
+        self_destruct();
+    }
 }
 
 #endif
@@ -112,6 +112,7 @@ HttpRequest::init()
     icapHistory_ = NULL;
 #endif
     rangeOffsetLimit = -2; //a value of -2 means not checked yet
+    forcedBodyContinuation = false;
 }
 
 void
@@ -252,6 +253,8 @@ HttpRequest::inheritProperties(const HttpMsg *aMsg)
 
     myportname = aReq->myportname;
 
+    forcedBodyContinuation = aReq->forcedBodyContinuation;
+
     // main property is which connection the request was received on (if any)
     clientConnectionManager = aReq->clientConnectionManager;
 
@@ -13,8 +13,8 @@
 #include "Debug.h"
 #include "err_type.h"
 #include "HierarchyLogEntry.h"
-#include "HttpMsg.h"
 #include "http/RequestMethod.h"
+#include "HttpMsg.h"
 #include "Notes.h"
 #include "RequestFlags.h"
 #include "URL.h"
@@ -202,6 +202,9 @@ class HttpRequest: public HttpMsg
     /// A strong etag of the cached entry. Used for refreshing that entry.
     String etag;
 
+    /// whether we have responded with HTTP 100 or FTP 150 already
+    bool forcedBodyContinuation;
+
 public:
     bool multipartRangeRequest() const;
 
@@ -377,6 +377,8 @@ class SquidConfig
         acl_access* spoof_client_ip;
 
         acl_access *ftp_epsv;
+
+        acl_access *forceRequestBodyContinuation;
     } accessList;
     AclDenyInfoList *denyInfoList;
 
@@ -18,6 +18,9 @@
 int
 ACLUrlPathStrategy::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
+    if (!checklist->request->urlpath.size())
+        return -1;
+
     char *esc_buf = xstrdup(checklist->request->urlpath.termedBuf());
     rfc1738_unescape(esc_buf);
     int result = data->match(esc_buf);
@@ -235,8 +235,7 @@ Adaptation::Ecap::RequestLineRep::method(const Name &aMethod)
         theMessage.method = HttpRequestMethod(static_cast<Http::MethodType>(id));
     } else {
         const std::string &image = aMethod.image();
-        theMessage.method = HttpRequestMethod(image.data(),
-                                              image.data() + image.size());
+        theMessage.method.HttpRequestMethodXXX(image.c_str());
     }
 }
 
@@ -428,7 +428,7 @@ DOC_START
 		For Digest there is no default, this parameter is mandatory.
 		For NTLM and Negotiate this parameter is ignored.
 
-	"children" numberofchildren [startup=N] [idle=N] [concurrency=N]
+	"children" numberofchildren [startup=N] [idle=N] [concurrency=N] [queue-size=N]
 
 		The maximum number of authenticator processes to spawn. If
 		you start too few Squid will have to wait for them to process
@@ -453,6 +453,11 @@ DOC_START
 		Concurrency must not be set unless it's known the helper
 		supports the input format with channel-ID fields.
 
+		The queue-size= option sets the maximum number of queued
+		requests. If the queued requests exceed queue size for more
+		than 3 minutes then squid aborts its operation.
+		The default value is set to 2*numberofchildren/
+
 		NOTE: NTLM and Negotiate schemes do not support concurrency
 			in the Squid code module even though some helpers can.
 
@@ -646,6 +651,10 @@ DOC_START
 			Up to the value of children-max. (default 1)
 	  concurrency=n	concurrency level per process. Only used with helpers
 			capable of processing more than one query at a time.
+	  queue-size=N  The queue-size= option sets the maximum number of queued
+			requests. If the queued requests exceed queue size 
+			the acl ignored.
+			The default value is set to 2*children-max.
 	  cache=n	limit the result cache size, default is 262144.
 	  grace=n	Percentage remaining of TTL where a refresh of a
 			cached entry should be initiated without needing to
@@ -1740,7 +1749,6 @@ DOC_START
 
 	   version=	The version of SSL/TLS supported
 			    1	automatic (default)
-			    2	SSLv2 only
 			    3	SSLv3 only
 			    4	TLSv1.0 only
 			    5	TLSv1.1 only
@@ -1754,7 +1762,6 @@ DOC_START
 
 	   options=	Various SSL implementation options. The most important
 			being:
-			    NO_SSLv2    Disallow the use of SSLv2
 			    NO_SSLv3    Disallow the use of SSLv3
 			    NO_TLSv1    Disallow the use of TLSv1.0
 			    NO_TLSv1_1  Disallow the use of TLSv1.1
@@ -1914,15 +1921,13 @@ DOC_START
 
 	   version=	The version of SSL/TLS supported
 			    1	automatic (default)
-			    2	SSLv2 only
 			    3	SSLv3 only
 			    4	TLSv1 only
 
 	   cipher=	Colon separated list of supported ciphers.
 
 	   options=	Various SSL engine options. The most important
 			being:
-			    NO_SSLv2  Disallow the use of SSLv2
 			    NO_SSLv3  Disallow the use of SSLv3
 			    NO_TLSv1  Disallow the use of TLSv1
 			    SINGLE_DH_USE Always create a new key when using
@@ -2419,7 +2424,6 @@ DOC_START
 	The versions of SSL/TLS supported:
 
 	    1	automatic (default)
-	    2	SSLv2 only
 	    3	SSLv3 only
 	    4	TLSv1.0 only
 	    5	TLSv1.1 only
@@ -2436,7 +2440,6 @@ DOC_START
 	
 	The most important being:
 
-	    NO_SSLv2    Disallow the use of SSLv2
 	    NO_SSLv3    Disallow the use of SSLv3
 	    NO_TLSv1    Disallow the use of TLSv1.0
 	    NO_TLSv1_1  Disallow the use of TLSv1.1
@@ -2805,6 +2808,13 @@ DOC_START
 	at all times. When traffic begins to rise above what the existing
 	processes can handle this many more will be spawned up to the maximum
 	configured. A minimum setting of 1 is required.
+
+		queue-size=N
+
+	Sets the maximum number of queued requests.
+	If the queued requests exceed queue size for more than 3 minutes
+	squid aborts its operation.
+	The default value is set to 2*numberofchildren.
 	
 	You must have at least one ssl_crtd process.
 DOC_END
@@ -2864,6 +2874,13 @@ DOC_START
 	a request ID in front of the request/response. The request
 	ID from the request must be echoed back with the response
 	to that request.
+
+		queue-size=N
+
+	Sets the maximum number of queued requests.
+	If the queued requests exceed queue size for more than 3 minutes
+	squid aborts its operation.
+	The default value is set to 2*numberofchildren.
 	
 	You must have at least one ssl_crt_validator process.
 DOC_END
@@ -3149,7 +3166,6 @@ DOC_START
 	
 	ssloptions=... 	Specify various SSL implementation options:
 
-			    NO_SSLv2    Disallow the use of SSLv2
 			    NO_SSLv3    Disallow the use of SSLv3
 			    NO_TLSv1    Disallow the use of TLSv1.0
 			    NO_TLSv1_1  Disallow the use of TLSv1.1
@@ -4869,6 +4885,14 @@ DOC_START
 	used to communicate with the helper is modified to include
 	an ID in front of the request/response. The ID from the request
 	must be echoed back with the response to that request.
+
+		queue-size=N
+
+	Sets the maximum number of queued requests.
+	If the queued requests exceed queue size and redirector_bypass
+	configuration option is set, then redirector is bypassed. Otherwise, if
+	overloading persists squid may abort its operation.
+	The default value is set to 2*numberofchildren.
 DOC_END
 
 NAME: url_rewrite_host_header redirect_rewrites_host_header
@@ -4919,6 +4943,8 @@ DOC_START
 	redirectors for access control, and you enable this option,
 	users may have access to pages they should not
 	be allowed to request.
+	This options sets default queue-size option of the url_rewrite_children
+	to 0.
 DOC_END
 
 NAME: url_rewrite_extras
@@ -5043,6 +5069,14 @@ DOC_START
 	used to communicate with the helper is modified to include
 	an ID in front of the request/response. The ID from the request
 	must be echoed back with the response to that request.
+
+		queue-size=N
+
+	Sets the maximum number of queued requests.
+	If the queued requests exceed queue size and store_id_bypass
+	configuration option is set, then storeID helper is bypassed. Otherwise,
+	if overloading persists squid may abort its operation.
+	The default value is set to 2*numberofchildren.
 DOC_END
 
 NAME: store_id_access storeurl_rewrite_access
@@ -5072,6 +5106,8 @@ DOC_START
 	are not critical to your caching system.  If you use
 	helpers for critical caching components, and you enable this 
 	option,	users may not get objects from cache.
+	This options sets default queue-size option of the store_id_children
+	to 0.
 DOC_END
 
 COMMENT_START
@@ -6476,23 +6512,23 @@ DOC_START
 	description of delay_class.
 
 	For a class 1 delay pool, the syntax is:
-		delay_pools pool 1
+		delay_class pool 1
 		delay_parameters pool aggregate
 
 	For a class 2 delay pool:
-		delay_pools pool 2
+		delay_class pool 2
 		delay_parameters pool aggregate individual
 
 	For a class 3 delay pool:
-		delay_pools pool 3
+		delay_class pool 3
 		delay_parameters pool aggregate network individual
 
 	For a class 4 delay pool:
-		delay_pools pool 4
+		delay_class pool 4
 		delay_parameters pool aggregate network individual user
 
 	For a class 5 delay pool:
-		delay_pools pool 5
+		delay_class pool 5
 		delay_parameters pool tagrate
 
 	The option variables are:
@@ -6528,11 +6564,11 @@ DOC_START
 	above example, and is being used to strictly limit each host to 64Kbit/sec
 	(plus overheads), with no overall limit, the line is:
 
-		delay_parameters 1 -1/-1 8000/8000
+		delay_parameters 1 none 8000/8000
 
 	Note that 8 x 8000 KByte/sec -> 64Kbit/sec.
 
-	Note that the figure -1 is used to represent "unlimited".
+	Note that the word 'none' is used to represent no limit.
 
 
 	And, if delay pool number 2 is a class 3 delay pool as in the above
@@ -9303,4 +9339,33 @@ DOC_START
 	See also: workers
 DOC_END
 
+NAME: force_request_body_continuation
+TYPE: acl_access
+LOC: Config.accessList.forceRequestBodyContinuation
+DEFAULT: none
+DEFAULT_DOC: Deny, unless rules exist in squid.conf.
+DOC_START
+	This option controls how Squid handles data upload requests from HTTP
+	and FTP agents that require a "Please Continue" control message response
+	to actually send the request body to Squid. It is mostly useful in
+	adaptation environments.
+	
+	When Squid receives an HTTP request with an "Expect: 100-continue"
+	header or an FTP upload command (e.g., STOR), Squid normally sends the
+	request headers or FTP command information to an adaptation service (or
+	peer) and waits for a response. Most adaptation services (and some
+	broken peers) may not respond to Squid at that stage because they may
+	decide to wait for the HTTP request body or FTP data transfer. However,
+	that request body or data transfer may never come because Squid has not
+	responded with the HTTP 100 or FTP 150 (Please Continue) control message
+	to the request sender yet!
+	
+	An allow match tells Squid to respond with the HTTP 100 or FTP 150
+	(Please Continue) control message on its own, before forwarding the
+	request to an adaptation service or peer. Such a response usually forces
+	the request sender to proceed with sending the body. A deny match tells
+	Squid to delay that control response until the origin server confirms
+	that the request body is needed. Delaying is the default behavior.
+DOC_END
+
 EOF
@@ -2448,7 +2448,7 @@ bool ConnStateData::serveDelayedError(ClientSocketContext *context)
 }
 #endif // USE_OPENSSL
 
-static void
+void
 clientProcessRequestFinished(ConnStateData *conn, const HttpRequest::Pointer &request)
 {
     /*
@@ -2468,106 +2468,18 @@ void
 clientProcessRequest(ConnStateData *conn, const Http1::RequestParserPointer &hp, ClientSocketContext *context)
 {
     ClientHttpRequest *http = context->http;
-    HttpRequest::Pointer request;
     bool chunked = false;
     bool mustReplyToOptions = false;
     bool unsupportedTe = false;
     bool expectBody = false;
 
+    // We already have the request parsed and checked, so we
+    // only need to go through the final body/conn setup to doCallouts().
+    assert(http->request);
+    HttpRequest::Pointer request = http->request;
+
     // temporary hack to avoid splitting this huge function with sensitive code
     const bool isFtp = !hp;
-    if (isFtp) {
-        // In FTP, case, we already have the request parsed and checked, so we
-        // only need to go through the final body/conn setup to doCallouts().
-        assert(http->request);
-        request = http->request;
-    } else {
-
-        if (context->flags.parsed_ok == 0) {
-            clientStreamNode *node = context->getClientReplyContext();
-            debugs(33, 2, "Invalid Request");
-            conn->quitAfterError(NULL);
-            // setLogUri should called before repContext->setReplyToError
-            setLogUri(http, http->uri, true);
-            clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
-            assert(repContext);
-
-            // determine which error page templates to use for specific parsing errors
-            err_type errPage = ERR_INVALID_REQ;
-            switch (hp->parseStatusCode) {
-            case Http::scRequestHeaderFieldsTooLarge:
-                // fall through to next case
-            case Http::scUriTooLong:
-                errPage = ERR_TOO_BIG;
-                break;
-            case Http::scMethodNotAllowed:
-                errPage = ERR_UNSUP_REQ;
-                break;
-            case Http::scHttpVersionNotSupported:
-                errPage = ERR_UNSUP_HTTPVERSION;
-                break;
-            default:
-                // use default ERR_INVALID_REQ set above.
-                break;
-            }
-            repContext->setReplyToError(errPage, hp->parseStatusCode, hp->method(), http->uri,
-                                        conn->clientConnection->remote, NULL, conn->in.buf.c_str(), NULL);
-            assert(context->http->out.offset == 0);
-            context->pullData();
-            return;
-        }
-
-        if ((request = HttpRequest::CreateFromUrlAndMethod(http->uri, hp->method())) == NULL) {
-            clientStreamNode *node = context->getClientReplyContext();
-            debugs(33, 5, "Invalid URL: " << http->uri);
-            conn->quitAfterError(request.getRaw());
-            // setLogUri should called before repContext->setReplyToError
-            setLogUri(http, http->uri, true);
-            clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
-            assert(repContext);
-            repContext->setReplyToError(ERR_INVALID_URL, Http::scBadRequest, hp->method(), http->uri, conn->clientConnection->remote, NULL, NULL, NULL);
-            assert(context->http->out.offset == 0);
-            context->pullData();
-            return;
-        }
-
-        /* RFC 2616 section 10.5.6 : handle unsupported HTTP major versions cleanly. */
-        /* We currently only support 0.9, 1.0, 1.1 properly */
-        /* TODO: move HTTP-specific processing into servers/HttpServer and such */
-        if ( (hp->messageProtocol().major == 0 && hp->messageProtocol().minor != 9) ||
-                (hp->messageProtocol().major > 1) ) {
-
-            clientStreamNode *node = context->getClientReplyContext();
-            debugs(33, 5, "Unsupported HTTP version discovered. :\n" << hp->messageProtocol());
-            conn->quitAfterError(request.getRaw());
-            // setLogUri should called before repContext->setReplyToError
-            setLogUri(http, http->uri,  true);
-            clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
-            assert (repContext);
-            repContext->setReplyToError(ERR_UNSUP_HTTPVERSION, Http::scHttpVersionNotSupported, hp->method(), http->uri,
-                                        conn->clientConnection->remote, NULL, NULL, NULL);
-            assert(context->http->out.offset == 0);
-            context->pullData();
-            clientProcessRequestFinished(conn, request);
-            return;
-        }
-
-        /* compile headers */
-        if (hp->messageProtocol().major >= 1 && !request->parseHeader(*hp)) {
-            clientStreamNode *node = context->getClientReplyContext();
-            debugs(33, 5, "Failed to parse request headers:\n" << hp->mimeHeader());
-            conn->quitAfterError(request.getRaw());
-            // setLogUri should called before repContext->setReplyToError
-            setLogUri(http, http->uri, true);
-            clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
-            assert(repContext);
-            repContext->setReplyToError(ERR_INVALID_REQ, Http::scBadRequest, hp->method(), http->uri, conn->clientConnection->remote, NULL, NULL, NULL);
-            assert(context->http->out.offset == 0);
-            context->pullData();
-            clientProcessRequestFinished(conn, request);
-            return;
-        }
-    }
 
     // Some blobs below are still HTTP-specific, but we would have to rewrite
     // this entire function to remove them from the FTP code path. Connection
@@ -2701,11 +2613,6 @@ clientProcessRequest(ConnStateData *conn, const Http1::RequestParserPointer &hp,
         }
     }
 
-    if (!isFtp) {
-        http->request = request.getRaw();
-        HTTPMSGLOCK(http->request);
-    }
-
     clientSetKeepaliveFlag(http);
     // Let tunneling code be fully responsible for CONNECT requests
     if (http->request->method == Http::METHOD_CONNECT) {
@@ -14,8 +14,8 @@
 #include "clientStreamForward.h"
 #include "comm.h"
 #include "helper/forward.h"
-#include "HttpControlMsg.h"
 #include "http/forward.h"
+#include "HttpControlMsg.h"
 #include "ipc/FdNotes.h"
 #include "SBuf.h"
 #if USE_AUTH
@@ -577,7 +577,9 @@ Ftp::Relay::readDataReply()
     if (ctrl.replycode == 125 || ctrl.replycode == 150) {
         if (serverState() == fssHandleDataRequest)
             forwardPreliminaryReply(&Ftp::Relay::startDataDownload);
-        else // serverState() == fssHandleUploadRequest
+        else if (fwd->request->forcedBodyContinuation /*&& serverState() == fssHandleUploadRequest*/)
+            startDataUpload();
+        else // serverState() == fssHandleUploadRequest 
             forwardPreliminaryReply(&Ftp::Relay::startDataUpload);
     } else
         forwardReply();
@@ -268,6 +268,9 @@ parse_externalAclHelper(external_acl ** list)
             a->children.n_idle = atoi(token + 14);
         } else if (strncmp(token, "concurrency=", 12) == 0) {
             a->children.concurrency = atoi(token + 12);
+        } else if (strncmp(token, "queue-size=", 11) == 0) {
+            a->children.queue_size = atoi(token + 11);
+            a->children.defaultQueueSize = false;
         } else if (strncmp(token, "cache=", 6) == 0) {
             a->cache_size = atoi(token + 6);
         } else if (strncmp(token, "grace=", 6) == 0) {
@@ -315,6 +318,9 @@ parse_externalAclHelper(external_acl ** list)
     if (a->negative_ttl == -1)
         a->negative_ttl = a->ttl;
 
+    if (a->children.defaultQueueSize)
+        a->children.queue_size = 2 * a->children.n_max;
+
     /* Parse format */
     external_acl_format::Pointer *p = &a->format;
 
@@ -776,7 +782,7 @@ aclMatchExternal(external_acl_data *acl, ACLFilledChecklist *ch)
         if (!entry) {
             debugs(82, 2, HERE << acl->def->name << "(\"" << key << "\") = lookup needed");
 
-            if (acl->def->theHelper->stats.queue_size < (int)acl->def->theHelper->childs.n_active) {
+            if (!acl->def->theHelper->queueFull()) {
                 debugs(82, 2, HERE << "\"" << key << "\": queueing a call.");
                 if (!ch->goAsync(ExternalACLLookup::Instance()))
                     debugs(82, 2, "\"" << key << "\": no async support!");
@@ -1415,24 +1421,19 @@ ExternalACLLookup::Start(ACLChecklist *checklist, external_acl_data *acl, bool i
     } else {
         /* No pending lookup found. Sumbit to helper */
 
-        /* Check for queue overload */
-
-        if (def->theHelper->stats.queue_size >= (int)def->theHelper->childs.n_running) {
-            debugs(82, 7, HERE << "'" << def->name << "' queue is too long");
-            assert(inBackground); // or the caller should have checked
-            cbdataFree(state);
-            return;
-        }
-
-        /* Send it off to the helper */
         MemBuf buf;
         buf.init();
 
         buf.Printf("%s\n", key);
 
         debugs(82, 4, "externalAclLookup: looking up for '" << key << "' in '" << def->name << "'.");
 
-        helperSubmit(def->theHelper, buf.buf, externalAclHandleReply, state);
+        if (!def->theHelper->trySubmit(buf.buf, externalAclHandleReply, state)) {
+            debugs(82, 7, HERE << "'" << def->name << "' submit to helper failed");
+            assert(inBackground); // or the caller should have checked
+            cbdataFree(state);
+            return;
+        }
 
         dlinkAdd(state, &state->list, &def->queue);
 
@@ -374,16 +374,62 @@ helperSubmit(helper * hlp, const char *buf, HLPCB * callback, void *data)
         callback(data, nilReply);
         return;
     }
+    hlp->prepSubmit();
+    hlp->submit(buf, callback, data);
+}
+
+bool
+helper::queueFull() const {
+    return stats.queue_size > static_cast<int>(childs.queue_size);
+}
+
+/// prepares the helper for request submission via trySubmit() or helperSubmit()
+/// currently maintains full_time and kills Squid if the helper remains full for too long
+void
+helper::prepSubmit()
+{
+    if (!queueFull())
+        full_time = 0;
+    else if (!full_time) // may happen here if reconfigure decreases capacity
+        full_time = squid_curtime;
+    else if (squid_curtime - full_time > 180)
+        fatalf("Too many queued %s requests", id_name);
+}
+
+bool
+helper::trySubmit(const char *buf, HLPCB * callback, void *data)
+{
+    prepSubmit();
 
+    if (queueFull()) {
+        debugs(84, DBG_IMPORTANT, id_name << " drops request due to a full queue");
+        return false; // request was ignored
+    }
+
+    submit(buf, callback, data); // will send or queue
+    return true; // request submitted or queued
+}
+
+/// dispatches or enqueues a helper requests; does not enforce queue limits
+void
+helper::submit(const char *buf, HLPCB * callback, void *data)
+{
     Helper::Request *r = new Helper::Request(callback, data, buf);
     helper_server *srv;
 
-    if ((srv = GetFirstAvailable(hlp)))
+    if ((srv = GetFirstAvailable(this)))
         helperDispatch(srv, r);
     else
-        Enqueue(hlp, r);
+        Enqueue(this, r);
 
     debugs(84, DBG_DATA, Raw("buf", buf, strlen(buf)));
+
+    if (!queueFull()) {
+        full_time = 0;
+    } else if (!full_time) {
+        debugs(84, 3, id_name << " queue became full");
+        full_time = squid_curtime;
+    }
 }
 
 /// lastserver = "server last used as part of a reserved request sequence"
@@ -396,7 +442,12 @@ helperStatefulSubmit(statefulhelper * hlp, const char *buf, HLPCB * callback, vo
         callback(data, nilReply);
         return;
     }
+    hlp->prepSubmit();
+    hlp->submit(buf, callback, data, lastserver);
+}
 
+void statefulhelper::submit(const char *buf, HLPCB * callback, void *data, helper_stateful_server * lastserver)
+{
     Helper::Request *r = new Helper::Request(callback, data, buf);
 
     if ((buf != NULL) && lastserver) {
@@ -408,14 +459,21 @@ helperStatefulSubmit(statefulhelper * hlp, const char *buf, HLPCB * callback, vo
         helperStatefulDispatch(lastserver, r);
     } else {
         helper_stateful_server *srv;
-        if ((srv = StatefulGetFirstAvailable(hlp))) {
+        if ((srv = StatefulGetFirstAvailable(this))) {
             helperStatefulDispatch(srv, r);
         } else
-            StatefulEnqueue(hlp, r);
+            StatefulEnqueue(this, r);
     }
 
     debugs(84, DBG_DATA, "placeholder: '" << r->placeholder <<
            "', " << Raw("buf", buf, (!buf?0:strlen(buf))));
+
+    if (!queueFull()) {
+        full_time = 0;
+    } else if (!full_time) {
+        debugs(84, 3, id_name << " queue became full");
+        full_time = squid_curtime;
+    }
 }
 
 /**
@@ -1060,6 +1118,7 @@ helperStatefulHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t
     }
 }
 
+/// Handles a request when all running helpers, if any, are busy.
 static void
 Enqueue(helper * hlp, Helper::Request * r)
 {
@@ -1074,7 +1133,7 @@ Enqueue(helper * hlp, Helper::Request * r)
         return;
     }
 
-    if (hlp->stats.queue_size < (int)hlp->childs.n_running)
+    if (hlp->stats.queue_size < (int)hlp->childs.queue_size)
         return;
 
     if (squid_curtime - hlp->last_queue_warn < 600)
@@ -1088,9 +1147,6 @@ Enqueue(helper * hlp, Helper::Request * r)
     debugs(84, DBG_CRITICAL, "WARNING: All " << hlp->childs.n_active << "/" << hlp->childs.n_max << " " << hlp->id_name << " processes are busy.");
     debugs(84, DBG_CRITICAL, "WARNING: " << hlp->stats.queue_size << " pending requests queued");
     debugs(84, DBG_CRITICAL, "WARNING: Consider increasing the number of " << hlp->id_name << " processes in your config file.");
-
-    if (hlp->stats.queue_size > (int)hlp->childs.n_running * 2)
-        fatalf("Too many queued %s requests", hlp->id_name);
 }
 
 static void
@@ -1107,12 +1163,9 @@ StatefulEnqueue(statefulhelper * hlp, Helper::Request * r)
         return;
     }
 
-    if (hlp->stats.queue_size < (int)hlp->childs.n_running)
+    if (hlp->stats.queue_size < (int)hlp->childs.queue_size)
         return;
 
-    if (hlp->stats.queue_size > (int)hlp->childs.n_running * 2)
-        fatalf("Too many queued %s requests", hlp->id_name);
-
     if (squid_curtime - hlp->last_queue_warn < 600)
         return;
 
@@ -20,6 +20,21 @@
 #include "helper/forward.h"
 #include "ip/Address.h"
 
+/**
+ * Managers a set of individual helper processes with a common queue of requests.
+ *
+ * With respect to load, a helper goes through these states (roughly):
+ *   idle:   no processes are working on requests (and no requests are queued);
+ *   normal: some, but not all processes are working (and no requests are queued);
+ *   busy:   all processes are working (and some requests are possibly queued);
+ *   full:   all processes are working and at least 2*#processes requests are queued.
+ *
+ * A "busy" helper queues new requests and issues a WARNING every 10 minutes or so.
+ * A "full" helper either drops new requests or keeps queuing them, depending on
+ *   whether the caller can handle dropped requests (trySubmit vs helperSubmit APIs).
+ * An attempt to use a "full" helper that has been "full" for 3+ minutes kills worker.
+ *   Given enough load, all helpers except for external ACL will make such attempts.
+ */
 class helper
 {
     CBDATA_CLASS(helper);
@@ -29,13 +44,20 @@ class helper
             cmdline(NULL),
             id_name(name),
             ipc_type(0),
+            full_time(0),
             last_queue_warn(0),
             last_restart(0),
             eom('\n') {
         memset(&stats, 0, sizeof(stats));
     }
     ~helper();
 
+    ///< whether at least one more request can be successfully submitted
+    bool queueFull() const;
+
+    ///< If not full, submit request. Otherwise, either kill Squid or return false.
+    bool trySubmit(const char *buf, HLPCB * callback, void *data);
+
 public:
     wordlist *cmdline;
     dlink_list servers;
@@ -44,6 +66,7 @@ class helper
     Helper::ChildConfig childs;    ///< Configuration settings for number running.
     int ipc_type;
     Ip::Address addr;
+    time_t full_time; ///< when a full helper became full (zero for non-full helpers)
     time_t last_queue_warn;
     time_t last_restart;
     char eom;   ///< The char which marks the end of (response) message, normally '\n'
@@ -54,6 +77,11 @@ class helper
         int queue_size;
         int avg_svc_time;
     } stats;
+
+protected:
+    friend void helperSubmit(helper * hlp, const char *buf, HLPCB * callback, void *data);
+    void prepSubmit();
+    void submit(const char *buf, HLPCB * callback, void *data);
 };
 
 class statefulhelper : public helper
@@ -68,6 +96,10 @@ class statefulhelper : public helper
     MemAllocator *datapool;
     HLPSAVAIL *IsAvailable;
     HLPSONEQ *OnEmptyQueue;
+
+private:
+    friend void helperStatefulSubmit(statefulhelper * hlp, const char *buf, HLPCB * callback, void *data, helper_stateful_server * lastserver);
+    void submit(const char *buf, HLPCB * callback, void *data, helper_stateful_server *lastserver);
 };
 
 /**
@@ -22,7 +22,9 @@ Helper::ChildConfig::ChildConfig():
         n_idle(1),
         concurrency(0),
         n_running(0),
-        n_active(0)
+        n_active(0),
+        queue_size(0),
+        defaultQueueSize(true)
 {}
 
 Helper::ChildConfig::ChildConfig(const unsigned int m):
@@ -31,7 +33,9 @@ Helper::ChildConfig::ChildConfig(const unsigned int m):
         n_idle(1),
         concurrency(0),
         n_running(0),
-        n_active(0)
+        n_active(0),
+        queue_size(2 * m),
+        defaultQueueSize(true)
 {}
 
 Helper::ChildConfig &
@@ -43,6 +47,8 @@ Helper::ChildConfig::updateLimits(const Helper::ChildConfig &rhs)
     n_startup = rhs.n_startup;
     n_idle = rhs.n_idle;
     concurrency = rhs.concurrency;
+    queue_size = rhs.queue_size;
+    defaultQueueSize = rhs.defaultQueueSize;
     return *this;
 }
 
@@ -87,6 +93,9 @@ Helper::ChildConfig::parseConfig()
             }
         } else if (strncmp(token, "concurrency=", 12) == 0) {
             concurrency = xatoui(token + 12);
+        } else if (strncmp(token, "queue-size=", 11) == 0) {
+            queue_size = xatoui(token + 11);
+            defaultQueueSize = false;
         } else {
             debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: Undefined option: " << token << ".");
             self_destruct();
@@ -104,4 +113,7 @@ Helper::ChildConfig::parseConfig()
         debugs(0, DBG_CRITICAL, "WARNING OVERIDE: Capping idle=" << n_idle << " to the defined maximum (" << n_max <<")");
         n_idle = n_max;
     }
+    
+    if (defaultQueueSize)
+        queue_size = 2 * n_max;
 }
@@ -84,6 +84,18 @@ class ChildConfig
      * This includes both idle and in-use children.
      */
     unsigned int n_active;
+
+    /**
+     * The requests queue size. By default it is of size 2*n_max
+     */
+    unsigned int queue_size;
+
+    /**
+     * True if the default queue size is used.
+     * Needed in the cases where we need to adjust default queue_size in
+     * special configurations, for example when redirector_bypass is used.
+     */
+    bool defaultQueueSize;
 };
 
 } // namespace Helper
@@ -11,8 +11,8 @@
 
 #if USE_HTCP
 
-#include "HttpHeader.h"
 #include "http/forward.h"
+#include "HttpHeader.h"
 #include "ip/forward.h"
 
 /// \ingroup ServerProtocolHTCP
@@ -809,8 +809,8 @@ HttpStateData::handle1xx(HttpReply *reply)
     Must(!flags.handling1xx);
     flags.handling1xx = true;
 
-    if (!request->canHandle1xx()) {
-        debugs(11, 2, HERE << "ignoring client-unsupported 1xx");
+    if (!request->canHandle1xx() || request->forcedBodyContinuation) {
+        debugs(11, 2, "ignoring 1xx because it is " << (request->forcedBodyContinuation ? "already sent" : "not supported by client"));
         proceedAfter1xx();
         return;
     }
@@ -290,8 +290,8 @@ redirectStart(ClientHttpRequest * http, HLPCB * handler, void *data)
     assert(handler);
     debugs(61, 5, "redirectStart: '" << http->uri << "'");
 
-    if (Config.onoff.redirector_bypass && redirectors->stats.queue_size) {
-        /* Skip redirector if there is one request queued */
+    if (Config.onoff.redirector_bypass && redirectors->queueFull()) {
+        /* Skip redirector if the queue is full */
         ++redirectorBypassed;
         Helper::Reply bypassReply;
         bypassReply.result = Helper::Okay;
@@ -314,8 +314,8 @@ storeIdStart(ClientHttpRequest * http, HLPCB * handler, void *data)
     assert(handler);
     debugs(61, 5, "storeIdStart: '" << http->uri << "'");
 
-    if (Config.onoff.store_id_bypass && storeIds->stats.queue_size) {
-        /* Skip StoreID Helper if there is one request queued */
+    if (Config.onoff.store_id_bypass && storeIds->queueFull()) {
+        /* Skip StoreID Helper if the queue is full */
         ++storeIdBypassed;
         Helper::Reply bypassReply;
 
@@ -346,6 +346,11 @@ redirectInit(void)
 
         redirectors->cmdline = Config.Program.redirect;
 
+        // BACKWARD COMPATIBILITY:
+        // if redirectot_bypass is set then use queue_size=0 as default size
+        if (Config.onoff.redirector_bypass && Config.redirectChildren.defaultQueueSize)
+            Config.redirectChildren.queue_size = 0;
+
         redirectors->childs.updateLimits(Config.redirectChildren);
 
         redirectors->ipc_type = IPC_STREAM;
@@ -360,6 +365,11 @@ redirectInit(void)
 
         storeIds->cmdline = Config.Program.store_id;
 
+        // BACKWARD COMPATIBILITY:
+        // if store_id_bypass is set then use queue_size=0 as default size
+        if (Config.onoff.store_id_bypass && Config.storeIdChildren.defaultQueueSize)
+            Config.storeIdChildren.queue_size = 0;
+
         storeIds->childs.updateLimits(Config.storeIdChildren);
 
         storeIds->ipc_type = IPC_STREAM;
@@ -9,6 +9,7 @@
 /* DEBUG: section 33    Transfer protocol servers */
 
 #include "squid.h"
+#include "acl/FilledChecklist.h"
 #include "base/CharacterSet.h"
 #include "base/RefCount.h"
 #include "base/Subscription.h"
@@ -1490,6 +1491,26 @@ Ftp::Server::handleUploadRequest(String &cmd, String &params)
     if (!checkDataConnPre())
         return false;
 
+    if (Config.accessList.forceRequestBodyContinuation) {
+        ClientHttpRequest *http = getCurrentContext()->http;
+        HttpRequest *request = http->request;
+        ACLFilledChecklist bodyContinuationCheck(Config.accessList.forceRequestBodyContinuation, request, NULL);
+        if (bodyContinuationCheck.fastCheck() == ACCESS_ALLOWED) {
+            request->forcedBodyContinuation = true;
+            if (checkDataConnPost()) {
+                // Write control Msg
+                writeEarlyReply(150, "Data connection opened");
+                maybeReadUploadData();
+            } else {
+                // wait for acceptDataConnection but tell it to call wroteEarlyReply
+                // after writing "150 Data connection opened"
+                typedef CommCbMemFunT<Server, CommIoCbParams> Dialer;
+                AsyncCall::Pointer call = JobCallback(33, 5, Dialer, this, Ftp::Server::wroteEarlyReply);
+                onDataAcceptCall = call;
+            }
+        }
+    }
+
     changeState(fssHandleUploadRequest, "handleDataRequest");
 
     return true;
@@ -9,11 +9,13 @@
 /* DEBUG: section 33    Client-side Routines */
 
 #include "squid.h"
+#include "acl/FilledChecklist.h"
 #include "client_side.h"
+#include "client_side_reply.h"
 #include "client_side_request.h"
 #include "comm/Write.h"
-#include "HttpHeaderTools.h"
 #include "http/one/RequestParser.h"
+#include "HttpHeaderTools.h"
 #include "profiler/Profiler.h"
 #include "servers/forward.h"
 #include "SquidConfig.h"
@@ -47,10 +49,18 @@ class Server: public ConnStateData
     /* AsyncJob API */
     virtual void start();
 
+    void proceedAfterBodyContinuation(ClientSocketContext::Pointer context);
+
 private:
     void processHttpRequest(ClientSocketContext *const context);
     void handleHttpRequestData();
 
+    /// Handles parsing results. May generate and deliver an error reply
+    /// to the client if parsing is failed, or parses the url and build the
+    /// HttpRequest object using parsing results.
+    /// Return false if parsing is failed, true otherwise.
+    bool buildHttpRequest(ClientSocketContext *context);
+
     Http1::RequestParserPointer parser_;
     HttpRequestMethod method_; ///< parsed HTTP method
 
@@ -127,9 +137,134 @@ Http::Server::parseOneRequest()
     return context;
 }
 
+void clientProcessRequestFinished(ConnStateData *conn, const HttpRequest::Pointer &request);
+
+bool
+Http::Server::buildHttpRequest(ClientSocketContext *context)
+{
+    HttpRequest::Pointer request;
+    ClientHttpRequest *http = context->http;
+    if (context->flags.parsed_ok == 0) {
+        clientStreamNode *node = context->getClientReplyContext();
+        debugs(33, 2, "Invalid Request");
+        quitAfterError(NULL);
+        // setLogUri should called before repContext->setReplyToError
+        setLogUri(http, http->uri, true);
+        clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
+        assert(repContext);
+
+        // determine which error page templates to use for specific parsing errors
+        err_type errPage = ERR_INVALID_REQ;
+        switch (parser_->parseStatusCode) {
+        case Http::scRequestHeaderFieldsTooLarge:
+            // fall through to next case
+        case Http::scUriTooLong:
+            errPage = ERR_TOO_BIG;
+            break;
+        case Http::scMethodNotAllowed:
+            errPage = ERR_UNSUP_REQ;
+            break;
+        case Http::scHttpVersionNotSupported:
+            errPage = ERR_UNSUP_HTTPVERSION;
+            break;
+        default:
+            // use default ERR_INVALID_REQ set above.
+            break;
+        }
+        repContext->setReplyToError(errPage, parser_->parseStatusCode, parser_->method(), http->uri,
+                                    clientConnection->remote, NULL, in.buf.c_str(), NULL);
+        assert(context->http->out.offset == 0);
+        context->pullData();
+        return false;
+    }
+
+    if ((request = HttpRequest::CreateFromUrlAndMethod(http->uri, parser_->method())) == NULL) {
+        clientStreamNode *node = context->getClientReplyContext();
+        debugs(33, 5, "Invalid URL: " << http->uri);
+        quitAfterError(request.getRaw());
+        // setLogUri should called before repContext->setReplyToError
+        setLogUri(http, http->uri, true);
+        clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
+        assert(repContext);
+        repContext->setReplyToError(ERR_INVALID_URL, Http::scBadRequest, parser_->method(), http->uri, clientConnection->remote, NULL, NULL, NULL);
+        assert(context->http->out.offset == 0);
+        context->pullData();
+        return false;
+    }
+
+    /* RFC 2616 section 10.5.6 : handle unsupported HTTP major versions cleanly. */
+    /* We currently only support 0.9, 1.0, 1.1 properly */
+    /* TODO: move HTTP-specific processing into servers/HttpServer and such */
+    if ( (parser_->messageProtocol().major == 0 && parser_->messageProtocol().minor != 9) ||
+         (parser_->messageProtocol().major > 1) ) {
+
+        clientStreamNode *node = context->getClientReplyContext();
+        debugs(33, 5, "Unsupported HTTP version discovered. :\n" << parser_->messageProtocol());
+        quitAfterError(request.getRaw());
+        // setLogUri should called before repContext->setReplyToError
+        setLogUri(http, http->uri,  true);
+        clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
+        assert (repContext);
+        repContext->setReplyToError(ERR_UNSUP_HTTPVERSION, Http::scHttpVersionNotSupported, parser_->method(), http->uri,
+                                    clientConnection->remote, NULL, NULL, NULL);
+        assert(context->http->out.offset == 0);
+        context->pullData();
+        clientProcessRequestFinished(this, request);
+        return false;
+    }
+
+    /* compile headers */
+    if (parser_->messageProtocol().major >= 1 && !request->parseHeader(*parser_.getRaw())) {
+        clientStreamNode *node = context->getClientReplyContext();
+        debugs(33, 5, "Failed to parse request headers:\n" << parser_->mimeHeader());
+        quitAfterError(request.getRaw());
+        // setLogUri should called before repContext->setReplyToError
+        setLogUri(http, http->uri, true);
+        clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
+        assert(repContext);
+        repContext->setReplyToError(ERR_INVALID_REQ, Http::scBadRequest, parser_->method(), http->uri, clientConnection->remote, NULL, NULL, NULL);
+        assert(context->http->out.offset == 0);
+        context->pullData();
+        clientProcessRequestFinished(this, request);
+        return false;
+    }
+
+    http->request = request.getRaw();
+    HTTPMSGLOCK(http->request);
+
+    return true;
+}
+
+void
+Http::Server::proceedAfterBodyContinuation(ClientSocketContext::Pointer context)
+{
+    debugs(33, 5, "Body Continuation written");
+    clientProcessRequest(this, parser_, context.getRaw());
+}
+
 void
 Http::Server::processParsedRequest(ClientSocketContext *context)
 {
+    if (!buildHttpRequest(context))
+        return;
+
+    if (Config.accessList.forceRequestBodyContinuation) {
+        ClientHttpRequest *http = context->http;
+        HttpRequest *request = http->request;
+        ACLFilledChecklist bodyContinuationCheck(Config.accessList.forceRequestBodyContinuation, request, NULL);
+        if (bodyContinuationCheck.fastCheck() == ACCESS_ALLOWED) {
+            debugs(33, 5, "Body Continuation forced");
+            request->forcedBodyContinuation = true;
+            //sendControlMsg
+            HttpReply::Pointer rep = new HttpReply;
+            rep->sline.set(Http::ProtocolVersion(1,1), Http::scContinue);
+
+            typedef UnaryMemFunT<Http::Server, ClientSocketContext::Pointer> CbDialer;
+            const AsyncCall::Pointer cb = asyncCall(11, 3,  "Http::Server::proceedAfterBodyContinuation", CbDialer(this, &Http::Server::proceedAfterBodyContinuation, ClientSocketContext::Pointer(context)));
+            sendControlMsg(HttpControlMsg(rep, cb));
+            return;
+        }
+    }
     clientProcessRequest(this, parser_, context);
 }
 
@@ -212,7 +212,7 @@ Ssl::ErrorDetailFile::parse(const char *buffer, int len, bool eof)
 
         if ( s != e) {
             DetailEntryParser parser;
-            if (!parser.parse(s, e)) {
+            if (!parser.parse(s, e - s)) {
                 debugs(83, DBG_IMPORTANT, HERE <<
                        "WARNING! parse error on:" << s);
                 return false;
@@ -98,26 +98,17 @@ void Ssl::Helper::Shutdown()
 
 void Ssl::Helper::sslSubmit(CrtdMessage const & message, HLPCB * callback, void * data)
 {
-    static time_t first_warn = 0;
     assert(ssl_crtd);
 
-    if (ssl_crtd->stats.queue_size >= (int)(ssl_crtd->childs.n_running * 2)) {
-        if (first_warn == 0)
-            first_warn = squid_curtime;
-        if (squid_curtime - first_warn > 3 * 60)
-            fatal("SSL servers not responding for 3 minutes");
-        debugs(34, DBG_IMPORTANT, HERE << "Queue overload, rejecting");
+    std::string msg = message.compose();
+    msg += '\n';
+    if (!ssl_crtd->trySubmit(msg.c_str(), callback, data)) {
         ::Helper::Reply failReply;
         failReply.result = ::Helper::BrokenHelper;
         failReply.notes.add("message", "error 45 Temporary network problem, please retry later");
         callback(data, failReply);
         return;
     }
-
-    first_warn = 0;
-    std::string msg = message.compose();
-    msg += '\n';
-    helperSubmit(ssl_crtd, msg.c_str(), callback, data);
 }
 #endif //USE_SSL_CRTD
 
@@ -251,22 +242,8 @@ sslCrtvdHandleReplyWrapper(void *data, const ::Helper::Reply &reply)
 
 void Ssl::CertValidationHelper::sslSubmit(Ssl::CertValidationRequest const &request, Ssl::CertValidationHelper::CVHCB * callback, void * data)
 {
-    static time_t first_warn = 0;
     assert(ssl_crt_validator);
 
-    if (ssl_crt_validator->stats.queue_size >= (int)(ssl_crt_validator->childs.n_running * 2)) {
-        if (first_warn == 0)
-            first_warn = squid_curtime;
-        if (squid_curtime - first_warn > 3 * 60)
-            fatal("ssl_crtvd queue being overloaded for long time");
-        debugs(83, DBG_IMPORTANT, "WARNING: ssl_crtvd queue overload, rejecting");
-        Ssl::CertValidationResponse resp;
-        resp.resultCode = ::Helper::BrokenHelper;
-        callback(data, resp);
-        return;
-    }
-    first_warn = 0;
-
     Ssl::CertValidationMsg message(Ssl::CrtdMessage::REQUEST);
     message.setCode(Ssl::CertValidationMsg::code_cert_validate);
     message.composeRequest(request);
@@ -289,5 +266,15 @@ void Ssl::CertValidationHelper::sslSubmit(Ssl::CertValidationRequest const &requ
         delete crtdvdData;
         return;
     }
-    helperSubmit(ssl_crt_validator, crtdvdData->query.c_str(), sslCrtvdHandleReplyWrapper, crtdvdData);
+
+    if (!ssl_crt_validator->trySubmit(crtdvdData->query.c_str(), sslCrtvdHandleReplyWrapper, crtdvdData)) {
+        Ssl::CertValidationResponse resp;
+        resp.resultCode = ::Helper::BrokenHelper;
+        callback(data, resp);
+
+        cbdataReferenceDone(crtdvdData->data);
+        SSL_free(crtdvdData->ssl);
+        delete crtdvdData;
+        return;
+    }
 }
@@ -354,16 +354,6 @@ static struct ssl_option {
 
 ssl_options[] = {
 
-#if SSL_OP_MICROSOFT_SESS_ID_BUG
-    {
-        "MICROSOFT_SESS_ID_BUG", SSL_OP_MICROSOFT_SESS_ID_BUG
-    },
-#endif
-#if SSL_OP_NETSCAPE_CHALLENGE_BUG
-    {
-        "NETSCAPE_CHALLENGE_BUG", SSL_OP_NETSCAPE_CHALLENGE_BUG
-    },
-#endif
 #if SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG
     {
         "NETSCAPE_REUSE_CIPHER_CHANGE_BUG", SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG
@@ -379,11 +369,6 @@ ssl_options[] = {
         "MICROSOFT_BIG_SSLV3_BUFFER", SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER
     },
 #endif
-#if SSL_OP_MSIE_SSLV2_RSA_PADDING
-    {
-        "MSIE_SSLV2_RSA_PADDING", SSL_OP_MSIE_SSLV2_RSA_PADDING
-    },
-#endif
 #if SSL_OP_SSLEAY_080_CLIENT_DH_BUG
     {
         "SSLEAY_080_CLIENT_DH_BUG", SSL_OP_SSLEAY_080_CLIENT_DH_BUG
@@ -449,11 +434,6 @@ ssl_options[] = {
         "NETSCAPE_DEMO_CIPHER_CHANGE_BUG", SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG
     },
 #endif
-#if SSL_OP_NO_SSLv2
-    {
-        "NO_SSLv2", SSL_OP_NO_SSLv2
-    },
-#endif
 #if SSL_OP_NO_SSLv3
     {
         "NO_SSLv3", SSL_OP_NO_SSLv3
@@ -563,6 +543,10 @@ Ssl::parse_options(const char *options)
     safe_free(tmp);
 
 no_options:
+#if SSL_OP_NO_SSLv2
+    // compliance with RFC 6176: Prohibiting Secure Sockets Layer (SSL) Version 2.0
+    op = op | SSL_OP_NO_SSLv2;
+#endif
     return op;
 }
 
@@ -1017,13 +1001,8 @@ Ssl::method(int version)
     switch (version) {
 
     case 2:
-#if !defined(OPENSSL_NO_SSL2)
-        debugs(83, 5, "Using SSLv2.");
-        return SSLv2_client_method();
-#else
         debugs(83, DBG_IMPORTANT, "SSLv2 is not available in this Proxy.");
         return NULL;
-#endif
         break;
 
     case 3:
@@ -1074,13 +1053,8 @@ Ssl::serverMethod(int version)
     switch (version) {
 
     case 2:
-#ifndef OPENSSL_NO_SSL2
-        debugs(83, 5, "Using SSLv2.");
-        return SSLv2_server_method();
-#else
         debugs(83, DBG_IMPORTANT, "SSLv2 is not available in this Proxy.");
         return NULL;
-#endif
         break;
 
     case 3:
@@ -1482,13 +1456,8 @@ Ssl::contextMethod(int version)
     switch (version) {
 
     case 2:
-#ifndef OPENSSL_NO_SSL2
-        debugs(83, 5, "Using SSLv2.");
-        method = SSLv2_server_method();
-#else
         debugs(83, DBG_IMPORTANT, "SSLv2 is not available in this Proxy.");
         return NULL;
-#endif
         break;
 
     case 3:
@@ -13,13 +13,13 @@
 #define private public
 #define protected public
 
-#include "testHttp1Parser.h"
 #include "http/one/RequestParser.h"
 #include "http/RequestMethod.h"
 #include "Mem.h"
 #include "MemBuf.h"
 #include "SquidConfig.h"
 #include "testHttp1Parser.h"
+#include "testHttp1Parser.h"
 
 CPPUNIT_TEST_SUITE_REGISTRATION( testHttp1Parser );
 
@@ -1018,8 +1018,8 @@ testHttp1Parser::testParseRequestLineInvalid()
     // no method (an invalid format)
     {
         input.append(" / HTTP/1.0\n", 12);
-
-        // XXX: squid custom tolerance consumes initial SP.
+#if USE_HTTP_VIOLATIONS
+        // squid custom tolerance consumes initial SP.
         Config.onoff.relaxed_header_parser = 1;
         struct resultSet expectRelaxed = {
             .parsed = true,
@@ -1041,19 +1041,19 @@ testHttp1Parser::testParseRequestLineInvalid()
         };
         output.clear();
         testResults(__LINE__, input, output, expectRelaxed);
+#endif
 
-        // STRICT detect as invalid
+#if !USE_HTTP_VIOLATIONS
+        // a compliant or strict parse, detects as invalid
         Config.onoff.relaxed_header_parser = 0;
-#if WHEN_RFC_COMPLIANT
-        // XXX: except Squid does not
         struct resultSet expectStrict = {
             .parsed = false,
             .needsMore = false,
             .parserState = Http1::HTTP_PARSE_DONE,
             .status = Http::scBadRequest,
             .msgStart = 0,
             .msgEnd = (int)input.length()-1,
-            .suffixSz = 0,
+            .suffixSz = input.length(),
             .methodStart = 0,
             .methodEnd = -1,
             .method = HttpRequestMethod(),
@@ -1065,23 +1065,24 @@ testHttp1Parser::testParseRequestLineInvalid()
             .version = AnyP::ProtocolVersion()
         };
 #else
+        // XXX: for now Squid confuses this with HTTP/0.9
         struct resultSet expectStrict = {
-            .parsed = false,
+            .parsed = true,
             .needsMore = false,
             .parserState = Http1::HTTP_PARSE_DONE,
-            .status = Http::scBadRequest,
+            .status = Http::scOkay,
             .msgStart = 0,
-            .msgEnd = (int)input.length()-1,
-            .suffixSz = input.length(),
+            .msgEnd = (int)input.length()-2,
+            .suffixSz = 0,
             .methodStart = 0,
-            .methodEnd = -1,
-            .method = HttpRequestMethod(),
-            .uriStart = -1,
-            .uriEnd = -1,
-            .uri = NULL,
+            .methodEnd = 0,
+            .method = HttpRequestMethod(SBuf("/")),
+            .uriStart = 2,
+            .uriEnd = 9,
+            .uri = "HTTP/1.0",
             .versionStart = -1,
             .versionEnd = -1,
-            .version = AnyP::ProtocolVersion()
+            .version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,0,9)
         };
 #endif
         output.clear();
@@ -1353,7 +1354,11 @@ testHttp1Parser::testDripFeed()
     // calling the parser repeatedly as visible data grows.
 
     SBuf data;
+#if USE_HTTP_VIOLATIONS
     data.append("            ", 12);
+#else
+    data.append("\n\n\n\n\n\n\n\n\n\n\n\n", 12);
+#endif
     SBuf::size_type garbageEnd = data.length();
     data.append("GET http://example.com/ HTTP/1.1\r\n", 34);
     SBuf::size_type reqLineEnd = data.length() - 1;
@@ -1422,7 +1427,7 @@ testHttp1Parser::testDripFeed()
             expect.version = AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1);
         }
 
-        // one mime header is done we are expectign a new request
+        // one mime header is done we are expecting a new request
         // parse results say true and initial data is all gone from the buffer
         if (pos == mimeEnd) {
             expect.parsed = true;
@@ -0,0 +1,17 @@
+## Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
+
+#
+# This file contains the list of reported regression cases in 3.5.0.2 parser
+# it covers:
+#       delay_parameters
+#
+
+delay_pools 1
+delay_class 1 1
+delay_parameters 1 none
+delay_parameters 1 64000/64000