@@ -1,6 +1,6 @@
 
 /*
- * $Id: acl.cc,v 1.217 2000/05/02 21:38:11 hno Exp $
+ * $Id: acl.cc,v 1.218 2000/05/12 00:29:06 wessels Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -1075,7 +1075,7 @@ aclDecodeProxyAuth(const char *proxy_auth, char **user, char **password, char *b
  */
 
 static int
-aclMatchProxyAuth(void * data, const char *proxy_auth, acl_proxy_auth_user * auth_user, aclCheck_t * checklist, squid_acl acltype)
+aclMatchProxyAuth(void *data, const char *proxy_auth, acl_proxy_auth_user * auth_user, aclCheck_t * checklist, squid_acl acltype)
 {
     /* checklist is used to register user name when identified, nothing else */
     LOCAL_ARRAY(char, login_buf, USER_IDENT_SZ);
@@ -1142,14 +1142,14 @@ aclMatchProxyAuth(void * data, const char *proxy_auth, acl_proxy_auth_user * aut
 	    auth_user->ipaddr = checklist->src_addr;
 	    /* copy username to request for logging on client-side */
 	    xstrncpy(checklist->request->user_ident, user, USER_IDENT_SZ);
-	    switch(acltype) {
+	    switch (acltype) {
 	    case ACL_PROXY_AUTH:
 		return aclMatchUser(data, user);
 	    case ACL_PROXY_AUTH_REGEX:
 		return aclMatchRegex(data, user);
 	    default:
 		fatal("aclMatchProxyAuth: unknown ACL type");
-		return 0; /* NOTREACHED */
+		return 0;	/* NOTREACHED */
 	    }
 	} else {
 	    if (Config.onoff.authenticateIpTTLStrict) {
@@ -2004,16 +2004,16 @@ aclDomainCompare(const void *a, const void *b)
     const char *d1;
     const char *d2;
     int ret;
-    d1=b;
-    d2=a;
+    d1 = b;
+    d2 = a;
     ret = aclHostDomainCompare(d1, d2);
     if (ret != 0) {
-	d1=a;
-	d2=b;
+	d1 = a;
+	d2 = b;
 	ret = aclHostDomainCompare(d1, d2);
     }
     if (ret == 0) {
-	debug(28,0 ) ("WARNING: '%s' is a subdomain of '%s'\n", d1, d2);
+	debug(28, 0) ("WARNING: '%s' is a subdomain of '%s'\n", d1, d2);
 	debug(28, 0) ("WARNING: because of this '%s' is ignored to keep splay tree searching predictable\n", a);
 	debug(28, 0) ("WARNING: You should probably remove '%s' from the ACL named '%s'\n", d1, AclMatchedName);
     }
@@ -1,5 +1,5 @@
 /*
- * $Id: asn.cc,v 1.60 2000/05/07 16:18:19 adrian Exp $
+ * $Id: asn.cc,v 1.61 2000/05/12 00:29:06 wessels Exp $
  *
  * DEBUG: section 53    AS Number handling
  * AUTHOR: Duane Wessels, Kostas Anagnostakis
@@ -206,7 +206,7 @@ asnCacheStart(int as)
     asState->seen = 0;
     asState->offset = 0;
     storeClientCopy(asState->sc,
-        e,
+	e,
 	asState->seen,
 	asState->offset,
 	4096,
@@ -262,7 +262,7 @@ asHandleReply(void *data, char *buf, ssize_t size)
     if (e->store_status == STORE_PENDING) {
 	debug(53, 3) ("asHandleReply: store_status == STORE_PENDING: %s\n", storeUrl(e));
 	storeClientCopy(asState->sc,
-            e,
+	    e,
 	    asState->seen,
 	    asState->offset,
 	    SM_PAGE_SIZE,
@@ -272,7 +272,7 @@ asHandleReply(void *data, char *buf, ssize_t size)
     } else if (asState->seen < e->mem_obj->inmem_hi) {
 	debug(53, 3) ("asHandleReply: asState->seen < e->mem_obj->inmem_hi %s\n", storeUrl(e));
 	storeClientCopy(asState->sc,
-            e,
+	    e,
 	    asState->seen,
 	    asState->offset,
 	    SM_PAGE_SIZE,
@@ -1,6 +1,6 @@
 
 /*
- * $Id: cache_cf.cc,v 1.343 2000/05/03 17:15:41 adrian Exp $
+ * $Id: cache_cf.cc,v 1.344 2000/05/12 00:29:06 wessels Exp $
  *
  * DEBUG: section 3     Configuration File Parsing
  * AUTHOR: Harvest Derived
@@ -113,7 +113,7 @@ wordlistAdd(wordlist ** list, const char *key)
 }
 
 void
-wordlistJoin(wordlist ** list, wordlist **wl)
+wordlistJoin(wordlist ** list, wordlist ** wl)
 {
     while (*list)
 	list = &(*list)->next;
@@ -122,14 +122,14 @@ wordlistJoin(wordlist ** list, wordlist **wl)
 }
 
 void
-wordlistAddWl(wordlist ** list, wordlist *wl)
+wordlistAddWl(wordlist ** list, wordlist * wl)
 {
     while (*list)
 	list = &(*list)->next;
-    for(;wl;wl=wl->next, list = &(*list)->next) {
+    for (; wl; wl = wl->next, list = &(*list)->next) {
 	*list = memAllocate(MEM_WORDLIST);
 	(*list)->key = xstrdup(wl->key);
-    (*list)->next = NULL;
+	(*list)->next = NULL;
     }
 }
 
@@ -200,8 +200,8 @@ update_maxobjsize(void)
     size_t ms = -1;
 
     for (i = 0; i < Config.cacheSwap.n_configured; i++) {
-        if (Config.cacheSwap.swapDirs[i].max_objsize > ms)
-            ms = Config.cacheSwap.swapDirs[i].max_objsize; 
+	if (Config.cacheSwap.swapDirs[i].max_objsize > ms)
+	    ms = Config.cacheSwap.swapDirs[i].max_objsize;
     }
     store_maxobjsize = ms;
 }
@@ -814,7 +814,7 @@ dump_cachedir(StoreEntry * entry, const char *name, cacheSwap swap)
     int i;
     for (i = 0; i < swap.n_configured; i++) {
 	s = swap.swapDirs + i;
-        s->dump(entry, name, s);
+	s->dump(entry, name, s);
     }
 }
 
@@ -852,7 +852,7 @@ find_fstype(char *type)
 {
     int i;
     for (i = 0; storefs_list[i].typestr != NULL; i++) {
-        if (strcasecmp(type, storefs_list[i].typestr) == 0) {
+	if (strcasecmp(type, storefs_list[i].typestr) == 0) {
 	    return i;
 	}
     }
@@ -872,7 +872,7 @@ parse_cachedir(cacheSwap * swap)
     if ((type_str = strtok(NULL, w_space)) == NULL)
 	self_destruct();
 
-    maxobjsize = (size_t)GetInteger();
+    maxobjsize = (size_t) GetInteger();
 
     if ((path_str = strtok(NULL, w_space)) == NULL)
 	self_destruct();
@@ -896,26 +896,25 @@ parse_cachedir(cacheSwap * swap)
      */
 
     for (i = 0; i < swap->n_configured; i++) {
-        if (0 == strcasecmp(path_str, swap->swapDirs[i].path)) {
+	if (0 == strcasecmp(path_str, swap->swapDirs[i].path)) {
 	    /* This is a little weird, you'll appreciate it later */
 	    fs = find_fstype(type_str);
 	    if (fs < 0) {
-                fatalf("Unknown cache_dir type '%s'\n", type_str);
+		fatalf("Unknown cache_dir type '%s'\n", type_str);
 	    }
 	    sd = swap->swapDirs + i;
 	    storefs_list[fs].reconfigurefunc(sd, i, path_str);
-            sd->max_objsize = maxobjsize;
-            update_maxobjsize();
-            return;
+	    sd->max_objsize = maxobjsize;
+	    update_maxobjsize();
+	    return;
 	}
     }
 
     fs = find_fstype(type_str);
     if (fs < 0) {
-        /* If we get here, we didn't find a matching cache_dir type */
-        fatalf("Unknown cache_dir type '%s'\n", type_str);
+	/* If we get here, we didn't find a matching cache_dir type */
+	fatalf("Unknown cache_dir type '%s'\n", type_str);
     }
-
     allocate_new_swapdir(swap);
     sd = swap->swapDirs + swap->n_configured;
     storefs_list[fs].parsefunc(sd, swap->n_configured, path_str);
@@ -1492,7 +1491,7 @@ parse_refreshpattern(refresh_t ** head)
 }
 
 static int
-check_null_refreshpattern(refresh_t *data)
+check_null_refreshpattern(refresh_t * data)
 {
     return data != NULL;
 }
@@ -1,5 +1,5 @@
 /*
- * $Id: cf_gen.cc,v 1.34 2000/05/02 20:58:30 hno Exp $
+ * $Id: cf_gen.cc,v 1.35 2000/05/12 00:29:06 wessels Exp $
  *
  * DEBUG: none
  * AUTHOR: Max Okumoto
@@ -107,11 +107,12 @@ static void gen_free(Entry *, FILE *);
 static void gen_conf(Entry *, FILE *);
 static void gen_default_if_none(Entry *, FILE *);
 
-static void lineAdd(Line **L, char *str)
+static void
+lineAdd(Line ** L, char *str)
 {
-    while(*L)
-    	L = &(*L)->next;
-    *L=xcalloc(1, sizeof(Line));
+    while (*L)
+	L = &(*L)->next;
+    *L = xcalloc(1, sizeof(Line));
     (*L)->data = xstrdup(str);
 }
 
@@ -431,7 +432,7 @@ gen_default_if_none(Entry * head, FILE * fp)
 	    fprintf(fp, "\t}\n");
 	}
 	if (entry->ifdef)
-	fprintf(fp, "#endif\n");
+	    fprintf(fp, "#endif\n");
     }
     fprintf(fp, "}\n\n");
 }
@@ -535,25 +536,27 @@ gen_free(Entry * head, FILE * fp)
     fprintf(fp, "}\n\n");
 }
 
-static int defined(char *name)
+static int
+defined(char *name)
 {
-	int i=0;
-	if (!name)
-	    return 1;
-	for(i=0;strcmp(defines[i].name, name) != 0; i++) {
-	    assert(defines[i].name);
-	}
-	return defines[i].defined;
+    int i = 0;
+    if (!name)
+	return 1;
+    for (i = 0; strcmp(defines[i].name, name) != 0; i++) {
+	assert(defines[i].name);
+    }
+    return defines[i].defined;
 }
 
-static const char *available_if(char *name)
+static const char *
+available_if(char *name)
 {
-	int i=0;
-	assert(name);
-	for(i=0;strcmp(defines[i].name, name) != 0; i++) {
-	    assert(defines[i].name);
-	}
-	return defines[i].enable;
+    int i = 0;
+    assert(name);
+    for (i = 0; strcmp(defines[i].name, name) != 0; i++) {
+	assert(defines[i].name);
+    }
+    return defines[i].enable;
 }
 
 static void
@@ -581,7 +584,7 @@ gen_conf(Entry * head, FILE * fp)
 	for (line = entry->doc; line != NULL; line = line->next) {
 	    fprintf(fp, "#%s\n", line->data);
 	}
-	if (entry->default_value && strcmp(entry->default_value,"none") != 0) {
+	if (entry->default_value && strcmp(entry->default_value, "none") != 0) {
 	    sprintf(buf, "%s %s", entry->name, entry->default_value);
 	    lineAdd(&def, buf);
 	}
@@ -594,7 +597,7 @@ gen_conf(Entry * head, FILE * fp)
 	if (entry->nocomment)
 	    blank = 0;
 	if (!def && entry->doc && !entry->nocomment &&
-		strcmp(entry->name, "comment") != 0)
+	    strcmp(entry->name, "comment") != 0)
 	    lineAdd(&def, "none");
 	if (def && (entry->doc || entry->nocomment)) {
 	    if (blank)
@@ -607,7 +610,7 @@ gen_conf(Entry * head, FILE * fp)
 		free(line->data);
 		free(line);
 	    }
-	    blank=1;
+	    blank = 1;
 	}
 	if (entry->nocomment && blank)
 	    fprintf(fp, "#\n");
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side.cc,v 1.482 2000/05/11 03:15:51 wessels Exp $
+ * $Id: client_side.cc,v 1.483 2000/05/12 00:29:06 wessels Exp $
  *
  * DEBUG: section 33    Client-side Routines
  * AUTHOR: Duane Wessels
@@ -139,7 +139,7 @@ clientIdentDone(const char *ident, void *data)
 #endif
 
 static aclCheck_t *
-clientAclChecklistCreate(const acl_access *acl, const clientHttpRequest *http)
+clientAclChecklistCreate(const acl_access * acl, const clientHttpRequest * http)
 {
     aclCheck_t *ch;
     ConnStateData *conn = http->conn;
@@ -1099,10 +1099,10 @@ clientBuildRangeHeader(clientHttpRequest * http, HttpReply * rep)
 	range_err = "canonization failed";
     else if (httpHdrRangeIsComplex(http->request->range))
 	range_err = "too complex range header";
-    else if (!request->flags.cachable) /* from we_do_ranges in http.c */
+    else if (!request->flags.cachable)	/* from we_do_ranges in http.c */
 	range_err = "non-cachable request";
     else if (!is_hit && Config.rangeOffsetLimit < httpHdrRangeFirstOffset(request->range)
-	    && Config.rangeOffsetLimit != -1) /* from we_do_ranges in http.c */
+	&& Config.rangeOffsetLimit != -1)	/* from we_do_ranges in http.c */
 	range_err = "range outside range_offset_limit";
     /* get rid of our range specs on error */
     if (range_err) {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: comm_select.cc,v 1.42 2000/05/03 17:15:41 adrian Exp $
+ * $Id: comm_select.cc,v 1.43 2000/05/12 00:29:07 wessels Exp $
  *
  * DEBUG: section 5     Socket Functions
  *
@@ -34,7 +34,7 @@
 
 #include "squid.h"
 
-static int MAX_POLL_TIME = 1000; /* see also comm_quick_poll_required() */
+static int MAX_POLL_TIME = 1000;	/* see also comm_quick_poll_required() */
 
 #ifndef        howmany
 #define howmany(x, y)   (((x)+((y)-1))/(y))
@@ -326,8 +326,8 @@ comm_poll(int msec)
 	getCurrentTime();
 	start = current_dtime;
 #endif
-    /* Handle any fs callbacks that need doing */
-    storeDirCallback();
+	/* Handle any fs callbacks that need doing */
+	storeDirCallback();
 #if DELAY_POOLS
 	FD_ZERO(&slowfds);
 #endif
@@ -661,8 +661,8 @@ comm_select(int msec)
 #if DELAY_POOLS
 	FD_ZERO(&slowfds);
 #endif
-        /* Handle any fs callbacks that need doing */
-        storeDirCallback();
+	/* Handle any fs callbacks that need doing */
+	storeDirCallback();
 	if (commCheckICPIncoming)
 	    comm_select_icp_incoming();
 	if (commCheckDNSIncoming)
@@ -1,6 +1,6 @@
 
 /*
- * $Id: defines.h,v 1.80 2000/05/03 17:15:41 adrian Exp $
+ * $Id: defines.h,v 1.81 2000/05/12 00:29:07 wessels Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -268,4 +268,3 @@
 #ifndef _PATH_DEVNULL
 #define _PATH_DEVNULL "/dev/null"
 #endif
-
@@ -1,6 +1,6 @@
 
 /*
- * $Id: delay_pools.cc,v 1.15 2000/05/07 16:18:19 adrian Exp $
+ * $Id: delay_pools.cc,v 1.16 2000/05/12 00:29:07 wessels Exp $
  *
  * DEBUG: section 77    Delay Pools
  * AUTHOR: David Luyer <luyer@ucs.uwa.edu.au>
@@ -222,18 +222,18 @@ delayInitDelayPool(unsigned short pool, u_char class, delaySpecSet * rates)
      */
     switch (class) {
     case 1:
-	delay_data[pool].class1->aggregate = (int)(((double)rates->aggregate.max_bytes *
-	    Config.Delay.initial) / 100);
+	delay_data[pool].class1->aggregate = (int) (((double) rates->aggregate.max_bytes *
+		Config.Delay.initial) / 100);
 	break;
     case 2:
-	delay_data[pool].class2->aggregate = (int)(((double)rates->aggregate.max_bytes *
-	    Config.Delay.initial) / 100);
+	delay_data[pool].class2->aggregate = (int) (((double) rates->aggregate.max_bytes *
+		Config.Delay.initial) / 100);
 	delay_data[pool].class2->individual_map[0] = 255;
 	delay_data[pool].class2->individual_255_used = 0;
 	break;
     case 3:
-	delay_data[pool].class3->aggregate = (int)(((double)rates->aggregate.max_bytes *
-	    Config.Delay.initial) / 100);
+	delay_data[pool].class3->aggregate = (int) (((double) rates->aggregate.max_bytes *
+		Config.Delay.initial) / 100);
 	delay_data[pool].class3->network_map[0] = 255;
 	delay_data[pool].class3->network_255_used = 0;
 	memset(&delay_data[pool].class3->individual_255_used, '\0',
@@ -307,8 +307,8 @@ delayClient(request_t * r)
 	    if (!delay_data[pool].class2->individual_255_used) {
 		delay_data[pool].class2->individual_255_used = 1;
 		delay_data[pool].class2->individual[IND_MAP_SZ - 1] =
-		    (int)(((double)Config.Delay.rates[pool]->individual.max_bytes *
-		    Config.Delay.initial) / 100);
+		    (int) (((double) Config.Delay.rates[pool]->individual.max_bytes *
+			Config.Delay.initial) / 100);
 	    }
 	    return delayId(pool + 1, 255);
 	}
@@ -320,8 +320,8 @@ delayClient(request_t * r)
 		assert(i < (IND_MAP_SZ - 1));
 		delay_data[pool].class2->individual_map[i + 1] = 255;
 		delay_data[pool].class2->individual[i] =
-		    (int)(((double)Config.Delay.rates[pool]->individual.max_bytes *
-		    Config.Delay.initial) / 100);
+		    (int) (((double) Config.Delay.rates[pool]->individual.max_bytes *
+			Config.Delay.initial) / 100);
 		break;
 	    }
 	}
@@ -336,8 +336,8 @@ delayClient(request_t * r)
 	if (!delay_data[pool].class3->network_255_used) {
 	    delay_data[pool].class3->network_255_used = 1;
 	    delay_data[pool].class3->network[255] =
-		(int)(((double)Config.Delay.rates[pool]->network.max_bytes *
-		Config.Delay.initial) / 100);
+		(int) (((double) Config.Delay.rates[pool]->network.max_bytes *
+		    Config.Delay.initial) / 100);
 	}
     } else {
 	for (i = 0; i < NET_MAP_SZ; i++) {
@@ -349,8 +349,8 @@ delayClient(request_t * r)
 		assert(i < (NET_MAP_SZ - 1));
 		delay_data[pool].class3->network_map[i + 1] = 255;
 		delay_data[pool].class3->network[i] =
-		    (int)(((double)Config.Delay.rates[pool]->network.max_bytes *
-		    Config.Delay.initial) / 100);
+		    (int) (((double) Config.Delay.rates[pool]->network.max_bytes *
+			Config.Delay.initial) / 100);
 		break;
 	    }
 	}
@@ -362,8 +362,8 @@ delayClient(request_t * r)
 	    delay_data[pool].class3->individual_255_used[i / 8] |= (1 << (i % 8));
 	    assert(position < C3_IND_SZ);
 	    delay_data[pool].class3->individual[position] =
-		(int)(((double)Config.Delay.rates[pool]->individual.max_bytes *
-		Config.Delay.initial) / 100);
+		(int) (((double) Config.Delay.rates[pool]->individual.max_bytes *
+		    Config.Delay.initial) / 100);
 	}
 	return delayId(pool + 1, position);
     }
@@ -380,8 +380,8 @@ delayClient(request_t * r)
 	    position |= j;
 	    assert(position < C3_IND_SZ);
 	    delay_data[pool].class3->individual[position] =
-		(int)(((double)Config.Delay.rates[pool]->individual.max_bytes *
-		Config.Delay.initial) / 100);
+		(int) (((double) Config.Delay.rates[pool]->individual.max_bytes *
+		    Config.Delay.initial) / 100);
 	    break;
 	}
     }
@@ -611,7 +611,7 @@ delayMostBytesWanted(const MemObject * mem, int max)
     store_client *sc;
     dlink_node *node;
     for (node = mem->clients.head; node; node = node->next) {
-        sc = (store_client *)node->data;
+	sc = (store_client *) node->data;
 	if (sc->callback_data == NULL)	/* open slot */
 	    continue;
 	if (sc->type != STORE_MEM_CLIENT)
@@ -631,7 +631,7 @@ delayMostBytesAllowed(const MemObject * mem)
     dlink_node *node;
     delay_id d = 0;
     for (node = mem->clients.head; node; node = node->next) {
-        sc = (store_client *)node->data;
+	sc = (store_client *) node->data;
 	if (sc->callback_data == NULL)	/* open slot */
 	    continue;
 	if (sc->type != STORE_MEM_CLIENT)
@@ -646,7 +646,7 @@ delayMostBytesAllowed(const MemObject * mem)
 }
 
 void
-delaySetStoreClient(store_client *sc, delay_id delay_id)
+delaySetStoreClient(store_client * sc, delay_id delay_id)
 {
     assert(sc != NULL);
     sc->delay_id = delay_id;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: disk.cc,v 1.148 2000/05/03 17:15:41 adrian Exp $
+ * $Id: disk.cc,v 1.149 2000/05/12 00:29:07 wessels Exp $
  *
  * DEBUG: section 6     Disk I/O Routines
  * AUTHOR: Harvest Derived
@@ -188,7 +188,7 @@ diskHandleWrite(int fd, void *notused)
 	fd, (int) (fdd->write_q->len - fdd->write_q->buf_offset));
     errno = 0;
     if (fdd->write_q->file_offset != -1)
-        lseek(fd, fdd->write_q->file_offset, SEEK_SET);
+	lseek(fd, fdd->write_q->file_offset, SEEK_SET);
     len = write(fd,
 	fdd->write_q->buf + fdd->write_q->buf_offset,
 	fdd->write_q->len - fdd->write_q->buf_offset);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: dns_internal.cc,v 1.24 2000/05/11 22:21:01 wessels Exp $
+ * $Id: dns_internal.cc,v 1.25 2000/05/12 00:29:07 wessels Exp $
  *
  * DEBUG: section 78    DNS lookups; interacts with lib/rfc1035.c
  * AUTHOR: Duane Wessels
@@ -205,7 +205,7 @@ idnsSendQuery(idns_query * q)
     assert(nns > 0);
     assert(q->lru.next == NULL);
     assert(q->lru.prev == NULL);
-try_again:
+  try_again:
     ns = q->nsends % nns;
     x = comm_udp_sendto(DnsSocket,
 	&nameservers[ns].S,
@@ -355,7 +355,7 @@ idnsCheckQueue(void *unused)
     event_queued = 0;
     for (n = lru_list.tail; n; n = p) {
 	q = n->data;
-	if (tvSubDsec(q->sent_t, current_time) < Config.Timeout.idns_retransmit * ( 1 << q->nsends % nns))
+	if (tvSubDsec(q->sent_t, current_time) < Config.Timeout.idns_retransmit * (1 << q->nsends % nns))
 	    break;
 	debug(78, 3) ("idnsCheckQueue: ID %#04x timeout\n",
 	    q->id);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: forward.cc,v 1.72 2000/05/02 20:28:30 hno Exp $
+ * $Id: forward.cc,v 1.73 2000/05/12 00:29:07 wessels Exp $
  *
  * DEBUG: section 17    Request Forwarding
  * AUTHOR: Duane Wessels
@@ -137,8 +137,8 @@ fwdServerClosed(int fd, void *data)
 	    FwdServer *fs = fwdState->servers;
 	    FwdServer **T, *T2 = NULL;
 	    fwdState->servers = fs->next;
-	    for (T = &fwdState->servers; *T; T2=*T, T = &(*T)->next);
-	    if (T2 && T2->peer)  {
+	    for (T = &fwdState->servers; *T; T2 = *T, T = &(*T)->next);
+	    if (T2 && T2->peer) {
 		/* cycle */
 		*T = fs;
 		fs->next = NULL;
@@ -251,7 +251,7 @@ fwdConnectStart(void *data)
 	ctimeout = fs->peer->connect_timeout > 0 ? fs->peer->connect_timeout
 	    : Config.Timeout.peer_connect;
     } else if (fwdState->request->flags.accelerated &&
-	    	Config.Accel.single_host && Config.Accel.host) {
+	Config.Accel.single_host && Config.Accel.host) {
 	host = Config.Accel.host;
 	port = Config.Accel.port;
 	ctimeout = Config.Timeout.connect;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: async_io.cc,v 1.1 2000/05/03 17:15:46 adrian Exp $
+ * $Id: async_io.cc,v 1.2 2000/05/12 00:29:18 wessels Exp $
  *
  * DEBUG: section 32    Asynchronous Disk I/O
  * AUTHOR: Pete Bentley <pete@demon.net>
@@ -76,7 +76,7 @@ static OBJH aioStats;
 static MemPool *aio_ctrl_pool;
 static void aioFDWasClosed(int fd);
 
-MemPool * aio_state_pool;
+MemPool *aio_state_pool;
 
 static void
 aioFDWasClosed(int fd)
@@ -219,7 +219,7 @@ aioWrite(int fd, int offset, char *bufp, int len, AIOCB * callback, void *callba
 	if (callback)
 	    (callback) (fd, callback_data, -1, errno);
 	if (free_func)
-            free_func(bufp);
+	    free_func(bufp);
 	return;
     }
     ctrlp = memPoolAlloc(aio_ctrl_pool);
@@ -249,7 +249,7 @@ aioWrite(int fd, int offset, char *bufp, int len, AIOCB * callback, void *callba
      * aio_write copies the buffer so we can free it here
      */
     if (free_func)
-        free_func(bufp);
+	free_func(bufp);
 }				/* aioWrite */
 
 
@@ -352,7 +352,7 @@ aioUnlink(const char *pathname, AIOCB * callback, void *callback_data)
 
 
 void
-aioCheckCallbacks(SwapDir *SD)
+aioCheckCallbacks(SwapDir * SD)
 {
     aio_result_t *resultp;
     aio_ctrl_t *ctrlp;
@@ -407,7 +407,7 @@ aioStats(StoreEntry * sentry)
 
 /* Flush all pending I/O */
 void
-aioSync(SwapDir *SD)
+aioSync(SwapDir * SD)
 {
     if (!initialised)
 	return;			/* nothing to do then */
@@ -40,16 +40,16 @@ int aio_get_queue_len(void);
 
 void aioInit(void);
 void aioDone(void);
-void aioCancel(int); 
-void aioOpen(const char *, int, mode_t, AIOCB *, void *);  
+void aioCancel(int);
+void aioOpen(const char *, int, mode_t, AIOCB *, void *);
 void aioClose(int);
 void aioWrite(int, int offset, char *, int size, AIOCB *, void *, FREE *);
 void aioRead(int, int offset, char *, int size, AIOCB *, void *);
 void aioStat(char *, struct stat *, AIOCB *, void *);
 void aioUnlink(const char *, AIOCB *, void *);
 void aioCheckCallbacks(SwapDir *);
 void aioSync(SwapDir *);
-int aioQueueSize(void); 
+int aioQueueSize(void);
 
 struct _aioinfo_t {
     int swaplog_fd;
@@ -76,14 +76,14 @@ typedef struct _aioinfo_t aioinfo_t;
 typedef struct _aiostate_t aiostate_t;
 
 /* The aio_state memory pool */
-extern MemPool * aio_state_pool;
+extern MemPool *aio_state_pool;
 
 extern void storeAufsDirMapBitReset(SwapDir *, sfileno);
 extern int storeAufsDirMapBitAllocate(SwapDir *);
 
-extern char * storeAufsDirFullPath(SwapDir *SD, sfileno filn, char *fullpath);
+extern char *storeAufsDirFullPath(SwapDir * SD, sfileno filn, char *fullpath);
 extern void storeAufsDirUnlinkFile(SwapDir *, sfileno);
-extern void storeAufsDirReplAdd(SwapDir *SD, StoreEntry *);
+extern void storeAufsDirReplAdd(SwapDir * SD, StoreEntry *);
 extern void storeAufsDirReplRemove(StoreEntry *);
 
 /*
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_dir_aufs.cc,v 1.1 2000/05/03 17:15:46 adrian Exp $
+ * $Id: store_dir_aufs.cc,v 1.2 2000/05/12 00:29:18 wessels Exp $
  *
  * DEBUG: section 47    Store Directory Routines
  * AUTHOR: Duane Wessels
@@ -81,7 +81,7 @@ static char *storeAufsDirSwapLogFile(SwapDir *, const char *);
 static EVH storeAufsDirRebuildFromDirectory;
 static EVH storeAufsDirRebuildFromSwapLog;
 static int storeAufsDirGetNextFile(RebuildState *, int *sfileno, int *size);
-static StoreEntry *storeAufsDirAddDiskRestore(SwapDir *SD, const cache_key * key,
+static StoreEntry *storeAufsDirAddDiskRestore(SwapDir * SD, const cache_key * key,
     int file_number,
     size_t swap_file_sz,
     time_t expires,
@@ -130,69 +130,69 @@ static time_t storeAufsDirExpiredReferenceAge(SwapDir *);
  */
 
 int
-storeAufsDirMapBitTest(SwapDir *SD, int fn)
+storeAufsDirMapBitTest(SwapDir * SD, int fn)
 {
     sfileno filn = fn;
     aioinfo_t *aioinfo;
-    aioinfo = (aioinfo_t *)SD->fsdata;
+    aioinfo = (aioinfo_t *) SD->fsdata;
     return file_map_bit_test(aioinfo->map, filn);
 }
- 
+
 void
-storeAufsDirMapBitSet(SwapDir *SD, int fn)
-{  
+storeAufsDirMapBitSet(SwapDir * SD, int fn)
+{
     sfileno filn = fn;
     aioinfo_t *aioinfo;
-    aioinfo = (aioinfo_t *)SD->fsdata;
+    aioinfo = (aioinfo_t *) SD->fsdata;
     file_map_bit_set(aioinfo->map, filn);
 }
- 
+
 void
-storeAufsDirMapBitReset(SwapDir *SD, int fn)
-{ 
+storeAufsDirMapBitReset(SwapDir * SD, int fn)
+{
     sfileno filn = fn;
     aioinfo_t *aioinfo;
-    aioinfo = (aioinfo_t *)SD->fsdata;
+    aioinfo = (aioinfo_t *) SD->fsdata;
     file_map_bit_reset(aioinfo->map, filn);
 }
 
 int
-storeAufsDirMapBitAllocate(SwapDir *SD)
+storeAufsDirMapBitAllocate(SwapDir * SD)
 {
-    aioinfo_t *aioinfo = (aioinfo_t *)SD->fsdata;
+    aioinfo_t *aioinfo = (aioinfo_t *) SD->fsdata;
     int fn;
     fn = file_map_allocate(aioinfo->map, aioinfo->suggest);
     file_map_bit_set(aioinfo->map, fn);
     aioinfo->suggest = fn + 1;
     return fn;
 }
 
-    
+
 /*
  * Initialise the asyncufs bitmap
  *
  * If there already is a bitmap, and the numobjects is larger than currently
  * configured, we allocate a new bitmap and 'grow' the old one into it.
  */
 static void
-storeAufsDirInitBitmap(SwapDir *sd)
+storeAufsDirInitBitmap(SwapDir * sd)
 {
-    aioinfo_t *aioinfo = (aioinfo_t *)sd->fsdata;
+    aioinfo_t *aioinfo = (aioinfo_t *) sd->fsdata;
 
     if (aioinfo->map == NULL) {
-        /* First time */
+	/* First time */
 	aioinfo->map = file_map_create();
     } else if (aioinfo->map->max_n_files) {
-        /* it grew, need to expand */
-        /* XXX We don't need it anymore .. */
+	/* it grew, need to expand */
+	/* XXX We don't need it anymore .. */
     }
     /* else it shrunk, and we leave the old one in place */
 }
 
 static char *
 storeAufsDirSwapSubDir(SwapDir * sd, int subdirn)
 {
-    aioinfo_t *aioinfo = (aioinfo_t *)sd->fsdata;
+    aioinfo_t *aioinfo = (aioinfo_t *) sd->fsdata;
 
     LOCAL_ARRAY(char, fullfilename, SQUID_MAXPATHLEN);
     assert(0 <= subdirn && subdirn < aioinfo->l1);
@@ -245,7 +245,7 @@ storeAufsDirVerifyDirectory(const char *path)
 static int
 storeAufsDirVerifyCacheDirs(SwapDir * sd)
 {
-    aioinfo_t *aioinfo = (aioinfo_t *)sd->fsdata;
+    aioinfo_t *aioinfo = (aioinfo_t *) sd->fsdata;
     int j;
     const char *path = sd->path;
 
@@ -262,7 +262,7 @@ storeAufsDirVerifyCacheDirs(SwapDir * sd)
 static void
 storeAufsDirCreateSwapSubDirs(SwapDir * sd)
 {
-    aioinfo_t *aioinfo = (aioinfo_t *)sd->fsdata;
+    aioinfo_t *aioinfo = (aioinfo_t *) sd->fsdata;
     int i, k;
     int should_exist;
     LOCAL_ARRAY(char, name, MAXPATHLEN);
@@ -288,31 +288,31 @@ storeAufsDirSwapLogFile(SwapDir * sd, const char *ext)
     LOCAL_ARRAY(char, digit, 32);
     char *pathtmp2;
     if (Config.Log.swap) {
-        xstrncpy(pathtmp, sd->path, SQUID_MAXPATHLEN - 64);
-        while (index(pathtmp,'/'))
-            *index(pathtmp,'/')='.';
-        while (strlen(pathtmp) && pathtmp[strlen(pathtmp)-1]=='.')
-            pathtmp[strlen(pathtmp)-1]= '\0';
-        for(pathtmp2 = pathtmp; *pathtmp2 == '.'; pathtmp2++);
-        snprintf(path, SQUID_MAXPATHLEN-64, Config.Log.swap, pathtmp2);
-        if (strncmp(path, Config.Log.swap, SQUID_MAXPATHLEN - 64) == 0) {
-            strcat(path, ".");
-            snprintf(digit, 32, "%02d", sd->index);
-            strncat(path, digit, 3);
-        }
+	xstrncpy(pathtmp, sd->path, SQUID_MAXPATHLEN - 64);
+	while (index(pathtmp, '/'))
+	    *index(pathtmp, '/') = '.';
+	while (strlen(pathtmp) && pathtmp[strlen(pathtmp) - 1] == '.')
+	    pathtmp[strlen(pathtmp) - 1] = '\0';
+	for (pathtmp2 = pathtmp; *pathtmp2 == '.'; pathtmp2++);
+	snprintf(path, SQUID_MAXPATHLEN - 64, Config.Log.swap, pathtmp2);
+	if (strncmp(path, Config.Log.swap, SQUID_MAXPATHLEN - 64) == 0) {
+	    strcat(path, ".");
+	    snprintf(digit, 32, "%02d", sd->index);
+	    strncat(path, digit, 3);
+	}
     } else {
-        xstrncpy(path, sd->path, SQUID_MAXPATHLEN - 64);
-        strcat(path, "/swap.state");
+	xstrncpy(path, sd->path, SQUID_MAXPATHLEN - 64);
+	strcat(path, "/swap.state");
     }
     if (ext)
-        strncat(path, ext, 16);
+	strncat(path, ext, 16);
     return path;
 }
 
 static void
 storeAufsDirOpenSwapLog(SwapDir * sd)
 {
-    aioinfo_t *aioinfo = (aioinfo_t *)sd->fsdata;
+    aioinfo_t *aioinfo = (aioinfo_t *) sd->fsdata;
     char *path;
     int fd;
     path = storeAufsDirSwapLogFile(sd, NULL);
@@ -332,7 +332,7 @@ storeAufsDirOpenSwapLog(SwapDir * sd)
 static void
 storeAufsDirCloseSwapLog(SwapDir * sd)
 {
-    aioinfo_t *aioinfo = (aioinfo_t *)sd->fsdata;
+    aioinfo_t *aioinfo = (aioinfo_t *) sd->fsdata;
     if (aioinfo->swaplog_fd < 0)	/* not open */
 	return;
     file_close(aioinfo->swaplog_fd);
@@ -551,14 +551,14 @@ storeAufsDirRebuildFromSwapLog(void *data)
 		 * because adding to store_swap_size happens in
 		 * the cleanup procedure.
 		 */
-                storeExpireNow(e);
-                storeReleaseRequest(e);
-                storeAufsDirReplRemove(e);
+		storeExpireNow(e);
+		storeReleaseRequest(e);
+		storeAufsDirReplRemove(e);
 		storeRelease(e);
 		if (e->swap_filen > -1) {
 		    /* Fake a unlink here, this is a bad hack :( */
 		    e->swap_filen = -1;
-                    e->swap_dirn = -1;
+		    e->swap_dirn = -1;
 		}
 		rb->counts.objcount--;
 		rb->counts.cancelcount++;
@@ -639,14 +639,14 @@ storeAufsDirRebuildFromSwapLog(void *data)
 	} else if (e) {
 	    /* key already exists, this swapfile not being used */
 	    /* junk old, load new */
-            storeExpireNow(e);
-            storeReleaseRequest(e);
-            storeAufsDirReplRemove(e);
+	    storeExpireNow(e);
+	    storeReleaseRequest(e);
+	    storeAufsDirReplRemove(e);
 	    storeRelease(e);
 	    if (e->swap_filen > -1) {
 		/* Fake a unlink here, this is a bad hack :( */
 		e->swap_filen = -1;
-                e->swap_dirn = -1;
+		e->swap_dirn = -1;
 	    }
 	    rb->counts.dupcount++;
 	} else {
@@ -675,7 +675,7 @@ static int
 storeAufsDirGetNextFile(RebuildState * rb, int *sfileno, int *size)
 {
     SwapDir *SD = rb->sd;
-    aioinfo_t *aioinfo = (aioinfo_t *)SD->fsdata;
+    aioinfo_t *aioinfo = (aioinfo_t *) SD->fsdata;
     int fd = -1;
     int used = 0;
     int dirs_opened = 0;
@@ -761,7 +761,7 @@ storeAufsDirGetNextFile(RebuildState * rb, int *sfileno, int *size)
 /* Add a new object to the cache with empty memory copy and pointer to disk
  * use to rebuild store from disk. */
 static StoreEntry *
-storeAufsDirAddDiskRestore(SwapDir *SD, const cache_key * key,
+storeAufsDirAddDiskRestore(SwapDir * SD, const cache_key * key,
     int file_number,
     size_t swap_file_sz,
     time_t expires,
@@ -842,7 +842,7 @@ storeAufsDirRebuild(SwapDir * sd)
 static void
 storeAufsDirCloseTmpSwapLog(SwapDir * sd)
 {
-    aioinfo_t *aioinfo = (aioinfo_t *)sd->fsdata;
+    aioinfo_t *aioinfo = (aioinfo_t *) sd->fsdata;
     char *swaplog_path = xstrdup(storeAufsDirSwapLogFile(sd, NULL));
     char *new_path = xstrdup(storeAufsDirSwapLogFile(sd, ".new"));
     int fd;
@@ -870,7 +870,7 @@ storeAufsDirCloseTmpSwapLog(SwapDir * sd)
 static FILE *
 storeAufsDirOpenTmpSwapLog(SwapDir * sd, int *clean_flag, int *zero_flag)
 {
-    aioinfo_t *aioinfo = (aioinfo_t *)sd->fsdata;
+    aioinfo_t *aioinfo = (aioinfo_t *) sd->fsdata;
     char *swaplog_path = xstrdup(storeAufsDirSwapLogFile(sd, NULL));
     char *clean_path = xstrdup(storeAufsDirSwapLogFile(sd, ".last-clean"));
     char *new_path = xstrdup(storeAufsDirSwapLogFile(sd, ".new"));
@@ -1056,7 +1056,7 @@ storeAufsDirWriteCleanClose(SwapDir * sd)
 static void
 storeAufsDirSwapLog(const SwapDir * sd, const StoreEntry * e, int op)
 {
-    aioinfo_t *aioinfo = (aioinfo_t *)sd->fsdata;
+    aioinfo_t *aioinfo = (aioinfo_t *) sd->fsdata;
     storeSwapLogData *s = xcalloc(1, sizeof(storeSwapLogData));
     s->op = (char) op;
     s->swap_filen = e->swap_filen;
@@ -1115,7 +1115,7 @@ storeAufsDirClean(int swap_index)
     N0 = n_asyncufs_dirs;
     D0 = asyncufs_dir_index[swap_index % N0];
     SD = &Config.cacheSwap.swapDirs[D0];
-    aioinfo = (aioinfo_t *)SD->fsdata;
+    aioinfo = (aioinfo_t *) SD->fsdata;
     N1 = aioinfo->l1;
     D1 = (swap_index / N0) % N1;
     N2 = aioinfo->l2;
@@ -1137,7 +1137,7 @@ storeAufsDirClean(int swap_index)
     while ((de = readdir(dp)) != NULL && k < 20) {
 	if (sscanf(de->d_name, "%X", &swapfileno) != 1)
 	    continue;
-	fn = swapfileno; /* XXX should remove this cruft ! */
+	fn = swapfileno;	/* XXX should remove this cruft ! */
 	if (storeAufsDirValidFileno(SD, fn))
 	    if (storeAufsDirMapBitTest(SD, fn))
 		if (storeAufsFilenoBelongsHere(fn, D0, D1, D2))
@@ -1183,7 +1183,7 @@ storeAufsDirCleanEvent(void *unused)
     assert(n_asyncufs_dirs);
     if (NULL == asyncufs_dir_index) {
 	SwapDir *sd;
-        aioinfo_t *aioinfo;
+	aioinfo_t *aioinfo;
 	/*
 	 * Initialize the little array that translates ASYNCUFS cache_dir
 	 * number into the Config.cacheSwap.swapDirs array index.
@@ -1194,7 +1194,7 @@ storeAufsDirCleanEvent(void *unused)
 	    if (!storeAufsDirIs(sd))
 		continue;
 	    asyncufs_dir_index[n++] = i;
-            aioinfo = (aioinfo_t *)sd->fsdata;
+	    aioinfo = (aioinfo_t *) sd->fsdata;
 	    j += (aioinfo->l1 * aioinfo->l2);
 	}
 	assert(n == n_asyncufs_dirs);
@@ -1233,7 +1233,7 @@ storeAufsFilenoBelongsHere(int fn, int F0, int F1, int F2)
     int filn = fn;
     aioinfo_t *aioinfo;
     assert(F0 < Config.cacheSwap.n_configured);
-    aioinfo = (aioinfo_t *)Config.cacheSwap.swapDirs[F0].fsdata;
+    aioinfo = (aioinfo_t *) Config.cacheSwap.swapDirs[F0].fsdata;
     L1 = aioinfo->l1;
     L2 = aioinfo->l2;
     D1 = ((filn / L2) / L2) % L1;
@@ -1245,19 +1245,19 @@ storeAufsFilenoBelongsHere(int fn, int F0, int F1, int F2)
     return 1;
 }
 
-int 
-storeAufsDirValidFileno(SwapDir *SD, sfileno filn)
+int
+storeAufsDirValidFileno(SwapDir * SD, sfileno filn)
 {
-    aioinfo_t *aioinfo = (aioinfo_t *)SD->fsdata;
+    aioinfo_t *aioinfo = (aioinfo_t *) SD->fsdata;
     if (filn < 0)
-        return 0;
-    if (filn > aioinfo->map->max_n_files)  
-        return 0;
+	return 0;
+    if (filn > aioinfo->map->max_n_files)
+	return 0;
     return 1;
 }
 
 void
-storeAufsDirMaintain(SwapDir *SD)
+storeAufsDirMaintain(SwapDir * SD)
 {
     StoreEntry *e = NULL;
     int scanned = 0;
@@ -1276,135 +1276,134 @@ storeAufsDirMaintain(SwapDir *SD)
     link_list *locked_entries = NULL;
 #if HEAP_REPLACEMENT_DEBUG
     if (!verify_heap_property(SD->repl.heap.heap)) {
-        debug(20, 1) ("Heap property violated!\n");
+	debug(20, 1) ("Heap property violated!\n");
     }
 #endif
 #endif
     /* We can't delete objects while rebuilding swap */
     if (store_dirs_rebuilding) {
-        return;
+	return;
     } else {
-        f = (double) (store_swap_size - store_swap_low) / (store_swap_high - store_swap_low);
-        f = f < 0.0 ? 0.0 : f > 1.0 ? 1.0 : f;
-        max_scan = (int) (f * 400.0 + 100.0);
-        max_remove = (int) (f * 70.0 + 10.0);
+	f = (double) (store_swap_size - store_swap_low) / (store_swap_high - store_swap_low);
+	f = f < 0.0 ? 0.0 : f > 1.0 ? 1.0 : f;
+	max_scan = (int) (f * 400.0 + 100.0);
+	max_remove = (int) (f * 70.0 + 10.0);
 	/*
 	 * This is kinda cheap, but so we need this priority hack?
-         */
+	 */
 #if 0
-        eventAdd("MaintainSwapSpace", storeMaintainSwapSpace, NULL, 1.0 - f, 1);
+	eventAdd("MaintainSwapSpace", storeMaintainSwapSpace, NULL, 1.0 - f, 1);
 #endif
     }
     debug(20, 3) ("storeMaintainSwapSpace: f=%f, max_scan=%d, max_remove=%d\n", f, max_scan, max_remove);
 #if HEAP_REPLACEMENT
     while (heap_nodes(SD->repl.heap.heap) > 0) {
-        if (store_swap_size < store_swap_low)
-            break;
-        if (expired >= max_remove)
-            break;
-        if (scanned >= max_scan)
-            break;
-        age = heap_peepminkey(SD->repl.heap.heap);
-        e = heap_extractmin(SD->repl.heap.heap);
-        e->repl.node = NULL;         /* no longer in the heap */
-        scanned++;
-        if (storeEntryLocked(e)) {
-            /*
-             * Entry is in use ... put it in a linked list to ignore it.
-             */
-            if (!EBIT_TEST(e->flags, ENTRY_SPECIAL)) {
-                /*
-                 * If this was a "SPECIAL" do not add it back into the heap.
-                 * It will always be "SPECIAL" and therefore never removed.
-                 */
-                debug(20, 4) ("storeAufsDirMaintain: locked url %s\n",
-                    (e->mem_obj && e->mem_obj->url) ? e->mem_obj->url : storeKeyText(e->
-key));
-                linklistPush(&locked_entries, e);
-            }
-            locked++;
-            continue;
-        } else if (storeAufsDirCheckExpired(SD, e)) {
-            /*
-             * Note: This will not check the reference age ifdef
-             * HEAP_REPLACEMENT, but it does some other useful
-             * checks...
-             */
-            expired++;
-            debug(20, 3) ("Released store object age %f size %d refs %d key %s\n",
-                age, e->swap_file_sz, e->refcount, storeKeyText(e->key));
-            min_age = age;
-            storeRelease(e);
-        } else {
-            /*
-             * Did not expire the object so we need to add it back
-             * into the heap!
-             */
-            debug(20, 5) ("storeMaintainSwapSpace: non-expired %s\n",
-                storeKeyText(e->key));
-            linklistPush(&locked_entries, e);
-            continue;
-        }
-        if (store_swap_size < store_swap_low)
-            break;
-        else if (expired >= max_remove)
-            break;
-        else if (scanned >= max_scan)
-            break;
+	if (store_swap_size < store_swap_low)
+	    break;
+	if (expired >= max_remove)
+	    break;
+	if (scanned >= max_scan)
+	    break;
+	age = heap_peepminkey(SD->repl.heap.heap);
+	e = heap_extractmin(SD->repl.heap.heap);
+	e->repl.node = NULL;	/* no longer in the heap */
+	scanned++;
+	if (storeEntryLocked(e)) {
+	    /*
+	     * Entry is in use ... put it in a linked list to ignore it.
+	     */
+	    if (!EBIT_TEST(e->flags, ENTRY_SPECIAL)) {
+		/*
+		 * If this was a "SPECIAL" do not add it back into the heap.
+		 * It will always be "SPECIAL" and therefore never removed.
+		 */
+		debug(20, 4) ("storeAufsDirMaintain: locked url %s\n",
+		    (e->mem_obj && e->mem_obj->url) ? e->mem_obj->url : storeKeyText(e->
+			key));
+		linklistPush(&locked_entries, e);
+	    }
+	    locked++;
+	    continue;
+	} else if (storeAufsDirCheckExpired(SD, e)) {
+	    /*
+	     * Note: This will not check the reference age ifdef
+	     * HEAP_REPLACEMENT, but it does some other useful
+	     * checks...
+	     */
+	    expired++;
+	    debug(20, 3) ("Released store object age %f size %d refs %d key %s\n",
+		age, e->swap_file_sz, e->refcount, storeKeyText(e->key));
+	    min_age = age;
+	    storeRelease(e);
+	} else {
+	    /*
+	     * Did not expire the object so we need to add it back
+	     * into the heap!
+	     */
+	    debug(20, 5) ("storeMaintainSwapSpace: non-expired %s\n",
+		storeKeyText(e->key));
+	    linklistPush(&locked_entries, e);
+	    continue;
+	}
+	if (store_swap_size < store_swap_low)
+	    break;
+	else if (expired >= max_remove)
+	    break;
+	else if (scanned >= max_scan)
+	    break;
     }
     /*
      * Bump the heap age factor.
      */
     if (min_age > 0.0)
-        SD->repl.heap.heap->age = min_age;
+	SD->repl.heap.heap->age = min_age;
     /*
      * Reinsert all bumped locked entries back into heap...
      */
     while ((e = linklistShift(&locked_entries)))
-        e->repl.node = heap_insert(SD->repl.heap.heap, e);
+	e->repl.node = heap_insert(SD->repl.heap.heap, e);
 #else
     for (m = SD->repl.lru.list.tail; m; m = prev) {
-        prev = m->prev;
-        e = m->data;
-        scanned++;
-        if (storeEntryLocked(e)) {
-            /*
-             * If there is a locked entry at the tail of the LRU list,
-             * move it to the beginning to get it out of the way.
-             * Theoretically, we might have all locked objects at the
-             * tail, and then we'll never remove anything here and the
-             * LRU age will go to zero.
-             */
-            if (memInUse(MEM_STOREENTRY) > max_scan) {
-                dlinkDelete(&e->repl.lru, &SD->repl.lru.list);
-                dlinkAdd(e, &e->repl.lru, &SD->repl.lru.list);
-            }
-            locked++;
-
-        } else if (storeAufsDirCheckExpired(SD, e)) {
-            expired++;
-            storeRelease(e);
-        }
-        if (expired >= max_remove)
-            break;
-        if (scanned >= max_scan)
-            break;
+	prev = m->prev;
+	e = m->data;
+	scanned++;
+	if (storeEntryLocked(e)) {
+	    /*
+	     * If there is a locked entry at the tail of the LRU list,
+	     * move it to the beginning to get it out of the way.
+	     * Theoretically, we might have all locked objects at the
+	     * tail, and then we'll never remove anything here and the
+	     * LRU age will go to zero.
+	     */
+	    if (memInUse(MEM_STOREENTRY) > max_scan) {
+		dlinkDelete(&e->repl.lru, &SD->repl.lru.list);
+		dlinkAdd(e, &e->repl.lru, &SD->repl.lru.list);
+	    }
+	    locked++;
+
+	} else if (storeAufsDirCheckExpired(SD, e)) {
+	    expired++;
+	    storeRelease(e);
+	}
+	if (expired >= max_remove)
+	    break;
+	if (scanned >= max_scan)
+	    break;
     }
 #endif
-    debug(20, (expired ? 2 : 3)) ("storeMaintainSwapSpace: scanned %d/%d removed %d/%d l
-ocked %d f=%.03f\n",
-        scanned, max_scan, expired, max_remove, locked, f);
+    debug(20, (expired ? 2 : 3)) ("storeMaintainSwapSpace: scanned %d/%d removed %d/%d locked %d f=%.03f\n",
+	scanned, max_scan, expired, max_remove, locked, f);
     debug(20, 3) ("storeMaintainSwapSpace stats:\n");
     debug(20, 3) ("  %6d objects\n", memInUse(MEM_STOREENTRY));
     debug(20, 3) ("  %6d were scanned\n", scanned);
     debug(20, 3) ("  %6d were locked\n", locked);
     debug(20, 3) ("  %6d were expired\n", expired);
     if (store_swap_size < Config.Swap.maxSize)
-        return;
+	return;
     if (squid_curtime - last_warn_time < 10)
-        return;
+	return;
     debug(20, 0) ("WARNING: Disk space over limit: %d KB > %d KB\n",
-        store_swap_size, Config.Swap.maxSize);
+	store_swap_size, Config.Swap.maxSize);
     last_warn_time = squid_curtime;
 }
 
@@ -1416,7 +1415,7 @@ ocked %d f=%.03f\n",
  * happily store anything as long as the LRU time isn't too small.
  */
 int
-storeAufsDirCheckObj(SwapDir *SD, const StoreEntry *e)
+storeAufsDirCheckObj(SwapDir * SD, const StoreEntry * e)
 {
     int loadav;
     int ql;
@@ -1431,11 +1430,11 @@ storeAufsDirCheckObj(SwapDir *SD, const StoreEntry *e)
 #endif
     ql = aioQueueSize();
     if (ql == 0)
-        loadav = 0;
-    else if (ql >= MAGIC1) /* Queue is too long, don't even consider it */
-        loadav = -1;
+	loadav = 0;
+    else if (ql >= MAGIC1)	/* Queue is too long, don't even consider it */
+	loadav = -1;
     else
-        loadav = MAGIC1 * 1000 / ql;
+	loadav = MAGIC1 * 1000 / ql;
     return loadav;
 }
 
@@ -1446,18 +1445,18 @@ storeAufsDirCheckObj(SwapDir *SD, const StoreEntry *e)
  * maintain replacement information within the storage fs.
  */
 void
-storeAufsDirRefObj(SwapDir *SD, StoreEntry *e)
+storeAufsDirRefObj(SwapDir * SD, StoreEntry * e)
 {
     debug(1, 3) ("storeAufsDirRefObj: referencing %d/%d\n", e->swap_dirn,
-      e->swap_filen);
+	e->swap_filen);
 #if HEAP_REPLACEMENT
     /* Nothing to do here */
 #else
     /* Reference the object */
     if (!EBIT_TEST(e->flags, RELEASE_REQUEST) &&
-        !EBIT_TEST(e->flags, ENTRY_SPECIAL)) {
-        dlinkDelete(&e->repl.lru, &SD->repl.lru.list);
-        dlinkAdd(e, &e->repl.lru, &SD->repl.lru.list);
+	!EBIT_TEST(e->flags, ENTRY_SPECIAL)) {
+	dlinkDelete(&e->repl.lru, &SD->repl.lru.list);
+	dlinkAdd(e, &e->repl.lru, &SD->repl.lru.list);
     }
 #endif
 }
@@ -1468,10 +1467,10 @@ storeAufsDirRefObj(SwapDir *SD, StoreEntry *e)
  * removed, to maintain replacement information within the storage fs.
  */
 void
-storeAufsDirUnrefObj(SwapDir *SD, StoreEntry *e)
+storeAufsDirUnrefObj(SwapDir * SD, StoreEntry * e)
 {
     debug(1, 3) ("storeAufsDirUnrefObj: referencing %d/%d\n", e->swap_dirn,
-      e->swap_filen);
+	e->swap_filen);
 #if HEAP_REPLACEMENT
     if (e->repl.node)
 	heap_update(SD->repl.heap.heap, e->repl.node, e);
@@ -1486,7 +1485,7 @@ storeAufsDirUnrefObj(SwapDir *SD, StoreEntry *e)
  * forced this bit of code here. Eeek.
  */
 void
-storeAufsDirUnlinkFile(SwapDir *SD, sfileno f)
+storeAufsDirUnlinkFile(SwapDir * SD, sfileno f)
 {
     debug(79, 3) ("storeAufsDirUnlinkFile: unlinking fileno %08X\n", f);
     storeAufsDirMapBitReset(SD, f);
@@ -1506,13 +1505,13 @@ storeAufsDirUnlinkFile(SwapDir *SD, sfileno f)
  * cachemgr 'info' page.
  */
 static time_t
-storeAufsDirExpiredReferenceAge(SwapDir *SD)
+storeAufsDirExpiredReferenceAge(SwapDir * SD)
 {
     double x;
     double z;
     time_t age;
     long store_high, store_low;
-    
+
     store_high = (long) (((float) SD->max_size *
 	    (float) Config.Swap.highWaterMark) / (float) 100);
     store_low = (long) (((float) SD->max_size *
@@ -1541,7 +1540,7 @@ storeAufsDirExpiredReferenceAge(SwapDir *SD)
  * right now.
  */
 static int
-storeAufsDirCheckExpired(SwapDir *SD, StoreEntry *e)
+storeAufsDirCheckExpired(SwapDir * SD, StoreEntry * e)
 {
     if (storeEntryLocked(e))
 	return 0;
@@ -1569,16 +1568,16 @@ storeAufsDirCheckExpired(SwapDir *SD, StoreEntry *e)
  */
 
 void
-storeAufsDirReplAdd(SwapDir *SD, StoreEntry *e)
+storeAufsDirReplAdd(SwapDir * SD, StoreEntry * e)
 {
     debug(20, 4) ("storeUfsDirReplAdd: added node %p to dir %d\n", e,
-      SD->index);
+	SD->index);
 #if HEAP_REPLACEMENT
     if (EBIT_TEST(e->flags, ENTRY_SPECIAL)) {
-        (void) 0;
+	(void) 0;
     } else {
-        e->repl.node = heap_insert(SD->repl.heap.heap, e);
-        debug(20, 4) ("storeUfsDirReplAdd: inserted node 0x%x\n", e->repl.node);
+	e->repl.node = heap_insert(SD->repl.heap.heap, e);
+	debug(20, 4) ("storeUfsDirReplAdd: inserted node 0x%x\n", e->repl.node);
     }
 #else
     /* Shouldn't we not throw special objects into the lru ? */
@@ -1588,18 +1587,18 @@ storeAufsDirReplAdd(SwapDir *SD, StoreEntry *e)
 
 
 void
-storeAufsDirReplRemove(StoreEntry *e)
+storeAufsDirReplRemove(StoreEntry * e)
 {
     SwapDir *SD = INDEXSD(e->swap_dirn);
     debug(20, 4) ("storeUfsDirReplRemove: remove node %p from dir %d\n", e,
-      SD->index);
+	SD->index);
 #if HEAP_REPLACEMENT
     /* And now, release the object from the replacement policy */
     if (e->repl.node) {
-        debug(20, 4) ("storeUfsDirReplRemove: deleting node 0x%x\n",
-          e->repl.node);
-        heap_delete(SD->repl.heap.heap, e->repl.node);
-        e->repl.node = NULL;
+	debug(20, 4) ("storeUfsDirReplRemove: deleting node 0x%x\n",
+	    e->repl.node);
+	heap_delete(SD->repl.heap.heap, e->repl.node);
+	e->repl.node = NULL;
     }
 #else
     dlinkDelete(&e->repl.lru, &SD->repl.lru.list);
@@ -1610,41 +1609,41 @@ storeAufsDirReplRemove(StoreEntry *e)
 /* ========== LOCAL FUNCTIONS ABOVE, GLOBAL FUNCTIONS BELOW ========== */
 
 void
-storeAufsDirStats(SwapDir *SD, StoreEntry * sentry)
+storeAufsDirStats(SwapDir * SD, StoreEntry * sentry)
 {
     aioinfo_t *aioinfo;
 #if HAVE_STATVFS
     struct statvfs sfs;
 #endif
-    aioinfo = (aioinfo_t *)SD->fsdata;
+    aioinfo = (aioinfo_t *) SD->fsdata;
     storeAppendPrintf(sentry, "First level subdirectories: %d\n", aioinfo->l1);
     storeAppendPrintf(sentry, "Second level subdirectories: %d\n", aioinfo->l2);
     storeAppendPrintf(sentry, "Maximum Size: %d KB\n", SD->max_size);
     storeAppendPrintf(sentry, "Current Size: %d KB\n", SD->cur_size);
     storeAppendPrintf(sentry, "Percent Used: %0.2f%%\n",
-        100.0 * SD->cur_size / SD->max_size);
+	100.0 * SD->cur_size / SD->max_size);
     storeAppendPrintf(sentry, "Filemap bits in use: %d of %d (%d%%)\n",
-    aioinfo->map->n_files_in_map, aioinfo->map->max_n_files,
-    percent(aioinfo->map->n_files_in_map, aioinfo->map->max_n_files));
+	aioinfo->map->n_files_in_map, aioinfo->map->max_n_files,
+	percent(aioinfo->map->n_files_in_map, aioinfo->map->max_n_files));
 #if HAVE_STATVFS
 #define fsbtoblk(num, fsbs, bs) \
     (((fsbs) != 0 && (fsbs) < (bs)) ? \
             (num) / ((bs) / (fsbs)) : (num) * ((fsbs) / (bs)))
-	if (!statvfs(SD->path, &sfs)) {
-            storeAppendPrintf(sentry, "Filesystem Space in use: %d/%d KB (%d%%)\n",
-            fsbtoblk((sfs.f_blocks - sfs.f_bfree), sfs.f_frsize, 1024),
-            fsbtoblk(sfs.f_blocks, sfs.f_frsize, 1024),
-            percent(sfs.f_blocks - sfs.f_bfree, sfs.f_blocks));
-            storeAppendPrintf(sentry, "Filesystem Inodes in use: %d/%d (%d%%)\n",
-            sfs.f_files - sfs.f_ffree, sfs.f_files,
-            percent(sfs.f_files - sfs.f_ffree, sfs.f_files));
+    if (!statvfs(SD->path, &sfs)) {
+	storeAppendPrintf(sentry, "Filesystem Space in use: %d/%d KB (%d%%)\n",
+	    fsbtoblk((sfs.f_blocks - sfs.f_bfree), sfs.f_frsize, 1024),
+	    fsbtoblk(sfs.f_blocks, sfs.f_frsize, 1024),
+	    percent(sfs.f_blocks - sfs.f_bfree, sfs.f_blocks));
+	storeAppendPrintf(sentry, "Filesystem Inodes in use: %d/%d (%d%%)\n",
+	    sfs.f_files - sfs.f_ffree, sfs.f_files,
+	    percent(sfs.f_files - sfs.f_ffree, sfs.f_files));
     }
 #endif
     storeAppendPrintf(sentry, "Flags:");
     if (SD->flags.selected)
-        storeAppendPrintf(sentry, " SELECTED");
+	storeAppendPrintf(sentry, " SELECTED");
     if (SD->flags.read_only)
-        storeAppendPrintf(sentry, " READ-ONLY");
+	storeAppendPrintf(sentry, " READ-ONLY");
     storeAppendPrintf(sentry, "\n");
 #if !HEAP_REPLACEMENT
     storeAppendPrintf(sentry, "LRU Expiration Age: %6.2f days\n",
@@ -1663,7 +1662,7 @@ storeAufsDirStats(SwapDir *SD, StoreEntry * sentry)
  * This routine is called when the given swapdir needs reconfiguring 
  */
 void
-storeAufsDirReconfigure(SwapDir *sd, int index, char *path)
+storeAufsDirReconfigure(SwapDir * sd, int index, char *path)
 {
     char *token;
     int i;
@@ -1706,10 +1705,10 @@ storeAufsDirReconfigure(SwapDir *sd, int index, char *path)
 void
 storeAufsDirDump(StoreEntry * entry, const char *name, SwapDir * s)
 {
-    aioinfo_t *aioinfo = (aioinfo_t *)s->fsdata;
+    aioinfo_t *aioinfo = (aioinfo_t *) s->fsdata;
     storeAppendPrintf(entry, "%s %s %s %d %d %d\n",
 	name,
-        "asyncufs",
+	"asyncufs",
 	s->path,
 	s->max_size >> 10,
 	aioinfo->l1,
@@ -1722,22 +1721,22 @@ storeAufsDirDump(StoreEntry * entry, const char *name, SwapDir * s)
 static void
 storeAufsDirFree(SwapDir * s)
 {
-    aioinfo_t *aioinfo = (aioinfo_t *)s->fsdata;
+    aioinfo_t *aioinfo = (aioinfo_t *) s->fsdata;
     if (aioinfo->swaplog_fd > -1) {
 	file_close(aioinfo->swaplog_fd);
 	aioinfo->swaplog_fd = -1;
     }
     filemapFreeMemory(aioinfo->map);
     xfree(aioinfo);
-    s->fsdata = NULL; /* Will aid debugging... */
+    s->fsdata = NULL;		/* Will aid debugging... */
 
 }
 
 char *
-storeAufsDirFullPath(SwapDir *SD, sfileno filn, char *fullpath)
+storeAufsDirFullPath(SwapDir * SD, sfileno filn, char *fullpath)
 {
     LOCAL_ARRAY(char, fullfilename, SQUID_MAXPATHLEN);
-    aioinfo_t *aioinfo = (aioinfo_t *)SD->fsdata;
+    aioinfo_t *aioinfo = (aioinfo_t *) SD->fsdata;
     int L1 = aioinfo->l1;
     int L2 = aioinfo->l2;
     if (!fullpath)
@@ -1757,28 +1756,28 @@ storeAufsDirFullPath(SwapDir *SD, sfileno filn, char *fullpath)
  * This is called by storeCleanup() if -S was given on the command line.
  */
 static int
-storeAufsCleanupDoubleCheck(SwapDir *sd, StoreEntry *e)
+storeAufsCleanupDoubleCheck(SwapDir * sd, StoreEntry * e)
 {
     struct stat sb;
 
     if (stat(storeAufsDirFullPath(sd, e->swap_filen, NULL), &sb) < 0) {
-        debug(20, 0) ("storeAufsCleanupDoubleCheck: MISSING SWAP FILE\n");
-        debug(20, 0) ("storeAufsCleanupDoubleCheck: FILENO %08X\n", e->swap_filen);
-        debug(20, 0) ("storeAufsCleanupDoubleCheck: PATH %s\n",
-            storeAufsDirFullPath(sd, e->swap_filen, NULL));
-        storeEntryDump(e, 0);
-        return -1;
-    }       
+	debug(20, 0) ("storeAufsCleanupDoubleCheck: MISSING SWAP FILE\n");
+	debug(20, 0) ("storeAufsCleanupDoubleCheck: FILENO %08X\n", e->swap_filen);
+	debug(20, 0) ("storeAufsCleanupDoubleCheck: PATH %s\n",
+	    storeAufsDirFullPath(sd, e->swap_filen, NULL));
+	storeEntryDump(e, 0);
+	return -1;
+    }
     if (e->swap_file_sz != sb.st_size) {
-        debug(20, 0) ("storeAufsCleanupDoubleCheck: SIZE MISMATCH\n");
-        debug(20, 0) ("storeAufsCleanupDoubleCheck: FILENO %08X\n", e->swap_filen);
-        debug(20, 0) ("storeAufsCleanupDoubleCheck: PATH %s\n",
-            storeAufsDirFullPath(sd, e->swap_filen, NULL));
-        debug(20, 0) ("storeAufsCleanupDoubleCheck: ENTRY SIZE: %d, FILE SIZE: %d\n",
-            e->swap_file_sz, (int) sb.st_size); 
-        storeEntryDump(e, 0); 
-        return -1;
-    }       
+	debug(20, 0) ("storeAufsCleanupDoubleCheck: SIZE MISMATCH\n");
+	debug(20, 0) ("storeAufsCleanupDoubleCheck: FILENO %08X\n", e->swap_filen);
+	debug(20, 0) ("storeAufsCleanupDoubleCheck: PATH %s\n",
+	    storeAufsDirFullPath(sd, e->swap_filen, NULL));
+	debug(20, 0) ("storeAufsCleanupDoubleCheck: ENTRY SIZE: %d, FILE SIZE: %d\n",
+	    e->swap_file_sz, (int) sb.st_size);
+	storeEntryDump(e, 0);
+	return -1;
+    }
     return 0;
 }
 
@@ -1788,7 +1787,7 @@ storeAufsCleanupDoubleCheck(SwapDir *sd, StoreEntry *e)
  * Called when a *new* fs is being setup.
  */
 void
-storeAufsDirParse(SwapDir *sd, int index, char *path)
+storeAufsDirParse(SwapDir * sd, int index, char *path)
 {
     char *token;
     int i;
@@ -1816,7 +1815,7 @@ storeAufsDirParse(SwapDir *sd, int index, char *path)
 
     aioinfo = xmalloc(sizeof(aioinfo_t));
     if (aioinfo == NULL)
-        fatal("storeAufsDirParse: couldn't xmalloc() aioinfo_t!\n");
+	fatal("storeAufsDirParse: couldn't xmalloc() aioinfo_t!\n");
 
     sd->index = index;
     sd->path = xstrdup(path);
@@ -1825,7 +1824,7 @@ storeAufsDirParse(SwapDir *sd, int index, char *path)
     aioinfo->l1 = l1;
     aioinfo->l2 = l2;
     aioinfo->swaplog_fd = -1;
-    aioinfo->map = NULL; /* Debugging purposes */
+    aioinfo->map = NULL;	/* Debugging purposes */
     aioinfo->suggest = 0;
     sd->flags.read_only = read_only;
     sd->init = storeAufsDirInit;
@@ -1861,24 +1860,24 @@ storeAufsDirParse(SwapDir *sd, int index, char *path)
      * always uses GDSF since we want to maximize object hit rate.
      */
     if (Config.replPolicy) {
-        if (tolower(Config.replPolicy[0]) == 'g') {
-            debug(20, 1) ("Using GDSF disk replacement policy\n");
-            sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_GDSF);
-        } else if (tolower(Config.replPolicy[0]) == 'l') {
-            if (tolower(Config.replPolicy[1]) == 'f') {
-                debug(20, 1) ("Using LFUDA disk replacement policy\n");
-                sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_LFUDA);
-            } else if (tolower(Config.replPolicy[1]) == 'r') {
-                debug(20, 1) ("Using LRU heap disk replacement policy\n");
-                sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_LRU);
-            }
-        } else {
-            debug(20, 1) ("Unrecognized replacement_policy; using GDSF\n");
-            sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_GDSF);
-        }
+	if (tolower(Config.replPolicy[0]) == 'g') {
+	    debug(20, 1) ("Using GDSF disk replacement policy\n");
+	    sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_GDSF);
+	} else if (tolower(Config.replPolicy[0]) == 'l') {
+	    if (tolower(Config.replPolicy[1]) == 'f') {
+		debug(20, 1) ("Using LFUDA disk replacement policy\n");
+		sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_LFUDA);
+	    } else if (tolower(Config.replPolicy[1]) == 'r') {
+		debug(20, 1) ("Using LRU heap disk replacement policy\n");
+		sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_LRU);
+	    }
+	} else {
+	    debug(20, 1) ("Unrecognized replacement_policy; using GDSF\n");
+	    sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_GDSF);
+	}
     } else {
-        debug(20, 1) ("Using default disk replacement policy (GDSF)\n");
-        sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_GDSF);
+	debug(20, 1) ("Using default disk replacement policy (GDSF)\n");
+	sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_GDSF);
     }
 #else
     sd->repl.lru.list.head = NULL;
@@ -1887,7 +1886,7 @@ storeAufsDirParse(SwapDir *sd, int index, char *path)
 }
 
 void
-storeFsSetup_aufs(storefs_entry_t *storefs)
+storeFsSetup_aufs(storefs_entry_t * storefs)
 {
     storefs->parsefunc = storeAufsDirParse;
     storefs->reconfigurefunc = storeAufsDirReconfigure;
@@ -33,8 +33,8 @@ struct _queued_read {
 
 /* open for reading */
 storeIOState *
-storeAufsOpen(SwapDir *SD, StoreEntry *e, STFNCB * file_callback,
-  STIOCB * callback, void *callback_data)
+storeAufsOpen(SwapDir * SD, StoreEntry * e, STFNCB * file_callback,
+    STIOCB * callback, void *callback_data)
 {
     sfileno f = e->swap_filen;
     char *path = storeAufsDirFullPath(SD, f, NULL);
@@ -49,8 +49,8 @@ storeAufsOpen(SwapDir *SD, StoreEntry *e, STFNCB * file_callback,
     sio = memAllocate(MEM_STORE_IO);
     cbdataAdd(sio, storeAufsIOFreeEntry, MEM_STORE_IO);
     sio->fsstate = memPoolAlloc(aio_state_pool);
-    ((aiostate_t *)(sio->fsstate))->fd = -1;
-    ((aiostate_t *)(sio->fsstate))->flags.opening = 1;
+    ((aiostate_t *) (sio->fsstate))->fd = -1;
+    ((aiostate_t *) (sio->fsstate))->flags.opening = 1;
     sio->swap_filen = f;
     sio->swap_dirn = SD->index;
     sio->mode = O_RDONLY;
@@ -66,9 +66,9 @@ storeAufsOpen(SwapDir *SD, StoreEntry *e, STFNCB * file_callback,
 
 /* open for creating */
 storeIOState *
-storeAufsCreate(SwapDir *SD, StoreEntry *e, STFNCB *file_callback, STIOCB *callback, void *callback_data)
+storeAufsCreate(SwapDir * SD, StoreEntry * e, STFNCB * file_callback, STIOCB * callback, void *callback_data)
 {
-    char *path ;
+    char *path;
     storeIOState *sio;
     sfileno filn;
     sdirno dirn;
@@ -88,8 +88,8 @@ storeAufsCreate(SwapDir *SD, StoreEntry *e, STFNCB *file_callback, STIOCB *callb
     sio = memAllocate(MEM_STORE_IO);
     cbdataAdd(sio, storeAufsIOFreeEntry, MEM_STORE_IO);
     sio->fsstate = memPoolAlloc(aio_state_pool);
-    ((aiostate_t *)(sio->fsstate))->fd = -1;
-    ((aiostate_t *)(sio->fsstate))->flags.opening = 1;
+    ((aiostate_t *) (sio->fsstate))->fd = -1;
+    ((aiostate_t *) (sio->fsstate))->flags.opening = 1;
     sio->swap_filen = filn;
     sio->swap_dirn = dirn;
     sio->mode = O_WRONLY;
@@ -111,9 +111,9 @@ storeAufsCreate(SwapDir *SD, StoreEntry *e, STFNCB *file_callback, STIOCB *callb
 
 /* Close */
 void
-storeAufsClose(SwapDir *SD, storeIOState * sio)
+storeAufsClose(SwapDir * SD, storeIOState * sio)
 {
-    aiostate_t *aiostate = (aiostate_t *)sio->fsstate;
+    aiostate_t *aiostate = (aiostate_t *) sio->fsstate;
     debug(78, 3) ("storeAufsClose: dirno %d, fileno %08X, FD %d\n",
 	sio->swap_dirn, sio->swap_filen, aiostate->fd);
     if (storeAufsSomethingPending(sio)) {
@@ -126,9 +126,9 @@ storeAufsClose(SwapDir *SD, storeIOState * sio)
 
 /* Read */
 void
-storeAufsRead(SwapDir *SD, storeIOState * sio, char *buf, size_t size, off_t offset, STRCB * callback, void *callback_data)
+storeAufsRead(SwapDir * SD, storeIOState * sio, char *buf, size_t size, off_t offset, STRCB * callback, void *callback_data)
 {
-    aiostate_t *aiostate = (aiostate_t *)sio->fsstate;
+    aiostate_t *aiostate = (aiostate_t *) sio->fsstate;
     assert(sio->read.callback == NULL);
     assert(sio->read.callback_data == NULL);
     assert(!aiostate->flags.reading);
@@ -160,9 +160,9 @@ storeAufsRead(SwapDir *SD, storeIOState * sio, char *buf, size_t size, off_t off
 
 /* Write */
 void
-storeAufsWrite(SwapDir *SD, storeIOState * sio, char *buf, size_t size, off_t offset, FREE * free_func)
+storeAufsWrite(SwapDir * SD, storeIOState * sio, char *buf, size_t size, off_t offset, FREE * free_func)
 {
-    aiostate_t *aiostate = (aiostate_t *)sio->fsstate;
+    aiostate_t *aiostate = (aiostate_t *) sio->fsstate;
     debug(78, 3) ("storeAufsWrite: dirno %d, fileno %08X, FD %d\n",
 	sio->swap_dirn, sio->swap_filen, aiostate->fd);
     if (aiostate->fd < 0) {
@@ -200,7 +200,7 @@ storeAufsWrite(SwapDir *SD, storeIOState * sio, char *buf, size_t size, off_t of
 
 /* Unlink */
 void
-storeAufsUnlink(SwapDir *SD, StoreEntry *e)
+storeAufsUnlink(SwapDir * SD, StoreEntry * e)
 {
     debug(78, 3) ("storeAufsUnlink: dirno %d, fileno %08X\n", SD->index, e->swap_filen);
     storeAufsDirReplRemove(e);
@@ -212,7 +212,7 @@ storeAufsUnlink(SwapDir *SD, StoreEntry *e)
 static int
 storeAufsKickWriteQueue(storeIOState * sio)
 {
-    aiostate_t *aiostate = (aiostate_t *)sio->fsstate;
+    aiostate_t *aiostate = (aiostate_t *) sio->fsstate;
     struct _queued_write *q = linklistShift(&aiostate->pending_writes);
     if (NULL == q)
 	return 0;
@@ -226,7 +226,7 @@ storeAufsKickWriteQueue(storeIOState * sio)
 static int
 storeAufsKickReadQueue(storeIOState * sio)
 {
-    aiostate_t *aiostate = (aiostate_t *)sio->fsstate;
+    aiostate_t *aiostate = (aiostate_t *) sio->fsstate;
     struct _queued_read *q = linklistShift(&(aiostate->pending_reads));
     if (NULL == q)
 	return 0;
@@ -241,7 +241,7 @@ static void
 storeAufsOpenDone(int unused, void *my_data, int fd, int errflag)
 {
     storeIOState *sio = my_data;
-    aiostate_t *aiostate = (aiostate_t *)sio->fsstate;
+    aiostate_t *aiostate = (aiostate_t *) sio->fsstate;
     debug(78, 3) ("storeAufsOpenDone: FD %d, errflag %d\n", fd, errflag);
     Opening_FD--;
     aiostate->flags.opening = 0;
@@ -266,7 +266,7 @@ static void
 storeAufsReadDone(int fd, void *my_data, int len, int errflag)
 {
     storeIOState *sio = my_data;
-    aiostate_t *aiostate = (aiostate_t *)sio->fsstate;
+    aiostate_t *aiostate = (aiostate_t *) sio->fsstate;
     STRCB *callback = sio->read.callback;
     void *their_data = sio->read.callback_data;
     ssize_t rlen;
@@ -293,7 +293,7 @@ storeAufsReadDone(int fd, void *my_data, int len, int errflag)
      * says it fixes his FD leaks, with no side effects.
      */
     if (aiostate->flags.close_request)
-        storeAufsIOCallback(sio, DISK_OK);
+	storeAufsIOCallback(sio, DISK_OK);
 }
 
 /*
@@ -307,7 +307,7 @@ storeAufsWriteDone(int fd, void *my_data, int len, int errflag)
 {
     static int loop_detect = 0;
     storeIOState *sio = my_data;
-    aiostate_t *aiostate = (aiostate_t *)sio->fsstate;
+    aiostate_t *aiostate = (aiostate_t *) sio->fsstate;
     debug(78, 3) ("storeAufsWriteDone: dirno %d, fileno %08X, FD %d, len %d\n",
 	sio->swap_dirn, sio->swap_filen, fd, len);
     assert(++loop_detect < 10);
@@ -331,7 +331,7 @@ storeAufsIOCallback(storeIOState * sio, int errflag)
 {
     STIOCB *callback = sio->callback;
     void *their_data = sio->callback_data;
-    aiostate_t *aiostate = (aiostate_t *)sio->fsstate;
+    aiostate_t *aiostate = (aiostate_t *) sio->fsstate;
     int fd = aiostate->fd;
     debug(78, 3) ("storeAufsIOCallback: errflag=%d\n", errflag);
     sio->callback = NULL;
@@ -357,7 +357,7 @@ storeAufsIOCallback(storeIOState * sio, int errflag)
 static int
 storeAufsSomethingPending(storeIOState * sio)
 {
-    aiostate_t *aiostate = (aiostate_t *)sio->fsstate;
+    aiostate_t *aiostate = (aiostate_t *) sio->fsstate;
     if (aiostate->flags.reading)
 	return 1;
     if (aiostate->flags.writing)
@@ -371,11 +371,10 @@ storeAufsSomethingPending(storeIOState * sio)
 /*      
  * We can't pass memFree() as a free function here, because we need to free
  * the fsstate variable ..
- */ 
+ */
 static void
 storeAufsIOFreeEntry(void *sio, int foo)
 {
-        memPoolFree(aio_state_pool, ((storeIOState *)sio)->fsstate);
-        memFree(sio, MEM_STORE_IO);
+    memPoolFree(aio_state_pool, ((storeIOState *) sio)->fsstate);
+    memFree(sio, MEM_STORE_IO);
 }
-
@@ -16,8 +16,8 @@ struct _cossmembuf {
     int lockcount;
     char buffer[COSS_MEMBUF_SZ];
     struct _cossmembuf_flags {
-        unsigned int full:1;
-        unsigned int writing:1;
+	unsigned int full:1;
+	unsigned int writing:1;
     } flags;
     struct _cossmembuf *next;
 };
@@ -42,8 +42,8 @@ struct _cossstate {
     size_t requestoffset;
     sfileno reqdiskoffset;
     struct {
-        unsigned int reading:1;
-        unsigned int writing:1;
+	unsigned int reading:1;
+	unsigned int writing:1;
     } flags;
 };
 
@@ -53,8 +53,8 @@ typedef struct _cossstate CossState;
 
 /* Whether the coss system has been setup or not */
 extern int coss_initialised;
-extern MemPool * coss_membuf_pool;
-extern MemPool * coss_state_pool;
+extern MemPool *coss_membuf_pool;
+extern MemPool *coss_state_pool;
 
 
 /*
@@ -67,11 +67,11 @@ extern STOBJREAD storeCossRead;
 extern STOBJWRITE storeCossWrite;
 extern STOBJUNLINK storeCossUnlink;
 
-extern off_t storeCossAllocate(SwapDir *SD, const StoreEntry *e, int which);
-extern void storeCossFree(StoreEntry *e);
-extern void storeCossMaintainSwapSpace(SwapDir *SD);
+extern off_t storeCossAllocate(SwapDir * SD, const StoreEntry * e, int which);
+extern void storeCossFree(StoreEntry * e);
+extern void storeCossMaintainSwapSpace(SwapDir * SD);
 extern void storeCossDirStats(SwapDir *, StoreEntry *);
-extern void storeCossDirDump(StoreEntry * entry, const char *name, SwapDir* s);
+extern void storeCossDirDump(StoreEntry * entry, const char *name, SwapDir * s);
 extern void storeCossDirFree(SwapDir *);
 extern SwapDir *storeCossDirPick(void);
 
@@ -1,6 +1,6 @@
- 
+
 /*
- * $Id: store_dir_coss.cc,v 1.1 2000/05/03 17:15:47 adrian Exp $
+ * $Id: store_dir_coss.cc,v 1.2 2000/05/12 00:29:19 wessels Exp $
  *
  * DEBUG: section 81    Store COSS Directory Routines
  * AUTHOR: Eric Stern
@@ -39,13 +39,13 @@
 
 #define STORE_META_BUFSZ 4096
 
-extern void storeCossFlushMemBufs(SwapDir *SD);
+extern void storeCossFlushMemBufs(SwapDir * SD);
 
 int n_coss_dirs = 0;
 /* static int last_coss_pick_index = -1; */
 int coss_initialised = 0;
-MemPool * coss_membuf_pool = NULL;
-MemPool * coss_state_pool = NULL;
+MemPool *coss_membuf_pool = NULL;
+MemPool *coss_state_pool = NULL;
 
 typedef struct _RebuildState RebuildState;
 struct _RebuildState {
@@ -72,7 +72,7 @@ struct _RebuildState {
 
 static char *storeCossDirSwapLogFile(SwapDir *, const char *);
 static EVH storeCossRebuildFromSwapLog;
-static StoreEntry *storeCossAddDiskRestore(SwapDir *SD,const cache_key *key,
+static StoreEntry *storeCossAddDiskRestore(SwapDir * SD, const cache_key * key,
     int file_number,
     size_t swap_file_sz,
     time_t expires,
@@ -106,31 +106,31 @@ storeCossDirSwapLogFile(SwapDir * sd, const char *ext)
     LOCAL_ARRAY(char, digit, 32);
     char *pathtmp2;
     if (Config.Log.swap) {
-        xstrncpy(pathtmp, sd->path, SQUID_MAXPATHLEN - 64);
-        while (index(pathtmp,'/'))
-            *index(pathtmp,'/')='.';
-        while (strlen(pathtmp) && pathtmp[strlen(pathtmp)-1]=='.')
-            pathtmp[strlen(pathtmp)-1]= '\0';
-        for(pathtmp2 = pathtmp; *pathtmp2 == '.'; pathtmp2++);
-        snprintf(path, SQUID_MAXPATHLEN-64, Config.Log.swap, pathtmp2);
-        if (strncmp(path, Config.Log.swap, SQUID_MAXPATHLEN - 64) == 0) {
-            strcat(path, ".");
-            snprintf(digit, 32, "%02d", sd->index);
-            strncat(path, digit, 3);
-        }
+	xstrncpy(pathtmp, sd->path, SQUID_MAXPATHLEN - 64);
+	while (index(pathtmp, '/'))
+	    *index(pathtmp, '/') = '.';
+	while (strlen(pathtmp) && pathtmp[strlen(pathtmp) - 1] == '.')
+	    pathtmp[strlen(pathtmp) - 1] = '\0';
+	for (pathtmp2 = pathtmp; *pathtmp2 == '.'; pathtmp2++);
+	snprintf(path, SQUID_MAXPATHLEN - 64, Config.Log.swap, pathtmp2);
+	if (strncmp(path, Config.Log.swap, SQUID_MAXPATHLEN - 64) == 0) {
+	    strcat(path, ".");
+	    snprintf(digit, 32, "%02d", sd->index);
+	    strncat(path, digit, 3);
+	}
     } else {
-        xstrncpy(path, sd->path, SQUID_MAXPATHLEN - 64);
-        strcat(path, "/swap.state");
+	xstrncpy(path, sd->path, SQUID_MAXPATHLEN - 64);
+	strcat(path, "/swap.state");
     }
     if (ext)
-        strncat(path, ext, 16);
+	strncat(path, ext, 16);
     return path;
 }
 
 static void
 storeCossDirOpenSwapLog(SwapDir * sd)
 {
-    CossInfo *cs = (CossInfo *)sd->fsdata;
+    CossInfo *cs = (CossInfo *) sd->fsdata;
     char *path;
     int fd;
     path = storeCossDirSwapLogFile(sd, NULL);
@@ -146,7 +146,7 @@ storeCossDirOpenSwapLog(SwapDir * sd)
 static void
 storeCossDirCloseSwapLog(SwapDir * sd)
 {
-    CossInfo *cs = (CossInfo *)sd->fsdata;
+    CossInfo *cs = (CossInfo *) sd->fsdata;
     if (cs->swaplog_fd < 0)	/* not open */
 	return;
     file_close(cs->swaplog_fd);
@@ -158,7 +158,7 @@ storeCossDirCloseSwapLog(SwapDir * sd)
 static void
 storeCossDirInit(SwapDir * sd)
 {
-    CossInfo *cs = (CossInfo *)sd->fsdata;
+    CossInfo *cs = (CossInfo *) sd->fsdata;
     storeCossDirOpenSwapLog(sd);
     storeCossDirRebuild(sd);
     cs->fd = file_open(sd->path, O_RDWR | O_CREAT);
@@ -213,8 +213,8 @@ storeCossRebuildFromSwapLog(void *data)
 		if (e->swap_filen > -1) {
 		    e->swap_filen = -1;
 		}
-                storeRelease(e);
-                /* Fake an unlink here, this is a bad hack :( */
+		storeRelease(e);
+		/* Fake an unlink here, this is a bad hack :( */
 		dlinkDelete(&e->repl.lru, &rb->sd->repl.lru.list);
 		rb->counts.objcount--;
 		rb->counts.cancelcount++;
@@ -244,7 +244,7 @@ storeCossRebuildFromSwapLog(void *data)
 	}
 	/* update store_swap_size */
 	rb->counts.objcount++;
-	e = storeCossAddDiskRestore(rb->sd,s.key,
+	e = storeCossAddDiskRestore(rb->sd, s.key,
 	    s.swap_filen,
 	    s.swap_file_sz,
 	    s.expires,
@@ -262,7 +262,7 @@ storeCossRebuildFromSwapLog(void *data)
 /* Add a new object to the cache with empty memory copy and pointer to disk
  * use to rebuild store from disk. */
 static StoreEntry *
-storeCossAddDiskRestore(SwapDir *SD, const cache_key * key,
+storeCossAddDiskRestore(SwapDir * SD, const cache_key * key,
     int file_number,
     size_t swap_file_sz,
     time_t expires,
@@ -323,25 +323,25 @@ storeCossDirRebuild(SwapDir * sd)
     debug(20, 1) ("Rebuilding COSS storage in %s (%s)\n",
 	sd->path, clean ? "CLEAN" : "DIRTY");
     if (!clean || fp == NULL) {
-    	/* COSS cannot yet rebuild from a dirty state. If the log
+	/* COSS cannot yet rebuild from a dirty state. If the log
 	 * is dirty then the COSS contents is thrown away.
 	 * Why? I guess it is because some contents will be lost,
 	 * and COSS cannot verify this..
 	 */
 	if (fp != NULL)
 	    fclose(fp);
 	storeCossDirCloseTmpSwapLog(rb->sd);
-        /*
+	/*
 	 * XXX Make sure we don't trigger an assertion if this is the first
 	 * storedir, since if we are, this call will cause storeRebuildComplete
 	 * to prematurely complete the rebuild process, and then some other
 	 * storedir will try to rebuild and eventually die.
 	 */
-        store_dirs_rebuilding++;
-        storeRebuildComplete(&rb->counts);
-        store_dirs_rebuilding--;
+	store_dirs_rebuilding++;
+	storeRebuildComplete(&rb->counts);
+	store_dirs_rebuilding--;
 	xfree(rb);
-        return;
+	return;
     }
     func = storeCossRebuildFromSwapLog;
     rb->log = fp;
@@ -354,7 +354,7 @@ storeCossDirRebuild(SwapDir * sd)
 static void
 storeCossDirCloseTmpSwapLog(SwapDir * sd)
 {
-    CossInfo *cs = (CossInfo *)sd->fsdata;
+    CossInfo *cs = (CossInfo *) sd->fsdata;
     char *swaplog_path = xstrdup(storeCossDirSwapLogFile(sd, NULL));
     char *new_path = xstrdup(storeCossDirSwapLogFile(sd, ".new"));
     int fd;
@@ -382,7 +382,7 @@ storeCossDirCloseTmpSwapLog(SwapDir * sd)
 static FILE *
 storeCossDirOpenTmpSwapLog(SwapDir * sd, int *clean_flag, int *zero_flag)
 {
-    CossInfo *cs = (CossInfo *)sd->fsdata;
+    CossInfo *cs = (CossInfo *) sd->fsdata;
     char *swaplog_path = xstrdup(storeCossDirSwapLogFile(sd, NULL));
     char *clean_path = xstrdup(storeCossDirSwapLogFile(sd, ".last-clean"));
     char *new_path = xstrdup(storeCossDirSwapLogFile(sd, ".new"));
@@ -568,7 +568,7 @@ storeCossDirWriteCleanClose(SwapDir * sd)
 static void
 storeCossDirSwapLog(const SwapDir * sd, const StoreEntry * e, int op)
 {
-    CossInfo *cs = (CossInfo *)sd->fsdata;
+    CossInfo *cs = (CossInfo *) sd->fsdata;
     storeSwapLogData *s = xcalloc(1, sizeof(storeSwapLogData));
     s->op = (char) op;
     s->swap_filen = e->swap_filen;
@@ -595,17 +595,17 @@ storeCossDirNewfs(SwapDir * sd)
     debug(47, 3) ("Creating swap space in %s\n", sd->path);
 }
 
-// we are shutting down, flush all membufs to disk
+/* we are shutting down, flush all membufs to disk */
 static void
-storeCossDirShutdown(SwapDir *SD)
+storeCossDirShutdown(SwapDir * SD)
 {
-    CossInfo *cs = (CossInfo *)SD->fsdata;
+    CossInfo *cs = (CossInfo *) SD->fsdata;
     CossMemBuf *t;
 
-    // we need to do this synchronously!
+    /* we need to do this synchronously! */
     for (t = cs->membufs; t; t = t->next) {
-        lseek(cs->fd, t->diskstart, SEEK_SET);
-        write(cs->fd, t->buffer, COSS_MEMBUF_SZ);
+	lseek(cs->fd, t->diskstart, SEEK_SET);
+	write(cs->fd, t->buffer, COSS_MEMBUF_SZ);
     }
     file_close(cs->fd);
     cs->fd = -1;
@@ -614,7 +614,6 @@ storeCossDirShutdown(SwapDir *SD)
 	file_close(cs->swaplog_fd);
 	cs->swaplog_fd = -1;
     }
-
     n_coss_dirs--;
 }
 
@@ -627,46 +626,46 @@ storeCossDirShutdown(SwapDir *SD)
  * done by the upper layers.
  */
 int
-storeCossDirCheckObj(SwapDir *SD, const StoreEntry *e)
+storeCossDirCheckObj(SwapDir * SD, const StoreEntry * e)
 {
-  /* Check if the object is a special object, we can't cache these */
-  if (EBIT_TEST(e->flags, ENTRY_SPECIAL))
-      return -1;
+    /* Check if the object is a special object, we can't cache these */
+    if (EBIT_TEST(e->flags, ENTRY_SPECIAL))
+	return -1;
 
-  /* Otherwise, we're ok */
-  /* Return 900 (90%) load */
-  return 900;
+    /* Otherwise, we're ok */
+    /* Return 900 (90%) load */
+    return 900;
 }
-     
+
 /* ========== LOCAL FUNCTIONS ABOVE, GLOBAL FUNCTIONS BELOW ========== */
 
 void
-storeCossDirStats(SwapDir *SD, StoreEntry * sentry)
+storeCossDirStats(SwapDir * SD, StoreEntry * sentry)
 {
-    CossInfo *cs = (CossInfo *)SD->fsdata;
-    
+    CossInfo *cs = (CossInfo *) SD->fsdata;
+
     storeAppendPrintf(sentry, "\n");
     storeAppendPrintf(sentry, "Maximum Size: %d KB\n", SD->max_size);
     storeAppendPrintf(sentry, "Current Size: %d KB\n", SD->cur_size);
     storeAppendPrintf(sentry, "Percent Used: %0.2f%%\n",
-      100.0 * SD->cur_size / SD->max_size);
-    storeAppendPrintf(sentry, "Number of object collisions: %d\n", (int)cs->numcollisions);
+	100.0 * SD->cur_size / SD->max_size);
+    storeAppendPrintf(sentry, "Number of object collisions: %d\n", (int) cs->numcollisions);
 #if 0
     /* is this applicable? I Hope not .. */
     storeAppendPrintf(sentry, "Filemap bits in use: %d of %d (%d%%)\n",
-      SD->map->n_files_in_map, SD->map->max_n_files,
-      percent(SD->map->n_files_in_map, SD->map->max_n_files));
+	SD->map->n_files_in_map, SD->map->max_n_files,
+	percent(SD->map->n_files_in_map, SD->map->max_n_files));
 #endif
     storeAppendPrintf(sentry, "Flags:");
     if (SD->flags.selected)
-        storeAppendPrintf(sentry, " SELECTED");
+	storeAppendPrintf(sentry, " SELECTED");
     if (SD->flags.read_only)
-        storeAppendPrintf(sentry, " READ-ONLY");
+	storeAppendPrintf(sentry, " READ-ONLY");
     storeAppendPrintf(sentry, "\n");
 }
 
 static void
-storeCossDirParse(SwapDir *sd, int index, char *path)
+storeCossDirParse(SwapDir * sd, int index, char *path)
 {
     char *token;
     unsigned int i;
@@ -703,10 +702,10 @@ storeCossDirParse(SwapDir *sd, int index, char *path)
     sd->statfs = storeCossDirStats;
     sd->maintainfs = NULL;
     sd->checkobj = storeCossDirCheckObj;
-    sd->refobj = NULL;			/* LRU is done in storeCossRead */
+    sd->refobj = NULL;		/* LRU is done in storeCossRead */
     sd->unrefobj = NULL;
     sd->callback = NULL;
-    sd->sync = NULL; /* should we make it call the coss sync? */
+    sd->sync = NULL;		/* should we make it call the coss sync? */
 
     sd->obj.create = storeCossCreate;
     sd->obj.open = storeCossOpen;
@@ -741,7 +740,7 @@ storeCossDirParse(SwapDir *sd, int index, char *path)
 
 
 static void
-storeCossDirReconfigure(SwapDir *sd, int index, char *path)
+storeCossDirReconfigure(SwapDir * sd, int index, char *path)
 {
     char *token;
     unsigned int i;
@@ -757,15 +756,15 @@ storeCossDirReconfigure(SwapDir *sd, int index, char *path)
 	    read_only = 1;
 
     if (size == sd->max_size)
-        debug (3, 1) ("Cache COSS dir '%s' size remains unchanged at %d KB\n", path, size);
+	debug(3, 1) ("Cache COSS dir '%s' size remains unchanged at %d KB\n", path, size);
     else {
-        debug (3, 1) ("Cache COSS dir '%s' size changed to %d KB\n", path, size);
-        sd->max_size = size;
+	debug(3, 1) ("Cache COSS dir '%s' size changed to %d KB\n", path, size);
+	sd->max_size = size;
     }
 
     if (read_only != sd->flags.read_only) {
-        debug (3, 1) ("Cache COSS dir '%s' now %s\n", path, read_only ? "Read-Only" : "Read-Write");
-        sd->flags.read_only = read_only;
+	debug(3, 1) ("Cache COSS dir '%s' now %s\n", path, read_only ? "Read-Only" : "Read-Write");
+	sd->flags.read_only = read_only;
     }
 }
 
@@ -774,7 +773,7 @@ storeCossDirDump(StoreEntry * entry, const char *name, SwapDir * s)
 {
     storeAppendPrintf(entry, "%s %s %s %d\n",
 	name,
-        s->type,
+	s->type,
 	s->path,
 	s->max_size >> 20);
 }
@@ -783,40 +782,40 @@ storeCossDirDump(StoreEntry * entry, const char *name, SwapDir * s)
 SwapDir *
 storeCossDirPick(void)
 {
-    int i,choosenext = 0;
+    int i, choosenext = 0;
     SwapDir *SD;
-  
+
     if (n_coss_dirs == 0)
-        return NULL;
+	return NULL;
     for (i = 0; i < Config.cacheSwap.n_configured; i++) {
 	SD = &Config.cacheSwap.swapDirs[i];
-        if (SD->type == SWAPDIR_COSS) {
-            if ((last_coss_pick_index == -1) || (n_coss_dirs == 1)) {
-                last_coss_pick_index = i;
-                return SD;
-            } else if (choosenext) {
-                last_coss_pick_index = i;
-                return SD;
-            } else if (last_coss_pick_index == i) {
-                choosenext = 1;
-            }
-        }
+	if (SD->type == SWAPDIR_COSS) {
+	    if ((last_coss_pick_index == -1) || (n_coss_dirs == 1)) {
+		last_coss_pick_index = i;
+		return SD;
+	    } else if (choosenext) {
+		last_coss_pick_index = i;
+		return SD;
+	    } else if (last_coss_pick_index == i) {
+		choosenext = 1;
+	    }
+	}
     }
     for (i = 0; i < Config.cacheSwap.n_configured; i++) {
 	SD = &Config.cacheSwap.swapDirs[i];
-        if (SD->type == SWAPDIR_COSS) {
-            if ((last_coss_pick_index == -1) || (n_coss_dirs == 1)) {
-                last_coss_pick_index = i;
-                return SD;
-            } else if (choosenext) {
-                last_coss_pick_index = i;
-                return SD;
-            } else if (last_coss_pick_index == i) {
-                choosenext = 1;
-            }
-        }
+	if (SD->type == SWAPDIR_COSS) {
+	    if ((last_coss_pick_index == -1) || (n_coss_dirs == 1)) {
+		last_coss_pick_index = i;
+		return SD;
+	    } else if (choosenext) {
+		last_coss_pick_index = i;
+		return SD;
+	    } else if (last_coss_pick_index == i) {
+		choosenext = 1;
+	    }
+	}
     }
-    return NULL;               
+    return NULL;
 }
 #endif
 
@@ -832,7 +831,7 @@ storeCossDirDone(void)
 }
 
 void
-storeFsSetup_coss(storefs_entry_t *storefs)
+storeFsSetup_coss(storefs_entry_t * storefs)
 {
     assert(!coss_initialised);
 
@@ -843,4 +842,3 @@ storeFsSetup_coss(storefs_entry_t *storefs)
     coss_state_pool = memPoolCreate("COSS IO State data", sizeof(CossState));
     coss_initialised = 1;
 }
-
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_io_coss.cc,v 1.1 2000/05/03 17:15:47 adrian Exp $
+ * $Id: store_io_coss.cc,v 1.2 2000/05/12 00:29:19 wessels Exp $
  *
  * DEBUG: section 81    Storage Manager COSS Interface
  * AUTHOR: Eric Stern
@@ -39,13 +39,13 @@
 static DWCB storeCossWriteMemBufDone;
 static DRCB storeCossReadDone;
 static void storeCossIOCallback(storeIOState * sio, int errflag);
-static char *storeCossMemPointerFromDiskOffset(SwapDir *SD, size_t offset, CossMemBuf **mb);
-static void storeCossMemBufLock(SwapDir *SD, storeIOState *e);
-static void storeCossMemBufUnlock(SwapDir *SD, storeIOState *e);
-static void storeCossWriteMemBuf(SwapDir *SD,CossMemBuf *t);
+static char *storeCossMemPointerFromDiskOffset(SwapDir * SD, size_t offset, CossMemBuf ** mb);
+static void storeCossMemBufLock(SwapDir * SD, storeIOState * e);
+static void storeCossMemBufUnlock(SwapDir * SD, storeIOState * e);
+static void storeCossWriteMemBuf(SwapDir * SD, CossMemBuf * t);
 static void storeCossWriteMemBufDone(int fd, int errflag, size_t len, void *my_data);
-static CossMemBuf *storeCossCreateMemBuf(SwapDir *SD, size_t start,
-  sfileno curfn, int *collision);
+static CossMemBuf *storeCossCreateMemBuf(SwapDir * SD, size_t start,
+    sfileno curfn, int *collision);
 static void storeCossIOFreeEntry(void *, int);
 static void storeCossMembufFree(void *, int);
 
@@ -59,68 +59,71 @@ static void storeCossMembufFree(void *, int);
  * -- Adrian
  */
 off_t
-storeCossAllocate(SwapDir *SD, const StoreEntry *e, int which)
+storeCossAllocate(SwapDir * SD, const StoreEntry * e, int which)
 {
-    CossInfo *cs = (CossInfo *)SD->fsdata;
+    CossInfo *cs = (CossInfo *) SD->fsdata;
     CossMemBuf *newmb;
     off_t retofs;
     size_t allocsize;
     int coll = 0;
     sfileno checkf;
 
-     /* Make sure we chcek collisions if reallocating */
+    /* Make sure we chcek collisions if reallocating */
     if (which == COSS_ALLOC_REALLOC)
 	checkf = e->swap_filen;
     else
 	checkf = -1;
 
-    retofs = e->swap_filen; /* Just for defaults */
+    retofs = e->swap_filen;	/* Just for defaults */
 
     if (e->swap_file_sz > 0)
-        allocsize = e->swap_file_sz;
+	allocsize = e->swap_file_sz;
     else
-        allocsize = objectLen(e) + e->mem_obj->swap_hdr_sz;
+	allocsize = objectLen(e) + e->mem_obj->swap_hdr_sz;
 
     if (which != COSS_ALLOC_NOTIFY) {
-        if ((cs->current_offset + allocsize) > (SD->max_size << 10)) {
-            // tried to allocate past the end of the disk, so wrap
-            // back to the beginning
-            cs->current_membuf->flags.full = 1;
-            cs->current_membuf->diskend = cs->current_offset-1;
-	    cs->current_offset = 0; // wrap back to beginning
-            newmb = storeCossCreateMemBuf(SD, 0, checkf, &coll);
-            cs->current_membuf = newmb;
-        } else if ((cs->current_offset + allocsize) > cs->current_membuf->diskend) {
-            cs->current_membuf->flags.full = 1;
-            cs->current_membuf->diskend = cs->current_offset-1;
-            newmb = storeCossCreateMemBuf(SD, cs->current_offset,
-              checkf, &coll);
-            cs->current_membuf = newmb;
+	if ((cs->current_offset + allocsize) > (SD->max_size << 10)) {
+	    /*
+	     * tried to allocate past the end of the disk, so wrap
+	     * back to the beginning
+	     */
+	    cs->current_membuf->flags.full = 1;
+	    cs->current_membuf->diskend = cs->current_offset - 1;
+	    cs->current_offset = 0;	/* wrap back to beginning */
+
+	    newmb = storeCossCreateMemBuf(SD, 0, checkf, &coll);
+	    cs->current_membuf = newmb;
+	} else if ((cs->current_offset + allocsize) > cs->current_membuf->diskend) {
+	    cs->current_membuf->flags.full = 1;
+	    cs->current_membuf->diskend = cs->current_offset - 1;
+	    newmb = storeCossCreateMemBuf(SD, cs->current_offset,
+		checkf, &coll);
+	    cs->current_membuf = newmb;
+	}
+	if (coll == 0) {
+	    retofs = cs->current_offset;
+	} else {
+	    debug(81, 3) ("storeCossAllocate: Collision\n");
 	}
-        if (coll == 0) {
-            retofs = cs->current_offset;
-        } else {
-            debug(81, 3) ("storeCossAllocate: Collision\n");
-        }
     }
     if (coll == 0) {
-        cs->current_offset += allocsize;
-        return retofs;
+	cs->current_offset += allocsize;
+	return retofs;
     } else {
-        return -1;
+	return -1;
     }
 }
 
 void
-storeCossUnlink(SwapDir *SD, StoreEntry *e)
+storeCossUnlink(SwapDir * SD, StoreEntry * e)
 {
     debug(81, 3) ("storeCossUnlink: offset %d\n", e->swap_filen);
     dlinkDelete(&e->repl.lru, &SD->repl.lru.list);
 }
 
 
 storeIOState *
-storeCossCreate(SwapDir *SD, StoreEntry *e, STFNCB *file_callback, STIOCB *callback, void *callback_data)
+storeCossCreate(SwapDir * SD, StoreEntry * e, STFNCB * file_callback, STIOCB * callback, void *callback_data)
 {
     CossState *cstate;
     storeIOState *sio;
@@ -144,8 +147,8 @@ storeCossCreate(SwapDir *SD, StoreEntry *e, STFNCB *file_callback, STIOCB *callb
     sio->callback = callback;
     sio->callback_data = callback_data;
     cbdataLock(callback_data);
-    sio->e = (StoreEntry *)e;
-    sio->st_size = -1; // we won't know this until we read the metadata
+    sio->e = (StoreEntry *) e;
+    sio->st_size = -1;		/* we won't know this until we read the metadata */
 
     cstate->flags.writing = 0;
     cstate->flags.reading = 0;
@@ -160,14 +163,14 @@ storeCossCreate(SwapDir *SD, StoreEntry *e, STFNCB *file_callback, STIOCB *callb
 }
 
 storeIOState *
-storeCossOpen(SwapDir *SD, StoreEntry *e, STFNCB * file_callback,
-  STIOCB * callback, void *callback_data)
+storeCossOpen(SwapDir * SD, StoreEntry * e, STFNCB * file_callback,
+    STIOCB * callback, void *callback_data)
 {
     storeIOState *sio;
     char *p;
     CossState *cstate;
     sfileno f = e->swap_filen;
-    CossInfo *cs = (CossInfo *)SD->fsdata;
+    CossInfo *cs = (CossInfo *) SD->fsdata;
 
     debug(81, 3) ("storeCossOpen: offset %d\n", f);
 
@@ -192,71 +195,71 @@ storeCossOpen(SwapDir *SD, StoreEntry *e, STFNCB * file_callback,
     cstate->readbuffer = NULL;
     cstate->reqdiskoffset = -1;
     p = storeCossMemPointerFromDiskOffset(SD, f, NULL);
-    // make local copy so we don't have to lock membuf
+    /* make local copy so we don't have to lock membuf */
     if (p) {
-        cstate->readbuffer = xmalloc(sio->st_size);
-        memcpy(cstate->readbuffer, p, sio->st_size);
+	cstate->readbuffer = xmalloc(sio->st_size);
+	memcpy(cstate->readbuffer, p, sio->st_size);
     } else {
-        /* Do the allocation */
+	/* Do the allocation */
 	/* this is the first time we've been called on a new sio
-           read the whole object into memory, then return the 
-           requested amount
-         */
-        /*
-         * This bit of code actually does the LRU disk thing - we realloc
-         * a place for the object here, and the file_read() reads the object
-         * into the cossmembuf for later writing ..
-         */
-        cstate->reqdiskoffset = sio->swap_filen;
-        sio->swap_filen = -1;
-        sio->swap_filen = storeCossAllocate(SD, e, COSS_ALLOC_REALLOC);
+	 * read the whole object into memory, then return the 
+	 * requested amount
+	 */
+	/*
+	 * This bit of code actually does the LRU disk thing - we realloc
+	 * a place for the object here, and the file_read() reads the object
+	 * into the cossmembuf for later writing ..
+	 */
+	cstate->reqdiskoffset = sio->swap_filen;
+	sio->swap_filen = -1;
+	sio->swap_filen = storeCossAllocate(SD, e, COSS_ALLOC_REALLOC);
 	if (sio->swap_filen == -1) {
-            /* We have to clean up neatly .. */
+	    /* We have to clean up neatly .. */
 	    cbdataFree(sio);
 	    cs->numcollisions++;
 	    debug(81, 2) ("storeCossOpen: Reallocation of %d/%d failed\n", e->swap_dirn, e->swap_filen);
-            /* XXX XXX XXX Will squid call storeUnlink for this object? */
+	    /* XXX XXX XXX Will squid call storeUnlink for this object? */
 	    return NULL;
 	}
-        /* Notify the upper levels that we've changed file number */
+	/* Notify the upper levels that we've changed file number */
 	sio->file_callback(sio->callback_data, 0, sio);
-        
-        /*
-         * lock the buffer so it doesn't get swapped out on us
-         * this will get unlocked in storeCossReadDone
-         */
-        storeCossMemBufLock(SD, sio);
-
-        /*
-         * Do the LRU magic to keep the disk and memory LRUs identical
-         */
-        dlinkDelete(&sio->e->repl.lru, &SD->repl.lru.list);
-        dlinkAdd(sio->e, &sio->e->repl.lru, &SD->repl.lru.list);
-
-        /*
-         * Since we've reallocated a spot for this object, we need to
-         * write it to the cossmembuf *and* return it in the read ..
-         */
-        cstate->readbuffer = NULL;
+
+	/*
+	 * lock the buffer so it doesn't get swapped out on us
+	 * this will get unlocked in storeCossReadDone
+	 */
+	storeCossMemBufLock(SD, sio);
+
+	/*
+	 * Do the LRU magic to keep the disk and memory LRUs identical
+	 */
+	dlinkDelete(&sio->e->repl.lru, &SD->repl.lru.list);
+	dlinkAdd(sio->e, &sio->e->repl.lru, &SD->repl.lru.list);
+
+	/*
+	 * Since we've reallocated a spot for this object, we need to
+	 * write it to the cossmembuf *and* return it in the read ..
+	 */
+	cstate->readbuffer = NULL;
     }
     return sio;
 }
 
 void
-storeCossClose(SwapDir *SD, storeIOState * sio)
+storeCossClose(SwapDir * SD, storeIOState * sio)
 {
-    debug(81, 3) ("storeCossClose: offset %d\n",sio->swap_filen);
+    debug(81, 3) ("storeCossClose: offset %d\n", sio->swap_filen);
     if (sio->mode == O_WRONLY)
-        storeCossMemBufUnlock(SD, sio);
+	storeCossMemBufUnlock(SD, sio);
     storeCossIOCallback(sio, 0);
 }
 
 void
-storeCossRead(SwapDir *SD, storeIOState * sio, char *buf, size_t size, off_t offset, STRCB * callback, void *callback_data)
+storeCossRead(SwapDir * SD, storeIOState * sio, char *buf, size_t size, off_t offset, STRCB * callback, void *callback_data)
 {
     char *p;
-    CossState *cstate = (CossState *)sio->fsstate;
-    CossInfo *cs = (CossInfo *)SD->fsdata;
+    CossState *cstate = (CossState *) sio->fsstate;
+    CossInfo *cs = (CossInfo *) SD->fsdata;
 
     assert(sio->read.callback == NULL);
     assert(sio->read.callback_data == NULL);
@@ -267,43 +270,43 @@ storeCossRead(SwapDir *SD, storeIOState * sio, char *buf, size_t size, off_t off
     sio->offset = offset;
     cstate->flags.reading = 1;
     if ((offset + size) > sio->st_size)
-        size = sio->st_size - offset;
+	size = sio->st_size - offset;
     cstate->requestlen = size;
     cstate->requestbuf = buf;
     cstate->requestoffset = offset;
     if (cstate->readbuffer == NULL) {
-        p = storeCossMemPointerFromDiskOffset(SD, sio->swap_filen, NULL);
-        file_read(cs->fd,
+	p = storeCossMemPointerFromDiskOffset(SD, sio->swap_filen, NULL);
+	file_read(cs->fd,
 	    p,
 	    sio->st_size,
 	    cstate->reqdiskoffset,
 	    storeCossReadDone,
 	    sio);
-        cstate->reqdiskoffset = 0; /* XXX */
+	cstate->reqdiskoffset = 0;	/* XXX */
     } else {
-        storeCossReadDone(cs->fd,
-            cstate->readbuffer,
-            sio->st_size,
-            0,
-            sio);
-    }            
+	storeCossReadDone(cs->fd,
+	    cstate->readbuffer,
+	    sio->st_size,
+	    0,
+	    sio);
+    }
 }
 
 void
-storeCossWrite(SwapDir *SD, storeIOState * sio, char *buf, size_t size, off_t offset, FREE * free_func)
+storeCossWrite(SwapDir * SD, storeIOState * sio, char *buf, size_t size, off_t offset, FREE * free_func)
 {
     char *dest;
     CossMemBuf *membuf;
     off_t diskoffset;
-    
-    debug(81, 3) ("storeCossWrite: offset %d, len %d\n",sio->offset, size);
+
+    debug(81, 3) ("storeCossWrite: offset %d, len %d\n", sio->offset, size);
     diskoffset = sio->swap_filen + sio->offset;
     dest = storeCossMemPointerFromDiskOffset(SD, diskoffset, &membuf);
     assert(dest != NULL);
     memcpy(dest, buf, size);
     sio->offset += size;
     if (free_func)
-        (free_func)(buf);
+	(free_func) (buf);
 }
 
 
@@ -317,26 +320,26 @@ storeCossReadDone(int fd, const char *buf, int len, int errflag, void *my_data)
     STRCB *callback = sio->read.callback;
     void *their_data = sio->read.callback_data;
     SwapDir *SD = INDEXSD(sio->swap_dirn);
-    CossState *cstate = (CossState *)sio->fsstate;
+    CossState *cstate = (CossState *) sio->fsstate;
     size_t rlen;
 
     debug(81, 3) ("storeCossReadDone: fileno %d, FD %d, len %d\n",
 	sio->swap_filen, fd, len);
     cstate->flags.reading = 0;
     if (errflag) {
 	debug(81, 3) ("storeCossReadDone: got failure (%d)\n", errflag);
-        rlen = -1;
+	rlen = -1;
     } else {
-        if (cstate->readbuffer == NULL) {
-            cstate->readbuffer = xmalloc(sio->st_size);
-            p = storeCossMemPointerFromDiskOffset(SD, sio->swap_filen, NULL);
-            memcpy(cstate->readbuffer, p, sio->st_size);
-            storeCossMemBufUnlock(SD, sio);
-        }
-        sio->offset += len;
-        memcpy(cstate->requestbuf, &cstate->readbuffer[cstate->requestoffset],
-          cstate->requestlen);
-        rlen = (size_t) cstate->requestlen;
+	if (cstate->readbuffer == NULL) {
+	    cstate->readbuffer = xmalloc(sio->st_size);
+	    p = storeCossMemPointerFromDiskOffset(SD, sio->swap_filen, NULL);
+	    memcpy(cstate->readbuffer, p, sio->st_size);
+	    storeCossMemBufUnlock(SD, sio);
+	}
+	sio->offset += len;
+	memcpy(cstate->requestbuf, &cstate->readbuffer[cstate->requestoffset],
+	    cstate->requestlen);
+	rlen = (size_t) cstate->requestlen;
     }
     assert(callback);
     assert(their_data);
@@ -350,7 +353,7 @@ storeCossReadDone(int fd, const char *buf, int len, int errflag, void *my_data)
 static void
 storeCossIOCallback(storeIOState * sio, int errflag)
 {
-    CossState *cstate = (CossState *)sio->fsstate;
+    CossState *cstate = (CossState *) sio->fsstate;
     debug(81, 3) ("storeCossIOCallback: errflag=%d\n", errflag);
     xfree(cstate->readbuffer);
     if (cbdataValid(sio->callback_data))
@@ -360,63 +363,63 @@ storeCossIOCallback(storeIOState * sio, int errflag)
 }
 
 static char *
-storeCossMemPointerFromDiskOffset(SwapDir *SD, size_t offset, CossMemBuf **mb)
+storeCossMemPointerFromDiskOffset(SwapDir * SD, size_t offset, CossMemBuf ** mb)
 {
     CossMemBuf *t;
-    CossInfo *cs = (CossInfo *)SD->fsdata;
-
-    for (t=cs->membufs; t; t = t->next)
-        if ((offset >= t->diskstart) && (offset <= t->diskend)) {
-            if (mb)
-                *mb = t;
-            return &t->buffer[offset - t->diskstart];
-        }
+    CossInfo *cs = (CossInfo *) SD->fsdata;
+
+    for (t = cs->membufs; t; t = t->next)
+	if ((offset >= t->diskstart) && (offset <= t->diskend)) {
+	    if (mb)
+		*mb = t;
+	    return &t->buffer[offset - t->diskstart];
+	}
     if (mb)
-        *mb = NULL;
+	*mb = NULL;
     return NULL;
 }
 
 static void
-storeCossMemBufLock(SwapDir *SD, storeIOState *e)
+storeCossMemBufLock(SwapDir * SD, storeIOState * e)
 {
     CossMemBuf *t;
-    CossInfo *cs = (CossInfo *)SD->fsdata;
+    CossInfo *cs = (CossInfo *) SD->fsdata;
 
     for (t = cs->membufs; t; t = t->next)
-        if ((e->swap_filen >= t->diskstart) && (e->swap_filen <= t->diskend)) {
-            debug(81, 3) ("storeCossMemBufLock: locking %08X, lockcount %d\n",t, t->lockcount);
-            t->lockcount++;
-            return;
-        }
-    debug(81, 3) ("storeCossMemBufLock: FAILED to lock %08X\n",e);
+	if ((e->swap_filen >= t->diskstart) && (e->swap_filen <= t->diskend)) {
+	    debug(81, 3) ("storeCossMemBufLock: locking %08X, lockcount %d\n", t, t->lockcount);
+	    t->lockcount++;
+	    return;
+	}
+    debug(81, 3) ("storeCossMemBufLock: FAILED to lock %08X\n", e);
 }
 
 static void
-storeCossMemBufUnlock(SwapDir *SD, storeIOState *e)
+storeCossMemBufUnlock(SwapDir * SD, storeIOState * e)
 {
     CossMemBuf *t;
-    CossInfo *cs = (CossInfo *)SD->fsdata;
+    CossInfo *cs = (CossInfo *) SD->fsdata;
 
     for (t = cs->membufs; t; t = t->next) {
-        if ((e->swap_filen >= t->diskstart) && (e->swap_filen <= t->diskend)) {
-            t->lockcount--;
-            debug(81, 3) ("storeCossMemBufUnlock: unlocking %08X, lockcount %d\n",t, t->lockcount);
-        }
-        if (t->flags.full && !t->flags.writing && !t->lockcount) 
-            storeCossWriteMemBuf(SD, t);
+	if ((e->swap_filen >= t->diskstart) && (e->swap_filen <= t->diskend)) {
+	    t->lockcount--;
+	    debug(81, 3) ("storeCossMemBufUnlock: unlocking %08X, lockcount %d\n", t, t->lockcount);
+	}
+	if (t->flags.full && !t->flags.writing && !t->lockcount)
+	    storeCossWriteMemBuf(SD, t);
     }
 }
 
 
 static void
-storeCossWriteMemBuf(SwapDir *SD, CossMemBuf *t)
+storeCossWriteMemBuf(SwapDir * SD, CossMemBuf * t)
 {
-    CossInfo *cs = (CossInfo *)SD->fsdata;
+    CossInfo *cs = (CossInfo *) SD->fsdata;
     debug(81, 3) ("storeCossWriteMemBuf: offset %d, len %d\n",
 	t->diskstart, t->diskend - t->diskstart);
     cbdataAdd(t, storeCossMembufFree, 0);
     file_write(cs->fd, t->diskstart, &t->buffer,
-      t->diskend - t->diskstart, storeCossWriteMemBufDone, t, NULL);
+	t->diskend - t->diskstart, storeCossWriteMemBufDone, t, NULL);
     t->flags.writing = 1;
 }
 
@@ -425,73 +428,73 @@ static void
 storeCossWriteMemBufDone(int fd, int errflag, size_t len, void *my_data)
 {
     CossMemBuf *t = my_data;
-    CossMemBuf *p,*prev;
-    CossInfo *cs = (CossInfo *)t->SD->fsdata;
+    CossMemBuf *p, *prev;
+    CossInfo *cs = (CossInfo *) t->SD->fsdata;
 
-    debug(81, 3) ("storeCossWriteMemBufDone: len %d\n",len);
+    debug(81, 3) ("storeCossWriteMemBufDone: len %d\n", len);
     if (errflag) {
 	debug(81, 0) ("storeCossMemBufWriteDone: got failure (%d)\n", errflag);
-        cbdataFree(t);
+	cbdataFree(t);
 	return;
     }
-
     if (t == cs->membufs) {
-        cs->membufs = t->next;
-        cbdataFree(t);
-        return;
+	cs->membufs = t->next;
+	cbdataFree(t);
+	return;
     }
     prev = t;
     for (p = cs->membufs; p; p = p->next) {
-        if (t == p) {
-            prev->next = t->next;
-            cbdataFree(t);
-            return;
-        }
-        prev = p;
-    }    
+	if (t == p) {
+	    prev->next = t->next;
+	    cbdataFree(t);
+	    return;
+	}
+	prev = p;
+    }
     cbdataFree(t);
 }
 
-static CossMemBuf *storeCossCreateMemBuf(SwapDir *SD, size_t start,
-  sfileno curfn, int *collision)
+static CossMemBuf *
+storeCossCreateMemBuf(SwapDir * SD, size_t start,
+    sfileno curfn, int *collision)
 {
-    CossMemBuf *newmb,*t;
+    CossMemBuf *newmb, *t;
     StoreEntry *e;
-    dlink_node *m,*prev;
-    int numreleased=0;
-    CossInfo *cs = (CossInfo *)SD->fsdata;
+    dlink_node *m, *prev;
+    int numreleased = 0;
+    CossInfo *cs = (CossInfo *) SD->fsdata;
 
     newmb = memPoolAlloc(coss_membuf_pool);
     newmb->diskstart = start;
-    debug(81, 3) ("storeCossCreateMemBuf: creating new membuf at %d\n",newmb->diskstart);
+    debug(81, 3) ("storeCossCreateMemBuf: creating new membuf at %d\n", newmb->diskstart);
     newmb->diskend = newmb->diskstart + COSS_MEMBUF_SZ - 1;
     newmb->flags.full = 0;
     newmb->flags.writing = 0;
     newmb->lockcount = 0;
     newmb->SD = SD;
     newmb->next = cs->membufs;
     cs->membufs = newmb;
-    for (t = cs->membufs; t; t = t->next) 
-        debug(81, 3) ("storeCossCreateMemBuf: membuflist %d lockcount %d\n",t->diskstart,t->lockcount);
+    for (t = cs->membufs; t; t = t->next)
+	debug(81, 3) ("storeCossCreateMemBuf: membuflist %d lockcount %d\n", t->diskstart, t->lockcount);
 
     /*
      * XXX more evil LRU specific code. This needs to be replaced.
      */
     for (m = SD->repl.lru.list.tail; m; m = prev) {
-        prev = m->prev;
-        e = m->data;
-        if (curfn == e->swap_filen)
-            *collision = 1; /* Mark an object alloc collision */
-        if ((e->swap_filen >= newmb->diskstart) &&
-          (e->swap_filen <= newmb->diskend)) {
-            storeRelease(e);
-            numreleased++;         
-        } else
-            break;    
+	prev = m->prev;
+	e = m->data;
+	if (curfn == e->swap_filen)
+	    *collision = 1;	/* Mark an object alloc collision */
+	if ((e->swap_filen >= newmb->diskstart) &&
+	    (e->swap_filen <= newmb->diskend)) {
+	    storeRelease(e);
+	    numreleased++;
+	} else
+	    break;
     }
     if (numreleased > 0)
-       debug(81, 3) ("storeCossCreateMemBuf: this allocation released %d storeEntries\n",numreleased);
-    return newmb; 
+	debug(81, 3) ("storeCossCreateMemBuf: this allocation released %d storeEntries\n", numreleased);
+    return newmb;
 }
 
 /*
@@ -501,8 +504,8 @@ static CossMemBuf *storeCossCreateMemBuf(SwapDir *SD, size_t start,
 static void
 storeCossIOFreeEntry(void *sio, int foo)
 {
-        memPoolFree(coss_state_pool, ((storeIOState *)sio)->fsstate);
-        memFree(sio, MEM_STORE_IO);
+    memPoolFree(coss_state_pool, ((storeIOState *) sio)->fsstate);
+    memFree(sio, MEM_STORE_IO);
 }
 
 /*
@@ -515,4 +518,3 @@ storeCossMembufFree(void *mb, int foo)
 {
     memPoolFree(coss_membuf_pool, mb);
 }
-
@@ -307,4 +307,3 @@ main(int argc, char *argv[])
 	perror("shmctl IPC_RMID");
     return 0;
 }
-
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_dir_diskd.cc,v 1.1 2000/05/03 17:15:47 adrian Exp $
+ * $Id: store_dir_diskd.cc,v 1.2 2000/05/12 00:29:20 wessels Exp $
  *
  * DEBUG: section 47    Store Directory Routines
  * AUTHOR: Duane Wessels
@@ -81,7 +81,7 @@ struct _RebuildState {
 
 static int n_diskd_dirs = 0;
 static int *diskd_dir_index = NULL;
-MemPool * diskd_state_pool = NULL;
+MemPool *diskd_state_pool = NULL;
 static int diskd_initialised = 0;
 
 static char *storeDiskdDirSwapSubDir(SwapDir *, int subdirn);
@@ -93,7 +93,7 @@ static char *storeDiskdDirSwapLogFile(SwapDir *, const char *);
 static EVH storeDiskdDirRebuildFromDirectory;
 static EVH storeDiskdDirRebuildFromSwapLog;
 static int storeDiskdDirGetNextFile(RebuildState *, int *sfileno, int *size);
-static StoreEntry *storeDiskdDirAddDiskRestore(SwapDir *SD, const cache_key * key,
+static StoreEntry *storeDiskdDirAddDiskRestore(SwapDir * SD, const cache_key * key,
     int file_number,
     size_t swap_file_sz,
     time_t expires,
@@ -146,68 +146,68 @@ static void storeDiskdDirCallback(SwapDir *);
  */
 
 int
-storeDiskdDirMapBitTest(SwapDir *SD, int fn)
+storeDiskdDirMapBitTest(SwapDir * SD, int fn)
 {
     sfileno filn = fn;
     diskdinfo_t *diskdinfo;
-    diskdinfo = (diskdinfo_t *)SD->fsdata;
+    diskdinfo = (diskdinfo_t *) SD->fsdata;
     return file_map_bit_test(diskdinfo->map, filn);
 }
- 
+
 void
-storeDiskdDirMapBitSet(SwapDir *SD, int fn)
-{  
+storeDiskdDirMapBitSet(SwapDir * SD, int fn)
+{
     sfileno filn = fn;
     diskdinfo_t *diskdinfo;
-    diskdinfo = (diskdinfo_t *)SD->fsdata;
+    diskdinfo = (diskdinfo_t *) SD->fsdata;
     file_map_bit_set(diskdinfo->map, filn);
 }
- 
+
 void
-storeDiskdDirMapBitReset(SwapDir *SD, int fn)
-{ 
+storeDiskdDirMapBitReset(SwapDir * SD, int fn)
+{
     sfileno filn = fn;
     diskdinfo_t *diskdinfo;
-    diskdinfo = (diskdinfo_t *)SD->fsdata;
+    diskdinfo = (diskdinfo_t *) SD->fsdata;
     file_map_bit_reset(diskdinfo->map, filn);
 }
 
 int
-storeDiskdDirMapBitAllocate(SwapDir *SD)
+storeDiskdDirMapBitAllocate(SwapDir * SD)
 {
-    diskdinfo_t *diskdinfo = (diskdinfo_t *)SD->fsdata;
+    diskdinfo_t *diskdinfo = (diskdinfo_t *) SD->fsdata;
     int fn;
     fn = file_map_allocate(diskdinfo->map, diskdinfo->suggest);
     file_map_bit_set(diskdinfo->map, fn);
     diskdinfo->suggest = fn + 1;
     return fn;
 }
-    
+
 /*
  * Initialise the diskd bitmap
  *
  * If there already is a bitmap, and the numobjects is larger than currently
  * configured, we allocate a new bitmap and 'grow' the old one into it.
  */
 static void
-storeDiskdDirInitBitmap(SwapDir *sd)
+storeDiskdDirInitBitmap(SwapDir * sd)
 {
-    diskdinfo_t *diskdinfo = (diskdinfo_t *)sd->fsdata;
+    diskdinfo_t *diskdinfo = (diskdinfo_t *) sd->fsdata;
 
     if (diskdinfo->map == NULL) {
-        /* First time */
+	/* First time */
 	diskdinfo->map = file_map_create();
     } else if (diskdinfo->map->max_n_files) {
-        /* it grew, need to expand */
-        /* XXX We don't need it anymore .. */
+	/* it grew, need to expand */
+	/* XXX We don't need it anymore .. */
     }
     /* else it shrunk, and we leave the old one in place */
 }
 
 static char *
 storeDiskdDirSwapSubDir(SwapDir * sd, int subdirn)
 {
-    diskdinfo_t *diskdinfo = (diskdinfo_t *)sd->fsdata;
+    diskdinfo_t *diskdinfo = (diskdinfo_t *) sd->fsdata;
 
     LOCAL_ARRAY(char, fullfilename, SQUID_MAXPATHLEN);
     assert(0 <= subdirn && subdirn < diskdinfo->l1);
@@ -260,7 +260,7 @@ storeDiskdDirVerifyDirectory(const char *path)
 static int
 storeDiskdDirVerifyCacheDirs(SwapDir * sd)
 {
-    diskdinfo_t *diskdinfo = (diskdinfo_t *)sd->fsdata;
+    diskdinfo_t *diskdinfo = (diskdinfo_t *) sd->fsdata;
     int j;
     const char *path = sd->path;
 
@@ -277,7 +277,7 @@ storeDiskdDirVerifyCacheDirs(SwapDir * sd)
 static void
 storeDiskdDirCreateSwapSubDirs(SwapDir * sd)
 {
-    diskdinfo_t *diskdinfo = (diskdinfo_t *)sd->fsdata;
+    diskdinfo_t *diskdinfo = (diskdinfo_t *) sd->fsdata;
     int i, k;
     int should_exist;
     LOCAL_ARRAY(char, name, MAXPATHLEN);
@@ -303,31 +303,31 @@ storeDiskdDirSwapLogFile(SwapDir * sd, const char *ext)
     LOCAL_ARRAY(char, digit, 32);
     char *pathtmp2;
     if (Config.Log.swap) {
-        xstrncpy(pathtmp, sd->path, SQUID_MAXPATHLEN - 64);
-        while (index(pathtmp,'/'))
-            *index(pathtmp,'/')='.';
-        while (strlen(pathtmp) && pathtmp[strlen(pathtmp)-1]=='.')
-            pathtmp[strlen(pathtmp)-1]= '\0';
-        for(pathtmp2 = pathtmp; *pathtmp2 == '.'; pathtmp2++);
-        snprintf(path, SQUID_MAXPATHLEN-64, Config.Log.swap, pathtmp2);
-        if (strncmp(path, Config.Log.swap, SQUID_MAXPATHLEN - 64) == 0) {
-            strcat(path, ".");
-            snprintf(digit, 32, "%02d", sd->index);
-            strncat(path, digit, 3);
-        }
+	xstrncpy(pathtmp, sd->path, SQUID_MAXPATHLEN - 64);
+	while (index(pathtmp, '/'))
+	    *index(pathtmp, '/') = '.';
+	while (strlen(pathtmp) && pathtmp[strlen(pathtmp) - 1] == '.')
+	    pathtmp[strlen(pathtmp) - 1] = '\0';
+	for (pathtmp2 = pathtmp; *pathtmp2 == '.'; pathtmp2++);
+	snprintf(path, SQUID_MAXPATHLEN - 64, Config.Log.swap, pathtmp2);
+	if (strncmp(path, Config.Log.swap, SQUID_MAXPATHLEN - 64) == 0) {
+	    strcat(path, ".");
+	    snprintf(digit, 32, "%02d", sd->index);
+	    strncat(path, digit, 3);
+	}
     } else {
-        xstrncpy(path, sd->path, SQUID_MAXPATHLEN - 64);
-        strcat(path, "/swap.state");
+	xstrncpy(path, sd->path, SQUID_MAXPATHLEN - 64);
+	strcat(path, "/swap.state");
     }
     if (ext)
-        strncat(path, ext, 16);
+	strncat(path, ext, 16);
     return path;
 }
 
 static void
 storeDiskdDirOpenSwapLog(SwapDir * sd)
 {
-    diskdinfo_t *diskdinfo = (diskdinfo_t *)sd->fsdata;
+    diskdinfo_t *diskdinfo = (diskdinfo_t *) sd->fsdata;
     char *path;
     int fd;
     path = storeDiskdDirSwapLogFile(sd, NULL);
@@ -347,7 +347,7 @@ storeDiskdDirOpenSwapLog(SwapDir * sd)
 static void
 storeDiskdDirCloseSwapLog(SwapDir * sd)
 {
-    diskdinfo_t *diskdinfo = (diskdinfo_t *)sd->fsdata;
+    diskdinfo_t *diskdinfo = (diskdinfo_t *) sd->fsdata;
     if (diskdinfo->swaplog_fd < 0)	/* not open */
 	return;
     file_close(diskdinfo->swaplog_fd);
@@ -380,28 +380,28 @@ storeDiskdDirInit(SwapDir * sd)
 
     diskdinfo->smsgid = msgget((key_t) ikey, 0700 | IPC_CREAT);
     if (diskdinfo->smsgid < 0) {
-        debug(50, 0) ("storeDiskdInit: msgget: %s\n", xstrerror());
-        fatal("msgget failed");
+	debug(50, 0) ("storeDiskdInit: msgget: %s\n", xstrerror());
+	fatal("msgget failed");
     }
     diskdinfo->rmsgid = msgget((key_t) (ikey + 1), 0700 | IPC_CREAT);
     if (diskdinfo->rmsgid < 0) {
-        debug(50, 0) ("storeDiskdInit: msgget: %s\n", xstrerror());
-        fatal("msgget failed");
+	debug(50, 0) ("storeDiskdInit: msgget: %s\n", xstrerror());
+	fatal("msgget failed");
     }
     diskdinfo->shm.id = shmget((key_t) (ikey + 2),
-        SHMBUFS * SHMBUF_BLKSZ, 0600 | IPC_CREAT);
+	SHMBUFS * SHMBUF_BLKSZ, 0600 | IPC_CREAT);
     if (diskdinfo->shm.id < 0) {
-        debug(50, 0) ("storeDiskdInit: shmget: %s\n", xstrerror());
-        fatal("shmget failed");
+	debug(50, 0) ("storeDiskdInit: shmget: %s\n", xstrerror());
+	fatal("shmget failed");
     }
     diskdinfo->shm.buf = shmat(diskdinfo->shm.id, NULL, 0);
     if (diskdinfo->shm.buf == (void *) -1) {
-        debug(50, 0) ("storeDiskdInit: shmat: %s\n", xstrerror());
-        fatal("shmat failed");
+	debug(50, 0) ("storeDiskdInit: shmat: %s\n", xstrerror());
+	fatal("shmat failed");
     }
     diskd_stats.shmbuf_count += SHMBUFS;
     for (i = 0; i < SHMBUFS; i++)
-        storeDiskdShmPut(sd, i * SHMBUF_BLKSZ);
+	storeDiskdShmPut(sd, i * SHMBUF_BLKSZ);
     snprintf(skey1, 32, "%d", ikey);
     snprintf(skey2, 32, "%d", ikey + 1);
     snprintf(skey3, 32, "%d", ikey + 2);
@@ -416,15 +416,15 @@ storeDiskdDirInit(SwapDir * sd)
 #else
     x = ipcCreate(IPC_FIFO,
 #endif
-        SQUID_PREFIX "/bin/diskd",
-        args,
-        "diskd",
-        &rfd,
-        &diskdinfo->wfd);
+	SQUID_PREFIX "/bin/diskd",
+	args,
+	"diskd",
+	&rfd,
+	&diskdinfo->wfd);
     if (x < 0)
-        fatal("execl " SQUID_PREFIX "/bin/diskd failed");
+	fatal("execl " SQUID_PREFIX "/bin/diskd failed");
     if (rfd != diskdinfo->wfd)
-        comm_close(rfd);
+	comm_close(rfd);
     fd_note(diskdinfo->wfd, "squid -> diskd");
     commSetTimeout(diskdinfo->wfd, -1, NULL, NULL);
     commSetNonBlocking(diskdinfo->wfd);
@@ -459,7 +459,7 @@ storeDiskdStats(StoreEntry * sentry)
  * until the data has finished writing.
  */
 static void
-storeDiskdDirSync(SwapDir *SD)
+storeDiskdDirSync(SwapDir * SD)
 {
     /* XXX NOT DONE YET! */
 #warning "storeDiskdSync() needs to be written"
@@ -474,34 +474,33 @@ storeDiskdDirSync(SwapDir *SD)
  * don't get a message.
  */
 static void
-storeDiskdDirCallback(SwapDir *SD)
+storeDiskdDirCallback(SwapDir * SD)
 {
     diomsg M;
     int x;
-    diskdinfo_t *diskdinfo = (diskdinfo_t *)SD->fsdata;
+    diskdinfo_t *diskdinfo = (diskdinfo_t *) SD->fsdata;
 
     if (diskdinfo->away >= diskdinfo->magic2)
 	diskd_stats.block_queue_len++;
 
     if (diskd_stats.sent_count - diskd_stats.recv_count >
-      diskd_stats.max_away) {
-        diskd_stats.max_away = diskd_stats.sent_count - diskd_stats.recv_count;
-        diskd_stats.max_shmuse = diskd_stats.shmbuf_count;
+	diskd_stats.max_away) {
+	diskd_stats.max_away = diskd_stats.sent_count - diskd_stats.recv_count;
+	diskd_stats.max_shmuse = diskd_stats.shmbuf_count;
     }
-
     /* if we are above magic2, we do not break under any reason */
     while (1) {
-        memset(&M, '\0', sizeof(M));
-        x = msgrcv(diskdinfo->rmsgid, &M, msg_snd_rcv_sz, 0, IPC_NOWAIT);
+	memset(&M, '\0', sizeof(M));
+	x = msgrcv(diskdinfo->rmsgid, &M, msg_snd_rcv_sz, 0, IPC_NOWAIT);
 	if (x < 0) {
 	    if (diskdinfo->away >= diskdinfo->magic2)
 		continue;
-            else
-                break;
+	    else
+		break;
 	} else if (x != msg_snd_rcv_sz) {
-            debug(81, 1) ("storeDiskdReadIndividualQueue: msgget returns %d\n",
-	      x);
-            break;
+	    debug(81, 1) ("storeDiskdReadIndividualQueue: msgget returns %d\n",
+		x);
+	    break;
 	}
 	diskd_stats.recv_count++;
 	diskdinfo->away--;
@@ -580,7 +579,7 @@ storeDiskdDirRebuildFromDirectory(void *data)
 	tlv_list = storeSwapMetaUnpack(hdr_buf, &swap_hdr_len);
 	if (tlv_list == NULL) {
 	    debug(20, 1) ("storeDiskdDirRebuildFromDirectory: failed to get meta data\n");
-            /* XXX shouldn't this be a call to storeDiskdUnlink ? */
+	    /* XXX shouldn't this be a call to storeDiskdUnlink ? */
 	    storeDiskdDirUnlinkFile(SD, sfileno);
 	    continue;
 	}
@@ -700,13 +699,13 @@ storeDiskdDirRebuildFromSwapLog(void *data)
 		 * because adding to store_swap_size happens in
 		 * the cleanup procedure.
 		 */
-                storeExpireNow(e);
-                storeReleaseRequest(e);
-                storeDiskdDirReplRemove(e);
+		storeExpireNow(e);
+		storeReleaseRequest(e);
+		storeDiskdDirReplRemove(e);
 		if (e->swap_filen > -1) {
 		    storeDiskdDirMapBitReset(SD, e->swap_filen);
 		    e->swap_filen = -1;
-                    e->swap_dirn = -1;
+		    e->swap_dirn = -1;
 		}
 		storeRelease(e);
 		rb->counts.objcount--;
@@ -753,7 +752,7 @@ storeDiskdDirRebuildFromSwapLog(void *data)
 		e->refcount += s.refcount;
 #if HEAP_REPLACEMENT
 		storeHeapPositionUpdate(e, SD);
-                storeDiskdDirUnrefObj(SD, e);
+		storeDiskdDirUnrefObj(SD, e);
 #endif
 	    } else {
 		debug_trap("storeDiskdDirRebuildFromSwapLog: bad condition");
@@ -788,14 +787,14 @@ storeDiskdDirRebuildFromSwapLog(void *data)
 	} else if (e) {
 	    /* key already exists, this swapfile not being used */
 	    /* junk old, load new */
-            storeExpireNow(e);
-            storeReleaseRequest(e);
-            storeDiskdDirReplRemove(e);
+	    storeExpireNow(e);
+	    storeReleaseRequest(e);
+	    storeDiskdDirReplRemove(e);
 	    if (e->swap_filen > -1) {
-                /* Make sure we don't actually unlink the file */
+		/* Make sure we don't actually unlink the file */
 		storeDiskdDirMapBitReset(SD, e->swap_filen);
 		e->swap_filen = -1;
-                e->swap_dirn = -1;
+		e->swap_dirn = -1;
 	    }
 	    storeRelease(e);
 	    rb->counts.dupcount++;
@@ -825,7 +824,7 @@ static int
 storeDiskdDirGetNextFile(RebuildState * rb, int *sfileno, int *size)
 {
     SwapDir *SD = rb->sd;
-    diskdinfo_t *diskdinfo = (diskdinfo_t *)SD->fsdata;
+    diskdinfo_t *diskdinfo = (diskdinfo_t *) SD->fsdata;
     int fd = -1;
     int used = 0;
     int dirs_opened = 0;
@@ -911,7 +910,7 @@ storeDiskdDirGetNextFile(RebuildState * rb, int *sfileno, int *size)
 /* Add a new object to the cache with empty memory copy and pointer to disk
  * use to rebuild store from disk. */
 static StoreEntry *
-storeDiskdDirAddDiskRestore(SwapDir *SD, const cache_key * key,
+storeDiskdDirAddDiskRestore(SwapDir * SD, const cache_key * key,
     int file_number,
     size_t swap_file_sz,
     time_t expires,
@@ -992,7 +991,7 @@ storeDiskdDirRebuild(SwapDir * sd)
 static void
 storeDiskdDirCloseTmpSwapLog(SwapDir * sd)
 {
-    diskdinfo_t *diskdinfo = (diskdinfo_t *)sd->fsdata;
+    diskdinfo_t *diskdinfo = (diskdinfo_t *) sd->fsdata;
     char *swaplog_path = xstrdup(storeDiskdDirSwapLogFile(sd, NULL));
     char *new_path = xstrdup(storeDiskdDirSwapLogFile(sd, ".new"));
     int fd;
@@ -1020,7 +1019,7 @@ storeDiskdDirCloseTmpSwapLog(SwapDir * sd)
 static FILE *
 storeDiskdDirOpenTmpSwapLog(SwapDir * sd, int *clean_flag, int *zero_flag)
 {
-    diskdinfo_t *diskdinfo = (diskdinfo_t *)sd->fsdata;
+    diskdinfo_t *diskdinfo = (diskdinfo_t *) sd->fsdata;
     char *swaplog_path = xstrdup(storeDiskdDirSwapLogFile(sd, NULL));
     char *clean_path = xstrdup(storeDiskdDirSwapLogFile(sd, ".last-clean"));
     char *new_path = xstrdup(storeDiskdDirSwapLogFile(sd, ".new"));
@@ -1206,7 +1205,7 @@ storeDiskdDirWriteCleanClose(SwapDir * sd)
 static void
 storeDiskdDirSwapLog(const SwapDir * sd, const StoreEntry * e, int op)
 {
-    diskdinfo_t *diskdinfo = (diskdinfo_t *)sd->fsdata;
+    diskdinfo_t *diskdinfo = (diskdinfo_t *) sd->fsdata;
     storeSwapLogData *s = xcalloc(1, sizeof(storeSwapLogData));
     s->op = (char) op;
     s->swap_filen = e->swap_filen;
@@ -1265,7 +1264,7 @@ storeDiskdDirClean(int swap_index)
     N0 = n_diskd_dirs;
     D0 = diskd_dir_index[swap_index % N0];
     SD = &Config.cacheSwap.swapDirs[D0];
-    diskdinfo = (diskdinfo_t *)SD->fsdata;
+    diskdinfo = (diskdinfo_t *) SD->fsdata;
     N1 = diskdinfo->l1;
     D1 = (swap_index / N0) % N1;
     N2 = diskdinfo->l2;
@@ -1287,7 +1286,7 @@ storeDiskdDirClean(int swap_index)
     while ((de = readdir(dp)) != NULL && k < 20) {
 	if (sscanf(de->d_name, "%X", &swapfileno) != 1)
 	    continue;
-	fn = swapfileno; /* XXX should remove this cruft ! */
+	fn = swapfileno;	/* XXX should remove this cruft ! */
 	if (storeDiskdDirValidFileno(SD, fn))
 	    if (storeDiskdDirMapBitTest(SD, fn))
 		if (storeDiskdFilenoBelongsHere(fn, D0, D1, D2))
@@ -1333,7 +1332,7 @@ storeDiskdDirCleanEvent(void *unused)
     assert(n_diskd_dirs);
     if (NULL == diskd_dir_index) {
 	SwapDir *sd;
-        diskdinfo_t *diskdinfo;
+	diskdinfo_t *diskdinfo;
 	/*
 	 * Initialize the little array that translates DISKD cache_dir
 	 * number into the Config.cacheSwap.swapDirs array index.
@@ -1344,7 +1343,7 @@ storeDiskdDirCleanEvent(void *unused)
 	    if (!storeDiskdDirIs(sd))
 		continue;
 	    diskd_dir_index[n++] = i;
-            diskdinfo = (diskdinfo_t *)sd->fsdata;
+	    diskdinfo = (diskdinfo_t *) sd->fsdata;
 	    j += (diskdinfo->l1 * diskdinfo->l2);
 	}
 	assert(n == n_diskd_dirs);
@@ -1383,7 +1382,7 @@ storeDiskdFilenoBelongsHere(int fn, int F0, int F1, int F2)
     int filn = fn;
     diskdinfo_t *diskdinfo;
     assert(F0 < Config.cacheSwap.n_configured);
-    diskdinfo = (diskdinfo_t *)Config.cacheSwap.swapDirs[F0].fsdata;
+    diskdinfo = (diskdinfo_t *) Config.cacheSwap.swapDirs[F0].fsdata;
     L1 = diskdinfo->l1;
     L2 = diskdinfo->l2;
     D1 = ((filn / L2) / L2) % L1;
@@ -1395,19 +1394,19 @@ storeDiskdFilenoBelongsHere(int fn, int F0, int F1, int F2)
     return 1;
 }
 
-int 
-storeDiskdDirValidFileno(SwapDir *SD, sfileno filn)
+int
+storeDiskdDirValidFileno(SwapDir * SD, sfileno filn)
 {
-    diskdinfo_t *diskdinfo = (diskdinfo_t *)SD->fsdata;
+    diskdinfo_t *diskdinfo = (diskdinfo_t *) SD->fsdata;
     if (filn < 0)
-        return 0;
-    if (filn > diskdinfo->map->max_n_files)  
-        return 0;
+	return 0;
+    if (filn > diskdinfo->map->max_n_files)
+	return 0;
     return 1;
 }
 
 void
-storeDiskdDirMaintain(SwapDir *SD)
+storeDiskdDirMaintain(SwapDir * SD)
 {
     StoreEntry *e = NULL;
     int scanned = 0;
@@ -1426,135 +1425,134 @@ storeDiskdDirMaintain(SwapDir *SD)
     link_list *locked_entries = NULL;
 #if HEAP_REPLACEMENT_DEBUG
     if (!verify_heap_property(SD->repl.heap.heap)) {
-        debug(20, 1) ("Heap property violated!\n");
+	debug(20, 1) ("Heap property violated!\n");
     }
 #endif
 #endif
     /* We can't delete objects while rebuilding swap */
     if (store_dirs_rebuilding) {
-        return;
+	return;
     } else {
-        f = (double) (store_swap_size - store_swap_low) / (store_swap_high - store_swap_low);
-        f = f < 0.0 ? 0.0 : f > 1.0 ? 1.0 : f;
-        max_scan = (int) (f * 400.0 + 100.0);
-        max_remove = (int) (f * 70.0 + 10.0);
+	f = (double) (store_swap_size - store_swap_low) / (store_swap_high - store_swap_low);
+	f = f < 0.0 ? 0.0 : f > 1.0 ? 1.0 : f;
+	max_scan = (int) (f * 400.0 + 100.0);
+	max_remove = (int) (f * 70.0 + 10.0);
 	/*
 	 * This is kinda cheap, but so we need this priority hack?
-         */
+	 */
 #if 0
-        eventAdd("MaintainSwapSpace", storeMaintainSwapSpace, NULL, 1.0 - f, 1);
+	eventAdd("MaintainSwapSpace", storeMaintainSwapSpace, NULL, 1.0 - f, 1);
 #endif
     }
     debug(20, 3) ("storeMaintainSwapSpace: f=%f, max_scan=%d, max_remove=%d\n", f, max_scan, max_remove);
 #if HEAP_REPLACEMENT
     while (heap_nodes(SD->repl.heap.heap) > 0) {
-        if (store_swap_size < store_swap_low)
-            break;
-        if (expired >= max_remove)
-            break;
-        if (scanned >= max_scan)
-            break;
-        age = heap_peepminkey(SD->repl.heap.heap);
-        e = heap_extractmin(SD->repl.heap.heap);
-        e->repl.node = NULL;         /* no longer in the heap */
-        scanned++;
-        if (storeEntryLocked(e)) {
-            /*
-             * Entry is in use ... put it in a linked list to ignore it.
-             */
-            if (!EBIT_TEST(e->flags, ENTRY_SPECIAL)) {
-                /*
-                 * If this was a "SPECIAL" do not add it back into the heap.
-                 * It will always be "SPECIAL" and therefore never removed.
-                 */
-                debug(20, 4) ("storeDiskdDirMaintain: locked url %s\n",
-                    (e->mem_obj && e->mem_obj->url) ? e->mem_obj->url : storeKeyText(e->
-key));
-                linklistPush(&locked_entries, e);
-            }
-            locked++;
-            continue;
-        } else if (storeDiskdDirCheckExpired(SD, e)) {
-            /*
-             * Note: This will not check the reference age ifdef
-             * HEAP_REPLACEMENT, but it does some other useful
-             * checks...
-             */
-            expired++;
-            debug(20, 3) ("Released store object age %f size %d refs %d key %s\n",
-                age, e->swap_file_sz, e->refcount, storeKeyText(e->key));
-            min_age = age;
-            storeRelease(e);
-        } else {
-            /*
-             * Did not expire the object so we need to add it back
-             * into the heap!
-             */
-            debug(20, 5) ("storeMaintainSwapSpace: non-expired %s\n",
-                storeKeyText(e->key));
-            linklistPush(&locked_entries, e);
-            continue;
-        }
-        if (store_swap_size < store_swap_low)
-            break;
-        else if (expired >= max_remove)
-            break;
-        else if (scanned >= max_scan)
-            break;
+	if (store_swap_size < store_swap_low)
+	    break;
+	if (expired >= max_remove)
+	    break;
+	if (scanned >= max_scan)
+	    break;
+	age = heap_peepminkey(SD->repl.heap.heap);
+	e = heap_extractmin(SD->repl.heap.heap);
+	e->repl.node = NULL;	/* no longer in the heap */
+	scanned++;
+	if (storeEntryLocked(e)) {
+	    /*
+	     * Entry is in use ... put it in a linked list to ignore it.
+	     */
+	    if (!EBIT_TEST(e->flags, ENTRY_SPECIAL)) {
+		/*
+		 * If this was a "SPECIAL" do not add it back into the heap.
+		 * It will always be "SPECIAL" and therefore never removed.
+		 */
+		debug(20, 4) ("storeDiskdDirMaintain: locked url %s\n",
+		    (e->mem_obj && e->mem_obj->url) ? e->mem_obj->url : storeKeyText(e->
+			key));
+		linklistPush(&locked_entries, e);
+	    }
+	    locked++;
+	    continue;
+	} else if (storeDiskdDirCheckExpired(SD, e)) {
+	    /*
+	     * Note: This will not check the reference age ifdef
+	     * HEAP_REPLACEMENT, but it does some other useful
+	     * checks...
+	     */
+	    expired++;
+	    debug(20, 3) ("Released store object age %f size %d refs %d key %s\n",
+		age, e->swap_file_sz, e->refcount, storeKeyText(e->key));
+	    min_age = age;
+	    storeRelease(e);
+	} else {
+	    /*
+	     * Did not expire the object so we need to add it back
+	     * into the heap!
+	     */
+	    debug(20, 5) ("storeMaintainSwapSpace: non-expired %s\n",
+		storeKeyText(e->key));
+	    linklistPush(&locked_entries, e);
+	    continue;
+	}
+	if (store_swap_size < store_swap_low)
+	    break;
+	else if (expired >= max_remove)
+	    break;
+	else if (scanned >= max_scan)
+	    break;
     }
     /*
      * Bump the heap age factor.
      */
     if (min_age > 0.0)
-        SD->repl.heap.heap->age = min_age;
+	SD->repl.heap.heap->age = min_age;
     /*
      * Reinsert all bumped locked entries back into heap...
      */
     while ((e = linklistShift(&locked_entries)))
-        e->repl.node = heap_insert(SD->repl.heap.heap, e);
+	e->repl.node = heap_insert(SD->repl.heap.heap, e);
 #else
     for (m = SD->repl.lru.list.tail; m; m = prev) {
-        prev = m->prev;
-        e = m->data;
-        scanned++;
-        if (storeEntryLocked(e)) {
-            /*
-             * If there is a locked entry at the tail of the LRU list,
-             * move it to the beginning to get it out of the way.
-             * Theoretically, we might have all locked objects at the
-             * tail, and then we'll never remove anything here and the
-             * LRU age will go to zero.
-             */
-            if (memInUse(MEM_STOREENTRY) > max_scan) {
-                dlinkDelete(&e->repl.lru, &SD->repl.lru.list);
-                dlinkAdd(e, &e->repl.lru, &SD->repl.lru.list);
-            }
-            locked++;
-
-        } else if (storeDiskdDirCheckExpired(SD, e)) {
-            expired++;
-            storeRelease(e);
-        }
-        if (expired >= max_remove)
-            break;
-        if (scanned >= max_scan)
-            break;
+	prev = m->prev;
+	e = m->data;
+	scanned++;
+	if (storeEntryLocked(e)) {
+	    /*
+	     * If there is a locked entry at the tail of the LRU list,
+	     * move it to the beginning to get it out of the way.
+	     * Theoretically, we might have all locked objects at the
+	     * tail, and then we'll never remove anything here and the
+	     * LRU age will go to zero.
+	     */
+	    if (memInUse(MEM_STOREENTRY) > max_scan) {
+		dlinkDelete(&e->repl.lru, &SD->repl.lru.list);
+		dlinkAdd(e, &e->repl.lru, &SD->repl.lru.list);
+	    }
+	    locked++;
+
+	} else if (storeDiskdDirCheckExpired(SD, e)) {
+	    expired++;
+	    storeRelease(e);
+	}
+	if (expired >= max_remove)
+	    break;
+	if (scanned >= max_scan)
+	    break;
     }
 #endif
-    debug(20, (expired ? 2 : 3)) ("storeMaintainSwapSpace: scanned %d/%d removed %d/%d l
-ocked %d f=%.03f\n",
-        scanned, max_scan, expired, max_remove, locked, f);
+    debug(20, (expired ? 2 : 3)) ("storeMaintainSwapSpace: scanned %d/%d removed %d/%d locked %d f=%.03f\n",
+	scanned, max_scan, expired, max_remove, locked, f);
     debug(20, 3) ("storeMaintainSwapSpace stats:\n");
     debug(20, 3) ("  %6d objects\n", memInUse(MEM_STOREENTRY));
     debug(20, 3) ("  %6d were scanned\n", scanned);
     debug(20, 3) ("  %6d were locked\n", locked);
     debug(20, 3) ("  %6d were expired\n", expired);
     if (store_swap_size < Config.Swap.maxSize)
-        return;
+	return;
     if (squid_curtime - last_warn_time < 10)
-        return;
+	return;
     debug(20, 0) ("WARNING: Disk space over limit: %d KB > %d KB\n",
-        store_swap_size, Config.Swap.maxSize);
+	store_swap_size, Config.Swap.maxSize);
     last_warn_time = squid_curtime;
 }
 
@@ -1566,29 +1564,29 @@ ocked %d f=%.03f\n",
  * happily store anything as long as the LRU time isn't too small.
  */
 int
-storeDiskdDirCheckObj(SwapDir *SD, const StoreEntry *e)
+storeDiskdDirCheckObj(SwapDir * SD, const StoreEntry * e)
 {
     int loadav;
 
-    diskdinfo_t *diskdinfo = (diskdinfo_t *)SD->fsdata;
+    diskdinfo_t *diskdinfo = (diskdinfo_t *) SD->fsdata;
 #if !HEAP_REPLACEMENT
     if (storeDiskdDirExpiredReferenceAge(SD) < 300) {
-        debug(20, 3) ("storeDiskdDirCheckObj: NO: LRU Age = %d\n",
-            storeDiskdDirExpiredReferenceAge(SD));
-        /* store_check_cachable_hist.no.lru_age_too_low++; */
-        return -1;
+	debug(20, 3) ("storeDiskdDirCheckObj: NO: LRU Age = %d\n",
+	    storeDiskdDirExpiredReferenceAge(SD));
+	/* store_check_cachable_hist.no.lru_age_too_low++; */
+	return -1;
     }
 #endif
 
     /* Check the queue length */
     if (diskdinfo->away >= diskdinfo->magic1)
-        return -1;
+	return -1;
 
     /* Calculate the storedir load relative to magic2 on a scale of 0 .. 1000 */
     if (diskdinfo->away == 0)
-        loadav = 0;
+	loadav = 0;
     else
-        loadav = diskdinfo->magic2 * 1000 / diskdinfo->away;
+	loadav = diskdinfo->magic2 * 1000 / diskdinfo->away;
     return loadav;
 }
 
@@ -1599,18 +1597,18 @@ storeDiskdDirCheckObj(SwapDir *SD, const StoreEntry *e)
  * maintain replacement information within the storage fs.
  */
 void
-storeDiskdDirRefObj(SwapDir *SD, StoreEntry *e)
+storeDiskdDirRefObj(SwapDir * SD, StoreEntry * e)
 {
     debug(1, 3) ("storeDiskdDirRefObj: referencing %p %d/%d\n", e, e->swap_dirn,
-      e->swap_filen);
+	e->swap_filen);
 #if HEAP_REPLACEMENT
     /* Nothing to do here */
 #else
     /* Reference the object */
     if (!EBIT_TEST(e->flags, RELEASE_REQUEST) &&
-        !EBIT_TEST(e->flags, ENTRY_SPECIAL)) {
-        dlinkDelete(&e->repl.lru, &SD->repl.lru.list);
-        dlinkAdd(e, &e->repl.lru, &SD->repl.lru.list);
+	!EBIT_TEST(e->flags, ENTRY_SPECIAL)) {
+	dlinkDelete(&e->repl.lru, &SD->repl.lru.list);
+	dlinkAdd(e, &e->repl.lru, &SD->repl.lru.list);
     }
 #endif
 }
@@ -1621,13 +1619,13 @@ storeDiskdDirRefObj(SwapDir *SD, StoreEntry *e)
  * removed, to maintain replacement information within the storage fs.
  */
 void
-storeDiskdDirUnrefObj(SwapDir *SD, StoreEntry *e)
+storeDiskdDirUnrefObj(SwapDir * SD, StoreEntry * e)
 {
     debug(1, 3) ("storeDiskdDirUnrefObj: referencing %p %d/%d\n", e,
-      e->swap_dirn, e->swap_filen);
+	e->swap_dirn, e->swap_filen);
 #if HEAP_REPLACEMENT
     if (e->repl.node)
-        heap_update(SD->repl.heap.heap, e->repl.node, e);
+	heap_update(SD->repl.heap.heap, e->repl.node, e);
 #endif
 }
 
@@ -1639,7 +1637,7 @@ storeDiskdDirUnrefObj(SwapDir *SD, StoreEntry *e)
  * uses storeDiskdUnlink() ..
  */
 void
-storeDiskdDirUnlinkFile(SwapDir *SD, sfileno f)
+storeDiskdDirUnlinkFile(SwapDir * SD, sfileno f)
 {
     debug(79, 3) ("storeDiskdDirUnlinkFile: unlinking fileno %08X\n", f);
     storeDiskdDirMapBitReset(SD, f);
@@ -1659,28 +1657,28 @@ storeDiskdDirUnlinkFile(SwapDir *SD, sfileno f)
  * cachemgr 'info' page.
  */
 static time_t
-storeDiskdDirExpiredReferenceAge(SwapDir *SD)
+storeDiskdDirExpiredReferenceAge(SwapDir * SD)
 {
     double x;
     double z;
     time_t age;
     long store_high, store_low;
- 
+
     store_high = (long) (((float) SD->max_size *
-            (float) Config.Swap.highWaterMark) / (float) 100);
+	    (float) Config.Swap.highWaterMark) / (float) 100);
     store_low = (long) (((float) SD->max_size *
-            (float) Config.Swap.lowWaterMark) / (float) 100);
+	    (float) Config.Swap.lowWaterMark) / (float) 100);
     debug(20, 20) ("RA: Dir %s, hi=%d, lo=%d, cur=%d\n", SD->path, store_high, store_low, SD->cur_size);
-  
+
     x = (double) (store_high - SD->cur_size) /
-        (store_high - store_low);
+	(store_high - store_low);
     x = x < 0.0 ? 0.0 : x > 1.0 ? 1.0 : x;
     z = pow((double) (Config.referenceAge / 60), x);
     age = (time_t) (z * 60.0);
     if (age < 60)
-        age = 60;
+	age = 60;
     else if (age > Config.referenceAge)
-        age = Config.referenceAge;
+	age = Config.referenceAge;
     return age;
 }
 #endif
@@ -1694,14 +1692,14 @@ storeDiskdDirExpiredReferenceAge(SwapDir *SD)
  * right now.
  */
 static int
-storeDiskdDirCheckExpired(SwapDir *SD, StoreEntry *e)
+storeDiskdDirCheckExpired(SwapDir * SD, StoreEntry * e)
 {
     if (storeEntryLocked(e))
-       return 0;
+	return 0;
     if (EBIT_TEST(e->flags, RELEASE_REQUEST))
-       return 1;
+	return 1;
     if (EBIT_TEST(e->flags, ENTRY_NEGCACHED) && squid_curtime >= e->expires)
-       return 1;
+	return 1;
 
 #if HEAP_REPLACEMENT
     /*
@@ -1711,7 +1709,7 @@ storeDiskdDirCheckExpired(SwapDir *SD, StoreEntry *e)
     return 1;
 #else
     if (squid_curtime - e->lastref > storeDiskdDirExpiredReferenceAge(SD))
-       return 1;
+	return 1;
     return 0;
 #endif
 }
@@ -1722,16 +1720,16 @@ storeDiskdDirCheckExpired(SwapDir *SD, StoreEntry *e)
  */
 
 void
-storeDiskdDirReplAdd(SwapDir *SD, StoreEntry *e)
+storeDiskdDirReplAdd(SwapDir * SD, StoreEntry * e)
 {
     debug(20, 4) ("storeDiskdDirReplAdd: added node %p to dir %d\n", e,
-      SD->index);
+	SD->index);
 #if HEAP_REPLACEMENT
     if (EBIT_TEST(e->flags, ENTRY_SPECIAL)) {
-        (void) 0;
+	(void) 0;
     } else {
-        e->repl.node = heap_insert(SD->repl.heap.heap, e);
-        debug(20, 4) ("storeDiskdDirReplAdd: inserted node 0x%x\n", e->repl.node);
+	e->repl.node = heap_insert(SD->repl.heap.heap, e);
+	debug(20, 4) ("storeDiskdDirReplAdd: inserted node 0x%x\n", e->repl.node);
     }
 #else
     /* Shouldn't we not throw special objects into the lru ? */
@@ -1741,18 +1739,18 @@ storeDiskdDirReplAdd(SwapDir *SD, StoreEntry *e)
 
 
 void
-storeDiskdDirReplRemove(StoreEntry *e)
+storeDiskdDirReplRemove(StoreEntry * e)
 {
     SwapDir *SD = INDEXSD(e->swap_dirn);
     debug(20, 4) ("storeDiskdDirReplRemove: remove node %p from dir %d\n", e,
-      SD->index);
+	SD->index);
 #if HEAP_REPLACEMENT
     /* And now, release the object from the replacement policy */
     if (e->repl.node) {
-        debug(20, 4) ("storeDiskdDirReplRemove: deleting node 0x%x\n",
-          e->repl.node);
-        heap_delete(SD->repl.heap.heap, e->repl.node);
-        e->repl.node = NULL;
+	debug(20, 4) ("storeDiskdDirReplRemove: deleting node 0x%x\n",
+	    e->repl.node);
+	heap_delete(SD->repl.heap.heap, e->repl.node);
+	e->repl.node = NULL;
     }
 #else
     dlinkDelete(&e->repl.lru, &SD->repl.lru.list);
@@ -1769,7 +1767,7 @@ void *
 storeDiskdShmGet(SwapDir * sd, int *shm_offset)
 {
     char *buf;
-    diskdinfo_t *diskdinfo = (diskdinfo_t *)sd->fsdata;
+    diskdinfo_t *diskdinfo = (diskdinfo_t *) sd->fsdata;
     buf = linklistShift(&diskdinfo->shm.stack);
     assert(buf);
     *shm_offset = buf - diskdinfo->shm.buf;
@@ -1782,7 +1780,7 @@ void
 storeDiskdShmPut(SwapDir * sd, int offset)
 {
     char *buf;
-    diskdinfo_t *diskdinfo = (diskdinfo_t *)sd->fsdata;
+    diskdinfo_t *diskdinfo = (diskdinfo_t *) sd->fsdata;
     assert(offset >= 0);
     assert(offset < SHMBUFS * SHMBUF_BLKSZ);
     buf = diskdinfo->shm.buf + offset;
@@ -1796,49 +1794,49 @@ storeDiskdShmPut(SwapDir * sd, int offset)
 /* ========== LOCAL FUNCTIONS ABOVE, GLOBAL FUNCTIONS BELOW ========== */
 
 void
-storeDiskdDirStats(SwapDir *SD, StoreEntry * sentry)
+storeDiskdDirStats(SwapDir * SD, StoreEntry * sentry)
 {
     diskdinfo_t *diskdinfo;
 #if HAVE_STATVFS
     struct statvfs sfs;
 #endif
-    diskdinfo = (diskdinfo_t *)SD->fsdata;
+    diskdinfo = (diskdinfo_t *) SD->fsdata;
     storeAppendPrintf(sentry, "First level subdirectories: %d\n", diskdinfo->l1);
     storeAppendPrintf(sentry, "Second level subdirectories: %d\n", diskdinfo->l2);
     storeAppendPrintf(sentry, "Maximum Size: %d KB\n", SD->max_size);
     storeAppendPrintf(sentry, "Current Size: %d KB\n", SD->cur_size);
     storeAppendPrintf(sentry, "Percent Used: %0.2f%%\n",
-        100.0 * SD->cur_size / SD->max_size);
+	100.0 * SD->cur_size / SD->max_size);
     storeAppendPrintf(sentry, "Filemap bits in use: %d of %d (%d%%)\n",
-    diskdinfo->map->n_files_in_map, diskdinfo->map->max_n_files,
-    percent(diskdinfo->map->n_files_in_map, diskdinfo->map->max_n_files));
+	diskdinfo->map->n_files_in_map, diskdinfo->map->max_n_files,
+	percent(diskdinfo->map->n_files_in_map, diskdinfo->map->max_n_files));
 #if HAVE_STATVFS
 #define fsbtoblk(num, fsbs, bs) \
     (((fsbs) != 0 && (fsbs) < (bs)) ? \
             (num) / ((bs) / (fsbs)) : (num) * ((fsbs) / (bs)))
-	if (!statvfs(SD->path, &sfs)) {
-            storeAppendPrintf(sentry, "Filesystem Space in use: %d/%d KB (%d%%)\n",
-            fsbtoblk((sfs.f_blocks - sfs.f_bfree), sfs.f_frsize, 1024),
-            fsbtoblk(sfs.f_blocks, sfs.f_frsize, 1024),
-            percent(sfs.f_blocks - sfs.f_bfree, sfs.f_blocks));
-            storeAppendPrintf(sentry, "Filesystem Inodes in use: %d/%d (%d%%)\n",
-            sfs.f_files - sfs.f_ffree, sfs.f_files,
-            percent(sfs.f_files - sfs.f_ffree, sfs.f_files));
+    if (!statvfs(SD->path, &sfs)) {
+	storeAppendPrintf(sentry, "Filesystem Space in use: %d/%d KB (%d%%)\n",
+	    fsbtoblk((sfs.f_blocks - sfs.f_bfree), sfs.f_frsize, 1024),
+	    fsbtoblk(sfs.f_blocks, sfs.f_frsize, 1024),
+	    percent(sfs.f_blocks - sfs.f_bfree, sfs.f_blocks));
+	storeAppendPrintf(sentry, "Filesystem Inodes in use: %d/%d (%d%%)\n",
+	    sfs.f_files - sfs.f_ffree, sfs.f_files,
+	    percent(sfs.f_files - sfs.f_ffree, sfs.f_files));
     }
 #endif
     storeAppendPrintf(sentry, "Flags:");
     if (SD->flags.selected)
-        storeAppendPrintf(sentry, " SELECTED");
+	storeAppendPrintf(sentry, " SELECTED");
     if (SD->flags.read_only)
-        storeAppendPrintf(sentry, " READ-ONLY");
+	storeAppendPrintf(sentry, " READ-ONLY");
     storeAppendPrintf(sentry, "\n");
 #if !HEAP_REPLACEMENT
     storeAppendPrintf(sentry, "LRU Expiration Age: %6.2f days\n",
-      (double) storeDiskdDirExpiredReferenceAge(SD) / 86400.0); 
+	(double) storeDiskdDirExpiredReferenceAge(SD) / 86400.0);
 #else
 #if 0
     storeAppendPrintf(sentry, "Storage Replacement Threshold:\t%f\n",
-        heap_peepminkey(sd.repl.heap.heap));
+	heap_peepminkey(sd.repl.heap.heap));
 #endif
 #endif
     storeAppendPrintf(sentry, "Pending operations: %d\n", diskdinfo->away);
@@ -1850,7 +1848,7 @@ storeDiskdDirStats(SwapDir *SD, StoreEntry * sentry)
  * This routine is called when the given swapdir needs reconfiguring 
  */
 void
-storeDiskdDirReconfigure(SwapDir *sd, int index, char *path)
+storeDiskdDirReconfigure(SwapDir * sd, int index, char *path)
 {
     char *token;
     int i;
@@ -1896,7 +1894,7 @@ storeDiskdDirReconfigure(SwapDir *sd, int index, char *path)
     if (sd->flags.read_only != read_only)
 	debug(3, 1) ("Cache dir '%s' now %s\n",
 	    path, read_only ? "Read-Only" : "Read-Write");
-    diskdinfo = (diskdinfo_t *)sd->fsdata;
+    diskdinfo = (diskdinfo_t *) sd->fsdata;
     diskdinfo->magic1 = magic1;
     diskdinfo->magic2 = magic2;
     sd->flags.read_only = read_only;
@@ -1906,10 +1904,10 @@ storeDiskdDirReconfigure(SwapDir *sd, int index, char *path)
 void
 storeDiskdDirDump(StoreEntry * entry, const char *name, SwapDir * s)
 {
-    diskdinfo_t *diskdinfo = (diskdinfo_t *)s->fsdata;
+    diskdinfo_t *diskdinfo = (diskdinfo_t *) s->fsdata;
     storeAppendPrintf(entry, "%s %s %s %d %d %d\n",
 	name,
-        "diskd",
+	"diskd",
 	s->path,
 	s->max_size >> 10,
 	diskdinfo->l1,
@@ -1922,22 +1920,22 @@ storeDiskdDirDump(StoreEntry * entry, const char *name, SwapDir * s)
 static void
 storeDiskdDirFree(SwapDir * s)
 {
-    diskdinfo_t *diskdinfo = (diskdinfo_t *)s->fsdata;
+    diskdinfo_t *diskdinfo = (diskdinfo_t *) s->fsdata;
     if (diskdinfo->swaplog_fd > -1) {
 	file_close(diskdinfo->swaplog_fd);
 	diskdinfo->swaplog_fd = -1;
     }
     filemapFreeMemory(diskdinfo->map);
     xfree(diskdinfo);
-    s->fsdata = NULL; /* Will aid debugging... */
+    s->fsdata = NULL;		/* Will aid debugging... */
 
 }
 
 char *
-storeDiskdDirFullPath(SwapDir *SD, sfileno filn, char *fullpath)
+storeDiskdDirFullPath(SwapDir * SD, sfileno filn, char *fullpath)
 {
     LOCAL_ARRAY(char, fullfilename, SQUID_MAXPATHLEN);
-    diskdinfo_t *diskdinfo = (diskdinfo_t *)SD->fsdata;
+    diskdinfo_t *diskdinfo = (diskdinfo_t *) SD->fsdata;
     int L1 = diskdinfo->l1;
     int L2 = diskdinfo->l2;
     if (!fullpath)
@@ -1957,28 +1955,28 @@ storeDiskdDirFullPath(SwapDir *SD, sfileno filn, char *fullpath)
  * This is called by storeCleanup() if -S was given on the command line.
  */
 static int
-storeDiskdCleanupDoubleCheck(SwapDir *sd, StoreEntry *e)
+storeDiskdCleanupDoubleCheck(SwapDir * sd, StoreEntry * e)
 {
     struct stat sb;
 
     if (stat(storeDiskdDirFullPath(sd, e->swap_filen, NULL), &sb) < 0) {
-        debug(20, 0) ("storeDiskdCleanupDoubleCheck: MISSING SWAP FILE\n");
-        debug(20, 0) ("storeDiskdCleanupDoubleCheck: FILENO %08X\n", e->swap_filen);
-        debug(20, 0) ("storeDiskdCleanupDoubleCheck: PATH %s\n",
-            storeDiskdDirFullPath(sd, e->swap_filen, NULL));
-        storeEntryDump(e, 0);
-        return -1;
-    }       
+	debug(20, 0) ("storeDiskdCleanupDoubleCheck: MISSING SWAP FILE\n");
+	debug(20, 0) ("storeDiskdCleanupDoubleCheck: FILENO %08X\n", e->swap_filen);
+	debug(20, 0) ("storeDiskdCleanupDoubleCheck: PATH %s\n",
+	    storeDiskdDirFullPath(sd, e->swap_filen, NULL));
+	storeEntryDump(e, 0);
+	return -1;
+    }
     if (e->swap_file_sz != sb.st_size) {
-        debug(20, 0) ("storeDiskdCleanupDoubleCheck: SIZE MISMATCH\n");
-        debug(20, 0) ("storeDiskdCleanupDoubleCheck: FILENO %08X\n", e->swap_filen);
-        debug(20, 0) ("storeDiskdCleanupDoubleCheck: PATH %s\n",
-            storeDiskdDirFullPath(sd, e->swap_filen, NULL));
-        debug(20, 0) ("storeDiskdCleanupDoubleCheck: ENTRY SIZE: %d, FILE SIZE: %d\n",
-            e->swap_file_sz, (int) sb.st_size); 
-        storeEntryDump(e, 0); 
-        return -1;
-    }       
+	debug(20, 0) ("storeDiskdCleanupDoubleCheck: SIZE MISMATCH\n");
+	debug(20, 0) ("storeDiskdCleanupDoubleCheck: FILENO %08X\n", e->swap_filen);
+	debug(20, 0) ("storeDiskdCleanupDoubleCheck: PATH %s\n",
+	    storeDiskdDirFullPath(sd, e->swap_filen, NULL));
+	debug(20, 0) ("storeDiskdCleanupDoubleCheck: ENTRY SIZE: %d, FILE SIZE: %d\n",
+	    e->swap_file_sz, (int) sb.st_size);
+	storeEntryDump(e, 0);
+	return -1;
+    }
     return 0;
 }
 
@@ -1988,7 +1986,7 @@ storeDiskdCleanupDoubleCheck(SwapDir *sd, StoreEntry *e)
  * Called when a *new* fs is being setup.
  */
 void
-storeDiskdDirParse(SwapDir *sd, int index, char *path)
+storeDiskdDirParse(SwapDir * sd, int index, char *path)
 {
     char *token;
     int i;
@@ -2027,7 +2025,7 @@ storeDiskdDirParse(SwapDir *sd, int index, char *path)
 
     diskdinfo = xmalloc(sizeof(diskdinfo_t));
     if (diskdinfo == NULL)
-        fatal("storeDiskdDirParse: couldn't xmalloc() diskdinfo_t!\n");
+	fatal("storeDiskdDirParse: couldn't xmalloc() diskdinfo_t!\n");
 
     sd->index = index;
     sd->path = xstrdup(path);
@@ -2036,7 +2034,7 @@ storeDiskdDirParse(SwapDir *sd, int index, char *path)
     diskdinfo->l1 = l1;
     diskdinfo->l2 = l2;
     diskdinfo->swaplog_fd = -1;
-    diskdinfo->map = NULL; /* Debugging purposes */
+    diskdinfo->map = NULL;	/* Debugging purposes */
     diskdinfo->suggest = 0;
     diskdinfo->magic1 = magic1;
     diskdinfo->magic2 = magic2;
@@ -2074,24 +2072,24 @@ storeDiskdDirParse(SwapDir *sd, int index, char *path)
      * always uses GDSF since we want to maximize object hit rate.
      */
     if (Config.replPolicy) {
-        if (tolower(Config.replPolicy[0]) == 'g') {
-            debug(20, 1) ("Using GDSF disk replacement policy\n");
-            sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_GDSF);
-        } else if (tolower(Config.replPolicy[0]) == 'l') {
-            if (tolower(Config.replPolicy[1]) == 'f') {
-                debug(20, 1) ("Using LFUDA disk replacement policy\n");
-                sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_LFUDA);
-            } else if (tolower(Config.replPolicy[1]) == 'r') {
-                debug(20, 1) ("Using LRU heap disk replacement policy\n");
-                sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_LRU);
-            }
-        } else {
-            debug(20, 1) ("Unrecognized replacement_policy; using GDSF\n");
-            sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_GDSF);
-        }
+	if (tolower(Config.replPolicy[0]) == 'g') {
+	    debug(20, 1) ("Using GDSF disk replacement policy\n");
+	    sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_GDSF);
+	} else if (tolower(Config.replPolicy[0]) == 'l') {
+	    if (tolower(Config.replPolicy[1]) == 'f') {
+		debug(20, 1) ("Using LFUDA disk replacement policy\n");
+		sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_LFUDA);
+	    } else if (tolower(Config.replPolicy[1]) == 'r') {
+		debug(20, 1) ("Using LRU heap disk replacement policy\n");
+		sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_LRU);
+	    }
+	} else {
+	    debug(20, 1) ("Unrecognized replacement_policy; using GDSF\n");
+	    sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_GDSF);
+	}
     } else {
-        debug(20, 1) ("Using default disk replacement policy (GDSF)\n");
-        sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_GDSF);
+	debug(20, 1) ("Using default disk replacement policy (GDSF)\n");
+	sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_GDSF);
     }
 #else
     sd->repl.lru.list.head = NULL;
@@ -2110,7 +2108,7 @@ storeDiskdDirDone(void)
 }
 
 void
-storeFsSetup_diskd(storefs_entry_t *storefs)
+storeFsSetup_diskd(storefs_entry_t * storefs)
 {
     assert(!diskd_initialised);
     storefs->parsefunc = storeDiskdDirParse;
@@ -2122,4 +2120,3 @@ storeFsSetup_diskd(storefs_entry_t *storefs)
     debug(81, 1) ("diskd started\n");
     diskd_initialised = 1;
 }
-
@@ -82,17 +82,17 @@ typedef struct _diskdstate_t diskdstate_t;
 static const int msg_snd_rcv_sz = sizeof(diomsg) - sizeof(mtyp_t);
 
 /* The diskd_state memory pool */
-extern MemPool * diskd_state_pool;
+extern MemPool *diskd_state_pool;
 
 extern void storeDiskdDirMapBitReset(SwapDir *, sfileno);
 extern int storeDiskdDirMapBitAllocate(SwapDir *);
-extern char * storeDiskdDirFullPath(SwapDir *SD, sfileno filn, char *fullpath);
+extern char *storeDiskdDirFullPath(SwapDir * SD, sfileno filn, char *fullpath);
 extern void storeDiskdDirUnlinkFile(SwapDir *, sfileno);
 extern void storeDiskdDirReplAdd(SwapDir *, StoreEntry *);
 extern void storeDiskdDirReplRemove(StoreEntry *);
 extern void storeDiskdShmPut(SwapDir *, int);
 extern void *storeDiskdShmGet(SwapDir *, int *);
-extern void storeDiskdHandle(diomsg *M);
+extern void storeDiskdHandle(diomsg * M);
 
 
 /*
@@ -31,8 +31,8 @@ static void storeDiskdIOFreeEntry(void *sio, int foo);
 /* === PUBLIC =========================================================== */
 
 storeIOState *
-storeDiskdOpen(SwapDir *SD, StoreEntry *e, STFNCB *file_callback,
-  STIOCB *callback, void *callback_data)
+storeDiskdOpen(SwapDir * SD, StoreEntry * e, STFNCB * file_callback,
+    STIOCB * callback, void *callback_data)
 {
     sfileno f = e->swap_filen;
     int x;
@@ -46,7 +46,7 @@ storeDiskdOpen(SwapDir *SD, StoreEntry *e, STFNCB *file_callback,
      * If there are too many requests queued.
      */
     if (diskdinfo->away > diskdinfo->magic1) {
-        debug(81, 3) ("storeDiskdOpen: FAILING, too many requests away\n");
+	debug(81, 3) ("storeDiskdOpen: FAILING, too many requests away\n");
 	diskd_stats.open_fail_queue_len++;
 	return NULL;
     }
@@ -62,17 +62,17 @@ storeDiskdOpen(SwapDir *SD, StoreEntry *e, STFNCB *file_callback,
     sio->e = e;
     cbdataLock(callback_data);
 
-    ((diskdstate_t *)(sio->fsstate))->flags.writing = 0;
-    ((diskdstate_t *)(sio->fsstate))->flags.reading = 0;
-    ((diskdstate_t *)(sio->fsstate))->flags.close_request = 0;
-    ((diskdstate_t *)(sio->fsstate))->id = diskd_stats.sio_id++;
+    ((diskdstate_t *) (sio->fsstate))->flags.writing = 0;
+    ((diskdstate_t *) (sio->fsstate))->flags.reading = 0;
+    ((diskdstate_t *) (sio->fsstate))->flags.close_request = 0;
+    ((diskdstate_t *) (sio->fsstate))->id = diskd_stats.sio_id++;
 
     buf = storeDiskdShmGet(SD, &shm_offset);
     /* XXX WRONG!!! :) */
     strcpy(buf, storeDiskdDirFullPath(SD, f, NULL));
     x = storeDiskdSend(_MQD_OPEN,
 	SD,
-	((diskdstate_t *)(sio->fsstate))->id,
+	((diskdstate_t *) (sio->fsstate))->id,
 	sio,
 	strlen(buf) + 1,
 	O_RDONLY,
@@ -88,8 +88,8 @@ storeDiskdOpen(SwapDir *SD, StoreEntry *e, STFNCB *file_callback,
 }
 
 storeIOState *
-storeDiskdCreate(SwapDir *SD, StoreEntry *e, STFNCB *file_callback,
-  STIOCB *callback, void *callback_data)
+storeDiskdCreate(SwapDir * SD, StoreEntry * e, STFNCB * file_callback,
+    STIOCB * callback, void *callback_data)
 {
     sfileno f;
     int x;
@@ -105,7 +105,6 @@ storeDiskdCreate(SwapDir *SD, StoreEntry *e, STFNCB *file_callback,
 	diskd_stats.open_fail_queue_len++;
 	return NULL;
     }
-
     /* Allocate a number */
     f = storeDiskdDirMapBitAllocate(SD);
     debug(81, 3) ("storeDiskdCreate: fileno %08X\n", f);
@@ -122,17 +121,17 @@ storeDiskdCreate(SwapDir *SD, StoreEntry *e, STFNCB *file_callback,
     sio->e = e;
     cbdataLock(callback_data);
 
-    ((diskdstate_t *)(sio->fsstate))->flags.writing = 0;
-    ((diskdstate_t *)(sio->fsstate))->flags.reading = 0;
-    ((diskdstate_t *)(sio->fsstate))->flags.close_request = 0;
-    ((diskdstate_t *)(sio->fsstate))->id = diskd_stats.sio_id++;
+    ((diskdstate_t *) (sio->fsstate))->flags.writing = 0;
+    ((diskdstate_t *) (sio->fsstate))->flags.reading = 0;
+    ((diskdstate_t *) (sio->fsstate))->flags.close_request = 0;
+    ((diskdstate_t *) (sio->fsstate))->id = diskd_stats.sio_id++;
 
     buf = storeDiskdShmGet(SD, &shm_offset);
     /* XXX WRONG!!! :) */
     strcpy(buf, storeDiskdDirFullPath(SD, f, NULL));
     x = storeDiskdSend(_MQD_OPEN,
 	SD,
-	((diskdstate_t *)(sio->fsstate))->id,
+	((diskdstate_t *) (sio->fsstate))->id,
 	sio,
 	strlen(buf) + 1,
 	sio->mode,
@@ -150,12 +149,12 @@ storeDiskdCreate(SwapDir *SD, StoreEntry *e, STFNCB *file_callback,
 
 
 void
-storeDiskdClose(SwapDir *SD, storeIOState * sio)
+storeDiskdClose(SwapDir * SD, storeIOState * sio)
 {
     int x;
-    diskdstate_t *diskdstate = (diskdstate_t *)sio->fsstate;
+    diskdstate_t *diskdstate = (diskdstate_t *) sio->fsstate;
     debug(81, 3) ("storeDiskdClose: dirno %d, fileno %08X\n", SD->index,
-      sio->swap_filen);
+	sio->swap_filen);
     x = storeDiskdSend(_MQD_CLOSE,
 	SD,
 	diskdstate->id,
@@ -170,12 +169,12 @@ storeDiskdClose(SwapDir *SD, storeIOState * sio)
 }
 
 void
-storeDiskdRead(SwapDir *SD, storeIOState * sio, char *buf, size_t size, off_t offset, STRCB * callback, void *callback_data)
+storeDiskdRead(SwapDir * SD, storeIOState * sio, char *buf, size_t size, off_t offset, STRCB * callback, void *callback_data)
 {
     int x;
     int shm_offset;
     char *rbuf;
-    diskdstate_t *diskdstate = (diskdstate_t *)sio->fsstate;
+    diskdstate_t *diskdstate = (diskdstate_t *) sio->fsstate;
     if (!cbdataValid(sio))
 	return;
     if (diskdstate->flags.reading) {
@@ -208,12 +207,12 @@ storeDiskdRead(SwapDir *SD, storeIOState * sio, char *buf, size_t size, off_t of
 }
 
 void
-storeDiskdWrite(SwapDir *SD, storeIOState * sio, char *buf, size_t size, off_t offset, FREE * free_func)
+storeDiskdWrite(SwapDir * SD, storeIOState * sio, char *buf, size_t size, off_t offset, FREE * free_func)
 {
     int x;
     char *sbuf;
     int shm_offset;
-    diskdstate_t *diskdstate = (diskdstate_t *)sio->fsstate;
+    diskdstate_t *diskdstate = (diskdstate_t *) sio->fsstate;
     debug(81, 3) ("storeDiskdWrite: dirno %d, fileno %08X\n", SD->index, sio->swap_filen);
     if (!cbdataValid(sio)) {
 	free_func(buf);
@@ -223,7 +222,7 @@ storeDiskdWrite(SwapDir *SD, storeIOState * sio, char *buf, size_t size, off_t o
     sbuf = storeDiskdShmGet(SD, &shm_offset);
     xmemcpy(sbuf, buf, size);
     if (free_func)
-        free_func(buf);
+	free_func(buf);
     x = storeDiskdSend(_MQD_WRITE,
 	SD,
 	diskdstate->id,
@@ -239,24 +238,23 @@ storeDiskdWrite(SwapDir *SD, storeIOState * sio, char *buf, size_t size, off_t o
 }
 
 void
-storeDiskdUnlink(SwapDir *SD, StoreEntry *e)
+storeDiskdUnlink(SwapDir * SD, StoreEntry * e)
 {
     int x;
     int shm_offset;
     char *buf;
-    diskdinfo_t *diskdinfo = (diskdinfo_t *)SD->fsdata;
+    diskdinfo_t *diskdinfo = (diskdinfo_t *) SD->fsdata;
 
     debug(81, 3) ("storeDiskdUnlink: dirno %d, fileno %08X\n", SD->index,
-      e->swap_filen);
+	e->swap_filen);
     storeDiskdDirReplRemove(e);
     storeDiskdDirMapBitReset(SD, e->swap_filen);
     if (diskdinfo->away >= diskdinfo->magic1) {
-        /* Damn, we need to issue a sync unlink here :( */
-        debug(50, 2) ("storeDiskUnlink: Out of queue space, sync unlink\n");
-        storeDiskdDirUnlinkFile(SD, e->swap_filen);
-        return;
+	/* Damn, we need to issue a sync unlink here :( */
+	debug(50, 2) ("storeDiskUnlink: Out of queue space, sync unlink\n");
+	storeDiskdDirUnlinkFile(SD, e->swap_filen);
+	return;
     }
-
     /* We can attempt a diskd unlink */
     buf = storeDiskdShmGet(SD, &shm_offset);
     strcpy(buf, storeDiskdDirFullPath(SD, e->swap_filen, NULL));
@@ -269,7 +267,7 @@ storeDiskdUnlink(SwapDir *SD, StoreEntry *e)
 	shm_offset);
     if (x < 0) {
 	debug(50, 1) ("storeDiskdSend UNLINK: %s\n", xstrerror());
-	unlink(buf); /* XXX EWW! */
+	unlink(buf);		/* XXX EWW! */
 	storeDiskdShmPut(SD, shm_offset);
     }
 }
@@ -342,7 +340,7 @@ static void
 storeDiskdWriteDone(diomsg * M)
 {
     storeIOState *sio = M->callback_data;
-    diskdstate_t *diskdstate = (diskdstate_t *)sio->fsstate;
+    diskdstate_t *diskdstate = (diskdstate_t *) sio->fsstate;
     Counter.syscalls.disk.writes++;
     diskdstate->flags.writing = 0;
     debug(81, 3) ("storeDiskdWriteDone: dirno %d, fileno %08x status %d\n",
@@ -423,7 +421,7 @@ storeDiskdSend(int mtype, SwapDir * sd, int id, storeIOState * sio, int size, in
     static int send_errors = 0;
     static int last_seq_no = 0;
     static int seq_no = 0;
-    diskdinfo_t *diskdinfo = (diskdinfo_t *)sd->fsdata;
+    diskdinfo_t *diskdinfo = (diskdinfo_t *) sd->fsdata;
     M.mtype = mtype;
     M.callback_data = sio;
     M.size = size;
@@ -458,7 +456,6 @@ storeDiskdSend(int mtype, SwapDir * sd, int id, storeIOState * sio, int size, in
 static void
 storeDiskdIOFreeEntry(void *sio, int foo)
 {
-    memPoolFree(diskd_state_pool, ((storeIOState *)sio)->fsstate);
+    memPoolFree(diskd_state_pool, ((storeIOState *) sio)->fsstate);
     memFree(sio, MEM_STORE_IO);
 }
-
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_dir_ufs.cc,v 1.1 2000/05/03 17:15:47 adrian Exp $
+ * $Id: store_dir_ufs.cc,v 1.2 2000/05/12 00:29:20 wessels Exp $
  *
  * DEBUG: section 47    Store Directory Routines
  * AUTHOR: Duane Wessels
@@ -71,7 +71,7 @@ struct _RebuildState {
 
 static int n_ufs_dirs = 0;
 static int *ufs_dir_index = NULL;
-MemPool * ufs_state_pool = NULL;
+MemPool *ufs_state_pool = NULL;
 static int ufs_initialised = 0;
 
 static char *storeUfsDirSwapSubDir(SwapDir *, int subdirn);
@@ -83,7 +83,7 @@ static char *storeUfsDirSwapLogFile(SwapDir *, const char *);
 static EVH storeUfsDirRebuildFromDirectory;
 static EVH storeUfsDirRebuildFromSwapLog;
 static int storeUfsDirGetNextFile(RebuildState *, int *sfileno, int *size);
-static StoreEntry *storeUfsDirAddDiskRestore(SwapDir *SD, const cache_key * key,
+static StoreEntry *storeUfsDirAddDiskRestore(SwapDir * SD, const cache_key * key,
     int file_number,
     size_t swap_file_sz,
     time_t expires,
@@ -132,68 +132,68 @@ static time_t storeUfsDirExpiredReferenceAge(SwapDir *);
  */
 
 int
-storeUfsDirMapBitTest(SwapDir *SD, int fn)
+storeUfsDirMapBitTest(SwapDir * SD, int fn)
 {
     sfileno filn = fn;
     ufsinfo_t *ufsinfo;
-    ufsinfo = (ufsinfo_t *)SD->fsdata;
+    ufsinfo = (ufsinfo_t *) SD->fsdata;
     return file_map_bit_test(ufsinfo->map, filn);
 }
- 
+
 void
-storeUfsDirMapBitSet(SwapDir *SD, int fn)
-{  
+storeUfsDirMapBitSet(SwapDir * SD, int fn)
+{
     sfileno filn = fn;
     ufsinfo_t *ufsinfo;
-    ufsinfo = (ufsinfo_t *)SD->fsdata;
+    ufsinfo = (ufsinfo_t *) SD->fsdata;
     file_map_bit_set(ufsinfo->map, filn);
 }
- 
+
 void
-storeUfsDirMapBitReset(SwapDir *SD, int fn)
-{ 
+storeUfsDirMapBitReset(SwapDir * SD, int fn)
+{
     sfileno filn = fn;
     ufsinfo_t *ufsinfo;
-    ufsinfo = (ufsinfo_t *)SD->fsdata;
+    ufsinfo = (ufsinfo_t *) SD->fsdata;
     file_map_bit_reset(ufsinfo->map, filn);
 }
 
 int
-storeUfsDirMapBitAllocate(SwapDir *SD)
+storeUfsDirMapBitAllocate(SwapDir * SD)
 {
-    ufsinfo_t *ufsinfo = (ufsinfo_t *)SD->fsdata;
+    ufsinfo_t *ufsinfo = (ufsinfo_t *) SD->fsdata;
     int fn;
     fn = file_map_allocate(ufsinfo->map, ufsinfo->suggest);
     file_map_bit_set(ufsinfo->map, fn);
     ufsinfo->suggest = fn + 1;
     return fn;
 }
-    
+
 /*
  * Initialise the ufs bitmap
  *
  * If there already is a bitmap, and the numobjects is larger than currently
  * configured, we allocate a new bitmap and 'grow' the old one into it.
  */
 static void
-storeUfsDirInitBitmap(SwapDir *sd)
+storeUfsDirInitBitmap(SwapDir * sd)
 {
-    ufsinfo_t *ufsinfo = (ufsinfo_t *)sd->fsdata;
+    ufsinfo_t *ufsinfo = (ufsinfo_t *) sd->fsdata;
 
     if (ufsinfo->map == NULL) {
-        /* First time */
+	/* First time */
 	ufsinfo->map = file_map_create();
     } else if (ufsinfo->map->max_n_files) {
-        /* it grew, need to expand */
-        /* XXX We don't need it anymore .. */
+	/* it grew, need to expand */
+	/* XXX We don't need it anymore .. */
     }
     /* else it shrunk, and we leave the old one in place */
 }
 
 static char *
 storeUfsDirSwapSubDir(SwapDir * sd, int subdirn)
 {
-    ufsinfo_t *ufsinfo = (ufsinfo_t *)sd->fsdata;
+    ufsinfo_t *ufsinfo = (ufsinfo_t *) sd->fsdata;
 
     LOCAL_ARRAY(char, fullfilename, SQUID_MAXPATHLEN);
     assert(0 <= subdirn && subdirn < ufsinfo->l1);
@@ -246,7 +246,7 @@ storeUfsDirVerifyDirectory(const char *path)
 static int
 storeUfsDirVerifyCacheDirs(SwapDir * sd)
 {
-    ufsinfo_t *ufsinfo = (ufsinfo_t *)sd->fsdata;
+    ufsinfo_t *ufsinfo = (ufsinfo_t *) sd->fsdata;
     int j;
     const char *path = sd->path;
 
@@ -263,7 +263,7 @@ storeUfsDirVerifyCacheDirs(SwapDir * sd)
 static void
 storeUfsDirCreateSwapSubDirs(SwapDir * sd)
 {
-    ufsinfo_t *ufsinfo = (ufsinfo_t *)sd->fsdata;
+    ufsinfo_t *ufsinfo = (ufsinfo_t *) sd->fsdata;
     int i, k;
     int should_exist;
     LOCAL_ARRAY(char, name, MAXPATHLEN);
@@ -290,12 +290,12 @@ storeUfsDirSwapLogFile(SwapDir * sd, const char *ext)
     char *pathtmp2;
     if (Config.Log.swap) {
 	xstrncpy(pathtmp, sd->path, SQUID_MAXPATHLEN - 64);
-	while (index(pathtmp,'/'))
-	    *index(pathtmp,'/')='.';
-	while (strlen(pathtmp) && pathtmp[strlen(pathtmp)-1]=='.')
-	    pathtmp[strlen(pathtmp)-1]= '\0';
-	for(pathtmp2 = pathtmp; *pathtmp2 == '.'; pathtmp2++);
-	snprintf(path, SQUID_MAXPATHLEN-64, Config.Log.swap, pathtmp2);
+	while (index(pathtmp, '/'))
+	    *index(pathtmp, '/') = '.';
+	while (strlen(pathtmp) && pathtmp[strlen(pathtmp) - 1] == '.')
+	    pathtmp[strlen(pathtmp) - 1] = '\0';
+	for (pathtmp2 = pathtmp; *pathtmp2 == '.'; pathtmp2++);
+	snprintf(path, SQUID_MAXPATHLEN - 64, Config.Log.swap, pathtmp2);
 	if (strncmp(path, Config.Log.swap, SQUID_MAXPATHLEN - 64) == 0) {
 	    strcat(path, ".");
 	    snprintf(digit, 32, "%02d", sd->index);
@@ -313,7 +313,7 @@ storeUfsDirSwapLogFile(SwapDir * sd, const char *ext)
 static void
 storeUfsDirOpenSwapLog(SwapDir * sd)
 {
-    ufsinfo_t *ufsinfo = (ufsinfo_t *)sd->fsdata;
+    ufsinfo_t *ufsinfo = (ufsinfo_t *) sd->fsdata;
     char *path;
     int fd;
     path = storeUfsDirSwapLogFile(sd, NULL);
@@ -333,7 +333,7 @@ storeUfsDirOpenSwapLog(SwapDir * sd)
 static void
 storeUfsDirCloseSwapLog(SwapDir * sd)
 {
-    ufsinfo_t *ufsinfo = (ufsinfo_t *)sd->fsdata;
+    ufsinfo_t *ufsinfo = (ufsinfo_t *) sd->fsdata;
     if (ufsinfo->swaplog_fd < 0)	/* not open */
 	return;
     file_close(ufsinfo->swaplog_fd);
@@ -432,7 +432,7 @@ storeUfsDirRebuildFromDirectory(void *data)
 	tlv_list = storeSwapMetaUnpack(hdr_buf, &swap_hdr_len);
 	if (tlv_list == NULL) {
 	    debug(20, 1) ("storeUfsDirRebuildFromDirectory: failed to get meta data\n");
-            /* XXX shouldn't this be a call to storeUfsUnlink ? */
+	    /* XXX shouldn't this be a call to storeUfsUnlink ? */
 	    storeUfsDirUnlinkFile(SD, sfileno);
 	    continue;
 	}
@@ -552,13 +552,13 @@ storeUfsDirRebuildFromSwapLog(void *data)
 		 * because adding to store_swap_size happens in
 		 * the cleanup procedure.
 		 */
-                storeExpireNow(e);
-                storeReleaseRequest(e);
-                storeUfsDirReplRemove(e);
+		storeExpireNow(e);
+		storeReleaseRequest(e);
+		storeUfsDirReplRemove(e);
 		if (e->swap_filen > -1) {
 		    storeUfsDirMapBitReset(SD, e->swap_filen);
 		    e->swap_filen = -1;
-                    e->swap_dirn = -1;
+		    e->swap_dirn = -1;
 		}
 		storeRelease(e);
 		rb->counts.objcount--;
@@ -605,7 +605,7 @@ storeUfsDirRebuildFromSwapLog(void *data)
 		e->refcount += s.refcount;
 #if HEAP_REPLACEMENT
 		storeHeapPositionUpdate(e, SD);
-                storeUfsDirUnrefObj(SD, e);
+		storeUfsDirUnrefObj(SD, e);
 #endif
 	    } else {
 		debug_trap("storeUfsDirRebuildFromSwapLog: bad condition");
@@ -640,14 +640,14 @@ storeUfsDirRebuildFromSwapLog(void *data)
 	} else if (e) {
 	    /* key already exists, this swapfile not being used */
 	    /* junk old, load new */
-            storeExpireNow(e);
-            storeReleaseRequest(e);
-            storeUfsDirReplRemove(e);
+	    storeExpireNow(e);
+	    storeReleaseRequest(e);
+	    storeUfsDirReplRemove(e);
 	    if (e->swap_filen > -1) {
-                /* Make sure we don't actually unlink the file */
+		/* Make sure we don't actually unlink the file */
 		storeUfsDirMapBitReset(SD, e->swap_filen);
 		e->swap_filen = -1;
-                e->swap_dirn = -1;
+		e->swap_dirn = -1;
 	    }
 	    storeRelease(e);
 	    rb->counts.dupcount++;
@@ -677,7 +677,7 @@ static int
 storeUfsDirGetNextFile(RebuildState * rb, int *sfileno, int *size)
 {
     SwapDir *SD = rb->sd;
-    ufsinfo_t *ufsinfo = (ufsinfo_t *)SD->fsdata;
+    ufsinfo_t *ufsinfo = (ufsinfo_t *) SD->fsdata;
     int fd = -1;
     int used = 0;
     int dirs_opened = 0;
@@ -763,7 +763,7 @@ storeUfsDirGetNextFile(RebuildState * rb, int *sfileno, int *size)
 /* Add a new object to the cache with empty memory copy and pointer to disk
  * use to rebuild store from disk. */
 static StoreEntry *
-storeUfsDirAddDiskRestore(SwapDir *SD, const cache_key * key,
+storeUfsDirAddDiskRestore(SwapDir * SD, const cache_key * key,
     int file_number,
     size_t swap_file_sz,
     time_t expires,
@@ -844,7 +844,7 @@ storeUfsDirRebuild(SwapDir * sd)
 static void
 storeUfsDirCloseTmpSwapLog(SwapDir * sd)
 {
-    ufsinfo_t *ufsinfo = (ufsinfo_t *)sd->fsdata;
+    ufsinfo_t *ufsinfo = (ufsinfo_t *) sd->fsdata;
     char *swaplog_path = xstrdup(storeUfsDirSwapLogFile(sd, NULL));
     char *new_path = xstrdup(storeUfsDirSwapLogFile(sd, ".new"));
     int fd;
@@ -872,7 +872,7 @@ storeUfsDirCloseTmpSwapLog(SwapDir * sd)
 static FILE *
 storeUfsDirOpenTmpSwapLog(SwapDir * sd, int *clean_flag, int *zero_flag)
 {
-    ufsinfo_t *ufsinfo = (ufsinfo_t *)sd->fsdata;
+    ufsinfo_t *ufsinfo = (ufsinfo_t *) sd->fsdata;
     char *swaplog_path = xstrdup(storeUfsDirSwapLogFile(sd, NULL));
     char *clean_path = xstrdup(storeUfsDirSwapLogFile(sd, ".last-clean"));
     char *new_path = xstrdup(storeUfsDirSwapLogFile(sd, ".new"));
@@ -1058,7 +1058,7 @@ storeUfsDirWriteCleanClose(SwapDir * sd)
 static void
 storeUfsDirSwapLog(const SwapDir * sd, const StoreEntry * e, int op)
 {
-    ufsinfo_t *ufsinfo = (ufsinfo_t *)sd->fsdata;
+    ufsinfo_t *ufsinfo = (ufsinfo_t *) sd->fsdata;
     storeSwapLogData *s = xcalloc(1, sizeof(storeSwapLogData));
     s->op = (char) op;
     s->swap_filen = e->swap_filen;
@@ -1117,7 +1117,7 @@ storeUfsDirClean(int swap_index)
     N0 = n_ufs_dirs;
     D0 = ufs_dir_index[swap_index % N0];
     SD = &Config.cacheSwap.swapDirs[D0];
-    ufsinfo = (ufsinfo_t *)SD->fsdata;
+    ufsinfo = (ufsinfo_t *) SD->fsdata;
     N1 = ufsinfo->l1;
     D1 = (swap_index / N0) % N1;
     N2 = ufsinfo->l2;
@@ -1139,7 +1139,7 @@ storeUfsDirClean(int swap_index)
     while ((de = readdir(dp)) != NULL && k < 20) {
 	if (sscanf(de->d_name, "%X", &swapfileno) != 1)
 	    continue;
-	fn = swapfileno; /* XXX should remove this cruft ! */
+	fn = swapfileno;	/* XXX should remove this cruft ! */
 	if (storeUfsDirValidFileno(SD, fn))
 	    if (storeUfsDirMapBitTest(SD, fn))
 		if (storeUfsFilenoBelongsHere(fn, D0, D1, D2))
@@ -1185,7 +1185,7 @@ storeUfsDirCleanEvent(void *unused)
     assert(n_ufs_dirs);
     if (NULL == ufs_dir_index) {
 	SwapDir *sd;
-        ufsinfo_t *ufsinfo;
+	ufsinfo_t *ufsinfo;
 	/*
 	 * Initialize the little array that translates UFS cache_dir
 	 * number into the Config.cacheSwap.swapDirs array index.
@@ -1196,7 +1196,7 @@ storeUfsDirCleanEvent(void *unused)
 	    if (!storeUfsDirIs(sd))
 		continue;
 	    ufs_dir_index[n++] = i;
-            ufsinfo = (ufsinfo_t *)sd->fsdata;
+	    ufsinfo = (ufsinfo_t *) sd->fsdata;
 	    j += (ufsinfo->l1 * ufsinfo->l2);
 	}
 	assert(n == n_ufs_dirs);
@@ -1235,7 +1235,7 @@ storeUfsFilenoBelongsHere(int fn, int F0, int F1, int F2)
     int filn = fn;
     ufsinfo_t *ufsinfo;
     assert(F0 < Config.cacheSwap.n_configured);
-    ufsinfo = (ufsinfo_t *)Config.cacheSwap.swapDirs[F0].fsdata;
+    ufsinfo = (ufsinfo_t *) Config.cacheSwap.swapDirs[F0].fsdata;
     L1 = ufsinfo->l1;
     L2 = ufsinfo->l2;
     D1 = ((filn / L2) / L2) % L1;
@@ -1247,19 +1247,19 @@ storeUfsFilenoBelongsHere(int fn, int F0, int F1, int F2)
     return 1;
 }
 
-int 
-storeUfsDirValidFileno(SwapDir *SD, sfileno filn)
+int
+storeUfsDirValidFileno(SwapDir * SD, sfileno filn)
 {
-    ufsinfo_t *ufsinfo = (ufsinfo_t *)SD->fsdata;
+    ufsinfo_t *ufsinfo = (ufsinfo_t *) SD->fsdata;
     if (filn < 0)
-        return 0;
-    if (filn > ufsinfo->map->max_n_files)  
-        return 0;
+	return 0;
+    if (filn > ufsinfo->map->max_n_files)
+	return 0;
     return 1;
 }
 
 void
-storeUfsDirMaintain(SwapDir *SD)
+storeUfsDirMaintain(SwapDir * SD)
 {
     StoreEntry *e = NULL;
     int scanned = 0;
@@ -1278,135 +1278,134 @@ storeUfsDirMaintain(SwapDir *SD)
     link_list *locked_entries = NULL;
 #if HEAP_REPLACEMENT_DEBUG
     if (!verify_heap_property(SD->repl.heap.heap)) {
-        debug(20, 1) ("Heap property violated!\n");
+	debug(20, 1) ("Heap property violated!\n");
     }
 #endif
 #endif
     /* We can't delete objects while rebuilding swap */
     if (store_dirs_rebuilding) {
-        return;
+	return;
     } else {
-        f = (double) (store_swap_size - store_swap_low) / (store_swap_high - store_swap_low);
-        f = f < 0.0 ? 0.0 : f > 1.0 ? 1.0 : f;
-        max_scan = (int) (f * 400.0 + 100.0);
-        max_remove = (int) (f * 70.0 + 10.0);
+	f = (double) (store_swap_size - store_swap_low) / (store_swap_high - store_swap_low);
+	f = f < 0.0 ? 0.0 : f > 1.0 ? 1.0 : f;
+	max_scan = (int) (f * 400.0 + 100.0);
+	max_remove = (int) (f * 70.0 + 10.0);
 	/*
 	 * This is kinda cheap, but so we need this priority hack?
-         */
+	 */
 #if 0
-        eventAdd("MaintainSwapSpace", storeMaintainSwapSpace, NULL, 1.0 - f, 1);
+	eventAdd("MaintainSwapSpace", storeMaintainSwapSpace, NULL, 1.0 - f, 1);
 #endif
     }
     debug(20, 3) ("storeMaintainSwapSpace: f=%f, max_scan=%d, max_remove=%d\n", f, max_scan, max_remove);
 #if HEAP_REPLACEMENT
     while (heap_nodes(SD->repl.heap.heap) > 0) {
-        if (store_swap_size < store_swap_low)
-            break;
-        if (expired >= max_remove)
-            break;
-        if (scanned >= max_scan)
-            break;
-        age = heap_peepminkey(SD->repl.heap.heap);
-        e = heap_extractmin(SD->repl.heap.heap);
-        e->repl.node = NULL;         /* no longer in the heap */
-        scanned++;
-        if (storeEntryLocked(e)) {
-            /*
-             * Entry is in use ... put it in a linked list to ignore it.
-             */
-            if (!EBIT_TEST(e->flags, ENTRY_SPECIAL)) {
-                /*
-                 * If this was a "SPECIAL" do not add it back into the heap.
-                 * It will always be "SPECIAL" and therefore never removed.
-                 */
-                debug(20, 4) ("storeUfsDirMaintain: locked url %s\n",
-                    (e->mem_obj && e->mem_obj->url) ? e->mem_obj->url : storeKeyText(e->
-key));
-                linklistPush(&locked_entries, e);
-            }
-            locked++;
-            continue;
-        } else if (storeUfsDirCheckExpired(SD, e)) {
-            /*
-             * Note: This will not check the reference age ifdef
-             * HEAP_REPLACEMENT, but it does some other useful
-             * checks...
-             */
-            expired++;
-            debug(20, 3) ("Released store object age %f size %d refs %d key %s\n",
-                age, e->swap_file_sz, e->refcount, storeKeyText(e->key));
-            min_age = age;
-            storeRelease(e);
-        } else {
-            /*
-             * Did not expire the object so we need to add it back
-             * into the heap!
-             */
-            debug(20, 5) ("storeMaintainSwapSpace: non-expired %s\n",
-                storeKeyText(e->key));
-            linklistPush(&locked_entries, e);
-            continue;
-        }
-        if (store_swap_size < store_swap_low)
-            break;
-        else if (expired >= max_remove)
-            break;
-        else if (scanned >= max_scan)
-            break;
+	if (store_swap_size < store_swap_low)
+	    break;
+	if (expired >= max_remove)
+	    break;
+	if (scanned >= max_scan)
+	    break;
+	age = heap_peepminkey(SD->repl.heap.heap);
+	e = heap_extractmin(SD->repl.heap.heap);
+	e->repl.node = NULL;	/* no longer in the heap */
+	scanned++;
+	if (storeEntryLocked(e)) {
+	    /*
+	     * Entry is in use ... put it in a linked list to ignore it.
+	     */
+	    if (!EBIT_TEST(e->flags, ENTRY_SPECIAL)) {
+		/*
+		 * If this was a "SPECIAL" do not add it back into the heap.
+		 * It will always be "SPECIAL" and therefore never removed.
+		 */
+		debug(20, 4) ("storeUfsDirMaintain: locked url %s\n",
+		    (e->mem_obj && e->mem_obj->url) ? e->mem_obj->url : storeKeyText(e->
+			key));
+		linklistPush(&locked_entries, e);
+	    }
+	    locked++;
+	    continue;
+	} else if (storeUfsDirCheckExpired(SD, e)) {
+	    /*
+	     * Note: This will not check the reference age ifdef
+	     * HEAP_REPLACEMENT, but it does some other useful
+	     * checks...
+	     */
+	    expired++;
+	    debug(20, 3) ("Released store object age %f size %d refs %d key %s\n",
+		age, e->swap_file_sz, e->refcount, storeKeyText(e->key));
+	    min_age = age;
+	    storeRelease(e);
+	} else {
+	    /*
+	     * Did not expire the object so we need to add it back
+	     * into the heap!
+	     */
+	    debug(20, 5) ("storeMaintainSwapSpace: non-expired %s\n",
+		storeKeyText(e->key));
+	    linklistPush(&locked_entries, e);
+	    continue;
+	}
+	if (store_swap_size < store_swap_low)
+	    break;
+	else if (expired >= max_remove)
+	    break;
+	else if (scanned >= max_scan)
+	    break;
     }
     /*
      * Bump the heap age factor.
      */
     if (min_age > 0.0)
-        SD->repl.heap.heap->age = min_age;
+	SD->repl.heap.heap->age = min_age;
     /*
      * Reinsert all bumped locked entries back into heap...
      */
     while ((e = linklistShift(&locked_entries)))
-        e->repl.node = heap_insert(SD->repl.heap.heap, e);
+	e->repl.node = heap_insert(SD->repl.heap.heap, e);
 #else
     for (m = SD->repl.lru.list.tail; m; m = prev) {
-        prev = m->prev;
-        e = m->data;
-        scanned++;
-        if (storeEntryLocked(e)) {
-            /*
-             * If there is a locked entry at the tail of the LRU list,
-             * move it to the beginning to get it out of the way.
-             * Theoretically, we might have all locked objects at the
-             * tail, and then we'll never remove anything here and the
-             * LRU age will go to zero.
-             */
-            if (memInUse(MEM_STOREENTRY) > max_scan) {
-                dlinkDelete(&e->repl.lru, &SD->repl.lru.list);
-                dlinkAdd(e, &e->repl.lru, &SD->repl.lru.list);
-            }
-            locked++;
-
-        } else if (storeUfsDirCheckExpired(SD, e)) {
-            expired++;
-            storeRelease(e);
-        }
-        if (expired >= max_remove)
-            break;
-        if (scanned >= max_scan)
-            break;
+	prev = m->prev;
+	e = m->data;
+	scanned++;
+	if (storeEntryLocked(e)) {
+	    /*
+	     * If there is a locked entry at the tail of the LRU list,
+	     * move it to the beginning to get it out of the way.
+	     * Theoretically, we might have all locked objects at the
+	     * tail, and then we'll never remove anything here and the
+	     * LRU age will go to zero.
+	     */
+	    if (memInUse(MEM_STOREENTRY) > max_scan) {
+		dlinkDelete(&e->repl.lru, &SD->repl.lru.list);
+		dlinkAdd(e, &e->repl.lru, &SD->repl.lru.list);
+	    }
+	    locked++;
+
+	} else if (storeUfsDirCheckExpired(SD, e)) {
+	    expired++;
+	    storeRelease(e);
+	}
+	if (expired >= max_remove)
+	    break;
+	if (scanned >= max_scan)
+	    break;
     }
 #endif
-    debug(20, (expired ? 2 : 3)) ("storeMaintainSwapSpace: scanned %d/%d removed %d/%d l
-ocked %d f=%.03f\n",
-        scanned, max_scan, expired, max_remove, locked, f);
+    debug(20, (expired ? 2 : 3)) ("storeMaintainSwapSpace: scanned %d/%d removed %d/%d locked %d f=%.03f\n",
+	scanned, max_scan, expired, max_remove, locked, f);
     debug(20, 3) ("storeMaintainSwapSpace stats:\n");
     debug(20, 3) ("  %6d objects\n", memInUse(MEM_STOREENTRY));
     debug(20, 3) ("  %6d were scanned\n", scanned);
     debug(20, 3) ("  %6d were locked\n", locked);
     debug(20, 3) ("  %6d were expired\n", expired);
     if (store_swap_size < Config.Swap.maxSize)
-        return;
+	return;
     if (squid_curtime - last_warn_time < 10)
-        return;
+	return;
     debug(20, 0) ("WARNING: Disk space over limit: %d KB > %d KB\n",
-        store_swap_size, Config.Swap.maxSize);
+	store_swap_size, Config.Swap.maxSize);
     last_warn_time = squid_curtime;
 }
 
@@ -1418,14 +1417,14 @@ ocked %d f=%.03f\n",
  * happily store anything as long as the LRU time isn't too small.
  */
 int
-storeUfsDirCheckObj(SwapDir *SD, const StoreEntry *e)
+storeUfsDirCheckObj(SwapDir * SD, const StoreEntry * e)
 {
 #if !HEAP_REPLACEMENT
     if (storeUfsDirExpiredReferenceAge(SD) < 300) {
-        debug(20, 3) ("storeUfsDirCheckObj: NO: LRU Age = %d\n",
-            storeUfsDirExpiredReferenceAge(SD));
-        /* store_check_cachable_hist.no.lru_age_too_low++; */
-        return -1;
+	debug(20, 3) ("storeUfsDirCheckObj: NO: LRU Age = %d\n",
+	    storeUfsDirExpiredReferenceAge(SD));
+	/* store_check_cachable_hist.no.lru_age_too_low++; */
+	return -1;
     }
 #endif
     /* Return 999 (99.9%) constant load */
@@ -1439,18 +1438,18 @@ storeUfsDirCheckObj(SwapDir *SD, const StoreEntry *e)
  * maintain replacement information within the storage fs.
  */
 void
-storeUfsDirRefObj(SwapDir *SD, StoreEntry *e)
+storeUfsDirRefObj(SwapDir * SD, StoreEntry * e)
 {
     debug(1, 3) ("storeUfsDirRefObj: referencing %p %d/%d\n", e, e->swap_dirn,
-      e->swap_filen);
+	e->swap_filen);
 #if HEAP_REPLACEMENT
     /* Nothing to do here */
 #else
     /* Reference the object */
     if (!EBIT_TEST(e->flags, RELEASE_REQUEST) &&
-        !EBIT_TEST(e->flags, ENTRY_SPECIAL)) {
-        dlinkDelete(&e->repl.lru, &SD->repl.lru.list);
-        dlinkAdd(e, &e->repl.lru, &SD->repl.lru.list);
+	!EBIT_TEST(e->flags, ENTRY_SPECIAL)) {
+	dlinkDelete(&e->repl.lru, &SD->repl.lru.list);
+	dlinkAdd(e, &e->repl.lru, &SD->repl.lru.list);
     }
 #endif
 }
@@ -1461,13 +1460,13 @@ storeUfsDirRefObj(SwapDir *SD, StoreEntry *e)
  * removed, to maintain replacement information within the storage fs.
  */
 void
-storeUfsDirUnrefObj(SwapDir *SD, StoreEntry *e)
+storeUfsDirUnrefObj(SwapDir * SD, StoreEntry * e)
 {
     debug(1, 3) ("storeUfsDirUnrefObj: referencing %p %d/%d\n", e, e->swap_dirn,
-      e->swap_filen);
+	e->swap_filen);
 #if HEAP_REPLACEMENT
     if (e->repl.node)
-        heap_update(SD->repl.heap.heap, e->repl.node, e);
+	heap_update(SD->repl.heap.heap, e->repl.node, e);
 #endif
 }
 
@@ -1479,7 +1478,7 @@ storeUfsDirUnrefObj(SwapDir *SD, StoreEntry *e)
  * forced this bit of code here. Eeek.
  */
 void
-storeUfsDirUnlinkFile(SwapDir *SD, sfileno f)
+storeUfsDirUnlinkFile(SwapDir * SD, sfileno f)
 {
     debug(79, 3) ("storeUfsDirUnlinkFile: unlinking fileno %08X\n", f);
     storeUfsDirMapBitReset(SD, f);
@@ -1499,28 +1498,28 @@ storeUfsDirUnlinkFile(SwapDir *SD, sfileno f)
  * cachemgr 'info' page.
  */
 static time_t
-storeUfsDirExpiredReferenceAge(SwapDir *SD)
+storeUfsDirExpiredReferenceAge(SwapDir * SD)
 {
     double x;
     double z;
     time_t age;
     long store_high, store_low;
- 
+
     store_high = (long) (((float) SD->max_size *
-            (float) Config.Swap.highWaterMark) / (float) 100);
+	    (float) Config.Swap.highWaterMark) / (float) 100);
     store_low = (long) (((float) SD->max_size *
-            (float) Config.Swap.lowWaterMark) / (float) 100);
+	    (float) Config.Swap.lowWaterMark) / (float) 100);
     debug(20, 20) ("RA: Dir %s, hi=%d, lo=%d, cur=%d\n", SD->path, store_high, store_low, SD->cur_size);
-  
+
     x = (double) (store_high - SD->cur_size) /
-        (store_high - store_low);
+	(store_high - store_low);
     x = x < 0.0 ? 0.0 : x > 1.0 ? 1.0 : x;
     z = pow((double) (Config.referenceAge / 60), x);
     age = (time_t) (z * 60.0);
     if (age < 60)
-        age = 60;
+	age = 60;
     else if (age > Config.referenceAge)
-        age = Config.referenceAge;
+	age = Config.referenceAge;
     return age;
 }
 #endif
@@ -1534,14 +1533,14 @@ storeUfsDirExpiredReferenceAge(SwapDir *SD)
  * right now.
  */
 static int
-storeUfsDirCheckExpired(SwapDir *SD, StoreEntry *e)
+storeUfsDirCheckExpired(SwapDir * SD, StoreEntry * e)
 {
     if (storeEntryLocked(e))
-       return 0;
+	return 0;
     if (EBIT_TEST(e->flags, RELEASE_REQUEST))
-       return 1;
+	return 1;
     if (EBIT_TEST(e->flags, ENTRY_NEGCACHED) && squid_curtime >= e->expires)
-       return 1;
+	return 1;
 
 #if HEAP_REPLACEMENT
     /*
@@ -1551,7 +1550,7 @@ storeUfsDirCheckExpired(SwapDir *SD, StoreEntry *e)
     return 1;
 #else
     if (squid_curtime - e->lastref > storeUfsDirExpiredReferenceAge(SD))
-       return 1;
+	return 1;
     return 0;
 #endif
 }
@@ -1562,16 +1561,16 @@ storeUfsDirCheckExpired(SwapDir *SD, StoreEntry *e)
  */
 
 void
-storeUfsDirReplAdd(SwapDir *SD, StoreEntry *e)
+storeUfsDirReplAdd(SwapDir * SD, StoreEntry * e)
 {
     debug(20, 4) ("storeUfsDirReplAdd: added node %p to dir %d\n", e,
-      SD->index);
+	SD->index);
 #if HEAP_REPLACEMENT
     if (EBIT_TEST(e->flags, ENTRY_SPECIAL)) {
-        (void) 0;
+	(void) 0;
     } else {
-        e->repl.node = heap_insert(SD->repl.heap.heap, e);
-        debug(20, 4) ("storeUfsDirReplAdd: inserted node 0x%x\n", e->repl.node);
+	e->repl.node = heap_insert(SD->repl.heap.heap, e);
+	debug(20, 4) ("storeUfsDirReplAdd: inserted node 0x%x\n", e->repl.node);
     }
 #else
     /* Shouldn't we not throw special objects into the lru ? */
@@ -1581,18 +1580,18 @@ storeUfsDirReplAdd(SwapDir *SD, StoreEntry *e)
 
 
 void
-storeUfsDirReplRemove(StoreEntry *e)
+storeUfsDirReplRemove(StoreEntry * e)
 {
     SwapDir *SD = INDEXSD(e->swap_dirn);
     debug(20, 4) ("storeUfsDirReplRemove: remove node %p from dir %d\n", e,
-      SD->index);
+	SD->index);
 #if HEAP_REPLACEMENT
     /* And now, release the object from the replacement policy */
     if (e->repl.node) {
-        debug(20, 4) ("storeUfsDirReplRemove: deleting node 0x%x\n",
-          e->repl.node);
-        heap_delete(SD->repl.heap.heap, e->repl.node);
-        e->repl.node = NULL;
+	debug(20, 4) ("storeUfsDirReplRemove: deleting node 0x%x\n",
+	    e->repl.node);
+	heap_delete(SD->repl.heap.heap, e->repl.node);
+	e->repl.node = NULL;
     }
 #else
     dlinkDelete(&e->repl.lru, &SD->repl.lru.list);
@@ -1604,49 +1603,49 @@ storeUfsDirReplRemove(StoreEntry *e)
 /* ========== LOCAL FUNCTIONS ABOVE, GLOBAL FUNCTIONS BELOW ========== */
 
 void
-storeUfsDirStats(SwapDir *SD, StoreEntry * sentry)
+storeUfsDirStats(SwapDir * SD, StoreEntry * sentry)
 {
     ufsinfo_t *ufsinfo;
 #if HAVE_STATVFS
     struct statvfs sfs;
 #endif
-    ufsinfo = (ufsinfo_t *)SD->fsdata;
+    ufsinfo = (ufsinfo_t *) SD->fsdata;
     storeAppendPrintf(sentry, "First level subdirectories: %d\n", ufsinfo->l1);
     storeAppendPrintf(sentry, "Second level subdirectories: %d\n", ufsinfo->l2);
     storeAppendPrintf(sentry, "Maximum Size: %d KB\n", SD->max_size);
     storeAppendPrintf(sentry, "Current Size: %d KB\n", SD->cur_size);
     storeAppendPrintf(sentry, "Percent Used: %0.2f%%\n",
-        100.0 * SD->cur_size / SD->max_size);
+	100.0 * SD->cur_size / SD->max_size);
     storeAppendPrintf(sentry, "Filemap bits in use: %d of %d (%d%%)\n",
-    ufsinfo->map->n_files_in_map, ufsinfo->map->max_n_files,
-    percent(ufsinfo->map->n_files_in_map, ufsinfo->map->max_n_files));
+	ufsinfo->map->n_files_in_map, ufsinfo->map->max_n_files,
+	percent(ufsinfo->map->n_files_in_map, ufsinfo->map->max_n_files));
 #if HAVE_STATVFS
 #define fsbtoblk(num, fsbs, bs) \
     (((fsbs) != 0 && (fsbs) < (bs)) ? \
             (num) / ((bs) / (fsbs)) : (num) * ((fsbs) / (bs)))
-	if (!statvfs(SD->path, &sfs)) {
-            storeAppendPrintf(sentry, "Filesystem Space in use: %d/%d KB (%d%%)\n",
-            fsbtoblk((sfs.f_blocks - sfs.f_bfree), sfs.f_frsize, 1024),
-            fsbtoblk(sfs.f_blocks, sfs.f_frsize, 1024),
-            percent(sfs.f_blocks - sfs.f_bfree, sfs.f_blocks));
-            storeAppendPrintf(sentry, "Filesystem Inodes in use: %d/%d (%d%%)\n",
-            sfs.f_files - sfs.f_ffree, sfs.f_files,
-            percent(sfs.f_files - sfs.f_ffree, sfs.f_files));
+    if (!statvfs(SD->path, &sfs)) {
+	storeAppendPrintf(sentry, "Filesystem Space in use: %d/%d KB (%d%%)\n",
+	    fsbtoblk((sfs.f_blocks - sfs.f_bfree), sfs.f_frsize, 1024),
+	    fsbtoblk(sfs.f_blocks, sfs.f_frsize, 1024),
+	    percent(sfs.f_blocks - sfs.f_bfree, sfs.f_blocks));
+	storeAppendPrintf(sentry, "Filesystem Inodes in use: %d/%d (%d%%)\n",
+	    sfs.f_files - sfs.f_ffree, sfs.f_files,
+	    percent(sfs.f_files - sfs.f_ffree, sfs.f_files));
     }
 #endif
     storeAppendPrintf(sentry, "Flags:");
     if (SD->flags.selected)
-        storeAppendPrintf(sentry, " SELECTED");
+	storeAppendPrintf(sentry, " SELECTED");
     if (SD->flags.read_only)
-        storeAppendPrintf(sentry, " READ-ONLY");
+	storeAppendPrintf(sentry, " READ-ONLY");
     storeAppendPrintf(sentry, "\n");
 #if !HEAP_REPLACEMENT
     storeAppendPrintf(sentry, "LRU Expiration Age: %6.2f days\n",
-      (double) storeUfsDirExpiredReferenceAge(SD) / 86400.0); 
+	(double) storeUfsDirExpiredReferenceAge(SD) / 86400.0);
 #else
 #if 0
     storeAppendPrintf(sentry, "Storage Replacement Threshold:\t%f\n",
-        heap_peepminkey(sd.repl.heap.heap));
+	heap_peepminkey(sd.repl.heap.heap));
 #endif
 #endif
 }
@@ -1657,7 +1656,7 @@ storeUfsDirStats(SwapDir *SD, StoreEntry * sentry)
  * This routine is called when the given swapdir needs reconfiguring 
  */
 void
-storeUfsDirReconfigure(SwapDir *sd, int index, char *path)
+storeUfsDirReconfigure(SwapDir * sd, int index, char *path)
 {
     char *token;
     int i;
@@ -1700,10 +1699,10 @@ storeUfsDirReconfigure(SwapDir *sd, int index, char *path)
 void
 storeUfsDirDump(StoreEntry * entry, const char *name, SwapDir * s)
 {
-    ufsinfo_t *ufsinfo = (ufsinfo_t *)s->fsdata;
+    ufsinfo_t *ufsinfo = (ufsinfo_t *) s->fsdata;
     storeAppendPrintf(entry, "%s %s %s %d %d %d\n",
 	name,
-        "ufs",
+	"ufs",
 	s->path,
 	s->max_size >> 10,
 	ufsinfo->l1,
@@ -1716,22 +1715,22 @@ storeUfsDirDump(StoreEntry * entry, const char *name, SwapDir * s)
 static void
 storeUfsDirFree(SwapDir * s)
 {
-    ufsinfo_t *ufsinfo = (ufsinfo_t *)s->fsdata;
+    ufsinfo_t *ufsinfo = (ufsinfo_t *) s->fsdata;
     if (ufsinfo->swaplog_fd > -1) {
 	file_close(ufsinfo->swaplog_fd);
 	ufsinfo->swaplog_fd = -1;
     }
     filemapFreeMemory(ufsinfo->map);
     xfree(ufsinfo);
-    s->fsdata = NULL; /* Will aid debugging... */
+    s->fsdata = NULL;		/* Will aid debugging... */
 
 }
 
 char *
-storeUfsDirFullPath(SwapDir *SD, sfileno filn, char *fullpath)
+storeUfsDirFullPath(SwapDir * SD, sfileno filn, char *fullpath)
 {
     LOCAL_ARRAY(char, fullfilename, SQUID_MAXPATHLEN);
-    ufsinfo_t *ufsinfo = (ufsinfo_t *)SD->fsdata;
+    ufsinfo_t *ufsinfo = (ufsinfo_t *) SD->fsdata;
     int L1 = ufsinfo->l1;
     int L2 = ufsinfo->l2;
     if (!fullpath)
@@ -1751,28 +1750,28 @@ storeUfsDirFullPath(SwapDir *SD, sfileno filn, char *fullpath)
  * This is called by storeCleanup() if -S was given on the command line.
  */
 static int
-storeUfsCleanupDoubleCheck(SwapDir *sd, StoreEntry *e)
+storeUfsCleanupDoubleCheck(SwapDir * sd, StoreEntry * e)
 {
     struct stat sb;
 
     if (stat(storeUfsDirFullPath(sd, e->swap_filen, NULL), &sb) < 0) {
-        debug(20, 0) ("storeUfsCleanupDoubleCheck: MISSING SWAP FILE\n");
-        debug(20, 0) ("storeUfsCleanupDoubleCheck: FILENO %08X\n", e->swap_filen);
-        debug(20, 0) ("storeUfsCleanupDoubleCheck: PATH %s\n",
-            storeUfsDirFullPath(sd, e->swap_filen, NULL));
-        storeEntryDump(e, 0);
-        return -1;
-    }       
+	debug(20, 0) ("storeUfsCleanupDoubleCheck: MISSING SWAP FILE\n");
+	debug(20, 0) ("storeUfsCleanupDoubleCheck: FILENO %08X\n", e->swap_filen);
+	debug(20, 0) ("storeUfsCleanupDoubleCheck: PATH %s\n",
+	    storeUfsDirFullPath(sd, e->swap_filen, NULL));
+	storeEntryDump(e, 0);
+	return -1;
+    }
     if (e->swap_file_sz != sb.st_size) {
-        debug(20, 0) ("storeUfsCleanupDoubleCheck: SIZE MISMATCH\n");
-        debug(20, 0) ("storeUfsCleanupDoubleCheck: FILENO %08X\n", e->swap_filen);
-        debug(20, 0) ("storeUfsCleanupDoubleCheck: PATH %s\n",
-            storeUfsDirFullPath(sd, e->swap_filen, NULL));
-        debug(20, 0) ("storeUfsCleanupDoubleCheck: ENTRY SIZE: %d, FILE SIZE: %d\n",
-            e->swap_file_sz, (int) sb.st_size); 
-        storeEntryDump(e, 0); 
-        return -1;
-    }       
+	debug(20, 0) ("storeUfsCleanupDoubleCheck: SIZE MISMATCH\n");
+	debug(20, 0) ("storeUfsCleanupDoubleCheck: FILENO %08X\n", e->swap_filen);
+	debug(20, 0) ("storeUfsCleanupDoubleCheck: PATH %s\n",
+	    storeUfsDirFullPath(sd, e->swap_filen, NULL));
+	debug(20, 0) ("storeUfsCleanupDoubleCheck: ENTRY SIZE: %d, FILE SIZE: %d\n",
+	    e->swap_file_sz, (int) sb.st_size);
+	storeEntryDump(e, 0);
+	return -1;
+    }
     return 0;
 }
 
@@ -1782,7 +1781,7 @@ storeUfsCleanupDoubleCheck(SwapDir *sd, StoreEntry *e)
  * Called when a *new* fs is being setup.
  */
 void
-storeUfsDirParse(SwapDir *sd, int index, char *path)
+storeUfsDirParse(SwapDir * sd, int index, char *path)
 {
     char *token;
     int i;
@@ -1810,7 +1809,7 @@ storeUfsDirParse(SwapDir *sd, int index, char *path)
 
     ufsinfo = xmalloc(sizeof(ufsinfo_t));
     if (ufsinfo == NULL)
-        fatal("storeUfsDirParse: couldn't xmalloc() ufsinfo_t!\n");
+	fatal("storeUfsDirParse: couldn't xmalloc() ufsinfo_t!\n");
 
     sd->index = index;
     sd->path = xstrdup(path);
@@ -1819,7 +1818,7 @@ storeUfsDirParse(SwapDir *sd, int index, char *path)
     ufsinfo->l1 = l1;
     ufsinfo->l2 = l2;
     ufsinfo->swaplog_fd = -1;
-    ufsinfo->map = NULL; /* Debugging purposes */
+    ufsinfo->map = NULL;	/* Debugging purposes */
     ufsinfo->suggest = 0;
     sd->flags.read_only = read_only;
     sd->init = storeUfsDirInit;
@@ -1855,24 +1854,24 @@ storeUfsDirParse(SwapDir *sd, int index, char *path)
      * always uses GDSF since we want to maximize object hit rate.
      */
     if (Config.replPolicy) {
-        if (tolower(Config.replPolicy[0]) == 'g') {
-            debug(20, 1) ("Using GDSF disk replacement policy\n");
-            sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_GDSF);
-        } else if (tolower(Config.replPolicy[0]) == 'l') {
-            if (tolower(Config.replPolicy[1]) == 'f') {
-                debug(20, 1) ("Using LFUDA disk replacement policy\n");
-                sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_LFUDA);
-            } else if (tolower(Config.replPolicy[1]) == 'r') {
-                debug(20, 1) ("Using LRU heap disk replacement policy\n");
-                sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_LRU);
-            }
-        } else {
-            debug(20, 1) ("Unrecognized replacement_policy; using GDSF\n");
-            sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_GDSF);
-        }
+	if (tolower(Config.replPolicy[0]) == 'g') {
+	    debug(20, 1) ("Using GDSF disk replacement policy\n");
+	    sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_GDSF);
+	} else if (tolower(Config.replPolicy[0]) == 'l') {
+	    if (tolower(Config.replPolicy[1]) == 'f') {
+		debug(20, 1) ("Using LFUDA disk replacement policy\n");
+		sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_LFUDA);
+	    } else if (tolower(Config.replPolicy[1]) == 'r') {
+		debug(20, 1) ("Using LRU heap disk replacement policy\n");
+		sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_LRU);
+	    }
+	} else {
+	    debug(20, 1) ("Unrecognized replacement_policy; using GDSF\n");
+	    sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_GDSF);
+	}
     } else {
-        debug(20, 1) ("Using default disk replacement policy (GDSF)\n");
-        sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_GDSF);
+	debug(20, 1) ("Using default disk replacement policy (GDSF)\n");
+	sd->repl.heap.heap = new_heap(10000, HeapKeyGen_StoreEntry_GDSF);
     }
 #else
     sd->repl.lru.list.head = NULL;
@@ -1891,7 +1890,7 @@ storeUfsDirDone(void)
 }
 
 void
-storeFsSetup_ufs(storefs_entry_t *storefs)
+storeFsSetup_ufs(storefs_entry_t * storefs)
 {
     assert(!ufs_initialised);
     storefs->parsefunc = storeUfsDirParse;
@@ -1900,4 +1899,3 @@ storeFsSetup_ufs(storefs_entry_t *storefs)
     ufs_state_pool = memPoolCreate("UFS IO State data", sizeof(ufsstate_t));
     ufs_initialised = 1;
 }
-
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_io_ufs.cc,v 1.1 2000/05/03 17:15:48 adrian Exp $
+ * $Id: store_io_ufs.cc,v 1.2 2000/05/12 00:29:20 wessels Exp $
  *
  * DEBUG: section 79    Storage Manager UFS Interface
  * AUTHOR: Duane Wessels
@@ -45,8 +45,8 @@ static void storeUfsIOFreeEntry(void *, int);
 /* === PUBLIC =========================================================== */
 
 storeIOState *
-storeUfsOpen(SwapDir *SD, StoreEntry *e, STFNCB * file_callback, 
-  STIOCB * callback, void *callback_data)
+storeUfsOpen(SwapDir * SD, StoreEntry * e, STFNCB * file_callback,
+    STIOCB * callback, void *callback_data)
 {
     sfileno f = e->swap_filen;
     char *path = storeUfsDirFullPath(SD, f, NULL);
@@ -71,26 +71,26 @@ storeUfsOpen(SwapDir *SD, StoreEntry *e, STFNCB * file_callback,
     sio->callback_data = callback_data;
     cbdataLock(callback_data);
     sio->e = e;
-    ((ufsstate_t *)(sio->fsstate))->fd = fd;
-    ((ufsstate_t *)(sio->fsstate))->flags.writing = 0;
-    ((ufsstate_t *)(sio->fsstate))->flags.reading = 0;
-    ((ufsstate_t *)(sio->fsstate))->flags.close_request = 0;
+    ((ufsstate_t *) (sio->fsstate))->fd = fd;
+    ((ufsstate_t *) (sio->fsstate))->flags.writing = 0;
+    ((ufsstate_t *) (sio->fsstate))->flags.reading = 0;
+    ((ufsstate_t *) (sio->fsstate))->flags.close_request = 0;
     if (fstat(fd, &sb) == 0)
-        sio->st_size = sb.st_size;
+	sio->st_size = sb.st_size;
     store_open_disk_fd++;
 
     /* We should update the heap/dlink position here ! */
     return sio;
 }
 
 storeIOState *
-storeUfsCreate(SwapDir *SD, StoreEntry *e, STFNCB *file_callback, STIOCB *callback, void *callback_data)
+storeUfsCreate(SwapDir * SD, StoreEntry * e, STFNCB * file_callback, STIOCB * callback, void *callback_data)
 {
     storeIOState *sio;
     int fd;
     int mode = (O_WRONLY | O_CREAT | O_TRUNC);
     char *path;
-    ufsinfo_t *ufsinfo = (ufsinfo_t *)SD->fsdata;
+    ufsinfo_t *ufsinfo = (ufsinfo_t *) SD->fsdata;
     sfileno filn;
     sdirno dirn;
 
@@ -104,8 +104,8 @@ storeUfsCreate(SwapDir *SD, StoreEntry *e, STFNCB *file_callback, STIOCB *callba
     debug(79, 3) ("storeUfsCreate: fileno %08X\n", filn);
     fd = file_open(path, mode);
     if (fd < 0) {
-        debug(79, 3) ("storeUfsCreate: got failure (%d)\n", errno);
-        return NULL;
+	debug(79, 3) ("storeUfsCreate: got failure (%d)\n", errno);
+	return NULL;
     }
     debug(79, 3) ("storeUfsCreate: opened FD %d\n", fd);
     sio = memAllocate(MEM_STORE_IO);
@@ -119,10 +119,10 @@ storeUfsCreate(SwapDir *SD, StoreEntry *e, STFNCB *file_callback, STIOCB *callba
     sio->callback_data = callback_data;
     cbdataLock(callback_data);
     sio->e = (StoreEntry *) e;
-    ((ufsstate_t *)(sio->fsstate))->fd = fd;
-    ((ufsstate_t *)(sio->fsstate))->flags.writing = 0;
-    ((ufsstate_t *)(sio->fsstate))->flags.reading = 0;
-    ((ufsstate_t *)(sio->fsstate))->flags.close_request = 0;
+    ((ufsstate_t *) (sio->fsstate))->fd = fd;
+    ((ufsstate_t *) (sio->fsstate))->flags.writing = 0;
+    ((ufsstate_t *) (sio->fsstate))->flags.reading = 0;
+    ((ufsstate_t *) (sio->fsstate))->flags.close_request = 0;
     store_open_disk_fd++;
 
     /* now insert into the replacement policy */
@@ -131,9 +131,9 @@ storeUfsCreate(SwapDir *SD, StoreEntry *e, STFNCB *file_callback, STIOCB *callba
 }
 
 void
-storeUfsClose(SwapDir *SD, storeIOState * sio)
+storeUfsClose(SwapDir * SD, storeIOState * sio)
 {
-    ufsstate_t *ufsstate = (ufsstate_t *)sio->fsstate;
+    ufsstate_t *ufsstate = (ufsstate_t *) sio->fsstate;
 
     debug(79, 3) ("storeUfsClose: dirno %d, fileno %08X, FD %d\n",
 	sio->swap_dirn, sio->swap_filen, ufsstate->fd);
@@ -145,9 +145,9 @@ storeUfsClose(SwapDir *SD, storeIOState * sio)
 }
 
 void
-storeUfsRead(SwapDir *SD, storeIOState * sio, char *buf, size_t size, off_t offset, STRCB * callback, void *callback_data)
+storeUfsRead(SwapDir * SD, storeIOState * sio, char *buf, size_t size, off_t offset, STRCB * callback, void *callback_data)
 {
-    ufsstate_t *ufsstate = (ufsstate_t *)sio->fsstate;
+    ufsstate_t *ufsstate = (ufsstate_t *) sio->fsstate;
 
     assert(sio->read.callback == NULL);
     assert(sio->read.callback_data == NULL);
@@ -167,9 +167,9 @@ storeUfsRead(SwapDir *SD, storeIOState * sio, char *buf, size_t size, off_t offs
 }
 
 void
-storeUfsWrite(SwapDir *SD, storeIOState * sio, char *buf, size_t size, off_t offset, FREE * free_func)
+storeUfsWrite(SwapDir * SD, storeIOState * sio, char *buf, size_t size, off_t offset, FREE * free_func)
 {
-    ufsstate_t *ufsstate = (ufsstate_t *)sio->fsstate;
+    ufsstate_t *ufsstate = (ufsstate_t *) sio->fsstate;
     debug(79, 3) ("storeUfsWrite: dirn %d, fileno %08X, FD %d\n", sio->swap_dirn, sio->swap_filen, ufsstate->fd);
     ufsstate->flags.writing = 1;
     file_write(ufsstate->fd,
@@ -182,7 +182,7 @@ storeUfsWrite(SwapDir *SD, storeIOState * sio, char *buf, size_t size, off_t off
 }
 
 void
-storeUfsUnlink(SwapDir *SD, StoreEntry *e)
+storeUfsUnlink(SwapDir * SD, StoreEntry * e)
 {
     debug(79, 3) ("storeUfsUnlink: fileno %08X\n", e->swap_filen);
     storeUfsDirReplRemove(e);
@@ -195,7 +195,7 @@ static void
 storeUfsReadDone(int fd, const char *buf, int len, int errflag, void *my_data)
 {
     storeIOState *sio = my_data;
-    ufsstate_t *ufsstate = (ufsstate_t *)sio->fsstate;
+    ufsstate_t *ufsstate = (ufsstate_t *) sio->fsstate;
     STRCB *callback = sio->read.callback;
     void *their_data = sio->read.callback_data;
     ssize_t rlen;
@@ -205,10 +205,10 @@ storeUfsReadDone(int fd, const char *buf, int len, int errflag, void *my_data)
     ufsstate->flags.reading = 0;
     if (errflag) {
 	debug(79, 3) ("storeUfsReadDone: got failure (%d)\n", errflag);
-        rlen = -1;
+	rlen = -1;
     } else {
-        rlen = (ssize_t) len;
-        sio->offset += len;
+	rlen = (ssize_t) len;
+	sio->offset += len;
     }
     assert(callback);
     assert(their_data);
@@ -223,7 +223,7 @@ static void
 storeUfsWriteDone(int fd, int errflag, size_t len, void *my_data)
 {
     storeIOState *sio = my_data;
-    ufsstate_t *ufsstate = (ufsstate_t *)sio->fsstate;
+    ufsstate_t *ufsstate = (ufsstate_t *) sio->fsstate;
     debug(79, 3) ("storeUfsWriteDone: dirno %d, fileno %08X, FD %d, len %d\n",
 	sio->swap_dirn, sio->swap_filen, fd, len);
     ufsstate->flags.writing = 0;
@@ -240,7 +240,7 @@ storeUfsWriteDone(int fd, int errflag, size_t len, void *my_data)
 static void
 storeUfsIOCallback(storeIOState * sio, int errflag)
 {
-    ufsstate_t *ufsstate = (ufsstate_t *)sio->fsstate;
+    ufsstate_t *ufsstate = (ufsstate_t *) sio->fsstate;
     debug(79, 3) ("storeUfsIOCallback: errflag=%d\n", errflag);
     if (ufsstate->fd > -1) {
 	file_close(ufsstate->fd);
@@ -262,6 +262,6 @@ storeUfsIOCallback(storeIOState * sio, int errflag)
 static void
 storeUfsIOFreeEntry(void *sio, int foo)
 {
-    memPoolFree(ufs_state_pool, ((storeIOState *)sio)->fsstate);
+    memPoolFree(ufs_state_pool, ((storeIOState *) sio)->fsstate);
     memFree(sio, MEM_STORE_IO);
 }
@@ -28,13 +28,13 @@ typedef struct _ufsinfo_t ufsinfo_t;
 typedef struct _ufsstate_t ufsstate_t;
 
 /* The ufs_state memory pool */
-extern MemPool * ufs_state_pool;
+extern MemPool *ufs_state_pool;
 
 extern void storeUfsDirMapBitReset(SwapDir *, sfileno);
 extern int storeUfsDirMapBitAllocate(SwapDir *);
-extern char * storeUfsDirFullPath(SwapDir *SD, sfileno filn, char *fullpath);
+extern char *storeUfsDirFullPath(SwapDir * SD, sfileno filn, char *fullpath);
 extern void storeUfsDirUnlinkFile(SwapDir *, sfileno);
-extern void storeUfsDirReplAdd(SwapDir *SD, StoreEntry *);
+extern void storeUfsDirReplAdd(SwapDir * SD, StoreEntry *);
 extern void storeUfsDirReplRemove(StoreEntry *);
 
 /*
@@ -1,6 +1,6 @@
 
 /*
- * $Id: globals.h,v 1.88 2000/05/03 17:15:42 adrian Exp $
+ * $Id: globals.h,v 1.89 2000/05/12 00:29:07 wessels Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -149,7 +149,7 @@ extern int refresh_nocache_hack;	/* 0 */
 extern request_flags null_request_flags;
 extern int store_open_disk_fd;	/* 0 */
 extern const char *SwapDirType[];
-extern storefs_entry_t *storefs_list; /* NULL */
+extern storefs_entry_t *storefs_list;	/* NULL */
 extern int store_swap_low;
 extern int store_swap_high;
 extern int store_pages_max;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: http.cc,v 1.359 2000/05/02 21:21:08 hno Exp $
+ * $Id: http.cc,v 1.360 2000/05/12 00:29:07 wessels Exp $
  *
  * DEBUG: section 11    Hypertext Transfer Protocol (HTTP)
  * AUTHOR: Harvest Derived
@@ -877,7 +877,7 @@ httpSendRequest(HttpStateData * httpState)
 	httpState->flags.keepalive = 1;
     if (httpState->peer)
 	if (neighborType(httpState->peer, httpState->request) == PEER_SIBLING &&
-		!httpState->peer->options.allow_miss)
+	    !httpState->peer->options.allow_miss)
 	    httpState->flags.only_if_cached = 1;
     memBufDefInit(&mb);
     httpBuildRequestPrefix(req,
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ipc.cc,v 1.20 2000/05/02 20:21:04 hno Exp $
+ * $Id: ipc.cc,v 1.21 2000/05/12 00:29:07 wessels Exp $
  *
  * DEBUG: section 54    Interprocess Communication
  * AUTHOR: Duane Wessels
@@ -269,7 +269,7 @@ ipcCreate(int type, const char *prog, char *const args[], const char *name, int
     close(t2);
     close(t3);
     /* Make sure all other filedescriptors are closed */
-    for(x=3;x<SQUID_MAXFD; x++)
+    for (x = 3; x < SQUID_MAXFD; x++)
 	close(x);
 #if HAVE_SETSID
     setsid();
@@ -1,6 +1,6 @@
 
 /*
- * $Id: mem.cc,v 1.45 2000/05/03 17:15:42 adrian Exp $
+ * $Id: mem.cc,v 1.46 2000/05/12 00:29:07 wessels Exp $
  *
  * DEBUG: section 13    High Level Memory Pool Management
  * AUTHOR: Harvest Derived
@@ -349,4 +349,3 @@ memFree8K(void *p)
 {
     memFree(p, MEM_8K_BUF);
 }
-
@@ -1,6 +1,6 @@
 
 /*
- * $Id: neighbors.cc,v 1.282 2000/05/02 20:31:44 hno Exp $
+ * $Id: neighbors.cc,v 1.283 2000/05/12 00:29:07 wessels Exp $
  *
  * DEBUG: section 15    Neighbor Routines
  * AUTHOR: Harvest Derived
@@ -269,7 +269,7 @@ peerClearRR(void *data)
     if (p->rr_count < 0)
 	p->rr_count = 0;
     p->rr_lastcount = p->rr_count;
-    eventAdd("peerClearRR",peerClearRR, p, 5*60, 0);
+    eventAdd("peerClearRR", peerClearRR, p, 5 * 60, 0);
 }
 
 peer *
@@ -893,13 +893,13 @@ int
 neighborUp(const peer * p)
 {
     if (!p->tcp_up) {
-	peerProbeConnect((peer *)p);
+	peerProbeConnect((peer *) p);
 	return 0;
     }
     if (p->options.no_query)
 	return 1;
     if (p->stats.probe_start != 0 &&
-	    squid_curtime - p->stats.probe_start > Config.Timeout.deadPeer)
+	squid_curtime - p->stats.probe_start > Config.Timeout.deadPeer)
 	return 0;
     return 1;
 }
@@ -996,7 +996,7 @@ peerRefreshDNS(void *data)
 }
 
 void
-peerConnectFailed(peer *p)
+peerConnectFailed(peer * p)
 {
     p->stats.last_connect_failure = squid_curtime;
     if (!p->tcp_up) {
@@ -1014,7 +1014,7 @@ peerConnectFailed(peer *p)
 }
 
 void
-peerConnectSucceded(peer *p)
+peerConnectSucceded(peer * p)
 {
     if (!p->tcp_up) {
 	debug(15, 2) ("TCP connection to %s/%d succeded\n", p->host, p->http_port);
@@ -1030,13 +1030,13 @@ peerConnectSucceded(peer *p)
  * peerProbeConnect will be called on dead peers by neighborUp 
  */
 static void
-peerProbeConnect(peer *p)
+peerProbeConnect(peer * p)
 {
     int fd;
     if (p->test_fd != -1)
-	return; /* probe already running */
+	return;			/* probe already running */
     if (squid_curtime - p->stats.last_connect_probe < Config.Timeout.connect)
-	return; /* don't probe to often */
+	return;			/* don't probe to often */
     fd = comm_open(SOCK_STREAM, 0, Config.Addrs.tcp_outgoing,
 	0, COMM_NONBLOCKING, p->host);
     if (fd < 0)
@@ -1,6 +1,6 @@
 
 /*
- * $Id: protos.h,v 1.364 2000/05/07 16:18:19 adrian Exp $
+ * $Id: protos.h,v 1.365 2000/05/12 00:29:08 wessels Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -201,12 +201,12 @@ extern void file_read(int, char *, int, off_t, DRCB *, void *);
 extern void disk_init(void);
 
 /* diskd.c */
-extern diskd_queue * afile_create_queue(void);
+extern diskd_queue *afile_create_queue(void);
 extern void afile_destroy_queue(diskd_queue *);
 extern void afile_sync_queue(diskd_queue *);
 extern void afile_sync(void);
 extern void afile_open(const char *path, int mode, DOCB *, void *);
-extern void afile_close(int fd, DCCB *callback, void *data);
+extern void afile_close(int fd, DCCB * callback, void *data);
 extern void afile_write(int, off_t, void *, int len, DWCB *, void *, FREE *);
 extern void afile_write_mbuf(int fd, off_t, MemBuf, DWCB *, void *);
 extern void afile_read(int, char *, int, off_t, DRCB *, void *);
@@ -860,8 +860,8 @@ extern heap_key HeapKeyGen_StoreEntry_LRU(void *, double);
 extern void storeFsSetup(void);
 
 /* store_io.c */
-extern storeIOState * storeCreate(StoreEntry *, STFNCB *, STIOCB *, void *);
-extern storeIOState * storeOpen(StoreEntry *, STFNCB *, STIOCB *, void *);
+extern storeIOState *storeCreate(StoreEntry *, STFNCB *, STIOCB *, void *);
+extern storeIOState *storeOpen(StoreEntry *, STFNCB *, STIOCB *, void *);
 extern void storeClose(storeIOState *);
 extern void storeRead(storeIOState *, char *, size_t, off_t, STRCB *, void *);
 extern void storeWrite(storeIOState *, char *, size_t, off_t, FREE *);
@@ -963,7 +963,7 @@ extern store_client *storeClientListSearch(const MemObject * mem, void *data);
 extern store_client *storeClientListAdd(StoreEntry * e, void *data);
 extern void storeClientCopy(store_client *, StoreEntry *, off_t, off_t, size_t, char *, STCB *, void *);
 extern int storeClientCopyPending(store_client *, StoreEntry * e, void *data);
-extern int storeUnregister(store_client *sc, StoreEntry * e, void *data);
+extern int storeUnregister(store_client * sc, StoreEntry * e, void *data);
 extern off_t storeLowestMemReaderOffset(const StoreEntry * entry);
 extern void InvokeHandlers(StoreEntry * e);
 extern int storePendingNClients(const StoreEntry * e);
@@ -1151,7 +1151,7 @@ extern int delayBytesWanted(delay_id d, int min, int max);
 extern void delayBytesIn(delay_id, int qty);
 extern int delayMostBytesWanted(const MemObject * mem, int max);
 extern delay_id delayMostBytesAllowed(const MemObject * mem);
-extern void delaySetStoreClient(store_client *sc, delay_id delay_id);
+extern void delaySetStoreClient(store_client * sc, delay_id delay_id);
 extern void delayRegisterDelayIdPtr(delay_id * loc);
 extern void delayUnregisterDelayIdPtr(delay_id * loc);
 #endif
@@ -1,6 +1,6 @@
 
 /*
- * $Id: snmp_agent.cc,v 1.74 2000/05/03 17:15:42 adrian Exp $
+ * $Id: snmp_agent.cc,v 1.75 2000/05/12 00:29:08 wessels Exp $
  *
  * DEBUG: section 49     SNMP Interface
  * AUTHOR: Kostas Anagnostakis
@@ -279,9 +279,9 @@ snmp_prfSysFn(variable_list * Var, snint * ErrP)
 	    ASN_INTEGER);
 	break;
     case PERF_SYS_CURLRUEXP:
-        /* No global LRU info anymore */
+	/* No global LRU info anymore */
 	Answer = snmp_var_new_integer(Var->name, Var->name_length,
-            0,
+	    0,
 	    SMI_TIMETICKS);
 	break;
     case PERF_SYS_CURUNLREQ:
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ssl.cc,v 1.104 2000/05/02 19:55:45 hno Exp $
+ * $Id: ssl.cc,v 1.105 2000/05/12 00:29:08 wessels Exp $
  *
  * DEBUG: section 26    Secure Sockets Layer Proxy
  * AUTHOR: Duane Wessels
@@ -382,10 +382,10 @@ sslConnectDone(int fdnotused, int status, void *data)
 	    sslState->servers->peer->host);
     else if (Config.onoff.log_ip_on_direct)
 	hierarchyNote(&sslState->request->hier, sslState->servers->code,
-		fd_table[sslState->server.fd].ipaddr);
+	    fd_table[sslState->server.fd].ipaddr);
     else
 	hierarchyNote(&sslState->request->hier, sslState->servers->code,
-		sslState->host);
+	    sslState->host);
     if (status == COMM_ERR_DNS) {
 	debug(26, 4) ("sslConnect: Unknown host: %s\n", sslState->host);
 	err = errorCon(ERR_DNS_FAIL, HTTP_NOT_FOUND);
@@ -428,14 +428,14 @@ sslStart(int fd, const char *url, request_t * request, size_t * size_ptr)
     aclCheck_t ch;
     int answer;
     /*
-       * client_addr == no_addr indicates this is an "internal" request
-       * from peer_digest.c, asn.c, netdb.c, etc and should always
-       * be allowed.  yuck, I know.
-       */
+     * client_addr == no_addr indicates this is an "internal" request
+     * from peer_digest.c, asn.c, netdb.c, etc and should always
+     * be allowed.  yuck, I know.
+     */
     if (request->client_addr.s_addr != no_addr.s_addr) {
 	/*
-	   * Check if this host is allowed to fetch MISSES from us (miss_access)
-	   */
+	 * Check if this host is allowed to fetch MISSES from us (miss_access)
+	 */
 	memset(&ch, '\0', sizeof(aclCheck_t));
 	ch.src_addr = request->client_addr;
 	ch.my_addr = request->my_addr;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: stat.cc,v 1.326 2000/05/07 16:18:19 adrian Exp $
+ * $Id: stat.cc,v 1.327 2000/05/12 00:29:08 wessels Exp $
  *
  * DEBUG: section 18    Cache Manager Statistics
  * AUTHOR: Harvest Derived
@@ -275,8 +275,8 @@ statStoreEntry(StoreEntry * s, StoreEntry * e)
 	if (mem->swapout.sio)
 	    storeAppendPrintf(s, "\tswapout: %d bytes written\n",
 		(int) storeOffset(mem->swapout.sio));
-        for (i = 0, node = mem->clients.head; node; node = node->next, i++) {
-            sc = (store_client *)node->data;
+	for (i = 0, node = mem->clients.head; node; node = node->next, i++) {
+	    sc = (store_client *) node->data;
 	    if (sc->callback_data == NULL)
 		continue;
 	    storeAppendPrintf(s, "\tClient #%d, %p\n", i, sc->callback_data);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store.cc,v 1.521 2000/05/07 16:18:20 adrian Exp $
+ * $Id: store.cc,v 1.522 2000/05/12 00:29:08 wessels Exp $
  *
  * DEBUG: section 20    Storage Manager
  * AUTHOR: Harvest Derived
@@ -232,17 +232,17 @@ storeLockObject(StoreEntry * e)
     SwapDir *SD;
 
     if (e->swap_dirn > -1)
-      SD = INDEXSD(e->swap_dirn);
+	SD = INDEXSD(e->swap_dirn);
     else
-      SD = NULL;
+	SD = NULL;
 
     e->lock_count++;
     debug(20, 3) ("storeLockObject: key '%s' count=%d\n",
 	storeKeyText(e->key), (int) e->lock_count);
     e->lastref = squid_curtime;
     /* Notify the fs that we're referencing this object again */
     if (SD != NULL && SD->refobj != NULL)
-        SD->refobj(SD, e);
+	SD->refobj(SD, e);
 }
 
 void
@@ -277,11 +277,11 @@ storeUnlockObject(StoreEntry * e)
     assert(storePendingNClients(e) == 0);
     /* Notify the fs that we're not referencing this object any more */
     if (e->swap_filen > -1)
-        SD = INDEXSD(e->swap_dirn);
+	SD = INDEXSD(e->swap_dirn);
     else
-        SD = NULL;
+	SD = NULL;
     if (SD != NULL && SD->unrefobj != NULL)
-        SD->unrefobj(SD, e);
+	SD->unrefobj(SD, e);
 #if HEAP_REPLACEMENT
     storeHeapPositionUpdate(e, SD);
 #else
@@ -541,7 +541,7 @@ storeCheckCachable(StoreEntry * e)
 	return 0;		/* avoid release call below */
     } else if ((e->mem_obj->reply->content_length > 0 &&
 		e->mem_obj->reply->content_length > Config.Store.maxObjectSize) ||
-		e->mem_obj->inmem_hi > Config.Store.maxObjectSize) {
+	e->mem_obj->inmem_hi > Config.Store.maxObjectSize) {
 	debug(20, 2) ("storeCheckCachable: NO: too big\n");
 	store_check_cachable_hist.no.too_big++;
     } else if (e->mem_obj->reply->content_length > (int) Config.Store.maxObjectSize) {
@@ -769,8 +769,8 @@ storeMaintainSwapSpace(void *datanotused)
     /* walk each fs */
     for (i = 0; i < Config.cacheSwap.n_configured; i++) {
 	/* call the maintain function .. */
-	SD = INDEXSD(i); 
-        if (SD->maintainfs != NULL)
+	SD = INDEXSD(i);
+	if (SD->maintainfs != NULL)
 	    SD->maintainfs(SD);
     }
 
@@ -1269,24 +1269,25 @@ storeFsDone(void)
     int i = 0;
 
     while (storefs_list[i].typestr != NULL) {
-        storefs_list[i].donefunc();
+	storefs_list[i].donefunc();
 	i++;
     }
 }
 
 /*
  * called to add another store fs module
  */
-void storeFsAdd(char *type, STSETUP *setup)
+void
+storeFsAdd(char *type, STSETUP * setup)
 {
     int i;
     /* find the number of currently known storefs types */
     for (i = 0; storefs_list && storefs_list[i].typestr; i++) {
-	assert(strcmp(storefs_list[i].typestr, type)!=0);
+	assert(strcmp(storefs_list[i].typestr, type) != 0);
     }
     /* add the new type */
     storefs_list = xrealloc(storefs_list, (i + 2) * sizeof(storefs_entry_t));
-    memset(&storefs_list[i+1],0,sizeof(storefs_entry_t));
+    memset(&storefs_list[i + 1], 0, sizeof(storefs_entry_t));
     storefs_list[i].typestr = type;
     /* Call the FS to set up capabilities and initialize the FS driver */
     setup(&storefs_list[i]);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_client.cc,v 1.88 2000/05/07 16:18:20 adrian Exp $
+ * $Id: store_client.cc,v 1.89 2000/05/12 00:29:09 wessels Exp $
  *
  * DEBUG: section 20    Storage Manager Client-Side Interface
  * AUTHOR: Duane Wessels
@@ -59,7 +59,7 @@ storeClientWaiting(const StoreEntry * e)
     dlink_node *node;
     store_client *sc;
     for (node = mem->clients.head; node; node = node->next) {
-        sc = (store_client *)node->data;
+	sc = (store_client *) node->data;
 	if (sc->callback_data != NULL)
 	    return 1;
     }
@@ -73,7 +73,7 @@ storeClientListSearch(const MemObject * mem, void *data)
     dlink_node *node;
     store_client *sc = NULL;
     for (node = mem->clients.head; node; node = node->next) {
-        sc = (store_client *)node->data;
+	sc = (store_client *) node->data;
 	if (sc->callback_data == data)
 	    return sc;
     }
@@ -129,7 +129,7 @@ storeClientListAdd(StoreEntry * e, void *data)
     assert(mem);
 #if STORE_CLIENT_LIST_DEBUG
     if (storeClientListSearch(mem, data) != NULL)
-	assert(1==0); /* XXX die! */
+	assert(1 == 0);		/* XXX die! */
 #endif
     e->refcount++;
     mem->nclients++;
@@ -178,7 +178,7 @@ storeClientCopyEvent(void *data)
 
 /* copy bytes requested by the client */
 void
-storeClientCopy(store_client *sc,
+storeClientCopy(store_client * sc,
     StoreEntry * e,
     off_t seen_offset,
     off_t copy_offset,
@@ -317,9 +317,9 @@ storeClientCopy3(StoreEntry * e, store_client * sc)
 	/* What the client wants is in memory */
 	debug(20, 3) ("storeClientCopy3: Copying from memory\n");
 	sz = stmemCopy(&mem->data_hdr,
-  	sc->copy_offset, sc->copy_buf, sc->copy_size);
-        storeClientCallback(sc, sz);
-        return;
+	    sc->copy_offset, sc->copy_buf, sc->copy_size);
+	storeClientCallback(sc, sz);
+	return;
     }
     /* What the client wants is not in memory. Schedule a disk read */
     assert(STORE_DISK_CLIENT == sc->type);
@@ -467,7 +467,7 @@ storeClientReadHeader(void *data, const char *buf, ssize_t len)
 }
 
 int
-storeClientCopyPending(store_client *sc, StoreEntry * e, void *data)
+storeClientCopyPending(store_client * sc, StoreEntry * e, void *data)
 {
 #if STORE_CLIENT_LIST_DEBUG
     assert(sc == storeClientListSearch(e->mem_obj, data));
@@ -485,50 +485,50 @@ storeClientCopyPending(store_client *sc, StoreEntry * e, void *data)
  * passed sc. Yet.
  */
 int
-storeUnregister(store_client *sc, StoreEntry * e, void *data)
+storeUnregister(store_client * sc, StoreEntry * e, void *data)
 {
     MemObject *mem = e->mem_obj;
 #if STORE_CLIENT_LIST_DEBUG
     assert(sc == storeClientListSearch(e->mem_obj, data));
 #endif
     if (mem == NULL)
-        return 0;
+	return 0;
     debug(20, 3) ("storeUnregister: called for '%s'\n", storeKeyText(e->key));
     if (sc == NULL)
-        return 0;
+	return 0;
     if (mem->clients.head == NULL)
-        return 0;
-    if (sc == (store_client *)mem->clients.head->data) {
-        /*
-         * If we are unregistering the _first_ client for this
-         * entry, then we have to reset the client FD to -1.
-         */
-        mem->fd = -1;
+	return 0;
+    if (sc == (store_client *) mem->clients.head->data) {
+	/*
+	 * If we are unregistering the _first_ client for this
+	 * entry, then we have to reset the client FD to -1.
+	 */
+	mem->fd = -1;
     }
     dlinkDelete(&sc->node, &mem->clients);
     mem->nclients--;
     if (e->store_status == STORE_OK && e->swap_status != SWAPOUT_DONE)
-        storeSwapOut(e);
+	storeSwapOut(e);
     if (sc->swapin_sio) {
-        storeClose(sc->swapin_sio);
-        cbdataUnlock(sc->swapin_sio);
-        sc->swapin_sio = NULL;
+	storeClose(sc->swapin_sio);
+	cbdataUnlock(sc->swapin_sio);
+	sc->swapin_sio = NULL;
     }
     if (NULL != sc->callback) {
-        /* callback with ssize = -1 to indicate unexpected termination */
-        debug(20, 3) ("storeUnregister: store_client for %s has a callback\n",
-            mem->url);
-        storeClientCallback(sc, -1);
+	/* callback with ssize = -1 to indicate unexpected termination */
+	debug(20, 3) ("storeUnregister: store_client for %s has a callback\n",
+	    mem->url);
+	storeClientCallback(sc, -1);
     }
 #if DELAY_POOLS
     delayUnregisterDelayIdPtr(&sc->delay_id);
 #endif
-    cbdataUnlock(sc->callback_data);    /* we're done with it now */
+    cbdataUnlock(sc->callback_data);	/* we're done with it now */
     /*assert(!sc->flags.disk_io_pending); */
     cbdataFree(sc);
     assert(e->lock_count > 0);
     if (mem->nclients == 0)
-        CheckQuickAbort(e);
+	CheckQuickAbort(e);
     return 1;
 }
 
@@ -542,7 +542,7 @@ storeLowestMemReaderOffset(const StoreEntry * entry)
     dlink_node *node;
 
     for (node = mem->clients.head; node; node = nx) {
-        sc = (store_client *)node->data;
+	sc = (store_client *) node->data;
 	nx = node->next;
 	if (sc->callback_data == NULL)	/* open slot */
 	    continue;
@@ -570,7 +570,7 @@ InvokeHandlers(StoreEntry * e)
     debug(20, 3) ("InvokeHandlers: %s\n", storeKeyText(e->key));
     /* walk the entire list looking for valid callbacks */
     for (node = mem->clients.head; node; node = nx) {
-        sc = (store_client *)node->data;
+	sc = (store_client *) node->data;
 	nx = node->next;
 	debug(20, 3) ("InvokeHandlers: checking client #%d\n", i++);
 	if (sc->callback_data == NULL)
@@ -1,5 +1,5 @@
 /*
- * $Id: store_digest.cc,v 1.39 2000/05/06 16:44:26 adrian Exp $
+ * $Id: store_digest.cc,v 1.40 2000/05/12 00:29:09 wessels Exp $
  *
  * DEBUG: section 71    Store Digest Manager
  * AUTHOR: Alex Rousskov
@@ -230,7 +230,7 @@ storeDigestAddable(const StoreEntry * e)
      * idea: skip objects that are going to be purged before the next
      * update.
      */
-#if 0 /* This code isn't applicable anymore, we can't fix it atm either :( */
+#if 0				/* This code isn't applicable anymore, we can't fix it atm either :( */
 #if !HEAP_REPLACEMENT
     if ((squid_curtime + Config.digest.rebuild_period) - e->lastref > storeExpiredReferenceAge())
 	return 0;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_dir.cc,v 1.107 2000/05/03 17:15:43 adrian Exp $
+ * $Id: store_dir.cc,v 1.108 2000/05/12 00:29:09 wessels Exp $
  *
  * DEBUG: section 47    Store Directory Routines
  * AUTHOR: Duane Wessels
@@ -88,18 +88,18 @@ storeDirValidSwapDirSize(int swapdir, size_t objsize)
      * If the swapdir's max_obj_size is -1, then it definitely can
      */
     if (Config.cacheSwap.swapDirs[swapdir].max_objsize == -1)
-        return 1;
+	return 1;
     /*
      * Else, make sure that the max object size is larger than objsize
      */
     if (Config.cacheSwap.swapDirs[swapdir].max_objsize > objsize)
-        return 1;
+	return 1;
     else
-        return 0;
+	return 0;
 }
 
 
-#if UNUSED /* Squid-2..4.DEVEL3 code */
+#if UNUSED			/* Squid-2..4.DEVEL3 code */
 /*
  * This new selection scheme simply does round-robin on all SwapDirs.
  * A SwapDir is skipped if it is over the max_size (100%) limit.  If
@@ -179,7 +179,7 @@ storeDirSelectSwapDir(void)
  * we sort out the real usefulness of this algorithm.
  */
 int
-storeDirSelectSwapDir(const StoreEntry *e)
+storeDirSelectSwapDir(const StoreEntry * e)
 {
     size_t objsize;
     size_t least_size;
@@ -198,28 +198,28 @@ storeDirSelectSwapDir(const StoreEntry *e)
     least_size = Config.cacheSwap.swapDirs[0].cur_size;
     least_objsize = Config.cacheSwap.swapDirs[0].max_objsize;
     for (i = 0; i < Config.cacheSwap.n_configured; i++) {
-        SD = &Config.cacheSwap.swapDirs[i];
+	SD = &Config.cacheSwap.swapDirs[i];
 	SD->flags.selected = 0;
-        if (SD->flags.read_only)
-            continue;
-        /* Valid for object size check */
-        if (!storeDirValidSwapDirSize(i, objsize))
-            continue;
-        load = SD->checkobj(SD, e);
-        if (load < 0)
+	if (SD->flags.read_only)
+	    continue;
+	/* Valid for object size check */
+	if (!storeDirValidSwapDirSize(i, objsize))
+	    continue;
+	load = SD->checkobj(SD, e);
+	if (load < 0)
+	    continue;
+	if (SD->cur_size > SD->max_size)
 	    continue;
-        if (SD->cur_size > SD->max_size)
-            continue;
-        if (load > least_load)
-            continue;
-        if ((least_objsize > 0) && (objsize > least_objsize))
-            continue;
-        /* Only use leastsize if the load is equal */
-        if ((load == least_load) && (SD->cur_size > least_size))
-            continue;
-        least_load = load;
-        least_size = SD->cur_size;
-        dirn = i;
+	if (load > least_load)
+	    continue;
+	if ((least_objsize > 0) && (objsize > least_objsize))
+	    continue;
+	/* Only use leastsize if the load is equal */
+	if ((load == least_load) && (SD->cur_size > least_size))
+	    continue;
+	least_load = load;
+	least_size = SD->cur_size;
+	dirn = i;
     }
 
     if (dirn >= 0)
@@ -261,14 +261,14 @@ storeDirSwapLog(const StoreEntry * e, int op)
     debug(20, 3) ("storeDirSwapLog: %s %s %d %08X\n",
 	swap_log_op_str[op],
 	storeKeyText(e->key),
-        e->swap_dirn,
+	e->swap_dirn,
 	e->swap_filen);
     sd = &Config.cacheSwap.swapDirs[e->swap_dirn];
     sd->log.write(sd, e, op);
 }
 
 void
-storeDirUpdateSwapSize(SwapDir *SD, size_t size, int sign)
+storeDirUpdateSwapSize(SwapDir * SD, size_t size, int sign)
 {
     int k = ((size + 1023) >> 10) * sign;
     SD->cur_size += k;
@@ -298,11 +298,11 @@ storeDirStats(StoreEntry * sentry)
 
     /* Now go through each swapdir, calling its statfs routine */
     for (i = 0; i < Config.cacheSwap.n_configured; i++) {
-        storeAppendPrintf(sentry, "\n");
-        SD = &(Config.cacheSwap.swapDirs[i]);
-        storeAppendPrintf(sentry, "Store Directory #%d (%s): %s\n", i, SD->type,
-          storeSwapDir(i));
-        SD->statfs(SD, sentry);
+	storeAppendPrintf(sentry, "\n");
+	SD = &(Config.cacheSwap.swapDirs[i]);
+	storeAppendPrintf(sentry, "Store Directory #%d (%s): %s\n", i, SD->type,
+	    storeSwapDir(i));
+	SD->statfs(SD, sentry);
     }
 }
 
@@ -391,16 +391,16 @@ storeDirWriteCleanLogs(int reopen)
 	if (NULL == sd->log.clean.write)
 	    continue;
 #if HEAP_REPLACEMENT
-        if (NULL == sd->repl.heap.heap)
-            continue;
+	if (NULL == sd->repl.heap.heap)
+	    continue;
 #endif
 #if HEAP_REPLACEMENT
-        for (node = 0; node < heap_nodes(sd->repl.heap.heap); node++)
+	for (node = 0; node < heap_nodes(sd->repl.heap.heap); node++)
 #else
 	storeDirLRUWalkInitHead(sd);
-        while ((e = storeDirLRUWalkNext(sd)) != NULL)
+	while ((e = storeDirLRUWalkNext(sd)) != NULL)
 #endif
-        {
+	{
 #if HEAP_REPLACEMENT
 	    e = (StoreEntry *) heap_peep(sd->repl.heap.heap, node);
 #endif
@@ -422,8 +422,8 @@ storeDirWriteCleanLogs(int reopen)
 		debug(20, 1) ("  %7d entries written so far.\n", n);
 	    }
 	}
-        /* Flush */
-        sd->log.clean.write(NULL, sd);
+	/* Flush */
+	sd->log.clean.write(NULL, sd);
     }
     if (reopen)
 	storeDirOpenSwapLogs();
@@ -446,9 +446,9 @@ storeDirSync(void)
     SwapDir *SD;
 
     for (i = 0; i < Config.cacheSwap.n_configured; i++) {
-        SD = &Config.cacheSwap.swapDirs[i];
-        if (SD->sync != NULL)
-            SD->sync(SD);
+	SD = &Config.cacheSwap.swapDirs[i];
+	if (SD->sync != NULL)
+	    SD->sync(SD);
     }
 }
 
@@ -462,13 +462,13 @@ storeDirCallback(void)
     SwapDir *SD;
 
     for (i = 0; i < Config.cacheSwap.n_configured; i++) {
-        SD = &Config.cacheSwap.swapDirs[i];
-        if (SD->callback != NULL)
-            SD->callback(SD);
+	SD = &Config.cacheSwap.swapDirs[i];
+	if (SD->callback != NULL)
+	    SD->callback(SD);
     }
 }
 
-#if 0 /* from Squid-2.4.DEVEL3 */
+#if 0				/* from Squid-2.4.DEVEL3 */
 void
 storeDirLRUDelete(StoreEntry * e)
 {
@@ -8,7 +8,7 @@
  * to select different polices depending on object size or type.
  */
 storeIOState *
-storeCreate(StoreEntry *e, STIOCB *file_callback, STIOCB *close_callback, void *callback_data)
+storeCreate(StoreEntry * e, STIOCB * file_callback, STIOCB * close_callback, void *callback_data)
 {
     size_t objsize;
     sdirno dirn;
@@ -17,22 +17,22 @@ storeCreate(StoreEntry *e, STIOCB *file_callback, STIOCB *close_callback, void *
     /* This is just done for logging purposes */
     objsize = objectLen(e);
     if (objsize != -1)
-        objsize += e->mem_obj->swap_hdr_sz;
+	objsize += e->mem_obj->swap_hdr_sz;
 
     /*
      * Pick the swapdir
      * We assume that the header has been packed by now ..
      */
     dirn = storeDirSelectSwapDir(e);
     if (dirn == -1) {
-        debug(20, 2) ("storeCreate: no valid swapdirs for this object\n");
-        return NULL;
+	debug(20, 2) ("storeCreate: no valid swapdirs for this object\n");
+	return NULL;
     }
-    debug (20, 2) ("storeCreate: Selected dir '%d' for obj size '%d'\n", dirn, objsize);
+    debug(20, 2) ("storeCreate: Selected dir '%d' for obj size '%d'\n", dirn, objsize);
     SD = &Config.cacheSwap.swapDirs[dirn];
 
     /* Now that we have a fs to use, call its storeCreate function */
-    return(SD->obj.create(SD, e, file_callback, close_callback, callback_data));
+    return (SD->obj.create(SD, e, file_callback, close_callback, callback_data));
 
     /* Done */
 }
@@ -42,8 +42,8 @@ storeCreate(StoreEntry *e, STIOCB *file_callback, STIOCB *close_callback, void *
  * storeOpen() is purely for reading ..
  */
 storeIOState *
-storeOpen(StoreEntry *e, STFNCB * file_callback, STIOCB * callback,
-  void *callback_data)
+storeOpen(StoreEntry * e, STFNCB * file_callback, STIOCB * callback,
+    void *callback_data)
 {
     SwapDir *SD = &Config.cacheSwap.swapDirs[e->swap_dirn];
     return SD->obj.open(SD, e, file_callback, callback, callback_data);
@@ -74,7 +74,7 @@ storeWrite(storeIOState * sio, char *buf, size_t size, off_t offset, FREE * free
 }
 
 void
-storeUnlink(StoreEntry *e)
+storeUnlink(StoreEntry * e)
 {
     SwapDir *SD = INDEXSD(e->swap_dirn);
     SD->obj.unlink(SD, e);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_log.cc,v 1.13 2000/05/03 17:15:44 adrian Exp $
+ * $Id: store_log.cc,v 1.14 2000/05/12 00:29:09 wessels Exp $
  *
  * DEBUG: section 20    Storage Manager Logging Functions
  * AUTHOR: Duane Wessels
@@ -71,7 +71,7 @@ storeLog(int tag, const StoreEntry * e)
 	(int) current_time.tv_sec,
 	(int) current_time.tv_usec / 1000,
 	storeLogTags[tag],
-        e->swap_dirn,
+	e->swap_dirn,
 	e->swap_filen,
 	reply->sline.status,
 	(int) reply->date,
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_swapin.cc,v 1.23 2000/05/03 17:15:44 adrian Exp $
+ * $Id: store_swapin.cc,v 1.24 2000/05/12 00:29:09 wessels Exp $
  *
  * DEBUG: section 20    Storage Manager Swapin Functions
  * AUTHOR: Duane Wessels
@@ -62,7 +62,7 @@ storeSwapInStart(store_client * sc)
     debug(20, 3) ("storeSwapInStart: Opening fileno %08X\n",
 	e->swap_filen);
     sc->swapin_sio = storeOpen(e, storeSwapInFileNotify, storeSwapInFileClosed,
-      sc);
+	sc);
     cbdataLock(sc->swapin_sio);
 }
 
@@ -85,11 +85,11 @@ storeSwapInFileClosed(void *data, int errflag, storeIOState * sio)
 static void
 storeSwapInFileNotify(void *data, int errflag, storeIOState * sio)
 {
-  store_client *sc = data;
-  StoreEntry *e = sc->entry;
- 
-  debug(1, 3) ("storeSwapInFileNotify: changing %d/%d to %d/%d\n", e->swap_filen, e->swap_dirn, sio->swap_filen, sio->swap_dirn);
+    store_client *sc = data;
+    StoreEntry *e = sc->entry;
+
+    debug(1, 3) ("storeSwapInFileNotify: changing %d/%d to %d/%d\n", e->swap_filen, e->swap_dirn, sio->swap_filen, sio->swap_dirn);
 
-  e->swap_filen = sio->swap_filen;
-  e->swap_dirn = sio->swap_dirn;
+    e->swap_filen = sio->swap_filen;
+    e->swap_dirn = sio->swap_dirn;
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_swapout.cc,v 1.66 2000/05/07 16:18:20 adrian Exp $
+ * $Id: store_swapout.cc,v 1.67 2000/05/12 00:29:09 wessels Exp $
  *
  * DEBUG: section 20    Storage Manager Swapout Functions
  * AUTHOR: Duane Wessels
@@ -71,8 +71,8 @@ storeSwapOutStart(StoreEntry * e)
 	xfree(buf);
 	return;
     }
-    storeLockObject(e); /* Don't lock until after create, or the replacement
-                         * code might get confused */
+    storeLockObject(e);		/* Don't lock until after create, or the replacement
+				 * code might get confused */
     /* Pick up the file number if it was assigned immediately */
     e->swap_filen = mem->swapout.sio->swap_filen;
     e->swap_dirn = mem->swapout.sio->swap_dirn;
@@ -134,8 +134,8 @@ storeSwapOut(StoreEntry * e)
      */
     swapout_size = (size_t) (mem->inmem_hi - mem->swapout.queue_offset);
     if ((e->store_status != STORE_OK) && (swapout_size < store_maxobjsize)) {
-        debug (20, 5) ("storeSwapOut: Deferring starting swapping out\n"); 
-        return;
+	debug(20, 5) ("storeSwapOut: Deferring starting swapping out\n");
+	return;
     }
     /*
      * Careful.  lowest_offset can be greater than inmem_hi, such
@@ -194,8 +194,8 @@ storeSwapOut(StoreEntry * e)
      * than the maximum object size (so we pick a -1 maxobjsize fs)
      */
     if ((e->store_status != STORE_OK) && (swapout_size < store_maxobjsize)) {
-        debug (20, 5) ("storeSwapOut: Deferring starting swapping out\n"); 
-        return;
+	debug(20, 5) ("storeSwapOut: Deferring starting swapping out\n");
+	return;
     }
     /* Ok, we have stuff to swap out.  Is there a swapout.sio open? */
     if (e->swap_status == SWAPOUT_NONE) {
@@ -210,18 +210,18 @@ storeSwapOut(StoreEntry * e)
     if (NULL == mem->swapout.sio)
 	return;
     do {
-        /*
+	/*
 	 * Evil hack time.
 	 * We are paging out to disk in page size chunks. however, later on when
 	 * we update the queue position, we might not have a page (I *think*),
 	 * so we do the actual page update here.
-         */
+	 */
 
-        if (mem->swapout.memnode == NULL) {
-            /* We need to swap out the first page */
+	if (mem->swapout.memnode == NULL) {
+	    /* We need to swap out the first page */
 	    mem->swapout.memnode = mem->data_hdr.head;
 	} else {
-            /* We need to swap out the next page */
+	    /* We need to swap out the next page */
 	    mem->swapout.memnode = mem->swapout.memnode->next;
 	}
 	/*
@@ -292,8 +292,8 @@ storeSwapOutFileClosed(void *data, int errflag, storeIOState * sio)
 	}
 	if (e->swap_filen > 0)
 	    storeUnlink(e);
-        e->swap_filen = -1;
-        e->swap_dirn = -1;
+	e->swap_filen = -1;
+	e->swap_dirn = -1;
 	e->swap_status = SWAPOUT_NONE;
 	storeReleaseRequest(e);
     } else {
@@ -356,8 +356,8 @@ storeSwapOutAble(const StoreEntry * e)
      * even if its not cachable
      */
     for (node = e->mem_obj->clients.head; node; node = node->next) {
-        if (((store_client *)node->data)->type == STORE_DISK_CLIENT)
-            return 1;
+	if (((store_client *) node->data)->type == STORE_DISK_CLIENT)
+	    return 1;
     }
     if (store_dirs_rebuilding)
 	if (!EBIT_TEST(e->flags, ENTRY_SPECIAL))
@@ -1,6 +1,6 @@
 
 /*
- * $Id: structs.h,v 1.330 2000/05/07 16:18:20 adrian Exp $
+ * $Id: structs.h,v 1.331 2000/05/12 00:29:09 wessels Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -1212,6 +1212,7 @@ struct _pingerReplyData {
     int psize;
     char payload[PINGER_PAYLOAD_SZ];
 };
+
 #endif
 
 struct _icp_common_t {
@@ -1280,7 +1281,7 @@ struct _MemObject {
     int nclients;
     struct {
 	off_t queue_offset;	/* relative to in-mem data */
-        mem_node *memnode;	/* which node we're currently paging out */
+	mem_node *memnode;	/* which node we're currently paging out */
 	storeIOState *sio;
     } swapout;
     HttpReply *reply;
@@ -1326,9 +1327,9 @@ struct _StoreEntry {
     sfileno swap_filen;
     union {
 #ifdef HEAP_REPLACEMENT
-        heap_node *node;
+	heap_node *node;
 #endif
-        dlink_node lru;
+	dlink_node lru;
     } repl;
     u_short lock_count;		/* Assume < 65536! */
     mem_status_t mem_status:3;
@@ -1348,13 +1349,13 @@ struct _SwapDir {
     size_t max_objsize;
     union {
 #ifdef HEAP_REPLACEMENT
-        struct {
-	   heap *heap;
+	struct {
+	    heap *heap;
 	} heap;
 #endif
-        struct {
-	   dlink_list list;
-	   dlink_node *walker;
+	struct {
+	    dlink_list list;
+	    dlink_node *walker;
 	} lru;
     } repl;
     int removals;
@@ -1377,7 +1378,7 @@ struct _SwapDir {
     STCALLBACK *callback;	/* Handle pending callbacks */
     STSYNC *sync;		/* Sync the directory */
     struct {
-        STOBJCREATE *create;
+	STOBJCREATE *create;
 	STOBJOPEN *open;
 	STOBJCLOSE *close;
 	STOBJREAD *read;
@@ -1882,7 +1883,7 @@ struct _diskd_queue {
     int recv_count;		/* number of messages received */
     struct {
 	char *buf;		/* shm buffer */
-	link_list *stack;	
+	link_list *stack;
 	int id;			/* sysvshm id */
     } shm;
 };
@@ -1,6 +1,6 @@
 
 /*
- * $Id: tunnel.cc,v 1.104 2000/05/02 19:55:45 hno Exp $
+ * $Id: tunnel.cc,v 1.105 2000/05/12 00:29:08 wessels Exp $
  *
  * DEBUG: section 26    Secure Sockets Layer Proxy
  * AUTHOR: Duane Wessels
@@ -382,10 +382,10 @@ sslConnectDone(int fdnotused, int status, void *data)
 	    sslState->servers->peer->host);
     else if (Config.onoff.log_ip_on_direct)
 	hierarchyNote(&sslState->request->hier, sslState->servers->code,
-		fd_table[sslState->server.fd].ipaddr);
+	    fd_table[sslState->server.fd].ipaddr);
     else
 	hierarchyNote(&sslState->request->hier, sslState->servers->code,
-		sslState->host);
+	    sslState->host);
     if (status == COMM_ERR_DNS) {
 	debug(26, 4) ("sslConnect: Unknown host: %s\n", sslState->host);
 	err = errorCon(ERR_DNS_FAIL, HTTP_NOT_FOUND);
@@ -428,14 +428,14 @@ sslStart(int fd, const char *url, request_t * request, size_t * size_ptr)
     aclCheck_t ch;
     int answer;
     /*
-       * client_addr == no_addr indicates this is an "internal" request
-       * from peer_digest.c, asn.c, netdb.c, etc and should always
-       * be allowed.  yuck, I know.
-       */
+     * client_addr == no_addr indicates this is an "internal" request
+     * from peer_digest.c, asn.c, netdb.c, etc and should always
+     * be allowed.  yuck, I know.
+     */
     if (request->client_addr.s_addr != no_addr.s_addr) {
 	/*
-	   * Check if this host is allowed to fetch MISSES from us (miss_access)
-	   */
+	 * Check if this host is allowed to fetch MISSES from us (miss_access)
+	 */
 	memset(&ch, '\0', sizeof(aclCheck_t));
 	ch.src_addr = request->client_addr;
 	ch.my_addr = request->my_addr;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: typedefs.h,v 1.102 2000/05/03 17:15:44 adrian Exp $
+ * $Id: typedefs.h,v 1.103 2000/05/12 00:29:09 wessels Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -195,11 +195,11 @@ typedef void PF(int, void *);
 /* disk.c / diskd.c callback typedefs */
 typedef void DRCB(int, const char *buf, int size, int errflag, void *data);
 							/* Disk read CB */
-typedef void DWCB(int, int, size_t, void *);		/* disk write CB */
+typedef void DWCB(int, int, size_t, void *);	/* disk write CB */
 typedef void DOCB(int, int errflag, void *data);	/* disk open CB */
 typedef void DCCB(int, int errflag, void *data);	/* disk close CB */
-typedef void DUCB(int errflag, void *data);		/* disk unlink CB */
-typedef void DTCB(int errflag, void *data);		/* disk trunc CB */
+typedef void DUCB(int errflag, void *data);	/* disk unlink CB */
+typedef void DTCB(int errflag, void *data);	/* disk trunc CB */
 
 typedef void FQDNH(const char *, void *);
 typedef void IDCB(const char *ident, void *data);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: url.cc,v 1.123 2000/05/03 17:15:44 adrian Exp $
+ * $Id: url.cc,v 1.124 2000/05/12 00:29:10 wessels Exp $
  *
  * DEBUG: section 23    URL Parsing
  * AUTHOR: Duane Wessels
@@ -243,10 +243,10 @@ urlParse(method_t method, char *url)
 	port = urlDefaultPort(protocol);
 	/* Is there any login informaiton? */
 	if ((t = strrchr(host, '@'))) {
-	    strcpy((char *)login, (char *)host);
+	    strcpy((char *) login, (char *) host);
 	    t = strrchr(login, '@');
 	    *t = 0;
-	    strcpy((char *)host, t + 1);
+	    strcpy((char *) host, t + 1);
 	}
 	if ((t = strrchr(host, ':'))) {
 	    *t++ = '\0';