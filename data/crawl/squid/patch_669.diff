@@ -1,3 +1,15 @@
+Changes to squid-3.2.0.7 (19 Apr 2011):
+
+	- Regression fix: NTLM and Negotiate auth assertion "RefCountCount() == 2"
+	- Regression fix: icons/ FHS compliance
+	- Regression fix: Startup aborts with URL error when --disable-htcp
+	- Bug 3192: comm.cc:216: "fd_table[fd].halfClosedReader != NULL"
+	- Add negotiate_wrapper_auth version 1.0.1
+	- Fixed %dt logging in the presence of REQMOD
+	- Fixed chunked request forwarding in ICAP REQMOD presence
+	- ... all bug fixes and updates from 3.1.12.1
+	- ... many code polishings and display cleanups
+
 Changes to squid-3.2.0.6 (04 Apr 2011):
 
 	- Regression fix: upgrade existing icons
@@ -152,6 +164,16 @@ Changes to squid-3.2.0.1 (03 Aug 2010):
 	- ... and a great many testing improvements
 	- ... and many documentation updates
 
+Changes to squid-3.1.12.1 (19 Apr 2011):
+
+	- Port from 3.2: Dynamic SSL Certificate generation
+	- Bug 3194: selinux may prevent ntlm_smb_lm_auth from using /tmp
+	- Bug 3185: 3.1.11 fails to compile on OpenBSD 4.8 and 4.9
+	- Bug 3183: Invalid URL accepted with url host part of only '@'
+	- Display ERROR in cache.log for invalid configured paths
+	- Cache Manager: send User-Agent header from cachemgr.cgi
+	- ... and many portability compile fixes for non-GCC systems.
+
 Changes to squid-3.1.12 (04 Apr 2011):
 
 	- Regression fix: Use bigger buffer for server reads.
@@ -0,0 +1,157 @@
+# pkg.m4 - Macros to locate and utilise pkg-config.            -*- Autoconf -*-
+# serial 1 (pkg-config-0.24)
+# 
+# Copyright Â© 2004 Scott James Remnant <scott@netsplit.com>.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that program.
+
+# PKG_PROG_PKG_CONFIG([MIN-VERSION])
+# ----------------------------------
+AC_DEFUN([PKG_PROG_PKG_CONFIG],
+[m4_pattern_forbid([^_?PKG_[A-Z_]+$])
+m4_pattern_allow([^PKG_CONFIG(_PATH)?$])
+AC_ARG_VAR([PKG_CONFIG], [path to pkg-config utility])
+AC_ARG_VAR([PKG_CONFIG_PATH], [directories to add to pkg-config's search path])
+AC_ARG_VAR([PKG_CONFIG_LIBDIR], [path overriding pkg-config's built-in search path])
+
+if test "x$ac_cv_env_PKG_CONFIG_set" != "xset"; then
+	AC_PATH_TOOL([PKG_CONFIG], [pkg-config])
+fi
+if test -n "$PKG_CONFIG"; then
+	_pkg_min_version=m4_default([$1], [0.9.0])
+	AC_MSG_CHECKING([pkg-config is at least version $_pkg_min_version])
+	if $PKG_CONFIG --atleast-pkgconfig-version $_pkg_min_version; then
+		AC_MSG_RESULT([yes])
+	else
+		AC_MSG_RESULT([no])
+		PKG_CONFIG=""
+	fi
+fi[]dnl
+])# PKG_PROG_PKG_CONFIG
+
+# PKG_CHECK_EXISTS(MODULES, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])
+#
+# Check to see whether a particular set of modules exists.  Similar
+# to PKG_CHECK_MODULES(), but does not set variables or print errors.
+#
+# Please remember that m4 expands AC_REQUIRE([PKG_PROG_PKG_CONFIG])
+# only at the first occurence in configure.ac, so if the first place
+# it's called might be skipped (such as if it is within an "if", you
+# have to call PKG_CHECK_EXISTS manually
+# --------------------------------------------------------------
+AC_DEFUN([PKG_CHECK_EXISTS],
+[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl
+if test -n "$PKG_CONFIG" && \
+    AC_RUN_LOG([$PKG_CONFIG --exists --print-errors "$1"]); then
+  m4_default([$2], [:])
+m4_ifvaln([$3], [else
+  $3])dnl
+fi])
+
+# _PKG_CONFIG([VARIABLE], [COMMAND], [MODULES])
+# ---------------------------------------------
+m4_define([_PKG_CONFIG],
+[if test -n "$$1"; then
+    pkg_cv_[]$1="$$1"
+ elif test -n "$PKG_CONFIG"; then
+    PKG_CHECK_EXISTS([$3],
+                     [pkg_cv_[]$1=`$PKG_CONFIG --[]$2 "$3" 2>/dev/null`],
+		     [pkg_failed=yes])
+ else
+    pkg_failed=untried
+fi[]dnl
+])# _PKG_CONFIG
+
+# _PKG_SHORT_ERRORS_SUPPORTED
+# -----------------------------
+AC_DEFUN([_PKG_SHORT_ERRORS_SUPPORTED],
+[AC_REQUIRE([PKG_PROG_PKG_CONFIG])
+if $PKG_CONFIG --atleast-pkgconfig-version 0.20; then
+        _pkg_short_errors_supported=yes
+else
+        _pkg_short_errors_supported=no
+fi[]dnl
+])# _PKG_SHORT_ERRORS_SUPPORTED
+
+
+# PKG_CHECK_MODULES(VARIABLE-PREFIX, MODULES, [ACTION-IF-FOUND],
+# [ACTION-IF-NOT-FOUND])
+#
+#
+# Note that if there is a possibility the first call to
+# PKG_CHECK_MODULES might not happen, you should be sure to include an
+# explicit call to PKG_PROG_PKG_CONFIG in your configure.ac
+#
+#
+# --------------------------------------------------------------
+AC_DEFUN([PKG_CHECK_MODULES],
+[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl
+AC_ARG_VAR([$1][_CFLAGS], [C compiler flags for $1, overriding pkg-config])dnl
+AC_ARG_VAR([$1][_LIBS], [linker flags for $1, overriding pkg-config])dnl
+
+pkg_failed=no
+AC_MSG_CHECKING([for $1])
+
+_PKG_CONFIG([$1][_CFLAGS], [cflags], [$2])
+_PKG_CONFIG([$1][_LIBS], [libs], [$2])
+
+m4_define([_PKG_TEXT], [Alternatively, you may set the environment variables $1[]_CFLAGS
+and $1[]_LIBS to avoid the need to call pkg-config.
+See the pkg-config man page for more details.])
+
+if test $pkg_failed = yes; then
+   	AC_MSG_RESULT([no])
+        _PKG_SHORT_ERRORS_SUPPORTED
+        if test $_pkg_short_errors_supported = yes; then
+	        $1[]_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors "$2" 2>&1`
+        else 
+	        $1[]_PKG_ERRORS=`$PKG_CONFIG --print-errors "$2" 2>&1`
+        fi
+	# Put the nasty error message in config.log where it belongs
+	echo "$$1[]_PKG_ERRORS" >&AS_MESSAGE_LOG_FD
+
+	m4_default([$4], [AC_MSG_ERROR(
+[Package requirements ($2) were not met:
+
+$$1_PKG_ERRORS
+
+Consider adjusting the PKG_CONFIG_PATH environment variable if you
+installed software in a non-standard prefix.
+
+_PKG_TEXT])dnl
+        ])
+elif test $pkg_failed = untried; then
+     	AC_MSG_RESULT([no])
+	m4_default([$4], [AC_MSG_FAILURE(
+[The pkg-config script could not be found or is too old.  Make sure it
+is in your PATH or set the PKG_CONFIG environment variable to the full
+path to pkg-config.
+
+_PKG_TEXT
+
+To get pkg-config, see <http://pkg-config.freedesktop.org/>.])dnl
+        ])
+else
+	$1[]_CFLAGS=$pkg_cv_[]$1[]_CFLAGS
+	$1[]_LIBS=$pkg_cv_[]$1[]_LIBS
+        AC_MSG_RESULT([yes])
+	$3
+fi[]dnl
+])# PKG_CHECK_MODULES
@@ -3446,6 +3446,7 @@ AC_CONFIG_FILES([\
 	helpers/negotiate_auth/Makefile \
 	helpers/negotiate_auth/kerberos/Makefile \
 	helpers/negotiate_auth/SSPI/Makefile \
+	helpers/negotiate_auth/wrapper/Makefile \
 	helpers/external_acl/Makefile \
 	helpers/external_acl/AD_group/Makefile \
 	helpers/external_acl/eDirectory_userip/Makefile \
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.1.12 release notes</title>
+<title>Squid 3.1.12.1 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.1.12
+The Squid Team are pleased to announce the release of Squid-3.1.12.1
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.1/"> or the <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
 
@@ -62,6 +62,7 @@ The most important of these new features are:
 	<item>eCAP Adaptation Module support
 	<item>ICAP Bypass and Retry enhancements
 	<item>ICY streaming protocol support
+	<item>Dynamic SSL Certificate Generation (3.1.12.1 and later)
 </itemize>
 
 Most user-facing changes are reflected in squid.conf (see below).
@@ -287,6 +288,25 @@ Microsoft NTLM Authentication instead of HTTP standard authentication through a
   configuration. Use of interception for port 443 is not officially supported, despite
   being known to work under certain limited networking circumstances.
 
+<sect1> Dynamic SSL Certificate Generation
+<p> SslBump users know how many certificate warnings a single complex site
+(using dedicated image, style, and/or advertisement servers for embedded content)
+can generate. The warnings are legitimate and are caused by Squid-provided site
+certificate. Two things may be wrong with that certificate:
+<itemize>
+   <item> Squid certificate is not signed by a trusted authority.
+   <item> Squid certificate name does not match the site domain name.
+</itemize>
+Squid can do nothing about (A), but in most targeted environments, users will
+trust the "man in the middle" authority and install the corresponding root
+certificate.
+  
+<p>To avoid mismatch (B), the DynamicSslCert feature concentrates on generating  
+site certificates that match the requested site domain name. Please note that
+the browser site name check does not really add much security in an SslBump
+environment where the user already trusts the "man in the middle". The check
+only adds warnings and creates page rendering problems in browsers that try to
+reduce the number of warnings by blocking some embedded content.
 
 <sect1>eCAP Adaptation Module support
 
@@ -894,6 +914,12 @@ NOCOMMENT_START
 # ssl_bump allow all
 	</verb>
 
+	<tag>sslcrtd_program</tag>
+	<p>Specify the location and options of the executable for ssl_crtd process.
+
+	<tag>sslcrtd_children</tag>
+	<p> Configures the number of sslcrtd processes to spawn
+
 	<tag>sslproxy_cert_error</tag>
 	<p>New Access Control to selectively bypass server certificate validation errors.
 	   DEFAULT: None bypassed.
@@ -1379,6 +1405,10 @@ This section gives an account of those changes in three categories:
 	   original or indirect client when a request has been forwarded through other
 	   proxies.
 
+	<tag>--enable-ssl-crtd</tag>
+	<p>Prevent Squid from direct generation of SSL private key and
+	certificate request and instead enables the <em>ssl_crtd</em> processes.
+
 	<tag>--enable-zph-qos</tag>
 	<p>Build with support for ZPH Quality of Service controls
 
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.2.0.6 release notes</title>
+<title>Squid 3.2.0.7 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.2.0.6 for testing.
+The Squid Team are pleased to announce the release of Squid-3.2.0.7 for testing.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.2/"> or the <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
 
@@ -42,7 +42,6 @@ The 3.2 change history can be <url url="http://www.squid-cache.org/Versions/v3/3
 	<item>Surrogate/1.0 protocol extensions to HTTP
 	<item>Logging Infrastructure Updated
 	<item>Client Bandwidth Limits
-	<item>Dynamic SSL Certificate Generation
 	<item>Better eCAP support
 </itemize>
 
@@ -208,6 +207,7 @@ Most user-facing changes are reflected in squid.conf (see below).
 <p><itemize>
 	<item>squid_kerb_auth - negotiate_kerberos_auth - Authenticate with Kerberos servers.
 	<item>mswin_sspi - negotiate_sspi_auth - Authenticate with a Windows Domain Controller using SSPI.
+	<item>negotiate_wrapper - negotiate_wrapper_auth - Split Negotiate traffic between Kerberos and NTLM helpers.
 </itemize>
 
 <sect2>NTLM Authentication protocol helpers
@@ -321,26 +321,6 @@ Most user-facing changes are reflected in squid.conf (see below).
    response data from Squid.  This delay may need to be lowered in 
    high-bandwidth environments.
 
-<sect1> Dynamic SSL Certificate Generation
-<p> SslBump users know how many certificate warnings a single complex site 
-(using dedicated image, style, and/or advertisement servers for embedded content)
-can generate. The warnings are legitimate and are caused by Squid-provided site
-certificate. Two things may be wrong with that certificate:
-<itemize>
-   <item> Squid certificate is not signed by a trusted authority.
-   <item> Squid certificate name does not match the site domain name. 
-</itemize>
-Squid can do nothing about (A), but in most targeted environments, users will 
-trust the "man in the middle" authority and install the corresponding root
-certificate.
-
-<p>To avoid mismatch (B), the DynamicSslCert feature concentrates on generating
-site certificates that match the requested site domain name. Please note that
-the browser site name check does not really add much security in an SslBump
-environment where the user already trusts the "man in the middle". The check
-only adds warnings and creates page rendering problems in browsers that try to
-reduce the number of warnings by blocking some embedded content. 
-
 <sect>Changes to squid.conf since Squid-3.1
 <p>
 There have been changes to Squid's configuration file since Squid-3.1.
@@ -447,12 +427,6 @@ This section gives a thorough account of those changes in three categories:
 
 	<tag>write_timeout</tag>
 	<p>New setting to limit time spent waiting for data writes to be confirmed.
-
-        <tag>sslcrtd_program</tag>
-        <p>Specify the location and options of the executable for ssl_crtd process.
-
-        <tag>sslcrtd_children</tag>
-        <p> Configures the number of sslcrtd processes to spawn
 </descrip>
 
 <sect1>Changes to existing tags<label id="modifiedtags">
@@ -665,10 +639,6 @@ This section gives an account of those changes in three categories:
 	<tag>--without-netfiler-conntrack</tag>
 	<p>Disables the libnetfilter_conntrack library being used for the new qos_flows option <em>mark</em>.
 	   default is to auto-detect the library and use where available.
-
-        <tag>--enable-ssl-crtd</tag>
-        <p>  Prevent Squid from directly generation of SSL private key and 
-        certificate request and instead enables the ssl_crtd processes.
 </descrip>
 
 <sect1>Changes to existing options<label id="modifiedoptions">
@@ -1,3 +1,3 @@
 
-DIST_SUBDIRS	= kerberos SSPI
+DIST_SUBDIRS	= kerberos SSPI wrapper
 SUBDIRS		= $(NEGOTIATE_AUTH_HELPERS)
@@ -0,0 +1,8 @@
+include $(top_srcdir)/src/Common.am
+
+EXTRA_DIST = config.test
+
+libexec_PROGRAMS = negotiate_wrapper_auth
+
+negotiate_wrapper_auth_SOURCES = negotiate_wrapper.cc nw_base64.cc nw_base64.h
+negotiate_wrapper_auth_LDADD =  $(COMPAT_LIB) $(XTRA_LIBS)
@@ -0,0 +1,2 @@
+#!/bin/sh
+exit 0
@@ -0,0 +1,420 @@
+/*
+ * -----------------------------------------------------------------------------
+ *
+ * Author: Markus Moeller (markus_moeller at compuserve.com)
+ *
+ * Copyright (C) 2011 Markus Moeller. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
+ *
+ * -----------------------------------------------------------------------------
+ */
+/*
+ * Hosted at http://sourceforge.net/projects/squidkerbauth
+ */
+
+#include "config.h"
+#include "nw_base64.h"
+
+#if HAVE_STRING_H
+#include <string.h>
+#endif
+#if HAVE_STDIO_H
+#include <stdio.h>
+#endif
+#if HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#if HAVE_NETDB_H
+#include <netdb.h>
+#endif
+#if HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#if HAVE_TIME_H
+#include <time.h>
+#endif
+#if HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#if HAVE_ERRNO_H
+#include <errno.h>
+#endif
+
+#if !defined(HAVE_DECL_XMALLOC) || !HAVE_DECL_XMALLOC
+#define xmalloc malloc
+#endif
+#if !defined(HAVE_DECL_XSTRDUP) || !HAVE_DECL_XSTRDUP
+#define xstrdup strdup
+#endif
+#if !defined(HAVE_DECL_XFREE) || !HAVE_DECL_XFREE
+#define xfree free
+#endif
+
+#undef PROGRAM
+#define PROGRAM "negotiate_wrapper"
+#undef VERSION
+#define VERSION "1.0.1"
+
+#ifndef MAX_AUTHTOKEN_LEN
+#define MAX_AUTHTOKEN_LEN   65535
+#endif
+
+static const unsigned char ntlmProtocol[] = {'N', 'T', 'L', 'M', 'S', 'S', 'P', 0};
+
+static const char *
+LogTime()
+{
+    struct timeval now;
+    static time_t last_t = 0;
+    static char buf[128];
+
+    gettimeofday(&now, NULL);
+    if (now.tv_sec != last_t) {
+        time_t *tmp = (time_t *) & now.tv_sec;
+        struct tm *tm = localtime(tmp);
+        strftime(buf, 127, "%Y/%m/%d %H:%M:%S", tm);
+        last_t = now.tv_sec;
+    }
+    return buf;
+}
+
+void usage(void)
+{
+    fprintf(stderr, "Usage: \n");
+    fprintf(stderr, "negotiate_wrapper [-h] [-d] --ntlm ntlm helper + arguments --kerberos kerberos helper + arguments\n");
+    fprintf(stderr, "-h help\n");
+    fprintf(stderr, "-d full debug\n");
+    fprintf(stderr, "--ntlm full ntlm helper path with arguments\n");
+    fprintf(stderr, "--kerberos full kerberos helper path with arguments\n");
+}
+
+int
+main(int argc, char *const argv[])
+{
+    char buf[MAX_AUTHTOKEN_LEN];
+    char tbuff[MAX_AUTHTOKEN_LEN];
+    char buff[MAX_AUTHTOKEN_LEN+2];
+    char *c;
+    static int err = 0;
+    int debug = 0;
+    int length;
+    int nstart = 0, kstart = 0;
+    int nend = 0, kend = 0;
+    char *token;
+    char **nargs, **kargs;
+    int i,j;
+    int fpid;
+    FILE *FDKIN,*FDKOUT;
+    FILE *FDNIN,*FDNOUT;
+    int pkin[2];
+    int pkout[2];
+    int pnin[2];
+    int pnout[2];
+
+    setbuf(stdout, NULL);
+    setbuf(stdin, NULL);
+
+    if (argc ==1 || !strncasecmp(argv[1],"-h",2)) {
+        usage();
+        return 0;
+    }
+
+    j = 1;
+    if (!strncasecmp(argv[1],"-d",2)) {
+        debug = 1;
+        j = 2;
+    }
+
+    for (i=j; i<argc; i++) {
+        if (!strncasecmp(argv[i],"--ntlm",6))
+            nstart = i;
+        if (!strncasecmp(argv[i],"--kerberos",10))
+            kstart = i;
+    }
+    if (nstart > kstart) {
+        kend = nstart-1;
+        nend = argc-1;
+    } else {
+        kend = argc-1;
+        nend = kstart-1;
+    }
+    if (nstart == 0 || kstart == 0 || kend-kstart <= 0 || nend-nstart <= 0 ) {
+        usage();
+        return 0;
+    }
+
+    if (debug)
+        fprintf(stderr, "%s| %s: Starting version %s\n", LogTime(), PROGRAM,
+                VERSION);
+
+    if ((nargs = (char **)xmalloc((nend-nstart+1)*sizeof(char *))) == NULL) {
+        fprintf(stderr, "%s| %s: Error allocating memory for ntlm helper\n", LogTime(), PROGRAM);
+        return 1;
+    }
+    memcpy(nargs,argv+nstart+1,(nend-nstart)*sizeof(char *));
+    nargs[nend-nstart]=NULL;
+    if (debug) {
+        fprintf(stderr, "%s| %s: NTLM command: ", LogTime(), PROGRAM);
+        for (i=0; i<nend-nstart; i++)
+            fprintf(stderr, "%s ", nargs[i]);
+        fprintf(stderr, "\n");
+    }
+    if ((kargs = (char **)xmalloc((kend-kstart+1)*sizeof(char *))) == NULL) {
+        fprintf(stderr, "%s| %s: Error allocating memory for kerberos helper\n", LogTime(), PROGRAM);
+        return 1;
+    }
+    memcpy(kargs,argv+kstart+1,(kend-kstart)*sizeof(char *));
+    kargs[kend-kstart]=NULL;
+    if (debug) {
+        fprintf(stderr, "%s| %s: Kerberos command: ", LogTime(), PROGRAM);
+        for (i=0; i<kend-kstart; i++)
+            fprintf(stderr, "%s ", kargs[i]);
+        fprintf(stderr, "\n");
+    }
+    /*
+       Fork Kerberos helper and NTLM helper and manage IO to send NTLM requests
+       to the right helper. squid must keep session state
+    */
+
+    if (pipe(pkin) < 0) {
+        fprintf(stderr, "%s| %s: Could not assign streams for pkin\n", LogTime(), PROGRAM);
+        return 1;
+    }
+    if (pipe(pkout) < 0) {
+        fprintf(stderr, "%s| %s: Could not assign streams for pkout\n", LogTime(), PROGRAM);
+        return 1;
+    }
+
+
+    if  (( fpid = vfork()) < 0 ) {
+        fprintf(stderr, "%s| %s: Failed first fork\n", LogTime(), PROGRAM);
+        return 1;
+    }
+
+    if ( fpid == 0 ) {
+        /* First Child for Kerberos helper */
+
+        close(pkin[1]);
+        dup2(pkin[0],STDIN_FILENO);
+        close(pkin[0]);
+
+        close(pkout[0]);
+        dup2(pkout[1],STDOUT_FILENO);
+        close(pkout[1]);
+
+        setbuf(stdin, NULL);
+        setbuf(stdout, NULL);
+
+        execv(kargs[0], kargs);
+        fprintf(stderr, "%s| %s: Failed execv for %s: %s\n", LogTime(), PROGRAM, kargs[0], strerror(errno));
+        return 1;
+
+    }
+
+    close(pkin[0]);
+    close(pkout[1]);
+
+    if (pipe(pnin) < 0) {
+        fprintf(stderr, "%s| %s: Could not assign streams for pnin\n", LogTime(), PROGRAM);
+        return 1;
+    }
+    if (pipe(pnout) < 0) {
+        fprintf(stderr, "%s| %s: Could not assign streams for pnout\n", LogTime(), PROGRAM);
+        return 1;
+    }
+
+    if  (( fpid = vfork()) < 0 ) {
+        fprintf(stderr, "%s| %s: Failed second fork\n", LogTime(), PROGRAM);
+        return 1;
+    }
+
+    if ( fpid == 0 ) {
+        /* Second Child for NTLM helper */
+
+        close(pnin[1]);
+        dup2(pnin[0],STDIN_FILENO);
+        close(pnin[0]);
+
+        close(pnout[0]);
+        dup2(pnout[1],STDOUT_FILENO);
+        close(pnout[1]);
+
+        setbuf(stdin, NULL);
+        setbuf(stdout, NULL);
+
+        execv(nargs[0], nargs);
+        fprintf(stderr, "%s| %s: Failed execv for %s: %s\n", LogTime(), PROGRAM, nargs[0], strerror(errno));
+        return 1;
+    }
+
+    close(pnin[0]);
+    close(pnout[1]);
+
+    FDKIN=fdopen(pkin[1],"w");
+    FDKOUT=fdopen(pkout[0],"r");
+
+    FDNIN=fdopen(pnin[1],"w");
+    FDNOUT=fdopen(pnout[0],"r");
+
+    if (!FDKIN || !FDKOUT || !FDNIN || !FDNOUT) {
+        fprintf(stderr, "%s| %s: Could not assign streams for FDKIN/FDKOUT/FDNIN/FDNOUT\n", LogTime(), PROGRAM);
+        return 1;
+    }
+
+    setbuf(FDKIN, NULL);
+    setbuf(FDKOUT, NULL);
+    setbuf(FDNIN, NULL);
+    setbuf(FDNOUT, NULL);
+
+
+    while (1) {
+        if (fgets(buf, sizeof(buf) - 1, stdin) == NULL) {
+            if (ferror(stdin)) {
+                if (debug)
+                    fprintf(stderr,
+                            "%s| %s: fgets() failed! dying..... errno=%d (%s)\n",
+                            LogTime(), PROGRAM, ferror(stdin),
+                            strerror(ferror(stdin)));
+
+                fprintf(stdout, "BH input error\n");
+                return 1;        /* BIIG buffer */
+            }
+            fprintf(stdout, "BH input error\n");
+            return 0;
+        }
+        c = static_cast<char*>(memchr(buf, '\n', sizeof(buf) - 1));
+        if (c) {
+            *c = '\0';
+            length = c - buf;
+        } else {
+            err = 1;
+        }
+        if (err) {
+            if (debug)
+                fprintf(stderr, "%s| %s: Oversized message\n", LogTime(),
+                        PROGRAM);
+            fprintf(stdout, "BH Oversized message\n");
+            err = 0;
+            continue;
+        }
+        if (debug)
+            fprintf(stderr, "%s| %s: Got '%s' from squid (length: %d).\n",
+                    LogTime(), PROGRAM, buf, length);
+
+        if (buf[0] == '\0') {
+            if (debug)
+                fprintf(stderr, "%s| %s: Invalid request\n", LogTime(),
+                        PROGRAM);
+            fprintf(stdout, "BH Invalid request\n");
+            continue;
+        }
+        if (strlen(buf) < 2) {
+            if (debug)
+                fprintf(stderr, "%s| %s: Invalid request [%s]\n", LogTime(),
+                        PROGRAM, buf);
+            fprintf(stdout, "BH Invalid request\n");
+            continue;
+        }
+        if (!strncmp(buf, "QQ", 2)) {
+            fprintf(stdout, "BH quit command\n");
+            return 0;
+        }
+        if (strncmp(buf, "YR", 2) && strncmp(buf, "KK", 2)) {
+            if (debug)
+                fprintf(stderr, "%s| %s: Invalid request [%s]\n", LogTime(),
+                        PROGRAM, buf);
+            fprintf(stdout, "BH Invalid request\n");
+            continue;
+        }
+        if (strlen(buf) <= 3) {
+            if (debug)
+                fprintf(stderr, "%s| %s: Invalid negotiate request [%s]\n",
+                        LogTime(), PROGRAM, buf);
+            fprintf(stdout, "BH Invalid negotiate request\n");
+            continue;
+        }
+        length = nw_base64_decode_len(buf + 3);
+        if (debug)
+            fprintf(stderr, "%s| %s: Decode '%s' (decoded length: %d).\n",
+                    LogTime(), PROGRAM, buf + 3, (int) length);
+
+        if ((token = (char *)xmalloc(length)) == NULL) {
+            fprintf(stderr, "%s| %s: Error allocating memory for token\n", LogTime(), PROGRAM);
+            return 1;
+        }
+
+        nw_base64_decode(token, buf + 3, length);
+
+        if ((static_cast<size_t>(length) >= sizeof(ntlmProtocol) + 1) &&
+                (!memcmp(token, ntlmProtocol, sizeof ntlmProtocol))) {
+            free(token);
+            if (debug)
+                fprintf(stderr, "%s| %s: received type %d NTLM token\n",
+                        LogTime(), PROGRAM, (int) *((unsigned char *) token +
+                                                    sizeof ntlmProtocol));
+            fprintf(FDNIN, "%s\n",buf);
+            if (fgets(tbuff, sizeof(tbuff) - 1, FDNOUT) == NULL) {
+                if (ferror(FDNOUT)) {
+                    fprintf(stderr,
+                            "fgets() failed! dying..... errno=%d (%s)\n",
+                            ferror(FDNOUT), strerror(ferror(FDNOUT)));
+                    return 1;
+                }
+                fprintf(stderr, "%s| %s: Error reading NTLM helper response\n",
+                        LogTime(), PROGRAM);
+                return 0;
+            }
+            /*
+                   Need to translate NTLM reply to Negotiate reply
+                   AF user => AF blob user
+               NA reason => NA blob reason
+               Set blob to '='
+                */
+            if (strlen(tbuff) >= 3 && (!strncmp(tbuff,"AF ",3) || !strncmp(tbuff,"NA ",3))) {
+                strncpy(buff,tbuff,3);
+                buff[3]='=';
+                for (unsigned int i=2; i<=strlen(tbuff); i++)
+                    buff[i+2] = tbuff[i];
+            } else {
+                strcpy(buff,tbuff);
+            }
+        } else {
+            free(token);
+            if (debug)
+                fprintf(stderr, "%s| %s: received Kerberos token\n",
+                        LogTime(), PROGRAM);
+
+            fprintf(FDKIN, "%s\n",buf);
+            if (fgets(buff, sizeof(buff) - 1, FDKOUT) == NULL) {
+                if (ferror(FDKOUT)) {
+                    fprintf(stderr,
+                            "fgets() failed! dying..... errno=%d (%s)\n",
+                            ferror(FDKOUT), strerror(ferror(FDKOUT)));
+                    return 1;
+                }
+                fprintf(stderr, "%s| %s: Error reading Kerberos helper response\n",
+                        LogTime(), PROGRAM);
+                return 0;
+            }
+        }
+        fprintf(stdout,"%s",buff);
+        if (debug)
+            fprintf(stderr, "%s| %s: Return '%s'\n",
+                    LogTime(), PROGRAM, buff);
+    }
+
+    return 1;
+}
@@ -0,0 +1,83 @@
+/*
+ * Markus Moeller has modified the following code from Squid
+ */
+#include "config.h"
+#include "nw_base64.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+
+static void nw_base64_init(void);
+
+static int base64_initialized = 0;
+#define BASE64_VALUE_SZ 256
+int base64_value[BASE64_VALUE_SZ];
+const char base64_code[] =
+    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+
+
+static void
+nw_base64_init(void)
+{
+    int i;
+
+    for (i = 0; i < BASE64_VALUE_SZ; i++)
+        base64_value[i] = -1;
+
+    for (i = 0; i < 64; i++)
+        base64_value[(int) base64_code[i]] = i;
+    base64_value[(int)'='] = 0;
+
+    base64_initialized = 1;
+}
+
+void
+nw_base64_decode(char *result, const char *data, int result_size)
+{
+    int j;
+    int c;
+    long val;
+    if (!data)
+        return;
+    if (!base64_initialized)
+        nw_base64_init();
+    val = c = 0;
+
+    for (j = 0; *data; data++) {
+        unsigned int k = ((unsigned char) *data) % BASE64_VALUE_SZ;
+        if (base64_value[k] < 0)
+            continue;
+        val <<= 6;
+        val += base64_value[k];
+        if (++c < 4)
+            continue;
+        /* One quantum of four encoding characters/24 bit */
+        if (j >= result_size)
+            break;
+        result[j++] = val >> 16;	/* High 8 bits */
+        if (j >= result_size)
+            break;
+        result[j++] = (val >> 8) & 0xff;	/* Mid 8 bits */
+        if (j >= result_size)
+            break;
+        result[j++] = val & 0xff;	/* Low 8 bits */
+        val = c = 0;
+    }
+    return;
+}
+
+int
+nw_base64_decode_len(const char *data)
+{
+    int i, j;
+
+    j = 0;
+    for (i = strlen(data) - 1; i >= 0; i--) {
+        if (data[i] == '=')
+            j++;
+        if (data[i] != '=')
+            break;
+    }
+    return strlen(data) / 4 * 3 - j;
+}
@@ -0,0 +1,11 @@
+#ifndef _NW_BASE64_H
+#define _NW_BASE64_H
+
+/*
+ * Markus Moeller has modified the following code from Squid
+ */
+
+void nw_base64_decode(char *result, const char *data, int result_size);
+int nw_base64_decode_len(const char *data);
+
+#endif
@@ -86,19 +86,12 @@ Auth::User::credentials(CredentialState newCreds)
  * two users _can_ be merged without invalidating all the request
  * scheme data. The scheme is also responsible for merging any user
  * related scheme data itself.
+ * The caller is responsible for altering all refcount pointers to
+ * the 'from' object. They are invalid once this method is complete.
  */
 void
 Auth::User::absorb(Auth::User::Pointer from)
 {
-
-    /* RefCount children CANNOT be merged like this. The external Auth::User::Pointer's cannot be changed. */
-
-    /* check that we only have the two references:
-     * 1) our function scope
-     * 2) the parsing function scope)
-     */
-    assert(from->RefCountCount() == 2);
-
     /*
      * XXX Incomplete: it should merge in hash references too and ask the module to merge in scheme data
      *  dlink_list proxy_auth_list;
@@ -8,7 +8,7 @@ Auth::Basic::User::User(Auth::Config *aConfig) :
         Auth::User(aConfig),
         passwd(NULL),
         auth_queue(NULL),
-        currentRequest(NULL)   
+        currentRequest(NULL)
 {}
 
 Auth::Basic::User::~User()
@@ -27,7 +27,7 @@ class User : public Auth::User
     void submitRequest(AuthUserRequest::Pointer auth_user_request, RH * handler, void *data);
 
     bool valid() const;
-  
+
     /** Update the cached password for a username. */
     void updateCached(User *from);
     virtual int32_t ttl() const;
@@ -37,12 +37,12 @@ Auth::Digest::User::ttl() const
         digest_nonce_h *nonce = static_cast<digest_nonce_h *>(link->data);
         if (nonce->flags.valid && nonce->noncedata.creationtime > latest_nonce)
             latest_nonce = nonce->noncedata.creationtime;
-            
+
         link = link->next;
     }
     if (latest_nonce == -1)
         return min(-1, global_ttl);
- 
+
     int32_t nonce_ttl = latest_nonce - current_time.tv_sec + static_cast<Config*>(Auth::Config::Find("digest"))->noncemaxduration;
 
     return min(nonce_ttl, global_ttl);
@@ -4,7 +4,7 @@
 #include "auth/User.h"
 
 namespace Auth
-{  
+{
 namespace Digest
 {
 
@@ -26,7 +26,7 @@ class User : public Auth::User
     /* what nonces have been allocated to this user */
     dlink_list nonces;
 };
- 
+
 MEMPROXY_CLASS_INLINE(Auth::Digest::User);
 
 } // namespace Digest
@@ -339,8 +339,6 @@ AuthNegotiateUserRequest::HandleReply(void *data, void *lastserver, char *reply)
         safe_free(negotiate_request->server_blob);
         negotiate_request->server_blob = xstrdup(blob);
         negotiate_request->releaseAuthServer();
-        auth_user_request->user()->credentials(Auth::Ok);
-        debugs(29, 4, HERE << "Successfully validated user via Negotiate. Username '" << blob << "'");
 
         /* connection is authenticated */
         debugs(29, 4, HERE << "authenticated user " << auth_user_request->user()->username());
@@ -357,18 +355,18 @@ AuthNegotiateUserRequest::HandleReply(void *data, void *lastserver, char *reply)
              * Just free the temporary auth_user after merging as
              * much of it new state into the existing one as possible */
             usernamehash->user()->absorb(local_auth_user);
-            local_auth_user = usernamehash->user();
             /* from here on we are working with the original cached credentials. */
-            negotiate_request->_auth_user = local_auth_user;
+            local_auth_user = usernamehash->user();
+            auth_user_request->user(local_auth_user);
         } else {
             /* store user in hash's */
             local_auth_user->addToNameCache();
         }
         /* set these to now because this is either a new login from an
          * existing user or a new user */
         local_auth_user->expiretime = current_time.tv_sec;
-        negotiate_request->releaseAuthServer();
-        negotiate_request->user()->credentials(Auth::Ok);
+        auth_user_request->user()->credentials(Auth::Ok);
+        debugs(29, 4, HERE << "Successfully validated user via Negotiate. Username '" << blob << "'");
 
     } else if (strncasecmp(reply, "NA ", 3) == 0 && arg != NULL) {
         /* authentication failure (wrong password, etc.) */
@@ -313,10 +313,11 @@ AuthNTLMUserRequest::HandleReply(void *data, void *lastserver, char *reply)
         if (usernamehash) {
             /* we can't seamlessly recheck the username due to the
              * challenge-response nature of the protocol.
-             * Just free the temporary auth_user */
+             * Just free the temporary auth_user after merging as
+             * much of it new state into the existing one as possible */
             usernamehash->user()->absorb(local_auth_user);
             local_auth_user = usernamehash->user();
-            ntlm_request->_auth_user = local_auth_user;
+            auth_user_request->user(local_auth_user);
         } else {
             /* store user in hash's */
             local_auth_user->addToNameCache();