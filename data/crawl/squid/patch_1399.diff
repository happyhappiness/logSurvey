@@ -81,5 +81,6 @@ and ideas to make this software available.
 	Alex Rousskov <rousskov@ircache.net>
 	Sergio Rabellino <rabellino@di.unito.it>
 	Ian Turner <vectro@pipeline.com>
+	Moez Mahfoudh <moez.mahfoudh@imag.fr>
 
 	Duane Wessels <wessels@squid-cache.org>
@@ -2,7 +2,7 @@
 <article>
 <title>Squid Programmers Guide</title>
 <author>Duane Wessels, Squid Developers
-<date>$Id: prog-guide.sgml,v 1.29 2001/01/04 03:38:05 wessels Exp $</date>
+<date>$Id: prog-guide.sgml,v 1.30 2001/01/05 09:51:34 adrian Exp $</date>
 
 <abstract>
 Squid is a WWW Cache application developed by the National Laboratory
@@ -257,7 +257,7 @@ Squid consists of the following major components
 	and <tt/squid.conf/.  <tt/cf_parser.c/ is included directly
 	into <tt/cache_cf.c/ at compile time.
 
-<sect1>Callback Data Database
+<sect1>Callback Data Allocator
 
 	<P>
 	Squid's extensive use of callback functions makes it very
@@ -1840,10 +1840,6 @@ coupling between the storage layer and the replacement policy.
 	It should also populate the _data member with a pointer to policy
 	specific data.
 
-<P>
-	Prior to returning the created instance must be registered as
-	callback-data by calling cbdataAdd().
-
 <sect3>Walker
 
 <P>
@@ -1852,10 +1848,6 @@ coupling between the storage layer and the replacement policy.
 	policy implementation must make sure to NULL fill the structure prior
 	to populating it in order to assure future API compability.
 
-<P>
-	Prior to returning the created instance must be registered as
-	callback-data by calling cbdataAdd().
-
 <sect2>Design notes/bugs
 
 <P>
@@ -2037,8 +2029,8 @@ coupling between the storage layer and the replacement policy.
 	<P>
 	To be written...
 
-<!-- %%%% Chapter : Callback Data Base %%%% -->
-<sect>Callback Data Database
+<!-- %%%% Chapter : Callback Data Allocator %%%% -->
+<sect>Callback Data Allocator
 
 	<P>
 	Squid's extensive use of callback functions makes it very
@@ -2060,14 +2052,14 @@ coupling between the storage layer and the replacement policy.
 	before the operation completes.
 
 	<P>
-	The callback data database lets us do this in a uniform and
-	safe manner.  Every callback_data pointer must be added to the
-	database.  It is then locked while the blocking operation executes
-	elsewhere, and is freed when the operation completes.  The normal
-	sequence of events is:
+	The callback data allocator lets us do this in a uniform and
+	safe manner.  The callback data allocator is used to allocate,
+	track and free memory pool objects used during callback
+	operations.  Allocated memory is locked while the blocking
+	operation executes elsewhere, and is freed when the operation
+	completes.  The normal sequence of events is:
 <verb>
-	callback_data = malloc(...);
-	cbdataAdd(callback_data);
+	callback_data = CBDATA_ALLOC(type_of_data, free_handler);
 	...
 	cbdataLock(callback_data);
 	fooOperationStart(bar, callback_func, callback_data);
@@ -2083,8 +2075,7 @@ coupling between the storage layer and the replacement policy.
 	With this scheme, nothing bad happens if <tt/cbdataFree/ gets called
 	before <tt/cbdataUnlock/:
 <verb>
-	callback_data = malloc(...);
-	cbdataAdd(callback_data);
+	callback_data = CBDATA_ALLOC(...);
 	...
 	cbdataLock(callback_data);
 	fooOperationStart(bar, callback_func, callback_data);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: acl.cc,v 1.230 2001/01/04 04:01:17 wessels Exp $
+ * $Id: acl.cc,v 1.231 2001/01/05 09:51:36 adrian Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -898,7 +898,7 @@ aclParseAccessLine(acl_access ** head)
 	debug(28, 0) ("aclParseAccessLine: missing 'allow' or 'deny'.\n");
 	return;
     }
-    A = memAllocate(MEM_ACL_ACCESS);
+    A = CBDATA_ALLOC(acl_access, NULL);
 
     if (!strcmp(t, "allow"))
 	A->allow = 1;
@@ -908,7 +908,7 @@ aclParseAccessLine(acl_access ** head)
 	debug(28, 0) ("%s line %d: %s\n",
 	    cfg_filename, config_lineno, config_input_line);
 	debug(28, 0) ("aclParseAccessLine: expecting 'allow' or 'deny', got '%s'.\n", t);
-	memFree(A, MEM_ACL_ACCESS);
+	cbdataFree(A);
 	return;
     }
 
@@ -940,15 +940,14 @@ aclParseAccessLine(acl_access ** head)
 	debug(28, 0) ("%s line %d: %s\n",
 	    cfg_filename, config_lineno, config_input_line);
 	debug(28, 0) ("aclParseAccessLine: Access line contains no ACL's, skipping\n");
-	memFree(A, MEM_ACL_ACCESS);
+	cbdataFree(A);
 	return;
     }
     A->cfgline = xstrdup(config_input_line);
     /* Append to the end of this list */
     for (B = *head, T = head; B; T = &B->next, B = B->next);
     *T = A;
     /* We lock _acl_access structures in aclCheck() */
-    cbdataAdd(A, memFree, MEM_ACL_ACCESS);
 }
 
 /**************/
@@ -1813,8 +1812,8 @@ aclChecklistCreate(const acl_access * A,
     const char *ident)
 {
     int i;
-    aclCheck_t *checklist = memAllocate(MEM_ACLCHECK_T);
-    cbdataAdd(checklist, memFree, MEM_ACLCHECK_T);
+    aclCheck_t *checklist;
+    checklist = CBDATA_ALLOC(aclCheck_t, NULL);
     checklist->access_list = A;
     /*
      * aclCheck() makes sure checklist->access_list is a valid
@@ -1,6 +1,6 @@
 
 /*
- * $Id: asn.cc,v 1.65 2000/12/18 09:48:50 adrian Exp $
+ * $Id: asn.cc,v 1.66 2001/01/05 09:51:36 adrian Exp $
  *
  * DEBUG: section 53    AS Number handling
  * AUTHOR: Duane Wessels, Kostas Anagnostakis
@@ -151,6 +151,7 @@ asnAclInitialize(acl * acls)
 
 /* initialize the radix tree structure */
 
+CBDATA_TYPE(ASState);
 void
 asnInit(void)
 {
@@ -162,6 +163,7 @@ asnInit(void)
     rn_inithead((void **) &AS_tree_head, 8);
     asnAclInitialize(Config.aclList);
     cachemgrRegister("asndb", "AS Number Database", asnStats, 0, 1);
+    CBDATA_INIT_TYPE(ASState);
 }
 
 void
@@ -187,8 +189,8 @@ asnCacheStart(int as)
     LOCAL_ARRAY(char, asres, 4096);
     StoreEntry *e;
     request_t *req;
-    ASState *asState = xcalloc(1, sizeof(ASState));
-    cbdataAdd(asState, cbdataXfree, 0);
+    ASState *asState;
+    asState = CBDATA_ALLOC(ASState, NULL);
     debug(53, 3) ("asnCacheStart: AS %d\n", as);
     snprintf(asres, 4096, "whois://%s/!gAS%d", Config.as_whois_server, as);
     asState->as_number = as;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: authenticate.cc,v 1.13 2000/10/31 23:48:13 wessels Exp $
+ * $Id: authenticate.cc,v 1.14 2001/01/05 09:51:36 adrian Exp $
  *
  * DEBUG: section 29    Authenticator
  * AUTHOR: Duane Wessels
@@ -78,6 +78,8 @@ authenticateStats(StoreEntry * sentry)
     helperStats(sentry, authenticators);
 }
 
+CBDATA_TYPE(authenticateStateData);
+
 /**** PUBLIC FUNCTIONS ****/
 
 
@@ -94,8 +96,7 @@ authenticateStart(acl_proxy_auth_user * auth_user, RH * handler, void *data)
 	handler(data, NULL);
 	return;
     }
-    r = xcalloc(1, sizeof(authenticateStateData));
-    cbdataAdd(r, cbdataXfree, 0);
+    r = CBDATA_ALLOC(authenticateStateData, NULL);
     r->handler = handler;
     cbdataLock(data);
     r->data = data;
@@ -123,6 +124,7 @@ authenticateInit(void)
 	    authenticateStats, 0, 1);
 	init++;
     }
+    CBDATA_INIT_TYPE(authenticateStateData);
 }
 
 void
@@ -1,6 +1,6 @@
 
 /*
- * $Id: cache_cf.cc,v 1.365 2001/01/05 03:58:18 wessels Exp $
+ * $Id: cache_cf.cc,v 1.366 2001/01/05 09:51:36 adrian Exp $
  *
  * DEBUG: section 3     Configuration File Parsing
  * AUTHOR: Harvest Derived
@@ -393,8 +393,7 @@ configDoConfigure(void)
     if (Config.Wais.relayHost) {
 	if (Config.Wais.peer)
 	    cbdataFree(Config.Wais.peer);
-	Config.Wais.peer = memAllocate(MEM_PEER);
-	cbdataAdd(Config.Wais.peer, peerDestroy, MEM_PEER);
+	Config.Wais.peer = CBDATA_ALLOC(peer, peerDestroy);
 	Config.Wais.peer->host = xstrdup(Config.Wais.relayHost);
 	Config.Wais.peer->http_port = Config.Wais.relayPort;
     }
@@ -1101,7 +1100,7 @@ parse_peer(peer ** head)
     char *token = NULL;
     peer *p;
     int i;
-    p = memAllocate(MEM_PEER);
+    p = CBDATA_ALLOC(peer, peerDestroy);
     p->http_port = CACHE_HTTP_PORT;
     p->icp.port = CACHE_ICP_PORT;
     p->weight = 1;
@@ -1189,8 +1188,6 @@ parse_peer(peer ** head)
 	p->carp.hash = ROTATE_LEFT(p->carp.hash, 21);
     }
 #endif
-    /* This must preceed peerDigestCreate */
-    cbdataAdd(p, peerDestroy, MEM_PEER);
 #if USE_CACHE_DIGESTS
     if (!p->options.no_digest) {
 	p->digest = peerDigestCreate(p);
@@ -1,9 +1,10 @@
 
 /*
- * $Id: cbdata.cc,v 1.31 2000/10/31 23:48:13 wessels Exp $
+ * $Id: cbdata.cc,v 1.32 2001/01/05 09:51:36 adrian Exp $
  *
  * DEBUG: section 45    Callback Data Registry
- * AUTHOR: Duane Wessels
+ * ORIGINAL AUTHOR: Duane Wessels
+ * Modified by Moez Mahfoudh (08/12/2000)
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
  * ----------------------------------------------------------
@@ -44,16 +45,15 @@
  * 
  * In terms of time, the sequence goes something like this:
  * 
- * foo = xcalloc(sizeof(foo));
- * cbdataAdd(foo);
+ * foo = cbdataAlloc(sizeof(foo),NULL);
  * ...
- * cbdataLock(foo);
  * some_blocking_operation(..., callback_func, foo);
- * ...
- * some_blocking_operation_completes()
- * if (cbdataValid(foo))
- * callback_func(..., foo)
- * cbdataUnlock(foo);
+ *   cbdataLock(foo);
+ *   ...
+ *   some_blocking_operation_completes()
+ *   if (cbdataValid(foo))
+ *   callback_func(..., foo)
+ *   cbdataUnlock(foo);
  * ...
  * cbdataFree(foo);
  * 
@@ -66,107 +66,132 @@
 
 #include "squid.h"
 
-static hash_table *htable = NULL;
-
 static int cbdataCount = 0;
 
 typedef struct _cbdata {
-    hash_link hash;		/* must be first */
     int valid;
     int locks;
     CBDUNL *unlock_func;
-    int id;
+    int type;			/* move to CBDATA_DEBUG with type argument to cbdataFree */
 #if CBDATA_DEBUG
     const char *file;
     int line;
 #endif
+    void *y;			/* cookie used while debugging */
+    union {
+	void *pointer;
+	double double_float;
+	int integer;
+    } data;
 } cbdata;
 
-static HASHCMP cbdata_cmp;
-static HASHHASH cbdata_hash;
-static void cbdataReallyFree(cbdata * c);
 static OBJH cbdataDump;
-static MemPool *cbdata_pool = NULL;
 
-static int
-cbdata_cmp(const void *p1, const void *p2)
+static MemPool **cbdata_memory_pool = NULL;
+int cbdata_types = 0;
+
+#define OFFSET_OF(type, member) ((int)(char *)&((type *)0L)->member)
+
+void
+cbdataInitType(cbdata_type type, char *name, int size)
 {
-    return (char *) p1 - (char *) p2;
+    char *label;
+    if (type >= cbdata_types) {
+	cbdata_memory_pool = xrealloc(cbdata_memory_pool, (type + 1) * sizeof(*cbdata_memory_pool));
+	memset(&cbdata_memory_pool[cbdata_types], 0,
+	    (type + 1 - cbdata_types) * sizeof(*cbdata_memory_pool));
+	cbdata_types = type + 1;
+    }
+    if (cbdata_memory_pool[type])
+	return;
+    label = xmalloc(strlen(name) + 20);
+    snprintf(label, strlen(name) + 20, "cbdata %s (%d)", name, (int) type);
+    assert(OFFSET_OF(cbdata, data) == (sizeof(cbdata) - sizeof(((cbdata *) NULL)->data)));
+    cbdata_memory_pool[type] = memPoolCreate(label, size + OFFSET_OF(cbdata, data));
 }
 
-static unsigned int
-cbdata_hash(const void *p, unsigned int mod)
+cbdata_type
+cbdataAddType(cbdata_type type, char *name, int size)
 {
-    return ((unsigned long) p >> 8) % mod;
+    if (type)
+	return type;
+    type = cbdata_types;
+    cbdataInitType(type, name, size);
+    return type;
 }
 
-
 void
 cbdataInit(void)
 {
     debug(45, 3) ("cbdataInit\n");
-    if (cbdata_pool == NULL) {
-	cbdata_pool = memPoolCreate("cbdata", sizeof(cbdata));
-    }
-    htable = hash_create(cbdata_cmp, 1 << 8, cbdata_hash);
     cachemgrRegister("cbdata",
 	"Callback Data Registry Contents",
 	cbdataDump, 0, 1);
+/* TEMPORARILY DEFINED IN squid.h
+ * #define CREATE_CBDATA(type) cbdataInitType(CBDATA_##type, #type, sizeof(type))
+ */
+    CREATE_CBDATA(acl_access);
+    CREATE_CBDATA(aclCheck_t);
+    CREATE_CBDATA(clientHttpRequest);
+    CREATE_CBDATA(ConnStateData);
+    CREATE_CBDATA(ErrorState);
+    CREATE_CBDATA(FwdState);
+    CREATE_CBDATA(generic_cbdata);
+    CREATE_CBDATA(helper);
+    CREATE_CBDATA(helper_server);
+    CREATE_CBDATA(HttpStateData);
+    CREATE_CBDATA(peer);
+    CREATE_CBDATA(ps_state);
+    CREATE_CBDATA(RemovalPolicy);
+    CREATE_CBDATA(RemovalPolicyWalker);
+    CREATE_CBDATA(RemovalPurgeWalker);
+    CREATE_CBDATA(store_client);
+    CREATE_CBDATA(storeIOState);
 }
 
-void
+void *
 #if CBDATA_DEBUG
-cbdataAddDbg(const void *p, CBDUNL * unlock_func, int id, const char *file, int line)
+cbdataInternalAllocDbg(cbdata_type type, CBDUNL * unlock_func, const char *file, int line)
 #else
-cbdataAdd(const void *p, CBDUNL * unlock_func, int id)
+cbdataInternalAlloc(cbdata_type type, CBDUNL * unlock_func)
 #endif
 {
-    cbdata *c;
-    assert(p);
-    debug(45, 3) ("cbdataAdd: %p\n", p);
-    assert(htable != NULL);
-    assert(hash_lookup(htable, p) == NULL);
-    c = memPoolAlloc(cbdata_pool);
-    c->hash.key = (void *) p;
-    c->valid = 1;
-    c->unlock_func = unlock_func;
-    c->id = id;
+    cbdata *p;
+    assert(type > 0 && type < cbdata_types);
+    p = memPoolAlloc(cbdata_memory_pool[type]);
+    p->type = type;
+    p->unlock_func = unlock_func;
+    p->valid = 1;
+    p->locks = 0;
 #if CBDATA_DEBUG
-    c->file = file;
-    c->line = line;
+    p->file = file;
+    p->line = line;
 #endif
-    hash_join(htable, &c->hash);
+    p->y = p;
     cbdataCount++;
-}
 
-static void
-cbdataReallyFree(cbdata * c)
-{
-    CBDUNL *unlock_func = c->unlock_func;
-    void *p = c->hash.key;
-    int id = c->id;
-    hash_remove_link(htable, (hash_link *) c);
-    cbdataCount--;
-    memPoolFree(cbdata_pool, c);
-    debug(45, 3) ("cbdataReallyFree: Freeing %p\n", p);
-    if (unlock_func)
-	unlock_func(p, id);
+    return (void *) &p->data;
 }
 
 void
 cbdataFree(void *p)
 {
-    cbdata *c = (cbdata *) hash_lookup(htable, p);
-    assert(p);
+    cbdata *c;
     debug(45, 3) ("cbdataFree: %p\n", p);
-    assert(c != NULL);
+    assert(p);
+    c = (cbdata *) (((char *) p) - OFFSET_OF(cbdata, data));
+    assert(c->y == c);
     c->valid = 0;
     if (c->locks) {
 	debug(45, 3) ("cbdataFree: %p has %d locks, not freeing\n",
 	    p, c->locks);
 	return;
     }
-    cbdataReallyFree(c);
+    cbdataCount--;
+    debug(45, 3) ("cbdataFree: Freeing %p\n", p);
+    if (c->unlock_func)
+	c->unlock_func((void *) p);
+    memPoolFree(cbdata_memory_pool[c->type], c);
 }
 
 void
@@ -179,7 +204,8 @@ cbdataLock(const void *p)
     cbdata *c;
     if (p == NULL)
 	return;
-    c = (cbdata *) hash_lookup(htable, p);
+    c = (cbdata *) (((char *) p) - OFFSET_OF(cbdata, data));
+    assert(c->y == c);
     debug(45, 3) ("cbdataLock: %p\n", p);
     assert(c != NULL);
     c->locks++;
@@ -199,7 +225,8 @@ cbdataUnlock(const void *p)
     cbdata *c;
     if (p == NULL)
 	return;
-    c = (cbdata *) hash_lookup(htable, p);
+    c = (cbdata *) (((char *) p) - OFFSET_OF(cbdata, data));
+    assert(c->y == c);
     debug(45, 3) ("cbdataUnlock: %p\n", p);
     assert(c != NULL);
     assert(c->locks > 0);
@@ -210,50 +237,29 @@ cbdataUnlock(const void *p)
 #endif
     if (c->valid || c->locks)
 	return;
-    cbdataReallyFree(c);
+    cbdataCount--;
+    debug(45, 3) ("cbdataUnlock: Freeing %p\n", p);
+    if (c->unlock_func)
+	c->unlock_func((void *) p);
+    memPoolFree(cbdata_memory_pool[c->type], c);
 }
 
 int
 cbdataValid(const void *p)
 {
     cbdata *c;
-    /* Maybe NULL should be considered valid? */
     if (p == NULL)
-	return 0;
-    c = (cbdata *) hash_lookup(htable, p);
+	return 1;		/* A NULL pointer cannot become invalid */
     debug(45, 3) ("cbdataValid: %p\n", p);
-    assert(c != NULL);
+    c = (cbdata *) (((char *) p) - OFFSET_OF(cbdata, data));
+    assert(c->y == c);
     assert(c->locks > 0);
     return c->valid;
 }
 
-void
-cbdataXfree(void *p, int unused)
-{
-    xfree(p);
-}
-
-
 static void
 cbdataDump(StoreEntry * sentry)
 {
-    hash_link *hptr;
-    cbdata *c;
     storeAppendPrintf(sentry, "%d cbdata entries\n", cbdataCount);
-    hash_first(htable);
-    while ((hptr = hash_next(htable))) {
-	c = (cbdata *) hptr;
-#if CBDATA_DEBUG
-	storeAppendPrintf(sentry, "%20p %10s %d locks %s:%d\n",
-	    c->hash.key,
-	    c->valid ? "VALID" : "NOT VALID",
-	    c->locks,
-	    c->file, c->line);
-#else
-	storeAppendPrintf(sentry, "%20p %10s %d locks\n",
-	    c->hash.key,
-	    c->valid ? "VALID" : "NOT VALID",
-	    c->locks);
-#endif
-    }
+    storeAppendPrintf(sentry, "see also memory pools section\n");
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side.cc,v 1.520 2001/01/04 21:09:01 wessels Exp $
+ * $Id: client_side.cc,v 1.521 2001/01/05 09:51:36 adrian Exp $
  *
  * DEBUG: section 33    Client-side Routines
  * AUTHOR: Duane Wessels
@@ -2234,8 +2234,8 @@ clientProcessMiss(clientHttpRequest * http)
 static clientHttpRequest *
 parseHttpRequestAbort(ConnStateData * conn, const char *uri)
 {
-    clientHttpRequest *http = memAllocate(MEM_CLIENTHTTPREQUEST);
-    cbdataAdd(http, memFree, MEM_CLIENTHTTPREQUEST);
+    clientHttpRequest *http;
+    http = CBDATA_ALLOC(clientHttpRequest, NULL);
     http->conn = conn;
     http->start = current_time;
     http->req_sz = conn->in.offset;
@@ -2374,8 +2374,7 @@ parseHttpRequest(ConnStateData * conn, method_t * method_p, int *status,
     assert(prefix_sz <= conn->in.offset);
 
     /* Ok, all headers are received */
-    http = memAllocate(MEM_CLIENTHTTPREQUEST);
-    cbdataAdd(http, memFree, MEM_CLIENTHTTPREQUEST);
+    http = CBDATA_ALLOC(clientHttpRequest, NULL);
     http->http_ver = http_ver;
     http->conn = conn;
     http->start = current_time;
@@ -2883,8 +2882,7 @@ httpAccept(int sock, void *data)
 	    break;
 	}
 	debug(33, 4) ("httpAccept: FD %d: accepted\n", fd);
-	connState = memAllocate(MEM_CONNSTATEDATA);
-	cbdataAdd(connState, memFree, MEM_CONNSTATEDATA);
+	connState = CBDATA_ALLOC(ConnStateData, NULL);
 	connState->peer = peer;
 	connState->log_addr = peer.sin_addr;
 	connState->log_addr.s_addr &= Config.Addrs.client_netmask.s_addr;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: comm.cc,v 1.312 2000/11/01 03:58:51 wessels Exp $
+ * $Id: comm.cc,v 1.313 2001/01/05 09:51:37 adrian Exp $
  *
  * DEBUG: section 5     Socket Functions
  * AUTHOR: Harvest Derived
@@ -69,10 +69,9 @@ static IPH commConnectDnsHandle;
 static void commConnectCallback(ConnectStateData * cs, int status);
 static int commResetFD(ConnectStateData * cs);
 static int commRetryConnect(ConnectStateData * cs);
-static CBDUNL commConnectDataFree;
+CBDATA_TYPE(ConnectStateData);
 
 static MemPool *comm_write_pool = NULL;
-static MemPool *conn_state_pool = NULL;
 static MemPool *conn_close_pool = NULL;
 
 static void
@@ -231,9 +230,9 @@ comm_listen(int sock)
 void
 commConnectStart(int fd, const char *host, u_short port, CNCB * callback, void *data)
 {
-    ConnectStateData *cs = memPoolAlloc(conn_state_pool);
+    ConnectStateData *cs;
     debug(5, 3) ("commConnectStart: FD %d, %s:%d\n", fd, host, (int) port);
-    cbdataAdd(cs, commConnectDataFree, 0);
+    cs = CBDATA_ALLOC(ConnectStateData, NULL);
     cs->fd = fd;
     cs->host = xstrdup(host);
     cs->port = port;
@@ -245,12 +244,6 @@ commConnectStart(int fd, const char *host, u_short port, CNCB * callback, void *
     ipcache_nbgethostbyname(host, commConnectDnsHandle, cs);
 }
 
-static void
-commConnectDataFree(void *data, int unused)
-{
-    memPoolFree(conn_state_pool, data);
-}
-
 static void
 commConnectDnsHandle(const ipcache_addrs * ia, void *data)
 {
@@ -797,8 +790,8 @@ comm_init(void)
      * after accepting a client but before it opens a socket or a file.
      * Since Squid_MaxFD can be as high as several thousand, don't waste them */
     RESERVED_FD = XMIN(100, Squid_MaxFD / 4);
+    CBDATA_INIT_TYPE(ConnectStateData);
     comm_write_pool = memPoolCreate("CommWriteStateData", sizeof(CommWriteStateData));
-    conn_state_pool = memPoolCreate("ConnectStateData", sizeof(ConnectStateData));
     conn_close_pool = memPoolCreate("close_handler", sizeof(close_handler));
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: defines.h,v 1.84 2001/01/04 03:42:34 wessels Exp $
+ * $Id: defines.h,v 1.85 2001/01/05 09:51:37 adrian Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -282,6 +282,11 @@
 #define _PATH_DEVNULL "/dev/null"
 #endif
 
+/* cbdata macros */
+#define CBDATA_ALLOC(type, unl) ((type *)cbdataInternalAlloc(CBDATA_##type, unl))
+#define CBDATA_TYPE(type)	static cbdata_type CBDATA_##type = 0
+#define CBDATA_INIT_TYPE(type)	(CBDATA_##type = cbdataAddType(CBDATA_##type, #type, sizeof(type)))
+
 #ifndef O_TEXT
 #define O_TEXT 0
 #endif
@@ -1,6 +1,6 @@
 
 /*
- * $Id: enums.h,v 1.177 2000/12/09 01:47:18 wessels Exp $
+ * $Id: enums.h,v 1.178 2001/01/05 09:51:37 adrian Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -675,3 +675,32 @@ enum {
     NETDB_EX_RTT,
     NETDB_EX_HOPS
 };
+
+/*
+ * cbdata types. similar to the MEM_* types above, but managed
+ * in cbdata.c. A big difference is that these types are dynamically
+ * allocated. This list is only a list of predefined types. Other types
+ * are added runtime
+ */
+typedef enum {
+    CBDATA_UNKNOWN = 0,
+    CBDATA_acl_access,
+    CBDATA_aclCheck_t,
+    CBDATA_clientHttpRequest,
+    CBDATA_ConnStateData,
+    CBDATA_DigestFetchState,
+    CBDATA_ErrorState,
+    CBDATA_FwdState,
+    CBDATA_generic_cbdata,
+    CBDATA_helper,
+    CBDATA_helper_server,
+    CBDATA_HttpStateData,
+    CBDATA_peer,
+    CBDATA_ps_state,
+    CBDATA_RemovalPolicy,
+    CBDATA_RemovalPolicyWalker,
+    CBDATA_RemovalPurgeWalker,
+    CBDATA_store_client,
+    CBDATA_storeIOState,
+    CBDATA_FIRST_CUSTOM_TYPE
+} cbdata_type;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: errorpage.cc,v 1.159 2001/01/04 03:42:34 wessels Exp $
+ * $Id: errorpage.cc,v 1.160 2001/01/05 09:51:37 adrian Exp $
  *
  * DEBUG: section 4     Error Generation
  * AUTHOR: Duane Wessels
@@ -236,7 +236,8 @@ errorPageName(int pageId)
 ErrorState *
 errorCon(err_type type, http_status status)
 {
-    ErrorState *err = memAllocate(MEM_ERRORSTATE);
+    ErrorState *err;
+    err = CBDATA_ALLOC(ErrorState, NULL);
     err->page_id = type;	/* has to be reset manually if needed */
     err->type = type;
     err->http_status = status;
@@ -340,7 +341,6 @@ errorSend(int fd, ErrorState * err)
 	err->request->err_type = err->type;
     /* moved in front of errorBuildBuf @?@ */
     err->flags.flag_cbdata = 1;
-    cbdataAdd(err, memFree, MEM_ERRORSTATE);
     rep = errorBuildReply(err);
     comm_write_mbuf(fd, httpReplyPack(rep), errorSendComplete, err);
     httpReplyDestroy(rep);
@@ -382,10 +382,7 @@ errorStateFree(ErrorState * err)
     wordlistDestroy(&err->ftp.server_msg);
     safe_free(err->ftp.request);
     safe_free(err->ftp.reply);
-    if (err->flags.flag_cbdata)
-	cbdataFree(err);
-    else
-	memFree(err, MEM_ERRORSTATE);
+    cbdataFree(err);
 }
 
 #define CVT_BUF_SZ 512
@@ -1,6 +1,6 @@
 
 /*
- * $Id: forward.cc,v 1.77 2000/12/17 13:31:29 hno Exp $
+ * $Id: forward.cc,v 1.78 2001/01/05 09:51:37 adrian Exp $
  *
  * DEBUG: section 17    Request Forwarding
  * AUTHOR: Duane Wessels
@@ -545,8 +545,7 @@ fwdStart(int fd, StoreEntry * e, request_t * r)
     default:
 	break;
     }
-    fwdState = memAllocate(MEM_FWD_STATE);
-    cbdataAdd(fwdState, memFree, MEM_FWD_STATE);
+    fwdState = CBDATA_ALLOC(FwdState, NULL);
     fwdState->entry = e;
     fwdState->client_fd = fd;
     fwdState->server_fd = -1;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: fqdncache.cc,v 1.144 2000/12/30 23:29:06 wessels Exp $
+ * $Id: fqdncache.cc,v 1.145 2001/01/05 09:51:37 adrian Exp $
  *
  * DEBUG: section 35    FQDN Cache
  * AUTHOR: Harvest Derived
@@ -388,9 +388,8 @@ fqdncache_nbgethostbyaddr(struct in_addr addr, FQDNH * handler, void *handlerDat
     f->handlerData = handlerData;
     cbdataLock(handlerData);
     f->request_time = current_time;
-    c = memAllocate(MEM_GEN_CBDATA);
+    c = CBDATA_ALLOC(generic_cbdata, NULL);
     c->data = f;
-    cbdataAdd(c, memFree, MEM_GEN_CBDATA);
 #if USE_DNSSERVERS
     dnsSubmit(hashKeyStr(&f->hash), fqdncacheHandleReply, c);
 #else
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_dir_aufs.cc,v 1.25 2001/01/05 03:58:21 wessels Exp $
+ * $Id: store_dir_aufs.cc,v 1.26 2001/01/05 09:51:46 adrian Exp $
  *
  * DEBUG: section 47    Store Directory Routines
  * AUTHOR: Duane Wessels
@@ -820,14 +820,18 @@ storeAufsDirAddDiskRestore(SwapDir * SD, const cache_key * key,
     return e;
 }
 
+CBDATA_TYPE(RebuildState);
+
 static void
 storeAufsDirRebuild(SwapDir * sd)
 {
-    RebuildState *rb = xcalloc(1, sizeof(*rb));
+    RebuildState *rb;
     int clean = 0;
     int zero = 0;
     FILE *fp;
     EVH *func = NULL;
+    CBDATA_INIT_TYPE(RebuildState);
+    rb = CBDATA_ALLOC(RebuildState, NULL);
     rb->sd = sd;
     rb->speed = opt_foreground_rebuild ? 1 << 30 : 50;
     /*
@@ -851,7 +855,6 @@ storeAufsDirRebuild(SwapDir * sd)
     debug(20, 1) ("Rebuilding storage in %s (%s)\n",
 	sd->path, clean ? "CLEAN" : "DIRTY");
     store_dirs_rebuilding++;
-    cbdataAdd(rb, cbdataXfree, 0);
     eventAdd("storeRebuild", func, rb, 0.0, 1);
 }
 
@@ -20,7 +20,7 @@ static void storeAufsIOCallback(storeIOState * sio, int errflag);
 static AIOCB storeAufsOpenDone;
 static int storeAufsSomethingPending(storeIOState *);
 static int storeAufsKickWriteQueue(storeIOState * sio);
-static void storeAufsIOFreeEntry(void *, int);
+static CBDUNL storeAufsIOFreeEntry;
 
 /* === PUBLIC =========================================================== */
 
@@ -51,8 +51,7 @@ storeAufsOpen(SwapDir * SD, StoreEntry * e, STFNCB * file_callback,
 	return NULL;
     }
 #endif
-    sio = memAllocate(MEM_STORE_IO);
-    cbdataAdd(sio, storeAufsIOFreeEntry, MEM_STORE_IO);
+    sio = CBDATA_ALLOC(storeIOState, storeAufsIOFreeEntry);
     sio->fsstate = memPoolAlloc(aio_state_pool);
     ((aiostate_t *) (sio->fsstate))->fd = -1;
     ((aiostate_t *) (sio->fsstate))->flags.opening = 1;
@@ -106,8 +105,7 @@ storeAufsCreate(SwapDir * SD, StoreEntry * e, STFNCB * file_callback, STIOCB * c
 	return NULL;
     }
 #endif
-    sio = memAllocate(MEM_STORE_IO);
-    cbdataAdd(sio, storeAufsIOFreeEntry, MEM_STORE_IO);
+    sio = CBDATA_ALLOC(storeIOState, storeAufsIOFreeEntry);
     sio->fsstate = memPoolAlloc(aio_state_pool);
     ((aiostate_t *) (sio->fsstate))->fd = -1;
     ((aiostate_t *) (sio->fsstate))->flags.opening = 1;
@@ -453,12 +451,12 @@ storeAufsSomethingPending(storeIOState * sio)
 
 
 /*      
- * We can't pass memFree() as a free function here, because we need to free
- * the fsstate variable ..
+ * Clean up references from the SIO before it gets released.
+ * The actuall SIO is managed by cbdata so we do not need
+ * to bother with that.
  */
 static void
-storeAufsIOFreeEntry(void *sio, int foo)
+storeAufsIOFreeEntry(void *sio)
 {
     memPoolFree(aio_state_pool, ((storeIOState *) sio)->fsstate);
-    memFree(sio, MEM_STORE_IO);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_dir_coss.cc,v 1.15 2001/01/05 03:58:22 wessels Exp $
+ * $Id: store_dir_coss.cc,v 1.16 2001/01/05 09:51:47 adrian Exp $
  *
  * DEBUG: section 81    Store COSS Directory Routines
  * AUTHOR: Eric Stern
@@ -42,7 +42,6 @@
 int n_coss_dirs = 0;
 /* static int last_coss_pick_index = -1; */
 int coss_initialised = 0;
-MemPool *coss_membuf_pool = NULL;
 MemPool *coss_state_pool = NULL;
 MemPool *coss_index_pool = NULL;
 
@@ -327,15 +326,17 @@ storeCossAddDiskRestore(SwapDir * SD, const cache_key * key,
     return e;
 }
 
+CBDATA_TYPE(RebuildState);
 static void
 storeCossDirRebuild(SwapDir * sd)
 {
-    RebuildState *rb = xcalloc(1, sizeof(*rb));
+    RebuildState *rb;
     int clean = 0;
     int zero = 0;
     FILE *fp;
     EVH *func = NULL;
-    cbdataAdd(rb, cbdataXfree, 0);
+    CBDATA_INIT_TYPE(RebuildState);
+    rb = CBDATA_ALLOC(RebuildState, NULL);
     rb->sd = sd;
     rb->speed = opt_foreground_rebuild ? 1 << 30 : 50;
     func = storeCossRebuildFromSwapLog;
@@ -858,7 +859,6 @@ storeCossDirPick(void)
 static void
 storeCossDirDone(void)
 {
-    memPoolDestroy(coss_membuf_pool);
     memPoolDestroy(coss_state_pool);
     coss_initialised = 0;
 }
@@ -871,7 +871,6 @@ storeFsSetup_coss(storefs_entry_t * storefs)
     storefs->parsefunc = storeCossDirParse;
     storefs->reconfigurefunc = storeCossDirReconfigure;
     storefs->donefunc = storeCossDirDone;
-    coss_membuf_pool = memPoolCreate("COSS Membuf data", sizeof(CossMemBuf));
     coss_state_pool = memPoolCreate("COSS IO State data", sizeof(CossState));
     coss_index_pool = memPoolCreate("COSS index data", sizeof(CossIndexNode));
     coss_initialised = 1;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_io_coss.cc,v 1.5 2001/01/02 00:11:54 wessels Exp $
+ * $Id: store_io_coss.cc,v 1.6 2001/01/05 09:51:47 adrian Exp $
  *
  * DEBUG: section 81    Storage Manager COSS Interface
  * AUTHOR: Eric Stern
@@ -46,8 +46,8 @@ static void storeCossWriteMemBuf(SwapDir * SD, CossMemBuf * t);
 static void storeCossWriteMemBufDone(int fd, int errflag, size_t len, void *my_data);
 static CossMemBuf *storeCossCreateMemBuf(SwapDir * SD, size_t start,
     sfileno curfn, int *collision);
-static void storeCossIOFreeEntry(void *, int);
-static void storeCossMembufFree(void *, int);
+static CBDUNL storeCossIOFreeEntry;
+static CBDUNL storeCossMembufFree;
 
 /* === PUBLIC =========================================================== */
 
@@ -128,8 +128,7 @@ storeCossCreate(SwapDir * SD, StoreEntry * e, STFNCB * file_callback, STIOCB * c
     CossState *cstate;
     storeIOState *sio;
 
-    sio = memAllocate(MEM_STORE_IO);
-    cbdataAdd(sio, storeCossIOFreeEntry, MEM_STORE_IO);
+    sio = CBDATA_ALLOC(storeIOState, storeCossIOFreeEntry);
     cstate = memPoolAlloc(coss_state_pool);
     sio->fsstate = cstate;
     sio->offset = 0;
@@ -173,8 +172,7 @@ storeCossOpen(SwapDir * SD, StoreEntry * e, STFNCB * file_callback,
 
     debug(81, 3) ("storeCossOpen: offset %d\n", f);
 
-    sio = memAllocate(MEM_STORE_IO);
-    cbdataAdd(sio, storeCossIOFreeEntry, MEM_STORE_IO);
+    sio = CBDATA_ALLOC(storeIOState, storeCossIOFreeEntry);
     cstate = memPoolAlloc(coss_state_pool);
 
     sio->fsstate = cstate;
@@ -432,7 +430,6 @@ storeCossWriteMemBuf(SwapDir * SD, CossMemBuf * t)
     CossInfo *cs = (CossInfo *) SD->fsdata;
     debug(81, 3) ("storeCossWriteMemBuf: offset %d, len %d\n",
 	t->diskstart, t->diskend - t->diskstart);
-    cbdataAdd(t, storeCossMembufFree, 0);
     t->flags.writing = 1;
     file_write(cs->fd, t->diskstart, &t->buffer,
 	t->diskend - t->diskstart, storeCossWriteMemBufDone, t, NULL);
@@ -469,6 +466,7 @@ storeCossWriteMemBufDone(int fd, int errflag, size_t len, void *my_data)
     cbdataFree(t);
 }
 
+CBDATA_TYPE(CossMemBuf);
 static CossMemBuf *
 storeCossCreateMemBuf(SwapDir * SD, size_t start,
     sfileno curfn, int *collision)
@@ -479,7 +477,8 @@ storeCossCreateMemBuf(SwapDir * SD, size_t start,
     int numreleased = 0;
     CossInfo *cs = (CossInfo *) SD->fsdata;
 
-    newmb = memPoolAlloc(coss_membuf_pool);
+    CBDATA_INIT_TYPE(CossMemBuf);
+    newmb = CBDATA_ALLOC(CossMemBuf, storeCossMembufFree);
     newmb->diskstart = start;
     debug(81, 3) ("storeCossCreateMemBuf: creating new membuf at %d\n", newmb->diskstart);
     newmb->diskend = newmb->diskstart + COSS_MEMBUF_SZ - 1;
@@ -530,7 +529,7 @@ storeCossStartMembuf(SwapDir * sd)
  * the fsstate variable ..
  */
 static void
-storeCossIOFreeEntry(void *sio, int foo)
+storeCossIOFreeEntry(void *sio)
 {
     memPoolFree(coss_state_pool, ((storeIOState *) sio)->fsstate);
     memFree(sio, MEM_STORE_IO);
@@ -542,7 +541,7 @@ storeCossIOFreeEntry(void *sio, int foo)
  * So we have this hack here ..
  */
 static void
-storeCossMembufFree(void *mb, int foo)
+storeCossMembufFree(void *mb)
 {
-    memPoolFree(coss_membuf_pool, mb);
+    cbdataFree(mb);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_dir_diskd.cc,v 1.32 2001/01/05 03:58:23 wessels Exp $
+ * $Id: store_dir_diskd.cc,v 1.33 2001/01/05 09:51:55 adrian Exp $
  *
  * DEBUG: section 47    Store Directory Routines
  * AUTHOR: Duane Wessels
@@ -1011,14 +1011,18 @@ storeDiskdDirAddDiskRestore(SwapDir * SD, const cache_key * key,
     return e;
 }
 
+CBDATA_TYPE(RebuildState);
+
 static void
 storeDiskdDirRebuild(SwapDir * sd)
 {
-    RebuildState *rb = xcalloc(1, sizeof(*rb));
+    RebuildState *rb;
     int clean = 0;
     int zero = 0;
     FILE *fp;
     EVH *func = NULL;
+    CBDATA_INIT_TYPE(RebuildState);
+    rb = CBDATA_ALLOC(RebuildState, NULL);
     rb->sd = sd;
     rb->speed = opt_foreground_rebuild ? 1 << 30 : 50;
     /*
@@ -1042,7 +1046,6 @@ storeDiskdDirRebuild(SwapDir * sd)
     debug(20, 1) ("Rebuilding storage in %s (%s)\n",
 	sd->path, clean ? "CLEAN" : "DIRTY");
     store_dirs_rebuilding++;
-    cbdataAdd(rb, cbdataXfree, 0);
     eventAdd("storeRebuild", func, rb, 0.0, 1);
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_io_diskd.cc,v 1.18 2001/01/02 00:11:54 wessels Exp $
+ * $Id: store_io_diskd.cc,v 1.19 2001/01/05 09:51:55 adrian Exp $
  *
  * DEBUG: section 81    Squid-side DISKD I/O functions.
  * AUTHOR: Duane Wessels
@@ -44,7 +44,7 @@
 
 static int storeDiskdSend(int, SwapDir *, int, storeIOState *, int, int, int);
 static void storeDiskdIOCallback(storeIOState * sio, int errflag);
-static void storeDiskdIOFreeEntry(void *sio, int foo);
+static CBDUNL storeDiskdIOFreeEntry;
 
 /* === PUBLIC =========================================================== */
 
@@ -68,8 +68,7 @@ storeDiskdOpen(SwapDir * SD, StoreEntry * e, STFNCB * file_callback,
 	diskd_stats.open_fail_queue_len++;
 	return NULL;
     }
-    sio = memAllocate(MEM_STORE_IO);
-    cbdataAdd(sio, storeDiskdIOFreeEntry, MEM_STORE_IO);
+    sio = CBDATA_ALLOC(storeIOState, storeDiskdIOFreeEntry);
     sio->fsstate = diskdstate = memPoolAlloc(diskd_state_pool);
 
     sio->swap_filen = f;
@@ -127,8 +126,7 @@ storeDiskdCreate(SwapDir * SD, StoreEntry * e, STFNCB * file_callback,
     f = storeDiskdDirMapBitAllocate(SD);
     debug(81, 3) ("storeDiskdCreate: fileno %08X\n", f);
 
-    sio = memAllocate(MEM_STORE_IO);
-    cbdataAdd(sio, storeDiskdIOFreeEntry, MEM_STORE_IO);
+    sio = CBDATA_ALLOC(storeIOState, storeDiskdIOFreeEntry);
     sio->fsstate = diskdstate = memPoolAlloc(diskd_state_pool);
 
     sio->swap_filen = f;
@@ -519,8 +517,7 @@ storeDiskdSend(int mtype, SwapDir * sd, int id, storeIOState * sio, int size, in
  * the fsstate variable ..
  */
 static void
-storeDiskdIOFreeEntry(void *sio, int foo)
+storeDiskdIOFreeEntry(void *sio)
 {
     memPoolFree(diskd_state_pool, ((storeIOState *) sio)->fsstate);
-    memFree(sio, MEM_STORE_IO);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_dir_ufs.cc,v 1.24 2001/01/05 03:58:23 wessels Exp $
+ * $Id: store_dir_ufs.cc,v 1.25 2001/01/05 09:52:00 adrian Exp $
  *
  * DEBUG: section 47    Store Directory Routines
  * AUTHOR: Duane Wessels
@@ -818,14 +818,17 @@ storeUfsDirAddDiskRestore(SwapDir * SD, const cache_key * key,
     return e;
 }
 
+CBDATA_TYPE(RebuildState);
 static void
 storeUfsDirRebuild(SwapDir * sd)
 {
-    RebuildState *rb = xcalloc(1, sizeof(*rb));
+    RebuildState *rb;
     int clean = 0;
     int zero = 0;
     FILE *fp;
     EVH *func = NULL;
+    CBDATA_INIT_TYPE(RebuildState);
+    rb = CBDATA_ALLOC(RebuildState, NULL);
     rb->sd = sd;
     rb->speed = opt_foreground_rebuild ? 1 << 30 : 50;
     /*
@@ -849,7 +852,6 @@ storeUfsDirRebuild(SwapDir * sd)
     debug(20, 1) ("Rebuilding storage in %s (%s)\n",
 	sd->path, clean ? "CLEAN" : "DIRTY");
     store_dirs_rebuilding++;
-    cbdataAdd(rb, cbdataXfree, 0);
     eventAdd("storeRebuild", func, rb, 0.0, 1);
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_io_ufs.cc,v 1.4 2001/01/04 03:42:38 wessels Exp $
+ * $Id: store_io_ufs.cc,v 1.5 2001/01/05 09:52:00 adrian Exp $
  *
  * DEBUG: section 79    Storage Manager UFS Interface
  * AUTHOR: Duane Wessels
@@ -40,7 +40,7 @@
 static DRCB storeUfsReadDone;
 static DWCB storeUfsWriteDone;
 static void storeUfsIOCallback(storeIOState * sio, int errflag);
-static void storeUfsIOFreeEntry(void *, int);
+static CBDUNL storeUfsIOFreeEntry;
 
 /* === PUBLIC =========================================================== */
 
@@ -60,8 +60,7 @@ storeUfsOpen(SwapDir * SD, StoreEntry * e, STFNCB * file_callback,
 	return NULL;
     }
     debug(79, 3) ("storeUfsOpen: opened FD %d\n", fd);
-    sio = memAllocate(MEM_STORE_IO);
-    cbdataAdd(sio, storeUfsIOFreeEntry, MEM_STORE_IO);
+    sio = CBDATA_ALLOC(storeIOState, storeUfsIOFreeEntry);
     sio->fsstate = memPoolAlloc(ufs_state_pool);
 
     sio->swap_filen = f;
@@ -108,8 +107,7 @@ storeUfsCreate(SwapDir * SD, StoreEntry * e, STFNCB * file_callback, STIOCB * ca
 	return NULL;
     }
     debug(79, 3) ("storeUfsCreate: opened FD %d\n", fd);
-    sio = memAllocate(MEM_STORE_IO);
-    cbdataAdd(sio, storeUfsIOFreeEntry, MEM_STORE_IO);
+    sio = CBDATA_ALLOC(storeIOState, storeUfsIOFreeEntry);
     sio->fsstate = memPoolAlloc(ufs_state_pool);
 
     sio->swap_filen = filn;
@@ -257,12 +255,10 @@ storeUfsIOCallback(storeIOState * sio, int errflag)
 
 
 /*
- * We can't pass memFree() as a free function here, because we need to free
- * the fsstate variable ..
+ * Clean up any references from the SIO before it get's released.
  */
 static void
-storeUfsIOFreeEntry(void *sio, int foo)
+storeUfsIOFreeEntry(void *sio)
 {
     memPoolFree(ufs_state_pool, ((storeIOState *) sio)->fsstate);
-    memFree(sio, MEM_STORE_IO);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ftp.cc,v 1.300 2000/11/14 07:06:19 wessels Exp $
+ * $Id: ftp.cc,v 1.301 2001/01/05 09:51:37 adrian Exp $
  *
  * DEBUG: section 9     File Transfer Protocol (FTP)
  * AUTHOR: Harvest Derived
@@ -1033,6 +1033,7 @@ ftpBuildTitleUrl(FtpStateData * ftpState)
     strcat(t, "/");
 }
 
+CBDATA_TYPE(FtpStateData);
 void
 ftpStart(FwdState * fwd)
 {
@@ -1041,11 +1042,13 @@ ftpStart(FwdState * fwd)
     int fd = fwd->server_fd;
     LOCAL_ARRAY(char, realm, 8192);
     const char *url = storeUrl(entry);
-    FtpStateData *ftpState = xcalloc(1, sizeof(FtpStateData));
+    FtpStateData *ftpState;
     HttpReply *reply;
     StoreEntry *pe = NULL;
     const cache_key *key = NULL;
-    cbdataAdd(ftpState, cbdataXfree, 0);
+
+    CBDATA_INIT_TYPE(FtpStateData);
+    ftpState = CBDATA_ALLOC(FtpStateData, NULL);
     debug(9, 3) ("ftpStart: '%s'\n", url);
     statCounter.server.all.requests++;
     statCounter.server.ftp.requests++;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: gopher.cc,v 1.157 2000/12/05 09:15:59 wessels Exp $
+ * $Id: gopher.cc,v 1.158 2001/01/05 09:51:38 adrian Exp $
  *
  * DEBUG: section 10    Gopher
  * AUTHOR: Harvest Derived
@@ -812,11 +812,13 @@ gopherStart(FwdState * fwdState)
     commSetTimeout(fd, Config.Timeout.read, gopherTimeout, gopherState);
 }
 
+CBDATA_TYPE(GopherStateData);
 static GopherStateData *
 CreateGopherStateData(void)
 {
-    GopherStateData *gd = xcalloc(1, sizeof(GopherStateData));
-    cbdataAdd(gd, cbdataXfree, 0);
+    GopherStateData *gd;
+    CBDATA_INIT_TYPE(GopherStateData);
+    gd = CBDATA_ALLOC(GopherStateData, NULL);
     gd->buf = memAllocate(MEM_4K_BUF);
     return (gd);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: helper.cc,v 1.20 2000/06/27 22:06:02 hno Exp $
+ * $Id: helper.cc,v 1.21 2001/01/05 09:51:38 adrian Exp $
  *
  * DEBUG: section 29    Helper process maintenance
  * AUTHOR: Harvest Derived?
@@ -93,8 +93,7 @@ helperOpenServers(helper * hlp)
 	    continue;
 	}
 	hlp->n_running++;
-	srv = memAllocate(MEM_HELPER_SERVER);
-	cbdataAdd(srv, memFree, MEM_HELPER_SERVER);
+	srv = CBDATA_ALLOC(helper_server, NULL);
 	srv->flags.alive = 1;
 	srv->index = k;
 	srv->rfd = rfd;
@@ -224,8 +223,8 @@ helperShutdown(helper * hlp)
 helper *
 helperCreate(const char *name)
 {
-    helper *hlp = memAllocate(MEM_HELPER);
-    cbdataAdd(hlp, memFree, MEM_HELPER);
+    helper *hlp;
+    hlp = CBDATA_ALLOC(helper, NULL);
     hlp->id_name = name;
     return hlp;
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: http.cc,v 1.373 2001/01/04 21:09:01 wessels Exp $
+ * $Id: http.cc,v 1.374 2001/01/05 09:51:38 adrian Exp $
  *
  * DEBUG: section 11    Hypertext Transfer Protocol (HTTP)
  * AUTHOR: Harvest Derived
@@ -899,13 +899,13 @@ void
 httpStart(FwdState * fwd)
 {
     int fd = fwd->server_fd;
-    HttpStateData *httpState = memAllocate(MEM_HTTP_STATE_DATA);
+    HttpStateData *httpState;
     request_t *proxy_req;
     request_t *orig_req = fwd->request;
     debug(11, 3) ("httpStart: \"%s %s\"\n",
 	RequestMethodStr[orig_req->method],
 	storeUrl(fwd->entry));
-    cbdataAdd(httpState, memFree, MEM_HTTP_STATE_DATA);
+    httpState = CBDATA_ALLOC(HttpStateData, NULL);
     storeLockObject(fwd->entry);
     httpState->fwd = fwd;
     httpState->entry = fwd->entry;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ident.cc,v 1.54 2000/10/31 23:48:13 wessels Exp $
+ * $Id: ident.cc,v 1.55 2001/01/05 09:51:38 adrian Exp $
  *
  * DEBUG: section 30    Ident (RFC 931)
  * AUTHOR: Duane Wessels
@@ -178,6 +178,8 @@ identClientAdd(IdentStateData * state, IDCB * callback, void *callback_data)
     *C = c;
 }
 
+CBDATA_TYPE(IdentStateData);
+
 /**** PUBLIC FUNCTIONS ****/
 
 /*
@@ -213,8 +215,8 @@ identStart(struct sockaddr_in *me, struct sockaddr_in *my_peer, IDCB * callback,
 	callback(NULL, data);
 	return;
     }
-    state = xcalloc(1, sizeof(IdentStateData));
-    cbdataAdd(state, cbdataXfree, 0);
+    CBDATA_INIT_TYPE(IdentStateData);
+    state = CBDATA_ALLOC(IdentStateData, NULL);
     state->hash.key = xstrdup(key);
     state->fd = fd;
     state->me = *me;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ipcache.cc,v 1.230 2001/01/01 22:14:32 wessels Exp $
+ * $Id: ipcache.cc,v 1.231 2001/01/05 09:51:38 adrian Exp $
  *
  * DEBUG: section 14    IP Cache
  * AUTHOR: Harvest Derived
@@ -433,9 +433,8 @@ ipcache_nbgethostbyname(const char *name, IPH * handler, void *handlerData)
     i->handlerData = handlerData;
     cbdataLock(handlerData);
     i->request_time = current_time;
-    c = memAllocate(MEM_GEN_CBDATA);
+    c = CBDATA_ALLOC(generic_cbdata, NULL);
     c->data = i;
-    cbdataAdd(c, memFree, MEM_GEN_CBDATA);
 #if USE_DNSSERVERS
     dnsSubmit(hashKeyStr(&i->hash), ipcacheHandleReply, c);
 #else
@@ -1,6 +1,6 @@
 
 /*
- * $Id: main.cc,v 1.327 2001/01/04 03:42:34 wessels Exp $
+ * $Id: main.cc,v 1.328 2001/01/05 09:51:39 adrian Exp $
  *
  * DEBUG: section 1     Startup and Main Loop
  * AUTHOR: Harvest Derived
@@ -625,11 +625,11 @@ main(int argc, char **argv)
 	if (!ConfigFile)
 	    ConfigFile = xstrdup(DefaultConfigFile);
 	assert(!configured_once);
-	memInit();		/* memInit is required for config parsing */
-	cbdataInit();
 #if USE_LEAKFINDER
 	leakInit();
 #endif
+	memInit();
+	cbdataInit();
 	eventInit();		/* eventInit() is required for config parsing */
 	storeFsInit();		/* required for config parsing */
 	parse_err = parseConfigFile(ConfigFile);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: neighbors.cc,v 1.290 2000/12/05 08:55:47 wessels Exp $
+ * $Id: neighbors.cc,v 1.291 2001/01/05 09:51:39 adrian Exp $
  *
  * DEBUG: section 15    Neighbor Routines
  * AUTHOR: Harvest Derived
@@ -932,7 +932,7 @@ neighborUp(const peer * p)
 }
 
 void
-peerDestroy(void *data, int unused)
+peerDestroy(void *data)
 {
     peer *p = data;
     struct _domain_ping *l = NULL;
@@ -952,7 +952,6 @@ peerDestroy(void *data, int unused)
 	cbdataUnlock(pd);
     }
 #endif
-    xfree(p);
 }
 
 void
@@ -1114,7 +1113,7 @@ static void
 peerCountMcastPeersStart(void *data)
 {
     peer *p = data;
-    ps_state *psstate = xcalloc(1, sizeof(ps_state));
+    ps_state *psstate;
     StoreEntry *fake;
     MemObject *mem;
     icp_common_t *query;
@@ -1124,12 +1123,12 @@ peerCountMcastPeersStart(void *data)
     p->mcast.flags.count_event_pending = 0;
     snprintf(url, MAX_URL, "http://%s/", inet_ntoa(p->in_addr.sin_addr));
     fake = storeCreateEntry(url, url, null_request_flags, METHOD_GET);
+    psstate = CBDATA_ALLOC(ps_state, NULL);
     psstate->request = requestLink(urlParse(METHOD_GET, url));
     psstate->entry = fake;
     psstate->callback = NULL;
     psstate->callback_data = p;
     psstate->ping.start = current_time;
-    cbdataAdd(psstate, cbdataXfree, 0);
     mem = fake->mem_obj;
     mem->request = requestLink(psstate->request);
     mem->start_ping = current_time;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: net_db.cc,v 1.154 2001/01/04 03:42:35 wessels Exp $
+ * $Id: net_db.cc,v 1.155 2001/01/05 09:51:39 adrian Exp $
  *
  * DEBUG: section 38    Network Measurement Database
  * AUTHOR: Duane Wessels
@@ -223,14 +223,14 @@ static void
 netdbSendPing(const ipcache_addrs * ia, void *data)
 {
     struct in_addr addr;
-    char *hostname = data;
+    char *hostname = ((generic_cbdata *) data)->data;
     netdbEntry *n;
     netdbEntry *na;
     net_db_name *x;
     net_db_name **X;
-    cbdataUnlock(hostname);
+    cbdataFree(data);
     if (ia == NULL) {
-	cbdataFree(hostname);
+	xfree(hostname);
 	return;
     }
     addr = ia->in_addrs[ia->cur];
@@ -248,7 +248,7 @@ netdbSendPing(const ipcache_addrs * ia, void *data)
 	x = (net_db_name *) hash_lookup(host_table, hostname);
 	if (x == NULL) {
 	    debug(38, 1) ("netdbSendPing: net_db_name list bug: %s not found", hostname);
-	    cbdataFree(hostname);
+	    xfree(hostname);
 	    return;
 	}
 	/* remove net_db_name from 'network n' linked list */
@@ -274,7 +274,7 @@ netdbSendPing(const ipcache_addrs * ia, void *data)
 	n->next_ping_time = squid_curtime + Config.Netdb.period;
 	n->last_use_time = squid_curtime;
     }
-    cbdataFree(hostname);
+    xfree(hostname);
 }
 
 static struct in_addr
@@ -678,13 +678,12 @@ netdbPingSite(const char *hostname)
 {
 #if USE_ICMP
     netdbEntry *n;
-    char *h;
+    generic_cbdata *h;
     if ((n = netdbLookupHost(hostname)) != NULL)
 	if (n->next_ping_time > squid_curtime)
 	    return;
-    h = xstrdup(hostname);
-    cbdataAdd(h, cbdataXfree, 0);
-    cbdataLock(h);
+    h = CBDATA_ALLOC(generic_cbdata, NULL);
+    h->data = xstrdup(hostname);
     ipcache_nbgethostbyname(hostname, netdbSendPing, h);
 #endif
 }
@@ -980,14 +979,19 @@ netdbBinaryExchange(StoreEntry * s)
     storeComplete(s);
 }
 
+#if USE_ICMP
+CBDATA_TYPE(netdbExchangeState);
+#endif
+
 void
 netdbExchangeStart(void *data)
 {
 #if USE_ICMP
     peer *p = data;
     char *uri;
-    netdbExchangeState *ex = xcalloc(1, sizeof(*ex));
-    cbdataAdd(ex, cbdataXfree, 0);
+    netdbExchangeState *ex;
+    CBDATA_INIT_TYPE(netdbExchangeState);
+    ex = CBDATA_ALLOC(netdbExchangeState, NULL);
     cbdataLock(p);
     ex->p = p;
     uri = internalRemoteUri(p->host, p->http_port, "/squid-internal-dynamic/", "netdb");
@@ -1,6 +1,6 @@
 
 /*
- * $Id: peer_digest.cc,v 1.75 2000/06/27 22:06:03 hno Exp $
+ * $Id: peer_digest.cc,v 1.76 2001/01/05 09:51:39 adrian Exp $
  *
  * DEBUG: section 72    Peer Digest Routines
  * AUTHOR: Alex Rousskov
@@ -97,15 +97,17 @@ peerDigestClean(PeerDigest * pd)
     stringClean(&pd->host);
 }
 
+CBDATA_TYPE(PeerDigest);
+
 /* allocate new peer digest, call Init, and lock everything */
 PeerDigest *
 peerDigestCreate(peer * p)
 {
     PeerDigest *pd;
     assert(p);
 
-    pd = memAllocate(MEM_PEER_DIGEST);
-    cbdataAdd(pd, memFree, MEM_PEER_DIGEST);
+    CBDATA_INIT_TYPE(PeerDigest);
+    pd = CBDATA_ALLOC(PeerDigest, NULL);
     peerDigestInit(pd, p);
     cbdataLock(pd->peer);	/* we will use the peer */
 
@@ -293,8 +295,7 @@ peerDigestRequest(PeerDigest * pd)
     if (p->login)
 	xstrncpy(req->login, p->login, MAX_LOGIN_SZ);
     /* create fetch state structure */
-    fetch = memAllocate(MEM_DIGEST_FETCH_STATE);
-    cbdataAdd(fetch, memFree, MEM_DIGEST_FETCH_STATE);
+    fetch = CBDATA_ALLOC(DigestFetchState, NULL);
     fetch->request = requestLink(req);
     fetch->pd = pd;
     fetch->offset = 0;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: peer_select.cc,v 1.110 2001/01/01 23:09:59 wessels Exp $
+ * $Id: peer_select.cc,v 1.111 2001/01/05 09:51:39 adrian Exp $
  *
  * DEBUG: section 44    Peer Selection Algorithm
  * AUTHOR: Duane Wessels
@@ -134,12 +134,12 @@ peerSelect(request_t * request,
     PSC * callback,
     void *callback_data)
 {
-    ps_state *psstate = memAllocate(MEM_PS_STATE);
+    ps_state *psstate;
     if (entry)
 	debug(44, 3) ("peerSelect: %s\n", storeUrl(entry));
     else
 	debug(44, 3) ("peerSelect: %s\n", RequestMethodStr[request->method]);
-    cbdataAdd(psstate, memFree, MEM_PS_STATE);
+    psstate = CBDATA_ALLOC(ps_state, NULL);
     psstate->request = requestLink(request);
     psstate->entry = entry;
     psstate->callback = callback;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: protos.h,v 1.391 2001/01/04 21:09:01 wessels Exp $
+ * $Id: protos.h,v 1.392 2001/01/05 09:51:39 adrian Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -86,19 +86,25 @@ extern void self_destruct(void);
 extern int GetInteger(void);
 
 
+/*
+ * cbdata.c
+ */
 extern void cbdataInit(void);
 #if CBDATA_DEBUG
-extern void cbdataAddDbg(const void *p, CBDUNL *, int, const char *, int);
+extern void *cbdataInternalAllocDbg(cbdata_type type, CBDUNL *, int, const char *);
 extern void cbdataLockDbg(const void *p, const char *, int);
 extern void cbdataUnlockDbg(const void *p, const char *, int);
 #else
-extern void cbdataAdd(const void *p, CBDUNL *, int);
+extern void *cbdataInternalAlloc(cbdata_type type, CBDUNL *);
 extern void cbdataLock(const void *p);
 extern void cbdataUnlock(const void *p);
 #endif
+/* Note: Allocations is done using the CBDATA_ALLOC macro */
+
 extern void cbdataFree(void *p);
 extern int cbdataValid(const void *p);
-extern CBDUNL cbdataXfree;
+extern void cbdataInitType(cbdata_type type, char *label, int size);
+extern cbdata_type cbdataAddType(cbdata_type type, char *label, int size);
 
 extern void clientdbInit(void);
 extern void clientdbUpdate(struct in_addr, log_type, protocol_t, size_t);
@@ -772,7 +778,7 @@ extern void memCleanModule(void);
 extern void memConfigure(void);
 extern void *memAllocate(mem_type);
 extern void *memAllocBuf(size_t net_size, size_t * gross_size);
-extern CBDUNL memFree;
+extern void memFree(void *, int type);
 extern void memFreeBuf(size_t size, void *);
 extern void memFree2K(void *);
 extern void memFree4K(void *);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: redirect.cc,v 1.84 2000/03/06 16:23:34 wessels Exp $
+ * $Id: redirect.cc,v 1.85 2001/01/05 09:51:40 adrian Exp $
  *
  * DEBUG: section 29    Redirector
  * AUTHOR: Duane Wessels
@@ -49,6 +49,7 @@ static void redirectStateFree(redirectStateData * r);
 static helper *redirectors = NULL;
 static OBJH redirectStats;
 static int n_bypassed = 0;
+CBDATA_TYPE(redirectStateData);
 
 static void
 redirectHandleReply(void *data, char *reply)
@@ -122,8 +123,7 @@ redirectStart(clientHttpRequest * http, RH * handler, void *data)
 	handler(data, NULL);
 	return;
     }
-    r = xcalloc(1, sizeof(redirectStateData));
-    cbdataAdd(r, cbdataXfree, 0);
+    r = CBDATA_ALLOC(redirectStateData, NULL);
     r->orig_url = xstrdup(http->uri);
     r->client_addr = conn->log_addr;
     if (http->request->user_ident[0])
@@ -165,6 +165,7 @@ redirectInit(void)
 	    "URL Redirector Stats",
 	    redirectStats, 0, 1);
 	init = 1;
+	CBDATA_INIT_TYPE(redirectStateData);
     }
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_repl_heap.cc,v 1.2 2000/11/03 16:39:42 wessels Exp $
+ * $Id: store_repl_heap.cc,v 1.3 2001/01/05 09:52:03 adrian Exp $
  *
  * DEBUG: section ?     HEAP based removal policies
  * AUTHOR: Henrik Nordstrom
@@ -151,14 +151,13 @@ heap_walkInit(RemovalPolicy * policy)
     RemovalPolicyWalker *walker;
     HeapWalkData *heap_walk;
     heap->nwalkers += 1;
-    walker = xcalloc(1, sizeof(*walker));
+    walker = CBDATA_ALLOC(RemovalPolicyWalker, NULL);
     heap_walk = xcalloc(1, sizeof(*heap_walk));
     heap_walk->current = 0;
     walker->_policy = policy;
     walker->_data = heap_walk;
     walker->Next = heap_walkNext;
     walker->Done = heap_walkDone;
-    cbdataAdd(walker, cbdataXfree, 0);
     return walker;
 }
 
@@ -225,7 +224,7 @@ heap_purgeInit(RemovalPolicy * policy, int max_scan)
     RemovalPurgeWalker *walker;
     HeapPurgeData *heap_walk;
     heap->nwalkers += 1;
-    walker = xcalloc(1, sizeof(*walker));
+    walker = CBDATA_ALLOC(RemovalPurgeWalker, NULL);
     heap_walk = xcalloc(1, sizeof(*heap_walk));
     heap_walk->min_age = 0.0;
     heap_walk->locked_entries = NULL;
@@ -234,7 +233,6 @@ heap_purgeInit(RemovalPolicy * policy, int max_scan)
     walker->max_scan = max_scan;
     walker->Next = heap_purgeNext;
     walker->Done = heap_purgeDone;
-    cbdataAdd(walker, cbdataXfree, 0);
 #if HEAP_REPLACEMENT_DEBUG
     if (!verify_heap_property(heap->heap)) {
 	debug(81, 1) ("Heap property violated!\n");
@@ -264,10 +262,8 @@ createRemovalPolicy_heap(wordlist * args)
     HeapPolicyData *heap_data;
     char *keytype;
     /* Allocate the needed structures */
-    policy = xcalloc(1, sizeof(*policy));
+    policy = CBDATA_ALLOC(RemovalPolicy, NULL);
     heap_data = xcalloc(1, sizeof(*heap_data));
-    /* cbdata register the policy */
-    cbdataAdd(policy, cbdataXfree, 0);
     /* Initialize the policy data */
     heap_data->policy = policy;
     if (args) {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_repl_lru.cc,v 1.3 2000/10/06 05:13:04 wessels Exp $
+ * $Id: store_repl_lru.cc,v 1.4 2001/01/05 09:52:11 adrian Exp $
  *
  * DEBUG: section ?     LRU Removal policy
  * AUTHOR: Henrik Nordstrom
@@ -162,14 +162,13 @@ lru_walkInit(RemovalPolicy * policy)
     RemovalPolicyWalker *walker;
     LruWalkData *lru_walk;
     lru->nwalkers += 1;
-    walker = xcalloc(1, sizeof(*walker));
+    walker=CBDATA_ALLOC(RemovalPolicyWalker, NULL);
     lru_walk = xcalloc(1, sizeof(*lru_walk));
     walker->_policy = policy;
     walker->_data = lru_walk;
     walker->Next = lru_walkNext;
     walker->Done = lru_walkDone;
     lru_walk->current = (LruNode *) lru->list.head;
-    cbdataAdd(walker, cbdataXfree, 0);
     return walker;
 }
 
@@ -232,15 +231,14 @@ lru_purgeInit(RemovalPolicy * policy, int max_scan)
     RemovalPurgeWalker *walker;
     LruPurgeData *lru_walk;
     lru->nwalkers += 1;
-    walker = xcalloc(1, sizeof(*walker));
+    walker=CBDATA_ALLOC(RemovalPurgeWalker, NULL);
     lru_walk = xcalloc(1, sizeof(*lru_walk));
     walker->_policy = policy;
     walker->_data = lru_walk;
     walker->max_scan = max_scan;
     walker->Next = lru_purgeNext;
     walker->Done = lru_purgeDone;
     lru_walk->start = lru_walk->current = (LruNode *) lru->list.head;
-    cbdataAdd(walker, cbdataXfree, 0);
     return walker;
 }
 
@@ -269,10 +267,8 @@ createRemovalPolicy_lru(wordlist * args)
     if (!lru_node_pool)
 	lru_node_pool = memPoolCreate("LRU policy node", sizeof(LruNode));
     /* Allocate the needed structures */
-    policy = xcalloc(1, sizeof(*policy));
     lru_data = xcalloc(1, sizeof(*lru_data));
-    /* cbdata register the policy */
-    cbdataAdd(policy, cbdataXfree, 0);
+    policy=CBDATA_ALLOC(RemovalPolicy, NULL);
     /* Initialize the URL data */
     lru_data->policy = policy;
     /* Populate the policy structure */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: send-announce.cc,v 1.59 2001/01/04 03:42:35 wessels Exp $
+ * $Id: send-announce.cc,v 1.60 2001/01/05 09:51:40 adrian Exp $
  *
  * DEBUG: section 27    Cache Announcer
  * AUTHOR: Duane Wessels
@@ -40,13 +40,11 @@ static IPH send_announce;
 void
 start_announce(void *datanotused)
 {
-    void *junk;
     if (0 == Config.onoff.announce)
 	return;
     if (theOutIcpConnection < 0)
 	return;
-    cbdataAdd(junk = xmalloc(1), cbdataXfree, 0);
-    ipcache_nbgethostbyname(Config.Announce.host, send_announce, junk);
+    ipcache_nbgethostbyname(Config.Announce.host, send_announce, NULL);
     eventAdd("send_announce", start_announce, NULL, (double) Config.Announce.period, 1);
 }
 
@@ -63,7 +61,6 @@ send_announce(const ipcache_addrs * ia, void *junk)
     int n;
     int fd;
     int x;
-    cbdataFree(junk);
     if (ia == NULL) {
 	debug(27, 1) ("send_announce: Unknown host '%s'\n", host);
 	return;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: squid.h,v 1.206 2001/01/04 22:34:18 hno Exp $
+ * $Id: squid.h,v 1.207 2001/01/05 09:51:40 adrian Exp $
  *
  * AUTHOR: Duane Wessels
  *
@@ -318,7 +318,7 @@ struct rusage {
 #endif
 
 #if CBDATA_DEBUG
-#define cbdataAdd(a,b,c)	cbdataAddDbg(a,b,c,__FILE__,__LINE__)
+#define cbdataAlloc(a,b)	cbdataAllocDbg(a,b,__FILE__,__LINE__)
 #define cbdataLock(a)		cbdataLockDbg(a,__FILE__,__LINE__)
 #define cbdataUnlock(a)		cbdataUnlockDbg(a,__FILE__,__LINE__)
 #endif
@@ -432,3 +432,4 @@ struct rusage {
 #define INDEXSD(i)   (&Config.cacheSwap.swapDirs[(i)])
 
 #endif /* SQUID_H */
+#define CREATE_CBDATA(type) cbdataInitType(CBDATA_##type, #type, sizeof(type))
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ssl.cc,v 1.108 2000/10/04 02:18:49 wessels Exp $
+ * $Id: ssl.cc,v 1.109 2001/01/05 09:51:40 adrian Exp $
  *
  * DEBUG: section 26    Secure Sockets Layer Proxy
  * AUTHOR: Duane Wessels
@@ -429,6 +429,7 @@ sslConnectDone(int fdnotused, int status, void *data)
     }
 }
 
+CBDATA_TYPE(SslStateData);
 void
 sslStart(int fd, const char *url, request_t * request, size_t * size_ptr, int *status_ptr)
 {
@@ -482,8 +483,8 @@ sslStart(int fd, const char *url, request_t * request, size_t * size_ptr, int *s
 	errorSend(fd, err);
 	return;
     }
-    sslState = xcalloc(1, sizeof(SslStateData));
-    cbdataAdd(sslState, cbdataXfree, 0);
+    CBDATA_INIT_TYPE(SslStateData);
+    sslState = CBDATA_ALLOC(SslStateData, NULL);
 #if DELAY_POOLS
     sslState->delay_id = delayClient(request);
     delayRegisterDelayIdPtr(&sslState->delay_id);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: stat.cc,v 1.340 2000/10/31 23:48:14 wessels Exp $
+ * $Id: stat.cc,v 1.341 2001/01/05 09:51:40 adrian Exp $
  *
  * DEBUG: section 18    Cache Manager Statistics
  * AUTHOR: Harvest Derived
@@ -88,6 +88,7 @@ StatCounters CountHist[N_COUNT_HIST];
 static int NCountHist = 0;
 static StatCounters CountHourHist[N_COUNT_HOUR_HIST];
 static int NCountHourHist = 0;
+CBDATA_TYPE(StatObjectsState);
 
 extern unsigned int mem_pool_alloc_calls;
 extern unsigned int mem_pool_free_calls;
@@ -343,11 +344,11 @@ statObjects(void *data)
 static void
 statObjectsStart(StoreEntry * sentry, STOBJFLT * filter)
 {
-    StatObjectsState *state = xcalloc(1, sizeof(*state));
+    StatObjectsState *state;
+    state = CBDATA_ALLOC(StatObjectsState, NULL);
     state->sentry = sentry;
     state->filter = filter;
     storeLockObject(sentry);
-    cbdataAdd(state, cbdataXfree, 0);
     eventAdd("statObjects", statObjects, state, 0.0, 1);
 }
 
@@ -832,6 +833,7 @@ statInit(void)
 {
     int i;
     debug(18, 5) ("statInit: Initializing...\n");
+    CBDATA_INIT_TYPE(StatObjectsState);
     for (i = 0; i < N_COUNT_HIST; i++)
 	statCountersInit(&CountHist[i]);
     for (i = 0; i < N_COUNT_HOUR_HIST; i++)
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_client.cc,v 1.98 2000/10/31 23:48:15 wessels Exp $
+ * $Id: store_client.cc,v 1.99 2001/01/05 09:51:40 adrian Exp $
  *
  * DEBUG: section 20    Storage Manager Client-Side Interface
  * AUTHOR: Duane Wessels
@@ -133,8 +133,7 @@ storeClientListAdd(StoreEntry * e, void *data)
 #endif
     e->refcount++;
     mem->nclients++;
-    sc = memAllocate(MEM_STORE_CLIENT);
-    cbdataAdd(sc, memFree, MEM_STORE_CLIENT);	/* sc is callback_data for file_read */
+    sc = CBDATA_ALLOC(store_client, NULL);
     cbdataLock(data);		/* locked while we point to it */
     sc->callback_data = data;
     sc->seen_offset = 0;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_digest.cc,v 1.44 2000/11/14 07:06:19 wessels Exp $
+ * $Id: store_digest.cc,v 1.45 2001/01/05 09:51:40 adrian Exp $
  *
  * DEBUG: section 71    Store Digest Manager
  * AUTHOR: Alex Rousskov
@@ -51,7 +51,7 @@
 typedef struct {
     StoreDigestCBlock cblock;
     int rebuild_lock;		/* bucket number */
-    StoreEntry *rewrite_lock;	/* store entry with the digest */
+    generic_cbdata *rewrite_lock;	/* points to store entry with the digest */
     int rebuild_offset;
     int rewrite_offset;
     int rebuild_count;
@@ -350,9 +350,10 @@ storeDigestRewriteStart(void *datanotused)
     url = internalLocalUri("/squid-internal-periodic/", StoreDigestFileName);
     flags = null_request_flags;
     flags.cachable = 1;
-    sd_state.rewrite_lock = e = storeCreateEntry(url, url, flags, METHOD_GET);
-    assert(sd_state.rewrite_lock);
-    cbdataAdd(sd_state.rewrite_lock, NULL, 0);
+    e = storeCreateEntry(url, url, flags, METHOD_GET);
+    assert(e);
+    sd_state.rewrite_lock = CBDATA_ALLOC(generic_cbdata, NULL);
+    sd_state.rewrite_lock->data = e;
     debug(71, 3) ("storeDigestRewrite: url: %s key: %s\n", url, storeKeyText(e->hash.key));
     e->mem_obj->request = requestLink(urlParse(METHOD_GET, url));
     /* wait for rebuild (if any) to finish */
@@ -366,11 +367,12 @@ storeDigestRewriteStart(void *datanotused)
 static void
 storeDigestRewriteResume(void)
 {
-    StoreEntry *e = sd_state.rewrite_lock;
+    StoreEntry *e;
     http_version_t version;
 
     assert(sd_state.rewrite_lock);
     assert(!sd_state.rebuild_lock);
+    e = sd_state.rewrite_lock->data;
     sd_state.rewrite_offset = 0;
     EBIT_SET(e->flags, ENTRY_SPECIAL);
     /* setting public key will purge old digest entry if any */
@@ -394,7 +396,7 @@ storeDigestRewriteResume(void)
 static void
 storeDigestRewriteFinish(StoreEntry * e)
 {
-    assert(e == sd_state.rewrite_lock);
+    assert(sd_state.rewrite_lock && e == sd_state.rewrite_lock->data);
     storeComplete(e);
     storeTimestampsSet(e);
     debug(71, 2) ("storeDigestRewriteFinish: digest expires at %d (%+d)\n",
@@ -403,10 +405,6 @@ storeDigestRewriteFinish(StoreEntry * e)
     requestUnlink(e->mem_obj->request);
     e->mem_obj->request = NULL;
     storeUnlockObject(e);
-    /*
-     * note, it won't really get free()'d here because we used
-     * MEM_DONTFREE in the call to cbdataAdd().
-     */
     cbdataFree(sd_state.rewrite_lock);
     sd_state.rewrite_lock = e = NULL;
     sd_state.rewrite_count++;
@@ -421,10 +419,11 @@ storeDigestRewriteFinish(StoreEntry * e)
 static void
 storeDigestSwapOutStep(void *data)
 {
-    StoreEntry *e = data;
+    StoreEntry *e;
     int chunk_size = Config.digest.swapout_chunk_size;
+    assert(data == sd_state.rewrite_lock);
+    e = (StoreEntry *) ((generic_cbdata *) data)->data;
     assert(e);
-    assert(e == sd_state.rewrite_lock);
     /* _add_ check that nothing bad happened while we were waiting @?@ @?@ */
     if (sd_state.rewrite_offset + chunk_size > store_digest->mask_size)
 	chunk_size = store_digest->mask_size - sd_state.rewrite_offset;
@@ -436,7 +435,7 @@ storeDigestSwapOutStep(void *data)
     if (sd_state.rewrite_offset >= store_digest->mask_size)
 	storeDigestRewriteFinish(e);
     else
-	eventAdd("storeDigestSwapOutStep", storeDigestSwapOutStep, e, 0.0, 1);
+	eventAdd("storeDigestSwapOutStep", storeDigestSwapOutStep, data, 0.0, 1);
 }
 
 static void
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store_swapout.cc,v 1.77 2000/10/31 23:48:15 wessels Exp $
+ * $Id: store_swapout.cc,v 1.78 2001/01/05 09:51:41 adrian Exp $
  *
  * DEBUG: section 20    Storage Manager Swapout Functions
  * AUTHOR: Duane Wessels
@@ -61,9 +61,8 @@ storeSwapOutStart(StoreEntry * e)
     storeSwapTLVFree(tlv_list);
     mem->swap_hdr_sz = (size_t) swap_hdr_sz;
     /* Create the swap file */
-    c = memAllocate(MEM_GEN_CBDATA);
+    c = CBDATA_ALLOC(generic_cbdata, NULL);
     c->data = e;
-    cbdataAdd(c, memFree, MEM_GEN_CBDATA);
     mem->swapout.sio = storeCreate(e, storeSwapOutFileNotify, storeSwapOutFileClosed, c);
     if (NULL == mem->swapout.sio) {
 	e->swap_status = SWAPOUT_NONE;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: tunnel.cc,v 1.108 2000/10/04 02:18:49 wessels Exp $
+ * $Id: tunnel.cc,v 1.109 2001/01/05 09:51:40 adrian Exp $
  *
  * DEBUG: section 26    Secure Sockets Layer Proxy
  * AUTHOR: Duane Wessels
@@ -429,6 +429,7 @@ sslConnectDone(int fdnotused, int status, void *data)
     }
 }
 
+CBDATA_TYPE(SslStateData);
 void
 sslStart(int fd, const char *url, request_t * request, size_t * size_ptr, int *status_ptr)
 {
@@ -482,8 +483,8 @@ sslStart(int fd, const char *url, request_t * request, size_t * size_ptr, int *s
 	errorSend(fd, err);
 	return;
     }
-    sslState = xcalloc(1, sizeof(SslStateData));
-    cbdataAdd(sslState, cbdataXfree, 0);
+    CBDATA_INIT_TYPE(SslStateData);
+    sslState = CBDATA_ALLOC(SslStateData, NULL);
 #if DELAY_POOLS
     sslState->delay_id = delayClient(request);
     delayRegisterDelayIdPtr(&sslState->delay_id);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: typedefs.h,v 1.112 2001/01/04 21:09:02 wessels Exp $
+ * $Id: typedefs.h,v 1.113 2001/01/05 09:51:41 adrian Exp $
  *
  *
  * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
@@ -195,7 +195,7 @@ typedef void CWCB(int fd, char *, size_t size, int flag, void *data);
 typedef void CNCB(int fd, int status, void *);
 
 typedef void FREE(void *);
-typedef void CBDUNL(void *, int);
+typedef void CBDUNL(void *);
 typedef void FOCB(void *, int fd, int errcode);
 typedef void EVH(void *);
 typedef void PF(int, void *);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: urn.cc,v 1.62 2000/12/05 09:16:02 wessels Exp $
+ * $Id: urn.cc,v 1.63 2001/01/05 09:51:41 adrian Exp $
  *
  * DEBUG: section 52    URN Parsing
  * AUTHOR: Kostas Anagnostakis
@@ -95,6 +95,7 @@ urnFindMinRtt(url_entry * urls, method_t m, int *rtt_ret)
     return min_u;
 }
 
+CBDATA_TYPE(UrnState);
 void
 urnStart(request_t * r, StoreEntry * e)
 {
@@ -106,10 +107,10 @@ urnStart(request_t * r, StoreEntry * e)
     StoreEntry *urlres_e;
     ErrorState *err;
     debug(52, 3) ("urnStart: '%s'\n", storeUrl(e));
-    urnState = xcalloc(1, sizeof(UrnState));
+    CBDATA_INIT_TYPE(UrnState);
+    urnState = CBDATA_ALLOC(UrnState, NULL);
     urnState->entry = e;
     urnState->request = requestLink(r);
-    cbdataAdd(urnState, cbdataXfree, 0);
     storeLockObject(urnState->entry);
     if (strncasecmp(strBuf(r->urlpath), "menu.", 5) == 0) {
 	char *new_path = xstrdup(strBuf(r->urlpath) + 5);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: wais.cc,v 1.133 2000/06/27 22:06:05 hno Exp $
+ * $Id: wais.cc,v 1.134 2001/01/05 09:51:41 adrian Exp $
  *
  * DEBUG: section 24    WAIS Relay
  * AUTHOR: Harvest Derived
@@ -216,6 +216,7 @@ waisSendRequest(int fd, void *data)
     EBIT_CLR(waisState->entry->flags, ENTRY_FWD_HDR_WAIT);
 }
 
+CBDATA_TYPE(WaisStateData);
 void
 waisStart(FwdState * fwd)
 {
@@ -228,8 +229,8 @@ waisStart(FwdState * fwd)
     debug(24, 3) ("waisStart: \"%s %s\"\n", RequestMethodStr[method], url);
     statCounter.server.all.requests++;
     statCounter.server.other.requests++;
-    waisState = xcalloc(1, sizeof(WaisStateData));
-    cbdataAdd(waisState, cbdataXfree, 0);
+    CBDATA_INIT_TYPE(WaisStateData);
+    waisState = CBDATA_ALLOC(WaisStateData, NULL);
     waisState->method = method;
     waisState->request_hdr = &request->header;
     waisState->fd = fd;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: whois.cc,v 1.12 2000/06/27 22:06:06 hno Exp $
+ * $Id: whois.cc,v 1.13 2001/01/05 09:51:41 adrian Exp $
  *
  * DEBUG: section 75    WHOIS protocol
  * AUTHOR: Duane Wessels, Kostas Anagnostakis
@@ -49,17 +49,20 @@ static PF whoisReadReply;
 
 /* PUBLIC */
 
+CBDATA_TYPE(WhoisState);
+
 void
 whoisStart(FwdState * fwd)
 {
-    WhoisState *p = xcalloc(1, sizeof(*p));
+    WhoisState *p;
     int fd = fwd->server_fd;
     char *buf;
     size_t l;
+    CBDATA_INIT_TYPE(WhoisState);
+    p = CBDATA_ALLOC(WhoisState, NULL);
     p->request = fwd->request;
     p->entry = fwd->entry;
     p->fwd = fwd;
-    cbdataAdd(p, cbdataXfree, 0);
     storeLockObject(p->entry);
     comm_add_close_handler(fd, whoisClose, p);
     l = strLen(p->request->urlpath) + 3;