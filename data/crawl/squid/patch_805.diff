@@ -813,7 +813,7 @@ AC_ARG_ENABLE(icap-client,
 if test "$use_icap_client" = "yes" ; then
   AC_DEFINE(ICAP_CLIENT,1,[Enable ICAP client features in Squid])
   AM_CONDITIONAL(USE_ICAP_CLIENT, true)
-  ICAP_LIBS="ICAP/libicap.la"
+  ICAP_LIBS="icap/libicap.la"
   use_adaptation=yes
 else
   AC_DEFINE(ICAP_CLIENT,0,[Enable ICAP client features in Squid])
@@ -860,7 +860,7 @@ AM_CONDITIONAL(USE_ECAP, test $use_ecap = yes)
 if test $use_ecap = yes;
 then
     AC_DEFINE(USE_ECAP,1,[Enable eCAP support])
-    ECAP_LIBS="eCAP/libeCAP.la $ECAP_LIBS"
+    ECAP_LIBS="ecap/libecap.la $ECAP_LIBS"
     use_adaptation=yes
 else
     AC_DEFINE(USE_ECAP,0,[Disable eCAP support])
@@ -3800,10 +3800,10 @@ AC_CONFIG_FILES([\
 	src/repl/Makefile \
 	src/auth/Makefile \
 	src/adaptation/Makefile \
-	src/ICAP/Makefile \
+	src/adaptation/icap/Makefile \
+	src/adaptation/ecap/Makefile \
 	src/icmp/Makefile \
 	src/ip/Makefile \
-	src/eCAP/Makefile \
 	contrib/Makefile \
 	snmplib/Makefile \
 	icons/Makefile \
@@ -1,11 +0,0 @@
-#include "squid.h"
-#include "ICAPClient.h"
-
-void ICAPInitModule()
-{
-    debugs(93,2, "ICAP Client module enabled.");
-}
-
-void ICAPCleanModule()
-{
-}
@@ -1,105 +0,0 @@
-/*
- * DEBUG: section 93    ICAP (RFC 3507) Client
- */
-
-#include "squid.h"
-#include "comm.h"
-#include "HttpReply.h"
-
-#include "ICAPOptXact.h"
-#include "ICAPOptions.h"
-#include "TextException.h"
-
-CBDATA_CLASS_INIT(ICAPOptXact);
-CBDATA_CLASS_INIT(ICAPOptXactLauncher);
-
-
-ICAPOptXact::ICAPOptXact(Adaptation::Initiator *anInitiator, ICAPServiceRep::Pointer &aService):
-        AsyncJob("ICAPOptXact"),
-        ICAPXaction("ICAPOptXact", anInitiator, aService)
-{
-}
-
-void ICAPOptXact::start()
-{
-    ICAPXaction::start();
-
-    openConnection();
-}
-
-void ICAPOptXact::handleCommConnected()
-{
-    scheduleRead();
-
-    MemBuf requestBuf;
-    requestBuf.init();
-    makeRequest(requestBuf);
-    debugs(93, 9, "ICAPOptXact request " << status() << ":\n" <<
-           (requestBuf.terminate(), requestBuf.content()));
-
-    scheduleWrite(requestBuf);
-}
-
-void ICAPOptXact::makeRequest(MemBuf &buf)
-{
-    const Adaptation::Service &s = service();
-    const String uri = s.cfg().uri;
-    buf.Printf("OPTIONS " SQUIDSTRINGPH " ICAP/1.0\r\n", SQUIDSTRINGPRINT(uri));
-    const String host = s.cfg().host;
-    buf.Printf("Host: " SQUIDSTRINGPH ":%d\r\n", SQUIDSTRINGPRINT(host), s.cfg().port);
-    buf.append(ICAP::crlf, 2);
-}
-
-void ICAPOptXact::handleCommWrote(size_t size)
-{
-    debugs(93, 9, "ICAPOptXact finished writing " << size <<
-           "-byte request " << status());
-}
-
-// comm module read a portion of the ICAP response for us
-void ICAPOptXact::handleCommRead(size_t)
-{
-    if (HttpMsg *r = parseResponse()) {
-        sendAnswer(r);
-        Must(done()); // there should be nothing else to do
-        return;
-    }
-
-    scheduleRead();
-}
-
-HttpMsg *ICAPOptXact::parseResponse()
-{
-    debugs(93, 5, HERE << "have " << readBuf.contentSize() << " bytes to parse" <<
-           status());
-    debugs(93, 5, HERE << "\n" << readBuf.content());
-
-    HttpReply *r = new HttpReply;
-    r->protoPrefix = "ICAP/"; // TODO: make an IcapReply class?
-
-    if (!parseHttpMsg(r)) { // throws on errors
-        delete r;
-        return 0;
-    }
-
-    if (httpHeaderHasConnDir(&r->header, "close"))
-        reuseConnection = false;
-
-    return r;
-}
-
-/* ICAPOptXactLauncher */
-
-ICAPOptXactLauncher::ICAPOptXactLauncher(Adaptation::Initiator *anInitiator, Adaptation::ServicePointer aService):
-        AsyncJob("ICAPOptXactLauncher"),
-        ICAPLauncher("ICAPOptXactLauncher", anInitiator, aService)
-{
-}
-
-ICAPXaction *ICAPOptXactLauncher::createXaction()
-{
-    ICAPServiceRep::Pointer s =
-        dynamic_cast<ICAPServiceRep*>(theService.getRaw());
-    Must(s != NULL);
-    return new ICAPOptXact(this, s);
-}
@@ -1,44 +0,0 @@
-AM_CFLAGS = @SQUID_CFLAGS@
-AM_CXXFLAGS = @SQUID_CXXFLAGS@
-CLEANFILES =
-
-INCLUDES = \
-	-I$(top_srcdir) \
-	-I$(top_builddir)/include \
-	-I$(top_srcdir)/include \
-        -I$(top_srcdir)/src
-
-noinst_LTLIBRARIES = libicap.la
-
-libicap_la_SOURCES = \
-	ICAPClient.cc \
-	ICAPClient.h \
-	ICAPInOut.h \
-	ICAPConfig.cc \
-	ICAPConfig.h \
-	ICAPElements.cc \
-	ICAPElements.h \
-	ICAPOptions.cc \
-	ICAPOptions.h \
-	ICAPServiceRep.cc \
-	ICAPServiceRep.h \
-	ICAPLauncher.cc \
-	ICAPLauncher.h \
-	ICAPOptXact.cc \
-	ICAPOptXact.h \
-	ICAPXaction.cc \
-	ICAPXaction.h \
-	ICAPModXact.cc \
-	ICAPModXact.h
-
-
-check_PROGRAMS = testHeaders
-
-## test .h correctness
-testHeaders: $(top_srcdir)/src/ICAP/*.h
-	$(top_srcdir)/test-suite/testheaders.sh "$(CXXCOMPILE)" "." || exit 1
-
-## No such file...
-testHeaders.c:
-	touch testHeaders.c
-CLEANFILES += testHeaders.c
@@ -38,15 +38,7 @@ if USE_ADAPTATION
 SUBDIRS += adaptation
 endif
 
-if USE_ICAP_CLIENT
-SUBDIRS += ICAP
-endif
-
-if USE_ECAP
-SUBDIRS += eCAP
-endif
-
-ADAPTATION_LIBS = @ECAP_LIBS@ @ICAP_LIBS@ @ADAPTATION_LIBS@
+ADAPTATION_LIBS = @ADAPTATION_LIBS@
 
 DELAY_POOL_ALL_SOURCE = \
 	CommonPool.h \
@@ -52,7 +52,7 @@ Adaptation::AccessCheck::AccessCheck(Method aMethod,
 
     acl_checklist = NULL;
 
-    debugs(93, 5, "AccessCheck constructed for " << methodStr(method) << " " << vectPointStr(point));
+    debugs(93, 5, HERE << "AccessCheck constructed for " << methodStr(method) << " " << vectPointStr(point));
 }
 
 Adaptation::AccessCheck::~AccessCheck()
@@ -70,7 +70,7 @@ Adaptation::AccessCheck::~AccessCheck()
 void
 Adaptation::AccessCheck::check()
 {
-    debugs(93, 4, "Adaptation::AccessCheck::check");
+    debugs(93, 4, HERE << "start checking");
 
     typedef AccessRules::iterator ARI;
     for (ARI i = AllRules().begin(); i != AllRules().end(); ++i) {
@@ -84,7 +84,7 @@ Adaptation::AccessCheck::check()
         AccessRule *r = *i;
         ServicePointer service = findBestService(*r, false);
         if (service != NULL) {
-            debugs(93, 5, "Adaptation::AccessCheck::check: rule '" << r->id << "' has candidate service '" << service->cfg().key << "'");
+            debugs(93, 5, HERE << "check: rule '" << r->id << "' has candidate service '" << service->cfg().key << "'");
             candidates += r->id;
         }
     }
@@ -100,7 +100,7 @@ Adaptation::AccessCheck::check()
 void
 Adaptation::AccessCheck::checkCandidates()
 {
-    debugs(93, 4, "Adaptation::AccessCheck has " << candidates.size() << " rules");
+    debugs(93, 4, HERE << "has " << candidates.size() << " rules");
 
     while (!candidates.empty()) {
         if (AccessRule *r = FindRule(topCandidate())) {
@@ -116,14 +116,14 @@ Adaptation::AccessCheck::checkCandidates()
     }
 
     // when there are no canidates, fake answer 1
-    debugs(93, 4, "Adaptation::AccessCheck::check: NO candidates left");
+    debugs(93, 4, HERE << "NO candidates left");
     noteAnswer(1);
 }
 
 void
 Adaptation::AccessCheck::AccessCheckCallbackWrapper(int answer, void *data)
 {
-    debugs(93, 8, "AccessCheckCallbackWrapper: answer=" << answer);
+    debugs(93, 8, HERE << "callback answer=" << answer);
     AccessCheck *ac = (AccessCheck*)data;
 
     /** \todo AYJ 2008-06-12: If answer == ACCESS_REQ_PROXY_AUTH
@@ -156,7 +156,7 @@ Adaptation::AccessCheck::noteAnswer(int answer)
 void
 Adaptation::AccessCheck::do_callback()
 {
-    debugs(93, 3, "Adaptation::AccessCheck::do_callback");
+    debugs(93, 3, HERE);
 
     if (candidates.size())
         debugs(93, 3, HERE << "was checking rule" << topCandidate());
@@ -82,7 +82,7 @@ Adaptation::Config::finalize()
     // create service reps from service configs
     typedef Vector<ServiceConfig*>::const_iterator VISCI;
     const Vector<ServiceConfig*> &configs = serviceConfigs;
-    debugs(93,3, "Found " << configs.size() << " service configs.");
+    debugs(93,3, HERE << "Found " << configs.size() << " service configs.");
     for (VISCI i = configs.begin(); i != configs.end(); ++i) {
         const ServiceConfig &cfg = **i;
         if (FindService(cfg.key) != NULL) {
@@ -95,7 +95,7 @@ Adaptation::Config::finalize()
             AllServices().push_back(s);
     }
 
-    debugs(93,3, "Created " << configs.size() <<
+    debugs(93,3, HERE << "Created " << configs.size() <<
            " message adaptation services.");
 }
 
@@ -108,7 +108,7 @@ FinalizeEach(Collection &collection, const char *label)
     for (CI i = collection.begin(); i != collection.end(); ++i)
         (*i)->finalize();
 
-    debugs(93,2, "Initialized " << collection.size() << ' ' << label);
+    debugs(93,2, HERE << "Initialized " << collection.size() << ' ' << label);
 }
 
 void
@@ -1,15 +1,20 @@
-AM_CFLAGS = @SQUID_CFLAGS@
-AM_CXXFLAGS = @SQUID_CXXFLAGS@
-CLEANFILES =
+include $(top_srcdir)/src/Common.am
+include $(top_srcdir)/src/TestHeaders.am
 
-INCLUDES = \
-	-I$(top_srcdir) \
-	-I$(top_builddir)/include \
-	-I$(top_srcdir)/include \
-        -I$(top_srcdir)/src
+## make a list of directories for configured adaptation schemes
+SUBDIRS =
+
+if USE_ICAP_CLIENT
+SUBDIRS += icap
+endif
+
+if USE_ECAP
+SUBDIRS += ecap
+endif
 
 noinst_LTLIBRARIES = libadaptation.la
 
+## start with the code shared among all adaptation schemes
 libadaptation_la_SOURCES = \
 	AccessCheck.cc \
 	AccessCheck.h \
@@ -33,13 +38,6 @@ libadaptation_la_SOURCES = \
 	ServiceGroups.cc \
 	ServiceGroups.h
 
-check_PROGRAMS = testHeaders
-
-## test .h correctness
-testHeaders: $(top_srcdir)/src/adaptation/*.h
-	$(top_srcdir)/test-suite/testheaders.sh "$(CXXCOMPILE)" "." || exit 1
+# add libraries for specific adaptation schemes
+libadaptation_la_LIBADD = @ECAP_LIBS@ @ICAP_LIBS@
 
-## No such file...
-testHeaders.c:
-	touch testHeaders.c
-CLEANFILES += testHeaders.c
@@ -6,9 +6,9 @@
 #include "squid.h"
 
 #include <libecap/common/registry.h>
-#include "eCAP/Host.h"
-#include "eCAP/ServiceRep.h"
-#include "eCAP/Config.h"
+#include "adaptation/ecap/Host.h"
+#include "adaptation/ecap/ServiceRep.h"
+#include "adaptation/ecap/Config.h"
 
 Ecap::Config Ecap::TheConfig;
 
@@ -2,8 +2,8 @@
 #include <libecap/adapter/service.h>
 #include <libecap/common/names.h>
 #include "TextException.h"
-#include "eCAP/ServiceRep.h"
-#include "eCAP/Host.h"
+#include "adaptation/ecap/ServiceRep.h"
+#include "adaptation/ecap/Host.h"
 
 const libecap::Name Ecap::protocolInternal("internal", libecap::Name::NextId());
 const libecap::Name Ecap::protocolCacheObj("cache_object", libecap::Name::NextId());
@@ -63,7 +63,7 @@ Ecap::Host::noteService(const libecap::weak_ptr<libecap::adapter::Service> &weak
         }
     }
 
-    debugs(93,5, "Found " << found << " ecap_service configs for " <<
+    debugs(93,5, HERE << "Found " << found << " ecap_service configs for " <<
            shared->uri());
     if (!found) {
         debugs(93,1, "Warning: ignoring loaded eCAP module service without " <<
@@ -0,0 +1,18 @@
+include $(top_srcdir)/src/Common.am
+include $(top_srcdir)/src/TestHeaders.am
+
+noinst_LTLIBRARIES = libecap.la
+
+libecap_la_SOURCES = \
+	Config.h \
+	Config.cc \
+	Host.h \
+	Host.cc \
+	MessageRep.h \
+	MessageRep.cc \
+	ServiceRep.h \
+	ServiceRep.cc \
+	XactionRep.h \
+	XactionRep.cc \
+	\
+	Registry.h
@@ -7,13 +7,12 @@
 #include "HttpReply.h"
 #include "BodyPipe.h"
 #include "TextException.h"
-#include "adaptation/Message.h"
 #include <libecap/common/names.h>
 #include <libecap/common/area.h>
 #include <libecap/common/version.h>
-#include "eCAP/MessageRep.h"
-#include "eCAP/XactionRep.h"
-#include "eCAP/Host.h" /* for protocol constants */
+#include "adaptation/ecap/MessageRep.h"
+#include "adaptation/ecap/XactionRep.h"
+#include "adaptation/ecap/Host.h" /* for protocol constants */
 
 /* HeaderRep */
 
@@ -6,11 +6,19 @@
 #ifndef SQUID__ECAP__MESSAGE_REP_H
 #define SQUID__ECAP__MESSAGE_REP_H
 
+#include "config.h"
+#include "HttpHeader.h"
+#include "BodyPipe.h"
 #include "adaptation/forward.h"
+#include "adaptation/Message.h"
 #include <libecap/common/message.h>
 #include <libecap/common/header.h>
 #include <libecap/common/body.h>
 
+class HttpMsg;
+class HttpRequest;
+class HttpReply;
+
 namespace Ecap
 {
 
@@ -1,8 +1,8 @@
 #include "squid.h"
 #include <libecap/adapter/service.h>
 #include "TextException.h"
-#include "eCAP/ServiceRep.h"
-#include "eCAP/XactionRep.h"
+#include "adaptation/ecap/ServiceRep.h"
+#include "adaptation/ecap/XactionRep.h"
 
 Ecap::ServiceRep::ServiceRep(const Adaptation::ServiceConfig &cfg):
         /*AsyncJob("Ecap::ServiceRep"),*/ Adaptation::Service(cfg)
@@ -17,7 +17,7 @@ void Ecap::ServiceRep::noteService(const AdapterService &s)
 {
     Must(s != NULL);
     theService = s;
-    debugs(93,7, "Matched loaded and configured eCAP services: " <<
+    debugs(93,7, HERE << "matched loaded and configured eCAP services: " <<
            s->uri() << ' ' << cfg().key << "\n");
 }
 
@@ -5,11 +5,9 @@
 #include "TextException.h"
 #include "HttpRequest.h"
 #include "HttpReply.h"
-#include "eCAP/XactionRep.h"
+#include "adaptation/ecap/XactionRep.h"
 
-// CBDATA_CLASS_INIT(Ecap::XactionRep);
-// TODO: add CBDATA_NAMESPACED_CLASS_INIT(namespace, classname)
-cbdata_type Ecap::XactionRep::CBDATA_XactionRep = CBDATA_UNKNOWN;
+CBDATA_NAMESPACED_CLASS_INIT(Ecap::XactionRep, XactionRep);
 
 
 Ecap::XactionRep::XactionRep(Adaptation::Initiator *anInitiator,
@@ -10,7 +10,7 @@
 #include "adaptation/Initiate.h"
 #include "adaptation/Service.h"
 #include "adaptation/Message.h"
-#include "eCAP/MessageRep.h"
+#include "adaptation/ecap/MessageRep.h"
 #include <libecap/common/forward.h>
 #include <libecap/common/memory.h>
 #include <libecap/host/xaction.h>
@@ -0,0 +1,11 @@
+#include "squid.h"
+#include "adaptation/icap/Client.h"
+
+void Adaptation::Icap::InitModule()
+{
+    debugs(93,2, HERE << "module enabled.");
+}
+
+void Adaptation::Icap::CleanModule()
+{
+}
@@ -36,7 +36,15 @@
 
 // ICAP-related things needed by code unaware of ICAP internals.
 
-extern void ICAPInitModule();
-extern void ICAPCleanModule();
+
+namespace Adaptation {
+namespace Icap {
+
+extern void InitModule();
+extern void CleanModule();
+
+
+} // namespace Icap
+} // namespace Adaptation
 
 #endif /* SQUID_ICAPCLIENT_H */
@@ -38,43 +38,43 @@
 #include "ACL.h"
 #include "Store.h"
 #include "Array.h"	// really Vector
-#include "ICAPConfig.h"
-#include "ICAPServiceRep.h"
+#include "adaptation/icap/Config.h"
+#include "adaptation/icap/ServiceRep.h"
 #include "HttpRequest.h"
 #include "HttpReply.h"
 #include "ACLChecklist.h"
 #include "wordlist.h"
 
-ICAPConfig TheICAPConfig;
+Adaptation::Icap::Config Adaptation::Icap::TheConfig;
 
-ICAPConfig::ICAPConfig(): preview_enable(0), preview_size(0),
+Adaptation::Icap::Config::Config(): preview_enable(0), preview_size(0),
         connect_timeout_raw(0), io_timeout_raw(0), reuse_connections(0),
         client_username_header(NULL), client_username_encode(0)
 {
 }
 
-ICAPConfig::~ICAPConfig()
+Adaptation::Icap::Config::~Config()
 {
     // TODO: delete client_username_header?
 }
 
 Adaptation::ServicePointer
-ICAPConfig::createService(const Adaptation::ServiceConfig &cfg)
+Adaptation::Icap::Config::createService(const Adaptation::ServiceConfig &cfg)
 {
-    ICAPServiceRep::Pointer s = new ICAPServiceRep(cfg);
+    Adaptation::Icap::ServiceRep::Pointer s = new Adaptation::Icap::ServiceRep(cfg);
     s->setSelf(s);
     return s.getRaw();
 }
 
-time_t ICAPConfig::connect_timeout(bool bypassable) const
+time_t Adaptation::Icap::Config::connect_timeout(bool bypassable) const
 {
     if (connect_timeout_raw > 0)
         return connect_timeout_raw; // explicitly configured
 
     return bypassable ? ::Config.Timeout.peer_connect : ::Config.Timeout.connect;
 }
 
-time_t ICAPConfig::io_timeout(bool) const
+time_t Adaptation::Icap::Config::io_timeout(bool) const
 {
     if (io_timeout_raw > 0)
         return io_timeout_raw; // explicitly configured
@@ -39,13 +39,17 @@
 #include "event.h"
 #include "AsyncCall.h"
 #include "adaptation/Config.h"
-#include "ICAPServiceRep.h"
+#include "adaptation/icap/ServiceRep.h"
+
+
+namespace Adaptation {
+namespace Icap {
 
 class acl_access;
 
 class ConfigParser;
 
-class ICAPConfig: public Adaptation::Config
+class Config: public Adaptation::Config
 {
 
 public:
@@ -58,19 +62,23 @@ class ICAPConfig: public Adaptation::Config
     char* client_username_header;
     int client_username_encode;
 
-    ICAPConfig();
-    ~ICAPConfig();
+    Config();
+    ~Config();
 
     time_t connect_timeout(bool bypassable) const;
     time_t io_timeout(bool bypassable) const;
 
 private:
-    ICAPConfig(const ICAPConfig &); // not implemented
-    ICAPConfig &operator =(const ICAPConfig &); // not implemented
+    Config(const Config &); // not implemented
+    Config &operator =(const Config &); // not implemented
 
     virtual Adaptation::ServicePointer createService(const Adaptation::ServiceConfig &cfg);
 };
 
-extern ICAPConfig TheICAPConfig;
+extern Config TheConfig;
+
+
+} // namespace Icap
+} // namespace Adaptation
 
 #endif /* SQUID_ICAPCONFIG_H */
@@ -1,4 +1,4 @@
 #include "squid.h"
-#include "ICAPElements.h"
+#include "adaptation/icap/Elements.h"
 
 // TODO: remove this file?
@@ -38,6 +38,10 @@
 
 // ICAP-related things shared by many ICAP classes
 
+
+namespace Adaptation {
+namespace Icap {
+
 namespace ICAP
 {
 using Adaptation::Method;
@@ -55,4 +59,8 @@ using Adaptation::methodStr;
 using Adaptation::vectPointStr;
 }
 
+
+} // namespace Icap
+} // namespace Adaptation
+
 #endif /* SQUID_ICAPCLIENT_H */
@@ -43,15 +43,19 @@
 // as the "cause". ICAP transactions use this class to store virgin
 // and adapted HTTP messages.
 
-class ICAPInOut
+
+namespace Adaptation {
+namespace Icap {
+
+class InOut
 {
 
 public:
     typedef HttpMsg Header;
 
-    ICAPInOut(): header(0), cause(0) {}
+    InOut(): header(0), cause(0) {}
 
-    ~ICAPInOut() {
+    ~InOut() {
         HTTPMSGUNLOCK(cause);
         HTTPMSGUNLOCK(header);
     }
@@ -84,4 +88,8 @@ class ICAPInOut
 
 // TODO: s/Header/Message/i ?
 
+
+} // namespace Icap
+} // namespace Adaptation
+
 #endif /* SQUID_ICAPINOUT_H */
@@ -5,53 +5,53 @@
 #include "squid.h"
 #include "TextException.h"
 #include "HttpMsg.h"
-#include "ICAPLauncher.h"
-#include "ICAPXaction.h"
-#include "ICAPServiceRep.h"
+#include "adaptation/icap/Launcher.h"
+#include "adaptation/icap/Xaction.h"
+#include "adaptation/icap/ServiceRep.h"
 
 
-ICAPLauncher::ICAPLauncher(const char *aTypeName,
+Adaptation::Icap::Launcher::Launcher(const char *aTypeName,
                            Adaptation::Initiator *anInitiator, Adaptation::ServicePointer &aService):
         AsyncJob(aTypeName),
         Adaptation::Initiate(aTypeName, anInitiator, aService),
         theXaction(0), theLaunches(0)
 {
 }
 
-ICAPLauncher::~ICAPLauncher()
+Adaptation::Icap::Launcher::~Launcher()
 {
     assert(!theXaction);
 }
 
-void ICAPLauncher::start()
+void Adaptation::Icap::Launcher::start()
 {
     Adaptation::Initiate::start();
 
     Must(theInitiator);
     launchXaction(false);
 }
 
-void ICAPLauncher::launchXaction(bool final)
+void Adaptation::Icap::Launcher::launchXaction(bool final)
 {
     Must(!theXaction);
     ++theLaunches;
     debugs(93,4, HERE << "launching xaction #" << theLaunches);
-    ICAPXaction *x = createXaction();
+    Adaptation::Icap::Xaction *x = createXaction();
     if (final)
         x->disableRetries();
     theXaction = initiateAdaptation(x);
     Must(theXaction);
 }
 
-void ICAPLauncher::noteAdaptationAnswer(HttpMsg *message)
+void Adaptation::Icap::Launcher::noteAdaptationAnswer(HttpMsg *message)
 {
     sendAnswer(message);
     clearAdaptation(theXaction);
     Must(done());
-    debugs(93,3, HERE << "ICAPLauncher::noteAdaptationAnswer exiting ");
+    debugs(93,3, HERE << "Adaptation::Icap::Launcher::noteAdaptationAnswer exiting ");
 }
 
-void ICAPLauncher::noteInitiatorAborted()
+void Adaptation::Icap::Launcher::noteInitiatorAborted()
 {
 
     announceInitiatorAbort(theXaction); // propogate to the transaction
@@ -60,7 +60,7 @@ void ICAPLauncher::noteInitiatorAborted()
 
 }
 
-void ICAPLauncher::noteAdaptationQueryAbort(bool final)
+void Adaptation::Icap::Launcher::noteAdaptationQueryAbort(bool final)
 {
     clearAdaptation(theXaction);
 
@@ -75,12 +75,12 @@ void ICAPLauncher::noteAdaptationQueryAbort(bool final)
 
 }
 
-bool ICAPLauncher::doneAll() const
+bool Adaptation::Icap::Launcher::doneAll() const
 {
     return (!theInitiator || !theXaction) && Adaptation::Initiate::doneAll();
 }
 
-void ICAPLauncher::swanSong()
+void Adaptation::Icap::Launcher::swanSong()
 {
     if (theInitiator)
         tellQueryAborted(!service().cfg().bypass);
@@ -36,7 +36,7 @@
 
 #include "adaptation/Initiator.h"
 #include "adaptation/Initiate.h"
-#include "ICAP/ICAPServiceRep.h"
+#include "adaptation/icap/ServiceRep.h"
 
 /*
  * The ICAP Launcher starts an ICAP transaction. If the transaction fails
@@ -58,16 +58,20 @@
  * ICAP transactions.
  */
 
-class ICAPXaction;
 
-// Note: ICAPInitiate must be the first parent for cbdata to work. We use
-// a temporary ICAPInitaitorHolder/toCbdata hacks and do not call cbdata
+namespace Adaptation {
+namespace Icap {
+
+class Xaction;
+
+// Note: Initiate must be the first parent for cbdata to work. We use
+// a temporary InitaitorHolder/toCbdata hacks and do not call cbdata
 // operations on the initiator directly.
-class ICAPLauncher: public Adaptation::Initiate, public Adaptation::Initiator
+class Launcher: public Adaptation::Initiate, public Adaptation::Initiator
 {
 public:
-    ICAPLauncher(const char *aTypeName, Adaptation::Initiator *anInitiator, Adaptation::ServicePointer &aService);
-    virtual ~ICAPLauncher();
+    Launcher(const char *aTypeName, Adaptation::Initiator *anInitiator, Adaptation::ServicePointer &aService);
+    virtual ~Launcher();
 
     // Adaptation::Initiate: asynchronous communication with the initiator
     void noteInitiatorAborted();
@@ -83,12 +87,16 @@ class ICAPLauncher: public Adaptation::Initiate, public Adaptation::Initiator
     virtual void swanSong();
 
     // creates the right ICAP transaction using stored configuration params
-    virtual ICAPXaction *createXaction() = 0;
+    virtual Xaction *createXaction() = 0;
 
     void launchXaction(bool final);
 
     Adaptation::Initiate *theXaction; // current ICAP transaction
     int theLaunches; // the number of transaction launches
 };
 
+
+} // namespace Icap
+} // namespace Adaptation
+
 #endif /* SQUID_ICAPLAUNCHER_H */
@@ -0,0 +1,25 @@
+include $(top_srcdir)/src/Common.am
+include $(top_srcdir)/src/TestHeaders.am
+
+noinst_LTLIBRARIES = libicap.la
+
+libicap_la_SOURCES = \
+	Client.cc \
+	Client.h \
+	InOut.h \
+	Config.cc \
+	Config.h \
+	Elements.cc \
+	Elements.h \
+	Options.cc \
+	Options.h \
+	ServiceRep.cc \
+	ServiceRep.h \
+	Launcher.cc \
+	Launcher.h \
+	OptXact.cc \
+	OptXact.h \
+	Xaction.cc \
+	Xaction.h \
+	ModXact.cc \
+	ModXact.h
@@ -8,14 +8,14 @@
 #include "HttpRequest.h"
 #include "HttpReply.h"
 #include "adaptation/Initiator.h"
-#include "ICAPServiceRep.h"
-#include "ICAPLauncher.h"
-#include "ICAPModXact.h"
-#include "ICAPClient.h"
+#include "adaptation/icap/ServiceRep.h"
+#include "adaptation/icap/Launcher.h"
+#include "adaptation/icap/ModXact.h"
+#include "adaptation/icap/Client.h"
 #include "ChunkedCodingParser.h"
 #include "TextException.h"
 #include "AuthUserRequest.h"
-#include "ICAPConfig.h"
+#include "adaptation/icap/Config.h"
 #include "SquidTime.h"
 
 // flow and terminology:
@@ -24,23 +24,23 @@
 
 // TODO: replace gotEncapsulated() with something faster; we call it often
 
-CBDATA_CLASS_INIT(ICAPModXact);
-CBDATA_CLASS_INIT(ICAPModXactLauncher);
+CBDATA_NAMESPACED_CLASS_INIT(Adaptation::Icap, ModXact);
+CBDATA_NAMESPACED_CLASS_INIT(Adaptation::Icap, ModXactLauncher);
 
 static const size_t TheBackupLimit = BodyPipe::MaxCapacity;
 
-extern ICAPConfig TheICAPConfig;
+extern Adaptation::Icap::Config Adaptation::Icap::TheConfig;
 
 
-ICAPModXact::State::State()
+Adaptation::Icap::ModXact::State::State()
 {
     memset(this, 0, sizeof(*this));
 }
 
-ICAPModXact::ICAPModXact(Adaptation::Initiator *anInitiator, HttpMsg *virginHeader,
-                         HttpRequest *virginCause, ICAPServiceRep::Pointer &aService):
-        AsyncJob("ICAPModXact"),
-        ICAPXaction("ICAPModXact", anInitiator, aService),
+Adaptation::Icap::ModXact::ModXact(Adaptation::Initiator *anInitiator, HttpMsg *virginHeader,
+                         HttpRequest *virginCause, Adaptation::Icap::ServiceRep::Pointer &aService):
+        AsyncJob("Adaptation::Icap::ModXact"),
+        Adaptation::Icap::Xaction("Adaptation::Icap::ModXact", anInitiator, aService),
         icapReply(NULL),
         virginConsumed(0),
         bodyParser(NULL),
@@ -53,7 +53,7 @@ ICAPModXact::ICAPModXact(Adaptation::Initiator *anInitiator, HttpMsg *virginHead
 
     // adapted header and body are initialized when we parse them
 
-    // writing and reading ends are handled by ICAPXaction
+    // writing and reading ends are handled by Adaptation::Icap::Xaction
 
     // encoding
     // nothing to do because we are using temporary buffers
@@ -62,13 +62,13 @@ ICAPModXact::ICAPModXact(Adaptation::Initiator *anInitiator, HttpMsg *virginHead
     icapReply = new HttpReply;
     icapReply->protoPrefix = "ICAP/"; // TODO: make an IcapReply class?
 
-    debugs(93,7, "ICAPModXact initialized." << status());
+    debugs(93,7, HERE << "initialized." << status());
 }
 
 // initiator wants us to start
-void ICAPModXact::start()
+void Adaptation::Icap::ModXact::start()
 {
-    ICAPXaction::start();
+    Adaptation::Icap::Xaction::start();
 
     estimateVirginBody(); // before virgin disappears!
 
@@ -82,17 +82,17 @@ void ICAPModXact::start()
         waitForService();
 }
 
-void ICAPModXact::waitForService()
+void Adaptation::Icap::ModXact::waitForService()
 {
     Must(!state.serviceWaiting);
-    debugs(93, 7, "ICAPModXact will wait for the ICAP service" << status());
+    debugs(93, 7, HERE << "will wait for the ICAP service" << status());
     state.serviceWaiting = true;
-    AsyncCall::Pointer call = asyncCall(93,5, "ICAPModXact::noteServiceReady",
-                                        MemFun(this, &ICAPModXact::noteServiceReady));
+    AsyncCall::Pointer call = asyncCall(93,5, "Adaptation::Icap::ModXact::noteServiceReady",
+                                        MemFun(this, &Adaptation::Icap::ModXact::noteServiceReady));
     service().callWhenReady(call);
 }
 
-void ICAPModXact::noteServiceReady()
+void Adaptation::Icap::ModXact::noteServiceReady()
 {
     Must(state.serviceWaiting);
     state.serviceWaiting = false;
@@ -105,7 +105,7 @@ void ICAPModXact::noteServiceReady()
     }
 }
 
-void ICAPModXact::startWriting()
+void Adaptation::Icap::ModXact::startWriting()
 {
     state.writing = State::writingConnect;
 
@@ -116,7 +116,7 @@ void ICAPModXact::startWriting()
 }
 
 // connection with the ICAP service established
-void ICAPModXact::handleCommConnected()
+void Adaptation::Icap::ModXact::handleCommConnected()
 {
     Must(state.writing == State::writingConnect);
 
@@ -126,15 +126,15 @@ void ICAPModXact::handleCommConnected()
     requestBuf.init();
 
     makeRequestHeaders(requestBuf);
-    debugs(93, 9, "ICAPModXact ICAP will write" << status() << ":\n" <<
+    debugs(93, 9, HERE << "will write" << status() << ":\n" <<
            (requestBuf.terminate(), requestBuf.content()));
 
     // write headers
     state.writing = State::writingHeaders;
     scheduleWrite(requestBuf);
 }
 
-void ICAPModXact::handleCommWrote(size_t sz)
+void Adaptation::Icap::ModXact::handleCommWrote(size_t sz)
 {
     debugs(93, 5, HERE << "Wrote " << sz << " bytes");
 
@@ -144,7 +144,7 @@ void ICAPModXact::handleCommWrote(size_t sz)
         handleCommWroteBody();
 }
 
-void ICAPModXact::handleCommWroteHeaders()
+void Adaptation::Icap::ModXact::handleCommWroteHeaders()
 {
     Must(state.writing == State::writingHeaders);
 
@@ -162,7 +162,7 @@ void ICAPModXact::handleCommWroteHeaders()
     writeMore();
 }
 
-void ICAPModXact::writeMore()
+void Adaptation::Icap::ModXact::writeMore()
 {
     debugs(93, 5, HERE << "checking whether to write more" << status());
 
@@ -196,11 +196,11 @@ void ICAPModXact::writeMore()
         return;
 
     default:
-        throw TexcHere("ICAPModXact in bad writing state");
+        throw TexcHere("Adaptation::Icap::ModXact in bad writing state");
     }
 }
 
-void ICAPModXact::writePreviewBody()
+void Adaptation::Icap::ModXact::writePreviewBody()
 {
     debugs(93, 8, HERE << "will write Preview body from " <<
            virgin.body_pipe << status());
@@ -214,7 +214,7 @@ void ICAPModXact::writePreviewBody()
     // change state once preview is written
 
     if (preview.done()) {
-        debugs(93, 7, "ICAPModXact wrote entire Preview body" << status());
+        debugs(93, 7, HERE << "wrote entire Preview body" << status());
 
         if (preview.ieof())
             stopWriting(true);
@@ -223,7 +223,7 @@ void ICAPModXact::writePreviewBody()
     }
 }
 
-void ICAPModXact::writePrimeBody()
+void Adaptation::Icap::ModXact::writePrimeBody()
 {
     Must(state.writing == State::writingPrime);
     Must(virginBodyWriting.active());
@@ -237,7 +237,7 @@ void ICAPModXact::writePrimeBody()
     }
 }
 
-void ICAPModXact::writeSomeBody(const char *label, size_t size)
+void Adaptation::Icap::ModXact::writeSomeBody(const char *label, size_t size)
 {
     Must(!writer && state.writing < state.writingAlmostDone);
     Must(virgin.body_pipe != NULL);
@@ -262,7 +262,7 @@ void ICAPModXact::writeSomeBody(const char *label, size_t size)
         virginBodyWriting.progress(chunkSize);
         virginConsume();
     } else {
-        debugs(93, 7, "ICAPModXact has no writable " << label << " content");
+        debugs(93, 7, HERE << "has no writable " << label << " content");
     }
 
     const bool wroteEof = virginBodyEndReached(virginBodyWriting);
@@ -287,25 +287,25 @@ void ICAPModXact::writeSomeBody(const char *label, size_t size)
     }
 }
 
-void ICAPModXact::addLastRequestChunk(MemBuf &buf)
+void Adaptation::Icap::ModXact::addLastRequestChunk(MemBuf &buf)
 {
     const bool ieof = state.writing == State::writingPreview && preview.ieof();
     openChunk(buf, 0, ieof);
     closeChunk(buf);
 }
 
-void ICAPModXact::openChunk(MemBuf &buf, size_t chunkSize, bool ieof)
+void Adaptation::Icap::ModXact::openChunk(MemBuf &buf, size_t chunkSize, bool ieof)
 {
     buf.Printf((ieof ? "%x; ieof\r\n" : "%x\r\n"), (int) chunkSize);
 }
 
-void ICAPModXact::closeChunk(MemBuf &buf)
+void Adaptation::Icap::ModXact::closeChunk(MemBuf &buf)
 {
     buf.append(ICAP::crlf, 2); // chunk-terminating CRLF
 }
 
 // did the activity reached the end of the virgin body?
-bool ICAPModXact::virginBodyEndReached(const VirginBodyAct &act) const
+bool Adaptation::Icap::ModXact::virginBodyEndReached(const Adaptation::Icap::VirginBodyAct &act) const
 {
     return
         !act.active() || // did all (assuming it was originally planned)
@@ -314,7 +314,7 @@ bool ICAPModXact::virginBodyEndReached(const VirginBodyAct &act) const
 
 // the size of buffered virgin body data available for the specified activity
 // if this size is zero, we may be done or may be waiting for more data
-size_t ICAPModXact::virginContentSize(const VirginBodyAct &act) const
+size_t Adaptation::Icap::ModXact::virginContentSize(const Adaptation::Icap::VirginBodyAct &act) const
 {
     Must(act.active());
     // asbolute start of unprocessed data
@@ -326,17 +326,17 @@ size_t ICAPModXact::virginContentSize(const VirginBodyAct &act) const
 }
 
 // pointer to buffered virgin body data available for the specified activity
-const char *ICAPModXact::virginContentData(const VirginBodyAct &act) const
+const char *Adaptation::Icap::ModXact::virginContentData(const Adaptation::Icap::VirginBodyAct &act) const
 {
     Must(act.active());
     const uint64_t start = act.offset();
     Must(virginConsumed <= start);
     return virgin.body_pipe->buf().content() + static_cast<size_t>(start-virginConsumed);
 }
 
-void ICAPModXact::virginConsume()
+void Adaptation::Icap::ModXact::virginConsume()
 {
-    debugs(93, 9, "consumption guards: " << !virgin.body_pipe << isRetriable);
+    debugs(93, 9, HERE << "consumption guards: " << !virgin.body_pipe << isRetriable);
 
     if (!virgin.body_pipe)
         return; // nothing to consume
@@ -385,15 +385,15 @@ void ICAPModXact::virginConsume()
     }
 }
 
-void ICAPModXact::handleCommWroteBody()
+void Adaptation::Icap::ModXact::handleCommWroteBody()
 {
     writeMore();
 }
 
 // Called when we do not expect to call comm_write anymore.
 // We may have a pending write though.
 // If stopping nicely, we will just wait for that pending write, if any.
-void ICAPModXact::stopWriting(bool nicely)
+void Adaptation::Icap::ModXact::stopWriting(bool nicely)
 {
     if (state.writing == State::writingReallyDone)
         return;
@@ -425,24 +425,24 @@ void ICAPModXact::stopWriting(bool nicely)
     checkConsuming();
 }
 
-void ICAPModXact::stopBackup()
+void Adaptation::Icap::ModXact::stopBackup()
 {
     if (!virginBodySending.active())
         return;
 
-    debugs(93, 7, "ICAPModXact will no longer backup" << status());
+    debugs(93, 7, HERE << "will no longer backup" << status());
     virginBodySending.disable();
     virginConsume();
 }
 
-bool ICAPModXact::doneAll() const
+bool Adaptation::Icap::ModXact::doneAll() const
 {
-    return ICAPXaction::doneAll() && !state.serviceWaiting &&
+    return Adaptation::Icap::Xaction::doneAll() && !state.serviceWaiting &&
            doneSending() &&
            doneReading() && state.doneWriting();
 }
 
-void ICAPModXact::startReading()
+void Adaptation::Icap::ModXact::startReading()
 {
     Must(connection >= 0);
     Must(!reader);
@@ -453,7 +453,7 @@ void ICAPModXact::startReading()
     readMore();
 }
 
-void ICAPModXact::readMore()
+void Adaptation::Icap::ModXact::readMore()
 {
     if (reader != NULL || doneReading()) {
         debugs(93,3,HERE << "returning from readMore because reader or doneReading()");
@@ -474,14 +474,14 @@ void ICAPModXact::readMore()
 }
 
 // comm module read a portion of the ICAP response for us
-void ICAPModXact::handleCommRead(size_t)
+void Adaptation::Icap::ModXact::handleCommRead(size_t)
 {
     Must(!state.doneParsing());
     parseMore();
     readMore();
 }
 
-void ICAPModXact::echoMore()
+void Adaptation::Icap::ModXact::echoMore()
 {
     Must(state.sending == State::sendingVirgin);
     Must(adapted.body_pipe != NULL);
@@ -503,29 +503,29 @@ void ICAPModXact::echoMore()
     }
 
     if (virginBodyEndReached(virginBodySending)) {
-        debugs(93, 5, "ICAPModXact echoed all" << status());
+        debugs(93, 5, HERE << "echoed all" << status());
         stopSending(true);
     } else {
-        debugs(93, 5, "ICAPModXact has " <<
+        debugs(93, 5, HERE << "has " <<
                virgin.body_pipe->buf().contentSize() << " bytes " <<
                "and expects more to echo" << status());
         // TODO: timeout if virgin or adapted pipes are broken
     }
 }
 
-bool ICAPModXact::doneSending() const
+bool Adaptation::Icap::ModXact::doneSending() const
 {
     return state.sending == State::sendingDone;
 }
 
 // stop (or do not start) sending adapted message body
-void ICAPModXact::stopSending(bool nicely)
+void Adaptation::Icap::ModXact::stopSending(bool nicely)
 {
     if (doneSending())
         return;
 
     if (state.sending != State::sendingUndecided) {
-        debugs(93, 7, "ICAPModXact will no longer send" << status());
+        debugs(93, 7, HERE << "will no longer send" << status());
         if (adapted.body_pipe != NULL) {
             virginBodySending.disable();
             // we may leave debts if we were echoing and the virgin
@@ -534,7 +534,7 @@ void ICAPModXact::stopSending(bool nicely)
             stopProducingFor(adapted.body_pipe, nicely && !leftDebts);
         }
     } else {
-        debugs(93, 7, "ICAPModXact will not start sending" << status());
+        debugs(93, 7, HERE << "will not start sending" << status());
         Must(!adapted.body_pipe);
     }
 
@@ -543,7 +543,7 @@ void ICAPModXact::stopSending(bool nicely)
 }
 
 // should be called after certain state.writing or state.sending changes
-void ICAPModXact::checkConsuming()
+void Adaptation::Icap::ModXact::checkConsuming()
 {
     // quit if we already stopped or are still using the pipe
     if (!virgin.body_pipe || !state.doneConsumingVirgin())
@@ -553,7 +553,7 @@ void ICAPModXact::checkConsuming()
     stopConsumingFrom(virgin.body_pipe);
 }
 
-void ICAPModXact::parseMore()
+void Adaptation::Icap::ModXact::parseMore()
 {
     debugs(93, 5, HERE << "have " << readBuf.contentSize() << " bytes to parse" <<
            status());
@@ -566,23 +566,23 @@ void ICAPModXact::parseMore()
         parseBody();
 }
 
-void ICAPModXact::callException(const std::exception &e)
+void Adaptation::Icap::ModXact::callException(const std::exception &e)
 {
     if (!canStartBypass || isRetriable) {
-        ICAPXaction::callException(e);
+        Adaptation::Icap::Xaction::callException(e);
         return;
     }
 
     try {
-        debugs(93, 3, "bypassing ICAPModXact::" << inCall << " exception: " <<
-               e.what() << ' ' << status());
+        debugs(93, 3, HERE << "bypassing " << inCall << " exception: " <<
+            e.what() << ' ' << status());
         bypassFailure();
     } catch (const std::exception &bypassE) {
-        ICAPXaction::callException(bypassE);
+        Adaptation::Icap::Xaction::callException(bypassE);
     }
 }
 
-void ICAPModXact::bypassFailure()
+void Adaptation::Icap::ModXact::bypassFailure()
 {
     disableBypass("already started to bypass");
 
@@ -601,11 +601,11 @@ void ICAPModXact::bypassFailure()
         reuseConnection = false; // be conservative
         cancelRead(); // may not work; and we cannot stop connecting either
         if (!doneWithIo())
-            debugs(93, 7, "Warning: bypass failed to stop I/O" << status());
+            debugs(93, 7, HERE << "Warning: bypass failed to stop I/O" << status());
     }
 }
 
-void ICAPModXact::disableBypass(const char *reason)
+void Adaptation::Icap::ModXact::disableBypass(const char *reason)
 {
     if (canStartBypass) {
         debugs(93,7, HERE << "will never start bypass because " << reason);
@@ -616,7 +616,7 @@ void ICAPModXact::disableBypass(const char *reason)
 
 
 // note that allocation for echoing is done in handle204NoContent()
-void ICAPModXact::maybeAllocateHttpMsg()
+void Adaptation::Icap::ModXact::maybeAllocateHttpMsg()
 {
     if (adapted.header) // already allocated
         return;
@@ -629,7 +629,7 @@ void ICAPModXact::maybeAllocateHttpMsg()
         throw TexcHere("Neither res-hdr nor req-hdr in maybeAllocateHttpMsg()");
 }
 
-void ICAPModXact::parseHeaders()
+void Adaptation::Icap::ModXact::parseHeaders()
 {
     Must(state.parsingHeaders());
 
@@ -652,7 +652,7 @@ void ICAPModXact::parseHeaders()
 }
 
 // called after parsing all headers or when bypassing an exception
-void ICAPModXact::startSending()
+void Adaptation::Icap::ModXact::startSending()
 {
     disableBypass("sent headers");
     sendAnswer(adapted.header);
@@ -661,7 +661,7 @@ void ICAPModXact::startSending()
         echoMore();
 }
 
-void ICAPModXact::parseIcapHead()
+void Adaptation::Icap::ModXact::parseIcapHead()
 {
     Must(state.sending == State::sendingUndecided);
 
@@ -706,7 +706,7 @@ void ICAPModXact::parseIcapHead()
         stopWriting(true);
 }
 
-bool ICAPModXact::validate200Ok()
+bool Adaptation::Icap::ModXact::validate200Ok()
 {
     if (ICAP::methodRespmod == service().cfg().method) {
         if (!gotEncapsulated("res-hdr"))
@@ -725,7 +725,7 @@ bool ICAPModXact::validate200Ok()
     return false;
 }
 
-void ICAPModXact::handle100Continue()
+void Adaptation::Icap::ModXact::handle100Continue()
 {
     Must(state.writing == State::writingPaused);
     // server must not respond before the end of preview: we may send ieof
@@ -743,15 +743,15 @@ void ICAPModXact::handle100Continue()
     writeMore();
 }
 
-void ICAPModXact::handle200Ok()
+void Adaptation::Icap::ModXact::handle200Ok()
 {
     state.parsing = State::psHttpHeader;
     state.sending = State::sendingAdapted;
     stopBackup();
     checkConsuming();
 }
 
-void ICAPModXact::handle204NoContent()
+void Adaptation::Icap::ModXact::handle204NoContent()
 {
     stopParsing();
     prepEchoing();
@@ -760,7 +760,7 @@ void ICAPModXact::handle204NoContent()
 // Called when we receive a 204 No Content response and
 // when we are trying to bypass a service failure.
 // We actually start sending (echoig or not) in startSending.
-void ICAPModXact::prepEchoing()
+void Adaptation::Icap::ModXact::prepEchoing()
 {
     disableBypass("preparing to echo content");
 
@@ -770,7 +770,7 @@ void ICAPModXact::prepEchoing()
     // Instead, we simply write the HTTP message and "clone" it by parsing.
 
     HttpMsg *oldHead = virgin.header;
-    debugs(93, 7, "ICAPModXact cloning virgin message " << oldHead);
+    debugs(93, 7, HERE << "cloning virgin message " << oldHead);
 
     MemBuf httpBuf;
 
@@ -802,7 +802,7 @@ void ICAPModXact::prepEchoing()
 
     httpBuf.clean();
 
-    debugs(93, 7, "ICAPModXact cloned virgin message " << oldHead << " to " <<
+    debugs(93, 7, HERE << "cloned virgin message " << oldHead << " to " <<
            newHead);
 
     // setup adapted body pipe if needed
@@ -827,7 +827,7 @@ void ICAPModXact::prepEchoing()
     }
 }
 
-void ICAPModXact::handleUnknownScode()
+void Adaptation::Icap::ModXact::handleUnknownScode()
 {
     stopParsing();
     stopBackup();
@@ -837,7 +837,7 @@ void ICAPModXact::handleUnknownScode()
     throw TexcHere("Unsupported ICAP status code");
 }
 
-void ICAPModXact::parseHttpHead()
+void Adaptation::Icap::ModXact::parseHttpHead()
 {
     if (gotEncapsulated("res-hdr") || gotEncapsulated("req-hdr")) {
         maybeAllocateHttpMsg();
@@ -863,7 +863,7 @@ void ICAPModXact::parseHttpHead()
 }
 
 // parses both HTTP and ICAP headers
-bool ICAPModXact::parseHead(HttpMsg *head)
+bool Adaptation::Icap::ModXact::parseHead(HttpMsg *head)
 {
     Must(head);
     debugs(93, 5, HERE << "have " << readBuf.contentSize() << " head bytes to parse" <<
@@ -884,7 +884,7 @@ bool ICAPModXact::parseHead(HttpMsg *head)
     return true;
 }
 
-void ICAPModXact::decideOnParsingBody()
+void Adaptation::Icap::ModXact::decideOnParsingBody()
 {
     if (gotEncapsulated("res-body") || gotEncapsulated("req-body")) {
         debugs(93, 5, HERE << "expecting a body");
@@ -899,7 +899,7 @@ void ICAPModXact::decideOnParsingBody()
     }
 }
 
-void ICAPModXact::parseBody()
+void Adaptation::Icap::ModXact::parseBody()
 {
     Must(state.parsing == State::psBody);
     Must(bodyParser);
@@ -940,12 +940,12 @@ void ICAPModXact::parseBody()
     }
 }
 
-void ICAPModXact::stopParsing()
+void Adaptation::Icap::ModXact::stopParsing()
 {
     if (state.parsing == State::psDone)
         return;
 
-    debugs(93, 7, "ICAPModXact will no longer parse" << status());
+    debugs(93, 7, HERE << "will no longer parse" << status());
 
     delete bodyParser;
 
@@ -955,7 +955,7 @@ void ICAPModXact::stopParsing()
 }
 
 // HTTP side added virgin body data
-void ICAPModXact::noteMoreBodyDataAvailable(BodyPipe::Pointer)
+void Adaptation::Icap::ModXact::noteMoreBodyDataAvailable(BodyPipe::Pointer)
 {
     writeMore();
 
@@ -964,7 +964,7 @@ void ICAPModXact::noteMoreBodyDataAvailable(BodyPipe::Pointer)
 }
 
 // HTTP side sent us all virgin info
-void ICAPModXact::noteBodyProductionEnded(BodyPipe::Pointer)
+void Adaptation::Icap::ModXact::noteBodyProductionEnded(BodyPipe::Pointer)
 {
     Must(virgin.body_pipe->productionEnded());
 
@@ -977,7 +977,7 @@ void ICAPModXact::noteBodyProductionEnded(BodyPipe::Pointer)
 
 // body producer aborted, but the initiator may still want to know
 // the answer, even though the HTTP message has been truncated
-void ICAPModXact::noteBodyProducerAborted(BodyPipe::Pointer)
+void Adaptation::Icap::ModXact::noteBodyProducerAborted(BodyPipe::Pointer)
 {
     Must(virgin.body_pipe->productionEnded());
 
@@ -990,7 +990,7 @@ void ICAPModXact::noteBodyProducerAborted(BodyPipe::Pointer)
 
 // adapted body consumer wants more adapted data and
 // possibly freed some buffer space
-void ICAPModXact::noteMoreBodySpaceAvailable(BodyPipe::Pointer)
+void Adaptation::Icap::ModXact::noteMoreBodySpaceAvailable(BodyPipe::Pointer)
 {
     if (state.sending == State::sendingVirgin)
         echoMore();
@@ -1001,13 +1001,13 @@ void ICAPModXact::noteMoreBodySpaceAvailable(BodyPipe::Pointer)
 }
 
 // adapted body consumer aborted
-void ICAPModXact::noteBodyConsumerAborted(BodyPipe::Pointer)
+void Adaptation::Icap::ModXact::noteBodyConsumerAborted(BodyPipe::Pointer)
 {
     mustStop("adapted body consumer aborted");
 }
 
 // internal cleanup
-void ICAPModXact::swanSong()
+void Adaptation::Icap::ModXact::swanSong()
 {
     debugs(93, 5, HERE << "swan sings" << status());
 
@@ -1019,10 +1019,10 @@ void ICAPModXact::swanSong()
         icapReply = NULL;
     }
 
-    ICAPXaction::swanSong();
+    Adaptation::Icap::Xaction::swanSong();
 }
 
-void ICAPModXact::makeRequestHeaders(MemBuf &buf)
+void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
 {
     char ntoabuf[MAX_IPSTRLEN];
     /*
@@ -1033,7 +1033,7 @@ void ICAPModXact::makeRequestHeaders(MemBuf &buf)
     buf.Printf("Host: " SQUIDSTRINGPH ":%d\r\n", SQUIDSTRINGPRINT(s.host), s.port);
     buf.Printf("Date: %s\r\n", mkrfc1123(squid_curtime));
 
-    if (!TheICAPConfig.reuse_connections)
+    if (!TheConfig.reuse_connections)
         buf.Printf("Connection: close\r\n");
 
     // we must forward "Proxy-Authenticate" and "Proxy-Authorization"
@@ -1102,11 +1102,11 @@ void ICAPModXact::makeRequestHeaders(MemBuf &buf)
             virginBodySending.plan();
     }
 
-    if (TheICAPConfig.send_client_ip && request)
+    if (TheConfig.send_client_ip && request)
         if (!request->client_addr.IsAnyAddr() && !request->client_addr.IsNoAddr())
             buf.Printf("X-Client-IP: %s\r\n", request->client_addr.NtoA(ntoabuf,MAX_IPSTRLEN));
 
-    if (TheICAPConfig.send_client_username && request)
+    if (TheConfig.send_client_username && request)
         makeUsernameHeader(request, buf);
 
     // fprintf(stderr, "%s\n", buf.content());
@@ -1119,19 +1119,19 @@ void ICAPModXact::makeRequestHeaders(MemBuf &buf)
     httpBuf.clean();
 }
 
-void ICAPModXact::makeUsernameHeader(const HttpRequest *request, MemBuf &buf)
+void Adaptation::Icap::ModXact::makeUsernameHeader(const HttpRequest *request, MemBuf &buf)
 {
     if (const AuthUserRequest *auth = request->auth_user_request) {
         if (char const *name = auth->username()) {
-            const char *value = TheICAPConfig.client_username_encode ?
+            const char *value = TheConfig.client_username_encode ?
                                 base64_encode(name) : name;
-            buf.Printf("%s: %s\r\n", TheICAPConfig.client_username_header,
+            buf.Printf("%s: %s\r\n", TheConfig.client_username_header,
                        value);
         }
     }
 }
 
-void ICAPModXact::encapsulateHead(MemBuf &icapBuf, const char *section, MemBuf &httpBuf, const HttpMsg *head)
+void Adaptation::Icap::ModXact::encapsulateHead(MemBuf &icapBuf, const char *section, MemBuf &httpBuf, const HttpMsg *head)
 {
     // update ICAP header
     icapBuf.Printf("%s=%d, ", section, (int) httpBuf.contentSize());
@@ -1170,7 +1170,7 @@ void ICAPModXact::encapsulateHead(MemBuf &icapBuf, const char *section, MemBuf &
     delete headClone;
 }
 
-void ICAPModXact::packHead(MemBuf &httpBuf, const HttpMsg *head)
+void Adaptation::Icap::ModXact::packHead(MemBuf &httpBuf, const HttpMsg *head)
 {
     Packer p;
     packerToMemInit(&p, &httpBuf);
@@ -1179,9 +1179,9 @@ void ICAPModXact::packHead(MemBuf &httpBuf, const HttpMsg *head)
 }
 
 // decides whether to offer a preview and calculates its size
-void ICAPModXact::decideOnPreview()
+void Adaptation::Icap::ModXact::decideOnPreview()
 {
-    if (!TheICAPConfig.preview_enable) {
+    if (!TheConfig.preview_enable) {
         debugs(93, 5, HERE << "preview disabled by squid.conf");
         return;
     }
@@ -1192,7 +1192,7 @@ void ICAPModXact::decideOnPreview()
     const String urlPath = request ? request->urlpath : String();
     size_t wantedSize;
     if (!service().wantsPreview(urlPath, wantedSize)) {
-        debugs(93, 5, "ICAPModXact should not offer preview for " << urlPath);
+        debugs(93, 5, HERE << "should not offer preview for " << urlPath);
         return;
     }
 
@@ -1209,15 +1209,15 @@ void ICAPModXact::decideOnPreview()
         if (virginBody.knownSize())
             ad = XMIN(static_cast<uint64_t>(ad), virginBody.size()); // not more than we have
 
-    debugs(93, 5, "ICAPModXact should offer " << ad << "-byte preview " <<
+    debugs(93, 5, HERE << "should offer " << ad << "-byte preview " <<
            "(service wanted " << wantedSize << ")");
 
     preview.enable(ad);
     Must(preview.enabled());
 }
 
 // decides whether to allow 204 responses
-bool ICAPModXact::shouldAllow204()
+bool Adaptation::Icap::ModXact::shouldAllow204()
 {
     if (!service().allows204())
         return false;
@@ -1226,7 +1226,7 @@ bool ICAPModXact::shouldAllow204()
 }
 
 // used by shouldAllow204 and decideOnRetries
-bool ICAPModXact::canBackupEverything() const
+bool Adaptation::Icap::ModXact::canBackupEverything() const
 {
     if (!virginBody.expected())
         return true; // no body means no problems with backup
@@ -1243,7 +1243,7 @@ bool ICAPModXact::canBackupEverything() const
 
 // Decide whether this transaction can be retried if pconn fails
 // Must be called after decideOnPreview and before openConnection()
-void ICAPModXact::decideOnRetries()
+void Adaptation::Icap::ModXact::decideOnRetries()
 {
     if (!isRetriable)
         return; // no, already decided
@@ -1263,7 +1263,7 @@ void ICAPModXact::decideOnRetries()
 // structures were initialized. This is not the case when there is no body
 // or the body is known to be empty, because the virgin message will lack a
 // body_pipe. So we handle preview of null-body and zero-size bodies here.
-void ICAPModXact::finishNullOrEmptyBodyPreview(MemBuf &buf)
+void Adaptation::Icap::ModXact::finishNullOrEmptyBodyPreview(MemBuf &buf)
 {
     Must(!virginBodyWriting.active()); // one reason we handle it here
     Must(!virgin.body_pipe);          // another reason we handle it here
@@ -1277,9 +1277,9 @@ void ICAPModXact::finishNullOrEmptyBodyPreview(MemBuf &buf)
     Must(preview.ieof());
 }
 
-void ICAPModXact::fillPendingStatus(MemBuf &buf) const
+void Adaptation::Icap::ModXact::fillPendingStatus(MemBuf &buf) const
 {
-    ICAPXaction::fillPendingStatus(buf);
+    Adaptation::Icap::Xaction::fillPendingStatus(buf);
 
     if (state.serviceWaiting)
         buf.append("U", 1);
@@ -1311,9 +1311,9 @@ void ICAPModXact::fillPendingStatus(MemBuf &buf) const
         buf.append("Y", 1);
 }
 
-void ICAPModXact::fillDoneStatus(MemBuf &buf) const
+void Adaptation::Icap::ModXact::fillDoneStatus(MemBuf &buf) const
 {
-    ICAPXaction::fillDoneStatus(buf);
+    Adaptation::Icap::Xaction::fillDoneStatus(buf);
 
     if (!virgin.body_pipe)
         buf.append("R", 1);
@@ -1336,7 +1336,7 @@ void ICAPModXact::fillDoneStatus(MemBuf &buf) const
         buf.append("S", 1);
 }
 
-bool ICAPModXact::gotEncapsulated(const char *section) const
+bool Adaptation::Icap::ModXact::gotEncapsulated(const char *section) const
 {
     return icapReply->header.getByNameListMember("Encapsulated",
             section, ',').size() > 0;
@@ -1345,7 +1345,7 @@ bool ICAPModXact::gotEncapsulated(const char *section) const
 // calculate whether there is a virgin HTTP body and
 // whether its expected size is known
 // TODO: rename because we do not just estimate
-void ICAPModXact::estimateVirginBody()
+void Adaptation::Icap::ModXact::estimateVirginBody()
 {
     // note: lack of size info may disable previews and 204s
 
@@ -1366,7 +1366,7 @@ void ICAPModXact::estimateVirginBody()
     // expectingBody returns true for zero-sized bodies, but we will not
     // get a pipe for that body, so we treat the message as bodyless
     if (method != METHOD_NONE && msg->expectingBody(method, size) && size) {
-        debugs(93, 6, "ICAPModXact expects virgin body from " <<
+        debugs(93, 6, HERE << "expects virgin body from " <<
                virgin.body_pipe << "; size: " << size);
 
         virginBody.expect(size);
@@ -1380,13 +1380,13 @@ void ICAPModXact::estimateVirginBody()
         // make sure TheBackupLimit is in-sync with the buffer size
         Must(TheBackupLimit <= static_cast<size_t>(msg->body_pipe->buf().max_capacity));
     } else {
-        debugs(93, 6, "ICAPModXact does not expect virgin body");
+        debugs(93, 6, HERE << "does not expect virgin body");
         Must(msg->body_pipe == NULL);
         checkConsuming();
     }
 }
 
-void ICAPModXact::makeAdaptedBodyPipe(const char *what)
+void Adaptation::Icap::ModXact::makeAdaptedBodyPipe(const char *what)
 {
     Must(!adapted.body_pipe);
     Must(!adapted.header->body_pipe);
@@ -1397,69 +1397,69 @@ void ICAPModXact::makeAdaptedBodyPipe(const char *what)
 }
 
 
-// TODO: Move SizedEstimate, MemBufBackup, and ICAPPreview elsewhere
+// TODO: Move SizedEstimate and Preview elsewhere
 
-SizedEstimate::SizedEstimate()
+Adaptation::Icap::SizedEstimate::SizedEstimate()
         : theData(dtUnexpected)
 {}
 
-void SizedEstimate::expect(int64_t aSize)
+void Adaptation::Icap::SizedEstimate::expect(int64_t aSize)
 {
     theData = (aSize >= 0) ? aSize : (int64_t)dtUnknown;
 }
 
-bool SizedEstimate::expected() const
+bool Adaptation::Icap::SizedEstimate::expected() const
 {
     return theData != dtUnexpected;
 }
 
-bool SizedEstimate::knownSize() const
+bool Adaptation::Icap::SizedEstimate::knownSize() const
 {
     Must(expected());
     return theData != dtUnknown;
 }
 
-uint64_t SizedEstimate::size() const
+uint64_t Adaptation::Icap::SizedEstimate::size() const
 {
     Must(knownSize());
     return static_cast<uint64_t>(theData);
 }
 
 
 
-VirginBodyAct::VirginBodyAct(): theStart(0), theState(stUndecided)
+Adaptation::Icap::VirginBodyAct::VirginBodyAct(): theStart(0), theState(stUndecided)
 {}
 
-void VirginBodyAct::plan()
+void Adaptation::Icap::VirginBodyAct::plan()
 {
     Must(!disabled());
     Must(!theStart); // not started
     theState = stActive;
 }
 
-void VirginBodyAct::disable()
+void Adaptation::Icap::VirginBodyAct::disable()
 {
     theState = stDisabled;
 }
 
-void VirginBodyAct::progress(size_t size)
+void Adaptation::Icap::VirginBodyAct::progress(size_t size)
 {
     Must(active());
     Must(size >= 0);
     theStart += static_cast<int64_t>(size);
 }
 
-uint64_t VirginBodyAct::offset() const
+uint64_t Adaptation::Icap::VirginBodyAct::offset() const
 {
     Must(active());
     return static_cast<uint64_t>(theStart);
 }
 
 
-ICAPPreview::ICAPPreview(): theWritten(0), theAd(0), theState(stDisabled)
+Adaptation::Icap::Preview::Preview(): theWritten(0), theAd(0), theState(stDisabled)
 {}
 
-void ICAPPreview::enable(size_t anAd)
+void Adaptation::Icap::Preview::enable(size_t anAd)
 {
     // TODO: check for anAd not exceeding preview size limit
     Must(anAd >= 0);
@@ -1468,36 +1468,36 @@ void ICAPPreview::enable(size_t anAd)
     theState = stWriting;
 }
 
-bool ICAPPreview::enabled() const
+bool Adaptation::Icap::Preview::enabled() const
 {
     return theState != stDisabled;
 }
 
-size_t ICAPPreview::ad() const
+size_t Adaptation::Icap::Preview::ad() const
 {
     Must(enabled());
     return theAd;
 }
 
-bool ICAPPreview::done() const
+bool Adaptation::Icap::Preview::done() const
 {
     Must(enabled());
     return theState >= stIeof;
 }
 
-bool ICAPPreview::ieof() const
+bool Adaptation::Icap::Preview::ieof() const
 {
     Must(enabled());
     return theState == stIeof;
 }
 
-size_t ICAPPreview::debt() const
+size_t Adaptation::Icap::Preview::debt() const
 {
     Must(enabled());
     return done() ? 0 : (theAd - theWritten);
 }
 
-void ICAPPreview::wrote(size_t size, bool wroteEof)
+void Adaptation::Icap::Preview::wrote(size_t size, bool wroteEof)
 {
     Must(enabled());
 
@@ -1512,7 +1512,7 @@ void ICAPPreview::wrote(size_t size, bool wroteEof)
             theState = stDone;
 }
 
-bool ICAPModXact::fillVirginHttpHeader(MemBuf &mb) const
+bool Adaptation::Icap::ModXact::fillVirginHttpHeader(MemBuf &mb) const
 {
     if (virgin.header == NULL)
         return false;
@@ -1523,20 +1523,20 @@ bool ICAPModXact::fillVirginHttpHeader(MemBuf &mb) const
 }
 
 
-/* ICAPModXactLauncher */
+/* Adaptation::Icap::ModXactLauncher */
 
-ICAPModXactLauncher::ICAPModXactLauncher(Adaptation::Initiator *anInitiator, HttpMsg *virginHeader, HttpRequest *virginCause, Adaptation::ServicePointer aService):
-        AsyncJob("ICAPModXactLauncher"),
-        ICAPLauncher("ICAPModXactLauncher", anInitiator, aService)
+Adaptation::Icap::ModXactLauncher::ModXactLauncher(Adaptation::Initiator *anInitiator, HttpMsg *virginHeader, HttpRequest *virginCause, Adaptation::ServicePointer aService):
+        AsyncJob("Adaptation::Icap::ModXactLauncher"),
+        Adaptation::Icap::Launcher("Adaptation::Icap::ModXactLauncher", anInitiator, aService)
 {
     virgin.setHeader(virginHeader);
     virgin.setCause(virginCause);
 }
 
-ICAPXaction *ICAPModXactLauncher::createXaction()
+Adaptation::Icap::Xaction *Adaptation::Icap::ModXactLauncher::createXaction()
 {
-    ICAPServiceRep::Pointer s =
-        dynamic_cast<ICAPServiceRep*>(theService.getRaw());
+    Adaptation::Icap::ServiceRep::Pointer s =
+        dynamic_cast<Adaptation::Icap::ServiceRep*>(theService.getRaw());
     Must(s != NULL);
-    return new ICAPModXact(this, virgin.header, virgin.cause, s);
+    return new Adaptation::Icap::ModXact(this, virgin.header, virgin.cause, s);
 }
@@ -35,9 +35,9 @@
 #define SQUID_ICAPMODXACT_H
 
 #include "BodyPipe.h"
-#include "ICAPXaction.h"
-#include "ICAPInOut.h"
-#include "ICAPLauncher.h"
+#include "adaptation/icap/Xaction.h"
+#include "adaptation/icap/InOut.h"
+#include "adaptation/icap/Launcher.h"
 
 /*
  * ICAPModXact implements ICAP REQMOD and RESPMOD transaction using
@@ -52,6 +52,9 @@
 
 class ChunkedCodingParser;
 
+namespace Adaptation {
+namespace Icap {
+
 // estimated future presence and size of something (e.g., HTTP body)
 
 class SizedEstimate
@@ -104,11 +107,11 @@ class VirginBodyAct
 
 // maintains preview-related sizes
 
-class ICAPPreview
+class Preview
 {
 
 public:
-    ICAPPreview();            // disabled
+    Preview();            // disabled
     void enable(size_t anAd); // enabled with advertised size
     bool enabled() const;
 
@@ -127,11 +130,11 @@ class ICAPPreview
     enum State { stDisabled, stWriting, stIeof, stDone } theState;
 };
 
-class ICAPModXact: public ICAPXaction, public BodyProducer, public BodyConsumer
+class ModXact: public Xaction, public BodyProducer, public BodyConsumer
 {
 
 public:
-    ICAPModXact(Adaptation::Initiator *anInitiator, HttpMsg *virginHeader, HttpRequest *virginCause, ICAPServiceRep::Pointer &s);
+    ModXact(Adaptation::Initiator *anInitiator, HttpMsg *virginHeader, HttpRequest *virginCause, ServiceRep::Pointer &s);
 
     // BodyProducer methods
     virtual void noteMoreBodySpaceAvailable(BodyPipe::Pointer);
@@ -153,8 +156,8 @@ class ICAPModXact: public ICAPXaction, public BodyProducer, public BodyConsumer
     void noteServiceReady();
 
 public:
-    ICAPInOut virgin;
-    ICAPInOut adapted;
+    InOut virgin;
+    InOut adapted;
 
 protected:
     // bypasses exceptions if needed and possible
@@ -253,7 +256,7 @@ class ICAPModXact: public ICAPXaction, public BodyProducer, public BodyConsumer
     VirginBodyAct virginBodyWriting; // virgin body writing state
     VirginBodyAct virginBodySending;  // virgin body sending state
     uint64_t virginConsumed;        // virgin data consumed so far
-    ICAPPreview preview; // use for creating (writing) the preview
+    Preview preview; // use for creating (writing) the preview
 
     ChunkedCodingParser *bodyParser; // ICAP response body parser
 
@@ -302,23 +305,27 @@ class ICAPModXact: public ICAPXaction, public BodyProducer, public BodyConsumer
                      } sending;
     } state;
 
-    CBDATA_CLASS2(ICAPModXact);
+    CBDATA_CLASS2(ModXact);
 };
 
-// An ICAPLauncher that stores ICAPModXact construction info and
-// creates ICAPModXact when needed
-class ICAPModXactLauncher: public ICAPLauncher
+// An Launcher that stores ModXact construction info and
+// creates ModXact when needed
+class ModXactLauncher: public Launcher
 {
 public:
-    ICAPModXactLauncher(Adaptation::Initiator *anInitiator, HttpMsg *virginHeader, HttpRequest *virginCause, Adaptation::ServicePointer s);
+    ModXactLauncher(Adaptation::Initiator *anInitiator, HttpMsg *virginHeader, HttpRequest *virginCause, Adaptation::ServicePointer s);
 
 protected:
-    virtual ICAPXaction *createXaction();
+    virtual Xaction *createXaction();
 
-    ICAPInOut virgin;
+    InOut virgin;
 
 private:
-    CBDATA_CLASS2(ICAPModXactLauncher);
+    CBDATA_CLASS2(ModXactLauncher);
 };
 
+
+} // namespace Icap
+} // namespace Adaptation
+
 #endif /* SQUID_ICAPMOD_XACT_H */
@@ -0,0 +1,105 @@
+/*
+ * DEBUG: section 93    ICAP (RFC 3507) Client
+ */
+
+#include "squid.h"
+#include "comm.h"
+#include "HttpReply.h"
+
+#include "adaptation/icap/OptXact.h"
+#include "adaptation/icap/Options.h"
+#include "TextException.h"
+
+CBDATA_NAMESPACED_CLASS_INIT(Adaptation::Icap, OptXact);
+CBDATA_NAMESPACED_CLASS_INIT(Adaptation::Icap, OptXactLauncher);
+
+
+Adaptation::Icap::OptXact::OptXact(Adaptation::Initiator *anInitiator, Adaptation::Icap::ServiceRep::Pointer &aService):
+        AsyncJob("Adaptation::Icap::OptXact"),
+        Adaptation::Icap::Xaction("Adaptation::Icap::OptXact", anInitiator, aService)
+{
+}
+
+void Adaptation::Icap::OptXact::start()
+{
+    Adaptation::Icap::Xaction::start();
+
+    openConnection();
+}
+
+void Adaptation::Icap::OptXact::handleCommConnected()
+{
+    scheduleRead();
+
+    MemBuf requestBuf;
+    requestBuf.init();
+    makeRequest(requestBuf);
+    debugs(93, 9, HERE << "request " << status() << ":\n" <<
+           (requestBuf.terminate(), requestBuf.content()));
+
+    scheduleWrite(requestBuf);
+}
+
+void Adaptation::Icap::OptXact::makeRequest(MemBuf &buf)
+{
+    const Adaptation::Service &s = service();
+    const String uri = s.cfg().uri;
+    buf.Printf("OPTIONS " SQUIDSTRINGPH " ICAP/1.0\r\n", SQUIDSTRINGPRINT(uri));
+    const String host = s.cfg().host;
+    buf.Printf("Host: " SQUIDSTRINGPH ":%d\r\n", SQUIDSTRINGPRINT(host), s.cfg().port);
+    buf.append(ICAP::crlf, 2);
+}
+
+void Adaptation::Icap::OptXact::handleCommWrote(size_t size)
+{
+    debugs(93, 9, HERE << "finished writing " << size <<
+           "-byte request " << status());
+}
+
+// comm module read a portion of the ICAP response for us
+void Adaptation::Icap::OptXact::handleCommRead(size_t)
+{
+    if (HttpMsg *r = parseResponse()) {
+        sendAnswer(r);
+        Must(done()); // there should be nothing else to do
+        return;
+    }
+
+    scheduleRead();
+}
+
+HttpMsg *Adaptation::Icap::OptXact::parseResponse()
+{
+    debugs(93, 5, HERE << "have " << readBuf.contentSize() << " bytes to parse" <<
+           status());
+    debugs(93, 5, HERE << "\n" << readBuf.content());
+
+    HttpReply *r = new HttpReply;
+    r->protoPrefix = "ICAP/"; // TODO: make an IcapReply class?
+
+    if (!parseHttpMsg(r)) { // throws on errors
+        delete r;
+        return 0;
+    }
+
+    if (httpHeaderHasConnDir(&r->header, "close"))
+        reuseConnection = false;
+
+    return r;
+}
+
+/* Adaptation::Icap::OptXactLauncher */
+
+Adaptation::Icap::OptXactLauncher::OptXactLauncher(Adaptation::Initiator *anInitiator, Adaptation::ServicePointer aService):
+        AsyncJob("Adaptation::Icap::OptXactLauncher"),
+        Adaptation::Icap::Launcher("Adaptation::Icap::OptXactLauncher", anInitiator, aService)
+{
+}
+
+Adaptation::Icap::Xaction *Adaptation::Icap::OptXactLauncher::createXaction()
+{
+    Adaptation::Icap::ServiceRep::Pointer s =
+        dynamic_cast<Adaptation::Icap::ServiceRep*>(theService.getRaw());
+    Must(s != NULL);
+    return new Adaptation::Icap::OptXact(this, s);
+}
@@ -33,22 +33,26 @@
 #ifndef SQUID_ICAPOPTXACT_H
 #define SQUID_ICAPOPTXACT_H
 
-#include "ICAPXaction.h"
-#include "ICAPLauncher.h"
+#include "adaptation/icap/Xaction.h"
+#include "adaptation/icap/Launcher.h"
 
-class ICAPOptions;
 
+namespace Adaptation {
+namespace Icap {
 
-/* ICAPOptXact sends an ICAP OPTIONS request to the ICAP service,
+class Adaptation::Icap::Options;
+
+
+/* OptXact sends an ICAP OPTIONS request to the ICAP service,
  * parses the ICAP response, and sends it to the initiator. A NULL response
  * means the ICAP service could not be contacted or did not return any
  * valid response. */
 
-class ICAPOptXact: public ICAPXaction
+class OptXact: public Xaction
 {
 
 public:
-    ICAPOptXact(Adaptation::Initiator *anInitiator, ICAPServiceRep::Pointer &aService);
+    OptXact(Adaptation::Initiator *anInitiator, ServiceRep::Pointer &aService);
 
 protected:
     virtual void start();
@@ -62,21 +66,25 @@ class ICAPOptXact: public ICAPXaction
     void startReading();
 
 private:
-    CBDATA_CLASS2(ICAPOptXact);
+    CBDATA_CLASS2(OptXact);
 };
 
-// An ICAPLauncher that stores ICAPOptXact construction info and
-// creates ICAPOptXact when needed
-class ICAPOptXactLauncher: public ICAPLauncher
+// An Launcher that stores OptXact construction info and
+// creates OptXact when needed
+class OptXactLauncher: public Launcher
 {
 public:
-    ICAPOptXactLauncher(Adaptation::Initiator *anInitiator, Adaptation::ServicePointer aService);
+    OptXactLauncher(Adaptation::Initiator *anInitiator, Adaptation::ServicePointer aService);
 
 protected:
-    virtual ICAPXaction *createXaction();
+    virtual Xaction *createXaction();
 
 private:
-    CBDATA_CLASS2(ICAPOptXactLauncher);
+    CBDATA_CLASS2(OptXactLauncher);
 };
 
+
+} // namespace Icap
+} // namespace Adaptation
+
 #endif /* SQUID_ICAPOPTXACT_H */
@@ -1,14 +1,14 @@
 #include "squid.h"
 #include "wordlist.h"
 #include "HttpReply.h"
-#include "ICAPOptions.h"
+#include "adaptation/icap/Options.h"
 #include "TextException.h"
-#include "ICAPConfig.h"
+#include "adaptation/icap/Config.h"
 #include "SquidTime.h"
 
-extern ICAPConfig TheICAPConfig;
+extern Adaptation::Icap::Config Adaptation::Icap::TheConfig;
 
-ICAPOptions::ICAPOptions(): error("unconfigured"),
+Adaptation::Icap::Options::Options(): error("unconfigured"),
         max_connections(-1), allow204(false),
         preview(-1), theTTL(-1)
 {
@@ -24,14 +24,14 @@ ICAPOptions::ICAPOptions(): error("unconfigured"),
     theTransfers.byDefault = &theTransfers.complete;
 }
 
-ICAPOptions::~ICAPOptions()
+Adaptation::Icap::Options::~Options()
 {
 }
 
 // future optimization note: this method is called by ICAP ACL code at least
 // twice for each HTTP message to see if the message should be ignored. For any
 // non-ignored HTTP message, ICAP calls to check whether a preview is needed.
-ICAPOptions::TransferKind ICAPOptions::transferKind(const String &urlPath) const
+Adaptation::Icap::Options::TransferKind Adaptation::Icap::Options::transferKind(const String &urlPath) const
 {
     if (theTransfers.preview.matches(urlPath))
         return xferPreview;
@@ -42,34 +42,34 @@ ICAPOptions::TransferKind ICAPOptions::transferKind(const String &urlPath) const
     if (theTransfers.ignore.matches(urlPath))
         return xferIgnore;
 
-    debugs(93,7, "ICAPOptions url " << urlPath << " matches no extensions; " <<
+    debugs(93,7, HERE << "url " << urlPath << " matches no extensions; " <<
            "using default: " << theTransfers.byDefault->name);
     return theTransfers.byDefault->kind;
 }
 
-bool ICAPOptions::valid() const
+bool Adaptation::Icap::Options::valid() const
 {
     return !error;
 }
 
-bool ICAPOptions::fresh() const
+bool Adaptation::Icap::Options::fresh() const
 {
     return squid_curtime <= expire();
 }
 
-int ICAPOptions::ttl() const
+int Adaptation::Icap::Options::ttl() const
 {
     Must(valid());
-    return theTTL >= 0 ? theTTL : TheICAPConfig.default_options_ttl;
+    return theTTL >= 0 ? theTTL : TheConfig.default_options_ttl;
 }
 
-time_t ICAPOptions::expire() const
+time_t Adaptation::Icap::Options::expire() const
 {
     Must(valid());
     return theTimestamp + ttl();
 }
 
-void ICAPOptions::configure(const HttpReply *reply)
+void Adaptation::Icap::Options::configure(const HttpReply *reply)
 {
     error = NULL; // reset initial "unconfigured" value (or an old error?)
 
@@ -113,14 +113,14 @@ void ICAPOptions::configure(const HttpReply *reply)
     cfgTransferList(h, theTransfers.complete);
 }
 
-void ICAPOptions::cfgMethod(ICAP::Method m)
+void Adaptation::Icap::Options::cfgMethod(ICAP::Method m)
 {
     Must(m != ICAP::methodNone);
     methods += m;
 }
 
 // TODO: HttpHeader should provide a general method for this type of conversion
-void ICAPOptions::cfgIntHeader(const HttpHeader *h, const char *fname, int &value)
+void Adaptation::Icap::Options::cfgIntHeader(const HttpHeader *h, const char *fname, int &value)
 {
     const String s = h->getByName(fname);
 
@@ -129,43 +129,42 @@ void ICAPOptions::cfgIntHeader(const HttpHeader *h, const char *fname, int &valu
     else
         value = -1;
 
-    debugs(93,5, "ICAPOptions::cfgIntHeader " << fname << ": " << value);
+    debugs(93,5, HERE << "int header: " << fname << ": " << value);
 }
 
-void ICAPOptions::cfgTransferList(const HttpHeader *h, TransferList &list)
+void Adaptation::Icap::Options::cfgTransferList(const HttpHeader *h, TransferList &list)
 {
     const String buf = h->getByName(list.name);
     bool foundStar = false;
     list.parse(buf, foundStar);
 
     if (foundStar) {
         theTransfers.byDefault = &list;
-        debugs(93,5, "ICAPOptions::cfgTransferList: " <<
-               "set default transfer to " << list.name);
+        debugs(93,5, HERE << "set default transfer to " << list.name);
     }
 
-    list.report(5, "ICAPOptions::cfgTransferList: ");
+    list.report(5, "Adaptation::Icap::Options::cfgTransferList: ");
 }
 
 
-/* ICAPOptions::TransferList */
+/* Adaptation::Icap::Options::TransferList */
 
-ICAPOptions::TransferList::TransferList(): extensions(NULL), name(NULL),
+Adaptation::Icap::Options::TransferList::TransferList(): extensions(NULL), name(NULL),
         kind(xferNone)
 {
 };
 
-ICAPOptions::TransferList::~TransferList()
+Adaptation::Icap::Options::TransferList::~TransferList()
 {
     wordlistDestroy(&extensions);
 };
 
-void ICAPOptions::TransferList::add(const char *extension)
+void Adaptation::Icap::Options::TransferList::add(const char *extension)
 {
     wordlistAdd(&extensions, extension);
 };
 
-bool ICAPOptions::TransferList::matches(const String &urlPath) const
+bool Adaptation::Icap::Options::TransferList::matches(const String &urlPath) const
 {
     const int urlLen = urlPath.size();
     for (wordlist *e = extensions; e; e = e->next) {
@@ -178,17 +177,17 @@ bool ICAPOptions::TransferList::matches(const String &urlPath) const
             // RFC 3507 examples imply that extensions come without leading '.'
             if (urlPath[eOff-1] == '.' &&
                     strcmp(urlPath.termedBuf() + eOff, e->key) == 0) {
-                debugs(93,7, "ICAPOptions url " << urlPath << " matches " <<
+                debugs(93,7, HERE << "url " << urlPath << " matches " <<
                        name << " extension " << e->key);
                 return true;
             }
         }
     }
-    debugs(93,8, "ICAPOptions url " << urlPath << " matches no " << name << " extensions");
+    debugs(93,8, HERE << "url " << urlPath << " matches no " << name << " extensions");
     return false;
 }
 
-void ICAPOptions::TransferList::parse(const String &buf, bool &foundStar)
+void Adaptation::Icap::Options::TransferList::parse(const String &buf, bool &foundStar)
 {
     foundStar = false;
 
@@ -203,7 +202,7 @@ void ICAPOptions::TransferList::parse(const String &buf, bool &foundStar)
     }
 }
 
-void ICAPOptions::TransferList::report(int level, const char *prefix) const
+void Adaptation::Icap::Options::TransferList::report(int level, const char *prefix) const
 {
     if (extensions) {
         for (wordlist *e = extensions; e; e = e->next)
@@ -35,23 +35,26 @@
 #define SQUID_ICAPOPTIONS_H
 
 #include "squid.h"
-#include "ICAPServiceRep.h"
+#include "adaptation/icap/ServiceRep.h"
 
 class wordlist;
 
+namespace Adaptation {
+namespace Icap {
+
 /* Maintains options supported by a given ICAP service.
  * See RFC 3507, Section "4.10.2 OPTIONS Response". */
 
-class ICAPOptions
+class Options
 {
 
 public:
-    typedef void GetCallback(void *data, ICAPOptions *options);
-    static void Get(ICAPServiceRep::Pointer &service, GetCallback *cb, void *data);
+    typedef void GetCallback(void *data, Options *options);
+    static void Get(ServiceRep::Pointer &service, GetCallback *cb, void *data);
 
 public:
-    ICAPOptions();
-    ~ICAPOptions();
+    Options();
+    ~Options();
 
     void configure(const HttpReply *reply);
 
@@ -118,4 +121,8 @@ class ICAPOptions
 
 
 
+
+} // namespace Icap
+} // namespace Adaptation
+
 #endif /* SQUID_ICAPOPTIONS_H */
@@ -5,39 +5,39 @@
 #include "squid.h"
 #include "TextException.h"
 #include "HttpReply.h"
-#include "ICAPServiceRep.h"
-#include "ICAPOptions.h"
-#include "ICAPOptXact.h"
+#include "adaptation/icap/ServiceRep.h"
+#include "adaptation/icap/Options.h"
+#include "adaptation/icap/OptXact.h"
 #include "ConfigParser.h"
-#include "ICAPConfig.h"
-#include "ICAPModXact.h"
+#include "adaptation/icap/Config.h"
+#include "adaptation/icap/ModXact.h"
 #include "SquidTime.h"
 
-CBDATA_CLASS_INIT(ICAPServiceRep);
+CBDATA_NAMESPACED_CLASS_INIT(Adaptation::Icap, ServiceRep);
 
-ICAPServiceRep::ICAPServiceRep(const Adaptation::ServiceConfig &cfg):
-        AsyncJob("ICAPServiceRep"), Adaptation::Service(cfg),
+Adaptation::Icap::ServiceRep::ServiceRep(const Adaptation::ServiceConfig &cfg):
+        AsyncJob("Adaptation::Icap::ServiceRep"), Adaptation::Service(cfg),
         theOptions(NULL), theOptionsFetcher(0), theLastUpdate(0),
         theSessionFailures(0), isSuspended(0), notifying(false),
         updateScheduled(false), self(NULL),
         wasAnnouncedUp(true) // do not announce an "up" service at startup
 {}
 
-ICAPServiceRep::~ICAPServiceRep()
+Adaptation::Icap::ServiceRep::~ServiceRep()
 {
     Must(!theOptionsFetcher);
     changeOptions(0);
 }
 
 void
-ICAPServiceRep::setSelf(Pointer &aSelf)
+Adaptation::Icap::ServiceRep::setSelf(Pointer &aSelf)
 {
     assert(!self && aSelf != NULL);
     self = aSelf;
 }
 
 void
-ICAPServiceRep::finalize()
+Adaptation::Icap::ServiceRep::finalize()
 {
     Adaptation::Service::finalize();
     assert(self != NULL);
@@ -55,7 +55,7 @@ ICAPServiceRep::finalize()
     }
 }
 
-void ICAPServiceRep::invalidate()
+void Adaptation::Icap::ServiceRep::invalidate()
 {
     assert(self != NULL);
     Pointer savedSelf = self; // to prevent destruction when we nullify self
@@ -67,17 +67,17 @@ void ICAPServiceRep::invalidate()
     // TODO: it would be nice to invalidate cbdata(this) when not destroyed
 }
 
-void ICAPServiceRep::noteFailure()
+void Adaptation::Icap::ServiceRep::noteFailure()
 {
     ++theSessionFailures;
-    debugs(93,4, theSessionFailures << " ICAPService failures, out of " <<
-           TheICAPConfig.service_failure_limit << " allowed " << status());
+    debugs(93,4, HERE << " failure " << theSessionFailures << " out of " <<
+           TheConfig.service_failure_limit << " allowed " << status());
 
     if (isSuspended)
         return;
 
-    if (TheICAPConfig.service_failure_limit >= 0 &&
-            theSessionFailures > TheICAPConfig.service_failure_limit)
+    if (TheConfig.service_failure_limit >= 0 &&
+            theSessionFailures > TheConfig.service_failure_limit)
         suspend("too many failures");
 
     // TODO: Should bypass setting affect how much Squid tries to talk to
@@ -86,98 +86,98 @@ void ICAPServiceRep::noteFailure()
     // should be configurable.
 }
 
-void ICAPServiceRep::suspend(const char *reason)
+void Adaptation::Icap::ServiceRep::suspend(const char *reason)
 {
     if (isSuspended) {
-        debugs(93,4, "keeping ICAPService suspended, also for " << reason);
+        debugs(93,4, HERE << "keeping suspended, also for " << reason);
     } else {
         isSuspended = reason;
-        debugs(93,1, "suspending ICAPService for " << reason);
-        scheduleUpdate(squid_curtime + TheICAPConfig.service_revival_delay);
+        debugs(93,1, "suspending ICAP service for " << reason);
+        scheduleUpdate(squid_curtime + TheConfig.service_revival_delay);
         announceStatusChange("suspended", true);
     }
 }
 
-bool ICAPServiceRep::probed() const
+bool Adaptation::Icap::ServiceRep::probed() const
 {
     return theLastUpdate != 0;
 }
 
-bool ICAPServiceRep::hasOptions() const
+bool Adaptation::Icap::ServiceRep::hasOptions() const
 {
     return theOptions && theOptions->valid() && theOptions->fresh();
 }
 
-bool ICAPServiceRep::up() const
+bool Adaptation::Icap::ServiceRep::up() const
 {
     return self != NULL && !isSuspended && hasOptions();
 }
 
-bool ICAPServiceRep::wantsUrl(const String &urlPath) const
+bool Adaptation::Icap::ServiceRep::wantsUrl(const String &urlPath) const
 {
     Must(hasOptions());
-    return theOptions->transferKind(urlPath) != ICAPOptions::xferIgnore;
+    return theOptions->transferKind(urlPath) != Adaptation::Icap::Options::xferIgnore;
 }
 
-bool ICAPServiceRep::wantsPreview(const String &urlPath, size_t &wantedSize) const
+bool Adaptation::Icap::ServiceRep::wantsPreview(const String &urlPath, size_t &wantedSize) const
 {
     Must(hasOptions());
 
     if (theOptions->preview < 0)
         return false;
 
-    if (theOptions->transferKind(urlPath) != ICAPOptions::xferPreview)
+    if (theOptions->transferKind(urlPath) != Adaptation::Icap::Options::xferPreview)
         return false;
 
     wantedSize = theOptions->preview;
 
     return true;
 }
 
-bool ICAPServiceRep::allows204() const
+bool Adaptation::Icap::ServiceRep::allows204() const
 {
     Must(hasOptions());
     return true; // in the future, we may have ACLs to prevent 204s
 }
 
 
 static
-void ICAPServiceRep_noteTimeToUpdate(void *data)
+void ServiceRep_noteTimeToUpdate(void *data)
 {
-    ICAPServiceRep *service = static_cast<ICAPServiceRep*>(data);
+    Adaptation::Icap::ServiceRep *service = static_cast<Adaptation::Icap::ServiceRep*>(data);
     Must(service);
     service->noteTimeToUpdate();
 }
 
-void ICAPServiceRep::noteTimeToUpdate()
+void Adaptation::Icap::ServiceRep::noteTimeToUpdate()
 {
     if (self != NULL)
         updateScheduled = false;
 
     if (!self || theOptionsFetcher) {
-        debugs(93,5, "ICAPService ignores options update " << status());
+        debugs(93,5, HERE << "ignores options update " << status());
         return;
     }
 
-    debugs(93,5, "ICAPService performs a regular options update " << status());
+    debugs(93,5, HERE << "performs a regular options update " << status());
     startGettingOptions();
 }
 
 #if 0
 static
-void ICAPServiceRep_noteTimeToNotify(void *data)
+void Adaptation::Icap::ServiceRep_noteTimeToNotify(void *data)
 {
-    ICAPServiceRep *service = static_cast<ICAPServiceRep*>(data);
+    Adaptation::Icap::ServiceRep *service = static_cast<Adaptation::Icap::ServiceRep*>(data);
     Must(service);
     service->noteTimeToNotify();
 }
 #endif
 
-void ICAPServiceRep::noteTimeToNotify()
+void Adaptation::Icap::ServiceRep::noteTimeToNotify()
 {
     Must(!notifying);
     notifying = true;
-    debugs(93,7, "ICAPService notifies " << theClients.size() << " clients " <<
+    debugs(93,7, HERE << "notifies " << theClients.size() << " clients " <<
            status());
 
     // note: we must notify even if we are invalidated
@@ -193,11 +193,11 @@ void ICAPServiceRep::noteTimeToNotify()
     notifying = false;
 }
 
-void ICAPServiceRep::callWhenReady(AsyncCall::Pointer &cb)
+void Adaptation::Icap::ServiceRep::callWhenReady(AsyncCall::Pointer &cb)
 {
     Must(cb!=NULL);
 
-    debugs(93,5, HERE << "ICAPService is asked to call " << *cb <<
+    debugs(93,5, HERE << "Adaptation::Icap::Service is asked to call " << *cb <<
            " when ready " << status());
 
     Must(self != NULL);
@@ -217,20 +217,20 @@ void ICAPServiceRep::callWhenReady(AsyncCall::Pointer &cb)
         scheduleNotification();
 }
 
-void ICAPServiceRep::scheduleNotification()
+void Adaptation::Icap::ServiceRep::scheduleNotification()
 {
-    debugs(93,7, "ICAPService will notify " << theClients.size() << " clients");
-    CallJobHere(93, 5, this, ICAPServiceRep::noteTimeToNotify);
+    debugs(93,7, HERE << "will notify " << theClients.size() << " clients");
+    CallJobHere(93, 5, this, Adaptation::Icap::ServiceRep::noteTimeToNotify);
 }
 
-bool ICAPServiceRep::needNewOptions() const
+bool Adaptation::Icap::ServiceRep::needNewOptions() const
 {
     return self != NULL && !up();
 }
 
-void ICAPServiceRep::changeOptions(ICAPOptions *newOptions)
+void Adaptation::Icap::ServiceRep::changeOptions(Adaptation::Icap::Options *newOptions)
 {
-    debugs(93,8, "ICAPService changes options from " << theOptions << " to " <<
+    debugs(93,8, HERE << "changes options from " << theOptions << " to " <<
            newOptions << ' ' << status());
 
     delete theOptions;
@@ -243,7 +243,7 @@ void ICAPServiceRep::changeOptions(ICAPOptions *newOptions)
     announceStatusChange("down after an options fetch failure", true);
 }
 
-void ICAPServiceRep::checkOptions()
+void Adaptation::Icap::ServiceRep::checkOptions()
 {
     if (theOptions == NULL)
         return;
@@ -297,7 +297,7 @@ void ICAPServiceRep::checkOptions()
     }
 }
 
-void ICAPServiceRep::announceStatusChange(const char *downPhrase, bool important) const
+void Adaptation::Icap::ServiceRep::announceStatusChange(const char *downPhrase, bool important) const
 {
     if (wasAnnouncedUp == up()) // no significant changes to announce
         return;
@@ -312,68 +312,68 @@ void ICAPServiceRep::announceStatusChange(const char *downPhrase, bool important
 }
 
 // we are receiving ICAP OPTIONS response headers here or NULL on failures
-void ICAPServiceRep::noteAdaptationAnswer(HttpMsg *msg)
+void Adaptation::Icap::ServiceRep::noteAdaptationAnswer(HttpMsg *msg)
 {
     Must(theOptionsFetcher);
     clearAdaptation(theOptionsFetcher);
 
     Must(msg);
 
-    debugs(93,5, "ICAPService is interpreting new options " << status());
+    debugs(93,5, HERE << "is interpreting new options " << status());
 
-    ICAPOptions *newOptions = NULL;
+    Adaptation::Icap::Options *newOptions = NULL;
     if (HttpReply *r = dynamic_cast<HttpReply*>(msg)) {
-        newOptions = new ICAPOptions;
+        newOptions = new Adaptation::Icap::Options;
         newOptions->configure(r);
     } else {
-        debugs(93,1, "ICAPService got wrong options message " << status());
+        debugs(93,1, "ICAP service got wrong options message " << status());
     }
 
     handleNewOptions(newOptions);
 }
 
-void ICAPServiceRep::noteAdaptationQueryAbort(bool)
+void Adaptation::Icap::ServiceRep::noteAdaptationQueryAbort(bool)
 {
     Must(theOptionsFetcher);
     clearAdaptation(theOptionsFetcher);
 
-    debugs(93,3, "ICAPService failed to fetch options " << status());
+    debugs(93,3, HERE << "failed to fetch options " << status());
     handleNewOptions(0);
 }
 
-void ICAPServiceRep::handleNewOptions(ICAPOptions *newOptions)
+void Adaptation::Icap::ServiceRep::handleNewOptions(Adaptation::Icap::Options *newOptions)
 {
     // new options may be NULL
     changeOptions(newOptions);
 
-    debugs(93,3, "ICAPService got new options and is now " << status());
+    debugs(93,3, HERE << "got new options and is now " << status());
 
     scheduleUpdate(optionsFetchTime());
     scheduleNotification();
 }
 
-void ICAPServiceRep::startGettingOptions()
+void Adaptation::Icap::ServiceRep::startGettingOptions()
 {
     Must(!theOptionsFetcher);
-    debugs(93,6, "ICAPService will get new options " << status());
+    debugs(93,6, HERE << "will get new options " << status());
 
     // XXX: second "this" is "self"; this works but may stop if API changes
-    theOptionsFetcher = initiateAdaptation(new ICAPOptXactLauncher(this, this));
+    theOptionsFetcher = initiateAdaptation(new Adaptation::Icap::OptXactLauncher(this, this));
     Must(theOptionsFetcher);
-    // TODO: timeout in case ICAPOptXact never calls us back?
+    // TODO: timeout in case Adaptation::Icap::OptXact never calls us back?
     // Such a timeout should probably be a generic AsyncStart feature.
 }
 
-void ICAPServiceRep::scheduleUpdate(time_t when)
+void Adaptation::Icap::ServiceRep::scheduleUpdate(time_t when)
 {
     if (updateScheduled) {
-        debugs(93,7, "ICAPService reschedules update");
+        debugs(93,7, HERE << "reschedules update");
         // XXX: check whether the event is there because AR saw
         // an unreproducible eventDelete assertion on 2007/06/18
-        if (eventFind(&ICAPServiceRep_noteTimeToUpdate, this))
-            eventDelete(&ICAPServiceRep_noteTimeToUpdate, this);
+        if (eventFind(&ServiceRep_noteTimeToUpdate, this))
+            eventDelete(&ServiceRep_noteTimeToUpdate, this);
         else
-            debugs(93,1, "XXX: ICAPService lost an update event.");
+            debugs(93,1, "XXX: ICAP service lost an update event.");
         updateScheduled = false;
     }
 
@@ -387,33 +387,33 @@ void ICAPServiceRep::scheduleUpdate(time_t when)
     if (when < squid_curtime)
         when = squid_curtime;
 
-    // XXX: move hard-coded constants from here to TheICAPConfig
+    // XXX: move hard-coded constants from here to Adaptation::Icap::TheConfig
     const int minUpdateGap = 30; // seconds
     if (when < theLastUpdate + minUpdateGap)
         when = theLastUpdate + minUpdateGap;
 
     const int delay = when - squid_curtime;
-    debugs(93,5, "ICAPService will fetch OPTIONS in " << delay << " sec");
+    debugs(93,5, HERE << "will fetch OPTIONS in " << delay << " sec");
 
-    eventAdd("ICAPServiceRep::noteTimeToUpdate",
-             &ICAPServiceRep_noteTimeToUpdate, this, delay, 0, true);
+    eventAdd("Adaptation::Icap::ServiceRep::noteTimeToUpdate",
+             &ServiceRep_noteTimeToUpdate, this, delay, 0, true);
     updateScheduled = true;
 }
 
 // returns absolute time when OPTIONS should be fetched
 time_t
-ICAPServiceRep::optionsFetchTime() const
+Adaptation::Icap::ServiceRep::optionsFetchTime() const
 {
     if (theOptions && theOptions->valid()) {
         const time_t expire = theOptions->expire();
-        debugs(93,7, "ICAPService options expire on " << expire << " >= " << squid_curtime);
+        debugs(93,7, HERE << "options expire on " << expire << " >= " << squid_curtime);
 
         // conservative estimate of how long the OPTIONS transaction will take
-        // XXX: move hard-coded constants from here to TheICAPConfig
+        // XXX: move hard-coded constants from here to Adaptation::Icap::TheConfig
         const int expectedWait = 20; // seconds
 
         // Unknown or invalid (too small) expiration times should not happen.
-        // ICAPOptions should use the default TTL, and ICAP servers should not
+        // Adaptation::Icap::Options should use the default TTL, and ICAP servers should not
         // send invalid TTLs, but bugs and attacks happen.
         if (expire < expectedWait)
             return squid_curtime;
@@ -422,18 +422,18 @@ ICAPServiceRep::optionsFetchTime() const
     }
 
     // use revival delay as "expiration" time for a service w/o valid options
-    return squid_curtime + TheICAPConfig.service_revival_delay;
+    return squid_curtime + TheConfig.service_revival_delay;
 }
 
 Adaptation::Initiate *
-ICAPServiceRep::makeXactLauncher(Adaptation::Initiator *initiator,
+Adaptation::Icap::ServiceRep::makeXactLauncher(Adaptation::Initiator *initiator,
                                  HttpMsg *virgin, HttpRequest *cause)
 {
-    return new ICAPModXactLauncher(initiator, virgin, cause, this);
+    return new Adaptation::Icap::ModXactLauncher(initiator, virgin, cause, this);
 }
 
 // returns a temporary string depicting service status, for debugging
-const char *ICAPServiceRep::status() const
+const char *Adaptation::Icap::ServiceRep::status() const
 {
     static MemBuf buf;
 
@@ -38,10 +38,14 @@
 #include "adaptation/Service.h"
 #include "adaptation/forward.h"
 #include "adaptation/Initiator.h"
-#include "ICAPElements.h"
+#include "adaptation/icap/Elements.h"
 
-class ICAPOptions;
-class ICAPOptXact;
+
+namespace Adaptation {
+namespace Icap {
+
+class Options;
+class OptXact;
 
 /* The ICAP service representative maintains information about a single ICAP
    service that Squid communicates with. The representative initiates OPTIONS
@@ -72,18 +76,18 @@ class ICAPOptXact;
  */
 
 
-class ICAPServiceRep : public RefCountable, public Adaptation::Service,
+class ServiceRep : public RefCountable, public Adaptation::Service,
             public Adaptation::Initiator
 {
 
 public:
-    typedef RefCount<ICAPServiceRep> Pointer;
+    typedef RefCount<ServiceRep> Pointer;
 
 public:
-    ICAPServiceRep(const Adaptation::ServiceConfig &config);
-    virtual ~ICAPServiceRep();
+    ServiceRep(const Adaptation::ServiceConfig &config);
+    virtual ~ServiceRep();
 
-    void setSelf(Pointer &aSelf); // needs self pointer for ICAPOptXact
+    void setSelf(Pointer &aSelf); // needs self pointer for OptXact
     virtual void finalize();
 
     void invalidate(); // call when the service is no longer needed or valid
@@ -124,7 +128,7 @@ class ICAPServiceRep : public RefCountable, public Adaptation::Service,
     typedef Vector<Client> Clients;
     Clients theClients; // all clients waiting for a call back
 
-    ICAPOptions *theOptions;
+    Options *theOptions;
     Adaptation::Initiate *theOptionsFetcher; // pending ICAP OPTIONS transaction
     time_t theLastUpdate; // time the options were last updated
 
@@ -149,8 +153,8 @@ class ICAPServiceRep : public RefCountable, public Adaptation::Service,
     void scheduleNotification();
 
     void startGettingOptions();
-    void handleNewOptions(ICAPOptions *newOptions);
-    void changeOptions(ICAPOptions *newOptions);
+    void handleNewOptions(Options *newOptions);
+    void changeOptions(Options *newOptions);
     void checkOptions();
 
     void announceStatusChange(const char *downPhrase, bool important) const;
@@ -159,7 +163,11 @@ class ICAPServiceRep : public RefCountable, public Adaptation::Service,
 
     Pointer self;
     mutable bool wasAnnouncedUp; // prevent sequential same-state announcements
-    CBDATA_CLASS2(ICAPServiceRep);
+    CBDATA_CLASS2(ServiceRep);
 };
 
+
+} // namespace Icap
+} // namespace Adaptation
+
 #endif /* SQUID_ICAPSERVICEREP_H */
@@ -6,18 +6,18 @@
 #include "comm.h"
 #include "CommCalls.h"
 #include "HttpMsg.h"
-#include "ICAPXaction.h"
-#include "ICAPConfig.h"
+#include "adaptation/icap/Xaction.h"
+#include "adaptation/icap/Config.h"
 #include "TextException.h"
 #include "pconn.h"
 #include "fde.h"
 
 static PconnPool *icapPconnPool = new PconnPool("ICAP Servers");
 
 
-//CBDATA_CLASS_INIT(ICAPXaction);
+//CBDATA_NAMESPACED_CLASS_INIT(Adaptation::Icap, Xaction);
 
-ICAPXaction::ICAPXaction(const char *aTypeName, Adaptation::Initiator *anInitiator, ICAPServiceRep::Pointer &aService):
+Adaptation::Icap::Xaction::Xaction(const char *aTypeName, Adaptation::Initiator *anInitiator, Adaptation::Icap::ServiceRep::Pointer &aService):
         AsyncJob(aTypeName),
         Adaptation::Initiate(aTypeName, anInitiator, aService.getRaw()),
         connection(-1),
@@ -32,28 +32,28 @@ ICAPXaction::ICAPXaction(const char *aTypeName, Adaptation::Initiator *anInitiat
            " [icapx" << id << ']'); // we should not call virtual status() here
 }
 
-ICAPXaction::~ICAPXaction()
+Adaptation::Icap::Xaction::~Xaction()
 {
     debugs(93,3, typeName << " destructed, this=" << this <<
            " [icapx" << id << ']'); // we should not call virtual status() here
 }
 
-ICAPServiceRep &
-ICAPXaction::service()
+Adaptation::Icap::ServiceRep &
+Adaptation::Icap::Xaction::service()
 {
-    ICAPServiceRep *s = dynamic_cast<ICAPServiceRep*>(&Initiate::service());
+    Adaptation::Icap::ServiceRep *s = dynamic_cast<Adaptation::Icap::ServiceRep*>(&Initiate::service());
     Must(s);
     return *s;
 }
 
-void ICAPXaction::disableRetries()
+void Adaptation::Icap::Xaction::disableRetries()
 {
     debugs(93,5, typeName << (isRetriable ? " becomes" : " remains") <<
            " final" << status());
     isRetriable = false;
 }
 
-void ICAPXaction::start()
+void Adaptation::Icap::Xaction::start()
 {
     Adaptation::Initiate::start();
 
@@ -64,15 +64,15 @@ void ICAPXaction::start()
 }
 
 // TODO: obey service-specific, OPTIONS-reported connection limit
-void ICAPXaction::openConnection()
+void Adaptation::Icap::Xaction::openConnection()
 {
     IpAddress client_addr;
 
     Must(connection < 0);
 
     const Adaptation::Service &s = service();
 
-    if (!TheICAPConfig.reuse_connections)
+    if (!TheConfig.reuse_connections)
         disableRetries(); // this will also safely drain pconn pool
 
     // TODO: check whether NULL domain is appropriate here
@@ -81,13 +81,13 @@ void ICAPXaction::openConnection()
         debugs(93,3, HERE << "reused pconn FD " << connection);
 
         // fake the connect callback
-        // TODO: can we sync call ICAPXaction::noteCommConnected here instead?
-        typedef CommCbMemFunT<ICAPXaction, CommConnectCbParams> Dialer;
-        Dialer dialer(this, &ICAPXaction::noteCommConnected);
+        // TODO: can we sync call Adaptation::Icap::Xaction::noteCommConnected here instead?
+        typedef CommCbMemFunT<Adaptation::Icap::Xaction, CommConnectCbParams> Dialer;
+        Dialer dialer(this, &Adaptation::Icap::Xaction::noteCommConnected);
 	dialer.params.fd = connection;
         dialer.params.flag = COMM_OK;
         // fake other parameters by copying from the existing connection
-        connector = asyncCall(93,3, "ICAPXaction::noteCommConnected", dialer);
+        connector = asyncCall(93,3, "Adaptation::Icap::Xaction::noteCommConnected", dialer);
         ScheduleCallHere(connector);
         return;
     }
@@ -104,39 +104,39 @@ void ICAPXaction::openConnection()
     debugs(93,3, typeName << " opens connection to " << s.cfg().host << ":" << s.cfg().port);
 
     // TODO: service bypass status may differ from that of a transaction
-    typedef CommCbMemFunT<ICAPXaction, CommTimeoutCbParams> TimeoutDialer;
-    AsyncCall::Pointer timeoutCall =  asyncCall(93, 5, "ICAPXaction::noteCommTimedout",
-                                      TimeoutDialer(this,&ICAPXaction::noteCommTimedout));
+    typedef CommCbMemFunT<Adaptation::Icap::Xaction, CommTimeoutCbParams> TimeoutDialer;
+    AsyncCall::Pointer timeoutCall =  asyncCall(93, 5, "Adaptation::Icap::Xaction::noteCommTimedout",
+                                      TimeoutDialer(this,&Adaptation::Icap::Xaction::noteCommTimedout));
 
-    commSetTimeout(connection, TheICAPConfig.connect_timeout(
+    commSetTimeout(connection, TheConfig.connect_timeout(
                        service().cfg().bypass), timeoutCall);
 
-    typedef CommCbMemFunT<ICAPXaction, CommCloseCbParams> CloseDialer;
-    closer =  asyncCall(93, 5, "ICAPXaction::noteCommClosed",
-                        CloseDialer(this,&ICAPXaction::noteCommClosed));
+    typedef CommCbMemFunT<Adaptation::Icap::Xaction, CommCloseCbParams> CloseDialer;
+    closer =  asyncCall(93, 5, "Adaptation::Icap::Xaction::noteCommClosed",
+                        CloseDialer(this,&Adaptation::Icap::Xaction::noteCommClosed));
     comm_add_close_handler(connection, closer);
 
-    typedef CommCbMemFunT<ICAPXaction, CommConnectCbParams> ConnectDialer;
-    connector = asyncCall(93,3, "ICAPXaction::noteCommConnected",
-                          ConnectDialer(this, &ICAPXaction::noteCommConnected));
+    typedef CommCbMemFunT<Adaptation::Icap::Xaction, CommConnectCbParams> ConnectDialer;
+    connector = asyncCall(93,3, "Adaptation::Icap::Xaction::noteCommConnected",
+                          ConnectDialer(this, &Adaptation::Icap::Xaction::noteCommConnected));
     commConnectStart(connection, s.cfg().host.termedBuf(), s.cfg().port, connector);
 }
 
 /*
  * This event handler is necessary to work around the no-rentry policy
- * of ICAPXaction::callStart()
+ * of Adaptation::Icap::Xaction::callStart()
  */
 #if 0
 void
-ICAPXaction::reusedConnection(void *data)
+Adaptation::Icap::Xaction::reusedConnection(void *data)
 {
-    debugs(93, 5, "ICAPXaction::reusedConnection");
-    ICAPXaction *x = (ICAPXaction*)data;
+    debugs(93, 5, HERE << "reused connection");
+    Adaptation::Icap::Xaction *x = (Adaptation::Icap::Xaction*)data;
     x->noteCommConnected(COMM_OK);
 }
 #endif
 
-void ICAPXaction::closeConnection()
+void Adaptation::Icap::Xaction::closeConnection()
 {
     if (connection >= 0) {
 
@@ -177,7 +177,7 @@ void ICAPXaction::closeConnection()
 }
 
 // connection with the ICAP service established
-void ICAPXaction::noteCommConnected(const CommConnectCbParams &io)
+void Adaptation::Icap::Xaction::noteCommConnected(const CommConnectCbParams &io)
 {
     Must(connector != NULL);
     connector = NULL;
@@ -190,26 +190,26 @@ void ICAPXaction::noteCommConnected(const CommConnectCbParams &io)
     handleCommConnected();
 }
 
-void ICAPXaction::dieOnConnectionFailure()
+void Adaptation::Icap::Xaction::dieOnConnectionFailure()
 {
     debugs(93, 2, HERE << typeName <<
            " failed to connect to " << service().cfg().uri);
     theService->noteFailure();
     throw TexcHere("cannot connect to the ICAP service");
 }
 
-void ICAPXaction::scheduleWrite(MemBuf &buf)
+void Adaptation::Icap::Xaction::scheduleWrite(MemBuf &buf)
 {
     // comm module will free the buffer
-    typedef CommCbMemFunT<ICAPXaction, CommIoCbParams> Dialer;
-    writer = asyncCall(93,3, "ICAPXaction::noteCommWrote",
-                       Dialer(this, &ICAPXaction::noteCommWrote));
+    typedef CommCbMemFunT<Adaptation::Icap::Xaction, CommIoCbParams> Dialer;
+    writer = asyncCall(93,3, "Adaptation::Icap::Xaction::noteCommWrote",
+                       Dialer(this, &Adaptation::Icap::Xaction::noteCommWrote));
 
     comm_write_mbuf(connection, &buf, writer);
     updateTimeout();
 }
 
-void ICAPXaction::noteCommWrote(const CommIoCbParams &io)
+void Adaptation::Icap::Xaction::noteCommWrote(const CommIoCbParams &io)
 {
     Must(writer != NULL);
     writer = NULL;
@@ -226,12 +226,12 @@ void ICAPXaction::noteCommWrote(const CommIoCbParams &io)
 }
 
 // communication timeout with the ICAP service
-void ICAPXaction::noteCommTimedout(const CommTimeoutCbParams &io)
+void Adaptation::Icap::Xaction::noteCommTimedout(const CommTimeoutCbParams &io)
 {
     handleCommTimedout();
 }
 
-void ICAPXaction::handleCommTimedout()
+void Adaptation::Icap::Xaction::handleCommTimedout()
 {
     debugs(93, 2, HERE << typeName << " failed: timeout with " <<
            theService->cfg().methodStr() << " " <<
@@ -245,18 +245,18 @@ void ICAPXaction::handleCommTimedout()
 }
 
 // unexpected connection close while talking to the ICAP service
-void ICAPXaction::noteCommClosed(const CommCloseCbParams &io)
+void Adaptation::Icap::Xaction::noteCommClosed(const CommCloseCbParams &io)
 {
     closer = NULL;
     handleCommClosed();
 }
 
-void ICAPXaction::handleCommClosed()
+void Adaptation::Icap::Xaction::handleCommClosed()
 {
     mustStop("ICAP service connection externally closed");
 }
 
-void ICAPXaction::callEnd()
+void Adaptation::Icap::Xaction::callEnd()
 {
     if (doneWithIo()) {
         debugs(93, 5, HERE << typeName << " done with I/O" << status());
@@ -265,23 +265,23 @@ void ICAPXaction::callEnd()
     Adaptation::Initiate::callEnd(); // may destroy us
 }
 
-bool ICAPXaction::doneAll() const
+bool Adaptation::Icap::Xaction::doneAll() const
 {
     return !connector && !reader && !writer && Adaptation::Initiate::doneAll();
 }
 
-void ICAPXaction::updateTimeout()
+void Adaptation::Icap::Xaction::updateTimeout()
 {
     if (reader != NULL || writer != NULL) {
         // restart the timeout before each I/O
         // XXX: why does Config.Timeout lacks a write timeout?
         // TODO: service bypass status may differ from that of a transaction
-        typedef CommCbMemFunT<ICAPXaction, CommTimeoutCbParams> TimeoutDialer;
-        AsyncCall::Pointer call =  asyncCall(93, 5, "ICAPXaction::noteCommTimedout",
-                                             TimeoutDialer(this,&ICAPXaction::noteCommTimedout));
+        typedef CommCbMemFunT<Adaptation::Icap::Xaction, CommTimeoutCbParams> TimeoutDialer;
+        AsyncCall::Pointer call =  asyncCall(93, 5, "Adaptation::Icap::Xaction::noteCommTimedout",
+                                             TimeoutDialer(this,&Adaptation::Icap::Xaction::noteCommTimedout));
 
         commSetTimeout(connection,
-                       TheICAPConfig.io_timeout(service().cfg().bypass), call);
+                       TheConfig.io_timeout(service().cfg().bypass), call);
     } else {
         // clear timeout when there is no I/O
         // Do we need a lifetime timeout?
@@ -290,26 +290,26 @@ void ICAPXaction::updateTimeout()
     }
 }
 
-void ICAPXaction::scheduleRead()
+void Adaptation::Icap::Xaction::scheduleRead()
 {
     Must(connection >= 0);
     Must(!reader);
     Must(readBuf.hasSpace());
 
     /*
-     * See comments in ICAPXaction.h about why we use commBuf
+     * See comments in Adaptation::Icap::Xaction.h about why we use commBuf
      * here instead of reading directly into readBuf.buf.
      */
-    typedef CommCbMemFunT<ICAPXaction, CommIoCbParams> Dialer;
-    reader = asyncCall(93,3, "ICAPXaction::noteCommRead",
-                       Dialer(this, &ICAPXaction::noteCommRead));
+    typedef CommCbMemFunT<Adaptation::Icap::Xaction, CommIoCbParams> Dialer;
+    reader = asyncCall(93,3, "Adaptation::Icap::Xaction::noteCommRead",
+                       Dialer(this, &Adaptation::Icap::Xaction::noteCommRead));
 
     comm_read(connection, commBuf, readBuf.spaceSize(), reader);
     updateTimeout();
 }
 
 // comm module read a portion of the ICAP response for us
-void ICAPXaction::noteCommRead(const CommIoCbParams &io)
+void Adaptation::Icap::Xaction::noteCommRead(const CommIoCbParams &io)
 {
     Must(reader != NULL);
     reader = NULL;
@@ -322,7 +322,7 @@ void ICAPXaction::noteCommRead(const CommIoCbParams &io)
     debugs(93, 3, HERE << "read " << io.size << " bytes");
 
     /*
-     * See comments in ICAPXaction.h about why we use commBuf
+     * See comments in Adaptation::Icap::Xaction.h about why we use commBuf
      * here instead of reading directly into readBuf.buf.
      */
 
@@ -337,15 +337,15 @@ void ICAPXaction::noteCommRead(const CommIoCbParams &io)
     handleCommRead(io.size);
 }
 
-void ICAPXaction::cancelRead()
+void Adaptation::Icap::Xaction::cancelRead()
 {
     if (reader != NULL) {
         comm_read_cancel(connection, reader);
         reader = NULL;
     }
 }
 
-bool ICAPXaction::parseHttpMsg(HttpMsg *msg)
+bool Adaptation::Icap::Xaction::parseHttpMsg(HttpMsg *msg)
 {
     debugs(93, 5, HERE << "have " << readBuf.contentSize() << " head bytes to parse");
 
@@ -363,31 +363,31 @@ bool ICAPXaction::parseHttpMsg(HttpMsg *msg)
     return true;
 }
 
-bool ICAPXaction::mayReadMore() const
+bool Adaptation::Icap::Xaction::mayReadMore() const
 {
     return !doneReading() && // will read more data
            readBuf.hasSpace();  // have space for more data
 }
 
-bool ICAPXaction::doneReading() const
+bool Adaptation::Icap::Xaction::doneReading() const
 {
     return commEof;
 }
 
-bool ICAPXaction::doneWriting() const
+bool Adaptation::Icap::Xaction::doneWriting() const
 {
     return !writer;
 }
 
-bool ICAPXaction::doneWithIo() const
+bool Adaptation::Icap::Xaction::doneWithIo() const
 {
     return connection >= 0 && // or we could still be waiting to open it
            !connector && !reader && !writer && // fast checks, some redundant
            doneReading() && doneWriting();
 }
 
 // initiator aborted
-void ICAPXaction::noteInitiatorAborted()
+void Adaptation::Icap::Xaction::noteInitiatorAborted()
 {
 
     if (theInitiator) {
@@ -400,7 +400,7 @@ void ICAPXaction::noteInitiatorAborted()
 // This 'last chance' method is called before a 'done' transaction is deleted.
 // It is wrong to call virtual methods from a destructor. Besides, this call
 // indicates that the transaction will terminate as planned.
-void ICAPXaction::swanSong()
+void Adaptation::Icap::Xaction::swanSong()
 {
     // kids should sing first and then call the parent method.
 
@@ -419,7 +419,7 @@ void ICAPXaction::swanSong()
 }
 
 // returns a temporary string depicting transaction status, for debugging
-const char *ICAPXaction::status() const
+const char *Adaptation::Icap::Xaction::status() const
 {
     static MemBuf buf;
     buf.reset();
@@ -437,7 +437,7 @@ const char *ICAPXaction::status() const
     return buf.content();
 }
 
-void ICAPXaction::fillPendingStatus(MemBuf &buf) const
+void Adaptation::Icap::Xaction::fillPendingStatus(MemBuf &buf) const
 {
     if (connection >= 0) {
         buf.Printf("FD %d", connection);
@@ -452,7 +452,7 @@ void ICAPXaction::fillPendingStatus(MemBuf &buf) const
     }
 }
 
-void ICAPXaction::fillDoneStatus(MemBuf &buf) const
+void Adaptation::Icap::Xaction::fillDoneStatus(MemBuf &buf) const
 {
     if (connection >= 0 && commEof)
         buf.Printf("Comm(%d)", connection);
@@ -461,7 +461,7 @@ void ICAPXaction::fillDoneStatus(MemBuf &buf) const
         buf.Printf("Stopped");
 }
 
-bool ICAPXaction::fillVirginHttpHeader(MemBuf &buf) const
+bool Adaptation::Icap::Xaction::fillVirginHttpHeader(MemBuf &buf) const
 {
     return false;
 }
@@ -37,28 +37,31 @@
 #include "comm.h"
 #include "CommCalls.h"
 #include "MemBuf.h"
-#include "ICAPServiceRep.h"
+#include "adaptation/icap/ServiceRep.h"
 #include "adaptation/Initiate.h"
 
 class HttpMsg;
 class CommConnectCbParams;
 
+namespace Adaptation {
+namespace Icap {
+
 /*
  * The ICAP Xaction implements common tasks for ICAP OPTIONS, REQMOD, and
- * RESPMOD transactions. It is started by an ICAPInitiator. It terminates
+ * RESPMOD transactions. It is started by an Initiator. It terminates
  * on its own, when done. Transactions communicate with Initiator using
  * asynchronous messages because a transaction or Initiator may be gone at
  * any time.
  */
 
-// Note: ICAPXaction must be the first parent for object-unaware cbdata to work
+// Note: Xaction must be the first parent for object-unaware cbdata to work
 
-class ICAPXaction: public Adaptation::Initiate
+class Xaction: public Adaptation::Initiate
 {
 
 public:
-    ICAPXaction(const char *aTypeName, Adaptation::Initiator *anInitiator, ICAPServiceRep::Pointer &aService);
-    virtual ~ICAPXaction();
+    Xaction(const char *aTypeName, Adaptation::Initiator *anInitiator, ServiceRep::Pointer &aService);
+    virtual ~Xaction();
 
     void disableRetries();
 
@@ -112,7 +115,7 @@ class ICAPXaction: public Adaptation::Initiate
     // custom end-of-call checks
     virtual void callEnd();
 
-    ICAPServiceRep &service();
+    ServiceRep &service();
 
 protected:
     int connection;     // FD of the ICAP server connection
@@ -145,7 +148,11 @@ class ICAPXaction: public Adaptation::Initiate
     AsyncCall::Pointer closer;
 
 private:
-    //CBDATA_CLASS2(ICAPXaction);
+    //CBDATA_CLASS2(Xaction);
 };
 
+
+} // namespace Icap
+} // namespace Adaptation
+
 #endif /* SQUID_ICAPXACTION_H */
@@ -69,18 +69,18 @@ static void parse_adaptation_access_type();
 #endif
 
 #if ICAP_CLIENT
-#include "ICAP/ICAPConfig.h"
+#include "adaptation/icap/Config.h"
 
-static void parse_icap_service_type(ICAPConfig *);
-static void dump_icap_service_type(StoreEntry *, const char *, const ICAPConfig &);
-static void free_icap_service_type(ICAPConfig *);
+static void parse_icap_service_type(Adaptation::Icap::Config *);
+static void dump_icap_service_type(StoreEntry *, const char *, const Adaptation::Icap::Config &);
+static void free_icap_service_type(Adaptation::Icap::Config *);
 static void parse_icap_class_type();
 static void parse_icap_access_type();
 
 #endif
 
 #if USE_ECAP
-#include "eCAP/Config.h"
+#include "adaptation/ecap/Config.h"
 static void parse_ecap_service_type(Ecap::Config *);
 static void dump_ecap_service_type(StoreEntry *, const char *, const Ecap::Config &);
 static void free_ecap_service_type(Ecap::Config *);
@@ -3508,19 +3508,19 @@ parse_adaptation_access_type()
 #if ICAP_CLIENT
 
 static void
-parse_icap_service_type(ICAPConfig * cfg)
+parse_icap_service_type(Adaptation::Icap::Config * cfg)
 {
     cfg->parseService();
 }
 
 static void
-free_icap_service_type(ICAPConfig * cfg)
+free_icap_service_type(Adaptation::Icap::Config * cfg)
 {
     cfg->freeService();
 }
 
 static void
-dump_icap_service_type(StoreEntry * entry, const char *name, const ICAPConfig &cfg)
+dump_icap_service_type(StoreEntry * entry, const char *name, const Adaptation::Icap::Config &cfg)
 {
     cfg.dumpService(entry, name);
 }
@@ -378,6 +378,7 @@ extern cbdata_type cbdataInternalAddType(cbdata_type type, const char *label, in
 
 /// \ingroup CBDATAAPI
 #define CBDATA_CLASS_INIT(type) cbdata_type type::CBDATA_##type = CBDATA_UNKNOWN
+#define CBDATA_NAMESPACED_CLASS_INIT(namespace, type) cbdata_type namespace::type::CBDATA_##type = CBDATA_UNKNOWN
 
 /**
  \ingroup CBDATAAPI
@@ -5120,7 +5120,7 @@ NAME: icap_enable
 TYPE: onoff
 IFDEF: ICAP_CLIENT
 COMMENT: on|off
-LOC: TheICAPConfig.onoff
+LOC: Adaptation::Icap::TheConfig.onoff
 DEFAULT: off
 DOC_START
 	If you want to enable the ICAP module support, set this to on.
@@ -5129,7 +5129,7 @@ DOC_END
 NAME: icap_connect_timeout
 TYPE: time_t
 DEFAULT: none
-LOC: TheICAPConfig.connect_timeout_raw
+LOC: Adaptation::Icap::TheConfig.connect_timeout_raw
 IFDEF: ICAP_CLIENT
 DOC_START
 	This parameter specifies how long to wait for the TCP connect to
@@ -5145,7 +5145,7 @@ NAME: icap_io_timeout
 COMMENT: time-units
 TYPE: time_t
 DEFAULT: none
-LOC: TheICAPConfig.io_timeout_raw
+LOC: Adaptation::Icap::TheConfig.io_timeout_raw
 IFDEF: ICAP_CLIENT
 DOC_START
 	This parameter specifies how long to wait for an I/O activity on
@@ -5159,7 +5159,7 @@ DOC_END
 NAME: icap_service_failure_limit
 TYPE: int
 IFDEF: ICAP_CLIENT
-LOC: TheICAPConfig.service_failure_limit
+LOC: Adaptation::Icap::TheConfig.service_failure_limit
 DEFAULT: 10
 DOC_START
 	The limit specifies the number of failures that Squid tolerates
@@ -5177,7 +5177,7 @@ DOC_END
 NAME: icap_service_revival_delay
 TYPE: int
 IFDEF: ICAP_CLIENT
-LOC: TheICAPConfig.service_revival_delay
+LOC: Adaptation::Icap::TheConfig.service_revival_delay
 DEFAULT: 180
 DOC_START
 	The delay specifies the number of seconds to wait after an ICAP
@@ -5193,7 +5193,7 @@ NAME: icap_preview_enable
 TYPE: onoff
 IFDEF: ICAP_CLIENT
 COMMENT: on|off
-LOC: TheICAPConfig.preview_enable
+LOC: Adaptation::Icap::TheConfig.preview_enable
 DEFAULT: on
 DOC_START
 	The ICAP Preview feature allows the ICAP server to handle the
@@ -5214,7 +5214,7 @@ DOC_END
 NAME: icap_preview_size
 TYPE: int
 IFDEF: ICAP_CLIENT
-LOC: TheICAPConfig.preview_size
+LOC: Adaptation::Icap::TheConfig.preview_size
 DEFAULT: -1
 DOC_START
 	The default size of preview data to be sent to the ICAP server.
@@ -5225,7 +5225,7 @@ DOC_END
 NAME: icap_default_options_ttl
 TYPE: int
 IFDEF: ICAP_CLIENT
-LOC: TheICAPConfig.default_options_ttl
+LOC: Adaptation::Icap::TheConfig.default_options_ttl
 DEFAULT: 60
 DOC_START
 	The default TTL value for ICAP OPTIONS responses that don't have
@@ -5236,7 +5236,7 @@ NAME: icap_persistent_connections
 TYPE: onoff
 IFDEF: ICAP_CLIENT
 COMMENT: on|off
-LOC: TheICAPConfig.reuse_connections
+LOC: Adaptation::Icap::TheConfig.reuse_connections
 DEFAULT: on
 DOC_START
 	Whether or not Squid should use persistent connections to
@@ -5247,7 +5247,7 @@ NAME: icap_send_client_ip
 TYPE: onoff
 IFDEF: ICAP_CLIENT
 COMMENT: on|off
-LOC: TheICAPConfig.send_client_ip
+LOC: Adaptation::Icap::TheConfig.send_client_ip
 DEFAULT: off
 DOC_START
 	This adds the header "X-Client-IP" to ICAP requests.
@@ -5257,7 +5257,7 @@ NAME: icap_send_client_username
 TYPE: onoff
 IFDEF: ICAP_CLIENT
 COMMENT: on|off
-LOC: TheICAPConfig.send_client_username
+LOC: Adaptation::Icap::TheConfig.send_client_username
 DEFAULT: off
 DOC_START
 	This sends authenticated HTTP client username (if available) to
@@ -5269,7 +5269,7 @@ DOC_END
 NAME: icap_client_username_header
 TYPE: string
 IFDEF: ICAP_CLIENT
-LOC: TheICAPConfig.client_username_header
+LOC: Adaptation::Icap::TheConfig.client_username_header
 DEFAULT: X-Client-Username
 DOC_START
 	ICAP request header name to use for send_client_username.
@@ -5279,7 +5279,7 @@ NAME: icap_client_username_encode
 TYPE: onoff
 IFDEF: ICAP_CLIENT
 COMMENT: on|off
-LOC: TheICAPConfig.client_username_encode
+LOC: Adaptation::Icap::TheConfig.client_username_encode
 DEFAULT: off
 DOC_START
 	Whether to base64 encode the authenticated client username.
@@ -5288,7 +5288,7 @@ DOC_END
 NAME: icap_service
 TYPE: icap_service_type
 IFDEF: ICAP_CLIENT
-LOC: TheICAPConfig
+LOC: Adaptation::Icap::TheConfig
 DEFAULT: none
 DOC_START
 	Defines a single ICAP service
@@ -1,30 +0,0 @@
-#  Makefile for the eCAP library
-#
-#  $Id$
-#
-
-AM_CFLAGS = @SQUID_CFLAGS@
-AM_CXXFLAGS = @SQUID_CXXFLAGS@
-
-noinst_LTLIBRARIES = libeCAP.la
-
-libeCAP_la_SOURCES = \
-	Config.h \
-	Config.cc \
-	Host.h \
-	Host.cc \
-	MessageRep.h \
-	MessageRep.cc \
-	ServiceRep.h \
-	ServiceRep.cc \
-	XactionRep.h \
-	XactionRep.cc \
-	\
-	Registry.h
-
-INCLUDES = \
-	-I$(top_srcdir) \
-	-I. \
-	-I$(top_builddir)/include \
-	-I$(top_srcdir)/include \
-        -I$(top_srcdir)/src
@@ -77,10 +77,10 @@
 #endif
 
 #if ICAP_CLIENT
-#include "ICAP/ICAPConfig.h"
+#include "adaptation/icap/Config.h"
 #endif
 #if USE_ECAP
-#include "eCAP/Config.h"
+#include "adaptation/ecap/Config.h"
 #endif
 #if USE_ADAPTATION
 #include "adaptation/Config.h"
@@ -1050,8 +1050,8 @@ mainInitialize(void)
     // We can remove this dependency on specific adaptation mechanisms
     // if we create a generic Registry of such mechanisms. Should we?
 #if ICAP_CLIENT
-    TheICAPConfig.finalize();
-    enableAdaptation = TheICAPConfig.onoff || enableAdaptation;
+    Adaptation::Icap::TheConfig.finalize();
+    enableAdaptation = Adaptation::Icap::TheConfig.onoff || enableAdaptation;
 #endif
 #if USE_ECAP
     Ecap::TheConfig.finalize(); // must be after we load modules