@@ -170,7 +170,7 @@ AC_DEFUN([SQUID_CC_GUESS_OPTIONS], [
    squid_cv_cc_arg_pipe=""
    ;;
   clang) 
-   squid_cv_cxx_option_werror="-Werror -Wno-error=parentheses-equality"
+   squid_cv_cxx_option_werror="-Werror -Wno-error=parentheses-equality -Qunused-arguments"
    squid_cv_cc_option_werror="$squid_cv_cxx_option_werror" 
    squid_cv_cc_option_wall="-Wall"
    squid_cv_cc_option_optimize="-O2"
@@ -252,27 +252,29 @@ AS_VAR_POPDEF([ac_Search])dnl
 
 dnl Check for Cyrus SASL
 AC_DEFUN([SQUID_CHECK_SASL],[
-  squid_sasl_present="auto"
+  squid_cv_check_sasl="auto"
   AC_CHECK_HEADERS([sasl/sasl.h sasl.h])
   AC_CHECK_LIB(sasl2,sasl_errstring,[LIBSASL="-lsasl2"],[
     AC_CHECK_LIB(sasl,sasl_errstring,[LIBSASL="-lsasl"], [
-      squid_sasl_present="no"
+      squid_cv_check_sasl="no"
     ])
   ])
   case "$squid_host_os" in
     Darwin)
       if test "$ac_cv_lib_sasl2_sasl_errstring" = "yes" ; then
         AC_DEFINE(HAVE_SASL_DARWIN,1,[Define to 1 if Mac Darwin without sasl.h])
         echo "checking for MAC Darwin without sasl.h ... yes"
-        squid_sasl_present="yes"
+        squid_cv_check_sasl="yes"
       else
         echo "checking for MAC Darwin without sasl.h ... no"
-        squid_sasl_present="no"
+        squid_cv_check_sasl="no"
       fi
       ;;
   esac
-  if test "x$squid_sasl_present" != "yes"; then
+  if test "x$squid_cv_check_sasl" = "xno"; then
     AC_MSG_WARN([Neither SASL nor SASL2 found])
+  else
+    squid_cv_check_sasl="yes"
   fi
   AC_SUBST(LIBSASL)
 ])
@@ -2202,7 +2202,6 @@ AC_CHECK_HEADERS( \
   shadow.h \
   regex.h \
   sched.h \
-  security/pam_appl.h \
   siginfo.h \
   signal.h \
   sstream \
@@ -2254,8 +2253,6 @@ AC_CHECK_HEADERS( \
   wchar.h
 )
 
-CHECK_STRUCT_PAM_CONV
-
 AC_CHECK_HEADERS(
   linux/netfilter_ipv4.h
 ,,,
@@ -115,7 +115,7 @@ Most user-facing changes are reflected in squid.conf (see below).
    resources and de-duplicate the cache content. <em>store_id_access</em> is provided to
    allow ACL-based tuning of which traffic gets sent to the helper and reduce overheads.
 
-<p>Once subtle and noteworthy difference between Squid-2 and Squid-3 which is highlighted by
+<p>One subtle and noteworthy difference between Squid-2 and Squid-3 which is highlighted by
    this feature is that <em>refresh_pattern</em> applies its regex argument against the Store
    ID key and not the transaction URL. So using the Store-ID feature to alter the value
    affects which <em>refresh_pattern</em> directive will be matched.
@@ -1141,7 +1141,7 @@ msgid ""
 "revalidation prohibited by the <q>only-if-cached</q> directive."
 msgstr ""
 "Դուք իրականացրեցիք հարցում <q>only-if-cached</q> քեշի կառավարման դիրեկտիվով: "
-"Փաստաթուղթը քեշում բացակայում է <em>կամ</em պահանջվում է <q>only-if-cached</"
+"Փաստաթուղթը քեշում բացակայում է <em>կամ</em> պահանջվում է <q>only-if-cached</"
 "q> դիրեկտիվի կողմից արգելված հաստատում:"
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.blockquote.p:21
@@ -1 +1,4 @@
-AC_CHECK_HEADERS([security/pam_appl.h],[BUILD_HELPER="PAM"])
+AC_CHECK_HEADERS([security/pam_appl.h],[
+  BUILD_HELPER="PAM"
+  CHECK_STRUCT_PAM_CONV
+])
@@ -1,6 +1,6 @@
 SQUID_CHECK_SASL
 
 # on success, add to the built modules list
-if test "x$squid_check_sasl" = "xyes"; then
+if test "x$squid_cv_check_sasl" = "xyes"; then
   BUILD_HELPER="SASL"
 fi
@@ -49,6 +49,9 @@ if test "x$enable_auth_basic" != "xno" ; then
       elif test "x$helper" = "xNIS" ; then
         m4_include([helpers/basic_auth/NIS/required.m4])
 
+      elif test "x$helper" = "xPAM" ; then
+        m4_include([helpers/basic_auth/PAM/required.m4])
+
       elif test "x$helper" = "xPOP3" ; then
         m4_include([helpers/basic_auth/POP3/required.m4])
 
@@ -80,7 +80,7 @@ =head1 COPYRIGHT
     } else {
         my $readlen = length($body);
         my %certs = ();
-        my @errors = ();
+        my %errors = ();
         my @responseErrors = ();
 
         while($readlen < $bodylen) {
@@ -93,12 +93,12 @@ =head1 COPYRIGHT
 
         print(STDERR logPrefix()."GOT ". "Code=".$code." $bodylen \n") if ($debug); #.$body;
         my $hostname;
-        parseRequest($body, \$hostname, \@errors, \%certs);
+        parseRequest($body, \$hostname, \%errors, \%certs);
         print(STDERR logPrefix()."Parse result: \n") if ($debug);
         print(STDERR logPrefix()."\tFOUND host:".$hostname."\n") if ($debug);
         print(STDERR logPrefix()."\tFOUND ERRORS:") if ($debug);
-        foreach my $err (@errors) {
-            print(STDERR logPrefix()."$err ,")  if ($debug);
+        foreach my $err (keys %errors) {
+            print(STDERR logPrefix().$errors{$err}{"name"}."/".$errors{$err}{"cert"}." ,")  if ($debug);
         }
         print(STDERR "\n") if ($debug);
         foreach my $key (keys %certs) {
@@ -110,12 +110,12 @@ =head1 COPYRIGHT
         my $peerCertId = (keys %certs)[0];
 
         # Echo back the errors: fill the responseErrors array  with the errors we read.
-        foreach my $err (@errors) {
+        foreach my $err (keys %errors) {
             $haserror = 1;
             appendError (\@responseErrors, 
-                         $err, #The error name
+                         $errors{$err}{"name"}, #The error name
                          "Checked by Cert Validator", # An error reason
-                         $peerCertId # The cert ID. We are always filling with the peer certificate.
+                         $errors{$err}{"cert"} # The cert ID. We are always filling with the peer certificate.
                 );
         }
 
@@ -175,21 +175,27 @@ sub parseRequest
             my($vallen) = index($request, "\n");
             my $host = substr($request, 5, $vallen - 5);
             $$hostname = $host;
-            $request =~ s/^host=.*\n//;
+            $request =~ s/^host=.*$//m;
         }
-        if ($request =~ /^errors=/) {
-            my($vallen) = index($request, "\n");
-            my $listerrors = substr($request, 7, $vallen - 7);
-            @$errors = split /,/, $listerrors;
-            $request =~ s/^errors=.*\n//;
-        }
-        elsif ($request =~ /^cert_(\d+)=/) {
+        if ($request =~ /^cert_(\d+)=/) {
             my $certId = "cert_".$1;
             my($vallen) = index($request, "-----END CERTIFICATE-----") + length("-----END CERTIFICATE-----");
             my $x509 = Crypt::OpenSSL::X509->new_from_string(substr($request, index($request, "-----BEGIN")));
             $certs->{$certId} = $x509;
             $request = substr($request, $vallen);
         }
+        elsif ($request =~ /^error_name_(\d+)=(.*)$/m) {
+            my $errorId = $1;
+            my $errorName = $2;
+            $request =~ s/^error_name_\d+=.*$//m;
+            $errors->{$errorId}{"name"} = $errorName;
+        }
+        elsif ($request =~ /^error_cert_(\d+)=(.*)$/m) {
+            my $errorId = $1;
+            my $certId = $2;
+            $request =~ s/^error_cert_\d+=.*$//m;
+            $errors->{$errorId}{"cert"} = $certId;
+        }
         else {
             print(STDERR logPrefix()."ParseError on \"".$request."\"\n") if ($debug);
             $request = "";# finish processing....
@@ -85,6 +85,15 @@ for FILENAME in `ls -1`; do
 		;;
 	esac
 
+	#
+	# forward.h means different things to Squid code depending on the path
+	# require the full path is explicit for every include
+	#
+	FI=`grep "#include \"forward.h\"" ${FILENAME}`;
+	if test "x${FI}" != "x" ; then
+		echo "ERROR: ${PWD}/${FILENAME} contains reference to forward.h without path"
+	fi
+
 	#
 	# DEBUG Section list maintenance
 	#
@@ -690,8 +690,8 @@ parse_objectid(FILE *fp, char *name) {
          */
         if (count == (length - 2)) {
             if (op->label) {
-                strncpy(np->parent, op->label, sizeof(np->parent));
-                strncpy(np->label, name, sizeof(np->label));
+                strncpy(np->parent, op->label, sizeof(np->parent)-1);
+                strncpy(np->label, name, sizeof(np->label)-1);
                 if (nop->subid != -1)
                     np->subid = nop->subid;
                 else
@@ -17,15 +17,15 @@ AccessLogEntry::getLogClientIp(char *buf, size_t bufsz) const
 {
 #if FOLLOW_X_FORWARDED_FOR
     if (Config.onoff.log_uses_indirect_client && request)
-        request->indirect_client_addr.NtoA(buf, bufsz);
+        request->indirect_client_addr.toStr(buf, bufsz);
     else
 #endif
         if (tcpClient != NULL)
-            tcpClient->remote.NtoA(buf, bufsz);
-        else if (cache.caddr.IsNoAddr()) // e.g., ICAP OPTIONS lack client
+            tcpClient->remote.toStr(buf, bufsz);
+        else if (cache.caddr.isNoAddr()) // e.g., ICAP OPTIONS lack client
             strncpy(buf, "-", bufsz);
         else
-            cache.caddr.NtoA(buf, bufsz);
+            cache.caddr.toStr(buf, bufsz);
 }
 
 AccessLogEntry::~AccessLogEntry()
@@ -149,7 +149,7 @@ ACLStrategised<int> ACLUrlPort::RegistryEntry_(new ACLIntRange, ACLUrlPortStrate
 
 #if USE_SSL
 ACL::Prototype ACLSslError::RegistryProtoype(&ACLSslError::RegistryEntry_, "ssl_error");
-ACLStrategised<const Ssl::Errors *> ACLSslError::RegistryEntry_(new ACLSslErrorData, ACLSslErrorStrategy::Instance(), "ssl_error");
+ACLStrategised<const Ssl::CertErrors *> ACLSslError::RegistryEntry_(new ACLSslErrorData, ACLSslErrorStrategy::Instance(), "ssl_error");
 ACL::Prototype ACLCertificate::UserRegistryProtoype(&ACLCertificate::UserRegistryEntry_, "user_cert");
 ACLStrategised<X509 *> ACLCertificate::UserRegistryEntry_(new ACLCertificateData (Ssl::GetX509UserAttribute, "*"), ACLCertificateStrategy::Instance(), "user_cert");
 ACL::Prototype ACLCertificate::CARegistryProtoype(&ACLCertificate::CARegistryEntry_, "ca_cert");
@@ -97,7 +97,7 @@ DelayId::DelayClient(ClientHttpRequest * http)
     assert(http);
     r = http->request;
 
-    if (r->client_addr.IsNoAddr()) {
+    if (r->client_addr.isNoAddr()) {
         debugs(77, 2, "delayClient: WARNING: Called with 'NO_ADDR' address, ignoring");
         return DelayId();
     }
@@ -195,7 +195,7 @@ DiskdIOStrategy::init()
     args[2] = skey2;
     args[3] = skey3;
     args[4] = NULL;
-    localhost.SetLocalhost();
+    localhost.setLocalhost();
     pid = ipcCreate(IPC_STREAM,
                     Config.Program.diskd,
                     args,
@@ -47,8 +47,8 @@
 #include "event.h"
 #include "fd.h"
 #include "fde.h"
-#include "forward.h"
 #include "ftp.h"
+#include "FwdState.h"
 #include "globals.h"
 #include "gopher.h"
 #include "hier_code.h"
@@ -296,7 +296,7 @@ FwdState::Start(const Comm::ConnectionPointer &clientConn, StoreEntry *entry, Ht
      * be allowed.  yuck, I know.
      */
 
-    if ( Config.accessList.miss && !request->client_addr.IsNoAddr() &&
+    if ( Config.accessList.miss && !request->client_addr.isNoAddr() &&
             request->protocol != AnyP::PROTO_INTERNAL && request->protocol != AnyP::PROTO_CACHE_OBJECT) {
         /**
          * Check if this host is allowed to fetch MISSES from us (miss_access).
@@ -710,7 +710,7 @@ FwdState::negotiateSSL(int fd)
                     serverBump->serverCert.resetAndLock(errDetails->peerCert());
 
                     // remember validation errors, if any
-                    if (Ssl::Errors *errs = static_cast<Ssl::Errors*>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors)))
+                    if (Ssl::CertErrors *errs = static_cast<Ssl::CertErrors*>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors)))
                         serverBump->sslErrors = cbdataReference(errs);
                 }
             }
@@ -748,7 +748,7 @@ FwdState::negotiateSSL(int fd)
             serverBump->serverCert.reset(SSL_get_peer_certificate(ssl));
 
             // remember validation errors, if any
-            if (Ssl::Errors *errs = static_cast<Ssl::Errors *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors)))
+            if (Ssl::CertErrors *errs = static_cast<Ssl::CertErrors *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors)))
                 serverBump->sslErrors = cbdataReference(errs);
         }
     }
@@ -768,7 +768,7 @@ FwdState::negotiateSSL(int fd)
         // Ssl::CertValidationHelper::submit method.
         validationRequest.ssl = ssl;
         validationRequest.domainName = request->GetHost();
-        if (Ssl::Errors *errs = static_cast<Ssl::Errors *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors)))
+        if (Ssl::CertErrors *errs = static_cast<Ssl::CertErrors *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors)))
             // validationRequest disappears on return so no need to cbdataReference
             validationRequest.errors = errs;
         else
@@ -807,7 +807,7 @@ FwdState::sslCrtvdHandleReplyWrapper(void *data, Ssl::CertValidationResponse con
 void
 FwdState::sslCrtvdHandleReply(Ssl::CertValidationResponse const &validationResponse)
 {
-    Ssl::Errors *errs = NULL;
+    Ssl::CertErrors *errs = NULL;
     Ssl::ErrorDetail *errDetails = NULL;
     bool validatorFailed = false;
     if (!Comm::IsConnOpen(serverConnection())) {
@@ -860,11 +860,11 @@ FwdState::sslCrtvdHandleReply(Ssl::CertValidationResponse const &validationRespo
 
 /// Checks errors in the cert. validator response against sslproxy_cert_error.
 /// The first honored error, if any, is returned via errDetails parameter.
-/// The method returns all seen errors except SSL_ERROR_NONE as Ssl::Errors.
-Ssl::Errors *
+/// The method returns all seen errors except SSL_ERROR_NONE as Ssl::CertErrors.
+Ssl::CertErrors *
 FwdState::sslCrtvdCheckForErrors(Ssl::CertValidationResponse const &resp, Ssl::ErrorDetail *& errDetails)
 {
-    Ssl::Errors *errs = NULL;
+    Ssl::CertErrors *errs = NULL;
 
     ACLFilledChecklist *check = NULL;
     if (acl_access *acl = Config.ssl_client.cert_error)
@@ -880,7 +880,7 @@ FwdState::sslCrtvdCheckForErrors(Ssl::CertValidationResponse const &resp, Ssl::E
         if (!errDetails) {
             bool allowed = false;
             if (check) {
-                check->sslErrors = new Ssl::Errors(i->error_no);
+                check->sslErrors = new Ssl::CertErrors(Ssl::CertError(i->error_no, i->cert.get()));
                 if (check->fastCheck() == ACCESS_ALLOWED)
                     allowed = true;
             }
@@ -903,9 +903,9 @@ FwdState::sslCrtvdCheckForErrors(Ssl::CertValidationResponse const &resp, Ssl::E
         }
 
         if (!errs)
-            errs = new Ssl::Errors(i->error_no);
+            errs = new Ssl::CertErrors(Ssl::CertError(i->error_no, i->cert.get()));
         else
-            errs->push_back_unique(i->error_no);
+            errs->push_back_unique(Ssl::CertError(i->error_no, i->cert.get()));
     }
     if (check)
         delete check;
@@ -1181,7 +1181,7 @@ FwdState::connectStart()
     // We will try to open a new connection, possibly to the same destination.
     // We reset serverDestinations[0] in case we are using it again because
     // ConnOpener modifies its destination argument.
-    serverDestinations[0]->local.SetPort(0);
+    serverDestinations[0]->local.port(0);
     serverConn = NULL;
 
 #if URL_CHECKSUM_DEBUG
@@ -1520,11 +1520,11 @@ void
 getOutgoingAddress(HttpRequest * request, Comm::ConnectionPointer conn)
 {
     // skip if an outgoing address is already set.
-    if (!conn->local.IsAnyAddr()) return;
+    if (!conn->local.isAnyAddr()) return;
 
     // ensure that at minimum the wildcard local matches remote protocol
-    if (conn->remote.IsIPv4())
-        conn->local.SetIPv4();
+    if (conn->remote.isIPv4())
+        conn->local.setIPv4();
 
     // maybe use TPROXY client address
     if (request && request->flags.spoofClientIp) {
@@ -1558,7 +1558,7 @@ getOutgoingAddress(HttpRequest * request, Comm::ConnectionPointer conn)
     for (l = Config.accessList.outgoing_address; l; l = l->next) {
 
         /* check if the outgoing address is usable to the destination */
-        if (conn->remote.IsIPv4() != l->addr.IsIPv4()) continue;
+        if (conn->remote.isIPv4() != l->addr.isIPv4()) continue;
 
         /* check ACLs for this outgoing address */
         if (!l->aclList || ch.fastCheck(l->aclList) == ACCESS_ALLOWED) {
@@ -90,7 +90,7 @@ class FwdState : public RefCountable
     /// Process response from cert validator helper
     void sslCrtvdHandleReply(Ssl::CertValidationResponse const &);
     /// Check SSL errors returned from cert validator against sslproxy_cert_error access list
-    Ssl::Errors *sslCrtvdCheckForErrors(Ssl::CertValidationResponse const &, Ssl::ErrorDetail *&);
+    Ssl::CertErrors *sslCrtvdCheckForErrors(Ssl::CertValidationResponse const &, Ssl::ErrorDetail *&);
 #endif
 private:
     // hidden for safer management of self; use static fwdStart
@@ -105,8 +105,8 @@ HttpRequest::init()
     ims = -1;
     imslen = 0;
     lastmod = -1;
-    client_addr.SetEmpty();
-    my_addr.SetEmpty();
+    client_addr.setEmpty();
+    my_addr.setEmpty();
     body_pipe = NULL;
     // hier
     dnsWait = -1;
@@ -126,7 +126,7 @@ HttpRequest::init()
     extacl_message = null_string;
     pstate = psReadyToParseStartLine;
 #if FOLLOW_X_FORWARDED_FOR
-    indirect_client_addr.SetEmpty();
+    indirect_client_addr.setEmpty();
 #endif /* FOLLOW_X_FORWARDED_FOR */
 #if USE_ADAPTATION
     adaptHistory_ = NULL;
@@ -93,13 +93,13 @@ class HttpRequest: public HttpMsg
     /*      caused by HttpRequest being used in places it really shouldn't.        */
     /*      ideally they would be methods of URL instead. */
     inline void SetHost(const char *src) {
-        host_addr.SetEmpty();
+        host_addr.setEmpty();
         host_addr = src;
-        if ( host_addr.IsAnyAddr() ) {
+        if (host_addr.isAnyAddr()) {
             xstrncpy(host, src, SQUIDHOSTNAMELEN);
             host_is_numeric = 0;
         } else {
-            host_addr.ToHostname(host, SQUIDHOSTNAMELEN);
+            host_addr.toHostStr(host, SQUIDHOSTNAMELEN);
             debugs(23, 3, "HttpRequest::SetHost() given IP: " << host_addr);
             host_is_numeric = 1;
         }
@@ -354,12 +354,12 @@ squid_SOURCES = \
 	fde.h \
 	FileMap.h \
 	filemap.cc \
-	forward.cc \
-	forward.h \
 	fqdncache.h \
 	fqdncache.cc \
 	ftp.h \
 	ftp.cc \
+	FwdState.cc \
+	FwdState.h \
 	Generic.h \
 	globals.h \
 	gopher.h \
@@ -1450,11 +1450,12 @@ tests_testCacheManager_SOURCES = \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
-	forward.cc \
 	fqdncache.h \
 	fqdncache.cc \
 	ftp.h \
 	ftp.cc \
+	FwdState.cc \
+	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	hier_code.h \
@@ -1860,11 +1861,12 @@ tests_testEvent_SOURCES = \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
-	forward.cc \
 	fqdncache.h \
 	fqdncache.cc \
 	ftp.h \
 	ftp.cc \
+	FwdState.cc \
+	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
@@ -2107,11 +2109,12 @@ tests_testEventLoop_SOURCES = \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
-	forward.cc \
 	fqdncache.h \
 	fqdncache.cc \
 	ftp.h \
 	ftp.cc \
+	FwdState.cc \
+	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
@@ -2351,11 +2354,12 @@ tests_test_http_range_SOURCES = \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
-	forward.cc \
 	fqdncache.h \
 	fqdncache.cc \
 	ftp.h \
 	ftp.cc \
+	FwdState.cc \
+	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
@@ -2646,11 +2650,12 @@ tests_testHttpRequest_SOURCES = \
 	fd.h \
 	fd.cc \
 	fde.cc \
-	forward.cc \
 	fqdncache.h \
 	fqdncache.cc \
 	ftp.h \
 	ftp.cc \
+	FwdState.cc \
+	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
@@ -3607,11 +3612,12 @@ tests_testURL_SOURCES = \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
-	forward.cc \
 	fqdncache.h \
 	fqdncache.cc \
 	ftp.h \
 	ftp.cc \
+	FwdState.cc \
+	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
@@ -302,14 +302,14 @@ GetHostWithPort(char *token, Ip::Address *ipa)
     }
 
     if (NULL == host)
-        ipa->SetAnyAddr();
+        ipa->setAnyAddr();
     else if ( ipa->GetHostByName(host) ) /* dont use ipcache. Accept either FQDN or IPA. */
         (void) 0;
     else
         return false;
 
     /* port MUST be set after the IPA lookup/conversion is performed. */
-    ipa->SetPort(port);
+    ipa->port(port);
 
     return true;
 }
@@ -32,11 +32,11 @@
 #ifndef SQUID_SERVER_H
 #define SQUID_SERVER_H
 
-#include "StoreIOBuffer.h"
-#include "forward.h"
 #include "BodyPipe.h"
 #include "base/AsyncJob.h"
 #include "CommCalls.h"
+#include "FwdState.h"
+#include "StoreIOBuffer.h"
 #if USE_ADAPTATION
 #include "adaptation/forward.h"
 #include "adaptation/Initiator.h"
@@ -161,7 +161,7 @@ ACLARP::match(ACLChecklist *cl)
     ACLFilledChecklist *checklist = Filled(cl);
 
     /* IPv6 does not do ARP */
-    if (!checklist->src_addr.IsIPv4()) {
+    if (!checklist->src_addr.isIPv4()) {
         debugs(14, 3, "ACLARP::match: IPv4 Required for ARP Lookups. Skipping " << checklist->src_addr );
         return 0;
     }
@@ -39,7 +39,7 @@
 #include "acl/DestinationIp.h"
 #include "acl/SourceAsn.h"
 #include "cache_cf.h"
-#include "src/forward.h"
+#include "FwdState.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "ipcache.h"
@@ -149,10 +149,10 @@ asnMatchIp(CbDataList<int> *data, Ip::Address &addr)
     if (AS_tree_head == NULL)
         return 0;
 
-    if (addr.IsNoAddr())
+    if (addr.isNoAddr())
         return 0;
 
-    if (addr.IsAnyAddr())
+    if (addr.isAnyAddr())
         return 0;
 
     m_addr.addr = addr;
@@ -422,8 +422,8 @@ asnAddNet(char *as_string, int as_number)
     t = strchr(as_string, '.');
 
     // generate Netbits Format Mask
-    mask.SetNoAddr();
-    mask.ApplyMask(bitl, (t!=NULL?AF_INET:AF_INET6) );
+    mask.setNoAddr();
+    mask.applyMask(bitl, (t!=NULL?AF_INET:AF_INET6) );
 
     debugs(53, 3, "asnAddNet: called for " << addr << "/" << mask );
 
@@ -522,8 +522,8 @@ printRadixNode(struct squid_radix_node *rn, void *_sentry)
     addr = e->e_addr.addr;
     mask = e->e_mask.addr;
     storeAppendPrintf(sentry, "%s/%d\t",
-                      addr.NtoA(buf, MAX_IPSTRLEN),
-                      mask.GetCIDR() );
+                      addr.toStr(buf, MAX_IPSTRLEN),
+                      mask.cidr() );
     asinfo = e->e_info;
     assert(asinfo->as_number);
 
@@ -642,7 +642,7 @@ ACLDestinationASNStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist
         // else fall through to noaddr match, hiding the lookup failure (XXX)
     }
     Ip::Address noaddr;
-    noaddr.SetNoAddr();
+    noaddr.setNoAddr();
     return data->match(noaddr);
 }
 
@@ -60,6 +60,11 @@ void
 ACLChecklist::preCheck(const char *what)
 {
     debugs(28, 3, HERE << this << " checking " << what);
+
+    // concurrent checks using the same Checklist are not supported
+    assert(!occupied_);
+    occupied_ = true;
+
     AclMatchedName = NULL;
     finished_ = false;
 }
@@ -148,6 +153,9 @@ ACLChecklist::checkCallback(allow_t answer)
     if (cbdataReferenceValidDone(callback_data, &cbdata_))
         callback_(answer, cbdata_);
 
+    // not really meaningful just before delete, but here for completeness sake
+    occupied_ = false;
+
     delete this;
 }
 
@@ -156,6 +164,7 @@ ACLChecklist::ACLChecklist() :
         callback (NULL),
         callback_data (NULL),
         asyncCaller_(false),
+        occupied_(false),
         finished_(false),
         allow_(ACCESS_DENIED),
         asyncStage_(asyncNone),
@@ -287,10 +296,10 @@ ACLChecklist::fastCheck(const Acl::Tree * list)
     preCheck("fast ACLs");
     asyncCaller_ = false;
 
-    // This call is not compatible with a pre-set accessList because we cannot
-    // tell whether this Checklist is used by some other concurent call, which
-    // is not supported.
-    assert(!accessList);
+    // Concurrent checks are not supported, but sequential checks are, and they
+    // may use a mixture of fastCheck(void) and fastCheck(list) calls.
+    const Acl::Tree * const savedList = accessList;
+
     accessList = cbdataReference(list);
 
     // assume DENY/ALLOW on mis/matches due to action-free accessList
@@ -301,6 +310,8 @@ ACLChecklist::fastCheck(const Acl::Tree * list)
         markFinished(ACCESS_DENIED, "ACLs failed to match");
 
     cbdataReferenceDone(accessList);
+    accessList = savedList;
+    occupied_ = false;
     PROF_stop(aclCheckFast);
     return currentAnswer();
 }
@@ -324,6 +335,7 @@ ACLChecklist::fastCheck()
         // if finished (on a match or in exceptional cases), stop
         if (finished()) {
             cbdataReferenceDone(acl);
+            occupied_ = false;
             PROF_stop(aclCheckFast);
             return currentAnswer();
         }
@@ -334,6 +346,7 @@ ACLChecklist::fastCheck()
     // There were no rules to match or no rules matched
     calcImplicitAnswer();
     cbdataReferenceDone(acl);
+    occupied_ = false;
     PROF_stop(aclCheckFast);
 
     return currentAnswer();
@@ -224,6 +224,7 @@ class ACLChecklist
     void calcImplicitAnswer();
 
     bool asyncCaller_; ///< whether the caller supports async/slow ACLs
+    bool occupied_; ///< whether a check (fast or non-blocking) is in progress
     bool finished_;
     allow_t allow_;
 
@@ -135,7 +135,7 @@ ACLEui64::match(ACLChecklist *cl)
     ACLFilledChecklist *checklist = Filled(cl);
 
     /* IPv4 does not do EUI-64 (yet) */
-    if (!checklist->src_addr.IsIPv6()) {
+    if (!checklist->src_addr.isIPv6()) {
         debugs(14, 3, "ACLEui64::match: IPv6 Required for EUI-64 Lookups. Skipping " << checklist->src_addr );
         return 0;
     }
@@ -33,9 +33,9 @@ ACLFilledChecklist::ACLFilledChecklist() :
         destinationDomainChecked_(false),
         sourceDomainChecked_(false)
 {
-    my_addr.SetEmpty();
-    src_addr.SetEmpty();
-    dst_addr.SetEmpty();
+    my_addr.setEmpty();
+    src_addr.setEmpty();
+    dst_addr.setEmpty();
     rfc931[0] = '\0';
 }
 
@@ -149,9 +149,9 @@ ACLFilledChecklist::ACLFilledChecklist(const acl_access *A, HttpRequest *http_re
         destinationDomainChecked_(false),
         sourceDomainChecked_(false)
 {
-    my_addr.SetEmpty();
-    src_addr.SetEmpty();
-    dst_addr.SetEmpty();
+    my_addr.setEmpty();
+    src_addr.setEmpty();
+    dst_addr.setEmpty();
     rfc931[0] = '\0';
 
     // cbdataReferenceDone() is in either fastCheck() or the destructor
@@ -70,7 +70,7 @@ class ACLFilledChecklist: public ACLChecklist
 
 #if USE_SSL
     /// SSL [certificate validation] errors, in undefined order
-    Ssl::Errors *sslErrors;
+    Ssl::CertErrors *sslErrors;
     /// The peer certificate
     Ssl::X509_Pointer serverCert;
 #endif
@@ -92,24 +92,24 @@ acl_ip_data::toStr(char *buf, int len) const
     char *b3 = NULL;
     int rlen = 0;
 
-    addr1.NtoA(b1, len - rlen );
+    addr1.toStr(b1, len - rlen );
     rlen = strlen(buf);
     b2 = buf + rlen;
 
-    if (!addr2.IsAnyAddr()) {
+    if (!addr2.isAnyAddr()) {
         b2[0] = '-';
         ++rlen;
-        addr2.NtoA(&(b2[1]), len - rlen );
+        addr2.toStr(&(b2[1]), len - rlen );
         rlen = strlen(buf);
     } else
         b2[0] = '\0';
 
     b3 = buf + rlen;
 
-    if (!mask.IsNoAddr()) {
+    if (!mask.isNoAddr()) {
         b3[0] = '/';
         ++rlen;
-        int cidr =  mask.GetCIDR() - (addr1.IsIPv4()?96:0);
+        int cidr =  mask.cidr() - (addr1.isIPv4()?96:0);
         snprintf(&(b3[1]), (len-rlen), "%u", (unsigned int)(cidr<0?0:cidr) );
     } else
         b3[0] = '\0';
@@ -128,12 +128,12 @@ aclIpAddrNetworkCompare(acl_ip_data * const &p, acl_ip_data * const &q)
     Ip::Address A = p->addr1;
 
     /* apply netmask */
-    A.ApplyMask(q->mask);
+    A.applyMask(q->mask);
 
     debugs(28,9, "aclIpAddrNetworkCompare: compare: " << p->addr1 << "/" << q->mask << " (" << A << ")  vs " <<
            q->addr1 << "-" << q->addr2 << "/" << q->mask);
 
-    if (q->addr2.IsAnyAddr()) {       /* single address check */
+    if (q->addr2.isAnyAddr()) {       /* single address check */
 
         return A.matchIPAddr( q->addr1 );
 
@@ -197,7 +197,7 @@ acl_ip_data::DecodeMask(const char *asc, Ip::Address &mask, int ctype)
     int a1 = 0;
 
     /* default is a mask that doesn't change any IP */
-    mask.SetNoAddr();
+    mask.setNoAddr();
 
     if (!asc || !*asc) {
         return true;
@@ -207,24 +207,24 @@ acl_ip_data::DecodeMask(const char *asc, Ip::Address &mask, int ctype)
     if ((sscanf(asc, "%d%c", &a1, &junk)==1) &&
             (a1 <= 128) && (a1  >= 0)
        ) {
-        return mask.ApplyMask(a1, ctype);
+        return mask.applyMask(a1, ctype);
     }
 
     /* dotted notation */
     /* assignment returns true if asc contained an IP address as text */
     if ((mask = asc)) {
         /* HACK: IPv4 netmasks don't cleanly map to IPv6 masks. */
         debugs(28, DBG_CRITICAL, "WARNING: Netmasks are deprecated. Please use CIDR masks instead.");
-        if (mask.IsIPv4()) {
+        if (mask.isIPv4()) {
             /* locate what CIDR mask was _probably_ meant to be in its native protocol format. */
             /* this will completely crap out with a security fail-open if the admin is playing mask tricks */
             /* however, thats their fault, and we do warn. see bug 2601 for the effects if we don't do this. */
-            unsigned int m = mask.GetCIDR();
+            unsigned int m = mask.cidr();
             debugs(28, DBG_CRITICAL, "WARNING: IPv4 netmasks are particularly nasty when used to compare IPv6 to IPv4 ranges.");
             debugs(28, DBG_CRITICAL, "WARNING: For now we will assume you meant to write /" << m);
             /* reset the mask completely, and crop to the CIDR boundary back properly. */
-            mask.SetNoAddr();
-            return mask.ApplyMask(m,AF_INET);
+            mask.setNoAddr();
+            return mask.applyMask(m,AF_INET);
         }
         return true;
     }
@@ -262,9 +262,9 @@ acl_ip_data::FactoryParse(const char *t)
     /* Special ACL RHS "all" matches entire Internet */
     if (strcmp(t, "all") == 0) {
         debugs(28, 9, "aclIpParseIpData: magic 'all' found.");
-        q->addr1.SetAnyAddr();
-        q->addr2.SetEmpty();
-        q->mask.SetAnyAddr();
+        q->addr1.setAnyAddr();
+        q->addr2.setEmpty();
+        q->mask.setAnyAddr();
         return q;
     }
 
@@ -275,18 +275,18 @@ acl_ip_data::FactoryParse(const char *t)
 
         debugs(28,DBG_CRITICAL, "ERROR: '" << t << "' needs to be replaced by the term 'all'.");
         debugs(28,DBG_CRITICAL, "SECURITY NOTICE: Overriding config setting. Using 'all' instead.");
-        q->addr1.SetAnyAddr();
-        q->addr2.SetEmpty();
-        q->mask.SetAnyAddr();
+        q->addr1.setAnyAddr();
+        q->addr2.setEmpty();
+        q->mask.setAnyAddr();
         return q;
     }
 
     /* Special ACL RHS "ipv4" matches IPv4 Internet
      * A nod to IANA; we include the entire class space in case
      * they manage to find a way to recover and use it */
     if (strcmp(t, "ipv4") == 0) {
-        q->mask.SetNoAddr();
-        q->mask.ApplyMask(0, AF_INET);
+        q->mask.setNoAddr();
+        q->mask.applyMask(0, AF_INET);
         return q;
     }
 
@@ -299,59 +299,59 @@ acl_ip_data::FactoryParse(const char *t)
 
         /* Future global unicast space: 1000::/4 */
         q->addr1 = "1000::";
-        q->mask.SetNoAddr();
-        q->mask.ApplyMask(4, AF_INET6);
+        q->mask.setNoAddr();
+        q->mask.applyMask(4, AF_INET6);
 
         /* Current global unicast space: 2000::/4 = (2000::/4 - 3000::/4) */
         q->next = new acl_ip_data;
         q = q->next;
         q->addr1 = "2000::";
-        q->mask.SetNoAddr();
-        q->mask.ApplyMask(3, AF_INET6);
+        q->mask.setNoAddr();
+        q->mask.applyMask(3, AF_INET6);
 
         /* Future global unicast space: 4000::/2 = (4000::/4 - 7000::/4) */
         q->next = new acl_ip_data;
         q = q->next;
         q->addr1 = "4000::";
-        q->mask.SetNoAddr();
-        q->mask.ApplyMask(2, AF_INET6);
+        q->mask.setNoAddr();
+        q->mask.applyMask(2, AF_INET6);
 
         /* Future global unicast space: 8000::/2 = (8000::/4 - B000::/4) */
         q->next = new acl_ip_data;
         q = q->next;
         q->addr1 = "8000::";
-        q->mask.SetNoAddr();
-        q->mask.ApplyMask(2, AF_INET6);
+        q->mask.setNoAddr();
+        q->mask.applyMask(2, AF_INET6);
 
         /* Future global unicast space: C000::/3 = (C000::/4 - D000::/4) */
         q->next = new acl_ip_data;
         q = q->next;
         q->addr1 = "C000::";
-        q->mask.SetNoAddr();
-        q->mask.ApplyMask(3, AF_INET6);
+        q->mask.setNoAddr();
+        q->mask.applyMask(3, AF_INET6);
 
         /* Future global unicast space: E000::/4 */
         q->next = new acl_ip_data;
         q = q->next;
         q->addr1 = "E000::";
-        q->mask.SetNoAddr();
-        q->mask.ApplyMask(4, AF_INET6);
+        q->mask.setNoAddr();
+        q->mask.applyMask(4, AF_INET6);
 
         /* F000::/4 is mostly reserved non-unicast. With some exceptions ... */
 
         /* RFC 4193 Unique-Local unicast space: FC00::/7 */
         q->next = new acl_ip_data;
         q = q->next;
         q->addr1 = "FC00::";
-        q->mask.SetNoAddr();
-        q->mask.ApplyMask(7, AF_INET6);
+        q->mask.setNoAddr();
+        q->mask.applyMask(7, AF_INET6);
 
         /* Link-Local unicast space: FE80::/10 */
         q->next = new acl_ip_data;
         q = q->next;
         q->addr1 = "FE80::";
-        q->mask.SetNoAddr();
-        q->mask.ApplyMask(10, AF_INET6);
+        q->mask.setNoAddr();
+        q->mask.applyMask(10, AF_INET6);
 
         return r;
     }
@@ -438,8 +438,8 @@ acl_ip_data::FactoryParse(const char *t)
 
             debugs(28, 3, "aclIpParseIpData: Located host/IP: '" << r->addr1 << "'");
 
-            r->addr2.SetAnyAddr();
-            r->mask.SetNoAddr();
+            r->addr2.setAnyAddr();
+            r->mask.setNoAddr();
 
             Q = &r->next;
 
@@ -474,7 +474,7 @@ acl_ip_data::FactoryParse(const char *t)
 
     /* Decode addr2 */
     if (!*addr2)
-        q->addr2.SetAnyAddr();
+        q->addr2.setAnyAddr();
     else if (!(q->addr2=addr2) ) {
         debugs(28, DBG_CRITICAL, "aclIpParseIpData: unknown second address in '" << t << "'");
         delete q;
@@ -491,13 +491,13 @@ acl_ip_data::FactoryParse(const char *t)
     }
 
     changed = 0;
-    changed += q->addr1.ApplyMask(q->mask);
-    changed += q->addr2.ApplyMask(q->mask);
+    changed += q->addr1.applyMask(q->mask);
+    changed += q->addr2.applyMask(q->mask);
 
     if (changed)
         debugs(28, DBG_CRITICAL, "aclIpParseIpData: WARNING: Netmask masks away part of the specified IP in '" << t << "'");
 
-    debugs(28,9, HERE << "Parsed: " << q->addr1 << "-" << q->addr2 << "/" << q->mask << "(/" << q->mask.GetCIDR() <<")");
+    debugs(28,9, HERE << "Parsed: " << q->addr1 << "-" << q->addr2 << "/" << q->mask << "(/" << q->mask.cidr() <<")");
 
     /* 1.2.3.4/255.255.255.0  --> 1.2.3.0 */
     /* Same as IPv6 (not so trivial to depict) */
@@ -553,8 +553,8 @@ ACLIP::match(Ip::Address &clientip)
      * MUST be set to empty.
      */
     ClientAddress.addr1 = clientip;
-    ClientAddress.addr2.SetEmpty();
-    ClientAddress.mask.SetEmpty();
+    ClientAddress.addr2.setEmpty();
+    ClientAddress.mask.setEmpty();
 
     data = data->splay(&ClientAddress, aclIpAddrNetworkCompare);
     debugs(28, 3, "aclIpMatchIp: '" << clientip << "' " << (splayLastResult ? "NOT found" : "found"));
@@ -39,7 +39,7 @@
 int
 ACLLocalPortStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
-    return data->match (checklist->my_addr.GetPort());
+    return data->match (checklist->my_addr.port());
 }
 
 ACLLocalPortStrategy *
@@ -4,7 +4,7 @@
 #include "acl/Strategised.h"
 #include "ssl/support.h"
 
-class ACLSslErrorStrategy : public ACLStrategy<const Ssl::Errors *>
+class ACLSslErrorStrategy : public ACLStrategy<const Ssl::CertErrors *>
 {
 
 public:
@@ -27,7 +27,7 @@ class ACLSslError
 
 private:
     static ACL::Prototype RegistryProtoype;
-    static ACLStrategised<const Ssl::Errors *> RegistryEntry_;
+    static ACLStrategised<const Ssl::CertErrors *> RegistryEntry_;
 };
 
 #endif /* SQUID_ACLSSL_ERROR_H */
@@ -52,10 +52,10 @@ ACLSslErrorData::~ACLSslErrorData()
 }
 
 bool
-ACLSslErrorData::match(const Ssl::Errors *toFind)
+ACLSslErrorData::match(const Ssl::CertErrors *toFind)
 {
-    for (const Ssl::Errors *err = toFind; err; err = err->next ) {
-        if (values->findAndTune(err->element))
+    for (const Ssl::CertErrors *err = toFind; err; err = err->next ) {
+        if (values->findAndTune(err->element.code))
             return true;
     }
     return false;
@@ -7,7 +7,7 @@
 #include "ssl/ErrorDetail.h"
 #include <vector>
 
-class ACLSslErrorData : public ACLData<const Ssl::Errors *>
+class ACLSslErrorData : public ACLData<const Ssl::CertErrors *>
 {
 
 public:
@@ -17,7 +17,7 @@ class ACLSslErrorData : public ACLData<const Ssl::Errors *>
     ACLSslErrorData(ACLSslErrorData const &);
     ACLSslErrorData &operator= (ACLSslErrorData const &);
     virtual ~ACLSslErrorData();
-    bool match(const Ssl::Errors *);
+    bool match(const Ssl::CertErrors *);
     wordlist *dump();
     void parse();
     bool empty() const;
@@ -22,7 +22,7 @@ Acl::Tree::lastAction() const
 allow_t
 Acl::Tree::actionAt(const Nodes::size_type pos) const
 {
-    assert(0 <= pos && pos < nodes.size());
+    assert(pos < nodes.size());
     if (actions.size()) {
         assert(actions.size() == nodes.size());
         return actions[pos];
@@ -124,9 +124,9 @@ Adaptation::Ecap::XactionRep::clientIpValue() const
         } else
 #endif
             client_addr = request->client_addr;
-        if (!client_addr.IsAnyAddr() && !client_addr.IsNoAddr()) {
+        if (!client_addr.isAnyAddr() && !client_addr.isNoAddr()) {
             char ntoabuf[MAX_IPSTRLEN] = "";
-            client_addr.NtoA(ntoabuf,MAX_IPSTRLEN);
+            client_addr.toStr(ntoabuf,MAX_IPSTRLEN);
             return libecap::Area::FromTempBuffer(ntoabuf, strlen(ntoabuf));
         }
     }
@@ -1253,9 +1253,11 @@ void prepareLogWithRequestDetails(HttpRequest *, AccessLogEntry::Pointer &);
 void Adaptation::Icap::ModXact::finalizeLogInfo()
 {
     HttpRequest * request_ = NULL;
+    HttpRequest * adapted_request_ = NULL;
     HttpReply * reply_ = NULL;
-    if (!(request_ = dynamic_cast<HttpRequest*>(adapted.header))) {
-        request_ = (virgin.cause? virgin.cause: dynamic_cast<HttpRequest*>(virgin.header));
+    request_ = (virgin.cause? virgin.cause: dynamic_cast<HttpRequest*>(virgin.header));
+    if (!(adapted_request_ = dynamic_cast<HttpRequest*>(adapted.header))) {
+        adapted_request_ = request_;
         reply_ = dynamic_cast<HttpReply*>(adapted.header);
     }
 
@@ -1270,6 +1272,9 @@ void Adaptation::Icap::ModXact::finalizeLogInfo()
 
     al.request = request_;
     HTTPMSGLOCK(al.request);
+    al.adapted_request = adapted_request_;
+    HTTPMSGLOCK(al.adapted_request);
+
     if (reply_) {
         al.reply = reply_;
         HTTPMSGLOCK(al.reply);
@@ -1314,7 +1319,7 @@ void Adaptation::Icap::ModXact::finalizeLogInfo()
         packerClean(&p);
         mb.clean();
     }
-    prepareLogWithRequestDetails(request_, alep);
+    prepareLogWithRequestDetails(adapted_request_, alep);
     Xaction::finalizeLogInfo();
 }
 
@@ -1413,8 +1418,8 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
         } else
 #endif
             client_addr = request->client_addr;
-        if (!client_addr.IsAnyAddr() && !client_addr.IsNoAddr())
-            buf.Printf("X-Client-IP: %s\r\n", client_addr.NtoA(ntoabuf,MAX_IPSTRLEN));
+        if (!client_addr.isAnyAddr() && !client_addr.isNoAddr())
+            buf.Printf("X-Client-IP: %s\r\n", client_addr.toStr(ntoabuf,MAX_IPSTRLEN));
     }
 
     if (TheConfig.send_username && request)
@@ -15,7 +15,7 @@
 #include "CommCalls.h"
 #include "err_detail_type.h"
 #include "fde.h"
-#include "forward.h"
+#include "FwdState.h"
 #include "globals.h"
 #include "HttpMsg.h"
 #include "HttpReply.h"
@@ -166,7 +166,7 @@ Adaptation::Icap::Xaction::dnsLookupDone(const ipcache_addrs *ia)
 
     connection = new Comm::Connection;
     connection->remote = ia->in_addrs[ia->cur];
-    connection->remote.SetPort(s.cfg().port);
+    connection->remote.port(s.cfg().port);
     getOutgoingAddress(NULL, connection);
 
     // TODO: service bypass status may differ from that of a transaction
@@ -550,7 +550,11 @@ void Adaptation::Icap::Xaction::tellQueryAborted()
 void Adaptation::Icap::Xaction::maybeLog()
 {
     if (IcapLogfileStatus == LOG_ENABLE) {
-        ACLChecklist *checklist = new ACLFilledChecklist(::Config.accessList.icap, al.request, dash_str);
+        ACLFilledChecklist *checklist = new ACLFilledChecklist(::Config.accessList.icap, al.request, dash_str);
+        if (al.reply) {
+            checklist->reply = al.reply;
+            HTTPMSGLOCK(checklist->reply);
+        }
         if (!::Config.accessList.icap || checklist->fastCheck() == ACCESS_ALLOWED) {
             finalizeLogInfo();
             icapLogLog(alep, checklist);
@@ -99,7 +99,7 @@ AnyP::PortCfg::configureSslServerContext()
 
     if (!signingCert) {
         char buf[128];
-        fatalf("No valid signing SSL certificate configured for %s_port %s", protocol,  s.ToURL(buf, sizeof(buf)));
+        fatalf("No valid signing SSL certificate configured for %s_port %s", protocol,  s.toUrl(buf, sizeof(buf)));
     }
 
     if (!signPkey)
@@ -110,7 +110,7 @@ AnyP::PortCfg::configureSslServerContext()
 
     if (!untrustedSigningCert) {
         char buf[128];
-        fatalf("Unable to generate  signing SSL certificate for untrusted sites for %s_port %s", protocol, s.ToURL(buf, sizeof(buf)));
+        fatalf("Unable to generate  signing SSL certificate for untrusted sites for %s_port %s", protocol, s.toUrl(buf, sizeof(buf)));
     }
 
     if (crlfile)
@@ -139,7 +139,7 @@ AnyP::PortCfg::configureSslServerContext()
 
     if (!staticSslContext) {
         char buf[128];
-        fatalf("%s_port %s initialization error", protocol,  s.ToURL(buf, sizeof(buf)));
+        fatalf("%s_port %s initialization error", protocol,  s.toUrl(buf, sizeof(buf)));
     }
 }
 #endif
@@ -130,7 +130,7 @@ Auth::Digest::UserRequest::authenticate(HttpRequest * request, ConnStateData * c
                 static int seen_broken_client = 0;
 
                 if (!seen_broken_client) {
-                    last_broken_addr.SetNoAddr();
+                    last_broken_addr.setNoAddr();
                     seen_broken_client = 1;
                 }
 
@@ -319,7 +319,7 @@ Auth::Negotiate::UserRequest::HandleReply(void *data, const HelperReply &reply)
         if (tokenNote != NULL)
             lm_request->server_blob = xstrdup(tokenNote);
         lm_request->releaseAuthServer();
-        debugs(29, 4, HERE << "Failed validating user via Negotiate. Error returned '" << reply << "'");
+        debugs(29, 4, "Failed validating user via Negotiate. Result: " << reply);
     }
     break;
 
@@ -343,7 +343,7 @@ Auth::Negotiate::UserRequest::HandleReply(void *data, const HelperReply &reply)
         auth_user_request->user()->credentials(Auth::Failed);
         safe_free(lm_request->server_blob);
         lm_request->releaseAuthServer();
-        debugs(29, DBG_IMPORTANT, "ERROR: Negotiate Authentication validating user. Error returned " << reply);
+        debugs(29, DBG_IMPORTANT, "ERROR: Negotiate Authentication validating user. Result: " << reply);
     } // break;
     }
 
@@ -301,7 +301,7 @@ Auth::Ntlm::UserRequest::HandleReply(void *data, const HelperReply &reply)
         auth_user_request->user()->credentials(Auth::Failed);
         safe_free(lm_request->server_blob);
         lm_request->releaseAuthServer();
-        debugs(29, 4, HERE << "Failed validating user via NTLM. Error returned '" << errNote << "'");
+        debugs(29, 4, "Failed validating user via NTLM. Result: " << reply);
     }
     break;
 
@@ -325,7 +325,7 @@ Auth::Ntlm::UserRequest::HandleReply(void *data, const HelperReply &reply)
         auth_user_request->user()->credentials(Auth::Failed);
         safe_free(lm_request->server_blob);
         lm_request->releaseAuthServer();
-        debugs(29, DBG_IMPORTANT, "ERROR: NTLM Authentication validating user. Error returned '" << reply << "'");
+        debugs(29, DBG_IMPORTANT, "ERROR: NTLM Authentication validating user. Result: " << reply);
     }
     break;
     }
@@ -1295,7 +1295,7 @@ parseBytesUnits(const char *unit)
 static void
 dump_wordlist(StoreEntry * entry, wordlist *words)
 {
-    for (wordlist *word = words; word; word = words->next)
+    for (wordlist *word = words; word; word = word->next)
         storeAppendPrintf(entry, "%s ", word->key);
 }
 
@@ -1341,9 +1341,11 @@ dump_acl_list(StoreEntry * entry, ACLList * head)
 void
 dump_acl_access(StoreEntry * entry, const char *name, acl_access * head)
 {
-    wordlist *lines = head->treeDump(name, NULL);
-    dump_wordlist(entry, lines);
-    wordlistDestroy(&lines);
+    if (head) {
+        wordlist *lines = head->treeDump(name, NULL);
+        dump_wordlist(entry, lines);
+        wordlistDestroy(&lines);
+    }
 }
 
 static void
@@ -1362,7 +1364,7 @@ static void
 dump_address(StoreEntry * entry, const char *name, Ip::Address &addr)
 {
     char buf[MAX_IPSTRLEN];
-    storeAppendPrintf(entry, "%s %s\n", name, addr.NtoA(buf,MAX_IPSTRLEN) );
+    storeAppendPrintf(entry, "%s %s\n", name, addr.toStr(buf,MAX_IPSTRLEN) );
 }
 
 static void
@@ -1376,9 +1378,9 @@ parse_address(Ip::Address *addr)
     }
 
     if (!strcmp(token,"any_addr"))
-        addr->SetAnyAddr();
+        addr->setAnyAddr();
     else if ( (!strcmp(token,"no_addr")) || (!strcmp(token,"full_mask")) )
-        addr->SetNoAddr();
+        addr->setNoAddr();
     else if ( (*addr = token) ) // try parse numeric/IPA
         (void) 0;
     else
@@ -1388,7 +1390,7 @@ parse_address(Ip::Address *addr)
 static void
 free_address(Ip::Address *addr)
 {
-    addr->SetEmpty();
+    addr->setEmpty();
 }
 
 CBDATA_TYPE(AclAddress);
@@ -1400,8 +1402,8 @@ dump_acl_address(StoreEntry * entry, const char *name, AclAddress * head)
     AclAddress *l;
 
     for (l = head; l; l = l->next) {
-        if (!l->addr.IsAnyAddr())
-            storeAppendPrintf(entry, "%s %s", name, l->addr.NtoA(buf,MAX_IPSTRLEN));
+        if (!l->addr.isAnyAddr())
+            storeAppendPrintf(entry, "%s %s", name, l->addr.toStr(buf,MAX_IPSTRLEN));
         else
             storeAppendPrintf(entry, "%s autoselect", name);
 
@@ -3495,7 +3497,7 @@ dump_IpAddress_list(StoreEntry * e, const char *n, const Ip::Address_list * s)
     while (s) {
         storeAppendPrintf(e, "%s %s\n",
                           n,
-                          s->s.NtoA(ntoabuf,MAX_IPSTRLEN));
+                          s->s.toStr(ntoabuf,MAX_IPSTRLEN));
         s = s->next;
     }
 }
@@ -3572,22 +3574,22 @@ parsePortSpecification(AnyP::PortCfg * s, char *token)
     }
 
     if (NULL == host) {
-        s->s.SetAnyAddr();
-        s->s.SetPort(port);
+        s->s.setAnyAddr();
+        s->s.port(port);
         if (!Ip::EnableIpv6)
-            s->s.SetIPv4();
-        debugs(3, 3, s->protocol << "_port: found Listen on wildcard address: *:" << s->s.GetPort() );
+            s->s.setIPv4();
+        debugs(3, 3, s->protocol << "_port: found Listen on wildcard address: *:" << s->s.port() );
     } else if ( (s->s = host) ) { /* check/parse numeric IPA */
-        s->s.SetPort(port);
+        s->s.port(port);
         if (!Ip::EnableIpv6)
-            s->s.SetIPv4();
+            s->s.setIPv4();
         debugs(3, 3, s->protocol << "_port: Listen on Host/IP: " << host << " --> " << s->s);
     } else if ( s->s.GetHostByName(host) ) { /* check/parse for FQDN */
         /* dont use ipcache */
         s->defaultsite = xstrdup(host);
-        s->s.SetPort(port);
+        s->s.port(port);
         if (!Ip::EnableIpv6)
-            s->s.SetIPv4();
+            s->s.setIPv4();
         debugs(3, 3, s->protocol << "_port: found Listen as Host " << s->defaultsite << " on IP: " << s->s);
     } else {
         debugs(3, DBG_CRITICAL, s->protocol << "_port: failed to resolve Host/IP: " << host);
@@ -3621,7 +3623,7 @@ parse_port_option(AnyP::PortCfg * s, char *token)
         /* INET6: until transparent REDIRECT works on IPv6 SOCKET, force wildcard to IPv4 */
         if (Ip::EnableIpv6)
             debugs(3, DBG_IMPORTANT, "Disabling IPv6 on port " << s->s << " (interception enabled)");
-        if ( !s->s.SetIPv4() ) {
+        if ( !s->s.setIPv4() ) {
             debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: IPv6 addresses cannot NAT intercept (protocol does not provide NAT)" << s->s );
             self_destruct();
         }
@@ -3716,7 +3718,7 @@ parse_port_option(AnyP::PortCfg * s, char *token)
         else
             self_destruct();
     } else if (strcmp(token, "ipv4") == 0) {
-        if ( !s->s.SetIPv4() ) {
+        if ( !s->s.setIPv4() ) {
             debugs(3, DBG_CRITICAL, "FATAL: http(s)_port: IPv6 addresses cannot be used as IPv4-Only. " << s->s );
             self_destruct();
         }
@@ -3851,10 +3853,10 @@ parsePortCfg(AnyP::PortCfg ** head, const char *optionName)
     }
 #endif
 
-    if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && s->s.IsAnyAddr()) {
+    if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && s->s.isAnyAddr()) {
         // clone the port options from *s to *(s->next)
         s->next = cbdataReference(s->clone());
-        s->next->s.SetIPv4();
+        s->next->s.setIPv4();
         debugs(3, 3, protocol << "_port: clone wildcard address for split-stack: " << s->s << " and " << s->next->s);
     }
 
@@ -3871,7 +3873,7 @@ dump_generic_port(StoreEntry * e, const char *n, const AnyP::PortCfg * s)
 
     storeAppendPrintf(e, "%s %s",
                       n,
-                      s->s.ToURL(buf,MAX_IPSTRLEN));
+                      s->s.toUrl(buf,MAX_IPSTRLEN));
 
     // MODES and specific sub-options.
     if (s->flags.natIntercept)
@@ -3931,7 +3933,7 @@ dump_generic_port(StoreEntry * e, const char *n, const AnyP::PortCfg * s)
         storeAppendPrintf(e, " disable-pmtu-discovery=%s", pmtu);
     }
 
-    if (s->s.IsAnyAddr() && !s->s.IsIPv6())
+    if (s->s.isAnyAddr() && !s->s.isIPv6())
         storeAppendPrintf(e, " ipv4");
 
     if (s->tcp_keepalive.enabled) {
@@ -4720,10 +4722,10 @@ static void parse_sslproxy_ssl_bump(acl_access **ssl_bump)
 
     bumpCfgStyleLast = bumpCfgStyleNow;
 
-    ACL *rule = new Acl::AndNode;
-    rule->parse();
-    // empty rule OK
+    Acl::AndNode *rule = new Acl::AndNode;
     rule->context("(ssl_bump rule)", config_input_line);
+    rule->lineParse();
+    // empty rule OK
 
     assert(ssl_bump);
     if (!*ssl_bump) {
@@ -7740,6 +7740,8 @@ DOC_START
 	can even specify multiple identical services as long as their
 	service_names differ.
 
+	To activate a service, use the adaptation_access directive. To group
+	services, use adaptation_service_chain and adaptation_service_set.
 
 	Service options are separated by white space. ICAP services support
 	the following name=value options:
@@ -7871,6 +7873,8 @@ DOC_START
 		eCAP service must have a unique URI. Obtain the right URI from
 		the service provider.
 
+	To activate a service, use the adaptation_access directive. To group
+	services, use adaptation_service_chain and adaptation_service_set.
 
 	Service options are separated by white space. eCAP services support
 	the following name=value options:
@@ -82,7 +82,7 @@ clientdbAdd(const Ip::Address &addr)
     char *buf = static_cast<char*>(xmalloc(MAX_IPSTRLEN)); // becomes hash.key
     c = (ClientInfo *)memAllocate(MEM_CLIENT_INFO);
     debugs(77, 9, "ClientInfo constructed, this=" << c);
-    c->hash.key = addr.NtoA(buf,MAX_IPSTRLEN);
+    c->hash.key = addr.toStr(buf,MAX_IPSTRLEN);
     c->addr = addr;
 #if USE_DELAY_POOLS
     /* setup default values for client write limiter */
@@ -141,7 +141,7 @@ ClientInfo * clientdbGetInfo(const Ip::Address &addr)
     if (!Config.onoff.client_db)
         return NULL;
 
-    addr.NtoA(key,MAX_IPSTRLEN);
+    addr.toStr(key,MAX_IPSTRLEN);
 
     c = (ClientInfo *) hash_lookup(client_table, key);
     if (c==NULL) {
@@ -160,7 +160,7 @@ clientdbUpdate(const Ip::Address &addr, LogTags ltype, AnyP::ProtocolType p, siz
     if (!Config.onoff.client_db)
         return;
 
-    addr.NtoA(key,MAX_IPSTRLEN);
+    addr.toStr(key,MAX_IPSTRLEN);
 
     c = (ClientInfo *) hash_lookup(client_table, key);
 
@@ -204,7 +204,7 @@ clientdbEstablished(const Ip::Address &addr, int delta)
     if (!Config.onoff.client_db)
         return 0;
 
-    addr.NtoA(key,MAX_IPSTRLEN);
+    addr.toStr(key,MAX_IPSTRLEN);
 
     c = (ClientInfo *) hash_lookup(client_table, key);
 
@@ -234,7 +234,7 @@ clientdbCutoffDenied(const Ip::Address &addr)
     if (!Config.onoff.client_db)
         return 0;
 
-    addr.NtoA(key,MAX_IPSTRLEN);
+    addr.toStr(key,MAX_IPSTRLEN);
 
     c = (ClientInfo *) hash_lookup(client_table, key);
 
@@ -445,7 +445,7 @@ client_entry(Ip::Address *current)
     char key[MAX_IPSTRLEN];
 
     if (current) {
-        current->NtoA(key,MAX_IPSTRLEN);
+        current->toStr(key,MAX_IPSTRLEN);
         hash_first(client_table);
         while ((c = (ClientInfo *) hash_next(client_table))) {
             if (!strcmp(key, hashKeyStr(&c->hash)))
@@ -486,7 +486,7 @@ snmp_meshCtblFn(variable_list * Var, snint * ErrP)
         return NULL;
     }
 
-    keyIp.NtoA(key, sizeof(key));
+    keyIp.toStr(key, sizeof(key));
     debugs(49, 5, HERE << "[" << key << "] requested!");
     c = (ClientInfo *) hash_lookup(client_table, key);
 
@@ -503,7 +503,7 @@ snmp_meshCtblFn(variable_list * Var, snint * ErrP)
 
     case MESH_CTBL_ADDR_TYPE: {
         int ival;
-        ival = c->addr.IsIPv4() ? INETADDRESSTYPE_IPV4 : INETADDRESSTYPE_IPV6 ;
+        ival = c->addr.isIPv4() ? INETADDRESSTYPE_IPV4 : INETADDRESSTYPE_IPV6 ;
         Answer = snmp_var_new_integer(Var->name, Var->name_length,
                                       ival, SMI_INTEGER);
     }
@@ -516,7 +516,7 @@ snmp_meshCtblFn(variable_list * Var, snint * ErrP)
         // See: rfc4001.txt
         Answer->type = ASN_OCTET_STR;
         char client[MAX_IPSTRLEN];
-        c->addr.NtoA(client,MAX_IPSTRLEN);
+        c->addr.toStr(client,MAX_IPSTRLEN);
         Answer->val_len = strlen(client);
         Answer->val.string =  (u_char *) xstrdup(client);
     }
@@ -100,8 +100,8 @@
 #include "errorpage.h"
 #include "fd.h"
 #include "fde.h"
-#include "forward.h"
 #include "fqdncache.h"
+#include "FwdState.h"
 #include "globals.h"
 #include "http.h"
 #include "HttpHdrContRange.h"
@@ -650,7 +650,7 @@ ClientHttpRequest::logRequest()
     if (loggingEntry() && loggingEntry()->mem_obj)
         al->cache.objectSize = loggingEntry()->contentLen();
 
-    al->cache.caddr.SetNoAddr();
+    al->cache.caddr.setNoAddr();
 
     if (getConn() != NULL) {
         al->cache.caddr = getConn()->log_addr;
@@ -2135,7 +2135,7 @@ prepareAcceleratedURL(ConnStateData * conn, ClientHttpRequest *http, char *url,
     }
 
     if (vport < 0)
-        vport = http->getConn()->clientConnection->local.GetPort();
+        vport = http->getConn()->clientConnection->local.port();
 
     const bool switchedToHttps = conn->switchedToHttps();
     const bool tryHostHeader = vhost || switchedToHttps;
@@ -2179,7 +2179,7 @@ prepareAcceleratedURL(ConnStateData * conn, ClientHttpRequest *http, char *url,
         /* Put the local socket IP address as the hostname, with whatever vport we found  */
         int url_sz = strlen(url) + 32 + Config.appendDomainLen;
         http->uri = (char *)xcalloc(url_sz, 1);
-        http->getConn()->clientConnection->local.ToHostname(ipbuf,MAX_IPSTRLEN);
+        http->getConn()->clientConnection->local.toHostStr(ipbuf,MAX_IPSTRLEN);
         snprintf(http->uri, url_sz, "%s://%s:%d%s",
                  http->getConn()->port->protocol,
                  ipbuf, vport, url);
@@ -2208,10 +2208,10 @@ prepareTransparentURL(ConnStateData * conn, ClientHttpRequest *http, char *url,
         /* Put the local socket IP address as the hostname.  */
         int url_sz = strlen(url) + 32 + Config.appendDomainLen;
         http->uri = (char *)xcalloc(url_sz, 1);
-        http->getConn()->clientConnection->local.ToHostname(ipbuf,MAX_IPSTRLEN);
+        http->getConn()->clientConnection->local.toHostStr(ipbuf,MAX_IPSTRLEN);
         snprintf(http->uri, url_sz, "%s://%s:%d%s",
                  http->getConn()->port->protocol,
-                 ipbuf, http->getConn()->clientConnection->local.GetPort(), url);
+                 ipbuf, http->getConn()->clientConnection->local.port(), url);
         debugs(33, 5, "TRANSPARENT REWRITE: '" << http->uri << "'");
     }
 }
@@ -2304,7 +2304,7 @@ parseHttpRequest(ConnStateData *csd, HttpParser *hp, HttpRequestMethod * method_
 
     /* deny CONNECT via accelerated ports */
     if (*method_p == Http::METHOD_CONNECT && csd->port && csd->port->flags.accelSurrogate) {
-        debugs(33, DBG_IMPORTANT, "WARNING: CONNECT method received on " << csd->port->protocol << " Accelerator port " << csd->port->s.GetPort() );
+        debugs(33, DBG_IMPORTANT, "WARNING: CONNECT method received on " << csd->port->protocol << " Accelerator port " << csd->port->s.port() );
         /* XXX need a way to say "this many character length string" */
         debugs(33, DBG_IMPORTANT, "WARNING: for request: " << hp->buf);
         hp->request_parse_status = Http::scMethodNotAllowed;
@@ -2606,16 +2606,16 @@ bool ConnStateData::serveDelayedError(ClientSocketContext *context)
     // In bump-server-first mode, we have not necessarily seen the intended
     // server name at certificate-peeking time. Check for domain mismatch now,
     // when we can extract the intended name from the bumped HTTP request.
-    if (sslServerBump->serverCert.get()) {
+    if (X509 *srvCert = sslServerBump->serverCert.get()) {
         HttpRequest *request = http->request;
-        if (!Ssl::checkX509ServerValidity(sslServerBump->serverCert.get(), request->GetHost())) {
+        if (!Ssl::checkX509ServerValidity(srvCert, request->GetHost())) {
             debugs(33, 2, "SQUID_X509_V_ERR_DOMAIN_MISMATCH: Certificate " <<
                    "does not match domainname " << request->GetHost());
 
             bool allowDomainMismatch = false;
             if (Config.ssl_client.cert_error) {
                 ACLFilledChecklist check(Config.ssl_client.cert_error, request, dash_str);
-                check.sslErrors = new Ssl::Errors(SQUID_X509_V_ERR_DOMAIN_MISMATCH);
+                check.sslErrors = new Ssl::CertErrors(Ssl::CertError(SQUID_X509_V_ERR_DOMAIN_MISMATCH, srvCert));
                 allowDomainMismatch = (check.fastCheck() == ACCESS_ALLOWED);
                 delete check.sslErrors;
                 check.sslErrors = NULL;
@@ -2637,7 +2637,7 @@ bool ConnStateData::serveDelayedError(ClientSocketContext *context)
                 err->src_addr = clientConnection->remote;
                 Ssl::ErrorDetail *errDetail = new Ssl::ErrorDetail(
                     SQUID_X509_V_ERR_DOMAIN_MISMATCH,
-                    sslServerBump->serverCert.get(), NULL);
+                    srvCert, NULL);
                 err->detail = errDetail;
                 // Save the original request for logging purposes.
                 if (!context->http->al->request) {
@@ -3307,71 +3307,16 @@ ConnStateData::noteBodyConsumerAborted(BodyPipe::Pointer )
 void
 ConnStateData::requestTimeout(const CommTimeoutCbParams &io)
 {
-#if THIS_CONFUSES_PERSISTENT_CONNECTION_AWARE_BROWSERS_AND_USERS
-    debugs(33, 3, "requestTimeout: FD " << io.fd << ": lifetime is expired.");
-
-    if (COMMIO_FD_WRITECB(io.fd)->active) {
-        /* FIXME: If this code is reinstated, check the conn counters,
-         * not the fd table state
-         */
-        /*
-         * Some data has been sent to the client, just close the FD
-         */
-        clientConnection->close();
-    } else if (nrequests) {
-        /*
-         * assume its a persistent connection; just close it
-         */
-        clientConnection->close();
-    } else {
-        /*
-         * Generate an error
-         */
-        ClientHttpRequest **H;
-        clientStreamNode *node;
-        ClientHttpRequest *http = parseHttpRequestAbort(this, "error:Connection%20lifetime%20expired");
-        node = http->client_stream.tail->prev->data;
-        clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
-        assert (repContext);
-        repContext->setReplyToError(ERR_LIFETIME_EXP,
-                                    Http::scRequestTimeout, Http::METHOD_NONE, "N/A", &CachePeer.sin_addr,
-                                    NULL, NULL, NULL);
-        /* No requests can be outstanded */
-        assert(chr == NULL);
-        /* add to the client request queue */
-
-        for (H = &chr; *H; H = &(*H)->next);
-        *H = http;
-
-        clientStreamRead(http->client_stream.tail->data, http, 0,
-                         HTTP_REQBUF_SZ, context->reqbuf);
-
-        /*
-         * if we don't close() here, we still need a timeout handler!
-         */
-        typedef CommCbMemFunT<ConnStateData, CommTimeoutCbParams> TimeoutDialer;
-        AsyncCall::Pointer timeoutCall =  JobCallback(33, 5,
-                                          TimeoutDialer, this, ConnStateData::requestTimeout);
-        commSetConnTimeout(io.conn, 30, timeoutCall);
-
-        /*
-         * Aha, but we don't want a read handler!
-         */
-        Comm::SetSelect(io.fd, COMM_SELECT_READ, NULL, NULL, 0);
-    }
-
-#else
     /*
     * Just close the connection to not confuse browsers
-    * using persistent connections. Some browsers opens
-    * an connection and then does not use it until much
+    * using persistent connections. Some browsers open
+    * a connection and then do not use it until much
     * later (presumeably because the request triggering
     * the open has already been completed on another
     * connection)
     */
     debugs(33, 3, "requestTimeout: FD " << io.fd << ": lifetime is expired.");
     io.conn->close();
-#endif
 }
 
 static void
@@ -3392,7 +3337,7 @@ connStateCreate(const Comm::ConnectionPointer &client, AnyP::PortCfg *port)
 
     result->clientConnection = client;
     result->log_addr = client->remote;
-    result->log_addr.ApplyMask(Config.Addrs.client_netmask);
+    result->log_addr.applyMask(Config.Addrs.client_netmask);
     result->in.buf = (char *)memAllocBuf(CLIENT_REQ_BUF_SZ, &result->in.allocatedSize);
     result->port = cbdataReference(port);
 
@@ -3680,8 +3625,8 @@ httpsEstablish(ConnStateData *connState,  SSL_CTX *sslContext, Ssl::BumpMode bum
         char buf[MAX_IPSTRLEN];
         assert(bumpMode != Ssl::bumpNone && bumpMode != Ssl::bumpEnd);
         HttpRequest::Pointer fakeRequest(new HttpRequest);
-        fakeRequest->SetHost(details->local.NtoA(buf, sizeof(buf)));
-        fakeRequest->port = details->local.GetPort();
+        fakeRequest->SetHost(details->local.toStr(buf, sizeof(buf)));
+        fakeRequest->port = details->local.port();
         fakeRequest->clientConnectionManager = connState;
         fakeRequest->client_addr = connState->clientConnection->remote;
 #if FOLLOW_X_FORWARDED_FOR
@@ -3731,7 +3676,7 @@ httpsSslBumpAccessCheckDone(allow_t answer, void *data)
         // fake a CONNECT request to force connState to tunnel
         static char ip[MAX_IPSTRLEN];
         static char reqStr[MAX_IPSTRLEN + 80];
-        connState->clientConnection->local.ToURL(ip, sizeof(ip));
+        connState->clientConnection->local.toUrl(ip, sizeof(ip));
         snprintf(reqStr, sizeof(reqStr), "CONNECT %s HTTP/1.1\r\nHost: %s\r\n\r\n", ip, ip);
         bool ret = connState->handleReadData(reqStr, strlen(reqStr));
         if (ret)
@@ -3781,8 +3726,8 @@ httpsAccept(const CommAcceptCbParams &params)
         HttpRequest *request = new HttpRequest();
         static char ip[MAX_IPSTRLEN];
         assert(params.conn->flags & (COMM_TRANSPARENT | COMM_INTERCEPTION));
-        request->SetHost(params.conn->local.NtoA(ip, sizeof(ip)));
-        request->port = params.conn->local.GetPort();
+        request->SetHost(params.conn->local.toStr(ip, sizeof(ip)));
+        request->port = params.conn->local.port();
         request->myportname = s->name;
 
         ACLFilledChecklist *acl_checklist = new ACLFilledChecklist(Config.accessList.ssl_bump, request, NULL);
@@ -4070,7 +4015,7 @@ ConnStateData::httpsPeeked(Comm::ConnectionPointer serverConnection)
         // Squid serves its own error page and closes, so we want
         // a CN that causes no additional browser errors. Possible
         // only when bumping CONNECT with a user-typed address.
-        if (intendedDest.IsAnyAddr() || isConnectRequest)
+        if (intendedDest.isAnyAddr() || isConnectRequest)
             sslCommonName = sslConnectHostOrIp;
         else if (sslServerBump->serverCert.get())
             sslCommonName = Ssl::CommonHostName(sslServerBump->serverCert.get());
@@ -4569,7 +4514,7 @@ ConnStateData::pinConnection(const Comm::ConnectionPointer &pinServer, HttpReque
         pinning.port = request->port;
         pinnedHost = pinning.host;
     } else {
-        pinning.port = pinServer->remote.GetPort();
+        pinning.port = pinServer->remote.port();
     }
     pinning.pinned = true;
     if (aPeer)
@@ -4578,7 +4523,7 @@ ConnStateData::pinConnection(const Comm::ConnectionPointer &pinServer, HttpReque
     char stmp[MAX_IPSTRLEN];
     snprintf(desc, FD_DESC_SZ, "%s pinned connection for %s (%d)",
              (auth || !aPeer) ? pinnedHost : aPeer->name,
-             clientConnection->remote.ToURL(stmp,MAX_IPSTRLEN),
+             clientConnection->remote.toUrl(stmp,MAX_IPSTRLEN),
              clientConnection->fd);
     fd_note(pinning.serverConnection->fd, desc);
 
@@ -38,7 +38,7 @@
 #include "fd.h"
 #include "fde.h"
 #include "format/Token.h"
-#include "forward.h"
+#include "FwdState.h"
 #include "globals.h"
 #include "globals.h"
 #include "HttpHeaderTools.h"
@@ -1853,7 +1853,7 @@ void
 clientReplyContext::sendBodyTooLargeError()
 {
     Ip::Address tmp_noaddr;
-    tmp_noaddr.SetNoAddr(); // TODO: make a global const
+    tmp_noaddr.setNoAddr(); // TODO: make a global const
     http->logType = LOG_TCP_DENIED_REPLY;
     ErrorState *err = clientBuildError(ERR_TOO_BIG, Http::scForbidden, NULL,
                                        http->getConn() != NULL ? http->getConn()->clientConnection->remote : tmp_noaddr,
@@ -1976,7 +1976,7 @@ clientReplyContext::processReplyAccessResult(const allow_t &accessAllowed)
             page_id = ERR_ACCESS_DENIED;
 
         Ip::Address tmp_noaddr;
-        tmp_noaddr.SetNoAddr();
+        tmp_noaddr.setNoAddr();
         err = clientBuildError(page_id, Http::scForbidden, NULL,
                                http->getConn() != NULL ? http->getConn()->clientConnection->remote : tmp_noaddr,
                                http->request);
@@ -408,15 +408,15 @@ clientBeginRequest(const HttpRequestMethod& method, char const *url, CSCB * stre
     /* Internally created requests cannot have bodies today */
     request->content_length = 0;
 
-    request->client_addr.SetNoAddr();
+    request->client_addr.setNoAddr();
 
 #if FOLLOW_X_FORWARDED_FOR
-    request->indirect_client_addr.SetNoAddr();
+    request->indirect_client_addr.setNoAddr();
 #endif /* FOLLOW_X_FORWARDED_FOR */
 
-    request->my_addr.SetNoAddr();	/* undefined for internal requests */
+    request->my_addr.setNoAddr();	/* undefined for internal requests */
 
-    request->my_addr.SetPort(0);
+    request->my_addr.port(0);
 
     /* Our version is HTTP/1.1 */
     request->http_ver = Http::ProtocolVersion(1,1);
@@ -672,8 +672,8 @@ ClientRequestContext::hostHeaderVerify()
     debugs(85, 3, HERE << "validate host=" << host << ", port=" << port << ", portStr=" << (portStr?portStr:"NULL"));
     if (http->request->flags.intercepted || http->request->flags.interceptTproxy) {
         // verify the Host: port (if any) matches the apparent destination
-        if (portStr && port != http->getConn()->clientConnection->local.GetPort()) {
-            debugs(85, 3, HERE << "FAIL on validate port " << http->getConn()->clientConnection->local.GetPort() <<
+        if (portStr && port != http->getConn()->clientConnection->local.port()) {
+            debugs(85, 3, HERE << "FAIL on validate port " << http->getConn()->clientConnection->local.port() <<
                    " matches Host: port " << port << " (" << portStr << ")");
             hostHeaderVerifyFailed("intercepted port", portStr);
         } else {
@@ -722,7 +722,7 @@ ClientRequestContext::clientAccessCheck()
 
         /* we always trust the direct client address for actual use */
         http->request->indirect_client_addr = http->request->client_addr;
-        http->request->indirect_client_addr.SetPort(0);
+        http->request->indirect_client_addr.port(0);
 
         /* setup the XFF iterator for processing */
         http->request->x_forwarded_for_iterator = http->request->header.getList(HDR_X_FORWARDED_FOR);
@@ -839,7 +839,7 @@ ClientRequestContext::clientAccessCheckDone(const allow_t &answer)
         }
 
         Ip::Address tmpnoaddr;
-        tmpnoaddr.SetNoAddr();
+        tmpnoaddr.setNoAddr();
         error = clientBuildError(page_id, status,
                                  NULL,
                                  http->getConn() != NULL ? http->getConn()->clientConnection->remote : tmpnoaddr,
@@ -906,6 +906,7 @@ clientRedirectAccessCheckDone(allow_t answer, void *data)
         redirectStart(http, clientRedirectDoneWrapper, context);
     else {
         HelperReply nilReply;
+        nilReply.result = HelperReply::Error;
         context->clientRedirectDone(nilReply);
     }
 }
@@ -2079,7 +2080,7 @@ ClientHttpRequest::handleAdaptationFailure(int errDetail, bool bypassable)
     // true cause of the error at this point, so I did not pass it.
     if (calloutContext) {
         Ip::Address noAddr;
-        noAddr.SetNoAddr();
+        noAddr.setNoAddr();
         ConnStateData * c = getConn();
         calloutContext->error = clientBuildError(ERR_ICAP_FAILURE, Http::scInternalServerError,
                                 NULL,
@@ -323,21 +323,12 @@ int
 comm_udp_recvfrom(int fd, void *buf, size_t len, int flags, Ip::Address &from)
 {
     ++ statCounter.syscalls.sock.recvfroms;
-    int x = 0;
-    struct addrinfo *AI = NULL;
-
     debugs(5,8, "comm_udp_recvfrom: FD " << fd << " from " << from);
-
-    assert( NULL == AI );
-
-    from.InitAddrInfo(AI);
-
-    x = recvfrom(fd, buf, len, flags, AI->ai_addr, &AI->ai_addrlen);
-
+    struct addrinfo *AI = NULL;
+    Ip::Address::InitAddrInfo(AI);
+    int x = recvfrom(fd, buf, len, flags, AI->ai_addr, &AI->ai_addrlen);
     from = *AI;
-
-    from.FreeAddrInfo(AI);
-
+    Ip::Address::FreeAddrInfo(AI);
     return x;
 }
 
@@ -381,32 +372,32 @@ comm_local_port(int fd)
         return 0;
     }
 
-    if (F->local_addr.GetPort())
-        return F->local_addr.GetPort();
+    if (F->local_addr.port())
+        return F->local_addr.port();
 
     if (F->sock_family == AF_INET)
-        temp.SetIPv4();
+        temp.setIPv4();
 
-    temp.InitAddrInfo(addr);
+    Ip::Address::InitAddrInfo(addr);
 
     if (getsockname(fd, addr->ai_addr, &(addr->ai_addrlen)) ) {
         debugs(50, DBG_IMPORTANT, "comm_local_port: Failed to retrieve TCP/UDP port number for socket: FD " << fd << ": " << xstrerror());
-        temp.FreeAddrInfo(addr);
+        Ip::Address::FreeAddrInfo(addr);
         return 0;
     }
     temp = *addr;
 
-    temp.FreeAddrInfo(addr);
+    Ip::Address::FreeAddrInfo(addr);
 
-    if (F->local_addr.IsAnyAddr()) {
+    if (F->local_addr.isAnyAddr()) {
         /* save the whole local address, not just the port. */
         F->local_addr = temp;
     } else {
-        F->local_addr.SetPort(temp.GetPort());
+        F->local_addr.port(temp.port());
     }
 
-    debugs(5, 6, "comm_local_port: FD " << fd << ": port " << F->local_addr.GetPort() << "(family=" << F->sock_family << ")");
-    return F->local_addr.GetPort();
+    debugs(5, 6, "comm_local_port: FD " << fd << ": port " << F->local_addr.port() << "(family=" << F->sock_family << ")");
+    return F->local_addr.port();
 }
 
 static comm_err_t
@@ -551,7 +542,7 @@ comm_openex(int sock_type,
     ++ statCounter.syscalls.sock.sockets;
 
     /* Setup the socket addrinfo details for use */
-    addr.GetAddrInfo(AI);
+    addr.getAddrInfo(AI);
     AI->ai_socktype = sock_type;
     AI->ai_protocol = proto;
 
@@ -561,11 +552,11 @@ comm_openex(int sock_type,
 
     /* under IPv6 there is the possibility IPv6 is present but disabled. */
     /* try again as IPv4-native if possible */
-    if ( new_socket < 0 && Ip::EnableIpv6 && addr.IsIPv6() && addr.SetIPv4() ) {
+    if ( new_socket < 0 && Ip::EnableIpv6 && addr.isIPv6() && addr.setIPv4() ) {
         /* attempt to open this IPv4-only. */
-        addr.FreeAddrInfo(AI);
+        Ip::Address::FreeAddrInfo(AI);
         /* Setup the socket addrinfo details for use */
-        addr.GetAddrInfo(AI);
+        addr.getAddrInfo(AI);
         AI->ai_socktype = sock_type;
         AI->ai_protocol = proto;
         debugs(50, 3, "comm_openex: Attempt fallback open socket for: " << addr );
@@ -585,7 +576,7 @@ comm_openex(int sock_type,
             debugs(50, DBG_CRITICAL, "comm_open: socket failure: " << xstrerror());
         }
 
-        addr.FreeAddrInfo(AI);
+        Ip::Address::FreeAddrInfo(AI);
 
         PROF_stop(comm_open);
         return -1;
@@ -606,18 +597,18 @@ comm_openex(int sock_type,
     if (nfmark)
         Ip::Qos::setSockNfmark(conn, nfmark);
 
-    if ( Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && addr.IsIPv6() )
+    if ( Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && addr.isIPv6() )
         comm_set_v6only(conn->fd, 1);
 
     /* Windows Vista supports Dual-Sockets. BUT defaults them to V6ONLY. Turn it OFF. */
     /* Other OS may have this administratively disabled for general use. Same deal. */
-    if ( Ip::EnableIpv6&IPV6_SPECIAL_V4MAPPING && addr.IsIPv6() )
+    if ( Ip::EnableIpv6&IPV6_SPECIAL_V4MAPPING && addr.isIPv6() )
         comm_set_v6only(conn->fd, 0);
 
     comm_init_opened(conn, tos, nfmark, note, AI);
     new_socket = comm_apply_flags(conn->fd, addr, flags, AI);
 
-    addr.FreeAddrInfo(AI);
+    Ip::Address::FreeAddrInfo(AI);
 
     PROF_stop(comm_open);
 
@@ -673,7 +664,7 @@ comm_apply_flags(int new_socket,
     if ((flags & COMM_REUSEADDR))
         commSetReuseAddr(new_socket);
 
-    if (addr.GetPort() > (unsigned short) 0) {
+    if (addr.port() > (unsigned short) 0) {
 #if _SQUID_WINDOWS_
         if (sock_type != SOCK_DGRAM)
 #endif
@@ -688,10 +679,10 @@ comm_apply_flags(int new_socket,
         comm_set_transparent(new_socket);
     }
 
-    if ( (flags & COMM_DOBIND) || addr.GetPort() > 0 || !addr.IsAnyAddr() ) {
-        if ( !(flags & COMM_DOBIND) && addr.IsAnyAddr() )
+    if ( (flags & COMM_DOBIND) || addr.port() > 0 || !addr.isAnyAddr() ) {
+        if ( !(flags & COMM_DOBIND) && addr.isAnyAddr() )
             debugs(5, DBG_IMPORTANT,"WARNING: Squid is attempting to bind() port " << addr << " without being a listener.");
-        if ( addr.IsNoAddr() )
+        if ( addr.isNoAddr() )
             debugs(5,0,"CRITICAL: Squid is attempting to bind() port " << addr << "!!");
 
         if (commBind(new_socket, *AI) != COMM_OK) {
@@ -732,7 +723,7 @@ comm_import_opened(const Comm::ConnectionPointer &conn,
     if (!(conn->flags & COMM_NOCLOEXEC))
         fd_table[conn->fd].flags.close_on_exec = true;
 
-    if (conn->local.GetPort() > (unsigned short) 0) {
+    if (conn->local.port() > (unsigned short) 0) {
 #if _SQUID_WINDOWS_
         if (AI->ai_socktype != SOCK_DGRAM)
 #endif
@@ -816,16 +807,16 @@ comm_connect_addr(int sock, const Ip::Address &address)
     struct addrinfo *AI = NULL;
     PROF_start(comm_connect_addr);
 
-    assert(address.GetPort() != 0);
+    assert(address.port() != 0);
 
     debugs(5, 9, HERE << "connecting socket FD " << sock << " to " << address << " (want family: " << F->sock_family << ")");
 
     /* Handle IPv6 over IPv4-only socket case.
-     * this case must presently be handled here since the GetAddrInfo asserts on bad mappings.
+     * this case must presently be handled here since the getAddrInfo asserts on bad mappings.
      * NP: because commResetFD is private to ConnStateData we have to return an error and
      *     trust its handled properly.
      */
-    if (F->sock_family == AF_INET && !address.IsIPv4()) {
+    if (F->sock_family == AF_INET && !address.isIPv4()) {
         errno = ENETUNREACH;
         return COMM_ERR_PROTOCOL;
     }
@@ -837,12 +828,12 @@ comm_connect_addr(int sock, const Ip::Address &address)
      * but needs carefull cross-platform verification, and verifying the address
      * condition here is simple.
      */
-    if (!F->local_addr.IsIPv4() && address.IsIPv4()) {
+    if (!F->local_addr.isIPv4() && address.isIPv4()) {
         errno = ENETUNREACH;
         return COMM_ERR_PROTOCOL;
     }
 
-    address.GetAddrInfo(AI, F->sock_family);
+    address.getAddrInfo(AI, F->sock_family);
 
     /* Establish connection. */
     errno = 0;
@@ -909,7 +900,7 @@ comm_connect_addr(int sock, const Ip::Address &address)
 
     }
 
-    address.FreeAddrInfo(AI);
+    Ip::Address::FreeAddrInfo(AI);
 
     PROF_stop(comm_connect_addr);
 
@@ -922,9 +913,9 @@ comm_connect_addr(int sock, const Ip::Address &address)
     else
         return COMM_ERROR;
 
-    address.NtoA(F->ipaddr, MAX_IPSTRLEN);
+    address.toStr(F->ipaddr, MAX_IPSTRLEN);
 
-    F->remote_port = address.GetPort(); /* remote_port is HS */
+    F->remote_port = address.port(); /* remote_port is HS */
 
     if (status == COMM_OK) {
         debugs(5, DBG_DATA, "comm_connect_addr: FD " << sock << " connected to " << address);
@@ -1174,24 +1165,16 @@ comm_udp_sendto(int fd,
                 const void *buf,
                 int len)
 {
-    int x = 0;
-    struct addrinfo *AI = NULL;
-
     PROF_start(comm_udp_sendto);
     ++ statCounter.syscalls.sock.sendtos;
 
     debugs(50, 3, "comm_udp_sendto: Attempt to send UDP packet to " << to_addr <<
            " using FD " << fd << " using Port " << comm_local_port(fd) );
 
-    /* BUG: something in the above macro appears to occasionally be setting AI to garbage. */
-    /* AYJ: 2007-08-27 : or was it because I wasn't then setting 'fd_table[fd].sock_family' to fill properly. */
-    assert( NULL == AI );
-
-    to_addr.GetAddrInfo(AI, fd_table[fd].sock_family);
-
-    x = sendto(fd, buf, len, 0, AI->ai_addr, AI->ai_addrlen);
-
-    to_addr.FreeAddrInfo(AI);
+    struct addrinfo *AI = NULL;
+    to_addr.getAddrInfo(AI, fd_table[fd].sock_family);
+    int x = sendto(fd, buf, len, 0, AI->ai_addr, AI->ai_addrlen);
+    Ip::Address::FreeAddrInfo(AI);
 
     PROF_stop(comm_udp_sendto);
 
@@ -225,8 +225,8 @@ Comm::ConnOpener::start()
     Must(conn_ != NULL);
 
     /* outbound sockets have no need to be protocol agnostic. */
-    if (!(Ip::EnableIpv6&IPV6_SPECIAL_V4MAPPING) && conn_->remote.IsIPv4()) {
-        conn_->local.SetIPv4();
+    if (!(Ip::EnableIpv6&IPV6_SPECIAL_V4MAPPING) && conn_->remote.isIPv4()) {
+        conn_->local.setIPv4();
     }
 
     if (createFd())
@@ -388,16 +388,16 @@ void
 Comm::ConnOpener::lookupLocalAddress()
 {
     struct addrinfo *addr = NULL;
-    conn_->local.InitAddrInfo(addr);
+    Ip::Address::InitAddrInfo(addr);
 
     if (getsockname(conn_->fd, addr->ai_addr, &(addr->ai_addrlen)) != 0) {
         debugs(50, DBG_IMPORTANT, "ERROR: Failed to retrieve TCP/UDP details for socket: " << conn_ << ": " << xstrerror());
-        conn_->local.FreeAddrInfo(addr);
+        Ip::Address::FreeAddrInfo(addr);
         return;
     }
 
     conn_->local = *addr;
-    conn_->local.FreeAddrInfo(addr);
+    Ip::Address::FreeAddrInfo(addr);
     debugs(5, 6, HERE << conn_);
 }
 
@@ -133,7 +133,7 @@ Comm::TcpAcceptor::status() const
 
     static char ipbuf[MAX_IPSTRLEN] = {'\0'};
     if (ipbuf[0] == '\0')
-        conn->local.ToHostname(ipbuf, MAX_IPSTRLEN);
+        conn->local.toHostStr(ipbuf, MAX_IPSTRLEN);
 
     static MemBuf buf;
     buf.reset();
@@ -310,13 +310,13 @@ Comm::TcpAcceptor::oldAccept(Comm::ConnectionPointer &details)
     ++statCounter.syscalls.sock.accepts;
     int sock;
     struct addrinfo *gai = NULL;
-    details->local.InitAddrInfo(gai);
+    Ip::Address::InitAddrInfo(gai);
 
     errcode = 0; // reset local errno copy.
     if ((sock = accept(conn->fd, gai->ai_addr, &gai->ai_addrlen)) < 0) {
         errcode = errno; // store last accept errno locally.
 
-        details->local.FreeAddrInfo(gai);
+        Ip::Address::FreeAddrInfo(gai);
 
         PROF_stop(comm_accept);
 
@@ -339,21 +339,21 @@ Comm::TcpAcceptor::oldAccept(Comm::ConnectionPointer &details)
     if ( Config.client_ip_max_connections >= 0) {
         if (clientdbEstablished(details->remote, 0) > Config.client_ip_max_connections) {
             debugs(50, DBG_IMPORTANT, "WARNING: " << details->remote << " attempting more than " << Config.client_ip_max_connections << " connections.");
-            details->local.FreeAddrInfo(gai);
+            Ip::Address::FreeAddrInfo(gai);
             return COMM_ERROR;
         }
     }
 
     // lookup the local-end details of this new connection
-    details->local.InitAddrInfo(gai);
-    details->local.SetEmpty();
+    Ip::Address::InitAddrInfo(gai);
+    details->local.setEmpty();
     if (getsockname(sock, gai->ai_addr, &gai->ai_addrlen) != 0) {
         debugs(50, DBG_IMPORTANT, "ERROR: getsockname() failed to locate local-IP on " << details << ": " << xstrerror());
-        details->local.FreeAddrInfo(gai);
+        Ip::Address::FreeAddrInfo(gai);
         return COMM_ERROR;
     }
     details->local = *gai;
-    details->local.FreeAddrInfo(gai);
+    Ip::Address::FreeAddrInfo(gai);
 
     /* fdstat update */
     // XXX : these are not all HTTP requests. use a note about type and ip:port details->
@@ -364,10 +364,10 @@ Comm::TcpAcceptor::oldAccept(Comm::ConnectionPointer &details)
     fdd_table[sock].close_line = 0;
 
     fde *F = &fd_table[sock];
-    details->remote.NtoA(F->ipaddr,MAX_IPSTRLEN);
-    F->remote_port = details->remote.GetPort();
+    details->remote.toStr(F->ipaddr,MAX_IPSTRLEN);
+    F->remote_port = details->remote.port();
     F->local_addr = details->local;
-    F->sock_family = details->local.IsIPv6()?AF_INET6:AF_INET;
+    F->sock_family = details->local.isIPv6()?AF_INET6:AF_INET;
 
     // set socket flags
     commSetCloseOnExec(sock);
@@ -384,9 +384,9 @@ Comm::TcpAcceptor::oldAccept(Comm::ConnectionPointer &details)
 
 #if USE_SQUID_EUI
     if (Eui::TheConfig.euiLookup) {
-        if (conn->remote.IsIPv4()) {
+        if (conn->remote.isIPv4()) {
             conn->remoteEui48.lookup(conn->remote);
-        } else if (conn->remote.IsIPv6()) {
+        } else if (conn->remote.isIPv6()) {
             conn->remoteEui64.lookup(conn->remote);
         }
     }
@@ -810,7 +810,7 @@ VectorPool::id(CompositeSelectionDetails &details)
         return new NullDelayId;
 
     /* non-IPv4 are not able to provide IPv4-bitmask for this pool type key. */
-    if ( !details.src_addr.IsIPv4() )
+    if ( !details.src_addr.isIPv4() )
         return new NullDelayId;
 
     unsigned int key = makeKey(details.src_addr);
@@ -858,11 +858,11 @@ unsigned int
 IndividualPool::makeKey(Ip::Address &src_addr) const
 {
     /* IPv4 required for this pool */
-    if ( !src_addr.IsIPv4() )
+    if ( !src_addr.isIPv4() )
         return 1;
 
     struct in_addr host;
-    src_addr.GetInAddr(host);
+    src_addr.getInAddr(host);
     return (ntohl(host.s_addr) & 0xff);
 }
 
@@ -884,11 +884,11 @@ unsigned int
 ClassCNetPool::makeKey(Ip::Address &src_addr) const
 {
     /* IPv4 required for this pool */
-    if ( !src_addr.IsIPv4() )
+    if ( !src_addr.isIPv4() )
         return 1;
 
     struct in_addr net;
-    src_addr.GetInAddr(net);
+    src_addr.getInAddr(net);
     return ( (ntohl(net.s_addr) >> 8) & 0xff);
 }
 
@@ -956,24 +956,24 @@ unsigned char
 ClassCHostPool::makeHostKey(Ip::Address &src_addr) const
 {
     /* IPv4 required for this pool */
-    if ( !src_addr.IsIPv4() )
+    if ( !src_addr.isIPv4() )
         return 1;
 
     /* Temporary bypass for IPv4-only */
     struct in_addr host;
-    src_addr.GetInAddr(host);
+    src_addr.getInAddr(host);
     return (ntohl(host.s_addr) & 0xff);
 }
 
 unsigned int
 ClassCHostPool::makeKey(Ip::Address &src_addr) const
 {
     /* IPv4 required for this pool */
-    if ( !src_addr.IsIPv4() )
+    if ( !src_addr.isIPv4() )
         return 1;
 
     struct in_addr net;
-    src_addr.GetInAddr(net);
+    src_addr.getInAddr(net);
     return ( (ntohl(net.s_addr) >> 8) & 0xff);
 }
 
@@ -984,7 +984,7 @@ ClassCHostPool::id(CompositeSelectionDetails &details)
         return new NullDelayId;
 
     /* non-IPv4 are not able to provide IPv4-bitmask for this pool type key. */
-    if ( !details.src_addr.IsIPv4() )
+    if ( !details.src_addr.isIPv4() )
         return new NullDelayId;
 
     unsigned int key = makeKey (details.src_addr);
@@ -40,6 +40,10 @@
 #include "Store.h"
 #include "wordlist.h"
 
+#if SQUID_SNMP
+#include "snmp_core.h"
+#endif
+
 /* MS VisualStudio Projects are monolitich, so we need the following
    #if to include the external DNS code in compile process when
    using external DNS.
@@ -280,11 +280,11 @@ idnsAddMDNSNameservers()
 
     // mDNS resolver addresses are explicit multicast group IPs
     idnsAddNameserver("FF02::FB");
-    nameservers[nns-1].S.SetPort(5353);
+    nameservers[nns-1].S.port(5353);
     nameservers[nns-1].mDNSResolver = true;
 
     idnsAddNameserver("224.0.0.251");
-    nameservers[nns-1].S.SetPort(5353);
+    nameservers[nns-1].S.port(5353);
     nameservers[nns-1].mDNSResolver = true;
 }
 
@@ -298,13 +298,13 @@ idnsAddNameserver(const char *buf)
         return;
     }
 
-    if (A.IsAnyAddr()) {
+    if (A.isAnyAddr()) {
         debugs(78, DBG_CRITICAL, "WARNING: Squid does not accept " << A << " in DNS server specifications.");
-        A.SetLocalhost();
+        A.setLocalhost();
         debugs(78, DBG_CRITICAL, "Will be using " << A << " instead, assuming you meant that DNS is running on the same machine");
     }
 
-    if (!Ip::EnableIpv6 && !A.SetIPv4()) {
+    if (!Ip::EnableIpv6 && !A.setIPv4()) {
         debugs(78, DBG_IMPORTANT, "WARNING: IPv6 is disabled. Discarding " << A << " in DNS server specifications.");
         return;
     }
@@ -328,7 +328,7 @@ idnsAddNameserver(const char *buf)
     }
 
     assert(nns < nns_alloc);
-    A.SetPort(NS_DEFAULTPORT);
+    A.port(NS_DEFAULTPORT);
     nameservers[nns].S = A;
 #if WHEN_EDNS_RESPONSES_ARE_PARSED
     nameservers[nns].last_seen_edns = RFC1035_DEFAULT_PACKET_SZ;
@@ -733,7 +733,7 @@ idnsStats(StoreEntry * sentry)
 
     for (i = 0; i < nns; ++i) {
         storeAppendPrintf(sentry, "%-45s %9d %9d %s\n",  /* Let's take the maximum: (15 IPv4/45 IPv6) */
-                          nameservers[i].S.NtoA(buf,MAX_IPSTRLEN),
+                          nameservers[i].S.toStr(buf,MAX_IPSTRLEN),
                           nameservers[i].nqueries,
                           nameservers[i].nreplies,
                           nameservers[i].mDNSResolver?"multicast":"recurse");
@@ -847,7 +847,7 @@ idnsInitVCConnected(const Comm::ConnectionPointer &conn, comm_err_t status, int
     if (status != COMM_OK || !conn) {
         char buf[MAX_IPSTRLEN] = "";
         if (vc->ns < nns)
-            nameservers[vc->ns].S.NtoA(buf,MAX_IPSTRLEN);
+            nameservers[vc->ns].S.toStr(buf,MAX_IPSTRLEN);
         debugs(78, DBG_IMPORTANT, HERE << "Failed to connect to nameserver " << buf << " using TCP.");
         return;
     }
@@ -888,15 +888,15 @@ idnsInitVC(int nsv)
 
     Comm::ConnectionPointer conn = new Comm::Connection();
 
-    if (!Config.Addrs.udp_outgoing.IsNoAddr())
+    if (!Config.Addrs.udp_outgoing.isNoAddr())
         conn->local = Config.Addrs.udp_outgoing;
     else
         conn->local = Config.Addrs.udp_incoming;
 
     conn->remote = nameservers[nsv].S;
 
-    if (conn->remote.IsIPv4()) {
-        conn->local.SetIPv4();
+    if (conn->remote.isIPv4()) {
+        conn->local.setIPv4();
     }
 
     AsyncCall::Pointer call = commCbCall(78,3, "idnsInitVCConnected", CommConnectCbPtrFun(idnsInitVCConnected, vc));
@@ -917,7 +917,7 @@ idnsSendQueryVC(idns_query * q, int nsn)
 
     if (!vc) {
         char buf[MAX_IPSTRLEN];
-        debugs(78, DBG_IMPORTANT, "idnsSendQuery: Failed to initiate TCP connection to nameserver " << nameservers[nsn].S.NtoA(buf,MAX_IPSTRLEN) << "!");
+        debugs(78, DBG_IMPORTANT, "idnsSendQuery: Failed to initiate TCP connection to nameserver " << nameservers[nsn].S.toStr(buf,MAX_IPSTRLEN) << "!");
 
         return;
     }
@@ -964,7 +964,7 @@ idnsSendQuery(idns_query * q)
             idnsSendQueryVC(q, nsn);
             x = y = 0;
         } else {
-            if (DnsSocketB >= 0 && nameservers[nsn].S.IsIPv6())
+            if (DnsSocketB >= 0 && nameservers[nsn].S.isIPv6())
                 y = comm_udp_sendto(DnsSocketB, nameservers[nsn].S, q->buf, q->sz);
             else if (DnsSocketA >= 0)
                 x = comm_udp_sendto(DnsSocketA, nameservers[nsn].S, q->buf, q->sz);
@@ -974,9 +974,9 @@ idnsSendQuery(idns_query * q)
 
         q->sent_t = current_time;
 
-        if (y < 0 && nameservers[nsn].S.IsIPv6())
+        if (y < 0 && nameservers[nsn].S.isIPv6())
             debugs(50, DBG_IMPORTANT, "idnsSendQuery: FD " << DnsSocketB << ": sendto: " << xstrerror());
-        if (x < 0 && nameservers[nsn].S.IsIPv4())
+        if (x < 0 && nameservers[nsn].S.isIPv4())
             debugs(50, DBG_IMPORTANT, "idnsSendQuery: FD " << DnsSocketA << ": sendto: " << xstrerror());
 
     } while ( (x<0 && y<0) && q->nsends % nns != 0);
@@ -1004,7 +1004,7 @@ idnsFromKnownNameserver(Ip::Address const &from)
         if (nameservers[i].S != from)
             continue;
 
-        if (nameservers[i].S.GetPort() != from.GetPort())
+        if (nameservers[i].S.port() != from.port())
             continue;
 
         return i;
@@ -1530,15 +1530,15 @@ dnsInit(void)
     if (DnsSocketA < 0 && DnsSocketB < 0) {
         Ip::Address addrV6; // since we don't want to alter Config.Addrs.udp_* and dont have one of our own.
 
-        if (!Config.Addrs.udp_outgoing.IsNoAddr())
+        if (!Config.Addrs.udp_outgoing.isNoAddr())
             addrV6 = Config.Addrs.udp_outgoing;
         else
             addrV6 = Config.Addrs.udp_incoming;
 
         Ip::Address addrV4 = addrV6;
-        addrV4.SetIPv4();
+        addrV4.setIPv4();
 
-        if (Ip::EnableIpv6 && addrV6.IsIPv6()) {
+        if (Ip::EnableIpv6 && addrV6.isIPv6()) {
             debugs(78, 2, "idnsInit: attempt open DNS socket to: " << addrV6);
             DnsSocketB = comm_open_listener(SOCK_DGRAM,
                                             IPPROTO_UDP,
@@ -1547,7 +1547,7 @@ dnsInit(void)
                                             "DNS Socket IPv6");
         }
 
-        if (addrV4.IsIPv4()) {
+        if (addrV4.isIPv4()) {
             debugs(78, 2, "idnsInit: attempt open DNS socket to: " << addrV4);
             DnsSocketA = comm_open_listener(SOCK_DGRAM,
                                             IPPROTO_UDP,
@@ -1770,21 +1770,21 @@ idnsPTRLookup(const Ip::Address &addr, IDNSCB * callback, void *data)
 
     char ip[MAX_IPSTRLEN];
 
-    addr.NtoA(ip,MAX_IPSTRLEN);
+    addr.toStr(ip,MAX_IPSTRLEN);
 
     q = cbdataAlloc(idns_query);
 
     // idns_query is POD so no constructors are called after allocation
     q->xact_id.change();
     q->query_id = idnsQueryID();
 
-    if (addr.IsIPv6()) {
+    if (addr.isIPv6()) {
         struct in6_addr addr6;
-        addr.GetInAddr(addr6);
+        addr.getInAddr(addr6);
         q->sz = rfc3596BuildPTRQuery6(addr6, q->buf, sizeof(q->buf), q->query_id, &q->query, Config.dns.packet_max);
     } else {
         struct in_addr addr4;
-        addr.GetInAddr(addr4);
+        addr.getInAddr(addr4);
         // see EDNS notes at top of file why this sends 0
         q->sz = rfc3596BuildPTRQuery4(addr4, q->buf, sizeof(q->buf), q->query_id, &q->query, 0);
     }
@@ -746,7 +746,7 @@ ErrorState::Dump(MemBuf * mb)
     str.Printf("TimeStamp: %s\r\n\r\n", mkrfc1123(squid_curtime));
 
     /* - IP stuff */
-    str.Printf("ClientIP: %s\r\n", src_addr.NtoA(ntoabuf,MAX_IPSTRLEN));
+    str.Printf("ClientIP: %s\r\n", src_addr.toStr(ntoabuf,MAX_IPSTRLEN));
 
     if (request && request->hier.host[0] != '\0') {
         str.Printf("ServerIP: %s\r\n", request->hier.host);
@@ -906,12 +906,12 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
         break;
 
     case 'i':
-        mb.Printf("%s", src_addr.NtoA(ntoabuf,MAX_IPSTRLEN));
+        mb.Printf("%s", src_addr.toStr(ntoabuf,MAX_IPSTRLEN));
         break;
 
     case 'I':
         if (request && request->hier.tcpServer != NULL)
-            p = request->hier.tcpServer->remote.NtoA(ntoabuf,MAX_IPSTRLEN);
+            p = request->hier.tcpServer->remote.toStr(ntoabuf,MAX_IPSTRLEN);
         else if (!building_deny_info_url)
             p = "[unknown]";
         break;
@@ -161,7 +161,7 @@ Eui::Eui48::lookup(const Ip::Address &c)
 #endif /* !_SQUID_WINDOWS_ */
 
     Ip::Address ipAddr = c;
-    ipAddr.SetPort(0);
+    ipAddr.port(0);
 
 #if _SQUID_LINUX_
 
@@ -198,7 +198,7 @@ Eui::Eui48::lookup(const Ip::Address &c)
     memset(&arpReq, '\0', sizeof(arpReq));
 
     struct sockaddr_in *sa = (struct sockaddr_in*)&arpReq.arp_pa;
-    ipAddr.GetSockAddr(*sa);
+    ipAddr.getSockAddr(*sa);
 
     /* Query ARP table */
     if (ioctl(tmpSocket, SIOCGARP, &arpReq) != -1) {
@@ -263,7 +263,7 @@ Eui::Eui48::lookup(const Ip::Address &c)
         memset(&arpReq, '\0', sizeof(arpReq));
 
         sa = (sockaddr_in*)&arpReq.arp_pa;
-        ipAddr.GetSockAddr(*sa);
+        ipAddr.getSockAddr(*sa);
 
         strncpy(arpReq.arp_dev, ifr->ifr_name, sizeof(arpReq.arp_dev) - 1);
 
@@ -328,7 +328,7 @@ Eui::Eui48::lookup(const Ip::Address &c)
     memset(&arpReq, '\0', sizeof(arpReq));
 
     struct sockaddr_in *sa = (struct sockaddr_in*)&arpReq.arp_pa;
-    ipAddr.GetSockAddr(*sa);
+    ipAddr.getSockAddr(*sa);
 
     /* Query ARP table */
     if (ioctl(tmpSocket, SIOCGARP, &arpReq) != -1) {
@@ -380,7 +380,7 @@ Eui::Eui48::lookup(const Ip::Address &c)
     memset(&arpReq, '\0', sizeof(arpReq));
 
     struct sockaddr_in *sa = (struct sockaddr_in*)&arpReq.arp_pa;
-    ipAddr.GetSockAddr(*sa);
+    ipAddr.getSockAddr(*sa);
 
     /* Query ARP table */
     mib[0] = CTL_NET;
@@ -49,11 +49,11 @@ bool
 Eui::Eui64::lookupSlaac(const Ip::Address &c)
 {
     /* RFC 4291 Link-Local unicast addresses which contain SLAAC - usually trustable. */
-    if (c.IsSiteLocal6() && c.IsSlaac() ) {
+    if (c.isSiteLocal6() && c.isSiteLocalAuto() ) {
 
         // strip the final 64 bits of the address...
         struct in6_addr tmp;
-        c.GetInAddr(tmp);
+        c.getInAddr(tmp);
         memcpy(eui, &(tmp.s6_addr[8]), SZ_EUI64_BUF);
 
         return true;
@@ -185,7 +185,7 @@ struct _external_acl_format {
 
 #if USE_SSL
         EXT_ACL_USER_CERT,
-        EXT_ACL_CA_CERT,
+        EXT_ACL_USER_CA_CERT,
         EXT_ACL_USER_CERT_RAW,
         EXT_ACL_USER_CERTCHAIN_RAW,
 #endif
@@ -327,7 +327,7 @@ parse_externalAclHelper(external_acl ** list)
     a->children.n_max = DEFAULT_EXTERNAL_ACL_CHILDREN;
     a->children.n_startup = a->children.n_max;
     a->children.n_idle = 1;
-    a->local_addr.SetLocalhost();
+    a->local_addr.setLocalhost();
     a->quote = external_acl::QUOTE_METHOD_URL;
 
     token = strtok(NULL, w_space);
@@ -375,7 +375,7 @@ parse_externalAclHelper(external_acl ** list)
             /* INET6: allow admin to configure some helpers explicitly to
                       bind to IPv4/v6 localhost port. */
         } else if (strcmp(token, "ipv4") == 0) {
-            if ( !a->local_addr.SetIPv4() ) {
+            if ( !a->local_addr.setIPv4() ) {
                 debugs(3, DBG_CRITICAL, "WARNING: Error converting " << a->local_addr << " to IPv4 in " << a->name );
             }
         } else if (strcmp(token, "ipv6") == 0) {
@@ -417,52 +417,54 @@ parse_externalAclHelper(external_acl ** list)
 
         if (strncmp(token, "%{", 2) == 0) {
             // deprecated. but assume the old configs all referred to request headers.
-            debugs(82, DBG_IMPORTANT, "WARNING: external_acl_type format %{...} is being replaced by %>{...} for : " << token);
+            debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type format %{...} is being replaced by %>ha{...} for : " << token);
             parse_header_token(format, (token+2), _external_acl_format::EXT_ACL_HEADER_REQUEST);
         } else if (strncmp(token, "%>{", 3) == 0) {
+            debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type format %>{...} is being replaced by %>ha{...} for : " << token);
+            parse_header_token(format, (token+3), _external_acl_format::EXT_ACL_HEADER_REQUEST);
+        } else if (strncmp(token, "%>ha{", 5) == 0) {
             parse_header_token(format, (token+3), _external_acl_format::EXT_ACL_HEADER_REQUEST);
         } else if (strncmp(token, "%<{", 3) == 0) {
+            debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type format %<{...} is being replaced by %<h{...} for : " << token);
+            parse_header_token(format, (token+3), _external_acl_format::EXT_ACL_HEADER_REPLY);
+        } else if (strncmp(token, "%<h{", 4) == 0) {
             parse_header_token(format, (token+3), _external_acl_format::EXT_ACL_HEADER_REPLY);
 #if USE_AUTH
-        } else if (strcmp(token, "%LOGIN") == 0) {
+        } else if (strcmp(token, "%LOGIN") == 0 || strcmp(token, "%ul") == 0) {
             format->type = _external_acl_format::EXT_ACL_LOGIN;
             a->require_auth = true;
 #endif
         }
-
 #if USE_IDENT
-        else if (strcmp(token, "%IDENT") == 0)
+        else if (strcmp(token, "%IDENT") == 0 || strcmp(token, "%ui") == 0)
             format->type = _external_acl_format::EXT_ACL_IDENT;
-
 #endif
-
-        else if (strcmp(token, "%SRC") == 0)
+        else if (strcmp(token, "%SRC") == 0 || strcmp(token, "%>a") == 0)
             format->type = _external_acl_format::EXT_ACL_SRC;
-        else if (strcmp(token, "%SRCPORT") == 0)
+        else if (strcmp(token, "%SRCPORT") == 0 || strcmp(token, "%>p") == 0)
             format->type = _external_acl_format::EXT_ACL_SRCPORT;
 #if USE_SQUID_EUI
         else if (strcmp(token, "%SRCEUI48") == 0)
             format->type = _external_acl_format::EXT_ACL_SRCEUI48;
         else if (strcmp(token, "%SRCEUI64") == 0)
             format->type = _external_acl_format::EXT_ACL_SRCEUI64;
 #endif
-        else if (strcmp(token, "%MYADDR") == 0)
+        else if (strcmp(token, "%MYADDR") == 0 || strcmp(token, "%la") == 0)
             format->type = _external_acl_format::EXT_ACL_MYADDR;
-        else if (strcmp(token, "%MYPORT") == 0)
+        else if (strcmp(token, "%MYPORT") == 0 || strcmp(token, "%lp") == 0)
             format->type = _external_acl_format::EXT_ACL_MYPORT;
-        else if (strcmp(token, "%URI") == 0)
+        else if (strcmp(token, "%URI") == 0 || strcmp(token, "%>ru") == 0)
             format->type = _external_acl_format::EXT_ACL_URI;
         else if (strcmp(token, "%DST") == 0)
             format->type = _external_acl_format::EXT_ACL_DST;
         else if (strcmp(token, "%PROTO") == 0)
             format->type = _external_acl_format::EXT_ACL_PROTO;
         else if (strcmp(token, "%PORT") == 0)
             format->type = _external_acl_format::EXT_ACL_PORT;
-        else if (strcmp(token, "%PATH") == 0)
+        else if (strcmp(token, "%PATH") == 0 || strcmp(token, "%>rp") == 0)
             format->type = _external_acl_format::EXT_ACL_PATH;
-        else if (strcmp(token, "%METHOD") == 0)
+        else if (strcmp(token, "%METHOD") == 0 || strcmp(token, "%>rm") == 0)
             format->type = _external_acl_format::EXT_ACL_METHOD;
-
 #if USE_SSL
         else if (strcmp(token, "%USER_CERT") == 0)
             format->type = _external_acl_format::EXT_ACL_USER_CERT_RAW;
@@ -471,8 +473,12 @@ parse_externalAclHelper(external_acl ** list)
         else if (strncmp(token, "%USER_CERT_", 11) == 0) {
             format->type = _external_acl_format::EXT_ACL_USER_CERT;
             format->header = xstrdup(token + 11);
+        } else if (strncmp(token, "%USER_CA_CERT_", 11) == 0) {
+            format->type = _external_acl_format::EXT_ACL_USER_CA_CERT;
+            format->header = xstrdup(token + 11);
         } else if (strncmp(token, "%CA_CERT_", 11) == 0) {
-            format->type = _external_acl_format::EXT_ACL_USER_CERT;
+            debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type %CA_CERT_* code is obsolete. Use %USER_CA_CERT_* instead");
+            format->type = _external_acl_format::EXT_ACL_USER_CA_CERT;
             format->header = xstrdup(token + 11);
         }
 #endif
@@ -529,7 +535,7 @@ dump_externalAclHelper(StoreEntry * sentry, const char *name, const external_acl
     for (node = list; node; node = node->next) {
         storeAppendPrintf(sentry, "%s %s", name, node->name);
 
-        if (!node->local_addr.IsIPv6())
+        if (!node->local_addr.isIPv6())
             storeAppendPrintf(sentry, " ipv4");
         else
             storeAppendPrintf(sentry, " ipv6");
@@ -618,7 +624,7 @@ dump_externalAclHelper(StoreEntry * sentry, const char *name, const external_acl
                 DUMP_EXT_ACL_TYPE_FMT(USER_CERT_RAW, " %%USER_CERT_RAW");
                 DUMP_EXT_ACL_TYPE_FMT(USER_CERTCHAIN_RAW, " %%USER_CERTCHAIN_RAW");
                 DUMP_EXT_ACL_TYPE_FMT(USER_CERT, " %%USER_CERT_%s", format->header);
-                DUMP_EXT_ACL_TYPE_FMT(CA_CERT, " %%CA_CERT_%s", format->header);
+                DUMP_EXT_ACL_TYPE_FMT(USER_CA_CERT, " %%USER_CA_CERT_%s", format->header);
 #endif
 #if USE_AUTH
                 DUMP_EXT_ACL_TYPE(EXT_USER);
@@ -999,11 +1005,11 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
 #endif
 
         case _external_acl_format::EXT_ACL_SRC:
-            str = ch->src_addr.NtoA(buf,sizeof(buf));
+            str = ch->src_addr.toStr(buf,sizeof(buf));
             break;
 
         case _external_acl_format::EXT_ACL_SRCPORT:
-            snprintf(buf, sizeof(buf), "%d", request->client_addr.GetPort());
+            snprintf(buf, sizeof(buf), "%d", request->client_addr.port());
             str = buf;
             break;
 
@@ -1022,11 +1028,11 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
 #endif
 
         case _external_acl_format::EXT_ACL_MYADDR:
-            str = request->my_addr.NtoA(buf, sizeof(buf));
+            str = request->my_addr.toStr(buf, sizeof(buf));
             break;
 
         case _external_acl_format::EXT_ACL_MYPORT:
-            snprintf(buf, sizeof(buf), "%d", request->my_addr.GetPort());
+            snprintf(buf, sizeof(buf), "%d", request->my_addr.port());
             str = buf;
             break;
 
@@ -1137,7 +1143,7 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
 
             break;
 
-        case _external_acl_format::EXT_ACL_CA_CERT:
+        case _external_acl_format::EXT_ACL_USER_CA_CERT:
 
             if (ch->conn() != NULL && Comm::IsConnOpen(ch->conn()->clientConnection)) {
                 SSL *ssl = fd_table[ch->conn()->clientConnection->fd].ssl;
@@ -116,7 +116,7 @@ fde::remoteAddr() const
     if ( *ipaddr )
         snprintf( buf, MAX_IPSTRLEN, "%s:%d", ipaddr, (int)remote_port);
     else
-        local_addr.ToURL(buf,MAX_IPSTRLEN); // ToHostname does not include port.
+        local_addr.toUrl(buf,MAX_IPSTRLEN); // toHostStr does not include port.
 
     return buf;
 }
@@ -157,7 +157,7 @@ class fde
     inline void clear() {
         type = 0;
         remote_port = 0;
-        local_addr.SetEmpty();
+        local_addr.setEmpty();
         tosToServer = '\0';
         nfmarkToServer = 0;
         sock_family = 0;
@@ -331,19 +331,19 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             break;
 
         case LFT_CLIENT_FQDN:
-            if (al->cache.caddr.IsAnyAddr()) // e.g., ICAP OPTIONS lack client
+            if (al->cache.caddr.isAnyAddr()) // e.g., ICAP OPTIONS lack client
                 out = "-";
             else
                 out = fqdncache_gethostbyaddr(al->cache.caddr, FQDN_LOOKUP_IF_MISS);
             if (!out) {
-                out = al->cache.caddr.NtoA(tmp,1024);
+                out = al->cache.caddr.toStr(tmp,1024);
             }
 
             break;
 
         case LFT_CLIENT_PORT:
             if (al->request) {
-                outint = al->request->client_addr.GetPort();
+                outint = al->request->client_addr.port();
                 doint = 1;
             }
             break;
@@ -352,7 +352,7 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
 #if USE_SQUID_EUI
             // TODO make the ACL checklist have a direct link to any TCP details.
             if (al->request && al->request->clientConnectionManager.valid() && al->request->clientConnectionManager->clientConnection != NULL) {
-                if (al->request->clientConnectionManager->clientConnection->remote.IsIPv4())
+                if (al->request->clientConnectionManager->clientConnection->remote.isIPv4())
                     al->request->clientConnectionManager->clientConnection->remoteEui48.encode(tmp, 1024);
                 else
                     al->request->clientConnectionManager->clientConnection->remoteEui64.encode(tmp, 1024);
@@ -365,7 +365,7 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
 
         case LFT_SERVER_IP_ADDRESS:
             if (al->hier.tcpServer != NULL) {
-                out = al->hier.tcpServer->remote.NtoA(tmp,sizeof(tmp));
+                out = al->hier.tcpServer->remote.toStr(tmp,sizeof(tmp));
             }
             break;
 
@@ -375,7 +375,7 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
 
         case LFT_SERVER_PORT:
             if (al->hier.tcpServer != NULL) {
-                outint = al->hier.tcpServer->remote.GetPort();
+                outint = al->hier.tcpServer->remote.port();
                 doint = 1;
             }
             break;
@@ -387,44 +387,44 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
                                                  al->request->flags.intercepted) && al->cache.port :
                                                 false;
             if (interceptedAtKnownPort) {
-                const bool portAddressConfigured = !al->cache.port->s.IsAnyAddr();
+                const bool portAddressConfigured = !al->cache.port->s.isAnyAddr();
                 if (portAddressConfigured)
-                    out = al->cache.port->s.NtoA(tmp, sizeof(tmp));
+                    out = al->cache.port->s.toStr(tmp, sizeof(tmp));
             } else if (al->tcpClient != NULL)
-                out = al->tcpClient->local.NtoA(tmp, sizeof(tmp));
+                out = al->tcpClient->local.toStr(tmp, sizeof(tmp));
         }
         break;
 
         case LFT_CLIENT_LOCAL_IP:
             if (al->tcpClient != NULL) {
-                out = al->tcpClient->local.NtoA(tmp,sizeof(tmp));
+                out = al->tcpClient->local.toStr(tmp,sizeof(tmp));
             }
             break;
 
         case LFT_LOCAL_LISTENING_PORT:
             if (al->cache.port) {
-                outint = al->cache.port->s.GetPort();
+                outint = al->cache.port->s.port();
                 doint = 1;
             }
             break;
 
         case LFT_CLIENT_LOCAL_PORT:
             if (al->tcpClient != NULL) {
-                outint = al->tcpClient->local.GetPort();
+                outint = al->tcpClient->local.port();
                 doint = 1;
             }
             break;
 
         case LFT_SERVER_LOCAL_IP_OLD_27:
         case LFT_SERVER_LOCAL_IP:
             if (al->hier.tcpServer != NULL) {
-                out = al->hier.tcpServer->local.NtoA(tmp,sizeof(tmp));
+                out = al->hier.tcpServer->local.toStr(tmp,sizeof(tmp));
             }
             break;
 
         case LFT_SERVER_LOCAL_PORT:
             if (al->hier.tcpServer != NULL) {
-                outint = al->hier.tcpServer->local.GetPort();
+                outint = al->hier.tcpServer->local.port();
                 doint = 1;
             }
 
@@ -510,7 +510,7 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
 
         case LFT_ADAPTED_REQUEST_HEADER:
 
-            if (al->request)
+            if (al->adapted_request)
                 sb = al->adapted_request->header.getByName(fmt->data.header.header);
 
             out = sb.termedBuf();
@@ -586,7 +586,7 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
 #if ICAP_CLIENT
         case LFT_ICAP_ADDR:
             if (!out)
-                out = al->icap.hostAddr.NtoA(tmp,1024);
+                out = al->icap.hostAddr.toStr(tmp,1024);
             break;
 
         case LFT_ICAP_SERV_NAME:
@@ -538,7 +538,7 @@ fqdncache_nbgethostbyaddr(const Ip::Address &addr, FQDNH * handler, void *handle
     fqdncache_entry *f = NULL;
     char name[MAX_IPSTRLEN];
     generic_cbdata *c;
-    addr.NtoA(name,MAX_IPSTRLEN);
+    addr.toStr(name,MAX_IPSTRLEN);
     debugs(35, 4, "fqdncache_nbgethostbyaddr: Name '" << name << "'.");
     ++FqdncacheStats.requests;
 
@@ -609,11 +609,11 @@ fqdncache_gethostbyaddr(const Ip::Address &addr, int flags)
     char name[MAX_IPSTRLEN];
     fqdncache_entry *f = NULL;
 
-    if (addr.IsAnyAddr() || addr.IsNoAddr()) {
+    if (addr.isAnyAddr() || addr.isNoAddr()) {
         return NULL;
     }
 
-    addr.NtoA(name,MAX_IPSTRLEN);
+    addr.toStr(name,MAX_IPSTRLEN);
     ++ FqdncacheStats.requests;
     f = fqdncache_get(name);
 
@@ -40,7 +40,7 @@
 #include "errorpage.h"
 #include "fd.h"
 #include "fde.h"
-#include "forward.h"
+#include "FwdState.h"
 #include "html_quote.h"
 #include "HttpHdrContRange.h"
 #include "HttpHeader.h"
@@ -2488,9 +2488,9 @@ ftpReadEPSV(FtpStateData* ftpState)
     // Generate a new data channel descriptor to be opened.
     Comm::ConnectionPointer conn = new Comm::Connection;
     conn->local = ftpState->ctrl.conn->local;
-    conn->local.SetPort(0);
+    conn->local.port(0);
     conn->remote = ftpState->ctrl.conn->remote;
-    conn->remote.SetPort(port);
+    conn->remote.port(port);
 
     debugs(9, 3, HERE << "connecting to " << conn->remote);
 
@@ -2555,7 +2555,7 @@ ftpSendPassive(FtpStateData * ftpState)
     switch (ftpState->state) {
     case SENT_EPSV_ALL: /* EPSV ALL resulted in a bad response. Try ther EPSV methods. */
         ftpState->flags.epsv_all_sent = true;
-        if (ftpState->ctrl.conn->local.IsIPv6()) {
+        if (ftpState->ctrl.conn->local.isIPv6()) {
             debugs(9, 5, HERE << "FTP Channel is IPv6 (" << ftpState->ctrl.conn->remote << ") attempting EPSV 2 after EPSV ALL has failed.");
             snprintf(cbuf, CTRL_BUFLEN, "EPSV 2\r\n");
             ftpState->state = SENT_EPSV_2;
@@ -2564,7 +2564,7 @@ ftpSendPassive(FtpStateData * ftpState)
         // else fall through to skip EPSV 2
 
     case SENT_EPSV_2: /* EPSV IPv6 failed. Try EPSV IPv4 */
-        if (ftpState->ctrl.conn->local.IsIPv4()) {
+        if (ftpState->ctrl.conn->local.isIPv4()) {
             debugs(9, 5, HERE << "FTP Channel is IPv4 (" << ftpState->ctrl.conn->remote << ") attempting EPSV 1 after EPSV ALL has failed.");
             snprintf(cbuf, CTRL_BUFLEN, "EPSV 1\r\n");
             ftpState->state = SENT_EPSV_1;
@@ -2594,12 +2594,12 @@ ftpSendPassive(FtpStateData * ftpState)
             /* block other non-EPSV connections being attempted */
             ftpState->flags.epsv_all_sent = true;
         } else {
-            if (ftpState->ctrl.conn->local.IsIPv6()) {
+            if (ftpState->ctrl.conn->local.isIPv6()) {
                 debugs(9, 5, HERE << "FTP Channel (" << ftpState->ctrl.conn->remote << "). Sending default EPSV 2");
                 snprintf(cbuf, CTRL_BUFLEN, "EPSV 2\r\n");
                 ftpState->state = SENT_EPSV_2;
             }
-            if (ftpState->ctrl.conn->local.IsIPv4()) {
+            if (ftpState->ctrl.conn->local.isIPv4()) {
                 debugs(9, 5, HERE << "Channel (" << ftpState->ctrl.conn->remote <<"). Sending default EPSV 1");
                 snprintf(cbuf, CTRL_BUFLEN, "EPSV 1\r\n");
                 ftpState->state = SENT_EPSV_1;
@@ -2689,7 +2689,7 @@ ftpReadPasv(FtpStateData * ftpState)
 
     ipa_remote = ipaddr;
 
-    if ( ipa_remote.IsAnyAddr() ) {
+    if ( ipa_remote.isAnyAddr() ) {
         debugs(9, DBG_IMPORTANT, "Unsafe PASV reply from " <<
                ftpState->ctrl.conn->remote << ": " <<
                ftpState->ctrl.last_reply);
@@ -2736,9 +2736,9 @@ ftpReadPasv(FtpStateData * ftpState)
 
     Comm::ConnectionPointer conn = new Comm::Connection;
     conn->local = ftpState->ctrl.conn->local;
-    conn->local.SetPort(0);
+    conn->local.port(0);
     conn->remote = ipaddr;
-    conn->remote.SetPort(port);
+    conn->remote.port(port);
 
     debugs(9, 3, HERE << "connecting to " << conn->remote);
 
@@ -2803,7 +2803,7 @@ ftpOpenListenSocket(FtpStateData * ftpState, int fallback)
         temp->flags |= COMM_REUSEADDR;
     } else {
         /* if not running in fallback mode a new port needs to be retrieved */
-        temp->local.SetPort(0);
+        temp->local.port(0);
     }
 
     ftpState->listenForDataChannel(temp, ftpState->entry->url());
@@ -2827,7 +2827,7 @@ ftpSendPORT(FtpStateData * ftpState)
     ftpOpenListenSocket(ftpState, 0);
 
     if (!Comm::IsConnOpen(ftpState->data.listenConn)) {
-        if ( ftpState->data.listenConn != NULL && !ftpState->data.listenConn->local.IsIPv4() ) {
+        if ( ftpState->data.listenConn != NULL && !ftpState->data.listenConn->local.isIPv4() ) {
             /* non-IPv4 CANNOT send PORT command.                       */
             /* we got here by attempting and failing an EPRT            */
             /* using the same reply code should simulate a PORT failure */
@@ -2844,7 +2844,7 @@ ftpSendPORT(FtpStateData * ftpState)
     // source them from the listen_conn->local
 
     struct addrinfo *AI = NULL;
-    ftpState->data.listenConn->local.GetAddrInfo(AI, AF_INET);
+    ftpState->data.listenConn->local.getAddrInfo(AI, AF_INET);
     unsigned char *addrptr = (unsigned char *) &((struct sockaddr_in*)AI->ai_addr)->sin_addr;
     unsigned char *portptr = (unsigned char *) &((struct sockaddr_in*)AI->ai_addr)->sin_port;
     snprintf(cbuf, CTRL_BUFLEN, "PORT %d,%d,%d,%d,%d,%d\r\n",
@@ -2853,7 +2853,7 @@ ftpSendPORT(FtpStateData * ftpState)
     ftpState->writeCommand(cbuf);
     ftpState->state = SENT_PORT;
 
-    ftpState->data.listenConn->local.FreeAddrInfo(AI);
+    Ip::Address::FreeAddrInfo(AI);
 }
 
 /// \ingroup ServerProtocolFTPInternal
@@ -2904,9 +2904,9 @@ ftpSendEPRT(FtpStateData * ftpState)
     /* RFC 2428 defines EPRT as IPv6 equivalent to IPv4 PORT command. */
     /* Which can be used by EITHER protocol. */
     snprintf(cbuf, CTRL_BUFLEN, "EPRT |%d|%s|%d|\r\n",
-             ( ftpState->data.listenConn->local.IsIPv6() ? 2 : 1 ),
-             ftpState->data.listenConn->local.NtoA(buf,MAX_IPSTRLEN),
-             ftpState->data.listenConn->local.GetPort() );
+             ( ftpState->data.listenConn->local.isIPv6() ? 2 : 1 ),
+             ftpState->data.listenConn->local.toStr(buf,MAX_IPSTRLEN),
+             ftpState->data.listenConn->local.port() );
 
     ftpState->writeCommand(cbuf);
     ftpState->state = SENT_EPRT;
@@ -2994,7 +2994,7 @@ FtpStateData::ftpAcceptDataConnection(const CommAcceptCbParams &io)
     data.close();
     data.opened(io.conn, dataCloser());
     static char ntoapeer[MAX_IPSTRLEN];
-    io.conn->remote.NtoA(ntoapeer,sizeof(ntoapeer));
+    io.conn->remote.toStr(ntoapeer,sizeof(ntoapeer));
     data.host = xstrdup(ntoapeer);
 
     debugs(9, 3, HERE << "Connected data socket on " <<
@@ -34,7 +34,7 @@
 #include "comm/Write.h"
 #include "errorpage.h"
 #include "fd.h"
-#include "forward.h"
+#include "FwdState.h"
 #include "globals.h"
 #include "html_quote.h"
 #include "HttpReply.h"
@@ -850,7 +850,7 @@ htcpAccessAllowed(acl_access * acl, htcpSpecifier * s, Ip::Address &from)
 
     ACLFilledChecklist checklist(acl, s->request, NULL);
     checklist.src_addr = from;
-    checklist.my_addr.SetNoAddr();
+    checklist.my_addr.setNoAddr();
     return (checklist.fastCheck() == ACCESS_ALLOWED);
 }
 
@@ -1121,7 +1121,7 @@ htcpHandleTstResponse(htcpDataHeader * hdr, char *buf, int sz, Ip::Address &from
 
     peer = &queried_addr[hdr->msg_id % N_QUERIED_KEYS];
 
-    if ( *peer != from || peer->GetPort() != from.GetPort() ) {
+    if ( *peer != from || peer->port() != from.port() ) {
         debugs(31, 3, "htcpHandleTstResponse: Unexpected response source " << from );
         return;
     }
@@ -1485,15 +1485,15 @@ htcpOpenPorts(void)
 
     htcpIncomingConn = new Comm::Connection;
     htcpIncomingConn->local = Config.Addrs.udp_incoming;
-    htcpIncomingConn->local.SetPort(Config.Port.htcp);
+    htcpIncomingConn->local.port(Config.Port.htcp);
 
-    if (!Ip::EnableIpv6 && !htcpIncomingConn->local.SetIPv4()) {
+    if (!Ip::EnableIpv6 && !htcpIncomingConn->local.setIPv4()) {
         debugs(31, DBG_CRITICAL, "ERROR: IPv6 is disabled. " << htcpIncomingConn->local << " is not an IPv4 address.");
         fatal("HTCP port cannot be opened.");
     }
     /* split-stack for now requires default IPv4-only HTCP */
-    if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && htcpIncomingConn->local.IsAnyAddr()) {
-        htcpIncomingConn->local.SetIPv4();
+    if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && htcpIncomingConn->local.isAnyAddr()) {
+        htcpIncomingConn->local.setIPv4();
     }
 
     AsyncCall::Pointer call = asyncCall(31, 2,
@@ -1505,18 +1505,18 @@ htcpOpenPorts(void)
                         htcpIncomingConn,
                         Ipc::fdnInHtcpSocket, call);
 
-    if (!Config.Addrs.udp_outgoing.IsNoAddr()) {
+    if (!Config.Addrs.udp_outgoing.isNoAddr()) {
         htcpOutgoingConn = new Comm::Connection;
         htcpOutgoingConn->local = Config.Addrs.udp_outgoing;
-        htcpOutgoingConn->local.SetPort(Config.Port.htcp);
+        htcpOutgoingConn->local.port(Config.Port.htcp);
 
-        if (!Ip::EnableIpv6 && !htcpOutgoingConn->local.SetIPv4()) {
+        if (!Ip::EnableIpv6 && !htcpOutgoingConn->local.setIPv4()) {
             debugs(31, DBG_CRITICAL, "ERROR: IPv6 is disabled. " << htcpOutgoingConn->local << " is not an IPv4 address.");
             fatal("HTCP port cannot be opened.");
         }
         /* split-stack for now requires default IPv4-only HTCP */
-        if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && htcpOutgoingConn->local.IsAnyAddr()) {
-            htcpOutgoingConn->local.SetIPv4();
+        if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && htcpOutgoingConn->local.isAnyAddr()) {
+            htcpOutgoingConn->local.setIPv4();
         }
 
         enter_suid();
@@ -1546,7 +1546,7 @@ htcpIncomingConnectionOpened(const Comm::ConnectionPointer &conn, int)
 
     debugs(31, DBG_CRITICAL, "Accepting HTCP messages on " << conn->local);
 
-    if (Config.Addrs.udp_outgoing.IsNoAddr()) {
+    if (Config.Addrs.udp_outgoing.isNoAddr()) {
         htcpOutgoingConn = conn;
         debugs(31, DBG_IMPORTANT, "Sending HTCP messages from " << htcpOutgoingConn->local);
     }
@@ -1770,21 +1770,21 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
 
         if (strcmp(opt_forwarded_for, "on") == 0) {
             /** If set to ON - append client IP or 'unknown'. */
-            if ( request->client_addr.IsNoAddr() )
+            if ( request->client_addr.isNoAddr() )
                 strListAdd(&strFwd, "unknown", ',');
             else
-                strListAdd(&strFwd, request->client_addr.NtoA(ntoabuf, MAX_IPSTRLEN), ',');
+                strListAdd(&strFwd, request->client_addr.toStr(ntoabuf, MAX_IPSTRLEN), ',');
         } else if (strcmp(opt_forwarded_for, "off") == 0) {
             /** If set to OFF - append 'unknown'. */
             strListAdd(&strFwd, "unknown", ',');
         } else if (strcmp(opt_forwarded_for, "transparent") == 0) {
             /** If set to TRANSPARENT - pass through unchanged. */
         } else if (strcmp(opt_forwarded_for, "truncate") == 0) {
             /** If set to TRUNCATE - drop existing list and replace with client IP or 'unknown'. */
-            if ( request->client_addr.IsNoAddr() )
+            if ( request->client_addr.isNoAddr() )
                 strFwd = "unknown";
             else
-                strFwd = request->client_addr.NtoA(ntoabuf, MAX_IPSTRLEN);
+                strFwd = request->client_addr.toStr(ntoabuf, MAX_IPSTRLEN);
         }
         if (strFwd.size() > 0)
             hdr_out->putStr(HDR_X_FORWARDED_FOR, strFwd.termedBuf());
@@ -137,7 +137,7 @@ Icmp4::SendEcho(Ip::Address &to, int opcode, const char *payload, int len)
 
     icmp->icmp_cksum = CheckSum((unsigned short *) icmp, icmp_pktsize);
 
-    to.GetAddrInfo(S);
+    to.getAddrInfo(S);
     ((sockaddr_in*)S->ai_addr)->sin_port = 0;
     assert(icmp_pktsize <= MAX_PKT4_SZ);
 
@@ -155,7 +155,7 @@ Icmp4::SendEcho(Ip::Address &to, int opcode, const char *payload, int len)
     }
 
     Log(to, ' ', NULL, 0, 0);
-    to.FreeAddrInfo(S);
+    Ip::Address::FreeAddrInfo(S);
 }
 
 void
@@ -179,7 +179,7 @@ Icmp4::Recv(void)
     if (pkt == NULL)
         pkt = (char *)xmalloc(MAX_PKT4_SZ);
 
-    preply.from.InitAddrInfo(from);
+    Ip::Address::InitAddrInfo(from);
     n = recvfrom(icmp_sock,
                  (void *)pkt,
                  MAX_PKT4_SZ,
@@ -222,12 +222,12 @@ Icmp4::Recv(void)
     icmp = (struct icmphdr *) (void *) (pkt + iphdrlen);
 
     if (icmp->icmp_type != ICMP_ECHOREPLY) {
-        preply.from.FreeAddrInfo(from);
+        Ip::Address::FreeAddrInfo(from);
         return;
     }
 
     if (icmp->icmp_id != icmp_ident) {
-        preply.from.FreeAddrInfo(from);
+        Ip::Address::FreeAddrInfo(from);
         return;
     }
 
@@ -246,7 +246,7 @@ Icmp4::Recv(void)
     control.SendResult(preply, (sizeof(pingerReplyData) - MAX_PKT4_SZ + preply.psize) );
 
     Log(preply.from, icmp->icmp_type, icmpPktStr[icmp->icmp_type], preply.rtt, preply.hops);
-    preply.from.FreeAddrInfo(from);
+    Ip::Address::FreeAddrInfo(from);
 }
 
 #endif /* USE_ICMP */
@@ -180,7 +180,7 @@ Icmp6::SendEcho(Ip::Address &to, int opcode, const char *payload, int len)
 
     icmp->icmp6_cksum = CheckSum((unsigned short *) icmp, icmp6_pktsize);
 
-    to.GetAddrInfo(S);
+    to.getAddrInfo(S);
     ((sockaddr_in6*)S->ai_addr)->sin6_port = 0;
 
     assert(icmp6_pktsize <= MAX_PKT6_SZ);
@@ -200,7 +200,7 @@ Icmp6::SendEcho(Ip::Address &to, int opcode, const char *payload, int len)
     debugs(42,9, HERE << "x=" << x);
 
     Log(to, 0, NULL, 0, 0);
-    to.FreeAddrInfo(S);
+    Ip::Address::FreeAddrInfo(S);
 }
 
 /**
@@ -227,7 +227,7 @@ Icmp6::Recv(void)
         pkt = (char *)xmalloc(MAX_PKT6_SZ);
     }
 
-    preply.from.InitAddrInfo(from);
+    Ip::Address::InitAddrInfo(from);
 
     n = recvfrom(icmp_sock,
                  (void *)pkt,
@@ -294,13 +294,13 @@ Icmp6::Recv(void)
                    ( icmp6header->icmp6_type&0x80 ? icmp6HighPktStr[(int)(icmp6header->icmp6_type&0x7f)] : icmp6LowPktStr[(int)(icmp6header->icmp6_type&0x7f)] )
                   );
         }
-        preply.from.FreeAddrInfo(from);
+        Ip::Address::FreeAddrInfo(from);
         return;
     }
 
     if (icmp6header->icmp6_id != icmp_ident) {
         debugs(42, 8, HERE << "dropping Icmp6 read. IDENT check failed. ident=='" << icmp_ident << "'=='" << icmp6header->icmp6_id << "'");
-        preply.from.FreeAddrInfo(from);
+        Ip::Address::FreeAddrInfo(from);
         return;
     }
 
@@ -337,7 +337,7 @@ Icmp6::Recv(void)
 
     /* send results of the lookup back to squid.*/
     control.SendResult(preply, (sizeof(pingerReplyData) - PINGER_PAYLOAD_SZ + preply.psize) );
-    preply.from.FreeAddrInfo(from);
+    Ip::Address::FreeAddrInfo(from);
 }
 
 #endif /* USE_ICMP */
@@ -209,7 +209,7 @@ IcmpPinger::Recv(void)
     }
 
     /* pass request for ICMPv6 handing */
-    if (pecho.to.IsIPv6()) {
+    if (pecho.to.isIPv6()) {
         debugs(42, 2, HERE << " Pass " << pecho.to << " off to ICMPv6 module.");
         icmp6.SendEcho(pecho.to,
                        pecho.opcode,
@@ -218,7 +218,7 @@ IcmpPinger::Recv(void)
     }
 
     /* pass the packet for ICMP handling */
-    else if (pecho.to.IsIPv4()) {
+    else if (pecho.to.isIPv4()) {
         debugs(42, 2, HERE << " Pass " << pecho.to << " off to ICMPv4 module.");
         icmp4.SendEcho(pecho.to,
                        pecho.opcode,
@@ -177,7 +177,7 @@ IcmpSquid::Recv()
 
     F = preply.from;
 
-    F.SetPort(0);
+    F.port(0);
 
     switch (preply.opcode) {
 
@@ -224,7 +224,7 @@ IcmpSquid::Open(void)
 
     args[0] = "(pinger)";
     args[1] = NULL;
-    localhost.SetLocalhost();
+    localhost.setLocalhost();
 
     /*
      * Do NOT use IPC_DGRAM (=IPC_UNIX_DGRAM) here because you can't
@@ -258,7 +258,7 @@ IcmpSquid::Open(void)
     /* Tests the pinger immediately using localhost */
     if (Ip::EnableIpv6)
         SendEcho(localhost, S_ICMP_ECHO, "ip6-localhost");
-    if (localhost.SetIPv4())
+    if (localhost.setIPv4())
         SendEcho(localhost, S_ICMP_ECHO, "localhost");
 
 #if _SQUID_WINDOWS_
@@ -44,7 +44,7 @@
 #include "disk.h"
 #include "event.h"
 #include "fde.h"
-#include "forward.h"
+#include "FwdState.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "icmp/net_db.h"
@@ -126,7 +126,7 @@ static wordlist *peer_names = NULL;
 static void
 netdbHashInsert(netdbEntry * n, Ip::Address &addr)
 {
-    networkFromInaddr(addr).NtoA(n->network, MAX_IPSTRLEN);
+    networkFromInaddr(addr).toStr(n->network, MAX_IPSTRLEN);
     n->hash.key = n->network;
     assert(hash_lookup(addr_table, n->network) == NULL);
     hash_join(addr_table, &n->hash);
@@ -264,7 +264,7 @@ netdbLookupAddr(const Ip::Address &addr)
 {
     netdbEntry *n;
     char *key = new char[MAX_IPSTRLEN];
-    networkFromInaddr(addr).NtoA(key,MAX_IPSTRLEN);
+    networkFromInaddr(addr).toStr(key,MAX_IPSTRLEN);
     n = (netdbEntry *) hash_lookup(addr_table, key);
     delete[] key;
     return n;
@@ -362,16 +362,16 @@ networkFromInaddr(const Ip::Address &in)
     out = in;
 
     /* in IPv6 the 'network' should be the routing section. */
-    if ( in.IsIPv6() ) {
-        out.ApplyMask(64, AF_INET6);
+    if ( in.isIPv6() ) {
+        out.applyMask(64, AF_INET6);
         debugs(14, 5, "networkFromInaddr : Masked IPv6 Address to " << in << "/64 routing part.");
         return out;
     }
 
 #if USE_CLASSFUL
     struct in_addr b;
 
-    in.GetInAddr(b);
+    in.getInAddr(b);
 
     if (IN_CLASSC(b.s_addr))
         b.s_addr &= IN_CLASSC_NET;
@@ -387,7 +387,7 @@ networkFromInaddr(const Ip::Address &in)
     debugs(14, 5, "networkFromInaddr : Masked IPv4 Address to " << out << "/24.");
 
     /* use /24 for everything under IPv4 */
-    out.ApplyMask(24, AF_INET);
+    out.applyMask(24, AF_INET);
     debugs(14, 5, "networkFromInaddr : Masked IPv4 Address to " << in << "/24.");
 
     return out;
@@ -782,7 +782,7 @@ netdbExchangeHandleReply(void *data, StoreIOBuffer receivedData)
 
     while (size >= rec_sz) {
         debugs(38, 5, "netdbExchangeHandleReply: in parsing loop, size = " << size);
-        addr.SetAnyAddr();
+        addr.setAnyAddr();
         hops = rtt = 0.0;
 
         for (o = 0; o < rec_sz;) {
@@ -817,7 +817,7 @@ netdbExchangeHandleReply(void *data, StoreIOBuffer receivedData)
             }
         }
 
-        if (!addr.IsAnyAddr() && rtt > 0)
+        if (!addr.isAnyAddr() && rtt > 0)
             netdbExchangeUpdatePeer(addr, ex->p, rtt, hops);
 
         assert(o == rec_sz);
@@ -1152,7 +1152,7 @@ netdbExchangeUpdatePeer(Ip::Address &addr, CachePeer * e, double rtt, double hop
            std::setfill('0')<< std::setprecision(2) << hops << " hops, " <<
            rtt << " rtt");
 
-    if ( !addr.IsIPv4() ) {
+    if ( !addr.isIPv4() ) {
         debugs(38, 5, "netdbExchangeUpdatePeer: Aborting peer update for '" << addr << "', NetDB cannot handle IPv6.");
         return;
     }
@@ -1236,13 +1236,13 @@ netdbBinaryExchange(StoreEntry * s)
             continue;
 
         /* FIXME INET6 : NetDB cannot yet handle IPv6 addresses. Ensure only IPv4 get sent. */
-        if ( !addr.IsIPv4() )
+        if ( !addr.isIPv4() )
             continue;
 
         buf[i] = (char) NETDB_EX_NETWORK;
         ++i;
 
-        addr.GetInAddr(line_addr);
+        addr.getInAddr(line_addr);
         memcpy(&buf[i], &line_addr, sizeof(struct in_addr));
 
         i += sizeof(struct in_addr);
@@ -437,7 +437,7 @@ icpAccessAllowed(Ip::Address &from, HttpRequest * icp_request)
 
     ACLFilledChecklist checklist(Config.accessList.icp, icp_request, NULL);
     checklist.src_addr = from;
-    checklist.my_addr.SetNoAddr();
+    checklist.my_addr.setNoAddr();
     return (checklist.fastCheck() == ACCESS_ALLOWED);
 }
 
@@ -684,15 +684,15 @@ icpOpenPorts(void)
 
     icpIncomingConn = new Comm::Connection;
     icpIncomingConn->local = Config.Addrs.udp_incoming;
-    icpIncomingConn->local.SetPort(port);
+    icpIncomingConn->local.port(port);
 
-    if (!Ip::EnableIpv6 && !icpIncomingConn->local.SetIPv4()) {
+    if (!Ip::EnableIpv6 && !icpIncomingConn->local.setIPv4()) {
         debugs(12, DBG_CRITICAL, "ERROR: IPv6 is disabled. " << icpIncomingConn->local << " is not an IPv4 address.");
         fatal("ICP port cannot be opened.");
     }
     /* split-stack for now requires default IPv4-only ICP */
-    if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && icpIncomingConn->local.IsAnyAddr()) {
-        icpIncomingConn->local.SetIPv4();
+    if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && icpIncomingConn->local.isAnyAddr()) {
+        icpIncomingConn->local.setIPv4();
     }
 
     AsyncCall::Pointer call = asyncCall(12, 2,
@@ -704,18 +704,18 @@ icpOpenPorts(void)
                         icpIncomingConn,
                         Ipc::fdnInIcpSocket, call);
 
-    if ( !Config.Addrs.udp_outgoing.IsNoAddr() ) {
+    if ( !Config.Addrs.udp_outgoing.isNoAddr() ) {
         icpOutgoingConn = new Comm::Connection;
         icpOutgoingConn->local = Config.Addrs.udp_outgoing;
-        icpOutgoingConn->local.SetPort(port);
+        icpOutgoingConn->local.port(port);
 
-        if (!Ip::EnableIpv6 && !icpOutgoingConn->local.SetIPv4()) {
+        if (!Ip::EnableIpv6 && !icpOutgoingConn->local.setIPv4()) {
             debugs(49, DBG_CRITICAL, "ERROR: IPv6 is disabled. " << icpOutgoingConn->local << " is not an IPv4 address.");
             fatal("ICP port cannot be opened.");
         }
         /* split-stack for now requires default IPv4-only ICP */
-        if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && icpOutgoingConn->local.IsAnyAddr()) {
-            icpOutgoingConn->local.SetIPv4();
+        if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && icpOutgoingConn->local.isAnyAddr()) {
+            icpOutgoingConn->local.setIPv4();
         }
 
         enter_suid();
@@ -747,7 +747,7 @@ icpIncomingConnectionOpened(const Comm::ConnectionPointer &conn, int errNo)
 
     fd_note(conn->fd, "Incoming ICP port");
 
-    if (Config.Addrs.udp_outgoing.IsNoAddr()) {
+    if (Config.Addrs.udp_outgoing.isNoAddr()) {
         icpOutgoingConn = conn;
         debugs(12, DBG_IMPORTANT, "Sending ICP messages from " << icpOutgoingConn->local);
     }
@@ -238,8 +238,8 @@ Ident::Start(const Comm::ConnectionPointer &conn, IDCB * callback, void *data)
     char key2[IDENT_KEY_SZ];
     char key[IDENT_KEY_SZ];
 
-    conn->local.ToURL(key1, IDENT_KEY_SZ);
-    conn->remote.ToURL(key2, IDENT_KEY_SZ);
+    conn->local.toUrl(key1, IDENT_KEY_SZ);
+    conn->remote.toUrl(key2, IDENT_KEY_SZ);
     snprintf(key, IDENT_KEY_SZ, "%s,%s", key1, key2);
 
     if (!ident_hash) {
@@ -257,12 +257,12 @@ Ident::Start(const Comm::ConnectionPointer &conn, IDCB * callback, void *data)
     // copy the conn details. We dont want the original FD to be re-used by IDENT.
     state->conn = conn->copyDetails();
     // NP: use random port for secure outbound to IDENT_PORT
-    state->conn->local.SetPort(0);
-    state->conn->remote.SetPort(IDENT_PORT);
+    state->conn->local.port(0);
+    state->conn->remote.port(IDENT_PORT);
 
     // build our query from the original connection details
     state->queryMsg.init();
-    state->queryMsg.Printf("%d, %d\r\n", conn->remote.GetPort(), conn->local.GetPort());
+    state->queryMsg.Printf("%d, %d\r\n", conn->remote.port(), conn->local.port());
 
     ClientAdd(state, callback, data);
     hash_join(ident_hash, &state->hash);
@@ -108,8 +108,8 @@ internalRemoteUri(const char *host, unsigned short port, const char *dir, const
 
     /* check for an IP address and format appropriately if found */
     Ip::Address test = lc_host;
-    if ( !test.IsAnyAddr() ) {
-        test.ToHostname(lc_host,SQUIDHOSTNAMELEN);
+    if ( !test.isAnyAddr() ) {
+        test.toHostStr(lc_host,SQUIDHOSTNAMELEN);
     }
 
     /*
@@ -1,39 +1,8 @@
 /*
  * DEBUG: section 14    IP Storage and Handling
  * AUTHOR: Amos Jeffries
- *
- * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from the
- *  Internet community.  Development is led by Duane Wessels of the
- *  National Laboratory for Applied Network Research and funded by the
- *  National Science Foundation.  Squid is Copyrighted (C) 1998 by
- *  the Regents of the University of California.  Please see the
- *  COPYRIGHT file for full details.  Squid incorporates software
- *  developed and/or copyrighted by other sources.  Please see the
- *  CREDITS file for full details.
- *
- *  This Ip::Address code is copyright (C) 2007 by Treehouse Networks Ltd
- *  of New Zealand. It is published and Lisenced as an extension of
- *  squid under the same conditions as the main squid application.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
+ * COPYRIGHT: GPL version 2, (C)2007-2013 Treehouse Networks Ltd.
  */
-
 #include "squid.h"
 #include "compat/inet_ntop.h"
 #include "compat/getaddrinfo.h"
@@ -56,20 +25,20 @@
 /* Debugging only. Dump the address content when a fatal assert is encountered. */
 #define IASSERT(a,b)  \
 	if(!(b)){	printf("assert \"%s\" at line %d\n", a, __LINE__); \
-		printf("Ip::Address invalid? with IsIPv4()=%c, IsIPv6()=%c\n",(IsIPv4()?'T':'F'),(IsIPv6()?'T':'F')); \
+		printf("Ip::Address invalid? with isIPv4()=%c, isIPv6()=%c\n",(isIPv4()?'T':'F'),(isIPv6()?'T':'F')); \
 		printf("ADDRESS:"); \
-		for(unsigned int i = 0; i < sizeof(m_SocketAddr.sin6_addr); ++i) { \
-			printf(" %x", m_SocketAddr.sin6_addr.s6_addr[i]); \
+		for(unsigned int i = 0; i < sizeof(mSocketAddr_.sin6_addr); ++i) { \
+			printf(" %x", mSocketAddr_.sin6_addr.s6_addr[i]); \
 		} printf("\n"); assert(b); \
 	}
 
 int
-Ip::Address::GetCIDR() const
+Ip::Address::cidr() const
 {
     uint8_t shift,byte;
     uint8_t bit,caught;
     int len = 0;
-    const uint8_t *ptr= m_SocketAddr.sin6_addr.s6_addr;
+    const uint8_t *ptr= mSocketAddr_.sin6_addr.s6_addr;
 
     /* Let's scan all the bits from Most Significant to Least */
     /* Until we find an "0" bit. Then, we return */
@@ -78,11 +47,11 @@ Ip::Address::GetCIDR() const
     /* return IPv4 CIDR for any Mapped address */
     /* Thus only check the mapped bit */
 
-    if ( !IsIPv6() ) {
+    if ( !isIPv6() ) {
         shift = 12;
     }
 
-    for (; shift<sizeof(m_SocketAddr.sin6_addr) ; ++shift) {
+    for (; shift<sizeof(mSocketAddr_.sin6_addr) ; ++shift) {
         byte= *(ptr+shift);
 
         if (byte == 0xFF) {
@@ -107,11 +76,11 @@ Ip::Address::GetCIDR() const
 }
 
 int
-Ip::Address::ApplyMask(Ip::Address const &mask_addr)
+Ip::Address::applyMask(Ip::Address const &mask_addr)
 {
-    uint32_t *p1 = (uint32_t*)(&m_SocketAddr.sin6_addr);
-    uint32_t const *p2 = (uint32_t const *)(&mask_addr.m_SocketAddr.sin6_addr);
-    unsigned int blen = sizeof(m_SocketAddr.sin6_addr)/sizeof(uint32_t);
+    uint32_t *p1 = (uint32_t*)(&mSocketAddr_.sin6_addr);
+    uint32_t const *p2 = (uint32_t const *)(&mask_addr.mSocketAddr_.sin6_addr);
+    unsigned int blen = sizeof(mSocketAddr_.sin6_addr)/sizeof(uint32_t);
     unsigned int changes = 0;
 
     for (unsigned int i = 0; i < blen; ++i) {
@@ -125,33 +94,33 @@ Ip::Address::ApplyMask(Ip::Address const &mask_addr)
 }
 
 bool
-Ip::Address::ApplyMask(const unsigned int cidr, int mtype)
+Ip::Address::applyMask(const unsigned int cidrMask, int mtype)
 {
     uint8_t clearbits = 0;
     uint8_t* p = NULL;
 
     // validation and short-cuts.
-    if (cidr > 128)
+    if (cidrMask > 128)
         return false;
 
-    if (cidr > 32 && mtype == AF_INET)
+    if (cidrMask > 32 && mtype == AF_INET)
         return false;
 
-    if (cidr == 0) {
+    if (cidrMask == 0) {
         /* CIDR /0 is NoAddr regardless of the IPv4/IPv6 protocol */
-        SetNoAddr();
+        setNoAddr();
         return true;
     }
 
-    clearbits = (uint8_t)( (mtype==AF_INET6?128:32) -cidr);
+    clearbits = (uint8_t)( (mtype==AF_INET6?128:32) - cidrMask);
 
     // short-cut
     if (clearbits == 0)
         return true;
 
-    p = (uint8_t*)(&m_SocketAddr.sin6_addr) + 15;
+    p = (uint8_t*)(&mSocketAddr_.sin6_addr) + 15;
 
-    for (; clearbits>0 && p >= (uint8_t*)&m_SocketAddr.sin6_addr ; --p ) {
+    for (; clearbits>0 && p >= (uint8_t*)&mSocketAddr_.sin6_addr ; --p ) {
         if (clearbits < 8) {
             *p &= ((0xFF << clearbits) & 0xFF);
             clearbits = 0;
@@ -165,41 +134,41 @@ Ip::Address::ApplyMask(const unsigned int cidr, int mtype)
 }
 
 bool
-Ip::Address::IsSockAddr() const
+Ip::Address::isSockAddr() const
 {
-    return (m_SocketAddr.sin6_port != 0);
+    return (mSocketAddr_.sin6_port != 0);
 }
 
 bool
-Ip::Address::IsIPv4() const
+Ip::Address::isIPv4() const
 {
-    return IN6_IS_ADDR_V4MAPPED( &m_SocketAddr.sin6_addr );
+    return IN6_IS_ADDR_V4MAPPED( &mSocketAddr_.sin6_addr );
 }
 
 bool
-Ip::Address::IsIPv6() const
+Ip::Address::isIPv6() const
 {
-    return !IsIPv4();
+    return !isIPv4();
 }
 
 bool
-Ip::Address::IsAnyAddr() const
+Ip::Address::isAnyAddr() const
 {
-    return IN6_IS_ADDR_UNSPECIFIED(&m_SocketAddr.sin6_addr) || IN6_ARE_ADDR_EQUAL(&m_SocketAddr.sin6_addr, &v4_anyaddr);
+    return IN6_IS_ADDR_UNSPECIFIED(&mSocketAddr_.sin6_addr) || IN6_ARE_ADDR_EQUAL(&mSocketAddr_.sin6_addr, &v4_anyaddr);
 }
 
 /// NOTE: Does NOT clear the Port stored. Ony the Address and Type.
 void
-Ip::Address::SetAnyAddr()
+Ip::Address::setAnyAddr()
 {
-    memset(&m_SocketAddr.sin6_addr, 0, sizeof(struct in6_addr) );
+    memset(&mSocketAddr_.sin6_addr, 0, sizeof(struct in6_addr) );
 }
 
 /// NOTE: completely empties the Ip::Address structure. Address, Port, Type, everything.
 void
-Ip::Address::SetEmpty()
+Ip::Address::setEmpty()
 {
-    memset(&m_SocketAddr, 0, sizeof(m_SocketAddr) );
+    memset(&mSocketAddr_, 0, sizeof(mSocketAddr_) );
 }
 
 #if _SQUID_AIX_
@@ -225,82 +194,82 @@ const struct in6_addr Ip::Address::v6_noaddr = {{{ 0xff, 0xff, 0xff, 0xff, 0xff,
 #endif
 
 bool
-Ip::Address::SetIPv4()
+Ip::Address::setIPv4()
 {
-    if ( IsLocalhost() ) {
-        m_SocketAddr.sin6_addr = v4_localhost;
+    if ( isLocalhost() ) {
+        mSocketAddr_.sin6_addr = v4_localhost;
         return true;
     }
 
-    if ( IsAnyAddr() ) {
-        m_SocketAddr.sin6_addr = v4_anyaddr;
+    if ( isAnyAddr() ) {
+        mSocketAddr_.sin6_addr = v4_anyaddr;
         return true;
     }
 
-    if ( IsNoAddr() ) {
-        m_SocketAddr.sin6_addr = v4_noaddr;
+    if ( isNoAddr() ) {
+        mSocketAddr_.sin6_addr = v4_noaddr;
         return true;
     }
 
-    if ( IsIPv4())
+    if ( isIPv4())
         return true;
 
     // anything non-IPv4 and non-convertable is BAD.
     return false;
 }
 
 bool
-Ip::Address::IsLocalhost() const
+Ip::Address::isLocalhost() const
 {
-    return IN6_IS_ADDR_LOOPBACK( &m_SocketAddr.sin6_addr ) || IN6_ARE_ADDR_EQUAL( &m_SocketAddr.sin6_addr, &v4_localhost );
+    return IN6_IS_ADDR_LOOPBACK( &mSocketAddr_.sin6_addr ) || IN6_ARE_ADDR_EQUAL( &mSocketAddr_.sin6_addr, &v4_localhost );
 }
 
 void
-Ip::Address::SetLocalhost()
+Ip::Address::setLocalhost()
 {
     if (Ip::EnableIpv6) {
-        m_SocketAddr.sin6_addr = in6addr_loopback;
-        m_SocketAddr.sin6_family = AF_INET6;
+        mSocketAddr_.sin6_addr = in6addr_loopback;
+        mSocketAddr_.sin6_family = AF_INET6;
     } else {
-        m_SocketAddr.sin6_addr = v4_localhost;
-        m_SocketAddr.sin6_family = AF_INET;
+        mSocketAddr_.sin6_addr = v4_localhost;
+        mSocketAddr_.sin6_family = AF_INET;
     }
 }
 
 bool
-Ip::Address::IsSiteLocal6() const
+Ip::Address::isSiteLocal6() const
 {
     // RFC 4193 the site-local allocated range is fc00::/7
     // with fd00::/8 as the only currently allocated range (so we test it first).
     // BUG: as of 2010-02 Linux and BSD define IN6_IS_ADDR_SITELOCAL() to check for fec::/10
-    return m_SocketAddr.sin6_addr.s6_addr[0] == static_cast<uint8_t>(0xfd) ||
-           m_SocketAddr.sin6_addr.s6_addr[0] == static_cast<uint8_t>(0xfc);
+    return mSocketAddr_.sin6_addr.s6_addr[0] == static_cast<uint8_t>(0xfd) ||
+           mSocketAddr_.sin6_addr.s6_addr[0] == static_cast<uint8_t>(0xfc);
 }
 
 bool
-Ip::Address::IsSlaac() const
+Ip::Address::isSiteLocalAuto() const
 {
-    return m_SocketAddr.sin6_addr.s6_addr[10] == static_cast<uint8_t>(0xff) &&
-           m_SocketAddr.sin6_addr.s6_addr[11] == static_cast<uint8_t>(0xfe);
+    return mSocketAddr_.sin6_addr.s6_addr[10] == static_cast<uint8_t>(0xff) &&
+           mSocketAddr_.sin6_addr.s6_addr[11] == static_cast<uint8_t>(0xfe);
 }
 
 bool
-Ip::Address::IsNoAddr() const
+Ip::Address::isNoAddr() const
 {
     // IFF the address == 0xff..ff (all ones)
-    return IN6_ARE_ADDR_EQUAL( &m_SocketAddr.sin6_addr, &v6_noaddr )
-           || IN6_ARE_ADDR_EQUAL( &m_SocketAddr.sin6_addr, &v4_noaddr );
+    return IN6_ARE_ADDR_EQUAL( &mSocketAddr_.sin6_addr, &v6_noaddr )
+           || IN6_ARE_ADDR_EQUAL( &mSocketAddr_.sin6_addr, &v4_noaddr );
 }
 
 void
-Ip::Address::SetNoAddr()
+Ip::Address::setNoAddr()
 {
-    memset(&m_SocketAddr.sin6_addr, 0xFF, sizeof(struct in6_addr) );
-    m_SocketAddr.sin6_family = AF_INET6;
+    memset(&mSocketAddr_.sin6_addr, 0xFF, sizeof(struct in6_addr) );
+    mSocketAddr_.sin6_family = AF_INET6;
 }
 
 bool
-Ip::Address::GetReverseString6(char buf[MAX_IPSTRLEN], const struct in6_addr &dat) const
+Ip::Address::getReverseString6(char buf[MAX_IPSTRLEN], const struct in6_addr &dat) const
 {
     char *p = buf;
     unsigned char const *r = dat.s6_addr;
@@ -327,7 +296,7 @@ Ip::Address::GetReverseString6(char buf[MAX_IPSTRLEN], const struct in6_addr &da
 }
 
 bool
-Ip::Address::GetReverseString4(char buf[MAX_IPSTRLEN], const struct in_addr &dat) const
+Ip::Address::getReverseString4(char buf[MAX_IPSTRLEN], const struct in_addr &dat) const
 {
     unsigned int i = (unsigned int) ntohl(dat.s_addr);
     snprintf(buf, 32, "%u.%u.%u.%u.in-addr.arpa.",
@@ -339,21 +308,21 @@ Ip::Address::GetReverseString4(char buf[MAX_IPSTRLEN], const struct in_addr &dat
 }
 
 bool
-Ip::Address::GetReverseString(char buf[MAX_IPSTRLEN], int show_type) const
+Ip::Address::getReverseString(char buf[MAX_IPSTRLEN], int show_type) const
 {
 
     if (show_type == AF_UNSPEC) {
-        show_type = IsIPv6() ? AF_INET6 : AF_INET ;
+        show_type = isIPv6() ? AF_INET6 : AF_INET ;
     }
 
-    if (show_type == AF_INET && IsIPv4()) {
-        struct in_addr* tmp = (struct in_addr*)&m_SocketAddr.sin6_addr.s6_addr[12];
-        return GetReverseString4(buf, *tmp);
-    } else if ( show_type == AF_INET6 && IsIPv6() ) {
-        return GetReverseString6(buf, m_SocketAddr.sin6_addr);
+    if (show_type == AF_INET && isIPv4()) {
+        struct in_addr* tmp = (struct in_addr*)&mSocketAddr_.sin6_addr.s6_addr[12];
+        return getReverseString4(buf, *tmp);
+    } else if ( show_type == AF_INET6 && isIPv6() ) {
+        return getReverseString6(buf, mSocketAddr_.sin6_addr);
     }
 
-    debugs(14, DBG_CRITICAL, "Unable to convert '" << NtoA(buf,MAX_IPSTRLEN) << "' to the rDNS type requested.");
+    debugs(14, DBG_CRITICAL, "Unable to convert '" << toStr(buf,MAX_IPSTRLEN) << "' to the rDNS type requested.");
 
     buf[0] = '\0';
 
@@ -369,76 +338,66 @@ Ip::Address::operator =(const Ip::Address &s)
 
 Ip::Address::Address(const char*s)
 {
-    SetEmpty();
-    LookupHostIP(s, true);
+    setEmpty();
+    lookupHostIP(s, true);
 }
 
 bool
 Ip::Address::operator =(const char* s)
 {
-    return LookupHostIP(s, true);
+    return lookupHostIP(s, true);
 }
 
 bool
 Ip::Address::GetHostByName(const char* s)
 {
-    return LookupHostIP(s, false);
+    return lookupHostIP(s, false);
 }
 
 bool
-Ip::Address::LookupHostIP(const char *s, bool nodns)
+Ip::Address::lookupHostIP(const char *s, bool nodns)
 {
-    int err = 0;
-
-    short port = 0;
-
-    struct addrinfo *res = NULL;
-
     struct addrinfo want;
-
     memset(&want, 0, sizeof(struct addrinfo));
     if (nodns) {
         want.ai_flags = AI_NUMERICHOST; // prevent actual DNS lookups!
     }
 
+    int err = 0;
+    struct addrinfo *res = NULL;
     if ( (err = getaddrinfo(s, NULL, &want, &res)) != 0) {
         debugs(14,3, HERE << "Given Non-IP '" << s << "': " << gai_strerror(err) );
         /* free the memory getaddrinfo() dynamically allocated. */
-        if (res) {
+        if (res)
             freeaddrinfo(res);
-            res = NULL;
-        }
         return false;
     }
 
     /*
      *  NP: =(sockaddr_*) may alter the port. we don't want that.
      *      all we have been given as input was an IPA.
      */
-    port = GetPort();
+    short portSaved = port();
     operator=(*res);
-    SetPort(port);
+    port(portSaved);
 
     /* free the memory getaddrinfo() dynamically allocated. */
     freeaddrinfo(res);
-
-    res = NULL;
-
     return true;
 }
 
 Ip::Address::Address(struct sockaddr_in const &s)
 {
-    SetEmpty();
+    setEmpty();
     operator=(s);
 };
 
 Ip::Address &
 Ip::Address::operator =(struct sockaddr_in const &s)
 {
-    Map4to6((const in_addr)s.sin_addr, m_SocketAddr.sin6_addr);
-    m_SocketAddr.sin6_port = s.sin_port;
-    m_SocketAddr.sin6_family = AF_INET6;
+    map4to6((const in_addr)s.sin_addr, mSocketAddr_.sin6_addr);
+    mSocketAddr_.sin6_port = s.sin_port;
+    mSocketAddr_.sin6_family = AF_INET6;
     return *this;
 };
 
@@ -447,75 +406,68 @@ Ip::Address::operator =(const struct sockaddr_storage &s)
 {
     /* some AF_* magic to tell socket types apart and what we need to do */
     if (s.ss_family == AF_INET6) {
-        memcpy(&m_SocketAddr, &s, sizeof(struct sockaddr_in));
+        memcpy(&mSocketAddr_, &s, sizeof(struct sockaddr_in));
     } else { // convert it to our storage mapping.
         struct sockaddr_in *sin = (struct sockaddr_in*)&s;
-        m_SocketAddr.sin6_port = sin->sin_port;
-        Map4to6( sin->sin_addr, m_SocketAddr.sin6_addr);
+        mSocketAddr_.sin6_port = sin->sin_port;
+        map4to6( sin->sin_addr, mSocketAddr_.sin6_addr);
     }
     return *this;
 };
 
 Ip::Address::Address(struct sockaddr_in6 const &s)
 {
-    SetEmpty();
+    setEmpty();
     operator=(s);
 };
 
 Ip::Address &
 Ip::Address::operator =(struct sockaddr_in6 const &s)
 {
-    memcpy(&m_SocketAddr, &s, sizeof(struct sockaddr_in6));
+    memcpy(&mSocketAddr_, &s, sizeof(struct sockaddr_in6));
 
     return *this;
 };
 
 Ip::Address::Address(struct in_addr const &s)
 {
-    SetEmpty();
+    setEmpty();
     operator=(s);
 };
 
 Ip::Address &
 Ip::Address::operator =(struct in_addr const &s)
 {
-    Map4to6((const in_addr)s, m_SocketAddr.sin6_addr);
-    m_SocketAddr.sin6_family = AF_INET6;
+    map4to6((const in_addr)s, mSocketAddr_.sin6_addr);
+    mSocketAddr_.sin6_family = AF_INET6;
     return *this;
 };
 
 Ip::Address::Address(struct in6_addr const &s)
 {
-    SetEmpty();
+    setEmpty();
     operator=(s);
 };
 
 Ip::Address &
 Ip::Address::operator =(struct in6_addr const &s)
 {
 
-    memcpy(&m_SocketAddr.sin6_addr, &s, sizeof(struct in6_addr));
-    m_SocketAddr.sin6_family = AF_INET6;
+    memcpy(&mSocketAddr_.sin6_addr, &s, sizeof(struct in6_addr));
+    mSocketAddr_.sin6_family = AF_INET6;
 
     return *this;
 };
 
 Ip::Address::Address(const Ip::Address &s)
 {
-    SetEmpty();
+    setEmpty();
     operator=(s);
 }
 
-Ip::Address::Address(Ip::Address *s)
-{
-    SetEmpty();
-    if (s)
-        memcpy(this, s, sizeof(Ip::Address));
-}
-
 Ip::Address::Address(const struct hostent &s)
 {
-    SetEmpty();
+    setEmpty();
     operator=(s);
 }
 
@@ -559,7 +511,7 @@ Ip::Address::operator =(const struct hostent &s)
 
 Ip::Address::Address(const struct addrinfo &s)
 {
-    SetEmpty();
+    setEmpty();
     operator=(s);
 }
 
@@ -618,7 +570,7 @@ Ip::Address::operator =(const struct addrinfo &s)
 }
 
 void
-Ip::Address::GetAddrInfo(struct addrinfo *&dst, int force) const
+Ip::Address::getAddrInfo(struct addrinfo *&dst, int force) const
 {
     if (dst == NULL) {
         dst = new addrinfo;
@@ -645,12 +597,12 @@ Ip::Address::GetAddrInfo(struct addrinfo *&dst, int force) const
             && dst->ai_protocol == 0)
         dst->ai_protocol = IPPROTO_UDP;
 
-    if (force == AF_INET6 || (force == AF_UNSPEC && Ip::EnableIpv6 && IsIPv6()) ) {
+    if (force == AF_INET6 || (force == AF_UNSPEC && Ip::EnableIpv6 && isIPv6()) ) {
         dst->ai_addr = (struct sockaddr*)new sockaddr_in6;
 
         memset(dst->ai_addr,0,sizeof(struct sockaddr_in6));
 
-        GetSockAddr(*((struct sockaddr_in6*)dst->ai_addr));
+        getSockAddr(*((struct sockaddr_in6*)dst->ai_addr));
 
         dst->ai_addrlen = sizeof(struct sockaddr_in6);
 
@@ -670,13 +622,13 @@ Ip::Address::GetAddrInfo(struct addrinfo *&dst, int force) const
         dst->ai_protocol = IPPROTO_IPV6;
 #endif
 
-    } else if ( force == AF_INET || (force == AF_UNSPEC && IsIPv4()) ) {
+    } else if ( force == AF_INET || (force == AF_UNSPEC && isIPv4()) ) {
 
         dst->ai_addr = (struct sockaddr*)new sockaddr_in;
 
         memset(dst->ai_addr,0,sizeof(struct sockaddr_in));
 
-        GetSockAddr(*((struct sockaddr_in*)dst->ai_addr));
+        getSockAddr(*((struct sockaddr_in*)dst->ai_addr));
 
         dst->ai_addrlen = sizeof(struct sockaddr_in);
 
@@ -724,13 +676,13 @@ Ip::Address::FreeAddrInfo(struct addrinfo *&ai)
 int
 Ip::Address::matchIPAddr(const Ip::Address &rhs) const
 {
-    uint8_t *l = (uint8_t*)m_SocketAddr.sin6_addr.s6_addr;
-    uint8_t *r = (uint8_t*)rhs.m_SocketAddr.sin6_addr.s6_addr;
+    uint8_t *l = (uint8_t*)mSocketAddr_.sin6_addr.s6_addr;
+    uint8_t *r = (uint8_t*)rhs.mSocketAddr_.sin6_addr.s6_addr;
 
     // loop a byte-wise compare
     // NP: match MUST be R-to-L : L-to-R produces inconsistent gt/lt results at varying CIDR
     //     expected difference on CIDR is gt/eq or lt/eq ONLY.
-    for (unsigned int i = 0 ; i < sizeof(m_SocketAddr.sin6_addr) ; ++i) {
+    for (unsigned int i = 0 ; i < sizeof(mSocketAddr_.sin6_addr) ; ++i) {
 
         if (l[i] < r[i])
             return -1;
@@ -763,7 +715,7 @@ Ip::Address::operator !=(const Ip::Address &s) const
 bool
 Ip::Address::operator <=(const Ip::Address &rhs) const
 {
-    if (IsAnyAddr() && !rhs.IsAnyAddr())
+    if (isAnyAddr() && !rhs.isAnyAddr())
         return true;
 
     return (matchIPAddr(rhs) <= 0);
@@ -772,7 +724,7 @@ Ip::Address::operator <=(const Ip::Address &rhs) const
 bool
 Ip::Address::operator >=(const Ip::Address &rhs) const
 {
-    if (IsNoAddr() && !rhs.IsNoAddr())
+    if (isNoAddr() && !rhs.isNoAddr())
         return true;
 
     return ( matchIPAddr(rhs) >= 0);
@@ -781,7 +733,7 @@ Ip::Address::operator >=(const Ip::Address &rhs) const
 bool
 Ip::Address::operator >(const Ip::Address &rhs) const
 {
-    if (IsNoAddr() && !rhs.IsNoAddr())
+    if (isNoAddr() && !rhs.isNoAddr())
         return true;
 
     return ( matchIPAddr(rhs) > 0);
@@ -790,28 +742,28 @@ Ip::Address::operator >(const Ip::Address &rhs) const
 bool
 Ip::Address::operator <(const Ip::Address &rhs) const
 {
-    if (IsAnyAddr() && !rhs.IsAnyAddr())
+    if (isAnyAddr() && !rhs.isAnyAddr())
         return true;
 
     return ( matchIPAddr(rhs) < 0);
 }
 
 unsigned short
-Ip::Address::GetPort() const
+Ip::Address::port() const
 {
-    return ntohs( m_SocketAddr.sin6_port );
+    return ntohs( mSocketAddr_.sin6_port );
 }
 
 unsigned short
-Ip::Address::SetPort(unsigned short prt)
+Ip::Address::port(unsigned short prt)
 {
-    m_SocketAddr.sin6_port = htons(prt);
+    mSocketAddr_.sin6_port = htons(prt);
 
     return prt;
 }
 
 /**
- * NtoA Given a buffer writes a readable ascii version of the IPA and/or port stored
+ * toStr Given a buffer writes a readable ascii version of the IPA and/or port stored
  *
  * Buffer must be of a size large enough to hold the converted address.
  * This size is provided in the form of a global defined variable MAX_IPSTRLEN
@@ -821,7 +773,7 @@ Ip::Address::SetPort(unsigned short prt)
  * A copy of the buffer is also returned for simple immediate display.
  */
 char *
-Ip::Address::NtoA(char* buf, const unsigned int blen, int force) const
+Ip::Address::toStr(char* buf, const unsigned int blen, int force) const
 {
     // Ensure we have a buffer.
     if (buf == NULL) {
@@ -830,10 +782,10 @@ Ip::Address::NtoA(char* buf, const unsigned int blen, int force) const
 
     /* some external code may have blindly memset a parent. */
     /* thats okay, our default is known */
-    if ( IsAnyAddr() ) {
-        if (IsIPv6())
+    if ( isAnyAddr() ) {
+        if (isIPv6())
             memcpy(buf,"::\0", min(static_cast<unsigned int>(3),blen));
-        else if (IsIPv4())
+        else if (isIPv4())
             memcpy(buf,"0.0.0.0\0", min(static_cast<unsigned int>(8),blen));
         return buf;
     }
@@ -842,21 +794,21 @@ Ip::Address::NtoA(char* buf, const unsigned int blen, int force) const
 
     /* Pure-IPv6 CANNOT be displayed in IPv4 format. */
     /* However IPv4 CAN. */
-    if ( force == AF_INET && !IsIPv4() ) {
-        if ( IsIPv6() ) {
+    if ( force == AF_INET && !isIPv4() ) {
+        if ( isIPv6() ) {
             memcpy(buf, "{!IPv4}\0", min(static_cast<unsigned int>(8),blen));
         }
         return buf;
     }
 
-    if ( force == AF_INET6 || (force == AF_UNSPEC && IsIPv6()) ) {
+    if ( force == AF_INET6 || (force == AF_UNSPEC && isIPv6()) ) {
 
-        inet_ntop(AF_INET6, &m_SocketAddr.sin6_addr, buf, blen);
+        inet_ntop(AF_INET6, &mSocketAddr_.sin6_addr, buf, blen);
 
-    } else  if ( force == AF_INET || (force == AF_UNSPEC && IsIPv4()) ) {
+    } else  if ( force == AF_INET || (force == AF_UNSPEC && isIPv4()) ) {
 
         struct in_addr tmp;
-        GetInAddr(tmp);
+        getInAddr(tmp);
         inet_ntop(AF_INET, &tmp, buf, blen);
     } else {
         debugs(14, DBG_CRITICAL, "WARNING: Corrupt IP Address details OR required to display in unknown format (" <<
@@ -871,26 +823,26 @@ Ip::Address::NtoA(char* buf, const unsigned int blen, int force) const
 }
 
 unsigned int
-Ip::Address::ToHostname(char *buf, const unsigned int blen) const
+Ip::Address::toHostStr(char *buf, const unsigned int blen) const
 {
     char *p = buf;
 
-    if (IsIPv6() && blen > 0) {
+    if (isIPv6() && blen > 0) {
         *p = '[';
         ++p;
     }
 
     /* 8 being space for [ ] : and port digits */
-    if ( IsIPv6() )
-        NtoA(p, blen-8, AF_INET6);
+    if ( isIPv6() )
+        toStr(p, blen-8, AF_INET6);
     else
-        NtoA(p, blen-8, AF_INET);
+        toStr(p, blen-8, AF_INET);
 
     // find the end of the new string
     while (*p != '\0' && p < buf+blen)
         ++p;
 
-    if (IsIPv6() && p < (buf+blen-1) ) {
+    if (isIPv6() && p < (buf+blen-1) ) {
         *p = ']';
         ++p;
     }
@@ -903,7 +855,7 @@ Ip::Address::ToHostname(char *buf, const unsigned int blen) const
 }
 
 char *
-Ip::Address::ToURL(char* buf, unsigned int blen) const
+Ip::Address::toUrl(char* buf, unsigned int blen) const
 {
     char *p = buf;
 
@@ -913,11 +865,11 @@ Ip::Address::ToURL(char* buf, unsigned int blen) const
         return NULL;
     }
 
-    p += ToHostname(p, blen);
+    p += toHostStr(p, blen);
 
-    if (m_SocketAddr.sin6_port > 0 && p <= (buf+blen-7) ) {
+    if (mSocketAddr_.sin6_port > 0 && p <= (buf+blen-7) ) {
         // ':port' (short int) needs at most 6 bytes plus 1 for 0-terminator
-        snprintf(p, 7, ":%d", GetPort() );
+        snprintf(p, 7, ":%d", port() );
     }
 
     // force a null-terminated string
@@ -927,36 +879,36 @@ Ip::Address::ToURL(char* buf, unsigned int blen) const
 }
 
 void
-Ip::Address::GetSockAddr(struct sockaddr_storage &addr, const int family) const
+Ip::Address::getSockAddr(struct sockaddr_storage &addr, const int family) const
 {
     struct sockaddr_in *sin = NULL;
 
-    if ( family == AF_INET && !IsIPv4()) {
+    if ( family == AF_INET && !isIPv4()) {
         // FIXME INET6: caller using the wrong socket type!
-        debugs(14, DBG_CRITICAL, HERE << "Ip::Address::GetSockAddr : Cannot convert non-IPv4 to IPv4. from " << *this);
+        debugs(14, DBG_CRITICAL, HERE << "Ip::Address::getSockAddr : Cannot convert non-IPv4 to IPv4. from " << *this);
         assert(false);
     }
 
-    if ( family == AF_INET6 || (family == AF_UNSPEC && IsIPv6()) ) {
+    if ( family == AF_INET6 || (family == AF_UNSPEC && isIPv6()) ) {
         struct sockaddr_in6 *ss6 = (struct sockaddr_in6*)&addr;
-        GetSockAddr(*ss6);
-    } else if ( family == AF_INET || (family == AF_UNSPEC && IsIPv4()) ) {
+        getSockAddr(*ss6);
+    } else if ( family == AF_INET || (family == AF_UNSPEC && isIPv4()) ) {
         sin = (struct sockaddr_in*)&addr;
-        GetSockAddr(*sin);
+        getSockAddr(*sin);
     } else {
         IASSERT("false",false);
     }
 }
 
 void
-Ip::Address::GetSockAddr(struct sockaddr_in &buf) const
+Ip::Address::getSockAddr(struct sockaddr_in &buf) const
 {
-    if ( IsIPv4() ) {
+    if ( isIPv4() ) {
         buf.sin_family = AF_INET;
-        buf.sin_port = m_SocketAddr.sin6_port;
-        Map6to4( m_SocketAddr.sin6_addr, buf.sin_addr);
+        buf.sin_port = mSocketAddr_.sin6_port;
+        map6to4( mSocketAddr_.sin6_addr, buf.sin_addr);
     } else {
-        debugs(14, DBG_CRITICAL, HERE << "Ip::Address::GetSockAddr : Cannot convert non-IPv4 to IPv4. from " << *this );
+        debugs(14, DBG_CRITICAL, HERE << "Ip::Address::getSockAddr : Cannot convert non-IPv4 to IPv4. from " << *this );
 
         memset(&buf,0xFFFFFFFF,sizeof(struct sockaddr_in));
         assert(false);
@@ -969,9 +921,9 @@ Ip::Address::GetSockAddr(struct sockaddr_in &buf) const
 }
 
 void
-Ip::Address::GetSockAddr(struct sockaddr_in6 &buf) const
+Ip::Address::getSockAddr(struct sockaddr_in6 &buf) const
 {
-    memcpy(&buf, &m_SocketAddr, sizeof(struct sockaddr_in6));
+    memcpy(&buf, &mSocketAddr_, sizeof(struct sockaddr_in6));
     /* maintain address family. It may have changed inside us. */
     buf.sin6_family = AF_INET6;
 
@@ -982,7 +934,7 @@ Ip::Address::GetSockAddr(struct sockaddr_in6 &buf) const
 }
 
 void
-Ip::Address::Map4to6(const struct in_addr &in, struct in6_addr &out) const
+Ip::Address::map4to6(const struct in_addr &in, struct in6_addr &out) const
 {
     /* check for special cases */
 
@@ -1003,7 +955,7 @@ Ip::Address::Map4to6(const struct in_addr &in, struct in6_addr &out) const
 }
 
 void
-Ip::Address::Map6to4(const struct in6_addr &in, struct in_addr &out) const
+Ip::Address::map6to4(const struct in6_addr &in, struct in_addr &out) const
 {
     /* ANYADDR */
     /* NOADDR */
@@ -1017,23 +969,23 @@ Ip::Address::Map6to4(const struct in6_addr &in, struct in_addr &out) const
 }
 
 void
-Ip::Address::GetInAddr(in6_addr &buf) const
+Ip::Address::getInAddr(in6_addr &buf) const
 {
-    memcpy(&buf, &m_SocketAddr.sin6_addr, sizeof(struct in6_addr));
+    memcpy(&buf, &mSocketAddr_.sin6_addr, sizeof(struct in6_addr));
 }
 
 bool
-Ip::Address::GetInAddr(struct in_addr &buf) const
+Ip::Address::getInAddr(struct in_addr &buf) const
 {
-    if ( IsIPv4() ) {
-        Map6to4((const in6_addr)m_SocketAddr.sin6_addr, buf);
+    if ( isIPv4() ) {
+        map6to4((const in6_addr)mSocketAddr_.sin6_addr, buf);
         return true;
     }
 
     // default:
     // non-compatible IPv6 Pure Address
 
-    debugs(14, DBG_IMPORTANT, HERE << "Ip::Address::GetInAddr : Cannot convert non-IPv4 to IPv4. IPA=" << *this);
+    debugs(14, DBG_IMPORTANT, HERE << "Ip::Address::getInAddr : Cannot convert non-IPv4 to IPv4. IPA=" << *this);
     memset(&buf,0xFFFFFFFF,sizeof(struct in_addr));
     assert(false);
     return false;
@@ -1,40 +1,10 @@
 /*
  * DEBUG: section 14    IP Storage and Handling
  * AUTHOR: Amos Jeffries
- *
- * SQUID Internet Object Cache  http://squid.nlanr.net/Squid/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from the
- *  Internet community.  Development is led by Duane Wessels of the
- *  National Laboratory for Applied Network Research and funded by the
- *  National Science Foundation.  Squid is Copyrighted (C) 1998 by
- *  the Regents of the University of California.  Please see the
- *  COPYRIGHT file for full details.  Squid incorporates software
- *  developed and/or copyrighted by other sources.  Please see the
- *  CREDITS file for full details.
- *
- *  This Ip::Address code is copyright (C) 2007 by Treehouse Networks Ltd
- *  of New Zealand. It is published and Lisenced as an extension of
- *  squid under the same conditions as the main squid application.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
+ * COPYRIGHT: GPL version 2, (C)2007-2013 Treehouse Networks Ltd.
  */
-#ifndef _SQUID_IP_IPADDRESS_H
-#define _SQUID_IP_IPADDRESS_H
+#ifndef _SQUID_SRC_IP_ADDRESS_H
+#define _SQUID_SRC_IP_ADDRESS_H
 
 #if HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
@@ -75,18 +45,8 @@ class Address
 public:
     /** @name Constructors and Destructor */
     /*@{*/
-    Address() { SetEmpty(); }
-    Address(const Address &);
-
-    /**
-     * This constructor takes its own copy of the object pointed to for memory-safe usage later.
-     * The caller must itself perform and ptr memory-management needed.
-     *
-     \deprecated Use of pointers can be nasty. Consider this a last-resort.
-     *           Prefer the by-reference (&) version instead.
-     */
-    Address(Address *);
-
+    Address() { setEmpty(); }
+    Address(const Ip::Address &);
     Address(const struct in_addr &);
     Address(const struct sockaddr_in &);
     Address(const struct in6_addr &);
@@ -126,113 +86,113 @@ class Address
      \retval true  if content was received as an IPv4-Mapped address
      \retval false if content was received as a non-mapped IPv6 native address.
      */
-    bool IsIPv4() const;
+    bool isIPv4() const;
 
     /** Test whether content can be used as an IPv6 address.
      \retval true  if content is a non IPv4-mapped address.
      \retval false if content is IPv4-mapped.
      */
-    bool IsIPv6() const;
+    bool isIPv6() const;
 
     /** Test whether content can be used as a Socket address.
      \retval true  if address AND port are both set
      \retval true  if content was received as a Socket address with port
      \retval false if port in unset (zero)
      */
-    bool IsSockAddr() const;
+    bool isSockAddr() const;
 
     /** Content-neutral test for whether the specific IP case ANY_ADDR is stored.
      *  This is the default content of a new undefined Ip::Address object.
      \retval true IPv4 0.0.0.0
      \retval true IPv6 ::
      \retval false anything else.
      */
-    bool IsAnyAddr() const;
+    bool isAnyAddr() const;
 
     /** Content-neutral test for whether the specific IP case NO_ADDR is stored.
      \retval true IPv4 255.255.255.255
      \retval true IPv6 ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff
      \retval false anything else.
      */
-    bool IsNoAddr() const;
+    bool isNoAddr() const;
 
     /** Content-neutral test for whether the specific IP case LOCALHOST is stored.
      *  This is the default content of a new undefined Ip::Address object.
      \retval true IPv4 127.0.0.1
      \retval true IPv6 ::1
      \retval false anything else.
      */
-    bool IsLocalhost() const;
+    bool isLocalhost() const;
 
     /** Test whether content is an IPv6 Site-Local address.
      \retval true  if address begins with fd00::/8.
      \retval false if --disable-ipv6 has been compiled.
      \retval false if address does not match fd00::/8
      */
-    bool IsSiteLocal6() const;
+    bool isSiteLocal6() const;
 
     /** Test whether content is an IPv6 address with SLAAC EUI-64 embeded.
      \retval true  if address matches ::ff:fe00:0
      \retval false if --disable-ipv6 has been compiled.
      \retval false if address does not match ::ff:fe00:0
      */
-    bool IsSlaac() const;
+    bool isSiteLocalAuto() const;
 
     /*@}*/
 
     /** Retrieve the Port if stored.
      \retval 0 Port is unset or an error occured.
      \retval n Port associated with this address in host native -endian.
      */
-    unsigned short GetPort() const;
+    unsigned short port() const;
 
     /** Set the Port value for an address.
      *  Replaces any previously existing Port value.
      \param port Port being assigned in host native -endian.
      \retval 0 Port is unset or an error occured.
      \retval n Port associated with this address in host native -endian.
      */
-    unsigned short SetPort(unsigned short port);
+    unsigned short port(unsigned short port);
 
     /// Set object to contain the specific IP case ANY_ADDR (format-neutral).
-    /// see IsAnyAddr() for more detail.
-    void SetAnyAddr();
+    /// see isAnyAddr() for more detail.
+    void setAnyAddr();
 
     /// Set object to contain the specific IP case NO_ADDR (format-neutral).
-    /// see IsNoAddr() for more detail.
-    void SetNoAddr();
+    /// see isNoAddr() for more detail.
+    void setNoAddr();
 
     /// Set object to contain the specific IP case LOCALHOST (format-neutral).
-    /// see IsLocalhost() for more detail.
-    void SetLocalhost();
+    /// see isLocalhost() for more detail.
+    void setLocalhost();
 
     /// Fast reset of the stored content to what would be after default constructor.
-    void SetEmpty();
+    void setEmpty();
 
     /** Require an IPv4-only address for this usage.
      *  Converts the object to prefer only IPv4 output.
      \retval true	Content can be IPv4
      \retval false	Content CANNOT be IPv4
      */
-    bool SetIPv4();
+    bool setIPv4();
 
     /**
      *  Valid results IF and only IF the stored IP address is actually a network bitmask
      \retval N number of bits which are set in the bitmask stored.
      */
-    int GetCIDR() const;
+    int cidr() const;
 
     /** Apply a mask to the stored address.
      \param mask Netmask format to be bit-mask-AND'd over the stored address.
      */
-    int ApplyMask(const Address &mask);
+    int applyMask(const Address &mask);
 
     /** Apply a mask to the stored address.
      *  CIDR will be converted appropriate to map the stored content.
      \param cidr   CIDR Mask being applied. As an integer in host format.
      \param mtype  Type of CIDR mask being applied (AF_INET or AF_INET6)
      */
-    bool ApplyMask(const unsigned int cidr, int mtype);
+    bool applyMask(const unsigned int cidr, int mtype);
 
     /** Return the ASCII equivalent of the address
      *  Semantically equivalent to the IPv4 inet_ntoa()
@@ -245,7 +205,7 @@ class Address
      \param force (optional) require the IPA in a specific format.
      \return pointer to buffer received.
      */
-    char* NtoA(char *buf, const unsigned int blen, int force = AF_UNSPEC) const;
+    char* toStr(char *buf, const unsigned int blen, int force = AF_UNSPEC) const;
 
     /** Return the ASCII equivalent of the address:port combination
      *  Provides a URL formatted version of the content.
@@ -255,7 +215,7 @@ class Address
      \param len byte length of buffer available for writing.
      \return pointer to buffer received.
      */
-    char* ToURL(char *buf, unsigned int len) const;
+    char* toUrl(char *buf, unsigned int len) const;
 
     /** Return a properly hostname formatted copy of the address
      *  Provides a URL formatted version of the content.
@@ -265,7 +225,7 @@ class Address
      \param len byte length of buffer available for writing.
      \return amount of buffer filled.
      */
-    unsigned int ToHostname(char *buf, const unsigned int len) const;
+    unsigned int toHostStr(char *buf, const unsigned int len) const;
 
     /**
      *  Convert the content into a Reverse-DNS string.
@@ -276,7 +236,7 @@ class Address
      *                 AF_UNSPEC the default displays the IP in its most advanced native form.
      \param buf        buffer to receive the text string output.
      */
-    bool GetReverseString(char buf[MAX_IPSTRLEN], int show_type = AF_UNSPEC) const;
+    bool getReverseString(char buf[MAX_IPSTRLEN], int show_type = AF_UNSPEC) const;
 
     /** Test how two IP relate to each other.
      \retval  0  IP are equal
@@ -308,7 +268,7 @@ class Address
      \param ai structure to be filled out.
      \param force a specific sockaddr type is needed. default: don't care.
      */
-    void GetAddrInfo(struct addrinfo *&ai, int force = AF_UNSPEC) const;
+    void getAddrInfo(struct addrinfo *&ai, int force = AF_UNSPEC) const;
 
     /**
      *  Equivalent to the sysem call freeaddrinfo() but for Ip::Address allocated data
@@ -338,32 +298,32 @@ class Address
      * when moving from converted code to unconverted
      * these functions can be used to convert this object
      * and pull out the data needed by the unconverted code
-     * they are intentionaly hard to use, use GetAddrInfo() instead.
+     * they are intentionaly hard to use, use getAddrInfo() instead.
      * these functiosn WILL NOT be in the final public API after transition.
      */
 
-    void GetSockAddr(struct sockaddr_storage &addr, const int family) const;
-    void GetSockAddr(struct sockaddr_in &) const;
-    bool GetInAddr(struct in_addr &) const; /* false if could not convert IPv6 down to IPv4 */
-    void GetSockAddr(struct sockaddr_in6 &) const;
-    void GetInAddr(struct in6_addr &) const;
+    void getSockAddr(struct sockaddr_storage &addr, const int family) const;
+    void getSockAddr(struct sockaddr_in &) const;
+    bool getInAddr(struct in_addr &) const; /* false if could not convert IPv6 down to IPv4 */
+    void getSockAddr(struct sockaddr_in6 &) const;
+    void getInAddr(struct in6_addr &) const;
 
 private:
     /* Conversion for dual-type internals */
 
-    bool GetReverseString4(char buf[MAX_IPSTRLEN], const struct in_addr &dat) const;
+    bool getReverseString4(char buf[MAX_IPSTRLEN], const struct in_addr &dat) const;
 
-    bool GetReverseString6(char buf[MAX_IPSTRLEN], const struct in6_addr &dat) const;
+    bool getReverseString6(char buf[MAX_IPSTRLEN], const struct in6_addr &dat) const;
 
-    void Map4to6(const struct in_addr &src, struct in6_addr &dest) const;
+    void map4to6(const struct in_addr &src, struct in6_addr &dest) const;
 
-    void Map6to4(const struct in6_addr &src, struct in_addr &dest) const;
+    void map6to4(const struct in6_addr &src, struct in_addr &dest) const;
 
     // Worker behind GetHostName and char* converters
-    bool LookupHostIP(const char *s, bool nodns);
+    bool lookupHostIP(const char *s, bool nodns);
 
     /* variables */
-    struct sockaddr_in6 m_SocketAddr;
+    struct sockaddr_in6 mSocketAddr_;
 
 private:
     /* Internally used constants */
@@ -385,7 +345,7 @@ inline std::ostream &
 operator << (std::ostream &os, const Address &ipa)
 {
     char buf[MAX_IPSTRLEN];
-    os << ipa.ToURL(buf,MAX_IPSTRLEN);
+    os << ipa.toUrl(buf,MAX_IPSTRLEN);
     return os;
 }
 
@@ -404,4 +364,4 @@ class Address_list
 
 void parse_IpAddress_list_token(Ip::Address_list **, char *);
 
-#endif /* _SQUID_IP_IPADDRESS_H */
+#endif /* _SQUID_SRC_IP_ADDRESS_H */
@@ -126,7 +126,7 @@ Ip::Intercept::NetfilterInterception(const Comm::ConnectionPointer &newConn, int
 #if LINUX_NETFILTER
     struct sockaddr_in lookup;
     socklen_t len = sizeof(struct sockaddr_in);
-    newConn->local.GetSockAddr(lookup);
+    newConn->local.getSockAddr(lookup);
 
     /** \par
      * Try NAT lookup for REDIRECT or DNAT targets. */
@@ -156,7 +156,7 @@ Ip::Intercept::TproxyTransparent(const Comm::ConnectionPointer &newConn, int sil
     /* Trust the user configured properly. If not no harm done.
      * We will simply attempt a bind outgoing on our own IP.
      */
-    newConn->remote.SetPort(0); // allow random outgoing port to prevent address clashes
+    newConn->remote.port(0); // allow random outgoing port to prevent address clashes
     debugs(89, 5, HERE << "address TPROXY: " << newConn);
     return true;
 #else
@@ -191,10 +191,10 @@ Ip::Intercept::IpfInterception(const Comm::ConnectionPointer &newConn, int silen
     // all fields must be set to 0
     memset(&natLookup, 0, sizeof(natLookup));
     // for NAT lookup set local and remote IP:port's
-    natLookup.nl_inport = htons(newConn->local.GetPort());
-    newConn->local.GetInAddr(natLookup.nl_inip);
-    natLookup.nl_outport = htons(newConn->remote.GetPort());
-    newConn->remote.GetInAddr(natLookup.nl_outip);
+    natLookup.nl_inport = htons(newConn->local.port());
+    newConn->local.getInAddr(natLookup.nl_inip);
+    natLookup.nl_outport = htons(newConn->remote.port());
+    newConn->remote.getInAddr(natLookup.nl_outip);
     // ... and the TCP flag
     natLookup.nl_flags = IPN_TCP;
 
@@ -260,7 +260,7 @@ Ip::Intercept::IpfInterception(const Comm::ConnectionPointer &newConn, int silen
         return false;
     } else {
         newConn->local = natLookup.nl_realip;
-        newConn->local.SetPort(ntohs(natLookup.nl_realport));
+        newConn->local.port(ntohs(natLookup.nl_realport));
         debugs(89, 5, HERE << "address NAT: " << newConn);
         return true;
     }
@@ -301,11 +301,11 @@ Ip::Intercept::PfInterception(const Comm::ConnectionPointer &newConn, int silent
     }
 
     memset(&nl, 0, sizeof(struct pfioc_natlook));
-    newConn->remote.GetInAddr(nl.saddr.v4);
-    nl.sport = htons(newConn->remote.GetPort());
+    newConn->remote.getInAddr(nl.saddr.v4);
+    nl.sport = htons(newConn->remote.port());
 
-    newConn->local.GetInAddr(nl.daddr.v4);
-    nl.dport = htons(newConn->local.GetPort());
+    newConn->local.getInAddr(nl.daddr.v4);
+    nl.dport = htons(newConn->local.port());
 
     nl.af = AF_INET;
     nl.proto = IPPROTO_TCP;
@@ -324,7 +324,7 @@ Ip::Intercept::PfInterception(const Comm::ConnectionPointer &newConn, int silent
         return false;
     } else {
         newConn->local = nl.rdaddr.v4;
-        newConn->local.SetPort(ntohs(nl.rdport));
+        newConn->local.port(ntohs(nl.rdport));
         debugs(89, 5, HERE << "address NAT: " << newConn);
         return true;
     }
@@ -360,8 +360,8 @@ Ip::Intercept::Lookup(const Comm::ConnectionPointer &newConn, const Comm::Connec
     }
 
     /* NAT is only available in IPv4 */
-    if ( !newConn->local.IsIPv4()  ) return false;
-    if ( !newConn->remote.IsIPv4() ) return false;
+    if ( !newConn->local.isIPv4()  ) return false;
+    if ( !newConn->remote.isIPv4() ) return false;
 
     if (interceptActive_ && listenConn->flags&COMM_INTERCEPTION) {
         /* NAT methods that use sock-opts to return client address */
@@ -411,13 +411,13 @@ Ip::Intercept::ProbeForTproxy(Ip::Address &test)
     int tmp_sock = -1;
 
     /* Probe to see if the Kernel TPROXY support is IPv6-enabled */
-    if (test.IsIPv6()) {
+    if (test.isIPv6()) {
         debugs(3, 3, "...Probing for IPv6 TPROXY support.");
 
         struct sockaddr_in6 tmp_ip6;
         Ip::Address tmp = "::2";
-        tmp.SetPort(0);
-        tmp.GetSockAddr(tmp_ip6);
+        tmp.port(0);
+        tmp.getSockAddr(tmp_ip6);
 
         if ( (tmp_sock = socket(PF_INET6, SOCK_STREAM, IPPROTO_TCP)) >= 0 &&
                 setsockopt(tmp_sock, soLevel, soFlag, (char *)&tos, sizeof(int)) == 0 &&
@@ -435,21 +435,21 @@ Ip::Intercept::ProbeForTproxy(Ip::Address &test)
         }
     }
 
-    if ( test.IsIPv6() && !test.SetIPv4() ) {
+    if ( test.isIPv6() && !test.setIPv4() ) {
         debugs(3, DBG_CRITICAL, "TPROXY lacks IPv6 support for " << test );
         if (doneSuid)
             leave_suid();
         return false;
     }
 
     /* Probe to see if the Kernel TPROXY support is IPv4-enabled (aka present) */
-    if (test.IsIPv4()) {
+    if (test.isIPv4()) {
         debugs(3, 3, "...Probing for IPv4 TPROXY support.");
 
         struct sockaddr_in tmp_ip4;
         Ip::Address tmp = "127.0.0.2";
-        tmp.SetPort(0);
-        tmp.GetSockAddr(tmp_ip4);
+        tmp.port(0);
+        tmp.getSockAddr(tmp_ip4);
 
         if ( (tmp_sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) >= 0 &&
                 setsockopt(tmp_sock, soLevel, soFlag, (char *)&tos, sizeof(int)) == 0 &&
@@ -66,27 +66,27 @@ void Ip::Qos::getNfmarkFromServer(const Comm::ConnectionPointer &server, const f
          * port numbers.
          */
 
-        if (Ip::EnableIpv6 && server->local.IsIPv6()) {
+        if (Ip::EnableIpv6 && server->local.isIPv6()) {
             nfct_set_attr_u8(ct, ATTR_L3PROTO, AF_INET6);
             struct in6_addr serv_fde_remote_ip6;
-            server->remote.GetInAddr(serv_fde_remote_ip6);
+            server->remote.getInAddr(serv_fde_remote_ip6);
             nfct_set_attr(ct, ATTR_IPV6_DST, serv_fde_remote_ip6.s6_addr);
             struct in6_addr serv_fde_local_ip6;
-            server->local.GetInAddr(serv_fde_local_ip6);
+            server->local.getInAddr(serv_fde_local_ip6);
             nfct_set_attr(ct, ATTR_IPV6_SRC, serv_fde_local_ip6.s6_addr);
         } else {
             nfct_set_attr_u8(ct, ATTR_L3PROTO, AF_INET);
             struct in_addr serv_fde_remote_ip;
-            server->remote.GetInAddr(serv_fde_remote_ip);
+            server->remote.getInAddr(serv_fde_remote_ip);
             nfct_set_attr_u32(ct, ATTR_IPV4_DST, serv_fde_remote_ip.s_addr);
             struct in_addr serv_fde_local_ip;
-            server->local.GetInAddr(serv_fde_local_ip);
+            server->local.getInAddr(serv_fde_local_ip);
             nfct_set_attr_u32(ct, ATTR_IPV4_SRC, serv_fde_local_ip.s_addr);
         }
 
         nfct_set_attr_u8(ct, ATTR_L4PROTO, IPPROTO_TCP);
-        nfct_set_attr_u16(ct, ATTR_PORT_DST, htons(server->remote.GetPort()));
-        nfct_set_attr_u16(ct, ATTR_PORT_SRC, htons(server->local.GetPort()));
+        nfct_set_attr_u16(ct, ATTR_PORT_DST, htons(server->remote.port()));
+        nfct_set_attr_u16(ct, ATTR_PORT_SRC, htons(server->local.port()));
 
         /* Open a handle to the conntrack */
         if (struct nfct_handle *h = nfct_open(CONNTRACK, 0)) {
@@ -38,12 +38,12 @@ testIpAddress::testDefaults()
     Ip::Address anIPA;
 
     /* test stored values */
-    CPPUNIT_ASSERT( anIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsIPv4() );
-    CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
-    CPPUNIT_ASSERT( anIPA.IsIPv6() );
+    CPPUNIT_ASSERT( anIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !anIPA.isNoAddr() );
+    CPPUNIT_ASSERT( !anIPA.isIPv4() );
+    CPPUNIT_ASSERT( !anIPA.isSockAddr() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.port() );
+    CPPUNIT_ASSERT( anIPA.isIPv6() );
 }
 
 void
@@ -58,13 +58,13 @@ testIpAddress::testInAddrConstructor()
     Ip::Address anIPA(inval);
 
     /* test stored values */
-    CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( anIPA.IsIPv4() );
-    CPPUNIT_ASSERT( !anIPA.IsIPv6() );
-    CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
-    anIPA.GetInAddr(outval);
+    CPPUNIT_ASSERT( !anIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !anIPA.isNoAddr() );
+    CPPUNIT_ASSERT( anIPA.isIPv4() );
+    CPPUNIT_ASSERT( !anIPA.isIPv6() );
+    CPPUNIT_ASSERT( !anIPA.isSockAddr() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.port() );
+    anIPA.getInAddr(outval);
     CPPUNIT_ASSERT( memcmp(&inval, &outval, sizeof(struct in_addr)) == 0 );
 }
 
@@ -82,13 +82,13 @@ testIpAddress::testInAddr6Constructor()
     Ip::Address anIPA(inval);
 
     /* test stored values */
-    CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsIPv4() );
-    CPPUNIT_ASSERT( anIPA.IsIPv6() );
-    CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
-    anIPA.GetInAddr(outval);
+    CPPUNIT_ASSERT( !anIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !anIPA.isNoAddr() );
+    CPPUNIT_ASSERT( !anIPA.isIPv4() );
+    CPPUNIT_ASSERT( anIPA.isIPv6() );
+    CPPUNIT_ASSERT( !anIPA.isSockAddr() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.port() );
+    anIPA.getInAddr(outval);
     CPPUNIT_ASSERT( memcmp( &inval, &outval, sizeof(struct in6_addr)) == 0 );
 }
 
@@ -111,13 +111,13 @@ testIpAddress::testSockAddrConstructor()
     Ip::Address anIPA((const struct sockaddr_in)insock);
 
     /* test stored values */
-    CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( anIPA.IsIPv4() );
-    CPPUNIT_ASSERT( !anIPA.IsIPv6() );
-    CPPUNIT_ASSERT( anIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 80 , anIPA.GetPort() );
-    anIPA.GetSockAddr(outsock);
+    CPPUNIT_ASSERT( !anIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !anIPA.isNoAddr() );
+    CPPUNIT_ASSERT( anIPA.isIPv4() );
+    CPPUNIT_ASSERT( !anIPA.isIPv6() );
+    CPPUNIT_ASSERT( anIPA.isSockAddr() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 80 , anIPA.port() );
+    anIPA.getSockAddr(outsock);
     CPPUNIT_ASSERT( memcmp( &insock, &outsock, sizeof(struct sockaddr_in)) == 0 );
 }
 
@@ -143,13 +143,13 @@ testIpAddress::testSockAddr6Constructor()
     Ip::Address anIPA((const struct sockaddr_in6)insock);
 
     /* test stored values */
-    CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsIPv4() );
-    CPPUNIT_ASSERT( anIPA.IsIPv6() );
-    CPPUNIT_ASSERT( anIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 80 , anIPA.GetPort() );
-    anIPA.GetSockAddr(outsock);
+    CPPUNIT_ASSERT( !anIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !anIPA.isNoAddr() );
+    CPPUNIT_ASSERT( !anIPA.isIPv4() );
+    CPPUNIT_ASSERT( anIPA.isIPv6() );
+    CPPUNIT_ASSERT( anIPA.isSockAddr() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 80 , anIPA.port() );
+    anIPA.getSockAddr(outsock);
     CPPUNIT_ASSERT( memcmp( &insock, &outsock, sizeof(struct sockaddr_in6)) == 0 );
 }
 
@@ -173,13 +173,13 @@ testIpAddress::testCopyConstructor()
     Ip::Address outIPA(inIPA);
 
     /* test stored values */
-    CPPUNIT_ASSERT( !outIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !outIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( outIPA.IsIPv4() );
-    CPPUNIT_ASSERT( !outIPA.IsIPv6() );
-    CPPUNIT_ASSERT( outIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 80 , outIPA.GetPort() );
-    outIPA.GetSockAddr(outsock);
+    CPPUNIT_ASSERT( !outIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !outIPA.isNoAddr() );
+    CPPUNIT_ASSERT( outIPA.isIPv4() );
+    CPPUNIT_ASSERT( !outIPA.isIPv6() );
+    CPPUNIT_ASSERT( outIPA.isSockAddr() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 80 , outIPA.port() );
+    outIPA.getSockAddr(outsock);
     CPPUNIT_ASSERT( memcmp( &insock, &outsock, sizeof(struct sockaddr_in)) == 0 );
 }
 
@@ -198,13 +198,13 @@ testIpAddress::testHostentConstructor()
     Ip::Address anIPA(*hp);
 
     /* test stored values */
-    CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( anIPA.IsIPv4() );
-    CPPUNIT_ASSERT( !anIPA.IsIPv6() );
-    CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
-    anIPA.GetInAddr(outval);
+    CPPUNIT_ASSERT( !anIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !anIPA.isNoAddr() );
+    CPPUNIT_ASSERT( anIPA.isIPv4() );
+    CPPUNIT_ASSERT( !anIPA.isIPv6() );
+    CPPUNIT_ASSERT( !anIPA.isSockAddr() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.port() );
+    anIPA.getInAddr(outval);
     CPPUNIT_ASSERT( memcmp( &expectval, &outval, sizeof(struct in_addr)) == 0 );
 }
 
@@ -219,13 +219,13 @@ testIpAddress::testStringConstructor()
     Ip::Address anIPA = "192.168.100.12";
 
     /* test stored values */
-    CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( anIPA.IsIPv4() );
-    CPPUNIT_ASSERT( !anIPA.IsIPv6() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
-    CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
-    anIPA.GetInAddr(outval);
+    CPPUNIT_ASSERT( !anIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !anIPA.isNoAddr() );
+    CPPUNIT_ASSERT( anIPA.isIPv4() );
+    CPPUNIT_ASSERT( !anIPA.isIPv6() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.port() );
+    CPPUNIT_ASSERT( !anIPA.isSockAddr() );
+    anIPA.getInAddr(outval);
     CPPUNIT_ASSERT( memcmp( &expectval, &outval, sizeof(struct in_addr)) == 0 );
 
     struct in6_addr expectv6;
@@ -239,17 +239,17 @@ testIpAddress::testStringConstructor()
     Ip::Address bnIPA = "2000:800::45";
 
 //char test[256];
-//bnIPA.NtoA(test, 256);
+//bnIPA.toStr(test, 256);
 //printf("bnIPA: %s\n", test);
 
     /* test stored values */
-    CPPUNIT_ASSERT( !bnIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !bnIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( !bnIPA.IsIPv4() );
-    CPPUNIT_ASSERT(  bnIPA.IsIPv6() );
-    CPPUNIT_ASSERT( !bnIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , bnIPA.GetPort() );
-    bnIPA.GetInAddr(outval6);
+    CPPUNIT_ASSERT( !bnIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !bnIPA.isNoAddr() );
+    CPPUNIT_ASSERT( !bnIPA.isIPv4() );
+    CPPUNIT_ASSERT(  bnIPA.isIPv6() );
+    CPPUNIT_ASSERT( !bnIPA.isSockAddr() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , bnIPA.port() );
+    bnIPA.getInAddr(outval6);
     CPPUNIT_ASSERT( memcmp( &expectv6, &outval6, sizeof(struct in6_addr)) == 0 );
 
     /* test IPv6 as an old netmask format. This is invalid but sometimes use. */
@@ -261,18 +261,18 @@ testIpAddress::testStringConstructor()
     expectv6.s6_addr32[3] = htonl(0x00000000);
 
     /* test stored values */
-    CPPUNIT_ASSERT( !cnIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !cnIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( !cnIPA.IsIPv4() );
-    CPPUNIT_ASSERT( cnIPA.IsIPv6() );
-    CPPUNIT_ASSERT( !cnIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , cnIPA.GetPort() );
-    cnIPA.GetInAddr(outval6);
+    CPPUNIT_ASSERT( !cnIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !cnIPA.isNoAddr() );
+    CPPUNIT_ASSERT( !cnIPA.isIPv4() );
+    CPPUNIT_ASSERT( cnIPA.isIPv6() );
+    CPPUNIT_ASSERT( !cnIPA.isSockAddr() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , cnIPA.port() );
+    cnIPA.getInAddr(outval6);
     CPPUNIT_ASSERT( memcmp( &expectv6, &outval6, sizeof(struct in6_addr)) == 0 );
 }
 
 void
-testIpAddress::testSetEmpty()
+testIpAddress::testsetEmpty()
 {
     Ip::Address anIPA;
     struct in_addr inval;
@@ -282,22 +282,22 @@ testIpAddress::testSetEmpty()
     anIPA = inval;
 
     /* test stored values before empty */
-    CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( anIPA.IsIPv4() );
-    CPPUNIT_ASSERT( !anIPA.IsIPv6() );
-    CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
+    CPPUNIT_ASSERT( !anIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !anIPA.isNoAddr() );
+    CPPUNIT_ASSERT( anIPA.isIPv4() );
+    CPPUNIT_ASSERT( !anIPA.isIPv6() );
+    CPPUNIT_ASSERT( !anIPA.isSockAddr() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.port() );
 
-    anIPA.SetEmpty();
+    anIPA.setEmpty();
 
     /* test stored values after empty */
-    CPPUNIT_ASSERT( anIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsIPv4() );
-    CPPUNIT_ASSERT( anIPA.IsIPv6() );
-    CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
+    CPPUNIT_ASSERT( anIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !anIPA.isNoAddr() );
+    CPPUNIT_ASSERT( !anIPA.isIPv4() );
+    CPPUNIT_ASSERT( anIPA.isIPv6() );
+    CPPUNIT_ASSERT( !anIPA.isSockAddr() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.port() );
 }
 
 void
@@ -323,8 +323,8 @@ testIpAddress::testBooleans()
     CPPUNIT_ASSERT( !( lhsIPA <  rhsIPA ) );
 
     /* test equality versus ANYADDR */
-    lhsIPA.SetAnyAddr();
-    rhsIPA.SetAnyAddr();
+    lhsIPA.setAnyAddr();
+    rhsIPA.setAnyAddr();
     CPPUNIT_ASSERT( lhsIPA.matchIPAddr(rhsIPA) == 0 );
     CPPUNIT_ASSERT(  ( lhsIPA == rhsIPA ) );
     CPPUNIT_ASSERT( !( lhsIPA != rhsIPA ) );
@@ -334,8 +334,8 @@ testIpAddress::testBooleans()
     CPPUNIT_ASSERT( !( lhsIPA <  rhsIPA ) );
 
     /* test equality versus NOADDR */
-    lhsIPA.SetNoAddr();
-    rhsIPA.SetNoAddr();
+    lhsIPA.setNoAddr();
+    rhsIPA.setNoAddr();
     CPPUNIT_ASSERT( lhsIPA.matchIPAddr(rhsIPA) == 0 );
     CPPUNIT_ASSERT(  ( lhsIPA == rhsIPA ) );
     CPPUNIT_ASSERT( !( lhsIPA != rhsIPA ) );
@@ -356,7 +356,7 @@ testIpAddress::testBooleans()
     CPPUNIT_ASSERT(  ( lhsIPA <  rhsIPA ) );
 
     /* test inequality versus ANYADDR (less than) */
-    lhsIPA.SetAnyAddr();
+    lhsIPA.setAnyAddr();
     rhsIPA = valHigh;
     CPPUNIT_ASSERT( lhsIPA.matchIPAddr(rhsIPA) < 0 );
     CPPUNIT_ASSERT( !( lhsIPA == rhsIPA ) );
@@ -368,7 +368,7 @@ testIpAddress::testBooleans()
 
     /* test inequality versus NOADDR (less than) */
     lhsIPA = valLow;
-    rhsIPA.SetNoAddr();
+    rhsIPA.setNoAddr();
     CPPUNIT_ASSERT( lhsIPA.matchIPAddr(rhsIPA) < 0 );
     CPPUNIT_ASSERT( !( lhsIPA == rhsIPA ) );
     CPPUNIT_ASSERT(  ( lhsIPA != rhsIPA ) );
@@ -390,7 +390,7 @@ testIpAddress::testBooleans()
 
     /* test inequality (greater than) */
     lhsIPA = valHigh;
-    rhsIPA.SetAnyAddr();
+    rhsIPA.setAnyAddr();
     CPPUNIT_ASSERT( lhsIPA.matchIPAddr(rhsIPA) > 0 );
     CPPUNIT_ASSERT( !( lhsIPA == rhsIPA ) );
     CPPUNIT_ASSERT(  ( lhsIPA != rhsIPA ) );
@@ -400,7 +400,7 @@ testIpAddress::testBooleans()
     CPPUNIT_ASSERT( !( lhsIPA <  rhsIPA ) );
 
     /* test inequality versus NOADDR (greater than) */
-    lhsIPA.SetNoAddr();
+    lhsIPA.setNoAddr();
     rhsIPA = valLow;
     CPPUNIT_ASSERT( lhsIPA.matchIPAddr(rhsIPA) > 0 );
     CPPUNIT_ASSERT( !( lhsIPA == rhsIPA ) );
@@ -413,31 +413,31 @@ testIpAddress::testBooleans()
 }
 
 void
-testIpAddress::testNtoA()
+testIpAddress::testtoStr()
 {
     struct in_addr inval;
     char buf[MAX_IPSTRLEN];
     Ip::Address anIPA;
 
-    anIPA.SetAnyAddr();
+    anIPA.setAnyAddr();
 
     /* test AnyAddr display values */
-    CPPUNIT_ASSERT( memcmp("::", anIPA.NtoA(buf,MAX_IPSTRLEN), 2) == 0 );
+    CPPUNIT_ASSERT( memcmp("::", anIPA.toStr(buf,MAX_IPSTRLEN), 2) == 0 );
 
     inval.s_addr = htonl(0xC0A8640C);
     anIPA = inval;
 
     /* test IP display */
-    CPPUNIT_ASSERT( memcmp("192.168.100.12",anIPA.NtoA(buf,MAX_IPSTRLEN), 14) == 0 );
+    CPPUNIT_ASSERT( memcmp("192.168.100.12",anIPA.toStr(buf,MAX_IPSTRLEN), 14) == 0 );
 
-    anIPA.SetNoAddr();
+    anIPA.setNoAddr();
 
     /* test NoAddr display values */
-    CPPUNIT_ASSERT( memcmp("ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff",anIPA.NtoA(buf,MAX_IPSTRLEN), 39) == 0 );
+    CPPUNIT_ASSERT( memcmp("ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff",anIPA.toStr(buf,MAX_IPSTRLEN), 39) == 0 );
 }
 
 void
-testIpAddress::testToURL_fromInAddr()
+testIpAddress::testtoUrl_fromInAddr()
 {
     char buf[MAX_IPSTRLEN];
     buf[0] = '\0';
@@ -448,7 +448,7 @@ testIpAddress::testToURL_fromInAddr()
     Ip::Address anIPA(inval);
 
     /* test values */
-    anIPA.ToURL(buf,MAX_IPSTRLEN);
+    anIPA.toUrl(buf,MAX_IPSTRLEN);
     CPPUNIT_ASSERT( memcmp("192.168.100.12", buf, 14) == 0 );
 
     /* test output when constructed from in6_addr with IPv6 */
@@ -461,12 +461,12 @@ testIpAddress::testToURL_fromInAddr()
 
     Ip::Address bnIPA(ip6val);
 
-    bnIPA.ToURL(buf,MAX_IPSTRLEN);
+    bnIPA.toUrl(buf,MAX_IPSTRLEN);
     CPPUNIT_ASSERT( memcmp("[c0a8:640c:ffff:ffff:ffff:ffff:ffff:ffff]", buf, 41) == 0 );
 }
 
 void
-testIpAddress::testToURL_fromSockAddr()
+testIpAddress::testtoUrl_fromSockAddr()
 {
     struct sockaddr_in sock;
     sock.sin_addr.s_addr = htonl(0xC0A8640C);
@@ -480,7 +480,7 @@ testIpAddress::testToURL_fromSockAddr()
     char buf[MAX_IPSTRLEN];
 
     /* test values */
-    anIPA.ToURL(buf,MAX_IPSTRLEN);
+    anIPA.toUrl(buf,MAX_IPSTRLEN);
     CPPUNIT_ASSERT( memcmp("192.168.100.12:80", buf, 17) == 0 );
 
     /* test output when constructed from in6_addr with IPv6 */
@@ -498,12 +498,12 @@ testIpAddress::testToURL_fromSockAddr()
 
     Ip::Address bnIPA(ip6val);
 
-    bnIPA.ToURL(buf,MAX_IPSTRLEN);
+    bnIPA.toUrl(buf,MAX_IPSTRLEN);
     CPPUNIT_ASSERT( memcmp("[c0a8:640c:ffff:ffff:ffff:ffff:ffff:ffff]:80", buf, 44) == 0 );
 }
 
 void
-testIpAddress::testGetReverseString()
+testIpAddress::testgetReverseString()
 {
     char buf[MAX_IPSTRLEN];
 
@@ -513,13 +513,13 @@ testIpAddress::testGetReverseString()
     Ip::Address v4IPA(ipv4val);
 
     /* test IPv4 output */
-    v4IPA.GetReverseString(buf);
+    v4IPA.getReverseString(buf);
     CPPUNIT_ASSERT( memcmp("12.100.168.192.in-addr.arpa.",buf, 28) == 0 );
 
-    v4IPA.GetReverseString(buf,AF_INET);
+    v4IPA.getReverseString(buf,AF_INET);
     CPPUNIT_ASSERT( memcmp("12.100.168.192.in-addr.arpa.",buf, 28) == 0 );
 
-    v4IPA.GetReverseString(buf,AF_INET6);
+    v4IPA.getReverseString(buf,AF_INET6);
     CPPUNIT_ASSERT( memcmp("",buf, 1) == 0 );
 
     struct in6_addr ip6val;
@@ -532,7 +532,7 @@ testIpAddress::testGetReverseString()
     Ip::Address v6IPA(ip6val);
 
     /* test IPv6 output */
-    v6IPA.GetReverseString(buf);
+    v6IPA.getReverseString(buf);
     CPPUNIT_ASSERT( memcmp("f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.f.c.0.4.6.8.a.0.c.ip6.arpa.",buf,73) == 0 );
 }
 
@@ -544,77 +544,77 @@ testIpAddress::testMasking()
     Ip::Address maskIPA;
 
     /* Test Basic CIDR Routine */
-    anIPA.SetAnyAddr();
-    CPPUNIT_ASSERT_EQUAL( 0 ,anIPA.GetCIDR() );
+    anIPA.setAnyAddr();
+    CPPUNIT_ASSERT_EQUAL( 0 ,anIPA.cidr() );
 
-    anIPA.SetNoAddr();
-    CPPUNIT_ASSERT_EQUAL( 128 , anIPA.GetCIDR() );
+    anIPA.setNoAddr();
+    CPPUNIT_ASSERT_EQUAL( 128 , anIPA.cidr() );
 
     /* Test Numeric ApplyCIDR */
-    anIPA.SetNoAddr();
-    CPPUNIT_ASSERT( !anIPA.ApplyMask(129,AF_INET6) );
-    CPPUNIT_ASSERT( !anIPA.ApplyMask(33,AF_INET) );
+    anIPA.setNoAddr();
+    CPPUNIT_ASSERT( !anIPA.applyMask(129,AF_INET6) );
+    CPPUNIT_ASSERT( !anIPA.applyMask(33,AF_INET) );
 
-    anIPA.SetNoAddr();
-    CPPUNIT_ASSERT( anIPA.ApplyMask(31,AF_INET) );
-    CPPUNIT_ASSERT_EQUAL( 127 , anIPA.GetCIDR() );
+    anIPA.setNoAddr();
+    CPPUNIT_ASSERT( anIPA.applyMask(31,AF_INET) );
+    CPPUNIT_ASSERT_EQUAL( 127 , anIPA.cidr() );
 
-    anIPA.SetNoAddr();
-    CPPUNIT_ASSERT( anIPA.ApplyMask(127,AF_INET6) );
-    CPPUNIT_ASSERT_EQUAL( 127 , anIPA.GetCIDR() );
+    anIPA.setNoAddr();
+    CPPUNIT_ASSERT( anIPA.applyMask(127,AF_INET6) );
+    CPPUNIT_ASSERT_EQUAL( 127 , anIPA.cidr() );
 
-    anIPA.SetNoAddr();
-    anIPA.ApplyMask(80,AF_INET6);
-    CPPUNIT_ASSERT_EQUAL( 80 , anIPA.GetCIDR() );
+    anIPA.setNoAddr();
+    anIPA.applyMask(80,AF_INET6);
+    CPPUNIT_ASSERT_EQUAL( 80 , anIPA.cidr() );
 
     /* BUG Check: test values by display. */
-    CPPUNIT_ASSERT( anIPA.NtoA(buf,MAX_IPSTRLEN) != NULL );
+    CPPUNIT_ASSERT( anIPA.toStr(buf,MAX_IPSTRLEN) != NULL );
     CPPUNIT_ASSERT( memcmp("ffff:ffff:ffff:ffff:ffff::", buf, 26) == 0 );
 
     /* Test Network Bitmask from Ip::Address */
-    anIPA.SetNoAddr();
+    anIPA.setNoAddr();
     maskIPA = "255.255.240.0";
-    CPPUNIT_ASSERT_EQUAL( 20 , maskIPA.GetCIDR() );
-    anIPA.ApplyMask(maskIPA);
-    CPPUNIT_ASSERT_EQUAL( 20 , anIPA.GetCIDR() );
+    CPPUNIT_ASSERT_EQUAL( 20 , maskIPA.cidr() );
+    anIPA.applyMask(maskIPA);
+    CPPUNIT_ASSERT_EQUAL( 20 , anIPA.cidr() );
 
     /* BUG Check: test values memory after masking. */
     struct in_addr btest;
-    CPPUNIT_ASSERT( anIPA.IsIPv4() );
-    CPPUNIT_ASSERT( !anIPA.IsIPv6() );
-    anIPA.GetInAddr(btest);
+    CPPUNIT_ASSERT( anIPA.isIPv4() );
+    CPPUNIT_ASSERT( !anIPA.isIPv6() );
+    anIPA.getInAddr(btest);
     CPPUNIT_ASSERT_EQUAL( (uint32_t)htonl(0xFFFFF000) , btest.s_addr );
 
     /* BUG Check failing test. Masked values for display. */
-    CPPUNIT_ASSERT( memcmp("255.255.240.0",anIPA.NtoA(buf,MAX_IPSTRLEN), 13) == 0 );
+    CPPUNIT_ASSERT( memcmp("255.255.240.0",anIPA.toStr(buf,MAX_IPSTRLEN), 13) == 0 );
 
-    anIPA.SetNoAddr();
-    maskIPA.SetNoAddr();
+    anIPA.setNoAddr();
+    maskIPA.setNoAddr();
 
     /* IPv6 masks MUST be CIDR representations. */
     /* however as with IPv4 they can technically be represented as a bitmask */
     maskIPA = "ffff:ffff:fff0::";
-    CPPUNIT_ASSERT( !maskIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !maskIPA.IsNoAddr() );
-    anIPA.ApplyMask(maskIPA);
-    CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
-    CPPUNIT_ASSERT_EQUAL( 44 , anIPA.GetCIDR() );
+    CPPUNIT_ASSERT( !maskIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !maskIPA.isNoAddr() );
+    anIPA.applyMask(maskIPA);
+    CPPUNIT_ASSERT( !anIPA.isNoAddr() );
+    CPPUNIT_ASSERT_EQUAL( 44 , anIPA.cidr() );
 
-    anIPA.SetNoAddr();
-    maskIPA.SetNoAddr();
+    anIPA.setNoAddr();
+    maskIPA.setNoAddr();
 
     /* IPv4 masks represented in IPv6 as IPv4 bitmasks. */
     maskIPA = "::ffff:ffff:f000";
-    CPPUNIT_ASSERT( !maskIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !maskIPA.IsNoAddr() );
-    CPPUNIT_ASSERT(  maskIPA.IsIPv4() );
-    CPPUNIT_ASSERT( !maskIPA.IsIPv6() );
-    anIPA.ApplyMask(maskIPA);
-    CPPUNIT_ASSERT( !maskIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !maskIPA.IsNoAddr() );
-    CPPUNIT_ASSERT(  maskIPA.IsIPv4() );
-    CPPUNIT_ASSERT( !maskIPA.IsIPv6() );
-    CPPUNIT_ASSERT_EQUAL( 20 , anIPA.GetCIDR() );
+    CPPUNIT_ASSERT( !maskIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !maskIPA.isNoAddr() );
+    CPPUNIT_ASSERT(  maskIPA.isIPv4() );
+    CPPUNIT_ASSERT( !maskIPA.isIPv6() );
+    anIPA.applyMask(maskIPA);
+    CPPUNIT_ASSERT( !maskIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !maskIPA.isNoAddr() );
+    CPPUNIT_ASSERT(  maskIPA.isIPv4() );
+    CPPUNIT_ASSERT( !maskIPA.isIPv6() );
+    CPPUNIT_ASSERT_EQUAL( 20 , anIPA.cidr() );
 }
 
 void
@@ -633,7 +633,7 @@ testIpAddress::testAddrInfo()
     /* assert this just to check that getaddrinfo is working properly */
     CPPUNIT_ASSERT( getaddrinfo("127.0.0.1", NULL, &hints, &expect ) == 0 );
 
-    anIP.GetAddrInfo(ipval);
+    anIP.getAddrInfo(ipval);
 
 #if 0
     /* display a byte-by-byte hex comparison of the addr cores */
@@ -711,7 +711,7 @@ testIpAddress::testAddrInfo()
     CPPUNIT_ASSERT( memcmp( expect->ai_addr, ipval->ai_addr, expect->ai_addrlen ) == 0 );
 
     freeaddrinfo(expect);
-    anIP.FreeAddrInfo(ipval);
+    Ip::Address::FreeAddrInfo(ipval);
 }
 
 void
@@ -733,52 +733,52 @@ testIpAddress::testBugNullingDisplay()
     Ip::Address anIPA = "192.168.100.12";
 
     /* test stored values */
-    CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( anIPA.IsIPv4() );
-    CPPUNIT_ASSERT( !anIPA.IsIPv6() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
-    CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
-    anIPA.GetInAddr(outval);
+    CPPUNIT_ASSERT( !anIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !anIPA.isNoAddr() );
+    CPPUNIT_ASSERT( anIPA.isIPv4() );
+    CPPUNIT_ASSERT( !anIPA.isIPv6() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.port() );
+    CPPUNIT_ASSERT( !anIPA.isSockAddr() );
+    anIPA.getInAddr(outval);
     CPPUNIT_ASSERT( memcmp( &expectval, &outval, sizeof(struct in_addr)) == 0 );
 
-    /* POKE NtoA display function to see what it is doing */
-    anIPA.NtoA(ntoabuf,MAX_IPSTRLEN);
-    CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
+    /* POKE toStr display function to see what it is doing */
+    anIPA.toStr(ntoabuf,MAX_IPSTRLEN);
+    CPPUNIT_ASSERT( !anIPA.isAnyAddr() );
     /* test stored values */
-    CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( anIPA.IsIPv4() );
-    CPPUNIT_ASSERT( !anIPA.IsIPv6() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
-    CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
-    anIPA.GetInAddr(outval);
+    CPPUNIT_ASSERT( !anIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !anIPA.isNoAddr() );
+    CPPUNIT_ASSERT( anIPA.isIPv4() );
+    CPPUNIT_ASSERT( !anIPA.isIPv6() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.port() );
+    CPPUNIT_ASSERT( !anIPA.isSockAddr() );
+    anIPA.getInAddr(outval);
     CPPUNIT_ASSERT( memcmp( &expectval, &outval, sizeof(struct in_addr)) == 0 );
 
-    /* POKE ToHostname display function to see what it is doing */
-    anIPA.ToHostname(hostbuf,MAX_IPSTRLEN);
-    CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
+    /* POKE toHostStr display function to see what it is doing */
+    anIPA.toHostStr(hostbuf,MAX_IPSTRLEN);
+    CPPUNIT_ASSERT( !anIPA.isAnyAddr() );
     /* test stored values */
-    CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( anIPA.IsIPv4() );
-    CPPUNIT_ASSERT( !anIPA.IsIPv6() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
-    CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
-    anIPA.GetInAddr(outval);
+    CPPUNIT_ASSERT( !anIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !anIPA.isNoAddr() );
+    CPPUNIT_ASSERT( anIPA.isIPv4() );
+    CPPUNIT_ASSERT( !anIPA.isIPv6() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.port() );
+    CPPUNIT_ASSERT( !anIPA.isSockAddr() );
+    anIPA.getInAddr(outval);
     CPPUNIT_ASSERT( memcmp( &expectval, &outval, sizeof(struct in_addr)) == 0 );
 
-    /* POKE ToURL display function to see what it is doing */
-    anIPA.ToURL(urlbuf,MAX_IPSTRLEN);
-    CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
+    /* POKE toUrl display function to see what it is doing */
+    anIPA.toUrl(urlbuf,MAX_IPSTRLEN);
+    CPPUNIT_ASSERT( !anIPA.isAnyAddr() );
     /* test stored values */
-    CPPUNIT_ASSERT( !anIPA.IsAnyAddr() );
-    CPPUNIT_ASSERT( !anIPA.IsNoAddr() );
-    CPPUNIT_ASSERT( anIPA.IsIPv4() );
-    CPPUNIT_ASSERT( !anIPA.IsIPv6() );
-    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.GetPort() );
-    CPPUNIT_ASSERT( !anIPA.IsSockAddr() );
-    anIPA.GetInAddr(outval);
+    CPPUNIT_ASSERT( !anIPA.isAnyAddr() );
+    CPPUNIT_ASSERT( !anIPA.isNoAddr() );
+    CPPUNIT_ASSERT( anIPA.isIPv4() );
+    CPPUNIT_ASSERT( !anIPA.isIPv6() );
+    CPPUNIT_ASSERT_EQUAL( (unsigned short) 0 , anIPA.port() );
+    CPPUNIT_ASSERT( !anIPA.isSockAddr() );
+    anIPA.getInAddr(outval);
     CPPUNIT_ASSERT( memcmp( &expectval, &outval, sizeof(struct in_addr)) == 0 );
 
 }
@@ -18,13 +18,13 @@ class testIpAddress : public CPPUNIT_NS::TestFixture
     CPPUNIT_TEST( testHostentConstructor );
     CPPUNIT_TEST( testStringConstructor );
     CPPUNIT_TEST( testCopyConstructor );
-    CPPUNIT_TEST( testSetEmpty );
+    CPPUNIT_TEST( testsetEmpty );
     CPPUNIT_TEST( testBooleans );
     CPPUNIT_TEST( testAddrInfo );
-    CPPUNIT_TEST( testNtoA );
-    CPPUNIT_TEST( testToURL_fromInAddr );
-    CPPUNIT_TEST( testToURL_fromSockAddr );
-    CPPUNIT_TEST( testGetReverseString );
+    CPPUNIT_TEST( testtoStr );
+    CPPUNIT_TEST( testtoUrl_fromInAddr );
+    CPPUNIT_TEST( testtoUrl_fromSockAddr );
+    CPPUNIT_TEST( testgetReverseString );
     CPPUNIT_TEST( testMasking );
 
     CPPUNIT_TEST( testBugNullingDisplay );
@@ -43,15 +43,15 @@ class testIpAddress : public CPPUNIT_NS::TestFixture
     void testStringConstructor();
     void testCopyConstructor();
 
-    void testSetEmpty();
+    void testsetEmpty();
     void testBooleans();
 
     void testAddrInfo();
 
-    void testNtoA();
-    void testToURL_fromInAddr();
-    void testToURL_fromSockAddr();
-    void testGetReverseString();
+    void testtoStr();
+    void testtoUrl_fromInAddr();
+    void testtoUrl_fromSockAddr();
+    void testgetReverseString();
     void testMasking();
 
     // bugs.
@@ -205,10 +205,10 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
     debugs(54, 3, "ipcCreate: cwfd FD " << cwfd);
 
     if (type == IPC_TCP_SOCKET || type == IPC_UDP_SOCKET) {
-        PaS.InitAddrInfo(AI);
+        Ip::Address::InitAddrInfo(AI);
 
         if (getsockname(pwfd, AI->ai_addr, &AI->ai_addrlen) < 0) {
-            PaS.FreeAddrInfo(AI);
+            Ip::Address::FreeAddrInfo(AI);
             debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerror());
             return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);
         }
@@ -217,19 +217,19 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
 
         debugs(54, 3, "ipcCreate: FD " << pwfd << " sockaddr " << PaS);
 
-        PaS.FreeAddrInfo(AI);
+        Ip::Address::FreeAddrInfo(AI);
 
-        ChS.InitAddrInfo(AI);
+        Ip::Address::InitAddrInfo(AI);
 
         if (getsockname(crfd, AI->ai_addr, &AI->ai_addrlen) < 0) {
-            ChS.FreeAddrInfo(AI);
+            Ip::Address::FreeAddrInfo(AI);
             debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerror());
             return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);
         }
 
         ChS = *AI;
 
-        ChS.FreeAddrInfo(AI);
+        Ip::Address::FreeAddrInfo(AI);
 
         debugs(54, 3, "ipcCreate: FD " << crfd << " sockaddr " << ChS );
 
@@ -142,11 +142,11 @@ void Ipc::SharedListenJoined(const SharedListenResponse &response)
         cbd->conn->flags = p.flags;
         // XXX: leave the comm AI stuff to comm_import_opened()?
         struct addrinfo *AI = NULL;
-        p.addr.GetAddrInfo(AI);
+        p.addr.getAddrInfo(AI);
         AI->ai_socktype = p.sock_type;
         AI->ai_protocol = p.proto;
         comm_import_opened(cbd->conn, FdNote(p.fdNote), AI);
-        p.addr.FreeAddrInfo(AI);
+        Ip::Address::FreeAddrInfo(AI);
     }
 
     cbd->errNo = response.errNo;
@@ -138,11 +138,11 @@ Ipc::ImportFdIntoComm(const Comm::ConnectionPointer &conn, int socktype, int pro
     if (getsockname(conn->fd, reinterpret_cast<sockaddr*>(&addr), &len) == 0) {
         conn->remote = addr;
         struct addrinfo* addr_info = NULL;
-        conn->remote.GetAddrInfo(addr_info);
+        conn->remote.getAddrInfo(addr_info);
         addr_info->ai_socktype = socktype;
         addr_info->ai_protocol = protocol;
         comm_import_opened(conn, Ipc::FdNote(noteId), addr_info);
-        conn->remote.FreeAddrInfo(addr_info);
+        Ip::Address::FreeAddrInfo(addr_info);
     } else {
         debugs(54, DBG_CRITICAL, "ERROR: Ipc::ImportFdIntoComm: " << conn << ' ' << xstrerror());
         conn->close();
@@ -203,26 +203,30 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
 // AYJ: these flags should be neutral, but if not IPv6 version needs adding
     if (type == IPC_TCP_SOCKET || type == IPC_UDP_SOCKET) {
 
-        tmp_addr.InitAddrInfo(aiPS);
+        Ip::Address::InitAddrInfo(aiPS);
 
         if (getsockname(pwfd, aiPS->ai_addr, &(aiPS->ai_addrlen) ) < 0) {
             debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerror());
+            Ip::Address::FreeAddrInfo(aiPS);
             return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);
         }
 
         tmp_addr = *aiPS;
+        Ip::Address::FreeAddrInfo(aiPS);
 
         debugs(54, 3, "ipcCreate: FD " << pwfd << " sockaddr " << tmp_addr );
 
-        tmp_addr.InitAddrInfo(aiCS);
+        Ip::Address::InitAddrInfo(aiCS);
 
         if (getsockname(crfd, aiCS->ai_addr, &(aiCS->ai_addrlen) ) < 0) {
             debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerror());
+            Ip::Address::FreeAddrInfo(aiCS);
             return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);
         }
 
-        tmp_addr.SetEmpty();
+        tmp_addr.setEmpty();
         tmp_addr = *aiCS;
+        Ip::Address::FreeAddrInfo(aiCS);
 
         debugs(54, 3, "ipcCreate: FD " << crfd << " sockaddr " << tmp_addr );
     }
@@ -482,27 +486,31 @@ ipc_thread_1(void *in_params)
             goto cleanup;
         }
 
-        PS_ipc.InitAddrInfo(aiPS_ipc);
+        Ip::Address::InitAddrInfo(aiPS_ipc);
 
         if (getsockname(pwfd_ipc, aiPS_ipc->ai_addr, &(aiPS_ipc->ai_addrlen)) < 0) {
             debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerror());
             ipcSend(cwfd, err_string, strlen(err_string));
+            Ip::Address::FreeAddrInfo(aiPS_ipc);
             goto cleanup;
         }
 
         PS_ipc = *aiPS_ipc;
+        Ip::Address::FreeAddrInfo(aiPS_ipc);
 
         debugs(54, 3, "ipcCreate: FD " << pwfd_ipc << " sockaddr " << PS_ipc);
 
-        CS_ipc.InitAddrInfo(aiCS_ipc);
+        Ip::Address::InitAddrInfo(aiCS_ipc);
 
         if (getsockname(crfd_ipc, aiCS_ipc->ai_addr, &(aiCS_ipc->ai_addrlen)) < 0) {
             debugs(54, DBG_CRITICAL, "ipcCreate: getsockname: " << xstrerror());
             ipcSend(cwfd, err_string, strlen(err_string));
+            Ip::Address::FreeAddrInfo(aiCS_ipc);
             goto cleanup;
         }
 
         CS_ipc = *aiCS_ipc;
+        Ip::Address::FreeAddrInfo(aiCS_ipc);
 
         debugs(54, 3, "ipcCreate: FD " << crfd_ipc << " sockaddr " << CS_ipc);
 
@@ -429,7 +429,7 @@ ipcacheParse(ipcache_entry *i, const char *inbuf)
 
         i->addrs.in_addrs = static_cast<Ip::Address *>(xcalloc(ipcount, sizeof(Ip::Address)));
         for (int l = 0; l < ipcount; ++l)
-            i->addrs.in_addrs[l].SetEmpty(); // perform same init actions as constructor would.
+            i->addrs.in_addrs[l].setEmpty(); // perform same init actions as constructor would.
         i->addrs.bad_mask = (unsigned char *)xcalloc(ipcount, sizeof(unsigned char));
         memset(i->addrs.bad_mask, 0, sizeof(unsigned char) * ipcount);
 
@@ -539,7 +539,7 @@ ipcacheParse(ipcache_entry *i, const rfc1035_rr * answers, int nr, const char *e
 
     i->addrs.in_addrs = static_cast<Ip::Address *>(xcalloc(na, sizeof(Ip::Address)));
     for (int l = 0; l < na; ++l)
-        i->addrs.in_addrs[l].SetEmpty(); // perform same init actions as constructor would.
+        i->addrs.in_addrs[l].setEmpty(); // perform same init actions as constructor would.
     i->addrs.bad_mask = (unsigned char *)xcalloc(na, sizeof(unsigned char));
 
     for (j = 0, k = 0; k < nr; ++k) {
@@ -732,7 +732,7 @@ ipcache_init(void)
     memset(&static_addrs, '\0', sizeof(ipcache_addrs));
 
     static_addrs.in_addrs = static_cast<Ip::Address *>(xcalloc(1, sizeof(Ip::Address)));
-    static_addrs.in_addrs->SetEmpty(); // properly setup the Ip::Address!
+    static_addrs.in_addrs->setEmpty(); // properly setup the Ip::Address!
     static_addrs.bad_mask = (unsigned char *)xcalloc(1, sizeof(unsigned char));
     ipcache_high = (long) (((float) Config.ipcache.size *
                             (float) Config.ipcache.high) / (float) 100);
@@ -843,12 +843,12 @@ ipcacheStatPrint(ipcache_entry * i, StoreEntry * sentry)
         /* Display tidy-up: IPv6 are so big make the list vertical */
         if (k == 0)
             storeAppendPrintf(sentry, " %45.45s-%3s\n",
-                              i->addrs.in_addrs[k].NtoA(buf,MAX_IPSTRLEN),
+                              i->addrs.in_addrs[k].toStr(buf,MAX_IPSTRLEN),
                               i->addrs.bad_mask[k] ? "BAD" : "OK ");
         else
             storeAppendPrintf(sentry, "%s %45.45s-%3s\n",
                               "                                                         ", /* blank-space indenting IP list */
-                              i->addrs.in_addrs[k].NtoA(buf,MAX_IPSTRLEN),
+                              i->addrs.in_addrs[k].toStr(buf,MAX_IPSTRLEN),
                               i->addrs.bad_mask[k] ? "BAD" : "OK ");
     }
 }
@@ -50,13 +50,13 @@ Log::Format::SquidIcap(const AccessLogEntry::Pointer &al, Logfile * logfile)
     const char *user = NULL;
     char tmp[MAX_IPSTRLEN], clientbuf[MAX_IPSTRLEN];
 
-    if (al->cache.caddr.IsAnyAddr()) { // ICAP OPTIONS xactions lack client
+    if (al->cache.caddr.isAnyAddr()) { // ICAP OPTIONS xactions lack client
         client = "-";
     } else {
         if (Config.onoff.log_fqdn)
             client = fqdncache_gethostbyaddr(al->cache.caddr, FQDN_LOOKUP_IF_MISS);
         if (!client)
-            client = al->cache.caddr.NtoA(clientbuf, MAX_IPSTRLEN);
+            client = al->cache.caddr.toStr(clientbuf, MAX_IPSTRLEN);
     }
 
 #if USE_AUTH
@@ -89,7 +89,7 @@ Log::Format::SquidIcap(const AccessLogEntry::Pointer &al, Logfile * logfile)
                   Adaptation::Icap::ICAP::methodStr(al->icap.reqMethod),
                   al->icap.reqUri.termedBuf(),
                   user ? user : "-",
-                  al->icap.hostAddr.NtoA(tmp, MAX_IPSTRLEN));
+                  al->icap.hostAddr.toStr(tmp, MAX_IPSTRLEN));
     safe_free(user);
 }
 #endif
@@ -84,7 +84,7 @@ Log::Format::SquidNative(const AccessLogEntry::Pointer &al, Logfile * logfile)
                   user ? user : dash_str,
                   al->hier.ping.timedout ? "TIMEOUT_" : "",
                   hier_code_str[al->hier.code],
-                  al->hier.tcpServer != NULL ? al->hier.tcpServer->remote.NtoA(hierHost, sizeof(hierHost)) : "-",
+                  al->hier.tcpServer != NULL ? al->hier.tcpServer->remote.toStr(hierHost, sizeof(hierHost)) : "-",
                   al->http.content_type,
                   (Config.onoff.log_mime_hdrs?"":"\n"));
 
@@ -253,7 +253,7 @@ logfile_mod_daemon_open(Logfile * lf, const char *path, size_t bufsz, int fatal_
         args[0] = "(logfile-daemon)";
         args[1] = path;
         args[2] = NULL;
-        localhost.SetLocalhost();
+        localhost.setLocalhost();
         ll->pid = ipcCreate(IPC_STREAM, Log::TheConfig.logfile_daemon, args, "logfile-daemon", localhost, &ll->rfd, &ll->wfd, NULL);
         if (ll->pid < 0)
             fatal("Couldn't start logfile helper");
@@ -183,11 +183,11 @@ logfile_mod_udp_open(Logfile * lf, const char *path, size_t bufsz, int fatal_fla
     safe_free(strAddr);
 
     Ip::Address any_addr;
-    any_addr.SetAnyAddr();
+    any_addr.setAnyAddr();
 
     // require the sending UDP port to be of the right family for the destination address.
-    if (addr.IsIPv4())
-        any_addr.SetIPv4();
+    if (addr.isIPv4())
+        any_addr.setIPv4();
 
     ll->fd = comm_open(SOCK_DGRAM, IPPROTO_UDP, any_addr, COMM_NONBLOCKING, "UDP log socket");
     if (ll->fd < 0) {
@@ -197,7 +197,7 @@ logfile_mod_udp_open(Logfile * lf, const char *path, size_t bufsz, int fatal_fla
             debugs(50, DBG_IMPORTANT, "Unable to open UDP socket for logging");
             return FALSE;
         }
-    } else if (!comm_connect_addr(ll->fd, &addr)) {
+    } else if (!comm_connect_addr(ll->fd, addr)) {
         if (lf->flags.fatal) {
             fatalf("Unable to connect to %s for UDP log: %s\n", lf->path, xstrerror());
         } else {
@@ -241,9 +241,9 @@ Log::TcpLogger::connect()
 
     Comm::ConnectionPointer futureConn = new Comm::Connection;
     futureConn->remote = remote;
-    futureConn->local.SetAnyAddr();
-    if (futureConn->remote.IsIPv4())
-        futureConn->local.SetIPv4();
+    futureConn->local.setAnyAddr();
+    if (futureConn->remote.isIPv4())
+        futureConn->local.setIPv4();
 
     typedef CommCbMemFunT<TcpLogger, CommConnectCbParams> Dialer;
     AsyncCall::Pointer call = JobCallback(MY_DEBUG_SECTION, 5, Dialer, this, Log::TcpLogger::connectDone);
@@ -53,9 +53,9 @@
 #include "ExternalACL.h"
 #include "fd.h"
 #include "format/Token.h"
-#include "forward.h"
 #include "fs/Module.h"
 #include "fqdncache.h"
+#include "FwdState.h"
 #include "globals.h"
 #include "htcp.h"
 #include "HttpHeader.h"
@@ -951,23 +951,42 @@ setEffectiveUser(void)
     }
 }
 
+/// changes working directory, providing error reporting
+static bool
+mainChangeDir(const char *dir)
+{
+    if (chdir(dir) == 0)
+        return true;
+
+    debugs(50, DBG_CRITICAL, "cannot change current directory to " << dir <<
+           ": " << xstrerror());
+    return false;
+}
+
+/// set the working directory.
 static void
 mainSetCwd(void)
 {
-    char pathbuf[MAXPATHLEN];
+    static bool chrooted = false;
+    if (Config.chroot_dir && !chrooted) {
+        chrooted = true;
 
-    if (Config.coredump_dir) {
-        if (0 == strcmp("none", Config.coredump_dir)) {
-            (void) 0;
-        } else if (chdir(Config.coredump_dir) == 0) {
+        if (chroot(Config.chroot_dir) != 0)
+            fatalf("chroot to %s failed: %s", Config.chroot_dir, xstrerror());
+
+        if (!mainChangeDir("/"))
+            fatalf("chdir to / after chroot to %s failed", Config.chroot_dir);
+    }
+
+    if (Config.coredump_dir && strcmp("none", Config.coredump_dir) != 0) {
+        if (mainChangeDir(Config.coredump_dir)) {
             debugs(0, DBG_IMPORTANT, "Set Current Directory to " << Config.coredump_dir);
             return;
-        } else {
-            debugs(50, DBG_CRITICAL, "chdir: " << Config.coredump_dir << ": " << xstrerror());
         }
     }
 
     /* If we don't have coredump_dir or couldn't cd there, report current dir */
+    char pathbuf[MAXPATHLEN];
     if (getcwd(pathbuf, MAXPATHLEN)) {
         debugs(0, DBG_IMPORTANT, "Current Directory is " << pathbuf);
     } else {
@@ -979,10 +998,7 @@ static void
 mainInitialize(void)
 {
     /* chroot if configured to run inside chroot */
-
-    if (Config.chroot_dir && (chroot(Config.chroot_dir) != 0 || chdir("/") != 0)) {
-        fatal("failed to chroot");
-    }
+    mainSetCwd();
 
     if (opt_catch_signals) {
         squid_signal(SIGSEGV, death, SA_NODEFER | SA_RESETHAND);
@@ -1425,11 +1441,8 @@ SquidMain(int argc, char **argv)
     /* send signal to running copy and exit */
     if (opt_send_signal != -1) {
         /* chroot if configured to run inside chroot */
-
+        mainSetCwd();
         if (Config.chroot_dir) {
-            if (chroot(Config.chroot_dir))
-                fatal("failed to chroot");
-
             no_suid();
         } else {
             leave_suid();
@@ -1451,10 +1464,7 @@ SquidMain(int argc, char **argv)
 
     if (opt_create_swap_dirs) {
         /* chroot if configured to run inside chroot */
-
-        if (Config.chroot_dir && chroot(Config.chroot_dir)) {
-            fatal("failed to chroot");
-        }
+        mainSetCwd();
 
         setEffectiveUser();
         debugs(0, DBG_CRITICAL, "Creating missing swap directories");
@@ -67,12 +67,12 @@ mcastJoinGroups(const ipcache_addrs *ia, const DnsLookupDetails &, void *datanot
     for (i = 0; i < (int) ia->count; ++i) {
         debugs(7, 9, "Listening for ICP requests on " << ia->in_addrs[i] );
 
-        if ( ! ia->in_addrs[i].IsIPv4() ) {
+        if ( ! ia->in_addrs[i].isIPv4() ) {
             debugs(7, 9, "ERROR: IPv6 Multicast Listen has not been implemented!");
             continue;
         }
 
-        ia->in_addrs[i].GetInAddr(mr.imr_multiaddr);
+        ia->in_addrs[i].getInAddr(mr.imr_multiaddr);
 
         mr.imr_interface.s_addr = INADDR_ANY;
 
@@ -39,7 +39,7 @@
 #include "comm/Connection.h"
 #include "comm/ConnOpener.h"
 #include "event.h"
-#include "forward.h"
+#include "FwdState.h"
 #include "globals.h"
 #include "htcp.h"
 #include "HttpRequest.h"
@@ -121,7 +121,7 @@ whichPeer(const Ip::Address &from)
 
     for (p = Config.peers; p; p = p->next) {
         for (j = 0; j < p->n_addresses; ++j) {
-            if (from == p->addresses[j] && from.GetPort() == p->icp.port) {
+            if (from == p->addresses[j] && from.port() == p->icp.port) {
                 return p;
             }
         }
@@ -181,7 +181,7 @@ peerAllowedToUse(const CachePeer * p, HttpRequest * request)
 
     // CONNECT requests are proxy requests. Not to be forwarded to origin servers.
     // Unless the destination port matches, in which case we MAY perform a 'DIRECT' to this CachePeer.
-    if (p->options.originserver && request->method == Http::METHOD_CONNECT && request->port != p->in_addr.GetPort())
+    if (p->options.originserver && request->method == Http::METHOD_CONNECT && request->port != p->in_addr.port())
         return false;
 
     if (p->peer_domain == NULL && p->access == NULL)
@@ -549,7 +549,7 @@ neighbors_init(void)
                 continue;
 
             for (AnyP::PortCfg *s = Config.Sockaddr.http; s; s = s->next) {
-                if (thisPeer->http_port != s->s.GetPort())
+                if (thisPeer->http_port != s->s.port())
                     continue;
 
                 debugs(15, DBG_IMPORTANT, "WARNING: Peer looks like this host");
@@ -925,7 +925,7 @@ neighborIgnoreNonPeer(const Ip::Address &from, icp_opcode opcode)
         if (np->in_addr != from)
             continue;
 
-        if (np->in_addr.GetPort() != from.GetPort())
+        if (np->in_addr.port() != from.port())
             continue;
 
         break;
@@ -934,10 +934,10 @@ neighborIgnoreNonPeer(const Ip::Address &from, icp_opcode opcode)
     if (np == NULL) {
         np = (CachePeer *)xcalloc(1, sizeof(CachePeer));
         np->in_addr = from;
-        np->icp.port = from.GetPort();
+        np->icp.port = from.port();
         np->type = PEER_NONE;
         np->host = new char[MAX_IPSTRLEN];
-        from.NtoA(np->host,MAX_IPSTRLEN);
+        from.toStr(np->host,MAX_IPSTRLEN);
         np->next = non_peers;
         non_peers = np;
     }
@@ -1223,9 +1223,9 @@ peerDNSConfigure(const ipcache_addrs *ia, const DnsLookupDetails &, void *data)
         ++ p->n_addresses;
     }
 
-    p->in_addr.SetEmpty();
+    p->in_addr.setEmpty();
     p->in_addr = p->addresses[0];
-    p->in_addr.SetPort(p->icp.port);
+    p->in_addr.port(p->icp.port);
 
     if (p->type == PEER_MULTICAST)
         peerCountMcastPeersSchedule(p, 10);
@@ -1317,7 +1317,7 @@ peerProbeConnect(CachePeer * p)
     for (int i = 0; i < p->n_addresses; ++i) {
         Comm::ConnectionPointer conn = new Comm::Connection;
         conn->remote = p->addresses[i];
-        conn->remote.SetPort(p->http_port);
+        conn->remote.port(p->http_port);
         getOutgoingAddress(NULL, conn);
 
         ++ p->testing_now;
@@ -1376,7 +1376,7 @@ peerCountMcastPeersStart(void *data)
     assert(p->type == PEER_MULTICAST);
     p->mcast.flags.count_event_pending = false;
     snprintf(url, MAX_URL, "http://");
-    p->in_addr.ToURL(url+7, MAX_URL -8 );
+    p->in_addr.toUrl(url+7, MAX_URL -8 );
     strcat(url, "/");
     fake = storeCreateEntry(url, url, RequestFlags(), Http::METHOD_GET);
     HttpRequest *req = HttpRequest::CreateFromUrl(url);
@@ -1609,7 +1609,7 @@ dump_peers(StoreEntry * sentry, CachePeer * peers)
 
         for (i = 0; i < e->n_addresses; ++i) {
             storeAppendPrintf(sentry, "Address[%d] : %s\n", i,
-                              e->addresses[i].NtoA(ntoabuf,MAX_IPSTRLEN) );
+                              e->addresses[i].toStr(ntoabuf,MAX_IPSTRLEN) );
         }
 
         storeAppendPrintf(sentry, "Status     : %s\n",
@@ -1773,7 +1773,7 @@ neighborsHtcpClear(StoreEntry * e, const char *uri, HttpRequest * req, const Htt
         if (p->options.htcp_no_purge_clr && reason == HTCP_CLR_PURGE) {
             continue;
         }
-        debugs(15, 3, "neighborsHtcpClear: sending CLR to " << p->in_addr.ToURL(buf, 128));
+        debugs(15, 3, "neighborsHtcpClear: sending CLR to " << p->in_addr.toUrl(buf, 128));
         htcpClear(e, uri, req, method, p, reason);
     }
 }
@@ -254,16 +254,16 @@ IdleConnList::findUseable(const Comm::ConnectionPointer &key)
     assert(size_);
 
     // small optimization: do the constant bool tests only once.
-    const bool keyCheckAddr = !key->local.IsAnyAddr();
-    const bool keyCheckPort = key->local.GetPort() > 0;
+    const bool keyCheckAddr = !key->local.isAnyAddr();
+    const bool keyCheckPort = key->local.port() > 0;
 
     for (int i=size_-1; i>=0; --i) {
 
         if (!isAvailable(i))
             continue;
 
         // local end port is required, but dont match.
-        if (keyCheckPort && key->local.GetPort() != theList_[i]->local.GetPort())
+        if (keyCheckPort && key->local.port() != theList_[i]->local.port())
             continue;
 
         // local address is required, but does not match.
@@ -331,7 +331,7 @@ PconnPool::key(const Comm::ConnectionPointer &destLink, const char *domain)
 {
     LOCAL_ARRAY(char, buf, SQUIDHOSTNAMELEN * 3 + 10);
 
-    destLink->remote.ToURL(buf, SQUIDHOSTNAMELEN * 3 + 10);
+    destLink->remote.toUrl(buf, SQUIDHOSTNAMELEN * 3 + 10);
     if (domain) {
         const int used = strlen(buf);
         snprintf(buf+used, SQUIDHOSTNAMELEN * 3 + 10-used, "/%s", domain);
@@ -36,7 +36,7 @@
 #include "CacheDigest.h"
 #include "CachePeer.h"
 #include "event.h"
-#include "forward.h"
+#include "FwdState.h"
 #include "globals.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -38,7 +38,7 @@
 #include "DnsLookupDetails.h"
 #include "errorpage.h"
 #include "event.h"
-#include "forward.h"
+#include "FwdState.h"
 #include "globals.h"
 #include "hier_code.h"
 #include "htcp.h"
@@ -341,7 +341,7 @@ peerSelectDnsResults(const ipcache_addrs *ia, const DnsLookupDetails &details, v
 
             // for TPROXY spoofing we must skip unusable addresses.
             if (psstate->request->flags.spoofClientIp && !(fs->_peer && fs->_peer->options.no_tproxy) ) {
-                if (ia->in_addrs[n].IsIPv4() != psstate->request->client_addr.IsIPv4()) {
+                if (ia->in_addrs[n].isIPv4() != psstate->request->client_addr.isIPv4()) {
                     // we CAN'T spoof the address on this link. find another.
                     continue;
                 }
@@ -351,16 +351,16 @@ peerSelectDnsResults(const ipcache_addrs *ia, const DnsLookupDetails &details, v
             p->remote = ia->in_addrs[n];
 
             // when IPv6 is disabled we cannot use it
-            if (!Ip::EnableIpv6 && p->remote.IsIPv6()) {
+            if (!Ip::EnableIpv6 && p->remote.isIPv6()) {
                 const char *host = (fs->_peer ? fs->_peer->host : psstate->request->GetHost());
                 ipcacheMarkBadAddr(host, p->remote);
                 continue;
             }
 
             if (fs->_peer)
-                p->remote.SetPort(fs->_peer->http_port);
+                p->remote.port(fs->_peer->http_port);
             else
-                p->remote.SetPort(psstate->request->port);
+                p->remote.port(psstate->request->port);
             p->peerType = fs->code;
             p->setPeer(fs->_peer);
 
@@ -637,10 +637,10 @@ peerGetSomeNeighborReplies(ps_state * ps)
     if ((p = ps->hit)) {
         code = ps->hit_type == PEER_PARENT ? PARENT_HIT : SIBLING_HIT;
     } else {
-        if (!ps->closest_parent_miss.IsAnyAddr()) {
+        if (!ps->closest_parent_miss.isAnyAddr()) {
             p = whichPeer(ps->closest_parent_miss);
             code = CLOSEST_PARENT_MISS;
-        } else if (!ps->first_parent_miss.IsAnyAddr()) {
+        } else if (!ps->first_parent_miss.isAnyAddr()) {
             p = whichPeer(ps->first_parent_miss);
             code = FIRST_PARENT_MISS;
         }
@@ -796,15 +796,15 @@ peerIcpParentMiss(CachePeer * p, icp_common_t * header, ps_state * ps)
         return;
 
     /* set FIRST_MISS if there is no CLOSEST parent */
-    if (!ps->closest_parent_miss.IsAnyAddr())
+    if (!ps->closest_parent_miss.isAnyAddr())
         return;
 
     rtt = (tvSubMsec(ps->ping.start, current_time) - p->basetime) / p->weight;
 
     if (rtt < 1)
         rtt = 1;
 
-    if (ps->first_parent_miss.IsAnyAddr() || rtt < ps->ping.w_rtt) {
+    if (ps->first_parent_miss.isAnyAddr() || rtt < ps->ping.w_rtt) {
         ps->first_parent_miss = p->in_addr;
         ps->ping.w_rtt = rtt;
     }
@@ -894,15 +894,15 @@ peerHtcpParentMiss(CachePeer * p, HtcpReplyData * htcp, ps_state * ps)
         return;
 
     /* set FIRST_MISS if there is no CLOSEST parent */
-    if (!ps->closest_parent_miss.IsAnyAddr())
+    if (!ps->closest_parent_miss.isAnyAddr())
         return;
 
     rtt = (tvSubMsec(ps->ping.start, current_time) - p->basetime) / p->weight;
 
     if (rtt < 1)
         rtt = 1;
 
-    if (ps->first_parent_miss.IsAnyAddr() || rtt < ps->ping.w_rtt) {
+    if (ps->first_parent_miss.isAnyAddr() || rtt < ps->ping.w_rtt) {
         ps->first_parent_miss = p->in_addr;
         ps->ping.w_rtt = rtt;
     }
@@ -183,7 +183,7 @@ peerSourceHashSelectParent(HttpRequest * request)
     if (n_sourcehash_peers == 0)
         return NULL;
 
-    key = request->client_addr.NtoA(ntoabuf, sizeof(ntoabuf));
+    key = request->client_addr.toStr(ntoabuf, sizeof(ntoabuf));
 
     /* calculate hash key */
     debugs(39, 2, "peerSourceHashSelectParent: Calculating hash for " << key);
@@ -121,7 +121,7 @@ main(int argc, char *argv[])
         ipa = R.sin_addr;
         printf("==============================================================================\n");
         printf("Received from %s [%s]\n",
-               ipa.NtoA(tmp,MAX_HOSTNAMELEN),
+               ipa.toStr(tmp,MAX_HOSTNAMELEN),
                (hp && hp->h_name) ? hp->h_name : "Unknown");
         fputs(buf, stdout);
         fflush(stdout);
@@ -231,7 +231,7 @@ constructHelperQuery(const char *name, helper *hlp, HLPCB *replyHandler, ClientH
     if (conn != NULL)
         r->client_addr = conn->log_addr;
     else
-        r->client_addr.SetNoAddr();
+        r->client_addr.setNoAddr();
     r->client_ident = NULL;
 #if USE_AUTH
     if (http->request->auth_user_request != NULL) {
@@ -273,12 +273,12 @@ constructHelperQuery(const char *name, helper *hlp, HLPCB *replyHandler, ClientH
 
     sz = snprintf(buf, MAX_REDIRECTOR_REQUEST_STRLEN, "%s %s/%s %s %s myip=%s myport=%d\n",
                   r->orig_url,
-                  r->client_addr.NtoA(claddr,MAX_IPSTRLEN),
+                  r->client_addr.toStr(claddr,MAX_IPSTRLEN),
                   fqdn,
                   r->client_ident[0] ? rfc1738_escape(r->client_ident) : dash_str,
                   r->method_s,
-                  http->request->my_addr.NtoA(myaddr,MAX_IPSTRLEN),
-                  http->request->my_addr.GetPort());
+                  http->request->my_addr.toStr(myaddr,MAX_IPSTRLEN),
+                  http->request->my_addr.port());
 
     if ((sz<=0) || (sz>=MAX_REDIRECTOR_REQUEST_STRLEN)) {
         if (sz<=0) {
@@ -293,7 +293,7 @@ constructHelperQuery(const char *name, helper *hlp, HLPCB *replyHandler, ClientH
         clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
         assert (repContext);
         Ip::Address tmpnoaddr;
-        tmpnoaddr.SetNoAddr();
+        tmpnoaddr.setNoAddr();
         repContext->setReplyToError(ERR_GATEWAY_FAILURE, status,
                                     http->request->method, NULL,
                                     http->getConn() != NULL && http->getConn()->clientConnection != NULL ?
@@ -113,7 +113,7 @@ send_announce(const ipcache_addrs *ia, const DnsLookupDetails &, void *junk)
     }
 
     Ip::Address S = ia->in_addrs[0];
-    S.SetPort(port);
+    S.port(port);
     assert(Comm::IsConnOpen(icpOutgoingConn));
 
     if (comm_udp_sendto(icpOutgoingConn->fd, S, sndbuf, strlen(sndbuf) + 1) < 0)
@@ -245,7 +245,7 @@ snmp_meshPtblFn(variable_list * Var, snint * ErrP)
 
     case MESH_PTBL_ADDR_TYPE: {
         int ival;
-        ival = laddr.IsIPv4() ? INETADDRESSTYPE_IPV4 : INETADDRESSTYPE_IPV6 ;
+        ival = laddr.isIPv4() ? INETADDRESSTYPE_IPV4 : INETADDRESSTYPE_IPV6 ;
         Answer = snmp_var_new_integer(Var->name, Var->name_length,
                                       ival, SMI_INTEGER);
     }
@@ -257,7 +257,7 @@ snmp_meshPtblFn(variable_list * Var, snint * ErrP)
         // See: rfc4001.txt
         Answer->type = ASN_OCTET_STR;
         char host[MAX_IPSTRLEN];
-        laddr.NtoA(host,MAX_IPSTRLEN);
+        laddr.toStr(host,MAX_IPSTRLEN);
         Answer->val_len = strlen(host);
         Answer->val.string =  (u_char *) xstrdup(host);
     }
@@ -282,33 +282,33 @@ snmpOpenPorts(void)
 
     snmpIncomingConn = new Comm::Connection;
     snmpIncomingConn->local = Config.Addrs.snmp_incoming;
-    snmpIncomingConn->local.SetPort(Config.Port.snmp);
+    snmpIncomingConn->local.port(Config.Port.snmp);
 
-    if (!Ip::EnableIpv6 && !snmpIncomingConn->local.SetIPv4()) {
+    if (!Ip::EnableIpv6 && !snmpIncomingConn->local.setIPv4()) {
         debugs(49, DBG_CRITICAL, "ERROR: IPv6 is disabled. " << snmpIncomingConn->local << " is not an IPv4 address.");
         fatal("SNMP port cannot be opened.");
     }
     /* split-stack for now requires IPv4-only SNMP */
-    if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && snmpIncomingConn->local.IsAnyAddr()) {
-        snmpIncomingConn->local.SetIPv4();
+    if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && snmpIncomingConn->local.isAnyAddr()) {
+        snmpIncomingConn->local.setIPv4();
     }
 
     AsyncCall::Pointer call = asyncCall(49, 2, "snmpIncomingConnectionOpened",
                                         Comm::UdpOpenDialer(&snmpPortOpened));
     Ipc::StartListening(SOCK_DGRAM, IPPROTO_UDP, snmpIncomingConn, Ipc::fdnInSnmpSocket, call);
 
-    if (!Config.Addrs.snmp_outgoing.IsNoAddr()) {
+    if (!Config.Addrs.snmp_outgoing.isNoAddr()) {
         snmpOutgoingConn = new Comm::Connection;
         snmpOutgoingConn->local = Config.Addrs.snmp_outgoing;
-        snmpOutgoingConn->local.SetPort(Config.Port.snmp);
+        snmpOutgoingConn->local.port(Config.Port.snmp);
 
-        if (!Ip::EnableIpv6 && !snmpOutgoingConn->local.SetIPv4()) {
+        if (!Ip::EnableIpv6 && !snmpOutgoingConn->local.setIPv4()) {
             debugs(49, DBG_CRITICAL, "ERROR: IPv6 is disabled. " << snmpOutgoingConn->local << " is not an IPv4 address.");
             fatal("SNMP port cannot be opened.");
         }
         /* split-stack for now requires IPv4-only SNMP */
-        if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && snmpOutgoingConn->local.IsAnyAddr()) {
-            snmpOutgoingConn->local.SetIPv4();
+        if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && snmpOutgoingConn->local.isAnyAddr()) {
+            snmpOutgoingConn->local.setIPv4();
         }
         AsyncCall::Pointer c = asyncCall(49, 2, "snmpOutgoingConnectionOpened",
                                          Comm::UdpOpenDialer(&snmpPortOpened));
@@ -332,7 +332,7 @@ snmpPortOpened(const Comm::ConnectionPointer &conn, int errNo)
     else if (conn->fd == snmpOutgoingConn->fd)
         debugs(1, DBG_IMPORTANT, "Sending SNMP messages from " << snmpOutgoingConn->local);
     else
-        fatalf("Lost SNMP port (%d) on FD %d", (int)conn->local.GetPort(), conn->fd);
+        fatalf("Lost SNMP port (%d) on FD %d", (int)conn->local.port(), conn->fd);
 }
 
 void
@@ -799,9 +799,9 @@ client_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn
         if (aux)
             laddr = *aux;
         else
-            laddr.SetAnyAddr();
+            laddr.setAnyAddr();
 
-        if (laddr.IsIPv4())
+        if (laddr.isIPv4())
             size = sizeof(in_addr);
         else
             size = sizeof(in6_addr);
@@ -811,7 +811,7 @@ client_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn
         instance = (oid *)xmalloc(sizeof(*name) * (*len + size ));
         memcpy(instance, name, (sizeof(*name) * (*len)));
 
-        if ( !laddr.IsAnyAddr() ) {
+        if ( !laddr.isAnyAddr() ) {
             addr2oid(laddr, &instance[ *len]);  // the addr
             *len += size ;
         }
@@ -822,10 +822,10 @@ client_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn
         if (aux)
             laddr = *aux;
         else
-            laddr.SetAnyAddr();
+            laddr.setAnyAddr();
 
-        if (!laddr.IsAnyAddr()) {
-            if (laddr.IsIPv4())
+        if (!laddr.isAnyAddr()) {
+            if (laddr.isIPv4())
                 newshift = sizeof(in_addr);
             else
                 newshift = sizeof(in6_addr);
@@ -1104,14 +1104,14 @@ addr2oid(Ip::Address &addr, oid * Dest)
     u_char *cp = NULL;
     struct in_addr i4addr;
     struct in6_addr i6addr;
-    oid code = addr.IsIPv6()? INETADDRESSTYPE_IPV6  : INETADDRESSTYPE_IPV4 ;
+    oid code = addr.isIPv6()? INETADDRESSTYPE_IPV6  : INETADDRESSTYPE_IPV4 ;
     u_int size = (code == INETADDRESSTYPE_IPV4) ? sizeof(struct in_addr):sizeof(struct in6_addr);
     //  Dest[0] = code ;
     if ( code == INETADDRESSTYPE_IPV4 ) {
-        addr.GetInAddr(i4addr);
+        addr.getInAddr(i4addr);
         cp = (u_char *) &(i4addr.s_addr);
     } else {
-        addr.GetInAddr(i6addr);
+        addr.getInAddr(i6addr);
         cp = (u_char *) &i6addr;
     }
     for ( i=0 ; i < size ; ++i) {
@@ -6,7 +6,7 @@
 #include "squid.h"
 
 #include "client_side.h"
-#include "forward.h"
+#include "FwdState.h"
 #include "ssl/ServerBump.h"
 #include "Store.h"
 #include "StoreClient.h"
@@ -27,7 +27,7 @@ class ServerBump
     HttpRequest::Pointer request;
     StoreEntry *entry; ///< for receiving Squid-generated error messages
     Ssl::X509_Pointer serverCert; ///< HTTPS server certificate
-    Ssl::Errors *sslErrors; ///< SSL [certificate validation] errors
+    Ssl::CertErrors *sslErrors; ///< SSL [certificate validation] errors
 
 private:
     store_client *sc; ///< dummy client to prevent entry trimming
@@ -10,36 +10,38 @@ Ssl::CertValidationMsg::composeRequest(CertValidationRequest const &vcert)
 {
     body.clear();
     body += Ssl::CertValidationMsg::param_host + "=" + vcert.domainName;
-    if (vcert.errors) {
-        body += "\n" + Ssl::CertValidationMsg::param_error + "=";
-        bool comma = false;
-        for (const Ssl::Errors *err = vcert.errors; err; err = err->next ) {
-            if (comma)
-                body += ",";
-            body += GetErrorName(err->element);
-            comma = true;
-        }
-    }
-
     STACK_OF(X509) *peerCerts = SSL_get_peer_cert_chain(vcert.ssl);
     if (peerCerts) {
-        body +="\n";
         Ssl::BIO_Pointer bio(BIO_new(BIO_s_mem()));
         for (int i = 0; i < sk_X509_num(peerCerts); ++i) {
             X509 *cert = sk_X509_value(peerCerts, i);
             PEM_write_bio_X509(bio.get(), cert);
-            body = body + "cert_" + xitoa(i) + "=";
+            body = body + "\n" + param_cert + xitoa(i) + "=";
             char *ptr;
             long len = BIO_get_mem_data(bio.get(), &ptr);
-            body.append(ptr, len);
-            // Normally openssl toolkit terminates Certificate with a '\n'.
-            if (ptr[len-1] != '\n')
-                body +="\n";
+            body.append(ptr, (ptr[len-1] == '\n' ? len - 1 : len));
             if (!BIO_reset(bio.get())) {
                 // print an error?
             }
         }
     }
+
+    if (vcert.errors) {
+        int i = 0;
+        for (const Ssl::CertErrors *err = vcert.errors; err; err = err->next, ++i) {
+            body +="\n";
+            body = body + param_error_name + xitoa(i) + "=" + GetErrorName(err->element.code) + "\n";
+            int errorCertPos = -1;
+            if (err->element.cert.get())
+                errorCertPos = sk_X509_find(peerCerts, err->element.cert.get());
+            if (errorCertPos < 0) {
+                // assert this error ?
+                debugs(83, 4, "WARNING: wrong cert in cert validator request");
+            }
+            body += param_error_cert + xitoa(i) + "=";
+            body += param_cert + xitoa((errorCertPos >= 0 ? errorCertPos : 0));
+        }
+    }
 }
 
 static int
@@ -212,7 +214,6 @@ Ssl::CertValidationMsg::CertItem::setCert(X509 *aCert)
 
 const std::string Ssl::CertValidationMsg::code_cert_validate("cert_validate");
 const std::string Ssl::CertValidationMsg::param_domain("domain");
-const std::string Ssl::CertValidationMsg::param_error("errors");
 const std::string Ssl::CertValidationMsg::param_cert("cert_");
 const std::string Ssl::CertValidationMsg::param_error_name("error_name_");
 const std::string Ssl::CertValidationMsg::param_error_reason("error_reason_");
@@ -20,7 +20,7 @@ class CertValidationRequest
 {
 public:
     SSL *ssl;
-    Errors *errors; ///< The list of errors detected
+    CertErrors *errors; ///< The list of errors detected
     std::string domainName; ///< The server name
     CertValidationRequest() : ssl(NULL), errors(NULL) {}
 };
@@ -99,8 +99,6 @@ class CertValidationMsg: public CrtdMessage
     static const std::string code_cert_validate;
     /// Parameter name for passing intended domain name
     static const std::string param_domain;
-    /// Parameter name for passing SSL errors
-    static const std::string param_error;
     /// Parameter name for passing SSL certificates
     static const std::string param_cert;
     /// Parameter name for passing the major SSL error
@@ -261,16 +261,20 @@ ssl_verify_cb(int ok, X509_STORE_CTX * ctx)
     }
 
     if (!ok) {
-        Ssl::Errors *errs = static_cast<Ssl::Errors *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors));
+        X509 *broken_cert =  X509_STORE_CTX_get_current_cert(ctx);
+        if (!broken_cert)
+            broken_cert = peer_cert;
+
+        Ssl::CertErrors *errs = static_cast<Ssl::CertErrors *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors));
         if (!errs) {
-            errs = new Ssl::Errors(error_no);
+            errs = new Ssl::CertErrors(Ssl::CertError(error_no, broken_cert));
             if (!SSL_set_ex_data(ssl, ssl_ex_index_ssl_errors,  (void *)errs)) {
                 debugs(83, 2, "Failed to set ssl error_no in ssl_verify_cb: Certificate " << buffer);
                 delete errs;
                 errs = NULL;
             }
         } else // remember another error number
-            errs->push_back_unique(error_no);
+            errs->push_back_unique(Ssl::CertError(error_no, broken_cert));
 
         if (const char *err_descr = Ssl::GetErrorDescr(error_no))
             debugs(83, 5, err_descr << ": " << buffer);
@@ -280,7 +284,7 @@ ssl_verify_cb(int ok, X509_STORE_CTX * ctx)
         if (check) {
             ACLFilledChecklist *filledCheck = Filled(check);
             assert(!filledCheck->sslErrors);
-            filledCheck->sslErrors = new Ssl::Errors(error_no);
+            filledCheck->sslErrors = new Ssl::CertErrors(Ssl::CertError(error_no, broken_cert));
             filledCheck->serverCert.resetAndLock(peer_cert);
             if (check->fastCheck() == ACCESS_ALLOWED) {
                 debugs(83, 3, "bypassing SSL error " << error_no << " in " << buffer);
@@ -635,7 +639,7 @@ static void
 ssl_free_SslErrors(void *, void *ptr, CRYPTO_EX_DATA *,
                    int, long, void *)
 {
-    Ssl::Errors *errs = static_cast <Ssl::Errors*>(ptr);
+    Ssl::CertErrors *errs = static_cast <Ssl::CertErrors*>(ptr);
     delete errs;
 }
 
@@ -1596,4 +1600,34 @@ bool Ssl::generateUntrustedCert(X509_Pointer &untrustedCert, EVP_PKEY_Pointer &u
     return Ssl::generateSslCertificate(untrustedCert, untrustedPkey, certProperties);
 }
 
+Ssl::CertError::CertError(ssl_error_t anErr, X509 *aCert): code(anErr)
+{
+    cert.resetAndLock(aCert);
+}
+
+Ssl::CertError::CertError(CertError const &err): code(err.code)
+{
+    cert.resetAndLock(err.cert.get());
+}
+
+Ssl::CertError &
+Ssl::CertError::operator = (const CertError &old)
+{
+    code = old.code;
+    cert.resetAndLock(old.cert.get());
+    return *this;
+}
+
+bool
+Ssl::CertError::operator == (const CertError &ce) const
+{
+    return code == ce.code && cert.get() == ce.cert.get();
+}
+
+bool
+Ssl::CertError::operator != (const CertError &ce) const
+{
+    return code != ce.code || cert.get() != ce.cert.get();
+}
+
 #endif /* USE_SSL */
@@ -74,6 +74,23 @@ typedef int ssl_error_t;
 
 typedef CbDataList<Ssl::ssl_error_t> Errors;
 
+/// An SSL certificate-related error.
+/// Pairs an error code with the certificate experiencing the error.
+class CertError
+{
+public:
+    ssl_error_t code; ///< certificate error code
+    X509_Pointer cert; ///< certificate with the above error code
+    CertError(ssl_error_t anErr, X509 *aCert);
+    CertError(CertError const &err);
+    CertError & operator = (const CertError &old);
+    bool operator == (const CertError &ce) const;
+    bool operator != (const CertError &ce) const;
+};
+
+/// Holds a list of certificate SSL errors
+typedef CbDataList<Ssl::CertError> CertErrors;
+
 } //namespace Ssl
 
 /// \ingroup ServerProtocolSSLAPI
@@ -2025,9 +2025,9 @@ statClientRequests(StoreEntry * s)
             storeAppendPrintf(s, "\tin: buf %p, offset %ld, size %ld\n",
                               conn->in.buf, (long int) conn->in.notYetUsed, (long int) conn->in.allocatedSize);
             storeAppendPrintf(s, "\tremote: %s\n",
-                              conn->clientConnection->remote.ToURL(buf,MAX_IPSTRLEN));
+                              conn->clientConnection->remote.toUrl(buf,MAX_IPSTRLEN));
             storeAppendPrintf(s, "\tlocal: %s\n",
-                              conn->clientConnection->local.ToURL(buf,MAX_IPSTRLEN));
+                              conn->clientConnection->local.toUrl(buf,MAX_IPSTRLEN));
             storeAppendPrintf(s, "\tnrequests: %d\n",
                               conn->nrequests);
         }
@@ -549,12 +549,12 @@ getMyHostname(void)
 
     host[0] = '\0';
 
-    if (Config.Sockaddr.http && sa.IsAnyAddr())
+    if (Config.Sockaddr.http && sa.isAnyAddr())
         sa = Config.Sockaddr.http->s;
 
 #if USE_SSL
 
-    if (Config.Sockaddr.https && sa.IsAnyAddr())
+    if (Config.Sockaddr.https && sa.isAnyAddr())
         sa = Config.Sockaddr.https->s;
 
 #endif
@@ -563,9 +563,9 @@ getMyHostname(void)
      * If the first http_port address has a specific address, try a
      * reverse DNS lookup on it.
      */
-    if ( !sa.IsAnyAddr() ) {
+    if ( !sa.isAnyAddr() ) {
 
-        sa.GetAddrInfo(AI);
+        sa.getAddrInfo(AI);
         /* we are looking for a name. */
         if (getnameinfo(AI->ai_addr, AI->ai_addrlen, host, SQUIDHOSTNAMELEN, NULL, 0, NI_NAMEREQD ) == 0) {
             /* DNS lookup successful */
@@ -574,13 +574,13 @@ getMyHostname(void)
 
             present = 1;
 
-            sa.FreeAddrInfo(AI);
+            Ip::Address::FreeAddrInfo(AI);
 
             if (strchr(host, '.'))
                 return host;
         }
 
-        sa.FreeAddrInfo(AI);
+        Ip::Address::FreeAddrInfo(AI);
         debugs(50, 2, "WARNING: failed to resolve " << sa << " to a fully qualified hostname");
     }
 
@@ -600,15 +600,14 @@ getMyHostname(void)
             present = 1;
 
             /* AYJ: do we want to flag AI_ALL and cache the result anywhere. ie as our local host IPs? */
-            if (AI) {
+            if (AI)
                 freeaddrinfo(AI);
-                AI = NULL;
-            }
 
             return host;
         }
 
-        if (AI) freeaddrinfo(AI);
+        if (AI)
+            freeaddrinfo(AI);
         debugs(50, DBG_IMPORTANT, "WARNING: '" << host << "' rDNS test failed: " << xstrerror());
     }
 
@@ -1210,7 +1209,7 @@ getMyPort(void)
         while (p && p->flags.isIntercepted())
             p = p->next;
         if (p)
-            return p->s.GetPort();
+            return p->s.port();
     }
 
 #if USE_SSL
@@ -1219,7 +1218,7 @@ getMyPort(void)
         while (p && p->flags.isIntercepted())
             p = p->next;
         if (p)
-            return p->s.GetPort();
+            return p->s.port();
     }
 #endif
 
@@ -91,6 +91,12 @@ class TunnelStateData
     static void WriteClientDone(const Comm::ConnectionPointer &, char *buf, size_t len, comm_err_t flag, int xerrno, void *data);
     static void WriteServerDone(const Comm::ConnectionPointer &, char *buf, size_t len, comm_err_t flag, int xerrno, void *data);
 
+    /// Starts reading peer response to our CONNECT request.
+    void readConnectResponse();
+
+    /// Called when we may be done handling a CONNECT exchange with the peer.
+    void connectExchangeCheckpoint();
+
     bool noConnections() const;
     char *url;
     HttpRequest::Pointer request;
@@ -100,6 +106,19 @@ class TunnelStateData
         return (server.conn != NULL && server.conn->getPeer() ? server.conn->getPeer()->host : request->GetHost());
     };
 
+    /// Whether we are writing a CONNECT request to a peer.
+    bool waitingForConnectRequest() const { return connectReqWriting; }
+    /// Whether we are reading a CONNECT response from a peer.
+    bool waitingForConnectResponse() const { return connectRespBuf; }
+    /// Whether we are waiting for the CONNECT request/response exchange with the peer.
+    bool waitingForConnectExchange() const { return waitingForConnectRequest() || waitingForConnectResponse(); }
+
+    /// Whether the client sent a CONNECT request to us.
+    bool clientExpectsConnectResponse() const {
+        return !(request != NULL &&
+                 (request->flags.interceptTproxy || request->flags.intercepted));
+    }
+
     class Connection
     {
 
@@ -117,6 +136,8 @@ class TunnelStateData
 
         void error(int const xerrno);
         int debugLevelForError(int const xerrno) const;
+        /// handles a non-I/O error associated with this Connection
+        void logicError(const char *errMsg);
         void closeIfOpen();
         void dataSent (size_t amount);
         int len;
@@ -135,15 +156,23 @@ class TunnelStateData
 
     Connection client, server;
     int *status_ptr;		/* pointer to status for logging */
+    MemBuf *connectRespBuf; ///< accumulates peer CONNECT response when we need it
+    bool connectReqWriting; ///< whether we are writing a CONNECT request to a peer
+
     void copyRead(Connection &from, IOCB *completion);
 
 private:
     CBDATA_CLASS2(TunnelStateData);
-    void copy (size_t len, comm_err_t errcode, int xerrno, Connection &from, Connection &to, IOCB *);
+    bool keepGoingAfterRead(size_t len, comm_err_t errcode, int xerrno, Connection &from, Connection &to);
+    void copy(size_t len, Connection &from, Connection &to, IOCB *);
+    void handleConnectResponse(const size_t chunkSize);
     void readServer(char *buf, size_t len, comm_err_t errcode, int xerrno);
     void readClient(char *buf, size_t len, comm_err_t errcode, int xerrno);
     void writeClientDone(char *buf, size_t len, comm_err_t flag, int xerrno);
     void writeServerDone(char *buf, size_t len, comm_err_t flag, int xerrno);
+
+    static void ReadConnectResponseDone(const Comm::ConnectionPointer &, char *buf, size_t len, comm_err_t errcode, int xerrno, void *data);
+    void readConnectResponseDone(char *buf, size_t len, comm_err_t errcode, int xerrno);
 };
 
 static const char *const conn_established = "HTTP/1.1 200 Connection established\r\n\r\n";
@@ -196,7 +225,9 @@ tunnelClientClosed(const CommCloseCbParams &params)
 TunnelStateData::TunnelStateData() :
         url(NULL),
         request(NULL),
-        status_ptr(NULL)
+        status_ptr(NULL),
+        connectRespBuf(NULL),
+        connectReqWriting(false)
 {
     debugs(26, 3, "TunnelStateData constructed this=" << this);
 }
@@ -207,6 +238,7 @@ TunnelStateData::~TunnelStateData()
     assert(noConnections());
     xfree(url);
     serverDestinations.clean();
+    delete connectRespBuf;
 }
 
 TunnelStateData::Connection::~Connection()
@@ -282,7 +314,108 @@ TunnelStateData::readServer(char *buf, size_t len, comm_err_t errcode, int xerrn
         kb_incr(&(statCounter.server.other.kbytes_in), len);
     }
 
-    copy (len, errcode, xerrno, server, client, WriteClientDone);
+    if (keepGoingAfterRead(len, errcode, xerrno, server, client))
+        copy(len, server, client, WriteClientDone);
+}
+
+/// Called when we read [a part of] CONNECT response from the peer
+void
+TunnelStateData::readConnectResponseDone(char *buf, size_t len, comm_err_t errcode, int xerrno)
+{
+    debugs(26, 3, server.conn << ", read " << len << " bytes, err=" << errcode);
+    assert(waitingForConnectResponse());
+
+    if (errcode == COMM_ERR_CLOSING)
+        return;
+
+    if (len > 0) {
+        connectRespBuf->appended(len);
+        server.bytesIn(len);
+        kb_incr(&(statCounter.server.all.kbytes_in), len);
+        kb_incr(&(statCounter.server.other.kbytes_in), len);
+    }
+
+    if (keepGoingAfterRead(len, errcode, xerrno, server, client))
+        handleConnectResponse(len);
+}
+
+/* Read from client side and queue it for writing to the server */
+void
+TunnelStateData::ReadConnectResponseDone(const Comm::ConnectionPointer &, char *buf, size_t len, comm_err_t errcode, int xerrno, void *data)
+{
+    TunnelStateData *tunnelState = (TunnelStateData *)data;
+    assert (cbdataReferenceValid (tunnelState));
+
+    tunnelState->readConnectResponseDone(buf, len, errcode, xerrno);
+}
+
+/// Parses [possibly incomplete] CONNECT response and reacts to it.
+/// If the tunnel is being closed or more response data is needed, returns false.
+/// Otherwise, the caller should handle the remaining read data, if any.
+void
+TunnelStateData::handleConnectResponse(const size_t chunkSize)
+{
+    assert(waitingForConnectResponse());
+
+    // Ideally, client and server should use MemBuf or better, but current code
+    // never accumulates more than one read when shoveling data (XXX) so it does
+    // not need to deal with MemBuf complexity. To keep it simple, we use a
+    // dedicated MemBuf for accumulating CONNECT responses. TODO: When shoveling
+    // is optimized, reuse server.buf for CONNEC response accumulation instead.
+
+    /* mimic the basic parts of HttpStateData::processReplyHeader() */
+    HttpReply rep;
+    Http::StatusCode parseErr = Http::scNone;
+    const bool eof = !chunkSize;
+    const bool parsed = rep.parse(connectRespBuf, eof, &parseErr);
+    if (!parsed) {
+        if (parseErr > 0) { // unrecoverable parsing error
+            server.logicError("malformed CONNECT response from peer");
+            return;
+        }
+
+        // need more data
+        assert(!eof);
+        assert(!parseErr);
+
+        if (!connectRespBuf->hasSpace()) {
+            server.logicError("huge CONNECT response from peer");
+            return;
+        }
+
+        // keep reading
+        readConnectResponse();
+        return;
+    }
+
+    // CONNECT response was successfully parsed
+    *status_ptr = rep.sline.status();
+
+    // bail if we did not get an HTTP 200 (Connection Established) response
+    if (rep.sline.status() != Http::scOkay) {
+        server.logicError("unsupported CONNECT response status code");
+        return;
+    }
+
+    if (rep.hdr_sz < connectRespBuf->contentSize()) {
+        // preserve bytes that the server already sent after the CONNECT response
+        server.len = connectRespBuf->contentSize() - rep.hdr_sz;
+        memcpy(server.buf, connectRespBuf->content()+rep.hdr_sz, server.len);
+    } else {
+        // reset; delay pools were using this field to throttle CONNECT response
+        server.len = 0;
+    }
+
+    delete connectRespBuf;
+    connectRespBuf = NULL;
+    connectExchangeCheckpoint();
+}
+
+void
+TunnelStateData::Connection::logicError(const char *errMsg)
+{
+    debugs(50, 3, conn << " closing on error: " << errMsg);
+    conn->close();
 }
 
 void
@@ -325,11 +458,14 @@ TunnelStateData::readClient(char *buf, size_t len, comm_err_t errcode, int xerrn
         kb_incr(&(statCounter.client_http.kbytes_in), len);
     }
 
-    copy (len, errcode, xerrno, client, server, WriteServerDone);
+    if (keepGoingAfterRead(len, errcode, xerrno, client, server))
+        copy(len, client, server, WriteServerDone);
 }
 
-void
-TunnelStateData::copy (size_t len, comm_err_t errcode, int xerrno, Connection &from, Connection &to, IOCB *completion)
+/// Updates state after reading from client or server.
+/// Returns whether the caller should use the data just read.
+bool
+TunnelStateData::keepGoingAfterRead(size_t len, comm_err_t errcode, int xerrno, Connection &from, Connection &to)
 {
     debugs(26, 3, HERE << "from={" << from.conn << "}, to={" << to.conn << "}");
 
@@ -365,11 +501,19 @@ TunnelStateData::copy (size_t len, comm_err_t errcode, int xerrno, Connection &f
             to.conn->close();
         }
     } else if (cbdataReferenceValid(this)) {
-        debugs(26, 3, HERE << "Schedule Write");
-        AsyncCall::Pointer call = commCbCall(5,5, "TunnelBlindCopyWriteHandler",
-                                             CommIoCbPtrFun(completion, this));
-        Comm::Write(to.conn, from.buf, len, call, NULL);
+        return true;
     }
+
+    return false;
+}
+
+void
+TunnelStateData::copy(size_t len, Connection &from, Connection &to, IOCB *completion)
+{
+    debugs(26, 3, HERE << "Schedule Write");
+    AsyncCall::Pointer call = commCbCall(5,5, "TunnelBlindCopyWriteHandler",
+                                         CommIoCbPtrFun(completion, this));
+    Comm::Write(to.conn, from.buf, len, call, NULL);
 }
 
 /* Writes data from the client buffer to the server side */
@@ -509,16 +653,31 @@ TunnelStateData::copyRead(Connection &from, IOCB *completion)
     comm_read(from.conn, from.buf, from.bytesWanted(1, SQUID_TCP_SO_RCVBUF), call);
 }
 
+void
+TunnelStateData::readConnectResponse()
+{
+    assert(waitingForConnectResponse());
+
+    AsyncCall::Pointer call = commCbCall(5,4, "readConnectResponseDone",
+                                         CommIoCbPtrFun(ReadConnectResponseDone, this));
+    comm_read(server.conn, connectRespBuf->space(),
+              server.bytesWanted(1, connectRespBuf->spaceSize()), call);
+}
+
 /**
  * Set the HTTP status for this request and sets the read handlers for client
  * and server side connections.
  */
 static void
 tunnelStartShoveling(TunnelStateData *tunnelState)
 {
+    assert(!tunnelState->waitingForConnectExchange());
     *tunnelState->status_ptr = Http::scOkay;
     if (cbdataReferenceValid(tunnelState)) {
-        tunnelState->copyRead(tunnelState->server, TunnelStateData::ReadServer);
+        if (!tunnelState->server.len)
+            tunnelState->copyRead(tunnelState->server, TunnelStateData::ReadServer);
+        else
+            tunnelState->copy(tunnelState->server.len, tunnelState->server, tunnelState->client, TunnelStateData::WriteClientDone);
         tunnelState->copyRead(tunnelState->client, TunnelStateData::ReadClient);
     }
 }
@@ -543,6 +702,38 @@ tunnelConnectedWriteDone(const Comm::ConnectionPointer &conn, char *buf, size_t
     tunnelStartShoveling(tunnelState);
 }
 
+/// Called when we are done writing CONNECT request to a peer.
+static void
+tunnelConnectReqWriteDone(const Comm::ConnectionPointer &conn, char *buf, size_t size, comm_err_t flag, int xerrno, void *data)
+{
+    TunnelStateData *tunnelState = (TunnelStateData *)data;
+    debugs(26, 3, conn << ", flag=" << flag);
+    assert(tunnelState->waitingForConnectRequest());
+
+    if (flag != COMM_OK) {
+        *tunnelState->status_ptr = Http::scInternalServerError;
+        tunnelErrorComplete(conn->fd, data, 0);
+        return;
+    }
+
+    tunnelState->connectReqWriting = false;
+    tunnelState->connectExchangeCheckpoint();
+}
+
+void
+TunnelStateData::connectExchangeCheckpoint()
+{
+    if (waitingForConnectResponse()) {
+        debugs(26, 5, "still reading CONNECT response on " << server.conn);
+    } else if (waitingForConnectRequest()) {
+        debugs(26, 5, "still writing CONNECT request on " << server.conn);
+    } else {
+        assert(!waitingForConnectExchange());
+        debugs(26, 3, "done with CONNECT exchange on " << server.conn);
+        tunnelConnected(server.conn, this);
+    }
+}
+
 /*
  * handle the write completion from a proxy request to an upstream origin
  */
@@ -552,7 +743,7 @@ tunnelConnected(const Comm::ConnectionPointer &server, void *data)
     TunnelStateData *tunnelState = (TunnelStateData *)data;
     debugs(26, 3, HERE << server << ", tunnelState=" << tunnelState);
 
-    if (tunnelState->request != NULL && (tunnelState->request->flags.interceptTproxy || tunnelState->request->flags.intercepted))
+    if (!tunnelState->clientExpectsConnectResponse())
         tunnelStartShoveling(tunnelState); // ssl-bumped connection, be quiet
     else {
         AsyncCall::Pointer call = commCbCall(5,5, "tunnelConnectedWriteDone",
@@ -610,7 +801,7 @@ tunnelConnectDone(const Comm::ConnectionPointer &conn, comm_err_t status, int xe
             *tunnelState->status_ptr = Http::scServiceUnavailable;
             err->xerrno = xerrno;
             // on timeout is this still:    err->xerrno = ETIMEDOUT;
-            err->port = conn->remote.GetPort();
+            err->port = conn->remote.port();
             err->callback = tunnelErrorComplete;
             err->callback_data = tunnelState;
             errorSend(tunnelState->client.conn, err);
@@ -664,12 +855,12 @@ tunnelStart(ClientHttpRequest * http, int64_t * size_ptr, int *status_ptr)
     char *url = http->uri;
 
     /*
-     * client_addr.IsNoAddr()  indicates this is an "internal" request
+     * client_addr.isNoAddr()  indicates this is an "internal" request
      * from peer_digest.c, asn.c, netdb.c, etc and should always
      * be allowed.  yuck, I know.
      */
 
-    if (Config.accessList.miss && !request->client_addr.IsNoAddr()) {
+    if (Config.accessList.miss && !request->client_addr.isNoAddr()) {
         /*
          * Check if this host is allowed to fetch MISSES from us (miss_access)
          * default is to allow.
@@ -718,6 +909,7 @@ static void
 tunnelRelayConnectRequest(const Comm::ConnectionPointer &srv, void *data)
 {
     TunnelStateData *tunnelState = (TunnelStateData *)data;
+    assert(!tunnelState->waitingForConnectExchange());
     HttpHeader hdr_out(hoRequest);
     Packer p;
     HttpStateFlags flags;
@@ -738,9 +930,29 @@ tunnelRelayConnectRequest(const Comm::ConnectionPointer &srv, void *data)
     packerClean(&p);
     mb.append("\r\n", 2);
 
-    AsyncCall::Pointer writeCall = commCbCall(5,5, "tunnelConnectedWriteDone",
-                                   CommIoCbPtrFun(tunnelConnectedWriteDone, tunnelState));
-    Comm::Write(srv, &mb, writeCall);
+    if (tunnelState->clientExpectsConnectResponse()) {
+        // hack: blindly tunnel peer response (to our CONNECT request) to the client as ours.
+        AsyncCall::Pointer writeCall = commCbCall(5,5, "tunnelConnectedWriteDone",
+                                       CommIoCbPtrFun(tunnelConnectedWriteDone, tunnelState));
+        Comm::Write(srv, &mb, writeCall);
+    } else {
+        // we have to eat the connect response from the peer (so that the client
+        // does not see it) and only then start shoveling data to the client
+        AsyncCall::Pointer writeCall = commCbCall(5,5, "tunnelConnectReqWriteDone",
+                                       CommIoCbPtrFun(tunnelConnectReqWriteDone,
+                                                      tunnelState));
+        Comm::Write(srv, &mb, writeCall);
+        tunnelState->connectReqWriting = true;
+
+        tunnelState->connectRespBuf = new MemBuf;
+        // SQUID_TCP_SO_RCVBUF: we should not accumulate more than regular I/O buffer
+        // can hold since any CONNECT response leftovers have to fit into server.buf.
+        // 2*SQUID_TCP_SO_RCVBUF: HttpMsg::parse() zero-terminates, which uses space.
+        tunnelState->connectRespBuf->init(SQUID_TCP_SO_RCVBUF, 2*SQUID_TCP_SO_RCVBUF);
+        tunnelState->readConnectResponse();
+
+        assert(tunnelState->waitingForConnectExchange());
+    }
 
     AsyncCall::Pointer timeoutCall = commCbCall(5, 4, "tunnelTimeout",
                                      CommTimeoutCbPtrFun(tunnelTimeout, tunnelState));
@@ -218,7 +218,7 @@ unlinkdInit(void)
 
     args[0] = "(unlinkd)";
     args[1] = NULL;
-    localhost.SetLocalhost();
+    localhost.setLocalhost();
 
     pid = ipcCreate(
 #if USE_POLL && _SQUID_OSF_
@@ -32,7 +32,7 @@
 
 #include "squid.h"
 #include "errorpage.h"
-#include "forward.h"
+#include "FwdState.h"
 #include "globals.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -120,7 +120,7 @@ wccpInit(void)
     last_assign_buckets_change = 0;
     number_caches = 0;
 
-    if (!Config.Wccp.router.IsAnyAddr())
+    if (!Config.Wccp.router.isAnyAddr())
         if (!eventFind(wccpHereIam, NULL))
             eventAdd("wccpHereIam", wccpHereIam, NULL, 5.0, 1);
 }
@@ -130,23 +130,23 @@ wccpConnectionOpen(void)
 {
     debugs(80, 5, "wccpConnectionOpen: Called");
 
-    if (Config.Wccp.router.IsAnyAddr()) {
+    if (Config.Wccp.router.isAnyAddr()) {
         debugs(80, 2, "WCCPv1 disabled.");
         return;
     }
 
-    if ( !Config.Wccp.router.SetIPv4() ) {
+    if ( !Config.Wccp.router.setIPv4() ) {
         debugs(80, DBG_CRITICAL, "WCCPv1 Disabled. Router " << Config.Wccp.router << " is not an IPv4 address.");
         return;
     }
 
-    if ( !Config.Wccp.address.SetIPv4() ) {
+    if ( !Config.Wccp.address.setIPv4() ) {
         debugs(80, DBG_CRITICAL, "WCCPv1 Disabled. Local address " << Config.Wccp.address << " is not an IPv4 address.");
         return;
     }
 
-    Config.Wccp.address.SetPort(WCCP_PORT);
-    Config.Wccp.router.SetPort(WCCP_PORT);
+    Config.Wccp.address.port(WCCP_PORT);
+    Config.Wccp.router.port(WCCP_PORT);
 
     theWccpConnection = comm_open_listener(SOCK_DGRAM,
                                            IPPROTO_UDP,
@@ -164,7 +164,7 @@ wccpConnectionOpen(void)
     // Sadly WCCP only does IPv4
 
     struct sockaddr_in router;
-    Config.Wccp.router.GetSockAddr(router);
+    Config.Wccp.router.getSockAddr(router);
     if (connect(theWccpConnection, (struct sockaddr*)&router, sizeof(router)))
         fatal("Unable to connect WCCP out socket");
 
@@ -690,7 +690,7 @@ wccp2Init(void)
 
     /* Calculate the number of routers configured in the config file */
     for (s = Config.Wccp2.router; s; s = s->next) {
-        if (!s->s.IsAnyAddr()) {
+        if (!s->s.isAnyAddr()) {
             /* Increment the counter */
             ++wccp2_numrouters;
         }
@@ -850,17 +850,17 @@ wccp2Init(void)
 
         /* Add each router.  Keep this functionality here to make sure the received_id can be updated in the packet */
         for (s = Config.Wccp2.router; s; s = s->next) {
-            if (!s->s.IsAnyAddr()) {
+            if (!s->s.isAnyAddr()) {
 
                 wccp2_here_i_am_header.length += sizeof(struct wccp2_router_id_element_t);
                 assert(wccp2_here_i_am_header.length <= WCCP_RESPONSE_SIZE);
 
                 /* Add a pointer to the router list for this router */
 
                 router_list_ptr->info = (struct wccp2_router_id_element_t *) ptr;
-                s->s.GetInAddr(router_list_ptr->info->router_address);
+                s->s.getInAddr(router_list_ptr->info->router_address);
                 router_list_ptr->info->received_id = htonl(0);
-                s->s.GetInAddr(router_list_ptr->router_sendto_address);
+                s->s.getInAddr(router_list_ptr->router_sendto_address);
                 router_list_ptr->member_change = htonl(0);
 
                 /* Build the next struct */
@@ -983,12 +983,12 @@ wccp2ConnectionOpen(void)
         return;
     }
 
-    if ( !Config.Wccp2.address.SetIPv4() ) {
+    if ( !Config.Wccp2.address.setIPv4() ) {
         debugs(80, DBG_CRITICAL, "WCCPv2 Disabled. Local address " << Config.Wccp2.address << " is not an IPv4 address.");
         return;
     }
 
-    Config.Wccp2.address.SetPort(WCCP_PORT);
+    Config.Wccp2.address.port(WCCP_PORT);
     theWccp2Connection = comm_open_listener(SOCK_DGRAM,
                                             0,
                                             Config.Wccp2.address,
@@ -1179,7 +1179,7 @@ wccp2HandleUdp(int sock, void *not_used)
                             0,
                             from_tmp);
     /* FIXME INET6 : drop conversion boundary */
-    from_tmp.GetSockAddr(from);
+    from_tmp.getSockAddr(from);
 
     if (len < 0)
         return;
@@ -1555,7 +1555,7 @@ wccp2HereIam(void *voidnotused)
         return;
     }
 
-    router.SetPort(WCCP_PORT);
+    router.port(WCCP_PORT);
 
     /* for each router on each service send a packet */
     service_list_ptr = wccp2_service_list_head;
@@ -35,10 +35,10 @@
 #include "comm.h"
 #include "comm/Write.h"
 #include "errorpage.h"
+#include "FwdState.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "HttpRequest.h"
-#include "forward.h"
 #include "SquidConfig.h"
 #include "StatCounters.h"
 #include "Store.h"
@@ -838,7 +838,7 @@ process_request(cachemgr_request * req)
 
     S = *gethostbyname(req->hostname);
 
-    if ( !S.IsAnyAddr() ) {
+    if ( !S.isAnyAddr() ) {
         (void) 0;
     } else if ((S = req->hostname))
         (void) 0;
@@ -848,9 +848,9 @@ process_request(cachemgr_request * req)
         return 1;
     }
 
-    S.SetPort(req->port);
+    S.port(req->port);
 
-    S.GetAddrInfo(AI);
+    S.getAddrInfo(AI);
 
 #if USE_IPV6
     if ((s = socket( AI->ai_family, SOCK_STREAM, 0)) < 0) {
@@ -859,21 +859,21 @@ process_request(cachemgr_request * req)
 #endif
         snprintf(buf, sizeof(buf), "socket: %s\n", xstrerror());
         error_html(buf);
-        S.FreeAddrInfo(AI);
+        Ip::Address::FreeAddrInfo(AI);
         return 1;
     }
 
     if (connect(s, AI->ai_addr, AI->ai_addrlen) < 0) {
         snprintf(buf, sizeof(buf), "connect %s: %s\n",
-                 S.ToURL(ipbuf,MAX_IPSTRLEN),
+                 S.toUrl(ipbuf,MAX_IPSTRLEN),
                  xstrerror());
         error_html(buf);
-        S.FreeAddrInfo(AI);
+        Ip::Address::FreeAddrInfo(AI);
         close(s);
         return 1;
     }
 
-    S.FreeAddrInfo(AI);
+    Ip::Address::FreeAddrInfo(AI);
 
     l = snprintf(buf, sizeof(buf),
                  "GET cache_object://%s/%s%s%s HTTP/1.0\r\n"
@@ -591,35 +591,35 @@ main(int argc, char *argv[])
             }
         }
 
-        iaddr.GetAddrInfo(AI);
+        iaddr.getAddrInfo(AI);
         if ((conn = socket(AI->ai_family, AI->ai_socktype, 0)) < 0) {
             perror("client: socket");
-            iaddr.FreeAddrInfo(AI);
+            Ip::Address::FreeAddrInfo(AI);
             exit(1);
         }
-        iaddr.FreeAddrInfo(AI);
+        Ip::Address::FreeAddrInfo(AI);
 
         if (localhost && client_comm_bind(conn, iaddr) < 0) {
             perror("client: bind");
             exit(1);
         }
 
-        iaddr.SetEmpty();
+        iaddr.setEmpty();
         if ( !iaddr.GetHostByName(hostname) ) {
             fprintf(stderr, "client: ERROR: Cannot resolve %s: Host unknown.\n", hostname);
             exit(1);
         }
 
-        iaddr.SetPort(port);
+        iaddr.port(port);
 
         if (opt_verbose) {
             char ipbuf[MAX_IPSTRLEN];
-            fprintf(stderr, "Connecting... %s(%s)\n", hostname, iaddr.NtoA(ipbuf, MAX_IPSTRLEN));
+            fprintf(stderr, "Connecting... %s(%s)\n", hostname, iaddr.toStr(ipbuf, MAX_IPSTRLEN));
         }
 
         if (client_comm_connect(conn, iaddr, ping ? &tv1 : NULL) < 0) {
             char hostnameBuf[MAX_IPSTRLEN];
-            iaddr.ToURL(hostnameBuf, MAX_IPSTRLEN);
+            iaddr.toUrl(hostnameBuf, MAX_IPSTRLEN);
             if (errno == 0) {
                 fprintf(stderr, "client: ERROR: Cannot connect to %s: Host unknown.\n", hostnameBuf);
             } else {
@@ -631,7 +631,7 @@ main(int argc, char *argv[])
         }
         if (opt_verbose) {
             char ipbuf[MAX_IPSTRLEN];
-            fprintf(stderr, "Connected to: %s (%s)\n", hostname, iaddr.NtoA(ipbuf, MAX_IPSTRLEN));
+            fprintf(stderr, "Connected to: %s (%s)\n", hostname, iaddr.toStr(ipbuf, MAX_IPSTRLEN));
         }
 
         /* Send the HTTP request */
@@ -740,39 +740,24 @@ main(int argc, char *argv[])
 static int
 client_comm_bind(int sock, const Ip::Address &addr)
 {
-
-    int res;
-
-    static struct addrinfo *AI = NULL;
-
     /* Set up the source socket address from which to send. */
-
-    addr.GetAddrInfo(AI);
-
-    res = bind(sock, AI->ai_addr, AI->ai_addrlen);
-
-    addr.FreeAddrInfo(AI);
-
+    static struct addrinfo *AI = NULL;
+    addr.getAddrInfo(AI);
+    int res = bind(sock, AI->ai_addr, AI->ai_addrlen);
+    Ip::Address::FreeAddrInfo(AI);
     return res;
 }
 
 static int
 client_comm_connect(int sock, const Ip::Address &addr, struct timeval *tvp)
 {
-    int res;
-    static struct addrinfo *AI = NULL;
-
     /* Set up the destination socket address for message to send to. */
-
-    addr.GetAddrInfo(AI);
-
-    res = connect(sock, AI->ai_addr, AI->ai_addrlen);
-
-    addr.FreeAddrInfo(AI);
-
+    static struct addrinfo *AI = NULL;
+    addr.getAddrInfo(AI);
+    int res = connect(sock, AI->ai_addr, AI->ai_addrlen);
+    Ip::Address::FreeAddrInfo(AI);
     if (tvp)
         (void) Now(tvp);
-
     return res;
 }
 
@@ -782,10 +767,9 @@ Now(struct timeval *tp)
 #if GETTIMEOFDAY_NO_TZP
     return gettimeofday(tp);
 #else
-
     return gettimeofday(tp, NULL);
 #endif
-}				/* ARGSUSED */
+}
 
 void
 catchSignal(int sig)