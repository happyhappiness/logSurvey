@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side.cc,v 1.97 1997/04/28 05:32:40 wessels Exp $
+ * $Id: client_side.cc,v 1.98 1997/04/29 22:12:49 wessels Exp $
  *
  * DEBUG: section 33    Client-side Routines
  * AUTHOR: Duane Wessels
@@ -31,7 +31,7 @@
 
 #include "squid.h"
 
-static void clientRedirectDone _PARAMS((void *data, char *result));
+static RH clientRedirectDone;
 static void icpHandleIMSReply _PARAMS((int fd, StoreEntry * entry, void *data));
 static int clientGetsOldEntry _PARAMS((StoreEntry * new, StoreEntry * old, request_t * request));
 static int checkAccelOnly _PARAMS((icpStateData * icpState));
@@ -1,6 +1,6 @@
 
 /*
- * $Id: comm.cc,v 1.142 1997/04/28 05:32:41 wessels Exp $
+ * $Id: comm.cc,v 1.143 1997/04/29 22:12:50 wessels Exp $
  *
  * DEBUG: section 5     Socket Functions
  * AUTHOR: Harvest Derived
@@ -153,7 +153,7 @@ static void commSetTcpNoDelay _PARAMS((int));
 static void commSetTcpRcvbuf _PARAMS((int, int));
 static void commConnectFree _PARAMS((int fd, void *data));
 static void commConnectHandle _PARAMS((int fd, void *data));
-static void commHandleWrite _PARAMS((int fd, RWStateData * state));
+static void commHandleWrite _PARAMS((int fd, void *data));
 
 static struct timeval zero_tv;
 
@@ -640,7 +640,7 @@ comm_select_incoming(void)
     unsigned long N = 0;
     unsigned long i, nfds;
     int dopoll = 0;
-    PF hdl = NULL;
+    PF *hdl = NULL;
     if (theInIcpConnection >= 0)
 	fds[N++] = theInIcpConnection;
     if (theInIcpConnection != theOutIcpConnection)
@@ -700,7 +700,7 @@ comm_select_incoming(void)
     int fds[4];
     int N = 0;
     int i = 0;
-    PF hdl = NULL;
+    PF *hdl = NULL;
     FD_ZERO(&read_mask);
     FD_ZERO(&write_mask);
     if (theHttpConnection >= 0 && fdstat_are_n_free_fd(RESERVED_FD))
@@ -753,7 +753,7 @@ int
 comm_select(time_t sec)
 {
     struct pollfd pfds[SQUID_MAXFD];
-    PF hdl = NULL;
+    PF *hdl = NULL;
     int fd;
     int i;
     int maxfd;
@@ -943,7 +943,7 @@ comm_select(time_t sec)
 {
     fd_set readfds;
     fd_set writefds;
-    PF hdl = NULL;
+    PF *hdl = NULL;
     int fd;
     int i;
     int maxfd;
@@ -1081,7 +1081,7 @@ comm_select(time_t sec)
 #endif
 
 void
-commSetSelect(int fd, unsigned int type, PF handler, void *client_data, time_t timeout)
+commSetSelect(int fd, unsigned int type, PF * handler, void *client_data, time_t timeout)
 {
     if (fd < 0) {
 	debug_trap("commSetSelect: FD < 0");
@@ -1136,7 +1136,7 @@ comm_get_select_handler(int fd,
 }
 
 void
-comm_add_close_handler(int fd, PF handler, void *data)
+comm_add_close_handler(int fd, PF * handler, void *data)
 {
     struct close_handler *new = xmalloc(sizeof(*new));
     debug(5, 5, "comm_add_close_handler: FD %d, handler=%p, data=%p\n",
@@ -1148,7 +1148,7 @@ comm_add_close_handler(int fd, PF handler, void *data)
 }
 
 void
-comm_remove_close_handler(int fd, PF handler, void *data)
+comm_remove_close_handler(int fd, PF * handler, void *data)
 {
     struct close_handler *p, *last = NULL;
 
@@ -1409,7 +1409,7 @@ static void
 checkTimeouts(void)
 {
     int fd;
-    PF hdl = NULL;
+    PF *hdl = NULL;
     FD_ENTRY *f = NULL;
     void *data;
     /* scan for timeout */
@@ -1435,7 +1435,7 @@ checkLifetimes(void)
     int fd;
     FD_ENTRY *fde = NULL;
 
-    PF hdl = NULL;
+    PF *hdl = NULL;
 
     for (fd = 0; fd <= Biggest_FD; fd++) {
 	fde = &fd_table[fd];
@@ -1489,8 +1489,9 @@ Reserve_More_FDs(void)
 
 /* Write to FD. */
 static void
-commHandleWrite(int fd, RWStateData * state)
+commHandleWrite(int fd, void *data)
 {
+    RWStateData *state = data;
     int len = 0;
     int nleft;
 
@@ -1,5 +1,5 @@
 /*
- * $Id: disk.cc,v 1.59 1997/04/28 05:32:41 wessels Exp $
+ * $Id: disk.cc,v 1.60 1997/04/29 22:12:52 wessels Exp $
  *
  * DEBUG: section 6     Disk I/O Routines
  * AUTHOR: Harvest Derived
@@ -125,21 +125,21 @@ typedef struct _dwalk_ctrl {
     off_t offset;
     char *buf;			/* line buffer */
     int cur_len;		/* line len */
-    FILE_WALK_HD handler;
+    FILE_WALK_HD *handler;
     void *client_data;
-    int (*line_handler) (int fd, char *buf, int size, void *line_data);
+    FILE_WALK_LHD *line_handler;
     void *line_data;
 } dwalk_ctrl;
 
 /* table for FILE variable, write lock and queue. Indexed by fd. */
 FileEntry *file_table;
 
-static int diskHandleRead _PARAMS((int, dread_ctrl *));
-static int diskHandleWalk _PARAMS((int, dwalk_ctrl *));
-static int diskHandleWrite _PARAMS((int, FileEntry *));
 static int diskHandleWriteComplete _PARAMS((void *, int, int));
 static int diskHandleReadComplete _PARAMS((void *, int, int));
 static int diskHandleWalkComplete _PARAMS((void *, int, int));
+static void diskHandleWalk _PARAMS((int, void *));
+static void diskHandleRead _PARAMS((int, void *));
+static void diskHandleWrite _PARAMS((int, void *));
 static void file_open_complete _PARAMS((void *, int, int));
 
 /* initialize table */
@@ -340,15 +340,16 @@ file_close(int fd)
 
 
 /* write handler */
-static int
-diskHandleWrite(int fd, FileEntry * entry)
+static void
+diskHandleWrite(int fd, void *data)
 {
+    FileEntry *entry = data;
     int len = 0;
     disk_ctrl_t *ctrlp;
     dwrite_q *q = NULL;
     dwrite_q *wq = NULL;
     if (!entry->write_q)
-	return DISK_OK;
+	return;
     if (file_table[fd].at_eof == NO)
 	lseek(fd, 0, SEEK_END);
     /* We need to combine subsequent write requests after the first */
@@ -383,12 +384,11 @@ diskHandleWrite(int fd, FileEntry * entry)
 	entry->write_q->len - entry->write_q->cur_offset,
 	diskHandleWriteComplete,
 	ctrlp);
-    return DISK_OK;
 #else
     len = write(fd,
 	entry->write_q->buf + entry->write_q->cur_offset,
 	entry->write_q->len - entry->write_q->cur_offset);
-    return diskHandleWriteComplete(ctrlp, len, errno);
+    diskHandleWriteComplete(ctrlp, len, errno);
 #endif
 }
 
@@ -515,9 +515,10 @@ file_write(int fd,
 
 
 /* Read from FD */
-static int
-diskHandleRead(int fd, dread_ctrl * ctrl_dat)
+static void
+diskHandleRead(int fd, void *data)
 {
+    dread_ctrl *ctrl_dat = data;
     int len;
     disk_ctrl_t *ctrlp;
     ctrlp = xcalloc(1, sizeof(disk_ctrl_t));
@@ -532,12 +533,11 @@ diskHandleRead(int fd, dread_ctrl * ctrl_dat)
 	ctrl_dat->req_len - ctrl_dat->cur_len,
 	diskHandleReadComplete,
 	ctrlp);
-    return DISK_OK;
 #else
     len = read(fd,
 	ctrl_dat->buf + ctrl_dat->cur_len,
 	ctrl_dat->req_len - ctrl_dat->cur_len);
-    return diskHandleReadComplete(ctrlp, len, errno);
+    diskHandleReadComplete(ctrlp, len, errno);
 #endif
 }
 
@@ -609,7 +609,7 @@ diskHandleReadComplete(void *data, int retcode, int errcode)
  * It must have at least req_len space in there. 
  * call handler when a reading is complete. */
 int
-file_read(int fd, char *buf, int req_len, int offset, FILE_READ_HD handler, void *client_data)
+file_read(int fd, char *buf, int req_len, int offset, FILE_READ_HD * handler, void *client_data)
 {
     dread_ctrl *ctrl_dat;
     if (fd < 0)
@@ -637,9 +637,10 @@ file_read(int fd, char *buf, int req_len, int offset, FILE_READ_HD handler, void
 
 
 /* Read from FD and pass a line to routine. Walk to EOF. */
-static int
-diskHandleWalk(int fd, dwalk_ctrl * walk_dat)
+static void
+diskHandleWalk(int fd, void *data)
 {
+    dwalk_ctrl *walk_dat = data;
     int len;
     disk_ctrl_t *ctrlp;
     ctrlp = xcalloc(1, sizeof(disk_ctrl_t));
@@ -653,10 +654,9 @@ diskHandleWalk(int fd, dwalk_ctrl * walk_dat)
 	DISK_LINE_LEN - 1,
 	diskHandleWalkComplete,
 	ctrlp);
-    return DISK_OK;
 #else
     len = read(fd, walk_dat->buf, DISK_LINE_LEN - 1);
-    return diskHandleWalkComplete(ctrlp, len, errno);
+    diskHandleWalkComplete(ctrlp, len, errno);
 #endif
 }
 
@@ -681,8 +681,7 @@ diskHandleWalkComplete(void *data, int retcode, int errcode)
 
     if (len < 0) {
 	if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR) {
-	    commSetSelect(fd, COMM_SELECT_READ, diskHandleWalk,
-		walk_dat, 0);
+	    commSetSelect(fd, COMM_SELECT_READ, diskHandleWalk, walk_dat, 0);
 	    return DISK_OK;
 	}
 	debug(50, 1, "diskHandleWalk: FD %d: error readingd: %s\n",
@@ -734,9 +733,9 @@ diskHandleWalkComplete(void *data, int retcode, int errcode)
  * call a completion handler when done. */
 int
 file_walk(int fd,
-    FILE_WALK_HD handler,
+    FILE_WALK_HD * handler,
     void *client_data,
-    FILE_WALK_LHD line_handler,
+    FILE_WALK_LHD * line_handler,
     void *line_data)
 {
     dwalk_ctrl *walk_dat;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: event.cc,v 1.5 1997/02/27 06:29:11 wessels Exp $
+ * $Id: event.cc,v 1.6 1997/04/29 22:12:53 wessels Exp $
  *
  * DEBUG: section 41    Event Processing
  * AUTHOR: Henrik Nordstrom
@@ -33,7 +33,7 @@
 
 /* The list of event processes */
 struct ev_entry {
-    EVH func;
+    EVH *func;
     void *arg;
     const char *name;
     time_t when;
@@ -43,7 +43,7 @@ struct ev_entry {
 static struct ev_entry *tasks = NULL;
 
 void
-eventAdd(const char *name, EVH func, void *arg, time_t when)
+eventAdd(const char *name, EVH * func, void *arg, time_t when)
 {
     struct ev_entry *event = xcalloc(1, sizeof(struct ev_entry));
     struct ev_entry **E;
@@ -62,7 +62,7 @@ eventAdd(const char *name, EVH func, void *arg, time_t when)
 }
 
 void
-eventDelete(EVH func, void *arg)
+eventDelete(EVH * func, void *arg)
 {
     struct ev_entry **E;
     struct ev_entry *event;
@@ -82,7 +82,7 @@ void
 eventRun(void)
 {
     struct ev_entry *event = NULL;
-    EVH func;
+    EVH *func;
     void *arg;
     if ((event = tasks) == NULL)
 	return;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: fqdncache.cc,v 1.48 1997/04/28 04:23:07 wessels Exp $
+ * $Id: fqdncache.cc,v 1.49 1997/04/29 22:12:54 wessels Exp $
  *
  * DEBUG: section 35    FQDN Cache
  * AUTHOR: Harvest Derived
@@ -114,7 +114,7 @@
 
 struct _fqdn_pending {
     int fd;
-    FQDNH handler;
+    FQDNH *handler;
     void *handlerData;
     struct _fqdn_pending *next;
 };
@@ -151,7 +151,7 @@ static int fqdncacheHasPending _PARAMS((const fqdncache_entry *));
 static fqdncache_entry *fqdncache_get _PARAMS((const char *));
 static void dummy_handler _PARAMS((int, const char *, void *));
 static int fqdncacheExpiredEntry _PARAMS((const fqdncache_entry *));
-static void fqdncacheAddPending _PARAMS((fqdncache_entry *, int fd, FQDNH, void *));
+static void fqdncacheAddPending _PARAMS((fqdncache_entry *, int fd, FQDNH *, void *));
 static void fqdncacheEnqueue _PARAMS((fqdncache_entry *));
 static void *fqdncacheDequeue _PARAMS((void));
 static void fqdncache_dnsDispatch _PARAMS((dnsserver_t *, fqdncache_entry *));
@@ -344,7 +344,7 @@ fqdncache_purgelru(void)
     qsort((char *) LRU_list,
 	LRU_list_count,
 	sizeof(fqdncache_entry *),
-	(QS) fqdncache_compareLastRef);
+	(QS *) fqdncache_compareLastRef);
     for (k = 0; k < LRU_list_count; k++) {
 	if (meta_data.fqdncache_count < fqdncache_low)
 	    break;
@@ -598,7 +598,7 @@ fqdncache_dnsHandleRead(int fd, void *data)
 }
 
 static void
-fqdncacheAddPending(fqdncache_entry * f, int fd, FQDNH handler, void *handlerData)
+fqdncacheAddPending(fqdncache_entry * f, int fd, FQDNH * handler, void *handlerData)
 {
     struct _fqdn_pending *pending = xcalloc(1, sizeof(struct _fqdn_pending));
     struct _fqdn_pending **I = NULL;
@@ -613,7 +613,7 @@ fqdncacheAddPending(fqdncache_entry * f, int fd, FQDNH handler, void *handlerDat
 }
 
 void
-fqdncache_nbgethostbyaddr(struct in_addr addr, int fd, FQDNH handler, void *handlerData)
+fqdncache_nbgethostbyaddr(struct in_addr addr, int fd, FQDNH * handler, void *handlerData)
 {
     fqdncache_entry *f = NULL;
     dnsserver_t *dnsData = NULL;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ftp.cc,v 1.100 1997/04/28 05:32:42 wessels Exp $
+ * $Id: ftp.cc,v 1.101 1997/04/29 22:12:56 wessels Exp $
  *
  * DEBUG: section 9     File Transfer Protocol (FTP)
  * AUTHOR: Harvest Derived
@@ -135,58 +135,58 @@ typedef struct ftp_ctrl_t {
 /* Local functions */
 static const char *ftpTransferMode _PARAMS((const char *));
 static char *ftpGetBasicAuth _PARAMS((const char *));
-static int ftpReadReply _PARAMS((int, FtpStateData *));
-static int ftpStateFree _PARAMS((int, FtpStateData *));
+static void ftpStateFree _PARAMS((int, void *));
+static void ftpReadReply _PARAMS((int, void *));
 static void ftpStartComplete _PARAMS((void *, int));
 static void ftpConnectDone _PARAMS((int fd, int status, void *data));
-static void ftpLifetimeExpire _PARAMS((int, FtpStateData *));
+static void ftpLifetimeExpire _PARAMS((int, void *));
 static void ftpProcessReplyHeader _PARAMS((FtpStateData *, const char *, int));
 static void ftpSendComplete _PARAMS((int, char *, int, int, void *));
-static void ftpSendRequest _PARAMS((int, FtpStateData *));
+static void ftpSendRequest _PARAMS((int, void *));
 static void ftpServerClosed _PARAMS((int, void *));
 static void ftp_login_parser _PARAMS((const char *, FtpStateData *));
 
 /* External functions */
 extern char *base64_decode _PARAMS((const char *coded));
 
-static int
-ftpStateFree(int fd, FtpStateData * ftpState)
+static void
+ftpStateFree(int fd, void *data)
 {
+    FtpStateData *ftpState = data;
     if (ftpState == NULL)
-	return 1;
+	return;
     storeUnlockObject(ftpState->entry);
     if (ftpState->reply_hdr) {
 	put_free_8k_page(ftpState->reply_hdr);
 	ftpState->reply_hdr = NULL;
     }
     requestUnlink(ftpState->request);
     xfree(ftpState);
-    return 0;
 }
 
 static void
-ftp_login_parser(const char *login, FtpStateData * data)
+ftp_login_parser(const char *login, FtpStateData * ftpState)
 {
     char *s = NULL;
-    xstrncpy(data->user, login, MAX_URL);
-    if ((s = strchr(data->user, ':'))) {
+    xstrncpy(ftpState->user, login, MAX_URL);
+    if ((s = strchr(ftpState->user, ':'))) {
 	*s = 0;
-	xstrncpy(data->password, s + 1, MAX_URL);
+	xstrncpy(ftpState->password, s + 1, MAX_URL);
     } else {
-	xstrncpy(data->password, null_string, MAX_URL);
+	xstrncpy(ftpState->password, null_string, MAX_URL);
     }
-    if (data->user[0] || data->password[0])
+    if (ftpState->user[0] || ftpState->password[0])
 	return;
-    xstrncpy(data->user, "anonymous", MAX_URL);
-    xstrncpy(data->password, Config.ftpUser, MAX_URL);
+    xstrncpy(ftpState->user, "anonymous", MAX_URL);
+    xstrncpy(ftpState->password, Config.ftpUser, MAX_URL);
 }
 
 /* This will be called when socket lifetime is expired. */
 static void
-ftpLifetimeExpire(int fd, FtpStateData * data)
+ftpLifetimeExpire(int fd, void *data)
 {
-    StoreEntry *entry = NULL;
-    entry = data->entry;
+    FtpStateData *ftpState = data;
+    StoreEntry *entry = ftpState->entry;
     debug(9, 4, "ftpLifeTimeExpire: FD %d: '%s'\n", fd, entry->url);
     squid_error_entry(entry, ERR_LIFETIME_EXP, NULL);
     comm_close(fd);
@@ -196,41 +196,41 @@ ftpLifetimeExpire(int fd, FtpStateData * data)
 /* This is too much duplicated code from httpProcessReplyHeader.  Only
  * difference is FtpStateData vs HttpData. */
 static void
-ftpProcessReplyHeader(FtpStateData * data, const char *buf, int size)
+ftpProcessReplyHeader(FtpStateData * ftpState, const char *buf, int size)
 {
     char *t = NULL;
-    StoreEntry *entry = data->entry;
+    StoreEntry *entry = ftpState->entry;
     int room;
     int hdr_len;
     struct _http_reply *reply = entry->mem_obj->reply;
 
     debug(11, 3, "ftpProcessReplyHeader: key '%s'\n", entry->key);
 
-    if (data->reply_hdr == NULL)
-	data->reply_hdr = get_free_8k_page();
-    if (data->reply_hdr_state == 0) {
-	hdr_len = strlen(data->reply_hdr);
+    if (ftpState->reply_hdr == NULL)
+	ftpState->reply_hdr = get_free_8k_page();
+    if (ftpState->reply_hdr_state == 0) {
+	hdr_len = strlen(ftpState->reply_hdr);
 	room = 8191 - hdr_len;
-	strncat(data->reply_hdr, buf, room < size ? room : size);
+	strncat(ftpState->reply_hdr, buf, room < size ? room : size);
 	hdr_len += room < size ? room : size;
-	if (hdr_len > 4 && strncmp(data->reply_hdr, "HTTP/", 5)) {
+	if (hdr_len > 4 && strncmp(ftpState->reply_hdr, "HTTP/", 5)) {
 	    debug(11, 3, "ftpProcessReplyHeader: Non-HTTP-compliant header: '%s'\n", entry->key);
-	    data->reply_hdr_state += 2;
+	    ftpState->reply_hdr_state += 2;
 	    return;
 	}
 	/* Find the end of the headers */
-	if ((t = mime_headers_end(data->reply_hdr)) == NULL)
+	if ((t = mime_headers_end(ftpState->reply_hdr)) == NULL)
 	    return;		/* headers not complete */
 	/* Cut after end of headers */
 	*t = '\0';
-	data->reply_hdr_state++;
+	ftpState->reply_hdr_state++;
     }
-    if (data->reply_hdr_state == 1) {
-	data->reply_hdr_state++;
+    if (ftpState->reply_hdr_state == 1) {
+	ftpState->reply_hdr_state++;
 	debug(11, 9, "GOT HTTP REPLY HDR:\n---------\n%s\n----------\n",
-	    data->reply_hdr);
+	    ftpState->reply_hdr);
 	/* Parse headers into reply structure */
-	httpParseReplyHeaders(data->reply_hdr, reply);
+	httpParseReplyHeaders(ftpState->reply_hdr, reply);
 	storeTimestampsSet(entry);
 	/* Check if object is cacheable or not based on reply code */
 	if (reply->code)
@@ -267,22 +267,23 @@ ftpProcessReplyHeader(FtpStateData * data, const char *buf, int size)
 
 /* This will be called when data is ready to be read from fd.  Read until
  * error or connection closed. */
-static int
-ftpReadReply(int fd, FtpStateData * data)
+static void
+ftpReadReply(int fd, void *data)
 {
+    FtpStateData *ftpState = data;
     LOCAL_ARRAY(char, buf, SQUID_TCP_SO_RCVBUF);
     int len;
     int clen;
     int off;
     int bin;
     StoreEntry *entry = NULL;
 
-    entry = data->entry;
+    entry = ftpState->entry;
     if (entry->flag & DELETE_BEHIND && !storeClientWaiting(entry)) {
 	/* we can terminate connection right now */
 	squid_error_entry(entry, ERR_NO_CLIENTS_BIG_OBJ, NULL);
 	comm_close(fd);
-	return 0;
+	return;
     }
     /* check if we want to defer reading */
     clen = entry->mem_obj->e_current_len;
@@ -308,7 +309,7 @@ ftpReadReply(int fd, FtpStateData * data)
 	}
 	/* dont try reading again for a while */
 	comm_set_stall(fd, Config.stallDelay);
-	return 0;
+	return;
     } else {
 	BIT_RESET(entry->flag, READ_DEFERRED);
     }
@@ -343,7 +344,7 @@ ftpReadReply(int fd, FtpStateData * data)
 	comm_close(fd);
     } else if (len == 0) {
 	/* Connection closed; retrieval done. */
-	if (!data->got_marker) {
+	if (!ftpState->got_marker) {
 	    /* If we didn't see the magic marker, assume the transfer
 	     * failed and arrange so the object gets ejected and
 	     * never gets to disk. */
@@ -363,22 +364,22 @@ ftpReadReply(int fd, FtpStateData * data)
 	squid_error_entry(entry, ERR_CLIENT_ABORT, NULL);
 	comm_close(fd);
     } else {
-	if (data->got_marker) {
+	if (ftpState->got_marker) {
 	    /* oh, this is so gross -- we found the marker at the
 	     * end of the previous read, but theres more data!
 	     * So put the marker back in. */
 	    storeAppend(entry, MAGIC_MARKER, MAGIC_MARKER_SZ);
 	}
 	/* check for a magic marker at the end of the read */
-	data->got_marker = 0;
+	ftpState->got_marker = 0;
 	if (len >= MAGIC_MARKER_SZ) {
 	    if (!memcmp(MAGIC_MARKER, buf + len - MAGIC_MARKER_SZ, MAGIC_MARKER_SZ)) {
-		data->got_marker = 1;
+		ftpState->got_marker = 1;
 		len -= MAGIC_MARKER_SZ;
 	    }
 	}
 	storeAppend(entry, buf, len);
-	if (data->reply_hdr_state < 2 && len > 0)
+	if (ftpState->reply_hdr_state < 2 && len > 0)
 	    ftpProcessReplyHeader(data, buf, len);
 	commSetSelect(fd,
 	    COMM_SELECT_READ,
@@ -390,7 +391,6 @@ ftpReadReply(int fd, FtpStateData * data)
 	    data,
 	    Config.readTimeout);
     }
-    return 0;
 }
 
 static void
@@ -443,8 +443,9 @@ ftpTransferMode(const char *urlpath)
 }
 
 static void
-ftpSendRequest(int fd, FtpStateData * data)
+ftpSendRequest(int fd, void *data)
 {
+    FtpStateData *ftpState = data;
     char *path = NULL;
     const char *mode = NULL;
     char *buf = NULL;
@@ -459,7 +460,7 @@ ftpSendRequest(int fd, FtpStateData * data)
 
     buf = get_free_8k_page();
 
-    path = data->request->urlpath;
+    path = ftpState->request->urlpath;
     mode = ftpTransferMode(path);
 
     /* Start building the buffer ... */
@@ -483,15 +484,15 @@ ftpSendRequest(int fd, FtpStateData * data)
 	sprintf(tbuf, "-n %d ", Config.negativeTtl);
 	strcat(buf, tbuf);
     }
-    if (data->request->port) {
-	sprintf(tbuf, "-P %d ", data->request->port);
+    if (ftpState->request->port) {
+	sprintf(tbuf, "-P %d ", ftpState->request->port);
 	strcat(buf, tbuf);
     }
     if ((s = Config.visibleHostname)) {
 	sprintf(tbuf, "-H %s ", s);
 	strcat(buf, tbuf);
     }
-    if (data->authenticated) {
+    if (ftpState->authenticated) {
 	strcat(buf, "-a ");
     }
     if (Config.Addrs.tcp_outgoing.s_addr != no_addr.s_addr) {
@@ -500,23 +501,23 @@ ftpSendRequest(int fd, FtpStateData * data)
     }
     strcat(buf, "-h ");		/* httpify */
     strcat(buf, "- ");		/* stdout */
-    strcat(buf, data->request->host);
+    strcat(buf, ftpState->request->host);
     strcat(buf, space);
     strcat(buf, *path ? path : "\"\"");
     strcat(buf, space);
     strcat(buf, mode);		/* A or I */
     strcat(buf, space);
-    strcat(buf, *data->user ? data->user : "\"\"");
+    strcat(buf, *ftpState->user ? ftpState->user : "\"\"");
     strcat(buf, space);
-    strcat(buf, *data->password ? data->password : "\"\"");
+    strcat(buf, *ftpState->password ? ftpState->password : "\"\"");
     strcat(buf, "\n");
     debug(9, 5, "ftpSendRequest: FD %d: buf '%s'\n", fd, buf);
     comm_write(fd,
 	buf,
 	strlen(buf),
 	30,
 	ftpSendComplete,
-	data,
+	ftpState,
 	put_free_8k_page);
 }
 
@@ -1,5 +1,5 @@
 /*
- * $Id: gopher.cc,v 1.74 1997/04/28 05:32:43 wessels Exp $
+ * $Id: gopher.cc,v 1.75 1997/04/29 22:12:56 wessels Exp $
  *
  * DEBUG: section 10    Gopher
  * AUTHOR: Harvest Derived
@@ -158,7 +158,7 @@ typedef struct gopher_ds {
     char *buf;			/* pts to a 4k page */
 } GopherStateData;
 
-static int gopherStateFree _PARAMS((int fd, GopherStateData *));
+static PF gopherStateFree;
 static void gopher_mime_content _PARAMS((char *buf, const char *name, const char *def));
 static void gopherMimeCreate _PARAMS((GopherStateData *));
 static int gopher_url_parser(const char *url,
@@ -168,32 +168,32 @@ static int gopher_url_parser(const char *url,
     char *request);
 static void gopherEndHTML _PARAMS((GopherStateData *));
 static void gopherToHTML _PARAMS((GopherStateData *, char *inbuf, int len));
-static int gopherReadReplyTimeout _PARAMS((int fd, GopherStateData *));
-static void gopherLifetimeExpire _PARAMS((int fd, GopherStateData *));
-static void gopherReadReply _PARAMS((int fd, GopherStateData *));
+static PF gopherReadReplyTimeout;
+static PF gopherLifetimeExpire;
+static PF gopherReadReply;
 static void gopherSendComplete(int fd,
     char *buf,
     int size,
     int errflag,
     void *data);
-static void gopherStartComplete _PARAMS((void *, int));
-static void gopherSendRequest _PARAMS((int fd, GopherStateData *));
+static void gopherStartComplete _PARAMS((void *datap, int status));
+static PF gopherSendRequest;
 static GopherStateData *CreateGopherStateData _PARAMS((void));
-static void gopherConnectDone _PARAMS((int fd, int status, void *data));
+static CCH gopherConnectDone;
 
 static char def_gopher_bin[] = "www/unknown";
 static char def_gopher_text[] = "text/plain";
 
-static int
-gopherStateFree(int fd, GopherStateData * gopherState)
+static void
+gopherStateFree(int fd, void *data)
 {
+    GopherStateData *gopherState = data;
     if (gopherState == NULL)
-	return 1;
+	return;
     if (gopherState->entry)
 	storeUnlockObject(gopherState->entry);
     put_free_4k_page(gopherState->buf);
     xfree(gopherState);
-    return 0;
 }
 
 
@@ -249,7 +249,7 @@ gopher_mime_content(char *buf, const char *name, const char *def)
 
 /* create MIME Header for Gopher Data */
 static void
-gopherMimeCreate(GopherStateData * data)
+gopherMimeCreate(GopherStateData * gopherState)
 {
     LOCAL_ARRAY(char, tempMIME, MAX_MIME);
 
@@ -260,7 +260,7 @@ gopherMimeCreate(GopherStateData * data)
 	"MIME-version: 1.0\r\n",
 	version_string, mkrfc1123(squid_curtime));
 
-    switch (data->type_id) {
+    switch (gopherState->type_id) {
 
     case GOPHER_DIRECTORY:
     case GOPHER_INDEX:
@@ -286,18 +286,18 @@ gopherMimeCreate(GopherStateData * data)
     case GOPHER_UUENCODED:
     case GOPHER_BIN:
 	/* Rightnow We have no idea what it is. */
-	gopher_mime_content(tempMIME, data->request, def_gopher_bin);
+	gopher_mime_content(tempMIME, gopherState->request, def_gopher_bin);
 	break;
 
     case GOPHER_FILE:
     default:
-	gopher_mime_content(tempMIME, data->request, def_gopher_text);
+	gopher_mime_content(tempMIME, gopherState->request, def_gopher_text);
 	break;
 
     }
 
     strcat(tempMIME, "\r\n");
-    storeAppend(data->entry, tempMIME, strlen(tempMIME));
+    storeAppend(gopherState->entry, tempMIME, strlen(tempMIME));
 }
 
 /* Parse a gopher url into components.  By Anawat. */
@@ -337,17 +337,17 @@ gopher_url_parser(const char *url, char *host, int *port, char *type_id, char *r
 int
 gopherCachable(const char *url)
 {
-    GopherStateData *data = NULL;
+    GopherStateData *gopherState = NULL;
     int cachable = 1;
     /* use as temp data structure to parse gopher URL */
-    data = CreateGopherStateData();
+    gopherState = CreateGopherStateData();
     /* parse to see type */
     gopher_url_parser(url,
-	data->host,
-	&data->port,
-	&data->type_id,
-	data->request);
-    switch (data->type_id) {
+	gopherState->host,
+	&gopherState->port,
+	&gopherState->type_id,
+	gopherState->request);
+    switch (gopherState->type_id) {
     case GOPHER_INDEX:
     case GOPHER_CSO:
     case GOPHER_TELNET:
@@ -357,19 +357,19 @@ gopherCachable(const char *url)
     default:
 	cachable = 1;
     }
-    gopherStateFree(-1, data);
+    gopherStateFree(-1, gopherState);
     return cachable;
 }
 
 static void
-gopherEndHTML(GopherStateData * data)
+gopherEndHTML(GopherStateData * gopherState)
 {
     LOCAL_ARRAY(char, tmpbuf, TEMP_BUF_SIZE);
 
-    if (!data->data_in) {
+    if (!gopherState->data_in) {
 	sprintf(tmpbuf, "<HTML><HEAD><TITLE>Server Return Nothing.</TITLE>\n"
 	    "</HEAD><BODY><HR><H1>Server Return Nothing.</H1></BODY></HTML>\n");
-	storeAppend(data->entry, tmpbuf, strlen(tmpbuf));
+	storeAppend(gopherState->entry, tmpbuf, strlen(tmpbuf));
 	return;
     }
 }
@@ -378,7 +378,7 @@ gopherEndHTML(GopherStateData * data)
 /* Convert Gopher to HTML */
 /* Borrow part of code from libwww2 came with Mosaic distribution */
 static void
-gopherToHTML(GopherStateData * data, char *inbuf, int len)
+gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)
 {
     char *pos = inbuf;
     char *lpos = NULL;
@@ -399,9 +399,9 @@ gopherToHTML(GopherStateData * data, char *inbuf, int len)
     memset(tmpbuf, '\0', TEMP_BUF_SIZE);
     memset(line, '\0', TEMP_BUF_SIZE);
 
-    entry = data->entry;
+    entry = gopherState->entry;
 
-    if (data->conversion == HTML_INDEX_PAGE) {
+    if (gopherState->conversion == HTML_INDEX_PAGE) {
 	sprintf(outbuf, "<HTML><HEAD><TITLE>Gopher Index %s</TITLE></HEAD>\n"
 	    "<BODY><H1>%s<BR>Gopher Search</H1>\n"
 	    "<p>This is a searchable Gopher index. Use the search\n"
@@ -410,11 +410,11 @@ gopherToHTML(GopherStateData * data, char *inbuf, int len)
 	storeAppend(entry, outbuf, strlen(outbuf));
 	/* now let start sending stuff to client */
 	BIT_RESET(entry->flag, DELAY_SENDING);
-	data->data_in = 1;
+	gopherState->data_in = 1;
 
 	return;
     }
-    if (data->conversion == HTML_CSO_PAGE) {
+    if (gopherState->conversion == HTML_CSO_PAGE) {
 	sprintf(outbuf, "<HTML><HEAD><TITLE>CSO Search of %s</TITLE></HEAD>\n"
 	    "<BODY><H1>%s<BR>CSO Search</H1>\n"
 	    "<P>A CSO database usually contains a phonebook or\n"
@@ -425,39 +425,39 @@ gopherToHTML(GopherStateData * data, char *inbuf, int len)
 	storeAppend(entry, outbuf, strlen(outbuf));
 	/* now let start sending stuff to client */
 	BIT_RESET(entry->flag, DELAY_SENDING);
-	data->data_in = 1;
+	gopherState->data_in = 1;
 
 	return;
     }
     inbuf[len] = '\0';
 
-    if (!data->HTML_header_added) {
-	if (data->conversion == HTML_CSO_RESULT)
+    if (!gopherState->HTML_header_added) {
+	if (gopherState->conversion == HTML_CSO_RESULT)
 	    strcat(outbuf, "<HTML><HEAD><TITLE>CSO Searchs Result</TITLE></HEAD>\n"
 		"<BODY><H1>CSO Searchs Result</H1>\n<PRE>\n");
 	else
 	    strcat(outbuf, "<HTML><HEAD><TITLE>Gopher Menu</TITLE></HEAD>\n"
 		"<BODY><H1>Gopher Menu</H1>\n<PRE>\n");
-	data->HTML_header_added = 1;
+	gopherState->HTML_header_added = 1;
     }
     while ((pos != NULL) && (pos < inbuf + len)) {
 
-	if (data->len != 0) {
+	if (gopherState->len != 0) {
 	    /* there is something left from last tx. */
-	    xstrncpy(line, data->buf, data->len);
-	    lpos = (char *) memccpy(line + data->len, inbuf, '\n', len);
+	    xstrncpy(line, gopherState->buf, gopherState->len);
+	    lpos = (char *) memccpy(line + gopherState->len, inbuf, '\n', len);
 	    if (lpos)
 		*lpos = '\0';
 	    else {
 		/* there is no complete line in inbuf */
 		/* copy it to temp buffer */
-		if (data->len + len > TEMP_BUF_SIZE) {
+		if (gopherState->len + len > TEMP_BUF_SIZE) {
 		    debug(10, 1, "GopherHTML: Buffer overflow. Lost some data on URL: %s\n",
 			entry->url);
-		    len = TEMP_BUF_SIZE - data->len;
+		    len = TEMP_BUF_SIZE - gopherState->len;
 		}
-		xmemcpy(data->buf + data->len, inbuf, len);
-		data->len += len;
+		xmemcpy(gopherState->buf + gopherState->len, inbuf, len);
+		gopherState->len += len;
 		return;
 	    }
 
@@ -467,8 +467,8 @@ gopherToHTML(GopherStateData * data, char *inbuf, int len)
 		pos++;
 
 	    /* we're done with the remain from last tx. */
-	    data->len = 0;
-	    *(data->buf) = '\0';
+	    gopherState->len = 0;
+	    *(gopherState->buf) = '\0';
 	} else {
 
 	    lpos = (char *) memccpy(line, pos, '\n', len - (pos - inbuf));
@@ -483,8 +483,8 @@ gopherToHTML(GopherStateData * data, char *inbuf, int len)
 		    len = TEMP_BUF_SIZE;
 		}
 		if (len > (pos - inbuf)) {
-		    xmemcpy(data->buf, pos, len - (pos - inbuf));
-		    data->len = len - (pos - inbuf);
+		    xmemcpy(gopherState->buf, pos, len - (pos - inbuf));
+		    gopherState->len = len - (pos - inbuf);
 		}
 		break;
 	    }
@@ -503,7 +503,7 @@ gopherToHTML(GopherStateData * data, char *inbuf, int len)
 	    memset(line, '\0', TEMP_BUF_SIZE);
 	    continue;
 	}
-	switch (data->conversion) {
+	switch (gopherState->conversion) {
 
 	case HTML_INDEX_RESULT:
 	case HTML_DIR:{
@@ -593,7 +593,7 @@ gopherToHTML(GopherStateData * data, char *inbuf, int len)
 			}
 			safe_free(escaped_selector);
 			strcat(outbuf, tmpbuf);
-			data->data_in = 1;
+			gopherState->data_in = 1;
 		    } else {
 			memset(line, '\0', TEMP_BUF_SIZE);
 			continue;
@@ -622,14 +622,14 @@ gopherToHTML(GopherStateData * data, char *inbuf, int len)
 		    if (code != 200)
 			break;
 
-		    if (data->cso_recno != recno) {
+		    if (gopherState->cso_recno != recno) {
 			sprintf(tmpbuf, "</PRE><HR><H2>Record# %d<br><i>%s</i></H2>\n<PRE>", recno, result);
-			data->cso_recno = recno;
+			gopherState->cso_recno = recno;
 		    } else {
 			sprintf(tmpbuf, "%s\n", result);
 		    }
 		    strcat(outbuf, tmpbuf);
-		    data->data_in = 1;
+		    gopherState->data_in = 1;
 		    break;
 		} else {
 		    /* handle some error codes */
@@ -653,7 +653,7 @@ gopherToHTML(GopherStateData * data, char *inbuf, int len)
 			    /* Print the message the server returns */
 			    sprintf(tmpbuf, "</PRE><HR><H2>%s</H2>\n<PRE>", result);
 			    strcat(outbuf, tmpbuf);
-			    data->data_in = 1;
+			    gopherState->data_in = 1;
 			    break;
 			}
 
@@ -677,23 +677,24 @@ gopherToHTML(GopherStateData * data, char *inbuf, int len)
     return;
 }
 
-static int
-gopherReadReplyTimeout(int fd, GopherStateData * data)
+static void
+gopherReadReplyTimeout(int fd, void *data)
 {
+    GopherStateData *gopherState = data;
     StoreEntry *entry = NULL;
-    entry = data->entry;
-    debug(10, 4, "GopherReadReplyTimeout: Timeout on %d\n url: %s\n", fd, entry->url);
+    entry = gopherState->entry;
+    debug(10, 4, "GopherReadReplyTimeout: Timeout on %d\n url: %s\n",
+	fd, entry->url);
     squid_error_entry(entry, ERR_READ_TIMEOUT, NULL);
     comm_close(fd);
-    return 0;
 }
 
 /* This will be called when socket lifetime is expired. */
 static void
-gopherLifetimeExpire(int fd, GopherStateData * data)
+gopherLifetimeExpire(int fd, void *data)
 {
-    StoreEntry *entry = NULL;
-    entry = data->entry;
+    GopherStateData *gopherState = data;
+    StoreEntry *entry = gopherState->entry;
     debug(10, 4, "gopherLifeTimeExpire: FD %d: '%s'\n", fd, entry->url);
     squid_error_entry(entry, ERR_LIFETIME_EXP, NULL);
     commSetSelect(fd,
@@ -707,16 +708,17 @@ gopherLifetimeExpire(int fd, GopherStateData * data)
 /* This will be called when data is ready to be read from fd.  Read until
  * error or connection closed. */
 static void
-gopherReadReply(int fd, GopherStateData * data)
+gopherReadReply(int fd, void *data)
 {
+    GopherStateData *gopherState = data;
     char *buf = NULL;
     int len;
     int clen;
     int off;
     StoreEntry *entry = NULL;
     int bin;
 
-    entry = data->entry;
+    entry = gopherState->entry;
     if (entry->flag & DELETE_BEHIND && !storeClientWaiting(entry)) {
 	/* we can terminate connection right now */
 	squid_error_entry(entry, ERR_NO_CLIENTS_BIG_OBJ, NULL);
@@ -797,7 +799,7 @@ gopherReadReply(int fd, GopherStateData * data)
     } else if (len == 0) {
 	/* Connection closed; retrieval done. */
 	/* flush the rest of data in temp buf if there is one. */
-	if (data->conversion != NORMAL)
+	if (gopherState->conversion != NORMAL)
 	    gopherEndHTML(data);
 	if (!(entry->flag & DELETE_BEHIND))
 	    storeTimestampsSet(entry);
@@ -806,18 +808,18 @@ gopherReadReply(int fd, GopherStateData * data)
 	comm_close(fd);
     } else if (entry->flag & CLIENT_ABORT_REQUEST) {
 	/* append the last bit of info we got */
-	if (data->conversion != NORMAL) {
+	if (gopherState->conversion != NORMAL) {
 	    gopherToHTML(data, buf, len);
 	} else {
 	    storeAppend(entry, buf, len);
 	}
 	squid_error_entry(entry, ERR_CLIENT_ABORT, NULL);
-	if (data->conversion != NORMAL)
+	if (gopherState->conversion != NORMAL)
 	    gopherEndHTML(data);
 	BIT_RESET(entry->flag, DELAY_SENDING);
 	comm_close(fd);
     } else {
-	if (data->conversion != NORMAL) {
+	if (gopherState->conversion != NORMAL) {
 	    gopherToHTML(data, buf, len);
 	} else {
 	    storeAppend(entry, buf, len);
@@ -908,20 +910,21 @@ gopherSendComplete(int fd, char *buf, int size, int errflag, void *data)
 
 /* This will be called when connect completes. Write request. */
 static void
-gopherSendRequest(int fd, GopherStateData * data)
+gopherSendRequest(int fd, void *data)
 {
+    GopherStateData *gopherState = data;
     LOCAL_ARRAY(char, query, MAX_URL);
     char *buf = get_free_4k_page();
     char *t;
-    if (data->type_id == GOPHER_CSO) {
-	sscanf(data->request, "?%s", query);
+    if (gopherState->type_id == GOPHER_CSO) {
+	sscanf(gopherState->request, "?%s", query);
 	sprintf(buf, "query %s\r\nquit\r\n", query);
-    } else if (data->type_id == GOPHER_INDEX) {
-	if ((t = strchr(data->request, '?')))
+    } else if (gopherState->type_id == GOPHER_INDEX) {
+	if ((t = strchr(gopherState->request, '?')))
 	    *t = '\t';
-	sprintf(buf, "%s\r\n", data->request);
+	sprintf(buf, "%s\r\n", gopherState->request);
     } else {
-	sprintf(buf, "%s\r\n", data->request);
+	sprintf(buf, "%s\r\n", gopherState->request);
     }
     debug(10, 5, "gopherSendRequest: FD %d\n", fd);
     comm_write(fd,
@@ -931,8 +934,8 @@ gopherSendRequest(int fd, GopherStateData * data)
 	gopherSendComplete,
 	data,
 	put_free_4k_page);
-    if (BIT_TEST(data->entry->flag, ENTRY_CACHABLE))
-	storeSetPublicKey(data->entry);		/* Make it public */
+    if (BIT_TEST(gopherState->entry->flag, ENTRY_CACHABLE))
+	storeSetPublicKey(gopherState->entry);	/* Make it public */
 }
 
 int
@@ -948,15 +951,15 @@ gopherStartComplete(void *datap, int status)
 {
     StoreEntry *entry = datap;
     char *url = entry->url;
-    GopherStateData *data = CreateGopherStateData();
+    GopherStateData *gopherState = CreateGopherStateData();
     int sock;
-    data->entry = entry;
+    gopherState->entry = entry;
     debug(10, 3, "gopherStart: url: %s\n", url);
     /* Parse url. */
-    if (gopher_url_parser(url, data->host, &data->port,
-	    &data->type_id, data->request)) {
+    if (gopher_url_parser(url, gopherState->host, &gopherState->port,
+	    &gopherState->type_id, gopherState->request)) {
 	squid_error_entry(entry, ERR_INVALID_URL, NULL);
-	gopherStateFree(-1, data);
+	gopherStateFree(-1, gopherState);
 	return;
     }
     /* Create socket. */
@@ -969,46 +972,46 @@ gopherStartComplete(void *datap, int status)
     if (sock == COMM_ERROR) {
 	debug(10, 4, "gopherStart: Failed because we're out of sockets.\n");
 	squid_error_entry(entry, ERR_NO_FDS, xstrerror());
-	gopherStateFree(-1, data);
+	gopherStateFree(-1, gopherState);
 	return;
     }
     comm_add_close_handler(sock,
 	gopherStateFree,
-	data);
+	gopherState);
     /* check if IP is already in cache. It must be. 
      * It should be done before this route is called. 
      * Otherwise, we cannot check return code for connect. */
-    if (!ipcache_gethostbyname(data->host, 0)) {
+    if (!ipcache_gethostbyname(gopherState->host, 0)) {
 	debug(10, 4, "gopherStart: Called without IP entry in ipcache. OR lookup failed.\n");
 	squid_error_entry(entry, ERR_DNS_FAIL, dns_error_message);
 	comm_close(sock);
 	return;
     }
-    if (((data->type_id == GOPHER_INDEX) || (data->type_id == GOPHER_CSO))
-	&& (strchr(data->request, '?') == NULL)
+    if (((gopherState->type_id == GOPHER_INDEX) || (gopherState->type_id == GOPHER_CSO))
+	&& (strchr(gopherState->request, '?') == NULL)
 	&& (BIT_TEST(entry->flag, ENTRY_HTML))) {
 	/* Index URL without query word */
 	/* We have to generate search page back to client. No need for connection */
-	gopherMimeCreate(data);
-	if (data->type_id == GOPHER_INDEX) {
-	    data->conversion = HTML_INDEX_PAGE;
+	gopherMimeCreate(gopherState);
+	if (gopherState->type_id == GOPHER_INDEX) {
+	    gopherState->conversion = HTML_INDEX_PAGE;
 	} else {
-	    if (data->type_id == GOPHER_CSO) {
-		data->conversion = HTML_CSO_PAGE;
+	    if (gopherState->type_id == GOPHER_CSO) {
+		gopherState->conversion = HTML_CSO_PAGE;
 	    } else {
-		data->conversion = HTML_INDEX_PAGE;
+		gopherState->conversion = HTML_INDEX_PAGE;
 	    }
 	}
-	gopherToHTML(data, (char *) NULL, 0);
+	gopherToHTML(gopherState, (char *) NULL, 0);
 	storeComplete(entry);
 	comm_close(sock);
 	return;
     }
     commConnectStart(sock,
-	data->host,
-	data->port,
+	gopherState->host,
+	gopherState->port,
 	gopherConnectDone,
-	data);
+	gopherState);
 }
 
 static void
@@ -1,5 +1,5 @@
 /*
- * $Id: ident.cc,v 1.26 1997/04/28 05:32:46 wessels Exp $
+ * $Id: ident.cc,v 1.27 1997/04/29 22:12:59 wessels Exp $
  *
  * DEBUG: section 30    Ident (RFC 931)
  * AUTHOR: Duane Wessels
@@ -33,14 +33,15 @@
 #define IDENT_PORT 113
 
 static void identRequestComplete _PARAMS((int, char *, int, int, void *));
-static void identReadReply _PARAMS((int, icpStateData *));
-static void identClose _PARAMS((int, icpStateData *));
-static void identConnectDone _PARAMS((int fd, int status, void *data));
+static PF identReadReply;
+static PF identClose;
+static CCH identConnectDone;
 static void identCallback _PARAMS((icpStateData * icpState));
 
 static void
-identClose(int fd, icpStateData * icpState)
+identClose(int fd, void *data)
 {
+    icpStateData *icpState = data;
     icpState->ident.fd = -1;
 }
 
@@ -106,8 +107,9 @@ identRequestComplete(int fd, char *buf, int size, int errflag, void *data)
 }
 
 static void
-identReadReply(int fd, icpStateData * icpState)
+identReadReply(int fd, void *data)
 {
+    icpStateData *icpState = data;
     LOCAL_ARRAY(char, buf, BUFSIZ);
     char *t = NULL;
     int len = -1;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ipcache.cc,v 1.110 1997/04/28 05:32:47 wessels Exp $
+ * $Id: ipcache.cc,v 1.111 1997/04/29 22:13:00 wessels Exp $
  *
  * DEBUG: section 14    IP Cache
  * AUTHOR: Harvest Derived
@@ -108,7 +108,7 @@
 
 struct _ip_pending {
     int fd;
-    IPH handler;
+    IPH *handler;
     void *handlerData;
     struct _ip_pending *next;
 };
@@ -134,7 +134,7 @@ static struct {
 static int ipcache_testname _PARAMS((void));
 static int ipcache_compareLastRef _PARAMS((ipcache_entry **, ipcache_entry **));
 static int ipcache_reverseLastRef _PARAMS((ipcache_entry **, ipcache_entry **));
-static void ipcache_dnsHandleRead _PARAMS((int, dnsserver_t *));
+static PF ipcache_dnsHandleRead;
 static ipcache_entry *ipcache_parsebuffer _PARAMS((const char *buf, dnsserver_t *));
 static void ipcache_release _PARAMS((ipcache_entry *));
 static ipcache_entry *ipcache_GetFirst _PARAMS((void));
@@ -148,7 +148,7 @@ static int ipcacheHasPending _PARAMS((ipcache_entry *));
 static ipcache_entry *ipcache_get _PARAMS((const char *));
 static void dummy_handler _PARAMS((int, const ipcache_addrs *, void *));
 static int ipcacheExpiredEntry _PARAMS((ipcache_entry *));
-static void ipcacheAddPending _PARAMS((ipcache_entry *, int fd, IPH, void *));
+static void ipcacheAddPending _PARAMS((ipcache_entry *, int fd, IPH *, void *));
 static void ipcacheEnqueue _PARAMS((ipcache_entry *));
 static void *ipcacheDequeue _PARAMS((void));
 static void ipcache_dnsDispatch _PARAMS((dnsserver_t *, ipcache_entry *));
@@ -321,7 +321,7 @@ ipcacheExpiredEntry(ipcache_entry * i)
 }
 
 /* finds the LRU and deletes */
-int
+void
 ipcache_purgelru(void *unused)
 {
     ipcache_entry *i = NULL;
@@ -331,7 +331,7 @@ ipcache_purgelru(void *unused)
     ipcache_entry **LRU_list = NULL;
     int LRU_list_count = 0;
 
-    eventAdd("ipcache_purgelru", (EVH) ipcache_purgelru, NULL, 10);
+    eventAdd("ipcache_purgelru", ipcache_purgelru, NULL, 10);
     LRU_list = xcalloc(meta_data.ipcache_count, sizeof(ipcache_entry *));
 
     for (i = ipcache_GetFirst(); i; i = ipcache_GetNext()) {
@@ -352,17 +352,11 @@ ipcache_purgelru(void *unused)
 	LRU_list[LRU_list_count++] = i;
     }
 
-    debug(14, 3, "ipcache_purgelru: ipcache_count: %5d\n", meta_data.ipcache_count);
-    debug(14, 3, "                LRU candidates : %5d\n", LRU_list_count);
-    debug(14, 3, "                   high W mark : %5d\n", ipcache_high);
-    debug(14, 3, "                   low  W mark : %5d\n", ipcache_low);
-    debug(14, 3, "                   not pending : %5d\n", local_ip_notpending_count);
-
     /* sort LRU candidate list */
     qsort((char *) LRU_list,
 	LRU_list_count,
 	sizeof(ipcache_entry *),
-	(QS) ipcache_compareLastRef);
+	(QS *) ipcache_compareLastRef);
     for (k = 0; k < LRU_list_count; k++) {
 	if (meta_data.ipcache_count < ipcache_low)
 	    break;
@@ -371,10 +365,10 @@ ipcache_purgelru(void *unused)
 	ipcache_release(LRU_list[k]);
 	removed++;
     }
-
-    debug(14, 3, "                       removed : %5d\n", removed);
+    if (meta_data.ipcache_count > ipcache_low)
+	debug_trap("ipcache_purgelru: Couldn't reach the low water mark");
+    debug(14, 3, "ipcache_purgelru: removed %d entries\n", removed);
     safe_free(LRU_list);
-    return (removed > 0) ? 0 : -1;
 }
 
 
@@ -383,10 +377,8 @@ static ipcache_entry *
 ipcache_create(const char *name)
 {
     static ipcache_entry *new;
-    if (meta_data.ipcache_count > ipcache_high) {
-	if (ipcache_purgelru(NULL) < 0)
-	    debug(14, 0, "HELP!! IP Cache is overflowing!\n");
-    }
+    if (meta_data.ipcache_count > ipcache_high)
+	ipcache_purgelru(NULL);
     meta_data.ipcache_count++;
     new = xcalloc(1, sizeof(ipcache_entry));
     new->name = xstrdup(name);
@@ -550,8 +542,9 @@ ipcacheNudgeQueue(void)
 }
 
 static void
-ipcache_dnsHandleRead(int fd, dnsserver_t * dnsData)
+ipcache_dnsHandleRead(int fd, void *data)
 {
+    dnsserver_t *dnsData = data;
     int len;
     int svc_time;
     int n;
@@ -622,7 +615,7 @@ ipcache_dnsHandleRead(int fd, dnsserver_t * dnsData)
 }
 
 static void
-ipcacheAddPending(ipcache_entry * i, int fd, IPH handler, void *handlerData)
+ipcacheAddPending(ipcache_entry * i, int fd, IPH * handler, void *handlerData)
 {
     struct _ip_pending *pending = xcalloc(1, sizeof(struct _ip_pending));
     struct _ip_pending **I = NULL;
@@ -637,7 +630,7 @@ ipcacheAddPending(ipcache_entry * i, int fd, IPH handler, void *handlerData)
 }
 
 void
-ipcache_nbgethostbyname(const char *name, int fd, IPH handler, void *handlerData)
+ipcache_nbgethostbyname(const char *name, int fd, IPH * handler, void *handlerData)
 {
     ipcache_entry *i = NULL;
     dnsserver_t *dnsData = NULL;
@@ -941,7 +934,7 @@ stat_ipcache_get(StoreEntry * sentry)
     qsort((char *) list,
 	N,
 	sizeof(ipcache_entry *),
-	(QS) ipcache_reverseLastRef);
+	(QS *) ipcache_reverseLastRef);
     for (k = 0; k < N; k++)
 	ipcacheStatPrint(*(list + k), sentry);
     storeAppendPrintf(sentry, close_bracket);
@@ -1,5 +1,5 @@
 /*
- * $Id: main.cc,v 1.141 1997/04/28 04:23:16 wessels Exp $
+ * $Id: main.cc,v 1.142 1997/04/29 22:13:02 wessels Exp $
  *
  * DEBUG: section 1     Startup and Main Loop
  * AUTHOR: Harvest Derived
@@ -607,7 +607,7 @@ mainInitialize(void)
 	eventAdd("storeDirClean", storeDirClean, NULL, 15);
 	if (Config.Announce.on)
 	    eventAdd("start_announce", start_announce, NULL, 3600);
-	eventAdd("ipcache_purgelru", (EVH) ipcache_purgelru, NULL, 10);
+	eventAdd("ipcache_purgelru", ipcache_purgelru, NULL, 10);
     }
     first_time = 0;
 }
@@ -1,5 +1,5 @@
 /*
- * $Id: neighbors.cc,v 1.131 1997/04/28 04:23:17 wessels Exp $
+ * $Id: neighbors.cc,v 1.132 1997/04/29 22:13:02 wessels Exp $
  *
  * DEBUG: section 15    Neighbor Routines
  * AUTHOR: Harvest Derived
@@ -438,7 +438,7 @@ neighbors_open(int fd)
 int
 neighborsUdpPing(request_t * request,
     StoreEntry * entry,
-    IRCB callback,
+    IRCB * callback,
     void *callback_data,
     int *exprep)
 {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: net_db.cc,v 1.32 1997/04/28 04:23:19 wessels Exp $
+ * $Id: net_db.cc,v 1.33 1997/04/29 22:13:04 wessels Exp $
  *
  * DEBUG: section 37    Network Measurement Database
  * AUTHOR: Duane Wessels
@@ -175,7 +175,7 @@ netdbPurgeLRU(void)
     qsort((char *) list,
 	list_count,
 	sizeof(netdbEntry *),
-	(QS) netdbLRU);
+	(QS *) netdbLRU);
     for (k = 0; k < list_count; k++) {
 	if (meta_data.netdb_addrs < Config.Netdb.low)
 	    break;
@@ -573,7 +573,7 @@ netdbDump(StoreEntry * sentry)
     qsort((char *) list,
 	i,
 	sizeof(netdbEntry *),
-	(QS) sortByRtt);
+	(QS *) sortByRtt);
     for (k = 0; k < i; k++) {
 	n = *(list + k);
 	storeAppendPrintf(sentry, "{%-16.16s %4d/%4d %7.1f %5.1f",	/* } */
@@ -648,6 +648,6 @@ netdbUpdatePeer(request_t * r, peer * e, int irtt, int ihops)
     qsort((char *) n->peers,
 	n->n_peers,
 	sizeof(net_db_peer),
-	(QS) sortPeerByRtt);
+	(QS *) sortPeerByRtt);
 #endif
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: peer_select.cc,v 1.9 1997/04/28 04:23:21 wessels Exp $
+ * $Id: peer_select.cc,v 1.10 1997/04/29 22:13:04 wessels Exp $
  *
  * DEBUG: section 44    Peer Selection Algorithm
  * AUTHOR: Duane Wessels
@@ -121,8 +121,8 @@ peerGetSomeParent(request_t * request, hier_code * code)
 void
 peerSelect(request_t * request,
     StoreEntry * entry,
-    PSC callback,
-    PSC fail_callback,
+    PSC * callback,
+    PSC * fail_callback,
     void *callback_data)
 {
     ps_state *psstate = xcalloc(1, sizeof(ps_state));
@@ -1,5 +1,5 @@
 /*
- * $Id: redirect.cc,v 1.36 1997/04/28 05:32:48 wessels Exp $
+ * $Id: redirect.cc,v 1.37 1997/04/29 22:13:06 wessels Exp $
  *
  * DEBUG: section 29    Redirector
  * AUTHOR: Duane Wessels
@@ -41,7 +41,7 @@ typedef struct {
     struct in_addr client_addr;
     const char *client_ident;
     const char *method_s;
-    RH handler;
+    RH *handler;
 } redirectStateData;
 
 typedef struct _redirector {
@@ -73,7 +73,7 @@ struct redirectQueueData {
 
 static redirector_t *GetFirstAvailable _PARAMS((void));
 static int redirectCreateRedirector _PARAMS((const char *command));
-static int redirectHandleRead _PARAMS((int, redirector_t *));
+static PF redirectHandleRead;
 static redirectStateData *Dequeue _PARAMS((void));
 static void Enqueue _PARAMS((redirectStateData *));
 static void redirectDispatch _PARAMS((redirector_t *, redirectStateData *));
@@ -160,9 +160,10 @@ redirectCreateRedirector(const char *command)
     return 0;
 }
 
-static int
-redirectHandleRead(int fd, redirector_t * redirector)
+static void
+redirectHandleRead(int fd, void *data)
 {
+    redirector_t *redirector = data;
     int len;
     redirectStateData *r = redirector->redirectState;
     char *t = NULL;
@@ -186,7 +187,7 @@ redirectHandleRead(int fd, redirector_t * redirector)
 	comm_close(fd);
 	if (--NRedirectorsOpen == 0 && !shutdown_pending && !reread_pending)
 	    fatal_dump("All redirectors have exited!");
-	return 0;
+	return;
     }
     if (len != 1)
 	RedirectStats.rewrites[redirector->index]++;
@@ -232,7 +233,6 @@ redirectHandleRead(int fd, redirector_t * redirector)
     }
     while ((redirector = GetFirstAvailable()) && (r = Dequeue()))
 	redirectDispatch(redirector, r);
-    return 0;
 }
 
 static void
@@ -322,7 +322,7 @@ redirectDispatch(redirector_t * redirect, redirectStateData * r)
 
 
 void
-redirectStart(int cfd, icpStateData * icpState, RH handler, void *data)
+redirectStart(int cfd, icpStateData * icpState, RH * handler, void *data)
 {
     redirectStateData *r = NULL;
     redirector_t *redirector = NULL;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: squid.h,v 1.104 1997/04/28 04:23:27 wessels Exp $
+ * $Id: squid.h,v 1.105 1997/04/29 22:13:07 wessels Exp $
  *
  * AUTHOR: Duane Wessels
  *
@@ -265,8 +265,8 @@ typedef unsigned long u_num32;
 #include <regex.h>
 #endif
 
-typedef void (*SIH) (void *, int);	/* swap in */
-typedef int (*QS) (const void *, const void *);
+typedef void SIH _PARAMS((void *, int));	/* swap in */
+typedef int QS _PARAMS((const void *, const void *));	/* qsort */
 
 #include "cache_cf.h"
 #include "comm.h"
@@ -280,6 +280,7 @@ typedef int (*QS) (const void *, const void *);
 #include "icp.h"
 #include "errorpage.h"		/* must go after icp.h */
 #include "dns.h"
+#include "event.h"
 #include "ipcache.h"
 #include "fqdncache.h"
 #include "mime.h"
@@ -293,7 +294,6 @@ typedef int (*QS) (const void *, const void *);
 #include "ftp.h"
 #include "gopher.h"
 #include "util.h"
-#include "event.h"
 #include "acl.h"
 #include "async_io.h"
 #include "redirect.h"
@@ -1,6 +1,6 @@
 
 /*
- * $Id: stat.cc,v 1.134 1997/04/28 05:32:50 wessels Exp $
+ * $Id: stat.cc,v 1.135 1997/04/29 22:13:08 wessels Exp $
  *
  * DEBUG: section 18    Cache Manager Statistics
  * AUTHOR: Harvest Derived
@@ -136,7 +136,7 @@ static const char *describeFlags _PARAMS((const StoreEntry *));
 static const char *describeTimestamps _PARAMS((const StoreEntry *));
 static void dummyhandler _PARAMS((cacheinfo *, StoreEntry *));
 static void info_get _PARAMS((const cacheinfo *, StoreEntry *));
-static void logReadEndHandler _PARAMS((int, int, log_read_data_t *));
+static FILE_WALK_HD logReadEndHandler;
 static void log_clear _PARAMS((cacheinfo *, StoreEntry *));
 static void log_disable _PARAMS((cacheinfo *, StoreEntry *));
 static void log_enable _PARAMS((cacheinfo *, StoreEntry *));
@@ -148,16 +148,16 @@ static void proto_newobject _PARAMS((cacheinfo *, protocol_t, int, int));
 static void proto_purgeobject _PARAMS((cacheinfo *, protocol_t, int));
 static void proto_touchobject _PARAMS((cacheinfo *, protocol_t, int));
 static void server_list _PARAMS((const cacheinfo *, StoreEntry *));
-static void squidReadEndHandler _PARAMS((int, int, squid_read_data_t *));
+static FILE_WALK_HD squidReadEndHandler;
 static void squid_get_start _PARAMS((const cacheinfo *, StoreEntry *));
 static void statFiledescriptors _PARAMS((StoreEntry *));
 static void stat_get _PARAMS((const cacheinfo *, const char *req, StoreEntry *));
 static void stat_io_get _PARAMS((StoreEntry *));
 static void stat_objects_get _PARAMS((const cacheinfo *, StoreEntry *, int vm_or_not));
 static void stat_utilization_get _PARAMS((cacheinfo *, StoreEntry *, const char *desc));
 static int cache_size_get _PARAMS((const cacheinfo *));
-static int logReadHandler _PARAMS((int, const char *, int, log_read_data_t *));
-static int squidReadHandler _PARAMS((int, const char *, int, squid_read_data_t *));
+static FILE_WALK_LHD logReadHandler;
+static FILE_WALK_LHD squidReadHandler;
 static int memoryAccounted _PARAMS((void));
 
 #ifdef UNUSED_CODE
@@ -460,26 +460,25 @@ log_status_get(const cacheinfo * obj, StoreEntry * sentry)
 
 /* log convert handler */
 /* call for each line in file, use fileWalk routine */
-static int
-logReadHandler(int fd_unused, const char *buf, int size_unused, log_read_data_t * data)
+static void
+logReadHandler(int fd_unused, const char *buf, int size_unused, void *data)
 {
-    storeAppendPrintf(data->sentry, "{%s}\n", buf);
-    return 0;
+    log_read_data_t *ctrl = data;
+    storeAppendPrintf(ctrl->sentry, "{%s}\n", buf);
 }
 
 /* log convert end handler */
 /* call when a walk is completed or error. */
 static void
-logReadEndHandler(int fd, int errflag_unused, log_read_data_t * data)
+logReadEndHandler(int fd, int errflag_unused, void *data)
 {
-    storeAppendPrintf(data->sentry, close_bracket);
-    storeComplete(data->sentry);
-    safe_free(data);
+    log_read_data_t *ctrl = data;
+    storeAppendPrintf(ctrl->sentry, close_bracket);
+    storeComplete(ctrl->sentry);
+    safe_free(ctrl);
     file_close(fd);
 }
 
-
-
 /* start converting logfile to processed format */
 static void
 log_get_start(const cacheinfo * obj, StoreEntry * sentry)
@@ -513,22 +512,23 @@ log_get_start(const cacheinfo * obj, StoreEntry * sentry)
 
 /* squid convert handler */
 /* call for each line in file, use fileWalk routine */
-static int
-squidReadHandler(int fd_unused, const char *buf, int size_unused, squid_read_data_t * data)
+static void
+squidReadHandler(int fd_unused, const char *buf, int size_unused, void *data)
 {
-    storeAppendPrintf(data->sentry, "{\"%s\"}\n", buf);
-    return 0;
+    squid_read_data_t *ctrl = data;
+    storeAppendPrintf(ctrl->sentry, "{\"%s\"}\n", buf);
 }
 
 /* squid convert end handler */
 /* call when a walk is completed or error. */
 static void
-squidReadEndHandler(int fd_unused, int errflag_unused, squid_read_data_t * data)
+squidReadEndHandler(int fd_unused, int errflag_unused, void *data)
 {
-    storeAppendPrintf(data->sentry, close_bracket);
-    storeComplete(data->sentry);
-    file_close(data->fd);
-    safe_free(data);
+    squid_read_data_t *ctrl = data;
+    storeAppendPrintf(ctrl->sentry, close_bracket);
+    storeComplete(ctrl->sentry);
+    file_close(ctrl->fd);
+    safe_free(ctrl);
 }
 
 
@@ -542,8 +542,7 @@ squid_get_start(const cacheinfo * obj, StoreEntry * sentry)
     data->sentry = sentry;
     data->fd = file_open(ConfigFile, NULL, O_RDONLY, NULL, NULL);
     storeAppendPrintf(sentry, open_bracket);
-    file_walk(data->fd, squidReadEndHandler, data,
-	squidReadHandler, data);
+    file_walk(data->fd, squidReadEndHandler, data, squidReadHandler, data);
 }
 
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store.cc,v 1.224 1997/04/28 05:32:51 wessels Exp $
+ * $Id: store.cc,v 1.225 1997/04/29 22:13:09 wessels Exp $
  *
  * DEBUG: section 20    Storeage Manager
  * AUTHOR: Harvest Derived
@@ -226,12 +226,12 @@ typedef struct valid_ctrl_t {
 typedef struct swapin_ctrl_t {
     StoreEntry *e;
     char *path;
-    SIH callback;
+    SIH *callback;
     void *callback_data;
 } swapin_ctrl_t;
 
 typedef struct lock_ctrl_t {
-    SIH callback;
+    SIH *callback;
     void *callback_data;
     StoreEntry *e;
 } lock_ctrl_t;
@@ -262,12 +262,8 @@ static int storeEntryValidLength _PARAMS((const StoreEntry *));
 static void storeGetMemSpace _PARAMS((int));
 static int storeHashDelete _PARAMS((StoreEntry *));
 static int storeShouldPurgeMem _PARAMS((const StoreEntry *));
-static int storeSwapInHandle _PARAMS((int,
-	const char *,
-	int,
-	int,
-	StoreEntry *));
-static int storeSwapInStart _PARAMS((StoreEntry *, SIH, void *));
+static FILE_READ_HD storeSwapInHandle;
+static int storeSwapInStart _PARAMS((StoreEntry *, SIH *, void *));
 static void storeSwapInValidateComplete _PARAMS((void *, int));
 static void storeSwapInStartComplete _PARAMS((void *, int));
 static int swapInError _PARAMS((int, StoreEntry *));
@@ -292,7 +288,7 @@ static void storeSetMemStatus _PARAMS((StoreEntry *, mem_status_t));
 static void storeStartRebuildFromDisk _PARAMS((void));
 static void storeSwapOutStart _PARAMS((StoreEntry * e));
 static void storeSwapOutStartComplete _PARAMS((void *, int));
-static void storeSwapOutHandle _PARAMS((int, int, StoreEntry *));
+static FILE_WRITE_HD storeSwapOutHandle;
 static void storeHashMemInsert _PARAMS((StoreEntry *));
 static void storeHashMemDelete _PARAMS((StoreEntry *));
 static void storeSetPrivateKey _PARAMS((StoreEntry *));
@@ -553,7 +549,7 @@ storePurgeMem(StoreEntry * e)
  * {http,ftp,gopher,wais}Start()
  */
 void
-storeLockObject(StoreEntry * e, SIH callback, void *callback_data)
+storeLockObject(StoreEntry * e, SIH * callback, void *callback_data)
 {
     lock_ctrl_t *ctrlp;
     e->lock_count++;
@@ -897,7 +893,7 @@ storeAddDiskRestore(const char *url, int file_number, int size, time_t expires,
 
 /* Register interest in an object currently being retrieved. */
 int
-storeRegister(StoreEntry * e, int fd, PIF handler, void *data)
+storeRegister(StoreEntry * e, int fd, PIF * handler, void *data)
 {
     int i;
     MemObject *mem = e->mem_obj;
@@ -967,7 +963,7 @@ InvokeHandlers(StoreEntry * e)
 {
     int i;
     MemObject *mem = e->mem_obj;
-    PIF handler = NULL;
+    PIF *handler = NULL;
     void *data = NULL;
     struct _store_client *sc;
     if (mem->clients == NULL && mem->nclients) {
@@ -1071,9 +1067,10 @@ storeAppendPrintf(va_alist)
 }
 
 /* swapping in handle */
-static int
-storeSwapInHandle(int fd_notused, const char *buf, int len, int flag, StoreEntry * e)
+static void
+storeSwapInHandle(int u1, const char *buf, int len, int flag, void *data)
 {
+    StoreEntry *e = data;
     MemObject *mem = e->mem_obj;
     debug(20, 2, "storeSwapInHandle: '%s'\n", e->key);
     if ((flag < 0) && (flag != DISK_EOF)) {
@@ -1082,7 +1079,7 @@ storeSwapInHandle(int fd_notused, const char *buf, int len, int flag, StoreEntry
 	storeSetMemStatus(e, NOT_IN_MEMORY);
 	file_close(mem->swapin_fd);
 	swapInError(-1, e);	/* Invokes storeAbort() and completes the I/O */
-	return -1;
+	return;
     }
     debug(20, 5, "storeSwapInHandle: e->swap_offset   = %d\n", mem->swap_offset);
     debug(20, 5, "storeSwapInHandle: e->e_current_len = %d\n", mem->e_current_len);
@@ -1101,7 +1098,7 @@ storeSwapInHandle(int fd_notused, const char *buf, int len, int flag, StoreEntry
 	    mem->swap_offset,
 	    storeSwapInHandle,
 	    e);
-	return 0;
+	return;
     }
     /* complete swapping in */
     storeSetMemStatus(e, IN_MEMORY);
@@ -1127,12 +1124,11 @@ storeSwapInHandle(int fd_notused, const char *buf, int len, int flag, StoreEntry
 	requestUnlink(mem->request);
 	mem->request = NULL;
     }
-    return 0;
 }
 
 /* start swapping in */
 static int
-storeSwapInStart(StoreEntry * e, SIH callback, void *callback_data)
+storeSwapInStart(StoreEntry * e, SIH * callback, void *callback_data)
 {
     swapin_ctrl_t *ctrlp;
     /* sanity check! */
@@ -1219,8 +1215,9 @@ storeSwapInStartComplete(void *data, int fd)
 }
 
 static void
-storeSwapOutHandle(int fd, int flag, StoreEntry * e)
+storeSwapOutHandle(int fd, int flag, void *data)
 {
+    StoreEntry *e = data;
     MemObject *mem = e->mem_obj;
     debug(20, 3, "storeSwapOutHandle: '%s'\n", e->key);
     if (mem == NULL) {
@@ -1930,7 +1927,7 @@ storeGetMemSpace(int size)
     qsort((char *) list,
 	list_count,
 	sizeof(StoreEntry *),
-	(QS) compareSize);
+	(QS *) compareSize);
 
     /* Kick LRU out until we have enough memory space */
     for (i = 0; i < list_count; i++) {
@@ -2076,7 +2073,7 @@ storeGetSwapSpace(int size)
 	qsort((char *) LRU_list,
 	    list_count,
 	    sizeof(StoreEntry *),
-	    (QS) compareLastRef);
+	    (QS *) compareLastRef);
 	if (list_count > SWAP_LRU_REMOVE_COUNT)
 	    list_count = SWAP_LRU_REMOVE_COUNT;		/* chop list */
 	if (scan_count > SWAP_LRUSCAN_COUNT)
@@ -2419,7 +2416,7 @@ storeRandomizeBuckets(void)
     qsort((char *) MaintBucketsOrder,
 	store_buckets,
 	sizeof(struct _bucketOrder),
-	             (QS) compareBucketOrder);
+	             (QS *) compareBucketOrder);
 }
 
 static void
@@ -1,6 +1,6 @@
 
 /*
- * $Id: wais.cc,v 1.64 1997/04/28 05:32:52 wessels Exp $
+ * $Id: wais.cc,v 1.65 1997/04/29 22:13:12 wessels Exp $
  *
  * DEBUG: section 24    WAIS Relay
  * AUTHOR: Harvest Derived
@@ -119,35 +119,34 @@ typedef struct {
     int ip_lookup_pending;
 } WaisStateData;
 
-static int waisStateFree _PARAMS((int, WaisStateData *));
+static PF waisStateFree;
 static void waisStartComplete _PARAMS((void *, int));
-static void waisReadReplyTimeout _PARAMS((int, WaisStateData *));
-static void waisLifetimeExpire _PARAMS((int, WaisStateData *));
-static void waisReadReply _PARAMS((int, WaisStateData *));
+static PF waisReadReplyTimeout;
+static PF waisLifetimeExpire;
+static PF waisReadReply;
 static void waisSendComplete _PARAMS((int, char *, int, int, void *));
-static void waisSendRequest _PARAMS((int, WaisStateData *));
+static PF waisSendRequest;
 static void waisConnect _PARAMS((int, const ipcache_addrs *, void *));
-static void waisConnectDone _PARAMS((int fd, int status, void *data));
+static CCH waisConnectDone;
 
-static int
-waisStateFree(int fd, WaisStateData * waisState)
+static void
+waisStateFree(int fd, void *data)
 {
+    WaisStateData *waisState = data;
     if (waisState == NULL)
-	return 1;
+	return;
     storeUnlockObject(waisState->entry);
     if (waisState->ip_lookup_pending)
 	ipcache_unregister(waisState->relayhost, waisState->fd);
     xfree(waisState);
-    return 0;
 }
 
 /* This will be called when timeout on read. */
 static void
-waisReadReplyTimeout(int fd, WaisStateData * waisState)
+waisReadReplyTimeout(int fd, void *data)
 {
-    StoreEntry *entry = NULL;
-
-    entry = waisState->entry;
+    WaisStateData *waisState = data;
+    StoreEntry *entry = waisState->entry;
     debug(24, 4, "waisReadReplyTimeout: Timeout on %d\n url: %s\n", fd, entry->url);
     squid_error_entry(entry, ERR_READ_TIMEOUT, NULL);
     commSetSelect(fd, COMM_SELECT_READ, NULL, NULL, 0);
@@ -156,11 +155,10 @@ waisReadReplyTimeout(int fd, WaisStateData * waisState)
 
 /* This will be called when socket lifetime is expired. */
 static void
-waisLifetimeExpire(int fd, WaisStateData * waisState)
+waisLifetimeExpire(int fd, void *data)
 {
-    StoreEntry *entry = NULL;
-
-    entry = waisState->entry;
+    WaisStateData *waisState = data;
+    StoreEntry *entry = waisState->entry;
     debug(24, 4, "waisLifeTimeExpire: FD %d: '%s'\n", fd, entry->url);
     squid_error_entry(entry, ERR_LIFETIME_EXP, NULL);
     commSetSelect(fd, COMM_SELECT_READ | COMM_SELECT_WRITE, NULL, NULL, 0);
@@ -172,16 +170,16 @@ waisLifetimeExpire(int fd, WaisStateData * waisState)
 /* This will be called when data is ready to be read from fd.  Read until
  * error or connection closed. */
 static void
-waisReadReply(int fd, WaisStateData * waisState)
+waisReadReply(int fd, void *data)
 {
+    WaisStateData *waisState = data;
     LOCAL_ARRAY(char, buf, 4096);
     int len;
-    StoreEntry *entry = NULL;
+    StoreEntry *entry = waisState->entry;
     int clen;
     int off;
     int bin;
 
-    entry = waisState->entry;
     if (entry->flag & DELETE_BEHIND && !storeClientWaiting(entry)) {
 	/* we can terminate connection right now */
 	squid_error_entry(entry, ERR_NO_CLIENTS_BIG_OBJ, NULL);
@@ -275,9 +273,8 @@ waisReadReply(int fd, WaisStateData * waisState)
 static void
 waisSendComplete(int fd, char *buf, int size, int errflag, void *data)
 {
-    StoreEntry *entry = NULL;
     WaisStateData *waisState = data;
-    entry = waisState->entry;
+    StoreEntry *entry = waisState->entry;
     debug(24, 5, "waisSendComplete: FD %d size: %d errflag: %d\n",
 	fd, size, errflag);
     if (errflag) {
@@ -299,8 +296,9 @@ waisSendComplete(int fd, char *buf, int size, int errflag, void *data)
 
 /* This will be called when connect completes. Write request. */
 static void
-waisSendRequest(int fd, WaisStateData * waisState)
+waisSendRequest(int fd, void *data)
 {
+    WaisStateData *waisState = data;
     int len = strlen(waisState->request) + 4;
     char *buf = NULL;
     const char *Method = RequestMethodStr[waisState->method];
@@ -371,7 +369,7 @@ waisStart(method_t method, char *mime_hdr, StoreEntry * entry)
 static void
 waisStartComplete(void *data, int status)
 {
-    WaisStateData *waisState = (WaisStateData *) data;
+    WaisStateData *waisState = data;
 
     comm_add_close_handler(waisState->fd,
 	waisStateFree,