@@ -1,3 +1,15 @@
+Changes to squid-3.2.0.17 (12 Apr 2011):
+
+	- Bug 3527: EUI compile errors on Mac OS X 10.5.8 PPC
+	- Bug 3509: kQueue compile error
+	- Bug 3505: crash in CbcPointer<Comm::ConnOpener> constructor
+	- Bug 3441: Part 3: Replace corrupted v1 swap.state with new v2 format.
+	- Bug 3397: do not mark connection as opened until after SYN-ACK
+	- Bug 3193: NTLM decoder truncating strings
+	- Windows FD handling polish and some fixes
+	- Solaris 9/10 various build fixes
+	- ... and some more code polish
+
 Changes to squid-3.2.0.16 (07 Mar 2011):
 
 	- Bug 3508: Correct DNS timeout handling.
@@ -47,6 +47,33 @@ AC_DEFUN([SQUID_CC_CHECK_ARGUMENT],[
   }])
 ])
 
+# Check if the compiler requires a supplied flag to build a test program.
+# When cross-compiling set flags explicitly.
+#
+# first argument is the variable containing the result 
+# (will be set to "yes" or "no")
+# second argument is the flag to be tested, verbatim
+# third is the #include and global setup for test program, verbatim
+# fourth is the test program to compile, verbatim
+#
+AC_DEFUN([SQUID_CC_REQUIRE_ARGUMENT],[
+  AC_CACHE_CHECK([whether compiler requires $2],[$1],
+  [{
+    AC_REQUIRE([AC_PROG_CC])
+    SAVED_FLAGS="$CFLAGS"
+    SAVED_CXXFLAGS="$CXXFLAGS"
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM($3,$4)],[$1=no],[],[$1=no])
+    if test "$1" != "no" ; then
+      CFLAGS="$CXXFLAGS $2"
+      CXXFLAGS="$CXXFLAGS $2"
+      AC_COMPILE_IFELSE([AC_LANG_PROGRAM($3,$4)],[$1=yes],[$1=no],[$1=no])
+    fi
+    CFLAGS="$SAVED_CFLAGS"
+    CXXFLAGS="$SAVED_CXXFLAGS"
+  }])
+  AC_MSG_RESULT([$1])
+])
+
 # detect what kind of compiler we're using, either by using hints from
 # autoconf itself, or by using predefined preprocessor macros
 # sets the variable squid_cv_compiler to one of
@@ -257,9 +257,4 @@ const char * squid_strnstr(const char *s, const char *find, size_t slen);
 #define PRINTF_FORMAT_ARG3
 #endif
 
-/* NULL is not always provided. */
-#ifndef NULL
-#define NULL ((void *)0)
-#endif
-
 #endif /* _SQUID_COMPAT_SHARED_H */
@@ -3005,19 +3005,36 @@ dnl Please change your configure script.  AIX doesn't need -lbsd.
   *-ibm-aix*)
     AC_MSG_NOTICE([Removing -lbsd for AIX...])
     LIBS=`echo $LIBS | sed -e s/-lbsd//`
-    AC_MSG_CHECKING(for aix xlc c++ comments support)
-    AC_LANG_PUSH([C])
-    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]], [[//c++ cmt]])],
-      [AIX_CPPCMT_SUPPORT=yes],[AIX_CPPCMT_SUPPORT=no])	
-    AC_MSG_RESULT($AIX_CPPCMT_SUPPORT)
-    if test -n `echo $CC | grep cc` 2>/dev/null && \
-      test -n `cc -qversion 2>/dev/null | grep "IBM XL C/C++ for AIX"` 2>/dev/null; then
-        if test "$AIX_CPPCMT_SUPPORT"="no";then
-          SQUID_CFLAGS="-qcpluscmt $SQUID_CFLAGS"
-        fi
+
+    SQUID_CC_REQUIRE_ARGUMENT([ac_cv_require_rtti],[-rtti],[[
+#include <assert.h>
+#ifndef NULL
+#define NULL 0
+#endif
+class Foo{
+public:virtual ~Foo(){}
+};
+class Bar:public Foo{
+public:Bar():Foo(){}
+};
+      ]],[[
+Foo * myFoo=new Bar();
+Bar * myBar=dynamic_cast<Bar *>(myFoo);
+assert(myBar != NULL);
+      ]])
+    if test "$ac_cv_require_rtti" = "yes"; then
+      SQUID_CFLAGS="-rtti $SQUID_CFLAGS"
+      SQUID_CXXFLAGS="-rtti $SQUID_CXXFLAGS"
     fi
+
+    AC_LANG_PUSH([C])
+    SQUID_CC_REQUIRE_ARGUMENT([ac_cv_require_qcpluscmt],[-qcpluscmt],[[]],[[//c++ cmt]])
     AC_LANG_POP([C])
+    if test "$ac_cv_require_qcpluscmt" = "yes"; then
+      SQUID_CFLAGS="-qcpluscmt $SQUID_CFLAGS"
+    fi
     ;;
+
     *m88k*)
       SQUID_CFLAGS="$SQUID_CFLAGS -D_SQUID_MOTOROLA_"
       SQUID_CXXFLAGS="$SQUID_CXXFLAGS -D_SQUID_MOTOROLA_"
@@ -7,7 +7,7 @@ msgstr ""
 "Project-Id-Version: PACKAGE VERSION\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2010-02-13 00:05+1400\n"
-"PO-Revision-Date: 2012-02-02 16:58+0200\n"
+"PO-Revision-Date: 2012-04-06 19:32+0200\n"
 "Last-Translator: Bernard <fli4l.charrier@free.fr>\n"
 "Language-Team: LANGUAGE <LL@li.org>\n"
 "Language: fr\n"
@@ -321,7 +321,7 @@ msgstr "OPTIONS"
 #: helpers/basic_auth/LDAP/basic_ldap_auth.8:67
 msgid "B<REQUIRED.> Specifies the base DN under which the users are located."
 msgstr ""
-"B<REQUIRED.> permet de spécifie la base DN dans laquelle se trouve les "
+"B<REQUIRED> permet de spécifie la base DN dans laquelle se trouve les "
 "utilisateurs."
 
 #. type: Plain text
@@ -489,9 +489,9 @@ msgid ""
 "used for searching for the user DN is kept persistent but a new connection "
 "is opened to verify each users password once the DN is found."
 msgstr ""
-"Effectuer seulement une connexion LDAP à la fois. Certains serveurs LDAP ne "
+"Effectue seulement une connexion LDAP à la fois. Certains serveurs LDAP ne "
 "permettent pas de rajouter un autre utilisateur après une connexion réussi. "
-"I<ldap_bind> L'utilisation de cette option ouvre toujours une nouvelle "
+"Avec I<ldap_bind> l'utilisation de cette option ouvre toujours une nouvelle "
 "connexion après chaque identifiant connecté. Si cette option est combiné "
 "avec l'option B<-P> pour une connexion LDAP persistante, la connexion "
 "utilisée pour la recherche d'utilisateur DN sera maintenu persistant mais "
@@ -514,9 +514,9 @@ msgid ""
 "B<never> dereference aliases (default), B<always> dereference aliases, only "
 "while B<search ing> or only to B<find> the base object."
 msgstr ""
-"B<never> Ne jamais résoudre les alias, par (défaut), B<always> résous en "
-"plus les alias, B<search> uniquement pendant une recherche ou B<find> "
-"uniquement pour une recherche dans une base d'objets."
+"B<never> ne jamais résoudre les alias par (défaut), B<always> résous en plus "
+"les alias, B<search> uniquement pendant une recherche ou B<find> uniquement "
+"pour une recherche dans une base d'objets."
 
 #. type: Plain text
 #: helpers/basic_auth/LDAP/basic_ldap_auth.8:201
@@ -525,8 +525,8 @@ msgid ""
 "libraries).  Servers can also be specified last on the command line."
 msgstr ""
 "Spécifier un serveur LDAP, avec une connexion LDAP par URI (nécessite une "
-"bibliothèque OpenLDAP). Les serveurs peuvent également être spécifiée sur la "
-"dernière ligne de commande."
+"bibliothèque OpenLDAP). Les serveurs peuvent également être spécifiée en "
+"dernier par ligne de commande."
 
 #. type: Plain text
 #: helpers/basic_auth/LDAP/basic_ldap_auth.8:206
@@ -607,10 +607,10 @@ msgid ""
 "locate your user DNs as these can no longer be constructed direcly from the "
 "base DN and login name alone:"
 msgstr ""
-"Si vous avez des sous-domaines, vous devez utiliser une Méthode de filtre de "
+"Si vous avez des sous-domaines, vous devez utiliser une méthode de filtre de "
 "recherche pour localiser vos utilisateurs DNs, car ils ne pourront plus "
-"être construits directement seulement à partir de l'identifiant dans la base "
-"DN :"
+"être directement construits dans la base DN seulement à partir du nom "
+"d'utilisateur:"
 
 #. type: Plain text
 #: helpers/basic_auth/LDAP/basic_ldap_auth.8:257
@@ -653,10 +653,10 @@ msgid ""
 "the filter using B<ldapsearch> before you attempt to use B<basic_ldap_auth.> "
 "This to verify that the filter matches what you expect."
 msgstr ""
-"B<NOTE:> Lors de la construction du filtre de recherche, il est fortement "
+"B<NOTE:> lors de la construction du filtre de recherche, il est fortement "
 "recommandé de tester le filtre en utilisant B<ldapsearch>, avant d'essayer "
-"d'utiliser B<basic_ldap_auth.> Ceci pour vérifier que le filtre correspond "
-"à ce que vous attendiez."
+"d'utiliser B<basic_ldap_auth>. Ceci pour vérifier que le filtre correspond "
+"bien à ce que vous attendez."
 
 #. type: Plain text
 #: helpers/basic_auth/LDAP/basic_ldap_auth.8:290 helpers/basic_auth/RADIUS/basic_radius_auth.8:87
@@ -835,9 +835,9 @@ msgid ""
 "B<auth> and B<account> management groups to verify the password and the "
 "accounts validity."
 msgstr ""
-"Le nom du service par défaut est B<squid>, le programme utilise les groupes "
-"de gestion B<auth> et B<account> qui vérifie la validité du mot de passe et "
-"du comptes."
+"Le nom du service par défaut est B<squid>, le programme de gestion utilise "
+"B<auth> et B<account> pour vérifier la validité du mot de passe et du "
+"comptes."
 
 #. type: Plain text
 #: helpers/basic_auth/PAM/basic_pam_auth.8:58
@@ -923,8 +923,8 @@ msgid ""
 "the user name and password of Basic HTTP authentication."
 msgstr ""
 "B<basic_radius_auth> permet à Squid de se connecter à un serveur RADIUS pour "
-"valider le nom d'utilisateur et le mot de passe de l'authentification HTTP "
-"de base."
+"valider le nom d'utilisateur et le mot de passe avec l'authentification "
+"HTTP de base."
 
 #. type: Plain text
 #: helpers/basic_auth/RADIUS/basic_radius_auth.8:36
@@ -1028,7 +1028,7 @@ msgstr ""
 #: helpers/basic_auth/RADIUS/basic_radius_auth.8:121
 msgid "B<RFC2058> - Remote Authentication Dial In User Service (RADIUS)"
 msgstr ""
-"B<RFC2058> - connexion à distance au service d'authentification des "
+"B<RFC2058> - Connexion à distance au service d'authentification des "
 "utilisateurs (RADIUS)"
 
 #. type: Plain text
@@ -1059,7 +1059,7 @@ msgstr ""
 "l'autorisation les utilisateurs à travers des groupes LDAP. Les options LDAP "
 "sont spécifiées par des paramètres en ligne de commande, le nom(s) "
 "d'utilisateur(s) et le groupe(s), seront vérifiés depuis l'annuaire LDAP et "
-"précisés sur la ligne suivante après une Entrée, le couple nom "
+"précisés sur la ligne suivante après avoir appuyé sur entrée, le couple nom "
 "d'utilisateur/groupe seront sur une même ligne et séparées par un espace."
 
 #. type: Plain text
@@ -1072,9 +1072,9 @@ msgid ""
 msgstr ""
 "Comme prévu, on utilise B<external_acl_type> pour la construction de Squid, "
 "on spécifie pour chaque nouvelle ligne le nom d'utilisateur et le groupe "
-"suivis d'une entrée, sur la ligne suivante il sera alors indiqué soit B<OK> "
-"soit B<ERR>, pour aider l'utilisateur à vérifier si le membre appartient "
-"bien au groupe spécifié."
+"suivis de la touche entrée, sur la ligne suivante il sera alors indiqué soit "
+"B<OK> soit B<ERR>, pour aider l'utilisateur à vérifier si le membre "
+"appartient bien au groupe spécifié."
 
 #. type: Plain text
 #: helpers/external_acl/ldap_group/squid_ldap_group.8:48
@@ -1105,21 +1105,22 @@ msgstr ""
 #. type: Plain text
 #: helpers/external_acl/ldap_group/squid_ldap_group.8:67
 msgid "B<REQUIRED.> Specifies the base DN under which the groups are located."
-msgstr "B<REQUIRED.> spécifie la base DN sous laquel les groupes sont situés."
+msgstr "B<REQUIRED> spécifie la base DN sous laquelle les groupes sont situés."
 
 #. type: Plain text
 #: helpers/external_acl/ldap_group/squid_ldap_group.8:71
 msgid "Specifies the base DN under which the users are located (if different)"
 msgstr ""
-"Spécifie la base DN sous laquel les utilisateurs sont situés (si différent)"
+"Spécifie la base DN sous laquelle les utilisateurs sont situés (si "
+"différent)"
 
 #. type: Plain text
 #: helpers/external_acl/ldap_group/squid_ldap_group.8:76
 msgid ""
 "Specify timeout used when connecting to LDAP servers (requires Netscape LDAP "
 "API libraries)"
 msgstr ""
-"Spécifier le temps de pause, lors d'une connexion aux serveurs LDAP (requies "
+"Spécifier le temps de pause, lors d'une connexion aux serveurs LDAP (requis "
 "une bibliothèques API pour Netscape LDAP)"
 
 #. type: Plain text
@@ -1128,7 +1129,7 @@ msgid ""
 "The DN and password to bind as while performing searches. Required if the "
 "directory does not allow anonymous searches."
 msgstr ""
-"Le DN et le mot de passe doivent être liès pour des recherches, si "
+"Le DN et le mot de passe doivent être liés pour des recherches, si "
 "l'annuaire ne permet pas de faire des recherches anonymes."
 
 #. type: Plain text
@@ -1157,9 +1158,9 @@ msgid ""
 "name."
 msgstr ""
 "Utiliser le filtre de recherche LDAP pour rechercher tous les membres du "
-"groupe correspondant dans l'annuaire LDAP. Le Filtre B<%u> sera remplacé "
-"par le nom d'utilisateur (ou utiliser le option B<-F> ou B<-u> pour les DN "
-"(Non de Domaine)) et B<%g> sera remplacé par le nom du groupe demandé."
+"groupe correspondant dans l'annuaire LDAP. Le filtre B<%u> sera remplacé par "
+"le nom d'utilisateur (ou utiliser le option B<-F> ou B<-u> pour les DN (Non "
+"de Domaine)) et B<%g> sera remplacé par le nom du groupe demandé."
 
 #. type: Plain text
 #: helpers/external_acl/ldap_group/squid_ldap_group.8:135
@@ -1169,8 +1170,9 @@ msgid ""
 "be included literally in the filter then use B<%%>"
 msgstr ""
 "Utiliser le filtre de recherche LDAP pour rechercher tous les utilisateurs "
-"dans l'annuaire LDAP. Le filtre B<%s> sera remplacé par le nom d'utilisateur. "
-"Si le signe B<%> est inclu littéralement dans le filtre, utiliser alors B<%%>"
+"dans l'annuaire LDAP. Le filtre B<%s> sera remplacé par le nom "
+"d'utilisateur. Si le signe B<%> est inclus littéralement dans le filtre, "
+"utiliser alors B<%%>"
 
 #. type: Plain text
 #: helpers/external_acl/ldap_group/squid_ldap_group.8:141
@@ -1268,10 +1270,10 @@ msgid ""
 "the filter using B<ldapsearch> to verify that the filter matches what you "
 "expect before you attempt to use B<squid_ldap_group>"
 msgstr ""
-"B<NOTE:> Lors de la construction du filtre de recherche, il est recommandé "
-"de tester d'abord le filtre à l'aide du paramètre B<ldapsearch> pour vérifier "
-"que le filtre correspond bien à vos attentent et avant de tenter d'utiliser "
-"le paramètre B<squid_ldap_group>"
+"B<NOTE:> lors de la construction du filtre de recherche, il est recommandé "
+"de tester d'abord le filtre à l'aide du paramètre B<ldapsearch> pour "
+"vérifier que le filtre correspond bien à vos attentent et avant de tenter "
+"d'utiliser le paramètre B<squid_ldap_group>"
 
 #. type: Plain text
 #: helpers/external_acl/ldap_group/squid_ldap_group.8:240
@@ -1359,8 +1361,8 @@ msgid ""
 "Without this flag the helper automatically starts the session after the "
 "first request."
 msgstr ""
-"Sans ce repère l'aide démarre automatiquement la session après "
-"la première requête."
+"Sans ce repère, l'aide démarre automatiquement la session après la première "
+"requête."
 
 #. type: Plain text
 #: helpers/external_acl/session/squid_session.8:53
@@ -1494,8 +1496,9 @@ msgid ""
 msgstr ""
 "B<squid> est un serveur proxy de haute performance cachant les clients sur "
 "le web, il supporte les protocoles FTP, Gopher, ICAP, ICP, HTCP et HTTP pour "
-"les données. Contrairement aux logiciels de mise en cache traditionnelle, "
-"Squid gère toutes les requêtes en un seul processus non-bloquant."
+"le transfert des données. Contrairement aux logiciels de mise en cache "
+"traditionnelle, Squid gère toutes les requêtes en un seul processus non-"
+"bloquant."
 
 #. type: Plain text
 #: src/squid.8.in:36
@@ -1505,8 +1508,8 @@ msgid ""
 "of failed requests."
 msgstr ""
 "Squid conserve au chaud (la mis en cache) des meta-données et des données "
-"les plus utilisées cachées dans la RAM, il conserve aussi les DNS dans la "
-"mémoire, les DNS sont non bloquante et applique la mise en cache négative "
+"les plus utilisées sont cachées dans la RAM, il conserve aussi les DNS dans "
+"la mémoire, les DNS sont non bloquante et applique la mise en cache négative "
 "des requêtes ayant échouées."
 
 #. type: Plain text
@@ -2038,14 +2041,14 @@ msgstr "Dans l'en-tête ne PAS inclure Accept:"
 #: tools/squidclient.1:66
 msgid "Ping mode, perform I<count> iterations (0 to loop until interrupted)."
 msgstr ""
-"Mode ping, I<count> permet une répétition (boucle de 0 à ..., jusqu'à "
-"l'interrompu)."
+"Mode ping, I<count> permet une répétition (boucle de 0 à ..., jusqu'à son "
+"interruption)."
 
 #. type: Plain text
 #: tools/squidclient.1:71
 msgid "Retrieve URL from cache on hostname.  Default is B<localhost>"
 msgstr ""
-"Accéde à l'URL du nom d'hôte dans la mémoire cache. Par défaut B<localhost>"
+"Accède à l'URL du nom d'hôte dans la mémoire cache. Par défaut B<localhost>"
 
 #. type: Plain text
 #: tools/squidclient.1:77
@@ -2093,9 +2096,9 @@ msgid ""
 msgstr ""
 "Méthode de requête par défaut\n"
 "I<GET.>\n"
-"Squid prend également en charge une méthode non-standard appelé\n"
+"Squid prend également en charge une méthode non-standard appelée\n"
 "I<PURGE.>\n"
-"Vous pouvez l'utiliser avec purger une URL spécifique à partir du cache.\n"
+"Vous pouvez l'utiliser pour purger une URL spécifique à partir du cache.\n"
 "Vous devez avoir\n"
 "I<purge>\n"
 "pour accéder au setup dans\n"
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.2.0.16 release notes</title>
+<title>Squid 3.2.0.17 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.2.0.16 for testing.
+The Squid Team are pleased to announce the release of Squid-3.2.0.17 for testing.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.2/"> or the <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
 
@@ -154,3 +154,10 @@ rfc4559.txt
 	Microsoft Negotiate "HTTP" authentication scheme
 	Microsoft connection pinning HTTP extension to support
 	connection oriented authentication over proxies
+
+rfc6585.txt
+	Additional HTTP Status Codes
+	428 (Precondition Required),
+	429 (Too Many Requests),
+	431 (Request Header Fields Too Large),
+	511 (Network Authentication Required)
@@ -0,0 +1,563 @@
+
+
+
+
+
+
+Internet Engineering Task Force (IETF)                     M. Nottingham
+Request for Comments: 6585                                     Rackspace
+Updates: 2616                                                R. Fielding
+Category: Standards Track                                          Adobe
+ISSN: 2070-1721                                               April 2012
+
+
+                      Additional HTTP Status Codes
+
+Abstract
+
+   This document specifies additional HyperText Transfer Protocol (HTTP)
+   status codes for a variety of common situations.
+
+Status of This Memo
+
+   This is an Internet Standards Track document.
+
+   This document is a product of the Internet Engineering Task Force
+   (IETF).  It represents the consensus of the IETF community.  It has
+   received public review and has been approved for publication by the
+   Internet Engineering Steering Group (IESG).  Further information on
+   Internet Standards is available in Section 2 of RFC 5741.
+
+   Information about the current status of this document, any errata,
+   and how to provide feedback on it may be obtained at
+   http://www.rfc-editor.org/info/rfc6585.
+
+Copyright Notice
+
+   Copyright (c) 2012 IETF Trust and the persons identified as the
+   document authors.  All rights reserved.
+
+   This document is subject to BCP 78 and the IETF Trust's Legal
+   Provisions Relating to IETF Documents
+   (http://trustee.ietf.org/license-info) in effect on the date of
+   publication of this document.  Please review these documents
+   carefully, as they describe your rights and restrictions with respect
+   to this document.  Code Components extracted from this document must
+   include Simplified BSD License text as described in Section 4.e of
+   the Trust Legal Provisions and are provided without warranty as
+   described in the Simplified BSD License.
+
+
+
+
+
+
+
+
+
+Nottingham & Fielding        Standards Track                    [Page 1]
+
+RFC 6585              Additional HTTP Status Codes            April 2012
+
+
+Table of Contents
+
+   1. Introduction ....................................................2
+   2. Requirements ....................................................2
+   3. 428 Precondition Required .......................................2
+   4. 429 Too Many Requests ...........................................3
+   5. 431 Request Header Fields Too Large .............................4
+   6. 511 Network Authentication Required .............................4
+   7. Security Considerations .........................................6
+   8. IANA Considerations .............................................7
+   9. References ......................................................7
+   Appendix A. Acknowledgements .......................................9
+   Appendix B. Issues Raised by Captive Portals .......................9
+
+1.  Introduction
+
+   This document specifies additional HTTP [RFC2616] status codes for a
+   variety of common situations, to improve interoperability and avoid
+   confusion when other, less precise status codes are used.
+
+   Note that these status codes are optional; servers cannot be required
+   to support them.  However, because clients will treat unknown status
+   codes as a generic error of the same class (e.g., 499 is treated as
+   400 if it is not recognized), they can be safely deployed by existing
+   servers (see [RFC2616] Section 6.1.1 for more information).
+
+2.  Requirements
+
+   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
+   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
+   document are to be interpreted as described in [RFC2119].
+
+3.  428 Precondition Required
+
+   The 428 status code indicates that the origin server requires the
+   request to be conditional.
+
+   Its typical use is to avoid the "lost update" problem, where a client
+   GETs a resource's state, modifies it, and PUTs it back to the server,
+   when meanwhile a third party has modified the state on the server,
+   leading to a conflict.  By requiring requests to be conditional, the
+   server can assure that clients are working with the correct copies.
+
+   Responses using this status code SHOULD explain how to resubmit the
+   request successfully.  For example:
+
+   HTTP/1.1 428 Precondition Required
+   Content-Type: text/html
+
+
+
+Nottingham & Fielding        Standards Track                    [Page 2]
+
+RFC 6585              Additional HTTP Status Codes            April 2012
+
+
+   <html>
+      <head>
+         <title>Precondition Required</title>
+      </head>
+      <body>
+         <h1>Precondition Required</h1>
+         <p>This request is required to be conditional;
+         try using "If-Match".</p>
+      </body>
+   </html>
+
+   Responses with the 428 status code MUST NOT be stored by a cache.
+
+4.  429 Too Many Requests
+
+   The 429 status code indicates that the user has sent too many
+   requests in a given amount of time ("rate limiting").
+
+   The response representations SHOULD include details explaining the
+   condition, and MAY include a Retry-After header indicating how long
+   to wait before making a new request.
+
+   For example:
+
+   HTTP/1.1 429 Too Many Requests
+   Content-Type: text/html
+   Retry-After: 3600
+
+   <html>
+      <head>
+         <title>Too Many Requests</title>
+      </head>
+      <body>
+         <h1>Too Many Requests</h1>
+         <p>I only allow 50 requests per hour to this Web site per
+            logged in user.  Try again soon.</p>
+      </body>
+   </html>
+
+   Note that this specification does not define how the origin server
+   identifies the user, nor how it counts requests.  For example, an
+   origin server that is limiting request rates can do so based upon
+   counts of requests on a per-resource basis, across the entire server,
+   or even among a set of servers.  Likewise, it might identify the user
+   by its authentication credentials, or a stateful cookie.
+
+   Responses with the 429 status code MUST NOT be stored by a cache.
+
+
+
+
+Nottingham & Fielding        Standards Track                    [Page 3]
+
+RFC 6585              Additional HTTP Status Codes            April 2012
+
+
+5.  431 Request Header Fields Too Large
+
+   The 431 status code indicates that the server is unwilling to process
+   the request because its header fields are too large.  The request MAY
+   be resubmitted after reducing the size of the request header fields.
+
+   It can be used both when the set of request header fields in total is
+   too large, and when a single header field is at fault.  In the latter
+   case, the response representation SHOULD specify which header field
+   was too large.
+
+   For example:
+
+   HTTP/1.1 431 Request Header Fields Too Large
+   Content-Type: text/html
+
+   <html>
+      <head>
+         <title>Request Header Fields Too Large</title>
+      </head>
+      <body>
+         <h1>Request Header Fields Too Large</h1>
+         <p>The "Example" header was too large.</p>
+      </body>
+   </html>
+
+   Responses with the 431 status code MUST NOT be stored by a cache.
+
+6.  511 Network Authentication Required
+
+   The 511 status code indicates that the client needs to authenticate
+   to gain network access.
+
+   The response representation SHOULD contain a link to a resource that
+   allows the user to submit credentials (e.g., with an HTML form).
+
+   Note that the 511 response SHOULD NOT contain a challenge or the
+   login interface itself, because browsers would show the login
+   interface as being associated with the originally requested URL,
+   which may cause confusion.
+
+   The 511 status SHOULD NOT be generated by origin servers; it is
+   intended for use by intercepting proxies that are interposed as a
+   means of controlling access to the network.
+
+   Responses with the 511 status code MUST NOT be stored by a cache.
+
+
+
+
+
+Nottingham & Fielding        Standards Track                    [Page 4]
+
+RFC 6585              Additional HTTP Status Codes            April 2012
+
+
+6.1.  The 511 Status Code and Captive Portals
+
+   The 511 status code is designed to mitigate problems caused by
+   "captive portals" to software (especially non-browser agents) that is
+   expecting a response from the server that a request was made to, not
+   the intervening network infrastructure.  It is not intended to
+   encourage deployment of captive portals -- only to limit the damage
+   caused by them.
+
+   A network operator wishing to require some authentication, acceptance
+   of terms, or other user interaction before granting access usually
+   does so by identifying clients who have not done so ("unknown
+   clients") using their Media Access Control (MAC) addresses.
+
+   Unknown clients then have all traffic blocked, except for that on TCP
+   port 80, which is sent to an HTTP server (the "login server")
+   dedicated to "logging in" unknown clients, and of course traffic to
+   the login server itself.
+
+   For example, a user agent might connect to a network and make the
+   following HTTP request on TCP port 80:
+
+   GET /index.htm HTTP/1.1
+   Host: www.example.com
+
+   Upon receiving such a request, the login server would generate a 511
+   response:
+
+   HTTP/1.1 511 Network Authentication Required
+   Content-Type: text/html
+
+   <html>
+      <head>
+         <title>Network Authentication Required</title>
+         <meta http-equiv="refresh"
+               content="0; url=https://login.example.net/">
+      </head>
+      <body>
+         <p>You need to <a href="https://login.example.net/">
+         authenticate with the local network</a> in order to gain
+         access.</p>
+      </body>
+   </html>
+
+   Here, the 511 status code assures that non-browser clients will not
+   interpret the response as being from the origin server, and the META
+   HTML element redirects the user agent to the login server.
+
+
+
+
+Nottingham & Fielding        Standards Track                    [Page 5]
+
+RFC 6585              Additional HTTP Status Codes            April 2012
+
+
+7.  Security Considerations
+
+7.1.  428 Precondition Required
+
+   The 428 status code is optional; clients cannot rely upon its use to
+   prevent "lost update" conflicts.
+
+7.2.  429 Too Many Requests
+
+   When a server is under attack or just receiving a very large number
+   of requests from a single party, responding to each with a 429 status
+   code will consume resources.
+
+   Therefore, servers are not required to use the 429 status code; when
+   limiting resource usage, it may be more appropriate to just drop
+   connections, or take other steps.
+
+7.3.  431 Request Header Fields Too Large
+
+   Servers are not required to use the 431 status code; when under
+   attack, it may be more appropriate to just drop connections, or take
+   other steps.
+
+7.4.  511 Network Authentication Required
+
+   In common use, a response carrying the 511 status code will not come
+   from the origin server indicated in the request's URL.  This presents
+   many security issues; e.g., an attacking intermediary may be
+   inserting cookies into the original domain's name space, may be
+   observing cookies or HTTP authentication credentials sent from the
+   user agent, and so on.
+
+   However, these risks are not unique to the 511 status code; in other
+   words, a captive portal that is not using this status code introduces
+   the same issues.
+
+   Also, note that captive portals using this status code on a Secure
+   Socket Layer (SSL) or Transport Layer Security (TLS) connection
+   (commonly, port 443) will generate a certificate error on the client.
+
+
+
+
+
+
+
+
+
+
+
+
+Nottingham & Fielding        Standards Track                    [Page 6]
+
+RFC 6585              Additional HTTP Status Codes            April 2012
+
+
+8.  IANA Considerations
+
+   The HTTP Status Codes registry has been updated with the following
+   entries:
+
+      Value: 428
+      Description: Precondition Required
+      Reference: [RFC6585]
+
+      Value: 429
+      Description: Too Many Requests
+      Reference: [RFC6585]
+
+      Value: 431
+      Description: Request Header Fields Too Large
+      Reference: [RFC6585]
+
+      Value: 511
+      Description: Network Authentication Required
+      Reference: [RFC6585]
+
+9.  References
+
+9.1.  Normative References
+
+   [RFC2119]   Bradner, S., "Key words for use in RFCs to Indicate
+               Requirement Levels", BCP 14, RFC 2119, March 1997.
+
+   [RFC2616]   Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
+               Masinter, L., Leach, P., and T. Berners-Lee, "Hypertext
+               Transfer Protocol -- HTTP/1.1", RFC 2616, June 1999.
+
+9.2.  Informative References
+
+   [CORS]      van Kesteren, A., Ed., "Cross-Origin Resource Sharing",
+               W3C Working Draft WD-cors-20100727, July 2010,
+               <http://www.w3.org/TR/cors/>.
+
+   [Favicon]   Wikipedia, "Favicon", March 2012,
+               <http://en.wikipedia.org/w/
+               index.php?title=Favicon&oldid=484627550>.
+
+   [OAuth2.0]  Hammer-Lahav, E., Ed., Recordon, D., and D. Hardt, "The
+               OAuth 2.0 Authorization Protocol", Work in Progress,
+               March 2012.
+
+
+
+
+
+
+Nottingham & Fielding        Standards Track                    [Page 7]
+
+RFC 6585              Additional HTTP Status Codes            April 2012
+
+
+   [P3P]       Marchiori, M., Ed., "The Platform for Privacy Preferences
+               1.0 (P3P1.0) Specification", W3C Recommendation
+               REC-P3P-20020416, April 2002,
+               <http://www.w3.org/TR/P3P/>.
+
+   [RFC4791]   Daboo, C., Desruisseaux, B., and L. Dusseault,
+               "Calendaring Extensions to WebDAV (CalDAV)", RFC 4791,
+               March 2007.
+
+   [RFC4918]   Dusseault, L., Ed., "HTTP Extensions for Web Distributed
+               Authoring and Versioning (WebDAV)", RFC 4918, June 2007.
+
+   [WIDGETS]   Caceres, M., Ed., "Widget Packaging and XML
+               Configuration", W3C Recommendation REC-widgets-20110927,
+               September 2011, <http://www.w3.org/TR/widgets/>.
+
+   [WebFinger] WebFinger Project, "WebFingerProtocol (Draft)",
+               January 2010, <http://code.google.com/p/webfinger/wiki/
+               WebFingerProtocol>.
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Nottingham & Fielding        Standards Track                    [Page 8]
+
+RFC 6585              Additional HTTP Status Codes            April 2012
+
+
+Appendix A.  Acknowledgements
+
+   Thanks to Jan Algermissen and Julian Reschke for their suggestions
+   and feedback.
+
+Appendix B.  Issues Raised by Captive Portals
+
+   Since clients cannot differentiate between a portal's response and
+   that of the HTTP server that they intended to communicate with, a
+   number of issues arise.  The 511 status code is intended to help
+   mitigate some of them.
+
+   One example is the "favicon.ico" [Favicon] commonly used by browsers
+   to identify the site being accessed.  If the favicon for a given site
+   is fetched from a captive portal instead of the intended site (e.g.,
+   because the user is unauthenticated), it will often "stick" in the
+   browser's cache (most implementations cache favicons aggressively)
+   beyond the portal session, so that it seems as if the portal's
+   favicon has "taken over" the legitimate site.
+
+   Another browser-based issue comes about when the Platform for Privacy
+   Preferences [P3P] is supported.  Depending on how it is implemented,
+   it's possible a browser might interpret a portal's response for the
+   p3p.xml file as the server's, resulting in the privacy policy (or
+   lack thereof) advertised by the portal being interpreted as applying
+   to the intended site.  Other Web-based protocols such as WebFinger
+   [WebFinger], Cross-Origin Resource Sharing [CORS], and Open
+   Authorization [OAuth2.0] may also be vulnerable to such issues.
+
+   Although HTTP is most widely used with Web browsers, a growing number
+   of non-browsing applications use it as a substrate protocol.  For
+   example, Web Distributed Authoring and Versioning (WebDAV) [RFC4918]
+   and Calendaring Extensions to WebDAV (CalDAV) [RFC4791] both use HTTP
+   as the basis (for remote authoring and calendaring, respectively).
+   Using these applications from behind a captive portal can result in
+   spurious errors being presented to the user, and might result in
+   content corruption, in extreme cases.
+
+   Similarly, other non-browser applications using HTTP can be affected
+   as well, e.g., widgets [WIDGETS], software updates, and other
+   specialized software such as Twitter clients and the iTunes Music
+   Store.
+
+   It should be noted that it's sometimes believed that using HTTP
+   redirection to direct traffic to the portal addresses these issues.
+   However, since many of these uses "follow" redirects, this is not a
+   good solution.
+
+
+
+
+Nottingham & Fielding        Standards Track                    [Page 9]
+
+RFC 6585              Additional HTTP Status Codes            April 2012
+
+
+Authors' Addresses
+
+   Mark Nottingham
+   Rackspace
+
+   EMail: mnot@mnot.net
+   URI:   http://www.mnot.net/
+
+
+   Roy T. Fielding
+   Adobe Systems Incorporated
+   345 Park Ave.
+   San Jose, CA  95110
+   USA
+
+   EMail: fielding@gbiv.com
+   URI:   http://roy.gbiv.com/
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+Nottingham & Fielding        Standards Track                   [Page 10]
+
@@ -3,7 +3,7 @@ msgstr ""
 "Project-Id-Version: Squid-3\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2012-02-06 18:41+1300\n"
-"PO-Revision-Date: 2012-03-04 19:05+0200\n"
+"PO-Revision-Date: 2012-04-01 21:32+0200\n"
 "Last-Translator: Bernard <fli4l.charrier@free.fr>\n"
 "Language-Team: Squid Developers <squid-dev@squid-cache.org>\n"
 "Language: fr\n"
@@ -549,12 +549,12 @@ msgstr ""
 #: templates/ERR_INVALID_URL+html.body.div.ul.li.p:33
 msgid "Illegal character in hostname; underscores are not allowed."
 msgstr ""
-"Caractère non valide dans le nom d'hôte; Les caractères soulignés "
-"(underscores) ne sont pas autorisés."
+"Caractère illégal dans le nom d'hôte; Le caractère tiret bas n'est pas "
+"autorisé."
 
 #: templates/ERR_INVALID_URL+html.body.div.ul.li.p:32
 msgid "Illegal double-escape in the URL-Path"
-msgstr "Les double espaces ne sont pas valides dans une adresse URL"
+msgstr "Les doubles espaces sont illégaux dans une adresse URL"
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:30
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:38
@@ -654,7 +654,7 @@ msgstr "Délai de lecture dépassé"
 
 #: templates/ERR_INVALID_REQ+html.body.div.ul.li.p:31
 msgid "Request is too large."
-msgstr "La requête est trop volumineuse"
+msgstr "La requête est trop grande"
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT.detail:9
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY.detail:81
@@ -722,7 +722,7 @@ msgstr "Erreur de socket"
 
 #: templates/ERR_INVALID_URL+html.body.div.p:26
 msgid "Some aspect of the requested URL is incorrect."
-msgstr "Quelque chose dans l'adresse URL est incorrect."
+msgstr "Certains aspects de l'adresse URL est incorrect."
 
 #: templates/ERR_CANNOT_FORWARD+html.body.div.p:28
 #: templates/ERR_CONFLICT_HOST+html.body.div.p:28
@@ -880,7 +880,7 @@ msgstr ""
 
 #: templates/ERR_TOO_BIG+html.body.div.blockquote.p:23
 msgid "The request or reply is too large."
-msgstr "La requête ou la réponse sont trop volumineuses."
+msgstr "La requête ou la réponse est trop grande."
 
 #: templates/ERR_ACCESS_DENIED+html.body.div.h2:15
 #: templates/ERR_ACL_TIME_QUOTA_EXCEEDED+html.body.div.h2:15
@@ -8,7 +8,7 @@ msgstr ""
 "Project-Id-Version: squid\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2012-02-06 18:41+1300\n"
-"PO-Revision-Date: 2012-03-16 13:18+0200\n"
+"PO-Revision-Date: 2012-03-30 20:25+0200\n"
 "Last-Translator: Aecio F. <aecioneto@gmail.com>\n"
 "Language-Team: Brazilian Portuguese <pt_BR@li.org>\n"
 "Language: pt_BR\n"
@@ -112,14 +112,12 @@ msgstr ""
 "<b>Resposta Inválida</b> erro encontrado ao tentar processar a requisição:"
 
 #: templates/ERR_READ_TIMEOUT+html.body.div.p:28
-#, fuzzy
 msgid ""
 "A Timeout occurred while waiting to read data from the network. The network "
 "or server may be down or congested. Please retry your request."
 msgstr ""
 "Tempo esgotado esperando a leitura de dados pela rede. A rede ou o servidor "
-"pode estar desconectado ou congestionado. Por favor, tente novamente sua "
-"requisição."
+"pode estar desconectado ou congestionado. Por favor, repita sua requisição."
 
 #: templates/ERR_URN_RESOLVE+html.body.div.h2:15
 msgid "A URL for the requested URN could not be retrieved"
@@ -138,7 +136,6 @@ msgid "Access Denied."
 msgstr "Acesso negado."
 
 #: templates/ERR_ACCESS_DENIED+html.body.div.p:26
-#, fuzzy
 msgid ""
 "Access control configuration prevents your request from being allowed at "
 "this time. Please contact your service provider if you feel this is "
@@ -150,7 +147,8 @@ msgstr ""
 
 #: templates/ERR_CANNOT_FORWARD+html.body.div.ul.li:31
 msgid "All configured parent caches may be currently unreachable."
-msgstr "Todos os caches-pais parecem estar fora de alcance no momento."
+msgstr ""
+"Todos os caches-pais configurados parecem estar fora de alcance no momento."
 
 #: templates/ERR_FTP_FORBIDDEN+html.body.div.p:20
 msgid ""
@@ -185,17 +183,21 @@ msgstr ""
 msgid ""
 "An error condition occurred while reading data from the network. Please "
 "retry your request."
-msgstr "Ocorreu um erro ao ler dados da rede. Por favor, repita sua requisição."
+msgstr ""
+"Ocorreu uma condição de erro ao ler dados da rede. Por favor, repita sua "
+"requisição."
 
 #: templates/ERR_WRITE_ERROR+html.body.div.p:28
 msgid ""
 "An error condition occurred while writing to the network. Please retry your "
 "request."
-msgstr "Ocorreu um erro ao escrever na rede. Por favor, repita sua requisição."
+msgstr ""
+"Ocorreu uma condição de erro ao escrever na rede. Por favor, repita sua "
+"requisição."
 
 #: templates/error-details.txt+X509_V_ERR_APPLICATION_VERIFICATION.descr:133
 msgid "Application verification failure"
-msgstr "Falha de verificação de aplicação"
+msgstr "Verificação do aplicativo falhou"
 
 #: templates/ERR_PRECONDITION_FAILED+html.body.div.blockquote.p:28
 msgid ""
@@ -244,9 +246,8 @@ msgid "Certificate chain too long"
 msgstr "Cadeia de certificados longa demais"
 
 #: templates/error-details.txt+SQUID_X509_V_ERR_DOMAIN_MISMATCH.descr:5
-#, fuzzy
 msgid "Certificate does not match domainname"
-msgstr "Certificate is not yet valid"
+msgstr "Certificado não combina com nome de domínio"
 
 #: templates/error-details.txt+X509_V_ERR_CERT_HAS_EXPIRED.descr:41
 msgid "Certificate has expired"
@@ -298,7 +299,7 @@ msgstr "Diretório: %U"
 
 #: templates/ERR_DIR_LISTING+html.body.div.h2:14
 msgid "Directory: <a href=\"%U\">%U</a>/"
-msgstr "Directório: <a href=\"%U\">%U</a>/"
+msgstr "Diretório: <a href=\"%U\">%U</a>/"
 
 #: templates/ERR_ACCESS_DENIED+html.body.div.h1:14
 #: templates/ERR_ACL_TIME_QUOTA_EXCEEDED+html.body.div.h1:14
@@ -343,11 +344,11 @@ msgstr "ERRO"
 
 #: templates/ERR_CACHE_ACCESS_DENIED+html.head.title:4
 msgid "ERROR: Cache Access Denied"
-msgstr "ERRO: Acesso ao cache negado "
+msgstr "ERRO: Acesso negado ao cache"
 
 #: templates/ERR_CACHE_MGR_ACCESS_DENIED+html.head.title:4
 msgid "ERROR: Cache Manager Access Denied"
-msgstr "ERRO: Acesso ao gerenciador de cache negado"
+msgstr "ERRO: Acesso negado ao gerenciador de cache"
 
 #: templates/ERR_FTP_PUT_ERROR+html.head.title:4
 msgid "ERROR: FTP upload failed"
@@ -390,7 +391,7 @@ msgstr "ERRO: A URL requisitada não pode ser recuperada"
 
 #: templates/ERR_URN_RESOLVE+html.head.title:4
 msgid "ERROR: The requested URN could not be retrieved"
-msgstr "ERRO: A URL requisitada não pode ser recebida"
+msgstr "ERRO: A URN requisitada não pode ser recuperada"
 
 #: templates/ERR_ESI+html.body.div.blockquote.p:23
 msgid "ESI Processing failed."
@@ -424,17 +425,17 @@ msgstr "Arquivo atualizado"
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:26
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:26
 msgid "For Firefox browsers go to: <ul>"
-msgstr "Para navegadores Firefox vá para: <url>"
+msgstr "Para navegadores Firefox vá para: <ul>"
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:34
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:34
 msgid "For Internet Explorer browsers go to: <ul>"
-msgstr "Para navegadores Internet Expĺorer vá para: <url>"
+msgstr "Para navegadores Internet Expĺorer vá para: <ul>"
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:42
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:42
 msgid "For Opera browsers go to: <ul>"
-msgstr "Para navegadores Opera vá para: <url>"
+msgstr "Para navegadores Opera vá para: <ul>"
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD.descr:61
 msgid "Format error in CRL's lastUpdate field"
@@ -446,7 +447,7 @@ msgstr "Erro de formato no campo nextUpdate do CRL"
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD.descr:57
 msgid "Format error in certificate's notAfter field"
-msgstr "Erro de formato nos certificados no campo notAfter"
+msgstr "Erro de formato no campo notAfter do certificado"
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD.descr:53
 msgid "Format error in certificate's notBefore field"
@@ -507,12 +508,11 @@ msgstr "Gerado %T por %h (%s)"
 #: templates/ERR_INVALID_REQ+html.body.div.ul.li.p:34
 msgid ""
 "HTTP/1.1 <q>Expect:</q> feature is being asked from an HTTP/1.0 software."
-msgstr "HTTP/1.1 <q>Expect:</q> requisição proveniente de um software HTTP/1.0"
+msgstr "HTTP/1.1 <q>Expect:</q> requisição proveniente de um software HTTP/1.0."
 
 #: templates/error-details.txt+SQUID_ERR_SSL_HANDSHAKE.descr:1
-#, fuzzy
 msgid "Handshake with SSL server failed"
-msgstr "Handshake com servidor SSL falhou"
+msgstr "Negociação com servidor SSL falhou"
 
 #: templates/ERR_URN_RESOLVE+html.body.div.p:26
 msgid "Hey, don't expect too much from URNs on %T :)"
@@ -521,7 +521,7 @@ msgstr "Olha, não espere muito por URNs em %T :)"
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.p:24
 #: templates/ERR_AGENT_WPAD+html.body.div.p:24
 msgid "How to find these settings in your browser:"
-msgstr "Como encontrar estas configurações no seu navegador"
+msgstr "Como encontrar estas configurações no seu navegador:"
 
 #: templates/ERR_ICAP_FAILURE+html.body.div.blockquote.p:23
 msgid "ICAP protocol error."
@@ -604,11 +604,11 @@ msgstr "Operação bem sucedida"
 
 #: templates/error-details.txt+X509_V_ERR_OUT_OF_MEM.descr:69
 msgid "Out of memory"
-msgstr "Out of memory"
+msgstr "Memória insuficiente"
 
 #: templates/error-details.txt+X509_V_ERR_PATH_LENGTH_EXCEEDED.descr:101
 msgid "Path length constraint exceeded"
-msgstr "Path length constraint exceeded"
+msgstr "Limite de comprimento do Path excedido"
 
 #: templates/ERR_CACHE_MGR_ACCESS_DENIED+html.body.div.p:28
 msgid ""
@@ -623,7 +623,6 @@ msgstr ""
 "cache e cheque o log para maiores detalhes sobre mensagens de erro."
 
 #: templates/ERR_CACHE_ACCESS_DENIED+html.body.div.p:28
-#, fuzzy
 msgid ""
 "Please contact the <a href=\"mailto:%w%W\">cache administrator</a> if you "
 "have difficulties authenticating yourself."
@@ -634,7 +633,7 @@ msgstr ""
 
 #: templates/ERR_PRECONDITION_FAILED+html.body.div.blockquote.p:23
 msgid "Precondition Failed."
-msgstr "Pré-condição Falhou."
+msgstr "Précondição falhou."
 
 #: templates/ERR_READ_ERROR+html.body.div.blockquote.p:23
 msgid "Read Error"
@@ -651,33 +650,36 @@ msgstr "Requisição é muito grande."
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT.detail:9
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY.detail:81
 msgid "SSL Certficate error: certificate issuer (CA) not known: %ssl_ca_name"
-msgstr "SSL Certficate error: certificate issuer (CA) not known: %ssl_ca_name"
+msgstr ""
+"Erro de Certificado SSL: emissor do certificado (CA) desconhecido: %"
+"ssl_ca_name"
 
 #: templates/error-details.txt+X509_V_ERR_CERT_NOT_YET_VALID.detail:37
 msgid "SSL Certficate is not valid before: %ssl_notbefore"
-msgstr "SSL Certficate is not valid before: %ssl_notbefore"
+msgstr "O Certificado SSL não é válido antes: %ssl_notbefore"
 
 #: templates/error-details.txt+X509_V_ERR_CERT_HAS_EXPIRED.detail:41
 msgid "SSL Certificate expired on: %ssl_notafter"
-msgstr "SSL Certificate expired on: %ssl_notafter"
+msgstr "O Certificado SSL expirou em: %ssl_notafter"
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD.detail:57
 msgid ""
 "SSL Certificate has invalid expiration date (the 'not after' field): "
 "%ssl_subject"
 msgstr ""
-"SSL Certificate has invalid expiration date (the 'not after' field): "
-"%ssl_subject"
+"O Certificado SSL tem data de expiração inválida (o campo 'not after'): %"
+"ssl_subject"
 
 #: templates/error-details.txt+X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD.detail:53
 msgid ""
 "SSL Certificate has invalid start date (the 'not before' field): %ssl_subject"
 msgstr ""
-"SSL Certificate has invalid start date (the 'not before' field): %ssl_subject"
+"O Certificado SSL tem data de início inválida (o campo 'not before'): %"
+"ssl_subject"
 
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:30
 msgid "Select Auto-detect proxy settings for this network"
-msgstr "Selecione Autodetectart as configurações de proxy para esta rede"
+msgstr "Selecionar configurações de auto-detecção de proxy para esta rede"
 
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:38
 msgid "Select Automatically detect settings"
@@ -689,19 +691,19 @@ msgstr "Selecione Usar configuração automática de proxy"
 
 #: templates/error-details.txt+X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT.descr:73
 msgid "Self signed certificate"
-msgstr "Self signed certificate"
+msgstr "Certificado próprio"
 
 #: templates/error-details.txt+X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN.descr:77
 msgid "Self signed certificate in certificate chain"
-msgstr "Self signed certificate in certificate chain"
+msgstr "Certificado próprio na cadeia de certificados"
 
 #: templates/error-details.txt+X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN.detail:77
 msgid "Self-signed SSL Certificate in chain: %ssl_subject"
-msgstr "Self-signed SSL Certificate in chain: %ssl_subject"
+msgstr "Certificado SSL próprio na cadeia: %ssl_subject"
 
 #: templates/error-details.txt+X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT.detail:73
 msgid "Self-signed SSL Certificate: %ssl_subject"
-msgstr "Self-signed SSL Certificate: %ssl_subject"
+msgstr "Certificado SSL próprio: %ssl_subject"
 
 #: templates/ERR_SOCKET_FAILURE+html.body.div.blockquote.p:23
 msgid "Socket Failure"
@@ -732,7 +734,7 @@ msgid ""
 "Sorry, you are not currently allowed to request %U from this cache until you "
 "have authenticated yourself."
 msgstr ""
-"Desculpe. Atualmente, você não está permitido a requisitar %U desse cache "
+"Desculpe. Atualmente, você não tem permissáo para requisitar %U deste cache "
 "até que você tenha se autenticado."
 
 #: templates/ERR_ZERO_SIZE_OBJECT+html.body.div.p:26
@@ -774,7 +776,7 @@ msgstr "Squid enviou o seguinte comando FTP:"
 
 #: templates/error-details.txt+X509_V_ERR_SUBJECT_ISSUER_MISMATCH.descr:117
 msgid "Subject issuer mismatch"
-msgstr "Subject issuer mismatch"
+msgstr "Emissor do assunto não coincide"
 
 #: templates/ERR_DNS_FAIL+html.body.div.p:26
 msgid "The DNS server returned:"
@@ -865,10 +867,9 @@ msgstr ""
 "a>"
 
 #: templates/ERR_CONNECT_FAIL+html.body.div.p:28
-#, fuzzy
 msgid "The remote host or network may be down. Please try the request again."
 msgstr ""
-"O host remoto ou a rede pode estar fora do ar. Por favor, faça a requisição "
+"O host ou rede remota pode estar fora do ar. Por favor, faça a requisição "
 "novamente."
 
 #: templates/ERR_TOO_BIG+html.body.div.blockquote.p:23
@@ -928,33 +929,30 @@ msgid "The system returned: <i>%E</i>"
 msgstr "O sistema retornou: <i>%E</i>"
 
 #: templates/ERR_CONFLICT_HOST+html.body.div.ul.li:31
-#, fuzzy
 msgid ""
 "The website may require you to use a local country-based version. Using your "
 "ISP provided DNS server(s) should resolve that."
 msgstr ""
-"O website pode exigir que você use uma versão 'country-based' local. Usar os "
-"servidores DNS fornecidos por seu provedor pode resolver isto."
+"O website pode exigir que você use uma versão baseada no país local. Usar "
+"o(s) servidore(s) DNS fornecido(s) por seu provedor pode resolver isto."
 
 #: templates/ERR_NO_RELAY+html.body.div.p:26
-#, fuzzy
 msgid ""
 "There is no WAIS Relay host defined for this Cache! Yell at the "
 "administrator."
 msgstr ""
-"Não há nenhum host de WAIS Relay definido para esse Cache!  Contate o "
+"Não há nenhum host de relay de WAIS definido para esse Cache! Contate o "
 "administrador."
 
 #: templates/ERR_ACL_TIME_QUOTA_EXCEEDED+html.body.div.p:27
 #: templates/ERR_TOO_BIG+html.body.div.p:28
-#, fuzzy
 msgid ""
 "These limits have been established by the Internet Service Provider who "
 "operates this cache. Please contact them directly if you feel this is an "
 "error."
 msgstr ""
-"Esses limites foram estabelecidos pelo Provedor de Serviço Internet em que "
-"este cache opera. Por favor, contate-os diretamente se você acha que isso é "
+"Esses limites foram estabelecidos pelo Provedor de Serviço Internet que "
+"opera este cache. Por favor, contate-os diretamente se você acha que isso é "
 "um erro."
 
 #: templates/ERR_UNSUP_HTTPVERSION+html.body.div.p:26
@@ -966,16 +964,14 @@ msgid "This cache does not support FTP."
 msgstr "Esse cache não suporta FTP."
 
 #: templates/ERR_SHUTTING_DOWN+html.body.div.p:22
-#, fuzzy
 msgid ""
 "This cache is in the process of shutting down and can not service your "
 "request at this time. Please retry your request again soon."
 msgstr ""
 "Este cache está sendo desligado e não pode atender sua requisição neste "
-"momento.  Por favor, tente novamente em breve."
+"momento. Por favor, tente novamente em breve."
 
 #: templates/ERR_FORWARDING_DENIED+html.body.div.p:26
-#, fuzzy
 msgid ""
 "This cache will not forward your request because it is trying to enforce a "
 "sibling relationship. Perhaps the client at %i is a cache which has been "
@@ -985,14 +981,12 @@ msgstr ""
 "relacionamento. Talvez o cliente em %i é um cache que está mal configurado."
 
 #: templates/ERR_GATEWAY_FAILURE+html.body.div.p:28
-#, fuzzy
 msgid ""
 "This may be due to limits established by the Internet Service Provider who "
 "operates this cache. Please contact them directly for more information."
 msgstr ""
-"Esses limites foram estabelecidos pelo Provedor de Serviço Internet em que "
-"este cache opera. Por favor, contate-os diretamente se você acha que isso é "
-"um erro."
+"Isto pode ser devido aos limites estabelecidos pelo provedor de internet que "
+"opera este cache. Por favor contate-os para mais informações."
 
 #: templates/ERR_ICAP_FAILURE+html.body.div.p:28
 msgid "This means that some aspect of the ICAP communication failed."
@@ -1036,15 +1030,14 @@ msgid "This means:"
 msgstr "Isto significa:"
 
 #: templates/ERR_FTP_NOT_FOUND+html.body.div.p:33
-#, fuzzy
 msgid ""
 "This might be caused by an FTP URL with an absolute path (which does not "
 "comply with RFC 1738). If this is the cause, then the file can be found at "
 "<a href=\"%B\">%B</a>."
 msgstr ""
-"Isto pode ter sido causado por uma URL de FTP com um caminho absoluto (que "
-"não é conforme com a RFC 1738). Se esta for a causa, então o arquivo pode "
-"ser encontrado em <a href=\"%B\">%B</a>."
+"Isto pode ser causa de uma URL de FTP com um caminho absoluto (que não é "
+"conforme com a RFC 1738). Se esta for a causa, então o arquivo pode ser "
+"encontrado em <a href=\"%B\">%B</a>."
 
 #: templates/ERR_SECURE_CONNECT_FAIL+html.body.div.p:28
 msgid ""
@@ -1077,7 +1070,7 @@ msgstr ""
 
 #: templates/ERR_ACL_TIME_QUOTA_EXCEEDED+html.body.div.blockquote.p:23
 msgid "Time Quota Exceeded."
-msgstr "Quota de Tempo Excedida."
+msgstr "Quota de tempo Excedida."
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.div.ul.li:37
 #: templates/ERR_AGENT_WPAD+html.body.div.div.ul.li:37
@@ -1109,19 +1102,20 @@ msgstr "Conflito de máquina de URI"
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY.detail:25
 msgid "Unable to decode issuer (CA) public key: %ssl_ca_name"
-msgstr "Unable to decode issuer (CA) public key: %ssl_ca_name"
+msgstr ""
+"Não foi possível decodificar a chave pública do emissor (CA): %ssl_ca_name"
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY.descr:25
 msgid "Unable to decode issuer public key"
-msgstr "Unable to decode issuer public key"
+msgstr "Não foi possível decodificar a chave pública do emissor"
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE.descr:21
 msgid "Unable to decrypt CRL's signature"
-msgstr "Unable to decrypt CRL's signature"
+msgstr "Não foi possível descriptografar a assinatura CRL"
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE.descr:17
 msgid "Unable to decrypt certificate's signature"
-msgstr "Unable to decrypt certificate's signature"
+msgstr "Não foi possível descriptografar a assinatura do certificado"
 
 #: templates/ERR_DNS_FAIL+html.body.div.blockquote.p:23
 msgid "Unable to determine IP address from host name <q>%H</q>"
@@ -1133,32 +1127,32 @@ msgstr "Impossível encaminhar esta requisição nesse momento."
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_CRL.descr:13
 msgid "Unable to get certificate CRL"
-msgstr "Unable to get certificate CRL"
+msgstr "Não foi possível obter certificado CRL"
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT.descr:9
 msgid "Unable to get issuer certificate"
-msgstr "Unable to get issuer certificate"
+msgstr "Não foi possível obter o certificado do emissor"
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY.descr:81
 msgid "Unable to get local issuer certificate"
-msgstr "Unable to get local issuer certificate"
+msgstr "Não foi possível obter o certificado do emissor local"
 
 #: templates/error-details.txt+X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE.descr:85
 msgid "Unable to verify the first certificate"
-msgstr "Unable to verify the first certificate"
+msgstr "Não foi possível verificar o primeiro certificado"
 
 #: templates/ERR_UNSUP_HTTPVERSION+html.body.div.h2:15
 #: templates/ERR_UNSUP_HTTPVERSION+html.body.div.blockquote.p:23
 msgid "Unsupported HTTP version"
-msgstr "Versão do HTTP não é suportada."
+msgstr "Versão do HTTP não é suportada"
 
 #: templates/ERR_UNSUP_REQ+html.body.div.blockquote.p:23
 msgid "Unsupported Request Method and Protocol"
 msgstr "Método e Protocolo de Requisição Não-Suportado"
 
 #: templates/error-details.txt+X509_V_ERR_INVALID_PURPOSE.descr:105
 msgid "Unsupported certificate purpose"
-msgstr "Unsupported certificate purpose"
+msgstr "Propósito do certificado não é suportado"
 
 #: templates/ERR_ONLY_IF_CACHED_MISS+html.body.div.blockquote.p:23
 msgid ""
@@ -1173,7 +1167,7 @@ msgstr ""
 #: templates/ERR_AGENT_WPAD+html.head.title:4
 #: templates/ERR_AGENT_WPAD+html.body.div.h2:15
 msgid "Web Browser Configuration"
-msgstr "Configuração de Navegador Web"
+msgstr "Configuração do Navegador Web"
 
 #: templates/ERR_WRITE_ERROR+html.body.div.blockquote.p:23
 msgid "Write Error"
@@ -1187,7 +1181,7 @@ msgid ""
 msgstr ""
 "Você enviou uma requisição com a diretiva de controle de cache <q>only-if-"
 "cached</q>. O documento não foi encontrado no cache <em>ou</em> o cache "
-"requer uma revalidação, que é proibida por esta diretiva."
+"requer uma revalidação, que é proibida pela diretiva <q>only-if-cached</q>."
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.blockquote.p:21
 #: templates/ERR_AGENT_WPAD+html.body.div.blockquote.p:21
@@ -1257,7 +1251,6 @@ msgstr "Resposta de tamanho zero"
 #~ msgid "Parent Directory"
 #~ msgstr "Diretório pai"
 
-#, fuzzy
 msgid ""
 "This request could not be forwarded to the origin server or to any parent "
 "caches. The most likely cause for this error is that the cache "
@@ -58,6 +58,7 @@ make_snapshot()
     rm -f ${dst}/squid-${ver}.snapshot${type}.md5
     ln -s ${file}.md5 ${dst}/squid-${ver}.snapshot${type}.md5
 
+  set +e
     # cleanup old snapshots
     ls ${dst}/*-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]-r*[0-9]${type} | \
 		sed -e 's/.*-\([0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]-r[0-9]+'${type}'\)/\1/' | \
@@ -66,6 +67,8 @@ make_snapshot()
 	rm -f ${dst}/*-${f} ${dst}/*-${f}.md5
     done
 
+  set -e
+
     # update dynamic index pages Last-Modified info
     touch ${dst}/index.dyn
 
@@ -30,6 +30,7 @@
 #ifndef SQUID_HTTPACCESSLOGENTRY_H
 #define SQUID_HTTPACCESSLOGENTRY_H
 
+#include "anyp/PortCfg.h"
 #include "comm/Connection.h"
 #include "HttpVersion.h"
 #include "HttpRequestMethod.h"
@@ -39,7 +40,6 @@
 #if ICAP_CLIENT
 #include "adaptation/icap/Elements.h"
 #endif
-#include "ProtoPort.h"
 
 /* forward decls */
 class HttpReply;
@@ -154,7 +154,7 @@ class AccessLogEntry
 
         const char *ssluser;
 #endif
-        http_port_list *port;
+        AnyP::PortCfg *port;
 
     } cache;
 
@@ -71,11 +71,7 @@ class ClientRequestContext : public RefCountable
     ErrorState *error;
     bool readNextRequest;
 
-    /// Send authentication response (challenge or error) if ACL result indicates one is needed
-    /// \return true if an error page of any kind has been sent back to the client.
-    // NP: public only until ACLChecklist::nonBlockingCheck() takes Async::Pointer to a call
-    bool maybeSendAuthChallenge(const allow_t &answer);
-
+private:
     CBDATA_CLASS(ClientRequestContext);
 };
 
@@ -220,6 +220,10 @@ httpStatusString(http_status status)
         p = "Temporary Redirect";
         break;
 
+    case HTTP_PERMANENT_REDIRECT:
+        p = "Permanent Redirect";
+        break;
+
     case HTTP_BAD_REQUEST:
         p = "Bad Request";
         break;
@@ -109,7 +109,10 @@ class ICPState
 
 /// \ingroup ServerProtocolICPAPI
 struct icpUdpData {
+
+    /// IP address for the remote end. Because we reply to packets from unknown non-peers.
     Ip::Address address;
+
     void *msg;
     size_t len;
     icpUdpData *next;
@@ -128,10 +131,10 @@ extern Comm::ConnectionPointer icpOutgoingConn;
 extern Ip::Address theIcpPublicHostID;
 
 /// \ingroup ServerProtocolICPAPI
-HttpRequest* icpGetRequest(char *url, int reqnum, int fd, Ip::Address &from);
+extern HttpRequest* icpGetRequest(char *url, int reqnum, int fd, Ip::Address &from);
 
 /// \ingroup ServerProtocolICPAPI
-bool icpAccessAllowed(Ip::Address &from, HttpRequest * icp_request);
+extern bool icpAccessAllowed(Ip::Address &from, HttpRequest * icp_request);
 
 /// \ingroup ServerProtocolICPAPI
 SQUIDCEXTERN void icpCreateAndSend(icp_opcode, int flags, char const *url, int reqnum, int pad, int fd, const Ip::Address &from);
@@ -161,13 +164,13 @@ SQUIDCEXTERN void icpHandleIcpV3(int, Ip::Address &, char *, int);
 SQUIDCEXTERN int icpCheckUdpHit(StoreEntry *, HttpRequest * request);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN void icpConnectionsOpen(void);
+SQUIDCEXTERN void icpOpenPorts(void);
 
 /// \ingroup ServerProtocolICPAPI
 SQUIDCEXTERN void icpConnectionShutdown(void);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN void icpConnectionClose(void);
+SQUIDCEXTERN void icpClosePorts(void);
 
 /// \ingroup ServerProtocolICPAPI
 SQUIDCEXTERN int icpSetCacheKey(const cache_key * key);
@@ -262,8 +262,6 @@ squid_SOURCES = \
 	AsyncEngine.cc \
 	AsyncEngine.h \
 	cache_cf.cc \
-	ProtoPort.cc \
-	ProtoPort.h \
 	CacheDigest.cc \
 	cache_manager.cc \
 	CacheManager.h \
@@ -650,7 +648,7 @@ recv_announce_SOURCES = recv-announce.cc
 ## ACLProxyAuth.cc wants ACLRegexData
 ## cache_cf.cc wants $(AUTH_LIBS)
 ## cache_cf.cc wants Swapdir
-## cache_cf.cc wants ProtoPort
+## cache_cf.cc wants AnyP::PortCfg
 ## client_side wants client_db
 ## client_db wants SNMP_SOURCE
 ## snmp_core wants ACLStringData
@@ -1269,8 +1267,6 @@ tests_testCacheManager_SOURCES = \
 	BodyPipe.cc \
 	cache_manager.cc \
 	cache_cf.cc \
-	ProtoPort.cc \
-	ProtoPort.h \
 	CacheDigest.cc \
 	carp.cc \
 	cbdata.cc \
@@ -1547,7 +1543,6 @@ nodist_tests_testDiskIO_SOURCES= \
 	SquidMath.h \
 	swap_log_op.cc
 tests_testDiskIO_LDADD = \
-	anyp/libanyp.la \
 	SquidConfig.o \
 	CommCalls.o \
 	DnsLookupDetails.o \
@@ -1559,6 +1554,7 @@ tests_testDiskIO_LDADD = \
 	$(AUTH_LIBS) \
 	libsquid.la \
 	comm/libcomm.la \
+	anyp/libanyp.la \
 	ip/libip.la \
 	fs/libfs.la \
 	ipc/libipc.la \
@@ -1678,8 +1674,6 @@ tests_testEvent_SOURCES = \
 	peer_select.cc \
 	peer_sourcehash.cc \
 	peer_userhash.cc \
-	ProtoPort.cc \
-	ProtoPort.h \
 	redirect.cc \
 	refresh.cc \
 	RemovalPolicy.cc \
@@ -1872,8 +1866,6 @@ tests_testEventLoop_SOURCES = \
 	peer_select.cc \
 	peer_sourcehash.cc \
 	peer_userhash.cc \
-	ProtoPort.cc \
-	ProtoPort.h \
 	RemovalPolicy.cc \
 	redirect.cc \
 	refresh.cc \
@@ -1977,8 +1969,6 @@ tests_test_http_range_SOURCES = \
 	$(ACL_REGISTRATION_SOURCES) \
 	BodyPipe.cc \
 	cache_cf.cc \
-	ProtoPort.cc \
-	ProtoPort.h \
 	cache_manager.cc \
 	CacheDigest.cc \
 	carp.cc \
@@ -2218,8 +2208,6 @@ tests_testHttpRequest_SOURCES = \
 	cache_manager.cc \
 	cache_cf.cc \
 	debug.cc \
-	ProtoPort.cc \
-	ProtoPort.h \
 	CacheDigest.cc \
 	carp.cc \
 	cbdata.cc \
@@ -2696,13 +2684,13 @@ tests_testUfs_LDADD = \
 	mgr/libmgr.la \
 	$(REPL_OBJS) \
 	acl/libacls.la \
-	anyp/libanyp.la \
 	$(DISK_LIBS) \
 	$(DISK_OS_LIBS) \
 	acl/libapi.la \
 	ipc/libipc.la \
 	$(SSL_LIBS) \
 	comm/libcomm.la \
+	anyp/libanyp.la \
 	base/libbase.la \
 	ip/libip.la \
 	$(top_builddir)/lib/libmisccontainers.la \
@@ -2815,9 +2803,9 @@ nodist_tests_testRock_SOURCES = \
 	SquidMath.h \
 	$(TESTSOURCES)
 tests_testRock_LDADD = \
-	anyp/libanyp.la \
 	libsquid.la \
 	comm/libcomm.la \
+	anyp/libanyp.la \
 	ip/libip.la \
 	fs/libfs.la \
 	$(AUTH_LIBS) \
@@ -3198,8 +3186,6 @@ tests_testURL_SOURCES = \
 	peer_select.cc \
 	peer_sourcehash.cc \
 	peer_userhash.cc \
-	ProtoPort.cc \
-	ProtoPort.h \
 	redirect.cc \
 	refresh.cc \
 	RemovalPolicy.cc \
@@ -734,10 +734,7 @@ ServerStateData::handleMoreAdaptedBodyAvailable()
     if (!contentSize)
         return; // XXX: bytesWanted asserts on zero-size ranges
 
-    // XXX: entry->bytesWanted returns contentSize-1 if entry can accept data.
-    // We have to add 1 to avoid suspending forever.
-    const size_t bytesWanted = entry->bytesWanted(Range<size_t>(0, contentSize));
-    const size_t spaceAvailable = bytesWanted >  0 ? (bytesWanted + 1) : 0;
+    const size_t spaceAvailable = entry->bytesWanted(Range<size_t>(0, contentSize));
 
     if (spaceAvailable < contentSize ) {
         // No or partial body data consuming
@@ -747,8 +744,7 @@ ServerStateData::handleMoreAdaptedBodyAvailable()
         entry->deferProducer(call);
     }
 
-    // XXX: bytesWanted API does not allow us to write just one byte!
-    if (!spaceAvailable && contentSize > 1)  {
+    if (!spaceAvailable)  {
         debugs(11, 5, HERE << "NOT storing " << contentSize << " bytes of adapted " <<
                "response body at offset " << adaptedBodySource->consumedSize());
         return;
@@ -144,9 +144,9 @@ class StatCounters
     double cputime;
 
     struct timeval timestamp;
-    StatHist comm_icp_incoming;
+    StatHist comm_udp_incoming;
     StatHist comm_dns_incoming;
-    StatHist comm_http_incoming;
+    StatHist comm_tcp_incoming;
     StatHist select_fds_hist;
 
     struct {
@@ -62,16 +62,17 @@ StatHist::init(unsigned int newCapacity, hbase_f * val_in_, hbase_f * val_out_,
 void
 StatHist::clear()
 {
-    for (unsigned int i=0; i<capacity_; ++i)
-        bins[i]=0;
+    xfree(bins); // can handle case of bins being NULL
+    bins=NULL;
+    capacity_=0; // mark as destructed, may be needed for troubleshooting
 }
 
 StatHist::StatHist(const StatHist &src) :
         capacity_(src.capacity_), min_(src.min_), max_(src.max_),
         scale_(src.scale_), val_in(src.val_in), val_out(src.val_out)
 {
     if (src.bins!=NULL) {
-        bins = static_cast<bins_type *>(xcalloc(src.capacity_, sizeof(int)));
+        bins = static_cast<bins_type *>(xcalloc(src.capacity_, sizeof(bins_type)));
         memcpy(bins,src.bins,capacity_*sizeof(*bins));
     }
 }
@@ -57,7 +57,7 @@ class StatHist
      */
     StatHist();
     StatHist(const StatHist&); //not needed
-    ~StatHist();
+    ~StatHist() { clear(); };
 
     typedef uint64_t bins_type;
 
@@ -148,12 +148,4 @@ StatHist::StatHist() :
         scale_(1.0), val_in(NULL), val_out(NULL)
 {}
 
-inline
-StatHist::~StatHist()
-{
-    xfree(bins); //can handle case of bins being NULL
-    bins=NULL;
-    capacity_=0; //mark as destructed, may be needed for troubleshooting
-}
-
 #endif /* STATHIST_H_ */
@@ -240,7 +240,7 @@ class NullStoreEntry:public StoreEntry
 
     bool isEmpty () const {return true;}
 
-    virtual size_t bytesWanted(Range<size_t> const aRange) const { assert (aRange.size()); return aRange.end - 1;}
+    virtual size_t bytesWanted(Range<size_t> const aRange) const { return aRange.end; }
 
     void operator delete(void *address);
     void complete() {}
@@ -36,16 +36,53 @@
 #include "StoreSwapLogData.h"
 #include "swap_log_op.h"
 
-StoreSwapLogData::StoreSwapLogData(): op(0), swap_filen (0), timestamp (0), lastref (0), expires (0), lastmod(0), swap_file_sz (0), refcount (0), flags (0)
+// Based on Internet Checksum (RFC 1071) algorithm but takes three 32bit ints.
+// TODO: Consider Fletcher's checksum algorithm as a higher quality alternative
+void
+SwapChecksum24::set(uint32_t f1, uint32_t f2, uint32_t f3)
 {
-    memset (key, '\0', sizeof(key));
+    uint64_t sum = f1;
+    sum += f2;
+    sum += f3;
+
+    while (const uint64_t higherBits = sum >> 24)
+        sum = (sum & 0xFFFFFF) + higherBits;
+
+    sum = ~sum;
+
+    raw[0] = static_cast<uint8_t>(sum);
+    raw[1] = static_cast<uint8_t>(sum >> 8);
+    raw[2] = static_cast<uint8_t>(sum >> 16);
+}
+
+/// Same as 3-argument SwapChecksum24::set() but for int32_t and uint64_t
+void
+SwapChecksum24::set(int32_t f1, uint64_t f2)
+{
+    // split the second 64bit word into two 32bit words
+    set(static_cast<uint32_t>(f1),
+        static_cast<uint32_t>(f2 >> 32),
+        static_cast<uint32_t>(f2 & 0xFFFFFFFF));
+}
+
+std::ostream &
+SwapChecksum24::print(std::ostream &os) const
+{
+    return os << raw[0] << '-' << raw[1] << '-' << raw[2];
+}
+
+StoreSwapLogData::StoreSwapLogData()
+{
+    memset(this, 0, sizeof(*this));
 }
 
 bool
 StoreSwapLogData::sane() const
 {
-    // TODO: These checks are rather weak. A corrupted swap.state may still
-    // cause havoc (e.g., cur_size may become astronomical). Add checksums?
+    SwapChecksum24 actualSum;
+    actualSum.set(swap_filen, swap_file_sz);
+    if (checksum != actualSum)
+        return false;
 
     const time_t minTime = -2; // -1 is common; expires sometimes uses -2
 
@@ -59,7 +96,33 @@ StoreSwapLogData::sane() const
            swap_file_sz > 0; // because swap headers ought to consume space
 }
 
-StoreSwapLogHeader::StoreSwapLogHeader():op(SWAP_LOG_VERSION), version(1)
+void
+StoreSwapLogData::finalize()
+{
+    checksum.set(swap_filen, swap_file_sz);
+}
+
+StoreSwapLogHeader::StoreSwapLogHeader(): op(SWAP_LOG_VERSION), version(2),
+        record_size(sizeof(StoreSwapLogData))
+{
+    checksum.set(version, record_size, 0);
+}
+
+bool
+StoreSwapLogHeader::sane() const
+{
+    SwapChecksum24 actualSum;
+    actualSum.set(version, record_size, 0);
+    if (checksum != actualSum)
+        return false;
+
+    return op == SWAP_LOG_VERSION && version >= 2 && record_size > 0;
+}
+
+size_t
+StoreSwapLogHeader::gapSize() const
 {
-    record_size = sizeof(StoreSwapLogData);
+    assert(record_size > 0);
+    assert(static_cast<size_t>(record_size) > sizeof(*this));
+    return static_cast<size_t>(record_size) - sizeof(*this);
 }
@@ -61,20 +61,45 @@
 
 #include "squid-old.h"
 
-/*
- * Do we need to have the dirn in here? I don't think so, since we already
- * know the dirn ..
- */
+/// maintains a 24-bit checksum over integer fields
+class SwapChecksum24
+{
+public:
+    SwapChecksum24() { raw[0] = raw[1] = raw[2] = 0; }
+
+    bool operator ==(const SwapChecksum24 &o) const {
+        return raw[0] == o.raw[0] && raw[1] == o.raw[1] && raw[2] == o.raw[2];
+    }
+
+    bool operator !=(const SwapChecksum24 &o) const {
+        return !(*this == o);
+    }
+
+    /// compute and store checksum based on three 32bit integers
+    void set(uint32_t f1, uint32_t f2, uint32_t f3);
+
+    /// compute and store checksum based on int32_t and uint64_t integers
+    void set(int32_t f1, uint64_t f2);
+
+    // printing for debugging
+    std::ostream &print(std::ostream &os) const;
+
+private:
+    uint8_t raw[3]; // designed to follow "op" members, in pading space
+};
+
+inline std::ostream &
+operator <<(std::ostream &os, const SwapChecksum24 &sum)
+{
+    return sum.print(os);
+}
+
 /**
  \ingroup FielFormatSwapStateAPI
- \note This information is current as of version 2.2.STABLE4
- *
- \li		Binary format on disk.
- \li		DO NOT randomly alter.
- \li		DO NOT add ANY virtual's.
  *
  \par
- * Defines the structure of a binary swap.state file entry.
+ * Defines the structure of a binary swap.state file entry for UFS stores.
+ * TODO: Move to fs/ufs (and remove from COSS).
  *
  \note StoreSwapLogData entries are written in native machine byte order
  *     They are not necessarily portable across architectures.
@@ -84,16 +109,28 @@ class StoreSwapLogData
 
 public:
     MEMPROXY_CLASS(StoreSwapLogData);
+
+    /// type to use for storing time-related members; must be signed
+    typedef int64_t SwappedTime;
+
     StoreSwapLogData();
 
     /// consistency self-check: whether the data appears to make sense
     bool sane() const;
 
+    /// call this before storing the log entry
+    void finalize();
+
     /**
      * Either SWAP_LOG_ADD when an object is added to the disk storage,
      * or SWAP_LOG_DEL when an object is deleted.
      */
-    char op;
+    uint8_t op;
+
+    /**
+     * Fingerprint to weed out bogus/corrupted swap.state entries.
+     */
+    SwapChecksum24 checksum; // follows "op" because compiler will pad anyway
 
     /**
      * The 32-bit file number which maps to a pathname.
@@ -105,20 +142,20 @@ class StoreSwapLogData
     sfileno swap_filen;
 
     /**
-     * A 32-bit Unix time value that represents the time when
+     * A Unix time value that represents the time when
      * the origin server generated this response. If the response
      * has a valid Date: header, this timestamp corresponds
      * to that time. Otherwise, it is set to the Squid process time
      * when the response is read (as soon as the end of headers are found).
      */
-    time_t timestamp;
+    SwappedTime timestamp;
 
     /**
      * The last time that a client requested this object.
      * Strictly speaking, this time is set whenever the StoreEntry
      * is locked (via storeLockObject()).
      */
-    time_t lastref;
+    SwappedTime lastref;
 
     /**
      * The value of the response's Expires: header, if any.
@@ -129,14 +166,14 @@ class StoreSwapLogData
      * where Squid sets expires to -2. This happens for the
      * internal "netdb" object and for FTP URL responses.
      */
-    time_t expires;
+    SwappedTime expires;
 
     /**
      * The value of the response's Last-modified: header, if any.
      * This is set to -1 if there is no Last-modified: header,
      * or if it is unparseable.
      */
-    time_t lastmod;
+    SwappedTime lastmod;
 
     /**
      * This is the number of bytes that the object occupies on
@@ -167,13 +204,23 @@ class StoreSwapLogData
 MEMPROXY_CLASS_INLINE(StoreSwapLogData);
 
 /// \ingroup FileFormatSwapStateAPI
+/// Swap log starts with this binary structure.
 class StoreSwapLogHeader
 {
 public:
+    // sets default values for this Squid version; loaded values may differ
     StoreSwapLogHeader();
-    char op;
-    int version;
-    int record_size;
+
+    /// consistency self-check: whether the data appears to make sense
+    bool sane() const;
+
+    /// number of bytes after the log header before the first log entry
+    size_t gapSize() const;
+
+    uint8_t op;
+    SwapChecksum24 checksum; // follows "op" because compiler will pad anyway
+    int32_t version;
+    int32_t record_size;
 };
 
 
@@ -37,7 +37,7 @@
 #include "ConfigParser.h"
 #include "Debug.h"
 #include "dlink.h"
-#include "ProtoPort.h"
+#include "anyp/PortCfg.h"
 
 const char *AclMatchedName = NULL;
 
@@ -123,7 +123,7 @@ ACL::ParseAclLine(ConfigParser &parser, ACL ** head)
 
     // Is this ACL going to work?
     if (strcmp(theType, "myip") == 0) {
-        http_port_list *p = Config.Sockaddr.http;
+        AnyP::PortCfg *p = Config.Sockaddr.http;
         while (p) {
             // Bug 3239: not reliable when there is interception traffic coming
             if (p->intercepted)
@@ -133,7 +133,7 @@ ACL::ParseAclLine(ConfigParser &parser, ACL ** head)
         debugs(28, DBG_IMPORTANT, "UPGRADE: ACL 'myip' type is has been renamed to 'localip' and matches the IP the client connected to.");
         theType = "localip";
     } else if (strcmp(theType, "myport") == 0) {
-        http_port_list *p = Config.Sockaddr.http;
+        AnyP::PortCfg *p = Config.Sockaddr.http;
         while (p) {
             // Bug 3239: not reliable when there is interception traffic coming
             // Bug 3239: myport - not reliable (yet) when there is interception traffic coming
@@ -116,8 +116,6 @@ typedef enum {
 
     // Authentication ACL result states
     ACCESS_AUTH_REQUIRED,    // Missing Credentials
-    ACCESS_AUTH_EXPIRED_OK,  // Expired now. Were Okay.
-    ACCESS_AUTH_EXPIRED_BAD  // Expired now. Were Failed.
 } aclMatchCode;
 
 /// \ingroup ACLAPI
@@ -145,7 +143,6 @@ class allow_t {
     int kind; ///< which custom access list verb matched
 };
 
-
 inline std::ostream &
 operator <<(std::ostream &o, const allow_t a)
 {
@@ -162,12 +159,6 @@ operator <<(std::ostream &o, const allow_t a)
     case ACCESS_AUTH_REQUIRED:
         o << "AUTH_REQUIRED";
         break;
-    case ACCESS_AUTH_EXPIRED_OK:
-        o << "AUTH_EXPIRED_OK";
-        break;
-    case ACCESS_AUTH_EXPIRED_BAD:
-        o << "AUTH_EXPIRED_BAD";
-        break;
     }
     return o;
 }
@@ -34,10 +34,10 @@
  */
 
 #include "squid-old.h"
-#include "ProtoPort.h"
 #include "acl/MyPortName.h"
 #include "acl/StringData.h"
 #include "acl/Checklist.h"
+#include "anyp/PortCfg.h"
 #include "HttpRequest.h"
 
 /* for ConnStateData */
@@ -4,6 +4,8 @@ include $(top_srcdir)/src/TestHeaders.am
 noinst_LTLIBRARIES = libanyp.la
 
 libanyp_la_SOURCES = \
+	PortCfg.cc \
+	PortCfg.h \
 	ProtocolType.cc \
 	ProtocolType.h \
 	ProtocolVersion.h
@@ -1,14 +1,19 @@
 #include "squid.h"
+#include "anyp/PortCfg.h"
 #include "comm.h"
-#include "ProtoPort.h"
 #if HAVE_LIMITS
 #include <limits>
 #endif
 #if USE_SSL
 #include "ssl/support.h"
 #endif
 
-http_port_list::http_port_list(const char *aProtocol)
+CBDATA_NAMESPACED_CLASS_INIT(AnyP, PortCfg);
+
+int NHttpSockets = 0;
+int HttpSockets[MAXTCPLISTENPORTS];
+
+AnyP::PortCfg::PortCfg(const char *aProtocol)
 #if USE_SSL
         :
         dynamicCertMemCacheSize(std::numeric_limits<size_t>::max())
@@ -17,7 +22,7 @@ http_port_list::http_port_list(const char *aProtocol)
     protocol = xstrdup(aProtocol);
 }
 
-http_port_list::~http_port_list()
+AnyP::PortCfg::~PortCfg()
 {
     if (Comm::IsConnOpen(listenConn)) {
         listenConn->close();
@@ -41,8 +46,55 @@ http_port_list::~http_port_list()
 #endif
 }
 
+AnyP::PortCfg *
+AnyP::PortCfg::clone() const
+{
+    AnyP::PortCfg *b = new AnyP::PortCfg(protocol);
+
+    b->s = s;
+    if (name)
+        b->name = xstrdup(name);
+    if (defaultsite)
+        b->defaultsite = xstrdup(defaultsite);
+
+    b->intercepted = intercepted;
+    b->spoof_client_ip = spoof_client_ip;
+    b->accel = accel;
+    b->allow_direct = allow_direct;
+    b->vhost = vhost;
+    b->sslBump = sslBump;
+    b->vport = vport;
+    b->connection_auth_disabled = connection_auth_disabled;
+    b->disable_pmtu_discovery = disable_pmtu_discovery;
+
+    memcpy( &(b->tcp_keepalive), &(tcp_keepalive), sizeof(tcp_keepalive));
+
+#if 0
+    // AYJ: 2009-07-18: for now SSL does not clone. Configure separate ports with IPs and SSL settings
+
 #if USE_SSL
-void http_port_list::configureSslServerContext()
+    char *cert;
+    char *key;
+    int version;
+    char *cipher;
+    char *options;
+    char *clientca;
+    char *cafile;
+    char *capath;
+    char *crlfile;
+    char *dhfile;
+    char *sslflags;
+    char *sslContextSessionId;
+    SSL_CTX *sslContext;
+#endif
+
+#endif /*0*/
+
+    return b;
+}
+
+#if USE_SSL
+void AnyP::PortCfg::configureSslServerContext()
 {
     staticSslContext.reset(
         sslCreateServerContext(cert, key,
@@ -78,3 +130,4 @@ void http_port_list::configureSslServerContext()
     }
 }
 #endif
+
@@ -1,9 +1,5 @@
-/*
- * $Id$
- */
-
-#ifndef SQUID_PROTO_PORT_H
-#define SQUID_PROTO_PORT_H
+#ifndef SQUID_ANYP_PORTCFG_H
+#define SQUID_ANYP_PORTCFG_H
 
 #include "cbdata.h"
 #include "comm/Connection.h"
@@ -12,14 +8,18 @@
 #include "ssl/gadgets.h"
 #endif
 
-struct http_port_list {
-    http_port_list(const char *aProtocol);
-    ~http_port_list();
+namespace AnyP
+{
+
+struct PortCfg {
+    PortCfg(const char *aProtocol);
+    ~PortCfg();
+    AnyP::PortCfg *clone() const;
 #if USE_SSL
     void configureSslServerContext();
 #endif
 
-    http_port_list *next;
+    PortCfg *next;
 
     Ip::Address s;
     char *protocol;            /* protocol name */
@@ -77,7 +77,16 @@ struct http_port_list {
     Ssl::EVP_PKEY_Pointer untrustedSignPkey; ///< private key for signing untrusted generated certificates
 #endif
 
-    CBDATA_CLASS2(http_port_list);
+    CBDATA_CLASS2(PortCfg); // namespaced
 };
 
-#endif /* SQUID_PROTO_PORT_H */
+} // namespace AnyP
+
+// Max number of TCP listening ports
+#define MAXTCPLISTENPORTS 128
+
+// TODO: kill this global array. Need to check performance of array vs list though.
+extern int NHttpSockets;
+extern int HttpSockets[MAXTCPLISTENPORTS];
+
+#endif /* SQUID_ANYP_PORTCFG_H */
@@ -163,14 +163,12 @@ ACLMaxUserIP::match(ACLChecklist *cl)
     // convert to tri-state ACL match 1,0,-1
     switch (answer) {
     case ACCESS_ALLOWED:
-    case ACCESS_AUTH_EXPIRED_OK:
         // check for a match
         ti = match(checklist->auth_user_request, checklist->src_addr);
         checklist->auth_user_request = NULL;
         return ti;
 
     case ACCESS_DENIED:
-    case ACCESS_AUTH_EXPIRED_BAD:
         return 0; // non-match
 
     case ACCESS_DUNNO:
@@ -90,12 +90,10 @@ ACLProxyAuth::match(ACLChecklist *checklist)
     // convert to tri-state ACL match 1,0,-1
     switch (answer) {
     case ACCESS_ALLOWED:
-    case ACCESS_AUTH_EXPIRED_OK:
         // check for a match
         return matchProxyAuth(checklist);
 
     case ACCESS_DENIED:
-    case ACCESS_AUTH_EXPIRED_BAD:
         return 0; // non-match
 
     case ACCESS_DUNNO:
@@ -46,6 +46,7 @@
 #if USE_ECAP
 #include "adaptation/ecap/Config.h"
 #endif
+#include "anyp/PortCfg.h"
 #if USE_SSL
 #include "ssl/support.h"
 #include "ssl/Config.h"
@@ -71,7 +72,6 @@
 #include "MemBuf.h"
 #include "mgr/Registration.h"
 #include "Parsing.h"
-#include "ProtoPort.h"
 #include "rfc1738.h"
 #if SQUID_SNMP
 #include "snmp.h"
@@ -190,16 +190,12 @@ static int check_null_IpAddress_list(const Ip::Address_list *);
 #endif /* CURRENTLY_UNUSED */
 #endif /* USE_WCCPv2 */
 
-static void parsePortList(http_port_list **, const char *protocol);
-#define parse_http_port_list(l) parsePortList((l),"http")
-static void dump_http_port_list(StoreEntry *, const char *, const http_port_list *);
-static void free_http_port_list(http_port_list **);
+static void parsePortCfg(AnyP::PortCfg **, const char *protocol);
+#define parse_PortCfg(l) parsePortCfg((l), token)
+static void dump_PortCfg(StoreEntry *, const char *, const AnyP::PortCfg *);
+static void free_PortCfg(AnyP::PortCfg **);
 
 #if USE_SSL
-#define parse_https_port_list(l) parsePortList((l),"https")
-#define dump_https_port_list(e,n,l) dump_http_port_list((e),(n),(l))
-#define free_https_port_list(l) free_http_port_list((l))
-#define check_null_https_port_list(l) check_null_http_port_list((l))
 static void parse_sslproxy_cert_sign(sslproxy_cert_sign **cert_sign);
 static void dump_sslproxy_cert_sign(StoreEntry *entry, const char *name, sslproxy_cert_sign *cert_sign);
 static void free_sslproxy_cert_sign(sslproxy_cert_sign **cert_sign);
@@ -892,39 +888,24 @@ configDoConfigure(void)
 
     Config.ssl_client.sslContext = sslCreateClientContext(Config.ssl_client.cert, Config.ssl_client.key, Config.ssl_client.version, Config.ssl_client.cipher, Config.ssl_client.options, Config.ssl_client.flags, Config.ssl_client.cafile, Config.ssl_client.capath, Config.ssl_client.crlfile);
 
-    {
-
-        peer *p;
-
-        for (p = Config.peers; p != NULL; p = p->next) {
-            if (p->use_ssl) {
-                debugs(3, 1, "Initializing cache_peer " << p->name << " SSL context");
-                p->sslContext = sslCreateClientContext(p->sslcert, p->sslkey, p->sslversion, p->sslcipher, p->ssloptions, p->sslflags, p->sslcafile, p->sslcapath, p->sslcrlfile);
-            }
+    for (peer *p = Config.peers; p != NULL; p = p->next) {
+        if (p->use_ssl) {
+            debugs(3, 1, "Initializing cache_peer " << p->name << " SSL context");
+            p->sslContext = sslCreateClientContext(p->sslcert, p->sslkey, p->sslversion, p->sslcipher, p->ssloptions, p->sslflags, p->sslcafile, p->sslcapath, p->sslcrlfile);
         }
     }
 
-    {
-
-        http_port_list *s;
-
-        for (s = Config.Sockaddr.http; s != NULL; s = (http_port_list *) s->next) {
-            if (!s->sslBump)
-                continue;
+    for (AnyP::PortCfg *s = Config.Sockaddr.http; s != NULL; s = s->next) {
+        if (!s->sslBump)
+            continue;
 
-            debugs(3, 1, "Initializing http_port " << s->s << " SSL context");
-            s->configureSslServerContext();
-        }
+        debugs(3, 1, "Initializing http_port " << s->s << " SSL context");
+        s->configureSslServerContext();
     }
 
-    {
-
-        http_port_list *s;
-
-        for (s = Config.Sockaddr.https; s != NULL; s = s->next) {
-            debugs(3, 1, "Initializing https_port " << s->s << " SSL context");
-            s->configureSslServerContext();
-        }
+    for (AnyP::PortCfg *s = Config.Sockaddr.https; s != NULL; s = s->next) {
+        debugs(3, 1, "Initializing https_port " << s->s << " SSL context");
+        s->configureSslServerContext();
     }
 
 #endif
@@ -3511,10 +3492,8 @@ check_null_IpAddress_list(const Ip::Address_list * s)
 #endif /* CURRENTLY_UNUSED */
 #endif /* USE_WCCPv2 */
 
-CBDATA_CLASS_INIT(http_port_list);
-
 static void
-parsePortSpecification(http_port_list * s, char *token)
+parsePortSpecification(AnyP::PortCfg * s, char *token)
 {
     char *host = NULL;
     unsigned short port = 0;
@@ -3588,7 +3567,7 @@ parsePortSpecification(http_port_list * s, char *token)
 }
 
 static void
-parse_http_port_option(http_port_list * s, char *token)
+parse_port_option(AnyP::PortCfg * s, char *token)
 {
     /* modes first */
 
@@ -3789,66 +3768,16 @@ parse_http_port_option(http_port_list * s, char *token)
 void
 add_http_port(char *portspec)
 {
-    http_port_list *s = new http_port_list("http");
+    AnyP::PortCfg *s = new AnyP::PortCfg("http_port");
     parsePortSpecification(s, portspec);
-    // we may need to merge better of the above returns a list with clones
+    // we may need to merge better if the above returns a list with clones
     assert(s->next == NULL);
     s->next = Config.Sockaddr.http;
     Config.Sockaddr.http = s;
 }
 
-http_port_list *
-clone_http_port_list(http_port_list *a)
-{
-    http_port_list *b = new http_port_list(a->protocol);
-
-    b->s = a->s;
-    if (a->name)
-        b->name = xstrdup(a->name);
-    if (a->defaultsite)
-        b->defaultsite = xstrdup(a->defaultsite);
-
-    b->intercepted = a->intercepted;
-    b->spoof_client_ip = a->spoof_client_ip;
-    b->accel = a->accel;
-    b->allow_direct = a->allow_direct;
-    b->vhost = a->vhost;
-    b->sslBump = a->sslBump;
-    b->vport = a->vport;
-    b->connection_auth_disabled = a->connection_auth_disabled;
-    b->disable_pmtu_discovery = a->disable_pmtu_discovery;
-
-    memcpy( &(b->tcp_keepalive), &(a->tcp_keepalive), sizeof(a->tcp_keepalive));
-
-#if 0
-    // AYJ: 2009-07-18: for now SSL does not clone. Configure separate ports with IPs and SSL settings
-
-#if USE_SSL
-    // XXX: temporary hack to ease move of SSL options to http_port
-    http_port_list &http;
-
-    char *cert;
-    char *key;
-    int version;
-    char *cipher;
-    char *options;
-    char *clientca;
-    char *cafile;
-    char *capath;
-    char *crlfile;
-    char *dhfile;
-    char *sslflags;
-    char *sslContextSessionId;
-    SSL_CTX *sslContext;
-#endif
-
-#endif /*0*/
-
-    return b;
-}
-
 static void
-parsePortList(http_port_list ** head, const char *protocol)
+parsePortCfg(AnyP::PortCfg ** head, const char *protocol)
 {
     char *token = strtok(NULL, w_space);
 
@@ -3857,12 +3786,12 @@ parsePortList(http_port_list ** head, const char *protocol)
         return;
     }
 
-    http_port_list *s = new http_port_list(protocol);
+    AnyP::PortCfg *s = new AnyP::PortCfg(protocol);
     parsePortSpecification(s, token);
 
     /* parse options ... */
     while ((token = strtok(NULL, w_space))) {
-        parse_http_port_option(s, token);
+        parse_port_option(s, token);
     }
 
 #if USE_SSL
@@ -3882,7 +3811,7 @@ parsePortList(http_port_list ** head, const char *protocol)
 
     if (Ip::EnableIpv6&IPV6_SPECIAL_SPLITSTACK && s->s.IsAnyAddr()) {
         // clone the port options from *s to *(s->next)
-        s->next = clone_http_port_list(s);
+        s->next = s->clone();
         s->next->s.SetIPv4();
         debugs(3, 3, protocol << "_port: clone wildcard address for split-stack: " << s->s << " and " << s->next->s);
     }
@@ -3894,7 +3823,7 @@ parsePortList(http_port_list ** head, const char *protocol)
 }
 
 static void
-dump_generic_http_port(StoreEntry * e, const char *n, const http_port_list * s)
+dump_generic_port(StoreEntry * e, const char *n, const AnyP::PortCfg * s)
 {
     char buf[MAX_IPSTRLEN];
 
@@ -4017,19 +3946,19 @@ dump_generic_http_port(StoreEntry * e, const char *n, const http_port_list * s)
 }
 
 static void
-dump_http_port_list(StoreEntry * e, const char *n, const http_port_list * s)
+dump_PortCfg(StoreEntry * e, const char *n, const AnyP::PortCfg * s)
 {
     while (s) {
-        dump_generic_http_port(e, n, s);
+        dump_generic_port(e, n, s);
         storeAppendPrintf(e, "\n");
         s = s->next;
     }
 }
 
 static void
-free_http_port_list(http_port_list ** head)
+free_PortCfg(AnyP::PortCfg ** head)
 {
-    http_port_list *s;
+    AnyP::PortCfg *s;
 
     while ((s = *head) != NULL) {
         *head = s->next;
@@ -31,8 +31,6 @@ hostdomain		cache_peer
 hostdomaintype		cache_peer
 http_header_access	acl
 http_header_replace
-http_port_list
-https_port_list
 adaptation_access_type	adaptation_service_set adaptation_service_chain acl icap_service icap_class
 adaptation_service_set_type	icap_service ecap_service
 adaptation_service_chain_type	icap_service ecap_service
@@ -52,6 +50,7 @@ obsolete
 onoff
 peer
 peer_access		cache_peer acl
+PortCfg
 QosConfig
 refreshpattern
 removalpolicy
@@ -1310,7 +1310,7 @@ COMMENT_START
 COMMENT_END
 
 NAME: http_port ascii_port
-TYPE: http_port_list
+TYPE: PortCfg
 DEFAULT: none
 LOC: Config.Sockaddr.http
 DOC_START
@@ -1433,7 +1433,9 @@ DOC_START
 			    1	automatic (default)
 			    2	SSLv2 only
 			    3	SSLv3 only
-			    4	TLSv1 only
+			    4	TLSv1.0 only
+			    5	TLSv1.1 only
+			    6	TLSv1.2 only
 
 	   cipher=	Colon separated list of supported ciphers.
 			NOTE: some ciphers such as EDH ciphers depend on
@@ -1443,9 +1445,11 @@ DOC_START
 
 	   options=	Various SSL implementation options. The most important
 			being:
-			    NO_SSLv2  Disallow the use of SSLv2
-			    NO_SSLv3  Disallow the use of SSLv3
-			    NO_TLSv1  Disallow the use of TLSv1
+			    NO_SSLv2    Disallow the use of SSLv2
+			    NO_SSLv3    Disallow the use of SSLv3
+			    NO_TLSv1    Disallow the use of TLSv1.0
+			    NO_TLSv1_1  Disallow the use of TLSv1.1
+			    NO_TLSv1_2  Disallow the use of TLSv1.2
 			    SINGLE_DH_USE Always create a new key when using
 				      temporary/ephemeral DH key exchanges
 			    ALL       Enable various bug workarounds
@@ -1541,7 +1545,7 @@ DOC_END
 
 NAME: https_port
 IFDEF: USE_SSL
-TYPE: https_port_list
+TYPE: PortCfg
 DEFAULT: none
 LOC: Config.Sockaddr.https
 DOC_START
@@ -2005,6 +2009,15 @@ LOC: Config.ssl_client.version
 TYPE: int
 DOC_START
 	SSL version level to use when proxying https:// URLs
+
+	The versions of SSL/TLS supported:
+
+	    1	automatic (default)
+	    2	SSLv2 only
+	    3	SSLv3 only
+	    4	TLSv1.0 only
+	    5	TLSv1.1 only
+	    6	TLSv1.2 only
 DOC_END
 
 NAME: sslproxy_options
@@ -2017,9 +2030,11 @@ DOC_START
 	
 	The most important being:
 
-	    NO_SSLv2  Disallow the use of SSLv2
-	    NO_SSLv3  Disallow the use of SSLv3
-	    NO_TLSv1  Disallow the use of TLSv1
+	    NO_SSLv2    Disallow the use of SSLv2
+	    NO_SSLv3    Disallow the use of SSLv3
+	    NO_TLSv1    Disallow the use of TLSv1.0
+	    NO_TLSv1_1  Disallow the use of TLSv1.1
+	    NO_TLSv1_2  Disallow the use of TLSv1.2
 	    SINGLE_DH_USE
 		      Always create a new key when using temporary/ephemeral
 		      DH key exchanges
@@ -2146,11 +2161,11 @@ DOC_START
 	Use this ACL to bypass server certificate validation errors.
 
 	For example, the following lines will bypass all validation errors
-	when talking to servers located at 172.16.0.0/16. All other
+	when talking to servers for example.com. All other
 	validation errors will result in ERR_SECURE_CONNECT_FAIL error.
 
-		acl BrokenServersAtTrustedIP dst 172.16.0.0/16
-		sslproxy_cert_error allow BrokenServersAtTrustedIP
+		acl BrokenButTrustedServers dstdomain example.com
+		sslproxy_cert_error allow BrokenButTrustedServers
 		sslproxy_cert_error deny all
 
 	This clause only supports fast acl types.
@@ -2581,21 +2596,25 @@ DOC_START
 			reference a combined file containing both the
 			certificate and the key.
 	
-	sslversion=1|2|3|4
+	sslversion=1|2|3|4|5|6
 			The SSL version to use when connecting to this peer
 				1 = automatic (default)
 				2 = SSL v2 only
 				3 = SSL v3 only
-				4 = TLS v1 only
+				4 = TLS v1.0 only
+				5 = TLS v1.1 only
+				6 = TLS v1.2 only
 	
 	sslcipher=...	The list of valid SSL ciphers to use when connecting
 			to this peer.
 	
 	ssloptions=... 	Specify various SSL implementation options:
 
-			    NO_SSLv2  Disallow the use of SSLv2
-			    NO_SSLv3  Disallow the use of SSLv3
-			    NO_TLSv1  Disallow the use of TLSv1
+			    NO_SSLv2    Disallow the use of SSLv2
+			    NO_SSLv3    Disallow the use of SSLv3
+			    NO_TLSv1    Disallow the use of TLSv1.0
+			    NO_TLSv1_1  Disallow the use of TLSv1.1
+			    NO_TLSv1_2  Disallow the use of TLSv1.2
 			    SINGLE_DH_USE
 				      Always create a new key when using
 				      temporary/ephemeral DH key exchanges
@@ -6557,40 +6576,60 @@ COMMENT_START
  -----------------------------------------------------------------------------
 COMMENT_END
 
-NAME: incoming_icp_average
+NAME: incoming_udp_average incoming_icp_average
 TYPE: int
 DEFAULT: 6
-LOC: Config.comm_incoming.icp_average
-DOC_NONE
+LOC: Config.comm_incoming.udp.average
+DOC_START
+	Heavy voodoo here.  I can't even believe you are reading this.
+	Are you crazy?  Don't even think about adjusting these unless
+	you understand the algorithms in comm_select.c first!
+DOC_END
 
-NAME: incoming_http_average
+NAME: incoming_tcp_average  incoming_http_average
 TYPE: int
 DEFAULT: 4
-LOC: Config.comm_incoming.http_average
-DOC_NONE
+LOC: Config.comm_incoming.tcp.average
+DOC_START
+	Heavy voodoo here.  I can't even believe you are reading this.
+	Are you crazy?  Don't even think about adjusting these unless
+	you understand the algorithms in comm_select.c first!
+DOC_END
 
 NAME: incoming_dns_average
 TYPE: int
 DEFAULT: 4
-LOC: Config.comm_incoming.dns_average
-DOC_NONE
+LOC: Config.comm_incoming.dns.average
+DOC_START
+	Heavy voodoo here.  I can't even believe you are reading this.
+	Are you crazy?  Don't even think about adjusting these unless
+	you understand the algorithms in comm_select.c first!
+DOC_END
 
-NAME: min_icp_poll_cnt
+NAME: min_udp_poll_cnt min_icp_poll_cnt
 TYPE: int
 DEFAULT: 8
-LOC: Config.comm_incoming.icp_min_poll
-DOC_NONE
+LOC: Config.comm_incoming.udp.min_poll
+DOC_START
+	Heavy voodoo here.  I can't even believe you are reading this.
+	Are you crazy?  Don't even think about adjusting these unless
+	you understand the algorithms in comm_select.c first!
+DOC_END
 
 NAME: min_dns_poll_cnt
 TYPE: int
 DEFAULT: 8
-LOC: Config.comm_incoming.dns_min_poll
-DOC_NONE
+LOC: Config.comm_incoming.dns.min_poll
+DOC_START
+	Heavy voodoo here.  I can't even believe you are reading this.
+	Are you crazy?  Don't even think about adjusting these unless
+	you understand the algorithms in comm_select.c first!
+DOC_END
 
-NAME: min_http_poll_cnt
+NAME: min_tcp_poll_cnt min_http_poll_cnt
 TYPE: int
 DEFAULT: 8
-LOC: Config.comm_incoming.http_min_poll
+LOC: Config.comm_incoming.tcp.min_poll
 DOC_START
 	Heavy voodoo here.  I can't even believe you are reading this.
 	Are you crazy?  Don't even think about adjusting these unless
@@ -87,6 +87,7 @@
 #if USE_AUTH
 #include "auth/UserRequest.h"
 #endif
+#include "anyp/PortCfg.h"
 #include "base/Subscription.h"
 #include "base/TextException.h"
 #include "ChunkedCodingParser.h"
@@ -117,7 +118,6 @@
 #include "ipc/StartListening.h"
 #include "MemBuf.h"
 #include "MemObject.h"
-#include "ProtoPort.h"
 #include "rfc1738.h"
 #include "StatCounters.h"
 #include "StatHist.h"
@@ -148,8 +148,8 @@
 class ListeningStartedDialer: public CallDialer, public Ipc::StartListeningCb
 {
 public:
-    typedef void (*Handler)(http_port_list *portCfg, const Ipc::FdNoteId note, const Subscription::Pointer &sub);
-    ListeningStartedDialer(Handler aHandler, http_port_list *aPortCfg, const Ipc::FdNoteId note, const Subscription::Pointer &aSub):
+    typedef void (*Handler)(AnyP::PortCfg *portCfg, const Ipc::FdNoteId note, const Subscription::Pointer &sub);
+    ListeningStartedDialer(Handler aHandler, AnyP::PortCfg *aPortCfg, const Ipc::FdNoteId note, const Subscription::Pointer &aSub):
             handler(aHandler), portCfg(aPortCfg), portTypeNote(note), sub(aSub) {}
 
     virtual void print(std::ostream &os) const {
@@ -164,12 +164,12 @@ class ListeningStartedDialer: public CallDialer, public Ipc::StartListeningCb
     Handler handler;
 
 private:
-    http_port_list *portCfg;   ///< from Config.Sockaddr.http
+    AnyP::PortCfg *portCfg;   ///< from Config.Sockaddr.http
     Ipc::FdNoteId portTypeNote;    ///< Type of IPC socket being opened
     Subscription::Pointer sub; ///< The handler to be subscribed for this connetion listener
 };
 
-static void clientListenerConnectionOpened(http_port_list *s, const Ipc::FdNoteId portTypeNote, const Subscription::Pointer &sub);
+static void clientListenerConnectionOpened(AnyP::PortCfg *s, const Ipc::FdNoteId portTypeNote, const Subscription::Pointer &sub);
 
 /* our socket-related context */
 
@@ -228,7 +228,7 @@ static void clientUpdateSocketStats(log_type logType, size_t size);
 char *skipLeadingSpace(char *aString);
 static void connNoteUseOfBuffer(ConnStateData* conn, size_t byteCount);
 
-static ConnStateData *connStateCreate(const Comm::ConnectionPointer &client, http_port_list *port);
+static ConnStateData *connStateCreate(const Comm::ConnectionPointer &client, AnyP::PortCfg *port);
 
 
 clientStreamNode *
@@ -3250,7 +3250,7 @@ clientLifetimeTimeout(const CommTimeoutCbParams &io)
 }
 
 ConnStateData *
-connStateCreate(const Comm::ConnectionPointer &client, http_port_list *port)
+connStateCreate(const Comm::ConnectionPointer &client, AnyP::PortCfg *port)
 {
     ConnStateData *result = new ConnStateData;
 
@@ -3312,7 +3312,7 @@ connStateCreate(const Comm::ConnectionPointer &client, http_port_list *port)
 void
 httpAccept(const CommAcceptCbParams &params)
 {
-    http_port_list *s = (http_port_list *)params.data;
+    AnyP::PortCfg *s = static_cast<AnyP::PortCfg *>(params.data);
 
     if (params.flag != COMM_OK) {
         // Its possible the call was still queued when the client disconnected
@@ -3610,7 +3610,7 @@ httpsSslBumpAccessCheckDone(allow_t answer, void *data)
 static void
 httpsAccept(const CommAcceptCbParams &params)
 {
-    http_port_list *s = (http_port_list *)params.data;
+    AnyP::PortCfg *s = static_cast<AnyP::PortCfg *>(params.data);
 
     if (params.flag != COMM_OK) {
         // Its possible the call was still queued when the client disconnected
@@ -3979,12 +3979,12 @@ AddOpenedHttpSocket(const Comm::ConnectionPointer &conn)
 static void
 clientHttpConnectionsOpen(void)
 {
-    http_port_list *s = NULL;
+    AnyP::PortCfg *s = NULL;
 
     for (s = Config.Sockaddr.http; s; s = s->next) {
-        if (MAXHTTPPORTS == NHttpSockets) {
+        if (MAXTCPLISTENPORTS == NHttpSockets) {
             debugs(1, 1, "WARNING: You have too many 'http_port' lines.");
-            debugs(1, 1, "         The limit is " << MAXHTTPPORTS);
+            debugs(1, 1, "         The limit is " << MAXTCPLISTENPORTS << " HTTP ports.");
             continue;
         }
 
@@ -4027,12 +4027,12 @@ clientHttpConnectionsOpen(void)
 static void
 clientHttpsConnectionsOpen(void)
 {
-    http_port_list *s;
+    AnyP::PortCfg *s;
 
     for (s = Config.Sockaddr.https; s; s = s->next) {
-        if (MAXHTTPPORTS == NHttpSockets) {
+        if (MAXTCPLISTENPORTS == NHttpSockets) {
             debugs(1, 1, "Ignoring 'https_port' lines exceeding the limit.");
-            debugs(1, 1, "The limit is " << MAXHTTPPORTS << " HTTPS ports.");
+            debugs(1, 1, "The limit is " << MAXTCPLISTENPORTS << " HTTPS ports.");
             continue;
         }
 
@@ -4080,7 +4080,7 @@ clientHttpsConnectionsOpen(void)
 
 /// process clientHttpConnectionsOpen result
 static void
-clientListenerConnectionOpened(http_port_list *s, const Ipc::FdNoteId portTypeNote, const Subscription::Pointer &sub)
+clientListenerConnectionOpened(AnyP::PortCfg *s, const Ipc::FdNoteId portTypeNote, const Subscription::Pointer &sub)
 {
     if (!OpenedHttpSocket(s->listenConn, portTypeNote))
         return;
@@ -4117,7 +4117,7 @@ clientOpenListenSockets(void)
 void
 clientHttpConnectionsClose(void)
 {
-    for (http_port_list *s = Config.Sockaddr.http; s; s = s->next) {
+    for (AnyP::PortCfg *s = Config.Sockaddr.http; s; s = s->next) {
         if (s->listenConn != NULL) {
             debugs(1, 1, "Closing HTTP port " << s->listenConn->local);
             s->listenConn->close();
@@ -4126,7 +4126,7 @@ clientHttpConnectionsClose(void)
     }
 
 #if USE_SSL
-    for (http_port_list *s = Config.Sockaddr.https; s; s = s->next) {
+    for (AnyP::PortCfg *s = Config.Sockaddr.https; s; s = s->next) {
         if (s->listenConn != NULL) {
             debugs(1, 1, "Closing HTTPS port " << s->listenConn->local);
             s->listenConn->close();
@@ -261,7 +261,7 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
         AsyncCall::Pointer closeHandler; /*The close handler for pinned server side connection*/
     } pinning;
 
-    http_port_list *port;
+    AnyP::PortCfg *port;
 
     bool transparent() const;
     bool reading() const;
@@ -40,6 +40,7 @@
 #include "squid-old.h"
 #include "acl/FilledChecklist.h"
 #include "acl/Gadgets.h"
+#include "anyp/PortCfg.h"
 #if USE_AUTH
 #include "auth/UserRequest.h"
 #endif
@@ -61,7 +62,6 @@
 #include "ip/QosConfig.h"
 #include "ipcache.h"
 #include "MemObject.h"
-#include "ProtoPort.h"
 #include "SquidTime.h"
 #include "StoreClient.h"
 #include "Store.h"
@@ -664,11 +664,7 @@ clientReplyContext::processMiss()
 
         if (http->redirect.status) {
             HttpReply *rep = new HttpReply;
-#if LOG_TCP_REDIRECTS
-
             http->logType = LOG_TCP_REDIRECT;
-#endif
-
             http->storeEntry()->releaseRequest();
             rep->redirect(http->redirect.status, http->redirect.location);
             http->storeEntry()->replaceHttpReply(rep);
@@ -1633,9 +1629,9 @@ clientReplyContext::identifyFoundObject(StoreEntry *newEntry)
 
     if (http->redirect.status) {
         /** \li If redirection status is True force this to be a MISS */
-        debugs(85, 3, "clientProcessRequest2: redirectStatus forced StoreEntry to NULL -  MISS");
+        debugs(85, 3, HERE << "REDIRECT status forced StoreEntry to NULL (no body on 3XX responses)");
         http->storeEntry(NULL);
-        http->logType = LOG_TCP_MISS;
+        http->logType = LOG_TCP_REDIRECT;
         doGetMoreData();
         return;
     }
@@ -54,6 +54,7 @@
 #include "adaptation/icap/History.h"
 #endif
 #endif
+#include "anyp/PortCfg.h"
 #if USE_AUTH
 #include "auth/UserRequest.h"
 #endif
@@ -73,7 +74,6 @@
 #include "HttpRequest.h"
 #include "ip/QosConfig.h"
 #include "MemObject.h"
-#include "ProtoPort.h"
 #include "Store.h"
 #include "SquidTime.h"
 #include "wordlist.h"
@@ -545,6 +545,7 @@ ClientRequestContext::hostHeaderIpVerify(const ipcache_addrs* ia, const DnsLooku
         for (int i = 0; i < ia->count; i++) {
             if (clientConn->local.matchIPAddr(ia->in_addrs[i]) == 0) {
                 debugs(85, 3, HERE << "validate IP " << clientConn->local << " possible from Host:");
+                http->request->flags.hostVerified = 1;
                 http->doCallouts();
                 return;
             }
@@ -570,6 +571,7 @@ ClientRequestContext::hostHeaderVerifyFailed(const char *A, const char *B)
         // XXX: when we have updated the cache key to base on raw-IP + URI this cacheable limit can go.
         http->request->flags.hierarchical = 0; // MUST NOT pass to peers (for now)
         // XXX: when we have sorted out the best way to relay requests properly to peers this hierarchical limit can go.
+        http->doCallouts();
         return;
     }
 
@@ -743,12 +745,17 @@ clientAccessCheckDoneWrapper(allow_t answer, void *data)
     calloutContext->clientAccessCheckDone(answer);
 }
 
-bool
-ClientRequestContext::maybeSendAuthChallenge(const allow_t &answer)
+void
+ClientRequestContext::clientAccessCheckDone(const allow_t &answer)
 {
     acl_checklist = NULL;
     err_type page_id;
     http_status status;
+    debugs(85, 2, "The request " <<
+           RequestMethodStr(http->request->method) << " " <<
+           http->uri << " is " << answer <<
+           ", because it matched '" <<
+           (AclMatchedName ? AclMatchedName : "NO ACL's") << "'" );
 
 #if USE_AUTH
     char const *proxy_auth_msg = "<null>";
@@ -758,96 +765,77 @@ ClientRequestContext::maybeSendAuthChallenge(const allow_t &answer)
         proxy_auth_msg = http->request->auth_user_request->denyMessage("<null>");
 #endif
 
-    bool auth_challenge = false;
-    switch (answer) {
-    case ACCESS_ALLOWED:
-    case ACCESS_AUTH_EXPIRED_OK:
-        // No authentication challenge on these ACL results
-        return auth_challenge;
-
-    case ACCESS_DENIED:
-    case ACCESS_DUNNO:
-        // MAYBE challenge on these ACL results
-        auth_challenge |= aclIsProxyAuth(AclMatchedName);
-        break;
-
-    case ACCESS_AUTH_REQUIRED:
-    case ACCESS_AUTH_EXPIRED_BAD:
-        // Send an auth challenge or error
-        auth_challenge = true;
-    }
+    if (answer != ACCESS_ALLOWED) {
+        // auth has a grace period where credentials can be expired but okay not to challenge.
 
-    // auth has a grace period where credentials can be expired but okay not to challenge.
-    debugs(85, 5, "Access Denied: " << http->uri);
-    debugs(85, 5, "AclMatchedName = " << (AclMatchedName ? AclMatchedName : "<null>"));
+        /* Send an auth challenge or error */
+        // XXX: do we still need aclIsProxyAuth() ?
+        bool auth_challenge = (answer == ACCESS_AUTH_REQUIRED || aclIsProxyAuth(AclMatchedName));
+        debugs(85, 5, "Access Denied: " << http->uri);
+        debugs(85, 5, "AclMatchedName = " << (AclMatchedName ? AclMatchedName : "<null>"));
 #if USE_AUTH
-    if (auth_challenge)
-        debugs(33, 5, "Proxy Auth Message = " << (proxy_auth_msg ? proxy_auth_msg : "<null>"));
+        if (auth_challenge)
+            debugs(33, 5, "Proxy Auth Message = " << (proxy_auth_msg ? proxy_auth_msg : "<null>"));
 #endif
 
-    /*
-     * NOTE: get page_id here, based on AclMatchedName because if
-     * USE_DELAY_POOLS is enabled, then AclMatchedName gets clobbered in
-     * the clientCreateStoreEntry() call just below.  Pedro Ribeiro
-     * <pribeiro@isel.pt>
-     */
-    page_id = aclGetDenyInfoPage(&Config.denyInfoList, AclMatchedName, auth_challenge);
+        /*
+         * NOTE: get page_id here, based on AclMatchedName because if
+         * USE_DELAY_POOLS is enabled, then AclMatchedName gets clobbered in
+         * the clientCreateStoreEntry() call just below.  Pedro Ribeiro
+         * <pribeiro@isel.pt>
+         */
+        page_id = aclGetDenyInfoPage(&Config.denyInfoList, AclMatchedName, answer != ACCESS_AUTH_REQUIRED);
 
-    http->logType = LOG_TCP_DENIED;
+        http->logType = LOG_TCP_DENIED;
 
-    if (auth_challenge) {
+        if (auth_challenge) {
 #if USE_AUTH
-        if (http->request->flags.sslBumped) {
-            /*SSL Bumped request, authentication is not possible*/
+            if (http->request->flags.sslBumped) {
+                /*SSL Bumped request, authentication is not possible*/
+                status = HTTP_FORBIDDEN;
+            } else if (!http->flags.accel) {
+                /* Proxy authorisation needed */
+                status = HTTP_PROXY_AUTHENTICATION_REQUIRED;
+            } else {
+                /* WWW authorisation needed */
+                status = HTTP_UNAUTHORIZED;
+            }
+#else
+            // need auth, but not possible to do.
             status = HTTP_FORBIDDEN;
-        } else if (!http->flags.accel) {
-            /* Proxy authorisation needed */
-            status = HTTP_PROXY_AUTHENTICATION_REQUIRED;
+#endif
+            if (page_id == ERR_NONE)
+                page_id = ERR_CACHE_ACCESS_DENIED;
         } else {
-            /* WWW authorisation needed */
-            status = HTTP_UNAUTHORIZED;
+            status = HTTP_FORBIDDEN;
+
+            if (page_id == ERR_NONE)
+                page_id = ERR_ACCESS_DENIED;
         }
+
+        clientStreamNode *node = (clientStreamNode *)http->client_stream.tail->prev->data;
+        clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
+        assert (repContext);
+        Ip::Address tmpnoaddr;
+        tmpnoaddr.SetNoAddr();
+        repContext->setReplyToError(page_id, status,
+                                    http->request->method, NULL,
+                                    http->getConn() != NULL ? http->getConn()->clientConnection->remote : tmpnoaddr,
+                                    http->request,
+                                    NULL,
+#if USE_AUTH
+                                    http->getConn() != NULL && http->getConn()->auth_user_request != NULL ?
+                                    http->getConn()->auth_user_request : http->request->auth_user_request);
 #else
-        // need auth, but not possible to do.
-        status = HTTP_FORBIDDEN;
+                                    NULL);
 #endif
-        if (page_id == ERR_NONE)
-            page_id = ERR_CACHE_ACCESS_DENIED;
-    } else {
-        status = HTTP_FORBIDDEN;
-
-        if (page_id == ERR_NONE)
-            page_id = ERR_ACCESS_DENIED;
+        http->getConn()->flags.readMore = true; // resume any pipeline reads.
+        node = (clientStreamNode *)http->client_stream.tail->data;
+        clientStreamRead(node, http, node->readBuffer);
+        return;
     }
 
-    Ip::Address tmpnoaddr;
-    tmpnoaddr.SetNoAddr();
-    error = clientBuildError(page_id, status, 
-                             NULL,
-                             http->getConn() != NULL ? http->getConn()->clientConnection->remote : tmpnoaddr,
-                             http->request
-        );
-
-    error->auth_user_request = 
-        http->getConn() != NULL && http->getConn()->auth_user_request != NULL ?
-        http->getConn()->auth_user_request : http->request->auth_user_request;
-
-    readNextRequest = true;
-    return true;
-}
-
-void
-ClientRequestContext::clientAccessCheckDone(const allow_t &answer)
-{
-    debugs(85, 2, "The request " <<
-           RequestMethodStr(http->request->method) << " " <<
-           http->uri << " is " << answer <<
-           ", because it matched '" <<
-           (AclMatchedName ? AclMatchedName : "NO ACL's") << "'" );
-
-    maybeSendAuthChallenge(answer);
-     
-    /* ACCESS_ALLOWED (or auth in grace period ACCESS_AUTH_EXPIRED_OK) continues here ... */
+    /* ACCESS_ALLOWED continues here ... */
     safe_free(http->uri);
 
     http->uri = xstrdup(urlCanonical(http->request));
@@ -891,9 +879,11 @@ static void
 clientRedirectAccessCheckDone(allow_t answer, void *data)
 {
     ClientRequestContext *context = (ClientRequestContext *)data;
+    ClientHttpRequest *http = context->http;
+    context->acl_checklist = NULL;
 
-    if (!context->maybeSendAuthChallenge(answer) && answer == ACCESS_ALLOWED)
-        redirectStart(context->http, clientRedirectDoneWrapper, context);
+    if (answer == ACCESS_ALLOWED)
+        redirectStart(http, clientRedirectDoneWrapper, context);
     else
         context->clientRedirectDone(NULL);
 }
@@ -1205,6 +1195,7 @@ ClientRequestContext::clientRedirectDone(char *result)
         if (status == HTTP_MOVED_PERMANENTLY
                 || status == HTTP_MOVED_TEMPORARILY
                 || status == HTTP_SEE_OTHER
+                || status == HTTP_PERMANENT_REDIRECT
                 || status == HTTP_TEMPORARY_REDIRECT) {
             char *t = result;
 
@@ -1213,10 +1204,7 @@ ClientRequestContext::clientRedirectDone(char *result)
                 http->redirect.location = xstrdup(t + 1);
                 // TODO: validate the URL produced here is RFC 2616 compliant absolute URI
             } else {
-                if (old_request->http_ver < HttpVersion(1,1))
-                    debugs(85, DBG_CRITICAL, "ERROR: URL-rewrite produces invalid 302 redirect Location: " << result);
-                else
-                    debugs(85, DBG_CRITICAL, "ERROR: URL-rewrite produces invalid 303 redirect Location: " << result);
+                debugs(85, DBG_CRITICAL, "ERROR: URL-rewrite produces invalid " << status << " redirect Location: " << result);
             }
         } else if (strcmp(result, http->uri)) {
             // XXX: validate the URL properly *without* generating a whole new request object right here.
@@ -1318,6 +1306,9 @@ static void
 sslBumpAccessCheckDoneWrapper(allow_t answer, void *data)
 {
     ClientRequestContext *calloutContext = static_cast<ClientRequestContext *>(data);
+
+    if (!calloutContext->httpStateIsValid())
+        return;
     calloutContext->sslBumpAccessCheckDone(answer);
 }
 
@@ -1785,10 +1776,7 @@ ClientHttpRequest::noteMoreBodyDataAvailable(BodyPipe::Pointer)
     assert(adaptedBodySource != NULL);
 
     if (size_t contentSize = adaptedBodySource->buf().contentSize()) {
-        // XXX: entry->bytesWanted returns contentSize-1 if entry can accept data.
-        // We have to add 1 to avoid suspending forever.
-        const size_t bytesWanted = storeEntry()->bytesWanted(Range<size_t>(0,contentSize));
-        const size_t spaceAvailable = bytesWanted >  0 ? (bytesWanted + 1) : 0;
+        const size_t spaceAvailable = storeEntry()->bytesWanted(Range<size_t>(0,contentSize));
 
         if (spaceAvailable < contentSize ) {
             // No or partial body data consuming
@@ -1798,8 +1786,7 @@ ClientHttpRequest::noteMoreBodyDataAvailable(BodyPipe::Pointer)
             storeEntry()->deferProducer(call);
         }
 
-        // XXX: bytesWanted API does not allow us to write just one byte!
-        if (!spaceAvailable && contentSize > 1)
+        if (!spaceAvailable)
             return;
 
         if (spaceAvailable < contentSize )
@@ -241,7 +241,7 @@ Comm::ConnOpener::connect()
             return;
         } else {
             debugs(5, 5, HERE << conn_ << ": COMM_INPROGRESS");
-            Comm::SetSelect(temporaryFd_, COMM_SELECT_WRITE, Comm::ConnOpener::InProgressConnectRetry, this, 0);
+            Comm::SetSelect(temporaryFd_, COMM_SELECT_WRITE, Comm::ConnOpener::InProgressConnectRetry, new Pointer(this), 0);
         }
         break;
 
@@ -261,7 +261,7 @@ Comm::ConnOpener::connect()
             doneConnecting(COMM_TIMEOUT, errno);
         } else if (failRetries_ < Config.connect_retries) {
             debugs(5, 5, HERE << conn_ << ": * - try again");
-            eventAdd("Comm::ConnOpener::DelayedConnectRetry", Comm::ConnOpener::DelayedConnectRetry, this, 0.05, 0);
+            eventAdd("Comm::ConnOpener::DelayedConnectRetry", Comm::ConnOpener::DelayedConnectRetry, new Pointer(this), 0.05, 0);
             return;
         } else {
             // send ERROR back to the upper layer.
@@ -319,14 +319,16 @@ Comm::ConnOpener::timeout(const CommTimeoutCbParams &)
 void
 Comm::ConnOpener::InProgressConnectRetry(int fd, void *data)
 {
-    ConnOpener *cs = static_cast<Comm::ConnOpener *>(data);
-    assert(cs);
-
-    // Ew. we are now outside the all AsyncJob protections.
-    // get back inside by scheduling another call...
-    typedef NullaryMemFunT<Comm::ConnOpener> Dialer;
-    AsyncCall::Pointer call = JobCallback(5, 4, Dialer, cs, Comm::ConnOpener::connect);
-    ScheduleCallHere(call);
+    Pointer *ptr = static_cast<Pointer*>(data);
+    assert(ptr);
+    if (ConnOpener *cs = ptr->valid()) {
+        // Ew. we are now outside the all AsyncJob protections.
+        // get back inside by scheduling another call...
+        typedef NullaryMemFunT<Comm::ConnOpener> Dialer;
+        AsyncCall::Pointer call = JobCallback(5, 4, Dialer, cs, Comm::ConnOpener::connect);
+        ScheduleCallHere(call);
+    }
+    delete ptr;
 }
 
 /* Legacy Wrapper for the retry event with small delay after errors.
@@ -335,12 +337,14 @@ Comm::ConnOpener::InProgressConnectRetry(int fd, void *data)
 void
 Comm::ConnOpener::DelayedConnectRetry(void *data)
 {
-    ConnOpener *cs = static_cast<Comm::ConnOpener *>(data);
-    assert(cs);
-
-    // Ew. we are now outside the all AsyncJob protections.
-    // get back inside by scheduling another call...
-    typedef NullaryMemFunT<Comm::ConnOpener> Dialer;
-    AsyncCall::Pointer call = JobCallback(5, 4, Dialer, cs, Comm::ConnOpener::connect);
-    ScheduleCallHere(call);
+    Pointer *ptr = static_cast<Pointer*>(data);
+    assert(ptr);
+    if (ConnOpener *cs = ptr->valid()) {
+        // Ew. we are now outside the all AsyncJob protections.
+        // get back inside by scheduling another call...
+        typedef NullaryMemFunT<Comm::ConnOpener> Dialer;
+        AsyncCall::Pointer call = JobCallback(5, 4, Dialer, cs, Comm::ConnOpener::connect);
+        ScheduleCallHere(call);
+    }
+    delete ptr;
 }
@@ -21,6 +21,8 @@ class ConnOpener : public AsyncJob
     virtual void swanSong();
 
 public:
+    typedef CbcPointer<ConnOpener> Pointer;
+
     virtual bool doneAll() const;
 
     ConnOpener(Comm::ConnectionPointer &, AsyncCall::Pointer &handler, time_t connect_timeout);
@@ -31,6 +31,37 @@ extern comm_err_t DoSelect(int);
 
 extern void QuickPollRequired(void);
 
+/**
+ * Max number of UDP messages to receive per call to the UDP receive poller.
+ * This is a per-port limit for ICP/HTCP ports.
+ * DNS has a separate limit.
+ */
+#if _SQUID_MSWIN_
+#define INCOMING_UDP_MAX 1
+#else
+#define INCOMING_UDP_MAX 15
+#endif
+
+/**
+ * Max number of DNS messages to receive per call to DNS read handler
+ */
+#if _SQUID_MSWIN_
+#define INCOMING_DNS_MAX 1
+#else
+#define INCOMING_DNS_MAX 15
+#endif
+
+/**
+ * Max number of new TCP connections to accept per call to the TCP listener poller.
+ * This is a per-port limit for HTTP/HTTPS ports.
+ */
+#if _SQUID_MSWIN_
+#define INCOMING_TCP_MAX 1
+#else
+#define INCOMING_TCP_MAX 10
+#endif
+#define INCOMING_TOTAL_MAX (INCOMING_TCP_MAX+INCOMING_UDP_MAX+INCOMING_DNS_MAX)
+
 } // namespace Comm
 
 #endif /* _SQUID_SRC_COMM_LOOPS_H */
@@ -23,6 +23,7 @@ libcomm_la_SOURCES= \
 	ModSelectWin32.cc \
 	TcpAcceptor.cc \
 	TcpAcceptor.h \
+	UdpOpenDialer.h \
 	Write.cc \
 	Write.h \
 	\
@@ -35,6 +35,7 @@
 #if USE_POLL
 
 #include "squid-old.h"
+#include "anyp/PortCfg.h"
 #include "comm/Connection.h"
 #include "comm/Loops.h"
 #include "fde.h"
@@ -70,8 +71,8 @@ static int MAX_POLL_TIME = 1000;	/* see also Comm::QuickPollRequired() */
 #define FD_MASK_BITS (FD_MASK_BYTES*NBBY)
 
 /* STATIC */
-static int fdIsHttp(int fd);
-static int fdIsIcp(int fd);
+static int fdIsTcpListen(int fd);
+static int fdIsUdpListen(int fd);
 static int fdIsDns(int fd);
 static OBJH commIncomingStats;
 static int comm_check_incoming_poll_handlers(int nfds, int *fds);
@@ -92,7 +93,7 @@ static void comm_poll_dns_incoming(void);
  * multipled by a factor of (2^INCOMING_FACTOR) to have some
  * pseudo-floating point precision.
  *
- * The variable 'icp_io_events' and 'http_io_events' counts how many normal
+ * The variable 'udp_io_events' and 'tcp_io_events' counts how many normal
  * I/O events have been processed since the last check on the incoming
  * sockets.  When io_events > incoming_interval, its time to check incoming
  * sockets.
@@ -106,7 +107,7 @@ static void comm_poll_dns_incoming(void);
  *
  *  incoming_interval = incoming_interval + target_average - number_of_events_processed
  *
- * There are separate incoming_interval counters for both HTTP and ICP events
+ * There are separate incoming_interval counters for TCP-based, UDP-based, and DNS events
  *
  * You can see the current values of the incoming_interval's, as well as
  * a histogram of 'incoming_events' by asking the cache manager
@@ -128,15 +129,15 @@ static void comm_poll_dns_incoming(void);
 #define MAX_INCOMING_INTEGER 256
 #define INCOMING_FACTOR 5
 #define MAX_INCOMING_INTERVAL (MAX_INCOMING_INTEGER << INCOMING_FACTOR)
-static int icp_io_events = 0;
-static int dns_io_events = 0;
-static int http_io_events = 0;
-static int incoming_icp_interval = 16 << INCOMING_FACTOR;
+static int udp_io_events = 0; ///< I/O events passed since last UDP receiver socket poll
+static int dns_io_events = 0; ///< I/O events passed since last DNS socket poll
+static int tcp_io_events = 0; ///< I/O events passed since last TCP listening socket poll
+static int incoming_udp_interval = 16 << INCOMING_FACTOR;
 static int incoming_dns_interval = 16 << INCOMING_FACTOR;
-static int incoming_http_interval = 16 << INCOMING_FACTOR;
-#define commCheckICPIncoming (++icp_io_events > (incoming_icp_interval>> INCOMING_FACTOR))
-#define commCheckDNSIncoming (++dns_io_events > (incoming_dns_interval>> INCOMING_FACTOR))
-#define commCheckHTTPIncoming (++http_io_events > (incoming_http_interval>> INCOMING_FACTOR))
+static int incoming_tcp_interval = 16 << INCOMING_FACTOR;
+#define commCheckUdpIncoming (++udp_io_events > (incoming_udp_interval>> INCOMING_FACTOR))
+#define commCheckDnsIncoming (++dns_io_events > (incoming_dns_interval>> INCOMING_FACTOR))
+#define commCheckTcpIncoming (++tcp_io_events > (incoming_tcp_interval>> INCOMING_FACTOR))
 
 
 void
@@ -169,7 +170,7 @@ Comm::ResetSelect(int fd)
 }
 
 static int
-fdIsIcp(int fd)
+fdIsUdpListen(int fd)
 {
     if (icpIncomingConn != NULL && icpIncomingConn->fd == fd)
         return 1;
@@ -193,12 +194,10 @@ fdIsDns(int fd)
 }
 
 static int
-fdIsHttp(int fd)
+fdIsTcpListen(int fd)
 {
-    int j;
-
-    for (j = 0; j < NHttpSockets; j++) {
-        if (fd == HttpSockets[j])
+    for (const AnyP::PortCfg *s = Config.Sockaddr.http; s; s = s->next) {
+        if (s->listenConn != NULL && s->listenConn->fd == fd)
             return 1;
     }
 
@@ -213,7 +212,7 @@ comm_check_incoming_poll_handlers(int nfds, int *fds)
     PF *hdl = NULL;
     int npfds;
 
-    struct pollfd pfds[3 + MAXHTTPPORTS];
+    struct pollfd pfds[3 + MAXTCPLISTENPORTS];
     PROF_start(comm_check_incoming);
     incoming_sockets_accepted = 0;
 
@@ -277,12 +276,12 @@ comm_check_incoming_poll_handlers(int nfds, int *fds)
 }
 
 static void
-comm_poll_icp_incoming(void)
+comm_poll_udp_incoming(void)
 {
     int nfds = 0;
     int fds[2];
     int nevents;
-    icp_io_events = 0;
+    udp_io_events = 0;
 
     if (Comm::IsConnOpen(icpIncomingConn))
         fds[nfds++] = icpIncomingConn->fd;
@@ -295,30 +294,30 @@ comm_poll_icp_incoming(void)
 
     nevents = comm_check_incoming_poll_handlers(nfds, fds);
 
-    incoming_icp_interval += Config.comm_incoming.icp_average - nevents;
+    incoming_udp_interval += Config.comm_incoming.udp.average - nevents;
 
-    if (incoming_icp_interval < Config.comm_incoming.icp_min_poll)
-        incoming_icp_interval = Config.comm_incoming.icp_min_poll;
+    if (incoming_udp_interval < Config.comm_incoming.udp.min_poll)
+        incoming_udp_interval = Config.comm_incoming.udp.min_poll;
 
-    if (incoming_icp_interval > MAX_INCOMING_INTERVAL)
-        incoming_icp_interval = MAX_INCOMING_INTERVAL;
+    if (incoming_udp_interval > MAX_INCOMING_INTERVAL)
+        incoming_udp_interval = MAX_INCOMING_INTERVAL;
 
-    if (nevents > INCOMING_ICP_MAX)
-        nevents = INCOMING_ICP_MAX;
+    if (nevents > INCOMING_UDP_MAX)
+        nevents = INCOMING_UDP_MAX;
 
-    statCounter.comm_icp_incoming.count(nevents);
+    statCounter.comm_udp_incoming.count(nevents);
 }
 
 static void
-comm_poll_http_incoming(void)
+comm_poll_tcp_incoming(void)
 {
     int nfds = 0;
-    int fds[MAXHTTPPORTS];
+    int fds[MAXTCPLISTENPORTS];
     int j;
     int nevents;
-    http_io_events = 0;
+    tcp_io_events = 0;
 
-    /* only poll sockets that won't be deferred */
+    // XXX: only poll sockets that won't be deferred. But how do we identify them?
 
     for (j = 0; j < NHttpSockets; j++) {
         if (HttpSockets[j] < 0)
@@ -328,19 +327,19 @@ comm_poll_http_incoming(void)
     }
 
     nevents = comm_check_incoming_poll_handlers(nfds, fds);
-    incoming_http_interval = incoming_http_interval
-                             + Config.comm_incoming.http_average - nevents;
+    incoming_tcp_interval = incoming_tcp_interval
+                            + Config.comm_incoming.tcp.average - nevents;
 
-    if (incoming_http_interval < Config.comm_incoming.http_min_poll)
-        incoming_http_interval = Config.comm_incoming.http_min_poll;
+    if (incoming_tcp_interval < Config.comm_incoming.tcp.min_poll)
+        incoming_tcp_interval = Config.comm_incoming.tcp.min_poll;
 
-    if (incoming_http_interval > MAX_INCOMING_INTERVAL)
-        incoming_http_interval = MAX_INCOMING_INTERVAL;
+    if (incoming_tcp_interval > MAX_INCOMING_INTERVAL)
+        incoming_tcp_interval = MAX_INCOMING_INTERVAL;
 
-    if (nevents > INCOMING_HTTP_MAX)
-        nevents = INCOMING_HTTP_MAX;
+    if (nevents > INCOMING_TCP_MAX)
+        nevents = INCOMING_TCP_MAX;
 
-    statCounter.comm_http_incoming.count(nevents);
+    statCounter.comm_tcp_incoming.count(nevents);
 }
 
 /* poll all sockets; call handlers for those that are ready. */
@@ -355,27 +354,26 @@ Comm::DoSelect(int msec)
     unsigned long nfds;
     unsigned long npending;
     int num;
-    int callicp = 0, callhttp = 0;
-    int calldns = 0;
+    int calldns = 0, calludp = 0, calltcp = 0;
     double timeout = current_dtime + (msec / 1000.0);
 
     do {
         double start;
         getCurrentTime();
         start = current_dtime;
 
-        if (commCheckICPIncoming)
-            comm_poll_icp_incoming();
+        if (commCheckUdpIncoming)
+            comm_poll_udp_incoming();
 
-        if (commCheckDNSIncoming)
+        if (commCheckDnsIncoming)
             comm_poll_dns_incoming();
 
-        if (commCheckHTTPIncoming)
-            comm_poll_http_incoming();
+        if (commCheckTcpIncoming)
+            comm_poll_tcp_incoming();
 
         PROF_start(comm_poll_prep_pfds);
 
-        callicp = calldns = callhttp = 0;
+        calldns = calludp = calltcp = 0;
 
         nfds = 0;
 
@@ -474,8 +472,8 @@ Comm::DoSelect(int msec)
             if (revents == 0)
                 continue;
 
-            if (fdIsIcp(fd)) {
-                callicp = 1;
+            if (fdIsUdpListen(fd)) {
+                calludp = 1;
                 continue;
             }
 
@@ -484,8 +482,8 @@ Comm::DoSelect(int msec)
                 continue;
             }
 
-            if (fdIsHttp(fd)) {
-                callhttp = 1;
+            if (fdIsTcpListen(fd)) {
+                calltcp = 1;
                 continue;
             }
 
@@ -494,24 +492,22 @@ Comm::DoSelect(int msec)
             if (revents & (POLLRDNORM | POLLIN | POLLHUP | POLLERR)) {
                 debugs(5, 6, "comm_poll: FD " << fd << " ready for reading");
 
-                if (NULL == (hdl = F->read_handler))
-                    (void) 0;
-                else {
+                if ((hdl = F->read_handler)) {
                     PROF_start(comm_read_handler);
                     F->read_handler = NULL;
                     F->flags.read_pending = 0;
                     hdl(fd, F->read_data);
                     PROF_stop(comm_read_handler);
                     statCounter.select_fds++;
 
-                    if (commCheckICPIncoming)
-                        comm_poll_icp_incoming();
+                    if (commCheckUdpIncoming)
+                        comm_poll_udp_incoming();
 
-                    if (commCheckDNSIncoming)
+                    if (commCheckDnsIncoming)
                         comm_poll_dns_incoming();
 
-                    if (commCheckHTTPIncoming)
-                        comm_poll_http_incoming();
+                    if (commCheckTcpIncoming)
+                        comm_poll_tcp_incoming();
                 }
             }
 
@@ -525,14 +521,14 @@ Comm::DoSelect(int msec)
                     PROF_stop(comm_write_handler);
                     statCounter.select_fds++;
 
-                    if (commCheckICPIncoming)
-                        comm_poll_icp_incoming();
+                    if (commCheckUdpIncoming)
+                        comm_poll_udp_incoming();
 
-                    if (commCheckDNSIncoming)
+                    if (commCheckDnsIncoming)
                         comm_poll_dns_incoming();
 
-                    if (commCheckHTTPIncoming)
-                        comm_poll_http_incoming();
+                    if (commCheckTcpIncoming)
+                        comm_poll_tcp_incoming();
                 }
             }
 
@@ -566,14 +562,14 @@ Comm::DoSelect(int msec)
 
         PROF_stop(comm_handle_ready_fd);
 
-        if (callicp)
-            comm_poll_icp_incoming();
+        if (calludp)
+            comm_poll_udp_incoming();
 
         if (calldns)
             comm_poll_dns_incoming();
 
-        if (callhttp)
-            comm_poll_http_incoming();
+        if (calltcp)
+            comm_poll_tcp_incoming();
 
         getCurrentTime();
 
@@ -610,10 +606,10 @@ comm_poll_dns_incoming(void)
     if (nevents < 0)
         return;
 
-    incoming_dns_interval += Config.comm_incoming.dns_average - nevents;
+    incoming_dns_interval += Config.comm_incoming.dns.average - nevents;
 
-    if (incoming_dns_interval < Config.comm_incoming.dns_min_poll)
-        incoming_dns_interval = Config.comm_incoming.dns_min_poll;
+    if (incoming_dns_interval < Config.comm_incoming.dns.min_poll)
+        incoming_dns_interval = Config.comm_incoming.dns.min_poll;
 
     if (incoming_dns_interval > MAX_INCOMING_INTERVAL)
         incoming_dns_interval = MAX_INCOMING_INTERVAL;
@@ -642,20 +638,20 @@ Comm::SelectLoopInit(void)
 static void
 commIncomingStats(StoreEntry * sentry)
 {
-    storeAppendPrintf(sentry, "Current incoming_icp_interval: %d\n",
-                      incoming_icp_interval >> INCOMING_FACTOR);
+    storeAppendPrintf(sentry, "Current incoming_udp_interval: %d\n",
+                      incoming_udp_interval >> INCOMING_FACTOR);
     storeAppendPrintf(sentry, "Current incoming_dns_interval: %d\n",
                       incoming_dns_interval >> INCOMING_FACTOR);
-    storeAppendPrintf(sentry, "Current incoming_http_interval: %d\n",
-                      incoming_http_interval >> INCOMING_FACTOR);
+    storeAppendPrintf(sentry, "Current incoming_tcp_interval: %d\n",
+                      incoming_tcp_interval >> INCOMING_FACTOR);
     storeAppendPrintf(sentry, "\n");
     storeAppendPrintf(sentry, "Histogram of events per incoming socket type\n");
-    storeAppendPrintf(sentry, "ICP Messages handled per comm_poll_icp_incoming() call:\n");
-    statCounter.comm_icp_incoming.dump(sentry, statHistIntDumper);
+    storeAppendPrintf(sentry, "ICP Messages handled per comm_poll_udp_incoming() call:\n");
+    statCounter.comm_udp_incoming.dump(sentry, statHistIntDumper);
     storeAppendPrintf(sentry, "DNS Messages handled per comm_poll_dns_incoming() call:\n");
     statCounter.comm_dns_incoming.dump(sentry, statHistIntDumper);
-    storeAppendPrintf(sentry, "HTTP Messages handled per comm_poll_http_incoming() call:\n");
-    statCounter.comm_http_incoming.dump(sentry, statHistIntDumper);
+    storeAppendPrintf(sentry, "HTTP Messages handled per comm_poll_tcp_incoming() call:\n");
+    statCounter.comm_tcp_incoming.dump(sentry, statHistIntDumper);
 }
 
 /* Called by async-io or diskd to speed up the polling */
@@ -35,6 +35,7 @@
 #if USE_SELECT
 
 #include "squid-old.h"
+#include "anyp/PortCfg.h"
 #include "comm/Connection.h"
 #include "comm/Loops.h"
 #include "fde.h"
@@ -58,8 +59,8 @@ static int MAX_POLL_TIME = 1000;	/* see also Comm::QuickPollRequired() */
 
 /* STATIC */
 static int examine_select(fd_set *, fd_set *);
-static int fdIsHttp(int fd);
-static int fdIsIcp(int fd);
+static int fdIsTcpListener(int fd);
+static int fdIsUdpListener(int fd);
 static int fdIsDns(int fd);
 static OBJH commIncomingStats;
 static int comm_check_incoming_select_handlers(int nfds, int *fds);
@@ -83,13 +84,13 @@ static int nwritefds;
  * of incoming ICP, then we need to check these sockets more than
  * if we just have HTTP.
  *
- * The variables 'incoming_icp_interval' and 'incoming_http_interval'
+ * The variables 'incoming_udp_interval' and 'incoming_tcp_interval'
  * determine how many normal I/O events to process before checking
  * incoming sockets again.  Note we store the incoming_interval
  * multipled by a factor of (2^INCOMING_FACTOR) to have some
  * pseudo-floating point precision.
  *
- * The variable 'icp_io_events' and 'http_io_events' counts how many normal
+ * The variable 'udp_io_events' and 'tcp_io_events' counts how many normal
  * I/O events have been processed since the last check on the incoming
  * sockets.  When io_events > incoming_interval, its time to check incoming
  * sockets.
@@ -103,7 +104,7 @@ static int nwritefds;
  *
  *  incoming_interval = incoming_interval + target_average - number_of_events_processed
  *
- * There are separate incoming_interval counters for both HTTP and ICP events
+ * There are separate incoming_interval counters for DNS, UDP and TCP events
  *
  * You can see the current values of the incoming_interval's, as well as
  * a histogram of 'incoming_events' by asking the cache manager
@@ -125,15 +126,15 @@ static int nwritefds;
 #define MAX_INCOMING_INTEGER 256
 #define INCOMING_FACTOR 5
 #define MAX_INCOMING_INTERVAL (MAX_INCOMING_INTEGER << INCOMING_FACTOR)
-static int icp_io_events = 0;
+static int udp_io_events = 0;
 static int dns_io_events = 0;
-static int http_io_events = 0;
-static int incoming_icp_interval = 16 << INCOMING_FACTOR;
+static int tcp_io_events = 0;
+static int incoming_udp_interval = 16 << INCOMING_FACTOR;
 static int incoming_dns_interval = 16 << INCOMING_FACTOR;
-static int incoming_http_interval = 16 << INCOMING_FACTOR;
-#define commCheckICPIncoming (++icp_io_events > (incoming_icp_interval>> INCOMING_FACTOR))
-#define commCheckDNSIncoming (++dns_io_events > (incoming_dns_interval>> INCOMING_FACTOR))
-#define commCheckHTTPIncoming (++http_io_events > (incoming_http_interval>> INCOMING_FACTOR))
+static int incoming_tcp_interval = 16 << INCOMING_FACTOR;
+#define commCheckUdpIncoming (++udp_io_events > (incoming_udp_interval>> INCOMING_FACTOR))
+#define commCheckDnsIncoming (++dns_io_events > (incoming_dns_interval>> INCOMING_FACTOR))
+#define commCheckTcpIncoming (++tcp_io_events > (incoming_tcp_interval>> INCOMING_FACTOR))
 
 void
 Comm::SetSelect(int fd, unsigned int type, PF * handler, void *client_data, time_t timeout)
@@ -167,7 +168,7 @@ Comm::ResetSelect(int fd)
 }
 
 static int
-fdIsIcp(int fd)
+fdIsUdpListener(int fd)
 {
     if (icpIncomingConn != NULL && fd == icpIncomingConn->fd)
         return 1;
@@ -191,12 +192,10 @@ fdIsDns(int fd)
 }
 
 static int
-fdIsHttp(int fd)
+fdIsTcpListener(int fd)
 {
-    int j;
-
-    for (j = 0; j < NHttpSockets; j++) {
-        if (fd == HttpSockets[j])
+    for (const AnyP::PortCfg *s = Config.Sockaddr.http; s; s = s->next) {
+        if (s->listenConn != NULL && s->listenConn->fd == fd)
             return 1;
     }
 
@@ -272,12 +271,12 @@ comm_check_incoming_select_handlers(int nfds, int *fds)
 }
 
 static void
-comm_select_icp_incoming(void)
+comm_select_udp_incoming(void)
 {
     int nfds = 0;
     int fds[2];
     int nevents;
-    icp_io_events = 0;
+    udp_io_events = 0;
 
     if (Comm::IsConnOpen(icpIncomingConn))
         fds[nfds++] = icpIncomingConn->fd;
@@ -290,49 +289,48 @@ comm_select_icp_incoming(void)
 
     nevents = comm_check_incoming_select_handlers(nfds, fds);
 
-    incoming_icp_interval += Config.comm_incoming.icp_average - nevents;
+    incoming_udp_interval += Config.comm_incoming.udp.average - nevents;
 
-    if (incoming_icp_interval < 0)
-        incoming_icp_interval = 0;
+    if (incoming_udp_interval < 0)
+        incoming_udp_interval = 0;
 
-    if (incoming_icp_interval > MAX_INCOMING_INTERVAL)
-        incoming_icp_interval = MAX_INCOMING_INTERVAL;
+    if (incoming_udp_interval > MAX_INCOMING_INTERVAL)
+        incoming_udp_interval = MAX_INCOMING_INTERVAL;
 
-    if (nevents > INCOMING_ICP_MAX)
-        nevents = INCOMING_ICP_MAX;
+    if (nevents > INCOMING_UDP_MAX)
+        nevents = INCOMING_UDP_MAX;
 
-    statCounter.comm_icp_incoming.count(nevents);
+    statCounter.comm_udp_incoming.count(nevents);
 }
 
 static void
-comm_select_http_incoming(void)
+comm_select_tcp_incoming(void)
 {
     int nfds = 0;
-    int fds[MAXHTTPPORTS];
-    int j;
+    int fds[MAXTCPLISTENPORTS];
     int nevents;
-    http_io_events = 0;
+    tcp_io_events = 0;
 
-    for (j = 0; j < NHttpSockets; j++) {
-        if (HttpSockets[j] < 0)
-            continue;
+    // XXX: only poll sockets that won't be deferred. But how do we identify them?
 
-        fds[nfds++] = HttpSockets[j];
+    for (const AnyP::PortCfg *s = Config.Sockaddr.http; s; s = s->next) {
+        if (Comm::IsConnOpen(s->listenConn))
+            fds[nfds++] = s->listenConn->fd;
     }
 
     nevents = comm_check_incoming_select_handlers(nfds, fds);
-    incoming_http_interval += Config.comm_incoming.http_average - nevents;
+    incoming_tcp_interval += Config.comm_incoming.tcp.average - nevents;
 
-    if (incoming_http_interval < 0)
-        incoming_http_interval = 0;
+    if (incoming_tcp_interval < 0)
+        incoming_tcp_interval = 0;
 
-    if (incoming_http_interval > MAX_INCOMING_INTERVAL)
-        incoming_http_interval = MAX_INCOMING_INTERVAL;
+    if (incoming_tcp_interval > MAX_INCOMING_INTERVAL)
+        incoming_tcp_interval = MAX_INCOMING_INTERVAL;
 
-    if (nevents > INCOMING_HTTP_MAX)
-        nevents = INCOMING_HTTP_MAX;
+    if (nevents > INCOMING_TCP_MAX)
+        nevents = INCOMING_TCP_MAX;
 
-    statCounter.comm_http_incoming.count(nevents);
+    statCounter.comm_tcp_incoming.count(nevents);
 }
 
 #define DEBUG_FDBITS 0
@@ -349,8 +347,7 @@ Comm::DoSelect(int msec)
     int maxfd;
     int num;
     int pending;
-    int callicp = 0, callhttp = 0;
-    int calldns = 0;
+    int calldns = 0, calludp = 0, calltcp = 0;
     int maxindex;
     unsigned int k;
     int j;
@@ -372,16 +369,16 @@ Comm::DoSelect(int msec)
         getCurrentTime();
         start = current_dtime;
 
-        if (commCheckICPIncoming)
-            comm_select_icp_incoming();
+        if (commCheckUdpIncoming)
+            comm_select_udp_incoming();
 
-        if (commCheckDNSIncoming)
+        if (commCheckDnsIncoming)
             comm_select_dns_incoming();
 
-        if (commCheckHTTPIncoming)
-            comm_select_http_incoming();
+        if (commCheckTcpIncoming)
+            comm_select_tcp_incoming();
 
-        callicp = calldns = callhttp = 0;
+        calldns = calludp = calltcp = 0;
 
         maxfd = Biggest_FD + 1;
 
@@ -508,8 +505,8 @@ Comm::DoSelect(int msec)
 
 #endif
 
-                if (fdIsIcp(fd)) {
-                    callicp = 1;
+                if (fdIsUdpListener(fd)) {
+                    calludp = 1;
                     continue;
                 }
 
@@ -518,8 +515,8 @@ Comm::DoSelect(int msec)
                     continue;
                 }
 
-                if (fdIsHttp(fd)) {
-                    callhttp = 1;
+                if (fdIsTcpListener(fd)) {
+                    calltcp = 1;
                     continue;
                 }
 
@@ -535,14 +532,14 @@ Comm::DoSelect(int msec)
                     hdl(fd, F->read_data);
                     statCounter.select_fds++;
 
-                    if (commCheckICPIncoming)
-                        comm_select_icp_incoming();
+                    if (commCheckUdpIncoming)
+                        comm_select_udp_incoming();
 
-                    if (commCheckDNSIncoming)
+                    if (commCheckDnsIncoming)
                         comm_select_dns_incoming();
 
-                    if (commCheckHTTPIncoming)
-                        comm_select_http_incoming();
+                    if (commCheckTcpIncoming)
+                        comm_select_tcp_incoming();
                 }
             }
         }
@@ -573,8 +570,8 @@ Comm::DoSelect(int msec)
 
 #endif
 
-                if (fdIsIcp(fd)) {
-                    callicp = 1;
+                if (fdIsUdpListener(fd)) {
+                    calludp = 1;
                     continue;
                 }
 
@@ -583,8 +580,8 @@ Comm::DoSelect(int msec)
                     continue;
                 }
 
-                if (fdIsHttp(fd)) {
-                    callhttp = 1;
+                if (fdIsTcpListener(fd)) {
+                    calltcp = 1;
                     continue;
                 }
 
@@ -597,26 +594,26 @@ Comm::DoSelect(int msec)
                     hdl(fd, F->write_data);
                     statCounter.select_fds++;
 
-                    if (commCheckICPIncoming)
-                        comm_select_icp_incoming();
+                    if (commCheckUdpIncoming)
+                        comm_select_udp_incoming();
 
-                    if (commCheckDNSIncoming)
+                    if (commCheckDnsIncoming)
                         comm_select_dns_incoming();
 
-                    if (commCheckHTTPIncoming)
-                        comm_select_http_incoming();
+                    if (commCheckTcpIncoming)
+                        comm_select_tcp_incoming();
                 }
             }
         }
 
-        if (callicp)
-            comm_select_icp_incoming();
+        if (calludp)
+            comm_select_udp_incoming();
 
         if (calldns)
             comm_select_dns_incoming();
 
-        if (callhttp)
-            comm_select_http_incoming();
+        if (calltcp)
+            comm_select_tcp_incoming();
 
         getCurrentTime();
 
@@ -651,10 +648,10 @@ comm_select_dns_incoming(void)
     if (nevents < 0)
         return;
 
-    incoming_dns_interval += Config.comm_incoming.dns_average - nevents;
+    incoming_dns_interval += Config.comm_incoming.dns.average - nevents;
 
-    if (incoming_dns_interval < Config.comm_incoming.dns_min_poll)
-        incoming_dns_interval = Config.comm_incoming.dns_min_poll;
+    if (incoming_dns_interval < Config.comm_incoming.dns.min_poll)
+        incoming_dns_interval = Config.comm_incoming.dns.min_poll;
 
     if (incoming_dns_interval > MAX_INCOMING_INTERVAL)
         incoming_dns_interval = MAX_INCOMING_INTERVAL;
@@ -754,20 +751,20 @@ examine_select(fd_set * readfds, fd_set * writefds)
 static void
 commIncomingStats(StoreEntry * sentry)
 {
-    storeAppendPrintf(sentry, "Current incoming_icp_interval: %d\n",
-                      incoming_icp_interval >> INCOMING_FACTOR);
+    storeAppendPrintf(sentry, "Current incoming_udp_interval: %d\n",
+                      incoming_udp_interval >> INCOMING_FACTOR);
     storeAppendPrintf(sentry, "Current incoming_dns_interval: %d\n",
                       incoming_dns_interval >> INCOMING_FACTOR);
-    storeAppendPrintf(sentry, "Current incoming_http_interval: %d\n",
-                      incoming_http_interval >> INCOMING_FACTOR);
+    storeAppendPrintf(sentry, "Current incoming_tcp_interval: %d\n",
+                      incoming_tcp_interval >> INCOMING_FACTOR);
     storeAppendPrintf(sentry, "\n");
     storeAppendPrintf(sentry, "Histogram of events per incoming socket type\n");
-    storeAppendPrintf(sentry, "ICP Messages handled per comm_select_icp_incoming() call:\n");
-    statCounter.comm_icp_incoming.dump(sentry, statHistIntDumper);
+    storeAppendPrintf(sentry, "ICP Messages handled per comm_select_udp_incoming() call:\n");
+    statCounter.comm_udp_incoming.dump(sentry, statHistIntDumper);
     storeAppendPrintf(sentry, "DNS Messages handled per comm_select_dns_incoming() call:\n");
     statCounter.comm_dns_incoming.dump(sentry, statHistIntDumper);
-    storeAppendPrintf(sentry, "HTTP Messages handled per comm_select_http_incoming() call:\n");
-    statCounter.comm_http_incoming.dump(sentry, statHistIntDumper);
+    storeAppendPrintf(sentry, "HTTP Messages handled per comm_select_tcp_incoming() call:\n");
+    statCounter.comm_tcp_incoming.dump(sentry, statHistIntDumper);
 }
 
 void
@@ -35,6 +35,7 @@
 #if USE_SELECT_WIN32
 
 #include "squid-old.h"
+#include "anyp/PortCfg.h"
 #include "comm/Connection.h"
 #include "comm/Loops.h"
 #include "fde.h"
@@ -58,8 +59,8 @@ static int MAX_POLL_TIME = 1000;	/* see also Comm::QuickPollRequired() */
 
 /* STATIC */
 static int examine_select(fd_set *, fd_set *);
-static int fdIsHttp(int fd);
-static int fdIsIcp(int fd);
+static int fdIsTcpListener(int fd);
+static int fdIsUdpListener(int fd);
 static int fdIsDns(int fd);
 static OBJH commIncomingStats;
 static int comm_check_incoming_select_handlers(int nfds, int *fds);
@@ -83,13 +84,13 @@ static int nwritefds;
  * of incoming ICP, then we need to check these sockets more than
  * if we just have HTTP.
  *
- * The variables 'incoming_icp_interval' and 'incoming_http_interval'
+ * The variables 'incoming_udp_interval' and 'incoming_tcp_interval'
  * determine how many normal I/O events to process before checking
  * incoming sockets again.  Note we store the incoming_interval
  * multipled by a factor of (2^INCOMING_FACTOR) to have some
  * pseudo-floating point precision.
  *
- * The variable 'icp_io_events' and 'http_io_events' counts how many normal
+ * The variable 'udp_io_events' and 'tcp_io_events' counts how many normal
  * I/O events have been processed since the last check on the incoming
  * sockets.  When io_events > incoming_interval, its time to check incoming
  * sockets.
@@ -103,7 +104,7 @@ static int nwritefds;
  *
  *  incoming_interval = incoming_interval + target_average - number_of_events_processed
  *
- * There are separate incoming_interval counters for both HTTP and ICP events
+ * There are separate incoming_interval counters for DNS, UDP and TCP events
  *
  * You can see the current values of the incoming_interval's, as well as
  * a histogram of 'incoming_events' by asking the cache manager
@@ -125,15 +126,15 @@ static int nwritefds;
 #define MAX_INCOMING_INTEGER 256
 #define INCOMING_FACTOR 5
 #define MAX_INCOMING_INTERVAL (MAX_INCOMING_INTEGER << INCOMING_FACTOR)
-static int icp_io_events = 0;
+static int udp_io_events = 0;
 static int dns_io_events = 0;
-static int http_io_events = 0;
-static int incoming_icp_interval = 16 << INCOMING_FACTOR;
+static int tcp_io_events = 0;
+static int incoming_udp_interval = 16 << INCOMING_FACTOR;
 static int incoming_dns_interval = 16 << INCOMING_FACTOR;
-static int incoming_http_interval = 16 << INCOMING_FACTOR;
-#define commCheckICPIncoming (++icp_io_events > (incoming_icp_interval>> INCOMING_FACTOR))
-#define commCheckDNSIncoming (++dns_io_events > (incoming_dns_interval>> INCOMING_FACTOR))
-#define commCheckHTTPIncoming (++http_io_events > (incoming_http_interval>> INCOMING_FACTOR))
+static int incoming_tcp_interval = 16 << INCOMING_FACTOR;
+#define commCheckUdpIncoming (++udp_io_events > (incoming_udp_interval>> INCOMING_FACTOR))
+#define commCheckDnsIncoming (++dns_io_events > (incoming_dns_interval>> INCOMING_FACTOR))
+#define commCheckTcpIncoming (++tcp_io_events > (incoming_tcp_interval>> INCOMING_FACTOR))
 
 void
 Comm::SetSelect(int fd, unsigned int type, PF * handler, void *client_data, time_t timeout)
@@ -167,7 +168,7 @@ Comm::ResetSelect(int fd)
 }
 
 static int
-fdIsIcp(int fd)
+fdIsUdpListener(int fd)
 {
     if (icpIncomingConn != NULL && fd == icpIncomingConn->fd)
         return 1;
@@ -191,12 +192,10 @@ fdIsDns(int fd)
 }
 
 static int
-fdIsHttp(int fd)
+fdIsTcpListener(int fd)
 {
-    int j;
-
-    for (j = 0; j < NHttpSockets; j++) {
-        if (fd == HttpSockets[j])
+    for (const AnyP::PortCfg *s = Config.Sockaddr.http; s; s = s->next) {
+        if (s->listenConn != NULL && s->listenConn->fd == fd)
             return 1;
     }
 
@@ -275,12 +274,12 @@ comm_check_incoming_select_handlers(int nfds, int *fds)
 }
 
 static void
-comm_select_icp_incoming(void)
+comm_select_udp_incoming(void)
 {
     int nfds = 0;
     int fds[2];
     int nevents;
-    icp_io_events = 0;
+    udp_io_events = 0;
 
     if (Comm::IsConnOpen(icpIncomingConn))
         fds[nfds++] = icpIncomingConn->fd;
@@ -293,49 +292,48 @@ comm_select_icp_incoming(void)
 
     nevents = comm_check_incoming_select_handlers(nfds, fds);
 
-    incoming_icp_interval += Config.comm_incoming.icp_average - nevents;
+    incoming_udp_interval += Config.comm_incoming.udp_average - nevents;
 
-    if (incoming_icp_interval < 0)
-        incoming_icp_interval = 0;
+    if (incoming_udp_interval < 0)
+        incoming_udp_interval = 0;
 
-    if (incoming_icp_interval > MAX_INCOMING_INTERVAL)
-        incoming_icp_interval = MAX_INCOMING_INTERVAL;
+    if (incoming_udp_interval > MAX_INCOMING_INTERVAL)
+        incoming_udp_interval = MAX_INCOMING_INTERVAL;
 
-    if (nevents > INCOMING_ICP_MAX)
-        nevents = INCOMING_ICP_MAX;
+    if (nevents > INCOMING_UDP_MAX)
+        nevents = INCOMING_UDP_MAX;
 
-    statCounter.comm_icp_incoming.count(nevents);
+    statCounter.comm_udp_incoming.count(nevents);
 }
 
 static void
-comm_select_http_incoming(void)
+comm_select_tcp_incoming(void)
 {
     int nfds = 0;
-    int fds[MAXHTTPPORTS];
-    int j;
+    int fds[MAXTCPLISTENPORTS];
     int nevents;
-    http_io_events = 0;
+    tcp_io_events = 0;
 
-    for (j = 0; j < NHttpSockets; j++) {
-        if (HttpSockets[j] < 0)
-            continue;
+    // XXX: only poll sockets that won't be deferred. But how do we identify them?
 
-        fds[nfds++] = HttpSockets[j];
+    for (const AnyP::PortCfg *s = Config.Sockaddr.http; s; s = s->next) {
+        if (Comm::IsConnOpen(s->listenConn))
+            fds[nfds++] = s->listenConn->fd;
     }
 
     nevents = comm_check_incoming_select_handlers(nfds, fds);
-    incoming_http_interval += Config.comm_incoming.http_average - nevents;
+    incoming_tcp_interval += Config.comm_incoming.tcp_average - nevents;
 
-    if (incoming_http_interval < 0)
-        incoming_http_interval = 0;
+    if (incoming_tcp_interval < 0)
+        incoming_tcp_interval = 0;
 
-    if (incoming_http_interval > MAX_INCOMING_INTERVAL)
-        incoming_http_interval = MAX_INCOMING_INTERVAL;
+    if (incoming_tcp_interval > MAX_INCOMING_INTERVAL)
+        incoming_tcp_interval = MAX_INCOMING_INTERVAL;
 
-    if (nevents > INCOMING_HTTP_MAX)
-        nevents = INCOMING_HTTP_MAX;
+    if (nevents > INCOMING_TCP_MAX)
+        nevents = INCOMING_TCP_MAX;
 
-    statCounter.comm_http_incoming.count(nevents);
+    statCounter.comm_tcp_incoming.count(nevents);
 }
 
 #define DEBUG_FDBITS 0
@@ -352,8 +350,7 @@ Comm::DoSelect(int msec)
     int maxfd;
     int num;
     int pending;
-    int callicp = 0, callhttp = 0;
-    int calldns = 0;
+    int calldns = 0, callicp = 0, callhttp = 0;
     int j;
 #if DEBUG_FDBITS
 
@@ -372,16 +369,16 @@ Comm::DoSelect(int msec)
         getCurrentTime();
         start = current_dtime;
 
-        if (commCheckICPIncoming)
-            comm_select_icp_incoming();
+        if (commCheckUdpIncoming)
+            comm_select_udp_incoming();
 
-        if (commCheckDNSIncoming)
+        if (commCheckDnsIncoming)
             comm_select_dns_incoming();
 
-        if (commCheckHTTPIncoming)
-            comm_select_http_incoming();
+        if (commCheckTcpIncoming)
+            comm_select_tcp_incoming();
 
-        callicp = calldns = callhttp = 0;
+        calludp = calldns = calltcp = 0;
 
         maxfd = Biggest_FD + 1;
 
@@ -510,8 +507,8 @@ Comm::DoSelect(int msec)
 
 #endif
 
-            if (fdIsIcp(fd)) {
-                callicp = 1;
+            if (fdIsUdpListener(fd)) {
+                calludp = 1;
                 continue;
             }
 
@@ -520,31 +517,29 @@ Comm::DoSelect(int msec)
                 continue;
             }
 
-            if (fdIsHttp(fd)) {
-                callhttp = 1;
+            if (fdIsTcpListener(fd)) {
+                calltcp = 1;
                 continue;
             }
 
             F = &fd_table[fd];
             debugs(5, 6, "comm_select: FD " << fd << " ready for reading");
 
-            if (NULL == (hdl = F->read_handler))
-                (void) 0;
-            else {
+            if ((hdl = F->read_handler)) {
                 F->read_handler = NULL;
                 F->flags.read_pending = 0;
                 commUpdateReadBits(fd, NULL);
                 hdl(fd, F->read_data);
                 statCounter.select_fds++;
 
-                if (commCheckICPIncoming)
-                    comm_select_icp_incoming();
+                if (commCheckUdpIncoming)
+                    comm_select_udp_incoming();
 
-                if (commCheckDNSIncoming)
+                if (commCheckDnsIncoming)
                     comm_select_dns_incoming();
 
-                if (commCheckHTTPIncoming)
-                    comm_select_http_incoming();
+                if (commCheckTcpIncoming)
+                    comm_select_tcp_incoming();
             }
         }
 
@@ -596,8 +591,8 @@ Comm::DoSelect(int msec)
 
 #endif
 
-            if (fdIsIcp(fd)) {
-                callicp = 1;
+            if (fdIsUdpListener(fd)) {
+                calludp = 1;
                 continue;
             }
 
@@ -606,8 +601,8 @@ Comm::DoSelect(int msec)
                 continue;
             }
 
-            if (fdIsHttp(fd)) {
-                callhttp = 1;
+            if (fdIsTcpListener(fd)) {
+                calltcp = 1;
                 continue;
             }
 
@@ -620,25 +615,25 @@ Comm::DoSelect(int msec)
                 hdl(fd, F->write_data);
                 statCounter.select_fds++;
 
-                if (commCheckICPIncoming)
-                    comm_select_icp_incoming();
+                if (commCheckUdpIncoming)
+                    comm_select_udp_incoming();
 
-                if (commCheckDNSIncoming)
+                if (commCheckDnsIncoming)
                     comm_select_dns_incoming();
 
-                if (commCheckHTTPIncoming)
-                    comm_select_http_incoming();
+                if (commCheckTcpIncoming)
+                    comm_select_tcp_incoming();
             }
         }
 
-        if (callicp)
-            comm_select_icp_incoming();
+        if (calludp)
+            comm_select_udp_incoming();
 
         if (calldns)
             comm_select_dns_incoming();
 
-        if (callhttp)
-            comm_select_http_incoming();
+        if (calltcp)
+            comm_select_tcp_incoming();
 
         getCurrentTime();
 
@@ -673,10 +668,10 @@ comm_select_dns_incoming(void)
     if (nevents < 0)
         return;
 
-    incoming_dns_interval += Config.comm_incoming.dns_average - nevents;
+    incoming_dns_interval += Config.comm_incoming.dns.average - nevents;
 
-    if (incoming_dns_interval < Config.comm_incoming.dns_min_poll)
-        incoming_dns_interval = Config.comm_incoming.dns_min_poll;
+    if (incoming_dns_interval < Config.comm_incoming.dns.min_poll)
+        incoming_dns_interval = Config.comm_incoming.dns.min_poll;
 
     if (incoming_dns_interval > MAX_INCOMING_INTERVAL)
         incoming_dns_interval = MAX_INCOMING_INTERVAL;
@@ -776,20 +771,20 @@ examine_select(fd_set * readfds, fd_set * writefds)
 static void
 commIncomingStats(StoreEntry * sentry)
 {
-    storeAppendPrintf(sentry, "Current incoming_icp_interval: %d\n",
-                      incoming_icp_interval >> INCOMING_FACTOR);
+    storeAppendPrintf(sentry, "Current incoming_udp_interval: %d\n",
+                      incoming_udp_interval >> INCOMING_FACTOR);
     storeAppendPrintf(sentry, "Current incoming_dns_interval: %d\n",
                       incoming_dns_interval >> INCOMING_FACTOR);
-    storeAppendPrintf(sentry, "Current incoming_http_interval: %d\n",
-                      incoming_http_interval >> INCOMING_FACTOR);
+    storeAppendPrintf(sentry, "Current incoming_tcp_interval: %d\n",
+                      incoming_tcp_interval >> INCOMING_FACTOR);
     storeAppendPrintf(sentry, "\n");
     storeAppendPrintf(sentry, "Histogram of events per incoming socket type\n");
-    storeAppendPrintf(sentry, "ICP Messages handled per comm_select_icp_incoming() call:\n");
-    statCounter.comm_icp_incoming.dump(sentry, statHistIntDumper);
+    storeAppendPrintf(sentry, "ICP Messages handled per comm_select_udp_incoming() call:\n");
+    statCounter.comm_udp_incoming.dump(sentry, statHistIntDumper);
     storeAppendPrintf(sentry, "DNS Messages handled per comm_select_dns_incoming() call:\n");
     statCounter.comm_dns_incoming.dump(sentry, statHistIntDumper);
-    storeAppendPrintf(sentry, "HTTP Messages handled per comm_select_http_incoming() call:\n");
-    statCounter.comm_http_incoming.dump(sentry, statHistIntDumper);
+    storeAppendPrintf(sentry, "HTTP Messages handled per comm_select_tcp_incoming() call:\n");
+    statCounter.comm_tcp_incoming.dump(sentry, statHistIntDumper);
 }
 
 void
@@ -0,0 +1,27 @@
+#ifndef SQUID_COMM_UDPOPENDIALER_H
+#define SQUID_COMM_UDPOPENDIALER_H
+
+#include "ipc/StartListening.h"
+
+namespace Comm
+{
+
+/// dials a UDP port-opened call
+class UdpOpenDialer: public CallDialer,
+        public Ipc::StartListeningCb
+{
+public:
+    typedef void (*Handler)(const Comm::ConnectionPointer &conn, int errNo);
+    UdpOpenDialer(Handler aHandler): handler(aHandler) {}
+
+    virtual void print(std::ostream &os) const { startPrint(os) << ')'; }
+    virtual bool canDial(AsyncCall &) const { return true; }
+    virtual void dial(AsyncCall &) { (handler)(conn, errNo); }
+
+public:
+    Handler handler;
+};
+
+} // namespace Comm
+
+#endif /* SQUID_COMM_UDPOPENDIALER_H */
@@ -56,8 +56,6 @@
 #define ACL_ALLWEEK	0x7F
 #define ACL_WEEKDAYS	0x3E
 
-#define MAXHTTPPORTS			128
-
 /* Select types. */
 #define COMM_SELECT_READ   (0x1)
 #define COMM_SELECT_WRITE  (0x2)
@@ -208,33 +206,6 @@
 /* handy to determine the #elements in a static array */
 #define countof(arr) (sizeof(arr)/sizeof(*arr))
 
-/*
- * Max number of ICP messages to receive per call to icpHandleUdp
- */
-#if _SQUID_MSWIN_
-#define INCOMING_ICP_MAX 1
-#else
-#define INCOMING_ICP_MAX 15
-#endif
-/*
- * Max number of DNS messages to receive per call to DNS read handler
- */
-#if _SQUID_MSWIN_
-#define INCOMING_DNS_MAX 1
-#else
-#define INCOMING_DNS_MAX 15
-#endif
-/*
- * Max number of HTTP connections to accept per call to httpAccept
- * and PER HTTP PORT
- */
-#if _SQUID_MSWIN_
-#define INCOMING_HTTP_MAX 1
-#else
-#define INCOMING_HTTP_MAX 10
-#endif
-#define INCOMING_TOTAL_MAX (INCOMING_ICP_MAX+INCOMING_HTTP_MAX)
-
 /*
  * This many TCP connections must FAIL before we mark the
  * peer as DEAD
@@ -52,9 +52,7 @@ typedef enum {
     LOG_TCP_DENIED,
     LOG_TCP_DENIED_REPLY,
     LOG_TCP_OFFLINE_HIT,
-#if LOG_TCP_REDIRECTS
     LOG_TCP_REDIRECT,
-#endif
     LOG_UDP_HIT,
     LOG_UDP_MISS,
     LOG_UDP_DENIED,
@@ -158,9 +158,7 @@ Eui::Eui48::encode(char *buf, const int len)
 bool
 Eui::Eui48::lookup(const Ip::Address &c)
 {
-    struct arpreq arpReq;
 #if !_SQUID_WINDOWS_
-    struct sockaddr_in *sa = NULL;
 #endif /* !_SQUID_WINDOWS_ */
 
     Ip::Address ipAddr = c;
@@ -192,9 +190,10 @@ Eui::Eui48::lookup(const Ip::Address &c)
     /*
      * Set up structures for ARP lookup with blank interface name
      */
+    struct arpreq arpReq;
     memset(&arpReq, '\0', sizeof(arpReq));
 
-    sa = (sockaddr_in*)&arpReq.arp_pa;
+    struct sockaddr_in *sa = (struct sockaddr_in*)&arpReq.arp_pa;
     ipAddr.GetSockAddr(*sa);
 
     /* Query ARP table */
@@ -316,10 +315,10 @@ Eui::Eui48::lookup(const Ip::Address &c)
     int tmpSocket = socket(AF_INET,SOCK_STREAM,0);
 
     /* Set up structures for ARP lookup with blank interface name */
-
+    struct arpreq arpReq;
     memset(&arpReq, '\0', sizeof(arpReq));
 
-    sa = (sockaddr_in*)&arpReq.arp_pa;
+    struct sockaddr_in *sa = (struct sockaddr_in*)&arpReq.arp_pa;
     ipAddr.GetSockAddr(*sa);
 
     /* Query ARP table */
@@ -368,10 +367,10 @@ Eui::Eui48::lookup(const Ip::Address &c)
     /*
     * Set up structures for ARP lookup with blank interface name
     */
-
+    struct arpreq arpReq;
     memset(&arpReq, '\0', sizeof(arpReq));
 
-    sa = (struct sockaddr_in*) &arpReq.arp_pa;
+    struct sockaddr_in *sa = (struct sockaddr_in*)&arpReq.arp_pa;
     ipAddr.GetSockAddr(*sa);
 
     /* Query ARP table */
@@ -460,6 +459,7 @@ Eui::Eui48::lookup(const Ip::Address &c)
 
     DWORD            i;
 
+    struct arpreq arpReq;
     memset(&arpReq, '\0', sizeof(arpReq));
 
     /* Get size of Windows ARP table */
@@ -871,11 +871,9 @@ ACLExternal::match(ACLChecklist *checklist)
     // convert to tri-state ACL match 1,0,-1
     switch (answer) {
     case ACCESS_ALLOWED:
-    case ACCESS_AUTH_EXPIRED_OK:
         return 1; // match
 
     case ACCESS_DENIED:
-    case ACCESS_AUTH_EXPIRED_BAD:
         return 0; // non-match
 
     case ACCESS_DUNNO:
@@ -20,9 +20,7 @@ const char *Format::log_tags[] = {
     "TCP_DENIED",
     "TCP_DENIED_REPLY",
     "TCP_OFFLINE_HIT",
-#if LOG_TCP_REDIRECTS
     "TCP_REDIRECT",
-#endif
     "UDP_HIT",
     "UDP_MISS",
     "UDP_DENIED",
@@ -35,6 +35,7 @@
 #include "forward.h"
 #include "acl/FilledChecklist.h"
 #include "acl/Gadgets.h"
+#include "anyp/PortCfg.h"
 #include "CacheManager.h"
 #include "comm/Connection.h"
 #include "comm/ConnOpener.h"
@@ -50,7 +51,6 @@
 #include "MemObject.h"
 #include "pconn.h"
 #include "PeerSelectState.h"
-#include "ProtoPort.h"
 #include "SquidTime.h"
 #include "Store.h"
 #include "icmp/net_db.h"
@@ -804,9 +804,8 @@ UFSSwapDir::openTmpSwapLog(int *clean_flag, int *zero_flag)
         buf.init(header.record_size, header.record_size);
         buf.append(reinterpret_cast<const char*>(&header), sizeof(header));
         // Pad to keep in sync with UFSSwapDir::writeCleanStart().
-        // TODO: When MemBuf::spaceSize() is fixed not to subtract one,
-        // memset() space() with zeroes and use spaceSize() below.
-        buf.appended(static_cast<size_t>(header.record_size) - sizeof(header));
+        memset(buf.space(), 0, header.gapSize());
+        buf.appended(header.gapSize());
         file_write(swaplog_fd, -1, buf.content(), buf.contentSize(),
                    NULL, NULL, buf.freeFunc());
     }
@@ -895,6 +894,7 @@ UFSSwapDir::writeCleanStart()
     /*copy the header */
     memcpy(state->outbuf, &header, sizeof(StoreSwapLogHeader));
     // Leave a gap to keep in sync with UFSSwapDir::openTmpSwapLog().
+    memset(state->outbuf + sizeof(StoreSwapLogHeader), 0, header.gapSize());
     state->outbuf_offset += header.record_size;
 
     state->walker = repl->WalkInit(repl);
@@ -944,6 +944,7 @@ UFSCleanLog::write(StoreEntry const &e)
     s.refcount = e.refcount;
     s.flags = e.flags;
     memcpy(&s.key, e.key, SQUID_MD5_DIGEST_LENGTH);
+    s.finalize();
     memcpy(outbuf + outbuf_offset, &s, ss);
     outbuf_offset += ss;
     /* buffered write */
@@ -1052,6 +1053,7 @@ UFSSwapDir::logEntry(const StoreEntry & e, int op) const
     s->refcount = e.refcount;
     s->flags = e.flags;
     memcpy(s->key, e.key, SQUID_MD5_DIGEST_LENGTH);
+    s->finalize();
     file_write(swaplog_fd,
                -1,
                s,
@@ -95,6 +95,7 @@ class UFSSwapLogParser_v1_32bs:public UFSSwapLogParser
     }
 };
 
+#if UNUSED_CODE
 /// Parse a swap header entry created on a system with 32-bit size_t, time_t and sfileno
 /// this is typical of 32-bit systems without large file support and with old kernels
 /// NP: SQUID_MD5_DIGEST_LENGTH is very risky still.
@@ -213,6 +214,20 @@ bool UFSSwapLogParser_v1::ReadRecord(StoreSwapLogData &swapData)
     }
     return true;
 }
+#endif /* UNUSED_CODE */
+
+/// swap.state v2 log parser
+class UFSSwapLogParser_v2: public UFSSwapLogParser
+{
+public:
+    UFSSwapLogParser_v2(FILE *fp): UFSSwapLogParser(fp) {
+        record_size = sizeof(StoreSwapLogData);
+    }
+    bool ReadRecord(StoreSwapLogData &swapData) {
+        assert(log);
+        return fread(&swapData, sizeof(StoreSwapLogData), 1, log) == 1;
+    }
+};
 
 
 UFSSwapLogParser *UFSSwapLogParser::GetUFSSwapLogParser(FILE *fp)
@@ -230,10 +245,18 @@ UFSSwapLogParser *UFSSwapLogParser::GetUFSSwapLogParser(FILE *fp)
         return new UFSSwapLogParser_v1_32bs(fp); // Um. 32-bits except time_t, and can't determine that.
     }
 
+    debugs(47, 2, "Swap file version: " << header.version);
+
     if (header.version == 1) {
         if (fseek(fp, header.record_size, SEEK_SET) != 0)
             return NULL;
 
+        debugs(47, DBG_IMPORTANT, "Rejecting swap file v1 to avoid cache " <<
+               "index corruption. Forcing a full cache index rebuild. " <<
+               "See Squid bug #3441.");
+        return NULL;
+
+#if UNUSED_CODE
         // baseline
         // 32-bit sfileno
         // native time_t (hopefully 64-bit)
@@ -272,11 +295,26 @@ UFSSwapLogParser *UFSSwapLogParser::GetUFSSwapLogParser(FILE *fp)
         debugs(47, 1, "WARNING: The swap file has wrong format!... ");
         debugs(47, 1, "NOTE: Cannot safely downgrade caches to short (32-bit) timestamps.");
         return NULL;
+#endif
     }
 
-    // XXX: version 2 of swapfile. This time use fixed-bit sizes for everything!!
-    // and preferrably write to disk in network-order bytes for the larger fields.
+    if (header.version >= 2) {
+        if (!header.sane()) {
+            debugs(47, DBG_IMPORTANT, "ERROR: Corrupted v" << header.version <<
+                   " swap file header.");
+            return NULL;
+        }
+
+        if (fseek(fp, header.record_size, SEEK_SET) != 0)
+            return NULL;
 
+        if (header.version == 2)
+            return new UFSSwapLogParser_v2(fp);
+    }
+
+    // TODO: v3: write to disk in network-order bytes for the larger fields?
+
+    debugs(47, DBG_IMPORTANT, "Unknown swap file version: " << header.version);
     return NULL;
 }
 
@@ -327,7 +365,8 @@ RebuildState::RebuildState (RefCount<UFSSwapDir> aSwapDir) : sd (aSwapDir),LogPa
     if (!clean)
         flags.need_to_validate = 1;
 
-    debugs(47, 1, "Rebuilding storage in " << sd->path << " (" << (clean ? "CLEAN" : "DIRTY") << ")");
+    debugs(47, DBG_IMPORTANT, "Rebuilding storage in " << sd->path << " (" <<
+           (clean ? "clean log" : (LogParser ? "dirty log" : "no log")) << ")");
 }
 
 RebuildState::~RebuildState()
@@ -407,7 +446,8 @@ RebuildState::rebuildFromDirectory()
     fd = getNextFile(&filn, &size);
 
     if (fd == -2) {
-        debugs(47, 1, "Done scanning " << sd->path << " swaplog (" << n_read << " entries)");
+        debugs(47, DBG_IMPORTANT, "Done scanning " << sd->path << " dir (" <<
+               n_read << " entries)");
         _done = true;
         return;
     } else if (fd < 0) {
@@ -417,6 +457,8 @@ RebuildState::rebuildFromDirectory()
     assert(fd > -1);
     /* lets get file stats here */
 
+    n_read++;
+
     if (fstat(fd, &sb) < 0) {
         debugs(47, 1, "commonUfsDirRebuildFromDirectory: fstat(FD " << fd << "): " << xstrerror());
         file_close(fd);
@@ -38,7 +38,7 @@
 
 #include "rfc2181.h"
 
-/* for ERROR_BUF_SZ, BUFSIZ, MAXHTTPPORTS */
+/* for ERROR_BUF_SZ, BUFSIZ */
 #include "defines.h"
 
 /* for iostats */
@@ -78,9 +78,7 @@ extern "C" {
     extern int Biggest_FD;		/* -1 */
     extern int Number_FD;		/* 0 */
     extern int Opening_FD;		/* 0 */
-    extern int HttpSockets[MAXHTTPPORTS];
     extern int NDnsServersAlloc;	/* 0 */
-    extern int NHttpSockets;	/* 0 */
     extern int RESERVED_FD;
     extern int Squid_MaxFD;		/* SQUID_MAXFD */
     extern int config_lineno;	/* 0 */
@@ -38,12 +38,13 @@
 #include "acl/FilledChecklist.h"
 #include "acl/Acl.h"
 #include "comm.h"
+#include "comm/Connection.h"
 #include "comm/Loops.h"
+#include "comm/UdpOpenDialer.h"
 #include "htcp.h"
 #include "http.h"
 #include "HttpRequest.h"
 #include "icmp/net_db.h"
-#include "ipc/StartListening.h"
 #include "ip/tools.h"
 #include "MemBuf.h"
 #include "SquidTime.h"
@@ -52,22 +53,6 @@
 #include "StoreClient.h"
 #include "compat/xalloc.h"
 
-/// dials htcpIncomingConnectionOpened call
-class HtcpListeningStartedDialer: public CallDialer,
-        public Ipc::StartListeningCb
-{
-public:
-    typedef void (*Handler)(int errNo);
-    HtcpListeningStartedDialer(Handler aHandler): handler(aHandler) {}
-
-    virtual void print(std::ostream &os) const { startPrint(os) << ')'; }
-    virtual bool canDial(AsyncCall &) const { return true; }
-    virtual void dial(AsyncCall &) { (handler)(errNo); }
-
-public:
-    Handler handler;
-};
-
 typedef struct _Countstr Countstr;
 
 typedef struct _htcpHeader htcpHeader;
@@ -246,7 +231,7 @@ enum {
     RR_RESPONSE
 };
 
-static void htcpIncomingConnectionOpened(int errNo);
+static void htcpIncomingConnectionOpened(const Comm::ConnectionPointer &conn, int errNo);
 static uint32_t msg_id_counter = 0;
 
 static Comm::ConnectionPointer htcpOutgoingConn = NULL;
@@ -1485,7 +1470,7 @@ htcpRecv(int fd, void *data)
  */
 
 void
-htcpInit(void)
+htcpOpenPorts(void)
 {
     if (Config.Port.htcp <= 0) {
         debugs(31, DBG_IMPORTANT, "HTCP Disabled.");
@@ -1507,7 +1492,7 @@ htcpInit(void)
 
     AsyncCall::Pointer call = asyncCall(31, 2,
                                         "htcpIncomingConnectionOpened",
-                                        HtcpListeningStartedDialer(&htcpIncomingConnectionOpened));
+                                        Comm::UdpOpenDialer(&htcpIncomingConnectionOpened));
 
     Ipc::StartListening(SOCK_DGRAM,
                         IPPROTO_UDP,
@@ -1546,17 +1531,17 @@ htcpInit(void)
 }
 
 static void
-htcpIncomingConnectionOpened(int)
+htcpIncomingConnectionOpened(const Comm::ConnectionPointer &conn, int)
 {
-    if (!Comm::IsConnOpen(htcpIncomingConn))
+    if (!Comm::IsConnOpen(conn))
         fatal("Cannot open HTCP Socket");
 
-    Comm::SetSelect(htcpIncomingConn->fd, COMM_SELECT_READ, htcpRecv, NULL, 0);
+    Comm::SetSelect(conn->fd, COMM_SELECT_READ, htcpRecv, NULL, 0);
 
-    debugs(31, DBG_CRITICAL, "Accepting HTCP messages on " << htcpIncomingConn->local);
+    debugs(31, DBG_CRITICAL, "Accepting HTCP messages on " << conn->local);
 
     if (Config.Addrs.udp_outgoing.IsNoAddr()) {
-        htcpOutgoingConn = htcpIncomingConn;
+        htcpOutgoingConn = conn;
         debugs(31, DBG_IMPORTANT, "Sending HTCP messages from " << htcpOutgoingConn->local);
     }
 }
@@ -1719,7 +1704,7 @@ htcpSocketShutdown(void)
 }
 
 void
-htcpSocketClose(void)
+htcpClosePorts(void)
 {
     htcpSocketShutdown();
 
@@ -62,7 +62,7 @@ typedef class HtcpReplyData htcpReplyData;
 SQUIDCEXTERN void neighborsHtcpReply(const cache_key *, htcpReplyData *, const Ip::Address &);
 
 /// \ingroup ServerProtocolHTCP
-SQUIDCEXTERN void htcpInit(void);
+SQUIDCEXTERN void htcpOpenPorts(void);
 
 /**
  * \ingroup ServerProtocolHTCP
@@ -86,7 +86,7 @@ SQUIDCEXTERN void htcpClear(StoreEntry * e, const char *uri, HttpRequest * req,
 SQUIDCEXTERN void htcpSocketShutdown(void);
 
 /// \ingroup ServerProtocolHTCP
-SQUIDCEXTERN void htcpSocketClose(void);
+SQUIDCEXTERN void htcpClosePorts(void);
 
 #endif /* USE_HTCP */
 
@@ -412,6 +412,7 @@ HttpStateData::cacheableReply()
     case HTTP_MULTIPLE_CHOICES:
 
     case HTTP_MOVED_PERMANENTLY:
+    case HTTP_PERMANENT_REDIRECT:
 
     case HTTP_GONE:
         /*
@@ -38,9 +38,10 @@
 #include "squid-old.h"
 #include "Store.h"
 #include "comm.h"
+#include "comm/Connection.h"
 #include "comm/Loops.h"
+#include "comm/UdpOpenDialer.h"
 #include "ICP.h"
-#include "comm/Connection.h"
 #include "HttpRequest.h"
 #include "acl/FilledChecklist.h"
 #include "acl/Acl.h"
@@ -52,28 +53,10 @@
 #include "icmp/net_db.h"
 #include "ip/Address.h"
 #include "ip/tools.h"
-#include "ipc/StartListening.h"
 #include "ipcache.h"
 #include "rfc1738.h"
 
-/// dials icpIncomingConnectionOpened call
-class IcpListeningStartedDialer: public CallDialer,
-        public Ipc::StartListeningCb
-{
-public:
-    typedef void (*Handler)(int errNo);
-    IcpListeningStartedDialer(Handler aHandler):
-            handler(aHandler) {}
-
-    virtual void print(std::ostream &os) const { startPrint(os) << ')'; }
-    virtual bool canDial(AsyncCall &) const { return true; }
-    virtual void dial(AsyncCall &) { (handler)(errNo); }
-
-public:
-    Handler handler;
-};
-
-static void icpIncomingConnectionOpened(int errNo);
+static void icpIncomingConnectionOpened(const Comm::ConnectionPointer &conn, int errNo);
 
 /// \ingroup ServerProtocolICPInternal2
 static void icpLogIcp(const Ip::Address &, log_type, int, const char *, int);
@@ -612,7 +595,7 @@ icpHandleUdp(int sock, void *data)
     LOCAL_ARRAY(char, buf, SQUID_UDP_SO_RCVBUF);
     int len;
     int icp_version;
-    int max = INCOMING_ICP_MAX;
+    int max = INCOMING_UDP_MAX;
     Comm::SetSelect(sock, COMM_SELECT_READ, icpHandleUdp, NULL, 0);
 
     while (max--) {
@@ -674,7 +657,7 @@ icpHandleUdp(int sock, void *data)
 }
 
 void
-icpConnectionsOpen(void)
+icpOpenPorts(void)
 {
     uint16_t port;
 
@@ -696,7 +679,7 @@ icpConnectionsOpen(void)
 
     AsyncCall::Pointer call = asyncCall(12, 2,
                                         "icpIncomingConnectionOpened",
-                                        IcpListeningStartedDialer(&icpIncomingConnectionOpened));
+                                        Comm::UdpOpenDialer(&icpIncomingConnectionOpened));
 
     Ipc::StartListening(SOCK_DGRAM,
                         IPPROTO_UDP,
@@ -732,22 +715,22 @@ icpConnectionsOpen(void)
 }
 
 static void
-icpIncomingConnectionOpened(int errNo)
+icpIncomingConnectionOpened(const Comm::ConnectionPointer &conn, int errNo)
 {
-    if (!Comm::IsConnOpen(icpIncomingConn))
+    if (!Comm::IsConnOpen(conn))
         fatal("Cannot open ICP Port");
 
-    Comm::SetSelect(icpIncomingConn->fd, COMM_SELECT_READ, icpHandleUdp, NULL, 0);
+    Comm::SetSelect(conn->fd, COMM_SELECT_READ, icpHandleUdp, NULL, 0);
 
     for (const wordlist *s = Config.mcast_group_list; s; s = s->next)
-        ipcache_nbgethostbyname(s->key, mcastJoinGroups, NULL); // XXX: pass the icpIncomingConn for mcastJoinGroups usage.
+        ipcache_nbgethostbyname(s->key, mcastJoinGroups, NULL); // XXX: pass the conn for mcastJoinGroups usage.
 
-    debugs(12, DBG_IMPORTANT, "Accepting ICP messages on " << icpIncomingConn->local);
+    debugs(12, DBG_IMPORTANT, "Accepting ICP messages on " << conn->local);
 
-    fd_note(icpIncomingConn->fd, "Incoming ICP port");
+    fd_note(conn->fd, "Incoming ICP port");
 
     if (Config.Addrs.udp_outgoing.IsNoAddr()) {
-        icpOutgoingConn = icpIncomingConn;
+        icpOutgoingConn = conn;
         debugs(12, DBG_IMPORTANT, "Sending ICP messages from " << icpOutgoingConn->local);
     }
 }
@@ -782,7 +765,7 @@ icpConnectionShutdown(void)
 }
 
 void
-icpConnectionClose(void)
+icpClosePorts(void)
 {
     icpConnectionShutdown();
 
@@ -667,13 +667,12 @@ serverConnectionsOpen(void)
     // start various proxying services if we are responsible for them
     if (IamWorkerProcess()) {
         clientOpenListenSockets();
-        icpConnectionsOpen();
+        icpOpenPorts();
 #if USE_HTCP
-
-        htcpInit();
+        htcpOpenPorts();
 #endif
 #if SQUID_SNMP
-        snmpConnectionOpen();
+        snmpOpenPorts();
 #endif
 
         clientdbInit();
@@ -710,13 +709,12 @@ serverConnectionsClose(void)
         clientHttpConnectionsClose();
         icpConnectionShutdown();
 #if USE_HTCP
-
         htcpSocketShutdown();
 #endif
 
         icmpEngine.Close();
 #if SQUID_SNMP
-        snmpConnectionClose();
+        snmpClosePorts();
 #endif
 
         asnFreeMemory();
@@ -731,10 +729,9 @@ mainReconfigureStart(void)
 
     // Initiate asynchronous closing sequence
     serverConnectionsClose();
-    icpConnectionClose();
+    icpClosePorts();
 #if USE_HTCP
-
-    htcpSocketClose();
+    htcpClosePorts();
 #endif
     dnsShutdown();
 #if USE_SSL_CRTD
@@ -1832,13 +1829,12 @@ SquidShutdown()
 #endif
     redirectShutdown();
     externalAclShutdown();
-    icpConnectionClose();
+    icpClosePorts();
 #if USE_HTCP
-
-    htcpSocketClose();
+    htcpClosePorts();
 #endif
 #if SQUID_SNMP
-    snmpConnectionClose();
+    snmpClosePorts();
 #endif
 #if USE_WCCP
 
@@ -31,8 +31,8 @@
  */
 
 #include "squid-old.h"
-#include "ProtoPort.h"
 #include "acl/FilledChecklist.h"
+#include "anyp/PortCfg.h"
 #include "comm/Connection.h"
 #include "comm/ConnOpener.h"
 #include "event.h"
@@ -540,13 +540,12 @@ neighbors_init(void)
     if (Comm::IsConnOpen(icpIncomingConn)) {
 
         for (thisPeer = Config.peers; thisPeer; thisPeer = next) {
-            http_port_list *s = NULL;
             next = thisPeer->next;
 
             if (0 != strcmp(thisPeer->host, me))
                 continue;
 
-            for (s = Config.Sockaddr.http; s; s = s->next) {
+            for (AnyP::PortCfg *s = Config.Sockaddr.http; s; s = s->next) {
                 if (thisPeer->http_port != s->s.GetPort())
                     continue;
 
@@ -629,7 +628,8 @@ neighborsUdpPing(HttpRequest * request,
             }
 
             debugs(15, 3, "neighborsUdpPing: sending HTCP query");
-            if (htcpQuery(entry, request, p) <= 0) continue; // unable to send.
+            if (htcpQuery(entry, request, p) <= 0)
+                continue; // unable to send.
         } else
 #endif
         {
@@ -188,8 +188,6 @@ peerCheckNeverDirectDone(allow_t answer, void *data)
     case ACCESS_DUNNO:  // not relevant.
         break;
     case ACCESS_AUTH_REQUIRED:
-    case ACCESS_AUTH_EXPIRED_OK:
-    case ACCESS_AUTH_EXPIRED_BAD:
         debugs(44, DBG_IMPORTANT, "WARNING: never_direct resulted in " << answer << ". Username ACLs are not reliable here.");
         break;
     }
@@ -213,8 +211,6 @@ peerCheckAlwaysDirectDone(allow_t answer, void *data)
     case ACCESS_DUNNO:  // not relevant.
         break;
     case ACCESS_AUTH_REQUIRED:
-    case ACCESS_AUTH_EXPIRED_OK:
-    case ACCESS_AUTH_EXPIRED_BAD:
         debugs(44, DBG_IMPORTANT, "WARNING: always_direct resulted in " << answer << ". Username ACLs are not reliable here.");
         break;
     }
@@ -239,8 +239,8 @@ SQUIDCEXTERN int httpReqHdrManglersConfigured();
 #if SQUID_SNMP
 SQUIDCEXTERN PF snmpHandleUdp;
 SQUIDCEXTERN void snmpInit(void);
-SQUIDCEXTERN void snmpConnectionOpen(void);
-SQUIDCEXTERN void snmpConnectionClose(void);
+SQUIDCEXTERN void snmpOpenPorts(void);
+SQUIDCEXTERN void snmpClosePorts(void);
 SQUIDCEXTERN const char * snmpDebugOid(oid * Name, snint Len, MemBuf &outbuf);
 
 SQUIDCEXTERN void addr2oid(Ip::Address &addr, oid *Dest);
@@ -35,34 +35,14 @@
 #include "comm.h"
 #include "comm/Connection.h"
 #include "comm/Loops.h"
-#include "ipc/StartListening.h"
+#include "comm/UdpOpenDialer.h"
 #include "ip/Address.h"
 #include "ip/tools.h"
 #include "snmp_core.h"
 #include "snmp/Forwarder.h"
 
-
-/// dials snmpConnectionOpened call
-class SnmpListeningStartedDialer: public CallDialer,
-        public Ipc::StartListeningCb
-{
-public:
-    typedef void (*Handler)(const Comm::ConnectionPointer &conn, int errNo);
-    SnmpListeningStartedDialer(Handler aHandler): handler(aHandler) {}
-
-    virtual void print(std::ostream &os) const { startPrint(os) << ')'; }
-
-    virtual bool canDial(AsyncCall &) const { return true; }
-    virtual void dial(AsyncCall &) { (handler)(conn, errNo); }
-
-public:
-    Handler handler;
-};
-
-
 static void snmpPortOpened(const Comm::ConnectionPointer &conn, int errNo);
 
-
 mib_tree_entry *mib_tree_head;
 mib_tree_entry *mib_tree_last;
 
@@ -287,7 +267,7 @@ snmpInit(void)
 }
 
 void
-snmpConnectionOpen(void)
+snmpOpenPorts(void)
 {
     debugs(49, 5, "snmpConnectionOpen: Called");
 
@@ -308,7 +288,7 @@ snmpConnectionOpen(void)
     }
 
     AsyncCall::Pointer call = asyncCall(49, 2, "snmpIncomingConnectionOpened",
-                                        SnmpListeningStartedDialer(&snmpPortOpened));
+                                        Comm::UdpOpenDialer(&snmpPortOpened));
     Ipc::StartListening(SOCK_DGRAM, IPPROTO_UDP, snmpIncomingConn, Ipc::fdnInSnmpSocket, call);
 
     if (!Config.Addrs.snmp_outgoing.IsNoAddr()) {
@@ -325,7 +305,7 @@ snmpConnectionOpen(void)
             snmpOutgoingConn->local.SetIPv4();
         }
         AsyncCall::Pointer call = asyncCall(49, 2, "snmpOutgoingConnectionOpened",
-                                            SnmpListeningStartedDialer(&snmpPortOpened));
+                                            Comm::UdpOpenDialer(&snmpPortOpened));
         Ipc::StartListening(SOCK_DGRAM, IPPROTO_UDP, snmpOutgoingConn, Ipc::fdnOutSnmpSocket, call);
     } else {
         snmpOutgoingConn = snmpIncomingConn;
@@ -350,7 +330,7 @@ snmpPortOpened(const Comm::ConnectionPointer &conn, int errNo)
 }
 
 void
-snmpConnectionClose(void)
+snmpClosePorts(void)
 {
     if (Comm::IsConnOpen(snmpIncomingConn)) {
         debugs(49, DBG_IMPORTANT, "Closing SNMP receiving port " << snmpIncomingConn->local);
@@ -3,7 +3,7 @@
  */
 
 #include "squid.h"
-#include "ProtoPort.h"
+#include "anyp/PortCfg.h"
 #include "ssl/Config.h"
 #include "ssl/helper.h"
 #include "SquidTime.h"
@@ -28,12 +28,15 @@ void Ssl::Helper::Init()
 {
     assert(ssl_crtd == NULL);
 
-    bool found = false;
-    for (http_port_list *s = ::Config.Sockaddr.http; s && !found; s = s->next)
-        found = s->sslBump;
-    for (http_port_list *s = ::Config.Sockaddr.https; s && !found; s = s->next)
-        found = s->sslBump;
-    if (!found)
+    bool useSslBump = false;
+    for (AnyP::PortCfg *s = ::Config.Sockaddr.http; s; s = s->next) {
+        if (s->sslBump) {
+            useSslBump = true;
+            break;
+        }
+    }
+
+    if (!useSslBump)
         return;
 
     ssl_crtd = new helper("ssl_crtd");
@@ -427,6 +427,16 @@ ssl_options[] = {
     {
         "NO_TLSv1", SSL_OP_NO_TLSv1
     },
+#endif
+#if SSL_OP_NO_TLSv1_1
+    {
+        "NO_TLSv1_1", SSL_OP_NO_TLSv1_1
+    },
+#endif
+#if SSL_OP_NO_TLSv1_2
+    {
+        "NO_TLSv1_2", SSL_OP_NO_TLSv1_2
+    },
 #endif
     {
         "", 0
@@ -741,6 +751,26 @@ sslCreateServerContext(const char *certfile, const char *keyfile, int version, c
         method = TLSv1_server_method();
         break;
 
+    case 5:
+#if OPENSSL_VERSION_NUMBER >= 0x10001000L  // NP: not sure exactly which sub-version yet.
+        debugs(83, 5, "Using TLSv1.1.");
+        method = TLSv1_1_server_method();
+#else
+        debugs(83, DBG_IMPORTANT, "TLSv1.1 is not available in this Proxy.");
+        return NULL;
+#endif
+        break;
+
+    case 6:
+#if OPENSSL_VERSION_NUMBER >= 0x10001000L // NP: not sure exactly which sub-version yet.
+        debugs(83, 5, "Using TLSv1.2");
+        method = TLSv1_2_server_method();
+#else
+        debugs(83, DBG_IMPORTANT, "TLSv1.2 is not available in this Proxy.");
+        return NULL;
+#endif
+        break;
+
     case 1:
 
     default:
@@ -941,6 +971,26 @@ sslCreateClientContext(const char *certfile, const char *keyfile, int version, c
         method = TLSv1_client_method();
         break;
 
+    case 5:
+#if OPENSSL_VERSION_NUMBER >= 0x10001000L  // NP: not sure exactly which sub-version yet.
+        debugs(83, 5, "Using TLSv1.1.");
+        method = TLSv1_1_client_method();
+#else
+        debugs(83, DBG_IMPORTANT, "TLSv1.1 is not available in this Proxy.");
+        return NULL;
+#endif
+        break;
+
+    case 6:
+#if OPENSSL_VERSION_NUMBER >= 0x10001000L // NP: not sure exactly which sub-version yet.
+        debugs(83, 5, "Using TLSv1.2");
+        method = TLSv1_2_client_method();
+#else
+        debugs(83, DBG_IMPORTANT, "TLSv1.2 is not available in this Proxy.");
+        return NULL;
+#endif
+        break;
+
     case 1:
 
     default:
@@ -33,6 +33,7 @@
  */
 
 #include "squid-old.h"
+#include "comm/Loops.h"
 #include "event.h"
 #include "format/Token.h"
 #include "StoreClient.h"
@@ -1504,9 +1505,9 @@ statCountersInitSpecial(StatCounters * C)
      * Cache Digest Stuff
      */
     C->cd.on_xition_count.enumInit(CacheDigestHashFuncCount);
-    C->comm_icp_incoming.enumInit(INCOMING_ICP_MAX);
+    C->comm_udp_incoming.enumInit(INCOMING_UDP_MAX);
     C->comm_dns_incoming.enumInit(INCOMING_DNS_MAX);
-    C->comm_http_incoming.enumInit(INCOMING_HTTP_MAX);
+    C->comm_tcp_incoming.enumInit(INCOMING_TCP_MAX);
     C->select_fds_hist.enumInit(256);	/* was SQUID_MAXFD, but it is way too much. It is OK to crop this statistics */
 }
 
@@ -1524,9 +1525,9 @@ statCountersClean(StatCounters * C)
     C->icp.replySvcTime.clear();
     C->dns.svcTime.clear();
     C->cd.on_xition_count.clear();
-    C->comm_icp_incoming.clear();
+    C->comm_udp_incoming.clear();
     C->comm_dns_incoming.clear();
-    C->comm_http_incoming.clear();
+    C->comm_tcp_incoming.clear();
     C->select_fds_hist.clear();
 }
 
@@ -1551,8 +1552,9 @@ statCountersCopy(StatCounters * dest, const StatCounters * orig)
     dest->icp.replySvcTime=orig->icp.replySvcTime;
     dest->dns.svcTime=orig->dns.svcTime;
     dest->cd.on_xition_count=orig->cd.on_xition_count;
-    dest->comm_icp_incoming=orig->comm_icp_incoming;
-    dest->comm_http_incoming=orig->comm_http_incoming;
+    dest->comm_udp_incoming=orig->comm_udp_incoming;
+    dest->comm_dns_incoming=orig->comm_dns_incoming;
+    dest->comm_tcp_incoming=orig->comm_tcp_incoming;
     dest->select_fds_hist=orig->select_fds_hist;
 }
 
@@ -274,10 +274,8 @@ StoreEntry::delayAwareRead(const Comm::ConnectionPointer &conn, char *buf, int l
 size_t
 StoreEntry::bytesWanted (Range<size_t> const aRange) const
 {
-    assert (aRange.size());
-
     if (mem_obj == NULL)
-        return aRange.end - 1;
+        return aRange.end;
 
 #if URL_CHECKSUM_DEBUG
 
@@ -287,12 +285,12 @@ StoreEntry::bytesWanted (Range<size_t> const aRange) const
 
     /* Always read *something* here - we haven't got the header yet */
     if (EBIT_TEST(flags, ENTRY_FWD_HDR_WAIT))
-        return aRange.end - 1;
+        return aRange.end;
 
     if (!mem_obj->readAheadPolicyCanRead())
         return 0;
 
-    return mem_obj->mostBytesWanted(aRange.end - 1);
+    return mem_obj->mostBytesWanted(aRange.end);
 }
 
 bool
@@ -145,7 +145,10 @@ class CpuAffinityMap;
 class RemovalPolicySettings;
 class external_acl;
 class Store;
-struct http_port_list;
+namespace AnyP
+{
+struct PortCfg;
+}
 class SwapDir;
 
 /// Used for boolean enabled/disabled options with complex default logic.
@@ -244,11 +247,10 @@ struct SquidConfig {
     } Port;
 
     struct {
-        http_port_list *http;
+        AnyP::PortCfg *http;
 #if USE_SSL
-        http_port_list *https;
+        AnyP::PortCfg *https;
 #endif
-
     } Sockaddr;
 #if SQUID_SNMP
 
@@ -556,12 +558,10 @@ struct SquidConfig {
 #endif
 
     struct {
-        int icp_average;
-        int dns_average;
-        int http_average;
-        int icp_min_poll;
-        int dns_min_poll;
-        int http_min_poll;
+        struct {
+            int average;
+            int min_poll;
+        } dns, udp, tcp;
     } comm_incoming;
     int max_open_disk_fds;
     int uri_whitespace;
@@ -35,11 +35,12 @@
 #include "squid-old.h"
 #include "base/Subscription.h"
 #include "fde.h"
+#include "htcp.h"
 #include "ICP.h"
 #include "ip/Intercept.h"
 #include "ip/QosConfig.h"
 #include "MemBuf.h"
-#include "ProtoPort.h"
+#include "anyp/PortCfg.h"
 #include "SquidMath.h"
 #include "SquidTime.h"
 #include "ipc/Kids.h"
@@ -88,19 +89,16 @@ SQUIDCEXTERN int setresuid(uid_t, uid_t, uid_t);
 void
 releaseServerSockets(void)
 {
-    int i;
-    /* Release the main ports as early as possible */
+    // Release the main ports as early as possible
 
     // clear both http_port and https_port lists.
-    for (i = 0; i < NHttpSockets; i++) {
-        if (HttpSockets[i] >= 0)
-            close(HttpSockets[i]);
-    }
+    clientHttpConnectionsClose();
 
     // clear icp_port's
-    icpConnectionClose();
+    icpClosePorts();
 
     // XXX: Why not the HTCP, SNMP, DNS ports as well?
+    // XXX: why does this differ from main closeServerConnections() anyway ?
 }
 
 static char *
@@ -1258,7 +1256,7 @@ parseEtcHosts(void)
 int
 getMyPort(void)
 {
-    http_port_list *p = NULL;
+    AnyP::PortCfg *p = NULL;
     if ((p = Config.Sockaddr.http)) {
         // skip any special interception ports
         while (p && (p->intercepted || p->spoof_client_ip))
@@ -159,9 +159,8 @@ int WIN32_getrusage(int who, struct rusage *usage)
     return 0;
 }
 
-
-int Win32__WSAFDIsSet(int fd, fd_set FAR * set
-                     )
+int
+Win32__WSAFDIsSet(int fd, fd_set FAR * set)
 {
     fde *F = &fd_table[fd];
     SOCKET s = F->win32.handle;
@@ -49,7 +49,7 @@ recommended to configure your web server to restrict access to the
 program.
 .
 .SH AUTHOR
-Derived from Harvest. Further developed by by numerous individuals from
+Derived from Harvest. Further developed by numerous individuals from
 the internet community. Development is led by Duane Wessels of the
 National Laboratory for Applied Network Research and funded by
 the National Science Foundation.