@@ -1,3 +1,17 @@
+Changes to squid-3.4.0.2 (03 Oct 2013):
+
+	- Regression Bug 3891: squid.conf parser errors in 3.4.0.1
+	- Regression Fix: re-disable MinGW C++11 support
+	- Bug 3914: partial: make squidclient tool build cleanly with -Wconversion
+	- Fix memory leak in refresh_pattern parsing
+	- negotiate_kerberos_auth: upgrade to present group= keys
+	- Handle NTLM helper returning OK without user= value
+	- Add dns_multicast_local to control mDNS operation
+	- Add --disable-arch-native build option
+	- Display Build-Info in cache manager info report
+	- ... and all changes from squid 3.3.9
+	- ... and some code and debug output polishing
+
 Changes to squid-3.4.0.1 (29 Jul 2013):
 
 	- Port from 2.7: StoreURL (renamed Store-ID) support
@@ -40,6 +54,26 @@ Changes to squid-3.4.0.1 (29 Jul 2013):
 	- ... and many documentation changes
 	- ... and much code cleanup and polishing
 
+Changes to squid-3.3.9 (11 Sep 2013):
+
+	- Regression Bug 3077: off-by-one error in Digest header decoding
+	- Bug 3895: fix acl_uses_indirect_client and cache_peer_access
+	- Bug 3879: assertion failed ConnStateData::validatePinnedConnection
+	- Bug 3863: myportname acl causes segmentation fault
+	- Bug 3849: Duplicate certificate sent when using https_port
+	- Bug 2287: Better fix for unsupported HTTP version handling
+	- Bug 2112: Reload into If-None-Match
+	- Fix several assert with side effects in ICAP/eCAP response handling
+	- Fix myportname ACL on ICAP/eCAP transactions
+	- Fix external ACL user:pass detail logging after adaptation
+	- Fix SMP mgr:info report 'Largest file desc currently in use'
+	- Handle infinite certificate validation loops caused by OpenSSL Bug 3090.
+	- Improved compatibility with gcc 4.8, clang and icc
+	- Show number of available filedescriptors when reserved FD changes
+	- Sync with newest OpenSSL error codes
+	- Register Http2-Settings header
+	- ... and many Windows portability fixes
+
 Changes to squid-3.3.8 (13 Jul 2013):
 
 	- Bug 3869: assertion failed: MemBuf.cc:272: size < capacity
@@ -2,24 +2,7 @@ In addition to the numerous volunteer developers (see CONTRIBUTORS),
 the following organizations have provided non-financial support for
 the Squid Project:
 
-@Squid-3.3:
-Netbox Blue Pty (http://netboxblue.com/)
-
-	Netbox Blue Pty. contributed development resources towards
-	testing and stabilizing of authentication systems in Squid-3.2
-	and Squid-3.3.
-
-@Squid-3.2:
-iiNet Ltd - http://www.iinet.net.au/
-
-	iiNet Ltd contributed significant development resources to
-	Squid during its early stages and was instrumental in its
-	early adoption in the local internet community.
-	In Squid-2.6 and 3.0 iiNet supplied equipment to help develop
-	and test the WCCPv2 implementation.
-	In Squid-3.2 iiNet sponsored development time to resolve
-	authentication problems.
-
+@Squid-3.4:
 LaunchPad - http://launchpad.net/
 
 	Provide Bazaar mirroring services and host the Squid-3 developer
@@ -30,10 +13,6 @@ Messagenet - http://messagenet.it/
 	Messagenet donated hardware and bandwidth for the wiki server
 	and most continuous integration testing.
 
-Palisade Systems - http://www.palisadesys.com/
-
-	Palisade Systems funded SSL Bump feature development in Squid3.
-
 The Measurement Factory - http://www.measurement-factory.com/
 
 	Measurement Factory has constributed significant resources
@@ -45,6 +24,33 @@ Treehouse Networks, NZ - http://treenet.co.nz/
 	toward Squid-3 development and maintenance for their customer
 	gateways and CDN.
 
+@Squid-3.3:
+iCelero - http://icelero.com/
+
+	iCelero.com contributed development resources towards
+	testing and stabilization of Squid-3.3 on Windows.
+
+Netbox Blue Pty - http://netboxblue.com/
+
+	Netbox Blue Pty. contributed development resources towards
+	testing and stabilizing of authentication systems in Squid-3.2
+	and Squid-3.3.
+
+@Squid-3.2:
+iiNet Ltd - http://www.iinet.net.au/
+
+	iiNet Ltd contributed significant development resources to
+	Squid during its early stages and was instrumental in its
+	early adoption in the local internet community.
+	In Squid-2.6 and 3.0 iiNet supplied equipment to help develop
+	and test the WCCPv2 implementation.
+	In Squid-3.2 iiNet sponsored development time to resolve
+	authentication problems.
+
+Palisade Systems - http://www.palisadesys.com/
+
+	Palisade Systems funded SSL Bump feature development in Squid3.
+
 @Squid-3.1:
 Barefruit - http://www.barefruit.com/
 
@@ -9,6 +9,12 @@
 #include <sys/socket.h>
 #endif
 
+// WinSock2.h defines these for Windows
+#if HAVE_WINSOCK2_H
+#include <winsock2.h>
+#define CMSG_H_ // prevent re-definition
+#endif
+
 #ifndef CMSG_H_
 #define CMSG_H_
 
@@ -71,6 +71,11 @@
 #define NOMINMAX
 #endif
 
+/// some builds of MinGW do not define IPV6_V6ONLY socket option
+#if !defined(IPV6_V6ONLY)
+#define IPV6_V6ONLY 27
+#endif
+
 #if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS == 64
 # define __USE_FILE_OFFSET64	1
 #endif
@@ -469,6 +474,18 @@ namespace Squid
 {
 /** \endcond */
 
+/*
+ * Each of these functions is defined in the Squid namespace so as not to
+ * clash with the winsock.h and winsock2.h definitions.
+ * It is then paired with a #define to cause these wrappers to be used by
+ * the main code instead of those system definitions.
+ *
+ * We do this wrapper in order to:
+ * - cast the parameter types in only one place, and
+ * - record errors in POSIX errno variable, and
+ * - map the FD value used by Squid to the socket handes used by Windows.
+ */
+
 inline int
 accept(int s, struct sockaddr * a, socklen_t * l)
 {
@@ -720,6 +737,7 @@ WSAAsyncSelect(int s, HWND h, unsigned int w, long e)
     } else
         return 0;
 }
+#define WSAAsyncSelect(s,h,w,e) Squid::WSAAsyncSelect(s,h,w,e)
 
 #undef WSADuplicateSocket
 inline int
@@ -735,6 +753,7 @@ WSADuplicateSocket(int s, DWORD n, LPWSAPROTOCOL_INFO l)
     } else
         return 0;
 }
+#define WSADuplicateSocket(s,n,l) Squid::WSADuplicateSocket(s,n,l)
 
 #undef WSASocket
 inline int
@@ -752,6 +771,7 @@ WSASocket(int a, int t, int p, LPWSAPROTOCOL_INFO i, GROUP g, DWORD f)
     } else
         return _open_osfhandle(result, 0);
 }
+#define WSASocket(a,t,p,i,g,f) Squid::WSASocket(a,t,p,i,g,f)
 
 } /* namespace Squid */
 
@@ -782,6 +802,11 @@ WSASocket(int a, int t, int p, LPWSAPROTOCOL_INFO i, GROUP g, DWORD f)
 #define open       _open /* Needed in win32lib.c */
 #endif /* #ifdef __cplusplus */
 
+/* provide missing definitions from resoruce.h */
+/* NP: sys/resource.h and sys/time.h are apparently order-dependant. */
+#if HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
 #if HAVE_SYS_RESOURCE_H
 #include <sys/resource.h>
 #else
@@ -35,9 +35,22 @@ AC_PROG_CXX
 AC_LANG([C++])
 AC_CANONICAL_HOST
 
-# Clang 3.2 on some CPUs requires -march-native to detect correctly
-# GCC 4.3+ can also produce faster executables when its used
-SQUID_CC_CHECK_ARGUMENT([squid_cv_check_marchnative],[-march=native])
+# Clang 3.2 on some CPUs requires -march-native to detect correctly.
+# GCC 4.3+ can also produce faster executables when its used.
+# But building inside a virtual machine environment has been found to
+# cause random Illegal Instruction errors due to mis-detection of CPU.
+AC_ARG_ENABLE(arch-native,
+  AS_HELP_STRING([--disable-arch-native],[Some compilers offer CPU-specific
+                 optimizations with the -march=native parameter.
+                 This flag disables the optimization. The default is to
+                 auto-detect compiler support and use where available.]), [
+  SQUID_YESNO([$enableval],
+    [Unrecognized argument to --disable-arch-native: $enableval])
+])
+AC_MSG_NOTICE([CPU -march=native optimization enabled: ${enable_arch_native:=auto}])
+if test "x${enable_arch_native}" != "xno"; then
+  SQUID_CC_CHECK_ARGUMENT([squid_cv_check_marchnative],[-march=native])
+fi
 
 # might be cross-compiling.
 if test "x$HOSTCXX" = "x"; then
@@ -794,8 +807,6 @@ if test "x$squid_opt_enable_storeio" = "xauto"; then
   squid_opt_enable_storeio=yes
   AC_MSG_CHECKING([for available StoreIO modules])
   SQUID_LOOK_FOR_MODULES([$srcdir/src/fs],[squid_storeio_module_candidates])
-  # disable coss
-  squid_storeio_module_candidates=`echo $squid_storeio_module_candidates|sed 's/coss//'`
   AC_MSG_RESULT([$squid_storeio_module_candidates])
 fi
 
@@ -817,15 +828,6 @@ for fs in $squid_storeio_module_candidates none; do
         AC_MSG_ERROR([Storage module aufs requires DiskIO module: Blocking or DiskThreads])
       fi
       ;;
-    coss)
-      AC_MSG_WARN([COSS Support is not stable yet in Squid-3. Please do not use.])
-      if ! test "x$squid_disk_module_candidates_AIO" = "xyes"; then
-        AC_MSG_ERROR([COSS requires POSIX AIO which is not available.])
-      fi
-      # Automake on MinGW needs explicit exe extension
-      # for STORE_TESTS substition
-      STORE_TESTS="$STORE_TESTS tests/testCoss$EXEEXT"
-      ;;
     rock)
 	if test "x$squid_disk_module_candidates_IpcIo" != "xyes" -a \
 	  "x$squid_disk_module_candidates_Blocking" != "xyes"; then
@@ -843,7 +845,6 @@ dnl make sure that global FS objects are linked to the squid binary.
 AH_TEMPLATE(HAVE_FS_UFS, "Define to 1 if ufs filesystem module is build")
 AH_TEMPLATE(HAVE_FS_AUFS, "Define to 1 if aufs filesystem module is build")
 AH_TEMPLATE(HAVE_FS_DISKD, "Define to 1 if diskd filesystem module is build")
-AH_TEMPLATE(HAVE_FS_COSS, "Define to 1 if coss filesystem module is build")
 AH_TEMPLATE(HAVE_FS_ROCK, "Define to 1 if rock filesystem module is build")
 
 
@@ -1306,20 +1307,6 @@ SQUID_DEFINE_BOOL(USE_CACHE_DIGESTS,${enable_cache_digests:=no},
 AC_MSG_NOTICE([Cache Digests enabled: $enable_cache_digests])
 
 
-dnl Size of COSS memory buffer
-squid_opt_coss_membuf_size=1048576
-AC_ARG_WITH(coss-membuf-size,
-  AS_HELP_STRING([--with-coss-membuf-size=size],
-             [COSS membuf size (default $squid_opt_coss_membuf_size bytes)]), [
-case $withval in
-  [[0-9]]*) squid_opt_coss_membuf_size=$withval ;;
-  *) AC_MSG_ERROR([--with-coss-membuf-size expects a numeric argument]) ;;
-esac
-])
-AC_MSG_NOTICE([Setting COSS membuf size to $squid_opt_coss_membuf_size bytes])
-AC_DEFINE_UNQUOTED(COSS_MEMBUF_SZ, $squid_opt_coss_membuf_size,
-   [Default COSS membuf size])
-
 ################################
 # check for netio plugin stuff #
 ################################
@@ -1679,21 +1666,6 @@ AC_ARG_ENABLE(ident-lookups,
 AC_MSG_NOTICE([Support for Ident lookups enabled: ${enable_ident_lookups:=yes}])
 SQUID_DEFINE_BOOL(USE_IDENT,$enable_ident_lookups,[Support for Ident (RFC 931) lookups])
 
-squid_opt_use_dnshelper="no"
-AC_ARG_ENABLE(internal-dns,
-  AS_HELP_STRING([--disable-internal-dns],
-           [Prevents Squid from directly sending and receiving DNS messages, 
-            and instead enables the old external 'dnsserver' processes.]), [
-  if test "x$enableval" = "xno" ; then
-    AC_MSG_WARN([Disabling Internal DNS queries])
-    squid_opt_use_dnshelper="yes"
-  fi
-])
-SQUID_DEFINE_BOOL(USE_DNSHELPER,$squid_opt_use_dnshelper,
-  [Use dnsserver processes instead of the internal DNS protocol support])
-AM_CONDITIONAL([ENABLE_DNSHELPER],[test "x$squid_opt_use_dnshelper" = "xyes" ])
-
-
 AM_CONDITIONAL(USE_SSL_CRTD, false)
 AC_ARG_ENABLE(ssl-crtd,
   AC_HELP_STRING([--enable-ssl-crtd],
@@ -1907,6 +1879,10 @@ if test "x$ac_krb5_config" = "xyes" ; then
     AC_DEFINE(HAVE_KRB5_GET_ERROR_MESSAGE,1,
       [Define to 1 if you have krb5_get_error_message]),)
   AC_CHECK_DECLS(krb5_kt_free_entry,,,[#include <krb5.h>])
+  AC_CHECK_TYPE(krb5_pac,
+    AC_DEFINE(HAVE_KRB5_PAC,1,
+      [Define to 1 if you have krb5_pac]),,
+      [#include <krb5.h>])
   AC_CHECK_LIB(krb5,krb5_kt_free_entry,
     AC_DEFINE(HAVE_KRB5_KT_FREE_ENTRY,1,
       [Define to 1 if you have krb5_kt_free_entry]),)
@@ -1925,6 +1901,33 @@ if test "x$ac_krb5_config" = "xyes" ; then
   AC_CHECK_LIB(krb5,profile_release,
     AC_DEFINE(HAVE_PROFILE_RELEASE,1,
       [Define to 1 if you have profile_release]),)
+  AC_CHECK_LIB(krb5,krb5_get_renewed_creds,
+    AC_DEFINE(HAVE_KRB5_GET_RENEWED_CREDS,1,
+      [Define to 1 if you have krb5_get_renewed_creds]),)
+  AC_CHECK_LIB(krb5,krb5_principal_get_realm,
+    AC_DEFINE(HAVE_KRB5_PRINCIPAL_GET_REALM,1,
+      [Define to 1 if you have krb5_principal_get_realm]),)
+  AC_CHECK_LIB(krb5, krb5_get_init_creds_opt_alloc,
+    AC_DEFINE(HAVE_KRB5_GET_INIT_CREDS_OPT_ALLOC,1,
+      [Define to 1 if you have krb5_get_init_creds_opt_alloc]),)
+  AC_MSG_CHECKING([for krb5_get_init_creds_free requires krb5_context])
+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+	#include <krb5.h>
+    ]],[[krb5_context context;
+	 krb5_get_init_creds_opt *options;
+	 krb5_get_init_creds_opt_free(context, options)]])],[
+	AC_DEFINE(HAVE_KRB5_GET_INIT_CREDS_FREE_CONTEXT,1,
+		  [Define to 1 if you krb5_get_init_creds_free requires krb5_context])
+	AC_MSG_RESULT(yes)
+    ],[AC_MSG_RESULT(no)],[AC_MSG_RESULT(no)])
+
+
+  AC_CHECK_FUNCS(gss_map_name_to_any,
+    AC_DEFINE(HAVE_GSS_MAP_ANY_TO_ANY,1,
+      [Define to 1 if you have gss_map_name_to_any]),)
+  AC_CHECK_FUNCS(gsskrb5_extract_authz_data_from_sec_context,
+    AC_DEFINE(HAVE_GSSKRB5_EXTRACT_AUTHZ_DATA_FROM_SEC_CONTEXT,1,
+      [Define to 1 if you have gsskrb5_extract_authz_data_from_sec_context]),)
 
   SQUID_CHECK_KRB5_CONTEXT_MEMORY_CACHE
   SQUID_DEFINE_BOOL(HAVE_KRB5_MEMORY_CACHE,$squid_cv_memory_cache,
@@ -3310,10 +3313,8 @@ SQUID_CHECK_RECV_ARG_TYPE
 SQUID_CHECK_NEED_SYS_ERRLIST
 SQUID_CHECK_MAXPATHLEN
 
-if test "x$squid_opt_use_dnshelper" = "xyes"; then
-  SQUID_CHECK_LIBRESOLV_DNS_TTL_HACK
-  SQUID_CHECK_RESOLVER_FIELDS
-fi
+SQUID_CHECK_LIBRESOLV_DNS_TTL_HACK
+SQUID_CHECK_RESOLVER_FIELDS
 
 if test "x$ac_cv_header_sys_statvfs_h" = "xyes" ; then
   SQUID_CHECK_WORKING_STATVFS
@@ -7,7 +7,6 @@ section --    Unlink Daemon
 section --    WWW Client
 section 00    Announcement Server
 section 00    Client Database
-section 00    DNS Resolver Daemon
 section 00    Debug Routines
 section 00    Hash Tables
 section 00    UFS Store Dump Tool
@@ -68,7 +67,6 @@ section 30    Ident (RFC 931)
 section 31    Hypertext Caching Protocol
 section 32    Asynchronous Disk I/O
 section 33    Client-side Routines
-section 34    Dnsserver interface
 section 35    FQDN Cache
 section 37    ICMP Routines
 section 38    Network Measurement Database
@@ -89,7 +87,6 @@ section 46    Access Log - Squid ICAP Logging
 section 46    Access Log - Squid format
 section 46    Access Log - Squid referer format
 section 46    Access Log - Squid useragent format
-section 47    Store COSS Directory Routines
 section 47    Store Directory Routines
 section 48    Persistent Connections
 section 49    SNMP Interface
@@ -128,7 +125,6 @@ section 78    DNS lookups; interacts with lib/rfc1035.c
 section 79    Disk IO Routines
 section 79    Squid-side DISKD I/O functions.
 section 79    Squid-side Disk I/O functions.
-section 79    Storage Manager COSS Interface
 section 79    Storage Manager UFS Interface
 section 79   Disk IO Routines
 section 80    WCCP Support
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.3.8 release notes</title>
+<title>Squid 3.3.9 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.3.8.
+The Squid Team are pleased to announce the release of Squid-3.3.9.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.3/"> or the 
 <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.4.0.1 release notes</title>
+<title>Squid 3.4.0.2 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.4.0.1 for testing.
+The Squid Team are pleased to announce the release of Squid-3.4.0.2 for testing.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.4/"> or the
  <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
@@ -177,7 +177,7 @@ Most user-facing changes are reflected in squid.conf (see below).
 
 
 <sect1>Multicast DNS
-<p>The internal DNS component fof Squid now supports multicast DNS (mDNS) resolution in
+<p>The internal DNS component of Squid now supports multicast DNS (mDNS) resolution in
     accordance with RFC 6762.
 
 <p>The <em>dns_multicast_local</em> directive must be set to <em>on</em> to enable this
@@ -218,7 +218,9 @@ This section gives a thorough account of those changes in three categories:
 <descrip>
 	<tag>configuration_includes_quoted_values</tag>
 	<p>Whether Squid supports directive parameters with spaces, quotes, and other
-	   special characters. Surround such parameters with "double quotes".
+	   special characters. Surround such parameters with "double quotes" and
+	   also set this directive on/off around the relevant squid.conf line(s)
+	   making use of such quoting.
 
 	<tag>dns_multicast_local</tag>
 	<p>Use multicast DNS for <em>.local</em> domains and reverse-DNS resolution.
@@ -377,6 +379,13 @@ This section gives an account of those changes in three categories:
 	   omit to get all helper auto-detected.
 	<p>Currenly only a helper using <em>file</em> for backend is provided.
 
+	<tag>--disable-arch-native</tag>
+	<p>New option to disable use of -march=native compiler flag.
+	<p>The new flag auto-enables CPU-specific optimizations in GCC and is
+	  required by Clang++ v3.2 for correct 64-bit environment detection.
+	  It does not always work well however, so this build option is provided
+	  to remove it when necessary.
+
 	<tag>--with-nat-devpf</tag>
 	<p>New option to alter the behaviour of <em>http_port ... intercept</em> option
 	   in squid.conf.
@@ -35,5 +35,5 @@ th	th-th
 tr	tr-tr
 uk	uk-ua
 vi	vi-vn
-zh-tw	zh-hk zh-mo
-zh-cn	zh-sg
+zh-hant	zh-hant-tw zh-hant-hk zh-hant-mo zh-tw zh-hk zh-mo
+zh-hans	zh-hans-cn zh-cn zh-hans-sg zh-sg
@@ -41,5 +41,5 @@ TRANSLATE_LANGUAGES= \
     uk.lang \
     uz.lang \
     vi.lang \
-    zh-cn.lang \
-    zh-tw.lang 
+    zh-hans.lang \
+    zh-hant.lang 
@@ -37,7 +37,6 @@
 #include <signal.h>
 #include <syslog.h>
 #include <string.h>
-#include <sys/time.h>
 
 #include "msntauth.h"
 
@@ -89,10 +89,6 @@ PFldap_start_tls_s Win32_ldap_start_tls_s;
 
 #endif
 
-#if defined(LDAP_OPT_NETWORK_TIMEOUT)
-#include <sys/time.h>
-#endif
-
 #define PROGRAM_NAME "ext_ldap_group_acl"
 #define PROGRAM_VERSION "2.17"
 
@@ -65,7 +65,7 @@ init_args(struct main_args *margs)
 
 void clean_gd(struct gdstruct *gdsp);
 void clean_nd(struct ndstruct *ndsp);
-void clean_ls(struct ndstruct *lssp);
+void clean_ls(struct lsstruct *lssp);
 
 void
 clean_gd(struct gdstruct *gdsp)
@@ -78,22 +78,12 @@ clean_gd(struct gdstruct *gdsp)
             pp = p;
             p = p->next;
         }
-        if (p->group) {
-            xfree(p->group);
-            p->group = NULL;
-        }
-        if (p->domain) {
-            xfree(p->domain);
-            p->domain = NULL;
-        }
-        if (pp && pp->next) {
-            xfree(pp->next);
-            pp->next = NULL;
-        }
-        if (p == gdsp) {
-            xfree(gdsp);
-            gdsp = NULL;
-        }
+        safe_free(p->group);
+        safe_free(p->domain);
+        if (pp)
+            safe_free(pp->next);
+        if (p == gdsp)
+            safe_free(gdsp);
         p = gdsp;
     }
 }
@@ -109,22 +99,12 @@ clean_nd(struct ndstruct *ndsp)
             pp = p;
             p = p->next;
         }
-        if (p->netbios) {
-            xfree(p->netbios);
-            p->netbios = NULL;
-        }
-        if (p->domain) {
-            xfree(p->domain);
-            p->domain = NULL;
-        }
-        if (pp && pp->next) {
-            xfree(pp->next);
-            pp->next = NULL;
-        }
-        if (p == ndsp) {
-            xfree(ndsp);
-            ndsp = NULL;
-        }
+        safe_free(p->netbios);
+        safe_free(p->domain);
+        if (pp)
+            safe_free(pp->next);
+        if (p == ndsp)
+            safe_free(ndsp);
         p = ndsp;
     }
 }
@@ -140,73 +120,30 @@ clean_ls(struct lsstruct *lssp)
             pp = p;
             p = p->next;
         }
-        if (p->lserver) {
-            xfree(p->lserver);
-            p->lserver = NULL;
-        }
-        if (p->domain) {
-            xfree(p->domain);
-            p->domain = NULL;
-        }
-        if (pp && pp->next) {
-            xfree(pp->next);
-            pp->next = NULL;
-        }
-        if (p == lssp) {
-            xfree(lssp);
-            lssp = NULL;
-        }
+        safe_free(p->lserver);
+        safe_free(p->domain);
+        if (pp)
+            safe_free(pp->next);
+        if (p == lssp)
+            safe_free(lssp);
         p = lssp;
     }
 }
 
 void
 clean_args(struct main_args *margs)
 {
-    if (margs->glist) {
-        xfree(margs->glist);
-        margs->glist = NULL;
-    }
-    if (margs->ulist) {
-        xfree(margs->ulist);
-        margs->ulist = NULL;
-    }
-    if (margs->tlist) {
-        xfree(margs->tlist);
-        margs->tlist = NULL;
-    }
-    if (margs->nlist) {
-        xfree(margs->nlist);
-        margs->nlist = NULL;
-    }
-    if (margs->llist) {
-        xfree(margs->llist);
-        margs->llist = NULL;
-    }
-    if (margs->luser) {
-        xfree(margs->luser);
-        margs->luser = NULL;
-    }
-    if (margs->lpass) {
-        xfree(margs->lpass);
-        margs->lpass = NULL;
-    }
-    if (margs->lbind) {
-        xfree(margs->lbind);
-        margs->lbind = NULL;
-    }
-    if (margs->lurl) {
-        xfree(margs->lurl);
-        margs->lurl = NULL;
-    }
-    if (margs->ssl) {
-        xfree(margs->ssl);
-        margs->ssl = NULL;
-    }
-    if (margs->ddomain) {
-        xfree(margs->ddomain);
-        margs->ddomain = NULL;
-    }
+    safe_free(margs->glist);
+    safe_free(margs->ulist);
+    safe_free(margs->tlist);
+    safe_free(margs->nlist);
+    safe_free(margs->llist);
+    safe_free(margs->luser);
+    safe_free(margs->lpass);
+    safe_free(margs->lbind);
+    safe_free(margs->lurl);
+    safe_free(margs->ssl);
+    safe_free(margs->ddomain);
     if (margs->groups) {
         clean_gd(margs->groups);
         margs->groups = NULL;
@@ -413,8 +350,8 @@ main(int argc, char *const argv[])
                 log((char *) "%s| %s: INFO: Got User: %s Netbios Name: %s\n", LogTime(), PROGRAM, up, np);
             domain = get_netbios_name(&margs, netbios);
             user = nuser;
-            xfree(up);
-            xfree(np);
+            safe_free(up);
+            safe_free(np);
         } else if (domain) {
             strup(domain);
             *domain = '\0';
@@ -436,8 +373,8 @@ main(int argc, char *const argv[])
         else
             log((char *) "%s| %s: INFO: Got User: %s Domain: %s\n", LogTime(), PROGRAM, up, domain ? dp : "NULL");
 
-        xfree(up);
-        xfree(dp);
+        safe_free(up);
+        safe_free(dp);
         if (!strcmp(user, "QQ") && domain && !strcmp(domain, "QQ")) {
             clean_args(&margs);
             exit(-1);
@@ -477,7 +414,7 @@ void
 strup(char *s)
 {
     while (*s) {
-        *s = toupper((unsigned char) *s);
+        *s = (char)toupper((unsigned char) *s);
         ++s;
     }
 }
@@ -22,7 +22,7 @@
  * -----------------------------------------------------------------------------
  */
 
-#define KERBEROS_LDAP_GROUP_VERSION "1.3.0sq"
+#define KERBEROS_LDAP_GROUP_VERSION "1.3.1sq"
 
 #if HAVE_STRING_H
 #include <string.h>
@@ -156,13 +156,13 @@ int create_nd(struct main_args *margs);
 int create_ls(struct main_args *margs);
 
 #ifdef HAVE_KRB5
-int krb5_create_cache(struct main_args *margs, char *domain);
+int krb5_create_cache(char *domain);
 void krb5_cleanup(void);
 #endif
 
-int get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, int nhosts, char *domain);
-int get_hostname_list(struct main_args *margs, struct hstruct **hlist, int nhosts, char *name);
-int free_hostname_list(struct hstruct **hlist, int nhosts);
+size_t get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, size_t nhosts, char *domain);
+size_t get_hostname_list(struct hstruct **hlist, size_t nhosts, char *name);
+size_t free_hostname_list(struct hstruct **hlist, size_t nhosts);
 
 #if defined(HAVE_SASL_H) || defined(HAVE_SASL_SASL_H) || defined(HAVE_SASL_DARWIN)
 int tool_sasl_bind(LDAP * ld, char *binddn, char *ssl);
@@ -31,6 +31,7 @@
 #include "support.h"
 
 struct gdstruct *init_gd(void);
+void free_gd(struct gdstruct *gdsp);
 
 struct gdstruct *
 init_gd(void) {
@@ -59,7 +60,8 @@ char *utf8dup(struct main_args *margs);
 char *
 utf8dup(struct main_args *margs)
 {
-    int c = 0, s;
+    size_t c = 0;
+    unsigned char s;
     size_t n;
     char *src;
     unsigned char *p, *dupp;
@@ -79,7 +81,7 @@ utf8dup(struct main_args *margs)
                 *p = 194;
                 ++p;
                 *p = s;
-            } else if (s > 191 && s < 256) {
+            } else if (s > 191) {
                 *p = 195;
                 ++p;
                 *p = s - 64;
@@ -121,7 +123,7 @@ hex_utf_char(struct main_args *margs, int flag)
         return NULL;
 
     char *upd = strrchr(up, '@');
-    size_t a = (upd ? (upd - up) : strlen(up) );
+    size_t a = (upd ? (size_t)(upd - up) : strlen(up) );
 
     char *ul = (char *) xmalloc(strlen(up)+1);
     size_t n = 0;
@@ -174,17 +176,17 @@ hex_utf_char(struct main_args *margs, int flag)
         if (iUTF2) {
             if (iUTF2 == 0xC2 && ichar > 0x7F && ichar < 0xC0) {
                 iUTF2 = 0;
-                ul[nl - 1] = ichar;
+                ul[nl - 1] = (char)ichar;
             } else if (iUTF2 == 0xC3 && ichar > 0x7F && ichar < 0xC0) {
                 iUTF2 = 0;
-                ul[nl - 1] = ichar + 64;
+                ul[nl - 1] = (char)(ichar + 64);
             } else if (iUTF2 > 0xC3 && iUTF2 < 0xE0 && ichar > 0x7F && ichar < 0xC0) {
                 iUTF2 = 0;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else {
                 iUTF2 = 0;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ul[nl + 1] = '\0';
                 debug((char *) "%s| %s: WARNING: Invalid UTF-8 sequence for Unicode %s\n", LogTime(), PROGRAM, ul);
                 xfree(ul);
@@ -193,27 +195,27 @@ hex_utf_char(struct main_args *margs, int flag)
         } else if (iUTF3) {
             if (iUTF3 == 0xE0 && ichar > 0x9F && ichar < 0xC0) {
                 iUTF3 = 1;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else if (iUTF3 > 0xE0 && iUTF3 < 0xED && ichar > 0x7F && ichar < 0xC0) {
                 iUTF3 = 2;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else if (iUTF3 == 0xED && ichar > 0x7F && ichar < 0xA0) {
                 iUTF3 = 3;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else if (iUTF3 > 0xED && iUTF3 < 0xF0 && ichar > 0x7F && ichar < 0xC0) {
                 iUTF3 = 4;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else if (iUTF3 > 0 && iUTF3 < 5 && ichar > 0x7F && ichar < 0xC0) {
                 iUTF3 = 0;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else {
                 iUTF3 = 0;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ul[nl + 1] = '\0';
                 debug((char *) "%s| %s: WARNING: Invalid UTF-8 sequence for Unicode %s\n", LogTime(), PROGRAM, ul);
                 xfree(ul);
@@ -222,52 +224,52 @@ hex_utf_char(struct main_args *margs, int flag)
         } else if (iUTF4) {
             if (iUTF4 == 0xF0 && ichar > 0x8F && ichar < 0xC0) {
                 iUTF4 = 1;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else if (iUTF4 > 0xF0 && iUTF3 < 0xF4 && ichar > 0x7F && ichar < 0xC0) {
                 iUTF4 = 2;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else if (iUTF4 == 0xF4 && ichar > 0x7F && ichar < 0x90) {
                 iUTF4 = 3;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else if (iUTF4 > 0 && iUTF4 < 5 && ichar > 0x7F && ichar < 0xC0) {
                 if (iUTF4 == 4)
                     iUTF4 = 0;
                 else
                     iUTF4 = 4;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ++nl;
             } else {
                 iUTF4 = 0;
-                ul[nl] = ichar;
+                ul[nl] = (char)ichar;
                 ul[nl + 1] = '\0';
                 debug((char *) "%s| %s: WARNING: Invalid UTF-8 sequence for Unicode %s\n", LogTime(), PROGRAM, ul);
                 xfree(ul);
                 return NULL;
             }
         } else if (ichar < 0x80) {
             /* UTF1 */
-            ul[nl] = ichar;
+            ul[nl] = (char)ichar;
             ++nl;
         } else if (ichar > 0xC1 && ichar < 0xE0) {
             /* UTF2 (Latin) */
             iUTF2 = ichar;
-            ul[nl] = ichar;
+            ul[nl] = (char)ichar;
             ++nl;
         } else if (ichar > 0xDF && ichar < 0xF0) {
             /* UTF3 */
             iUTF3 = ichar;
-            ul[nl] = ichar;
+            ul[nl] = (char)ichar;
             ++nl;
         } else if (ichar > 0xEF && ichar < 0xF5) {
             /* UTF4 */
             iUTF4 = ichar;
-            ul[nl] = ichar;
+            ul[nl] = (char)ichar;
             ++nl;
         } else {
-            ul[nl] = ichar;
+            ul[nl] = (char)ichar;
             ul[nl + 1] = '\0';
             debug((char *) "%s| %s: WARNING: Invalid UTF-8 sequence for Unicode %s\n", LogTime(), PROGRAM, ul);
             xfree(ul);
@@ -33,7 +33,9 @@ struct kstruct {
     krb5_context context;
     char *mem_cache_env;
     krb5_ccache cc;
-} kparam;
+};
+
+static struct kstruct kparam;
 
 #define KT_PATH_MAX 256
 
@@ -50,23 +52,20 @@ krb5_cleanup()
  * create Kerberos memory cache
  */
 int
-krb5_create_cache(struct main_args *margs, char *domain)
+krb5_create_cache(char *domain)
 {
 
     krb5_keytab keytab = 0;
     krb5_keytab_entry entry;
     krb5_kt_cursor cursor;
     krb5_creds *creds = NULL;
-    krb5_creds *tgt_creds = NULL;
     krb5_principal *principal_list = NULL;
     krb5_principal principal = NULL;
     char *service;
     char *keytab_name = NULL, *principal_name = NULL, *mem_cache = NULL;
     char buf[KT_PATH_MAX], *p;
-    int nprinc = 0;
-    int i;
+    size_t j,nprinc = 0;
     int retval = 0;
-    int found = 0;
     krb5_error_code code = 0;
 
     kparam.context = NULL;
@@ -112,6 +111,7 @@ krb5_create_cache(struct main_args *margs, char *domain)
 
     nprinc = 0;
     while ((code = krb5_kt_next_entry(kparam.context, keytab, &entry, &cursor)) == 0) {
+        int found = 0;
 
         principal_list = (krb5_principal *) xrealloc(principal_list, sizeof(krb5_principal) * (nprinc + 1));
         krb5_copy_principal(kparam.context, entry.principal, &principal_list[nprinc++]);
@@ -182,12 +182,14 @@ krb5_create_cache(struct main_args *margs, char *domain)
      * if no principal name found in keytab for domain use the prinipal name which can get a TGT
      */
     if (!principal_name) {
+        size_t i;
         debug((char *) "%s| %s: DEBUG: Did not find a principal in keytab for domain %s.\n", LogTime(), PROGRAM, domain);
         debug((char *) "%s| %s: DEBUG: Try to get principal of trusted domain.\n", LogTime(), PROGRAM);
-        creds = (krb5_creds *) xmalloc(sizeof(*creds));
-        memset(creds, 0, sizeof(*creds));
 
         for (i = 0; i < nprinc; ++i) {
+            krb5_creds *tgt_creds = NULL;
+            creds = (krb5_creds *) xmalloc(sizeof(*creds));
+            memset(creds, 0, sizeof(*creds));
             /*
              * get credentials
              */
@@ -205,8 +207,7 @@ krb5_create_cache(struct main_args *margs, char *domain)
             snprintf(service, strlen("krbtgt") + 2 * strlen(domain) + 3, "krbtgt/%s@%s", domain, domain);
             creds->client = principal_list[i];
             code = krb5_parse_name(kparam.context, service, &creds->server);
-            if (service)
-                xfree(service);
+            xfree(service);
             code = krb5_get_in_tkt_with_keytab(kparam.context, 0, NULL, NULL, NULL, keytab, NULL, creds, 0);
 #endif
             if (code) {
@@ -233,8 +234,7 @@ krb5_create_cache(struct main_args *margs, char *domain)
             snprintf(service, strlen("krbtgt") + strlen(domain) + strlen(krb5_princ_realm(kparam.context, principal_list[i])->data) + 3, "krbtgt/%s@%s", domain, krb5_princ_realm(kparam.context, principal_list[i])->data);
 #endif
             code = krb5_parse_name(kparam.context, service, &creds->server);
-            if (service)
-                xfree(service);
+            xfree(service);
             if (code) {
                 error((char *) "%s| %s: ERROR: Error while initialising TGT credentials : %s\n", LogTime(), PROGRAM, error_message(code));
                 goto loop_end;
@@ -245,19 +245,22 @@ krb5_create_cache(struct main_args *margs, char *domain)
                 goto loop_end;
             } else {
                 debug((char *) "%s| %s: DEBUG: Found trusted principal name: %s\n", LogTime(), PROGRAM, principal_name);
-                found = 1;
                 break;
             }
 
 loop_end:
-            if (principal_name)
-                xfree(principal_name);
-            principal_name = NULL;
+            safe_free(principal_name);
+            if (tgt_creds) {
+                krb5_free_creds(kparam.context, tgt_creds);
+                tgt_creds = NULL;
+            }
+            if (creds)
+                krb5_free_creds(kparam.context, creds);
+            creds = NULL;
+
         }
 
-        if (tgt_creds)
-            krb5_free_creds(kparam.context, tgt_creds);
-        tgt_creds = NULL;
+        safe_free(principal_name);
         if (creds)
             krb5_free_creds(kparam.context, creds);
         creds = NULL;
@@ -287,8 +290,7 @@ krb5_create_cache(struct main_args *margs, char *domain)
         snprintf(service, strlen("krbtgt") + 2 * strlen(domain) + 3, "krbtgt/%s@%s", domain, domain);
         creds->client = principal;
         code = krb5_parse_name(kparam.context, service, &creds->server);
-        if (service)
-            xfree(service);
+        xfree(service);
         code = krb5_get_in_tkt_with_keytab(kparam.context, 0, NULL, NULL, NULL, keytab, NULL, creds, 0);
 #endif
         if (code) {
@@ -316,20 +318,16 @@ krb5_create_cache(struct main_args *margs, char *domain)
 cleanup:
     if (keytab)
         krb5_kt_close(kparam.context, keytab);
-    if (keytab_name)
-        xfree(keytab_name);
-    if (principal_name)
-        xfree(principal_name);
-    if (mem_cache)
-        xfree(mem_cache);
+    xfree(keytab_name);
+    xfree(principal_name);
+    xfree(mem_cache);
     if (principal)
         krb5_free_principal(kparam.context, principal);
-    for (i = 0; i < nprinc; ++i) {
-        if (principal_list[i])
-            krb5_free_principal(kparam.context, principal_list[i]);
+    for (j = 0; j < nprinc; ++j) {
+        if (principal_list[j])
+            krb5_free_principal(kparam.context, principal_list[j]);
     }
-    if (principal_list)
-        xfree(principal_list);
+    xfree(principal_list);
     if (creds)
         krb5_free_creds(kparam.context, creds);
 
@@ -35,7 +35,7 @@
 char *convert_domain_to_bind_path(char *domain);
 char *escape_filter(char *filter);
 int check_AD(struct main_args *margs, LDAP * ld);
-int ldap_set_defaults(struct main_args *margs, LDAP * ld);
+int ldap_set_defaults(LDAP * ld);
 int ldap_set_ssl_defaults(struct main_args *margs);
 LDAP *tool_ldap_open(struct main_args *margs, char *host, int port, char *ssl);
 
@@ -51,7 +51,7 @@ LDAP *tool_ldap_open(struct main_args *margs, char *host, int port, char *ssl);
 #define FILTER_AD "(samaccountname=%s)"
 #define ATTRIBUTE_AD "memberof"
 
-int get_attributes(struct main_args *margs, LDAP * ld, LDAPMessage * res, const char *attribute /* IN */ , char ***out_val /* OUT (caller frees) */ );
+size_t get_attributes(LDAP * ld, LDAPMessage * res, const char *attribute /* IN */ , char ***out_val /* OUT (caller frees) */ );
 int search_group_tree(struct main_args *margs, LDAP * ld, char *bindp, char *ldap_group, char *group, int depth);
 
 #if defined(HAVE_SUN_LDAP_SDK) || defined(HAVE_MOZILLA_LDAP_SDK)
@@ -210,7 +210,7 @@ char *
 convert_domain_to_bind_path(char *domain)
 {
     char *dp, *bindp = NULL, *bp = NULL;
-    int i = 0;
+    size_t i = 0;
 
     if (!domain)
         return NULL;
@@ -243,8 +243,8 @@ convert_domain_to_bind_path(char *domain)
 char *
 escape_filter(char *filter)
 {
-    int i;
     char *ldap_filter_esc, *ldf;
+    size_t i;
 
     i = 0;
     for (ldap_filter_esc = filter; *ldap_filter_esc; ++ldap_filter_esc) {
@@ -278,16 +278,16 @@ escape_filter(char *filter)
     *ldf = '\0';
 
     return ldap_filter_esc;
-};
+}
 
 int
 check_AD(struct main_args *margs, LDAP * ld)
 {
     LDAPMessage *res;
     char **attr_value = NULL;
     struct timeval searchtime;
-    int max_attr = 0;
-    int j, rc = 0;
+    size_t max_attr = 0;
+    int rc = 0;
 
 #define FILTER_SCHEMA "(objectclass=*)"
 #define ATTRIBUTE_SCHEMA "schemaNamingContext"
@@ -301,7 +301,7 @@ check_AD(struct main_args *margs, LDAP * ld)
                            NULL, NULL, &searchtime, 0, &res);
 
     if (rc == LDAP_SUCCESS)
-        max_attr = get_attributes(margs, ld, res, ATTRIBUTE_SCHEMA, &attr_value);
+        max_attr = get_attributes(ld, res, ATTRIBUTE_SCHEMA, &attr_value);
 
     if (max_attr == 1) {
         ldap_msgfree(res);
@@ -318,11 +318,11 @@ check_AD(struct main_args *margs, LDAP * ld)
      * Cleanup
      */
     if (attr_value) {
+        size_t j;
         for (j = 0; j < max_attr; ++j) {
             xfree(attr_value[j]);
         }
-        xfree(attr_value);
-        attr_value = NULL;
+        safe_free(attr_value);
     }
     ldap_msgfree(res);
     return rc;
@@ -332,11 +332,10 @@ search_group_tree(struct main_args *margs, LDAP * ld, char *bindp, char *ldap_gr
 {
     LDAPMessage *res = NULL;
     char **attr_value = NULL;
-    int max_attr = 0;
+    size_t max_attr = 0;
     char *filter = NULL;
     char *search_exp = NULL;
-    int j, rc = 0, retval = 0;
-    char *av = NULL, *avp = NULL;
+    int rc = 0, retval = 0;
     int ldepth;
     char *ldap_filter_esc = NULL;
     struct timeval searchtime;
@@ -378,38 +377,40 @@ search_group_tree(struct main_args *margs, LDAP * ld, char *bindp, char *ldap_gr
     debug((char *) "%s| %s: DEBUG: Found %d ldap entr%s\n", LogTime(), PROGRAM, ldap_count_entries(ld, res), ldap_count_entries(ld, res) > 1 || ldap_count_entries(ld, res) == 0 ? "ies" : "y");
 
     if (margs->AD)
-        max_attr = get_attributes(margs, ld, res, ATTRIBUTE_AD, &attr_value);
+        max_attr = get_attributes(ld, res, ATTRIBUTE_AD, &attr_value);
     else
-        max_attr = get_attributes(margs, ld, res, ATTRIBUTE, &attr_value);
+        max_attr = get_attributes(ld, res, ATTRIBUTE, &attr_value);
 
     /*
      * Compare group names
      */
     retval = 0;
     ldepth = depth + 1;
-    for (j = 0; j < max_attr; ++j) {
+    for (size_t j = 0; j < max_attr; ++j) {
+        char *av = NULL;
 
         /* Compare first CN= value assuming it is the same as the group name itself */
         av = attr_value[j];
         if (!strncasecmp("CN=", av, 3)) {
+            char *avp = NULL;
             av += 3;
             if ((avp = strchr(av, ','))) {
                 *avp = '\0';
             }
         }
         if (debug_enabled) {
             int n;
-            debug((char *) "%s| %s: DEBUG: Entry %d \"%s\" in hex UTF-8 is ", LogTime(), PROGRAM, j + 1, av);
+            debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " \"%s\" in hex UTF-8 is ", LogTime(), PROGRAM, j + 1, av);
             for (n = 0; av[n] != '\0'; ++n)
                 fprintf(stderr, "%02x", (unsigned char) av[n]);
             fprintf(stderr, "\n");
         }
         if (!strcasecmp(group, av)) {
             retval = 1;
-            debug((char *) "%s| %s: DEBUG: Entry %d \"%s\" matches group name \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
+            debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " \"%s\" matches group name \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
             break;
         } else
-            debug((char *) "%s| %s: DEBUG: Entry %d \"%s\" does not match group name \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
+            debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " \"%s\" does not match group name \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
         /*
          * Do recursive group search
          */
@@ -418,13 +419,14 @@ search_group_tree(struct main_args *margs, LDAP * ld, char *bindp, char *ldap_gr
         if (search_group_tree(margs, ld, bindp, av, group, ldepth)) {
             retval = 1;
             if (!strncasecmp("CN=", av, 3)) {
+                char *avp = NULL;
                 av += 3;
                 if ((avp = strchr(av, ','))) {
                     *avp = '\0';
                 }
             }
             if (debug_enabled)
-                debug((char *) "%s| %s: DEBUG: Entry %d \"%s\" is member of group named \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
+                debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " \"%s\" is member of group named \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
             else
                 break;
 
@@ -435,19 +437,18 @@ search_group_tree(struct main_args *margs, LDAP * ld, char *bindp, char *ldap_gr
      * Cleanup
      */
     if (attr_value) {
-        for (j = 0; j < max_attr; ++j) {
+        for (size_t j = 0; j < max_attr; ++j) {
             xfree(attr_value[j]);
         }
-        xfree(attr_value);
-        attr_value = NULL;
+        safe_free(attr_value);
     }
     ldap_msgfree(res);
 
     return retval;
 }
 
 int
-ldap_set_defaults(struct main_args *margs, LDAP * ld)
+ldap_set_defaults(LDAP * ld)
 {
     int val, rc = 0;
 #ifdef LDAP_OPT_NETWORK_TIMEOUT
@@ -484,14 +485,14 @@ ldap_set_ssl_defaults(struct main_args *margs)
 #endif
 #ifdef HAVE_OPENLDAP
     int val;
-    char *ssl_cacertfile = NULL;
-    int free_path;
 #elif defined(HAVE_LDAPSSL_CLIENT_INIT)
     char *ssl_certdbpath = NULL;
 #endif
 
 #ifdef HAVE_OPENLDAP
     if (!margs->rc_allow) {
+        char *ssl_cacertfile = NULL;
+        int free_path;
         debug((char *) "%s| %s: DEBUG: Enable server certificate check for ldap server.\n", LogTime(), PROGRAM);
         val = LDAP_OPT_X_TLS_DEMAND;
         rc = ldap_set_option(NULL, LDAP_OPT_X_TLS_REQUIRE_CERT, &val);
@@ -509,7 +510,6 @@ ldap_set_ssl_defaults(struct main_args *margs)
         rc = ldap_set_option(NULL, LDAP_OPT_X_TLS_CACERTFILE, ssl_cacertfile);
         if (ssl_cacertfile && free_path) {
             xfree(ssl_cacertfile);
-            ssl_cacertfile = NULL;
         }
         if (rc != LDAP_OPT_SUCCESS) {
             error((char *) "%s| %s: ERROR: Error while setting LDAP_OPT_X_TLS_CACERTFILE for ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
@@ -543,10 +543,7 @@ ldap_set_ssl_defaults(struct main_args *margs)
         rc = ldapssl_advclientauth_init(ssl_certdbpath, NULL, 0, NULL, NULL, 0, NULL, 0);
         debug((char *) "%s| %s: DEBUG: Disable server certificate check for ldap server.\n", LogTime(), PROGRAM);
     }
-    if (ssl_certdbpath) {
-        xfree(ssl_certdbpath);
-        ssl_certdbpath = NULL;
-    }
+    xfree(ssl_certdbpath);
     if (rc != LDAP_SUCCESS) {
         error((char *) "%s| %s: ERROR: Error while setting SSL for ldap server: %s\n", LogTime(), PROGRAM, ldapssl_err2string(rc));
         return rc;
@@ -557,13 +554,13 @@ ldap_set_ssl_defaults(struct main_args *margs)
     return LDAP_SUCCESS;
 }
 
-int
-get_attributes(struct main_args *margs, LDAP * ld, LDAPMessage * res, const char *attribute, char ***ret_value)
+size_t
+get_attributes(LDAP * ld, LDAPMessage * res, const char *attribute, char ***ret_value)
 {
 
     LDAPMessage *msg;
     char **attr_value = NULL;
-    int max_attr = 0;
+    size_t max_attr = 0;
 
     attr_value = *ret_value;
     /*
@@ -588,15 +585,15 @@ get_attributes(struct main_args *margs, LDAP * ld, LDAPMessage * res, const char
                     if ((values = ldap_get_values_len(ld, msg, attr)) != NULL) {
                         for (il = 0; values[il] != NULL; ++il) {
 
-                            attr_value = (char **) xrealloc(attr_value, (il + 1) * sizeof(char *));
+                            attr_value = (char **) xrealloc(attr_value, (max_attr + 1) * sizeof(char *));
                             if (!attr_value)
                                 break;
 
-                            attr_value[il] = (char *) xmalloc(values[il]->bv_len + 1);
-                            memcpy(attr_value[il], values[il]->bv_val, values[il]->bv_len);
-                            attr_value[il][values[il]->bv_len] = 0;
+                            attr_value[max_attr] = (char *) xmalloc(values[il]->bv_len + 1);
+                            memcpy(attr_value[max_attr], values[il]->bv_val, values[il]->bv_len);
+                            attr_value[max_attr][values[il]->bv_len] = 0;
+                            max_attr++;
                         }
-                        max_attr = il;
                     }
                     ber_bvecfree(values);
                 }
@@ -615,7 +612,7 @@ get_attributes(struct main_args *margs, LDAP * ld, LDAPMessage * res, const char
         }
     }
 
-    debug((char *) "%s| %s: DEBUG: %d ldap entr%s found with attribute : %s\n", LogTime(), PROGRAM, max_attr, max_attr > 1 || max_attr == 0 ? "ies" : "y", attribute);
+    debug((char *) "%s| %s: DEBUG: %" PRIuSIZE " ldap entr%s found with attribute : %s\n", LogTime(), PROGRAM, max_attr, max_attr > 1 || max_attr == 0 ? "ies" : "y", attribute);
 
     *ret_value = attr_value;
     return max_attr;
@@ -661,13 +658,13 @@ tool_ldap_open(struct main_args * margs, char *host, int port, char *ssl)
     if (rc != LDAP_SUCCESS) {
         error((char *) "%s| %s: ERROR: Error while parsing url: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
         xfree(ldapuri);
-        xfree(url);
+        ldap_free_urldesc(url);
         return NULL;
     }
 #else
 #error "No URL parsing function"
 #endif
-    safe_free(url);
+    ldap_free_urldesc(url);
     rc = ldap_initialize(&ld, ldapuri);
     xfree(ldapuri);
     if (rc != LDAP_SUCCESS) {
@@ -679,7 +676,7 @@ tool_ldap_open(struct main_args * margs, char *host, int port, char *ssl)
 #else
     ld = ldap_init(host, port);
 #endif
-    rc = ldap_set_defaults(margs, ld);
+    rc = ldap_set_defaults(ld);
     if (rc != LDAP_SUCCESS) {
         error((char *) "%s| %s: ERROR: Error while setting default options for ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
         ldap_unbind(ld);
@@ -726,13 +723,13 @@ tool_ldap_open(struct main_args * margs, char *host, int port, char *ssl)
             if (rc != LDAP_SUCCESS) {
                 error((char *) "%s| %s: ERROR: Error while parsing url: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
                 xfree(ldapuri);
-                xfree(url);
+                ldap_free_urldesc(url);
                 return NULL;
             }
 #else
 #error "No URL parsing function"
 #endif
-            safe_free(url);
+            ldap_free_urldesc(url);
             rc = ldap_initialize(&ld, ldapuri);
             xfree(ldapuri);
             if (rc != LDAP_SUCCESS) {
@@ -741,7 +738,7 @@ tool_ldap_open(struct main_args * margs, char *host, int port, char *ssl)
                 ld = NULL;
                 return NULL;
             }
-            rc = ldap_set_defaults(margs, ld);
+            rc = ldap_set_defaults(ld);
             if (rc != LDAP_SUCCESS) {
                 error((char *) "%s| %s: ERROR: Error while setting default options for ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
                 ldap_unbind(ld);
@@ -757,7 +754,7 @@ tool_ldap_open(struct main_args * margs, char *host, int port, char *ssl)
             ld = NULL;
             return NULL;
         }
-        rc = ldap_set_defaults(margs, ld);
+        rc = ldap_set_defaults(ld);
         if (rc != LDAP_SUCCESS) {
             error((char *) "%s| %s: ERROR: Error while setting default options for ldap server: %s\n", LogTime(), PROGRAM, ldap_err2string(rc));
             ldap_unbind(ld);
@@ -787,18 +784,12 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
     char *filter = NULL;
     char *search_exp;
     struct timeval searchtime;
-    int i, j, rc = 0, kc = 1;
+    int rc = 0, kc = 1;
     int retval;
     char **attr_value = NULL;
-    char *av = NULL, *avp = NULL;
-    int max_attr = 0;
+    size_t max_attr = 0;
     struct hstruct *hlist = NULL;
-    int nhosts = 0;
-    char *hostname;
-    char *host;
-    int port;
-    char *ssl = NULL;
-    char *p;
+    size_t nhosts = 0;
     char *ldap_filter_esc = NULL;
 
     searchtime.tv_sec = SEARCH_TIMEOUT;
@@ -810,7 +801,7 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
         debug((char *) "%s| %s: DEBUG: Setup Kerberos credential cache\n", LogTime(), PROGRAM);
 
 #ifdef HAVE_KRB5
-        kc = krb5_create_cache(margs, domain);
+        kc = krb5_create_cache(domain);
         if (kc) {
             error((char *) "%s| %s: ERROR: Error during setup of Kerberos credential cache\n", LogTime(), PROGRAM);
         }
@@ -847,8 +838,8 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
          * Loop over list of ldap servers of users domain
          */
         nhosts = get_ldap_hostname_list(margs, &hlist, 0, domain);
-        for (i = 0; i < nhosts; ++i) {
-            port = 389;
+        for (size_t i = 0; i < nhosts; ++i) {
+            int port = 389;
             if (hlist[i].port != -1)
                 port = hlist[i].port;
             debug((char *) "%s| %s: DEBUG: Setting up connection to ldap server %s:%d\n", LogTime(), PROGRAM, hlist[i].host, port);
@@ -893,6 +884,11 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
         bindp = convert_domain_to_bind_path(domain);
     }
     if ((!domain || !ld) && margs->lurl && strstr(margs->lurl, "://")) {
+        char *hostname;
+        char *host;
+        int port;
+        char *ssl = NULL;
+        char *p;
         /*
          * If username does not contain a domain and a url was given then try it
          */
@@ -912,9 +908,9 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
             ++p;
             port = atoi(p);
         }
-        nhosts = get_hostname_list(margs, &hlist, 0, host);
-        safe_free(host);
-        for (i = 0; i < nhosts; ++i) {
+        nhosts = get_hostname_list(&hlist, 0, host);
+        xfree(host);
+        for (size_t i = 0; i < nhosts; ++i) {
 
             ld = tool_ldap_open(margs, hlist[i].host, port, ssl);
             if (!ld)
@@ -997,40 +993,41 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
     if (ldap_count_entries(ld, res) != 0) {
 
         if (margs->AD)
-            max_attr = get_attributes(margs, ld, res, ATTRIBUTE_AD, &attr_value);
+            max_attr = get_attributes(ld, res, ATTRIBUTE_AD, &attr_value);
         else {
-            max_attr = get_attributes(margs, ld, res, ATTRIBUTE, &attr_value);
+            max_attr = get_attributes(ld, res, ATTRIBUTE, &attr_value);
         }
 
         /*
          * Compare group names
          */
         retval = 0;
-        for (j = 0; j < max_attr; ++j) {
+        for (size_t k = 0; k < max_attr; ++k) {
+            char *av = NULL;
 
             /* Compare first CN= value assuming it is the same as the group name itself */
-            av = attr_value[j];
+            av = attr_value[k];
             if (!strncasecmp("CN=", av, 3)) {
+                char *avp = NULL;
                 av += 3;
                 if ((avp = strchr(av, ','))) {
                     *avp = '\0';
                 }
             }
             if (debug_enabled) {
-                int n;
-                debug((char *) "%s| %s: DEBUG: Entry %d \"%s\" in hex UTF-8 is ", LogTime(), PROGRAM, j + 1, av);
-                for (n = 0; av[n] != '\0'; ++n)
+                debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " \"%s\" in hex UTF-8 is ", LogTime(), PROGRAM, k + 1, av);
+                for (unsigned int n = 0; av[n] != '\0'; ++n)
                     fprintf(stderr, "%02x", (unsigned char) av[n]);
                 fprintf(stderr, "\n");
             }
             if (!strcasecmp(group, av)) {
                 retval = 1;
                 if (debug_enabled)
-                    debug((char *) "%s| %s: DEBUG: Entry %d \"%s\" matches group name \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
+                    debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " \"%s\" matches group name \"%s\"\n", LogTime(), PROGRAM, k + 1, av, group);
                 else
                     break;
             } else
-                debug((char *) "%s| %s: DEBUG: Entry %d \"%s\" does not match group name \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
+                debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " \"%s\" does not match group name \"%s\"\n", LogTime(), PROGRAM, k + 1, av, group);
         }
         /*
          * Do recursive group search for AD only since posixgroups can not contain other groups
@@ -1039,19 +1036,21 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
             if (debug_enabled && max_attr > 0) {
                 debug((char *) "%s| %s: DEBUG: Perform recursive group search\n", LogTime(), PROGRAM);
             }
-            for (j = 0; j < max_attr; ++j) {
+            for (size_t j = 0; j < max_attr; ++j) {
+                char *av = NULL;
 
                 av = attr_value[j];
                 if (search_group_tree(margs, ld, bindp, av, group, 1)) {
                     retval = 1;
                     if (!strncasecmp("CN=", av, 3)) {
+                        char *avp = NULL;
                         av += 3;
                         if ((avp = strchr(av, ','))) {
                             *avp = '\0';
                         }
                     }
                     if (debug_enabled)
-                        debug((char *) "%s| %s: DEBUG: Entry %d group \"%s\" is (in)direct member of group \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
+                        debug((char *) "%s| %s: DEBUG: Entry %" PRIuSIZE " group \"%s\" is (in)direct member of group \"%s\"\n", LogTime(), PROGRAM, j + 1, av, group);
                     else
                         break;
                 }
@@ -1061,11 +1060,10 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
          * Cleanup
          */
         if (attr_value) {
-            for (j = 0; j < max_attr; ++j) {
+            for (size_t j = 0; j < max_attr; ++j) {
                 xfree(attr_value[j]);
             }
-            xfree(attr_value);
-            attr_value = NULL;
+            safe_free(attr_value);
         }
         ldap_msgfree(res);
     } else if (ldap_count_entries(ld, res) == 0 && margs->AD) {
@@ -1101,11 +1099,11 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
 
         debug((char *) "%s| %s: DEBUG: Found %d ldap entr%s\n", LogTime(), PROGRAM, ldap_count_entries(ld, res), ldap_count_entries(ld, res) > 1 || ldap_count_entries(ld, res) == 0 ? "ies" : "y");
 
-        max_attr = get_attributes(margs, ld, res, ATTRIBUTE_GID, &attr_value);
+        max_attr = get_attributes(ld, res, ATTRIBUTE_GID, &attr_value);
 
         if (max_attr == 1) {
             char **attr_value_2 = NULL;
-            int max_attr_2 = 0;
+            size_t max_attr_2 = 0;
 
             ldap_msgfree(res);
             filter = (char *) FILTER_GID;
@@ -1123,15 +1121,14 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
                                    NULL, NULL, &searchtime, 0, &res);
             xfree(search_exp);
 
-            max_attr_2 = get_attributes(margs, ld, res, ATTRIBUTE, &attr_value_2);
+            max_attr_2 = get_attributes(ld, res, ATTRIBUTE, &attr_value_2);
             /*
              * Compare group names
              */
             retval = 0;
             if (max_attr_2 == 1) {
-
                 /* Compare first CN= value assuming it is the same as the group name itself */
-                av = attr_value_2[0];
+                char *av = attr_value_2[0];
                 if (!strcasecmp(group, av)) {
                     retval = 1;
                     debug((char *) "%s| %s: DEBUG: \"%s\" matches group name \"%s\"\n", LogTime(), PROGRAM, av, group);
@@ -1143,11 +1140,11 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
              * Cleanup
              */
             if (attr_value_2) {
+                size_t j;
                 for (j = 0; j < max_attr_2; ++j) {
                     xfree(attr_value_2[j]);
                 }
-                xfree(attr_value_2);
-                attr_value_2 = NULL;
+                safe_free(attr_value_2);
             }
             ldap_msgfree(res);
 
@@ -1161,11 +1158,10 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
          * Cleanup
          */
         if (attr_value) {
-            for (j = 0; j < max_attr; ++j) {
+            for (size_t j = 0; j < max_attr; ++j) {
                 xfree(attr_value[j]);
             }
-            xfree(attr_value);
-            attr_value = NULL;
+            safe_free(attr_value);
         }
     }
     rc = ldap_unbind(ld);
@@ -34,13 +34,13 @@
 const char *
 LogTime()
 {
-    struct tm *tm;
-    struct timeval now;
     static time_t last_t = 0;
+    struct timeval now;
     static char buf[128];
 
     gettimeofday(&now, NULL);
     if (now.tv_sec != last_t) {
+        struct tm *tm;
         time_t tmp = now.tv_sec;
         tm = localtime(&tmp);
         strftime(buf, 127, "%Y/%m/%d %H:%M:%S", tm);
@@ -29,6 +29,7 @@
 
 #include "support.h"
 struct lsstruct *init_ls(void);
+void free_ls(struct lsstruct *lssp);
 
 struct lsstruct *
 init_ls(void) {
@@ -30,6 +30,7 @@
 #include "support.h"
 
 struct ndstruct *init_nd(void);
+void free_nd(struct ndstruct *ndsp);
 
 struct ndstruct *
 init_nd(void) {
@@ -95,10 +95,10 @@ static void
 sort(struct hstruct *array, int nitems, int (*cmp) (struct hstruct *, struct hstruct *), int begin, int end)
 {
     if (end > begin) {
-        int pivot = begin;
         int l = begin + 1;
         int r = end;
         while (l < r) {
+            int pivot = begin;
             if (cmp(&array[l], &array[pivot]) <= 0) {
                 l += 1;
             } else {
@@ -116,7 +116,7 @@ sort(struct hstruct *array, int nitems, int (*cmp) (struct hstruct *, struct hst
 static void
 msort(struct hstruct *array, size_t nitems, int (*cmp) (struct hstruct *, struct hstruct *))
 {
-    sort(array, nitems, cmp, 0, nitems - 1);
+    sort(array, (int)nitems, cmp, 0, (int)(nitems - 1));
 }
 
 static int
@@ -145,33 +145,25 @@ compare_hosts(struct hstruct *host1, struct hstruct *host2)
     return 0;
 }
 
-int
-free_hostname_list(struct hstruct **hlist, int nhosts)
+size_t
+free_hostname_list(struct hstruct **hlist, size_t nhosts)
 {
     struct hstruct *hp = NULL;
-    int i;
+    size_t i;
 
     hp = *hlist;
     for (i = 0; i < nhosts; ++i) {
-        if (hp[i].host)
-            xfree(hp[i].host);
-        hp[i].host = NULL;
+        xfree(hp[i].host);
     }
 
-    if (hp)
-        xfree(hp);
-    hp = NULL;
+    safe_free(hp);
     *hlist = hp;
     return 0;
 }
 
-int
-get_hostname_list(struct main_args *margs, struct hstruct **hlist, int nhosts, char *name)
+size_t
+get_hostname_list(struct hstruct **hlist, size_t nhosts, char *name)
 {
-    /*
-     * char host[sysconf(_SC_HOST_NAME_MAX)];
-     */
-    char host[1024];
     struct addrinfo *hres = NULL, *hres_list;
     int rc, count;
     struct hstruct *hp = NULL;
@@ -194,6 +186,10 @@ get_hostname_list(struct main_args *margs, struct hstruct **hlist, int nhosts, c
     hres_list = hres;
     count = 0;
     while (hres_list) {
+        /*
+         * char host[sysconf(_SC_HOST_NAME_MAX)];
+         */
+        char host[1024];
         rc = getnameinfo(hres_list->ai_addr, hres_list->ai_addrlen, host, sizeof(host), NULL, 0, 0);
         if (rc != 0) {
             error((char *) "%s| %s: ERROR: Error while resolving ip address with getnameinfo: %s\n", LogTime(), PROGRAM, gai_strerror(rc));
@@ -219,24 +215,21 @@ get_hostname_list(struct main_args *margs, struct hstruct **hlist, int nhosts, c
     return (nhosts);
 }
 
-int
-get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, int nh, char *domain)
+size_t
+get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, size_t nh, char *domain)
 {
 
     /*
      * char name[sysconf(_SC_HOST_NAME_MAX)];
      */
     char name[1024];
-    char host[NS_MAXDNAME];
     char *service = NULL;
     struct hstruct *hp = NULL;
     struct lsstruct *ls = NULL;
-    int nhosts = 0;
+    size_t nhosts = 0;
     int size;
-    int type, rdlength;
-    int priority, weight, port;
     int len, olen;
-    int i, j, k;
+    size_t i, j, k;
     u_char *buffer = NULL;
     u_char *p;
 
@@ -305,7 +298,7 @@ get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, int nh,
     }
     if (len > PACKETSZ_MULT * NS_PACKETSZ) {
         olen = len;
-        buffer = (u_char *) xrealloc(buffer, len);
+        buffer = (u_char *) xrealloc(buffer, (size_t)len);
         if ((len = res_search(service, ns_c_in, ns_t_srv, (u_char *) buffer, len)) < 0) {
             error((char *) "%s| %s: ERROR: Error while resolving service record %s with res_search\n", LogTime(), PROGRAM, service);
             nsError(h_errno, service);
@@ -322,7 +315,7 @@ get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, int nh,
         error((char *) "%s| %s: ERROR: Message to small: %d < header size\n", LogTime(), PROGRAM, len);
         goto finalise;
     }
-    if ((size = dn_expand(buffer, buffer + len, p, name, sysconf(_SC_HOST_NAME_MAX))) < 0) {
+    if ((size = dn_expand(buffer, buffer + len, p, name, sizeof(name))) < 0) {
         error((char *) "%s| %s: ERROR: Error while expanding query name with dn_expand:  %s\n", LogTime(), PROGRAM, strerror(errno));
         goto finalise;
     }
@@ -333,7 +326,8 @@ get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, int nh,
         goto finalise;
     }
     while (p < buffer + len) {
-        if ((size = dn_expand(buffer, buffer + len, p, name, sysconf(_SC_HOST_NAME_MAX))) < 0) {
+        int type, rdlength;
+        if ((size = dn_expand(buffer, buffer + len, p, name, sizeof(name))) < 0) {
             error((char *) "%s| %s: ERROR: Error while expanding answer name with dn_expand:  %s\n", LogTime(), PROGRAM, strerror(errno));
             goto finalise;
         }
@@ -351,6 +345,8 @@ get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, int nh,
         NS_GET16(rdlength, p);	/* RR data length (16bit) */
 
         if (type == ns_t_srv) {	/* SRV record */
+            int priority, weight, port;
+            char host[NS_MAXDNAME];
             if (p > buffer + len) {
                 error((char *) "%s| %s: ERROR: Message to small: %d < header + query name,type,class + answer name + RR type,class,ttl + RR data length\n", LogTime(), PROGRAM, len);
                 goto finalise;
@@ -400,7 +396,7 @@ get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, int nh,
     }
 
 finalise:
-    nhosts = get_hostname_list(margs, &hp, nh, domain);
+    nhosts = get_hostname_list(&hp, nh, domain);
 
     debug("%s| %s: DEBUG: Adding %s to list\n", LogTime(), PROGRAM, domain);
 
@@ -435,18 +431,16 @@ get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, int nh,
     }
 
     /* Sort by Priority / Weight */
-    msort(hp, nhosts, compare_hosts);
+    msort(hp, (size_t)nhosts, compare_hosts);
 
     if (debug_enabled) {
         debug((char *) "%s| %s: DEBUG: Sorted ldap server names for domain %s:\n", LogTime(), PROGRAM, domain);
         for (i = 0; i < nhosts; ++i) {
             debug((char *) "%s| %s: DEBUG: Host: %s Port: %d Priority: %d Weight: %d\n", LogTime(), PROGRAM, hp[i].host, hp[i].port, hp[i].priority, hp[i].weight);
         }
     }
-    if (buffer)
-        xfree(buffer);
-    if (service)
-        xfree(service);
+    xfree(buffer);
+    xfree(service);
     *hlist = hp;
     return (nhosts);
 }
@@ -196,18 +196,12 @@ lutil_sasl_freedefs(
 {
     lutilSASLdefaults *defs = (lutilSASLdefaults *) defaults;
 
-    if (defs->mech)
-        xfree(defs->mech);
-    if (defs->realm)
-        xfree(defs->realm);
-    if (defs->authcid)
-        xfree(defs->authcid);
-    if (defs->passwd)
-        xfree(defs->passwd);
-    if (defs->authzid)
-        xfree(defs->authzid);
-    if (defs->resps)
-        xfree(defs->resps);
+    xfree(defs->mech);
+    xfree(defs->realm);
+    xfree(defs->authcid);
+    xfree(defs->passwd);
+    xfree(defs->authzid);
+    xfree(defs->resps);
 
     xfree(defs);
 }
@@ -7,7 +7,7 @@ libexec_PROGRAMS = negotiate_kerberos_auth negotiate_kerberos_auth_test
 
 AM_CPPFLAGS = $(INCLUDES) -I$(srcdir)
 
-negotiate_kerberos_auth_SOURCES = negotiate_kerberos_auth.cc
+negotiate_kerberos_auth_SOURCES = negotiate_kerberos_auth.cc negotiate_kerberos_pac.cc negotiate_kerberos.h
 negotiate_kerberos_auth_LDFLAGS = 
 negotiate_kerberos_auth_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
@@ -0,0 +1,154 @@
+/*
+ * -----------------------------------------------------------------------------
+ *
+ * Author: Markus Moeller (markus_moeller at compuserve.com)
+ *
+ * Copyright (C) 2013 Markus Moeller. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
+ *
+ *   As a special exemption, M Moeller gives permission to link this program
+ *   with MIT, Heimdal or other GSS/Kerberos libraries, and distribute
+ *   the resulting executable, without including the source code for
+ *   the Libraries in the source distribution.
+ *
+ * -----------------------------------------------------------------------------
+ */
+
+#if HAVE_STRING_H
+#include <string.h>
+#endif
+#if HAVE_STDIO_H
+#include <stdio.h>
+#endif
+#if HAVE_NETDB_H
+#include <netdb.h>
+#endif
+#if HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#if HAVE_TIME_H
+#include <time.h>
+#endif
+
+#include "util.h"
+#include "base64.h"
+
+#if HAVE_KRB5_H
+#if HAVE_BROKEN_SOLARIS_KRB5_H
+#warn "Warning! You have a broken Solaris <krb5.h> system header"
+#warn "http://bugs.opensolaris.org/bugdatabase/view_bug.do?bug_id=6837512"
+#if defined(__cplusplus)
+#define KRB5INT_BEGIN_DECLS     extern "C" {
+#define KRB5INT_END_DECLS
+KRB5INT_BEGIN_DECLS
+#endif
+#endif /* HAVE_BROKEN_SOLARIS_KRB5_H */
+#if HAVE_BROKEN_HEIMDAL_KRB5_H
+extern "C" {
+#include <krb5.h>
+}
+#else
+#include <krb5.h>
+#endif
+#endif /* HAVE_KRB5_H */
+
+#if HAVE_GSSAPI_GSSAPI_H
+#include <gssapi/gssapi.h>
+#elif HAVE_GSSAPI_H
+#include <gssapi.h>
+#endif
+
+#if !HAVE_HEIMDAL_KERBEROS
+#if HAVE_GSSAPI_GSSAPI_KRB5_H
+#include <gssapi/gssapi_krb5.h>
+#endif
+#if HAVE_GSSAPI_GSSAPI_GENERIC_H
+#include <gssapi/gssapi_generic.h>
+#endif
+#if HAVE_GSSAPI_GSSAPI_EXT_H
+#include <gssapi/gssapi_ext.h>
+#endif
+#else
+#if HAVE_GSSAPI_GSSAPI_KRB5_H
+#include <gssapi/gssapi_krb5.h>
+#endif
+#endif
+
+#ifndef gss_nt_service_name
+#define gss_nt_service_name GSS_C_NT_HOSTBASED_SERVICE
+#endif
+
+#define PROGRAM "negotiate_kerberos_auth"
+
+#ifndef MAX_AUTHTOKEN_LEN
+#define MAX_AUTHTOKEN_LEN   65535
+#endif
+#ifndef SQUID_KERB_AUTH_VERSION
+#define SQUID_KERB_AUTH_VERSION "3.0.4sq"
+#endif
+
+char *gethost_name(void);
+
+static const unsigned char ntlmProtocol[] = {'N', 'T', 'L', 'M', 'S', 'S', 'P', 0};
+
+inline const char *
+LogTime()
+{
+    struct tm *tm;
+    struct timeval now;
+    static time_t last_t = 0;
+    static char buf[128];
+
+    gettimeofday(&now, NULL);
+    if (now.tv_sec != last_t) {
+        tm = localtime((time_t *) & now.tv_sec);
+        strftime(buf, 127, "%Y/%m/%d %H:%M:%S", tm);
+        last_t = now.tv_sec;
+    }
+    return buf;
+}
+
+int check_gss_err(OM_uint32 major_status, OM_uint32 minor_status,
+                  const char *function, int log, int sout);
+
+char *gethost_name(void);
+
+#if (defined(HAVE_GSSKRB5_EXTRACT_AUTHZ_DATA_FROM_SEC_CONTEXT) || defined(HAVE_GSS_MAP_NAME_TO_ANY)) && HAVE_KRB5_PAC
+#define HAVE_PAC_SUPPORT 1
+#define MAX_PAC_GROUP_SIZE 200*60
+typedef struct {
+    uint16_t length;
+    uint16_t maxlength;
+    uint32_t pointer;
+} RPC_UNICODE_STRING;
+
+int check_k5_err(krb5_context context, const char *msg, krb5_error_code code);
+void align(int n);
+void getustr(RPC_UNICODE_STRING *string);
+char **getgids(char **Rids, uint32_t GroupIds, uint32_t GroupCount);
+char *getdomaingids(char *ad_groups, uint32_t DomainLogonId, char **Rids, uint32_t  GroupCount);
+char *getextrasids(char *ad_groups, uint32_t ExtraSids, uint32_t SidCount);
+uint64_t get6byt_be(void);
+uint32_t get4byt(void);
+uint16_t get2byt(void);
+uint8_t get1byt(void);
+char *xstrcpy( char *src, const char*dst);
+char *xstrcat( char *src, const char*dst);
+int checkustr(RPC_UNICODE_STRING *string);
+char *get_ad_groups(char *ad_groups, krb5_context context, krb5_pac pac);
+#else
+#define HAVE_PAC_SUPPORT 0
+#endif
@@ -36,79 +36,7 @@
 
 #if HAVE_GSSAPI
 
-#if HAVE_STRING_H
-#include <string.h>
-#endif
-#if HAVE_STDOI_H
-#include <stdio.h>
-#endif
-#if HAVE_NETDB_H
-#include <netdb.h>
-#endif
-#if HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-#if HAVE_TIME_H
-#include <time.h>
-#endif
-
-#include "util.h"
-#include "base64.h"
-
-#if HAVE_GSSAPI_GSSAPI_H
-#include <gssapi/gssapi.h>
-#elif HAVE_GSSAPI_H
-#include <gssapi.h>
-#endif
-
-#if !HAVE_HEIMDAL_KERBEROS
-#if HAVE_GSSAPI_GSSAPI_KRB5_H
-#include <gssapi/gssapi_krb5.h>
-#endif
-#if HAVE_GSSAPI_GSSAPI_GENERIC_H
-#include <gssapi/gssapi_generic.h>
-#endif
-#if HAVE_GSSAPI_GSSAPI_EXT_H
-#include <gssapi/gssapi_ext.h>
-#endif
-#endif
-
-#ifndef gss_nt_service_name
-#define gss_nt_service_name GSS_C_NT_HOSTBASED_SERVICE
-#endif
-
-#define PROGRAM "negotiate_kerberos_auth"
-
-#ifndef MAX_AUTHTOKEN_LEN
-#define MAX_AUTHTOKEN_LEN   65535
-#endif
-#ifndef SQUID_KERB_AUTH_VERSION
-#define SQUID_KERB_AUTH_VERSION "3.0.4sq"
-#endif
-
-int check_gss_err(OM_uint32 major_status, OM_uint32 minor_status,
-                  const char *function, int log);
-char *gethost_name(void);
-static const char *LogTime(void);
-
-static const unsigned char ntlmProtocol[] = {'N', 'T', 'L', 'M', 'S', 'S', 'P', 0};
-
-static const char *
-LogTime()
-{
-    struct tm *tm;
-    struct timeval now;
-    static time_t last_t = 0;
-    static char buf[128];
-
-    gettimeofday(&now, NULL);
-    if (now.tv_sec != last_t) {
-        tm = localtime((time_t *) & now.tv_sec);
-        strftime(buf, 127, "%Y/%m/%d %H:%M:%S", tm);
-        last_t = now.tv_sec;
-    }
-    return buf;
-}
+#include "negotiate_kerberos.h"
 
 char *
 gethost_name(void)
@@ -155,7 +83,7 @@ gethost_name(void)
 
 int
 check_gss_err(OM_uint32 major_status, OM_uint32 minor_status,
-              const char *function, int log)
+              const char *function, int log, int sout)
 {
     if (GSS_ERROR(major_status)) {
         OM_uint32 maj_stat, min_stat;
@@ -198,7 +126,8 @@ check_gss_err(OM_uint32 major_status, OM_uint32 minor_status,
             gss_release_buffer(&min_stat, &status_string);
         } while (msg_ctx);
         debug((char *) "%s| %s: ERROR: %s failed: %s\n", LogTime(), PROGRAM, function, buf);
-        fprintf(stdout, "BH %s failed: %s\n", function, buf);
+        if (sout)
+            fprintf(stdout, "BH %s failed: %s\n", function, buf);
         if (log)
             fprintf(stderr, "%s| %s: INFO: User not authenticated\n", LogTime(),
                     PROGRAM);
@@ -213,7 +142,20 @@ main(int argc, char *const argv[])
     char buf[MAX_AUTHTOKEN_LEN];
     char *c, *p;
     char *user = NULL;
-    int length = 0;
+    char *rfc_user = NULL;
+#if HAVE_PAC_SUPPORT
+    char ad_groups[MAX_PAC_GROUP_SIZE];
+    char *ag=NULL;
+    krb5_context context = NULL;
+    krb5_error_code ret;
+    krb5_pac pac;
+#if HAVE_HEIMDAL_KERBEROS
+    gss_buffer_desc data_set = GSS_C_EMPTY_BUFFER;
+#else
+    gss_buffer_desc type_id = GSS_C_EMPTY_BUFFER;
+#endif
+#endif
+    long length = 0;
     static int err = 0;
     int opt, log = 0, norealm = 0;
     OM_uint32 ret_flags = 0, spnego_flag = 0;
@@ -284,6 +226,7 @@ main(int argc, char *const argv[])
         snprintf((char *) service.value, strlen(service_name) + strlen(host_name) + 2,
                  "%s@%s", service_name, host_name);
         service.length = strlen((char *) service.value);
+        xfree(host_name);
     }
 
     while (1) {
@@ -312,7 +255,7 @@ main(int argc, char *const argv[])
             err = 0;
             continue;
         }
-        debug((char *) "%s| %s: DEBUG: Got '%s' from squid (length: %d).\n", LogTime(), PROGRAM, buf, length);
+        debug((char *) "%s| %s: DEBUG: Got '%s' from squid (length: %ld).\n", LogTime(), PROGRAM, buf, length);
 
         if (buf[0] == '\0') {
             debug((char *) "%s| %s: ERROR: Invalid request\n", LogTime(), PROGRAM);
@@ -338,23 +281,13 @@ main(int argc, char *const argv[])
             if (kerberosToken) {
                 /* Allocated by parseNegTokenInit, but no matching free function exists.. */
                 if (!spnego_flag)
-                    xfree((char *) kerberosToken);
-                kerberosToken = NULL;
+                    xfree(kerberosToken);
             }
             if (spnego_flag) {
                 /* Allocated by makeNegTokenTarg, but no matching free function exists.. */
-                if (spnegoToken)
-                    xfree((char *) spnegoToken);
-                spnegoToken = NULL;
-            }
-            if (token) {
-                xfree(token);
-                token = NULL;
-            }
-            if (host_name) {
-                xfree(host_name);
-                host_name = NULL;
+                xfree(spnegoToken);
             }
+            xfree(token);
             fprintf(stdout, "BH quit command\n");
             exit(0);
         }
@@ -373,12 +306,12 @@ main(int argc, char *const argv[])
             fprintf(stdout, "BH Invalid negotiate request\n");
             continue;
         }
-        input_token.length = base64_decode_len(buf+3);
+        input_token.length = (size_t)base64_decode_len(buf+3);
         debug((char *) "%s| %s: DEBUG: Decode '%s' (decoded length: %d).\n",
               LogTime(), PROGRAM, buf + 3, (int) input_token.length);
         input_token.value = xmalloc(input_token.length);
 
-        input_token.length = base64_decode((char *) input_token.value, input_token.length, buf+3);
+        input_token.length = (size_t)base64_decode((char *) input_token.value, (unsigned int)input_token.length, buf+3);
 
         if ((input_token.length >= sizeof ntlmProtocol + 1) &&
                 (!memcmp(input_token.value, ntlmProtocol, sizeof ntlmProtocol))) {
@@ -399,19 +332,20 @@ main(int argc, char *const argv[])
             } else {
                 server_name = GSS_C_NO_NAME;
                 major_status = GSS_S_COMPLETE;
+                minor_status = 0;
             }
         } else {
             major_status = gss_import_name(&minor_status, &service,
                                            gss_nt_service_name, &server_name);
         }
 
-        if (check_gss_err(major_status, minor_status, "gss_import_name()", log))
+        if (check_gss_err(major_status, minor_status, "gss_import_name()", log, 1))
             goto cleanup;
 
         major_status =
             gss_acquire_cred(&minor_status, server_name, GSS_C_INDEFINITE,
                              GSS_C_NO_OID_SET, GSS_C_ACCEPT, &server_creds, NULL, NULL);
-        if (check_gss_err(major_status, minor_status, "gss_acquire_cred()", log))
+        if (check_gss_err(major_status, minor_status, "gss_acquire_cred()", log, 1))
             goto cleanup;
 
         major_status = gss_accept_sec_context(&minor_status,
@@ -424,16 +358,16 @@ main(int argc, char *const argv[])
         if (output_token.length) {
             spnegoToken = (const unsigned char *) output_token.value;
             spnegoTokenLength = output_token.length;
-            token = (char *) xmalloc(base64_encode_len(spnegoTokenLength));
+            token = (char *) xmalloc((size_t)base64_encode_len((int)spnegoTokenLength));
             if (token == NULL) {
                 debug((char *) "%s| %s: ERROR: Not enough memory\n", LogTime(), PROGRAM);
                 fprintf(stdout, "BH Not enough memory\n");
                 goto cleanup;
             }
-            base64_encode_str(token, base64_encode_len(spnegoTokenLength),
-                              (const char *) spnegoToken, spnegoTokenLength);
+            base64_encode_str(token, base64_encode_len((int)spnegoTokenLength),
+                              (const char *) spnegoToken, (int)spnegoTokenLength);
 
-            if (check_gss_err(major_status, minor_status, "gss_accept_sec_context()", log))
+            if (check_gss_err(major_status, minor_status, "gss_accept_sec_context()", log, 1))
                 goto cleanup;
             if (major_status & GSS_S_CONTINUE_NEEDED) {
                 debug((char *) "%s| %s: INFO: continuation needed\n", LogTime(), PROGRAM);
@@ -445,7 +379,7 @@ main(int argc, char *const argv[])
                 gss_display_name(&minor_status, client_name, &output_token,
                                  NULL);
 
-            if (check_gss_err(major_status, minor_status, "gss_display_name()", log))
+            if (check_gss_err(major_status, minor_status, "gss_display_name()", log, 1))
                 goto cleanup;
             user = (char *) xmalloc(output_token.length + 1);
             if (user == NULL) {
@@ -458,14 +392,49 @@ main(int argc, char *const argv[])
             if (norealm && (p = strchr(user, '@')) != NULL) {
                 *p = '\0';
             }
+
+#if HAVE_PAC_SUPPORT
+            ret = krb5_init_context(&context);
+            if (!check_k5_err(context, "krb5_init_context", ret)) {
+#if HAVE_HEIMDAL_KERBEROS
+#define ADWIN2KPAC 128
+                major_status = gsskrb5_extract_authz_data_from_sec_context(&minor_status,
+                               gss_context, ADWIN2KPAC, &data_set);
+                if (!check_gss_err(major_status, minor_status,
+                                   "gsskrb5_extract_authz_data_from_sec_context()", log, 0)) {
+                    ret = krb5_pac_parse(context, data_set.value, data_set.length, &pac);
+                    gss_release_buffer(&minor_status, &data_set);
+                    if (!check_k5_err(context, "krb5_pac_parse", ret)) {
+                        ag = get_ad_groups((char *)&ad_groups, context, pac);
+                        krb5_pac_free(context, pac);
+                    }
+                    krb5_free_context(context);
+                }
+#else
+                type_id.value = (void *)"mspac";
+                type_id.length = strlen((char *)type_id.value);
+#define KRB5PACLOGONINFO        1
+                major_status = gss_map_name_to_any(&minor_status, client_name, KRB5PACLOGONINFO, &type_id, (gss_any_t *)&pac);
+                if (!check_gss_err(major_status, minor_status, "gss_map_name_to_any()", log, 0)) {
+                    ag = get_ad_groups((char *)&ad_groups,context, pac);
+                }
+                (void)gss_release_any_name_mapping(&minor_status, client_name, &type_id, (gss_any_t *)&pac);
+                krb5_free_context(context);
+#endif
+            }
+            if (ag) {
+                debug((char *) "%s| %s: DEBUG: Groups %s\n", LogTime(), PROGRAM, ag);
+            }
+#endif
             fprintf(stdout, "AF %s %s\n", token, user);
-            debug((char *) "%s| %s: DEBUG: AF %s %s\n", LogTime(), PROGRAM, token, rfc1738_escape(user));
+            rfc_user = rfc1738_escape(user);
+            debug((char *) "%s| %s: DEBUG: AF %s %s\n", LogTime(), PROGRAM, token, rfc_user);
             if (log)
                 fprintf(stderr, "%s| %s: INFO: User %s authenticated\n", LogTime(),
                         PROGRAM, rfc1738_escape(user));
             goto cleanup;
         } else {
-            if (check_gss_err(major_status, minor_status, "gss_accept_sec_context()", log))
+            if (check_gss_err(major_status, minor_status, "gss_accept_sec_context()", log, 1))
                 goto cleanup;
             if (major_status & GSS_S_CONTINUE_NEEDED) {
                 debug((char *) "%s| %s: INFO: continuation needed\n", LogTime(), PROGRAM);
@@ -477,7 +446,7 @@ main(int argc, char *const argv[])
                 gss_display_name(&minor_status, client_name, &output_token,
                                  NULL);
 
-            if (check_gss_err(major_status, minor_status, "gss_display_name()", log))
+            if (check_gss_err(major_status, minor_status, "gss_display_name()", log, 1))
                 goto cleanup;
             /*
              *  Return dummy token AA. May need an extra return tag then AF
@@ -511,23 +480,14 @@ main(int argc, char *const argv[])
         if (kerberosToken) {
             /* Allocated by parseNegTokenInit, but no matching free function exists.. */
             if (!spnego_flag)
-                xfree((char *) kerberosToken);
-            kerberosToken = NULL;
+                safe_free(kerberosToken);
         }
         if (spnego_flag) {
             /* Allocated by makeNegTokenTarg, but no matching free function exists.. */
-            if (spnegoToken)
-                xfree((char *) spnegoToken);
-            spnegoToken = NULL;
-        }
-        if (token) {
-            xfree(token);
-            token = NULL;
-        }
-        if (user) {
-            xfree(user);
-            user = NULL;
+            safe_free(spnegoToken);
         }
+        safe_free(token);
+        safe_free(user);
         continue;
     }
 }
@@ -196,9 +196,9 @@ squid_kerb_proxy_auth(char *proxy)
         goto cleanup;
 
     if (output_token.length) {
-        token = (char *) xmalloc(base64_encode_len(output_token.length));
-        base64_encode_str(token, base64_encode_len(output_token.length),
-                          (const char *) output_token.value, output_token.length);
+        token = (char *) xmalloc((size_t)base64_encode_len((int)output_token.length));
+        base64_encode_str(token, base64_encode_len((int)output_token.length),
+                          (const char *) output_token.value, (int)output_token.length);
     }
 cleanup:
     gss_delete_sec_context(&minor_status, &gss_context, NULL);
@@ -0,0 +1,467 @@
+/*
+ * -----------------------------------------------------------------------------
+ *
+ * Author: Markus Moeller (markus_moeller at compuserve.com)
+ *
+ * Copyright (C) 2007 Markus Moeller. All rights reserved.
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
+ *
+ *   As a special exemption, M Moeller gives permission to link this program
+ *   with MIT, Heimdal or other GSS/Kerberos libraries, and distribute
+ *   the resulting executable, without including the source code for
+ *   the Libraries in the source distribution.
+ *
+ * -----------------------------------------------------------------------------
+ */
+
+#include "squid.h"
+#include "rfc1738.h"
+#include "compat/getaddrinfo.h"
+#include "compat/getnameinfo.h"
+
+#include "negotiate_kerberos.h"
+
+#if HAVE_PAC_SUPPORT
+
+static int bpos;
+static krb5_data *ad_data;
+static unsigned char *p;
+
+int
+check_k5_err(krb5_context context, const char *function, krb5_error_code code)
+{
+    const char *errmsg;
+
+    if (code) {
+        errmsg = krb5_get_error_message(context, code);
+        debug((char *) "%s| %s: ERROR: %s failed: %s\n", LogTime(), PROGRAM, function, errmsg);
+        fprintf(stderr, "%s| %s: ERROR: %s: %s\n", LogTime(), PROGRAM, function, errmsg);
+        krb5_free_error_message(context, errmsg);
+    }
+    return code;
+}
+
+void
+align(int n)
+{
+    if ( bpos % n != 0 ) {
+        int al;
+        al = (bpos/n);
+        bpos = bpos+(bpos-n*al);
+    }
+}
+
+void
+getustr(RPC_UNICODE_STRING *string)
+{
+
+    string->length = (uint16_t)((p[bpos]<<0) | (p[bpos+1]<<8));
+    string->maxlength = (uint16_t)((p[bpos+2]<<0) | (p[bpos+2+1]<<8));
+    string->pointer = (uint32_t)((p[bpos+4]<<0) | (p[bpos+4+1]<<8) | (p[bpos+4+2]<<16) | (p[bpos+4+3]<<24));
+    bpos = bpos+8;
+
+}
+
+uint64_t
+get6byt_be(void)
+{
+    uint64_t var;
+
+    var = ((uint64_t)p[bpos+5]<<0) | ((uint64_t)p[bpos+4]<<8) | ((uint64_t)p[bpos+3]<<16) | ((uint64_t)p[bpos+2]<<24) | ((uint64_t)p[bpos+1]<<32) | ((uint64_t)p[bpos]<<40);
+    bpos = bpos+6;
+
+    return var;
+}
+
+uint32_t
+get4byt(void)
+{
+    uint32_t var;
+
+    var=(uint32_t)((p[bpos]<<0) | (p[bpos+1]<<8) | (p[bpos+2]<<16) | (p[bpos+3]<<24));
+    bpos = bpos+4;
+
+    return var;
+}
+
+uint16_t
+get2byt(void)
+{
+    uint16_t var;
+
+    var=(uint16_t)((p[bpos]<<0) | (p[bpos+1]<<8));
+    bpos = bpos+2;
+
+    return var;
+}
+
+uint8_t
+get1byt(void)
+{
+    uint8_t var;
+
+    var=(uint8_t)((p[bpos]<<0));
+    bpos = bpos+1;
+
+    return var;
+}
+
+char *
+xstrcpy( char *src, const char *dst)
+{
+    if (dst) {
+        if (strlen(dst)>MAX_PAC_GROUP_SIZE)
+            return NULL;
+        else
+            return strcpy(src,dst);
+    } else
+        return src;
+}
+
+char *
+xstrcat( char *src, const char *dst)
+{
+    if (dst) {
+        if (strlen(src)+strlen(dst)+1>MAX_PAC_GROUP_SIZE)
+            return NULL;
+        else
+            return strcat(src,dst);
+    } else
+        return src;
+}
+
+int
+checkustr(RPC_UNICODE_STRING *string)
+{
+    uint32_t size,off,len;
+
+    if (string->pointer != 0) {
+        align(4);
+        size = (uint32_t)((p[bpos]<<0) | (p[bpos+1]<<8) | (p[bpos+2]<<16) | (p[bpos+3]<<24));
+        bpos = bpos+4;
+        off = (uint32_t)((p[bpos]<<0) | (p[bpos+1]<<8) | (p[bpos+2]<<16) | (p[bpos+3]<<24));
+        bpos = bpos+4;
+        len = (uint32_t)((p[bpos]<<0) | (p[bpos+1]<<8) | (p[bpos+2]<<16) | (p[bpos+3]<<24));
+        bpos = bpos+4;
+        if (len > size || off != 0 ||
+                string->length > string->maxlength || len != string->length/2) {
+            debug((char *) "%s| %s: ERROR: RPC_UNICODE_STRING encoding error => size: %d len: %d/%d maxlength: %d offset: %d\n",
+                  LogTime(), PROGRAM, size, len, string->length, string->maxlength, off);
+            return -1;
+        }
+        /* UNICODE string */
+        bpos = bpos+string->length;
+    }
+    return 0;
+}
+
+char **
+getgids(char **Rids, uint32_t GroupIds, uint32_t  GroupCount)
+{
+    if (GroupIds!= 0) {
+        uint32_t ngroup;
+        uint32_t sauth;
+        int l;
+
+        align(4);
+        ngroup = get4byt();
+        if ( ngroup != GroupCount) {
+            debug((char *) "%s| %s: ERROR: Group encoding error => GroupCount: %d Array size: %d\n",
+                  LogTime(), PROGRAM, GroupCount, ngroup);
+            return NULL;
+        }
+        debug((char *) "%s| %s: INFO: Found %d rids\n", LogTime(), PROGRAM, GroupCount);
+
+        Rids=(char **)xcalloc(GroupCount*sizeof(char*),1);
+        for ( l=0; l<(int)GroupCount; l++) {
+            Rids[l]=(char *)xcalloc(4*sizeof(char),1);
+            memcpy((void *)Rids[l],(void *)&p[bpos],4);
+            sauth = get4byt();
+            debug((char *) "%s| %s: Info: Got rid: %u\n", LogTime(), PROGRAM, sauth);
+            /* attribute */
+            bpos = bpos+4;
+        }
+    }
+    return Rids;
+}
+
+char *
+getdomaingids(char *ad_groups, uint32_t DomainLogonId, char **Rids, uint32_t GroupCount)
+{
+    if (DomainLogonId!= 0) {
+        uint32_t nauth;
+        uint8_t rev;
+        uint64_t idauth;
+        uint32_t sauth;
+        char dli[256];
+        char *ag;
+        size_t length;
+        int l;
+
+        align(4);
+
+        nauth = get4byt();
+
+        /* prepend rids with DomainID */
+        length=1+1+6+nauth*4;
+        for (l=0; l<(int)GroupCount; l++) {
+            ag=(char *)xcalloc((length+4)*sizeof(char),1);
+            memcpy((void *)ag,(const void*)&p[bpos],1);
+            memcpy((void *)&ag[1],(const void*)&p[bpos+1],1);
+            ag[1] = ag[1]+1;
+            memcpy((void *)&ag[2],(const void*)&p[bpos+2],6+nauth*4);
+            memcpy((void *)&ag[length],(const void*)Rids[l],4);
+            if (l==0) {
+                if (!xstrcpy(ad_groups,"group=")) {
+                    debug((char *) "%s| %s: WARN: Too many groups ! size > %d : %s\n",
+                          LogTime(), PROGRAM, MAX_PAC_GROUP_SIZE, ad_groups);
+                }
+            } else {
+                if (!xstrcat(ad_groups," group=")) {
+                    debug((char *) "%s| %s: WARN: Too many groups ! size > %d : %s\n",
+                          LogTime(), PROGRAM, MAX_PAC_GROUP_SIZE, ad_groups);
+                }
+            }
+            if (!xstrcat(ad_groups,base64_encode_bin(ag, (int)(length+4)))) {
+                debug((char *) "%s| %s: WARN: Too many groups ! size > %d : %s\n",
+                      LogTime(), PROGRAM, MAX_PAC_GROUP_SIZE, ad_groups);
+            }
+            xfree(ag);
+        }
+
+        /* mainly for debug only */
+        rev = get1byt();
+        bpos = bpos + 1; /*nsub*/
+        idauth = get6byt_be();
+
+        snprintf(dli,sizeof(dli),"S-%d-%lu",rev,(long unsigned int)idauth);
+        for ( l=0; l<(int)nauth; l++ ) {
+            sauth = get4byt();
+            snprintf((char *)&dli[strlen(dli)],sizeof(dli)-strlen(dli),"-%u",sauth);
+        }
+        debug((char *) "%s| %s: INFO: Got DomainLogonId %s\n", LogTime(), PROGRAM, dli);
+    }
+    return ad_groups;
+}
+
+char *
+getextrasids(char *ad_groups, uint32_t ExtraSids, uint32_t SidCount)
+{
+    if (ExtraSids!= 0) {
+        uint32_t ngroup;
+        uint32_t *pa;
+        char *ag;
+        size_t length;
+        int l;
+
+        align(4);
+        ngroup = get4byt();
+        if ( ngroup != SidCount) {
+            debug((char *) "%s| %s: ERROR: Group encoding error => SidCount: %d Array size: %d\n",
+                  LogTime(), PROGRAM, SidCount, ngroup);
+            return NULL;
+        }
+        debug((char *) "%s| %s: INFO: Found %d ExtraSIDs\n", LogTime(), PROGRAM, SidCount);
+
+        pa=(uint32_t *)xmalloc(SidCount*sizeof(uint32_t));
+        for ( l=0; l < (int)SidCount; l++ ) {
+            pa[l] = get4byt();
+            bpos = bpos+4; /* attr */
+        }
+
+        for ( l=0; l<(int)SidCount; l++ ) {
+            char es[256];
+            uint32_t nauth;
+            uint8_t rev;
+            uint64_t idauth;
+            uint32_t sauth;
+            int k;
+
+            if (pa[l] != 0) {
+                nauth = get4byt();
+
+                length = 1+1+6+nauth*4;
+                ag = (char *)xcalloc((length)*sizeof(char),1);
+                memcpy((void *)ag,(const void*)&p[bpos],length);
+                if (!ad_groups) {
+                    if (!xstrcpy(ad_groups,"group=")) {
+                        debug((char *) "%s| %s: WARN: Too many groups ! size > %d : %s\n",
+                              LogTime(), PROGRAM, MAX_PAC_GROUP_SIZE, ad_groups);
+                    }
+                } else {
+                    if (!xstrcat(ad_groups," group=")) {
+                        debug((char *) "%s| %s: WARN: Too many groups ! size > %d : %s\n",
+                              LogTime(), PROGRAM, MAX_PAC_GROUP_SIZE, ad_groups);
+                    }
+                }
+                if (!xstrcat(ad_groups,base64_encode_bin(ag, (int)length))) {
+                    debug((char *) "%s| %s: WARN: Too many groups ! size > %d : %s\n",
+                          LogTime(), PROGRAM, MAX_PAC_GROUP_SIZE, ad_groups);
+                }
+                xfree(ag);
+
+                rev = get1byt();
+                bpos = bpos + 1; /* nsub */
+                idauth = get6byt_be();
+
+                snprintf(es,sizeof(es),"S-%d-%lu",rev,(long unsigned int)idauth);
+                for ( k=0; k<(int)nauth; k++ ) {
+                    sauth = get4byt();
+                    snprintf((char *)&es[strlen(es)],sizeof(es)-strlen(es),"-%u",sauth);
+                }
+                debug((char *) "%s| %s: INFO: Got ExtraSid %s\n", LogTime(), PROGRAM, es);
+            }
+        }
+        xfree(pa);
+    }
+    return ad_groups;
+}
+
+char *
+get_ad_groups(char *ad_groups, krb5_context context, krb5_pac pac)
+{
+    krb5_error_code ret;
+    RPC_UNICODE_STRING EffectiveName;
+    RPC_UNICODE_STRING FullName;
+    RPC_UNICODE_STRING LogonScript;
+    RPC_UNICODE_STRING ProfilePath;
+    RPC_UNICODE_STRING HomeDirectory;
+    RPC_UNICODE_STRING HomeDirectoryDrive;
+    RPC_UNICODE_STRING LogonServer;
+    RPC_UNICODE_STRING LogonDomainName;
+    uint32_t GroupCount=0;
+    uint32_t GroupIds=0;
+    uint32_t LogonDomainId=0;
+    uint32_t SidCount=0;
+    uint32_t ExtraSids=0;
+    /*
+    uint32_t ResourceGroupDomainSid=0;
+    uint32_t ResourceGroupCount=0;
+    uint32_t ResourceGroupIds=0;
+    */
+    char **Rids=NULL;
+    int l=0;
+
+    ad_data = (krb5_data *)xmalloc(sizeof(krb5_data));
+
+#define KERB_LOGON_INFO 1
+    ret = krb5_pac_get_buffer(context, pac, KERB_LOGON_INFO, ad_data);
+    if (check_k5_err(context, "krb5_pac_get_buffer", ret))
+        goto k5clean;
+
+    p = (unsigned char *)ad_data->data;
+
+    debug((char *) "%s| %s: INFO: Got PAC data of lengh %d\n",
+          LogTime(), PROGRAM, (int)ad_data->length);
+
+    /* Skip 16 bytes icommon RPC header
+     * Skip 4 bytes RPC unique pointer referent
+     * http://msdn.microsoft.com/en-gb/library/cc237933.aspx
+     */
+    /* Some data are pointers to data which follows the main KRB5 LOGON structure =>
+     *         So need to read the data
+     * some logical consistency checks are done when analysineg the pointer data
+     */
+    bpos = 20;
+    /* 8 bytes LogonTime
+     * 8 bytes LogoffTime
+     * 8 bytes KickOffTime
+     * 8 bytes PasswordLastSet
+     * 8 bytes PasswordCanChange
+     * 8 bytes PasswordMustChange
+     */
+    bpos = bpos+48;
+    getustr(&EffectiveName);
+    getustr(&FullName);
+    getustr(&LogonScript);
+    getustr(&ProfilePath);
+    getustr(&HomeDirectory);
+    getustr(&HomeDirectoryDrive);
+    /* 2 bytes LogonCount
+     * 2 bytes BadPasswordCount
+     * 4 bytes UserID
+     * 4 bytes PrimaryGroupId
+     */
+    bpos = bpos+12;
+    GroupCount = get4byt();
+    GroupIds = get4byt();
+    /* 4 bytes UserFlags
+     * 16 bytes UserSessionKey
+     */
+    bpos = bpos+20;
+    getustr(&LogonServer);
+    getustr(&LogonDomainName);
+    LogonDomainId = get4byt();
+    /* 8 bytes Reserved1
+     * 4 bytes UserAccountControl
+     * 4 bytes SubAuthStatus
+     * 8 bytes LastSuccessfullLogon
+     * 8 bytes LastFailedLogon
+     * 4 bytes FailedLogonCount
+     * 4 bytes Reserved2
+     */
+    bpos = bpos+40;
+    SidCount = get4byt();
+    ExtraSids = get4byt();
+    /* 4 bytes ResourceGroupDomainSid
+     * 4 bytes ResourceGroupCount
+     * 4 bytes ResourceGroupIds
+     */
+    bpos = bpos+12;
+    /*
+     * Read all data from structure => Now check pointers
+     */
+    if (checkustr(&EffectiveName)<0)
+        goto k5clean;
+    if (checkustr(&FullName)<0)
+        goto k5clean;
+    if (checkustr(&LogonScript)<0)
+        goto k5clean;
+    if (checkustr(&ProfilePath)<0)
+        goto k5clean;
+    if (checkustr(&HomeDirectory)<0)
+        goto k5clean;
+    if (checkustr(&HomeDirectoryDrive)<0)
+        goto k5clean;
+    Rids = getgids(Rids,GroupIds,GroupCount);
+    if (checkustr(&LogonServer)<0)
+        goto k5clean;
+    if (checkustr(&LogonDomainName)<0)
+        goto k5clean;
+    ad_groups = getdomaingids(ad_groups,LogonDomainId,Rids,GroupCount);
+    if ((ad_groups = getextrasids(ad_groups,ExtraSids,SidCount))==NULL)
+        goto k5clean;
+
+    debug((char *) "%s| %s: INFO: Read %d of %d bytes \n", LogTime(), PROGRAM, bpos, (int)ad_data->length);
+    if (Rids) {
+        for ( l=0; l<(int)GroupCount; l++) {
+            xfree(Rids[l]);
+        }
+        xfree(Rids);
+    }
+    krb5_free_data(context, ad_data);
+    return ad_groups;
+k5clean:
+    if (Rids) {
+        for ( l=0; l<(int)GroupCount; l++) {
+            xfree(Rids[l]);
+        }
+        xfree(Rids);
+    }
+    krb5_free_data(context, ad_data);
+    return NULL;
+}
+#endif
@@ -0,0 +1,7 @@
+#!/bin/bash
+if [[ -z "$1" ]]; then
+	echo "Need squid hostname"
+	exit 0
+fi
+dir=`dirname $0`
+$dir/negotiate_kerberos_auth_test $1 | awk '{sub(/Token:/,"YR"); print $0}END{print "QQ"}' | $dir/negotiate_kerberos_auth -d
@@ -46,9 +46,6 @@
 #if HAVE_TIME_H
 #include <time.h>
 #endif
-#if HAVE_SYS_TIME_H
-#include <sys/time.h>
-#endif
 #if HAVE_ERRNO_H
 #include <errno.h>
 #endif
@@ -26,7 +26,7 @@
 #ifndef _RFCNB_RFCNB_COMMON_H
 #define _RFCNB_RFCNB_COMMON_H
 
-#ifdef __cplusplus
+#if defined(__cplusplus)
 extern "C" {
 #endif
 
@@ -40,8 +40,7 @@ extern "C" {
 
     } RFCNB_Pkt;
 
-#ifdef __cplusplus
+#if defined(__cplusplus)
 }
-
 #endif
-#endif                          /* _RFCNB_RFCNB_COMMON_H */
+#endif /* _RFCNB_RFCNB_COMMON_H */
@@ -25,10 +25,10 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#include "rfcnb/std-includes.h"
+#include "rfcnb/rfcnb-io.h"
 #include "rfcnb/rfcnb-priv.h"
 #include "rfcnb/rfcnb-util.h"
-#include "rfcnb/rfcnb-io.h"
+#include "rfcnb/std-includes.h"
 #include <sys/uio.h>
 #include <sys/signal.h>
 
@@ -1,3 +1,6 @@
+#ifndef _SQUID__LIB_RFCNB_RFCNB_IO_H
+#define _SQUID__LIB_RFCNB_RFCNB_IO_H
+
 /* UNIX RFCNB (RFC1001/RFC1002) NetBIOS implementation
  *
  * Version 1.0
@@ -23,6 +26,10 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+#include "rfcnb/rfcnb.h"
+
 int RFCNB_Put_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len);
 
 int RFCNB_Get_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len);
+
+#endif
@@ -32,9 +32,13 @@ typedef unsigned short uint16;
 
 #define GLOBAL extern
 
-#include "rfcnb/rfcnb-error.h"
-#include "rfcnb/rfcnb-common.h"
 #include "rfcnb/byteorder.h"
+#include "rfcnb/rfcnb-common.h"
+#include "rfcnb/rfcnb-error.h"
+
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
 
 #ifdef RFCNB_PORT
 #define RFCNB_Default_Port RFCNB_PORT
@@ -25,11 +25,11 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
-#include "rfcnb/rfcnb.h"
-#include "rfcnb/std-includes.h"
+#include "rfcnb/rfcnb-io.h"
 #include "rfcnb/rfcnb-priv.h"
 #include "rfcnb/rfcnb-util.h"
-#include "rfcnb/rfcnb-io.h"
+#include "rfcnb/rfcnb.h"
+#include "rfcnb/std-includes.h"
 
 #if HAVE_ARPA_INET_H
 #include <arpa/inet.h>
@@ -1,3 +1,6 @@
+#ifndef _RFCNB_RFCNB_UTIL_H
+#define _RFCNB_RFCNB_UTIL_H
+
 /* UNIX RFCNB (RFC1001/RFC1002) NetBIOS implementation
  *
  * Version 1.0
@@ -23,6 +26,8 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+#include "rfcnb/std-includes.h"
+
 void RFCNB_CvtPad_Name(char *name1, char *name2);
 
 void RFCNB_AName_To_NBName(char *AName, char *NBName);
@@ -48,3 +53,5 @@ int RFCNB_Session_Req(struct RFCNB_Con *con,
 
 typedef void RFCNB_Prot_Print_Routine(FILE * fd, int dir, struct RFCNB_Pkt *pkt, int header, int payload);
 extern RFCNB_Prot_Print_Routine *Prot_Print_Routine;
+
+#endif /* _RFCNB_RFCNB_UTIL_H */
@@ -28,8 +28,8 @@
 
 /* Error responses */
 
-#include "rfcnb/rfcnb-error.h"
 #include "rfcnb/rfcnb-common.h"
+#include "rfcnb/rfcnb-error.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -31,10 +31,10 @@ int RFCNB_saved_errno = 0;
 
 #include "rfcnb/std-includes.h"
 #include <netinet/tcp.h>
-#include "rfcnb/rfcnb.h"
-#include "rfcnb/rfcnb-priv.h"
 #include "rfcnb/rfcnb-io.h"
+#include "rfcnb/rfcnb-priv.h"
 #include "rfcnb/rfcnb-util.h"
+#include "rfcnb/rfcnb.h"
 
 #if HAVE_STRING_H
 #include <string.h>
@@ -1266,7 +1266,6 @@ PREDEFINED             = __cplusplus \
                          USE_CLASSFUL \
                          USE_DELAY_POOLS \
                          USE_DLMALLOC \
-                         USE_DNSHELPER \
                          USE_EPOLL \
                          USE_GNUREGEX \
                          USE_HEXDUMP \
@@ -214,9 +214,11 @@ ConfigParser::UnQuote(const char *token, const char **next)
             errorStr = "Unsupported cfg macro";
             errorPos = s;
 #endif
+#if 0
         } else if (*s == '%' && quoteChar == '"' && (!AllowMacros_ )) {
             errorStr = "Macros are not supported here";
             errorPos = s;
+#endif
         } else
             *d = *s;
         ++s;
@@ -1123,6 +1123,7 @@ FwdState::connectStart()
             flags.connected_okay = true;
             ++n_tries;
             request->flags.pinned = true;
+            request->hier.note(serverConn, pinned_connection->pinning.host);
             if (pinned_connection->pinnedAuth())
                 request->flags.auth = true;
             comm_add_close_handler(serverConn->fd, fwdServerClosedWrapper, this);
@@ -228,7 +228,6 @@ HttpRequest::clone() const
     copy->vary_headers = vary_headers ? xstrdup(vary_headers) : NULL;
     // XXX: what to do with copy->peer_domain?
 
-    copy->myportname = myportname;
     copy->tag = tag;
     copy->extacl_log = extacl_log;
     copy->extacl_message = extacl_message;
@@ -273,6 +272,8 @@ HttpRequest::inheritProperties(const HttpMsg *aMsg)
     extacl_passwd = aReq->extacl_passwd;
 #endif
 
+    myportname = aReq->myportname;
+
     // main property is which connection the request was received on (if any)
     clientConnectionManager = aReq->clientConnectionManager;
 
@@ -8,15 +8,8 @@ include $(top_srcdir)/src/Common.am
 
 AUTOMAKE_OPTIONS = subdir-objects
 
-if ENABLE_DNSHELPER
-DNSSOURCE = dns.cc
-DNSHELPER = dnsserver
-else
-DNSSOURCE = dns_internal.cc
-DNSHELPER =
-endif
-
-DNSSOURCE += \
+DNSSOURCE = \
+	dns_internal.cc \
 	SquidDns.h \
 	DnsLookupDetails.h \
 	DnsLookupDetails.cc
@@ -197,10 +190,8 @@ noinst_LTLIBRARIES = libsquid.la
 EXTRA_PROGRAMS = \
 	DiskIO/DiskDaemon/diskd \
 	unlinkd \
-	dnsserver \
 	recv-announce \
 	tests/testUfs \
-	tests/testCoss \
 	tests/testRock \
 	ufsdump
 
@@ -217,7 +208,6 @@ bin_PROGRAMS =
 
 
 libexec_PROGRAMS = \
-	$(DNSHELPER) \
 	$(DISK_PROGRAMS) \
 	$(UNLINKD)
 
@@ -572,11 +562,6 @@ EXTRA_squid_SOURCES = \
 	$(all_AUTHMODULES) \
 	ConfigOption.h \
 	$(DELAY_POOL_ALL_SOURCE) \
-	dns.cc \
-	dnsserver.cc \
-	dns_internal.cc \
-	DnsLookupDetails.cc \
-	DnsLookupDetails.h \
 	htcp.cc \
 	htcp.h \
 	ipc.cc \
@@ -700,12 +685,6 @@ unlinkd_LDADD = \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 
-## dnsserver is a standalone helper. Do not link to any internal libraries
-dnsserver_SOURCES = dnsserver.cc
-dnsserver_LDADD = \
-	$(COMPAT_LIB) \
-	$(XTRA_LIBS)
-
 recv_announce_SOURCES = recv-announce.cc
 
 ## What requires what..
@@ -927,7 +906,6 @@ DEFAULT_PREFIX		= $(prefix)
 DEFAULT_CONFIG_DIR	= $(sysconfdir)
 DEFAULT_CONFIG_FILE	= $(DEFAULT_CONFIG_DIR)/squid.conf
 DEFAULT_MIME_TABLE	= $(DEFAULT_CONFIG_DIR)/mime.conf
-DEFAULT_DNSSERVER	= $(libexecdir)/`echo dnsserver | sed '$(transform);s/$$/$(EXEEXT)/'`
 DEFAULT_SSL_CRTD	= $(libexecdir)/`echo ssl_crtd  | sed '$(transform);s/$$/$(EXEEXT)/'`
 DEFAULT_LOG_PREFIX	= $(DEFAULT_LOG_DIR)
 DEFAULT_CACHE_LOG	= $(DEFAULT_LOG_PREFIX)/cache.log
@@ -1009,7 +987,6 @@ cf.data: cf.data.pre Makefile
 	-e "s%[@]DEFAULT_ICP_PORT[@]%$(DEFAULT_ICP_PORT)%g" \
 	-e "s%[@]DEFAULT_CACHE_EFFECTIVE_USER[@]%$(CACHE_EFFECTIVE_USER)%g" \
 	-e "s%[@]DEFAULT_MIME_TABLE[@]%$(DEFAULT_MIME_TABLE)%g" \
-	-e "s%[@]DEFAULT_DNSSERVER[@]%$(DEFAULT_DNSSERVER)%g" \
 	-e "s%[@]DEFAULT_SSL_CRTD[@]%$(DEFAULT_SSL_CRTD)%g" \
 	-e "s%[@]DEFAULT_UNLINKD[@]%$(DEFAULT_UNLINKD)%g" \
 	-e "s%[@]DEFAULT_PINGER[@]%$(DEFAULT_PINGER)%g" \
@@ -3417,170 +3394,6 @@ tests_testRock_LDFLAGS = $(INCLUDES) $(LIBADD_DL)
 tests_testRock_DEPENDENCIES = \
 	$(SWAP_TEST_DS)
 
-tests_testCoss_SOURCES = \
-	tests/testCoss.cc \
-	tests/testMain.cc \
-	tests/testCoss.h \
-	tests/stub_cache_manager.cc \
-	client_db.h \
-	tests/stub_client_db.cc \
-	tests/stub_debug.cc \
-	tests/stub_HelperChildConfig.cc \
-	internal.h \
-	tests/stub_internal.cc \
-	tests/stub_ipc.cc \
-	tests/stub_libeui.cc \
-	tests/stub_pconn.cc \
-	store_rebuild.h \
-	tests/stub_store_rebuild.cc \
-	tests/stub_store_stats.cc \
-	fatal.h \
-	tests/stub_fatal.cc \
-	fd.h \
-	fd.cc \
-	fde.h \
-	fde.cc \
-	disk.h \
-	disk.cc \
-	FileMap.h \
-	filemap.cc \
-	HttpBody.h \
-	HttpBody.cc \
-	HttpReply.cc \
-	int.h \
-	int.cc \
-	SquidList.h \
-	SquidList.cc \
-	MemObject.cc \
-	StoreSwapLogData.cc \
-	StoreIOState.cc \
-	StoreMeta.cc \
-	StoreMetaMD5.cc \
-	StoreMetaSTD.cc \
-	StoreMetaSTDLFS.cc \
-	StoreMetaUnpacker.cc \
-	StoreMetaURL.cc \
-	StoreMetaVary.cc \
-	StoreFileSystem.cc \
-	store_io.cc \
-	store_swapout.cc \
-	store_swapmeta.cc \
-	$(UNLINKDSOURCE) \
-	$(WIN32_SOURCE) \
-	event.cc \
-	$(DELAY_POOL_SOURCE) \
-	CacheDigest.h \
-	CacheDigest.cc \
-	ConfigParser.cc \
-	EventLoop.cc \
-	HttpMsg.cc \
-	RemovalPolicy.cc \
-	store_dir.cc \
-	repl_modules.h \
-	store.cc \
-	HttpRequestMethod.cc \
-	store_key_md5.h \
-	store_key_md5.cc \
-	Parsing.cc \
-	ConfigOption.cc \
-	SwapDir.cc \
-	tests/stub_acl.cc \
-	cache_cf.h \
-	YesNoNone.h \
-	tests/stub_cache_cf.cc \
-	tests/stub_helper.cc \
-	cbdata.cc \
-	String.cc \
-	tests/stub_client_side_request.cc \
-	tests/stub_http.cc \
-	mem_node.cc \
-	stmem.cc \
-	mime.h \
-	tests/stub_mime.cc \
-	HttpHeaderFieldInfo.h \
-	HttpHeaderTools.h \
-	HttpHeaderTools.cc \
-	HttpHeader.h \
-	HttpHeader.cc \
-	Mem.h \
-	mem.cc \
-	ClientInfo.h \
-	MemBuf.cc \
-	HttpHdrContRange.cc \
-	Packer.cc \
-	HttpHeaderFieldStat.h \
-	HttpHdrCc.h \
-	HttpHdrCc.cc \
-	HttpHdrCc.cci \
-	HttpHdrSc.cc \
-	HttpHdrScTarget.cc \
-	url.cc \
-	StatCounters.h \
-	StatCounters.cc \
-	StatHist.h \
-	tests/stub_StatHist.cc \
-	tests/stub_errorpage.cc \
-	tests/stub_HttpRequest.cc \
-	log/access_log.h \
-	tests/stub_access_log.cc \
-	refresh.h \
-	refresh.cc \
-	tests/stub_MemStore.cc \
-	tests/stub_Port.cc \
-	tests/stub_store_client.cc \
-	tests/stub_store_stats.cc \
-	tools.h \
-	tests/stub_tools.cc \
-	tests/stub_UdsOp.cc \
-	tests/testStoreSupport.cc \
-	tests/testStoreSupport.h \
-	time.cc \
-	URLScheme.cc \
-	wordlist.h \
-	wordlist.cc \
-	$(DISKIO_SOURCE)
-
-nodist_tests_testCoss_SOURCES = \
-	swap_log_op.cc \
-	SquidMath.cc \
-	SquidMath.h \
-	$(TESTSOURCES) \
-	$(DISKIO_GEN_SOURCE)
-tests_testCoss_LDADD = \
-	anyp/libanyp.la \
-	libsquid.la \
-	$(REGEXLIB) \
-	$(AUTH_ACL_LIBS) \
-	ident/libident.la \
-	acl/libacls.la \
-	acl/libstate.la \
-	$(AUTH_LIBS) \
-	acl/libapi.la \
-	libsquid.la \
-	comm/libcomm.la \
-	ip/libip.la \
-	fs/libfs.la \
-	mgr/libmgr.la \
-	$(REPL_OBJS) \
-	$(DISK_LIBS) \
-	$(DISK_OS_LIBS) \
-	$(COMMON_LIBS) \
-	$(SSL_LIBS) \
-	acl/libapi.la \
-	ipc/libipc.la \
-	base/libbase.la \
-	$(top_builddir)/lib/libmisccontainers.la \
-	$(top_builddir)/lib/libmiscencoding.la \
-	$(top_builddir)/lib/libmiscutil.la \
-	$(SQUID_CPPUNIT_LIBS) \
-	$(REGEXLIB) \
-	$(SSLLIB) \
-	$(COMPAT_LIB) \
-	$(XTRA_LIBS)
-tests_testCoss_LDFLAGS = $(LIBADD_DL)
-tests_testCoss_DEPENDENCIES = \
-	$(SWAP_TEST_DS)
-
 ## Tests of the URL module.
 ## TODO: Trim this down once the insanity is over.
 tests_testURL_SOURCES = \
@@ -111,12 +111,8 @@ class SquidConfig
         int icp_query_max;  /* msec */
         int icp_query_min;  /* msec */
         int mcast_icp_query;    /* msec */
-
-#if !USE_DNSHELPER
         time_msec_t idns_retransmit;
         time_msec_t idns_query;
-#endif
-
     } Timeout;
     size_t maxRequestHeaderSize;
     int64_t maxRequestBodySize;
@@ -195,10 +191,6 @@ class SquidConfig
     char *effectiveGroup;
 
     struct {
-#if USE_DNSHELPER
-        char *dnsserver;
-#endif
-
         wordlist *redirect;
         wordlist *store_id;
 #if USE_UNLINKD
@@ -213,9 +205,6 @@ class SquidConfig
 #endif
 
     } Program;
-#if USE_DNSHELPER
-    HelperChildConfig dnsChildren;
-#endif
 
     HelperChildConfig redirectChildren;
     HelperChildConfig storeIdChildren;
@@ -1,10 +1,6 @@
 #ifndef SQUID_DNS_H
 #define SQUID_DNS_H
 
-#if USE_DNSHELPER
-#include "helper.h"
-#endif
-
 namespace Ip
 {
 class Address;
@@ -14,13 +10,8 @@ class Address;
 void dnsInit(void);
 void dnsShutdown(void);
 
-#if USE_DNSHELPER
-// external DNS helper API
-void dnsSubmit(const char *lookup, HLPCB * callback, void *data);
-#else
 // internal DNS client API
 void idnsALookup(const char *, IDNSCB *, void *);
 void idnsPTRLookup(const Ip::Address &, IDNSCB *, void *);
-#endif
 
 #endif /* SQUID_DNS_H */
@@ -70,7 +70,7 @@
  * configure will take a list of storage types through the
  * --enable-store-io parameter. This parameter takes a list of
  * space seperated storage types. For example,
- * --enable-store-io="ufs coss" .
+ * --enable-store-io="ufs aufs" .
  *
  \par
  * Each storage type must create an archive file
@@ -99,7 +99,7 @@ operator <<(std::ostream &os, const SwapChecksum24 &sum)
  *
  \par
  * Defines the structure of a binary swap.state file entry for UFS stores.
- * TODO: Move to fs/ufs (and remove from COSS).
+ * TODO: Move to fs/ufs
  *
  \note StoreSwapLogData entries are written in native machine byte order
  *     They are not necessarily portable across architectures.
@@ -197,9 +197,7 @@ static void parseBytesLine(size_t * bptr, const char *units);
 #if USE_SSL
 static void parseBytesOptionValue(size_t * bptr, const char *units, char const * value);
 #endif
-#if !USE_DNSHELPER
 static void parseBytesLineSigned(ssize_t * bptr, const char *units);
-#endif
 static size_t parseBytesUnits(const char *unit);
 static void free_all(void);
 void requirePathnameExists(const char *name, const char *path);
@@ -691,11 +689,6 @@ configDoConfigure(void)
     else
         visible_appname_string = (char const *)APP_FULLNAME;
 
-#if USE_DNSHELPER
-    if (Config.dnsChildren.n_max < 1)
-        fatal("No DNS helpers allocated");
-#endif
-
     if (Config.Program.redirect) {
         if (Config.redirectChildren.n_max < 1) {
             Config.redirectChildren.n_max = 0;
@@ -761,9 +754,6 @@ configDoConfigure(void)
     }
 
     requirePathnameExists("MIME Config Table", Config.mimeTablePathname);
-#if USE_DNSHELPER
-    requirePathnameExists("cache_dns_program", Config.Program.dnsserver);
-#endif
 #if USE_UNLINKD
 
     requirePathnameExists("unlinkd_program", Config.Program.unlinkd);
@@ -1185,7 +1175,6 @@ parseBytesLine(size_t * bptr, const char *units)
     }
 }
 
-#if !USE_DNSHELPER
 static void
 parseBytesLineSigned(ssize_t * bptr, const char *units)
 {
@@ -1232,7 +1221,6 @@ parseBytesLineSigned(ssize_t * bptr, const char *units)
         self_destruct();
     }
 }
-#endif
 
 /**
  * Parse bytes from a string.
@@ -3064,7 +3052,6 @@ free_time_t(time_t * var)
     *var = 0;
 }
 
-#if !USE_DNSHELPER
 static void
 dump_time_msec(StoreEntry * entry, const char *name, time_msec_t var)
 {
@@ -3085,7 +3072,6 @@ free_time_msec(time_msec_t * var)
 {
     *var = 0;
 }
-#endif
 
 #if UNUSED_CODE
 static void
@@ -3101,13 +3087,11 @@ dump_b_size_t(StoreEntry * entry, const char *name, size_t var)
     storeAppendPrintf(entry, "%s %d %s\n", name, (int) var, B_BYTES_STR);
 }
 
-#if !USE_DNSHELPER
 static void
 dump_b_ssize_t(StoreEntry * entry, const char *name, ssize_t var)
 {
     storeAppendPrintf(entry, "%s %d %s\n", name, (int) var, B_BYTES_STR);
 }
-#endif
 
 #if UNUSED_CODE
 static void
@@ -3145,13 +3129,11 @@ parse_b_size_t(size_t * var)
     parseBytesLine(var, B_BYTES_STR);
 }
 
-#if !USE_DNSHELPER
 static void
 parse_b_ssize_t(ssize_t * var)
 {
     parseBytesLineSigned(var, B_BYTES_STR);
 }
-#endif
 
 #if UNUSED_CODE
 static void
@@ -3179,13 +3161,11 @@ free_size_t(size_t * var)
     *var = 0;
 }
 
-#if !USE_DNSHELPER
 static void
 free_ssize_t(ssize_t * var)
 {
     *var = 0;
 }
-#endif
 
 static void
 free_b_int64_t(int64_t * var)
@@ -224,14 +224,12 @@
 
 /**
  *\ingroup CBDATAAPI
- * cbdata types. similar to the MEM_* types above, but managed
- * in cbdata.c. A big difference is that these types are dynamically
- * allocated. This list is only a list of predefined types. Other types
- * are added runtime
+ * cbdata types. Similar to the MEM_* types, but managed in cbdata.cc
+ * A big difference is that cbdata types are dynamically allocated.
+ * Initially only UNKNOWN type is predefined. Other types are added runtime.
  */
-typedef enum {
-    CBDATA_UNKNOWN = 0
-} cbdata_type;
+typedef int cbdata_type;
+static const cbdata_type CBDATA_UNKNOWN = 0;
 
 /// \ingroup CBDATAAPI
 void cbdataRegisterWithCacheManager(void);
@@ -3451,25 +3451,6 @@ DOC_START
 	enforcement. Currently supported by IpcIo module only.
 
 
-	====  The coss store type  ====
-
-	NP: COSS filesystem in Squid-3 has been deemed too unstable for
-	    production use and has thus been removed from this release.
-	    We hope that it can be made usable again soon.
-
-	block-size=n defines the "block size" for COSS cache_dir's.
-	Squid uses file numbers as block numbers.  Since file numbers
-	are limited to 24 bits, the block size determines the maximum
-	size of the COSS partition.  The default is 512 bytes, which
-	leads to a maximum cache_dir size of 512<<24, or 8 GB.  Note
-	you should not change the coss block size after Squid
-	has written some objects to the cache_dir.
-
-	The coss file store has changed from 2.5. Now it uses a file
-	called 'stripe' in the directory names in the config - and
-	this will be created by squid -z.
-
-
 	==== COMMON OPTIONS ====
 
 	no-store	no new objects should be stored to this cache_dir.
@@ -3478,7 +3459,7 @@ DOC_START
 			will accept.  It's used to restrict a cache_dir
 			to only store large objects (e.g. AUFS) while
 			other stores are optimized for smaller objects
-			(e.g. COSS).
+			(e.g. Rock).
 			Defaults to 0.
 
 	max-size=n	the maximum object size in bytes this cache_dir
@@ -3490,10 +3471,6 @@ DOC_START
 	Note: To make optimal use of the max-size limits you should order
 	the cache_dir lines with the smallest max-size value first.
 
-	Note for coss, max-size must be less than COSS_MEMBUF_SZ,
-	which can be changed with the --with-coss-membuf-size=N configure
-	option.
-
 NOCOMMENT_START
 
 # Uncomment and adjust the following to add a disk cache directory.
@@ -8228,52 +8205,10 @@ DOC_START
 	This check is performed only when check_hostnames is set to on.
 DOC_END
 
-NAME: cache_dns_program
-TYPE: string
-IFDEF: USE_DNSHELPER
-DEFAULT: @DEFAULT_DNSSERVER@
-LOC: Config.Program.dnsserver
-DOC_START
-	Specify the location of the executable for dnslookup process.
-DOC_END
-
-NAME: dns_children
-TYPE: HelperChildConfig
-IFDEF: USE_DNSHELPER
-DEFAULT: 32 startup=1 idle=1
-LOC: Config.dnsChildren
-DOC_START
-	The maximum number of processes spawn to service DNS name lookups.
-	If you limit it too few Squid will have to wait for them to process
-	a backlog of requests, slowing it down. If you allow too many they
-	will use RAM and other system resources noticably.
-	The maximum this may be safely set to is 32.
-	
-	The startup= and idle= options allow some measure of skew in your
-	tuning.
-	
-		startup=
-	
-	Sets a minimum of how many processes are to be spawned when Squid
-	starts or reconfigures. When set to zero the first request will
-	cause spawning of the first child process to handle it.
-	
-	Starting too few will cause an initial slowdown in traffic as Squid
-	attempts to simultaneously spawn enough processes to cope.
-	
-		idle=
-	
-	Sets a minimum of how many processes Squid is to try and keep available
-	at all times. When traffic begins to rise above what the existing
-	processes can handle this many more will be spawned up to the maximum
-	configured. A minimum setting of 1 is required.
-DOC_END
-
 NAME: dns_retransmit_interval
 TYPE: time_msec
 DEFAULT: 5 seconds
 LOC: Config.Timeout.idns_retransmit
-IFDEF: !USE_DNSHELPER
 DOC_START
 	Initial retransmit interval for DNS queries. The interval is
 	doubled each time all configured DNS servers have been tried.
@@ -8283,7 +8218,6 @@ NAME: dns_timeout
 TYPE: time_msec
 DEFAULT: 30 seconds
 LOC: Config.Timeout.idns_query
-IFDEF: !USE_DNSHELPER
 DOC_START
 	DNS Query timeout. If no response is received to a DNS query
 	within this time all DNS servers for the queried domain
@@ -8295,7 +8229,6 @@ TYPE: b_ssize_t
 DEFAULT_DOC: EDNS disabled
 DEFAULT: none
 LOC: Config.dns.packet_max
-IFDEF: !USE_DNSHELPER
 DOC_START
 	Maximum number of bytes packet size to advertise via EDNS.
 	Set to "none" to disable EDNS large packet support.
@@ -8413,7 +8346,6 @@ NAME: ignore_unknown_nameservers
 TYPE: onoff
 LOC: Config.onoff.ignore_unknown_nameservers
 DEFAULT: on
-IFDEF: !USE_DNSHELPER
 DOC_START
 	By default Squid checks that DNS responses are received
 	from the same IP addresses they are sent to.  If they
@@ -8426,7 +8358,6 @@ NAME: dns_v4_first
 TYPE: onoff
 DEFAULT: off
 LOC: Config.dns.v4_first
-IFDEF: !USE_DNSHELPER
 DOC_START
 	With the IPv6 Internet being as fast or faster than IPv4 Internet
 	for most networks Squid prefers to contact websites over IPv6.
@@ -16,8 +16,6 @@ BEGIN {
 	define["USE_ADAPTATION"]="--enable-ecap or --enable-icap-client"
 	define["USE_AUTH"]="--enable-auth"
 	define["USE_CACHE_DIGESTS"]="--enable-cache-digests"
-	define["USE_DNSHELPER"]="--disable-internal-dns"
-	define["!USE_DNSHELPER"]="--enable-internal-dns"
 	define["USE_ECAP"]="--enable-ecap"
 	define["USE_ERR_LOCALES"]="--enable-auto-locale"
 	define["USE_HTCP"]="--enable-htcp"
@@ -3938,8 +3938,18 @@ ConnStateData::getSslContextDone(SSL_CTX * sslContext, bool isNew)
     // Try to add generated ssl context to storage.
     if (port->generateHostCertificates && isNew) {
 
-        if (signAlgorithm == Ssl::algSignTrusted)
+        if (signAlgorithm == Ssl::algSignTrusted) {
+            // Add signing certificate to the certificates chain
+            X509 *cert = port->signingCert.get();
+            if (SSL_CTX_add_extra_chain_cert(sslContext, cert)) {
+                // increase the certificate lock
+                CRYPTO_add(&(cert->references),1,CRYPTO_LOCK_X509);
+            } else {
+                const int ssl_error = ERR_get_error();
+                debugs(33, DBG_IMPORTANT, "WARNING: can not add signing certificate to SSL context chain: " << ERR_error_string(ssl_error, NULL));
+            }
             Ssl::addChainToSslContext(sslContext, port->certsToChain.get());
+        }
         //else it is self-signed or untrusted do not attrach any certificate
 
         Ssl::LocalContextStorage & ssl_ctx_cache(Ssl::TheGlobalContextStorage.getLocalStorage(port->s));
@@ -1569,23 +1569,8 @@ clientReplyContext::identifyFoundObject(StoreEntry *newEntry)
     /** \li If the request has no-cache flag set or some no_cache HACK in operation we
       * 'invalidate' the cached IP entries for this request ???
       */
-    if (r->flags.noCache) {
-
-#if USE_DNSHELPER
-        ipcacheInvalidate(r->GetHost());
-#else
+    if (r->flags.noCache || r->flags.noCacheHack())
         ipcacheInvalidateNegative(r->GetHost());
-#endif /* USE_DNSHELPER */
-
-    } else if (r->flags.noCacheHack()) {
-
-#if USE_DNSHELPER
-        ipcacheInvalidate(r->GetHost());
-#else
-        ipcacheInvalidateNegative(r->GetHost());
-#endif /* USE_DNSHELPER */
-
-    }
 
 #if USE_CACHE_DIGESTS
     lookup_type = http->storeEntry() ? "HIT" : "MISS";
@@ -1521,7 +1521,7 @@ ClientHttpRequest::processRequest()
 #endif
         logType = LOG_TCP_MISS;
         getConn()->stopReading(); // tunnels read for themselves
-        tunnelStart(this, &out.size, &al->http.code);
+        tunnelStart(this, &out.size, &al->http.code, al);
         return;
     }
 
@@ -202,7 +202,7 @@ int clientHttpRequestStatus(int fd, ClientHttpRequest const *http);
 void clientAccessCheck(ClientHttpRequest *);
 
 /* ones that should be elsewhere */
-void tunnelStart(ClientHttpRequest *, int64_t *, int *);
+void tunnelStart(ClientHttpRequest *, int64_t *, int *, const AccessLogEntry::Pointer &al);
 
 #if _USE_INLINE_
 #include "Store.h"
@@ -1,194 +0,0 @@
-
-/*
- * DEBUG: section 34    Dnsserver interface
- * AUTHOR: Harvest Derived
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- */
-
-#include "squid.h"
-#include "helper.h"
-#include "HelperReply.h"
-#include "mgr/Registration.h"
-#include "SquidConfig.h"
-#include "SquidTime.h"
-#include "Store.h"
-#include "wordlist.h"
-
-#if SQUID_SNMP
-#include "snmp_core.h"
-#endif
-
-/* MS VisualStudio Projects are monolitich, so we need the following
-   #if to include the external DNS code in compile process when
-   using external DNS.
- */
-#if USE_DNSHELPER
-
-static helper *dnsservers = NULL;
-
-static void
-dnsStats(StoreEntry * sentry)
-{
-    storeAppendPrintf(sentry, "Dnsserver Statistics:\n");
-    helperStats(sentry, dnsservers);
-}
-
-static void
-dnsRegisterWithCacheManager(void)
-{
-    Mgr::RegisterAction("dns", "Dnsserver Statistics", dnsStats, 0, 1);
-}
-
-void
-dnsInit(void)
-{
-    wordlist *w;
-
-    dnsRegisterWithCacheManager();
-
-    if (!Config.Program.dnsserver)
-        return;
-
-    if (dnsservers == NULL)
-        dnsservers = new helper("dnsserver");
-
-    dnsservers->childs.updateLimits(Config.dnsChildren);
-
-    dnsservers->ipc_type = IPC_STREAM;
-
-    assert(dnsservers->cmdline == NULL);
-
-    wordlistAdd(&dnsservers->cmdline, Config.Program.dnsserver);
-
-    if (Config.onoff.res_defnames)
-        wordlistAdd(&dnsservers->cmdline, "-D");
-
-    for (w = Config.dns_nameservers; w != NULL; w = w->next) {
-        wordlistAdd(&dnsservers->cmdline, "-s");
-        wordlistAdd(&dnsservers->cmdline, w->key);
-    }
-
-    helperOpenServers(dnsservers);
-}
-
-void
-dnsShutdown(void)
-{
-    if (!dnsservers)
-        return;
-
-    helperShutdown(dnsservers);
-
-    wordlistDestroy(&dnsservers->cmdline);
-
-    if (!shutting_down)
-        return;
-
-    delete dnsservers;
-    dnsservers = NULL;
-}
-
-void
-dnsSubmit(const char *lookup, HLPCB * callback, void *data)
-{
-    char buf[256];
-    static time_t first_warn = 0;
-    snprintf(buf, 256, "%s\n", lookup);
-
-    if (dnsservers->stats.queue_size >= (int)dnsservers->childs.n_active && dnsservers->childs.needNew() > 0) {
-        helperOpenServers(dnsservers);
-    }
-
-    if (dnsservers->stats.queue_size >= (int)(dnsservers->childs.n_running * 2)) {
-        if (first_warn == 0)
-            first_warn = squid_curtime;
-
-        if (squid_curtime - first_warn > 3 * 60)
-            fatal("DNS servers not responding for 3 minutes");
-
-        debugs(34, DBG_IMPORTANT, "dnsSubmit: queue overload, rejecting " << lookup);
-
-        const char *t = "$fail Temporary network problem, please retry later";
-        HelperReply failReply;
-        /* XXX: upgrade the ipcache and fqdn cache handlers to new syntax
-        failReply.result= HelperReply::BrokenHelper;
-        failReply.notes.add("message","Temporary network problem, please retry later");
-        failReply.notes.add("message","DNS lookup queue overloaded");
-        */
-        failReply.modifiableOther().append(t, strlen(t));
-        callback(data, failReply);
-        return;
-    }
-
-    first_warn = 0;
-    helperSubmit(dnsservers, buf, callback, data);
-}
-
-#if SQUID_SNMP
-/*
- * The function to return the DNS via SNMP
- */
-variable_list *
-snmp_netDnsFn(variable_list * Var, snint * ErrP)
-{
-    variable_list *Answer = NULL;
-    MemBuf tmp;
-    debugs(49, 5, "snmp_netDnsFn: Processing request: " << Var->name[LEN_SQ_NET + 1] << " " << snmpDebugOid(Var->name, Var->name_length, tmp));
-    *ErrP = SNMP_ERR_NOERROR;
-
-    switch (Var->name[LEN_SQ_NET + 1]) {
-
-    case DNS_REQ:
-        Answer = snmp_var_new_integer(Var->name, Var->name_length,
-                                      dnsservers->stats.requests,
-                                      SMI_COUNTER32);
-        break;
-
-    case DNS_REP:
-        Answer = snmp_var_new_integer(Var->name, Var->name_length,
-                                      dnsservers->stats.replies,
-                                      SMI_COUNTER32);
-        break;
-
-    case DNS_SERVERS:
-        Answer = snmp_var_new_integer(Var->name, Var->name_length,
-                                      dnsservers->childs.n_running,
-                                      SMI_COUNTER32);
-        break;
-
-    default:
-        *ErrP = SNMP_ERR_NOSUCHNAME;
-        break;
-    }
-
-    return Answer;
-}
-
-#endif /* SQUID_SNMP */
-#endif /* USE_DNSHELPER */
@@ -37,6 +37,7 @@
 #include "comm.h"
 #include "comm/Loops.h"
 #include "comm/Write.h"
+#include "dlink.h"
 #include "event.h"
 #include "fd.h"
 #include "fde.h"
@@ -66,11 +67,6 @@
 #include <errno.h>
 #endif
 
-/* MS Visual Studio Projects are monolithic, so we need the following
-   #ifndef to exclude the internal DNS code from compile process when
-   using external DNS process.
- */
-#if !USE_DNSHELPER
 #if _SQUID_WINDOWS_
 #define REG_TCPIP_PARA_INTERFACES "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces"
 #define REG_TCPIP_PARA "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters"
@@ -1612,6 +1608,8 @@ dnsInit(void)
 #endif
 
         debugs(78, DBG_IMPORTANT, "or use the 'dns_nameservers' option in squid.conf.");
+        if (Ip::EnableIpv6)
+            idnsAddNameserver("::1");
         idnsAddNameserver("127.0.0.1");
     }
 
@@ -1882,4 +1880,3 @@ snmp_netDnsFn(variable_list * Var, snint * ErrP)
 }
 
 #endif /*SQUID_SNMP */
-#endif /* USE_DNSHELPER */
@@ -1,537 +0,0 @@
-/*
- * DEBUG: section 00    DNS Resolver Daemon
- * AUTHOR: Harvest Derived
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- */
-
-#include "squid.h"
-
-#if HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-#if HAVE_STDIO_H
-#include <stdio.h>
-#endif
-#if HAVE_CTYPE_H
-#include <ctype.h>
-#endif
-#if HAVE_ERRNO_H
-#include <errno.h>
-#endif
-#if HAVE_FCNTL_H
-#include <fcntl.h>
-#endif
-#if HAVE_GRP_H
-#include <grp.h>
-#endif
-#if HAVE_GNUMALLOC_H
-#include <gnumalloc.h>
-#elif HAVE_MALLOC_H
-#include <malloc.h>
-#endif
-#if HAVE_MEMORY_H
-#include <memory.h>
-#endif
-#if HAVE_NETDB_H
-#include <netdb.h>
-#endif
-#if HAVE_PWD_H
-#include <pwd.h>
-#endif
-#if HAVE_SIGNAL_H
-#include <signal.h>
-#endif
-#if HAVE_TIME_H
-#include <time.h>
-#endif
-#if HAVE_SYS_PARAM_H
-#include <sys/param.h>
-#endif
-#if HAVE_SYS_SOCKET_H
-#include <sys/socket.h>
-#endif
-#if HAVE_NETINET_IN_H
-#include <netinet/in.h>
-#endif
-#if HAVE_ARPA_INET_H
-#include <arpa/inet.h>
-#endif
-#if HAVE_SYS_STAT_H
-#include <sys/stat.h>
-#endif
-#if HAVE_SYS_UN_H
-#include <sys/un.h>
-#endif
-#if HAVE_SYS_WAIT_H
-#include <sys/wait.h>
-#endif
-#if HAVE_LIBC_H
-#include <libc.h>
-#endif
-#if HAVE_SYS_SYSCALL_H
-#include <sys/syscall.h>
-#endif
-#if HAVE_STRING_H
-#include <string.h>
-#endif
-#if HAVE_STRINGS_H
-#include <strings.h>
-#endif
-#if HAVE_BSTRING_H
-#include <bstring.h>
-#endif
-#if HAVE_CRYPT_H
-#include <crypt.h>
-#endif
-#if HAVE_GETOPT_H
-#include <getopt.h>
-#endif
-
-#if HAVE_ARPA_NAMESER_H
-#include <arpa/nameser.h>
-#endif
-#if HAVE_RESOLV_H
-#include <resolv.h>
-#endif
-
-/**
- \defgroup dnsserver dnsserver
- \ingroup ExternalPrograms
- \par
-    Because the standard gethostbyname() library call
-    blocks, Squid must use external processes to actually make
-    these calls.  Typically there will be ten dnsserver
-    processes spawned from Squid.  Communication occurs via
-    TCP sockets bound to the loopback interface.  The functions
-    in dns.cc are primarily concerned with starting and
-    stopping the dnsservers.  Reading and writing to and from
-    the dnsservers occurs in the \link IPCacheAPI IP\endlink and
-    \link FQDNCacheAPI FQDN\endlink cache modules.
-
- \section dnsserverInterface Command Line Interface
- \verbatim
-usage: dnsserver -Dhv -s nameserver
-	-D             Enable resolver RES_DEFNAMES and RES_DNSRCH options
-	-h             Help
-	-v             Version
-	-s nameserver  Specify alternate name server(s).  'nameserver'
-	               must be an IP address, -s option may be repeated
- \endverbatim
- */
-
-#if LIBRESOLV_DNS_TTL_HACK
-/// \ingroup dnsserver
-extern int _dns_ttl_;		/* this is a really *dirty* hack - bne */
-#endif
-
-/*
- * res_init() is a macro re-definition of __res_init on: Debian
- */
-#if !defined(HAVE_RES_INIT) && defined(HAVE___RES_INIT)
-#ifndef res_init
-#define res_init  __res_init
-#endif
-#define HAVE_RES_INIT   HAVE___RES_INIT
-#endif
-
-/// \ingroup dnsserver
-#define REQ_SZ 512
-
-/**
- \ingroup dnsserver
- */
-static void
-lookup(const char *buf)
-{
-    int ttl = 0;
-    int retry = 0;
-    unsigned int i = 0;
-    char ntoabuf[256];
-    struct addrinfo hints;
-    struct addrinfo *AI = NULL;
-    struct addrinfo *aiptr = NULL;
-    struct addrinfo *prev_addr = NULL;
-    int res = 0;
-
-    if (0 == strcmp(buf, "$shutdown"))
-        exit(0);
-
-    if (0 == strcmp(buf, "$hello")) {
-        printf("$alive\n");
-        return;
-    }
-
-    /* check if it's already an IP address in text form. */
-    memset(&hints, '\0', sizeof(struct addrinfo));
-    hints.ai_family = AF_UNSPEC;
-    hints.ai_flags = AI_NUMERICHOST; // only succeed if its numeric.
-    const bool isDomain = (getaddrinfo(buf,NULL,&hints,&AI) != 0);
-
-    // reset for real lookup
-    if (AI != NULL) {
-        freeaddrinfo(AI);
-        AI = NULL;
-    }
-
-    // resolve the address/name
-    memset(&hints, '\0', sizeof(struct addrinfo));
-    hints.ai_family = AF_UNSPEC;
-    hints.ai_flags = AI_CANONNAME;
-    for (;;) {
-        if (AI != NULL) {
-            freeaddrinfo(AI);
-            AI = NULL;
-        }
-
-        if ( 0 == (res = getaddrinfo(buf,NULL,&hints,&AI)) )
-            break;
-
-        if (res != EAI_AGAIN)
-            break;
-
-        if (++retry == 3)
-            break;
-
-        sleep(1);
-    }
-
-    if (isDomain) {
-        /* its a domain name. Use the forward-DNS lookup already done */
-
-        if (res == 0) {
-#if LIBRESOLV_DNS_TTL_HACK
-            /* DNS TTL handling - bne@CareNet.hu
-             * for first try it's a dirty hack, by hacking getanswer
-             * to place the ttl in a global variable */
-            if (_dns_ttl_ > -1)
-                ttl = _dns_ttl_;
-#endif
-            printf("$addr %d", ttl);
-
-            i = 0;
-            aiptr = AI;
-            while (NULL != aiptr && 32 >= i) {
-                memset(ntoabuf, 0, sizeof(ntoabuf));
-
-                /* getaddrinfo given a host has a nasty tendency to return duplicate addr's */
-                /* BUT sorted fortunately, so we can drop most of them easily */
-                if ( prev_addr &&
-                        prev_addr->ai_family==aiptr->ai_family &&
-                        memcmp(aiptr->ai_addr, prev_addr->ai_addr, aiptr->ai_addrlen)==0
-                   ) {
-                    prev_addr = aiptr;
-                    aiptr = aiptr->ai_next;
-                    continue;
-                } else {
-                    prev_addr = aiptr;
-                }
-
-                /* annoying inet_ntop breaks the nice code by requiring the in*_addr */
-                switch (aiptr->ai_family) {
-                case AF_INET:
-                    inet_ntop(aiptr->ai_family, &((struct sockaddr_in*)aiptr->ai_addr)->sin_addr, ntoabuf, sizeof(ntoabuf));
-                    break;
-                case AF_INET6:
-                    inet_ntop(aiptr->ai_family, &((struct sockaddr_in6*)aiptr->ai_addr)->sin6_addr, ntoabuf, sizeof(ntoabuf));
-                    break;
-                default:
-                    aiptr = aiptr->ai_next;
-                    continue;
-                }
-                printf(" %s", ntoabuf);
-                ++i;
-                aiptr = aiptr->ai_next;
-            }
-
-            prev_addr=NULL;
-            printf("\n");
-        }
-    } else { /* its an IPA in text form. perform rDNS */
-        /* You'd expect getaddrinfo given AI_CANONNAME would do a lookup on
-         * missing FQDN. But no, it only copies the input string to that
-         * position regardless of its content.
-         */
-        if (NULL != AI && NULL != AI->ai_addr) {
-            for (;;) {
-                if ( 0 == (res = getnameinfo(AI->ai_addr, AI->ai_addrlen, ntoabuf, sizeof(ntoabuf), NULL,0,0)) )
-                    break;
-
-                if (res != EAI_AGAIN)
-                    break;
-
-                if (++retry == 3)
-                    break;
-
-                sleep(1);
-            }
-        }
-
-        if (res == 0) {
-#if LIBRESOLV_DNS_TTL_HACK
-            /* DNS TTL handling - bne@CareNet.hu
-             * for first try it's a dirty hack, by hacking getanswer
-             * to place the ttl in a global variable */
-            if (_dns_ttl_ > -1)
-                ttl = _dns_ttl_;
-#endif
-
-            printf("$name %d %s\n", ttl, ntoabuf);
-        }
-    }
-
-    switch (res) {
-    case 0:
-        /* no error. */
-        break;
-
-    case EAI_AGAIN:
-        printf("$fail Name Server for domain '%s' is unavailable.\n", buf);
-        break;
-
-    case EAI_FAIL:
-        printf("$fail DNS Domain/IP '%s' does not exist: %s.\n", buf, gai_strerror(res));
-        break;
-
-#if defined(EAI_NODATA) || defined(EAI_NONAME)
-#if EAI_NODATA
-        /* deprecated. obsolete on some OS */
-    case EAI_NODATA:
-#endif
-#if EAI_NONAME
-    case EAI_NONAME:
-#endif
-        printf("$fail DNS Domain/IP '%s' exists without any FQDN/IPs: %s.\n", buf, gai_strerror(res));
-        break;
-#endif
-    default:
-        printf("$fail A system error occured looking up Domain/IP '%s': %s.\n", buf, gai_strerror(res));
-    }
-
-    if (AI != NULL)
-        freeaddrinfo(AI);
-}
-
-/**
- \ingroup dnsserver
- */
-static void
-usage(void)
-{
-    fprintf(stderr, "usage: dnsserver -hv -s nameserver\n"
-            "\t-h             Help\n"
-            "\t-v             Version\n"
-            "\t-s nameserver  Specify alternate name server(s).  'nameserver'\n"
-            "\t               must be an IPv4 address, -s option may be repeated\n"
-           );
-}
-
-#if defined(_SQUID_RES_NSADDR6_LARRAY)
-/// \ingroup dnsserver
-#define _SQUID_RES_NSADDR6_LIST(i)	_SQUID_RES_NSADDR6_LARRAY[i].sin6_addr
-#endif
-#if defined(_SQUID_RES_NSADDR6_LPTR)
-/// \ingroup dnsserver
-#define _SQUID_RES_NSADDR6_LIST(i)	_SQUID_RES_NSADDR6_LPTR[i]->sin6_addr
-#endif
-
-/**
- * \ingroup dnsserver
- *
- * Override the system DNS nameservers with some local ones.
- * Equivalent to the bind res_setservers() call but for any
- * system where we can find the needed _res fields.
- */
-void
-squid_res_setservers(int reset)
-{
-#if _SQUID_FREEBSD_ && defined(_SQUID_RES_NSADDR6_COUNT)
-    /* Only seems to be valid on FreeBSD 5.5 where _res_ext was provided without an ns6addr counter! */
-    /* Gone again on FreeBSD 6.2 along with _res_ext itself in any form. */
-    int ns6count = 0;
-#endif
-#if HAVE_RES_INIT && defined(_SQUID_RES_NSADDR_LIST)
-    extern char *optarg;
-#endif
-
-#if HAVE_RES_INIT && (defined(_SQUID_RES_NSADDR_LIST) || defined(_SQUID_RES_NSADDR6_LIST))
-
-    if (reset == 0) {
-#if defined(_SQUID_RES_NSADDR_COUNT)
-        _SQUID_RES_NSADDR_COUNT = 0;
-        /* because I don't trust the nscount super-count entirely, make sure these are ALL invalid */
-        memset(_SQUID_RES_NSADDR_LIST, 0, sizeof(struct sockaddr_in)*MAXNS);
-#endif
-#if defined(_SQUID_RES_NSADDR6_COUNT)
-        _SQUID_RES_NSADDR6_COUNT = 0;
-#endif
-    }
-
-    /* AYJ:
-     *  I experimented with all the permutations of mixed/unmixed nscount/nscount6 IPv4/IPv6/Both/invalid
-     *
-     *  I'm not sure if splitting them really helps.
-     *  I've seen no evidence of IPv4 resolver *ever* being used when some IPv6 are set (or not even)
-     *  BUT, have seen segfault when IPv4 is added to NSADDR6 list (_res._u._ext).
-     *  It also appears to not do ANY lookup when _res.nscount==0.
-     *
-     *  BUT, even if _res.nsaddrs is memset to NULL, it resolves IFF IPv6 set in _ext.
-     *
-     *  SO, am splitting the IPv4/v6 into the seperate _res fields
-     *      and making nscount a total of IPv4+IPv6 /w nscount6 the IPv6 sub-counter
-     *	ie. nscount = count(NSv4)+count(NSv6) & nscount6 = count(NSv6)
-     *
-     * If ANYONE knows better please let us know.
-     */
-    struct addrinfo hints;
-    memset(&hints, '\0', sizeof(struct addrinfo));
-    hints.ai_family = AF_UNSPEC;
-    hints.ai_flags = AI_NUMERICHOST; // prevent repeated DNS lookups!
-    struct addrinfo *AI = NULL;
-    if ( getaddrinfo(optarg, NULL, &hints, &AI) != 0) {
-        fprintf(stderr, "%s appears to be a bad nameserver FQDN/IP.\n",optarg);
-    } else if ( AI->ai_family == AF_INET ) {
-        if (_SQUID_RES_NSADDR_COUNT == MAXNS) {
-            fprintf(stderr, "Too many -s options, only %d are allowed\n", MAXNS);
-        } else {
-            _SQUID_RES_NSADDR_LIST[_SQUID_RES_NSADDR_COUNT] = _SQUID_RES_NSADDR_LIST[0];
-            memcpy(&_SQUID_RES_NSADDR_LIST[_SQUID_RES_NSADDR_COUNT++].sin_addr, &((struct sockaddr_in*)AI->ai_addr)->sin_addr, sizeof(struct in_addr));
-        }
-    } else if ( AI->ai_family == AF_INET6 ) {
-#if USE_IPV6 && defined(_SQUID_RES_NSADDR6_LIST)
-        /* because things NEVER seem to resolve in tests without _res.nscount being a total. */
-        if (_SQUID_RES_NSADDR_COUNT == MAXNS) {
-            fprintf(stderr, "Too many -s options, only %d are allowed\n", MAXNS);
-        } else {
-            ++ _SQUID_RES_NSADDR_COUNT;
-            memcpy(&_SQUID_RES_NSADDR6_LIST(_SQUID_RES_NSADDR6_COUNT++), &((struct sockaddr_in6*)AI->ai_addr)->sin6_addr, sizeof(struct in6_addr));
-        }
-#else
-        fprintf(stderr, "IPv6 nameservers not supported on this resolver\n");
-#endif
-    }
-    if (AI != NULL)
-        freeaddrinfo(AI);
-
-#else /* !HAVE_RES_INIT || !defined(_SQUID_RES_NSADDR_LIST) */
-
-    fprintf(stderr, "-s is not supported on this resolver\n");
-
-#endif /* HAVE_RES_INIT */
-}
-
-/**
- * \ingroup dnsserver
- *
- * This is the external dnsserver process.
- */
-int
-main(int argc, char *argv[])
-{
-    char request[512];
-    char *t = NULL;
-    int c;
-    int opt_s = 0;
-
-#if HAVE_RES_INIT
-    res_init();
-#endif
-
-#if USE_IPV6
-    /* perform AAAA lookups *before* A lookups in IPv6 mode. */
-    _res.options |= RES_USE_INET6;
-#endif
-
-    while ((c = getopt(argc, argv, "Dhs:v")) != -1) {
-        switch (c) {
-
-        case 'D':
-            fprintf(stderr, "-D is now default behaviour from this tool.\n");
-            break;
-
-        case 's':
-            squid_res_setservers(opt_s);
-            opt_s = 1;
-            break;
-
-        case 'v':
-            printf("dnsserver version %s\n", VERSION);
-
-            exit(0);
-
-            break;
-
-        case 'h':
-
-        default:
-            usage();
-
-            exit(1);
-
-            break;
-        }
-    }
-
-#if _SQUID_WINDOWS_
-    {
-        WSADATA wsaData;
-
-        WSAStartup(2, &wsaData);
-    }
-
-    fflush(stderr);
-#endif
-
-    for (;;) {
-        memset(request, '\0', REQ_SZ);
-
-        if (fgets(request, REQ_SZ, stdin) == NULL) {
-#if _SQUID_WINDOWS_
-            WSACleanup();
-#endif
-            exit(1);
-        }
-
-        t = strrchr(request, '\n');
-
-        if (t == NULL)		/* Ignore if no newline */
-            continue;
-
-        *t = '\0';		/* strip NL */
-
-        if ((t = strrchr(request, '\r')) != NULL)
-            *t = '\0';		/* strip CR */
-
-        lookup(request);
-
-        fflush(stdout);
-    }
-
-    /* NOTREACHED */
-    return 0;
-}
@@ -194,9 +194,7 @@ typedef enum {
     // following pools are initialized late by their component if needed (or never)
     MEM_FQDNCACHE_ENTRY,
     MEM_FWD_SERVER,
-#if !USE_DNSHELPER
     MEM_IDNS_QUERY,
-#endif
     MEM_IPCACHE_ENTRY,
     MEM_MAX
 } mem_type;
@@ -135,13 +135,8 @@ static struct _fqdn_cache_stats {
 /// \ingroup FQDNCacheInternal
 static dlink_list lru_list;
 
-#if USE_DNSHELPER
-static HLPCB fqdncacheHandleReply;
-static int fqdncacheParse(fqdncache_entry *, const char *buf);
-#else
 static IDNSCB fqdncacheHandleReply;
 static int fqdncacheParse(fqdncache_entry *, const rfc1035_rr *, int, const char *error_message);
-#endif
 static void fqdncacheRelease(fqdncache_entry *);
 static fqdncache_entry *fqdncacheCreateEntry(const char *name);
 static void fqdncacheCallback(fqdncache_entry *, int wait);
@@ -346,81 +341,6 @@ fqdncacheCallback(fqdncache_entry * f, int wait)
 }
 
 /// \ingroup FQDNCacheInternal
-#if USE_DNSHELPER
-static int
-fqdncacheParse(fqdncache_entry *f, const char *inbuf)
-{
-    LOCAL_ARRAY(char, buf, DNS_INBUF_SZ);
-    char *token;
-    int ttl;
-    const char *name = (const char *)f->hash.key;
-    f->expires = squid_curtime + Config.negativeDnsTtl;
-    f->flags.negcached = 1;
-
-    if (inbuf == NULL) {
-        debugs(35, DBG_IMPORTANT, "fqdncacheParse: Got <NULL> reply in response to '" << name << "'");
-        f->error_message = xstrdup("Internal Error");
-        return -1;
-    }
-
-    xstrncpy(buf, inbuf, DNS_INBUF_SZ);
-    debugs(35, 5, "fqdncacheParse: parsing: {" << buf << "}");
-    token = strtok(buf, w_space);
-
-    if (NULL == token) {
-        debugs(35, DBG_IMPORTANT, "fqdncacheParse: Got <NULL>, expecting '$name' in response to '" << name << "'");
-        f->error_message = xstrdup("Internal Error");
-        return -1;
-    }
-
-    if (0 == strcmp(token, "$fail")) {
-        token = strtok(NULL, "\n");
-        assert(NULL != token);
-        f->error_message = xstrdup(token);
-        return 0;
-    }
-
-    if (0 != strcmp(token, "$name")) {
-        debugs(35, DBG_IMPORTANT, "fqdncacheParse: Got '" << inbuf << "', expecting '$name' in response to '" << name << "'");
-        f->error_message = xstrdup("Internal Error");
-        return -1;
-    }
-
-    token = strtok(NULL, w_space);
-
-    if (NULL == token) {
-        debugs(35, DBG_IMPORTANT, "fqdncacheParse: Got '" << inbuf << "', expecting TTL in response to '" << name << "'");
-        f->error_message = xstrdup("Internal Error");
-        return -1;
-    }
-
-    ttl = atoi(token);
-
-    token = strtok(NULL, w_space);
-
-    if (NULL == token) {
-        debugs(35, DBG_IMPORTANT, "fqdncacheParse: Got '" << inbuf << "', expecting hostname in response to '" << name << "'");
-        f->error_message = xstrdup("Internal Error");
-        return -1;
-    }
-
-    f->names[0] = xstrdup(token);
-    f->name_count = 1;
-
-    if (ttl == 0 || ttl > Config.positiveDnsTtl)
-        ttl = Config.positiveDnsTtl;
-
-    if (ttl < Config.negativeDnsTtl)
-        ttl = Config.negativeDnsTtl;
-
-    f->expires = squid_curtime + ttl;
-
-    f->flags.negcached = 0;
-
-    return f->name_count;
-}
-
-#else
 static int
 fqdncacheParse(fqdncache_entry *f, const rfc1035_rr * answers, int nr, const char *error_message)
 {
@@ -490,35 +410,21 @@ fqdncacheParse(fqdncache_entry *f, const rfc1035_rr * answers, int nr, const cha
     return f->name_count;
 }
 
-#endif
-
 /**
  \ingroup FQDNCacheAPI
  *
  * Callback for handling DNS results.
  */
 static void
-#if USE_DNSHELPER
-fqdncacheHandleReply(void *data, const HelperReply &reply)
-#else
 fqdncacheHandleReply(void *data, const rfc1035_rr * answers, int na, const char *error_message)
-#endif
 {
     fqdncache_entry *f;
     static_cast<generic_cbdata *>(data)->unwrap(&f);
     ++FqdncacheStats.replies;
     const int age = f->age();
     statCounter.dns.svcTime.count(age);
-#if USE_DNSHELPER
-
-    fqdncacheParse(f, reply.other().content());
-#else
-
     fqdncacheParse(f, answers, na, error_message);
-#endif
-
     fqdncacheAddEntry(f);
-
     fqdncacheCallback(f, age);
 }
 
@@ -584,11 +490,7 @@ fqdncache_nbgethostbyaddr(const Ip::Address &addr, FQDNH * handler, void *handle
     f->handlerData = cbdataReference(handlerData);
     f->request_time = current_time;
     c = new generic_cbdata(f);
-#if USE_DNSHELPER
-    dnsSubmit(hashKeyStr(&f->hash), fqdncacheHandleReply, c);
-#else
     idnsPTRLookup(addr, fqdncacheHandleReply, c);
-#endif
 }
 
 /**
@@ -1,6 +1,6 @@
 include $(top_srcdir)/src/Common.am
 
-EXTRA_LTLIBRARIES = libaufs.la libdiskd.la libcoss.la libufs.la librock.la
+EXTRA_LTLIBRARIES = libaufs.la libdiskd.la libufs.la librock.la
 noinst_LTLIBRARIES =  $(STORE_LIBS_TO_BUILD) libfs.la
 
 # aufs is a "fake" legacy store
@@ -11,14 +11,6 @@ libaufs_la_SOURCES = \
 libdiskd_la_SOURCES = \
 	diskd/StoreFSdiskd.cc
 
-libcoss_la_SOURCES = \
-	coss/StoreFScoss.h \
-	coss/StoreFScoss.cc \
-	coss/store_coss.h \
-	coss/store_io_coss.cc \
-	coss/store_dir_coss.cc \
-	coss/CossSwapDir.h
-
 libufs_la_SOURCES = \
 	ufs/StoreFSufs.h \
 	ufs/StoreFSufs.cc \
@@ -52,16 +44,11 @@ libfs_la_SOURCES = Module.cc Module.h
 libfs_la_LIBADD =  $(STORE_LIBS_TO_BUILD)
 libfs_la_DEPENDENCIES = $(STORE_LIBS_TO_BUILD)
 
-EXTRA_DIST = \
-	coss/coss-notes.txt
-
 ## we need our local files too (but avoid -I. at all costs)
 INCLUDES += -I$(srcdir)
 
 
 ## targets below to emulate distributed makefiles
-coss/all: libcoss.la
-coss/clean: clean
 ufs/all: libufs.la
 ufs/clean: clean
 rock/all: librock.la
@@ -72,7 +59,7 @@ TESTS += testHeaders
 
 ## Special Universal .h dependency test script
 ## aborts if error encountered
-testHeaders: $(srcdir)/ufs/*.h $(srcdir)/coss/*.h $(srcdir)/rock/*.h
+testHeaders: $(srcdir)/ufs/*.h $(srcdir)/rock/*.h
 	$(SHELL) $(top_srcdir)/test-suite/testheaders.sh "$(CXXCOMPILE)" $^ || exit 1
 ## diskd/ has no .h files
 ## aufs/ has no .h files
@@ -5,10 +5,6 @@
 #include "fs/ufs/UFSSwapDir.h"
 #endif
 
-#if HAVE_FS_COSS
-#include "fs/coss/StoreFScoss.h"
-#endif
-
 #if HAVE_FS_UFS
 static Fs::Ufs::StoreFSufs<Fs::Ufs::UFSSwapDir> *UfsInstance;
 #endif
@@ -26,15 +22,6 @@ static Fs::Ufs::StoreFSufs<Fs::Ufs::UFSSwapDir> *DiskdInstance;
 static Rock::StoreFileSystem *RockInstance = NULL;
 #endif
 
-/* TODO: Modify coss code to:
- * (a) remove the StoreFScoss::GetInstance method,
- * (b) declare the StoreFScoss::stats  as static and
- * (c) merge the StoreFScoss::stat() method with the static
- *     StoreFScoss::Stats() */
-#if HAVE_FS_COSS
-StoreFScoss &CossInstance = StoreFScoss::GetInstance();
-#endif
-
 void Fs::Init()
 {
 
@@ -1,146 +0,0 @@
-#ifndef __COSSSWAPDIR_H__
-#define __COSSSWAPDIR_H__
-
-class StoreEntry;
-class CossSwapDir;
-class CossMemBuf;
-class DiskIOStrategy;
-class DiskIOModule;
-class ConfigOptionVector;
-class DiskFile;
-
-#include "SwapDir.h"
-#include "DiskIO/IORequestor.h"
-
-#ifndef COSS_MEMBUF_SZ
-#define	COSS_MEMBUF_SZ	1048576
-#endif
-
-/* Note that swap_filen in sio/e are actually disk offsets too! */
-
-/* What we're doing in storeCossAllocate() */
-#define COSS_ALLOC_ALLOCATE		1
-#define COSS_ALLOC_REALLOC		2
-
-/// \ingroup COSS
-class CossSwapDir : public SwapDir, public IORequestor
-{
-
-public:
-    CossSwapDir();
-    virtual void init();
-    virtual void create();
-    virtual void dump(StoreEntry &)const;
-    ~CossSwapDir();
-    virtual StoreSearch *search(String const url, HttpRequest *);
-    virtual bool unlinkdUseful() const;
-    virtual void unlink (StoreEntry &);
-    virtual void statfs (StoreEntry &)const;
-    virtual bool canStore(const StoreEntry &e, int64_t diskSpaceNeeded, int &load) const;
-    virtual int callback();
-    virtual void sync();
-    virtual StoreIOState::Pointer createStoreIO(StoreEntry &, StoreIOState::STFNCB *, StoreIOState::STIOCB *, void *);
-    virtual StoreIOState::Pointer openStoreIO(StoreEntry &, StoreIOState::STFNCB *, StoreIOState::STIOCB *, void *);
-    virtual void openLog();
-    virtual void closeLog();
-    virtual int writeCleanStart();
-    virtual void writeCleanDone();
-    virtual void logEntry(const StoreEntry & e, int op) const;
-    virtual void parse (int index, char *path);
-    virtual void reconfigure();
-    virtual void swappedOut(const StoreEntry &e);
-    virtual uint64_t currentSize() const { return cur_size; }
-    virtual uint64_t currentCount() const { return n_disk_objects; }
-    /* internals */
-    virtual off_t storeCossFilenoToDiskOffset(sfileno);
-    virtual sfileno storeCossDiskOffsetToFileno(off_t);
-    virtual CossMemBuf *storeCossFilenoToMembuf(sfileno f);
-    /* IORequestor routines */
-    virtual void ioCompletedNotification();
-    virtual void closeCompleted();
-    virtual void readCompleted(const char *buf, int len, int errflag, RefCount<ReadRequest>);
-    virtual void writeCompleted(int errflag, size_t len, RefCount<WriteRequest>);
-    //private:
-    int swaplog_fd;
-    int count;
-    dlink_list membufs;
-
-    CossMemBuf *current_membuf;
-    off_t current_offset;	/* in Blocks */
-    int numcollisions;
-    dlink_list cossindex;
-    unsigned int blksz_bits;
-    unsigned int blksz_mask;  /* just 1<<blksz_bits - 1*/
-    DiskIOStrategy *io;
-    RefCount<DiskFile> theFile;
-    char *storeCossMemPointerFromDiskOffset(off_t offset, CossMemBuf ** mb);
-    void storeCossMemBufUnlock(StoreIOState::Pointer);
-    CossMemBuf *createMemBuf(off_t start, sfileno curfn, int *collision);
-    sfileno allocate(const StoreEntry * e, int which);
-    void startMembuf();
-    StoreEntry *addDiskRestore(const cache_key *const key,
-                               int file_number,
-                               uint64_t swap_file_sz,
-                               time_t expires,
-                               time_t timestamp,
-                               time_t lastref,
-                               time_t lastmod,
-                               uint32_t refcount,
-                               uint16_t flags,
-                               int clean);
-
-private:
-    void changeIO(DiskIOModule *module);
-    bool optionIOParse(char const *option, const char *value, int reconfiguring);
-    void optionIODump(StoreEntry * e) const;
-    void optionBlockSizeDump(StoreEntry *) const;
-    bool optionBlockSizeParse(const char *, const char *, int);
-    char const *stripePath() const;
-    ConfigOption * getOptionTree() const;
-    const char *ioModule;
-    mutable ConfigOptionVector *currentIOOptions;
-    const char *stripe_path;
-    uint64_t cur_size; ///< currently used space in the storage area
-    uint64_t n_disk_objects; ///< total number of objects stored
-};
-
-/// \ingroup COSS
-void storeCossAdd(CossSwapDir *, StoreEntry *);
-/// \ingroup COSS
-void storeCossRemove(CossSwapDir *, StoreEntry *);
-/// \ingroup COSS
-void storeCossStartMembuf(CossSwapDir * SD);
-
-#include "StoreSearch.h"
-
-/// \ingroup COSS
-class StoreSearchCoss : public StoreSearch
-{
-
-public:
-    StoreSearchCoss(RefCount<CossSwapDir> sd);
-    StoreSearchCoss(StoreSearchCoss const &);
-    ~StoreSearchCoss();
-    /* Iterator API - garh, wrong place */
-    /* callback the client when a new StoreEntry is available
-     * or an error occurs
-     */
-    virtual void next(void (callback)(void *cbdata), void *cbdata);
-    /* return true if a new StoreEntry is immediately available */
-    virtual bool next();
-    virtual bool error() const;
-    virtual bool isDone() const;
-    virtual StoreEntry *currentItem();
-
-private:
-    RefCount<CossSwapDir> sd;
-    void (*callback)(void *cbdata);
-    void *cbdata;
-    bool _done;
-    dlink_node * current;
-    dlink_node * next_;
-
-    CBDATA_CLASS2(StoreSearchCoss);
-};
-
-#endif
@@ -1,132 +0,0 @@
-/*
- * DEBUG: section 47    Store Directory Routines
- * AUTHOR: Robert Collins
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
- */
-
-#include "squid.h"
-#include "StoreFileSystem.h"
-#include "StoreFScoss.h"
-#include "mgr/Registration.h"
-#include "Store.h"
-#include "CossSwapDir.h"
-#include "store_coss.h"
-
-StoreFScoss StoreFScoss::_instance;
-
-StoreFScoss &
-StoreFScoss::GetInstance()
-{
-    return _instance;
-}
-
-StoreFScoss::StoreFScoss()
-{
-    FsAdd(*this);
-    registerWithCacheManager();
-}
-
-char const *
-StoreFScoss::type() const
-{
-    return "coss";
-}
-
-void
-StoreFScoss::done()
-{
-    /*  delete coss_index_pool;coss_index_pool = NULL;  XXX Should be here? */
-    initialised = false;
-}
-
-SwapDir *
-StoreFScoss::createSwapDir()
-{
-    SwapDir *result = new CossSwapDir;
-    return result;
-}
-
-void
-StoreFScoss::setup()
-{
-    assert(!initialised);
-
-    coss_index_pool = memPoolCreate("COSS index data", sizeof(CossIndexNode));
-    initialised = true;
-}
-
-void
-StoreFScoss::registerWithCacheManager()
-{
-    Mgr::RegisterAction("coss", "COSS Stats", Stats, 0, 1);
-}
-
-void
-StoreFScoss::Stats(StoreEntry * sentry)
-{
-    GetInstance().stat(sentry);
-}
-
-void
-StoreFScoss::stat(StoreEntry *sentry)
-{
-    stats.stat(sentry);
-}
-
-void
-CossStats::stat(StoreEntry *sentry)
-{
-    const char *tbl_fmt = "%10s %10d %10d %10d\n";
-    storeAppendPrintf(sentry, "\n                   OPS     SUCCESS        FAIL\n");
-    storeAppendPrintf(sentry, tbl_fmt,
-                      "open", open.ops, open.success, open.fail);
-    storeAppendPrintf(sentry, tbl_fmt,
-                      "create", create.ops, create.success, create.fail);
-    storeAppendPrintf(sentry, tbl_fmt,
-                      "close", close.ops, close.success, close.fail);
-    storeAppendPrintf(sentry, tbl_fmt,
-                      "unlink", unlink.ops, unlink.success, unlink.fail);
-    storeAppendPrintf(sentry, tbl_fmt,
-                      "read", read.ops, read.success, read.fail);
-    storeAppendPrintf(sentry, tbl_fmt,
-                      "write", write.ops, write.success, write.fail);
-    storeAppendPrintf(sentry, tbl_fmt,
-                      "s_write", stripe_write.ops, stripe_write.success, stripe_write.fail);
-
-    storeAppendPrintf(sentry, "\n");
-    storeAppendPrintf(sentry, "stripes:          %d\n", stripes);
-    storeAppendPrintf(sentry, "alloc.alloc:      %d\n", alloc.alloc);
-    storeAppendPrintf(sentry, "alloc.realloc:    %d\n", alloc.realloc);
-    storeAppendPrintf(sentry, "alloc.collisions: %d\n", alloc.collisions);
-    storeAppendPrintf(sentry, "disk_overflows:   %d\n", disk_overflows);
-    storeAppendPrintf(sentry, "stripe_overflows: %d\n", stripe_overflows);
-    storeAppendPrintf(sentry, "open_mem_hits:    %d\n", open_mem_hits);
-    storeAppendPrintf(sentry, "open_mem_misses:  %d\n", open_mem_misses);
-}
@@ -1,96 +0,0 @@
-/*
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
- */
-#ifndef SQUID_STOREFSCOSS_H
-#define SQUID_STOREFSCOSS_H
-
-class StoreEntry;
-
-/**
- \defgroup COSS COSS Storage Filesystem
- \ingroup FileSystems
- */
-
-/// \ingroup COSS
-class CossStats
-{
-
-public:
-    void stat(StoreEntry * sentry);
-    int stripes;
-
-    struct {
-        int alloc;
-        int realloc;
-        int collisions;
-    } alloc;
-    int disk_overflows;
-    int stripe_overflows;
-    int open_mem_hits;
-    int open_mem_misses;
-
-    struct {
-        int ops;
-        int success;
-        int fail;
-    }
-
-    open, create, close, unlink, read, write, stripe_write;
-};
-
-class CacheManager;
-
-#include "StoreFileSystem.h"
-
-/// \ingroup COSS, FileSystems
-class StoreFScoss : public StoreFileSystem
-{
-
-public:
-    static StoreFScoss &GetInstance();
-    static void Stats(StoreEntry * sentry);
-    StoreFScoss();
-    virtual ~StoreFScoss() {}
-
-    virtual char const *type() const;
-    virtual SwapDir *createSwapDir();
-    virtual void done();
-    virtual void registerWithCacheManager(void);
-    virtual void setup();
-    /* Not implemented */
-    StoreFScoss (StoreFScoss const &);
-    StoreFScoss &operator=(StoreFScoss const &);
-    void stat(StoreEntry * sentry);
-    CossStats stats;
-
-private:
-    static StoreFScoss _instance;
-};
-
-#endif /* SQUID_STOREFSCOSS_H */
@@ -1,128 +0,0 @@
-COSS notes
-
-Amos Jeffries <squid3@treenet.co.nz>
-
-COSS Support is not stable yet in Squid-3. Please do not use.
-
-Any help porting the stability fixes from Squid 2.6 and 2.7
-is very welcome though to resolve this issue.
-
-
-Adrian Chadd <adrian@creative.net.au>
-
-COSS is a Cyclic Object storage system originally designed by
-Eric Stern <estern@logisense.com>. The idea has been extended
-and worked into the current framework by myself.
-
-In these notes I'll discuss the current implementation of COSS
-and note where the implementation differed from Eric's original
-idea and why the design changes were made.
-
-
-COSS basics
------------
-
-COSS works with a single file. Eventually the file may actually be
-a raw disk device, but since squid doesn't cache the disk reads
-in memory the OS buffer cache will need to be employed for reasonable
-performance. For the purposes of this discussion the COSS storage
-device will be referred to as a file.
-
-Each stripe is a fixed size an in a fixed position in the file. The
-stripe size is a compile-time option.
-
-As objects are written to a COSS stripe, their place is pre-reserved
-and data is copied into a memory copy of the stripe. Because of this,
-the object size must be known before it can be stored in a COSS
-filesystem. (Hence the max-size requirement with a coss cache_dir.)
-
-When a stripe is filled, the stripe is written to disk, and a new
-memory stripe is created.
-
-When objects are read back from the COSS file, they can either come
-from a stripe in-memory (the current one, or one being written),
-or from the disk. If the object is still in a memory stripe, then
-it is copied from memory rather than read of disk.
-
-If an object is read from disk, it is re-written to the head of
-the current stripe (just as if it were a new object.) This is required
-for correct operation of the replacement policy, detailed below.
-
-When the entire COSS file is full, the current stripe again becomes the
-fist stripe in the file, and the objects in that stripe are released.
-Since the objects on disk are kept in a strict LRU representing the
-replacement policy LRU linking the StoreEntry's together, this simply
-involves walking the tail of the LRU and freeing entries until we
-hit an entry in the next stripe.
-
-
-COSS implementation details
----------------------------
-
-* The stripe size is fixed. In the original COSS code, Eric optimised
-  this a little by allowing the stripes to be truncated to not
-  waste disk space at the end of the stripe. This was removed
-  to simplify the allocation code slightly and make things easier
-  when the store log and checksums are combined in the stripe
-  for faster rebuilds.
-
-* COSS currently copies object memory around WAY too much. This needs
-  to be fixed eventually.
-
-* It would be nice if the storeRead() interface were a little smarter
-  and allowed the filesystem to return as much of an object as possible.
-  This would be good for COSS since the read from disk could be simplified
-  to use a single OS read() call - this would work really well for
-  the object types COSS is designed to cache.
-
-* The original coss code used file_read() and file_write() for disk IO.
-  The file_* routines were initially used to implement async disk IO,
-  and Eric probably wrote some async disk code for windows.
-  I've written a very very simple async_io.c module which uses POSIX
-  AIO to implement the async IO. POSIX AIO is well-suited to the
-  disk IO COSS performs.
-
-COSS direction
---------------
-
-Eventually, when more of squid is rewritten, I'm going to replace
-the replacement policy with something a little more flexible.
-A shortcut would be to use a slab allocator and have one slab per
-stripe for the StoreEntry's. When it comes time to replace a stripe,
-you can just treat the stripe as an array. This would not work
-well in the current squid codebase, but it would work well in the
-planned rewrite. This would also allow alternate replacement policies
-to be used. Oh, it'd cut down the storage requirements per
-StoreEntry by two pointers (8 bytes on the i386.)
-
-Notes by DW July 23, 2003
--------------------------
-
-Fixed up swap_filen -> offset implementation.  Now user can use a
-block-size setting to determine the maximum COSS cache_dir size.
-
-Fixed bug when cached response is larger than COSS stripe size.
-Now require max-size to be less than COSS_MEMBUF_SZ.
-
-Fixed a lockcount bug.  Some aborted requests for cache hits failed
-to unlock the CossMemBuf because storeCossReadDone isn't called again.
-Solution is to add locked_membuf pointer to CossState structure and
-always unlock it if set.  This is probably more reliable than
-unlocking based on diskstart/diskend offsets.
-
-I'm worried that COSS is susceptible to a denial-of-service.  If
-the user can create N cache misses for responses about as large as
-COSS_MEMBUF_SZ, then COSS probably allocates N membufs (stripes)
-at the same time.  For large enough values of N, this should cause
-a malloc failure.  Solution may be to refuse to allocate new stripes
-(thus returning failure for cache misses and hits) after so many
-have already been allocated.
-
-Adrian's code has this comment:
-
-    /* Since we're not supporting NOTIFY anymore, lets fail */
-    assert(which != COSS_ALLOC_NOTIFY);
-
-However, COSS_ALLOC_NOTIFY was still present in the store_dir_coss.c
-rebuild routines.  To avoid assertions during rebuild, I commented
-out the storeCossAllocate(SD, e, COSS_ALLOC_NOTIFY) call.
@@ -1,133 +0,0 @@
-#ifndef __COSS_H__
-#define __COSS_H__
-
-#include "SwapDir.h"
-
-#ifndef COSS_MEMBUF_SZ
-#define	COSS_MEMBUF_SZ	1048576
-#endif
-
-/** \note  swap_filen in sio/e are actually disk offsets too! */
-
-/** What we're doing in storeCossAllocate() */
-#define COSS_ALLOC_NOTIFY		0
-
-/** What we're doing in storeCossAllocate() */
-#define COSS_ALLOC_ALLOCATE		1
-
-/** What we're doing in storeCossAllocate() */
-#define COSS_ALLOC_REALLOC		2
-
-class CossSwapDir;
-
-/// \ingroup COSS
-class CossMemBuf
-{
-
-public:
-    void describe(int level, int line);
-    void maybeWrite(CossSwapDir * SD);
-    void write(CossSwapDir * SD);
-    dlink_node node;
-    off_t diskstart;		/* in blocks */
-    off_t diskend;		/* in blocks */
-    CossSwapDir *SD;
-    int lockcount;
-    char buffer[COSS_MEMBUF_SZ];
-
-    struct _cossmembuf_flags {
-        _cossmembuf_flags() : full(false), writing(false) {}
-        bool full;
-        bool writing;
-    } flags;
-};
-
-/// \ingroup COSS
-struct _cossindex {
-    /**
-     \note The dlink_node MUST be the first member of the structure.
-     *     This member is later pointer typecasted to coss_index_node *.
-     */
-    dlink_node node;
-};
-
-/**
- \ingroup COSS
- * Per-storeiostate info
- */
-class CossState : public StoreIOState
-{
-
-public:
-    MEMPROXY_CLASS(CossState);
-    CossState(CossSwapDir *);
-    ~CossState();
-
-    char *readbuffer;
-    char *requestbuf;
-    size_t requestlen;
-    size_t requestoffset;	/* in blocks */
-    int64_t reqdiskoffset;	/* in blocks */
-
-    struct CossFlags {
-        bool reading;
-        bool writing;
-    } flags;
-
-    CossMemBuf *locked_membuf;
-    off_t st_size;
-    void read_(char *buf, size_t size, off_t offset, STRCB * callback, void *callback_data);
-    void write(char const *buf, size_t size, off_t offset, FREE * free_func);
-    virtual void close(int);
-    void doCallback(int errflag);
-    void lockMemBuf();
-
-    CossSwapDir *SD;
-};
-
-MEMPROXY_CLASS_INLINE(CossState);
-
-/// \ingroup COSS
-typedef struct _cossindex CossIndexNode;
-
-/**
- \ingroup COSS
- * Whether the coss system has been setup or not
- */
-extern int coss_initialised;
-/// \ingroup COSS
-extern MemAllocator *coss_membuf_pool;
-/// \ingroup COSS
-extern MemAllocator *coss_index_pool;
-
-#include "DiskIO/ReadRequest.h"
-
-/// \ingroup COSS
-class CossRead : public ReadRequest
-{
-
-public:
-    CossRead(ReadRequest const &base, StoreIOState::Pointer anSio) : ReadRequest(base) , sio(anSio) {}
-
-    StoreIOState::Pointer sio;
-
-private:
-    CBDATA_CLASS2(CossRead);
-};
-
-#include "DiskIO/WriteRequest.h"
-
-/// \ingroup COSS
-class CossWrite : public WriteRequest
-{
-
-public:
-    CossWrite(WriteRequest const &base, CossMemBuf *aBuf) : WriteRequest(base) , membuf(aBuf) {}
-
-    CossMemBuf *membuf;
-
-private:
-    CBDATA_CLASS2(CossWrite);
-};
-
-#endif
@@ -1,1203 +0,0 @@
-/*
- * DEBUG: section 47    Store COSS Directory Routines
- * AUTHOR: Eric Stern
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- */
-
-#include "squid.h"
-#include "CossSwapDir.h"
-#include "cache_cf.h"
-#include "Store.h"
-#include "store_coss.h"
-#include "disk.h"
-#include "event.h"
-#include "fde.h"
-#include "SwapDir.h"
-#include "StoreSwapLogData.h"
-#include "DiskIO/DiskIOModule.h"
-#include "DiskIO/DiskIOStrategy.h"
-#include "DiskIO/ReadRequest.h"
-#include "ConfigOption.h"
-#include "StoreFScoss.h"
-#include "Parsing.h"
-#include "store_key_md5.h"
-#include "swap_log_op.h"
-#include "store_rebuild.h"
-#include "SquidConfig.h"
-#include "SquidMath.h"
-
-#if HAVE_ERRNO_H
-#include <errno.h>
-#endif
-
-#define STORE_META_BUFSZ 4096
-
-int n_coss_dirs = 0;
-/* static int last_coss_pick_index = -1; */
-MemAllocator *coss_index_pool = NULL;
-
-typedef struct _RebuildState RebuildState;
-
-struct _RebuildState {
-    CossSwapDir *sd;
-    int n_read;
-    FILE *log;
-    int speed;
-
-    struct {
-        unsigned int clean:1;
-    } flags;
-
-    StoreRebuildData counts;
-};
-
-static char *storeCossDirSwapLogFile(SwapDir *, const char *);
-static EVH storeCossRebuildFromSwapLog;
-static void storeCossDirRebuild(CossSwapDir * sd);
-static void storeCossDirCloseTmpSwapLog(CossSwapDir * sd);
-static FILE *storeCossDirOpenTmpSwapLog(CossSwapDir *, int *, int *);
-
-static char *
-storeCossDirSwapLogFile(SwapDir * sd, const char *ext)
-{
-    LOCAL_ARRAY(char, path, MAXPATHLEN);
-    LOCAL_ARRAY(char, pathtmp, MAXPATHLEN);
-    LOCAL_ARRAY(char, digit, 32);
-    char *pathtmp2;
-
-    if (Config.Log.swap) {
-        xstrncpy(pathtmp, sd->path, MAXPATHLEN - 64);
-        pathtmp2 = pathtmp;
-
-        while ((pathtmp2 = strchr(pathtmp2, '/')) != NULL)
-            *pathtmp2 = '.';
-
-        while (strlen(pathtmp) && pathtmp[strlen(pathtmp) - 1] == '.')
-            pathtmp[strlen(pathtmp) - 1] = '\0';
-
-        for (pathtmp2 = pathtmp; *pathtmp2 == '.'; ++pathtmp2);
-        snprintf(path, MAXPATHLEN - 64, Config.Log.swap, pathtmp2);
-
-        if (strncmp(path, Config.Log.swap, MAXPATHLEN - 64) == 0) {
-            strcat(path, ".");
-            snprintf(digit, 32, "%02d", sd->index);
-            strncat(path, digit, 3);
-        }
-    } else {
-        xstrncpy(path, sd->path, MAXPATHLEN - 64);
-        strcat(path, "/swap.state");
-    }
-
-    if (ext)
-        strncat(path, ext, 16);
-
-    return path;
-}
-
-void
-CossSwapDir::openLog()
-{
-    char *logPath;
-    logPath = storeCossDirSwapLogFile(this, NULL);
-    swaplog_fd = file_open(logPath, O_WRONLY | O_CREAT | O_BINARY);
-
-    if (swaplog_fd < 0) {
-        debugs(47, DBG_IMPORTANT, "" << logPath << ": " << xstrerror());
-        fatal("storeCossDirOpenSwapLog: Failed to open swap log.");
-    }
-
-    debugs(47, 3, "Cache COSS Dir #" << index << " log opened on FD " << swaplog_fd);
-}
-
-void
-CossSwapDir::closeLog()
-{
-    if (swaplog_fd < 0)	/* not open */
-        return;
-
-    file_close(swaplog_fd);
-
-    debugs(47, 3, "Cache COSS Dir #" << index << " log closed on FD " << swaplog_fd);
-
-    swaplog_fd = -1;
-}
-
-void
-CossSwapDir::ioCompletedNotification()
-{
-    if (theFile->error()) {
-        debugs(47, DBG_IMPORTANT, "" << path << ": " << xstrerror());
-        fatal("storeCossDirInit: Failed to open a COSS file.");
-    }
-}
-
-void
-CossSwapDir::closeCompleted()
-{
-    theFile = NULL;
-}
-
-void
-CossSwapDir::readCompleted(const char *buf, int len, int errflag, RefCount<ReadRequest> aRequest)
-{
-    CossRead* cossRead= dynamic_cast<CossRead *>(aRequest.getRaw());
-    assert (cossRead);
-    StoreIOState::Pointer sio =  cossRead->sio;
-    void *cbdata;
-    StoreIOState::STRCB *callback = sio->read.callback;
-    char *p;
-    CossState *cstate = dynamic_cast<CossState *>(sio.getRaw());
-    ssize_t rlen;
-
-    debugs(79, 3, "storeCossReadDone: fileno " << sio->swap_filen << ", len " << len);
-    cstate->flags.reading = false;
-
-    if (errflag) {
-        ++ StoreFScoss::GetInstance().stats.read.fail;
-
-        if (errflag > 0) {
-            errno = errflag;
-            debugs(79, DBG_IMPORTANT, "storeCossReadDone: error: " << xstrerror());
-        } else {
-            debugs(79, DBG_IMPORTANT, "storeCossReadDone: got failure (" << errflag << ")");
-        }
-
-        rlen = -1;
-    } else {
-        ++ StoreFScoss::GetInstance().stats.read.success;
-
-        if (cstate->readbuffer == NULL) {
-            cstate->readbuffer = (char *)xmalloc(cstate->st_size);
-            p = storeCossMemPointerFromDiskOffset(storeCossFilenoToDiskOffset(sio->swap_filen),
-                                                  NULL);
-            memcpy(cstate->readbuffer, p, cstate->st_size);
-        }
-
-        sio->offset_ += len;
-        memcpy(cstate->requestbuf, &cstate->readbuffer[cstate->requestoffset],
-               cstate->requestlen);
-        rlen = (size_t) cstate->requestlen;
-    }
-
-    assert(callback);
-    sio->read.callback = NULL;
-
-    if (cbdataReferenceValidDone(sio->read.callback_data, &cbdata))
-        callback(cbdata, cstate->requestbuf, rlen, sio);
-}
-
-void
-CossSwapDir::writeCompleted(int errflag, size_t len, RefCount<WriteRequest> writeRequest)
-{
-    CossWrite* cossWrite= dynamic_cast<CossWrite *>(writeRequest.getRaw());
-    assert (cossWrite);
-
-    debugs(79, 3, "storeCossWriteMemBufDone: buf " << cossWrite->membuf << ", len " << len);
-
-    if (errflag) {
-        ++ StoreFScoss::GetInstance().stats.stripe_write.fail;
-        debugs(79, DBG_IMPORTANT, "storeCossWriteMemBufDone: got failure (" << errflag << ")");
-        debugs(79, DBG_IMPORTANT, "size=" << cossWrite->membuf->diskend - cossWrite->membuf->diskstart);
-    } else {
-        ++ StoreFScoss::GetInstance().stats.stripe_write.success;
-    }
-
-    dlinkDelete(&cossWrite->membuf->node, &membufs);
-    cbdataFree(cossWrite->membuf);
-    -- StoreFScoss::GetInstance().stats.stripes;
-}
-
-void
-CossSwapDir::changeIO(DiskIOModule *module)
-{
-    DiskIOStrategy *anIO = module->createStrategy();
-    safe_free(ioModule);
-    ioModule = xstrdup(module->type());
-
-    delete io;
-    io = anIO;
-    /* Change the IO Options */
-
-    if (currentIOOptions == NULL)
-        currentIOOptions = new ConfigOptionVector();
-
-    if (currentIOOptions->options.size() > 3)
-        delete currentIOOptions->options.pop_back();
-
-    /* TODO: factor out these 4 lines */
-    ConfigOption *ioOptions = NULL;
-
-    if (io)
-        ioOptions = io->getOptionTree();
-
-    if (ioOptions)
-        currentIOOptions->options.push_back(ioOptions);
-}
-
-bool
-CossSwapDir::optionIOParse(char const *option, const char *value, int reconfiguring)
-{
-    if (strcmp(option, "IOEngine") != 0)
-        return false;
-
-    if (reconfiguring)
-        /* silently ignore this */
-        return true;
-
-    if (!value)
-        self_destruct();
-
-    DiskIOModule *module = DiskIOModule::Find(value);
-
-    if (!module)
-        self_destruct();
-
-    changeIO(module);
-
-    return true;
-}
-
-void
-CossSwapDir::optionIODump(StoreEntry * e) const
-{
-    storeAppendPrintf(e, " IOEngine=%s", ioModule);
-}
-
-ConfigOption *
-CossSwapDir::getOptionTree() const
-{
-    ConfigOption *parentResult = SwapDir::getOptionTree();
-
-    if (currentIOOptions == NULL)
-        currentIOOptions = new ConfigOptionVector();
-
-    currentIOOptions->options.push_back(parentResult);
-
-    currentIOOptions->options.push_back(new ConfigOptionAdapter<CossSwapDir>(*const_cast<CossSwapDir *>(this), &CossSwapDir::optionIOParse, &CossSwapDir::optionIODump));
-
-    currentIOOptions->options.push_back(
-        new ConfigOptionAdapter<CossSwapDir>(*const_cast<CossSwapDir *>(this),
-                                             &CossSwapDir::optionBlockSizeParse,
-                                             &CossSwapDir::optionBlockSizeDump));
-
-    ConfigOption *ioOptions = NULL;
-
-    if (io)
-        ioOptions = io->getOptionTree();
-
-    if (ioOptions)
-        currentIOOptions->options.push_back(ioOptions);
-
-    ConfigOption* result = currentIOOptions;
-
-    currentIOOptions = NULL;
-
-    return result;
-}
-
-void
-CossSwapDir::init()
-{
-    /* FIXME: SwapDirs aren't refcounted. We call IORequestor calls, which
-     * are refcounted. SO, we up our count once to avoid implicit delete's.
-     */
-    RefCountReference();
-    io->init();
-    openLog();
-    storeCossDirRebuild(this);
-    theFile = io->newFile(stripePath());
-    theFile->open(O_RDWR | O_CREAT, 0644, this);
-
-    ++n_coss_dirs;
-    /*
-     * fs.blksize is normally determined by calling statvfs() etc,
-     * but we just set it here.  It is used in accounting the
-     * total store size, and is reported in cachemgr 'storedir'
-     * page.
-     */
-    fs.blksize = 1 << blksz_bits;
-}
-
-void
-storeCossRemove(CossSwapDir * sd, StoreEntry * e)
-{
-    CossIndexNode *coss_node = (CossIndexNode *)e->repl.data;
-    e->repl.data = NULL;
-    dlinkDelete(&coss_node->node, &sd->cossindex);
-    coss_index_pool->freeOne(coss_node);
-    sd->count -= 1;
-}
-
-void
-storeCossAdd(CossSwapDir * sd, StoreEntry * e)
-{
-    CossIndexNode *coss_node = (CossIndexNode *)coss_index_pool->alloc();
-    assert(!e->repl.data);
-    e->repl.data = coss_node;
-    dlinkAdd(e, &coss_node->node, &sd->cossindex);
-    sd->count += 1;
-}
-
-static void
-storeCossRebuildComplete(void *data)
-{
-    RebuildState *rb = (RebuildState *)data;
-    CossSwapDir *sd = rb->sd;
-    sd->startMembuf();
-    -- StoreController::store_dirs_rebuilding;
-    storeCossDirCloseTmpSwapLog(rb->sd);
-    storeRebuildComplete(&rb->counts);
-    cbdataFree(rb);
-}
-
-static void
-storeCossRebuildFromSwapLog(void *data)
-{
-    RebuildState *rb = (RebuildState *)data;
-    StoreEntry *e = NULL;
-    StoreSwapLogData s;
-    size_t ss = sizeof(StoreSwapLogData);
-    double x;
-    assert(rb != NULL);
-    /* load a number of objects per invocation */
-
-    for (int aCount = 0; aCount < rb->speed; ++aCount) {
-        if (fread(&s, ss, 1, rb->log) != 1) {
-            debugs(47, DBG_IMPORTANT, "Done reading " << rb->sd->path << " swaplog (" << rb->n_read << " entries)");
-            fclose(rb->log);
-            rb->log = NULL;
-            storeCossRebuildComplete(rb);
-            return;
-        }
-
-        ++ rb->n_read;
-
-        if (s.op <= SWAP_LOG_NOP)
-            continue;
-
-        if (s.op >= SWAP_LOG_MAX)
-            continue;
-
-        debugs(47, 3, "storeCossRebuildFromSwapLog: " <<
-               swap_log_op_str[(int) s.op]  << " " << storeKeyText(s.key)  <<
-               " "<< std::setfill('0') << std::hex << std::uppercase <<
-               std::setw(8) << s.swap_filen);
-
-        if (s.op == SWAP_LOG_ADD) {
-            (void) 0;
-        } else if (s.op == SWAP_LOG_DEL) {
-            /* Delete unless we already have a newer copy */
-
-            if ((e = rb->sd->get
-                     (s.key)) != NULL && s.lastref > e->lastref) {
-                /*
-                 * Make sure we don't unlink the file, it might be
-                 * in use by a subsequent entry.  Also note that
-                 * we don't have to subtract from cur_size because
-                 * adding to cur_size happens in the cleanup procedure.
-                 */
-                e->expireNow();
-                e->releaseRequest();
-
-                if (e->swap_filen > -1) {
-                    e->swap_filen = -1;
-                }
-
-                e->release();
-                /* Fake an unlink here, this is a bad hack :( */
-                storeCossRemove(rb->sd, e);
-                -- rb->counts.objcount;
-                ++ rb->counts.cancelcount;
-            }
-            continue;
-        } else {
-            x = log(static_cast<double>(++rb->counts.bad_log_op)) / log(10.0);
-
-            if (0.0 == x - (double)
-                    (int) x)
-                debugs(47, DBG_IMPORTANT, "WARNING: " << rb->counts.bad_log_op << " invalid swap log entries found");
-
-            ++ rb->counts.invalid;
-
-            continue;
-        }
-
-        if ((++rb->counts.scancount & 0xFFF) == 0) {
-
-            struct stat sb;
-
-            if (0 == fstat(fileno(rb->log), &sb))
-                storeRebuildProgress(rb->sd->index,
-                                     (int) sb.st_size / ss, rb->n_read);
-        }
-
-        if (EBIT_TEST(s.flags, KEY_PRIVATE)) {
-            ++ rb->counts.badflags;
-            continue;
-        }
-
-        e = rb->sd->get
-            (s.key);
-
-        if (e) {
-            /* key already exists, current entry is newer */
-            /* keep old, ignore new */
-            ++ rb->counts.dupcount;
-            continue;
-        }
-
-        ++ rb->counts.objcount;
-
-        e = rb->sd->addDiskRestore(s.key,
-                                   s.swap_filen,
-                                   s.swap_file_sz,
-                                   s.expires,
-                                   s.timestamp,
-                                   s.lastref,
-                                   s.lastmod,
-                                   s.refcount,
-                                   s.flags,
-                                   (int) rb->flags.clean);
-
-        storeDirSwapLog(e, SWAP_LOG_ADD);
-    }
-
-    eventAdd("storeCossRebuild", storeCossRebuildFromSwapLog, rb, 0.0, 1);
-}
-
-/* Add a new object to the cache with empty memory copy and pointer to disk
- * use to rebuild store from disk. */
-StoreEntry *
-CossSwapDir::addDiskRestore(const cache_key *const key,
-                            int file_number,
-                            uint64_t swap_file_sz,
-                            time_t expires,
-                            time_t timestamp,
-                            time_t lastref,
-                            time_t lastmod,
-                            uint32_t refcount,
-                            uint16_t flags,
-                            int clean)
-{
-    StoreEntry *e = NULL;
-    debugs(47, 5, "storeCossAddDiskRestore: " << storeKeyText(key)  <<
-           ", fileno="<< std::setfill('0') << std::hex << std::uppercase <<
-           std::setw(8) << file_number);
-
-    /* if you call this you'd better be sure file_number is not
-     * already in use! */
-    e = new StoreEntry();
-    e->store_status = STORE_OK;
-    e->swap_dirn = index;
-    e->setMemStatus(NOT_IN_MEMORY);
-    e->swap_status = SWAPOUT_DONE;
-    e->swap_filen = file_number;
-    e->swap_file_sz = swap_file_sz;
-    e->lock_count = 0;
-    e->lastref = lastref;
-    e->timestamp = timestamp;
-    e->expires = expires;
-    e->lastmod = lastmod;
-    e->refcount = refcount;
-    e->flags = flags;
-    EBIT_SET(e->flags, ENTRY_CACHABLE);
-    EBIT_CLR(e->flags, RELEASE_REQUEST);
-    EBIT_CLR(e->flags, KEY_PRIVATE);
-    e->ping_status = PING_NONE;
-    EBIT_CLR(e->flags, ENTRY_VALIDATED);
-    cur_size += fs.blksize * sizeInBlocks(e->swap_file_sz);
-    ++n_disk_objects;
-    e->hashInsert(key);	/* do it after we clear KEY_PRIVATE */
-    storeCossAdd(this, e);
-    assert(e->swap_filen >= 0);
-    return e;
-}
-
-CBDATA_TYPE(RebuildState);
-static void
-storeCossDirRebuild(CossSwapDir * sd)
-{
-    RebuildState *rb;
-    int clean = 0;
-    int zero = 0;
-    FILE *fp;
-    CBDATA_INIT_TYPE(RebuildState);
-    rb = cbdataAlloc(RebuildState);
-    rb->sd = sd;
-    rb->speed = opt_foreground_rebuild ? 1 << 30 : 50;
-    rb->flags.clean = (unsigned int) clean;
-    /*
-     * If the swap.state file exists in the cache_dir, then
-     * we'll use storeCossRebuildFromSwapLog().
-     */
-    fp = storeCossDirOpenTmpSwapLog(sd, &clean, &zero);
-    debugs(47, DBG_IMPORTANT, "Rebuilding COSS storage in " << sd->path << " (" << (clean ? "CLEAN" : "DIRTY") << ")");
-    rb->log = fp;
-    ++ StoreController::store_dirs_rebuilding;
-
-    if (!clean || fp == NULL) {
-        /* COSS cannot yet rebuild from a dirty state. If the log
-         * is dirty then the COSS contents is thrown away.
-         * Why? I guess it is because some contents will be lost,
-         * and COSS cannot verify this..
-         */
-
-        if (fp != NULL)
-            fclose(fp);
-
-        /*
-         * XXX Make sure we don't trigger an assertion if this is the first
-         * storedir, since if we are, this call will cause storeRebuildComplete
-         * to prematurely complete the rebuild process, and then some other
-         * storedir will try to rebuild and eventually die.
-         */
-        eventAdd("storeCossRebuildComplete", storeCossRebuildComplete, rb, 0.0, 0);
-
-        return;
-    }
-
-    eventAdd("storeCossRebuild", storeCossRebuildFromSwapLog, rb, 0.0, 1);
-}
-
-static void
-storeCossDirCloseTmpSwapLog(CossSwapDir * sd)
-{
-    char *swaplog_path = xstrdup(storeCossDirSwapLogFile(sd, NULL));
-    char *new_path = xstrdup(storeCossDirSwapLogFile(sd, ".new"));
-    int anfd;
-    file_close(sd->swaplog_fd);
-
-    if (xrename(new_path, swaplog_path) < 0) {
-        fatal("storeCossDirCloseTmpSwapLog: rename failed");
-    }
-
-    anfd = file_open(swaplog_path, O_WRONLY | O_CREAT | O_BINARY);
-
-    if (anfd < 0) {
-        debugs(50, DBG_IMPORTANT, "" << swaplog_path << ": " << xstrerror());
-        fatal("storeCossDirCloseTmpSwapLog: Failed to open swap log.");
-    }
-
-    safe_free(swaplog_path);
-    safe_free(new_path);
-    sd->swaplog_fd = anfd;
-    debugs(47, 3, "Cache COSS Dir #" << sd->index << " log opened on FD " << anfd);
-}
-
-static FILE *
-storeCossDirOpenTmpSwapLog(CossSwapDir * sd, int *clean_flag, int *zero_flag)
-{
-    char *swaplog_path = xstrdup(storeCossDirSwapLogFile(sd, NULL));
-    char *clean_path = xstrdup(storeCossDirSwapLogFile(sd, ".last-clean"));
-    char *new_path = xstrdup(storeCossDirSwapLogFile(sd, ".new"));
-
-    struct stat log_sb;
-
-    struct stat clean_sb;
-    FILE *fp;
-    int anfd;
-
-    if (::stat(swaplog_path, &log_sb) < 0) {
-        debugs(50, DBG_IMPORTANT, "Cache COSS Dir #" << sd->index << ": No log file");
-        safe_free(swaplog_path);
-        safe_free(clean_path);
-        safe_free(new_path);
-        return NULL;
-    }
-
-    *zero_flag = log_sb.st_size == 0 ? 1 : 0;
-    /* close the existing write-only FD */
-
-    if (sd->swaplog_fd >= 0)
-        file_close(sd->swaplog_fd);
-
-    /* open a write-only FD for the new log */
-    anfd = file_open(new_path, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY);
-
-    if (anfd < 0) {
-        debugs(50, DBG_IMPORTANT, "" << new_path << ": " << xstrerror());
-        fatal("storeDirOpenTmpSwapLog: Failed to open swap log.");
-    }
-
-    sd->swaplog_fd = anfd;
-    /* open a read-only stream of the old log */
-    fp = fopen(swaplog_path, "rb");
-
-    if (fp == NULL) {
-        debugs(50, DBG_CRITICAL, "" << swaplog_path << ": " << xstrerror());
-        fatal("Failed to open swap log for reading");
-    }
-
-    memset(&clean_sb, '\0', sizeof(struct stat));
-
-    if (::stat(clean_path, &clean_sb) < 0)
-        *clean_flag = 0;
-    else if (clean_sb.st_mtime < log_sb.st_mtime)
-        *clean_flag = 0;
-    else
-        *clean_flag = 1;
-
-    safeunlink(clean_path, 1);
-
-    safe_free(swaplog_path);
-
-    safe_free(clean_path);
-
-    safe_free(new_path);
-
-    return fp;
-}
-
-class CossCleanLog : public SwapDir::CleanLog
-{
-
-public:
-    CossCleanLog(CossSwapDir *);
-    virtual const StoreEntry *nextEntry();
-    virtual void write(StoreEntry const &);
-    char *cur;
-    char *newLog;
-    char *cln;
-    char *outbuf;
-    off_t outbuf_offset;
-    int fd;
-    dlink_node *current;
-    CossSwapDir *sd;
-};
-
-#define CLEAN_BUF_SZ 16384
-
-CossCleanLog::CossCleanLog(CossSwapDir *aSwapDir) : cur(NULL),newLog(NULL),cln(NULL),outbuf(NULL),
-        outbuf_offset(0), fd(-1),current(NULL), sd(aSwapDir)
-{}
-
-/*
- * Begin the process to write clean cache state.  For COSS this means
- * opening some log files and allocating write buffers.  Return 0 if
- * we succeed, and assign the 'func' and 'data' return pointers.
- */
-int
-CossSwapDir::writeCleanStart()
-{
-    CossCleanLog *state = new CossCleanLog(this);
-#if HAVE_FCHMOD
-
-    struct stat sb;
-#endif
-
-    state->newLog = xstrdup(storeCossDirSwapLogFile(this, ".clean"));
-    state->fd = file_open(state->newLog, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY);
-    cleanLog = NULL;
-
-    if (state->fd < 0) {
-        xfree(state->newLog);
-        delete state;
-        return -1;
-    }
-
-    state->cur = xstrdup(storeCossDirSwapLogFile(this, NULL));
-    state->cln = xstrdup(storeCossDirSwapLogFile(this, ".last-clean"));
-    state->outbuf = (char *)xcalloc(CLEAN_BUF_SZ, 1);
-    state->outbuf_offset = 0;
-    ::unlink(state->cln);
-    state->current = cossindex.tail;
-    debugs(50, 3, "storeCOssDirWriteCleanLogs: opened " << state->newLog << ", FD " << state->fd);
-#if HAVE_FCHMOD
-
-    if (::stat(state->cur, &sb) == 0)
-        fchmod(state->fd, sb.st_mode);
-
-#endif
-
-    cleanLog = state;
-
-    return 0;
-}
-
-/* RBC 20050101 - I think there is a race condition here,
- * *current can be freed as its not ref counted, if/when
- * the store overruns the log writer
- */
-const StoreEntry *
-CossCleanLog::nextEntry()
-{
-    const StoreEntry *entry;
-
-    if (!current)
-        return NULL;
-
-    entry = (const StoreEntry *) current->data;
-
-    current = current->prev;
-
-    return entry;
-}
-
-/*
- * "write" an entry to the clean log file.
- */
-void
-CossCleanLog::write(StoreEntry const &e)
-{
-    CossCleanLog *state = this;
-    StoreSwapLogData s;
-    static size_t ss = sizeof(StoreSwapLogData);
-    s.op = (char) SWAP_LOG_ADD;
-    s.swap_filen = e.swap_filen;
-    s.timestamp = e.timestamp;
-    s.lastref = e.lastref;
-    s.expires = e.expires;
-    s.lastmod = e.lastmod;
-    s.swap_file_sz = e.swap_file_sz;
-    s.refcount = e.refcount;
-    s.flags = e.flags;
-    memcpy(&s.key, e.key, SQUID_MD5_DIGEST_LENGTH);
-    memcpy(outbuf + outbuf_offset, &s, ss);
-    outbuf_offset += ss;
-    /* buffered write */
-
-    if (outbuf_offset + ss > CLEAN_BUF_SZ) {
-        if (FD_WRITE_METHOD(fd, outbuf, outbuf_offset) < 0) {
-            debugs(50, DBG_CRITICAL, "storeCossDirWriteCleanLogs: " << newLog << ": write: " << xstrerror());
-            debugs(50, DBG_CRITICAL, "storeCossDirWriteCleanLogs: Current swap logfile not replaced.");
-            file_close(fd);
-            fd = -1;
-            unlink(newLog);
-            sd->cleanLog = NULL;
-            delete state;
-            return;
-        }
-
-        outbuf_offset = 0;
-    }
-}
-
-void
-CossSwapDir::writeCleanDone()
-{
-    CossCleanLog *state = (CossCleanLog *)cleanLog;
-
-    if (NULL == state)
-        return;
-
-    if (state->fd < 0)
-        return;
-
-    if (FD_WRITE_METHOD(state->fd, state->outbuf, state->outbuf_offset) < 0) {
-        debugs(50, DBG_CRITICAL, "storeCossDirWriteCleanLogs: " << state->newLog << ": write: " << xstrerror());
-        debugs(50, DBG_CRITICAL, "storeCossDirWriteCleanLogs: Current swap logfile not replaced.");
-        file_close(state->fd);
-        state->fd = -1;
-        ::unlink(state->newLog);
-    }
-
-    safe_free(state->outbuf);
-    /*
-     * You can't rename open files on Microsoft "operating systems"
-     * so we have to close before renaming.
-     */
-    closeLog();
-    /* save the fd value for a later test */
-    int anfd = state->fd;
-    /* rename */
-
-    if (state->fd >= 0) {
-#if _SQUID_OS2_ || _SQUID_WINDOWS_
-        file_close(state->fd);
-        state->fd = -1;
-#endif
-
-        xrename(state->newLog, state->cur);
-    }
-
-    /* touch a timestamp file if we're not still validating */
-    if (StoreController::store_dirs_rebuilding)
-        (void) 0;
-    else if (anfd < 0)
-        (void) 0;
-    else
-        file_close(file_open(state->cln, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY));
-
-    /* close */
-    safe_free(state->cur);
-
-    safe_free(state->newLog);
-
-    safe_free(state->cln);
-
-    if (state->fd >= 0)
-        file_close(state->fd);
-
-    state->fd = -1;
-
-    delete state;
-
-    cleanLog = NULL;
-}
-
-static void
-FreeObject(void *address)
-{
-    StoreSwapLogData *anObject = static_cast <StoreSwapLogData *>(address);
-    delete anObject;
-}
-
-void
-CossSwapDir::logEntry(const StoreEntry & e, int op) const
-{
-    StoreSwapLogData *s = new StoreSwapLogData;
-    s->op = (char) op;
-    s->swap_filen = e.swap_filen;
-    s->timestamp = e.timestamp;
-    s->lastref = e.lastref;
-    s->expires = e.expires;
-    s->lastmod = e.lastmod;
-    s->swap_file_sz = e.swap_file_sz;
-    s->refcount = e.refcount;
-    s->flags = e.flags;
-    memcpy(s->key, e.key, SQUID_MD5_DIGEST_LENGTH);
-    file_write(swaplog_fd,
-               -1,
-               s,
-               sizeof(StoreSwapLogData),
-               NULL,
-               NULL,
-               &FreeObject);
-}
-
-void
-CossSwapDir::create()
-{
-    debugs (47, 3, "Creating swap space in " << path);
-
-    struct stat swap_sb;
-    int swap;
-
-    if (::stat(path, &swap_sb) < 0) {
-        debugs (47, 2, "COSS swap space space being allocated.");
-        mkdir(path, 0700);
-    }
-
-    /* should check here for directories instead of files, and for file size
-     * TODO - if nothing changes, there is nothing to do
-     */
-    swap = open(stripePath(), O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0600);
-
-    /* TODO just set the file size */
-    char block[1024];
-    Must(maxSize() % sizeof(block) == 0);
-    memset(block, '\0', sizeof(block));
-
-    for (uint64_t offset = 0; offset < maxSize(); offset += sizeof(block)) {
-        if (write (swap, block, sizeof(block)) != sizeof(block)) {
-            debugs (47, 0, "Failed to create COSS swap space in " << path);
-        }
-    }
-
-    close (swap);
-
-}
-
-/* we are shutting down, flush all membufs to disk */
-CossSwapDir::~CossSwapDir()
-{
-    io->sync();
-
-    if (theFile != NULL)
-        theFile->close();
-
-    delete io;
-
-    closeLog();
-
-    --n_coss_dirs;
-
-    safe_free(ioModule);
-
-    safe_free(stripe_path);
-}
-
-bool
-CossSwapDir::canStore(const StoreEntry &e, int64_t diskSpaceNeeded, int &load) const
-{
-    if (!SwapDir::canStore(e, diskSpaceNeeded, load))
-        return false;
-
-    load = io->load();
-    return true;
-}
-
-/*
- * storeCossDirCallback - do the IO completions
- */
-int
-CossSwapDir::callback()
-{
-    return io->callback();
-}
-
-/* ========== LOCAL FUNCTIONS ABOVE, GLOBAL FUNCTIONS BELOW ========== */
-
-void
-CossSwapDir::statfs(StoreEntry & sentry) const
-{
-    storeAppendPrintf(&sentry, "\n");
-    storeAppendPrintf(&sentry, "Maximum Size: %" PRIu64 " KB\n", maxSize() >> 10);
-    storeAppendPrintf(&sentry, "Current Size: %.2f KB\n", currentSize() / 1024.0);
-    storeAppendPrintf(&sentry, "Percent Used: %0.2f%%\n",
-                      Math::doublePercent(currentSize(), maxSize()) );
-    storeAppendPrintf(&sentry, "Number of object collisions: %d\n", (int) numcollisions);
-#if 0
-    /* is this applicable? I Hope not .. */
-    storeAppendPrintf(sentry, "Filemap bits in use: %d of %d (%d%%)\n",
-                      SD->map->numFilesInMap(), SD->map->capacity(),
-                      Math::intPercent(SD->map->numFilesInMap(), SD->map->capacity()));
-#endif
-
-    //    storeAppendPrintf(&sentry, "Pending operations: %d out of %d\n", io->aq.aq_numpending, MAX_ASYNCOP);
-    storeAppendPrintf(&sentry, "Flags:");
-
-    if (flags.selected)
-        storeAppendPrintf(&sentry, " SELECTED");
-
-    if (flags.read_only)
-        storeAppendPrintf(&sentry, " READ-ONLY");
-
-    storeAppendPrintf(&sentry, "\n");
-}
-
-void
-CossSwapDir::parse(int anIndex, char *aPath)
-{
-    const int i = GetInteger();
-    if (i <= 0)
-        fatal("storeCossDirParse: invalid size value");
-
-    index = anIndex;
-
-    path = xstrdup(aPath);
-
-    max_size = static_cast<uint64_t>(i) << 20; // MBytes to Bytes
-
-    parseOptions(0);
-
-    if (NULL == io)
-        changeIO(DiskIOModule::FindDefault());
-
-    /* Enforce maxobjsize being set to something */
-    if (max_objsize == -1)
-        fatal("COSS requires max-size to be set to something other than -1!\n");
-
-    if (max_objsize > COSS_MEMBUF_SZ)
-        fatalf("COSS max-size option must be less than COSS_MEMBUF_SZ (%d)\n",
-               COSS_MEMBUF_SZ);
-
-    // check that we won't overflow sfileno later.
-    const uint64_t max_offset = (uint64_t)SwapFilenMax << blksz_bits;
-
-    if (maxSize() > max_offset) {
-        debugs(47, DBG_CRITICAL, "COSS block-size = " << (1<<blksz_bits) << " bytes");
-        debugs(47, DBG_CRITICAL, "COSS largest file offset = " << (max_offset >> 10) << " KB");
-        debugs(47, DBG_CRITICAL, "COSS cache_dir size = " << (maxSize() >> 10) << " KB");
-        fatal("COSS cache_dir size exceeds largest offset\n");
-    }
-}
-
-void
-CossSwapDir::reconfigure()
-{
-    const int i = GetInteger();
-    if (i <= 0)
-        fatal("storeCossDirParse: invalid size value");
-
-    const uint64_t size = static_cast<uint64_t>(i) << 20; // MBytes to Bytes
-
-    if (size == maxSize())
-        debugs(3, DBG_IMPORTANT, "Cache COSS dir '" << path << "' size remains unchanged at " << i << " MB");
-    else {
-        debugs(3, DBG_IMPORTANT, "Cache COSS dir '" << path << "' size changed to " << i << " MB");
-        max_size = size;
-    }
-
-    /* Enforce maxobjsize being set to something */
-    if (max_objsize == -1)
-        fatal("COSS requires max-size to be set to something other than -1!\n");
-}
-
-void
-CossSwapDir::swappedOut(const StoreEntry &e)
-{
-    cur_size += fs.blksize * sizeInBlocks(e.swap_file_sz);
-    ++n_disk_objects;
-}
-
-void
-CossSwapDir::dump(StoreEntry &entry)const
-{
-    storeAppendPrintf(&entry, " %" PRIu64, maxSize() >> 20);
-    dumpOptions(&entry);
-}
-
-CossSwapDir::CossSwapDir() : SwapDir ("coss"), swaplog_fd(-1), count(0), current_membuf (NULL), current_offset(0), numcollisions(0),  blksz_bits(0), io (NULL), ioModule(NULL), currentIOOptions(new ConfigOptionVector()), stripe_path(NULL), cur_size(0), n_disk_objects(0)
-{
-    membufs.head = NULL;
-    membufs.tail = NULL;
-    cossindex.head = NULL;
-    cossindex.tail = NULL;
-    blksz_mask = (1 << blksz_bits) - 1;
-    repl = NULL;
-}
-
-bool
-CossSwapDir::optionBlockSizeParse(const char *option, const char *value, int reconfiguring)
-{
-    assert(option);
-
-    if (strcmp(option, "block-size") != 0)
-        return false;
-
-    if (!value)
-        self_destruct();
-
-    int blksz = atoi(value);
-
-    if (blksz == (1 << blksz_bits))
-        /* no change */
-        return true;
-
-    if (reconfiguring) {
-        debugs(47, DBG_CRITICAL, "WARNING: cannot change COSS block-size while Squid is running");
-        return false;
-    }
-
-    int nbits = 0;
-    int check = blksz;
-
-    while (check > 1) {
-        ++nbits;
-        check >>= 1;
-    }
-
-    check = 1 << nbits;
-
-    if (check != blksz)
-        fatal("COSS block-size must be a power of 2\n");
-
-    if (nbits > 13)
-        fatal("COSS block-size must be 8192 or smaller\n");
-
-    blksz_bits = nbits;
-
-    blksz_mask = (1 << blksz_bits) - 1;
-
-    return true;
-}
-
-void
-CossSwapDir::optionBlockSizeDump(StoreEntry * e) const
-{
-    storeAppendPrintf(e, " block-size=%d", 1 << blksz_bits);
-}
-
-StoreSearch *
-CossSwapDir::search(String const url, HttpRequest *)
-{
-    if (url.size())
-        fatal ("Cannot search by url yet\n");
-
-    return new StoreSearchCoss (this);
-}
-
-char const *
-CossSwapDir::stripePath() const
-{
-    if (!stripe_path) {
-        String result = path;
-        result.append("/stripe");
-        const_cast<CossSwapDir *>(this)->stripe_path = xstrdup(result.termedBuf());
-    }
-
-    return stripe_path;
-}
-
-CBDATA_CLASS_INIT(StoreSearchCoss);
-StoreSearchCoss::StoreSearchCoss(RefCount<CossSwapDir> aSwapDir) : sd(aSwapDir), callback (NULL), cbdata(NULL),  _done (false), current(NULL), next_(sd->cossindex.tail)
-{
-    /* TODO: this races with the store as does the cleanlog stuff.
-     * FIXME by making coss_nodes ref counted */
-}
-
-/* do not link
-StoreSearchCoss::StoreSearchCoss(StoreSearchCoss const &);
-*/
-
-StoreSearchCoss::~StoreSearchCoss()
-{}
-
-void
-StoreSearchCoss::next(void (callback)(void *cbdata), void *cbdata)
-{
-    next();
-    callback (cbdata);
-}
-
-bool
-StoreSearchCoss::next()
-{
-    current = next_;
-
-    if (next_)
-        next_ = next_->prev;
-
-    if (!current)
-        _done = true;
-
-    return current != NULL;
-}
-
-bool
-StoreSearchCoss::error() const
-{
-    return false;
-}
-
-bool
-StoreSearchCoss::isDone() const
-{
-    return _done;
-}
-
-StoreEntry *
-StoreSearchCoss::currentItem()
-{
-    if (!current)
-        return NULL;
-
-    return static_cast<StoreEntry *>( current->data );
-}
@@ -1,605 +0,0 @@
-
-/*
- * DEBUG: section 79    Storage Manager COSS Interface
- * AUTHOR: Eric Stern
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- */
-
-#include "squid.h"
-#include "CossSwapDir.h"
-#include "DiskIO/DiskIOStrategy.h"
-#include "fde.h"
-#include "MemObject.h"
-#include "SquidConfig.h"
-#include "store_coss.h"
-#include "Store.h"
-#include "StoreFScoss.h"
-#include "SwapDir.h"
-
-CBDATA_TYPE(CossMemBuf);
-
-/* === PUBLIC =========================================================== */
-
-CossState::CossState(CossSwapDir *aCSD):SD (aCSD)
-{}
-
-/*
- * This routine sucks. I want to rewrite it when possible, and I also think
- * that we should check after creatmembuf() to see if the object has a
- * RELEASE_REQUEST set on it (thanks Eric!) rather than this way which seems
- * to work..
- * -- Adrian
- */
-sfileno
-CossSwapDir::allocate(const StoreEntry * e, int which)
-{
-    CossMemBuf *newmb;
-    off_t retofs;
-    off_t allocsize;
-    int coll = 0;
-    sfileno checkf;
-
-    /* Make sure we chcek collisions if reallocating */
-
-    if (which == COSS_ALLOC_REALLOC) {
-        checkf = e->swap_filen;
-        ++ StoreFScoss::GetInstance().stats.alloc.realloc;
-    } else {
-        checkf = -1;
-        ++ StoreFScoss::GetInstance().stats.alloc.alloc;
-    }
-
-    if (e->swap_file_sz > 0)
-        allocsize = e->swap_file_sz;
-    else
-        allocsize = e->objectLen() + e->mem_obj->swap_hdr_sz;
-
-    /* Check if we have overflowed the disk .. */
-    if (current_offset + allocsize > static_cast<int64_t>(maxSize())) {
-        /*
-         * tried to allocate past the end of the disk, so wrap
-         * back to the beginning
-         */
-        ++ StoreFScoss::GetInstance().stats.disk_overflows;
-        current_membuf->flags.full = true;
-        current_membuf->diskend = current_offset;
-        current_membuf->maybeWrite(this);
-        current_offset = 0;	/* wrap back to beginning */
-        debugs(79, 2, "CossSwapDir::allocate: wrap to 0");
-
-        newmb = createMemBuf(0, checkf, &coll);
-        current_membuf = newmb;
-
-        /* Check if we have overflowed the MemBuf */
-    } else if ((current_offset + allocsize) >= current_membuf->diskend) {
-        /*
-         * Skip the blank space at the end of the stripe. start over.
-         */
-        ++ StoreFScoss::GetInstance().stats.stripe_overflows;
-        current_membuf->flags.full = true;
-        current_offset = current_membuf->diskend;
-        current_membuf->maybeWrite(this);
-        debugs(79, 2, "CossSwapDir::allocate: New offset - " << current_offset);
-        newmb = createMemBuf(current_offset, checkf, &coll);
-        current_membuf = newmb;
-    }
-
-    /*
-     * If we didn't get a collision, then update the current offset
-     * and return it
-     */
-    if (coll == 0) {
-        retofs = current_offset;
-        current_offset = retofs + allocsize;
-        /* round up to our blocksize */
-        current_offset = ((current_offset + blksz_mask) >> blksz_bits ) << blksz_bits;
-        return storeCossDiskOffsetToFileno(retofs);
-    } else {
-        ++ StoreFScoss::GetInstance().stats.alloc.collisions;
-        debugs(79, 3, "CossSwapDir::allocate: Collision");
-        return -1;
-    }
-}
-
-bool
-CossSwapDir::unlinkdUseful() const
-{
-    // no entry-specific files to unlink
-    return false;
-}
-
-void
-CossSwapDir::unlink(StoreEntry & e)
-{
-    debugs(79, 3, "storeCossUnlink: offset " << e.swap_filen);
-    if (e.swap_status == SWAPOUT_DONE && EBIT_TEST(e.flags, ENTRY_VALIDATED)) {
-        cur_size -= fs.blksize * sizeInBlocks(e.swap_file_sz);
-        --n_disk_objects;
-    }
-    ++ StoreFScoss::GetInstance().stats.unlink.ops;
-    ++ StoreFScoss::GetInstance().stats.unlink.success;
-    storeCossRemove(this, &e);
-}
-
-StoreIOState::Pointer
-CossSwapDir::createStoreIO(StoreEntry &e, StoreIOState::STFNCB * file_callback, StoreIOState::STIOCB * callback, void *callback_data)
-{
-    CossState *cstate;
-    StoreIOState::Pointer sio = new CossState(this);
-    cstate = dynamic_cast<CossState *>(sio.getRaw());
-    sio->offset_ = 0;
-    sio->mode = O_WRONLY | O_BINARY;
-
-    /*
-     * If we get handed an object with a size of -1,
-     * the squid code is broken
-     */
-    assert(e.mem_obj->object_sz != -1);
-    ++ StoreFScoss::GetInstance().stats.create.ops;
-
-    /*
-     * this one is kinda strange - Eric called allocate(), then
-     * storeCossOpen(O_RDONLY) .. weird. Anyway, I'm allocating this now.
-     */
-    cstate->st_size = e.objectLen() + e.mem_obj->swap_hdr_sz;
-    sio->swap_dirn = index;
-    sio->swap_filen = allocate(&e, COSS_ALLOC_ALLOCATE);
-    debugs(79, 3, "storeCossCreate: offset " <<
-           storeCossFilenoToDiskOffset(sio->swap_filen) <<
-           ", size " << (long int) cstate->st_size << ", end " <<
-           (sio->swap_filen + cstate->st_size));
-
-    /* assume allocate() always succeeds */
-    assert(-1 != sio->swap_filen);
-
-    sio->callback = callback;
-    sio->file_callback = file_callback;
-    sio->callback_data = cbdataReference(callback_data);
-    sio->e = &e;
-
-    cstate->flags.writing = false;
-    cstate->flags.reading = false;
-    cstate->readbuffer = NULL;
-    cstate->reqdiskoffset = -1;
-
-    /* Now add it into the index list */
-    storeCossAdd(this, &e);
-
-    cstate->lockMemBuf();
-    ++ StoreFScoss::GetInstance().stats.create.success;
-    return sio;
-}
-
-StoreIOState::Pointer
-CossSwapDir::openStoreIO(StoreEntry & e, StoreIOState::STFNCB * file_callback,
-                         StoreIOState::STIOCB * callback, void *callback_data)
-{
-    char *p;
-    CossState *cstate;
-    sfileno f = e.swap_filen;
-
-    debugs(79, 3, "storeCossOpen: offset " << f);
-    ++ StoreFScoss::GetInstance().stats.open.ops;
-
-    StoreIOState::Pointer sio = new CossState (this);
-    cstate = dynamic_cast<CossState *>(sio.getRaw());
-
-    sio->swap_filen = f;
-    sio->swap_dirn = index;
-    sio->offset_ = 0;
-    sio->mode = O_RDONLY | O_BINARY;
-    sio->callback = callback;
-    sio->file_callback = file_callback;
-    sio->callback_data = cbdataReference(callback_data);
-    cstate->st_size = e.swap_file_sz;
-    sio->e = &e;
-
-    cstate->flags.writing = false;
-    cstate->flags.reading = false;
-    cstate->readbuffer = NULL;
-    cstate->reqdiskoffset = -1;
-    p = storeCossMemPointerFromDiskOffset(storeCossFilenoToDiskOffset(f), NULL);
-    /* make local copy so we don't have to lock membuf */
-
-    if (p) {
-        cstate->readbuffer = (char *)xmalloc(cstate->st_size);
-        memcpy(cstate->readbuffer, p, cstate->st_size);
-        ++ StoreFScoss::GetInstance().stats.open_mem_hits;
-    } else {
-        /* Do the allocation */
-        /* this is the first time we've been called on a new sio
-         * read the whole object into memory, then return the
-         * requested amount
-         */
-        ++ StoreFScoss::GetInstance().stats.open_mem_misses;
-        /*
-         * This bit of code actually does the LRU disk thing - we realloc
-         * a place for the object here, and the file_read() reads the object
-         * into the cossmembuf for later writing ..
-         */
-        cstate->reqdiskoffset = storeCossFilenoToDiskOffset(sio->swap_filen);
-        sio->swap_filen = -1;
-        sio->swap_filen = allocate(&e, COSS_ALLOC_REALLOC);
-
-        if (sio->swap_filen == -1) {
-            /* We have to clean up neatly .. */
-            ++ StoreFScoss::GetInstance().stats.open.fail;
-            ++numcollisions;
-            debugs(79, 2, "storeCossOpen: Reallocation of " << e.swap_dirn << "/" << e.swap_filen << " failed");
-            /* XXX XXX XXX Will squid call storeUnlink for this object? */
-            return NULL;
-        }
-
-        /* Notify the upper levels that we've changed file number */
-        sio->file_callback(sio->callback_data, 0, sio);
-
-        /*
-         * lock the buffer so it doesn't get swapped out on us
-         * this will get unlocked in storeCossClose
-         */
-        cstate->lockMemBuf();
-
-        /*
-         * Do the index magic to keep the disk and memory LRUs identical
-         */
-        storeCossRemove(this, &e);
-
-        storeCossAdd(this, &e);
-
-        /*
-        	 * NOTE cstate->readbuffer is NULL.  We'll actually read
-        	 * the disk data into the MemBuf in storeCossRead() and
-        	 * return that pointer back to the caller
-         	 */
-    }
-
-    ++ StoreFScoss::GetInstance().stats.open.success;
-    return sio;
-}
-
-/// COSS does not distinguish different closure types
-void
-CossState::close(int)
-{
-    debugs(79, 3, "storeCossClose: offset " << swap_filen);
-
-    ++ StoreFScoss::GetInstance().stats.close.ops;
-    ++ StoreFScoss::GetInstance().stats.close.success;
-    SD->storeCossMemBufUnlock(this);
-    doCallback(0);
-}
-
-void
-CossState::read_(char *buf, size_t size, off_t offset, STRCB * callback, void *callback_data)
-{
-    char *p;
-    CossSwapDir *SD = (CossSwapDir *)INDEXSD(swap_dirn);
-
-    ++ StoreFScoss::GetInstance().stats.read.ops;
-    assert(read.callback == NULL);
-    assert(read.callback_data == NULL);
-    read.callback = callback;
-    read.callback_data = cbdataReference(callback_data);
-    debugs(79, 3, "storeCossRead: offset " << offset);
-    offset_ = offset;
-    flags.reading = true;
-
-    if ((offset + (off_t)size) > st_size)
-        size = st_size - offset;
-
-    requestlen = size;
-
-    requestbuf = buf;
-
-    requestoffset = offset;
-
-    if (readbuffer == NULL) {
-        p = SD->storeCossMemPointerFromDiskOffset(SD->storeCossFilenoToDiskOffset(swap_filen), NULL);
-        sfileno tempReqdiskoffset = reqdiskoffset;
-        reqdiskoffset = 0;	/* XXX */
-        SD->theFile->read(new CossRead(ReadRequest(p, st_size, tempReqdiskoffset), this));
-    } else {
-        /*
-         * It was copied from memory in storeCossOpen()
-         */
-        ReadRequest::Pointer readRequest = new CossRead(ReadRequest(
-                    (char *)readbuffer,st_size, 0), this);
-        SD->readCompleted(readbuffer, st_size, 0, readRequest);
-    }
-}
-
-void
-CossState::write(char const *buf, size_t size, off_t offset, FREE * free_func)
-{
-    char *dest;
-    CossMemBuf *membuf;
-    off_t diskoffset;
-
-    /*
-     * If we get handed an object with a size of -1,
-     * the squid code is broken
-     */
-    assert(e->mem_obj->object_sz != -1);
-    ++ StoreFScoss::GetInstance().stats.write.ops;
-
-    debugs(79, 3, "storeCossWrite: offset " << offset_ << ", len " << (unsigned long int) size);
-    diskoffset = SD->storeCossFilenoToDiskOffset(swap_filen) + offset_;
-    CossSwapDir *SD = (CossSwapDir *)INDEXSD(swap_dirn);
-    dest = SD->storeCossMemPointerFromDiskOffset(diskoffset, &membuf);
-    assert(dest != NULL);
-    memcpy(dest, buf, size);
-    offset_ += size;
-
-    if (free_func)
-        (free_func) ((char *)buf);
-
-    ++ StoreFScoss::GetInstance().stats.write.success;
-}
-
-off_t
-CossSwapDir::storeCossFilenoToDiskOffset(sfileno f)
-{
-    return (off_t) f << blksz_bits;
-}
-
-sfileno
-CossSwapDir::storeCossDiskOffsetToFileno(off_t o)
-{
-    assert(0 == (o & blksz_mask));
-    return o >> blksz_bits;
-}
-
-CossMemBuf *
-CossSwapDir::storeCossFilenoToMembuf(sfileno f)
-{
-    CossMemBuf *t = NULL;
-    dlink_node *m;
-    off_t o = storeCossFilenoToDiskOffset(f);
-
-    for (m = membufs.head; m; m = m->next) {
-        t = (CossMemBuf *)m->data;
-
-        if ((o >= (off_t)t->diskstart) && (o < (off_t)t->diskend))
-            break;
-    }
-
-    assert(t);
-    return t;
-}
-
-/*  === STATIC =========================================================== */
-
-CBDATA_CLASS_INIT(CossRead);
-CBDATA_CLASS_INIT(CossWrite);
-
-void
-CossState::doCallback(int errflag)
-{
-    STIOCB *callback = this->callback;
-    void *cbdata;
-    debugs(79, 3, "CossState::doCallback: errflag=" << errflag);
-    assert(NULL == locked_membuf);
-    xfree(readbuffer);
-    this->callback = NULL;
-
-    if (cbdataReferenceValidDone(callback_data, &cbdata))
-        callback(cbdata, errflag, this);
-}
-
-char *
-CossSwapDir::storeCossMemPointerFromDiskOffset(off_t offset, CossMemBuf ** mb)
-{
-    CossMemBuf *t;
-    dlink_node *m;
-
-    for (m = membufs.head; m; m = m->next) {
-        t = (CossMemBuf *)m->data;
-
-        if ((offset >= t->diskstart) && (offset < t->diskend)) {
-            if (mb)
-                *mb = t;
-
-            return &t->buffer[offset - t->diskstart];
-        }
-    }
-
-    if (mb)
-        *mb = NULL;
-
-    return NULL;
-}
-
-void
-CossState::lockMemBuf()
-{
-    CossMemBuf *t = SD->storeCossFilenoToMembuf(swap_filen);
-    debugs(79, 3, "CossState::lockMemBuf: locking " << t << ", lockcount " << t->lockcount);
-    locked_membuf = t;
-    ++t->lockcount;
-}
-
-void
-CossSwapDir::storeCossMemBufUnlock(StoreIOState::Pointer sio)
-{
-    CossMemBuf *t = storeCossFilenoToMembuf(sio->swap_filen);
-    CossState *cstate = dynamic_cast<CossState *>(sio.getRaw());
-
-    if (NULL == t)
-        return;
-
-    debugs(79, 3, "storeCossMemBufUnlock: unlocking " << t << ", lockcount " << t->lockcount);
-
-    -- t->lockcount;
-
-    cstate->locked_membuf = NULL;
-
-    t->maybeWrite(this);
-}
-
-void
-CossSwapDir::sync()
-{
-    CossMemBuf *t;
-    dlink_node *m;
-    off_t end;
-
-    /* First, flush pending IO ops */
-    io->sync();
-
-    /* Then, flush any in-memory partial membufs */
-
-    if (!membufs.head)
-        return;
-
-    for (m = membufs.head; m; m = m->next) {
-        t = (CossMemBuf *)m->data;
-
-        if (t->flags.writing) {
-            debugs(79, DBG_IMPORTANT, "WARNING: sleeping for 5 seconds in storeCossSync()");
-            sleep(5);		/* XXX EEEWWW! */
-        }
-
-        end = (t == current_membuf) ? current_offset : t->diskend;
-
-        if (end > t->diskstart)
-            theFile->write(new CossWrite(WriteRequest((char const *)&t->buffer, t->diskstart, end - t->diskstart, NULL), t));
-
-        /* and flush */
-        io->sync();
-    }
-}
-
-void
-CossMemBuf::maybeWrite(CossSwapDir * SD)
-{
-    describe(3, __LINE__);
-
-    if (!flags.full)
-        debugs(79, 3, "membuf " << this << " not full");
-    else if (flags.writing)
-        debugs(79, 3, "membuf " << this << " writing");
-    else if (lockcount)
-        debugs(79, 3, "membuf " << this << " lockcount=" << lockcount);
-    else
-        write(SD);
-}
-
-void
-CossMemBuf::write(CossSwapDir * SD)
-{
-    ++ StoreFScoss::GetInstance().stats.stripe_write.ops;
-    debugs(79, 3, "CossMemBuf::write: offset " << diskstart << ", len " << (diskend - diskstart));
-    flags.writing = true;
-    /* XXX Remember that diskstart/diskend are block offsets! */
-    SD->theFile->write(new CossWrite(WriteRequest((char const *)&buffer, diskstart, diskend - diskstart, NULL), this));
-}
-
-CossMemBuf *
-CossSwapDir::createMemBuf(off_t start, sfileno curfn, int *collision)
-{
-    CossMemBuf *newmb;
-    CossMemBuf *t;
-    StoreEntry *e;
-    dlink_node *m, *prev;
-    int numreleased = 0;
-
-    CBDATA_INIT_TYPE_FREECB(CossMemBuf, NULL);
-    newmb = cbdataAlloc(CossMemBuf);
-    newmb->diskstart = start;
-    debugs(79, 3, "CossSwapDir::createMemBuf: creating new membuf at " << newmb->diskstart);
-    debugs(79, 3, "CossSwapDir::createMemBuf: at " << newmb);
-    newmb->diskend = newmb->diskstart + COSS_MEMBUF_SZ;
-    newmb->lockcount = 0;
-    newmb->SD = this;
-    /* XXX This should be reversed, with the new buffer last in the chain */
-    dlinkAdd(newmb, &newmb->node, &membufs);
-
-    /* Print out the list of membufs */
-
-    debugs(79, 3, "CossSwapDir::createMemBuf: membuflist:");
-
-    for (m = membufs.head; m; m = m->next) {
-        t = (CossMemBuf *)m->data;
-        t->describe(3, __LINE__);
-    }
-
-    /*
-     * Kill objects from the tail to make space for a new chunk
-     */
-    for (m = cossindex.tail; m; m = prev) {
-        off_t o;
-        prev = m->prev;
-        e = (StoreEntry *)m->data;
-        o = storeCossFilenoToDiskOffset(e->swap_filen);
-
-        if (curfn == e->swap_filen)
-            *collision = 1;	/* Mark an object alloc collision */
-
-        if ((o >= (off_t)newmb->diskstart) && (o < (off_t)newmb->diskend)) {
-            e->release();
-            ++numreleased;
-        } else
-            break;
-    }
-
-    if (numreleased > 0)
-        debugs(79, 3, "CossSwapDir::createMemBuf: this allocation released " << numreleased << " storeEntries");
-
-    ++ StoreFScoss::GetInstance().stats.stripes;
-
-    return newmb;
-}
-
-/*
- * Creates the initial membuf after rebuild
- */
-void
-CossSwapDir::startMembuf()
-{
-    CossMemBuf *newmb;
-    newmb = createMemBuf(current_offset, -1, NULL);
-    assert(!current_membuf);
-    current_membuf = newmb;
-}
-
-/*
- * Clean up any references from the SIO before it get's released.
- */
-CossState::~CossState()
-{}
-
-void
-CossMemBuf::describe(int level, int line)
-{
-    debugs(79, level, "membuf " << this << ", LC:" << std::setfill('0') <<
-           std::setw(2) << lockcount << ", ST:" <<
-           std::setw(10) <<  (unsigned long) diskstart << ", FL:" <<
-           (flags.full ? 'F' : '.') << (flags.writing ? 'W' : '.'));
-}
-
@@ -146,7 +146,7 @@ Rock::SwapDir::entryLimitAllowed() const
     return min(max(eLimitLo, eWanted), entryLimitHigh());
 }
 
-// TODO: encapsulate as a tool; identical to CossSwapDir::create()
+// TODO: encapsulate as a tool
 void
 Rock::SwapDir::create()
 {
@@ -33,6 +33,7 @@
 #include "squid.h"
 #include "cbdata.h"
 #include "CacheManager.h"
+#include "dlink.h"
 #include "DnsLookupDetails.h"
 #include "event.h"
 #include "ip/Address.h"
@@ -142,17 +143,9 @@ static dlink_list lru_list;
 static void stat_ipcache_get(StoreEntry *);
 
 static FREE ipcacheFreeEntry;
-#if USE_DNSHELPER
-static HLPCB ipcacheHandleReply;
-#else
 static IDNSCB ipcacheHandleReply;
-#endif
 static int ipcacheExpiredEntry(ipcache_entry *);
-#if USE_DNSHELPER
-static int ipcacheParse(ipcache_entry *, const char *buf);
-#else
 static int ipcacheParse(ipcache_entry *, const rfc1035_rr *, int, const char *error);
-#endif
 static ipcache_entry *ipcache_get(const char *);
 static void ipcacheLockEntry(ipcache_entry *);
 static void ipcacheStatPrint(ipcache_entry *, StoreEntry *);
@@ -358,110 +351,6 @@ ipcacheCallback(ipcache_entry *i, int wait)
 }
 
 /// \ingroup IPCacheAPI
-#if USE_DNSHELPER
-static int
-ipcacheParse(ipcache_entry *i, const char *inbuf)
-{
-    LOCAL_ARRAY(char, buf, DNS_INBUF_SZ);
-    char *token;
-    int ipcount = 0;
-    int ttl;
-    char *A[32];
-    const char *name = (const char *)i->hash.key;
-    i->expires = squid_curtime + Config.negativeDnsTtl;
-    i->flags.negcached = 1;
-    safe_free(i->addrs.in_addrs);
-    safe_free(i->addrs.bad_mask);
-    safe_free(i->error_message);
-    i->addrs.count = 0;
-
-    if (inbuf == NULL) {
-        debugs(14, DBG_IMPORTANT, "ipcacheParse: Got <NULL> reply");
-        i->error_message = xstrdup("Internal Error");
-        return -1;
-    }
-
-    xstrncpy(buf, inbuf, DNS_INBUF_SZ);
-    debugs(14, 5, "ipcacheParse: parsing: {" << buf << "}");
-    token = strtok(buf, w_space);
-
-    if (NULL == token) {
-        debugs(14, DBG_IMPORTANT, "ipcacheParse: expecting result, got '" << inbuf << "'");
-
-        i->error_message = xstrdup("Internal Error");
-        return -1;
-    }
-
-    if (0 == strcmp(token, "$fail")) {
-        token = strtok(NULL, "\n");
-        assert(NULL != token);
-        i->error_message = xstrdup(token);
-        return 0;
-    }
-
-    if (0 != strcmp(token, "$addr")) {
-        debugs(14, DBG_IMPORTANT, "ipcacheParse: expecting '$addr', got '" << inbuf << "' in response to '" << name << "'");
-
-        i->error_message = xstrdup("Internal Error");
-        return -1;
-    }
-
-    token = strtok(NULL, w_space);
-
-    if (NULL == token) {
-        debugs(14, DBG_IMPORTANT, "ipcacheParse: expecting TTL, got '" << inbuf << "' in response to '" << name << "'");
-
-        i->error_message = xstrdup("Internal Error");
-        return -1;
-    }
-
-    ttl = atoi(token);
-
-    while (NULL != (token = strtok(NULL, w_space))) {
-        A[ipcount] = token;
-
-        if (++ipcount == 32)
-            break;
-    }
-
-    if (ipcount > 0) {
-        int j, k;
-
-        i->addrs.in_addrs = static_cast<Ip::Address *>(xcalloc(ipcount, sizeof(Ip::Address)));
-        for (int l = 0; l < ipcount; ++l)
-            i->addrs.in_addrs[l].setEmpty(); // perform same init actions as constructor would.
-        i->addrs.bad_mask = (unsigned char *)xcalloc(ipcount, sizeof(unsigned char));
-        memset(i->addrs.bad_mask, 0, sizeof(unsigned char) * ipcount);
-
-        for (j = 0, k = 0; k < ipcount; ++k) {
-            if ((i->addrs.in_addrs[j] = A[k]))
-                ++j;
-            else
-                debugs(14, DBG_IMPORTANT, "ipcacheParse: Invalid IP address '" << A[k] << "' in response to '" << name << "'");
-        }
-
-        i->addrs.count = (unsigned char) j;
-    }
-
-    if (i->addrs.count <= 0) {
-        debugs(14, DBG_IMPORTANT, "ipcacheParse: No addresses in response to '" << name << "'");
-        return -1;
-    }
-
-    if (ttl == 0 || ttl > Config.positiveDnsTtl)
-        ttl = Config.positiveDnsTtl;
-
-    if (ttl < Config.negativeDnsTtl)
-        ttl = Config.negativeDnsTtl;
-
-    i->expires = squid_curtime + ttl;
-
-    i->flags.negcached = 0;
-
-    return i->addrs.count;
-}
-
-#else
 static int
 ipcacheParse(ipcache_entry *i, const rfc1035_rr * answers, int nr, const char *error_message)
 {
@@ -590,33 +479,20 @@ ipcacheParse(ipcache_entry *i, const rfc1035_rr * answers, int nr, const char *e
     return i->addrs.count;
 }
 
-#endif
-
 /// \ingroup IPCacheInternal
 static void
-#if USE_DNSHELPER
-ipcacheHandleReply(void *data, const HelperReply &reply)
-#else
 ipcacheHandleReply(void *data, const rfc1035_rr * answers, int na, const char *error_message)
-#endif
 {
     ipcache_entry *i;
     static_cast<generic_cbdata *>(data)->unwrap(&i);
     ++IpcacheStats.replies;
     const int age = i->age();
     statCounter.dns.svcTime.count(age);
 
-#if USE_DNSHELPER
-    ipcacheParse(i, reply.other().content());
-#else
-
     int done = ipcacheParse(i, answers, na, error_message);
 
     /* If we have not produced either IPs or Error immediately, wait for recursion to finish. */
-    if (done != 0 || error_message != NULL)
-#endif
-
-    {
+    if (done != 0 || error_message != NULL) {
         ipcacheAddEntry(i);
         ipcacheCallback(i, age);
     }
@@ -699,11 +575,7 @@ ipcache_nbgethostbyname(const char *name, IPH * handler, void *handlerData)
     i->handlerData = cbdataReference(handlerData);
     i->request_time = current_time;
     c = new generic_cbdata(i);
-#if USE_DNSHELPER
-    dnsSubmit(hashKeyStr(&i->hash), ipcacheHandleReply, c);
-#else
     idnsALookup(hashKeyStr(&i->hash), ipcacheHandleReply, c);
-#endif
 }
 
 /// \ingroup IPCacheInternal
@@ -804,7 +804,7 @@ mainReconfigureFinish(void *)
     if (oldWorkers != Config.workers) {
         debugs(1, DBG_CRITICAL, "WARNING: Changing 'workers' (from " <<
                oldWorkers << " to " << Config.workers <<
-               ") is not supported and ignored");
+               ") requires a full restart. It has been ignored by reconfigure.");
         Config.workers = oldWorkers;
     }
 
@@ -901,9 +901,6 @@ static void
 mainRotate(void)
 {
     icmpEngine.Close();
-#if USE_DNSHELPER
-    dnsShutdown();
-#endif
     redirectShutdown();
 #if USE_AUTH
     authenticateRotate();
@@ -918,9 +915,6 @@ mainRotate(void)
     icapLogRotate();               /*icap.log*/
 #endif
     icmpEngine.Open();
-#if USE_DNSHELPER
-    dnsInit();
-#endif
     redirectInit();
 #if USE_AUTH
     authenticateInit(&Auth::TheConfig);
@@ -7,7 +7,6 @@
 #define SQUID_MGR_COUNTERS_ACTION_H
 
 #include "mgr/Action.h"
-#include <sys/time.h>
 
 namespace Mgr
 {
@@ -8,7 +8,6 @@
 
 #include "mgr/Action.h"
 #include "StoreStats.h"
-#include <sys/time.h>
 
 namespace Mgr
 {
@@ -7,7 +7,6 @@
 #define SQUID_MGR_INTERVAL_ACTION_H
 
 #include "mgr/Action.h"
-#include <sys/time.h>
 
 namespace Mgr
 {
@@ -210,21 +210,29 @@ extern "C" {
         static krb5_keytab_entry entry;
         static krb5_kt_cursor cursor;
         static krb5_creds *creds = NULL;
-#if HAVE_HEIMDAL_KERBEROS
+#if HAVE_HEIMDAL_KERBEROS && !HAVE_KRB5_GET_RENEWED_CREDS
         static krb5_creds creds2;
 #endif
         static krb5_principal principal = NULL;
         static krb5_deltat skew;
 
+#if HAVE_KRB5_GET_INIT_CREDS_OPT_ALLOC
+        krb5_get_init_creds_opt *options;
+#else
         krb5_get_init_creds_opt options;
+#endif
         krb5_error_code code = 0;
         krb5_deltat rlife;
 #if HAVE_PROFILE_H && HAVE_KRB5_GET_PROFILE && HAVE_PROFILE_GET_INTEGER && HAVE_PROFILE_RELEASE
         profile_t profile;
 #endif
-#if HAVE_HEIMDAL_KERBEROS
+#if HAVE_HEIMDAL_KERBEROS && !HAVE_KRB5_GET_RENEWED_CREDS
         krb5_kdc_flags flags;
-        krb5_realm *client_realm;
+#if HAVE_KRB5_PRINCIPAL_GET_REALM
+        const char *client_realm;
+#else
+        krb5_realm client_realm;
+#endif
 #endif
         char *mem_cache;
 
@@ -236,7 +244,7 @@ extern "C" {
                 (creds->times.endtime - time(0) > skew) &&
                 (creds->times.renew_till - time(0) > 2 * skew)) {
             if (creds->times.endtime - time(0) < 2 * skew) {
-#if !HAVE_HEIMDAL_KERBEROS
+#if HAVE_KRB5_GET_RENEWED_CREDS
                 /* renew ticket */
                 code =
                     krb5_get_renewed_creds(kparam.context, creds, principal,
@@ -256,10 +264,15 @@ extern "C" {
                            << error_message(code));
                     return (1);
                 }
+#if HAVE_KRB5_PRINCIPAL_GET_REALM
+                client_realm = krb5_principal_get_realm(kparam.context, principal);
+#else
                 client_realm = krb5_princ_realm(kparam.context, creds2.client);
+#endif
                 code =
                     krb5_make_principal(kparam.context, &creds2.server,
-                                        *client_realm, KRB5_TGS_NAME, *client_realm, NULL);
+                                        (krb5_const_realm)&client_realm, KRB5_TGS_NAME,
+                                        (krb5_const_realm)&client_realm, NULL);
                 if (code) {
                     debugs(11, 5,
                            HERE << "Error while getting krbtgt principal : " <<
@@ -400,19 +413,34 @@ extern "C" {
 
             creds = (krb5_creds *) xmalloc(sizeof(*creds));
             memset(creds, 0, sizeof(*creds));
+#if HAVE_KRB5_GET_INIT_CREDS_OPT_ALLOC
+            krb5_get_init_creds_opt_alloc(kparam.context, &options);
+#else
             krb5_get_init_creds_opt_init(&options);
+#endif
             code = krb5_string_to_deltat((char *) MAX_RENEW_TIME, &rlife);
             if (code != 0 || rlife == 0) {
                 debugs(11, 5,
                        HERE << "Error bad lifetime value " << MAX_RENEW_TIME <<
                        " : " << error_message(code));
                 return (1);
             }
+#if HAVE_KRB5_GET_INIT_CREDS_OPT_ALLOC
+            krb5_get_init_creds_opt_set_renew_life(options, rlife);
+            code =
+                krb5_get_init_creds_keytab(kparam.context, creds, principal,
+                                           keytab, 0, NULL, options);
+#if HAVE_KRB5_GET_INIT_CREDS_FREE_CONTEXT
+            krb5_get_init_creds_opt_free(kparam.context, options);
+#else
+            krb5_get_init_creds_opt_free(options);
+#endif
+#else
             krb5_get_init_creds_opt_set_renew_life(&options, rlife);
-
             code =
                 krb5_get_init_creds_keytab(kparam.context, creds, principal,
                                            keytab, 0, NULL, &options);
+#endif
             if (code) {
                 debugs(11, 5,
                        HERE <<
@@ -1584,11 +1584,7 @@ static X509 * readSslX509CertificatesChain(char const * certFilename,  STACK_OF(
         if (X509_check_issued(certificate, certificate) == X509_V_OK)
             debugs(83, 5, "Certificate is self-signed, will not be chained");
         else {
-            if (sk_X509_push(chain, certificate))
-                CRYPTO_add(&(certificate->references), 1, CRYPTO_LOCK_X509);
-            else
-                debugs(83, DBG_IMPORTANT, "WARNING: unable to add signing certificate to cert chain");
-            // and add to the chain any certificate loaded from the file
+            // and add to the chain any other certificate exist in the file
             while (X509 *ca = PEM_read_bio_X509(bio.get(), NULL, NULL, NULL)) {
                 if (!sk_X509_push(chain, ca))
                     debugs(83, DBG_IMPORTANT, "WARNING: unable to add CA certificate to cert chain");
@@ -808,7 +808,7 @@ CheckQuickAbortIsReasonable(StoreEntry * entry)
     }
 
     if (curlen > expectlen) {
-        debugs(90, 3, "quick-abort? YES bad content length");
+        debugs(90, 3, "quick-abort? YES bad content length (" << curlen << " of " << expectlen << " bytes received)");
         return true;
     }
 
@@ -1,298 +0,0 @@
-#define SQUID_UNIT_TEST 1
-#include "squid.h"
-#include "ConfigParser.h"
-#include "testCoss.h"
-#include "Store.h"
-#include "SwapDir.h"
-#include "DiskIO/DiskIOModule.h"
-#include "fs/coss/CossSwapDir.h"
-#include "Mem.h"
-#include "MemObject.h"
-#include "HttpHeader.h"
-#include "HttpReply.h"
-#include "RequestFlags.h"
-#include "StoreFileSystem.h"
-#include "testStoreSupport.h"
-#include "SquidConfig.h"
-
-#if HAVE_STDEXCEPT
-#include <stdexcept>
-#endif
-
-#define TESTDIR "testCoss_Store"
-
-CPPUNIT_TEST_SUITE_REGISTRATION( testCoss );
-
-typedef RefCount<CossSwapDir> SwapDirPointer;
-extern REMOVALPOLICYCREATE createRemovalPolicy_lru;
-
-static void
-addSwapDir(SwapDirPointer aStore)
-{
-    allocate_new_swapdir(&Config.cacheSwap);
-    Config.cacheSwap.swapDirs[Config.cacheSwap.n_configured] = aStore.getRaw();
-    ++Config.cacheSwap.n_configured;
-}
-
-void
-testCoss::commonInit()
-{
-    static bool inited = false;
-
-    if (inited)
-        return;
-
-    StoreFileSystem::SetupAllFs();
-
-    Config.Store.avgObjectSize = 1024;
-
-    Config.Store.objectsPerBucket = 20;
-
-    Config.Store.maxObjectSize = 2048;
-
-    Config.store_dir_select_algorithm = xstrdup("round-robin");
-
-    Config.replPolicy = new RemovalPolicySettings;
-
-    Config.replPolicy->type = xstrdup ("lru");
-
-    Config.replPolicy->args = NULL;
-
-    /* garh garh */
-    storeReplAdd("lru", createRemovalPolicy_lru);
-
-    visible_appname_string = xstrdup(APP_FULLNAME);
-
-    Mem::Init();
-
-    comm_init();
-
-    httpHeaderInitModule();	/* must go before any header processing (e.g. the one in errorInitialize) */
-
-    httpReplyInitModule();	/* must go before accepting replies */
-
-    mem_policy = createRemovalPolicy(Config.replPolicy);
-
-    inited = true;
-}
-
-void
-testCoss::testCossCreate()
-{
-    if (0 > system ("rm -rf " TESTDIR))
-        throw std::runtime_error("Failed to clean test work directory");
-
-    Store::Root(new StoreController);
-
-    SwapDirPointer aStore (new CossSwapDir());
-
-    addSwapDir(aStore);
-
-    commonInit();
-
-    char *path=xstrdup(TESTDIR);
-
-    char *config_line=xstrdup("100 max-size=102400 block-size=512 IOEngine=Blocking");
-
-    ConfigParser::SetCfgLine(config_line);
-
-    aStore->parse(0, path);
-
-    safe_free(path);
-
-    safe_free(config_line);
-
-    /* ok, ready to create */
-    aStore->create();
-
-    struct stat sb;
-
-    CPPUNIT_ASSERT(::stat(TESTDIR, &sb) == 0);
-
-    /* TODO: check the size */
-
-    Store::Root(NULL);
-
-    free_cachedir(&Config.cacheSwap);
-
-    /* todo: here we should test a dirty rebuild */
-
-    //    safe_free(Config.replPolicy->type);
-    //    delete Config.replPolicy;
-    if (0 > system ("rm -rf " TESTDIR))
-        throw std::runtime_error("Failed to clean test work directory");
-}
-
-/* TODO make this a cbdata class */
-
-static bool cbcalled;
-
-static void
-searchCallback(void *cbdata)
-{
-    cbcalled = true;
-}
-
-void
-testCoss::testCossSearch()
-{
-    /* test sequence
-     * make a valid working ufs swapdir
-     * put two entries in it and sync logs
-     * search the ufs dir
-     * check the entries we find are what we want
-     */
-
-    if (0 > system ("rm -rf " TESTDIR))
-        throw std::runtime_error("Failed to clean test work directory");
-
-    Store::Root(new StoreController);
-
-    SwapDirPointer aStore (new CossSwapDir());
-
-    addSwapDir(aStore);
-
-    commonInit();
-
-    char *path=xstrdup(TESTDIR);
-
-    char *config_line=xstrdup("100 max-size=102400 block-size=512 IOEngine=Blocking");
-
-    ConfigParser::SetCfgLine(config_line);
-
-    aStore->parse(0, path);
-
-    safe_free(path);
-
-    safe_free(config_line);
-
-    /* ok, ready to create */
-    aStore->create();
-
-    /* ok, ready to use */
-    Store::Root().init();
-
-    /* rebuild is a scheduled event */
-    StockEventLoop loop;
-
-    /* our swapdir must be scheduled to rebuild */
-    CPPUNIT_ASSERT_EQUAL(2, StoreController::store_dirs_rebuilding);
-
-    loop.run();
-
-    /* cannot use loop.run(); as the loop will never idle: the store-dir
-     * clean() scheduled event prevents it
-     */
-
-    /* nothing left to rebuild */
-    CPPUNIT_ASSERT_EQUAL(1, StoreController::store_dirs_rebuilding);
-
-    /* add an entry */
-    {
-        /* Create "vary" base object */
-        RequestFlags flags;
-        flags.cachable = true;
-        StoreEntry *pe = storeCreateEntry("dummy url", "dummy log url", flags, METHOD_GET);
-        HttpReply *rep = (HttpReply *) pe->getReply();	// bypass const
-        rep->setHeaders(Http::scOkay, "dummy test object", "x-squid-internal/test", -1, -1, squid_curtime + 100000);
-
-        pe->setPublicKey();
-
-        pe->buffer();
-        /* TODO: remove this when the metadata is separated */
-        {
-            Packer p;
-            packerToStoreInit(&p, pe);
-            pe->getReply()->packHeadersInto(&p);
-            packerClean(&p);
-        }
-
-        pe->flush();
-        pe->timestampsSet();
-        pe->complete();
-        pe->swapOut();
-        CPPUNIT_ASSERT(pe->swap_dirn == 0);
-        CPPUNIT_ASSERT(pe->swap_filen == 0);
-        pe->unlock();
-    }
-
-    storeDirWriteCleanLogs(0);
-
-    /* here we cheat: we know that UFSSwapDirs search off disk. If we did an init call to a new
-     * swapdir instance, we'd not be testing a clean build.
-     */
-    StoreSearchPointer search = aStore->search (NULL, NULL); /* search for everything in the store */
-
-    /* nothing should be immediately available */
-#if 0
-
-    CPPUNIT_ASSERT(search->next() == false);
-#endif
-
-    CPPUNIT_ASSERT(search->error() == false);
-    CPPUNIT_ASSERT(search->isDone() == false);
-    CPPUNIT_ASSERT(search->currentItem() == NULL);
-
-    /* trigger a callback */
-    cbcalled = false;
-    search->next(searchCallback, NULL);
-    CPPUNIT_ASSERT(cbcalled == true);
-
-    /* we should have access to a entry now, that matches the entry we had before */
-    //CPPUNIT_ASSERT(search->next() == false);
-    CPPUNIT_ASSERT(search->error() == false);
-    CPPUNIT_ASSERT(search->isDone() == false);
-    CPPUNIT_ASSERT(search->currentItem() != NULL);
-
-    /* trigger another callback */
-    cbcalled = false;
-    search->next(searchCallback, NULL);
-    CPPUNIT_ASSERT(cbcalled == true);
-
-    /* now we should have no error, we should have finished and have no current item */
-    //CPPUNIT_ASSERT(search->next() == false);
-    CPPUNIT_ASSERT(search->error() == false);
-    CPPUNIT_ASSERT(search->isDone() == true);
-    CPPUNIT_ASSERT(search->currentItem() == NULL);
-
-    Store::Root(NULL);
-
-    free_cachedir(&Config.cacheSwap);
-
-    /* todo: here we should test a dirty rebuild */
-
-    //TODO: do this once, or each time.    safe_free(Config.replPolicy->type);
-    //    delete Config.replPolicy;
-
-    if (0 > system ("rm -rf " TESTDIR))
-        throw std::runtime_error("Failed to clean test work directory");
-}
-
-/* The COSS store should always configure an IO engine even if none is
- * supplied on the configuration line.
- */
-void
-testCoss::testDefaultEngine()
-{
-    /* boring common test boilerplate */
-    if (0 > system ("rm -rf " TESTDIR))
-        throw std::runtime_error("Failed to clean test work directory");
-
-    Store::Root(new StoreController);
-    SwapDirPointer aStore (new CossSwapDir());
-    addSwapDir(aStore);
-    commonInit();
-
-    char *path=xstrdup(TESTDIR);
-    char *config_line=xstrdup("100 max-size=102400 block-size=512");
-    ConfigParser::SetCfgLine(config_line);
-    aStore->parse(0, path);
-    safe_free(path);
-    safe_free(config_line);
-    CPPUNIT_ASSERT(aStore->io != NULL);
-
-    Store::Root(NULL);
-    free_cachedir(&Config.cacheSwap);
-    if (0 > system ("rm -rf " TESTDIR))
-        throw std::runtime_error("Failed to clean test work directory");
-}
@@ -1,29 +0,0 @@
-
-#ifndef SQUID_SRC_TEST_STORECONTROLLER_H
-#define SQUID_SRC_TEST_STORECONTROLLER_H
-
-#include <cppunit/extensions/HelperMacros.h>
-
-/*
- * test the store framework
- */
-
-class testCoss : public CPPUNIT_NS::TestFixture
-{
-    CPPUNIT_TEST_SUITE( testCoss );
-    CPPUNIT_TEST( testCossCreate );
-    CPPUNIT_TEST( testCossSearch );
-    CPPUNIT_TEST( testDefaultEngine );
-    CPPUNIT_TEST_SUITE_END();
-
-public:
-
-protected:
-    void commonInit();
-    void testCossCreate();
-    void testCossSearch();
-    void testDefaultEngine();
-};
-
-#endif
-
@@ -12,11 +12,6 @@
 #include "StoreFileSystem.h"
 #include "testStoreSupport.h"
 
-#if 0
-// AYJ: COSS in Squid-3 is disabled.
-#include "fs/coss/CossSwapDir.h"
-#endif
-
 #if HAVE_STDEXCEPT
 #include <stdexcept>
 #endif
@@ -188,7 +188,7 @@ testHttpReply::testSanityCheckFirstLine()
     error = Http::scNone;
 
     // status line with nul-byte
-    input.append("HTTP/1.1\0200 Okay\n\n", 19); /* real case seen */
+    input.append("HTTP/1.1" "\0" "200 Okay\n\n", 19); /* real case seen */
     hdr_len = headersEnd(input.content(),input.contentSize());
     CPPUNIT_ASSERT(!engine.sanityCheckStartLine(&input, hdr_len, &error) );
     CPPUNIT_ASSERT_EQUAL(error, Http::scInvalidHeader);
@@ -100,6 +100,7 @@ class TunnelStateData
     bool noConnections() const;
     char *url;
     HttpRequest::Pointer request;
+    AccessLogEntryPointer al;
     Comm::ConnectionList serverDestinations;
 
     const char * getHost() const {
@@ -845,7 +846,7 @@ tos_t GetTosToServer(HttpRequest * request);
 nfmark_t GetNfmarkToServer(HttpRequest * request);
 
 void
-tunnelStart(ClientHttpRequest * http, int64_t * size_ptr, int *status_ptr)
+tunnelStart(ClientHttpRequest * http, int64_t * size_ptr, int *status_ptr, const AccessLogEntryPointer &al)
 {
     debugs(26, 3, HERE);
     /* Create state structure. */
@@ -890,6 +891,7 @@ tunnelStart(ClientHttpRequest * http, int64_t * size_ptr, int *status_ptr)
     tunnelState->server.size_ptr = size_ptr;
     tunnelState->status_ptr = status_ptr;
     tunnelState->client.conn = http->getConn()->clientConnection;
+    tunnelState->al = al;
 
     comm_add_close_handler(tunnelState->client.conn->fd,
                            tunnelClientClosed,
@@ -921,7 +923,7 @@ tunnelRelayConnectRequest(const Comm::ConnectionPointer &srv, void *data)
     mb.Printf("CONNECT %s HTTP/1.1\r\n", tunnelState->url);
     HttpStateData::httpBuildRequestHeader(tunnelState->request.getRaw(),
                                           NULL,			/* StoreEntry */
-                                          NULL,			/* AccessLogEntry */
+                                          tunnelState->al,			/* AccessLogEntry */
                                           &hdr_out,
                                           flags);			/* flags */
     packerToMemInit(&p, &mb);
@@ -35,13 +35,6 @@
 
 #if _SQUID_WINDOWS_
 
-#if HAVE_SYS_TIME_H
-#include <sys/time.h>
-#endif
-#if HAVE_SYS_RESOURCE_H
-#include <sys/resource.h>
-#endif
-
 void WIN32_ExceptionHandlerInit(void);
 
 int Win32__WSAFDIsSet(int fd, fd_set* set);
@@ -14,7 +14,9 @@ LDADD = \
 
 EXTRA_PROGRAMS = mem_node_test membanger splay tcp-banger2
 
-EXTRA_DIST = testheaders.sh
+EXTRA_DIST = \
+	$(srcdir)/squidconf/* \
+	testheaders.sh
 
 ESI_ALL_TESTS = \
 	ESIExpressions
@@ -34,7 +36,8 @@ TESTS += debug \
 	MemPoolTest\
 	mem_node_test\
 	mem_hdr_test\
-	$(ESI_TESTS)
+	$(ESI_TESTS) \
+	squid-conf-tests
 
 ## Sort by alpha - any build failures are significant.
 check_PROGRAMS += debug \
@@ -111,3 +114,22 @@ VirtualDeleteOperator_SOURCES = VirtualDeleteOperator.cc $(DEBUG_SOURCE)
 ##
 ##$(TARGLIB): $(LIBOBJS)
 ##	$(AR_R) $(TARGLIB) $(LIBOBJS)
+
+squid-conf-tests: $(top_builddir)/src/squid.conf.default $(srcdir)/squidconf/*
+	@failed=0; cfglist="$?"; rm -f $@ || $(TRUE); \
+	for cfg in $$cfglist ; do \
+		$(top_builddir)/src/squid -k parse -f $$cfg || \
+			{ echo "FAIL: squid.conf test: $$cfg" | \
+				sed s%$(top_builddir)/src/%% | \
+				sed s%$(srcdir)/squidconf/%% ; \
+				failed=1; break; \
+			}; \
+		if test "$$failed" -eq 0; then \
+			echo "PASS: squid.conf test: $$cfg" | \
+				sed s%$(top_builddir)/src/%% | \
+				sed s%$(srcdir)/squidconf/%% ; \
+		else break; fi; \
+	done; \
+	if test "$$failed" -eq 0; then cp $(TRUE) $@ ; fi
+
+CLEANFILES += squid-conf-tests
@@ -20,7 +20,6 @@ MAKETEST="distcheck"
 #
 #   --without-default-user \
 #   --without-aufs-threads \
-#   --without-coss-membuf-size \
 #   --without-filedescriptors \
 #   --without-cppunit-basedir \
 #   --without-build-environment \
@@ -71,7 +70,6 @@ DISTCHECK_CONFIGURE_FLAGS=" \
 	--disable-leakfinder \
 	--disable-follow-x-forwarded-for \
 	--disable-ident-lookups \
-	--disable-internal-dns \
 	--disable-default-hostsfile \
 	--disable-auth \
 	--disable-basic-auth-helpers \
@@ -22,7 +22,6 @@ MAKETEST="distcheck"
 #
 #   --with-default-user=NAME \
 #   --with-aufs-threads=N \
-#   --with-coss-membuf-size=N \
 #   --with-filedescriptors=N \
 #   --with-cppunit-basedir=PATH \
 #   --with-openssl=PATH \
@@ -78,7 +77,6 @@ DISTCHECK_CONFIGURE_FLAGS=" \
 	--enable-leakfinder \
 	--enable-follow-x-forwarded-for \
 	--enable-ident-lookups \
-	--enable-internal-dns \
 	--enable-default-hostsfile \
 	--enable-auth \
 	--enable-basic-auth-helpers \
@@ -22,7 +22,6 @@ MAKETEST="distcheck"
 #
 #   --with-default-user=NAME \
 #   --with-aufs-threads=N \
-#   --with-coss-membuf-size=N \
 #   --with-filedescriptors=N \
 #   --with-cppunit-basedir=PATH \
 #   --with-openssl=PATH \
@@ -0,0 +1,42 @@
+#
+# This file contains the list of reported regression cases in 3.4.0.1 parser
+# it covers various uses of:
+#	folded lines
+#	bare macro token
+#	key=value tokens
+#	helper command line
+#	quoted file include
+#	regular expressions
+#	percentage token
+#	bare double-quote characters (escaped and unescaped)
+#	false-positive quoted-string token
+#
+
+external_acl_type LdapGroup children-max=30 children-startup=10 \
+concurrency=0 ttl=600 negative_ttl=10 grace=0 protocol=2.5 %SRC \
+  /bin/true -v 3 -h 127.0.0.1 -b "o=A,c=INVALID" -B "org=borken?,ou=People,o=A,c=INVALID" \
+  -f "(&(cn=%g)(memberUid=%u))" -F "(&(objectClass=account)(uid=%s))" -s sub 
+
+acl Mark dstdomain "empty"
+
+refresh_pattern "foo 0 80% 20160
+refresh_pattern "foo\" 0 80% 20160
+refresh_pattern foo\" 0 80% 20160
+
+
+refresh_pattern -i bar.com.invalid/.*\.(cab|exe|ms[i|u|f]|asf|wm[v|a]|dat|zip) 4320 90% 43200
+refresh_pattern -i foo.com.invalid.*\.(cab|exe|ms[i|u|f]|asf|wm[v|a]|dat|zip) 4320 90% 43200
+
+refresh_pattern http://download\.foo\.invalid/ 0 80% 20160
+refresh_pattern ftp://ftp\.bar\.invalid/ 0 80% 20160
+refresh_pattern http://ftp\.software\.invalid/ 0 80% 20160
+
+# Others
+refresh_pattern -i \.mp4 1440 90% 43200
+refresh_pattern -i \.(gif|png|jpg|jpeg|ico)$ 40320 75% 86400
+refresh_pattern -i \.(iso|avi|wav|mp3|mpeg|swf|flv|x-flv)$ 1440 40% 40320
+
+refresh_pattern ^ftp:           1440    20%     10080
+refresh_pattern ^gopher:        1440    0%      1440
+refresh_pattern -i (/cgi-bin/|\?)       0       0%      0
+refresh_pattern .       0       20%     4320
@@ -211,7 +211,8 @@ int
 main(int argc, char *argv[])
 {
     int conn, c, len, bytesWritten;
-    int port, to_stdout, reload;
+    uint16_t port;
+    bool to_stdout, reload;
     int ping, pcount;
     int keep_alive = 0;
     int opt_noaccept = 0;
@@ -245,8 +246,8 @@ main(int argc, char *argv[])
     localhost = NULL;
     extra_hdrs[0] = '\0';
     port = CACHE_HTTP_PORT;
-    to_stdout = 1;
-    reload = 0;
+    to_stdout = true;
+    reload = false;
     ping = 0;
     pcount = 0;
     ping_int = 1 * 1000;
@@ -292,19 +293,19 @@ main(int argc, char *argv[])
                 break;
 
             case 's':		/* silent */
-                to_stdout = 0;
+                to_stdout = false;
                 break;
 
             case 'k':		/* backward compat */
                 keep_alive = 1;
                 break;
 
             case 'r':		/* reload */
-                reload = 1;
+                reload = true;
                 break;
 
             case 'p':		/* port number */
-                sscanf(optarg, "%d", &port);
+                sscanf(optarg, "%hd", &port);
                 if (port < 1)
                     port = CACHE_HTTP_PORT;	/* default */
                 break;