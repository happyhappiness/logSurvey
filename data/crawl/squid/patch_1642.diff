@@ -1,6 +1,6 @@
 
 /*
- * $Id: CacheDigest.cc,v 1.1 1998/03/30 21:03:33 rousskov Exp $
+ * $Id: CacheDigest.cc,v 1.2 1998/03/31 05:35:35 wessels Exp $
  *
  * DEBUG: section ??    Cache Digest
  * AUTHOR: Alex Rousskov
@@ -44,24 +44,24 @@ CacheDigest *
 cacheDigestCreate(int capacity)
 {
     CacheDigest *cd = xcalloc(1, sizeof(CacheDigest));
-    assert(MD5_DIGEST_CHARS == 16); /* our hash functions rely on 16 byte keys */
+    assert(MD5_DIGEST_CHARS == 16);	/* our hash functions rely on 16 byte keys */
     assert(capacity > 0);
     cd->capacity = capacity;
-    cd->mask_size = (size_t) (capacity * BitsPerEntry + 7)/ 8;
+    cd->mask_size = (size_t) (capacity * BitsPerEntry + 7) / 8;
     cd->mask = xcalloc(cd->mask_size, 1);
     return cd;
 }
 
 void
-cacheDigestDestroy(CacheDigest *cd)
+cacheDigestDestroy(CacheDigest * cd)
 {
     assert(cd);
     xfree(cd->mask);
     xfree(cd);
 }
 
 void
-cacheDigestAdd(CacheDigest *cd, const cache_key *key)
+cacheDigestAdd(CacheDigest * cd, const cache_key * key)
 {
     assert(cd && key);
     /* hash */
@@ -76,21 +76,21 @@ cacheDigestAdd(CacheDigest *cd, const cache_key *key)
 
 /* returns true if the key belongs to the digest */
 int
-cacheDigestTest(const CacheDigest *cd, const cache_key *key)
+cacheDigestTest(const CacheDigest * cd, const cache_key * key)
 {
     assert(cd && key);
     /* hash */
     cacheDigestHashKey(cd->capacity * BitsPerEntry, key);
     /* test corresponding bits */
-    return 
+    return
 	CBIT_TEST(cd->mask, hashed_keys[0]) &&
 	CBIT_TEST(cd->mask, hashed_keys[1]) &&
 	CBIT_TEST(cd->mask, hashed_keys[2]) &&
 	CBIT_TEST(cd->mask, hashed_keys[3]);
 }
 
 void
-cacheDigestDel(CacheDigest *cd, const cache_key *key)
+cacheDigestDel(CacheDigest * cd, const cache_key * key)
 {
     assert(cd && key);
     cd->del_count++;
@@ -109,5 +109,3 @@ cacheDigestHashKey(int bit_count, const char *key)
     hashed_keys[2] %= bit_count;
     hashed_keys[3] %= bit_count;
 }
-
-
@@ -1,5 +1,7 @@
+
+
 /*
- * $Id: HttpBody.cc,v 1.5 1998/02/26 18:00:30 wessels Exp $
+ * $Id: HttpBody.cc,v 1.6 1998/03/31 05:35:36 wessels Exp $
  *
  * DEBUG: section 56    HTTP Message Body
  * AUTHOR: Alex Rousskov
@@ -1,7 +1,7 @@
 
 
 /*
- * $Id: access_log.cc,v 1.24 1998/03/31 03:57:14 wessels Exp $
+ * $Id: access_log.cc,v 1.25 1998/03/31 05:37:33 wessels Exp $
  *
  * DEBUG: section 46    Access Log
  * AUTHOR: Duane Wessels
@@ -63,15 +63,15 @@ const char *log_tags[] =
 
 #if FORW_VIA_DB
 typedef struct {
-        char *key;
-        void *next;
-        int n;
+    char *key;
+    void *next;
+    int n;
 } fvdb_entry;
 static hash_table *via_table = NULL;
 static hash_table *forw_table = NULL;
 static void fvdbInit(void);
-static void fvdbDumpTable(StoreEntry *e, hash_table *hash);
-static void fvdbCount(hash_table *hash, const char *key);
+static void fvdbDumpTable(StoreEntry * e, hash_table * hash);
+static void fvdbCount(hash_table * hash, const char *key);
 static OBJH fvdbDumpVia;
 static OBJH fvdbDumpForw;
 static FREE fvdbFreeEntry;
@@ -355,75 +355,76 @@ accessLogTime(time_t t)
 
 
 #if FORW_VIA_DB
-    
+
 static void
 fvdbInit(void)
 {
     via_table = hash_create((HASHCMP *) strcmp, 977, hash4);
     forw_table = hash_create((HASHCMP *) strcmp, 977, hash4);
     cachemgrRegister("via_headers", "Via Request Headers", fvdbDumpVia, 0);
     cachemgrRegister("forw_headers", "X-Forwarded-For Request Headers",
-        fvdbDumpForw, 0);
+	fvdbDumpForw, 0);
 }
 
 static void
-fvdbCount(hash_table *hash, const char *key)
-{   
-        fvdb_entry *fv;
-        if (NULL == hash)
-                return;
-        fv = hash_lookup(hash, key);
-        if (NULL == fv) {
-                fv = xcalloc(1, sizeof(fvdb_entry));
-                fv->key = xstrdup(key);
-                hash_join(hash, (hash_link *) fv);
-        }
-        fv->n++;
+fvdbCount(hash_table * hash, const char *key)
+{
+    fvdb_entry *fv;
+    if (NULL == hash)
+	return;
+    fv = hash_lookup(hash, key);
+    if (NULL == fv) {
+	fv = xcalloc(1, sizeof(fvdb_entry));
+	fv->key = xstrdup(key);
+	hash_join(hash, (hash_link *) fv);
+    }
+    fv->n++;
 }
 
 void
 fvdbCountVia(const char *key)
 {
-	fvdbCount(via_table, key);
+    fvdbCount(via_table, key);
 }
 
 void
 fvdbCountForw(const char *key)
 {
-	fvdbCount(forw_table, key);
+    fvdbCount(forw_table, key);
 }
 
-static void 
-fvdbDumpTable(StoreEntry *e, hash_table *hash)
+static void
+fvdbDumpTable(StoreEntry * e, hash_table * hash)
 {
-        hash_link *h;
-        fvdb_entry *fv;
-        if (hash == NULL)  
-                return;
-        for (h = hash_first(hash); h != NULL; h = hash_next(hash)) {
-                fv = (fvdb_entry *) h;
-                storeAppendPrintf(e, "%9d %s\n", fv->n, fv->key);
-        }
+    hash_link *h;
+    fvdb_entry *fv;
+    if (hash == NULL)
+	return;
+    for (h = hash_first(hash); h != NULL; h = hash_next(hash)) {
+	fv = (fvdb_entry *) h;
+	storeAppendPrintf(e, "%9d %s\n", fv->n, fv->key);
+    }
 }
 
 static void
-fvdbDumpVia(StoreEntry *e)
+fvdbDumpVia(StoreEntry * e)
 {
-        fvdbDumpTable(e, via_table);
+    fvdbDumpTable(e, via_table);
 }
-    
+
 static void
-fvdbDumpForw(StoreEntry *e)
+fvdbDumpForw(StoreEntry * e)
 {
-        fvdbDumpTable(e, forw_table); 
+    fvdbDumpTable(e, forw_table);
 }
 
 static
-void fvdbFreeEntry(void *data)
+void 
+fvdbFreeEntry(void *data)
 {
-	fvdb_entry *fv = data;
-	xfree(fv->key);
-	xfree(fv);
+    fvdb_entry *fv = data;
+    xfree(fv->key);
+    xfree(fv);
 }
 
 static void
@@ -433,4 +434,4 @@ fvdbClear(void)
     hashFreeItems(forw_table, fvdbFreeEntry);
 }
 
-#endif  
+#endif
@@ -1,6 +1,6 @@
 
 /*
- * $Id: cache_cf.cc,v 1.268 1998/03/31 04:09:48 wessels Exp $
+ * $Id: cache_cf.cc,v 1.269 1998/03/31 05:37:34 wessels Exp $
  *
  * DEBUG: section 3     Configuration File Parsing
  * AUTHOR: Harvest Derived
@@ -442,16 +442,15 @@ dump_acl_access(StoreEntry * entry, const char *name, acl_access * head)
 static void
 parse_snmp_access(communityEntry ** head)
 {
-    char *t=NULL;
+    char *t = NULL;
     communityEntry *cp;
 /* This is tricky: we need to define the communities here, assuming that 
-   communities and the MIB have already been defined */
-    
+ * communities and the MIB have already been defined */
+
     if (!snmpInitConfig()) {
-	debug(15,0)("parse_snmp_access: Access lists NOT defined.\n");
+	debug(15, 0) ("parse_snmp_access: Access lists NOT defined.\n");
 	return;
     }
-
     t = strtok(NULL, w_space);
     for (cp = *head; cp; cp = cp->next)
 	if (!strcmp(t, cp->name)) {
@@ -1,5 +1,5 @@
 /*
- * $Id: cache_diff.cc,v 1.6 1998/03/29 21:01:49 rousskov Exp $
+ * $Id: cache_diff.cc,v 1.7 1998/03/31 05:37:35 wessels Exp $
  *
  * AUTHOR: Alex Rousskov
  *
@@ -38,10 +38,10 @@
 typedef struct {
     const char *name;
     hash_table *hash;
-    int count;          /* #currently cached entries */
-    int scanned_count;  /* #scanned entries */
-    int bad_add_count;  /* #duplicate adds */
-    int bad_del_count;  /* #dels with no prior add */
+    int count;			/* #currently cached entries */
+    int scanned_count;		/* #scanned entries */
+    int bad_add_count;		/* #duplicate adds */
+    int bad_del_count;		/* #dels with no prior add */
 } CacheIndex;
 
 
@@ -67,11 +67,11 @@ const char *RequestMethodStr[] =
 };
 
 
-static int cacheIndexScan(CacheIndex *idx, const char *fname, FILE *file);
+static int cacheIndexScan(CacheIndex * idx, const char *fname, FILE * file);
 
 
 static CacheEntry *
-cacheEntryCreate(const storeSwapLogData *s)
+cacheEntryCreate(const storeSwapLogData * s)
 {
     CacheEntry *e = xcalloc(1, sizeof(CacheEntry));
     assert(s);
@@ -82,7 +82,7 @@ cacheEntryCreate(const storeSwapLogData *s)
 }
 
 static void
-cacheEntryDestroy(CacheEntry *e)
+cacheEntryDestroy(CacheEntry * e)
 {
     assert(e);
     xfree(e);
@@ -103,14 +103,14 @@ cacheIndexCreate(const char *name)
 }
 
 static void
-cacheIndexDestroy(CacheIndex *idx)
+cacheIndexDestroy(CacheIndex * idx)
 {
     hash_link *hashr = NULL;
     if (idx) {
 	/* destroy hash list contents */
 	for (hashr = hash_first(idx->hash); hashr; hashr = hash_next(idx->hash)) {
 	    hash_remove_link(idx->hash, hashr);
-	    cacheEntryDestroy((CacheEntry*)hashr);
+	    cacheEntryDestroy((CacheEntry *) hashr);
 	}
 	/* destroy the hash table itself */
 	hashFreeMemory(idx->hash);
@@ -119,7 +119,7 @@ cacheIndexDestroy(CacheIndex *idx)
 }
 
 static int
-cacheIndexAddLog(CacheIndex *idx, const char *fname)
+cacheIndexAddLog(CacheIndex * idx, const char *fname)
 {
     FILE *file;
     int scanned_count = 0;
@@ -131,27 +131,26 @@ cacheIndexAddLog(CacheIndex *idx, const char *fname)
 	fprintf(stderr, "cannot open %s: %s\n", fname, strerror(errno));
 	return 0;
     }
-
     scanned_count = cacheIndexScan(idx, fname, file);
 
     fclose(file);
     return scanned_count;
 }
 
 static void
-cacheIndexInitReport(CacheIndex *idx)
+cacheIndexInitReport(CacheIndex * idx)
 {
     assert(idx);
     fprintf(stderr, "%s: bad swap_add:  %d\n",
 	idx->name, idx->bad_add_count);
-    fprintf(stderr, "%s: bad swap_del:  %d\n", 
+    fprintf(stderr, "%s: bad swap_del:  %d\n",
 	idx->name, idx->bad_del_count);
-    fprintf(stderr, "%s: scanned lines: %d\n", 
+    fprintf(stderr, "%s: scanned lines: %d\n",
 	idx->name, idx->scanned_count);
 }
 
 static int
-cacheIndexScan(CacheIndex *idx, const char *fname, FILE *file)
+cacheIndexScan(CacheIndex * idx, const char *fname, FILE * file)
 {
     int count = 0;
     storeSwapLogData s;
@@ -160,24 +159,23 @@ cacheIndexScan(CacheIndex *idx, const char *fname, FILE *file)
 	count++;
 	idx->scanned_count++;
 	/* if (s.op <= SWAP_LOG_NOP || s.op >= SWAP_LOG_MAX)
-	    continue; */
+	 * continue; */
 	if (s.op == SWAP_LOG_ADD) {
 	    CacheEntry *olde = (CacheEntry *) hash_lookup(idx->hash, s.key);
 	    if (olde) {
 		idx->bad_add_count++;
 	    } else {
 		CacheEntry *e = cacheEntryCreate(&s);
-		hash_join(idx->hash, (hash_link*) e);
+		hash_join(idx->hash, (hash_link *) e);
 		idx->count++;
 	    }
-	} else
-	if (s.op == SWAP_LOG_DEL) {
+	} else if (s.op == SWAP_LOG_DEL) {
 	    CacheEntry *olde = (CacheEntry *) hash_lookup(idx->hash, s.key);
 	    if (!olde)
 		idx->bad_del_count++;
 	    else {
 		assert(idx->count);
-		hash_remove_link(idx->hash, (hash_link*) olde);
+		hash_remove_link(idx->hash, (hash_link *) olde);
 		cacheEntryDestroy(olde);
 		idx->count--;
 	    }
@@ -186,13 +184,13 @@ cacheIndexScan(CacheIndex *idx, const char *fname, FILE *file)
 	    exit(-3);
 	}
     }
-    fprintf(stderr, "%s:%d: scanned (size: %d bytes)\n", 
-	fname, count, (int)(count*sizeof(CacheEntry)));
+    fprintf(stderr, "%s:%d: scanned (size: %d bytes)\n",
+	fname, count, (int) (count * sizeof(CacheEntry)));
     return count;
 }
 
 static void
-cacheIndexCmpReport(CacheIndex *idx, int shared_count)
+cacheIndexCmpReport(CacheIndex * idx, int shared_count)
 {
     assert(idx && shared_count <= idx->count);
 
@@ -201,12 +199,12 @@ cacheIndexCmpReport(CacheIndex *idx, int shared_count)
 	idx->count,
 	idx->count - shared_count,
 	shared_count,
-	xpercent(idx->count-shared_count, idx->count),
+	xpercent(idx->count - shared_count, idx->count),
 	xpercent(shared_count, idx->count));
 }
 
 static void
-cacheIndexCmp(CacheIndex *idx1, CacheIndex *idx2)
+cacheIndexCmp(CacheIndex * idx1, CacheIndex * idx2)
 {
     int shared_count = 0;
     int hashed_count = 0;
@@ -256,12 +254,12 @@ main(int argc, char *argv[])
 	const int len = strlen(argv[i]);
 	if (!len)
 	    return usage(argv[0]);
-	if (argv[i][len-1] == ':') {
+	if (argv[i][len - 1] == ':') {
 	    idxCount++;
 	    if (len < 2 || idxCount > 2)
 		return usage(argv[0]);
 	    idx = cacheIndexCreate(argv[i]);
-	    CacheIdx[idxCount-1] = idx;
+	    CacheIdx[idxCount - 1] = idx;
 	} else {
 	    if (!idx)
 		return usage(argv[0]);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: cachemgr.cc,v 1.77 1998/03/07 20:17:44 rousskov Exp $
+ * $Id: cachemgr.cc,v 1.78 1998/03/31 05:37:35 wessels Exp $
  *
  * DEBUG: section 0     CGI Cache Manager
  * AUTHOR: Duane Wessels
@@ -662,7 +662,7 @@ make_pub_auth(cachemgr_request * req)
     /* host | time | user | passwd */
     snprintf(buf, sizeof(buf), "%s|%d|%s|%s",
 	req->hostname,
-	(int)now,
+	(int) now,
 	req->user_name ? req->user_name : "",
 	req->passwd);
     debug(3) fprintf(stderr, "cmgr: pre-encoded for pub: %s\n", buf);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: cbdata.cc,v 1.18 1998/03/30 22:58:51 wessels Exp $
+ * $Id: cbdata.cc,v 1.19 1998/03/31 05:37:36 wessels Exp $
  *
  * DEBUG: section 45    Callback Data Registry
  * AUTHOR: Duane Wessels
@@ -80,7 +80,7 @@ typedef struct _cbdata {
 
 static HASHCMP cbdata_cmp;
 static HASHHASH cbdata_hash;
-static void cbdataReallyFree(cbdata *c);
+static void cbdataReallyFree(cbdata * c);
 
 static int
 cbdata_cmp(const void *p1, const void *p2)
@@ -130,7 +130,7 @@ cbdataAdd(const void *p, mem_type mem_type)
 }
 
 static void
-cbdataReallyFree(cbdata *c)
+cbdataReallyFree(cbdata * c)
 {
     mem_type mem_type = c->mem_type;
     void *p = (void *) c->key;
@@ -139,9 +139,9 @@ cbdataReallyFree(cbdata *c)
     xfree(c);
     debug(45, 3) ("cbdataReallyFree: Freeing %p\n", p);
     if (mem_type == MEM_NONE)
-        xfree(p);
+	xfree(p);
     else
-        memFree(mem_type, p);
+	memFree(mem_type, p);
 }
 
 void
@@ -2,8 +2,9 @@
 
 
 
+
 /*
- * $Id: client.cc,v 1.61 1998/03/28 23:24:42 wessels Exp $
+ * $Id: client.cc,v 1.62 1998/03/31 05:37:36 wessels Exp $
  *
  * DEBUG: section 0     WWW Client
  * AUTHOR: Harvest Derived
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side.cc,v 1.241 1998/03/31 05:35:22 wessels Exp $
+ * $Id: client_side.cc,v 1.242 1998/03/31 05:37:37 wessels Exp $
  *
  * DEBUG: section 33    Client-side Routines
  * AUTHOR: Duane Wessels
@@ -277,7 +277,7 @@ clientGetsOldEntry(StoreEntry * new_entry, StoreEntry * old_entry, request_t * r
      * need to send the old object */
     if (modifiedSince(old_entry, request)) {
 	debug(33, 5) ("clientGetsOldEntry: YES, modified since %d\n",
-		(int) request->ims);
+	    (int) request->ims);
 	return 1;
     }
     debug(33, 5) ("clientGetsOldEntry: NO, new one is fine\n");
@@ -959,7 +959,7 @@ clientSendMoreData(void *data, char *buf, ssize_t size)
 	    size_t k;
 	    if ((k = headersEnd(buf, size))) {
 		safe_free(http->al.headers.reply);
-		http->al.headers.reply = xcalloc(k+1, 1);
+		http->al.headers.reply = xcalloc(k + 1, 1);
 		xstrncpy(http->al.headers.reply, buf, k);
 	    }
 	}
@@ -1539,7 +1539,7 @@ parseHttpRequest(ConnStateData * conn, method_t * method_p, int *status,
 	*status = -1;
 	return http;
 #else
-	http_ver = (float) 0.9; /* wild guess */
+	http_ver = (float) 0.9;	/* wild guess */
 #endif
     } else
 	http_ver = (float) atof(token + 5);
@@ -2194,4 +2194,3 @@ clientHttpConnectionsClose(void)
     }
     NHttpSockets = 0;
 }
-
@@ -1,6 +1,7 @@
 
+
 /*
- * $Id: comm.cc,v 1.241 1998/03/31 05:34:46 wessels Exp $
+ * $Id: comm.cc,v 1.242 1998/03/31 05:37:38 wessels Exp $
  *
  * DEBUG: section 5     Socket Functions
  * AUTHOR: Harvest Derived
@@ -1,6 +1,6 @@
 
 /*
- * $Id: errorpage.cc,v 1.123 1998/03/28 05:24:34 wessels Exp $
+ * $Id: errorpage.cc,v 1.124 1998/03/31 05:37:39 wessels Exp $
  *
  * DEBUG: section 4     Error Generation
  * AUTHOR: Duane Wessels
@@ -53,9 +53,10 @@ typedef struct {
  * to give you more control on the format
  */
 static const struct {
-    int type; /* and page_id */
+    int type;			/* and page_id */
     const char *text;
 } error_hard_text[] = {
+
     {
 	ERR_SQUID_SIGNATURE,
 	    "\n<br clear=\"all\">\n"
@@ -95,19 +96,19 @@ errorInitialize(void)
     int i;
     const char *text;
     error_page_count = ERR_MAX + ErrorDynamicPages.count;
-    error_text = xcalloc(error_page_count, sizeof(char*));
+    error_text = xcalloc(error_page_count, sizeof(char *));
     for (i = ERR_NONE + 1; i < error_page_count; i++) {
 	safe_free(error_text[i]);
 	/* hard-coded ? */
 	if ((text = errorFindHardText(i)))
 	    error_text[i] = xstrdup(text);
 	else
-	/* precompiled ? */
+	    /* precompiled ? */
 	if (i < ERR_MAX)
 	    error_text[i] = errorLoadText(err_type_str[i]);
 	/* dynamic */
 	else {
-	    ErrorDynamicPageInfo *info = ErrorDynamicPages.items[i-ERR_MAX];
+	    ErrorDynamicPageInfo *info = ErrorDynamicPages.items[i - ERR_MAX];
 	    assert(info && info->id == i && info->page_name);
 	    error_text[i] = errorLoadText(info->page_name);
 	}
@@ -179,7 +180,7 @@ errorDynamicPageInfoCreate(int id, const char *page_name)
 }
 
 static void
-errorDynamicPageInfoDestroy(ErrorDynamicPageInfo *info)
+errorDynamicPageInfoDestroy(ErrorDynamicPageInfo * info)
 {
     assert(info);
     xfree(info->page_name);
@@ -189,8 +190,8 @@ errorDynamicPageInfoDestroy(ErrorDynamicPageInfo *info)
 int
 errorReservePageId(const char *page_name)
 {
-    ErrorDynamicPageInfo *info = 
-	errorDynamicPageInfoCreate(ERR_MAX + ErrorDynamicPages.count, page_name);
+    ErrorDynamicPageInfo *info =
+    errorDynamicPageInfoCreate(ERR_MAX + ErrorDynamicPages.count, page_name);
     stackPush(&ErrorDynamicPages, info);
     return info->id;
 }
@@ -216,7 +217,7 @@ ErrorState *
 errorCon(int type, http_status status)
 {
     ErrorState *err = xcalloc(1, sizeof(ErrorState));
-    err->page_id = type; /* has to be reset manually if needed */
+    err->page_id = type;	/* has to be reset manually if needed */
     err->type = type;
     err->http_status = status;
     return err;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ftp.cc,v 1.215 1998/03/28 20:31:51 wessels Exp $
+ * $Id: ftp.cc,v 1.216 1998/03/31 05:37:40 wessels Exp $
  *
  * DEBUG: section 9     File Transfer Protocol (FTP)
  * AUTHOR: Harvest Derived
@@ -1574,7 +1574,7 @@ ftpReadPasv(FtpStateData * ftpState)
     }
     port = ((p1 << 8) + p2);
     if (0 == port) {
-	debug(9,1)("ftpReadPasv: Invalid PASV reply: %s\n", buf);
+	debug(9, 1) ("ftpReadPasv: Invalid PASV reply: %s\n", buf);
 	ftpSendPort(ftpState);
 	return;
     }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: globals.h,v 1.46 1998/03/31 05:34:47 wessels Exp $
+ * $Id: globals.h,v 1.47 1998/03/31 05:37:41 wessels Exp $
  */
 
 extern FILE *debug_log;		/* NULL */
@@ -81,7 +81,7 @@ extern struct timeval current_time;
 extern struct timeval squid_start;
 extern time_t squid_curtime;	/* 0 */
 extern int shutting_down;	/* 0 */
-extern int reconfiguring; 	/* 0 */
+extern int reconfiguring;	/* 0 */
 extern int store_rebuilding;	/* 1 */
 extern int store_swap_size;	/* 0 */
 extern unsigned long store_mem_size;	/* 0 */
@@ -84,13 +84,14 @@ enum {
     HTCP_END
 };
 
-static const char *const htcpOpcodeStr[] = {
-	"HTCP_NOP",
-	"HTCP_TST",
-	"HTCP_MON",
-	"HTCP_SET",
-	"HTCP_CLR",
-	"HTCP_END"
+static const char *const htcpOpcodeStr[] =
+{
+    "HTCP_NOP",
+    "HTCP_TST",
+    "HTCP_MON",
+    "HTCP_SET",
+    "HTCP_CLR",
+    "HTCP_END"
 };
 
 /*
@@ -246,7 +247,7 @@ htcpBuildPacket(htcpStuff * stuff, ssize_t * len)
     if (s < 0)
 	return NULL;
     off += s;
-    hdr.length = htons((u_short)off);
+    hdr.length = htons((u_short) off);
     hdr.major = 0;
     hdr.minor = 0;
     xmemcpy(buf, &hdr, hdr_sz);
@@ -309,139 +310,139 @@ htcpFreeSpecifier(htcpSpecifier * s)
 int
 htcpUnpackCountstr(char *buf, int sz, char **str)
 {
-	u_short l;
-	debug(31,1)("htcpUnpackCountstr: sz = %d\n", sz);
-	if (sz < 2) {
-	    debug(31,1)("htcpUnpackCountstr: sz < 2\n");
-	    return -1;
-	}
-	xmemcpy(&l, buf, 2);
-	l = ntohl(l);
-	buf += 2;
-	sz -= 2;
-	debug(31,1)("htcpUnpackCountstr: LENGTH = %d\n", (int) l);
-	if (sz < l) {
-	    debug(31,1)("htcpUnpackCountstr: sz(%d) < l(%d)\n", sz, l);
-	    return -1;
-	}
-	if (str) {
-		*str = xmalloc(l+1);
-		xstrncpy(*str, buf, l+1);
-		debug(31,1)("htcpUnpackCountstr: TEXT = %s\n", *str);
-	}
-	return (int)l+2;
+    u_short l;
+    debug(31, 1) ("htcpUnpackCountstr: sz = %d\n", sz);
+    if (sz < 2) {
+	debug(31, 1) ("htcpUnpackCountstr: sz < 2\n");
+	return -1;
+    }
+    xmemcpy(&l, buf, 2);
+    l = ntohl(l);
+    buf += 2;
+    sz -= 2;
+    debug(31, 1) ("htcpUnpackCountstr: LENGTH = %d\n", (int) l);
+    if (sz < l) {
+	debug(31, 1) ("htcpUnpackCountstr: sz(%d) < l(%d)\n", sz, l);
+	return -1;
+    }
+    if (str) {
+	*str = xmalloc(l + 1);
+	xstrncpy(*str, buf, l + 1);
+	debug(31, 1) ("htcpUnpackCountstr: TEXT = %s\n", *str);
+    }
+    return (int) l + 2;
 }
 
 
 htcpSpecifier *
 htcpUnpackSpecifier(char *buf, int sz)
 {
-	htcpSpecifier *s = xcalloc(1, sizeof(htcpSpecifier));
-	int o;
-
-	o = htcpUnpackCountstr(buf, sz, &s->method);
-	if (o < 0) {
-		debug(31,1)("htcpUnpackSpecifier: failed to unpack METHOD\n");
-		htcpFreeSpecifier(s);
-		return NULL;
-	}
-	buf += o;
-	sz -= o;
-
-	o = htcpUnpackCountstr(buf, sz, &s->uri);
-	if (o < 0) {
-		debug(31,1)("htcpUnpackSpecifier: failed to unpack URI\n");
-		htcpFreeSpecifier(s);
-		return NULL;
-	}
-	buf += o;
-	sz -= o;
-
-	o = htcpUnpackCountstr(buf, sz, &s->version);
-	if (o < 0) {
-		debug(31,1)("htcpUnpackSpecifier: failed to unpack VERSION\n");
-		htcpFreeSpecifier(s);
-		return NULL;
-	}
-	buf += o;
-	sz -= o;
-
-	o = htcpUnpackCountstr(buf, sz, &s->req_hdrs);
-	if (o < 0) {
-		debug(31,1)("htcpUnpackSpecifier: failed to unpack REQ-HDRS\n");
-		htcpFreeSpecifier(s);
-		return NULL;
-	}
-	buf += o;
-	sz -= o;
+    htcpSpecifier *s = xcalloc(1, sizeof(htcpSpecifier));
+    int o;
 
-	return s;
+    o = htcpUnpackCountstr(buf, sz, &s->method);
+    if (o < 0) {
+	debug(31, 1) ("htcpUnpackSpecifier: failed to unpack METHOD\n");
+	htcpFreeSpecifier(s);
+	return NULL;
+    }
+    buf += o;
+    sz -= o;
+
+    o = htcpUnpackCountstr(buf, sz, &s->uri);
+    if (o < 0) {
+	debug(31, 1) ("htcpUnpackSpecifier: failed to unpack URI\n");
+	htcpFreeSpecifier(s);
+	return NULL;
+    }
+    buf += o;
+    sz -= o;
+
+    o = htcpUnpackCountstr(buf, sz, &s->version);
+    if (o < 0) {
+	debug(31, 1) ("htcpUnpackSpecifier: failed to unpack VERSION\n");
+	htcpFreeSpecifier(s);
+	return NULL;
+    }
+    buf += o;
+    sz -= o;
+
+    o = htcpUnpackCountstr(buf, sz, &s->req_hdrs);
+    if (o < 0) {
+	debug(31, 1) ("htcpUnpackSpecifier: failed to unpack REQ-HDRS\n");
+	htcpFreeSpecifier(s);
+	return NULL;
+    }
+    buf += o;
+    sz -= o;
+
+    return s;
 }
 
 static void
 htcpHandleNop(char *buf, int sz, struct sockaddr_in *from)
 {
-	debug(31,1)("htcpHandleNop: Unimplemented\n");
+    debug(31, 1) ("htcpHandleNop: Unimplemented\n");
 }
 
 static void
 htcpHandleTst(char *buf, int sz, struct sockaddr_in *from)
 {
-	/* buf should be a SPECIFIER */
-	htcpSpecifier *s = htcpUnpackSpecifier(buf, sz);
-	if (NULL == s) {
-		debug(31,1)("htcpHandleTst: htcpUnpackSpecifier failed\n");
-		return;
-	}
-	debug(31,1)("htcpHandleTst: %s %s %s\n",
-		s->method,
-		s->uri,
-		s->version);
-	debug(31,1)("htcpHandleTst: %s\n", s->req_hdrs);
+    /* buf should be a SPECIFIER */
+    htcpSpecifier *s = htcpUnpackSpecifier(buf, sz);
+    if (NULL == s) {
+	debug(31, 1) ("htcpHandleTst: htcpUnpackSpecifier failed\n");
+	return;
+    }
+    debug(31, 1) ("htcpHandleTst: %s %s %s\n",
+	s->method,
+	s->uri,
+	s->version);
+    debug(31, 1) ("htcpHandleTst: %s\n", s->req_hdrs);
 }
 
 static void
 htcpHandleMon(char *buf, int sz, struct sockaddr_in *from)
 {
-	debug(31,1)("htcpHandleMon: Unimplemented\n");
+    debug(31, 1) ("htcpHandleMon: Unimplemented\n");
 }
 
 static void
 htcpHandleSet(char *buf, int sz, struct sockaddr_in *from)
 {
-	debug(31,1)("htcpHandleSet: Unimplemented\n");
+    debug(31, 1) ("htcpHandleSet: Unimplemented\n");
 }
 
 static void
 htcpHandleData(char *buf, int sz, struct sockaddr_in *from)
 {
     htcpDataHeader hdr;
     if (sz < sizeof(htcpDataHeader)) {
-	debug(31,0)("htcpHandleData: msg size less than htcpDataHeader size\n");
+	debug(31, 0) ("htcpHandleData: msg size less than htcpDataHeader size\n");
 	return;
     }
     xmemcpy(&hdr, buf, sizeof(htcpDataHeader));
     hdr.length = ntohs(hdr.length);
     hdr.msg_id = ntohs(hdr.msg_id);
-    debug(31,1)("htcpHandleData: length = %d\n", (int) hdr.length);
+    debug(31, 1) ("htcpHandleData: length = %d\n", (int) hdr.length);
     if (hdr.opcode < HTCP_NOP || hdr.opcode > HTCP_END) {
-	debug(31,0)("htcpHandleData: opcode %d out of range\n",
+	debug(31, 0) ("htcpHandleData: opcode %d out of range\n",
 	    (int) hdr.opcode);
 	return;
     }
-    debug(31,1)("htcpHandleData: opcode = %d %s\n",
+    debug(31, 1) ("htcpHandleData: opcode = %d %s\n",
 	(int) hdr.opcode, htcpOpcodeStr[hdr.opcode]);
-    debug(31,1)("htcpHandleData: response = %d\n", (int) hdr.response);
-    debug(31,1)("htcpHandleData: F1 = %d\n", (int) hdr.F1);
-    debug(31,1)("htcpHandleData: RR = %d\n", (int) hdr.RR);
-    debug(31,1)("htcpHandleData: msg_id = %#x\n", (int) hdr.msg_id);
+    debug(31, 1) ("htcpHandleData: response = %d\n", (int) hdr.response);
+    debug(31, 1) ("htcpHandleData: F1 = %d\n", (int) hdr.F1);
+    debug(31, 1) ("htcpHandleData: RR = %d\n", (int) hdr.RR);
+    debug(31, 1) ("htcpHandleData: msg_id = %#x\n", (int) hdr.msg_id);
     if (sz < hdr.length) {
-	debug(31,0)("htcpHandle: sz < hdr.length\n");
+	debug(31, 0) ("htcpHandle: sz < hdr.length\n");
 	return;
     }
     buf += sizeof(htcpDataHeader);
     sz -= sizeof(htcpDataHeader);
-    switch(hdr.opcode) {
+    switch (hdr.opcode) {
     case HTCP_NOP:
 	htcpHandleNop(buf, sz, from);
 	break;
@@ -465,16 +466,16 @@ htcpHandle(char *buf, int sz, struct sockaddr_in *from)
 {
     htcpHeader htcpHdr;
     if (sz < sizeof(htcpHeader)) {
-	debug(31,0)("htcpHandle: msg size less than htcpHeader size\n");
+	debug(31, 0) ("htcpHandle: msg size less than htcpHeader size\n");
 	return;
     }
     xmemcpy(&htcpHdr, buf, sizeof(htcpHeader));
     htcpHdr.length = ntohs(htcpHdr.length);
-    debug(31,1)("htcpHandle: htcpHdr.length = %d\n", (int) htcpHdr.length);
-    debug(31,1)("htcpHandle: htcpHdr.major = %d\n", (int) htcpHdr.major);
-    debug(31,1)("htcpHandle: htcpHdr.minor = %d\n", (int) htcpHdr.minor);
+    debug(31, 1) ("htcpHandle: htcpHdr.length = %d\n", (int) htcpHdr.length);
+    debug(31, 1) ("htcpHandle: htcpHdr.major = %d\n", (int) htcpHdr.major);
+    debug(31, 1) ("htcpHandle: htcpHdr.minor = %d\n", (int) htcpHdr.minor);
     if (sz != htcpHdr.length) {
-	debug(31,0)("htcpHandle: sz != htcpHdr.length\n");
+	debug(31, 0) ("htcpHandle: sz != htcpHdr.length\n");
 	return;
     }
     buf += sizeof(htcpHeader);
@@ -536,39 +537,39 @@ htcpInit(void)
 /*  
  * htcpSocketShutdown only closes the 'in' socket if it is
  * different than the 'out' socket.
- */ 
+ */
 void
 htcpSocketShutdown(void)
-{   
+{
     if (htcpInSocket < 0)
-        return;
-    if (htcpInSocket != htcpOutSocket) { 
-        debug(12, 1) ("FD %d Closing HTCP socket\n", htcpInSocket);
-        comm_close(htcpInSocket);
-    }       
+	return;
+    if (htcpInSocket != htcpOutSocket) {
+	debug(12, 1) ("FD %d Closing HTCP socket\n", htcpInSocket);
+	comm_close(htcpInSocket);
+    }
     /*      
      * Here we set 'htcpInSocket' to -1 even though the HTCP 'in'
      * and 'out' sockets might be just one FD.  This prevents this
      * function from executing repeatedly.  When we are really ready to
      * exit or restart, main will comm_close the 'out' descriptor.
-     */     
+     */
     htcpInSocket = -1;
     /*      
      * Normally we only write to the outgoing HTCP socket, but
      * we also have a read handler there to catch messages sent
      * to that specific interface.  During shutdown, we must
      * disable reading on the outgoing socket.
-     */     
+     */
     assert(htcpOutSocket > -1);
     commSetSelect(htcpOutSocket, COMM_SELECT_READ, NULL, NULL, 0);
 }
 
-void    
+void
 htcpSocketClose(void)
 {
     htcpSocketShutdown();
     if (htcpOutSocket > -1) {
-        debug(12, 1) ("FD %d Closing HTCP socket\n", htcpOutSocket);
-        comm_close(htcpOutSocket);
-    }   
-}   
+	debug(12, 1) ("FD %d Closing HTCP socket\n", htcpOutSocket);
+	comm_close(htcpOutSocket);
+    }
+}
@@ -1,6 +1,6 @@
 
 /*
- * $Id: http.cc,v 1.260 1998/03/31 05:35:23 wessels Exp $
+ * $Id: http.cc,v 1.261 1998/03/31 05:37:42 wessels Exp $
  *
  * DEBUG: section 11    Hypertext Transfer Protocol (HTTP)
  * AUTHOR: Harvest Derived
@@ -470,7 +470,7 @@ httpReadReply(int fd, void *data)
 	    err->xerrno = errno;
 	    err->request = requestLink(httpState->orig_request);
 	    errorAppendEntry(entry, err);
-	   comm_close(fd);
+	    comm_close(fd);
 	} else {
 	    storeAbort(entry, 0);
 	    comm_close(fd);
@@ -626,7 +626,7 @@ httpBuildRequestHeader(request_t * request,
 	if (l > 4096)
 	    l = 4096;
 	if (0 == l)
-	   break;
+	    break;
 	xstrncpy(xbuf, t, l);
 	debug(11, 5) ("httpBuildRequestHeader: %s\n", xbuf);
 	if (strncasecmp(xbuf, "Proxy-Connection:", 17) == 0)
@@ -47,7 +47,7 @@ icpUdpReply(int fd, void *data)
 	} else {
 	    Counter.icp.pkts_sent++;
 	    if (queue->logcode == LOG_UDP_HIT)
-	        Counter.icp.hits_sent++;
+		Counter.icp.hits_sent++;
 	    kb_incr(&Counter.icp.kbytes_sent, (size_t) x);
 	}
 	UdpQueueHead = queue->next;
@@ -202,7 +202,7 @@ icpHandleIcpV2(int fd, struct sockaddr_in from, char *buf, int len)
 		 * count this DENIED query in the clientdb, even though
 		 * we're not sending an ICP reply...
 		 */
-		clientdbUpdate(from.sin_addr, LOG_UDP_DENIED, Config.Port.icp,0);
+		clientdbUpdate(from.sin_addr, LOG_UDP_DENIED, Config.Port.icp, 0);
 	    } else {
 		reply = icpCreateMessage(ICP_DENIED, 0, url, header.reqnum, 0);
 		icpUdpSend(fd, &from, reply, LOG_UDP_DENIED, icp_request->protocol);
@@ -24,8 +24,8 @@ icpHandleIcpV3(int fd, struct sockaddr_in from, char *buf, int len)
 
     method = header.reqnum >> 24;
     /* Squid-1.1 doesn't use the "method bits" for METHOD_GET */
-    if (METHOD_NONE == method || METHOD_ENUM_END <= method) 
-        method = METHOD_GET;
+    if (METHOD_NONE == method || METHOD_ENUM_END <= method)
+	method = METHOD_GET;
     switch (header.opcode) {
     case ICP_QUERY:
 	/* We have a valid packet */
@@ -46,7 +46,7 @@ icpHandleIcpV3(int fd, struct sockaddr_in from, char *buf, int len)
 		 * count this DENIED query in the clientdb, even though
 		 * we're not sending an ICP reply...
 		 */
-		clientdbUpdate(from.sin_addr, LOG_UDP_DENIED, Config.Port.icp,0);
+		clientdbUpdate(from.sin_addr, LOG_UDP_DENIED, Config.Port.icp, 0);
 	    } else {
 		reply = icpCreateMessage(ICP_DENIED, 0, url, header.reqnum, 0);
 		icpUdpSend(fd, &from, reply, LOG_UDP_DENIED, icp_request->protocol);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ident.cc,v 1.39 1998/03/27 22:44:23 wessels Exp $
+ * $Id: ident.cc,v 1.40 1998/03/31 05:37:45 wessels Exp $
  *
  * DEBUG: section 30    Ident (RFC 931)
  * AUTHOR: Duane Wessels
@@ -50,7 +50,7 @@ static void
 identTimeout(int fd, void *data)
 {
     ConnStateData *connState = data;
-    debug(30,3)("identTimeout: FD %d, %s\n", fd,
+    debug(30, 3) ("identTimeout: FD %d, %s\n", fd,
 	inet_ntoa(connState->peer.sin_addr));
     comm_close(fd);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: mime.cc,v 1.56 1998/03/31 05:35:24 wessels Exp $
+ * $Id: mime.cc,v 1.57 1998/03/31 05:37:45 wessels Exp $
  *
  * DEBUG: section 25    MIME Parsing
  * AUTHOR: Harvest Derived
@@ -184,6 +184,7 @@ mime_headers_end(const char *mime)
 	end += (end == p1 ? 3 : 2);
     return (char *) end;
 }
+
 #endif
 
 size_t
@@ -192,32 +193,32 @@ headersEnd(const char *mime, size_t l)
     size_t e = 0;
     int state = 0;
     while (e < l && state < 3) {
-        switch (state) {
-        case 0:
-            if ('\n' == mime[e]) 
-                state = 1;
-            break;
-        case 1:
-            if ('\r' == mime[e])
-                state = 2;
-            else if ('\n' == mime[e])
-                state = 3;
-            else
-                state = 0;
-            break;
-        case 2:
-            if ('\n' == mime[e])
-                state = 3;
-            else
-                state = 0;
-            break;
-        default:
-                break;
-        }
-        e++;
+	switch (state) {
+	case 0:
+	    if ('\n' == mime[e])
+		state = 1;
+	    break;
+	case 1:
+	    if ('\r' == mime[e])
+		state = 2;
+	    else if ('\n' == mime[e])
+		state = 3;
+	    else
+		state = 0;
+	    break;
+	case 2:
+	    if ('\n' == mime[e])
+		state = 3;
+	    else
+		state = 0;
+	    break;
+	default:
+	    break;
+	}
+	e++;
     }
     if (3 == state)
-        return e;
+	return e;
     return 0;
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: neighbors.cc,v 1.186 1998/03/28 18:37:07 wessels Exp $
+ * $Id: neighbors.cc,v 1.187 1998/03/31 05:37:47 wessels Exp $
  *
  * DEBUG: section 15    Neighbor Routines
  * AUTHOR: Harvest Derived
@@ -444,11 +444,11 @@ neighborsUdpPing(request_t * request,
 
 #if USE_HTCP
 	if (EBIT_TEST(p->options, NEIGHBOR_HTCP)) {
-	    debug(15, 0)("neighborsUdpPing: sending HTCP query\n");
+	    debug(15, 0) ("neighborsUdpPing: sending HTCP query\n");
 	    htcpQuery(entry, request, p);
 	} else
 #endif
- if (p->icp_port == echo_port) {
+	if (p->icp_port == echo_port) {
 	    debug(15, 4) ("neighborsUdpPing: Looks like a dumb cache, send DECHO ping\n");
 	    echo_hdr.reqnum = reqnum;
 	    query = icpCreateMessage(ICP_DECHO, 0, url, reqnum, 0);
@@ -891,10 +891,10 @@ extern int ipcCreate(int type,
 
 /* CacheDigest */
 extern CacheDigest *cacheDigestCreate(int capacity);
-extern void cacheDigestDestroy(CacheDigest *cd);
-extern int cacheDigestTest(const CacheDigest *cd, const cache_key *key);
-extern void cacheDigestAdd(CacheDigest *cd, const cache_key *key);
-extern void cacheDigestDel(CacheDigest *cd, const cache_key *key);
+extern void cacheDigestDestroy(CacheDigest * cd);
+extern int cacheDigestTest(const CacheDigest * cd, const cache_key * key);
+extern void cacheDigestAdd(CacheDigest * cd, const cache_key * key);
+extern void cacheDigestDel(CacheDigest * cd, const cache_key * key);
 
 /*
  * prototypes for system functions missing from system includes
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ssl.cc,v 1.76 1998/03/27 22:44:25 wessels Exp $
+ * $Id: ssl.cc,v 1.77 1998/03/31 05:37:49 wessels Exp $
  *
  * DEBUG: section 26    Secure Sockets Layer Proxy
  * AUTHOR: Duane Wessels
@@ -344,10 +344,10 @@ sslConnectDone(int fdnotused, int status, void *data)
 	    sslProxyConnected(sslState->server.fd, sslState);
 	else
 	    sslConnected(sslState->server.fd, sslState);
-    commSetTimeout(sslState->server.fd,
-	Config.Timeout.read,
-	sslTimeout,
-	sslState);
+	commSetTimeout(sslState->server.fd,
+	    Config.Timeout.read,
+	    sslTimeout,
+	    sslState);
     }
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: stat.cc,v 1.220 1998/03/28 23:24:49 wessels Exp $
+ * $Id: stat.cc,v 1.221 1998/03/31 05:37:50 wessels Exp $
  *
  * DEBUG: section 18    Cache Manager Statistics
  * AUTHOR: Harvest Derived
@@ -1076,4 +1076,5 @@ statGraphDump(StoreEntry * e)
     GENGRAPH(select_loops, "select_loops", "System Select Loop calls/sec");
     GENGRAPH(cputime, "cputime", "CPU utilisation");
 }
+
 #endif /* STAT_GRAPHS */
@@ -425,6 +425,6 @@ storePendingNClients(const StoreEntry * e)
 	npend++;
     }
 #endif
-    debug(20,3)("storePendingNClients: returning %d\n", npend);
+    debug(20, 3) ("storePendingNClients: returning %d\n", npend);
     return npend;
 }
@@ -1,5 +1,6 @@
 
 
+
 struct _acl_ip_data {
     struct in_addr addr1;	/* if addr2 non-zero then its a range */
     struct in_addr addr2;
@@ -1202,9 +1203,9 @@ struct _ClientInfo {
 
 struct _CacheDigest {
     /* public, read-only */
-    char *mask;       /* bit mask */
-    size_t mask_size; /* mask size in bytes */
-    int capacity;     /* expected maximum for .count, not a hard limit */
-    int count;        /* number of digested entries */
-    int del_count;    /* number of deletions performed so far */
+    char *mask;			/* bit mask */
+    size_t mask_size;		/* mask size in bytes */
+    int capacity;		/* expected maximum for .count, not a hard limit */
+    int count;			/* number of digested entries */
+    int del_count;		/* number of deletions performed so far */
 };
@@ -1,5 +1,6 @@
+
 /*
- * $Id: test_cache_digest.cc,v 1.4 1998/03/31 00:10:10 rousskov Exp $
+ * $Id: test_cache_digest.cc,v 1.5 1998/03/31 05:37:52 wessels Exp $
  *
  * AUTHOR: Alex Rousskov
  *
@@ -37,10 +38,10 @@ typedef struct {
     const char *name;
     hash_table *hash;
     CacheDigest *digest;
-    int count;          /* #currently cached entries */
-    int scanned_count;  /* #scanned entries */
-    int bad_add_count;  /* #duplicate adds */
-    int bad_del_count;  /* #dels with no prior add */
+    int count;			/* #currently cached entries */
+    int scanned_count;		/* #scanned entries */
+    int bad_add_count;		/* #duplicate adds */
+    int bad_del_count;		/* #dels with no prior add */
 } CacheIndex;
 
 
@@ -68,34 +69,34 @@ const char *RequestMethodStr[] =
 
 static CacheIndex *Peer = NULL;
 
-static int cacheIndexScanCleanPrefix(CacheIndex *idx, const char *fname, FILE *file);
-static int cacheIndexScanAccessLog(CacheIndex *idx, const char *fname, FILE *file);
+static int cacheIndexScanCleanPrefix(CacheIndex * idx, const char *fname, FILE * file);
+static int cacheIndexScanAccessLog(CacheIndex * idx, const char *fname, FILE * file);
 
 /* copied from url.c */
 static method_t
 cacheIndexParseMethod(const char *s)
 {
     if (strcasecmp(s, "GET") == 0) {
-        return METHOD_GET;
+	return METHOD_GET;
     } else if (strcasecmp(s, "POST") == 0) {
-        return METHOD_POST;
+	return METHOD_POST;
     } else if (strcasecmp(s, "PUT") == 0) {
-        return METHOD_PUT;
+	return METHOD_PUT;
     } else if (strcasecmp(s, "HEAD") == 0) {
-        return METHOD_HEAD;
+	return METHOD_HEAD;
     } else if (strcasecmp(s, "CONNECT") == 0) {
-        return METHOD_CONNECT;
+	return METHOD_CONNECT;
     } else if (strcasecmp(s, "TRACE") == 0) {
-        return METHOD_TRACE;
+	return METHOD_TRACE;
     } else if (strcasecmp(s, "PURGE") == 0) {
-        return METHOD_PURGE;
+	return METHOD_PURGE;
     }
     return METHOD_NONE;
 }
 
 
 static CacheEntry *
-cacheEntryCreate(const storeSwapLogData *s)
+cacheEntryCreate(const storeSwapLogData * s)
 {
     CacheEntry *e = xcalloc(1, sizeof(CacheEntry));
     assert(s);
@@ -106,7 +107,7 @@ cacheEntryCreate(const storeSwapLogData *s)
 }
 
 static void
-cacheEntryDestroy(CacheEntry *e)
+cacheEntryDestroy(CacheEntry * e)
 {
     assert(e);
     xfree(e);
@@ -127,14 +128,14 @@ cacheIndexCreate(const char *name)
 }
 
 static void
-cacheIndexDestroy(CacheIndex *idx)
+cacheIndexDestroy(CacheIndex * idx)
 {
     hash_link *hashr = NULL;
     if (idx) {
 	/* destroy hash list contents */
 	for (hashr = hash_first(idx->hash); hashr; hashr = hash_next(idx->hash)) {
 	    hash_remove_link(idx->hash, hashr);
-	    cacheEntryDestroy((CacheEntry*)hashr);
+	    cacheEntryDestroy((CacheEntry *) hashr);
 	}
 	/* destroy the hash table itself */
 	hashFreeMemory(idx->hash);
@@ -146,25 +147,25 @@ cacheIndexDestroy(CacheIndex *idx)
 
 /* makes digest based on currently hashed entries */
 static void
-cacheIndexInitDigest(CacheIndex *idx)
+cacheIndexInitDigest(CacheIndex * idx)
 {
     hash_link *hashr = NULL;
     struct timeval t_start, t_end;
     assert(idx && !idx->digest);
     fprintf(stderr, "%s: init-ing digest with %d entries\n", idx->name, idx->count);
-    idx->digest = cacheDigestCreate(2*idx->count); /* 50% utilization */
+    idx->digest = cacheDigestCreate(2 * idx->count);	/* 50% utilization */
     gettimeofday(&t_start, NULL);
     for (hashr = hash_first(idx->hash); hashr; hashr = hash_next(idx->hash)) {
 	cacheDigestAdd(idx->digest, hashr->key);
     }
     gettimeofday(&t_end, NULL);
     assert(idx->digest->count == idx->count);
-    fprintf(stderr, "%s: init-ed  digest with %d entries\n", 
+    fprintf(stderr, "%s: init-ed  digest with %d entries\n",
 	idx->name, idx->digest->count);
     fprintf(stderr, "%s: init took: %f sec, %f sec/M\n",
 	idx->name,
 	tvSubDsec(t_start, t_end),
-	(double)1e6*tvSubDsec(t_start, t_end)/idx->count);
+	(double) 1e6 * tvSubDsec(t_start, t_end) / idx->count);
     /* check how long it takes to traverse the hash */
     gettimeofday(&t_start, NULL);
     for (hashr = hash_first(idx->hash); hashr; hashr = hash_next(idx->hash)) {
@@ -173,11 +174,11 @@ cacheIndexInitDigest(CacheIndex *idx)
     fprintf(stderr, "%s: hash scan took: %f sec, %f sec/M\n",
 	idx->name,
 	tvSubDsec(t_start, t_end),
-	(double)1e6*tvSubDsec(t_start, t_end)/idx->count);
+	(double) 1e6 * tvSubDsec(t_start, t_end) / idx->count);
 }
 
 static int
-cacheIndexAddLog(CacheIndex *idx, const char *fname)
+cacheIndexAddLog(CacheIndex * idx, const char *fname)
 {
     FILE *file;
     int scanned_count = 0;
@@ -195,20 +196,20 @@ cacheIndexAddLog(CacheIndex *idx, const char *fname)
 }
 
 static void
-cacheIndexInitReport(CacheIndex *idx)
+cacheIndexInitReport(CacheIndex * idx)
 {
     assert(idx);
     fprintf(stderr, "%s: bad swap_add:  %d\n",
 	idx->name, idx->bad_add_count);
-    fprintf(stderr, "%s: bad swap_del:  %d\n", 
+    fprintf(stderr, "%s: bad swap_del:  %d\n",
 	idx->name, idx->bad_del_count);
-    fprintf(stderr, "%s: scanned lines: %d\n", 
+    fprintf(stderr, "%s: scanned lines: %d\n",
 	idx->name, idx->scanned_count);
 }
 
 #if 0
 static int
-cacheIndexGetLogEntry(CacheIndex *idx, storeSwapLogData *s)
+cacheIndexGetLogEntry(CacheIndex * idx, storeSwapLogData * s)
 {
     if (!idx->has_log_entry)
 	cacheIndexStepLogEntry();
@@ -220,7 +221,7 @@ cacheIndexGetLogEntry(CacheIndex *idx, storeSwapLogData *s)
 }
 
 static int
-cacheIndexStepLogEntry(CacheIndex *idx)
+cacheIndexStepLogEntry(CacheIndex * idx)
 {
     if (fread(&idx->log_entry_buf, sizeof(idx->log_entry_buf), 1, idx->log) == 1) {
 	int op = (int) idx->log_entry_buf.op;
@@ -235,7 +236,7 @@ cacheIndexStepLogEntry(CacheIndex *idx)
 }
 
 static int
-cacheIndexScan(CacheIndex *idx, const char *fname, FILE *file)
+cacheIndexScan(CacheIndex * idx, const char *fname, FILE * file)
 {
     int count = 0;
     int del_count = 0;
@@ -250,17 +251,16 @@ cacheIndexScan(CacheIndex *idx, const char *fname, FILE *file)
 		idx->bad_add_count++;
 	    } else {
 		CacheEntry *e = cacheEntryCreate(&s);
-		hash_join(idx->hash, (hash_link*) e);
+		hash_join(idx->hash, (hash_link *) e);
 		idx->count++;
 	    }
-	} else
-	if (s.op == SWAP_LOG_DEL) {
+	} else if (s.op == SWAP_LOG_DEL) {
 	    CacheEntry *olde = (CacheEntry *) hash_lookup(idx->hash, s.key);
 	    if (!olde)
 		idx->bad_del_count++;
 	    else {
 		assert(idx->count);
-		hash_remove_link(idx->hash, (hash_link*) olde);
+		hash_remove_link(idx->hash, (hash_link *) olde);
 		cacheEntryDestroy(olde);
 		idx->count--;
 	    }
@@ -271,14 +271,14 @@ cacheIndexScan(CacheIndex *idx, const char *fname, FILE *file)
 	}
     }
     fprintf(stderr, "%s scanned %d entries, alloc: %d bytes\n",
-	fname, count, 
-	(int)(count*sizeof(CacheEntry)));
+	fname, count,
+	(int) (count * sizeof(CacheEntry)));
     return count;
 }
 #endif
 
 static int
-cacheIndexScanCleanPrefix(CacheIndex *idx, const char *fname, FILE *file)
+cacheIndexScanCleanPrefix(CacheIndex * idx, const char *fname, FILE * file)
 {
     int count = 0;
     storeSwapLogData s;
@@ -292,20 +292,19 @@ cacheIndexScanCleanPrefix(CacheIndex *idx, const char *fname, FILE *file)
 		idx->bad_add_count++;
 	    } else {
 		CacheEntry *e = cacheEntryCreate(&s);
-		hash_join(idx->hash, (hash_link*) e);
+		hash_join(idx->hash, (hash_link *) e);
 		idx->count++;
 	    }
-	} else
-	if (s.op == SWAP_LOG_DEL) {
+	} else if (s.op == SWAP_LOG_DEL) {
 	    break;
 	} else {
 	    fprintf(stderr, "%s:%d: unknown swap log action\n", fname, count);
 	    exit(-3);
 	}
     }
     fprintf(stderr, "%s scanned %d entries, alloc: %d bytes\n",
-	fname, count, 
-	(int)(count*sizeof(CacheEntry)));
+	fname, count,
+	(int) (count * sizeof(CacheEntry)));
     return count;
 }
 
@@ -318,7 +317,7 @@ static int we_false_hit_count = 0;
 static int we_false_miss_count = 0;
 
 static void
-cacheIndexQueryPeer(CacheIndex *idx, const cache_key *key)
+cacheIndexQueryPeer(CacheIndex * idx, const cache_key * key)
 {
     const int peer_has_it = hash_lookup(Peer->hash, key) != NULL;
     const int we_think_we_have_it = cacheDigestTest(Peer->digest, key);
@@ -329,33 +328,32 @@ cacheIndexQueryPeer(CacheIndex *idx, const cache_key *key)
 	    we_true_hit_count++;
 	else
 	    we_false_miss_count++;
+    else if (we_think_we_have_it)
+	we_false_hit_count++;
     else
-	if (we_think_we_have_it)
-	    we_false_hit_count++;
-	else
-	    we_true_miss_count++;
+	we_true_miss_count++;
 }
 
 static void
-cacheIndexIcpReport(CacheIndex *idx)
+cacheIndexIcpReport(CacheIndex * idx)
 {
     fprintf(stdout, "we: icp: %d\n", we_icp_query_count);
     fprintf(stdout, "we: t-hit: %d (%d%%) t-miss: %d (%d%%) t-*: %d (%d%%)\n",
 	we_true_hit_count, xpercentInt(we_true_hit_count, we_icp_query_count),
 	we_true_miss_count, xpercentInt(we_true_miss_count, we_icp_query_count),
-	we_true_hit_count+we_true_miss_count, 
-	    xpercentInt(we_true_hit_count+we_true_miss_count, we_icp_query_count)
-    );
+	we_true_hit_count + we_true_miss_count,
+	xpercentInt(we_true_hit_count + we_true_miss_count, we_icp_query_count)
+	);
     fprintf(stdout, "we: f-hit: %d (%d%%) f-miss: %d (%d%%) f-*: %d (%d%%)\n",
 	we_false_hit_count, xpercentInt(we_false_hit_count, we_icp_query_count),
 	we_false_miss_count, xpercentInt(we_false_miss_count, we_icp_query_count),
-	we_false_hit_count+we_false_miss_count, 
-	    xpercentInt(we_false_hit_count+we_false_miss_count, we_icp_query_count)
-    );
+	we_false_hit_count + we_false_miss_count,
+	xpercentInt(we_false_hit_count + we_false_miss_count, we_icp_query_count)
+	);
 }
 
 static int
-cacheIndexAddAccessLog(CacheIndex *idx, const char *fname)
+cacheIndexAddAccessLog(CacheIndex * idx, const char *fname)
 {
     FILE *file;
     int scanned_count = 0;
@@ -373,7 +371,7 @@ cacheIndexAddAccessLog(CacheIndex *idx, const char *fname)
 }
 
 static int
-cacheIndexScanAccessLog(CacheIndex *idx, const char *fname, FILE *file)
+cacheIndexScanAccessLog(CacheIndex * idx, const char *fname, FILE * file)
 {
     static char buf[4096];
     int count = 0;
@@ -390,11 +388,11 @@ cacheIndexScanAccessLog(CacheIndex *idx, const char *fname, FILE *file)
 
 	scanned_count++;
 	if (!(scanned_count % 50000))
-	    fprintf(stderr, "%s scanned %d K entries (%d bad)\n", 
-		fname, scanned_count/1000, scanned_count-count-1);
+	    fprintf(stderr, "%s scanned %d K entries (%d bad)\n",
+		fname, scanned_count / 1000, scanned_count - count - 1);
 	if (!url || !hier) {
 	    /*fprintf(stderr, "%s:%d: strange access log entry '%s'\n", 
-		fname, scanned_count, buf);*/
+	     * fname, scanned_count, buf); */
 	    continue;
 	}
 	method = url;
@@ -407,16 +405,17 @@ cacheIndexScanAccessLog(CacheIndex *idx, const char *fname, FILE *file)
 	method_id = cacheIndexParseMethod(method);
 	if (method_id == METHOD_NONE) {
 	    /*fprintf(stderr, "%s:%d: invalid method %s in '%s'\n", 
-		fname, scanned_count, method, buf);*/
+	     * fname, scanned_count, method, buf); */
 	    continue;
 	}
-	while (*url) url--;
+	while (*url)
+	    url--;
 	url++;
 	*hier = '\0';
 	hier += 3;
 	*strchr(hier, '/') = '\0';
 	/*fprintf(stdout, "%s:%d: %s %s %s\n",
-	    fname, count, method, url, hier);*/
+	 * fname, count, method, url, hier); */
 	count++;
 	/* no ICP lookup for these status codes */
 	if (!strcmp(hier, "NONE") ||
@@ -432,12 +431,12 @@ cacheIndexScanAccessLog(CacheIndex *idx, const char *fname, FILE *file)
 	    continue;
 	key = storeKeyPublic(url, method_id);
 	/*fprintf(stdout, "%s:%d: %s %s %s %s\n",
-	    fname, count, method, storeKeyText(key), url, hier);*/
+	 * fname, count, method, storeKeyText(key), url, hier); */
 	cacheIndexQueryPeer(idx, key);
 	icp_count++;
     }
     fprintf(stderr, "%s: scanned %d access log entries; bad: %d\n",
-	fname, scanned_count, scanned_count-count);
+	fname, scanned_count, scanned_count - count);
     fprintf(stderr, "%s: icp: %d (%d%%)\n",
 	fname, icp_count, xpercentInt(icp_count, count));
     return count;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: tunnel.cc,v 1.76 1998/03/27 22:44:25 wessels Exp $
+ * $Id: tunnel.cc,v 1.77 1998/03/31 05:37:49 wessels Exp $
  *
  * DEBUG: section 26    Secure Sockets Layer Proxy
  * AUTHOR: Duane Wessels
@@ -344,10 +344,10 @@ sslConnectDone(int fdnotused, int status, void *data)
 	    sslProxyConnected(sslState->server.fd, sslState);
 	else
 	    sslConnected(sslState->server.fd, sslState);
-    commSetTimeout(sslState->server.fd,
-	Config.Timeout.read,
-	sslTimeout,
-	sslState);
+	commSetTimeout(sslState->server.fd,
+	    Config.Timeout.read,
+	    sslTimeout,
+	    sslState);
     }
 }
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: url.cc,v 1.83 1998/03/07 23:43:12 rousskov Exp $
+ * $Id: url.cc,v 1.84 1998/03/31 05:37:53 wessels Exp $
  *
  * DEBUG: section 23    URL Parsing
  * AUTHOR: Duane Wessels
@@ -294,7 +294,7 @@ urnParse(method_t method, char *urn)
 #if OLD_CODE
     xstrncpy(request->urlpath, &urn[4], MAX_URL);
 #else
-    stringReset(&request->urlpath, urn+4);
+    stringReset(&request->urlpath, urn + 4);
 #endif
     request->max_age = -1;
     request->max_forwards = -1;
@@ -255,7 +255,7 @@ urnHandleReply(void *data, char *buf, ssize_t size)
     } else if (min_w) {
 	httpHeaderPutStr(&rep->header, HDR_LOCATION, min_w->key);
     }
-    httpBodySet(&rep->body, mb.buf, mb.size+1, memBufFreeFunc(&mb));
+    httpBodySet(&rep->body, mb.buf, mb.size + 1, memBufFreeFunc(&mb));
     httpReplySwapOut(rep, e);
     storeComplete(e);
     memFree(MEM_4K_BUF, buf);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: wais.cc,v 1.105 1998/03/28 23:24:54 wessels Exp $
+ * $Id: wais.cc,v 1.106 1998/03/31 05:37:55 wessels Exp $
  *
  * DEBUG: section 24    WAIS Relay
  * AUTHOR: Harvest Derived
@@ -188,7 +188,7 @@ waisReadReply(int fd, void *data)
     }
     if (len < 0) {
 	debug(50, 1) ("waisReadReply: FD %d: read failure: %s.\n",
-		fd, xstrerror());
+	    fd, xstrerror());
 	if (ignoreErrno(errno)) {
 	    /* reinstall handlers */
 	    /* XXX This may loop forever */
@@ -360,7 +360,7 @@ waisConnectDone(int fd, int status, void *data)
 	comm_close(fd);
     } else {
 	commSetSelect(fd, COMM_SELECT_WRITE, waisSendRequest, waisState, 0);
-        commSetTimeout(fd, Config.Timeout.read, waisTimeout, waisState);
+	commSetTimeout(fd, Config.Timeout.read, waisTimeout, waisState);
     }
 }
 