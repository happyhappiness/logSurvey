diff --git a/ChangeLog b/ChangeLog
index 2692bad..8c992a6 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,44 @@
+Thu May  9 13:54:49 1996  Roland McGrath  <roland@delasyd.gnu.ai.mit.edu>
+
+	* GNUmakefile (globfiles): Add AmigaDOS support files.
+	(distfiles): Add $(amigafiles).
+	(amigafiles): New variable.
+
+Thu Nov  7 10:18:16 1995  Aaron Digulla   <digulla@fh-konstanz.de>
+
+	* Added Amiga support in commands.c, dir.c, function.c,
+	job.c, main.c, make.h, read.c, remake.c
+	* commands.c: Amiga has neither SIGHUP nor SIGQUIT
+	* dir.c: Amiga has filenames with Upper- and Lowercase,
+	but "FileName" is the same as "filename". Added strieq()
+	which is use to compare filenames. This is like streq()
+	on all other systems. Also there is no such thing as
+	"." under AmigaDOS.
+	* function.c: On Amiga, the environment is not passed as envp,
+	there are no pipes and Amiga can't fork. Use my own function
+	to create a new child.
+	* job.c: default_shell is "" (The system automatically chooses
+	a shell for me). Have to use the same workaround as MSDOS for
+	running batch commands. Added HAVE_SYS_PARAM_H. NOFILE isn't
+	known on Amiga. Cloned code to run children from MSDOS. Own
+	version of sh_chars[] and sh_cmds[]. No dup2() or dup() on Amiga.
+	* main.c: Force stack to 20000 bytes. Read environment from ENV:
+	device. On Amiga, exec_command() does return, so I exit()
+	afterwards.
+	* make.h: Added strieq() to compare filenames.
+	* read.c: Amiga needs special extension to have passwd. Only
+	one include-dir. "Makefile" and "makefile" are the same.
+	Added "SMakefile".  Added special code to handle device names (xxx:)
+	and "./" in rules.
+	* remake.c: Only one lib-dir. Amiga link-libs are named "%s.lib"
+	instead of "lib%s.a".
+	* main.c, rule.c, variable.c: Avoid floats at all costs.
+	* vpath.c: Get rid of as many alloca()s as possible.
+
+Thu May  9 13:20:43 1996  Roland McGrath  <roland@delasyd.gnu.ai.mit.edu>
+
+	* read.c (read_makefile): Grok `sinclude' as alias for `-include'.
+
 Wed Mar 20 09:52:27 1996  Roland McGrath  <roland@charlie-brown.gnu.ai.mit.edu>
 
 	* GNUmakefile (vmsfiles): New variable.
diff --git a/GNUmakefile b/GNUmakefile
index 0e1d494..6e179c9 100644
--- a/GNUmakefile
+++ b/GNUmakefile
@@ -153,6 +153,7 @@ $(prog): $(objs) $(globdep) #$(addprefix $(ARCH)/,gmalloc.o mcheck.o)
 
 libc-srcdir = /home/gd/gnu/libc
 globfiles = $(addprefix glob/,COPYING.LIB configure.in configure Makefile.in \
+			Makefile.ami SCOPTIONS SMakefile \
 			configure.bat glob.c fnmatch.c glob.h fnmatch.h)
 $(globfiles): stamp-glob ;
 stamp-glob: $(libc-srcdir)/posix/glob.tar
@@ -224,10 +225,13 @@ tarfiles: $(tarfiles)
 
 vmsfiles = config.h-vms makefile.com makefile.vms readme.vms \
 	   vmsdir.h vmsfunctionc.c vmsify.c
+amigafiles = README.Amiga config.ami Makefile.ami SCOPTIONS SMakefile \
+	     amiga.c make.lnk
 distfiles=README INSTALL COPYING ChangeLog NEWS \
           configure Makefile.in configure.in build.sh.in mkinstalldirs \
 	  configh.dos configure.bat \
-	  aclocal.m4 acconfig.h $(srcs) remote-*.c $(globfiles) $(vmsfiles) \
+	  $(amigafiles) $(vmsfiles) \
+	  aclocal.m4 acconfig.h $(srcs) remote-*.c $(globfiles) \
 	  make.texinfo make-stds.texi \
 	  make.?? make.??s make.toc make.aux make.man texinfo.tex TAGS tags \
 	  install-sh \
diff --git a/Makefile.ami b/Makefile.ami
new file mode 100644
index 0000000..5a8a968
--- /dev/null
+++ b/Makefile.ami
@@ -0,0 +1,305 @@
+# NOTE: If you have no `make' program at all to process this makefile, run
+# `build.sh' instead.
+#
+# Copyright (C) 1988, 89, 91, 92, 93, 94, 1995 Free Software Foundation, Inc.
+# This file is part of GNU Make.
+#
+# GNU Make is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+#
+# GNU Make is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GNU Make; see the file COPYING.  If not, write to
+# the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+
+#
+#	Makefile for GNU Make
+#
+
+# Ultrix 2.2 make doesn't expand the value of VPATH.
+VPATH = /make-3.74/
+# This must repeat the value, because configure will remove `VPATH = .'.
+srcdir = /make-3.74/
+
+CC = sc
+RM = delete
+
+CFLAGS =
+CPPFLAGS =
+LDFLAGS =
+
+# Define these for your system as follows:
+#	-DNO_ARCHIVES		To disable `ar' archive support.
+#	-DNO_FLOAT		To avoid using floating-point numbers.
+#	-DENUM_BITFIELDS	If the compiler isn't GCC but groks enum foo:2.
+#				Some compilers apparently accept this
+#				without complaint but produce losing code,
+#				so beware.
+# NeXT 1.0a uses an old version of GCC, which required -D__inline=inline.
+# See also `config.h'.
+defines =
+
+# Which flavor of remote job execution support to use.
+# The code is found in `remote-$(REMOTE).c'.
+REMOTE = stub
+
+# If you are using the GNU C library, or have the GNU getopt functions in
+# your C library, you can comment these out.
+GETOPT = getopt.o getopt1.o
+GETOPT_SRC = $(srcdir)getopt.c $(srcdir)getopt1.c $(srcdir)getopt.h
+
+# If you are using the GNU C library, or have the GNU glob functions in
+# your C library, you can comment this out.  GNU make uses special hooks
+# into the glob functions to be more efficient (by using make's directory
+# cache for globbing), so you must use the GNU functions even if your
+# system's C library has the 1003.2 glob functions already.  Also, the glob
+# functions in the AIX and HPUX C libraries are said to be buggy.
+GLOB = glob/glob.lib
+
+# If your system doesn't have alloca, or the one provided is bad, define this.
+ALLOCA = alloca.o
+ALLOCA_SRC = $(srcdir)alloca.c
+
+# If your system needs extra libraries loaded in, define them here.
+# System V probably need -lPW for alloca.  HP-UX 7.0's alloca in
+# libPW.a is broken on HP9000s300 and HP9000s400 machines.  Use
+# alloca.c instead on those machines.
+LOADLIBES =
+
+# Any extra object files your system needs.
+extras = amiga.o
+
+# Common prefix for machine-independent installed files.
+prefix =
+# Common prefix for machine-dependent installed files.
+exec_prefix =
+
+# Directory to install `make' in.
+bindir = sc:c
+# Directory to find libraries in for `-lXXX'.
+libdir = lib:
+# Directory to search by default for included makefiles.
+includedir = include:
+# Directory to install the Info files in.
+infodir = doc:
+# Directory to install the man page in.
+mandir = t:
+# Number to put on the man page filename.
+manext = 1
+# Prefix to put on installed `make' binary file name.
+binprefix =
+# Prefix to put on installed `make' man page file name.
+manprefix = $(binprefix)
+
+# Whether or not make needs to be installed setgid.
+# The value should be either `true' or `false'.
+# On many systems, the getloadavg function (used to implement the `-l'
+# switch) will not work unless make is installed setgid kmem.
+install_setgid = false
+# Install make setgid to this group so it can read /dev/kmem.
+group = sys
+
+# Program to install `make'.
+INSTALL_PROGRAM = copy
+# Program to install the man page.
+INSTALL_DATA = copy
+# Generic install program.
+INSTALL = copy
+
+# Program to format Texinfo source into Info files.
+MAKEINFO = makeinfo
+# Program to format Texinfo source into DVI files.
+TEXI2DVI = texi2dvi
+
+# Programs to make tags files.
+ETAGS = etags -w
+CTAGS = ctags -w
+
+objs = commands.o job.o dir.o file.o misc.o main.o read.o remake.o	\
+       rule.o implicit.o default.o variable.o expand.o function.o	\
+       vpath.o version.o ar.o arscan.o signame.o remote-$(REMOTE).o     \
+       $(GETOPT) $(ALLOCA) $(extras)
+srcs = $(srcdir)commands.c $(srcdir)job.c $(srcdir)dir.c             \
+       $(srcdir)file.c $(srcdir)getloadavg.c $(srcdir)misc.c         \
+       $(srcdir)main.c $(srcdir)read.c $(srcdir)remake.c             \
+       $(srcdir)rule.c $(srcdir)implicit.c $(srcdir)default.c        \
+       $(srcdir)variable.c $(srcdir)expand.c $(srcdir)function.c     \
+       $(srcdir)vpath.c $(srcdir)version.c                            \
+       $(srcdir)remote-$(REMOTE).c                                     \
+       $(srcdir)ar.c $(srcdir)arscan.c                                \
+       $(srcdir)signame.c $(srcdir)signame.h $(GETOPT_SRC)            \
+       $(srcdir)commands.h $(srcdir)dep.h $(srcdir)file.h            \
+       $(srcdir)job.h $(srcdir)make.h $(srcdir)rule.h                \
+       $(srcdir)variable.h $(ALLOCA_SRC) $(srcdir)config.h.in
+
+
+.SUFFIXES:
+.SUFFIXES: .o .c .h .ps .dvi .info .texinfo
+
+all: make
+info: make.info
+dvi: make.dvi
+# Some makes apparently use .PHONY as the default goal if it is before `all'.
+.PHONY: all check info dvi
+
+make.info: make.texinfo
+	$(MAKEINFO) -I$(srcdir) $(srcdir)make.texinfo -o make.info
+
+make.dvi: make.texinfo
+	$(TEXI2DVI) $(srcdir)make.texinfo
+
+make.ps: make.dvi
+	dvi2ps make.dvi > make.ps
+
+make: $(objs) $(GLOB)
+	$(CC) Link $(LDFLAGS) $(objs) Lib $(GLOB) $(LOADLIBES) To make.new
+	-delete make
+	rename make.new make
+
+TMPFILE = t:Make$$
+
+$(GLOB):
+	cd glob @@\
+	/make -f makefile
+
+# -I. is needed to find config.h in the build directory.
+OUTPUT_OPTION =
+.c.o:
+	$(CC) $(defines) IDir "" IDir $(srcdir)glob \
+	      $(CPPFLAGS) $(CFLAGS) $< $(OUTPUT_OPTION)
+
+# For some losing Unix makes.
+SHELL = /bin/sh
+#@SET_MAKE@
+
+glob/libglob.a: FORCE config.h
+	cd glob; $(MAKE) libglob.a
+FORCE:
+
+tagsrcs = $(srcs) $(srcdir)remote-*.c
+TAGS: $(tagsrcs)
+	$(ETAGS) $(tagsrcs)
+tags: $(tagsrcs)
+	$(CTAGS) $(tagsrcs)
+
+.PHONY: install installdirs
+install: installdirs \
+	 $(bindir)$(binprefix)make $(infodir)make.info \
+	 $(mandir)$(manprefix)make.$(manext)
+
+installdirs:
+	$(SHELL) ${srcdir}/mkinstalldirs $(bindir) $(infodir) $(mandir)
+
+$(bindir)$(binprefix)make: make
+	$(INSTALL_PROGRAM) make $@.new
+	@if $(install_setgid); then \
+	   if chgrp $(group) $@.new && chmod g+s $@.new; then \
+	     echo "chgrp $(group) $@.new && chmod g+s $@.new"; \
+	   else \
+	     echo "$@ needs to be owned by group $(group) and setgid;"; \
+	     echo "otherwise the \`-l' option will probably not work."; \
+	     echo "You may need special privileges to install $@."; \
+	   fi; \
+	 else true; fi
+# Some systems can't deal with renaming onto a running binary.
+	-$(RM) $@.old
+	-mv $@ $@.old
+	mv $@.new $@
+
+$(infodir)make.info: make.info
+	if [ -r ./make.info ]; then dir=.; else dir=$(srcdir); fi; \
+	for file in $${dir}/make.info*; do \
+	  name="`basename $$file`"; \
+	  $(INSTALL_DATA) $$file \
+	    `echo $@ | sed "s,make.info\$$,$$name,"`; \
+	done
+# Run install-info only if it exists.
+# Use `if' instead of just prepending `-' to the
+# line so we notice real errors from install-info.
+# We use `$(SHELL) -c' because some shells do not
+# fail gracefully when there is an unknown command.
+	if $(SHELL) -c 'install-info --version' >/dev/null 2>&1; then \
+	  if [ -r ./make.info ]; then dir=.; else dir=$(srcdir); fi; \
+	  install-info --infodir=$(infodir) $$dir/make.info; \
+	else true; fi
+
+$(mandir)$(manprefix)make.$(manext): make.man
+	$(INSTALL_DATA) $(srcdir)make.man $@
+
+
+loadavg: loadavg.c config.h
+	$(CC) $(defines) -DTEST -I. -I$(srcdir) $(CFLAGS) $(LDFLAGS) \
+	      loadavg.c $(LOADLIBES) -o $@
+# We copy getloadavg.c into a different file rather than compiling it
+# directly because some compilers clobber getloadavg.o in the process.
+loadavg.c: getloadavg.c
+	ln $(srcdir)getloadavg.c loadavg.c || \
+	cp $(srcdir)getloadavg.c loadavg.c
+check-loadavg: loadavg
+	@echo The system uptime program believes the load average to be:
+	-uptime
+	@echo The GNU load average checking code believes:
+	./loadavg
+check: check-loadavg
+
+
+.PHONY: clean realclean distclean mostlyclean
+clean: glob-clean
+	-$(RM) make loadavg "#?.o" core make.dvi
+
+distclean: clean glob-realclean
+	-$(RM) Makefile config.h config.status build.sh stamp-config
+	-$(RM) config.log config.cache
+	-$(RM) TAGS tags
+	-$(RM) make.?? make.??s make.log make.toc make.*aux
+	-$(RM) loadavg.c
+
+realclean: distclean
+	-$(RM) make.info*
+mostlyclean: clean
+
+.PHONY: glob-clean glob-realclean
+glob-clean glob-realclean:
+	cd glob @@\
+	$(MAKE) $@
+
+# This tells versions [3.59,3.63) of GNU make not to export all variables.
+.NOEXPORT:
+
+# The automatically generated dependencies below may omit config.h
+# because it is included with ``#include <config.h>'' rather than
+# ``#include "config.h"''.  So we add the explicit dependency to make sure.
+$(objs): config.h
+
+# Automatically generated dependencies will be put at the end of the file.
+
+# Automatically generated dependencies.
+commands.o : commands.c make.h dep.h commands.h file.h variable.h job.h
+job.o: job.c make.h commands.h job.h file.h variable.h
+dir.o: dir.c make.h
+file.o: file.c make.h commands.h dep.h file.h variable.h
+misc.o: misc.c make.h dep.h
+main.o: main.c make.h commands.h dep.h file.h variable.h job.h getopt.h
+read.o: read.c make.h commands.h dep.h file.h variable.h glob/glob.h
+remake.o: remake.c make.h commands.h job.h dep.h file.h
+rule.o : rule.c make.h config.h commands.h dep.h file.h variable.h rule.h
+implicit.o : implicit.c make.h rule.h dep.h file.h
+default.o: default.c make.h rule.h dep.h file.h commands.h variable.h
+variable.o : variable.c make.h commands.h variable.h dep.h file.h
+expand.o: expand.c make.h commands.h file.h variable.h
+function.o: function.c make.h variable.h dep.h commands.h job.h
+vpath.o : vpath.c make.h file.h variable.h
+version.o: version.c
+ar.o : ar.c make.h file.h dep.h
+arscan.o: arscan.c make.h
+signame.o: signame.c signame.h
+remote-stub.o : remote-stub.c make.h commands.h
+getopt.o: getopt.c getopt.h
+getopt1.o : getopt1.c getopt.h
+getloadavg.o: getloadavg.c
diff --git a/README.Amiga b/README.Amiga
new file mode 100644
index 0000000..7bb309f
--- /dev/null
+++ b/README.Amiga
@@ -0,0 +1,62 @@
+Short: Port of GNU make with SAS/C (no ixemul.library required)
+Author: GNU, Amiga port by Aaron "Optimizer" Digulla
+Uploader: Aaron "Optimizer" Digulla (digulla@fh-konstanz.de)
+Type: dev/c
+
+This is a pure Amiga port of GNU make 3.74. It needs no extra libraries or
+anything. It has the following features (in addition to any features of
+GNU make):
+
+- Runs Amiga-Commands with SystemTags() (Execute)
+- Can run multi-line statements
+- Allows to use Device-Names in targets:
+
+	c:make : make.o
+
+    is ok. To distinguish between device-names and target : or ::, MAKE
+    looks for spaces. If there are any around :, it's taken as a target
+    delimiter, if there are none, it's taken as the name of a device. Note
+    that "make:make.o" tries to create "make.o" on the device "make:".
+- Replaces @@ by a newline in any command line:
+
+	if exists make @@\
+	    delete make.bak quiet @@\
+	    rename make make.bak @@\
+	endif @@\
+	$(CC) Link Make.o To make
+
+    works. Note that the @@ must stand alone (ie. "make@@\" is illegal).
+    Also be carefull that there is a space after the "\" (ie, at the
+    beginning of the next line).
+- Can be made resident to save space and time
+- To use "#?" as a wildcard, you must enclose it in "":
+
+    delete "#?.o"
+
+BUGS:
+- The line
+
+    dummy.h : src/*.c
+
+tries to make dummy.h from "src/*.c" (ie. no wildcard-expansion takes
+place). You have to use "$(wildcard src/*.c)" instead.
+
+COMPILING FROM SCRATCH
+
+To recompile, you need SAS/C 6.51. make itself is not neccessary, there
+is an smakefile.
+
+1. Copy config.ami to config.h
+2. If you use make to compie, copy Makefile.ami to Makefile and
+    glob/Makefile.ami to glob/Makefile. Copy make into the current
+    directory.
+
+3. Run smake/make
+
+INSTALLATION
+
+Copy make somewhere in your search path (eg. sc:c or sc:bin).
+If you plan to use recursive makes, install make resident:
+
+    Resident make Add
+
diff --git a/SCOPTIONS b/SCOPTIONS
new file mode 100644
index 0000000..f89daae
--- /dev/null
+++ b/SCOPTIONS
@@ -0,0 +1,13 @@
+ERRORREXX
+OPTIMIZE
+NOVERSION
+OPTIMIZERTIME
+OPTIMIZERALIAS
+DEFINE INCLUDEDIR="include:"
+DEFINE LIBDIR="lib:"
+DEFINE NO_ALLOCA
+DEFINE NO_FLOAT
+DEFINE NO_ARCHIVES
+IGNORE=161
+IGNORE=100
+STARTUP=cres
diff --git a/SMakefile.template b/SMakefile.template
new file mode 100644
index 0000000..8e339fe
--- /dev/null
+++ b/SMakefile.template
@@ -0,0 +1,268 @@
+# NOTE: If you have no `make' program at all to process this makefile, run
+# `build.sh' instead.
+#
+# Copyright (C) 1988, 89, 91, 92, 93, 94, 1995 Free Software Foundation, Inc.
+# This file is part of GNU Make.
+#
+# GNU Make is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+#
+# GNU Make is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GNU Make; see the file COPYING.  If not, write to
+# the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+
+#
+#	Makefile for GNU Make
+#
+
+# Ultrix 2.2 make doesn't expand the value of VPATH.
+VPATH = /make-3.74/
+# This must repeat the value, because configure will remove `VPATH = .'.
+srcdir = /make-3.74/
+
+CC = sc
+RM = delete
+MAKE = smake
+
+CFLAGS =
+CPPFLAGS =
+LDFLAGS =
+
+# Define these for your system as follows:
+#	-DNO_ARCHIVES		To disable `ar' archive support.
+#	-DNO_FLOAT		To avoid using floating-point numbers.
+#	-DENUM_BITFIELDS	If the compiler isn't GCC but groks enum foo:2.
+#				Some compilers apparently accept this
+#				without complaint but produce losing code,
+#				so beware.
+# NeXT 1.0a uses an old version of GCC, which required -D__inline=inline.
+# See also `config.h'.
+defines =
+
+# Which flavor of remote job execution support to use.
+# The code is found in `remote-$(REMOTE).c'.
+REMOTE = stub
+
+# If you are using the GNU C library, or have the GNU getopt functions in
+# your C library, you can comment these out.
+GETOPT = getopt.o getopt1.o
+GETOPT_SRC = $(srcdir)getopt.c $(srcdir)getopt1.c $(srcdir)getopt.h
+
+# If you are using the GNU C library, or have the GNU glob functions in
+# your C library, you can comment this out.  GNU make uses special hooks
+# into the glob functions to be more efficient (by using make's directory
+# cache for globbing), so you must use the GNU functions even if your
+# system's C library has the 1003.2 glob functions already.  Also, the glob
+# functions in the AIX and HPUX C libraries are said to be buggy.
+GLOB = Lib glob/glob.lib
+
+# If your system doesn't have alloca, or the one provided is bad, define this.
+ALLOCA = alloca.o
+ALLOCA_SRC = $(srcdir)alloca.c
+
+# If your system needs extra libraries loaded in, define them here.
+# System V probably need -lPW for alloca.  HP-UX 7.0's alloca in
+# libPW.a is broken on HP9000s300 and HP9000s400 machines.  Use
+# alloca.c instead on those machines.
+LOADLIBES =
+
+# Any extra object files your system needs.
+extras = amiga.o
+
+# Common prefix for machine-independent installed files.
+prefix =
+# Common prefix for machine-dependent installed files.
+exec_prefix =
+
+# Directory to install `make' in.
+bindir = sc:c
+# Directory to find libraries in for `-lXXX'.
+libdir = lib:
+# Directory to search by default for included makefiles.
+includedir = include:
+# Directory to install the Info files in.
+infodir = doc:
+# Directory to install the man page in.
+mandir = t:
+# Number to put on the man page filename.
+manext = 1
+# Prefix to put on installed `make' binary file name.
+binprefix =
+# Prefix to put on installed `make' man page file name.
+manprefix = $(binprefix)
+
+# Whether or not make needs to be installed setgid.
+# The value should be either `true' or `false'.
+# On many systems, the getloadavg function (used to implement the `-l'
+# switch) will not work unless make is installed setgid kmem.
+install_setgid = false
+# Install make setgid to this group so it can read /dev/kmem.
+group = sys
+
+# Program to install `make'.
+INSTALL_PROGRAM = copy
+# Program to install the man page.
+INSTALL_DATA = copy
+# Generic install program.
+INSTALL = copy
+
+# Program to format Texinfo source into Info files.
+MAKEINFO = makeinfo
+# Program to format Texinfo source into DVI files.
+TEXI2DVI = texi2dvi
+
+# Programs to make tags files.
+ETAGS = etags -w
+CTAGS = ctags -w
+
+objs = commands.o job.o dir.o file.o misc.o main.o read.o remake.o	\
+       rule.o implicit.o default.o variable.o expand.o function.o	\
+       vpath.o version.o ar.o arscan.o signame.o remote-$(REMOTE).o     \
+       $(GLOB) $(GETOPT) $(ALLOCA) $(extras)
+srcs = $(srcdir)commands.c $(srcdir)job.c $(srcdir)dir.c             \
+       $(srcdir)file.c $(srcdir)getloadavg.c $(srcdir)misc.c         \
+       $(srcdir)main.c $(srcdir)read.c $(srcdir)remake.c             \
+       $(srcdir)rule.c $(srcdir)implicit.c $(srcdir)default.c        \
+       $(srcdir)variable.c $(srcdir)expand.c $(srcdir)function.c     \
+       $(srcdir)vpath.c $(srcdir)version.c                            \
+       $(srcdir)remote-$(REMOTE).c                                     \
+       $(srcdir)ar.c $(srcdir)arscan.c                                \
+       $(srcdir)signame.c $(srcdir)signame.h $(GETOPT_SRC)            \
+       $(srcdir)commands.h $(srcdir)dep.h $(srcdir)file.h            \
+       $(srcdir)job.h $(srcdir)make.h $(srcdir)rule.h                \
+       $(srcdir)variable.h $(ALLOCA_SRC) $(srcdir)config.h.in
+
+
+.SUFFIXES:
+.SUFFIXES: .o .c .h .ps .dvi .info .texinfo
+
+all: make
+info: make.info
+dvi: make.dvi
+# Some makes apparently use .PHONY as the default goal if it is before `all'.
+.PHONY: all check info dvi
+
+make.info: make.texinfo
+	$(MAKEINFO) -I$(srcdir) $(srcdir)make.texinfo -o make.info
+
+make.dvi: make.texinfo
+	$(TEXI2DVI) $(srcdir)make.texinfo
+
+make.ps: make.dvi
+	dvi2ps make.dvi > make.ps
+
+make: $(objs) glob/glob.lib
+	$(CC) Link $(LDFLAGS) $(objs) $(LOADLIBES) To make.new
+	-delete quiet make
+	rename make.new make
+
+# -I. is needed to find config.h in the build directory.
+.c.o:
+	$(CC) $(defines) IDir "" IDir $(srcdir)glob \
+	      $(CPPFLAGS) $(CFLAGS) $< $(OUTPUT_OPTION)
+
+glob/glob.lib:
+	execute <<
+	    cd glob
+	    smake
+<
+
+tagsrcs = $(srcs) $(srcdir)remote-*.c
+TAGS: $(tagsrcs)
+	$(ETAGS) $(tagsrcs)
+tags: $(tagsrcs)
+	$(CTAGS) $(tagsrcs)
+
+.PHONY: install installdirs
+install:
+	copy make sc:c
+
+loadavg: loadavg.c config.h
+	$(CC) $(defines) -DTEST -I. -I$(srcdir) $(CFLAGS) $(LDFLAGS) \
+	      loadavg.c $(LOADLIBES) -o $@
+
+clean: glob-clean
+	-$(RM) -f make loadavg *.o core make.dvi
+
+distclean: clean glob-realclean
+	-$(RM) -f Makefile config.h config.status build.sh stamp-config
+	-$(RM) -f config.log config.cache
+	-$(RM) -f TAGS tags
+	-$(RM) -f make.?? make.??s make.log make.toc make.*aux
+	-$(RM) -f loadavg.c
+
+realclean: distclean
+	-$(RM) -f make.info*
+
+mostlyclean: clean
+
+.PHONY: glob-clean glob-realclean
+
+glob-clean glob-realclean:
+	execute <<
+	cd glob
+	smake $@
+<
+
+# The automatically generated dependencies below may omit config.h
+# because it is included with ``#include <config.h>'' rather than
+# ``#include "config.h"''.  So we add the explicit dependency to make sure.
+$(objs): config.h
+
+# Automatically generated dependencies will be put at the end of the file.
+
+# Automatically generated dependencies.
+commands.o : commands.c make.h dep.h commands.h file.h variable.h job.h
+
+job.o: job.c make.h commands.h job.h file.h variable.h
+
+dir.o: dir.c make.h
+
+file.o: file.c make.h commands.h dep.h file.h variable.h
+
+misc.o: misc.c make.h dep.h
+
+main.o: main.c make.h commands.h dep.h file.h variable.h job.h getopt.h
+
+read.o: read.c make.h commands.h dep.h file.h variable.h glob/glob.h
+
+remake.o: remake.c make.h commands.h job.h dep.h file.h
+
+rule.o : rule.c make.h config.h commands.h dep.h file.h variable.h rule.h
+
+implicit.o : implicit.c make.h rule.h dep.h file.h
+
+default.o: default.c make.h rule.h dep.h file.h commands.h variable.h
+
+variable.o : variable.c make.h commands.h variable.h dep.h file.h
+
+expand.o: expand.c make.h commands.h file.h variable.h
+
+function.o: function.c make.h variable.h dep.h commands.h job.h
+
+vpath.o : vpath.c make.h file.h variable.h
+
+version.o: version.c
+
+ar.o : ar.c make.h file.h dep.h
+
+arscan.o: arscan.c make.h
+
+signame.o: signame.c signame.h
+
+remote-stub.o : remote-stub.c make.h commands.h
+
+getopt.o: getopt.c getopt.h
+
+getopt1.o : getopt1.c getopt.h
+
+getloadavg.o: getloadavg.c
+
+amiga.o: amiga.c make.h
diff --git a/amiga.c b/amiga.c
new file mode 100644
index 0000000..26fd3ab
--- /dev/null
+++ b/amiga.c
@@ -0,0 +1,86 @@
+/* Running commands on Amiga
+Copyright (C) 1988, 89, 90, 91, 92, 93, 94, 1995 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Make is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Make; see the file COPYING.  If not, write to
+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
+
+#include "make.h"
+#include <assert.h>
+#include <exec/memory.h>
+#include <dos/dostags.h>
+#include <proto/exec.h>
+#include <proto/dos.h>
+
+int
+MyExecute (argv)
+char ** argv;
+{
+    char * buffer, * ptr;
+    char ** aptr;
+    int len = 0;
+    int status;
+
+    for (aptr=argv; *aptr; aptr++)
+    {
+	len += strlen (*aptr) + 4;
+    }
+
+    buffer = AllocMem (len, MEMF_ANY);
+
+    if (!buffer)
+      fatal ("MyExecute: Cannot allocate space for calling a command");
+
+    ptr = buffer;
+
+    for (aptr=argv; *aptr; aptr++)
+    {
+	if (((*aptr)[0] == ';' && !(*aptr)[1]))
+	{
+	    *ptr ++ = '"';
+	    strcpy (ptr, *aptr);
+	    ptr += strlen (ptr);
+	    *ptr ++ = '"';
+	}
+	else if ((*aptr)[0] == '@' && (*aptr)[1] == '@' && !(*aptr)[2])
+	{
+	    *ptr ++ = '\n';
+	    continue;
+	}
+	else
+	{
+	    strcpy (ptr, *aptr);
+	    ptr += strlen (ptr);
+	}
+	*ptr ++ = ' ';
+	*ptr = 0;
+    }
+
+    ptr[-1] = '\n';
+
+    status = SystemTags (buffer,
+	SYS_UserShell, TRUE,
+	TAG_END);
+
+    FreeMem (buffer, len);
+
+    if (SetSignal(0L,0L) & SIGBREAKF_CTRL_C)
+	status = 20;
+
+    /* Warnings don't count */
+    if (status == 5)
+	status = 0;
+
+    return status;
+}
diff --git a/commands.c b/commands.c
index 1a4372f..6993e62 100644
--- a/commands.c
+++ b/commands.c
@@ -369,9 +369,16 @@ RETSIGTYPE
 fatal_error_signal (sig)
      int sig;
 {
-#ifdef	__MSDOS__
+#if defined(__MSDOS__) || defined(_AMIGA)
   remove_intermediates (1);
+#ifdef _AMIGA
+  if (sig == SIGINT)
+     fputs ("*** Break.\n", stderr);
+
+  exit (10);
+#else
   exit (1);
+#endif
 #else	/* Not MSDOS.  */
   handling_fatal_signal = 1;
 
@@ -393,7 +400,14 @@ fatal_error_signal (sig)
   /* If we got a signal that means the user
      wanted to kill make, remove pending targets.  */
 
-  if (sig == SIGTERM || sig == SIGINT || sig == SIGHUP || sig == SIGQUIT)
+  if (sig == SIGTERM || sig == SIGINT
+#ifdef SIGHUP
+    || sig == SIGHUP
+#endif
+#ifdef SIGQUIT
+    || sig == SIGQUIT
+#endif
+    )
     {
       register struct child *c;
 
diff --git a/config.ami.template b/config.ami.template
new file mode 100644
index 0000000..d480b0a
--- /dev/null
+++ b/config.ami.template
@@ -0,0 +1,271 @@
+/* config.h.in.  Generated automatically from configure.in by autoheader.  */
+
+/* Define if on AIX 3.
+   System headers sometimes define this.
+   We just want to avoid a redefinition error message.	*/
+#ifndef _ALL_SOURCE
+#undef _ALL_SOURCE
+#endif
+
+/* Define if using alloca.c.  */
+#define C_ALLOCA
+
+/* Define to empty if the keyword does not work.  */
+#undef const
+
+/* Define to one of _getb67, GETB67, getb67 for Cray-2 and Cray-YMP systems.
+   This function is required for alloca.c support on those systems.  */
+#undef CRAY_STACKSEG_END
+
+/* Define for DGUX with <sys/dg_sys_info.h>.  */
+#undef DGUX
+
+/* Define if the `getloadavg' function needs to be run setuid or setgid.  */
+#undef GETLOADAVG_PRIVILEGED
+
+/* Define to `int' if <sys/types.h> doesn't define.  */
+#define gid_t int
+
+/* Define if you have alloca, as a function or macro.  */
+#undef HAVE_ALLOCA
+
+/* Define if you have <alloca.h> and it should be used (not on Ultrix).  */
+#undef HAVE_ALLOCA_H
+
+/* Define if you don't have vprintf but do have _doprnt.  */
+#undef HAVE_DOPRNT
+
+/* Define if your system has its own `getloadavg' function.  */
+#undef HAVE_GETLOADAVG
+
+/* Define if you have the getmntent function.  */
+#undef HAVE_GETMNTENT
+
+/* Define if the `long double' type works.  */
+#undef HAVE_LONG_DOUBLE
+
+/* Define if you support file names longer than 14 characters.	*/
+#define HAVE_LONG_FILE_NAMES
+
+/* Define if you have a working `mmap' system call.  */
+#undef HAVE_MMAP
+
+/* Define if system calls automatically restart after interruption
+   by a signal.  */
+#undef HAVE_RESTARTABLE_SYSCALLS
+
+/* Define if your struct stat has st_blksize.  */
+#undef HAVE_ST_BLKSIZE
+
+/* Define if your struct stat has st_blocks.  */
+#undef HAVE_ST_BLOCKS
+
+/* Define if you have the strcoll function and it is properly defined.	*/
+#define HAVE_STRCOLL
+
+/* Define if your struct stat has st_rdev.  */
+#define HAVE_ST_RDEV
+
+/* Define if you have the strftime function.  */
+#define HAVE_STRFTIME
+
+/* Define if you have <sys/wait.h> that is POSIX.1 compatible.	*/
+#undef HAVE_SYS_WAIT_H
+
+/* Define if your struct tm has tm_zone.  */
+#undef HAVE_TM_ZONE
+
+/* Define if you don't have tm_zone but do have the external array
+   tzname.  */
+#define HAVE_TZNAME
+/* #define tzname __tzname */
+
+/* Define if you have <unistd.h>.  */
+#define HAVE_UNISTD_H
+
+/* Define if utime(file, NULL) sets file's timestamp to the present.  */
+#undef HAVE_UTIME_NULL
+
+/* Define if you have <vfork.h>.  */
+#undef HAVE_VFORK_H
+
+/* Define if you have the vprintf function.  */
+#define HAVE_VPRINTF
+
+/* Define if you have the wait3 system call.  */
+#undef HAVE_WAIT3
+
+/* Define if on MINIX.	*/
+#undef _MINIX
+
+/* Define if your struct nlist has an n_un member.  */
+#undef NLIST_NAME_UNION
+
+/* Define if you have <nlist.h>.  */
+#undef NLIST_STRUCT
+
+/* Define if your C compiler doesn't accept -c and -o together.  */
+#undef NO_MINUS_C_MINUS_O
+
+/* Define to `int' if <sys/types.h> doesn't define.  */
+#define pid_t int
+
+/* Define if the system does not provide POSIX.1 features except
+   with this defined.  */
+#undef _POSIX_1_SOURCE
+
+/* Define if you need to in order for stat and other things to work.  */
+#undef _POSIX_SOURCE
+
+/* Define as the return type of signal handlers (int or void).  */
+#define RETSIGTYPE void
+
+/* Define if the setvbuf function takes the buffering type as its second
+   argument and the buffer pointer as the third, as on System V
+   before release 3.  */
+#undef SETVBUF_REVERSED
+
+/* If using the C implementation of alloca, define if you know the
+   direction of stack growth for your system; otherwise it will be
+   automatically deduced at run-time.
+	STACK_DIRECTION > 0 => grows toward higher addresses
+	STACK_DIRECTION < 0 => grows toward lower addresses
+	STACK_DIRECTION = 0 => direction of growth unknown
+ */
+#define STACK_DIRECTION -1
+
+/* Define if the `S_IS*' macros in <sys/stat.h> do not work properly.  */
+#undef STAT_MACROS_BROKEN
+
+/* Define if you have the ANSI C header files.	*/
+#define STDC_HEADERS
+
+/* Define on System V Release 4.  */
+#undef SVR4
+
+/* Define if `sys_siglist' is declared by <signal.h>.  */
+#undef SYS_SIGLIST_DECLARED
+
+/* Define to `int' if <sys/types.h> doesn't define.  */
+#define uid_t int
+
+/* Define for Encore UMAX.  */
+#undef UMAX
+
+/* Define for Encore UMAX 4.3 that has <inq_status/cpustats.h>
+   instead of <sys/cpustats.h>.  */
+#undef UMAX4_3
+
+/* Define vfork as fork if vfork does not work.  */
+#undef vfork
+
+/* Define to the name of the SCCS `get' command.  */
+#define SCCS_GET "get"
+
+/* Define this if the SCCS `get' command understands the `-G<file>' option.  */
+#undef SCCS_GET_MINUS_G
+
+/* Define this if the C library defines the variable `sys_siglist'.  */
+#undef HAVE_SYS_SIGLIST
+
+/* Define this if the C library defines the variable `_sys_siglist'.  */
+#undef HAVE__SYS_SIGLIST
+
+/* Define this if you have the `union wait' type in <sys/wait.h>.  */
+#undef HAVE_UNION_WAIT
+
+/* Define this if the POSIX.1 call `sysconf (_SC_OPEN_MAX)' works properly.  */
+#undef HAVE_SYSCONF_OPEN_MAX
+
+/* Define if you have the dup2 function.  */
+#undef HAVE_DUP2
+
+/* Define if you have the getcwd function.  */
+#define HAVE_GETCWD
+
+/* Define if you have the getdtablesize function.  */
+#undef HAVE_GETDTABLESIZE
+
+/* Define if you have the getgroups function.  */
+#undef HAVE_GETGROUPS
+
+/* Define if you have the mktemp function.  */
+#define HAVE_MKTEMP
+
+/* Define if you have the psignal function.  */
+#undef HAVE_PSIGNAL
+
+/* Define if you have the setegid function.  */
+#undef HAVE_SETEGID
+
+/* Define if you have the seteuid function.  */
+#undef HAVE_SETEUID
+
+/* Define if you have the setlinebuf function.	*/
+#undef HAVE_SETLINEBUF
+
+/* Define if you have the setregid function.  */
+#undef HAVE_SETREGID
+
+/* Define if you have the setreuid function.  */
+#undef HAVE_SETREUID
+
+/* Define if you have the sigsetmask function.	*/
+#undef HAVE_SIGSETMASK
+
+/* Define if you have the strerror function.  */
+#define HAVE_STRERROR
+
+/* Define if you have the strsignal function.  */
+#undef HAVE_STRSIGNAL
+
+/* Define if you have the wait3 function.  */
+#undef HAVE_WAIT3
+
+/* Define if you have the waitpid function.  */
+#undef HAVE_WAITPID
+
+/* Define if you have the <dirent.h> header file.  */
+#define HAVE_DIRENT_H
+
+/* Define if you have the <fcntl.h> header file.  */
+#define HAVE_FCNTL_H
+
+/* Define if you have the <limits.h> header file.  */
+#define HAVE_LIMITS_H
+
+/* Define if you have the <mach/mach.h> header file.  */
+#undef HAVE_MACH_MACH_H
+
+/* Define if you have the <memory.h> header file.  */
+#undef HAVE_MEMORY_H
+
+/* Define if you have the <ndir.h> header file.  */
+#undef HAVE_NDIR_H
+
+/* Define if you have the <string.h> header file.  */
+#define HAVE_STRING_H
+
+/* Define if you have the <sys/dir.h> header file.  */
+#define HAVE_SYS_DIR_H
+
+/* Define if you have the <sys/ndir.h> header file.  */
+#undef HAVE_SYS_NDIR_H
+
+/* Define if you have the <sys/param.h> header file.  */
+#undef HAVE_SYS_PARAM_H
+
+/* Define if you have the <sys/timeb.h> header file.  */
+#undef HAVE_SYS_TIMEB_H
+
+/* Define if you have the <sys/wait.h> header file.  */
+#undef HAVE_SYS_WAIT_H
+
+/* Define if you have the <unistd.h> header file.  */
+#define HAVE_UNISTD_H
+
+/* Define if you have the dgc library (-ldgc).  */
+#undef HAVE_LIBDGC
+
+/* Define if you have the sun library (-lsun).  */
+#undef HAVE_LIBSUN
diff --git a/function.c b/function.c
index 1886f75..9794872 100644
--- a/function.c
+++ b/function.c
@@ -1,5 +1,5 @@
 /* Variable function expansion for GNU Make.
-Copyright (C) 1988, 89, 91, 92, 93, 94, 95 Free Software Foundation, Inc.
+Copyright (C) 1988, 89, 91, 92, 93, 94, 95, 96 Free Software Foundation, Inc.
 This file is part of GNU Make.
 
 GNU Make is free software; you can redistribute it and/or modify
@@ -356,6 +356,7 @@ expand_function (o, function, text, end)
 	if (argv == 0)
 	  break;
 
+#ifndef _AMIGA
 	/* Using a target environment for `shell' loses in cases like:
 	   	export var = $(shell echo foobie)
 	   because target_environment hits a loop trying to expand $(var)
@@ -368,6 +369,7 @@ expand_function (o, function, text, end)
 	/* Construct the environment.  */
 	envp = target_environment ((struct file *) 0);
 #endif
+#endif	/* Not Amiga.  */
 
 	/* For error messages.  */
 	if (reading_filename != 0)
@@ -379,7 +381,7 @@ expand_function (o, function, text, end)
 	else
 	  error_prefix = "";
 
-#ifndef	  __MSDOS__
+#if !defined(__MSDOS__) && !defined(_AMIGA)
 	if (pipe (pipedes) < 0)
 	  {
 	    perror_with_name (error_prefix, "pipe");
@@ -484,7 +486,8 @@ expand_function (o, function, text, end)
 
 	    free (buffer);
 	  }
-#else	/* MSDOS.  */
+#else	/* MSDOS or Amiga */
+#ifndef _AMIGA
          {
 	   /* MS-DOS can't do fork, but it can do spawn.  However, this
 	      means that we don't have an opportunity to reopen stdout to
@@ -546,7 +549,83 @@ expand_function (o, function, text, end)
 	     }
 	   free (buffer);
 	 }
-#endif	/* Not MSDOS.  */
+#else /* Amiga */
+	 {
+	   /* Amiga can't fork nor spawn, but I can start a program with
+	      redirection of my choice. The rest is the same as above. */
+#include <dos/dos.h>
+#include <proto/dos.h>
+
+	   BPTR child_stdout;
+	   char tmp_output[FILENAME_MAX];
+	   unsigned int maxlen = 200;
+	   int cc;
+	   char * buffer, * ptr;
+	   char ** aptr;
+	   int len = 0;
+
+	   strcpy (tmp_output, "t:MakeshXXXXXXXX");
+	   mktemp (tmp_output);
+	   child_stdout = Open (tmp_output, MODE_NEWFILE);
+
+	   for (aptr=argv; *aptr; aptr++)
+	     {
+	       len += strlen (*aptr) + 1;
+	     }
+
+	   buffer = xmalloc (len + 1);
+	   ptr = buffer;
+
+	   for (aptr=argv; *aptr; aptr++)
+	     {
+	       strcpy (ptr, *aptr);
+	       len += strlen (ptr) + 1;
+	       *ptr ++ = ' ';
+	       *ptr = 0;
+	     }
+
+	   ptr[-1] = '\n';
+
+	   Execute (buffer, NULL, child_stdout);
+	   free (buffer);
+
+	   Close (child_stdout);
+
+	   child_stdout = Open (tmp_output, MODE_OLDFILE);
+
+	   buffer = xmalloc (maxlen);
+	   i = 0;
+	   do
+	     {
+	       if (i == maxlen)
+		 {
+		   maxlen += 512;
+		   buffer = (char *) xrealloc (buffer, maxlen + 1);
+		 }
+
+	       cc = read (child_stdout, &buffer[i], maxlen - i);
+	       if (cc > 0)
+		 i += cc;
+	     } while (cc > 0);
+
+	   Close (child_stdout);
+	   DeleteFile (tmp_output);
+
+	   if (i > 0)
+	     {
+	       if (buffer[i - 1] == '\n')
+		 buffer[--i] = '\0';
+	       else
+		 buffer[i] = '\0';
+	       p = buffer;
+	       while ((p = index (p, '\n')) != 0)
+		 *p++ = ' ';
+	       o = variable_buffer_output (o, buffer, i);
+	     }
+	   free (buffer);
+	 }
+#endif	/* Not Amiga.  */
+#endif	/* MSDOS or Amiga.  */
 
 	free (text);
 	break;
diff --git a/job.c b/job.c
index 90ae9d9..098beee 100644
--- a/job.c
+++ b/job.c
@@ -25,7 +25,12 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 #include <assert.h>
 
 /* Default shell to use.  */
+#ifndef _AMIGA
 char default_shell[] = "/bin/sh";
+#else
+char default_shell[] = "";
+extern int MyExecute (char **);
+#endif
 
 #ifdef __MSDOS__
 #include <process.h>
@@ -35,6 +40,13 @@ static char *dos_bname;
 static char *dos_bename;
 static int dos_batch_file;
 #endif /* MSDOS.  */
+#ifdef _AMIGA
+#include <proto/dos.h>
+static int amiga_pid = 123;
+static int amiga_status;
+static char amiga_bname[32];
+static int amiga_batch_file;
+#endif /* Amiga.  */
 
 #ifdef VMS
 #include <time.h>
@@ -300,7 +312,7 @@ reap_children (block, err)
 	}
       else if (pid == 0)
 	{
-#ifndef	__MSDOS__
+#if !defined(__MSDOS__) && !defined(_AMIGA)
 	  /* No remote children.  Check for local children.  */
 
 	  if (any_local)
@@ -355,12 +367,21 @@ reap_children (block, err)
 	      coredump = WCOREDUMP (status);
 	    }
 #else	/* MSDOS.  */
+#ifdef __MSDOS__
 	  /* Life is very different on MSDOS.  */
 	  pid = dos_pid - 1;
 	  status = dos_status;
 	  exit_code = dos_status;
 	  exit_sig = 0;
 	  coredump = 0;
+#else
+	  /* Same on Amiga */
+	  pid = amiga_pid - 1;
+	  status = amiga_status;
+	  exit_code = amiga_status;
+	  exit_sig = 0;
+	  coredump = 0;
+#endif
 #endif	/* Not MSDOS.  */
 	}
       else
@@ -572,7 +593,9 @@ static void
 start_job_command (child)
      register struct child *child;
 {
+#ifndef _AMIGA
   static int bad_stdin = -1;
+#endif
   register char *p;
   int flags;
 #ifdef VMS
@@ -732,11 +755,13 @@ start_job_command (child)
 
   child->deleted = 0;
 
+#ifndef _AMIGA
   /* Set up the environment for the child.  */
   if (child->environment == 0)
     child->environment = target_environment (child->file);
+#endif
 
-#ifndef	__MSDOS__
+#if !defined(__MSDOS__) && !defined(_AMIGA)
 
 #ifndef VMS
   /* start_waiting_job has set CHILD->remote if we can start a remote job.  */
@@ -805,8 +830,8 @@ start_job_command (child)
 #endif /* !VMS */
     }
 
-#else	/* MSDOS.  */
-
+#else	/* MSDOS or Amiga.  */
+#ifdef __MSDOS__
   dos_status = spawnvpe (P_WAIT, argv[0], argv, child->environment);
   ++dead_children;
   child->pid = dos_pid++;
@@ -820,6 +845,17 @@ start_job_command (child)
        dos_status = 0;
      remove (dos_bename);
    }
+#else
+  amiga_status = MyExecute (argv);
+
+  ++dead_children;
+  child->pid = amiga_pid++;
+  if (amiga_batch_file)
+  {
+     amiga_batch_file = 0;
+     DeleteFile (amiga_bname);        /* Ignore errors.  */
+  }
+#endif	/* Not Amiga */
 #endif	/* Not MSDOS.  */
 
   /* We are the parent side.  Set the state to
@@ -1468,6 +1504,14 @@ construct_command_argv_internal (line, restp, shell, ifs)
 			     "mkdir", "path", "pause", "prompt", "rem", "ren",
 			     "rename", "set", "shift", "time", "type",
 			     "ver", "verify", "vol", ":", 0 };
+#endif
+#ifdef _AMIGA
+  static char sh_chars[] = "#;\"|<>()?*$`";
+  static char *sh_cmds[] = { "cd", "eval", "if", "delete", "echo", "copy",
+			     "rename", "set", "setenv", "date", "makedir",
+			     "skip", "else", "endif", "path", "prompt",
+			     "unset", "unsetenv", "version",
+			     0 };
 #else
   static char sh_chars[] = "#;\"*?[]&|<>(){}$`^";
   static char *sh_cmds[] = { "cd", "eval", "exec", "exit", "login",
@@ -1715,7 +1759,35 @@ construct_command_argv_internal (line, restp, shell, ifs)
      new_argv[0] = strdup (dos_bname);
      new_argv[1] = 0;
    }
-#else	/* Not MSDOS.  */
+#endif /* MSDOS. */
+#ifdef _AMIGA
+   {
+     char *ptr;
+     char *buffer;
+     char *dptr;
+
+     buffer = (char *)xmalloc (strlen (line)+1);
+
+     ptr = line;
+     for (dptr=buffer; *ptr; )
+     {
+	if (*ptr == '\\' && ptr[1] == '\n')
+	    ptr += 2;
+	else if (*ptr == '@') /* Kludge: multiline commands */
+	{
+	    ptr += 2;
+	    *dptr++ = '\n';
+	}
+	else
+	    *dptr++ = *ptr++;
+     }
+     *dptr = 0;
+
+     new_argv = (char **) xmalloc(2 * sizeof(char *));
+     new_argv[0] = buffer;
+     new_argv[1] = 0;
+   }
+#else	/* Not MSDOS or Amiga  */
   {
     /* SHELL may be a multi-word command.  Construct a command line
        "SHELL -c LINE", with all special chars in LINE escaped.
@@ -1773,7 +1845,7 @@ construct_command_argv_internal (line, restp, shell, ifs)
     new_argv = construct_command_argv_internal (new_line, (char **) NULL,
 						(char *) 0, (char *) 0);
   }
-#endif	/* MSDOS.  */
+#endif	/* Not MSDOS nor Amiga.  */
 
   return new_argv;
 }
@@ -1819,7 +1891,7 @@ construct_command_argv (line, restp, file)
 }
 #endif /* !VMS */
 
-#ifndef	HAVE_DUP2
+#if !defined(HAVE_DUP2) && !defined(_AMIGA)
 int
 dup2 (old, new)
      int old, new;
@@ -1837,4 +1909,4 @@ dup2 (old, new)
 
   return fd;
 }
-#endif
+#endif /* !HAPE_DUP2 && !_AMIGA */
diff --git a/main.c b/main.c
index efbd70e..3525fed 100644
--- a/main.c
+++ b/main.c
@@ -174,9 +174,13 @@ static unsigned int inf_jobs = 0;
    Negative values mean unlimited, while zero means limit to
    zero load (which could be useful to start infinite jobs remotely
    but one at a time locally).  */
-
+#ifndef NO_FLOAT
 double max_load_average = -1.0;
 double default_load_average = -1.0;
+#else
+int max_load_average = -1;
+int default_load_average = -1;
+#endif
 
 /* List of directories given with -C switches.  */
 
@@ -239,10 +243,17 @@ static const struct command_switch switches[] =
 	0, (char *) &default_keep_going_flag,
 	"keep-going", 0,
 	"Keep going when some targets can't be made" },
+#ifndef NO_FLOAT
     { 'l', floating, (char *) &max_load_average, 1, 1, 0,
 	(char *) &default_load_average, (char *) &default_load_average,
 	"load-average", "N",
 	"Don't start multiple jobs unless load is below N" },
+#else
+    { 'l', positive_int, (char *) &max_load_average, 1, 1, 0,
+	(char *) &default_load_average, (char *) &default_load_average,
+	"load-average", "N",
+	"Don't start multiple jobs unless load is below N" },
+#endif
     { 'm', ignore, 0, 0, 0, 0, 0, 0,
 	0, 0,
 	"-b" },
@@ -414,11 +425,15 @@ debug_signal_handler (sig)
   debug_flag = ! debug_flag;
 }
 
+#ifndef _AMIGA
 int
 main (argc, argv, envp)
      int argc;
      char **argv;
      char **envp;
+#else
+int main (int argc, char ** argv)
+#endif
 {
   register struct file *f;
   register unsigned int i;
@@ -452,8 +467,12 @@ main (argc, argv, envp)
   else									      \
     ADD_SIG (sig);
 
+#ifdef SIGHUP
   FATAL_SIG (SIGHUP);
+#endif
+#ifdef SIGQUIT
   FATAL_SIG (SIGQUIT);
+#endif
   FATAL_SIG (SIGINT);
   FATAL_SIG (SIGTERM);
 
@@ -530,6 +549,7 @@ main (argc, argv, envp)
      done before $(MAKE) is are figured out so its definitions will not be
      one from the environment.  */
 
+#ifndef _AMIGA
   for (i = 0; envp[i] != 0; ++i)
     {
       register char *ep = envp[i];
@@ -547,6 +567,41 @@ main (argc, argv, envp)
 	   be exported, because it was originally in the environment.  */
 	->export = v_export;
     }
+#else /* For Amiga, read the ENV: device, ignoring all dirs */
+    {
+	BPTR env, file, old;
+	char buffer[1024];
+	int len;
+	__aligned struct FileInfoBlock fib;
+
+	env = Lock ("ENV:", ACCESS_READ);
+	if (env)
+	{
+	    old = CurrentDir (DupLock(env));
+	    Examine (env, &fib);
+
+	    while (ExNext (env, &fib))
+	    {
+		if (fib.fib_DirEntryType < 0) /* File */
+		{
+		    file = Open (fib.fib_FileName, MODE_OLDFILE);
+
+		    if (file)
+		    {
+			len = Read (file, buffer, sizeof (buffer)-1);
+			buffer[len] = 0;
+
+			define_variable (fib.fib_FileName,
+			    strlen (fib.fib_FileName),
+			    buffer, o_env, 1)->export = v_export;
+		    }
+		}
+	    }
+	    UnLock (env);
+	    UnLock(CurrentDir(old));
+	}
+    }
+#endif
 
   /* Decode the switches.  */
 
@@ -1051,6 +1106,7 @@ main (argc, argv, envp)
 		fatal ("Couldn't change back to original directory.");
 	    }
 
+#ifndef _AMIGA
 	  for (p = environ; *p != 0; ++p)
 	    if (!strncmp (*p, "MAKELEVEL=", 10))
 	      {
@@ -1063,6 +1119,17 @@ main (argc, argv, envp)
 		sprintf (*p, "MAKELEVEL=%u", makelevel);
 		break;
 	      }
+#else /* AMIGA */
+#   include <dos/dos.h>
+#   include <proto/dos.h>
+	  {
+	    char buffer[256];
+	    int len;
+
+	    sprintf (buffer, "%u", makelevel);
+	    SetVar ("MAKELEVEL", buffer, -1, GVF_LOCAL_ONLY);
+	  }
+#endif
 
 	  if (debug_flag)
 	    {
@@ -1076,7 +1143,12 @@ main (argc, argv, envp)
 	  fflush (stdout);
 	  fflush (stderr);
 
+#ifndef _AMIGA
 	  exec_command (argv, environ);
+#else
+	  exec_command (argv);
+	  exit (0);
+#endif
 	  /* NOTREACHED */
 	}
     }
@@ -1372,6 +1444,7 @@ positive integral argument",
 		      = *(unsigned int *) cs->noarg_value;
 		  break;
 
+#ifndef NO_FLOAT
 		case floating:
 		  if (optarg == 0 && optind < argc
 		      && (isdigit (argv[optind][0]) || argv[optind][0] == '.'))
@@ -1383,6 +1456,7 @@ positive integral argument",
 			 : *(double *) cs->noarg_value);
 
 		  break;
+#endif
 		}
 
 	      /* We've found the switch.  Stop looking.  */
@@ -1702,6 +1776,7 @@ define_makeflags (all, makefile)
 	    }
 	  break;
 
+#ifndef NO_FLOAT
 	case floating:
 	  if (all)
 	    {
@@ -1721,6 +1796,7 @@ define_makeflags (all, makefile)
 		}
 	    }
 	  break;
+#endif
 
 	case string:
 	  if (all)
diff --git a/make.h b/make.h
index 04bc1e9..d2927c6 100644
--- a/make.h
+++ b/make.h
@@ -255,9 +255,19 @@ extern char *alloca ();
 #define streq(a, b) \
   ((a) == (b) || \
    (*(a) == *(b) && (*(a) == '\0' || !strcmp ((a) + 1, (b) + 1))))
+#ifdef _AMIGA
+#define strieq(a, b) \
+  ((a) == (b) || \
+   (tolower(*(a)) == tolower(*(b)) && (*(a) == '\0' || !strcmpi ((a) + 1, (b) + 1))))
+#else
+#define strieq(a, b) \
+  ((a) == (b) || \
+   (*(a) == *(b) && (*(a) == '\0' || !strcmp ((a) + 1, (b) + 1))))
+#endif
 #else
 /* Buggy compiler can't handle this.  */
 #define streq(a, b) (strcmp ((a), (b)) == 0)
+#define strieq(a, b) (strcmp ((a), (b)) == 0)
 #endif
 
 /* Add to VAR the hashing value of C, one character in a name.  */
@@ -376,7 +386,11 @@ extern int print_directory_flag, warn_undefined_variables_flag;
 extern int posix_pedantic;
 
 extern unsigned int job_slots;
+#ifndef NO_FLOAT
 extern double max_load_average;
+#else
+extern int max_load_average;
+#endif
 
 extern char *program;
 extern char *starting_directory;
diff --git a/make.lnk b/make.lnk
new file mode 100644
index 0000000..8fbbeff
--- /dev/null
+++ b/make.lnk
@@ -0,0 +1,5 @@
+FROM LIB:cres.o "commands.o"+"job.o"+"dir.o"+"file.o"+"misc.o"+"main.o"+"read.o"+"remake.o"+"rule.o"+"implicit.o"+"default.o"+"variable.o"+"expand.o"+"function.o"+"vpath.o"+"version.o"+"ar.o"+"arscan.o"+"signame.o"+"remote-stub.o"+"getopt.o"+"getopt1.o"+"alloca.o"+"amiga.o"
+TO "make.new"
+LIB glob/glob.lib LIB:sc.lib LIB:amiga.lib
+QUIET
+
diff --git a/read.c b/read.c
index 1de67f5..db35e10 100644
--- a/read.c
+++ b/read.c
@@ -78,9 +78,11 @@ static struct conditionals *conditionals = &toplevel_conditionals;
 static char *default_include_directories[] =
   {
     INCLUDEDIR,
+#ifndef _AMIGA
     "/usr/gnu/include",
     "/usr/local/include",
     "/usr/include",
+#endif
     0
   };
 
@@ -749,6 +751,22 @@ read_makefile (filename, flags)
 	  if (p != 0 && p[1] == '\\' && isalpha (p[-1]))
 	    p = 0;
 #endif
+#ifdef _AMIGA
+	  /* Here, the situation is quite complicated. Let's have a look
+	    at a couple of targets:
+
+		install: dev:make
+
+		dev:make: make
+
+		dev:make:: xyz
+
+	    The rule is that it's only a target, if there are TWO :'s
+	    OR a space around the :.
+	  */
+	  if (p && !(isspace(p[1]) || !p[1] || isspace(p[-1])))
+	    p = 0;
+#endif
 	  if (p != 0)
 	    {
 	      struct nameseq *target;
@@ -1569,6 +1587,13 @@ parse_file_seq (stringp, stopchar, size, strip)
       if (stopchar == ':' && p != 0 && p[1] == '\\' && isalpha (p[-1]))
 	p = 0;
 #endif
+#ifdef _AMIGA
+      if (stopchar == ':' && p && *p == ':' &&
+	!(isspace(p[1]) || !p[1] || isspace(p[-1])))
+      {
+	p = find_char_unquote (p+1, stopchars, 1);
+      }
+#endif
       if (p == 0)
 	p = q + strlen (q);
 
@@ -1950,6 +1975,7 @@ tilde_expand (name)
 	  free (home_dir);
 	  home_dir = getenv ("HOME");
 	}
+#ifndef _AMIGA
       if (home_dir == 0 || home_dir[0] == '\0')
 	{
 	  extern char *getlogin ();
@@ -1962,6 +1988,7 @@ tilde_expand (name)
 		home_dir = p->pw_dir;
 	    }
 	}
+#endif
       if (home_dir != 0)
 	{
 	  char *new = concat (home_dir, "", name + 1);
@@ -1970,6 +1997,7 @@ tilde_expand (name)
 	  return new;
 	}
     }
+#ifndef _AMIGA
   else
     {
       struct passwd *pwent;
@@ -2119,6 +2147,7 @@ multi_glob (chain, size)
 	  break;
 	}
     }
+#endif
 
   return new;
 }
diff --git a/remake.c b/remake.c
index befb7ad..8eb6a5d 100644
--- a/remake.c
+++ b/remake.c
@@ -1100,8 +1100,10 @@ library_search (lib, mtime_ptr)
 {
   static char *dirs[] =
     {
+#ifndef _AMIGA
       "/lib",
       "/usr/lib",
+#endif
       LIBDIR,			/* Defined by configuration.  */
       0
     };
@@ -1115,7 +1117,11 @@ library_search (lib, mtime_ptr)
 
   /* Look first for `libNAME.a' in the current directory.  */
 
+#ifndef _AMIGA
   sprintf (buf, "lib%s.a", libname);
+#else
+  sprintf (buf, "%s.lib", libname);
+#endif
   mtime = name_mtime (buf);
   if (mtime != (time_t) -1)
     {
@@ -1139,7 +1145,11 @@ library_search (lib, mtime_ptr)
 
   for (dp = dirs; *dp != 0; ++dp)
     {
+#ifndef _AMIGA
       sprintf (buf, "%s/lib%s.a", *dp, libname);
+#else
+      sprintf (buf, "%s/%s.lib", *dp, libname);
+#endif
       mtime = name_mtime (buf);
       if (mtime != (time_t) -1)
 	{
diff --git a/rule.c b/rule.c
index d38cf54..831c18c 100644
--- a/rule.c
+++ b/rule.c
@@ -574,6 +574,11 @@ print_rule_data_base ()
       printf ("\n# %u implicit rules, %u", rules, terminal);
 #ifndef	NO_FLOAT
       printf (" (%.1f%%)", (double) terminal / (double) rules * 100.0);
+#else
+      {
+	int f = (terminal * 1000 + 5) / rules;
+	printf (" (%d.%d%%)", f/10, f%10);
+      }
 #endif
       puts (" terminal.");
     }
diff --git a/variable.c b/variable.c
index a414516..12cfcc4 100644
--- a/variable.c
+++ b/variable.c
@@ -801,6 +801,14 @@ print_variable_set (set, prefix)
 max %u in one bucket.\n",
 	      (double) nvariables / (double) set->buckets,
 	      per_bucket);
+#else
+      {
+	int f = (nvariables * 1000 + 5) / set->buckets;
+	printf ("# average of %d.%d variables per bucket, \
+max %u in one bucket.\n",
+	      f/10, f%10,
+	      per_bucket);
+      }
 #endif
     }
 }
diff --git a/vpath.c b/vpath.c
index 3e78a9a..57f2b7c 100644
--- a/vpath.c
+++ b/vpath.c
@@ -1,5 +1,5 @@
 /* Implementation of pattern-matching file search paths for GNU Make.
-Copyright (C) 1988, 89, 91, 92, 93, 94, 95 Free Software Foundation, Inc.
+Copyright (C) 1988, 89, 91, 92, 93, 94, 95, 96 Free Software Foundation, Inc.
 This file is part of GNU Make.
 
 GNU Make is free software; you can redistribute it and/or modify
@@ -340,7 +340,7 @@ selective_vpath_search (path, file, mtime_ptr)
      a slash, the directory prefix that came with *FILE,
      another slash (although this one may not always be
      necessary), the filename, and a null terminator.  */
-  name = (char *) alloca (maxvpath + 1 + name_dplen + 1 + flen + 1);
+  name = (char *) xmalloc (maxvpath + 1 + name_dplen + 1 + flen + 1);
 
   /* Try each VPATH entry.  */
   for (i = 0; vpath[i] != 0; ++i)
@@ -432,6 +432,7 @@ selective_vpath_search (path, file, mtime_ptr)
 		   we record a zero modtime to indicate this.  */
 		*mtime_ptr = exists_in_cache ? st.st_mtime : (time_t) 0;
 
+	      free (name);
 	      return 1;
 	    }
 	  else
@@ -439,6 +440,7 @@ selective_vpath_search (path, file, mtime_ptr)
 	}
     }
 
+  free (name);
   return 0;
 }
 
-- 
cgit v1.0-41-gc330

