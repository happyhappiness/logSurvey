@@ -10,20 +10,20 @@ USAGE='<refname> <target directory>'
 export GIT_DIR
 
 test -z "$mandir" && usage
-if ! git-rev-parse --verify "$head^0" >/dev/null; then
+if ! git rev-parse --verify "$head^0" >/dev/null; then
 	echo >&2 "head: $head does not exist in the current repository"
 	usage
 fi
 
 GIT_INDEX_FILE=`pwd`/.quick-doc.index
 export GIT_INDEX_FILE
 rm -f "$GIT_INDEX_FILE"
-git-read-tree $head
-git-checkout-index -a -f --prefix="$mandir"/
+git read-tree $head
+git checkout-index -a -f --prefix="$mandir"/
 
 if test -n "$GZ"; then
 	cd "$mandir"
-	for i in `git-ls-tree -r --name-only $head`
+	for i in `git ls-tree -r --name-only $head`
 	do
 		gzip < $i > $i.gz && rm $i
 	done
@@ -30,8 +30,8 @@ notbare|"")
 esac
 
 test "true" != "$pack_refs" ||
-git-pack-refs --prune &&
-git-reflog expire --all &&
+git pack-refs --prune &&
+git reflog expire --all &&
 git-repack -a -d -l &&
-$no_prune git-prune &&
-git-rerere gc || exit
+$no_prune git prune &&
+git rerere gc || exit
@@ -17,8 +17,8 @@ dropheads() {
 		"$GIT_DIR/LAST_MERGE" || exit 1
 }
 
-head=$(git-rev-parse --verify "$1"^0) &&
-merge=$(git-rev-parse --verify "$2"^0) &&
+head=$(git rev-parse --verify "$1"^0) &&
+merge=$(git rev-parse --verify "$2"^0) &&
 merge_name="$2" &&
 merge_msg="$3" || usage
 
@@ -34,7 +34,7 @@ dropheads
 echo $head > "$GIT_DIR"/ORIG_HEAD
 echo $merge > "$GIT_DIR"/LAST_MERGE
 
-common=$(git-merge-base $head $merge)
+common=$(git merge-base $head $merge)
 if [ -z "$common" ]; then
 	die "Unable to find common commit between" $merge $head
 fi
@@ -46,11 +46,11 @@ case "$common" in
 	exit 0
 	;;
 "$head")
-	echo "Updating $(git-rev-parse --short $head)..$(git-rev-parse --short $merge)"
-	git-read-tree -u -m $head $merge || exit 1
-	git-update-ref -m "resolve $merge_name: Fast forward" \
+	echo "Updating $(git rev-parse --short $head)..$(git rev-parse --short $merge)"
+	git read-tree -u -m $head $merge || exit 1
+	git update-ref -m "resolve $merge_name: Fast forward" \
 		HEAD "$merge" "$head"
-	git-diff-tree -p $head $merge | git-apply --stat
+	git diff-tree -p $head $merge | git apply --stat
 	dropheads
 	exit 0
 	;;
@@ -62,7 +62,7 @@ git var GIT_COMMITTER_IDENT >/dev/null || exit
 # Find an optimum merge base if there are more than one candidates.
 LF='
 '
-common=$(git-merge-base -a $head $merge)
+common=$(git merge-base -a $head $merge)
 case "$common" in
 ?*"$LF"?*)
 	echo "Trying to find the optimum merge base."
@@ -72,10 +72,10 @@ case "$common" in
 	for c in $common
 	do
 		rm -f $G
-		GIT_INDEX_FILE=$G git-read-tree -m $c $head $merge \
+		GIT_INDEX_FILE=$G git read-tree -m $c $head $merge \
 			2>/dev/null || continue
 		# Count the paths that are unmerged.
-		cnt=`GIT_INDEX_FILE=$G git-ls-files --unmerged | wc -l`
+		cnt=`GIT_INDEX_FILE=$G git ls-files --unmerged | wc -l`
 		if test $best_cnt -le 0 -o $cnt -le $best_cnt
 		then
 			best=$c
@@ -92,21 +92,21 @@ case "$common" in
 esac
 
 echo "Trying to merge $merge into $head using $common."
-git-update-index --refresh 2>/dev/null
-git-read-tree -u -m $common $head $merge || exit 1
-result_tree=$(git-write-tree  2> /dev/null)
+git update-index --refresh 2>/dev/null
+git read-tree -u -m $common $head $merge || exit 1
+result_tree=$(git write-tree  2> /dev/null)
 if [ $? -ne 0 ]; then
 	echo "Simple merge failed, trying Automatic merge"
 	git-merge-index -o git-merge-one-file -a
 	if [ $? -ne 0 ]; then
 		echo $merge > "$GIT_DIR"/MERGE_HEAD
 		die "Automatic merge failed, fix up by hand"
 	fi
-	result_tree=$(git-write-tree) || exit 1
+	result_tree=$(git write-tree) || exit 1
 fi
-result_commit=$(echo "$merge_msg" | git-commit-tree $result_tree -p $head -p $merge)
+result_commit=$(echo "$merge_msg" | git commit-tree $result_tree -p $head -p $merge)
 echo "Committed merge $result_commit"
-git-update-ref -m "resolve $merge_name: In-index merge" \
+git update-ref -m "resolve $merge_name: In-index merge" \
 	HEAD "$result_commit" "$head"
-git-diff-tree -p $head $result_commit | git-apply --stat
+git diff-tree -p $head $result_commit | git apply --stat
 dropheads
@@ -26,8 +26,8 @@ if [ -d "$GIT_DIR"/remotes ]; then
 				mv "$GIT_DIR"/remotes "$GIT_DIR"/remotes.old
 			fi ;;
 		*)
-			echo "git-config $key "$value" $regex"
-			git-config $key "$value" $regex || error=1 ;;
+			echo "git config $key "$value" $regex"
+			git config $key "$value" $regex || error=1 ;;
 		esac
 	done
 fi
@@ -60,17 +60,17 @@ fall_back_3way () {
     mkdir "$dotest/patch-merge-tmp-dir"
 
     # First see if the patch records the index info that we can use.
-    git-apply -z --index-info "$dotest/patch" \
+    git apply -z --index-info "$dotest/patch" \
 	>"$dotest/patch-merge-index-info" &&
     GIT_INDEX_FILE="$dotest/patch-merge-tmp-index" \
-    git-update-index -z --index-info <"$dotest/patch-merge-index-info" &&
+    git update-index -z --index-info <"$dotest/patch-merge-index-info" &&
     GIT_INDEX_FILE="$dotest/patch-merge-tmp-index" \
-    git-write-tree >"$dotest/patch-merge-base+" ||
+    git write-tree >"$dotest/patch-merge-base+" ||
     cannot_fallback "Repository lacks necessary blobs to fall back on 3-way merge."
 
     echo Using index info to reconstruct a base tree...
     if GIT_INDEX_FILE="$dotest/patch-merge-tmp-index" \
-	git-apply $binary --cached <"$dotest/patch"
+	git apply $binary --cached <"$dotest/patch"
     then
 	mv "$dotest/patch-merge-base+" "$dotest/patch-merge-base"
 	mv "$dotest/patch-merge-tmp-index" "$dotest/patch-merge-index"
@@ -80,7 +80,7 @@ It does not apply to blobs recorded in its index."
     fi
 
     test -f "$dotest/patch-merge-index" &&
-    his_tree=$(GIT_INDEX_FILE="$dotest/patch-merge-index" git-write-tree) &&
+    his_tree=$(GIT_INDEX_FILE="$dotest/patch-merge-index" git write-tree) &&
     orig_tree=$(cat "$dotest/patch-merge-base") &&
     rm -fr "$dotest"/patch-merge-* || exit 1
 
@@ -97,7 +97,7 @@ It does not apply to blobs recorded in its index."
     git-merge-recursive $orig_tree -- HEAD $his_tree || {
 	    if test -d "$GIT_DIR/rr-cache"
 	    then
-		git-rerere
+		git rerere
 	    fi
 	    echo Failed to merge in the changes.
 	    exit 1
@@ -198,7 +198,7 @@ else
 	# Start afresh.
 	mkdir -p "$dotest" || exit
 
-	git-mailsplit -d"$prec" -o"$dotest" -b -- "$@" > "$dotest/last" ||  {
+	git mailsplit -d"$prec" -o"$dotest" -b -- "$@" > "$dotest/last" ||  {
 		rm -fr "$dotest"
 		exit 1
 	}
@@ -216,7 +216,7 @@ fi
 
 case "$resolved" in
 '')
-	files=$(git-diff-index --cached --name-only HEAD) || exit
+	files=$(git diff-index --cached --name-only HEAD) || exit
 	if [ "$files" ]; then
 	   echo "Dirty index: cannot apply patches (dirty: $files)" >&2
 	   exit 1
@@ -254,7 +254,7 @@ if test "$skip" = t
 then
 	if test -d "$GIT_DIR/rr-cache"
 	then
-		git-rerere clear
+		git rerere clear
 	fi
 	this=`expr "$this" + 1`
 	resume=
@@ -287,14 +287,14 @@ do
 	# by the user, or the user can tell us to do so by --resolved flag.
 	case "$resume" in
 	'')
-		git-mailinfo $keep $utf8 "$dotest/msg" "$dotest/patch" \
+		git mailinfo $keep $utf8 "$dotest/msg" "$dotest/patch" \
 			<"$dotest/$msgnum" >"$dotest/info" ||
 			stop_here $this
 		test -s $dotest/patch || {
 			echo "Patch is empty.  Was it split wrong?"
 			stop_here $this
 		}
-		git-stripspace < "$dotest/msg" > "$dotest/msg-clean"
+		git stripspace < "$dotest/msg" > "$dotest/msg-clean"
 		;;
 	esac
 
@@ -347,7 +347,7 @@ do
 		case "$resolved$interactive" in
 		tt)
 			# This is used only for interactive view option.
-			git-diff-index -p --cached HEAD >"$dotest/patch"
+			git diff-index -p --cached HEAD >"$dotest/patch"
 			;;
 		esac
 	esac
@@ -399,7 +399,7 @@ do
 
 	case "$resolved" in
 	'')
-		git-apply $git_apply_opt $binary --index "$dotest/patch"
+		git apply $git_apply_opt $binary --index "$dotest/patch"
 		apply_status=$?
 		;;
 	t)
@@ -408,11 +408,11 @@ do
 		# trust what the user has in the index file and the
 		# working tree.
 		resolved=
-		git-diff-index --quiet --cached HEAD && {
+		git diff-index --quiet --cached HEAD && {
 			echo "No changes - did you forget to use 'git add'?"
 			stop_here_user_resolve $this
 		}
-		unmerged=$(git-ls-files -u)
+		unmerged=$(git ls-files -u)
 		if test -n "$unmerged"
 		then
 			echo "You still have unmerged paths in your index"
@@ -433,7 +433,7 @@ do
 		then
 		    # Applying the patch to an earlier tree and merging the
 		    # result may have produced the same tree as ours.
-		    git-diff-index --quiet --cached HEAD && {
+		    git diff-index --quiet --cached HEAD && {
 			echo No changes -- Patch already applied.
 			go_next
 			continue
@@ -453,12 +453,12 @@ do
 		"$GIT_DIR"/hooks/pre-applypatch || stop_here $this
 	fi
 
-	tree=$(git-write-tree) &&
+	tree=$(git write-tree) &&
 	echo Wrote tree $tree &&
-	parent=$(git-rev-parse --verify HEAD) &&
-	commit=$(git-commit-tree $tree -p $parent <"$dotest/final-commit") &&
+	parent=$(git rev-parse --verify HEAD) &&
+	commit=$(git commit-tree $tree -p $parent <"$dotest/final-commit") &&
 	echo Committed: $commit &&
-	git-update-ref -m "$GIT_REFLOG_ACTION: $SUBJECT" HEAD $commit $parent ||
+	git update-ref -m "$GIT_REFLOG_ACTION: $SUBJECT" HEAD $commit $parent ||
 	stop_here $this
 
 	if test -x "$GIT_DIR"/hooks/post-applypatch
@@ -56,7 +56,7 @@ bisect_start() {
 	# Verify HEAD. If we were bisecting before this, reset to the
 	# top-of-line master first!
 	#
-	head=$(GIT_DIR="$GIT_DIR" git-symbolic-ref HEAD) ||
+	head=$(GIT_DIR="$GIT_DIR" git symbolic-ref HEAD) ||
 	die "Bad HEAD - I need a symbolic ref"
 	case "$head" in
 	refs/heads/bisect)
@@ -99,7 +99,7 @@ bisect_start() {
 		break
 		;;
 	    *)
-	        rev=$(git-rev-parse --verify "$arg^{commit}" 2>/dev/null) || {
+	        rev=$(git rev-parse --verify "$arg^{commit}" 2>/dev/null) || {
 		    test $has_double_dash -eq 1 &&
 		        die "'$arg' does not appear to be a valid revision"
 		    break
@@ -124,9 +124,9 @@ bisect_bad() {
 	bisect_autostart
 	case "$#" in
 	0)
-		rev=$(git-rev-parse --verify HEAD) ;;
+		rev=$(git rev-parse --verify HEAD) ;;
 	1)
-		rev=$(git-rev-parse --verify "$1^{commit}") ;;
+		rev=$(git rev-parse --verify "$1^{commit}") ;;
 	*)
 		usage ;;
 	esac || exit
@@ -138,19 +138,19 @@ bisect_bad() {
 bisect_write_bad() {
 	rev="$1"
 	echo "$rev" >"$GIT_DIR/refs/bisect/bad"
-	echo "# bad: "$(git-show-branch $rev) >>"$GIT_DIR/BISECT_LOG"
+	echo "# bad: "$(git show-branch $rev) >>"$GIT_DIR/BISECT_LOG"
 }
 
 bisect_good() {
 	bisect_autostart
         case "$#" in
-	0)    revs=$(git-rev-parse --verify HEAD) || exit ;;
-	*)    revs=$(git-rev-parse --revs-only --no-flags "$@") &&
+	0)    revs=$(git rev-parse --verify HEAD) || exit ;;
+	*)    revs=$(git rev-parse --revs-only --no-flags "$@") &&
 		test '' != "$revs" || die "Bad rev input: $@" ;;
 	esac
 	for rev in $revs
 	do
-		rev=$(git-rev-parse --verify "$rev^{commit}") || exit
+		rev=$(git rev-parse --verify "$rev^{commit}") || exit
 		bisect_write_good "$rev"
 		echo "git-bisect good $rev" >>"$GIT_DIR/BISECT_LOG"
 
@@ -161,7 +161,7 @@ bisect_good() {
 bisect_write_good() {
 	rev="$1"
 	echo "$rev" >"$GIT_DIR/refs/bisect/good-$rev"
-	echo "# good: "$(git-show-branch $rev) >>"$GIT_DIR/BISECT_LOG"
+	echo "# good: "$(git show-branch $rev) >>"$GIT_DIR/BISECT_LOG"
 }
 
 bisect_next_check() {
@@ -211,10 +211,10 @@ bisect_next() {
 	bisect_autostart
 	bisect_next_check good
 
-	bad=$(git-rev-parse --verify refs/bisect/bad) &&
+	bad=$(git rev-parse --verify refs/bisect/bad) &&
 	good=$(git for-each-ref --format='^%(objectname)' \
 		"refs/bisect/good-*" | tr '[\012]' ' ') &&
-	eval="git-rev-list --bisect-vars $good $bad --" &&
+	eval="git rev-list --bisect-vars $good $bad --" &&
 	eval="$eval $(cat "$GIT_DIR/BISECT_NAMES")" &&
 	eval=$(eval "$eval") &&
 	eval "$eval" || exit
@@ -225,16 +225,16 @@ bisect_next() {
 	fi
 	if [ "$bisect_rev" = "$bad" ]; then
 		echo "$bisect_rev is first bad commit"
-		git-diff-tree --pretty $bisect_rev
+		git diff-tree --pretty $bisect_rev
 		exit 0
 	fi
 
 	echo "Bisecting: $bisect_nr revisions left to test after this"
 	echo "$bisect_rev" >"$GIT_DIR/refs/heads/new-bisect"
 	git checkout -q new-bisect || exit
 	mv "$GIT_DIR/refs/heads/new-bisect" "$GIT_DIR/refs/heads/bisect" &&
-	GIT_DIR="$GIT_DIR" git-symbolic-ref HEAD refs/heads/bisect
-	git-show-branch "$bisect_rev"
+	GIT_DIR="$GIT_DIR" git symbolic-ref HEAD refs/heads/bisect
+	git show-branch "$bisect_rev"
 }
 
 bisect_visualize() {
@@ -250,7 +250,7 @@ bisect_reset() {
 	   else
 	       branch=master
 	   fi ;;
-	1) git-show-ref --verify --quiet -- "refs/heads/$1" || {
+	1) git show-ref --verify --quiet -- "refs/heads/$1" || {
 	       echo >&2 "$1 does not seem to be a valid branch"
 	       exit 1
 	   }
@@ -288,12 +288,12 @@ bisect_replay () {
 			;;
 		good)
 			echo "$rev" >"$GIT_DIR/refs/bisect/good-$rev"
-			echo "# good: "$(git-show-branch $rev) >>"$GIT_DIR/BISECT_LOG"
+			echo "# good: "$(git show-branch $rev) >>"$GIT_DIR/BISECT_LOG"
 			echo "git-bisect good $rev" >>"$GIT_DIR/BISECT_LOG"
 			;;
 		bad)
 			echo "$rev" >"$GIT_DIR/refs/bisect/bad"
-			echo "# bad: "$(git-show-branch $rev) >>"$GIT_DIR/BISECT_LOG"
+			echo "# bad: "$(git show-branch $rev) >>"$GIT_DIR/BISECT_LOG"
 			echo "git-bisect bad $rev" >>"$GIT_DIR/BISECT_LOG"
 			;;
 		*)
@@ -6,8 +6,8 @@ SUBDIRECTORY_OK=Sometimes
 require_work_tree
 
 old_name=HEAD
-old=$(git-rev-parse --verify $old_name 2>/dev/null)
-oldbranch=$(git-symbolic-ref $old_name 2>/dev/null)
+old=$(git rev-parse --verify $old_name 2>/dev/null)
+oldbranch=$(git symbolic-ref $old_name 2>/dev/null)
 new=
 new_name=
 force=
@@ -29,9 +29,9 @@ while [ "$#" != "0" ]; do
 		shift
 		[ -z "$newbranch" ] &&
 			die "git checkout: -b needs a branch name"
-		git-show-ref --verify --quiet -- "refs/heads/$newbranch" &&
+		git show-ref --verify --quiet -- "refs/heads/$newbranch" &&
 			die "git checkout: branch $newbranch already exists"
-		git-check-ref-format "heads/$newbranch" ||
+		git check-ref-format "heads/$newbranch" ||
 			die "git checkout: we do not like '$newbranch' as a branch name."
 		;;
 	"-l")
@@ -57,20 +57,20 @@ while [ "$#" != "0" ]; do
 		usage
 		;;
 	*)
-		if rev=$(git-rev-parse --verify "$arg^0" 2>/dev/null)
+		if rev=$(git rev-parse --verify "$arg^0" 2>/dev/null)
 		then
 			if [ -z "$rev" ]; then
 				echo "unknown flag $arg"
 				exit 1
 			fi
 			new_name="$arg"
-			if git-show-ref --verify --quiet -- "refs/heads/$arg"
+			if git show-ref --verify --quiet -- "refs/heads/$arg"
 			then
-				rev=$(git-rev-parse --verify "refs/heads/$arg^0")
+				rev=$(git rev-parse --verify "refs/heads/$arg^0")
 				branch="$arg"
 			fi
 			new="$rev"
-		elif rev=$(git-rev-parse --verify "$arg^{tree}" 2>/dev/null)
+		elif rev=$(git rev-parse --verify "$arg^{tree}" 2>/dev/null)
 		then
 			# checking out selected paths from a tree-ish.
 			new="$rev"
@@ -129,22 +129,22 @@ Did you intend to checkout '$@' which can not be resolved as commit?"
 		# from a specific tree-ish; note that this is for
 		# rescuing paths and is never meant to remove what
 		# is not in the named tree-ish.
-		git-ls-tree --full-name -r "$new" "$@" |
-		git-update-index --index-info || exit $?
+		git ls-tree --full-name -r "$new" "$@" |
+		git update-index --index-info || exit $?
 	fi
 
 	# Make sure the request is about existing paths.
-	git-ls-files --error-unmatch -- "$@" >/dev/null || exit
-	git-ls-files -- "$@" |
-	git-checkout-index -f -u --stdin
+	git ls-files --error-unmatch -- "$@" >/dev/null || exit
+	git ls-files -- "$@" |
+	git checkout-index -f -u --stdin
 	exit $?
 else
 	# Make sure we did not fall back on $arg^{tree} codepath
 	# since we are not checking out from an arbitrary tree-ish,
 	# but switching branches.
 	if test '' != "$new"
 	then
-		git-rev-parse --verify "$new^{commit}" >/dev/null 2>&1 ||
+		git rev-parse --verify "$new^{commit}" >/dev/null 2>&1 ||
 		die "Cannot switch branch to a non-commit."
 	fi
 fi
@@ -200,10 +200,10 @@ fi
 
 if [ "$force" ]
 then
-    git-read-tree $v --reset -u $new
+    git read-tree $v --reset -u $new
 else
-    git-update-index --refresh >/dev/null
-    merge_error=$(git-read-tree -m -u --exclude-per-directory=.gitignore $old $new 2>&1) || (
+    git update-index --refresh >/dev/null
+    merge_error=$(git read-tree -m -u --exclude-per-directory=.gitignore $old $new 2>&1) || (
 	case "$merge" in
 	'')
 		echo >&2 "$merge_error"
@@ -254,12 +254,12 @@ fi
 #
 if [ "$?" -eq 0 ]; then
 	if [ "$newbranch" ]; then
-		git-branch $track $newbranch_log "$newbranch" "$new_name" || exit
+		git branch $track $newbranch_log "$newbranch" "$new_name" || exit
 		branch="$newbranch"
 	fi
 	if test -n "$branch"
 	then
-		GIT_DIR="$GIT_DIR" git-symbolic-ref -m "checkout: moving to $branch" HEAD "refs/heads/$branch"
+		GIT_DIR="$GIT_DIR" git symbolic-ref -m "checkout: moving to $branch" HEAD "refs/heads/$branch"
 		if test -n "$quiet"
 		then
 			true	# nothing
@@ -271,7 +271,7 @@ if [ "$?" -eq 0 ]; then
 		fi
 	elif test -n "$detached"
 	then
-		git-update-ref --no-deref -m "checkout: moving to $arg" HEAD "$detached" ||
+		git update-ref --no-deref -m "checkout: moving to $arg" HEAD "$detached" ||
 			die "Cannot detach HEAD"
 		if test -n "$detach_warn"
 		then
@@ -20,7 +20,7 @@ require_work_tree
 ignored=
 ignoredonly=
 cleandir=
-disabled="`git-config --bool clean.requireForce`"
+disabled="`git config --bool clean.requireForce`"
 rmf="rm -f --"
 rmrf="rm -rf --"
 rm_refuse="echo Not removing"
@@ -83,7 +83,7 @@ if [ -z "$ignored" ]; then
 	fi
 fi
 
-git-ls-files --others --directory $excl ${excl_info:+"$excl_info"} -- "$@" |
+git ls-files --others --directory $excl ${excl_info:+"$excl_info"} -- "$@" |
 while read -r file; do
 	if [ -d "$file" -a ! -L "$file" ]; then
 		if [ -z "$cleandir" ]; then
@@ -43,7 +43,7 @@ clone_dumb_http () {
 	clone_tmp="$GIT_DIR/clone-tmp" &&
 	mkdir -p "$clone_tmp" || exit 1
 	if [ -n "$GIT_CURL_FTP_NO_EPSV" -o \
-		"`git-config --bool http.noEPSV`" = true ]; then
+		"`git config --bool http.noEPSV`" = true ]; then
 		curl_extra_args="${curl_extra_args} --disable-epsv"
 	fi
 	http_fetch "$1/info/refs" "$clone_tmp/refs" ||
@@ -132,7 +132,7 @@ while
 		*/*)
 		    die "'$2' is not suitable for an origin name"
 		esac
-		git-check-ref-format "heads/$2" ||
+		git check-ref-format "heads/$2" ||
 		    die "'$2' is not suitable for a branch name"
 		test -z "$origin_override" ||
 		    die "Do not give more than one --origin options."
@@ -195,7 +195,7 @@ yes)
 	GIT_DIR="$D" ;;
 *)
 	GIT_DIR="$D/.git" ;;
-esac && export GIT_DIR && git-init $quiet ${template+"$template"} || usage
+esac && export GIT_DIR && git init $quiet ${template+"$template"} || usage
 
 if test -n "$reference"
 then
@@ -345,7 +345,7 @@ then
 		*)
 			continue ;;
 		esac
-		git-update-ref -m "clone: from $repo" "$destname" "$sha1" ""
+		git update-ref -m "clone: from $repo" "$destname" "$sha1" ""
 	done < "$GIT_DIR/CLONE_HEAD"
 fi
 
@@ -389,39 +389,39 @@ then
 	)
 
 	# Upstream URL
-	git-config remote."$origin".url "$repo" &&
+	git config remote."$origin".url "$repo" &&
 
 	# Set up the mappings to track the remote branches.
-	git-config remote."$origin".fetch \
+	git config remote."$origin".fetch \
 		"+refs/heads/*:$remote_top/*" '^$' &&
 
 	# Write out remote.$origin config, and update our "$head_points_at".
 	case "$head_points_at" in
 	?*)
 		# Local default branch
-		git-symbolic-ref HEAD "refs/heads/$head_points_at" &&
+		git symbolic-ref HEAD "refs/heads/$head_points_at" &&
 
 		# Tracking branch for the primary branch at the remote.
-		git-update-ref HEAD "$head_sha1" &&
+		git update-ref HEAD "$head_sha1" &&
 
 		rm -f "refs/remotes/$origin/HEAD"
-		git-symbolic-ref "refs/remotes/$origin/HEAD" \
+		git symbolic-ref "refs/remotes/$origin/HEAD" \
 			"refs/remotes/$origin/$head_points_at" &&
 
-		git-config branch."$head_points_at".remote "$origin" &&
-		git-config branch."$head_points_at".merge "refs/heads/$head_points_at"
+		git config branch."$head_points_at".remote "$origin" &&
+		git config branch."$head_points_at".merge "refs/heads/$head_points_at"
 		;;
 	'')
 		# Source had detached HEAD pointing nowhere
-		git-update-ref --no-deref HEAD "$head_sha1" &&
+		git update-ref --no-deref HEAD "$head_sha1" &&
 		rm -f "refs/remotes/$origin/HEAD"
 		;;
 	esac
 
 	case "$no_checkout" in
 	'')
 		test "z$quiet" = z -a "z$no_progress" = z && v=-v || v=
-		git-read-tree -m -u $v HEAD HEAD
+		git read-tree -m -u $v HEAD HEAD
 	esac
 fi
 rm -f "$GIT_DIR/CLONE_HEAD" "$GIT_DIR/REMOTE_HEAD"
@@ -8,7 +8,7 @@ SUBDIRECTORY_OK=Yes
 . git-sh-setup
 require_work_tree
 
-git-rev-parse --verify HEAD >/dev/null 2>&1 || initial_commit=t
+git rev-parse --verify HEAD >/dev/null 2>&1 || initial_commit=t
 
 case "$0" in
 *status)
@@ -53,7 +53,7 @@ run_status () {
 	t) color= ;;
 	*) color=--nocolor ;;
 	esac
-	git-runstatus ${color} \
+	git runstatus ${color} \
 		${verbose:+--verbose} \
 		${amend:+--amend} \
 		${untracked_files:+--untracked}
@@ -335,20 +335,20 @@ t,)
 		cd_to_toplevel &&
 		GIT_INDEX_FILE="$NEXT_INDEX" &&
 		export GIT_INDEX_FILE &&
-		git-diff-files --name-only -z |
-		git-update-index --remove -z --stdin
+		git diff-files --name-only -z |
+		git update-index --remove -z --stdin
 	) || exit
 	;;
 ,t)
 	save_index &&
-	git-ls-files --error-unmatch -- "$@" >/dev/null || exit
+	git ls-files --error-unmatch -- "$@" >/dev/null || exit
 
-	git-diff-files --name-only -z -- "$@"  |
+	git diff-files --name-only -z -- "$@"  |
 	(
 		cd_to_toplevel &&
 		GIT_INDEX_FILE="$NEXT_INDEX" &&
 		export GIT_INDEX_FILE &&
-		git-update-index --remove -z --stdin
+		git update-index --remove -z --stdin
 	) || exit
 	;;
 ,)
@@ -364,28 +364,28 @@ t,)
 			refuse_partial "Cannot do a partial commit during a merge."
 		fi
 		TMP_INDEX="$GIT_DIR/tmp-index$$"
-		commit_only=`git-ls-files --error-unmatch -- "$@"` || exit
+		commit_only=`git ls-files --error-unmatch -- "$@"` || exit
 
 		# Build a temporary index and update the real index
 		# the same way.
 		if test -z "$initial_commit"
 		then
 			GIT_INDEX_FILE="$THIS_INDEX" \
-			git-read-tree --index-output="$TMP_INDEX" -i -m HEAD
+			git read-tree --index-output="$TMP_INDEX" -i -m HEAD
 		else
 			rm -f "$TMP_INDEX"
 		fi || exit
 
 		printf '%s\n' "$commit_only" |
 		GIT_INDEX_FILE="$TMP_INDEX" \
-		git-update-index --add --remove --stdin &&
+		git update-index --add --remove --stdin &&
 
 		save_index &&
 		printf '%s\n' "$commit_only" |
 		(
 			GIT_INDEX_FILE="$NEXT_INDEX"
 			export GIT_INDEX_FILE
-			git-update-index --remove --stdin
+			git update-index --remove --stdin
 		) || exit
 		;;
 	esac
@@ -408,12 +408,12 @@ case "$status_only" in
 t)
 	# This will silently fail in a read-only repository, which is
 	# what we want.
-	GIT_INDEX_FILE="$USE_INDEX" git-update-index -q --unmerged --refresh
+	GIT_INDEX_FILE="$USE_INDEX" git update-index -q --unmerged --refresh
 	run_status
 	exit $?
 	;;
 '')
-	GIT_INDEX_FILE="$USE_INDEX" git-update-index -q --refresh || exit
+	GIT_INDEX_FILE="$USE_INDEX" git update-index -q --refresh || exit
 	;;
 esac
 
@@ -454,7 +454,7 @@ then
 elif test -f "$GIT_DIR/SQUASH_MSG"
 then
 	cat "$GIT_DIR/SQUASH_MSG"
-fi | git-stripspace >"$GIT_DIR"/COMMIT_EDITMSG
+fi | git stripspace >"$GIT_DIR"/COMMIT_EDITMSG
 
 case "$signoff" in
 t)
@@ -505,12 +505,12 @@ then
 		PARENTS="-p HEAD "`sed -e 's/^/-p /' "$GIT_DIR/MERGE_HEAD"`
 	elif test -n "$amend"; then
 		rloga='commit (amend)'
-		PARENTS=$(git-cat-file commit HEAD |
+		PARENTS=$(git cat-file commit HEAD |
 			sed -n -e '/^$/q' -e 's/^parent /-p /p')
 	fi
-	current="$(git-rev-parse --verify HEAD)"
+	current="$(git rev-parse --verify HEAD)"
 else
-	if [ -z "$(git-ls-files)" ]; then
+	if [ -z "$(git ls-files)" ]; then
 		echo >&2 'nothing to commit (use "git add file1 file2" to include for commit)'
 		exit 1
 	fi
@@ -577,23 +577,23 @@ then
 else
     cat "$GIT_DIR"/COMMIT_EDITMSG
 fi |
-git-stripspace >"$GIT_DIR"/COMMIT_MSG
+git stripspace >"$GIT_DIR"/COMMIT_MSG
 
 if cnt=`grep -v -i '^Signed-off-by' "$GIT_DIR"/COMMIT_MSG |
-	git-stripspace |
+	git stripspace |
 	wc -l` &&
    test 0 -lt $cnt
 then
 	if test -z "$TMP_INDEX"
 	then
-		tree=$(GIT_INDEX_FILE="$USE_INDEX" git-write-tree)
+		tree=$(GIT_INDEX_FILE="$USE_INDEX" git write-tree)
 	else
-		tree=$(GIT_INDEX_FILE="$TMP_INDEX" git-write-tree) &&
+		tree=$(GIT_INDEX_FILE="$TMP_INDEX" git write-tree) &&
 		rm -f "$TMP_INDEX"
 	fi &&
-	commit=$(cat "$GIT_DIR"/COMMIT_MSG | git-commit-tree $tree $PARENTS) &&
+	commit=$(cat "$GIT_DIR"/COMMIT_MSG | git commit-tree $tree $PARENTS) &&
 	rlogm=$(sed -e 1q "$GIT_DIR"/COMMIT_MSG) &&
-	git-update-ref -m "$GIT_REFLOG_ACTION: $rlogm" HEAD $commit "$current" &&
+	git update-ref -m "$GIT_REFLOG_ACTION: $rlogm" HEAD $commit "$current" &&
 	rm -f -- "$GIT_DIR/MERGE_HEAD" "$GIT_DIR/MERGE_MSG" &&
 	if test -f "$NEXT_INDEX"
 	then
@@ -612,7 +612,7 @@ cd_to_toplevel
 
 if test -d "$GIT_DIR/rr-cache"
 then
-	git-rerere
+	git rerere
 fi
 
 if test "$ret" = 0
@@ -623,7 +623,7 @@ then
 	fi
 	if test -z "$quiet"
 	then
-		commit=`git-diff-tree --always --shortstat --pretty="format:%h: %s"\
+		commit=`git diff-tree --always --shortstat --pretty="format:%h: %s"\
 		       --summary --root HEAD --`
 		echo "Created${initial_commit:+ initial} commit $commit"
 	fi
@@ -117,20 +117,20 @@ append_fetch_head () {
 	test -n "$verbose" && flags="$flags$LF-v"
 	test -n "$force$single_force" && flags="$flags$LF-f"
 	GIT_REFLOG_ACTION="$GIT_REFLOG_ACTION" \
-		git-fetch--tool $flags append-fetch-head "$@"
+		git fetch--tool $flags append-fetch-head "$@"
 }
 
 # updating the current HEAD with git-fetch in a bare
 # repository is always fine.
 if test -z "$update_head_ok" && test $(is_bare_repository) = false
 then
-	orig_head=$(git-rev-parse --verify HEAD 2>/dev/null)
+	orig_head=$(git rev-parse --verify HEAD 2>/dev/null)
 fi
 
 # Allow --notags from remote.$1.tagopt
 case "$tags$no_tags" in
 '')
-	case "$(git-config --get "remote.$1.tagopt")" in
+	case "$(git config --get "remote.$1.tagopt")" in
 	--no-tags)
 		no_tags=t ;;
 	esac
@@ -146,7 +146,7 @@ if test "$tags"
 then
 	taglist=`IFS='	' &&
 		  echo "$ls_remote_result" |
-		  git-show-ref --exclude-existing=refs/tags/ |
+		  git show-ref --exclude-existing=refs/tags/ |
 	          while read sha1 name
 		  do
 			echo ".${name}:${name}"
@@ -163,18 +163,18 @@ fi
 
 fetch_all_at_once () {
 
-  eval=$(echo "$1" | git-fetch--tool parse-reflist "-")
+  eval=$(echo "$1" | git fetch--tool parse-reflist "-")
   eval "$eval"
 
     ( : subshell because we muck with IFS
       IFS=" 	$LF"
       (
 	if test "$remote" = . ; then
-	    git-show-ref $rref || echo failed "$remote"
+	    git show-ref $rref || echo failed "$remote"
 	elif test -f "$remote" ; then
 	    test -n "$shallow_depth" &&
 		die "shallow clone with bundle is not supported"
-	    git-bundle unbundle "$remote" $rref ||
+	    git bundle unbundle "$remote" $rref ||
 	    echo failed "$remote"
 	else
 		if	test -d "$remote" &&
@@ -190,16 +190,16 @@ fetch_all_at_once () {
 			# connected to our repository's tips, in which
 			# case we do not have to do any fetch.
 			theirs=$(echo "$ls_remote_result" | \
-				git-fetch--tool -s pick-rref "$rref" "-") &&
+				git fetch--tool -s pick-rref "$rref" "-") &&
 
 			# This will barf when $theirs reach an object that
 			# we do not have in our repository.  Otherwise,
 			# we already have everything the fetch would bring in.
-			git-rev-list --objects $theirs --not --all \
+			git rev-list --objects $theirs --not --all \
 				>/dev/null 2>/dev/null
 		then
 			echo "$ls_remote_result" | \
-				git-fetch--tool pick-rref "$rref" "-"
+				git fetch--tool pick-rref "$rref" "-"
 		else
 			flags=
 			case $verbose in
@@ -218,7 +218,7 @@ fetch_all_at_once () {
 	test -n "$verbose" && flags="$flags -v"
 	test -n "$force" && flags="$flags -f"
 	GIT_REFLOG_ACTION="$GIT_REFLOG_ACTION" \
-		git-fetch--tool $flags native-store \
+		git fetch--tool $flags native-store \
 			"$remote" "$remote_nick" "$refs"
       )
     ) || exit
@@ -265,13 +265,13 @@ fetch_per_ref () {
 	      curl_extra_args="-k"
 	  fi
 	  if [ -n "$GIT_CURL_FTP_NO_EPSV" -o \
-		"`git-config --bool http.noEPSV`" = true ]; then
+		"`git config --bool http.noEPSV`" = true ]; then
 	      noepsv_opt="--disable-epsv"
 	  fi
 
 	  # Find $remote_name from ls-remote output.
 	  head=$(echo "$ls_remote_result" | \
-		git-fetch--tool -s pick-rref "$remote_name" "-")
+		git fetch--tool -s pick-rref "$remote_name" "-")
 	  expr "z$head" : "z$_x40\$" >/dev/null ||
 		die "No such ref $remote_name at $remote"
 	  echo >&2 "Fetching $remote_name from $remote using $proto"
@@ -283,7 +283,7 @@ fetch_per_ref () {
 		die "shallow clone with rsync not supported"
 	  TMP_HEAD="$GIT_DIR/TMP_HEAD"
 	  rsync -L -q "$remote/$remote_name" "$TMP_HEAD" || exit 1
-	  head=$(git-rev-parse --verify TMP_HEAD)
+	  head=$(git rev-parse --verify TMP_HEAD)
 	  rm -f "$TMP_HEAD"
 	  case "$quiet" in '') v=-v ;; *) v= ;; esac
 	  test "$rsync_slurped_objects" || {
@@ -342,10 +342,10 @@ case "$no_tags$tags" in
 		# using local tracking branch.
 		taglist=$(IFS='	' &&
 		echo "$ls_remote_result" |
-		git-show-ref --exclude-existing=refs/tags/ |
+		git show-ref --exclude-existing=refs/tags/ |
 		while read sha1 name
 		do
-			git-cat-file -t "$sha1" >/dev/null 2>&1 || continue
+			git cat-file -t "$sha1" >/dev/null 2>&1 || continue
 			echo >&2 "Auto-following $name"
 			echo ".${name}:${name}"
 		done)
@@ -365,10 +365,10 @@ case "$orig_head" in
 '')
 	;;
 ?*)
-	curr_head=$(git-rev-parse --verify HEAD 2>/dev/null)
+	curr_head=$(git rev-parse --verify HEAD 2>/dev/null)
 	if test "$curr_head" != "$orig_head"
 	then
-	    git-update-ref \
+	    git update-ref \
 			-m "$GIT_REFLOG_ACTION: Undoing incorrectly fetched HEAD." \
 			HEAD "$orig_head"
 		die "Cannot fetch into the current branch."
@@ -81,7 +81,7 @@
 #	This is the filter for rewriting the commit's parent list.
 #	It will receive the parent string on stdin and shall output
 #	the new parent string on stdout. The parent string is in
-#	format accepted by `git-commit-tree`: empty for initial
+#	format accepted by `git commit-tree`: empty for initial
 #	commit, "-p parent" for a normal commit and "-p parent1
 #	-p parent2 -p parent3 ..." for a merge commit.
 #
@@ -93,7 +93,7 @@
 #
 # --commit-filter COMMAND:: The filter for performing the commit
 #	If this filter is passed, it will be called instead of the
-#	`git-commit-tree` command, with those arguments:
+#	`git commit-tree` command, with those arguments:
 #
 #		TREE_ID [-p PARENT_COMMIT_ID]...
 #
@@ -132,7 +132,7 @@
 #
 # A significantly faster version:
 #
-#	git-filter-branch --index-filter 'git-update-index --remove filename' newbranch
+#	git-filter-branch --index-filter 'git update-index --remove filename' newbranch
 #
 # Now, you will get the rewritten history saved in the branch 'newbranch'
 # (your current branch is left untouched).
@@ -151,7 +151,7 @@
 #
 # To remove commits authored by "Darl McBribe" from the history:
 #
-#	git-filter-branch --commit-filter 'if [ "$GIT_AUTHOR_NAME" = "Darl McBribe" ]; then shift; while [ -n "$1" ]; do shift; echo "$1"; shift; done; else git-commit-tree "$@"; fi' newbranch
+#	git-filter-branch --commit-filter 'if [ "$GIT_AUTHOR_NAME" = "Darl McBribe" ]; then shift; while [ -n "$1" ]; do shift; echo "$1"; shift; done; else git commit-tree "$@"; fi' newbranch
 #
 # (the shift magic first throws away the tree id and then the -p
 # parameters). Note that this handles merges properly! In case Darl
@@ -182,9 +182,9 @@
 # To move the whole tree into a subdirectory, or remove it from there:
 #
 # git-filter-branch --index-filter \
-#	'git-ls-files -s | sed "s-\t-&newsubdir/-" |
+#	'git ls-files -s | sed "s-\t-&newsubdir/-" |
 #		GIT_INDEX_FILE=$GIT_INDEX_FILE.new \
-#			git-update-index --index-info &&
+#			git update-index --index-info &&
 #	 mv $GIT_INDEX_FILE.new $GIT_INDEX_FILE' directorymoved
 
 # Testsuite: TODO
@@ -240,7 +240,7 @@ filter_tree=
 filter_index=
 filter_parent=
 filter_msg=cat
-filter_commit='git-commit-tree "$@"'
+filter_commit='git commit-tree "$@"'
 filter_tag_name=
 filter_subdir=
 while case "$#" in 0) usage;; esac
@@ -300,7 +300,7 @@ done
 dstbranch="$1"
 shift
 test -n "$dstbranch" || die "missing branch name"
-git-show-ref "refs/heads/$dstbranch" 2> /dev/null &&
+git show-ref "refs/heads/$dstbranch" 2> /dev/null &&
 	die "branch $dstbranch already exists"
 
 test ! -e "$tempdir" || die "$tempdir already exists, please remove it"
@@ -318,7 +318,7 @@ esac
 export GIT_DIR GIT_WORK_TREE=.
 
 export GIT_INDEX_FILE="$(pwd)/../index"
-git-read-tree # seed the index file
+git read-tree # seed the index file
 
 ret=0
 
@@ -327,11 +327,11 @@ mkdir ../map # map old->new commit ids for rewriting parents
 
 case "$filter_subdir" in
 "")
-	git-rev-list --reverse --topo-order --default HEAD \
+	git rev-list --reverse --topo-order --default HEAD \
 		--parents "$@"
 	;;
 *)
-	git-rev-list --reverse --topo-order --default HEAD \
+	git rev-list --reverse --topo-order --default HEAD \
 		--parents --full-history "$@" -- "$filter_subdir"
 esac > ../revs
 commits=$(cat ../revs | wc -l | tr -d " ")
@@ -345,29 +345,29 @@ while read commit parents; do
 
 	case "$filter_subdir" in
 	"")
-		git-read-tree -i -m $commit
+		git read-tree -i -m $commit
 		;;
 	*)
-		git-read-tree -i -m $commit:"$filter_subdir"
+		git read-tree -i -m $commit:"$filter_subdir"
 	esac
 
 	export GIT_COMMIT=$commit
-	git-cat-file commit "$commit" >../commit
+	git cat-file commit "$commit" >../commit
 
 	eval "$(set_ident AUTHOR <../commit)"
 	eval "$(set_ident COMMITTER <../commit)"
 	eval "$filter_env" < /dev/null
 
 	if [ "$filter_tree" ]; then
-		git-checkout-index -f -u -a
+		git checkout-index -f -u -a
 		# files that $commit removed are now still in the working tree;
 		# remove them, else they would be added again
-		git-ls-files -z --others | xargs -0 rm -f
+		git ls-files -z --others | xargs -0 rm -f
 		eval "$filter_tree" < /dev/null
-		git-diff-index -r $commit | cut -f 2- | tr '\n' '\0' | \
-			xargs -0 git-update-index --add --replace --remove
-		git-ls-files -z --others | \
-			xargs -0 git-update-index --add --replace --remove
+		git diff-index -r $commit | cut -f 2- | tr '\n' '\0' | \
+			xargs -0 git update-index --add --replace --remove
+		git ls-files -z --others | \
+			xargs -0 git update-index --add --replace --remove
 	fi
 
 	eval "$filter_index" < /dev/null
@@ -384,7 +384,7 @@ while read commit parents; do
 
 	sed -e '1,/^$/d' <../commit | \
 		eval "$filter_msg" | \
-		sh -c "$filter_commit" "git-commit-tree" $(git-write-tree) $parentstr | \
+		sh -c "$filter_commit" "git commit-tree" $(git write-tree) $parentstr | \
 		tee ../map/$commit
 done <../revs
 
@@ -395,7 +395,7 @@ case "$target_head" in
 	echo Nothing rewritten
 	;;
 *)
-	git-update-ref refs/heads/"$dstbranch" $target_head
+	git update-ref refs/heads/"$dstbranch" $target_head
 	if [ $(cat ../map/$src_head | wc -l) -gt 1 ]; then
 		echo "WARNING: Your commit filter caused the head commit to expand to several rewritten commits. Only the first such commit was recorded as the current $dstbranch head but you will need to resolve the situation now (probably by manually merging the other commits). These are all the commits:" >&2
 		sed 's/^/	/' ../map/$src_head >&2
@@ -405,7 +405,7 @@ case "$target_head" in
 esac
 
 if [ "$filter_tag_name" ]; then
-	git-for-each-ref --format='%(objectname) %(objecttype) %(refname)' refs/tags |
+	git for-each-ref --format='%(objectname) %(objecttype) %(refname)' refs/tags |
 	while read sha1 type ref; do
 		ref="${ref#refs/tags/}"
 		# XXX: Rewrite tagged trees as well?
@@ -416,7 +416,7 @@ if [ "$filter_tag_name" ]; then
 		if [ "$type" = "tag" ]; then
 			# Dereference to a commit
 			sha1t="$sha1"
-			sha1="$(git-rev-parse "$sha1"^{commit} 2>/dev/null)" || continue
+			sha1="$(git rev-parse "$sha1"^{commit} 2>/dev/null)" || continue
 		fi
 
 		[ -f "../map/$sha1" ] || continue
@@ -431,7 +431,7 @@ if [ "$filter_tag_name" ]; then
 			warn "unreferencing tag object $sha1t"
 		fi
 
-		git-update-ref "refs/tags/$new_ref" "$new_sha1"
+		git update-ref "refs/tags/$new_ref" "$new_sha1"
 	done
 fi
 
@@ -17,10 +17,10 @@ while read dangling type sha1
 do
 	case "$dangling" in
 	dangling)
-		if git-rev-parse --verify "$sha1^0" >/dev/null 2>/dev/null
+		if git rev-parse --verify "$sha1^0" >/dev/null 2>/dev/null
 		then
 			dir="$laf/commit"
-			git-show-branch "$sha1"
+			git show-branch "$sha1"
 		else
 			dir="$laf/other"
 		fi
@@ -58,7 +58,7 @@ http://* | https://* | ftp://* )
             curl_extra_args="-k"
         fi
 	if [ -n "$GIT_CURL_FTP_NO_EPSV" -o \
-		"`git-config --bool http.noEPSV`" = true ]; then
+		"`git config --bool http.noEPSV`" = true ]; then
 		curl_extra_args="${curl_extra_args} --disable-epsv"
 	fi
 	curl -nsf $curl_extra_args --header "Pragma: no-cache" "$peek_repo/info/refs" ||
@@ -45,7 +45,7 @@ esac
 # MRT is the current "merge result tree"
 
 MRC=$head MSG= PARENT="-p $head"
-MRT=$(git-write-tree)
+MRT=$(git write-tree)
 CNT=1 ;# counting our head
 NON_FF_MERGE=0
 OCTOPUS_FAILURE=0
@@ -61,7 +61,7 @@ do
 		exit 2
 	esac
 
-	common=$(git-merge-base --all $MRC $SHA1) ||
+	common=$(git merge-base --all $MRC $SHA1) ||
 		die "Unable to find common commit with $SHA1"
 
 	case "$LF$common$LF" in
@@ -82,22 +82,22 @@ do
 		# We still need to count this as part of the parent set.
 
 		echo "Fast forwarding to: $SHA1"
-		git-read-tree -u -m $head $SHA1 || exit
-		MRC=$SHA1 MRT=$(git-write-tree)
+		git read-tree -u -m $head $SHA1 || exit
+		MRC=$SHA1 MRT=$(git write-tree)
 		continue
 	fi
 
 	NON_FF_MERGE=1
 
 	echo "Trying simple merge with $SHA1"
-	git-read-tree -u -m --aggressive  $common $MRT $SHA1 || exit 2
-	next=$(git-write-tree 2>/dev/null)
+	git read-tree -u -m --aggressive  $common $MRT $SHA1 || exit 2
+	next=$(git write-tree 2>/dev/null)
 	if test $? -ne 0
 	then
 		echo "Simple merge did not work, trying automatic merge."
 		git-merge-index -o git-merge-one-file -a ||
 		OCTOPUS_FAILURE=1
-		next=$(git-write-tree 2>/dev/null)
+		next=$(git write-tree 2>/dev/null)
 	fi
 
 	# We have merged the other branch successfully.  Ideally
@@ -13,7 +13,7 @@
 #   $7 - file in branch2 mode (or empty)
 #
 # Handle some trivial cases.. The _really_ trivial cases have
-# been handled already by git-read-tree, but that one doesn't
+# been handled already by git read-tree, but that one doesn't
 # do any merges that might change the tree layout.
 
 case "${1:-.}${2:-.}${3:-.}" in
@@ -34,7 +34,7 @@ case "${1:-.}${2:-.}${3:-.}" in
 		rm -f -- "$4" &&
 		rmdir -p "$(expr "z$4" : 'z\(.*\)/')" 2>/dev/null || :
 	fi &&
-		exec git-update-index --remove -- "$4"
+		exec git update-index --remove -- "$4"
 	;;
 
 #
@@ -50,8 +50,8 @@ case "${1:-.}${2:-.}${3:-.}" in
 		echo "ERROR: untracked $4 is overwritten by the merge."
 		exit 1
 	}
-	git-update-index --add --cacheinfo "$6$7" "$2$3" "$4" &&
-		exec git-checkout-index -u -f -- "$4"
+	git update-index --add --cacheinfo "$6$7" "$2$3" "$4" &&
+		exec git checkout-index -u -f -- "$4"
 	;;
 
 #
@@ -64,8 +64,8 @@ case "${1:-.}${2:-.}${3:-.}" in
 		exit 1
 	fi
 	echo "Adding $4"
-	git-update-index --add --cacheinfo "$6" "$2" "$4" &&
-		exec git-checkout-index -u -f -- "$4"
+	git update-index --add --cacheinfo "$6" "$2" "$4" &&
+		exec git checkout-index -u -f -- "$4"
 	;;
 
 #
@@ -84,11 +84,11 @@ case "${1:-.}${2:-.}${3:-.}" in
 	case "$1" in
 	'')
 		echo "Added $4 in both, but differently."
-		# This extracts OUR file in $orig, and uses git-apply to
+		# This extracts OUR file in $orig, and uses git apply to
 		# remove lines that are unique to ours.
 		orig=`git-unpack-file $2`
 		sz0=`wc -c <"$orig"`
-		diff -u -La/$orig -Lb/$orig $orig $src2 | git-apply --no-add
+		diff -u -La/$orig -Lb/$orig $orig $src2 | git apply --no-add
 		sz1=`wc -c <"$orig"`
 
 		# If we do not have enough common material, it is not
@@ -104,12 +104,12 @@ case "${1:-.}${2:-.}${3:-.}" in
 	# Be careful for funny filename such as "-L" in "$4", which
 	# would confuse "merge" greatly.
 	src1=`git-unpack-file $2`
-	git-merge-file "$src1" "$orig" "$src2"
+	git merge-file "$src1" "$orig" "$src2"
 	ret=$?
 
 	# Create the working tree file, using "our tree" version from the
 	# index, and then store the result of the merge.
-	git-checkout-index -f --stage=2 -- "$4" && cat "$src1" >"$4"
+	git checkout-index -f --stage=2 -- "$4" && cat "$src1" >"$4"
 	rm -f -- "$orig" "$src1" "$src2"
 
 	if [ "$6" != "$7" ]; then
@@ -124,7 +124,7 @@ case "${1:-.}${2:-.}${3:-.}" in
 		echo "ERROR: Merge conflict in $4"
 		exit 1
 	fi
-	exec git-update-index -- "$4"
+	exec git update-index -- "$4"
 	;;
 
 *)
@@ -9,6 +9,6 @@
 # because the current index is what we will be committing as the
 # merge result.
 
-git-diff-index --quiet --cached HEAD || exit 2
+git diff-index --quiet --cached HEAD || exit 2
 
 exit 0
@@ -37,10 +37,10 @@ then
 	exit 2
 fi
 
-git-update-index --refresh 2>/dev/null
-git-read-tree -u -m --aggressive $bases $head $remotes || exit 2
+git update-index --refresh 2>/dev/null
+git read-tree -u -m --aggressive $bases $head $remotes || exit 2
 echo "Trying simple merge."
-if result_tree=$(git-write-tree  2>/dev/null)
+if result_tree=$(git write-tree  2>/dev/null)
 then
 	exit 0
 else
@@ -40,10 +40,10 @@ case "$bases" in
 	for c in $bases
 	do
 		rm -f $G
-		GIT_INDEX_FILE=$G git-read-tree -m $c $head $remotes \
+		GIT_INDEX_FILE=$G git read-tree -m $c $head $remotes \
 			 2>/dev/null ||	continue
 		# Count the paths that are unmerged.
-		cnt=`GIT_INDEX_FILE=$G git-ls-files --unmerged | wc -l`
+		cnt=`GIT_INDEX_FILE=$G git ls-files --unmerged | wc -l`
 		if test $best_cnt -le 0 -o $cnt -le $best_cnt
 		then
 			best=$c
@@ -63,10 +63,10 @@ case "$bases" in
 	;;
 esac
 
-git-update-index --refresh 2>/dev/null
-git-read-tree -u -m $common $head $remotes || exit 2
+git update-index --refresh 2>/dev/null
+git read-tree -u -m $common $head $remotes || exit 2
 echo "Trying simple merge."
-if result_tree=$(git-write-tree  2>/dev/null)
+if result_tree=$(git write-tree  2>/dev/null)
 then
 	exit 0
 else
@@ -31,7 +31,7 @@ dropsave() {
 
 savestate() {
 	# Stash away any local modifications.
-	git-diff-index -z --name-only $head |
+	git diff-index -z --name-only $head |
 	cpio -0 -o >"$GIT_DIR/MERGE_SAVE"
 }
 
@@ -40,7 +40,7 @@ restorestate() {
 	then
 		git reset --hard $head >/dev/null
 		cpio -iuv <"$GIT_DIR/MERGE_SAVE"
-		git-update-index --refresh >/dev/null
+		git update-index --refresh >/dev/null
 	fi
 }
 
@@ -57,7 +57,7 @@ finish_up_to_date () {
 squash_message () {
 	echo Squashed commit of the following:
 	echo
-	git-log --no-merges ^"$head" $remote
+	git log --no-merges ^"$head" $remote
 }
 
 finish () {
@@ -79,7 +79,7 @@ finish () {
 			echo "No merge message -- not updating HEAD"
 			;;
 		*)
-			git-update-ref -m "$rlogm" HEAD "$1" "$head" || exit 1
+			git update-ref -m "$rlogm" HEAD "$1" "$head" || exit 1
 			;;
 		esac
 		;;
@@ -91,21 +91,21 @@ finish () {
 		if test "$show_diffstat" = t
 		then
 			# We want color (if set), but no pager
-			GIT_PAGER='' git-diff --stat --summary -M "$head" "$1"
+			GIT_PAGER='' git diff --stat --summary -M "$head" "$1"
 		fi
 		;;
 	esac
 }
 
 merge_name () {
 	remote="$1"
-	rh=$(git-rev-parse --verify "$remote^0" 2>/dev/null) || return
-	bh=$(git-show-ref -s --verify "refs/heads/$remote" 2>/dev/null)
+	rh=$(git rev-parse --verify "$remote^0" 2>/dev/null) || return
+	bh=$(git show-ref -s --verify "refs/heads/$remote" 2>/dev/null)
 	if test "$rh" = "$bh"
 	then
 		echo "$rh		branch '$remote' of ."
 	elif truname=$(expr "$remote" : '\(.*\)~[1-9][0-9]*$') &&
-		git-show-ref -q --verify "refs/heads/$truname" 2>/dev/null
+		git show-ref -q --verify "refs/heads/$truname" 2>/dev/null
 	then
 		echo "$rh		branch '$truname' (early part) of ."
 	elif test "$remote" = "FETCH_HEAD" -a -r "$GIT_DIR/FETCH_HEAD"
@@ -170,7 +170,7 @@ do
 done
 
 if test -z "$show_diffstat"; then
-    test "$(git-config --bool merge.diffstat)" = false && show_diffstat=false
+    test "$(git config --bool merge.diffstat)" = false && show_diffstat=false
     test -z "$show_diffstat" && show_diffstat=t
 fi
 
@@ -181,15 +181,15 @@ fi
 # have "-m" so it is an additional safety measure to check for it.
 
 if test -z "$have_message" &&
-	second_token=$(git-rev-parse --verify "$2^0" 2>/dev/null) &&
-	head_commit=$(git-rev-parse --verify "HEAD" 2>/dev/null) &&
+	second_token=$(git rev-parse --verify "$2^0" 2>/dev/null) &&
+	head_commit=$(git rev-parse --verify "HEAD" 2>/dev/null) &&
 	test "$second_token" = "$head_commit"
 then
 	merge_msg="$1"
 	shift
 	head_arg="$1"
 	shift
-elif ! git-rev-parse --verify HEAD >/dev/null 2>&1
+elif ! git rev-parse --verify HEAD >/dev/null 2>&1
 then
 	# If the merged head is a valid one there is no reason to
 	# forbid "git merge" into a branch yet to be born.  We do
@@ -203,8 +203,8 @@ then
 	rh=$(git rev-parse --verify "$1^0") ||
 		die "$1 - not something we can merge"
 
-	git-update-ref -m "initial pull" HEAD "$rh" "" &&
-	git-read-tree --reset -u HEAD
+	git update-ref -m "initial pull" HEAD "$rh" "" &&
+	git read-tree --reset -u HEAD
 	exit
 
 else
@@ -219,11 +219,11 @@ else
 	merge_name=$(for remote
 		do
 			merge_name "$remote"
-		done | git-fmt-merge-msg
+		done | git fmt-merge-msg
 	)
 	merge_msg="${merge_msg:+$merge_msg$LF$LF}$merge_name"
 fi
-head=$(git-rev-parse --verify "$head_arg"^0) || usage
+head=$(git rev-parse --verify "$head_arg"^0) || usage
 
 # All the rest are remote heads
 test "$#" = 0 && usage ;# we need at least one remote head.
@@ -232,7 +232,7 @@ set_reflog_action "merge $*"
 remoteheads=
 for remote
 do
-	remotehead=$(git-rev-parse --verify "$remote"^0 2>/dev/null) ||
+	remotehead=$(git rev-parse --verify "$remote"^0 2>/dev/null) ||
 	    die "$remote - not something we can merge"
 	remoteheads="${remoteheads}$remotehead "
 	eval GITHEAD_$remotehead='"$remote"'
@@ -244,15 +244,15 @@ case "$use_strategies" in
 '')
 	case "$#" in
 	1)
-		var="`git-config --get pull.twohead`"
+		var="`git config --get pull.twohead`"
 		if test -n "$var"
 		then
 			use_strategies="$var"
 		else
 			use_strategies="$default_twohead_strategies"
 		fi ;;
 	*)
-		var="`git-config --get pull.octopus`"
+		var="`git config --get pull.octopus`"
 		if test -n "$var"
 		then
 			use_strategies="$var"
@@ -278,10 +278,10 @@ done
 
 case "$#" in
 1)
-	common=$(git-merge-base --all $head "$@")
+	common=$(git merge-base --all $head "$@")
 	;;
 *)
-	common=$(git-show-branch --merge-base $head "$@")
+	common=$(git show-branch --merge-base $head "$@")
 	;;
 esac
 echo "$head" >"$GIT_DIR/ORIG_HEAD"
@@ -301,15 +301,15 @@ f,*)
 	;;
 ?,1,"$head",*)
 	# Again the most common case of merging one remote.
-	echo "Updating $(git-rev-parse --short $head)..$(git-rev-parse --short $1)"
-	git-update-index --refresh 2>/dev/null
+	echo "Updating $(git rev-parse --short $head)..$(git rev-parse --short $1)"
+	git update-index --refresh 2>/dev/null
 	msg="Fast forward"
 	if test -n "$have_message"
 	then
 		msg="$msg (no commit created; -m option ignored)"
 	fi
-	new_head=$(git-rev-parse --verify "$1^0") &&
-	git-read-tree -v -m -u --exclude-per-directory=.gitignore $head "$new_head" &&
+	new_head=$(git rev-parse --verify "$1^0") &&
+	git read-tree -v -m -u --exclude-per-directory=.gitignore $head "$new_head" &&
 	finish "$new_head" "$msg" || exit
 	dropsave
 	exit 0
@@ -321,7 +321,7 @@ f,*)
 ?,1,*,)
 	# We are not doing octopus, not fast forward, and have only
 	# one common.
-	git-update-index --refresh 2>/dev/null
+	git update-index --refresh 2>/dev/null
 	case " $use_strategies " in
 	*' recursive '*|*' recur '*)
 		: run merge later
@@ -330,13 +330,13 @@ f,*)
 		# See if it is really trivial.
 		git var GIT_COMMITTER_IDENT >/dev/null || exit
 		echo "Trying really trivial in-index merge..."
-		if git-read-tree --trivial -m -u -v $common $head "$1" &&
-		   result_tree=$(git-write-tree)
+		if git read-tree --trivial -m -u -v $common $head "$1" &&
+		   result_tree=$(git write-tree)
 		then
 			echo "Wonderful."
 			result_commit=$(
 				printf '%s\n' "$merge_msg" |
-				git-commit-tree $result_tree -p HEAD -p "$1"
+				git commit-tree $result_tree -p HEAD -p "$1"
 			) || exit
 			finish "$result_commit" "In-index merge"
 			dropsave
@@ -350,7 +350,7 @@ f,*)
 	up_to_date=t
 	for remote
 	do
-		common_one=$(git-merge-base --all $head $remote)
+		common_one=$(git merge-base --all $head $remote)
 		if test "$common_one" != "$remote"
 		then
 			up_to_date=f
@@ -419,8 +419,8 @@ do
 	if test "$exit" -eq 1
 	then
 	    cnt=`{
-		git-diff-files --name-only
-		git-ls-files --unmerged
+		git diff-files --name-only
+		git ls-files --unmerged
 	    } | wc -l`
 	    if test $best_cnt -le 0 -o $cnt -le $best_cnt
 	    then
@@ -432,15 +432,15 @@ do
     }
 
     # Automerge succeeded.
-    result_tree=$(git-write-tree) && break
+    result_tree=$(git write-tree) && break
 done
 
 # If we have a resulting tree, that means the strategy module
 # auto resolved the merge cleanly.
 if test '' != "$result_tree"
 then
-    parents=$(git-show-branch --independent "$head" "$@" | sed -e 's/^/-p /')
-    result_commit=$(printf '%s\n' "$merge_msg" | git-commit-tree $result_tree $parents) || exit
+    parents=$(git show-branch --independent "$head" "$@" | sed -e 's/^/-p /')
+    result_commit=$(printf '%s\n' "$merge_msg" | git commit-tree $result_tree $parents) || exit
     finish "$result_commit" "Merge made by $wt_strategy."
     dropsave
     exit 0
@@ -498,7 +498,7 @@ Conflicts:
 	} >>"$GIT_DIR/MERGE_MSG"
 	if test -d "$GIT_DIR/rr-cache"
 	then
-		git-rerere
+		git rerere
 	fi
 	die "Automatic merge failed; fix conflicts and then commit the result."
 fi
@@ -65,14 +65,14 @@ resolve_symlink_merge () {
 	read ans
 	case "$ans" in
 	    [lL]*)
-		git-checkout-index -f --stage=2 -- "$path"
-		git-add -- "$path"
+		git checkout-index -f --stage=2 -- "$path"
+		git add -- "$path"
 		cleanup_temp_files --save-backup
 		return
 		;;
 	    [rR]*)
-		git-checkout-index -f --stage=3 -- "$path"
-		git-add -- "$path"
+		git checkout-index -f --stage=3 -- "$path"
+		git add -- "$path"
 		cleanup_temp_files --save-backup
 		return
 		;;
@@ -93,12 +93,12 @@ resolve_deleted_merge () {
 	read ans
 	case "$ans" in
 	    [mMcC]*)
-		git-add -- "$path"
+		git add -- "$path"
 		cleanup_temp_files --save-backup
 		return
 		;;
 	    [dD]*)
-		git-rm -- "$path" > /dev/null
+		git rm -- "$path" > /dev/null
 		cleanup_temp_files
 		return
 		;;
@@ -140,7 +140,7 @@ remove_backup () {
 merge_file () {
     path="$1"
 
-    f=`git-ls-files -u -- "$path"`
+    f=`git ls-files -u -- "$path"`
     if test -z "$f" ; then
 	if test ! -f "$path" ; then
 	    echo "$path: file not found"
@@ -297,7 +297,7 @@ do
 done
 
 if test -z "$merge_tool"; then
-    merge_tool=`git-config merge.tool`
+    merge_tool=`git config merge.tool`
     case "$merge_tool" in
 	kdiff3 | tkdiff | xxdiff | meld | opendiff | emerge | vimdiff | gvimdiff | "")
 	    ;; # happy
@@ -2,7 +2,7 @@
 
 # git-ls-remote could be called from outside a git managed repository;
 # this would fail in that case and would issue an error message.
-GIT_DIR=$(git-rev-parse --git-dir 2>/dev/null) || :;
+GIT_DIR=$(git rev-parse --git-dir 2>/dev/null) || :;
 
 get_data_source () {
 	case "$1" in
@@ -13,7 +13,7 @@ get_data_source () {
 		echo self
 		;;
 	*)
-		if test "$(git-config --get "remote.$1.url")"
+		if test "$(git config --get "remote.$1.url")"
 		then
 			echo config
 		elif test -f "$GIT_DIR/remotes/$1"
@@ -38,7 +38,7 @@ get_remote_url () {
 		echo "$1"
 		;;
 	config)
-		git-config --get "remote.$1.url"
+		git config --get "remote.$1.url"
 		;;
 	remotes)
 		sed -ne '/^URL: */{
@@ -55,8 +55,8 @@ get_remote_url () {
 }
 
 get_default_remote () {
-	curr_branch=$(git-symbolic-ref -q HEAD | sed -e 's|^refs/heads/||')
-	origin=$(git-config --get "branch.$curr_branch.remote")
+	curr_branch=$(git symbolic-ref -q HEAD | sed -e 's|^refs/heads/||')
+	origin=$(git config --get "branch.$curr_branch.remote")
 	echo ${origin:-origin}
 }
 
@@ -66,7 +66,7 @@ get_remote_default_refs_for_push () {
 	'' | branches | self)
 		;; # no default push mapping, just send matching refs.
 	config)
-		git-config --get-all "remote.$1.push" ;;
+		git config --get-all "remote.$1.push" ;;
 	remotes)
 		sed -ne '/^Push: */{
 			s///p
@@ -107,9 +107,9 @@ canon_refs_list_for_fetch () {
 		shift
 		if test "$remote" = "$(get_default_remote)"
 		then
-			curr_branch=$(git-symbolic-ref -q HEAD | \
+			curr_branch=$(git symbolic-ref -q HEAD | \
 			    sed -e 's|^refs/heads/||')
-			merge_branches=$(git-config \
+			merge_branches=$(git config \
 			    --get-all "branch.${curr_branch}.merge")
 		fi
 		if test -z "$merge_branches" && test $is_explicit != explicit
@@ -156,7 +156,7 @@ canon_refs_list_for_fetch () {
 
 		if local_ref_name=$(expr "z$local" : 'zrefs/\(.*\)')
 		then
-		   git-check-ref-format "$local_ref_name" ||
+		   git check-ref-format "$local_ref_name" ||
 		   die "* refusing to create funny ref '$local_ref_name' locally"
 		fi
 		echo "${dot_prefix}${force}${remote}:${local}"
@@ -171,11 +171,11 @@ get_remote_default_refs_for_fetch () {
 		echo "HEAD:" ;;
 	self)
 	        canon_refs_list_for_fetch -d "$1" \
-			$(git-for-each-ref --format='%(refname):')
+			$(git for-each-ref --format='%(refname):')
 		;;
 	config)
 		canon_refs_list_for_fetch -d "$1" \
-			$(git-config --get-all "remote.$1.fetch") ;;
+			$(git config --get-all "remote.$1.fetch") ;;
 	branches)
 		remote_branch=$(sed -ne '/#/s/.*#//p' "$GIT_DIR/branches/$1")
 		case "$remote_branch" in '') remote_branch=master ;; esac
@@ -254,7 +254,7 @@ get_uploadpack () {
 	data_source=$(get_data_source "$1")
 	case "$data_source" in
 	config)
-		uplp=$(git-config --get "remote.$1.uploadpack")
+		uplp=$(git config --get "remote.$1.uploadpack")
 		echo ${uplp:-git-upload-pack}
 		;;
 	*)
@@ -54,10 +54,10 @@ do
 	shift
 done
 
-orig_head=$(git-rev-parse --verify HEAD 2>/dev/null)
+orig_head=$(git rev-parse --verify HEAD 2>/dev/null)
 git-fetch --update-head-ok "$@" || exit 1
 
-curr_head=$(git-rev-parse --verify HEAD 2>/dev/null)
+curr_head=$(git rev-parse --verify HEAD 2>/dev/null)
 if test "$curr_head" != "$orig_head"
 then
 	# The fetch involved updating the current branch.
@@ -69,8 +69,8 @@ then
 	echo >&2 "Warning: fetch updated the current branch head."
 	echo >&2 "Warning: fast forwarding your working tree from"
 	echo >&2 "Warning: commit $orig_head."
-	git-update-index --refresh 2>/dev/null
-	git-read-tree -u -m "$orig_head" "$curr_head" ||
+	git update-index --refresh 2>/dev/null
+	git read-tree -u -m "$orig_head" "$curr_head" ||
 		die 'Cannot fast-forward your working tree.
 After making sure that you saved anything precious from
 $ git diff '$orig_head'
@@ -86,7 +86,7 @@ merge_head=$(sed -e '/	not-for-merge	/d' \
 
 case "$merge_head" in
 '')
-	curr_branch=$(git-symbolic-ref -q HEAD)
+	curr_branch=$(git symbolic-ref -q HEAD)
 	case $? in
 	  0) ;;
 	  1) echo >&2 "You are not currently on a branch; you must explicitly"
@@ -113,11 +113,11 @@ esac
 
 if test -z "$orig_head"
 then
-	git-update-ref -m "initial pull" HEAD $merge_head "" &&
-	git-read-tree --reset -u HEAD || exit 1
+	git update-ref -m "initial pull" HEAD $merge_head "" &&
+	git read-tree --reset -u HEAD || exit 1
 	exit
 fi
 
-merge_name=$(git-fmt-merge-msg <"$GIT_DIR/FETCH_HEAD") || exit
+merge_name=$(git fmt-merge-msg <"$GIT_DIR/FETCH_HEAD") || exit
 exec git-merge $no_summary $no_commit $squash $strategy_args \
 	"$merge_name" HEAD $merge_head
@@ -67,12 +67,12 @@ tmp_info="$tmp_dir/info"
 
 
 # Find the intial commit
-commit=$(git-rev-parse HEAD)
+commit=$(git rev-parse HEAD)
 
 mkdir $tmp_dir || exit 2
 for patch_name in $(cat "$QUILT_PATCHES/series" | grep -v '^#'); do
 	echo $patch_name
-	(cat $QUILT_PATCHES/$patch_name | git-mailinfo "$tmp_msg" "$tmp_patch" > "$tmp_info") || exit 3
+	(cat $QUILT_PATCHES/$patch_name | git mailinfo "$tmp_msg" "$tmp_patch" > "$tmp_info") || exit 3
 	test -s .dotest/patch || {
 		echo "Patch is empty.  Was it split wrong?"
 		exit 1
@@ -113,10 +113,10 @@ for patch_name in $(cat "$QUILT_PATCHES/series" | grep -v '^#'); do
 	fi
 
 	if [ -z "$dry_run" ] ; then
-		git-apply --index -C1 "$tmp_patch" &&
-		tree=$(git-write-tree) &&
-		commit=$( (echo "$SUBJECT"; echo; cat "$tmp_msg") | git-commit-tree $tree -p $commit) &&
-		git-update-ref -m "quiltimport: $patch_name" HEAD $commit || exit 4
+		git apply --index -C1 "$tmp_patch" &&
+		tree=$(git write-tree) &&
+		commit=$( (echo "$SUBJECT"; echo; cat "$tmp_msg") | git commit-tree $tree -p $commit) &&
+		git update-ref -m "quiltimport: $patch_name" HEAD $commit || exit 4
 	fi
 done
 rm -rf $tmp_dir || exit 5
@@ -51,15 +51,15 @@ continue_merge () {
 	test -n "$prev_head" || die "prev_head must be defined"
 	test -d "$dotest" || die "$dotest directory does not exist"
 
-	unmerged=$(git-ls-files -u)
+	unmerged=$(git ls-files -u)
 	if test -n "$unmerged"
 	then
 		echo "You still have unmerged paths in your index"
 		echo "did you forget to use git add?"
 		die "$RESOLVEMSG"
 	fi
 
-	if ! git-diff-index --quiet HEAD
+	if ! git diff-index --quiet HEAD
 	then
 		if ! git-commit -C "`cat $dotest/current`"
 		then
@@ -71,10 +71,10 @@ continue_merge () {
 	else
 		printf "Already applied: %0${prec}d" $msgnum
 	fi
-	echo ' '`git-rev-list --pretty=oneline -1 HEAD | \
+	echo ' '`git rev-list --pretty=oneline -1 HEAD | \
 				sed 's/^[a-f0-9]\+ //'`
 
-	prev_head=`git-rev-parse HEAD^0`
+	prev_head=`git rev-parse HEAD^0`
 	# save the resulting commit so we can read-tree on it later
 	echo "$prev_head" > "$dotest/prev_head"
 
@@ -86,8 +86,8 @@ continue_merge () {
 call_merge () {
 	cmt="$(cat $dotest/cmt.$1)"
 	echo "$cmt" > "$dotest/current"
-	hd=$(git-rev-parse --verify HEAD)
-	cmt_name=$(git-symbolic-ref HEAD)
+	hd=$(git rev-parse --verify HEAD)
+	cmt_name=$(git symbolic-ref HEAD)
 	msgnum=$(cat $dotest/msgnum)
 	end=$(cat $dotest/end)
 	eval GITHEAD_$cmt='"${cmt_name##refs/heads/}~$(($end - $msgnum))"'
@@ -101,7 +101,7 @@ call_merge () {
 		return
 		;;
 	1)
-		test -d "$GIT_DIR/rr-cache" && git-rerere
+		test -d "$GIT_DIR/rr-cache" && git rerere
 		die "$RESOLVEMSG"
 		;;
 	2)
@@ -134,7 +134,7 @@ while case "$#" in 0) break ;; esac
 do
 	case "$1" in
 	--continue)
-		git-diff-files --quiet || {
+		git diff-files --quiet || {
 			echo "You must edit all merge conflicts and then"
 			echo "mark them as resolved using git add"
 			exit 1
@@ -162,7 +162,7 @@ do
 		then
 			if test -d "$GIT_DIR/rr-cache"
 			then
-				git-rerere clear
+				git rerere clear
 			fi
 			prev_head="`cat $dotest/prev_head`"
 			end="`cat $dotest/end`"
@@ -183,7 +183,7 @@ do
 	--abort)
 		if test -d "$GIT_DIR/rr-cache"
 		then
-			git-rerere clear
+			git rerere clear
 		fi
 		if test -d "$dotest"
 		then
@@ -259,8 +259,8 @@ else
 fi
 
 # The tree must be really really clean.
-git-update-index --refresh || exit
-diff=$(git-diff-index --cached --name-status -r HEAD)
+git update-index --refresh || exit
+diff=$(git diff-index --cached --name-status -r HEAD)
 case "$diff" in
 ?*)	echo "cannot rebase: your index is not up-to-date"
 	echo "$diff"
@@ -275,7 +275,7 @@ upstream=`git rev-parse --verify "${upstream_name}^0"` ||
 
 # Make sure the branch to rebase onto is valid.
 onto_name=${newbase-"$upstream_name"}
-onto=$(git-rev-parse --verify "${onto_name}^0") || exit
+onto=$(git rev-parse --verify "${onto_name}^0") || exit
 
 # If a hook exists, give it a chance to interrupt
 if test -x "$GIT_DIR/hooks/pre-rebase"
@@ -301,13 +301,13 @@ case "$#" in
 	fi
 	;;
 esac
-branch=$(git-rev-parse --verify "${branch_name}^0") || exit
+branch=$(git rev-parse --verify "${branch_name}^0") || exit
 
 # Now we are rebasing commits $upstream..$branch on top of $onto
 
 # Check if we are already based on $onto, but this should be
 # done only when upstream and onto are the same.
-mb=$(git-merge-base "$onto" "$branch")
+mb=$(git merge-base "$onto" "$branch")
 if test "$upstream" = "$onto" && test "$mb" = "$onto"
 then
 	echo >&2 "Current branch $branch_name is up to date."
@@ -318,7 +318,7 @@ if test -n "$verbose"
 then
 	echo "Changes from $mb to $onto:"
 	# We want color (if set), but no pager
-	GIT_PAGER='' git-diff --stat --summary "$mb" "$onto"
+	GIT_PAGER='' git diff --stat --summary "$mb" "$onto"
 fi
 
 # Rewind the head to "$onto"; this saves our current head in ORIG_HEAD.
@@ -335,7 +335,7 @@ fi
 
 if test -z "$do_merge"
 then
-	git-format-patch -k --stdout --full-index --ignore-if-in-upstream "$upstream"..ORIG_HEAD |
+	git format-patch -k --stdout --full-index --ignore-if-in-upstream "$upstream"..ORIG_HEAD |
 	git am $git_am_opt --binary -3 -k --resolvemsg="$RESOLVEMSG"
 	exit $?
 fi
@@ -346,11 +346,11 @@ fi
 mkdir -p "$dotest"
 echo "$onto" > "$dotest/onto"
 echo "$onto_name" > "$dotest/onto_name"
-prev_head=`git-rev-parse HEAD^0`
+prev_head=`git rev-parse HEAD^0`
 echo "$prev_head" > "$dotest/prev_head"
 
 msgnum=0
-for cmt in `git-rev-list --reverse --no-merges "$upstream"..ORIG_HEAD`
+for cmt in `git rev-list --reverse --no-merges "$upstream"..ORIG_HEAD`
 do
 	msgnum=$(($msgnum + 1))
 	echo "$cmt" > "$dotest/cmt.$msgnum"
@@ -63,7 +63,7 @@ case ",$all_into_one," in
 esac
 
 args="$args $local $quiet $no_reuse$extra"
-names=$(git-pack-objects --non-empty --all --reflog $args </dev/null "$PACKTMP") ||
+names=$(git pack-objects --non-empty --all --reflog $args </dev/null "$PACKTMP") ||
 	exit 1
 if [ -z "$names" ]; then
 	echo Nothing new to pack.
@@ -113,7 +113,7 @@ then
 		  done
 		)
 	fi
-	git-prune-packed $quiet
+	git prune-packed $quiet
 fi
 
 case "$no_update_info" in
@@ -18,8 +18,8 @@ head=${3-HEAD}
 [ "$base" ] || usage
 [ "$url" ] || usage
 
-baserev=`git-rev-parse --verify "$base"^0` &&
-headrev=`git-rev-parse --verify "$head"^0` || exit
+baserev=`git rev-parse --verify "$base"^0` &&
+headrev=`git rev-parse --verify "$head"^0` || exit
 
 merge_base=`git merge-base $baserev $headrev` ||
 die "fatal: No commits in common between $base and $head"
@@ -24,7 +24,7 @@ do
 		usage
 		;;
 	*)
-		rev=$(git-rev-parse --verify "$1") || exit
+		rev=$(git rev-parse --verify "$1") || exit
 		shift
 		break
 		;;
@@ -33,7 +33,7 @@ do
 done
 
 : ${rev=HEAD}
-rev=$(git-rev-parse --verify $rev^0) || exit
+rev=$(git rev-parse --verify $rev^0) || exit
 
 # Skip -- in "git reset HEAD -- foo" and "git reset -- foo".
 case "$1" in --) shift ;; esac
@@ -46,7 +46,7 @@ then
 	test "$reset_type" = "--mixed" ||
 		die "Cannot do partial $reset_type reset."
 
-	git-diff-index --cached $rev -- "$@" |
+	git diff-index --cached $rev -- "$@" |
 	sed -e 's/^:\([0-7][0-7]*\) [0-7][0-7]* \([0-9a-f][0-9a-f]*\) [0-9a-f][0-9a-f]* [A-Z]	\(.*\)$/\1 \2	\3/' |
 	git update-index --add --remove --index-info || exit
 	git update-index --refresh
@@ -66,22 +66,22 @@ fi
 if test "$reset_type" = "--soft"
 then
 	if test -f "$GIT_DIR/MERGE_HEAD" ||
-	   test "" != "$(git-ls-files --unmerged)"
+	   test "" != "$(git ls-files --unmerged)"
 	then
 		die "Cannot do a soft reset in the middle of a merge."
 	fi
 else
-	git-read-tree -v --reset $update "$rev" || exit
+	git read-tree -v --reset $update "$rev" || exit
 fi
 
 # Any resets update HEAD to the head being switched to.
-if orig=$(git-rev-parse --verify HEAD 2>/dev/null)
+if orig=$(git rev-parse --verify HEAD 2>/dev/null)
 then
 	echo "$orig" >"$GIT_DIR/ORIG_HEAD"
 else
 	rm -f "$GIT_DIR/ORIG_HEAD"
 fi
-git-update-ref -m "$GIT_REFLOG_ACTION" HEAD "$rev"
+git update-ref -m "$GIT_REFLOG_ACTION" HEAD "$rev"
 update_ref_status=$?
 
 case "$reset_type" in
@@ -96,7 +96,7 @@ case "$reset_type" in
 	;; # Nothing else to do
 --mixed )
 	# Report what has not been updated.
-	git-update-index --refresh
+	git update-index --refresh
 	;;
 esac
 
@@ -29,11 +29,11 @@ set_reflog_action() {
 }
 
 is_bare_repository () {
-	git-rev-parse --is-bare-repository
+	git rev-parse --is-bare-repository
 }
 
 cd_to_toplevel () {
-	cdup=$(git-rev-parse --show-cdup)
+	cdup=$(git rev-parse --show-cdup)
 	if test ! -z "$cdup"
 	then
 		cd "$cdup" || {
@@ -44,8 +44,8 @@ cd_to_toplevel () {
 }
 
 require_work_tree () {
-	test $(git-rev-parse --is-inside-work-tree) = true &&
-	test $(git-rev-parse --is-inside-git-dir) = false ||
+	test $(git rev-parse --is-inside-work-tree) = true &&
+	test $(git rev-parse --is-inside-git-dir) = false ||
 	die "fatal: $0 cannot be used without a working tree."
 }
 
@@ -95,12 +95,12 @@ esac
 if [ -z "$SUBDIRECTORY_OK" ]
 then
 	: ${GIT_DIR=.git}
-	GIT_DIR=$(GIT_DIR="$GIT_DIR" git-rev-parse --git-dir) || {
+	GIT_DIR=$(GIT_DIR="$GIT_DIR" git rev-parse --git-dir) || {
 		exit=$?
 		echo >&2 "You need to run this command from the toplevel of the working tree."
 		exit $exit
 	}
 else
-	GIT_DIR=$(git-rev-parse --git-dir) || exit
+	GIT_DIR=$(git rev-parse --git-dir) || exit
 fi
 : ${GIT_OBJECT_DIRECTORY="$GIT_DIR/objects"}
@@ -12,8 +12,8 @@ trap 'rm -f "$TMP-*"' 0
 ref_stash=refs/stash
 
 no_changes () {
-	git-diff-index --quiet --cached HEAD &&
-	git-diff-files --quiet
+	git diff-index --quiet --cached HEAD &&
+	git diff-files --quiet
 }
 
 clear_stash () {
@@ -32,14 +32,14 @@ save_stash () {
 		clear_stash || die "Cannot initialize stash"
 
 	# state of the base commit
-	if b_commit=$(git-rev-parse --verify HEAD)
+	if b_commit=$(git rev-parse --verify HEAD)
 	then
-		head=$(git-log --abbrev-commit --pretty=oneline -n 1 HEAD)
+		head=$(git log --abbrev-commit --pretty=oneline -n 1 HEAD)
 	else
 		die "You do not have the initial commit yet"
 	fi
 
-	if branch=$(git-symbolic-ref -q HEAD)
+	if branch=$(git symbolic-ref -q HEAD)
 	then
 		branch=${branch#refs/heads/}
 	else
@@ -48,9 +48,9 @@ save_stash () {
 	msg=$(printf '%s: %s' "$branch" "$head")
 
 	# state of the index
-	i_tree=$(git-write-tree) &&
+	i_tree=$(git write-tree) &&
 	i_commit=$(printf 'index on %s' "$msg" |
-		git-commit-tree $i_tree -p $b_commit) ||
+		git commit-tree $i_tree -p $b_commit) ||
 		die "Cannot save the current index state"
 
 	# state of the working tree
@@ -59,57 +59,57 @@ save_stash () {
 		export GIT_INDEX_FILE &&
 
 		rm -f "$TMP-index" &&
-		git-read-tree $i_tree &&
-		git-add -u &&
-		git-write-tree &&
+		git read-tree $i_tree &&
+		git add -u &&
+		git write-tree &&
 		rm -f "$TMP-index"
 	) ) ||
 		die "Cannot save the current worktree state"
 
 	# create the stash
 	w_commit=$(printf 'WIP on %s' "$msg" |
-		git-commit-tree $w_tree -p $b_commit -p $i_commit) ||
+		git commit-tree $w_tree -p $b_commit -p $i_commit) ||
 		die "Cannot record working tree state"
 
-	git-update-ref -m "$msg" $ref_stash $w_commit ||
+	git update-ref -m "$msg" $ref_stash $w_commit ||
 		die "Cannot save the current status"
 	printf >&2 'Saved WIP on %s\n' "$msg"
 }
 
 have_stash () {
-	git-rev-parse --verify $ref_stash >/dev/null 2>&1
+	git rev-parse --verify $ref_stash >/dev/null 2>&1
 }
 
 list_stash () {
 	have_stash || return 0
-	git-log --pretty=oneline -g "$@" $ref_stash |
+	git log --pretty=oneline -g "$@" $ref_stash |
 	sed -n -e 's/^[.0-9a-f]* refs\///p'
 }
 
 show_stash () {
-	flags=$(git-rev-parse --no-revs --flags "$@")
+	flags=$(git rev-parse --no-revs --flags "$@")
 	if test -z "$flags"
 	then
 		flags=--stat
 	fi
-	s=$(git-rev-parse --revs-only --no-flags --default $ref_stash "$@")
+	s=$(git rev-parse --revs-only --no-flags --default $ref_stash "$@")
 
-	w_commit=$(git-rev-parse --verify "$s") &&
-	b_commit=$(git-rev-parse --verify "$s^") &&
-	git-diff $flags $b_commit $w_commit
+	w_commit=$(git rev-parse --verify "$s") &&
+	b_commit=$(git rev-parse --verify "$s^") &&
+	git diff $flags $b_commit $w_commit
 }
 
 apply_stash () {
-	git-diff-files --quiet ||
+	git diff-files --quiet ||
 		die 'Cannot restore on top of a dirty state'
 
 	# current index state
-	c_tree=$(git-write-tree) ||
+	c_tree=$(git write-tree) ||
 		die 'Cannot apply a stash in the middle of a merge'
 
-	s=$(git-rev-parse --revs-only --no-flags --default $ref_stash "$@") &&
-	w_tree=$(git-rev-parse --verify "$s:") &&
-	b_tree=$(git-rev-parse --verify "$s^:") ||
+	s=$(git rev-parse --revs-only --no-flags --default $ref_stash "$@") &&
+	w_tree=$(git rev-parse --verify "$s:") &&
+	b_tree=$(git rev-parse --verify "$s^:") ||
 		die "$*: no valid stashed state found"
 
 	eval "
@@ -123,9 +123,9 @@ apply_stash () {
 	then
 		# No conflict
 		a="$TMP-added" &&
-		git-diff --cached --name-only --diff-filter=A $c_tree >"$a" &&
-		git-read-tree --reset $c_tree &&
-		git-update-index --add --stdin <"$a" ||
+		git diff --cached --name-only --diff-filter=A $c_tree >"$a" &&
+		git read-tree --reset $c_tree &&
+		git update-index --add --stdin <"$a" ||
 			die "Cannot unstage modified files"
 		git-status
 		rm -f "$a"
@@ -46,7 +46,7 @@ get_repo_base() {
 #
 module_name()
 {
-       name=$(GIT_CONFIG=.gitmodules git-config --get-regexp '^submodule\..*\.path$' "$1" |
+       name=$(GIT_CONFIG=.gitmodules git config --get-regexp '^submodule\..*\.path$' "$1" |
        sed -nre 's/^submodule\.(.+)\.path .+$/\1/p')
        test -z "$name" &&
        die "No submodule mapping found in .gitmodules for path '$path'"
@@ -116,7 +116,7 @@ module_add()
 	test -e "$path" &&
 	die "'$path' already exists"
 
-	git-ls-files --error-unmatch "$path" > /dev/null 2>&1 &&
+	git ls-files --error-unmatch "$path" > /dev/null 2>&1 &&
 	die "'$path' already exists in the index"
 
 	module_clone "$path" "$repo" || exit
@@ -143,14 +143,14 @@ modules_init()
 	do
 		# Skip already registered paths
 		name=$(module_name "$path") || exit
-		url=$(git-config submodule."$name".url)
+		url=$(git config submodule."$name".url)
 		test -z "$url" || continue
 
-		url=$(GIT_CONFIG=.gitmodules git-config submodule."$name".url)
+		url=$(GIT_CONFIG=.gitmodules git config submodule."$name".url)
 		test -z "$url" &&
 		die "No url found for submodule path '$path' in .gitmodules"
 
-		git-config submodule."$name".url "$url" ||
+		git config submodule."$name".url "$url" ||
 		die "Failed to register url for submodule path '$path'"
 
 		say "Submodule '$name' ($url) registered for path '$path'"
@@ -168,7 +168,7 @@ modules_update()
 	while read mode sha1 stage path
 	do
 		name=$(module_name "$path") || exit
-		url=$(git-config submodule."$name".url)
+		url=$(git config submodule."$name".url)
 		if test -z "$url"
 		then
 			# Only mention uninitialized submodules when its
@@ -184,7 +184,7 @@ modules_update()
 			subsha1=
 		else
 			subsha1=$(unset GIT_DIR && cd "$path" &&
-				git-rev-parse --verify HEAD) ||
+				git rev-parse --verify HEAD) ||
 			die "Unable to find current revision in submodule path '$path'"
 		fi
 
@@ -203,9 +203,9 @@ set_name_rev () {
 	revname=$( (
 		unset GIT_DIR &&
 		cd "$1" && {
-			git-describe "$2" 2>/dev/null ||
-			git-describe --tags "$2" 2>/dev/null ||
-			git-describe --contains --tags "$2"
+			git describe "$2" 2>/dev/null ||
+			git describe --tags "$2" 2>/dev/null ||
+			git describe --contains --tags "$2"
 		}
 	) )
 	test -z "$revname" || revname=" ($revname)"
@@ -227,21 +227,21 @@ modules_list()
 	while read mode sha1 stage path
 	do
 		name=$(module_name "$path") || exit
-		url=$(git-config submodule."$name".url)
+		url=$(git config submodule."$name".url)
 		if test -z "url" || ! test -d "$path"/.git
 		then
 			say "-$sha1 $path"
 			continue;
 		fi
-		revname=$(unset GIT_DIR && cd "$path" && git-describe --tags $sha1)
+		revname=$(unset GIT_DIR && cd "$path" && git describe --tags $sha1)
 		set_name_rev "$path" $"sha1"
 		if git diff-files --quiet -- "$path"
 		then
 			say " $sha1 $path$revname"
 		else
 			if test -z "$cached"
 			then
-				sha1=$(unset GIT_DIR && cd "$path" && git-rev-parse --verify HEAD)
+				sha1=$(unset GIT_DIR && cd "$path" && git rev-parse --verify HEAD)
 				set_name_rev "$path" $"sha1"
 			fi
 			say "+$sha1 $path$revname"
@@ -118,12 +118,12 @@ do
 	had_error=0
 	for tag
 	do
-		cur=$(git-show-ref --verify --hash -- "refs/tags/$tag") || {
+		cur=$(git show-ref --verify --hash -- "refs/tags/$tag") || {
 			echo >&2 "Seriously, what tag are you talking about?"
 			had_error=1
 			continue
 		}
-		git-update-ref -m 'tag: delete' -d "refs/tags/$tag" "$cur" || {
+		git update-ref -m 'tag: delete' -d "refs/tags/$tag" "$cur" || {
 			had_error=1
 			continue
 		}
@@ -134,7 +134,7 @@ do
     -v)
 	shift
 	tag_name="$1"
-	tag=$(git-show-ref --verify --hash -- "refs/tags/$tag_name") ||
+	tag=$(git show-ref --verify --hash -- "refs/tags/$tag_name") ||
 		die "Seriously, what tag are you talking about?"
 	git-verify-tag -v "$tag"
 	exit $?
@@ -153,21 +153,21 @@ done
 name="$1"
 [ "$name" ] || usage
 prev=0000000000000000000000000000000000000000
-if git-show-ref --verify --quiet -- "refs/tags/$name"
+if git show-ref --verify --quiet -- "refs/tags/$name"
 then
     test -n "$force" || die "tag '$name' already exists"
     prev=`git rev-parse "refs/tags/$name"`
 fi
 shift
-git-check-ref-format "tags/$name" ||
+git check-ref-format "tags/$name" ||
 	die "we do not like '$name' as a tag name."
 
-object=$(git-rev-parse --verify --default HEAD "$@") || exit 1
-type=$(git-cat-file -t $object) || exit 1
+object=$(git rev-parse --verify --default HEAD "$@") || exit 1
+type=$(git cat-file -t $object) || exit 1
 tagger=$(git-var GIT_COMMITTER_IDENT) || exit 1
 
 test -n "$username" ||
-	username=$(git-repo-config user.signingkey) ||
+	username=$(git repo-config user.signingkey) ||
 	username=$(expr "z$tagger" : 'z\(.*>\)')
 
 trap 'rm -f "$GIT_DIR"/TAG_TMP* "$GIT_DIR"/TAG_FINALMSG "$GIT_DIR"/TAG_EDITMSG' 0
@@ -183,7 +183,7 @@ if [ "$annotate" ]; then
     fi
 
     grep -v '^#' <"$GIT_DIR"/TAG_EDITMSG |
-    git-stripspace >"$GIT_DIR"/TAG_FINALMSG
+    git stripspace >"$GIT_DIR"/TAG_FINALMSG
 
     [ -s "$GIT_DIR"/TAG_FINALMSG -o -n "$message_given" ] || {
 	echo >&2 "No tag message?"
@@ -21,22 +21,22 @@ then
 	usage
 fi
 
-type="$(git-cat-file -t "$1" 2>/dev/null)" ||
+type="$(git cat-file -t "$1" 2>/dev/null)" ||
 	die "$1: no such object."
 
 test "$type" = tag ||
 	die "$1: cannot verify a non-tag object of type $type."
 
 case "$verbose" in
 t)
-	git-cat-file -p "$1" |
+	git cat-file -p "$1" |
 	sed -n -e '/^-----BEGIN PGP SIGNATURE-----/q' -e p
 	;;
 esac
 
 trap 'rm -f "$GIT_DIR/.tmp-vtag"' 0
 
-git-cat-file tag "$1" >"$GIT_DIR/.tmp-vtag" || exit 1
+git cat-file tag "$1" >"$GIT_DIR/.tmp-vtag" || exit 1
 sed -n -e '
 	/^-----BEGIN PGP SIGNATURE-----$/q
 	p
@@ -10,14 +10,14 @@ do
 	echo This is Z/$p from the original tree. >Z/$p
 	test_expect_success \
 	    "adding test file $p and Z/$p" \
-	    'git-update-index --add $p &&
-	    git-update-index --add Z/$p'
+	    'git update-index --add $p &&
+	    git update-index --add Z/$p'
     done
 done
 echo This is SS from the original tree. >SS
 test_expect_success \
     'adding test file SS' \
-    'git-update-index --add SS'
+    'git update-index --add SS'
 cat >TT <<\EOF
 This is a trivial merge sample text.
 Branch A is expected to upcase this word, here.
@@ -32,10 +32,10 @@ This concludes the trivial merge sample file.
 EOF
 test_expect_success \
     'adding test file TT' \
-    'git-update-index --add TT'
+    'git update-index --add TT'
 test_expect_success \
     'prepare initial tree' \
-    'tree_O=$(git-write-tree)'
+    'tree_O=$(git write-tree)'
 
 ################################################################
 # Branch A and B makes the changes according to the above matrix.
@@ -47,46 +47,46 @@ to_remove=$(echo D? Z/D?)
 rm -f $to_remove
 test_expect_success \
     'change in branch A (removal)' \
-    'git-update-index --remove $to_remove'
+    'git update-index --remove $to_remove'
 
 for p in M? Z/M?
 do
     echo This is modified $p in the branch A. >$p
     test_expect_success \
 	'change in branch A (modification)' \
-        "git-update-index $p"
+        "git update-index $p"
 done
 
 for p in AN AA Z/AN Z/AA
 do
     echo This is added $p in the branch A. >$p
     test_expect_success \
 	'change in branch A (addition)' \
-	"git-update-index --add $p"
+	"git update-index --add $p"
 done
 
 echo This is SS from the modified tree. >SS
 echo This is LL from the modified tree. >LL
 test_expect_success \
     'change in branch A (addition)' \
-    'git-update-index --add LL &&
-     git-update-index SS'
+    'git update-index --add LL &&
+     git update-index SS'
 mv TT TT-
 sed -e '/Branch A/s/word/WORD/g' <TT- >TT
 rm -f TT-
 test_expect_success \
     'change in branch A (edit)' \
-    'git-update-index TT'
+    'git update-index TT'
 
 mkdir DF
 echo Branch A makes a file at DF/DF, creating a directory DF. >DF/DF
 test_expect_success \
     'change in branch A (change file to directory)' \
-    'git-update-index --add DF/DF'
+    'git update-index --add DF/DF'
 
 test_expect_success \
     'recording branch A tree' \
-    'tree_A=$(git-write-tree)'
+    'tree_A=$(git write-tree)'
 
 ################################################################
 # Branch B
@@ -96,63 +96,63 @@ rm -rf [NDMASLT][NDMASLT] Z DF
 mkdir Z
 test_expect_success \
     'reading original tree and checking out' \
-    'git-read-tree $tree_O &&
-     git-checkout-index -a'
+    'git read-tree $tree_O &&
+     git checkout-index -a'
 
 to_remove=$(echo ?D Z/?D)
 rm -f $to_remove
 test_expect_success \
     'change in branch B (removal)' \
-    "git-update-index --remove $to_remove"
+    "git update-index --remove $to_remove"
 
 for p in ?M Z/?M
 do
     echo This is modified $p in the branch B. >$p
     test_expect_success \
 	'change in branch B (modification)' \
-	"git-update-index $p"
+	"git update-index $p"
 done
 
 for p in NA AA Z/NA Z/AA
 do
     echo This is added $p in the branch B. >$p
     test_expect_success \
 	'change in branch B (addition)' \
-	"git-update-index --add $p"
+	"git update-index --add $p"
 done
 echo This is SS from the modified tree. >SS
 echo This is LL from the modified tree. >LL
 test_expect_success \
     'change in branch B (addition and modification)' \
-    'git-update-index --add LL &&
-     git-update-index SS'
+    'git update-index --add LL &&
+     git update-index SS'
 mv TT TT-
 sed -e '/Branch B/s/word/WORD/g' <TT- >TT
 rm -f TT-
 test_expect_success \
     'change in branch B (modification)' \
-    'git-update-index TT'
+    'git update-index TT'
 
 echo Branch B makes a file at DF. >DF
 test_expect_success \
     'change in branch B (addition of a file to conflict with directory)' \
-    'git-update-index --add DF'
+    'git update-index --add DF'
 
 test_expect_success \
     'recording branch B tree' \
-    'tree_B=$(git-write-tree)'
+    'tree_B=$(git write-tree)'
 
 test_expect_success \
     'keep contents of 3 trees for easy access' \
     'rm -f .git/index &&
-     git-read-tree $tree_O &&
+     git read-tree $tree_O &&
      mkdir .orig-O &&
-     git-checkout-index --prefix=.orig-O/ -f -q -a &&
+     git checkout-index --prefix=.orig-O/ -f -q -a &&
      rm -f .git/index &&
-     git-read-tree $tree_A &&
+     git read-tree $tree_A &&
      mkdir .orig-A &&
-     git-checkout-index --prefix=.orig-A/ -f -q -a &&
+     git checkout-index --prefix=.orig-A/ -f -q -a &&
      rm -f .git/index &&
-     git-read-tree $tree_B &&
+     git read-tree $tree_B &&
      mkdir .orig-B &&
-     git-checkout-index --prefix=.orig-B/ -f -q -a'
+     git checkout-index --prefix=.orig-B/ -f -q -a'
@@ -31,12 +31,12 @@ fi
 . ./test-lib.sh
 
 ################################################################
-# git-init has been done in an empty repository.
+# git init has been done in an empty repository.
 # make sure it is empty.
 
 find .git/objects -type f -print >should-be-empty
 test_expect_success \
-    '.git/objects should be empty after git-init in an empty repo.' \
+    '.git/objects should be empty after git init in an empty repo.' \
     'cmp -s /dev/null should-be-empty'
 
 # also it should have 2 subdirectories; no fan-out anymore, pack, and info.
@@ -51,17 +51,17 @@ test_expect_success \
 
 # updating a new file without --add should fail.
 test_expect_failure \
-    'git-update-index without --add should fail adding.' \
-    'git-update-index should-be-empty'
+    'git update-index without --add should fail adding.' \
+    'git update-index should-be-empty'
 
 # and with --add it should succeed, even if it is empty (it used to fail).
 test_expect_success \
-    'git-update-index with --add should succeed.' \
-    'git-update-index --add should-be-empty'
+    'git update-index with --add should succeed.' \
+    'git update-index --add should-be-empty'
 
 test_expect_success \
-    'writing tree out with git-write-tree' \
-    'tree=$(git-write-tree)'
+    'writing tree out with git write-tree' \
+    'tree=$(git write-tree)'
 
 # we know the shape and contents of the tree and know the object ID for it.
 test_expect_success \
@@ -71,17 +71,17 @@ test_expect_success \
 # Removing paths.
 rm -f should-be-empty full-of-directories
 test_expect_failure \
-    'git-update-index without --remove should fail removing.' \
-    'git-update-index should-be-empty'
+    'git update-index without --remove should fail removing.' \
+    'git update-index should-be-empty'
 
 test_expect_success \
-    'git-update-index with --remove should be able to remove.' \
-    'git-update-index --remove should-be-empty'
+    'git update-index with --remove should be able to remove.' \
+    'git update-index --remove should-be-empty'
 
 # Empty tree can be written with recent write-tree.
 test_expect_success \
-    'git-write-tree should be able to write an empty tree.' \
-    'tree=$(git-write-tree)'
+    'git write-tree should be able to write an empty tree.' \
+    'tree=$(git write-tree)'
 
 test_expect_success \
     'validate object ID of a known tree.' \
@@ -95,13 +95,13 @@ do
     ln -s "hello $p" ${p}sym
 done
 test_expect_success \
-    'adding various types of objects with git-update-index --add.' \
-    'find path* ! -type d -print | xargs git-update-index --add'
+    'adding various types of objects with git update-index --add.' \
+    'find path* ! -type d -print | xargs git update-index --add'
 
 # Show them and see that matches what we expect.
 test_expect_success \
-    'showing stage with git-ls-files --stage' \
-    'git-ls-files --stage >current'
+    'showing stage with git ls-files --stage' \
+    'git ls-files --stage >current'
 
 cat >expected <<\EOF
 100644 f87290f8eb2cbbea7857214459a0739927eab154 0	path0
@@ -114,34 +114,34 @@ cat >expected <<\EOF
 120000 6649a1ebe9e9f1c553b66f5a6e74136a07ccc57c 0	path3/subp3/file3sym
 EOF
 test_expect_success \
-    'validate git-ls-files output for a known tree.' \
+    'validate git ls-files output for a known tree.' \
     'diff current expected'
 
 test_expect_success \
-    'writing tree out with git-write-tree.' \
-    'tree=$(git-write-tree)'
+    'writing tree out with git write-tree.' \
+    'tree=$(git write-tree)'
 test_expect_success \
     'validate object ID for a known tree.' \
     'test "$tree" = 087704a96baf1c2d1c869a8b084481e121c88b5b'
 
 test_expect_success \
-    'showing tree with git-ls-tree' \
-    'git-ls-tree $tree >current'
+    'showing tree with git ls-tree' \
+    'git ls-tree $tree >current'
 cat >expected <<\EOF
 100644 blob f87290f8eb2cbbea7857214459a0739927eab154	path0
 120000 blob 15a98433ae33114b085f3eb3bb03b832b3180a01	path0sym
 040000 tree 58a09c23e2ca152193f2786e06986b7b6712bdbe	path2
 040000 tree 21ae8269cacbe57ae09138dcc3a2887f904d02b3	path3
 EOF
 test_expect_success \
-    'git-ls-tree output for a known tree.' \
+    'git ls-tree output for a known tree.' \
     'diff current expected'
 
 # This changed in ls-tree pathspec change -- recursive does
 # not show tree nodes anymore.
 test_expect_success \
-    'showing tree with git-ls-tree -r' \
-    'git-ls-tree -r $tree >current'
+    'showing tree with git ls-tree -r' \
+    'git ls-tree -r $tree >current'
 cat >expected <<\EOF
 100644 blob f87290f8eb2cbbea7857214459a0739927eab154	path0
 120000 blob 15a98433ae33114b085f3eb3bb03b832b3180a01	path0sym
@@ -153,13 +153,13 @@ cat >expected <<\EOF
 120000 blob 6649a1ebe9e9f1c553b66f5a6e74136a07ccc57c	path3/subp3/file3sym
 EOF
 test_expect_success \
-    'git-ls-tree -r output for a known tree.' \
+    'git ls-tree -r output for a known tree.' \
     'diff current expected'
 
 # But with -r -t we can have both.
 test_expect_success \
-    'showing tree with git-ls-tree -r -t' \
-    'git-ls-tree -r -t $tree >current'
+    'showing tree with git ls-tree -r -t' \
+    'git ls-tree -r -t $tree >current'
 cat >expected <<\EOF
 100644 blob f87290f8eb2cbbea7857214459a0739927eab154	path0
 120000 blob 15a98433ae33114b085f3eb3bb03b832b3180a01	path0sym
@@ -174,19 +174,19 @@ cat >expected <<\EOF
 120000 blob 6649a1ebe9e9f1c553b66f5a6e74136a07ccc57c	path3/subp3/file3sym
 EOF
 test_expect_success \
-    'git-ls-tree -r output for a known tree.' \
+    'git ls-tree -r output for a known tree.' \
     'diff current expected'
 
 test_expect_success \
-    'writing partial tree out with git-write-tree --prefix.' \
-    'ptree=$(git-write-tree --prefix=path3)'
+    'writing partial tree out with git write-tree --prefix.' \
+    'ptree=$(git write-tree --prefix=path3)'
 test_expect_success \
     'validate object ID for a known tree.' \
     'test "$ptree" = 21ae8269cacbe57ae09138dcc3a2887f904d02b3'
 
 test_expect_success \
-    'writing partial tree out with git-write-tree --prefix.' \
-    'ptree=$(git-write-tree --prefix=path3/subp3)'
+    'writing partial tree out with git write-tree --prefix.' \
+    'ptree=$(git write-tree --prefix=path3/subp3)'
 test_expect_success \
     'validate object ID for a known tree.' \
     'test "$ptree" = 3c5e5399f3a333eddecce7a9b9465b63f65f51e2'
@@ -202,24 +202,24 @@ EOF
 rm .git/index
 test_expect_success \
     'put invalid objects into the index.' \
-    'git-update-index --index-info < badobjects'
+    'git update-index --index-info < badobjects'
 
 test_expect_failure \
     'writing this tree without --missing-ok.' \
-    'git-write-tree'
+    'git write-tree'
 
 test_expect_success \
     'writing this tree with --missing-ok.' \
-    'git-write-tree --missing-ok'
+    'git write-tree --missing-ok'
 
 
 ################################################################
 rm .git/index
 test_expect_success \
-    'git-read-tree followed by write-tree should be idempotent.' \
-    'git-read-tree $tree &&
+    'git read-tree followed by write-tree should be idempotent.' \
+    'git read-tree $tree &&
      test -f .git/index &&
-     newtree=$(git-write-tree) &&
+     newtree=$(git write-tree) &&
      test "$newtree" = "$tree"'
 
 cat >expected <<\EOF
@@ -233,36 +233,36 @@ cat >expected <<\EOF
 :120000 120000 6649a1ebe9e9f1c553b66f5a6e74136a07ccc57c 0000000000000000000000000000000000000000 M	path3/subp3/file3sym
 EOF
 test_expect_success \
-    'validate git-diff-files output for a know cache/work tree state.' \
-    'git-diff-files >current && diff >/dev/null -b current expected'
+    'validate git diff-files output for a know cache/work tree state.' \
+    'git diff-files >current && diff >/dev/null -b current expected'
 
 test_expect_success \
-    'git-update-index --refresh should succeed.' \
-    'git-update-index --refresh'
+    'git update-index --refresh should succeed.' \
+    'git update-index --refresh'
 
 test_expect_success \
-    'no diff after checkout and git-update-index --refresh.' \
-    'git-diff-files >current && cmp -s current /dev/null'
+    'no diff after checkout and git update-index --refresh.' \
+    'git diff-files >current && cmp -s current /dev/null'
 
 ################################################################
 P=087704a96baf1c2d1c869a8b084481e121c88b5b
 test_expect_success \
-    'git-commit-tree records the correct tree in a commit.' \
-    'commit0=$(echo NO | git-commit-tree $P) &&
+    'git commit-tree records the correct tree in a commit.' \
+    'commit0=$(echo NO | git commit-tree $P) &&
      tree=$(git show --pretty=raw $commit0 |
 	 sed -n -e "s/^tree //p" -e "/^author /q") &&
      test "z$tree" = "z$P"'
 
 test_expect_success \
-    'git-commit-tree records the correct parent in a commit.' \
-    'commit1=$(echo NO | git-commit-tree $P -p $commit0) &&
+    'git commit-tree records the correct parent in a commit.' \
+    'commit1=$(echo NO | git commit-tree $P -p $commit0) &&
      parent=$(git show --pretty=raw $commit1 |
 	 sed -n -e "s/^parent //p" -e "/^author /q") &&
      test "z$commit0" = "z$parent"'
 
 test_expect_success \
-    'git-commit-tree omits duplicated parent in a commit.' \
-    'commit2=$(echo NO | git-commit-tree $P -p $commit0 -p $commit0) &&
+    'git commit-tree omits duplicated parent in a commit.' \
+    'commit2=$(echo NO | git commit-tree $P -p $commit0 -p $commit0) &&
      parent=$(git show --pretty=raw $commit2 |
 	 sed -n -e "s/^parent //p" -e "/^author /q" |
 	 sort -u) &&
@@ -3,7 +3,7 @@
 # Copyright (c) 2007 Carlos Rica
 #
 
-test_description='git-stripspace'
+test_description='git stripspace'
 
 . ./test-lib.sh
 
@@ -15,292 +15,292 @@ ttt="$t40$t40$t40$t40$t40$t40$t40$t40$t40$t40" # 400
 test_expect_success \
     'long lines without spaces should be unchanged' '
     echo "$ttt" >expect &&
-    git-stripspace <expect >actual &&
+    git stripspace <expect >actual &&
     git diff expect actual &&
 
     echo "$ttt$ttt" >expect &&
-    git-stripspace <expect >actual &&
+    git stripspace <expect >actual &&
     git diff expect actual &&
 
     echo "$ttt$ttt$ttt" >expect &&
-    git-stripspace <expect >actual &&
+    git stripspace <expect >actual &&
     git diff expect actual &&
 
     echo "$ttt$ttt$ttt$ttt" >expect &&
-    git-stripspace <expect >actual &&
+    git stripspace <expect >actual &&
     git diff expect actual
 '
 
 test_expect_success \
     'lines with spaces at the beginning should be unchanged' '
     echo "$sss$ttt" >expect &&
-    git-stripspace <expect >actual &&
+    git stripspace <expect >actual &&
     git diff expect actual &&
 
     echo "$sss$sss$ttt" >expect &&
-    git-stripspace <expect >actual &&
+    git stripspace <expect >actual &&
     git diff expect actual &&
 
     echo "$sss$sss$sss$ttt" >expect &&
-    git-stripspace <expect >actual &&
+    git stripspace <expect >actual &&
     git diff expect actual
 '
 
 test_expect_success \
     'lines with intermediate spaces should be unchanged' '
     echo "$ttt$sss$ttt" >expect &&
-    git-stripspace <expect >actual &&
+    git stripspace <expect >actual &&
     git diff expect actual &&
 
     echo "$ttt$sss$sss$ttt" >expect &&
-    git-stripspace <expect >actual &&
+    git stripspace <expect >actual &&
     git diff expect actual
 '
 
 test_expect_success \
     'consecutive blank lines should be unified' '
     printf "$ttt\n\n$ttt\n" > expect &&
-    printf "$ttt\n\n\n\n\n$ttt\n" | git-stripspace >actual &&
+    printf "$ttt\n\n\n\n\n$ttt\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt$ttt\n\n$ttt\n" > expect &&
-    printf "$ttt$ttt\n\n\n\n\n$ttt\n" | git-stripspace >actual &&
+    printf "$ttt$ttt\n\n\n\n\n$ttt\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt$ttt$ttt\n\n$ttt\n" > expect &&
-    printf "$ttt$ttt$ttt\n\n\n\n\n$ttt\n" | git-stripspace >actual &&
+    printf "$ttt$ttt$ttt\n\n\n\n\n$ttt\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt\n\n$ttt\n" > expect &&
-    printf "$ttt\n\n\n\n\n$ttt\n" | git-stripspace >actual &&
+    printf "$ttt\n\n\n\n\n$ttt\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt\n\n$ttt$ttt\n" > expect &&
-    printf "$ttt\n\n\n\n\n$ttt$ttt\n" | git-stripspace >actual &&
+    printf "$ttt\n\n\n\n\n$ttt$ttt\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt\n\n$ttt$ttt$ttt\n" > expect &&
-    printf "$ttt\n\n\n\n\n$ttt$ttt$ttt\n" | git-stripspace >actual &&
+    printf "$ttt\n\n\n\n\n$ttt$ttt$ttt\n" | git stripspace >actual &&
     git diff expect actual
 '
 
 test_expect_success \
     'consecutive blank lines at the beginning should be removed' '
     printf "" > expect &&
-    printf "\n" | git-stripspace >actual &&
+    printf "\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "" > expect &&
-    printf "\n\n\n" | git-stripspace >actual &&
+    printf "\n\n\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "" > expect &&
-    printf "$sss\n$sss\n$sss\n" | git-stripspace >actual &&
+    printf "$sss\n$sss\n$sss\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "" > expect &&
-    printf "$sss$sss\n$sss\n\n" | git-stripspace >actual &&
+    printf "$sss$sss\n$sss\n\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "" > expect &&
-    printf "\n$sss\n$sss$sss\n" | git-stripspace >actual &&
+    printf "\n$sss\n$sss$sss\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "" > expect &&
-    printf "$sss$sss$sss$sss\n\n\n" | git-stripspace >actual &&
+    printf "$sss$sss$sss$sss\n\n\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "" > expect &&
-    printf "\n$sss$sss$sss$sss\n\n" | git-stripspace >actual &&
+    printf "\n$sss$sss$sss$sss\n\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "" > expect &&
-    printf "\n\n$sss$sss$sss$sss\n" | git-stripspace >actual &&
+    printf "\n\n$sss$sss$sss$sss\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt\n" > expect &&
-    printf "\n$ttt\n" | git-stripspace >actual &&
+    printf "\n$ttt\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt\n" > expect &&
-    printf "\n\n\n$ttt\n" | git-stripspace >actual &&
+    printf "\n\n\n$ttt\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt$ttt\n" > expect &&
-    printf "\n\n\n$ttt$ttt\n" | git-stripspace >actual &&
+    printf "\n\n\n$ttt$ttt\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt$ttt$ttt\n" > expect &&
-    printf "\n\n\n$ttt$ttt$ttt\n" | git-stripspace >actual &&
+    printf "\n\n\n$ttt$ttt$ttt\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt$ttt$ttt$ttt\n" > expect &&
-    printf "\n\n\n$ttt$ttt$ttt$ttt\n" | git-stripspace >actual &&
+    printf "\n\n\n$ttt$ttt$ttt$ttt\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt\n" > expect &&
-    printf "$sss\n$sss\n$sss\n$ttt\n" | git-stripspace >actual &&
+    printf "$sss\n$sss\n$sss\n$ttt\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt\n" > expect &&
-    printf "\n$sss\n$sss$sss\n$ttt\n" | git-stripspace >actual &&
+    printf "\n$sss\n$sss$sss\n$ttt\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt\n" > expect &&
-    printf "$sss$sss\n$sss\n\n$ttt\n" | git-stripspace >actual &&
+    printf "$sss$sss\n$sss\n\n$ttt\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt\n" > expect &&
-    printf "$sss$sss$sss\n\n\n$ttt\n" | git-stripspace >actual &&
+    printf "$sss$sss$sss\n\n\n$ttt\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt\n" > expect &&
-    printf "\n$sss$sss$sss\n\n$ttt\n" | git-stripspace >actual &&
+    printf "\n$sss$sss$sss\n\n$ttt\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt\n" > expect &&
-    printf "\n\n$sss$sss$sss\n$ttt\n" | git-stripspace >actual &&
+    printf "\n\n$sss$sss$sss\n$ttt\n" | git stripspace >actual &&
     git diff expect actual
 '
 
 test_expect_success \
     'consecutive blank lines at the end should be removed' '
     printf "$ttt\n" > expect &&
-    printf "$ttt\n\n" | git-stripspace >actual &&
+    printf "$ttt\n\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt\n" > expect &&
-    printf "$ttt\n\n\n\n" | git-stripspace >actual &&
+    printf "$ttt\n\n\n\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt$ttt\n" > expect &&
-    printf "$ttt$ttt\n\n\n\n" | git-stripspace >actual &&
+    printf "$ttt$ttt\n\n\n\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt$ttt$ttt\n" > expect &&
-    printf "$ttt$ttt$ttt\n\n\n\n" | git-stripspace >actual &&
+    printf "$ttt$ttt$ttt\n\n\n\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt$ttt$ttt$ttt\n" > expect &&
-    printf "$ttt$ttt$ttt$ttt\n\n\n\n" | git-stripspace >actual &&
+    printf "$ttt$ttt$ttt$ttt\n\n\n\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt\n" > expect &&
-    printf "$ttt\n$sss\n$sss\n$sss\n" | git-stripspace >actual &&
+    printf "$ttt\n$sss\n$sss\n$sss\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt\n" > expect &&
-    printf "$ttt\n\n$sss\n$sss$sss\n" | git-stripspace >actual &&
+    printf "$ttt\n\n$sss\n$sss$sss\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt\n" > expect &&
-    printf "$ttt\n$sss$sss\n$sss\n\n" | git-stripspace >actual &&
+    printf "$ttt\n$sss$sss\n$sss\n\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt\n" > expect &&
-    printf "$ttt\n$sss$sss$sss\n\n\n" | git-stripspace >actual &&
+    printf "$ttt\n$sss$sss$sss\n\n\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt\n" > expect &&
-    printf "$ttt\n\n$sss$sss$sss\n\n" | git-stripspace >actual &&
+    printf "$ttt\n\n$sss$sss$sss\n\n" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt\n" > expect &&
-    printf "$ttt\n\n\n$sss$sss$sss\n" | git-stripspace >actual &&
+    printf "$ttt\n\n\n$sss$sss$sss\n" | git stripspace >actual &&
     git diff expect actual
 '
 
 test_expect_success \
     'text without newline at end should end with newline' '
-    test `printf "$ttt" | git-stripspace | wc -l` -gt 0 &&
-    test `printf "$ttt$ttt" | git-stripspace | wc -l` -gt 0 &&
-    test `printf "$ttt$ttt$ttt" | git-stripspace | wc -l` -gt 0 &&
-    test `printf "$ttt$ttt$ttt$ttt" | git-stripspace | wc -l` -gt 0
+    test `printf "$ttt" | git stripspace | wc -l` -gt 0 &&
+    test `printf "$ttt$ttt" | git stripspace | wc -l` -gt 0 &&
+    test `printf "$ttt$ttt$ttt" | git stripspace | wc -l` -gt 0 &&
+    test `printf "$ttt$ttt$ttt$ttt" | git stripspace | wc -l` -gt 0
 '
 
 # text plus spaces at the end:
 
 test_expect_success \
     'text plus spaces without newline at end should end with newline' '
-    test `printf "$ttt$sss" | git-stripspace | wc -l` -gt 0 &&
-    test `printf "$ttt$ttt$sss" | git-stripspace | wc -l` -gt 0 &&
-    test `printf "$ttt$ttt$ttt$sss" | git-stripspace | wc -l` -gt 0
-    test `printf "$ttt$sss$sss" | git-stripspace | wc -l` -gt 0 &&
-    test `printf "$ttt$ttt$sss$sss" | git-stripspace | wc -l` -gt 0 &&
-    test `printf "$ttt$sss$sss$sss" | git-stripspace | wc -l` -gt 0
+    test `printf "$ttt$sss" | git stripspace | wc -l` -gt 0 &&
+    test `printf "$ttt$ttt$sss" | git stripspace | wc -l` -gt 0 &&
+    test `printf "$ttt$ttt$ttt$sss" | git stripspace | wc -l` -gt 0
+    test `printf "$ttt$sss$sss" | git stripspace | wc -l` -gt 0 &&
+    test `printf "$ttt$ttt$sss$sss" | git stripspace | wc -l` -gt 0 &&
+    test `printf "$ttt$sss$sss$sss" | git stripspace | wc -l` -gt 0
 '
 
 test_expect_failure \
     'text plus spaces without newline at end should not show spaces' '
-    printf "$ttt$sss" | git-stripspace | grep -q "  " ||
-    printf "$ttt$ttt$sss" | git-stripspace | grep -q "  " ||
-    printf "$ttt$ttt$ttt$sss" | git-stripspace | grep -q "  " ||
-    printf "$ttt$sss$sss" | git-stripspace | grep -q "  " ||
-    printf "$ttt$ttt$sss$sss" | git-stripspace | grep -q "  " ||
-    printf "$ttt$sss$sss$sss" | git-stripspace | grep -q "  "
+    printf "$ttt$sss" | git stripspace | grep -q "  " ||
+    printf "$ttt$ttt$sss" | git stripspace | grep -q "  " ||
+    printf "$ttt$ttt$ttt$sss" | git stripspace | grep -q "  " ||
+    printf "$ttt$sss$sss" | git stripspace | grep -q "  " ||
+    printf "$ttt$ttt$sss$sss" | git stripspace | grep -q "  " ||
+    printf "$ttt$sss$sss$sss" | git stripspace | grep -q "  "
 '
 
 test_expect_success \
     'text plus spaces without newline should show the correct lines' '
     printf "$ttt\n" >expect &&
-    printf "$ttt$sss" | git-stripspace >actual &&
+    printf "$ttt$sss" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt\n" >expect &&
-    printf "$ttt$sss$sss" | git-stripspace >actual &&
+    printf "$ttt$sss$sss" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt\n" >expect &&
-    printf "$ttt$sss$sss$sss" | git-stripspace >actual &&
+    printf "$ttt$sss$sss$sss" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt$ttt\n" >expect &&
-    printf "$ttt$ttt$sss" | git-stripspace >actual &&
+    printf "$ttt$ttt$sss" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt$ttt\n" >expect &&
-    printf "$ttt$ttt$sss$sss" | git-stripspace >actual &&
+    printf "$ttt$ttt$sss$sss" | git stripspace >actual &&
     git diff expect actual &&
 
     printf "$ttt$ttt$ttt\n" >expect &&
-    printf "$ttt$ttt$ttt$sss" | git-stripspace >actual &&
+    printf "$ttt$ttt$ttt$sss" | git stripspace >actual &&
     git diff expect actual
 '
 
 test_expect_failure \
     'text plus spaces at end should not show spaces' '
-    echo "$ttt$sss" | git-stripspace | grep -q "  " ||
-    echo "$ttt$ttt$sss" | git-stripspace | grep -q "  " ||
-    echo "$ttt$ttt$ttt$sss" | git-stripspace | grep -q "  " ||
-    echo "$ttt$sss$sss" | git-stripspace | grep -q "  " ||
-    echo "$ttt$ttt$sss$sss" | git-stripspace | grep -q "  " ||
-    echo "$ttt$sss$sss$sss" | git-stripspace | grep -q "  "
+    echo "$ttt$sss" | git stripspace | grep -q "  " ||
+    echo "$ttt$ttt$sss" | git stripspace | grep -q "  " ||
+    echo "$ttt$ttt$ttt$sss" | git stripspace | grep -q "  " ||
+    echo "$ttt$sss$sss" | git stripspace | grep -q "  " ||
+    echo "$ttt$ttt$sss$sss" | git stripspace | grep -q "  " ||
+    echo "$ttt$sss$sss$sss" | git stripspace | grep -q "  "
 '
 
 test_expect_success \
     'text plus spaces at end should be cleaned and newline must remain' '
     echo "$ttt" >expect &&
-    echo "$ttt$sss" | git-stripspace >actual &&
+    echo "$ttt$sss" | git stripspace >actual &&
     git diff expect actual &&
 
     echo "$ttt" >expect &&
-    echo "$ttt$sss$sss" | git-stripspace >actual &&
+    echo "$ttt$sss$sss" | git stripspace >actual &&
     git diff expect actual &&
 
     echo "$ttt" >expect &&
-    echo "$ttt$sss$sss$sss" | git-stripspace >actual &&
+    echo "$ttt$sss$sss$sss" | git stripspace >actual &&
     git diff expect actual &&
 
     echo "$ttt$ttt" >expect &&
-    echo "$ttt$ttt$sss" | git-stripspace >actual &&
+    echo "$ttt$ttt$sss" | git stripspace >actual &&
     git diff expect actual &&
 
     echo "$ttt$ttt" >expect &&
-    echo "$ttt$ttt$sss$sss" | git-stripspace >actual &&
+    echo "$ttt$ttt$sss$sss" | git stripspace >actual &&
     git diff expect actual &&
 
     echo "$ttt$ttt$ttt" >expect &&
-    echo "$ttt$ttt$ttt$sss" | git-stripspace >actual &&
+    echo "$ttt$ttt$ttt$sss" | git stripspace >actual &&
     git diff expect actual
 '
 
@@ -310,45 +310,45 @@ test_expect_success \
     'spaces with newline at end should be replaced with empty string' '
     printf "" >expect &&
 
-    echo | git-stripspace >actual &&
+    echo | git stripspace >actual &&
     git diff expect actual &&
 
-    echo "$sss" | git-stripspace >actual &&
+    echo "$sss" | git stripspace >actual &&
     git diff expect actual &&
 
-    echo "$sss$sss" | git-stripspace >actual &&
+    echo "$sss$sss" | git stripspace >actual &&
     git diff expect actual &&
 
-    echo "$sss$sss$sss" | git-stripspace >actual &&
+    echo "$sss$sss$sss" | git stripspace >actual &&
     git diff expect actual &&
 
-    echo "$sss$sss$sss$sss" | git-stripspace >actual &&
+    echo "$sss$sss$sss$sss" | git stripspace >actual &&
     git diff expect actual
 '
 
 test_expect_failure \
     'spaces without newline at end should not show spaces' '
-    printf "" | git-stripspace | grep -q " " ||
-    printf "$sss" | git-stripspace | grep -q " " ||
-    printf "$sss$sss" | git-stripspace | grep -q " " ||
-    printf "$sss$sss$sss" | git-stripspace | grep -q " " ||
-    printf "$sss$sss$sss$sss" | git-stripspace | grep -q " "
+    printf "" | git stripspace | grep -q " " ||
+    printf "$sss" | git stripspace | grep -q " " ||
+    printf "$sss$sss" | git stripspace | grep -q " " ||
+    printf "$sss$sss$sss" | git stripspace | grep -q " " ||
+    printf "$sss$sss$sss$sss" | git stripspace | grep -q " "
 '
 
 test_expect_success \
     'spaces without newline at end should be replaced with empty string' '
     printf "" >expect &&
 
-    printf "" | git-stripspace >actual &&
+    printf "" | git stripspace >actual &&
     git diff expect actual
 
-    printf "$sss$sss" | git-stripspace >actual &&
+    printf "$sss$sss" | git stripspace >actual &&
     git diff expect actual
 
-    printf "$sss$sss$sss" | git-stripspace >actual &&
+    printf "$sss$sss$sss" | git stripspace >actual &&
     git diff expect actual
 
-    printf "$sss$sss$sss$sss" | git-stripspace >actual &&
+    printf "$sss$sss$sss$sss" | git stripspace >actual &&
     git diff expect actual
 '
 
@@ -130,28 +130,28 @@ _x40='[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f]'
 _x40="$_x40$_x40$_x40$_x40$_x40$_x40$_x40$_x40"
 
 check_result () {
-    git-ls-files --stage | sed -e 's/ '"$_x40"' / X /' >current &&
+    git ls-files --stage | sed -e 's/ '"$_x40"' / X /' >current &&
     git diff expected current
 }
 
 # This is done on an empty work directory, which is the normal
 # merge person behaviour.
 test_expect_success \
-    '3-way merge with git-read-tree -m, empty cache' \
+    '3-way merge with git read-tree -m, empty cache' \
     "rm -fr [NDMALTS][NDMALTSF] Z &&
      rm .git/index &&
-     git-read-tree -m $tree_O $tree_A $tree_B &&
+     git read-tree -m $tree_O $tree_A $tree_B &&
      check_result"
 
 # This starts out with the first head, which is the normal
 # patch submitter behaviour.
 test_expect_success \
-    '3-way merge with git-read-tree -m, match H' \
+    '3-way merge with git read-tree -m, match H' \
     "rm -fr [NDMALTS][NDMALTSF] Z &&
      rm .git/index &&
-     git-read-tree $tree_A &&
-     git-checkout-index -f -u -a &&
-     git-read-tree -m $tree_O $tree_A $tree_B &&
+     git read-tree $tree_A &&
+     git checkout-index -f -u -a &&
+     git read-tree -m $tree_O $tree_A $tree_B &&
      check_result"
 
 : <<\END_OF_CASE_TABLE
@@ -160,7 +160,7 @@ We have so far tested only empty index and clean-and-matching-A index
 case which are trivial.  Make sure index requirements are also
 checked.
 
-"git-read-tree -m O A B"
+"git read-tree -m O A B"
 
      O       A       B         result      index requirements
 -------------------------------------------------------------------
@@ -214,301 +214,301 @@ test_expect_failure \
     '1 - must not have an entry not in A.' \
     "rm -f .git/index XX &&
      echo XX >XX &&
-     git-update-index --add XX &&
-     git-read-tree -m $tree_O $tree_A $tree_B"
+     git update-index --add XX &&
+     git read-tree -m $tree_O $tree_A $tree_B"
 
 test_expect_success \
     '2 - must match B in !O && !A && B case.' \
     "rm -f .git/index NA &&
      cp .orig-B/NA NA &&
-     git-update-index --add NA &&
-     git-read-tree -m $tree_O $tree_A $tree_B"
+     git update-index --add NA &&
+     git read-tree -m $tree_O $tree_A $tree_B"
 
 test_expect_success \
     '2 - matching B alone is OK in !O && !A && B case.' \
     "rm -f .git/index NA &&
      cp .orig-B/NA NA &&
-     git-update-index --add NA &&
+     git update-index --add NA &&
      echo extra >>NA &&
-     git-read-tree -m $tree_O $tree_A $tree_B"
+     git read-tree -m $tree_O $tree_A $tree_B"
 
 test_expect_success \
     '3 - must match A in !O && A && !B case.' \
     "rm -f .git/index AN &&
      cp .orig-A/AN AN &&
-     git-update-index --add AN &&
-     git-read-tree -m $tree_O $tree_A $tree_B &&
+     git update-index --add AN &&
+     git read-tree -m $tree_O $tree_A $tree_B &&
      check_result"
 
 test_expect_success \
     '3 - matching A alone is OK in !O && A && !B case.' \
     "rm -f .git/index AN &&
      cp .orig-A/AN AN &&
-     git-update-index --add AN &&
+     git update-index --add AN &&
      echo extra >>AN &&
-     git-read-tree -m $tree_O $tree_A $tree_B"
+     git read-tree -m $tree_O $tree_A $tree_B"
 
 test_expect_failure \
     '3 (fail) - must match A in !O && A && !B case.' \
     "rm -f .git/index AN &&
      cp .orig-A/AN AN &&
      echo extra >>AN &&
-     git-update-index --add AN &&
-     git-read-tree -m $tree_O $tree_A $tree_B"
+     git update-index --add AN &&
+     git read-tree -m $tree_O $tree_A $tree_B"
 
 test_expect_success \
     '4 - must match and be up-to-date in !O && A && B && A!=B case.' \
     "rm -f .git/index AA &&
      cp .orig-A/AA AA &&
-     git-update-index --add AA &&
-     git-read-tree -m $tree_O $tree_A $tree_B &&
+     git update-index --add AA &&
+     git read-tree -m $tree_O $tree_A $tree_B &&
      check_result"
 
 test_expect_failure \
     '4 (fail) - must match and be up-to-date in !O && A && B && A!=B case.' \
     "rm -f .git/index AA &&
      cp .orig-A/AA AA &&
-     git-update-index --add AA &&
+     git update-index --add AA &&
      echo extra >>AA &&
-     git-read-tree -m $tree_O $tree_A $tree_B"
+     git read-tree -m $tree_O $tree_A $tree_B"
 
 test_expect_failure \
     '4 (fail) - must match and be up-to-date in !O && A && B && A!=B case.' \
     "rm -f .git/index AA &&
      cp .orig-A/AA AA &&
      echo extra >>AA &&
-     git-update-index --add AA &&
-     git-read-tree -m $tree_O $tree_A $tree_B"
+     git update-index --add AA &&
+     git read-tree -m $tree_O $tree_A $tree_B"
 
 test_expect_success \
     '5 - must match in !O && A && B && A==B case.' \
     "rm -f .git/index LL &&
      cp .orig-A/LL LL &&
-     git-update-index --add LL &&
-     git-read-tree -m $tree_O $tree_A $tree_B &&
+     git update-index --add LL &&
+     git read-tree -m $tree_O $tree_A $tree_B &&
      check_result"
 
 test_expect_success \
     '5 - must match in !O && A && B && A==B case.' \
     "rm -f .git/index LL &&
      cp .orig-A/LL LL &&
-     git-update-index --add LL &&
+     git update-index --add LL &&
      echo extra >>LL &&
-     git-read-tree -m $tree_O $tree_A $tree_B &&
+     git read-tree -m $tree_O $tree_A $tree_B &&
      check_result"
 
 test_expect_failure \
     '5 (fail) - must match A in !O && A && B && A==B case.' \
     "rm -f .git/index LL &&
      cp .orig-A/LL LL &&
      echo extra >>LL &&
-     git-update-index --add LL &&
-     git-read-tree -m $tree_O $tree_A $tree_B"
+     git update-index --add LL &&
+     git read-tree -m $tree_O $tree_A $tree_B"
 
 test_expect_failure \
     '6 - must not exist in O && !A && !B case' \
     "rm -f .git/index DD &&
      echo DD >DD
-     git-update-index --add DD &&
-     git-read-tree -m $tree_O $tree_A $tree_B"
+     git update-index --add DD &&
+     git read-tree -m $tree_O $tree_A $tree_B"
 
 test_expect_failure \
     '7 - must not exist in O && !A && B && O!=B case' \
     "rm -f .git/index DM &&
      cp .orig-B/DM DM &&
-     git-update-index --add DM &&
-     git-read-tree -m $tree_O $tree_A $tree_B"
+     git update-index --add DM &&
+     git read-tree -m $tree_O $tree_A $tree_B"
 
 test_expect_failure \
     '8 - must not exist in O && !A && B && O==B case' \
     "rm -f .git/index DN &&
      cp .orig-B/DN DN &&
-     git-update-index --add DN &&
-     git-read-tree -m $tree_O $tree_A $tree_B"
+     git update-index --add DN &&
+     git read-tree -m $tree_O $tree_A $tree_B"
 
 test_expect_success \
     '9 - must match and be up-to-date in O && A && !B && O!=A case' \
     "rm -f .git/index MD &&
      cp .orig-A/MD MD &&
-     git-update-index --add MD &&
-     git-read-tree -m $tree_O $tree_A $tree_B &&
+     git update-index --add MD &&
+     git read-tree -m $tree_O $tree_A $tree_B &&
      check_result"
 
 test_expect_failure \
     '9 (fail) - must match and be up-to-date in O && A && !B && O!=A case' \
     "rm -f .git/index MD &&
      cp .orig-A/MD MD &&
-     git-update-index --add MD &&
+     git update-index --add MD &&
      echo extra >>MD &&
-     git-read-tree -m $tree_O $tree_A $tree_B"
+     git read-tree -m $tree_O $tree_A $tree_B"
 
 test_expect_failure \
     '9 (fail) - must match and be up-to-date in O && A && !B && O!=A case' \
     "rm -f .git/index MD &&
      cp .orig-A/MD MD &&
      echo extra >>MD &&
-     git-update-index --add MD &&
-     git-read-tree -m $tree_O $tree_A $tree_B"
+     git update-index --add MD &&
+     git read-tree -m $tree_O $tree_A $tree_B"
 
 test_expect_success \
     '10 - must match and be up-to-date in O && A && !B && O==A case' \
     "rm -f .git/index ND &&
      cp .orig-A/ND ND &&
-     git-update-index --add ND &&
-     git-read-tree -m $tree_O $tree_A $tree_B &&
+     git update-index --add ND &&
+     git read-tree -m $tree_O $tree_A $tree_B &&
      check_result"
 
 test_expect_failure \
     '10 (fail) - must match and be up-to-date in O && A && !B && O==A case' \
     "rm -f .git/index ND &&
      cp .orig-A/ND ND &&
-     git-update-index --add ND &&
+     git update-index --add ND &&
      echo extra >>ND &&
-     git-read-tree -m $tree_O $tree_A $tree_B"
+     git read-tree -m $tree_O $tree_A $tree_B"
 
 test_expect_failure \
     '10 (fail) - must match and be up-to-date in O && A && !B && O==A case' \
     "rm -f .git/index ND &&
      cp .orig-A/ND ND &&
      echo extra >>ND &&
-     git-update-index --add ND &&
-     git-read-tree -m $tree_O $tree_A $tree_B"
+     git update-index --add ND &&
+     git read-tree -m $tree_O $tree_A $tree_B"
 
 test_expect_success \
     '11 - must match and be up-to-date in O && A && B && O!=A && O!=B && A!=B case' \
     "rm -f .git/index MM &&
      cp .orig-A/MM MM &&
-     git-update-index --add MM &&
-     git-read-tree -m $tree_O $tree_A $tree_B &&
+     git update-index --add MM &&
+     git read-tree -m $tree_O $tree_A $tree_B &&
      check_result"
 
 test_expect_failure \
     '11 (fail) - must match and be up-to-date in O && A && B && O!=A && O!=B && A!=B case' \
     "rm -f .git/index MM &&
      cp .orig-A/MM MM &&
-     git-update-index --add MM &&
+     git update-index --add MM &&
      echo extra >>MM &&
-     git-read-tree -m $tree_O $tree_A $tree_B"
+     git read-tree -m $tree_O $tree_A $tree_B"
 
 test_expect_failure \
     '11 (fail) - must match and be up-to-date in O && A && B && O!=A && O!=B && A!=B case' \
     "rm -f .git/index MM &&
      cp .orig-A/MM MM &&
      echo extra >>MM &&
-     git-update-index --add MM &&
-     git-read-tree -m $tree_O $tree_A $tree_B"
+     git update-index --add MM &&
+     git read-tree -m $tree_O $tree_A $tree_B"
 
 test_expect_success \
     '12 - must match A in O && A && B && O!=A && A==B case' \
     "rm -f .git/index SS &&
      cp .orig-A/SS SS &&
-     git-update-index --add SS &&
-     git-read-tree -m $tree_O $tree_A $tree_B &&
+     git update-index --add SS &&
+     git read-tree -m $tree_O $tree_A $tree_B &&
      check_result"
 
 test_expect_success \
     '12 - must match A in O && A && B && O!=A && A==B case' \
     "rm -f .git/index SS &&
      cp .orig-A/SS SS &&
-     git-update-index --add SS &&
+     git update-index --add SS &&
      echo extra >>SS &&
-     git-read-tree -m $tree_O $tree_A $tree_B &&
+     git read-tree -m $tree_O $tree_A $tree_B &&
      check_result"
 
 test_expect_failure \
     '12 (fail) - must match A in O && A && B && O!=A && A==B case' \
     "rm -f .git/index SS &&
      cp .orig-A/SS SS &&
      echo extra >>SS &&
-     git-update-index --add SS &&
-     git-read-tree -m $tree_O $tree_A $tree_B"
+     git update-index --add SS &&
+     git read-tree -m $tree_O $tree_A $tree_B"
 
 test_expect_success \
     '13 - must match A in O && A && B && O!=A && O==B case' \
     "rm -f .git/index MN &&
      cp .orig-A/MN MN &&
-     git-update-index --add MN &&
-     git-read-tree -m $tree_O $tree_A $tree_B &&
+     git update-index --add MN &&
+     git read-tree -m $tree_O $tree_A $tree_B &&
      check_result"
 
 test_expect_success \
     '13 - must match A in O && A && B && O!=A && O==B case' \
     "rm -f .git/index MN &&
      cp .orig-A/MN MN &&
-     git-update-index --add MN &&
+     git update-index --add MN &&
      echo extra >>MN &&
-     git-read-tree -m $tree_O $tree_A $tree_B &&
+     git read-tree -m $tree_O $tree_A $tree_B &&
      check_result"
 
 test_expect_success \
     '14 - must match and be up-to-date in O && A && B && O==A && O!=B case' \
     "rm -f .git/index NM &&
      cp .orig-A/NM NM &&
-     git-update-index --add NM &&
-     git-read-tree -m $tree_O $tree_A $tree_B &&
+     git update-index --add NM &&
+     git read-tree -m $tree_O $tree_A $tree_B &&
      check_result"
 
 test_expect_success \
     '14 - may match B in O && A && B && O==A && O!=B case' \
     "rm -f .git/index NM &&
      cp .orig-B/NM NM &&
-     git-update-index --add NM &&
+     git update-index --add NM &&
      echo extra >>NM &&
-     git-read-tree -m $tree_O $tree_A $tree_B &&
+     git read-tree -m $tree_O $tree_A $tree_B &&
      check_result"
 
 test_expect_failure \
     '14 (fail) - must match and be up-to-date in O && A && B && O==A && O!=B case' \
     "rm -f .git/index NM &&
      cp .orig-A/NM NM &&
-     git-update-index --add NM &&
+     git update-index --add NM &&
      echo extra >>NM &&
-     git-read-tree -m $tree_O $tree_A $tree_B"
+     git read-tree -m $tree_O $tree_A $tree_B"
 
 test_expect_failure \
     '14 (fail) - must match and be up-to-date in O && A && B && O==A && O!=B case' \
     "rm -f .git/index NM &&
      cp .orig-A/NM NM &&
      echo extra >>NM &&
-     git-update-index --add NM &&
-     git-read-tree -m $tree_O $tree_A $tree_B"
+     git update-index --add NM &&
+     git read-tree -m $tree_O $tree_A $tree_B"
 
 test_expect_success \
     '15 - must match A in O && A && B && O==A && O==B case' \
     "rm -f .git/index NN &&
      cp .orig-A/NN NN &&
-     git-update-index --add NN &&
-     git-read-tree -m $tree_O $tree_A $tree_B &&
+     git update-index --add NN &&
+     git read-tree -m $tree_O $tree_A $tree_B &&
      check_result"
 
 test_expect_success \
     '15 - must match A in O && A && B && O==A && O==B case' \
     "rm -f .git/index NN &&
      cp .orig-A/NN NN &&
-     git-update-index --add NN &&
+     git update-index --add NN &&
      echo extra >>NN &&
-     git-read-tree -m $tree_O $tree_A $tree_B &&
+     git read-tree -m $tree_O $tree_A $tree_B &&
      check_result"
 
 test_expect_failure \
     '15 (fail) - must match A in O && A && B && O==A && O==B case' \
     "rm -f .git/index NN &&
      cp .orig-A/NN NN &&
      echo extra >>NN &&
-     git-update-index --add NN &&
-     git-read-tree -m $tree_O $tree_A $tree_B"
+     git update-index --add NN &&
+     git read-tree -m $tree_O $tree_A $tree_B"
 
 # #16
 test_expect_success \
     '16 - A matches in one and B matches in another.' \
     'rm -f .git/index F16 &&
     echo F16 >F16 &&
-    git-update-index --add F16 &&
-    tree0=`git-write-tree` &&
+    git update-index --add F16 &&
+    tree0=`git write-tree` &&
     echo E16 >F16 &&
-    git-update-index F16 &&
-    tree1=`git-write-tree` &&
-    git-read-tree -m $tree0 $tree1 $tree1 $tree0 &&
-    git-ls-files --stage'
+    git update-index F16 &&
+    tree1=`git write-tree` &&
+    git read-tree -m $tree0 $tree1 $tree1 $tree0 &&
+    git ls-files --stage'
 
 test_done
@@ -11,7 +11,7 @@ There is the head (called H) and another commit (called M), which is
 simply ahead of H.  The index and the work tree contains a state that
 is derived from H, but may also have local changes.  This test checks
 all the combinations described in the two-tree merge "carry forward"
-rules, found in <Documentation/git-read-tree.txt>.
+rules, found in <Documentation/git read-tree.txt>.
 
 In the test, these paths are used:
         bozbar  - in H, stays in M, modified from bozbar to gnusto
@@ -23,7 +23,7 @@ In the test, these paths are used:
 . ./test-lib.sh
 
 read_tree_twoway () {
-    git-read-tree -m "$1" "$2" && git-ls-files --stage
+    git read-tree -m "$1" "$2" && git ls-files --stage
 }
 
 _x40='[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f]'
@@ -37,7 +37,7 @@ compare_change () {
 }
 
 check_cache_at () {
-	clean_if_empty=`git-diff-files -- "$1"`
+	clean_if_empty=`git diff-files -- "$1"`
 	case "$clean_if_empty" in
 	'')  echo "$1: clean" ;;
 	?*)  echo "$1: dirty" ;;
@@ -68,24 +68,24 @@ test_expect_success \
      cat bozbar-old >bozbar &&
      echo rezrov >rezrov &&
      echo yomin >yomin &&
-     git-update-index --add nitfol bozbar rezrov &&
-     treeH=`git-write-tree` &&
+     git update-index --add nitfol bozbar rezrov &&
+     treeH=`git write-tree` &&
      echo treeH $treeH &&
-     git-ls-tree $treeH &&
+     git ls-tree $treeH &&
 
      cat bozbar-new >bozbar &&
-     git-update-index --add frotz bozbar --force-remove rezrov &&
-     git-ls-files --stage >M.out &&
-     treeM=`git-write-tree` &&
+     git update-index --add frotz bozbar --force-remove rezrov &&
+     git ls-files --stage >M.out &&
+     treeM=`git write-tree` &&
      echo treeM $treeM &&
-     git-ls-tree $treeM &&
-     git-diff-tree $treeH $treeM'
+     git ls-tree $treeM &&
+     git diff-tree $treeH $treeM'
 
 test_expect_success \
     '1, 2, 3 - no carry forward' \
     'rm -f .git/index &&
      read_tree_twoway $treeH $treeM &&
-     git-ls-files --stage >1-3.out &&
+     git ls-files --stage >1-3.out &&
      git diff M.out 1-3.out &&
      check_cache_at bozbar dirty &&
      check_cache_at frotz dirty &&
@@ -96,109 +96,109 @@ echo '+100644 X 0	yomin' >expected
 test_expect_success \
     '4 - carry forward local addition.' \
     'rm -f .git/index &&
-     git-read-tree $treeH &&
-     git-checkout-index -u -f -q -a &&
-     git-update-index --add yomin &&
+     git read-tree $treeH &&
+     git checkout-index -u -f -q -a &&
+     git update-index --add yomin &&
      read_tree_twoway $treeH $treeM &&
-     git-ls-files --stage >4.out || return 1
+     git ls-files --stage >4.out || return 1
      git diff M.out 4.out >4diff.out
      compare_change 4diff.out expected &&
      check_cache_at yomin clean'
 
 test_expect_success \
     '5 - carry forward local addition.' \
     'rm -f .git/index &&
-     git-read-tree $treeH &&
-     git-checkout-index -u -f -q -a &&
+     git read-tree $treeH &&
+     git checkout-index -u -f -q -a &&
      echo yomin >yomin &&
-     git-update-index --add yomin &&
+     git update-index --add yomin &&
      echo yomin yomin >yomin &&
      read_tree_twoway $treeH $treeM &&
-     git-ls-files --stage >5.out || return 1
+     git ls-files --stage >5.out || return 1
      git diff M.out 5.out >5diff.out
      compare_change 5diff.out expected &&
      check_cache_at yomin dirty'
 
 test_expect_success \
     '6 - local addition already has the same.' \
     'rm -f .git/index &&
-     git-read-tree $treeH &&
-     git-checkout-index -u -f -q -a &&
-     git-update-index --add frotz &&
+     git read-tree $treeH &&
+     git checkout-index -u -f -q -a &&
+     git update-index --add frotz &&
      read_tree_twoway $treeH $treeM &&
-     git-ls-files --stage >6.out &&
+     git ls-files --stage >6.out &&
      git diff M.out 6.out &&
      check_cache_at frotz clean'
 
 test_expect_success \
     '7 - local addition already has the same.' \
     'rm -f .git/index &&
-     git-read-tree $treeH &&
-     git-checkout-index -u -f -q -a &&
+     git read-tree $treeH &&
+     git checkout-index -u -f -q -a &&
      echo frotz >frotz &&
-     git-update-index --add frotz &&
+     git update-index --add frotz &&
      echo frotz frotz >frotz &&
      read_tree_twoway $treeH $treeM &&
-     git-ls-files --stage >7.out &&
+     git ls-files --stage >7.out &&
      git diff M.out 7.out &&
      check_cache_at frotz dirty'
 
 test_expect_success \
     '8 - conflicting addition.' \
     'rm -f .git/index &&
-     git-read-tree $treeH &&
-     git-checkout-index -u -f -q -a &&
+     git read-tree $treeH &&
+     git checkout-index -u -f -q -a &&
      echo frotz frotz >frotz &&
-     git-update-index --add frotz &&
+     git update-index --add frotz &&
      if read_tree_twoway $treeH $treeM; then false; else :; fi'
 
 test_expect_success \
     '9 - conflicting addition.' \
     'rm -f .git/index &&
-     git-read-tree $treeH &&
-     git-checkout-index -u -f -q -a &&
+     git read-tree $treeH &&
+     git checkout-index -u -f -q -a &&
      echo frotz frotz >frotz &&
-     git-update-index --add frotz &&
+     git update-index --add frotz &&
      echo frotz >frotz &&
      if read_tree_twoway $treeH $treeM; then false; else :; fi'
 
 test_expect_success \
     '10 - path removed.' \
     'rm -f .git/index &&
-     git-read-tree $treeH &&
-     git-checkout-index -u -f -q -a &&
+     git read-tree $treeH &&
+     git checkout-index -u -f -q -a &&
      echo rezrov >rezrov &&
-     git-update-index --add rezrov &&
+     git update-index --add rezrov &&
      read_tree_twoway $treeH $treeM &&
-     git-ls-files --stage >10.out &&
+     git ls-files --stage >10.out &&
      git diff M.out 10.out'
 
 test_expect_success \
     '11 - dirty path removed.' \
     'rm -f .git/index &&
-     git-read-tree $treeH &&
-     git-checkout-index -u -f -q -a &&
+     git read-tree $treeH &&
+     git checkout-index -u -f -q -a &&
      echo rezrov >rezrov &&
-     git-update-index --add rezrov &&
+     git update-index --add rezrov &&
      echo rezrov rezrov >rezrov &&
      if read_tree_twoway $treeH $treeM; then false; else :; fi'
 
 test_expect_success \
     '12 - unmatching local changes being removed.' \
     'rm -f .git/index &&
-     git-read-tree $treeH &&
-     git-checkout-index -u -f -q -a &&
+     git read-tree $treeH &&
+     git checkout-index -u -f -q -a &&
      echo rezrov rezrov >rezrov &&
-     git-update-index --add rezrov &&
+     git update-index --add rezrov &&
      if read_tree_twoway $treeH $treeM; then false; else :; fi'
 
 test_expect_success \
     '13 - unmatching local changes being removed.' \
     'rm -f .git/index &&
-     git-read-tree $treeH &&
-     git-checkout-index -u -f -q -a &&
+     git read-tree $treeH &&
+     git checkout-index -u -f -q -a &&
      echo rezrov rezrov >rezrov &&
-     git-update-index --add rezrov &&
+     git update-index --add rezrov &&
      echo rezrov >rezrov &&
      if read_tree_twoway $treeH $treeM; then false; else :; fi'
 
@@ -210,133 +210,133 @@ EOF
 test_expect_success \
     '14 - unchanged in two heads.' \
     'rm -f .git/index &&
-     git-read-tree $treeH &&
-     git-checkout-index -u -f -q -a &&
+     git read-tree $treeH &&
+     git checkout-index -u -f -q -a &&
      echo nitfol nitfol >nitfol &&
-     git-update-index --add nitfol &&
+     git update-index --add nitfol &&
      read_tree_twoway $treeH $treeM &&
-     git-ls-files --stage >14.out || return 1
+     git ls-files --stage >14.out || return 1
      git diff M.out 14.out >14diff.out
      compare_change 14diff.out expected &&
      check_cache_at nitfol clean'
 
 test_expect_success \
     '15 - unchanged in two heads.' \
     'rm -f .git/index &&
-     git-read-tree $treeH &&
-     git-checkout-index -u -f -q -a &&
+     git read-tree $treeH &&
+     git checkout-index -u -f -q -a &&
      echo nitfol nitfol >nitfol &&
-     git-update-index --add nitfol &&
+     git update-index --add nitfol &&
      echo nitfol nitfol nitfol >nitfol &&
      read_tree_twoway $treeH $treeM &&
-     git-ls-files --stage >15.out || return 1
+     git ls-files --stage >15.out || return 1
      git diff M.out 15.out >15diff.out
      compare_change 15diff.out expected &&
      check_cache_at nitfol dirty'
 
 test_expect_success \
     '16 - conflicting local change.' \
     'rm -f .git/index &&
-     git-read-tree $treeH &&
-     git-checkout-index -u -f -q -a &&
+     git read-tree $treeH &&
+     git checkout-index -u -f -q -a &&
      echo bozbar bozbar >bozbar &&
-     git-update-index --add bozbar &&
+     git update-index --add bozbar &&
      if read_tree_twoway $treeH $treeM; then false; else :; fi'
 
 test_expect_success \
     '17 - conflicting local change.' \
     'rm -f .git/index &&
-     git-read-tree $treeH &&
-     git-checkout-index -u -f -q -a &&
+     git read-tree $treeH &&
+     git checkout-index -u -f -q -a &&
      echo bozbar bozbar >bozbar &&
-     git-update-index --add bozbar &&
+     git update-index --add bozbar &&
      echo bozbar bozbar bozbar >bozbar &&
      if read_tree_twoway $treeH $treeM; then false; else :; fi'
 
 test_expect_success \
     '18 - local change already having a good result.' \
     'rm -f .git/index &&
-     git-read-tree $treeH &&
-     git-checkout-index -u -f -q -a &&
+     git read-tree $treeH &&
+     git checkout-index -u -f -q -a &&
      cat bozbar-new >bozbar &&
-     git-update-index --add bozbar &&
+     git update-index --add bozbar &&
      read_tree_twoway $treeH $treeM &&
-     git-ls-files --stage >18.out &&
+     git ls-files --stage >18.out &&
      git diff M.out 18.out &&
      check_cache_at bozbar clean'
 
 test_expect_success \
     '19 - local change already having a good result, further modified.' \
     'rm -f .git/index &&
-     git-read-tree $treeH &&
-     git-checkout-index -u -f -q -a &&
+     git read-tree $treeH &&
+     git checkout-index -u -f -q -a &&
      cat bozbar-new >bozbar &&
-     git-update-index --add bozbar &&
+     git update-index --add bozbar &&
      echo gnusto gnusto >bozbar &&
      read_tree_twoway $treeH $treeM &&
-     git-ls-files --stage >19.out &&
+     git ls-files --stage >19.out &&
      git diff M.out 19.out &&
      check_cache_at bozbar dirty'
 
 test_expect_success \
     '20 - no local change, use new tree.' \
     'rm -f .git/index &&
-     git-read-tree $treeH &&
-     git-checkout-index -u -f -q -a &&
+     git read-tree $treeH &&
+     git checkout-index -u -f -q -a &&
      cat bozbar-old >bozbar &&
-     git-update-index --add bozbar &&
+     git update-index --add bozbar &&
      read_tree_twoway $treeH $treeM &&
-     git-ls-files --stage >20.out &&
+     git ls-files --stage >20.out &&
      git diff M.out 20.out &&
      check_cache_at bozbar dirty'
 
 test_expect_success \
     '21 - no local change, dirty cache.' \
     'rm -f .git/index &&
-     git-read-tree $treeH &&
-     git-checkout-index -u -f -q -a &&
+     git read-tree $treeH &&
+     git checkout-index -u -f -q -a &&
      cat bozbar-old >bozbar &&
-     git-update-index --add bozbar &&
+     git update-index --add bozbar &&
      echo gnusto gnusto >bozbar &&
      if read_tree_twoway $treeH $treeM; then false; else :; fi'
 
 # This fails with straight two-way fast forward.
 test_expect_success \
     '22 - local change cache updated.' \
     'rm -f .git/index &&
-     git-read-tree $treeH &&
-     git-checkout-index -u -f -q -a &&
+     git read-tree $treeH &&
+     git checkout-index -u -f -q -a &&
      sed -e "s/such as/SUCH AS/" bozbar-old >bozbar &&
-     git-update-index --add bozbar &&
+     git update-index --add bozbar &&
      if read_tree_twoway $treeH $treeM; then false; else :; fi'
 
 # Also make sure we did not break DF vs DF/DF case.
 test_expect_success \
     'DF vs DF/DF case setup.' \
     'rm -f .git/index &&
      echo DF >DF &&
-     git-update-index --add DF &&
-     treeDF=`git-write-tree` &&
+     git update-index --add DF &&
+     treeDF=`git write-tree` &&
      echo treeDF $treeDF &&
-     git-ls-tree $treeDF &&
+     git ls-tree $treeDF &&
 
      rm -f DF &&
      mkdir DF &&
      echo DF/DF >DF/DF &&
-     git-update-index --add --remove DF DF/DF &&
-     treeDFDF=`git-write-tree` &&
+     git update-index --add --remove DF DF/DF &&
+     treeDFDF=`git write-tree` &&
      echo treeDFDF $treeDFDF &&
-     git-ls-tree $treeDFDF &&
-     git-ls-files --stage >DFDF.out'
+     git ls-tree $treeDFDF &&
+     git ls-files --stage >DFDF.out'
 
 test_expect_success \
     'DF vs DF/DF case test.' \
     'rm -f .git/index &&
      rm -fr DF &&
      echo DF >DF &&
-     git-update-index --add DF &&
+     git update-index --add DF &&
      read_tree_twoway $treeDF $treeDFDF &&
-     git-ls-files --stage >DFDFcheck.out &&
+     git ls-files --stage >DFDFcheck.out &&
      git diff DFDF.out DFDFcheck.out &&
      check_cache_at DF/DF dirty &&
      :'
@@ -20,7 +20,7 @@ compare_change () {
 }
 
 check_cache_at () {
-	clean_if_empty=`git-diff-files -- "$1"`
+	clean_if_empty=`git diff-files -- "$1"`
 	case "$clean_if_empty" in
 	'')  echo "$1: clean" ;;
 	?*)  echo "$1: dirty" ;;
@@ -39,26 +39,26 @@ test_expect_success \
      echo nitfol >nitfol &&
      echo bozbar >bozbar &&
      echo rezrov >rezrov &&
-     git-update-index --add nitfol bozbar rezrov &&
-     treeH=`git-write-tree` &&
+     git update-index --add nitfol bozbar rezrov &&
+     treeH=`git write-tree` &&
      echo treeH $treeH &&
-     git-ls-tree $treeH &&
+     git ls-tree $treeH &&
 
      echo gnusto >bozbar &&
-     git-update-index --add frotz bozbar --force-remove rezrov &&
-     git-ls-files --stage >M.out &&
-     treeM=`git-write-tree` &&
+     git update-index --add frotz bozbar --force-remove rezrov &&
+     git ls-files --stage >M.out &&
+     treeM=`git write-tree` &&
      echo treeM $treeM &&
-     git-ls-tree $treeM &&
+     git ls-tree $treeM &&
      sum bozbar frotz nitfol >M.sum &&
-     git-diff-tree $treeH $treeM'
+     git diff-tree $treeH $treeM'
 
 test_expect_success \
     '1, 2, 3 - no carry forward' \
     'rm -f .git/index nitfol bozbar rezrov frotz &&
-     git-read-tree --reset -u $treeH &&
-     git-read-tree -m -u $treeH $treeM &&
-     git-ls-files --stage >1-3.out &&
+     git read-tree --reset -u $treeH &&
+     git read-tree -m -u $treeH $treeM &&
+     git ls-files --stage >1-3.out &&
      cmp M.out 1-3.out &&
      sum bozbar frotz nitfol >actual3.sum &&
      cmp M.sum actual3.sum &&
@@ -69,12 +69,12 @@ test_expect_success \
 test_expect_success \
     '4 - carry forward local addition.' \
     'rm -f .git/index nitfol bozbar rezrov frotz &&
-     git-read-tree --reset -u $treeH &&
+     git read-tree --reset -u $treeH &&
      echo "+100644 X 0	yomin" >expected &&
      echo yomin >yomin &&
-     git-update-index --add yomin &&
-     git-read-tree -m -u $treeH $treeM &&
-     git-ls-files --stage >4.out || return 1
+     git update-index --add yomin &&
+     git read-tree -m -u $treeH $treeM &&
+     git ls-files --stage >4.out || return 1
      diff -U0 M.out 4.out >4diff.out
      compare_change 4diff.out expected &&
      check_cache_at yomin clean &&
@@ -87,13 +87,13 @@ test_expect_success \
 test_expect_success \
     '5 - carry forward local addition.' \
     'rm -f .git/index nitfol bozbar rezrov frotz &&
-     git-read-tree --reset -u $treeH &&
-     git-read-tree -m -u $treeH &&
+     git read-tree --reset -u $treeH &&
+     git read-tree -m -u $treeH &&
      echo yomin >yomin &&
-     git-update-index --add yomin &&
+     git update-index --add yomin &&
      echo yomin yomin >yomin &&
-     git-read-tree -m -u $treeH $treeM &&
-     git-ls-files --stage >5.out || return 1
+     git read-tree -m -u $treeH $treeM &&
+     git ls-files --stage >5.out || return 1
      diff -U0 M.out 5.out >5diff.out
      compare_change 5diff.out expected &&
      check_cache_at yomin dirty &&
@@ -107,11 +107,11 @@ test_expect_success \
 test_expect_success \
     '6 - local addition already has the same.' \
     'rm -f .git/index nitfol bozbar rezrov frotz &&
-     git-read-tree --reset -u $treeH &&
+     git read-tree --reset -u $treeH &&
      echo frotz >frotz &&
-     git-update-index --add frotz &&
-     git-read-tree -m -u $treeH $treeM &&
-     git-ls-files --stage >6.out &&
+     git update-index --add frotz &&
+     git read-tree -m -u $treeH $treeM &&
+     git ls-files --stage >6.out &&
      diff -U0 M.out 6.out &&
      check_cache_at frotz clean &&
      sum bozbar frotz nitfol >actual3.sum &&
@@ -123,12 +123,12 @@ test_expect_success \
 test_expect_success \
     '7 - local addition already has the same.' \
     'rm -f .git/index nitfol bozbar rezrov frotz &&
-     git-read-tree --reset -u $treeH &&
+     git read-tree --reset -u $treeH &&
      echo frotz >frotz &&
-     git-update-index --add frotz &&
+     git update-index --add frotz &&
      echo frotz frotz >frotz &&
-     git-read-tree -m -u $treeH $treeM &&
-     git-ls-files --stage >7.out &&
+     git read-tree -m -u $treeH $treeM &&
+     git ls-files --stage >7.out &&
      diff -U0 M.out 7.out &&
      check_cache_at frotz dirty &&
      sum bozbar frotz nitfol >actual7.sum &&
@@ -141,57 +141,57 @@ test_expect_success \
 test_expect_success \
     '8 - conflicting addition.' \
     'rm -f .git/index nitfol bozbar rezrov frotz &&
-     git-read-tree --reset -u $treeH &&
+     git read-tree --reset -u $treeH &&
      echo frotz frotz >frotz &&
-     git-update-index --add frotz &&
-     if git-read-tree -m -u $treeH $treeM; then false; else :; fi'
+     git update-index --add frotz &&
+     if git read-tree -m -u $treeH $treeM; then false; else :; fi'
 
 test_expect_success \
     '9 - conflicting addition.' \
     'rm -f .git/index nitfol bozbar rezrov frotz &&
-     git-read-tree --reset -u $treeH &&
+     git read-tree --reset -u $treeH &&
      echo frotz frotz >frotz &&
-     git-update-index --add frotz &&
+     git update-index --add frotz &&
      echo frotz >frotz &&
-     if git-read-tree -m -u $treeH $treeM; then false; else :; fi'
+     if git read-tree -m -u $treeH $treeM; then false; else :; fi'
 
 test_expect_success \
     '10 - path removed.' \
     'rm -f .git/index nitfol bozbar rezrov frotz &&
-     git-read-tree --reset -u $treeH &&
+     git read-tree --reset -u $treeH &&
      echo rezrov >rezrov &&
-     git-update-index --add rezrov &&
-     git-read-tree -m -u $treeH $treeM &&
-     git-ls-files --stage >10.out &&
+     git update-index --add rezrov &&
+     git read-tree -m -u $treeH $treeM &&
+     git ls-files --stage >10.out &&
      cmp M.out 10.out &&
      sum bozbar frotz nitfol >actual10.sum &&
      cmp M.sum actual10.sum'
 
 test_expect_success \
     '11 - dirty path removed.' \
     'rm -f .git/index nitfol bozbar rezrov frotz &&
-     git-read-tree --reset -u $treeH &&
+     git read-tree --reset -u $treeH &&
      echo rezrov >rezrov &&
-     git-update-index --add rezrov &&
+     git update-index --add rezrov &&
      echo rezrov rezrov >rezrov &&
-     if git-read-tree -m -u $treeH $treeM; then false; else :; fi'
+     if git read-tree -m -u $treeH $treeM; then false; else :; fi'
 
 test_expect_success \
     '12 - unmatching local changes being removed.' \
     'rm -f .git/index nitfol bozbar rezrov frotz &&
-     git-read-tree --reset -u $treeH &&
+     git read-tree --reset -u $treeH &&
      echo rezrov rezrov >rezrov &&
-     git-update-index --add rezrov &&
-     if git-read-tree -m -u $treeH $treeM; then false; else :; fi'
+     git update-index --add rezrov &&
+     if git read-tree -m -u $treeH $treeM; then false; else :; fi'
 
 test_expect_success \
     '13 - unmatching local changes being removed.' \
     'rm -f .git/index nitfol bozbar rezrov frotz &&
-     git-read-tree --reset -u $treeH &&
+     git read-tree --reset -u $treeH &&
      echo rezrov rezrov >rezrov &&
-     git-update-index --add rezrov &&
+     git update-index --add rezrov &&
      echo rezrov >rezrov &&
-     if git-read-tree -m -u $treeH $treeM; then false; else :; fi'
+     if git read-tree -m -u $treeH $treeM; then false; else :; fi'
 
 cat >expected <<EOF
 -100644 X 0	nitfol
@@ -201,11 +201,11 @@ EOF
 test_expect_success \
     '14 - unchanged in two heads.' \
     'rm -f .git/index nitfol bozbar rezrov frotz &&
-     git-read-tree --reset -u $treeH &&
+     git read-tree --reset -u $treeH &&
      echo nitfol nitfol >nitfol &&
-     git-update-index --add nitfol &&
-     git-read-tree -m -u $treeH $treeM &&
-     git-ls-files --stage >14.out || return 1
+     git update-index --add nitfol &&
+     git read-tree -m -u $treeH $treeM &&
+     git ls-files --stage >14.out || return 1
      diff -U0 M.out 14.out >14diff.out
      compare_change 14diff.out expected &&
      sum bozbar frotz >actual14.sum &&
@@ -221,12 +221,12 @@ test_expect_success \
 test_expect_success \
     '15 - unchanged in two heads.' \
     'rm -f .git/index nitfol bozbar rezrov frotz &&
-     git-read-tree --reset -u $treeH &&
+     git read-tree --reset -u $treeH &&
      echo nitfol nitfol >nitfol &&
-     git-update-index --add nitfol &&
+     git update-index --add nitfol &&
      echo nitfol nitfol nitfol >nitfol &&
-     git-read-tree -m -u $treeH $treeM &&
-     git-ls-files --stage >15.out || return 1
+     git read-tree -m -u $treeH $treeM &&
+     git ls-files --stage >15.out || return 1
      diff -U0 M.out 15.out >15diff.out
      compare_change 15diff.out expected &&
      check_cache_at nitfol dirty &&
@@ -242,28 +242,28 @@ test_expect_success \
 test_expect_success \
     '16 - conflicting local change.' \
     'rm -f .git/index nitfol bozbar rezrov frotz &&
-     git-read-tree --reset -u $treeH &&
+     git read-tree --reset -u $treeH &&
      echo bozbar bozbar >bozbar &&
-     git-update-index --add bozbar &&
-     if git-read-tree -m -u $treeH $treeM; then false; else :; fi'
+     git update-index --add bozbar &&
+     if git read-tree -m -u $treeH $treeM; then false; else :; fi'
 
 test_expect_success \
     '17 - conflicting local change.' \
     'rm -f .git/index nitfol bozbar rezrov frotz &&
-     git-read-tree --reset -u $treeH &&
+     git read-tree --reset -u $treeH &&
      echo bozbar bozbar >bozbar &&
-     git-update-index --add bozbar &&
+     git update-index --add bozbar &&
      echo bozbar bozbar bozbar >bozbar &&
-     if git-read-tree -m -u $treeH $treeM; then false; else :; fi'
+     if git read-tree -m -u $treeH $treeM; then false; else :; fi'
 
 test_expect_success \
     '18 - local change already having a good result.' \
     'rm -f .git/index nitfol bozbar rezrov frotz &&
-     git-read-tree --reset -u $treeH &&
+     git read-tree --reset -u $treeH &&
      echo gnusto >bozbar &&
-     git-update-index --add bozbar &&
-     git-read-tree -m -u $treeH $treeM &&
-     git-ls-files --stage >18.out &&
+     git update-index --add bozbar &&
+     git read-tree -m -u $treeH $treeM &&
+     git ls-files --stage >18.out &&
      diff -U0 M.out 18.out &&
      check_cache_at bozbar clean &&
      sum bozbar frotz nitfol >actual18.sum &&
@@ -272,12 +272,12 @@ test_expect_success \
 test_expect_success \
     '19 - local change already having a good result, further modified.' \
     'rm -f .git/index nitfol bozbar rezrov frotz &&
-     git-read-tree --reset -u $treeH &&
+     git read-tree --reset -u $treeH &&
      echo gnusto >bozbar &&
-     git-update-index --add bozbar &&
+     git update-index --add bozbar &&
      echo gnusto gnusto >bozbar &&
-     git-read-tree -m -u $treeH $treeM &&
-     git-ls-files --stage >19.out &&
+     git read-tree -m -u $treeH $treeM &&
+     git ls-files --stage >19.out &&
      diff -U0 M.out 19.out &&
      check_cache_at bozbar dirty &&
      sum frotz nitfol >actual19.sum &&
@@ -292,11 +292,11 @@ test_expect_success \
 test_expect_success \
     '20 - no local change, use new tree.' \
     'rm -f .git/index nitfol bozbar rezrov frotz &&
-     git-read-tree --reset -u $treeH &&
+     git read-tree --reset -u $treeH &&
      echo bozbar >bozbar &&
-     git-update-index --add bozbar &&
-     git-read-tree -m -u $treeH $treeM &&
-     git-ls-files --stage >20.out &&
+     git update-index --add bozbar &&
+     git read-tree -m -u $treeH $treeM &&
+     git ls-files --stage >20.out &&
      diff -U0 M.out 20.out &&
      check_cache_at bozbar clean &&
      sum bozbar frotz nitfol >actual20.sum &&
@@ -305,39 +305,39 @@ test_expect_success \
 test_expect_success \
     '21 - no local change, dirty cache.' \
     'rm -f .git/index nitfol bozbar rezrov frotz &&
-     git-read-tree --reset -u $treeH &&
+     git read-tree --reset -u $treeH &&
      echo bozbar >bozbar &&
-     git-update-index --add bozbar &&
+     git update-index --add bozbar &&
      echo gnusto gnusto >bozbar &&
-     if git-read-tree -m -u $treeH $treeM; then false; else :; fi'
+     if git read-tree -m -u $treeH $treeM; then false; else :; fi'
 
 # Also make sure we did not break DF vs DF/DF case.
 test_expect_success \
     'DF vs DF/DF case setup.' \
     'rm -f .git/index
      echo DF >DF &&
-     git-update-index --add DF &&
-     treeDF=`git-write-tree` &&
+     git update-index --add DF &&
+     treeDF=`git write-tree` &&
      echo treeDF $treeDF &&
-     git-ls-tree $treeDF &&
+     git ls-tree $treeDF &&
 
      rm -f DF &&
      mkdir DF &&
      echo DF/DF >DF/DF &&
-     git-update-index --add --remove DF DF/DF &&
-     treeDFDF=`git-write-tree` &&
+     git update-index --add --remove DF DF/DF &&
+     treeDFDF=`git write-tree` &&
      echo treeDFDF $treeDFDF &&
-     git-ls-tree $treeDFDF &&
-     git-ls-files --stage >DFDF.out'
+     git ls-tree $treeDFDF &&
+     git ls-files --stage >DFDF.out'
 
 test_expect_success \
     'DF vs DF/DF case test.' \
     'rm -f .git/index &&
      rm -fr DF &&
      echo DF >DF &&
-     git-update-index --add DF &&
-     git-read-tree -m -u $treeDF $treeDFDF &&
-     git-ls-files --stage >DFDFcheck.out &&
+     git update-index --add DF &&
+     git read-tree -m -u $treeDF $treeDFDF &&
+     git ls-files --stage >DFDFcheck.out &&
      diff -U0 DFDF.out DFDFcheck.out &&
      check_cache_at DF/DF clean'
 
@@ -3,24 +3,24 @@
 # Copyright (c) 2006 Junio C Hamano
 #
 
-test_description='git-read-tree --prefix test.
+test_description='git read-tree --prefix test.
 '
 
 . ./test-lib.sh
 
 test_expect_success setup '
 	echo hello >one &&
-	git-update-index --add one &&
-	tree=`git-write-tree` &&
+	git update-index --add one &&
+	tree=`git write-tree` &&
 	echo tree is $tree
 '
 
 echo 'one
 two/one' >expect
 
 test_expect_success 'read-tree --prefix' '
-	git-read-tree --prefix=two/ $tree &&
-	git-ls-files >actual &&
+	git read-tree --prefix=two/ $tree &&
+	git ls-files >actual &&
 	cmp expect actual
 '
 
@@ -84,7 +84,7 @@ test_expect_success 'three-way not complaining on an untracked path in both' '
 	echo >file2 file two is untracked on the master side &&
 	echo >subdir/file2 file two is untracked on the master side &&
 
-	git-read-tree -m -u branch-point master side
+	git read-tree -m -u branch-point master side
 '
 
 test_expect_success 'three-way not clobbering a working tree file' '
@@ -22,33 +22,33 @@ LF='
 
 test_expect_success 'update-index and ls-files' '
 	cd $HERE &&
-	git-update-index --add one &&
-	case "`git-ls-files`" in
+	git update-index --add one &&
+	case "`git ls-files`" in
 	one) echo ok one ;;
 	*) echo bad one; exit 1 ;;
 	esac &&
 	cd dir &&
-	git-update-index --add two &&
-	case "`git-ls-files`" in
+	git update-index --add two &&
+	case "`git ls-files`" in
 	two) echo ok two ;;
 	*) echo bad two; exit 1 ;;
 	esac &&
 	cd .. &&
-	case "`git-ls-files`" in
+	case "`git ls-files`" in
 	dir/two"$LF"one) echo ok both ;;
 	*) echo bad; exit 1 ;;
 	esac
 '
 
 test_expect_success 'cat-file' '
 	cd $HERE &&
-	two=`git-ls-files -s dir/two` &&
+	two=`git ls-files -s dir/two` &&
 	two=`expr "$two" : "[0-7]* \\([0-9a-f]*\\)"` &&
 	echo "$two" &&
-	git-cat-file -p "$two" >actual &&
+	git cat-file -p "$two" >actual &&
 	cmp dir/two actual &&
 	cd dir &&
-	git-cat-file -p "$two" >actual &&
+	git cat-file -p "$two" >actual &&
 	cmp two actual
 '
 rm -f actual dir/actual
@@ -57,51 +57,51 @@ test_expect_success 'diff-files' '
 	cd $HERE &&
 	echo a >>one &&
 	echo d >>dir/two &&
-	case "`git-diff-files --name-only`" in
+	case "`git diff-files --name-only`" in
 	dir/two"$LF"one) echo ok top ;;
 	*) echo bad top; exit 1 ;;
 	esac &&
 	# diff should not omit leading paths
 	cd dir &&
-	case "`git-diff-files --name-only`" in
+	case "`git diff-files --name-only`" in
 	dir/two"$LF"one) echo ok subdir ;;
 	*) echo bad subdir; exit 1 ;;
 	esac &&
-	case "`git-diff-files --name-only .`" in
+	case "`git diff-files --name-only .`" in
 	dir/two) echo ok subdir limited ;;
 	*) echo bad subdir limited; exit 1 ;;
 	esac
 '
 
 test_expect_success 'write-tree' '
 	cd $HERE &&
-	top=`git-write-tree` &&
+	top=`git write-tree` &&
 	echo $top &&
 	cd dir &&
-	sub=`git-write-tree` &&
+	sub=`git write-tree` &&
 	echo $sub &&
 	test "z$top" = "z$sub"
 '
 
 test_expect_success 'checkout-index' '
 	cd $HERE &&
-	git-checkout-index -f -u one &&
+	git checkout-index -f -u one &&
 	cmp one original.one &&
 	cd dir &&
-	git-checkout-index -f -u two &&
+	git checkout-index -f -u two &&
 	cmp two ../original.two
 '
 
 test_expect_success 'read-tree' '
 	cd $HERE &&
 	rm -f one dir/two &&
-	tree=`git-write-tree` &&
-	git-read-tree --reset -u "$tree" &&
+	tree=`git write-tree` &&
+	git read-tree --reset -u "$tree" &&
 	cmp one original.one &&
 	cmp dir/two original.two &&
 	cd dir &&
 	rm -f two &&
-	git-read-tree --reset -u "$tree" &&
+	git read-tree --reset -u "$tree" &&
 	cmp two ../original.two &&
 	cmp ../one ../original.one
 '
@@ -3,9 +3,9 @@
 # Copyright (C) 2005 Rene Scharfe
 #
 
-test_description='git-commit-tree options test
+test_description='git commit-tree options test
 
-This test checks that git-commit-tree can create a specific commit
+This test checks that git commit-tree can create a specific commit
 object by defining all environment variables that it understands.
 '
 
@@ -21,7 +21,7 @@ EOF
 
 test_expect_success \
     'test preparation: write empty tree' \
-    'git-write-tree >treeid'
+    'git write-tree >treeid'
 
 test_expect_success \
     'construct commit' \
@@ -32,11 +32,11 @@ test_expect_success \
      GIT_COMMITTER_NAME="Committer Name" \
      GIT_COMMITTER_EMAIL="committer@email" \
      GIT_COMMITTER_DATE="2005-05-26 23:30" \
-     TZ=GMT git-commit-tree `cat treeid` >commitid 2>/dev/null'
+     TZ=GMT git commit-tree `cat treeid` >commitid 2>/dev/null'
 
 test_expect_success \
     'read commit' \
-    'git-cat-file commit `cat commitid` >commit'
+    'git cat-file commit `cat commitid` >commit'
 
 test_expect_success \
     'compare commit' \
@@ -10,11 +10,11 @@ test_description='A simple turial in the form of a test case'
 echo "Hello World" > hello
 echo "Silly example" > example
 
-git-update-index --add hello example
+git update-index --add hello example
 
-test_expect_success 'blob' "test blob = \"$(git-cat-file -t 557db03)\""
+test_expect_success 'blob' "test blob = \"$(git cat-file -t 557db03)\""
 
-test_expect_success 'blob 557db03' "test \"Hello World\" = \"$(git-cat-file blob 557db03)\""
+test_expect_success 'blob 557db03' "test \"Hello World\" = \"$(git cat-file blob 557db03)\""
 
 echo "It's a new day for git" >>hello
 cat > diff.expect << EOF
@@ -26,25 +26,25 @@ index 557db03..263414f 100644
  Hello World
 +It's a new day for git
 EOF
-git-diff-files -p > diff.output
-test_expect_success 'git-diff-files -p' 'cmp diff.expect diff.output'
+git diff-files -p > diff.output
+test_expect_success 'git diff-files -p' 'cmp diff.expect diff.output'
 git diff > diff.output
 test_expect_success 'git diff' 'cmp diff.expect diff.output'
 
-tree=$(git-write-tree 2>/dev/null)
+tree=$(git write-tree 2>/dev/null)
 
 test_expect_success 'tree' "test 8988da15d077d4829fc51d8544c097def6644dbb = $tree"
 
-output="$(echo "Initial commit" | git-commit-tree $(git-write-tree) 2>&1 > .git/refs/heads/master)"
+output="$(echo "Initial commit" | git commit-tree $(git write-tree) 2>&1 > .git/refs/heads/master)"
 
-git-diff-index -p HEAD > diff.output
-test_expect_success 'git-diff-index -p HEAD' 'cmp diff.expect diff.output'
+git diff-index -p HEAD > diff.output
+test_expect_success 'git diff-index -p HEAD' 'cmp diff.expect diff.output'
 
 git diff HEAD > diff.output
 test_expect_success 'git diff HEAD' 'cmp diff.expect diff.output'
 
 #rm hello
-#test_expect_success 'git-read-tree --reset HEAD' "git-read-tree --reset HEAD ; test \"hello: needs update\" = \"$(git-update-index --refresh)\""
+#test_expect_success 'git read-tree --reset HEAD' "git read-tree --reset HEAD ; test \"hello: needs update\" = \"$(git update-index --refresh)\""
 
 cat > whatchanged.expect << EOF
 commit VARIABLE
@@ -69,11 +69,11 @@ index 0000000..557db03
 +Hello World
 EOF
 
-git-whatchanged -p --root | \
+git whatchanged -p --root | \
 	sed -e "1s/^\(.\{7\}\).\{40\}/\1VARIABLE/" \
 		-e "2,3s/^\(.\{8\}\).*$/\1VARIABLE/" \
 > whatchanged.output
-test_expect_success 'git-whatchanged -p --root' 'cmp whatchanged.expect whatchanged.output'
+test_expect_success 'git whatchanged -p --root' 'cmp whatchanged.expect whatchanged.output'
 
 git tag my-first-tag
 test_expect_success 'git tag my-first-tag' 'cmp .git/refs/heads/master .git/refs/tags/my-first-tag'
@@ -3,13 +3,13 @@
 # Copyright (c) 2005 Johannes Schindelin
 #
 
-test_description='Test git-config in different settings'
+test_description='Test git config in different settings'
 
 . ./test-lib.sh
 
 test -f .git/config && rm .git/config
 
-git-config core.penguin "little blue"
+git config core.penguin "little blue"
 
 cat > expect << EOF
 [core]
@@ -18,7 +18,7 @@ EOF
 
 test_expect_success 'initial' 'cmp .git/config expect'
 
-git-config Core.Movie BadPhysics
+git config Core.Movie BadPhysics
 
 cat > expect << EOF
 [core]
@@ -28,7 +28,7 @@ EOF
 
 test_expect_success 'mixed case' 'cmp .git/config expect'
 
-git-config Cores.WhatEver Second
+git config Cores.WhatEver Second
 
 cat > expect << EOF
 [core]
@@ -40,7 +40,7 @@ EOF
 
 test_expect_success 'similar section' 'cmp .git/config expect'
 
-git-config CORE.UPPERCASE true
+git config CORE.UPPERCASE true
 
 cat > expect << EOF
 [core]
@@ -54,10 +54,10 @@ EOF
 test_expect_success 'similar section' 'cmp .git/config expect'
 
 test_expect_success 'replace with non-match' \
-	'git-config core.penguin kingpin !blue'
+	'git config core.penguin kingpin !blue'
 
 test_expect_success 'replace with non-match (actually matching)' \
-	'git-config core.penguin "very blue" !kingpin'
+	'git config core.penguin "very blue" !kingpin'
 
 cat > expect << EOF
 [core]
@@ -86,7 +86,7 @@ EOF
 cp .git/config .git/config2
 
 test_expect_success 'multiple unset' \
-	'git-config --unset-all beta.haha'
+	'git config --unset-all beta.haha'
 
 cat > expect << EOF
 [beta] ; silly comment # another comment
@@ -102,7 +102,7 @@ test_expect_success 'multiple unset is correct' 'cmp .git/config expect'
 mv .git/config2 .git/config
 
 test_expect_success '--replace-all' \
-	'git-config --replace-all beta.haha gamma'
+	'git config --replace-all beta.haha gamma'
 
 cat > expect << EOF
 [beta] ; silly comment # another comment
@@ -116,7 +116,7 @@ EOF
 
 test_expect_success 'all replaced' 'cmp .git/config expect'
 
-git-config beta.haha alpha
+git config beta.haha alpha
 
 cat > expect << EOF
 [beta] ; silly comment # another comment
@@ -130,7 +130,7 @@ EOF
 
 test_expect_success 'really mean test' 'cmp .git/config expect'
 
-git-config nextsection.nonewline wow
+git config nextsection.nonewline wow
 
 cat > expect << EOF
 [beta] ; silly comment # another comment
@@ -145,8 +145,8 @@ EOF
 
 test_expect_success 'really really mean test' 'cmp .git/config expect'
 
-test_expect_success 'get value' 'test alpha = $(git-config beta.haha)'
-git-config --unset beta.haha
+test_expect_success 'get value' 'test alpha = $(git config beta.haha)'
+git config --unset beta.haha
 
 cat > expect << EOF
 [beta] ; silly comment # another comment
@@ -160,7 +160,7 @@ EOF
 
 test_expect_success 'unset' 'cmp .git/config expect'
 
-git-config nextsection.NoNewLine "wow2 for me" "for me$"
+git config nextsection.NoNewLine "wow2 for me" "for me$"
 
 cat > expect << EOF
 [beta] ; silly comment # another comment
@@ -176,18 +176,18 @@ EOF
 test_expect_success 'multivar' 'cmp .git/config expect'
 
 test_expect_success 'non-match' \
-	'git-config --get nextsection.nonewline !for'
+	'git config --get nextsection.nonewline !for'
 
 test_expect_success 'non-match value' \
-	'test wow = $(git-config --get nextsection.nonewline !for)'
+	'test wow = $(git config --get nextsection.nonewline !for)'
 
 test_expect_failure 'ambiguous get' \
-	'git-config --get nextsection.nonewline'
+	'git config --get nextsection.nonewline'
 
 test_expect_success 'get multivar' \
-	'git-config --get-all nextsection.nonewline'
+	'git config --get-all nextsection.nonewline'
 
-git-config nextsection.nonewline "wow3" "wow$"
+git config nextsection.nonewline "wow3" "wow$"
 
 cat > expect << EOF
 [beta] ; silly comment # another comment
@@ -202,15 +202,15 @@ EOF
 
 test_expect_success 'multivar replace' 'cmp .git/config expect'
 
-test_expect_failure 'ambiguous value' 'git-config nextsection.nonewline'
+test_expect_failure 'ambiguous value' 'git config nextsection.nonewline'
 
 test_expect_failure 'ambiguous unset' \
-	'git-config --unset nextsection.nonewline'
+	'git config --unset nextsection.nonewline'
 
 test_expect_failure 'invalid unset' \
-	'git-config --unset somesection.nonewline'
+	'git config --unset somesection.nonewline'
 
-git-config --unset nextsection.nonewline "wow3$"
+git config --unset nextsection.nonewline "wow3$"
 
 cat > expect << EOF
 [beta] ; silly comment # another comment
@@ -224,12 +224,12 @@ EOF
 
 test_expect_success 'multivar unset' 'cmp .git/config expect'
 
-test_expect_failure 'invalid key' 'git-config inval.2key blabla'
+test_expect_failure 'invalid key' 'git config inval.2key blabla'
 
-test_expect_success 'correct key' 'git-config 123456.a123 987'
+test_expect_success 'correct key' 'git config 123456.a123 987'
 
 test_expect_success 'hierarchical section' \
-	'git-config Version.1.2.3eX.Alpha beta'
+	'git config Version.1.2.3eX.Alpha beta'
 
 cat > expect << EOF
 [beta] ; silly comment # another comment
@@ -255,41 +255,41 @@ version.1.2.3eX.alpha=beta
 EOF
 
 test_expect_success 'working --list' \
-	'git-config --list > output && cmp output expect'
+	'git config --list > output && cmp output expect'
 
 cat > expect << EOF
 beta.noindent sillyValue
 nextsection.nonewline wow2 for me
 EOF
 
 test_expect_success '--get-regexp' \
-	'git-config --get-regexp in > output && cmp output expect'
+	'git config --get-regexp in > output && cmp output expect'
 
-git-config --add nextsection.nonewline "wow4 for you"
+git config --add nextsection.nonewline "wow4 for you"
 
 cat > expect << EOF
 wow2 for me
 wow4 for you
 EOF
 
 test_expect_success '--add' \
-	'git-config --get-all nextsection.nonewline > output && cmp output expect'
+	'git config --get-all nextsection.nonewline > output && cmp output expect'
 
 cat > .git/config << EOF
 [novalue]
 	variable
 EOF
 
 test_expect_success 'get variable with no value' \
-	'git-config --get novalue.variable ^$'
+	'git config --get novalue.variable ^$'
 
 echo novalue.variable > expect
 
 test_expect_success 'get-regexp variable with no value' \
-	'git-config --get-regexp novalue > output &&
+	'git config --get-regexp novalue > output &&
 	 cmp output expect'
 
-git-config > output 2>&1
+git config > output 2>&1
 
 test_expect_success 'no arguments, but no crash' \
 	"test $? = 129 && grep usage output"
@@ -299,7 +299,7 @@ cat > .git/config << EOF
 	c = d
 EOF
 
-git-config a.x y
+git config a.x y
 
 cat > expect << EOF
 [a.b]
@@ -310,8 +310,8 @@ EOF
 
 test_expect_success 'new section is partial match of another' 'cmp .git/config expect'
 
-git-config b.x y
-git-config a.b c
+git config b.x y
+git config a.b c
 
 cat > expect << EOF
 [a.b]
@@ -334,11 +334,11 @@ cat > expect << EOF
 ein.bahn=strasse
 EOF
 
-GIT_CONFIG=other-config git-config -l > output
+GIT_CONFIG=other-config git config -l > output
 
 test_expect_success 'alternative GIT_CONFIG' 'cmp output expect'
 
-GIT_CONFIG=other-config git-config anwohner.park ausweis
+GIT_CONFIG=other-config git config anwohner.park ausweis
 
 cat > expect << EOF
 [ein]
@@ -361,7 +361,7 @@ weird
 EOF
 
 test_expect_success "rename section" \
-	"git-config --rename-section branch.eins branch.zwei"
+	"git config --rename-section branch.eins branch.zwei"
 
 cat > expect << EOF
 # Hallo
@@ -377,12 +377,12 @@ EOF
 test_expect_success "rename succeeded" "git diff expect .git/config"
 
 test_expect_failure "rename non-existing section" \
-	'git-config --rename-section branch."world domination" branch.drei'
+	'git config --rename-section branch."world domination" branch.drei'
 
 test_expect_success "rename succeeded" "git diff expect .git/config"
 
 test_expect_success "rename another section" \
-	'git-config --rename-section branch."1 234 blabl/a" branch.drei'
+	'git config --rename-section branch."1 234 blabl/a" branch.drei'
 
 cat > expect << EOF
 # Hallo
@@ -425,20 +425,20 @@ EOF
 
 test_expect_success 'section ending' '
 
-	git-config gitcvs.enabled true &&
-	git-config gitcvs.ext.dbname %Ggitcvs1.%a.%m.sqlite &&
-	git-config gitcvs.dbname %Ggitcvs2.%a.%m.sqlite &&
+	git config gitcvs.enabled true &&
+	git config gitcvs.ext.dbname %Ggitcvs1.%a.%m.sqlite &&
+	git config gitcvs.dbname %Ggitcvs2.%a.%m.sqlite &&
 	cmp .git/config expect
 
 '
 
 test_expect_success numbers '
 
-	git-config kilo.gram 1k &&
-	git-config mega.ton 1m &&
-	k=$(git-config --int --get kilo.gram) &&
+	git config kilo.gram 1k &&
+	git config mega.ton 1m &&
+	k=$(git config --int --get kilo.gram) &&
 	test z1024 = "z$k" &&
-	m=$(git-config --int --get mega.ton) &&
+	m=$(git config --int --get mega.ton) &&
 	test z1048576 = "z$m"
 '
 
@@ -455,30 +455,30 @@ EOF
 
 test_expect_success bool '
 
-	git-config bool.true1 01 &&
-	git-config bool.true2 -1 &&
-	git-config bool.true3 YeS &&
-	git-config bool.true4 true &&
-	git-config bool.false1 000 &&
-	git-config bool.false2 "" &&
-	git-config bool.false3 nO &&
-	git-config bool.false4 FALSE &&
+	git config bool.true1 01 &&
+	git config bool.true2 -1 &&
+	git config bool.true3 YeS &&
+	git config bool.true4 true &&
+	git config bool.false1 000 &&
+	git config bool.false2 "" &&
+	git config bool.false3 nO &&
+	git config bool.false4 FALSE &&
 	rm -f result &&
 	for i in 1 2 3 4
 	do
-	    git-config --bool --get bool.true$i >>result
-	    git-config --bool --get bool.false$i >>result
+	    git config --bool --get bool.true$i >>result
+	    git config --bool --get bool.false$i >>result
         done &&
 	cmp expect result'
 
 test_expect_failure 'invalid bool (--get)' '
 
-	git-config bool.nobool foobar &&
-	git-config --bool --get bool.nobool'
+	git config bool.nobool foobar &&
+	git config --bool --get bool.nobool'
 
 test_expect_failure 'invalid bool (set)' '
 
-	git-config --bool bool.nobool foobar'
+	git config --bool bool.nobool foobar'
 
 rm .git/config
 
@@ -496,14 +496,14 @@ EOF
 
 test_expect_success 'set --bool' '
 
-	git-config --bool bool.true1 01 &&
-	git-config --bool bool.true2 -1 &&
-	git-config --bool bool.true3 YeS &&
-	git-config --bool bool.true4 true &&
-	git-config --bool bool.false1 000 &&
-	git-config --bool bool.false2 "" &&
-	git-config --bool bool.false3 nO &&
-	git-config --bool bool.false4 FALSE &&
+	git config --bool bool.true1 01 &&
+	git config --bool bool.true2 -1 &&
+	git config --bool bool.true3 YeS &&
+	git config --bool bool.true4 true &&
+	git config --bool bool.false1 000 &&
+	git config --bool bool.false2 "" &&
+	git config --bool bool.false3 nO &&
+	git config --bool bool.false4 FALSE &&
 	cmp expect .git/config'
 
 rm .git/config
@@ -517,17 +517,17 @@ EOF
 
 test_expect_success 'set --int' '
 
-	git-config --int int.val1 01 &&
-	git-config --int int.val2 -1 &&
-	git-config --int int.val3 5m &&
+	git config --int int.val1 01 &&
+	git config --int int.val2 -1 &&
+	git config --int int.val3 5m &&
 	cmp expect .git/config'
 
 rm .git/config
 
-git-config quote.leading " test"
-git-config quote.ending "test "
-git-config quote.semicolon "test;test"
-git-config quote.hash "test#test"
+git config quote.leading " test"
+git config quote.ending "test "
+git config quote.semicolon "test;test"
+git config quote.hash "test#test"
 
 cat > expect << EOF
 [quote]
@@ -3,7 +3,7 @@
 # Copyright (c) 2006 Shawn Pearce
 #
 
-test_description='Test git-update-ref and basic ref logging'
+test_description='Test git update-ref and basic ref logging'
 . ./test-lib.sh
 
 Z=0000000000000000000000000000000000000000
@@ -19,45 +19,45 @@ n=$n_dir/fixes
 
 test_expect_success \
 	"create $m" \
-	"git-update-ref $m $A &&
+	"git update-ref $m $A &&
 	 test $A"' = $(cat .git/'"$m"')'
 test_expect_success \
 	"create $m" \
-	"git-update-ref $m $B $A &&
+	"git update-ref $m $B $A &&
 	 test $B"' = $(cat .git/'"$m"')'
 rm -f .git/$m
 
 test_expect_success \
 	"fail to create $n" \
 	"touch .git/$n_dir
-	 git-update-ref $n $A >out 2>err"'
+	 git update-ref $n $A >out 2>err"'
 	 test $? != 0'
 rm -f .git/$n_dir out err
 
 test_expect_success \
 	"create $m (by HEAD)" \
-	"git-update-ref HEAD $A &&
+	"git update-ref HEAD $A &&
 	 test $A"' = $(cat .git/'"$m"')'
 test_expect_success \
 	"create $m (by HEAD)" \
-	"git-update-ref HEAD $B $A &&
+	"git update-ref HEAD $B $A &&
 	 test $B"' = $(cat .git/'"$m"')'
 rm -f .git/$m
 
 test_expect_failure \
 	'(not) create HEAD with old sha1' \
-	"git-update-ref HEAD $A $B"
+	"git update-ref HEAD $A $B"
 test_expect_failure \
 	"(not) prior created .git/$m" \
 	"test -f .git/$m"
 rm -f .git/$m
 
 test_expect_success \
 	"create HEAD" \
-	"git-update-ref HEAD $A"
+	"git update-ref HEAD $A"
 test_expect_failure \
 	'(not) change HEAD with wrong SHA1' \
-	"git-update-ref HEAD $B $Z"
+	"git update-ref HEAD $B $Z"
 test_expect_failure \
 	"(not) changed .git/$m" \
 	"test $B"' = $(cat .git/'"$m"')'
@@ -68,17 +68,17 @@ rm -f .git/$m
 test_expect_success \
 	"create $m (logged by touch)" \
 	'GIT_COMMITTER_DATE="2005-05-26 23:30" \
-	 git-update-ref HEAD '"$A"' -m "Initial Creation" &&
+	 git update-ref HEAD '"$A"' -m "Initial Creation" &&
 	 test '"$A"' = $(cat .git/'"$m"')'
 test_expect_success \
 	"update $m (logged by touch)" \
 	'GIT_COMMITTER_DATE="2005-05-26 23:31" \
-	 git-update-ref HEAD'" $B $A "'-m "Switch" &&
+	 git update-ref HEAD'" $B $A "'-m "Switch" &&
 	 test '"$B"' = $(cat .git/'"$m"')'
 test_expect_success \
 	"set $m (logged by touch)" \
 	'GIT_COMMITTER_DATE="2005-05-26 23:41" \
-	 git-update-ref HEAD'" $A &&
+	 git update-ref HEAD'" $A &&
 	 test $A"' = $(cat .git/'"$m"')'
 
 cat >expect <<EOF
@@ -93,23 +93,23 @@ rm -rf .git/$m .git/logs expect
 
 test_expect_success \
 	'enable core.logAllRefUpdates' \
-	'git-config core.logAllRefUpdates true &&
-	 test true = $(git-config --bool --get core.logAllRefUpdates)'
+	'git config core.logAllRefUpdates true &&
+	 test true = $(git config --bool --get core.logAllRefUpdates)'
 
 test_expect_success \
 	"create $m (logged by config)" \
 	'GIT_COMMITTER_DATE="2005-05-26 23:32" \
-	 git-update-ref HEAD'" $A "'-m "Initial Creation" &&
+	 git update-ref HEAD'" $A "'-m "Initial Creation" &&
 	 test '"$A"' = $(cat .git/'"$m"')'
 test_expect_success \
 	"update $m (logged by config)" \
 	'GIT_COMMITTER_DATE="2005-05-26 23:33" \
-	 git-update-ref HEAD'" $B $A "'-m "Switch" &&
+	 git update-ref HEAD'" $B $A "'-m "Switch" &&
 	 test '"$B"' = $(cat .git/'"$m"')'
 test_expect_success \
 	"set $m (logged by config)" \
 	'GIT_COMMITTER_DATE="2005-05-26 23:43" \
-	 git-update-ref HEAD '"$A &&
+	 git update-ref HEAD '"$A &&
 	 test $A"' = $(cat .git/'"$m"')'
 
 cat >expect <<EOF
@@ -122,7 +122,7 @@ test_expect_success \
 	'diff expect .git/logs/$m'
 rm -f .git/$m .git/logs/$m expect
 
-git-update-ref $m $D
+git update-ref $m $D
 cat >.git/logs/$m <<EOF
 $C $A $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> 1117150320 -0500
 $A $B $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> 1117150380 -0500
@@ -136,49 +136,49 @@ ld="Thu, 26 May 2005 18:43:00 -0500"
 test_expect_success \
 	'Query "master@{May 25 2005}" (before history)' \
 	'rm -f o e
-	 git-rev-parse --verify "master@{May 25 2005}" >o 2>e &&
+	 git rev-parse --verify "master@{May 25 2005}" >o 2>e &&
 	 test '"$C"' = $(cat o) &&
 	 test "warning: Log for '\'master\'' only goes back to $ed." = "$(cat e)"'
 test_expect_success \
 	"Query master@{2005-05-25} (before history)" \
 	'rm -f o e
-	 git-rev-parse --verify master@{2005-05-25} >o 2>e &&
+	 git rev-parse --verify master@{2005-05-25} >o 2>e &&
 	 test '"$C"' = $(cat o) &&
 	 echo test "warning: Log for '\'master\'' only goes back to $ed." = "$(cat e)"'
 test_expect_success \
 	'Query "master@{May 26 2005 23:31:59}" (1 second before history)' \
 	'rm -f o e
-	 git-rev-parse --verify "master@{May 26 2005 23:31:59}" >o 2>e &&
+	 git rev-parse --verify "master@{May 26 2005 23:31:59}" >o 2>e &&
 	 test '"$C"' = $(cat o) &&
 	 test "warning: Log for '\''master'\'' only goes back to $ed." = "$(cat e)"'
 test_expect_success \
 	'Query "master@{May 26 2005 23:32:00}" (exactly history start)' \
 	'rm -f o e
-	 git-rev-parse --verify "master@{May 26 2005 23:32:00}" >o 2>e &&
+	 git rev-parse --verify "master@{May 26 2005 23:32:00}" >o 2>e &&
 	 test '"$A"' = $(cat o) &&
 	 test "" = "$(cat e)"'
 test_expect_success \
 	'Query "master@{2005-05-26 23:33:01}" (middle of history with gap)' \
 	'rm -f o e
-	 git-rev-parse --verify "master@{2005-05-26 23:33:01}" >o 2>e &&
+	 git rev-parse --verify "master@{2005-05-26 23:33:01}" >o 2>e &&
 	 test '"$B"' = $(cat o) &&
 	 test "warning: Log .git/logs/'"$m has gap after $gd"'." = "$(cat e)"'
 test_expect_success \
 	'Query "master@{2005-05-26 23:38:00}" (middle of history)' \
 	'rm -f o e
-	 git-rev-parse --verify "master@{2005-05-26 23:38:00}" >o 2>e &&
+	 git rev-parse --verify "master@{2005-05-26 23:38:00}" >o 2>e &&
 	 test '"$Z"' = $(cat o) &&
 	 test "" = "$(cat e)"'
 test_expect_success \
 	'Query "master@{2005-05-26 23:43:00}" (exact end of history)' \
 	'rm -f o e
-	 git-rev-parse --verify "master@{2005-05-26 23:43:00}" >o 2>e &&
+	 git rev-parse --verify "master@{2005-05-26 23:43:00}" >o 2>e &&
 	 test '"$E"' = $(cat o) &&
 	 test "" = "$(cat e)"'
 test_expect_success \
 	'Query "master@{2005-05-28}" (past end of history)' \
 	'rm -f o e
-	 git-rev-parse --verify "master@{2005-05-28}" >o 2>e &&
+	 git rev-parse --verify "master@{2005-05-28}" >o 2>e &&
 	 test '"$D"' = $(cat o) &&
 	 test "warning: Log .git/logs/'"$m unexpectedly ended on $ld"'." = "$(cat e)"'
 
@@ -188,26 +188,26 @@ rm -f .git/$m .git/logs/$m expect
 test_expect_success \
     'creating initial files' \
     'echo TEST >F &&
-     git-add F &&
+     git add F &&
 	 GIT_AUTHOR_DATE="2005-05-26 23:30" \
 	 GIT_COMMITTER_DATE="2005-05-26 23:30" git-commit -m add -a &&
-	 h_TEST=$(git-rev-parse --verify HEAD)
+	 h_TEST=$(git rev-parse --verify HEAD)
 	 echo The other day this did not work. >M &&
 	 echo And then Bob told me how to fix it. >>M &&
 	 echo OTHER >F &&
 	 GIT_AUTHOR_DATE="2005-05-26 23:41" \
 	 GIT_COMMITTER_DATE="2005-05-26 23:41" git-commit -F M -a &&
-	 h_OTHER=$(git-rev-parse --verify HEAD) &&
+	 h_OTHER=$(git rev-parse --verify HEAD) &&
 	 echo FIXED >F &&
 	 GIT_AUTHOR_DATE="2005-05-26 23:44" \
 	 GIT_COMMITTER_DATE="2005-05-26 23:44" git-commit --amend &&
-	 h_FIXED=$(git-rev-parse --verify HEAD) &&
+	 h_FIXED=$(git rev-parse --verify HEAD) &&
 	 echo TEST+FIXED >F &&
 	 echo Merged initial commit and a later commit. >M &&
 	 echo $h_TEST >.git/MERGE_HEAD &&
 	 GIT_AUTHOR_DATE="2005-05-26 23:45" \
 	 GIT_COMMITTER_DATE="2005-05-26 23:45" git-commit -F M &&
-	 h_MERGED=$(git-rev-parse --verify HEAD)
+	 h_MERGED=$(git rev-parse --verify HEAD)
 	 rm -f M'
 
 cat >expect <<EOF
@@ -222,13 +222,13 @@ test_expect_success \
 unset h_TEST h_OTHER h_FIXED h_MERGED
 
 test_expect_success \
-	'git-cat-file blob master:F (expect OTHER)' \
-	'test OTHER = $(git-cat-file blob master:F)'
+	'git cat-file blob master:F (expect OTHER)' \
+	'test OTHER = $(git cat-file blob master:F)'
 test_expect_success \
-	'git-cat-file blob master@{2005-05-26 23:30}:F (expect TEST)' \
-	'test TEST = $(git-cat-file blob "master@{2005-05-26 23:30}:F")'
+	'git cat-file blob master@{2005-05-26 23:30}:F (expect TEST)' \
+	'test TEST = $(git cat-file blob "master@{2005-05-26 23:30}:F")'
 test_expect_success \
-	'git-cat-file blob master@{2005-05-26 23:42}:F (expect OTHER)' \
-	'test OTHER = $(git-cat-file blob "master@{2005-05-26 23:42}:F")'
+	'git cat-file blob master@{2005-05-26 23:42}:F (expect OTHER)' \
+	'test OTHER = $(git cat-file blob "master@{2005-05-26 23:42}:F")'
 
 test_done
@@ -3,7 +3,7 @@
 # Copyright (c) 2005 Junio C Hamano
 #
 
-test_description='git-checkout-index test.
+test_description='git checkout-index test.
 
 This test registers the following filesystem structure in the
 cache:
@@ -16,7 +16,7 @@ And then tries to checkout in a work tree that has the following:
     path0/file0 - a file in a directory
     path1       - a file
 
-The git-checkout-index command should fail when attempting to checkout
+The git checkout-index command should fail when attempting to checkout
 path0, finding it is occupied by a directory, and path1/file1, finding
 path1 is occupied by a non-directory.  With "-f" flag, it should remove
 the conflicting paths and succeed.
@@ -28,24 +28,24 @@ mkdir path1
 date >path1/file1
 
 test_expect_success \
-    'git-update-index --add various paths.' \
-    'git-update-index --add path0 path1/file1'
+    'git update-index --add various paths.' \
+    'git update-index --add path0 path1/file1'
 
 rm -fr path0 path1
 mkdir path0
 date >path0/file0
 date >path1
 
 test_expect_failure \
-    'git-checkout-index without -f should fail on conflicting work tree.' \
-    'git-checkout-index -a'
+    'git checkout-index without -f should fail on conflicting work tree.' \
+    'git checkout-index -a'
 
 test_expect_success \
-    'git-checkout-index with -f should succeed.' \
-    'git-checkout-index -f -a'
+    'git checkout-index with -f should succeed.' \
+    'git checkout-index -f -a'
 
 test_expect_success \
-    'git-checkout-index conflicting paths.' \
+    'git checkout-index conflicting paths.' \
     'test -f path0 && test -d path1 && test -f path1/file1'
 
 test_done
@@ -3,7 +3,7 @@
 # Copyright (c) 2005 Junio C Hamano
 #
 
-test_description='git-checkout-index test.
+test_description='git checkout-index test.
 
 This test registers the following filesystem structure in the cache:
 
@@ -26,54 +26,54 @@ show_files() {
 	find path? -ls |
 	sed -e 's/^[0-9]* * [0-9]* * \([-bcdl]\)[^ ]* *[0-9]* *[^ ]* *[^ ]* *[0-9]* [A-Z][a-z][a-z] [0-9][0-9] [^ ]* /fs: \1 /'
 	# what's in the cache, just mode and name
-	git-ls-files --stage |
+	git ls-files --stage |
 	sed -e 's/^\([0-9]*\) [0-9a-f]* [0-3] /ca: \1 /'
 	# what's in the tree, just mode and name.
-	git-ls-tree -r "$1" |
+	git ls-tree -r "$1" |
 	sed -e 's/^\([0-9]*\)	[^ ]*	[0-9a-f]*	/tr: \1 /'
 }
 
 mkdir path0
 date >path0/file0
 test_expect_success \
-    'git-update-index --add path0/file0' \
-    'git-update-index --add path0/file0'
+    'git update-index --add path0/file0' \
+    'git update-index --add path0/file0'
 test_expect_success \
-    'writing tree out with git-write-tree' \
-    'tree1=$(git-write-tree)'
+    'writing tree out with git write-tree' \
+    'tree1=$(git write-tree)'
 test_debug 'show_files $tree1'
 
 mkdir path1
 date >path1/file1
 test_expect_success \
-    'git-update-index --add path1/file1' \
-    'git-update-index --add path1/file1'
+    'git update-index --add path1/file1' \
+    'git update-index --add path1/file1'
 test_expect_success \
-    'writing tree out with git-write-tree' \
-    'tree2=$(git-write-tree)'
+    'writing tree out with git write-tree' \
+    'tree2=$(git write-tree)'
 test_debug 'show_files $tree2'
 
 rm -fr path1
 test_expect_success \
     'read previously written tree and checkout.' \
-    'git-read-tree -m $tree1 && git-checkout-index -f -a'
+    'git read-tree -m $tree1 && git checkout-index -f -a'
 test_debug 'show_files $tree1'
 
 ln -s path0 path1
 test_expect_success \
-    'git-update-index --add a symlink.' \
-    'git-update-index --add path1'
+    'git update-index --add a symlink.' \
+    'git update-index --add path1'
 test_expect_success \
-    'writing tree out with git-write-tree' \
-    'tree3=$(git-write-tree)'
+    'writing tree out with git write-tree' \
+    'tree3=$(git write-tree)'
 test_debug 'show_files $tree3'
 
 # Morten says "Got that?" here.
 # Test begins.
 
 test_expect_success \
     'read previously written tree and checkout.' \
-    'git-read-tree $tree2 && git-checkout-index -f -a'
+    'git read-tree $tree2 && git checkout-index -f -a'
 test_debug 'show_files $tree2'
 
 test_expect_success \
@@ -3,31 +3,31 @@
 # Copyright (c) 2005 Junio C Hamano
 #
 
-test_description='git-checkout-index -u test.
+test_description='git checkout-index -u test.
 
-With -u flag, git-checkout-index internally runs the equivalent of
-git-update-index --refresh on the checked out entry.'
+With -u flag, git checkout-index internally runs the equivalent of
+git update-index --refresh on the checked out entry.'
 
 . ./test-lib.sh
 
 test_expect_success \
 'preparation' '
 echo frotz >path0 &&
-git-update-index --add path0 &&
-t=$(git-write-tree)'
+git update-index --add path0 &&
+t=$(git write-tree)'
 
 test_expect_failure \
-'without -u, git-checkout-index smudges stat information.' '
+'without -u, git checkout-index smudges stat information.' '
 rm -f path0 &&
-git-read-tree $t &&
-git-checkout-index -f -a &&
-git-diff-files | diff - /dev/null'
+git read-tree $t &&
+git checkout-index -f -a &&
+git diff-files | diff - /dev/null'
 
 test_expect_success \
-'with -u, git-checkout-index picks up stat information from new files.' '
+'with -u, git checkout-index picks up stat information from new files.' '
 rm -f path0 &&
-git-read-tree $t &&
-git-checkout-index -u -f -a &&
-git-diff-files | diff - /dev/null'
+git read-tree $t &&
+git checkout-index -u -f -a &&
+git diff-files | diff - /dev/null'
 
 test_done
@@ -3,7 +3,7 @@
 # Copyright (c) 2005 Junio C Hamano
 #
 
-test_description='git-checkout-index --prefix test.
+test_description='git checkout-index --prefix test.
 
 This test makes sure that --prefix option works as advertised, and
 also verifies that such leading path may contain symlinks, unlike
@@ -17,22 +17,22 @@ test_expect_success \
     'mkdir path1 &&
     echo frotz >path0 &&
     echo rezrov >path1/file1 &&
-    git-update-index --add path0 path1/file1'
+    git update-index --add path0 path1/file1'
 
 test_expect_success \
     'have symlink in place where dir is expected.' \
     'rm -fr path0 path1 &&
      mkdir path2 &&
      ln -s path2 path1 &&
-     git-checkout-index -f -a &&
+     git checkout-index -f -a &&
      test ! -h path1 && test -d path1 &&
      test -f path1/file1 && test ! -f path2/file1'
 
 test_expect_success \
     'use --prefix=path2/' \
     'rm -fr path0 path1 path2 &&
      mkdir path2 &&
-     git-checkout-index --prefix=path2/ -f -a &&
+     git checkout-index --prefix=path2/ -f -a &&
      test -f path2/path0 &&
      test -f path2/path1/file1 &&
      test ! -f path0 &&
@@ -41,7 +41,7 @@ test_expect_success \
 test_expect_success \
     'use --prefix=tmp-' \
     'rm -fr path0 path1 path2 tmp* &&
-     git-checkout-index --prefix=tmp- -f -a &&
+     git checkout-index --prefix=tmp- -f -a &&
      test -f tmp-path0 &&
      test -f tmp-path1/file1 &&
      test ! -f path0 &&
@@ -52,7 +52,7 @@ test_expect_success \
     'rm -fr path0 path1 path2 tmp* &&
      echo nitfol >tmp-path1 &&
      mkdir tmp-path0 &&
-     git-checkout-index --prefix=tmp- -f -a &&
+     git checkout-index --prefix=tmp- -f -a &&
      test -f tmp-path0 &&
      test -f tmp-path1/file1 &&
      test ! -f path0 &&
@@ -64,7 +64,7 @@ test_expect_success \
     'rm -fr path0 path1 path2 tmp* &&
      mkdir tmp1 tmp1/orary &&
      ln -s tmp1 tmp &&
-     git-checkout-index --prefix=tmp/orary/ -f -a &&
+     git checkout-index --prefix=tmp/orary/ -f -a &&
      test -d tmp1/orary &&
      test -f tmp1/orary/path0 &&
      test -f tmp1/orary/path1/file1 &&
@@ -76,7 +76,7 @@ test_expect_success \
     'rm -fr path0 path1 path2 tmp* &&
      mkdir tmp1 &&
      ln -s tmp1 tmp &&
-     git-checkout-index --prefix=tmp/orary- -f -a &&
+     git checkout-index --prefix=tmp/orary- -f -a &&
      test -f tmp1/orary-path0 &&
      test -f tmp1/orary-path1/file1 &&
      test -h tmp'
@@ -87,7 +87,7 @@ test_expect_success \
     'rm -fr path0 path1 path2 tmp* &&
      mkdir tmp1 &&
      ln -s tmp1 tmp-path1 &&
-     git-checkout-index --prefix=tmp- -f -a &&
+     git checkout-index --prefix=tmp- -f -a &&
      test -f tmp-path0 &&
      test ! -h tmp-path1 &&
      test -d tmp-path1 &&
@@ -3,9 +3,9 @@
 # Copyright (c) 2006 Shawn Pearce
 #
 
-test_description='git-checkout-index --temp test.
+test_description='git checkout-index --temp test.
 
-With --temp flag, git-checkout-index writes to temporary merge files
+With --temp flag, git checkout-index writes to temporary merge files
 rather than the tracked path.'
 
 . ./test-lib.sh
@@ -18,28 +18,28 @@ echo tree1path1 >path1 &&
 echo tree1path3 >path3 &&
 echo tree1path4 >path4 &&
 echo tree1asubdir/path5 >asubdir/path5 &&
-git-update-index --add path0 path1 path3 path4 asubdir/path5 &&
-t1=$(git-write-tree) &&
+git update-index --add path0 path1 path3 path4 asubdir/path5 &&
+t1=$(git write-tree) &&
 rm -f path* .merge_* out .git/index &&
 echo tree2path0 >path0 &&
 echo tree2path1 >path1 &&
 echo tree2path2 >path2 &&
 echo tree2path4 >path4 &&
-git-update-index --add path0 path1 path2 path4 &&
-t2=$(git-write-tree) &&
+git update-index --add path0 path1 path2 path4 &&
+t2=$(git write-tree) &&
 rm -f path* .merge_* out .git/index &&
 echo tree2path0 >path0 &&
 echo tree3path1 >path1 &&
 echo tree3path2 >path2 &&
 echo tree3path3 >path3 &&
-git-update-index --add path0 path1 path2 path3 &&
-t3=$(git-write-tree)'
+git update-index --add path0 path1 path2 path3 &&
+t3=$(git write-tree)'
 
 test_expect_success \
 'checkout one stage 0 to temporary file' '
 rm -f path* .merge_* out .git/index &&
-git-read-tree $t1 &&
-git-checkout-index --temp -- path1 >out &&
+git read-tree $t1 &&
+git checkout-index --temp -- path1 >out &&
 test $(wc -l <out) = 1 &&
 test $(cut "-d	" -f2 out) = path1 &&
 p=$(cut "-d	" -f1 out) &&
@@ -49,8 +49,8 @@ test $(cat $p) = tree1path1'
 test_expect_success \
 'checkout all stage 0 to temporary files' '
 rm -f path* .merge_* out .git/index &&
-git-read-tree $t1 &&
-git-checkout-index -a --temp >out &&
+git read-tree $t1 &&
+git checkout-index -a --temp >out &&
 test $(wc -l <out) = 5 &&
 for f in path0 path1 path3 path4 asubdir/path5
 do
@@ -63,12 +63,12 @@ done'
 test_expect_success \
 'prepare 3-way merge' '
 rm -f path* .merge_* out .git/index &&
-git-read-tree -m $t1 $t2 $t3'
+git read-tree -m $t1 $t2 $t3'
 
 test_expect_success \
 'checkout one stage 2 to temporary file' '
 rm -f path* .merge_* out &&
-git-checkout-index --stage=2 --temp -- path1 >out &&
+git checkout-index --stage=2 --temp -- path1 >out &&
 test $(wc -l <out) = 1 &&
 test $(cut "-d	" -f2 out) = path1 &&
 p=$(cut "-d	" -f1 out) &&
@@ -78,7 +78,7 @@ test $(cat $p) = tree2path1'
 test_expect_success \
 'checkout all stage 2 to temporary files' '
 rm -f path* .merge_* out &&
-git-checkout-index --all --stage=2 --temp >out &&
+git checkout-index --all --stage=2 --temp >out &&
 test $(wc -l <out) = 3 &&
 for f in path1 path2 path4
 do
@@ -91,13 +91,13 @@ done'
 test_expect_success \
 'checkout all stages/one file to nothing' '
 rm -f path* .merge_* out &&
-git-checkout-index --stage=all --temp -- path0 >out &&
+git checkout-index --stage=all --temp -- path0 >out &&
 test $(wc -l <out) = 0'
 
 test_expect_success \
 'checkout all stages/one file to temporary files' '
 rm -f path* .merge_* out &&
-git-checkout-index --stage=all --temp -- path1 >out &&
+git checkout-index --stage=all --temp -- path1 >out &&
 test $(wc -l <out) = 1 &&
 test $(cut "-d	" -f2 out) = path1 &&
 cut "-d	" -f1 out | (read s1 s2 s3 &&
@@ -111,7 +111,7 @@ test $(cat $s3) = tree3path1)'
 test_expect_success \
 'checkout some stages/one file to temporary files' '
 rm -f path* .merge_* out &&
-git-checkout-index --stage=all --temp -- path2 >out &&
+git checkout-index --stage=all --temp -- path2 >out &&
 test $(wc -l <out) = 1 &&
 test $(cut "-d	" -f2 out) = path2 &&
 cut "-d	" -f1 out | (read s1 s2 s3 &&
@@ -124,7 +124,7 @@ test $(cat $s3) = tree3path2)'
 test_expect_success \
 'checkout all stages/all files to temporary files' '
 rm -f path* .merge_* out &&
-git-checkout-index -a --stage=all --temp >out &&
+git checkout-index -a --stage=all --temp >out &&
 test $(wc -l <out) = 5'
 
 test_expect_success \
@@ -184,7 +184,7 @@ test $(cat $s1) = tree1asubdir/path5)'
 test_expect_success \
 'checkout --temp within subdir' '
 (cd asubdir &&
- git-checkout-index -a --stage=all >out &&
+ git checkout-index -a --stage=all >out &&
  test $(wc -l <out) = 1 &&
  test $(grep path5 out | cut "-d	" -f2) = path5 &&
  grep path5 out | cut "-d	" -f1 | (read s1 s2 s3 &&
@@ -198,11 +198,11 @@ test_expect_success \
 'checkout --temp symlink' '
 rm -f path* .merge_* out .git/index &&
 ln -s b a &&
-git-update-index --add a &&
-t4=$(git-write-tree) &&
+git update-index --add a &&
+t4=$(git write-tree) &&
 rm -f .git/index &&
-git-read-tree $t4 &&
-git-checkout-index --temp -a >out &&
+git read-tree $t4 &&
+git checkout-index --temp -a >out &&
 test $(wc -l <out) = 1 &&
 test $(cut "-d	" -f2 out) = a &&
 p=$(cut "-d	" -f1 out) &&
@@ -3,22 +3,22 @@
 # Copyright (c) 2007 Johannes Sixt
 #
 
-test_description='git-checkout-index on filesystem w/o symlinks test.
+test_description='git checkout-index on filesystem w/o symlinks test.
 
-This tests that git-checkout-index creates a symbolic link as a plain
+This tests that git checkout-index creates a symbolic link as a plain
 file if core.symlinks is false.'
 
 . ./test-lib.sh
 
 test_expect_success \
 'preparation' '
-git-config core.symlinks false &&
+git config core.symlinks false &&
 l=$(echo -n file | git-hash-object -t blob -w --stdin) &&
-echo "120000 $l	symlink" | git-update-index --index-info'
+echo "120000 $l	symlink" | git update-index --index-info'
 
 test_expect_success \
 'the checked-out symlink must be a file' '
-git-checkout-index symlink &&
+git checkout-index symlink &&
 test -f symlink'
 
 test_expect_success \
@@ -3,7 +3,7 @@
 # Copyright (c) 2005 Junio C Hamano
 #
 
-test_description='git-update-index nonsense-path test.
+test_description='git update-index nonsense-path test.
 
 This test creates the following structure in the cache:
 
@@ -12,7 +12,7 @@ This test creates the following structure in the cache:
     path2/file2 - a file in a directory
     path3/file3 - a file in a directory
 
-and tries to git-update-index --add the following:
+and tries to git update-index --add the following:
 
     path0/file0 - a file in a directory
     path1/file1 - a file in a directory
@@ -31,8 +31,8 @@ date >path2/file2
 date >path3/file3
 
 test_expect_success \
-    'git-update-index --add to add various paths.' \
-    'git-update-index --add -- path0 path1 path2/file2 path3/file3'
+    'git update-index --add to add various paths.' \
+    'git update-index --add -- path0 path1 path2/file2 path3/file3'
 
 rm -fr path?
 
@@ -45,7 +45,7 @@ date >path1/file1
 for p in path0/file0 path1/file1 path2 path3
 do
 	test_expect_failure \
-	    "git-update-index to add conflicting path $p should fail." \
-	    "git-update-index --add -- $p"
+	    "git update-index to add conflicting path $p should fail." \
+	    "git update-index --add -- $p"
 done
 test_done
@@ -3,7 +3,7 @@
 # Copyright (c) 2006 Junio C Hamano
 #
 
-test_description='git-update-index --again test.
+test_description='git update-index --again test.
 '
 
 . ./test-lib.sh
@@ -15,29 +15,29 @@ EOF
 test_expect_success 'update-index --add' \
 	'echo hello world >file1 &&
 	 echo goodbye people >file2 &&
-	 git-update-index --add file1 file2 &&
-	 git-ls-files -s >current &&
+	 git update-index --add file1 file2 &&
+	 git ls-files -s >current &&
 	 cmp current expected'
 
 test_expect_success 'update-index --again' \
 	'rm -f file1 &&
 	echo hello everybody >file2 &&
-	if git-update-index --again
+	if git update-index --again
 	then
 		echo should have refused to remove file1
 		exit 1
 	else
 		echo happy - failed as expected
 	fi &&
-	 git-ls-files -s >current &&
+	 git ls-files -s >current &&
 	 cmp current expected'
 
 cat > expected <<\EOF
 100644 0f1ae1422c2bf43f117d3dbd715c988a9ed2103f 0	file2
 EOF
 test_expect_success 'update-index --remove --again' \
-	'git-update-index --remove --again &&
-	 git-ls-files -s >current &&
+	'git update-index --remove --again &&
+	 git ls-files -s >current &&
 	 cmp current expected'
 
 test_expect_success 'first commit' 'git-commit -m initial'
@@ -50,11 +50,11 @@ test_expect_success 'update-index again' \
 	'mkdir -p dir1 &&
 	echo hello world >dir1/file3 &&
 	echo goodbye people >file2 &&
-	git-update-index --add file2 dir1/file3 &&
+	git update-index --add file2 dir1/file3 &&
 	echo hello everybody >file2
 	echo happy >dir1/file3 &&
-	git-update-index --again &&
-	git-ls-files -s >current &&
+	git update-index --again &&
+	git ls-files -s >current &&
 	cmp current expected'
 
 cat > expected <<\EOF
@@ -65,9 +65,9 @@ test_expect_success 'update-index --update from subdir' \
 	'echo not so happy >file2 &&
 	cd dir1 &&
 	cat ../file2 >file3 &&
-	git-update-index --again &&
+	git update-index --again &&
 	cd .. &&
-	git-ls-files -s >current &&
+	git ls-files -s >current &&
 	cmp current expected'
 
 cat > expected <<\EOF
@@ -77,8 +77,8 @@ EOF
 test_expect_success 'update-index --update with pathspec' \
 	'echo very happy >file2 &&
 	cat file2 >dir1/file3 &&
-	git-update-index --again dir1/ &&
-	git-ls-files -s >current &&
+	git update-index --again dir1/ &&
+	git ls-files -s >current &&
 	cmp current expected'
 
 test_done
@@ -3,29 +3,29 @@
 # Copyright (c) 2007 Johannes Sixt
 #
 
-test_description='git-update-index on filesystem w/o symlinks test.
+test_description='git update-index on filesystem w/o symlinks test.
 
-This tests that git-update-index keeps the symbolic link property
+This tests that git update-index keeps the symbolic link property
 even if a plain file is in the working tree if core.symlinks is false.'
 
 . ./test-lib.sh
 
 test_expect_success \
 'preparation' '
-git-config core.symlinks false &&
+git config core.symlinks false &&
 l=$(echo -n file | git-hash-object -t blob -w --stdin) &&
-echo "120000 $l	symlink" | git-update-index --index-info'
+echo "120000 $l	symlink" | git update-index --index-info'
 
 test_expect_success \
 'modify the symbolic link' '
 echo -n new-file > symlink &&
-git-update-index symlink'
+git update-index symlink'
 
 test_expect_success \
 'the index entry must still be a symbolic link' '
-case "`git-ls-files --stage --cached symlink`" in
+case "`git ls-files --stage --cached symlink`" in
 120000" "*symlink) echo ok;;
-*) echo fail; git-ls-files --stage --cached symlink; (exit 1);;
+*) echo fail; git ls-files --stage --cached symlink; (exit 1);;
 esac'
 
 test_done
@@ -1,14 +1,14 @@
 #!/bin/sh
 
-test_description='git-add -u with path limiting
+test_description='git add -u with path limiting
 
 This test creates a working tree state with three files:
 
   top (previously committed, modified)
   dir/sub (previously committed, modified)
   dir/other (untracked)
 
-and issues a git-add -u with path limiting on "dir" to add
+and issues a git add -u with path limiting on "dir" to add
 only the updates to dir/sub.'
 
 . ./test-lib.sh
@@ -17,22 +17,22 @@ test_expect_success 'setup' '
 echo initial >top &&
 mkdir dir &&
 echo initial >dir/sub &&
-git-add dir/sub top &&
+git add dir/sub top &&
 git-commit -m initial &&
 echo changed >top &&
 echo changed >dir/sub &&
 echo other >dir/other
 '
 
-test_expect_success 'update' 'git-add -u dir'
+test_expect_success 'update' 'git add -u dir'
 
 test_expect_success 'update touched correct path' \
-  'test "`git-diff-files --name-status dir/sub`" = ""'
+  'test "`git diff-files --name-status dir/sub`" = ""'
 
 test_expect_success 'update did not touch other tracked files' \
-  'test "`git-diff-files --name-status top`" = "M	top"'
+  'test "`git diff-files --name-status top`" = "M	top"'
 
 test_expect_success 'update did not touch untracked files' \
-  'test "`git-diff-files --name-status dir/other`" = ""'
+  'test "`git diff-files --name-status dir/other`" = ""'
 
 test_done
@@ -3,9 +3,9 @@
 # Copyright (c) 2005 Junio C Hamano
 #
 
-test_description='git-ls-files test (--others should pick up symlinks).
+test_description='git ls-files test (--others should pick up symlinks).
 
-This test runs git-ls-files --others with the following on the
+This test runs git ls-files --others with the following on the
 filesystem.
 
     path0       - a file
@@ -23,7 +23,7 @@ date >path2/file2
 date >path2-junk
 date >path3/file3
 date >path3-junk
-git-update-index --add path3-junk path3/file3
+git update-index --add path3-junk path3/file3
 
 cat >expected1 <<EOF
 expected1
@@ -37,20 +37,20 @@ EOF
 sed -e 's|path2/file2|path2/|' <expected1 >expected2
 
 test_expect_success \
-    'git-ls-files --others to show output.' \
-    'git-ls-files --others >output'
+    'git ls-files --others to show output.' \
+    'git ls-files --others >output'
 
 test_expect_success \
-    'git-ls-files --others should pick up symlinks.' \
+    'git ls-files --others should pick up symlinks.' \
     'diff output expected1'
 
 test_expect_success \
-    'git-ls-files --others --directory to show output.' \
-    'git-ls-files --others --directory >output'
+    'git ls-files --others --directory to show output.' \
+    'git ls-files --others --directory >output'
 
 
 test_expect_success \
-    'git-ls-files --others --directory should not get confused.' \
+    'git ls-files --others --directory should not get confused.' \
     'diff output expected2'
 
 test_done
@@ -3,9 +3,9 @@
 # Copyright (c) 2005 Junio C Hamano
 #
 
-test_description='git-ls-files --others --exclude
+test_description='git ls-files --others --exclude
 
-This test runs git-ls-files --others and tests --exclude patterns.
+This test runs git ls-files --others and tests --exclude patterns.
 '
 
 . ./test-lib.sh
@@ -59,8 +59,8 @@ echo '!*.2
 !*.8' >one/two/.gitignore
 
 test_expect_success \
-    'git-ls-files --others with various exclude options.' \
-    'git-ls-files --others \
+    'git ls-files --others with various exclude options.' \
+    'git ls-files --others \
        --exclude=\*.6 \
        --exclude-per-directory=.gitignore \
        --exclude-from=.git/ignore \
@@ -71,8 +71,8 @@ test_expect_success \
 printf '*.1\r\n/*.3\r\n!*.6\r\n' >.gitignore
 
 test_expect_success \
-    'git-ls-files --others with \r\n line endings.' \
-    'git-ls-files --others \
+    'git ls-files --others with \r\n line endings.' \
+    'git ls-files --others \
        --exclude=\*.6 \
        --exclude-per-directory=.gitignore \
        --exclude-from=.git/ignore \
@@ -84,9 +84,9 @@ cat > excludes-file << EOF
 e*
 EOF
 
-git-config core.excludesFile excludes-file
+git config core.excludesFile excludes-file
 
-git-runstatus | grep "^#	" > output
+git runstatus | grep "^#	" > output
 
 cat > expect << EOF
 #	.gitignore
@@ -3,9 +3,9 @@
 # Copyright (c) 2005 Junio C Hamano
 #
 
-test_description='git-ls-files test (-- to terminate the path list).
+test_description='git ls-files test (-- to terminate the path list).
 
-This test runs git-ls-files --others with the following on the
+This test runs git ls-files --others with the following on the
 filesystem.
 
     path0       - a file
@@ -21,8 +21,8 @@ test_expect_success \
 	echo frotz >./--'
 
 test_expect_success \
-    'git-ls-files without path restriction.' \
-    'git-ls-files --others >output &&
+    'git ls-files without path restriction.' \
+    'git ls-files --others >output &&
      git diff output - <<EOF
 --
 -foo
@@ -32,32 +32,32 @@ EOF
 '
 
 test_expect_success \
-    'git-ls-files with path restriction.' \
-    'git-ls-files --others path0 >output &&
+    'git ls-files with path restriction.' \
+    'git ls-files --others path0 >output &&
 	git diff output - <<EOF
 path0
 EOF
 '
 
 test_expect_success \
-    'git-ls-files with path restriction with --.' \
-    'git-ls-files --others -- path0 >output &&
+    'git ls-files with path restriction with --.' \
+    'git ls-files --others -- path0 >output &&
 	git diff output - <<EOF
 path0
 EOF
 '
 
 test_expect_success \
-    'git-ls-files with path restriction with -- --.' \
-    'git-ls-files --others -- -- >output &&
+    'git ls-files with path restriction with -- --.' \
+    'git ls-files --others -- -- >output &&
 	git diff output - <<EOF
 --
 EOF
 '
 
 test_expect_success \
-    'git-ls-files with no path restriction.' \
-    'git-ls-files --others -- >output &&
+    'git ls-files with no path restriction.' \
+    'git ls-files --others -- >output &&
 	git diff output - <<EOF
 --
 -foo
@@ -3,7 +3,7 @@
 # Copyright (c) 2005 Junio C Hamano
 #
 
-test_description='git-ls-files -k and -m flags test.
+test_description='git ls-files -k and -m flags test.
 
 This test prepares the following in the cache:
 
@@ -22,7 +22,7 @@ and the following on the filesystem:
     path5	- a symlink
     path6/file6 - a file in a directory
 
-git-ls-files -k should report that existing filesystem
+git ls-files -k should report that existing filesystem
 objects except path4, path5 and path6/file6 to be killed.
 
 Also for modification test, the cache and working tree have:
@@ -47,8 +47,8 @@ date >path8
 : >path9
 date >path10
 test_expect_success \
-    'git-update-index --add to add various paths.' \
-    "git-update-index --add -- path0 path1 path?/file? path7 path8 path9 path10"
+    'git update-index --add to add various paths.' \
+    "git update-index --add -- path0 path1 path?/file? path7 path8 path9 path10"
 
 rm -fr path? ;# leave path10 alone
 date >path2
@@ -64,8 +64,8 @@ date >path7
 touch path10
 
 test_expect_success \
-    'git-ls-files -k to show killed files.' \
-    'git-ls-files -k >.output'
+    'git ls-files -k to show killed files.' \
+    'git ls-files -k >.output'
 cat >.expected <<EOF
 path0/file0
 path1/file1
@@ -74,12 +74,12 @@ path3
 EOF
 
 test_expect_success \
-    'validate git-ls-files -k output.' \
+    'validate git ls-files -k output.' \
     'diff .output .expected'
 
 test_expect_success \
-    'git-ls-files -m to show modified files.' \
-    'git-ls-files -m >.output'
+    'git ls-files -m to show modified files.' \
+    'git ls-files -m >.output'
 cat >.expected <<EOF
 path0
 path1
@@ -90,7 +90,7 @@ path8
 EOF
 
 test_expect_success \
-    'validate git-ls-files -m output.' \
+    'validate git ls-files -m output.' \
     'diff .output .expected'
 
 test_done
@@ -3,25 +3,25 @@
 # Copyright (c) 2006 Carl D. Worth
 #
 
-test_description='git-ls-files test for --error-unmatch option
+test_description='git ls-files test for --error-unmatch option
 
-This test runs git-ls-files --error-unmatch to ensure it correctly
+This test runs git ls-files --error-unmatch to ensure it correctly
 returns an error when a non-existent path is provided on the command
 line.
 '
 . ./test-lib.sh
 
 touch foo bar
-git-update-index --add foo bar
+git update-index --add foo bar
 git-commit -m "add foo bar"
 
 test_expect_failure \
-    'git-ls-files --error-unmatch should fail with unmatched path.' \
-    'git-ls-files --error-unmatch foo bar-does-not-match'
+    'git ls-files --error-unmatch should fail with unmatched path.' \
+    'git ls-files --error-unmatch foo bar-does-not-match'
 
 test_expect_success \
-    'git-ls-files --error-unmatch should succeed eith matched paths.' \
-    'git-ls-files --error-unmatch foo bar'
+    'git ls-files --error-unmatch should succeed eith matched paths.' \
+    'git ls-files --error-unmatch foo bar'
 
 test_done
 1
@@ -3,9 +3,9 @@
 # Copyright (c) 2005 Junio C Hamano
 #
 
-test_description='git-ls-tree test.
+test_description='git ls-tree test.
 
-This test runs git-ls-tree with the following in a tree.
+This test runs git ls-tree with the following in a tree.
 
     path0       - a file
     path1	- a symlink
@@ -27,8 +27,8 @@ test_expect_success \
      ln -s ../path1 path2/bazbo &&
      echo Mi >path2/baz/b &&
      find path? \( -type f -o -type l \) -print |
-     xargs git-update-index --add &&
-     tree=`git-write-tree` &&
+     xargs git update-index --add &&
+     tree=`git write-tree` &&
      echo $tree'
 
 _x40='[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f]'
@@ -40,7 +40,7 @@ test_output () {
 
 test_expect_success \
     'ls-tree plain' \
-    'git-ls-tree $tree >current &&
+    'git ls-tree $tree >current &&
      cat >expected <<\EOF &&
 100644 blob X	path0
 120000 blob X	path1
@@ -50,7 +50,7 @@ EOF
 
 test_expect_success \
     'ls-tree recursive' \
-    'git-ls-tree -r $tree >current &&
+    'git ls-tree -r $tree >current &&
      cat >expected <<\EOF &&
 100644 blob X	path0
 120000 blob X	path1
@@ -62,7 +62,7 @@ EOF
 
 test_expect_success \
     'ls-tree recursive with -t' \
-    'git-ls-tree -r -t $tree >current &&
+    'git ls-tree -r -t $tree >current &&
      cat >expected <<\EOF &&
 100644 blob X	path0
 120000 blob X	path1
@@ -76,7 +76,7 @@ EOF
 
 test_expect_success \
     'ls-tree recursive with -d' \
-    'git-ls-tree -r -d $tree >current &&
+    'git ls-tree -r -d $tree >current &&
      cat >expected <<\EOF &&
 040000 tree X	path2
 040000 tree X	path2/baz
@@ -85,7 +85,7 @@ EOF
 
 test_expect_success \
     'ls-tree filtered with path' \
-    'git-ls-tree $tree path >current &&
+    'git ls-tree $tree path >current &&
      cat >expected <<\EOF &&
 EOF
      test_output'
@@ -95,7 +95,7 @@ EOF
 # they are shown in canonical order.
 test_expect_success \
     'ls-tree filtered with path1 path0' \
-    'git-ls-tree $tree path1 path0 >current &&
+    'git ls-tree $tree path1 path0 >current &&
      cat >expected <<\EOF &&
 100644 blob X	path0
 120000 blob X	path1
@@ -104,7 +104,7 @@ EOF
 
 test_expect_success \
     'ls-tree filtered with path0/' \
-    'git-ls-tree $tree path0/ >current &&
+    'git ls-tree $tree path0/ >current &&
      cat >expected <<\EOF &&
 EOF
      test_output'
@@ -113,7 +113,7 @@ EOF
 # with pathspec semantics it shows only path2
 test_expect_success \
     'ls-tree filtered with path2' \
-    'git-ls-tree $tree path2 >current &&
+    'git ls-tree $tree path2 >current &&
      cat >expected <<\EOF &&
 040000 tree X	path2
 EOF
@@ -122,7 +122,7 @@ EOF
 # ... and path2/ shows the children.
 test_expect_success \
     'ls-tree filtered with path2/' \
-    'git-ls-tree $tree path2/ >current &&
+    'git ls-tree $tree path2/ >current &&
      cat >expected <<\EOF &&
 040000 tree X	path2/baz
 120000 blob X	path2/bazbo
@@ -134,22 +134,22 @@ EOF
 # path2/baz
 test_expect_success \
     'ls-tree filtered with path2/baz' \
-    'git-ls-tree $tree path2/baz >current &&
+    'git ls-tree $tree path2/baz >current &&
      cat >expected <<\EOF &&
 040000 tree X	path2/baz
 EOF
      test_output'
 
 test_expect_success \
     'ls-tree filtered with path2/bak' \
-    'git-ls-tree $tree path2/bak >current &&
+    'git ls-tree $tree path2/bak >current &&
      cat >expected <<\EOF &&
 EOF
      test_output'
 
 test_expect_success \
     'ls-tree -t filtered with path2/bak' \
-    'git-ls-tree -t $tree path2/bak >current &&
+    'git ls-tree -t $tree path2/bak >current &&
      cat >expected <<\EOF &&
 040000 tree X	path2
 EOF
@@ -4,9 +4,9 @@
 # Copyright (c) 2005 Robert Fitzsimons
 #
 
-test_description='git-ls-tree directory and filenames handling.
+test_description='git ls-tree directory and filenames handling.
 
-This test runs git-ls-tree with the following in a tree.
+This test runs git ls-tree with the following in a tree.
 
     1.txt              - a file
     2.txt              - a file
@@ -35,8 +35,8 @@ test_expect_success \
      echo 111 >path3/1.txt &&
      echo 222 >path3/2.txt &&
      find *.txt path* \( -type f -o -type l \) -print |
-     xargs git-update-index --add &&
-     tree=`git-write-tree` &&
+     xargs git update-index --add &&
+     tree=`git write-tree` &&
      echo $tree'
 
 _x40='[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f]'
@@ -48,7 +48,7 @@ test_output () {
 
 test_expect_success \
     'ls-tree plain' \
-    'git-ls-tree $tree >current &&
+    'git ls-tree $tree >current &&
      cat >expected <<\EOF &&
 100644 blob X	1.txt
 100644 blob X	2.txt
@@ -62,7 +62,7 @@ EOF
 # Recursive does not show tree nodes anymore...
 test_expect_success \
     'ls-tree recursive' \
-    'git-ls-tree -r $tree >current &&
+    'git ls-tree -r $tree >current &&
      cat >expected <<\EOF &&
 100644 blob X	1.txt
 100644 blob X	2.txt
@@ -76,23 +76,23 @@ EOF
 
 test_expect_success \
     'ls-tree filter 1.txt' \
-    'git-ls-tree $tree 1.txt >current &&
+    'git ls-tree $tree 1.txt >current &&
      cat >expected <<\EOF &&
 100644 blob X	1.txt
 EOF
      test_output'
 
 test_expect_success \
     'ls-tree filter path1/b/c/1.txt' \
-    'git-ls-tree $tree path1/b/c/1.txt >current &&
+    'git ls-tree $tree path1/b/c/1.txt >current &&
      cat >expected <<\EOF &&
 100644 blob X	path1/b/c/1.txt
 EOF
      test_output'
 
 test_expect_success \
     'ls-tree filter all 1.txt files' \
-    'git-ls-tree $tree 1.txt path0/a/b/c/1.txt path1/b/c/1.txt path2/1.txt path3/1.txt >current &&
+    'git ls-tree $tree 1.txt path0/a/b/c/1.txt path1/b/c/1.txt path2/1.txt path3/1.txt >current &&
      cat >expected <<\EOF &&
 100644 blob X	1.txt
 100644 blob X	path0/a/b/c/1.txt
@@ -107,7 +107,7 @@ EOF
 # it behaves as if path0/a/b/c, path1/b/c, path2 and path3 are specified.
 test_expect_success \
     'ls-tree filter directories' \
-    'git-ls-tree $tree path3 path2 path0/a/b/c path1/b/c path0/a >current &&
+    'git ls-tree $tree path3 path2 path0/a/b/c path1/b/c path0/a >current &&
      cat >expected <<\EOF &&
 040000 tree X	path0/a/b/c
 040000 tree X	path1/b/c
@@ -120,7 +120,7 @@ EOF
 # having 1.txt and path3
 test_expect_success \
     'ls-tree filter odd names' \
-    'git-ls-tree $tree 1.txt /1.txt //1.txt path3/1.txt /path3/1.txt //path3//1.txt path3 /path3/ path3// >current &&
+    'git ls-tree $tree 1.txt /1.txt //1.txt path3/1.txt /path3/1.txt //path3//1.txt path3 /path3/ path3// >current &&
      cat >expected <<\EOF &&
 100644 blob X	1.txt
 100644 blob X	path3/1.txt
@@ -130,7 +130,7 @@ EOF
 
 test_expect_success \
     'ls-tree filter missing files and extra slashes' \
-    'git-ls-tree $tree 1.txt/ abc.txt path3//23.txt path3/2.txt/// >current &&
+    'git ls-tree $tree 1.txt/ abc.txt path3//23.txt path3/2.txt/// >current &&
      cat >expected <<\EOF &&
 EOF
      test_output'
@@ -13,172 +13,172 @@ handled.  Specifically, that a bogus branch is not created.
 test_expect_success \
     'prepare a trivial repository' \
     'echo Hello > A &&
-     git-update-index --add A &&
+     git update-index --add A &&
      git-commit -m "Initial commit." &&
-     HEAD=$(git-rev-parse --verify HEAD)'
+     HEAD=$(git rev-parse --verify HEAD)'
 
 test_expect_failure \
     'git branch --help should not have created a bogus branch' \
-    'git-branch --help </dev/null >/dev/null 2>/dev/null || :
+    'git branch --help </dev/null >/dev/null 2>/dev/null || :
      test -f .git/refs/heads/--help'
 
 test_expect_success \
     'git branch abc should create a branch' \
-    'git-branch abc && test -f .git/refs/heads/abc'
+    'git branch abc && test -f .git/refs/heads/abc'
 
 test_expect_success \
     'git branch a/b/c should create a branch' \
-    'git-branch a/b/c && test -f .git/refs/heads/a/b/c'
+    'git branch a/b/c && test -f .git/refs/heads/a/b/c'
 
 cat >expect <<EOF
 0000000000000000000000000000000000000000 $HEAD $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> 1117150200 +0000	branch: Created from master
 EOF
 test_expect_success \
     'git branch -l d/e/f should create a branch and a log' \
 	'GIT_COMMITTER_DATE="2005-05-26 23:30" \
-     git-branch -l d/e/f &&
+     git branch -l d/e/f &&
 	 test -f .git/refs/heads/d/e/f &&
 	 test -f .git/logs/refs/heads/d/e/f &&
 	 diff expect .git/logs/refs/heads/d/e/f'
 
 test_expect_success \
     'git branch -d d/e/f should delete a branch and a log' \
-	'git-branch -d d/e/f &&
+	'git branch -d d/e/f &&
 	 test ! -f .git/refs/heads/d/e/f &&
 	 test ! -f .git/logs/refs/heads/d/e/f'
 
 test_expect_success \
     'git branch j/k should work after branch j has been deleted' \
-       'git-branch j &&
-        git-branch -d j &&
-        git-branch j/k'
+       'git branch j &&
+        git branch -d j &&
+        git branch j/k'
 
 test_expect_success \
     'git branch l should work after branch l/m has been deleted' \
-       'git-branch l/m &&
-        git-branch -d l/m &&
-        git-branch l'
+       'git branch l/m &&
+        git branch -d l/m &&
+        git branch l'
 
 test_expect_success \
     'git branch -m m m/m should work' \
-       'git-branch -l m &&
-        git-branch -m m m/m &&
+       'git branch -l m &&
+        git branch -m m m/m &&
         test -f .git/logs/refs/heads/m/m'
 
 test_expect_success \
     'git branch -m n/n n should work' \
-       'git-branch -l n/n &&
-        git-branch -m n/n n
+       'git branch -l n/n &&
+        git branch -m n/n n
         test -f .git/logs/refs/heads/n'
 
 test_expect_failure \
     'git branch -m o/o o should fail when o/p exists' \
-       'git-branch o/o &&
-        git-branch o/p &&
-        git-branch -m o/o o'
+       'git branch o/o &&
+        git branch o/p &&
+        git branch -m o/o o'
 
 test_expect_failure \
     'git branch -m q r/q should fail when r exists' \
-       'git-branch q &&
-         git-branch r &&
-         git-branch -m q r/q'
+       'git branch q &&
+         git branch r &&
+         git branch -m q r/q'
 
 mv .git/config .git/config-saved
 
 test_expect_success 'git branch -m q q2 without config should succeed' '
-	git-branch -m q q2 &&
-	git-branch -m q2 q
+	git branch -m q q2 &&
+	git branch -m q2 q
 '
 
 mv .git/config-saved .git/config
 
-git-config branch.s/s.dummy Hello
+git config branch.s/s.dummy Hello
 
 test_expect_success \
     'git branch -m s/s s should work when s/t is deleted' \
-       'git-branch -l s/s &&
+       'git branch -l s/s &&
         test -f .git/logs/refs/heads/s/s &&
-        git-branch -l s/t &&
+        git branch -l s/t &&
         test -f .git/logs/refs/heads/s/t &&
-        git-branch -d s/t &&
-        git-branch -m s/s s &&
+        git branch -d s/t &&
+        git branch -m s/s s &&
         test -f .git/logs/refs/heads/s'
 
 test_expect_success 'config information was renamed, too' \
-	"test $(git-config branch.s.dummy) = Hello &&
-	 ! git-config branch.s/s/dummy"
+	"test $(git config branch.s.dummy) = Hello &&
+	 ! git config branch.s/s/dummy"
 
 test_expect_failure \
-    'git-branch -m u v should fail when the reflog for u is a symlink' \
-    'git-branch -l u &&
+    'git branch -m u v should fail when the reflog for u is a symlink' \
+    'git branch -l u &&
      mv .git/logs/refs/heads/u real-u &&
      ln -s real-u .git/logs/refs/heads/u &&
-     git-branch -m u v'
+     git branch -m u v'
 
 test_expect_success 'test tracking setup via --track' \
-    'git-config remote.local.url . &&
-     git-config remote.local.fetch refs/heads/*:refs/remotes/local/* &&
-     (git-show-ref -q refs/remotes/local/master || git-fetch local) &&
-     git-branch --track my1 local/master &&
-     test $(git-config branch.my1.remote) = local &&
-     test $(git-config branch.my1.merge) = refs/heads/master'
+    'git config remote.local.url . &&
+     git config remote.local.fetch refs/heads/*:refs/remotes/local/* &&
+     (git show-ref -q refs/remotes/local/master || git-fetch local) &&
+     git branch --track my1 local/master &&
+     test $(git config branch.my1.remote) = local &&
+     test $(git config branch.my1.merge) = refs/heads/master'
 
 test_expect_success 'test tracking setup (non-wildcard, matching)' \
-    'git-config remote.local.url . &&
-     git-config remote.local.fetch refs/heads/master:refs/remotes/local/master &&
-     (git-show-ref -q refs/remotes/local/master || git-fetch local) &&
-     git-branch --track my4 local/master &&
-     test $(git-config branch.my4.remote) = local &&
-     test $(git-config branch.my4.merge) = refs/heads/master'
+    'git config remote.local.url . &&
+     git config remote.local.fetch refs/heads/master:refs/remotes/local/master &&
+     (git show-ref -q refs/remotes/local/master || git-fetch local) &&
+     git branch --track my4 local/master &&
+     test $(git config branch.my4.remote) = local &&
+     test $(git config branch.my4.merge) = refs/heads/master'
 
 test_expect_success 'test tracking setup (non-wildcard, not matching)' \
-    'git-config remote.local.url . &&
-     git-config remote.local.fetch refs/heads/s:refs/remotes/local/s &&
-     (git-show-ref -q refs/remotes/local/master || git-fetch local) &&
-     git-branch --track my5 local/master &&
-     ! test "$(git-config branch.my5.remote)" = local &&
-     ! test "$(git-config branch.my5.merge)" = refs/heads/master'
+    'git config remote.local.url . &&
+     git config remote.local.fetch refs/heads/s:refs/remotes/local/s &&
+     (git show-ref -q refs/remotes/local/master || git-fetch local) &&
+     git branch --track my5 local/master &&
+     ! test "$(git config branch.my5.remote)" = local &&
+     ! test "$(git config branch.my5.merge)" = refs/heads/master'
 
 test_expect_success 'test tracking setup via config' \
-    'git-config branch.autosetupmerge true &&
-     git-config remote.local.url . &&
-     git-config remote.local.fetch refs/heads/*:refs/remotes/local/* &&
-     (git-show-ref -q refs/remotes/local/master || git-fetch local) &&
-     git-branch my3 local/master &&
-     test $(git-config branch.my3.remote) = local &&
-     test $(git-config branch.my3.merge) = refs/heads/master'
+    'git config branch.autosetupmerge true &&
+     git config remote.local.url . &&
+     git config remote.local.fetch refs/heads/*:refs/remotes/local/* &&
+     (git show-ref -q refs/remotes/local/master || git-fetch local) &&
+     git branch my3 local/master &&
+     test $(git config branch.my3.remote) = local &&
+     test $(git config branch.my3.merge) = refs/heads/master'
 
 test_expect_success 'test overriding tracking setup via --no-track' \
-    'git-config branch.autosetupmerge true &&
-     git-config remote.local.url . &&
-     git-config remote.local.fetch refs/heads/*:refs/remotes/local/* &&
-     (git-show-ref -q refs/remotes/local/master || git-fetch local) &&
-     git-branch --no-track my2 local/master &&
-     git-config branch.autosetupmerge false &&
-     ! test "$(git-config branch.my2.remote)" = local &&
-     ! test "$(git-config branch.my2.merge)" = refs/heads/master'
+    'git config branch.autosetupmerge true &&
+     git config remote.local.url . &&
+     git config remote.local.fetch refs/heads/*:refs/remotes/local/* &&
+     (git show-ref -q refs/remotes/local/master || git-fetch local) &&
+     git branch --no-track my2 local/master &&
+     git config branch.autosetupmerge false &&
+     ! test "$(git config branch.my2.remote)" = local &&
+     ! test "$(git config branch.my2.merge)" = refs/heads/master'
 
 test_expect_success 'test local tracking setup' \
     'git branch --track my6 s &&
-     test $(git-config branch.my6.remote) = . &&
-     test $(git-config branch.my6.merge) = refs/heads/s'
+     test $(git config branch.my6.remote) = . &&
+     test $(git config branch.my6.merge) = refs/heads/s'
 
 test_expect_success 'test tracking setup via --track but deeper' \
-    'git-config remote.local.url . &&
-     git-config remote.local.fetch refs/heads/*:refs/remotes/local/* &&
-     (git-show-ref -q refs/remotes/local/o/o || git-fetch local) &&
-     git-branch --track my7 local/o/o &&
-     test "$(git-config branch.my7.remote)" = local &&
-     test "$(git-config branch.my7.merge)" = refs/heads/o/o'
+    'git config remote.local.url . &&
+     git config remote.local.fetch refs/heads/*:refs/remotes/local/* &&
+     (git show-ref -q refs/remotes/local/o/o || git-fetch local) &&
+     git branch --track my7 local/o/o &&
+     test "$(git config branch.my7.remote)" = local &&
+     test "$(git config branch.my7.merge)" = refs/heads/o/o'
 
 test_expect_success 'test deleting branch deletes branch config' \
-    'git-branch -d my7 &&
-     test "$(git-config branch.my7.remote)" = "" &&
-     test "$(git-config branch.my7.merge)" = ""'
+    'git branch -d my7 &&
+     test "$(git config branch.my7.remote)" = "" &&
+     test "$(git config branch.my7.merge)" = ""'
 
 test_expect_success 'test deleting branch without config' \
-    'git-branch my7 s &&
-     test "$(git-branch -d my7 2>&1)" = "Deleted branch my7."'
+    'git branch my7 s &&
+     test "$(git branch -d my7 2>&1)" = "Deleted branch my7."'
 
 # Keep this test last, as it changes the current branch
 cat >expect <<EOF
@@ -16,92 +16,92 @@ echo '[core] logallrefupdates = true' >>.git/config
 test_expect_success \
     'prepare a trivial repository' \
     'echo Hello > A &&
-     git-update-index --add A &&
+     git update-index --add A &&
      git-commit -m "Initial commit." &&
-     HEAD=$(git-rev-parse --verify HEAD)'
+     HEAD=$(git rev-parse --verify HEAD)'
 
 SHA1=
 
 test_expect_success \
     'see if git show-ref works as expected' \
-    'git-branch a &&
+    'git branch a &&
      SHA1=`cat .git/refs/heads/a` &&
      echo "$SHA1 refs/heads/a" >expect &&
-     git-show-ref a >result &&
+     git show-ref a >result &&
      diff expect result'
 
 test_expect_success \
     'see if a branch still exists when packed' \
-    'git-branch b &&
-     git-pack-refs --all &&
+    'git branch b &&
+     git pack-refs --all &&
      rm -f .git/refs/heads/b &&
      echo "$SHA1 refs/heads/b" >expect &&
-     git-show-ref b >result &&
+     git show-ref b >result &&
      diff expect result'
 
 test_expect_failure \
     'git branch c/d should barf if branch c exists' \
-    'git-branch c &&
-     git-pack-refs --all &&
+    'git branch c &&
+     git pack-refs --all &&
      rm .git/refs/heads/c &&
-     git-branch c/d'
+     git branch c/d'
 
 test_expect_success \
     'see if a branch still exists after git pack-refs --prune' \
-    'git-branch e &&
-     git-pack-refs --all --prune &&
+    'git branch e &&
+     git pack-refs --all --prune &&
      echo "$SHA1 refs/heads/e" >expect &&
-     git-show-ref e >result &&
+     git show-ref e >result &&
      diff expect result'
 
 test_expect_failure \
     'see if git pack-refs --prune remove ref files' \
-    'git-branch f &&
-     git-pack-refs --all --prune &&
+    'git branch f &&
+     git pack-refs --all --prune &&
      ls .git/refs/heads/f'
 
 test_expect_success \
     'git branch g should work when git branch g/h has been deleted' \
-    'git-branch g/h &&
-     git-pack-refs --all --prune &&
-     git-branch -d g/h &&
-     git-branch g &&
-     git-pack-refs --all &&
-     git-branch -d g'
+    'git branch g/h &&
+     git pack-refs --all --prune &&
+     git branch -d g/h &&
+     git branch g &&
+     git pack-refs --all &&
+     git branch -d g'
 
 test_expect_failure \
     'git branch i/j/k should barf if branch i exists' \
-    'git-branch i &&
-     git-pack-refs --all --prune &&
-     git-branch i/j/k'
+    'git branch i &&
+     git pack-refs --all --prune &&
+     git branch i/j/k'
 
 test_expect_success \
     'test git branch k after branch k/l/m and k/lm have been deleted' \
-    'git-branch k/l &&
-     git-branch k/lm &&
-     git-branch -d k/l &&
-     git-branch k/l/m &&
-     git-branch -d k/l/m &&
-     git-branch -d k/lm &&
-     git-branch k'
+    'git branch k/l &&
+     git branch k/lm &&
+     git branch -d k/l &&
+     git branch k/l/m &&
+     git branch -d k/l/m &&
+     git branch -d k/lm &&
+     git branch k'
 
 test_expect_success \
     'test git branch n after some branch deletion and pruning' \
-    'git-branch n/o &&
-     git-branch n/op &&
-     git-branch -d n/o &&
-     git-branch n/o/p &&
-     git-branch -d n/op &&
-     git-pack-refs --all --prune &&
-     git-branch -d n/o/p &&
-     git-branch n'
+    'git branch n/o &&
+     git branch n/op &&
+     git branch -d n/o &&
+     git branch n/o/p &&
+     git branch -d n/op &&
+     git pack-refs --all --prune &&
+     git branch -d n/o/p &&
+     git branch n'
 
 test_expect_success 'pack, prune and repack' '
 	git-tag foo &&
-	git-pack-refs --all --prune &&
-	git-show-ref >all-of-them &&
-	git-pack-refs &&
-	git-show-ref >again &&
+	git pack-refs --all --prune &&
+	git show-ref >all-of-them &&
+	git pack-refs &&
+	git show-ref >again &&
 	diff all-of-them again
 '
 
@@ -32,78 +32,78 @@ test -f "$p1" && cmp "$p0" "$p1" || {
 
 echo 'just space
 no-funny' >expected
-test_expect_success 'git-ls-files no-funny' \
-	'git-update-index --add "$p0" "$p2" &&
-	git-ls-files >current &&
+test_expect_success 'git ls-files no-funny' \
+	'git update-index --add "$p0" "$p2" &&
+	git ls-files >current &&
 	git diff expected current'
 
-t0=`git-write-tree`
+t0=`git write-tree`
 echo "$t0" >t0
 
 cat > expected <<\EOF
 just space
 no-funny
 "tabs\t,\" (dq) and spaces"
 EOF
-test_expect_success 'git-ls-files with-funny' \
-	'git-update-index --add "$p1" &&
-	git-ls-files >current &&
+test_expect_success 'git ls-files with-funny' \
+	'git update-index --add "$p1" &&
+	git ls-files >current &&
 	git diff expected current'
 
 echo 'just space
 no-funny
 tabs	," (dq) and spaces' >expected
-test_expect_success 'git-ls-files -z with-funny' \
-	'git-ls-files -z | tr \\0 \\012 >current &&
+test_expect_success 'git ls-files -z with-funny' \
+	'git ls-files -z | tr \\0 \\012 >current &&
 	git diff expected current'
 
-t1=`git-write-tree`
+t1=`git write-tree`
 echo "$t1" >t1
 
 cat > expected <<\EOF
 just space
 no-funny
 "tabs\t,\" (dq) and spaces"
 EOF
-test_expect_success 'git-ls-tree with funny' \
-	'git-ls-tree -r $t1 | sed -e "s/^[^	]*	//" >current &&
+test_expect_success 'git ls-tree with funny' \
+	'git ls-tree -r $t1 | sed -e "s/^[^	]*	//" >current &&
 	 git diff expected current'
 
 cat > expected <<\EOF
 A	"tabs\t,\" (dq) and spaces"
 EOF
-test_expect_success 'git-diff-index with-funny' \
-	'git-diff-index --name-status $t0 >current &&
+test_expect_success 'git diff-index with-funny' \
+	'git diff-index --name-status $t0 >current &&
 	git diff expected current'
 
-test_expect_success 'git-diff-tree with-funny' \
-	'git-diff-tree --name-status $t0 $t1 >current &&
+test_expect_success 'git diff-tree with-funny' \
+	'git diff-tree --name-status $t0 $t1 >current &&
 	git diff expected current'
 
 echo 'A
 tabs	," (dq) and spaces' >expected
-test_expect_success 'git-diff-index -z with-funny' \
-	'git-diff-index -z --name-status $t0 | tr \\0 \\012 >current &&
+test_expect_success 'git diff-index -z with-funny' \
+	'git diff-index -z --name-status $t0 | tr \\0 \\012 >current &&
 	git diff expected current'
 
-test_expect_success 'git-diff-tree -z with-funny' \
-	'git-diff-tree -z --name-status $t0 $t1 | tr \\0 \\012 >current &&
+test_expect_success 'git diff-tree -z with-funny' \
+	'git diff-tree -z --name-status $t0 $t1 | tr \\0 \\012 >current &&
 	git diff expected current'
 
 cat > expected <<\EOF
 CNUM	no-funny	"tabs\t,\" (dq) and spaces"
 EOF
-test_expect_success 'git-diff-tree -C with-funny' \
-	'git-diff-tree -C --find-copies-harder --name-status \
+test_expect_success 'git diff-tree -C with-funny' \
+	'git diff-tree -C --find-copies-harder --name-status \
 		$t0 $t1 | sed -e 's/^C[0-9]*/CNUM/' >current &&
 	git diff expected current'
 
 cat > expected <<\EOF
 RNUM	no-funny	"tabs\t,\" (dq) and spaces"
 EOF
-test_expect_success 'git-diff-tree delete with-funny' \
-	'git-update-index --force-remove "$p0" &&
-	git-diff-index -M --name-status \
+test_expect_success 'git diff-tree delete with-funny' \
+	'git update-index --force-remove "$p0" &&
+	git diff-index -M --name-status \
 		$t0 | sed -e 's/^R[0-9]*/RNUM/' >current &&
 	git diff expected current'
 
@@ -113,8 +113,8 @@ similarity index NUM%
 rename from no-funny
 rename to "tabs\t,\" (dq) and spaces"
 EOF
-test_expect_success 'git-diff-tree delete with-funny' \
-	'git-diff-index -M -p $t0 |
+test_expect_success 'git diff-tree delete with-funny' \
+	'git diff-index -M -p $t0 |
 	 sed -e "s/index [0-9]*%/index NUM%/" >current &&
 	 git diff expected current'
 
@@ -127,34 +127,34 @@ similarity index NUM%
 rename from no-funny
 rename to "tabs\t,\" (dq) and spaces"
 EOF
-test_expect_success 'git-diff-tree delete with-funny' \
-	'git-diff-index -M -p $t0 |
+test_expect_success 'git diff-tree delete with-funny' \
+	'git diff-index -M -p $t0 |
 	 sed -e "s/index [0-9]*%/index NUM%/" >current &&
 	 git diff expected current'
 
 cat >expected <<\EOF
  "tabs\t,\" (dq) and spaces"
  1 files changed, 0 insertions(+), 0 deletions(-)
 EOF
-test_expect_success 'git-diff-tree rename with-funny applied' \
-	'git-diff-index -M -p $t0 |
-	 git-apply --stat | sed -e "s/|.*//" -e "s/ *\$//" >current &&
+test_expect_success 'git diff-tree rename with-funny applied' \
+	'git diff-index -M -p $t0 |
+	 git apply --stat | sed -e "s/|.*//" -e "s/ *\$//" >current &&
 	 git diff expected current'
 
 cat > expected <<\EOF
  no-funny
  "tabs\t,\" (dq) and spaces"
  2 files changed, 3 insertions(+), 3 deletions(-)
 EOF
-test_expect_success 'git-diff-tree delete with-funny applied' \
-	'git-diff-index -p $t0 |
-	 git-apply --stat | sed -e "s/|.*//" -e "s/ *\$//" >current &&
+test_expect_success 'git diff-tree delete with-funny applied' \
+	'git diff-index -p $t0 |
+	 git apply --stat | sed -e "s/|.*//" -e "s/ *\$//" >current &&
 	 git diff expected current'
 
-test_expect_success 'git-apply non-git diff' \
-	'git-diff-index -p $t0 |
+test_expect_success 'git apply non-git diff' \
+	'git diff-index -p $t0 |
 	 sed -ne "/^[-+@]/p" |
-	 git-apply --stat | sed -e "s/|.*//" -e "s/ *\$//" >current &&
+	 git apply --stat | sed -e "s/|.*//" -e "s/ *\$//" >current &&
 	 git diff expected current'
 
 test_done
@@ -14,15 +14,15 @@ export GIT_AUTHOR_EMAIL=bogus_email_address
 test_expect_success \
     'prepare repository with topic branch, then rebase against master' \
     'echo First > A &&
-     git-update-index --add A &&
+     git update-index --add A &&
      git-commit -m "Add A." &&
      git checkout -b my-topic-branch &&
      echo Second > B &&
-     git-update-index --add B &&
+     git update-index --add B &&
      git-commit -m "Add B." &&
      git checkout -f master &&
      echo Third >> A &&
-     git-update-index A &&
+     git update-index A &&
      git-commit -m "Modify A." &&
      git checkout -f my-topic-branch &&
      git rebase master'
@@ -14,37 +14,37 @@ local branch.
 test_expect_success \
     'prepare repository with topic branch' \
     'echo First > A &&
-     git-update-index --add A &&
+     git update-index --add A &&
      git-commit -m "Add A." &&
 
      git-checkout -b my-topic-branch &&
 
      echo Second > B &&
-     git-update-index --add B &&
+     git update-index --add B &&
      git-commit -m "Add B." &&
 
      echo AnotherSecond > C &&
-     git-update-index --add C &&
+     git update-index --add C &&
      git-commit -m "Add C." &&
 
      git-checkout -f master &&
 
      echo Third >> A &&
-     git-update-index A &&
+     git update-index A &&
      git-commit -m "Modify A."
 '
 
 test_expect_success \
     'pick top patch from topic branch into master' \
-    'git-cherry-pick my-topic-branch^0 &&
+    'git cherry-pick my-topic-branch^0 &&
      git-checkout -f my-topic-branch &&
-     git-branch master-merge master &&
-     git-branch my-topic-branch-merge my-topic-branch
+     git branch master-merge master &&
+     git branch my-topic-branch-merge my-topic-branch
 '
 
 test_debug \
-    'git-cherry master &&
-     git-format-patch -k --stdout --full-index master >/dev/null &&
+    'git cherry master &&
+     git format-patch -k --stdout --full-index master >/dev/null &&
      gitk --all & sleep 1
 '
 
@@ -49,7 +49,7 @@ test_expect_success 'rebase --skip with --merge' '
 	'
 
 test_expect_success 'merge and reference trees equal' \
-	'test -z "`git-diff-tree skip-merge skip-reference`"'
+	'test -z "`git diff-tree skip-merge skip-reference`"'
 
 test_debug 'gitk --all & sleep 1'
 
@@ -3,10 +3,10 @@
 # Copyright (c) 2006 Yann Dirson, based on t3400 by Amos Waterland
 #
 
-test_description='git-cherry should detect patches integrated upstream
+test_description='git cherry should detect patches integrated upstream
 
 This test cherry-picks one local change of two into master branch, and
-checks that git-cherry only returns the second patch in the local branch
+checks that git cherry only returns the second patch in the local branch
 '
 . ./test-lib.sh
 
@@ -15,40 +15,40 @@ export GIT_AUTHOR_EMAIL=bogus_email_address
 test_expect_success \
     'prepare repository with topic branch, and check cherry finds the 2 patches from there' \
     'echo First > A &&
-     git-update-index --add A &&
+     git update-index --add A &&
      git-commit -m "Add A." &&
 
      git-checkout -b my-topic-branch &&
 
      echo Second > B &&
-     git-update-index --add B &&
+     git update-index --add B &&
      git-commit -m "Add B." &&
 
      sleep 2 &&
      echo AnotherSecond > C &&
-     git-update-index --add C &&
+     git update-index --add C &&
      git-commit -m "Add C." &&
 
      git-checkout -f master &&
      rm -f B C &&
 
      echo Third >> A &&
-     git-update-index A &&
+     git update-index A &&
      git-commit -m "Modify A." &&
 
-     expr "$(echo $(git-cherry master my-topic-branch) )" : "+ [^ ]* + .*"
+     expr "$(echo $(git cherry master my-topic-branch) )" : "+ [^ ]* + .*"
 '
 
 test_expect_success \
     'check that cherry with limit returns only the top patch'\
-    'expr "$(echo $(git-cherry master my-topic-branch my-topic-branch^1) )" : "+ [^ ]*"
+    'expr "$(echo $(git cherry master my-topic-branch my-topic-branch^1) )" : "+ [^ ]*"
 '
 
 test_expect_success \
     'cherry-pick one of the 2 patches, and check cherry recognized one and only one as new' \
-    'git-cherry-pick my-topic-branch^0 &&
-     echo $(git-cherry master my-topic-branch) &&
-     expr "$(echo $(git-cherry master my-topic-branch) )" : "+ [^ ]* - .*"
+    'git cherry-pick my-topic-branch^0 &&
+     echo $(git cherry master my-topic-branch) &&
+     expr "$(echo $(git cherry master my-topic-branch) )" : "+ [^ ]* - .*"
 '
 
 test_done
@@ -3,21 +3,21 @@
 # Copyright (c) 2006 Carl D. Worth
 #
 
-test_description='Test of the various options to git-rm.'
+test_description='Test of the various options to git rm.'
 
 . ./test-lib.sh
 
 # Setup some files to be removed, some with funny characters
 test_expect_success \
     'Initialize test directory' \
     "touch -- foo bar baz 'space embedded' -q &&
-     git-add -- foo bar baz 'space embedded' -q &&
+     git add -- foo bar baz 'space embedded' -q &&
      git-commit -m 'add normal files' &&
      test_tabs=y &&
      if touch -- 'tab	embedded' 'newline
 embedded'
      then
-     git-add -- 'tab	embedded' 'newline
+     git add -- 'tab	embedded' 'newline
 embedded' &&
      git-commit -m 'add files with tabs and newlines'
      else
@@ -26,7 +26,7 @@ embedded' &&
      fi"
 
 # Later we will try removing an unremovable path to make sure
-# git-rm barfs, but if the test is run as root that cannot be
+# git rm barfs, but if the test is run as root that cannot be
 # arranged.
 test_expect_success \
     'Determine rm behavior' \
@@ -38,51 +38,51 @@ test_expect_success \
      rm -f test-file'
 
 test_expect_success \
-    'Pre-check that foo exists and is in index before git-rm foo' \
-    '[ -f foo ] && git-ls-files --error-unmatch foo'
+    'Pre-check that foo exists and is in index before git rm foo' \
+    '[ -f foo ] && git ls-files --error-unmatch foo'
 
 test_expect_success \
-    'Test that git-rm foo succeeds' \
-    'git-rm --cached foo'
+    'Test that git rm foo succeeds' \
+    'git rm --cached foo'
 
 test_expect_success \
-    'Post-check that foo exists but is not in index after git-rm foo' \
-    '[ -f foo ] && ! git-ls-files --error-unmatch foo'
+    'Post-check that foo exists but is not in index after git rm foo' \
+    '[ -f foo ] && ! git ls-files --error-unmatch foo'
 
 test_expect_success \
-    'Pre-check that bar exists and is in index before "git-rm bar"' \
-    '[ -f bar ] && git-ls-files --error-unmatch bar'
+    'Pre-check that bar exists and is in index before "git rm bar"' \
+    '[ -f bar ] && git ls-files --error-unmatch bar'
 
 test_expect_success \
-    'Test that "git-rm bar" succeeds' \
-    'git-rm bar'
+    'Test that "git rm bar" succeeds' \
+    'git rm bar'
 
 test_expect_success \
-    'Post-check that bar does not exist and is not in index after "git-rm -f bar"' \
-    '! [ -f bar ] && ! git-ls-files --error-unmatch bar'
+    'Post-check that bar does not exist and is not in index after "git rm -f bar"' \
+    '! [ -f bar ] && ! git ls-files --error-unmatch bar'
 
 test_expect_success \
-    'Test that "git-rm -- -q" succeeds (remove a file that looks like an option)' \
-    'git-rm -- -q'
+    'Test that "git rm -- -q" succeeds (remove a file that looks like an option)' \
+    'git rm -- -q'
 
 test "$test_tabs" = y && test_expect_success \
-    "Test that \"git-rm -f\" succeeds with embedded space, tab, or newline characters." \
-    "git-rm -f 'space embedded' 'tab	embedded' 'newline
+    "Test that \"git rm -f\" succeeds with embedded space, tab, or newline characters." \
+    "git rm -f 'space embedded' 'tab	embedded' 'newline
 embedded'"
 
 if test "$test_failed_remove" = y; then
 chmod a-w .
 test_expect_failure \
-    'Test that "git-rm -f" fails if its rm fails' \
-    'git-rm -f baz'
+    'Test that "git rm -f" fails if its rm fails' \
+    'git rm -f baz'
 chmod 775 .
 else
     test_expect_success 'skipping removal failure (perhaps running as root?)' :
 fi
 
 test_expect_success \
-    'When the rm in "git-rm -f" fails, it should not remove the file from the index' \
-    'git-ls-files --error-unmatch baz'
+    'When the rm in "git rm -f" fails, it should not remove the file from the index' \
+    'git ls-files --error-unmatch baz'
 
 test_expect_success 'Remove nonexistent file with --ignore-unmatch' '
 	git rm --ignore-unmatch nonexistent
@@ -3,72 +3,72 @@
 # Copyright (c) 2006 Carl D. Worth
 #
 
-test_description='Test of git-add, including the -- option.'
+test_description='Test of git add, including the -- option.'
 
 . ./test-lib.sh
 
 test_expect_success \
-    'Test of git-add' \
-    'touch foo && git-add foo'
+    'Test of git add' \
+    'touch foo && git add foo'
 
 test_expect_success \
     'Post-check that foo is in the index' \
-    'git-ls-files foo | grep foo'
+    'git ls-files foo | grep foo'
 
 test_expect_success \
-    'Test that "git-add -- -q" works' \
-    'touch -- -q && git-add -- -q'
+    'Test that "git add -- -q" works' \
+    'touch -- -q && git add -- -q'
 
 test_expect_success \
-	'git-add: Test that executable bit is not used if core.filemode=0' \
+	'git add: Test that executable bit is not used if core.filemode=0' \
 	'git config core.filemode 0 &&
 	 echo foo >xfoo1 &&
 	 chmod 755 xfoo1 &&
-	 git-add xfoo1 &&
-	 case "`git-ls-files --stage xfoo1`" in
+	 git add xfoo1 &&
+	 case "`git ls-files --stage xfoo1`" in
 	 100644" "*xfoo1) echo ok;;
-	 *) echo fail; git-ls-files --stage xfoo1; (exit 1);;
+	 *) echo fail; git ls-files --stage xfoo1; (exit 1);;
 	 esac'
 
-test_expect_success 'git-add: filemode=0 should not get confused by symlink' '
+test_expect_success 'git add: filemode=0 should not get confused by symlink' '
 	rm -f xfoo1 &&
 	ln -s foo xfoo1 &&
-	git-add xfoo1 &&
-	case "`git-ls-files --stage xfoo1`" in
+	git add xfoo1 &&
+	case "`git ls-files --stage xfoo1`" in
 	120000" "*xfoo1) echo ok;;
-	*) echo fail; git-ls-files --stage xfoo1; (exit 1);;
+	*) echo fail; git ls-files --stage xfoo1; (exit 1);;
 	esac
 '
 
 test_expect_success \
-	'git-update-index --add: Test that executable bit is not used...' \
+	'git update-index --add: Test that executable bit is not used...' \
 	'git config core.filemode 0 &&
 	 echo foo >xfoo2 &&
 	 chmod 755 xfoo2 &&
-	 git-update-index --add xfoo2 &&
-	 case "`git-ls-files --stage xfoo2`" in
+	 git update-index --add xfoo2 &&
+	 case "`git ls-files --stage xfoo2`" in
 	 100644" "*xfoo2) echo ok;;
-	 *) echo fail; git-ls-files --stage xfoo2; (exit 1);;
+	 *) echo fail; git ls-files --stage xfoo2; (exit 1);;
 	 esac'
 
-test_expect_success 'git-add: filemode=0 should not get confused by symlink' '
+test_expect_success 'git add: filemode=0 should not get confused by symlink' '
 	rm -f xfoo2 &&
 	ln -s foo xfoo2 &&
 	git update-index --add xfoo2 &&
-	case "`git-ls-files --stage xfoo2`" in
+	case "`git ls-files --stage xfoo2`" in
 	120000" "*xfoo2) echo ok;;
-	*) echo fail; git-ls-files --stage xfoo2; (exit 1);;
+	*) echo fail; git ls-files --stage xfoo2; (exit 1);;
 	esac
 '
 
 test_expect_success \
-	'git-update-index --add: Test that executable bit is not used...' \
+	'git update-index --add: Test that executable bit is not used...' \
 	'git config core.filemode 0 &&
 	 ln -s xfoo2 xfoo3 &&
-	 git-update-index --add xfoo3 &&
-	 case "`git-ls-files --stage xfoo3`" in
+	 git update-index --add xfoo3 &&
+	 case "`git ls-files --stage xfoo3`" in
 	 120000" "*xfoo3) echo ok;;
-	 *) echo fail; git-ls-files --stage xfoo3; (exit 1);;
+	 *) echo fail; git ls-files --stage xfoo3; (exit 1);;
 	 esac'
 
 test_expect_success '.gitignore test setup' '
@@ -80,28 +80,28 @@ test_expect_success '.gitignore test setup' '
 '
 
 test_expect_success '.gitignore is honored' '
-	git-add . &&
-	! git-ls-files | grep "\\.ig"
+	git add . &&
+	! git ls-files | grep "\\.ig"
 '
 
 test_expect_success 'error out when attempting to add ignored ones without -f' '
-	! git-add a.?? &&
-	! git-ls-files | grep "\\.ig"
+	! git add a.?? &&
+	! git ls-files | grep "\\.ig"
 '
 
 test_expect_success 'error out when attempting to add ignored ones without -f' '
-	! git-add d.?? &&
-	! git-ls-files | grep "\\.ig"
+	! git add d.?? &&
+	! git ls-files | grep "\\.ig"
 '
 
 test_expect_success 'add ignored ones with -f' '
-	git-add -f a.?? &&
-	git-ls-files --error-unmatch a.ig
+	git add -f a.?? &&
+	git ls-files --error-unmatch a.ig
 '
 
 test_expect_success 'add ignored ones with -f' '
-	git-add -f d.??/* &&
-	git-ls-files --error-unmatch d.ig/d.if d.ig/d.ig
+	git add -f d.??/* &&
+	git ls-files --error-unmatch d.ig/d.if d.ig/d.ig
 '
 
 mkdir 1 1/2 1/3
@@ -22,9 +22,9 @@ check_verify_failure () {
 # first create a commit, so we have a valid object/type
 # for the tag.
 echo Hello >A
-git-update-index --add A
+git update-index --add A
 git-commit -m "Initial commit"
-head=$(git-rev-parse --verify HEAD)
+head=$(git rev-parse --verify HEAD)
 
 ############################################################
 #  1. length check
@@ -8,28 +8,28 @@ test_description='commit and log output encodings'
 . ./test-lib.sh
 
 compare_with () {
-	git-show -s $1 | sed -e '1,/^$/d' -e 's/^    //' -e '$d' >current &&
+	git show -s $1 | sed -e '1,/^$/d' -e 's/^    //' -e '$d' >current &&
 	git diff current "$2"
 }
 
 test_expect_success setup '
 	: >F &&
-	git-add F &&
-	T=$(git-write-tree) &&
-	C=$(git-commit-tree $T <../t3900/1-UTF-8.txt) &&
-	git-update-ref HEAD $C &&
+	git add F &&
+	T=$(git write-tree) &&
+	C=$(git commit-tree $T <../t3900/1-UTF-8.txt) &&
+	git update-ref HEAD $C &&
 	git-tag C0
 '
 
 test_expect_success 'no encoding header for base case' '
-	E=$(git-cat-file commit C0 | sed -ne "s/^encoding //p") &&
+	E=$(git cat-file commit C0 | sed -ne "s/^encoding //p") &&
 	test z = "z$E"
 '
 
 for H in ISO-8859-1 EUCJP ISO-2022-JP
 do
 	test_expect_success "$H setup" '
-		git-config i18n.commitencoding $H &&
+		git config i18n.commitencoding $H &&
 		git-checkout -b $H C0 &&
 		echo $H >F &&
 		git-commit -a -F ../t3900/$H.txt
@@ -39,21 +39,21 @@ done
 for H in ISO-8859-1 EUCJP ISO-2022-JP
 do
 	test_expect_success "check encoding header for $H" '
-		E=$(git-cat-file commit '$H' | sed -ne "s/^encoding //p") &&
+		E=$(git cat-file commit '$H' | sed -ne "s/^encoding //p") &&
 		test "z$E" = "z'$H'"
 	'
 done
 
 test_expect_success 'config to remove customization' '
-	git-config --unset-all i18n.commitencoding &&
-	if Z=$(git-config --get-all i18n.commitencoding)
+	git config --unset-all i18n.commitencoding &&
+	if Z=$(git config --get-all i18n.commitencoding)
 	then
 		echo Oops, should have failed.
 		false
 	else
 		test z = "z$Z"
 	fi &&
-	git-config i18n.commitencoding utf-8
+	git config i18n.commitencoding utf-8
 '
 
 test_expect_success 'ISO-8859-1 should be shown in UTF-8 now' '
@@ -68,8 +68,8 @@ do
 done
 
 test_expect_success 'config to add customization' '
-	git-config --unset-all i18n.commitencoding &&
-	if Z=$(git-config --get-all i18n.commitencoding)
+	git config --unset-all i18n.commitencoding &&
+	if Z=$(git config --get-all i18n.commitencoding)
 	then
 		echo Oops, should have failed.
 		false
@@ -81,13 +81,13 @@ test_expect_success 'config to add customization' '
 for H in ISO-8859-1 EUCJP ISO-2022-JP
 do
 	test_expect_success "$H should be shown in itself now" '
-		git-config i18n.commitencoding '$H' &&
+		git config i18n.commitencoding '$H' &&
 		compare_with '$H' ../t3900/'$H'.txt
 	'
 done
 
 test_expect_success 'config to tweak customization' '
-	git-config i18n.logoutputencoding utf-8
+	git config i18n.logoutputencoding utf-8
 '
 
 test_expect_success 'ISO-8859-1 should be shown in UTF-8 now' '
@@ -103,7 +103,7 @@ done
 
 for J in EUCJP ISO-2022-JP
 do
-	git-config i18n.logoutputencoding $J
+	git config i18n.logoutputencoding $J
 	for H in EUCJP ISO-2022-JP
 	do
 		test_expect_success "$H should be shown in $J now" '
@@ -14,7 +14,7 @@ check_encoding () {
 	do
 		git format-patch --encoding=UTF-8 --stdout HEAD~$i..HEAD~$j |
 		grep "^From: =?UTF-8?q?=C3=81=C3=A9=C3=AD=20=C3=B3=C3=BA?=" &&
-		git-cat-file commit HEAD~$j |
+		git cat-file commit HEAD~$j |
 		case "$header" in
 		8859)
 			grep "^encoding ISO-8859-1" ;;
@@ -31,7 +31,7 @@ check_encoding () {
 }
 
 test_expect_success setup '
-	git-config i18n.commitencoding UTF-8 &&
+	git config i18n.commitencoding UTF-8 &&
 
 	# use UTF-8 in author and committer name to match the
 	# i18n.commitencoding settings
@@ -55,7 +55,7 @@ test_expect_success setup '
 	git commit -s -m "Second on side" &&
 
 	# the second one on the side branch is ISO-8859-1
-	git-config i18n.commitencoding ISO-8859-1 &&
+	git config i18n.commitencoding ISO-8859-1 &&
 	# use author and committer name in ISO-8859-1 to match it.
 	. ../t3901-8859-1.txt &&
 	test_tick &&
@@ -64,11 +64,11 @@ test_expect_success setup '
 	git commit -s -m "Third on side" &&
 
 	# Back to default
-	git-config i18n.commitencoding UTF-8
+	git config i18n.commitencoding UTF-8
 '
 
 test_expect_success 'format-patch output (ISO-8859-1)' '
-	git-config i18n.logoutputencoding ISO-8859-1 &&
+	git config i18n.logoutputencoding ISO-8859-1 &&
 
 	git format-patch --stdout master..HEAD^ >out-l1 &&
 	git format-patch --stdout HEAD^ >out-l2 &&
@@ -91,7 +91,7 @@ test_expect_success 'format-patch output (UTF-8)' '
 
 test_expect_success 'rebase (U/U)' '
 	# We want the result of rebase in UTF-8
-	git-config i18n.commitencoding UTF-8 &&
+	git config i18n.commitencoding UTF-8 &&
 
 	# The test is about logoutputencoding not affecting the
 	# final outcome -- it is used internally to generate the
@@ -109,7 +109,7 @@ test_expect_success 'rebase (U/U)' '
 '
 
 test_expect_success 'rebase (U/L)' '
-	git-config i18n.commitencoding UTF-8 &&
+	git config i18n.commitencoding UTF-8 &&
 	git config i18n.logoutputencoding ISO-8859-1 &&
 	. ../t3901-utf8.txt &&
 
@@ -121,7 +121,7 @@ test_expect_success 'rebase (U/L)' '
 
 test_expect_success 'rebase (L/L)' '
 	# In this test we want ISO-8859-1 encoded commits as the result
-	git-config i18n.commitencoding ISO-8859-1 &&
+	git config i18n.commitencoding ISO-8859-1 &&
 	git config i18n.logoutputencoding ISO-8859-1 &&
 	. ../t3901-8859-1.txt &&
 
@@ -134,7 +134,7 @@ test_expect_success 'rebase (L/L)' '
 test_expect_success 'rebase (L/U)' '
 	# This is pathological -- use UTF-8 as intermediate form
 	# to get ISO-8859-1 results.
-	git-config i18n.commitencoding ISO-8859-1 &&
+	git config i18n.commitencoding ISO-8859-1 &&
 	git config i18n.logoutputencoding UTF-8 &&
 	. ../t3901-8859-1.txt &&
 
@@ -147,7 +147,7 @@ test_expect_success 'rebase (L/U)' '
 test_expect_success 'cherry-pick(U/U)' '
 	# Both the commitencoding and logoutputencoding is set to UTF-8.
 
-	git-config i18n.commitencoding UTF-8 &&
+	git config i18n.commitencoding UTF-8 &&
 	git config i18n.logoutputencoding UTF-8 &&
 	. ../t3901-utf8.txt &&
 
@@ -162,7 +162,7 @@ test_expect_success 'cherry-pick(U/U)' '
 test_expect_success 'cherry-pick(L/L)' '
 	# Both the commitencoding and logoutputencoding is set to ISO-8859-1
 
-	git-config i18n.commitencoding ISO-8859-1 &&
+	git config i18n.commitencoding ISO-8859-1 &&
 	git config i18n.logoutputencoding ISO-8859-1 &&
 	. ../t3901-8859-1.txt &&
 
@@ -177,7 +177,7 @@ test_expect_success 'cherry-pick(L/L)' '
 test_expect_success 'cherry-pick(U/L)' '
 	# Commitencoding is set to UTF-8 but logoutputencoding is ISO-8859-1
 
-	git-config i18n.commitencoding UTF-8 &&
+	git config i18n.commitencoding UTF-8 &&
 	git config i18n.logoutputencoding ISO-8859-1 &&
 	. ../t3901-utf8.txt &&
 
@@ -193,7 +193,7 @@ test_expect_success 'cherry-pick(L/U)' '
 	# Again, the commitencoding is set to ISO-8859-1 but
 	# logoutputencoding is set to UTF-8.
 
-	git-config i18n.commitencoding ISO-8859-1 &&
+	git config i18n.commitencoding ISO-8859-1 &&
 	git config i18n.logoutputencoding UTF-8 &&
 	. ../t3901-8859-1.txt &&
 
@@ -206,7 +206,7 @@ test_expect_success 'cherry-pick(L/U)' '
 '
 
 test_expect_success 'rebase --merge (U/U)' '
-	git-config i18n.commitencoding UTF-8 &&
+	git config i18n.commitencoding UTF-8 &&
 	git config i18n.logoutputencoding UTF-8 &&
 	. ../t3901-utf8.txt &&
 
@@ -217,7 +217,7 @@ test_expect_success 'rebase --merge (U/U)' '
 '
 
 test_expect_success 'rebase --merge (U/L)' '
-	git-config i18n.commitencoding UTF-8 &&
+	git config i18n.commitencoding UTF-8 &&
 	git config i18n.logoutputencoding ISO-8859-1 &&
 	. ../t3901-utf8.txt &&
 
@@ -229,7 +229,7 @@ test_expect_success 'rebase --merge (U/L)' '
 
 test_expect_success 'rebase --merge (L/L)' '
 	# In this test we want ISO-8859-1 encoded commits as the result
-	git-config i18n.commitencoding ISO-8859-1 &&
+	git config i18n.commitencoding ISO-8859-1 &&
 	git config i18n.logoutputencoding ISO-8859-1 &&
 	. ../t3901-8859-1.txt &&
 
@@ -242,7 +242,7 @@ test_expect_success 'rebase --merge (L/L)' '
 test_expect_success 'rebase --merge (L/U)' '
 	# This is pathological -- use UTF-8 as intermediate form
 	# to get ISO-8859-1 results.
-	git-config i18n.commitencoding ISO-8859-1 &&
+	git config i18n.commitencoding ISO-8859-1 &&
 	git config i18n.logoutputencoding UTF-8 &&
 	. ../t3901-8859-1.txt &&
 
@@ -17,15 +17,15 @@ chmod +x path1
 
 test_expect_success \
     'update-cache --add two files with and without +x.' \
-    'git-update-index --add path0 path1'
+    'git update-index --add path0 path1'
 
 mv path0 path0-
 sed -e 's/line/Line/' <path0- >path0
 chmod +x path0
 rm -f path1
 test_expect_success \
-    'git-diff-files -p after editing work tree.' \
-    'git-diff-files -p >current'
+    'git diff-files -p after editing work tree.' \
+    'git diff-files -p >current'
 
 # that's as far as it comes
 if [ "$(git config --get core.filemode)" = false ]
@@ -56,7 +56,7 @@ deleted file mode 100755
 EOF
 
 test_expect_success \
-    'validate git-diff-files -p output.' \
+    'validate git diff-files -p output.' \
     'compare_diff_patch current expected'
 
 test_done
@@ -28,21 +28,21 @@ Line 15
 
 test_expect_success \
     'update-cache --add a file.' \
-    'git-update-index --add path0'
+    'git update-index --add path0'
 
 test_expect_success \
     'write that tree.' \
-    'tree=$(git-write-tree) && echo $tree'
+    'tree=$(git write-tree) && echo $tree'
 
 sed -e 's/line/Line/' <path0 >path1
 rm -f path0
 test_expect_success \
     'renamed and edited the file.' \
-    'git-update-index --add --remove path0 path1'
+    'git update-index --add --remove path0 path1'
 
 test_expect_success \
-    'git-diff-index -p -M after rename and editing.' \
-    'git-diff-index -p -M $tree >current'
+    'git diff-index -p -M after rename and editing.' \
+    'git diff-index -p -M $tree >current'
 cat >expected <<\EOF
 diff --git a/path0 b/path1
 rename from path0
@@ -140,80 +140,80 @@ cmp_diff_files_output () {
 
 test_expect_success \
     'diff-tree of known trees.' \
-    'git-diff-tree $tree_O $tree_A >.test-a &&
+    'git diff-tree $tree_O $tree_A >.test-a &&
      cmp -s .test-a .test-plain-OA'
 
 test_expect_success \
     'diff-tree of known trees.' \
-    'git-diff-tree -r $tree_O $tree_A >.test-a &&
+    'git diff-tree -r $tree_O $tree_A >.test-a &&
      cmp -s .test-a .test-recursive-OA'
 
 test_expect_success \
     'diff-tree of known trees.' \
-    'git-diff-tree $tree_O $tree_B >.test-a &&
+    'git diff-tree $tree_O $tree_B >.test-a &&
      cmp -s .test-a .test-plain-OB'
 
 test_expect_success \
     'diff-tree of known trees.' \
-    'git-diff-tree -r $tree_O $tree_B >.test-a &&
+    'git diff-tree -r $tree_O $tree_B >.test-a &&
      cmp -s .test-a .test-recursive-OB'
 
 test_expect_success \
     'diff-tree of known trees.' \
-    'git-diff-tree $tree_A $tree_B >.test-a &&
+    'git diff-tree $tree_A $tree_B >.test-a &&
      cmp -s .test-a .test-plain-AB'
 
 test_expect_success \
     'diff-tree of known trees.' \
-    'git-diff-tree -r $tree_A $tree_B >.test-a &&
+    'git diff-tree -r $tree_A $tree_B >.test-a &&
      cmp -s .test-a .test-recursive-AB'
 
 test_expect_success \
     'diff-cache O with A in cache' \
-    'git-read-tree $tree_A &&
-     git-diff-index --cached $tree_O >.test-a &&
+    'git read-tree $tree_A &&
+     git diff-index --cached $tree_O >.test-a &&
      cmp -s .test-a .test-recursive-OA'
 
 test_expect_success \
     'diff-cache O with B in cache' \
-    'git-read-tree $tree_B &&
-     git-diff-index --cached $tree_O >.test-a &&
+    'git read-tree $tree_B &&
+     git diff-index --cached $tree_O >.test-a &&
      cmp -s .test-a .test-recursive-OB'
 
 test_expect_success \
     'diff-cache A with B in cache' \
-    'git-read-tree $tree_B &&
-     git-diff-index --cached $tree_A >.test-a &&
+    'git read-tree $tree_B &&
+     git diff-index --cached $tree_A >.test-a &&
      cmp -s .test-a .test-recursive-AB'
 
 test_expect_success \
     'diff-files with O in cache and A checked out' \
     'rm -fr Z [A-Z][A-Z] &&
-     git-read-tree $tree_A &&
-     git-checkout-index -f -a &&
-     git-read-tree --reset $tree_O || return 1
-     git-update-index --refresh >/dev/null ;# this can exit non-zero
-     git-diff-files >.test-a &&
+     git read-tree $tree_A &&
+     git checkout-index -f -a &&
+     git read-tree --reset $tree_O || return 1
+     git update-index --refresh >/dev/null ;# this can exit non-zero
+     git diff-files >.test-a &&
      cmp_diff_files_output .test-a .test-recursive-OA'
 
 test_expect_success \
     'diff-files with O in cache and B checked out' \
     'rm -fr Z [A-Z][A-Z] &&
-     git-read-tree $tree_B &&
-     git-checkout-index -f -a &&
-     git-read-tree --reset $tree_O || return 1
-     git-update-index --refresh >/dev/null ;# this can exit non-zero
-     git-diff-files >.test-a &&
+     git read-tree $tree_B &&
+     git checkout-index -f -a &&
+     git read-tree --reset $tree_O || return 1
+     git update-index --refresh >/dev/null ;# this can exit non-zero
+     git diff-files >.test-a &&
      cmp_diff_files_output .test-a .test-recursive-OB'
 
 test_expect_success \
     'diff-files with A in cache and B checked out' \
     'rm -fr Z [A-Z][A-Z] &&
-     git-read-tree $tree_B &&
-     git-checkout-index -f -a &&
-     git-read-tree --reset $tree_A || return 1
-     git-update-index --refresh >/dev/null ;# this can exit non-zero
-     git-diff-files >.test-a &&
+     git read-tree $tree_B &&
+     git checkout-index -f -a &&
+     git read-tree --reset $tree_A || return 1
+     git update-index --refresh >/dev/null ;# this can exit non-zero
+     git diff-files >.test-a &&
      cmp_diff_files_output .test-a .test-recursive-AB'
 
 ################################################################
@@ -222,26 +222,26 @@ test_expect_success \
 
 test_expect_success \
     'diff-tree O A == diff-tree -R A O' \
-    'git-diff-tree $tree_O $tree_A >.test-a &&
-    git-diff-tree -R $tree_A $tree_O >.test-b &&
+    'git diff-tree $tree_O $tree_A >.test-a &&
+    git diff-tree -R $tree_A $tree_O >.test-b &&
     cmp -s .test-a .test-b'
 
 test_expect_success \
     'diff-tree -r O A == diff-tree -r -R A O' \
-    'git-diff-tree -r $tree_O $tree_A >.test-a &&
-    git-diff-tree -r -R $tree_A $tree_O >.test-b &&
+    'git diff-tree -r $tree_O $tree_A >.test-a &&
+    git diff-tree -r -R $tree_A $tree_O >.test-b &&
     cmp -s .test-a .test-b'
 
 test_expect_success \
     'diff-tree B A == diff-tree -R A B' \
-    'git-diff-tree $tree_B $tree_A >.test-a &&
-    git-diff-tree -R $tree_A $tree_B >.test-b &&
+    'git diff-tree $tree_B $tree_A >.test-a &&
+    git diff-tree -R $tree_A $tree_B >.test-b &&
     cmp -s .test-a .test-b'
 
 test_expect_success \
     'diff-tree -r B A == diff-tree -r -R A B' \
-    'git-diff-tree -r $tree_B $tree_A >.test-a &&
-    git-diff-tree -r -R $tree_A $tree_B >.test-b &&
+    'git diff-tree -r $tree_B $tree_A >.test-a &&
+    git diff-tree -r -R $tree_A $tree_B >.test-b &&
     cmp -s .test-a .test-b'
 
 test_done
@@ -13,23 +13,23 @@ test_expect_success \
     'prepare reference tree' \
     'cat ../../COPYING >COPYING &&
      echo frotz >rezrov &&
-    git-update-index --add COPYING rezrov &&
-    tree=$(git-write-tree) &&
+    git update-index --add COPYING rezrov &&
+    tree=$(git write-tree) &&
     echo $tree'
 
 test_expect_success \
     'prepare work tree' \
     'sed -e 's/HOWEVER/However/' <COPYING >COPYING.1 &&
     sed -e 's/GPL/G.P.L/g' <COPYING >COPYING.2 &&
     rm -f COPYING &&
-    git-update-index --add --remove COPYING COPYING.?'
+    git update-index --add --remove COPYING COPYING.?'
 
 # tree has COPYING and rezrov.  work tree has COPYING.1 and COPYING.2,
 # both are slightly edited, and unchanged rezrov.  So we say you
 # copy-and-edit one, and rename-and-edit the other.  We do not say
 # anything about rezrov.
 
-GIT_DIFF_OPTS=--unified=0 git-diff-index -M -p $tree >current
+GIT_DIFF_OPTS=--unified=0 git diff-index -M -p $tree >current
 cat >expected <<\EOF
 diff --git a/COPYING b/COPYING.1
 copy from COPYING
@@ -62,14 +62,14 @@ test_expect_success \
 test_expect_success \
     'prepare work tree again' \
     'mv COPYING.2 COPYING &&
-     git-update-index --add --remove COPYING COPYING.1 COPYING.2'
+     git update-index --add --remove COPYING COPYING.1 COPYING.2'
 
 # tree has COPYING and rezrov.  work tree has COPYING and COPYING.1,
 # both are slightly edited, and unchanged rezrov.  So we say you
 # edited one, and copy-and-edit the other.  We do not say
 # anything about rezrov.
 
-GIT_DIFF_OPTS=--unified=0 git-diff-index -C -p $tree >current
+GIT_DIFF_OPTS=--unified=0 git diff-index -C -p $tree >current
 cat >expected <<\EOF
 diff --git a/COPYING b/COPYING
 --- a/COPYING
@@ -100,16 +100,16 @@ test_expect_success \
 test_expect_success \
     'prepare work tree once again' \
     'cat ../../COPYING >COPYING &&
-     git-update-index --add --remove COPYING COPYING.1'
+     git update-index --add --remove COPYING COPYING.1'
 
 # tree has COPYING and rezrov.  work tree has COPYING and COPYING.1,
 # but COPYING is not edited.  We say you copy-and-edit COPYING.1; this
 # is only possible because -C mode now reports the unmodified file to
 # the diff-core.  Unchanged rezrov, although being fed to
-# git-diff-index as well, should not be mentioned.
+# git diff-index as well, should not be mentioned.
 
 GIT_DIFF_OPTS=--unified=0 \
-    git-diff-index -C --find-copies-harder -p $tree >current
+    git diff-index -C --find-copies-harder -p $tree >current
 cat >expected <<\EOF
 diff --git a/COPYING b/COPYING.1
 copy from COPYING
@@ -16,8 +16,8 @@ test_expect_success \
     'prepare reference tree' \
     'echo xyzzy | tr -d '\\\\'012 >yomin &&
      ln -s xyzzy frotz &&
-    git-update-index --add frotz yomin &&
-    tree=$(git-write-tree) &&
+    git update-index --add frotz yomin &&
+    tree=$(git write-tree) &&
     echo $tree'
 
 test_expect_success \
@@ -26,15 +26,15 @@ test_expect_success \
      rm -f yomin &&
      ln -s xyzzy nitfol &&
      ln -s xzzzy bozbar &&
-    git-update-index --add --remove frotz rezrov nitfol bozbar yomin'
+    git update-index --add --remove frotz rezrov nitfol bozbar yomin'
 
 # tree has frotz pointing at xyzzy, and yomin that contains xyzzy to
 # confuse things.  work tree has rezrov (xyzzy) nitfol (xyzzy) and
 # bozbar (xzzzy).
 # rezrov and nitfol are rename/copy of frotz and bozbar should be
 # a new creation.
 
-GIT_DIFF_OPTS=--unified=0 git-diff-index -M -p $tree >current
+GIT_DIFF_OPTS=--unified=0 git diff-index -M -p $tree >current
 cat >expected <<\EOF
 diff --git a/bozbar b/bozbar
 new file mode 120000
@@ -13,23 +13,23 @@ test_expect_success \
     'prepare reference tree' \
     'cat ../../COPYING >COPYING &&
      echo frotz >rezrov &&
-    git-update-index --add COPYING rezrov &&
-    tree=$(git-write-tree) &&
+    git update-index --add COPYING rezrov &&
+    tree=$(git write-tree) &&
     echo $tree'
 
 test_expect_success \
     'prepare work tree' \
     'sed -e 's/HOWEVER/However/' <COPYING >COPYING.1 &&
     sed -e 's/GPL/G.P.L/g' <COPYING >COPYING.2 &&
     rm -f COPYING &&
-    git-update-index --add --remove COPYING COPYING.?'
+    git update-index --add --remove COPYING COPYING.?'
 
 # tree has COPYING and rezrov.  work tree has COPYING.1 and COPYING.2,
 # both are slightly edited, and unchanged rezrov.  We say COPYING.1
 # and COPYING.2 are based on COPYING, and do not say anything about
 # rezrov.
 
-git-diff-index -M $tree >current
+git diff-index -M $tree >current
 
 cat >expected <<\EOF
 :100644 100644 6ff87c4664981e4397625791c8ea3bbb5f2279a3 0603b3238a076dc6c8022aedc6648fa523a17178 C1234	COPYING	COPYING.1
@@ -45,14 +45,14 @@ test_expect_success \
 test_expect_success \
     'prepare work tree again' \
     'mv COPYING.2 COPYING &&
-     git-update-index --add --remove COPYING COPYING.1 COPYING.2'
+     git update-index --add --remove COPYING COPYING.1 COPYING.2'
 
 # tree has COPYING and rezrov.  work tree has COPYING and COPYING.1,
 # both are slightly edited, and unchanged rezrov.  We say COPYING.1
 # is based on COPYING and COPYING is still there, and do not say anything
 # about rezrov.
 
-git-diff-index -C $tree >current
+git diff-index -C $tree >current
 cat >expected <<\EOF
 :100644 100644 6ff87c4664981e4397625791c8ea3bbb5f2279a3 06c67961bbaed34a127f76d261f4c0bf73eda471 M	COPYING
 :100644 100644 6ff87c4664981e4397625791c8ea3bbb5f2279a3 0603b3238a076dc6c8022aedc6648fa523a17178 C1234	COPYING	COPYING.1
@@ -72,9 +72,9 @@ test_expect_success \
 test_expect_success \
     'prepare work tree once again' \
     'cat ../../COPYING >COPYING &&
-     git-update-index --add --remove COPYING COPYING.1'
+     git update-index --add --remove COPYING COPYING.1'
 
-git-diff-index -C --find-copies-harder $tree >current
+git diff-index -C --find-copies-harder $tree >current
 cat >expected <<\EOF
 :100644 100644 6ff87c4664981e4397625791c8ea3bbb5f2279a3 0603b3238a076dc6c8022aedc6648fa523a17178 C1234	COPYING	COPYING.1
 EOF
@@ -11,24 +11,24 @@ test_description='Test mode change diffs.
 test_expect_success \
     'setup' \
     'echo frotz >rezrov &&
-     git-update-index --add rezrov &&
-     tree=`git-write-tree` &&
+     git update-index --add rezrov &&
+     tree=`git write-tree` &&
      echo $tree'
 
 if [ "$(git config --get core.filemode)" = false ]
 then
 	say 'filemode disabled on the filesystem, using update-index --chmod=+x'
 	test_expect_success \
-	    'git-update-index --chmod=+x' \
-	    'git-update-index rezrov &&
-	     git-update-index --chmod=+x rezrov &&
-	     git-diff-index $tree >current'
+	    'git update-index --chmod=+x' \
+	    'git update-index rezrov &&
+	     git update-index --chmod=+x rezrov &&
+	     git diff-index $tree >current'
 else
 	test_expect_success \
 	    'chmod' \
 	    'chmod +x rezrov &&
-	     git-update-index rezrov &&
-	     git-diff-index $tree >current'
+	     git update-index rezrov &&
+	     git diff-index $tree >current'
 fi
 
 _x40='[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f]'
@@ -13,20 +13,20 @@ test_expect_success \
     'prepare reference tree' \
     'mkdir path0 path1 &&
      cp ../../COPYING path0/COPYING &&
-     git-update-index --add path0/COPYING &&
-    tree=$(git-write-tree) &&
+     git update-index --add path0/COPYING &&
+    tree=$(git write-tree) &&
     echo $tree'
 
 test_expect_success \
     'prepare work tree' \
     'cp path0/COPYING path1/COPYING &&
-     git-update-index --add --remove path0/COPYING path1/COPYING'
+     git update-index --add --remove path0/COPYING path1/COPYING'
 
 # In the tree, there is only path0/COPYING.  In the cache, path0 and
 # path1 both have COPYING and the latter is a copy of path0/COPYING.
 # Comparing the full tree with cache should tell us so.
 
-git-diff-index -C --find-copies-harder $tree >current
+git diff-index -C --find-copies-harder $tree >current
 
 cat >expected <<\EOF
 :100644 100644 6ff87c4664981e4397625791c8ea3bbb5f2279a3 6ff87c4664981e4397625791c8ea3bbb5f2279a3 C100	path0/COPYING	path1/COPYING
@@ -42,7 +42,7 @@ test_expect_success \
 # path1/COPYING suddenly appearing from nowhere, not detected as
 # a copy from path0/COPYING.
 
-git-diff-index -C $tree path1 >current
+git diff-index -C $tree path1 >current
 
 cat >expected <<\EOF
 :000000 100644 0000000000000000000000000000000000000000 6ff87c4664981e4397625791c8ea3bbb5f2279a3 A	path1/COPYING
@@ -55,14 +55,14 @@ test_expect_success \
 test_expect_success \
     'tweak work tree' \
     'rm -f path0/COPYING &&
-     git-update-index --remove path0/COPYING'
+     git update-index --remove path0/COPYING'
 
 # In the tree, there is only path0/COPYING.  In the cache, path0 does
 # not have COPYING anymore and path1 has COPYING which is a copy of
 # path0/COPYING.  Showing the full tree with cache should tell us about
 # the rename.
 
-git-diff-index -C $tree >current
+git diff-index -C $tree >current
 
 cat >expected <<\EOF
 :100644 100644 6ff87c4664981e4397625791c8ea3bbb5f2279a3 6ff87c4664981e4397625791c8ea3bbb5f2279a3 R100	path0/COPYING	path1/COPYING
@@ -77,7 +77,7 @@ test_expect_success \
 # path0/COPYING.  When we say we care only about path1, we should just
 # see path1/COPYING appearing from nowhere.
 
-git-diff-index -C $tree path1 >current
+git diff-index -C $tree path1 >current
 
 cat >expected <<\EOF
 :000000 100644 0000000000000000000000000000000000000000 6ff87c4664981e4397625791c8ea3bbb5f2279a3 A	path1/COPYING
@@ -28,19 +28,19 @@ test_expect_success \
     setup \
     'cat ../../README >file0 &&
      cat ../../COPYING >file1 &&
-    git-update-index --add file0 file1 &&
-    tree=$(git-write-tree) &&
+    git update-index --add file0 file1 &&
+    tree=$(git write-tree) &&
     echo "$tree"'
 
 test_expect_success \
     'change file1 with copy-edit of file0 and remove file0' \
     'sed -e "s/git/GIT/" file0 >file1 &&
      rm -f file0 &&
-    git-update-index --remove file0 file1'
+    git update-index --remove file0 file1'
 
 test_expect_success \
     'run diff with -B' \
-    'git-diff-index -B --cached "$tree" >current'
+    'git diff-index -B --cached "$tree" >current'
 
 cat >expected <<\EOF
 :100644 000000 f5deac7be59e7eeab8657fd9ae706fd6a57daed2 0000000000000000000000000000000000000000 D	file0
@@ -53,7 +53,7 @@ test_expect_success \
 
 test_expect_success \
     'run diff with -B and -M' \
-    'git-diff-index -B -M "$tree" >current'
+    'git diff-index -B -M "$tree" >current'
 
 cat >expected <<\EOF
 :100644 100644 f5deac7be59e7eeab8657fd9ae706fd6a57daed2 08bb2fb671deff4c03a4d4a0a1315dff98d5732c R100	file0	file1
@@ -66,16 +66,16 @@ test_expect_success \
 test_expect_success \
     'swap file0 and file1' \
     'rm -f file0 file1 &&
-     git-read-tree -m $tree &&
-     git-checkout-index -f -u -a &&
+     git read-tree -m $tree &&
+     git checkout-index -f -u -a &&
      mv file0 tmp &&
      mv file1 file0 &&
      mv tmp file1 &&
-     git-update-index file0 file1'
+     git update-index file0 file1'
 
 test_expect_success \
     'run diff with -B' \
-    'git-diff-index -B "$tree" >current'
+    'git diff-index -B "$tree" >current'
 
 cat >expected <<\EOF
 :100644 100644 f5deac7be59e7eeab8657fd9ae706fd6a57daed2 6ff87c4664981e4397625791c8ea3bbb5f2279a3 M100	file0
@@ -88,7 +88,7 @@ test_expect_success \
 
 test_expect_success \
     'run diff with -B and -M' \
-    'git-diff-index -B -M "$tree" >current'
+    'git diff-index -B -M "$tree" >current'
 
 cat >expected <<\EOF
 :100644 100644 6ff87c4664981e4397625791c8ea3bbb5f2279a3 6ff87c4664981e4397625791c8ea3bbb5f2279a3 R100	file1	file0
@@ -103,11 +103,11 @@ test_expect_success \
     'make file0 into something completely different' \
     'rm -f file0 &&
      ln -s frotz file0 &&
-     git-update-index file0 file1'
+     git update-index file0 file1'
 
 test_expect_success \
     'run diff with -B' \
-    'git-diff-index -B "$tree" >current'
+    'git diff-index -B "$tree" >current'
 
 cat >expected <<\EOF
 :100644 120000 f5deac7be59e7eeab8657fd9ae706fd6a57daed2 67be421f88824578857624f7b3dc75e99a8a1481 T	file0
@@ -120,7 +120,7 @@ test_expect_success \
 
 test_expect_success \
     'run diff with -B' \
-    'git-diff-index -B -M "$tree" >current'
+    'git diff-index -B -M "$tree" >current'
 
 # This should not mistake file0 as the copy source of new file1
 # due to type differences.
@@ -135,7 +135,7 @@ test_expect_success \
 
 test_expect_success \
     'run diff with -M' \
-    'git-diff-index -M "$tree" >current'
+    'git diff-index -M "$tree" >current'
 
 # This should not mistake file0 as the copy source of new file1
 # due to type differences.
@@ -151,16 +151,16 @@ test_expect_success \
 test_expect_success \
     'file1 edited to look like file0 and file0 rename-edited to file2' \
     'rm -f file0 file1 &&
-     git-read-tree -m $tree &&
-     git-checkout-index -f -u -a &&
+     git read-tree -m $tree &&
+     git checkout-index -f -u -a &&
      sed -e "s/git/GIT/" file0 >file1 &&
      sed -e "s/git/GET/" file0 >file2 &&
      rm -f file0
-     git-update-index --add --remove file0 file1 file2'
+     git update-index --add --remove file0 file1 file2'
 
 test_expect_success \
     'run diff with -B' \
-    'git-diff-index -B "$tree" >current'
+    'git diff-index -B "$tree" >current'
 
 cat >expected <<\EOF
 :100644 000000 f5deac7be59e7eeab8657fd9ae706fd6a57daed2 0000000000000000000000000000000000000000 D	file0
@@ -174,7 +174,7 @@ test_expect_success \
 
 test_expect_success \
     'run diff with -B -M' \
-    'git-diff-index -B -M "$tree" >current'
+    'git diff-index -B -M "$tree" >current'
 
 cat >expected <<\EOF
 :100644 100644 f5deac7be59e7eeab8657fd9ae706fd6a57daed2 08bb2fb671deff4c03a4d4a0a1315dff98d5732c C095	file0	file1
@@ -13,23 +13,23 @@ test_expect_success \
     'prepare reference tree' \
     'cat ../../COPYING >COPYING &&
      echo frotz >rezrov &&
-    git-update-index --add COPYING rezrov &&
-    tree=$(git-write-tree) &&
+    git update-index --add COPYING rezrov &&
+    tree=$(git write-tree) &&
     echo $tree'
 
 test_expect_success \
     'prepare work tree' \
     'sed -e 's/HOWEVER/However/' <COPYING >COPYING.1 &&
     sed -e 's/GPL/G.P.L/g' <COPYING >COPYING.2 &&
     rm -f COPYING &&
-    git-update-index --add --remove COPYING COPYING.?'
+    git update-index --add --remove COPYING COPYING.?'
 
 # tree has COPYING and rezrov.  work tree has COPYING.1 and COPYING.2,
 # both are slightly edited, and unchanged rezrov.  We say COPYING.1
 # and COPYING.2 are based on COPYING, and do not say anything about
 # rezrov.
 
-git-diff-index -z -M $tree >current
+git diff-index -z -M $tree >current
 
 cat >expected <<\EOF
 :100644 100644 6ff87c4664981e4397625791c8ea3bbb5f2279a3 0603b3238a076dc6c8022aedc6648fa523a17178 C1234
@@ -49,14 +49,14 @@ test_expect_success \
 test_expect_success \
     'prepare work tree again' \
     'mv COPYING.2 COPYING &&
-     git-update-index --add --remove COPYING COPYING.1 COPYING.2'
+     git update-index --add --remove COPYING COPYING.1 COPYING.2'
 
 # tree has COPYING and rezrov.  work tree has COPYING and COPYING.1,
 # both are slightly edited, and unchanged rezrov.  We say COPYING.1
 # is based on COPYING and COPYING is still there, and do not say anything
 # about rezrov.
 
-git-diff-index -z -C $tree >current
+git diff-index -z -C $tree >current
 cat >expected <<\EOF
 :100644 100644 6ff87c4664981e4397625791c8ea3bbb5f2279a3 06c67961bbaed34a127f76d261f4c0bf73eda471 M
 COPYING
@@ -79,9 +79,9 @@ test_expect_success \
 test_expect_success \
     'prepare work tree once again' \
     'cat ../../COPYING >COPYING &&
-     git-update-index --add --remove COPYING COPYING.1'
+     git update-index --add --remove COPYING COPYING.1'
 
-git-diff-index -z -C --find-copies-harder $tree >current
+git diff-index -z -C --find-copies-harder $tree >current
 cat >expected <<\EOF
 :100644 100644 6ff87c4664981e4397625791c8ea3bbb5f2279a3 0603b3238a076dc6c8022aedc6648fa523a17178 C1234
 COPYING
@@ -17,49 +17,49 @@ test_expect_success \
     'echo frotz >file0 &&
      mkdir path1 &&
      echo rezrov >path1/file1 &&
-     git-update-index --add file0 path1/file1 &&
-     tree=`git-write-tree` &&
+     git update-index --add file0 path1/file1 &&
+     tree=`git write-tree` &&
      echo "$tree" &&
      echo nitfol >file0 &&
      echo yomin >path1/file1 &&
-     git-update-index file0 path1/file1'
+     git update-index file0 path1/file1'
 
 cat >expected <<\EOF
 EOF
 test_expect_success \
     'limit to path should show nothing' \
-    'git-diff-index --cached $tree -- path >current &&
+    'git diff-index --cached $tree -- path >current &&
      compare_diff_raw current expected'
 
 cat >expected <<\EOF
 :100644 100644 766498d93a4b06057a8e49d23f4068f1170ff38f 0a41e115ab61be0328a19b29f18cdcb49338d516 M	path1/file1
 EOF
 test_expect_success \
     'limit to path1 should show path1/file1' \
-    'git-diff-index --cached $tree -- path1 >current &&
+    'git diff-index --cached $tree -- path1 >current &&
      compare_diff_raw current expected'
 
 cat >expected <<\EOF
 :100644 100644 766498d93a4b06057a8e49d23f4068f1170ff38f 0a41e115ab61be0328a19b29f18cdcb49338d516 M	path1/file1
 EOF
 test_expect_success \
     'limit to path1/ should show path1/file1' \
-    'git-diff-index --cached $tree -- path1/ >current &&
+    'git diff-index --cached $tree -- path1/ >current &&
      compare_diff_raw current expected'
 
 cat >expected <<\EOF
 :100644 100644 766498d93a4b06057a8e49d23f4068f1170ff38f 0a41e115ab61be0328a19b29f18cdcb49338d516 M	file0
 EOF
 test_expect_success \
     'limit to file0 should show file0' \
-    'git-diff-index --cached $tree -- file0 >current &&
+    'git diff-index --cached $tree -- file0 >current &&
      compare_diff_raw current expected'
 
 cat >expected <<\EOF
 EOF
 test_expect_success \
     'limit to file0/ should emit nothing.' \
-    'git-diff-index --cached $tree -- file0/ >current &&
+    'git diff-index --cached $tree -- file0/ >current &&
      compare_diff_raw current expected'
 
 test_done
@@ -23,17 +23,17 @@ EOF
 test_expect_success \
     'diff new symlink' \
     'ln -s xyzzy frotz &&
-    git-update-index &&
-    tree=$(git-write-tree) &&
-    git-update-index --add frotz &&
-    GIT_DIFF_OPTS=--unified=0 git-diff-index -M -p $tree > current &&
+    git update-index &&
+    tree=$(git write-tree) &&
+    git update-index --add frotz &&
+    GIT_DIFF_OPTS=--unified=0 git diff-index -M -p $tree > current &&
     compare_diff_patch current expected'
 
 test_expect_success \
     'diff unchanged symlink' \
-    'tree=$(git-write-tree) &&
-    git-update-index frotz &&
-    test -z "$(git-diff-index --name-only $tree)"'
+    'tree=$(git write-tree) &&
+    git update-index frotz &&
+    test -z "$(git diff-index --name-only $tree)"'
 
 cat > expected << EOF
 diff --git a/frotz b/frotz
@@ -49,7 +49,7 @@ EOF
 test_expect_success \
     'diff removed symlink' \
     'rm frotz &&
-    git-diff-index -M -p $tree > current &&
+    git diff-index -M -p $tree > current &&
     compare_diff_patch current expected'
 
 cat > expected << EOF
@@ -60,7 +60,7 @@ test_expect_success \
     'diff identical, but newly created symlink' \
     'sleep 3 &&
     ln -s xyzzy frotz &&
-    git-diff-index -M -p $tree > current &&
+    git diff-index -M -p $tree > current &&
     compare_diff_patch current expected'
 
 cat > expected << EOF
@@ -79,7 +79,7 @@ test_expect_success \
     'diff different symlink' \
     'rm frotz &&
     ln -s yxyyz frotz &&
-    git-diff-index -M -p $tree > current &&
+    git diff-index -M -p $tree > current &&
     compare_diff_patch current expected'
 
 test_done
@@ -10,7 +10,7 @@ test_description='Binary diff and apply
 
 test_expect_success 'prepare repository' \
 	'echo AIT >a && echo BIT >b && echo CIT >c && echo DIT >d &&
-	 git-update-index --add a b c d &&
+	 git update-index --add a b c d &&
 	 echo git >a &&
 	 cat ../test4012.png >b &&
 	 echo git >c &&
@@ -24,18 +24,18 @@ cat > expected <<\EOF
  4 files changed, 2 insertions(+), 2 deletions(-)
 EOF
 test_expect_success 'diff without --binary' \
-	'git-diff | git-apply --stat --summary >current &&
+	'git diff | git apply --stat --summary >current &&
 	 cmp current expected'
 
 test_expect_success 'diff with --binary' \
-	'git-diff --binary | git-apply --stat --summary >current &&
+	'git diff --binary | git apply --stat --summary >current &&
 	 cmp current expected'
 
 # apply needs to be able to skip the binary material correctly
 # in order to report the line number of a corrupt patch.
 test_expect_success 'apply detecting corrupt patch correctly' \
-	'git-diff | sed -e 's/-CIT/xCIT/' >broken &&
-	 if git-apply --stat --summary broken 2>detected
+	'git diff | sed -e 's/-CIT/xCIT/' >broken &&
+	 if git apply --stat --summary broken 2>detected
 	 then
 		echo unhappy - should have detected an error
 		(exit 1)
@@ -48,8 +48,8 @@ test_expect_success 'apply detecting corrupt patch correctly' \
 	 test "$detected" = xCIT'
 
 test_expect_success 'apply detecting corrupt patch correctly' \
-	'git-diff --binary | sed -e 's/-CIT/xCIT/' >broken &&
-	 if git-apply --stat --summary broken 2>detected
+	'git diff --binary | sed -e 's/-CIT/xCIT/' >broken &&
+	 if git apply --stat --summary broken 2>detected
 	 then
 		echo unhappy - should have detected an error
 		(exit 1)
@@ -66,15 +66,15 @@ test_expect_success 'initial commit' 'git-commit -a -m initial'
 # Try removal (b), modification (d), and creation (e).
 test_expect_success 'diff-index with --binary' \
 	'echo AIT >a && mv b e && echo CIT >c && cat e >d &&
-	 git-update-index --add --remove a b c d e &&
-	 tree0=`git-write-tree` &&
-	 git-diff --cached --binary >current &&
-	 git-apply --stat --summary current'
+	 git update-index --add --remove a b c d e &&
+	 tree0=`git write-tree` &&
+	 git diff --cached --binary >current &&
+	 git apply --stat --summary current'
 
 test_expect_success 'apply binary patch' \
 	'git-reset --hard &&
-	 git-apply --binary --index <current &&
-	 tree1=`git-write-tree` &&
+	 git apply --binary --index <current &&
+	 tree1=`git write-tree` &&
 	 test "$tree1" = "$tree0"'
 
 test_done
@@ -17,7 +17,7 @@ do {
 } while (0);
 EOF
 
-git-update-index --add x
+git update-index --add x
 
 cat << EOF > x
 do
@@ -42,13 +42,13 @@ index adf3937..6edc172 100644
 +while (0);
 EOF
 
-git-diff > out
+git diff > out
 test_expect_success "Ray's example without options" 'git diff expect out'
 
-git-diff -w > out
+git diff -w > out
 test_expect_success "Ray's example with -w" 'git diff expect out'
 
-git-diff -b > out
+git diff -b > out
 test_expect_success "Ray's example with -b" 'git diff expect out'
 
 tr 'Q' '\015' << EOF > x
@@ -60,7 +60,7 @@ unchanged line
 CR at endQ
 EOF
 
-git-update-index x
+git update-index x
 
 cat << EOF > x
 	whitespace at beginning
@@ -89,14 +89,14 @@ index d99af23..8b32fb5 100644
 -CR at endQ
 +CR at end
 EOF
-git-diff > out
+git diff > out
 test_expect_success 'another test, without options' 'git diff expect out'
 
 cat << EOF > expect
 diff --git a/x b/x
 index d99af23..8b32fb5 100644
 EOF
-git-diff -w > out
+git diff -w > out
 test_expect_success 'another test, with -w' 'git diff expect out'
 
 tr 'Q' '\015' << EOF > expect
@@ -114,7 +114,7 @@ index d99af23..8b32fb5 100644
  unchanged line
  CR at endQ
 EOF
-git-diff -b > out
+git diff -b > out
 test_expect_success 'another test, with -b' 'git diff expect out'
 
 test_done
@@ -3,44 +3,44 @@
 # Copyright (c) 2005 Junio C Hamano
 #
 
-test_description='git-apply --stat --summary test.
+test_description='git apply --stat --summary test.
 
 '
 . ./test-lib.sh
 
 test_expect_success \
     'rename' \
-    'git-apply --stat --summary <../t4100/t-apply-1.patch >current &&
+    'git apply --stat --summary <../t4100/t-apply-1.patch >current &&
     git diff ../t4100/t-apply-1.expect current'
 
 test_expect_success \
     'copy' \
-    'git-apply --stat --summary <../t4100/t-apply-2.patch >current &&
+    'git apply --stat --summary <../t4100/t-apply-2.patch >current &&
     git diff ../t4100/t-apply-2.expect current'
 
 test_expect_success \
     'rewrite' \
-    'git-apply --stat --summary <../t4100/t-apply-3.patch >current &&
+    'git apply --stat --summary <../t4100/t-apply-3.patch >current &&
     git diff ../t4100/t-apply-3.expect current'
 
 test_expect_success \
     'mode' \
-    'git-apply --stat --summary <../t4100/t-apply-4.patch >current &&
+    'git apply --stat --summary <../t4100/t-apply-4.patch >current &&
     git diff ../t4100/t-apply-4.expect current'
 
 test_expect_success \
     'non git' \
-    'git-apply --stat --summary <../t4100/t-apply-5.patch >current &&
+    'git apply --stat --summary <../t4100/t-apply-5.patch >current &&
     git diff ../t4100/t-apply-5.expect current'
 
 test_expect_success \
     'non git' \
-    'git-apply --stat --summary <../t4100/t-apply-6.patch >current &&
+    'git apply --stat --summary <../t4100/t-apply-6.patch >current &&
     git diff ../t4100/t-apply-6.expect current'
 
 test_expect_success \
     'non git' \
-    'git-apply --stat --summary <../t4100/t-apply-7.patch >current &&
+    'git apply --stat --summary <../t4100/t-apply-7.patch >current &&
     git diff ../t4100/t-apply-7.expect current'
 
 test_done
@@ -3,7 +3,7 @@
 # Copyright (c) 2005 Junio C Hamano
 #
 
-test_description='git-apply should handle files with incomplete lines.
+test_description='git apply should handle files with incomplete lines.
 
 '
 . ./test-lib.sh
@@ -23,7 +23,7 @@ do
     cat frotz.$i >frotz
     test_expect_success \
         "apply diff between $i and $j" \
-	"git-apply <../t4101/diff.$i-$j && diff frotz.$j frotz"
+	"git apply <../t4101/diff.$i-$j && diff frotz.$j frotz"
   done
 done
 
@@ -3,7 +3,7 @@
 # Copyright (c) 2005 Junio C Hamano
 #
 
-test_description='git-apply handling copy/rename patch.
+test_description='git apply handling copy/rename patch.
 
 '
 . ./test-lib.sh
@@ -26,10 +26,10 @@ echo 'This is foo' >foo
 chmod +x foo
 
 test_expect_success setup \
-    'git-update-index --add foo'
+    'git update-index --add foo'
 
 test_expect_success apply \
-    'git-apply --index --stat --summary --apply test-patch'
+    'git apply --index --stat --summary --apply test-patch'
 
 if [ "$(git config --get core.filemode)" = false ]
 then
@@ -40,7 +40,7 @@ else
 fi
 
 test_expect_success 'apply reverse' \
-    'git-apply -R --index --stat --summary --apply test-patch &&
+    'git apply -R --index --stat --summary --apply test-patch &&
      test "$(cat foo)" = "This is foo"'
 
 cat >test-patch <<\EOF
@@ -56,7 +56,7 @@ copy to bar
 EOF
 
 test_expect_success 'apply copy' \
-    'git-apply --index --stat --summary --apply test-patch &&
+    'git apply --index --stat --summary --apply test-patch &&
      test "$(cat bar)" = "This is bar" -a "$(cat foo)" = "This is foo"'
 
 test_done
@@ -3,7 +3,7 @@
 # Copyright (c) 2005 Junio C Hamano
 #
 
-test_description='git-apply handling binary patches
+test_description='git apply handling binary patches
 
 '
 . ./test-lib.sh
@@ -20,55 +20,55 @@ EOF
 cat file1 >file2
 cat file1 >file4
 
-git-update-index --add --remove file1 file2 file4
+git update-index --add --remove file1 file2 file4
 git-commit -m 'Initial Version' 2>/dev/null
 
 git-checkout -b binary
 tr 'x' '\0' <file1 >file3
 cat file3 >file4
-git-add file2
+git add file2
 tr '\0' 'v' <file3 >file1
 rm -f file2
-git-update-index --add --remove file1 file2 file3 file4
+git update-index --add --remove file1 file2 file3 file4
 git-commit -m 'Second Version'
 
-git-diff-tree -p master binary >B.diff
-git-diff-tree -p -C master binary >C.diff
+git diff-tree -p master binary >B.diff
+git diff-tree -p -C master binary >C.diff
 
-git-diff-tree -p --binary master binary >BF.diff
-git-diff-tree -p --binary -C master binary >CF.diff
+git diff-tree -p --binary master binary >BF.diff
+git diff-tree -p --binary -C master binary >CF.diff
 
 test_expect_success 'stat binary diff -- should not fail.' \
 	'git-checkout master
-	 git-apply --stat --summary B.diff'
+	 git apply --stat --summary B.diff'
 
 test_expect_success 'stat binary diff (copy) -- should not fail.' \
 	'git-checkout master
-	 git-apply --stat --summary C.diff'
+	 git apply --stat --summary C.diff'
 
 test_expect_failure 'check binary diff -- should fail.' \
 	'git-checkout master
-	 git-apply --check B.diff'
+	 git apply --check B.diff'
 
 test_expect_failure 'check binary diff (copy) -- should fail.' \
 	'git-checkout master
-	 git-apply --check C.diff'
+	 git apply --check C.diff'
 
 test_expect_failure 'check incomplete binary diff with replacement -- should fail.' \
 	'git-checkout master
-	 git-apply --check --allow-binary-replacement B.diff'
+	 git apply --check --allow-binary-replacement B.diff'
 
 test_expect_failure 'check incomplete binary diff with replacement (copy) -- should fail.' \
 	'git-checkout master
-	 git-apply --check --allow-binary-replacement C.diff'
+	 git apply --check --allow-binary-replacement C.diff'
 
 test_expect_success 'check binary diff with replacement.' \
 	'git-checkout master
-	 git-apply --check --allow-binary-replacement BF.diff'
+	 git apply --check --allow-binary-replacement BF.diff'
 
 test_expect_success 'check binary diff with replacement (copy).' \
 	'git-checkout master
-	 git-apply --check --allow-binary-replacement CF.diff'
+	 git apply --check --allow-binary-replacement CF.diff'
 
 # Now we start applying them.
 
@@ -80,36 +80,36 @@ do_reset () {
 
 test_expect_failure 'apply binary diff -- should fail.' \
 	'do_reset
-	 git-apply B.diff'
+	 git apply B.diff'
 
 test_expect_failure 'apply binary diff -- should fail.' \
 	'do_reset
-	 git-apply --index B.diff'
+	 git apply --index B.diff'
 
 test_expect_failure 'apply binary diff (copy) -- should fail.' \
 	'do_reset
-	 git-apply C.diff'
+	 git apply C.diff'
 
 test_expect_failure 'apply binary diff (copy) -- should fail.' \
 	'do_reset
-	 git-apply --index C.diff'
+	 git apply --index C.diff'
 
 test_expect_success 'apply binary diff without replacement.' \
 	'do_reset
-	 git-apply BF.diff'
+	 git apply BF.diff'
 
 test_expect_success 'apply binary diff without replacement (copy).' \
 	'do_reset
-	 git-apply CF.diff'
+	 git apply CF.diff'
 
 test_expect_success 'apply binary diff.' \
 	'do_reset
-	 git-apply --allow-binary-replacement --index BF.diff &&
-	 test -z "$(git-diff --name-status binary)"'
+	 git apply --allow-binary-replacement --index BF.diff &&
+	 test -z "$(git diff --name-status binary)"'
 
 test_expect_success 'apply binary diff (copy).' \
 	'do_reset
-	 git-apply --allow-binary-replacement --index CF.diff &&
-	 test -z "$(git-diff --name-status binary)"'
+	 git apply --allow-binary-replacement --index CF.diff &&
+	 test -z "$(git diff --name-status binary)"'
 
 test_done
@@ -3,7 +3,7 @@
 # Copyright (c) 2005 Junio C Hamano
 #
 
-test_description='git-apply boundary tests
+test_description='git apply boundary tests
 
 '
 . ./test-lib.sh
@@ -4,7 +4,7 @@
 # Copyright (c) 2005 Robert Fitzsimons
 #
 
-test_description='git-apply test patches with multiple fragments.
+test_description='git apply test patches with multiple fragments.
 
 '
 . ./test-lib.sh
@@ -138,8 +138,8 @@ diff --git a/main.c b/main.c
  
 EOF
 
-test_expect_success "S = git-apply (1)" \
-    'git-apply patch1.patch patch2.patch'
+test_expect_success "S = git apply (1)" \
+    'git apply patch1.patch patch2.patch'
 mv main.c main.c.git
 
 test_expect_success "S = patch (1)" \
@@ -150,8 +150,8 @@ test_expect_success "S = cmp (1)" \
 
 rm -f main.c main.c.git
 
-test_expect_success "S = git-apply (2)" \
-    'git-apply patch1.patch patch2.patch patch3.patch'
+test_expect_success "S = git apply (2)" \
+    'git apply patch1.patch patch2.patch patch3.patch'
 mv main.c main.c.git
 
 test_expect_success "S = patch (2)" \
@@ -162,8 +162,8 @@ test_expect_success "S = cmp (2)" \
 
 rm -f main.c main.c.git
 
-test_expect_success "S = git-apply (3)" \
-    'git-apply patch1.patch patch4.patch'
+test_expect_success "S = git apply (3)" \
+    'git apply patch1.patch patch4.patch'
 mv main.c main.c.git
 
 test_expect_success "S = patch (3)" \
@@ -4,7 +4,7 @@
 # Copyright (c) 2005 Robert Fitzsimons
 #
 
-test_description='git-apply test for patches which require scanning forwards and backwards.
+test_description='git apply test for patches which require scanning forwards and backwards.
 
 '
 . ./test-lib.sh
@@ -86,8 +86,8 @@ diff --git a/new.txt b/new.txt
 +c2222
 EOF
 
-test_expect_success "S = git-apply scan" \
-    'git-apply patch1.patch patch2.patch patch3.patch patch4.patch patch5.patch'
+test_expect_success "S = git apply scan" \
+    'git apply patch1.patch patch2.patch patch3.patch patch4.patch patch5.patch'
 mv new.txt apply.txt
 
 test_expect_success "S = patch scan" \
@@ -3,7 +3,7 @@
 # Copyright (c) 2005 Junio C Hamano
 #
 
-test_description='git-apply should not get confused with rename/copy.
+test_description='git apply should not get confused with rename/copy.
 
 '
 
@@ -115,10 +115,10 @@ rename to include/arch/m32r/klibc/archsetjmp.h
 +#endif /* _KLIBC_ARCHSETJMP_H */
 EOF
 
-find klibc -type f -print | xargs git-update-index --add --
+find klibc -type f -print | xargs git update-index --add --
 
-test_expect_success 'check rename/copy patch' 'git-apply --check patch'
+test_expect_success 'check rename/copy patch' 'git apply --check patch'
 
-test_expect_success 'apply rename/copy patch' 'git-apply --index patch'
+test_expect_success 'apply rename/copy patch' 'git apply --index patch'
 
 test_done
@@ -3,7 +3,7 @@
 # Copyright (c) 2006 Catalin Marinas
 #
 
-test_description='git-apply trying to add an ending line.
+test_description='git apply trying to add an ending line.
 
 '
 . ./test-lib.sh
@@ -25,12 +25,12 @@ echo 'b' >>file
 echo 'c' >>file
 
 test_expect_success setup \
-    'git-update-index --add file'
+    'git update-index --add file'
 
 # test
 
 test_expect_failure 'apply at the end' \
-    'git-apply --index test-patch'
+    'git apply --index test-patch'
 
 cat >test-patch <<\EOF
 diff a/file b/file
@@ -45,9 +45,9 @@ EOF
 echo >file 'a
 b
 c'
-git-update-index file
+git update-index file
 
 test_expect_failure 'apply at the beginning' \
-	'git-apply --index test-patch'
+	'git apply --index test-patch'
 
 test_done
@@ -3,7 +3,7 @@
 # Copyright (c) 2006 Eric Wong
 #
 
-test_description='git-apply should not get confused with type changes.
+test_description='git apply should not get confused with type changes.
 
 '
 
@@ -3,7 +3,7 @@
 # Copyright (c) 2005 Junio C Hamano
 #
 
-test_description='git-apply symlinks and partial files
+test_description='git apply symlinks and partial files
 
 '
 
@@ -3,7 +3,7 @@
 # Copyright (c) 2005 Junio C Hamano
 #
 
-test_description='git-apply in reverse
+test_description='git apply in reverse
 
 '
 
@@ -3,7 +3,7 @@
 # Copyright (c) 2005 Junio C Hamano
 #
 
-test_description='git-apply with rejects
+test_description='git apply with rejects
 
 '
 
@@ -3,7 +3,7 @@
 # Copyright (c) 2006 Junio C Hamano
 #
 
-test_description='git-apply with new style GNU diff with empty context
+test_description='git apply with new style GNU diff with empty context
 
 '
 
@@ -3,7 +3,7 @@
 # Copyright (c) 2007 Junio C Hamano
 #
 
-test_description='git-apply --whitespace=strip and configuration file.
+test_description='git apply --whitespace=strip and configuration file.
 
 '
 
@@ -3,7 +3,7 @@
 # Copyright (c) 2007 Shawn O. Pearce
 #
 
-test_description='git-apply -p handling.'
+test_description='git apply -p handling.'
 
 . ./test-lib.sh
 
@@ -1,6 +1,6 @@
 #!/bin/sh
 
-test_description='git-apply for contextually independent diffs'
+test_description='git apply for contextually independent diffs'
 . ./test-lib.sh
 
 echo '1
@@ -3,7 +3,7 @@
 # Copyright (c) 2006 Johannes E. Schindelin
 #
 
-test_description='git-rerere
+test_description='git rerere
 '
 
 . ./test-lib.sh
@@ -3,7 +3,7 @@
 # Copyright (c) 2006 Johannes E. Schindelin
 #
 
-test_description='git-shortlog
+test_description='git shortlog
 '
 
 . ./test-lib.sh
@@ -3,7 +3,7 @@
 # Copyright (C) 2005 Rene Scharfe
 #
 
-test_description='git-tar-tree and git-get-tar-commit-id test
+test_description='git tar-tree and git get-tar-commit-id test
 
 This test covers the topics of file contents, commit date handling and
 commit id embedding:
@@ -13,13 +13,13 @@ commit id embedding:
   binary file (/bin/sh).  Only paths shorter than 99 characters are
   used.
 
-  git-tar-tree applies the commit date to every file in the archive it
+  git tar-tree applies the commit date to every file in the archive it
   creates.  The test sets the commit date to a specific value and checks
   if the tar archive contains that value.
 
-  When giving git-tar-tree a commit id (in contrast to a tree id) it
+  When giving git tar-tree a commit id (in contrast to a tree id) it
   embeds this commit id into the tar archive as a comment.  The test
-  checks the ability of git-get-tar-commit-id to figure it out from the
+  checks the ability of git get-tar-commit-id to figure it out from the
   tar file.
 
 '
@@ -42,23 +42,23 @@ test_expect_success \
 
 test_expect_success \
     'add files to repository' \
-    'find a -type f | xargs git-update-index --add &&
-     find a -type l | xargs git-update-index --add &&
-     treeid=`git-write-tree` &&
+    'find a -type f | xargs git update-index --add &&
+     find a -type l | xargs git update-index --add &&
+     treeid=`git write-tree` &&
      echo $treeid >treeid &&
-     git-update-ref HEAD $(TZ=GMT GIT_COMMITTER_DATE="2005-05-27 22:00:00" \
-     git-commit-tree $treeid </dev/null)'
+     git update-ref HEAD $(TZ=GMT GIT_COMMITTER_DATE="2005-05-27 22:00:00" \
+     git commit-tree $treeid </dev/null)'
 
 test_expect_success \
-    'git-archive' \
-    'git-archive HEAD >b.tar'
+    'git archive' \
+    'git archive HEAD >b.tar'
 
 test_expect_success \
-    'git-tar-tree' \
-    'git-tar-tree HEAD >b2.tar'
+    'git tar-tree' \
+    'git tar-tree HEAD >b2.tar'
 
 test_expect_success \
-    'git-archive vs. git-tar-tree' \
+    'git archive vs. git tar-tree' \
     'diff b.tar b2.tar'
 
 test_expect_success \
@@ -70,9 +70,9 @@ test_expect_success \
      diff expected.mtime b.mtime'
 
 test_expect_success \
-    'git-get-tar-commit-id' \
-    'git-get-tar-commit-id <b.tar >b.commitid &&
-     diff .git/$(git-symbolic-ref HEAD) b.commitid'
+    'git get-tar-commit-id' \
+    'git get-tar-commit-id <b.tar >b.commitid &&
+     diff .git/$(git symbolic-ref HEAD) b.commitid'
 
 test_expect_success \
     'extract tar archive' \
@@ -88,8 +88,8 @@ test_expect_success \
     'diff -r a b/a'
 
 test_expect_success \
-    'git-tar-tree with prefix' \
-    'git-tar-tree HEAD prefix >c.tar'
+    'git tar-tree with prefix' \
+    'git tar-tree HEAD prefix >c.tar'
 
 test_expect_success \
     'extract tar archive with prefix' \
@@ -105,8 +105,8 @@ test_expect_success \
     'diff -r a c/prefix/a'
 
 test_expect_success \
-    'git-archive --format=zip' \
-    'git-archive --format=zip HEAD >d.zip'
+    'git archive --format=zip' \
+    'git archive --format=zip HEAD >d.zip'
 
 $UNZIP -v >/dev/null 2>&1
 if [ $? -eq 127 ]; then
@@ -129,8 +129,8 @@ test_expect_success \
     'diff -r a d/a'
 
 test_expect_success \
-    'git-archive --format=zip with prefix' \
-    'git-archive --format=zip --prefix=prefix/ HEAD >e.zip'
+    'git archive --format=zip with prefix' \
+    'git archive --format=zip --prefix=prefix/ HEAD >e.zip'
 
 test_expect_success \
     'extract ZIP archive with prefix' \
@@ -146,7 +146,7 @@ test_expect_success \
     'diff -r a e/prefix/a'
 
 test_expect_success \
-    'git-archive --list outside of a git repo' \
-    'GIT_DIR=some/non-existing/directory git-archive --list'
+    'git archive --list outside of a git repo' \
+    'GIT_DIR=some/non-existing/directory git archive --list'
 
 test_done
@@ -3,20 +3,20 @@
 # Copyright (c) 2005 Junio C Hamano
 #
 
-test_description='git-mailinfo and git-mailsplit test'
+test_description='git mailinfo and git mailsplit test'
 
 . ./test-lib.sh
 
 test_expect_success 'split sample box' \
-	'git-mailsplit -o. ../t5100/sample.mbox >last &&
+	'git mailsplit -o. ../t5100/sample.mbox >last &&
 	last=`cat last` &&
 	echo total is $last &&
 	test `cat last` = 8'
 
 for mail in `echo 00*`
 do
 	test_expect_success "mailinfo $mail" \
-		"git-mailinfo -u msg$mail patch$mail <$mail >info$mail &&
+		"git mailinfo -u msg$mail patch$mail <$mail >info$mail &&
 		echo msg &&
 		diff ../t5100/msg$mail msg$mail &&
 		echo patch &&
@@ -16,26 +16,26 @@ test_expect_success \
      for i in a b c
      do
 	     dd if=/dev/zero bs=4k count=1 | tr "\\0" $i >$i &&
-	     git-update-index --add $i || return 1
+	     git update-index --add $i || return 1
      done &&
-     cat c >d && echo foo >>d && git-update-index --add d &&
-     tree=`git-write-tree` &&
-     commit=`git-commit-tree $tree </dev/null` && {
+     cat c >d && echo foo >>d && git update-index --add d &&
+     tree=`git write-tree` &&
+     commit=`git commit-tree $tree </dev/null` && {
 	 echo $tree &&
 	 echo $commit &&
-	 git-ls-tree $tree | sed -e "s/.* \\([0-9a-f]*\\)	.*/\\1/"
+	 git ls-tree $tree | sed -e "s/.* \\([0-9a-f]*\\)	.*/\\1/"
      } >obj-list && {
-	 git-diff-tree --root -p $commit &&
+	 git diff-tree --root -p $commit &&
 	 while read object
 	 do
-	    t=`git-cat-file -t $object` &&
-	    git-cat-file $t $object || return 1
+	    t=`git cat-file -t $object` &&
+	    git cat-file $t $object || return 1
 	 done <obj-list
      } >expect'
 
 test_expect_success \
     'pack without delta' \
-    'packname_1=$(git-pack-objects --window=0 test-1 <obj-list)'
+    'packname_1=$(git pack-objects --window=0 test-1 <obj-list)'
 
 rm -fr .git2
 mkdir .git2
@@ -44,9 +44,9 @@ test_expect_success \
     'unpack without delta' \
     "GIT_OBJECT_DIRECTORY=.git2/objects &&
      export GIT_OBJECT_DIRECTORY &&
-     git-init &&
-     git-unpack-objects -n <test-1-${packname_1}.pack &&
-     git-unpack-objects <test-1-${packname_1}.pack"
+     git init &&
+     git unpack-objects -n <test-1-${packname_1}.pack &&
+     git unpack-objects <test-1-${packname_1}.pack"
 
 unset GIT_OBJECT_DIRECTORY
 cd "$TRASH/.git2"
@@ -66,7 +66,7 @@ cd "$TRASH"
 test_expect_success \
     'pack with REF_DELTA' \
     'pwd &&
-     packname_2=$(git-pack-objects test-2 <obj-list)'
+     packname_2=$(git pack-objects test-2 <obj-list)'
 
 rm -fr .git2
 mkdir .git2
@@ -75,9 +75,9 @@ test_expect_success \
     'unpack with REF_DELTA' \
     'GIT_OBJECT_DIRECTORY=.git2/objects &&
      export GIT_OBJECT_DIRECTORY &&
-     git-init &&
-     git-unpack-objects -n <test-2-${packname_2}.pack &&
-     git-unpack-objects <test-2-${packname_2}.pack'
+     git init &&
+     git unpack-objects -n <test-2-${packname_2}.pack &&
+     git unpack-objects <test-2-${packname_2}.pack'
 
 unset GIT_OBJECT_DIRECTORY
 cd "$TRASH/.git2"
@@ -96,7 +96,7 @@ cd "$TRASH"
 test_expect_success \
     'pack with OFS_DELTA' \
     'pwd &&
-     packname_3=$(git-pack-objects --delta-base-offset test-3 <obj-list)'
+     packname_3=$(git pack-objects --delta-base-offset test-3 <obj-list)'
 
 rm -fr .git2
 mkdir .git2
@@ -105,9 +105,9 @@ test_expect_success \
     'unpack with OFS_DELTA' \
     'GIT_OBJECT_DIRECTORY=.git2/objects &&
      export GIT_OBJECT_DIRECTORY &&
-     git-init &&
-     git-unpack-objects -n <test-3-${packname_3}.pack &&
-     git-unpack-objects <test-3-${packname_3}.pack'
+     git init &&
+     git unpack-objects -n <test-3-${packname_3}.pack &&
+     git unpack-objects <test-3-${packname_3}.pack'
 
 unset GIT_OBJECT_DIRECTORY
 cd "$TRASH/.git2"
@@ -137,13 +137,13 @@ test_expect_success \
     'use packed objects' \
     'GIT_OBJECT_DIRECTORY=.git2/objects &&
      export GIT_OBJECT_DIRECTORY &&
-     git-init &&
+     git init &&
      cp test-1-${packname_1}.pack test-1-${packname_1}.idx .git2/objects/pack && {
-	 git-diff-tree --root -p $commit &&
+	 git diff-tree --root -p $commit &&
 	 while read object
 	 do
-	    t=`git-cat-file -t $object` &&
-	    git-cat-file $t $object || return 1
+	    t=`git cat-file -t $object` &&
+	    git cat-file $t $object || return 1
 	 done <obj-list
     } >current &&
     diff expect current'
@@ -154,11 +154,11 @@ test_expect_success \
      export GIT_OBJECT_DIRECTORY &&
      rm -f .git2/objects/pack/test-* &&
      cp test-2-${packname_2}.pack test-2-${packname_2}.idx .git2/objects/pack && {
-	 git-diff-tree --root -p $commit &&
+	 git diff-tree --root -p $commit &&
 	 while read object
 	 do
-	    t=`git-cat-file -t $object` &&
-	    git-cat-file $t $object || return 1
+	    t=`git cat-file -t $object` &&
+	    git cat-file $t $object || return 1
 	 done <obj-list
     } >current &&
     diff expect current'
@@ -169,11 +169,11 @@ test_expect_success \
      export GIT_OBJECT_DIRECTORY &&
      rm -f .git2/objects/pack/test-* &&
      cp test-3-${packname_3}.pack test-3-${packname_3}.idx .git2/objects/pack && {
-	 git-diff-tree --root -p $commit &&
+	 git diff-tree --root -p $commit &&
 	 while read object
 	 do
-	    t=`git-cat-file -t $object` &&
-	    git-cat-file $t $object || return 1
+	    t=`git cat-file -t $object` &&
+	    git cat-file $t $object || return 1
 	 done <obj-list
     } >current &&
     diff expect current'
@@ -182,39 +182,39 @@ unset GIT_OBJECT_DIRECTORY
 
 test_expect_success \
     'verify pack' \
-    'git-verify-pack	test-1-${packname_1}.idx \
+    'git verify-pack	test-1-${packname_1}.idx \
 			test-2-${packname_2}.idx \
 			test-3-${packname_3}.idx'
 
 test_expect_success \
     'corrupt a pack and see if verify catches' \
     'cat test-1-${packname_1}.idx >test-3.idx &&
      cat test-2-${packname_2}.pack >test-3.pack &&
-     if git-verify-pack test-3.idx
+     if git verify-pack test-3.idx
      then false
      else :;
      fi &&
 
      : PACK_SIGNATURE &&
      cat test-1-${packname_1}.pack >test-3.pack &&
      dd if=/dev/zero of=test-3.pack count=1 bs=1 conv=notrunc seek=2 &&
-     if git-verify-pack test-3.idx
+     if git verify-pack test-3.idx
      then false
      else :;
      fi &&
 
      : PACK_VERSION &&
      cat test-1-${packname_1}.pack >test-3.pack &&
      dd if=/dev/zero of=test-3.pack count=1 bs=1 conv=notrunc seek=7 &&
-     if git-verify-pack test-3.idx
+     if git verify-pack test-3.idx
      then false
      else :;
      fi &&
 
      : TYPE/SIZE byte of the first packed object data &&
      cat test-1-${packname_1}.pack >test-3.pack &&
      dd if=/dev/zero of=test-3.pack count=1 bs=1 conv=notrunc seek=12 &&
-     if git-verify-pack test-3.idx
+     if git verify-pack test-3.idx
      then false
      else :;
      fi &&
@@ -224,7 +224,7 @@ test_expect_success \
      l=`expr $l - 20` &&
      cat test-1-${packname_1}.pack >test-3.pack &&
      dd if=/dev/zero of=test-3.idx count=20 bs=1 conv=notrunc seek=$l &&
-     if git-verify-pack test-3.pack
+     if git verify-pack test-3.pack
      then false
      else :;
      fi &&
@@ -13,48 +13,48 @@ test_expect_success \
      do
          echo $i >$i &&
          test-genrandom "$i" 32768 >>$i &&
-         git-update-index --add $i || return 1
+         git update-index --add $i || return 1
      done &&
-     echo d >d && cat c >>d && git-update-index --add d &&
-     tree=`git-write-tree` &&
-     commit1=`git-commit-tree $tree </dev/null` &&
-     git-update-ref HEAD $commit1 &&
+     echo d >d && cat c >>d && git update-index --add d &&
+     tree=`git write-tree` &&
+     commit1=`git commit-tree $tree </dev/null` &&
+     git update-ref HEAD $commit1 &&
      git-repack -a -d &&
-     test "`git-count-objects`" = "0 objects, 0 kilobytes" &&
+     test "`git count-objects`" = "0 objects, 0 kilobytes" &&
      pack1=`ls .git/objects/pack/*.pack` &&
      test -f "$pack1"'
 
 test_expect_success \
     'verify-pack -v, defaults' \
-    'git-verify-pack -v "$pack1"'
+    'git verify-pack -v "$pack1"'
 
 test_expect_success \
     'verify-pack -v, packedGitWindowSize == 1 page' \
-    'git-config core.packedGitWindowSize 512 &&
-     git-verify-pack -v "$pack1"'
+    'git config core.packedGitWindowSize 512 &&
+     git verify-pack -v "$pack1"'
 
 test_expect_success \
     'verify-pack -v, packedGit{WindowSize,Limit} == 1 page' \
-    'git-config core.packedGitWindowSize 512 &&
-     git-config core.packedGitLimit 512 &&
-     git-verify-pack -v "$pack1"'
+    'git config core.packedGitWindowSize 512 &&
+     git config core.packedGitLimit 512 &&
+     git verify-pack -v "$pack1"'
 
 test_expect_success \
     'repack -a -d, packedGit{WindowSize,Limit} == 1 page' \
-    'git-config core.packedGitWindowSize 512 &&
-     git-config core.packedGitLimit 512 &&
-     commit2=`git-commit-tree $tree -p $commit1 </dev/null` &&
-     git-update-ref HEAD $commit2 &&
+    'git config core.packedGitWindowSize 512 &&
+     git config core.packedGitLimit 512 &&
+     commit2=`git commit-tree $tree -p $commit1 </dev/null` &&
+     git update-ref HEAD $commit2 &&
      git-repack -a -d &&
-     test "`git-count-objects`" = "0 objects, 0 kilobytes" &&
+     test "`git count-objects`" = "0 objects, 0 kilobytes" &&
      pack2=`ls .git/objects/pack/*.pack` &&
      test -f "$pack2"
      test "$pack1" \!= "$pack2"'
 
 test_expect_success \
     'verify-pack -v, defaults' \
-    'git-config --unset core.packedGitWindowSize &&
-     git-config --unset core.packedGitLimit &&
-     git-verify-pack -v "$pack2"'
+    'git config --unset core.packedGitWindowSize &&
+     git config --unset core.packedGitLimit &&
+     git verify-pack -v "$pack2"'
 
 test_done
@@ -9,34 +9,34 @@ test_description='pack index with 64-bit offsets and object CRC'
 test_expect_success \
     'setup' \
     'rm -rf .git
-     git-init &&
+     git init &&
      i=1 &&
 	 while test $i -le 100
      do
 		 i=`printf '%03i' $i`
          echo $i >file_$i &&
          test-genrandom "$i" 8192 >>file_$i &&
-         git-update-index --add file_$i &&
+         git update-index --add file_$i &&
 		 i=`expr $i + 1` || return 1
      done &&
      { echo 101 && test-genrandom 100 8192; } >file_101 &&
-     git-update-index --add file_101 &&
-     tree=`git-write-tree` &&
-     commit=`git-commit-tree $tree </dev/null` && {
+     git update-index --add file_101 &&
+     tree=`git write-tree` &&
+     commit=`git commit-tree $tree </dev/null` && {
 	 echo $tree &&
-	 git-ls-tree $tree | sed -e "s/.* \\([0-9a-f]*\\)	.*/\\1/"
+	 git ls-tree $tree | sed -e "s/.* \\([0-9a-f]*\\)	.*/\\1/"
      } >obj-list &&
-     git-update-ref HEAD $commit'
+     git update-ref HEAD $commit'
 
 test_expect_success \
     'pack-objects with index version 1' \
-    'pack1=$(git-pack-objects --index-version=1 test-1 <obj-list) &&
-     git-verify-pack -v "test-1-${pack1}.pack"'
+    'pack1=$(git pack-objects --index-version=1 test-1 <obj-list) &&
+     git verify-pack -v "test-1-${pack1}.pack"'
 
 test_expect_success \
     'pack-objects with index version 2' \
-    'pack2=$(git-pack-objects --index-version=2 test-2 <obj-list) &&
-     git-verify-pack -v "test-2-${pack2}.pack"'
+    'pack2=$(git pack-objects --index-version=2 test-2 <obj-list) &&
+     git verify-pack -v "test-2-${pack2}.pack"'
 
 test_expect_success \
     'both packs should be identical' \
@@ -61,8 +61,8 @@ test_expect_success \
 
 test_expect_success \
     'index v2: force some 64-bit offsets with pack-objects' \
-    'pack3=$(git-pack-objects --index-version=2,0x40000 test-3 <obj-list) &&
-     git-verify-pack -v "test-3-${pack3}.pack"'
+    'pack3=$(git pack-objects --index-version=2,0x40000 test-3 <obj-list) &&
+     git verify-pack -v "test-3-${pack3}.pack"'
 
 test_expect_failure \
     '64-bit offsets: should be different from previous index v2 results' \
@@ -79,71 +79,71 @@ test_expect_success \
 test_expect_success \
     '[index v1] 1) stream pack to repository' \
     'git-index-pack --index-version=1 --stdin < "test-1-${pack1}.pack" &&
-     git-prune-packed &&
-     git-count-objects | ( read nr rest && test "$nr" -eq 1 ) &&
+     git prune-packed &&
+     git count-objects | ( read nr rest && test "$nr" -eq 1 ) &&
      cmp "test-1-${pack1}.pack" ".git/objects/pack/pack-${pack1}.pack" &&
      cmp "test-1-${pack1}.idx"  ".git/objects/pack/pack-${pack1}.idx"'
 
 test_expect_success \
     '[index v1] 2) create a stealth corruption in a delta base reference' \
     '# this test assumes a delta smaller than 16 bytes at the end of the pack
-     git-show-index <1.idx | sort -n | tail -n 1 | (
+     git show-index <1.idx | sort -n | tail -n 1 | (
        read delta_offs delta_sha1 &&
-       git-cat-file blob "$delta_sha1" > blob_1 &&
+       git cat-file blob "$delta_sha1" > blob_1 &&
        chmod +w ".git/objects/pack/pack-${pack1}.pack" &&
        dd of=".git/objects/pack/pack-${pack1}.pack" seek=$(($delta_offs + 1)) \
 	  if=".git/objects/pack/pack-${pack1}.idx" skip=$((256 * 4 + 4)) \
 	  bs=1 count=20 conv=notrunc &&
-       git-cat-file blob "$delta_sha1" > blob_2 )'
+       git cat-file blob "$delta_sha1" > blob_2 )'
 
 test_expect_failure \
     '[index v1] 3) corrupted delta happily returned wrong data' \
     'cmp blob_1 blob_2'
 
 test_expect_failure \
     '[index v1] 4) confirm that the pack is actually corrupted' \
-    'git-fsck --full $commit'
+    'git fsck --full $commit'
 
 test_expect_success \
     '[index v1] 5) pack-objects happily reuses corrupted data' \
-    'pack4=$(git-pack-objects test-4 <obj-list) &&
+    'pack4=$(git pack-objects test-4 <obj-list) &&
      test -f "test-4-${pack1}.pack"'
 
 test_expect_failure \
     '[index v1] 6) newly created pack is BAD !' \
-    'git-verify-pack -v "test-4-${pack1}.pack"'
+    'git verify-pack -v "test-4-${pack1}.pack"'
 
 test_expect_success \
     '[index v2] 1) stream pack to repository' \
     'rm -f .git/objects/pack/* &&
      git-index-pack --index-version=2,0x40000 --stdin < "test-1-${pack1}.pack" &&
-     git-prune-packed &&
-     git-count-objects | ( read nr rest && test "$nr" -eq 1 ) &&
+     git prune-packed &&
+     git count-objects | ( read nr rest && test "$nr" -eq 1 ) &&
      cmp "test-1-${pack1}.pack" ".git/objects/pack/pack-${pack1}.pack" &&
      cmp "test-3-${pack1}.idx"  ".git/objects/pack/pack-${pack1}.idx"'
 
 test_expect_success \
     '[index v2] 2) create a stealth corruption in a delta base reference' \
     '# this test assumes a delta smaller than 16 bytes at the end of the pack
-     git-show-index <1.idx | sort -n | tail -n 1 | (
+     git show-index <1.idx | sort -n | tail -n 1 | (
        read delta_offs delta_sha1 delta_crc &&
-       git-cat-file blob "$delta_sha1" > blob_3 &&
+       git cat-file blob "$delta_sha1" > blob_3 &&
        chmod +w ".git/objects/pack/pack-${pack1}.pack" &&
        dd of=".git/objects/pack/pack-${pack1}.pack" seek=$(($delta_offs + 1)) \
 	  if=".git/objects/pack/pack-${pack1}.idx" skip=$((8 + 256 * 4)) \
 	  bs=1 count=20 conv=notrunc &&
-       git-cat-file blob "$delta_sha1" > blob_4 )'
+       git cat-file blob "$delta_sha1" > blob_4 )'
 
 test_expect_failure \
     '[index v2] 3) corrupted delta happily returned wrong data' \
     'cmp blob_3 blob_4'
 
 test_expect_failure \
     '[index v2] 4) confirm that the pack is actually corrupted' \
-    'git-fsck --full $commit'
+    'git fsck --full $commit'
 
 test_expect_failure \
     '[index v2] 5) pack-objects refuses to reuse corrupted data' \
-    'git-pack-objects test-5 <obj-list'
+    'git pack-objects test-5 <obj-list'
 
 test_done
@@ -13,9 +13,9 @@ test_expect_success setup '
 	test_tick &&
 	mkdir mozart mozart/is &&
 	echo "Commit #0" >mozart/is/pink &&
-	git-update-index --add mozart/is/pink &&
-	tree=$(git-write-tree) &&
-	commit=$(echo "Commit #0" | git-commit-tree $tree) &&
+	git update-index --add mozart/is/pink &&
+	tree=$(git write-tree) &&
+	commit=$(echo "Commit #0" | git commit-tree $tree) &&
 	zero=$commit &&
 	parent=$zero &&
 	i=0 &&
@@ -24,34 +24,34 @@ test_expect_success setup '
 	    i=$(($i+1)) &&
 	    test_tick &&
 	    echo "Commit #$i" >mozart/is/pink &&
-	    git-update-index --add mozart/is/pink &&
-	    tree=$(git-write-tree) &&
-	    commit=$(echo "Commit #$i" | git-commit-tree $tree -p $parent) &&
-	    git-update-ref refs/tags/commit$i $commit &&
+	    git update-index --add mozart/is/pink &&
+	    tree=$(git write-tree) &&
+	    commit=$(echo "Commit #$i" | git commit-tree $tree -p $parent) &&
+	    git update-ref refs/tags/commit$i $commit &&
 	    parent=$commit || return 1
 	done &&
-	git-update-ref HEAD "$commit" &&
+	git update-ref HEAD "$commit" &&
 	git-clone ./. victim &&
 	cd victim &&
-	git-log &&
+	git log &&
 	cd .. &&
-	git-update-ref HEAD "$zero" &&
+	git update-ref HEAD "$zero" &&
 	parent=$zero &&
 	i=0 &&
 	while test $i -le $cnt
 	do
 	    i=$(($i+1)) &&
 	    test_tick &&
 	    echo "Rebase #$i" >mozart/is/pink &&
-	    git-update-index --add mozart/is/pink &&
-	    tree=$(git-write-tree) &&
-	    commit=$(echo "Rebase #$i" | git-commit-tree $tree -p $parent) &&
-	    git-update-ref refs/tags/rebase$i $commit &&
+	    git update-index --add mozart/is/pink &&
+	    tree=$(git write-tree) &&
+	    commit=$(echo "Rebase #$i" | git commit-tree $tree -p $parent) &&
+	    git update-ref refs/tags/rebase$i $commit &&
 	    parent=$commit || return 1
 	done &&
-	git-update-ref HEAD "$commit" &&
+	git update-ref HEAD "$commit" &&
 	echo Rebase &&
-	git-log'
+	git log'
 
 test_expect_success 'pack the source repository' '
 	git repack -a -d &&
@@ -106,9 +106,9 @@ export HOME ;# this way we force the victim/.git/config to be used.
 test_expect_success \
         'pushing with --force should be denied with denyNonFastforwards' '
 	cd victim &&
-	git-config receive.denyNonFastforwards true &&
+	git config receive.denyNonFastforwards true &&
 	cd .. &&
-	git-update-ref refs/heads/master master^ || return 1
+	git update-ref refs/heads/master master^ || return 1
 	git-send-pack --force ./victim/.git/ master && return 1
 	! git diff .git/refs/heads/master victim/.git/refs/heads/master
 '
@@ -8,19 +8,19 @@ test_description='Test the update hook infrastructure.'
 
 test_expect_success setup '
 	echo This is a test. >a &&
-	git-update-index --add a &&
-	tree0=$(git-write-tree) &&
-	commit0=$(echo setup | git-commit-tree $tree0) &&
+	git update-index --add a &&
+	tree0=$(git write-tree) &&
+	commit0=$(echo setup | git commit-tree $tree0) &&
 	echo We hope it works. >a &&
-	git-update-index a &&
-	tree1=$(git-write-tree) &&
-	commit1=$(echo modify | git-commit-tree $tree1 -p $commit0) &&
-	git-update-ref refs/heads/master $commit0 &&
-	git-update-ref refs/heads/tofail $commit1 &&
+	git update-index a &&
+	tree1=$(git write-tree) &&
+	commit1=$(echo modify | git commit-tree $tree1 -p $commit0) &&
+	git update-ref refs/heads/master $commit0 &&
+	git update-ref refs/heads/tofail $commit1 &&
 	git-clone ./. victim &&
-	GIT_DIR=victim/.git git-update-ref refs/heads/tofail $commit1 &&
-	git-update-ref refs/heads/master $commit1 &&
-	git-update-ref refs/heads/tofail $commit0
+	GIT_DIR=victim/.git git update-ref refs/heads/tofail $commit1 &&
+	git update-ref refs/heads/master $commit1 &&
+	git update-ref refs/heads/tofail $commit0
 '
 
 cat >victim/.git/hooks/pre-receive <<'EOF'
@@ -65,8 +65,8 @@ test_expect_failure push '
 '
 
 test_expect_success 'updated as expected' '
-	test $(GIT_DIR=victim/.git git-rev-parse master) = $commit1 &&
-	test $(GIT_DIR=victim/.git git-rev-parse tofail) = $commit1
+	test $(GIT_DIR=victim/.git git rev-parse master) = $commit1 &&
+	test $(GIT_DIR=victim/.git git rev-parse tofail) = $commit1
 '
 
 test_expect_success 'hooks ran' '
@@ -25,12 +25,12 @@ add () {
 	done
 
 	echo "$text" > test.txt
-	git-update-index --add test.txt
-	tree=$(git-write-tree)
+	git update-index --add test.txt
+	tree=$(git write-tree)
 	# make sure timestamps are in correct order
 	sec=$(($sec+1))
 	commit=$(echo "$text" | GIT_AUTHOR_DATE=$sec \
-		git-commit-tree $tree $parents 2>>log2.txt)
+		git commit-tree $tree $parents 2>>log2.txt)
 	export $name=$commit
 	echo $commit > .git/refs/heads/$branch
 	eval ${branch}TIP=$commit
@@ -61,19 +61,19 @@ pull_to_client () {
 		"git-fetch-pack -k -v .. $heads"
 	case "$heads" in *A*) echo $ATIP > .git/refs/heads/A;; esac
 	case "$heads" in *B*) echo $BTIP > .git/refs/heads/B;; esac
-	git-symbolic-ref HEAD refs/heads/`echo $heads | sed -e 's/^\(.\).*$/\1/'`
+	git symbolic-ref HEAD refs/heads/`echo $heads | sed -e 's/^\(.\).*$/\1/'`
 
-	test_expect_success "fsck" 'git-fsck --full > fsck.txt 2>&1'
+	test_expect_success "fsck" 'git fsck --full > fsck.txt 2>&1'
 
 	test_expect_success 'check downloaded results' \
 	'mv .git/objects/pack/pack-* . &&
 	 p=`ls -1 pack-*.pack` &&
-	 git-unpack-objects <$p &&
-	 git-fsck --full'
+	 git unpack-objects <$p &&
+	 git fsck --full'
 
 	test_expect_success "new object count after $number pull" \
 	'idx=`echo pack-*.idx` &&
-	 pack_count=`git-show-index <$idx | wc -l` &&
+	 pack_count=`git show-index <$idx | wc -l` &&
 	 test $pack_count = $count'
 	test -z "$pack_count" && pack_count=0
 	if [ -z "$no_strict_count_check" ]; then
@@ -97,7 +97,7 @@ pull_to_client () {
 (
 	mkdir client &&
 	cd client &&
-	git-init 2>> log2.txt &&
+	git init 2>> log2.txt &&
 	git config transfer.unpacklimit 0
 )
 
@@ -113,7 +113,7 @@ add B1 $A1
 
 echo $ATIP > .git/refs/heads/A
 echo $BTIP > .git/refs/heads/B
-git-symbolic-ref HEAD refs/heads/B
+git symbolic-ref HEAD refs/heads/B
 
 pull_to_client 1st "B A" $((11*3))
 
@@ -131,7 +131,7 @@ pull_to_client 3rd "A" $((1*3)) # old fails
 
 test_expect_success "clone shallow" "git-clone --depth 2 . shallow"
 
-(cd shallow; git-count-objects -v) > count.shallow
+(cd shallow; git count-objects -v) > count.shallow
 
 test_expect_success "clone shallow object count" \
 	"test \"in-pack: 18\" = \"$(grep in-pack count.shallow)\""
@@ -145,7 +145,7 @@ test_expect_success "clone shallow object count (part 2)" '
 '
 
 test_expect_success "fsck in shallow repo" \
-	"(cd shallow; git-fsck --full)"
+	"(cd shallow; git fsck --full)"
 
 #test_done; exit
 
@@ -155,7 +155,7 @@ add B67 $B66
 test_expect_success "pull in shallow repo" \
 	"(cd shallow; git pull .. B)"
 
-(cd shallow; git-count-objects -v) > count.shallow
+(cd shallow; git count-objects -v) > count.shallow
 test_expect_success "clone shallow object count" \
 	"test \"count: 6\" = \"$(grep count count.shallow)\""
 
@@ -165,14 +165,14 @@ add B69 $B68
 test_expect_success "deepening pull in shallow repo" \
 	"(cd shallow; git pull --depth 4 .. B)"
 
-(cd shallow; git-count-objects -v) > count.shallow
+(cd shallow; git count-objects -v) > count.shallow
 test_expect_success "clone shallow object count" \
 	"test \"count: 12\" = \"$(grep count count.shallow)\""
 
 test_expect_success "deepening fetch in shallow repo" \
 	"(cd shallow; git fetch --depth 4 .. A:A)"
 
-(cd shallow; git-count-objects -v) > count.shallow
+(cd shallow; git count-objects -v) > count.shallow
 test_expect_success "clone shallow object count" \
 	"test \"count: 18\" = \"$(grep count count.shallow)\""
 
@@ -17,7 +17,7 @@ unique_commit()
 	_text=$1
         _tree=$2
 	shift 2
-	echo $_text | git-commit-tree $(tag $_tree) "$@"
+	echo $_text | git commit-tree $(tag $_tree) "$@"
 }
 
 # Save the output of a command into the tag specified. Prepend
@@ -62,7 +62,7 @@ as_author()
 commit_date()
 {
         _commit=$1
-	git-cat-file commit $_commit | sed -n "s/^committer .*> \([0-9]*\) .*/\1/p"
+	git cat-file commit $_commit | sed -n "s/^committer .*> \([0-9]*\) .*/\1/p"
 }
 
 on_committer_date()
@@ -2,7 +2,7 @@
 #
 # Copyright (c) 2005 Jon Seymour
 #
-test_description='Tests git-rev-list --bisect functionality'
+test_description='Tests git rev-list --bisect functionality'
 
 . ./test-lib.sh
 . ../t6000lib.sh # t6xxx specific functions
@@ -16,11 +16,11 @@ test_bisection_diff()
 	_max_diff=$1
 	_bisect_option=$2
 	shift 2
-	_bisection=$(git-rev-list $_bisect_option "$@")
-	_list_size=$(git-rev-list "$@" | wc -l)
+	_bisection=$(git rev-list $_bisect_option "$@")
+	_list_size=$(git rev-list "$@" | wc -l)
         _head=$1
 	shift 1
-	_bisection_size=$(git-rev-list $_bisection "$@" | wc -l)
+	_bisection_size=$(git rev-list $_bisection "$@" | wc -l)
 	[ -n "$_list_size" -a -n "$_bisection_size" ] ||
 	error "test_bisection_diff failed"
 
@@ -37,8 +37,8 @@ test_bisection_diff()
 }
 
 date >path0
-git-update-index --add path0
-save_tag tree git-write-tree
+git update-index --add path0
+save_tag tree git write-tree
 on_committer_date "1971-08-16 00:00:00" hide_error save_tag root unique_commit root tree
 on_committer_date "1971-08-16 00:00:01" save_tag l0 unique_commit l0 tree -p root
 on_committer_date "1971-08-16 00:00:02" save_tag l1 unique_commit l1 tree -p l0
@@ -58,7 +58,7 @@ on_committer_date "1971-08-16 00:00:15" save_tag a4 unique_commit a4 tree -p a3
 on_committer_date "1971-08-16 00:00:16" save_tag l3 unique_commit l3 tree -p a4
 on_committer_date "1971-08-16 00:00:17" save_tag l4 unique_commit l4 tree -p l3
 on_committer_date "1971-08-16 00:00:18" save_tag l5 unique_commit l5 tree -p l4
-git-update-ref HEAD $(tag l5)
+git update-ref HEAD $(tag l5)
 
 
 #     E
@@ -163,35 +163,35 @@ test_sequence()
 # the bisection point is the head - this is the bad point.
 #
 
-test_output_expect_success "$_bisect_option l5 ^root" 'git-rev-list $_bisect_option l5 ^root' <<EOF
+test_output_expect_success "$_bisect_option l5 ^root" 'git rev-list $_bisect_option l5 ^root' <<EOF
 c3
 EOF
 
-test_output_expect_success "$_bisect_option l5 ^root ^c3" 'git-rev-list $_bisect_option l5 ^root ^c3' <<EOF
+test_output_expect_success "$_bisect_option l5 ^root ^c3" 'git rev-list $_bisect_option l5 ^root ^c3' <<EOF
 b4
 EOF
 
-test_output_expect_success "$_bisect_option l5 ^root ^c3 ^b4" 'git-rev-list $_bisect_option l5 ^c3 ^b4' <<EOF
+test_output_expect_success "$_bisect_option l5 ^root ^c3 ^b4" 'git rev-list $_bisect_option l5 ^c3 ^b4' <<EOF
 l3
 EOF
 
-test_output_expect_success "$_bisect_option l3 ^root ^c3 ^b4" 'git-rev-list $_bisect_option l3 ^root ^c3 ^b4' <<EOF
+test_output_expect_success "$_bisect_option l3 ^root ^c3 ^b4" 'git rev-list $_bisect_option l3 ^root ^c3 ^b4' <<EOF
 a4
 EOF
 
-test_output_expect_success "$_bisect_option l5 ^b3 ^a3 ^b4 ^a4" 'git-rev-list $_bisect_option l3 ^b3 ^a3 ^a4' <<EOF
+test_output_expect_success "$_bisect_option l5 ^b3 ^a3 ^b4 ^a4" 'git rev-list $_bisect_option l3 ^b3 ^a3 ^a4' <<EOF
 l3
 EOF
 
 #
 # if l3 is bad, then l4 is bad too - so advance the bad pointer by making b4 the known bad head
 #
 
-test_output_expect_success "$_bisect_option l4 ^a2 ^a3 ^b ^a4" 'git-rev-list $_bisect_option l4 ^a2 ^a3 ^a4' <<EOF
+test_output_expect_success "$_bisect_option l4 ^a2 ^a3 ^b ^a4" 'git rev-list $_bisect_option l4 ^a2 ^a3 ^a4' <<EOF
 l3
 EOF
 
-test_output_expect_success "$_bisect_option l3 ^a2 ^a3 ^b ^a4" 'git-rev-list $_bisect_option l3 ^a2 ^a3 ^a4' <<EOF
+test_output_expect_success "$_bisect_option l3 ^a2 ^a3 ^b ^a4" 'git rev-list $_bisect_option l3 ^a2 ^a3 ^a4' <<EOF
 l3
 EOF
 
@@ -201,15 +201,15 @@ EOF
 # as another example, let's consider a4 to be the bad head, in which case
 #
 
-test_output_expect_success "$_bisect_option a4 ^a2 ^a3 ^b4" 'git-rev-list $_bisect_option a4 ^a2 ^a3 ^b4' <<EOF
+test_output_expect_success "$_bisect_option a4 ^a2 ^a3 ^b4" 'git rev-list $_bisect_option a4 ^a2 ^a3 ^b4' <<EOF
 c2
 EOF
 
-test_output_expect_success "$_bisect_option a4 ^a2 ^a3 ^b4 ^c2" 'git-rev-list $_bisect_option a4 ^a2 ^a3 ^b4 ^c2' <<EOF
+test_output_expect_success "$_bisect_option a4 ^a2 ^a3 ^b4 ^c2" 'git rev-list $_bisect_option a4 ^a2 ^a3 ^b4 ^c2' <<EOF
 c3
 EOF
 
-test_output_expect_success "$_bisect_option a4 ^a2 ^a3 ^b4 ^c2 ^c3" 'git-rev-list $_bisect_option a4 ^a2 ^a3 ^b4 ^c2 ^c3' <<EOF
+test_output_expect_success "$_bisect_option a4 ^a2 ^a3 ^b4 ^c2 ^c3" 'git rev-list $_bisect_option a4 ^a2 ^a3 ^b4 ^c2 ^c3' <<EOF
 a4
 EOF
 
@@ -219,11 +219,11 @@ EOF
 # or consider c3 to be the bad head
 #
 
-test_output_expect_success "$_bisect_option a4 ^a2 ^a3 ^b4" 'git-rev-list $_bisect_option a4 ^a2 ^a3 ^b4' <<EOF
+test_output_expect_success "$_bisect_option a4 ^a2 ^a3 ^b4" 'git rev-list $_bisect_option a4 ^a2 ^a3 ^b4' <<EOF
 c2
 EOF
 
-test_output_expect_success "$_bisect_option c3 ^a2 ^a3 ^b4 ^c2" 'git-rev-list $_bisect_option c3 ^a2 ^a3 ^b4 ^c2' <<EOF
+test_output_expect_success "$_bisect_option c3 ^a2 ^a3 ^b4 ^c2" 'git rev-list $_bisect_option c3 ^a2 ^a3 ^b4 ^c2' <<EOF
 c3
 EOF
 
@@ -3,7 +3,7 @@
 # Copyright (c) 2005 Jon Seymour
 #
 
-test_description='Tests git-rev-list --topo-order functionality'
+test_description='Tests git rev-list --topo-order functionality'
 
 . ./test-lib.sh
 . ../t6000lib.sh # t6xxx specific functions
@@ -14,8 +14,8 @@ list_duplicates()
 }
 
 date >path0
-git-update-index --add path0
-save_tag tree git-write-tree
+git update-index --add path0
+save_tag tree git write-tree
 on_committer_date "1971-08-16 00:00:00" hide_error save_tag root unique_commit root tree
 on_committer_date "1971-08-16 00:00:01" save_tag l0 unique_commit l0 tree -p root
 on_committer_date "1971-08-16 00:00:02" save_tag l1 unique_commit l1 tree -p l0
@@ -77,13 +77,13 @@ save_tag h2 unique_commit g4 tree -p g2
 save_tag g3 unique_commit g5 tree -p g2
 save_tag g4 unique_commit g6 tree -p g3 -p h2
 
-git-update-ref HEAD $(tag l5)
+git update-ref HEAD $(tag l5)
 
-test_output_expect_success 'rev-list has correct number of entries' 'git-rev-list HEAD | wc -l | tr -d \" \"' <<EOF
+test_output_expect_success 'rev-list has correct number of entries' 'git rev-list HEAD | wc -l | tr -d \" \"' <<EOF
 19
 EOF
 
-test_output_expect_success 'simple topo order' 'git-rev-list --topo-order  HEAD' <<EOF
+test_output_expect_success 'simple topo order' 'git rev-list --topo-order  HEAD' <<EOF
 l5
 l4
 l3
@@ -105,7 +105,7 @@ l0
 root
 EOF
 
-test_output_expect_success 'two diamonds topo order (g6)' 'git-rev-list --topo-order  g4' <<EOF
+test_output_expect_success 'two diamonds topo order (g6)' 'git rev-list --topo-order  g4' <<EOF
 g4
 h2
 g3
@@ -115,7 +115,7 @@ g1
 g0
 EOF
 
-test_output_expect_success 'multiple heads' 'git-rev-list --topo-order a3 b3 c3' <<EOF
+test_output_expect_success 'multiple heads' 'git rev-list --topo-order a3 b3 c3' <<EOF
 a3
 a2
 a1
@@ -132,7 +132,7 @@ l0
 root
 EOF
 
-test_output_expect_success 'multiple heads, prune at a1' 'git-rev-list --topo-order a3 b3 c3 ^a1' <<EOF
+test_output_expect_success 'multiple heads, prune at a1' 'git rev-list --topo-order a3 b3 c3 ^a1' <<EOF
 a3
 a2
 c3
@@ -143,7 +143,7 @@ b2
 b1
 EOF
 
-test_output_expect_success 'multiple heads, prune at l1' 'git-rev-list --topo-order a3 b3 c3 ^l1' <<EOF
+test_output_expect_success 'multiple heads, prune at l1' 'git rev-list --topo-order a3 b3 c3 ^l1' <<EOF
 a3
 a2
 a1
@@ -157,7 +157,7 @@ a0
 l2
 EOF
 
-test_output_expect_success 'cross-epoch, head at l5, prune at l1' 'git-rev-list --topo-order l5 ^l1' <<EOF
+test_output_expect_success 'cross-epoch, head at l5, prune at l1' 'git rev-list --topo-order l5 ^l1' <<EOF
 l5
 l4
 l3
@@ -176,7 +176,7 @@ a0
 l2
 EOF
 
-test_output_expect_success 'duplicated head arguments' 'git-rev-list --topo-order l5 l5 ^l1' <<EOF
+test_output_expect_success 'duplicated head arguments' 'git rev-list --topo-order l5 l5 ^l1' <<EOF
 l5
 l4
 l3
@@ -195,7 +195,7 @@ a0
 l2
 EOF
 
-test_output_expect_success 'prune near topo' 'git-rev-list --topo-order a4 ^c3' <<EOF
+test_output_expect_success 'prune near topo' 'git rev-list --topo-order a4 ^c3' <<EOF
 a4
 b4
 a3
@@ -204,52 +204,52 @@ a1
 b3
 EOF
 
-test_output_expect_success "head has no parent" 'git-rev-list --topo-order  root' <<EOF
+test_output_expect_success "head has no parent" 'git rev-list --topo-order  root' <<EOF
 root
 EOF
 
-test_output_expect_success "two nodes - one head, one base" 'git-rev-list --topo-order  l0' <<EOF
+test_output_expect_success "two nodes - one head, one base" 'git rev-list --topo-order  l0' <<EOF
 l0
 root
 EOF
 
-test_output_expect_success "three nodes one head, one internal, one base" 'git-rev-list --topo-order  l1' <<EOF
+test_output_expect_success "three nodes one head, one internal, one base" 'git rev-list --topo-order  l1' <<EOF
 l1
 l0
 root
 EOF
 
-test_output_expect_success "linear prune l2 ^root" 'git-rev-list --topo-order  l2 ^root' <<EOF
+test_output_expect_success "linear prune l2 ^root" 'git rev-list --topo-order  l2 ^root' <<EOF
 l2
 l1
 l0
 EOF
 
-test_output_expect_success "linear prune l2 ^l0" 'git-rev-list --topo-order  l2 ^l0' <<EOF
+test_output_expect_success "linear prune l2 ^l0" 'git rev-list --topo-order  l2 ^l0' <<EOF
 l2
 l1
 EOF
 
-test_output_expect_success "linear prune l2 ^l1" 'git-rev-list --topo-order  l2 ^l1' <<EOF
+test_output_expect_success "linear prune l2 ^l1" 'git rev-list --topo-order  l2 ^l1' <<EOF
 l2
 EOF
 
-test_output_expect_success "linear prune l5 ^a4" 'git-rev-list --topo-order  l5 ^a4' <<EOF
+test_output_expect_success "linear prune l5 ^a4" 'git rev-list --topo-order  l5 ^a4' <<EOF
 l5
 l4
 l3
 EOF
 
-test_output_expect_success "linear prune l5 ^l3" 'git-rev-list --topo-order  l5 ^l3' <<EOF
+test_output_expect_success "linear prune l5 ^l3" 'git rev-list --topo-order  l5 ^l3' <<EOF
 l5
 l4
 EOF
 
-test_output_expect_success "linear prune l5 ^l4" 'git-rev-list --topo-order  l5 ^l4' <<EOF
+test_output_expect_success "linear prune l5 ^l4" 'git rev-list --topo-order  l5 ^l4' <<EOF
 l5
 EOF
 
-test_output_expect_success "max-count 10 - topo order" 'git-rev-list --topo-order  --max-count=10 l5' <<EOF
+test_output_expect_success "max-count 10 - topo order" 'git rev-list --topo-order  --max-count=10 l5' <<EOF
 l5
 l4
 l3
@@ -262,7 +262,7 @@ a3
 a2
 EOF
 
-test_output_expect_success "max-count 10 - non topo order" 'git-rev-list --max-count=10 l5' <<EOF
+test_output_expect_success "max-count 10 - non topo order" 'git rev-list --max-count=10 l5' <<EOF
 l5
 l4
 l3
@@ -275,7 +275,7 @@ c2
 b3
 EOF
 
-test_output_expect_success '--max-age=c3, no --topo-order' "git-rev-list --max-age=$(commit_date c3) l5" <<EOF
+test_output_expect_success '--max-age=c3, no --topo-order' "git rev-list --max-age=$(commit_date c3) l5" <<EOF
 l5
 l4
 l3
@@ -289,7 +289,7 @@ EOF
 #
 # this test fails on --topo-order - a fix is required
 #
-#test_output_expect_success '--max-age=c3, --topo-order' "git-rev-list --topo-order --max-age=$(commit_date c3) l5" <<EOF
+#test_output_expect_success '--max-age=c3, --topo-order' "git rev-list --topo-order --max-age=$(commit_date c3) l5" <<EOF
 #l5
 #l4
 #l3
@@ -300,31 +300,31 @@ EOF
 #a2
 #EOF
 
-test_output_expect_success 'one specified head reachable from another a4, c3, --topo-order' "list_duplicates git-rev-list --topo-order a4 c3" <<EOF
+test_output_expect_success 'one specified head reachable from another a4, c3, --topo-order' "list_duplicates git rev-list --topo-order a4 c3" <<EOF
 EOF
 
-test_output_expect_success 'one specified head reachable from another c3, a4, --topo-order' "list_duplicates git-rev-list --topo-order c3 a4" <<EOF
+test_output_expect_success 'one specified head reachable from another c3, a4, --topo-order' "list_duplicates git rev-list --topo-order c3 a4" <<EOF
 EOF
 
-test_output_expect_success 'one specified head reachable from another a4, c3, no --topo-order' "list_duplicates git-rev-list a4 c3" <<EOF
+test_output_expect_success 'one specified head reachable from another a4, c3, no --topo-order' "list_duplicates git rev-list a4 c3" <<EOF
 EOF
 
-test_output_expect_success 'one specified head reachable from another c3, a4, no --topo-order' "list_duplicates git-rev-list c3 a4" <<EOF
+test_output_expect_success 'one specified head reachable from another c3, a4, no --topo-order' "list_duplicates git rev-list c3 a4" <<EOF
 EOF
 
-test_output_expect_success 'graph with c3 and a4 parents of head' "list_duplicates git-rev-list m1" <<EOF
+test_output_expect_success 'graph with c3 and a4 parents of head' "list_duplicates git rev-list m1" <<EOF
 EOF
 
-test_output_expect_success 'graph with a4 and c3 parents of head' "list_duplicates git-rev-list m2" <<EOF
+test_output_expect_success 'graph with a4 and c3 parents of head' "list_duplicates git rev-list m2" <<EOF
 EOF
 
-test_expect_success "head ^head --topo-order" 'git-rev-list --topo-order  a3 ^a3' <<EOF
+test_expect_success "head ^head --topo-order" 'git rev-list --topo-order  a3 ^a3' <<EOF
 EOF
 
-test_expect_success "head ^head no --topo-order" 'git-rev-list a3 ^a3' <<EOF
+test_expect_success "head ^head no --topo-order" 'git rev-list a3 ^a3' <<EOF
 EOF
 
-test_output_expect_success 'simple topo order (l5r1)' 'git-rev-list --topo-order  l5r1' <<EOF
+test_output_expect_success 'simple topo order (l5r1)' 'git rev-list --topo-order  l5r1' <<EOF
 l5r1
 r1
 r0
@@ -350,7 +350,7 @@ l0
 root
 EOF
 
-test_output_expect_success 'simple topo order (r1l5)' 'git-rev-list --topo-order  r1l5' <<EOF
+test_output_expect_success 'simple topo order (r1l5)' 'git rev-list --topo-order  r1l5' <<EOF
 r1l5
 l5
 l4
@@ -376,13 +376,13 @@ r0
 alt_root
 EOF
 
-test_output_expect_success "don't print things unreachable from one branch" "git-rev-list a3 ^b3 --topo-order" <<EOF
+test_output_expect_success "don't print things unreachable from one branch" "git rev-list a3 ^b3 --topo-order" <<EOF
 a3
 a2
 a1
 EOF
 
-test_output_expect_success "--topo-order a4 l3" "git-rev-list --topo-order a4 l3" <<EOF
+test_output_expect_success "--topo-order a4 l3" "git rev-list --topo-order a4 l3" <<EOF
 l3
 a4
 c3
@@ -1,6 +1,6 @@
 #!/bin/sh
 
-test_description='git-rev-list trivial path optimization test'
+test_description='git rev-list trivial path optimization test'
 
 . ./test-lib.sh
 
@@ -12,9 +12,9 @@ initial=$(git rev-parse --verify HEAD)
 '
 
 test_expect_success path-optimization '
-    commit=$(echo "Unchanged tree" | git-commit-tree "HEAD^{tree}" -p HEAD) &&
-    test $(git-rev-list $commit | wc -l) = 2 &&
-    test $(git-rev-list $commit -- . | wc -l) = 1
+    commit=$(echo "Unchanged tree" | git commit-tree "HEAD^{tree}" -p HEAD) &&
+    test $(git rev-list $commit | wc -l) = 2 &&
+    test $(git rev-list $commit -- . | wc -l) = 1
 '
 
 test_expect_success 'further setup' '
@@ -1,6 +1,6 @@
 #!/bin/sh
 
-test_description='git-rev-list --max-count and --skip test'
+test_description='git rev-list --max-count and --skip test'
 
 . ./test-lib.sh
 
@@ -13,39 +13,39 @@ test_expect_success 'setup' '
 '
 
 test_expect_success 'no options' '
-    test $(git-rev-list HEAD | wc -l) = 5
+    test $(git rev-list HEAD | wc -l) = 5
 '
 
 test_expect_success '--max-count' '
-    test $(git-rev-list HEAD --max-count=0 | wc -l) = 0 &&
-    test $(git-rev-list HEAD --max-count=3 | wc -l) = 3 &&
-    test $(git-rev-list HEAD --max-count=5 | wc -l) = 5 &&
-    test $(git-rev-list HEAD --max-count=10 | wc -l) = 5
+    test $(git rev-list HEAD --max-count=0 | wc -l) = 0 &&
+    test $(git rev-list HEAD --max-count=3 | wc -l) = 3 &&
+    test $(git rev-list HEAD --max-count=5 | wc -l) = 5 &&
+    test $(git rev-list HEAD --max-count=10 | wc -l) = 5
 '
 
 test_expect_success '--max-count all forms' '
-    test $(git-rev-list HEAD --max-count=1 | wc -l) = 1 &&
-    test $(git-rev-list HEAD -1 | wc -l) = 1 &&
-    test $(git-rev-list HEAD -n1 | wc -l) = 1 &&
-    test $(git-rev-list HEAD -n 1 | wc -l) = 1
+    test $(git rev-list HEAD --max-count=1 | wc -l) = 1 &&
+    test $(git rev-list HEAD -1 | wc -l) = 1 &&
+    test $(git rev-list HEAD -n1 | wc -l) = 1 &&
+    test $(git rev-list HEAD -n 1 | wc -l) = 1
 '
 
 test_expect_success '--skip' '
-    test $(git-rev-list HEAD --skip=0 | wc -l) = 5 &&
-    test $(git-rev-list HEAD --skip=3 | wc -l) = 2 &&
-    test $(git-rev-list HEAD --skip=5 | wc -l) = 0 &&
-    test $(git-rev-list HEAD --skip=10 | wc -l) = 0
+    test $(git rev-list HEAD --skip=0 | wc -l) = 5 &&
+    test $(git rev-list HEAD --skip=3 | wc -l) = 2 &&
+    test $(git rev-list HEAD --skip=5 | wc -l) = 0 &&
+    test $(git rev-list HEAD --skip=10 | wc -l) = 0
 '
 
 test_expect_success '--skip --max-count' '
-    test $(git-rev-list HEAD --skip=0 --max-count=0 | wc -l) = 0 &&
-    test $(git-rev-list HEAD --skip=0 --max-count=10 | wc -l) = 5 &&
-    test $(git-rev-list HEAD --skip=3 --max-count=0 | wc -l) = 0 &&
-    test $(git-rev-list HEAD --skip=3 --max-count=1 | wc -l) = 1 &&
-    test $(git-rev-list HEAD --skip=3 --max-count=2 | wc -l) = 2 &&
-    test $(git-rev-list HEAD --skip=3 --max-count=10 | wc -l) = 2 &&
-    test $(git-rev-list HEAD --skip=5 --max-count=10 | wc -l) = 0 &&
-    test $(git-rev-list HEAD --skip=10 --max-count=10 | wc -l) = 0
+    test $(git rev-list HEAD --skip=0 --max-count=0 | wc -l) = 0 &&
+    test $(git rev-list HEAD --skip=0 --max-count=10 | wc -l) = 5 &&
+    test $(git rev-list HEAD --skip=3 --max-count=0 | wc -l) = 0 &&
+    test $(git rev-list HEAD --skip=3 --max-count=1 | wc -l) = 1 &&
+    test $(git rev-list HEAD --skip=3 --max-count=2 | wc -l) = 2 &&
+    test $(git rev-list HEAD --skip=3 --max-count=10 | wc -l) = 2 &&
+    test $(git rev-list HEAD --skip=5 --max-count=10 | wc -l) = 0 &&
+    test $(git rev-list HEAD --skip=10 --max-count=10 | wc -l) = 0
 '
 
 test_done
@@ -1,21 +1,21 @@
 #!/bin/sh
 
-test_description='git-rev-list --pretty=format test'
+test_description='git rev-list --pretty=format test'
 
 . ./test-lib.sh
 
 test_tick
 test_expect_success 'setup' '
-touch foo && git-add foo && git-commit -m "added foo" &&
+touch foo && git add foo && git-commit -m "added foo" &&
   echo changed >foo && git-commit -a -m "changed foo"
 '
 
 # usage: test_format name format_string <expected_output
 test_format() {
 	cat >expect.$1
 	test_expect_success "format $1" "
-git-rev-list --pretty=format:$2 master >output.$1 &&
-git-diff expect.$1 output.$1
+git rev-list --pretty=format:$2 master >output.$1 &&
+git diff expect.$1 output.$1
 "
 }
 
@@ -113,7 +113,7 @@ and it will be encoded in iso8859-1. We should therefore
 include an iso8859 character: ¡bueno!
 EOF
 test_expect_success 'setup complex body' '
-git-config i18n.commitencoding iso8859-1 &&
+git config i18n.commitencoding iso8859-1 &&
   echo change2 >foo && git-commit -a -F commit-msg
 '
 
@@ -8,7 +8,7 @@ test_description='Merge base computation.
 
 . ./test-lib.sh
 
-T=$(git-write-tree)
+T=$(git write-tree)
 
 M=1130000000
 Z=+0000
@@ -29,7 +29,7 @@ doit() {
 	GIT_COMMITTER_DATE="$(($M + $OFFSET)) $Z"
 	GIT_AUTHOR_DATE=$GIT_COMMITTER_DATE
 	export GIT_COMMITTER_DATE GIT_AUTHOR_DATE
-	commit=$(echo $NAME | git-commit-tree $T $PARENTS)
+	commit=$(echo $NAME | git commit-tree $T $PARENTS)
 	echo $commit >.git/refs/tags/$NAME
 	echo $commit
 }
@@ -51,16 +51,16 @@ G=$(doit 7 G $B $E)
 H=$(doit 8 H $A $F)
 
 test_expect_success 'compute merge-base (single)' \
-    'MB=$(git-merge-base G H) &&
-     expr "$(git-name-rev "$MB")" : "[0-9a-f]* tags/B"'
+    'MB=$(git merge-base G H) &&
+     expr "$(git name-rev "$MB")" : "[0-9a-f]* tags/B"'
 
 test_expect_success 'compute merge-base (all)' \
-    'MB=$(git-merge-base --all G H) &&
-     expr "$(git-name-rev "$MB")" : "[0-9a-f]* tags/B"'
+    'MB=$(git merge-base --all G H) &&
+     expr "$(git name-rev "$MB")" : "[0-9a-f]* tags/B"'
 
 test_expect_success 'compute merge-base with show-branch' \
-    'MB=$(git-show-branch --merge-base G H) &&
-     expr "$(git-name-rev "$MB")" : "[0-9a-f]* tags/B"'
+    'MB=$(git show-branch --merge-base G H) &&
+     expr "$(git name-rev "$MB")" : "[0-9a-f]* tags/B"'
 
 # Setup for second test to demonstrate that relying on timestamps in a
 # distributed SCM to provide a _consistent_ partial ordering of commits
@@ -100,11 +100,11 @@ PL=$(doit  4 PL $L2 $C2)
 PR=$(doit  4 PR $C2 $R2)
 
 test_expect_success 'compute merge-base (single)' \
-    'MB=$(git-merge-base PL PR) &&
-     expr "$(git-name-rev "$MB")" : "[0-9a-f]* tags/C2"'
+    'MB=$(git merge-base PL PR) &&
+     expr "$(git name-rev "$MB")" : "[0-9a-f]* tags/C2"'
 
 test_expect_success 'compute merge-base (all)' \
-    'MB=$(git-merge-base --all PL PR) &&
-     expr "$(git-name-rev "$MB")" : "[0-9a-f]* tags/C2"'
+    'MB=$(git merge-base --all PL PR) &&
+     expr "$(git name-rev "$MB")" : "[0-9a-f]* tags/C2"'
 
 test_done
@@ -56,18 +56,18 @@ printf "propter nomen suum." >> new4.txt
 
 cp new1.txt test.txt
 test_expect_success "merge without conflict" \
-	"git-merge-file test.txt orig.txt new2.txt"
+	"git merge-file test.txt orig.txt new2.txt"
 
 cp new1.txt test2.txt
 test_expect_success "merge without conflict (missing LF at EOF)" \
-	"git-merge-file test2.txt orig.txt new2.txt"
+	"git merge-file test2.txt orig.txt new2.txt"
 
 test_expect_success "merge result added missing LF" \
 	"git diff test.txt test2.txt"
 
 cp test.txt backup.txt
 test_expect_failure "merge with conflicts" \
-	"git-merge-file test.txt orig.txt new3.txt"
+	"git merge-file test.txt orig.txt new3.txt"
 
 cat > expect.txt << EOF
 <<<<<<< test.txt
@@ -90,7 +90,7 @@ test_expect_success "expected conflict markers" "git diff test.txt expect.txt"
 
 cp backup.txt test.txt
 test_expect_failure "merge with conflicts, using -L" \
-	"git-merge-file -L 1 -L 2 test.txt orig.txt new3.txt"
+	"git merge-file -L 1 -L 2 test.txt orig.txt new3.txt"
 
 cat > expect.txt << EOF
 <<<<<<< 1
@@ -114,7 +114,7 @@ test_expect_success "expected conflict markers, with -L" \
 
 sed "s/ tu / TU /" < new1.txt > new5.txt
 test_expect_failure "conflict in removed tail" \
-	"git-merge-file -p orig.txt new1.txt new5.txt > out"
+	"git merge-file -p orig.txt new1.txt new5.txt > out"
 
 cat > expect << EOF
 Dominus regit me,
@@ -28,7 +28,7 @@ echo B > a1 &&
 GIT_AUTHOR_DATE="2006-12-12 23:00:02" git commit -m B a1 &&
 
 git checkout -b D A &&
-git-rev-parse B > .git/MERGE_HEAD &&
+git rev-parse B > .git/MERGE_HEAD &&
 echo D > a1 &&
 git update-index a1 &&
 GIT_AUTHOR_DATE="2006-12-12 23:00:03" git commit -m D &&
@@ -42,19 +42,19 @@ echo C > a1 &&
 GIT_AUTHOR_DATE="2006-12-12 23:00:05" git commit -m C a1 &&
 
 git checkout -b E C &&
-git-rev-parse B > .git/MERGE_HEAD &&
+git rev-parse B > .git/MERGE_HEAD &&
 echo E > a1 &&
 git update-index a1 &&
 GIT_AUTHOR_DATE="2006-12-12 23:00:06" git commit -m E &&
 
 git checkout -b G E &&
-git-rev-parse A > .git/MERGE_HEAD &&
+git rev-parse A > .git/MERGE_HEAD &&
 echo G > a1 &&
 git update-index a1 &&
 GIT_AUTHOR_DATE="2006-12-12 23:00:07" git commit -m G &&
 
 git checkout -b F D &&
-git-rev-parse C > .git/MERGE_HEAD &&
+git rev-parse C > .git/MERGE_HEAD &&
 echo F > a1 &&
 git update-index a1 &&
 GIT_AUTHOR_DATE="2006-12-12 23:00:08" git commit -m F
@@ -12,22 +12,22 @@ if core.symlinks is false.'
 
 test_expect_success \
 'setup' '
-git-config core.symlinks false &&
+git config core.symlinks false &&
 > file &&
-git-add file &&
+git add file &&
 git-commit -m initial &&
-git-branch b-symlink &&
-git-branch b-file &&
+git branch b-symlink &&
+git branch b-file &&
 l=$(echo -n file | git-hash-object -t blob -w --stdin) &&
-echo "120000 $l	symlink" | git-update-index --index-info &&
+echo "120000 $l	symlink" | git update-index --index-info &&
 git-commit -m master &&
 git-checkout b-symlink &&
 l=$(echo -n file-different | git-hash-object -t blob -w --stdin) &&
-echo "120000 $l	symlink" | git-update-index --index-info &&
+echo "120000 $l	symlink" | git update-index --index-info &&
 git-commit -m b-symlink &&
 git-checkout b-file &&
 echo plain-file > symlink &&
-git-add symlink &&
+git add symlink &&
 git-commit -m b-file'
 
 test_expect_failure \
@@ -3,31 +3,31 @@
 # Copyright (c) 2005 Johannes Schindelin
 #
 
-test_description='Test git-rev-parse with different parent options'
+test_description='Test git rev-parse with different parent options'
 
 . ./test-lib.sh
 . ../t6000lib.sh # t6xxx specific functions
 
 date >path0
-git-update-index --add path0
-save_tag tree git-write-tree
+git update-index --add path0
+save_tag tree git write-tree
 hide_error save_tag start unique_commit "start" tree
 save_tag second unique_commit "second" tree -p start
 hide_error save_tag start2 unique_commit "start2" tree
 save_tag two_parents unique_commit "next" tree -p second -p start2
 save_tag final unique_commit "final" tree -p two_parents
 
-test_expect_success 'start is valid' 'git-rev-parse start | grep "^[0-9a-f]\{40\}$"'
-test_expect_success 'start^0' "test $(cat .git/refs/tags/start) = $(git-rev-parse start^0)"
-test_expect_success 'start^1 not valid' "if git-rev-parse --verify start^1; then false; else :; fi"
-test_expect_success 'second^1 = second^' "test $(git-rev-parse second^1) = $(git-rev-parse second^)"
-test_expect_success 'final^1^1^1' "test $(git-rev-parse start) = $(git-rev-parse final^1^1^1)"
-test_expect_success 'final^1^1^1 = final^^^' "test $(git-rev-parse final^1^1^1) = $(git-rev-parse final^^^)"
-test_expect_success 'final^1^2' "test $(git-rev-parse start2) = $(git-rev-parse final^1^2)"
-test_expect_success 'final^1^2 != final^1^1' "test $(git-rev-parse final^1^2) != $(git-rev-parse final^1^1)"
-test_expect_success 'final^1^3 not valid' "if git-rev-parse --verify final^1^3; then false; else :; fi"
-test_expect_failure '--verify start2^1' 'git-rev-parse --verify start2^1'
-test_expect_success '--verify start2^0' 'git-rev-parse --verify start2^0'
+test_expect_success 'start is valid' 'git rev-parse start | grep "^[0-9a-f]\{40\}$"'
+test_expect_success 'start^0' "test $(cat .git/refs/tags/start) = $(git rev-parse start^0)"
+test_expect_success 'start^1 not valid' "if git rev-parse --verify start^1; then false; else :; fi"
+test_expect_success 'second^1 = second^' "test $(git rev-parse second^1) = $(git rev-parse second^)"
+test_expect_success 'final^1^1^1' "test $(git rev-parse start) = $(git rev-parse final^1^1^1)"
+test_expect_success 'final^1^1^1 = final^^^' "test $(git rev-parse final^1^1^1) = $(git rev-parse final^^^)"
+test_expect_success 'final^1^2' "test $(git rev-parse start2) = $(git rev-parse final^1^2)"
+test_expect_success 'final^1^2 != final^1^1' "test $(git rev-parse final^1^2) != $(git rev-parse final^1^1)"
+test_expect_success 'final^1^3 not valid' "if git rev-parse --verify final^1^3; then false; else :; fi"
+test_expect_failure '--verify start2^1' 'git rev-parse --verify start2^1'
+test_expect_success '--verify start2^0' 'git rev-parse --verify start2^0'
 
 test_expect_success 'repack for next test' 'git repack -a -d'
 test_expect_success 'short SHA-1 works' '
@@ -28,39 +28,39 @@ check_describe () {
 test_expect_success setup '
 
 	test_tick &&
-	echo one >file && git-add file && git-commit -m initial &&
-	one=$(git-rev-parse HEAD) &&
+	echo one >file && git add file && git-commit -m initial &&
+	one=$(git rev-parse HEAD) &&
 
 	test_tick &&
-	echo two >file && git-add file && git-commit -m second &&
-	two=$(git-rev-parse HEAD) &&
+	echo two >file && git add file && git-commit -m second &&
+	two=$(git rev-parse HEAD) &&
 
 	test_tick &&
-	echo three >file && git-add file && git-commit -m third &&
+	echo three >file && git add file && git-commit -m third &&
 
 	test_tick &&
-	echo A >file && git-add file && git-commit -m A &&
+	echo A >file && git add file && git-commit -m A &&
 	test_tick &&
 	git-tag -a -m A A &&
 
 	test_tick &&
-	echo c >file && git-add file && git-commit -m c &&
+	echo c >file && git add file && git-commit -m c &&
 	test_tick &&
 	git-tag c &&
 
 	git reset --hard $two &&
 	test_tick &&
-	echo B >side && git-add side && git-commit -m B &&
+	echo B >side && git add side && git-commit -m B &&
 	test_tick &&
 	git-tag -a -m B B &&
 
 	test_tick &&
 	git-merge -m Merged c &&
-	merged=$(git-rev-parse HEAD) &&
+	merged=$(git rev-parse HEAD) &&
 
 	git reset --hard $two &&
 	test_tick &&
-	echo D >another && git-add another && git-commit -m D &&
+	echo D >another && git add another && git-commit -m D &&
 	test_tick &&
 	git-tag -a -m D D &&
 
@@ -77,7 +77,7 @@ test_expect_success setup '
 	git-merge -m Merged $merged &&
 
 	test_tick &&
-	echo X >file && echo X >side && git-add file side &&
+	echo X >file && echo X >side && git add file side &&
 	git-commit -m x
 
 '
@@ -1,18 +1,18 @@
 #!/bin/sh
 
-test_description='git-mv in subdirs'
+test_description='git mv in subdirs'
 . ./test-lib.sh
 
 test_expect_success \
     'prepare reference tree' \
     'mkdir path0 path1 &&
      cp ../../COPYING path0/COPYING &&
-     git-add path0/COPYING &&
+     git add path0/COPYING &&
      git-commit -m add -a'
 
 test_expect_success \
     'moving the file out of subdirectory' \
-    'cd path0 && git-mv COPYING ../path1/COPYING'
+    'cd path0 && git mv COPYING ../path1/COPYING'
 
 # in path0 currently
 test_expect_success \
@@ -21,12 +21,12 @@ test_expect_success \
 
 test_expect_success \
     'checking the commit' \
-    'git-diff-tree -r -M --name-status  HEAD^ HEAD | \
+    'git diff-tree -r -M --name-status  HEAD^ HEAD | \
     grep -E "^R100.+path0/COPYING.+path1/COPYING"'
 
 test_expect_success \
     'moving the file back into subdirectory' \
-    'cd path0 && git-mv ../path1/COPYING COPYING'
+    'cd path0 && git mv ../path1/COPYING COPYING'
 
 # in path0 currently
 test_expect_success \
@@ -35,56 +35,56 @@ test_expect_success \
 
 test_expect_success \
     'checking the commit' \
-    'git-diff-tree -r -M --name-status  HEAD^ HEAD | \
+    'git diff-tree -r -M --name-status  HEAD^ HEAD | \
     grep -E "^R100.+path1/COPYING.+path0/COPYING"'
 
 test_expect_success \
     'adding another file' \
     'cp ../../README path0/README &&
-     git-add path0/README &&
+     git add path0/README &&
      git-commit -m add2 -a'
 
 test_expect_success \
     'moving whole subdirectory' \
-    'git-mv path0 path2'
+    'git mv path0 path2'
 
 test_expect_success \
     'commiting the change' \
     'git-commit -m dir-move -a'
 
 test_expect_success \
     'checking the commit' \
-    'git-diff-tree -r -M --name-status  HEAD^ HEAD | \
+    'git diff-tree -r -M --name-status  HEAD^ HEAD | \
      grep -E "^R100.+path0/COPYING.+path2/COPYING" &&
-     git-diff-tree -r -M --name-status  HEAD^ HEAD | \
+     git diff-tree -r -M --name-status  HEAD^ HEAD | \
      grep -E "^R100.+path0/README.+path2/README"'
 
 test_expect_success \
     'succeed when source is a prefix of destination' \
-    'git-mv path2/COPYING path2/COPYING-renamed'
+    'git mv path2/COPYING path2/COPYING-renamed'
 
 test_expect_success \
     'moving whole subdirectory into subdirectory' \
-    'git-mv path2 path1'
+    'git mv path2 path1'
 
 test_expect_success \
     'commiting the change' \
     'git-commit -m dir-move -a'
 
 test_expect_success \
     'checking the commit' \
-    'git-diff-tree -r -M --name-status  HEAD^ HEAD | \
+    'git diff-tree -r -M --name-status  HEAD^ HEAD | \
      grep -E "^R100.+path2/COPYING.+path1/path2/COPYING" &&
-     git-diff-tree -r -M --name-status  HEAD^ HEAD | \
+     git diff-tree -r -M --name-status  HEAD^ HEAD | \
      grep -E "^R100.+path2/README.+path1/path2/README"'
 
 test_expect_failure \
     'do not move directory over existing directory' \
-    'mkdir path0 && mkdir path0/path2 && git-mv path2 path0'
+    'mkdir path0 && mkdir path0/path2 && git mv path2 path0'
 
 test_expect_success \
     'move into "."' \
-    'git-mv path1/path2/ .'
+    'git mv path1/path2/ .'
 
 test_expect_success "Michael Cassar's test case" '
 	rm -fr .git papers partA &&
@@ -27,14 +27,14 @@ test_expect_success 'setup' '
 	make_commit H
 '
 
-H=$(git-rev-parse H)
+H=$(git rev-parse H)
 
 test_expect_success 'rewrite identically' '
 	git-filter-branch H2
 '
 
 test_expect_success 'result is really identical' '
-	test $H = $(git-rev-parse H2)
+	test $H = $(git rev-parse H2)
 '
 
 test_expect_success 'rewrite, renaming a specific file' '
@@ -51,7 +51,7 @@ test_expect_success 'rewrite one branch, keeping a side branch' '
 '
 
 test_expect_success 'common ancestor is still common (unchanged)' '
-	test "$(git-merge-base modD D)" = "$(git-rev-parse B)"
+	test "$(git merge-base modD D)" = "$(git rev-parse B)"
 '
 
 test_expect_success 'filter subdirectory only' '
@@ -73,7 +73,7 @@ test_expect_success 'filter subdirectory only' '
 '
 
 test_expect_success 'subdirectory filter result looks okay' '
-	test 2 = $(git-rev-list sub | wc -l) &&
+	test 2 = $(git rev-list sub | wc -l) &&
 	git show sub:new &&
 	! git show sub:subdir
 '
@@ -93,17 +93,17 @@ test_expect_success 'setup and filter history that requires --full-history' '
 '
 
 test_expect_success 'subdirectory filter result looks okay' '
-	test 3 = $(git-rev-list -1 --parents sub-master | wc -w) &&
+	test 3 = $(git rev-list -1 --parents sub-master | wc -w) &&
 	git show sub-master^:new &&
 	git show sub-master^2:new &&
 	! git show sub:subdir
 '
 
 test_expect_success 'use index-filter to move into a subdirectory' '
 	git-filter-branch --index-filter \
-		 "git-ls-files -s | sed \"s-\\t-&newsubdir/-\" |
+		 "git ls-files -s | sed \"s-\\t-&newsubdir/-\" |
 	          GIT_INDEX_FILE=\$GIT_INDEX_FILE.new \
-			git-update-index --index-info &&
+			git update-index --index-info &&
 		  mv \$GIT_INDEX_FILE.new \$GIT_INDEX_FILE" directorymoved &&
 	test -z "$(git diff HEAD directorymoved:newsubdir)"'
 
@@ -176,7 +176,7 @@ EOF
 test_expect_success \
 	'listing tags with substring as pattern must print those matching' '
 	git-tag -l a > actual &&
-	git-diff expect actual
+	git diff expect actual
 '
 
 cat >expect <<EOF
@@ -187,7 +187,7 @@ EOF
 test_expect_success \
 	'listing tags with substring as pattern must print those matching' '
 	git-tag -l .1 > actual &&
-	git-diff expect actual
+	git diff expect actual
 '
 
 cat >expect <<EOF
@@ -197,7 +197,7 @@ EOF
 test_expect_success \
 	'listing tags with substring as pattern must print those matching' '
 	git-tag -l t21 > actual &&
-	git-diff expect actual
+	git diff expect actual
 '
 
 cat >expect <<EOF
@@ -207,7 +207,7 @@ EOF
 test_expect_success \
 	'listing tags using a name as pattern must print those matching' '
 	git-tag -l a1 > actual &&
-	git-diff expect actual
+	git diff expect actual
 '
 
 cat >expect <<EOF
@@ -217,7 +217,7 @@ EOF
 test_expect_success \
 	'listing tags using a name as pattern must print those matching' '
 	git-tag -l v1.0 > actual &&
-	git-diff expect actual
+	git diff expect actual
 '
 
 cat >expect <<EOF
@@ -226,14 +226,14 @@ EOF
 test_expect_success \
 	'listing tags with ? in the pattern should print those matching' '
 	git-tag -l "1.1?" > actual &&
-	git-diff expect actual
+	git diff expect actual
 '
 
 >expect
 test_expect_success \
 	'listing tags using v.* should print nothing because none have v.' '
 	git-tag -l "v.*" > actual &&
-	git-diff expect actual
+	git diff expect actual
 '
 
 cat >expect <<EOF
@@ -245,16 +245,16 @@ EOF
 test_expect_success \
 	'listing tags using v* should print only those having v' '
 	git-tag -l "v*" > actual &&
-	git-diff expect actual
+	git diff expect actual
 '
 
 # creating and verifying lightweight tags:
 
 test_expect_success \
 	'a non-annotated tag created without parameters should point to HEAD' '
 	git-tag non-annotated-tag &&
-	test $(git-cat-file -t non-annotated-tag) = commit &&
-	test $(git-rev-parse non-annotated-tag) = $(git-rev-parse HEAD)
+	test $(git cat-file -t non-annotated-tag) = commit &&
+	test $(git rev-parse non-annotated-tag) = $(git rev-parse HEAD)
 '
 
 test_expect_failure 'trying to verify an unknown tag should fail' \
@@ -475,7 +475,7 @@ echo '-----BEGIN PGP SIGNATURE-----' >>expect
 test_expect_success 'creating a signed tag with -m message should succeed' '
 	git-tag -s -m "A signed tag message" signed-tag &&
 	get_tag_msg signed-tag >actual &&
-	git-diff expect actual
+	git diff expect actual
 '
 
 test_expect_success 'verifying a signed tag should succeed' \
@@ -10,7 +10,7 @@ test_expect_success \
     'creating initial files' \
     'mkdir path0 &&
      cp ../../COPYING path0/COPYING &&
-     git-add path0/COPYING &&
+     git add path0/COPYING &&
      git-commit -m add -a'
 
 test_expect_success \
@@ -21,10 +21,10 @@ test_expect_success \
      cp ../../COPYING path1/COPYING &&
      cp ../../COPYING COPYING &&
      cp ../../COPYING path0/COPYING-TOO &&
-     git-add path1/path2/COPYING &&
-     git-add path1/COPYING &&
-     git-add COPYING &&
-     git-add path0/COPYING-TOO &&
+     git add path1/path2/COPYING &&
+     git add path1/COPYING &&
+     git add COPYING &&
+     git add path0/COPYING-TOO &&
      git-commit -m change -a'
 
 test_expect_success \
@@ -13,10 +13,10 @@ test_expect_success 'setup' '
 	touch src/part1.c Makefile &&
 	echo build >.gitignore &&
 	echo \*.o >>.gitignore &&
-	git-add . &&
+	git add . &&
 	git-commit -m setup &&
 	touch src/part2.c README &&
-	git-add .
+	git add .
 
 '
 
@@ -141,7 +141,7 @@ test_expect_success 'git-clean -d -X' '
 
 test_expect_success 'clean.requireForce' '
 
-	git-config clean.requireForce true &&
+	git config clean.requireForce true &&
 	! git-clean
 
 '
@@ -23,34 +23,34 @@ subcommands of git-submodule.
 test_expect_success 'Prepare submodule testing' '
 	mkdir lib &&
 	cd lib &&
-	git-init &&
+	git init &&
 	echo a >a &&
-	git-add a &&
+	git add a &&
 	git-commit -m "submodule commit 1" &&
 	git-tag -a -m "rev-1" rev-1 &&
-	rev1=$(git-rev-parse HEAD) &&
+	rev1=$(git rev-parse HEAD) &&
 	if test -z "$rev1"
 	then
-		echo "[OOPS] submodule git-rev-parse returned nothing"
+		echo "[OOPS] submodule git rev-parse returned nothing"
 		false
 	fi &&
 	cd .. &&
 	echo a >a &&
 	echo z >z &&
-	git-add a lib z &&
+	git add a lib z &&
 	git-commit -m "super commit 1" &&
 	mv lib .subrepo &&
-	GIT_CONFIG=.gitmodules git-config submodule.example.url git://example.com/lib.git
+	GIT_CONFIG=.gitmodules git config submodule.example.url git://example.com/lib.git
 '
 
 test_expect_success 'status should fail for unmapped paths' '
 	if git-submodule status
 	then
 		echo "[OOPS] submodule status succeeded"
 		false
-	elif ! GIT_CONFIG=.gitmodules git-config submodule.example.path lib
+	elif ! GIT_CONFIG=.gitmodules git config submodule.example.path lib
 	then
-		echo "[OOPS] git-config failed to update .gitmodules"
+		echo "[OOPS] git config failed to update .gitmodules"
 		false
 	fi
 '
@@ -66,12 +66,12 @@ test_expect_success 'status should initially be "missing"' '
 
 test_expect_success 'init should register submodule url in .git/config' '
 	git-submodule init &&
-	url=$(git-config submodule.example.url) &&
+	url=$(git config submodule.example.url) &&
 	if test "$url" != "git://example.com/lib.git"
 	then
 		echo "[OOPS] init succeeded but submodule url is wrong"
 		false
-	elif ! git-config submodule.example.url ./.subrepo
+	elif ! git config submodule.example.url ./.subrepo
 	then
 		echo "[OOPS] init succeeded but update of url failed"
 		false
@@ -113,7 +113,7 @@ test_expect_success 'update should work when path is an empty dir' '
 	rm -rf lib &&
 	mkdir lib &&
 	git-submodule update &&
-	head=$(cd lib && git-rev-parse HEAD) &&
+	head=$(cd lib && git rev-parse HEAD) &&
 	if test -z "$head"
 	then
 		echo "[OOPS] Failed to obtain submodule head"
@@ -132,13 +132,13 @@ test_expect_success 'status should be "up-to-date" after update' '
 test_expect_success 'status should be "modified" after submodule commit' '
 	cd lib &&
 	echo b >b &&
-	git-add b &&
+	git add b &&
 	git-commit -m "submodule commit 2" &&
-	rev2=$(git-rev-parse HEAD) &&
+	rev2=$(git rev-parse HEAD) &&
 	cd .. &&
 	if test -z "$rev2"
 	then
-		echo "[OOPS] submodule git-rev-parse returned nothing"
+		echo "[OOPS] submodule git rev-parse returned nothing"
 		false
 	fi &&
 	git-submodule status | grep "^+$rev2"
@@ -150,10 +150,10 @@ test_expect_success 'the --cached sha1 should be rev1' '
 
 test_expect_success 'update should checkout rev1' '
 	git-submodule update &&
-	head=$(cd lib && git-rev-parse HEAD) &&
+	head=$(cd lib && git rev-parse HEAD) &&
 	if test -z "$head"
 	then
-		echo "[OOPS] submodule git-rev-parse returned nothing"
+		echo "[OOPS] submodule git rev-parse returned nothing"
 		false
 	elif test "$head" != "$rev1"
 	then
@@ -1,6 +1,6 @@
 #!/bin/sh
 
-test_description='git-annotate'
+test_description='git annotate'
 . ./test-lib.sh
 
 PROG='git annotate'
@@ -1,6 +1,6 @@
 #!/bin/sh
 
-test_description='git-blame'
+test_description='git blame'
 . ./test-lib.sh
 
 PROG='git blame -c'
@@ -86,10 +86,10 @@ test_expect_failure "$name" "
 	rm -f '$GIT_DIR'/index &&
 	git checkout -f -b mybranch3 remotes/git-svn &&
 	rm bar/zzz &&
-	git-update-index --remove bar/zzz &&
+	git update-index --remove bar/zzz &&
 	mkdir bar/zzz &&
 	echo yyy > bar/zzz/yyy &&
-	git-update-index --add bar/zzz/yyy &&
+	git update-index --add bar/zzz/yyy &&
 	git commit -m '$name' &&
 	git-svn set-tree --find-copies-harder --rmdir \
 		remotes/git-svn..mybranch3" || true
@@ -191,8 +191,8 @@ GIT_SVN_ID=alt
 export GIT_SVN_ID
 test_expect_success "$name" \
     "git-svn init $svnrepo && git-svn fetch &&
-     git-rev-list --pretty=raw remotes/git-svn | grep ^tree | uniq > a &&
-     git-rev-list --pretty=raw remotes/alt | grep ^tree | uniq > b &&
+     git rev-list --pretty=raw remotes/git-svn | grep ^tree | uniq > a &&
+     git rev-list --pretty=raw remotes/alt | grep ^tree | uniq > b &&
      git diff a b"
 
 name='check imported tree checksums expected tree checksums'
@@ -214,15 +214,15 @@ EOF
 test_expect_success "$name" "git diff a expected"
 
 test_expect_failure 'exit if remote refs are ambigious' "
-        git-config --add svn-remote.svn.fetch \
+        git config --add svn-remote.svn.fetch \
                               bar:refs/remotes/git-svn &&
         git-svn migrate
         "
 
 test_expect_failure 'exit if init-ing a would clobber a URL' "
         svnadmin create ${PWD}/svnrepo2 &&
         svn mkdir -m 'mkdir bar' ${svnrepo}2/bar &&
-        git-config --unset svn-remote.svn.fetch \
+        git config --unset svn-remote.svn.fetch \
                                 '^bar:refs/remotes/git-svn$' &&
         git-svn init ${svnrepo}2/bar
         "
@@ -30,31 +30,31 @@ test_expect_success 'initialize repo' "
 test_expect_success 'init and fetch a moved directory' "
 	git-svn init --minimize-url -i thunk $svnrepo/thunk &&
 	git-svn fetch -i thunk &&
-	test \"\`git-rev-parse --verify refs/remotes/thunk@2\`\" \
-           = \"\`git-rev-parse --verify refs/remotes/thunk~1\`\" &&
-        test \"\`git-cat-file blob refs/remotes/thunk:readme |\
+	test \"\`git rev-parse --verify refs/remotes/thunk@2\`\" \
+           = \"\`git rev-parse --verify refs/remotes/thunk~1\`\" &&
+        test \"\`git cat-file blob refs/remotes/thunk:readme |\
                  sed -n -e '3p'\`\" = goodbye &&
-	test -z \"\`git-config --get svn-remote.svn.fetch \
+	test -z \"\`git config --get svn-remote.svn.fetch \
 	         '^trunk:refs/remotes/thunk@2$'\`\"
 	"
 
 test_expect_success 'init and fetch from one svn-remote' "
-        git-config svn-remote.svn.url $svnrepo &&
-        git-config --add svn-remote.svn.fetch \
+        git config svn-remote.svn.url $svnrepo &&
+        git config --add svn-remote.svn.fetch \
           trunk:refs/remotes/svn/trunk &&
-        git-config --add svn-remote.svn.fetch \
+        git config --add svn-remote.svn.fetch \
           thunk:refs/remotes/svn/thunk &&
         git-svn fetch -i svn/thunk &&
-	test \"\`git-rev-parse --verify refs/remotes/svn/trunk\`\" \
-           = \"\`git-rev-parse --verify refs/remotes/svn/thunk~1\`\" &&
-        test \"\`git-cat-file blob refs/remotes/svn/thunk:readme |\
+	test \"\`git rev-parse --verify refs/remotes/svn/trunk\`\" \
+           = \"\`git rev-parse --verify refs/remotes/svn/thunk~1\`\" &&
+        test \"\`git cat-file blob refs/remotes/svn/thunk:readme |\
                  sed -n -e '3p'\`\" = goodbye
         "
 
 test_expect_success 'follow deleted parent' "
         svn cp -m 'resurrecting trunk as junk' \
                -r2 $svnrepo/trunk $svnrepo/junk &&
-        git-config --add svn-remote.svn.fetch \
+        git config --add svn-remote.svn.fetch \
           junk:refs/remotes/svn/junk &&
         git-svn fetch -i svn/thunk &&
         git-svn fetch -i svn/junk &&
@@ -71,13 +71,13 @@ test_expect_success 'follow larger parent' "
         git-svn init --minimize-url -i larger \
           $svnrepo/another-larger/trunk/thunk/bump/thud &&
         git-svn fetch -i larger &&
-        git-rev-parse --verify refs/remotes/larger &&
-        git-rev-parse --verify \
+        git rev-parse --verify refs/remotes/larger &&
+        git rev-parse --verify \
            refs/remotes/larger-parent/trunk/thunk/bump/thud &&
-        test \"\`git-merge-base \
+        test \"\`git merge-base \
                  refs/remotes/larger-parent/trunk/thunk/bump/thud \
                  refs/remotes/larger\`\" = \
-             \"\`git-rev-parse refs/remotes/larger\`\"
+             \"\`git rev-parse refs/remotes/larger\`\"
         true
         "
 
@@ -19,9 +19,9 @@ test_expect_success 'setup old-looking metadata' "
 	mv $GIT_DIR/svn/* $GIT_DIR/ &&
 	mv $GIT_DIR/svn/.metadata $GIT_DIR/ &&
 	rmdir $GIT_DIR/svn &&
-	git-update-ref refs/heads/git-svn-HEAD refs/remotes/git-svn &&
-	git-update-ref refs/heads/svn-HEAD refs/remotes/git-svn &&
-	git-update-ref -d refs/remotes/git-svn refs/remotes/git-svn
+	git update-ref refs/heads/git-svn-HEAD refs/remotes/git-svn &&
+	git update-ref refs/heads/svn-HEAD refs/remotes/git-svn &&
+	git update-ref -d refs/remotes/git-svn refs/remotes/git-svn
 	"
 
 head=`git rev-parse --verify refs/heads/git-svn-HEAD^0`
@@ -33,29 +33,29 @@ test_expect_success 'initialize old-style (v0) git-svn layout' "
 	echo $svnrepo > $GIT_DIR/svn/info/url &&
 	git-svn migrate &&
 	! test -d $GIT_DIR/git-svn &&
-	git-rev-parse --verify refs/remotes/git-svn^0 &&
-	git-rev-parse --verify refs/remotes/svn^0 &&
+	git rev-parse --verify refs/remotes/git-svn^0 &&
+	git rev-parse --verify refs/remotes/svn^0 &&
 	test \`git config --get svn-remote.svn.url\` = '$svnrepo' &&
 	test \`git config --get svn-remote.svn.fetch\` = \
              ':refs/remotes/git-svn'
 	"
 
 test_expect_success 'initialize a multi-repository repo' "
 	git-svn init $svnrepo -T trunk -t tags -b branches &&
-	git-config --get-all svn-remote.svn.fetch > fetch.out &&
+	git config --get-all svn-remote.svn.fetch > fetch.out &&
 	grep '^trunk:refs/remotes/trunk$' fetch.out &&
-	test -n \"\`git-config --get svn-remote.svn.branches \
+	test -n \"\`git config --get svn-remote.svn.branches \
 	            '^branches/\*:refs/remotes/\*$'\`\" &&
-	test -n \"\`git-config --get svn-remote.svn.tags \
+	test -n \"\`git config --get svn-remote.svn.tags \
 	            '^tags/\*:refs/remotes/tags/\*$'\`\" &&
 	git config --unset svn-remote.svn.branches \
 	                        '^branches/\*:refs/remotes/\*$' &&
 	git config --unset svn-remote.svn.tags \
 	                        '^tags/\*:refs/remotes/tags/\*$' &&
-	git-config --add svn-remote.svn.fetch 'branches/a:refs/remotes/a' &&
-	git-config --add svn-remote.svn.fetch 'branches/b:refs/remotes/b' &&
+	git config --add svn-remote.svn.fetch 'branches/a:refs/remotes/a' &&
+	git config --add svn-remote.svn.fetch 'branches/b:refs/remotes/b' &&
 	for i in tags/0.1 tags/0.2 tags/0.3; do
-		git-config --add svn-remote.svn.fetch \
+		git config --add svn-remote.svn.fetch \
 		                 \$i:refs/remotes/\$i || exit 1; done
 	"
 
@@ -86,8 +86,8 @@ test_expect_success 'migrate --minimize on old inited layout' "
 		echo $svnrepo\$path > $GIT_DIR/svn/\$ref/info/url ) || exit 1;
 	done &&
 	git-svn migrate --minimize &&
-	test -z \"\`git-config -l |grep -v '^svn-remote\.git-svn\.'\`\" &&
-	git-config --get-all svn-remote.svn.fetch > fetch.out &&
+	test -z \"\`git config -l |grep -v '^svn-remote\.git-svn\.'\`\" &&
+	git config --get-all svn-remote.svn.fetch > fetch.out &&
 	grep '^trunk:refs/remotes/trunk$' fetch.out &&
 	grep '^branches/a:refs/remotes/a$' fetch.out &&
 	grep '^branches/b:refs/remotes/b$' fetch.out &&
@@ -13,39 +13,39 @@ test_expect_success 'load svm repo' "
 	git-svn init --minimize-url -R argh -i dir $svnrepo/mirror/argh &&
 	git-svn init --minimize-url -R argh -i e \
 	  $svnrepo/mirror/argh/a/b/c/d/e &&
-	git-config svn.useSvmProps true &&
+	git config svn.useSvmProps true &&
 	git-svn fetch --all
 	"
 
 uuid=161ce429-a9dd-4828-af4a-52023f968c89
 
 bar_url=http://mayonaise/svnrepo/bar
 test_expect_success 'verify metadata for /bar' "
-	git-cat-file commit refs/remotes/bar | \
+	git cat-file commit refs/remotes/bar | \
 	   grep '^git-svn-id: $bar_url@12 $uuid$' &&
-	git-cat-file commit refs/remotes/bar~1 | \
+	git cat-file commit refs/remotes/bar~1 | \
 	   grep '^git-svn-id: $bar_url@11 $uuid$' &&
-	git-cat-file commit refs/remotes/bar~2 | \
+	git cat-file commit refs/remotes/bar~2 | \
 	   grep '^git-svn-id: $bar_url@10 $uuid$' &&
-	git-cat-file commit refs/remotes/bar~3 | \
+	git cat-file commit refs/remotes/bar~3 | \
 	   grep '^git-svn-id: $bar_url@9 $uuid$' &&
-	git-cat-file commit refs/remotes/bar~4 | \
+	git cat-file commit refs/remotes/bar~4 | \
 	   grep '^git-svn-id: $bar_url@6 $uuid$' &&
-	git-cat-file commit refs/remotes/bar~5 | \
+	git cat-file commit refs/remotes/bar~5 | \
 	   grep '^git-svn-id: $bar_url@1 $uuid$'
 	"
 
 e_url=http://mayonaise/svnrepo/dir/a/b/c/d/e
 test_expect_success 'verify metadata for /dir/a/b/c/d/e' "
-	git-cat-file commit refs/remotes/e | \
+	git cat-file commit refs/remotes/e | \
 	   grep '^git-svn-id: $e_url@1 $uuid$'
 	"
 
 dir_url=http://mayonaise/svnrepo/dir
 test_expect_success 'verify metadata for /dir' "
-	git-cat-file commit refs/remotes/dir | \
+	git cat-file commit refs/remotes/dir | \
 	   grep '^git-svn-id: $dir_url@2 $uuid$' &&
-	git-cat-file commit refs/remotes/dir~1 | \
+	git cat-file commit refs/remotes/dir~1 | \
 	   grep '^git-svn-id: $dir_url@1 $uuid$'
 	"
 
@@ -12,39 +12,39 @@ test_expect_success 'load svnsync repo' "
 	git-svn init --minimize-url -R arr -i bar $svnrepo/bar &&
 	git-svn init --minimize-url -R argh -i dir $svnrepo/dir &&
 	git-svn init --minimize-url -R argh -i e $svnrepo/dir/a/b/c/d/e &&
-	git-config svn.useSvnsyncProps true &&
+	git config svn.useSvnsyncProps true &&
 	git-svn fetch --all
 	"
 
 uuid=161ce429-a9dd-4828-af4a-52023f968c89
 
 bar_url=http://mayonaise/svnrepo/bar
 test_expect_success 'verify metadata for /bar' "
-	git-cat-file commit refs/remotes/bar | \
+	git cat-file commit refs/remotes/bar | \
 	   grep '^git-svn-id: $bar_url@12 $uuid$' &&
-	git-cat-file commit refs/remotes/bar~1 | \
+	git cat-file commit refs/remotes/bar~1 | \
 	   grep '^git-svn-id: $bar_url@11 $uuid$' &&
-	git-cat-file commit refs/remotes/bar~2 | \
+	git cat-file commit refs/remotes/bar~2 | \
 	   grep '^git-svn-id: $bar_url@10 $uuid$' &&
-	git-cat-file commit refs/remotes/bar~3 | \
+	git cat-file commit refs/remotes/bar~3 | \
 	   grep '^git-svn-id: $bar_url@9 $uuid$' &&
-	git-cat-file commit refs/remotes/bar~4 | \
+	git cat-file commit refs/remotes/bar~4 | \
 	   grep '^git-svn-id: $bar_url@6 $uuid$' &&
-	git-cat-file commit refs/remotes/bar~5 | \
+	git cat-file commit refs/remotes/bar~5 | \
 	   grep '^git-svn-id: $bar_url@1 $uuid$'
 	"
 
 e_url=http://mayonaise/svnrepo/dir/a/b/c/d/e
 test_expect_success 'verify metadata for /dir/a/b/c/d/e' "
-	git-cat-file commit refs/remotes/e | \
+	git cat-file commit refs/remotes/e | \
 	   grep '^git-svn-id: $e_url@1 $uuid$'
 	"
 
 dir_url=http://mayonaise/svnrepo/dir
 test_expect_success 'verify metadata for /dir' "
-	git-cat-file commit refs/remotes/dir | \
+	git cat-file commit refs/remotes/dir | \
 	   grep '^git-svn-id: $dir_url@2 $uuid$' &&
-	git-cat-file commit refs/remotes/dir~1 | \
+	git cat-file commit refs/remotes/dir~1 | \
 	   grep '^git-svn-id: $dir_url@1 $uuid$'
 	"
 
@@ -60,10 +60,10 @@ INPUT_END
 test_expect_success \
     'A: create pack from stdin' \
     'git-fast-import --export-marks=marks.out <input &&
-	 git-whatchanged master'
+	 git whatchanged master'
 test_expect_success \
 	'A: verify pack' \
-	'for p in .git/objects/pack/*.pack;do git-verify-pack $p||exit;done'
+	'for p in .git/objects/pack/*.pack;do git verify-pack $p||exit;done'
 
 cat >expect <<EOF
 author $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE
@@ -73,7 +73,7 @@ initial
 EOF
 test_expect_success \
 	'A: verify commit' \
-	'git-cat-file commit master | sed 1d >actual &&
+	'git cat-file commit master | sed 1d >actual &&
 	git diff expect actual'
 
 cat >expect <<EOF
@@ -83,29 +83,29 @@ cat >expect <<EOF
 EOF
 test_expect_success \
 	'A: verify tree' \
-	'git-cat-file -p master^{tree} | sed "s/ [0-9a-f]*	/ /" >actual &&
+	'git cat-file -p master^{tree} | sed "s/ [0-9a-f]*	/ /" >actual &&
 	 git diff expect actual'
 
 echo "$file2_data" >expect
 test_expect_success \
 	'A: verify file2' \
-	'git-cat-file blob master:file2 >actual && git diff expect actual'
+	'git cat-file blob master:file2 >actual && git diff expect actual'
 
 echo "$file3_data" >expect
 test_expect_success \
 	'A: verify file3' \
-	'git-cat-file blob master:file3 >actual && git diff expect actual'
+	'git cat-file blob master:file3 >actual && git diff expect actual'
 
 printf "$file4_data" >expect
 test_expect_success \
 	'A: verify file4' \
-	'git-cat-file blob master:file4 >actual && git diff expect actual'
+	'git cat-file blob master:file4 >actual && git diff expect actual'
 
 cat >expect <<EOF
-:2 `git-rev-parse --verify master:file2`
-:3 `git-rev-parse --verify master:file3`
-:4 `git-rev-parse --verify master:file4`
-:5 `git-rev-parse --verify master^0`
+:2 `git rev-parse --verify master:file2`
+:3 `git rev-parse --verify master:file3`
+:4 `git rev-parse --verify master:file4`
+:5 `git rev-parse --verify master^0`
 EOF
 test_expect_success \
 	'A: verify marks output' \
@@ -134,19 +134,19 @@ INPUT_END
 test_expect_success \
 	'A: verify marks import does not crash' \
 	'git-fast-import --import-marks=marks.out <input &&
-	 git-whatchanged verify--import-marks'
+	 git whatchanged verify--import-marks'
 test_expect_success \
 	'A: verify pack' \
-	'for p in .git/objects/pack/*.pack;do git-verify-pack $p||exit;done'
+	'for p in .git/objects/pack/*.pack;do git verify-pack $p||exit;done'
 cat >expect <<EOF
 :000000 100755 0000000000000000000000000000000000000000 7123f7f44e39be127c5eb701e5968176ee9d78b1 A	copy-of-file2
 EOF
-git-diff-tree -M -r master verify--import-marks >actual
+git diff-tree -M -r master verify--import-marks >actual
 test_expect_success \
 	'A: verify diff' \
 	'compare_diff_raw expect actual &&
-	 test `git-rev-parse --verify master:file2` \
-	    = `git-rev-parse --verify verify--import-marks:copy-of-file2`'
+	 test `git rev-parse --verify master:file2` \
+	    = `git rev-parse --verify verify--import-marks:copy-of-file2`'
 
 ###
 ### series B
@@ -175,7 +175,7 @@ rm -f .git/objects/pack_* .git/objects/index_*
 ###
 
 newf=`echo hi newf | git-hash-object -w --stdin`
-oldf=`git-rev-parse --verify master:file2`
+oldf=`git rev-parse --verify master:file2`
 test_tick
 cat >input <<INPUT_END
 commit refs/heads/branch
@@ -193,33 +193,33 @@ INPUT_END
 test_expect_success \
     'C: incremental import create pack from stdin' \
     'git-fast-import <input &&
-	 git-whatchanged branch'
+	 git whatchanged branch'
 test_expect_success \
 	'C: verify pack' \
-	'for p in .git/objects/pack/*.pack;do git-verify-pack $p||exit;done'
+	'for p in .git/objects/pack/*.pack;do git verify-pack $p||exit;done'
 test_expect_success \
 	'C: validate reuse existing blob' \
-	'test $newf = `git-rev-parse --verify branch:file2/newf`
-	 test $oldf = `git-rev-parse --verify branch:file2/oldf`'
+	'test $newf = `git rev-parse --verify branch:file2/newf`
+	 test $oldf = `git rev-parse --verify branch:file2/oldf`'
 
 cat >expect <<EOF
-parent `git-rev-parse --verify master^0`
+parent `git rev-parse --verify master^0`
 author $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE
 committer $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE
 
 second
 EOF
 test_expect_success \
 	'C: verify commit' \
-	'git-cat-file commit branch | sed 1d >actual &&
+	'git cat-file commit branch | sed 1d >actual &&
 	 git diff expect actual'
 
 cat >expect <<EOF
 :000000 100755 0000000000000000000000000000000000000000 f1fb5da718392694d0076d677d6d0e364c79b0bc A	file2/newf
 :100644 100644 7123f7f44e39be127c5eb701e5968176ee9d78b1 7123f7f44e39be127c5eb701e5968176ee9d78b1 R100	file2	file2/oldf
 :100644 000000 0d92e9f3374ae2947c23aa477cbc68ce598135f1 0000000000000000000000000000000000000000 D	file3
 EOF
-git-diff-tree -M -r master branch >actual
+git diff-tree -M -r master branch >actual
 test_expect_success \
 	'C: validate rename result' \
 	'compare_diff_raw expect actual'
@@ -251,30 +251,30 @@ INPUT_END
 test_expect_success \
     'D: inline data in commit' \
     'git-fast-import <input &&
-	 git-whatchanged branch'
+	 git whatchanged branch'
 test_expect_success \
 	'D: verify pack' \
-	'for p in .git/objects/pack/*.pack;do git-verify-pack $p||exit;done'
+	'for p in .git/objects/pack/*.pack;do git verify-pack $p||exit;done'
 
 cat >expect <<EOF
 :000000 100755 0000000000000000000000000000000000000000 35a59026a33beac1569b1c7f66f3090ce9c09afc A	newdir/exec.sh
 :000000 100644 0000000000000000000000000000000000000000 046d0371e9220107917db0d0e030628de8a1de9b A	newdir/interesting
 EOF
-git-diff-tree -M -r branch^ branch >actual
+git diff-tree -M -r branch^ branch >actual
 test_expect_success \
 	'D: validate new files added' \
 	'compare_diff_raw expect actual'
 
 echo "$file5_data" >expect
 test_expect_success \
 	'D: verify file5' \
-	'git-cat-file blob branch:newdir/interesting >actual &&
+	'git cat-file blob branch:newdir/interesting >actual &&
 	 git diff expect actual'
 
 echo "$file6_data" >expect
 test_expect_success \
 	'D: verify file6' \
-	'git-cat-file blob branch:newdir/exec.sh >actual &&
+	'git cat-file blob branch:newdir/exec.sh >actual &&
 	 git diff expect actual'
 
 ###
@@ -300,7 +300,7 @@ test_expect_success \
     'git-fast-import --date-format=rfc2822 <input'
 test_expect_success \
 	'E: verify pack' \
-	'for p in .git/objects/pack/*.pack;do git-verify-pack $p||exit;done'
+	'for p in .git/objects/pack/*.pack;do git verify-pack $p||exit;done'
 
 cat >expect <<EOF
 author $GIT_AUTHOR_NAME <$GIT_AUTHOR_EMAIL> 1170778938 -0500
@@ -310,14 +310,14 @@ RFC 2822 type date
 EOF
 test_expect_success \
 	'E: verify commit' \
-	'git-cat-file commit branch | sed 1,2d >actual &&
+	'git cat-file commit branch | sed 1,2d >actual &&
 	git diff expect actual'
 
 ###
 ### series F
 ###
 
-old_branch=`git-rev-parse --verify branch^0`
+old_branch=`git rev-parse --verify branch^0`
 test_tick
 cat >input <<INPUT_END
 commit refs/heads/branch
@@ -339,7 +339,7 @@ test_expect_success \
 		echo BAD gfi did not fail
 		return 1
 	 else
-		if test $old_branch = `git-rev-parse --verify branch^0`
+		if test $old_branch = `git rev-parse --verify branch^0`
 		then
 			: branch unaffected and failure returned
 			return 0
@@ -351,26 +351,26 @@ test_expect_success \
 	'
 test_expect_success \
 	'F: verify pack' \
-	'for p in .git/objects/pack/*.pack;do git-verify-pack $p||exit;done'
+	'for p in .git/objects/pack/*.pack;do git verify-pack $p||exit;done'
 
 cat >expect <<EOF
-tree `git-rev-parse branch~1^{tree}`
-parent `git-rev-parse branch~1`
+tree `git rev-parse branch~1^{tree}`
+parent `git rev-parse branch~1`
 author $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE
 committer $GIT_COMMITTER_NAME <$GIT_COMMITTER_EMAIL> $GIT_COMMITTER_DATE
 
 losing things already?
 EOF
 test_expect_success \
 	'F: verify other commit' \
-	'git-cat-file commit other >actual &&
+	'git cat-file commit other >actual &&
 	git diff expect actual'
 
 ###
 ### series G
 ###
 
-old_branch=`git-rev-parse --verify branch^0`
+old_branch=`git rev-parse --verify branch^0`
 test_tick
 cat >input <<INPUT_END
 commit refs/heads/branch
@@ -387,11 +387,11 @@ test_expect_success \
     'git-fast-import --force <input'
 test_expect_success \
 	'G: verify pack' \
-	'for p in .git/objects/pack/*.pack;do git-verify-pack $p||exit;done'
+	'for p in .git/objects/pack/*.pack;do git verify-pack $p||exit;done'
 test_expect_success \
 	'G: branch changed, but logged' \
-	'test $old_branch != `git-rev-parse --verify branch^0` &&
-	 test $old_branch = `git-rev-parse --verify branch@{1}`'
+	'test $old_branch != `git rev-parse --verify branch^0` &&
+	 test $old_branch = `git rev-parse --verify branch@{1}`'
 
 ###
 ### series H
@@ -421,10 +421,10 @@ INPUT_END
 test_expect_success \
     'H: deletall, add 1' \
     'git-fast-import <input &&
-	 git-whatchanged H'
+	 git whatchanged H'
 test_expect_success \
 	'H: verify pack' \
-	'for p in .git/objects/pack/*.pack;do git-verify-pack $p||exit;done'
+	'for p in .git/objects/pack/*.pack;do git verify-pack $p||exit;done'
 
 cat >expect <<EOF
 :100755 000000 f1fb5da718392694d0076d677d6d0e364c79b0bc 0000000000000000000000000000000000000000 D	file2/newf
@@ -433,15 +433,15 @@ cat >expect <<EOF
 :100644 100644 fcf778cda181eaa1cbc9e9ce3a2e15ee9f9fe791 fcf778cda181eaa1cbc9e9ce3a2e15ee9f9fe791 R100	newdir/interesting	h/e/l/lo
 :100755 000000 e74b7d465e52746be2b4bae983670711e6e66657 0000000000000000000000000000000000000000 D	newdir/exec.sh
 EOF
-git-diff-tree -M -r H^ H >actual
+git diff-tree -M -r H^ H >actual
 test_expect_success \
 	'H: validate old files removed, new files added' \
 	'compare_diff_raw expect actual'
 
 echo "$file5_data" >expect
 test_expect_success \
 	'H: verify file' \
-	'git-cat-file blob H:h/e/l/lo >actual &&
+	'git cat-file blob H:h/e/l/lo >actual &&
 	 git diff expect actual'
 
 ###
@@ -463,7 +463,7 @@ test_expect_success \
     'git-fast-import --export-pack-edges=edges.list <input'
 
 cat >expect <<EOF
-.git/objects/pack/pack-.pack: `git-rev-parse --verify export-boundary`
+.git/objects/pack/pack-.pack: `git rev-parse --verify export-boundary`
 EOF
 test_expect_success \
 	'I: verify edge list' \
@@ -497,7 +497,7 @@ test_expect_success \
     'git-fast-import <input'
 test_expect_success \
 	'J: branch has 1 commit, empty tree' \
-	'test 1 = `git-rev-list J | wc -l` &&
+	'test 1 = `git rev-list J | wc -l` &&
 	 test 0 = `git ls-tree J | wc -l`'
 
 ###
@@ -527,8 +527,8 @@ test_expect_success \
     'git-fast-import <input'
 test_expect_success \
     'K: verify K^1 = branch^1' \
-    'test `git-rev-parse --verify branch^1` \
-		= `git-rev-parse --verify K^1`'
+    'test `git rev-parse --verify branch^1` \
+		= `git rev-parse --verify K^1`'
 
 ###
 ### series L
@@ -577,7 +577,7 @@ EXPECT_END
 test_expect_success \
     'L: verify internal tree sorting' \
 	'git-fast-import <input &&
-	 git-diff --raw L^ L >output &&
+	 git diff --raw L^ L >output &&
 	 git diff expect output'
 
 test_done