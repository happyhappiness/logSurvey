diff --git a/src/extract.c b/src/extract.c
index 0cb3e20..0ed4153 100644
--- a/src/extract.c
+++ b/src/extract.c
@@ -315,7 +315,7 @@ delay_set_stat (char const *file_name, struct stat const *stat_info,
 }
 
 /* Update the delayed_set_stat info for an intermediate directory
-   created on the path to DIR.  The intermediate directory turned
+   created within the file name of DIR.  The intermediate directory turned
    out to be the same as this directory, e.g. due to ".." or symbolic
    links.  *DIR_STAT_INFO is the status of the directory.  */
 static void
@@ -355,7 +355,7 @@ static int
 make_directories (char *file_name)
 {
   char *cursor0 = file_name + FILESYSTEM_PREFIX_LEN (file_name);
-  char *cursor;			/* points into path */
+  char *cursor;			/* points into the file name */
   int did_something = 0;	/* did we do anything yet? */
   int mode;
   int invert_permissions;
@@ -372,7 +372,7 @@ make_directories (char *file_name)
       if (cursor == cursor0 || ISSLASH (cursor[-1]))
 	continue;
 
-      /* Avoid mkdir where last part of path is "." or "..".  */
+      /* Avoid mkdir where last part of file name is "." or "..".  */
 
       if (cursor[-1] == '.'
 	  && (cursor == cursor0 + 1 || ISSLASH (cursor[-2])
@@ -380,7 +380,7 @@ make_directories (char *file_name)
 		  && (cursor == cursor0 + 2 || ISSLASH (cursor[-3])))))
 	continue;
 
-      *cursor = '\0';		/* truncate the path there */
+      *cursor = '\0';		/* truncate the name there */
       mode = MODE_RWX & ~ newdir_umask;
       invert_permissions = we_are_root ? 0 : MODE_WXUSR & ~ mode;
       status = mkdir (file_name, mode ^ invert_permissions);
diff --git a/src/incremen.c b/src/incremen.c
index 6009a2d..5e853f6 100644
--- a/src/incremen.c
+++ b/src/incremen.c
@@ -39,7 +39,7 @@ struct directory
     enum children children;
     bool nfs;
     bool found;
-    char name[1];		/* path name of directory */
+    char name[1];		/* file name of directory */
   };
 
 static Hash_table *directory_table;
@@ -95,7 +95,7 @@ note_directory (char const *name, dev_t dev, ino_t ino, bool nfs, bool found)
   return directory;
 }
 
-/* Return a directory entry for a given path NAME, or zero if none found.  */
+/* Return a directory entry for a given file NAME, or zero if none found.  */
 static struct directory *
 find_directory (char *name)
 {
@@ -117,11 +117,11 @@ compare_dirents (const void *first, const void *second)
 		 (*(char *const *) second) + 1);
 }
 
-/* Recursively scan the given PATH.  */
+/* Recursively scan the given directory. */
 static void
-scan_path (struct obstack *stk, char *path, dev_t device)
+scan_directory (struct obstack *stk, char *dir_name, dev_t device)
 {
-  char *dirp = savedir (path);	/* for scanning directory */
+  char *dirp = savedir (dir_name);	/* for scanning directory */
   char const *entry;	/* directory entry being scanned */
   size_t entrylen;	/* length of directory entry */
   char *name_buffer;		/* directory, `/', and directory member */
@@ -132,18 +132,18 @@ scan_path (struct obstack *stk, char *path, dev_t device)
 
   if (! dirp)
     {
-      savedir_error (path);
+      savedir_error (dir_name);
     }
   errno = 0;
 
-  name_buffer_size = strlen (path) + NAME_FIELD_SIZE;
+  name_buffer_size = strlen (dir_name) + NAME_FIELD_SIZE;
   name_buffer = xmalloc (name_buffer_size + 2);
-  strcpy (name_buffer, path);
-  if (! ISSLASH (path[strlen (path) - 1]))
+  strcpy (name_buffer, dir_name);
+  if (! ISSLASH (dir_name[strlen (dir_name) - 1]))
     strcat (name_buffer, "/");
   name_length = strlen (name_buffer);
 
-  directory = find_directory (path);
+  directory = find_directory (dir_name);
   children = directory ? directory->children : CHANGED_CHILDREN;
 
   if (dirp && children != NO_CHILDREN)
@@ -298,13 +298,13 @@ sort_obstack (struct obstack *stk)
 }
 
 char *
-get_directory_contents (char *path, dev_t device)
+get_directory_contents (char *dir_name, dev_t device)
 {
   struct obstack stk;
   char *buffer;
 
   obstack_init (&stk);
-  scan_path (&stk, path, device);
+  scan_directory (&stk, dir_name, device);
   buffer = sort_obstack (&stk);
   obstack_free (&stk, NULL);
   return buffer;
diff --git a/src/list.c b/src/list.c
index e2746bc..cb207a9 100644
--- a/src/list.c
+++ b/src/list.c
@@ -1202,7 +1202,7 @@ print_header (struct tar_stat_info *st, off_t block_ordinal)
 
 /* Print a similar line when we make a directory automatically.  */
 void
-print_for_mkdir (char *pathname, int length, mode_t mode)
+print_for_mkdir (char *dirname, int length, mode_t mode)
 {
   char modes[11];
 
@@ -1221,7 +1221,7 @@ print_for_mkdir (char *pathname, int length, mode_t mode)
 	}
 
       fprintf (stdlis, "%s %*s %.*s\n", modes, ugswidth + DATEWIDTH,
-	       _("Creating directory:"), length, quotearg (pathname));
+	       _("Creating directory:"), length, quotearg (dirname));
     }
 }
 
diff --git a/src/misc.c b/src/misc.c
index bca569a..bae6cfc 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -203,32 +203,33 @@ unquote_string (char *string)
 static char *before_backup_name;
 static char *after_backup_name;
 
-/* Return 1 if PATH is obviously "." or "/".  */
+/* Return 1 if FILE_NAME is obviously "." or "/".  */
 static bool
-must_be_dot_or_slash (char const *path)
+must_be_dot_or_slash (char const *file_name)
 {
-  path += FILESYSTEM_PREFIX_LEN (path);
+  file_name += FILESYSTEM_PREFIX_LEN (file_name);
 
-  if (ISSLASH (path[0]))
+  if (ISSLASH (file_name[0]))
     {
       for (;;)
-	if (ISSLASH (path[1]))
-	  path++;
-	else if (path[1] == '.' && ISSLASH (path[2 + (path[2] == '.')]))
-	  path += 2 + (path[2] == '.');
+	if (ISSLASH (file_name[1]))
+	  file_name++;
+	else if (file_name[1] == '.' 
+                 && ISSLASH (file_name[2 + (file_name[2] == '.')]))
+	  file_name += 2 + (file_name[2] == '.');
 	else
-	  return ! path[1];
+	  return ! file_name[1];
     }
   else
     {
-      while (path[0] == '.' && ISSLASH (path[1]))
+      while (file_name[0] == '.' && ISSLASH (file_name[1]))
 	{
-	  path += 2;
-	  while (ISSLASH (*path))
-	    path++;
+	  file_name += 2;
+	  while (ISSLASH (*file_name))
+	    file_name++;
 	}
 
-      return ! path[0] || (path[0] == '.' && ! path[1]);
+      return ! file_name[0] || (file_name[0] == '.' && ! file_name[1]);
     }
 }
 
@@ -236,32 +237,32 @@ must_be_dot_or_slash (char const *path)
    Report an error with errno set to zero for obvious cases of this;
    otherwise call rmdir.  */
 static int
-safer_rmdir (const char *path)
+safer_rmdir (const char *file_name)
 {
-  if (must_be_dot_or_slash (path))
+  if (must_be_dot_or_slash (file_name))
     {
       errno = 0;
       return -1;
     }
 
-  return rmdir (path);
+  return rmdir (file_name);
 }
 
-/* Remove PATH, returning 1 on success.  If PATH is a directory, then
-   if OPTION is RECURSIVE_REMOVE_OPTION is set remove PATH
-   recursively; otherwise, remove it only if it is empty.  If PATH is
+/* Remove FILE_NAME, returning 1 on success.  If FILE_NAME is a directory, 
+   then if OPTION is RECURSIVE_REMOVE_OPTION is set remove FILE_NAME
+   recursively; otherwise, remove it only if it is empty.  If FILE_NAME is
    a directory that cannot be removed (e.g., because it is nonempty)
    and if OPTION is WANT_DIRECTORY_REMOVE_OPTION, then return -1.
-   Return 0 on error, with errno set; if PATH is obviously the working
+   Return 0 on error, with errno set; if FILE_NAME is obviously the working
    directory return zero with errno set to zero.  */
 int
-remove_any_file (const char *path, enum remove_option option)
+remove_any_file (const char *file_name, enum remove_option option)
 {
   /* Try unlink first if we are not root, as this saves us a system
      call in the common case where we're removing a non-directory.  */
   if (! we_are_root)
     {
-      if (unlink (path) == 0)
+      if (unlink (file_name) == 0)
 	return 1;
 
       /* POSIX 1003.1-2001 requires EPERM when attempting to unlink a
@@ -271,13 +272,13 @@ remove_any_file (const char *path, enum remove_option option)
 	return 0;
     }
 
-  if (safer_rmdir (path) == 0)
+  if (safer_rmdir (file_name) == 0)
     return 1;
 
   switch (errno)
     {
     case ENOTDIR:
-      return we_are_root && unlink (path) == 0;
+      return we_are_root && unlink (file_name) == 0;
 
     case 0:
     case EEXIST:
@@ -294,7 +295,7 @@ remove_any_file (const char *path, enum remove_option option)
 
 	case RECURSIVE_REMOVE_OPTION:
 	  {
-	    char *directory = savedir (path);
+	    char *directory = savedir (file_name);
 	    char const *entry;
 	    size_t entrylen;
 
@@ -305,10 +306,10 @@ remove_any_file (const char *path, enum remove_option option)
 		 (entrylen = strlen (entry)) != 0;
 		 entry += entrylen + 1)
 	      {
-		char *path_buffer = new_name (path, entry);
-		int r = remove_any_file (path_buffer, 1);
+		char *file_name_buffer = new_name (file_name, entry);
+		int r = remove_any_file (file_name_buffer, 1);
 		int e = errno;
-		free (path_buffer);
+		free (file_name_buffer);
 
 		if (! r)
 		  {
@@ -319,7 +320,7 @@ remove_any_file (const char *path, enum remove_option option)
 	      }
 
 	    free (directory);
-	    return safer_rmdir (path) == 0;
+	    return safer_rmdir (file_name) == 0;
 	  }
 	}
       break;
@@ -328,28 +329,28 @@ remove_any_file (const char *path, enum remove_option option)
   return 0;
 }
 
-/* Check if PATH already exists and make a backup of it right now.
+/* Check if FILE_NAME already exists and make a backup of it right now.
    Return success (nonzero) only if the backup is either unneeded, or
    successful.  For now, directories are considered to never need
    backup.  If THIS_IS_THE_ARCHIVE is nonzero, this is the archive and
    so, we do not have to backup block or character devices, nor remote
    entities.  */
 bool
-maybe_backup_file (const char *path, int this_is_the_archive)
+maybe_backup_file (const char *file_name, int this_is_the_archive)
 {
   struct stat file_stat;
 
   /* Check if we really need to backup the file.  */
 
-  if (this_is_the_archive && _remdev (path))
+  if (this_is_the_archive && _remdev (file_name))
     return true;
 
-  if (stat (path, &file_stat))
+  if (stat (file_name, &file_stat))
     {
       if (errno == ENOENT)
 	return true;
 
-      stat_error (path);
+      stat_error (file_name);
       return false;
     }
 
@@ -360,7 +361,7 @@ maybe_backup_file (const char *path, int this_is_the_archive)
       && (S_ISBLK (file_stat.st_mode) || S_ISCHR (file_stat.st_mode)))
     return true;
 
-  assign_string (&before_backup_name, path);
+  assign_string (&before_backup_name, file_name);
 
   /* A run situation may exist between Emacs or other GNU programs trying to
      make a backup for the same file simultaneously.  If theoretically
@@ -368,7 +369,7 @@ maybe_backup_file (const char *path, int this_is_the_archive)
      convention, GNU-wide, for all programs doing backups.  */
 
   assign_string (&after_backup_name, 0);
-  after_backup_name = find_backup_file_name (path, backup_type);
+  after_backup_name = find_backup_file_name (file_name, backup_type);
   if (! after_backup_name)
     xalloc_die ();
 
diff --git a/src/names.c b/src/names.c
index e9b689c..5553021 100644
--- a/src/names.c
+++ b/src/names.c
@@ -515,10 +515,10 @@ addname (char const *string, int change_dir)
   return name;
 }
 
-/* Find a match for PATH (whose string length is LENGTH) in the name
+/* Find a match for FILE_NAME (whose string length is LENGTH) in the name
    list.  */
 static struct name *
-namelist_match (char const *path, size_t length)
+namelist_match (char const *file_name, size_t length)
 {
   struct name *p;
 
@@ -526,27 +526,27 @@ namelist_match (char const *path, size_t length)
     {
       /* If first chars don't match, quick skip.  */
 
-      if (p->firstch && p->name[0] != path[0])
+      if (p->firstch && p->name[0] != file_name[0])
 	continue;
 
       if (p->regexp
-	  ? fnmatch (p->name, path, recursion_option) == 0
+	  ? fnmatch (p->name, file_name, recursion_option) == 0
 	  : (p->length <= length
-	     && (path[p->length] == '\0'
-		 || (ISSLASH (path[p->length]) && recursion_option))
-	     && memcmp (path, p->name, p->length) == 0))
+	     && (file_name[p->length] == '\0'
+		 || (ISSLASH (file_name[p->length]) && recursion_option))
+	     && memcmp (file_name, p->name, p->length) == 0))
 	return p;
     }
 
   return 0;
 }
 
-/* Return true if and only if name PATH (from an archive) matches any
+/* Return true if and only if name FILE_NAME (from an archive) matches any
    name from the namelist.  */
 int
-name_match (const char *path)
+name_match (const char *file_name)
 {
-  size_t length = strlen (path);
+  size_t length = strlen (file_name);
 
   while (1)
     {
@@ -563,10 +563,10 @@ name_match (const char *path)
 	  return ! files_from_option;
 	}
 
-      cursor = namelist_match (path, length);
+      cursor = namelist_match (file_name, length);
       if (cursor)
 	{
-	  if (!(ISSLASH (path[cursor->length]) && recursion_option)
+	  if (!(ISSLASH (file_name[cursor->length]) && recursion_option)
 	      || cursor->found_count == 0)
 	    cursor->found_count++; /* remember it matched */
 	  if (starting_file_option)
@@ -750,8 +750,8 @@ compare_names (struct name const *n1, struct name const *n2)
 static void
 add_hierarchy_to_namelist (struct name *name, dev_t device)
 {
-  char *path = name->name;
-  char *buffer = get_directory_contents (path, device);
+  char *file_name = name->name;
+  char *buffer = get_directory_contents (file_name, device);
 
   if (! buffer)
     name->dir_contents = "\0\0\0\0";
@@ -768,7 +768,7 @@ add_hierarchy_to_namelist (struct name *name, dev_t device)
       int change_dir = name->change_dir;
 
       name->dir_contents = buffer;
-      strcpy (namebuf, path);
+      strcpy (namebuf, file_name);
       if (! ISSLASH (namebuf[name_length - 1]))
 	{
 	  namebuf[name_length++] = '/';
@@ -859,13 +859,13 @@ collect_and_sort_names (void)
    will have to do that if it wants to.  Oh, and if the namelist is
    empty, it returns null, unlike name_match, which returns TRUE.  */
 struct name *
-name_scan (const char *path)
+name_scan (const char *file_name)
 {
-  size_t length = strlen (path);
+  size_t length = strlen (file_name);
 
   while (1)
     {
-      struct name *cursor = namelist_match (path, length);
+      struct name *cursor = namelist_match (file_name, length);
       if (cursor)
 	return cursor;
 
@@ -916,18 +916,18 @@ blank_name_list (void)
     name->found_count = 0;
 }
 
-/* Yield a newly allocated file name consisting of PATH concatenated to
-   NAME, with an intervening slash if PATH does not already end in one.  */
+/* Yield a newly allocated file name consisting of FILE_NAME concatenated to
+   NAME, with an intervening slash if FILE_NAME does not already end in one.  */
 char *
-new_name (const char *path, const char *name)
+new_name (const char *file_name, const char *name)
 {
-  size_t pathlen = strlen (path);
+  size_t file_name_len = strlen (file_name);
   size_t namesize = strlen (name) + 1;
-  int slash = pathlen && ! ISSLASH (path[pathlen - 1]);
-  char *buffer = xmalloc (pathlen + slash + namesize);
-  memcpy (buffer, path, pathlen);
-  buffer[pathlen] = '/';
-  memcpy (buffer + pathlen + slash, name, namesize);
+  int slash = file_name_len && ! ISSLASH (file_name[file_name_len - 1]);
+  char *buffer = xmalloc (file_name_len + slash + namesize);
+  memcpy (buffer, file_name, file_name_len);
+  buffer[file_name_len] = '/';
+  memcpy (buffer + file_name_len + slash, name, namesize);
   return buffer;
 }
 
@@ -1016,7 +1016,7 @@ safer_name_suffix (char const *file_name, bool link_target)
     p = file_name;
   else
     {
-      /* Skip file system prefixes, leading pathnames that contain
+      /* Skip file system prefixes, leading file name components that contain
 	 "..", and leading slashes.  */
 
       size_t prefix_len = FILESYSTEM_PREFIX_LEN (file_name);
@@ -1077,7 +1077,7 @@ safer_name_suffix (char const *file_name, bool link_target)
 }
 
 /* Return the size of the prefix of FILE_NAME that is removed after
-   stripping NUM leading path name components.  NUM must be
+   stripping NUM leading file name components.  NUM must be
    positive.  */
 
 size_t
@@ -1101,7 +1101,7 @@ stripped_prefix_len (char const *file_name, size_t num)
   return -1;
 }
 
-/* Return nonzero if NAME contains ".." as a path name component.  */
+/* Return nonzero if NAME contains ".." as a file name component.  */
 bool
 contains_dot_dot (char const *name)
 {
diff --git a/src/rmt.h b/src/rmt.h
index d949071..a685686 100644
--- a/src/rmt.h
+++ b/src/rmt.h
@@ -17,7 +17,7 @@
    along with this program; if not, write to the Free Software Foundation,
    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
 
-extern char *rmt_path__;
+extern char *rmt_dev_name__;
 
 int rmt_open__ (const char *, int, int, const char *);
 int rmt_close__ (int);
@@ -32,12 +32,13 @@ int rmt_ioctl__ (int, int, char *);
    Distributed File System (DFS).  However, when --force-local, a
    filename is never remote.  */
 
-#define _remdev(Path) \
-  (!force_local_option && (rmt_path__ = strchr (Path, ':')) \
-   && rmt_path__ > (Path) && ! memchr (Path, '/', rmt_path__ - (Path)))
+#define _remdev(dev_name) \
+  (!force_local_option && (rmt_dev_name__ = strchr (dev_name, ':')) \
+   && rmt_dev_name__ > (dev_name) \
+   && ! memchr (dev_name, '/', rmt_dev_name__ - (dev_name)))
 
-#define _isrmt(Fd) \
-  ((Fd) >= __REM_BIAS)
+#define _isrmt(fd) \
+  ((fd) >= __REM_BIAS)
 
 #define __REM_BIAS (1 << 30)
 
@@ -45,51 +46,51 @@ int rmt_ioctl__ (int, int, char *);
 # define O_CREAT 01000
 #endif
 
-#define rmtopen(Path, Oflag, Mode, Command) \
-  (_remdev (Path) ? rmt_open__ (Path, Oflag, __REM_BIAS, Command) \
-   : open (Path, Oflag, Mode))
+#define rmtopen(dev_name, oflag, mode, command) \
+  (_remdev (dev_name) ? rmt_open__ (dev_name, oflag, __REM_BIAS, command) \
+   : open (dev_name, oflag, mode))
 
-#define rmtaccess(Path, Amode) \
-  (_remdev (Path) ? 0 : access (Path, Amode))
+#define rmtaccess(dev_name, amode) \
+  (_remdev (dev_name) ? 0 : access (dev_name, amode))
 
-#define rmtstat(Path, Buffer) \
-  (_remdev (Path) ? (errno = EOPNOTSUPP), -1 : stat (Path, Buffer))
+#define rmtstat(dev_name, buffer) \
+  (_remdev (dev_name) ? (errno = EOPNOTSUPP), -1 : stat (dev_name, buffer))
 
-#define rmtcreat(Path, Mode, Command) \
-   (_remdev (Path) \
-    ? rmt_open__ (Path, 1 | O_CREAT, __REM_BIAS, Command) \
-    : creat (Path, Mode))
+#define rmtcreat(dev_name, mode, command) \
+   (_remdev (dev_name) \
+    ? rmt_open__ (dev_name, 1 | O_CREAT, __REM_BIAS, command) \
+    : creat (dev_name, mode))
 
-#define rmtlstat(Path, Buffer) \
-  (_remdev (Path) ? (errno = EOPNOTSUPP), -1 : lstat (Path, Buffer))
+#define rmtlstat(dev_name, muffer) \
+  (_remdev (dev_name) ? (errno = EOPNOTSUPP), -1 : lstat (dev_name, buffer))
 
-#define rmtread(Fd, Buffer, Length) \
-  (_isrmt (Fd) ? rmt_read__ (Fd - __REM_BIAS, Buffer, Length) \
-   : safe_read (Fd, Buffer, Length))
+#define rmtread(fd, buffer, length) \
+  (_isrmt (fd) ? rmt_read__ (fd - __REM_BIAS, buffer, length) \
+   : safe_read (fd, buffer, length))
 
-#define rmtwrite(Fd, Buffer, Length) \
-  (_isrmt (Fd) ? rmt_write__ (Fd - __REM_BIAS, Buffer, Length) \
-   : full_write (Fd, Buffer, Length))
+#define rmtwrite(fd, buffer, length) \
+  (_isrmt (fd) ? rmt_write__ (fd - __REM_BIAS, buffer, length) \
+   : full_write (fd, buffer, length))
 
-#define rmtlseek(Fd, Offset, Where) \
-  (_isrmt (Fd) ? rmt_lseek__ (Fd - __REM_BIAS, Offset, Where) \
-   : lseek (Fd, Offset, Where))
+#define rmtlseek(fd, offset, where) \
+  (_isrmt (fd) ? rmt_lseek__ (fd - __REM_BIAS, offset, where) \
+   : lseek (fd, offset, where))
 
-#define rmtclose(Fd) \
-  (_isrmt (Fd) ? rmt_close__ (Fd - __REM_BIAS) : close (Fd))
+#define rmtclose(fd) \
+  (_isrmt (fd) ? rmt_close__ (fd - __REM_BIAS) : close (fd))
 
-#define rmtioctl(Fd, Request, Argument) \
-  (_isrmt (Fd) ? rmt_ioctl__ (Fd - __REM_BIAS, Request, Argument) \
-   : ioctl (Fd, Request, Argument))
+#define rmtioctl(fd, request, argument) \
+  (_isrmt (fd) ? rmt_ioctl__ (fd - __REM_BIAS, request, argument) \
+   : ioctl (fd, request, argument))
 
-#define rmtdup(Fd) \
-  (_isrmt (Fd) ? (errno = EOPNOTSUPP), -1 : dup (Fd))
+#define rmtdup(fd) \
+  (_isrmt (fd) ? (errno = EOPNOTSUPP), -1 : dup (fd))
 
-#define rmtfstat(Fd, Buffer) \
-  (_isrmt (Fd) ? (errno = EOPNOTSUPP), -1 : fstat (Fd, Buffer))
+#define rmtfstat(fd, buffer) \
+  (_isrmt (fd) ? (errno = EOPNOTSUPP), -1 : fstat (fd, buffer))
 
-#define rmtfcntl(Fd, Command, Argument) \
-  (_isrmt (Fd) ? (errno = EOPNOTSUPP), -1 : fcntl (Fd, Command, Argument))
+#define rmtfcntl(cd, command, argument) \
+  (_isrmt (fd) ? (errno = EOPNOTSUPP), -1 : fcntl (fd, command, argument))
 
-#define rmtisatty(Fd) \
-  (_isrmt (Fd) ? 0 : isatty (Fd))
+#define rmtisatty(fd) \
+  (_isrmt (fd) ? 0 : isatty (fd))
diff --git a/src/rtapelib.c b/src/rtapelib.c
index 9a03a88..a31a893 100644
--- a/src/rtapelib.c
+++ b/src/rtapelib.c
@@ -91,7 +91,7 @@ static int to_remote[MAXUNIT][2] = {{-1, -1}, {-1, -1}, {-1, -1}, {-1, -1}};
 #define RMT_COMMAND (rmt_command_option ? rmt_command_option : "/etc/rmt")
 
 /* Temporary variable used by macros in rmt.h.  */
-char *rmt_path__;
+char *rmt_dev_name__;
 
 
 /* Close remote tape connection HANDLE, and reset errno to ERRNO_VALUE.  */
@@ -348,15 +348,16 @@ encode_oflag (char *buf, int oflag)
 }
 
 /* Open a file (a magnetic tape device?) on the system specified in
-   PATH, as the given user.  PATH has the form `[USER@]HOST:FILE'.
+   FILE_NAME, as the given user. FILE_NAME has the form `[USER@]HOST:FILE'.
    OPEN_MODE is O_RDONLY, O_WRONLY, etc.  If successful, return the
    remote pipe number plus BIAS.  REMOTE_SHELL may be overridden.  On
    error, return -1.  */
 int
-rmt_open__ (const char *path, int open_mode, int bias, const char *remote_shell)
+rmt_open__ (const char *file_name, int open_mode, int bias, 
+            const char *remote_shell)
 {
   int remote_pipe_number;	/* pseudo, biased file descriptor */
-  char *path_copy ;		/* copy of path string */
+  char *file_name_copy;		/* copy of file_name string */
   char *remote_host;		/* remote host name */
   char *remote_file;		/* remote file name (often a device) */
   char *remote_user;		/* remote user name */
@@ -381,21 +382,21 @@ rmt_open__ (const char *path, int open_mode, int bias, const char *remote_shell)
   {
     char *cursor;
 
-    path_copy = xstrdup (path);
-    remote_host = path_copy;
+    file_name_copy = xstrdup (file_name);
+    remote_host = file_name_copy;
     remote_user = 0;
     remote_file = 0;
 
-    for (cursor = path_copy; *cursor; cursor++)
+    for (cursor = file_name_copy; *cursor; cursor++)
       switch (*cursor)
 	{
 	default:
 	  break;
 
 	case '\n':
-	  /* Do not allow newlines in the path, since the protocol
+	  /* Do not allow newlines in the file_name, since the protocol
 	     uses newline delimiters.  */
-	  free (path_copy);
+	  free (file_name_copy);
 	  errno = ENOENT;
 	  return -1;
 
@@ -431,7 +432,7 @@ rmt_open__ (const char *path, int open_mode, int bias, const char *remote_shell)
   if (READ_SIDE (remote_pipe_number) < 0)
     {
       int e = errno;
-      free (path_copy);
+      free (file_name_copy);
       errno = e;
       return -1;
     }
@@ -450,7 +451,7 @@ rmt_open__ (const char *path, int open_mode, int bias, const char *remote_shell)
 #ifdef REMOTE_SHELL
 	remote_shell = REMOTE_SHELL;
 #else
-	free (path_copy);
+	free (file_name_copy);
 	errno = EIO;
 	return -1;
 #endif
@@ -463,7 +464,7 @@ rmt_open__ (const char *path, int open_mode, int bias, const char *remote_shell)
 	|| pipe (from_remote[remote_pipe_number]) == -1)
       {
 	int e = errno;
-	free (path_copy);
+	free (file_name_copy);
 	errno = e;
 	return -1;
       }
@@ -472,7 +473,7 @@ rmt_open__ (const char *path, int open_mode, int bias, const char *remote_shell)
     if (status == -1)
       {
 	int e = errno;
-	free (path_copy);
+	free (file_name_copy);
 	errno = e;
 	return -1;
       }
@@ -526,14 +527,14 @@ rmt_open__ (const char *path, int open_mode, int bias, const char *remote_shell)
       {
 	int e = errno;
 	free (command_buffer);
-	free (path_copy);
+	free (file_name_copy);
 	_rmt_shutdown (remote_pipe_number, e);
 	return -1;
       }
     free (command_buffer);
   }
 
-  free (path_copy);
+  free (file_name_copy);
   return remote_pipe_number + bias;
 }
 
diff --git a/src/update.c b/src/update.c
index 6b33529..b9987af 100644
--- a/src/update.c
+++ b/src/update.c
@@ -42,22 +42,22 @@ bool time_to_start_writing;
    first part of the record.  */
 char *output_start;
 
-/* Catenate file PATH to the archive without creating a header for it.
+/* Catenate file FILE_NAME to the archive without creating a header for it.
    It had better be a tar file or the archive is screwed.  */
 static void
-append_file (char *path)
+append_file (char *file_name)
 {
-  int handle = open (path, O_RDONLY | O_BINARY);
+  int handle = open (file_name, O_RDONLY | O_BINARY);
   struct stat stat_data;
 
   if (handle < 0)
     {
-      open_error (path);
+      open_error (file_name);
       return;
     }
 
   if (fstat (handle, &stat_data) != 0)
-    stat_error (path);
+    stat_error (file_name);
   else
     {
       off_t bytes_left = stat_data.st_size;
@@ -79,14 +79,14 @@ append_file (char *path)
 
 	  status = safe_read (handle, start->buffer, buffer_size);
 	  if (status == SAFE_READ_ERROR)
-	    read_fatal_details (path, stat_data.st_size - bytes_left,
+	    read_fatal_details (file_name, stat_data.st_size - bytes_left,
 				buffer_size);
 	  if (status == 0)
 	    FATAL_ERROR ((0, 0,
 			  ngettext ("%s: File shrank by %s byte",
 				    "%s: File shrank by %s bytes",
 				    bytes_left),
-			  quotearg_colon (path),
+			  quotearg_colon (file_name),
 			  STRINGIFY_BIGINT (bytes_left, buf)));
 
 	  bytes_left -= status;
@@ -96,7 +96,7 @@ append_file (char *path)
     }
 
   if (close (handle) != 0)
-    close_error (path);
+    close_error (file_name);
 }
 
 /* Implement the 'r' (add files to end of archive), and 'u' (add files
@@ -183,18 +183,18 @@ update_archive (void)
   output_start = current_block->buffer;
 
   {
-    char *path;
+    char *file_name;
 
-    while ((path = name_from_list ()) != NULL)
+    while ((file_name = name_from_list ()) != NULL)
       {
-	if (excluded_name (path))
+	if (excluded_name (file_name))
 	  continue;
-	if (interactive_option && !confirm ("add", path))
+	if (interactive_option && !confirm ("add", file_name))
 	  continue;
 	if (subcommand_option == CAT_SUBCOMMAND)
-	  append_file (path);
+	  append_file (file_name);
 	else
-	  dump_file (path, 1, (dev_t) 0);
+	  dump_file (file_name, 1, (dev_t) 0);
       }
   }
 
diff --git a/src/xheader.c b/src/xheader.c
index f26cf66..b63cdb7 100644
--- a/src/xheader.c
+++ b/src/xheader.c
@@ -220,10 +220,10 @@ to_decimal (uintmax_t value, char *where, size_t size)
      %d                       The directory name of the file,
                               equivalent to the result of the
                               dirname utility on the translated
-                              pathname.
+                              file name.
      %f                       The filename of the file, equivalent
                               to the result of the basename
-                              utility on the translated pathname.
+                              utility on the translated file name.
      %p                       The process ID of the pax process.
      %%                       A '%' character. */
 
-- 
cgit v1.0-41-gc330

