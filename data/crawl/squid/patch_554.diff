@@ -39,8 +39,11 @@ xstrncpy(char *dst, const char *src, size_t n)
         return dst;
 
     if (src)
-        while (--n != 0 && *src != '\0')
-            *dst++ = *src++;
+        while (--n != 0 && *src != '\0') {
+            *dst = *src;
+            ++dst;
+            ++src;
+        }
 
     *dst = '\0';
     return r;
@@ -623,13 +623,17 @@ ldap_escape_value(char *escaped, int size, const char *src)
             n += 3;
             size -= 3;
             if (size > 0) {
-                *escaped++ = '\\';
-                snprintf(escaped, 3, "%02x", (unsigned char) *src++);
+                *escaped = '\\';
+                ++escaped;
+                snprintf(escaped, 3, "%02x", (unsigned char) *src);
+                ++src;
                 escaped += 2;
             }
             break;
         default:
-            *escaped++ = *src++;
+            *escaped = *src;
+            ++escaped;
+            ++src;
             ++n;
             --size;
         }
@@ -32,7 +32,8 @@ static unsigned char itoa64[] =	/* 0 ... 63 => ascii - 64 */
 static void md5to64(char *s, unsigned long v, int n)
 {
     while (--n >= 0) {
-        *s++ = itoa64[v & 0x3f];
+        *s = itoa64[v & 0x3f];
+        ++s;
         v >>= 6;
     }
 }
@@ -59,7 +60,8 @@ char *crypt_md5(const char *pw, const char *salt)
     unsigned long l;
 
     if (*salt == '$') {
-        magic = salt++;
+        magic = salt;
+        ++salt;
         while (*salt && *salt != '$')
             ++salt;
         if (*salt == '$') {
@@ -221,7 +221,8 @@ main(int argc, char *argv[])
             debug("ERROR: %s: Unexpected input '%s'\n", argv[0], buf);
             goto error;
         }
-        *password_buf++ = '\0';
+        *password_buf = '\0';
+        ++password_buf;
         rfc1738_unescape(user);
         rfc1738_unescape(password_buf);
         conv.appdata_ptr = (char *) password_buf;	/* from buf above. not allocated */
@@ -264,16 +264,21 @@ urldecode(char *dst, const char *src, int size)
     tmp[2] = '\0';
     while (*src && size > 1) {
         if (*src == '%' && src[1] != '\0' && src[2] != '\0') {
-            src++;
-            tmp[0] = *src++;
-            tmp[1] = *src++;
-            *dst++ = strtol(tmp, NULL, 16);
+            ++src;
+            tmp[0] = *src;
+            ++src;
+            tmp[1] = *src;
+            ++src;
+            *dst = strtol(tmp, NULL, 16);
+            ++dst;
         } else {
-            *dst++ = *src++;
+            *dst = *src;
+            ++dst;
+            ++src;
         }
-        size--;
+        --size;
     }
-    *dst++ = '\0';
+    *dst = '\0';
 }
 
 static int
@@ -308,12 +313,14 @@ authenticate(int socket_fd, const char *username, const char *passwd)
     /*
      *    User Name
      */
-    *ptr++ = PW_USER_NAME;
+    *ptr = PW_USER_NAME;
+    ++ptr;
     length = strlen(username);
     if (length > MAXPWNAM) {
         length = MAXPWNAM;
     }
-    *ptr++ = length + 2;
+    *ptr = length + 2;
+    ++ptr;
     memcpy(ptr, username, length);
     ptr += length;
     total_length += length + 2;
@@ -335,8 +342,10 @@ authenticate(int socket_fd, const char *username, const char *passwd)
      */
     length = ((length / AUTH_VECTOR_LEN) + 1) * AUTH_VECTOR_LEN;
 
-    *ptr++ = PW_PASSWORD;
-    *ptr++ = length + 2;
+    *ptr = PW_PASSWORD;
+    ++ptr;
+    *ptr = length + 2;
+    ++ptr;
 
     secretlen = strlen(secretkey);
     /* Set up the Cipher block chain */
@@ -348,22 +357,27 @@ authenticate(int socket_fd, const char *username, const char *passwd)
         md5_calc(cbc, md5buf, secretlen + AUTH_VECTOR_LEN);
 
         /* Xor the password into the MD5 digest */
-        for (i = 0; i < AUTH_VECTOR_LEN; i++) {
-            *ptr++ = (cbc[i] ^= passbuf[j + i]);
+        for (i = 0; i < AUTH_VECTOR_LEN; ++i) {
+            *ptr = (cbc[i] ^= passbuf[j + i]);
+            ++ptr;
         }
     }
     total_length += length + 2;
 
-    *ptr++ = PW_NAS_PORT_ID;
-    *ptr++ = 6;
+    *ptr = PW_NAS_PORT_ID;
+    ++ptr;
+    *ptr = 6;
+    ++ptr;
 
     ui = htonl(nasport);
     memcpy(ptr, &ui, 4);
     ptr += 4;
     total_length += 6;
 
-    *ptr++ = PW_NAS_PORT_TYPE;
-    *ptr++ = 6;
+    *ptr = PW_NAS_PORT_TYPE;
+    ++ptr;
+    *ptr = 6;
+    ++ptr;
 
     ui = htonl(nasporttype);
     memcpy(ptr, &ui, 4);
@@ -372,14 +386,18 @@ authenticate(int socket_fd, const char *username, const char *passwd)
 
     if (*identifier) {
         int len = strlen(identifier);
-        *ptr++ = PW_NAS_ID;
-        *ptr++ = len + 2;
+        *ptr = PW_NAS_ID;
+        ++ptr;
+        *ptr = len + 2;
+        ++ptr;
         memcpy(ptr, identifier, len);
         ptr += len;
         total_length += len + 2;
     } else {
-        *ptr++ = PW_NAS_IP_ADDRESS;
-        *ptr++ = 6;
+        *ptr = PW_NAS_IP_ADDRESS;
+        ++ptr;
+        *ptr = 6;
+        ++ptr;
 
         ui = htonl(nas_ipaddr);
         memcpy(ptr, &ui, 4);
@@ -397,7 +415,8 @@ authenticate(int socket_fd, const char *username, const char *passwd)
      */
     auth->length = htons(total_length);
 
-    while (retry--) {
+    while (retry) {
+        --retry;
         int time_spent;
         struct timeval sent;
         /*
@@ -566,7 +585,7 @@ main(int argc, char **argv)
         /* Parse out the username and password */
         ptr = buf;
         while (isspace(*ptr))
-            ptr++;
+            ++ptr;
         if ((end = strchr(ptr, ' ')) == NULL) {
             SEND_ERR("No password");
             continue;
@@ -575,7 +594,7 @@ main(int argc, char **argv)
         urldecode(username, ptr, MAXPWNAM);
         ptr = end + 1;
         while (isspace(*ptr))
-            ptr++;
+            ++ptr;
         urldecode(passwd, ptr, MAXPASS);
 
         if (authenticate(sockfd, username, passwd))
@@ -79,17 +79,17 @@ static int good_ipaddr(char *addr)
     digit_count = 0;
     while (*addr != '\0' && *addr != ' ') {
         if (*addr == '.') {
-            dot_count++;
+            ++dot_count;
             digit_count = 0;
         } else if (!isdigit(*addr)) {
             dot_count = 5;
         } else {
-            digit_count++;
+            ++digit_count;
             if (digit_count > 3) {
                 dot_count = 5;
             }
         }
-        addr++;
+        ++addr;
     }
     if (dot_count != 3) {
         return(-1);
@@ -112,16 +112,18 @@ static uint32_t ipstr2long(char *ip_str)
     int	cur_byte;
 
     ipaddr = (uint32_t)0;
-    for (i = 0; i < 4; i++) {
+    for (i = 0; i < 4; ++i) {
         ptr = buf;
         count = 0;
         *ptr = '\0';
         while (*ip_str != '.' && *ip_str != '\0' && count < 4) {
             if (!isdigit(*ip_str)) {
                 return((uint32_t)0);
             }
-            *ptr++ = *ip_str++;
-            count++;
+            *ptr = *ip_str;
+            ++ptr;
+            ++ip_str;
+            ++count;
         }
         if (count >= 4 || count == 0) {
             return((uint32_t)0);
@@ -131,7 +133,7 @@ static uint32_t ipstr2long(char *ip_str)
         if (cur_byte < 0 || cur_byte > 255) {
             return((uint32_t)0);
         }
-        ip_str++;
+        ++ip_str;
         ipaddr = ipaddr << 8 | (uint32_t)cur_byte;
     }
     return(ipaddr);
@@ -99,7 +99,8 @@ main(int argc, char *argv[])
             SEND_ERR("No Password");
             continue;
         }
-        *password++ = '\0';
+        *password = '\0';
+        ++password;
 
         rfc1738_unescape(username);
         rfc1738_unescape(password);
@@ -91,7 +91,8 @@ print_esc(FILE * p, char *s)
         if (*t == '\\')
             buf[i++] = '\\';
 
-        buf[i++] = *t;
+        buf[i] = *t;
+        ++i;
     }
 
     if (i > 0) {
@@ -170,13 +170,17 @@ ldap_escape_value(char *escaped, int size, const char *src)
             n += 3;
             size -= 3;
             if (size > 0) {
-                *escaped++ = '\\';
-                snprintf(escaped, 3, "%02x", (int) *src++);
+                *escaped = '\\';
+                ++escaped;
+                snprintf(escaped, 3, "%02x", (int) *src);
+                ++src;
                 escaped += 2;
             }
             break;
         default:
-            *escaped++ = *src++;
+            *escaped = *src;
+            ++escaped;
+            ++src;
             ++n;
             --size;
         }
@@ -171,13 +171,17 @@ ldap_escape_value(char *escaped, int size, const char *src)
             n += 3;
             size -= 3;
             if (size > 0) {
-                *escaped++ = '\\';
-                snprintf(escaped, 3, "%02x", (int) *src++);
+                *escaped = '\\';
+                ++escaped;
+                snprintf(escaped, 3, "%02x", (int) *src);
+                ++src;
                 escaped += 2;
             }
             break;
         default:
-            *escaped++ = *src++;
+            *escaped = *src;
+            ++escaped;
+            ++src;
             ++n;
             --size;
         }
@@ -583,7 +583,7 @@ Valid_Local_Groups(char *UserName, const char **Groups)
      */
     if (nStatus == NERR_Success) {
         if ((pTmpBuf = pBuf) != NULL) {
-            for (i = 0; i < dwEntriesRead; i++) {
+            for (i = 0; i < dwEntriesRead; ++i) {
                 assert(pTmpBuf != NULL);
                 if (pTmpBuf == NULL) {
                     result = 0;
@@ -629,7 +629,7 @@ Valid_Global_Groups(char *UserName, const char **Groups)
 
     strncpy(NTDomain, UserName, sizeof(NTDomain));
 
-    for (j = 0; j < strlen(NTV_VALID_DOMAIN_SEPARATOR); j++) {
+    for (j = 0; j < strlen(NTV_VALID_DOMAIN_SEPARATOR); ++j) {
         if ((domain_qualify = strchr(NTDomain, NTV_VALID_DOMAIN_SEPARATOR[j])) != NULL)
             break;
     }
@@ -850,7 +850,7 @@ main(int argc, char *argv[])
             continue;
         }
         username = strtok(buf, " ");
-        for (n = 0; (group = strtok(NULL, " ")) != NULL; n++) {
+        for (n = 0; (group = strtok(NULL, " ")) != NULL; ++n) {
             rfc1738_unescape(group);
             groups[n] = group;
         }
@@ -631,13 +631,17 @@ ldap_escape_value(char *escaped, int size, const char *src)
             n += 3;
             size -= 3;
             if (size > 0) {
-                *escaped++ = '\\';
-                snprintf(escaped, 3, "%02x", (unsigned char) *src++);
+                *escaped = '\\';
+                ++escaped;
+                snprintf(escaped, 3, "%02x", (unsigned char) *src);
+                ++src;
                 escaped += 2;
             }
             break;
         default:
-            *escaped++ = *src++;
+            *escaped = *src;
+            ++escaped;
+            ++src;
             ++n;
             --size;
         }
@@ -678,12 +682,16 @@ build_filter(char *filter, int size, const char *templ, const char *user, const
         case '\\':
             ++templ;
             if (*templ) {
-                *filter++ = *templ++;
+                *filter = *templ;
+                ++filter;
+                ++templ;
                 --size;
             }
             break;
         default:
-            *filter++ = *templ++;
+            *filter = *templ;
+            ++filter;
+            ++templ;
             --size;
             break;
         }
@@ -285,7 +285,7 @@ Valid_Local_Groups(char *UserName, const char **Groups)
      */
     if (nStatus == NERR_Success) {
         if ((pTmpBuf = pBuf) != NULL) {
-            for (i = 0; i < dwEntriesRead; i++) {
+            for (i = 0; i < dwEntriesRead; ++i) {
                 assert(pTmpBuf != NULL);
                 if (pTmpBuf == NULL) {
                     result = 0;
@@ -341,7 +341,7 @@ Valid_Global_Groups(char *UserName, const char **Groups)
 
     strncpy(NTDomain, UserName, sizeof(NTDomain));
 
-    for (j = 0; j < strlen(NTV_VALID_DOMAIN_SEPARATOR); j++) {
+    for (j = 0; j < strlen(NTV_VALID_DOMAIN_SEPARATOR); ++j) {
         if ((domain_qualify = strchr(NTDomain, NTV_VALID_DOMAIN_SEPARATOR[j])) != NULL)
             break;
     }
@@ -422,7 +422,7 @@ Valid_Global_Groups(char *UserName, const char **Groups)
          */
         if (nStatus == NERR_Success) {
             if ((pTmpBuf = pUsrBuf) != NULL) {
-                for (i = 0; i < dwEntriesRead; i++) {
+                for (i = 0; i < dwEntriesRead; ++i) {
                     assert(pTmpBuf != NULL);
                     if (pTmpBuf == NULL) {
                         result = 0;
@@ -579,7 +579,7 @@ main(int argc, char *argv[])
             continue;
         }
         username = strtok(buf, " ");
-        for (n = 0; (group = strtok(NULL, " ")) != NULL; n++) {
+        for (n = 0; (group = strtok(NULL, " ")) != NULL; ++n) {
             rfc1738_unescape(group);
             groups[n] = group;
         }
@@ -1092,7 +1092,7 @@ SearchFilterLDAP(edui_ldap_t *l, char *group)
     bufc[0] = '\134';
     swi = 0;
     j = 1;
-    for (i = 0; i < s; i++) {
+    for (i = 0; i < s; ++i) {
         if (swi == 2) {
             bufc[j] = '\134';
             ++j;
@@ -1256,20 +1256,20 @@ SearchIPLDAP(edui_ldap_t *l)
             l->num_val = x;
             if (x > 0) {
                 /* Display all values */
-                for (i = 0; i < x; i++) {
+                for (i = 0; i < x; ++i) {
                     j = l->val[i]->bv_len;
                     memcpy(bufa, l->val[i]->bv_val, j);
                     z = BinarySplit(bufa, j, '#', bufb, sizeof(bufb));
                     /* BINARY DEBUGGING *
                                         	  local_printfx("value[%" PRIuSIZE "]: BinarySplit(", (size_t) i);
-                                        	  for (k = 0; k < z; k++) {
+                                        	  for (k = 0; k < z; ++k) {
                                         	    c = (int) bufb[k];
                                         	    if (c < 0)
                                         	      c = c + 256;
                                         	    local_printfx("%02X", c);
                                         	  }
                                         	  local_printfx(", ");
-                                        	  for (k = 0; k < (j - z - 1); k++) {
+                                        	  for (k = 0; k < (j - z - 1); ++k) {
                                         	    c = (int) bufa[k];
                                         	    if (c < 0)
                                         	      c = c + 256;
@@ -1284,7 +1284,7 @@ SearchIPLDAP(edui_ldap_t *l)
                         /* bufa is the address, just compare it */
                         if (!(l->status & LDAP_IPV4_S) || (l->status & LDAP_IPV6_S))
                             break;							/* Not looking for IPv4 */
-                        for (k = 0; k < z; k++) {
+                        for (k = 0; k < z; ++k) {
                             c = (int) bufa[k];
                             if (c < 0)
                                 c = c + 256;
@@ -1299,7 +1299,7 @@ SearchIPLDAP(edui_ldap_t *l)
                         if (memcmp(l->search_ip, bufb, y) == 0) {
                             /* We got a match! - Scan 'ber' for 'cn' values */
                             z = ldap_count_values_len(ber);
-                            for (j = 0; j < z; j++) {
+                            for (j = 0; j < z; ++j) {
 // broken?                        xstrncpy(l->userid, ber[j]->bv_val, min(sizeof(l->userid),static_cast<size_t>(ber[j]->bv_len)));
                                 xstrncpy(l->userid, ber[j]->bv_val, sizeof(l->userid));
                                 /* Using bv_len of min() breaks the result by 2 chars */
@@ -1319,7 +1319,7 @@ SearchIPLDAP(edui_ldap_t *l)
                         /* bufa + 2 is the address (skip 2 digit port) */
                         if (!(l->status & LDAP_IPV4_S) || (l->status & LDAP_IPV6_S))
                             break;							/* Not looking for IPv4 */
-                        for (k = 2; k < z; k++) {
+                        for (k = 2; k < z; ++k) {
                             c = (int) bufa[k];
                             if (c < 0)
                                 c = c + 256;
@@ -1334,7 +1334,7 @@ SearchIPLDAP(edui_ldap_t *l)
                         if (memcmp(l->search_ip, bufb, y) == 0) {
                             /* We got a match! - Scan 'ber' for 'cn' values */
                             z = ldap_count_values_len(ber);
-                            for (j = 0; j < z; j++) {
+                            for (j = 0; j < z; ++j) {
 // broken?                        xstrncpy(l->userid, ber[j]->bv_val, min(sizeof(l->userid),static_cast<size_t>(ber[j]->bv_len)));
                                 xstrncpy(l->userid, ber[j]->bv_val, sizeof(l->userid));
                                 /* Using bv_len of min() breaks the result by 2 chars */
@@ -1354,7 +1354,7 @@ SearchIPLDAP(edui_ldap_t *l)
                         /* bufa + 2 is the address (skip 2 digit port) */
                         if (!(l->status & LDAP_IPV6_S))
                             break;							/* Not looking for IPv6 */
-                        for (k = 2; k < z; k++) {
+                        for (k = 2; k < z; ++k) {
                             c = (int) bufa[k];
                             if (c < 0)
                                 c = c + 256;
@@ -1369,7 +1369,7 @@ SearchIPLDAP(edui_ldap_t *l)
                         if (memcmp(l->search_ip, bufb, y) == 0) {
                             /* We got a match! - Scan 'ber' for 'cn' values */
                             z = ldap_count_values_len(ber);
-                            for (j = 0; j < z; j++) {
+                            for (j = 0; j < z; ++j) {
 // broken?                        xstrncpy(l->userid, ber[j]->bv_val, min(sizeof(l->userid),static_cast<size_t>(ber[j]->bv_len)));
                                 xstrncpy(l->userid, ber[j]->bv_val, sizeof(l->userid));
                                 /* Using bv_len of min() breaks the result by 2 chars */
@@ -1527,7 +1527,7 @@ MainSafe(int argc, char **argv)
 
     /* Scan args */
     if (k > 1) {
-        for (i = 1; i < k; i++) {
+        for (i = 1; i < k; ++i) {
             /* Classic / novelty usage schemes */
             if (!strcmp(argv[i], "--help")) {
                 DisplayUsage();
@@ -1540,7 +1540,7 @@ MainSafe(int argc, char **argv)
                 return 1;
             } else if (argv[i][0] == '-') {
                 s = strlen(argv[i]);
-                for (j = 1; j < s; j++) {
+                for (j = 1; j < s; ++j) {
                     switch (argv[i][j]) {
                     case 'h':
                         DisplayUsage();
@@ -1760,7 +1760,7 @@ MainSafe(int argc, char **argv)
         k = strlen(bufa);
         /* BINARY DEBUGGING *
                     local_printfx("while() -> bufa[%" PRIuSIZE "]: %s", k, bufa);
-                    for (i = 0; i < k; i++)
+                    for (i = 0; i < k; ++i)
                       local_printfx("%02X", bufa[i]);
                     local_printfx("\n");
         * BINARY DEBUGGING */
@@ -55,13 +55,13 @@ utf8dup(struct main_args *margs)
     src = margs->glist;
     if (!src)
         return NULL;
-    for (n = 0; n < strlen(src); n++)
+    for (n = 0; n < strlen(src); ++n)
         if ((unsigned char) src[n] > 127)
             ++c;
     if (c != 0) {
         p = (unsigned char *) xmalloc(strlen(src) + c);
         dupp = p;
-        for (n = 0; n < strlen(src); n++) {
+        for (n = 0; n < strlen(src); ++n) {
             s = (unsigned char) src[n];
             if (s > 127 && s < 192) {
                 *p = 194;
@@ -187,7 +187,7 @@ krb5_create_cache(struct main_args *margs, char *domain)
         creds = (krb5_creds *) xmalloc(sizeof(*creds));
         memset(creds, 0, sizeof(*creds));
 
-        for (i = 0; i < nprinc; i++) {
+        for (i = 0; i < nprinc; ++i) {
             /*
              * get credentials
              */
@@ -324,7 +324,7 @@ krb5_create_cache(struct main_args *margs, char *domain)
         xfree(mem_cache);
     if (principal)
         krb5_free_principal(kparam.context, principal);
-    for (i = 0; i < nprinc; i++) {
+    for (i = 0; i < nprinc; ++i) {
         if (principal_list[i])
             krb5_free_principal(kparam.context, principal_list[i]);
     }
@@ -227,7 +227,7 @@ convert_domain_to_bind_path(char *domain)
     if (!domain)
         return NULL;
 
-    for (dp = domain; *dp; dp++) {
+    for (dp = domain; *dp; ++dp) {
         if (*dp == '.')
             ++i;
     }
@@ -239,12 +239,14 @@ convert_domain_to_bind_path(char *domain)
     bp = bindp;
     strcpy(bp, "dc=");
     bp += 3;
-    for (dp = domain; *dp; dp++) {
+    for (dp = domain; *dp; ++dp) {
         if (*dp == '.') {
             strcpy(bp, ",dc=");
             bp += 4;
-        } else
-            *bp++ = *dp;
+        } else {
+            *bp = *dp;
+            ++bp;
+        }
     }
     *bp = '\0';
     return bindp;
@@ -257,7 +259,7 @@ escape_filter(char *filter)
     char *ldap_filter_esc, *ldf;
 
     i = 0;
-    for (ldap_filter_esc = filter; *ldap_filter_esc; ldap_filter_esc++) {
+    for (ldap_filter_esc = filter; *ldap_filter_esc; ++ldap_filter_esc) {
         if ((*ldap_filter_esc == '*') ||
                 (*ldap_filter_esc == '(') ||
                 (*ldap_filter_esc == ')') ||
@@ -267,7 +269,7 @@ escape_filter(char *filter)
 
     ldap_filter_esc = (char *) xcalloc(strlen(filter) + i + 1, sizeof(char));
     ldf = ldap_filter_esc;
-    for (; *filter; filter++) {
+    for (; *filter; ++filter) {
         if (*filter == '*') {
             strcpy(ldf, "\\2a");
             ldf = ldf + 3;
@@ -328,7 +330,7 @@ check_AD(struct main_args *margs, LDAP * ld)
      * Cleanup
      */
     if (attr_value) {
-        for (j = 0; j < max_attr; j++) {
+        for (j = 0; j < max_attr; ++j) {
             xfree(attr_value[j]);
         }
         xfree(attr_value);
@@ -398,7 +400,7 @@ search_group_tree(struct main_args *margs, LDAP * ld, char *bindp, char *ldap_gr
      */
     retval = 0;
     ldepth = depth + 1;
-    for (j = 0; j < max_attr; j++) {
+    for (j = 0; j < max_attr; ++j) {
 
         /* Compare first CN= value assuming it is the same as the group name itself */
         av = attr_value[j];
@@ -411,7 +413,7 @@ search_group_tree(struct main_args *margs, LDAP * ld, char *bindp, char *ldap_gr
         if (debug_enabled) {
             int n;
             debug((char *) "%s| %s: DEBUG: Entry %d \"%s\" in hex UTF-8 is ", LogTime(), PROGRAM, j + 1, av);
-            for (n = 0; av[n] != '\0'; n++)
+            for (n = 0; av[n] != '\0'; ++n)
                 fprintf(stderr, "%02x", (unsigned char) av[n]);
             fprintf(stderr, "\n");
         }
@@ -446,7 +448,7 @@ search_group_tree(struct main_args *margs, LDAP * ld, char *bindp, char *ldap_gr
      * Cleanup
      */
     if (attr_value) {
-        for (j = 0; j < max_attr; j++) {
+        for (j = 0; j < max_attr; ++j) {
             xfree(attr_value[j]);
         }
         xfree(attr_value);
@@ -597,7 +599,7 @@ get_attributes(struct main_args *margs, LDAP * ld, LDAPMessage * res, const char
                     int il;
 
                     if ((values = ldap_get_values_len(ld, msg, attr)) != NULL) {
-                        for (il = 0; values[il] != NULL; il++) {
+                        for (il = 0; values[il] != NULL; ++il) {
 
                             attr_value = (char **) xrealloc(attr_value, (il + 1) * sizeof(char *));
                             if (!attr_value)
@@ -871,7 +873,7 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
          * Loop over list of ldap servers of users domain
          */
         nhosts = get_ldap_hostname_list(margs, &hlist, 0, domain);
-        for (i = 0; i < nhosts; i++) {
+        for (i = 0; i < nhosts; ++i) {
             port = 389;
             if (hlist[i].port != -1)
                 port = hlist[i].port;
@@ -940,7 +942,7 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
         if (host)
             xfree(host);
         host = NULL;
-        for (i = 0; i < nhosts; i++) {
+        for (i = 0; i < nhosts; ++i) {
 
             ld = tool_ldap_open(margs, hlist[i].host, port, ssl);
             if (!ld)
@@ -1035,7 +1037,7 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
          * Compare group names
          */
         retval = 0;
-        for (j = 0; j < max_attr; j++) {
+        for (j = 0; j < max_attr; ++j) {
 
             /* Compare first CN= value assuming it is the same as the group name itself */
             av = attr_value[j];
@@ -1048,7 +1050,7 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
             if (debug_enabled) {
                 int n;
                 debug((char *) "%s| %s: DEBUG: Entry %d \"%s\" in hex UTF-8 is ", LogTime(), PROGRAM, j + 1, av);
-                for (n = 0; av[n] != '\0'; n++)
+                for (n = 0; av[n] != '\0'; ++n)
                     fprintf(stderr, "%02x", (unsigned char) av[n]);
                 fprintf(stderr, "\n");
             }
@@ -1068,7 +1070,7 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
             if (debug_enabled && max_attr > 0) {
                 debug((char *) "%s| %s: DEBUG: Perform recursive group search\n", LogTime(), PROGRAM);
             }
-            for (j = 0; j < max_attr; j++) {
+            for (j = 0; j < max_attr; ++j) {
 
                 av = attr_value[j];
                 if (search_group_tree(margs, ld, bindp, av, group, 1)) {
@@ -1090,7 +1092,7 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
          * Cleanup
          */
         if (attr_value) {
-            for (j = 0; j < max_attr; j++) {
+            for (j = 0; j < max_attr; ++j) {
                 xfree(attr_value[j]);
             }
             xfree(attr_value);
@@ -1176,7 +1178,7 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
              * Cleanup
              */
             if (attr_value_2) {
-                for (j = 0; j < max_attr_2; j++) {
+                for (j = 0; j < max_attr_2; ++j) {
                     xfree(attr_value_2[j]);
                 }
                 xfree(attr_value_2);
@@ -1192,7 +1194,7 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
          * Cleanup
          */
         if (attr_value) {
-            for (j = 0; j < max_attr; j++) {
+            for (j = 0; j < max_attr; ++j) {
                 xfree(attr_value[j]);
             }
             xfree(attr_value);
@@ -152,7 +152,7 @@ free_hostname_list(struct hstruct **hlist, int nhosts)
     int i;
 
     hp = *hlist;
-    for (i = 0; i < nhosts; i++) {
+    for (i = 0; i < nhosts; ++i) {
         if (hp[i].host)
             xfree(hp[i].host);
         hp[i].host = NULL;
@@ -169,7 +169,8 @@ main(int argc, char *argv[])
             break;
         case 'g':
             grents = (char**)realloc(grents, sizeof(*grents) * (ngroups+1));
-            grents[ngroups++] = optarg;
+            grents[ngroups] = optarg;
+            ++ngroups;
             break;
         case '?':
             if (xisprint(optopt)) {
@@ -223,7 +224,7 @@ main(int argc, char *argv[])
         }
 
         /* check groups supplied on the command line */
-        for (i = 0; i < ngroups; i++) {
+        for (i = 0; i < ngroups; ++i) {
             if (check_pw == 1) {
                 j += validate_user_pw(user, grents[i]);
             }
@@ -243,7 +243,8 @@ ntlm_check_auth(ntlm_authenticate * auth, int auth_length)
     }
     memcpy(domain, tmp.str, tmp.l);
     user = domain + tmp.l;
-    *user++ = '\0';
+    *user = '\0';
+    ++user;
 
     /*      debug("fetching user name\n"); */
     tmp = ntlm_fetch_string(&(auth->hdr), auth_length, &auth->user, auth->flags);
@@ -429,7 +430,8 @@ process_options(int argc, char *argv[])
             free(d);
             continue;
         }
-        *c++ = '\0';
+        *c= '\0';
+        ++c;
         new_dc = (dc *) malloc(sizeof(dc));
         if (!new_dc) {
             fprintf(stderr, "Malloc error while parsing DC options\n");
@@ -184,7 +184,7 @@ MemChunk::~MemChunk()
 {
     memMeterDel(pool->getMeter().alloc, pool->chunk_capacity);
     memMeterDel(pool->getMeter().idle, pool->chunk_capacity);
-    pool->chunkCount--;
+    -- pool->chunkCount;
     pool->allChunks.remove(this, memCompChunks);
     xfree(objCache);
 }
@@ -230,7 +230,7 @@ MemPoolChunked::get()
     /* then try perchunk freelist chain */
     if (nextFreeChunk == NULL) {
         /* no chunk with frees, so create new one */
-        saved_calls--; // compensate for the ++ above
+        -- saved_calls; // compensate for the ++ above
         createChunk();
     }
     /* now we have some in perchunk freelist chain */
@@ -371,7 +371,7 @@ MemPoolChunked::convertFreeCacheToChunkFreeCache()
         chunk = const_cast<MemChunk *>(*allChunks.find(Free, memCompObjChunks));
         assert(splayLastResult == 0);
         assert(chunk->inuse_count > 0);
-        chunk->inuse_count--;
+        -- chunk->inuse_count;
         (void) VALGRIND_MAKE_MEM_DEFINED(Free, sizeof(void *));
         freeCache = *(void **)Free;	/* remove from global cache */
         *(void **)Free = chunk->freeList;	/* stuff into chunks freelist */
@@ -72,7 +72,8 @@ hash_string(const void *data, unsigned int size)
     unsigned int i = 0;
     while (*s) {
         ++j;
-        n ^= 271 * (*s++);
+        n ^= 271 * *s;
+        ++s;
     }
     i = n ^ (j * 271);
     return i % size;
@@ -121,7 +122,7 @@ hash4(const void *data, unsigned int size)
     case 1:
         HASH4;
     }
-    while (loop--) {
+    while (--loop) {
         HASH4;
         HASH4;
         HASH4;
@@ -143,7 +143,8 @@ ntlm_fetch_string(const ntlmhdr *packet, const int32_t packet_size, const strhdr
                 fprintf(stderr, "ntlmssp: bad unicode: %04x\n", c);
                 return rv;
             }
-            *d++ = c;
+            *d = c;
+            ++d;
             ++rv.l;
         }
     } else {
@@ -18,7 +18,7 @@ uc(char *string)
     char *p = string, c;
     while ((c = *p)) {
         *p = xtoupper(c);
-        p++;
+        ++p;
     }
 }
 
@@ -29,7 +29,7 @@ lc(char *string)
     char *p = string, c;
     while ((c = *p)) {
         *p = xtolower(c);
-        p++;
+        ++p;
     }
 }
 
@@ -53,7 +53,7 @@ hex_dump(unsigned char *data, int size)
         char addrstr[10] = {0};
         char hexstr[16 * 3 + 5] = {0};
         char charstr[16 * 1 + 5] = {0};
-        for (n = 1; n <= size; n++) {
+        for (n = 1; n <= size; ++n) {
             if (n % 16 == 1) {
                 /* store address for this line */
                 snprintf(addrstr, sizeof(addrstr), "%.4x", (int) (p - data));
@@ -80,7 +80,7 @@ hex_dump(unsigned char *data, int size)
                 strncat(hexstr, "  ", sizeof(hexstr) - strlen(hexstr) - 1);
                 strncat(charstr, " ", sizeof(charstr) - strlen(charstr) - 1);
             }
-            p++;                /* next byte */
+            ++p;                /* next byte */
         }
 
         if (strlen(hexstr) > 0) {
@@ -159,35 +159,35 @@ cacheDigestAdd(CacheDigest * cd, const cache_key * key)
 
         if (!CBIT_TEST(cd->mask, hashed_keys[0])) {
             CBIT_SET(cd->mask, hashed_keys[0]);
-            on_xition_cnt++;
+            ++on_xition_cnt;
         }
 
         if (!CBIT_TEST(cd->mask, hashed_keys[1])) {
             CBIT_SET(cd->mask, hashed_keys[1]);
-            on_xition_cnt++;
+            ++on_xition_cnt;
         }
 
         if (!CBIT_TEST(cd->mask, hashed_keys[2])) {
             CBIT_SET(cd->mask, hashed_keys[2]);
-            on_xition_cnt++;
+            ++on_xition_cnt;
         }
 
         if (!CBIT_TEST(cd->mask, hashed_keys[3])) {
             CBIT_SET(cd->mask, hashed_keys[3]);
-            on_xition_cnt++;
+            ++on_xition_cnt;
         }
 
         statCounter.cd.on_xition_count.count(on_xition_cnt);
     }
 #endif
-    cd->count++;
+    ++ cd->count;
 }
 
 void
 cacheDigestDel(CacheDigest * cd, const cache_key * key)
 {
     assert(cd && key);
-    cd->del_count++;
+    ++ cd->del_count;
     /* we do not support deletions from the digest */
 }
 
@@ -208,16 +208,16 @@ cacheDigestStats(const CacheDigest * cd, CacheDigestStats * stats)
         const int is_on = 0 != CBIT_TEST(cd->mask, pos);
 
         if (is_on)
-            on_count++;
+            ++on_count;
 
         if (is_on != cur_seq_type || !pos) {
             seq_len_sum += cur_seq_len;
-            seq_count++;
+            ++seq_count;
             cur_seq_type = is_on;
             cur_seq_len = 0;
         }
 
-        cur_seq_len++;
+        ++cur_seq_len;
     }
 
     stats->bit_count = cd->mask_size * 8;
@@ -38,7 +38,7 @@ void ClientDelayConfig::dumpPoolCount(StoreEntry * entry, const char *name) cons
 {
     if (pools.size()) {
         storeAppendPrintf(entry, "%s %d\n", name, (int)pools.size());
-        for (unsigned int i = 0; i < pools.size(); i++)
+        for (unsigned int i = 0; i < pools.size(); ++i)
             pools[i].dump(entry, i);
     }
 }
@@ -51,7 +51,7 @@ void ClientDelayConfig::parsePoolCount()
     }
     unsigned short pools_;
     ConfigParser::ParseUShort(&pools_);
-    for (int i = 0; i < pools_; i++) {
+    for (int i = 0; i < pools_; ++i) {
         pools.push_back(ClientDelayPool());
     }
 }
@@ -66,7 +66,7 @@ void ClientDelayConfig::parsePoolRates()
         return;
     }
 
-    pool--;
+    --pool;
 
     pools[pool].rate = GetInteger();
     pools[pool].highwatermark = GetInteger64();
@@ -89,7 +89,7 @@ void ClientDelayConfig::parsePoolAccess(ConfigParser &parser)
 
 void ClientDelayConfig::clean()
 {
-    for (unsigned int i = 0; i < pools.size(); i++) {
+    for (unsigned int i = 0; i < pools.size(); ++i) {
         aclDestroyAccessList(&pools[i].access);
     }
 }
@@ -66,7 +66,7 @@ ConfigParser::strtokFile(void)
                 fn = ++t;
 
                 while (*t && *t != '\"' && *t != '\'')
-                    t++;
+                    ++t;
 
                 *t = '\0';
 
@@ -147,7 +147,7 @@ ConfigParser::ParseQuotedString(String *var, bool *wasQuoted)
             const char * next = s+1; // may point to 0
             memmove(s, next, strlen(next) + 1);
         }
-        s++;
+        ++s;
     }
 
     if (*s != '"') {
@@ -167,15 +167,15 @@ ConfigParser::QuoteString(String &var)
     const char *s = var.termedBuf();
     bool  needQuote = false;
 
-    for (const char *l = s; !needQuote &&  *l != '\0'; l++  )
+    for (const char *l = s; !needQuote &&  *l != '\0'; ++l  )
         needQuote = !isalnum(*l);
 
     if (!needQuote)
         return s;
 
     quotedStr.clean();
     quotedStr.append('"');
-    for (; *s != '\0'; s++) {
+    for (; *s != '\0'; ++s) {
         if (*s == '"' || *s == '\\')
             quotedStr.append('\\');
         quotedStr.append(*s);
@@ -77,7 +77,7 @@ DelayConfig::parsePoolClass()
         return;
     }
 
-    pool--;
+    --pool;
 
     DelayPools::delay_data[pool].createPool(delay_class_);
 }
@@ -93,7 +93,7 @@ DelayConfig::parsePoolRates()
         return;
     }
 
-    pool--;
+    --pool;
 
     if (!DelayPools::delay_data[pool].theComposite().getRaw()) {
         debugs(3, 0, "parse_delay_pool_rates: Ignoring pool " << pool + 1 << " attempt to set rates with class not set");
@@ -138,7 +138,7 @@ DelayConfig::dumpPoolCount(StoreEntry * entry, const char *name) const
 
     storeAppendPrintf(entry, "%s %d\n", name, DelayPools::pools());
 
-    for (i = 0; i < DelayPools::pools(); i++)
+    for (i = 0; i < DelayPools::pools(); ++i)
         DelayPools::delay_data[i].dump (entry, i);
 }
 
@@ -105,7 +105,7 @@ DelayId::DelayClient(ClientHttpRequest * http)
         return DelayId();
     }
 
-    for (pool = 0; pool < DelayPools::pools(); pool++) {
+    for (pool = 0; pool < DelayPools::pools(); ++pool) {
 
         /* pools require explicit 'allow' to assign a client into them */
         if (!DelayPools::delay_data[pool].access) {
@@ -37,7 +37,8 @@ DescriptorSet::add(int fd)
         return false; // already have it
 
     assert(size_ < capacity_); // \todo: replace with Must()
-    const int pos = size_++;
+    const int pos = size_;
+    ++size_;
     index_[fd] = pos;
     descriptors_[pos] = fd;
     return true; // really added
@@ -99,7 +99,7 @@ AIODiskFile::open(int flags, mode_t mode, RefCount<IORequestor> callback)
         error(true);
     } else {
         closed = false;
-        store_open_disk_fd++;
+        ++store_open_disk_fd;
         debugs(79, 3, HERE << ": opened FD " << fd);
     }
 
@@ -159,7 +159,7 @@ AIODiskFile::read(ReadRequest *request)
     qe->aq_e_aiocb.aio_buf =  request->buf;
 
     /* Account */
-    strategy->aq.aq_numpending++;
+    ++ strategy->aq.aq_numpending;
 
     /* Initiate aio */
     if (aio_read(&qe->aq_e_aiocb) < 0) {
@@ -136,7 +136,7 @@ AIODiskIOStrategy::callback()
 
     /* Loop through all slots */
 
-    for (i = 0; i < MAX_ASYNCOP; i++) {
+    for (i = 0; i < MAX_ASYNCOP; ++i) {
         if (aq.aq_queue[i].aq_e_state == AQ_ENTRY_USED) {
             aqe = &aq.aq_queue[i];
             /* Active, get status */
@@ -223,7 +223,7 @@ AIODiskIOStrategy::findSlot()
 {
     /* Later we should use something a little more .. efficient :) */
 
-    for (int i = 0; i < MAX_ASYNCOP; i++) {
+    for (int i = 0; i < MAX_ASYNCOP; ++i) {
         if (aq.aq_queue[i].aq_e_state == AQ_ENTRY_FREE)
             /* Found! */
             return i;
@@ -319,7 +319,7 @@ int aio_open(const char *path, int mode)
                            FILE_FLAG_OVERLAPPED,	/* file attributes         */
                            NULL			            /* handle to template file */
                           )) != INVALID_HANDLE_VALUE) {
-        statCounter.syscalls.disk.opens++;
+        ++ statCounter.syscalls.disk.opens;
         fd = _open_osfhandle((long) hndl, 0);
         commSetCloseOnExec(fd);
         fd_open(fd, FD_FILE, path);
@@ -336,7 +336,7 @@ void aio_close(int fd)
 {
     CloseHandle((HANDLE)_get_osfhandle(fd));
     fd_close(fd);
-    statCounter.syscalls.disk.closes++;
+    ++ statCounter.syscalls.disk.closes;
 }
 
 
@@ -82,7 +82,7 @@ BlockingFile::open(int flags, mode_t mode, RefCount<IORequestor> callback)
         error(true);
     } else {
         closed = false;
-        store_open_disk_fd++;
+        ++store_open_disk_fd;
         debugs(79, 3, "BlockingFile::open: opened FD " << fd);
     }
 
@@ -106,7 +106,7 @@ void BlockingFile::doClose()
     if (fd > -1) {
         closed = true;
         file_close(fd);
-        store_open_disk_fd--;
+        --store_open_disk_fd;
         fd = -1;
     }
 }
@@ -75,7 +75,8 @@ DiskdFile::DiskdFile(char const *aPath, DiskdIOStrategy *anIO) : errorOccured (f
     assert (aPath);
     debugs(79, 3, "DiskdFile::DiskdFile: " << aPath);
     path_ = xstrdup (aPath);
-    id = diskd_stats.sio_id++;
+    id = diskd_stats.sio_id;
+    ++diskd_stats.sio_id;
 }
 
 DiskdFile::~DiskdFile()
@@ -112,7 +113,7 @@ DiskdFile::open(int flags, mode_t aMode, RefCount< IORequestor > callback)
         ioRequestor = NULL;
     }
 
-    diskd_stats.open.ops++;
+    ++diskd_stats.open.ops;
 }
 
 void
@@ -145,7 +146,7 @@ DiskdFile::create(int flags, mode_t aMode, RefCount< IORequestor > callback)
         return;
     }
 
-    diskd_stats.create.ops++;
+    ++diskd_stats.create.ops;
 }
 
 void
@@ -174,7 +175,7 @@ DiskdFile::read(ReadRequest *aRead)
         return;
     }
 
-    diskd_stats.read.ops++;
+    ++diskd_stats.read.ops;
 }
 
 void
@@ -200,7 +201,7 @@ DiskdFile::close()
         return;
     }
 
-    diskd_stats.close.ops++;
+    ++diskd_stats.close.ops;
 }
 
 bool
@@ -280,10 +281,10 @@ DiskdFile::openDone(diomsg *M)
     debugs(79, 3, "storeDiskdOpenDone: status " << M->status);
 
     if (M->status < 0) {
-        diskd_stats.open.fail++;
+        ++diskd_stats.open.fail;
         errorOccured = true;
     } else {
-        diskd_stats.open.success++;
+        ++diskd_stats.open.success;
     }
 
     ioCompleted();
@@ -297,10 +298,10 @@ DiskdFile::createDone(diomsg *M)
     debugs(79, 3, "storeDiskdCreateDone: status " << M->status);
 
     if (M->status < 0) {
-        diskd_stats.create.fail++;
+        ++diskd_stats.create.fail;
         errorOccured = true;
     } else {
-        diskd_stats.create.success++;
+        ++diskd_stats.create.success;
     }
 
     ioCompleted();
@@ -338,7 +339,7 @@ DiskdFile::write(WriteRequest *aRequest)
         return;
     }
 
-    diskd_stats.write.ops++;
+    ++diskd_stats.write.ops;
 }
 
 void
@@ -360,10 +361,10 @@ DiskdFile::closeDone(diomsg * M)
     debugs(79, 3, "DiskdFile::closeDone: status " << M->status);
 
     if (M->status < 0) {
-        diskd_stats.close.fail++;
+        ++diskd_stats.close.fail;
         errorOccured = true;
     } else {
-        diskd_stats.close.success++;
+        ++diskd_stats.close.success;
     }
 
     ioCompleted();
@@ -385,14 +386,14 @@ DiskdFile::readDone(diomsg * M)
     readRequest->RefCountDereference();
 
     if (M->status < 0) {
-        diskd_stats.read.fail++;
+        ++diskd_stats.read.fail;
         ioCompleted();
         errorOccured = true;
         ioRequestor->readCompleted(NULL, -1, DISK_ERROR, readRequest);
         return;
     }
 
-    diskd_stats.read.success++;
+    ++diskd_stats.read.success;
 
     ioCompleted();
     ioRequestor->readCompleted (IO->shm.buf + M->shm_offset,  M->status, DISK_OK, readRequest);
@@ -410,13 +411,13 @@ DiskdFile::writeDone(diomsg *M)
 
     if (M->status < 0) {
         errorOccured = true;
-        diskd_stats.write.fail++;
+        ++diskd_stats.write.fail;
         ioCompleted();
         ioRequestor->writeCompleted (DISK_ERROR,0, writeRequest);
         return;
     }
 
-    diskd_stats.write.success++;
+    ++diskd_stats.write.success;
     ioCompleted();
     ioRequestor->writeCompleted (DISK_OK,M->status, writeRequest);
 }
@@ -87,7 +87,7 @@ DiskdIOStrategy::load()
 void
 DiskdIOStrategy::openFailed()
 {
-    diskd_stats.open_fail_queue_len++;
+    ++diskd_stats.open_fail_queue_len;
 }
 
 DiskFile::Pointer
@@ -151,7 +151,7 @@ DiskdIOStrategy::unlinkFile(char const *path)
         //        shm.put (shm_offset);
     }
 
-    diskd_stats.unlink.ops++;
+    ++diskd_stats.unlink.ops;
 }
 
 void
@@ -238,7 +238,7 @@ SharedMemory::get(ssize_t * shm_offset)
     char *aBuf = NULL;
     int i;
 
-    for (i = 0; i < nbufs; i++) {
+    for (i = 0; i < nbufs; ++i) {
         if (CBIT_TEST(inuse_map, i))
             continue;
 
@@ -254,7 +254,7 @@ SharedMemory::get(ssize_t * shm_offset)
     assert(aBuf);
     assert(aBuf >= buf);
     assert(aBuf < buf + (nbufs * SHMBUF_BLKSZ));
-    diskd_stats.shmbuf_count++;
+    ++diskd_stats.shmbuf_count;
 
     if (diskd_stats.max_shmuse < diskd_stats.shmbuf_count)
         diskd_stats.max_shmuse = diskd_stats.shmbuf_count;
@@ -284,7 +284,7 @@ SharedMemory::init(int ikey, int magic2)
     inuse_map = (char *)xcalloc((nbufs + 7) / 8, 1);
     diskd_stats.shmbuf_count += nbufs;
 
-    for (int i = 0; i < nbufs; i++) {
+    for (int i = 0; i < nbufs; ++i) {
         CBIT_SET(inuse_map, i);
         put (i * SHMBUF_BLKSZ);
     }
@@ -297,9 +297,9 @@ DiskdIOStrategy::unlinkDone(diomsg * M)
     ++statCounter.syscalls.disk.unlinks;
 
     if (M->status < 0)
-        diskd_stats.unlink.fail++;
+        ++diskd_stats.unlink.fail;
     else
-        diskd_stats.unlink.success++;
+        ++diskd_stats.unlink.success;
 }
 
 void
@@ -400,8 +400,8 @@ DiskdIOStrategy::SEND(diomsg *M, int mtype, int id, size_t size, off_t offset, s
     last_seq_no = M->seq_no;
 
     if (0 == x) {
-        diskd_stats.sent_count++;
-        away++;
+        ++diskd_stats.sent_count;
+        ++away;
     } else {
         debugs(79, 1, "storeDiskdSend: msgsnd: " << xstrerror());
         cbdataReferenceDone(M->callback_data);
@@ -549,7 +549,7 @@ DiskdIOStrategy::callback()
     int retval = 0;
 
     if (away >= magic2) {
-        diskd_stats.block_queue_len++;
+        ++diskd_stats.block_queue_len;
         retval = 1;
         /* We might not have anything to do, but our queue
          * is full.. */
@@ -574,7 +574,7 @@ DiskdIOStrategy::callback()
             break;
         }
 
-        diskd_stats.recv_count++;
+        ++diskd_stats.recv_count;
         --away;
         handle(&M);
         retval = 1;		/* Return that we've actually done some work */
@@ -96,7 +96,7 @@ DiskThreadsDiskFile::open(int flags, mode_t mode, RefCount<IORequestor> callback
     }
 
 #endif
-    Opening_FD++;
+    ++Opening_FD;
 
     ioRequestor = callback;
 
@@ -145,7 +145,7 @@ DiskThreadsDiskFile::create(int flags, mode_t mode, RefCount<IORequestor> callba
     }
 
 #endif
-    Opening_FD++;
+    ++Opening_FD;
 
     ioRequestor = callback;
 
@@ -179,7 +179,7 @@ void
 DiskThreadsDiskFile::openDone(int unused, const char *unused2, int anFD, int errflag)
 {
     debugs(79, 3, "DiskThreadsDiskFile::openDone: FD " << anFD << ", errflag " << errflag);
-    Opening_FD--;
+    --Opening_FD;
 
     fd = anFD;
 
@@ -189,7 +189,7 @@ DiskThreadsDiskFile::openDone(int unused, const char *unused2, int anFD, int err
         debugs(79, 1, "\t" << path_);
         errorOccured = true;
     } else {
-        store_open_disk_fd++;
+        ++store_open_disk_fd;
         commSetCloseOnExec(fd);
         fd_open(fd, FD_FILE, path_);
     }
@@ -215,7 +215,7 @@ void DiskThreadsDiskFile::doClose()
         file_close(fd);
 #endif
 
-        store_open_disk_fd--;
+        --store_open_disk_fd;
         fd = -1;
     }
 }
@@ -94,7 +94,7 @@ DiskThreadsIOStrategy::callback()
     int retval = 0;
 
     assert(initialised);
-    squidaio_counts.check_callback++;
+    ++squidaio_counts.check_callback;
 
     for (;;) {
         if ((resultp = squidaio_poll_done()) == NULL)
@@ -313,7 +313,7 @@ squidaio_init(void)
 
     assert(NUMTHREADS);
 
-    for (i = 0; i < NUMTHREADS; i++) {
+    for (i = 0; i < NUMTHREADS; ++i) {
         threadp = (squidaio_thread_t *)squidaio_thread_pool->alloc();
         threadp->status = _THREAD_STARTING;
         threadp->current_req = NULL;
@@ -473,7 +473,7 @@ squidaio_thread_loop(void *ptr)
         done_queue.tailp = &request->next;
         pthread_mutex_unlock(&done_queue.mutex);
         CommIO::NotifyIOCompleted();
-        threadp->requests++;
+        ++ threadp->requests;
     }				/* while forever */
 
     return NULL;
@@ -1040,7 +1040,7 @@ squidaio_stats(StoreEntry * sentry)
 
     threadp = threads;
 
-    for (i = 0; i < NUMTHREADS; i++) {
+    for (i = 0; i < NUMTHREADS; ++i) {
         storeAppendPrintf(sentry, "%i\t0x%lx\t%ld\n", i + 1, (unsigned long)threadp->thread, threadp->requests);
         threadp = threadp->next;
     }
@@ -305,7 +305,7 @@ squidaio_init(void)
 
     assert(NUMTHREADS);
 
-    for (i = 0; i < NUMTHREADS; i++) {
+    for (i = 0; i < NUMTHREADS; ++i) {
         threadp = (squidaio_thread_t *)squidaio_thread_pool->alloc();
         threadp->status = _THREAD_STARTING;
         threadp->current_req = NULL;
@@ -364,7 +364,7 @@ squidaio_shutdown(void)
 
     threadp = threads;
 
-    for (i = 0; i < NUMTHREADS; i++) {
+    for (i = 0; i < NUMTHREADS; ++i) {
         threadp->exit = 1;
         hthreads[i] = threadp->thread;
         threadp = threadp->next;
@@ -378,7 +378,7 @@ squidaio_shutdown(void)
 
     WaitForMultipleObjects(NUMTHREADS, hthreads, TRUE, 2000);
 
-    for (i = 0; i < NUMTHREADS; i++) {
+    for (i = 0; i < NUMTHREADS; ++i) {
         CloseHandle(hthreads[i]);
     }
 
@@ -550,7 +550,7 @@ squidaio_thread_loop(LPVOID lpParam)
 
         CommIO::NotifyIOCompleted();
         Sleep(0);
-        threadp->requests++;
+        ++ threadp->requests;
     }				/* while forever */
 
     CloseHandle(cond);
@@ -1153,7 +1153,7 @@ squidaio_stats(StoreEntry * sentry)
 
     threadp = threads;
 
-    for (i = 0; i < NUMTHREADS; i++) {
+    for (i = 0; i < NUMTHREADS; ++i) {
         storeAppendPrintf(sentry, "%i\t0x%lx\t%ld\n", i + 1, threadp->dwThreadId, threadp->requests);
         threadp = threadp->next;
     }
@@ -57,7 +57,7 @@ aioOpen(const char *path, int oflag, mode_t mode, AIOCB * callback, void *callba
     squidaio_ctrl_t *ctrlp;
 
     assert(DiskThreadsIOStrategy::Instance.initialised);
-    squidaio_counts.open_start++;
+    ++squidaio_counts.open_start;
     ctrlp = (squidaio_ctrl_t *)DiskThreadsIOStrategy::Instance.squidaio_ctrl_pool->alloc();
     ctrlp->fd = -2;
     ctrlp->done_handler = callback;
@@ -75,7 +75,7 @@ aioClose(int fd)
     squidaio_ctrl_t *ctrlp;
 
     assert(DiskThreadsIOStrategy::Instance.initialised);
-    squidaio_counts.close_start++;
+    ++squidaio_counts.close_start;
     aioCancel(fd);
     ctrlp = (squidaio_ctrl_t *)DiskThreadsIOStrategy::Instance.squidaio_ctrl_pool->alloc();
     ctrlp->fd = fd;
@@ -95,7 +95,7 @@ aioCancel(int fd)
     dlink_node *m, *next;
 
     assert(DiskThreadsIOStrategy::Instance.initialised);
-    squidaio_counts.cancel++;
+    ++squidaio_counts.cancel;
 
     for (m = used_list.head; m; m = next) {
         next = m->next;
@@ -137,7 +137,7 @@ aioWrite(int fd, off_t offset, char *bufp, size_t len, AIOCB * callback, void *c
     int seekmode;
 
     assert(DiskThreadsIOStrategy::Instance.initialised);
-    squidaio_counts.write_start++;
+    ++squidaio_counts.write_start;
     ctrlp = (squidaio_ctrl_t *)DiskThreadsIOStrategy::Instance.squidaio_ctrl_pool->alloc();
     ctrlp->fd = fd;
     ctrlp->done_handler = callback;
@@ -166,7 +166,7 @@ aioRead(int fd, off_t offset, size_t len, AIOCB * callback, void *callback_data)
     int seekmode;
 
     assert(DiskThreadsIOStrategy::Instance.initialised);
-    squidaio_counts.read_start++;
+    ++squidaio_counts.read_start;
     ctrlp = (squidaio_ctrl_t *)DiskThreadsIOStrategy::Instance.squidaio_ctrl_pool->alloc();
     ctrlp->fd = fd;
     ctrlp->done_handler = callback;
@@ -195,7 +195,7 @@ aioStat(char *path, struct stat *sb, AIOCB * callback, void *callback_data)
     squidaio_ctrl_t *ctrlp;
 
     assert(DiskThreadsIOStrategy::Instance.initialised);
-    squidaio_counts.stat_start++;
+    ++squidaio_counts.stat_start;
     ctrlp = (squidaio_ctrl_t *)DiskThreadsIOStrategy::Instance.squidaio_ctrl_pool->alloc();
     ctrlp->fd = -2;
     ctrlp->done_handler = callback;
@@ -212,7 +212,7 @@ aioUnlink(const char *path, AIOCB * callback, void *callback_data)
 {
     squidaio_ctrl_t *ctrlp;
     assert(DiskThreadsIOStrategy::Instance.initialised);
-    squidaio_counts.unlink_start++;
+    ++squidaio_counts.unlink_start;
     ctrlp = (squidaio_ctrl_t *)DiskThreadsIOStrategy::Instance.squidaio_ctrl_pool->alloc();
     ctrlp->fd = -2;
     ctrlp->done_handler = callback;
@@ -835,7 +835,7 @@ DiskerOpen(const String &path, int flags, mode_t mode)
         return false;
     }
 
-    store_open_disk_fd++;
+    ++store_open_disk_fd;
     debugs(79,3, HERE << "rock db opened " << path << ": FD " << TheFile);
     return true;
 }
@@ -847,7 +847,7 @@ DiskerClose(const String &path)
         file_close(TheFile);
         debugs(79,3, HERE << "rock db closed " << path << ": FD " << TheFile);
         TheFile = -1;
-        store_open_disk_fd--;
+        --store_open_disk_fd;
     }
 }
 
@@ -80,7 +80,7 @@ MmappedFile::open(int flags, mode_t mode, RefCount<IORequestor> callback)
         debugs(79,3, HERE << "open error: " << xstrerror());
         error_ = true;
     } else {
-        store_open_disk_fd++;
+        ++store_open_disk_fd;
         debugs(79,3, HERE << "FD " << fd);
 
         // setup mapping boundaries
@@ -108,7 +108,7 @@ void MmappedFile::doClose()
     if (fd >= 0) {
         file_close(fd);
         fd = -1;
-        store_open_disk_fd--;
+        --store_open_disk_fd;
     }
 }
 
@@ -121,10 +121,12 @@ HttpHdrCc::parse(const String & str)
     while (strListGetItem(&str, ',', &item, &ilen, &pos)) {
         /* isolate directive name */
 
-        if ((p = (const char *)memchr(item, '=', ilen)) && (p - item < ilen))
-            nlen = p++ - item;
-        else
+        if ((p = (const char *)memchr(item, '=', ilen)) && (p - item < ilen)) {
+            nlen = p - item;
+            ++p;
+        } else {
             nlen = ilen;
+        }
 
         /* find type */
         const CcNameToIdMap_t::const_iterator i=CcNameToIdMap.find(StringArea(item,nlen));
@@ -90,7 +90,7 @@ httpHdrRangeRespSpecParseInit(HttpHdrRangeSpec * spec, const char *field, int fl
         return 0;
     }
 
-    p++;
+    ++p;
 
     /* do we have last-pos ? */
     if (p - field >= flen) {
@@ -182,7 +182,7 @@ httpHdrContRangeParseInit(HttpHdrContRange * range, const char *str)
     else if (!httpHdrRangeRespSpecParseInit(&range->spec, str, p - str))
         return 0;
 
-    p++;
+    ++p;
 
     if (*p == '*')
         range->elength = range_spec_unknown;
@@ -104,7 +104,7 @@ HttpHdrRangeSpec::parseInit(const char *field, int flen)
             if (!httpHeaderParseOffset(field, &offset))
                 return false;
 
-            p++;
+            ++p;
 
             /* do we have last-pos ? */
             if (p - field < flen) {
@@ -136,12 +136,14 @@ HttpHdrSc::parse(const String * str)
         if ((p = strchr(item, '=')) && (p - item < ilen)) {
             vlen = ilen - (p + 1 - item);
             ilen = p - item;
-            p++;
+            ++p;
         }
 
         /* decrease ilen to still match the token for ';' qualified non '=' statments */
-        else if ((p = strchr(item, ';')) && (p - item < ilen))
-            ilen = p++ - item;
+        else if ((p = strchr(item, ';')) && (p - item < ilen)) {
+            ilen = p - item;
+            ++p;
+        }
 
         /* find type */
         /* TODO: use a type-safe map-based lookup */
@@ -175,7 +177,7 @@ HttpHdrSc::parse(const String * str)
             if (type != SC_OTHER)
                 debugs(90, 2, "hdr sc: ignoring duplicate control-directive: near '" << item << "' in '" << str << "'");
 
-            ScFieldsInfo[type].stat.repCount++;
+            ++ ScFieldsInfo[type].stat.repCount;
 
             continue;
         }
@@ -280,7 +282,7 @@ HttpHdrScTarget::packInto(Packer * p) const
             if (flag == SC_CONTENT)
                 packerPrintf(p, "=\"" SQUIDSTRINGPH "\"", SQUIDSTRINGPRINT(content_));
 
-            pcount++;
+            ++pcount;
         }
     }
 
@@ -340,7 +340,7 @@ httpHeaderInitModule(void)
     /* init header stats */
     assert(HttpHeaderStatCount == hoReply + 1);
 
-    for (i = 0; i < HttpHeaderStatCount; i++)
+    for (i = 0; i < HttpHeaderStatCount; ++i)
         httpHeaderStatInit(HttpHeaderStats + i, HttpHeaderStats[i].label);
 
     HttpHeaderStats[hoRequest].owner_mask = &RequestHeadersMask;
@@ -448,7 +448,7 @@ HttpHeader::clean()
         if (0 != entries.count)
             HttpHeaderStats[owner].hdrUCountDistr.count(entries.count);
 
-        HttpHeaderStats[owner].destroyedCount++;
+        ++ HttpHeaderStats[owner].destroyedCount;
 
         HttpHeaderStats[owner].busyDestroyedCount += entries.count > 0;
 
@@ -544,7 +544,7 @@ HttpHeader::parse(const char *header_start, const char *header_end)
 
     assert(header_start && header_end);
     debugs(55, 7, "parsing hdr: (" << this << ")" << std::endl << getStringPrefix(header_start, header_end));
-    HttpHeaderStats[owner].parsedCount++;
+    ++ HttpHeaderStats[owner].parsedCount;
 
     char *nulpos;
     if ((nulpos = (char*)memchr(header_start, '\0', header_end - header_start))) {
@@ -568,10 +568,10 @@ HttpHeader::parse(const char *header_start, const char *header_end)
 
             field_end = field_ptr;
 
-            field_ptr++;	/* Move to next line */
+            ++field_ptr;	/* Move to next line */
 
             if (field_end > this_line && field_end[-1] == '\r') {
-                field_end--;	/* Ignore CR LF */
+                --field_end;	/* Ignore CR LF */
 
                 if (owner == hoRequest && field_end > this_line) {
                     bool cr_only = true;
@@ -596,8 +596,10 @@ HttpHeader::parse(const char *header_start, const char *header_end)
                 if (Config.onoff.relaxed_header_parser) {
                     char *p = (char *) this_line;	/* XXX Warning! This destroys original header content and violates specifications somewhat */
 
-                    while ((p = (char *)memchr(p, '\r', field_end - p)) != NULL)
-                        *p++ = ' ';
+                    while ((p = (char *)memchr(p, '\r', field_end - p)) != NULL) {
+                        *p = ' ';
+                        ++p;
+                    }
                 } else
                     goto reset;
             }
@@ -733,7 +735,7 @@ HttpHeader::getEntry(HttpHeaderPos * pos) const
     assert(pos);
     assert(*pos >= HttpHeaderInitPos && *pos < (ssize_t)entries.count);
 
-    for ((*pos)++; *pos < (ssize_t)entries.count; (*pos)++) {
+    for (++(*pos); *pos < (ssize_t)entries.count; ++(*pos)) {
         if (entries.items[*pos])
             return (HttpHeaderEntry*)entries.items[*pos];
     }
@@ -900,7 +902,7 @@ HttpHeader::addEntry(HttpHeaderEntry * e)
     debugs(55, 7, HERE << this << " adding entry: " << e->id << " at " << entries.count);
 
     if (CBIT_TEST(mask, e->id))
-        Headers[e->id].stat.repCount++;
+        ++ Headers[e->id].stat.repCount;
     else
         CBIT_SET(mask, e->id);
 
@@ -922,7 +924,7 @@ HttpHeader::insertEntry(HttpHeaderEntry * e)
     debugs(55, 7, HERE << this << " adding entry: " << e->id << " at " << entries.count);
 
     if (CBIT_TEST(mask, e->id))
-        Headers[e->id].stat.repCount++;
+        ++ Headers[e->id].stat.repCount;
     else
         CBIT_SET(mask, e->id);
 
@@ -1344,7 +1346,7 @@ HttpHeader::getCc() const
         cc = NULL;
     }
 
-    HttpHeaderStats[owner].ccParsedCount++;
+    ++ HttpHeaderStats[owner].ccParsedCount;
 
     if (cc)
         httpHdrCcUpdateStats(cc, &HttpHeaderStats[owner].ccTypeDistr);
@@ -1387,7 +1389,7 @@ HttpHeader::getSc() const
 
     HttpHdrSc *sc = httpHdrScParseCreate(s);
 
-    ++HttpHeaderStats[owner].ccParsedCount;
+    ++ HttpHeaderStats[owner].ccParsedCount;
 
     if (sc)
         sc->updateStats(&HttpHeaderStats[owner].scTypeDistr);
@@ -1433,7 +1435,7 @@ HttpHeader::getAuth(http_hdr_type id, const char *auth_scheme) const
         return NULL;
 
     /* skip white space */
-    for (; field && xisspace(*field); field++);
+    for (; field && xisspace(*field); ++field);
 
     if (!*field)		/* no authorization cookie */
         return NULL;
@@ -1500,7 +1502,7 @@ HttpHeaderEntry::HttpHeaderEntry(http_hdr_type anId, const char *aName, const ch
 
     value = aValue;
 
-    Headers[id].stat.aliveCount++;
+    ++ Headers[id].stat.aliveCount;
 
     debugs(55, 9, "created HttpHeaderEntry " << this << ": '" << name << " : " << value );
 }
@@ -1518,7 +1520,7 @@ HttpHeaderEntry::~HttpHeaderEntry()
 
     assert(Headers[id].stat.aliveCount);
 
-    Headers[id].stat.aliveCount--;
+    -- Headers[id].stat.aliveCount;
 
     id = HDR_BAD_HDR;
 }
@@ -1533,7 +1535,7 @@ HttpHeaderEntry::parse(const char *field_start, const char *field_end)
     const char *value_start = field_start + name_len + 1;	/* skip ':' */
     /* note: value_end == field_end */
 
-    HeaderEntryParsedCount++;
+    ++ HeaderEntryParsedCount;
 
     /* do we have a valid field name within this field? */
 
@@ -1551,7 +1553,7 @@ HttpHeaderEntry::parse(const char *field_start, const char *field_end)
                "NOTICE: Whitespace after header name in '" << getStringPrefix(field_start, field_end) << "'");
 
         while (name_len > 0 && xisspace(field_start[name_len - 1]))
-            name_len--;
+            --name_len;
 
         if (!name_len)
             return NULL;
@@ -1581,10 +1583,10 @@ HttpHeaderEntry::parse(const char *field_start, const char *field_end)
 
     /* trim field value */
     while (value_start < field_end && xisspace(*value_start))
-        value_start++;
+        ++value_start;
 
     while (value_start < field_end && xisspace(field_end[-1]))
-        field_end--;
+        --field_end;
 
     if (field_end - value_start > 65534) {
         /* String must be LESS THAN 64K and it adds a terminating NULL */
@@ -1599,7 +1601,7 @@ HttpHeaderEntry::parse(const char *field_start, const char *field_end)
     /* set field value */
     value.limitInit(value_start, field_end - value_start);
 
-    Headers[id].stat.seenCount++;
+    ++ Headers[id].stat.seenCount;
 
     debugs(55, 9, "parsed HttpHeaderEntry: '" << name << ": " << value << "'");
 
@@ -1653,10 +1655,10 @@ HttpHeaderEntry::getInt64() const
 static void
 httpHeaderNoteParsedEntry(http_hdr_type id, String const &context, int error)
 {
-    Headers[id].stat.parsCount++;
+    ++ Headers[id].stat.parsCount;
 
     if (error) {
-        Headers[id].stat.errCount++;
+        ++ Headers[id].stat.errCount;
         debugs(55, 2, "cannot parse hdr field: '" << Headers[id].name << ": " << context << "'");
     }
 }
@@ -1738,7 +1740,7 @@ httpHeaderStoreReport(StoreEntry * e)
     HttpHeaderStats[0].busyDestroyedCount =
         HttpHeaderStats[hoRequest].busyDestroyedCount + HttpHeaderStats[hoReply].busyDestroyedCount;
 
-    for (i = 1; i < HttpHeaderStatCount; i++) {
+    for (i = 1; i < HttpHeaderStatCount; ++i) {
         httpHeaderStatDump(HttpHeaderStats + i, e);
         storeAppendPrintf(e, "%s\n", "<br>");
     }
@@ -290,7 +290,7 @@ strListGetItem(const String * str, char del, const char **item, int *ilen, const
 
     /* rtrim */
     while (len > 0 && xisspace((*item)[len - 1]))
-        len--;
+        --len;
 
     if (ilen)
         *ilen = len;
@@ -359,7 +359,7 @@ httpHeaderParseQuotedString(const char *start, const int len, String *val)
     while (*pos != '"' && len > (pos-start)) {
 
         if (*pos =='\r') {
-            pos++;
+            ++pos;
             if ((pos-start) > len || *pos != '\n') {
                 debugs(66, 2, HERE << "failed to parse a quoted-string header field with '\\r' octet " << (start-pos)
                        << " bytes into '" << start << "'");
@@ -369,22 +369,22 @@ httpHeaderParseQuotedString(const char *start, const int len, String *val)
         }
 
         if (*pos == '\n') {
-            pos++;
+            ++pos;
             if ( (pos-start) > len || (*pos != ' ' && *pos != '\t')) {
                 debugs(66, 2, HERE << "failed to parse multiline quoted-string header field '" << start << "'");
                 val->clean();
                 return 0;
             }
             // TODO: replace the entire LWS with a space
             val->append(" ");
-            pos++;
+            ++pos;
             debugs(66, 2, HERE << "len < pos-start => " << len << " < " << (pos-start));
             continue;
         }
 
         bool quoted = (*pos == '\\');
         if (quoted) {
-            pos++;
+            ++pos;
             if (!*pos || (pos-start) > len) {
                 debugs(66, 2, HERE << "failed to parse a quoted-string header field near '" << start << "'");
                 val->clean();
@@ -393,7 +393,7 @@ httpHeaderParseQuotedString(const char *start, const int len, String *val)
         }
         end = pos;
         while (end < (start+len) && *end != '\\' && *end != '\"' && (unsigned char)*end > 0x1F && *end != 0x7F)
-            end++;
+            ++end;
         if (((unsigned char)*end <= 0x1F && *end != '\r' && *end != '\n') || *end == 0x7F) {
             debugs(66, 2, HERE << "failed to parse a quoted-string header field with CTL octet " << (start-pos)
                    << " bytes into '" << start << "'");
@@ -521,7 +521,7 @@ HeaderManglers::HeaderManglers()
 
 HeaderManglers::~HeaderManglers()
 {
-    for (int i = 0; i < HDR_ENUM_END; i++)
+    for (int i = 0; i < HDR_ENUM_END; ++i)
         header_mangler_clean(known[i]);
 
     typedef ManglersByName::iterator MBNI;
@@ -534,7 +534,7 @@ HeaderManglers::~HeaderManglers()
 void
 HeaderManglers::dumpAccess(StoreEntry * entry, const char *name) const
 {
-    for (int i = 0; i < HDR_ENUM_END; i++) {
+    for (int i = 0; i < HDR_ENUM_END; ++i) {
         header_mangler_dump_access(entry, name, known[i],
                                    httpHeaderNameById(i));
     }
@@ -549,7 +549,7 @@ HeaderManglers::dumpAccess(StoreEntry * entry, const char *name) const
 void
 HeaderManglers::dumpReplacement(StoreEntry * entry, const char *name) const
 {
-    for (int i = 0; i < HDR_ENUM_END; i++) {
+    for (int i = 0; i < HDR_ENUM_END; ++i) {
         header_mangler_dump_replacement(entry, name, known[i],
                                         httpHeaderNameById(i));
     }
@@ -76,7 +76,7 @@ httpMsgIsolateHeaders(const char **parse_start, int l, const char **blk_start, c
         assert(**blk_end == '\n');
 
         while (*(*blk_end - 1) == '\r')
-            (*blk_end)--;
+            --(*blk_end);
 
         assert(*(*blk_end - 1) == '\n');
 
@@ -102,11 +102,11 @@ httpMsgIsolateHeaders(const char **parse_start, int l, const char **blk_start, c
 
     *blk_end = *blk_start;
 
-    for (nnl = 0; nnl == 0; (*parse_start)++) {
+    for (nnl = 0; nnl == 0; ++(*parse_start)) {
         if (**parse_start == '\r')
             (void) 0;
         else if (**parse_start == '\n')
-            nnl++;
+            ++nnl;
         else
             break;
     }
@@ -128,10 +128,10 @@ httpMsgIsolateStart(const char **parse_start, const char **blk_start, const char
     *blk_end = *blk_start + slen;
 
     while (**blk_end == '\r')   /* CR */
-        (*blk_end)++;
+        ++(*blk_end);
 
     if (**blk_end == '\n')      /* LF */
-        (*blk_end)++;
+        ++(*blk_end);
 
     *parse_start = *blk_end;
 
@@ -360,7 +360,7 @@ void HttpMsg::firstLineBuf(MemBuf& mb)
 HttpMsg *
 HttpMsg::_lock()
 {
-    lock_count++;
+    ++lock_count;
     return this;
 }
 
@@ -46,10 +46,10 @@ HttpParser::parseRequestFirstLine()
                    "Whitespace bytes received ahead of method. " <<
                    "Ignored due to relaxed_header_parser.");
         // Be tolerant of prefix spaces (other bytes are valid method values)
-        for (; req.start < bufsiz && buf[req.start] == ' '; req.start++);
+        for (; req.start < bufsiz && buf[req.start] == ' '; ++req.start);
     }
     req.end = -1;
-    for (int i = 0; i < bufsiz; i++) {
+    for (int i = 0; i < bufsiz; ++i) {
         // track first and last whitespace (SP only)
         if (buf[i] == ' ') {
             last_whitespace = i;
@@ -79,7 +79,7 @@ HttpParser::parseRequestFirstLine()
                 if (buf[i + 1] == '\n' || buf[i + 1] == '\r')
                     line_end = i - 1;
                 while (i < bufsiz - 1 && buf[i + 1] == '\r')
-                    i++;
+                    ++i;
 
                 if (buf[i + 1] == '\n') {
                     req.end = i + 1;
@@ -151,7 +151,7 @@ HttpParser::parseRequestFirstLine()
         // otherwise last whitespace is somewhere after end of URI.
         req.u_end = last_whitespace;
         // crop any trailing whitespace in the area we think of as URI
-        for (; req.u_end >= req.u_start && xisspace(buf[req.u_end]); req.u_end--);
+        for (; req.u_end >= req.u_start && xisspace(buf[req.u_end]); --req.u_end);
     }
     if (req.u_end < req.u_start) {
         request_parse_status = HTTP_BAD_REQUEST; // missing URI
@@ -191,7 +191,7 @@ HttpParser::parseRequestFirstLine()
         return -1;
     }
     int maj = 0;
-    for (; i <= line_end && (isdigit(buf[i])) && maj < 65536; i++) {
+    for (; i <= line_end && (isdigit(buf[i])) && maj < 65536; ++i) {
         maj = maj * 10;
         maj = maj + (buf[i]) - '0';
     }
@@ -218,7 +218,7 @@ HttpParser::parseRequestFirstLine()
         return -1;
     }
     int min = 0;
-    for (; i <= line_end && (isdigit(buf[i])) && min < 65536; i++) {
+    for (; i <= line_end && (isdigit(buf[i])) && min < 65536; ++i) {
         min = min * 10;
         min = min + (buf[i]) - '0';
     }
@@ -314,9 +314,9 @@ HttpRequest::parseFirstLine(const char *start, const char *end)
         end = ver - 1;
 
         while (xisspace(*end)) // find prev non-space
-            end--;
+            --end;
 
-        end++;                 // back to space
+        ++end;                 // back to space
 
         if (2 != sscanf(ver + 5, "%d.%d", &http_ver.major, &http_ver.minor)) {
             debugs(73, 1, "parseRequestLine: Invalid HTTP identifier.");
@@ -160,7 +160,7 @@ HttpRequestMethod::Configure(SquidConfig &cfg)
     while (w) {
         char *s;
 
-        for (s = w->key; *s; s++)
+        for (s = w->key; *s; ++s)
             *s = xtoupper(*s);
 
         AddExtension(w->key);
@@ -73,7 +73,7 @@ LeakFinder::addSome(void *p, const char *file, int line)
     assert(hash_lookup(table, p) == NULL);
     LeakFinderPtr *c = new LeakFinderPtr(p, file, line);
     hash_join(table, c);
-    count++;
+    ++count;
     return p;
 }
 
@@ -96,7 +96,7 @@ LeakFinder::freeSome(void *p, const char *file, int line)
     LeakFinderPtr *c = (LeakFinderPtr *) hash_lookup(table, p);
     assert(c);
     hash_remove_link(table, c);
-    count--;
+    --count;
     delete c;
     dump();
     return p;
@@ -340,7 +340,7 @@ MemBuf::vPrintf(const char *fmt, va_list vargs)
     if (!size || buf[size - 1]) {
         assert(!buf[size]);
     } else {
-        size--;
+        --size;
     }
 }
 
@@ -211,7 +211,8 @@ struct StoreClientStats : public unary_function<store_client, void> {
     StoreClientStats(MemBuf *anEntry):where(anEntry),index(0) {}
 
     void operator()(store_client const &x) {
-        x.dumpStats(where, index++);
+        x.dumpStats(where, index);
+        ++index;
     }
 
     MemBuf *where;
@@ -179,7 +179,8 @@ GetHostWithPort(char *token, Ip::Address *ipa)
         t = strchr(host, ']');
         if (!t)
             return false;
-        *t++ = '\0';
+        *t = '\0';
+        ++t;
         if (*t != ':')
             return false;
         port = xatos(t + 1);
@@ -100,7 +100,7 @@ xprof_comp(xprof_stats_node ** ii, xprof_stats_node ** jj)
 static void
 xprof_sorthist(TimersArray * xprof_list)
 {
-    for (int i = 0; i < XPROF_LAST; i++) {
+    for (int i = 0; i < XPROF_LAST; ++i) {
         sortlist[i] = xprof_list[i];
     }
 
@@ -151,7 +151,7 @@ xprof_summary_item(StoreEntry * sentry, char const *descr, TimersArray * list)
     storeAppendPrintf(sentry,
                       "Probe Name\t  Events\t cumulated time \t best case \t average \t worst case\t Rate / sec \t %% in int\n");
 
-    for (i = 0; i < XPROF_LAST; i++) {
+    for (i = 0; i < XPROF_LAST; ++i) {
         if (!hist[i]->name)
             continue;
 
@@ -193,7 +193,7 @@ xprof_average(TimersArray ** list, int secs)
 
     now = get_tick();
 
-    for (i = 0; i < XPROF_LAST; i++) {
+    for (i = 0; i < XPROF_LAST; ++i) {
         hist[i]->name = head[i]->name;
         hist[i]->accu.summ += head[i]->accu.summ;
         hist[i]->accu.count += head[i]->accu.count;	/* accumulate multisec */
@@ -295,7 +295,7 @@ xprof_event(void *data)
     xprof_Init();
     xprof_delta = now - xprof_start_t;
     xprof_start_t = now;
-    xprof_events++;
+    ++xprof_events;
 
     if (!xprof_average_delta)
         xprof_average_delta = xprof_delta;
@@ -92,7 +92,8 @@ StoreMetaUnpacker::StoreMetaUnpacker (char const *aBuffer, ssize_t aLen, int *an
 void
 StoreMetaUnpacker::getType()
 {
-    type = buf[position++];
+    type = buf[position];
+    ++position;
 }
 
 void
@@ -363,7 +363,7 @@ strwordtok(char *buf, char **t)
         goto error;
 
     while (*p && xisspace(*p))
-        p++;
+        ++p;
 
     if (!*p)
         goto error;
@@ -374,7 +374,7 @@ strwordtok(char *buf, char **t)
         switch (ch) {
 
         case '\\':
-            p++;
+            ++p;
 
             switch (*p) {
 
@@ -395,33 +395,36 @@ strwordtok(char *buf, char **t)
 
             }
 
-            *d++ = ch;
+            *d = ch;
+            ++d;
 
             if (ch)
-                p++;
+                ++p;
 
             break;
 
         case '"':
             quoted = !quoted;
 
-            p++;
+            ++p;
 
             break;
 
         default:
             if (!quoted && xisspace(*p)) {
-                p++;
+                ++p;
                 goto done;
             }
 
-            *d++ = *p++;
+            *d = *p;
+            ++d;
+            ++p;
             break;
         }
     }
 
 done:
-    *d++ = '\0';
+    *d = '\0';
 
 error:
     *t = (char *) p;
@@ -244,8 +244,10 @@ SwapDir::parseOptions(int isaReconfig)
     while ((name = strtok(NULL, w_space)) != NULL) {
         value = strchr(name, '=');
 
-        if (value)
-            *value++ = '\0';	/* cut on = */
+        if (value) {
+            *value = '\0';	/* cut on = */
+            ++value;
+        }
 
         debugs(3,2, "SwapDir::parseOptions: parsing store option '" << name << "'='" << (value ? value : "") << "'");
 
@@ -160,7 +160,7 @@ WIN32_create_key(void)
         }
 
         hKey = hKeyNext;
-        index++;
+        ++index;
     }
 
     if (keys[index] == NULL) {
@@ -268,15 +268,15 @@ static void WIN32_build_argv(char *cmd)
         /* Ignore spaces */
 
         if (xisspace(*cmd)) {
-            cmd++;
+            ++cmd;
             continue;
         }
 
         /* Found the beginning of an argument. */
         word = cmd;
 
         while (*cmd) {
-            cmd++;		/* Skip over this character */
+            ++cmd;		/* Skip over this character */
 
             if (xisspace(*cmd))	/* End of argument if space */
                 break;
@@ -602,7 +602,7 @@ void
 WIN32_svcstatusupdate(DWORD svcstate, DWORD WaitHint)
 {
     if (WIN32_run_mode == _WIN_SQUID_RUN_MODE_SERVICE) {
-        svcStatus.dwCheckPoint++;
+        ++svcStatus.dwCheckPoint;
         svcStatus.dwWaitHint = WaitHint;
         svcStatus.dwCurrentState = svcstate;
         SetServiceStatus(svcHandle, &svcStatus);
@@ -987,7 +987,7 @@ static int Win32SockInit(void)
     int optlen = sizeof(opt);
 
     if (s_iInitCount > 0) {
-        s_iInitCount++;
+        ++s_iInitCount;
         return (0);
     } else if (s_iInitCount < 0)
         return (s_iInitCount);
@@ -1026,7 +1026,7 @@ static int Win32SockInit(void)
     }
 
     WIN32_Socks_initialized = 1;
-    s_iInitCount++;
+    ++s_iInitCount;
     return (s_iInitCount);
 }
 
@@ -53,8 +53,10 @@ ACLIntRange::parse()
         char *b = strchr(a, '-');
         unsigned short port1, port2;
 
-        if (b)
-            *b++ = '\0';
+        if (b) {
+            *b = '\0';
+            ++b;
+        }
 
         port1 = xatos(a);
 
@@ -235,12 +235,18 @@ compileOptimisedREs(relist **curlist, wordlist * wl)
             }
         } else if (RElen + largeREindex + 3 < BUFSIZ-1) {
             debugs(28, 2, "compileOptimisedREs: adding RE '" << wl->key << "'");
-            if (largeREindex > 0)
-                largeRE[largeREindex++] = '|';
-            largeRE[largeREindex++] = '(';
-            for (char * t = wl->key; *t != '\0'; ++t)
-                largeRE[largeREindex++] = *t;
-            largeRE[largeREindex++] = ')';
+            if (largeREindex > 0) {
+                largeRE[largeREindex] = '|';
+                ++largeREindex;
+            }
+            largeRE[largeREindex] = '(';
+            ++largeREindex;
+            for (char * t = wl->key; *t != '\0'; ++t) {
+                largeRE[largeREindex] = *t;
+                ++largeREindex;
+            }
+            largeRE[largeREindex] = ')';
+            ++largeREindex;
             largeRE[largeREindex] = '\0';
             ++numREs;
         } else {
@@ -209,7 +209,7 @@ int Adaptation::Icap::ServiceRep::excessConnections() const
 
 void Adaptation::Icap::ServiceRep::noteGoneWaiter()
 {
-    theAllWaiters--;
+    --theAllWaiters;
 
     // in case the notified transaction did not take the connection slot
     busyCheckpoint();
@@ -111,7 +111,7 @@ Auth::User::absorb(Auth::User::Pointer from)
             dlinkDelete(&new_ipdata->node, &(from->ip_list));
             cbdataFree(new_ipdata);
             /* catch incipient underflow */
-            from->ipcount--;
+            -- from->ipcount;
         } else {
             /* add to our list. replace if already present. */
             AuthUserIP *ipdata = static_cast<AuthUserIP *>(ip_list.head->data);
@@ -131,7 +131,7 @@ Auth::User::absorb(Auth::User::Pointer from)
                     cbdataFree(ipdata);
                     /* catch incipient underflow */
                     assert(ipcount);
-                    ipcount--;
+                    -- ipcount;
                 }
 
                 ipdata = tempnode;
@@ -257,7 +257,7 @@ Auth::User::clearIp()
         cbdataFree(ipdata);
         /* catch incipient underflow */
         assert(ipcount);
-        ipcount--;
+        -- ipcount;
         ipdata = tempnode;
     }
 
@@ -279,7 +279,7 @@ Auth::User::removeIp(Ip::Address ipaddr)
             cbdataFree(ipdata);
             /* catch incipient underflow */
             assert(ipcount);
-            ipcount--;
+            -- ipcount;
             return;
         }
 
@@ -316,7 +316,7 @@ Auth::User::addIp(Ip::Address ipaddr)
             cbdataFree(ipdata);
             /* catch incipient underflow */
             assert(ipcount);
-            ipcount--;
+            -- ipcount;
         }
 
         ipdata = tempnode;
@@ -143,8 +143,10 @@ Auth::Basic::UserRequest::HandleReply(void *data, char *reply)
     debugs(29, 5, HERE << "{" << (reply ? reply : "<NULL>") << "}");
 
     if (reply) {
-        if ((t = strchr(reply, ' ')))
-            *t++ = '\0';
+        if ((t = strchr(reply, ' '))) {
+            *t = '\0';
+            ++t;
+        }
 
         if (*reply == '\0')
             reply = NULL;
@@ -279,8 +279,10 @@ Auth::Digest::UserRequest::HandleReply(void *data, char *reply)
     debugs(29, 9, HERE << "{" << (reply ? reply : "<NULL>") << "}");
 
     if (reply) {
-        if ((t = strchr(reply, ' ')))
-            *t++ = '\0';
+        if ((t = strchr(reply, ' '))) {
+            *t = '\0';
+            ++t;
+        }
 
         if (*reply == '\0' || *reply == '\n')
             reply = NULL;
@@ -320,7 +320,7 @@ authDigestNonceUnlink(digest_nonce_h * nonce)
     assert(nonce != NULL);
 
     if (nonce->references > 0) {
-        nonce->references--;
+        -- nonce->references;
     } else {
         debugs(29, 1, "authDigestNonceUnlink; Attempt to lower nonce " << nonce << " refcount below 0!");
     }
@@ -809,7 +809,8 @@ Auth::Digest::Config::decode(char const *proxy_auth)
         size_t nlen;
         size_t vlen;
         if ((p = (const char *)memchr(item, '=', ilen)) && (p - item < ilen)) {
-            nlen = p++ - item;
+            nlen = p - item;
+            ++p;
             vlen = ilen - (p - item);
         } else {
             nlen = ilen;
@@ -270,16 +270,18 @@ Auth::Negotiate::UserRequest::HandleReply(void *data, void *lastserver, char *re
     blob = strchr(reply, ' ');
 
     if (blob) {
-        blob++;
+        ++blob;
         arg = strchr(blob + 1, ' ');
     } else {
         arg = NULL;
     }
 
     if (strncasecmp(reply, "TT ", 3) == 0) {
         /* we have been given a blob to send to the client */
-        if (arg)
-            *arg++ = '\0';
+        if (arg) {
+            *arg = '\0';
+            ++arg;
+        }
         safe_free(lm_request->server_blob);
         lm_request->request->flags.must_keepalive = 1;
         if (lm_request->request->flags.proxy_keepalive) {
@@ -294,8 +296,10 @@ Auth::Negotiate::UserRequest::HandleReply(void *data, void *lastserver, char *re
     } else if (strncasecmp(reply, "AF ", 3) == 0 && arg != NULL) {
         /* we're finished, release the helper */
 
-        if (arg)
-            *arg++ = '\0';
+        if (arg) {
+            *arg = '\0';
+            ++arg;
+        }
 
         auth_user_request->user()->username(arg);
         auth_user_request->denyMessage("Login successful");
@@ -334,8 +338,10 @@ Auth::Negotiate::UserRequest::HandleReply(void *data, void *lastserver, char *re
     } else if (strncasecmp(reply, "NA ", 3) == 0 && arg != NULL) {
         /* authentication failure (wrong password, etc.) */
 
-        if (arg)
-            *arg++ = '\0';
+        if (arg) {
+            *arg = '\0';
+            ++arg;
+        }
 
         auth_user_request->denyMessage(arg);
         auth_user_request->user()->credentials(Auth::Failed);
@@ -57,7 +57,8 @@ unsigned int TextException::FileNameHash(const char *fname)
 
     while (*s) {
         ++j;
-        n ^= 271 * (unsigned) *s++;
+        n ^= 271 * (unsigned) *s;
+        ++s;
     }
     i = n ^ (j * 271);
     /*18bits of a 32 bit integer used  for filename hash (max hash=262143),
@@ -247,7 +247,7 @@ update_maxobjsize(void)
     int i;
     int64_t ms = -1;
 
-    for (i = 0; i < Config.cacheSwap.n_configured; i++) {
+    for (i = 0; i < Config.cacheSwap.n_configured; ++i) {
         assert (Config.cacheSwap.swapDirs[i].getRaw());
 
         if (dynamic_cast<SwapDir *>(Config.cacheSwap.swapDirs[i].getRaw())->
@@ -295,7 +295,7 @@ parseManyConfigFiles(char* files, int depth)
                    path, xstrerror());
         }
     }
-    for (i = 0; i < (int)globbuf.gl_pathc; i++) {
+    for (i = 0; i < (int)globbuf.gl_pathc; ++i) {
         error_count += parseOneConfigFile(globbuf.gl_pathv[i], depth);
     }
     globfree(&globbuf);
@@ -453,7 +453,7 @@ parseOneConfigFile(const char *file_name, unsigned int depth)
 
     Vector<bool> if_states;
     while (fgets(config_input_line, BUFSIZ, fp)) {
-        config_lineno++;
+        ++config_lineno;
 
         if ((token = strchr(config_input_line, '\n')))
             *token = '\0';
@@ -477,7 +477,7 @@ parseOneConfigFile(const char *file_name, unsigned int depth)
                 continue;	/* Not a valid #line directive, may be a comment */
 
             while (*file && xisspace((unsigned char) *file))
-                file++;
+                ++file;
 
             if (*file) {
                 if (*file != '"')
@@ -538,7 +538,7 @@ parseOneConfigFile(const char *file_name, unsigned int depth)
                 err_count += parseManyConfigFiles(tmp_line + 8, depth + 1);
             } else if (!parse_line(tmp_line)) {
                 debugs(3, 0, HERE << cfg_filename << ":" << config_lineno << " unrecognized: '" << tmp_line << "'");
-                err_count++;
+                ++err_count;
             }
         }
 
@@ -1188,7 +1188,7 @@ static void parseBytesOptionValue(size_t * bptr, const char *units, char const *
     char const * number_end = value;
 
     while ((*number_end >= '0' && *number_end <= '9')) {
-        number_end++;
+        ++number_end;
     }
 
     String number;
@@ -1757,7 +1757,7 @@ dump_cachedir(StoreEntry * entry, const char *name, SquidConfig::_cacheSwap swap
     int i;
     assert (entry);
 
-    for (i = 0; i < swap.n_configured; i++) {
+    for (i = 0; i < swap.n_configured; ++i) {
         s = dynamic_cast<SwapDir *>(swap.swapDirs[i].getRaw());
         if (!s) continue;
         storeAppendPrintf(entry, "%s %s %s", name, s->type(), s->path);
@@ -1866,7 +1866,7 @@ parse_cachedir(SquidConfig::_cacheSwap * swap)
 
     /* reconfigure existing dir */
 
-    for (i = 0; i < swap->n_configured; i++) {
+    for (i = 0; i < swap->n_configured; ++i) {
         assert (swap->swapDirs[i].getRaw());
 
         if ((strcasecmp(path_str, dynamic_cast<SwapDir *>(swap->swapDirs[i].getRaw())->path)) == 0) {
@@ -1993,7 +1993,7 @@ isUnsignedNumeric(const char *str, size_t len)
 {
     if (len < 1) return false;
 
-    for (; len >0 && *str; str++, len--) {
+    for (; len >0 && *str; ++str, --len) {
         if (! isdigit(*str))
             return false;
     }
@@ -2129,8 +2129,10 @@ parse_peer(peer ** head)
             char *mode, *nextmode;
             for (mode = nextmode = tmp; mode; mode = nextmode) {
                 nextmode = strchr(mode, ',');
-                if (nextmode)
-                    *nextmode++ = '\0';
+                if (nextmode) {
+                    *nextmode = '\0';
+                    ++nextmode;
+                }
                 if (!strcasecmp(mode, "no-clr")) {
                     if (p->options.htcp_only_clr)
                         fatalf("parse_peer: can't set htcp-no-clr and htcp-only-clr simultaneously");
@@ -2497,7 +2499,7 @@ parse_hostdomain(void)
 
         if (*domain == '!') {	/* check for !.edu */
             l->do_ping = 0;
-            domain++;
+            ++domain;
         }
 
         l->domain = xstrdup(domain);
@@ -2939,7 +2941,7 @@ parse_eol(char *volatile *var)
     }
 
     while (*token && xisspace(*token))
-        token++;
+        ++token;
 
     if (!*token) {
         self_destruct();
@@ -3451,7 +3453,8 @@ parsePortSpecification(AnyP::PortCfg * s, char *token)
             debugs(3, DBG_CRITICAL, s->protocol << "_port: missing ']' on IPv6 address: " << token);
             self_destruct();
         }
-        *t++ = '\0';
+        *t = '\0';
+        ++t;
         if (*t != ':') {
             debugs(3, DBG_CRITICAL, s->protocol << "_port: missing Port in: " << token);
             self_destruct();
@@ -3637,12 +3640,12 @@ parse_port_option(AnyP::PortCfg * s, char *token)
         s->tcp_keepalive.idle = atoi(t);
         t = strchr(t, ',');
         if (t) {
-            t++;
+            ++t;
             s->tcp_keepalive.interval = atoi(t);
             t = strchr(t, ',');
         }
         if (t) {
-            t++;
+            ++t;
             s->tcp_keepalive.timeout = atoi(t);
             t = strchr(t, ',');
         }
@@ -4353,7 +4356,7 @@ static void parse_sslproxy_cert_adapt(sslproxy_cert_adapt **cert_adapt)
     const char *param;
     if ( char *s = strchr(al, '{')) {
         *s = '\0'; // terminate the al string
-        s++;
+        ++s;
         param = s;
         s = strchr(s, '}');
         if (!s) {
@@ -177,31 +177,31 @@ cacheIndexScan(CacheIndex * idx, const char *fname, FILE * file)
     fprintf(stderr, "%s scanning\n", fname);
 
     while (fread(&s, sizeof(s), 1, file) == 1) {
-        count++;
-        idx->scanned_count++;
+        ++count;
+        ++ idx->scanned_count;
         /* if (!s.sane())
          * continue; */
 
         if (s.op == SWAP_LOG_ADD) {
             CacheEntry *olde = (CacheEntry *) hash_lookup(idx->hash, s.key);
 
             if (olde) {
-                idx->bad_add_count++;
+                ++ idx->bad_add_count;
             } else {
                 CacheEntry *e = cacheEntryCreate(&s);
                 hash_join(idx->hash, &e->hash);
-                idx->count++;
+                ++ idx->count;
             }
         } else if (s.op == SWAP_LOG_DEL) {
             CacheEntry *olde = (CacheEntry *) hash_lookup(idx->hash, s.key);
 
             if (!olde)
-                idx->bad_del_count++;
+                ++ idx->bad_del_count;
             else {
                 assert(idx->count);
                 hash_remove_link(idx->hash, (hash_link *) olde);
                 cacheEntryDestroy(olde);
-                idx->count--;
+                -- idx->count;
             }
         } else {
             fprintf(stderr, "%s:%d: unknown swap log action\n", fname, count);
@@ -249,10 +249,10 @@ cacheIndexCmp(CacheIndex * idx1, CacheIndex * idx2)
     hash_first(small_idx->hash);
 
     for (hashr = hash_next(small_idx->hash)) {
-        hashed_count++;
+        ++hashed_count;
 
         if (hash_lookup(large_idx->hash, hashr->key))
-            shared_count++;
+            ++shared_count;
     }
 
     assert(hashed_count == small_idx->count);
@@ -288,7 +288,7 @@ main(int argc, char *argv[])
             return usage(argv[0]);
 
         if (argv[i][len - 1] == ':') {
-            idxCount++;
+            ++idxCount;
 
             if (len < 2 || idxCount > 2)
                 return usage(argv[0]);
@@ -72,7 +72,7 @@ carpInit(void)
     char *t;
     /* Clean up */
 
-    for (k = 0; k < n_carp_peers; k++) {
+    for (k = 0; k < n_carp_peers; ++k) {
         cbdataReferenceDone(carp_peers[k]);
     }
 
@@ -93,7 +93,7 @@ carpInit(void)
         if (p->weight == 0)
             continue;
 
-        n_carp_peers++;
+        ++n_carp_peers;
 
         W += p->weight;
     }
@@ -114,7 +114,7 @@ carpInit(void)
         /* calculate this peers hash */
         p->carp.hash = 0;
 
-        for (t = p->name; *t != 0; t++)
+        for (t = p->name; *t != 0; ++t)
             p->carp.hash += ROTATE_LEFT(p->carp.hash, 19) + (unsigned int) *t;
 
         p->carp.hash += p->carp.hash * 0x62531965;
@@ -128,7 +128,8 @@ carpInit(void)
             p->carp.load_factor = 0.0;
 
         /* add it to our list of peers */
-        *P++ = cbdataReference(p);
+        *P = cbdataReference(p);
+        ++P;
     }
 
     /* Sort our list on weight */
@@ -150,7 +151,7 @@ carpInit(void)
 
     X_last = 0.0;		/* Empty X_0, nullifies the first pow statement */
 
-    for (k = 1; k <= K; k++) {
+    for (k = 1; k <= K; ++k) {
         double Kk1 = (double) (K - k + 1);
         p = carp_peers[k - 1];
         p->carp.load_multiplier = (Kk1 * (p->carp.load_factor - P_last)) / Xn;
@@ -180,7 +181,7 @@ carpSelectParent(HttpRequest * request)
     debugs(39, 2, "carpSelectParent: Calculating hash for " << urlCanonical(request));
 
     /* select peer */
-    for (k = 0; k < n_carp_peers; k++) {
+    for (k = 0; k < n_carp_peers; ++k) {
         String key;
         tp = carp_peers[k];
         if (tp->options.carp_key.set) {
@@ -221,7 +222,7 @@ carpSelectParent(HttpRequest * request)
         if (key.size()==0)
             key=urlCanonical(request);
 
-        for (const char *c = key.rawBuf(), *e=key.rawBuf()+key.size(); c < e; c++)
+        for (const char *c = key.rawBuf(), *e=key.rawBuf()+key.size(); c < e; ++c)
             user_hash += ROTATE_LEFT(user_hash, 19) + *c;
         combined_hash = (user_hash ^ tp->carp.hash);
         combined_hash += combined_hash * 0x62531965;
@@ -310,7 +310,7 @@ cbdataInternalAlloc(cbdata_type type)
     c->valid = 1;
     c->locks = 0;
     c->cookie = (long) c ^ cbdata::Cookie;
-    cbdataCount++;
+    ++cbdataCount;
 #if USE_CBDATA_DEBUG
 
     c->file = file;
@@ -360,7 +360,7 @@ cbdataInternalFree(void *p)
         return NULL;
     }
 
-    cbdataCount--;
+    --cbdataCount;
     debugs(45, 9, "cbdataFree: Freeing " << p);
 #if USE_CBDATA_DEBUG
 
@@ -423,7 +423,7 @@ cbdataInternalLock(const void *p)
 
     assert(c->locks < INT_MAX);
 
-    c->locks++;
+    ++ c->locks;
 }
 
 void
@@ -462,12 +462,12 @@ cbdataInternalUnlock(const void *p)
 
     assert(c->locks > 0);
 
-    c->locks--;
+    -- c->locks;
 
     if (c->valid || c->locks)
         return;
 
-    cbdataCount--;
+    --cbdataCount;
 
     debugs(45, 9, "cbdataUnlock: Freeing " << p);
 
@@ -585,7 +585,7 @@ cbdataDump(StoreEntry * sentry)
     storeAppendPrintf(sentry, "\n");
     storeAppendPrintf(sentry, "types\tsize\tallocated\ttotal\n");
 
-    for (int i = 1; i < cbdata_types; i++) {
+    for (int i = 1; i < cbdata_types; ++i) {
         MemAllocator *pool = cbdata_index[i].pool;
 
         if (pool) {
@@ -254,7 +254,7 @@ main(int argc, char *argv[])
     while (fp.getline(buff,MAX_LINE), fp.good() && state != sEXIT) {
         char *t;
 
-        linenum++;
+        ++linenum;
 
         if ((t = strchr(buff, '\n')))
             *t = '\0';
@@ -318,35 +318,35 @@ main(int argc, char *argv[])
                     ptr = buff + 8;
 
                     while (isspace((unsigned char)*ptr))
-                        ptr++;
+                        ++ptr;
 
                     curr.comment = ptr;
                 } else if (!strncmp(buff, "DEFAULT:", 8)) {
                     ptr = buff + 8;
 
                     while (isspace((unsigned char)*ptr))
-                        ptr++;
+                        ++ptr;
 
                     curr.defaults.preset.push_back(ptr);
                 } else if (!strncmp(buff, "DEFAULT_IF_NONE:", 16)) {
                     ptr = buff + 16;
 
                     while (isspace((unsigned char)*ptr))
-                        ptr++;
+                        ++ptr;
 
                     curr.defaults.if_none.push_back(ptr);
                 } else if (!strncmp(buff, "POSTSCRIPTUM:", 13)) {
                     ptr = buff + 13;
 
                     while (isspace((unsigned char)*ptr))
-                        ptr++;
+                        ++ptr;
 
                     curr.defaults.postscriptum.push_back(ptr);
                 } else if (!strncmp(buff, "DEFAULT_DOC:", 12)) {
                     ptr = buff + 12;
 
                     while (isspace((unsigned char)*ptr))
-                        ptr++;
+                        ++ptr;
 
                     curr.defaults.docs.push_back(ptr);
                 } else if (!strncmp(buff, "LOC:", 4)) {
@@ -737,7 +737,7 @@ isDefined(const std::string &name)
     if (!name.size())
         return true;
 
-    for (int i = 0; defines[i].name; i++) {
+    for (int i = 0; defines[i].name; ++i) {
         if (name.compare(defines[i].name) == 0)
             return defines[i].defined;
     }
@@ -750,7 +750,7 @@ available_if(const std::string &name)
 {
     assert(name.size());
 
-    for (int i = 0; defines[i].name; i++) {
+    for (int i = 0; defines[i].name; ++i) {
         if (name.compare(defines[i].name) == 0)
             return defines[i].enable;
     }
@@ -96,7 +96,7 @@ clientdbAdd(const Ip::Address &addr)
     ++statCounter.client_http.clients;
 
     if ((statCounter.client_http.clients > max_clients) && !cleanup_running && cleanup_scheduled < 2) {
-        cleanup_scheduled++;
+        ++cleanup_scheduled;
         eventAdd("client_db garbage collector", clientdbScheduledGC, NULL, 90, 0);
     }
 
@@ -163,15 +163,15 @@ clientdbUpdate(const Ip::Address &addr, log_type ltype, AnyP::ProtocolType p, si
         debug_trap("clientdbUpdate: Failed to add entry");
 
     if (p == AnyP::PROTO_HTTP) {
-        c->Http.n_requests++;
-        c->Http.result_hist[ltype]++;
+        ++ c->Http.n_requests;
+        ++ c->Http.result_hist[ltype];
         kb_incr(&c->Http.kbytes_out, size);
 
         if (logTypeIsATcpHit(ltype))
             kb_incr(&c->Http.hit_kbytes_out, size);
     } else if (p == AnyP::PROTO_ICP) {
-        c->Icp.n_requests++;
-        c->Icp.result_hist[ltype]++;
+        ++ c->Icp.n_requests;
+        ++ c->Icp.result_hist[ltype];
         kb_incr(&c->Icp.kbytes_out, size);
 
         if (LOG_UDP_HIT == ltype)
@@ -407,7 +407,7 @@ clientdbGC(void *unused)
 
         --statCounter.client_http.clients;
 
-        cleanup_removed++;
+        ++cleanup_removed;
     }
 
     if (bucket < CLIENT_DB_HASH_SIZE)
@@ -502,7 +502,7 @@ clientUpdateHierCounters(HierarchyLogEntry * someEntry)
     case CD_PARENT_HIT:
 
     case CD_SIBLING_HIT:
-        statCounter.cd.times_used++;
+        ++ statCounter.cd.times_used;
         break;
 #endif
 
@@ -513,21 +513,21 @@ clientUpdateHierCounters(HierarchyLogEntry * someEntry)
     case FIRST_PARENT_MISS:
 
     case CLOSEST_PARENT_MISS:
-        statCounter.icp.times_used++;
+        ++ statCounter.icp.times_used;
         i = &someEntry->ping;
 
         if (clientPingHasFinished(i))
             statCounter.icp.querySvcTime.count(tvSubUsec(i->start, i->stop));
 
         if (i->timeout)
-            statCounter.icp.query_timeouts++;
+            ++ statCounter.icp.query_timeouts;
 
         break;
 
     case CLOSEST_PARENT:
 
     case CLOSEST_DIRECT:
-        statCounter.netdb.times_used++;
+        ++ statCounter.netdb.times_used;
 
         break;
 
@@ -542,7 +542,7 @@ ClientHttpRequest::updateCounters()
     clientUpdateStatCounters(logType);
 
     if (request->errType != ERR_NONE)
-        statCounter.client_http.errors++;
+        ++ statCounter.client_http.errors;
 
     clientUpdateStatHistCounters(logType,
                                  tvSubMsec(start_time, current_time));
@@ -1928,7 +1928,7 @@ findTrailingHTTPVersion(const char *uriAndHTTPVersion, const char *end)
         assert(end);
     }
 
-    for (; end > uriAndHTTPVersion; end--) {
+    for (; end > uriAndHTTPVersion; --end) {
         if (*end == '\n' || *end == '\r')
             continue;
 
@@ -1979,9 +1979,11 @@ setLogUri(ClientHttpRequest * http, char const *uri, bool cleanUrl)
             char *q = tmp_uri;
             t = uri;
             while (*t) {
-                if (!xisspace(*t))
-                    *q++ = *t;
-                t++;
+                if (!xisspace(*t)) {
+                    *q = *t;
+                    ++q;
+                }
+                ++t;
             }
             *q = '\0';
             http->log_uri = xstrndup(rfc1738_escape_unescaped(tmp_uri), MAX_URL);
@@ -2820,7 +2822,7 @@ connStripBufferWhitespace (ConnStateData * conn)
 {
     while (conn->in.notYetUsed > 0 && xisspace(conn->in.buf[0])) {
         memmove(conn->in.buf, conn->in.buf + 1, conn->in.notYetUsed - 1);
-        --conn->in.notYetUsed;
+        -- conn->in.notYetUsed;
     }
 }
 
@@ -3331,7 +3333,7 @@ httpAccept(const CommAcceptCbParams &params)
         commSetTcpKeepalive(params.conn->fd, s->tcp_keepalive.idle, s->tcp_keepalive.interval, s->tcp_keepalive.timeout);
     }
 
-    incoming_sockets_accepted++;
+    ++ incoming_sockets_accepted;
 
     // Socket is ready, setup the connection manager to start using it
     ConnStateData *connState = connStateCreate(params.conn, s);
@@ -3358,7 +3360,7 @@ httpAccept(const CommAcceptCbParams &params)
         ch.src_addr = params.conn->remote;
         ch.my_addr = params.conn->local;
 
-        for (unsigned int pool = 0; pool < pools.size(); pool++) {
+        for (unsigned int pool = 0; pool < pools.size(); ++pool) {
 
             /* pools require explicit 'allow' to assign a client into them */
             if (pools[pool].access) {
@@ -3632,7 +3634,7 @@ httpsAccept(const CommAcceptCbParams &params)
         commSetTcpKeepalive(params.conn->fd, s->tcp_keepalive.idle, s->tcp_keepalive.interval, s->tcp_keepalive.timeout);
     }
 
-    incoming_sockets_accepted++;
+    ++incoming_sockets_accepted;
 
     // Socket is ready, setup the connection manager to start using it
     ConnStateData *connState = connStateCreate(params.conn, s);
@@ -3975,7 +3977,7 @@ static bool
 AddOpenedHttpSocket(const Comm::ConnectionPointer &conn)
 {
     bool found = false;
-    for (int i = 0; i < NHttpSockets && !found; i++) {
+    for (int i = 0; i < NHttpSockets && !found; ++i) {
         if ((found = HttpSockets[i] < 0))
             HttpSockets[i] = conn->fd;
     }
@@ -4025,7 +4027,8 @@ clientHttpConnectionsOpen(void)
                                         ListeningStartedDialer(&clientListenerConnectionOpened, s, Ipc::fdnHttpSocket, sub));
         Ipc::StartListening(SOCK_STREAM, IPPROTO_TCP, s->listenConn, Ipc::fdnHttpSocket, listenCall);
 
-        HttpSockets[NHttpSockets++] = -1; // set in clientListenerConnectionOpened
+        HttpSockets[NHttpSockets] = -1; // set in clientListenerConnectionOpened
+        ++NHttpSockets;
     }
 }
 
@@ -4079,7 +4082,8 @@ clientHttpsConnectionsOpen(void)
                                         ListeningStartedDialer(&clientListenerConnectionOpened,
                                                                s, Ipc::fdnHttpsSocket, sub));
         Ipc::StartListening(SOCK_STREAM, IPPROTO_TCP, s->listenConn, Ipc::fdnHttpsSocket, listenCall);
-        HttpSockets[NHttpSockets++] = -1;
+        HttpSockets[NHttpSockets] = -1;
+        ++NHttpSockets;
     }
 }
 #endif
@@ -4142,7 +4146,7 @@ clientHttpConnectionsClose(void)
 #endif
 
     // TODO see if we can drop HttpSockets array entirely */
-    for (int i = 0; i < NHttpSockets; i++) {
+    for (int i = 0; i < NHttpSockets; ++i) {
         HttpSockets[i] = -1;
     }
 
@@ -247,11 +247,11 @@ checkFailureRatio(err_type etype, hier_code hcode)
     case ERR_SECURE_CONNECT_FAIL:
 
     case ERR_READ_ERROR:
-        n_bad++;
+        ++n_bad;
         break;
 
     default:
-        n_good++;
+        ++n_good;
     }
 
     request_failure_ratio = n_bad / n_good;
@@ -491,11 +491,11 @@ clientFollowXForwardedForCheck(allow_t answer, void *data)
         */
         /* skip trailing space and commas */
         while (l > 0 && (p[l-1] == ',' || xisspace(p[l-1])))
-            l--;
+            --l;
         request->x_forwarded_for_iterator.cut(l);
         /* look for start of last item in list */
         while (l > 0 && ! (p[l-1] == ',' || xisspace(p[l-1])))
-            l--;
+            --l;
         asciiaddr = p+l;
         if ((addr = asciiaddr)) {
             request->indirect_client_addr = addr;
@@ -549,7 +549,7 @@ ClientRequestContext::hostHeaderIpVerify(const ipcache_addrs* ia, const DnsLooku
 
     if (ia != NULL && ia->count > 0) {
         // Is the NAT destination IP in DNS?
-        for (int i = 0; i < ia->count; i++) {
+        for (int i = 0; i < ia->count; ++i) {
             if (clientConn->local.matchIPAddr(ia->in_addrs[i]) == 0) {
                 debugs(85, 3, HERE << "validate IP " << clientConn->local << " possible from Host:");
                 http->request->flags.hostVerified = 1;
@@ -1023,7 +1023,7 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
 {
     HttpRequest *request = http->request;
     HttpHeader *req_hdr = &request->header;
-    int no_cache = 0;
+    bool no_cache = false;
     const char *str;
 
     request->imslen = -1;
@@ -1037,14 +1037,14 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
             String s = req_hdr->getList(HDR_PRAGMA);
 
             if (strListIsMember(&s, "no-cache", ','))
-                no_cache++;
+                no_cache=true;
 
             s.clean();
         }
 
         if (request->cache_control)
             if (request->cache_control->noCache())
-                no_cache++;
+                no_cache=true;
 
         /*
         * Work around for supporting the Reload button in IE browsers when Squid
@@ -1057,20 +1057,20 @@ clientInterpretRequestHeaders(ClientHttpRequest * http)
             if (http->flags.accel && request->flags.ims) {
                 if ((str = req_hdr->getStr(HDR_USER_AGENT))) {
                     if (strstr(str, "MSIE 5.01") != NULL)
-                        no_cache++;
+                        no_cache=true;
                     else if (strstr(str, "MSIE 5.0") != NULL)
-                        no_cache++;
+                        no_cache=true;
                     else if (strstr(str, "MSIE 4.") != NULL)
-                        no_cache++;
+                        no_cache=true;
                     else if (strstr(str, "MSIE 3.") != NULL)
-                        no_cache++;
+                        no_cache=true;
                 }
             }
         }
     }
 
     if (request->method == METHOD_OTHER) {
-        no_cache++;
+        no_cache=true;
     }
 
     if (no_cache) {
@@ -123,7 +123,7 @@ commHandleRead(int fd, void *data)
     assert(data == COMMIO_FD_READCB(fd));
     assert(ccb->active());
     /* Attempt a read */
-    statCounter.syscalls.sock.reads++;
+    ++ statCounter.syscalls.sock.reads;
     errno = 0;
     int retval;
     retval = FD_READ_METHOD(fd, ccb->buf, ccb->size);
@@ -316,7 +316,7 @@ comm_read_cancel(int fd, AsyncCall::Pointer &callback)
 int
 comm_udp_recvfrom(int fd, void *buf, size_t len, int flags, Ip::Address &from)
 {
-    statCounter.syscalls.sock.recvfroms++;
+    ++ statCounter.syscalls.sock.recvfroms;
     int x = 0;
     struct addrinfo *AI = NULL;
 
@@ -407,7 +407,7 @@ comm_local_port(int fd)
 static comm_err_t
 commBind(int s, struct addrinfo &inaddr)
 {
-    statCounter.syscalls.sock.binds++;
+    ++ statCounter.syscalls.sock.binds;
 
     if (bind(s, inaddr.ai_addr, inaddr.ai_addrlen) == 0) {
         debugs(50, 6, "commBind: bind socket FD " << s << " to " << fd_table[s].local_addr);
@@ -519,7 +519,7 @@ comm_openex(int sock_type,
 
     PROF_start(comm_open);
     /* Create socket for accepting new connections. */
-    statCounter.syscalls.sock.sockets++;
+    ++ statCounter.syscalls.sock.sockets;
 
     /* Setup the socket addrinfo details for use */
     addr.GetAddrInfo(AI);
@@ -820,7 +820,7 @@ comm_connect_addr(int sock, const Ip::Address &address)
 
     if (!F->flags.called_connect) {
         F->flags.called_connect = 1;
-        statCounter.syscalls.sock.connects++;
+        ++ statCounter.syscalls.sock.connects;
 
         x = connect(sock, AI->ai_addr, AI->ai_addrlen);
 
@@ -1055,7 +1055,7 @@ comm_close_complete(const FdeCbParams &params)
     fd_close(params.fd);		/* update fdstat */
     close(params.fd);
 
-    statCounter.syscalls.sock.closes++;
+    ++ statCounter.syscalls.sock.closes;
 
     /* When one connection closes, give accept() a chance, if need be */
     Comm::AcceptLimiter::Instance().kick();
@@ -1167,7 +1167,7 @@ comm_udp_sendto(int fd,
     struct addrinfo *AI = NULL;
 
     PROF_start(comm_udp_sendto);
-    statCounter.syscalls.sock.sendtos++;
+    ++ statCounter.syscalls.sock.sendtos;
 
     debugs(50, 3, "comm_udp_sendto: Attempt to send UDP packet to " << to_addr <<
            " using FD " << fd << " using Port " << comm_local_port(fd) );
@@ -1739,7 +1739,7 @@ commCloseAllSockets(void)
     int fd;
     fde *F = NULL;
 
-    for (fd = 0; fd <= Biggest_FD; fd++) {
+    for (fd = 0; fd <= Biggest_FD; ++fd) {
         F = &fd_table[fd];
 
         if (!F->flags.open)
@@ -1797,7 +1797,7 @@ checkTimeouts(void)
     fde *F = NULL;
     AsyncCall::Pointer callback;
 
-    for (fd = 0; fd <= Biggest_FD; fd++) {
+    for (fd = 0; fd <= Biggest_FD; ++fd) {
         F = &fd_table[fd];
 
         if (writeTimedOut(fd)) {
@@ -2100,7 +2100,7 @@ comm_open_uds(int sock_type,
 
     PROF_start(comm_open);
     /* Create socket for accepting new connections. */
-    statCounter.syscalls.sock.sockets++;
+    ++ statCounter.syscalls.sock.sockets;
 
     /* Setup the socket addrinfo details for use */
     struct addrinfo AI;
@@ -14,7 +14,7 @@ Comm::AcceptLimiter &Comm::AcceptLimiter::Instance()
 void
 Comm::AcceptLimiter::defer(Comm::TcpAcceptor *afd)
 {
-    ++afd->isLimited;
+    ++ afd->isLimited;
     debugs(5, 5, HERE << afd->conn << " x" << afd->isLimited);
     deferred.push_back(afd);
 }
@@ -24,7 +24,7 @@ Comm::AcceptLimiter::removeDead(const Comm::TcpAcceptor *afd)
 {
     for (unsigned int i = 0; i < deferred.size() && afd->isLimited > 0; ++i) {
         if (deferred[i] == afd) {
-            deferred[i]->isLimited--;
+            -- deferred[i]->isLimited;
             deferred[i] = NULL; // fast. kick() will skip empty entries later.
             debugs(5, 5, HERE << afd->conn << " x" << afd->isLimited);
         }
@@ -44,7 +44,7 @@ Comm::AcceptLimiter::kick()
         TcpAcceptor *temp = deferred.shift();
         if (temp != NULL) {
             debugs(5, 5, HERE << " doing one.");
-            temp->isLimited--;
+            -- temp->isLimited;
             temp->acceptNext();
             break;
         }
@@ -230,7 +230,7 @@ Comm::ConnOpener::connect()
     if (callback_ == NULL || callback_->canceled())
         return;
 
-    totalTries_++;
+    ++ totalTries_;
 
     switch (comm_connect_addr(temporaryFd_, conn_->remote) ) {
 
@@ -254,7 +254,7 @@ Comm::ConnOpener::connect()
         break;
 
     default:
-        failRetries_++;
+        ++failRetries_;
 
         // check for timeout FIRST.
         if (squid_curtime - connectStart_ > connectTimeout_) {
@@ -61,8 +61,8 @@ Comm::Connection::close()
     if (isOpen()) {
         comm_close(fd);
         fd = -1;
-        if (getPeer())
-            getPeer()->stats.conn_open--;
+        if (peer *p=getPeer())
+            -- p->stats.conn_open;
     }
 }
 
@@ -165,7 +165,7 @@ comm_update_fd(int fd, int events)
         comm_flush_updates();
 
     /* Push new event onto array */
-    ++devpoll_update.cur;
+    ++ devpoll_update.cur;
     devpoll_update.pfds[devpoll_update.cur].fd = fd;
     devpoll_update.pfds[devpoll_update.cur].events = events;
     devpoll_update.pfds[devpoll_update.cur].revents = 0;
@@ -361,7 +361,7 @@ Comm::DoSelect(int msec)
         comm_flush_updates(); /* ensure latest changes are sent to /dev/poll */
 
         num = ioctl(devpoll_fd, DP_POLL, &do_poll);
-        ++statCounter.select_loops;
+        ++ statCounter.select_loops;
 
         if (num >= 0)
             break; /* no error, skip out of loop */
@@ -421,7 +421,7 @@ Comm::DoSelect(int msec)
                 F->read_handler = NULL;
                 hdl(fd, F->read_data);
                 PROF_stop(comm_read_handler);
-                ++statCounter.select_fds;
+                ++ statCounter.select_fds;
             } else {
                 debugs(
                     5,
@@ -445,7 +445,7 @@ Comm::DoSelect(int msec)
                 F->write_handler = NULL;
                 hdl(fd, F->write_data);
                 PROF_stop(comm_write_handler);
-                ++statCounter.select_fds;
+                ++ statCounter.select_fds;
             } else {
                 debugs(
                     5,
@@ -258,7 +258,7 @@ Comm::DoSelect(int msec)
 
     for (;;) {
         num = epoll_wait(kdpfd, pevents, SQUID_MAXFD, msec);
-        ++statCounter.select_loops;
+        ++ statCounter.select_loops;
 
         if (num >= 0)
             break;
@@ -300,7 +300,7 @@ Comm::DoSelect(int msec)
                 F->read_handler = NULL;
                 hdl(fd, F->read_data);
                 PROF_stop(comm_write_handler);
-                ++statCounter.select_fds;
+                ++ statCounter.select_fds;
             } else {
                 debugs(5, DEBUG_EPOLL ? 0 : 8, HERE << "no read handler for FD " << fd);
                 // remove interest since no handler exist for this event.
@@ -315,7 +315,7 @@ Comm::DoSelect(int msec)
                 F->write_handler = NULL;
                 hdl(fd, F->write_data);
                 PROF_stop(comm_read_handler);
-                ++statCounter.select_fds;
+                ++ statCounter.select_fds;
             } else {
                 debugs(5, DEBUG_EPOLL ? 0 : 8, HERE << "no write handler for FD " << fd);
                 // remove interest since no handler exist for this event.
@@ -216,7 +216,7 @@ comm_check_incoming_poll_handlers(int nfds, int *fds)
     PROF_start(comm_check_incoming);
     incoming_sockets_accepted = 0;
 
-    for (i = npfds = 0; i < nfds; i++) {
+    for (i = npfds = 0; i < nfds; ++i) {
         int events;
         fd = fds[i];
         events = 0;
@@ -241,7 +241,7 @@ comm_check_incoming_poll_handlers(int nfds, int *fds)
     }
 
     getCurrentTime();
-    ++statCounter.syscalls.selects;
+    ++ statCounter.syscalls.selects;
 
     if (poll(pfds, npfds, 0) < 1) {
         PROF_stop(comm_check_incoming);
@@ -283,11 +283,15 @@ comm_poll_udp_incoming(void)
     int nevents;
     udp_io_events = 0;
 
-    if (Comm::IsConnOpen(icpIncomingConn))
-        fds[nfds++] = icpIncomingConn->fd;
+    if (Comm::IsConnOpen(icpIncomingConn)) {
+        fds[nfds] = icpIncomingConn->fd;
+        ++nfds;
+    }
 
-    if (icpIncomingConn != icpOutgoingConn && Comm::IsConnOpen(icpOutgoingConn))
-        fds[nfds++] = icpOutgoingConn->fd;
+    if (icpIncomingConn != icpOutgoingConn && Comm::IsConnOpen(icpOutgoingConn)) {
+        fds[nfds] = icpOutgoingConn->fd;
+        ++nfds;
+    }
 
     if (nfds == 0)
         return;
@@ -319,11 +323,12 @@ comm_poll_tcp_incoming(void)
 
     // XXX: only poll sockets that won't be deferred. But how do we identify them?
 
-    for (j = 0; j < NHttpSockets; j++) {
+    for (j = 0; j < NHttpSockets; ++j) {
         if (HttpSockets[j] < 0)
             continue;
 
-        fds[nfds++] = HttpSockets[j];
+        fds[nfds] = HttpSockets[j];
+        ++nfds;
     }
 
     nevents = comm_check_incoming_poll_handlers(nfds, fds);
@@ -381,7 +386,7 @@ Comm::DoSelect(int msec)
 
         maxfd = Biggest_FD + 1;
 
-        for (int i = 0; i < maxfd; i++) {
+        for (int i = 0; i < maxfd; ++i) {
             int events;
             events = 0;
             /* Check each open socket for a handler. */
@@ -425,9 +430,9 @@ Comm::DoSelect(int msec)
 
         for (;;) {
             PROF_start(comm_poll_normal);
-            ++statCounter.syscalls.selects;
+            ++ statCounter.syscalls.selects;
             num = poll(pfds, nfds, msec);
-            ++statCounter.select_loops;
+            ++ statCounter.select_loops;
             PROF_stop(comm_poll_normal);
 
             if (num >= 0 || npending > 0)
@@ -458,7 +463,7 @@ Comm::DoSelect(int msec)
          * limit in SunOS */
         PROF_start(comm_handle_ready_fd);
 
-        for (size_t loopIndex = 0; loopIndex < nfds; loopIndex++) {
+        for (size_t loopIndex = 0; loopIndex < nfds; ++loopIndex) {
             fde *F;
             int revents = pfds[loopIndex].revents;
             fd = pfds[loopIndex].fd;
@@ -498,7 +503,7 @@ Comm::DoSelect(int msec)
                     F->flags.read_pending = 0;
                     hdl(fd, F->read_data);
                     PROF_stop(comm_read_handler);
-                    ++statCounter.select_fds;
+                    ++ statCounter.select_fds;
 
                     if (commCheckUdpIncoming)
                         comm_poll_udp_incoming();
@@ -519,7 +524,7 @@ Comm::DoSelect(int msec)
                     F->write_handler = NULL;
                     hdl(fd, F->write_data);
                     PROF_stop(comm_write_handler);
-                    ++statCounter.select_fds;
+                    ++ statCounter.select_fds;
 
                     if (commCheckUdpIncoming)
                         comm_poll_udp_incoming();
@@ -595,11 +600,15 @@ comm_poll_dns_incoming(void)
     if (DnsSocketA < 0 && DnsSocketB < 0)
         return;
 
-    if (DnsSocketA >= 0)
-        fds[nfds++] = DnsSocketA;
+    if (DnsSocketA >= 0) {
+        fds[nfds] = DnsSocketA;
+        ++nfds;
+    }
 
-    if (DnsSocketB >= 0)
-        fds[nfds++] = DnsSocketB;
+    if (DnsSocketB >= 0) {
+        fds[nfds] = DnsSocketB;
+        ++nfds;
+    }
 
     nevents = comm_check_incoming_poll_handlers(nfds, fds);
 
@@ -215,7 +215,7 @@ comm_check_incoming_select_handlers(int nfds, int *fds)
     FD_ZERO(&write_mask);
     incoming_sockets_accepted = 0;
 
-    for (i = 0; i < nfds; i++) {
+    for (i = 0; i < nfds; ++i) {
         fd = fds[i];
 
         if (fd_table[fd].read_handler) {
@@ -238,7 +238,7 @@ comm_check_incoming_select_handlers(int nfds, int *fds)
 
     getCurrentTime();
 
-    ++statCounter.syscalls.selects;
+    ++ statCounter.syscalls.selects;
 
     if (select(maxfd, &read_mask, &write_mask, NULL, &zero_tv) < 1)
         return incoming_sockets_accepted;
@@ -278,11 +278,15 @@ comm_select_udp_incoming(void)
     int nevents;
     udp_io_events = 0;
 
-    if (Comm::IsConnOpen(icpIncomingConn))
-        fds[nfds++] = icpIncomingConn->fd;
+    if (Comm::IsConnOpen(icpIncomingConn)) {
+        fds[nfds] = icpIncomingConn->fd;
+        ++nfds;
+    }
 
-    if (Comm::IsConnOpen(icpOutgoingConn) && icpIncomingConn != icpOutgoingConn)
-        fds[nfds++] = icpOutgoingConn->fd;
+    if (Comm::IsConnOpen(icpOutgoingConn) && icpIncomingConn != icpOutgoingConn) {
+        fds[nfds] = icpOutgoingConn->fd;
+        ++nfds;
+    }
 
     if (nfds == 0)
         return;
@@ -314,8 +318,10 @@ comm_select_tcp_incoming(void)
     // XXX: only poll sockets that won't be deferred. But how do we identify them?
 
     for (const AnyP::PortCfg *s = Config.Sockaddr.http; s; s = s->next) {
-        if (Comm::IsConnOpen(s->listenConn))
-            fds[nfds++] = s->listenConn->fd;
+        if (Comm::IsConnOpen(s->listenConn)) {
+            fds[nfds] = s->listenConn->fd;
+            ++nfds;
+        }
     }
 
     nevents = comm_check_incoming_select_handlers(nfds, fds);
@@ -397,11 +403,11 @@ Comm::DoSelect(int msec)
 
         fdsp = (fd_mask *) & readfds;
 
-        for (j = 0; j < maxindex; j++) {
+        for (j = 0; j < maxindex; ++j) {
             if ((tmask = fdsp[j]) == 0)
                 continue;	/* no bits here */
 
-            for (k = 0; k < FD_MASK_BITS; k++) {
+            for (k = 0; k < FD_MASK_BITS; ++k) {
                 if (!EBIT_TEST(tmask, k))
                     continue;
 
@@ -410,13 +416,13 @@ Comm::DoSelect(int msec)
 
                 if (FD_ISSET(fd, &readfds) && fd_table[fd].flags.read_pending) {
                     FD_SET(fd, &pendingfds);
-                    pending++;
+                    ++pending;
                 }
             }
         }
 
 #if DEBUG_FDBITS
-        for (i = 0; i < maxfd; i++) {
+        for (i = 0; i < maxfd; ++i) {
             /* Check each open socket for a handler. */
 
             if (fd_table[i].read_handler) {
@@ -443,9 +449,9 @@ Comm::DoSelect(int msec)
         for (;;) {
             poll_time.tv_sec = msec / 1000;
             poll_time.tv_usec = (msec % 1000) * 1000;
-            statCounter.syscalls.selects++;
+            ++ statCounter.syscalls.selects;
             num = select(maxfd, &readfds, &writefds, NULL, &poll_time);
-            ++statCounter.select_loops;
+            ++ statCounter.select_loops;
 
             if (num >= 0 || pending > 0)
                 break;
@@ -481,11 +487,11 @@ Comm::DoSelect(int msec)
 
         maxindex = howmany(maxfd, FD_MASK_BITS);
 
-        for (j = 0; j < maxindex; j++) {
+        for (j = 0; j < maxindex; ++j) {
             if ((tmask = (fdsp[j] | pfdsp[j])) == 0)
                 continue;	/* no bits here */
 
-            for (k = 0; k < FD_MASK_BITS; k++) {
+            for (k = 0; k < FD_MASK_BITS; ++k) {
                 if (tmask == 0)
                     break;	/* no more bits left */
 
@@ -530,7 +536,7 @@ Comm::DoSelect(int msec)
                     F->flags.read_pending = 0;
                     commUpdateReadBits(fd, NULL);
                     hdl(fd, F->read_data);
-                    statCounter.select_fds++;
+                    ++ statCounter.select_fds;
 
                     if (commCheckUdpIncoming)
                         comm_select_udp_incoming();
@@ -546,11 +552,11 @@ Comm::DoSelect(int msec)
 
         fdsp = (fd_mask *) & writefds;
 
-        for (j = 0; j < maxindex; j++) {
+        for (j = 0; j < maxindex; ++j) {
             if ((tmask = fdsp[j]) == 0)
                 continue;	/* no bits here */
 
-            for (k = 0; k < FD_MASK_BITS; k++) {
+            for (k = 0; k < FD_MASK_BITS; ++k) {
                 if (tmask == 0)
                     break;	/* no more bits left */
 
@@ -592,7 +598,7 @@ Comm::DoSelect(int msec)
                     F->write_handler = NULL;
                     commUpdateWriteBits(fd, NULL);
                     hdl(fd, F->write_data);
-                    statCounter.select_fds++;
+                    ++ statCounter.select_fds;
 
                     if (commCheckUdpIncoming)
                         comm_select_udp_incoming();
@@ -637,11 +643,15 @@ comm_select_dns_incoming(void)
     if (DnsSocketA < 0 && DnsSocketB < 0)
         return;
 
-    if (DnsSocketA >= 0)
-        fds[nfds++] = DnsSocketA;
+    if (DnsSocketA >= 0) {
+        fds[nfds] = DnsSocketA;
+        ++nfds;
+    }
 
-    if (DnsSocketB >= 0)
-        fds[nfds++] = DnsSocketB;
+    if (DnsSocketB >= 0) {
+        fds[nfds] = DnsSocketB;
+        ++nfds;
+    }
 
     nevents = comm_check_incoming_select_handlers(nfds, fds);
 
@@ -700,7 +710,7 @@ examine_select(fd_set * readfds, fd_set * writefds)
     struct stat sb;
     debugs(5, 0, "examine_select: Examining open file descriptors...");
 
-    for (fd = 0; fd < Squid_MaxFD; fd++) {
+    for (fd = 0; fd < Squid_MaxFD; ++fd) {
         FD_ZERO(&read_x);
         FD_ZERO(&write_x);
         tv.tv_sec = tv.tv_usec = 0;
@@ -712,7 +722,7 @@ examine_select(fd_set * readfds, fd_set * writefds)
         else
             continue;
 
-        statCounter.syscalls.selects++;
+        ++ statCounter.syscalls.selects;
         errno = 0;
 
         if (!fstat(fd, &sb)) {
@@ -772,10 +782,10 @@ commUpdateReadBits(int fd, PF * handler)
 {
     if (handler && !FD_ISSET(fd, &global_readfds)) {
         FD_SET(fd, &global_readfds);
-        nreadfds++;
+        ++nreadfds;
     } else if (!handler && FD_ISSET(fd, &global_readfds)) {
         FD_CLR(fd, &global_readfds);
-        nreadfds--;
+        --nreadfds;
     }
 }
 
@@ -784,10 +794,10 @@ commUpdateWriteBits(int fd, PF * handler)
 {
     if (handler && !FD_ISSET(fd, &global_writefds)) {
         FD_SET(fd, &global_writefds);
-        nwritefds++;
+        ++nwritefds;
     } else if (!handler && FD_ISSET(fd, &global_writefds)) {
         FD_CLR(fd, &global_writefds);
-        nwritefds--;
+        --nwritefds;
     }
 }
 
@@ -217,7 +217,7 @@ comm_check_incoming_select_handlers(int nfds, int *fds)
     FD_ZERO(&write_mask);
     incoming_sockets_accepted = 0;
 
-    for (i = 0; i < nfds; i++) {
+    for (i = 0; i < nfds; ++i) {
         fd = fds[i];
 
         if (fd_table[fd].read_handler) {
@@ -240,13 +240,13 @@ comm_check_incoming_select_handlers(int nfds, int *fds)
 
     getCurrentTime();
 
-    statCounter.syscalls.selects++;
+    ++ statCounter.syscalls.selects;
 
     if (select(maxfd, &read_mask, &write_mask, &errfds, &zero_tv) < 1)
 
         return incoming_sockets_accepted;
 
-    for (i = 0; i < nfds; i++) {
+    for (i = 0; i < nfds; ++i) {
         fd = fds[i];
 
         if (FD_ISSET(fd, &read_mask)) {
@@ -281,11 +281,15 @@ comm_select_udp_incoming(void)
     int nevents;
     udp_io_events = 0;
 
-    if (Comm::IsConnOpen(icpIncomingConn))
-        fds[nfds++] = icpIncomingConn->fd;
+    if (Comm::IsConnOpen(icpIncomingConn)) {
+        fds[nfds] = icpIncomingConn->fd;
+        ++nfds;
+    }
 
-    if (Comm::IsConnOpen(icpOutgoingConn) && icpIncomingConn != icpOutgoingConn)
-        fds[nfds++] = icpOutgoingConn->fd;
+    if (Comm::IsConnOpen(icpOutgoingConn) && icpIncomingConn != icpOutgoingConn) {
+        fds[nfds] = icpOutgoingConn->fd;
+        ++nfds;
+    }
 
     if (nfds == 0)
         return;
@@ -317,8 +321,10 @@ comm_select_tcp_incoming(void)
     // XXX: only poll sockets that won't be deferred. But how do we identify them?
 
     for (const AnyP::PortCfg *s = Config.Sockaddr.http; s; s = s->next) {
-        if (Comm::IsConnOpen(s->listenConn))
-            fds[nfds++] = s->listenConn->fd;
+        if (Comm::IsConnOpen(s->listenConn)) {
+            fds[nfds] = s->listenConn->fd;
+            ++nfds;
+        }
     }
 
     nevents = comm_check_incoming_select_handlers(nfds, fds);
@@ -393,11 +399,11 @@ Comm::DoSelect(int msec)
 
         FD_ZERO(&pendingfds);
 
-        for (j = 0; j < (int) readfds.fd_count; j++) {
+        for (j = 0; j < (int) readfds.fd_count; ++j) {
             register int readfds_handle = readfds.fd_array[j];
             no_bits = 1;
 
-            for ( fd = Biggest_FD; fd; fd-- ) {
+            for ( fd = Biggest_FD; fd; --fd ) {
                 if ( fd_table[fd].win32.handle == readfds_handle ) {
                     if (fd_table[fd].flags.open) {
                         no_bits = 0;
@@ -411,12 +417,12 @@ Comm::DoSelect(int msec)
 
             if (FD_ISSET(fd, &readfds) && fd_table[fd].flags.read_pending) {
                 FD_SET(fd, &pendingfds);
-                pending++;
+                ++pending;
             }
         }
 
 #if DEBUG_FDBITS
-        for (i = 0; i < maxfd; i++) {
+        for (i = 0; i < maxfd; ++i) {
             /* Check each open socket for a handler. */
 
             if (fd_table[i].read_handler) {
@@ -478,13 +484,13 @@ Comm::DoSelect(int msec)
         assert(readfds.fd_count <= (unsigned int) Biggest_FD);
         assert(pendingfds.fd_count <= (unsigned int) Biggest_FD);
 
-        for (j = 0; j < (int) readfds.fd_count; j++) {
+        for (j = 0; j < (int) readfds.fd_count; ++j) {
             register int readfds_handle = readfds.fd_array[j];
             register int pendingfds_handle = pendingfds.fd_array[j];
             register int osfhandle;
             no_bits = 1;
 
-            for ( fd = Biggest_FD; fd; fd-- ) {
+            for ( fd = Biggest_FD; fd; --fd ) {
                 osfhandle = fd_table[fd].win32.handle;
 
                 if (( osfhandle == readfds_handle ) ||
@@ -530,7 +536,7 @@ Comm::DoSelect(int msec)
                 F->flags.read_pending = 0;
                 commUpdateReadBits(fd, NULL);
                 hdl(fd, F->read_data);
-                statCounter.select_fds++;
+                ++ statCounter.select_fds;
 
                 if (commCheckUdpIncoming)
                     comm_select_udp_incoming();
@@ -545,10 +551,10 @@ Comm::DoSelect(int msec)
 
         assert(errfds.fd_count <= (unsigned int) Biggest_FD);
 
-        for (j = 0; j < (int) errfds.fd_count; j++) {
+        for (j = 0; j < (int) errfds.fd_count; ++j) {
             register int errfds_handle = errfds.fd_array[j];
 
-            for ( fd = Biggest_FD; fd; fd-- ) {
+            for ( fd = Biggest_FD; fd; --fd ) {
                 if ( fd_table[fd].win32.handle == errfds_handle )
                     break;
             }
@@ -560,18 +566,18 @@ Comm::DoSelect(int msec)
                     F->write_handler = NULL;
                     commUpdateWriteBits(fd, NULL);
                     hdl(fd, F->write_data);
-                    statCounter.select_fds++;
+                    ++ statCounter.select_fds;
                 }
             }
         }
 
         assert(writefds.fd_count <= (unsigned int) Biggest_FD);
 
-        for (j = 0; j < (int) writefds.fd_count; j++) {
+        for (j = 0; j < (int) writefds.fd_count; ++j) {
             register int writefds_handle = writefds.fd_array[j];
             no_bits = 1;
 
-            for ( fd = Biggest_FD; fd; fd-- ) {
+            for ( fd = Biggest_FD; fd; --fd ) {
                 if ( fd_table[fd].win32.handle == writefds_handle ) {
                     if (fd_table[fd].flags.open) {
                         no_bits = 0;
@@ -613,7 +619,7 @@ Comm::DoSelect(int msec)
                 F->write_handler = NULL;
                 commUpdateWriteBits(fd, NULL);
                 hdl(fd, F->write_data);
-                statCounter.select_fds++;
+                ++ statCounter.select_fds;
 
                 if (commCheckUdpIncoming)
                     comm_select_udp_incoming();
@@ -657,11 +663,15 @@ comm_select_dns_incoming(void)
     if (DnsSocketA < 0 && DnsSocketB < 0)
         return;
 
-    if (DnsSocketA >= 0)
-        fds[nfds++] = DnsSocketA;
+    if (DnsSocketA >= 0) {
+        fds[nfds] = DnsSocketA;
+        ++nfds;
+    }
 
-    if (DnsSocketB >= 0)
-        fds[nfds++] = DnsSocketB;
+    if (DnsSocketB >= 0) {
+        fds[nfds] = DnsSocketB;
+        ++nfds;
+    }
 
     nevents = comm_check_incoming_select_handlers(nfds, fds);
 
@@ -720,7 +730,7 @@ examine_select(fd_set * readfds, fd_set * writefds)
     struct stat sb;
     debugs(5, 0, "examine_select: Examining open file descriptors...");
 
-    for (fd = 0; fd < Squid_MaxFD; fd++) {
+    for (fd = 0; fd < Squid_MaxFD; ++fd) {
         FD_ZERO(&read_x);
         FD_ZERO(&write_x);
         tv.tv_sec = tv.tv_usec = 0;
@@ -732,7 +742,7 @@ examine_select(fd_set * readfds, fd_set * writefds)
         else
             continue;
 
-        statCounter.syscalls.selects++;
+        ++ statCounter.syscalls.selects;
         errno = 0;
 
         if (!fstat(fd, &sb)) {
@@ -792,10 +802,10 @@ commUpdateReadBits(int fd, PF * handler)
 {
     if (handler && !FD_ISSET(fd, &global_readfds)) {
         FD_SET(fd, &global_readfds);
-        nreadfds++;
+        ++nreadfds;
     } else if (!handler && FD_ISSET(fd, &global_readfds)) {
         FD_CLR(fd, &global_readfds);
-        nreadfds--;
+        --nreadfds;
     }
 }
 
@@ -804,10 +814,10 @@ commUpdateWriteBits(int fd, PF * handler)
 {
     if (handler && !FD_ISSET(fd, &global_writefds)) {
         FD_SET(fd, &global_writefds);
-        nwritefds++;
+        ++nwritefds;
     } else if (!handler && FD_ISSET(fd, &global_writefds)) {
         FD_CLR(fd, &global_writefds);
-        nwritefds--;
+        --nwritefds;
     }
 }
 
@@ -225,7 +225,7 @@ debugArg(const char *arg)
         return;
     }
 
-    for (i = 0; i < MAX_DEBUG_SECTIONS; i++)
+    for (i = 0; i < MAX_DEBUG_SECTIONS; ++i)
         Debug::Levels[i] = l;
 }
 
@@ -395,7 +395,7 @@ _db_set_syslog(const char *facility)
 
         struct syslog_facility_name *n;
 
-        for (n = syslog_facility_names; n->name; n++) {
+        for (n = syslog_facility_names; n->name; ++n) {
             if (strcmp(n->name, facility) == 0) {
                 syslog_facility = n->facility;
                 return;
@@ -427,7 +427,7 @@ Debug::parseOptions(char const *options)
         return;
     }
 
-    for (i = 0; i < MAX_DEBUG_SECTIONS; i++)
+    for (i = 0; i < MAX_DEBUG_SECTIONS; ++i)
         Debug::Levels[i] = 0;
 
     if (options) {
@@ -484,7 +484,7 @@ _db_rotate_log(void)
      */
     /* Rotate numbers 0 through N up one */
     for (int i = Debug::rotateNumber; i > 1;) {
-        i--;
+        --i;
         snprintf(from, MAXPATHLEN, "%s.%d", debug_log_file, i - 1);
         snprintf(to, MAXPATHLEN, "%s.%d", debug_log_file, i);
 #if _SQUID_MSWIN_
@@ -664,7 +664,7 @@ static const char *ctx_get_descr(Ctx ctx);
 Ctx
 ctx_enter(const char *descr)
 {
-    Ctx_Current_Level++;
+    ++Ctx_Current_Level;
 
     if (Ctx_Current_Level <= CTX_MAX_LEVEL)
         Ctx_Descrs[Ctx_Current_Level] = descr;
@@ -695,7 +695,7 @@ static void
 ctx_print(void)
 {
     /* lock so _db_print will not call us recursively */
-    Ctx_Lock++;
+    ++Ctx_Lock;
     /* ok, user saw [0,Ctx_Reported_Level] descriptions */
     /* first inform about entries popped since user saw them */
 
@@ -711,14 +711,14 @@ ctx_print(void)
 
     /* report new contexts that were pushed since last report */
     while (Ctx_Reported_Level < Ctx_Current_Level) {
-        Ctx_Reported_Level++;
-        Ctx_Valid_Level++;
+        ++Ctx_Reported_Level;
+        ++Ctx_Valid_Level;
         _db_print("ctx: enter level %2d: '%s'\n", Ctx_Reported_Level,
                   ctx_get_descr(Ctx_Reported_Level));
     }
 
     /* unlock */
-    Ctx_Lock--;
+    --Ctx_Lock;
 }
 
 /* checks for nulls and overflows */
@@ -743,7 +743,7 @@ VectorPool::stats(StoreEntry * sentry)
 
     storeAppendPrintf(sentry, "\t\tCurrent:");
 
-    for (unsigned int i = 0; i < buckets.size(); i++) {
+    for (unsigned int i = 0; i < buckets.size(); ++i) {
         storeAppendPrintf(sentry, " %d:", buckets.key_map[i]);
         buckets.values[i].stats(sentry);
     }
@@ -79,7 +79,7 @@ file_open(const char *path, int mode)
 
     fd = open(path, mode, 0644);
 
-    statCounter.syscalls.disk.opens++;
+    ++ statCounter.syscalls.disk.opens;
 
     if (fd < 0) {
         debugs(50, 3, "file_open: error opening file " << path << ": " << xstrerror());
@@ -145,7 +145,7 @@ file_close(int fd)
 
     fd_close(fd);
 
-    statCounter.syscalls.disk.closes++;
+    ++ statCounter.syscalls.disk.closes;
 
     PROF_stop(file_close);
 }
@@ -247,7 +247,7 @@ diskHandleWrite(int fd, void *notused)
 
     debugs(6, 3, "diskHandleWrite: FD " << fd << " len = " << len);
 
-    statCounter.syscalls.disk.writes++;
+    ++ statCounter.syscalls.disk.writes;
 
     fd_bytes(fd, len, FD_WRITE);
 
@@ -443,7 +443,7 @@ diskHandleRead(int fd, void *data)
 #endif
         debugs(6, 3, "diskHandleRead: FD " << fd << " seeking to offset " << ctrl_dat->offset);
         lseek(fd, ctrl_dat->offset, SEEK_SET);	/* XXX ignore return? */
-        ++statCounter.syscalls.disk.seeks;
+        ++ statCounter.syscalls.disk.seeks;
         F->disk.offset = ctrl_dat->offset;
     }
 
@@ -453,7 +453,7 @@ diskHandleRead(int fd, void *data)
     if (len > 0)
         F->disk.offset += len;
 
-    statCounter.syscalls.disk.reads++;
+    ++ statCounter.syscalls.disk.reads;
 
     fd_bytes(fd, len, FD_READ);
 
@@ -507,7 +507,7 @@ file_read(int fd, char *buf, int req_len, off_t offset, DRCB * handler, void *cl
 void
 safeunlink(const char *s, int quiet)
 {
-    statCounter.syscalls.disk.unlinks++;
+    ++ statCounter.syscalls.disk.unlinks;
 
     if (unlink(s) < 0 && !quiet)
         debugs(50, 1, "safeunlink: Couldn't delete " << s << ": " << xstrerror());
@@ -299,7 +299,7 @@ idnsAddNameserver(const char *buf)
     // TODO generate a test packet to probe this NS from EDNS size and ability.
 #endif
     debugs(78, 3, "idnsAddNameserver: Added nameserver #" << nns << " (" << A << ")");
-    nns++;
+    ++nns;
 }
 
 static void
@@ -327,7 +327,7 @@ idnsAddPathComponent(const char *buf)
     strcpy(searchpath[npc].domain, buf);
     Tolower(searchpath[npc].domain);
     debugs(78, 3, "idnsAddPathComponent: Added domain #" << npc << ": " << searchpath[npc].domain);
-    npc++;
+    ++npc;
 }
 
 
@@ -559,7 +559,7 @@ idnsParseWIN32Registry(void)
 
             if (RegQueryInfoKey(hndKey, NULL, NULL, NULL, &InterfacesCount, &MaxSubkeyLen, NULL, NULL, NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {
                 keyname = (char *) xmalloc(++MaxSubkeyLen);
-                for (i = 0; i < (int) InterfacesCount; i++) {
+                for (i = 0; i < (int) InterfacesCount; ++i) {
                     DWORD j;
                     j = MaxSubkeyLen;
                     if (RegEnumKeyEx(hndKey, i, keyname, &j, NULL, NULL, NULL, &ftLastWriteTime) == ERROR_SUCCESS) {
@@ -686,7 +686,7 @@ idnsStats(StoreEntry * sentry)
     storeAppendPrintf(sentry, "IP ADDRESS                                     # QUERIES # REPLIES\n");
     storeAppendPrintf(sentry, "---------------------------------------------- --------- ---------\n");
 
-    for (i = 0; i < nns; i++) {
+    for (i = 0; i < nns; ++i) {
         storeAppendPrintf(sentry, "%-45s %9d %9d\n",  /* Let's take the maximum: (15 IPv4/45 IPv6) */
                           nameservers[i].S.NtoA(buf,MAX_IPSTRLEN),
                           nameservers[i].nqueries,
@@ -696,18 +696,18 @@ idnsStats(StoreEntry * sentry)
     storeAppendPrintf(sentry, "\nRcode Matrix:\n");
     storeAppendPrintf(sentry, "RCODE");
 
-    for (i = 0; i < MAX_ATTEMPT; i++)
+    for (i = 0; i < MAX_ATTEMPT; ++i)
         storeAppendPrintf(sentry, " ATTEMPT%d", i + 1);
 
     storeAppendPrintf(sentry, " PROBLEM\n");
 
-    for (j = 0; j < MAX_RCODE; j++) {
+    for (j = 0; j < MAX_RCODE; ++j) {
         if (j > 10 && j < 16)
             continue; // unassigned by IANA.
 
         storeAppendPrintf(sentry, "%5d", j);
 
-        for (i = 0; i < MAX_ATTEMPT; i++)
+        for (i = 0; i < MAX_ATTEMPT; ++i)
             storeAppendPrintf(sentry, " %8d", RcodeMatrix[j][i]);
 
         storeAppendPrintf(sentry, " : %s\n",Rcodes[j]);
@@ -716,7 +716,7 @@ idnsStats(StoreEntry * sentry)
     if (npc) {
         storeAppendPrintf(sentry, "\nSearch list:\n");
 
-        for (i=0; i < npc; i++)
+        for (i=0; i < npc; ++i)
             storeAppendPrintf(sentry, "%s\n", searchpath[i].domain);
 
         storeAppendPrintf(sentry, "\n");
@@ -920,7 +920,7 @@ idnsSendQuery(idns_query * q)
                 x = comm_udp_sendto(DnsSocketA, nameservers[ns].S, q->buf, q->sz);
         }
 
-        q->nsends++;
+        ++ q->nsends;
 
         q->sent_t = current_time;
 
@@ -938,7 +938,7 @@ idnsSendQuery(idns_query * q)
         fd_bytes(DnsSocketA, x, FD_WRITE);
     }
 
-    nameservers[ns].nqueries++;
+    ++ nameservers[ns].nqueries;
     q->queue_t = current_time;
     dlinkAdd(q, &q->lru, &lru_list);
     q->pending = 1;
@@ -950,7 +950,7 @@ idnsFromKnownNameserver(Ip::Address const &from)
 {
     int i;
 
-    for (i = 0; i < nns; i++) {
+    for (i = 0; i < nns; ++i) {
         if (nameservers[i].S != from)
             continue;
 
@@ -986,7 +986,7 @@ idnsQueryID(void)
     unsigned short first_id = id;
 
     while (idnsFindQuery(id)) {
-        id++;
+        ++id;
 
         if (id == first_id) {
             debugs(78, 1, "idnsQueryID: Warning, too many pending DNS requests");
@@ -1129,7 +1129,7 @@ idnsGrokReply(const char *buf, size_t sz, int from_ns)
             // the altered NS was limiting the whole group.
             max_shared_edns = q->edns_seen;
             // may be limited by one of the others still
-            for (int i = 0; i < nns; i++)
+            for (int i = 0; i < nns; ++i)
                 max_shared_edns = min(max_shared_edns, nameservers[i].last_seen_edns);
         } else {
             nameservers[from_ns].last_seen_edns = q->edns_seen;
@@ -1150,7 +1150,7 @@ idnsGrokReply(const char *buf, size_t sz, int from_ns)
 
         if (!q->need_vc) {
             q->need_vc = 1;
-            q->nsends--;
+            -- q->nsends;
             idnsSendQuery(q);
         } else {
             // Strange: A TCP DNS response with the truncation bit (TC) set.
@@ -1168,7 +1168,7 @@ idnsGrokReply(const char *buf, size_t sz, int from_ns)
         q->rcode = -n;
         debugs(78, 3, "idnsGrokReply: error " << rfc1035ErrorMessage(n) << " (" << q->rcode << ")");
 
-        if (q->rcode == 2 && ++q->attempt < MAX_ATTEMPT) {
+        if (q->rcode == 2 && (++ q->attempt) < MAX_ATTEMPT) {
             /*
              * RCODE 2 is "Server failure - The name server was
              * unable to process this query due to a problem with
@@ -1193,9 +1193,9 @@ idnsGrokReply(const char *buf, size_t sz, int from_ns)
                 strcat(q->name, ".");
                 strcat(q->name, searchpath[q->domain].domain);
                 debugs(78, 3, "idnsGrokReply: searchpath used for " << q->name);
-                q->domain++;
+                ++ q->domain;
             } else {
-                q->attempt++;
+                ++ q->attempt;
             }
 
             rfc1035MessageDestroy(&message);
@@ -1263,7 +1263,8 @@ idnsRead(int fd, void *data)
      */
     Ip::Address bugbypass;
 
-    while (max--) {
+    while (max) {
+        --max;
         len = comm_udp_recvfrom(fd, rbuf, SQUID_UDP_SO_RCVBUF, 0, bugbypass);
 
         from = bugbypass; // BUG BYPASS. see notes above.
@@ -1291,15 +1292,15 @@ idnsRead(int fd, void *data)
         fd_bytes(fd, len, FD_READ);
 
         assert(N);
-        (*N)++;
+        ++(*N);
 
         debugs(78, 3, "idnsRead: FD " << fd << ": received " << len << " bytes from " << from);
 
         /* BUG: see above. Its here that it becomes apparent that the content of bugbypass is gone. */
         ns = idnsFromKnownNameserver(from);
 
         if (ns >= 0) {
-            nameservers[ns].nreplies++;
+            ++ nameservers[ns].nreplies;
         }
 
         // Before unknown_nameservers check to avoid flooding cache.log on attacks,
@@ -1458,7 +1459,7 @@ idnsRcodeCount(int rcode, int attempt)
 
     if (rcode < MAX_RCODE)
         if (attempt < MAX_ATTEMPT)
-            RcodeMatrix[rcode][attempt]++;
+            ++ RcodeMatrix[rcode][attempt];
 }
 
 /* ====================================================================== */
@@ -1553,7 +1554,7 @@ dnsInit(void)
         memDataInit(MEM_IDNS_QUERY, "idns_query", sizeof(idns_query), 0);
         memset(RcodeMatrix, '\0', sizeof(RcodeMatrix));
         idns_lookup_hash = hash_create((HASHCMP *) strcmp, 103, hash_string);
-        init++;
+        ++init;
     }
 
 #if WHEN_EDNS_RESPONSES_ARE_PARSED
@@ -1582,7 +1583,7 @@ dnsShutdown(void)
         DnsSocketB = -1;
     }
 
-    for (int i = 0; i < nns; i++) {
+    for (int i = 0; i < nns; ++i) {
         if (nsvc *vc = nameservers[i].vc) {
             if (Comm::IsConnOpen(vc->conn))
                 vc->conn->close();
@@ -1670,9 +1671,9 @@ idnsALookup(const char *name, IDNSCB * callback, void *data)
     q->xact_id.change();
     q->query_id = idnsQueryID();
 
-    for (i = 0; i < strlen(name); i++)
+    for (i = 0; i < strlen(name); ++i)
         if (name[i] == '.')
-            nd++;
+            ++nd;
 
     if (Config.onoff.res_defnames && npc > 0 && name[strlen(name)-1] != '.') {
         q->do_searchpath = 1;
@@ -1771,7 +1772,7 @@ snmp_netDnsFn(variable_list * Var, snint * ErrP)
 
     case DNS_REQ:
 
-        for (i = 0; i < nns; i++)
+        for (i = 0; i < nns; ++i)
             n += nameservers[i].nqueries;
 
         Answer = snmp_var_new_integer(Var->name, Var->name_length,
@@ -1781,7 +1782,7 @@ snmp_netDnsFn(variable_list * Var, snint * ErrP)
         break;
 
     case DNS_REP:
-        for (i = 0; i < nns; i++)
+        for (i = 0; i < nns; ++i)
             n += nameservers[i].nreplies;
 
         Answer = snmp_var_new_integer(Var->name, Var->name_length,
@@ -265,7 +265,7 @@ lookup(const char *buf)
                     continue;
                 }
                 printf(" %s", ntoabuf);
-                i++;
+                ++i;
                 aiptr = aiptr->ai_next;
             }
 
@@ -428,7 +428,7 @@ squid_res_setservers(int reset)
         if (_SQUID_RES_NSADDR_COUNT == MAXNS) {
             fprintf(stderr, "Too many -s options, only %d are allowed\n", MAXNS);
         } else {
-            _SQUID_RES_NSADDR_COUNT++;
+            ++ _SQUID_RES_NSADDR_COUNT;
             memcpy(&_SQUID_RES_NSADDR6_LIST(_SQUID_RES_NSADDR6_COUNT++), &((struct sockaddr_in6*)AI->ai_addr)->sin6_addr, sizeof(struct in6_addr));
         }
 #else
@@ -236,7 +236,7 @@ errorClean(void)
     if (error_text) {
         int i;
 
-        for (i = ERR_NONE + 1; i < error_page_count; i++)
+        for (i = ERR_NONE + 1; i < error_page_count; ++i)
             safe_free(error_text[i]);
 
         safe_free(error_text);
@@ -258,7 +258,7 @@ errorFindHardText(err_type type)
 {
     int i;
 
-    for (i = 0; i < error_hard_text_count; i++)
+    for (i = 0; i < error_hard_text_count; ++i)
         if (error_hard_text[i].type == type)
             return error_hard_text[i].text;
 
@@ -378,11 +378,14 @@ bool strHdrAcptLangGetItem(const String &hdr, char *lang, int langLen, size_t &p
 
         if (!pos) {
             /* skip any initial whitespace. */
-            while (pos < hdr.size() && xisspace(hdr[pos])) pos++;
+            while (pos < hdr.size() && xisspace(hdr[pos]))
+                ++pos;
         } else {
             // IFF we terminated the tag on whitespace or ';' we need to skip to the next ',' or end of header.
-            while (pos < hdr.size() && hdr[pos] != ',') pos++;
-            if (hdr[pos] == ',') pos++;
+            while (pos < hdr.size() && hdr[pos] != ',')
+                ++pos;
+            if (hdr[pos] == ',')
+                ++pos;
         }
 
         /*
@@ -407,11 +410,12 @@ bool strHdrAcptLangGetItem(const String &hdr, char *lang, int langLen, size_t &p
                 if (*dt != '-' && *dt != '*' && (*dt < 'a' || *dt > 'z') )
                     invalid_byte = true;
                 else
-                    dt++; // move to next destination byte.
+                    ++dt; // move to next destination byte.
             }
-            pos++;
+            ++pos;
         }
-        *dt++ = '\0'; // nul-terminated the filename content string before system use.
+        *dt = '\0'; // nul-terminated the filename content string before system use.
+        ++dt;
 
         debugs(4, 9, HERE << "STATE: dt='" << dt << "', lang='" << lang << "', pos=" << pos << ", buf='" << ((pos < hdr.size()) ? hdr.substr(pos,hdr.size()) : "") << "'");
 
@@ -519,12 +523,12 @@ errorDynamicPageInfoDestroy(ErrorDynamicPageInfo * info)
 static int
 errorPageId(const char *page_name)
 {
-    for (int i = 0; i < ERR_MAX; i++) {
+    for (int i = 0; i < ERR_MAX; ++i) {
         if (strcmp(err_type_str[i], page_name) == 0)
             return i;
     }
 
-    for (size_t j = 0; j < ErrorDynamicPages.size(); j++) {
+    for (size_t j = 0; j < ErrorDynamicPages.size(); ++j) {
         if (strcmp(ErrorDynamicPages.items[j]->page_name, page_name) == 0)
             return j + ERR_MAX;
     }
@@ -993,7 +993,8 @@ ESIContext::addStackElement (ESIElement::Pointer element)
         flags.error = 1;
     } else {
         /* added ok, push onto the stack */
-        parserState.stack[parserState.stackdepth++] = element;
+        parserState.stack[parserState.stackdepth] = element;
+        ++parserState.stackdepth;
     }
 }
 
@@ -1024,27 +1025,33 @@ ESIContext::start(const char *el, const char **attr, size_t attrCount)
         position = localbuf + strlen (localbuf);
 
         for (i = 0; i < specifiedattcount && attr[i]; i += 2) {
-            *position++ = ' ';
+            *position = ' ';
+            ++position;
             /* TODO: handle thisNode gracefully */
             assert (xstrncpy (position, attr[i], sizeof(localbuf) + (position - localbuf)));
             position += strlen (position);
-            *position++ = '=';
-            *position++ = '\"';
+            *position = '=';
+            ++position;
+            *position = '\"';
+            ++position;
             const char *chPtr = attr[i + 1];
             char ch;
             while ((ch = *chPtr++) != '\0') {
                 if (ch == '\"') {
                     assert( xstrncpy(position, "&quot;", sizeof(localbuf) + (position-localbuf)) );
                     position += 6;
                 } else {
-                    *(position++) = ch;
+                    *position = ch;
+                    ++position;
                 }
             }
             position += strlen (position);
-            *position++ = '\"';
+            *position = '\"';
+            ++position;
         }
 
-        *position++ = '>';
+        *position = '>';
+        ++position;
         *position = '\0';
 
         addLiteral (localbuf, position - localbuf);
@@ -1134,7 +1141,8 @@ ESIContext::end(const char *el)
         localbuf[1] = '/';
         assert (xstrncpy (&localbuf[2], el, sizeof(localbuf) - 3));
         position = localbuf + strlen (localbuf);
-        *position++ = '>';
+        *position = '>';
+        ++position;
         *position = '\0';
         addLiteral (localbuf, position - localbuf);
         break;
@@ -1283,7 +1291,8 @@ ESIContext::parse()
     if (!parserState.stackdepth) {
         debugs(86, 5, "empty parser stack, inserting the top level node");
         assert (tree.getRaw());
-        parserState.stack[parserState.stackdepth++] = tree;
+        parserState.stack[parserState.stackdepth] = tree;
+        ++parserState.stackdepth;
     }
 
     if (rep && !parserState.inited())
@@ -56,8 +56,8 @@ void esi_startElementSAXFunc(void * ctx, const xmlChar * name, const xmlChar **
     xmlChar **tmp = (xmlChar **)atts;
 
     while (tmp && *tmp != NULL) {
-        count++;
-        tmp++;
+        ++count;
+        ++tmp;
     }
 
     // we increased on every key and value
@@ -485,7 +485,7 @@ Eui::Eui48::lookup(const Ip::Address &c)
     }
 
     /* Find MAC address from net table */
-    for (i = 0 ; i < NetTable->dwNumEntries ; i++) {
+    for (i = 0 ; i < NetTable->dwNumEntries ; ++i) {
         in_addr a;
         a.s_addr = NetTable->table[i].dwAddr;
         if (c == a && (NetTable->table[i].dwType > 2)) {
@@ -264,12 +264,15 @@ parse_header_token(external_acl_format *format, char *header, const _external_ac
 
     if (member) {
         /* Split in header and member */
-        *member++ = '\0';
+        *member = '\0';
+        ++member;
 
-        if (!xisalnum(*member))
-            format->separator = *member++;
-        else
+        if (!xisalnum(*member)) {
+            format->separator = *member;
+            ++member;
+        } else {
             format->separator = ',';
+        }
 
         format->member = xstrdup(member);
 
@@ -659,7 +662,7 @@ external_acl::add(ExternalACLEntry *anEntry)
     anEntry->def = this;
     hash_join(cache, anEntry);
     dlinkAdd(anEntry, &anEntry->lru, &lru_list);
-    cache_entries++;
+    ++cache_entries;
 }
 
 void
@@ -1333,7 +1336,8 @@ externalAclHandleReply(void *data, char *reply)
             value = strchr(token, '=');
 
             if (value) {
-                *value++ = '\0';	/* terminate the token, and move up to the value */
+                *value = '\0';	/* terminate the token, and move up to the value */
+                ++value;
 
                 if (state->def->quote == external_acl::QUOTE_METHOD_URL)
                     rfc1738_unescape(value);
@@ -97,7 +97,7 @@ fdUpdateBiggest(int fd, int opening)
     assert(!opening);
 
     while (Biggest_FD >= 0 && !fd_table[Biggest_FD].flags.open)
-        Biggest_FD--;
+        --Biggest_FD;
 }
 
 void
@@ -118,7 +118,7 @@ fd_close(int fd)
     Comm::SetSelect(fd, COMM_SELECT_WRITE, NULL, NULL, 0);
     F->flags.open = 0;
     fdUpdateBiggest(fd, 0);
-    Number_FD--;
+    --Number_FD;
     *F = fde();
 }
 
@@ -267,7 +267,7 @@ fd_open(int fd, unsigned int type, const char *desc)
     if (desc)
         xstrncpy(F->desc, desc, FD_DESC_SZ);
 
-    Number_FD++;
+    ++Number_FD;
 }
 
 void
@@ -299,7 +299,7 @@ fdDumpOpen(void)
     int i;
     fde *F;
 
-    for (i = 0; i < Squid_MaxFD; i++) {
+    for (i = 0; i < Squid_MaxFD; ++i) {
         F = &fd_table[i];
 
         if (!F->flags.open)
@@ -99,7 +99,7 @@ fde::DumpStats (StoreEntry *dumpEntry)
     storeAppendPrintf(dumpEntry, "---- ------ ---- -------- -------- --------------------- ------------------------------\n");
 #endif
 
-    for (i = 0; i < Squid_MaxFD; i++) {
+    for (i = 0; i < Squid_MaxFD; ++i) {
         fd_table[i].dumpStats(*dumpEntry, i);
     }
 }
@@ -123,6 +123,6 @@ fde::remoteAddr() const
 void
 fde::noteUse(PconnPool *pool)
 {
-    pconn.uses++;
+    ++ pconn.uses;
     pconn.pool = pool;
 }
@@ -90,7 +90,7 @@ FileMap::setBit(sfileno file_number)
 
     bitmap[file_number >> LONG_BIT_SHIFT] |= bitmask;
 
-    usedSlots_++;
+    ++usedSlots_;
 
     return file_number;
 }
@@ -107,7 +107,7 @@ FileMap::clearBit(sfileno file_number)
 {
     unsigned long bitmask = (1L << (file_number & LONG_BIT_MASK));
     bitmap[file_number >> LONG_BIT_SHIFT] &= ~bitmask;
-    usedSlots_--;
+    --usedSlots_;
 }
 
 bool
@@ -135,14 +135,14 @@ FileMap::allocate(sfileno suggestion)
 
     word = suggestion >> LONG_BIT_SHIFT;
 
-    for (unsigned int count = 0; count < nwords; count++) {
+    for (unsigned int count = 0; count < nwords; ++count) {
         if (bitmap[word] != ALL_ONES)
             break;
 
         word = (word + 1) % nwords;
     }
 
-    for (unsigned char bit = 0; bit < BITS_IN_A_LONG; bit++) {
+    for (unsigned char bit = 0; bit < BITS_IN_A_LONG; ++bit) {
         suggestion = ((unsigned long) word << LONG_BIT_SHIFT) | bit;
 
         if (!testBit(suggestion)) {
@@ -262,32 +262,40 @@ log_quoted_string(const char *str, char *out)
             break;
 
         case '\r':
-            *p++ = '\\';
-            *p++ = 'r';
-            str++;
+            *p = '\\';
+            ++p;
+            *p = 'r';
+            ++p;
+            ++str;
             break;
 
         case '\n':
-            *p++ = '\\';
-            *p++ = 'n';
-            str++;
+            *p = '\\';
+            ++p;
+            *p = 'n';
+            ++p;
+            ++str;
             break;
 
         case '\t':
-            *p++ = '\\';
-            *p++ = 't';
-            str++;
+            *p = '\\';
+            ++p;
+            *p = 't';
+            ++p;
+            ++str;
             break;
 
         default:
-            *p++ = '\\';
-            *p++ = *str;
-            str++;
+            *p = '\\';
+            ++p;
+            *p = *str;
+            ++p;
+            ++str;
             break;
         }
     }
 
-    *p++ = '\0';
+    *p = '\0';
 }
 
 void
@@ -46,21 +46,29 @@ username_quote(const char *header)
 
     while ((c = *(const unsigned char *) header++) != '\0') {
         if (c == '\r') {
-            *buf_cursor++ = '\\';
-            *buf_cursor++ = 'r';
+            *buf_cursor = '\\';
+            ++buf_cursor;
+            *buf_cursor = 'r';
+            ++buf_cursor;
         } else if (c == '\n') {
-            *buf_cursor++ = '\\';
-            *buf_cursor++ = 'n';
+            *buf_cursor = '\\';
+            ++buf_cursor;
+            *buf_cursor = 'n';
+            ++buf_cursor;
         } else if (c <= 0x1F
                    || c >= 0x7F
                    || c == '%'
                    || c == ' ') {
-            *buf_cursor++ = '%';
+            *buf_cursor = '%';
+            ++buf_cursor;
             i = c * 2;
-            *buf_cursor++ = c2x[i];
-            *buf_cursor++ = c2x[i + 1];
+            *buf_cursor = c2x[i];
+            ++buf_cursor;
+            *buf_cursor = c2x[i + 1];
+            ++buf_cursor;
         } else {
-            *buf_cursor++ = (char) c;
+            *buf_cursor = (char) c;
+            ++buf_cursor;
         }
     }
 
@@ -108,11 +116,15 @@ Format::QuoteMimeBlob(const char *header)
     while ((c = *(const unsigned char *) header++) != '\0') {
 #if !OLD_LOG_MIME
         if (c == '\r') {
-            *buf_cursor++ = '\\';
-            *buf_cursor++ = 'r';
+            *buf_cursor = '\\';
+            ++buf_cursor;
+            *buf_cursor = 'r';
+            ++buf_cursor;
         } else if (c == '\n') {
-            *buf_cursor++ = '\\';
-            *buf_cursor++ = 'n';
+            *buf_cursor = '\\';
+            ++buf_cursor;
+            *buf_cursor = 'n';
+            ++buf_cursor;
         } else
 #endif
             if (c <= 0x1F
@@ -135,19 +147,25 @@ Format::QuoteMimeBlob(const char *header)
 #endif
                     || c == '['
                     || c == ']') {
-                *buf_cursor++ = '%';
+                *buf_cursor = '%';
+                ++buf_cursor;
                 i = c * 2;
-                *buf_cursor++ = c2x[i];
-                *buf_cursor++ = c2x[i + 1];
+                *buf_cursor = c2x[i];
+                ++buf_cursor;
+                *buf_cursor = c2x[i + 1];
+                ++buf_cursor;
 #if !OLD_LOG_MIME
 
             } else if (c == '\\') {
-                *buf_cursor++ = '\\';
-                *buf_cursor++ = '\\';
+                *buf_cursor = '\\';
+                ++buf_cursor;
+                *buf_cursor = '\\';
+                ++buf_cursor;
 #endif
 
             } else {
-                *buf_cursor++ = (char) c;
+                *buf_cursor = (char) c;
+                ++buf_cursor;
             }
     }
 
@@ -220,7 +220,7 @@ Format::Token::Init()
 const char *
 Format::Token::scanForToken(TokenTableEntry const table[], const char *cur)
 {
-    for (TokenTableEntry const *lte = table; lte->configTag != NULL; lte++) {
+    for (TokenTableEntry const *lte = table; lte->configTag != NULL; ++lte) {
         debugs(46, 8, HERE << "compare tokens '" << lte->configTag << "' with '" << cur << "'");
         if (strncmp(lte->configTag, cur, strlen(lte->configTag)) == 0) {
             type = lte->tokenType;
@@ -278,8 +278,8 @@ Format::Token::parse(const char *def, Quoting *quoting)
                 break;
             }
 
-            cur++;
-            l--;
+            ++cur;
+            --l;
         }
 
         goto done;
@@ -288,29 +288,29 @@ Format::Token::parse(const char *def, Quoting *quoting)
     if (!*cur)
         goto done;
 
-    cur++;
+    ++cur;
 
     // select quoting style for his particular token
     switch (*cur) {
 
     case '"':
         quote = LOG_QUOTE_QUOTES;
-        cur++;
+        ++cur;
         break;
 
     case '\'':
         quote = LOG_QUOTE_RAW;
-        cur++;
+        ++cur;
         break;
 
     case '[':
         quote = LOG_QUOTE_MIMEBLOB;
-        cur++;
+        ++cur;
         break;
 
     case '#':
         quote = LOG_QUOTE_URL;
-        cur++;
+        ++cur;
         break;
 
     default:
@@ -320,12 +320,12 @@ Format::Token::parse(const char *def, Quoting *quoting)
 
     if (*cur == '-') {
         left = 1;
-        cur++;
+        ++cur;
     }
 
     if (*cur == '0') {
         zero = 1;
-        cur++;
+        ++cur;
     }
 
     char *endp;
@@ -341,22 +341,22 @@ Format::Token::parse(const char *def, Quoting *quoting)
 
     if (*cur == '{') {
         char *cp;
-        cur++;
+        ++cur;
         l = strcspn(cur, "}");
         cp = (char *)xmalloc(l + 1);
         xstrncpy(cp, cur, l + 1);
         data.string = cp;
         cur += l;
 
         if (*cur == '}')
-            cur++;
+            ++cur;
     }
 
     type = LFT_NONE;
 
     // Scan each registered token namespace
     debugs(46, 9, HERE << "check for token in " << TheConfig.tokens.size() << " namespaces.");
-    for (std::list<TokenNamespace>::const_iterator itr = TheConfig.tokens.begin(); itr != TheConfig.tokens.end(); itr++) {
+    for (std::list<TokenNamespace>::const_iterator itr = TheConfig.tokens.begin(); itr != TheConfig.tokens.end(); ++itr) {
         debugs(46, 7, HERE << "check for possible " << itr->prefix << ":: token");
         const size_t len = itr->prefix.size();
         if (itr->prefix.cmp(cur, len) == 0 && cur[len] == ':' && cur[len+1] == ':') {
@@ -401,7 +401,7 @@ Format::Token::parse(const char *def, Quoting *quoting)
 
     if (*cur == ' ') {
         space = 1;
-        cur++;
+        ++cur;
     }
 
 done:
@@ -429,12 +429,15 @@ Format::Token::parse(const char *def, Quoting *quoting)
             char *cp = strchr(header, ':');
 
             if (cp) {
-                *cp++ = '\0';
+                *cp = '\0';
+                ++cp;
 
-                if (*cp == ',' || *cp == ';' || *cp == ':')
-                    data.header.separator = *cp++;
-                else
+                if (*cp == ',' || *cp == ';' || *cp == ':') {
+                    data.header.separator = *cp;
+                    ++cp;
+                } else {
                     data.header.separator = ',';
+                }
 
                 data.header.element = cp;
 
@@ -514,7 +517,7 @@ Format::Token::parse(const char *def, Quoting *quoting)
             int i;
             divisor = 1000000;
 
-            for (i = widthMax; i > 1; i--)
+            for (i = widthMax; i > 1; --i)
                 divisor /= 10;
 
             if (!divisor)
@@ -953,7 +953,7 @@ FwdState::connectStart()
             if (!serverConn->getPeer())
                 serverConn->peerType = HIER_DIRECT;
 #endif
-            n_tries++;
+            ++n_tries;
             request->flags.pinned = 1;
             if (pinned_connection->pinnedAuth())
                 request->flags.auth = 1;
@@ -998,10 +998,10 @@ FwdState::connectStart()
         serverConn = temp;
         flags.connected_okay = true;
         debugs(17, 3, HERE << "reusing pconn " << serverConnection());
-        n_tries++;
+        ++n_tries;
 
         if (!serverConnection()->getPeer())
-            origin_tries++;
+            ++origin_tries;
 
         comm_add_close_handler(serverConnection()->fd, fwdServerClosedWrapper, this);
 
@@ -1108,7 +1108,7 @@ FwdState::dispatch()
 #endif
 
     if (serverConnection()->getPeer() != NULL) {
-        serverConnection()->getPeer()->stats.fetches++;
+        ++ serverConnection()->getPeer()->stats.fetches;
         request->peer_login = serverConnection()->getPeer()->login;
         request->peer_domain = serverConnection()->getPeer()->domain;
         httpStart(this);
@@ -1238,19 +1238,19 @@ fwdStats(StoreEntry * s)
     int j;
     storeAppendPrintf(s, "Status");
 
-    for (j = 0; j <= MAX_FWD_STATS_IDX; j++) {
-        storeAppendPrintf(s, "\ttry#%d", j + 1);
+    for (j = 1; j < MAX_FWD_STATS_IDX; ++j) {
+        storeAppendPrintf(s, "\ttry#%d", j);
     }
 
     storeAppendPrintf(s, "\n");
 
-    for (i = 0; i <= (int) HTTP_INVALID_HEADER; i++) {
+    for (i = 0; i <= (int) HTTP_INVALID_HEADER; ++i) {
         if (FwdReplyCodes[0][i] == 0)
             continue;
 
         storeAppendPrintf(s, "%3d", i);
 
-        for (j = 0; j <= MAX_FWD_STATS_IDX; j++) {
+        for (j = 0; j <= MAX_FWD_STATS_IDX; ++j) {
             storeAppendPrintf(s, "\t%d", FwdReplyCodes[j][i]);
         }
 
@@ -1326,7 +1326,7 @@ FwdState::logReplyStatus(int tries, http_status status)
     if (tries > MAX_FWD_STATS_IDX)
         tries = MAX_FWD_STATS_IDX;
 
-    FwdReplyCodes[tries][status]++;
+    ++ FwdReplyCodes[tries][status];
 }
 
 /**** PRIVATE NON-MEMBER FUNCTIONS ********************************************/
@@ -175,7 +175,7 @@ fqdncacheRelease(fqdncache_entry * f)
     int k;
     hash_remove_link(fqdn_table, (hash_link *) f);
 
-    for (k = 0; k < (int) f->name_count; k++)
+    for (k = 0; k < (int) f->name_count; ++k)
         safe_free(f->names[k]);
 
     debugs(35, 5, "fqdncacheRelease: Released FQDN record for '" << hashKeyStr(&f->hash) << "'.");
@@ -247,7 +247,7 @@ fqdncache_purgelru(void *notused)
 
         fqdncacheRelease(f);
 
-        removed++;
+        ++removed;
     }
 
     debugs(35, 9, "fqdncache_purgelru: removed " << removed << " entries");
@@ -440,7 +440,7 @@ fqdncacheParse(fqdncache_entry *f, const rfc1035_rr * answers, int nr, const cha
     debugs(35, 3, "fqdncacheParse: " << nr << " answers for '" << name << "'");
     assert(answers);
 
-    for (k = 0; k < nr; k++) {
+    for (k = 0; k < nr; ++k) {
         if (answers[k]._class != RFC1035_CLASS_IN)
             continue;
 
@@ -455,7 +455,8 @@ fqdncacheParse(fqdncache_entry *f, const rfc1035_rr * answers, int nr, const cha
                 continue;
             }
 
-            f->names[f->name_count++] = xstrdup(answers[k].rdata);
+            f->names[f->name_count] = xstrdup(answers[k].rdata);
+            ++ f->name_count;
         } else if (answers[k].type != RFC1035_TYPE_CNAME)
             continue;
 
@@ -535,7 +536,7 @@ fqdncache_nbgethostbyaddr(const Ip::Address &addr, FQDNH * handler, void *handle
     generic_cbdata *c;
     addr.NtoA(name,MAX_IPSTRLEN);
     debugs(35, 4, "fqdncache_nbgethostbyaddr: Name '" << name << "'.");
-    FqdncacheStats.requests++;
+    ++FqdncacheStats.requests;
 
     if (name[0] == '\0') {
         debugs(35, 4, "fqdncache_nbgethostbyaddr: Invalid name!");
@@ -559,9 +560,9 @@ fqdncache_nbgethostbyaddr(const Ip::Address &addr, FQDNH * handler, void *handle
         debugs(35, 4, "fqdncache_nbgethostbyaddr: HIT for '" << name << "'");
 
         if (f->flags.negcached)
-            FqdncacheStats.negative_hits++;
+            ++ FqdncacheStats.negative_hits;
         else
-            FqdncacheStats.hits++;
+            ++ FqdncacheStats.hits;
 
         f->handler = handler;
 
@@ -573,7 +574,7 @@ fqdncache_nbgethostbyaddr(const Ip::Address &addr, FQDNH * handler, void *handle
     }
 
     debugs(35, 5, "fqdncache_nbgethostbyaddr: MISS for '" << name << "'");
-    FqdncacheStats.misses++;
+    ++ FqdncacheStats.misses;
     f = fqdncacheCreateEntry(name);
     f->handler = handler;
     f->handlerData = cbdataReference(handlerData);
@@ -654,7 +655,7 @@ fqdncache_gethostbyaddr(const Ip::Address &addr, int flags)
     }
 
     addr.NtoA(name,MAX_IPSTRLEN);
-    FqdncacheStats.requests++;
+    ++ FqdncacheStats.requests;
     f = fqdncache_get(name);
 
     if (NULL == f) {
@@ -663,19 +664,19 @@ fqdncache_gethostbyaddr(const Ip::Address &addr, int flags)
         fqdncacheRelease(f);
         f = NULL;
     } else if (f->flags.negcached) {
-        FqdncacheStats.negative_hits++;
+        ++ FqdncacheStats.negative_hits;
         // ignore f->error_message: the caller just checks FQDN cache presence
         return NULL;
     } else {
-        FqdncacheStats.hits++;
+        ++ FqdncacheStats.hits;
         f->lastref = squid_curtime;
         // ignore f->error_message: the caller just checks FQDN cache presence
         return f->names[0];
     }
 
     /* no entry [any more] */
 
-    FqdncacheStats.misses++;
+    ++ FqdncacheStats.misses;
 
     if (flags & FQDN_LOOKUP_IF_MISS) {
         fqdncache_nbgethostbyaddr(addr, NULL, NULL);
@@ -736,7 +737,7 @@ fqdnStats(StoreEntry * sentry)
                           ttl,
                           (int) f->name_count);
 
-        for (k = 0; k < (int) f->name_count; k++)
+        for (k = 0; k < (int) f->name_count; ++k)
             storeAppendPrintf(sentry, " %s", f->names[k]);
 
         storeAppendPrintf(sentry, "\n");
@@ -775,7 +776,7 @@ static void
 fqdncacheUnlockEntry(fqdncache_entry * f)
 {
     assert(f->locks > 0);
-    f->locks--;
+    -- f->locks;
 
     if (fqdncacheExpiredEntry(f))
         fqdncacheRelease(f);
@@ -788,7 +789,7 @@ fqdncacheFreeEntry(void *data)
     fqdncache_entry *f = (fqdncache_entry *)data;
     int k;
 
-    for (k = 0; k < (int) f->name_count; k++)
+    for (k = 0; k < (int) f->name_count; ++k)
         safe_free(f->names[k]);
 
     safe_free(f->hash.key);
@@ -857,7 +858,7 @@ fqdncacheAddEntryFromHosts(char *addr, wordlist * hostnames)
     while (hostnames) {
         fce->names[j] = xstrdup(hostnames->key);
         Tolower(fce->names[j]);
-        j++;
+        ++j;
         hostnames = hostnames->next;
 
         if (j >= FQDN_MAX_NAMES)
@@ -96,7 +96,7 @@ storeCossDirSwapLogFile(SwapDir * sd, const char *ext)
         while (strlen(pathtmp) && pathtmp[strlen(pathtmp) - 1] == '.')
             pathtmp[strlen(pathtmp) - 1] = '\0';
 
-        for (pathtmp2 = pathtmp; *pathtmp2 == '.'; pathtmp2++);
+        for (pathtmp2 = pathtmp; *pathtmp2 == '.'; ++pathtmp2);
         snprintf(path, MAXPATHLEN - 64, Config.Log.swap, pathtmp2);
 
         if (strncmp(path, Config.Log.swap, MAXPATHLEN - 64) == 0) {
@@ -174,7 +174,7 @@ CossSwapDir::readCompleted(const char *buf, int len, int errflag, RefCount<ReadR
     cstate->flags.reading = 0;
 
     if (errflag) {
-        StoreFScoss::GetInstance().stats.read.fail++;
+        ++ StoreFScoss::GetInstance().stats.read.fail;
 
         if (errflag > 0) {
             errno = errflag;
@@ -185,7 +185,7 @@ CossSwapDir::readCompleted(const char *buf, int len, int errflag, RefCount<ReadR
 
         rlen = -1;
     } else {
-        StoreFScoss::GetInstance().stats.read.success++;
+        ++ StoreFScoss::GetInstance().stats.read.success;
 
         if (cstate->readbuffer == NULL) {
             cstate->readbuffer = (char *)xmalloc(cstate->st_size);
@@ -217,17 +217,17 @@ CossSwapDir::writeCompleted(int errflag, size_t len, RefCount<WriteRequest> writ
 
 
     if (errflag) {
-        StoreFScoss::GetInstance().stats.stripe_write.fail++;
+        ++ StoreFScoss::GetInstance().stats.stripe_write.fail;
         debugs(79, 1, "storeCossWriteMemBufDone: got failure (" << errflag << ")");
         debugs(79, 1, "size=" << cossWrite->membuf->diskend - cossWrite->membuf->diskstart);
     } else {
-        StoreFScoss::GetInstance().stats.stripe_write.success++;
+        ++ StoreFScoss::GetInstance().stats.stripe_write.success;
     }
 
 
     dlinkDelete(&cossWrite->membuf->node, &membufs);
     cbdataFree(cossWrite->membuf);
-    StoreFScoss::GetInstance().stats.stripes--;
+    -- StoreFScoss::GetInstance().stats.stripes;
 }
 
 void
@@ -368,7 +368,7 @@ storeCossRebuildComplete(void *data)
     RebuildState *rb = (RebuildState *)data;
     CossSwapDir *sd = rb->sd;
     sd->startMembuf();
-    StoreController::store_dirs_rebuilding--;
+    -- StoreController::store_dirs_rebuilding;
     storeCossDirCloseTmpSwapLog(rb->sd);
     storeRebuildComplete(&rb->counts);
     cbdataFree(rb);
@@ -385,7 +385,7 @@ storeCossRebuildFromSwapLog(void *data)
     assert(rb != NULL);
     /* load a number of objects per invocation */
 
-    for (int aCount = 0; aCount < rb->speed; aCount++) {
+    for (int aCount = 0; aCount < rb->speed; ++aCount) {
         if (fread(&s, ss, 1, rb->log) != 1) {
             debugs(47, 1, "Done reading " << rb->sd->path << " swaplog (" << rb->n_read << " entries)");
             fclose(rb->log);
@@ -394,7 +394,7 @@ storeCossRebuildFromSwapLog(void *data)
             return;
         }
 
-        rb->n_read++;
+        ++ rb->n_read;
 
         if (s.op <= SWAP_LOG_NOP)
             continue;
@@ -430,8 +430,8 @@ storeCossRebuildFromSwapLog(void *data)
                 e->release();
                 /* Fake an unlink here, this is a bad hack :( */
                 storeCossRemove(rb->sd, e);
-                rb->counts.objcount--;
-                rb->counts.cancelcount++;
+                -- rb->counts.objcount;
+                ++ rb->counts.cancelcount;
             }
             continue;
         } else {
@@ -441,7 +441,7 @@ storeCossRebuildFromSwapLog(void *data)
                     (int) x)
                 debugs(47, 1, "WARNING: " << rb->counts.bad_log_op << " invalid swap log entries found");
 
-            rb->counts.invalid++;
+            ++ rb->counts.invalid;
 
             continue;
         }
@@ -456,7 +456,7 @@ storeCossRebuildFromSwapLog(void *data)
         }
 
         if (EBIT_TEST(s.flags, KEY_PRIVATE)) {
-            rb->counts.badflags++;
+            ++ rb->counts.badflags;
             continue;
         }
 
@@ -466,11 +466,11 @@ storeCossRebuildFromSwapLog(void *data)
         if (e) {
             /* key already exists, current entry is newer */
             /* keep old, ignore new */
-            rb->counts.dupcount++;
+            ++ rb->counts.dupcount;
             continue;
         }
 
-        rb->counts.objcount++;
+        ++ rb->counts.objcount;
 
         e = rb->sd->addDiskRestore(s.key,
                                    s.swap_filen,
@@ -557,7 +557,7 @@ storeCossDirRebuild(CossSwapDir * sd)
     fp = storeCossDirOpenTmpSwapLog(sd, &clean, &zero);
     debugs(47, 1, "Rebuilding COSS storage in " << sd->path << " (" << (clean ? "CLEAN" : "DIRTY") << ")");
     rb->log = fp;
-    StoreController::store_dirs_rebuilding++;
+    ++ StoreController::store_dirs_rebuilding;
 
     if (!clean || fp == NULL) {
         /* COSS cannot yet rebuild from a dirty state. If the log
@@ -941,7 +941,7 @@ CossSwapDir::~CossSwapDir()
 
     closeLog();
 
-    n_coss_dirs--;
+    --n_coss_dirs;
 
     safe_free(ioModule);
 
@@ -1106,7 +1106,7 @@ CossSwapDir::optionBlockSizeParse(const char *option, const char *value, int rec
     int check = blksz;
 
     while (check > 1) {
-        nbits++;
+        ++nbits;
         check >>= 1;
     }
 
@@ -71,10 +71,10 @@ CossSwapDir::allocate(const StoreEntry * e, int which)
 
     if (which == COSS_ALLOC_REALLOC) {
         checkf = e->swap_filen;
-        StoreFScoss::GetInstance().stats.alloc.realloc++;
+        ++ StoreFScoss::GetInstance().stats.alloc.realloc;
     } else {
         checkf = -1;
-        StoreFScoss::GetInstance().stats.alloc.alloc++;
+        ++ StoreFScoss::GetInstance().stats.alloc.alloc;
     }
 
     if (e->swap_file_sz > 0)
@@ -88,7 +88,7 @@ CossSwapDir::allocate(const StoreEntry * e, int which)
          * tried to allocate past the end of the disk, so wrap
          * back to the beginning
          */
-        StoreFScoss::GetInstance().stats.disk_overflows++;
+        ++ StoreFScoss::GetInstance().stats.disk_overflows;
         current_membuf->flags.full = 1;
         current_membuf->diskend = current_offset;
         current_membuf->maybeWrite(this);
@@ -103,7 +103,7 @@ CossSwapDir::allocate(const StoreEntry * e, int which)
         /*
          * Skip the blank space at the end of the stripe. start over.
          */
-        StoreFScoss::GetInstance().stats.stripe_overflows++;
+        ++ StoreFScoss::GetInstance().stats.stripe_overflows;
         current_membuf->flags.full = 1;
         current_offset = current_membuf->diskend;
         current_membuf->maybeWrite(this);
@@ -123,7 +123,7 @@ CossSwapDir::allocate(const StoreEntry * e, int which)
         current_offset = ((current_offset + blksz_mask) >> blksz_bits ) << blksz_bits;
         return storeCossDiskOffsetToFileno(retofs);
     } else {
-        StoreFScoss::GetInstance().stats.alloc.collisions++;
+        ++ StoreFScoss::GetInstance().stats.alloc.collisions;
         debugs(79, 3, "CossSwapDir::allocate: Collision");
         return -1;
     }
@@ -144,8 +144,8 @@ CossSwapDir::unlink(StoreEntry & e)
         cur_size -= fs.blksize * sizeInBlocks(e.swap_file_sz);
         --n_disk_objects;
     }
-    StoreFScoss::GetInstance().stats.unlink.ops++;
-    StoreFScoss::GetInstance().stats.unlink.success++;
+    ++ StoreFScoss::GetInstance().stats.unlink.ops;
+    ++ StoreFScoss::GetInstance().stats.unlink.success;
     storeCossRemove(this, &e);
 }
 
@@ -163,7 +163,7 @@ CossSwapDir::createStoreIO(StoreEntry &e, StoreIOState::STFNCB * file_callback,
      * the squid code is broken
      */
     assert(e.mem_obj->object_sz != -1);
-    StoreFScoss::GetInstance().stats.create.ops++;
+    ++ StoreFScoss::GetInstance().stats.create.ops;
 
     /*
      * this one is kinda strange - Eric called allocate(), then
@@ -194,7 +194,7 @@ CossSwapDir::createStoreIO(StoreEntry &e, StoreIOState::STFNCB * file_callback,
     storeCossAdd(this, &e);
 
     cstate->lockMemBuf();
-    StoreFScoss::GetInstance().stats.create.success++;
+    ++ StoreFScoss::GetInstance().stats.create.success;
     return sio;
 }
 
@@ -207,7 +207,7 @@ CossSwapDir::openStoreIO(StoreEntry & e, StoreIOState::STFNCB * file_callback,
     sfileno f = e.swap_filen;
 
     debugs(79, 3, "storeCossOpen: offset " << f);
-    StoreFScoss::GetInstance().stats.open.ops++;
+    ++ StoreFScoss::GetInstance().stats.open.ops;
 
     StoreIOState::Pointer sio = new CossState (this);
     cstate = dynamic_cast<CossState *>(sio.getRaw());
@@ -232,14 +232,14 @@ CossSwapDir::openStoreIO(StoreEntry & e, StoreIOState::STFNCB * file_callback,
     if (p) {
         cstate->readbuffer = (char *)xmalloc(cstate->st_size);
         memcpy(cstate->readbuffer, p, cstate->st_size);
-        StoreFScoss::GetInstance().stats.open_mem_hits++;
+        ++ StoreFScoss::GetInstance().stats.open_mem_hits;
     } else {
         /* Do the allocation */
         /* this is the first time we've been called on a new sio
          * read the whole object into memory, then return the
          * requested amount
          */
-        StoreFScoss::GetInstance().stats.open_mem_misses++;
+        ++ StoreFScoss::GetInstance().stats.open_mem_misses;
         /*
          * This bit of code actually does the LRU disk thing - we realloc
          * a place for the object here, and the file_read() reads the object
@@ -251,8 +251,8 @@ CossSwapDir::openStoreIO(StoreEntry & e, StoreIOState::STFNCB * file_callback,
 
         if (sio->swap_filen == -1) {
             /* We have to clean up neatly .. */
-            StoreFScoss::GetInstance().stats.open.fail++;
-            numcollisions++;
+            ++ StoreFScoss::GetInstance().stats.open.fail;
+            ++numcollisions;
             debugs(79, 2, "storeCossOpen: Reallocation of " << e.swap_dirn << "/" << e.swap_filen << " failed");
             /* XXX XXX XXX Will squid call storeUnlink for this object? */
             return NULL;
@@ -281,7 +281,7 @@ CossSwapDir::openStoreIO(StoreEntry & e, StoreIOState::STFNCB * file_callback,
          	 */
     }
 
-    StoreFScoss::GetInstance().stats.open.success++;
+    ++ StoreFScoss::GetInstance().stats.open.success;
     return sio;
 }
 
@@ -291,8 +291,8 @@ CossState::close(int)
 {
     debugs(79, 3, "storeCossClose: offset " << swap_filen);
 
-    StoreFScoss::GetInstance().stats.close.ops++;
-    StoreFScoss::GetInstance().stats.close.success++;
+    ++ StoreFScoss::GetInstance().stats.close.ops;
+    ++ StoreFScoss::GetInstance().stats.close.success;
     SD->storeCossMemBufUnlock(this);
     doCallback(0);
 }
@@ -303,7 +303,7 @@ CossState::read_(char *buf, size_t size, off_t offset, STRCB * callback, void *c
     char *p;
     CossSwapDir *SD = (CossSwapDir *)INDEXSD(swap_dirn);
 
-    StoreFScoss::GetInstance().stats.read.ops++;
+    ++ StoreFScoss::GetInstance().stats.read.ops;
     assert(read.callback == NULL);
     assert(read.callback_data == NULL);
     read.callback = callback;
@@ -348,7 +348,7 @@ CossState::write(char const *buf, size_t size, off_t offset, FREE * free_func)
      * the squid code is broken
      */
     assert(e->mem_obj->object_sz != -1);
-    StoreFScoss::GetInstance().stats.write.ops++;
+    ++ StoreFScoss::GetInstance().stats.write.ops;
 
     debugs(79, 3, "storeCossWrite: offset " << offset_ << ", len " << (unsigned long int) size);
     diskoffset = SD->storeCossFilenoToDiskOffset(swap_filen) + offset_;
@@ -361,7 +361,7 @@ CossState::write(char const *buf, size_t size, off_t offset, FREE * free_func)
     if (free_func)
         (free_func) ((char *)buf);
 
-    StoreFScoss::GetInstance().stats.write.success++;
+    ++ StoreFScoss::GetInstance().stats.write.success;
 }
 
 off_t
@@ -484,7 +484,7 @@ CossSwapDir::storeCossMemBufUnlock(StoreIOState::Pointer sio)
 
     debugs(79, 3, "storeCossMemBufUnlock: unlocking " << t << ", lockcount " << t->lockcount);
 
-    t->lockcount--;
+    -- t->lockcount;
 
     cstate->locked_membuf = NULL;
 
@@ -542,7 +542,7 @@ CossMemBuf::maybeWrite(CossSwapDir * SD)
 void
 CossMemBuf::write(CossSwapDir * SD)
 {
-    StoreFScoss::GetInstance().stats.stripe_write.ops++;
+    ++ StoreFScoss::GetInstance().stats.stripe_write.ops;
     debugs(79, 3, "CossMemBuf::write: offset " << diskstart << ", len " << (diskend - diskstart));
     flags.writing = 1;
     /* XXX Remember that diskstart/diskend are block offsets! */
@@ -594,15 +594,15 @@ CossSwapDir::createMemBuf(off_t start, sfileno curfn, int *collision)
 
         if ((o >= (off_t)newmb->diskstart) && (o < (off_t)newmb->diskend)) {
             e->release();
-            numreleased++;
+            ++numreleased;
         } else
             break;
     }
 
     if (numreleased > 0)
         debugs(79, 3, "CossSwapDir::createMemBuf: this allocation released " << numreleased << " storeEntries");
 
-    StoreFScoss::GetInstance().stats.stripes++;
+    ++ StoreFScoss::GetInstance().stats.stripes;
 
     return newmb;
 }
@@ -143,15 +143,15 @@ Rock::Rebuild::doOneEntry()
     if (buf.contentSize() < static_cast<mb_size_t>(sizeof(header))) {
         debugs(47, DBG_IMPORTANT, "WARNING: cache_dir[" << sd->index << "]: " <<
                "Ignoring truncated cache entry meta data at " << dbOffset);
-        counts.invalid++;
+        ++counts.invalid;
         return;
     }
     memcpy(&header, buf.content(), sizeof(header));
 
     if (!header.sane()) {
         debugs(47, DBG_IMPORTANT, "WARNING: cache_dir[" << sd->index << "]: " <<
                "Ignoring malformed cache entry meta data at " << dbOffset);
-        counts.invalid++;
+        ++counts.invalid;
         return;
     }
     buf.consume(sizeof(header)); // optimize to avoid memmove()
@@ -161,7 +161,7 @@ Rock::Rebuild::doOneEntry()
     if (!storeRebuildParseEntry(buf, loadedE, key, counts, header.payloadSize)) {
         // skip empty slots
         if (loadedE.swap_filen > 0 || loadedE.swap_file_sz > 0) {
-            counts.invalid++;
+            ++counts.invalid;
             //sd->unlink(filen); leave garbage on disk, it should not hurt
         }
         return;
@@ -171,7 +171,7 @@ Rock::Rebuild::doOneEntry()
     if (!storeRebuildKeepEntry(loadedE, key, counts))
         return;
 
-    counts.objcount++;
+    ++counts.objcount;
     // loadedE->dump(5);
 
     sd->addEntry(filen, header, loadedE);
@@ -395,7 +395,7 @@ UFSSwapDir::maintain()
         if (!e)
             break;		/* no more objects */
 
-        removed++;
+        ++removed;
 
         e->release();
     }
@@ -557,7 +557,7 @@ UFSSwapDir::verifyCacheDirs()
     if (!pathIsDirectory(path))
         return true;
 
-    for (int j = 0; j < l1; j++) {
+    for (int j = 0; j < l1; ++j) {
         char const *aPath = swapSubDir(j);
 
         if (!pathIsDirectory(aPath))
@@ -572,7 +572,7 @@ UFSSwapDir::createSwapSubDirs()
 {
     LOCAL_ARRAY(char, name, MAXPATHLEN);
 
-    for (int i = 0; i < l1; i++) {
+    for (int i = 0; i < l1; ++i) {
         snprintf(name, MAXPATHLEN, "%s/%02X", path, i);
 
         int should_exist;
@@ -584,7 +584,7 @@ UFSSwapDir::createSwapSubDirs()
 
         debugs(47, 1, "Making directories in " << name);
 
-        for (int k = 0; k < l2; k++) {
+        for (int k = 0; k < l2; ++k) {
             snprintf(name, MAXPATHLEN, "%s/%02X/%02X", path, i, k);
             createDirectory(name, should_exist);
         }
@@ -609,7 +609,7 @@ UFSSwapDir::logFile(char const *ext) const
         while (strlen(pathtmp) && pathtmp[strlen(pathtmp) - 1] == '.')
             pathtmp[strlen(pathtmp) - 1] = '\0';
 
-        for (pathtmp2 = pathtmp; *pathtmp2 == '.'; pathtmp2++);
+        for (pathtmp2 = pathtmp; *pathtmp2 == '.'; ++pathtmp2);
         snprintf(lpath, MAXPATHLEN - 64, Config.Log.swap, pathtmp2);
 
         if (strncmp(lpath, Config.Log.swap, MAXPATHLEN - 64) == 0) {
@@ -1145,7 +1145,8 @@ UFSSwapDir::DirClean(int swap_index)
                 if (UFSSwapDir::FilenoBelongsHere(fn, D0, D1, D2))
                     continue;
 
-        files[k++] = swapfileno;
+        files[k] = swapfileno;
+        ++k;
     }
 
     closedir(dir_pointer);
@@ -1158,7 +1159,7 @@ UFSSwapDir::DirClean(int swap_index)
     if (k > 10)
         k = 10;
 
-    for (n = 0; n < k; n++) {
+    for (n = 0; n < k; ++n) {
         debugs(36, 3, "storeDirClean: Cleaning file "<< std::setfill('0') << std::hex << std::uppercase << std::setw(8) << files[n]);
         snprintf(p2, MAXPATHLEN + 1, "%s/%08X", p1, files[n]);
         safeunlink(p2, 0);
@@ -1190,7 +1191,7 @@ UFSSwapDir::CleanEvent(void *unused)
          */
         UFSDirToGlobalDirMapping = (int *)xcalloc(NumberOfUFSDirs, sizeof(*UFSDirToGlobalDirMapping));
 
-        for (i = 0, n = 0; i < Config.cacheSwap.n_configured; i++) {
+        for (i = 0, n = 0; i < Config.cacheSwap.n_configured; ++i) {
             /* This is bogus, the controller should just clean each instance once */
             sd = dynamic_cast <SwapDir *>(INDEXSD(i));
 
@@ -1201,7 +1202,8 @@ UFSSwapDir::CleanEvent(void *unused)
 
             assert (usd);
 
-            UFSDirToGlobalDirMapping[n++] = i;
+            UFSDirToGlobalDirMapping[n] = i;
+            ++n;
 
             j += (usd->l1 * usd->l2);
         }
@@ -1218,7 +1220,7 @@ UFSSwapDir::CleanEvent(void *unused)
     /* if the rebuild is finished, start cleaning directories. */
     if (0 == StoreController::store_dirs_rebuilding) {
         n = DirClean(swap_index);
-        swap_index++;
+        ++swap_index;
     }
 
     eventAdd("storeDirClean", CleanEvent, NULL,
@@ -386,7 +386,7 @@ RebuildState::RebuildStep(void *data)
     if (!rb->isDone())
         eventAdd("storeRebuild", RebuildStep, rb, 0.01, 1);
     else {
-        StoreController::store_dirs_rebuilding--;
+        -- StoreController::store_dirs_rebuilding;
         storeRebuildComplete(&rb->counts);
         delete rb;
     }
@@ -457,12 +457,12 @@ RebuildState::rebuildFromDirectory()
     assert(fd > -1);
     /* lets get file stats here */
 
-    n_read++;
+    ++n_read;
 
     if (fstat(fd, &sb) < 0) {
         debugs(47, 1, "commonUfsDirRebuildFromDirectory: fstat(FD " << fd << "): " << xstrerror());
         file_close(fd);
-        store_open_disk_fd--;
+        --store_open_disk_fd;
         fd = -1;
         return;
     }
@@ -477,7 +477,7 @@ RebuildState::rebuildFromDirectory()
                         (int64_t)sb.st_size);
 
     file_close(fd);
-    store_open_disk_fd--;
+    --store_open_disk_fd;
     fd = -1;
 
     if (!loaded) {
@@ -489,7 +489,7 @@ RebuildState::rebuildFromDirectory()
     if (!storeRebuildKeepEntry(tmpe, key, counts))
         return;
 
-    counts.objcount++;
+    ++counts.objcount;
     // tmpe.dump(5);
     currentEntry(sd->addDiskRestore(key,
                                     filn,
@@ -531,10 +531,10 @@ RebuildState::rebuildFromSwapLog()
         return;
     }
 
-    n_read++;
+    ++n_read;
 
     if (!swapData.sane()) {
-        counts.invalid++;
+        ++counts.invalid;
         return;
     }
 
@@ -568,8 +568,8 @@ RebuildState::rebuildFromSwapLog()
 
         if (currentEntry() != NULL && swapData.lastref >= e->lastref) {
             undoAdd();
-            counts.objcount--;
-            counts.cancelcount++;
+            --counts.objcount;
+            ++counts.cancelcount;
         }
         return;
     } else {
@@ -579,20 +579,20 @@ RebuildState::rebuildFromSwapLog()
         if (0.0 == x - (double) (int) x)
             debugs(47, 1, "WARNING: " << counts.bad_log_op << " invalid swap log entries found");
 
-        counts.invalid++;
+        ++counts.invalid;
 
         return;
     }
 
     ++counts.scancount; // XXX: should not this be incremented earlier?
 
     if (!sd->validFileno(swapData.swap_filen, 0)) {
-        counts.invalid++;
+        ++counts.invalid;
         return;
     }
 
     if (EBIT_TEST(swapData.flags, KEY_PRIVATE)) {
-        counts.badflags++;
+        ++counts.badflags;
         return;
     }
 
@@ -616,7 +616,7 @@ RebuildState::rebuildFromSwapLog()
 
     if (used && !disk_entry_newer) {
         /* log entry is old, ignore it */
-        counts.clashcount++;
+        ++counts.clashcount;
         return;
     } else if (used && currentEntry() && currentEntry()->swap_filen == swapData.swap_filen && currentEntry()->swap_dirn == sd->index) {
         /* swapfile taken, same URL, newer, update meta */
@@ -654,26 +654,26 @@ RebuildState::rebuildFromSwapLog()
          * were in a slow rebuild and the the swap file number got taken
          * and the validation procedure hasn't run. */
         assert(flags.need_to_validate);
-        counts.clashcount++;
+        ++counts.clashcount;
         return;
     } else if (currentEntry() && !disk_entry_newer) {
         /* key already exists, current entry is newer */
         /* keep old, ignore new */
-        counts.dupcount++;
+        ++counts.dupcount;
         return;
     } else if (currentEntry()) {
         /* key already exists, this swapfile not being used */
         /* junk old, load new */
         undoAdd();
-        counts.objcount--;
-        counts.dupcount++;
+        --counts.objcount;
+        ++counts.dupcount;
     } else {
         /* URL doesnt exist, swapfile not in use */
         /* load new */
         (void) 0;
     }
 
-    counts.objcount++;
+    ++counts.objcount;
 
     currentEntry(sd->addDiskRestore(swapData.key,
                                     swapData.swap_filen,
@@ -745,7 +745,7 @@ RebuildState::getNextFile(sfileno * filn_p, int *size)
 
             td = opendir(fullpath);
 
-            dirs_opened++;
+            ++dirs_opened;
 
             if (td == NULL) {
                 debugs(47, 1, "commonUfsDirGetNextFile: opendir: " << fullpath << ": " << xstrerror());
@@ -760,7 +760,7 @@ RebuildState::getNextFile(sfileno * filn_p, int *size)
         }
 
         if (td != NULL && (entry = readdir(td)) != NULL) {
-            in_dir++;
+            ++in_dir;
 
             if (sscanf(entry->d_name, "%x", &fn) != 1) {
                 debugs(47, 3, "commonUfsDirGetNextFile: invalid " << entry->d_name);
@@ -789,7 +789,7 @@ RebuildState::getNextFile(sfileno * filn_p, int *size)
             if (fd < 0)
                 debugs(47, 1, "commonUfsDirGetNextFile: " << fullfilename << ": " << xstrerror());
             else
-                store_open_disk_fd++;
+                ++store_open_disk_fd;
 
             continue;
         }
@@ -485,8 +485,8 @@ FtpStateData::FtpStateData(FwdState *theFwdState, const Comm::ConnectionPointer
 {
     const char *url = entry->url();
     debugs(9, 3, HERE << "'" << url << "'" );
-    statCounter.server.all.requests++;
-    statCounter.server.ftp.requests++;
+    ++ statCounter.server.all.requests;
+    ++ statCounter.server.ftp.requests;
     theSize = -1;
     mdtm = -1;
 
@@ -711,7 +711,7 @@ is_month(const char *buf)
 {
     int i;
 
-    for (i = 0; i < 12; i++)
+    for (i = 0; i < 12; ++i)
         if (!strcasecmp(buf, Month[i]))
             return 1;
 
@@ -779,13 +779,15 @@ ftpListParseParts(const char *buf, struct _ftp_flags flags)
         return p;
     }
 
-    for (t = strtok(xbuf, w_space); t && n_tokens < MAX_TOKENS; t = strtok(NULL, w_space))
-        tokens[n_tokens++] = xstrdup(t);
+    for (t = strtok(xbuf, w_space); t && n_tokens < MAX_TOKENS; t = strtok(NULL, w_space)) {
+        tokens[n_tokens] = xstrdup(t);
+        ++n_tokens;
+    }
 
     xfree(xbuf);
 
     /* locate the Month field */
-    for (i = 3; i < n_tokens - 2; i++) {
+    for (i = 3; i < n_tokens - 2; ++i) {
         char *size = tokens[i - 1];
         char *month = tokens[i];
         char *day = tokens[i + 1];
@@ -821,7 +823,7 @@ ftpListParseParts(const char *buf, struct _ftp_flags flags)
                 copyFrom += strlen(tbuf);
 
                 while (strchr(w_space, *copyFrom))
-                    copyFrom++;
+                    ++copyFrom;
             } else {
                 /* XXX assumes a single space between date and filename
                  * suggested by:  Nathan.Bailey@cc.monash.edu.au and
@@ -862,7 +864,7 @@ ftpListParseParts(const char *buf, struct _ftp_flags flags)
             ct += strlen(tokens[2]);
 
             while (xisspace(*ct))
-                ct++;
+                ++ct;
 
             if (!*ct)
                 ct = NULL;
@@ -936,7 +938,7 @@ ftpListParseParts(const char *buf, struct _ftp_flags flags)
             ct = strstr(ct, ",");
 
             if (ct) {
-                ct++;
+                ++ct;
             }
         }
 
@@ -952,7 +954,7 @@ ftpListParseParts(const char *buf, struct _ftp_flags flags)
 
 found:
 
-    for (i = 0; i < n_tokens; i++)
+    for (i = 0; i < n_tokens; ++i)
         xfree(tokens[i]);
 
     if (!p->name)
@@ -998,7 +1000,7 @@ FtpStateData::htmlifyListEntry(const char *line)
         html->init();
         html->Printf("<tr class=\"entry\"><td colspan=\"5\">%s</td></tr>\n", line);
 
-        for (p = line; *p && xisspace(*p); p++);
+        for (p = line; *p && xisspace(*p); ++p);
         if (*p && !xisspace(*p))
             flags.listformat_unknown = 1;
 
@@ -1124,7 +1126,7 @@ FtpStateData::parseListing()
     end = sbuf + len - 1;
 
     while (*end != '\r' && *end != '\n' && end > sbuf)
-        end--;
+        --end;
 
     usable = end - sbuf;
 
@@ -1145,7 +1147,7 @@ FtpStateData::parseListing()
     debugs(9, 3, HERE << (unsigned long int)len << " bytes to play with");
 
     line = (char *)memAllocate(MEM_4K_BUF);
-    end++;
+    ++end;
     s = sbuf;
     s += strspn(s, crlf);
 
@@ -1279,12 +1281,12 @@ FtpStateData::dataRead(const CommIoCbParams &io)
         DelayId delayId = entry->mem_obj->mostBytesAllowed();
         delayId.bytesIn(io.size);
 #endif
-        IOStats.Ftp.reads++;
+        ++ IOStats.Ftp.reads;
 
-        for (j = io.size - 1, bin = 0; j; bin++)
+        for (j = io.size - 1, bin = 0; j; ++bin)
             j >>= 1;
 
-        IOStats.Ftp.read_hist[bin]++;
+        ++ IOStats.Ftp.read_hist[bin];
     }
 
     if (io.flag != COMM_OK) {
@@ -1557,20 +1559,24 @@ escapeIAC(const char *buf)
     unsigned const char *p;
     unsigned char *r;
 
-    for (p = (unsigned const char *)buf, n = 1; *p; n++, p++)
+    for (p = (unsigned const char *)buf, n = 1; *p; ++n, ++p)
         if (*p == 255)
-            n++;
+            ++n;
 
     ret = (char *)xmalloc(n);
 
-    for (p = (unsigned const char *)buf, r=(unsigned char *)ret; *p; p++) {
-        *r++ = *p;
+    for (p = (unsigned const char *)buf, r=(unsigned char *)ret; *p; ++p) {
+        *r = *p;
+        ++r;
 
-        if (*p == 255)
-            *r++ = 255;
+        if (*p == 255) {
+            *r = 255;
+            ++r;
+        }
     }
 
-    *r++ = '\0';
+    *r = '\0';
+    ++r;
     assert((r - (unsigned char *)ret) == n );
     return ret;
 }
@@ -1652,7 +1658,7 @@ FtpStateData::ftpParseControlReply(char *buf, size_t len, int *codep, size_t *us
     end = sbuf + len - 1;
 
     while (*end != '\r' && *end != '\n' && end > sbuf)
-        end--;
+        --end;
 
     usable = end - sbuf;
 
@@ -1665,7 +1671,7 @@ FtpStateData::ftpParseControlReply(char *buf, size_t len, int *codep, size_t *us
     }
 
     debugs(9, 3, HERE << len << " bytes to play with");
-    end++;
+    ++end;
     s = sbuf;
     s += strspn(s, crlf);
 
@@ -1865,7 +1871,7 @@ ftpReadWelcome(FtpStateData * ftpState)
     debugs(9, 3, HERE);
 
     if (ftpState->flags.pasv_only)
-        ftpState->login_att++;
+        ++ ftpState->login_att;
 
     if (code == 220) {
         if (ftpState->ctrl.message) {
@@ -2099,14 +2105,16 @@ ftpReadType(FtpStateData * ftpState)
         p = path = xstrdup(ftpState->request->urlpath.termedBuf());
 
         if (*p == '/')
-            p++;
+            ++p;
 
         while (*p) {
             d = p;
             p += strcspn(p, "/");
 
-            if (*p)
-                *p++ = '\0';
+            if (*p) {
+                *p = '\0';
+                ++p;
+            }
 
             rfc1738_unescape(d);
 
@@ -2395,8 +2403,10 @@ ftpReadEPSV(FtpStateData* ftpState)
          * which means close data + control without self-destructing and re-open from scratch. */
         debugs(9, 5, HERE << "scanning: " << ftpState->ctrl.last_reply);
         buf = ftpState->ctrl.last_reply;
-        while (buf != NULL && *buf != '\0' && *buf != '\n' && *buf != '(') ++buf;
-        if (buf != NULL && *buf == '\n') ++buf;
+        while (buf != NULL && *buf != '\0' && *buf != '\n' && *buf != '(')
+            ++buf;
+        if (buf != NULL && *buf == '\n')
+            ++buf;
 
         if (buf == NULL || *buf == '\0') {
             /* handle broken server (RFC 2428 says MUST specify supported protocols in 522) */
@@ -274,7 +274,7 @@ gopher_request_parse(const HttpRequest * req, char *type_id, char *request)
         request[0] = '\0';
 
     if (path && (*path == '/'))
-        path++;
+        ++path;
 
     if (!path || !*path) {
         *type_id = GOPHER_DIRECTORY;
@@ -448,7 +448,7 @@ gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)
         int left = len - (pos - inbuf);
         lpos = (char *)memchr(pos, '\n', left);
         if (lpos) {
-            lpos++;             /* Next line is after \n */
+            ++lpos;             /* Next line is after \n */
             llen = lpos - pos;
         } else {
             llen = left;
@@ -492,16 +492,19 @@ gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)
 
         case gopher_ds::HTML_DIR: {
             tline = line;
-            gtype = *tline++;
+            gtype = *tline;
+            ++tline;
             name = tline;
             selector = strchr(tline, TAB);
 
             if (selector) {
-                *selector++ = '\0';
+                *selector = '\0';
+                ++selector;
                 host = strchr(selector, TAB);
 
                 if (host) {
-                    *host++ = '\0';
+                    *host = '\0';
+                    ++host;
                     port = strchr(host, TAB);
 
                     if (port) {
@@ -778,12 +781,12 @@ gopherReadReply(const Comm::ConnectionPointer &conn, char *buf, size_t len, comm
     if (flag == COMM_OK && len > 0) {
         AsyncCall::Pointer nil;
         commSetConnTimeout(conn, Config.Timeout.read, nil);
-        IOStats.Gopher.reads++;
+        ++IOStats.Gopher.reads;
 
-        for (clen = len - 1, bin = 0; clen; bin++)
+        for (clen = len - 1, bin = 0; clen; ++bin)
             clen >>= 1;
 
-        IOStats.Gopher.read_hist[bin]++;
+        ++IOStats.Gopher.read_hist[bin];
 
         HttpRequest *req = gopherState->fwd->request;
         if (req->hier.bodyBytesRead < 0)
@@ -920,7 +923,7 @@ gopherSendRequest(int fd, void *data)
         const char *t = strchr(gopherState->request, '?');
 
         if (t != NULL)
-            t++;		/* skip the ? */
+            ++t;		/* skip the ? */
         else
             t = "";
 
@@ -965,9 +968,9 @@ gopherStart(FwdState * fwd)
 
     debugs(10, 3, "gopherStart: " << entry->url()  );
 
-    statCounter.server.all.requests++;
+    ++ statCounter.server.all.requests;
 
-    statCounter.server.other.requests++;
+    ++ statCounter.server.other.requests;
 
     /* Parse url. */
     gopher_request_parse(fwd->request,
@@ -182,16 +182,20 @@ helperOpenServers(helper * hlp)
 
     snprintf(procname, strlen(shortname) + 3, "(%s)", shortname);
 
-    args[nargs++] = procname;
+    args[nargs] = procname;
+    ++nargs;
 
-    for (w = hlp->cmdline->next; w && nargs < HELPER_MAX_ARGS; w = w->next)
-        args[nargs++] = w->key;
+    for (w = hlp->cmdline->next; w && nargs < HELPER_MAX_ARGS; w = w->next) {
+        args[nargs] = w->key;
+        ++nargs;
+    }
 
-    args[nargs++] = NULL;
+    args[nargs] = NULL;
+    ++nargs;
 
     assert(nargs <= HELPER_MAX_ARGS);
 
-    for (k = 0; k < need_new; k++) {
+    for (k = 0; k < need_new; ++k) {
         getCurrentTime();
         rfd = wfd = -1;
         pid = ipcCreate(hlp->ipc_type,
@@ -208,8 +212,8 @@ helperOpenServers(helper * hlp)
             continue;
         }
 
-        hlp->childs.n_running++;
-        hlp->childs.n_active++;
+        ++ hlp->childs.n_running;
+        ++ hlp->childs.n_active;
         CBDATA_INIT_TYPE(helper_server);
         srv = cbdataAlloc(helper_server);
         srv->hIpc = hIpc;
@@ -296,16 +300,20 @@ helperStatefulOpenServers(statefulhelper * hlp)
 
     snprintf(procname, strlen(shortname) + 3, "(%s)", shortname);
 
-    args[nargs++] = procname;
+    args[nargs] = procname;
+    ++nargs;
 
-    for (wordlist *w = hlp->cmdline->next; w && nargs < HELPER_MAX_ARGS; w = w->next)
-        args[nargs++] = w->key;
+    for (wordlist *w = hlp->cmdline->next; w && nargs < HELPER_MAX_ARGS; w = w->next) {
+        args[nargs] = w->key;
+        ++nargs;
+    }
 
-    args[nargs++] = NULL;
+    args[nargs] = NULL;
+    ++nargs;
 
     assert(nargs <= HELPER_MAX_ARGS);
 
-    for (int k = 0; k < need_new; k++) {
+    for (int k = 0; k < need_new; ++k) {
         getCurrentTime();
         int rfd = -1;
         int wfd = -1;
@@ -324,8 +332,8 @@ helperStatefulOpenServers(statefulhelper * hlp)
             continue;
         }
 
-        hlp->childs.n_running++;
-        hlp->childs.n_active++;
+        ++ hlp->childs.n_running;
+        ++ hlp->childs.n_active;
         CBDATA_INIT_TYPE(helper_stateful_server);
         helper_stateful_server *srv = cbdataAlloc(helper_stateful_server);
         srv->hIpc = hIpc;
@@ -456,7 +464,7 @@ helperStatefulReleaseServer(helper_stateful_server * srv)
     if (!srv->flags.reserved)
         return;
 
-    srv->stats.releases++;
+    ++ srv->stats.releases;
 
     srv->flags.reserved = 0;
     if (srv->parent->OnEmptyQueue != NULL && srv->data)
@@ -599,7 +607,7 @@ helperShutdown(helper * hlp)
         }
 
         assert(hlp->childs.n_active > 0);
-        hlp->childs.n_active--;
+        -- hlp->childs.n_active;
         srv->flags.shutdown = 1;	/* request it to shut itself down */
 
         if (srv->flags.closing) {
@@ -636,7 +644,7 @@ helperStatefulShutdown(statefulhelper * hlp)
         }
 
         assert(hlp->childs.n_active > 0);
-        hlp->childs.n_active--;
+        -- hlp->childs.n_active;
         srv->flags.shutdown = 1;	/* request it to shut itself down */
 
         if (srv->flags.busy) {
@@ -709,11 +717,11 @@ helperServerFree(helper_server *srv)
     dlinkDelete(&srv->link, &hlp->servers);
 
     assert(hlp->childs.n_running > 0);
-    hlp->childs.n_running--;
+    -- hlp->childs.n_running;
 
     if (!srv->flags.shutdown) {
         assert(hlp->childs.n_active > 0);
-        hlp->childs.n_active--;
+        -- hlp->childs.n_active;
         debugs(84, DBG_CRITICAL, "WARNING: " << hlp->id_name << " #" << srv->index + 1 << " exited");
 
         if (hlp->childs.needNew() > 0) {
@@ -727,7 +735,7 @@ helperServerFree(helper_server *srv)
         }
     }
 
-    for (i = 0; i < concurrency; i++) {
+    for (i = 0; i < concurrency; ++i) {
         if ((r = srv->requests[i])) {
             void *cbdata;
 
@@ -770,11 +778,11 @@ helperStatefulServerFree(helper_stateful_server *srv)
     dlinkDelete(&srv->link, &hlp->servers);
 
     assert(hlp->childs.n_running > 0);
-    hlp->childs.n_running--;
+    -- hlp->childs.n_running;
 
     if (!srv->flags.shutdown) {
         assert( hlp->childs.n_active > 0);
-        hlp->childs.n_active--;
+        -- hlp->childs.n_active;
         debugs(84, 0, "WARNING: " << hlp->id_name << " #" << srv->index + 1 << " exited");
 
         if (hlp->childs.needNew() > 0) {
@@ -822,9 +830,9 @@ static void helperReturnBuffer(int request_number, helper_server * srv, helper *
         if (cbdataReferenceValidDone(r->data, &cbdata))
             callback(cbdata, msg);
 
-        srv->stats.pending--;
+        -- srv->stats.pending;
 
-        hlp->stats.replies++;
+        ++ hlp->stats.replies;
 
         srv->answer_time = current_time;
 
@@ -899,13 +907,14 @@ helperHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t len, com
         if (t > srv->rbuf && t[-1] == '\r' && hlp->eom == '\n')
             t[-1] = '\0';
 
-        *t++ = '\0';
+        *t = '\0';
+        ++t;
 
         if (hlp->childs.concurrency) {
             i = strtol(msg, &msg, 10);
 
             while (*msg && xisspace(*msg))
-                msg++;
+                ++msg;
         }
 
         helperReturnBuffer(i, srv, hlp, msg, t);
@@ -999,7 +1008,7 @@ helperStatefulHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t
         srv->roffset = 0;
         helperStatefulRequestFree(r);
         srv->request = NULL;
-        hlp->stats.replies++;
+        ++ hlp->stats.replies;
         srv->answer_time = current_time;
         hlp->stats.avg_svc_time =
             Math::intAverage(hlp->stats.avg_svc_time,
@@ -1045,7 +1054,7 @@ Enqueue(helper * hlp, helper_request * r)
 {
     dlink_node *link = (dlink_node *)memAllocate(MEM_DLINK_NODE);
     dlinkAddTail(r, link, &hlp->queue);
-    hlp->stats.queue_size++;
+    ++ hlp->stats.queue_size;
 
     /* do this first so idle=N has a chance to grow the child pool before it hits critical. */
     if (hlp->childs.needNew() > 0) {
@@ -1078,7 +1087,7 @@ StatefulEnqueue(statefulhelper * hlp, helper_stateful_request * r)
 {
     dlink_node *link = (dlink_node *)memAllocate(MEM_DLINK_NODE);
     dlinkAddTail(r, link, &hlp->queue);
-    hlp->stats.queue_size++;
+    ++ hlp->stats.queue_size;
 
     /* do this first so idle=N has a chance to grow the child pool before it hits critical. */
     if (hlp->childs.needNew() > 0) {
@@ -1116,7 +1125,7 @@ Dequeue(helper * hlp)
         r = (helper_request *)link->data;
         dlinkDelete(link, &hlp->queue);
         memFree(link, MEM_DLINK_NODE);
-        hlp->stats.queue_size--;
+        -- hlp->stats.queue_size;
     }
 
     return r;
@@ -1132,7 +1141,7 @@ StatefulDequeue(statefulhelper * hlp)
         r = (helper_stateful_request *)link->data;
         dlinkDelete(link, &hlp->queue);
         memFree(link, MEM_DLINK_NODE);
-        hlp->stats.queue_size--;
+        -- hlp->stats.queue_size;
     }
 
     return r;
@@ -1258,7 +1267,7 @@ helperDispatch(helper_server * srv, helper_request * r)
         return;
     }
 
-    for (slot = 0; slot < (hlp->childs.concurrency ? hlp->childs.concurrency : 1); slot++) {
+    for (slot = 0; slot < (hlp->childs.concurrency ? hlp->childs.concurrency : 1); ++slot) {
         if (!srv->requests[slot]) {
             ptr = &srv->requests[slot];
             break;
@@ -1290,8 +1299,8 @@ helperDispatch(helper_server * srv, helper_request * r)
 
     debugs(84, 5, "helperDispatch: Request sent to " << hlp->id_name << " #" << srv->index + 1 << ", " << strlen(r->buf) << " bytes");
 
-    srv->stats.uses++;
-    hlp->stats.requests++;
+    ++ srv->stats.uses;
+    ++ hlp->stats.requests;
 }
 
 static void
@@ -1343,8 +1352,8 @@ helperStatefulDispatch(helper_stateful_server * srv, helper_stateful_request * r
            hlp->id_name << " #" << srv->index + 1 << ", " <<
            (int) strlen(r->buf) << " bytes");
 
-    srv->stats.uses++;
-    hlp->stats.requests++;
+    ++ srv->stats.uses;
+    ++ hlp->stats.requests;
 }
 
 
@@ -290,7 +290,7 @@ htcpHexdump(const char *tag, const char *s, int sz)
     debugs(31, 3, "htcpHexdump " << tag);
     memset(hex, '\0', 80);
 
-    for (i = 0; i < sz; i++) {
+    for (i = 0; i < sz; ++i) {
         k = i % 16;
         snprintf(&hex[k * 3], 4, " %02x", (int) *(s + i));
 
@@ -608,7 +608,7 @@ htcpSend(const char *buf, int len, Ip::Address &to)
     if (comm_udp_sendto(htcpOutgoingConn->fd, to, buf, len) < 0)
         debugs(31, 3, HERE << htcpOutgoingConn << " sendto: " << xstrerror());
     else
-        statCounter.htcp.pkts_sent++;
+        ++statCounter.htcp.pkts_sent;
 }
 
 /*
@@ -1057,7 +1057,7 @@ htcpClrStore(const htcpSpecifier * s)
     while ((e = storeGetPublicByRequest(request)) != NULL) {
         if (e != NULL) {
             htcpClrStoreEntry(e);
-            released++;
+            ++released;
         }
     }
 
@@ -1456,7 +1456,7 @@ htcpRecv(int fd, void *data)
     debugs(31, 3, "htcpRecv: FD " << fd << ", " << len << " bytes from " << from );
 
     if (len)
-        statCounter.htcp.pkts_recv++;
+        ++statCounter.htcp.pkts_recv;
 
     htcpHandleMsg(buf, len, from);
 
@@ -601,11 +601,11 @@ HttpStateData::keepaliveAccounting(HttpReply *reply)
 {
     if (flags.keepalive)
         if (_peer)
-            _peer->stats.n_keepalives_sent++;
+            ++ _peer->stats.n_keepalives_sent;
 
     if (reply->keep_alive) {
         if (_peer)
-            _peer->stats.n_keepalives_recv++;
+            ++ _peer->stats.n_keepalives_recv;
 
         if (Config.onoff.detect_broken_server_pconns
                 && reply->bodySize(request->method) == -1 && !flags.chunked) {
@@ -1101,12 +1101,12 @@ HttpStateData::readReply(const CommIoCbParams &io)
 
         kb_incr(&(statCounter.server.all.kbytes_in), len);
         kb_incr(&(statCounter.server.http.kbytes_in), len);
-        IOStats.Http.reads++;
+        ++ IOStats.Http.reads;
 
-        for (clen = len - 1, bin = 0; clen; bin++)
+        for (clen = len - 1, bin = 0; clen; ++bin)
             clen >>= 1;
 
-        IOStats.Http.read_hist[bin]++;
+        ++ IOStats.Http.read_hist[bin];
 
         // update peer response time stats (%<pt)
         const timeval &sent = request->hier.peer_http_request_sent;
@@ -2173,8 +2173,8 @@ HttpStateData::start()
         return;
     }
 
-    statCounter.server.all.requests++;
-    statCounter.server.http.requests++;
+    ++ statCounter.server.all.requests;
+    ++ statCounter.server.http.requests;
 
     /*
      * We used to set the read timeout here, but not any more.
@@ -69,7 +69,8 @@ Icmp::CheckSum(unsigned short *ptr, int size)
     sum = 0;
 
     while (size > 1) {
-        sum += *ptr++;
+        sum += *ptr;
+        ++ptr;
         size -= 2;
     }
 
@@ -117,7 +117,8 @@ Icmp4::SendEcho(Ip::Address &to, int opcode, const char *payload, int len)
     icmp->icmp_code = 0;
     icmp->icmp_cksum = 0;
     icmp->icmp_id = icmp_ident;
-    icmp->icmp_seq = (unsigned short) icmp_pkts_sent++;
+    icmp->icmp_seq = (unsigned short) icmp_pkts_sent;
+    ++icmp_pkts_sent;
 
     // Construct ICMP packet data content
     echo = (icmpEchoData *) (icmp + 1);
@@ -158,7 +158,8 @@ Icmp6::SendEcho(Ip::Address &to, int opcode, const char *payload, int len)
     icmp->icmp6_code = 0;
     icmp->icmp6_cksum = 0;
     icmp->icmp6_id = icmp_ident;
-    icmp->icmp6_seq = (unsigned short) icmp_pkts_sent++;
+    icmp->icmp6_seq = (unsigned short) icmp_pkts_sent;
+    ++icmp_pkts_sent;
 
     icmp6_pktsize = sizeof(struct icmp6_hdr);
 
@@ -142,7 +142,7 @@ netdbHostInsert(netdbEntry * n, const char *hostname)
     x->net_db_entry = n;
     assert(hash_lookup(host_table, hostname) == NULL);
     hash_join(host_table, &x->hash);
-    n->link_count++;
+    ++ n->link_count;
 }
 
 static void
@@ -153,7 +153,7 @@ netdbHostDelete(const net_db_name * x)
     assert(x != NULL);
     assert(x->net_db_entry != NULL);
     n = x->net_db_entry;
-    n->link_count--;
+    -- n->link_count;
 
     for (X = &n->hosts; *X; X = &(*X)->next) {
         if (*X == x) {
@@ -226,21 +226,21 @@ netdbPurgeLRU(void)
     while ((n = (netdbEntry *) hash_next(addr_table))) {
         assert(list_count < memInUse(MEM_NETDBENTRY));
         *(list + list_count) = n;
-        list_count++;
+        ++list_count;
     }
 
     qsort((char *) list,
           list_count,
           sizeof(netdbEntry *),
           netdbLRU);
 
-    for (k = 0; k < list_count; k++) {
+    for (k = 0; k < list_count; ++k) {
         if (memInUse(MEM_NETDBENTRY) < Config.Netdb.low)
             break;
 
         netdbRelease(*(list + k));
 
-        removed++;
+        ++removed;
     }
 
     xfree(list);
@@ -320,20 +320,20 @@ netdbSendPing(const ipcache_addrs *ia, const DnsLookupDetails &, void *data)
             }
         }
 
-        n->link_count--;
+        -- n->link_count;
         /* point to 'network na' from host entry */
         x->net_db_entry = na;
         /* link net_db_name to 'network na' */
         x->next = na->hosts;
         na->hosts = x;
-        na->link_count++;
+        ++ na->link_count;
         n = na;
     }
 
     if (n->next_ping_time <= squid_curtime) {
         debugs(38, 3, "netdbSendPing: pinging " << hostname);
         icmpEngine.DomainPing(addr, hostname);
-        n->pings_sent++;
+        ++ n->pings_sent;
         n->next_ping_time = squid_curtime + Config.Netdb.period;
         n->last_use_time = squid_curtime;
     }
@@ -400,7 +400,7 @@ netdbPeerByName(const netdbEntry * n, const char *peername)
     int i;
     net_db_peer *p = n->peers;
 
-    for (i = 0; i < n->n_peers; i++, p++) {
+    for (i = 0; i < n->n_peers; ++i, ++p) {
         if (!strcmp(p->peername, peername))
             return p;
     }
@@ -429,7 +429,7 @@ netdbPeerAdd(netdbEntry * n, peer * e)
 
         n->peers = (net_db_peer *)xcalloc(n->n_peers_alloc, sizeof(net_db_peer));
 
-        for (i = 0; i < osize; i++)
+        for (i = 0; i < osize; ++i)
             *(n->peers + i) = *(o + i);
 
         if (osize) {
@@ -439,7 +439,7 @@ netdbPeerAdd(netdbEntry * n, peer * e)
 
     p = n->peers + n->n_peers;
     p->peername = netdbPeerName(e->host);
-    n->n_peers++;
+    ++ n->n_peers;
     return p;
 }
 
@@ -506,7 +506,7 @@ netdbSaveState(void *foo)
 
         logfilePrintf(lf, "\n");
 
-        count++;
+        ++count;
 
 #undef RBUF_SZ
 
@@ -632,7 +632,7 @@ netdbReloadState(void)
             netdbHostInsert(n, q);
         }
 
-        count++;
+        ++count;
     }
 
     xfree(buf);
@@ -777,22 +777,22 @@ netdbExchangeHandleReply(void *data, StoreIOBuffer receivedData)
             switch ((int) *(p + o)) {
 
             case NETDB_EX_NETWORK:
-                o++;
+                ++o;
                 /* FIXME INET6 : NetDB can still ony send IPv4 */
                 memcpy(&line_addr, p + o, sizeof(struct in_addr));
                 addr = line_addr;
                 o += sizeof(struct in_addr);
                 break;
 
             case NETDB_EX_RTT:
-                o++;
+                ++o;
                 memcpy(&j, p + o, sizeof(int));
                 o += sizeof(int);
                 rtt = (double) ntohl(j) / 1000.0;
                 break;
 
             case NETDB_EX_HOPS:
-                o++;
+                ++o;
                 memcpy(&j, p + o, sizeof(int));
                 o += sizeof(int);
                 hops = (double) ntohl(j) / 1000.0;
@@ -816,7 +816,7 @@ netdbExchangeHandleReply(void *data, StoreIOBuffer receivedData)
 
         p += rec_sz;
 
-        nused++;
+        ++nused;
     }
 
     /*
@@ -1018,8 +1018,10 @@ netdbDump(StoreEntry * sentry)
     i = 0;
     hash_first(addr_table);
 
-    while ((n = (netdbEntry *) hash_next(addr_table)))
-        *(list + i++) = n;
+    while ((n = (netdbEntry *) hash_next(addr_table))) {
+        *(list + i) = n;
+        ++i;
+    }
 
     if (i != memInUse(MEM_NETDBENTRY))
         debugs(38, 0, "WARNING: netdb_addrs count off, found " << i <<
@@ -1030,7 +1032,7 @@ netdbDump(StoreEntry * sentry)
           sizeof(netdbEntry *),
           sortByRtt);
 
-    for (k = 0; k < i; k++) {
+    for (k = 0; k < i; ++k) {
         n = *(list + k);
         storeAppendPrintf(sentry, "%-46.46s %4d/%4d %7.1f %5.1f", /* Max between 16 (IPv4) or 46 (IPv6)   */
                           n->network,
@@ -1046,7 +1048,7 @@ netdbDump(StoreEntry * sentry)
 
         p = n->peers;
 
-        for (j = 0; j < n->n_peers; j++, p++) {
+        for (j = 0; j < n->n_peers; ++j, ++p) {
             storeAppendPrintf(sentry, "    %-22.22s %7.1f %5.1f\n",
                               p->peername,
                               p->rtt,
@@ -1245,22 +1247,25 @@ netdbBinaryExchange(StoreEntry * s)
         if ( !addr.IsIPv4() )
             continue;
 
-        buf[i++] = (char) NETDB_EX_NETWORK;
+        buf[i] = (char) NETDB_EX_NETWORK;
+        ++i;
 
         addr.GetInAddr(line_addr);
         memcpy(&buf[i], &line_addr, sizeof(struct in_addr));
 
         i += sizeof(struct in_addr);
 
-        buf[i++] = (char) NETDB_EX_RTT;
+        buf[i] = (char) NETDB_EX_RTT;
+        ++i;
 
         j = htonl((int) (n->rtt * 1000));
 
         memcpy(&buf[i], &j, sizeof(int));
 
         i += sizeof(int);
 
-        buf[i++] = (char) NETDB_EX_HOPS;
+        buf[i] = (char) NETDB_EX_HOPS;
+        ++i;
 
         j = htonl((int) (n->hops * 1000));
 
@@ -1374,7 +1379,7 @@ netdbClosestParent(HttpRequest * request)
      * Make sure we don't return a parent who is farther away than
      * we are.  Note, the n->peers list is pre-sorted by RTT.
      */
-    for (i = 0; i < n->n_peers; i++) {
+    for (i = 0; i < n->n_peers; ++i) {
         h = &n->peers[i];
 
         if (n->rtt > 0)
@@ -319,10 +319,10 @@ icpUdpSend(int fd,
         }
 
         Comm::SetSelect(fd, COMM_SELECT_WRITE, icpUdpSendQueue, NULL, 0);
-        statCounter.icp.replies_queued++;
+        ++statCounter.icp.replies_queued;
     } else {
         /* don't queue it */
-        statCounter.icp.replies_dropped++;
+        ++statCounter.icp.replies_dropped;
     }
 
     return x;
@@ -598,7 +598,8 @@ icpHandleUdp(int sock, void *data)
     int max = INCOMING_UDP_MAX;
     Comm::SetSelect(sock, COMM_SELECT_READ, icpHandleUdp, NULL, 0);
 
-    while (max--) {
+    while (max) {
+        --max;
         len = comm_udp_recvfrom(sock,
                                 buf,
                                 SQUID_UDP_SO_RCVBUF - 1,
@@ -625,7 +626,7 @@ icpHandleUdp(int sock, void *data)
             break;
         }
 
-        (*N)++;
+        ++(*N);
         icpCount(buf, RECV, (size_t) len, 0);
         buf[len] = '\0';
         debugs(12, 4, "icpHandleUdp: FD " << sock << ": received " <<
@@ -784,36 +785,36 @@ icpCount(void *buf, int which, size_t len, int delay)
         return;
 
     if (SENT == which) {
-        statCounter.icp.pkts_sent++;
+        ++statCounter.icp.pkts_sent;
         kb_incr(&statCounter.icp.kbytes_sent, len);
 
         if (ICP_QUERY == icp->opcode) {
-            statCounter.icp.queries_sent++;
+            ++statCounter.icp.queries_sent;
             kb_incr(&statCounter.icp.q_kbytes_sent, len);
         } else {
-            statCounter.icp.replies_sent++;
+            ++statCounter.icp.replies_sent;
             kb_incr(&statCounter.icp.r_kbytes_sent, len);
             /* this is the sent-reply service time */
             statCounter.icp.replySvcTime.count(delay);
         }
 
         if (ICP_HIT == icp->opcode)
-            statCounter.icp.hits_sent++;
+            ++statCounter.icp.hits_sent;
     } else if (RECV == which) {
-        statCounter.icp.pkts_recv++;
+        ++statCounter.icp.pkts_recv;
         kb_incr(&statCounter.icp.kbytes_recv, len);
 
         if (ICP_QUERY == icp->opcode) {
-            statCounter.icp.queries_recv++;
+            ++statCounter.icp.queries_recv;
             kb_incr(&statCounter.icp.q_kbytes_recv, len);
         } else {
-            statCounter.icp.replies_recv++;
+            ++statCounter.icp.replies_recv;
             kb_incr(&statCounter.icp.r_kbytes_recv, len);
             /* statCounter.icp.querySvcTime set in clientUpdateCounters */
         }
 
         if (ICP_HIT == icp->opcode)
-            statCounter.icp.hits_recv++;
+            ++statCounter.icp.hits_recv;
     }
 }
 
@@ -58,7 +58,7 @@
 	if(!(b)){	printf("assert \"%s\" at line %d\n", a, __LINE__); \
 		printf("Ip::Address invalid? with IsIPv4()=%c, IsIPv6()=%c\n",(IsIPv4()?'T':'F'),(IsIPv6()?'T':'F')); \
 		printf("ADDRESS:"); \
-		for(unsigned int i = 0; i < sizeof(m_SocketAddr.sin6_addr); i++) { \
+		for(unsigned int i = 0; i < sizeof(m_SocketAddr.sin6_addr); ++i) { \
 			printf(" %x", m_SocketAddr.sin6_addr.s6_addr[i]); \
 		} printf("\n"); assert(b); \
 	}
@@ -82,19 +82,19 @@ Ip::Address::GetCIDR() const
         shift = 12;
     }
 
-    for (; shift<sizeof(m_SocketAddr.sin6_addr) ; shift++) {
+    for (; shift<sizeof(m_SocketAddr.sin6_addr) ; ++shift) {
         byte= *(ptr+shift);
 
         if (byte == 0xFF) {
             len += 8;
             continue ;  /* A short-cut */
         }
 
-        for (caught = 0 , bit= 7 ; !caught && (bit <= 7); bit--) {
+        for (caught = 0 , bit= 7 ; !caught && (bit <= 7); --bit) {
             caught = ((byte & 0x80) == 0x00);  /* Found a '0' at 'bit' ? */
 
             if (!caught)
-                len++;
+                ++len;
 
             byte <<= 1;
         }
@@ -114,9 +114,9 @@ Ip::Address::ApplyMask(Ip::Address const &mask_addr)
     unsigned int blen = sizeof(m_SocketAddr.sin6_addr)/sizeof(uint32_t);
     unsigned int changes = 0;
 
-    for (unsigned int i = 0; i < blen; i++) {
+    for (unsigned int i = 0; i < blen; ++i) {
         if ((p1[i] & p2[i]) != p1[i])
-            changes++;
+            ++changes;
 
         p1[i] &= p2[i];
     }
@@ -151,7 +151,7 @@ Ip::Address::ApplyMask(const unsigned int cidr, int mtype)
 
     p = (uint8_t*)(&m_SocketAddr.sin6_addr) + 15;
 
-    for (; clearbits>0 && p >= (uint8_t*)&m_SocketAddr.sin6_addr ; p-- ) {
+    for (; clearbits>0 && p >= (uint8_t*)&m_SocketAddr.sin6_addr ; --p ) {
         if (clearbits < 8) {
             *p &= ((0xFF << clearbits) & 0xFF);
             clearbits = 0;
@@ -315,7 +315,7 @@ Ip::Address::GetReverseString6(char buf[MAX_IPSTRLEN], const struct in6_addr &da
 
     /* Compile Err: 'Too many arguments for format. */
 
-    for (int i = 15; i >= 0; i--, p+=4) {
+    for (int i = 15; i >= 0; --i, p+=4) {
         snprintf(p, 5, "%x.%x.", ((r[i])&0xf), (((r[i])>>4)&0xf) );
     }
 
@@ -729,7 +729,7 @@ Ip::Address::matchIPAddr(const Ip::Address &rhs) const
     // loop a byte-wise compare
     // NP: match MUST be R-to-L : L-to-R produces inconsistent gt/lt results at varying CIDR
     //     expected difference on CIDR is gt/eq or lt/eq ONLY.
-    for (unsigned int i = 0 ; i < sizeof(m_SocketAddr.sin6_addr) ; i++) {
+    for (unsigned int i = 0 ; i < sizeof(m_SocketAddr.sin6_addr) ; ++i) {
 
         if (l[i] < r[i])
             return -1;
@@ -876,7 +876,7 @@ Ip::Address::ToHostname(char *buf, const unsigned int blen) const
 
     if (IsIPv6() && blen > 0) {
         *p = '[';
-        p++;
+        ++p;
     }
 
     /* 8 being space for [ ] : and port digits */
@@ -887,11 +887,11 @@ Ip::Address::ToHostname(char *buf, const unsigned int blen) const
 
     // find the end of the new string
     while (*p != '\0' && p < buf+blen)
-        p++;
+        ++p;
 
     if (IsIPv6() && p < (buf+blen-1) ) {
         *p = ']';
-        p++;
+        ++p;
     }
 
     /* terminate just in case. */
@@ -49,7 +49,7 @@ Ip::Qos::Config::isAclNfmarkActive() const
 {
     acl_nfmark * nfmarkAcls [] = { nfmarkToServer, nfmarkToClient };
 
-    for (int i=0; i<2; i++) {
+    for (int i=0; i<2; ++i) {
         while (nfmarkAcls[i]) {
             acl_nfmark *l = nfmarkAcls[i];
             if (l->nfmark > 0)
@@ -66,7 +66,7 @@ Ip::Qos::Config::isAclTosActive() const
 {
     acl_tos * tosAcls [] = { tosToServer, tosToClient };
 
-    for (int i=0; i<2; i++) {
+    for (int i=0; i<2; ++i) {
         while (tosAcls[i]) {
             acl_tos *l = tosAcls[i];
             if (l->tos > 0)
@@ -388,7 +388,7 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
     close(t3);
 
     /* Make sure all other filedescriptors are closed */
-    for (x = 3; x < SQUID_MAXFD; x++)
+    for (x = 3; x < SQUID_MAXFD; ++x)
         close(x);
 
 #if HAVE_SETSID
@@ -54,7 +54,7 @@ void Kid::stop(status_type exitStatus)
     time_t stop_time;
     time(&stop_time);
     if ((stop_time - startTime) < fastFailureTimeLimit)
-        badFailures++;
+        ++badFailures;
     else
         badFailures = 0; // the failures are not "frequent" [any more]
 
@@ -547,7 +547,7 @@ ipc_thread_1(void *in_params)
     si.dwFlags = STARTF_USESTDHANDLES;
 
     /* Make sure all other valid handles are not inerithable */
-    for (x = 3; x < Squid_MaxFD; x++) {
+    for (x = 3; x < Squid_MaxFD; ++x) {
         if ((F = _get_osfhandle(x)) == -1)
             continue;
 
@@ -566,7 +566,8 @@ ipc_thread_1(void *in_params)
     x = 1;
 
     while (args[x]) {
-        strcat(buf1, args[x++]);
+        strcat(buf1, args[x]);
+        ++x;
         strcat(buf1, " ");
     }
 
@@ -832,7 +833,7 @@ ipc_thread_2(void *in_params)
             if ((buf2[x - 1] == '\n') && (buf2[x - 2] == '\r')) {
                 buf2[x - 2] = '\n';
                 buf2[x - 1] = '\0';
-                x--;
+                --x;
             }
         }
 
@@ -255,7 +255,7 @@ ipcache_purgelru(void *voidnotused)
 
         ipcacheRelease(i);
 
-        removed++;
+        ++removed;
     }
 
     debugs(14, 9, "ipcache_purgelru: removed " << removed << " entries");
@@ -423,14 +423,14 @@ ipcacheParse(ipcache_entry *i, const char *inbuf)
         int j, k;
 
         i->addrs.in_addrs = static_cast<Ip::Address *>(xcalloc(ipcount, sizeof(Ip::Address)));
-        for (int l = 0; l < ipcount; l++)
+        for (int l = 0; l < ipcount; ++l)
             i->addrs.in_addrs[l].SetEmpty(); // perform same init actions as constructor would.
         i->addrs.bad_mask = (unsigned char *)xcalloc(ipcount, sizeof(unsigned char));
         memset(i->addrs.bad_mask, 0, sizeof(unsigned char) * ipcount);
 
-        for (j = 0, k = 0; k < ipcount; k++) {
+        for (j = 0, k = 0; k < ipcount; ++k) {
             if ( i->addrs.in_addrs[j] = A[k] )
-                j++;
+                ++j;
             else
                 debugs(14, 1, "ipcacheParse: Invalid IP address '" << A[k] << "' in response to '" << name << "'");
         }
@@ -492,15 +492,15 @@ ipcacheParse(ipcache_entry *i, const rfc1035_rr * answers, int nr, const char *e
     debugs(14, 3, "ipcacheParse: " << nr << " answers for '" << name << "'");
     assert(answers);
 
-    for (k = 0; k < nr; k++) {
+    for (k = 0; k < nr; ++k) {
 
         if (Ip::EnableIpv6 && answers[k].type == RFC1035_TYPE_AAAA) {
             if (answers[k].rdlength != sizeof(struct in6_addr)) {
                 debugs(14, 1, "ipcacheParse: Invalid IPv6 address in response to '" << name << "'");
                 continue;
             }
-            na++;
-            IpcacheStats.rr_aaaa++;
+            ++na;
+            ++IpcacheStats.rr_aaaa;
             continue;
         }
 
@@ -509,15 +509,15 @@ ipcacheParse(ipcache_entry *i, const rfc1035_rr * answers, int nr, const char *e
                 debugs(14, 1, "ipcacheParse: Invalid IPv4 address in response to '" << name << "'");
                 continue;
             }
-            na++;
-            IpcacheStats.rr_a++;
+            ++na;
+            ++IpcacheStats.rr_a;
             continue;
         }
 
         /* With A and AAAA, the CNAME does not necessarily come with additional records to use. */
         if (answers[k].type == RFC1035_TYPE_CNAME) {
             cname_found=1;
-            IpcacheStats.rr_cname++;
+            ++IpcacheStats.rr_cname;
             continue;
         }
 
@@ -528,16 +528,16 @@ ipcacheParse(ipcache_entry *i, const rfc1035_rr * answers, int nr, const char *e
         debugs(14, 1, "ipcacheParse: No Address records in response to '" << name << "'");
         i->error_message = xstrdup("No Address records");
         if (cname_found)
-            IpcacheStats.cname_only++;
+            ++IpcacheStats.cname_only;
         return 0;
     }
 
     i->addrs.in_addrs = static_cast<Ip::Address *>(xcalloc(na, sizeof(Ip::Address)));
-    for (int l = 0; l < na; l++)
+    for (int l = 0; l < na; ++l)
         i->addrs.in_addrs[l].SetEmpty(); // perform same init actions as constructor would.
     i->addrs.bad_mask = (unsigned char *)xcalloc(na, sizeof(unsigned char));
 
-    for (j = 0, k = 0; k < nr; k++) {
+    for (j = 0, k = 0; k < nr; ++k) {
 
         if (answers[k].type == RFC1035_TYPE_A) {
             if (answers[k].rdlength != sizeof(struct in_addr))
@@ -548,7 +548,7 @@ ipcacheParse(ipcache_entry *i, const rfc1035_rr * answers, int nr, const char *e
             i->addrs.in_addrs[j] = temp;
 
             debugs(14, 3, "ipcacheParse: " << name << " #" << j << " " << i->addrs.in_addrs[j]);
-            j++;
+            ++j;
 
         } else if (Ip::EnableIpv6 && answers[k].type == RFC1035_TYPE_AAAA) {
             if (answers[k].rdlength != sizeof(struct in6_addr))
@@ -559,7 +559,7 @@ ipcacheParse(ipcache_entry *i, const rfc1035_rr * answers, int nr, const char *e
             i->addrs.in_addrs[j] = temp;
 
             debugs(14, 3, "ipcacheParse: " << name << " #" << j << " " << i->addrs.in_addrs[j] );
-            j++;
+            ++j;
         }
         if (ttl == 0 || (int) answers[k].ttl < ttl)
             ttl = answers[k].ttl;
@@ -597,7 +597,7 @@ ipcacheHandleReply(void *data, const rfc1035_rr * answers, int na, const char *e
 {
     ipcache_entry *i;
     static_cast<generic_cbdata *>(data)->unwrap(&i);
-    IpcacheStats.replies++;
+    ++IpcacheStats.replies;
     const int age = i->age();
     statCounter.dns.svcTime.count(age);
 
@@ -640,11 +640,11 @@ ipcache_nbgethostbyname(const char *name, IPH * handler, void *handlerData)
     const ipcache_addrs *addrs = NULL;
     generic_cbdata *c;
     debugs(14, 4, "ipcache_nbgethostbyname: Name '" << name << "'.");
-    IpcacheStats.requests++;
+    ++IpcacheStats.requests;
 
     if (name == NULL || name[0] == '\0') {
         debugs(14, 4, "ipcache_nbgethostbyname: Invalid name!");
-        IpcacheStats.invalid++;
+        ++IpcacheStats.invalid;
         const DnsLookupDetails details("Invalid hostname", -1); // error, no lookup
         if (handler)
             handler(NULL, details, handlerData);
@@ -653,7 +653,7 @@ ipcache_nbgethostbyname(const char *name, IPH * handler, void *handlerData)
 
     if ((addrs = ipcacheCheckNumeric(name))) {
         debugs(14, 4, "ipcache_nbgethostbyname: BYPASS for '" << name << "' (already numeric)");
-        IpcacheStats.numeric_hits++;
+        ++IpcacheStats.numeric_hits;
         const DnsLookupDetails details(NULL, -1); // no error, no lookup
         if (handler)
             handler(addrs, details, handlerData);
@@ -674,9 +674,9 @@ ipcache_nbgethostbyname(const char *name, IPH * handler, void *handlerData)
         debugs(14, 4, "ipcache_nbgethostbyname: HIT for '" << name << "'");
 
         if (i->flags.negcached)
-            IpcacheStats.negative_hits++;
+            ++IpcacheStats.negative_hits;
         else
-            IpcacheStats.hits++;
+            ++IpcacheStats.hits;
 
         i->handler = handler;
 
@@ -688,7 +688,7 @@ ipcache_nbgethostbyname(const char *name, IPH * handler, void *handlerData)
     }
 
     debugs(14, 5, "ipcache_nbgethostbyname: MISS for '" << name << "'");
-    IpcacheStats.misses++;
+    ++IpcacheStats.misses;
     i = ipcacheCreateEntry(name);
     i->handler = handler;
     i->handlerData = cbdataReference(handlerData);
@@ -763,7 +763,7 @@ ipcache_gethostbyname(const char *name, int flags)
     ipcache_addrs *addrs;
     assert(name);
     debugs(14, 3, "ipcache_gethostbyname: '" << name  << "', flags=" << std::hex << flags);
-    IpcacheStats.requests++;
+    ++IpcacheStats.requests;
     i = ipcache_get(name);
 
     if (NULL == i) {
@@ -772,11 +772,11 @@ ipcache_gethostbyname(const char *name, int flags)
         ipcacheRelease(i);
         i = NULL;
     } else if (i->flags.negcached) {
-        IpcacheStats.negative_hits++;
+        ++IpcacheStats.negative_hits;
         // ignore i->error_message: the caller just checks IP cache presence
         return NULL;
     } else {
-        IpcacheStats.hits++;
+        ++IpcacheStats.hits;
         i->lastref = squid_curtime;
         // ignore i->error_message: the caller just checks IP cache presence
         return &i->addrs;
@@ -785,11 +785,11 @@ ipcache_gethostbyname(const char *name, int flags)
     /* no entry [any more] */
 
     if ((addrs = ipcacheCheckNumeric(name))) {
-        IpcacheStats.numeric_hits++;
+        ++IpcacheStats.numeric_hits;
         return addrs;
     }
 
-    IpcacheStats.misses++;
+    ++IpcacheStats.misses;
 
     if (flags & IP_LOOKUP_IF_MISS)
         ipcache_nbgethostbyname(name, NULL, NULL);
@@ -835,7 +835,7 @@ ipcacheStatPrint(ipcache_entry * i, StoreEntry * sentry)
 
     /** \par
      * Cached entries have IPs listed with a BNF of:   ip-address '-' ('OK'|'BAD') */
-    for (k = 0; k < count; k++) {
+    for (k = 0; k < count; ++k) {
         /* Display tidy-up: IPv6 are so big make the list vertical */
         if (k == 0)
             storeAppendPrintf(sentry, " %45.45s-%3s\n",
@@ -987,7 +987,7 @@ ipcacheUnlockEntry(ipcache_entry * i)
         return;
     }
 
-    i->locks--;
+    -- i->locks;
 
     if (ipcacheExpiredEntry(i))
         ipcacheRelease(i);
@@ -1011,7 +1011,7 @@ ipcacheCycleAddr(const char *name, ipcache_addrs * ia)
         ia = &i->addrs;
     }
 
-    for (k = 0; k < ia->count; k++) {
+    for (k = 0; k < ia->count; ++k) {
         if (++ia->cur == ia->count)
             ia->cur = 0;
 
@@ -1023,7 +1023,7 @@ ipcacheCycleAddr(const char *name, ipcache_addrs * ia)
         /* All bad, reset to All good */
         debugs(14, 3, "ipcacheCycleAddr: Changing ALL " << name << " addrs from BAD to OK");
 
-        for (k = 0; k < ia->count; k++)
+        for (k = 0; k < ia->count; ++k)
             ia->bad_mask[k] = 0;
 
         ia->badcount = 0;
@@ -1054,7 +1054,7 @@ ipcacheMarkBadAddr(const char *name, const Ip::Address &addr)
 
     ia = &i->addrs;
 
-    for (k = 0; k < (int) ia->count; k++) {
+    for (k = 0; k < (int) ia->count; ++k) {
         if (addr == ia->in_addrs[k] )
             break;
     }
@@ -1066,7 +1066,7 @@ ipcacheMarkBadAddr(const char *name, const Ip::Address &addr)
     /** Marks the given address as BAD */
     if (!ia->bad_mask[k]) {
         ia->bad_mask[k] = TRUE;
-        ia->badcount++;
+        ++ia->badcount;
         i->expires = min(squid_curtime + max((time_t)60, Config.negativeDnsTtl), i->expires);
         debugs(14, 2, "ipcacheMarkBadAddr: " << name << " " << addr );
     }
@@ -1091,7 +1091,7 @@ ipcacheMarkAllGood(const char *name)
     /* All bad, reset to All good */
     debugs(14, 3, "ipcacheMarkAllGood: Changing ALL " << name << " addrs to OK (" << ia->badcount << "/" << ia->count << " bad)");
 
-    for (k = 0; k < ia->count; k++)
+    for (k = 0; k < ia->count; ++k)
         ia->bad_mask[k] = 0;
 
     ia->badcount = 0;
@@ -1110,7 +1110,7 @@ ipcacheMarkGoodAddr(const char *name, const Ip::Address &addr)
 
     ia = &i->addrs;
 
-    for (k = 0; k < (int) ia->count; k++) {
+    for (k = 0; k < (int) ia->count; ++k) {
         if (addr == ia->in_addrs[k])
             break;
     }
@@ -1123,7 +1123,7 @@ ipcacheMarkGoodAddr(const char *name, const Ip::Address &addr)
 
     ia->bad_mask[k] = FALSE;
 
-    ia->badcount--;
+    -- ia->badcount;
 
     debugs(14, 2, "ipcacheMarkGoodAddr: " << name << " " << addr );
 }
@@ -151,7 +151,7 @@ void
 logfileLineEnd(Logfile * lf)
 {
     lf->f_lineend(lf);
-    lf->sequence_number++;
+    ++ lf->sequence_number;
 }
 
 void
@@ -89,7 +89,7 @@ logfileNewBuffer(Logfile * lf)
     b->written_len = 0;
     b->len = 0;
     dlinkAddTail(b, &b->node, &ll->bufs);
-    ll->nbufs++;
+    ++ ll->nbufs;
 }
 
 static void
@@ -98,7 +98,7 @@ logfileFreeBuffer(Logfile * lf, logfile_buffer_t * b)
     l_daemon_t *ll = (l_daemon_t *) lf->data;
     assert(b != NULL);
     dlinkDelete(&b->node, &ll->bufs);
-    ll->nbufs--;
+    -- ll->nbufs;
     xfree(b->buf);
     xfree(b);
 }
@@ -140,7 +140,7 @@ logfile_mod_stdio_rotate(Logfile * lf)
 
     /* Rotate numbers 0 through N up one */
     for (i = Config.Log.rotateNumber; i > 1;) {
-        i--;
+        --i;
         snprintf(from, MAXPATHLEN, "%s.%d", realpath, i - 1);
         snprintf(to, MAXPATHLEN, "%s.%d", realpath, i);
         xrename(from, to);
@@ -178,7 +178,8 @@ logfile_mod_syslog_open(Logfile * lf, const char *path, size_t bufsz, int fatal_
         if (!facility)
             facility = (char *) strchr(priority, '|');
         if (facility) {
-            *facility++ = '\0';
+            *facility = '\0';
+            ++facility;
             ll->syslog_priority |= syslog_ntoa(facility);
         }
         ll->syslog_priority |= syslog_ntoa(priority);
@@ -411,7 +411,7 @@ fvdbCount(hash_table * hash, const char *key)
         hash_join(hash, &fv->hash);
     }
 
-    fv->n++;
+    ++ fv->n;
 }
 
 void
@@ -505,7 +505,7 @@ mcast_encode(unsigned int *ibuf, size_t isize, const unsigned int *key)
         z = htonl(ibuf[i + 1]);
         sum = 0;
 
-        for (n = 32; n; n--) {
+        for (n = 32; n; --n) {
             sum += delta;
             y += (z << 4) + (k0 ^ z) + (sum ^ (z >> 5)) + k1;
             z += (y << 4) + (k2 ^ y) + (sum ^ (y >> 5)) + k3;
@@ -764,10 +764,13 @@ Mem::Report(std::ostream &stream)
         if (!mp_stats.pool)	/* pool destroyed */
             continue;
 
-        if (mp_stats.pool->getMeter().gb_allocated.count > 0)	/* this pool has been used */
-            sortme[npools++] = mp_stats;
-        else
+        if (mp_stats.pool->getMeter().gb_allocated.count > 0) {
+            /* this pool has been used */
+            sortme[npools] = mp_stats;
+            ++npools;
+        } else {
             ++not_used;
+        }
     }
 
     memPoolIterateDone(&iter);
@@ -71,7 +71,7 @@ mime_get_header_field(const char *mime, const char *name, const char *prefix)
             return NULL;
 
         while (xisspace(*p))
-            p++;
+            ++p;
 
         if (strncasecmp(p, name, namelen))
             continue;
@@ -92,11 +92,15 @@ mime_get_header_field(const char *mime, const char *name, const char *prefix)
 
         q += namelen;
 
-        if (*q == ':')
-            q++, got = 1;
+        if (*q == ':') {
+            ++q;
+            got = 1;
+        }
 
-        while (xisspace(*q))
-            q++, got = 1;
+        while (xisspace(*q)) {
+            ++q;
+            got = 1;
+        }
 
         if (got && prefix) {
             /* we could process list entries here if we had strcasestr(). */
@@ -153,7 +157,7 @@ headersEnd(const char *mime, size_t l)
             break;
         }
 
-        e++;
+        ++e;
     }
     PROF_stop(headersEnd);
 
@@ -65,7 +65,7 @@ mcastJoinGroups(const ipcache_addrs *ia, const DnsLookupDetails &, void *datanot
         return;
     }
 
-    for (i = 0; i < (int) ia->count; i++) {
+    for (i = 0; i < (int) ia->count; ++i) {
         debugs(7, 9, "Listening for ICP requests on " << ia->in_addrs[i] );
 
         if ( ! ia->in_addrs[i].IsIPv4() ) {
@@ -107,7 +107,7 @@ whichPeer(const Ip::Address &from)
     debugs(15, 3, "whichPeer: from " << from);
 
     for (p = Config.peers; p; p = p->next) {
-        for (j = 0; j < p->n_addresses; j++) {
+        for (j = 0; j < p->n_addresses; ++j) {
             if (from == p->addresses[j] && from.GetPort() == p->icp.port) {
                 return p;
             }
@@ -271,7 +271,7 @@ neighborsCount(HttpRequest * request)
 
     for (p = Config.peers; p; p = p->next)
         if (peerWouldBePinged(p, request))
-            count++;
+            ++count;
 
     debugs(15, 3, "neighborsCount: " << count);
 
@@ -332,7 +332,7 @@ getRoundRobinParent(HttpRequest * request)
     }
 
     if (q)
-        q->rr_count++;
+        ++ q->rr_count;
 
     debugs(15, 3, HERE << "returning " << (q ? q->host : "NULL"));
 
@@ -507,7 +507,7 @@ neighborRemove(peer * target)
     if (p) {
         *P = p->next;
         cbdataFree(p);
-        Config.npeers--;
+        --Config.npeers;
     }
 
     first_ping = Config.peers;
@@ -612,7 +612,7 @@ neighborsUdpPing(HttpRequest * request,
         if (!peerWouldBePinged(p, request))
             continue;		/* next peer */
 
-        peers_pinged++;
+        ++peers_pinged;
 
         debugs(15, 4, "neighborsUdpPing: pinging peer " << p->host << " for '" << url << "'");
 
@@ -659,9 +659,9 @@ neighborsUdpPing(HttpRequest * request,
             }
         }
 
-        queries_sent++;
+        ++queries_sent;
 
-        p->stats.pings_sent++;
+        ++ p->stats.pings_sent;
 
         if (p->type == PEER_MULTICAST) {
             mcast_exprep += p->mcast.n_replies_expected;
@@ -670,10 +670,10 @@ neighborsUdpPing(HttpRequest * request,
             /* its alive, expect a reply from it */
 
             if (neighborType(p, request) == PEER_PARENT) {
-                parent_exprep++;
+                ++parent_exprep;
                 parent_timeout += p->stats.rtt;
             } else {
-                sibling_exprep++;
+                ++sibling_exprep;
                 sibling_timeout += p->stats.rtt;
             }
         } else {
@@ -807,7 +807,7 @@ neighborsDigestSelect(HttpRequest * request)
         if (lookup == LOOKUP_NONE)
             continue;
 
-        choice_count++;
+        ++choice_count;
 
         if (lookup == LOOKUP_MISS)
             continue;
@@ -822,7 +822,7 @@ neighborsDigestSelect(HttpRequest * request)
             best_rtt = p_rtt;
 
             if (p_rtt)		/* informative choice (aka educated guess) */
-                ichoice_count++;
+                ++ichoice_count;
 
             debugs(15, 4, "neighborsDigestSelect: peer " << p->host << " leads with rtt " << best_rtt);
         }
@@ -856,10 +856,10 @@ static void
 neighborAlive(peer * p, const MemObject * mem, const icp_common_t * header)
 {
     peerAlive(p);
-    p->stats.pings_acked++;
+    ++ p->stats.pings_acked;
 
     if ((icp_opcode) header->opcode <= ICP_END)
-        p->icp.counts[header->opcode]++;
+        ++ p->icp.counts[header->opcode];
 
     p->icp.version = (int) header->version;
 }
@@ -893,8 +893,8 @@ static void
 neighborAliveHtcp(peer * p, const MemObject * mem, const htcpReplyData * htcp)
 {
     peerAlive(p);
-    p->stats.pings_acked++;
-    p->htcp.counts[htcp->hit ? 1 : 0]++;
+    ++ p->stats.pings_acked;
+    ++ p->htcp.counts[htcp->hit ? 1 : 0];
     p->htcp.version = htcp->version;
 }
 
@@ -906,9 +906,9 @@ neighborCountIgnored(peer * p)
     if (p == NULL)
         return;
 
-    p->stats.ignored_replies++;
+    ++ p->stats.ignored_replies;
 
-    NLateReplies++;
+    ++NLateReplies;
 }
 
 static peer *non_peers = NULL;
@@ -939,7 +939,7 @@ neighborIgnoreNonPeer(const Ip::Address &from, icp_opcode opcode)
         non_peers = np;
     }
 
-    np->icp.counts[opcode]++;
+    ++ np->icp.counts[opcode];
 
     if (isPowTen(++np->stats.ignored_replies))
         debugs(15, 1, "WARNING: Ignored " << np->stats.ignored_replies << " replies from non-peer " << np->host);
@@ -1214,10 +1214,10 @@ peerDNSConfigure(const ipcache_addrs *ia, const DnsLookupDetails &, void *data)
 
     p->tcp_up = p->connect_fail_limit;
 
-    for (j = 0; j < (int) ia->count && j < PEER_MAX_ADDRESSES; j++) {
+    for (j = 0; j < (int) ia->count && j < PEER_MAX_ADDRESSES; ++j) {
         p->addresses[j] = ia->in_addrs[j];
         debugs(15, 2, "--> IP address #" << j << ": " << p->addresses[j]);
-        p->n_addresses++;
+        ++ p->n_addresses;
     }
 
     p->in_addr.SetEmpty();
@@ -1267,7 +1267,7 @@ peerConnectFailedSilent(peer * p)
         return;
     }
 
-    p->tcp_up--;
+    -- p->tcp_up;
 
     if (!p->tcp_up) {
         debugs(15, 1, "Detected DEAD " << neighborTypeStr(p) << ": " << p->name);
@@ -1311,13 +1311,13 @@ peerProbeConnect(peer * p)
         return ret;/* don't probe to often */
 
     /* for each IP address of this peer. find one that we can connect to and probe it. */
-    for (int i = 0; i < p->n_addresses; i++) {
+    for (int i = 0; i < p->n_addresses; ++i) {
         Comm::ConnectionPointer conn = new Comm::Connection;
         conn->remote = p->addresses[i];
         conn->remote.SetPort(p->http_port);
         getOutgoingAddress(NULL, conn);
 
-        p->testing_now++;
+        ++ p->testing_now;
 
         AsyncCall::Pointer call = commCbCall(15,3, "peerProbeConnectDone", CommConnectCbPtrFun(peerProbeConnectDone, p));
         Comm::ConnOpener *cs = new Comm::ConnOpener(conn, call, ctimeout);
@@ -1341,7 +1341,7 @@ peerProbeConnectDone(const Comm::ConnectionPointer &conn, comm_err_t status, int
         peerConnectFailedSilent(p);
     }
 
-    p->testing_now--;
+    -- p->testing_now;
     conn->close();
     // TODO: log this traffic.
 }
@@ -1439,7 +1439,7 @@ peerCountHandleIcpReply(peer * p, peer_t type, AnyP::ProtocolType proto, void *h
     assert(proto == AnyP::PROTO_ICP);
     assert(fake);
     assert(mem);
-    psstate->ping.n_recv++;
+    ++ psstate->ping.n_recv;
     rtt_av_factor = RTT_AV_FACTOR;
 
     if (p->options.weighted_roundrobin)
@@ -1602,7 +1602,7 @@ dump_peers(StoreEntry * sentry, peer * peers)
         storeAppendPrintf(sentry, "Flags      :");
         dump_peer_options(sentry, e);
 
-        for (i = 0; i < e->n_addresses; i++) {
+        for (i = 0; i < e->n_addresses; ++i) {
             storeAppendPrintf(sentry, "Address[%d] : %s\n", i,
                               e->addresses[i].NtoA(ntoabuf,MAX_IPSTRLEN) );
         }
@@ -99,7 +99,7 @@ IdleConnList::removeAt(int index)
         return false;
 
     // shuffle the remaining entries to fill the new gap.
-    for (; index < size_ - 1; index++)
+    for (; index < size_ - 1; ++index)
         theList_[index] = theList_[index + 1];
     theList_[--size_] = NULL;
 
@@ -136,7 +136,7 @@ IdleConnList::closeN(size_t n)
 
         size_t index;
         // ensure the first N entries are closed
-        for (index = 0; index < n; index++) {
+        for (index = 0; index < n; ++index) {
             const Comm::ConnectionPointer conn = theList_[index];
             theList_[index] = NULL;
             clearHandlers(conn);
@@ -145,12 +145,13 @@ IdleConnList::closeN(size_t n)
                 parent_->noteConnectionRemoved();
         }
         // shuffle the list N down.
-        for (index = 0; index < (size_t)size_ - n; index++) {
+        for (index = 0; index < (size_t)size_ - n; ++index) {
             theList_[index] = theList_[index + n];
         }
         // ensure the last N entries are unset
         while (index < ((size_t)size_)) {
-            theList_[index++] = NULL;
+            theList_[index] = NULL;
+            ++index;
         }
         size_ -= n;
     }
@@ -177,7 +178,7 @@ IdleConnList::push(const Comm::ConnectionPointer &conn)
         capacity_ <<= 1;
         const Comm::ConnectionPointer *oldList = theList_;
         theList_ = new Comm::ConnectionPointer[capacity_];
-        for (int index = 0; index < size_; index++)
+        for (int index = 0; index < size_; ++index)
             theList_[index] = oldList[index];
 
         delete[] oldList;
@@ -186,7 +187,8 @@ IdleConnList::push(const Comm::ConnectionPointer &conn)
     if (parent_)
         parent_->noteConnectionAdded();
 
-    theList_[size_++] = conn;
+    theList_[size_] = conn;
+    ++size_;
     AsyncCall::Pointer readCall = commCbCall(5,4, "IdleConnList::Read",
                                   CommIoCbPtrFun(IdleConnList::Read, this));
     comm_read(conn, fakeReadBuf_, sizeof(fakeReadBuf_), readCall);
@@ -216,7 +218,7 @@ IdleConnList::isAvailable(int i) const
 Comm::ConnectionPointer
 IdleConnList::pop()
 {
-    for (int i=size_-1; i>=0; i--) {
+    for (int i=size_-1; i>=0; --i) {
 
         if (!isAvailable(i))
             continue;
@@ -254,7 +256,7 @@ IdleConnList::findUseable(const Comm::ConnectionPointer &key)
     const bool keyCheckAddr = !key->local.IsAnyAddr();
     const bool keyCheckPort = key->local.GetPort() > 0;
 
-    for (int i=size_-1; i>=0; i--) {
+    for (int i=size_-1; i>=0; --i) {
 
         if (!isAvailable(i))
             continue;
@@ -349,7 +351,7 @@ PconnPool::dumpHist(StoreEntry * e) const
                       "\t----  ---------\n",
                       descr);
 
-    for (int i = 0; i < PCONN_HIST_SZ; i++) {
+    for (int i = 0; i < PCONN_HIST_SZ; ++i) {
         if (hist[i] == 0)
             continue;
 
@@ -365,7 +367,8 @@ PconnPool::dumpHash(StoreEntry *e) const
 
     int i = 0;
     for (hash_link *walker = hid->next; walker; walker = hash_next(hid)) {
-        storeAppendPrintf(e, "\t item %5d: %s\n", i++, (char *)(walker->key));
+        storeAppendPrintf(e, "\t item %5d: %s\n", i, (char *)(walker->key));
+        ++i;
     }
 }
 
@@ -377,7 +380,7 @@ PconnPool::PconnPool(const char *aDescr) : table(NULL), descr(aDescr),
     int i;
     table = hash_create((HASHCMP *) strcmp, 229, hash_string);
 
-    for (i = 0; i < PCONN_HIST_SZ; i++)
+    for (i = 0; i < PCONN_HIST_SZ; ++i)
         hist[i] = 0;
 
     PconnModule::GetInstance()->add(this);
@@ -465,7 +468,7 @@ PconnPool::noteUses(int uses)
     if (uses >= PCONN_HIST_SZ)
         uses = PCONN_HIST_SZ - 1;
 
-    hist[uses]++;
+    ++hist[uses];
 }
 
 /* ========== PconnModule ============================================ */
@@ -504,15 +507,15 @@ PconnModule::add(PconnPool *aPool)
 {
     assert(poolCount < MAX_NUM_PCONN_POOLS);
     *(pools+poolCount) = aPool;
-    poolCount++;
+    ++poolCount;
 }
 
 void
 PconnModule::dump(StoreEntry *e)
 {
     int i;
 
-    for (i = 0; i < poolCount; i++) {
+    for (i = 0; i < poolCount; ++i) {
         storeAppendPrintf(e, "\n Pool %d Stats\n", i);
         (*(pools+i))->dumpHist(e);
         storeAppendPrintf(e, "\n Pool %d Hash Table\n",i);
@@ -327,7 +327,7 @@ extern "C" {
                 krb5_kt_default_name(kparam.context, buf, KT_PATH_MAX);
                 p = strchr(buf, ':');
                 if (p)
-                    p++;
+                    ++p;
                 if (keytab_filename)
                     xfree(keytab_filename);
                 keytab_filename = xstrdup(p ? p : buf);
@@ -244,7 +244,7 @@ peerSelectDnsPaths(ps_state *psstate)
         debugs(44, 2, "Found sources for '" << psstate->entry->url() << "'");
         debugs(44, 2, "  always_direct = " << psstate->always_direct);
         debugs(44, 2, "   never_direct = " << psstate->never_direct);
-        for (size_t i = 0; i < psstate->paths->size(); i++) {
+        for (size_t i = 0; i < psstate->paths->size(); ++i) {
             if ((*psstate->paths)[i]->peerType == HIER_DIRECT)
                 debugs(44, 2, "         DIRECT = " << (*psstate->paths)[i]);
             else
@@ -279,7 +279,7 @@ peerSelectDnsResults(const ipcache_addrs *ia, const DnsLookupDetails &details, v
 
         // loop over each result address, adding to the possible destinations.
         int ip = ia->cur;
-        for (int n = 0; n < ia->count; n++, ip++) {
+        for (int n = 0; n < ia->count; ++n, ++ip) {
             Comm::ConnectionPointer p;
 
             if (ip >= ia->count) ip = 0; // looped back to zero.
@@ -700,7 +700,7 @@ peerPingTimeout(void *data)
         return;
     }
 
-    PeerStats.timeouts++;
+    ++PeerStats.timeouts;
     psstate->ping.timedout = 1;
     peerSelectFoo(psstate);
 }
@@ -768,7 +768,7 @@ peerHandleIcpReply(peer * p, peer_t type, icp_common_t * header, void *data)
 
 #endif
 
-    psstate->ping.n_recv++;
+    ++ psstate->ping.n_recv;
 
     if (op == ICP_MISS || op == ICP_DECHO) {
         if (type == PEER_PARENT)
@@ -794,7 +794,7 @@ peerHandleHtcpReply(peer * p, peer_t type, htcpReplyData * htcp, void *data)
     debugs(44, 3, "peerHandleHtcpReply: " <<
            (htcp->hit ? "HIT" : "MISS") << " " <<
            psstate->entry->url()  );
-    psstate->ping.n_recv++;
+    ++ psstate->ping.n_recv;
 
     if (htcp->hit) {
         psstate->hit = p;
@@ -66,7 +66,7 @@ peerSourceHashInit(void)
     char *t;
     /* Clean up */
 
-    for (k = 0; k < n_sourcehash_peers; k++) {
+    for (k = 0; k < n_sourcehash_peers; ++k) {
         cbdataReferenceDone(sourcehash_peers[k]);
     }
 
@@ -83,7 +83,7 @@ peerSourceHashInit(void)
         if (p->weight == 0)
             continue;
 
-        n_sourcehash_peers++;
+        ++n_sourcehash_peers;
 
         W += p->weight;
     }
@@ -106,7 +106,7 @@ peerSourceHashInit(void)
         /* calculate this peers hash */
         p->sourcehash.hash = 0;
 
-        for (t = p->name; *t != 0; t++)
+        for (t = p->name; *t != 0; ++t)
             p->sourcehash.hash += ROTATE_LEFT(p->sourcehash.hash, 19) + (unsigned int) *t;
 
         p->sourcehash.hash += p->sourcehash.hash * 0x62531965;
@@ -142,7 +142,7 @@ peerSourceHashInit(void)
 
     X_last = 0.0;		/* Empty X_0, nullifies the first pow statement */
 
-    for (k = 1; k <= K; k++) {
+    for (k = 1; k <= K; ++k) {
         double Kk1 = (double) (K - k + 1);
         p = sourcehash_peers[k - 1];
         p->sourcehash.load_multiplier = (Kk1 * (p->sourcehash.load_factor - P_last)) / Xn;
@@ -183,11 +183,11 @@ peerSourceHashSelectParent(HttpRequest * request)
     /* calculate hash key */
     debugs(39, 2, "peerSourceHashSelectParent: Calculating hash for " << key);
 
-    for (c = key; *c != 0; c++)
+    for (c = key; *c != 0; ++c)
         user_hash += ROTATE_LEFT(user_hash, 19) + *c;
 
     /* select peer */
-    for (k = 0; k < n_sourcehash_peers; k++) {
+    for (k = 0; k < n_sourcehash_peers; ++k) {
         tp = sourcehash_peers[k];
         combined_hash = (user_hash ^ tp->sourcehash.hash);
         combined_hash += combined_hash * 0x62531965;
@@ -70,7 +70,7 @@ peerUserHashInit(void)
     char *t;
     /* Clean up */
 
-    for (k = 0; k < n_userhash_peers; k++) {
+    for (k = 0; k < n_userhash_peers; ++k) {
         cbdataReferenceDone(userhash_peers[k]);
     }
 
@@ -90,7 +90,7 @@ peerUserHashInit(void)
         if (p->weight == 0)
             continue;
 
-        n_userhash_peers++;
+        ++n_userhash_peers;
 
         W += p->weight;
     }
@@ -111,7 +111,7 @@ peerUserHashInit(void)
         /* calculate this peers hash */
         p->userhash.hash = 0;
 
-        for (t = p->name; *t != 0; t++)
+        for (t = p->name; *t != 0; ++t)
             p->userhash.hash += ROTATE_LEFT(p->userhash.hash, 19) + (unsigned int) *t;
 
         p->userhash.hash += p->userhash.hash * 0x62531965;
@@ -147,7 +147,7 @@ peerUserHashInit(void)
 
     X_last = 0.0;		/* Empty X_0, nullifies the first pow statement */
 
-    for (k = 1; k <= K; k++) {
+    for (k = 1; k <= K; ++k) {
         double Kk1 = (double) (K - k + 1);
         p = userhash_peers[k - 1];
         p->userhash.load_multiplier = (Kk1 * (p->userhash.load_factor - P_last)) / Xn;
@@ -191,11 +191,11 @@ peerUserHashSelectParent(HttpRequest * request)
     /* calculate hash key */
     debugs(39, 2, "peerUserHashSelectParent: Calculating hash for " << key);
 
-    for (c = key; *c != 0; c++)
+    for (c = key; *c != 0; ++c)
         user_hash += ROTATE_LEFT(user_hash, 19) + *c;
 
     /* select peer */
-    for (k = 0; k < n_userhash_peers; k++) {
+    for (k = 0; k < n_userhash_peers; ++k) {
         tp = userhash_peers[k];
         combined_hash = (user_hash ^ tp->userhash.hash);
         combined_hash += combined_hash * 0x62531965;
@@ -89,7 +89,7 @@ main(int argc, char *argv[])
     const char *logfile;
     char ip[4];
 
-    for (len = 0; len < 32; len++) {
+    for (len = 0; len < 32; ++len) {
         signal(len, sig_handle);
     }
 
@@ -135,7 +135,7 @@ redirectStart(ClientHttpRequest * http, RH * handler, void *data)
 
     if (Config.onoff.redirector_bypass && redirectors->stats.queue_size) {
         /* Skip redirector if there is one request queued */
-        n_bypassed++;
+        ++n_bypassed;
         handler(data, NULL);
         return;
     }
@@ -443,8 +443,8 @@ refreshIsCachable(const StoreEntry * entry)
      * be refreshed.
      */
     int reason = refreshCheck(entry, NULL, Config.minimum_expiry_time);
-    refreshCounts[rcStore].total++;
-    refreshCounts[rcStore].status[reason]++;
+    ++ refreshCounts[rcStore].total;
+    ++ refreshCounts[rcStore].status[reason];
 
     if (reason < STALE_MUST_REVALIDATE)
         /* Does not need refresh. This is certainly cachable */
@@ -491,8 +491,8 @@ int
 refreshCheckHTTP(const StoreEntry * entry, HttpRequest * request)
 {
     int reason = refreshCheck(entry, request, 0);
-    refreshCounts[rcHTTP].total++;
-    refreshCounts[rcHTTP].status[reason]++;
+    ++ refreshCounts[rcHTTP].total;
+    ++ refreshCounts[rcHTTP].status[reason];
     request->flags.stale_if_hit = refreshIsStaleIfHit(reason);
     return (Config.onoff.offline || reason < 200) ? 0 : 1;
 }
@@ -501,8 +501,8 @@ int
 refreshCheckICP(const StoreEntry * entry, HttpRequest * request)
 {
     int reason = refreshCheck(entry, request, 30);
-    refreshCounts[rcICP].total++;
-    refreshCounts[rcICP].status[reason]++;
+    ++ refreshCounts[rcICP].total;
+    ++ refreshCounts[rcICP].status[reason];
     return (reason < 200) ? 0 : 1;
 }
 
@@ -511,8 +511,8 @@ int
 refreshCheckHTCP(const StoreEntry * entry, HttpRequest * request)
 {
     int reason = refreshCheck(entry, request, 10);
-    refreshCounts[rcHTCP].total++;
-    refreshCounts[rcHTCP].status[reason]++;
+    ++ refreshCounts[rcHTCP].total;
+    ++ refreshCounts[rcHTCP].status[reason];
     return (reason < 200) ? 0 : 1;
 }
 
@@ -525,8 +525,8 @@ refreshCheckDigest(const StoreEntry * entry, time_t delta)
     int reason = refreshCheck(entry,
                               entry->mem_obj ? entry->mem_obj->request : NULL,
                               delta);
-    refreshCounts[rcCDigest].total++;
-    refreshCounts[rcCDigest].status[reason]++;
+    ++ refreshCounts[rcCDigest].total;
+    ++ refreshCounts[rcCDigest].status[reason];
     return (reason < 200) ? 0 : 1;
 }
 
@@ -244,7 +244,7 @@ lru_purgeNext(RemovalPurgeWalker * walker)
 
     if (entry->locked()) {
         /* Shit, it is locked. we can't return this one */
-        walker->locked++;
+        ++ walker->locked;
         dlinkAddTail(entry, &lru_node->node, &lru->list);
         goto try_again;
     }
@@ -53,7 +53,7 @@ void
 Snmp::Pdu::aggregate(const Pdu& pdu)
 {
     Must(varCount() == pdu.varCount());
-    aggrCount++;
+    ++aggrCount;
     for (variable_list* p_aggr = variables, *p_var = pdu.variables; p_var != NULL;
             p_aggr = p_aggr->next_variable, p_var = p_var->next_variable) {
         Must(p_aggr != NULL);
@@ -210,7 +210,7 @@ snmp_meshPtblFn(variable_list * Var, snint * ErrP)
     *ErrP = SNMP_ERR_NOERROR;
 
     u_int index = Var->name[LEN_SQ_MESH + 3] ;
-    for (p = Config.peers; p != NULL; p = p->next, cnt++) {
+    for (p = Config.peers; p != NULL; p = p->next, ++cnt) {
         if (p->index == index) {
             laddr = p->in_addr ;
             break;
@@ -497,7 +497,7 @@ snmpAgentResponse(struct snmp_pdu *PDU) {
                 oid *NextOidName = NULL;
                 snint NextOidNameLen = 0;
 
-                index++;
+                ++index;
 
                 if (get_next)
                     ParseFn = snmpTreeNext(VarPtr->name, VarPtr->name_length, &NextOidName, &NextOidNameLen);
@@ -568,11 +568,11 @@ snmpTreeGet(oid * Current, snint CurrentLen)
     mibTreeEntry = mib_tree_head;
 
     if (Current[count] == mibTreeEntry->name[count]) {
-        count++;
+        ++count;
 
         while ((mibTreeEntry) && (count < CurrentLen) && (!mibTreeEntry->parsefunction)) {
             mibTreeEntry = snmpTreeEntry(Current[count], count, mibTreeEntry);
-            count++;
+            ++count;
         }
     }
 
@@ -594,13 +594,13 @@ snmpAggrType(oid* Current, snint CurrentLen)
     int count = 0;
 
     if (Current[count] == mibTreeEntry->name[count]) {
-        count++;
+        ++count;
 
         while (mibTreeEntry != NULL && count < CurrentLen) {
             mibTreeEntry = snmpTreeEntry(Current[count], count, mibTreeEntry);
             if (mibTreeEntry != NULL)
                 type = mibTreeEntry->aggrType;
-            count++;
+            ++count;
         }
     }
 
@@ -622,7 +622,7 @@ snmpTreeNext(oid * Current, snint CurrentLen, oid ** Next, snint * NextLen)
     mibTreeEntry = mib_tree_head;
 
     if (Current[count] == mibTreeEntry->name[count]) {
-        count++;
+        ++count;
 
         while ((mibTreeEntry) && (count < CurrentLen) && (!mibTreeEntry->parsefunction)) {
             mib_tree_entry *nextmibTreeEntry = snmpTreeEntry(Current[count], count, mibTreeEntry);
@@ -632,7 +632,7 @@ snmpTreeNext(oid * Current, snint CurrentLen, oid ** Next, snint * NextLen)
             else
                 mibTreeEntry = nextmibTreeEntry;
 
-            count++;
+            ++count;
         }
         debugs(49, 5, "snmpTreeNext: Recursed down to requested object");
     } else {
@@ -654,17 +654,17 @@ snmpTreeNext(oid * Current, snint CurrentLen, oid ** Next, snint * NextLen)
     }
 
     if ((mibTreeEntry) && (mibTreeEntry->parsefunction)) {
-        count--;
+        --count;
         nextoid = snmpTreeSiblingEntry(Current[count], count, mibTreeEntry->parent);
         if (nextoid) {
             debugs(49, 5, "snmpTreeNext: Next OID found for sibling" << nextoid );
             mibTreeEntry = nextoid;
-            count++;
+            ++count;
         } else {
             debugs(49, 5, "snmpTreeNext: Attempting to recurse up for next object");
 
             while (!nextoid) {
-                count--;
+                --count;
 
                 if (mibTreeEntry->parent->parent) {
                     nextoid = mibTreeEntry->parent;
@@ -728,7 +728,7 @@ time_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn)
         identifier = name[*len - 1];
 
         while ((loop < TIME_INDEX_LEN) && (identifier != index[loop]))
-            loop++;
+            ++loop;
 
         if (loop < (TIME_INDEX_LEN - 1)) {
             instance = (oid *)xmalloc(sizeof(name) * (*len));
@@ -862,7 +862,7 @@ snmpTreeSiblingEntry(oid entry, snint len, mib_tree_entry * current)
             next = current->leaves[count];
         }
 
-        count++;
+        ++count;
     }
 
     /* Exactly the sibling on right */
@@ -889,7 +889,7 @@ snmpTreeEntry(oid entry, snint len, mib_tree_entry * current)
             next = current->leaves[count];
         }
 
-        count++;
+        ++count;
     }
 
     return (next);
@@ -902,7 +902,7 @@ snmpAddNodeChild(mib_tree_entry *entry, mib_tree_entry *child)
     entry->leaves = (mib_tree_entry **)xrealloc(entry->leaves, sizeof(mib_tree_entry *) * (entry->children + 1));
     entry->leaves[entry->children] = child;
     entry->leaves[entry->children]->parent = entry;
-    entry->children++;
+    ++ entry->children;
 }
 
 mib_tree_entry *
@@ -931,7 +931,7 @@ snmpLookupNodeStr(mib_tree_entry *root, const char *str)
     while (r < namelen) {
 
         /* Find the child node which matches this */
-        for (i = 0; i < e->children && e->leaves[i]->name[r] != name[r]; i++) ; // seek-loop
+        for (i = 0; i < e->children && e->leaves[i]->name[r] != name[r]; ++i) ; // seek-loop
 
         /* Are we pointing to that node? */
         if (i >= e->children)
@@ -940,7 +940,7 @@ snmpLookupNodeStr(mib_tree_entry *root, const char *str)
 
         /* Skip to that node! */
         e = e->leaves[i];
-        r++;
+        ++r;
     }
 
     xfree(name);
@@ -962,7 +962,7 @@ snmpCreateOidFromStr(const char *str, oid **name, int *nl)
     while ( (p = strsep(&s_, delim)) != NULL) {
         *name = (oid*)xrealloc(*name, sizeof(oid) * ((*nl) + 1));
         (*name)[*nl] = atoi(p);
-        (*nl)++;
+        ++(*nl);
     }
 
     xfree(s);
@@ -1030,7 +1030,7 @@ snmpAddNode(oid * name, int len, oid_ParseFn * parsefunction, instance_Fn * inst
     if (children > 0) {
         entry->leaves = (mib_tree_entry **)xmalloc(sizeof(mib_tree_entry *) * children);
 
-        for (loop = 0; loop < children; loop++) {
+        for (loop = 0; loop < children; ++loop) {
             entry->leaves[loop] = va_arg(args, mib_tree_entry *);
             entry->leaves[loop]->parent = entry;
         }
@@ -1054,7 +1054,7 @@ snmpCreateOid(int length,...)
     new_oid = (oid *)xmalloc(sizeof(oid) * length);
 
     if (length > 0) {
-        for (loop = 0; loop < length; loop++) {
+        for (loop = 0; loop < length; ++loop) {
             new_oid[loop] = va_arg(args, int);
         }
     }
@@ -1073,7 +1073,7 @@ snmpDebugOid(oid * Name, snint Len, MemBuf &outbuf)
     if (outbuf.isNull())
         outbuf.init(16, MAX_IPSTRLEN);
 
-    for (x = 0; x < Len; x++) {
+    for (x = 0; x < Len; ++x) {
         size_t bytes = snprintf(mbuf, sizeof(mbuf), ".%u", (unsigned int) Name[x]);
         outbuf.append(mbuf, bytes);
     }
@@ -1111,9 +1111,10 @@ addr2oid(Ip::Address &addr, oid * Dest)
         addr.GetInAddr(i6addr);
         cp = (u_char *) &i6addr;
     }
-    for ( i=0 ; i < size ; i++) {
+    for ( i=0 ; i < size ; ++i) {
         // OID's are in network order
-        Dest[i] = *cp++;
+        Dest[i] = *cp;
+        ++cp;
     }
     MemBuf tmp;
     debugs(49, 7, "addr2oid: Dest : " << snmpDebugOid(Dest, size, tmp));
@@ -1138,7 +1139,7 @@ oid2addr(oid * id, Ip::Address &addr, u_int size)
         cp = (u_char *) &(i6addr);
     MemBuf tmp;
     debugs(49, 7, "oid2addr: id : " << snmpDebugOid(id, size, tmp) );
-    for (i=0 ; i<size; i++) {
+    for (i=0 ; i<size; ++i) {
         cp[i] = id[i];
     }
     if ( size == sizeof(struct in_addr) )
@@ -1159,7 +1160,7 @@ class ACLSNMPCommunityStrategy : public ACLStrategy<char const *>
     virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *);
     static ACLSNMPCommunityStrategy *Instance();
     /* Not implemented to prevent copies of the instance. */
-    /* Not private to prevent brain dead g+++ warnings about
+    /* Not private to prevent brain dead g++ warnings about
      * private constructors with no friends */
     ACLSNMPCommunityStrategy(ACLSNMPCommunityStrategy const &);
 
@@ -140,13 +140,14 @@ static void loadSslErrorMap()
 static void loadSslErrorShortcutsMap()
 {
     assert(TheSslErrorShortcuts.empty());
-    for (int i = 0; TheSslErrorShortcutsArray[i].name; i++)
+    for (int i = 0; TheSslErrorShortcutsArray[i].name; ++i)
         TheSslErrorShortcuts[TheSslErrorShortcutsArray[i].name] = TheSslErrorShortcutsArray[i].errors;
 }
 
 Ssl::ssl_error_t Ssl::GetErrorCode(const char *name)
 {
-    for (int i = 0; TheSslErrorArray[i].name != NULL; i++) {
+    //TODO: use a std::map?
+    for (int i = 0; TheSslErrorArray[i].name != NULL; ++i) {
         if (strcmp(name, TheSslErrorArray[i].name) == 0)
             return TheSslErrorArray[i].value;
     }
@@ -177,7 +178,7 @@ Ssl::ParseErrorString(const char *name)
         // Should not be empty...
         assert(it->second[0] != SSL_ERROR_NONE);
         Ssl::Errors *errors = new Ssl::Errors(it->second[0]);
-        for (int i =1; it->second[i] != SSL_ERROR_NONE; i++) {
+        for (int i =1; it->second[i] != SSL_ERROR_NONE; ++i) {
             errors->push_back_unique(it->second[i]);
         }
         return errors;
@@ -360,7 +361,7 @@ const char *Ssl::ErrorDetail::err_lib_error() const
 int Ssl::ErrorDetail::convert(const char *code, const char **value) const
 {
     *value = "-";
-    for (int i=0; ErrorFormatingCodes[i].code!=NULL; i++) {
+    for (int i=0; ErrorFormatingCodes[i].code!=NULL; ++i) {
         const int len = strlen(ErrorFormatingCodes[i].code);
         if (strncmp(code,ErrorFormatingCodes[i].code, len)==0) {
             ErrorDetail::fmt_action_t action  = ErrorFormatingCodes[i].fmt_action;
@@ -196,9 +196,10 @@ Ssl::ErrorDetailFile::parse(const char *buffer, int len, bool eof)
 
         //ignore spaces, new lines and comment lines (starting with #) at the beggining
         const char *s;
-        for (s = buf.content(); (*s == '\n' || *s == ' '  || *s == '\t' || *s == '#')  && s < e; s++) {
+        for (s = buf.content(); (*s == '\n' || *s == ' '  || *s == '\t' || *s == '#')  && s < e; ++s) {
             if (*s == '#')
-                while (s<e &&  *s != '\n') s++; // skip untill the end of line
+                while (s<e &&  *s != '\n')
+                    ++s; // skip untill the end of line
         }
 
         if ( s != e) {
@@ -109,14 +109,14 @@ Ssl::CertificateDb::Row::Row()
         :   width(cnlNumber)
 {
     row = new char *[width + 1];
-    for (size_t i = 0; i < width + 1; i++)
+    for (size_t i = 0; i < width + 1; ++i)
         row[i] = NULL;
 }
 
 Ssl::CertificateDb::Row::~Row()
 {
     if (row) {
-        for (size_t i = 0; i < width + 1; i++) {
+        for (size_t i = 0; i < width + 1; ++i) {
             delete[](row[i]);
         }
         delete[](row);
@@ -149,15 +149,16 @@ char ** Ssl::CertificateDb::Row::getRow()
 unsigned long Ssl::CertificateDb::index_serial_hash(const char **a)
 {
     const char *n = a[Ssl::CertificateDb::cnlSerial];
-    while (*n == '0') n++;
+    while (*n == '0')
+        ++n;
     return lh_strhash(n);
 }
 
 int Ssl::CertificateDb::index_serial_cmp(const char **a, const char **b)
 {
     const char *aa, *bb;
-    for (aa = a[Ssl::CertificateDb::cnlSerial]; *aa == '0'; aa++);
-    for (bb = b[Ssl::CertificateDb::cnlSerial]; *bb == '0'; bb++);
+    for (aa = a[Ssl::CertificateDb::cnlSerial]; *aa == '0'; ++aa);
+    for (bb = b[Ssl::CertificateDb::cnlSerial]; *bb == '0'; ++bb);
     return strcmp(aa, bb);
 }
 
@@ -441,7 +442,7 @@ void Ssl::CertificateDb::deleteRow(const char **row, int rowIndex)
 #endif
 
     const Columns db_indexes[]={cnlSerial, cnlName};
-    for (unsigned int i = 0; i < countof(db_indexes); i++) {
+    for (unsigned int i = 0; i < countof(db_indexes); ++i) {
 #if OPENSSL_VERSION_NUMBER >= 0x1000004fL
         if (LHASH_OF(OPENSSL_STRING) *fieldIndex =  db.get()->index[db_indexes[i]])
             lh_OPENSSL_STRING_delete(fieldIndex, (char **)row);
@@ -464,10 +465,10 @@ bool Ssl::CertificateDb::deleteInvalidCertificate()
 
     bool removed_one = false;
 #if OPENSSL_VERSION_NUMBER >= 0x1000004fL
-    for (int i = 0; i < sk_OPENSSL_PSTRING_num(db.get()->data); i++) {
+    for (int i = 0; i < sk_OPENSSL_PSTRING_num(db.get()->data); ++i) {
         const char ** current_row = ((const char **)sk_OPENSSL_PSTRING_value(db.get()->data, i));
 #else
-    for (int i = 0; i < sk_num(db.get()->data); i++) {
+    for (int i = 0; i < sk_num(db.get()->data); ++i) {
         const char ** current_row = ((const char **)sk_value(db.get()->data, i));
 #endif
 
@@ -512,10 +513,10 @@ bool Ssl::CertificateDb::deleteByHostname(std::string const & host)
         return false;
 
 #if OPENSSL_VERSION_NUMBER >= 0x1000004fL
-    for (int i = 0; i < sk_OPENSSL_PSTRING_num(db.get()->data); i++) {
+    for (int i = 0; i < sk_OPENSSL_PSTRING_num(db.get()->data); ++i) {
         const char ** current_row = ((const char **)sk_OPENSSL_PSTRING_value(db.get()->data, i));
 #else
-    for (int i = 0; i < sk_num(db.get()->data); i++) {
+    for (int i = 0; i < sk_num(db.get()->data); ++i) {
         const char ** current_row = ((const char **)sk_value(db.get()->data, i));
 #endif
         if (host == current_row[cnlName]) {
@@ -31,7 +31,7 @@ void Ssl::CertificateStorageAction::dump (StoreEntry *sentry)
     stream << "Port" << delimiter << "Max mem(KB)" << delimiter << "Cert number" << delimiter << "KB/cert" << delimiter << "Mem used(KB)" << delimiter << "Mem free(KB)" << endString;
 
     // Add info for each port.
-    for (std::map<Ip::Address, LocalContextStorage *>::iterator i = TheGlobalContextStorage.storage.begin(); i != TheGlobalContextStorage.storage.end(); i++) {
+    for (std::map<Ip::Address, LocalContextStorage *>::iterator i = TheGlobalContextStorage.storage.begin(); i != TheGlobalContextStorage.storage.end(); ++i) {
         stream << i->first << delimiter;
         LocalContextStorage & ssl_store_policy(*(i->second));
         stream << ssl_store_policy.max_memory / 1024 << delimiter;
@@ -50,7 +50,7 @@ Ssl::LocalContextStorage::LocalContextStorage(size_t aMax_memory)
 
 Ssl::LocalContextStorage::~LocalContextStorage()
 {
-    for (QueueIterator i = lru_queue.begin(); i != lru_queue.end(); i++) {
+    for (QueueIterator i = lru_queue.begin(); i != lru_queue.end(); ++i) {
         delete *i;
     }
 }
@@ -90,7 +90,7 @@ void Ssl::LocalContextStorage::remove(char const * host_name)
 void Ssl::LocalContextStorage::purgeOne()
 {
     QueueIterator i = lru_queue.end();
-    i--;
+    --i;
     if (i != lru_queue.end()) {
         remove((*i)->host_name.c_str());
     }
@@ -131,7 +131,7 @@ Ssl::GlobalContextStorage::GlobalContextStorage()
 
 Ssl::GlobalContextStorage::~GlobalContextStorage()
 {
-    for (std::map<Ip::Address, LocalContextStorage *>::iterator i = storage.begin(); i != storage.end(); i++) {
+    for (std::map<Ip::Address, LocalContextStorage *>::iterator i = storage.begin(); i != storage.end(); ++i) {
         delete i->second;
     }
 }
@@ -161,7 +161,7 @@ void Ssl::GlobalContextStorage::reconfigureFinish()
         reconfiguring = false;
 
         // remove or change old local storages.
-        for (std::map<Ip::Address, LocalContextStorage *>::iterator i = storage.begin(); i != storage.end(); i++) {
+        for (std::map<Ip::Address, LocalContextStorage *>::iterator i = storage.begin(); i != storage.end(); ++i) {
             std::map<Ip::Address, size_t>::iterator conf_i = configureStorage.find(i->first);
             if (conf_i == configureStorage.end()) {
                 storage.erase(i);
@@ -171,7 +171,7 @@ void Ssl::GlobalContextStorage::reconfigureFinish()
         }
 
         // add new local storages.
-        for (std::map<Ip::Address, size_t>::iterator conf_i = configureStorage.begin(); conf_i != configureStorage.end(); conf_i++ ) {
+        for (std::map<Ip::Address, size_t>::iterator conf_i = configureStorage.begin(); conf_i != configureStorage.end(); ++conf_i ) {
             if (storage.find(conf_i->first) == storage.end()) {
                 storage.insert(std::pair<Ip::Address, LocalContextStorage *>(conf_i->first, new LocalContextStorage(conf_i->second)));
             }
@@ -26,7 +26,7 @@ Ssl::CrtdMessage::ParseResult Ssl::CrtdMessage::parse(const char * buffer, size_
         switch (state) {
         case BEFORE_CODE: {
             if (xisspace(*current_pos)) {
-                current_pos++;
+                ++current_pos;
                 break;
             }
             if (xisalpha(*current_pos)) {
@@ -39,7 +39,7 @@ Ssl::CrtdMessage::ParseResult Ssl::CrtdMessage::parse(const char * buffer, size_
         case CODE: {
             if (xisalnum(*current_pos) || *current_pos == '_') {
                 current_block += *current_pos;
-                current_pos++;
+                ++current_pos;
                 break;
             }
             if (xisspace(*current_pos)) {
@@ -53,7 +53,7 @@ Ssl::CrtdMessage::ParseResult Ssl::CrtdMessage::parse(const char * buffer, size_
         }
         case BEFORE_LENGTH: {
             if (xisspace(*current_pos)) {
-                current_pos++;
+                ++current_pos;
                 break;
             }
             if (xisdigit(*current_pos)) {
@@ -66,7 +66,7 @@ Ssl::CrtdMessage::ParseResult Ssl::CrtdMessage::parse(const char * buffer, size_
         case LENGTH: {
             if (xisdigit(*current_pos)) {
                 current_block += *current_pos;
-                current_pos++;
+                ++current_pos;
                 break;
             }
             if (xisspace(*current_pos)) {
@@ -84,7 +84,7 @@ Ssl::CrtdMessage::ParseResult Ssl::CrtdMessage::parse(const char * buffer, size_
                 break;
             }
             if (xisspace(*current_pos)) {
-                current_pos++;
+                ++current_pos;
                 break;
             } else {
                 state = BODY;
@@ -168,7 +168,7 @@ void Ssl::CrtdMessage::parseBody(CrtdMessage::BodyParams & map, std::string & ot
 void Ssl::CrtdMessage::composeBody(CrtdMessage::BodyParams const & map, std::string const & other_part)
 {
     body.clear();
-    for (BodyParams::const_iterator i = map.begin(); i != map.end(); i++) {
+    for (BodyParams::const_iterator i = map.begin(); i != map.end(); ++i) {
         if (i != map.begin())
             body += "\n";
         body += i->first + "=" + i->second;
@@ -620,7 +620,7 @@ bool Ssl::certificateMatchesProperties(X509 *cert, CertificateProperties const &
     bool match = true;
     if (cert1_altnames) {
         int numalts = sk_GENERAL_NAME_num(cert1_altnames);
-        for (int i = 0; match && i < numalts; i++) {
+        for (int i = 0; match && i < numalts; ++i) {
             const GENERAL_NAME *aName = sk_GENERAL_NAME_value(cert1_altnames, i);
             match = sk_GENERAL_NAME_find(cert2_altnames, aName);
         }
@@ -134,7 +134,7 @@ static bool parseBytesOptionValue(size_t * bptr, char const * value)
     char const * number_end = value;
 
     while ((*number_end >= '0' && *number_end <= '9')) {
-        number_end++;
+        ++number_end;
     }
 
     std::string number(number_begin, number_end - number_begin);
@@ -74,8 +74,7 @@ ssl_ask_password_cb(char *buf, int size, int rwflag, void *userdata)
         len = strlen(buf);
 
     while (len > 0 && (buf[len - 1] == '\n' || buf[len - 1] == '\r'))
-
-        len--;
+        --len;
 
     buf[len] = '\0';
 
@@ -178,7 +177,7 @@ int Ssl::matchX509CommonNames(X509 *peer_cert, void *check_data, int (*check_fun
 
     if (altnames) {
         int numalts = sk_GENERAL_NAME_num(altnames);
-        for (int i = 0; i < numalts; i++) {
+        for (int i = 0; i < numalts; ++i) {
             const GENERAL_NAME *check = sk_GENERAL_NAME_value(altnames, i);
             if (check->type != GEN_DNS) {
                 continue;
@@ -473,20 +472,20 @@ ssl_parse_options(const char *options)
 
         case '-':
             mode = MODE_REMOVE;
-            option++;
+            ++option;
             break;
 
         case '+':
             mode = MODE_ADD;
-            option++;
+            ++option;
             break;
 
         default:
             mode = MODE_ADD;
             break;
         }
 
-        for (opttmp = ssl_options; opttmp->name; opttmp++) {
+        for (opttmp = ssl_options; opttmp->name; ++opttmp) {
             if (strcmp(opttmp->name, option) == 0) {
                 opt = opttmp;
                 break;
@@ -690,7 +689,7 @@ ssl_load_crl(SSL_CTX *sslContext, const char *CRLfile)
         if (!X509_STORE_add_crl(st, crl))
             debugs(83, 2, "WARNING: Failed to add CRL from file '" << CRLfile << "'");
         else
-            count++;
+            ++count;
 
         X509_CRL_free(crl);
     }
@@ -1278,7 +1277,7 @@ sslGetUserCertificateChainPEM(SSL *ssl)
 
     mem = BIO_new(BIO_s_mem());
 
-    for (i = 0; i < sk_X509_num(chain); i++) {
+    for (i = 0; i < sk_X509_num(chain); ++i) {
         X509 *cert = sk_X509_value(chain, i);
         PEM_write_bio_X509(mem, cert);
     }
@@ -1375,7 +1374,7 @@ void Ssl::addChainToSslContext(SSL_CTX *sslContext, STACK_OF(X509) *chain)
     if (!chain)
         return;
 
-    for (int i = 0; i < sk_X509_num(chain); i++) {
+    for (int i = 0; i < sk_X509_num(chain); ++i) {
         X509 *cert = sk_X509_value(chain, i);
         if (SSL_CTX_add_extra_chain_cert(sslContext, cert)) {
             // increase the certificate lock
@@ -215,19 +215,19 @@ GetIoStats(Mgr::IoActionData& stats)
 
     stats.http_reads = IOStats.Http.reads;
 
-    for (i = 0; i < _iostats::histSize; i++) {
+    for (i = 0; i < _iostats::histSize; ++i) {
         stats.http_read_hist[i] = IOStats.Http.read_hist[i];
     }
 
     stats.ftp_reads = IOStats.Ftp.reads;
 
-    for (i = 0; i < _iostats::histSize; i++) {
+    for (i = 0; i < _iostats::histSize; ++i) {
         stats.ftp_read_hist[i] = IOStats.Ftp.read_hist[i];
     }
 
     stats.gopher_reads = IOStats.Gopher.reads;
 
-    for (i = 0; i < _iostats::histSize; i++) {
+    for (i = 0; i < _iostats::histSize; ++i) {
         stats.gopher_read_hist[i] = IOStats.Gopher.read_hist[i];
     }
 }
@@ -241,7 +241,7 @@ DumpIoStats(Mgr::IoActionData& stats, StoreEntry* sentry)
     storeAppendPrintf(sentry, "number of reads: %.0f\n", stats.http_reads);
     storeAppendPrintf(sentry, "Read Histogram:\n");
 
-    for (i = 0; i < _iostats::histSize; i++) {
+    for (i = 0; i < _iostats::histSize; ++i) {
         storeAppendPrintf(sentry, "%5d-%5d: %9.0f %2.0f%%\n",
                           i ? (1 << (i - 1)) + 1 : 1,
                           1 << i,
@@ -254,7 +254,7 @@ DumpIoStats(Mgr::IoActionData& stats, StoreEntry* sentry)
     storeAppendPrintf(sentry, "number of reads: %.0f\n", stats.ftp_reads);
     storeAppendPrintf(sentry, "Read Histogram:\n");
 
-    for (i = 0; i < _iostats::histSize; i++) {
+    for (i = 0; i < _iostats::histSize; ++i) {
         storeAppendPrintf(sentry, "%5d-%5d: %9.0f %2.0f%%\n",
                           i ? (1 << (i - 1)) + 1 : 1,
                           1 << i,
@@ -267,7 +267,7 @@ DumpIoStats(Mgr::IoActionData& stats, StoreEntry* sentry)
     storeAppendPrintf(sentry, "number of reads: %.0f\n", stats.gopher_reads);
     storeAppendPrintf(sentry, "Read Histogram:\n");
 
-    for (i = 0; i < _iostats::histSize; i++) {
+    for (i = 0; i < _iostats::histSize; ++i) {
         storeAppendPrintf(sentry, "%5d-%5d: %9.0f %2.0f%%\n",
                           i ? (1 << (i - 1)) + 1 : 1,
                           1 << i,
@@ -1385,10 +1385,10 @@ statInit(void)
     int i;
     debugs(18, 5, "statInit: Initializing...");
 
-    for (i = 0; i < N_COUNT_HIST; i++)
+    for (i = 0; i < N_COUNT_HIST; ++i)
         statCountersInit(&CountHist[i]);
 
-    for (i = 0; i < N_COUNT_HOUR_HIST; i++)
+    for (i = 0; i < N_COUNT_HOUR_HIST; ++i)
         statCountersInit(&CountHourHist[i]);
 
     statCountersInit(&statCounter);
@@ -1419,7 +1419,7 @@ statAvgTick(void *notused)
     statCountersClean(CountHist + N_COUNT_HIST - 1);
     memmove(p, t, (N_COUNT_HIST - 1) * sizeof(StatCounters));
     statCountersCopy(t, c);
-    NCountHist++;
+    ++NCountHist;
 
     if ((NCountHist % COUNT_INTERVAL) == 0) {
         /* we have an hours worth of readings.  store previous hour */
@@ -1429,7 +1429,7 @@ statAvgTick(void *notused)
         statCountersClean(CountHourHist + N_COUNT_HOUR_HIST - 1);
         memmove(p2, t2, (N_COUNT_HOUR_HIST - 1) * sizeof(StatCounters));
         statCountersCopy(t2, c2);
-        NCountHourHist++;
+        ++NCountHourHist;
     }
 
     if (Config.warnings.high_rptm > 0) {
@@ -1795,10 +1795,10 @@ statFreeMemory(void)
 {
     int i;
 
-    for (i = 0; i < N_COUNT_HIST; i++)
+    for (i = 0; i < N_COUNT_HIST; ++i)
         statCountersClean(&CountHist[i]);
 
-    for (i = 0; i < N_COUNT_HOUR_HIST; i++)
+    for (i = 0; i < N_COUNT_HOUR_HIST; ++i)
         statCountersClean(&CountHourHist[i]);
 }
 
@@ -2081,7 +2081,7 @@ statClientRequests(StoreEntry * s)
  */
 
 #define GRAPH_PER_MIN(Y) \
-    for (i=0;i<(N_COUNT_HIST-2);i++) { \
+    for (i=0;i<(N_COUNT_HIST-2);++i) { \
 	dt = tvSubDsec(CountHist[i+1].timestamp, CountHist[i].timestamp); \
 	if (dt <= 0.0) \
 	    break; \
@@ -2091,7 +2091,7 @@ statClientRequests(StoreEntry * s)
     }
 
 #define GRAPH_PER_HOUR(Y) \
-    for (i=0;i<(N_COUNT_HOUR_HIST-2);i++) { \
+    for (i=0;i<(N_COUNT_HOUR_HIST-2);++i) { \
 	dt = tvSubDsec(CountHourHist[i+1].timestamp, CountHourHist[i].timestamp); \
 	if (dt <= 0.0) \
 	    break; \
@@ -514,7 +514,7 @@ void
 
 StoreEntry::lock()
 {
-    lock_count++;
+    ++lock_count;
     debugs(20, 3, "StoreEntry::lock: key '" << getMD5Text() <<"' count=" <<
            lock_count  );
     lastref = squid_curtime;
@@ -555,7 +555,7 @@ StoreEntry::releaseRequest()
 int
 StoreEntry::unlock()
 {
-    lock_count--;
+    --lock_count;
     debugs(20, 3, "StoreEntry::unlock: key '" << getMD5Text() << "' count=" << lock_count);
 
     if (lock_count)
@@ -974,34 +974,34 @@ StoreEntry::checkCachable()
 
     if (mem_obj->method != METHOD_GET) {
         debugs(20, 2, "StoreEntry::checkCachable: NO: non-GET method");
-        store_check_cachable_hist.no.non_get++;
+        ++store_check_cachable_hist.no.non_get;
     } else
 #endif
         if (store_status == STORE_OK && EBIT_TEST(flags, ENTRY_BAD_LENGTH)) {
             debugs(20, 2, "StoreEntry::checkCachable: NO: wrong content-length");
-            store_check_cachable_hist.no.wrong_content_length++;
+            ++store_check_cachable_hist.no.wrong_content_length;
         } else if (!EBIT_TEST(flags, ENTRY_CACHABLE)) {
             debugs(20, 2, "StoreEntry::checkCachable: NO: not cachable");
-            store_check_cachable_hist.no.not_entry_cachable++;
+            ++store_check_cachable_hist.no.not_entry_cachable;
         } else if (EBIT_TEST(flags, ENTRY_NEGCACHED)) {
             debugs(20, 3, "StoreEntry::checkCachable: NO: negative cached");
-            store_check_cachable_hist.no.negative_cached++;
+            ++store_check_cachable_hist.no.negative_cached;
             return 0;           /* avoid release call below */
         } else if ((getReply()->content_length > 0 &&
                     getReply()->content_length
                     > Config.Store.maxObjectSize) ||
                    mem_obj->endOffset() > Config.Store.maxObjectSize) {
             debugs(20, 2, "StoreEntry::checkCachable: NO: too big");
-            store_check_cachable_hist.no.too_big++;
+            ++store_check_cachable_hist.no.too_big;
         } else if (getReply()->content_length > Config.Store.maxObjectSize) {
             debugs(20, 2, "StoreEntry::checkCachable: NO: too big");
-            store_check_cachable_hist.no.too_big++;
+            ++store_check_cachable_hist.no.too_big;
         } else if (checkTooSmall()) {
             debugs(20, 2, "StoreEntry::checkCachable: NO: too small");
-            store_check_cachable_hist.no.too_small++;
+            ++store_check_cachable_hist.no.too_small;
         } else if (EBIT_TEST(flags, KEY_PRIVATE)) {
             debugs(20, 3, "StoreEntry::checkCachable: NO: private key");
-            store_check_cachable_hist.no.private_key++;
+            ++store_check_cachable_hist.no.private_key;
         } else if (swap_status != SWAPOUT_NONE) {
             /*
              * here we checked the swap_status because the remaining
@@ -1011,12 +1011,12 @@ StoreEntry::checkCachable()
             return 1;
         } else if (storeTooManyDiskFilesOpen()) {
             debugs(20, 2, "StoreEntry::checkCachable: NO: too many disk files open");
-            store_check_cachable_hist.no.too_many_open_files++;
+            ++store_check_cachable_hist.no.too_many_open_files;
         } else if (fdNFree() < RESERVED_FD) {
             debugs(20, 2, "StoreEntry::checkCachable: NO: too many FD's open");
-            store_check_cachable_hist.no.too_many_open_fds++;
+            ++store_check_cachable_hist.no.too_many_open_fds;
         } else {
-            store_check_cachable_hist.yes.Default++;
+            ++store_check_cachable_hist.yes.Default;
             return 1;
         }
 
@@ -1107,7 +1107,7 @@ StoreEntry::complete()
 void
 StoreEntry::abort()
 {
-    statCounter.aborted_requests++;
+    ++statCounter.aborted_requests;
     assert(store_status == STORE_PENDING);
     assert(mem_obj != NULL);
     debugs(20, 6, "storeAbort: " << getMD5Text());
@@ -1187,7 +1187,7 @@ storeGetMemSpace(int size)
 
     while ((e = walker->Next(walker))) {
         e->purgeMem();
-        released++;
+        ++released;
 
         if (mem_node::InUseCount() + pages_needed < store_pages_max)
             break;
@@ -1276,7 +1276,7 @@ StoreEntry::release()
              * Fake a call to StoreEntry->lock()  When rebuilding is done,
              * we'll just call StoreEntry->unlock() on these.
              */
-            lock_count++;
+            ++lock_count;
             setReleaseFlag();
             LateReleaseStack.push_back(this);
         } else {
@@ -1315,7 +1315,7 @@ storeLateRelease(void *unused)
         return;
     }
 
-    for (i = 0; i < 10; i++) {
+    for (i = 0; i < 10; ++i) {
         e = LateReleaseStack.count ? LateReleaseStack.pop() : NULL;
 
         if (e == NULL) {
@@ -1325,7 +1325,7 @@ storeLateRelease(void *unused)
         }
 
         e->unlock();
-        n++;
+        ++n;
     }
 
     eventAdd("storeLateRelease", storeLateRelease, NULL, 0.0, 1);
@@ -1644,7 +1644,7 @@ StoreEntry::setMemStatus(mem_status_t new_status)
             debugs(20, 4, "StoreEntry::setMemStatus: inserted mem node " << mem_obj->url << " key: " << getMD5Text());
         }
 
-        hot_obj_count++; // TODO: maintain for the shared hot cache as well
+        ++hot_obj_count; // TODO: maintain for the shared hot cache as well
     } else {
         if (EBIT_TEST(flags, ENTRY_SPECIAL)) {
             debugs(20, 4, "StoreEntry::setMemStatus: special entry " << mem_obj->url);
@@ -1653,7 +1653,7 @@ StoreEntry::setMemStatus(mem_status_t new_status)
             debugs(20, 4, "StoreEntry::setMemStatus: removed mem node " << mem_obj->url);
         }
 
-        hot_obj_count--;
+        --hot_obj_count;
     }
 
     mem_status = new_status;
@@ -1761,7 +1761,7 @@ storeReplAdd(const char *type, REMOVALPOLICYCREATE * create)
     int i;
 
     /* find the number of currently known repl types */
-    for (i = 0; storerepl_list && storerepl_list[i].typestr; i++) {
+    for (i = 0; storerepl_list && storerepl_list[i].typestr; ++i) {
         if (strcmp(storerepl_list[i].typestr, type) == 0) {
             debugs(20, 1, "WARNING: Trying to load store replacement policy " << type << " twice.");
             return;
@@ -1786,7 +1786,7 @@ createRemovalPolicy(RemovalPolicySettings * settings)
 {
     storerepl_entry_t *r;
 
-    for (r = storerepl_list; r && r->typestr; r++) {
+    for (r = storerepl_list; r && r->typestr; ++r) {
         if (strcmp(r->typestr, settings->type) == 0)
             return r->create(settings->args);
     }
@@ -190,7 +190,7 @@ store_client::store_client(StoreEntry *e) : entry (e)
 {
     cmp_offset = 0;
     flags.disk_io_pending = 0;
-    entry->refcount++;
+    ++ entry->refcount;
 
     if (getType() == STORE_DISK_CLIENT)
         /* assert we'll be able to get the data we want */
@@ -701,15 +701,15 @@ storeUnregister(store_client * sc, StoreEntry * e, void *data)
     }
 
     dlinkDelete(&sc->node, &mem->clients);
-    mem->nclients--;
+    -- mem->nclients;
 
     if (e->store_status == STORE_OK && e->swap_status != SWAPOUT_DONE)
         e->swapOut();
 
     if (sc->swapin_sio != NULL) {
         storeClose(sc->swapin_sio, StoreIOState::readerDone);
         sc->swapin_sio = NULL;
-        statCounter.swap.ins++;
+        ++statCounter.swap.ins;
     }
 
     if (sc->_callback.pending()) {
@@ -758,7 +758,8 @@ StoreEntry::invokeHandlers()
     for (node = mem_obj->clients.head; node; node = nx) {
         sc = (store_client *)node->data;
         nx = node->next;
-        debugs(90, 3, "StoreEntry::InvokeHandlers: checking client #" << i++  );
+        debugs(90, 3, "StoreEntry::InvokeHandlers: checking client #" << i  );
+        ++i;
 
         if (!sc->_callback.pending())
             continue;
@@ -165,10 +165,10 @@ storeDigestDel(const StoreEntry * entry)
 
     if (!EBIT_TEST(entry->flags, KEY_PRIVATE)) {
         if (!cacheDigestTest(store_digest,  (const cache_key *)entry->key)) {
-            sd_stats.del_lost_count++;
+            ++sd_stats.del_lost_count;
             debugs(71, 6, "storeDigestDel: lost entry, key: " << entry->getMD5Text() << " url: " << entry->url()  );
         } else {
-            sd_stats.del_count++;
+            ++sd_stats.del_count;
             cacheDigestDel(store_digest,  (const cache_key *)entry->key);
             debugs(71, 6, "storeDigestDel: deled entry, key: " << entry->getMD5Text());
         }
@@ -275,19 +275,19 @@ storeDigestAdd(const StoreEntry * entry)
     assert(entry && store_digest);
 
     if (storeDigestAddable(entry)) {
-        sd_stats.add_count++;
+        ++sd_stats.add_count;
 
         if (cacheDigestTest(store_digest, (const cache_key *)entry->key))
-            sd_stats.add_coll_count++;
+            ++sd_stats.add_coll_count;
 
         cacheDigestAdd(store_digest,  (const cache_key *)entry->key);
 
         debugs(71, 6, "storeDigestAdd: added entry, key: " << entry->getMD5Text());
     } else {
-        sd_stats.rej_count++;
+        ++sd_stats.rej_count;
 
         if (cacheDigestTest(store_digest,  (const cache_key *)entry->key))
-            sd_stats.rej_coll_count++;
+            ++sd_stats.rej_coll_count;
     }
 }
 
@@ -337,7 +337,7 @@ storeDigestRebuildFinish(void)
 {
     assert(sd_state.rebuild_lock);
     sd_state.rebuild_lock = 0;
-    sd_state.rebuild_count++;
+    ++sd_state.rebuild_count;
     debugs(71, 2, "storeDigestRebuildFinish: done.");
     eventAdd("storeDigestRebuildStart", storeDigestRebuildStart, NULL, (double)
              Config.digest.rebuild_period, 1);
@@ -444,7 +444,7 @@ storeDigestRewriteFinish(StoreEntry * e)
     e->mem_obj->unlinkRequest();
     e->unlock();
     sd_state.rewrite_lock = NULL;
-    sd_state.rewrite_count++;
+    ++sd_state.rewrite_count;
     eventAdd("storeDigestRewriteStart", storeDigestRewriteStart, NULL, (double)
              Config.digest.rewrite_period, 1);
     /* resume pending Rebuild if any */
@@ -204,7 +204,7 @@ storeDirSelectSwapDirRoundRobin(const StoreEntry * e)
     if (objsize != -1)
         objsize += e->mem_obj->swap_hdr_sz;
 
-    for (i = 0; i < Config.cacheSwap.n_configured; i++) {
+    for (i = 0; i < Config.cacheSwap.n_configured; ++i) {
         if (++dirn >= Config.cacheSwap.n_configured)
             dirn = 0;
 
@@ -253,7 +253,7 @@ storeDirSelectSwapDirLeastLoad(const StoreEntry * e)
     if (objsize != -1)
         objsize += e->mem_obj->swap_hdr_sz;
 
-    for (i = 0; i < Config.cacheSwap.n_configured; i++) {
+    for (i = 0; i < Config.cacheSwap.n_configured; ++i) {
         SD = dynamic_cast<SwapDir *>(INDEXSD(i));
         SD->flags.selected = 0;
 
@@ -456,7 +456,7 @@ storeDirWriteCleanLogs(int reopen)
     getCurrentTime();
     start = current_time;
 
-    for (dirn = 0; dirn < Config.cacheSwap.n_configured; dirn++) {
+    for (dirn = 0; dirn < Config.cacheSwap.n_configured; ++dirn) {
         sd = dynamic_cast<SwapDir *>(INDEXSD(dirn));
 
         if (sd->writeCleanStart() < 0) {
@@ -473,7 +473,7 @@ storeDirWriteCleanLogs(int reopen)
     while (notdone) {
         notdone = 0;
 
-        for (dirn = 0; dirn < Config.cacheSwap.n_configured; dirn++) {
+        for (dirn = 0; dirn < Config.cacheSwap.n_configured; ++dirn) {
             sd = dynamic_cast<SwapDir *>(INDEXSD(dirn));
 
             if (NULL == sd->cleanLog)
@@ -500,7 +500,7 @@ storeDirWriteCleanLogs(int reopen)
     }
 
     /* Flush */
-    for (dirn = 0; dirn < Config.cacheSwap.n_configured; dirn++)
+    for (dirn = 0; dirn < Config.cacheSwap.n_configured; ++dirn)
         dynamic_cast<SwapDir *>(INDEXSD(dirn))->writeCleanDone();
 
     if (reopen)
@@ -663,7 +663,7 @@ free_cachedir(SquidConfig::_cacheSwap * swap)
     if (reconfiguring)
         return;
 
-    for (i = 0; i < swap->n_configured; i++) {
+    for (i = 0; i < swap->n_configured; ++i) {
         /* TODO XXX this lets the swapdir free resources asynchronously
         * swap->swapDirs[i]->deactivate();
         * but there may be such a means already.
@@ -879,7 +879,7 @@ StoreHashIndex::callback()
     do {
         j = 0;
 
-        for (int i = 0; i < Config.cacheSwap.n_configured; i++) {
+        for (int i = 0; i < Config.cacheSwap.n_configured; ++i) {
             if (ndir >= Config.cacheSwap.n_configured)
                 ndir = ndir % Config.cacheSwap.n_configured;
 
@@ -896,15 +896,15 @@ StoreHashIndex::callback()
         }
     } while (j > 0);
 
-    ndir++;
+    ++ndir;
 
     return result;
 }
 
 void
 StoreHashIndex::create()
 {
-    for (int i = 0; i < Config.cacheSwap.n_configured; i++) {
+    for (int i = 0; i < Config.cacheSwap.n_configured; ++i) {
         if (dir(i).active())
             store(i)->create();
     }
@@ -950,7 +950,7 @@ StoreHashIndex::init()
     store_table = hash_create(storeKeyHashCmp,
                               store_hash_buckets, storeKeyHashHash);
 
-    for (int i = 0; i < Config.cacheSwap.n_configured; i++) {
+    for (int i = 0; i < Config.cacheSwap.n_configured; ++i) {
         /* this starts a search of the store dirs, loading their
          * index. under the new Store api this should be
          * driven by the StoreHashIndex, not by each store.
@@ -975,7 +975,7 @@ StoreHashIndex::maxSize() const
 {
     uint64_t result = 0;
 
-    for (int i = 0; i < Config.cacheSwap.n_configured; i++) {
+    for (int i = 0; i < Config.cacheSwap.n_configured; ++i) {
         if (dir(i).doReportStat())
             result += store(i)->maxSize();
     }
@@ -988,7 +988,7 @@ StoreHashIndex::minSize() const
 {
     uint64_t result = 0;
 
-    for (int i = 0; i < Config.cacheSwap.n_configured; i++) {
+    for (int i = 0; i < Config.cacheSwap.n_configured; ++i) {
         if (dir(i).doReportStat())
             result += store(i)->minSize();
     }
@@ -1001,7 +1001,7 @@ StoreHashIndex::currentSize() const
 {
     uint64_t result = 0;
 
-    for (int i = 0; i < Config.cacheSwap.n_configured; i++) {
+    for (int i = 0; i < Config.cacheSwap.n_configured; ++i) {
         if (dir(i).doReportStat())
             result += store(i)->currentSize();
     }
@@ -1014,7 +1014,7 @@ StoreHashIndex::currentCount() const
 {
     uint64_t result = 0;
 
-    for (int i = 0; i < Config.cacheSwap.n_configured; i++) {
+    for (int i = 0; i < Config.cacheSwap.n_configured; ++i) {
         if (dir(i).doReportStat())
             result += store(i)->currentCount();
     }
@@ -1027,7 +1027,7 @@ StoreHashIndex::maxObjectSize() const
 {
     int64_t result = -1;
 
-    for (int i = 0; i < Config.cacheSwap.n_configured; i++) {
+    for (int i = 0; i < Config.cacheSwap.n_configured; ++i) {
         if (dir(i).active() && store(i)->maxObjectSize() > result)
             result = store(i)->maxObjectSize();
     }
@@ -1039,7 +1039,7 @@ void
 StoreHashIndex::getStats(StoreInfoStats &stats) const
 {
     // accumulate per-disk cache stats
-    for (int i = 0; i < Config.cacheSwap.n_configured; i++) {
+    for (int i = 0; i < Config.cacheSwap.n_configured; ++i) {
         StoreInfoStats dirStats;
         store(i)->getStats(dirStats);
         stats += dirStats;
@@ -1058,7 +1058,7 @@ StoreHashIndex::stat(StoreEntry & output) const
 
     /* Now go through each store, calling its stat routine */
 
-    for (i = 0; i < Config.cacheSwap.n_configured; i++) {
+    for (i = 0; i < Config.cacheSwap.n_configured; ++i) {
         storeAppendPrintf(&output, "\n");
         store(i)->stat(output);
     }
@@ -1082,7 +1082,7 @@ StoreHashIndex::maintain()
     int i;
     /* walk each fs */
 
-    for (i = 0; i < Config.cacheSwap.n_configured; i++) {
+    for (i = 0; i < Config.cacheSwap.n_configured; ++i) {
         /* XXX FixMe: This should be done "in parallell" on the different
          * cache_dirs, not one at a time.
          */
@@ -1177,6 +1177,6 @@ StoreSearchHashIndex::copyBucket()
         entries.push_back(e);
     }
 
-    bucket++;
+    ++bucket;
     debugs(47,3, "got entries: " << entries.size());
 }
@@ -16,7 +16,7 @@ storeCreate(StoreEntry * e, StoreIOState::STFNCB * file_callback, StoreIOState::
 {
     assert (e);
 
-    store_io_stats.create.calls++;
+    ++store_io_stats.create.calls;
 
     /*
      * Pick the swapdir
@@ -26,7 +26,7 @@ storeCreate(StoreEntry * e, StoreIOState::STFNCB * file_callback, StoreIOState::
 
     if (dirn == -1) {
         debugs(20, 2, "storeCreate: no swapdirs for " << *e);
-        store_io_stats.create.select_fail++;
+        ++store_io_stats.create.select_fail;
         return NULL;
     }
 
@@ -37,9 +37,9 @@ storeCreate(StoreEntry * e, StoreIOState::STFNCB * file_callback, StoreIOState::
     StoreIOState::Pointer sio = SD->createStoreIO(*e, file_callback, close_callback, callback_data);
 
     if (sio == NULL)
-        store_io_stats.create.create_fail++;
+        ++store_io_stats.create.create_fail;
     else
-        store_io_stats.create.success++;
+        ++store_io_stats.create.success;
 
     return sio;
 }
@@ -44,7 +44,7 @@ storeKeyText(const cache_key *key)
     static char buf[SQUID_MD5_DIGEST_LENGTH * 2+1];
     int i;
 
-    for (i = 0; i < SQUID_MD5_DIGEST_LENGTH; i++)
+    for (i = 0; i < SQUID_MD5_DIGEST_LENGTH; ++i)
         snprintf(&buf[i*2],sizeof(buf) - i*2, "%02X", *(key + i));
 
     return buf;
@@ -58,7 +58,7 @@ storeKeyScan(const char *buf)
     int j = 0;
     char t[3];
 
-    for (i = 0; i < SQUID_MD5_DIGEST_LENGTH; i++) {
+    for (i = 0; i < SQUID_MD5_DIGEST_LENGTH; ++i) {
         t[0] = *(buf + (j++));
         t[1] = *(buf + (j++));
         t[2] = '\0';
@@ -75,7 +75,7 @@ storeKeyHashCmp(const void *a, const void *b)
     const unsigned char *B = (const unsigned char *)b;
     int i;
 
-    for (i = 0; i < SQUID_MD5_DIGEST_LENGTH; i++) {
+    for (i = 0; i < SQUID_MD5_DIGEST_LENGTH; ++i) {
         if (A[i] < B[i])
             return -1;
 
@@ -68,7 +68,7 @@ storeLog(int tag, const StoreEntry * e)
     if (NULL == storelog)
         return;
 
-    storeLogTagsCounts[tag]++;
+    ++storeLogTagsCounts[tag];
     if (mem != NULL) {
         if (mem->log_url == NULL) {
             debugs(20, 1, "storeLog: NULL log_url for " << mem->url);
@@ -161,7 +161,7 @@ void
 storeLogTagsHist(StoreEntry *e)
 {
     int tag;
-    for (tag = 0; tag <= STORE_LOG_SWAPOUTFAIL; tag++) {
+    for (tag = 0; tag <= STORE_LOG_SWAPOUTFAIL; ++tag) {
         storeAppendPrintf(e, "%s %d\n",
                           storeLogTags[tag],
                           storeLogTagsCounts[tag]);
@@ -92,7 +92,7 @@ storeCleanup(void *datanotused)
 
         if (opt_store_doublecheck)
             if (storeCleanupDoubleCheck(e))
-                store_errors++;
+                ++store_errors;
 
         EBIT_SET(e->flags, ENTRY_VALIDATED);
 
@@ -110,7 +110,7 @@ storeCleanup(void *datanotused)
         debugs(20, 1, "  Completed Validation Procedure");
         debugs(20, 1, "  Validated " << validated << " Entries");
         debugs(20, 1, "  store_swap_size = " << Store::Root().currentSize() / 1024.0 << " KB");
-        StoreController::store_dirs_rebuilding--;
+        --StoreController::store_dirs_rebuilding;
         assert(0 == StoreController::store_dirs_rebuilding);
 
         if (opt_store_doublecheck && store_errors) {
@@ -227,7 +227,7 @@ storeRebuildProgress(int sd_index, int total, int sofar)
     if (squid_curtime - last_report < 15)
         return;
 
-    for (sd_index = 0; sd_index < Config.cacheSwap.n_configured; sd_index++) {
+    for (sd_index = 0; sd_index < Config.cacheSwap.n_configured; ++sd_index) {
         n += (double) RebuildProgress[sd_index].scanned;
         d += (double) RebuildProgress[sd_index].total;
     }
@@ -297,7 +297,7 @@ storeRebuildLoadEntry(int fd, int diskIndex, MemBuf &buf,
     assert(buf.hasSpace()); // caller must allocate
 
     const int len = FD_READ_METHOD(fd, buf.space(), buf.spaceSize());
-    statCounter.syscalls.disk.reads++;
+    ++ statCounter.syscalls.disk.reads;
     if (len < 0) {
         const int xerrno = errno;
         debugs(47, DBG_IMPORTANT, "WARNING: cache_dir[" << diskIndex << "]: " <<
@@ -368,7 +368,7 @@ storeRebuildParseEntry(MemBuf &buf, StoreEntry &tmpe, cache_key *key,
     }
 
     if (EBIT_TEST(tmpe.flags, KEY_PRIVATE)) {
-        counts.badflags++;
+        ++ counts.badflags;
         return false;
     }
 
@@ -402,7 +402,7 @@ storeRebuildKeepEntry(const StoreEntry &tmpe, const cache_key *key,
         if (e->lastref >= tmpe.lastref) {
             /* key already exists, old entry is newer */
             /* keep old, ignore new */
-            counts.dupcount++;
+            ++counts.dupcount;
 
             // For some stores, get() creates/unpacks a store entry. Signal
             // such stores that we will no longer use the get() result:
@@ -414,7 +414,7 @@ storeRebuildKeepEntry(const StoreEntry &tmpe, const cache_key *key,
             /* URL already exists, this swapfile not being used */
             /* junk old, load new */
             e->release();	/* release old entry */
-            counts.dupcount++;
+            ++counts.dupcount;
         }
     }
 
@@ -125,22 +125,24 @@ storeSwapMetaPack(tlv * tlv_list, int *length)
     int j = 0;
     char *buf;
     assert(length != NULL);
-    buflen++;			/* STORE_META_OK */
+    ++buflen;			/* STORE_META_OK */
     buflen += sizeof(int);	/* size of header to follow */
 
     for (t = tlv_list; t; t = t->next)
         buflen += sizeof(char) + sizeof(int) + t->length;
 
     buf = (char *)xmalloc(buflen);
 
-    buf[j++] = (char) STORE_META_OK;
+    buf[j] = (char) STORE_META_OK;
+    ++j;
 
     memcpy(&buf[j], &buflen, sizeof(int));
 
     j += sizeof(int);
 
     for (t = tlv_list; t; t = t->next) {
-        buf[j++] = t->getType();
+        buf[j] = t->getType();
+        ++j;
         memcpy(&buf[j], &t->length, sizeof(int));
         j += sizeof(int);
         memcpy(&buf[j], t->value, t->length);
@@ -190,22 +190,22 @@ fileIteratorAdvance(FileIterator * fi)
         const time_t last_time = fi->inner_time;
         fi->inner_time = -1;
         res = fi->reader(fi);
-        fi->line_count++;
+        ++ fi->line_count;
 
         if (fi->inner_time < 0)
             fi->inner_time = last_time;
         else
             fi->inner_time += fi->time_offset;
 
         if (res == frError)
-            fi->bad_line_count++;
+            ++ fi->bad_line_count;
         else if (res == frEof) {
             fprintf(stderr, "exhausted %s (%d entries) at %s",
                     fi->fname, fi->line_count, ctime(&fi->inner_time));
             fi->inner_time = -1;
         } else if (fi->inner_time < last_time) {
             assert(last_time >= 0);
-            fi->time_warp_count++;
+            ++ fi->time_warp_count;
             fi->inner_time = last_time;
         }
 
@@ -332,18 +332,18 @@ cacheQueryPeer(Cache * cache, const cache_key * key)
     const int peer_has_it = hash_lookup(cache->peer->hash, key) != NULL;
     const int we_think_we_have_it = cacheDigestTest(cache->digest, key);
 
-    cache->qstats.query_count++;
+    ++ cache->qstats.query_count;
 
     if (peer_has_it) {
         if (we_think_we_have_it)
-            cache->qstats.true_hit_count++;
+            ++ cache->qstats.true_hit_count;
         else
-            cache->qstats.false_miss_count++;
+            ++ cache->qstats.false_miss_count;
     } else {
         if (we_think_we_have_it)
-            cache->qstats.false_hit_count++;
+            ++ cache->qstats.false_hit_count;
         else
-            cache->qstats.true_miss_count++;
+            ++ cache->qstats.true_miss_count;
     }
 }
 
@@ -383,7 +383,7 @@ static void
 cacheFetch(Cache * cache, const RawAccessLogEntry * e)
 {
     assert(e);
-    cache->req_count++;
+    ++ cache->req_count;
 
     if (e->use_icp)
         cacheQueryPeer(cache, e->key);
@@ -465,9 +465,9 @@ accessLogReader(FileIterator * fi)
     }
 
     while (*url)
-        url--;
+        --url;
 
-    url++;
+    ++url;
 
     *hier = '\0';
 
@@ -505,7 +505,7 @@ cachePurge(Cache * cache, storeSwapLogData * s, int update_digest)
     CacheEntry *olde = (CacheEntry *) hash_lookup(cache->hash, s->key);
 
     if (!olde) {
-        cache->bad_del_count++;
+        ++ cache->bad_del_count;
     } else {
         assert(cache->count);
         hash_remove_link(cache->hash, (hash_link *) olde);
@@ -515,7 +515,7 @@ cachePurge(Cache * cache, storeSwapLogData * s, int update_digest)
 
         cacheEntryDestroy(olde);
 
-        cache->count--;
+        -- cache->count;
     }
 }
 
@@ -525,11 +525,11 @@ cacheStore(Cache * cache, storeSwapLogData * s, int update_digest)
     CacheEntry *olde = (CacheEntry *) hash_lookup(cache->hash, s->key);
 
     if (olde) {
-        cache->bad_add_count++;
+        ++ cache->bad_add_count;
     } else {
         CacheEntry *e = cacheEntryCreate(s);
         hash_join(cache->hash, (hash_link *)&e->key);
-        cache->count++;
+        ++ cache->count;
 
         if (update_digest)
             cacheDigestAdd(cache->digest, e->key);
@@ -642,7 +642,7 @@ main(int argc, char *argv[])
                     next_time = fis[i]->inner_time;
                 }
 
-                active_fi_count++;
+                ++active_fi_count;
             }
         }
 
@@ -52,7 +52,7 @@ void parse_eol(char *volatile *var) STUB
         self_destruct();
 
     while (*token && xisspace(*token))
-        token++;
+        ++token;
 
     if (!*token)
         self_destruct();
@@ -50,7 +50,7 @@ find_proxy_auth(char const *type)
         {"negotiate", "Negotiate "}
     };
 
-    for (unsigned count = 0; count < 4 ; count++) {
+    for (unsigned count = 0; count < 4 ; ++count) {
         if (strcasecmp(type, proxy_auths[count][0]) == 0)
             return proxy_auths[count][1];
     }
@@ -89,7 +89,7 @@ setup_scheme(Auth::Config *scheme, char const **params, unsigned param_count)
 {
     Auth::ConfigVector &config = Auth::TheConfig;
 
-    for (unsigned position=0; position < param_count; position++) {
+    for (unsigned position=0; position < param_count; ++position) {
         char *param_str=xstrdup(params[position]);
         strtok(param_str, w_space);
         scheme->parse(scheme, config.size(), param_str);
@@ -133,7 +133,7 @@ fake_auth_setup()
         {"negotiate", negotiate_parms, 1}
     };
 
-    for (unsigned scheme=0; scheme < 4; scheme++) {
+    for (unsigned scheme=0; scheme < 4; ++scheme) {
         Auth::Config *schemeConfig;
         schemeConfig = getConfig(params[scheme].name);
         if (schemeConfig != NULL)
@@ -87,7 +87,7 @@ testEvent::testDump()
     /* loop over the strings, showing exactly where they differ (if at all) */
     printf("Actual Text:\n");
     /* TODO: these should really be just [] lookups, but String doesn't have those here yet. */
-    for ( unsigned int i = 0; i < anEntry->_appended_text.size(); i++) {
+    for ( unsigned int i = 0; i < anEntry->_appended_text.size(); ++i) {
         CPPUNIT_ASSERT( expect[i] );
         CPPUNIT_ASSERT( anEntry->_appended_text[i] );
 
@@ -93,7 +93,7 @@ addedEntry(StorePointer hashStore,
     e->swap_filen = 0; /* garh - lower level*/
     e->swap_dirn = -1;
 
-    for (int i=0; i < Config.cacheSwap.n_configured; i++) {
+    for (int i=0; i < Config.cacheSwap.n_configured; ++i) {
         if (INDEXSD (i) == aStore.getRaw())
             e->swap_dirn = i;
     }
@@ -74,7 +74,7 @@ addedEntry(StorePointer hashStore,
     e->swap_filen = 0; /* garh - lower level*/
     e->swap_dirn = -1;
 
-    for (int i=0; i < Config.cacheSwap.n_configured; i++) {
+    for (int i=0; i < Config.cacheSwap.n_configured; ++i) {
         if (INDEXSD (i) == aStore.getRaw())
             e->swap_dirn = i;
     }
@@ -1313,12 +1313,12 @@ strwordquote(MemBuf * mb, const char *str)
 
         case '\n':
             mb->append("\\n", 2);
-            str++;
+            ++str;
             break;
 
         case '\r':
             mb->append("\\r", 2);
-            str++;
+            ++str;
             break;
 
         case '\0':
@@ -1327,7 +1327,7 @@ strwordquote(MemBuf * mb, const char *str)
         default:
             mb->append("\\", 1);
             mb->append(str, 1);
-            str++;
+            ++str;
             break;
         }
     }
@@ -1363,9 +1363,11 @@ restoreCapabilities(int keep)
         int ncaps = 0;
         int rc = 0;
         cap_value_t cap_list[10];
-        cap_list[ncaps++] = CAP_NET_BIND_SERVICE;
+        cap_list[ncaps] = CAP_NET_BIND_SERVICE;
+        ++ncaps;
         if (Ip::Interceptor.TransparentActive() || Ip::Qos::TheConfig.isHitNfmarkActive() || Ip::Qos::TheConfig.isAclNfmarkActive()) {
-            cap_list[ncaps++] = CAP_NET_ADMIN;
+            cap_list[ncaps] = CAP_NET_ADMIN;
+            ++ncaps;
         }
 
         cap_clear_flag(caps, CAP_EFFECTIVE);
@@ -652,8 +652,8 @@ tunnelStart(ClientHttpRequest * http, int64_t * size_ptr, int *status_ptr)
     }
 
     debugs(26, 3, HERE << "'" << RequestMethodStr(request->method) << " " << url << " " << request->http_ver << "'");
-    statCounter.server.all.requests++;
-    statCounter.server.other.requests++;
+    ++statCounter.server.all.requests;
+    ++statCounter.server.other.requests;
 
     tunnelState = new TunnelStateData;
 #if USE_DELAY_POOLS
@@ -108,9 +108,9 @@ unlinkdUnlink(const char *path)
         if (bytes_read > 0) {
             rbuf[bytes_read] = '\0';
 
-            for (i = 0; i < bytes_read; i++)
+            for (i = 0; i < bytes_read; ++i)
                 if ('\n' == rbuf[i])
-                    queuelen--;
+                    --queuelen;
 
             assert(queuelen >= 0);
         }
@@ -119,7 +119,8 @@ unlinkdUnlink(const char *path)
     l = strlen(path);
     assert(l < MAXPATHLEN);
     xstrncpy(buf, path, MAXPATHLEN);
-    buf[l++] = '\n';
+    buf[l] = '\n';
+    ++l;
     bytes_written = write(unlinkd_wfd, buf, l);
 
     if (bytes_written < 0) {
@@ -139,7 +140,7 @@ unlinkdUnlink(const char *path)
     * in counting unlink operations.
     */
     ++statCounter.syscalls.disk.unlinks;
-    queuelen++;
+    ++queuelen;
 }
 
 void
@@ -254,7 +254,7 @@ urlParse(const HttpRequestMethod& method, char *url, HttpRequest *request)
         src = url;
         i = 0;
         /* Find first : - everything before is protocol */
-        for (i = 0, dst = proto; i < l && *src != ':'; i++, src++, dst++) {
+        for (i = 0, dst = proto; i < l && *src != ':'; ++i, ++src, ++dst) {
             *dst = *src;
         }
         if (i >= l)
@@ -271,7 +271,7 @@ urlParse(const HttpRequestMethod& method, char *url, HttpRequest *request)
         // bug 1881: If we don't get a "/" then we imply it was there
         // bug 3074: We could just be given a "?" or "#". These also imply "/"
         // bug 3233: whitespace is also a hostname delimiter.
-        for (dst = host; i < l && *src != '/' && *src != '?' && *src != '#' && *src != '\0' && !xisspace(*src); i++, src++, dst++) {
+        for (dst = host; i < l && *src != '/' && *src != '?' && *src != '#' && *src != '\0' && !xisspace(*src); ++i, ++src, ++dst) {
             *dst = *src;
         }
 
@@ -292,7 +292,7 @@ urlParse(const HttpRequestMethod& method, char *url, HttpRequest *request)
             dst = urlpath;
         }
         /* Then everything from / (inclusive) until \r\n or \0 - thats urlpath */
-        for (; i < l && *src != '\r' && *src != '\n' && *src != '\0'; i++, src++, dst++) {
+        for (; i < l && *src != '\r' && *src != '\n' && *src != '\0'; ++i, ++src, ++dst) {
             *dst = *src;
         }
 
@@ -301,7 +301,8 @@ urlParse(const HttpRequestMethod& method, char *url, HttpRequest *request)
             return NULL;
         /* If the URL path is empty we set it to be "/" */
         if (dst == urlpath) {
-            *(dst++) = '/';
+            *dst = '/';
+            ++dst;
         }
         *dst = '\0';
 
@@ -322,18 +323,20 @@ urlParse(const HttpRequestMethod& method, char *url, HttpRequest *request)
             dst = host;
             /* only for IPv6 sadly, pre-IPv6/URL code can't handle the clean result properly anyway. */
             src = host;
-            src++;
+            ++src;
             l = strlen(host);
             i = 1;
-            for (; i < l && *src != ']' && *src != '\0'; i++, src++, dst++) {
+            for (; i < l && *src != ']' && *src != '\0'; ++i, ++src, ++dst) {
                 *dst = *src;
             }
 
             /* we moved in-place, so truncate the actual hostname found */
-            *(dst++) = '\0';
+            *dst = '\0';
+            ++dst;
 
             /* skip ahead to either start of port, or original EOS */
-            while (*dst != '\0' && *dst != ':') dst++;
+            while (*dst != '\0' && *dst != ':')
+                ++dst;
             t = dst;
         } else {
             t = strrchr(host, ':');
@@ -354,21 +357,23 @@ urlParse(const HttpRequestMethod& method, char *url, HttpRequest *request)
 
         if (t && *t == ':') {
             *t = '\0';
-            t++;
+            ++t;
             port = atoi(t);
         }
     }
 
-    for (t = host; *t; t++)
+    for (t = host; *t; ++t)
         *t = xtolower(*t);
 
     if (stringHasWhitespace(host)) {
         if (URI_WHITESPACE_STRIP == Config.uri_whitespace) {
             t = q = host;
             while (*t) {
-                if (!xisspace(*t))
-                    *q++ = *t;
-                t++;
+                if (!xisspace(*t)) {
+                    *q = *t;
+                    ++q;
+                }
+                ++t;
             }
             *q = '\0';
         }
@@ -433,9 +438,11 @@ urlParse(const HttpRequestMethod& method, char *url, HttpRequest *request)
         default:
             t = q = urlpath;
             while (*t) {
-                if (!xisspace(*t))
-                    *q++ = *t;
-                t++;
+                if (!xisspace(*t)) {
+                    *q = *t;
+                    ++q;
+                }
+                ++t;
             }
             *q = '\0';
         }
@@ -581,8 +588,10 @@ urlCanonicalClean(const HttpRequest * request)
              */
 
             if (Config.onoff.strip_query_terms)
-                if ((t = strchr(buf, '?')))
-                    *(++t) = '\0';
+                if ((t = strchr(buf, '?'))) {
+                    ++t;
+                    *t = '\0';
+                }
 
             break;
         }
@@ -634,7 +643,7 @@ urlIsRelative(const char *url)
         return (false);
     }
 
-    for (p = url; *p != '\0' && *p != ':' && *p != '/'; p++);
+    for (p = url; *p != '\0' && *p != ':' && *p != '/'; ++p);
 
     if (*p == ':') {
         return (false);
@@ -698,10 +707,11 @@ urlMakeAbsolute(const HttpRequest * req, const char *relUrl)
         const char *last_slash = strrchr(path, '/');
 
         if (last_slash == NULL) {
-            urlbuf[urllen++] = '/';
+            urlbuf[urllen] = '/';
+            ++urllen;
             strncpy(&urlbuf[urllen], relUrl, MAX_URL - urllen - 1);
         } else {
-            last_slash++;
+            ++last_slash;
             size_t pathlen = last_slash - path;
             if (pathlen > MAX_URL - urllen - 1) {
                 pathlen = MAX_URL - urllen - 1;
@@ -746,7 +756,7 @@ matchDomainName(const char *h, const char *d)
     int hl;
 
     while ('.' == *h)
-        h++;
+        ++h;
 
     hl = strlen(h);
 
@@ -969,7 +979,7 @@ URLHostName::trimAuth()
     char *t;
 
     if ((t = strrchr(Host, '@'))) {
-        t++;
+        ++t;
         memmove(Host, t, strlen(t) + 1);
     }
 }
@@ -128,8 +128,8 @@ urnFindMinRtt(url_entry * urls, const HttpRequestMethod& m, int *rtt_ret)
     debugs(52, 3, "urnFindMinRtt");
     assert(urls != NULL);
 
-    for (i = 0; NULL != urls[i].url; i++)
-        urlcnt++;
+    for (i = 0; NULL != urls[i].url; ++i)
+        ++urlcnt;
 
     debugs(53, 3, "urnFindMinRtt: Counted " << i << " URLs");
 
@@ -138,7 +138,7 @@ urnFindMinRtt(url_entry * urls, const HttpRequestMethod& m, int *rtt_ret)
         return urls;
     }
 
-    for (i = 0; i < urlcnt; i++) {
+    for (i = 0; i < urlcnt; ++i) {
         u = &urls[i];
         debugs(52, 3, "urnFindMinRtt: " << u->host << " rtt=" << u->rtt);
 
@@ -384,12 +384,12 @@ urnHandleReply(void *data, StoreIOBuffer result)
     delete rep;
 
     while (xisspace(*s))
-        s++;
+        ++s;
 
     urls = urnParseReply(s, urnState->request->method);
 
-    for (i = 0; NULL != urls[i].url; i++)
-        urlcnt++;
+    for (i = 0; NULL != urls[i].url; ++i)
+        ++urlcnt;
 
     debugs(53, 3, "urnFindMinRtt: Counted " << i << " URLs");
 
@@ -412,7 +412,7 @@ urnHandleReply(void *data, StoreIOBuffer result)
                 "<H2>Select URL for %s</H2>\n"
                 "<TABLE BORDER=\"0\" WIDTH=\"100%%\">\n", e->url(), e->url());
 
-    for (i = 0; i < urlcnt; i++) {
+    for (i = 0; i < urlcnt; ++i) {
         u = &urls[i];
         debugs(52, 3, "URL {" << u->url << "}");
         mb->Printf(
@@ -449,7 +449,7 @@ urnHandleReply(void *data, StoreIOBuffer result)
     e->replaceHttpReply(rep);
     e->complete();
 
-    for (i = 0; i < urlcnt; i++) {
+    for (i = 0; i < urlcnt; ++i) {
         safe_free(urls[i].url);
         safe_free(urls[i].host);
     }
@@ -508,7 +508,7 @@ urnParseReply(const char *inbuf, const HttpRequestMethod& m)
         // TODO: Use storeHas() or lock/unlock entry to avoid creating unlocked
         // ones.
         list[i].flags.cached = storeGetPublic(url, m) ? 1 : 0;
-        i++;
+        ++i;
     }
 
     debugs(52, 3, "urnParseReply: Found " << i << " URLs");
@@ -283,7 +283,7 @@ wccpLowestIP(void)
      * We sanity checked wccp_i_see_you.number back in wccpHandleUdp()
      */
 
-    for (loop = 0; loop < (unsigned) ntohl(wccp_i_see_you.number); loop++) {
+    for (loop = 0; loop < (unsigned) ntohl(wccp_i_see_you.number); ++loop) {
         assert(loop < WCCP_ACTIVE_CACHES);
 
         if (local_ip > wccp_i_see_you.wccp_cache_entry[loop].ip_addr)
@@ -351,20 +351,22 @@ wccpAssignBuckets(void)
 
     buckets_per_cache = WCCP_BUCKETS / number_caches;
 
-    for (loop = 0; loop < number_caches; loop++) {
+    for (loop = 0; loop < number_caches; ++loop) {
         int i;
         memcpy(&caches[loop],
                &wccp_i_see_you.wccp_cache_entry[loop].ip_addr,
                sizeof(*caches));
 
-        for (i = 0; i < buckets_per_cache; i++) {
+        for (i = 0; i < buckets_per_cache; ++i) {
             assert(bucket < WCCP_BUCKETS);
-            buckets[bucket++] = loop;
+            buckets[bucket] = loop;
+            ++bucket;
         }
     }
 
     while (bucket < WCCP_BUCKETS) {
-        buckets[bucket++] = number_caches - 1;
+        buckets[bucket] = number_caches - 1;
+        ++bucket;
     }
 
     wccp_assign_bucket->type = htonl(WCCP_ASSIGN_BUCKET);
@@ -703,7 +703,7 @@ wccp2Init(void)
     for (s = Config.Wccp2.router; s; s = s->next) {
         if (!s->s.IsAnyAddr()) {
             /* Increment the counter */
-            wccp2_numrouters++;
+            ++wccp2_numrouters;
         }
     }
 
@@ -1435,7 +1435,7 @@ wccp2HandleUdp(int sock, void *not_used)
     if (ntohl(tmp) != 0) {
         /* search through the list of received-from ip addresses */
 
-        for (num_caches = 0; num_caches < (int) ntohl(tmp); num_caches++) {
+        for (num_caches = 0; num_caches < (int) ntohl(tmp); ++num_caches) {
             /* Get a copy of the ip */
             memset(&cache_address, 0, sizeof(cache_address)); // Make GCC happy
 
@@ -1804,7 +1804,7 @@ wccp2AssignBuckets(void *voidnotused)
                 if (num_caches) {
                     int cache;
 
-                    for (cache = 0, cache_list_ptr = &router_list_ptr->cache_list_head; cache_list_ptr->next; cache_list_ptr = cache_list_ptr->next, cache++) {
+                    for (cache = 0, cache_list_ptr = &router_list_ptr->cache_list_head; cache_list_ptr->next; cache_list_ptr = cache_list_ptr->next, ++cache) {
                         /* add caches */
 
                         cache_address = (struct in_addr *) &wccp_packet[offset];
@@ -1824,7 +1824,7 @@ wccp2AssignBuckets(void *voidnotused)
 
                 if (num_caches != 0) {
                     if (total_weight == 0) {
-                        for (bucket_counter = 0; bucket_counter < WCCP_BUCKETS; bucket_counter++) {
+                        for (bucket_counter = 0; bucket_counter < WCCP_BUCKETS; ++bucket_counter) {
                             buckets[bucket_counter] = (char) (bucket_counter % num_caches);
                         }
                     } else {
@@ -1833,18 +1833,18 @@ wccp2AssignBuckets(void *voidnotused)
                         int cache = -1;
                         unsigned long per_bucket = total_weight / WCCP_BUCKETS;
 
-                        for (bucket_counter = 0; bucket_counter < WCCP_BUCKETS; bucket_counter++) {
+                        for (bucket_counter = 0; bucket_counter < WCCP_BUCKETS; ++bucket_counter) {
                             int n;
                             unsigned long step;
 
-                            for (n = num_caches; n; n--) {
-                                cache++;
+                            for (n = num_caches; n; --n) {
+                                ++cache;
 
                                 if (cache >= num_caches)
                                     cache = 0;
 
                                 if (!weight[cache]) {
-                                    n++;
+                                    ++n;
                                     continue;
                                 }
 
@@ -1905,13 +1905,13 @@ wccp2AssignBuckets(void *voidnotused)
                 cache_list_ptr = &router_list_ptr->cache_list_head;
                 value = 0;
 
-                for (valuecounter = 0; valuecounter < 64; valuecounter++) {
+                for (valuecounter = 0; valuecounter < 64; ++valuecounter) {
 
                     value_element = (struct wccp2_value_element_t *) &wccp_packet[offset];
 
                     /* Update the value according the the "correct" formula */
 
-                    for (; (value & 0x1741) != value; value++) {
+                    for (; (value & 0x1741) != value; ++value) {
                         assert(value <= 0x1741);
                     }
 
@@ -1942,7 +1942,7 @@ wccp2AssignBuckets(void *voidnotused)
                     value_element->cache_ip = cache_list_ptr->cache_ip;
 
                     offset += sizeof(struct wccp2_value_element_t);
-                    value++;
+                    ++value;
 
                     /* Assign the next value to the next cache */
 
@@ -2278,7 +2278,7 @@ parse_wccp2_service_ports(char *options, int portlist[])
         }
 
         portlist[i] = p;
-        i++;
+        ++i;
         port = strsep(&tmp2, ",");
     }
 
@@ -70,7 +70,7 @@ int WIN32_pipe(int handles[2])
 
     handles[0] = handles[1] = -1;
 
-    statCounter.syscalls.sock.sockets++;
+    ++statCounter.syscalls.sock.sockets;
 
     handle0 = localhost;
     handle0.SetPort(0);
@@ -142,7 +142,7 @@ main(int argc, char *argv[])
         splayNode *top = NULL;
         squid_srandom(time(NULL));
 
-        for (i = 0; i < 100; i++) {
+        for (i = 0; i < 100; ++i) {
             I = (intnode *)xcalloc(sizeof(intnode), 1);
             I->i = squid_random();
             top = top->insert(I, compareintvoid);
@@ -164,7 +164,7 @@ main(int argc, char *argv[])
         /* intnode* */
         SplayNode<intnode *> *safeTop = NULL;
 
-        for ( int i = 0; i < 100; i++) {
+        for ( int i = 0; i < 100; ++i) {
             intnode *I;
             I = new intnode;
             I->i = squid_random();
@@ -183,7 +183,7 @@ main(int argc, char *argv[])
         /* intnode */
         SplayNode<intnode> *safeTop = NULL;
 
-        for (int i = 0; i < 100; i++) {
+        for (int i = 0; i < 100; ++i) {
             intnode I;
             I.i = squid_random();
             safeTop = safeTop->insert(I, compareintref);
@@ -219,7 +219,7 @@ main(int argc, char *argv[])
         if (safeTop->finish() != NULL)
             exit (1);
 
-        for (int i = 0; i < 100; i++) {
+        for (int i = 0; i < 100; ++i) {
             intnode I;
             I.i = squid_random();
 
@@ -175,7 +175,7 @@ int Win32SockInit(void)
     int err;
 
     if (s_iInitCount > 0) {
-        s_iInitCount++;
+        ++s_iInitCount;
         return (0);
     } else if (s_iInitCount < 0)
         return (s_iInitCount);
@@ -197,7 +197,7 @@ int Win32SockInit(void)
         return (s_iInitCount);
     }
 
-    s_iInitCount++;
+    ++s_iInitCount;
     return (s_iInitCount);
 }
 
@@ -245,7 +245,7 @@ xstrtok(char **str, char del)
             tok[--len] = '\0';
 
         while (xisspace(*tok))
-            tok++;
+            ++tok;
 
         return tok;
     } else
@@ -352,7 +352,7 @@ auth_html(const char *host, int port, const char *user_name)
 
             if (comment)
                 while (*comment == ' ' || *comment == '\t')
-                    comment++;
+                    ++comment;
 
             if (!comment || !*comment)
                 comment = server;
@@ -361,7 +361,7 @@ auth_html(const char *host, int port, const char *user_name)
                 printf("<TR><TH ALIGN=\"left\">Cache Server:</TH><TD><SELECT id=\"server\" NAME=\"server\">\n");
 
             printf("<OPTION VALUE=\"%s\"%s>%s</OPTION>\n", server, (servers || *host) ? "" : " SELECTED", comment);
-            servers++;
+            ++servers;
         }
 
         if (servers) {
@@ -566,8 +566,8 @@ munge_other_line(const char *buf, cachemgr_request * req)
         const char *cell = xstrtok(&x, '\t');
 
         while (x && *x == '\t') {
-            column_span++;
-            x++;
+            ++column_span;
+            ++x;
         }
 
         l += snprintf(html + l, sizeof(html) - l, "<%s colspan=\"%d\" align=\"%s\">%s</%s>",
@@ -580,7 +580,7 @@ munge_other_line(const char *buf, cachemgr_request * req)
     /* record ends */
     snprintf(html + l, sizeof(html) - l, "</tr>\n");
     next_is_header = is_header && strstr(buf, "\t\t");
-    table_line_num++;
+    ++table_line_num;
     return html;
 }
 
@@ -934,15 +934,15 @@ main(int argc, char *argv[])
                 value = args[1] + 2;
             } else if (argc > 2) {
                 value = args[2];
-                args++;
-                argc--;
+                ++args;
+                --argc;
             } else
                 value = "";
 #endif
             break;
         }
-        args++;
-        argc--;
+        ++args;
+        --argc;
     }
 
     req = read_request();
@@ -1027,7 +1027,8 @@ read_request(void)
         if ((q = strchr(t, '=')) == NULL)
             continue;
 
-        *q++ = '\0';
+        *q = '\0';
+        ++q;
 
         rfc1738_unescape(t);
 
@@ -136,7 +136,7 @@ readConfigFile( CacheDirVector& cachedir, const char* fn, FILE* debug )
                     cd.type = CacheDir::CDT_DISKD;
                 else
                     cd.type = CacheDir::CDT_OTHER;
-                offset++;
+                ++offset;
             }
 
             // extract base directory
@@ -146,7 +146,7 @@ readConfigFile( CacheDirVector& cachedir, const char* fn, FILE* debug )
                                       (int)subs[offset].rm_eo,
                                       line+subs[offset].rm_so );
             cd.base = strdup( line+subs[offset].rm_so );
-            offset++;
+            ++offset;
 
             // extract size information
             line[ subs[offset].rm_eo ] = '\0';
@@ -155,7 +155,7 @@ readConfigFile( CacheDirVector& cachedir, const char* fn, FILE* debug )
                                       (int)subs[offset].rm_eo,
                                       line+subs[offset].rm_so );
             cd.size = strtoul( line+subs[offset].rm_so, 0, 10 );
-            offset++;
+            ++offset;
 
             // extract 1st level directories
             line[ subs[offset].rm_eo ] = '\0';
@@ -164,7 +164,7 @@ readConfigFile( CacheDirVector& cachedir, const char* fn, FILE* debug )
                                       (int)subs[offset].rm_eo,
                                       line+subs[offset].rm_so );
             cd.level[0] = strtoul( line+subs[offset].rm_so, 0, 10 );
-            offset++;
+            ++offset;
 
             // extract 2nd level directories
             line[ subs[offset].rm_eo ] = '\0';
@@ -173,7 +173,7 @@ readConfigFile( CacheDirVector& cachedir, const char* fn, FILE* debug )
                                       (int)subs[offset].rm_eo,
                                       line+subs[offset].rm_so );
             cd.level[1] = strtoul( line+subs[offset].rm_so, 0, 10 );
-            offset++;
+            ++offset;
 
             cachedir.push_back( cd );
         }
@@ -157,7 +157,8 @@ copy_out( size_t filesize, size_t metasize, unsigned debug,
         } else if ( debug & 0x02 ) {
             fprintf( stderr, "# creating %s\n", filename );
         }
-        *t++ = '/';
+        *t = '/';
+        ++t;
     }
 
     // create file
@@ -198,7 +199,8 @@ copy_out( size_t filesize, size_t metasize, unsigned debug,
             //    1 ||  0 |  4 |  0 |
             //    2 ||  1 |  4 |  0 |
             //    3 ||  4 |  2 |  0 |
-            state = table[ state ][ xlate(*s++) ];
+            state = table[ state ][ xlate(*s) ];
+            ++s;
         }
 
         if ( state < 4 )
@@ -246,7 +246,8 @@ isxstring( const char* s, size_t testlen )
     if ( strlen(s) != testlen ) return false;
 
     size_t i=0;
-    while ( i<testlen && isxdigit(s[i]) ) i++;
+    while ( i<testlen && isxdigit(s[i]) )
+        ++i;
     return (i==testlen);
 }
 
@@ -618,8 +619,10 @@ parseCommandline( int argc, char* argv[], REList*& head,
     FILE* rfile;
 
     // program basename
-    if ( (ptr = strrchr(argv[0],'/')) == NULL ) ptr=argv[0];
-    else ptr++;
+    if ( (ptr = strrchr(argv[0],'/')) == NULL )
+        ptr=argv[0];
+    else
+        ++ptr;
     ::programname = ptr;
 
     // extract commandline parameters
@@ -662,7 +665,7 @@ parseCommandline( int argc, char* argv[], REList*& head,
 #define LINESIZE 512
                 char line[LINESIZE];
                 while ( fgets( line, LINESIZE, rfile ) != NULL ) {
-                    lineno++;
+                    ++lineno;
                     int len = strlen(line)-1;
                     if ( len+2 >= LINESIZE ) {
                         fprintf( stderr, "%s:%lu: line too long, sorry.\n",
@@ -671,8 +674,10 @@ parseCommandline( int argc, char* argv[], REList*& head,
                     }
 
                     // remove trailing line breaks
-                    while ( len > 0 && ( line[len] == '\n' || line[len] == '\r' ) )
-                        line[len--] = '\0';
+                    while ( len > 0 && ( line[len] == '\n' || line[len] == '\r' ) ) {
+                        line[len] = '\0';
+                        --len;
+                    }
 
                     // insert into list of expressions
                     if ( head == 0 ) tail = head = new REList(line,option=='F');
@@ -712,7 +717,8 @@ parseCommandline( int argc, char* argv[], REList*& head,
                 }
             } else {
                 // colon used, port is extra
-                *colon++ = 0;
+                *colon = 0;
+                ++colon;
                 if ( convertHostname(optarg,serverHost) == -1 ) {
                     fprintf( stderr, "unable to resolve host %s!\n", optarg );
                     exit(1);
@@ -779,7 +785,8 @@ parseCommandline( int argc, char* argv[], REList*& head,
 
         unsigned count(0);
         for ( tail = head; tail != NULL; tail = tail->next ) {
-            if ( count++ ) printf( "#%22u", count );
+            if ( count++ )
+                printf( "#%22u", count );
 #if defined(LINUX) && putc==_IO_putc
             // I HATE BROKEN LINUX HEADERS!
             // purge.o(.text+0x1040): undefined reference to `_IO_putc'
@@ -210,7 +210,7 @@ main(int argc, char *argv[])
     int ping, pcount;
     int keep_alive = 0;
     int opt_noaccept = 0;
-    int opt_verbose = 0;
+    bool opt_verbose = false;
 #if HAVE_GSSAPI
     int www_neg = 0, proxy_neg = 0;
 #endif
@@ -375,7 +375,7 @@ main(int argc, char *argv[])
 #endif
             case 'v':
                 /* undocumented: may increase verb-level by giving more -v's */
-                opt_verbose++;
+                opt_verbose=true;
                 break;
 
             case '?':		/* usage */
@@ -564,7 +564,7 @@ main(int argc, char *argv[])
     }
     loops = ping ? pcount : 1;
 
-    for (i = 0; loops == 0 || i < loops; i++) {
+    for (i = 0; loops == 0 || i < loops; ++i) {
         int fsize = 0;
         struct addrinfo *AI = NULL;
 