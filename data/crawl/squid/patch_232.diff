@@ -1606,8 +1606,12 @@ if test "x$with_solaris_krb5" = "xyes"; then
     AC_MSG_NOTICE([Use krb5-config to get CXXFLAGS and LIBS])
     LIB_KRB5_CFLAGS="`$ac_krb5_config --cflags krb5 2>/dev/null`"
     LIB_KRB5_LIBS="`$ac_krb5_config --libs krb5 2>/dev/null`"
-    LIB_KRB5_CFLAGS="`$ac_krb5_config --cflags gssapi 2>/dev/null` $LIB_KRB5_CFLAGS"
-    LIB_KRB5_LIBS="`$ac_krb5_config --libs gssapi 2>/dev/null` $LIB_KRB5_LIBS"
+    # Solaris 10 Update 11 patches the krb5-config tool to produce stderr messages on stdout.
+    SOLARIS_BROKEN_KRB5CONFIG_GSSAPI="`$ac_krb5_config --libs gssapi 2>/dev/null | grep "krb5-config"`"
+    if test "x$SOLARIS_BROKEN_KRB5CONFIG_GSSAPI" = "x"; then
+      LIB_KRB5_CFLAGS="`$ac_krb5_config --cflags gssapi 2>/dev/null` $LIB_KRB5_CFLAGS"
+      LIB_KRB5_LIBS="`$ac_krb5_config --libs gssapi 2>/dev/null` $LIB_KRB5_LIBS"
+    fi
   else
     ## For some OS pkg-config is broken or unavailable.
     ## Detect libraries the hard way.
@@ -3859,6 +3863,7 @@ AC_CONFIG_FILES([
 	src/base/Makefile
 	src/clients/Makefile
 	src/comm/Makefile
+	src/dns/Makefile
 	src/esi/Makefile
 	src/eui/Makefile
 	src/format/Makefile
@@ -124,7 +124,7 @@ section 75    WHOIS protocol
 section 76    Internal Squid Object handling
 section 77    Delay Pools
 section 78    DNS lookups
-section 78    DNS lookups; interacts with lib/rfc1035.c
+section 78    DNS lookups; interacts with dns/rfc1035.cc
 section 79    Disk IO Routines
 section 79    Squid-side DISKD I/O functions.
 section 79    Squid-side Disk I/O functions.
@@ -744,6 +744,9 @@ This section gives a thorough account of those changes in three categories:
 <sect1>Removed tags<label id="removedtags">
 <p>
 <descrip>
+	<tag>chunked_request_body_max_size</tag>
+	<p>Obsolete. Squid is now HTTP/1.1 with support for streaming chunked encoded requests.
+
 	<tag>dns_v4_fallback</tag>
 	<p>Obsolete. Replaced by DNS parallel lookups.
 
@@ -347,6 +347,12 @@ This section gives a thorough account of those changes in three categories:
 <sect1>Removed tags<label id="removedtags">
 <p>
 <descrip>
+	<tag>log_access</tag>
+	<p>Removed. Use access_log with ACLs instead
+
+	<tag>log_icap</tag>
+	<p>Removed. Use icap_log with ACLs instead
+
 	<tag>storeurl_access</tag>
 	<p>Replaced by <em>store_id_access</em>.
 
@@ -71,31 +71,16 @@ libmiscutil_la_SOURCES = \
 	heap.c \
 	iso3307.c \
 	radix.c \
-	rfc1035.c \
 	rfc1123.c \
-	rfc2671.c \
-	rfc3596.c \
 	$(SNPRINTFSOURCE) \
 	Splay.cc \
 	stub_memaccount.c \
 	util.c \
 	xusleep.c
 
-TESTS += tests/testRFC1035 tests/testRFC1738
+TESTS += tests/testRFC1738
 
-check_PROGRAMS += tests/testRFC1035 tests/testRFC1738
-
-tests_testRFC1035_SOURCES= \
-	tests/testRFC1035.h \
-	tests/testRFC1035.cc
-
-tests_testRFC1035_LDADD= \
-	$(SQUID_CPPUNIT_LA) $(SQUID_CPPUNIT_LIBS) \
-	$(top_builddir)/lib/libmiscencoding.la \
-	$(top_builddir)/lib/libmiscutil.la \
-	$(COMPAT_LIB)
-
-tests_testRFC1035_LDFLAGS = $(LIBADD_DL)
+check_PROGRAMS += tests/testRFC1738
 
 tests_testRFC1738_SOURCES= \
 	tests/testRFC1738.h \
@@ -0,0 +1,139 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#include "squid.h"
+#include "acl/Gadgets.h"
+#include "CachePeer.h"
+#include "CachePeerDomainList.h"
+#include "defines.h"
+#include "NeighborTypeDomainList.h"
+#include "pconn.h"
+#include "PeerPoolMgr.h"
+
+CBDATA_CLASS_INIT(CachePeer);
+
+CachePeer::CachePeer() :
+    index(0),
+    name(NULL),
+    host(NULL),
+    type(PEER_NONE),
+    http_port(CACHE_HTTP_PORT),
+    peer_domain(NULL),
+    typelist(NULL),
+    access(NULL),
+    weight(1),
+    basetime(0),
+#if USE_CACHE_DIGESTS
+    digest(NULL),
+    digest_url(NULL),
+#endif
+    tcp_up(0),
+    n_addresses(0),
+    rr_count(0),
+    next(NULL),
+    testing_now(false),
+    login(NULL),
+    connect_timeout(0),
+    connect_fail_limit(0),
+    max_conn(0),
+    domain(NULL),
+#if USE_OPENSSL
+    use_ssl(0),
+    sslcert(NULL),
+    sslkey(NULL),
+    sslversion(0),
+    ssloptions(NULL),
+    sslcipher(NULL),
+    sslcafile(NULL),
+    sslcapath(NULL),
+    sslcrlfile(NULL),
+    sslflags(NULL),
+    ssldomain(NULL),
+    sslContext(NULL),
+    sslSession(NULL),
+#endif
+    front_end_https(0),
+    connection_auth(2 /* auto */)
+{
+    memset(&stats, 0, sizeof(stats));
+    stats.logged_state = PEER_ALIVE;
+
+    memset(&icp, 0, sizeof(icp));
+    icp.port = CACHE_ICP_PORT;
+    icp.version = ICP_VERSION_CURRENT;
+
+#if USE_HTCP
+    memset(&htcp, 0, sizeof(htcp));
+#endif
+    memset(&options, 0, sizeof(options));
+    memset(&mcast, 0, sizeof(mcast));
+    memset(&carp, 0, sizeof(carp));
+#if USE_AUTH
+    memset(&userhash, 0, sizeof(userhash));
+#endif
+    memset(&sourcehash, 0, sizeof(sourcehash));
+
+    standby.pool = NULL;
+    standby.limit = 0;
+    standby.waitingForClose = false;
+}
+
+CachePeer::~CachePeer()
+{
+    xfree(name);
+    xfree(host);
+
+    while (CachePeerDomainList *l = peer_domain) {
+        peer_domain = l->next;
+        xfree(l->domain);
+        xfree(l);
+    }
+
+    while (NeighborTypeDomainList *l = typelist) {
+        typelist = l->next;
+        xfree(l->domain);
+        xfree(l);
+    }
+
+    aclDestroyAccessList(&access);
+
+#if USE_CACHE_DIGESTS
+    cbdataReferenceDone(digest);
+    xfree(digest_url);
+#endif
+
+    delete next;
+
+    xfree(login);
+
+    delete standby.pool;
+
+    // the mgr job will notice that its owner is gone and stop
+    PeerPoolMgr::Checkpoint(standby.mgr, "peer gone");
+
+    xfree(domain);
+
+#if USE_OPENSSL
+    xfree(sslcert);
+    xfree(sslkey);
+    xfree(ssloptions);
+    xfree(sslcipher);
+    xfree(sslcafile);
+    xfree(sslcapath);
+    xfree(sslcrlfile);
+    xfree(sslflags);
+    xfree(ssldomain);
+
+    if (sslContext)
+        SSL_CTX_free(sslContext);
+
+    if (sslSession)
+        SSL_SESSION_free(sslSession);
+#endif
+}
+
@@ -28,10 +28,14 @@ class PconnPool;
 class PeerDigest;
 class PeerPoolMgr;
 
-// currently a POD
 class CachePeer
 {
+    CBDATA_CLASS(CachePeer);
+
 public:
+    CachePeer();
+    ~CachePeer();
+
     u_int index;
     char *name;
     char *host;
@@ -11,6 +11,7 @@
 
 #include "base/RefCount.h"
 #include "cbdata.h"
+#include "dns/forward.h"
 #include "helper/forward.h"
 #include "ipcache.h"
 
@@ -20,7 +21,6 @@
 
 class ACLChecklist;
 class ClientHttpRequest;
-class DnsLookupDetails;
 class ErrorState;
 
 class ClientRequestContext : public RefCountable
@@ -33,7 +33,7 @@ class ClientRequestContext : public RefCountable
 
     bool httpStateIsValid();
     void hostHeaderVerify();
-    void hostHeaderIpVerify(const ipcache_addrs* ia, const DnsLookupDetails &dns);
+    void hostHeaderIpVerify(const ipcache_addrs* ia, const Dns::LookupDetails &dns);
     void hostHeaderVerifyFailed(const char *A, const char *B);
     void clientAccessCheck();
     void clientAccessCheck2();
@@ -13,11 +13,9 @@
 #include "base/RefCount.h"
 
 class external_acl;
+class external_acl_data;
 class StoreEntry;
 
-/** \todo CLEANUP: kill this typedef. */
-typedef struct _external_acl_data external_acl_data;
-
 class ExternalACLLookup : public ACLChecklist::AsyncState
 {
 
@@ -10,7 +10,7 @@
 
 #include "squid.h"
 #include "AccessLogEntry.h"
-#include "acl/AclAddress.h"
+#include "acl/Address.h"
 #include "acl/FilledChecklist.h"
 #include "acl/Gadgets.h"
 #include "anyp/PortCfg.h"
@@ -1197,9 +1197,7 @@ FwdState::logReplyStatus(int tries, const Http::StatusCode status)
 tos_t
 aclMapTOS(acl_tos * head, ACLChecklist * ch)
 {
-    acl_tos *l;
-
-    for (l = head; l; l = l->next) {
+    for (acl_tos *l = head; l; l = l->next) {
         if (!l->aclList || ch->fastCheck(l->aclList) == ACCESS_ALLOWED)
             return l->tos;
     }
@@ -1211,9 +1209,7 @@ aclMapTOS(acl_tos * head, ACLChecklist * ch)
 nfmark_t
 aclMapNfmark(acl_nfmark * head, ACLChecklist * ch)
 {
-    acl_nfmark *l;
-
-    for (l = head; l; l = l->next) {
+    for (acl_nfmark *l = head; l; l = l->next) {
         if (!l->aclList || ch->fastCheck(l->aclList) == ACCESS_ALLOWED)
             return l->nfmark;
     }
@@ -1259,8 +1255,7 @@ getOutgoingAddress(HttpRequest * request, Comm::ConnectionPointer conn)
     // TODO use the connection details in ACL.
     // needs a bit of rework in ACLFilledChecklist to use Comm::Connection instead of ConnStateData
 
-    AclAddress *l;
-    for (l = Config.accessList.outgoing_address; l; l = l->next) {
+    for (Acl::Address *l = Config.accessList.outgoing_address; l; l = l->next) {
 
         /* check if the outgoing address is usable to the destination */
         if (conn->remote.isIPv4() != l->addr.isIPv4()) continue;
@@ -13,7 +13,7 @@
 #include "acl/AclSizeLimit.h"
 #include "acl/FilledChecklist.h"
 #include "client_side.h"
-#include "DnsLookupDetails.h"
+#include "dns/LookupDetails.h"
 #include "err_detail_type.h"
 #include "globals.h"
 #include "gopher.h"
@@ -616,7 +616,7 @@ HttpRequest::conditional() const
 }
 
 void
-HttpRequest::recordLookup(const DnsLookupDetails &dns)
+HttpRequest::recordLookup(const Dns::LookupDetails &dns)
 {
     if (dns.wait >= 0) { // known delay
         if (dnsWait >= 0) // have recorded DNS wait before
@@ -11,6 +11,7 @@
 
 #include "base/CbcPointer.h"
 #include "Debug.h"
+#include "dns/forward.h"
 #include "err_type.h"
 #include "HierarchyLogEntry.h"
 #include "http/RequestMethod.h"
@@ -39,7 +40,6 @@ class ConnStateData;
 void httpRequestPack(void *obj, Packer *p);
 
 class HttpHdrRange;
-class DnsLookupDetails;
 
 class HttpRequest: public HttpMsg
 {
@@ -100,7 +100,7 @@ class HttpRequest: public HttpMsg
     Adaptation::Icap::History::Pointer icapHistory() const;
 #endif
 
-    void recordLookup(const DnsLookupDetails &detail);
+    void recordLookup(const Dns::LookupDetails &detail);
 
     /// sets error detail if no earlier detail was available
     void detailError(err_type aType, int aDetail);
@@ -10,10 +10,7 @@ include $(top_srcdir)/src/Common.am
 AUTOMAKE_OPTIONS = subdir-objects
 
 DNSSOURCE = \
-	dns_internal.cc \
-	SquidDns.h \
-	DnsLookupDetails.h \
-	DnsLookupDetails.cc
+	dns_internal.cc
 
 SBUF_SOURCE= \
 	base/CharacterSet.h \
@@ -47,8 +44,8 @@ LOADABLE_MODULES_SOURCES = \
 	LoadableModules.h \
 	LoadableModules.cc
 
-SUBDIRS	= mem base anyp helper ftp parser comm eui acl format clients servers fs repl
-DIST_SUBDIRS = mem base anyp helper ftp parser comm eui acl format clients servers fs repl
+SUBDIRS	= mem base anyp helper dns ftp parser comm eui acl format clients servers fs repl
+DIST_SUBDIRS = mem base anyp helper dns ftp parser comm eui acl format clients servers fs repl
 
 if ENABLE_AUTH
 SUBDIRS += auth
@@ -289,6 +286,7 @@ squid_SOURCES = \
 	cache_manager.cc \
 	NeighborTypeDomainList.h \
 	CachePeerDomainList.h \
+	CachePeer.cc \
 	CachePeer.h \
 	CacheManager.h \
 	carp.h \
@@ -614,6 +612,7 @@ squid_LDADD = \
 	helper/libhelper.la \
 	http/libsquid-http.la \
 	parser/libsquid-parser.la \
+	dns/libdns.la \
 	base/libbase.la \
 	libsquid.la \
 	ip/libip.la \
@@ -1059,6 +1058,7 @@ check_PROGRAMS+=\
 	tests/testBoilerplate \
 	tests/testCacheManager \
 	tests/testDiskIO \
+	tests/testDns \
 	tests/testEvent \
 	tests/testEventLoop \
 	tests/test_http_range \
@@ -1401,6 +1401,8 @@ tests_testCacheManager_SOURCES = \
 	YesNoNone.cc \
 	RefreshPattern.h \
 	cache_cf.cc \
+	CachePeer.cc \
+	CachePeer.h \
 	CacheDigest.h \
 	tests/stub_CacheDigest.cc \
 	carp.h \
@@ -1586,6 +1588,7 @@ tests_testCacheManager_LDADD = \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
+	dns/libdns.la \
 	base/libbase.la \
 	ip/libip.la \
 	fs/libfs.la \
@@ -1768,7 +1771,6 @@ tests_testDiskIO_LDADD = \
 	parser/libsquid-parser.la \
 	SquidConfig.o \
 	CommCalls.o \
-	DnsLookupDetails.o \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
@@ -1784,6 +1786,7 @@ tests_testDiskIO_LDADD = \
 	mgr/libmgr.la \
 	$(SSL_LIBS) \
 	ipc/libipc.la \
+	dns/libdns.la \
 	base/libbase.la \
 	mem/libmem.la \
 	$(top_builddir)/lib/libmisccontainers.la \
@@ -1802,7 +1805,23 @@ tests_testDiskIO_DEPENDENCIES = \
 	$(SWAP_TEST_DS) \
 	$(SQUID_CPPUNIT_LA)
 
-## Tests of the Even module.
+tests_testDns_SOURCES= \
+	tests/testRFC1035.cc \
+	tests/testRFC1035.h
+nodist_tests_testDns_SOURCES= \
+	tests/stub_debug.cc \
+	tests/stub_SBuf.cc \
+	tests/stub_tools.cc
+tests_testDns_LDADD= \
+	dns/libdns.la \
+	base/libbase.la \
+	$(top_builddir)/lib/libmiscutil.la \
+	$(COMPAT_LIB) \
+	$(XTRA_LIBS) \
+	$(SQUID_CPPUNIT_LA) \
+	$(SQUID_CPPUNIT_LIBS)
+tests_testDns_LDFLAGS= $(LIBADD_DL)
+
 tests_testEvent_SOURCES = \
 	AccessLogEntry.cc \
 	BodyPipe.cc \
@@ -1814,6 +1833,8 @@ tests_testEvent_SOURCES = \
 	YesNoNone.cc \
 	RefreshPattern.h \
 	cache_cf.cc \
+	CachePeer.cc \
+	CachePeer.h \
 	cache_manager.cc \
 	carp.h \
 	tests/stub_carp.cc \
@@ -2012,6 +2033,7 @@ tests_testEvent_LDADD = \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
+	dns/libdns.la \
 	base/libbase.la \
 	ip/libip.la \
 	fs/libfs.la \
@@ -2058,6 +2080,8 @@ tests_testEventLoop_SOURCES = \
 	YesNoNone.cc \
 	RefreshPattern.h \
 	cache_cf.cc \
+	CachePeer.cc \
+	CachePeer.h \
 	carp.h \
 	tests/stub_carp.cc \
 	cbdata.cc \
@@ -2254,6 +2278,7 @@ tests_testEventLoop_LDADD = \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
+	dns/libdns.la \
 	base/libbase.la \
 	ip/libip.la \
 	fs/libfs.la \
@@ -2296,6 +2321,8 @@ tests_test_http_range_SOURCES = \
 	YesNoNone.cc \
 	RefreshPattern.h \
 	cache_cf.cc \
+	CachePeer.cc \
+	CachePeer.h \
 	cache_manager.cc \
 	CacheDigest.h \
 	tests/stub_CacheDigest.cc \
@@ -2506,6 +2533,7 @@ tests_test_http_range_LDADD = \
 	$(ESI_LIBS) \
 	$(SSL_LIBS) \
 	ipc/libipc.la \
+	dns/libdns.la \
 	base/libbase.la \
 	mgr/libmgr.la \
 	$(SNMP_LIBS) \
@@ -2602,6 +2630,8 @@ tests_testHttpRequest_SOURCES = \
 	debug.cc \
 	CacheDigest.h \
 	tests/stub_CacheDigest.cc \
+	CachePeer.cc \
+	CachePeer.h \
 	carp.h \
 	tests/stub_carp.cc \
 	cbdata.cc \
@@ -2782,6 +2812,7 @@ tests_testHttpRequest_LDADD = \
 	$(SSL_LIBS) \
 	ipc/libipc.la \
 	parser/libsquid-parser.la \
+	dns/libdns.la \
 	base/libbase.la \
 	mgr/libmgr.la \
 	anyp/libanyp.la \
@@ -2960,6 +2991,7 @@ tests_testStore_LDADD= \
 	acl/libacls.la \
 	acl/libstate.la \
 	acl/libapi.la \
+	dns/libdns.la \
 	base/libbase.la \
 	ip/libip.la \
 	fs/libfs.la \
@@ -2975,7 +3007,6 @@ tests_testStore_LDADD= \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SSLLIB) \
 	CommCalls.o \
-	DnsLookupDetails.o \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testStore_LDFLAGS = $(LIBADD_DL)
@@ -3182,7 +3213,6 @@ tests_testUfs_LDADD = \
 	http/libsquid-http.la \
 	parser/libsquid-parser.la \
 	CommCalls.o \
-	DnsLookupDetails.o \
 	ident/libident.la \
 	acl/libacls.la \
 	acl/libstate.la \
@@ -3200,6 +3230,7 @@ tests_testUfs_LDADD = \
 	ipc/libipc.la \
 	comm/libcomm.la \
 	anyp/libanyp.la \
+	dns/libdns.la \
 	base/libbase.la \
 	ip/libip.la \
 	mem/libmem.la \
@@ -3408,6 +3439,8 @@ tests_testURL_SOURCES = \
 	tests/stub_cache_manager.cc \
 	CacheDigest.h \
 	tests/stub_CacheDigest.cc \
+	CachePeer.cc \
+	CachePeer.h \
 	carp.h \
 	tests/stub_carp.cc \
 	cbdata.cc \
@@ -3606,6 +3639,7 @@ tests_testURL_LDADD = \
 	eui/libeui.la \
 	acl/libstate.la \
 	acl/libapi.la \
+	dns/libdns.la \
 	base/libbase.la \
 	ip/libip.la \
 	fs/libfs.la \
@@ -44,7 +44,12 @@ class store_client;
 
 class DigestFetchState
 {
+    CBDATA_CLASS(DigestFetchState);
+
 public:
+    DigestFetchState(PeerDigest *,HttpRequest *);
+    ~DigestFetchState();
+
     PeerDigest *pd;
     StoreEntry *entry;
     StoreEntry *old_entry;
@@ -60,9 +65,8 @@ class DigestFetchState
     struct {
         int msg;
         int bytes;
-    }
+    } sent, recv;
 
-    sent, recv;
     char buf[SM_PAGE_SIZE];
     ssize_t bufofs;
     digest_read_state_t state;
@@ -38,6 +38,13 @@ class RefreshPattern
 #endif
     } flags;
     int max_stale;
+
+    // statistics about how many matches this pattern has had
+    mutable struct stats_ {
+        uint64_t matchTests;
+        uint64_t matchCount;
+        // TODO: some stats to indicate how useful/less the flags are would be nice.
+    } stats;
 };
 
 #endif /* SQUID_REFRESHPATTERN_H_ */
@@ -630,17 +630,17 @@ SBuf::find(const SBuf &needle, size_type startPos) const
 
     ++stats.find;
 
-    char *begin = buf()+startPos;
+    char *start = buf()+startPos;
     char *lastPossible = buf()+length()-needle.length()+1;
     char needleBegin = needle[0];
 
     debugs(24, 7, "looking for " << needle << "starting at " << startPos <<
            " in id " << id);
-    while (begin < lastPossible) {
+    while (start < lastPossible) {
         char *tmp;
-        debugs(24, 8, " begin=" << (void *) begin <<
+        debugs(24, 8, " begin=" << (void *) start <<
                ", lastPossible=" << (void*) lastPossible );
-        tmp = static_cast<char *>(memchr(begin, needleBegin, lastPossible-begin));
+        tmp = static_cast<char *>(memchr(start, needleBegin, lastPossible-start));
         if (tmp == NULL) {
             debugs(24, 8 , "First byte not found");
             return npos;
@@ -650,7 +650,7 @@ SBuf::find(const SBuf &needle, size_type startPos) const
             debugs(24, 8, "Found at " << (tmp-buf()));
             return (tmp-buf());
         }
-        begin = tmp+1;
+        start = tmp+1;
     }
     debugs(24, 8, "not found");
     return npos;
@@ -736,8 +736,8 @@ SBuf::findFirstOf(const CharacterSet &set, size_type startPos) const
 
     debugs(24, 7, "first of characterset " << set.name << " in id " << id);
     char *cur = buf()+startPos;
-    const char *end = bufEnd();
-    while (cur < end) {
+    const char *bufend = bufEnd();
+    while (cur < bufend) {
         if (set[*cur])
             return cur-buf();
         ++cur;
@@ -759,8 +759,8 @@ SBuf::findFirstNotOf(const CharacterSet &set, size_type startPos) const
 
     debugs(24, 7, "first not of characterset " << set.name << " in id " << id);
     char *cur = buf()+startPos;
-    const char *end = bufEnd();
-    while (cur < end) {
+    const char *bufend = bufEnd();
+    while (cur < bufend) {
         if (!set[*cur])
             return cur-buf();
         ++cur;
@@ -17,6 +17,7 @@
 #include <climits>
 #include <cstdarg>
 #include <iosfwd>
+#include <iterator>
 #if HAVE_UNISTD_H
 #include <unistd.h>
 #endif
@@ -75,6 +76,44 @@ class SBufStats
 };
 
 class CharacterSet;
+class SBuf;
+
+/** Forward input iterator for SBufs
+ *
+ * Please note that any operation on the underlying SBuf may invalidate
+ * all iterators over it, resulting in undefined behavior by them.
+ */
+class SBufIterator : public std::iterator<std::input_iterator_tag, char>
+{
+public:
+    friend class SBuf;
+    typedef MemBlob::size_type size_type;
+    bool operator==(const SBufIterator &s) const;
+    bool operator!=(const SBufIterator &s) const;
+
+    char operator*() const { return *iter; }
+    SBufIterator& operator++() { ++iter; return *this; }
+
+protected:
+    SBufIterator(const SBuf &, size_type);
+
+    const char *iter;
+};
+
+/** Reverse input iterator for SBufs
+ *
+ * Please note that any operation on the underlying SBuf may invalidate
+ * all iterators over it, resulting in undefined behavior by them.
+ */
+class SBufReverseIterator : public SBufIterator
+{
+    friend class SBuf;
+public:
+    SBufReverseIterator& operator++() { --iter; return *this;}
+    char operator*() const { return *(iter-1); }
+protected:
+    SBufReverseIterator(const SBuf &s, size_type sz) : SBufIterator(s,sz) {}
+};
 
 /**
  * A String or Buffer.
@@ -86,6 +125,8 @@ class SBuf
 {
 public:
     typedef MemBlob::size_type size_type;
+    typedef SBufIterator iterator;
+    typedef SBufReverseIterator reverse_iterator;
     static const size_type npos = 0xffffffff; // max(uint32_t)
 
     /// Maximum size of a SBuf. By design it MUST be < MAX(size_type)/2. Currently 256Mb.
@@ -541,6 +582,22 @@ class SBuf
     /// std::string export function
     std::string toStdString() const { return std::string(buf(),length()); }
 
+    iterator begin() {
+        return iterator(*this, 0);
+    }
+
+    iterator end() {
+        return iterator(*this, length());
+    }
+
+    reverse_iterator rbegin() {
+        return reverse_iterator(*this, length());
+    }
+
+    reverse_iterator rend() {
+        return reverse_iterator(*this, 0);
+    }
+
     // TODO: possibly implement erase() similar to std::string's erase
     // TODO: possibly implement a replace() call
 private:
@@ -619,5 +676,24 @@ ToLower(SBuf buf)
     return buf;
 }
 
+inline
+SBufIterator::SBufIterator(const SBuf &s, size_type pos)
+    : iter(s.rawContent()+pos)
+{}
+
+inline bool
+SBufIterator::operator==(const SBufIterator &s) const
+{
+    // note: maybe the sbuf comparison is unnecessary?
+    return iter == s.iter;
+}
+
+inline bool
+SBufIterator::operator!=(const SBufIterator &s) const
+{
+    // note: maybe the sbuf comparison is unnecessary?
+    return iter != s.iter;
+}
+
 #endif /* SQUID_SBUF_H */
 
@@ -103,7 +103,6 @@ class SquidConfig
     } Timeout;
     size_t maxRequestHeaderSize;
     int64_t maxRequestBodySize;
-    int64_t maxChunkedRequestBodySize;
     size_t maxRequestBufferSize;
     size_t maxReplyHeaderSize;
     AclSizeLimit *ReplyBodySize;
@@ -358,7 +357,7 @@ class SquidConfig
         acl_access *redirector;
         acl_access *store_id;
         acl_access *reply;
-        AclAddress *outgoing_address;
+        Acl::Address *outgoing_address;
 #if USE_HTCP
 
         acl_access *htcp;
@@ -7,7 +7,14 @@
  */
 
 #include "squid.h"
-#include "AclAddress.h"
+#include "acl/AclSizeLimit.h"
+#include "acl/Gadgets.h"
 
-//TODO: fill in
+CBDATA_CLASS_INIT(AclSizeLimit);
+
+AclSizeLimit::~AclSizeLimit()
+{
+    aclDestroyAclList(&aclList);
+    delete next;
+}
 
@@ -10,12 +10,17 @@
 #define SQUID_ACLSIZELIMIT_H_
 
 #include "acl/forward.h"
+#include "cbdata.h"
 
 /// representation of a class of Size-limit ACLs
-// a POD. TODO: convert to new ACL framework
 class AclSizeLimit
 {
+    CBDATA_CLASS(AclSizeLimit);
+
 public:
+    AclSizeLimit() : next(NULL), aclList(NULL), size(0) {}
+    ~AclSizeLimit();
+
     AclSizeLimit *next;
     ACLList *aclList;
     int64_t size;
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#include "squid.h"
+#include "acl/Address.h"
+#include "acl/Gadgets.h"
+
+CBDATA_NAMESPACED_CLASS_INIT(Acl, Address);
+
+Acl::Address::~Address()
+{
+    aclDestroyAclList(&aclList);
+    delete next;
+}
+
@@ -6,21 +6,31 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-#ifndef ACLADDRESS_H_
-#define ACLADDRESS_H_
+#ifndef _SQUID_SRC_ACL_ADDRESS_H_
+#define _SQUID_SRC_ACL_ADDRESS_H_
 
 #include "acl/Acl.h"
 #include "ip/Address.h"
 
+namespace Acl
+{
+
 /// list of address-based ACLs.
-class AclAddress
+class Address
 {
+    CBDATA_CLASS(Address);
+
 public:
-    AclAddress *next;
+    Address() : next(NULL), aclList(NULL) {}
+    ~Address();
+
+    Acl::Address *next;
     ACLList *aclList;
 
     Ip::Address addr;
 };
 
-#endif /* ACLADDRESS_H_ */
+} // namespace Acl
+
+#endif /* _SQUID_SRC_ACL_ADDRESS_H_ */
 
@@ -14,7 +14,6 @@
 
 #include "acl/Arp.h"
 #include "acl/FilledChecklist.h"
-#include "cache_cf.h"
 #include "Debug.h"
 #include "eui/Eui48.h"
 #include "globals.h"
@@ -102,7 +101,7 @@ aclParseArpData(const char *t)
 void
 ACLARP::parse()
 {
-    while (const char *t = strtokFile()) {
+    while (const char *t = ConfigParser::strtokFile()) {
         if (Eui::Eui48 *q = aclParseArpData(t)) {
             aclArpData.insert(*q);
             delete q;
@@ -130,7 +129,7 @@ SBufList
 ACLARP::dump() const
 {
     SBufList sl;
-    for (auto i = aclArpData.cbegin(); i != aclArpData.cend(); ++i) {
+    for (auto i = aclArpData.begin(); i != aclArpData.end(); ++i) {
         char buf[48];
         i->encode(buf,48);
         sl.push_back(SBuf(buf));
@@ -15,7 +15,6 @@
 #include "acl/DestinationAsn.h"
 #include "acl/DestinationIp.h"
 #include "acl/SourceAsn.h"
-#include "cache_cf.h"
 #include "FwdState.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -26,7 +25,6 @@
 #include "SquidConfig.h"
 #include "Store.h"
 #include "StoreClient.h"
-#include "StoreClient.h"
 
 #define WHOIS_PORT 43
 #define AS_REQBUF_SZ    4096
@@ -559,7 +557,7 @@ ACLASN::parse()
     char *t = NULL;
 
     for (Tail = curlist; *Tail; Tail = &((*Tail)->next));
-    while ((t = strtokFile())) {
+    while ((t = ConfigParser::strtokFile())) {
         q = new CbDataList<int> (atoi(t));
         *(Tail) = q;
         Tail = &q->next;
@@ -13,6 +13,7 @@
 #include "acl/AtStepData.h"
 #include "acl/Checklist.h"
 #include "cache_cf.h"
+#include "ConfigParser.h"
 #include "Debug.h"
 #include "wordlist.h"
 
@@ -53,7 +54,7 @@ ACLAtStepData::dump() const
 void
 ACLAtStepData::parse()
 {
-    while (const char *t = strtokFile()) {
+    while (const char *t = ConfigParser::strtokFile()) {
         if (strcasecmp(t, "SslBump1") == 0) {
             values.push_back(Ssl::bumpStep1);
         } else if (strcasecmp(t, "SslBump2") == 0) {
@@ -12,6 +12,7 @@
 #include "acl/CertificateData.h"
 #include "acl/Checklist.h"
 #include "cache_cf.h"
+#include "ConfigParser.h"
 #include "Debug.h"
 #include "wordlist.h"
 
@@ -78,15 +79,21 @@ ACLCertificateData::dump() const
     if (validAttributesStr)
         sl.push_back(SBuf(attribute));
 
+#if __cplusplus >= 201103L
     sl.splice(sl.end(),values.dump());
+#else
+    // temp is needed until c++11 move constructor
+    SBufList tmp = values.dump();
+    sl.splice(sl.end(),tmp);
+#endif
     return sl;
 }
 
 void
 ACLCertificateData::parse()
 {
     if (validAttributesStr) {
-        char *newAttribute = strtokFile();
+        char *newAttribute = ConfigParser::strtokFile();
 
         if (!newAttribute) {
             if (attributeIsOptional)
@@ -33,7 +33,7 @@ DestinationDomainLookup::checkForAsync(ACLChecklist *cl) const
 }
 
 void
-DestinationDomainLookup::LookupDone(const char *, const DnsLookupDetails &details, void *data)
+DestinationDomainLookup::LookupDone(const char *, const Dns::LookupDetails &details, void *data)
 {
     ACLFilledChecklist *checklist = Filled((ACLChecklist*)data);
     checklist->markDestinationDomainChecked();
@@ -48,7 +48,7 @@ class DestinationDomainLookup : public ACLChecklist::AsyncState
 
 private:
     static DestinationDomainLookup instance_;
-    static void LookupDone(const char *, const DnsLookupDetails &, void *);
+    static void LookupDone(const char *, const Dns::LookupDetails &, void *);
 };
 
 /// \ingroup ACLAPI
@@ -29,6 +29,10 @@ ACLDestinationIP::match(ACLChecklist *cl)
 {
     ACLFilledChecklist *checklist = Filled(cl);
 
+    // if there is no HTTP request details fallback to the dst_addr
+    if (!checklist->request)
+        return ACLIP::match(checklist->dst_addr);
+
     // Bug 3243: CVE 2009-0801
     // Bypass of browser same-origin access control in intercepted communication
     // To resolve this we will force DIRECT and only to the original client destination.
@@ -87,7 +91,7 @@ DestinationIPLookup::checkForAsync(ACLChecklist *cl)const
 }
 
 void
-DestinationIPLookup::LookupDone(const ipcache_addrs *, const DnsLookupDetails &details, void *data)
+DestinationIPLookup::LookupDone(const ipcache_addrs *, const Dns::LookupDetails &details, void *data)
 {
     ACLFilledChecklist *checklist = Filled((ACLChecklist*)data);
     checklist->request->flags.destinationIpLookedUp = true;
@@ -33,7 +33,6 @@ class ACLDestinationIP : public ACLIP
     ACLDestinationIP(): ACLIP(ACLDestinationIP::SupportedFlags) {}
     virtual char const *typeString() const;
     virtual int match(ACLChecklist *checklist);
-    virtual bool requiresRequest() const {return true;}
 
     virtual ACL *clone()const;
 
@@ -12,6 +12,7 @@
 #include "acl/Checklist.h"
 #include "acl/DomainData.h"
 #include "cache_cf.h"
+#include "ConfigParser.h"
 #include "Debug.h"
 #include "src/URL.h"
 #include "util.h"
@@ -134,12 +135,10 @@ ACLDomainData::dump() const
 void
 ACLDomainData::parse()
 {
-    char *t = NULL;
-
     if (!domains)
         domains = new Splay<char *>();
 
-    while ((t = strtokFile())) {
+    while (char *t = ConfigParser::strtokFile()) {
         Tolower(t);
         domains->insert(xstrdup(t), aclDomainCompare);
     }
@@ -14,7 +14,6 @@
 
 #include "acl/Eui64.h"
 #include "acl/FilledChecklist.h"
-#include "cache_cf.h"
 #include "Debug.h"
 #include "eui/Eui64.h"
 #include "globals.h"
@@ -74,7 +73,7 @@ aclParseEuiData(const char *t)
 void
 ACLEui64::parse()
 {
-    while (const char * t = strtokFile()) {
+    while (const char * t = ConfigParser::strtokFile()) {
         if (Eui::Eui64 * q = aclParseEuiData(t)) {
             eui64Data.insert(*q);
             delete q;
@@ -108,7 +107,7 @@ SBufList
 ACLEui64::dump() const
 {
     SBufList sl;
-    for (auto i = eui64Data.cbegin(); i != eui64Data.end(); ++i) {
+    for (auto i = eui64Data.begin(); i != eui64Data.end(); ++i) {
         static char buf[48];
         i->encode(buf,48);
         sl.push_back(SBuf(buf));
@@ -9,7 +9,7 @@
 #include "squid.h"
 #include "acl/Checklist.h"
 #include "acl/HierCodeData.h"
-#include "cache_cf.h"
+#include "ConfigParser.h"
 #include "fatal.h"
 #include "hier_code.h"
 
@@ -51,7 +51,7 @@ ACLHierCodeData::parse()
 {
     char *t = NULL;
 
-    while ((t = strtokFile())) {
+    while ((t = ConfigParser::strtokFile())) {
         for (hier_code iter = HIER_NONE; iter <= HIER_MAX; ++iter) {
             if (iter == HIER_MAX) {
                 fatalf("ERROR: No such hier_code '%s'",t);
@@ -13,7 +13,6 @@
 #include "acl/Checklist.h"
 #include "acl/HttpHeaderData.h"
 #include "acl/RegexData.h"
-#include "cache_cf.h"
 #include "ConfigParser.h"
 #include "Debug.h"
 #include "HttpHeaderTools.h"
@@ -60,16 +59,20 @@ ACLHTTPHeaderData::dump() const
 {
     SBufList sl;
     sl.push_back(SBuf(hdrName));
+#if __cplusplus >= 201103L
+    sl.splice(sl.end(), regex_rule->dump());
+#else
     // temp is needed until c++11 move-constructor
     SBufList temp = regex_rule->dump();
     sl.splice(sl.end(), temp);
+#endif
     return sl;
 }
 
 void
 ACLHTTPHeaderData::parse()
 {
-    char* t = strtokFile();
+    char* t = ConfigParser::strtokFile();
     assert (t != NULL);
     hdrName = t;
     hdrId = httpHeaderIdByNameDef(hdrName.rawBuf(), hdrName.size());
@@ -11,7 +11,6 @@
 #include "squid.h"
 #include "acl/FilledChecklist.h"
 #include "acl/HttpStatus.h"
-#include "cache_cf.h"
 #include "Debug.h"
 #include "HttpReply.h"
 
@@ -120,14 +119,9 @@ ACLHTTPStatus::parse()
 void
 aclParseHTTPStatusList(Splay<acl_httpstatus_data *> **curlist)
 {
-    char *t = NULL;
-    acl_httpstatus_data *q = NULL;
-
-    while ((t = strtokFile())) {
-        if ((q = aclParseHTTPStatusData(t)) == NULL)
-            continue;
-
-        (*curlist)->insert(q, acl_httpstatus_data::compare);
+    while (char *t = ConfigParser::strtokFile()) {
+        if (acl_httpstatus_data *q = aclParseHTTPStatusData(t))
+            (*curlist)->insert(q, acl_httpstatus_data::compare);
     }
 }
 
@@ -11,16 +11,15 @@
 #include "squid.h"
 #include "acl/IntRange.h"
 #include "cache_cf.h"
+#include "ConfigParser.h"
 #include "Debug.h"
 #include "fatal.h"
 #include "Parsing.h"
 
 void
 ACLIntRange::parse()
 {
-    char *a;
-
-    while ((a = strtokFile())) {
+    while (char *a = ConfigParser::strtokFile()) {
         char *b = strchr(a, '-');
         unsigned short port1, port2;
 
@@ -12,6 +12,7 @@
 #include "acl/Checklist.h"
 #include "acl/Ip.h"
 #include "cache_cf.h"
+#include "ConfigParser.h"
 #include "Debug.h"
 #include "ip/tools.h"
 #include "MemBuf.h"
@@ -478,7 +479,7 @@ ACLIP::parse()
 
     flags.parseFlags();
 
-    while (char *t = strtokFile()) {
+    while (char *t = ConfigParser::strtokFile()) {
         acl_ip_data *q = acl_ip_data::FactoryParse(t);
 
         while (q != NULL) {
@@ -33,8 +33,8 @@ libstate_la_SOURCES = \
 	Strategised.h \
 	FilledChecklist.cc \
 	FilledChecklist.h \
-	AclAddress.h \
-	AclAddress.cc
+	Address.h \
+	Address.cc
 
 ## data-specific ACLs
 libacls_la_SOURCES = \
@@ -136,6 +136,7 @@ libacls_la_SOURCES = \
 	AclDenyInfoList.h \
 	Gadgets.cc \
 	Gadgets.h \
+	AclSizeLimit.cc \
 	AclSizeLimit.h
 
 ## Add conditional sources
@@ -11,7 +11,6 @@
 #include "squid.h"
 #include "acl/FilledChecklist.h"
 #include "acl/MaxConnection.h"
-#include "cache_cf.h"
 #include "client_db.h"
 #include "Debug.h"
 #include "SquidConfig.h"
@@ -52,7 +51,7 @@ ACLMaxConnection::valid () const
 void
 ACLMaxConnection::parse()
 {
-    char *t = strtokFile();
+    char *t = ConfigParser::strtokFile();
 
     if (!t)
         return;
@@ -62,7 +61,7 @@ ACLMaxConnection::parse()
     /* suck out file contents */
     // ignore comments
     bool ignore = false;
-    while ((t = strtokFile())) {
+    while ((t = ConfigParser::strtokFile())) {
         ignore |= (*t != '#');
 
         if (ignore)
@@ -11,7 +11,7 @@
 #include "squid.h"
 #include "acl/Checklist.h"
 #include "acl/MethodData.h"
-#include "cache_cf.h"
+#include "ConfigParser.h"
 #include "http/RequestMethod.h"
 
 int ACLMethodData::ThePurgeCount = 0;
@@ -54,7 +54,7 @@ ACLMethodData::dump() const
 void
 ACLMethodData::parse()
 {
-    while (char *t = strtokFile()) {
+    while (char *t = ConfigParser::strtokFile()) {
         HttpRequestMethod m;
         m.HttpRequestMethodXXX(t);
         values.push_back(m);
@@ -11,7 +11,6 @@
 #include "acl/Checklist.h"
 #include "acl/NoteData.h"
 #include "acl/StringData.h"
-#include "cache_cf.h"
 #include "ConfigParser.h"
 #include "Debug.h"
 #include "HttpRequest.h"
@@ -64,16 +63,20 @@ ACLNoteData::dump() const
 {
     SBufList sl;
     sl.push_back(SBuf(name));
+#if __cplusplus >= 201103L
+    sl.splice(sl.end(), values->dump());
+#else
     // temp is needed until c++11 move constructor
     SBufList temp = values->dump();
     sl.splice(sl.end(), temp);
+#endif
     return sl;
 }
 
 void
 ACLNoteData::parse()
 {
-    char* t = strtokFile();
+    char* t = ConfigParser::strtokFile();
     assert (t != NULL);
     name = t;
     values->parse();
@@ -11,7 +11,7 @@
 #include "squid.h"
 #include "acl/Checklist.h"
 #include "acl/ProtocolData.h"
-#include "cache_cf.h"
+#include "ConfigParser.h"
 #include "Debug.h"
 #include "wordlist.h"
 
@@ -53,7 +53,7 @@ ACLProtocolData::dump() const
 void
 ACLProtocolData::parse()
 {
-    while (char *t = strtokFile()) {
+    while (char *t = ConfigParser::strtokFile()) {
         int p = AnyP::PROTO_NONE;
         for (; p < AnyP::PROTO_UNKNOWN; ++p) {
             if (strcasecmp(t, AnyP::ProtocolType_str[p]) == 0) {
@@ -9,10 +9,8 @@
 /* DEBUG: section 28    Access Control */
 
 #include "squid.h"
-
 #include "acl/FilledChecklist.h"
 #include "acl/Random.h"
-#include "cache_cf.h"
 #include "Debug.h"
 #include "Parsing.h"
 #include "wordlist.h"
@@ -60,10 +58,9 @@ ACLRandom::valid() const
 void
 ACLRandom::parse()
 {
-    char *t;
     char bufa[256], bufb[256];
 
-    t = strtokFile();
+    char *t = ConfigParser::strtokFile();
     if (!t) {
         debugs(28, DBG_PARSE_NOTE(DBG_IMPORTANT), "ACL random missing pattern");
         return;
@@ -31,7 +31,7 @@ SourceDomainLookup::checkForAsync(ACLChecklist *checklist) const
 }
 
 void
-SourceDomainLookup::LookupDone(const char *, const DnsLookupDetails &details, void *data)
+SourceDomainLookup::LookupDone(const char *, const Dns::LookupDetails &details, void *data)
 {
     ACLFilledChecklist *checklist = Filled((ACLChecklist*)data);
     checklist->markSourceDomainChecked();
@@ -40,7 +40,7 @@ class SourceDomainLookup : public ACLChecklist::AsyncState
 
 private:
     static SourceDomainLookup instance_;
-    static void LookupDone(const char *, const DnsLookupDetails &, void *);
+    static void LookupDone(const char *, const Dns::LookupDetails &, void *);
 };
 
 class ACLSourceDomain
@@ -9,7 +9,6 @@
 #include "squid.h"
 #include "acl/Checklist.h"
 #include "acl/SslErrorData.h"
-#include "cache_cf.h"
 #include "wordlist.h"
 
 ACLSslErrorData::ACLSslErrorData() : values (NULL)
@@ -58,10 +57,9 @@ void
 ACLSslErrorData::parse()
 {
     Ssl::Errors **Tail;
-    char *t = NULL;
 
     for (Tail = &values; *Tail; Tail = &((*Tail)->next));
-    while ((t = strtokFile())) {
+    while (char *t = ConfigParser::strtokFile()) {
         Ssl::Errors *q = Ssl::ParseErrorString(t);
         *(Tail) = q;
         Tail = &q->tail()->next;
@@ -11,7 +11,7 @@
 #include "squid.h"
 #include "acl/Checklist.h"
 #include "acl/StringData.h"
-#include "cache_cf.h"
+#include "ConfigParser.h"
 #include "Debug.h"
 
 ACLStringData::ACLStringData(ACLStringData const &old) : stringValues(old.stringValues)
@@ -50,8 +50,7 @@ ACLStringData::dump() const
 void
 ACLStringData::parse()
 {
-    char *t;
-    while ((t = strtokFile()))
+    while (const char *t = ConfigParser::strtokFile())
         stringValues.insert(SBuf(t));
 }
 
@@ -12,6 +12,7 @@
 #include "acl/Checklist.h"
 #include "acl/TimeData.h"
 #include "cache_cf.h"
+#include "ConfigParser.h"
 #include "Debug.h"
 #include "wordlist.h"
 
@@ -108,9 +109,7 @@ ACLTimeData::parse()
 
     int h1, m1, h2, m2;
 
-    char *t = NULL;
-
-    while ((t = strtokFile())) {
+    while (char *t = ConfigParser::strtokFile()) {
         if (*t < '0' || *t > '9') {
             /* assume its day-of-week spec */
 
@@ -73,9 +73,13 @@ Acl::Tree::treeDump(const char *prefix, const ActionToString &convert) const
             ++action;
         }
 
+#if __cplusplus >= 201103L
+        text.splice(text.end(), (*node)->dump());
+#else
         // temp is needed until c++11 move constructor
         SBufList temp = (*node)->dump();
         text.splice(text.end(), temp);
+#endif
         text.push_back(SBuf("\n"));
     }
     return text;
@@ -16,13 +16,13 @@ class ACLChecklist;
 class ACLFilledChecklist;
 class ACLList;
 
-class AclAddress;
 class AclDenyInfoList;
 class AclSizeLimit;
 
 namespace Acl
 {
 
+class Address;
 class InnerNode;
 class NotNode;
 class AndNode;
@@ -103,7 +103,7 @@ void Adaptation::Icap::Xaction::start()
 }
 
 static void
-icapLookupDnsResults(const ipcache_addrs *ia, const DnsLookupDetails &, void *data)
+icapLookupDnsResults(const ipcache_addrs *ia, const Dns::LookupDetails &, void *data)
 {
     Adaptation::Icap::Xaction *xa = static_cast<Adaptation::Icap::Xaction *>(data);
     xa->dnsLookupDone(ia);
@@ -391,22 +391,3 @@ Auth::Negotiate::UserRequest::HandleReply(void *data, const Helper::Reply &reply
     delete r;
 }
 
-void
-Auth::Negotiate::UserRequest::addAuthenticationInfoHeader(HttpReply * rep, int accel)
-{
-    http_hdr_type type;
-
-    if (!server_blob)
-        return;
-
-    /* don't add to authentication error pages */
-    if ((!accel && rep->sline.status() == Http::scProxyAuthenticationRequired)
-            || (accel && rep->sline.status() == Http::scUnauthorized))
-        return;
-
-    type = accel ? HDR_AUTHENTICATION_INFO : HDR_PROXY_AUTHENTICATION_INFO;
-    httpHeaderPutStrf(&rep->header, type, "Negotiate %s", server_blob);
-
-    safe_free(server_blob);
-}
-
@@ -35,8 +35,6 @@ class UserRequest : public Auth::UserRequest
     virtual void startHelperLookup(HttpRequest *request, AccessLogEntry::Pointer &al, AUTHCB *, void *);
     virtual const char *credentialsStr();
 
-    virtual void addAuthenticationInfoHeader(HttpReply * rep, int accel);
-
     virtual const char * connLastHeader();
 
     /* we need to store the helper server between requests */
@@ -10,10 +10,10 @@
 
 #include "squid.h"
 #include "acl/Acl.h"
-#include "acl/AclAddress.h"
 #include "acl/AclDenyInfoList.h"
 #include "acl/AclNameList.h"
 #include "acl/AclSizeLimit.h"
+#include "acl/Address.h"
 #include "acl/Gadgets.h"
 #include "acl/MethodData.h"
 #include "acl/Tree.h"
@@ -133,8 +133,6 @@ static void free_ecap_service_type(Adaptation::Ecap::Config *);
 
 static peer_t parseNeighborType(const char *s);
 
-CBDATA_TYPE(CachePeer);
-
 static const char *const T_MILLISECOND_STR = "millisecond";
 static const char *const T_SECOND_STR = "second";
 static const char *const T_MINUTE_STR = "minute";
@@ -1361,15 +1359,12 @@ free_address(Ip::Address *addr)
     addr->setEmpty();
 }
 
-CBDATA_TYPE(AclAddress);
-
 static void
-dump_acl_address(StoreEntry * entry, const char *name, AclAddress * head)
+dump_acl_address(StoreEntry * entry, const char *name, Acl::Address * head)
 {
     char buf[MAX_IPSTRLEN];
-    AclAddress *l;
 
-    for (l = head; l; l = l->next) {
+    for (Acl::Address *l = head; l; l = l->next) {
         if (!l->addr.isAnyAddr())
             storeAppendPrintf(entry, "%s %s", name, l->addr.toStr(buf,MAX_IPSTRLEN));
         else
@@ -1382,40 +1377,26 @@ dump_acl_address(StoreEntry * entry, const char *name, AclAddress * head)
 }
 
 static void
-freed_acl_address(void *data)
-{
-    AclAddress *l = static_cast<AclAddress *>(data);
-    aclDestroyAclList(&l->aclList);
-}
-
-static void
-parse_acl_address(AclAddress ** head)
+parse_acl_address(Acl::Address ** head)
 {
-    AclAddress *l;
-    AclAddress **tail = head;   /* sane name below */
-    CBDATA_INIT_TYPE_FREECB(AclAddress, freed_acl_address);
-    l = cbdataAlloc(AclAddress);
+    Acl::Address *l = new Acl::Address;
     parse_address(&l->addr);
     aclParseAclList(LegacyParser, &l->aclList, l->addr);
 
+    Acl::Address **tail = head;
     while (*tail)
         tail = &(*tail)->next;
 
     *tail = l;
 }
 
 static void
-free_acl_address(AclAddress ** head)
+free_acl_address(Acl::Address ** head)
 {
-    while (*head) {
-        AclAddress *l = *head;
-        *head = l->next;
-        cbdataFree(l);
-    }
+    delete *head;
+    *head = NULL;
 }
 
-CBDATA_TYPE(acl_tos);
-
 static void
 dump_acl_tos(StoreEntry * entry, const char *name, acl_tos * head)
 {
@@ -1433,18 +1414,9 @@ dump_acl_tos(StoreEntry * entry, const char *name, acl_tos * head)
     }
 }
 
-static void
-freed_acl_tos(void *data)
-{
-    acl_tos *l = static_cast<acl_tos *>(data);
-    aclDestroyAclList(&l->aclList);
-}
-
 static void
 parse_acl_tos(acl_tos ** head)
 {
-    acl_tos *l;
-    acl_tos **tail = head;  /* sane name below */
     unsigned int tos;           /* Initially uint for strtoui. Casted to tos_t before return */
     char *token = ConfigParser::NextToken();
 
@@ -1464,14 +1436,13 @@ parse_acl_tos(acl_tos ** head)
         tos = chTos;
     }
 
-    CBDATA_INIT_TYPE_FREECB(acl_tos, freed_acl_tos);
-
-    l = cbdataAlloc(acl_tos);
+    acl_tos *l = new acl_tos;
 
     l->tos = (tos_t)tos;
 
     aclParseAclList(LegacyParser, &l->aclList, token);
 
+    acl_tos **tail = head;  /* sane name below */
     while (*tail)
         tail = &(*tail)->next;
 
@@ -1481,24 +1452,16 @@ parse_acl_tos(acl_tos ** head)
 static void
 free_acl_tos(acl_tos ** head)
 {
-    while (*head) {
-        acl_tos *l = *head;
-        *head = l->next;
-        l->next = NULL;
-        cbdataFree(l);
-    }
+    delete *head;
+    head = NULL;
 }
 
 #if SO_MARK && USE_LIBCAP
 
-CBDATA_TYPE(acl_nfmark);
-
 static void
 dump_acl_nfmark(StoreEntry * entry, const char *name, acl_nfmark * head)
 {
-    acl_nfmark *l;
-
-    for (l = head; l; l = l->next) {
+    for (acl_nfmark *l = head; l; l = l->next) {
         if (l->nfmark > 0)
             storeAppendPrintf(entry, "%s 0x%02X", name, l->nfmark);
         else
@@ -1510,18 +1473,9 @@ dump_acl_nfmark(StoreEntry * entry, const char *name, acl_nfmark * head)
     }
 }
 
-static void
-freed_acl_nfmark(void *data)
-{
-    acl_nfmark *l = static_cast<acl_nfmark *>(data);
-    aclDestroyAclList(&l->aclList);
-}
-
 static void
 parse_acl_nfmark(acl_nfmark ** head)
 {
-    acl_nfmark *l;
-    acl_nfmark **tail = head;   /* sane name below */
     nfmark_t mark;
     char *token = ConfigParser::NextToken();
 
@@ -1535,14 +1489,13 @@ parse_acl_nfmark(acl_nfmark ** head)
         return;
     }
 
-    CBDATA_INIT_TYPE_FREECB(acl_nfmark, freed_acl_nfmark);
-
-    l = cbdataAlloc(acl_nfmark);
+    acl_nfmark *l = new acl_nfmark;
 
     l->nfmark = mark;
 
     aclParseAclList(LegacyParser, &l->aclList, token);
 
+    acl_nfmark **tail = head;   /* sane name below */
     while (*tail)
         tail = &(*tail)->next;
 
@@ -1552,23 +1505,15 @@ parse_acl_nfmark(acl_nfmark ** head)
 static void
 free_acl_nfmark(acl_nfmark ** head)
 {
-    while (*head) {
-        acl_nfmark *l = *head;
-        *head = l->next;
-        l->next = NULL;
-        cbdataFree(l);
-    }
+    delete *head;
+    head = NULL;
 }
 #endif /* SO_MARK */
 
-CBDATA_TYPE(AclSizeLimit);
-
 static void
 dump_acl_b_size_t(StoreEntry * entry, const char *name, AclSizeLimit * head)
 {
-    AclSizeLimit *l;
-
-    for (l = head; l; l = l->next) {
+    for (AclSizeLimit *l = head; l; l = l->next) {
         if (l->size != -1)
             storeAppendPrintf(entry, "%s %d %s\n", name, (int) l->size, B_BYTES_STR);
         else
@@ -1580,27 +1525,16 @@ dump_acl_b_size_t(StoreEntry * entry, const char *name, AclSizeLimit * head)
     }
 }
 
-static void
-freed_acl_b_size_t(void *data)
-{
-    AclSizeLimit *l = static_cast<AclSizeLimit *>(data);
-    aclDestroyAclList(&l->aclList);
-}
-
 static void
 parse_acl_b_size_t(AclSizeLimit ** head)
 {
-    AclSizeLimit *l;
-    AclSizeLimit **tail = head; /* sane name below */
-
-    CBDATA_INIT_TYPE_FREECB(AclSizeLimit, freed_acl_b_size_t);
-
-    l = cbdataAlloc(AclSizeLimit);
+    AclSizeLimit *l = new AclSizeLimit;
 
     parse_b_int64_t(&l->size);
 
     aclParseAclList(LegacyParser, &l->aclList, l->size);
 
+    AclSizeLimit **tail = head; /* sane name below */
     while (*tail)
         tail = &(*tail)->next;
 
@@ -1610,12 +1544,8 @@ parse_acl_b_size_t(AclSizeLimit ** head)
 static void
 free_acl_b_size_t(AclSizeLimit ** head)
 {
-    while (*head) {
-        AclSizeLimit *l = *head;
-        *head = l->next;
-        l->next = NULL;
-        cbdataFree(l);
-    }
+    delete *head;
+    *head = NULL;
 }
 
 #if USE_DELAY_POOLS
@@ -2069,14 +1999,7 @@ static void
 parse_peer(CachePeer ** head)
 {
     char *token = NULL;
-    CachePeer *p;
-    CBDATA_INIT_TYPE_FREECB(CachePeer, peerDestroy);
-    p = cbdataAlloc(CachePeer);
-    p->http_port = CACHE_HTTP_PORT;
-    p->icp.port = CACHE_ICP_PORT;
-    p->weight = 1;
-    p->basetime = 0;
-    p->stats.logged_state = PEER_ALIVE;
+    CachePeer *p = new CachePeer;
 
     if ((token = ConfigParser::NextToken()) == NULL)
         self_destruct();
@@ -2101,7 +2024,6 @@ parse_peer(CachePeer ** head)
         self_destruct();
 
     p->icp.port = GetUdpService();
-    p->connection_auth = 2;    /* auto */
 
     while ((token = ConfigParser::NextToken())) {
         if (!strcmp(token, "proxy-only")) {
@@ -2325,10 +2247,6 @@ parse_peer(CachePeer ** head)
     if (p->connect_fail_limit < 1)
         p->connect_fail_limit = 10;
 
-    p->icp.version = ICP_VERSION_CURRENT;
-
-    p->testing_now = false;
-
 #if USE_CACHE_DIGESTS
 
     if (!p->options.no_digest) {
@@ -2354,21 +2272,8 @@ parse_peer(CachePeer ** head)
 static void
 free_peer(CachePeer ** P)
 {
-    CachePeer *p;
-
-    while ((p = *P) != NULL) {
-        *P = p->next;
-#if USE_CACHE_DIGESTS
-
-        cbdataReferenceDone(p->digest);
-#endif
-
-        // the mgr job will notice that its owner is gone and stop
-        PeerPoolMgr::Checkpoint(p->standby.mgr, "peer gone");
-        delete p->standby.pool;
-        cbdataFree(p);
-    }
-
+    delete *P;
+    *P = NULL;
     Config.npeers = 0;
 }
 
@@ -4040,12 +3945,6 @@ requirePathnameExists(const char *name, const char *path)
     }
 }
 
-char *
-strtokFile(void)
-{
-    return ConfigParser::strtokFile();
-}
-
 #include "AccessLogEntry.h"
 
 /**
@@ -24,7 +24,6 @@ void parse_eol(char *volatile *var);
 void parse_wordlist(wordlist ** list);
 void requirePathnameExists(const char *name, const char *path);
 void parse_time_t(time_t * var);
-char *strtokFile(void);
 
 #endif /* SQUID_CACHE_CF_H_ */
 
@@ -8,19 +8,6 @@
 
 /* DEBUG: section 45    Callback Data Registry */
 
-/**
- \defgroup CBDATAInternal Callback Data Allocator Internals
- \ingroup CBDATAAPI
- *
- * These routines manage a set of registered callback data pointers.
- * One of the easiest ways to make Squid coredump is to issue a
- * callback to for some data structure which has previously been
- * freed.  With these routines, we register (add) callback data
- * pointers, lock them just before registering the callback function,
- * validate them before issuing the callback, and then free them
- * when finished.
- */
-
 #include "squid.h"
 #include "cbdata.h"
 #include "Generic.h"
@@ -58,10 +45,17 @@ class CBDataCall
 
 #endif
 
-/// \ingroup CBDATAInternal
 #define OFFSET_OF(TYPE, MEMBER) ((size_t) &(((TYPE) *)0)->(MEMBER))
 
-/// \ingroup CBDATAInternal
+/**
+ * Manage a set of registered callback data pointers.
+ * One of the easiest ways to make Squid coredump is to issue a
+ * callback to for some data structure which has previously been
+ * freed.  With this class, we register (add) callback data
+ * pointers, lock them just before registering the callback function,
+ * validate them before issuing the callback, and then free them
+ * when finished.
+ */
 class cbdata
 {
 #if !HASHED_CBDATA
@@ -140,14 +134,12 @@ static OBJH cbdataDump;
 static OBJH cbdataDumpHistory;
 #endif
 
-/// \ingroup CBDATAInternal
 struct CBDataIndex {
     MemAllocator *pool;
     FREE *free_func;
 }
 *cbdata_index = NULL;
 
-/// \ingroup CBDATAInternal
 int cbdata_types = 0;
 
 #if HASHED_CBDATA
@@ -6,96 +6,96 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-#ifndef   SQUID_CBDATA_H
-#define   SQUID_CBDATA_H
+#ifndef SQUID_SRC_CBDATA_H
+#define SQUID_SRC_CBDATA_H
 
 #include "typedefs.h"
 
 /**
- \defgroup CBDATAAPI Callback Data Allocator API
- \ingroup Components
+\page CBDATA Callback Data Allocator API
+
+ \section  Introduction
+
  \par
- *    Squid's extensive use of callback functions makes it very
- *    susceptible to memory access errors. To address this all callback
- *    functions make use of a construct called cbdata. This allows
- *    functions doing callbacks to verify that the caller is still
- *    valid before making the callback.
- *
- \note  cbdata is intended for callback data and is tailored specifically
- *      to make callbacks less dangerous leaving as few windows of errors as
- *      possible. It is not suitable or intended as a generic RefCount
- *      memory allocator.
- *
- *
+   Squid's extensive use of callback functions makes it very
+   susceptible to memory access errors. To address this all callback
+   functions make use of a construct called cbdata. This allows
+   functions doing callbacks to verify that the caller is still
+   valid before making the callback.
+
+ \note cbdata is intended for callback data and is tailored specifically
+       to make callbacks less dangerous leaving as few windows of errors as
+       possible. It is not suitable or intended as a generic RefCount
+       memory allocator.
+
+ \par
+   The AsyncJob/AsyncCall mechanism is preferred over CBDATA.
+   It replaces cbdata with an AsyncCall::Pointer object which
+   performs the same memory protection duties via other means.
+
  \section Examples Examples
  \par
- *  Here you can find some examples on how to use cbdata, and why.
- *
+   Here you can find some examples on how to use cbdata, and why.
+
  \subsection AsyncOpWithoutCBDATA Asynchronous operation without cbdata, showing why cbdata is needed
  \par
- *  For a asyncronous operation with callback functions, the normal
- *  sequence of events in programs NOT using cbdata is as follows:
- *
+   For a asyncronous operation with callback functions, the normal
+   sequence of events in programs NOT using cbdata is as follows:
+
  \code
     // initialization
-    type_of_data our_data;
-    ...
-    our_data = malloc(...);
+    type_of_data our_data = new ...;
     ...
     // Initiate a asyncronous operation, with our_data as callback_data
     fooOperationStart(bar, callback_func, our_data);
     ...
     // The asyncronous operation completes and makes the callback
     callback_func(callback_data, ....);
     // Some time later we clean up our data
-    free(our_data);
+    delete our_data;
  \endcode
- *
+
  \par
- *  However, things become more interesting if we want or need
- *  to free the callback_data, or otherwise cancel the callback,
- *  before the operation completes. In constructs like this you
- *  can quite easily end up with having the memory referenced
- *  pointed to by callback_data freed before the callback is invoked
- *  causing a program failure or memory corruption:
- *
+   However, things become more interesting if we want or need
+   to free the callback_data, or otherwise cancel the callback,
+   before the operation completes. In constructs like this you
+   can quite easily end up with having the memory referenced
+   pointed to by callback_data freed before the callback is invoked
+   causing a program failure or memory corruption:
+
  \code
     // initialization
-    type_of_data our_data;
-    ...
-    our_data = malloc(...);
+    type_of_data our_data = new ...;
     ...
     // Initiate a asyncronous operation, with our_data as callback_data
     fooOperationStart(bar, callback_func, our_data);
     ...
     // ouch, something bad happened elsewhere.. try to cleanup
     // but the programmer forgot there is a callback pending from
-    // fooOperationsStart() (an easy thing to forget when writing code
+    // fooOperationsStart(). An easy thing to forget when writing code
     // to deal with errors, especially if there may be many different
-    // pending operation)
-    free(our_data);
+    // pending operations.
+    delete our_data;
     ...
     // The asyncronous operation completes and makes the callback
     callback_func(callback_data, ....);
     // CRASH, the memory pointer to by callback_data is no longer valid
     // at the time of the callback
  \endcode
- *
+
  \subsection AsyncOpWithCBDATA Asyncronous operation with cbdata
- *
+
  \par
- *  The callback data allocator lets us do this in a uniform and
- *  safe manner.  The callback data allocator is used to allocate,
- *  track and free memory pool objects used during callback
- *  operations.  Allocated memory is locked while the asyncronous
- *  operation executes elsewhere, and is freed when the operation
- *  completes.  The normal sequence of events is:
- *
+   The callback data allocator lets us do this in a uniform and
+   safe manner.  The callback data allocator is used to allocate,
+   track and free memory pool objects used during callback
+   operations.  Allocated memory is locked while the asyncronous
+   operation executes elsewhere, and is freed when the operation
+   completes.  The normal sequence of events is:
+
  \code
     // initialization
-    type_of_data our_data;
-    ...
-    our_data = cbdataAlloc(type_of_data);
+    type_of_data our_data = new type_of_data;
     ...
     // Initiate a asyncronous operation, with our_data as callback_data
     fooOperationStart(..., callback_func, our_data);
@@ -107,102 +107,130 @@
     void *cbdata;
     if (cbdataReferenceValidDone(local_pointer, &amp;cbdata))
         callback_func(...., cbdata);
-    ...
-    cbdataFree(our_data);
+    delete our_data;
  \endcode
- *
+
  \subsection AsynchronousOpCancelledByCBDATA Asynchronous operation cancelled by cbdata
- *
+
  \par
- *  With this scheme, nothing bad happens if cbdataFree() gets called
- *  before fooOperantionComplete(...).
- *
+   With this scheme, nothing bad happens if delete gets called
+   before fooOperantionComplete(...).
+
  \par   Initalization
  \code
-    type_of_data our_data;
+    // initialization
+    type_of_data our_data = new type_of_data;
     ...
-    our_data = cbdataAlloc(type_of_data);
- \endcode
- *  Initiate a asyncronous operation, with our_data as callback_data
- \code
+    // Initiate a asyncronous operation, with our_data as callback_data
     fooOperationStart(..., callback_func, our_data);
- \endcode
- *  do some stuff with it
- \code
+    ...
+    // do some stuff with it
     void *local_pointer = cbdataReference(callback_data);
- \endcode
- *  something bad happened elsewhere.. cleanup
- \code
-    cbdataFree(our_data);
- \endcode
- *  The asyncronous operation completes and tries to make the callback
- \code
+    ...
+    // something bad happened elsewhere.. cleanup
+    delete our_data;
+    ....
+    // The asyncronous operation completes and makes the callback
     void *cbdata;
     if (cbdataReferenceValidDone(local_pointer, &amp;cbdata))
-        {
- \endcode
- *  won't be called, as the data is no longer valid
- \code
+        // won't be called, as the data is no longer valid
         callback_func(...., cbdata);
-    }
+    delete our_data;
  \endcode
- *
+
  \par
- *  In this case, when cbdataFree() is called before
- *  cbdataReferenceValidDone(), the callback_data gets marked as invalid.
- *  When the callback_data is invalid before executing the callback
- *  function, cbdataReferenceValidDone() will return 0 and
- *  callback_func is never executed.
- *
+   In this case, when delete is called before cbdataReferenceValidDone(),
+   the callback_data gets marked as invalid.
+   When the callback_data is invalid before executing the callback
+   function, cbdataReferenceValidDone() will return 0 and
+   callback_func is never executed.
+
  \subsection AddingCBDATAType Adding a new cbdata registered type
- *
+
+ \par
+   To add new module specific data types to the allocator one uses
+   the macro CBDATA_CLASS() in the class private section, and
+   CBDATA_CLASS_INIT() or CBDATA_NAMESPACED_CLASS_INIT() in the
+   class .cc file.
+
+ \code
+    class Foo
+    {
+        CBDATA_CLASS(Foo);
+
+    public:
+        Foo() {}
+        ~Foo() {}
+    };
+    ...
+    CBDATA_CLASS_INIT(Foo);
+ \endcode
+
+ \par
+   These macros create new(), delete() and toCbdata() methods
+   definition in class scope. Any allocate calls must be made with
+   new() and destruction with delete(), they may be called from
+   anywhere.
+
+ \par
+   The class constructor must make sure that all member
+   variables are initialized, and the class destructor that all
+   dynamic memory is released.
+
  \par
- *  To add new module specific data types to the allocator one uses the
- *  macro CBDATA_CLASS() in the class private section, and CBDATA_CLASS_INIT()
- *      or CBDATA_NAMESPACED_CLASS_INIT() in the .cc file.
- *      This creates new(), delete() and toCbdata() methods
- *  definition in class scope. Any allocate calls must be made with
- *      new() and destruction with delete(), they may be called from anywhere.
+   The CbcPointer<> template should be used to create a smart-pointer
+   type for simple reference tracking. It provides get() and valid()
+   accessors for use instead of cbdataReferenceValid(), and performs
+   reliable automatic cbdataReference() and cbdataReferenceDone()
+   tracking.
+   Note that it does NOT provide a replacement for cbdataReferenceValidDone().
+
  */
 
 /**
- *\ingroup CBDATAAPI
  * cbdata types. Similar to the MEM_* types, but managed in cbdata.cc
  * A big difference is that cbdata types are dynamically allocated.
- * Initially only UNKNOWN type is predefined. Other types are added runtime.
+ *
+ * Initially only UNKNOWN type is predefined.
+ * Other types are added at runtime by CBDATA_CLASS().
  */
 typedef int cbdata_type;
 static const cbdata_type CBDATA_UNKNOWN = 0;
 
-/// \ingroup CBDATAAPI
+/**
+ * Create a run-time registration of CBDATA component with
+ * the Squid cachemgr
+ */
 void cbdataRegisterWithCacheManager(void);
 
 /**
  * Allocates a new entry of a registered CBDATA type.
- * \deprecated use CBDATA_CLASS() instead
+ *
+ * \note For internal CBDATA use only.
  */
 void *cbdataInternalAlloc(cbdata_type type, const char *, int);
-/// \deprecated use CBDATA_CLASS() instead
-#define cbdataAlloc(type) ((type *)cbdataInternalAlloc(CBDATA_##type,__FILE__,__LINE__))
 
 /**
- * Frees a entry allocated by cbdataAlloc().
+ * Frees a entry allocated by cbdataInternalAlloc().
+ *
+ * Once this has been called cbdataReferenceValid() and
+ * cbdataReferenceValidDone() will return false regardless
+ * of whether there are remaining cbdata references.
  *
- \note  If there are active references to the entry then the entry
- *      will be freed with the last reference is removed. However,
- *      cbdataReferenceValid() will return false for those references.
- * \deprecated use CBDATA_CLASS() instead
+ * cbdataReferenceDone() must still be called for any active
+ * references to the cbdata entry. The cbdata entry will be freed
+ * only when the last reference is removed.
+ *
+ * \note For internal CBDATA use only.
  */
 void *cbdataInternalFree(void *p, const char *, int);
-/// \deprecated use CBDATA_CLASS() instead
-#define cbdataFree(var)     do {if (var) {cbdataInternalFree(var,__FILE__,__LINE__); var = NULL;}} while(0)
 
 #if USE_CBDATA_DEBUG
 void cbdataInternalLockDbg(const void *p, const char *, int);
-#define cbdataInternalLock(a)       cbdataInternalLockDbg(a,__FILE__,__LINE__)
+#define cbdataInternalLock(a) cbdataInternalLockDbg(a,__FILE__,__LINE__)
 
 void cbdataInternalUnlockDbg(const void *p, const char *, int);
-#define cbdataInternalUnlock(a)     cbdataInternalUnlockDbg(a,__FILE__,__LINE__)
+#define cbdataInternalUnlock(a) cbdataInternalUnlockDbg(a,__FILE__,__LINE__)
 
 int cbdataInternalReferenceDoneValidDbg(void **p, void **tp, const char *, int);
 #define cbdataReferenceValidDone(var, ptr) cbdataInternalReferenceDoneValidDbg((void **)&(var), (ptr), __FILE__,__LINE__)
@@ -223,8 +251,8 @@ void cbdataInternalUnlock(const void *p);
             callback(..., cbdata);
  \endcode
  *
- \param var The reference variable. Will be automatically cleared to NULL.
- \param ptr A temporary pointer to the referenced data (if valid).
+ * \param var The reference variable. Will be automatically cleared to NULL.
+ * \param ptr A temporary pointer to the referenced data (if valid).
  */
 int cbdataInternalReferenceDoneValid(void **p, void **tp);
 #define cbdataReferenceValidDone(var, ptr) cbdataInternalReferenceDoneValid((void **)&(var), (ptr))
@@ -234,123 +262,99 @@ int cbdataInternalReferenceDoneValid(void **p, void **tp);
 /**
  * \param p A cbdata entry reference pointer.
  *
- * \retval 0    A reference is stale. The pointer refers to a entry freed by cbdataFree().
+ * \retval 0    A reference is stale. The pointer refers to a entry already freed.
  * \retval true The reference is valid and active.
  */
 int cbdataReferenceValid(const void *p);
 
-/// \ingroup CBDATAAPI
+/**
+ * Create a run-time registration for the class type with cbdata memory allocator.
+ *
+ * \note For internal CBDATA use only.
+ */
 cbdata_type cbdataInternalAddType(cbdata_type type, const char *label, int size, FREE * free_func);
 
 /**
  * This needs to be defined FIRST in the class definition.
  * It plays with private/public states in C++.
  */
-#define CBDATA_CLASS(type)  \
+#define CBDATA_CLASS(type) \
     public: \
         void *operator new(size_t size) { \
           assert(size == sizeof(type)); \
-          if (!CBDATA_##type) \
-                      CBDATA_##type = cbdataInternalAddType(CBDATA_##type, #type, sizeof(type), NULL); \
+          if (!CBDATA_##type) CBDATA_##type = cbdataInternalAddType(CBDATA_##type, #type, sizeof(type), NULL); \
           return (type *)cbdataInternalAlloc(CBDATA_##type,__FILE__,__LINE__); \
         } \
         void operator delete (void *address) { \
-          if (address) cbdataInternalFree(address,__FILE__,__LINE__);\
+          if (address) cbdataInternalFree(address,__FILE__,__LINE__); \
         } \
-                void *toCbdata() { return this; } \
+        void *toCbdata() { return this; } \
     private: \
-    static cbdata_type CBDATA_##type;
+       static cbdata_type CBDATA_##type;
 
 /**
- \par
- *    Creates a new reference to a cbdata entry. Used when you need to
- *    store a reference in another structure. The reference can later
- *    be verified for validity by cbdataReferenceValid().
+ * Creates a global instance pointer for the CBDATA memory allocator
+ * to allocate and free objects for the matching CBDATA_CLASS().
  *
- \param var
- *       The reference variable is a pointer to the entry, in all
- *       aspects identical to the original pointer. But semantically it
- *       is quite different. It is best if the reference is thought of
- *       and handled as a "void *".
- */
-#define cbdataReference(var)    (cbdataInternalLock(var), var)
-
-/**
- \ingroup CBDATAAPI
- * Removes a reference created by cbdataReference().
+ * Place this in the appropriate .cc file for the class being registered.
  *
- \param var The reference variable. Will be automatically cleared to NULL.
+ * May be placed inside an explicit namespace scope declaration,
+ * or CBDATA_NAMESPACED_CLASS_INIT() used instead.
  */
-#define cbdataReferenceDone(var) do {if (var) {cbdataInternalUnlock(var); var = NULL;}} while(0)
-
-/// \ingroup CBDATAAPI
 #define CBDATA_CLASS_INIT(type) cbdata_type type::CBDATA_##type = CBDATA_UNKNOWN
-#define CBDATA_NAMESPACED_CLASS_INIT(namespace, type) cbdata_type namespace::type::CBDATA_##type = CBDATA_UNKNOWN
 
 /**
- * Macro that defines a new cbdata datatype. Similar to a variable
- * or struct definition. Scope is always local to the file/block
- * where it is defined and all calls to cbdataAlloc() for this type
- * must be within the same scope as the CBDATA_TYPE declaration.
- * Allocated entries may be referenced or freed anywhere with no
- * restrictions on scope.
- * \deprecated Use CBDATA_CLASS() instead
+ * Creates a global instance pointer for the CBDATA memory allocator
+ * to allocate and free objects for the matching CBDATA_CLASS().
+ *
+ * Place this in the appropriate .cc file for the class being registered.
  */
-#define CBDATA_TYPE(type)   static cbdata_type CBDATA_##type = CBDATA_UNKNOWN
+#define CBDATA_NAMESPACED_CLASS_INIT(namespace, type) cbdata_type namespace::type::CBDATA_##type = CBDATA_UNKNOWN
 
 /**
- \ingroup CBDATAAPI
+ * Creates a new reference to a cbdata entry. Used when you need to
+ * store a reference in another structure. The reference can later
+ * be verified for validity by cbdataReferenceValid().
  *
- * Initializes the cbdatatype. Must be called prior to the first use of cbdataAlloc() for the type.
+ * \deprecated Prefer the use of CbcPointer<> smart pointer.
  *
- \par
- * Alternative to CBDATA_INIT_TYPE()
- *
- \param type        Type being initialized
- \param free_func   The freehandler called when the last known reference to an allocated entry goes away.
+ * \param var
+ *       The reference variable is a pointer to the entry, in all
+ *       aspects identical to the original pointer. But semantically it
+ *       is quite different. It is best if the reference is thought of
+ *       and handled as a "void *".
  */
-#define CBDATA_INIT_TYPE_FREECB(type, free_func) do { if (!CBDATA_##type) CBDATA_##type = cbdataInternalAddType(CBDATA_##type, #type, sizeof(type), free_func); } while (false)
+#define cbdataReference(var)    (cbdataInternalLock(var), var)
 
 /**
- * Initializes the cbdatatype. Must be called prior to the first use of cbdataAlloc() for the type.
- *
- \par
- * Alternative to CBDATA_INIT_TYPE_FREECB()
+ * Removes a reference created by cbdataReference().
  *
- \param type        Type being initialized
+ * \deprecated Prefer the use of CbcPointer<> smart pointer.
  *
- * \deprecated Use CBDATA_CLASS() instead
+ * \param var The reference variable. Will be automatically cleared to NULL.
  */
-#define CBDATA_INIT_TYPE(type)  CBDATA_INIT_TYPE_FREECB(type, NULL)
+#define cbdataReferenceDone(var) do {if (var) {cbdataInternalUnlock(var); var = NULL;}} while(0)
 
 /**
- \ingroup CBDATA
- *
- * A generic wrapper for passing objects through cbdata.
+ * A generic wrapper for passing object pointers through cbdata.
  * Use this when you need to pass callback data to a blocking
- * operation, but you don't want to/cannot have that pointer be cbdata itself.
+ * operation, but you don't want to/cannot have that pointer be
+ * cbdata itself.
  */
 class generic_cbdata
 {
     CBDATA_CLASS(generic_cbdata);
 
 public:
-
-    generic_cbdata(void * aData) : data(aData) {}
+    generic_cbdata(void *aData) : data(aData) {}
 
     template<typename wrapped_type>void unwrap(wrapped_type **output) {
         *output = static_cast<wrapped_type *>(data);
         delete this;
     }
 
-    /**
-     * The wrapped data - only public to allow the mild abuse of this facility
-     * done by store_swapout - it gives a wrapped StoreEntry to StoreIO as the
-     * object to be given to the callbacks. That needs to be fully cleaned up!
-     * - RBC 20060820
-     \todo CODE: make this a private field.
-     */
-    void *data; /* the wrapped data */
+private:
+    void *data;
 };
 
 #endif /* SQUID_CBDATA_H */
@@ -155,6 +155,7 @@ DOC_START
 	Remove this line. Use always_direct or cache_peer_access ACLs instead if you need to prevent cache_peer use.
 DOC_END
 
+# Options removed in 3.4
 NAME: log_access
 TYPE: obsolete
 DOC_START
@@ -175,6 +176,12 @@ DOC_START
 DOC_END
 
 # Options Removed in 3.2
+NAME: chunked_request_body_max_size
+TYPE: obsolete
+DOC_START
+	Remove this line. Squid is now HTTP/1.1 compliant.
+DOC_END
+
 NAME: dns_v4_fallback
 TYPE: obsolete
 DOC_START
@@ -5673,33 +5680,6 @@ DOC_START
 	a large file.
 DOC_END
 
-NAME: chunked_request_body_max_size
-COMMENT: (bytes)
-TYPE: b_int64_t
-DEFAULT: 64 KB
-LOC: Config.maxChunkedRequestBodySize
-DOC_START
-	A broken or confused HTTP/1.1 client may send a chunked HTTP
-	request to Squid. Squid does not have full support for that
-	feature yet. To cope with such requests, Squid buffers the
-	entire request and then dechunks request body to create a
-	plain HTTP/1.0 request with a known content length. The plain
-	request is then used by the rest of Squid code as usual.
-
-	The option value specifies the maximum size of the buffer used
-	to hold the request before the conversion. If the chunked
-	request size exceeds the specified limit, the conversion
-	fails, and the client receives an "unsupported request" error,
-	as if dechunking was disabled.
-
-	Dechunking is enabled by default. To disable conversion of
-	chunked requests, set the maximum to zero.
-
-	Request dechunking feature and this option in particular are a
-	temporary hack. When chunking requests and responses are fully
-	supported, there will be no need to buffer a chunked request.
-DOC_END
-
 NAME: broken_posts
 IFDEF: USE_HTTP_VIOLATIONS
 TYPE: acl_access
@@ -44,7 +44,7 @@
  \par
  * Each node including the HEAD of the clientStream has a cbdataReference
  * held by the stream. Freeing the stream then removes that reference
- * and cbdataFree()'s every node.
+ * and delete's every node.
  * Any node with other References, and all nodes downstream will only
  * free when those references are released.
  * Stream nodes MAY hold references to the data member of the node.
@@ -72,34 +72,30 @@
  \code
    mycontext = thisObject->data;
    thisObject->data = NULL;
-   clientStreamFree (thisObject->head);
+   delete thisObject->head;
    mycontext = NULL;
    return;
  \endcode
  *
  \todo rather than each node undeleting the next, have a clientStreamDelete that walks the list.
  */
 
-/// \ingroup ClientStreamInternal
-CBDATA_TYPE(clientStreamNode);
+CBDATA_CLASS_INIT(clientStreamNode);
 
-/* Local functions */
-static FREE clientStreamFree;
+clientStreamNode::clientStreamNode(CSR * aReadfunc, CSCB * aCallback, CSD * aDetach, CSS * aStatus, ClientStreamData aData) :
+    readfunc(aReadfunc),
+    callback(aCallback),
+    detach(aDetach),
+    status(aStatus),
+    data(aData)
+{}
 
-/// \ingroup ClientStreamInternal
-clientStreamNode *
-clientStreamNew(CSR * readfunc, CSCB * callback, CSD * detach, CSS * status,
-                ClientStreamData data)
+clientStreamNode::~clientStreamNode()
 {
-    clientStreamNode *temp;
-    CBDATA_INIT_TYPE_FREECB(clientStreamNode, clientStreamFree);
-    temp = cbdataAlloc(clientStreamNode);
-    temp->readfunc = readfunc;
-    temp->callback = callback;
-    temp->detach = detach;
-    temp->status = status;
-    temp->data = data;
-    return temp;
+    debugs(87, 3, "Freeing clientStreamNode " << this);
+
+    removeFromStream();
+    data = NULL;
 }
 
 /**
@@ -115,8 +111,7 @@ clientStreamInit(dlink_list * list, CSR * func, CSD * rdetach, CSS * readstatus,
                  ClientStreamData readdata, CSCB * callback, CSD * cdetach, ClientStreamData callbackdata,
                  StoreIOBuffer tailBuffer)
 {
-    clientStreamNode *temp = clientStreamNew(func, NULL, rdetach, readstatus,
-                             readdata);
+    clientStreamNode *temp = new clientStreamNode(func, NULL, rdetach, readstatus, readdata);
     dlinkAdd(cbdataReference(temp), &temp->node, list);
     temp->head = list;
     clientStreamInsertHead(list, NULL, callback, cdetach, NULL, callbackdata);
@@ -134,11 +129,10 @@ void
 clientStreamInsertHead(dlink_list * list, CSR * func, CSCB * callback,
                        CSD * detach, CSS * status, ClientStreamData data)
 {
-
     /* test preconditions */
     assert(list != NULL);
     assert(list->head);
-    clientStreamNode *temp = clientStreamNew(func, callback, detach, status, data);
+    clientStreamNode *temp = new clientStreamNode(func, callback, detach, status, data);
     temp->head = list;
     debugs(87, 3, "clientStreamInsertHead: Inserted node " << temp <<
            " with data " << data.getRaw() << " after head");
@@ -211,7 +205,7 @@ clientStreamDetach(clientStreamNode * thisObject, ClientHttpRequest * http)
 
     cbdataReferenceDone(temp);
 
-    cbdataFree(thisObject);
+    delete thisObject;
 
     /* and tell the prev that the detach has occured */
     /*
@@ -267,8 +261,6 @@ clientStreamStatus(clientStreamNode * thisObject, ClientHttpRequest * http)
     return prev->status(prev, http);
 }
 
-/* Local function bodies */
-
 void
 clientStreamNode::removeFromStream()
 {
@@ -278,18 +270,6 @@ clientStreamNode::removeFromStream()
     head = NULL;
 }
 
-/// \ingroup ClientStreamInternal
-void
-clientStreamFree(void *foo)
-{
-    clientStreamNode *thisObject = (clientStreamNode *)foo;
-
-    debugs(87, 3, "Freeing clientStreamNode " << thisObject);
-
-    thisObject->removeFromStream();
-    thisObject->data = NULL;
-}
-
 clientStreamNode *
 clientStreamNode::prev() const
 {
@@ -73,14 +73,18 @@
  \li        Because of the callback nature of squid, every node would have to keep these parameters in their context anyway, so this reduces programmer overhead.
  */
 
-/// \ingroup ClientStreamAPI
 class clientStreamNode
 {
+    CBDATA_CLASS(clientStreamNode);
 
 public:
+    clientStreamNode(CSR * aReadfunc, CSCB * aCallback, CSD * aDetach, CSS * aStatus, ClientStreamData);
+    ~clientStreamNode();
+
     clientStreamNode *prev() const;
     clientStreamNode *next() const;
     void removeFromStream();
+
     dlink_node node;
     dlink_list *head;       /* sucks I know, but hey, the interface is limited */
     CSR *readfunc;
@@ -97,9 +101,6 @@ void clientStreamInit(dlink_list *, CSR *, CSD *, CSS *, ClientStreamData, CSCB
 /// \ingroup ClientStreamAPI
 void clientStreamInsertHead(dlink_list *, CSR *, CSCB *, CSD *, CSS *, ClientStreamData);
 
-/// \ingroup ClientStreamAPI
-clientStreamNode *clientStreamNew(CSR *, CSCB *, CSD *, CSS *, ClientStreamData);
-
 /**
  \ingroup ClientStreamAPI
  *
@@ -500,14 +500,14 @@ clientFollowXForwardedForCheck(allow_t answer, void *data)
 #endif /* FOLLOW_X_FORWARDED_FOR */
 
 static void
-hostHeaderIpVerifyWrapper(const ipcache_addrs* ia, const DnsLookupDetails &dns, void *data)
+hostHeaderIpVerifyWrapper(const ipcache_addrs* ia, const Dns::LookupDetails &dns, void *data)
 {
     ClientRequestContext *c = static_cast<ClientRequestContext*>(data);
     c->hostHeaderIpVerify(ia, dns);
 }
 
 void
-ClientRequestContext::hostHeaderIpVerify(const ipcache_addrs* ia, const DnsLookupDetails &dns)
+ClientRequestContext::hostHeaderIpVerify(const ipcache_addrs* ia, const Dns::LookupDetails &dns)
 {
     Comm::ConnectionPointer clientConn = http->getConn()->clientConnection;
 
@@ -9,19 +9,10 @@
 /* DEBUG: section 78    DNS lookups */
 
 #include "squid.h"
-#include "DnsLookupDetails.h"
-
-DnsLookupDetails::DnsLookupDetails(): wait(-1)
-{
-}
-
-DnsLookupDetails::DnsLookupDetails(const String &e, int w):
-    error(e), wait(w)
-{
-}
+#include "dns/LookupDetails.h"
 
 std::ostream &
-DnsLookupDetails::print(std::ostream &os) const
+Dns::LookupDetails::print(std::ostream &os) const
 {
     if (wait > 0)
         os << "lookup_wait=" << wait;
@@ -8,30 +8,35 @@
 
 /* DEBUG: section 78    DNS lookups */
 
-#ifndef SQUID_DNS_LOOKUP_DETAILS_H
-#define SQUID_DNS_LOOKUP_DETAILS_H
+#ifndef SQUID_DNS_LOOKUPDETAILS_H
+#define SQUID_DNS_LOOKUPDETAILS_H
 
 #include "SquidString.h"
 
+namespace Dns
+{
+
 /// encapsulates DNS lookup results
-class DnsLookupDetails
+class LookupDetails
 {
 public:
-    DnsLookupDetails(); ///< no error, no lookup delay (i.e., no lookup)
-    DnsLookupDetails(const String &error, int wait);
+    LookupDetails() : wait(-1) {} ///< no error, no lookup delay (i.e., no lookup)
+    LookupDetails(const String &anError, int aWait) : error(anError), wait(aWait) {}
 
     std::ostream &print(std::ostream &os) const;
 
 public:
-    String error; ///< error message for unsuccessdul lookups; empty otherwise
+    String error; ///< error message for unsuccessful lookups; empty otherwise
     int wait; ///< msecs spent waiting for the lookup (if any) or -1 (if none)
 };
 
-inline
-std::ostream &operator << (std::ostream &os, const DnsLookupDetails &dns)
+} // namespace Dns
+
+inline std::ostream &
+operator <<(std::ostream &os, const Dns::LookupDetails &dns)
 {
     return dns.print(os);
 }
 
-#endif
+#endif /* SQUID_DNS_LOOKUPDETAILS_H */
 
@@ -0,0 +1,24 @@
+## Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+##
+## Squid software is distributed under GPLv2+ license and includes
+## contributions from numerous individuals and organizations.
+## Please see the COPYING and CONTRIBUTORS files for details.
+##
+
+include $(top_srcdir)/src/Common.am
+include $(top_srcdir)/src/TestHeaders.am
+
+AUTOMAKE_OPTIONS = subdir-objects
+
+noinst_LTLIBRARIES = libdns.la
+
+libdns_la_SOURCES = \
+	forward.h \
+	LookupDetails.cc \
+	LookupDetails.h \
+	rfc1035.cc \
+	rfc1035.h \
+	rfc2671.cc \
+	rfc2671.h \
+	rfc3596.cc \
+	rfc3596.h
@@ -6,21 +6,32 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-#ifndef SQUID_DNS_H
-#define SQUID_DNS_H
+#ifndef _SQUID_SRC_DNS_FORWARD_H
+#define _SQUID_SRC_DNS_FORWARD_H
 
 namespace Ip
 {
 class Address;
 }
 
+class rfc1035_rr;
+
+typedef void IDNSCB(void *, const rfc1035_rr *, int, const char *);
+
 // generic DNS API
-void dnsInit(void);
-void dnsShutdown(void);
+namespace Dns
+{
+
+class LookupDetails;
+
+void Init(void);
+void Shutdown(void);
+
+} // namespace Dns
 
 // internal DNS client API
 void idnsALookup(const char *, IDNSCB *, void *);
 void idnsPTRLookup(const Ip::Address &, IDNSCB *, void *);
 
-#endif /* SQUID_DNS_H */
+#endif /* _SQUID_SRC_DNS_FORWARD_H */
 
@@ -15,6 +15,8 @@
  */
 
 #include "squid.h"
+#include "dns/rfc1035.h"
+#include "dns/rfc2671.h"
 #include "util.h"
 
 #if HAVE_STRING_H
@@ -39,9 +41,6 @@
 #include <strings.h>
 #endif
 
-#include "rfc1035.h"
-#include "rfc2671.h"
-
 #define RFC1035_MAXLABELSZ 63
 #define rfc1035_unpack_error 15
 
@@ -33,8 +33,9 @@
 
 #define RFC1035_DEFAULT_PACKET_SZ 512
 
-typedef struct _rfc1035_rr rfc1035_rr;
-struct _rfc1035_rr {
+class rfc1035_rr
+{
+public:
     char name[RFC1035_MAXHOSTNAMESZ];
     unsigned short type;
     unsigned short _class;
@@ -7,8 +7,8 @@
  */
 
 #include "squid.h"
-#include "rfc1035.h"
-#include "rfc2671.h"
+#include "dns/rfc1035.h"
+#include "dns/rfc2671.h"
 
 int
 rfc2671RROptPack(char *buf, size_t sz, ssize_t edns_sz)
@@ -7,6 +7,8 @@
  */
 
 #include "squid.h"
+#include "dns/rfc2671.h"
+#include "dns/rfc3596.h"
 #include "util.h"
 
 #if HAVE_UNISTD_H
@@ -25,9 +27,6 @@
 #include <strings.h>
 #endif
 
-#include "rfc2671.h"
-#include "rfc3596.h"
-
 #ifndef SQUID_RFC1035_H
 #error RFC3596 Library depends on RFC1035
 #endif
@@ -10,7 +10,7 @@
 #define SQUID_RFC3596_H
 
 /* RFC 3596 extends RFC 1035 */
-#include "rfc1035.h"
+#include "dns/rfc1035.h"
 
 SQUIDCEXTERN ssize_t rfc3596BuildAQuery(const char *hostname,
                                         char *buf,
@@ -6,7 +6,7 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-/* DEBUG: section 78    DNS lookups; interacts with lib/rfc1035.c */
+/* DEBUG: section 78    DNS lookups; interacts with dns/rfc1035.cc */
 
 #include "squid.h"
 #include "base/InstanceId.h"
@@ -17,13 +17,14 @@
 #include "comm/Read.h"
 #include "comm/Write.h"
 #include "dlink.h"
+#include "dns/forward.h"
+#include "dns/rfc3596.h"
 #include "event.h"
 #include "fd.h"
 #include "fde.h"
 #include "ip/tools.h"
 #include "MemBuf.h"
 #include "mgr/Registration.h"
-#include "rfc3596.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
@@ -93,15 +94,54 @@ static const char *Rcodes[] = {
     "Bad OPT Version or TSIG Signature Failure"
 };
 
-typedef struct _idns_query idns_query;
-
 typedef struct _ns ns;
 
 typedef struct _sp sp;
 
-typedef struct _nsvc nsvc;
+class idns_query
+{
+    CBDATA_CLASS(idns_query);
+
+public:
+    idns_query() :
+        sz(0),
+        query_id(0),
+        nsends(0),
+        need_vc(0),
+        permit_mdns(false),
+        pending(0),
+        callback(NULL),
+        callback_data(NULL),
+        attempt(0),
+        rcode(0),
+        queue(NULL),
+        slave(NULL),
+        master(NULL),
+        domain(0),
+        do_searchpath(0),
+        message(NULL),
+        ancount(0),
+        error(NULL)
+    {
+        memset(&hash, 0, sizeof(hash));
+        memset(&query, 0, sizeof(query));
+        *buf = 0;
+        *name = 0;
+        *orig = 0;
+        memset(&start_t, 0, sizeof(start_t));
+        memset(&sent_t, 0, sizeof(sent_t));
+        memset(&queue_t, 0, sizeof(queue_t));
+    }
+
+    ~idns_query() {
+        if (message)
+            rfc1035MessageDestroy(&message);
+        delete queue;
+        delete slave;
+        // master is just a back-reference
+        cbdataReferenceDone(callback_data);
+    }
 
-struct _idns_query {
     hash_link hash;
     rfc1035_query query;
     char buf[RESOLV_BUFSZ];
@@ -133,9 +173,19 @@ struct _idns_query {
     int ancount;
     const char *error;
 };
+
 InstanceIdDefinitions(idns_query,  "dns");
 
-struct _nsvc {
+CBDATA_CLASS_INIT(idns_query);
+
+class nsvc
+{
+    CBDATA_CLASS(nsvc);
+
+public:
+    explicit nsvc(int nsv) : ns(nsv), msglen(0), read_msglen(0), msg(new MemBuf()), queue(new MemBuf()), busy(true) {}
+    ~nsvc();
+
     int ns;
     Comm::ConnectionPointer conn;
     unsigned short msglen;
@@ -145,6 +195,8 @@ struct _nsvc {
     bool busy;
 };
 
+CBDATA_CLASS_INIT(nsvc);
+
 struct _ns {
     Ip::Address S;
     int nqueries;
@@ -161,9 +213,6 @@ struct _sp {
     int queries;
 };
 
-CBDATA_TYPE(nsvc);
-CBDATA_TYPE(idns_query);
-
 static ns *nameservers = NULL;
 static sp *searchpath = NULL;
 static int nns = 0;
@@ -849,25 +898,24 @@ static void
 idnsVCClosed(const CommCloseCbParams &params)
 {
     nsvc * vc = (nsvc *)params.data;
-    delete vc->queue;
-    delete vc->msg;
-    vc->conn = NULL;
-    if (vc->ns < nns) // XXX: dnsShutdown may have freed nameservers[]
-        nameservers[vc->ns].vc = NULL;
-    cbdataFree(vc);
+    delete vc;
+}
+
+nsvc::~nsvc()
+{
+    delete queue;
+    delete msg;
+    if (ns < nns) // XXX: Dns::Shutdown may have freed nameservers[]
+        nameservers[ns].vc = NULL;
 }
 
 static void
 idnsInitVC(int nsv)
 {
-    nsvc *vc = cbdataAlloc(nsvc);
+    nsvc *vc = new nsvc(nsv);
     assert(nsv < nns);
     assert(vc->conn == NULL); // MUST be NULL from the construction process!
     nameservers[nsv].vc = vc;
-    vc->ns = nsv;
-    vc->queue = new MemBuf;
-    vc->msg = new MemBuf;
-    vc->busy = 1;
 
     Comm::ConnectionPointer conn = new Comm::Connection();
 
@@ -1055,6 +1103,7 @@ idnsCallback(idns_query *q, const char *error)
     while ( idns_query *q2 = q->slave ) {
         debugs(78, 6, HERE << "Merging DNS results " << q->name << " A has " << n << " RR, AAAA has " << q2->ancount << " RR");
         q->slave = q2->slave;
+        q2->slave = NULL;
         if ( !q2->error ) {
             if (n > 0) {
                 // two sets of RR need merging
@@ -1082,8 +1131,7 @@ idnsCallback(idns_query *q, const char *error)
                 error = NULL;
             }
         }
-        rfc1035MessageDestroy(&q2->message);
-        cbdataFree(q2);
+        delete q2;
     }
 
     debugs(78, 6, HERE << "Sending " << n << " (" << (error ? error : "OK") << ") DNS results to caller.");
@@ -1098,13 +1146,15 @@ idnsCallback(idns_query *q, const char *error)
     while (q->queue) {
         idns_query *q2 = q->queue;
         q->queue = q2->queue;
+        q2->queue = NULL;
+
         callback = q2->callback;
         q2->callback = NULL;
 
         if (cbdataReferenceValidDone(q2->callback_data, &cbdata))
             callback(cbdata, answers, n, error);
 
-        cbdataFree(q2);
+        delete q2;
     }
 
     if (q->hash.key) {
@@ -1113,17 +1163,15 @@ idnsCallback(idns_query *q, const char *error)
     }
 
     rfc1035MessageDestroy(&message);
-    cbdataFree(q);
+    delete q;
 }
 
 static void
 idnsGrokReply(const char *buf, size_t sz, int /*from_ns*/)
 {
-    int n;
     rfc1035_message *message = NULL;
-    idns_query *q;
 
-    n = rfc1035MessageUnpack(buf, sz, &message);
+    int n = rfc1035MessageUnpack(buf, sz, &message);
 
     if (message == NULL) {
         debugs(78, DBG_IMPORTANT, "idnsGrokReply: Malformed DNS response");
@@ -1132,7 +1180,7 @@ idnsGrokReply(const char *buf, size_t sz, int /*from_ns*/)
 
     debugs(78, 3, "idnsGrokReply: QID 0x" << std::hex <<   message->id << ", " << std::dec << n << " answers");
 
-    q = idnsFindQuery(message->id);
+    idns_query *q = idnsFindQuery(message->id);
 
     if (q == NULL) {
         debugs(78, 3, "idnsGrokReply: Late response");
@@ -1233,8 +1281,8 @@ idnsGrokReply(const char *buf, size_t sz, int /*from_ns*/)
             while (idns_query *slave = q->slave) {
                 dlinkDelete(&slave->lru, &lru_list);
                 q->slave = slave->slave;
-                rfc1035MessageDestroy(&slave->message);
-                cbdataFree(slave);
+                slave->slave = NULL;
+                delete slave;
             }
 
             // Build new query
@@ -1497,22 +1545,11 @@ idnsRcodeCount(int rcode, int attempt)
             ++ RcodeMatrix[rcode][attempt];
 }
 
-/* ====================================================================== */
-
-static void
-idnsRegisterWithCacheManager(void)
-{
-    Mgr::RegisterAction("idns", "Internal DNS Statistics", idnsStats, 0, 1);
-}
-
 void
-dnsInit(void)
+Dns::Init(void)
 {
     static int init = 0;
 
-    CBDATA_INIT_TYPE(nsvc);
-    CBDATA_INIT_TYPE(idns_query);
-
     if (DnsSocketA < 0 && DnsSocketB < 0) {
         Ip::Address addrV6; // since we don't want to alter Config.Addrs.udp_* and dont have one of our own.
 
@@ -1600,11 +1637,11 @@ dnsInit(void)
     }
 #endif
 
-    idnsRegisterWithCacheManager();
+    Mgr::RegisterAction("idns", "Internal DNS Statistics", idnsStats, 0, 1);
 }
 
 void
-dnsShutdown(void)
+Dns::Shutdown(void)
 {
     if (DnsSocketA < 0 && DnsSocketB < 0)
         return;
@@ -1634,24 +1671,18 @@ dnsShutdown(void)
 static int
 idnsCachedLookup(const char *key, IDNSCB * callback, void *data)
 {
-    idns_query *q;
-
     idns_query *old = (idns_query *) hash_lookup(idns_lookup_hash, key);
 
     if (!old)
         return 0;
 
-    q = cbdataAlloc(idns_query);
-    // idns_query is POD so no constructors are called after allocation
-    q->xact_id.change();
+    idns_query *q = new idns_query;
     // no query_id on this instance.
 
     q->callback = callback;
-
     q->callback_data = cbdataReference(data);
 
     q->queue = old->queue;
-
     old->queue = q;
 
     return 1;
@@ -1673,21 +1704,23 @@ idnsStartQuery(idns_query *q, IDNSCB * callback, void *data)
 static void
 idnsSendSlaveAAAAQuery(idns_query *master)
 {
-    idns_query *q = cbdataAlloc(idns_query);
+    idns_query *q = new idns_query;
     memcpy(q->name, master->name, sizeof(q->name));
     memcpy(q->orig, master->orig, sizeof(q->orig));
     q->master = master;
     q->query_id = idnsQueryID();
     q->sz = rfc3596BuildAAAAQuery(q->name, q->buf, sizeof(q->buf), q->query_id, &q->query, Config.dns.packet_max);
-    q->start_t = master->start_t;
-    q->slave = master->slave;
 
     debugs(78, 3, HERE << "buf is " << q->sz << " bytes for " << q->name <<
            ", id = 0x" << std::hex << q->query_id);
     if (!q->sz) {
-        cbdataFree(q);
+        delete q;
         return;
     }
+
+    q->start_t = master->start_t;
+    q->slave = master->slave;
+
     idnsCheckMDNS(q);
     master->slave = q;
     idnsSendQuery(q);
@@ -1708,9 +1741,7 @@ idnsALookup(const char *name, IDNSCB * callback, void *data)
     if (idnsCachedLookup(name, callback, data))
         return;
 
-    idns_query *q = cbdataAlloc(idns_query);
-    // idns_query is POD so no constructors are called after allocation
-    q->xact_id.change();
+    idns_query *q = new idns_query;
     q->query_id = idnsQueryID();
 
     int nd = 0;
@@ -1740,7 +1771,7 @@ idnsALookup(const char *name, IDNSCB * callback, void *data)
     if (q->sz < 0) {
         /* problem with query data -- query not sent */
         callback(data, NULL, 0, "Internal error");
-        cbdataFree(q);
+        delete q;
         return;
     }
 
@@ -1752,22 +1783,16 @@ idnsALookup(const char *name, IDNSCB * callback, void *data)
 
     if (Ip::EnableIpv6)
         idnsSendSlaveAAAAQuery(q);
-
 }
 
 void
 idnsPTRLookup(const Ip::Address &addr, IDNSCB * callback, void *data)
 {
-    idns_query *q;
-
     char ip[MAX_IPSTRLEN];
 
     addr.toStr(ip,MAX_IPSTRLEN);
 
-    q = cbdataAlloc(idns_query);
-
-    // idns_query is POD so no constructors are called after allocation
-    q->xact_id.change();
+    idns_query *q = new idns_query;
     q->query_id = idnsQueryID();
 
     if (addr.isIPv6()) {
@@ -1784,12 +1809,12 @@ idnsPTRLookup(const Ip::Address &addr, IDNSCB * callback, void *data)
     if (q->sz < 0) {
         /* problem with query data -- query not sent */
         callback(data, NULL, 0, "Internal error");
-        cbdataFree(q);
+        delete q;
         return;
     }
 
     if (idnsCachedLookup(q->query.name, callback, data)) {
-        cbdataFree(q);
+        delete q;
         return;
     }
 
@@ -14,11 +14,7 @@
 #include "esi/Element.h"
 #include "esi/Sequence.h"
 
-/* esiAttempt */
-
 struct esiAttempt : public esiSequence {
-    //    void *operator new (size_t byteCount);
-    //    void operator delete (void *address);
     esiAttempt(esiTreeParentPtr aParent) : esiSequence (aParent) {}
 };
 
@@ -29,6 +29,7 @@
 #include "esi/Expression.h"
 #include "esi/Segment.h"
 #include "esi/VarState.h"
+#include "fatal.h"
 #include "HttpHdrSc.h"
 #include "HttpHdrScTarget.h"
 #include "HttpReply.h"
@@ -104,23 +105,19 @@ class esiComment : public ESIElement
 
 class esiRemove : public ESIElement
 {
+    MEMPROXY_CLASS(esiRemove);
 
 public:
-    void *operator new (size_t byteCount);
-    void operator delete (void *address);
-
-    esiRemove();
-    void render(ESISegment::Pointer);
-    bool addElement (ESIElement::Pointer);
-    Pointer makeCacheable() const;
-    Pointer makeUsable(esiTreeParentPtr, ESIVarState &) const;
-    void finish();
+    esiRemove() : ESIElement() {}
+    virtual ~esiRemove() {}
+
+    virtual void render(ESISegment::Pointer);
+    virtual bool addElement (ESIElement::Pointer);
+    virtual Pointer makeCacheable() const;
+    virtual Pointer makeUsable(esiTreeParentPtr, ESIVarState &) const;
+    virtual void finish() {}
 };
 
-CBDATA_TYPE (esiRemove);
-static FREE esiRemoveFree;
-static ESIElement * esiRemoveNew(void);
-
 class esiTry : public ESIElement
 {
     MEMPROXY_CLASS(esiTry);
@@ -213,8 +210,6 @@ class esiWhen : public esiSequence
 };
 
 struct esiOtherwise : public esiSequence {
-    //    void *operator new (size_t byteCount);
-    //    void operator delete (void *address);
     esiOtherwise(esiTreeParentPtr aParent) : esiSequence (aParent) {}
 };
 
@@ -1021,7 +1016,7 @@ ESIContext::start(const char *el, const char **attr, size_t attrCount)
 
     case ESIElement::ESI_ELEMENT_REMOVE:
         /* Put on the stack to allow skipping of 'invalid' markup */
-        element = esiRemoveNew ();
+        element = new esiRemove();
         break;
 
     case ESIElement::ESI_ELEMENT_TRY:
@@ -1584,42 +1579,6 @@ esiLiteral::makeUsable(esiTreeParentPtr , ESIVarState &newVarState) const
 }
 
 /* esiRemove */
-void
-esiRemoveFree (void *data)
-{
-    esiRemove *thisNode = (esiRemove *)data;
-    debugs(86, 5, "esiRemoveFree " << thisNode);
-}
-
-void *
-esiRemove::operator new(size_t byteCount)
-{
-    assert (byteCount == sizeof (esiRemove));
-    void *rv;
-    CBDATA_INIT_TYPE_FREECB(esiRemove, esiRemoveFree);
-    rv = (void *)cbdataAlloc (esiRemove);
-    return rv;
-}
-
-void
-esiRemove::operator delete (void *address)
-{
-    cbdataFree (address);
-}
-
-ESIElement *
-esiRemoveNew ()
-{
-    return new esiRemove;
-}
-
-esiRemove::esiRemove()
-{}
-
-void
-esiRemove::finish()
-{}
-
 void
 esiRemove::render(ESISegment::Pointer output)
 {
@@ -1916,63 +1875,6 @@ esiTry::finish()
     except = NULL;
 }
 
-/* esiAttempt */
-#if 0
-void *
-esiAttempt::operator new(size_t byteCount)
-{
-    assert (byteCount == sizeof (esiAttempt));
-
-}
-
-void
-esiAttempt::operator delete (void *address)
-{
-    cbdataFree (address);
-}
-
-#endif
-
-/* esiExcept */
-#if 0
-void *
-esiExcept::operator new(size_t byteCount)
-{
-    assert (byteCount == sizeof (esiExcept));
-    void *rv;
-    CBDATA_INIT_TYPE_FREECB(esiExcept, esiSequence::Free);
-    rv = (void *)cbdataAlloc (esiExcept);
-    return rv;
-}
-
-void
-esiExcept::operator delete (void *address)
-{
-    cbdataFree (address);
-}
-
-#endif
-
-/* ESIVar */
-#if 0
-void *
-esiVar::operator new(size_t byteCount)
-{
-    assert (byteCount == sizeof (esiVar));
-    void *rv;
-    CBDATA_INIT_TYPE_FREECB(esiVar, esiSequence::Free);
-    rv = (void *)cbdataAlloc (esiVar);
-    return rv;
-}
-
-void
-esiVar::operator delete (void *address)
-{
-    cbdataFree (address);
-}
-
-#endif
-
 /* esiChoose */
 esiChoose::~esiChoose()
 {
@@ -2369,26 +2271,6 @@ esiWhen::makeUsable(esiTreeParentPtr newParent, ESIVarState &newVarState) const
     return result;
 }
 
-/* esiOtherwise */
-#if 0
-void *
-esiOtherwise::operator new(size_t byteCount)
-{
-    assert (byteCount == sizeof (esiOtherwise));
-    void *rv;
-    CBDATA_INIT_TYPE_FREECB(esiOtherwise, esiSequence::Free);
-    rv = (void *)cbdataAlloc (esiOtherwise);
-    return rv;
-}
-
-void
-esiOtherwise::operator delete (void *address)
-{
-    cbdataFree (address);
-}
-
-#endif
-
 /* TODO: implement surrogate targeting and control processing */
 int
 esiEnableProcessing (HttpReply *rep)
@@ -20,8 +20,6 @@ class esiExcept : public esiSequence
 {
 
 public:
-    //    void *operator new (size_t byteCount);
-    //    void operator delete (void *address);
     esiExcept(esiTreeParentPtr aParent) : esiSequence (aParent) {}
 };
 
@@ -10,15 +10,13 @@
 
 #include "squid.h"
 
-/* MS Visual Studio Projects are monolithic, so we need the following
- * #if to exclude the ESI code from compile process when not needed.
- */
-#if (USE_SQUID_ESI == 1)
+#if USE_SQUID_ESI
 
 #include "client_side.h"
 #include "client_side_request.h"
 #include "esi/Include.h"
 #include "esi/VarState.h"
+#include "fatal.h"
 #include "HttpReply.h"
 #include "log/access_log.h"
 
@@ -559,5 +557,5 @@ ESIInclude::subRequestDone (ESIStreamContext::Pointer stream, bool success)
     }
 }
 
-#endif /* USE_SQUID_ESI == 1 */
+#endif /* USE_SQUID_ESI */
 
@@ -13,9 +13,8 @@
 #include "esi/Segment.h"
 #include "SquidString.h"
 
-CBDATA_TYPE(ESISegment);
+CBDATA_CLASS_INIT(ESISegment);
 
-/* ESISegment */
 void
 ESISegmentFreeList (ESISegment::Pointer &head)
 {
@@ -126,22 +125,6 @@ ESISegment::ListAppend (ESISegment::Pointer &head, char const *s, size_t len)
     head->tail()->listAppend (s, len);
 }
 
-void *
-ESISegment::operator new(size_t byteCount)
-{
-    assert (byteCount == sizeof (ESISegment));
-    void *rv;
-    CBDATA_INIT_TYPE(ESISegment);
-    rv = (void *)cbdataAlloc (ESISegment);
-    return rv;
-}
-
-void
-ESISegment::operator delete (void *address)
-{
-    cbdataFree (address);
-}
-
 /* XXX: if needed, make this iterative */
 ESISegment::Pointer
 ESISegment::cloneList () const
@@ -188,9 +171,6 @@ ESISegment::tail()
     return result.getRaw();
 }
 
-ESISegment::ESISegment() : len(0), next(NULL)
-{}
-
 ESISegment::ESISegment(ESISegment const &old) : len (0), next(NULL)
 {
     append (old.buf, old.len);
@@ -20,16 +20,17 @@
 
 class ESISegment : public RefCountable
 {
+    CBDATA_CLASS(ESISegment);
 
 public:
     typedef RefCount<ESISegment> Pointer;
     static void ListAppend (Pointer &, char const *, size_t);
     static void ListTransfer (Pointer &from, Pointer &to);
-    void *operator new (size_t byteCount);
-    void operator delete (void *address);
 
-    ESISegment();
+    ESISegment() : len(0), next(NULL) {*buf = 0;}
     ESISegment(ESISegment const &);
+    ~ESISegment() {}
+
     ESISegment::Pointer cloneList() const;
     char *listToChar() const;
     void listAppend (char const *s, size_t length);
@@ -20,8 +20,6 @@ class ESIVar:public esiSequence
 {
 
 public:
-    //    void *operator new (size_t byteCount);
-    //    void operator delete (void *address);
     ESIVar(esiTreeParentPtr aParent) : esiSequence (aParent) {
         flags.dovars = 1;
     }
@@ -13,9 +13,6 @@
 #include "fatal.h"
 #include "HttpReply.h"
 
-CBDATA_TYPE (ESIVarState);
-FREE ESIVarStateFree;
-
 char const *ESIVariableUserAgent::esiUserOs[]= {
     "WIN",
     "MAC",
@@ -28,6 +25,8 @@ char const * esiBrowsers[]= {"MSIE",
                              "OTHER"
                             };
 
+CBDATA_CLASS_INIT(ESIVarState);
+
 void
 ESIVarState::Variable::eval (ESIVarState &state, char const *subref, char const *found_default) const
 {
@@ -131,17 +130,12 @@ ESIVarState::extractChar ()
     return rv;
 }
 
-/* ESIVarState */
-void
-esiVarStateFree (void *data)
-{
-    ESIVarState *thisNode = (ESIVarState*)data;
-    thisNode->freeResources();
-}
-
 ESIVarState::~ESIVarState()
 {
-    freeResources();
+    // freeResources
+    input = NULL;
+    ESISegmentFreeList(output);
+    hdr.clean();
 
     while (!variablesForCleanup.empty()) {
         delete variablesForCleanup.back();
@@ -151,30 +145,6 @@ ESIVarState::~ESIVarState()
     delete defaultVariable;
 }
 
-void
-ESIVarState::freeResources()
-{
-    input = NULL;
-    ESISegmentFreeList (output);
-    hdr.clean();
-}
-
-void *
-ESIVarState::operator new(size_t byteCount)
-{
-    assert (byteCount == sizeof (ESIVarState));
-    void *rv;
-    CBDATA_INIT_TYPE_FREECB(ESIVarState, esiVarStateFree);
-    rv = (void *)cbdataAlloc (ESIVarState);
-    return rv;
-}
-
-void
-ESIVarState::operator delete (void *address)
-{
-    cbdataFree (address);
-}
-
 char *
 ESIVariableUserAgent::getProductVersion (char const *s)
 {
@@ -33,8 +33,12 @@ struct _query_elem {char *var, *val;};
 
 class ESIVarState
 {
+    CBDATA_CLASS(ESIVarState);
 
 public:
+    ESIVarState(HttpHeader const *hdr, char const *uri);
+    ~ESIVarState();
+
     ESISegment::Pointer extractList();
     char *extractChar();
     void feedData (const char *buf, size_t len);
@@ -44,12 +48,6 @@ class ESIVarState
     void addVariable (char const *, size_t, Variable *);
     void removeVariable (String const &);
 
-    void *operator new (size_t byteCount);
-    void operator delete (void *address);
-    void freeResources();
-    ESIVarState (HttpHeader const *hdr, char const *uri);
-    ~ESIVarState();
-
     /* For Variables */
     void cookieUsed();
     void hostUsed();
@@ -89,8 +89,15 @@ class external_acl_format : public RefCountable
 
 class external_acl
 {
+    /* FIXME: These are not really cbdata, but it is an easy way
+     * to get them pooled, refcounted, accounted and freed properly...
+     */
+    CBDATA_CLASS(external_acl);
 
 public:
+    external_acl();
+    ~external_acl();
+
     external_acl *next;
 
     void add(const ExternalACLEntryPointer &);
@@ -141,33 +148,52 @@ class external_acl
     Ip::Address local_addr;
 };
 
-/* FIXME: These are not really cbdata, but it is an easy way
- * to get them pooled, refcounted, accounted and freed properly...
- */
-CBDATA_TYPE(external_acl);
-
-static void
-free_external_acl(void *data)
+CBDATA_CLASS_INIT(external_acl);
+
+external_acl::external_acl() :
+    ttl(DEFAULT_EXTERNAL_ACL_TTL),
+    negative_ttl(-1),
+    grace(1),
+    name(NULL),
+    cmdline(NULL),
+    children(DEFAULT_EXTERNAL_ACL_CHILDREN),
+    theHelper(NULL),
+    cache(NULL),
+    cache_size(256*1024),
+    cache_entries(0),
+#if USE_AUTH
+    require_auth(0),
+#endif
+    quote(external_acl::QUOTE_METHOD_URL)
 {
-    external_acl *p = static_cast<external_acl *>(data);
-    safe_free(p->name);
-
-    p->format = NULL;
-
-    wordlistDestroy(&p->cmdline);
+    local_addr.setLocalhost();
+}
 
-    if (p->theHelper) {
-        helperShutdown(p->theHelper);
-        delete p->theHelper;
-        p->theHelper = NULL;
+external_acl::~external_acl()
+{
+    xfree(name);
+    format = NULL;
+    wordlistDestroy(&cmdline);
+
+    if (theHelper) {
+        helperShutdown(theHelper);
+        delete theHelper;
+        theHelper = NULL;
     }
 
-    while (p->lru_list.tail) {
-        ExternalACLEntryPointer e(static_cast<ExternalACLEntry *>(p->lru_list.tail->data));
-        external_acl_cache_delete(p, e);
+    while (lru_list.tail) {
+        ExternalACLEntryPointer e(static_cast<ExternalACLEntry *>(lru_list.tail->data));
+        external_acl_cache_delete(this, e);
+    }
+    if (cache)
+        hashFreeMemory(cache);
+
+    while (next) {
+        external_acl *node = next;
+        next = node->next;
+        node->next = NULL; // prevent recursion
+        delete node;
     }
-    if (p->cache)
-        hashFreeMemory(p->cache);
 }
 
 /**
@@ -223,24 +249,8 @@ parse_header_token(external_acl_format::Pointer format, char *header, const Form
 void
 parse_externalAclHelper(external_acl ** list)
 {
-    external_acl *a;
-    char *token;
-
-    CBDATA_INIT_TYPE_FREECB(external_acl, free_external_acl);
-
-    a = cbdataAlloc(external_acl);
-
-    /* set defaults */
-    a->ttl = DEFAULT_EXTERNAL_ACL_TTL;
-    a->negative_ttl = -1;
-    a->cache_size = 256*1024;
-    a->children.n_max = DEFAULT_EXTERNAL_ACL_CHILDREN;
-    a->children.n_startup = a->children.n_max;
-    a->children.n_idle = 1;
-    a->local_addr.setLocalhost();
-    a->quote = external_acl::QUOTE_METHOD_URL;
-
-    token = ConfigParser::NextToken();
+    external_acl *a = new external_acl;
+    char *token = ConfigParser::NextToken();
 
     if (!token)
         self_destruct();
@@ -565,12 +575,8 @@ dump_externalAclHelper(StoreEntry * sentry, const char *name, const external_acl
 void
 free_externalAclHelper(external_acl ** list)
 {
-    while (*list) {
-        external_acl *node = *list;
-        *list = node->next;
-        node->next = NULL;
-        cbdataFree(node);
-    }
+    delete *list;
+    *list = NULL;
 }
 
 static external_acl *
@@ -613,40 +619,40 @@ external_acl::trimCache()
  * external acl type
  */
 
-struct _external_acl_data {
+class external_acl_data
+{
+    CBDATA_CLASS(external_acl_data);
+
+public:
+    explicit external_acl_data(external_acl *aDef) : def(cbdataReference(aDef)), name(NULL), arguments(NULL) {}
+    ~external_acl_data();
+
     external_acl *def;
     const char *name;
     wordlist *arguments;
 };
 
-CBDATA_TYPE(external_acl_data);
-static void
-free_external_acl_data(void *data)
+CBDATA_CLASS_INIT(external_acl_data);
+
+external_acl_data::~external_acl_data()
 {
-    external_acl_data *p = static_cast<external_acl_data *>(data);
-    safe_free(p->name);
-    wordlistDestroy(&p->arguments);
-    cbdataReferenceDone(p->def);
+    xfree(name);
+    wordlistDestroy(&arguments);
+    cbdataReferenceDone(def);
 }
 
 void
 ACLExternal::parse()
 {
-    char *token;
-
     if (data)
         self_destruct();
 
-    CBDATA_INIT_TYPE_FREECB(external_acl_data, free_external_acl_data);
-
-    data = cbdataAlloc(external_acl_data);
-
-    token = strtokFile();
+    char *token = ConfigParser::strtokFile();
 
     if (!token)
         self_destruct();
 
-    data->def = cbdataReference(find_externalAclHelper(token));
+    data = new external_acl_data(find_externalAclHelper(token));
 
     if (!data->def)
         self_destruct();
@@ -655,7 +661,7 @@ ACLExternal::parse()
     // this is the name of the 'acl' directive being tested
     data->name = xstrdup(AclMatchedName);
 
-    while ((token = strtokFile())) {
+    while ((token = ConfigParser::strtokFile())) {
         wordlistAdd(&data->arguments, token);
     }
 }
@@ -688,8 +694,8 @@ ACLExternal::empty () const
 
 ACLExternal::~ACLExternal()
 {
-    cbdataFree(data);
-    safe_free (class_);
+    delete data;
+    xfree(class_);
 }
 
 static void
@@ -1252,9 +1258,20 @@ external_acl_cache_delete(external_acl * def, const ExternalACLEntryPointer &ent
  * external_acl helpers
  */
 
-typedef struct _externalAclState externalAclState;
+class externalAclState
+{
+    CBDATA_CLASS(externalAclState);
+
+public:
+    externalAclState(external_acl* aDef, const char *aKey) :
+        callback(NULL),
+        callback_data(NULL),
+        key(xstrdup(aKey)),
+        def(cbdataReference(aDef)),
+        queue(NULL)
+    {}
+    ~externalAclState();
 
-struct _externalAclState {
     EAH *callback;
     void *callback_data;
     char *key;
@@ -1263,14 +1280,13 @@ struct _externalAclState {
     externalAclState *queue;
 };
 
-CBDATA_TYPE(externalAclState);
-static void
-free_externalAclState(void *data)
+CBDATA_CLASS_INIT(externalAclState);
+
+externalAclState::~externalAclState()
 {
-    externalAclState *state = static_cast<externalAclState *>(data);
-    safe_free(state->key);
-    cbdataReferenceDone(state->callback_data);
-    cbdataReferenceDone(state->def);
+    xfree(key);
+    cbdataReferenceDone(callback_data);
+    cbdataReferenceDone(def);
 }
 
 /*
@@ -1352,14 +1368,13 @@ externalAclHandleReply(void *data, const Helper::Reply &reply)
 
     do {
         void *cbdata;
-        cbdataReferenceDone(state->def);
-
         if (state->callback && cbdataReferenceValidDone(state->callback_data, &cbdata))
             state->callback(cbdata, entry);
 
         next = state->queue;
+        state->queue = NULL;
 
-        cbdataFree(state);
+        delete state;
 
         state = next;
     } while (state);
@@ -1404,10 +1419,7 @@ ExternalACLLookup::Start(ACLChecklist *checklist, external_acl_data *acl, bool i
         return;
     }
 
-    externalAclState *state = cbdataAlloc(externalAclState);
-    state->def = cbdataReference(def);
-
-    state->key = xstrdup(key);
+    externalAclState *state = new externalAclState(def, key);
 
     if (!inBackground) {
         state->callback = &ExternalACLLookup::LookupDone;
@@ -1431,7 +1443,7 @@ ExternalACLLookup::Start(ACLChecklist *checklist, external_acl_data *acl, bool i
         if (!def->theHelper->trySubmit(buf.buf, externalAclHandleReply, state)) {
             debugs(82, 7, HERE << "'" << def->name << "' submit to helper failed");
             assert(inBackground); // or the caller should have checked
-            cbdataFree(state);
+            delete state;
             return;
         }
 
@@ -1447,9 +1459,7 @@ ExternalACLLookup::Start(ACLChecklist *checklist, external_acl_data *acl, bool i
 static void
 externalAclStats(StoreEntry * sentry)
 {
-    external_acl *p;
-
-    for (p = Config.externalAclHelperList; p; p = p->next) {
+    for (external_acl *p = Config.externalAclHelperList; p; p = p->next) {
         storeAppendPrintf(sentry, "External ACL Statistics: %s\n", p->name);
         storeAppendPrintf(sentry, "Cache size: %d\n", p->cache->count);
         helperStats(sentry, p->theHelper);
@@ -1468,10 +1478,7 @@ externalAclRegisterWithCacheManager(void)
 void
 externalAclInit(void)
 {
-    static int firstTimeInit = 1;
-    external_acl *p;
-
-    for (p = Config.externalAclHelperList; p; p = p->next) {
+    for (external_acl *p = Config.externalAclHelperList; p; p = p->next) {
         if (!p->cache)
             p->cache = hash_create((HASHCMP *) strcmp, hashPrime(1024), hash4);
 
@@ -1489,11 +1496,6 @@ externalAclInit(void)
         helperOpenServers(p->theHelper);
     }
 
-    if (firstTimeInit) {
-        firstTimeInit = 0;
-        CBDATA_INIT_TYPE_FREECB(externalAclState, free_externalAclState);
-    }
-
     externalAclRegisterWithCacheManager();
 }
 
@@ -10,12 +10,13 @@
 
 #include "squid.h"
 #include "cbdata.h"
-#include "DnsLookupDetails.h"
+#include "dns/forward.h"
+#include "dns/LookupDetails.h"
+#include "dns/rfc1035.h"
 #include "event.h"
 #include "helper.h"
 #include "mgr/Registration.h"
 #include "SquidConfig.h"
-#include "SquidDns.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
 #include "Store.h"
@@ -310,7 +311,7 @@ fqdncacheCallback(fqdncache_entry * f, int wait)
     f->handler = NULL;
 
     if (cbdataReferenceValidDone(f->handlerData, &cbdata)) {
-        const DnsLookupDetails details(f->error_message, wait);
+        const Dns::LookupDetails details(f->error_message, wait);
         callback(f->name_count ? f->names[0] : NULL, details, cbdata);
     }
 
@@ -427,7 +428,7 @@ fqdncache_nbgethostbyaddr(const Ip::Address &addr, FQDNH * handler, void *handle
 
     if (name[0] == '\0') {
         debugs(35, 4, "fqdncache_nbgethostbyaddr: Invalid name!");
-        const DnsLookupDetails details("Invalid hostname", -1); // error, no lookup
+        const Dns::LookupDetails details("Invalid hostname", -1); // error, no lookup
         if (handler)
             handler(NULL, details, handlerData);
         return;
@@ -80,7 +80,8 @@ nodist_pinger_SOURCES = \
 pinger_LDFLAGS = $(LIBADD_DL)
 pinger_LDADD=\
 	libicmp-core.la \
-	../ip/libip.la \
+	$(top_builddir)/src/ip/libip.la \
+	$(top_builddir)/src/base/libbase.la \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 
@@ -58,7 +58,37 @@ typedef enum {
     STATE_BODY
 } netdb_conn_state_t;
 
-typedef struct {
+class netdbExchangeState
+{
+    CBDATA_CLASS(netdbExchangeState);
+
+public:
+    netdbExchangeState(CachePeer *aPeer, HttpRequest *theReq) :
+        p(cbdataReference(aPeer)),
+        e(NULL),
+        sc(NULL),
+        r(theReq),
+        used(0),
+        buf_sz(NETDB_REQBUF_SZ),
+        buf_ofs(0),
+        connstate(STATE_HEADER)
+    {
+        *buf = 0;
+
+        assert(NULL != r);
+        HTTPMSGLOCK(r);
+        // TODO: check if we actually need to do this. should be implicit
+        r->http_ver = Http::ProtocolVersion();
+    }
+
+    ~netdbExchangeState() {
+        debugs(38, 3, e->url());
+        storeUnregister(sc, e, this);
+        e->unlock("netdbExchangeDone");
+        HTTPMSGUNLOCK(r);
+        cbdataReferenceDone(p);
+    }
+
     CachePeer *p;
     StoreEntry *e;
     store_client *sc;
@@ -68,7 +98,9 @@ typedef struct {
     char buf[NETDB_REQBUF_SZ];
     int buf_ofs;
     netdb_conn_state_t connstate;
-} netdbExchangeState;
+};
+
+CBDATA_CLASS_INIT(netdbExchangeState);
 
 static hash_table *addr_table = NULL;
 static hash_table *host_table = NULL;
@@ -92,7 +124,6 @@ static QS netdbLRU;
 static FREE netdbFreeNameEntry;
 static FREE netdbFreeNetdbEntry;
 static STCB netdbExchangeHandleReply;
-static void netdbExchangeDone(void *);
 
 /* We have to keep a local list of CachePeer names.  The Peers structure
  * gets freed during a reconfigure.  We want this database to
@@ -264,7 +295,7 @@ netdbAdd(Ip::Address &addr)
 }
 
 static void
-netdbSendPing(const ipcache_addrs *ia, const DnsLookupDetails &, void *data)
+netdbSendPing(const ipcache_addrs *ia, const Dns::LookupDetails &, void *data)
 {
     Ip::Address addr;
     char *hostname = NULL;
@@ -689,16 +720,15 @@ netdbExchangeHandleReply(void *data, StoreIOBuffer receivedData)
 
     if (!cbdataReferenceValid(ex->p)) {
         debugs(38, 3, "netdbExchangeHandleReply: Peer became invalid");
-        netdbExchangeDone(ex);
+        delete ex;
         return;
     }
 
     debugs(38, 3, "netdbExchangeHandleReply: for '" << ex->p->host << ":" << ex->p->http_port << "'");
 
-    if (receivedData.length == 0 &&
-            !receivedData.flags.error) {
+    if (receivedData.length == 0 && !receivedData.flags.error) {
         debugs(38, 3, "netdbExchangeHandleReply: Done");
-        netdbExchangeDone(ex);
+        delete ex;
         return;
     }
 
@@ -723,7 +753,7 @@ netdbExchangeHandleReply(void *data, StoreIOBuffer receivedData)
             debugs(38, 3, "netdbExchangeHandleReply: reply status " << rep->sline.status());
 
             if (rep->sline.status() != Http::scOkay) {
-                netdbExchangeDone(ex);
+                delete ex;
                 return;
             }
 
@@ -789,7 +819,7 @@ netdbExchangeHandleReply(void *data, StoreIOBuffer receivedData)
 
             default:
                 debugs(38, DBG_IMPORTANT, "netdbExchangeHandleReply: corrupt data, aborting");
-                netdbExchangeDone(ex);
+                delete ex;
                 return;
             }
         }
@@ -845,7 +875,7 @@ netdbExchangeHandleReply(void *data, StoreIOBuffer receivedData)
 
     if (EBIT_TEST(ex->e->flags, ENTRY_ABORTED)) {
         debugs(38, 3, "netdbExchangeHandleReply: ENTRY_ABORTED");
-        netdbExchangeDone(ex);
+        delete ex;
     } else if (ex->e->store_status == STORE_PENDING) {
         StoreIOBuffer tempBuffer;
         tempBuffer.offset = ex->used;
@@ -857,18 +887,6 @@ netdbExchangeHandleReply(void *data, StoreIOBuffer receivedData)
     }
 }
 
-static void
-netdbExchangeDone(void *data)
-{
-    netdbExchangeState *ex = (netdbExchangeState *)data;
-    debugs(38, 3, "netdbExchangeDone: " << ex->e->url()  );
-    HTTPMSGUNLOCK(ex->r);
-    storeUnregister(ex->sc, ex->e, ex);
-    ex->e->unlock("netdbExchangeDone");
-    cbdataReferenceDone(ex->p);
-    cbdataFree(ex);
-}
-
 static void
 netdbRegisterWithCacheManager(void)
 {
@@ -1266,42 +1284,31 @@ netdbBinaryExchange(StoreEntry * s)
     s->complete();
 }
 
-#if USE_ICMP
-CBDATA_TYPE(netdbExchangeState);
-#endif
-
 void
 netdbExchangeStart(void *data)
 {
 #if USE_ICMP
     CachePeer *p = (CachePeer *)data;
-    char *uri;
-    netdbExchangeState *ex;
-    StoreIOBuffer tempBuffer;
-    CBDATA_INIT_TYPE(netdbExchangeState);
-    ex = cbdataAlloc(netdbExchangeState);
-    ex->p = cbdataReference(p);
-    uri = internalRemoteUri(p->host, p->http_port, "/squid-internal-dynamic/", "netdb");
+    char *uri = internalRemoteUri(p->host, p->http_port, "/squid-internal-dynamic/", "netdb");
     debugs(38, 3, "netdbExchangeStart: Requesting '" << uri << "'");
     assert(NULL != uri);
-    ex->r = HttpRequest::CreateFromUrl(uri);
+    HttpRequest *req = HttpRequest::CreateFromUrl(uri);
 
-    if (NULL == ex->r) {
+    if (req == NULL) {
         debugs(38, DBG_IMPORTANT, "netdbExchangeStart: Bad URI " << uri);
         return;
     }
 
-    HTTPMSGLOCK(ex->r);
-    assert(NULL != ex->r);
-    ex->r->http_ver = Http::ProtocolVersion();
-    ex->connstate = STATE_HEADER;
+    netdbExchangeState *ex = new netdbExchangeState(p, req);
     ex->e = storeCreateEntry(uri, uri, RequestFlags(), Http::METHOD_GET);
-    ex->buf_sz = NETDB_REQBUF_SZ;
     assert(NULL != ex->e);
-    ex->sc = storeClientListAdd(ex->e, ex);
-    tempBuffer.offset = 0;
+
+    StoreIOBuffer tempBuffer;
     tempBuffer.length = ex->buf_sz;
     tempBuffer.data = ex->buf;
+
+    ex->sc = storeClientListAdd(ex->e, ex);
+
     storeClientCopy(ex->sc, ex->e, tempBuffer,
                     netdbExchangeHandleReply, ex);
     ex->r->flags.loopDetected = true;   /* cheat! -- force direct */
@@ -22,6 +22,22 @@
 
 #include <cerrno>
 
+CBDATA_CLASS_INIT(acl_tos);
+
+acl_tos::~acl_tos()
+{
+    aclDestroyAclList(&aclList);
+    delete next;
+}
+
+CBDATA_CLASS_INIT(acl_nfmark);
+
+acl_nfmark::~acl_nfmark()
+{
+    aclDestroyAclList(&aclList);
+    delete next;
+}
+
 void
 Ip::Qos::getTosFromServer(const Comm::ConnectionPointer &server, fde *clientFde)
 {
@@ -24,21 +24,28 @@
 class fde;
 
 // TODO: move to new ACL framework
-// not integrated in namespace, as this class uses a strange CBDATA definition
-// POD
 class acl_tos
 {
+    CBDATA_CLASS(acl_tos);
+
 public:
+    acl_tos() : next(NULL), aclList(NULL) {}
+    ~acl_tos();
+
     acl_tos *next;
     ACLList *aclList;
     tos_t tos;
 };
+
 // TODO: move to new ACL framework
-// not integrated in namespace, as this class uses a strange CBDATA definition
-// POD
 class acl_nfmark
 {
+    CBDATA_CLASS(acl_nfmark);
+
 public:
+    acl_nfmark() : next(NULL), aclList(NULL) {}
+    ~acl_nfmark();
+
     acl_nfmark *next;
     ACLList *aclList;
     nfmark_t nfmark;
@@ -12,15 +12,14 @@
 #include "CacheManager.h"
 #include "cbdata.h"
 #include "dlink.h"
-#include "DnsLookupDetails.h"
+#include "dns/LookupDetails.h"
+#include "dns/rfc3596.h"
 #include "event.h"
 #include "ip/Address.h"
 #include "ip/tools.h"
 #include "ipcache.h"
 #include "mgr/Registration.h"
-#include "rfc3596.h"
 #include "SquidConfig.h"
-#include "SquidDns.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
 #include "Store.h"
@@ -321,7 +320,7 @@ ipcacheCallback(ipcache_entry *i, int wait)
     i->handler = NULL;
 
     if (cbdataReferenceValidDone(i->handlerData, &cbdata)) {
-        const DnsLookupDetails details(i->error_message, wait);
+        const Dns::LookupDetails details(i->error_message, wait);
         callback((i->addrs.count ? &i->addrs : NULL), details, cbdata);
     }
 
@@ -504,7 +503,7 @@ ipcache_nbgethostbyname(const char *name, IPH * handler, void *handlerData)
     if (name == NULL || name[0] == '\0') {
         debugs(14, 4, "ipcache_nbgethostbyname: Invalid name!");
         ++IpcacheStats.invalid;
-        const DnsLookupDetails details("Invalid hostname", -1); // error, no lookup
+        const Dns::LookupDetails details("Invalid hostname", -1); // error, no lookup
         if (handler)
             handler(NULL, details, handlerData);
         return;
@@ -513,7 +512,7 @@ ipcache_nbgethostbyname(const char *name, IPH * handler, void *handlerData)
     if ((addrs = ipcacheCheckNumeric(name))) {
         debugs(14, 4, "ipcache_nbgethostbyname: BYPASS for '" << name << "' (already numeric)");
         ++IpcacheStats.numeric_hits;
-        const DnsLookupDetails details(NULL, -1); // no error, no lookup
+        const Dns::LookupDetails details; // no error, no lookup
         if (handler)
             handler(addrs, details, handlerData);
         return;
@@ -9,13 +9,13 @@
 #ifndef _SQUID_IPCACHE_H
 #define _SQUID_IPCACHE_H
 
+#include "dns/forward.h"
+
 namespace Ip
 {
 class Address;
 }
 
-class DnsLookupDetails;
-
 typedef struct _ipcache_addrs {
     Ip::Address *in_addrs;
     unsigned char *bad_mask;
@@ -24,7 +24,7 @@ typedef struct _ipcache_addrs {
     unsigned char badcount;
 } ipcache_addrs;
 
-typedef void IPH(const ipcache_addrs *, const DnsLookupDetails &details, void *);
+typedef void IPH(const ipcache_addrs *, const Dns::LookupDetails &details, void *);
 
 void ipcache_purgelru(void *);
 void ipcache_nbgethostbyname(const char *name, IPH * handler, void *handlerData);
@@ -18,7 +18,21 @@
 #include "log/ModUdp.h"
 #include "log/TcpLogger.h"
 
-CBDATA_TYPE(Logfile);
+CBDATA_CLASS_INIT(Logfile);
+
+Logfile::Logfile(const char *aPath) :
+    sequence_number(0),
+    data(NULL),
+    f_linestart(NULL),
+    f_linewrite(NULL),
+    f_lineend(NULL),
+    f_flush(NULL),
+    f_rotate(NULL),
+    f_close(NULL)
+{
+    xstrncpy(path, aPath, sizeof(path));
+    flags.fatal = 0;
+}
 
 Logfile *
 logfileOpen(const char *path, size_t bufsz, int fatal_flag)
@@ -27,10 +41,8 @@ logfileOpen(const char *path, size_t bufsz, int fatal_flag)
     const char *patharg;
 
     debugs(50, DBG_IMPORTANT, "Logfile: opening log " << path);
-    CBDATA_INIT_TYPE(Logfile);
 
-    Logfile *lf = cbdataAlloc(Logfile);
-    xstrncpy(lf->path, path, MAXPATHLEN);
+    Logfile *lf = new Logfile(path);
     patharg = path;
     /* need to call the per-logfile-type code */
     if (strncmp(path, "stdio:", 6) == 0) {
@@ -61,7 +73,7 @@ logfileOpen(const char *path, size_t bufsz, int fatal_flag)
         else
             debugs(50, DBG_IMPORTANT, "logfileOpen: " << path << ": couldn't open!");
         lf->f_close(lf);
-        cbdataFree(lf);
+        delete lf;
         return NULL;
     }
     assert(lf->data != NULL);
@@ -80,7 +92,7 @@ logfileClose(Logfile * lf)
     debugs(50, DBG_IMPORTANT, "Logfile: closing log " << lf->path);
     lf->f_flush(lf);
     lf->f_close(lf);
-    cbdataFree(lf);
+    delete lf;
 }
 
 void
@@ -9,6 +9,7 @@
 #ifndef SQUID_SRC_LOG_FILE_H
 #define SQUID_SRC_LOG_FILE_H
 
+#include "cbdata.h"
 #include "dlink.h"
 
 #if HAVE_SYS_PARAM_H
@@ -36,8 +37,12 @@ typedef void LOGCLOSE(Logfile *);
 
 class Logfile
 {
+    CBDATA_CLASS(Logfile);
 
 public:
+    explicit Logfile(const char *aPath);
+    ~Logfile() {}
+
     char path[MAXPATHLEN];
 
     struct {
@@ -25,6 +25,7 @@
 #include "CpuAffinity.h"
 #include "disk.h"
 #include "DiskIO/DiskIOModule.h"
+#include "dns/forward.h"
 #include "errorpage.h"
 #include "event.h"
 #include "EventLoop.h"
@@ -59,7 +60,6 @@
 #include "refresh.h"
 #include "send-announce.h"
 #include "SquidConfig.h"
-#include "SquidDns.h"
 #include "SquidTime.h"
 #include "stat.h"
 #include "StatCounters.h"
@@ -803,7 +803,7 @@ mainReconfigureStart(void)
 #if USE_HTCP
     htcpClosePorts();
 #endif
-    dnsShutdown();
+    Dns::Shutdown();
 #if USE_SSL_CRTD
     Ssl::Helper::GetInstance()->Shutdown();
 #endif
@@ -890,7 +890,7 @@ mainReconfigureFinish(void *)
     icapLogOpen();
 #endif
     storeLogOpen();
-    dnsInit();
+    Dns::Init();
 #if USE_SSL_CRTD
     Ssl::Helper::GetInstance()->Init();
 #endif
@@ -1094,7 +1094,7 @@ mainInitialize(void)
 
     parseEtcHosts();
 
-    dnsInit();
+    Dns::Init();
 
 #if USE_SSL_CRTD
     Ssl::Helper::GetInstance()->Init();
@@ -1915,7 +1915,7 @@ SquidShutdown()
 #endif
 
     debugs(1, DBG_IMPORTANT, "Shutting down...");
-    dnsShutdown();
+    Dns::Shutdown();
 #if USE_SSL_CRTD
     Ssl::Helper::GetInstance()->Shutdown();
 #endif
@@ -31,7 +31,7 @@ mcastSetTtl(int fd, int mcast_ttl)
 }
 
 void
-mcastJoinGroups(const ipcache_addrs *ia, const DnsLookupDetails &, void *)
+mcastJoinGroups(const ipcache_addrs *ia, const Dns::LookupDetails &, void *)
 {
 #ifdef IP_MULTICAST_TTL
     struct ip_mreq mr;
@@ -522,7 +522,8 @@ neighborRemove(CachePeer * target)
 
     if (p) {
         *P = p->next;
-        cbdataFree(p);
+        p->next = NULL;
+        delete p;
         --Config.npeers;
     }
 
@@ -945,7 +946,7 @@ neighborIgnoreNonPeer(const Ip::Address &from, icp_opcode opcode)
     }
 
     if (np == NULL) {
-        np = (CachePeer *)xcalloc(1, sizeof(CachePeer));
+        np = new CachePeer;
         np->in_addr = from;
         np->icp.port = from.port();
         np->type = PEER_NONE;
@@ -1169,31 +1170,6 @@ neighborUp(const CachePeer * p)
     return 1;
 }
 
-void
-peerDestroy(void *data)
-{
-    CachePeer *p = (CachePeer *)data;
-
-    if (p == NULL)
-        return;
-
-    CachePeerDomainList *nl = NULL;
-
-    for (CachePeerDomainList *l = p->peer_domain; l; l = nl) {
-        nl = l->next;
-        safe_free(l->domain);
-        xfree(l);
-    }
-
-    safe_free(p->host);
-    safe_free(p->name);
-    safe_free(p->domain);
-#if USE_CACHE_DIGESTS
-
-    cbdataReferenceDone(p->digest);
-#endif
-}
-
 void
 peerNoteDigestGone(CachePeer * p)
 {
@@ -1203,7 +1179,7 @@ peerNoteDigestGone(CachePeer * p)
 }
 
 static void
-peerDNSConfigure(const ipcache_addrs *ia, const DnsLookupDetails &, void *data)
+peerDNSConfigure(const ipcache_addrs *ia, const Dns::LookupDetails &, void *data)
 {
     // TODO: connections to no-longer valid IP addresses should be
     // closed when we can detect such IP addresses.
@@ -1447,8 +1423,7 @@ peerCountMcastPeersDone(void *data)
     fake->abort(); // sets ENTRY_ABORTED and initiates releated cleanup
     HTTPMSGUNLOCK(fake->mem_obj->request);
     fake->unlock("peerCountMcastPeersDone");
-    HTTPMSGUNLOCK(psstate->request);
-    cbdataFree(psstate);
+    delete psstate;
 }
 
 static void
@@ -51,7 +51,6 @@ CachePeer *neighborsDigestSelect(HttpRequest * request);
 void peerNoteDigestLookup(HttpRequest * request, CachePeer * p, lookup_t lookup);
 void peerNoteDigestGone(CachePeer * p);
 int neighborUp(const CachePeer * e);
-CBDUNL peerDestroy;
 const char *neighborTypeStr(const CachePeer * e);
 peer_t neighborType(const CachePeer *, const HttpRequest *);
 void peerConnectFailed(CachePeer *);
@@ -99,6 +99,47 @@ peerDigestClean(PeerDigest * pd)
 
 CBDATA_CLASS_INIT(PeerDigest);
 
+CBDATA_CLASS_INIT(DigestFetchState);
+
+DigestFetchState::DigestFetchState(PeerDigest *aPd, HttpRequest *req) :
+    pd(cbdataReference(aPd)),
+    entry(NULL),
+    old_entry(NULL),
+    sc(NULL),
+    old_sc(NULL),
+    request(req),
+    offset(0),
+    mask_offset(0),
+    start_time(squid_curtime),
+    resp_time(0),
+    expires(0),
+    bufofs(0),
+    state(DIGEST_READ_REPLY)
+{
+    HTTPMSGLOCK(request);
+
+    sent.msg = 0;
+    sent.bytes = 0;
+
+    recv.msg = 0;
+    recv.bytes = 0;
+
+    *buf = 0;
+}
+
+DigestFetchState::~DigestFetchState()
+{
+    /* unlock everything */
+    storeUnregister(sc, entry, this);
+
+    entry->unlock("DigestFetchState destructed");
+    entry = NULL;
+
+    HTTPMSGUNLOCK(request);
+
+    assert(pd == NULL);
+}
+
 /* allocate new peer digest, call Init, and lock everything */
 PeerDigest *
 peerDigestCreate(CachePeer * p)
@@ -270,8 +311,6 @@ peerDigestCheck(void *data)
         peerDigestSetCheck(pd, req_time - squid_curtime);
 }
 
-CBDATA_TYPE(DigestFetchState);
-
 /* ask store for a digest */
 static void
 peerDigestRequest(PeerDigest * pd)
@@ -281,7 +320,6 @@ peerDigestRequest(PeerDigest * pd)
     char *url = NULL;
     const cache_key *key;
     HttpRequest *req;
-    DigestFetchState *fetch = NULL;
     StoreIOBuffer tempBuffer;
 
     pd->req_result = NULL;
@@ -318,26 +356,11 @@ peerDigestRequest(PeerDigest * pd)
         req->url.userInfo(SBuf(p->login)); // XXX: performance regression make peer login SBuf as well.
     }
     /* create fetch state structure */
-    CBDATA_INIT_TYPE(DigestFetchState);
-
-    fetch = cbdataAlloc(DigestFetchState);
-
-    fetch->request = req;
-    HTTPMSGLOCK(fetch->request);
-
-    fetch->pd = cbdataReference(pd);
-
-    fetch->offset = 0;
-
-    fetch->state = DIGEST_READ_REPLY;
+    DigestFetchState *fetch = new DigestFetchState(pd, req);
 
     /* update timestamps */
-    fetch->start_time = squid_curtime;
-
     pd->times.requested = squid_curtime;
-
     pd_last_req_time = squid_curtime;
-
     req->flags.cachable = true;
 
     /* the rest is based on clientProcessExpired() */
@@ -418,7 +441,7 @@ peerDigestHandleReply(void *data, StoreIOBuffer receivedData)
      * try to destroy the fetch structure, and we like to know if they
      * do
      */
-    fetch = cbdataReference(fetch);
+    CbcPointer<DigestFetchState> tmpLock = fetch;
 
     /* Repeat this loop until we're out of data OR the state changes */
     /* (So keep going if the state has changed and we still have data */
@@ -447,15 +470,15 @@ peerDigestHandleReply(void *data, StoreIOBuffer receivedData)
             break;
 
         case DIGEST_READ_DONE:
-            goto finish;
+            return;
             break;
 
         default:
             fatal("Bad digest transfer mode!\n");
         }
 
         if (retsize < 0)
-            goto finish;
+            return;
 
         /*
          * The returned size indicates how much of the buffer was read -
@@ -482,10 +505,6 @@ peerDigestHandleReply(void *data, StoreIOBuffer receivedData)
         storeClientCopy(fetch->sc, fetch->entry, tempBuffer,
                         peerDigestHandleReply, fetch);
     }
-
-finish:
-    /* Get rid of our reference, we've finished with it for now */
-    cbdataReferenceDone(fetch);
 }
 
 /* wait for full http headers to be received then parse them */
@@ -902,18 +921,7 @@ peerDigestFetchFinish(DigestFetchState * fetch, int err)
 
     statCounter.cd.msgs_recv += fetch->recv.msg;
 
-    /* unlock everything */
-    storeUnregister(fetch->sc, fetch->entry, fetch);
-
-    fetch->entry->unlock("peerDigestFetchFinish new");
-
-    HTTPMSGUNLOCK(fetch->request);
-
-    fetch->entry = NULL;
-
-    assert(fetch->pd == NULL);
-
-    cbdataFree(fetch);
+    delete fetch;
 }
 
 /* calculate fetch stats after completion */
@@ -13,7 +13,7 @@
 #include "CachePeer.h"
 #include "carp.h"
 #include "client_side.h"
-#include "DnsLookupDetails.h"
+#include "dns/LookupDetails.h"
 #include "errorpage.h"
 #include "event.h"
 #include "FwdState.h"
@@ -61,7 +61,7 @@ static void peerGetSomeParent(ps_state *);
 static void peerGetAllParents(ps_state *);
 static void peerAddFwdServer(FwdServer **, CachePeer *, hier_code);
 static void peerSelectPinned(ps_state * ps);
-static void peerSelectDnsResults(const ipcache_addrs *ia, const DnsLookupDetails &details, void *data);
+static void peerSelectDnsResults(const ipcache_addrs *ia, const Dns::LookupDetails &details, void *data);
 
 CBDATA_CLASS_INIT(ps_state);
 
@@ -306,7 +306,7 @@ peerSelectDnsPaths(ps_state *psstate)
 }
 
 static void
-peerSelectDnsResults(const ipcache_addrs *ia, const DnsLookupDetails &details, void *data)
+peerSelectDnsResults(const ipcache_addrs *ia, const Dns::LookupDetails &details, void *data)
 {
     ps_state *psstate = (ps_state *)data;
 
@@ -107,8 +107,11 @@ refreshLimits(const char *url)
     const RefreshPattern *R;
 
     for (R = Config.Refresh; R; R = R->next) {
-        if (!regexec(&(R->compiled_pattern), url, 0, 0, 0))
+        ++(R->stats.matchTests);
+        if (!regexec(&(R->compiled_pattern), url, 0, 0, 0)) {
+            ++(R->stats.matchCount);
             return R;
+        }
     }
 
     return NULL;
@@ -694,14 +697,24 @@ refreshCountsStats(StoreEntry * sentry, struct RefreshCounts &rc)
     sum += refreshCountsStatsEntry(sentry, rc, STALE_MAX_RULE, "Stale: refresh_pattern max age rule");
     sum += refreshCountsStatsEntry(sentry, rc, STALE_LMFACTOR_RULE, "Stale: refresh_pattern last-mod factor percentage");
     sum += refreshCountsStatsEntry(sentry, rc, STALE_DEFAULT, "Stale: by default");
-
-    storeAppendPrintf(sentry, "%6d\t%6.2f\tTOTAL\n", rc.total, xpercent(rc.total, sum));
     storeAppendPrintf(sentry, "\n");
 }
 
 static void
 refreshStats(StoreEntry * sentry)
 {
+    // display per-rule counts of usage and tests
+    storeAppendPrintf(sentry, "\nRefresh pattern usage:\n\n");
+    storeAppendPrintf(sentry, "  Used      \tChecks    \t%% Matches\tPattern\n");
+    for (const RefreshPattern *R = Config.Refresh; R; R = R->next) {
+        storeAppendPrintf(sentry, "  %10" PRIu64 "\t%10" PRIu64 "\t%6.2f\t%s%s\n",
+                          R->stats.matchCount,
+                          R->stats.matchTests,
+                          xpercent(R->stats.matchCount, R->stats.matchTests),
+                          (R->flags.icase ? "-i " : ""),
+                          R->pattern);
+    }
+
     int i;
     int total = 0;
 
@@ -39,7 +39,7 @@ start_announce(void *)
 }
 
 static void
-send_announce(const ipcache_addrs *ia, const DnsLookupDetails &, void *)
+send_announce(const ipcache_addrs *ia, const Dns::LookupDetails &, void *)
 {
     LOCAL_ARRAY(char, tbuf, 256);
     LOCAL_ARRAY(char, sndbuf, BUFSIZ);
@@ -371,11 +371,11 @@ statObjects(void *data)
             storeAppendPrintf(state->sentry, "} by kid%d\n\n", KidIdentifier);
         state->sentry->complete();
         state->sentry->unlock("statObjects+isDone");
-        cbdataFree(state);
+        delete state;
         return;
     } else if (EBIT_TEST(state->sentry->flags, ENTRY_ABORTED)) {
         state->sentry->unlock("statObjects+aborted");
-        cbdataFree(state);
+        delete state;
         return;
     } else if (state->sentry->checkDeferRead(-1)) {
         state->sentry->flush();
@@ -308,13 +308,11 @@ storeClientCopy2(StoreEntry * e, store_client * sc)
      * this function
      * XXX: Locking does not prevent calling sc destructor (it only prevents
      * freeing sc memory) so sc may become invalid from C++ p.o.v.
-     *
      */
-    cbdataInternalLock(sc);
+    CbcPointer<store_client> tmpLock = sc;
     assert (!sc->flags.store_copying);
     sc->doCopy(e);
-    assert (!sc->flags.store_copying);
-    cbdataInternalUnlock(sc);
+    assert(!sc->flags.store_copying);
 }
 
 void
@@ -89,8 +89,9 @@ storeSwapOutStart(StoreEntry * e)
 static void
 storeSwapOutFileNotify(void *data, int errflag, StoreIOState::Pointer self)
 {
-    generic_cbdata *c = (generic_cbdata *)data;
-    StoreEntry *e = (StoreEntry *)c->data;
+    StoreEntry *e;
+    static_cast<generic_cbdata *>(data)->unwrap(&e);
+
     MemObject *mem = e->mem_obj;
     assert(e->swap_status == SWAPOUT_WRITING);
     assert(mem);
@@ -281,12 +282,12 @@ StoreEntry::swapOutFileClose(int how)
 static void
 storeSwapOutFileClosed(void *data, int errflag, StoreIOState::Pointer self)
 {
-    generic_cbdata *c = (generic_cbdata *)data;
-    StoreEntry *e = (StoreEntry *)c->data;
+    StoreEntry *e;
+    static_cast<generic_cbdata *>(data)->unwrap(&e);
+
     MemObject *mem = e->mem_obj;
     assert(mem->swapout.sio == self);
     assert(e->swap_status == SWAPOUT_WRITING);
-    cbdataFree(c);
 
     // if object_size is still unknown, the entry was probably aborted
     if (errflag || e->objectLen() < 0) {
@@ -17,14 +17,14 @@
 #define STUB_API "cache_cf.cc"
 #include "tests/STUB.h"
 
+#include "cache_cf.h"
 void self_destruct(void) STUB
 void parse_int(int *var) STUB
 void parse_onoff(int *var) STUB
 void parse_eol(char *volatile *var) STUB
 void parse_wordlist(wordlist ** list) STUB
 void requirePathnameExists(const char *name, const char *path) STUB_NOP
 void parse_time_t(time_t * var) STUB
-char * strtokFile(void) STUB_RETVAL(NULL)
 void ConfigParser::ParseUShort(unsigned short *var) STUB
 void dump_acl_access(StoreEntry * entry, const char *name, acl_access * head) STUB
 void dump_acl_list(StoreEntry*, ACLList*) STUB
@@ -7,15 +7,12 @@
  */
 
 #include "squid.h"
+#include "dns/rfc1035.h"
 #include "testRFC1035.h"
 #include "unitTestMain.h"
 
 #include <cassert>
 
-/* Being a C library code it is best bodily included and tested with C++ type-safe techniques. */
-#include "lib/rfc1035.c"
-#include "lib/rfc2671.c"
-
 CPPUNIT_TEST_SUITE_REGISTRATION( testRFC1035 );
 
 // TODO Test each function in the Library independently
@@ -915,3 +915,40 @@ testSBuf::testStdStringOps()
     CPPUNIT_ASSERT_EQUAL(astr,sb.toStdString());
 }
 
+void
+testSBuf::testIterators()
+{
+    SBuf text("foo"), text2("foo");
+    CPPUNIT_ASSERT(text.begin() == text.begin());
+    CPPUNIT_ASSERT(text.begin() != text.end());
+    CPPUNIT_ASSERT(text.begin() != text2.begin());
+    {
+        auto i = text.begin();
+        auto e = text.end();
+        CPPUNIT_ASSERT_EQUAL('f', *i);
+        CPPUNIT_ASSERT(i != e);
+        ++i;
+        CPPUNIT_ASSERT_EQUAL('o', *i);
+        CPPUNIT_ASSERT(i != e);
+        ++i;
+        CPPUNIT_ASSERT_EQUAL('o', *i);
+        CPPUNIT_ASSERT(i != e);
+        ++i;
+        CPPUNIT_ASSERT(i == e);
+    }
+    {
+        auto i = text.rbegin();
+        auto e = text.rend();
+        CPPUNIT_ASSERT_EQUAL('o', *i);
+        CPPUNIT_ASSERT(i != e);
+        ++i;
+        CPPUNIT_ASSERT_EQUAL('o', *i);
+        CPPUNIT_ASSERT(i != e);
+        ++i;
+        CPPUNIT_ASSERT_EQUAL('f', *i);
+        CPPUNIT_ASSERT(i != e);
+        ++i;
+        CPPUNIT_ASSERT(i == e);
+    }
+}
+
@@ -52,6 +52,7 @@ class testSBuf : public CPPUNIT_NS::TestFixture
     CPPUNIT_TEST( testSBufStream );
     CPPUNIT_TEST( testAutoFind );
     CPPUNIT_TEST( testStdStringOps );
+    CPPUNIT_TEST( testIterators );
 //    CPPUNIT_TEST( testDumpStats ); //fake test, to print alloc stats
     CPPUNIT_TEST_SUITE_END();
 protected:
@@ -91,6 +92,7 @@ class testSBuf : public CPPUNIT_NS::TestFixture
     void testFindFirstNotOf();
     void testAutoFind();
     void testStdStringOps();
+    void testIterators();
 };
 
 #endif
@@ -7,7 +7,6 @@
  */
 
 #include "enums.h"
-#include "rfc1035.h"
 
 #ifndef SQUID_TYPEDEFS_H
 #define SQUID_TYPEDEFS_H
@@ -31,7 +30,6 @@ typedef variable_list *(oid_ParseFn) (variable_list *, snint *);
 #endif
 
 typedef void FREE(void *);
-typedef void CBDUNL(void *);
 typedef void FOCB(void *, int fd, int errcode);
 typedef void PF(int, void *);
 
@@ -44,8 +42,11 @@ typedef void DCCB(int, int errflag, void *data);    /* disk close CB */
 typedef void DUCB(int errflag, void *data); /* disk unlink CB */
 typedef void DTCB(int errflag, void *data); /* disk trunc CB */
 
-class DnsLookupDetails;
-typedef void FQDNH(const char *, const DnsLookupDetails &details, void *);
+namespace Dns
+{
+class LookupDetails;
+}
+typedef void FQDNH(const char *, const Dns::LookupDetails &details, void *);
 
 #include "anyp/ProtocolType.h"
 class CachePeer;
@@ -68,7 +69,6 @@ typedef void STVLDCB(void *, int, int);
 typedef int HLPSAVAIL(void *);
 typedef void HLPSONEQ(void *);
 typedef void HLPCMDOPTS(int *argc, char **argv);
-typedef void IDNSCB(void *, const rfc1035_rr *, int, const char *);
 
 /* MD5 cache keys */
 typedef unsigned char cache_key;