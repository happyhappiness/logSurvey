@@ -1,3 +1,17 @@
+Changes to squid-3.5.10 (01 Oct 2015):
+
+	- Regression Fix cache_peer login=PASS(THRU) after CVE-2015-5400
+	- Regression Bug 4326: base64 binary encoder rejects data beginning with nil byte
+	- Bug 4323: Netfilter broken cross-includes with Linux 4.2
+	- Bug 4328: %un format code does not work for external ACLs in credentials-fetching rules
+	- Bug 4208: more than one port in wccp2_service_info line causes error
+	- Bug 4304: PeerConnector.cc:743 "!callback" assertion.
+	- Bug 4330: Do not use SSL_METHOD::put_cipher_by_char to determine size of SSL hello ciphers
+	- Relicense ntlm_fake_auth.pl to GPLv2+
+	- Relicense smb_lm auth helper to GPLv2+
+	- Relicense SSPI helper to GPLv2+
+	- ... and several minor performance optimizations
+
 Changes to squid-3.5.9 (17 Sep 2015):
 
 	- Regression Bug 3618: ntlm_smb_lm_auth rejects correct passwords
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.5.9 release notes</title>
+<title>Squid 3.5.10 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.5.9.
+The Squid Team are pleased to announce the release of Squid-3.5.10.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.5/"> or the
  <url url="http://www.squid-cache.org/Download/http-mirrors.html" name="mirrors">.
@@ -212,7 +212,7 @@ The ldap server list can be:
 server \- In this case server can be used for all Kerberos domains
 server@  \- In this case server can be used for all Kerberos domains
 server@domain  \- In this case server can be used for Kerberos domain domain
-server1a@domain1:server1b@domain1:server2@domain2:server3@:server4 \- A list is build with a colon as seperator
+server1a@domain1:server1b@domain1:server2@domain2:server3@:server4 \- A list is build with a colon as separator
 
 .
 .SH AUTHOR
@@ -252,7 +252,7 @@ main(int argc, char *const argv[])
             fprintf(stderr, "-n do not use Kerberos to authenticate to AD. Requires -u , -p and -l option\n");
             fprintf(stderr, "-g group list\n");
             fprintf(stderr, "-t group list (only group name hex UTF-8 format)\n");
-            fprintf(stderr, "-T group list (all in hex UTF-8 format - except seperator @)\n");
+            fprintf(stderr, "-T group list (all in hex UTF-8 format - except separator @)\n");
             fprintf(stderr, "-D default domain\n");
             fprintf(stderr, "-N netbios to dns domain map\n");
             fprintf(stderr, "-S ldap server to dns domain map\n");
@@ -272,7 +272,7 @@ main(int argc, char *const argv[])
             fprintf(stderr, "group   - In this case group can be used for all keberised and non kerberised ldap servers\n");
             fprintf(stderr, "group@  - In this case group can be used for all keberised ldap servers\n");
             fprintf(stderr, "group@domain  - In this case group can be used for ldap servers of domain domain\n");
-            fprintf(stderr, "group1@domain1:group2@domain2:group3@:group4  - A list is build with a colon as seperator\n");
+            fprintf(stderr, "group1@domain1:group2@domain2:group3@:group4  - A list is build with a colon as separator\n");
             fprintf(stderr, "Group membership is determined with AD servers through the users memberof attribute which\n");
             fprintf(stderr, "is followed to the top (e.g. if the group is a member of a group)\n");
             fprintf(stderr, "Group membership is determined with non AD servers through the users memberuid (assuming\n");
@@ -281,7 +281,7 @@ main(int argc, char *const argv[])
             fprintf(stderr, "server - In this case server can be used for all Kerberos domains\n");
             fprintf(stderr, "server@  - In this case server can be used for all Kerberos domains\n");
             fprintf(stderr, "server@domain  - In this case server can be used for Kerberos domain domain\n");
-            fprintf(stderr, "server1a@domain1:server1b@domain1:server2@domain2:server3@:server4 - A list is build with a colon as seperator\n");
+            fprintf(stderr, "server1a@domain1:server1b@domain1:server2@domain2:server3@:server4 - A list is build with a colon as separator\n");
             clean_args(&margs);
             exit(0);
         default:
@@ -95,13 +95,13 @@ void usage(void)
 static void
 closeFds(FILE *a, FILE *b, FILE *c, FILE *d)
 {
-    if (a >= 0)
+    if (a)
         fclose(a);
-    if (b >= 0)
+    if (b)
         fclose(b);
-    if (c >= 0)
+    if (c)
         fclose(c);
-    if (d >= 0)
+    if (d)
         fclose(d);
 }
 
@@ -162,6 +162,7 @@ processingLoop(FILE *FDKIN, FILE *FDKOUT, FILE *FDNIN, FILE *FDNOUT)
         }
         if (!strncmp(buf, "QQ", 2)) {
             fprintf(stdout, "BH quit command\n");
+            xfree(token);
             return 0;
         }
         if (strncmp(buf, "YR", 2) && strncmp(buf, "KK", 2)) {
@@ -12,6 +12,8 @@
 #include "StoreSwapLogData.h"
 #include "swap_log_op.h"
 
+#include <ostream>
+
 // Based on Internet Checksum (RFC 1071) algorithm but takes three 32bit ints.
 // TODO: Consider Fletcher's checksum algorithm as a higher quality alternative
 void
@@ -211,14 +211,14 @@ Auth::Basic::Config::decode(char const *proxy_auth, const char *aRequestRealm)
     /* permitted because local_basic is purely local function scope. */
     Auth::Basic::User *local_basic = NULL;
 
-    char *seperator = strchr(cleartext, ':');
+    char *separator = strchr(cleartext, ':');
 
     lb = local_basic = new Auth::Basic::User(this, aRequestRealm);
 
-    if (seperator) {
+    if (separator) {
         /* terminate the username */
-        *seperator = '\0';
-        local_basic->passwd = xstrdup(seperator+1);
+        *separator = '\0';
+        local_basic->passwd = xstrdup(separator+1);
     }
 
     if (!casesensitive)
@@ -234,7 +234,7 @@ Comm::TcpAcceptor::doAccept(int fd, void *data)
     } catch (const std::exception &e) {
         fatalf("FATAL: error while accepting new client connection: %s\n", e.what());
     } catch (...) {
-        fatal("FATAL: error while accepting new client connection: [unkown]\n");
+        fatal("FATAL: error while accepting new client connection: [unknown]\n");
     }
 }
 
@@ -97,6 +97,7 @@ class GopherStateData
         entry->lock("gopherState");
         *replybuf = 0;
     }
+    ~GopherStateData() {if(buf) swanSong();}
 
     /* AsyncJob API emulated */
     void deleteThis(const char *aReason);
@@ -166,8 +167,10 @@ GopherStateData::swanSong()
     if (entry)
         entry->unlock("gopherState");
 
-    if (buf)
+    if (buf) {
         memFree(buf, MEM_4K_BUF);
+        buf = nullptr;
+    }
 }
 
 /**
@@ -346,7 +346,7 @@ mem_hdr::write (StoreIOBuffer const &writeBuffer)
     if (unionNotEmpty(writeBuffer)) {
         debugs(19, DBG_CRITICAL, "mem_hdr::write: writeBuffer: " << writeBuffer.range());
         debugDump();
-        fatal_dump("Attempt to overwrite already in-memory data. Preceeding this there should be a mem_hdr::write output that lists the attempted write, and the currently present data. Please get a 'backtrace full' from this error - using the generated core, and file a bug report with the squid developers including the last 10 lines of cache.log and the backtrace.\n");
+        fatal_dump("Attempt to overwrite already in-memory data. Preceding this there should be a mem_hdr::write output that lists the attempted write, and the currently present data. Please get a 'backtrace full' from this error - using the generated core, and file a bug report with the squid developers including the last 10 lines of cache.log and the backtrace.\n");
         PROF_stop(mem_hdr_write);
         return false;
     }
@@ -323,7 +323,7 @@ urnHandleReply(void *data, StoreIOBuffer result)
 
     debugs(53, 3, "urnFindMinRtt: Counted " << i << " URLs");
 
-    if (urls == NULL) {     /* unkown URN error */
+    if (urls == NULL) {     /* unknown URN error */
         debugs(52, 3, "urnTranslateDone: unknown URN " << e->url());
         err = new ErrorState(ERR_URN_RESOLVE, Http::scNotFound, urnState->request.getRaw());
         err->url = xstrdup(e->url());