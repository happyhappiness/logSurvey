@@ -12,14 +12,14 @@
 
 #include "config.h"
 
- /* We want the Squid type and library definitions without the package ones */
+/* We want the Squid type and library definitions without the package ones */
 #undef VERSION
 #undef PACKAGE
 #undef PACKAGE_BUGREPORT
-#undef PACKAGE_NAME  
-#undef PACKAGE_STRING 
-#undef PACKAGE_TARNAME 
-#undef PACKAGE_VERSION 
+#undef PACKAGE_NAME
+#undef PACKAGE_STRING
+#undef PACKAGE_TARNAME
+#undef PACKAGE_VERSION
 #endif /* HAVE_SQUID */
 
 #endif /* SQUID__HELPERS_NEGOTIATE_AUTH_SQUID_KERB_AUTH_SQUID_COMPAT_H */
@@ -620,12 +620,12 @@ testIPAddress::testAddrInfo()
 #if 0
     p = (unsigned int*)(expect->ai_addr);
     printf("\nSYS-ADDR: (%d)  %x %x %x %x %x %x %x %x ...",
-            expect->ai_addrlen,
+           expect->ai_addrlen,
            p[0],p[1],p[2],p[3],p[4],p[5],p[6],p[7] );
 
     p = (unsigned int*)(ipval->ai_addr);
     printf("\nSQD-ADDR: (%d) %x %x %x %x %x %x %x %x ...",
-            ipval->ai_addrlen,
+           ipval->ai_addrlen,
            p[0],p[1],p[2],p[3],p[4],p[5],p[6],p[7] );
     printf("\n");
 #if HAVE_SS_LEN_IN_SS
@@ -11,7 +11,7 @@ int
 ACLPeerNameStrategy::match (ACLData<MatchType> * &data, ACLChecklist *checklist)
 {
     if (checklist->dst_peer != NULL && checklist->dst_peer->name != NULL)
-	return data->match(checklist->dst_peer->name);
+        return data->match(checklist->dst_peer->name);
     return 0;
 }
 
@@ -17,7 +17,7 @@ class ACLPeerNameStrategy : public ACLStrategy<const char *>
 
 private:
     static ACLPeerNameStrategy Instance_;
-    ACLPeerNameStrategy(){}
+    ACLPeerNameStrategy() {}
 
     ACLPeerNameStrategy&operator=(ACLPeerNameStrategy const &);
 };
@@ -21,12 +21,12 @@
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
- *  
+ *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
- *  
+ *
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
@@ -104,9 +104,9 @@ HttpRequest::init()
 void
 HttpRequest::clean()
 {
-    // we used to assert that the pipe is NULL, but now the request only 
+    // we used to assert that the pipe is NULL, but now the request only
     // points to a pipe that is owned and initiated by another object.
-    body_pipe = NULL; 
+    body_pipe = NULL;
 
     AUTHUSERREQUESTUNLOCK(auth_user_request, "request");
 
@@ -128,8 +128,8 @@ HttpRequest::clean()
         range = NULL;
     }
 
-    if(pinned_connection)
-	cbdataReferenceDone(pinned_connection);
+    if (pinned_connection)
+        cbdataReferenceDone(pinned_connection);
 
     tag.clean();
 
@@ -166,20 +166,20 @@ HttpRequest::clone() const
     if (auth_user_request) {
         copy->auth_user_request = auth_user_request;
         AUTHUSERREQUESTLOCK(copy->auth_user_request, "HttpRequest::clone");
-	}
+    }
 
     copy->port = port;
     // urlPath handled in ctor
-	copy->canonical = canonical ? xstrdup(canonical) : NULL;
-    
+    copy->canonical = canonical ? xstrdup(canonical) : NULL;
+
     // This may be too conservative for the 204 No Content case
     // may eventually need cloneNullAdaptationImmune() for that.
     copy->flags = flags.cloneAdaptationImmune();
 
-	copy->range = range ? new HttpHdrRange(*range) : NULL;
-	copy->ims = ims;
-	copy->imslen = imslen;
-	copy->max_forwards = max_forwards;
+    copy->range = range ? new HttpHdrRange(*range) : NULL;
+    copy->ims = ims;
+    copy->imslen = imslen;
+    copy->max_forwards = max_forwards;
     copy->client_addr = client_addr;
     copy->my_addr = my_addr;
     copy->hier = hier; // Is it safe to copy? Should we?
@@ -188,7 +188,7 @@ HttpRequest::clone() const
 
     // XXX: what to do with copy->peer_login?
 
-	copy->lastmod = lastmod;
+    copy->lastmod = lastmod;
     copy->vary_headers = vary_headers ? xstrdup(vary_headers) : NULL;
     // XXX: what to do with copy->peer_domain?
 
@@ -400,7 +400,8 @@ request_flags::cloneAdaptationImmune() const
 }
 
 bool
-HttpRequest::bodyNibbled() const {
+HttpRequest::bodyNibbled() const
+{
     return body_pipe != NULL && body_pipe->consumedSize() > 0;
 }
 
@@ -498,9 +499,9 @@ HttpRequest::cacheable() const
      * The below looks questionable: what non HTTP protocols use connect,
      * trace, put and post? RC
      */
-    
+
     if (!method.isCacheble())
-    	return false;
+        return false;
 
     /*
      * XXX POST may be cached sometimes.. ignored
@@ -518,9 +519,9 @@ HttpRequest::cacheable() const
 bool HttpRequest::inheritProperties(const HttpMsg *aMsg)
 {
     const HttpRequest* aReq = dynamic_cast<const HttpRequest*>(aMsg);
-    if(!aReq)
-	return false;
-    
+    if (!aReq)
+        return false;
+
     client_addr = aReq->client_addr;
     my_addr = aReq->my_addr;
 
@@ -530,11 +531,11 @@ bool HttpRequest::inheritProperties(const HttpMsg *aMsg)
 
     if (aReq->auth_user_request) {
         auth_user_request = aReq->auth_user_request;
-	AUTHUSERREQUESTLOCK(auth_user_request, "inheritProperties");
+        AUTHUSERREQUESTLOCK(auth_user_request, "inheritProperties");
     }
 
-    if(aReq->pinned_connection) {
-	pinned_connection = cbdataReference(aReq->pinned_connection);
+    if (aReq->pinned_connection) {
+        pinned_connection = cbdataReference(aReq->pinned_connection);
     }
     return true;
 }
@@ -38,13 +38,13 @@ ICAPModXact::State::State()
 }
 
 ICAPModXact::ICAPModXact(Adaptation::Initiator *anInitiator, HttpMsg *virginHeader,
-    HttpRequest *virginCause, ICAPServiceRep::Pointer &aService):
-    AsyncJob("ICAPModXact"),
-    ICAPXaction("ICAPModXact", anInitiator, aService),
-    icapReply(NULL),
-    virginConsumed(0),
-    bodyParser(NULL),
-    canStartBypass(false) // too early
+                         HttpRequest *virginCause, ICAPServiceRep::Pointer &aService):
+        AsyncJob("ICAPModXact"),
+        ICAPXaction("ICAPModXact", anInitiator, aService),
+        icapReply(NULL),
+        virginConsumed(0),
+        bodyParser(NULL),
+        canStartBypass(false) // too early
 {
     assert(virginHeader);
 
@@ -88,7 +88,7 @@ void ICAPModXact::waitForService()
     debugs(93, 7, "ICAPModXact will wait for the ICAP service" << status());
     state.serviceWaiting = true;
     AsyncCall::Pointer call = asyncCall(93,5, "ICAPModXact::noteServiceReady",
-        MemFun(this, &ICAPModXact::noteServiceReady));
+                                        MemFun(this, &ICAPModXact::noteServiceReady));
     service().callWhenReady(call);
 }
 
@@ -152,12 +152,12 @@ void ICAPModXact::handleCommWroteHeaders()
     if (preview.enabled())
         state.writing = preview.done() ? State::writingPaused : State::writingPreview;
     else
-    if (virginBody.expected())
-        state.writing = State::writingPrime;
-    else {
-        stopWriting(true);
-        return;
-    }
+        if (virginBody.expected())
+            state.writing = State::writingPrime;
+        else {
+            stopWriting(true);
+            return;
+        }
 
     writeMore();
 }
@@ -203,7 +203,7 @@ void ICAPModXact::writeMore()
 void ICAPModXact::writePreviewBody()
 {
     debugs(93, 8, HERE << "will write Preview body from " <<
-        virgin.body_pipe << status());
+           virgin.body_pipe << status());
     Must(state.writing == State::writingPreview);
     Must(virgin.body_pipe != NULL);
 
@@ -307,7 +307,7 @@ void ICAPModXact::closeChunk(MemBuf &buf)
 // did the activity reached the end of the virgin body?
 bool ICAPModXact::virginBodyEndReached(const VirginBodyAct &act) const
 {
-    return 
+    return
         !act.active() || // did all (assuming it was originally planned)
         !virgin.body_pipe->expectMoreAfter(act.offset()); // wont have more
 }
@@ -347,11 +347,11 @@ void ICAPModXact::virginConsume()
     BodyPipe &bp = *virgin.body_pipe;
 
     // Why > 2? HttpState does not use the last bytes in the buffer
-    // because delayAwareRead() is arguably broken. See 
+    // because delayAwareRead() is arguably broken. See
     // HttpStateData::maybeReadVirginBody for more details.
     if (canStartBypass && bp.buf().spaceSize() > 2) {
         // Postponing may increase memory footprint and slow the HTTP side
-        // down. Not postponing may increase the number of ICAP errors 
+        // down. Not postponing may increase the number of ICAP errors
         // if the ICAP service fails. We may also use "potential" space to
         // postpone more aggressively. Should the trade-off be configurable?
         debugs(93, 8, HERE << "postponing consumption from " << bp.status());
@@ -363,9 +363,9 @@ void ICAPModXact::virginConsume()
     uint64_t offset = end;
 
     debugs(93, 9, HERE << "max virgin consumption offset=" << offset <<
-        " acts " << virginBodyWriting.active() << virginBodySending.active() <<
-        " consumed=" << virginConsumed << 
-        " from " << virgin.body_pipe->status());
+           " acts " << virginBodyWriting.active() << virginBodySending.active() <<
+           " consumed=" << virginConsumed <<
+           " from " << virgin.body_pipe->status());
 
     if (virginBodyWriting.active())
         offset = XMIN(virginBodyWriting.offset(), offset);
@@ -462,7 +462,7 @@ void ICAPModXact::readMore()
 
     // do not fill readBuf if we have no space to store the result
     if (adapted.body_pipe != NULL &&
-        !adapted.body_pipe->buf().hasPotentialSpace()) {
+            !adapted.body_pipe->buf().hasPotentialSpace()) {
         debugs(93,3,HERE << "not reading because ICAP reply pipe is full");
         return;
     }
@@ -489,14 +489,14 @@ void ICAPModXact::echoMore()
 
     const size_t sizeMax = virginContentSize(virginBodySending);
     debugs(93,5, HERE << "will echo up to " << sizeMax << " bytes from " <<
-        virgin.body_pipe->status());
+           virgin.body_pipe->status());
     debugs(93,5, HERE << "will echo up to " << sizeMax << " bytes to   " <<
-        adapted.body_pipe->status());
+           adapted.body_pipe->status());
 
     if (sizeMax > 0) {
         const size_t size = adapted.body_pipe->putMoreData(virginContentData(virginBodySending), sizeMax);
         debugs(93,5, HERE << "echoed " << size << " out of " << sizeMax <<
-           " bytes");
+               " bytes");
         virginBodySending.progress(size);
         virginConsume();
         disableBypass("echoed content");
@@ -507,8 +507,8 @@ void ICAPModXact::echoMore()
         stopSending(true);
     } else {
         debugs(93, 5, "ICAPModXact has " <<
-            virgin.body_pipe->buf().contentSize() << " bytes " <<
-            "and expects more to echo" << status());
+               virgin.body_pipe->buf().contentSize() << " bytes " <<
+               "and expects more to echo" << status());
         // TODO: timeout if virgin or adapted pipes are broken
     }
 }
@@ -575,10 +575,9 @@ void ICAPModXact::callException(const std::exception &e)
 
     try {
         debugs(93, 3, "bypassing ICAPModXact::" << inCall << " exception: " <<
-           e.what() << ' ' << status());
+               e.what() << ' ' << status());
         bypassFailure();
-    }
-    catch (const std::exception &bypassE) {
+    } catch (const std::exception &bypassE) {
         ICAPXaction::callException(bypassE);
     }
 }
@@ -785,10 +784,9 @@ void ICAPModXact::prepEchoing()
     if (dynamic_cast<const HttpRequest*>(oldHead)) {
         HttpRequest *newR = new HttpRequest;
         newHead = newR;
-    } 
-    else if (dynamic_cast<const HttpReply*>(oldHead)) {
-	HttpReply *newRep = new HttpReply;
-	newHead = newRep;
+    } else if (dynamic_cast<const HttpReply*>(oldHead)) {
+        HttpReply *newRep = new HttpReply;
+        newHead = newRep;
     }
     Must(newHead);
     newHead->inheritProperties(oldHead);
@@ -805,12 +803,12 @@ void ICAPModXact::prepEchoing()
     httpBuf.clean();
 
     debugs(93, 7, "ICAPModXact cloned virgin message " << oldHead << " to " <<
-        newHead);
+           newHead);
 
     // setup adapted body pipe if needed
     if (oldHead->body_pipe != NULL) {
         debugs(93, 7, HERE << "will echo virgin body from " <<
-            oldHead->body_pipe);
+               oldHead->body_pipe);
         if (!virginBodySending.active())
             virginBodySending.plan(); // will throw if not possible
         state.sending = State::sendingVirgin;
@@ -822,7 +820,7 @@ void ICAPModXact::prepEchoing()
         if (oldHead->body_pipe->bodySizeKnown())
             adapted.body_pipe->setBodySize(oldHead->body_pipe->bodySize());
         debugs(93, 7, HERE << "will echo virgin body to " <<
-            adapted.body_pipe);
+               adapted.body_pipe);
     } else {
         debugs(93, 7, HERE << "no virgin body to echo");
         stopSending(true);
@@ -850,15 +848,15 @@ void ICAPModXact::parseHttpHead()
         if (dynamic_cast<HttpRequest*>(adapted.header)) {
             const HttpRequest *oldR = dynamic_cast<const HttpRequest*>(virgin.header);
             Must(oldR);
-            // TODO: the adapted request did not really originate from the 
-            // client; give proxy admin an option to prevent copying of 
+            // TODO: the adapted request did not really originate from the
+            // client; give proxy admin an option to prevent copying of
             // sensitive client information here. See the following thread:
             // http://www.squid-cache.org/mail-archive/squid-dev/200703/0040.html
         }
 
-	// Maybe adapted.header==NULL if HttpReply and have Http 0.9 ....
-	if(adapted.header) 
-	    adapted.header->inheritProperties(virgin.header);
+        // Maybe adapted.header==NULL if HttpReply and have Http 0.9 ....
+        if (adapted.header)
+            adapted.header->inheritProperties(virgin.header);
     }
 
     decideOnParsingBody();
@@ -886,7 +884,8 @@ bool ICAPModXact::parseHead(HttpMsg *head)
     return true;
 }
 
-void ICAPModXact::decideOnParsingBody() {
+void ICAPModXact::decideOnParsingBody()
+{
     if (gotEncapsulated("res-body") || gotEncapsulated("req-body")) {
         debugs(93, 5, HERE << "expecting a body");
         state.parsing = State::psBody;
@@ -976,7 +975,7 @@ void ICAPModXact::noteBodyProductionEnded(BodyPipe::Pointer)
         echoMore();
 }
 
-// body producer aborted, but the initiator may still want to know 
+// body producer aborted, but the initiator may still want to know
 // the answer, even though the HTTP message has been truncated
 void ICAPModXact::noteBodyProducerAborted(BodyPipe::Pointer)
 {
@@ -989,7 +988,7 @@ void ICAPModXact::noteBodyProducerAborted(BodyPipe::Pointer)
         echoMore();
 }
 
-// adapted body consumer wants more adapted data and 
+// adapted body consumer wants more adapted data and
 // possibly freed some buffer space
 void ICAPModXact::noteMoreBodySpaceAvailable(BodyPipe::Pointer)
 {
@@ -1039,13 +1038,13 @@ void ICAPModXact::makeRequestHeaders(MemBuf &buf)
 
     // we must forward "Proxy-Authenticate" and "Proxy-Authorization"
     // as ICAP headers.
-    if (virgin.header->header.has(HDR_PROXY_AUTHENTICATE)) 
-        buf.Printf("Proxy-Authenticate: %s\r\n", 
-                virgin.header->header.getByName("Proxy-Authenticate").buf());    
-    
-    if (virgin.header->header.has(HDR_PROXY_AUTHORIZATION)) 
-        buf.Printf("Proxy-Authorization: %s\r\n", 
-                virgin.header->header.getByName("Proxy-Authorization").buf());
+    if (virgin.header->header.has(HDR_PROXY_AUTHENTICATE))
+        buf.Printf("Proxy-Authenticate: %s\r\n",
+                   virgin.header->header.getByName("Proxy-Authenticate").buf());
+
+    if (virgin.header->header.has(HDR_PROXY_AUTHORIZATION))
+        buf.Printf("Proxy-Authorization: %s\r\n",
+                   virgin.header->header.getByName("Proxy-Authorization").buf());
 
     buf.Printf("Encapsulated: ");
 
@@ -1057,8 +1056,8 @@ void ICAPModXact::makeRequestHeaders(MemBuf &buf)
     ICAP::Method m = s.method;
 
     const HttpRequest *request = virgin.cause ?
-        virgin.cause :
-        dynamic_cast<const HttpRequest*>(virgin.header);
+                                 virgin.cause :
+                                 dynamic_cast<const HttpRequest*>(virgin.header);
 
     // to simplify, we could assume that request is always available
 
@@ -1068,8 +1067,8 @@ void ICAPModXact::makeRequestHeaders(MemBuf &buf)
         if (ICAP::methodRespmod == m)
             encapsulateHead(buf, "req-hdr", httpBuf, request);
         else
-        if (ICAP::methodReqmod == m)
-            encapsulateHead(buf, "req-hdr", httpBuf, virgin.header);
+            if (ICAP::methodReqmod == m)
+                encapsulateHead(buf, "req-hdr", httpBuf, virgin.header);
     }
 
     if (ICAP::methodRespmod == m)
@@ -1118,13 +1117,14 @@ void ICAPModXact::makeRequestHeaders(MemBuf &buf)
     httpBuf.clean();
 }
 
-void ICAPModXact::makeUsernameHeader(const HttpRequest *request, MemBuf &buf) {
+void ICAPModXact::makeUsernameHeader(const HttpRequest *request, MemBuf &buf)
+{
     if (const AuthUserRequest *auth = request->auth_user_request) {
         if (char const *name = auth->username()) {
             const char *value = TheICAPConfig.client_username_encode ?
-                base64_encode(name) : name;
+                                base64_encode(name) : name;
             buf.Printf("%s: %s\r\n", TheICAPConfig.client_username_header,
-                value);
+                       value);
         }
     }
 }
@@ -1136,29 +1136,28 @@ void ICAPModXact::encapsulateHead(MemBuf &icapBuf, const char *section, MemBuf &
 
     // begin cloning
     HttpMsg *headClone = NULL;
-    
+
     if (const HttpRequest* old_request = dynamic_cast<const HttpRequest*>(head)) {
         HttpRequest* new_request = new HttpRequest;
         urlParse(old_request->method, old_request->canonical,new_request);
         new_request->http_ver = old_request->http_ver;
         headClone = new_request;
-    } 
-    else if (const HttpReply *old_reply = dynamic_cast<const HttpReply*>(head)) {
+    } else if (const HttpReply *old_reply = dynamic_cast<const HttpReply*>(head)) {
         HttpReply* new_reply = new HttpReply;
         new_reply->sline = old_reply->sline;
         headClone = new_reply;
     }
-    
+
     Must(headClone);
     headClone->inheritProperties(head);
-    
+
     HttpHeaderPos pos = HttpHeaderInitPos;
     HttpHeaderEntry* p_head_entry = NULL;
     while (NULL != (p_head_entry = head->header.getEntry(&pos)) )
         headClone->header.addEntry(p_head_entry->clone());
 
     // end cloning
-        
+
     // remove all hop-by-hop headers from the clone
     headClone->header.delById(HDR_PROXY_AUTHENTICATE);
     headClone->header.removeHopByHopEntries();
@@ -1186,8 +1185,8 @@ void ICAPModXact::decideOnPreview()
     }
 
     const HttpRequest *request = virgin.cause ?
-        virgin.cause :
-        dynamic_cast<const HttpRequest*>(virgin.header);
+                                 virgin.cause :
+                                 dynamic_cast<const HttpRequest*>(virgin.header);
     const String urlPath = request ? request->urlpath : String();
     size_t wantedSize;
     if (!service().wantsPreview(urlPath, wantedSize)) {
@@ -1205,8 +1204,8 @@ void ICAPModXact::decideOnPreview()
     if (!virginBody.expected())
         ad = 0;
     else
-    if (virginBody.knownSize())
-        ad = XMIN(static_cast<uint64_t>(ad), virginBody.size()); // not more than we have
+        if (virginBody.knownSize())
+            ad = XMIN(static_cast<uint64_t>(ad), virginBody.size()); // not more than we have
 
     debugs(93, 5, "ICAPModXact should offer " << ad << "-byte preview " <<
            "(service wanted " << wantedSize << ")");
@@ -1307,7 +1306,7 @@ void ICAPModXact::fillPendingStatus(MemBuf &buf) const
         buf.Printf("S(%d)", state.sending);
 
     if (canStartBypass)
-       buf.append("Y", 1);
+        buf.append("Y", 1);
 }
 
 void ICAPModXact::fillDoneStatus(MemBuf &buf) const
@@ -1356,17 +1355,17 @@ void ICAPModXact::estimateVirginBody()
     if (virgin.cause)
         method = virgin.cause->method;
     else
-    if (HttpRequest *req = dynamic_cast<HttpRequest*>(msg))
-        method = req->method;
-    else
-        method = METHOD_NONE;
+        if (HttpRequest *req = dynamic_cast<HttpRequest*>(msg))
+            method = req->method;
+        else
+            method = METHOD_NONE;
 
     int64_t size;
     // expectingBody returns true for zero-sized bodies, but we will not
     // get a pipe for that body, so we treat the message as bodyless
     if (method != METHOD_NONE && msg->expectingBody(method, size) && size) {
-        debugs(93, 6, "ICAPModXact expects virgin body from " << 
-            virgin.body_pipe << "; size: " << size);
+        debugs(93, 6, "ICAPModXact expects virgin body from " <<
+               virgin.body_pipe << "; size: " << size);
 
         virginBody.expect(size);
         virginBodyWriting.plan();
@@ -1385,13 +1384,14 @@ void ICAPModXact::estimateVirginBody()
     }
 }
 
-void ICAPModXact::makeAdaptedBodyPipe(const char *what) {
+void ICAPModXact::makeAdaptedBodyPipe(const char *what)
+{
     Must(!adapted.body_pipe);
     Must(!adapted.header->body_pipe);
     adapted.header->body_pipe = new BodyPipe(this);
     adapted.body_pipe = adapted.header->body_pipe;
     debugs(93, 7, HERE << "will supply " << what << " via " <<
-        adapted.body_pipe << " pipe");
+           adapted.body_pipe << " pipe");
 }
 
 
@@ -1501,13 +1501,13 @@ void ICAPPreview::wrote(size_t size, bool wroteEof)
 
     theWritten += size;
 
-	Must(theWritten <= theAd);
+    Must(theWritten <= theAd);
 
-	if (wroteEof)
-		theState = stIeof; // written size is irrelevant
-	else
-    if (theWritten >= theAd)
-        theState = stDone;
+    if (wroteEof)
+        theState = stIeof; // written size is irrelevant
+    else
+        if (theWritten >= theAd)
+            theState = stDone;
 }
 
 bool ICAPModXact::fillVirginHttpHeader(MemBuf &mb) const
@@ -1524,8 +1524,8 @@ bool ICAPModXact::fillVirginHttpHeader(MemBuf &mb) const
 /* ICAPModXactLauncher */
 
 ICAPModXactLauncher::ICAPModXactLauncher(Adaptation::Initiator *anInitiator, HttpMsg *virginHeader, HttpRequest *virginCause, Adaptation::ServicePointer aService):
-    AsyncJob("ICAPModXactLauncher"),
-    ICAPLauncher("ICAPModXactLauncher", anInitiator, aService)
+        AsyncJob("ICAPModXactLauncher"),
+        ICAPLauncher("ICAPModXactLauncher", anInitiator, aService)
 {
     virgin.setHeader(virginHeader);
     virgin.setCause(virginCause);
@@ -19,12 +19,12 @@
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
- *  
+ *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
- *  
+ *
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
@@ -72,7 +72,7 @@ class SizedEstimate
     int64_t theData; // combines expectation and size info to save RAM
 };
 
-// Virgin body may be used for two activities: (a) writing preview or prime 
+// Virgin body may be used for two activities: (a) writing preview or prime
 // body to the ICAP server and (b) sending the body back in the echo mode.
 // Both activities use the same BodyPipe and may be active at the same time.
 // This class is used to maintain the state of body writing or sending
@@ -274,15 +274,16 @@ class ICAPModXact: public ICAPXaction, public BodyProducer, public BodyConsumer
         bool doneWriting() const { return writing == writingReallyDone; }
 
         // will not use virgin.body_pipe
-        bool doneConsumingVirgin() const { return writing >= writingAlmostDone
-            && (sending == sendingAdapted || sending == sendingDone); }
+        bool doneConsumingVirgin() const {
+            return writing >= writingAlmostDone
+                   && (sending == sendingAdapted || sending == sendingDone);
+        }
 
         // parsed entire ICAP response from the ICAP server
         bool doneParsing() const { return parsing == psDone; }
 
         // is parsing ICAP or HTTP headers read from the ICAP server
-        bool parsingHeaders() const
-        {
+        bool parsingHeaders() const {
             return parsing == psIcapHeader ||
                    parsing == psHttpHeader;
         }
@@ -291,18 +292,20 @@ class ICAPModXact: public ICAPXaction, public BodyProducer, public BodyConsumer
 
         // measures ICAP request writing progress
         enum Writing { writingInit, writingConnect, writingHeaders,
-            writingPreview, writingPaused, writingPrime,
-            writingAlmostDone, // waiting for the last write() call to finish
-            writingReallyDone } writing;
+                       writingPreview, writingPaused, writingPrime,
+                       writingAlmostDone, // waiting for the last write() call to finish
+                       writingReallyDone
+                     } writing;
 
         enum Sending { sendingUndecided, sendingVirgin, sendingAdapted,
-                       sendingDone } sending;
+                       sendingDone
+                     } sending;
     } state;
 
     CBDATA_CLASS2(ICAPModXact);
 };
 
-// An ICAPLauncher that stores ICAPModXact construction info and 
+// An ICAPLauncher that stores ICAPModXact construction info and
 // creates ICAPModXact when needed
 class ICAPModXactLauncher: public ICAPLauncher
 {
@@ -43,7 +43,7 @@ ICAPOptions::TransferKind ICAPOptions::transferKind(const String &urlPath) const
         return xferIgnore;
 
     debugs(93,7, "ICAPOptions url " << urlPath << " matches no extensions; " <<
-        "using default: " << theTransfers.byDefault->name);
+           "using default: " << theTransfers.byDefault->name);
     return theTransfers.byDefault->kind;
 }
 
@@ -141,7 +141,7 @@ void ICAPOptions::cfgTransferList(const HttpHeader *h, TransferList &list)
     if (foundStar) {
         theTransfers.byDefault = &list;
         debugs(93,5, "ICAPOptions::cfgTransferList: " <<
-            "set default transfer to " << list.name);
+               "set default transfer to " << list.name);
     }
 
     list.report(5, "ICAPOptions::cfgTransferList: ");
@@ -151,18 +151,22 @@ void ICAPOptions::cfgTransferList(const HttpHeader *h, TransferList &list)
 /* ICAPOptions::TransferList */
 
 ICAPOptions::TransferList::TransferList(): extensions(NULL), name(NULL),
-    kind(xferNone) {
+        kind(xferNone)
+{
 };
 
-ICAPOptions::TransferList::~TransferList() {
+ICAPOptions::TransferList::~TransferList()
+{
     wordlistDestroy(&extensions);
 };
 
-void ICAPOptions::TransferList::add(const char *extension) {
+void ICAPOptions::TransferList::add(const char *extension)
+{
     wordlistAdd(&extensions, extension);
 };
 
-bool ICAPOptions::TransferList::matches(const String &urlPath) const {
+bool ICAPOptions::TransferList::matches(const String &urlPath) const
+{
     const int urlLen = urlPath.size();
     for (wordlist *e = extensions; e; e = e->next) {
         // optimize: store extension lengths
@@ -173,9 +177,9 @@ bool ICAPOptions::TransferList::matches(const String &urlPath) const {
             const int eOff = urlLen - eLen;
             // RFC 3507 examples imply that extensions come without leading '.'
             if (urlPath.buf()[eOff-1] == '.' &&
-                strcmp(urlPath.buf() + eOff, e->key) == 0) {
+                    strcmp(urlPath.buf() + eOff, e->key) == 0) {
                 debugs(93,7, "ICAPOptions url " << urlPath << " matches " <<
-                    name << " extension " << e->key);
+                       name << " extension " << e->key);
                 return true;
             }
         }
@@ -184,7 +188,8 @@ bool ICAPOptions::TransferList::matches(const String &urlPath) const {
     return false;
 }
 
-void ICAPOptions::TransferList::parse(const String &buf, bool &foundStar) {
+void ICAPOptions::TransferList::parse(const String &buf, bool &foundStar)
+{
     foundStar = false;
 
     const char *item;
@@ -198,7 +203,8 @@ void ICAPOptions::TransferList::parse(const String &buf, bool &foundStar) {
     }
 }
 
-void ICAPOptions::TransferList::report(int level, const char *prefix) const {
+void ICAPOptions::TransferList::report(int level, const char *prefix) const
+{
     if (extensions) {
         for (wordlist *e = extensions; e; e = e->next)
             debugs(93,level, prefix << name << ": " << e->key);
@@ -39,11 +39,11 @@ ICAPServiceRep::setSelf(Pointer &aSelf)
 void
 ICAPServiceRep::finalize()
 {
-	Adaptation::Service::finalize();
+    Adaptation::Service::finalize();
     assert(self != NULL);
 
     // use /etc/services or default port if needed
-	const bool have_port = cfg().port >= 0;
+    const bool have_port = cfg().port >= 0;
     if (!have_port) {
         struct servent *serv = getservbyname("icap", "tcp");
 
@@ -67,25 +67,27 @@ void ICAPServiceRep::invalidate()
     // TODO: it would be nice to invalidate cbdata(this) when not destroyed
 }
 
-void ICAPServiceRep::noteFailure() {
+void ICAPServiceRep::noteFailure()
+{
     ++theSessionFailures;
-    debugs(93,4, theSessionFailures << " ICAPService failures, out of " << 
-        TheICAPConfig.service_failure_limit << " allowed " << status());
+    debugs(93,4, theSessionFailures << " ICAPService failures, out of " <<
+           TheICAPConfig.service_failure_limit << " allowed " << status());
 
     if (isSuspended)
         return;
 
     if (TheICAPConfig.service_failure_limit >= 0 &&
-        theSessionFailures > TheICAPConfig.service_failure_limit)
+            theSessionFailures > TheICAPConfig.service_failure_limit)
         suspend("too many failures");
 
     // TODO: Should bypass setting affect how much Squid tries to talk to
-    // the ICAP service that is currently unusable and is likely to remain 
-    // so for some time? The current code says "no". Perhaps the answer 
+    // the ICAP service that is currently unusable and is likely to remain
+    // so for some time? The current code says "no". Perhaps the answer
     // should be configurable.
 }
 
-void ICAPServiceRep::suspend(const char *reason) {
+void ICAPServiceRep::suspend(const char *reason)
+{
     if (isSuspended) {
         debugs(93,4, "keeping ICAPService suspended, also for " << reason);
     } else {
@@ -101,7 +103,8 @@ bool ICAPServiceRep::probed() const
     return theLastUpdate != 0;
 }
 
-bool ICAPServiceRep::hasOptions() const {
+bool ICAPServiceRep::hasOptions() const
+{
     return theOptions && theOptions->valid() && theOptions->fresh();
 }
 
@@ -183,8 +186,8 @@ void ICAPServiceRep::noteTimeToNotify()
 
     while (!theClients.empty()) {
         Client i = theClients.pop_back();
-		ScheduleCallHere(i.callback);
-		i.callback = 0;
+        ScheduleCallHere(i.callback);
+        i.callback = 0;
     }
 
     notifying = false;
@@ -195,7 +198,7 @@ void ICAPServiceRep::callWhenReady(AsyncCall::Pointer &cb)
     Must(cb!=NULL);
 
     debugs(93,5, HERE << "ICAPService is asked to call " << *cb <<
-        " when ready " << status());
+           " when ready " << status());
 
     Must(self != NULL);
     Must(!broken()); // we do not wait for a broken service
@@ -217,7 +220,7 @@ void ICAPServiceRep::callWhenReady(AsyncCall::Pointer &cb)
 void ICAPServiceRep::scheduleNotification()
 {
     debugs(93,7, "ICAPService will notify " << theClients.size() << " clients");
-     CallJobHere(93, 5, this, ICAPServiceRep::noteTimeToNotify);
+    CallJobHere(93, 5, this, ICAPServiceRep::noteTimeToNotify);
 }
 
 bool ICAPServiceRep::needNewOptions() const
@@ -247,7 +250,7 @@ void ICAPServiceRep::checkOptions()
 
     if (!theOptions->valid()) {
         debugs(93,1, "WARNING: Squid got an invalid ICAP OPTIONS response " <<
-            "from service " << cfg().uri << "; error: " << theOptions->error);
+               "from service " << cfg().uri << "; error: " << theOptions->error);
         return;
     }
 
@@ -290,7 +293,7 @@ void ICAPServiceRep::checkOptions()
         // TODO: If skew is negative, the option will be considered down
         // because of stale options. We should probably change this.
         debugs(93, 1, "ICAP service's clock is skewed by " << skew <<
-            " seconds: " << cfg().uri.buf());
+               " seconds: " << cfg().uri.buf());
     }
 }
 
@@ -301,9 +304,9 @@ void ICAPServiceRep::announceStatusChange(const char *downPhrase, bool important
 
     const char *what = cfg().bypass ? "optional" : "essential";
     const char *state = wasAnnouncedUp ? downPhrase : "up";
-    const int level = important ? 1 : 2;
+    const int level = important ? 1 :2;
     debugs(93,level, what << " ICAP service is " << state << ": " <<
-        cfg().uri << ' ' << status());
+           cfg().uri << ' ' << status());
 
     wasAnnouncedUp = !wasAnnouncedUp;
 }
@@ -320,16 +323,17 @@ void ICAPServiceRep::noteAdaptationAnswer(HttpMsg *msg)
 
     ICAPOptions *newOptions = NULL;
     if (HttpReply *r = dynamic_cast<HttpReply*>(msg)) {
-    	newOptions = new ICAPOptions;
-    	newOptions->configure(r);
+        newOptions = new ICAPOptions;
+        newOptions->configure(r);
     } else {
-    	debugs(93,1, "ICAPService got wrong options message " << status());
+        debugs(93,1, "ICAPService got wrong options message " << status());
     }
 
     handleNewOptions(newOptions);
 }
 
-void ICAPServiceRep::noteAdaptationQueryAbort(bool) {
+void ICAPServiceRep::noteAdaptationQueryAbort(bool)
+{
     Must(theOptionsFetcher);
     clearAdaptation(theOptionsFetcher);
 
@@ -374,9 +378,9 @@ void ICAPServiceRep::scheduleUpdate(time_t when)
     }
 
     debugs(93,7, HERE << "raw OPTIONS fetch at " << when << " or in " <<
-        (when - squid_curtime) << " sec");
+           (when - squid_curtime) << " sec");
     debugs(93,9, HERE << "last fetched at " << theLastUpdate << " or " <<
-        (squid_curtime - theLastUpdate) << " sec ago");
+           (squid_curtime - theLastUpdate) << " sec ago");
 
     /* adjust update time to prevent too-frequent updates */
 
@@ -423,7 +427,7 @@ ICAPServiceRep::optionsFetchTime() const
 
 Adaptation::Initiate *
 ICAPServiceRep::makeXactLauncher(Adaptation::Initiator *initiator,
-    HttpMsg *virgin, HttpRequest *cause)
+                                 HttpMsg *virgin, HttpRequest *cause)
 {
     return new ICAPModXactLauncher(initiator, virgin, cause, this);
 }
@@ -448,11 +452,11 @@ const char *ICAPServiceRep::status() const
         if (!theOptions)
             buf.append(",!opt", 5);
         else
-        if (!theOptions->valid())
-            buf.append(",!valid", 7);
-        else
-        if (!theOptions->fresh())
-            buf.append(",stale", 6);
+            if (!theOptions->valid())
+                buf.append(",!valid", 7);
+            else
+                if (!theOptions->fresh())
+                    buf.append(",stale", 6);
     }
 
     if (theOptionsFetcher)
@@ -19,12 +19,12 @@
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
- *  
+ *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
- *  
+ *
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
@@ -66,14 +66,14 @@ class ICAPOptXact;
  * eventually retry to fetch its options in hope to bring the service up.
  *
  * A service that should no longer be used after Squid reconfiguration is
- * treated as if it does not have a fresh cached OPTIONS response. We do 
- * not try to fetch fresh options for such a service. It should be 
+ * treated as if it does not have a fresh cached OPTIONS response. We do
+ * not try to fetch fresh options for such a service. It should be
  * auto-destroyed by refcounting when no longer used.
  */
 
 
 class ICAPServiceRep : public RefCountable, public Adaptation::Service,
-    public Adaptation::Initiator
+            public Adaptation::Initiator
 {
 
 public:
@@ -101,7 +101,7 @@ class ICAPServiceRep : public RefCountable, public Adaptation::Service,
     bool allows204() const;
 
     void noteFailure(); // called by transactions to report service failure
-    
+
     //AsyncJob virtual methods
     virtual bool doneAll() const { return Adaptation::Initiator::doneAll() && false;}
 
@@ -116,8 +116,7 @@ class ICAPServiceRep : public RefCountable, public Adaptation::Service,
 private:
     // stores Prepare() callback info
 
-    struct Client
-    {
+    struct Client {
         Pointer service; // one for each client to preserve service
         AsyncCall::Pointer callback;
     };
@@ -29,13 +29,13 @@ ICAPXaction::ICAPXaction(const char *aTypeName, Adaptation::Initiator *anInitiat
         connector(NULL), reader(NULL), writer(NULL), closer(NULL)
 {
     debugs(93,3, typeName << " constructed, this=" << this <<
-        " [icapx" << id << ']'); // we should not call virtual status() here
+           " [icapx" << id << ']'); // we should not call virtual status() here
 }
 
 ICAPXaction::~ICAPXaction()
 {
     debugs(93,3, typeName << " destructed, this=" << this <<
-        " [icapx" << id << ']'); // we should not call virtual status() here
+           " [icapx" << id << ']'); // we should not call virtual status() here
 }
 
 ICAPServiceRep &
@@ -46,9 +46,10 @@ ICAPXaction::service()
     return *s;
 }
 
-void ICAPXaction::disableRetries() {
+void ICAPXaction::disableRetries()
+{
     debugs(93,5, typeName << (isRetriable ? " becomes" : " remains") <<
-        " final" << status());
+           " final" << status());
     isRetriable = false;
 }
 
@@ -86,15 +87,15 @@ void ICAPXaction::openConnection()
         dialer.params.flag = COMM_OK;
         // fake other parameters by copying from the existing connection
         connector = asyncCall(93,3, "ICAPXaction::noteCommConnected", dialer);
-	    ScheduleCallHere(connector);
+        ScheduleCallHere(connector);
         return;
     }
 
     disableRetries(); // we only retry pconn failures
 
     IPAddress outgoing;
-    connection = comm_open(SOCK_STREAM, 0, outgoing, 
-        COMM_NONBLOCKING, s.cfg().uri.buf());
+    connection = comm_open(SOCK_STREAM, 0, outgoing,
+                           COMM_NONBLOCKING, s.cfg().uri.buf());
 
     if (connection < 0)
         dieOnConnectionFailure(); // throws
@@ -104,19 +105,19 @@ void ICAPXaction::openConnection()
     // TODO: service bypass status may differ from that of a transaction
     typedef CommCbMemFunT<ICAPXaction, CommTimeoutCbParams> TimeoutDialer;
     AsyncCall::Pointer timeoutCall =  asyncCall(93, 5, "ICAPXaction::noteCommTimedout",
-			TimeoutDialer(this,&ICAPXaction::noteCommTimedout));
+                                      TimeoutDialer(this,&ICAPXaction::noteCommTimedout));
 
     commSetTimeout(connection, TheICAPConfig.connect_timeout(
-        service().cfg().bypass), timeoutCall);
+                       service().cfg().bypass), timeoutCall);
 
     typedef CommCbMemFunT<ICAPXaction, CommCloseCbParams> CloseDialer;
     closer =  asyncCall(93, 5, "ICAPXaction::noteCommClosed",
-			CloseDialer(this,&ICAPXaction::noteCommClosed));
+                        CloseDialer(this,&ICAPXaction::noteCommClosed));
     comm_add_close_handler(connection, closer);
 
     typedef CommCbMemFunT<ICAPXaction, CommConnectCbParams> ConnectDialer;
     connector = asyncCall(93,3, "ICAPXaction::noteCommConnected",
-        ConnectDialer(this, &ICAPXaction::noteCommConnected));
+                          ConnectDialer(this, &ICAPXaction::noteCommConnected));
     commConnectStart(connection, s.cfg().host.buf(), s.cfg().port, connector);
 }
 
@@ -153,10 +154,10 @@ void ICAPXaction::closeConnection()
         if (reuseConnection) {
             IPAddress client_addr;
             debugs(93,3, HERE << "pushing pconn" << status());
-	    AsyncCall::Pointer call = NULL;
-	    commSetTimeout(connection, -1, call);
+            AsyncCall::Pointer call = NULL;
+            commSetTimeout(connection, -1, call);
             icapPconnPool->push(connection, theService->cfg().host.buf(),
-                theService->cfg().port, NULL, client_addr);
+                                theService->cfg().port, NULL, client_addr);
             disableRetries();
         } else {
             debugs(93,3, HERE << "closing pconn" << status());
@@ -185,9 +186,10 @@ void ICAPXaction::noteCommConnected(const CommConnectCbParams &io)
     handleCommConnected();
 }
 
-void ICAPXaction::dieOnConnectionFailure() {
+void ICAPXaction::dieOnConnectionFailure()
+{
     debugs(93, 2, HERE << typeName <<
-        " failed to connect to " << service().cfg().uri);
+           " failed to connect to " << service().cfg().uri);
     theService->noteFailure();
     throw TexcHere("cannot connect to the ICAP service");
 }
@@ -197,7 +199,7 @@ void ICAPXaction::scheduleWrite(MemBuf &buf)
     // comm module will free the buffer
     typedef CommCbMemFunT<ICAPXaction, CommIoCbParams> Dialer;
     writer = asyncCall(93,3, "ICAPXaction::noteCommWrote",
-		       Dialer(this, &ICAPXaction::noteCommWrote));
+                       Dialer(this, &ICAPXaction::noteCommWrote));
 
     comm_write_mbuf(connection, &buf, writer);
     updateTimeout();
@@ -207,10 +209,10 @@ void ICAPXaction::noteCommWrote(const CommIoCbParams &io)
 {
     Must(writer != NULL);
     writer = NULL;
-    
+
     if (ignoreLastWrite) {
         // a hack due to comm inability to cancel a pending write
-        ignoreLastWrite = false; 
+        ignoreLastWrite = false;
         debugs(93, 7, HERE << "ignoring last write; status: " << io.flag);
     } else {
         Must(io.flag == COMM_OK);
@@ -228,14 +230,14 @@ void ICAPXaction::noteCommTimedout(const CommTimeoutCbParams &io)
 void ICAPXaction::handleCommTimedout()
 {
     debugs(93, 2, HERE << typeName << " failed: timeout with " <<
-        theService->cfg().methodStr() << " " <<
-        theService->cfg().uri.buf() << status());
+           theService->cfg().methodStr() << " " <<
+           theService->cfg().uri.buf() << status());
     reuseConnection = false;
     service().noteFailure();
 
     throw TexcHere(connector != NULL ?
-        "timed out while connecting to the ICAP service" :
-        "timed out while talking to the ICAP service");
+                   "timed out while connecting to the ICAP service" :
+                   "timed out while talking to the ICAP service");
 }
 
 // unexpected connection close while talking to the ICAP service
@@ -264,21 +266,22 @@ bool ICAPXaction::doneAll() const
     return !connector && !reader && !writer && Adaptation::Initiate::doneAll();
 }
 
-void ICAPXaction::updateTimeout() {
+void ICAPXaction::updateTimeout()
+{
     if (reader != NULL || writer != NULL) {
         // restart the timeout before each I/O
         // XXX: why does Config.Timeout lacks a write timeout?
         // TODO: service bypass status may differ from that of a transaction
-	    typedef CommCbMemFunT<ICAPXaction, CommTimeoutCbParams> TimeoutDialer;
-	    AsyncCall::Pointer call =  asyncCall(93, 5, "ICAPXaction::noteCommTimedout",
-				    TimeoutDialer(this,&ICAPXaction::noteCommTimedout));
+        typedef CommCbMemFunT<ICAPXaction, CommTimeoutCbParams> TimeoutDialer;
+        AsyncCall::Pointer call =  asyncCall(93, 5, "ICAPXaction::noteCommTimedout",
+                                             TimeoutDialer(this,&ICAPXaction::noteCommTimedout));
 
-        commSetTimeout(connection, 
-            TheICAPConfig.io_timeout(service().cfg().bypass), call);
+        commSetTimeout(connection,
+                       TheICAPConfig.io_timeout(service().cfg().bypass), call);
     } else {
         // clear timeout when there is no I/O
         // Do we need a lifetime timeout?
-	AsyncCall::Pointer call = NULL;
+        AsyncCall::Pointer call = NULL;
         commSetTimeout(connection, -1, call);
     }
 }
@@ -295,7 +298,7 @@ void ICAPXaction::scheduleRead()
      */
     typedef CommCbMemFunT<ICAPXaction, CommIoCbParams> Dialer;
     reader = asyncCall(93,3, "ICAPXaction::noteCommRead",
-		       Dialer(this, &ICAPXaction::noteCommRead));
+                       Dialer(this, &ICAPXaction::noteCommRead));
 
     comm_read(connection, commBuf, readBuf.spaceSize(), reader);
     updateTimeout();
@@ -375,8 +378,8 @@ bool ICAPXaction::doneWriting() const
 bool ICAPXaction::doneWithIo() const
 {
     return connection >= 0 && // or we could still be waiting to open it
-        !connector && !reader && !writer && // fast checks, some redundant
-        doneReading() && doneWriting();
+           !connector && !reader && !writer && // fast checks, some redundant
+           doneReading() && doneWriting();
 }
 
 // initiator aborted
@@ -19,12 +19,12 @@
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
- *  
+ *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
- *  
+ *
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
@@ -99,7 +99,7 @@ class ICAPXaction: public Adaptation::Initiate
     virtual bool doneAll() const;
 
     // called just before the 'done' transaction is deleted
-    virtual void swanSong(); 
+    virtual void swanSong();
 
     // returns a temporary string depicting transaction status, for debugging
     virtual const char *status() const;
@@ -20,12 +20,12 @@
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
- *  
+ *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
- *  
+ *
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
@@ -51,9 +51,9 @@ extern void purgeEntriesByUrl(HttpRequest * req, const char *url);
 
 ServerStateData::ServerStateData(FwdState *theFwdState): AsyncJob("ServerStateData"),requestSender(NULL)
 #if USE_ADAPTATION
-    , adaptedHeadSource(NULL)
-    , adaptationAccessCheckPending(false)
-    , startedAdaptation(false)
+        , adaptedHeadSource(NULL)
+        , adaptationAccessCheckPending(false)
+        , startedAdaptation(false)
 #endif
 {
     fwd = theFwdState;
@@ -82,8 +82,8 @@ ServerStateData::~ServerStateData()
     fwd = NULL; // refcounted
 
     if (responseBodyBuffer != NULL) {
-	delete responseBodyBuffer;
-	responseBodyBuffer = NULL;
+        delete responseBodyBuffer;
+        responseBodyBuffer = NULL;
     }
 }
 
@@ -115,34 +115,39 @@ ServerStateData::swanSong()
 
 
 HttpReply *
-ServerStateData::virginReply() {
+ServerStateData::virginReply()
+{
     assert(theVirginReply);
     return theVirginReply;
 }
 
 const HttpReply *
-ServerStateData::virginReply() const {
+ServerStateData::virginReply() const
+{
     assert(theVirginReply);
     return theVirginReply;
 }
 
 HttpReply *
-ServerStateData::setVirginReply(HttpReply *rep) {
+ServerStateData::setVirginReply(HttpReply *rep)
+{
     debugs(11,5, HERE << this << " setting virgin reply to " << rep);
     assert(!theVirginReply);
     assert(rep);
     theVirginReply = HTTPMSGLOCK(rep);
-	return theVirginReply;
+    return theVirginReply;
 }
 
 HttpReply *
-ServerStateData::finalReply() {
+ServerStateData::finalReply()
+{
     assert(theFinalReply);
     return theFinalReply;
 }
 
 HttpReply *
-ServerStateData::setFinalReply(HttpReply *rep) {
+ServerStateData::setFinalReply(HttpReply *rep)
+{
     debugs(11,5, HERE << this << " setting final reply to " << rep);
 
     assert(!theFinalReply);
@@ -172,7 +177,7 @@ ServerStateData::serverComplete()
         stopConsumingFrom(requestBodySource);
 
     if (responseBodyBuffer != NULL)
-	return;
+        return;
 
     serverComplete2();
 }
@@ -194,10 +199,11 @@ ServerStateData::serverComplete2()
     quitIfAllDone();
 }
 
-// When we are done talking to the primary server, we may be still talking 
+// When we are done talking to the primary server, we may be still talking
 // to the ICAP service. And vice versa. Here, we quit only if we are done
 // talking to both.
-void ServerStateData::quitIfAllDone() {
+void ServerStateData::quitIfAllDone()
+{
 #if USE_ADAPTATION
     if (!doneWithAdaptation()) {
         debugs(11,5, HERE << "transaction not done: still talking to ICAP");
@@ -217,7 +223,8 @@ void ServerStateData::quitIfAllDone() {
 
 // FTP side overloads this to work around multiple calls to fwd->complete
 void
-ServerStateData::completeForwarding() {
+ServerStateData::completeForwarding()
+{
     debugs(11,5, HERE << "completing forwarding for "  << fwd);
     assert(fwd != NULL);
     fwd->complete();
@@ -231,12 +238,12 @@ bool ServerStateData::startRequestBodyFlow()
     requestBodySource = r->body_pipe;
     if (requestBodySource->setConsumerIfNotLate(this)) {
         debugs(11,3, HERE << "expecting request body from " <<
-            requestBodySource->status());
+               requestBodySource->status());
         return true;
     }
 
     debugs(11,3, HERE << "aborting on partially consumed request body: " <<
-        requestBodySource->status());
+           requestBodySource->status());
     requestBodySource = NULL;
     return false;
 }
@@ -315,7 +322,8 @@ ServerStateData::handleRequestBodyProductionEnded()
 
 // called when we are done sending request body; kids extend this
 void
-ServerStateData::doneSendingRequestBody() {
+ServerStateData::doneSendingRequestBody()
+{
     debugs(9,3, HERE << "done sending request body");
     assert(requestBodySource != NULL);
     stopConsumingFrom(requestBodySource);
@@ -388,9 +396,9 @@ ServerStateData::sendMoreRequestBody()
     MemBuf buf;
     if (requestBodySource->getMoreData(buf)) {
         debugs(9,3, HERE << "will write " << buf.contentSize() << " request body bytes");
-	typedef CommCbMemFunT<ServerStateData, CommIoCbParams> Dialer;
-	requestSender = asyncCall(93,3, "ServerStateData::sentRequestBody",
-				  Dialer(this, &ServerStateData::sentRequestBody));
+        typedef CommCbMemFunT<ServerStateData, CommIoCbParams> Dialer;
+        requestSender = asyncCall(93,3, "ServerStateData::sentRequestBody",
+                                  Dialer(this, &ServerStateData::sentRequestBody));
         comm_write_mbuf(dataDescriptor(), &buf, requestSender);
     } else {
         debugs(9,3, HERE << "will wait for more request body bytes or eof");
@@ -432,13 +440,13 @@ static void
 purgeEntriesByHeader(HttpRequest *req, const char *reqUrl, HttpMsg *rep, http_hdr_type hdr)
 {
     const char *hdrUrl, *absUrl;
-    
+
     absUrl = NULL;
     hdrUrl = rep->header.getStr(hdr);
     if (hdrUrl == NULL) {
         return;
     }
-    
+
     /*
      * If the URL is relative, make it absolute so we can find it.
      * If it's absolute, make sure the host parts match to avoid DOS attacks
@@ -452,9 +460,9 @@ purgeEntriesByHeader(HttpRequest *req, const char *reqUrl, HttpMsg *rep, http_hd
     } else if (!sameUrlHosts(reqUrl, hdrUrl)) {
         return;
     }
-    
+
     purgeEntriesByUrl(req, hdrUrl);
-    
+
     if (absUrl != NULL) {
         safe_free(absUrl);
     }
@@ -464,28 +472,28 @@ purgeEntriesByHeader(HttpRequest *req, const char *reqUrl, HttpMsg *rep, http_hd
 void
 ServerStateData::maybePurgeOthers()
 {
-   // only some HTTP methods should purge matching cache entries
-   if (!request->method.purgesOthers())
-       return;
+    // only some HTTP methods should purge matching cache entries
+    if (!request->method.purgesOthers())
+        return;
 
-   // and probably only if the response was successful
-   if (theFinalReply->sline.status >= 400)
-       return;
+    // and probably only if the response was successful
+    if (theFinalReply->sline.status >= 400)
+        return;
 
-   // XXX: should we use originalRequest() here?
-   const char *reqUrl = urlCanonical(request);
-   debugs(88, 5, "maybe purging due to " << RequestMethodStr(request->method) << ' ' << reqUrl);
-   purgeEntriesByUrl(request, reqUrl);
-   purgeEntriesByHeader(request, reqUrl, theFinalReply, HDR_LOCATION);
-   purgeEntriesByHeader(request, reqUrl, theFinalReply, HDR_CONTENT_LOCATION);
+    // XXX: should we use originalRequest() here?
+    const char *reqUrl = urlCanonical(request);
+    debugs(88, 5, "maybe purging due to " << RequestMethodStr(request->method) << ' ' << reqUrl);
+    purgeEntriesByUrl(request, reqUrl);
+    purgeEntriesByHeader(request, reqUrl, theFinalReply, HDR_LOCATION);
+    purgeEntriesByHeader(request, reqUrl, theFinalReply, HDR_CONTENT_LOCATION);
 }
 
 // called (usually by kids) when we have final (possibly adapted) reply headers
 void
 ServerStateData::haveParsedReplyHeaders()
 {
-   Must(theFinalReply);
-   maybePurgeOthers();
+    Must(theFinalReply);
+    maybePurgeOthers();
 }
 
 HttpRequest *
@@ -516,26 +524,27 @@ ServerStateData::startAdaptation(Adaptation::ServicePointer service, HttpRequest
     // check whether we should be sending a body as well
     // start body pipe to feed ICAP transaction if needed
     assert(!virginBodyDestination);
-        HttpReply *vrep = virginReply();
+    HttpReply *vrep = virginReply();
     assert(!vrep->body_pipe);
     int64_t size = 0;
     if (vrep->expectingBody(cause->method, size) && size) {
         virginBodyDestination = new BodyPipe(this);
         vrep->body_pipe = virginBodyDestination;
-        debugs(93, 6, HERE << "will send virgin reply body to " << 
-            virginBodyDestination << "; size: " << size);
+        debugs(93, 6, HERE << "will send virgin reply body to " <<
+               virginBodyDestination << "; size: " << size);
         if (size > 0)
             virginBodyDestination->setBodySize(size);
     }
 
     adaptedHeadSource = initiateAdaptation(service->makeXactLauncher(
-        this, vrep, cause));
+                                               this, vrep, cause));
     return adaptedHeadSource != NULL;
 }
 
 // properly cleans up ICAP-related state
 // may be called multiple times
-void ServerStateData::cleanAdaptation() {
+void ServerStateData::cleanAdaptation()
+{
     debugs(11,5, HERE << "cleaning ICAP; ACL: " << adaptationAccessCheckPending);
 
     if (virginBodyDestination != NULL)
@@ -551,9 +560,10 @@ void ServerStateData::cleanAdaptation() {
 }
 
 bool
-ServerStateData::doneWithAdaptation() const {
+ServerStateData::doneWithAdaptation() const
+{
     return !adaptationAccessCheckPending &&
-        !virginBodyDestination && !adaptedHeadSource && !adaptedBodySource;
+           !virginBodyDestination && !adaptedHeadSource && !adaptedBodySource;
 }
 
 // sends virgin reply body to ICAP, buffering excesses if needed
@@ -585,7 +595,7 @@ ServerStateData::adaptVirginReplyBody(const char *data, ssize_t len)
             responseBodyBuffer = NULL;
         } else {
             responseBodyBuffer->consume(putSize);
-		}
+        }
         return;
     }
 
@@ -723,7 +733,7 @@ void
 ServerStateData::handleAdaptationAborted(bool bypassable)
 {
     debugs(11,5, HERE << "handleAdaptationAborted; bypassable: " << bypassable <<
-        ", entry empty: " << entry->isEmpty());
+           ", entry empty: " << entry->isEmpty());
 
     if (abortOnBadEntry("entry went bad while ICAP aborted"))
         return;
@@ -770,7 +780,7 @@ ServerStateData::adaptationAclCheckDone(Adaptation::ServicePointer service)
     if (!startedAdaptation) {
         // handle start failure for an essential ICAP service
         ErrorState *err = errorCon(ERR_ICAP_FAILURE,
-            HTTP_INTERNAL_SERVER_ERROR, originalRequest());
+                                   HTTP_INTERNAL_SERVER_ERROR, originalRequest());
         err->xerrno = errno;
         errorAppendEntry(entry, err);
         abortTransaction("ICAP start failure");
@@ -798,7 +808,7 @@ ServerStateData::sendBodyIsTooLargeError()
     abortTransaction("Virgin body too large.");
 }
 
-// TODO: when HttpStateData sends all errors to ICAP, 
+// TODO: when HttpStateData sends all errors to ICAP,
 // we should be able to move this at the end of setVirginReply().
 void
 ServerStateData::adaptOrFinalizeReply()
@@ -807,8 +817,8 @@ ServerStateData::adaptOrFinalizeReply()
     // TODO: merge with client side and return void to hide the on/off logic?
     // The callback can be called with a NULL service if adaptation is off.
     adaptationAccessCheckPending = Adaptation::AccessCheck::Start(
-        Adaptation::methodRespmod, Adaptation::pointPreCache,
-        request, virginReply(), adaptationAclCheckDoneWrapper, this);
+                                       Adaptation::methodRespmod, Adaptation::pointPreCache,
+                                       request, virginReply(), adaptationAclCheckDoneWrapper, this);
     if (adaptationAccessCheckPending)
         return;
 #endif
@@ -843,7 +853,7 @@ size_t ServerStateData::replyBodySpace(size_t space)
 {
 #if USE_ADAPTATION
     if (responseBodyBuffer) {
-	return 0;	// Stop reading if already overflowed waiting for ICAP to catch up
+        return 0;	// Stop reading if already overflowed waiting for ICAP to catch up
     }
 
     if (virginBodyDestination != NULL) {
@@ -863,7 +873,7 @@ size_t ServerStateData::replyBodySpace(size_t space)
             virginBodyDestination->buf().potentialSpaceSize();
 
         debugs(11,9, "ServerStateData may read up to min(" <<
-            adaptation_space << ", " << space << ") bytes");
+               adaptation_space << ", " << space << ") bytes");
 
         if (adaptation_space < space)
             space = adaptation_space;
@@ -20,12 +20,12 @@
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
- *  
+ *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
- *  
+ *
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
@@ -56,18 +56,18 @@
  */
 class ServerStateData:
 #if USE_ADAPTATION
-    public Adaptation::Initiator,
-    public BodyProducer,
+            public Adaptation::Initiator,
+            public BodyProducer,
 #endif
-    public BodyConsumer
+            public BodyConsumer
 {
 
 public:
     ServerStateData(FwdState *);
     virtual ~ServerStateData();
 
     /// \return primary or "request data connection" fd
-    virtual int dataDescriptor() const = 0; 
+    virtual int dataDescriptor() const = 0;
 
     // BodyConsumer: consume request body or adapted response body.
     // The implementation just calls the corresponding HTTP or ICAP handle*()
@@ -101,12 +101,14 @@ class ServerStateData:
 
 //AsyncJob virtual methods
     virtual void swanSong();
-    virtual bool doneAll() const { return
+    virtual bool doneAll() const {
+        return
 #if USE_ADAPTATION
-                       Adaptation::Initiator::doneAll() &&
-				       BodyProducer::doneAll() &&
+            Adaptation::Initiator::doneAll() &&
+            BodyProducer::doneAll() &&
 #endif
-				       BodyConsumer::doneAll() && false;}
+            BodyConsumer::doneAll() && false;
+    }
 
 public: // should be protected
     void serverComplete();     /**< call when no server communication is expected */
@@ -46,8 +46,7 @@ class StoreIOBuffer
     StoreIOBuffer():length(0), offset (0), data (NULL) {flags.error = 0;}
 
     StoreIOBuffer(size_t aLength, int64_t anOffset, char *someData) :
-            length (aLength), offset (anOffset), data (someData)
-    {
+            length (aLength), offset (anOffset), data (someData) {
         flags.error = 0;
     }
 
@@ -20,12 +20,12 @@
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
- *  
+ *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
- *  
+ *
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
@@ -43,16 +43,16 @@
  * of client_side_reply.c.
  * Problem the second: resources are wasted if we delay in cleaning up.
  * Problem the third we can't depend on a connection close to clean up.
- * 
+ *
  \par Nice thing the first:
- * Any step in the stream can callback with data 
+ * Any step in the stream can callback with data
  * representing an error.
  * Nice thing the second: once you stop requesting reads from upstream,
  * upstream can be stopped too.
  *
  \par Solution #1:
  * Error has a callback mechanism to hand over a membuf
- * with the error content. The failing node pushes that back as the 
+ * with the error content. The failing node pushes that back as the
  * reply. Can this be generalised to reduce duplicate efforts?
  * A: Possibly. For now, only one location uses this.
  * How to deal with pre-stream errors?
@@ -65,19 +65,19 @@
  \par
  * requests (httpClientRequest structs) get added to the connection
  * list, with the current one being chr
- * 
+ *
  \par
  * The request is *immediately* kicked off, and data flows through
  * to clientSocketRecipient.
- * 
+ *
  \par
  * If the data that arrives at clientSocketRecipient is not for the current
  * request, clientSocketRecipient simply returns, without requesting more
  * data, or sending it.
  *
  \par
- * ClientKeepAliveNextRequest will then detect the presence of data in 
- * the next ClientHttpRequest, and will send it, restablishing the 
+ * ClientKeepAliveNextRequest will then detect the presence of data in
+ * the next ClientHttpRequest, and will send it, restablishing the
  * data flow.
  */
 
@@ -473,7 +473,7 @@ clientPrepareLogWithRequestDetails(HttpRequest * request, AccessLogEntry * aLogE
             aLogEntry->cache.authuser =
                 xstrdup(request->auth_user_request->username());
 
-	AUTHUSERREQUESTUNLOCK(request->auth_user_request, "request via clientPrepareLogWithRequestDetails");
+        AUTHUSERREQUESTUNLOCK(request->auth_user_request, "request via clientPrepareLogWithRequestDetails");
     }
 }
 
@@ -500,7 +500,7 @@ ClientHttpRequest::logRequest()
 
         al.cache.caddr.SetNoAddr();
 
-        if(getConn() != NULL) al.cache.caddr = getConn()->log_addr;
+        if (getConn() != NULL) al.cache.caddr = getConn()->log_addr;
 
         al.cache.requestSize = req_sz;
 
@@ -520,9 +520,9 @@ ClientHttpRequest::logRequest()
 
 #if USE_SSL && 0
 
-	/* This is broken. Fails if the connection has been closed. Needs
-	 * to snarf the ssl details some place earlier..
-	 */
+        /* This is broken. Fails if the connection has been closed. Needs
+         * to snarf the ssl details some place earlier..
+         */
         if (getConn() != NULL)
             al.cache.ssluser = sslGetUserEmail(fd_table[getConn()->fd].ssl);
 
@@ -622,7 +622,7 @@ ConnStateData::swanSong()
     }
 
     if (pinning.fd >= 0)
-	comm_close(pinning.fd);
+        comm_close(pinning.fd);
 
     BodyProducer::swanSong();
     flags.swanSang = true;
@@ -632,8 +632,8 @@ bool
 ConnStateData::isOpen() const
 {
     return cbdataReferenceValid(this) && // XXX: checking "this" in a method
-        fd >= 0 &&
-        !fd_table[fd].closing();
+           fd >= 0 &&
+           !fd_table[fd].closing();
 }
 
 ConnStateData::~ConnStateData()
@@ -829,21 +829,21 @@ ClientSocketContext::sendBody(HttpReply * rep, StoreIOBuffer bodyData)
     if (!multipartRangeRequest()) {
         size_t length = lengthToSend(bodyData.range());
         noteSentBodyBytes (length);
-	AsyncCall::Pointer call = commCbCall(33, 5, "clientWriteBodyComplete", 
-					     CommIoCbPtrFun(clientWriteBodyComplete, this));
-	comm_write(fd(), bodyData.data, length, call );
+        AsyncCall::Pointer call = commCbCall(33, 5, "clientWriteBodyComplete",
+                                             CommIoCbPtrFun(clientWriteBodyComplete, this));
+        comm_write(fd(), bodyData.data, length, call );
         return;
     }
 
     MemBuf mb;
     mb.init();
     packRange(bodyData, &mb);
 
-    if (mb.contentSize()){
+    if (mb.contentSize()) {
         /* write */
-	AsyncCall::Pointer call = commCbCall(33, 5, "clientWriteComplete", 
-					     CommIoCbPtrFun(clientWriteComplete, this));
-	comm_write_mbuf(fd(), &mb, call);
+        AsyncCall::Pointer call = commCbCall(33, 5, "clientWriteComplete",
+                                             CommIoCbPtrFun(clientWriteComplete, this));
+        comm_write_mbuf(fd(), &mb, call);
     }  else
         writeComplete(fd(), NULL, 0, COMM_OK);
 }
@@ -1096,7 +1096,7 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
         range_err = "INCONSISTENT length";	/* a bug? */
 
     /* hits only - upstream peer determines correct behaviour on misses, and client_side_reply determines
-     * hits candidates 
+     * hits candidates
      */
     else if (logTypeIsATcpHit(http->logType) && http->request->header.has(HDR_IF_RANGE) && !clientIfRangeMatch(http, rep))
         range_err = "If-Range match failed";
@@ -1110,7 +1110,7 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
     /* get rid of our range specs on error */
     if (range_err) {
         /* XXX We do this here because we need canonisation etc. However, this current
-         * code will lead to incorrect store offset requests - the store will have the 
+         * code will lead to incorrect store offset requests - the store will have the
          * offset data, but we won't be requesting it.
          * So, we can either re-request, or generate an error
          */
@@ -1131,7 +1131,7 @@ ClientSocketContext::buildRangeHeader(HttpReply * rep)
         int64_t actual_clen = -1;
 
         debugs(33, 3, "clientBuildRangeHeader: range spec count: " <<
-	    spec_count << " virgin clen: " << rep->content_length);
+               spec_count << " virgin clen: " << rep->content_length);
         assert(spec_count > 0);
         /* ETags should not be returned with Partial Content replies? */
         hdr->delById(HDR_ETAG);
@@ -1227,8 +1227,8 @@ ClientSocketContext::sendStartOfMessage(HttpReply * rep, StoreIOBuffer bodyData)
 
     /* write */
     debugs(33,7, HERE << "sendStartOfMessage schedules clientWriteComplete");
-    AsyncCall::Pointer call = commCbCall(33, 5, "clientWriteComplete", 
-					 CommIoCbPtrFun(clientWriteComplete, this));
+    AsyncCall::Pointer call = commCbCall(33, 5, "clientWriteComplete",
+                                         CommIoCbPtrFun(clientWriteComplete, this));
     comm_write_mbuf(fd(), mb, call);
 
     delete mb;
@@ -1238,7 +1238,7 @@ ClientSocketContext::sendStartOfMessage(HttpReply * rep, StoreIOBuffer bodyData)
  * Write a chunk of data to a client socket. If the reply is present,
  * send the reply headers down the wire too, and clean them up when
  * finished.
- * Pre-condition: 
+ * Pre-condition:
  *   The request is one backed by a connection, not an internal request.
  *   data context is not NULL
  *   There are no more entries in the stream chain.
@@ -1252,9 +1252,9 @@ clientSocketRecipient(clientStreamNode * node, ClientHttpRequest * http,
     assert(node != NULL);
     PROF_start(clientSocketRecipient);
     /* TODO: handle this rather than asserting
-     * - it should only ever happen if we cause an abort and 
-     * the callback chain loops back to here, so we can simply return. 
-     * However, that itself shouldn't happen, so it stays as an assert for now. 
+     * - it should only ever happen if we cause an abort and
+     * the callback chain loops back to here, so we can simply return.
+     * However, that itself shouldn't happen, so it stays as an assert for now.
      */
     assert(cbdataReferenceValid(node));
     assert(node->node.next == NULL);
@@ -1298,8 +1298,8 @@ clientSocketDetach(clientStreamNode * node, ClientHttpRequest * http)
     /* Test preconditions */
     assert(node != NULL);
     /* TODO: handle this rather than asserting
-     * - it should only ever happen if we cause an abort and 
-     * the callback chain loops back to here, so we can simply return. 
+     * - it should only ever happen if we cause an abort and
+     * the callback chain loops back to here, so we can simply return.
      * However, that itself shouldn't happen, so it stays as an assert for now.
      */
     assert(cbdataReferenceValid(node));
@@ -1331,7 +1331,7 @@ ConnStateData::readNextRequest()
      */
     typedef CommCbMemFunT<ConnStateData, CommTimeoutCbParams> TimeoutDialer;
     AsyncCall::Pointer timeoutCall =  asyncCall(33, 5, "ConnStateData::requestTimeout",
-		 TimeoutDialer(this, &ConnStateData::requestTimeout));
+                                      TimeoutDialer(this, &ConnStateData::requestTimeout));
     commSetTimeout(fd, Config.Timeout.persistent_request, timeoutCall);
 
     readSomeData();
@@ -1438,7 +1438,7 @@ clientUpdateSocketStats(log_type logType, size_t size)
  * used by clientPackMoreRanges
  *
  \retval true    there is still data available to pack more ranges
- \retval false   
+ \retval false
  */
 bool
 ClientSocketContext::canPackMoreRanges() const
@@ -1478,12 +1478,12 @@ ClientSocketContext::getNextRangeOffset() const
             start = http->range_iter.currentSpec()->offset + http->range_iter.currentSpec()->length - http->range_iter.debt();
             debugs(33, 3, "clientPackMoreRanges: in:  offset: " << http->out.offset);
             debugs(33, 3, "clientPackMoreRanges: out:"
-		" start: " << start <<
-		" spec[" << http->range_iter.pos - http->request->range->begin() << "]:" <<
-		" [" << http->range_iter.currentSpec()->offset <<
-		", " << http->range_iter.currentSpec()->offset + http->range_iter.currentSpec()->length << "),"
-		" len: " << http->range_iter.currentSpec()->length << 
-		" debt: " << http->range_iter.debt());
+                   " start: " << start <<
+                   " spec[" << http->range_iter.pos - http->request->range->begin() << "]:" <<
+                   " [" << http->range_iter.currentSpec()->offset <<
+                   ", " << http->range_iter.currentSpec()->offset + http->range_iter.currentSpec()->length << "),"
+                   " len: " << http->range_iter.currentSpec()->length <<
+                   " debt: " << http->range_iter.debt());
             if (http->range_iter.currentSpec()->length != -1)
                 assert(http->out.offset <= start);	/* we did not miss it */
 
@@ -1505,7 +1505,7 @@ void
 ClientSocketContext::pullData()
 {
     debugs(33, 5, "ClientSocketContext::pullData: FD " << fd() <<
-        " attempting to pull upstream data");
+           " attempting to pull upstream data");
 
     /* More data will be coming from the stream. */
     StoreIOBuffer readBuffer;
@@ -1533,7 +1533,7 @@ ClientSocketContext::socketState()
 
             if (!canPackMoreRanges()) {
                 debugs(33, 5, HERE << "Range request at end of returnable " <<
-                    "range sequence on FD " << fd());
+                       "range sequence on FD " << fd());
 
                 if (http->request->flags.proxy_keepalive)
                     return STREAM_COMPLETE;
@@ -1546,8 +1546,8 @@ ClientSocketContext::socketState()
             const int64_t &bytesExpected = reply->content_range->spec.length;
 
             debugs(33, 7, HERE << "body bytes sent vs. expected: " <<
-                bytesSent << " ? " << bytesExpected << " (+" <<
-                reply->content_range->spec.offset << ")");
+                   bytesSent << " ? " << bytesExpected << " (+" <<
+                   reply->content_range->spec.offset << ")");
 
             // did we get at least what we expected, based on range specs?
 
@@ -1809,7 +1809,7 @@ prepareAcceleratedURL(ConnStateData * conn, ClientHttpRequest *http, char *url,
                      strlen(host);
         http->uri = (char *)xcalloc(url_sz, 1);
         const char *protocol = switchedToHttps ?
-            "https" : conn->port->protocol;
+                               "https" : conn->port->protocol;
         snprintf(http->uri, url_sz, "%s://%s%s", protocol, host, url);
         debugs(33, 5, "ACCEL VHOST REWRITE: '" << http->uri << "'");
     } else if (conn->port->defaultsite) {
@@ -1872,7 +1872,7 @@ prepareTransparentURL(ConnStateData * conn, ClientHttpRequest *http, char *url,
 
 /**
  *  parseHttpRequest()
- * 
+ *
  *  Returns
  *  NULL on incomplete requests
  *  a ClientSocketContext structure on success or failure.
@@ -2142,7 +2142,7 @@ connNoteUseOfBuffer(ConnStateData* conn, size_t byteCount)
     conn->in.notYetUsed -= byteCount;
     debugs(33, 5, HERE << "conn->in.notYetUsed = " << conn->in.notYetUsed);
     /*
-     * If there is still data that will be used, 
+     * If there is still data that will be used,
      * move it to the beginning.
      */
 
@@ -2260,10 +2260,10 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
      * If transparent or interception mode is working clone the transparent and interception flags
      * from the port settings to the request.
      */
-    if(IPInterceptor.InterceptActive()) {
+    if (IPInterceptor.InterceptActive()) {
         request->flags.intercepted = http->flags.intercepted;
     }
-    if(IPInterceptor.TransparentActive()) {
+    if (IPInterceptor.TransparentActive()) {
         request->flags.spoof_client_ip = conn->port->spoof_client_ip;
     }
 
@@ -2361,7 +2361,7 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
     http->calloutContext = new ClientRequestContext(http);
 
     http->doCallouts();
-    
+
 finish:
     if (!notedUseOfBuffer)
         connNoteUseOfBuffer(conn, http->req_sz);
@@ -2374,10 +2374,10 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
      * assertion, not to mention that we were accessing freed memory.
      */
     if (http->request->flags.resetTCP() && conn->fd > -1) {
-	debugs(33, 3, HERE << "Sending TCP RST on FD " << conn->fd);
-	conn->flags.readMoreRequests = false;
-	comm_reset_close(conn->fd);
-	return;
+        debugs(33, 3, HERE << "Sending TCP RST on FD " << conn->fd);
+        conn->flags.readMoreRequests = false;
+        comm_reset_close(conn->fd);
+        return;
     }
 }
 
@@ -2541,9 +2541,9 @@ ConnStateData::clientReadRequest(const CommIoCbParams &io)
 
             handleReadData(io.buf, io.size);
 
-	    /* The above may close the connection under our feets */
-	    if (!isOpen())
-		return;
+            /* The above may close the connection under our feets */
+            if (!isOpen())
+                return;
 
         } else if (io.size == 0) {
             debugs(33, 5, "clientReadRequest: FD " << fd << " closed?");
@@ -2575,8 +2575,8 @@ ConnStateData::clientReadRequest(const CommIoCbParams &io)
         fd_note(fd, "Reading next request");
 
     if (! clientParseRequest(this, do_next_read)) {
-	if (!isOpen())
-	    return;
+        if (!isOpen())
+            return;
         /*
          * If the client here is half closed and we failed
          * to parse a request, close the connection.
@@ -2711,10 +2711,10 @@ ConnStateData::requestTimeout(const CommTimeoutCbParams &io)
         /*
          * if we don't close() here, we still need a timeout handler!
          */
-	typedef CommCbMemFunT<ConnStateData, CommTimeoutCbParams> TimeoutDialer;
-	AsyncCall::Pointer timeoutCall =  asyncCall(33, 5, "ConnStateData::requestTimeout",
-                        TimeoutDialer(this,&ConnStateData::requestTimeout));
-	commSetTimeout(io.fd, 30, timeoutCall);
+        typedef CommCbMemFunT<ConnStateData, CommTimeoutCbParams> TimeoutDialer;
+        AsyncCall::Pointer timeoutCall =  asyncCall(33, 5, "ConnStateData::requestTimeout",
+                                          TimeoutDialer(this,&ConnStateData::requestTimeout));
+        commSetTimeout(io.fd, 30, timeoutCall);
 
         /*
          * Aha, but we don't want a read handler!
@@ -2778,7 +2778,7 @@ connStateCreate(const IPAddress &peer, const IPAddress &me, int fd, http_port_li
     result->in.buf = (char *)memAllocBuf(CLIENT_REQ_BUF_SZ, &result->in.allocatedSize);
     result->port = cbdataReference(port);
 
-    if(port->intercepted || port->spoof_client_ip) {
+    if (port->intercepted || port->spoof_client_ip) {
         IPAddress client, dst;
 
         if (IPInterceptor.NatLookup(fd, me, peer, client, dst) == 0) {
@@ -2789,8 +2789,7 @@ connStateCreate(const IPAddress &peer, const IPAddress &me, int fd, http_port_li
     }
 
     if (port->disable_pmtu_discovery != DISABLE_PMTU_OFF &&
-            (result->transparent() || port->disable_pmtu_discovery == DISABLE_PMTU_ALWAYS))
-    {
+            (result->transparent() || port->disable_pmtu_discovery == DISABLE_PMTU_ALWAYS)) {
 #if defined(IP_MTU_DISCOVER) && defined(IP_PMTUDISC_DONT)
         int i = IP_PMTUDISC_DONT;
         setsockopt(fd, SOL_IP, IP_MTU_DISCOVER, &i, sizeof i);
@@ -2841,16 +2840,16 @@ httpAccept(int sock, int newfd, ConnectionDetail *details,
 
     typedef CommCbMemFunT<ConnStateData, CommCloseCbParams> Dialer;
     AsyncCall::Pointer call = asyncCall(33, 5, "ConnStateData::connStateClosed",
-                                 Dialer(connState, &ConnStateData::connStateClosed));
+                                        Dialer(connState, &ConnStateData::connStateClosed));
     comm_add_close_handler(newfd, call);
 
     if (Config.onoff.log_fqdn)
         fqdncache_gethostbyaddr(details->peer, FQDN_LOOKUP_IF_MISS);
 
-	typedef CommCbMemFunT<ConnStateData, CommTimeoutCbParams> TimeoutDialer;
-	AsyncCall::Pointer timeoutCall =  asyncCall(33, 5, "ConnStateData::requestTimeout",
-                        TimeoutDialer(connState,&ConnStateData::requestTimeout));
-	commSetTimeout(newfd, Config.Timeout.read, timeoutCall);
+    typedef CommCbMemFunT<ConnStateData, CommTimeoutCbParams> TimeoutDialer;
+    AsyncCall::Pointer timeoutCall =  asyncCall(33, 5, "ConnStateData::requestTimeout",
+                                      TimeoutDialer(connState,&ConnStateData::requestTimeout));
+    commSetTimeout(newfd, Config.Timeout.read, timeoutCall);
 
 #if USE_IDENT
 
@@ -2870,7 +2869,7 @@ httpAccept(int sock, int newfd, ConnectionDetail *details,
 #endif
 
     if (s->tcp_keepalive.enabled) {
-	commSetTcpKeepalive(newfd, s->tcp_keepalive.idle, s->tcp_keepalive.interval, s->tcp_keepalive.timeout);
+        commSetTcpKeepalive(newfd, s->tcp_keepalive.idle, s->tcp_keepalive.interval, s->tcp_keepalive.timeout);
     }
 
     connState->readSomeData();
@@ -2940,7 +2939,7 @@ clientNegotiateSSL(int fd, void *data)
                 if (errno == ECONNRESET)
                     hard = 0;
 
-                debugs(83, hard ? 1 : 2, "clientNegotiateSSL: Error negotiating SSL connection on FD " << 
+                debugs(83, hard ? 1 : 2, "clientNegotiateSSL: Error negotiating SSL connection on FD " <<
                        fd << ": " << strerror(errno) << " (" << errno << ")");
 
                 comm_close(fd);
@@ -2954,9 +2953,9 @@ clientNegotiateSSL(int fd, void *data)
             return;
 
         default:
-             debugs(83, 1, "clientNegotiateSSL: Error negotiating SSL connection on FD " << 
-                    fd << ": " << ERR_error_string(ERR_get_error(), NULL) << 
-                    " (" << ssl_error << "/" << ret << ")");
+            debugs(83, 1, "clientNegotiateSSL: Error negotiating SSL connection on FD " <<
+                   fd << ": " << ERR_error_string(ERR_get_error(), NULL) <<
+                   " (" << ssl_error << "/" << ret << ")");
             comm_close(fd);
             return;
         }
@@ -3056,19 +3055,19 @@ httpsAccept(int sock, int newfd, ConnectionDetail *details,
     debugs(33, 5, "httpsAccept: FD " << newfd << " accepted, starting SSL negotiation.");
     fd_note(newfd, "client https connect");
     ConnStateData *connState = connStateCreate(details->peer, details->me,
-        newfd, &s->http);
+                               newfd, &s->http);
     typedef CommCbMemFunT<ConnStateData, CommCloseCbParams> Dialer;
     AsyncCall::Pointer call = asyncCall(33, 5, "ConnStateData::connStateClosed",
-                                 Dialer(connState, &ConnStateData::connStateClosed));
+                                        Dialer(connState, &ConnStateData::connStateClosed));
     comm_add_close_handler(newfd, call);
 
     if (Config.onoff.log_fqdn)
         fqdncache_gethostbyaddr(details->peer, FQDN_LOOKUP_IF_MISS);
 
-	typedef CommCbMemFunT<ConnStateData, CommTimeoutCbParams> TimeoutDialer;
-	AsyncCall::Pointer timeoutCall =  asyncCall(33, 5, "ConnStateData::requestTimeout",
-                        TimeoutDialer(connState,&ConnStateData::requestTimeout));
-	commSetTimeout(newfd, Config.Timeout.request, timeoutCall);
+    typedef CommCbMemFunT<ConnStateData, CommTimeoutCbParams> TimeoutDialer;
+    AsyncCall::Pointer timeoutCall =  asyncCall(33, 5, "ConnStateData::requestTimeout",
+                                      TimeoutDialer(connState,&ConnStateData::requestTimeout));
+    commSetTimeout(newfd, Config.Timeout.request, timeoutCall);
 
 #if USE_IDENT
 
@@ -3088,7 +3087,7 @@ httpsAccept(int sock, int newfd, ConnectionDetail *details,
 #endif
 
     if (s->http.tcp_keepalive.enabled) {
-	commSetTcpKeepalive(newfd, s->http.tcp_keepalive.idle, s->http.tcp_keepalive.interval, s->http.tcp_keepalive.timeout);
+        commSetTcpKeepalive(newfd, s->http.tcp_keepalive.idle, s->http.tcp_keepalive.interval, s->http.tcp_keepalive.timeout);
     }
 
     commSetSelect(newfd, COMM_SELECT_READ, clientNegotiateSSL, connState, 0);
@@ -3162,7 +3161,7 @@ clientHttpConnectionsOpen(void)
 
         enter_suid();
 
-        if(s->spoof_client_ip) {
+        if (s->spoof_client_ip) {
             fd = comm_openex(SOCK_STREAM, IPPROTO_TCP, s->s, (COMM_NONBLOCKING|COMM_TRANSPARENT), 0, "HTTP Socket");
         } else {
             fd = comm_open(SOCK_STREAM, IPPROTO_TCP, s->s, COMM_NONBLOCKING, "HTTP Socket");
@@ -3181,7 +3180,7 @@ clientHttpConnectionsOpen(void)
                (s->intercepted ? " intercepted" : "") <<
                (s->spoof_client_ip ? " spoofing" : "") <<
                (s->sslBump ? " bumpy" : "") <<
-               (s->accel ? " accelerated" : "") 
+               (s->accel ? " accelerated" : "")
                << " HTTP connections at " << s->s
                << ", FD " << fd << "." );
 
@@ -3191,8 +3190,8 @@ clientHttpConnectionsOpen(void)
 #if USE_SSL
     if (bumpCount && !Config.accessList.ssl_bump)
         debugs(33, 1, "WARNING: http_port(s) with SslBump found, but no " <<
-            std::endl << "\tssl_bump ACL configured. No requests will be " <<
-            "bumped.");
+               std::endl << "\tssl_bump ACL configured. No requests will be " <<
+               "bumped.");
 #endif
 }
 
@@ -3282,8 +3281,8 @@ varyEvaluateMatch(StoreEntry * entry, HttpRequest * request)
     if (!has_vary || !entry->mem_obj->vary_headers) {
         if (vary) {
             /* Oops... something odd is going on here.. */
-             debugs(33, 1, "varyEvaluateMatch: Oops. Not a Vary object on second attempt, '" << 
-                    entry->mem_obj->url << "' '" << vary << "'");
+            debugs(33, 1, "varyEvaluateMatch: Oops. Not a Vary object on second attempt, '" <<
+                   entry->mem_obj->url << "' '" << vary << "'");
             safe_free(request->vary_headers);
             return VARY_CANCEL;
         }
@@ -3325,7 +3324,7 @@ varyEvaluateMatch(StoreEntry * entry, HttpRequest * request)
              * found the requested variant. Bail out
              */
             debugs(33, 1, "varyEvaluateMatch: Oops. Not a Vary match on second attempt, '" <<
-                    entry->mem_obj->url << "' '" << vary << "'");
+                   entry->mem_obj->url << "' '" << vary << "'");
             return VARY_CANCEL;
         }
     }
@@ -3449,42 +3448,43 @@ ConnStateData::clientPinnedConnectionClosed(const CommCloseCbParams &io)
 {
     pinning.fd = -1;
     if (pinning.peer) {
-	cbdataReferenceDone(pinning.peer);
+        cbdataReferenceDone(pinning.peer);
     }
     safe_free(pinning.host);
     /* NOTE: pinning.pinned should be kept. This combined with fd == -1 at the end of a request indicates that the host
      * connection has gone away */
 }
 
-void ConnStateData::pinConnection(int pinning_fd, HttpRequest *request, struct peer *peer, bool auth){
+void ConnStateData::pinConnection(int pinning_fd, HttpRequest *request, struct peer *peer, bool auth)
+{
     fde *f;
     char desc[FD_DESC_SZ];
 
     if (pinning.fd == pinning_fd)
-	return;
+        return;
     else if (pinning.fd != -1)
-	comm_close(pinning.fd);
-    
-    if(pinning.host)
-	safe_free(pinning.host);
-    
+        comm_close(pinning.fd);
+
+    if (pinning.host)
+        safe_free(pinning.host);
+
     pinning.fd = pinning_fd;
     pinning.host = xstrdup(request->GetHost());
     pinning.port = request->port;
     pinning.pinned = true;
     if (pinning.peer)
-	cbdataReferenceDone(pinning.peer);
+        cbdataReferenceDone(pinning.peer);
     if (peer)
-	pinning.peer = cbdataReference(peer);
+        pinning.peer = cbdataReference(peer);
     pinning.auth = auth;
     f = &fd_table[fd];
     snprintf(desc, FD_DESC_SZ, "%s pinned connection for %s:%d (%d)",
-	(auth || !peer) ? request->GetHost() : peer->name, f->ipaddr, (int) f->remote_port, fd);
+             (auth || !peer) ? request->GetHost() : peer->name, f->ipaddr, (int) f->remote_port, fd);
     fd_note(pinning_fd, desc);
-    
+
     typedef CommCbMemFunT<ConnStateData, CommCloseCbParams> Dialer;
     pinning.closeHandler = asyncCall(33, 5, "ConnStateData::clientPinnedConnectionClosed",
-					Dialer(this, &ConnStateData::clientPinnedConnectionClosed));
+                                     Dialer(this, &ConnStateData::clientPinnedConnectionClosed));
     comm_add_close_handler(pinning_fd, pinning.closeHandler);
 
 }
@@ -3493,44 +3493,44 @@ int ConnStateData::validatePinnedConnection(HttpRequest *request, const struct p
 {
     bool valid = true;
     if (pinning.fd < 0)
-	return -1;
-    
+        return -1;
+
     if (pinning.auth && request && strcasecmp(pinning.host, request->GetHost()) != 0) {
-	valid = false;
+        valid = false;
     }
-    if (request && pinning.port != request->port){
-	valid = false;
+    if (request && pinning.port != request->port) {
+        valid = false;
     }
-    if (pinning.peer && !cbdataReferenceValid(pinning.peer)){
-	valid = false;
+    if (pinning.peer && !cbdataReferenceValid(pinning.peer)) {
+        valid = false;
     }
-    if (peer != pinning.peer){
-	valid = false;
+    if (peer != pinning.peer) {
+        valid = false;
     }
 
-    if(!valid) {
-	int pinning_fd=pinning.fd;
-	/* The pinning info is not safe, remove any pinning info*/
-	unpinConnection();
+    if (!valid) {
+        int pinning_fd=pinning.fd;
+        /* The pinning info is not safe, remove any pinning info*/
+        unpinConnection();
 
-	/* also close the server side socket, we should not use it for invalid/unauthenticated
-	   requests...
-	 */
-	comm_close(pinning_fd);
-	return -1;
+        /* also close the server side socket, we should not use it for invalid/unauthenticated
+           requests...
+         */
+        comm_close(pinning_fd);
+        return -1;
     }
 
     return pinning.fd;
 }
 
 void ConnStateData::unpinConnection()
 {
-    if(pinning.peer)
-	cbdataReferenceDone(pinning.peer);
+    if (pinning.peer)
+        cbdataReferenceDone(pinning.peer);
 
-    if(pinning.closeHandler != NULL) {
-	comm_remove_close_handler(pinning.fd, pinning.closeHandler);
-	pinning.closeHandler = NULL;
+    if (pinning.closeHandler != NULL) {
+        comm_remove_close_handler(pinning.fd, pinning.closeHandler);
+        pinning.closeHandler = NULL;
     }
     pinning.fd = -1;
     safe_free(pinning.host);
@@ -18,12 +18,12 @@
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
- *  
+ *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
- *  
+ *
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
@@ -68,17 +68,15 @@ class ClientSocketContext : public RefCountable
     char reqbuf[HTTP_REQBUF_SZ];
     Pointer next;
 
-    struct
-    {
+    struct {
 
-unsigned deferred: 1; /* This is a pipelined request waiting for the current object to complete */
+        unsigned deferred:1; /* This is a pipelined request waiting for the current object to complete */
 
-unsigned parsed_ok: 1; /* Was this parsed correctly? */
+        unsigned parsed_ok:1; /* Was this parsed correctly? */
     } flags;
     bool mayUseConnection() const {return mayUseConnection_;}
 
-    void mayUseConnection(bool aBool)
-    {
+    void mayUseConnection(bool aBool) {
         mayUseConnection_ = aBool;
         debug (33,3)("ClientSocketContext::mayUseConnection: This %p marked %d\n",
                      this, aBool);
@@ -146,8 +144,7 @@ class ConnStateData : public BodyProducer/*, public RefCountable*/
 
     int fd;
 
-    struct In
-    {
+    struct In {
         In();
         ~In();
         char *addressToReadInto() const;
@@ -184,8 +181,7 @@ class ConnStateData : public BodyProducer/*, public RefCountable*/
     char rfc931[USER_IDENT_SZ];
     int nrequests;
 
-    struct
-    {
+    struct {
         bool readMoreRequests;
         bool swanSang; // XXX: temporary flag to check proper cleanup
     } flags;
@@ -196,8 +192,8 @@ class ConnStateData : public BodyProducer/*, public RefCountable*/
         bool pinned;             /* this connection was pinned */
         bool auth;               /* pinned for www authentication */
         struct peer *peer;             /* peer the connection goes via */
-	AsyncCall::Pointer closeHandler; /*The close handler for pinned server side connection*/
-     } pinning;
+        AsyncCall::Pointer closeHandler; /*The close handler for pinned server side connection*/
+    } pinning;
 
     http_port_list *port;
 
@@ -223,7 +219,7 @@ class ConnStateData : public BodyProducer/*, public RefCountable*/
     /**
      * Decorrelate the ConnStateData object from its pinned peer
      */
-    void unpinConnection();    
+    void unpinConnection();
     /**
      * Checks if there is pinning info if it is valid. It can close the server side connection
      * if pinned info is not valid.
@@ -21,12 +21,12 @@
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
- *  
+ *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
- *  
+ *
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
@@ -64,33 +64,33 @@
  */
 
 typedef enum {
-	IOCB_NONE,
-	IOCB_READ,
-	IOCB_WRITE
+    IOCB_NONE,
+    IOCB_READ,
+    IOCB_WRITE
 } iocb_type;
 
 static void commStopHalfClosedMonitor(int fd);
 static IOCB commHalfClosedReader;
 
 
 struct comm_io_callback_t {
-	iocb_type type;
-	int fd;
-	AsyncCall::Pointer callback;
-	char *buf;
-	FREE *freefunc;
-	int size;
-	int offset;
-	comm_err_t errcode;
-	int xerrno;
-
-	bool active() const { return callback != NULL; }
+    iocb_type type;
+    int fd;
+    AsyncCall::Pointer callback;
+    char *buf;
+    FREE *freefunc;
+    int size;
+    int offset;
+    comm_err_t errcode;
+    int xerrno;
+
+    bool active() const { return callback != NULL; }
 };
 
 struct _comm_fd {
-	int fd;
-	comm_io_callback_t	readcb;
-	comm_io_callback_t	writecb;
+    int fd;
+    comm_io_callback_t	readcb;
+    comm_io_callback_t	writecb;
 };
 typedef struct _comm_fd comm_fd_t;
 comm_fd_t *commfd_table;
@@ -99,9 +99,9 @@ comm_fd_t *commfd_table;
 bool
 commio_has_callback(int fd, iocb_type type, comm_io_callback_t *ccb)
 {
-	assert(ccb->fd == fd);
-	assert(ccb->type == type);
-	return ccb->active();
+    assert(ccb->fd == fd);
+    assert(ccb->type == type);
+    return ccb->active();
 }
 
 /*
@@ -117,17 +117,17 @@ commio_has_callback(int fd, iocb_type type, comm_io_callback_t *ccb)
  */
 static void
 commio_set_callback(int fd, iocb_type type, comm_io_callback_t *ccb,
-    AsyncCall::Pointer &cb, char *buf, FREE *freefunc, int size)
+                    AsyncCall::Pointer &cb, char *buf, FREE *freefunc, int size)
 {
-	assert(!ccb->active());
-	assert(ccb->type == type);
-	assert(cb != NULL);
-	ccb->fd = fd;
-	ccb->callback = cb;
-	ccb->buf = buf;
-	ccb->freefunc = freefunc;
-	ccb->size = size;
-	ccb->offset = 0;
+    assert(!ccb->active());
+    assert(ccb->type == type);
+    assert(cb != NULL);
+    ccb->fd = fd;
+    ccb->callback = cb;
+    ccb->buf = buf;
+    ccb->freefunc = freefunc;
+    ccb->size = size;
+    ccb->offset = 0;
 }
 
 
@@ -136,26 +136,26 @@ static void
 commio_finish_callback(int fd, comm_io_callback_t *ccb, comm_err_t code, int xerrno)
 {
     debugs(5, 3, "commio_finish_callback: called for FD " << fd << " (" <<
-        code << ", " << xerrno << ")");
-	assert(ccb->active());
-	assert(ccb->fd == fd);
-	ccb->errcode = code;
-	ccb->xerrno = xerrno;
-
-	comm_io_callback_t cb = *ccb;
-
-	/* We've got a copy; blow away the real one */
-	/* XXX duplicate code from commio_cancel_callback! */
-	ccb->xerrno = 0;
-	ccb->callback = NULL; // cb has it
-
-	/* free data */
-	if (cb.freefunc) {
-		cb.freefunc(cb.buf);
-		cb.buf = NULL;
-	}
-
-	if (cb.callback != NULL) {
+           code << ", " << xerrno << ")");
+    assert(ccb->active());
+    assert(ccb->fd == fd);
+    ccb->errcode = code;
+    ccb->xerrno = xerrno;
+
+    comm_io_callback_t cb = *ccb;
+
+    /* We've got a copy; blow away the real one */
+    /* XXX duplicate code from commio_cancel_callback! */
+    ccb->xerrno = 0;
+    ccb->callback = NULL; // cb has it
+
+    /* free data */
+    if (cb.freefunc) {
+        cb.freefunc(cb.buf);
+        cb.buf = NULL;
+    }
+
+    if (cb.callback != NULL) {
         typedef CommIoCbParams Params;
         Params &params = GetCommParams<Params>(cb.callback);
         params.fd = cb.fd;
@@ -164,7 +164,7 @@ commio_finish_callback(int fd, comm_io_callback_t *ccb, comm_err_t code, int xer
         params.flag = cb.errcode;
         params.xerrno = cb.xerrno;
         ScheduleCallHere(cb.callback);
-	}
+    }
 }
 
 
@@ -178,16 +178,16 @@ static void
 commio_cancel_callback(int fd, comm_io_callback_t *ccb)
 {
     debugs(5, 3, "commio_cancel_callback: called for FD " << fd);
-	assert(ccb->fd == fd);
-	assert(ccb->active());
+    assert(ccb->fd == fd);
+    assert(ccb->active());
 
-	ccb->xerrno = 0;
-	ccb->callback = NULL;
+    ccb->xerrno = 0;
+    ccb->callback = NULL;
 }
 
 /*
  * Call the given comm callback; assumes the callback is valid.
- * 
+ *
  * @param ccb		io completion callback
  */
 void
@@ -270,8 +270,7 @@ typedef enum {
     COMM_CB_DERIVED,
 } comm_callback_t;
 
-struct _fd_debug_t
-{
+struct _fd_debug_t {
     char const *close_file;
     int close_line;
 };
@@ -285,7 +284,7 @@ fd_debug_t *fdd_table = NULL;
 static bool
 isOpen(const int fd)
 {
-   return fd_table[fd].flags.open != 0;
+    return fd_table[fd].flags.open != 0;
 }
 
 /**
@@ -298,7 +297,7 @@ void
 commHandleRead(int fd, void *data)
 {
     comm_io_callback_t *ccb = (comm_io_callback_t *) data;
-    
+
     assert(data == COMMIO_FD_READCB(fd));
     assert(commio_has_callback(fd, IOCB_READ, ccb));
     /* Attempt a read */
@@ -310,17 +309,17 @@ commHandleRead(int fd, void *data)
 
     if (retval < 0 && !ignoreErrno(errno)) {
         debugs(5, 3, "comm_read_try: scheduling COMM_ERROR");
-	ccb->offset = 0;
-	commio_finish_callback(fd, ccb, COMM_ERROR, errno);
+        ccb->offset = 0;
+        commio_finish_callback(fd, ccb, COMM_ERROR, errno);
         return;
     };
 
     /* See if we read anything */
     /* Note - read 0 == socket EOF, which is a valid read */
     if (retval >= 0) {
         fd_bytes(fd, retval, FD_READ);
-	ccb->offset = retval;    
-	commio_finish_callback(fd, ccb, COMM_OK, errno);
+        ccb->offset = retval;
+        commio_finish_callback(fd, ccb, COMM_OK, errno);
         return;
     }
 
@@ -336,7 +335,7 @@ void
 comm_read(int fd, char *buf, int size, IOCB *handler, void *handler_data)
 {
     AsyncCall::Pointer call = commCbCall(5,4, "SomeCommReadHandler",
-					 CommIoCbPtrFun(handler, handler_data));
+                                         CommIoCbPtrFun(handler, handler_data));
     comm_read(fd, buf, size, call);
 }
 
@@ -432,21 +431,21 @@ comm_read_cancel(int fd, IOCB *callback, void *data)
     if (!isOpen(fd)) {
         debugs(5, 4, "comm_read_cancel fails: FD " << fd << " closed");
         return;
-	}
+    }
 
     comm_io_callback_t *cb = COMMIO_FD_READCB(fd);
     // TODO: is "active" == "monitors FD"?
     if (!cb->active()) {
         debugs(5, 4, "comm_read_cancel fails: FD " << fd << " inactive");
         return;
-	}
+    }
 
     typedef CommCbFunPtrCallT<CommIoCbPtrFun> Call;
     Call *call = dynamic_cast<Call*>(cb->callback.getRaw());
     if (!call) {
         debugs(5, 4, "comm_read_cancel fails: FD " << fd << " lacks callback");
         return;
-	}
+    }
 
     call->cancel("old comm_read_cancel");
 
@@ -468,7 +467,7 @@ void
 comm_read_cancel(int fd, AsyncCall::Pointer &callback)
 {
     callback->cancel("comm_read_cancel");
-    
+
     if (!isOpen(fd)) {
         debugs(5, 4, "comm_read_cancel fails: FD " << fd << " closed");
         return;
@@ -483,7 +482,7 @@ comm_read_cancel(int fd, AsyncCall::Pointer &callback)
 
     AsyncCall::Pointer call = cb->callback;
     assert(call != NULL); // XXX: should never fail (active() checks for callback==NULL)
-    
+
     /* Ok, we can be reasonably sure we won't lose any data here! */
     assert(call == callback);
 
@@ -625,13 +624,13 @@ int
 comm_set_tos(int fd, int tos)
 {
 #ifdef IP_TOS
-	int x = setsockopt(fd, IPPROTO_IP, IP_TOS, (char *) &tos, sizeof(int));
-        if (x < 0)
-            debugs(50, 1, "comm_set_tos: setsockopt(IP_TOS) on FD " << fd << ": " << xstrerror());
-	return x;
+    int x = setsockopt(fd, IPPROTO_IP, IP_TOS, (char *) &tos, sizeof(int));
+    if (x < 0)
+        debugs(50, 1, "comm_set_tos: setsockopt(IP_TOS) on FD " << fd << ": " << xstrerror());
+    return x;
 #else
-        debugs(50, 0, "WARNING: setsockopt(IP_TOS) not supported on this platform");
-	return -1;
+    debugs(50, 0, "WARNING: setsockopt(IP_TOS) not supported on this platform");
+    return -1;
 #endif
 }
 
@@ -657,8 +656,7 @@ comm_set_transparent(int fd)
     int tos = 1;
     if (setsockopt(fd, SOL_IP, IP_TRANSPARENT, (char *) &tos, sizeof(int)) < 0) {
         debugs(50, DBG_IMPORTANT, "comm_open: setsockopt(IP_TRANSPARENT) on FD " << fd << ": " << xstrerror());
-    }
-    else {
+    } else {
         /* mark the socket as having transparent options */
         fd_table[fd].flags.transparent = 1;
     }
@@ -695,8 +693,7 @@ comm_openex(int sock_type,
 
     debugs(50, 3, "comm_openex: Attempt open socket for: " << addr );
 
-    if ((new_socket = socket(AI->ai_family, AI->ai_socktype, AI->ai_protocol)) < 0)
-    {
+    if ((new_socket = socket(AI->ai_family, AI->ai_socktype, AI->ai_protocol)) < 0) {
         /* Increase the number of reserved fd's if calls to socket()
          * are failing because the open file table is full.  This
          * limits the number of simultaneous clients */
@@ -723,7 +720,7 @@ comm_openex(int sock_type,
 
 #if IPV6_SPECIAL_SPLITSTACK
 
-    if( addr.IsIPv6() )
+    if ( addr.IsIPv6() )
         comm_set_v6only(new_socket, tos);
 
 #endif
@@ -732,7 +729,7 @@ comm_openex(int sock_type,
 
     /* Windows Vista supports Dual-Sockets. BUT defaults them to V6ONLY. Turn it OFF. */
     /* Other OS may have this administratively disabled for general use. Same deal. */
-    if( addr.IsIPv6() )
+    if ( addr.IsIPv6() )
         comm_set_v6only(new_socket, 0);
 
 #endif
@@ -761,8 +758,7 @@ comm_openex(int sock_type,
     if ((flags & COMM_REUSEADDR))
         commSetReuseAddr(new_socket);
 
-    if (addr.GetPort() > (u_short) 0)
-    {
+    if (addr.GetPort() > (u_short) 0) {
 #ifdef _SQUID_MSWIN_
 
         if (sock_type != SOCK_DGRAM)
@@ -775,12 +771,11 @@ comm_openex(int sock_type,
     }
 
     /* MUST be done before binding or face OS Error: "(99) Cannot assign requested address"... */
-    if((flags & COMM_TRANSPARENT)) {
+    if ((flags & COMM_TRANSPARENT)) {
         comm_set_transparent(new_socket);
     }
 
-    if (!addr.IsNoAddr())
-    {
+    if (!addr.IsNoAddr()) {
         if (commBind(new_socket, *AI) != COMM_OK) {
             comm_close(new_socket);
             addr.FreeAddrInfo(AI);
@@ -792,8 +787,7 @@ comm_openex(int sock_type,
     addr.FreeAddrInfo(AI);
 
     if (flags & COMM_NONBLOCKING)
-        if (commSetNonBlocking(new_socket) == COMM_ERROR)
-        {
+        if (commSetNonBlocking(new_socket) == COMM_ERROR) {
             return -1;
             PROF_stop(comm_open);
         }
@@ -833,7 +827,7 @@ void
 commConnectStart(int fd, const char *host, u_short port, AsyncCall::Pointer &cb)
 {
     debugs(cb->debugSection, cb->debugLevel, "commConnectStart: FD " << fd <<
-        ", cb " << cb << ", " << host << ":" << port); // TODO: just print *cb
+           ", cb " << cb << ", " << host << ":" << port); // TODO: just print *cb
 
     ConnectStateData *cs;
     cs = new ConnectStateData;
@@ -855,7 +849,7 @@ commConnectStart(int fd, const char *host, u_short port, CNCB * callback, void *
 {
     debugs(5, 5, "commConnectStart: FD " << fd << ", data " << data << ", " << host << ":" << port);
     AsyncCall::Pointer call = commCbCall(5,3,
-					 "SomeCommConnectHandler", CommConnectCbPtrFun(callback, data));
+                                         "SomeCommConnectHandler", CommConnectCbPtrFun(callback, data));
     commConnectStart(fd, host, port, call);
 }
 
@@ -1007,7 +1001,7 @@ ConnectStateData::commResetFD()
      */
 
     /* MUST be done before binding or face OS Error: "(99) Cannot assign requested address"... */
-    if( F->flags.transparent ) {
+    if ( F->flags.transparent ) {
         comm_set_transparent(fd);
     }
 
@@ -1026,7 +1020,7 @@ ConnectStateData::commResetFD()
 
 #if IPV6_SPECIAL_SPLITSTACK
 
-    if( F->local_addr.IsIPv6() )
+    if ( F->local_addr.IsIPv6() )
         comm_set_v6only(fd, F->tos);
 
 #endif
@@ -1160,10 +1154,10 @@ commSetTimeout(int fd, int timeout, PF * handler, void *data)
 {
     AsyncCall::Pointer call;
     debugs(5, 3, HERE << "FD " << fd << " timeout " << timeout);
-    if(handler != NULL)
-	call=commCbCall(5,4, "SomeTimeoutHandler", CommTimeoutCbPtrFun(handler, data));
+    if (handler != NULL)
+        call=commCbCall(5,4, "SomeTimeoutHandler", CommTimeoutCbPtrFun(handler, data));
     else
-	call = NULL;
+        call = NULL;
     return commSetTimeout(fd, timeout, call);
 }
 
@@ -1181,9 +1175,9 @@ int commSetTimeout(int fd, int timeout, AsyncCall::Pointer &callback)
         F->timeout = 0;
     } else {
         if (callback != NULL) {
-	    typedef CommTimeoutCbParams Params;
-	    Params &params = GetCommParams<Params>(callback);
-	    params.fd = fd;
+            typedef CommTimeoutCbParams Params;
+            Params &params = GetCommParams<Params>(callback);
+            params.fd = fd;
             F->timeoutHandler = callback;
         }
 
@@ -1217,7 +1211,7 @@ comm_connect_addr(int sock, const IPAddress &address)
      *     trust its handled properly.
      */
 #if USE_IPV6
-    if(F->sock_family == AF_INET && !address.IsIPv4()) {
+    if (F->sock_family == AF_INET && !address.IsIPv4()) {
         return COMM_ERR_PROTOCOL;
     }
 #endif
@@ -1227,8 +1221,7 @@ comm_connect_addr(int sock, const IPAddress &address)
     /* Establish connection. */
     errno = 0;
 
-    if (!F->flags.called_connect)
-    {
+    if (!F->flags.called_connect) {
         F->flags.called_connect = 1;
         statCounter.syscalls.sock.connects++;
 
@@ -1241,21 +1234,19 @@ comm_connect_addr(int sock, const IPAddress &address)
             errno = EINPROGRESS;
         }
 
-        if (x < 0)
-        {
+        if (x < 0) {
             debugs(5,5, "comm_connect_addr: sock=" << sock << ", addrinfo( " <<
-                         " flags=" << AI->ai_flags <<
-                         ", family=" << AI->ai_family <<
-                         ", socktype=" << AI->ai_socktype <<
-                         ", protocol=" << AI->ai_protocol <<
-                         ", &addr=" << AI->ai_addr <<
-                         ", addrlen=" << AI->ai_addrlen <<
-                         " )" );
+                   " flags=" << AI->ai_flags <<
+                   ", family=" << AI->ai_family <<
+                   ", socktype=" << AI->ai_socktype <<
+                   ", protocol=" << AI->ai_protocol <<
+                   ", &addr=" << AI->ai_addr <<
+                   ", addrlen=" << AI->ai_addrlen <<
+                   " )" );
             debugs(5, 9, "connect FD " << sock << ": (" << x << ") " << xstrerror());
             debugs(14,9, "connecting to: " << address );
         }
-    } else
-    {
+    } else {
 #if defined(_SQUID_NEWSOS6_)
         /* Makoto MATSUSHITA <matusita@ics.es.osaka-u.ac.jp> */
 
@@ -1292,18 +1283,18 @@ comm_connect_addr(int sock, const IPAddress &address)
 
     }
 
-/* Squid seems to be working fine without this code. With this code,
- * we leak memory on many connect requests because of EINPROGRESS.
- * If you find that this code is needed, please file a bug report. */
+    /* Squid seems to be working fine without this code. With this code,
+     * we leak memory on many connect requests because of EINPROGRESS.
+     * If you find that this code is needed, please file a bug report. */
 #if 0
 #ifdef _SQUID_LINUX_
     /* 2007-11-27:
-     * Linux Debian replaces our allocated AI pointer with garbage when 
+     * Linux Debian replaces our allocated AI pointer with garbage when
      * connect() fails. This leads to segmentation faults deallocating
      * the system-allocated memory when we go to clean up our pointer.
      * HACK: is to leak the memory returned since we can't deallocate.
      */
-    if(errno != 0) {
+    if (errno != 0) {
         AI = NULL;
     }
 #endif
@@ -1319,32 +1310,29 @@ comm_connect_addr(int sock, const IPAddress &address)
         status = COMM_INPROGRESS;
     else
 #if USE_IPV6
-      if( address.IsIPv4() && F->sock_family == AF_INET6 ) {
+        if ( address.IsIPv4() && F->sock_family == AF_INET6 ) {
 
             /* failover to trying IPv4-only link if an IPv6 one fails */
             /* to catch the edge case of apps listening on IPv4-localhost */
-        F->sock_family = AF_INET;
-        int res = comm_connect_addr(sock, address);
+            F->sock_family = AF_INET;
+            int res = comm_connect_addr(sock, address);
 
-           /* if that fails too, undo our temporary socktype hack so the repeat works properly. */
-        if(res == COMM_ERROR)
-             F->sock_family = AF_INET6;
+            /* if that fails too, undo our temporary socktype hack so the repeat works properly. */
+            if (res == COMM_ERROR)
+                F->sock_family = AF_INET6;
 
-        return res;
-    }
-    else
+            return res;
+        } else
 #endif
-        return COMM_ERROR;
+            return COMM_ERROR;
 
     address.NtoA(F->ipaddr, MAX_IPSTRLEN);
 
     F->remote_port = address.GetPort(); /* remote_port is HS */
 
-    if (status == COMM_OK)
-    {
+    if (status == COMM_OK) {
         debugs(5, 10, "comm_connect_addr: FD " << sock << " connected to " << address);
-    } else if (status == COMM_INPROGRESS)
-    {
+    } else if (status == COMM_INPROGRESS) {
         debugs(5, 10, "comm_connect_addr: FD " << sock << " connection pending");
     }
 
@@ -1368,16 +1356,13 @@ comm_old_accept(int fd, ConnectionDetail &details)
 
         PROF_stop(comm_accept);
 
-        if (ignoreErrno(errno))
-        {
+        if (ignoreErrno(errno)) {
             debugs(50, 5, "comm_old_accept: FD " << fd << ": " << xstrerror());
             return COMM_NOMESSAGE;
-        } else if (ENFILE == errno || EMFILE == errno)
-        {
+        } else if (ENFILE == errno || EMFILE == errno) {
             debugs(50, 3, "comm_old_accept: FD " << fd << ": " << xstrerror());
             return COMM_ERROR;
-        } else
-        {
+        } else {
             debugs(50, 1, "comm_old_accept: FD " << fd << ": " << xstrerror());
             return COMM_ERROR;
         }
@@ -1425,16 +1410,16 @@ commCallCloseHandlers(int fd)
 
     while (F->closeHandler != NULL) {
         AsyncCall::Pointer call = F->closeHandler;
-	F->closeHandler = call->Next();
-	call->setNext(NULL);
-	// If call is not canceled schedule it for execution else ignore it
-	if(!call->canceled()){
-	    debugs(5, 5, "commCallCloseHandlers: ch->handler=" << call);
-	    typedef CommCloseCbParams Params;
-	    Params &params = GetCommParams<Params>(call);
-	    params.fd = fd;
-	    ScheduleCallHere(call);
-	}
+        F->closeHandler = call->Next();
+        call->setNext(NULL);
+        // If call is not canceled schedule it for execution else ignore it
+        if (!call->canceled()) {
+            debugs(5, 5, "commCallCloseHandlers: ch->handler=" << call);
+            typedef CommCloseCbParams Params;
+            Params &params = GetCommParams<Params>(call);
+            params.fd = fd;
+            ScheduleCallHere(call);
+        }
     }
 }
 
@@ -1502,7 +1487,7 @@ comm_reset_close(int fd)
     comm_close(fd);
 }
 
-void 
+void
 comm_close_start(int fd, void *data)
 {
 #if USE_SSL
@@ -1515,7 +1500,7 @@ comm_close_start(int fd, void *data)
 }
 
 
-void 
+void
 comm_close_complete(int fd, void *data)
 {
 #if USE_SSL
@@ -1549,7 +1534,7 @@ comm_close_complete(int fd, void *data)
  * + call read handlers with ERR_CLOSING
  * + call closing handlers
  *
- * NOTE: COMM_ERR_CLOSING will NOT be called for CommReads' sitting in a 
+ * NOTE: COMM_ERR_CLOSING will NOT be called for CommReads' sitting in a
  * DeferredReadManager.
  */
 void
@@ -1579,7 +1564,7 @@ _comm_close(int fd, char const *file, int line)
     F->flags.close_request = 1;
 
     AsyncCall::Pointer startCall=commCbCall(5,4, "comm_close_start",
-					    CommCloseCbPtrFun(comm_close_start, NULL));
+                                            CommCloseCbPtrFun(comm_close_start, NULL));
     typedef CommCloseCbParams Params;
     Params &startParams = GetCommParams<Params>(startCall);
     startParams.fd = fd;
@@ -1607,13 +1592,13 @@ _comm_close(int fd, char const *file, int line)
         F->pconn.pool->count(F->pconn.uses);
 
     comm_empty_os_read_buffers(fd);
-    
+
 
     AsyncCall::Pointer completeCall=commCbCall(5,4, "comm_close_complete",
-				       CommCloseCbPtrFun(comm_close_complete, NULL));
+                                    CommCloseCbPtrFun(comm_close_complete, NULL));
     Params &completeParams = GetCommParams<Params>(completeCall);
     completeParams.fd = fd;
-    // must use async call to wait for all callbacks 
+    // must use async call to wait for all callbacks
     // scheduled before comm_close() to finish
     ScheduleCallHere(completeCall);
 
@@ -1634,7 +1619,7 @@ comm_udp_sendto(int fd,
     statCounter.syscalls.sock.sendtos++;
 
     debugs(50, 3, "comm_udp_sendto: Attempt to send UDP packet to " << to_addr <<
-                  " using FD " << fd << " using Port " << comm_local_port(fd) );
+           " using FD " << fd << " using Port " << comm_local_port(fd) );
 
     /* BUG: something in the above macro appears to occasionally be setting AI to garbage. */
     /* AYJ: 2007-08-27 : or was it because I wasn't then setting 'fd_table[fd].sock_family' to fill properly. */
@@ -1668,7 +1653,7 @@ comm_add_close_handler(int fd, PF * handler, void *data)
            handler << ", data=" << data);
 
     AsyncCall::Pointer call=commCbCall(5,4, "SomeCloseHandler",
-                                         CommCloseCbPtrFun(handler, data));
+                                       CommCloseCbPtrFun(handler, data));
     comm_add_close_handler(fd, call);
 }
 
@@ -1697,7 +1682,7 @@ comm_remove_close_handler(int fd, PF * handler, void *data)
            handler << ", data=" << data);
 
     AsyncCall::Pointer p;
-    for (p = fd_table[fd].closeHandler; p != NULL; p = p->Next()){
+    for (p = fd_table[fd].closeHandler; p != NULL; p = p->Next()) {
         typedef CommCbFunPtrCallT<CommCloseCbPtrFun> Call;
         const Call *call = dynamic_cast<const Call*>(p.getRaw());
         if (!call) // method callbacks have their own comm_remove_close_handler
@@ -1873,30 +1858,29 @@ commSetTcpNoDelay(int fd) {
 #endif
 
 void
-commSetTcpKeepalive(int fd, int idle, int interval, int timeout)
-{
+commSetTcpKeepalive(int fd, int idle, int interval, int timeout) {
     int on = 1;
 #ifdef TCP_KEEPCNT
     if (timeout && interval) {
-	int count = (timeout + interval - 1) / interval;
-	if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &count, sizeof(on)) < 0)
-	    debugs(5, 1, "commSetKeepalive: FD " << fd << ": " << xstrerror());
+        int count = (timeout + interval - 1) / interval;
+        if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &count, sizeof(on)) < 0)
+            debugs(5, 1, "commSetKeepalive: FD " << fd << ": " << xstrerror());
     }
 #endif
 #ifdef TCP_KEEPIDLE
     if (idle) {
-	if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &idle, sizeof(on)) < 0)
-	    debugs(5, 1, "commSetKeepalive: FD " << fd << ": " << xstrerror());
+        if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &idle, sizeof(on)) < 0)
+            debugs(5, 1, "commSetKeepalive: FD " << fd << ": " << xstrerror());
     }
 #endif
 #ifdef TCP_KEEPINTVL
     if (interval) {
-	if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &interval, sizeof(on)) < 0)
-	    debugs(5, 1, "commSetKeepalive: FD " << fd << ": " << xstrerror());
+        if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &interval, sizeof(on)) < 0)
+            debugs(5, 1, "commSetKeepalive: FD " << fd << ": " << xstrerror());
     }
 #endif
     if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (char *) &on, sizeof(on)) < 0)
-	debugs(5, 1, "commSetKeepalive: FD " << fd << ": " << xstrerror());
+        debugs(5, 1, "commSetKeepalive: FD " << fd << ": " << xstrerror());
 }
 
 void
@@ -1911,11 +1895,11 @@ comm_init(void) {
 
     commfd_table = (comm_fd_t *) xcalloc(Squid_MaxFD, sizeof(comm_fd_t));
     for (int pos = 0; pos < Squid_MaxFD; pos++) {
-	commfd_table[pos].fd = pos;
-	commfd_table[pos].readcb.fd = pos;
-	commfd_table[pos].readcb.type = IOCB_READ;
-	commfd_table[pos].writecb.fd = pos;
-	commfd_table[pos].writecb.type = IOCB_WRITE;
+        commfd_table[pos].fd = pos;
+        commfd_table[pos].readcb.fd = pos;
+        commfd_table[pos].readcb.type = IOCB_READ;
+        commfd_table[pos].writecb.fd = pos;
+        commfd_table[pos].writecb.type = IOCB_WRITE;
     }
 
     /* XXX account fd_table */
@@ -1937,8 +1921,8 @@ comm_exit(void) {
     safe_free(fd_table);
     safe_free(fdd_table);
     if (fdc_table) {
-	delete[] fdc_table;
-	fdc_table = NULL;
+        delete[] fdc_table;
+        fdc_table = NULL;
     }
     safe_free(commfd_table);
 }
@@ -2013,17 +1997,15 @@ commHandleWrite(int fd, void *data) {
  * free_func is used to free the passed buffer when the write has completed.
  */
 void
-comm_write(int fd, const char *buf, int size, IOCB * handler, void *handler_data, FREE * free_func)
-{
+comm_write(int fd, const char *buf, int size, IOCB * handler, void *handler_data, FREE * free_func) {
     AsyncCall::Pointer call = commCbCall(5,5, "SomeCommWriteHander",
-        CommIoCbPtrFun(handler, handler_data));
+                                         CommIoCbPtrFun(handler, handler_data));
 
     comm_write(fd, buf, size, call, free_func);
 }
 
 void
-comm_write(int fd, const char *buf, int size, AsyncCall::Pointer &callback, FREE * free_func)
-{
+comm_write(int fd, const char *buf, int size, AsyncCall::Pointer &callback, FREE * free_func) {
     debugs(5, 5, "comm_write: FD " << fd << ": sz " << size << ": asynCall " << callback);
 
     /* Make sure we are open, not closing, and not writing */
@@ -2034,7 +2016,7 @@ comm_write(int fd, const char *buf, int size, AsyncCall::Pointer &callback, FREE
 
     /* Queue the write */
     commio_set_callback(fd, IOCB_WRITE, ccb, callback,
-	(char *)buf, free_func, size);
+                        (char *)buf, free_func, size);
     commSetSelect(fd, COMM_SELECT_WRITE, commHandleWrite, ccb, 0);
 }
 
@@ -2105,7 +2087,7 @@ commCloseAllSockets(void) {
             AsyncCall::Pointer callback = F->timeoutHandler;
             F->timeoutHandler = NULL;
             debugs(5, 5, "commCloseAllSockets: FD " << fd << ": Calling timeout handler");
-	    ScheduleCallHere(callback);
+            ScheduleCallHere(callback);
         } else {
             debugs(5, 5, "commCloseAllSockets: FD " << fd << ": calling comm_close()");
             comm_close(fd);
@@ -2139,13 +2121,13 @@ checkTimeouts(void) {
         if (AlreadyTimedOut(F))
             continue;
 
-            debugs(5, 5, "checkTimeouts: FD " << fd << " Expired");
+        debugs(5, 5, "checkTimeouts: FD " << fd << " Expired");
 
         if (F->timeoutHandler != NULL) {
             debugs(5, 5, "checkTimeouts: FD " << fd << ": Call timeout handler");
             callback = F->timeoutHandler;
             F->timeoutHandler = NULL;
-	    ScheduleCallHere(callback);
+            ScheduleCallHere(callback);
         } else {
             debugs(5, 5, "checkTimeouts: FD " << fd << ": Forcing comm_close()");
             comm_close(fd);
@@ -2171,22 +2153,22 @@ comm_listen(int sock) {
 
     if (Config.accept_filter && strcmp(Config.accept_filter, "none") != 0) {
 #ifdef SO_ACCEPTFILTER
-	struct accept_filter_arg afa;
-	bzero(&afa, sizeof(afa));
-	debugs(5, DBG_CRITICAL, "Installing accept filter '" << Config.accept_filter << "' on FD " << sock);
-	xstrncpy(afa.af_name, Config.accept_filter, sizeof(afa.af_name));
-	x = setsockopt(sock, SOL_SOCKET, SO_ACCEPTFILTER, &afa, sizeof(afa));
-	if (x < 0)
-	    debugs(5, 0, "SO_ACCEPTFILTER '" << Config.accept_filter << "': '" << xstrerror());
+        struct accept_filter_arg afa;
+        bzero(&afa, sizeof(afa));
+        debugs(5, DBG_CRITICAL, "Installing accept filter '" << Config.accept_filter << "' on FD " << sock);
+        xstrncpy(afa.af_name, Config.accept_filter, sizeof(afa.af_name));
+        x = setsockopt(sock, SOL_SOCKET, SO_ACCEPTFILTER, &afa, sizeof(afa));
+        if (x < 0)
+            debugs(5, 0, "SO_ACCEPTFILTER '" << Config.accept_filter << "': '" << xstrerror());
 #elif defined(TCP_DEFER_ACCEPT)
-	int seconds = 30;
-	if (strncmp(Config.accept_filter, "data=", 5) == 0)
-	    seconds = atoi(Config.accept_filter + 5);
-	x = setsockopt(sock, IPPROTO_TCP, TCP_DEFER_ACCEPT, &seconds, sizeof(seconds));
-	if (x < 0)
-	    debugs(5, 0, "TCP_DEFER_ACCEPT '" << Config.accept_filter << "': '" << xstrerror());
+        int seconds = 30;
+        if (strncmp(Config.accept_filter, "data=", 5) == 0)
+            seconds = atoi(Config.accept_filter + 5);
+        x = setsockopt(sock, IPPROTO_TCP, TCP_DEFER_ACCEPT, &seconds, sizeof(seconds));
+        if (x < 0)
+            debugs(5, 0, "TCP_DEFER_ACCEPT '" << Config.accept_filter << "': '" << xstrerror());
 #else
-	debugs(5, 0, "accept_filter not supported on your OS");
+        debugs(5, 0, "accept_filter not supported on your OS");
 #endif
     }
 
@@ -2199,19 +2181,19 @@ comm_accept(int fd, IOACB *handler, void *handler_data) {
     assert(isOpen(fd));
 
     AsyncCall::Pointer call = commCbCall(5,5, "SomeCommAcceptHandler",
-        CommAcceptCbPtrFun(handler, handler_data));
+                                         CommAcceptCbPtrFun(handler, handler_data));
     fdc_table[fd].subscribe(call);
 }
 
 void
 comm_accept(int fd, AsyncCall::Pointer &call) {
     debugs(5, 5, "comm_accept: FD " << fd << " AsyncCall: " << call);
     assert(isOpen(fd));
-    
+
     fdc_table[fd].subscribe(call);
 }
 
-// Called when somebody wants to be notified when our socket accepts new 
+// Called when somebody wants to be notified when our socket accepts new
 // connection. We do not probe the FD until there is such interest.
 void
 AcceptFD::subscribe(AsyncCall::Pointer &call) {
@@ -2235,7 +2217,7 @@ AcceptFD::acceptOne() {
     // When we are running out of FDs, there is often no callback.
     if (!theCallback) {
         debugs(5, 5, "AcceptFD::acceptOne orphaned: FD " << fd);
-        // XXX: can we remove this and similar "just in case" calls and 
+        // XXX: can we remove this and similar "just in case" calls and
         // either listen always or listen only when there is a callback?
         if (!AcceptLimiter::Instance().deferring())
             commSetSelect(fd, COMM_SELECT_READ, comm_accept_try, NULL, 0);
@@ -2260,7 +2242,7 @@ AcceptFD::acceptOne() {
         if (newfd == COMM_NOMESSAGE) {
             /* register interest again */
             debugs(5, 5, HERE << "try later: FD " << fd <<
-                " handler: " << *theCallback);
+                   " handler: " << *theCallback);
             commSetSelect(fd, COMM_SELECT_READ, comm_accept_try, NULL, 0);
             return false;
         }
@@ -2272,8 +2254,8 @@ AcceptFD::acceptOne() {
 
     assert(theCallback != NULL);
     debugs(5, 5, "AcceptFD::acceptOne accepted: FD " << fd <<
-        " newfd: " << newfd << " from: " << connDetails.peer <<
-        " handler: " << *theCallback);
+           " newfd: " << newfd << " from: " << connDetails.peer <<
+           " handler: " << *theCallback);
     notify(newfd, COMM_OK, 0, connDetails);
     return true;
 }
@@ -2284,8 +2266,7 @@ AcceptFD::acceptNext() {
 }
 
 void
-AcceptFD::notify(int newfd, comm_err_t errcode, int xerrno, const ConnectionDetail &connDetails)
-{
+AcceptFD::notify(int newfd, comm_err_t errcode, int xerrno, const ConnectionDetail &connDetails) {
     if (theCallback != NULL) {
         typedef CommAcceptCbParams Params;
         Params &params = GetCommParams<Params>(theCallback);
@@ -2312,7 +2293,7 @@ comm_accept_try(int fd, void *) {
 void CommIO::Initialise() {
     /* Initialize done pipe signal */
     int DonePipe[2];
-    if(pipe(DonePipe)) {}
+    if (pipe(DonePipe)) {}
     DoneFD = DonePipe[1];
     DoneReadFD = DonePipe[0];
     fd_open(DoneReadFD, FD_PIPE, "async-io completetion event: main");
@@ -2392,8 +2373,8 @@ AcceptLimiter::kick() {
     comm_accept (temp.acceptFD, temp.theFunction, temp.theData);
 }
 
-/// Start waiting for a possibly half-closed connection to close 
-// by scheduling a read callback to a monitoring handler that 
+/// Start waiting for a possibly half-closed connection to close
+// by scheduling a read callback to a monitoring handler that
 // will close the connection on read errors.
 void
 commStartHalfClosedMonitor(int fd) {
@@ -2406,8 +2387,7 @@ commStartHalfClosedMonitor(int fd) {
 
 static
 void
-commPlanHalfClosedCheck()
-{
+commPlanHalfClosedCheck() {
     if (!WillCheckHalfClosed && !TheHalfClosed->empty()) {
         eventAdd("commHalfClosedCheck", &commHalfClosedCheck, NULL, 1.0, 1);
         WillCheckHalfClosed = true;
@@ -2427,7 +2407,7 @@ commHalfClosedCheck(void *) {
         const int fd = *i;
         if (!fd_table[fd].halfClosedReader) { // not reading already
             AsyncCall::Pointer call = commCbCall(5,4, "commHalfClosedReader",
-                CommIoCbPtrFun(&commHalfClosedReader, NULL));
+                                                 CommIoCbPtrFun(&commHalfClosedReader, NULL));
             comm_read(fd, NULL, 0, call);
             fd_table[fd].halfClosedReader = call;
         }
@@ -2462,7 +2442,7 @@ commStopHalfClosedMonitor(int const fd) {
 static void
 commHalfClosedReader(int fd, char *, size_t size, comm_err_t flag, int, void *) {
     // there cannot be more data coming in on half-closed connections
-    assert(size == 0); 
+    assert(size == 0);
     assert(commHasHalfClosedMonitor(fd)); // or we would have canceled the read
 
     fd_table[fd].halfClosedReader = NULL; // done reading, for now
@@ -2508,12 +2488,12 @@ DeferredReadManager::delayRead(DeferredRead const &aRead) {
     debugs(5, 3, "Adding deferred read on FD " << aRead.theRead.fd);
     CbDataList<DeferredRead> *temp = deferredReads.push_back(aRead);
 
-    // We have to use a global function as a closer and point to temp 
+    // We have to use a global function as a closer and point to temp
     // instead of "this" because DeferredReadManager is not a job and
     // is not even cbdata protected
     AsyncCall::Pointer closer = commCbCall(5,4,
-        "DeferredReadManager::CloseHandler",
-        CommCloseCbPtrFun(&CloseHandler, temp));
+                                           "DeferredReadManager::CloseHandler",
+                                           CommCloseCbPtrFun(&CloseHandler, temp));
     comm_add_close_handler(aRead.theRead.fd, closer);
     temp->element.closer = closer; // remeber so that we can cancel
 }
@@ -21,12 +21,12 @@
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
- *  
+ *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
- *  
+ *
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
@@ -71,8 +71,7 @@ CBDATA_CLASS_INIT(ErrorState);
 /* local types */
 
 /// \ingroup ErrorPageInternal
-typedef struct
-{
+typedef struct {
     int id;
     char *page_name;
 } ErrorDynamicPageInfo;
@@ -85,28 +84,27 @@ typedef struct
  \note  hard coded error messages are not appended with %S
  *      automagically to give you more control on the format
  */
-static const struct
-{
+static const struct {
     int type;			/* and page_id */
     const char *text;
 }
 
 error_hard_text[] = {
 
-                        {
-                            ERR_SQUID_SIGNATURE,
-                            "\n<br>\n"
-                            "<hr>\n"
-                            "<div id=\"footer\">\n"
-                            "Generated %T by %h (%s)\n"
-                            "</div>\n"
-                            "</body></html>\n"
-                        },
-                        {
-                            TCP_RESET,
-                            "reset"
-                        }
-                    };
+    {
+        ERR_SQUID_SIGNATURE,
+        "\n<br>\n"
+        "<hr>\n"
+        "<div id=\"footer\">\n"
+        "Generated %T by %h (%s)\n"
+        "</div>\n"
+        "</body></html>\n"
+    },
+    {
+        TCP_RESET,
+        "reset"
+    }
+};
 
 /// \ingroup ErrorPageInternal
 static Vector<ErrorDynamicPageInfo *> ErrorDynamicPages;
@@ -189,9 +187,9 @@ errorInitialize(void)
     error_stylesheet.reset();
 
     // look for and load stylesheet into global MemBuf for it.
-    if(Config.errorStylesheet) {
+    if (Config.errorStylesheet) {
         char *temp = errorTryLoadText(Config.errorStylesheet,NULL);
-        if(temp) {
+        if (temp) {
             error_stylesheet.Printf("%s",temp);
             safe_free(temp);
         }
@@ -243,16 +241,16 @@ errorLoadText(const char *page_name)
     char *text = NULL;
 
     /** test error_directory configured location */
-    if(Config.errorDirectory)
+    if (Config.errorDirectory)
         text = errorTryLoadText(page_name, Config.errorDirectory);
 
 #if USE_ERR_LOCALES
     /** test error_default_language location */
-    if(!text && Config.errorDefaultLanguage) {
+    if (!text && Config.errorDefaultLanguage) {
         char dir[256];
         snprintf(dir,256,"%s/%s", DEFAULT_SQUID_ERROR_DIR, Config.errorDefaultLanguage);
         text = errorTryLoadText(page_name, dir);
-        if(!text) {
+        if (!text) {
             debugs(1, DBG_CRITICAL, "Unable to load default error language files. Reset to backups.");
         }
     }
@@ -282,7 +280,7 @@ errorTryLoadText(const char *page_name, const char *dir, bool silent)
     MemBuf textbuf;
 
     // maybe received compound parts, maybe an absolute page_name and no dir
-    if(dir)
+    if (dir)
         snprintf(path, sizeof(path), "%s/%s", dir, page_name);
     else
         snprintf(path, sizeof(path), "%s", page_name);
@@ -291,14 +289,14 @@ errorTryLoadText(const char *page_name, const char *dir, bool silent)
 
     if (fd < 0) {
         /* with dynamic locale negotiation we may see some failures before a success. */
-        if(!silent)
+        if (!silent)
             debugs(4, DBG_CRITICAL, HERE << "'" << path << "': " << xstrerror());
         return NULL;
     }
 
     textbuf.init();
 
-    while((len = FD_READ_METHOD(fd, buf, sizeof(buf))) > 0) {
+    while ((len = FD_READ_METHOD(fd, buf, sizeof(buf))) > 0) {
         textbuf.append(buf, len);
     }
 
@@ -506,7 +504,7 @@ errorStateFree(ErrorState * err)
     AUTHUSERREQUESTUNLOCK(err->auth_user_request, "errstate");
     safe_free(err->err_msg);
 #if USE_ERR_LOCALES
-    if(err->err_language != Config.errorDefaultLanguage)
+    if (err->err_language != Config.errorDefaultLanguage)
 #endif
         safe_free(err->err_language);
     cbdataFree(err);
@@ -885,22 +883,21 @@ ErrorState::BuildHttpReply()
          * We have even better reasons though:
          * see http://wiki.squid-cache.org/KnowledgeBase/VaryNotCaching
          */
-        if(!Config.errorDirectory) {
+        if (!Config.errorDirectory) {
             /* We 'negotiated' this ONLY from the Accept-Language. */
             rep->header.delById(HDR_VARY);
             rep->header.putStr(HDR_VARY, "Accept-Language");
         }
 
         /* add the Content-Language header according to RFC section 14.12 */
-        if(err_language) {
+        if (err_language) {
             rep->header.putStr(HDR_CONTENT_LANGUAGE, err_language);
-        }
-        else
+        } else
 #endif /* USE_ERROR_LOCALES */
         {
             /* default templates are in English */
             /* language is known unless error_directory override used */
-            if(!Config.errorDirectory)
+            if (!Config.errorDirectory)
                 rep->header.putStr(HDR_CONTENT_LANGUAGE, "en");
         }
 
@@ -929,7 +926,7 @@ ErrorState::BuildContent()
     /** error_directory option in squid.conf overrides translations.
      * Otherwise locate the Accept-Language header
      */
-    if(!Config.errorDirectory && request && request->header.getList(HDR_ACCEPT_LANGUAGE, &hdr) ) {
+    if (!Config.errorDirectory && request && request->header.getList(HDR_ACCEPT_LANGUAGE, &hdr) ) {
 
         const char *buf = hdr.buf(); // raw header string for parsing
         int pos = 0; // current parsing position in header string
@@ -944,39 +941,38 @@ ErrorState::BuildContent()
 
         debugs(4, 6, HERE << "Testing Header: '" << hdr << "'");
 
-        while( pos < hdr.size() ) {
+        while ( pos < hdr.size() ) {
 
-/*
- * Header value format:
- *  - sequence of whitespace delimited tags
- *  - each tag may suffix with ';'.* which we can ignore.
- *  - IFF a tag contains only two characters we can wildcard ANY translations matching: <it> '-'? .*
- *    with preference given to an exact match.
- */
-            while(pos < hdr.size() && buf[pos] != ';' && buf[pos] != ',' && !xisspace(buf[pos]) && dt < (dir+256) ) {
+            /*
+             * Header value format:
+             *  - sequence of whitespace delimited tags
+             *  - each tag may suffix with ';'.* which we can ignore.
+             *  - IFF a tag contains only two characters we can wildcard ANY translations matching: <it> '-'? .*
+             *    with preference given to an exact match.
+             */
+            while (pos < hdr.size() && buf[pos] != ';' && buf[pos] != ',' && !xisspace(buf[pos]) && dt < (dir+256) ) {
                 *dt++ = xtolower(buf[pos++]);
             }
             *dt++ = '\0'; // nul-terminated the filename content string before system use.
 
             debugs(4, 9, HERE << "STATE: dt='" << dt << "', reset='" << reset << "', reset[1]='" << reset[1] << "', pos=" << pos << ", buf='" << &buf[pos] << "'");
 
             /* if we found anything we might use, try it. */
-            if(*reset != '\0') {
+            if (*reset != '\0') {
 
                 debugs(4, 6, HERE << "Found language '" << reset << "', testing for available template in: '" << dir << "'");
                 m = errorTryLoadText( err_type_str[page_id], dir, false);
 
-                if(m) {
+                if (m) {
                     /* store the language we found for the Content-Language reply header */
                     err_language = xstrdup(reset);
                     break;
-                }
-                else if(Config.errorLogMissingLanguages) {
+                } else if (Config.errorLogMissingLanguages) {
                     debugs(4, DBG_IMPORTANT, "WARNING: Error Pages Missing Language: " << reset);
                 }
 
 #if HAVE_GLOB
-                if( (dt - reset) == 2) {
+                if ( (dt - reset) == 2) {
                     /* TODO glob the error directory for sub-dirs matching: <tag> '-*'   */
                     /* use first result. */
                     debugs(4,2, HERE << "wildcard fallback errors not coded yet.");
@@ -987,8 +983,8 @@ ErrorState::BuildContent()
             dt = reset; // reset for next tag testing. we replace the failed name instead of cloning.
 
             // IFF we terminated the tag on ';' we need to skip the 'q=' bit to the next ',' or end.
-            while(pos < hdr.size() && buf[pos] != ',') pos++;
-            if(buf[pos] == ',') pos++;
+            while (pos < hdr.size() && buf[pos] != ',') pos++;
+            if (buf[pos] == ',') pos++;
         }
     }
 #endif /* USE_ERR_LOCALES */
@@ -997,10 +993,10 @@ ErrorState::BuildContent()
      * If client-specific error templates are not enabled or available.
      * fall back to the old style squid.conf settings.
      */
-    if(!m) {
+    if (!m) {
         m = error_text[page_id];
 #if USE_ERR_LOCALES
-        if(!Config.errorDirectory)
+        if (!Config.errorDirectory)
             err_language = Config.errorDefaultLanguage;
 #endif
         debugs(4, 2, HERE << "No existing error page language negotiated for " << errorPageName(page_id) << ". Using default error file.");
@@ -19,12 +19,12 @@
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
- *  
+ *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
- *  
+ *
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
@@ -44,7 +44,7 @@ class fde
 
 public:
     fde() { clear(); };
-    
+
     /// True if comm_close for this fd has been called
     bool closing() { return flags.close_request; }
 
@@ -65,20 +65,19 @@ class fde
     char ipaddr[MAX_IPSTRLEN];            /* dotted decimal address of peer */
     char desc[FD_DESC_SZ];
 
-    struct
-    {
-	unsigned int open:1;
-	unsigned int close_request:1; // file_ or comm_close has been called
-	unsigned int write_daemon:1;
-	unsigned int socket_eof:1;
-	unsigned int nolinger:1;
-	unsigned int nonblocking:1;
-	unsigned int ipc:1;
-	unsigned int called_connect:1;
-	unsigned int nodelay:1;
-	unsigned int close_on_exec:1;
-	unsigned int read_pending:1;
-	unsigned int write_pending:1;
+    struct {
+        unsigned int open:1;
+        unsigned int close_request:1; // file_ or comm_close has been called
+        unsigned int write_daemon:1;
+        unsigned int socket_eof:1;
+        unsigned int nolinger:1;
+        unsigned int nonblocking:1;
+        unsigned int ipc:1;
+        unsigned int called_connect:1;
+        unsigned int nodelay:1;
+        unsigned int close_on_exec:1;
+        unsigned int read_pending:1;
+        unsigned int write_pending:1;
         unsigned int transparent:1;
     } flags;
 
@@ -109,7 +108,7 @@ class fde
     SSL *ssl;
 #endif
 #ifdef _SQUID_MSWIN_
-    struct { 
+    struct {
         long handle;
     } win32;
 #endif
@@ -127,7 +126,7 @@ class fde
         memset(this, 0, sizeof(fde));
         local_addr.SetEmpty(); // IPAddress likes to be setup nicely.
     }
-    
+
 };
 
 #endif /* SQUID_FDE_H */
@@ -336,8 +336,7 @@ FwdState::complete()
         startComplete(servers);
     } else {
         debugs(17, 3, "fwdComplete: server FD " << server_fd << " not re-forwarding status " << entry->getReply()->sline.status);
-        if (entry->isEmpty() && !err)
-        {
+        if (entry->isEmpty() && !err) {
             EBIT_CLR(entry->flags, ENTRY_FWD_HDR_WAIT);
             entry->complete();
         }
@@ -20,12 +20,12 @@
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
- *  
+ *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
- *  
+ *
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
@@ -92,8 +92,7 @@ typedef enum {
 } ftp_state_t;
 
 /// \ingroup ServerProtocolFTPInternal
-struct _ftp_flags
-{
+struct _ftp_flags {
     bool isdir;
     bool pasv_supported;
     bool epsv_all_sent;
@@ -124,7 +123,8 @@ typedef void (FTPSM) (FtpStateData *);
 
 /// common code for FTP control and data channels
 // does not own the channel descriptor, which is managed by FtpStateData
-class FtpChannel {
+class FtpChannel
+{
 public:
     FtpChannel(): fd(-1) {}
 
@@ -179,8 +179,7 @@ class FtpStateData : public ServerStateData
 
     // \todo: optimize ctrl and data structs member order, to minimize size
     /// FTP control channel info; the channel is opened once per transaction
-    struct CtrlChannel: public FtpChannel
-    {
+    struct CtrlChannel: public FtpChannel {
         char *buf;
         size_t size;
         size_t offset;
@@ -191,8 +190,7 @@ class FtpStateData : public ServerStateData
     } ctrl;
 
     /// FTP data channel info; the channel may be opened/closed a few times
-    struct DataChannel: public FtpChannel
-    {
+    struct DataChannel: public FtpChannel {
         MemBuf *readBuf;
         char *host;
         u_short port;
@@ -282,8 +280,7 @@ FtpStateData::operator delete (void *address)
 }
 
 /// \ingroup ServerProtocolFTPInternal
-typedef struct
-{
+typedef struct {
     char type;
     int64_t size;
     char *date;
@@ -389,42 +386,41 @@ Quit			-
 ************************************************/
 
 /// \ingroup ServerProtocolFTPInternal
-FTPSM *FTP_SM_FUNCS[] =
-    {
-        ftpReadWelcome,		/* BEGIN */
-        ftpReadUser,		/* SENT_USER */
-        ftpReadPass,		/* SENT_PASS */
-        ftpReadType,		/* SENT_TYPE */
-        ftpReadMdtm,		/* SENT_MDTM */
-        ftpReadSize,		/* SENT_SIZE */
-        ftpReadEPRT,		/* SENT_EPRT */
-        ftpReadPORT,		/* SENT_PORT */
-        ftpReadEPSV,		/* SENT_EPSV_ALL */
-        ftpReadEPSV,		/* SENT_EPSV_1 */
-        ftpReadEPSV,		/* SENT_EPSV_2 */
-        ftpReadPasv,		/* SENT_PASV */
-        ftpReadCwd,		/* SENT_CWD */
-        ftpReadList,		/* SENT_LIST */
-        ftpReadList,		/* SENT_NLST */
-        ftpReadRest,		/* SENT_REST */
-        ftpReadRetr,		/* SENT_RETR */
-        ftpReadStor,		/* SENT_STOR */
-        ftpReadQuit,		/* SENT_QUIT */
-        ftpReadTransferDone,	/* READING_DATA (RETR,LIST,NLST) */
-        ftpWriteTransferDone,	/* WRITING_DATA (STOR) */
-        ftpReadMkdir		/* SENT_MKDIR */
-    };
+FTPSM *FTP_SM_FUNCS[] = {
+    ftpReadWelcome,		/* BEGIN */
+    ftpReadUser,		/* SENT_USER */
+    ftpReadPass,		/* SENT_PASS */
+    ftpReadType,		/* SENT_TYPE */
+    ftpReadMdtm,		/* SENT_MDTM */
+    ftpReadSize,		/* SENT_SIZE */
+    ftpReadEPRT,		/* SENT_EPRT */
+    ftpReadPORT,		/* SENT_PORT */
+    ftpReadEPSV,		/* SENT_EPSV_ALL */
+    ftpReadEPSV,		/* SENT_EPSV_1 */
+    ftpReadEPSV,		/* SENT_EPSV_2 */
+    ftpReadPasv,		/* SENT_PASV */
+    ftpReadCwd,		/* SENT_CWD */
+    ftpReadList,		/* SENT_LIST */
+    ftpReadList,		/* SENT_NLST */
+    ftpReadRest,		/* SENT_REST */
+    ftpReadRetr,		/* SENT_RETR */
+    ftpReadStor,		/* SENT_STOR */
+    ftpReadQuit,		/* SENT_QUIT */
+    ftpReadTransferDone,	/* READING_DATA (RETR,LIST,NLST) */
+    ftpWriteTransferDone,	/* WRITING_DATA (STOR) */
+    ftpReadMkdir		/* SENT_MKDIR */
+};
 
 /// handler called by Comm when FTP control channel is closed unexpectedly
-void 
+void
 FtpStateData::ctrlClosed(const CommCloseCbParams &io)
 {
     ctrl.clear();
     deleteThis("FtpStateData::ctrlClosed");
 }
 
 /// handler called by Comm when FTP data channel is closed unexpectedly
-void 
+void
 FtpStateData::dataClosed(const CommCloseCbParams &io)
 {
     data.clear();
@@ -453,7 +449,7 @@ FtpStateData::FtpStateData(FwdState *theFwdState) : AsyncJob("FtpStateData"), Se
 
     typedef CommCbMemFunT<FtpStateData, CommCloseCbParams> Dialer;
     AsyncCall::Pointer closer = asyncCall(9, 5, "FtpStateData::ctrlClosed",
-        Dialer(this, &FtpStateData::ctrlClosed));
+                                          Dialer(this, &FtpStateData::ctrlClosed));
     ctrl.opened(theFwdState->server_fd, closer);
 
     if (request->method == METHOD_PUT)
@@ -473,7 +469,7 @@ FtpStateData::~FtpStateData()
 
     if (ctrl.fd >= 0) {
         debugs(9, DBG_IMPORTANT, HERE << "Internal bug: FtpStateData left " <<
-            "control FD " << ctrl.fd << " open");
+               "control FD " << ctrl.fd << " open");
     }
 
     if (ctrl.buf) {
@@ -483,7 +479,7 @@ FtpStateData::~FtpStateData()
 
     if (data.readBuf) {
         if (!data.readBuf->isNull())
-           data.readBuf->clean();
+            data.readBuf->clean();
 
         delete data.readBuf;
     }
@@ -675,11 +671,10 @@ FtpStateData::listingFinish()
 }
 
 /// \ingroup ServerProtocolFTPInternal
-static const char *Month[] =
-    {
-        "Jan", "Feb", "Mar", "Apr", "May", "Jun",
-        "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
-    };
+static const char *Month[] = {
+    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
+    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
+};
 
 /// \ingroup ServerProtocolFTPInternal
 static int
@@ -726,8 +721,7 @@ ftpListParseParts(const char *buf, struct _ftp_flags flags)
     static regex_t scan_ftp_dostime;
     static regex_t scan_ftp_dosdate;
 
-    if (!scan_ftp_initialized)
-    {
+    if (!scan_ftp_initialized) {
         scan_ftp_initialized = 1;
         regcomp(&scan_ftp_integer, "^[0123456789]+$", REG_EXTENDED | REG_NOSUB);
         regcomp(&scan_ftp_time, "^[0123456789:]+$", REG_EXTENDED | REG_NOSUB);
@@ -749,8 +743,7 @@ ftpListParseParts(const char *buf, struct _ftp_flags flags)
 
     xbuf = xstrdup(buf);
 
-    if (flags.tried_nlst)
-    {
+    if (flags.tried_nlst) {
         /* Machine readable format, one name per line */
         p->name = xbuf;
         p->type = '\0';
@@ -763,8 +756,7 @@ ftpListParseParts(const char *buf, struct _ftp_flags flags)
     xfree(xbuf);
 
     /* locate the Month field */
-    for (i = 3; i < n_tokens - 2; i++)
-    {
+    for (i = 3; i < n_tokens - 2; i++) {
         char *size = tokens[i - 1];
         char *month = tokens[i];
         char *day = tokens[i + 1];
@@ -824,8 +816,7 @@ ftpListParseParts(const char *buf, struct _ftp_flags flags)
     /* try it as a DOS listing, 04-05-70 09:33PM ... */
     if (n_tokens > 3 &&
             regexec(&scan_ftp_dosdate, tokens[0], 0, NULL, 0) == 0 &&
-            regexec(&scan_ftp_dostime, tokens[1], 0, NULL, 0) == 0)
-    {
+            regexec(&scan_ftp_dostime, tokens[1], 0, NULL, 0) == 0) {
         if (!strcasecmp(tokens[2], "<dir>")) {
             p->type = 'd';
         } else {
@@ -861,8 +852,7 @@ ftpListParseParts(const char *buf, struct _ftp_flags flags)
     }
 
     /* Try EPLF format; carson@lehman.com */
-    if (buf[0] == '+')
-    {
+    if (buf[0] == '+') {
         ct = buf + 1;
         p->type = 0;
 
@@ -1233,7 +1223,8 @@ FtpStateData::parseListing()
 }
 
 int
-FtpStateData::dataDescriptor() const {
+FtpStateData::dataDescriptor() const
+{
     return data.fd;
 }
 
@@ -1279,15 +1270,15 @@ FtpStateData::maybeReadVirginBody()
 
     typedef CommCbMemFunT<FtpStateData, CommTimeoutCbParams> TimeoutDialer;
     AsyncCall::Pointer timeoutCall =  asyncCall(9, 5, "FtpStateData::ftpTimeout",
-                        TimeoutDialer(this,&FtpStateData::ftpTimeout));
+                                      TimeoutDialer(this,&FtpStateData::ftpTimeout));
     commSetTimeout(data.fd, Config.Timeout.read, timeoutCall);
 
     debugs(9,5,HERE << "queueing read on FD " << data.fd);
 
     typedef CommCbMemFunT<FtpStateData, CommIoCbParams> Dialer;
     entry->delayAwareRead(data.fd, data.readBuf->space(), read_sz,
-	asyncCall(9, 5, "FtpStateData::dataRead",
-	      Dialer(this, &FtpStateData::dataRead)));
+                          asyncCall(9, 5, "FtpStateData::dataRead",
+                                    Dialer(this, &FtpStateData::dataRead)));
 }
 
 void
@@ -1347,13 +1338,13 @@ FtpStateData::dataRead(const CommIoCbParams &io)
     }
 
     if (io.flag != COMM_OK || io.size < 0) {
-         debugs(50, ignoreErrno(io.xerrno) ? 3 : DBG_IMPORTANT,
-             "ftpDataRead: read error: " << xstrerr(io.xerrno));
+        debugs(50, ignoreErrno(io.xerrno) ? 3 : DBG_IMPORTANT,
+               "ftpDataRead: read error: " << xstrerr(io.xerrno));
 
         if (ignoreErrno(io.xerrno)) {
             typedef CommCbMemFunT<FtpStateData, CommTimeoutCbParams> TimeoutDialer;
             AsyncCall::Pointer timeoutCall =  asyncCall(9, 5, "FtpStateData::ftpTimeout",
-                        TimeoutDialer(this,&FtpStateData::ftpTimeout));
+                                              TimeoutDialer(this,&FtpStateData::ftpTimeout));
             commSetTimeout(io.fd, Config.Timeout.read, timeoutCall);
 
             maybeReadVirginBody();
@@ -1369,16 +1360,16 @@ FtpStateData::dataRead(const CommIoCbParams &io)
         }
     } else if (io.size == 0) {
         debugs(9,3, HERE << "Calling dataComplete() because io.size == 0");
-	/*
-	 * DPW 2007-04-23
-	 * Dangerous curves ahead.  This call to dataComplete was
-	 * calling scheduleReadControlReply, handleControlReply,
-	 * and then ftpReadTransferDone.  If ftpReadTransferDone
-	 * gets unexpected status code, it closes down the control
-	 * socket and our FtpStateData object gets destroyed.   As
-	 * a workaround we no longer set the 'buffered_ok' flag in
-	 * the scheduleReadControlReply call.
-	 */
+        /*
+         * DPW 2007-04-23
+         * Dangerous curves ahead.  This call to dataComplete was
+         * calling scheduleReadControlReply, handleControlReply,
+         * and then ftpReadTransferDone.  If ftpReadTransferDone
+         * gets unexpected status code, it closes down the control
+         * socket and our FtpStateData object gets destroyed.   As
+         * a workaround we no longer set the 'buffered_ok' flag in
+         * the scheduleReadControlReply call.
+         */
         dataComplete();
     }
 
@@ -1399,10 +1390,10 @@ FtpStateData::processReplyBody()
         appendSuccessHeader();
 
     if (EBIT_TEST(entry->flags, ENTRY_ABORTED)) {
-	/*
-	 * probably was aborted because content length exceeds one
-	 * of the maximum size limits.
-	 */
+        /*
+         * probably was aborted because content length exceeds one
+         * of the maximum size limits.
+         */
         abortTransaction("entry aborted after calling appendSuccessHeader()");
         return;
     }
@@ -1421,12 +1412,12 @@ FtpStateData::processReplyBody()
 
     if (flags.isdir) {
         parseListing();
-    } else 
-    if (const int csize = data.readBuf->contentSize()) {
-        writeReplyBody(data.readBuf->content(), csize);
-        debugs(9, 5, HERE << "consuming " << csize << " bytes of readBuf");
-        data.readBuf->consume(csize);
-    }
+    } else
+        if (const int csize = data.readBuf->contentSize()) {
+            writeReplyBody(data.readBuf->content(), csize);
+            debugs(9, 5, HERE << "consuming " << csize << " bytes of readBuf");
+            data.readBuf->consume(csize);
+        }
 
     entry->flush();
 
@@ -1644,11 +1635,11 @@ FtpStateData::writeCommand(const char *buf)
 
     typedef CommCbMemFunT<FtpStateData, CommIoCbParams> Dialer;
     AsyncCall::Pointer call = asyncCall(9, 5, "FtpStateData::ftpWriteCommandCallback",
-					Dialer(this, &FtpStateData::ftpWriteCommandCallback));
+                                        Dialer(this, &FtpStateData::ftpWriteCommandCallback));
     comm_write(ctrl.fd,
                ctrl.last_command,
                strlen(ctrl.last_command),
-	       call);
+               call);
 
     scheduleReadControlReply(0);
 }
@@ -1780,23 +1771,23 @@ FtpStateData::scheduleReadControlReply(int buffered_ok)
         handleControlReply();
     } else {
         /* XXX What about Config.Timeout.read? */
-	typedef CommCbMemFunT<FtpStateData, CommIoCbParams> Dialer;
-	AsyncCall::Pointer reader=asyncCall(9, 5, "FtpStateData::ftpReadControlReply",
-				    Dialer(this, &FtpStateData::ftpReadControlReply));
-	comm_read(ctrl.fd, ctrl.buf + ctrl.offset, ctrl.size - ctrl.offset, reader);
+        typedef CommCbMemFunT<FtpStateData, CommIoCbParams> Dialer;
+        AsyncCall::Pointer reader=asyncCall(9, 5, "FtpStateData::ftpReadControlReply",
+                                            Dialer(this, &FtpStateData::ftpReadControlReply));
+        comm_read(ctrl.fd, ctrl.buf + ctrl.offset, ctrl.size - ctrl.offset, reader);
         /*
          * Cancel the timeout on the Data socket (if any) and
          * establish one on the control socket.
          */
 
-        if (data.fd > -1){
-	    AsyncCall::Pointer nullCall =  NULL;
+        if (data.fd > -1) {
+            AsyncCall::Pointer nullCall =  NULL;
             commSetTimeout(data.fd, -1, nullCall);
-	}
+        }
 
-	typedef CommCbMemFunT<FtpStateData, CommTimeoutCbParams> TimeoutDialer;
-	AsyncCall::Pointer timeoutCall =  asyncCall(9, 5, "FtpStateData::ftpTimeout",
-					    TimeoutDialer(this,&FtpStateData::ftpTimeout));
+        typedef CommCbMemFunT<FtpStateData, CommTimeoutCbParams> TimeoutDialer;
+        AsyncCall::Pointer timeoutCall =  asyncCall(9, 5, "FtpStateData::ftpTimeout",
+                                          TimeoutDialer(this,&FtpStateData::ftpTimeout));
 
         commSetTimeout(ctrl.fd, Config.Timeout.read, timeoutCall);
     }
@@ -1826,8 +1817,8 @@ void FtpStateData::ftpReadControlReply(const CommIoCbParams &io)
     }
 
     if (io.flag != COMM_OK || io.size < 0) {
-        debugs(50, ignoreErrno(io.xerrno) ? 3 : DBG_IMPORTANT, 
-            "ftpReadControlReply: read error: " << xstrerr(io.xerrno));
+        debugs(50, ignoreErrno(io.xerrno) ? 3 : DBG_IMPORTANT,
+               "ftpReadControlReply: read error: " << xstrerr(io.xerrno));
 
         if (ignoreErrno(io.xerrno)) {
             scheduleReadControlReply(0);
@@ -1847,7 +1838,7 @@ void FtpStateData::ftpReadControlReply(const CommIoCbParams &io)
             return;
         }
 
-    /* XXX this may end up having to be serverComplete() .. */
+        /* XXX this may end up having to be serverComplete() .. */
         abortTransaction("zero control reply read");
         return;
     }
@@ -1942,7 +1933,7 @@ static void
 ftpSendUser(FtpStateData * ftpState)
 {
     /* check the server control channel is still available */
-    if(!ftpState || !ftpState->haveControlChannel("ftpSendUser"))
+    if (!ftpState || !ftpState->haveControlChannel("ftpSendUser"))
         return;
 
     if (ftpState->proxy_host != NULL)
@@ -1978,7 +1969,7 @@ static void
 ftpSendPass(FtpStateData * ftpState)
 {
     /* check the server control channel is still available */
-    if(!ftpState || !ftpState->haveControlChannel("ftpSendPass"))
+    if (!ftpState || !ftpState->haveControlChannel("ftpSendPass"))
         return;
 
     snprintf(cbuf, 1024, "PASS %s\r\n", ftpState->password);
@@ -2009,7 +2000,7 @@ ftpSendType(FtpStateData * ftpState)
     char mode;
 
     /* check the server control channel is still available */
-    if(!ftpState || !ftpState->haveControlChannel("ftpSendType"))
+    if (!ftpState || !ftpState->haveControlChannel("ftpSendType"))
         return;
 
     /*
@@ -2137,7 +2128,7 @@ ftpSendCwd(FtpStateData * ftpState)
     char *path = NULL;
 
     /* check the server control channel is still available */
-    if(!ftpState || !ftpState->haveControlChannel("ftpSendCwd"))
+    if (!ftpState || !ftpState->haveControlChannel("ftpSendCwd"))
         return;
 
     debugs(9, 3, HERE);
@@ -2195,7 +2186,7 @@ ftpSendMkdir(FtpStateData * ftpState)
     char *path = NULL;
 
     /* check the server control channel is still available */
-    if(!ftpState || !ftpState->haveControlChannel("ftpSendMkdir"))
+    if (!ftpState || !ftpState->haveControlChannel("ftpSendMkdir"))
         return;
 
     path = ftpState->filepath;
@@ -2254,7 +2245,7 @@ static void
 ftpSendMdtm(FtpStateData * ftpState)
 {
     /* check the server control channel is still available */
-    if(!ftpState || !ftpState->haveControlChannel("ftpSendMdtm"))
+    if (!ftpState || !ftpState->haveControlChannel("ftpSendMdtm"))
         return;
 
     assert(*ftpState->filepath != '\0');
@@ -2275,7 +2266,7 @@ ftpReadMdtm(FtpStateData * ftpState)
         ftpState->unhack();
     } else if (code < 0) {
         ftpFail(ftpState);
-	return;
+        return;
     }
 
     ftpSendSize(ftpState);
@@ -2286,7 +2277,7 @@ static void
 ftpSendSize(FtpStateData * ftpState)
 {
     /* check the server control channel is still available */
-    if(!ftpState || !ftpState->haveControlChannel("ftpSendSize"))
+    if (!ftpState || !ftpState->haveControlChannel("ftpSendSize"))
         return;
 
     /* Only send SIZE for binary transfers. The returned size
@@ -2316,13 +2307,13 @@ ftpReadSize(FtpStateData * ftpState)
 
         if (ftpState->theSize == 0) {
             debugs(9, 2, "SIZE reported " <<
-                         ftpState->ctrl.last_reply << " on " << 
-                         ftpState->title_url.buf());
+                   ftpState->ctrl.last_reply << " on " <<
+                   ftpState->title_url.buf());
             ftpState->theSize = -1;
         }
     } else if (code < 0) {
         ftpFail(ftpState);
-	return;
+        return;
     }
 
     ftpSendPassive(ftpState);
@@ -2344,43 +2335,39 @@ ftpReadEPSV(FtpStateData* ftpState)
     debugs(9, 3, HERE);
 
     if (code != 229 && code != 522) {
-        if(code == 200) {
+        if (code == 200) {
             /* handle broken servers (RFC 2428 says OK code for EPSV MUST be 229 not 200) */
             /* vsftpd for one send '200 EPSV ALL ok.' without even port info.
              * Its okay to re-send EPSV 1/2 but nothing else. */
             debugs(9, DBG_IMPORTANT, "Broken FTP Server at " << fd_table[ftpState->ctrl.fd].ipaddr << ". Wrong accept code for EPSV");
-        }
-        else {
+        } else {
             debugs(9, 2, "EPSV not supported by remote end");
             ftpState->state = SENT_EPSV_1; /* simulate having failed EPSV 1 (last EPSV to try before shifting to PASV) */
         }
         ftpSendPassive(ftpState);
         return;
     }
 
-    if(code == 522) {
+    if (code == 522) {
         /* server response with list of supported methods   */
         /*   522 Network protocol not supported, use (1)    */
         /*   522 Network protocol not supported, use (1,2)  */
         debugs(9, 5, HERE << "scanning: " << ftpState->ctrl.last_reply);
 
         buf = ftpState->ctrl.last_reply + strcspn(ftpState->ctrl.last_reply, "(1,2)");
-        if(buf == NULL || *buf == '\0') {
+        if (buf == NULL || *buf == '\0') {
             /* handle broken server (RFC 2428 says MUST specify supported protocols in 522) */
             debugs(9, DBG_IMPORTANT, "Broken FTP Server at " << fd_table[ftpState->ctrl.fd].ipaddr << ". 522 error missing protocol negotiation hints");
             ftpSendPassive(ftpState);
-        }
-        else if(strcmp(buf, "(1)") == 0) {
+        } else if (strcmp(buf, "(1)") == 0) {
             ftpState->state = SENT_EPSV_2; /* simulate having sent and failed EPSV 2 */
             ftpSendPassive(ftpState);
-        }
-        else if(strcmp(buf, "(2)") == 0) {
+        } else if (strcmp(buf, "(2)") == 0) {
 #if USE_IPV6
             /* If server only supports EPSV 2 and we have already tried that. Go straight to EPRT */
-            if(ftpState->state == SENT_EPSV_2) {
+            if (ftpState->state == SENT_EPSV_2) {
                 ftpSendEPRT(ftpState);
-            }
-            else {
+            } else {
                 /* or try the next Passive mode down the chain. */
                 ftpSendPassive(ftpState);
             }
@@ -2459,7 +2446,7 @@ ftpSendPassive(FtpStateData * ftpState)
     struct addrinfo *AI = NULL;
 
     /** Checks the server control channel is still available before running. */
-    if(!ftpState || !ftpState->haveControlChannel("ftpSendPassive"))
+    if (!ftpState || !ftpState->haveControlChannel("ftpSendPassive"))
         return;
 
     debugs(9, 3, HERE);
@@ -2469,7 +2456,7 @@ ftpSendPassive(FtpStateData * ftpState)
       * If enabled to be sent, squid MUST NOT request any other connect methods.
       * If 'ALL' is sent and fails the entire FTP Session fails.
       * NP: By my reading exact EPSV protocols maybe attempted, but only EPSV method. */
-    if(Config.Ftp.epsv_all && ftpState->flags.epsv_all_sent && ftpState->state == SENT_EPSV_1 ) {
+    if (Config.Ftp.epsv_all && ftpState->flags.epsv_all_sent && ftpState->state == SENT_EPSV_1 ) {
         debugs(9, DBG_IMPORTANT, "FTP does not allow PASV method after 'EPSV ALL' has been sent.");
         ftpFail(ftpState);
         return;
@@ -2534,7 +2521,7 @@ ftpSendPassive(FtpStateData * ftpState)
       \item EPSV 1    is used if EPSV 2 (IPv6) fails or is not available.
       \item PASV      is used if EPSV 1 fails.
       */
-    switch(ftpState->state) {
+    switch (ftpState->state) {
     case SENT_EPSV_1: /* EPSV options exhausted. Try PASV now. */
         snprintf(cbuf, 1024, "PASV\r\n");
         ftpState->state = SENT_PASV;
@@ -2552,13 +2539,12 @@ ftpSendPassive(FtpStateData * ftpState)
         break;
 
     default:
-        if(Config.Ftp.epsv_all) {
+        if (Config.Ftp.epsv_all) {
             snprintf(cbuf, 1024, "EPSV ALL\r\n");
             ftpState->state = SENT_EPSV_ALL;
             /* block other non-EPSV connections being attempted */
             ftpState->flags.epsv_all_sent = true;
-        }
-        else {
+        } else {
 #if USE_IPV6
             snprintf(cbuf, 1024, "EPSV 2\r\n");
             ftpState->state = SENT_EPSV_2;
@@ -2578,7 +2564,7 @@ ftpSendPassive(FtpStateData * ftpState)
      */
     typedef CommCbMemFunT<FtpStateData, CommTimeoutCbParams> TimeoutDialer;
     AsyncCall::Pointer timeoutCall =  asyncCall(9, 5, "FtpStateData::ftpTimeout",
-					    TimeoutDialer(ftpState,&FtpStateData::ftpTimeout));
+                                      TimeoutDialer(ftpState,&FtpStateData::ftpTimeout));
 
     commSetTimeout(ftpState->data.fd, 15, timeoutCall);
 }
@@ -2608,7 +2594,7 @@ FtpStateData::processHeadResponse()
 #endif
 
     // processReplyBody calls serverComplete() since there is no body
-    processReplyBody(); 
+    processReplyBody();
 }
 
 /// \ingroup ServerProtocolFTPInternal
@@ -2653,7 +2639,7 @@ ftpReadPasv(FtpStateData * ftpState)
 
     ipa_remote = ipaddr;
 
-    if( ipa_remote.IsAnyAddr() ) {
+    if ( ipa_remote.IsAnyAddr() ) {
         debugs(9, DBG_IMPORTANT, "Unsafe PASV reply from " <<
                fd_table[ftpState->ctrl.fd].ipaddr << ": " <<
                ftpState->ctrl.last_reply);
@@ -2747,7 +2733,7 @@ ftpOpenListenSocket(FtpStateData * ftpState, int fallback)
 
     addr.FreeAddrInfo(AI);
 
-    if(x) {
+    if (x) {
         debugs(9, DBG_CRITICAL, HERE << "getsockname(" << ftpState->ctrl.fd << ",..): " << xstrerror());
         return -1;
     }
@@ -2758,8 +2744,7 @@ ftpOpenListenSocket(FtpStateData * ftpState, int fallback)
      */
     if (fallback) {
         setsockopt(ftpState->ctrl.fd, SOL_SOCKET, SO_REUSEADDR, (char *) &on, sizeof(on));
-    }
-    else {
+    } else {
         /* if not running in fallback mode a new port needs to be retrieved */
         addr.SetPort(0);
     }
@@ -2799,10 +2784,10 @@ ftpSendPORT(FtpStateData * ftpState)
     unsigned char *portptr;
 
     /* check the server control channel is still available */
-    if(!ftpState || !ftpState->haveControlChannel("ftpSendPort"))
+    if (!ftpState || !ftpState->haveControlChannel("ftpSendPort"))
         return;
 
-    if(Config.Ftp.epsv_all && ftpState->flags.epsv_all_sent) {
+    if (Config.Ftp.epsv_all && ftpState->flags.epsv_all_sent) {
         debugs(9, DBG_IMPORTANT, "FTP does not allow PORT method after 'EPSV ALL' has been sent.");
         return;
     }
@@ -2822,13 +2807,13 @@ ftpSendPORT(FtpStateData * ftpState)
     }
 
 #if USE_IPV6
-    if( AI->ai_addrlen != sizeof(struct sockaddr_in) ) {
+    if ( AI->ai_addrlen != sizeof(struct sockaddr_in) ) {
         ipa.FreeAddrInfo(AI);
-       /* IPv6 CANNOT send PORT command.                           */
-       /* we got here by attempting and failing an EPRT            */
-       /* using the same reply code should simulate a PORT failure */
-       ftpReadPORT(ftpState);
-       return;
+        /* IPv6 CANNOT send PORT command.                           */
+        /* we got here by attempting and failing an EPRT            */
+        /* using the same reply code should simulate a PORT failure */
+        ftpReadPORT(ftpState);
+        return;
     }
 #endif
 
@@ -2868,7 +2853,7 @@ ftpSendEPRT(FtpStateData * ftpState)
     struct addrinfo *AI = NULL;
     char buf[MAX_IPSTRLEN];
 
-    if(Config.Ftp.epsv_all && ftpState->flags.epsv_all_sent) {
+    if (Config.Ftp.epsv_all && ftpState->flags.epsv_all_sent) {
         debugs(9, DBG_IMPORTANT, "FTP does not allow EPRT method after 'EPSV ALL' has been sent.");
         return;
     }
@@ -2948,15 +2933,15 @@ void FtpStateData::ftpAcceptDataConnection(const CommAcceptCbParams &io)
         io.details.peer.NtoA(ntoapeer,MAX_IPSTRLEN);
 
         if (strcmp(fd_table[ctrl.fd].ipaddr, ntoapeer) != 0) {
-            debugs(9, DBG_IMPORTANT, 
-                "FTP data connection from unexpected server (" <<
-                io.details.peer << "), expecting " <<
-                fd_table[ctrl.fd].ipaddr);
+            debugs(9, DBG_IMPORTANT,
+                   "FTP data connection from unexpected server (" <<
+                   io.details.peer << "), expecting " <<
+                   fd_table[ctrl.fd].ipaddr);
 
             comm_close(io.nfd);
-	    typedef CommCbMemFunT<FtpStateData, CommAcceptCbParams> acceptDialer;
-	    AsyncCall::Pointer acceptCall = asyncCall(11, 5, "FtpStateData::ftpAcceptDataConnection",
-                        acceptDialer(this, &FtpStateData::ftpAcceptDataConnection));
+            typedef CommCbMemFunT<FtpStateData, CommAcceptCbParams> acceptDialer;
+            AsyncCall::Pointer acceptCall = asyncCall(11, 5, "FtpStateData::ftpAcceptDataConnection",
+                                            acceptDialer(this, &FtpStateData::ftpAcceptDataConnection));
             comm_accept(data.fd, acceptCall);
             return;
         }
@@ -2977,17 +2962,17 @@ void FtpStateData::ftpAcceptDataConnection(const CommAcceptCbParams &io)
     io.details.peer.NtoA(data.host,SQUIDHOSTNAMELEN);
 
     debugs(9, 3, "ftpAcceptDataConnection: Connected data socket on " <<
-        "FD " << io.nfd << " to " << io.details.peer << " FD table says: " <<
-        "ctrl-peer= " << fd_table[ctrl.fd].ipaddr << ", " <<
-        "data-peer= " << fd_table[data.fd].ipaddr);
+           "FD " << io.nfd << " to " << io.details.peer << " FD table says: " <<
+           "ctrl-peer= " << fd_table[ctrl.fd].ipaddr << ", " <<
+           "data-peer= " << fd_table[data.fd].ipaddr);
 
 
     AsyncCall::Pointer nullCall = NULL;
     commSetTimeout(ctrl.fd, -1, nullCall);
 
     typedef CommCbMemFunT<FtpStateData, CommTimeoutCbParams> TimeoutDialer;
     AsyncCall::Pointer timeoutCall =  asyncCall(9, 5, "FtpStateData::ftpTimeout",
-					    TimeoutDialer(this,&FtpStateData::ftpTimeout));
+                                      TimeoutDialer(this,&FtpStateData::ftpTimeout));
     commSetTimeout(data.fd, Config.Timeout.read, timeoutCall);
 
     /*\todo XXX We should have a flag to track connect state...
@@ -3027,7 +3012,7 @@ static void
 ftpSendStor(FtpStateData * ftpState)
 {
     /* check the server control channel is still available */
-    if(!ftpState || !ftpState->haveControlChannel("ftpSendStor"))
+    if (!ftpState || !ftpState->haveControlChannel("ftpSendStor"))
         return;
 
     debugs(9, 3, HERE);
@@ -3056,7 +3041,8 @@ ftpReadStor(FtpStateData * ftpState)
     ftpState->readStor();
 }
 
-void FtpStateData::readStor() {
+void FtpStateData::readStor()
+{
     int code = ctrl.replycode;
     debugs(9, 3, HERE);
 
@@ -3074,12 +3060,12 @@ void FtpStateData::readStor() {
          * Cancel the timeout on the Control socket and
          * establish one on the data socket.
          */
-	AsyncCall::Pointer nullCall = NULL;
+        AsyncCall::Pointer nullCall = NULL;
         commSetTimeout(ctrl.fd, -1, nullCall);
 
-	typedef CommCbMemFunT<FtpStateData, CommTimeoutCbParams> TimeoutDialer;
-	AsyncCall::Pointer timeoutCall =  asyncCall(9, 5, "FtpStateData::ftpTimeout",
-					    TimeoutDialer(this,&FtpStateData::ftpTimeout));
+        typedef CommCbMemFunT<FtpStateData, CommTimeoutCbParams> TimeoutDialer;
+        AsyncCall::Pointer timeoutCall =  asyncCall(9, 5, "FtpStateData::ftpTimeout",
+                                          TimeoutDialer(this,&FtpStateData::ftpTimeout));
 
         commSetTimeout(data.fd, Config.Timeout.read, timeoutCall);
 
@@ -3091,7 +3077,7 @@ void FtpStateData::readStor() {
         debugs(9, 3, "ftpReadStor: accepting data channel");
         typedef CommCbMemFunT<FtpStateData, CommAcceptCbParams> acceptDialer;
         AsyncCall::Pointer acceptCall = asyncCall(11, 5, "FtpStateData::ftpAcceptDataConnection",
-            acceptDialer(this, &FtpStateData::ftpAcceptDataConnection));
+                                        acceptDialer(this, &FtpStateData::ftpAcceptDataConnection));
 
         comm_accept(data.fd, acceptCall);
     } else {
@@ -3105,7 +3091,7 @@ static void
 ftpSendRest(FtpStateData * ftpState)
 {
     /* check the server control channel is still available */
-    if(!ftpState || !ftpState->haveControlChannel("ftpSendRest"))
+    if (!ftpState || !ftpState->haveControlChannel("ftpSendRest"))
         return;
 
     debugs(9, 3, HERE);
@@ -3136,7 +3122,7 @@ FtpStateData::restartable()
         return 0;
 
     if (desired_offset >= theSize)
-	return 0;
+        return 0;
 
     restart_offset = desired_offset;
     return 1;
@@ -3167,7 +3153,7 @@ static void
 ftpSendList(FtpStateData * ftpState)
 {
     /* check the server control channel is still available */
-    if(!ftpState || !ftpState->haveControlChannel("ftpSendList"))
+    if (!ftpState || !ftpState->haveControlChannel("ftpSendList"))
         return;
 
     debugs(9, 3, HERE);
@@ -3187,7 +3173,7 @@ static void
 ftpSendNlst(FtpStateData * ftpState)
 {
     /* check the server control channel is still available */
-    if(!ftpState || !ftpState->haveControlChannel("ftpSendNlst"))
+    if (!ftpState || !ftpState->haveControlChannel("ftpSendNlst"))
         return;
 
     debugs(9, 3, HERE);
@@ -3220,26 +3206,26 @@ ftpReadList(FtpStateData * ftpState)
          * Cancel the timeout on the Control socket and establish one
          * on the data socket
          */
-	AsyncCall::Pointer nullCall = NULL;
+        AsyncCall::Pointer nullCall = NULL;
         commSetTimeout(ftpState->ctrl.fd, -1, nullCall);
         return;
     } else if (code == 150) {
         /* Accept data channel */
-	typedef CommCbMemFunT<FtpStateData, CommAcceptCbParams> acceptDialer;
-	AsyncCall::Pointer acceptCall = asyncCall(11, 5, "FtpStateData::ftpAcceptDataConnection",
-			       acceptDialer(ftpState, &FtpStateData::ftpAcceptDataConnection));
+        typedef CommCbMemFunT<FtpStateData, CommAcceptCbParams> acceptDialer;
+        AsyncCall::Pointer acceptCall = asyncCall(11, 5, "FtpStateData::ftpAcceptDataConnection",
+                                        acceptDialer(ftpState, &FtpStateData::ftpAcceptDataConnection));
 
         comm_accept(ftpState->data.fd, acceptCall);
         /*
          * Cancel the timeout on the Control socket and establish one
          * on the data socket
          */
-	AsyncCall::Pointer nullCall = NULL;
+        AsyncCall::Pointer nullCall = NULL;
         commSetTimeout(ftpState->ctrl.fd, -1, nullCall);
-	
-	typedef CommCbMemFunT<FtpStateData, CommTimeoutCbParams> TimeoutDialer;
-	AsyncCall::Pointer timeoutCall =  asyncCall(9, 5, "FtpStateData::ftpTimeout",
-					    TimeoutDialer(ftpState,&FtpStateData::ftpTimeout));
+
+        typedef CommCbMemFunT<FtpStateData, CommTimeoutCbParams> TimeoutDialer;
+        AsyncCall::Pointer timeoutCall =  asyncCall(9, 5, "FtpStateData::ftpTimeout",
+                                          TimeoutDialer(ftpState,&FtpStateData::ftpTimeout));
         commSetTimeout(ftpState->data.fd, Config.Timeout.read, timeoutCall);
         return;
     } else if (!ftpState->flags.tried_nlst && code > 300) {
@@ -3255,7 +3241,7 @@ static void
 ftpSendRetr(FtpStateData * ftpState)
 {
     /* check the server control channel is still available */
-    if(!ftpState || !ftpState->haveControlChannel("ftpSendRetr"))
+    if (!ftpState || !ftpState->haveControlChannel("ftpSendRetr"))
         return;
 
     debugs(9, 3, HERE);
@@ -3283,24 +3269,24 @@ ftpReadRetr(FtpStateData * ftpState)
          * Cancel the timeout on the Control socket and establish one
          * on the data socket
          */
-	AsyncCall::Pointer nullCall = NULL;
+        AsyncCall::Pointer nullCall = NULL;
         commSetTimeout(ftpState->ctrl.fd, -1, nullCall);
     } else if (code == 150) {
         /* Accept data channel */
-	typedef CommCbMemFunT<FtpStateData, CommAcceptCbParams> acceptDialer;
-	AsyncCall::Pointer acceptCall = asyncCall(11, 5, "FtpStateData::ftpAcceptDataConnection",
-                        acceptDialer(ftpState, &FtpStateData::ftpAcceptDataConnection));
+        typedef CommCbMemFunT<FtpStateData, CommAcceptCbParams> acceptDialer;
+        AsyncCall::Pointer acceptCall = asyncCall(11, 5, "FtpStateData::ftpAcceptDataConnection",
+                                        acceptDialer(ftpState, &FtpStateData::ftpAcceptDataConnection));
         comm_accept(ftpState->data.fd, acceptCall);
         /*
          * Cancel the timeout on the Control socket and establish one
          * on the data socket
          */
-	AsyncCall::Pointer nullCall = NULL;
+        AsyncCall::Pointer nullCall = NULL;
         commSetTimeout(ftpState->ctrl.fd, -1, nullCall);
 
-	typedef CommCbMemFunT<FtpStateData, CommTimeoutCbParams> TimeoutDialer;
-	AsyncCall::Pointer timeoutCall =  asyncCall(9, 5, "FtpStateData::ftpTimeout",
-					    TimeoutDialer(ftpState,&FtpStateData::ftpTimeout));
+        typedef CommCbMemFunT<FtpStateData, CommTimeoutCbParams> TimeoutDialer;
+        AsyncCall::Pointer timeoutCall =  asyncCall(9, 5, "FtpStateData::ftpTimeout",
+                                          TimeoutDialer(ftpState,&FtpStateData::ftpTimeout));
         commSetTimeout(ftpState->data.fd, Config.Timeout.read, timeoutCall);
     } else if (code >= 300) {
         if (!ftpState->flags.try_slash_hack) {
@@ -3378,7 +3364,7 @@ static void
 ftpSendQuit(FtpStateData * ftpState)
 {
     /* check the server control channel is still available */
-    if(!ftpState || !ftpState->haveControlChannel("ftpSendQuit"))
+    if (!ftpState || !ftpState->haveControlChannel("ftpSendQuit"))
         return;
 
     snprintf(cbuf, 1024, "QUIT\r\n");
@@ -3463,10 +3449,10 @@ static void
 ftpFail(FtpStateData *ftpState)
 {
     debugs(9, 6, HERE << "flags(" <<
-            (ftpState->flags.isdir?"IS_DIR,":"") <<
-            (ftpState->flags.try_slash_hack?"TRY_SLASH_HACK":"") << "), " <<
-            "mdtm=" << ftpState->mdtm << ", size=" << ftpState->theSize <<
-            "slashhack=" << (ftpState->request->urlpath.caseCmp("/%2f", 4)==0? "T":"F") );
+           (ftpState->flags.isdir?"IS_DIR,":"") <<
+           (ftpState->flags.try_slash_hack?"TRY_SLASH_HACK":"") << "), " <<
+           "mdtm=" << ftpState->mdtm << ", size=" << ftpState->theSize <<
+           "slashhack=" << (ftpState->request->urlpath.caseCmp("/%2f", 4)==0? "T":"F") );
 
     /* Try the / hack to support "Netscape" FTP URL's for retreiving files */
     if (!ftpState->flags.isdir &&	/* Not a directory */
@@ -3685,16 +3671,16 @@ FtpStateData::appendSuccessHeader()
         reply->setHeaders(version, HTTP_OK, "Gatewaying",
                           mime_type, theSize, mdtm, -2);
     } else if (theSize < restarted_offset) {
-	/*
-	 * DPW 2007-05-04
-	 * offset should not be larger than theSize.  We should
-	 * not be seeing this condition any more because we'll only
-	 * send REST if we know the theSize and if it is less than theSize.
-	 */
-	debugs(0,DBG_CRITICAL,HERE << "Whoops! " <<
-		" restarted_offset=" << restarted_offset <<
-		", but theSize=" << theSize <<
-		".  assuming full content response");
+        /*
+         * DPW 2007-05-04
+         * offset should not be larger than theSize.  We should
+         * not be seeing this condition any more because we'll only
+         * send REST if we know the theSize and if it is less than theSize.
+         */
+        debugs(0,DBG_CRITICAL,HERE << "Whoops! " <<
+               " restarted_offset=" << restarted_offset <<
+               ", but theSize=" << theSize <<
+               ".  assuming full content response");
         reply->setHeaders(version, HTTP_OK, "Gatewaying",
                           mime_type, theSize, mdtm, -2);
     } else {
@@ -3756,7 +3742,7 @@ FtpStateData::ftpAuthRequired(HttpRequest * request, const char *realm)
  *  after the initial URI path delimiter, which happens to be / itself.
  *  This makes FTP absolute URI appear as:  ftp:host:port//root/path
  *  To encompass older software which compacts multiple // to / in transit
- *  We use standard URI-encoding on the second / making it 
+ *  We use standard URI-encoding on the second / making it
  *  ftp:host:port/%2froot/path  AKA 'the FTP %2f hack'.
  */
 const char *
@@ -3767,12 +3753,11 @@ ftpUrlWith2f(HttpRequest * request)
     if (request->protocol != PROTO_FTP)
         return NULL;
 
-    if( !strncmp(request->urlpath.buf(), "/", 1) ) {
+    if ( !strncmp(request->urlpath.buf(), "/", 1) ) {
         newbuf.append(request->urlpath);
         request->urlpath.absorb(newbuf);
         safe_free(request->canonical);
-    }
-    else if( !strncmp(request->urlpath.buf(), "%2f", 3) ) {
+    } else if ( !strncmp(request->urlpath.buf(), "%2f", 3) ) {
         newbuf.append(request->urlpath.buf() +1);
         request->urlpath.absorb(newbuf);
         safe_free(request->canonical);
@@ -3811,25 +3796,25 @@ FtpStateData::doneSendingRequestBody()
 {
     debugs(9,3, HERE);
     dataComplete();
-/* NP: RFC 959  3.3.  DATA CONNECTION MANAGEMENT
- * if transfer type is 'stream' call dataComplete()
- * otherwise leave open. (reschedule control channel read?)
- */
+    /* NP: RFC 959  3.3.  DATA CONNECTION MANAGEMENT
+     * if transfer type is 'stream' call dataComplete()
+     * otherwise leave open. (reschedule control channel read?)
+     */
 }
 
 /**
  * A hack to ensure we do not double-complete on the forward entry.
  *
- \todo FtpStateData logic should probably be rewritten to avoid 
+ \todo FtpStateData logic should probably be rewritten to avoid
  *	double-completion or FwdState should be rewritten to allow it.
  */
 void
 FtpStateData::completeForwarding()
 {
     if (fwd == NULL || flags.completed_forwarding) {
         debugs(9, 3, HERE << "completeForwarding avoids " <<
-            "double-complete on FD " << ctrl.fd << ", Data FD " << data.fd <<
-            ", this " << this << ", fwd " << fwd);
+               "double-complete on FD " << ctrl.fd << ", Data FD " << data.fd <<
+               ", this " << this << ", fwd " << fwd);
         return;
     }
 
@@ -3874,11 +3859,11 @@ FtpStateData::doneWithServer() const
 bool
 FtpStateData::haveControlChannel(const char *caller_name) const
 {
-    if(doneWithServer())
+    if (doneWithServer())
         return false;
 
     /* doneWithServer() only checks BOTH channels are closed. */
-    if(ctrl.fd < 0) {
+    if (ctrl.fd < 0) {
         debugs(9, DBG_IMPORTANT, "WARNING! FTP Server Control channel is closed, but Data channel still active.");
         debugs(9, 2, caller_name << ": attempted on a closed FTP channel.");
         return false;
@@ -3897,7 +3882,7 @@ void
 FtpStateData::abortTransaction(const char *reason)
 {
     debugs(9, 3, HERE << "aborting transaction for " << reason <<
-        "; FD " << ctrl.fd << ", Data FD " << data.fd << ", this " << this);
+           "; FD " << ctrl.fd << ", Data FD " << data.fd << ", this " << this);
     if (ctrl.fd >= 0) {
         comm_close(ctrl.fd);
         return;
@@ -3913,7 +3898,7 @@ FtpStateData::dataCloser()
 {
     typedef CommCbMemFunT<FtpStateData, CommCloseCbParams> Dialer;
     return asyncCall(9, 5, "FtpStateData::dataClosed",
-        Dialer(this, &FtpStateData::dataClosed));
+                     Dialer(this, &FtpStateData::dataClosed));
 }
 
 /// configures the channel with a descriptor and registers a close handler
@@ -908,8 +908,8 @@ htcpTstReply(htcpDataHeader * dhdr, StoreEntry * e, htcpSpecifier * spec, IPAddr
 
 #if USE_ICMP
         if (char *host = urlHostname(spec->uri)) {
-	    int rtt = 0;
-	    int hops = 0;
+            int rtt = 0;
+            int hops = 0;
             int samp = 0;
             netdbHostData(host, &samp, &rtt, &hops);
 
@@ -21,12 +21,12 @@
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
- *  
+ *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
- *  
+ *
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
@@ -65,7 +65,7 @@
     catch (const std::exception &e) { \
 	debugs (11, 1, "Exception error:" << e.what()); \
 	status = false; \
-    }  
+    }
 
 CBDATA_CLASS_INIT(HttpStateData);
 
@@ -98,7 +98,7 @@ HttpStateData::HttpStateData(FwdState *theFwdState) : AsyncJob("HttpStateData"),
             url = entry->url();
 
         HttpRequest * proxy_req = new HttpRequest(orig_request->method,
-                                  orig_request->protocol, url);
+                orig_request->protocol, url);
 
         proxy_req->SetHost(_peer->host);
 
@@ -134,7 +134,7 @@ HttpStateData::HttpStateData(FwdState *theFwdState) : AsyncJob("HttpStateData"),
      */
     typedef CommCbMemFunT<HttpStateData, CommCloseCbParams> Dialer;
     closeHandler = asyncCall(9, 5, "httpStateData::httpStateConnClosed",
-                                 Dialer(this,&HttpStateData::httpStateConnClosed));
+                             Dialer(this,&HttpStateData::httpStateConnClosed));
     comm_add_close_handler(fd, closeHandler);
 }
 
@@ -149,8 +149,8 @@ HttpStateData::~HttpStateData()
 
     delete readBuf;
 
-    if(httpChunkDecoder)
-	delete httpChunkDecoder;
+    if (httpChunkDecoder)
+        delete httpChunkDecoder;
 
     HTTPMSGUNLOCK(orig_request);
 
@@ -171,7 +171,7 @@ httpStateFree(int fd, void *data)
     delete httpState;
 }*/
 
-void 
+void
 HttpStateData::httpStateConnClosed(const CommCloseCbParams &params)
 {
     debugs(11, 5, "httpStateFree: FD " << params.fd << ", httpState=" << params.data);
@@ -183,7 +183,7 @@ httpCachable(const HttpRequestMethod& method)
 {
     /* GET and HEAD are cachable. Others are not. */
 
-	// TODO: replase to HttpRequestMethod::isCachable() ?
+    // TODO: replase to HttpRequestMethod::isCachable() ?
     if (method != METHOD_GET && method != METHOD_HEAD)
         return 0;
 
@@ -546,7 +546,7 @@ HttpStateData::cacheableReply()
 }
 
 /*
- * For Vary, store the relevant request headers as 
+ * For Vary, store the relevant request headers as
  * virtual headers in the reply
  * Returns false if the variance cannot be stored
  */
@@ -672,51 +672,50 @@ HttpStateData::processReplyHeader()
     HttpReply *newrep = new HttpReply;
     const bool parsed = newrep->parse(readBuf, eof, &error);
 
-    if(!parsed && readBuf->contentSize() > 5 && strncmp(readBuf->content(), "HTTP/", 5) != 0){
-	 MemBuf *mb;
-	 HttpReply *tmprep = new HttpReply;
-	 tmprep->sline.version = HttpVersion(1, 0);
-	 tmprep->sline.status = HTTP_OK;
-	 tmprep->header.putTime(HDR_DATE, squid_curtime);
-	 tmprep->header.putExt("X-Transformed-From", "HTTP/0.9");
-	 mb = tmprep->pack();
-	 newrep->parse(mb, eof, &error);
-	 delete tmprep;
-    }
-    else{
-	 if (!parsed && error > 0) { // unrecoverable parsing error
-	      debugs(11, 3, "processReplyHeader: Non-HTTP-compliant header: '" <<  readBuf->content() << "'");
-	      flags.headers_parsed = 1;
-          newrep->sline.version = HttpVersion(1, 0);
-          newrep->sline.status = error;
-          HttpReply *vrep = setVirginReply(newrep);
-          entry->replaceHttpReply(vrep);
-	      ctx_exit(ctx);
-	      return;
-	 }
-
-	 if (!parsed) { // need more data
-	      assert(!error);
-	      assert(!eof);
-	      delete newrep;
-	      ctx_exit(ctx);
-	      return;
-	 }
-
-	 debugs(11, 9, "GOT HTTP REPLY HDR:\n---------\n" << readBuf->content() << "\n----------");
-
-	 header_bytes_read = headersEnd(readBuf->content(), readBuf->contentSize());
-	 readBuf->consume(header_bytes_read);
+    if (!parsed && readBuf->contentSize() > 5 && strncmp(readBuf->content(), "HTTP/", 5) != 0) {
+        MemBuf *mb;
+        HttpReply *tmprep = new HttpReply;
+        tmprep->sline.version = HttpVersion(1, 0);
+        tmprep->sline.status = HTTP_OK;
+        tmprep->header.putTime(HDR_DATE, squid_curtime);
+        tmprep->header.putExt("X-Transformed-From", "HTTP/0.9");
+        mb = tmprep->pack();
+        newrep->parse(mb, eof, &error);
+        delete tmprep;
+    } else {
+        if (!parsed && error > 0) { // unrecoverable parsing error
+            debugs(11, 3, "processReplyHeader: Non-HTTP-compliant header: '" <<  readBuf->content() << "'");
+            flags.headers_parsed = 1;
+            newrep->sline.version = HttpVersion(1, 0);
+            newrep->sline.status = error;
+            HttpReply *vrep = setVirginReply(newrep);
+            entry->replaceHttpReply(vrep);
+            ctx_exit(ctx);
+            return;
+        }
+
+        if (!parsed) { // need more data
+            assert(!error);
+            assert(!eof);
+            delete newrep;
+            ctx_exit(ctx);
+            return;
+        }
+
+        debugs(11, 9, "GOT HTTP REPLY HDR:\n---------\n" << readBuf->content() << "\n----------");
+
+        header_bytes_read = headersEnd(readBuf->content(), readBuf->contentSize());
+        readBuf->consume(header_bytes_read);
     }
 
     flags.chunked = 0;
     if (newrep->header.hasListMember(HDR_TRANSFER_ENCODING, "chunked", ',')) {
-	 flags.chunked = 1;
-	 httpChunkDecoder = new ChunkedCodingParser;
+        flags.chunked = 1;
+        httpChunkDecoder = new ChunkedCodingParser;
     }
 
-    if(!peerSupportsConnectionPinning())
-	orig_request->flags.connection_auth_disabled = 1;
+    if (!peerSupportsConnectionPinning())
+        orig_request->flags.connection_auth_disabled = 1;
 
     HttpReply *vrep = setVirginReply(newrep);
     flags.headers_parsed = 1;
@@ -746,48 +745,48 @@ bool HttpStateData::peerSupportsConnectionPinning() const
     String header;
 
     if (!_peer)
-	return true;
-    
-    /*If this peer does not support connection pinning (authenticated 
+        return true;
+
+    /*If this peer does not support connection pinning (authenticated
       connections) return false
      */
     if (!_peer->connection_auth)
-	return false;
+        return false;
 
-    /*The peer supports connection pinning and the http reply status 
+    /*The peer supports connection pinning and the http reply status
       is not unauthorized, so the related connection can be pinned
      */
     if (rep->sline.status != HTTP_UNAUTHORIZED)
-	return true;
-    
-    /*The server respond with HTTP_UNAUTHORIZED and the peer configured 
-      with "connection-auth=on" we know that the peer supports pinned 
+        return true;
+
+    /*The server respond with HTTP_UNAUTHORIZED and the peer configured
+      with "connection-auth=on" we know that the peer supports pinned
       connections
     */
     if (_peer->connection_auth == 1)
-	return true;
+        return true;
 
-    /*At this point peer has configured with "connection-auth=auto" 
-      parameter so we need some extra checks to decide if we are going 
+    /*At this point peer has configured with "connection-auth=auto"
+      parameter so we need some extra checks to decide if we are going
       to allow pinned connections or not
     */
 
-    /*if the peer configured with originserver just allow connection 
+    /*if the peer configured with originserver just allow connection
         pinning (squid 2.6 behaviour)
      */
     if (_peer->options.originserver)
-	return true;
+        return true;
 
     /*if the connections it is already pinned it is OK*/
     if (request->flags.pinned)
-	return true;
-    
-    /*Allow pinned connections only if the Proxy-support header exists in 
-      reply and has in its list the "Session-Based-Authentication" 
+        return true;
+
+    /*Allow pinned connections only if the Proxy-support header exists in
+      reply and has in its list the "Session-Based-Authentication"
       which means that the peer supports connection pinning.
      */
     if (!hdr->has(HDR_PROXY_SUPPORT))
-	return false;
+        return false;
 
     header = hdr->getStrOrList(HDR_PROXY_SUPPORT);
     /* XXX This ought to be done in a case-insensitive manner */
@@ -949,12 +948,12 @@ HttpStateData::persistentConnStatus() const
     if (eof) // already reached EOF
         return COMPLETE_NONPERSISTENT_MSG;
 
-    /* In chunked responce we do not know the content length but we are absolutelly 
+    /* In chunked responce we do not know the content length but we are absolutelly
      * sure about the end of response, so we are calling the statusIfComplete to
-     * decide if we can be persistant 
+     * decide if we can be persistant
      */
     if (lastChunk && flags.chunked)
-	return statusIfComplete();
+        return statusIfComplete();
 
     const int64_t clen = vrep->bodySize(request->method);
 
@@ -1007,7 +1006,7 @@ HttpStateData::readReply (const CommIoCbParams &io)
     assert(fd == io.fd);
 
     flags.do_next_read = 0;
-   
+
     debugs(11, 5, "httpReadReply: FD " << fd << ": len " << len << ".");
 
     // Bail out early on COMM_ERR_CLOSING - close handlers will tidy up for us
@@ -1133,20 +1132,20 @@ HttpStateData::continueAfterParsingHeader()
             if (s == HTTP_INVALID_HEADER && v != HttpVersion(0,9)) {
                 error = ERR_INVALID_RESP;
             } else
-            if (s == HTTP_HEADER_TOO_LARGE) {
-                fwd->dontRetry(true);
-                error = ERR_TOO_BIG;
-            } else {
-                return true; // done parsing, got reply, and no error
-            }
+                if (s == HTTP_HEADER_TOO_LARGE) {
+                    fwd->dontRetry(true);
+                    error = ERR_TOO_BIG;
+                } else {
+                    return true; // done parsing, got reply, and no error
+                }
         } else {
             // parsed headers but got no reply
             error = ERR_INVALID_RESP;
         }
     } else {
         assert(eof);
         error = readBuf->hasContent() ?
-            ERR_INVALID_RESP : ERR_ZERO_SIZE_OBJECT;
+                ERR_INVALID_RESP : ERR_ZERO_SIZE_OBJECT;
     }
 
     assert(error != ERR_NONE);
@@ -1224,15 +1223,14 @@ HttpStateData::processReplyBody()
      * That means header content has been removed from readBuf and
      * it contains only body data.
      */
-    if(flags.chunked){
-	if(!decodeAndWriteReplyBody()){
-	    flags.do_next_read = 0;
-	    serverComplete();
-	    return;
-	}
-    }
-    else
-	writeReplyBody();
+    if (flags.chunked) {
+        if (!decodeAndWriteReplyBody()) {
+            flags.do_next_read = 0;
+            serverComplete();
+            return;
+        }
+    } else
+        writeReplyBody();
 
     if (EBIT_TEST(entry->flags, ENTRY_ABORTED)) {
         /*
@@ -1247,10 +1245,10 @@ HttpStateData::processReplyBody()
             debugs(11, 5, "processReplyBody: INCOMPLETE_MSG");
             /* Wait for more data or EOF condition */
             if (flags.keepalive_broken) {
-		call = NULL;
+                call = NULL;
                 commSetTimeout(fd, 10, call);
             } else {
-		call = NULL;
+                call = NULL;
                 commSetTimeout(fd, Config.Timeout.read, call);
             }
 
@@ -1260,28 +1258,28 @@ HttpStateData::processReplyBody()
         case COMPLETE_PERSISTENT_MSG:
             debugs(11, 5, "processReplyBody: COMPLETE_PERSISTENT_MSG");
             /* yes we have to clear all these! */
-	    call = NULL;
+            call = NULL;
             commSetTimeout(fd, -1, call);
             flags.do_next_read = 0;
 
-	    comm_remove_close_handler(fd, closeHandler);
+            comm_remove_close_handler(fd, closeHandler);
             closeHandler = NULL;
             fwd->unregister(fd);
 
             if (orig_request->flags.spoof_client_ip)
                 client_addr = orig_request->client_addr;
 
 
-	    if (request->flags.pinned) {
-		ispinned = true;
-	    } else if (request->flags.connection_auth && request->flags.auth_sent) {
-		ispinned = true;
-	    }
-	   
-	    if (orig_request->pinnedConnection() && ispinned) {
-		orig_request->pinnedConnection()->pinConnection(fd, orig_request, _peer, 
-								(request->flags.connection_auth != 0));
-	    } else if (_peer) {
+            if (request->flags.pinned) {
+                ispinned = true;
+            } else if (request->flags.connection_auth && request->flags.auth_sent) {
+                ispinned = true;
+            }
+
+            if (orig_request->pinnedConnection() && ispinned) {
+                orig_request->pinnedConnection()->pinConnection(fd, orig_request, _peer,
+                        (request->flags.connection_auth != 0));
+            } else if (_peer) {
                 if (_peer->options.originserver)
                     fwd->pconnPush(fd, _peer->name, orig_request->port, orig_request->GetHost(), client_addr);
                 else
@@ -1321,18 +1319,18 @@ HttpStateData::maybeReadVirginBody()
      * its okay to read again.
      */
     if (read_sz < 2) {
-	if (flags.headers_parsed)
-	    return;
-	else
-	    read_sz = 1024;
+        if (flags.headers_parsed)
+            return;
+        else
+            read_sz = 1024;
     }
 
     if (flags.do_next_read) {
         flags.do_next_read = 0;
         typedef CommCbMemFunT<HttpStateData, CommIoCbParams> Dialer;
         entry->delayAwareRead(fd, readBuf->space(read_sz), read_sz,
-            asyncCall(11, 5, "HttpStateData::readReply",
-            Dialer(this, &HttpStateData::readReply)));
+                              asyncCall(11, 5, "HttpStateData::readReply",
+                                        Dialer(this, &HttpStateData::readReply)));
     }
 }
 
@@ -1376,7 +1374,7 @@ HttpStateData::sendComplete(const CommIoCbParams &io)
      */
     typedef CommCbMemFunT<HttpStateData, CommTimeoutCbParams> TimeoutDialer;
     AsyncCall::Pointer timeoutCall =  asyncCall(11, 5, "HttpStateData::httpTimeout",
-                        TimeoutDialer(this,&HttpStateData::httpTimeout));
+                                      TimeoutDialer(this,&HttpStateData::httpTimeout));
 
     commSetTimeout(fd, Config.Timeout.read, timeoutCall);
 
@@ -1391,7 +1389,7 @@ HttpStateData::closeServer()
 
     if (fd >= 0) {
         fwd->unregister(fd);
-	comm_remove_close_handler(fd, closeHandler);
+        comm_remove_close_handler(fd, closeHandler);
         closeHandler = NULL;
         comm_close(fd);
         fd = -1;
@@ -1405,7 +1403,7 @@ HttpStateData::doneWithServer() const
 }
 
 /*
- * build request headers and append them to a given MemBuf 
+ * build request headers and append them to a given MemBuf
  * used by buildRequestPrefix()
  * note: initialised the HttpHeader, the caller is responsible for Clean()-ing
  */
@@ -1475,29 +1473,29 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
     strFwd = hdr_in->getList(HDR_X_FORWARDED_FOR);
 
     /** \pre Handle X-Forwarded-For */
-    if(strcmp(opt_forwarded_for, "delete") != 0) {
-        if(strcmp(opt_forwarded_for, "on") == 0) {
+    if (strcmp(opt_forwarded_for, "delete") != 0) {
+        if (strcmp(opt_forwarded_for, "on") == 0) {
             /** If set to ON - append client IP or 'unknown'. */
             strFwd = hdr_in->getList(HDR_X_FORWARDED_FOR);
-            if( orig_request->client_addr.IsNoAddr() )
+            if ( orig_request->client_addr.IsNoAddr() )
                 strListAdd(&strFwd, "unknown", ',');
             else
                 strListAdd(&strFwd, orig_request->client_addr.NtoA(ntoabuf, MAX_IPSTRLEN), ',');
-        } else if(strcmp(opt_forwarded_for, "off") == 0) {
+        } else if (strcmp(opt_forwarded_for, "off") == 0) {
             /** If set to OFF - append 'unknown'. */
             strFwd = hdr_in->getList(HDR_X_FORWARDED_FOR);
             strListAdd(&strFwd, "unknown", ',');
-        } else if(strcmp(opt_forwarded_for, "transparent") == 0) {
+        } else if (strcmp(opt_forwarded_for, "transparent") == 0) {
             /** If set to TRANSPARENT - pass through unchanged. */
             strFwd = hdr_in->getList(HDR_X_FORWARDED_FOR);
-        } else if(strcmp(opt_forwarded_for, "truncate") == 0) {
+        } else if (strcmp(opt_forwarded_for, "truncate") == 0) {
             /** If set to TRUNCATE - drop existing list and replace with client IP or 'unknown'. */
-            if( orig_request->client_addr.IsNoAddr() )
+            if ( orig_request->client_addr.IsNoAddr() )
                 strFwd = "unknown";
             else
                 strFwd = orig_request->client_addr.NtoA(ntoabuf, MAX_IPSTRLEN);
         }
-        if(strFwd.size() > 0)
+        if (strFwd.size() > 0)
             hdr_out->putStr(HDR_X_FORWARDED_FOR, strFwd.buf());
     }
     /** If set to DELETE - do not copy through. */
@@ -1698,7 +1696,7 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, St
          * went through our redirector and the admin configured
          * 'redir_rewrites_host' to be off.
          */
-	if (orig_request->peer_domain)
+        if (orig_request->peer_domain)
             hdr_out->putStr(HDR_HOST, orig_request->peer_domain);
         else if (request->flags.redirected && !Config.onoff.redir_rewrites_host)
             hdr_out->addEntry(e->clone());
@@ -1794,9 +1792,9 @@ HttpStateData::decideIfWeDoRanges (HttpRequest * orig_request)
             || orig_request->range->offsetLimitExceeded() || orig_request->flags.connection_auth)
         result = false;
 
-        debugs(11, 8, "decideIfWeDoRanges: range specs: " <<
-               orig_request->range << ", cachable: " <<
-               orig_request->flags.cachable << "; we_do_ranges: " << result);
+    debugs(11, 8, "decideIfWeDoRanges: range specs: " <<
+           orig_request->range << ", cachable: " <<
+           orig_request->flags.cachable << "; we_do_ranges: " << result);
 
     return result;
 }
@@ -1821,8 +1819,8 @@ HttpStateData::buildRequestPrefix(HttpRequest * request,
         HttpHeader hdr(hoRequest);
         Packer p;
         httpBuildRequestHeader(request, orig_request, entry, &hdr, flags);
-	
-	if (request->flags.pinned && request->flags.connection_auth)
+
+        if (request->flags.pinned && request->flags.connection_auth)
             request->flags.auth_sent = 1;
         else if (hdr.has(HDR_AUTHORIZATION))
             request->flags.auth_sent = 1;
@@ -1846,22 +1844,22 @@ HttpStateData::sendRequest()
     debugs(11, 5, "httpSendRequest: FD " << fd << ", request " << request << ", this " << this << ".");
     typedef CommCbMemFunT<HttpStateData, CommTimeoutCbParams> TimeoutDialer;
     AsyncCall::Pointer timeoutCall =  asyncCall(11, 5, "HttpStateData::httpTimeout",
-                        TimeoutDialer(this,&HttpStateData::httpTimeout));
+                                      TimeoutDialer(this,&HttpStateData::httpTimeout));
     commSetTimeout(fd, Config.Timeout.lifetime, timeoutCall);
     flags.do_next_read = 1;
     maybeReadVirginBody();
 
     if (orig_request->body_pipe != NULL) {
         if (!startRequestBodyFlow()) // register to receive body data
             return false;
-	typedef CommCbMemFunT<HttpStateData, CommIoCbParams> Dialer;
+        typedef CommCbMemFunT<HttpStateData, CommIoCbParams> Dialer;
         Dialer dialer(this, &HttpStateData::sentRequestBody);
-	requestSender = asyncCall(11,5, "HttpStateData::sentRequestBody", dialer);
+        requestSender = asyncCall(11,5, "HttpStateData::sentRequestBody", dialer);
     } else {
         assert(!requestBodySource);
-	typedef CommCbMemFunT<HttpStateData, CommIoCbParams> Dialer;
+        typedef CommCbMemFunT<HttpStateData, CommIoCbParams> Dialer;
         Dialer dialer(this, &HttpStateData::sendComplete);
-	requestSender = asyncCall(11,5, "HttpStateData::SendComplete", dialer);
+        requestSender = asyncCall(11,5, "HttpStateData::SendComplete", dialer);
     }
 
     if (_peer != NULL) {
@@ -1881,7 +1879,7 @@ HttpStateData::sendRequest()
      * Is keep-alive okay for all request methods?
      */
     if (orig_request->flags.must_keepalive)
-	flags.keepalive = 1;
+        flags.keepalive = 1;
     else if (!Config.onoff.server_pconns)
         flags.keepalive = 0;
     else if (_peer == NULL)
@@ -1944,21 +1942,21 @@ HttpStateData::doneSendingRequestBody()
 
     if (!Config.accessList.brokenPosts) {
         debugs(11, 5, "doneSendingRequestBody: No brokenPosts list");
-	CommIoCbParams io(NULL);
-	io.fd=fd;
-	io.flag=COMM_OK;
-	sendComplete(io);
+        CommIoCbParams io(NULL);
+        io.fd=fd;
+        io.flag=COMM_OK;
+        sendComplete(io);
     } else if (!ch.fastCheck()) {
         debugs(11, 5, "doneSendingRequestBody: didn't match brokenPosts");
-	CommIoCbParams io(NULL);
-	io.fd=fd;
-	io.flag=COMM_OK;
-	sendComplete(io);
+        CommIoCbParams io(NULL);
+        io.fd=fd;
+        io.flag=COMM_OK;
+        sendComplete(io);
     } else {
         debugs(11, 2, "doneSendingRequestBody: matched brokenPosts");
-	typedef CommCbMemFunT<HttpStateData, CommIoCbParams> Dialer;
+        typedef CommCbMemFunT<HttpStateData, CommIoCbParams> Dialer;
         Dialer dialer(this, &HttpStateData::sendComplete);
-	AsyncCall::Pointer call= asyncCall(11,5, "HttpStateData::SendComplete", dialer);
+        AsyncCall::Pointer call= asyncCall(11,5, "HttpStateData::SendComplete", dialer);
         comm_write(fd, "\r\n", 2, call);
     }
 }
@@ -248,13 +248,12 @@ mimeGetEntry(const char *fn, int skip_encodings)
             /* Assume we matched /\.\w$/ and cut off the last extension */
             if ((t = strrchr(name, '.'))) {
                 *t = '\0';
-            }
-            else {
+            } else {
                 /* What? A encoding without a extension? */
                 m = NULL;
             }
         }
-    } while(t);
+    } while (t);
 
     xfree(name);
     return m;
@@ -21,12 +21,12 @@
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
- *  
+ *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
- *  
+ *
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
@@ -87,8 +87,8 @@ IdleConnList::removeFD(int fd)
 {
     int index = findFDIndex(fd);
     if (index < 0) {
-	debugs(48, 0, "IdleConnList::removeFD: FD " << fd << " NOT FOUND!");
-	return;
+        debugs(48, 0, "IdleConnList::removeFD: FD " << fd << " NOT FOUND!");
+        return;
     }
     debugs(48, 3, "IdleConnList::removeFD: found FD " << fd << " at index " << index);
 
@@ -237,13 +237,11 @@ PconnPool::push(int fd, const char *host, u_short port, const char *domain, IPAd
     const char *aKey;
     LOCAL_ARRAY(char, desc, FD_DESC_SZ);
 
-    if (fdUsageHigh())
-    {
+    if (fdUsageHigh()) {
         debugs(48, 3, "PconnPool::push: Not many unused FDs");
         comm_close(fd);
         return;
-    } else if (shutting_down)
-    {
+    } else if (shutting_down) {
         comm_close(fd);
         return;
     }
@@ -252,8 +250,7 @@ PconnPool::push(int fd, const char *host, u_short port, const char *domain, IPAd
 
     list = (IdleConnList *) hash_lookup(table, aKey);
 
-    if (list == NULL)
-    {
+    if (list == NULL) {
         list = new IdleConnList(aKey, this);
         debugs(48, 3, "pconnNew: adding " << hashKeyStr(&list->hash));
         hash_join(table, &list->hash);
@@ -288,8 +285,7 @@ PconnPool::pop(const char *host, u_short port, const char *domain, IPAddress &cl
 
     int fd = list->findUseableFD(); // search from the end. skip pending reads.
 
-    if (fd >= 0)
-    {
+    if (fd >= 0) {
         list->clearHandlers(fd);
         list->removeFD(fd);	/* might delete list */
 
@@ -344,15 +340,15 @@ void
 PconnModule::registerWithCacheManager(void)
 {
     CacheManager::GetInstance()->
-        registerAction("pconn",
-                       "Persistent Connection Utilization Histograms",
-                       DumpWrapper, 0, 1);
+    registerAction("pconn",
+                   "Persistent Connection Utilization Histograms",
+                   DumpWrapper, 0, 1);
 }
 
 void
 
 PconnModule::add
-    (PconnPool *aPool)
+(PconnPool *aPool)
 {
     assert(poolCount < MAX_NUM_PCONN_POOLS);
     *(pools+poolCount) = aPool;
@@ -18,12 +18,12 @@
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
- *  
+ *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
- *  
+ *
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
@@ -41,14 +41,12 @@
 /* needed for the global config */
 #include "HttpHeader.h"
 
-struct acl_name_list
-{
+struct acl_name_list {
     char name[ACL_NAME_SZ];
     acl_name_list *next;
 };
 
-struct acl_deny_info_list
-{
+struct acl_deny_info_list {
     err_type err_page_id;
     char *err_page_name;
     acl_name_list *acl_list;
@@ -58,8 +56,7 @@ struct acl_deny_info_list
 
 class acl_access;
 
-struct _header_mangler
-{
+struct _header_mangler {
     acl_access *access_list;
     char *replacement;
 };
@@ -68,8 +65,7 @@ class ACLChecklist;
 
 #if SQUID_SNMP
 
-struct _snmp_request_t
-{
+struct _snmp_request_t {
     u_char *buf;
     u_char *outbuf;
     int len;
@@ -90,36 +86,31 @@ struct _snmp_request_t
 
 class ACLList;
 
-struct acl_address
-{
+struct acl_address {
     acl_address *next;
     ACLList *aclList;
 
     IPAddress addr;
 };
 
-struct acl_tos
-{
+struct acl_tos {
     acl_tos *next;
     ACLList *aclList;
     int tos;
 };
 
-struct acl_size_t
-{
+struct acl_size_t {
     acl_size_t *next;
     ACLList *aclList;
     int64_t size;
 };
 
-struct ushortlist
-{
+struct ushortlist {
     u_short i;
     ushortlist *next;
 };
 
-struct relist
-{
+struct relist {
     char *pattern;
     regex_t regex;
     relist *next;
@@ -139,11 +130,9 @@ class RemovalPolicySettings;
 class external_acl;
 class Store;
 
-struct SquidConfig
-{
+struct SquidConfig {
 
-    struct
-    {
+    struct {
         /* These should be for the Store::Root instance.
         * this needs pluggable parsing to be done smoothly.
         */
@@ -152,8 +141,7 @@ struct SquidConfig
     } Swap;
     size_t memMaxSize;
 
-    struct
-    {
+    struct {
         int64_t min;
         int pct;
         int64_t max;
@@ -169,8 +157,7 @@ struct SquidConfig
     time_t shutdownLifetime;
     time_t backgroundPingRate;
 
-    struct
-    {
+    struct {
         time_t read;
         time_t lifetime;
         time_t connect;
@@ -201,8 +188,7 @@ struct SquidConfig
     size_t maxReplyHeaderSize;
     acl_size_t *ReplyBodySize;
 
-    struct
-    {
+    struct {
         u_short icp;
 #if USE_HTCP
 
@@ -214,8 +200,7 @@ struct SquidConfig
 #endif
     } Port;
 
-    struct
-    {
+    struct {
         http_port_list *http;
 #if USE_SSL
 
@@ -225,16 +210,14 @@ struct SquidConfig
     } Sockaddr;
 #if SQUID_SNMP
 
-    struct
-    {
+    struct {
         char *configFile;
         char *agentInfo;
     } Snmp;
 #endif
 #if USE_WCCP
 
-    struct
-    {
+    struct {
 
         IPAddress router;
 
@@ -244,8 +227,7 @@ struct SquidConfig
 #endif
 #if USE_WCCPv2
 
-    struct
-    {
+    struct {
         IPAddress_list *router;
 
         IPAddress address;
@@ -264,8 +246,7 @@ struct SquidConfig
 
     char *as_whois_server;
 
-    struct
-    {
+    struct {
         char *log;
         char *store;
         char *swap;
@@ -295,8 +276,7 @@ struct SquidConfig
     char *visible_appname_string;
     char *effectiveGroup;
 
-    struct
-    {
+    struct {
 #if USE_DNSSERVERS
         char *dnsserver;
 #endif
@@ -325,8 +305,7 @@ struct SquidConfig
     time_t authenticateTTL;
     time_t authenticateIpTTL;
 
-    struct
-    {
+    struct {
 #if USE_SQUID_ESI
         char *surrogate_id;
 #endif
@@ -344,16 +323,14 @@ struct SquidConfig
     wordlist *hostnameAliases;
     char *errHtmlText;
 
-    struct
-    {
+    struct {
         char *host;
         char *file;
         time_t period;
         u_short port;
     } Announce;
 
-    struct
-    {
+    struct {
 
         IPAddress udp_incoming;
 
@@ -375,39 +352,34 @@ struct SquidConfig
     peer *peers;
     int npeers;
 
-    struct
-    {
+    struct {
         int size;
         int low;
         int high;
     } ipcache;
 
-    struct
-    {
+    struct {
         int size;
     } fqdncache;
     int minDirectHops;
     int minDirectRtt;
     cachemgr_passwd *passwd_list;
 
-    struct
-    {
+    struct {
         int objectsPerBucket;
         int64_t avgObjectSize;
         int64_t maxObjectSize;
         int64_t minObjectSize;
         size_t maxInMemObjSize;
     } Store;
 
-    struct
-    {
+    struct {
         int high;
         int low;
         time_t period;
     } Netdb;
 
-    struct
-    {
+    struct {
         int log_udp;
         int res_defnames;
         int anonymizer;
@@ -480,8 +452,7 @@ struct SquidConfig
 
     class ACL *aclList;
 
-    struct
-    {
+    struct {
         acl_access *http;
         acl_access *icp;
         acl_access *miss;
@@ -511,7 +482,7 @@ struct SquidConfig
         acl_access *htcp;
         acl_access *htcp_clr;
 #endif
-        
+
 #if USE_SSL
         acl_access *ssl_bump;
 #endif
@@ -523,8 +494,7 @@ struct SquidConfig
     acl_deny_info_list *denyInfoList;
     authConfig authConfiguration;
 
-    struct
-    {
+    struct {
         size_t list_width;
         int list_wrap;
         char *anon_user;
@@ -535,15 +505,13 @@ struct SquidConfig
     } Ftp;
     refresh_t *Refresh;
 
-    struct _cacheSwap
-    {
+    struct _cacheSwap {
         RefCount<class Store> *swapDirs;
         int n_allocated;
         int n_configured;
     } cacheSwap;
 
-    struct
-    {
+    struct {
         char *directory;
         int use_short_names;
     } icons;
@@ -554,23 +522,20 @@ struct SquidConfig
 #endif
     char *errorStylesheet;
 
-    struct
-    {
+    struct {
         int maxtries;
         int onerror;
     } retry;
 
-    struct
-    {
+    struct {
         size_t limit;
     } MemPools;
 #if DELAY_POOLS
 
     DelayConfig Delay;
 #endif
 
-    struct
-    {
+    struct {
         int icp_average;
         int dns_average;
         int http_average;
@@ -583,8 +548,7 @@ struct SquidConfig
     int64_t rangeOffsetLimit;
 #if MULTICAST_MISS_STREAM
 
-    struct
-    {
+    struct {
 
         IPAddress addr;
         int ttl;
@@ -601,8 +565,7 @@ struct SquidConfig
     char *chroot_dir;
 #if USE_CACHE_DIGESTS
 
-    struct
-    {
+    struct {
         int bits_per_entry;
         time_t rebuild_period;
         time_t rewrite_period;
@@ -612,17 +575,15 @@ struct SquidConfig
 #endif
 #if USE_SSL
 
-    struct
-    {
+    struct {
         int unclean_shutdown;
         char *ssl_engine;
     } SSL;
 #endif
 
     wordlist *ext_methods;
 
-    struct
-    {
+    struct {
         int high_rptm;
         int high_pf;
         size_t high_memory;
@@ -634,12 +595,11 @@ struct SquidConfig
 #if USE_ZPH_QOS
     int zph_tos_local;
     int zph_tos_peer;
-    int zph_preserve_miss_tos_mask; 
+    int zph_preserve_miss_tos_mask;
 #endif
 #if USE_SSL
 
-    struct
-    {
+    struct {
         char *cert;
         char *key;
         int version;
@@ -664,10 +624,8 @@ struct SquidConfig
 
 SQUIDCEXTERN SquidConfig Config;
 
-struct SquidConfig2
-{
-    struct
-    {
+struct SquidConfig2 {
+    struct {
         int enable_purge;
         int mangle_request_headers;
     } onoff;
@@ -677,15 +635,13 @@ struct SquidConfig2
 
 SQUIDCEXTERN SquidConfig2 Config2;
 
-struct _close_handler
-{
+struct _close_handler {
     PF *handler;
     void *data;
     close_handler *next;
 };
 
-struct _dread_ctrl
-{
+struct _dread_ctrl {
     int fd;
     off_t offset;
     int req_len;
@@ -695,8 +651,7 @@ struct _dread_ctrl
     void *client_data;
 };
 
-struct _dwrite_q
-{
+struct _dwrite_q {
     off_t file_offset;
     char *buf;
     size_t len;
@@ -711,23 +666,20 @@ struct _dwrite_q
  * Note: "str" points to memory in HttpHeaderEntry (for now)
  *       so ETags should be used as tmp variables only (for now) */
 
-struct _ETag
-{
+struct _ETag {
     const char *str;		/* quoted-string */
     int weak;			/* true if it is a weak validator */
 };
 
-struct _fde_disk
-{
+struct _fde_disk {
     DWCB *wrt_handle;
     void *wrt_handle_data;
     dwrite_q *write_q;
     dwrite_q *write_q_tail;
     off_t offset;
 };
 
-struct _fileMap
-{
+struct _fileMap {
     int max_n_files;
     int n_files_in_map;
     int toggle;
@@ -742,8 +694,7 @@ struct _fileMap
 
 class MemBuf;
 
-struct _HttpBody
-{
+struct _HttpBody {
     /* private */
     MemBuf *mb;
 };
@@ -772,8 +723,7 @@ class HttpHdrCc
 
 /* some fields can hold either time or etag specs (e.g. If-Range) */
 
-struct _TimeOrTag
-{
+struct _TimeOrTag {
     ETag tag;			/* entity tag */
     time_t time;
     int valid;			/* true if struct is usable */
@@ -785,7 +735,7 @@ class HttpHeaderFieldStat
 {
 
 public:
-    HttpHeaderFieldStat() : aliveCount(0), seenCount(0), parsCount(0), errCount(0), repCount(0){}
+    HttpHeaderFieldStat() : aliveCount(0), seenCount(0), parsCount(0), errCount(0), repCount(0) {}
 
     int aliveCount;		/* created but not destroyed (count) */
     int seenCount;		/* #fields we've seen */
@@ -800,16 +750,15 @@ class HttpHeaderFieldInfo
 {
 
 public:
-    HttpHeaderFieldInfo() : id (HDR_ACCEPT), type (ftInvalid){}
+    HttpHeaderFieldInfo() : id (HDR_ACCEPT), type (ftInvalid) {}
 
     http_hdr_type id;
     String name;
     field_type type;
     HttpHeaderFieldStat stat;
 };
 
-struct _http_state_flags
-{
+struct _http_state_flags {
     unsigned int proxying:1;
     unsigned int keepalive:1;
     unsigned int only_if_cached:1;
@@ -824,24 +773,21 @@ struct _http_state_flags
     unsigned int chunked:1;
 };
 
-struct _ipcache_addrs
-{
+struct _ipcache_addrs {
     IPAddress *in_addrs;
     unsigned char *bad_mask;
     unsigned char count;
     unsigned char cur;
     unsigned char badcount;
 };
 
-struct _domain_ping
-{
+struct _domain_ping {
     char *domain;
     int do_ping;		/* boolean */
     domain_ping *next;
 };
 
-struct _domain_type
-{
+struct _domain_type {
     char *domain;
     peer_t type;
     domain_type *next;
@@ -851,8 +797,7 @@ struct _domain_type
 
 /* statistics for cache digests and other hit "predictors" */
 
-struct _cd_guess_stats
-{
+struct _cd_guess_stats {
     /* public, read-only */
     int true_hits;
     int false_hits;
@@ -865,17 +810,15 @@ struct _cd_guess_stats
 
 class PeerDigest;
 
-struct peer
-{
+struct peer {
     u_int index;
     char *name;
     char *host;
     peer_t type;
 
     IPAddress in_addr;
 
-    struct
-    {
+    struct {
         int pings_sent;
         int pings_acked;
         int fetches;
@@ -892,16 +835,14 @@ struct peer
         int conn_open;		/* current opened connections */
     } stats;
 
-    struct
-    {
+    struct {
         int version;
         int counts[ICP_END+1];
         u_short port;
     } icp;
 #if USE_HTCP
 
-    struct
-    {
+    struct {
         double version;
         int counts[2];
         u_short port;
@@ -913,8 +854,7 @@ struct peer
     domain_type *typelist;
     acl_access *access;
 
-    struct
-    {
+    struct {
         unsigned int proxy_only:1;
         unsigned int no_query:1;
         unsigned int background_ping:1;
@@ -946,16 +886,14 @@ struct peer
     int weight;
     int basetime;
 
-    struct
-    {
+    struct {
         double avg_n_members;
         int n_times_counted;
         int n_replies_expected;
         int ttl;
         int id;
 
-        struct
-        {
+        struct {
             unsigned int count_event_pending:1;
             unsigned int counting:1;
         } flags;
@@ -974,22 +912,19 @@ struct peer
     peer *next;
     int test_fd;
 
-    struct
-    {
+    struct {
         unsigned int hash;
         double load_multiplier;
         double load_factor;	/* normalized weight value */
     } carp;
 
-    struct
-    {
+    struct {
         unsigned int hash;
         double load_multiplier;
         double load_factor;	/* normalized weight value */
     } userhash;
 
-    struct
-    {
+    struct {
         unsigned int hash;
         double load_multiplier;
         double load_factor;	/* normalized weight value */
@@ -1020,23 +955,20 @@ struct peer
     int connection_auth;
 };
 
-struct _net_db_name
-{
+struct _net_db_name {
     hash_link hash;		/* must be first */
     net_db_name *next;
     netdbEntry *net_db_entry;
 };
 
-struct _net_db_peer
-{
+struct _net_db_peer {
     const char *peername;
     double hops;
     double rtt;
     time_t expires;
 };
 
-struct _netdbEntry
-{
+struct _netdbEntry {
     hash_link hash;		/* must be first */
     char network[MAX_IPSTRLEN];
     int pings_sent;
@@ -1053,11 +985,9 @@ struct _netdbEntry
 };
 
 
-struct _iostats
-{
+struct _iostats {
 
-    struct
-    {
+    struct {
         int reads;
         int reads_deferred;
         int read_hist[16];
@@ -1069,15 +999,13 @@ struct _iostats
 };
 
 
-struct request_flags
-{
-    request_flags(): range(0),nocache(0),ims(0),auth(0),cachable(0),hierarchical(0),loopdetect(0),proxy_keepalive(0),proxying(0),refresh(0),redirected(0),need_validation(0),accelerated(0),intercepted(0),spoof_client_ip(0),internal(0),internalclient(0),must_keepalive(0),destinationIPLookedUp_(0)
-    {
+struct request_flags {
+    request_flags(): range(0),nocache(0),ims(0),auth(0),cachable(0),hierarchical(0),loopdetect(0),proxy_keepalive(0),proxying(0),refresh(0),redirected(0),need_validation(0),accelerated(0),intercepted(0),spoof_client_ip(0),internal(0),internalclient(0),must_keepalive(0),destinationIPLookedUp_(0) {
 #if HTTP_VIOLATIONS
         nocache_hack = 0;
 #endif
 #if FOLLOW_X_FORWARDED_FOR
-    done_follow_x_forwarded_for = 0;
+        done_follow_x_forwarded_for = 0;
 #endif /* FOLLOW_X_FORWARDED_FOR */
     }
 
@@ -1089,7 +1017,8 @@ struct request_flags
     unsigned int hierarchical:1;
     unsigned int loopdetect:1;
     unsigned int proxy_keepalive:1;
-    unsigned int proxying:1;	/* this should be killed, also in httpstateflags */
+unsigned int proxying:
+    1;	/* this should be killed, also in httpstateflags */
     unsigned int refresh:1;
     unsigned int redirected:1;
     unsigned int need_validation:1;
@@ -1129,31 +1058,27 @@ struct request_flags
     unsigned int destinationIPLookedUp_:1;
 };
 
-struct _link_list
-{
+struct _link_list {
     void *ptr;
 
     struct _link_list *next;
 };
 
-struct _cachemgr_passwd
-{
+struct _cachemgr_passwd {
     char *passwd;
     wordlist *actions;
     cachemgr_passwd *next;
 };
 
-struct _refresh_t
-{
+struct _refresh_t {
     const char *pattern;
     regex_t compiled_pattern;
     time_t min;
     double pct;
     time_t max;
     refresh_t *next;
 
-    struct
-    {
+    struct {
         unsigned int icase:1;
         unsigned int refresh_ims:1;
 #if HTTP_VIOLATIONS
@@ -1170,12 +1095,11 @@ struct _refresh_t
 };
 
 /*
- * "very generic" histogram; 
+ * "very generic" histogram;
  * see important comments on hbase_f restrictions in StatHist.c
  */
 
-struct _StatHist
-{
+struct _StatHist {
     int *bins;
     int capacity;
     double min;
@@ -1186,15 +1110,13 @@ struct _StatHist
 };
 
 /*
- * if you add a field to StatCounters, 
+ * if you add a field to StatCounters,
  * you MUST sync statCountersInitSpecial, statCountersClean, and statCountersCopy
  */
 
-struct _StatCounters
-{
+struct _StatCounters {
 
-    struct
-    {
+    struct {
         int clients;
         int requests;
         int hits;
@@ -1211,20 +1133,17 @@ struct _StatCounters
         StatHist all_svc_time;
     } client_http;
 
-    struct
-    {
+    struct {
 
-        struct
-        {
+        struct {
             int requests;
             int errors;
             kb_t kbytes_in;
             kb_t kbytes_out;
         } all , http, ftp, other;
     } server;
 
-    struct
-    {
+    struct {
         int pkts_sent;
         int queries_sent;
         int replies_sent;
@@ -1247,24 +1166,20 @@ struct _StatCounters
         int times_used;
     } icp;
 
-    struct
-    {
+    struct {
         int pkts_sent;
         int pkts_recv;
     } htcp;
 
-    struct
-    {
+    struct {
         int requests;
     } unlink;
 
-    struct
-    {
+    struct {
         StatHist svc_time;
     } dns;
 
-    struct
-    {
+    struct {
         int times_used;
         kb_t kbytes_sent;
         kb_t kbytes_recv;
@@ -1279,8 +1194,7 @@ struct _StatCounters
         StatHist on_xition_count;
     } cd;
 
-    struct
-    {
+    struct {
         int times_used;
     } netdb;
     int page_faults;
@@ -1295,10 +1209,8 @@ struct _StatCounters
     StatHist comm_http_incoming;
     StatHist select_fds_hist;
 
-    struct
-    {
-        struct
-        {
+    struct {
+        struct {
             int opens;
             int closes;
             int reads;
@@ -1307,8 +1219,7 @@ struct _StatCounters
             int unlinks;
         } disk;
 
-        struct
-        {
+        struct {
             int accepts;
             int sockets;
             int connects;
@@ -1323,8 +1234,7 @@ struct _StatCounters
     } syscalls;
     int aborted_requests;
 
-    struct
-    {
+    struct {
         int files_cleaned;
         int outs;
         int ins;
@@ -1333,8 +1243,7 @@ struct _StatCounters
 
 /* per header statistics */
 
-struct _HttpHeaderStat
-{
+struct _HttpHeaderStat {
     const char *label;
     HttpHeaderMask *owner_mask;
 
@@ -1351,23 +1260,20 @@ struct _HttpHeaderStat
 };
 
 
-struct _ClientInfo
-{
+struct _ClientInfo {
     hash_link hash;		/* must be first */
 
     IPAddress addr;
 
-    struct
-    {
+    struct {
         int result_hist[LOG_TYPE_MAX];
         int n_requests;
         kb_t kbytes_in;
         kb_t kbytes_out;
         kb_t hit_kbytes_out;
     } Http, Icp;
 
-    struct
-    {
+    struct {
         time_t time;
         int n_req;
         int n_denied;
@@ -1376,8 +1282,7 @@ struct _ClientInfo
     time_t last_seen;
 };
 
-struct _CacheDigest
-{
+struct _CacheDigest {
     /* public, read-only */
     char *mask;			/* bit mask */
     int mask_size;		/* mask size in bytes */
@@ -1388,8 +1293,7 @@ struct _CacheDigest
 };
 
 
-struct _store_rebuild_data
-{
+struct _store_rebuild_data {
     int objcount;		/* # objects successfully reloaded */
     int expcount;		/* # objects expired */
     int scancount;		/* # entries scanned or read from state file */
@@ -1402,16 +1306,14 @@ struct _store_rebuild_data
     int zero_object_sz;
 };
 
-struct _Logfile
-{
+struct _Logfile {
     int fd;
     char path[MAXPATHLEN];
     char *buf;
     size_t bufsz;
     size_t offset;
 
-    struct
-    {
+    struct {
         unsigned int fatal;
         unsigned int syslog;
     } flags;
@@ -1421,15 +1323,13 @@ struct _Logfile
 
 class logformat_token;
 
-struct _logformat
-{
+struct _logformat {
     char *name;
     logformat_token *format;
     logformat *next;
 };
 
-struct _customlog
-{
+struct _customlog {
     char *filename;
     ACLList *aclList;
     logformat *logFormat;
@@ -99,7 +99,7 @@ commSetSelect(int fd, unsigned int type, PF * handler, void *client_data,
 void
 comm_quick_poll_required()
 {
-  /* for tests ... ignore */
+    /* for tests ... ignore */
 }
 
 int
@@ -134,11 +134,11 @@ fake_auth_setup()
         AuthConfig *schemeConfig;
         schemeConfig = getConfig(params[scheme].name);
         if (schemeConfig != NULL)
-            setup_scheme (schemeConfig, params[scheme].params, 
-                params[scheme].paramlength);
-		else
-            fprintf(stderr,"Skipping unknown authentication scheme '%s'.\n", 
-                params[scheme].name);
+            setup_scheme(schemeConfig, params[scheme].params,
+                          params[scheme].paramlength);
+        else
+            fprintf(stderr,"Skipping unknown authentication scheme '%s'.\n",
+                    params[scheme].name);
     }
 
     authenticateInit(&config);
@@ -1159,7 +1159,7 @@ parseEtcHosts(void)
             lt = nt + 1;
         }
 
-        if(hosts) {
+        if (hosts) {
             fqdncacheAddEntryFromHosts(addr, hosts);
             wordlistDestroy(&hosts);
         }
@@ -1257,7 +1257,7 @@ keepCapabilities(void)
 static void
 restoreCapabilities(int keep)
 {
-/* NP: keep these two if-endif separate. Non-Linux work perfectly well without Linux syscap support. */
+    /* NP: keep these two if-endif separate. Non-Linux work perfectly well without Linux syscap support. */
 #if defined(_SQUID_LINUX_)
 
 #if HAVE_SYS_CAPABILITY_H
@@ -1271,11 +1271,9 @@ restoreCapabilities(int keep)
 
     if (capget(head, cap) != 0) {
         debugs(50, DBG_IMPORTANT, "Can't get current capabilities");
-    }
-    else if (head->version != _LINUX_CAPABILITY_VERSION_1) {
+    } else if (head->version != _LINUX_CAPABILITY_VERSION_1) {
         debugs(50, DBG_IMPORTANT, "Invalid capability version " << head->version << " (expected " << _LINUX_CAPABILITY_VERSION_1 << ")");
-    }
-    else {
+    } else {
 
         head->pid = 0;
 