@@ -1773,55 +1773,60 @@ fi
 # }}}
 
 # --with-liboping {{{
-with_own_liboping="no"
-liboping_LDFLAGS="$LDFLAGS"
-liboping_CPPFLAGS="$CPPFLAGS"
 AC_ARG_WITH(liboping, [AS_HELP_STRING([--with-liboping@<:@=PREFIX@:>@], [Path to liboping.])],
 [
-	if test "x$withval" != "xno" && test "x$withval" != "xyes"
+ if test "x$withval" = "xyes"
+ then
+	 with_liboping="yes"
+ else if test "x$withval" = "xno"
+ then
+	 with_liboping="no"
+ else
+	 with_liboping="yes"
+	 LIBOPING_CPPFLAGS="$LIBOPING_CPPFLAGS -I$withval/include"
+	 LIBOPING_LDFLAGS="$LIBOPING_LDFLAGS -L$withval/lib"
+ fi; fi
+],
+[with_liboping="yes"])
+
+SAVE_CPPFLAGS="$CPPFLAGS"
+SAVE_LDFLAGS="$LDFLAGS"
+
+CPPFLAGS="$CPPFLAGS $LIBOPING_CPPFLAGS"
+LDFLAGS="$LDFLAGS $LIBOPING_LDFLAGS"
+
+if test "x$with_liboping" = "xyes"
+then
+	if test "x$LIBOPING_CPPFLAGS" != "x"
 	then
-		if test -d "$withval/lib"
-		then
-			liboping_LDFLAGS="$LDFLAGS -L$withval/lib"
-		fi
-		if test -d "$withval/include"
-		then
-			liboping_CPPFLAGS="$CPPFLAGS -I$withval/include"
-		fi
+		AC_MSG_NOTICE([liboping CPPFLAGS: $LIBOPING_CPPFLAGS])
 	fi
-	if test "x$withval" = "xno"
-	then
-		with_liboping="no"
-		with_own_liboping="no"
-	else if test "x$withval" = "xyes"
+	AC_CHECK_HEADERS(oping.h,
+	[with_liboping="yes"],
+	[with_liboping="no ('oping.h' not found)"])
+fi
+if test "x$with_liboping" = "xyes"
+then
+	if test "x$LIBOPING_LDFLAGS" != "x"
 	then
-		with_liboping="yes"
-	fi; fi
-],
-[
-	with_liboping="yes"
-])
+		AC_MSG_NOTICE([liboping LDFLAGS: $LIBOPING_LDFLAGS])
+	fi
+	AC_CHECK_LIB(oping, ping_construct,
+	[with_liboping="yes"],
+	[with_liboping="no (symbol 'ping_construct' not found)"])
+fi
+
+CPPFLAGS="$SAVE_CPPFLAGS"
+LDFLAGS="$SAVE_LDFLAGS"
 
 if test "x$with_liboping" = "xyes"
 then
-	save_LDFLAGS="$LDFLAGS"
-	save_CPPFLAGS="$CPPFLAGS"
-	LDFLAGS="$liboping_LDFLAGS"
-	CPPFLAGS="$liboping_CPPFLAGS"
-	AC_CHECK_LIB(oping, ping_construct,
-	[
-		with_liboping="yes"
-		with_own_liboping="no"
-	],
-	[
-		with_liboping="yes"
-		with_own_liboping="yes"
-		LDFLAGS="$save_LDFLAGS"
-		CPPFLAGS="$save_CPPFLAGS"
-	])
+	BUILD_WITH_LIBOPING_CPPFLAGS="$LIBOPING_CPPFLAGS"
+	BUILD_WITH_LIBOPING_LDFLAGS="$LIBOPING_LDFLAGS"
+	AC_SUBST(BUILD_WITH_LIBOPING_CPPFLAGS)
+	AC_SUBST(BUILD_WITH_LIBOPING_LDFLAGS)
 fi
 AM_CONDITIONAL(BUILD_WITH_LIBOPING, test "x$with_liboping" = "xyes")
-AM_CONDITIONAL(BUILD_WITH_OWN_LIBOPING, test "x$with_own_liboping" = "xyes")
 # }}}
 
 # --with-oracle {{{
@@ -3482,20 +3487,14 @@ AC_SUBST(LCC_VERSION_STRING)
 
 AC_CONFIG_FILES(src/libcollectdclient/lcc_features.h)
 
-AC_OUTPUT(Makefile src/Makefile src/collectd.conf src/libiptc/Makefile src/libcollectdclient/Makefile src/libcollectdclient/libcollectdclient.pc src/liboconfig/Makefile src/liboping/Makefile bindings/Makefile)
+AC_OUTPUT(Makefile src/Makefile src/collectd.conf src/libiptc/Makefile src/libcollectdclient/Makefile src/libcollectdclient/libcollectdclient.pc src/liboconfig/Makefile bindings/Makefile)
 
 if test "x$with_librrd" = "xyes" \
 	&& test "x$librrd_threadsafe" != "xyes"
 then
 	with_librrd="yes (warning: librrd is not thread-safe)"
 fi
 
-if test "x$with_liboping" = "xyes" \
-	&& test "x$with_own_liboping" = "xyes"
-then
-	with_liboping="yes (shipped version)"
-fi
-
 if test "x$with_libiptc" = "xyes" -a "x$with_own_libiptc" = "xyes"
 then
 	with_libiptc="yes (shipped version)"
@@ -5,9 +5,6 @@ endif
 if BUILD_WITH_OWN_LIBOCONFIG
 SUBDIRS += liboconfig
 endif
-if BUILD_WITH_OWN_LIBOPING
-SUBDIRS += liboping
-endif
 
 if COMPILER_IS_GCC
 AM_CFLAGS = -Wall -Werror
@@ -674,13 +671,9 @@ endif
 if BUILD_PLUGIN_PING
 pkglib_LTLIBRARIES += ping.la
 ping_la_SOURCES = ping.c
-ping_la_LDFLAGS = -module -avoid-version
-if BUILD_WITH_OWN_LIBOPING
-ping_la_LIBADD = liboping/liboping.la
-ping_la_DEPENDENCIES = liboping/liboping.la
-else
+ping_la_CPPFLAGS = $(AM_CPPFLAGS) $(BUILD_WITH_LIBOPING_CPPFLAGS)
+ping_la_LDFLAGS = -module -avoid-version $(BUILD_WITH_LIBOPING_LDFLAGS)
 ping_la_LIBADD = -loping
-endif
 collectd_LDADD += "-dlopen" ping.la
 collectd_DEPENDENCIES += ping.la
 endif
@@ -1,340 +0,0 @@
-		    GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.
-     51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Library General Public License instead.)  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-			    NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-	    How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-
-
-Also add information on how to contact you by electronic and paper mail.
-
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
-
-    Gnomovision version 69, Copyright (C) year  name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  <signature of Ty Coon>, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Library General
-Public License instead of this License.
@@ -1,31 +0,0 @@
-2006-06-05, Version 0.2.2
-	* The `oping' application didn't exit if no hosts could be resolved.
-	  This release fixes it's behavior.
-
-2006-06-01, Version 0.2.1
-	* Fix the behavior for non GNU-Linux systems. liboping tried to
-	  `bind(2)' to the raw-socket it uses to send ICMP packets. Apparently
-	  (decided by majority vote ;) this is not the right thing to do.
-	  GNU/Linux never complained about it, but works find without the bind.
-	  Other operating systems don't work at all with the bind.
-	* Build fixes for non-GNU/Linux platforms: Mac OS X doesn't define
-	  `size_t' as `unsigned int' and therefore needs casting and FreeBSD
-	  needs to have `sys/types.h' included before `netinet/*.h'
-
-2006-05-29, Version 0.2.0
-	* It's now possible to set the data to be send to the remote host and
-	  to get the data received from the host.
-	* The `oping' binary now calculates the standard deviation. Also, it
-	  displays the number of byes that were received and other output
-	  changes.
-	* Hosts are now returned in the same order as they were added by
-	  `ping_host_add'. This is not guaranteed, but makes `oping' prettier.
-
-2006-05-12, Version 0.1.1
-	* A bug in the library has been fixed: When the sequence got higher
-	  than 2^16 the counter in the packets wrapped around, but the
-	  internal counter didn't, causing the library to ignore all further
-	  ICMP packets. This affected both, ICMPv4 and ICMPv6.
-
-2006-05-08, Version 0.1.0
-	* Initial release.
@@ -1,16 +0,0 @@
-AUTOMAKE_OPTIONS = foreign no-dependencies
-
-if COMPILER_IS_GCC
-AM_CFLAGS = -Wall -Werror
-endif
-
-EXTRA_DIST = AUTHORS COPYING ChangeLog README
-
-noinst_LTLIBRARIES = liboping.la
-
-#liboping_la_CFLAGS = 
-liboping_la_LDFLAGS = -version-info 0:3:0
-if BUILD_WITH_LIBSOCKET
-liboping_la_LDFLAGS += -lsocket
-endif
-liboping_la_SOURCES = liboping.c oping.h
@@ -1,28 +0,0 @@
- liboping - Library to ping IPv4 and IPv6 hosts in parallel
-============================================================
-http://verplant.org/liboping/
-
-About
------
-
-  liboping was inspired by ping, libping and fping: It differs from these
-  existing solutions in that it can `ping' multiple hosts in parallel using
-  IPv4 or IPv6 transparently. Other design principles were an object oriented
-  interface, simplicity and extensibility.
-
-
-Features
---------
-
-  * Support for multiple hosts.
-
-  * Support for IPv4 and IPv6.
-
-  * Object oriented interface.
-
-
-Author
-------
-
-  Florian octo Forster <octo at verplant.org>
-
@@ -1,1220 +0,0 @@
-/**
- * Object oriented C module to send ICMP and ICMPv6 `echo's.
- * Copyright (C) 2006  Florian octo Forster <octo at verplant.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
- */
-
-#if HAVE_CONFIG_H
-# include <config.h>
-#endif
-
-#if STDC_HEADERS
-# include <stdlib.h>
-# include <stdio.h>
-# include <string.h>
-# include <errno.h>
-# include <assert.h>
-#else
-# error "You don't have the standard C99 header files installed"
-#endif /* STDC_HEADERS */
-
-#if HAVE_UNISTD_H
-# include <unistd.h>
-#endif
-
-#if HAVE_FCNTL_H
-# include <fcntl.h>
-#endif
-#if HAVE_SYS_TYPES_H
-# include <sys/types.h>
-#endif
-#if HAVE_SYS_STAT_H
-# include <sys/stat.h>
-#endif
-
-#if TIME_WITH_SYS_TIME
-# include <sys/time.h>
-# include <time.h>
-#else
-# if HAVE_SYS_TIME_H
-#  include <sys/time.h>
-# else
-#  include <time.h>
-# endif
-#endif
-
-#if HAVE_SYS_SOCKET_H
-# include <sys/socket.h>
-#endif
-#if HAVE_NETDB_H
-# include <netdb.h>
-#endif
-
-#if HAVE_NETINET_IN_SYSTM_H
-# include <netinet/in_systm.h>
-#endif
-#if HAVE_NETINET_IN_H
-# include <netinet/in.h>
-#endif
-#if HAVE_NETINET_IP_H
-# include <netinet/ip.h>
-#endif
-#if HAVE_NETINET_IP_ICMP_H
-# include <netinet/ip_icmp.h>
-#endif
-#ifdef HAVE_NETINET_IP_VAR_H
-# include <netinet/ip_var.h>
-#endif
-#if HAVE_NETINET_IP6_H
-# include <netinet/ip6.h>
-#endif
-#if HAVE_NETINET_ICMP6_H
-# include <netinet/icmp6.h>
-#endif
-
-#include "oping.h"
-
-#if WITH_DEBUG
-# define dprintf(...) printf ("%s[%4i]: %-20s: ", __FILE__, __LINE__, __FUNCTION__); printf (__VA_ARGS__)
-#else
-# define dprintf(...) /**/
-#endif
-
-#define PING_ERRMSG_LEN 256
-
-struct pinghost
-{
-	char                    *hostname;
-	struct sockaddr_storage *addr;
-	socklen_t                addrlen;
-	int                      addrfamily;
-	int                      fd;
-	int                      ident;
-	int                      sequence;
-	struct timeval          *timer;
-	double                   latency;
-	char                    *data;
-
-	void                    *context;
-
-	struct pinghost         *next;
-};
-
-struct pingobj
-{
-	double      timeout;
-	int         ttl;
-	int         addrfamily;
-	char       *data;
-
-	char        errmsg[PING_ERRMSG_LEN];
-
-	pinghost_t *head;
-};
-
-/*
- * private (static) functions
- */
-static void ping_set_error (pingobj_t *obj, const char *function,
-	       	const char *message)
-{
-	snprintf (obj->errmsg, PING_ERRMSG_LEN, "%s: %s", function, message);
-	obj->errmsg[PING_ERRMSG_LEN - 1] = '\0';
-}
-
-static int ping_timeval_add (struct timeval *tv1, struct timeval *tv2,
-		struct timeval *res)
-{
-	res->tv_sec  = tv1->tv_sec  + tv2->tv_sec;
-	res->tv_usec = tv1->tv_usec + tv2->tv_usec;
-
-	while (res->tv_usec > 1000000)
-	{
-		res->tv_usec -= 1000000;
-		res->tv_sec++;
-	}
-
-	return (0);
-}
-
-static int ping_timeval_sub (struct timeval *tv1, struct timeval *tv2,
-		struct timeval *res)
-{
-
-	if ((tv1->tv_sec < tv2->tv_sec)
-			|| ((tv1->tv_sec == tv2->tv_sec)
-				&& (tv1->tv_usec < tv2->tv_usec)))
-		return (-1);
-
-	res->tv_sec  = tv1->tv_sec  - tv2->tv_sec;
-	res->tv_usec = tv1->tv_usec - tv2->tv_usec;
-
-	assert ((res->tv_sec > 0) || ((res->tv_sec == 0) && (res->tv_usec > 0)));
-
-	while (res->tv_usec < 0)
-	{
-		res->tv_usec += 1000000;
-		res->tv_sec--;
-	}
-
-	return (0);
-}
-
-static uint16_t ping_icmp4_checksum (char *buf, size_t len)
-{
-	uint32_t sum = 0;
-	uint16_t ret = 0;
-
-	uint16_t *ptr;
-
-	for (ptr = (uint16_t *) buf; len > 1; ptr++, len -= 2)
-		sum += *ptr;
-
-	if (len == 1)
-	{
-		*(char *) &ret = *(char *) ptr;
-		sum += ret;
-	}
-
-	/* Do this twice to get all possible carries.. */
-	sum = (sum >> 16) + (sum & 0xFFFF);
-	sum = (sum >> 16) + (sum & 0xFFFF);
-
-	ret = ~sum;
-
-	return (ret);
-}
-
-static pinghost_t *ping_receive_ipv4 (pinghost_t *ph, char *buffer, size_t buffer_len)
-{
-	struct ip *ip_hdr;
-	struct icmp *icmp_hdr;
-
-	size_t ip_hdr_len;
-
-	uint16_t recv_checksum;
-	uint16_t calc_checksum;
-
-	uint16_t ident;
-	uint16_t seq;
-
-	pinghost_t *ptr;
-
-	if (buffer_len < sizeof (struct ip))
-		return (NULL);
-
-	ip_hdr     = (struct ip *) buffer;
-	ip_hdr_len = ip_hdr->ip_hl << 2;
-
-	if (buffer_len < ip_hdr_len)
-		return (NULL);
-
-	buffer     += ip_hdr_len;
-	buffer_len -= ip_hdr_len;
-
-	if (buffer_len < sizeof (struct icmp))
-		return (NULL);
-
-	icmp_hdr = (struct icmp *) buffer;
-	buffer     += sizeof (struct icmp);
-	buffer_len -= sizeof (struct icmp);
-
-	if (icmp_hdr->icmp_type != ICMP_ECHOREPLY)
-	{
-		dprintf ("Unexpected ICMP type: %i\n", icmp_hdr->icmp_type);
-		return (NULL);
-	}
-
-	recv_checksum = icmp_hdr->icmp_cksum;
-	icmp_hdr->icmp_cksum = 0;
-	calc_checksum = ping_icmp4_checksum ((char *) icmp_hdr,
-			sizeof (struct icmp) + buffer_len);
-
-	if (recv_checksum != calc_checksum)
-	{
-		dprintf ("Checksum missmatch: Got 0x%04x, calculated 0x%04x\n",
-				recv_checksum, calc_checksum);
-		return (NULL);
-	}
-
-	ident = ntohs (icmp_hdr->icmp_id);
-	seq   = ntohs (icmp_hdr->icmp_seq);
-
-	for (ptr = ph; ptr != NULL; ptr = ptr->next)
-	{
-		dprintf ("hostname = %s, ident = 0x%04x, seq = %i\n",
-				ptr->hostname, ptr->ident, ((ptr->sequence - 1) & 0xFFFF));
-
-		if (ptr->addrfamily != AF_INET)
-			continue;
-
-		if (!timerisset (ptr->timer))
-			continue;
-
-		if (ptr->ident != ident)
-			continue;
-
-		if (((ptr->sequence - 1) & 0xFFFF) != seq)
-			continue;
-
-		dprintf ("Match found: hostname = %s, ident = 0x%04x, seq = %i\n",
-				ptr->hostname, ident, seq);
-
-		break;
-	}
-
-	if (ptr == NULL)
-	{
-		dprintf ("No match found for ident = 0x%04x, seq = %i\n",
-				ident, seq);
-	}
-
-	return (ptr);
-}
-
-static pinghost_t *ping_receive_ipv6 (pinghost_t *ph, char *buffer, size_t buffer_len)
-{
-	struct icmp6_hdr *icmp_hdr;
-
-	uint16_t ident;
-	uint16_t seq;
-
-	pinghost_t *ptr;
-
-	if (buffer_len < sizeof (struct icmp6_hdr))
-		return (NULL);
-
-	icmp_hdr = (struct icmp6_hdr *) buffer;
-	buffer     += sizeof (struct icmp);
-	buffer_len -= sizeof (struct icmp);
-
-	if (icmp_hdr->icmp6_type != ICMP6_ECHO_REPLY)
-	{
-		dprintf ("Unexpected ICMP type: %02x\n", icmp_hdr->icmp6_type);
-		return (NULL);
-	}
-
-	if (icmp_hdr->icmp6_code != 0)
-	{
-		dprintf ("Unexpected ICMP code: %02x\n", icmp_hdr->icmp6_code);
-		return (NULL);
-	}
-
-	ident = ntohs (icmp_hdr->icmp6_id);
-	seq   = ntohs (icmp_hdr->icmp6_seq);
-
-	for (ptr = ph; ptr != NULL; ptr = ptr->next)
-	{
-		dprintf ("hostname = %s, ident = 0x%04x, seq = %i\n",
-				ptr->hostname, ptr->ident, ((ptr->sequence - 1) & 0xFFFF));
-
-		if (ptr->addrfamily != AF_INET6)
-			continue;
-
-		if (!timerisset (ptr->timer))
-			continue;
-
-		if (ptr->ident != ident)
-			continue;
-
-		if (((ptr->sequence - 1) & 0xFFFF) != seq)
-			continue;
-
-		dprintf ("Match found: hostname = %s, ident = 0x%04x, seq = %i\n",
-				ptr->hostname, ident, seq);
-
-		break;
-	}
-
-	if (ptr == NULL)
-	{
-		dprintf ("No match found for ident = 0x%04x, seq = %i\n",
-				ident, seq);
-	}
-
-	return (ptr);
-}
-
-static int ping_receive_one (int fd, pinghost_t *ph, struct timeval *now)
-{
-	char   buffer[4096];
-	size_t buffer_len;
-
-	struct timeval diff;
-
-	pinghost_t *host = NULL;
-
-	struct sockaddr_storage sa;
-	socklen_t               sa_len;
-
-	sa_len = sizeof (sa);
-
-	buffer_len = recvfrom (fd, buffer, sizeof (buffer), 0,
-			(struct sockaddr *) &sa, &sa_len);
-	if (buffer_len == -1)
-	{
-		dprintf ("recvfrom: %s\n", strerror (errno));
-		return (-1);
-	}
-
-	dprintf ("Read %u bytes from fd = %i\n", (unsigned int) buffer_len, fd);
-
-	if (sa.ss_family == AF_INET)
-	{
-		if ((host = ping_receive_ipv4 (ph, buffer, buffer_len)) == NULL)
-			return (-1);
-	}
-	else if (sa.ss_family == AF_INET6)
-	{
-		if ((host = ping_receive_ipv6 (ph, buffer, buffer_len)) == NULL)
-			return (-1);
-	}
-
-	dprintf ("rcvd: %12i.%06i\n",
-			(int) now->tv_sec,
-			(int) now->tv_usec);
-	dprintf ("sent: %12i.%06i\n",
-			(int) host->timer->tv_sec,
-			(int) host->timer->tv_usec);
-
-	if (ping_timeval_sub (now, host->timer, &diff) < 0)
-	{
-		timerclear (host->timer);
-		return (-1);
-	}
-
-	dprintf ("diff: %12i.%06i\n",
-			(int) diff.tv_sec,
-			(int) diff.tv_usec);
-
-	host->latency  = ((double) diff.tv_usec) / 1000.0;
-	host->latency += ((double) diff.tv_sec)  * 1000.0;
-
-	timerclear (host->timer);
-
-	return (0);
-}
-
-static int ping_receive_all (pingobj_t *obj)
-{
-	fd_set readfds;
-	int num_readfds;
-	int max_readfds;
-
-	pinghost_t *ph;
-	pinghost_t *ptr;
-
-	struct timeval endtime;
-	struct timeval nowtime;
-	struct timeval timeout;
-	int status;
-
-	int ret;
-
-	ph = obj->head;
-	ret = 0;
-
-	for (ptr = ph; ptr != NULL; ptr = ptr->next)
-		ptr->latency = -1.0;
-
-	if (gettimeofday (&nowtime, NULL) == -1)
-	{
-		ping_set_error (obj, "gettimeofday", strerror (errno));
-		return (-1);
-	}
-
-	/* Set up timeout */
-	timeout.tv_sec = (time_t) obj->timeout;
-	timeout.tv_usec = (suseconds_t) (1000000 * (obj->timeout - ((double) timeout.tv_sec)));
-
-	dprintf ("Set timeout to %i.%06i seconds\n",
-			(int) timeout.tv_sec,
-			(int) timeout.tv_usec);
-
-	ping_timeval_add (&nowtime, &timeout, &endtime);
-
-	while (1)
-	{
-		FD_ZERO (&readfds);
-		num_readfds =  0;
-		max_readfds = -1;
-
-		for (ptr = ph; ptr != NULL; ptr = ptr->next)
-		{
-			if (!timerisset (ptr->timer))
-				continue;
-
-			FD_SET (ptr->fd, &readfds);
-			num_readfds++;
-
-			if (max_readfds < ptr->fd)
-				max_readfds = ptr->fd;
-		}
-
-		if (num_readfds == 0)
-			break;
-
-		if (gettimeofday (&nowtime, NULL) == -1)
-		{
-			ping_set_error (obj, "gettimeofday", strerror (errno));
-			return (-1);
-		}
-
-		if (ping_timeval_sub (&endtime, &nowtime, &timeout) == -1)
-			break;
-
-		dprintf ("Waiting on %i sockets for %i.%06i seconds\n", num_readfds,
-				(int) timeout.tv_sec,
-				(int) timeout.tv_usec);
-
-		status = select (max_readfds + 1, &readfds, NULL, NULL, &timeout);
-
-		if (gettimeofday (&nowtime, NULL) == -1)
-		{
-			ping_set_error (obj, "gettimeofday", strerror (errno));
-			return (-1);
-		}
-		
-		if ((status == -1) && (errno == EINTR))
-		{
-			dprintf ("select was interrupted by signal..\n");
-			continue;
-		}
-		else if (status < 0)
-		{
-			dprintf ("select: %s\n", strerror (errno));
-			break;
-		}
-		else if (status == 0)
-		{
-			dprintf ("select timed out\n");
-			break;
-		}
-
-		for (ptr = ph; ptr != NULL; ptr = ptr->next)
-		{
-			if (FD_ISSET (ptr->fd, &readfds))
-				if (ping_receive_one (ptr->fd, ph, &nowtime) == 0)
-					ret++;
-		}
-	} /* while (1) */
-	
-	return (ret);
-}
-
-/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
- * Sending functions:                                                        *
- *                                                                           *
- * ping_send_all                                                             *
- * +-> ping_send_one_ipv4                                                    *
- * `-> ping_send_one_ipv6                                                    *
- * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
-static ssize_t ping_sendto (pingobj_t *obj, pinghost_t *ph,
-		const void *buf, size_t buflen)
-{
-	ssize_t ret;
-
-	if (gettimeofday (ph->timer, NULL) == -1)
-	{
-		timerclear (ph->timer);
-		return (-1);
-	}
-
-	ret = sendto (ph->fd, buf, buflen, 0,
-			(struct sockaddr *) ph->addr, ph->addrlen);
-
-	if (ret < 0)
-	{
-#if defined(EHOSTUNREACH)
-		if (errno == EHOSTUNREACH)
-			return (0);
-#endif
-#if defined(ENETUNREACH)
-		if (errno == ENETUNREACH)
-			return (0);
-#endif
-		ping_set_error (obj, "sendto", strerror (errno));
-	}
-
-	return (ret);
-}
-
-static int ping_send_one_ipv4 (pingobj_t *obj, pinghost_t *ph)
-{
-	struct icmp *icmp4;
-	int status;
-
-	char buf[4096];
-	int  buflen;
-
-	char *data;
-	int   datalen;
-
-	dprintf ("ph->hostname = %s\n", ph->hostname);
-
-	memset (buf, '\0', sizeof (buf));
-	icmp4 = (struct icmp *) buf;
-	data  = (char *) (icmp4 + 1);
-
-	icmp4->icmp_type  = ICMP_ECHO;
-	icmp4->icmp_code  = 0;
-	icmp4->icmp_cksum = 0;
-	icmp4->icmp_id    = htons (ph->ident);
-	icmp4->icmp_seq   = htons (ph->sequence);
-
-	buflen = 4096 - sizeof (struct icmp);
-	strncpy (data, ph->data, buflen);
-	datalen = strlen (data);
-
-	buflen = datalen + sizeof (struct icmp);
-
-	icmp4->icmp_cksum = ping_icmp4_checksum (buf, buflen);
-
-	dprintf ("Sending ICMPv4 package with ID 0x%04x\n", ph->ident);
-
-	status = ping_sendto (obj, ph, buf, buflen);
-	if (status < 0)
-	{
-		perror ("ping_sendto");
-		return (-1);
-	}
-
-	dprintf ("sendto: status = %i\n", status);
-
-	return (0);
-}
-
-static int ping_send_one_ipv6 (pingobj_t *obj, pinghost_t *ph)
-{
-	struct icmp6_hdr *icmp6;
-	int status;
-
-	char buf[4096];
-	int  buflen;
-
-	char *data;
-	int   datalen;
-
-	dprintf ("ph->hostname = %s\n", ph->hostname);
-
-	memset (buf, '\0', sizeof (buf));
-	icmp6 = (struct icmp6_hdr *) buf;
-	data  = (char *) (icmp6 + 1);
-
-	icmp6->icmp6_type  = ICMP6_ECHO_REQUEST;
-	icmp6->icmp6_code  = 0;
-	/* The checksum will be calculated by the TCP/IP stack.  */
-	/* FIXME */
-	icmp6->icmp6_cksum = 0;
-	icmp6->icmp6_id    = htons (ph->ident);
-	icmp6->icmp6_seq   = htons (ph->sequence);
-
-	buflen = 4096 - sizeof (struct icmp6_hdr);
-	strncpy (data, ph->data, buflen);
-	datalen = strlen (data);
-
-	buflen = datalen + sizeof (struct icmp6_hdr);
-
-	dprintf ("Sending ICMPv6 package with ID 0x%04x\n", ph->ident);
-
-	status = ping_sendto (obj, ph, buf, buflen);
-	if (status < 0)
-	{
-		perror ("ping_sendto");
-		return (-1);
-	}
-
-	dprintf ("sendto: status = %i\n", status);
-
-	return (0);
-}
-
-static int ping_send_all (pingobj_t *obj)
-{
-	pinghost_t *ph;
-	pinghost_t *ptr;
-
-	int ret;
-
-	ret = 0;
-	ph = obj->head;
-
-	for (ptr = ph; ptr != NULL; ptr = ptr->next)
-	{
-		/* start timer.. The GNU `ping6' starts the timer before
-		 * sending the packet, so I will do that too */
-		if (gettimeofday (ptr->timer, NULL) == -1)
-		{
-			dprintf ("gettimeofday: %s\n", strerror (errno));
-			timerclear (ptr->timer);
-			ret--;
-			continue;
-		}
-		else
-		{
-			dprintf ("timer set for hostname = %s\n", ptr->hostname);
-		}
-
-		if (ptr->addrfamily == AF_INET6)
-		{	
-			dprintf ("Sending ICMPv6 echo request to `%s'\n", ptr->hostname);
-			if (ping_send_one_ipv6 (obj, ptr) != 0)
-			{
-				timerclear (ptr->timer);
-				ret--;
-				continue;
-			}
-		}
-		else if (ptr->addrfamily == AF_INET)
-		{
-			dprintf ("Sending ICMPv4 echo request to `%s'\n", ptr->hostname);
-			if (ping_send_one_ipv4 (obj, ptr) != 0)
-			{
-				timerclear (ptr->timer);
-				ret--;
-				continue;
-			}
-		}
-		else /* this should not happen */
-		{
-			dprintf ("Unknown address family: %i\n", ptr->addrfamily);
-			timerclear (ptr->timer);
-			ret--;
-			continue;
-		}
-
-		ptr->sequence++;
-	}
-
-	return (ret);
-}
-
-/*
- * Set the TTL of a socket protocol independently.
- */
-static int ping_set_ttl (pinghost_t *ph, int ttl)
-{
-	int ret = -2;
-
-	if (ph->addrfamily == AF_INET)
-	{
-		ret = setsockopt (ph->fd, IPPROTO_IP, IP_TTL, &ttl, sizeof (ttl));
-	}
-	else if (ph->addrfamily == AF_INET6)
-	{
-		ret = setsockopt (ph->fd, IPPROTO_IPV6, IPV6_UNICAST_HOPS, &ttl, sizeof (ttl));
-	}
-
-	return (ret);
-}
-
-static int ping_get_ident (void)
-{
-	int fd;
-	static int did_seed = 0;
-
-	int retval;
-
-	if (did_seed == 0)
-	{
-		if ((fd = open ("/dev/urandom", O_RDONLY)) != -1)
-		{
-			unsigned int seed;
-
-			if (read (fd, &seed, sizeof (seed)) != -1)
-			{
-				did_seed = 1;
-				dprintf ("Random seed: %i\n", seed);
-				srandom (seed);
-			}
-
-			close (fd);
-		}
-		else
-		{
-			dprintf ("open (/dev/urandom): %s\n", strerror (errno));
-		}
-	}
-
-	retval = (int) random ();
-
-	dprintf ("Random number: %i\n", retval);
-	
-	return (retval);
-}
-
-static pinghost_t *ping_alloc (void)
-{
-	pinghost_t *ph;
-	size_t      ph_size;
-
-	ph_size = sizeof (pinghost_t)
-		+ sizeof (struct sockaddr_storage)
-		+ sizeof (struct timeval);
-
-	ph = (pinghost_t *) malloc (ph_size);
-	if (ph == NULL)
-		return (NULL);
-
-	memset (ph, '\0', ph_size);
-
-	ph->timer   = (struct timeval *) (ph + 1);
-	ph->addr    = (struct sockaddr_storage *) (ph->timer + 1);
-
-	ph->addrlen = sizeof (struct sockaddr_storage);
-	ph->latency = -1.0;
-	ph->ident   = ping_get_ident () & 0xFFFF;
-
-	return (ph);
-}
-
-static void ping_free (pinghost_t *ph)
-{
-	if (ph->hostname != NULL)
-		free (ph->hostname);
-
-	if (ph->data != NULL)
-		free (ph->data);
-
-	free (ph);
-}
-
-/*
- * public methods
- */
-const char *ping_get_error (pingobj_t *obj)
-{
-	return (obj->errmsg);
-}
-
-pingobj_t *ping_construct (void)
-{
-	pingobj_t *obj;
-
-	if ((obj = (pingobj_t *) malloc (sizeof (pingobj_t))) == NULL)
-		return (NULL);
-	memset (obj, '\0', sizeof (pingobj_t));
-
-	obj->timeout    = PING_DEF_TIMEOUT;
-	obj->ttl        = PING_DEF_TTL;
-	obj->addrfamily = PING_DEF_AF;
-	obj->data       = strdup (PING_DEF_DATA);
-
-	return (obj);
-}
-
-void ping_destroy (pingobj_t *obj)
-{
-	pinghost_t *current;
-	pinghost_t *next;
-
-	current = obj->head;
-	next = NULL;
-
-	while (current != NULL)
-	{
-		next = current->next;
-		ping_free (current);
-		current = next;
-	}
-
-	if (obj->data != NULL)
-		free (obj->data);
-
-	free (obj);
-
-	return;
-}
-
-int ping_setopt (pingobj_t *obj, int option, void *value)
-{
-	int ret = 0;
-
-	switch (option)
-	{
-		case PING_OPT_TIMEOUT:
-			obj->timeout = *((double *) value);
-			if (obj->timeout < 0.0)
-			{
-				obj->timeout = PING_DEF_TIMEOUT;
-				ret = -1;
-			}
-			break;
-
-		case PING_OPT_TTL:
-			obj->ttl = *((int *) value);
-			if ((obj->ttl < 1) || (obj->ttl > 255))
-			{
-				obj->ttl = PING_DEF_TTL;
-				ret = -1;
-			}
-			break;
-
-		case PING_OPT_AF:
-			obj->addrfamily = *((int *) value);
-			if ((obj->addrfamily != AF_UNSPEC)
-					&& (obj->addrfamily != AF_INET)
-					&& (obj->addrfamily != AF_INET6))
-			{
-				obj->addrfamily = PING_DEF_AF;
-				ret = -1;
-			}
-			break;
-
-		case PING_OPT_DATA:
-			if (obj->data != NULL)
-			{
-				free (obj->data);
-				obj->data = NULL;
-			}
-			obj->data = strdup ((const char *) value);
-			break;
-
-		default:
-			ret = -2;
-	} /* switch (option) */
-
-	return (ret);
-} /* int ping_setopt */
-
-
-int ping_send (pingobj_t *obj)
-{
-	int ret;
-
-	if (ping_send_all (obj) < 0)
-		return (-1);
-
-	if ((ret = ping_receive_all (obj)) < 0)
-		return (-2);
-
-	return (ret);
-}
-
-static pinghost_t *ping_host_search (pinghost_t *ph, const char *host)
-{
-	while (ph != NULL)
-	{
-		if (strcasecmp (ph->hostname, host) == 0)
-			break;
-
-		ph = ph->next;
-	}
-
-	return (ph);
-}
-
-int ping_host_add (pingobj_t *obj, const char *host)
-{
-	pinghost_t *ph;
-
-	struct addrinfo  ai_hints;
-	struct addrinfo *ai_list, *ai_ptr;
-	int              ai_return;
-
-	dprintf ("host = %s\n", host);
-
-	if (ping_host_search (obj->head, host) != NULL)
-		return (0);
-
-	memset (&ai_hints, '\0', sizeof (ai_hints));
-	ai_hints.ai_flags     = 0;
-#ifdef AI_ADDRCONFIG
-	ai_hints.ai_flags    |= AI_ADDRCONFIG;
-#endif
-	ai_hints.ai_family    = obj->addrfamily;
-	ai_hints.ai_socktype  = SOCK_RAW;
-
-	if ((ph = ping_alloc ()) == NULL)
-	{
-		dprintf ("Out of memory!\n");
-		return (-1);
-	}
-
-	if ((ph->hostname = strdup (host)) == NULL)
-	{
-		dprintf ("Out of memory!\n");
-		ping_set_error (obj, "strdup", strerror (errno));
-		ping_free (ph);
-		return (-1);
-	}
-
-	/* obj->data is not garuanteed to be != NULL */
-	if ((ph->data = strdup (obj->data == NULL ? PING_DEF_DATA : obj->data)) == NULL)
-	{
-		dprintf ("Out of memory!\n");
-		ping_set_error (obj, "strdup", strerror (errno));
-		ping_free (ph);
-		return (-1);
-	}
-
-	if ((ai_return = getaddrinfo (host, NULL, &ai_hints, &ai_list)) != 0)
-	{
-		dprintf ("getaddrinfo failed\n");
-		ping_set_error (obj, "getaddrinfo",
-			       	(ai_return == EAI_SYSTEM)
-				? strerror (errno)
-				: gai_strerror (ai_return));
-		ping_free (ph);
-		return (-1);
-	}
-
-	if (ai_list == NULL)
-		ping_set_error (obj, "getaddrinfo", "No hosts returned");
-
-	for (ai_ptr = ai_list; ai_ptr != NULL; ai_ptr = ai_ptr->ai_next)
-	{
-		ph->fd = -1;
-
-		if (ai_ptr->ai_family == AF_INET)
-		{
-			ai_ptr->ai_socktype = SOCK_RAW;
-			ai_ptr->ai_protocol = IPPROTO_ICMP;
-		}
-		else if (ai_ptr->ai_family == AF_INET6)
-		{
-			ai_ptr->ai_socktype = SOCK_RAW;
-			ai_ptr->ai_protocol = IPPROTO_ICMPV6;
-		}
-		else
-		{
-			char errmsg[PING_ERRMSG_LEN];
-
-			snprintf (errmsg, PING_ERRMSG_LEN, "Unknown `ai_family': %i", ai_ptr->ai_family);
-			errmsg[PING_ERRMSG_LEN - 1] = '\0';
-
-			dprintf (errmsg);
-			ping_set_error (obj, "getaddrinfo", errmsg);
-			continue;
-		}
-
-		/* TODO: Move this to a static function `ping_open_socket' and
-		 * call it whenever the socket dies. */
-		ph->fd = socket (ai_ptr->ai_family, ai_ptr->ai_socktype, ai_ptr->ai_protocol);
-		if (ph->fd == -1)
-		{
-			dprintf ("socket: %s\n", strerror (errno));
-			ping_set_error (obj, "socket", strerror (errno));
-			continue;
-		}
-
-/*
- * The majority vote of operating systems has decided that you don't need to
- * bind here. This code should be reactivated to bind to a specific address,
- * though. See the `-I' option of `ping(1)' (GNU).  -octo
- */
-#if 0
-		if (bind (ph->fd, (struct sockaddr *) &sockaddr, sockaddr_len) == -1)
-		{
-			dprintf ("bind: %s\n", strerror (errno));
-			ping_set_error (obj, "bind", strerror (errno));
-			close (ph->fd);
-			ph->fd = -1;
-			continue;
-		}
-#endif
-
-		assert (sizeof (struct sockaddr_storage) >= ai_ptr->ai_addrlen);
-		memset (ph->addr, '\0', sizeof (struct sockaddr_storage));
-		memcpy (ph->addr, ai_ptr->ai_addr, ai_ptr->ai_addrlen);
-		ph->addrlen = ai_ptr->ai_addrlen;
-		ph->addrfamily = ai_ptr->ai_family;
-
-		break;
-	}
-
-	freeaddrinfo (ai_list);
-
-	if (ph->fd < 0)
-	{
-		free (ph->hostname);
-		free (ph);
-		return (-1);
-	}
-
-	/*
-	 * Adding in the front is much easier, but then the iterator will
-	 * return the host that was added last as first host. That's just not
-	 * nice. -octo
-	 */
-	if (obj->head == NULL)
-	{
-		obj->head = ph;
-	}
-	else
-	{
-		pinghost_t *hptr;
-
-		hptr = obj->head;
-		while (hptr->next != NULL)
-			hptr = hptr->next;
-
-		assert ((hptr != NULL) && (hptr->next == NULL));
-		hptr->next = ph;
-	}
-
-	ping_set_ttl (ph, obj->ttl);
-
-	return (0);
-}
-
-int ping_host_remove (pingobj_t *obj, const char *host)
-{
-	pinghost_t *pre, *cur;
-
-	pre = NULL;
-	cur = obj->head;
-
-	while (cur != NULL)
-	{
-		if (strcasecmp (host, cur->hostname))
-			break;
-
-		pre = cur;
-		cur = cur->next;
-	}
-
-	if (cur == NULL)
-	{
-		ping_set_error (obj, "ping_host_remove", "Host not found");
-		return (-1);
-	}
-
-	if (pre == NULL)
-		obj->head = cur->next;
-	else
-		pre->next = cur->next;
-	
-	if (cur->fd >= 0)
-		close (cur->fd);
-
-	ping_free (cur);
-
-	return (0);
-}
-
-pingobj_iter_t *ping_iterator_get (pingobj_t *obj)
-{
-	return ((pingobj_iter_t *) obj->head);
-}
-
-pingobj_iter_t *ping_iterator_next (pingobj_iter_t *iter)
-{
-	return ((pingobj_iter_t *) iter->next);
-}
-
-int ping_iterator_get_info (pingobj_iter_t *iter, int info,
-		void *buffer, size_t *buffer_len)
-{
-	int ret = EINVAL;
-
-	size_t orig_buffer_len = *buffer_len;
-
-	switch (info)
-	{
-		case PING_INFO_HOSTNAME:
-			ret = ENOMEM;
-			*buffer_len = strlen (iter->hostname);
-			if (orig_buffer_len <= *buffer_len)
-				break;
-			/* Since (orig_buffer_len > *buffer_len) `strncpy'
-			 * will copy `*buffer_len' and pad the rest of
-			 * `buffer' with null-bytes */
-			strncpy (buffer, iter->hostname, orig_buffer_len);
-			ret = 0;
-			break;
-
-		case PING_INFO_ADDRESS:
-			ret = getnameinfo ((struct sockaddr *) iter->addr,
-					iter->addrlen,
-					(char *) buffer,
-					*buffer_len,
-					NULL, 0,
-					NI_NUMERICHOST);
-			if (ret != 0)
-			{
-				if ((ret == EAI_MEMORY)
-#ifdef EAI_OVERFLOW
-						|| (ret == EAI_OVERFLOW)
-#endif
-				   )
-					ret = ENOMEM;
-				else if (ret == EAI_SYSTEM)
-					/* XXX: Not thread-safe! */
-					ret = errno;
-				else
-					ret = EINVAL;
-			}
-			break;
-
-		case PING_INFO_FAMILY:
-			ret = ENOMEM;
-			*buffer_len = sizeof (int);
-			if (orig_buffer_len < sizeof (int))
-				break;
-			*((int *) buffer) = iter->addrfamily;
-			ret = 0;
-			break;
-
-		case PING_INFO_LATENCY:
-			ret = ENOMEM;
-			*buffer_len = sizeof (double);
-			if (orig_buffer_len < sizeof (double))
-				break;
-			*((double *) buffer) = iter->latency;
-			ret = 0;
-			break;
-
-		case PING_INFO_SEQUENCE:
-			ret = ENOMEM;
-			*buffer_len = sizeof (unsigned int);
-			if (orig_buffer_len < sizeof (unsigned int))
-				break;
-			*((unsigned int *) buffer) = (unsigned int) iter->sequence;
-			ret = 0;
-			break;
-
-		case PING_INFO_IDENT:
-			ret = ENOMEM;
-			*buffer_len = sizeof (uint16_t);
-			if (orig_buffer_len < sizeof (uint16_t))
-				break;
-			*((uint16_t *) buffer) = (uint16_t) iter->ident;
-			ret = 0;
-			break;
-
-		case PING_INFO_DATA:
-			ret = ENOMEM;
-			*buffer_len = strlen (iter->data);
-			if (orig_buffer_len < *buffer_len)
-				break;
-			strncpy ((char *) buffer, iter->data, orig_buffer_len);
-			ret = 0;
-			break;
-	}
-
-	return (ret);
-}
-
-void *ping_iterator_get_context (pingobj_iter_t *iter)
-{
-	return (iter->context);
-}
-
-void ping_iterator_set_context (pingobj_iter_t *iter, void *context)
-{
-	iter->context = context;
-}
@@ -1,89 +0,0 @@
-/**
- * Object oriented C module to send ICMP and ICMPv6 `echo's.
- * Copyright (C) 2006  Florian octo Forster <octo at verplant.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
- */
-
-#ifndef OCTO_PING_H
-#define OCTO_PING_H 1
-
-#if HAVE_CONFIG_H
-# include <config.h>
-#endif
-
-#if HAVE_STDLIB_H
-# include <stdlib.h>
-#endif
-#if HAVE_UNISTD_H
-# include <unistd.h>
-#endif
-#if HAVE_SYS_SOCKET_H
-# include <sys/socket.h>
-#endif
-
-/*
- * Type definitions
- */
-struct pinghost;
-typedef struct pinghost pinghost_t;
-
-typedef pinghost_t pingobj_iter_t;
-
-struct pingobj;
-typedef struct pingobj pingobj_t;
-
-#define PING_OPT_TIMEOUT 0x01
-#define PING_OPT_TTL     0x02
-#define PING_OPT_AF      0x04
-#define PING_OPT_DATA    0x08
-
-#define PING_DEF_TIMEOUT 1.0
-#define PING_DEF_TTL     255
-#define PING_DEF_AF      AF_UNSPEC
-#define PING_DEF_DATA    "Florian Forster <octo@verplant.org> http://verplant.org/"
-
-/*
- * Method definitions
- */
-pingobj_t *ping_construct (void);
-void ping_destroy (pingobj_t *obj);
-
-int ping_setopt (pingobj_t *obj, int option, void *value);
-
-int ping_send (pingobj_t *obj);
-
-int ping_host_add (pingobj_t *obj, const char *host);
-int ping_host_remove (pingobj_t *obj, const char *host);
-
-pingobj_iter_t *ping_iterator_get (pingobj_t *obj);
-pingobj_iter_t *ping_iterator_next (pingobj_iter_t *iter);
-
-#define PING_INFO_HOSTNAME 1
-#define PING_INFO_ADDRESS  2
-#define PING_INFO_FAMILY   3
-#define PING_INFO_LATENCY  4
-#define PING_INFO_SEQUENCE 5
-#define PING_INFO_IDENT    6
-#define PING_INFO_DATA     7
-int ping_iterator_get_info (pingobj_iter_t *iter, int info,
-		void *buffer, size_t *buffer_len);
-
-const char *ping_get_error (pingobj_t *obj);
-
-void *ping_iterator_get_context (pingobj_iter_t *iter);
-void  ping_iterator_set_context (pingobj_iter_t *iter, void *context);
-
-#endif /* OCTO_PING_H */
@@ -25,14 +25,13 @@
 #include "configfile.h"
 
 #include <pthread.h>
-
 #include <netinet/in.h>
-#include "liboping/oping.h"
-
 #if HAVE_NETDB_H
 # include <netdb.h> /* NI_MAXHOST */
 #endif
 
+#include <oping.h>
+
 #ifndef NI_MAXHOST
 # define NI_MAXHOST 1025
 #endif