@@ -1,5 +1,3 @@
-$Id$
-
 ==============================================================================
 
 SQUID Internet Object Cache  http://www.squid-cache.org
@@ -1,3 +1,52 @@
+Changes to squid-3.3.0.1 (21 Oct 2012):
+
+	- Bug 3610: Add peername_regex ACL
+	- Bug 3239: rename myip/myport as localip/localport
+	- Bug 3130: helpers are crashing too rapidly
+	- Add log_db_daemon SQL Database Logging Daemon
+	- Add ext_time_quota_acl helper managing sessions by bandwidth usage
+	- Add request_header_add option
+	- Support C++11 features where possible
+	- Support bump-ssl-server-first
+	- Support mimic SSL server certificates
+	- Remove --enable-ntlm-fail-open
+	- Fix TLS/SSL Options does not apply to the dynamically generated certificates
+	- Fix SslBump stuck after error
+	- Polish: display ACL enumeration text in debugs
+	- ... and many portability fixes for MacOS X, Windows and others
+	- ... and many compile error fixes
+	- ... and a very large amount of code polish for faster compilation
+
+Changes to squid-3.2.3 (21 Oct 2012):
+
+	- Regression: SMP crashes on startup with workers > 1
+	- Bug 3655: pinning failure breaks NTLM and Negotiate authentication
+	- SMP: Allow a UFS cache_dir entry to coexist with a shared memory cache entry
+	- HTTP/1.1: honour Cache-Control before Pragma:no-cache
+	- HTTP/1.1: Cache-Control compliance upgrade
+	- Remove obsoleted refresh_pattern ignore-no-cache option
+	- Fix IPv6 enabled squidclient
+	- ... and several compile fixes
+
+Changes to squid-3.2.2 (06 Oct 2012):
+
+	- Regression: Make login=PASS send no credentials when none available
+	- Regression: Handle dstdomain duplicates and overlapping names better
+	- Bug 3661: Segmentation fault when using more than 1 worker
+	- Bug 3660: ACLFilledChecklist::fd set with wrong fd for sslproxy_cert_error
+	- Bug 3658: ERR_ZERO_SIZE_OBJECT propagates out even after successful retry
+	- Bug 3648: polish String class files
+	- Bug 3647: parsing hier_code acl fails
+	- Bug 3626: forwarding loops on intercepted traffic
+	- Bug 3616: retrieve client connection for ACL checks from the related HttpRequest object
+	- Bug 3609: several RADIUS helper improvements
+	- Bug 3605: memory leak in Negotiate authentication
+	- Fix small memory leak in src ACL parse
+	- Fix maximum_single_addr_tries upgrade
+	- Fix chunked encoding on responses carrying a Content-Range header.
+	- Do not reuse persistent connections for PUTs to avoid ERR_ZERO_SIZE_OBJECT
+	- ... and several compile errors
+
 Changes to squid-3.2.1 (15 Aug 2012):
 
 	- Bug 3605: memory leak in peer selection
@@ -405,6 +454,24 @@ Changes to squid-3.2.0.1 (03 Aug 2010):
 	- ... and a great many testing improvements
 	- ... and many documentation updates
 
+Changes to squid-3.1.21 (23 Sep 2012):
+
+	- Bug 3622: peerClearRRStart scheduling multiple events
+	- Bug 3615: configure check for default max number of FDs is broken
+	- Bug 3607: --enable-auth documented default action incorrect
+	- Bug 3593: socket failure: Address family not supported by protocol
+	- Bug 3584: Detection of setresuid() is broken
+	- Bug 3568: Consolidate external_acl_type config dumping and add missing %%
+	- Bug 3564: eCAP not supporting CoAP URI schemes
+	- Bug 3484: Docs: sslproxy_cert_error example flawed
+	- Bug 3462: Delay Pools and ICAP
+	- Bug 3133: better fix: Memory leak handling requests for sites that don't exist
+	- Bug 2976: ERR_INVALID_URL for transparently captured requests when reconfiguring
+	- Silence IOS 15.1 unknown capabilities messages.
+	- Account for Store disk client quota when bandwidth-limiting the server.
+	- ... and several documentation fixes
+	- ... and several compile fixes
+
 Changes to squid-3.1.20 (08 Jun 2012):
 
 	- Regression Bug 3545: FreeBSD dnsserver segfaults
@@ -1,8 +1,6 @@
 
 Squid QUICKSTART
 
-$Id$
-
 This document is intended only for people who want to get Squid running
 quickly It is not a substitute for the real documentation.  Squid has
 many features, but only a few of them are useful at the beginning.  Use
@@ -196,12 +196,12 @@ AC_DEFUN([SQUID_EMBED_BUILD_INFO],[
     yes)
       if test -d "${srcdir}/.bzr"; then
         AC_PATH_PROG(BZR,bzr,$FALSE)
-        squid_bzr_branch_nick=`${BZR} nick 2>/dev/null`
+        squid_bzr_branch_nick=`cd ${srcdir} && ${BZR} nick 2>/dev/null`
         if test $? -eq 0 -a "x$squid_bzr_branch_nick" != "x"; then
-          squid_bzr_branch_revno=`${BZR} revno 2>/dev/null | sed 's/\"//g'`
+          squid_bzr_branch_revno=`cd ${srcdir} && ${BZR} revno 2>/dev/null | sed 's/\"//g'`
         fi
         if test $? -eq 0 -a "x$squid_bzr_branch_revno" != "x"; then
-          ${BZR} diff 2>&1 >/dev/null
+          sh -c "cd ${srcdir} && ${BZR} diff 2>&1 >/dev/null"
           if test $? -eq 1; then
               squid_bzr_branch_revno="$squid_bzr_branch_revno+changes"
           fi
@@ -1,7 +1,3 @@
-/*
- * $Id$
- */
-
 /* Extended regular expression matching and search library,
  * version 0.12.
  * (Implements POSIX draft P10003.2/D11.2, except for
@@ -1,6 +1,3 @@
-/*
- * $Id$
- */
 #ifndef SQUID_REGEXP_LIBRARY_H
 #define SQUID_REGEXP_LIBRARY_H
 
@@ -62,8 +62,8 @@ libcompat_squid_a_SOURCES = \
 	os/hpux.h \
 	os/linux.h \
 	os/macosx.h \
-	os/mswin.h \
-	mswin.cc \
+	os/mswindows.h \
+	mswindows.cc \
 	os/netbsd.h \
 	os/next.h \
 	os/openbsd.h \
@@ -72,8 +72,7 @@ libcompat_squid_a_SOURCES = \
 	os/qnx.h \
 	os/sgi.h \
 	os/solaris.h \
-	os/sunos.h \
-	os/windows.h
+	os/sunos.h
 
 libcompat_squid_a_LIBADD= $(LIBOBJS)
 
@@ -61,7 +61,7 @@
 #include "compat/os/hpux.h"
 #include "compat/os/linux.h"
 #include "compat/os/macosx.h"
-#include "compat/os/mswin.h"
+#include "compat/os/mswindows.h"
 #include "compat/os/netbsd.h"
 #include "compat/os/next.h"
 #include "compat/os/openbsd.h"
@@ -70,7 +70,6 @@
 #include "compat/os/sgi.h"
 #include "compat/os/solaris.h"
 #include "compat/os/sunos.h"
-#include "compat/os/windows.h"
 
 /*****************************************************/
 /* portabilities shared between all platforms and    */
@@ -1,6 +1,3 @@
-/*
- * $Id$
- */
 #ifndef SQUID_COMPAT_CPU_H
 #define SQUID_COMPAT_CPU_H
 
@@ -12,8 +12,6 @@
  *
  *    06-Oct-2007 : Various fixes to allow the build on MinGW
  *
- * Squid CVS $Id$
- *
  *  Original License and code follows.
  */
 #include "squid.h"
@@ -13,8 +13,6 @@
  *    16-Aug-2007 : Altered configure checks
  *                  Un-hacked slightly to use system gethostbyname()
  *
- * Squid CVS $Id$
- *
  *  Original License and code follows.
  */
 
@@ -14,8 +14,6 @@
  *                      - use xinet_ntop instead of inet_ntop
  *                      - use SQUIDHOSTNAMELEN instead of MAXHOSTNAMELEN
  *
- * Squid CVS $Id$
- *
  *  Original License and code follows.
  */
 #include "squid.h"
@@ -114,7 +112,7 @@
 #include <inttypes.h>
 #endif
 
-#if _SQUID_MSWIN_
+#if _SQUID_WINDOWS_
 #undef IN_ADDR
 #include <ws2tcpip.h>
 #endif
@@ -160,7 +158,6 @@ int flags;
     int family, i;
     const char *addr;
     uint32_t v4a;
-    int h_error;
     char numserv[512];
 
     if (sa == NULL)
@@ -262,14 +259,17 @@ int flags;
         goto numeric;
     } else {
 #if USE_GETIPNODEBY
+        int h_error = 0;
         hp = getipnodebyaddr(addr, afd->a_addrlen, afd->a_af, &h_error);
 #else
         hp = gethostbyaddr(addr, afd->a_addrlen, afd->a_af);
+#if 0 // getnameinfo.c:161:9: error: variable 'h_error' set but not used
 #if HAVE_H_ERRNO
         h_error = h_errno;
 #else
         h_error = EINVAL;
 #endif
+#endif /* 0 */
 #endif
 
         if (hp) {
@@ -16,8 +16,6 @@
  *
  *    04-Nov-2010: drop SPRINTF casting macro
  *
- * Squid CVS $Id$
- *
  *  Original License and code follows.
  */
 
@@ -13,8 +13,6 @@
  *
  *    28-Oct-2007: drop some dead code. now tested working without.
  *
- * Squid CVS $Id$
- *
  *  Original License and code follows.
  */
 
@@ -1,4 +1,3 @@
-
 /*
  * Windows support
  * AUTHOR: Guido Serassio <serassio@squid-cache.org>
@@ -33,32 +32,33 @@
  */
 
 #include "squid.h"
-#include "util.h"
 
-/* The following code section is part of an EXPERIMENTAL native */
-/* Windows NT/2000 Squid port - Compiles only on MS Visual C++ or MinGW */
-#if _SQUID_MSWIN_ || _SQUID_MINGW_
+// The following code section is part of an EXPERIMENTAL native Windows NT/2000 Squid port.
+// Compiles only on MS Visual C++ or MinGW
+// CygWin appears not to need any of these
+#if _SQUID_WINDOWS_ && !_SQUID_CYGWIN_
 
-#undef strerror
 #define sys_nerr _sys_nerr
 
 #undef assert
 #include <assert.h>
 #include <stdio.h>
 #include <fcntl.h>
-#include "squid_windows.h"
 #include <string.h>
 #include <sys/timeb.h>
 #if HAVE_WIN32_PSAPI
 #include <psapi.h>
 #endif
+#ifndef _MSWSOCK_
+#include <mswsock.h>
+#endif
 
 THREADLOCAL int ws32_result;
 LPCRITICAL_SECTION dbg_mutex = NULL;
 
 void GetProcessName(pid_t, char *);
 
-#if defined(_MSC_VER)		/* Microsoft C Compiler ONLY */
+#if HAVE_GETPAGESIZE > 1
 size_t
 getpagesize()
 {
@@ -70,55 +70,7 @@ getpagesize()
     }
     return system_pagesize;
 }
-#endif
-
-uid_t
-geteuid(void)
-{
-    return 100;
-}
-
-uid_t
-getuid(void)
-{
-    return 100;
-}
-
-int
-setuid(uid_t uid)
-{
-    return 0;
-}
-
-int
-seteuid(uid_t euid)
-{
-    return 0;
-}
-
-gid_t
-getegid(void)
-{
-    return 100;
-}
-
-gid_t
-getgid(void)
-{
-    return 100;
-}
-
-int
-setgid(gid_t gid)
-{
-    return 0;
-}
-
-int
-setegid(gid_t egid)
-{
-    return 0;
-}
+#endif /* HAVE_GETPAGESIZE > 1 */
 
 int
 chroot(const char *dirname)
@@ -132,14 +84,10 @@ chroot(const char *dirname)
 void
 GetProcessName(pid_t pid, char *ProcessName)
 {
-    HANDLE hProcess;
-
     strcpy(ProcessName, "unknown");
 #if HAVE_WIN32_PSAPI
     /* Get a handle to the process. */
-    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION |
-                           PROCESS_VM_READ,
-                           FALSE, pid);
+    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
     /* Get the process name. */
     if (NULL != hProcess) {
         HMODULE hMod;
@@ -154,7 +102,7 @@ GetProcessName(pid_t pid, char *ProcessName)
     } else
         return;
     CloseHandle(hProcess);
-#endif
+#endif /* HAVE_WIN32_PSAPI */
 }
 
 int
@@ -193,12 +141,12 @@ gettimeofday(struct timeval *pcur_time, void *tzp)
     pcur_time->tv_sec = current.time;
     pcur_time->tv_usec = current.millitm * 1000L;
     if (tz) {
-        tz->tz_minuteswest = current.timezone;	/* minutes west of Greenwich  */
-        tz->tz_dsttime = current.dstflag;	/* type of dst correction  */
+        tz->tz_minuteswest = current.timezone; /* minutes west of Greenwich  */
+        tz->tz_dsttime = current.dstflag;      /* type of dst correction  */
     }
     return 0;
 }
-#endif
+#endif /* !HAVE_GETTIMEOFDAY */
 
 int
 statfs(const char *path, struct statfs *sfs)
@@ -296,7 +244,7 @@ getgrnam(char *unused) {
     return &grp;
 }
 
-#if defined(__MINGW32__)	/* MinGW environment */
+#if _SQUID_MINGW_
 int
 _free_osfhnd(int filehandle)
 {
@@ -322,7 +270,7 @@ _free_osfhnd(int filehandle)
         return -1;
     }
 }
-#endif
+#endif /* _SQUID_MINGW_ */
 
 struct errorentry {
     unsigned long WIN32_code;
@@ -386,10 +334,8 @@ static struct errorentry errortable[] = {
 void
 WIN32_maperror(unsigned long WIN32_oserrno)
 {
-    int i;
-
     _doserrno = WIN32_oserrno;
-    for (i = 0; i < (sizeof(errortable) / sizeof(struct errorentry)); ++i) {
+    for (size_t i = 0; i < (sizeof(errortable) / sizeof(struct errorentry)); ++i) {
         if (WIN32_oserrno == errortable[i].WIN32_code) {
             errno = errortable[i].POSIX_errno;
             return;
@@ -402,4 +348,67 @@ WIN32_maperror(unsigned long WIN32_oserrno)
     else
         errno = EINVAL;
 }
-#endif
+
+/* syslog emulation layer derived from git */
+static HANDLE ms_eventlog;
+
+void
+openlog(const char *ident, int logopt, int facility)
+{
+    if (ms_eventlog)
+        return;
+
+    ms_eventlog = RegisterEventSourceA(NULL, ident);
+
+    // note: RegisterEventAtSourceA may fail and return NULL.
+    //   in that case we'll just retry at the next message or not log
+}
+#define SYSLOG_MAX_MSG_SIZE 1024
+
+void
+syslog(int priority, const char *fmt, ...)
+{
+    WORD logtype;
+    char *str=static_cast<char *>(xmalloc(SYSLOG_MAX_MSG_SIZE));
+    int str_len;
+    va_list ap;
+
+    if (!ms_eventlog)
+        return;
+
+    va_start(ap, fmt);
+    str_len = vsnprintf(str, SYSLOG_MAX_MSG_SIZE-1, fmt, ap);
+    va_end(ap);
+
+    if (str_len < 0) {
+        /* vsnprintf failed */
+        return;
+    }
+
+    switch (priority) {
+    case LOG_EMERG:
+    case LOG_ALERT:
+    case LOG_CRIT:
+    case LOG_ERR:
+        logtype = EVENTLOG_ERROR_TYPE;
+        break;
+
+    case LOG_WARNING:
+        logtype = EVENTLOG_WARNING_TYPE;
+        break;
+
+    case LOG_NOTICE:
+    case LOG_INFO:
+    case LOG_DEBUG:
+    default:
+        logtype = EVENTLOG_INFORMATION_TYPE;
+        break;
+    }
+
+    //Windows API suck. They are overengineered
+    ReportEventA(ms_eventlog, logtype, 0, 0, NULL, 1, 0,
+                 const_cast<const char **>(&str), NULL);
+}
+
+/* note: this is all MSWindows-specific code; all of it should be conditional */
+#endif /* _SQUID_WINDOWS_ */
@@ -29,11 +29,31 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-#ifndef SQUID_OS_MSWIN_H
-#define SQUID_OS_MSWIN_H
+#ifndef SQUID_OS_MSWINDOWS_H
+#define SQUID_OS_MSWINDOWS_H
 
 #if _SQUID_WINDOWS_
 
+/* we target Windows XP and later - some API are missing otherwise */
+#if _SQUID_MINGW_
+#if WINVER < 0x0501
+#undef WINVER
+#define WINVER 0x0501
+#undef _WIN32_WINNT
+#define _WIN32_WINNT WINVER
+#endif
+#endif /* _SQUID_MINGW_ */
+
+#if HAVE_FCNTL_H
+#include <fcntl.h>
+#endif /* HAVE_FCNTL_H */
+#if HAVE_STRING_H
+#include <string.h>
+#endif /* HAVE_FCNTL_H */
+#if HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif /* HAVE_SYS_STAT_H */
+
 #define ACL WindowsACL
 #if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
 #if _MSC_VER == 1400
@@ -47,17 +67,17 @@
    causing the fail of the build process. The following
    #define will disable that definition
  */
-#if defined(__GNUC__)
+#if defined(__GNUC__) && !NOMINMAX
 #define NOMINMAX
 #endif
 
-#if defined _FILE_OFFSET_BITS && _FILE_OFFSET_BITS == 64
+#if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS == 64
 # define __USE_FILE_OFFSET64	1
 #endif
 
 #if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
 
-#if defined __USE_FILE_OFFSET64
+#if defined(__USE_FILE_OFFSET64)
 typedef uint64_t ino_t;
 #else
 typedef unsigned long ino_t;
@@ -75,54 +95,54 @@ typedef unsigned long ino_t;
 
 #define THREADLOCAL __attribute__((section(".tls")))
 
-#endif
+#endif /* _MSC_VER */
 
-#if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
+/* ONLY Microsoft C Compiler needs these: */
+#if defined(_MSC_VER)
 #define alloca _alloca
-#endif
-#define chdir _chdir
-#define dup _dup
-#define dup2 _dup2
-#define fdopen _fdopen
-#if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
 #define fileno _fileno
 #define fstat _fstati64
+#define lseek _lseeki64
+#define memccpy _memccpy
+#define mkdir(p,F) _mkdir((p))
+#define mktemp _mktemp
+#define snprintf _snprintf
+#define stat _stati64
+#define strcasecmp _stricmp
+#define strdup _strdup
+#define strlwr _strlwr
+#define strncasecmp _strnicmp
+#define tempnam _tempnam
+#define vsnprintf _vsnprintf
 #endif
-#if !defined(_SQUID_MINGW_) // MinGW defines these properly
+
+/* CygWin and MinGW compilers need these. Microsoft C Compiler does not. */
+#if _SQUID_MINGW_ || _SQUID_CYGWIN_
+#define mkdir(p,F) mkdir((p))
+#endif
+
+/*  Microsoft C Compiler and CygWin need these. MinGW does not */
+#if defined(_MSC_VER) || _SQUID_CYGWIN_
 SQUIDCEXTERN int WIN32_ftruncate(int fd, off_t size);
 #define ftruncate WIN32_ftruncate
 SQUIDCEXTERN int WIN32_truncate(const char *pathname, off_t length);
 #define truncate WIN32_truncate
 #endif
+
+/* All three compiler systems need these: */
+#define chdir _chdir
+#define dup _dup
+#define dup2 _dup2
+#define fdopen _fdopen
 #define getcwd _getcwd
 #define getpid _getpid
-#define getrusage WIN32_getrusage
-#if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
-#define lseek _lseeki64
-#define memccpy _memccpy
-#define mkdir(p,F) _mkdir((p))
-#define mktemp _mktemp
-#endif
 #define pclose _pclose
-#define pipe WIN32_pipe
 #define popen _popen
 #define putenv _putenv
 #define setmode _setmode
 #define sleep(t) Sleep((t)*1000)
-#if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
-#define snprintf _snprintf
-#define stat _stati64
-#define strcasecmp _stricmp
-#define strdup _strdup
-#define strlwr _strlwr
-#define strncasecmp _strnicmp
-#define tempnam _tempnam
-#endif
 #define umask _umask
 #define unlink _unlink
-#if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
-#define vsnprintf _vsnprintf
-#endif
 
 #define O_RDONLY        _O_RDONLY
 #define O_WRONLY        _O_WRONLY
@@ -151,7 +171,8 @@ SQUIDCEXTERN int WIN32_truncate(const char *pathname, off_t length);
 #define S_IEXEC  _S_IEXEC
 
 #define S_IRWXO 007
-#if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
+
+#if defined(_MSC_VER)
 #define	S_ISDIR(m) (((m) & _S_IFDIR) == _S_IFDIR)
 #endif
 
@@ -163,7 +184,13 @@ SQUIDCEXTERN int WIN32_truncate(const char *pathname, off_t length);
 #define SIGUSR1 30	/* user defined signal 1 */
 #define SIGUSR2 31	/* user defined signal 2 */
 
-#if !_SQUID_CYGWIN_
+#if _SQUID_MINGW_
+typedef unsigned char boolean;
+typedef unsigned char u_char;
+typedef unsigned int u_int;
+#endif
+
+#if defined(_MSC_VER)
 typedef int uid_t;
 typedef int gid_t;
 #endif
@@ -212,25 +239,36 @@ struct timezone {
 
 #include <process.h>
 #include <errno.h>
-#if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
+#if HAVE_WINSOCK2_H
 #include <winsock2.h>
+#elif HAVE_WINSOCK_H
+#include <winsock.h>
 #endif
+
+#if !_SQUID_CYGWIN_
+#undef IN_ADDR
 #include <ws2tcpip.h>
+#endif
+
 #if (EAI_NODATA == EAI_NONAME)
 #undef EAI_NODATA
 #define EAI_NODATA WSANO_DATA
 #endif
-#if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
+
+#if defined(_MSC_VER)
 /* Hack to suppress compiler warnings on FD_SET() & FD_CLR() */
 #pragma warning (push)
 #pragma warning (disable:4142)
 #endif
+
 /* prevent inclusion of wingdi.h */
 #define NOGDI
 #include <ws2spi.h>
-#if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
+
+#if defined(_MSC_VER)
 #pragma warning (pop)
 #endif
+
 #include <io.h>
 
 typedef char * caddr_t;
@@ -277,6 +315,9 @@ typedef char * caddr_t;
 #ifndef ENETUNREACH
 #define ENETUNREACH WSAENETUNREACH
 #endif
+#ifndef ENOTSUP
+#define ENOTSUP WSAEOPNOTSUPP
+#endif
 
 #undef h_errno
 #define h_errno errno /* we'll set it ourselves */
@@ -335,27 +376,22 @@ typedef struct {
 #define _osfhnd(i)  ( _pioinfo(i)->osfhnd )
 #define FOPEN           0x01    /* file handle open */
 
-#if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
-
+#if defined(_MSC_VER)
 SQUIDCEXTERN _CRTIMP ioinfo * __pioinfo[];
 SQUIDCEXTERN int __cdecl _free_osfhnd(int);
+#endif
 
-#elif defined(__MINGW32__) /* MinGW environment */
-
+#if _SQUID_MINGW_
 __MINGW_IMPORT ioinfo * __pioinfo[];
 SQUIDCEXTERN int _free_osfhnd(int);
-
 #endif
 
 SQUIDCEXTERN THREADLOCAL int ws32_result;
 
-#define strerror(e) WIN32_strerror(e)
-#define HAVE_STRERROR 1
-
-#ifdef __cplusplus
+#if defined(__cplusplus)
 
-inline
-int close(int fd)
+inline int
+close(int fd)
 {
     char l_so_type[sizeof(int)];
     int l_so_type_siz = sizeof(l_so_type);
@@ -384,15 +420,15 @@ int close(int fd)
 #define _S_IWRITE 0x0080
 #endif
 
-inline
-int open(const char *filename, int oflag, int pmode = 0)
+inline int
+open(const char *filename, int oflag, int pmode = 0)
 {
     return _open(filename, oflag, pmode & (_S_IREAD | _S_IWRITE));
 }
 #endif
 
-inline
-int read(int fd, void * buf, size_t siz)
+inline int
+read(int fd, void * buf, size_t siz)
 {
     char l_so_type[sizeof(int)];
     int l_so_type_siz = sizeof(l_so_type);
@@ -404,8 +440,8 @@ int read(int fd, void * buf, size_t siz)
         return _read(fd, buf, (unsigned int)siz);
 }
 
-inline
-int write(int fd, const void * buf, size_t siz)
+inline int
+write(int fd, const void * buf, size_t siz)
 {
     char l_so_type[sizeof(int)];
     int l_so_type_siz = sizeof(l_so_type);
@@ -417,8 +453,8 @@ int write(int fd, const void * buf, size_t siz)
         return _write(fd, buf, siz);
 }
 
-inline
-char *index(const char *s, int c)
+inline char *
+index(const char *s, int c)
 {
     return (char *)strchr(s,c);
 }
@@ -428,30 +464,32 @@ namespace Squid
 {
 /** \endcond */
 
-inline
-int accept(int s, struct sockaddr * a, size_t * l)
+inline int
+accept(int s, struct sockaddr * a, socklen_t * l)
 {
     SOCKET result;
-    if ((result = ::accept(_get_osfhandle(s), a, (int *)l)) == INVALID_SOCKET) {
+    if ((result = ::accept(_get_osfhandle(s), a, l)) == INVALID_SOCKET) {
         if (WSAEMFILE == (errno = WSAGetLastError()))
             errno = EMFILE;
         return -1;
     } else
         return _open_osfhandle(result, 0);
 }
+#define accept(s,a,l) Squid::accept(s,a,l)
 
-inline
-int bind(int s, struct sockaddr * n, int l)
+inline int
+bind(int s, const struct sockaddr * n, socklen_t l)
 {
     if (::bind(_get_osfhandle(s),n,l) == SOCKET_ERROR) {
         errno = WSAGetLastError();
         return -1;
     } else
         return 0;
 }
+#define bind(s,n,l) Squid::bind(s,n,l)
 
-inline
-int connect(int s, const struct sockaddr * n, int l)
+inline int
+connect(int s, const struct sockaddr * n, socklen_t l)
 {
     if (::connect(_get_osfhandle(s),n,l) == SOCKET_ERROR) {
         if (WSAEMFILE == (errno = WSAGetLastError()))
@@ -460,18 +498,19 @@ int connect(int s, const struct sockaddr * n, int l)
     } else
         return 0;
 }
+#define connect(s,n,l) Squid::connect(s,n,l)
 
-inline
-struct hostent * gethostbyname (const char *n) {
+inline struct hostent *
+gethostbyname(const char *n) {
     HOSTENT FAR * result;
     if ((result = ::gethostbyname(n)) == NULL)
         errno = WSAGetLastError();
     return result;
 }
 #define gethostbyname(n) Squid::gethostbyname(n)
 
-inline
-SERVENT FAR* getservbyname (const char * n, const char * p)
+inline SERVENT FAR *
+getservbyname(const char * n, const char * p)
 {
     SERVENT FAR * result;
     if ((result = ::getservbyname(n, p)) == NULL)
@@ -480,28 +519,30 @@ SERVENT FAR* getservbyname (const char * n, const char * p)
 }
 #define getservbyname(n,p) Squid::getservbyname(n,p)
 
-inline
-HOSTENT FAR * gethostbyaddr(const char * a, int l, int t)
+inline HOSTENT FAR *
+gethostbyaddr(const void * a, size_t l, int t)
 {
     HOSTENT FAR * result;
-    if ((result = ::gethostbyaddr(a, l, t)) == NULL)
+    if ((result = ::gethostbyaddr((const char*)a, l, t)) == NULL)
         errno = WSAGetLastError();
     return result;
 }
 #define gethostbyaddr(a,l,t) Squid::gethostbyaddr(a,l,t)
 
-inline
-int getsockname(int s, struct sockaddr * n, size_t * l)
+inline int
+getsockname(int s, struct sockaddr * n, socklen_t * l)
 {
-    if ((::getsockname(_get_osfhandle(s), n, (int *)l)) == SOCKET_ERROR) {
+    int i=*l;
+    if (::getsockname(_get_osfhandle(s), n, &i) == SOCKET_ERROR) {
         errno = WSAGetLastError();
         return -1;
     } else
         return 0;
 }
+#define getsockname(s,a,l) Squid::getsockname(s,a,l)
 
-inline
-int gethostname(char * n, size_t l)
+inline int
+gethostname(char * n, size_t l)
 {
     if ((::gethostname(n, l)) == SOCKET_ERROR) {
         errno = WSAGetLastError();
@@ -511,8 +552,8 @@ int gethostname(char * n, size_t l)
 }
 #define gethostname(n,l) Squid::gethostname(n,l)
 
-inline
-int getsockopt(int s, int l, int o, void * v, int * n)
+inline int
+getsockopt(int s, int l, int o, void * v, socklen_t * n)
 {
     Sleep(1);
     if ((::getsockopt(_get_osfhandle(s), l, o,(char *) v, n)) == SOCKET_ERROR) {
@@ -521,30 +562,33 @@ int getsockopt(int s, int l, int o, void * v, int * n)
     } else
         return 0;
 }
+#define getsockopt(s,l,o,v,n) Squid::getsockopt(s,l,o,v,n)
 
 /* Simple ioctl() emulation */
-inline
-int ioctl(int s, int c, void * a)
+inline int
+ioctl(int s, int c, void * a)
 {
     if ((::ioctlsocket(_get_osfhandle(s), c, (u_long FAR *)a)) == SOCKET_ERROR) {
         errno = WSAGetLastError();
         return -1;
     } else
         return 0;
 }
+#define ioctl(s,c,a) Squid::ioctl(s,c,a)
 
-inline
-int ioctlsocket(int s, long c, u_long FAR * a)
+inline int
+ioctlsocket(int s, long c, u_long FAR * a)
 {
     if ((::ioctlsocket(_get_osfhandle(s), c, a)) == SOCKET_ERROR) {
         errno = WSAGetLastError();
         return -1;
     } else
         return 0;
 }
+#define ioctlsocket(s,c,a) Squid::ioctlsocket(s,c,a)
 
-inline
-int listen(int s, int b)
+inline int
+listen(int s, int b)
 {
     if (::listen(_get_osfhandle(s), b) == SOCKET_ERROR) {
         if (WSAEMFILE == (errno = WSAGetLastError()))
@@ -555,30 +599,33 @@ int listen(int s, int b)
 }
 #define listen(s,b) Squid::listen(s,b)
 
-inline
-int recv(int s, void * b, size_t l, int f)
+inline ssize_t
+recv(int s, void * b, size_t l, int f)
 {
-    int result;
+    ssize_t result;
     if ((result = ::recv(_get_osfhandle(s), (char *)b, l, f)) == SOCKET_ERROR) {
         errno = WSAGetLastError();
         return -1;
     } else
         return result;
 }
+#define recv(s,b,l,f) Squid::recv(s,b,l,f)
 
-inline
-int recvfrom(int s, void * b, size_t l, int f, struct sockaddr * fr, size_t * fl)
+inline ssize_t
+recvfrom(int s, void * b, size_t l, int f, struct sockaddr * fr, socklen_t * fl)
 {
-    int result;
-    if ((result = ::recvfrom(_get_osfhandle(s), (char *)b, l, f, fr, (int *)fl)) == SOCKET_ERROR) {
+    ssize_t result;
+    int ifl=*fl;
+    if ((result = ::recvfrom(_get_osfhandle(s), (char *)b, l, f, fr, &ifl)) == SOCKET_ERROR) {
         errno = WSAGetLastError();
         return -1;
     } else
         return result;
 }
+#define recvfrom(s,b,l,f,r,n) Squid::recvfrom(s,b,l,f,r,n)
 
-inline
-int select(int n, fd_set * r, fd_set * w, fd_set * e, struct timeval * t)
+inline int
+select(int n, fd_set * r, fd_set * w, fd_set * e, struct timeval * t)
 {
     int result;
     if ((result = ::select(n,r,w,e,t)) == SOCKET_ERROR) {
@@ -589,55 +636,58 @@ int select(int n, fd_set * r, fd_set * w, fd_set * e, struct timeval * t)
 }
 #define select(n,r,w,e,t) Squid::select(n,r,w,e,t)
 
-inline
-int send(int s, const void * b, size_t l, int f)
+inline ssize_t
+send(int s, const char * b, size_t l, int f)
 {
-    int result;
-    if ((result = ::send(_get_osfhandle(s), (char *)b, l, f)) == SOCKET_ERROR) {
+    ssize_t result;
+    if ((result = ::send(_get_osfhandle(s), b, l, f)) == SOCKET_ERROR) {
         errno = WSAGetLastError();
         return -1;
     } else
         return result;
 }
+#define send(s,b,l,f) Squid::send(s,b,l,f)
 
-inline
-int sendto(int s, const void * b, size_t l, int f, const struct sockaddr * t, int tl)
+inline ssize_t
+sendto(int s, const void * b, size_t l, int f, const struct sockaddr * t, socklen_t tl)
 {
-    int result;
+    ssize_t result;
     if ((result = ::sendto(_get_osfhandle(s), (char *)b, l, f, t, tl)) == SOCKET_ERROR) {
         errno = WSAGetLastError();
         return -1;
     } else
         return result;
 }
+#define sendto(a,b,l,f,t,n) Squid::sendto(a,b,l,f,t,n)
 
-inline
-int setsockopt(SOCKET s, int l, int o, const char * v, int n)
+inline int
+setsockopt(SOCKET s, int l, int o, const void * v, socklen_t n)
 {
     SOCKET socket;
 
     socket = ((s == INVALID_SOCKET) ? s : (SOCKET)_get_osfhandle((int)s));
 
-    if (::setsockopt(socket, l, o, v, n) == SOCKET_ERROR) {
+    if (::setsockopt(socket, l, o, (const char *)v, n) == SOCKET_ERROR) {
         errno = WSAGetLastError();
         return -1;
     } else
         return 0;
 }
 #define setsockopt(s,l,o,v,n) Squid::setsockopt(s,l,o,v,n)
 
-inline
-int shutdown(int s, int h)
+inline int
+shutdown(int s, int h)
 {
     if (::shutdown(_get_osfhandle(s),h) == SOCKET_ERROR) {
         errno = WSAGetLastError();
         return -1;
     } else
         return 0;
 }
+#define shutdown(s,h) Squid::shutdown(s,h)
 
-inline
-int socket(int f, int t, int p)
+inline int
+socket(int f, int t, int p)
 {
     SOCKET result;
     if ((result = ::socket(f, t, p)) == INVALID_SOCKET) {
@@ -649,8 +699,15 @@ int socket(int f, int t, int p)
 }
 #define socket(f,t,p) Squid::socket(f,t,p)
 
-inline
-int WSAAsyncSelect(int s, HWND h, unsigned int w, long e)
+inline int
+pipe(int pipefd[2])
+{
+    return _pipe(pipefd,4096,_O_BINARY);
+}
+#define pipe(a) Squid::pipe(a)
+
+inline int
+WSAAsyncSelect(int s, HWND h, unsigned int w, long e)
 {
     if (::WSAAsyncSelect(_get_osfhandle(s), h, w, e) == SOCKET_ERROR) {
         errno = WSAGetLastError();
@@ -660,8 +717,8 @@ int WSAAsyncSelect(int s, HWND h, unsigned int w, long e)
 }
 
 #undef WSADuplicateSocket
-inline
-int WSADuplicateSocket(int s, DWORD n, LPWSAPROTOCOL_INFO l)
+inline int
+WSADuplicateSocket(int s, DWORD n, LPWSAPROTOCOL_INFO l)
 {
 #ifdef UNICODE
     if (::WSADuplicateSocketW(_get_osfhandle(s), n, l) == SOCKET_ERROR) {
@@ -675,8 +732,8 @@ int WSADuplicateSocket(int s, DWORD n, LPWSAPROTOCOL_INFO l)
 }
 
 #undef WSASocket
-inline
-int WSASocket(int a, int t, int p, LPWSAPROTOCOL_INFO i, GROUP g, DWORD f)
+inline int
+WSASocket(int a, int t, int p, LPWSAPROTOCOL_INFO i, GROUP g, DWORD f)
 {
     SOCKET result;
 #ifdef UNICODE
@@ -748,11 +805,68 @@ struct rusage {
 
 #undef ACL
 
-#if !defined(getpagesize)
-/* Windows may lack getpagesize() prototype */
-SQUIDCEXTERN size_t getpagesize(void);
+SQUIDCEXTERN int chroot(const char *dirname);
+SQUIDCEXTERN int kill(pid_t, int);
+SQUIDCEXTERN int statfs(const char *, struct statfs *);
+SQUIDCEXTERN struct passwd * getpwnam(char *unused);
+SQUIDCEXTERN struct group * getgrnam(char *unused);
+
+static inline uid_t
+geteuid(void)
+{
+    return 100;
+}
+static inline int
+seteuid (uid_t euid)
+{
+    return 0;
+}
+static inline uid_t
+getuid(void)
+{
+    return 100;
+}
+static inline int
+setuid (uid_t uid)
+{
+    return 0;
+}
+static inline gid_t
+getegid(void)
+{
+    return 100;
+}
+static inline int
+setegid (gid_t egid)
+{
+    return 0;
+}
+static inline int
+getgid(void)
+{
+    return 100;
+}
+static inline int
+setgid (gid_t gid)
+{
+    return 0;
+}
+
+/* for some reason autoconf misdetects getpagesize.. */
+#if HAVE_GETPAGESIZE && _SQUID_MINGW_
+#undef HAVE_GETPAGESIZE
 #endif
 
+#if !HAVE_GETPAGESIZE
+/* And now we define a compatibility layer */
+size_t getpagesize();
+#define HAVE_GETPAGESIZE 2
+#endif
+
+SQUIDCEXTERN void WIN32_ExceptionHandlerInit(void);
+SQUIDCEXTERN int Win32__WSAFDIsSet(int fd, fd_set* set);
+SQUIDCEXTERN DWORD WIN32_IpAddrChangeMonitorInit();
+
 /* gcc doesn't recognize the Windows native 64 bit formatting tags causing
  * the compile fail, so we must disable the check on native Windows.
  */
@@ -762,5 +876,61 @@ SQUIDCEXTERN size_t getpagesize(void);
 #define PRINTF_FORMAT_ARG3
 #endif
 
+/* XXX: the logic around this is a bit warped:
+ *   we #define ACL unconditionally at the top of this file,
+ *   then #undef ACL unconditionally hafway down,
+ *   then here re-define ACL to the same value as at the top,
+ *   then include windows.h and #undef ACL again.
+ */
+#ifndef ACL
+#define ACL WindowsACL
+#define _MSWIN_ACL_WAS_NOT_DEFINED 1
+#endif
+#include <windows.h>
+#if _MSWIN_ACL_WAS_NOT_DEFINED
+#undef ACL
+#undef _MSWIN_ACL_WAS_NOT_DEFINED
+#endif
+
+#if !HAVE_SYSLOG
+/* syslog compatibility layer derives from git */
+#define LOG_PID     0x01
+#define LOG_EMERG   0
+#define LOG_ALERT   1
+#define LOG_CRIT    2
+#define LOG_ERR     3
+#define LOG_WARNING 4
+#define LOG_NOTICE  5
+#define LOG_INFO    6
+#define LOG_DEBUG   7
+#define LOG_DAEMON  (3<<3)
+
+void openlog(const char *ident, int logopt, int facility);
+void syslog(int priority, const char *fmt, ...);
+#endif
+
+#if _SQUID_MINGW_
+/* MinGW missing bits from sys/wait.h */
+/* A status looks like:
+ *  <2 bytes info> <2 bytes code>
+ *
+ *  <code> == 0, child has exited, info is the exit value
+ *  <code> == 1..7e, child has exited, info is the signal number.
+ *  <code> == 7f, child has stopped, info was the signal number.
+ *  <code> == 80, there was a core dump.
+ */
+#define WIFEXITED(w)    (((w) & 0xff) == 0)
+#define WIFSIGNALED(w)  (((w) & 0x7f) > 0 && (((w) & 0x7f) < 0x7f))
+#define WIFSTOPPED(w)   (((w) & 0xff) == 0x7f)
+#define WEXITSTATUS(w)  (((w) >> 8) & 0xff)
+#define WTERMSIG(w) ((w) & 0x7f)
+#define WSTOPSIG    WEXITSTATUS
+#endif
+
+/* prototypes */
+void WIN32_maperror(unsigned long WIN32_oserrno);
+
+#include "compat/strsep.h"
+
 #endif /* _SQUID_WINDOWS_ */
-#endif /* SQUID_OS_MSWIN_H */
+#endif /* SQUID_OS_MSWINDOWS_H */
@@ -73,10 +73,6 @@
 #define _SQUID_WINDOWS_ 1
 
 #elif defined(WIN32) || defined(WINNT) || defined(__WIN32__) || defined(__WIN32)
-/* We are using _SQUID_MSWIN_ define in cf.data.pre, so
-   it must be defined to 1 to avoid the build failure of cfgen.
- */
-#define _SQUID_MSWIN_ 1
 #define _SQUID_WINDOWS_ 1
 
 #elif defined(__APPLE__)
@@ -1,6 +1,3 @@
-/*
- * $Id$
- */
 #ifndef SQUID_COMPAT_SHM_H
 #define SQUID_COMPAT_SHM_H
 
@@ -12,8 +12,6 @@
  * 			- added squid_ prefix for uniqueness
  * 			  so we can use it where OS copy is broken.
  *
- * Squid VCS $Id$
- *
  *  Original License and code follows.
  */
 
@@ -91,7 +91,7 @@
  * "%lx" instead of "%llx"
  */
 #ifndef PRId64
-#if _SQUID_MSWIN_		/* Windows native port using MSVCRT */
+#if _SQUID_WINDOWS_
 #define PRId64 "I64d"
 #elif SIZEOF_INT64_T > SIZEOF_LONG
 #define PRId64 "lld"
@@ -101,7 +101,7 @@
 #endif
 
 #ifndef PRIu64
-#if _SQUID_MSWIN_		/* Windows native port using MSVCRT */
+#if _SQUID_WINDOWS_
 #define PRIu64 "I64u"
 #elif SIZEOF_INT64_T > SIZEOF_LONG
 #define PRIu64 "llu"
@@ -111,7 +111,7 @@
 #endif
 
 #ifndef PRIX64
-#if _SQUID_MSWIN_		/* Windows native port using MSVCRT */
+#if _SQUID_WINDOWS_
 #define PRIX64 "I64X"
 #elif SIZEOF_INT64_T > SIZEOF_LONG
 #define PRIX64 "llX"
@@ -23,8 +23,6 @@
  * 			- xtables_strtoui renamed to xstrtoui
  * 			- xtables_strtoul renamed to xstrtoul
  *
- * Squid VCS $Id$
- *
  *  Original License and code follows.
  */
 
@@ -1,8 +1,3 @@
-dnl
-dnl  $Id$
-dnl
-dnl
-dnl
 AC_INIT([Squid Web Proxy],[3.HEAD-BZR],[http://www.squid-cache.org/bugs/],[squid])
 AC_PREREQ(2.61)
 AC_CONFIG_HEADERS([include/autoconf.h])
@@ -109,6 +104,14 @@ fi
 AR_R="$AR r"
 AC_SUBST(AR_R)
 
+# pre-define DEFAULT_PREFIX, some modules need it.
+if test "${prefix}" = "NONE" ; then
+  squid_prefix=$ac_default_prefix
+else
+  squid_prefix=$prefix
+fi
+AC_DEFINE_UNQUOTED(DEFAULT_PREFIX,[$squid_prefix],[The install prefix])
+
 AC_ARG_ENABLE(strict-error-checking,
   AS_HELP_STRING([--disable-strict-error-checking],[By default squid is compiled
                  with all possible static compiler error-checks enabled.
@@ -384,8 +387,8 @@ export enable_inline
 dnl
 dnl Check for atomic operations support in the compiler
 dnl
-AC_MSG_CHECKING([for atomic operations support])
-AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+AC_MSG_CHECKING([for GNU atomic operations support])
+AC_RUN_IFELSE([AC_LANG_PROGRAM([[
     int n = 0;
 ]],[[
     __sync_add_and_fetch(&n, 10); // n becomes 10
@@ -396,8 +399,7 @@ AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
     return (n == 200) ? 0 : -1;
 ]])],
 [
-    AC_DEFINE(HAVE_ATOMIC_OPS,1,
-        [Define to 1 if you have __sync_add_and_fetch() and such])
+    AC_DEFINE(HAVE_ATOMIC_OPS,1,[Define to 1 if you have __sync_add_and_fetch() and such])
     AC_MSG_RESULT(yes)
 ],[
     AC_MSG_RESULT(no)
@@ -689,10 +691,16 @@ for module in $squid_disk_module_candidates none; do
       ;;
 
     Mmapped)
-      AC_MSG_NOTICE([Enabling Mmapped DiskIO module])
-      DISK_LIBS="$DISK_LIBS libMmapped.a"
-      DISK_MODULES="$DISK_MODULES Mmapped"
-      DISK_LINKOBJS="$DISK_LINKOBJS DiskIO/Mmapped/MmappedDiskIOModule.o"
+      dnl TODO: use availability of sys/mman.h and/or mmap to define
+      dnl  OR support windows mmap functions
+      if test "x$squid_host_os" = "xmingw" ; then
+        AC_MSG_NOTICE([Mmapped DiskIO is not available on Mingw])
+      else
+        AC_MSG_NOTICE([Enabling Mmapped DiskIO module])
+        DISK_LIBS="$DISK_LIBS libMmapped.a"
+        DISK_MODULES="$DISK_MODULES Mmapped"
+        DISK_LINKOBJS="$DISK_LINKOBJS DiskIO/Mmapped/MmappedDiskIOModule.o"
+      fi
       ;;
 
     IpcIo)
@@ -993,19 +1001,23 @@ dnl Necessary if the first PKG_CHECK_MODULES call is conditional
 PKG_PROG_PKG_CONFIG
 
 dnl Perform configuration consistency checks for eCAP
-if test "x$squid_opt_use_ecap" = "xyes";
+if test "x$squid_opt_use_ecap" != "xno";
 then
-    dnl eCAP support requires loadable modules, which are enabled by default
-    if test "x$enable_loadable_modules" != "xyes"
-    then
-        AC_MSG_ERROR([eCAP support requires loadable modules. Please do not use --disable-loadable-modules with --enable-ecap.]);
-    fi
+  dnl eCAP support requires loadable modules, which are enabled by default
+  if test "x$enable_loadable_modules" != "xyes"
+  then
+    AC_MSG_ERROR([eCAP support requires loadable modules. Please do not use --disable-loadable-modules with --enable-ecap.])
+  fi
 
+  if test -n "$PKG_CONFIG"; then
     dnl eCAP support requires libecap.
     dnl This Squid supports libecap v0.2.x.
     dnl Use EXT_ prefix to distinguish external libecap (that we check for
     dnl here) from our own convenience ecap library in Makefiles.
-    PKG_CHECK_MODULES(EXT_LIBECAP, [libecap > 0.2 libecap < 0.3])
+    PKG_CHECK_MODULES([EXT_LIBECAP],[libecap >= 0.2.0 libecap < 0.3])
+  else
+    AC_MSG_NOTICE([eCAP support requires pkg-config to verify the correct library version. Trouble may follow.])
+  fi
 fi
 
 AM_CONDITIONAL(USE_ECAP, test "x$squid_opt_use_ecap" = "xyes")
@@ -1131,9 +1143,14 @@ if test "x${enable_eui:=yes}" = "xyes" ; then
   esac
   #Iphlpapi.h check delayed after winsock2.h
   AC_CHECK_HEADERS( \
-    net/if_dl.h \
+    windows.h \
     sys/sockio.h \
-    sys/param.h
+    sys/param.h,
+  [], [], [[
+#if HAVE_WINDOWS_H
+include <windows.h>
+#endif
+]]
   )
   AC_CHECK_HEADERS( \
     net/if_arp.h \
@@ -1143,9 +1160,12 @@ if test "x${enable_eui:=yes}" = "xyes" ; then
 #include <sys/socket.h>
 ]])
 
-  # openbsd requires sys/param.h to be included before sysctl.h
-  AC_CHECK_HEADERS(sys/sysctl.h, [], [],
-  [[#if HAVE_SYS_PARAM_H
+  # OpenBSD, FreeBSD and NetBSD requires sys/param.h to be included before sysctl.h and net/if_dl.h
+  AC_CHECK_HEADERS( \
+    net/if_dl.h \
+    sys/sysctl.h,
+  [], [], [[
+#if HAVE_SYS_PARAM_H
 #include <sys/param.h>
 #endif
   ]])
@@ -1700,7 +1720,7 @@ if test "x$enable_auth_basic" != "xno" ; then
     for helper in $enable_auth_basic
     do
     dir="$srcdir/helpers/basic_auth/$helper"
-    if test -f "$dir/config.test" && sh "$dir/config.test" "$@"; then
+    if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
       BASIC_AUTH_HELPERS="$BASIC_AUTH_HELPERS $helper"
       # special case
       if test "x$helper" = "xSASL" ; then
@@ -1746,7 +1766,7 @@ if test "x$enable_auth_ntlm" != "xno" ; then
     AC_DEFINE([HAVE_AUTH_MODULE_NTLM],1,[NTLM auth module is built])
     for helper in $enable_auth_ntlm ; do
         dir="$srcdir/helpers/ntlm_auth/$helper"
-        if test -f "$dir/config.test" && sh "$dir/config.test" "$@"; then
+        if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
             NTLM_AUTH_HELPERS="$NTLM_AUTH_HELPERS $helper"
         elif test -d "$srcdir/helpers/ntlm_auth/$helper" ; then
             AC_MSG_NOTICE([NTLM auth helper $helper ... found but cannot be built])
@@ -1791,7 +1811,7 @@ if test "x$enable_auth_negotiate" != "xno" ; then
     AC_DEFINE([HAVE_AUTH_MODULE_NEGOTIATE],1,[Negotiate auth module is built])
     for helper in $enable_auth_negotiate ; do
         dir="$srcdir/helpers/negotiate_auth/$helper"
-        if test -f "$dir/config.test" && sh "$dir/config.test" "$@"; then
+        if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
             NEGOTIATE_AUTH_HELPERS="$NEGOTIATE_AUTH_HELPERS $helper"
         elif test -d "$srcdir/helpers/negotiate_auth/$helper" ; then
             AC_MSG_NOTICE([Negotiate auth helper $helper ... found but cannot be built])
@@ -1834,7 +1854,7 @@ if test "x$enable_auth_digest" != "xno" ; then
     AC_DEFINE([HAVE_AUTH_MODULE_DIGEST],1,[Digest auth module is built])
     for helper in $enable_auth_digest ; do
         dir="$srcdir/helpers/digest_auth/$helper"
-        if test -f "$dir/config.test" && sh "$dir/config.test" "$@"; then
+        if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
             DIGEST_AUTH_HELPERS="$DIGEST_AUTH_HELPERS $helper"
         elif test -d "$srcdir/helpers/digest_auth/$helper" ; then
             AC_MSG_NOTICE([Digest auth helper $helper ... found but cannot be built])
@@ -1875,7 +1895,7 @@ if test "x$squid_opt_logdaemon_helpers" = "xauto" ; then
 fi
 for helper in $squid_opt_logdaemon_helpers ; do
   dir="$srcdir/helpers/log_daemon/$helper"
-  if test -f "$dir/config.test" && sh "$dir/config.test" "$@"; then
+  if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
     LOG_DAEMON_HELPERS="$LOG_DAEMON_HELPERS $helper"
   elif test -d "$srcdir/helpers/log_daemon/$helper" ; then
     AC_MSG_NOTICE([Log daemon helper $helper ... found but cannot be built])
@@ -2041,7 +2061,7 @@ enable_external_acl_helpers="`echo $enable_external_acl_helpers| sed -e 's/,/ /g
 if test "x$enable_external_acl_helpers" != "xno" ; then
   for helper in $enable_external_acl_helpers ; do
     dir="$srcdir/helpers/external_acl/$helper"
-    if test -f "$dir/config.test" && sh "$dir/config.test" "$@"; then
+    if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
       EXTERNAL_ACL_HELPERS="$EXTERNAL_ACL_HELPERS $helper"
       # special case
       if test "x$helper" = "xkerberos_ldap_group" ; then
@@ -2077,7 +2097,7 @@ URL_REWRITE_HELPERS=""
 if test "x$enable_url_rewrite_helpers" != "xno" ; then
   for helper in $enable_url_rewrite_helpers; do
     dir="$srcdir/helpers/url_rewrite/$helper"
-    if test -f "$dir/config.test" && sh "$dir/config.test" "$@"; then
+    if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
       URL_REWRITE_HELPERS="$URL_REWRITE_HELPERS $helper"
     elif test -d "$srcdir/helpers/ntlm_auth/$helper" ; then
       AC_MSG_NOTICE([URL rewrite helper $helper ... found but cannot be built])
@@ -2368,13 +2388,15 @@ AC_CHECK_HEADERS( \
   sys/endian.h \
   sys/file.h \
   sys/ioctl.h \
+  sys/ipc.cc \
   sys/param.h \
   sys/prctl.h \
   sys/md5.h \
   sys/mman.h \
   sys/msg.h \
   sys/resource.h \
   sys/select.h \
+  sys/shm.h \
   sys/socket.h \
   sys/stat.h \
   sys/statvfs.h \
@@ -2608,7 +2630,13 @@ AC_SEARCH_LIBS([yp_match], [nsl nss_nis nss_nisplus])
 dnl Check for Winsock only on MinGW, on Cygwin we must use emulated BSD socket API
 if test "x$squid_host_os" = "xmingw" ; then
   SQUID_CHECK_WINSOCK_LIB
-  AC_CHECK_HEADERS(Iphlpapi.h,,,[
+  AC_CHECK_HEADERS( \
+    windows.h \
+    ws2tcpip.h \
+    Iphlpapi.h ,,,[
+#if HAVE_WINDOWS_H
+#include <windows.h>
+#endif
 #if HAVE_WINSOCK2_H
 #include <winsock2.h>
 #endif])
@@ -3429,6 +3457,7 @@ SQUID_DETECT_UDP_RECV_BUFSIZE
 SQUID_DETECT_TCP_SND_BUFSIZE
 SQUID_DETECT_TCP_RECV_BUFSIZE
 
+SQUID_CHECK_RECV_ARG_TYPE
 SQUID_CHECK_NEED_SYS_ERRLIST
 SQUID_CHECK_MAXPATHLEN
 
@@ -3536,6 +3565,7 @@ AC_CONFIG_FILES([\
 	src/esi/Makefile \
 	src/eui/Makefile \
 	src/format/Makefile \
+	src/http/Makefile \
 	src/icmp/Makefile \
 	src/ident/Makefile \
 	src/ip/Makefile \
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.1.20 release notes</title>
+<title>Squid 3.1.21 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.1.20
+The Squid Team are pleased to announce the release of Squid-3.1.21
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.1/"> or the <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
 
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.2.1 release notes</title>
+<title>Squid 3.2.3 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.2.1 for testing.
+The Squid Team are pleased to announce the release of Squid-3.2.3 for testing.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.2/"> or the <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
 
@@ -341,7 +341,8 @@ Most user-facing changes are reflected in squid.conf (see below).
   direct filesystem logging (stdio, daemon) to network logging (syslog, UDP and TCP). The daemon logging
   interface allows for a custom helper to be written to process logs in real-time.
 
-<p>Upgrading: the <em>access_log</em> was previously logged via what is now called the <em>stdio</em> module.
+<p>Upgrading: the <em>access_log</em> and <em>cache_store_log</em> were previously logged via what is
+  now called the <em>stdio</em> module.
   This is still supported and used by default if no module is named. For best performance particularly in SMP
   environments we recommend the <em>daemon</em> be used. The provided <em>log_file_daemon</em> helper
   performs the traditional logging to local filesystem.
@@ -353,8 +354,8 @@ Most user-facing changes are reflected in squid.conf (see below).
   logging a single cache.log at relatively high debug levels on a high-traffic system. Or one which is
   required to store a long period of access.log and needs to conserve disk space.
 
-<p>The referer_log and useragent_log directives have been converted to built-in log formats.
-  These logs are now created using an access_log line with the format "referrer" or "useragent".
+<p>The <em>referer_log</em> and <em>useragent_log</em> directives have been converted to built-in log formats.
+  These logs are now created using an <em>access_log</em> line with the format "referrer" or "useragent".
   They also now log all client requests, if there was no Referer or User-Agent header a dash (-) is logged.
 
 <p>Known Issue: The TCP logging module does not recover from broken connections well.
@@ -587,6 +588,7 @@ This section gives a thorough account of those changes in three categories:
 	<p>New type <em>random</em>. Pseudo-randomly match requests based on a configured probability.
 	<p>Renamed <em>myip</em> to <em>localip</em>. It matches the IP which the client connected to.
 	<p>Renamed <em>myport</em> to <em>localport</em>. It matches the port which the client connected to.
+	<p>Ported <em>urllogin</em> option from Squid 2.7, to match a regex pattern on the URL login field (if any).
 	<p>The <em>localip</em>/<em>localport</em> differ from earlier releases where they matched a mix of
 	   of an invalid IP and port 0, the client destination IP/port or the Squid listening IP/port.
 	   This definition is now consistent across all modes of traffic received by Squid.
@@ -610,6 +612,10 @@ This section gives a thorough account of those changes in three categories:
 	<p><em>htcp-*</em> options collapsed into <em>htcp=</em> taking an optional comma-separated list of flags.
 	   The old form is deprecated but still accepted.
 
+	<tag>cache_store_log</tag>
+	<p>Now uses logging modules. Example: stdio:/file/path
+	   see <em>access_log</em> for a list of supported modules and their parameters.
+
 	<tag>clientside_mark</tag>
 	<p>New configuration parameter <em>clientside_mark</em>
 	<p>Allows packets leaving Squid on the client side to be marked with a Netfilter mark value in the same way as the existing clientside_tos feature.
@@ -686,6 +692,8 @@ This section gives a thorough account of those changes in three categories:
 	<tag>refresh_pattern</tag>
 	<p>New option <em>max-stale=</em> to provide a maximum staleness factor. Squid won't
 	   serve objects more stale than this even if it failed to validate the object.
+	<p>Removed option <em>ignore-no-cache</em>. Its commonly desired behaviour is obsoleted
+	   by correct HTTP/1.1 Cache-Control:no-cache handling.
 
 	<tag>reply_header_access</tag>
 	<p>Added support for custom response header names.</p>
@@ -1023,10 +1031,6 @@ This section gives an account of those changes in three categories:
 <sect1>Missing squid.conf options available in Squid-2.7
 <p>
 <descrip>
-	<tag>acl</tag>
-	<p><em>urllogin</em> option not yet ported from 2.6
-	<p><em>urlgroup</em> option not yet ported from 2.6
-
 	<tag>broken_vary_encoding</tag>
 	<p>Not yet ported from 2.6
 
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.3.0.0 release notes</title>
+<title>Squid 3.3.0.1 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.3.0.0 for testing.
+The Squid Team are pleased to announce the release of Squid-3.3.0.1 for testing.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.3/"> or the <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
 
@@ -34,13 +34,129 @@ The 3.3 change history can be <url url="http://www.squid-cache.org/Versions/v3/3
 
 <p>The most important of these new features are:
 <itemize>
-	<item>
+	<item>SQL Database logging helper
+	<item>Time-Quota session helper
+	<item>SSL-Bump Server First
+	<item>Server Certificate Mimic
+	<item>Custom HTTP request headers
 </itemize>
 
 Most user-facing changes are reflected in squid.conf (see below).
 
-<sect1>
-<p>
+<sect1>SQL Database logging helper
+<p><em>log_db_daemon</em> - Database logging daemon for Squid
+
+<p>This program writes Squid access.log entries to an SQL database.
+   Written in Perl it can utilize any database supported by the Perl
+   database abstraction layer.
+
+<p>NOTE: Presently it only accepts the Squid native log format.
+
+
+<sect1>Time-Quota session helper
+<p><em>ext_time_quota_acl</em> - Time quota external ACL helper.
+
+<p>Allows an administrator to define time budgets (quota) for the
+   users of Squid to limit the time using Squid.
+
+<p>This is useful for corporate lunch time allocations, wifi portal
+   pay-per-minute installations or for parental control of children.
+
+<p>The administrator can define a time budget (e.g. 1 hour per day)
+   which is enforced through this helper using session estimations
+   of their browsing time. A 'pause' threshold is given in seconds
+   and defines the period between two requests to be treated as part
+   of the same session. Pauses shorter than this value will be
+   counted against the quota, longer ones ignored.
+
+
+<sect1>SSL-Bump Server First
+<p>Details at <url url="http://wiki.squid-cache.org/Features/BumpSslServerFirst">.
+
+<p>When an intercepted connection is received, Squid first connects
+   to the server using SSL and receives the server certificate.
+   Squid then uses the host name inside the true server certificate
+   to generate a fake one and impersonates the server while still
+   using the already established secure connection to the server.
+
+<p>Bumping server first is essentially required for handling
+   intercepted HTTPS connections but the same scheme should be used
+   for most HTTP CONNECT requests because it offers a few advantages
+   compared to the old bump-client-first approach:
+
+<itemize>
+<item>When Squid knows valid server certificate details, it can
+   generate its fake server certificate with those details.
+   With the bump-client-first scheme, all those details are lost.
+   In general, browsers do not care about those details but there
+   may be HTTP clients (or even human users) that require or could
+   benefit from knowing them.
+
+<item>When a server sends a bad certificate, Squid may be able to
+   replicate that brokenness in its own fake certificate, giving
+   the HTTP client control whether to ignore the problem or
+   terminate the transaction. With bump-client-furst, it is
+   difficult to support similar dynamic, user-directed opt out; 
+   Squid itself has to decide what to do when the server
+   certificate cannot be validated.
+
+<item>When a server asks for a client certificate, Squid may be
+   able to ask the client and then forward the client certificate
+   to the server. Such client certificate handling may not be
+   possible with the bump-client-first scheme because it would
+   have to be done after the SSL handshake.
+
+<item>Some clients (e.g., Rekonq browser v0.7.x) do not send host
+   names in CONNECT requests. Such clients require bump-server-first
+   even in forward proxying mode. Unfortunately, there are other
+   problems with fully supporting such clients (i.e., Squid does
+   not know whether the IP address in the CONNECT request is what
+   the user have typed into the address bar) so not all features
+   will work well for them until more specialized detection code
+   is added.
+</itemize>
+
+<sect1>Server Certificate Mimic
+<p>Details at <url url="http://wiki.squid-cache.org/Features/MimicSslServerCert">.
+
+<p>One of the SslBump features serious drawbacks is the loss of
+   information embedded in SSL server certificate.
+   This certificate mimic feature passes original SSL server
+   certificate information to the user. Allowing the user to
+   make an informed decision on whether to trust the server
+   certificate.
+
+
+<sect1>Custom HTTP request headers
+<p>The <em>request_header_add</em> option is added to insert
+   HTTP header fields to outgoing HTTP requests (i.e.,
+   request headers sent by Squid to the next HTTP hop such as a
+   cache peer or an origin server). The option has no effect on
+   cache hit traffic or requests serviced by Squid and ICAP.
+
+<p>WARNING: If a standard HTTP header name is used, Squid does not check whether
+   the new header conflicts with any existing headers or violates
+   HTTP rules. If the request to be modified already contains a
+   field with the same name, the old field is preserved but the
+   header field values are not merged.
+
+<p>Field-value set can be either a token or a quoted string. If quoted
+   string format is used, then the surrounding quotes are removed
+   while escape sequences and %macros are processed.
+
+<p>In theory, all of the <em>logformat</em> codes can be used as %macros.
+   However, unlike logging (which happens at the very end of
+   transaction lifetime), the transaction may not yet have enough
+   information to expand a macro when the new header value is needed.
+   And some information may already be available to Squid but not yet
+   committed where the macro expansion code can access it (please report
+   such instances!). The macro will be expanded into a single dash
+   ('-') in such cases. Not all macros have been tested.
+
+<p>One or more Squid ACLs may be specified to restrict header
+   injection to matching requests. As always in squid.conf, all
+   ACLs in an option ACL list must be satisfied for the insertion
+   to happen. The <em>request_header_add</em> option supports fast ACLs only.
 
 
 <sect>Changes to squid.conf since Squid-3.2
@@ -59,19 +175,52 @@ This section gives a thorough account of those changes in three categories:
 <sect1>New tags<label id="newtags">
 <p>
 <descrip>
+	<tag>request_header_add</tag>
+	<p>New directive to add custom headers on HTTP traffic sent to upstream servers.
+
+	<tag>sslproxy_cert_sign</tag>
+	<p>New option to determine how the client certificate sent to upstream servers is signed.
+
+	<tag>sslproxy_cert_adapt</tag>
+	<p>New option to adapt certain properties of outgoing SSL certificates generated for use when bumping SSL to an upstream server.
+
 
 </descrip>
 
 <sect1>Changes to existing tags<label id="modifiedtags">
 <p>
 <descrip>
+	<tag>acl</tag>
+	<p><em>myport</em> and <em>myip</em>ACL types replaced with <em>localport</em> and <em>localip</em> respecitively.
+	   To reflect that it matches the TCP connection details and not the squid.conf port.
+	   This matters when dealing with interecepted traffic, where the Squid receiving port differs from the TCP connection IP:port.
+	   Always use <em>myportname</em> type to match the squid.conf port details.
+	<p>New default built-in ACLs for testing SSL certificate properties.
+	<p><em>ssl::certHasExpired</em>,
+	   <em>ssl::certNotYetValid</em>,
+	   <em>ssl::certDomainMismatch</em>,
+	   <em>ssl::certUntrusted</em>,
+	   <em>ssl::certSelfSigned</em>.
 
-</descrip>
+	<tag>logformat</tag>
+	<p>New token <em>%ssl::bump_mode</em> to log the SSL-bump mode type performed on a request.
+	  Logs values of: <em>-</em>, <em>none</em>, <em>client-first</em>, or <em>server-first</em>.
+	<p>New token of <em>%ssl::&gt;cert_subject</em> to log the Subject field of a SSL certficate received from the client.
+	<p>New token of <em>%ssl::&gt;cert_issuer</em> to log the Issuer field of a SSL certficate received from the client.
+
+	<tag>ssl_bump</tag>
+	<p>New action types <em>none</em>, <em>client-first</em>, <em>server-first</em>. The default is <em>none</em>.
+	<p>Use of <em>allow</em>/<em>deny</em> is now deprecated and they should be removed as soon as possible.
+	   To retain the exact same behaviour between 3.3 and older releases replace <em>deny</em> with <em>none</em>,
+	   and <em>allow</em> with <em>client-first</em>. However an upgrade to <em>server-first</em> is the recommended.
+	<p><em>NOTE</em>: Mixing of allow/deny with the new action types is prohibited and will cause Squid to exit with a FATAL error.
 
+</descrip>
 
 <sect1>Removed tags<label id="removedtags">
 <p>
 <descrip>
+	<p><em>There are no removed squid.conf tags in Squid-3.3.</em>
 
 </descrip>
 
@@ -92,12 +241,14 @@ This section gives an account of those changes in three categories:
 <sect1>New options<label id="newoptions">
 <p>
 <descrip>
+	<p><em>There are no new ./configure options in Squid-3.3.</em>
 
 </descrip>
 
 <sect1>Changes to existing options<label id="modifiedoptions">
 <p>
 <descrip>
+	<p><em>There are no changed ./configure options in Squid-3.3.</em>
 
 </descrip>
 </p>
@@ -106,129 +257,7 @@ This section gives an account of those changes in three categories:
 <p>
 <descrip>
 	<tag>--enable-ntlm-fail-open</tag>
-	<p>Removed. This has not been supported by Squid for several versions.
-
-</descrip>
-
-
-<sect>Options Removed since Squid-2
-
-<p>Some squid.conf and ./configure options which were available in Squid-2.6 and Squid-2.7 are made obsolete in Squid-3.3.
-
-<sect1>Removed squid.conf options since Squid-2.7
-<p>
-<descrip>
-	<tag>auth_param</tag>
-	<p><em>blankpassword</em> option for basic scheme removed.
-
-	<tag>cache_peer</tag>
-	<p><em>http11</em> Obsolete.
-
-	<tag>external_acl_type</tag>
-	<p>Format tag <em>%{Header}</em> replaced by <em>%>{Header}</em>
-	<p>Format tag <em>%{Header:member}</em> replaced by <em>%>{Header:member}</em>
-
-	<tag>header_access</tag>
-	<p>Replaced by <em>request_header_access</em> and <em>reply_header_access</em>
-
-	<tag>http_port</tag>
-	<p><em>no-connection-auth</em> replaced by <em>connection-auth=[on|off]</em>. Default is ON.
-	<p><em>transparent</em> option replaced by <em>intercept</em>
-	<p><em>http11</em> obsolete.
-
-	<tag>http_access2</tag>
-	<p>Replaced by <em>adapted_http_access</em>
-
-	<tag>httpd_accel_no_pmtu_disc</tag>
-	<p>Replaced by <em>http_port disable-pmtu-discovery=</em> option
-
-	<tag>incoming_rate</tag>
-	<p>Obsolete.
-
-	<tag>redirector_bypass</tag>
-	<p>Replaced by <em>url_rewrite_bypass</em>
-
-	<tag>server_http11</tag>
-	<p>Obsolete.
-
-	<tag>upgrade_http0.9</tag>
-	<p>Obsolete.
-
-	<tag>zph_local</tag>
-	<p>Replaced by <em>qos_flows local-hit=</em>
-
-	<tag>zph_mode</tag>
-	<p>Obsolete.
-
-	<tag>zph_option</tag>
-	<p>Obsolete.
-
-	<tag>zph_parent</tag>
-	<p>Replaced by <em>qos_flows parent-hit=</em>
-
-	<tag>zph_sibling</tag>
-	<p>Replaced by <em>qos_flows sibling-hit=</em>
-
-</descrip>
-
-<sect1>Removed squid.conf options since Squid-2.6
-<p>
-<descrip>
-	<tag>cache_dir</tag>
-	<p><em>read-only</em> option replaced by <em>no-store</em>.
-
-</descrip>
-
-<sect1>Removed ./configure options since Squid-2.7
-<p>
-<descrip>
-	<tag>--enable-coss-aio-ops</tag>
-	<p>Obsolete.
-
-	<tag>--enable-devpoll</tag>
-	<p>Replaced by automatic detection.
-
-	<tag>--enable-dlmalloc=LIB</tag>
-	<p>Obsolete.
-
-	<tag>--enable-epoll</tag>
-	<p>Replaced by automatic detection.
-
-	<tag>--enable-forward-log</tag>
-	<p>Obsolete.
-
-	<tag>--enable-heap-replacement</tag>
-	<p>Obsolete.
-
-	<tag>--enable-htcp</tag>
-	<p>Obsolete. Enabled by default.
-
-	<tag>--enable-large-cache-files</tag>
-	<p>Obsolete.
-
-	<tag>--enable-mempool-debug</tag>
-	<p>Obsolete.
-
-	<tag>--enable-multicast-miss</tag>
-	<p>Obsolete.
-
-	<tag>--enable-poll</tag>
-	<p>Replaced by automatic detection.
-
-	<tag>--enable-select</tag>
-	<p>Replaced by automatic detection.
-
-	<tag>--enable-select-simple</tag>
-	<p>Replaced by automatic detection.
-
-	<tag>--enable-snmp</tag>
-	<p>Obsolete. Enabled by default.
-
-	<tag>--enable-truncate</tag>
-	<p>Obsolete.
-
-	<tag>--disable-kqueue</tag>
-	<p>Obsolete. Disabled by default.
+	<p>This has not been supported by Squid for several versions.
 
 </descrip>
 
@@ -242,16 +271,6 @@ This section gives an account of those changes in three categories:
 <sect1>Missing squid.conf options available in Squid-2.7
 <p>
 <descrip>
-	<tag>acl</tag>
-	<p><em>urllogin</em> option not yet ported from 2.6
-	<p><em>urlgroup</em> option not yet ported from 2.6
-
-	<tag>authenticate_ip_shortcircuit_access</tag>
-	<p>Not yet ported from 2.7
-
-	<tag>authenticate_ip_shortcircuit_ttl</tag>
-	<p>Not yet ported from 2.7
-
 	<tag>broken_vary_encoding</tag>
 	<p>Not yet ported from 2.6
 
@@ -287,7 +306,6 @@ This section gives an account of those changes in three categories:
 
 	<tag>http_port</tag>
 	<p><em>act-as-origin</em> not yet ported from 2.7
-	<p><em>urlgroup=</em> not yet ported from 2.6
 
 	<tag>ignore_ims_on_miss</tag>
 	<p>Not yet ported from 2.7
@@ -304,9 +322,6 @@ This section gives an account of those changes in three categories:
 	<tag>location_rewrite_program</tag>
 	<p>Not yet ported from 2.6
 
-	<tag>logformat</tag>
-	<p><em>%oa</em> tag not yet ported from 2.7
-
 	<tag>refresh_pattern</tag>
 	<p><em>stale-while-revalidate=</em> not yet ported from 2.7
 	<p><em>ignore-stale-while-revalidate=</em> not yet ported from 2.7
@@ -330,16 +345,6 @@ This section gives an account of those changes in three categories:
 	<tag>update_headers</tag>
 	<p>Not yet ported from 2.7
 
-	<tag>zero_buffers</tag>
-	<p>Not yet ported from 2.7
-
-</descrip>
-
-<sect1>Missing ./configure options available in Squid-2.7
-<p>
-<descrip>
-	<tag>--without-system-md5</tag>
-
 </descrip>
 
 </article>
@@ -1,7 +1,4 @@
 ## Process this file with automake to produce Makefile.in
-#
-# $Id$
-#
 
 errordir = $(datadir)/errors
 
@@ -93,8 +93,7 @@
 #include <string.h>
 #include <ctype.h>
 
-#if _SQUID_MSWIN_		/* Native Windows port and MinGW */
-
+#if _SQUID_WINDOWS_ && !_SQUID_CYGWIN_
 #define snprintf _snprintf
 #include <windows.h>
 #include <winldap.h>
@@ -554,7 +553,7 @@ main(int argc, char **argv)
     /* On Windows ldap_start_tls_s is available starting from Windows XP,
      * so we need to bind at run-time with the function entry point
      */
-#if _SQUID_MSWIN_
+#if _SQUID_WINDOWS_
     if (use_tls) {
 
         HMODULE WLDAP32Handle;
@@ -1,5 +1,4 @@
 #!@PERL@
-# $Id$
 
 #if you define this, debugging output will be printed to STDERR.
 #$debug=1;
@@ -1,5 +1,10 @@
 #!/bin/sh
-# Don't build on Windows
+#
+# Don't build this helper on Windows
+#
+if test "$1" = "mingw"; then
+        exit 1
+fi
 if [ -f /usr/include/w32api/windows.h ]; then
 	exit 1
 fi
@@ -120,7 +120,7 @@ static int retries = 10;
 
 char progname[] = "basic_radius_auth";
 
-#if _SQUID_MSWIN_
+#if _SQUID_WINDOWS_
 void
 Win32SockCleanup(void)
 {
@@ -522,7 +522,7 @@ main(int argc, char **argv)
         fprintf(stderr, "FATAL: %s: Shared secret not specified\n", argv[0]);
         exit(1);
     }
-#if _SQUID_MSWIN_
+#if _SQUID_WINDOWS_
     {
         WSADATA wsaData;
         WSAStartup(2, &wsaData);
@@ -26,7 +26,9 @@
 
 #include "squid.h"
 #include "helpers/defines.h"
+#include "rfc1738.h"
 #include "util.h"
+#include "valid.h"
 
 #if HAVE_STDIO_H
 #include <stdio.h>
@@ -41,8 +43,6 @@
 #error NON WINDOWS PLATFORM
 #endif
 
-#include "valid.h"
-
 static char NTGroup[256];
 char * NTAllowedGroup;
 char * NTDisAllowedGroup;
@@ -56,18 +56,16 @@ int debug_enabled = 0;
  * -D can specify a Windows Local Group name not allowed to authenticate.
  * -O can specify the default Domain against to authenticate.
  */
-char *my_program_name = NULL;
-
-void
-usage()
+static void
+usage(const char *name)
 {
     fprintf(stderr, "Usage:\n%s [-A|D UserGroup][-O DefaultDomain][-d]\n"
             "-A can specify a Windows Local Group name allowed to authenticate\n"
             "-D can specify a Windows Local Group name not allowed to authenticate\n"
             "-O can specify the default Domain against to authenticate\n"
             "-d enable debugging.\n"
             "-h this message\n\n",
-            my_program_name);
+            name);
 }
 
 void
@@ -100,7 +98,7 @@ process_options(int argc, char *argv[])
             /* fall thru to default */
         default:
             fprintf(stderr, "FATAL: Unknown option: -%c\n", opt);
-            usage();
+            usage(argv[0]);
             exit(1);
         }
     }
@@ -118,7 +116,6 @@ main(int argc, char **argv)
     char *p;
     int err = 0;
 
-    my_program_name = argv[0];
     process_options(argc, argv);
 
     if (LoadSecurityDll(SSP_BASIC, NTLM_PACKAGE_NAME) == NULL) {
@@ -1,4 +1,10 @@
 #!/bin/sh
+#
+# Only build this helper on Windows
+#
+if test "$1" = "mingw"; then
+	exit 0
+fi
 if [ -f /usr/include/w32api/windows.h ]; then
 	exit 0
 fi
@@ -28,23 +28,16 @@
 #ifndef _VALID_H_
 #define _VALID_H_
 
-#if _SQUID_CYGWIN_
+#include "sspwin32.h"
+
+#if HAVE_WINDOWS_H
 #include <windows.h>
 #endif
 #include <lm.h>
-#include "sspwin32.h"
+#include <sys/types.h>
 #undef debug
 
 /************* CONFIGURATION ***************/
-/*
- * define this if you want debugging
- */
-#ifndef DEBUG
-#define DEBUG
-#endif
-
-#define safe_free(x)	if (x) { free(x); x = NULL; }
-
 /* SMB User verification function */
 
 #define NTV_NO_ERROR 0
@@ -66,12 +59,8 @@ extern int debug_enabled;
 extern char Default_NTDomain[DNLEN+1];
 extern const char * errormsg;
 
-#include <sys/types.h>
-
 /* Debugging stuff */
-
-#ifdef __GNUC__			/* this is really a gcc-ism */
-#ifdef DEBUG
+#if defined(__GNUC__)			/* this is really a gcc-ism */
 #include <stdio.h>
 #include <unistd.h>
 static char *__foo;
@@ -80,15 +69,10 @@ static char *__foo;
                     ((__foo=strrchr(__FILE__,'/'))==NULL?__FILE__:__foo+1),\
                     __LINE__);\
                     fprintf(stderr,X); }
-#else /* DEBUG */
-#define debug(X...)		/* */
-#endif /* DEBUG */
 #else /* __GNUC__ */
 static void
 debug(char *format,...)
 {
-#ifdef DEBUG
-#if _SQUID_MSWIN_
     if (debug_enabled) {
         va_list args;
 
@@ -97,8 +81,6 @@ debug(char *format,...)
         vfprintf(stderr, format, args);
         va_end(args);
     }
-#endif /* _SQUID_MSWIN_ */
-#endif /* DEBUG */
 }
 #endif /* __GNUC__ */
 
@@ -14,4 +14,7 @@
 /* send ERR result to Squid with a string parameter. */
 #define SEND_ERR(x)	fprintf(stdout, "ERR %s\n",x)
 
+/* send ERR result to Squid with a string parameter. */
+#define SEND_BH(x)	fprintf(stdout, "BH %s\n",x)
+
 #endif /* __SQUID_HELPERS_DEFINES_H */
@@ -12,7 +12,7 @@
 
 #include "ldap_backend.h"
 
-#if _SQUID_MSWIN_		/* Native Windows port and MinGW */
+#if _SQUID_WINDOWS_ && !_SQUID_CYGWIN_
 
 #define snprintf _snprintf
 #include <windows.h>
@@ -303,7 +303,7 @@ ldapconnect(void)
     /* On Windows ldap_start_tls_s is available starting from Windows XP,
      * so we need to bind at run-time with the function entry point
      */
-#if _SQUID_MSWIN_
+#if _SQUID_WINDOWS_
     if (use_tls) {
 
         HMODULE WLDAP32Handle;
@@ -26,7 +26,7 @@
 
 #include "digest_common.h"
 
-#if _SQUID_MSWIN_            /* Native Windows port and MinGW */
+#if _SQUID_WINDOWS_ && !_SQUID_CYGWIN_
 
 #define snprintf _snprintf
 #include <windows.h>
@@ -11,7 +11,7 @@
 
 #include "ldap_backend.h"
 
-#if _SQUID_MSWIN_		/* Native Windows port and MinGW */
+#if _SQUID_WINDOWS_ && !_SQUID_CYGWIN_
 
 #define snprintf _snprintf
 #include <windows.h>
@@ -331,7 +331,7 @@ ldapconnect(void)
     /* On Windows ldap_start_tls_s is available starting from Windows XP,
      * so we need to bind at run-time with the function entry point
      */
-#if _SQUID_MSWIN_
+#if _SQUID_WINDOWS_
     if (use_tls) {
 
         HMODULE WLDAP32Handle;
@@ -51,7 +51,7 @@
 #include <ctype.h>
 #endif
 
-#if _SQUID_MSWIN_		/* Native Windows port and MinGW */
+#if _SQUID_WINDOWS_ && !_SQUID_CYGWIN_
 
 #define snprintf _snprintf
 #include <windows.h>
@@ -451,7 +451,7 @@ main(int argc, char **argv)
     /* On Windows ldap_start_tls_s is available starting from Windows XP,
      * so we need to bind at run-time with the function entry point
      */
-#if _SQUID_MSWIN_
+#if _SQUID_WINDOWS_
     if (use_tls) {
 
         HMODULE WLDAP32Handle;
@@ -1,4 +1,10 @@
 #!/bin/sh
+#
+# Only build this helper on Windows
+#
+if test "$1" = "mingw"; then
+        exit 0
+fi
 if [ -f /usr/include/w32api/windows.h ]; then
 	exit 0
 fi
@@ -69,7 +69,8 @@
 
 #include "squid.h"
 #include "helpers/defines.h"
-#include "include/util.h"
+#include "rfc1738.h"
+#include "util.h"
 
 #if _SQUID_CYGWIN_
 #include <wchar.h>
@@ -1,23 +1,23 @@
-/* $Id$
-* Copyright (C) 2002 Rodrigo Campos
-*
-* This program is free software; you can redistribute it and/or modify
-* it under the terms of the GNU General Public License as published by
-* the Free Software Foundation; either version 2 of the License, or
-* (at your option) any later version.
-*
-* This program is distributed in the hope that it will be useful,
-* but WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-* GNU General Public License for more details.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*
-* Author: Rodrigo Campos (rodrigo@geekbunker.org)
-*
-*/
+/*
+ * Copyright (C) 2002 Rodrigo Campos
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Author: Rodrigo Campos (rodrigo@geekbunker.org)
+ *
+ */
 #include "squid.h"
 #include "helpers/defines.h"
 #include "rfc1738.h"
@@ -1,4 +1,10 @@
 #!/bin/sh
+#
+# Only build this helper on Windows
+#
+if test "$1" = "mingw"; then
+        exit 0
+fi
 if [ -f /usr/include/w32api/windows.h ]; then
 	exit 0
 fi
@@ -7,7 +7,7 @@ libexec_PROGRAMS = ntlm_sspi_auth
 ntlm_sspi_auth_SOURCES = ntlm_sspi_auth.cc
 
 LDADD = \
-	-L$(top_builddir)/libntlmauth -lntlmauth \
+	$(top_builddir)/lib/ntlmauth/libntlmauth.la \
 	-L$(top_builddir)/lib -lsspwin32 \
 	$(COMPAT_LIB) \
 	-lnetapi32 \
@@ -1,4 +1,10 @@
 #!/bin/sh
+#
+# Only build this helper on Windows
+#
+if test "$1" = "mingw"; then
+        exit 0
+fi
 if [ -f /usr/include/w32api/windows.h ]; then
 	exit 0
 fi
@@ -1,5 +1,10 @@
 #!/bin/sh
-# Don't build on Windows
+#
+# Don't build this helper on Windows
+#
+if test "$1" = "mingw"; then
+        exit 1
+fi
 if [ -f /usr/include/w32api/windows.h ]; then
 	exit 1
 fi
@@ -1,8 +0,0 @@
-#ifndef SQUID_FATAL_H
-#define SQUID_FATAL_H
-
-extern void fatal(const char *message);
-extern void fatalf(const char *fmt,...) PRINTF_FORMAT_ARG1;
-extern void fatal_dump(const char *message);
-
-#endif /* SQUID_FATAL_H */
@@ -1,6 +1,3 @@
-/*
- * $Id$
- */
 #ifndef _SQUID_GETFULLHOSTNAME_H
 #define _SQUID_GETFULLHOSTNAME_H
 
@@ -1,6 +1,3 @@
-/*
- * $Id$
- */
 #ifndef SQUID_HASH_H
 #define SQUID_HASH_H
 
@@ -1,6 +1,3 @@
-/*
- * $Id$
- */
 #ifndef _MEM_METER_H_
 #define _MEM_METER_H_
 
@@ -1,6 +1,3 @@
-/*
- * $Id$
- */
 #ifndef SQUID_PARSE_H
 #define SQUID_PARSE_H
 
@@ -1,6 +1,3 @@
-/*
- * $Id$
- */
 #ifndef SQUID_RADIX_H
 #define	SQUID_RADIX_H
 
@@ -1,6 +1,3 @@
-/*
- * $Id$
- */
 #ifndef _SQUID_INCLUDE_RFC1123_H
 #define _SQUID_INCLUDE_RFC1123_H
 
@@ -1,6 +1,3 @@
-/*
- * $Id$
- */
 #ifndef SQUID_SNMP_API_UTIL_H
 #define SQUID_SNMP_API_UTIL_H
 
@@ -1,7 +1,3 @@
-/*
- * $Id$
- */
-
 #ifndef SQUID_SNMP_CLIENT_H
 #define SQUID_SNMP_CLIENT_H
 
@@ -1,6 +1,3 @@
-/*
- * $Id$
- */
 #ifndef SQUID_SNMP_DEBUG_H
 #define SQUID_SNMP_DEBUG_H
 
@@ -1,6 +1,3 @@
-/*
- * $Id$
- */
 #ifndef SQUID_SNMP_IMPL_H
 #define SQUID_SNMP_IMPL_H
 
@@ -1,6 +1,3 @@
-/*
- * $Id$
- */
 #ifndef SQUID_SNMP_UTIL_H
 #define SQUID_SNMP_UTIL_H
 
@@ -1,7 +1,3 @@
-/*
- * $Id$
- */
-
 #ifndef SQUID_SPLAY_H
 #define SQUID_SPLAY_H
 
@@ -114,8 +114,8 @@
 /* temp hack: needs to be pre-defined for now. */
 #define SQUID_MAXPATHLEN 256
 
-// TODO: determine if this is required. OR if compat/os/mswin.h works
-#if _SQUID_MSWIN_
+// TODO: determine if this is required. OR if compat/os/mswindows.h works
+#if _SQUID_WINDOWS_ && defined(__cplusplus)
 /** \cond AUTODOCS-IGNORE */
 using namespace Squid;
 /** \endcond */
@@ -34,6 +34,10 @@
 
 #if _SQUID_WINDOWS_
 
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
 #define SECURITY_WIN32
 #define NTLM_PACKAGE_NAME "NTLM"
 #define NEGOTIATE_PACKAGE_NAME "Negotiate"
@@ -49,7 +53,7 @@
 #include <security.h>
 #include <sspi.h>
 
-typedef char * SSP_blobP;
+    typedef char * SSP_blobP;
 
 #define WINNT_SECURITY_DLL "security.dll"
 #define WIN2K_SECURITY_DLL "secur32.dll"
@@ -64,16 +68,20 @@ typedef char * SSP_blobP;
 #define SSP_OK 1
 #define SSP_ERROR 2
 
-HMODULE LoadSecurityDll(int, char *);
-void UnloadSecurityDll(void);
-BOOL WINAPI SSP_LogonUser(PTSTR, PTSTR, PTSTR);
-BOOL WINAPI SSP_ValidateNTLMCredentials(PVOID, int, char *);
-const char * WINAPI SSP_ValidateNegotiateCredentials(PVOID, int, PBOOL, int *, char *);
-const char * WINAPI SSP_MakeChallenge(PVOID, int);
-const char * WINAPI SSP_MakeNegotiateBlob(PVOID, int, PBOOL, int *, char *);
+    HMODULE LoadSecurityDll(int, const char *);
+    void UnloadSecurityDll(void);
+    BOOL WINAPI SSP_LogonUser(unsigned char *, unsigned char *, unsigned char *);
+    BOOL WINAPI SSP_ValidateNTLMCredentials(PVOID, int, char *);
+    const char * WINAPI SSP_ValidateNegotiateCredentials(PVOID, int, PBOOL, int *, char *);
+    const char * WINAPI SSP_MakeChallenge(PVOID, int);
+    const char * WINAPI SSP_MakeNegotiateBlob(PVOID, int, PBOOL, int *, char *);
 
-extern BOOL Use_Unicode;
-extern BOOL NTLM_LocalCall;
+    extern BOOL Use_Unicode;
+    extern BOOL NTLM_LocalCall;
+
+#if defined(__cplusplus)
+}
+#endif
 
 #endif /* _SQUID_WINDOWS_ */
 #endif /* LIBSSPWIN32_H_ */
@@ -109,25 +109,4 @@ int statMemoryAccounted(void);
 
 SQUIDCEXTERN unsigned int RoundTo(const unsigned int num, const unsigned int what);
 
-/* Windows Port */
-/* win32lib.c */
-#if _SQUID_MSWIN_
-SQUIDCEXTERN int chroot (const char *);
-#if !HAVE_GETTIMEOFDAY
-SQUIDCEXTERN int gettimeofday(struct timeval * ,void *);
-#endif
-SQUIDCEXTERN int kill(pid_t, int);
-SQUIDCEXTERN int statfs(const char *, struct statfs *);
-SQUIDCEXTERN struct passwd *getpwnam(char *);
-SQUIDCEXTERN struct group *getgrnam(char *);
-SQUIDCEXTERN uid_t geteuid(void);
-SQUIDCEXTERN uid_t getuid(void);
-SQUIDCEXTERN int setuid(uid_t);
-SQUIDCEXTERN int seteuid(uid_t);
-SQUIDCEXTERN gid_t getgid(void);
-SQUIDCEXTERN gid_t getegid(void);
-SQUIDCEXTERN int setgid(gid_t);
-SQUIDCEXTERN int setegid(gid_t);
-SQUIDCEXTERN void WIN32_maperror(unsigned long);
-#endif
 #endif /* SQUID_UTIL_H */
@@ -1,6 +1,3 @@
-/*
- * $Id$
- */
 #ifndef _INC_XUSLEEP_H
 #define _INC_XUSLEEP_H
 
@@ -1,36 +1,38 @@
 include $(top_srcdir)/src/Common.am
 
 DIST_SUBDIRS = ntlmauth profiler rfcnb smblib libTrie
+SUBDIRS=
 EXTRA_DIST=
 
-SUBDIRS = rfcnb smblib
-if ENABLE_AUTH_NTLM
-SUBDIRS += ntlmauth
-endif
 if USE_ESI
 SUBDIRS += libTrie
 endif
 if ENABLE_XPROF_STATS
 SUBDIRS += profiler
 endif
 
-
 install: all
 install-strip: all
 
-if ENABLE_WIN32SPECIFIC
-LIBSSPWIN32=libsspwin32.la
-else
-LIBSSPWIN32=
-EXTRA_LTLIBRARIES = \
-	libsspwin32.la
-endif
-
 noinst_LTLIBRARIES = \
 	libmiscencoding.la \
 	libmisccontainers.la \
-	libmiscutil.la \
-	$(LIBSSPWIN32)
+	libmiscutil.la
+
+#
+# Some libraries are only available on Windows
+# and others are unable to be built.
+#
+if ENABLE_WIN32SPECIFIC
+noinst_LTLIBRARIES += libsspwin32.la
+libsspwin32_la_SOURCES = sspwin32.cc
+else
+SUBDIRS += rfcnb smblib
+EXTRA_DIST += sspwin32.cc
+endif
+if ENABLE_AUTH_NTLM
+SUBDIRS += ntlmauth
+endif
 
 #
 # dirent.c, encrypt.c and getopt.c are needed for native Windows support.
@@ -71,10 +73,6 @@ libmiscutil_la_SOURCES = \
 	util.c \
 	xusleep.c
 
-# $(top_srcdir)/include/version.h should be a dependency
-libsspwin32_la_SOURCES = \
-	sspwin32.c
-
 TESTS += tests/testAll
 
 check_PROGRAMS += tests/testAll
@@ -49,7 +49,7 @@
 #include "squid.h"
 
 /* The following code section is part of the native Windows Squid port */
-#if _SQUID_MSWIN_
+#if _SQUID_WINDOWS_
 
 #include "util.h"
 #include <stdlib.h>
@@ -309,4 +309,4 @@ seekdir(DIR * dirp, long lPos)
         while ((dirp->dd_stat < lPos) && readdir(dirp));
     }
 }
-#endif /* _SQUID_MSWIN_ */
+#endif /* _SQUID_WINDOWS_ */
@@ -1,7 +1,4 @@
 ## Process this file with automake to produce Makefile.in
-#
-# $Id$
-#
 
 AUTOMAKE_OPTIONS = dist-bzip2 subdir-objects 1.5
 DIST_SUBDIRS = include src test
@@ -1,7 +1,3 @@
-/*
- * $Id$
- */
-
 /*
  * COMPILE WITH:
  *      gcc -Wall md5-test.c -I../include md5.o
@@ -32,10 +32,10 @@
  */
 
 #include "squid.h"
-#include "util.h"
-
-#include "libntlmauth/ntlmauth.h"
+#include "base64.h"
+#include "ntlmauth/ntlmauth.h"
 #include "sspwin32.h"
+#include "util.h"
 
 typedef struct _AUTH_SEQ {
     BOOL fInitialized;
@@ -106,7 +106,7 @@ void UnloadSecurityDll(void)
     hModule = NULL;
 }
 
-HMODULE LoadSecurityDll(int mode, char * SSP_Package)
+HMODULE LoadSecurityDll(int mode, const char * SSP_Package)
 {
     TCHAR lpszDLL[MAX_PATH];
     OSVERSIONINFO VerInfo;
@@ -422,11 +422,11 @@ BOOL WINAPI SSP_LogonUser(PTSTR szUser, PTSTR szPassword, PTSTR szDomain)
 
         /* Initialize auth identity structure */
         ZeroMemory(&ai, sizeof(ai));
-        ai.Domain = (void *)szDomain;
+        ai.Domain = (unsigned char *)szDomain;
         ai.DomainLength = lstrlen(szDomain);
-        ai.User = (void *)szUser;
+        ai.User = (unsigned char *)szUser;
         ai.UserLength = lstrlen(szUser);
-        ai.Password = (void *)szPassword;
+        ai.Password = (unsigned char *)szPassword;
         ai.PasswordLength = lstrlen(szPassword);
 #if defined(UNICODE) || defined(_UNICODE)
         ai.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
@@ -513,8 +513,8 @@ const char * WINAPI SSP_MakeChallenge(PVOID PNegotiateBuf, int NegotiateLen)
     } while (0);
     if (fResult != NULL) {
         challenge = (ntlm_challenge *) fResult;
-        Use_Unicode = NEGOTIATE_UNICODE & challenge->flags;
-        NTLM_LocalCall = NEGOTIATE_THIS_IS_LOCAL_CALL & challenge->flags;
+        Use_Unicode = NTLM_NEGOTIATE_UNICODE & challenge->flags;
+        NTLM_LocalCall = NTLM_NEGOTIATE_THIS_IS_LOCAL_CALL & challenge->flags;
         encoded = base64_encode_bin((char *) fResult, cbOut);
     }
     return encoded;
@@ -1,7 +1,3 @@
-/*
- * $Id$
- */
-
 /* Stub function for programs not implementing statMemoryAccounted */
 #include "squid.h"
 #include "util.h"
@@ -1,7 +1,3 @@
-/*
- * $Id$
- */
-
 #include "squid.h"
 #include "uudecode.h"
 
@@ -110,6 +110,9 @@ cp ../commit/squid-3/SPONSORS /server/httpd/htdocs/squid-cache.org/SPONSORS.new
 chmod 444 /server/httpd/htdocs/squid-cache.org/SPONSORS.new
 mv -f /server/httpd/htdocs/squid-cache.org/SPONSORS.new /server/httpd/htdocs/squid-cache.org/content/SPONSORS.txt
 
+../commit/bootstrap squid-3.3
+make_snapshot ../commit/squid-3/mksnapshot.sh 3.3 v3 3.3 30
+
 ../commit/bootstrap squid-3.2
 make_snapshot ../commit/squid-3/mksnapshot.sh branches/SQUID_3_2 v3 3.2 30
 
@@ -8,8 +8,6 @@
 # Check the Squid-1.1.x cache directory for stale objects - i.e. those
 # which exist on disk but aren't listed in cached's log file.
 
-# $Id$
-
 require "getopts.pl";
 &Getopts("c:drt:vh");
 # -c		: the full path to squid.conf
@@ -1,6 +1,5 @@
 #!/usr/bin/perl -w
 
-# $Id$
 # Convert hexadecimal cache file numbers (from swap log) into full pathnames.  
 # Duane Wessels 6/30/97
 
@@ -6,8 +6,6 @@
 # - i.e. those for which there is a "Content-length:" HTTP header,
 #   and this does not match the size of the cached object
 
-# $Id$
-
 require "getopts.pl";
 require "stat.pl";
 &Getopts("cd");
@@ -9,8 +9,6 @@
 # cf.data.pre and split it into separare files, one per option
 #
 # Henrik Nordstrom <henrik@henriknordstrom.net>
-#
-# $Id$
 
 #
 # The template file is reasonably simple to parse. There's a number of
@@ -1,7 +1,5 @@
 #!/usr/local/bin/perl
 
-# $Id$
-
 select(STDERR); $|=1;
 select(STDOUT); $|=1;
 
@@ -9,8 +9,6 @@
 # cf.data.pre and generate a set of HTML pages to use as documentation.
 #
 # Adrian Chadd <adrian@squid-cache.org>
-#
-# $Id$
 
 #
 # The template file is reasonably simple to parse. There's a number of
@@ -19,9 +17,10 @@
 # NAME: <name>
 # IFDEF: <the ifdef bit>
 # TYPE: <the config type>
-# DEFAULT: <the default value>
-# DEFAULT_IF_NONE: <alternative default value>
 # LOC: <location in the Config struct>
+# DEFAULT: <the default value(s) - may be multiple lines>
+# DEFAULT_IF_NONE: <alternative default value>
+# DEFAULT_DOC: <the text to display instead of default value(s)>
 # DOC_START
 #   documentation goes here
 # NOCOMMENT_START
@@ -225,6 +224,22 @@ ($)
 	print $index $comment;
 	print $index "</pre>\n";
 }
+sub update_defaults()
+{
+	if (defined($data->{"default_doc"})) {
+		# default text description masks out the default value display
+		if($data->{"default_doc"} ne "") {
+			print "REPLACE: default '". $data->{"default"} ."' with '" . $data->{"default_doc"} . "'\n" if $verbose;
+			$data->{"default"} = $data->{"default_doc"};
+		}
+	}
+	# when we have no predefined default use the DEFAULT_IF_NONE
+	if (defined($data->{"default_if_none"})) {
+		print "REPLACE: default '". $data->{"default"} ."' with '" . $data->{"default_if_none"} . "'\n" if $verbose && $data->{"default"} eq "";
+		$data->{"default"} = $data->{"default_if_none"} if $data->{"default"} eq "";
+	}
+}
+
 while (<>) {
 	chomp;
 	last if (/^EOF$/);
@@ -241,25 +256,32 @@ ($)
 		$option{$name} = $data;
 		$data->{'name'} = $name;
 		$data->{'aliases'} = \@aliases;
+		$data->{'default'} = "";
+		$data->{'default_doc'} = "";
+		$data->{'default_if_none'} = "";
 
 		print "DEBUG: new option: $name\n" if $verbose;
+		next;
 	} elsif ($_ =~ /^COMMENT: (.*)$/) {
 		$data->{"comment"} = $1;
 	} elsif ($_ =~ /^TYPE: (.*)$/) {
 		$data->{"type"} = $1;
 		start_option($data->{"name"}, $data->{"type"});
 	} elsif ($_ =~ /^DEFAULT: (.*)$/) {
 		if ($1 eq "none") {
-		    $data->{"default"} = "$1";
+		    $data->{"default"} = "$1\n";
 		} else {
-		    $data->{"default"} = "$name $1";
+		    $data->{"default"} .= "$name $1\n";
 		}
+	} elsif ($_ =~ /^DEFAULT_DOC: (.*)$/) {
+		$data->{"default_doc"} .= "$1\n";
 	} elsif ($_ =~ /^DEFAULT_IF_NONE: (.*)$/) {
-		$data->{"default"} = "$name $1";
+		$data->{"default_if_none"} .= "$1\n";
 	} elsif ($_ =~ /^LOC:(.*)$/) {
 		$data->{"loc"} = $1;
 		$data->{"loc"} =~ s/^[\s\t]*//;
 	} elsif ($_ =~ /^DOC_START$/) {
+		update_defaults;
 		$state = "doc";
 	} elsif ($_ =~ /^DOC_END$/) {
 		$state = "";
@@ -269,11 +291,10 @@ ($)
 		}
 		undef @chained;
 	} elsif ($_ =~ /^DOC_NONE$/) {
+		update_defaults;
 		push(@chained, $name);
 	} elsif ($_ =~ /^NOCOMMENT_START$/) {
 		$state = "nocomment";
-	} elsif ($_ =~ /^DEFAULT_IF_NONE: (.*)$/) {
-		$data->{"default_if_none"} = $1;
 	} elsif ($_ =~ /^NOCOMMENT_END$/) {
 		$state = "";
 	} elsif ($_ =~ /^IFDEF: (.*)$/) {
@@ -2,6 +2,7 @@
 #include "AccessLogEntry.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
+#include "SquidConfig.h"
 #include "ssl/support.h"
 
 #if USE_SSL
@@ -31,23 +31,27 @@
 #define SQUID_HTTPACCESSLOGENTRY_H
 
 #include "anyp/PortCfg.h"
+#include "base/RefCount.h"
 #include "comm/Connection.h"
+#include "HttpHeader.h"
 #include "HttpVersion.h"
 #include "HttpRequestMethod.h"
 #include "HierarchyLogEntry.h"
+#include "icp_opcode.h"
 #include "ip/Address.h"
 #include "HttpRequestMethod.h"
 #if ICAP_CLIENT
 #include "adaptation/icap/Elements.h"
 #endif
-#include "RefCount.h"
+#include "Notes.h"
 #if USE_SSL
 #include "ssl/gadgets.h"
 #endif
 
 /* forward decls */
 class HttpReply;
 class HttpRequest;
+class CustomLog;
 
 class AccessLogEntry: public RefCountable
 {
@@ -79,7 +83,7 @@ class AccessLogEntry: public RefCountable
     {
 
     public:
-        HttpDetails() : method(METHOD_NONE), code(0), content_type(NULL),
+        HttpDetails() : method(Http::METHOD_NONE), code(0), content_type(NULL),
                 timedout(false), aborted(false) {}
 
         HttpRequestMethod method;
@@ -227,6 +231,8 @@ class AccessLogEntry: public RefCountable
     HttpReply *reply;
     HttpRequest *request; //< virgin HTTP request
     HttpRequest *adapted_request; //< HTTP request after adaptation and redirection
+    /// key:value pairs set by note and adaptation_meta
+    NotePairs notes;
 
 #if ICAP_CLIENT
     /** \brief This subclass holds log info for ICAP part of request
@@ -274,11 +280,11 @@ class ACLChecklist;
 class StoreEntry;
 
 /* Should be in 'AccessLog.h' as the driver */
-extern void accessLogLogTo(customlog* log, AccessLogEntry::Pointer &al, ACLChecklist* checklist = NULL);
-extern void accessLogLog(AccessLogEntry::Pointer &, ACLChecklist * checklist);
-extern void accessLogRotate(void);
-extern void accessLogClose(void);
-extern void accessLogInit(void);
-extern const char *accessLogTime(time_t);
+void accessLogLogTo(CustomLog* log, AccessLogEntry::Pointer &al, ACLChecklist* checklist = NULL);
+void accessLogLog(AccessLogEntry::Pointer &, ACLChecklist * checklist);
+void accessLogRotate(void);
+void accessLogClose(void);
+void accessLogInit(void);
+const char *accessLogTime(time_t);
 
 #endif /* SQUID_HTTPACCESSLOGENTRY_H */
@@ -63,6 +63,7 @@
 #include "acl/TimeData.h"
 #include "acl/Time.h"
 #include "acl/Url.h"
+#include "acl/UrlLogin.h"
 #include "acl/UrlPath.h"
 #include "acl/UrlPort.h"
 #include "acl/UserData.h"
@@ -130,6 +131,8 @@ ACL::Prototype ACLTime::RegistryProtoype(&ACLTime::RegistryEntry_, "time");
 ACLStrategised<time_t> ACLTime::RegistryEntry_(new ACLTimeData, ACLTimeStrategy::Instance(), "time");
 ACL::Prototype ACLUrl::RegistryProtoype(&ACLUrl::RegistryEntry_, "url_regex");
 ACLStrategised<char const *> ACLUrl::RegistryEntry_(new ACLRegexData, ACLUrlStrategy::Instance(), "url_regex");
+ACL::Prototype ACLUrlLogin::RegistryProtoype(&ACLUrlLogin::RegistryEntry_, "urllogin");
+ACLStrategised<char const *> ACLUrlLogin::RegistryEntry_(new ACLRegexData, ACLUrlLoginStrategy::Instance(), "urllogin");
 ACL::Prototype ACLUrlPath::LegacyRegistryProtoype(&ACLUrlPath::RegistryEntry_, "pattern");
 ACL::Prototype ACLUrlPath::RegistryProtoype(&ACLUrlPath::RegistryEntry_, "urlpath_regex");
 ACLStrategised<char const *> ACLUrlPath::RegistryEntry_(new ACLRegexData, ACLUrlPathStrategy::Instance(), "urlpath_regex");
@@ -1,8 +1,7 @@
 #ifndef SQUID_AUTHREG_H_
 #define SQUID_AUTHREG_H_
 /*
- * DEBUG: section
- * AUTHOR:
+ * DEBUG: section 29    Authenticator
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
  * ----------------------------------------------------------
@@ -37,7 +36,7 @@ namespace Auth
 
 #if USE_AUTH
 /// Initialize Auth subsystem
-extern void Init(void);
+void Init(void);
 #else /* USE_AUTH */
 inline void Init(void) {} /* NOP if not USE_AUTH */
 #endif /* USE_AUTH */
@@ -41,7 +41,6 @@
 #if USE_CACHE_DIGESTS
 
 #include "CacheDigest.h"
-#include "structs.h"
 
 /* local types */
 
@@ -1,3 +1,5 @@
+#ifndef SQUID_CACHEDIGEST_H_
+#define SQUID_CACHEDIGEST_H_
 /*
  * DEBUG: section 70    Cache Digest
  * AUTHOR: Alex Rousskov
@@ -30,25 +32,37 @@
  *
  */
 
-#ifndef SQUID_CACHEDIGEST_H_
-#define SQUID_CACHEDIGEST_H_
-
+/* for cache_key */
 #include "typedefs.h"
+
 class CacheDigestGuessStats;
 class StoreEntry;
 
-extern CacheDigest *cacheDigestCreate(int capacity, int bpe);
-extern void cacheDigestDestroy(CacheDigest * cd);
-extern CacheDigest *cacheDigestClone(const CacheDigest * cd);
-extern void cacheDigestClear(CacheDigest * cd);
-extern void cacheDigestChangeCap(CacheDigest * cd, int new_cap);
-extern int cacheDigestTest(const CacheDigest * cd, const cache_key * key);
-extern void cacheDigestAdd(CacheDigest * cd, const cache_key * key);
-extern void cacheDigestDel(CacheDigest * cd, const cache_key * key);
-extern size_t cacheDigestCalcMaskSize(int cap, int bpe);
-extern int cacheDigestBitUtil(const CacheDigest * cd);
-extern void cacheDigestGuessStatsUpdate(CacheDigestGuessStats * stats, int real_hit, int guess_hit);
-extern void cacheDigestGuessStatsReport(const CacheDigestGuessStats * stats, StoreEntry * sentry, const char *label);
-extern void cacheDigestReport(CacheDigest * cd, const char *label, StoreEntry * e);
+// currently a POD
+class CacheDigest
+{
+public:
+    /* public, read-only */
+    char *mask;         /* bit mask */
+    int mask_size;      /* mask size in bytes */
+    int capacity;       /* expected maximum for .count, not a hard limit */
+    int bits_per_entry;     /* number of bits allocated for each entry from capacity */
+    int count;          /* number of digested entries */
+    int del_count;      /* number of deletions performed so far */
+};
+
+CacheDigest *cacheDigestCreate(int capacity, int bpe);
+void cacheDigestDestroy(CacheDigest * cd);
+CacheDigest *cacheDigestClone(const CacheDigest * cd);
+void cacheDigestClear(CacheDigest * cd);
+void cacheDigestChangeCap(CacheDigest * cd, int new_cap);
+int cacheDigestTest(const CacheDigest * cd, const cache_key * key);
+void cacheDigestAdd(CacheDigest * cd, const cache_key * key);
+void cacheDigestDel(CacheDigest * cd, const cache_key * key);
+size_t cacheDigestCalcMaskSize(int cap, int bpe);
+int cacheDigestBitUtil(const CacheDigest * cd);
+void cacheDigestGuessStatsUpdate(CacheDigestGuessStats * stats, int real_hit, int guess_hit);
+void cacheDigestGuessStatsReport(const CacheDigestGuessStats * stats, StoreEntry * sentry, const char *label);
+void cacheDigestReport(CacheDigest * cd, const char *label, StoreEntry * e);
 
 #endif /* SQUID_CACHEDIGEST_H_ */
@@ -37,6 +37,8 @@
 #include "mgr/ActionProfile.h"
 #include "mgr/Command.h"
 #include "mgr/forward.h"
+#include "typedefs.h"
+
 #include <vector>
 
 /**
@@ -48,6 +50,10 @@
  */
 
 class HttpRequest;
+namespace Mgr
+{
+class ActionPasswordList;
+} //namespace Mgr
 /**
  \ingroup CacheManagerAPI
  * a CacheManager - the menu system for interacting with squid.
@@ -83,7 +89,7 @@ class CacheManager
     Mgr::CommandPointer ParseUrl(const char *url);
     void ParseHeaders(const HttpRequest * request, Mgr::ActionParams &params);
     int CheckPassword(const Mgr::Command &cmd);
-    char *PasswdGet(cachemgr_passwd *, const char *);
+    char *PasswdGet(Mgr::ActionPasswordList *, const char *);
 
     void registerProfile(const Mgr::ActionProfilePointer &profile);
 
@@ -0,0 +1,211 @@
+#ifndef SQUID_CACHEPEER_H_
+#define SQUID_CACHEPEER_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "enums.h"
+#include "icp_opcode.h"
+#include "ip/Address.h"
+
+//TODO: remove, it is unconditionally defined and always used.
+#define PEER_MULTICAST_SIBLINGS 1
+
+#if USE_SSL
+#include <openssl/ssl.h>
+#endif
+
+class acl_access;
+class CachePeerDomainList;
+class NeighborTypeDomainList;
+class PeerDigest;
+
+// currently a POD
+class CachePeer
+{
+public:
+    u_int index;
+    char *name;
+    char *host;
+    peer_t type;
+
+    Ip::Address in_addr;
+
+    struct {
+        int pings_sent;
+        int pings_acked;
+        int fetches;
+        int rtt;
+        int ignored_replies;
+        int n_keepalives_sent;
+        int n_keepalives_recv;
+        time_t probe_start;
+        time_t last_query;
+        time_t last_reply;
+        time_t last_connect_failure;
+        time_t last_connect_probe;
+        int logged_state;   /* so we can print dead/revived msgs */
+        int conn_open;      /* current opened connections */
+    } stats;
+
+    struct {
+        int version;
+        int counts[ICP_END+1];
+        unsigned short port;
+    } icp;
+
+#if USE_HTCP
+    struct {
+        double version;
+        int counts[2];
+        unsigned short port;
+    } htcp;
+#endif
+
+    unsigned short http_port;
+    CachePeerDomainList *peer_domain;
+    NeighborTypeDomainList *typelist;
+    acl_access *access;
+
+    struct {
+        unsigned int proxy_only:1;
+        unsigned int no_query:1;
+        unsigned int background_ping:1;
+        unsigned int no_digest:1;
+        unsigned int default_parent:1;
+        unsigned int roundrobin:1;
+        unsigned int weighted_roundrobin:1;
+        unsigned int mcast_responder:1;
+        unsigned int closest_only:1;
+#if USE_HTCP
+        unsigned int htcp:1;
+        unsigned int htcp_oldsquid:1;
+        unsigned int htcp_no_clr:1;
+        unsigned int htcp_no_purge_clr:1;
+        unsigned int htcp_only_clr:1;
+        unsigned int htcp_forward_clr:1;
+#endif
+        unsigned int no_netdb_exchange:1;
+#if USE_DELAY_POOLS
+        unsigned int no_delay:1;
+#endif
+        unsigned int allow_miss:1;
+        unsigned int carp:1;
+        struct {
+            unsigned int set:1; //If false, whole url is to be used. Overrides others
+            unsigned int scheme:1;
+            unsigned int host:1;
+            unsigned int port:1;
+            unsigned int path:1;
+            unsigned int params:1;
+        } carp_key;
+#if USE_AUTH
+        unsigned int userhash:1;
+#endif
+        unsigned int sourcehash:1;
+        unsigned int originserver:1;
+        unsigned int no_tproxy:1;
+#if PEER_MULTICAST_SIBLINGS
+        unsigned int mcast_siblings:1;
+#endif
+    } options;
+
+    int weight;
+    int basetime;
+
+    struct {
+        double avg_n_members;
+        int n_times_counted;
+        int n_replies_expected;
+        int ttl;
+        int id;
+
+        struct {
+            unsigned int count_event_pending:1;
+            unsigned int counting:1;
+        } flags;
+    } mcast;
+#if USE_CACHE_DIGESTS
+
+    PeerDigest *digest;
+    char *digest_url;
+#endif
+
+    int tcp_up;         /* 0 if a connect() fails */
+
+    Ip::Address addresses[10];
+    int n_addresses;
+    int rr_count;
+    CachePeer *next;
+    int testing_now;
+
+    struct {
+        unsigned int hash;
+        double load_multiplier;
+        double load_factor; /* normalized weight value */
+    } carp;
+#if USE_AUTH
+    struct {
+        unsigned int hash;
+        double load_multiplier;
+        double load_factor; /* normalized weight value */
+    } userhash;
+#endif
+    struct {
+        unsigned int hash;
+        double load_multiplier;
+        double load_factor; /* normalized weight value */
+    } sourcehash;
+
+    char *login;        /* Proxy authorization */
+    time_t connect_timeout;
+    int connect_fail_limit;
+    int max_conn;
+    char *domain;       /* Forced domain */
+#if USE_SSL
+
+    int use_ssl;
+    char *sslcert;
+    char *sslkey;
+    int sslversion;
+    char *ssloptions;
+    char *sslcipher;
+    char *sslcafile;
+    char *sslcapath;
+    char *sslcrlfile;
+    char *sslflags;
+    char *ssldomain;
+    SSL_CTX *sslContext;
+    SSL_SESSION *sslSession;
+#endif
+
+    int front_end_https;
+    int connection_auth;
+};
+
+#endif /* SQUID_CACHEPEER_H_ */
@@ -0,0 +1,41 @@
+#ifndef SQUID_CACHEPEERDOMAINLIST_H_
+#define SQUID_CACHEPEERDOMAINLIST_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+/// representation of the cache_peer_domain list. POD.
+class CachePeerDomainList
+{
+public:
+    char *domain;
+    bool do_ping;
+    CachePeerDomainList *next;
+};
+
+#endif /* SQUID_CACHEPEERDOMAINLIST_H_ */
@@ -1,8 +1,8 @@
 #ifndef SQUID_CLIENTREQUESTCONTEXT_H
 #define SQUID_CLIENTREQUESTCONTEXT_H
 
+#include "base/RefCount.h"
 #include "cbdata.h"
-#include "RefCount.h"
 #include "ipcache.h"
 
 #if USE_ADAPTATION
@@ -1,8 +1,3 @@
-
-/*
- * $Id$
- */
-
 #ifndef SQUID_COMMCALLS_H
 #define SQUID_COMMCALLS_H
 
@@ -30,11 +30,11 @@
 #ifndef SQUID_CONFIGOPTION_H
 #define SQUID_CONFIGOPTION_H
 
-class StoreEntry;
-
 /* for Vector<> */
 #include "Array.h"
 
+class StoreEntry;
+
 /* cache option parsers */
 
 class ConfigOption
@@ -35,6 +35,7 @@
 #include "cache_cf.h"
 #include "ConfigParser.h"
 #include "Debug.h"
+#include "fatal.h"
 #include "globals.h"
 
 void
@@ -78,6 +78,6 @@ class ConfigParser
     static char * strtokFile();
 };
 
-extern int parseConfigFile(const char *file_name);
+int parseConfigFile(const char *file_name);
 
 #endif /* SQUID_CONFIGPARSER_H */
@@ -9,7 +9,7 @@
 #include "CpuAffinitySet.h"
 #include "Debug.h"
 #include "globals.h"
-#include "structs.h"
+#include "SquidConfig.h"
 #include "tools.h"
 
 #include <algorithm>
@@ -5,12 +5,12 @@
 #define SQUID_CPU_AFFINITY_H
 
 /// set CPU affinity for this process on startup
-SQUIDCEXTERN void CpuAffinityInit();
+void CpuAffinityInit();
 
 /// reconfigure CPU affinity for this process
-SQUIDCEXTERN void CpuAffinityReconfigure();
+void CpuAffinityReconfigure();
 
 /// check CPU affinity configuration and print warnings if needed
-SQUIDCEXTERN void CpuAffinityCheck();
+void CpuAffinityCheck();
 
 #endif // SQUID_CPU_AFFINITY_H
@@ -59,8 +59,8 @@
 
 /* context-based debugging, the actual type is subject to change */
 typedef int Ctx;
-extern Ctx ctx_enter(const char *descr);
-extern void ctx_exit(Ctx ctx);
+Ctx ctx_enter(const char *descr);
+void ctx_exit(Ctx ctx);
 
 /* defined debug section limits */
 #define MAX_DEBUG_SECTIONS 100
@@ -141,9 +141,9 @@ inline std::ostream& operator <<(std::ostream &os, const uint8_t d)
 #define old_debug(SECTION, LEVEL)  if do_debug((SECTION), (LEVEL)) _db_print
 
 /* Legacy debug function definitions */
-extern void _db_init(const char *logfile, const char *options);
-extern void _db_print(const char *,...) PRINTF_FORMAT_ARG1;
-extern void _db_set_syslog(const char *facility);
-extern void _db_rotate_log(void);
+void _db_init(const char *logfile, const char *options);
+void _db_print(const char *,...) PRINTF_FORMAT_ARG1;
+void _db_set_syslog(const char *facility);
+void _db_rotate_log(void);
 
 #endif /* SQUID_DEBUG_H */
@@ -39,6 +39,7 @@
 #if USE_DELAY_POOLS
 #include "DelayBucket.h"
 #include "DelaySpec.h"
+#include "SquidConfig.h"
 #include "Store.h"
 
 void
@@ -48,6 +48,7 @@
 #include "DelayPool.h"
 #include "DelayPools.h"
 #include "HttpRequest.h"
+#include "SquidConfig.h"
 
 DelayId::DelayId () : pool_ (0), compositeId(NULL), markedAsNoDelay(false)
 {}
@@ -38,8 +38,8 @@
 #define DELAYIDCOMPOSITE_H
 
 #if USE_DELAY_POOLS
+#include "base/RefCount.h"
 #include "fatal.h"
-#include "RefCount.h"
 
 class DeferredRead;
 
@@ -34,15 +34,11 @@
 
 #if USE_DISKIO_AIO
 
-#if _SQUID_CYGWIN_
-#include "squid_windows.h"
-#endif
-
 #ifndef off64_t
 typedef int64_t	off64_t;
 #endif
 
-#if _SQUID_MSWIN_
+#if _SQUID_WINDOWS_
 
 union sigval {
     int sival_int; /* integer value */
@@ -104,6 +100,6 @@ int aio_error64(const struct aiocb64 *);
 int aio_open(const char *, int);
 void aio_close(int);
 
-#endif /* _SQUID_MSWIN_ */
+#endif /* _SQUID_WINDOWS_ */
 #endif /* USE_DISKIO_AIO */
 #endif /* __WIN32_AIO_H__ */
@@ -41,9 +41,15 @@
 #include "DiskIO/WriteRequest.h"
 #include "StatCounters.h"
 
+#if HAVE_SYS_IPC_H
 #include <sys/ipc.h>
+#endif
+#if HAVE_SYS_MSG_H
 #include <sys/msg.h>
+#endif
+#if HAVE_SYS_SHM_H
 #include <sys/shm.h>
+#endif
 
 CBDATA_CLASS_INIT(DiskdFile);
 
@@ -380,7 +386,7 @@ DiskdFile::readDone(diomsg * M)
     assert (M->requestor);
     ReadRequest::Pointer readRequest = dynamic_cast<ReadRequest *>(M->requestor);
     /* remove the free protection */
-    readRequest->RefCountDereference();
+    readRequest->unlock();
 
     if (M->status < 0) {
         ++diskd_stats.read.fail;
@@ -404,7 +410,7 @@ DiskdFile::writeDone(diomsg *M)
     assert (M->requestor);
     WriteRequest::Pointer writeRequest = dynamic_cast<WriteRequest *>(M->requestor);
     /* remove the free protection */
-    writeRequest->RefCountDereference();
+    writeRequest->unlock();
 
     if (M->status < 0) {
         errorOccured = true;
@@ -41,13 +41,20 @@
 #include "fd.h"
 #include "Store.h"
 #include "StatCounters.h"
+#include "SquidConfig.h"
 #include "SquidIpc.h"
 #include "SquidTime.h"
 #include "unlinkd.h"
 
+#if HAVE_SYS_IPC_H
 #include <sys/ipc.h>
+#endif
+#if HAVE_SYS_MSG_H
 #include <sys/msg.h>
+#endif
+#if HAVE_SYS_SHM_H
 #include <sys/shm.h>
+#endif
 #if HAVE_ERRNO_H
 #include <errno.h>
 #endif
@@ -317,7 +324,7 @@ DiskdIOStrategy::handle(diomsg * M)
 
     if (M->newstyle) {
         DiskdFile *theFile = (DiskdFile *)M->callback_data;
-        theFile->RefCountDereference();
+        theFile->unlock();
         theFile->completed (M);
     } else
         switch (M->mtype) {
@@ -347,16 +354,16 @@ DiskdIOStrategy::handle(diomsg * M)
 }
 
 int
-DiskdIOStrategy::send(int mtype, int id, DiskdFile *theFile, size_t size, off_t offset, ssize_t shm_offset, RefCountable_ *requestor)
+DiskdIOStrategy::send(int mtype, int id, DiskdFile *theFile, size_t size, off_t offset, ssize_t shm_offset, Lock *requestor)
 {
     diomsg M;
     M.callback_data = cbdataReference(theFile);
-    theFile->RefCountReference();
+    theFile->lock();
     M.requestor = requestor;
     M.newstyle = true;
 
     if (requestor)
-        requestor->RefCountReference();
+        requestor->lock();
 
     return SEND(&M, mtype, id, size, offset, shm_offset);
 }
@@ -62,7 +62,7 @@ class SharedMemory
 class DiskFile;
 
 class DiskdFile;
-
+class Lock;
 class ReadRequest;
 
 /// \ingroup diskd
@@ -80,8 +80,8 @@ class DiskdIOStrategy : public DiskIOStrategy
     virtual void init();
     virtual void sync();
     virtual int callback();
-    virtual void statfs(StoreEntry & sentry)const;
-    int send(int mtype, int id, DiskdFile *theFile, size_t size, off_t offset, ssize_t shm_offset, RefCountable_ *requestor);
+    virtual void statfs(StoreEntry & sentry) const;
+    int send(int mtype, int id, DiskdFile *theFile, size_t size, off_t offset, ssize_t shm_offset, Lock *requestor);
 
     /** public for accessing return address's */
     SharedMemory shm;
@@ -17,14 +17,14 @@ enum {
     _MQD_UNLINK
 };
 
-struct RefCountable_;
+class Lock;
 
 struct diomsg {
     mtyp_t mtype;
     int id;
     int seq_no;
     void * callback_data;
-    RefCountable_ * requestor;
+    Lock * requestor;
     size_t size;
     off_t offset;
     int status;
@@ -37,9 +37,15 @@
 #if HAVE_ERRNO_H
 #include <errno.h>
 #endif
+#if HAVE_SYS_IPC_H
 #include <sys/ipc.h>
+#endif
+#if HAVE_SYS_MSG_H
 #include <sys/msg.h>
+#endif
+#if HAVE_SYS_SHM_H
 #include <sys/shm.h>
+#endif
 #if HAVE_IOSTREAM
 #include <iostream>
 #endif
@@ -31,10 +31,9 @@
 #ifndef SQUID_DISKFILE_H
 #define SQUID_DISKFILE_H
 
+#include "base/RefCount.h"
 #include "typedefs.h"
 
-#include "RefCount.h"
-
 class IORequestor;
 
 class ReadRequest;
@@ -31,8 +31,8 @@
 #ifndef SQUID_DISKIOSTRATEGY_H
 #define SQUID_DISKIOSTRATEGY_H
 
+#include "base/RefCount.h"
 #include "Store.h"
-#include "RefCount.h"
 
 class DiskFile;
 
@@ -39,19 +39,22 @@
 #include "globals.h"
 
 void
-CommIO::Initialise()
+CommIO::Initialize()
 {
+    if (CommIO::Initialized)
+        return;
+
     /* Initialize done pipe signal */
     int DonePipe[2];
     if (pipe(DonePipe)) {}
     DoneFD = DonePipe[1];
     DoneReadFD = DonePipe[0];
-    fd_open(DoneReadFD, FD_PIPE, "async-io completetion event: main");
-    fd_open(DoneFD, FD_PIPE, "async-io completetion event: threads");
+    fd_open(DoneReadFD, FD_PIPE, "async-io completion event: main");
+    fd_open(DoneFD, FD_PIPE, "async-io completion event: threads");
     commSetNonBlocking(DoneReadFD);
     commSetNonBlocking(DoneFD);
     Comm::SetSelect(DoneReadFD, COMM_SELECT_READ, NULLFDHandler, NULL, 0);
-    Initialised = true;
+    Initialized = true;
 }
 
 void
@@ -63,10 +66,10 @@ CommIO::NotifyIOClose()
     close(DoneReadFD);
     fd_close(DoneFD);
     fd_close(DoneReadFD);
-    Initialised = false;
+    Initialized = false;
 }
 
-bool CommIO::Initialised = false;
+bool CommIO::Initialized = false;
 bool CommIO::DoneSignalled = false;
 int CommIO::DoneFD = -1;
 int CommIO::DoneReadFD = -1;
@@ -10,24 +10,25 @@ class CommIO
 public:
     static inline void NotifyIOCompleted();
     static void ResetNotifications();
-    static void Initialise();
+    static void Initialize();
     static void NotifyIOClose();
 
 private:
     static void NULLFDHandler(int, void *);
     static void FlushPipe();
-    static bool Initialised;
+    static bool Initialized;
     static bool DoneSignalled;
     static int DoneFD;
     static int DoneReadFD;
 };
 
-/* Inline code. TODO: make structued approach to inlining */
+/* Inline code. TODO: make structured approach to inlining */
 void
 CommIO::NotifyIOCompleted()
 {
-    if (!Initialised)
-        Initialise();
+    if (!Initialized) {
+        fatalf("Disk Threads I/O pipes not initialized before first use.");
+    }
 
     if (!DoneSignalled) {
         DoneSignalled = true;
@@ -38,8 +38,8 @@
 #include "DiskThreadsIOStrategy.h"
 #include "fde.h"
 #include "mgr/Registration.h"
+#include "SquidConfig.h"
 #include "StatCounters.h"
-/* for statfs */
 #include "Store.h"
 
 void
@@ -36,16 +36,17 @@
 
 #include "squid.h"
 #include "DiskThreads.h"
-
-#include	<stdio.h>
-#include	<sys/stat.h>
-#include	<fcntl.h>
-#include	<pthread.h>
-#include	<errno.h>
-#include	<dirent.h>
-#include	<signal.h>
+#include "SquidConfig.h"
+
+#include <stdio.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <errno.h>
+#include <dirent.h>
+#include <signal.h>
 #if HAVE_SCHED_H
-#include	<sched.h>
+#include <sched.h>
 #endif
 #include "DiskIO/DiskThreads/CommIO.h"
 #include "SquidTime.h"
@@ -106,7 +107,7 @@ struct squidaio_thread_t {
 
 static void squidaio_queue_request(squidaio_request_t *);
 static void squidaio_cleanup_request(squidaio_request_t *);
-SQUIDCEXTERN void *squidaio_thread_loop(void *);
+void *squidaio_thread_loop(void *);
 static void squidaio_do_open(squidaio_request_t *);
 static void squidaio_do_read(squidaio_request_t *);
 static void squidaio_do_write(squidaio_request_t *);
@@ -305,6 +306,10 @@ squidaio_init(void)
 
     done_queue.blocked = 0;
 
+    // Initialize the thread I/O pipes before creating any threads
+    // see bug 3189 comment 5 about race conditions.
+    CommIO::Initialize();
+
     /* Create threads and get them to sit in their wait loop */
     squidaio_thread_pool = memPoolCreate("aio_thread", sizeof(squidaio_thread_t));
 
@@ -33,18 +33,18 @@
  */
 
 #include "squid.h"
-#include "squid_windows.h"
 #include "DiskIO/DiskThreads/CommIO.h"
 #include "DiskThreads.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 
-#include	<stdio.h>
-#include	<sys/stat.h>
-#include	<fcntl.h>
-#include	<errno.h>
-#include	<dirent.h>
-#include	<signal.h>
+#include <stdio.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <dirent.h>
+#include <signal.h>
 
 #define RIDICULOUS_LENGTH	4096
 
@@ -32,7 +32,7 @@
 #ifndef SQUID_IOREQUESTOR_H
 #define SQUID_IOREQUESTOR_H
 
-#include "RefCount.h"
+#include "base/RefCount.h"
 
 class ReadRequest;
 
@@ -18,6 +18,7 @@
 #include "ipc/Queue.h"
 #include "ipc/StrandSearch.h"
 #include "ipc/UdsOp.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "StatCounters.h"
 #include "tools.h"
@@ -32,8 +32,8 @@
 #ifndef SQUID_READREQUEST_H
 #define SQUID_READREQUEST_H
 
+#include "base/RefCount.h"
 #include "cbdata.h"
-#include "RefCount.h"
 
 class ReadRequest : public RefCountable
 {
@@ -32,8 +32,8 @@
 #ifndef SQUID_WRITEREQUEST_H
 #define SQUID_WRITEREQUEST_H
 
+#include "base/RefCount.h"
 #include "cbdata.h"
-#include "RefCount.h"
 
 class WriteRequest : public RefCountable
 {
@@ -5,7 +5,6 @@
 #ifndef SQUID_DNS_LOOKUP_DETAILS_H
 #define SQUID_DNS_LOOKUP_DETAILS_H
 
-#include "typedefs.h"
 #include "SquidString.h"
 
 /// encapsulates DNS lookup results
@@ -14,10 +14,10 @@ class ETag
 };
 
 /* ETag */
-SQUIDCEXTERN int etagParseInit(ETag * etag, const char *str);
+int etagParseInit(ETag * etag, const char *str);
 /// whether etags are strong-equal
-SQUIDCEXTERN bool etagIsStrongEqual(const ETag &tag1, const ETag &tag2);
+bool etagIsStrongEqual(const ETag &tag1, const ETag &tag2);
 /// whether etags are weak-equal
-SQUIDCEXTERN bool etagIsWeakEqual(const ETag &tag1, const ETag &tag2);
+bool etagIsWeakEqual(const ETag &tag1, const ETag &tag2);
 
 #endif /* _SQUIDETAG_H */
@@ -31,9 +31,11 @@
  */
 
 #include "squid.h"
+#include "AsyncEngine.h"
 #include "Debug.h"
 #include "EventLoop.h"
 #include "base/AsyncCallQueue.h"
+#include "SquidTime.h"
 
 EventLoop::EventLoop() : errcount(0), last_loop(false), timeService(NULL),
         primaryEngine(NULL)
@@ -32,11 +32,12 @@
 #define SQUID_EVENTLOOP_H
 
 #include "Array.h"
-#include "AsyncEngine.h"
-#include "SquidTime.h"
 
 #define EVENT_LOOP_TIMEOUT	1000 /* 1s timeout */
 
+class AsyncEngine;
+class TimeEngine;
+
 /** An event loop. An event loop is the core inner loop of squid.
  * The event loop can be run until exit, or once. After it finishes control
  * returns to the caller. If desired it can be run again.
@@ -33,6 +33,8 @@
 #define SQUID_EXTERNALACL_H
 
 #include "acl/Checklist.h"
+class external_acl;
+class StoreEntry;
 
 /** \todo CLEANUP: kill this typedef. */
 typedef struct _external_acl_data external_acl_data;
@@ -91,15 +93,12 @@ class ACLExternal : public ACL
 
 MEMPROXY_CLASS_INLINE(ACLExternal);
 
-class ACLChecklist;
-class StoreEntry;
-
-extern void parse_externalAclHelper(external_acl **);
-extern void dump_externalAclHelper(StoreEntry * sentry, const char *name, const external_acl *);
-extern void free_externalAclHelper(external_acl **);
+void parse_externalAclHelper(external_acl **);
+void dump_externalAclHelper(StoreEntry * sentry, const char *name, const external_acl *);
+void free_externalAclHelper(external_acl **);
 typedef void EAH(void *data, void *result);
-extern void externalAclLookup(ACLChecklist * ch, void *acl_data, EAH * handler, void *data);
-extern void externalAclInit(void);
-extern void externalAclShutdown(void);
+void externalAclLookup(ACLChecklist * ch, void *acl_data, EAH * handler, void *data);
+void externalAclInit(void);
+void externalAclShutdown(void);
 
 #endif /* SQUID_EXTERNALACL_H */
@@ -44,7 +44,10 @@
 
 #include "acl/Acl.h"
 #include "cbdata.h"
+#include "hash.h"
+#include "SquidString.h"
 
+class external_acl;
 /******************************************************************
  * ExternalACLEntryData
  * Core data that ExternalACLEntry manages.
@@ -1,7 +1,3 @@
-/*
- * $Id$
- */
-
 #include "squid.h"
 #include "base/TextException.h"
 #include "SquidTime.h"
@@ -1,7 +1,3 @@
-/*
- * $Id$
- */
-
 #ifndef SQUID_FADING_COUNTER_H
 #define SQUID_FADING_COUNTER_H
 
@@ -12,28 +12,34 @@ HelperReply::HelperReply(const char *buf, size_t len, bool urlQuoting) :
         whichServer(NULL)
 {
     // check we have something to parse
-    if (!buf || len < 1)
+    if (!buf || len < 1) {
+        // for now ensure that legacy handlers are not presented with NULL strings.
+        other_.init(1,1);
+        other_.terminate();
         return;
+    }
 
     const char *p = buf;
 
+    // optimization: do not consider parsing result code if the response is short.
+    // URL-rewriter may return relative URLs or empty response for a large portion
+    // of its replies.
     if (len >= 2) {
-        // NOTE: only increment 'p' if a result code is found.
         // some helper formats (digest auth, URL-rewriter) just send a data string
-        // we must also check for the ' ' character after the response token here
-        if (!strncmp(p,"OK ",3)) {
+        // we must also check for the ' ' character after the response token (if anything)
+        if (!strncmp(p,"OK",2) && (len == 2 || p[2] == ' ')) {
             result = HelperReply::Okay;
             p+=2;
-        } else if (!strncmp(p,"ERR ",4)) {
+        } else if (!strncmp(p,"ERR",3) && (len == 3 || p[3] == ' ')) {
             result = HelperReply::Error;
             p+=3;
-        } else if (!strncmp(p,"BH ",3)) {
+        } else if (!strncmp(p,"BH",2) && (len == 2 || p[2] == ' ')) {
             result = HelperReply::BrokenHelper;
             p+=2;
         } else if (!strncmp(p,"TT ",3)) {
             // NTLM challenge token
             result = HelperReply::TT;
-            p+=2;
+            p+=3;
             // followed by an auth token
             char *token = strwordtok(NULL, &p);
             authToken.init();
@@ -59,14 +65,14 @@ HelperReply::HelperReply(const char *buf, size_t len, bool urlQuoting) :
         } else if (!strncmp(p,"NA ",3)) {
             // NTLM fail-closed ERR response
             result = HelperReply::NA;
-            p+=2;
+            p+=3;
         }
 
-        for(;xisspace(*p);p++); // skip whitespace
+        for (; xisspace(*p); ++p); // skip whitespace
     }
 
     const mb_size_t blobSize = (buf+len-p);
-    other_.init(blobSize, blobSize+1);
+    other_.init(blobSize+1, blobSize+1);
     other_.append(p, blobSize); // remainders of the line.
 
     // NULL-terminate so the helper callback handlers do not buffer-overrun
@@ -119,8 +125,7 @@ std::ostream &
 operator <<(std::ostream &os, const HelperReply &r)
 {
     os << "{result=";
-    switch(r.result)
-    {
+    switch(r.result) {
     case HelperReply::Okay:
         os << "OK";
         break;
@@ -18,15 +18,13 @@ class helper_stateful_server;
 class HelperReply
 {
 private:
-    // implicit creation and copy are prohibited explicitly
-    HelperReply();
+    // copy are prohibited for now
     HelperReply(const HelperReply &r);
     HelperReply &operator =(const HelperReply &r);
 
 public:
     // create/parse details from the msg buffer provided
     HelperReply(const char *buf, size_t len, bool urlQuoting = false);
-    ~HelperReply() {}
 
     const MemBuf &other() const { return other_; }
 
@@ -34,6 +34,7 @@
 
 #include "comm/Connection.h"
 #include "hier_code.h"
+#include "HttpStatusCode.h"
 #include "lookup_t.h"
 #include "rfc2181.h"
 #include "PingData.h"
@@ -1,7 +1,3 @@
-/*
- * $Id$
- */
-
 #ifndef SQUID_HTTP_CONTROL_MSG_H
 #define SQUID_HTTP_CONTROL_MSG_H
 
@@ -33,6 +33,7 @@
 #include "squid.h"
 #include "base/StringArea.h"
 #include "HttpHeader.h"
+#include "HttpHeaderFieldStat.h"
 #include "HttpHeaderStat.h"
 #include "HttpHeaderTools.h"
 #include "HttpHdrCc.h"
@@ -34,9 +34,10 @@
 
 #include "enums.h"
 #include "MemPool.h"
-#include "Packer.h"
 #include "SquidString.h"
 
+class Packer;
+
 /** Http Cache-Control header representation
  *
  * Store and parse the Cache-Control HTTP header.
@@ -181,10 +182,10 @@ MEMPROXY_CLASS_INLINE(HttpHdrCc);
 class StatHist;
 class StoreEntry;
 
-extern void httpHdrCcInitModule(void);
-extern void httpHdrCcCleanModule(void);
-extern void httpHdrCcUpdateStats(const HttpHdrCc * cc, StatHist * hist);
-extern void httpHdrCcStatDumper(StoreEntry * sentry, int idx, double val, double size, int count);
+void httpHdrCcInitModule(void);
+void httpHdrCcCleanModule(void);
+void httpHdrCcUpdateStats(const HttpHdrCc * cc, StatHist * hist);
+void httpHdrCcStatDumper(StoreEntry * sentry, int idx, double val, double size, int count);
 
 #if _USE_INLINE_
 #include "HttpHdrCc.cci"
@@ -46,15 +46,15 @@ class HttpHdrContRange
 
 /** \todo CLEANUP: Move httpHdrContRange* functions into the class methods */
 
-SQUIDCEXTERN HttpHdrContRange *httpHdrContRangeCreate(void);
-SQUIDCEXTERN HttpHdrContRange *httpHdrContRangeParseCreate(const char *crange_spec);
+HttpHdrContRange *httpHdrContRangeCreate(void);
+HttpHdrContRange *httpHdrContRangeParseCreate(const char *crange_spec);
 /** returns true if range is valid; inits HttpHdrContRange */
-SQUIDCEXTERN int httpHdrContRangeParseInit(HttpHdrContRange * crange, const char *crange_spec);
-SQUIDCEXTERN void httpHdrContRangeDestroy(HttpHdrContRange * crange);
-SQUIDCEXTERN HttpHdrContRange *httpHdrContRangeDup(const HttpHdrContRange * crange);
-SQUIDCEXTERN void httpHdrContRangePackInto(const HttpHdrContRange * crange, Packer * p);
+int httpHdrContRangeParseInit(HttpHdrContRange * crange, const char *crange_spec);
+void httpHdrContRangeDestroy(HttpHdrContRange * crange);
+HttpHdrContRange *httpHdrContRangeDup(const HttpHdrContRange * crange);
+void httpHdrContRangePackInto(const HttpHdrContRange * crange, Packer * p);
 /** inits with given spec */
-SQUIDCEXTERN void httpHdrContRangeSet(HttpHdrContRange *, HttpHdrRangeSpec, int64_t);
-SQUIDCEXTERN void httpHeaderAddContRange(HttpHeader *, HttpHdrRangeSpec, int64_t);
+void httpHdrContRangeSet(HttpHdrContRange *, HttpHdrRangeSpec, int64_t);
+void httpHeaderAddContRange(HttpHeader *, HttpHdrRangeSpec, int64_t);
 
 #endif /* SQUID_HTTPHDRCONTRANGE_H */
@@ -36,6 +36,7 @@
 #include "HttpHeaderRange.h"
 #include "client_side_request.h"
 #include "HttpReply.h"
+#include "HttpHeaderTools.h"
 #include "StrList.h"
 
 /*
@@ -37,6 +37,8 @@
 #include "squid.h"
 #include "HttpHdrSc.h"
 #include "HttpHeader.h"
+#include "HttpHeaderFieldInfo.h"
+#include "HttpHeaderFieldStat.h"
 #include "HttpHeaderStat.h"
 #include "HttpHeaderTools.h"
 #include "Store.h"
@@ -69,10 +69,10 @@ class HttpHdrSc
 MEMPROXY_CLASS_INLINE(HttpHdrSc);
 
 /* Http Surrogate Control Header Field */
-extern void httpHdrScStatDumper(StoreEntry * sentry, int idx, double val, double size, int count);
-extern void httpHdrScInitModule (void);
-extern void httpHdrScCleanModule (void);
-extern HttpHdrSc *httpHdrScParseCreate(String const &);
-extern void httpHdrScSetMaxAge(HttpHdrSc *, char const *, int);
+void httpHdrScStatDumper(StoreEntry * sentry, int idx, double val, double size, int count);
+void httpHdrScInitModule (void);
+void httpHdrScCleanModule (void);
+HttpHdrSc *httpHdrScParseCreate(String const &);
+void httpHdrScSetMaxAge(HttpHdrSc *, char const *, int);
 
 #endif /* SQUID_HTTPHDRSURROGATECONTROL_H */
@@ -37,7 +37,7 @@
 #include "HttpHdrSc.h"
 #include "StatHist.h"
 
-extern http_hdr_sc_type &operator++ (http_hdr_sc_type &aHeader);
+http_hdr_sc_type &operator++ (http_hdr_sc_type &aHeader);
 /* copies non-extant fields from new_sc to this sc */
 void
 HttpHdrScTarget::mergeWith(const HttpHdrScTarget * new_sc)
@@ -126,6 +126,6 @@ class HttpHdrScTarget
 
 MEMPROXY_CLASS_INLINE(HttpHdrScTarget);
 
-extern void httpHdrScTargetStatDumper(StoreEntry * sentry, int idx, double val, double size, int count);
+void httpHdrScTargetStatDumper(StoreEntry * sentry, int idx, double val, double size, int count);
 
 #endif /* SQUID_HTTPHDRSURROGATECONTROLTARGET_H */
@@ -36,6 +36,7 @@
 #include "HttpHdrContRange.h"
 #include "HttpHdrSc.h"
 #include "HttpHeader.h"
+#include "HttpHeaderFieldInfo.h"
 #include "HttpHeaderStat.h"
 #include "HttpHeaderTools.h"
 #include "MemBuf.h"
@@ -45,6 +46,7 @@
 #include "StatHist.h"
 #include "Store.h"
 #include "StrList.h"
+#include "SquidConfig.h"
 #include "SquidString.h"
 #include "TimeOrTag.h"
 
@@ -32,16 +32,16 @@
 #define SQUID_HTTPHEADER_H
 
 /* because we pass a spec by value */
-#include "HttpHeaderRange.h"
-/* HttpHeader holds a HttpHeaderMask */
 #include "HttpHeaderMask.h"
+#include "MemPool.h"
+#include "SquidString.h"
 
 /* class forward declarations */
-class HttpHdrContRange;
 class HttpHdrCc;
-class HttpHdrSc;
+class HttpHdrContRange;
 class HttpHdrRange;
-class String;
+class HttpHdrSc;
+class Packer;
 class StoreEntry;
 
 /* constant attributes of http header fields */
@@ -175,10 +175,14 @@ typedef enum {
 #if USE_SSL
     hoErrorDetail,
 #endif
+    hoNote,
     hoEnd
 } http_hdr_owner_type;
 
-struct _HttpHeaderFieldAttrs {
+// currently a POD
+class HttpHeaderFieldAttrs
+{
+public:
     const char *name;
     http_hdr_type id;
     field_type type;
@@ -289,10 +293,10 @@ class HttpHeader
     HttpHeaderEntry *findLastEntry(http_hdr_type id) const;
 };
 
-extern int httpHeaderParseQuotedString(const char *start, const int len, String *val);
-extern int httpHeaderHasByNameListMember(const HttpHeader * hdr, const char *name, const char *member, const char separator);
-extern void httpHeaderUpdate(HttpHeader * old, const HttpHeader * fresh, const HttpHeaderMask * denied_mask);
-extern void httpHeaderCalcMask(HttpHeaderMask * mask, http_hdr_type http_hdr_type_enums[], size_t count);
+int httpHeaderParseQuotedString(const char *start, const int len, String *val);
+int httpHeaderHasByNameListMember(const HttpHeader * hdr, const char *name, const char *member, const char separator);
+void httpHeaderUpdate(HttpHeader * old, const HttpHeader * fresh, const HttpHeaderMask * denied_mask);
+void httpHeaderCalcMask(HttpHeaderMask * mask, http_hdr_type http_hdr_type_enums[], size_t count);
 
 inline bool
 HttpHeader::chunked() const
@@ -301,7 +305,7 @@ HttpHeader::chunked() const
            hasListMember(HDR_TRANSFER_ENCODING, "chunked", ',');
 }
 
-extern void httpHeaderInitModule(void);
-extern void httpHeaderCleanModule(void);
+void httpHeaderInitModule(void);
+void httpHeaderCleanModule(void);
 
 #endif /* SQUID_HTTPHEADER_H */
@@ -0,0 +1,47 @@
+#ifndef SQUID_HTTPHEADERFIELDINFO_H_
+#define SQUID_HTTPHEADERFIELDINFO_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "SquidString.h"
+#include "HttpHeaderFieldStat.h"
+
+/// compiled version of HttpHeaderFieldAttrs plus stats. Currently a POD.
+class HttpHeaderFieldInfo
+{
+public:
+    HttpHeaderFieldInfo() : id(HDR_ACCEPT), type(ftInvalid) {}
+
+    http_hdr_type id;
+    String name;
+    field_type type;
+    HttpHeaderFieldStat stat;
+};
+
+#endif /* SQUID_HTTPHEADERFIELDINFO_H_ */
@@ -0,0 +1,45 @@
+#ifndef SQUID_HTTPHEADERFIELDSTAT_H_
+#define SQUID_HTTPHEADERFIELDSTAT_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+/// per field statistics. Currently a POD.
+class HttpHeaderFieldStat
+{
+public:
+    HttpHeaderFieldStat() : aliveCount(0), seenCount(0), parsCount(0), errCount(0), repCount(0) {}
+
+    int aliveCount;     /* created but not destroyed (count) */
+    int seenCount;      /* number of fields we've seen */
+    int parsCount;      /* number of parsing attempts */
+    int errCount;       /* number of pasring errors */
+    int repCount;       /* number of repetitons */
+};
+
+#endif /* SQUID_HTTPHEADERFIELDSTAT_H_ */
@@ -33,6 +33,6 @@
 /* big mask for http headers */
 typedef char HttpHeaderMask[12];
 
-SQUIDCEXTERN void httpHeaderMaskInit(HttpHeaderMask * mask, int value);
+void httpHeaderMaskInit(HttpHeaderMask * mask, int value);
 
 #endif /* SQUID_HTTPHEADERMASK_H */
@@ -32,10 +32,10 @@
 #ifndef SQUID_HTTPHEADERRANGE_H
 #define SQUID_HTTPHEADERRANGE_H
 
-#include "MemPool.h"
-#include "Range.h"
 #include "Array.h"
+#include "MemPool.h"
 #include "Packer.h"
+#include "Range.h"
 #include "SquidString.h"
 
 class HttpReply;
@@ -31,18 +31,22 @@
  */
 
 #include "squid.h"
+#include "globals.h"
 #include "acl/FilledChecklist.h"
 #include "acl/Gadgets.h"
 #include "client_side_request.h"
 #include "client_side.h"
 #include "comm/Connection.h"
 #include "compat/strtoll.h"
+#include "ConfigParser.h"
 #include "fde.h"
 #include "HttpHdrContRange.h"
 #include "HttpHeader.h"
+#include "HttpHeaderFieldInfo.h"
 #include "HttpHeaderTools.h"
 #include "HttpRequest.h"
 #include "MemBuf.h"
+#include "SquidConfig.h"
 #include "Store.h"
 #include "StrList.h"
 
@@ -325,7 +329,7 @@ httpHdrMangle(HttpHeaderEntry * e, HttpRequest * request, int req_or_rep)
     if (!hms)
         return 1;
 
-    const header_mangler *hm = hms->find(*e);
+    const headerMangler *hm = hms->find(*e);
 
     /* mangler or checklist went away. default allow */
     if (!hm || !hm->access_list) {
@@ -369,15 +373,15 @@ httpHdrMangleList(HttpHeader * l, HttpRequest * request, int req_or_rep)
 }
 
 static
-void header_mangler_clean(header_mangler &m)
+void header_mangler_clean(headerMangler &m)
 {
     aclDestroyAccessList(&m.access_list);
     safe_free(m.replacement);
 }
 
 static
 void header_mangler_dump_access(StoreEntry * entry, const char *option,
-                                const header_mangler &m, const char *name)
+                                const headerMangler &m, const char *name)
 {
     if (m.access_list != NULL) {
         storeAppendPrintf(entry, "%s ", option);
@@ -387,7 +391,7 @@ void header_mangler_dump_access(StoreEntry * entry, const char *option,
 
 static
 void header_mangler_dump_replacement(StoreEntry * entry, const char *option,
-                                     const header_mangler &m, const char *name)
+                                     const headerMangler &m, const char *name)
 {
     if (m.replacement)
         storeAppendPrintf(entry, "%s %s %s\n", option, name, m.replacement);
@@ -443,7 +447,7 @@ HeaderManglers::dumpReplacement(StoreEntry * entry, const char *name) const
     header_mangler_dump_replacement(entry, name, all, "All");
 }
 
-header_mangler *
+headerMangler *
 HeaderManglers::track(const char *name)
 {
     int id = httpHeaderIdByNameDef(name, strlen(name));
@@ -455,7 +459,7 @@ HeaderManglers::track(const char *name)
             id = HDR_OTHER;
     }
 
-    header_mangler *m = NULL;
+    headerMangler *m = NULL;
     if (id == HDR_ENUM_END) {
         m = &all;
     } else if (id == HDR_BAD_HDR) {
@@ -473,13 +477,13 @@ HeaderManglers::setReplacement(const char *name, const char *value)
 {
     // for backword compatibility, we allow replacements to be configured
     // for headers w/o access rules, but such replacements are ignored
-    header_mangler *m = track(name);
+    headerMangler *m = track(name);
 
     safe_free(m->replacement); // overwrite old value if any
     m->replacement = xstrdup(value);
 }
 
-const header_mangler *
+const headerMangler *
 HeaderManglers::find(const HttpHeaderEntry &e) const
 {
     // a known header with a configured ACL list
@@ -15,30 +15,37 @@
 #include <string>
 #endif
 
+class acl_access;
+class ACLList;
 class HeaderWithAcl;
+class HttpHeader;
+class HttpHeaderFieldInfo;
+class HttpRequest;
+class StoreEntry;
+class String;
+
 typedef std::list<HeaderWithAcl> HeaderWithAclList;
 
-class acl_access;
-struct _header_mangler {
+// Currently a POD
+class headerMangler
+{
+public:
     acl_access *access_list;
     char *replacement;
 };
-typedef struct _header_mangler header_mangler;
-
-class StoreEntry;
 
-/// A collection of header_mangler objects for a given message kind.
+/// A collection of headerMangler objects for a given message kind.
 class HeaderManglers
 {
 public:
     HeaderManglers();
     ~HeaderManglers();
 
     /// returns a header mangler for field e or nil if none was specified
-    const header_mangler *find(const HttpHeaderEntry &e) const;
+    const headerMangler *find(const HttpHeaderEntry &e) const;
 
     /// returns a mangler for the named header (known or custom)
-    header_mangler *track(const char *name);
+    headerMangler *track(const char *name);
 
     /// updates mangler for the named header with a replacement value
     void setReplacement(const char *name, const char *replacementValue);
@@ -50,24 +57,23 @@ class HeaderManglers
 
 private:
     /// a name:mangler map; optimize: use unordered map or some such
-    typedef std::map<std::string, header_mangler> ManglersByName;
+    typedef std::map<std::string, headerMangler> ManglersByName;
 
     /// one mangler for each known header
-    header_mangler known[HDR_ENUM_END];
+    headerMangler known[HDR_ENUM_END];
 
     /// one mangler for each custom header
     ManglersByName custom;
 
     /// configured if some mangling ACL applies to all header names
-    header_mangler all;
+    headerMangler all;
 
 private:
     /* not implemented */
     HeaderManglers(const HeaderManglers &);
     HeaderManglers &operator =(const HeaderManglers &);
 };
 
-class ACLList;
 class HeaderWithAcl
 {
 public:
@@ -92,24 +98,19 @@ class HeaderWithAcl
     bool quoted;
 };
 
-extern int httpHeaderParseOffset(const char *start, int64_t * off);
-
-class HttpHeaderFieldInfo;
-class String;
-class HttpHeader;
-class HttpRequest;
+int httpHeaderParseOffset(const char *start, int64_t * off);
 
-extern HttpHeaderFieldInfo *httpHeaderBuildFieldsInfo(const HttpHeaderFieldAttrs * attrs, int count);
-extern void httpHeaderDestroyFieldsInfo(HttpHeaderFieldInfo * info, int count);
-extern http_hdr_type httpHeaderIdByName(const char *name, size_t name_len, const HttpHeaderFieldInfo * attrs, int end);
-extern http_hdr_type httpHeaderIdByNameDef(const char *name, int name_len);
-extern const char *httpHeaderNameById(int id);
-extern int httpHeaderHasConnDir(const HttpHeader * hdr, const char *directive);
-extern int httpHeaderParseInt(const char *start, int *val);
-extern void httpHeaderPutStrf(HttpHeader * hdr, http_hdr_type id, const char *fmt,...) PRINTF_FORMAT_ARG3;
+HttpHeaderFieldInfo *httpHeaderBuildFieldsInfo(const HttpHeaderFieldAttrs * attrs, int count);
+void httpHeaderDestroyFieldsInfo(HttpHeaderFieldInfo * info, int count);
+http_hdr_type httpHeaderIdByName(const char *name, size_t name_len, const HttpHeaderFieldInfo * attrs, int end);
+http_hdr_type httpHeaderIdByNameDef(const char *name, int name_len);
+const char *httpHeaderNameById(int id);
+int httpHeaderHasConnDir(const HttpHeader * hdr, const char *directive);
+int httpHeaderParseInt(const char *start, int *val);
+void httpHeaderPutStrf(HttpHeader * hdr, http_hdr_type id, const char *fmt,...) PRINTF_FORMAT_ARG3;
 
-extern const char *getStringPrefix(const char *str, const char *end);
+const char *getStringPrefix(const char *str, const char *end);
 
-extern void httpHdrMangleList(HttpHeader *, HttpRequest *, int req_or_rep);
+void httpHdrMangleList(HttpHeader *, HttpRequest *, int req_or_rep);
 
 #endif
@@ -38,6 +38,7 @@
 #include "MemBuf.h"
 #include "mime_header.h"
 #include "profiler/Profiler.h"
+#include "SquidConfig.h"
 
 HttpMsg::HttpMsg(http_hdr_owner_type owner): header(owner),
         cache_control(NULL), hdr_sz(0), content_length(0), protocol(AnyP::PROTO_NONE),
@@ -130,7 +130,7 @@ class HttpMsg
 
 };
 
-SQUIDCEXTERN int httpMsgIsolateHeaders(const char **parse_start, int len, const char **blk_start, const char **blk_end);
+int httpMsgIsolateHeaders(const char **parse_start, int len, const char **blk_start, const char **blk_end);
 
 #define HTTPMSGUNLOCK(a) if(a){(a)->_unlock();(a)=NULL;}
 #define HTTPMSGLOCK(a) (a)->_lock()
@@ -1,8 +1,8 @@
 #include "squid.h"
 #include "Debug.h"
 #include "HttpParser.h"
-#include "structs.h"
 #include "profiler/Profiler.h"
+#include "SquidConfig.h"
 
 void
 HttpParser::clear()
@@ -79,14 +79,14 @@ class HttpParser
 
 // Legacy functions
 #define HttpParserInit(h,b,l) (h)->reset((b),(l))
-extern int HttpParserParseReqLine(HttpParser *hp);
+int HttpParserParseReqLine(HttpParser *hp);
 
 #define MSGDODEBUG 0
 #if MSGDODEBUG
-extern int HttpParserReqSz(HttpParser *);
-extern int HttpParserHdrSz(HttpParser *);
-extern const char * HttpParserHdrBuf(HttpParser *);
-extern int HttpParserRequestLen(HttpParser *hp);
+int HttpParserReqSz(HttpParser *);
+int HttpParserHdrSz(HttpParser *);
+const char * HttpParserHdrBuf(HttpParser *);
+int HttpParserRequestLen(HttpParser *hp);
 #else
 #define HttpParserReqSz(hp)     ( (hp)->req.end - (hp)->req.start + 1 )
 #define HttpParserHdrSz(hp)     ( (hp)->hdr_end - (hp)->hdr_start + 1 )
@@ -32,6 +32,7 @@
  */
 
 #include "squid.h"
+#include "acl/AclSizeLimit.h"
 #include "acl/FilledChecklist.h"
 #include "globals.h"
 #include "HttpBody.h"
@@ -41,6 +42,7 @@
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "MemBuf.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 #include "StrList.h"
@@ -426,7 +428,7 @@ HttpReply::bodySize(const HttpRequestMethod& method) const
 {
     if (sline.version.major < 1)
         return -1;
-    else if (method.id() == METHOD_HEAD)
+    else if (method.id() == Http::METHOD_HEAD)
         return 0;
     else if (sline.status == HTTP_OK)
         (void) 0;		/* common case, continue */
@@ -530,7 +532,7 @@ HttpReply::expectingBody(const HttpRequestMethod& req_method, int64_t& theSize)
 {
     bool expectBody = true;
 
-    if (req_method == METHOD_HEAD)
+    if (req_method == Http::METHOD_HEAD)
         expectBody = false;
     else if (sline.status == HTTP_NO_CONTENT)
         expectBody = false;
@@ -596,7 +598,7 @@ HttpReply::calcMaxBodySize(HttpRequest& request)
 
     ACLFilledChecklist ch(NULL, &request, NULL);
     ch.reply = HTTPMSGLOCK(this); // XXX: this lock makes method non-const
-    for (acl_size_t *l = Config.ReplyBodySize; l; l = l -> next) {
+    for (AclSizeLimit *l = Config.ReplyBodySize; l; l = l -> next) {
         /* if there is no ACL list or if the ACLs listed match use this size value */
         if (!l->aclList || ch.fastCheck(l->aclList) == ACCESS_ALLOWED) {
             debugs(58, 4, HERE << "bodySizeMax=" << bodySizeMax);
@@ -35,11 +35,11 @@
 #include "HttpRequest.h"
 #include "HttpStatusLine.h"
 
-extern void httpReplyInitModule(void);
+void httpReplyInitModule(void);
 
 #if DEAD_CODE
 /** do everything in one call: init, set, pack, clean, return MemBuf */
-extern MemBuf *httpPackedReply(HttpVersion ver, http_status status, const char *ctype, int64_t clen, time_t lmt, time_t expires);
+MemBuf *httpPackedReply(HttpVersion ver, http_status status, const char *ctype, int64_t clen, time_t lmt, time_t expires);
 #endif
 
 /* Sync changes here with HttpReply.cc */
@@ -33,6 +33,7 @@
 
 #include "squid.h"
 #include "AccessLogEntry.h"
+#include "acl/AclSizeLimit.h"
 #include "acl/FilledChecklist.h"
 #include "client_side.h"
 #include "DnsLookupDetails.h"
@@ -45,6 +46,7 @@
 #include "HttpRequest.h"
 #include "log/Config.h"
 #include "MemBuf.h"
+#include "SquidConfig.h"
 #include "Store.h"
 #include "URL.h"
 
@@ -85,7 +87,7 @@ HttpRequest::initHTTP(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProt
 void
 HttpRequest::init()
 {
-    method = METHOD_NONE;
+    method = Http::METHOD_NONE;
     protocol = AnyP::PROTO_NONE;
     urlpath = NULL;
     login[0] = '\0';
@@ -291,7 +293,7 @@ HttpRequest::sanityCheckStartLine(MemBuf *buf, const size_t hdr_len, http_status
     }
 
     /* See if the request buffer starts with a known HTTP request method. */
-    if (HttpRequestMethod(buf->content(),NULL) == METHOD_NONE) {
+    if (HttpRequestMethod(buf->content(),NULL) == Http::METHOD_NONE) {
         debugs(73, 3, "HttpRequest::sanityCheckStartLine: did not find HTTP request method");
         *error = HTTP_INVALID_HEADER;
         return false;
@@ -306,7 +308,7 @@ HttpRequest::parseFirstLine(const char *start, const char *end)
     const char *t = start + strcspn(start, w_space);
     method = HttpRequestMethod(start, t);
 
-    if (method == METHOD_NONE)
+    if (method == Http::METHOD_NONE)
         return false;
 
     start = t + strspn(t, w_space);
@@ -419,27 +421,6 @@ HttpRequest::hdrCacheInit()
     range = header.getRange();
 }
 
-/* request_flags */
-bool
-request_flags::resetTCP() const
-{
-    return reset_tcp != 0;
-}
-
-void
-request_flags::setResetTCP()
-{
-    debugs(73, 9, "request_flags::setResetTCP");
-    reset_tcp = 1;
-}
-
-void
-request_flags::clearResetTCP()
-{
-    debugs(73, 9, "request_flags::clearResetTCP");
-    reset_tcp = 0;
-}
-
 #if ICAP_CLIENT
 Adaptation::Icap::History::Pointer
 HttpRequest::icapHistory() const
@@ -492,27 +473,6 @@ HttpRequest::multipartRangeRequest() const
     return (range && range->specs.count > 1);
 }
 
-void
-request_flags::destinationIPLookupCompleted()
-{
-    destinationIPLookedUp_ = true;
-}
-
-bool
-request_flags::destinationIPLookedUp() const
-{
-    return destinationIPLookedUp_;
-}
-
-request_flags
-request_flags::cloneAdaptationImmune() const
-{
-    // At the time of writing, all flags where either safe to copy after
-    // adaptation or were not set at the time of the adaptation. If there
-    // are flags that are different, they should be cleared in the clone.
-    return *this;
-}
-
 bool
 HttpRequest::bodyNibbled() const
 {
@@ -608,44 +568,45 @@ HttpRequest::CreateFromUrlAndMethod(char * url, const HttpRequestMethod& method)
 HttpRequest *
 HttpRequest::CreateFromUrl(char * url)
 {
-    return urlParse(METHOD_GET, url, NULL);
+    return urlParse(Http::METHOD_GET, url, NULL);
 }
 
-/*
+/**
  * Are responses to this request possible cacheable ?
  * If false then no matter what the response must not be cached.
  */
 bool
-HttpRequest::cacheable() const
+HttpRequest::maybeCacheable()
 {
     // Intercepted request with Host: header which cannot be trusted.
     // Because it failed verification, or someone bypassed the security tests
     // we cannot cache the reponse for sharing between clients.
     // TODO: update cache to store for particular clients only (going to same Host: and destination IP)
-    if (!flags.hostVerified && (flags.intercepted || flags.spoof_client_ip))
+    if (!flags.hostVerified && (flags.intercepted || flags.spoofClientIp))
         return false;
 
-    if (protocol == AnyP::PROTO_HTTP)
-        return httpCachable(method);
-
-    /*
-     * The below looks questionable: what non HTTP protocols use connect,
-     * trace, put and post? RC
-     */
+    switch (protocol) {
+    case AnyP::PROTO_HTTP:
+        if (!method.respMaybeCacheable())
+            return false;
 
-    if (!method.isCacheble())
-        return false;
+        // XXX: this would seem the correct place to detect request cache-controls
+        //      no-store, private and related which block cacheability
+        break;
 
-    /*
-     * XXX POST may be cached sometimes.. ignored
-     * for now
-     */
-    if (protocol == AnyP::PROTO_GOPHER)
-        return gopherCachable(this);
+    case AnyP::PROTO_GOPHER:
+        if (!gopherCachable(this))
+            return false;
+        break;
 
-    if (protocol == AnyP::PROTO_CACHE_OBJECT)
+    case AnyP::PROTO_CACHE_OBJECT:
         return false;
 
+        //case AnyP::PROTO_FTP:
+    default:
+        break;
+    }
+
     return true;
 }
 
@@ -683,7 +644,7 @@ HttpRequest::getRangeOffsetLimit()
     ch.src_addr = client_addr;
     ch.my_addr =  my_addr;
 
-    for (acl_size_t *l = Config.rangeOffsetLimit; l; l = l -> next) {
+    for (AclSizeLimit *l = Config.rangeOffsetLimit; l; l = l -> next) {
         /* if there is no ACL list or if the ACLs listed match use this limit value */
         if (!l->aclList || ch.fastCheck(l->aclList) == ACCESS_ALLOWED) {
             debugs(58, 4, HERE << "rangeOffsetLimit=" << rangeOffsetLimit);
@@ -33,9 +33,11 @@
 
 #include "base/CbcPointer.h"
 #include "Debug.h"
+#include "err_type.h"
 #include "HierarchyLogEntry.h"
 #include "HttpMsg.h"
 #include "HttpRequestMethod.h"
+#include "RequestFlags.h"
 
 #if USE_AUTH
 #include "auth/UserRequest.h"
@@ -54,8 +56,7 @@
 class ConnStateData;
 
 /*  Http Request */
-//DEAD?: extern int httpRequestHdrAllowedByName(http_hdr_type id);
-extern void httpRequestPack(void *obj, Packer *p);
+void httpRequestPack(void *obj, Packer *p);
 
 class HttpHdrRange;
 class DnsLookupDetails;
@@ -81,8 +82,10 @@ class HttpRequest: public HttpMsg
 
     virtual HttpRequest *clone() const;
 
-    /* are responses to this request potentially cachable */
-    bool cacheable() const;
+    /// Whether response to this request is potentially cachable
+    /// \retval false  Not cacheable.
+    /// \retval true   Possibly cacheable. Response factors will determine.
+    bool maybeCacheable();
 
     bool conditional() const; ///< has at least one recognized If-* header
 
@@ -161,7 +164,7 @@ class HttpRequest: public HttpMsg
 
     char *canonical;
 
-    request_flags flags;
+    RequestFlags flags;
 
     HttpHdrRange *range;
 
@@ -1,89 +1,25 @@
-
 /*
  * DEBUG: section 73    HTTP Request
- * AUTHOR: Duane Wessels
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
 
 #include "squid.h"
 #include "HttpRequestMethod.h"
 #include "wordlist.h"
 
-const char* HttpRequestMethod::RequestMethodStr[] = {
-    "NONE",
-    "GET",
-    "POST",
-    "PUT",
-    "HEAD",
-    "CONNECT",
-    "TRACE",
-    "PURGE",
-    "OPTIONS",
-    "DELETE",
-    "PROPFIND",
-    "PROPPATCH",
-    "MKCOL",
-    "COPY",
-    "MOVE",
-    "LOCK",
-    "UNLOCK",
-    "BMOVE",
-    "BDELETE",
-    "BPROPFIND",
-    "BPROPPATCH",
-    "BCOPY",
-    "SEARCH",
-    "SUBSCRIBE",
-    "UNSUBSCRIBE",
-    "POLL",
-    "REPORT",
-    "MKACTIVITY",
-    "CHECKOUT",
-    "MERGE",
-    "ERROR"
-};
-
-static
-_method_t &operator++ (_method_t &aMethod)
+static Http::MethodType &
+operator++ (Http::MethodType &aMethod)
 {
     int tmp = (int)aMethod;
-    aMethod = (_method_t)(++tmp);
+    aMethod = (Http::MethodType)(++tmp);
     return aMethod;
 }
 
-/*
+/**
  * Construct a HttpRequestMethod from a NULL terminated string such as "GET"
  * or from a range of chars, * such as "GET" from "GETFOOBARBAZ"
  * (pass in pointer to G and pointer to F.)
  */
-HttpRequestMethod::HttpRequestMethod(char const *begin, char const *end) : theMethod (METHOD_NONE)
+HttpRequestMethod::HttpRequestMethod(char const *begin, char const *end) : theMethod (Http::METHOD_NONE)
 {
     if (begin == NULL)
         return;
@@ -106,137 +42,190 @@ HttpRequestMethod::HttpRequestMethod(char const *begin, char const *end) : theMe
         end = begin + strcspn(begin, w_space);
 
     if (end == begin) {
-        theMethod = METHOD_NONE;
+        theMethod = Http::METHOD_NONE;
         return;
     }
 
-    for (++theMethod; theMethod < METHOD_ENUM_END; ++theMethod) {
-        if (0 == strncasecmp(begin, RequestMethodStr[theMethod], end-begin)) {
+    for (++theMethod; theMethod < Http::METHOD_ENUM_END; ++theMethod) {
+        if (0 == strncasecmp(begin, Http::MethodType_str[theMethod], end-begin)) {
             return;
         }
     }
 
     // if method not found and method string is not null then it is other method
-    theMethod = METHOD_OTHER;
+    theMethod = Http::METHOD_OTHER;
     theImage.limitInit(begin,end-begin);
 }
 
-/** \todo AYJ: this _should_ be obsolete. Since all such methods fit nicely into METHOD_OTHER now. */
-void
-HttpRequestMethod::AddExtension(const char *mstr)
+char const*
+HttpRequestMethod::image() const
 {
-#if 0 /* obsolete now that we have METHOD_OTHER always enabled */
-    _method_t method = METHOD_NONE;
-
-    for (++method; method < METHOD_ENUM_END; ++method) {
-        if (0 == strcmp(mstr, RequestMethodStr[method])) {
-            debugs(23, 2, "Extension method '" << mstr << "' already exists");
-            return;
+    if (Http::METHOD_OTHER != theMethod) {
+        return Http::MethodType_str[theMethod];
+    } else {
+        if (theImage.size()>0) {
+            return theImage.termedBuf();
+        } else {
+            return "METHOD_OTHER";
         }
+    }
+}
 
-        if (0 != strncmp("%EXT", RequestMethodStr[method], 4))
-            continue;
+bool
+HttpRequestMethod::isHttpSafe() const
+{
+    // Only a few methods are defined as safe. All others are "unsafe"
 
-        /* Don't free statically allocated "%EXTnn" string */
-        RequestMethodStr[method] = xstrdup(mstr);
+    // NOTE:
+    // All known RFCs which register methods are listed in comments.
+    // if there is one not listed which defines methods, it needs
+    // checking and adding. If only to say it is known to define none.
 
-        debugs(23, DBG_IMPORTANT, "Extension method '" << mstr << "' added, enum=" << method);
+    switch (theMethod) {
+        // RFC 2068 - none
 
-        return;
-    }
+        // RFC 2616 section 9.1.1
+    case Http::METHOD_GET:
+    case Http::METHOD_HEAD:
+    case Http::METHOD_OPTIONS:
 
-    debugs(23, DBG_IMPORTANT, "WARNING: Could not add new extension method '" << mstr << "' due to lack of array space");
-#endif
-}
+        // RFC 3253 section 3.6
+    case Http::METHOD_REPORT:
 
-void
-HttpRequestMethod::Configure(SquidConfig &cfg)
-{
-#if 0 /* extension methods obsolete now that we have METHOD_OTHER always enabled */
-    wordlist *w = cfg.ext_methods;
+        // RFC 3648 - none
+        // RFC 3744 - none
+        // RFC 4437 - none
+        // RFC 4791 - none
 
-    while (w) {
-        char *s;
+        // RFC 4918 section 9.1
+    case Http::METHOD_PROPFIND:
 
-        for (s = w->key; *s; ++s)
-            *s = xtoupper(*s);
+        // RFC 5323 section 2
+    case Http::METHOD_SEARCH:
 
-        AddExtension(w->key);
+        // RFC 5789 - none
+        // RFC 5842 - none
 
-        w = w->next;
-    }
-#endif
-}
+        return true;
 
-char const*
-HttpRequestMethod::image() const
-{
-    if (METHOD_OTHER != theMethod) {
-        return RequestMethodStr[theMethod];
-    } else {
-        if (theImage.size()>0) {
-            return theImage.termedBuf();
-        } else {
-            return "METHOD_OTHER";
-        }
+    default:
+        return false;
     }
 }
 
 bool
-HttpRequestMethod::isCacheble() const
+HttpRequestMethod::isIdempotent() const
 {
-    // TODO: optimize the lookup with a precomputed flags array
-    // XXX: the list seems wrong; e.g., Is METHOD_DELETE really cachable?
-    // see also http.cc::httpCachable()
+    // Only a few methods are defined as idempotent.
 
-    if (theMethod == METHOD_CONNECT)
-        return false;
-
-    if (theMethod == METHOD_TRACE)
-        return false;
+    // NOTE:
+    // All known RFCs which register methods are listed in comments.
+    // if there is one not listed which defines methods, it needs
+    // checking and adding. If only to say it is known to define none.
 
-    if (theMethod == METHOD_PUT)
-        return false;
+    switch (theMethod) {
+        // RFC 2068 - TODO check LINK/UNLINK definition
+
+        // RFC 2616 section 9.1.2
+    case Http::METHOD_GET:
+    case Http::METHOD_HEAD:
+    case Http::METHOD_PUT:
+    case Http::METHOD_DELETE:
+    case Http::METHOD_OPTIONS:
+    case Http::METHOD_TRACE:
+
+        // RFC 3253 - TODO check
+        // RFC 3648 - TODO check
+        // RFC 3744 - TODO check
+        // RFC 4437 - TODO check
+        // RFC 4791 - TODO check
+
+        // RFC 4918 section 9
+    case Http::METHOD_PROPFIND:
+    case Http::METHOD_PROPPATCH:
+    case Http::METHOD_MKCOL:
+    case Http::METHOD_COPY:
+    case Http::METHOD_MOVE:
+    case Http::METHOD_UNLOCK:
+
+        // RFC 5323 - TODO check
+        // RFC 5789 - TODO check
+        // RFC 5842 - TODO check
 
-    if (theMethod == METHOD_POST)
-        return false;
+        return true;
 
-    if (theMethod == METHOD_OTHER)
+    default:
         return false;
-
-    return true;
+    }
 }
 
 bool
-HttpRequestMethod::purgesOthers() const
+HttpRequestMethod::respMaybeCacheable() const
 {
-    // TODO: optimize the lookup with a precomputed flags array
-
+    // Only a few methods are defined as cacheable.
+    // All other methods from the below RFC are "MUST NOT cache"
     switch (theMethod) {
-        /* common sense suggests purging is not required? */
-    case METHOD_GET:     // XXX: but we do purge HEAD on successful GET
-    case METHOD_HEAD:
-    case METHOD_NONE:
-    case METHOD_CONNECT:
-    case METHOD_TRACE:
-    case METHOD_OPTIONS:
-    case METHOD_PROPFIND:
-    case METHOD_BPROPFIND:
-    case METHOD_COPY:
-    case METHOD_BCOPY:
-    case METHOD_LOCK:
-    case METHOD_UNLOCK:
-    case METHOD_SEARCH:
+        // RFC 2616 section 9
+    case Http::METHOD_GET:
+    case Http::METHOD_HEAD:
+        return true;
+#if WHEN_POST_CACHE_SUPPORTED
+    case Http::METHOD_POST: // Special case.
+        // RFC 2616 specifies POST as possibly cacheable
+        // However, Squid does not implement the required checks yet
+        return true;
+#endif
+
+        // RFC 4918 section 9
+#if WHEN_PROPFIND_CACHE_SUPPORTED
+    case Http::METHOD_PROPFIND: // Special case.
+        // RFC 4918 specifies PROPFIND as possibly cacheable
+        // However, Squid does not implement the required checks yet
+        return true;
+#endif
+
+        // RFC 5323 section 2 - defines no cacheable methods
+
+        // RFC 3253
+#if WHEN_CC_NOCACHE_DOES_REVALIDATES_IS_CONFIRMED
+    case Http::METHOD_CHECKOUT:
+    case Http::METHOD_CHECKIN:
+    case Http::METHOD_UNCHECKOUT:
+    case Http::METHOD_MKWORKSPACE:
+    case Http::METHOD_VERSION_CONTROL:
+    case Http::METHOD_UPDATE:
+    case Http::METHOD_LABEL:
+    case Http::METHOD_MERGE:
+    case Http::METHOD_BASELINE_CONTROL:
+    case Http::METHOD_MKACTIVITY:
+        // RFC 3253 defines these methods using "MUST include Cache-Control: no-cache".
+        //
+        // XXX: follow RFC 2616 definition of "no-cache" meaning "MAY cache, always revalidate"
+        // XXX: or treat as unregistered/undefined methods ??
+        // However, Squid may not implement the required revalidation checks yet
+        return ??;
+#endif
+
+        // Special Squid method tokens are not cacheable.
+        // RFC 2616 defines all unregistered or unspecified methods as non-cacheable
+        // until such time as an RFC defines them cacheable.
+    default:
         return false;
+    }
+}
 
-        /* purging mandated by RFC 2616 */
-    case METHOD_POST:
-    case METHOD_PUT:
-    case METHOD_DELETE:
+bool
+HttpRequestMethod::shouldInvalidate() const
+{
+    switch (theMethod) {
+        /* RFC 2616 section 13.10 - "MUST invalidate" */
+    case Http::METHOD_POST:
+    case Http::METHOD_PUT:
+    case Http::METHOD_DELETE:
         return true;
 
-        /* purging suggested by common sense */
-    case METHOD_PURGE:
+        /* Squid extension to force invalidation */
+    case Http::METHOD_PURGE:
         return true;
 
         /*
@@ -245,10 +234,37 @@ HttpRequestMethod::purgesOthers() const
          * understand SHOULD invalidate any entities referred to by the
          * Request-URI.
          */
-    case METHOD_OTHER:
-    default:
+    case Http::METHOD_OTHER:
         return true;
+
+    default:
+        // Methods which are known but not required to invalidate.
+        return false;
     }
+}
+
+bool
+HttpRequestMethod::purgesOthers() const
+{
+    if (shouldInvalidate())
+        return true;
+
+    switch (theMethod) {
+        /* common sense suggests purging is not required? */
+    case Http::METHOD_GET:     // XXX: but we do purge HEAD on successful GET
+    case Http::METHOD_HEAD:
+    case Http::METHOD_NONE:
+    case Http::METHOD_CONNECT:
+    case Http::METHOD_TRACE:
+    case Http::METHOD_OPTIONS:
+    case Http::METHOD_PROPFIND:
+    case Http::METHOD_COPY:
+    case Http::METHOD_LOCK:
+    case Http::METHOD_UNLOCK:
+    case Http::METHOD_SEARCH:
+        return false;
 
-    return true; // not reached, but just in case
+    default:
+        return true;
+    }
 }
@@ -1,93 +1,29 @@
-/*
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- */
-
 #ifndef SQUID_HTTPREQUESTMETHOD_H
 #define SQUID_HTTPREQUESTMETHOD_H
 
+#include "http/MethodType.h"
+#include "SquidString.h"
 #include "SquidString.h"
-#include "structs.h"
 
-#include <iosfwd>
+class SquidConfig;
 
-enum _method_t {
-    METHOD_NONE,		/* 000 */
-    METHOD_GET,			/* 001 */
-    METHOD_POST,		/* 010 */
-    METHOD_PUT,			/* 011 */
-    METHOD_HEAD,		/* 100 */
-    METHOD_CONNECT,		/* 101 */
-    METHOD_TRACE,		/* 110 */
-    METHOD_PURGE,		/* 111 */
-    METHOD_OPTIONS,
-    METHOD_DELETE,		/* RFC2616 section 9.7 */
-    METHOD_PROPFIND,
-    METHOD_PROPPATCH,
-    METHOD_MKCOL,
-    METHOD_COPY,
-    METHOD_MOVE,
-    METHOD_LOCK,
-    METHOD_UNLOCK,
-    METHOD_BMOVE,
-    METHOD_BDELETE,
-    METHOD_BPROPFIND,
-    METHOD_BPROPPATCH,
-    METHOD_BCOPY,
-    METHOD_SEARCH,
-    METHOD_SUBSCRIBE,
-    METHOD_UNSUBSCRIBE,
-    METHOD_POLL,
-    METHOD_REPORT,
-    METHOD_MKACTIVITY,
-    METHOD_CHECKOUT,
-    METHOD_MERGE,
-    METHOD_OTHER,
-    METHOD_ENUM_END  // MUST be last, (yuck) this is used as an array-initialization index constant!
-};
+#include <iosfwd>
 
 /**
  * This class represents an HTTP Request METHOD
  * - i.e. PUT, POST, GET etc.
  * It has a runtime extension facility to allow it to
  * efficiently support new methods
- \ingroup POD
  */
 class HttpRequestMethod
 {
 
 public:
-    static void AddExtension(const char *methodString);
-    static void Configure(SquidConfig &Config);
+//    static void Configure(SquidConfig &Config);
 
-    HttpRequestMethod() : theMethod(METHOD_NONE), theImage() {}
+    HttpRequestMethod() : theMethod(Http::METHOD_NONE), theImage() {}
 
-    HttpRequestMethod(_method_t const aMethod) : theMethod(aMethod), theImage() {}
+    HttpRequestMethod(Http::MethodType const aMethod) : theMethod(aMethod), theImage() {}
 
     /**
      \param begin    string to convert to request method.
@@ -103,19 +39,19 @@ class HttpRequestMethod
         return *this;
     }
 
-    HttpRequestMethod & operator = (_method_t const aMethod) {
+    HttpRequestMethod & operator = (Http::MethodType const aMethod) {
         theMethod = aMethod;
         theImage.clean();
         return *this;
     }
 
-    bool operator == (_method_t const & aMethod) const { return theMethod == aMethod; }
+    bool operator == (Http::MethodType const & aMethod) const { return theMethod == aMethod; }
     bool operator == (HttpRequestMethod const & aMethod) const {
         return theMethod == aMethod.theMethod &&
-               (theMethod != METHOD_OTHER || theImage == aMethod.theImage);
+               (theMethod != Http::METHOD_OTHER || theImage == aMethod.theImage);
     }
 
-    bool operator != (_method_t const & aMethod) const { return theMethod != aMethod; }
+    bool operator != (Http::MethodType const & aMethod) const { return theMethod != aMethod; }
     bool operator != (HttpRequestMethod const & aMethod) const {
         return !operator==(aMethod);
     }
@@ -124,30 +60,62 @@ class HttpRequestMethod
     HttpRequestMethod& operator++() {
         // TODO: when this operator is used in more than one place,
         // replace it with HttpRequestMethods::Iterator API
-        // XXX: this interface can create METHOD_OTHER without an image
-        assert(theMethod < METHOD_ENUM_END);
-        theMethod = (_method_t)(1 + (int)theMethod);
+        // XXX: this interface can create Http::METHOD_OTHER without an image
+        assert(theMethod < Http::METHOD_ENUM_END);
+        theMethod = (Http::MethodType)(1 + (int)theMethod);
         return *this;
     }
 
     /** Get an ID representation of the method.
-     \retval METHOD_NONE   the method is unset
-     \retval METHOD_OTHER  the method is not recognized and has no unique ID
-     \retval *             the method is on of the recognized HTTP methods.
+     * \retval Http::METHOD_NONE   the method is unset
+     * \retval Http::METHOD_OTHER  the method is not recognized and has no unique ID
+     * \retval *                   the method is on of the recognized HTTP methods.
      */
-    _method_t id() const { return theMethod; }
+    Http::MethodType id() const { return theMethod; }
 
     /** Get a char string representation of the method. */
     char const * image() const;
 
-    bool isCacheble() const;
+    /// Whether this method is defined as a "safe" in HTTP/1.1
+    /// see RFC 2616 section 9.1.1
+    bool isHttpSafe() const;
+
+    /// Whether this method is defined as "idempotent" in HTTP/1.1
+    /// see RFC 2616 section 9.1.2
+    bool isIdempotent() const;
+
+    /** Whether responses to this method MAY be cached.
+     * \retval false  Not cacheable.
+     * \retval true   Possibly cacheable. Other details will determine.
+     */
+    bool respMaybeCacheable() const;
+
+    /** Whether this method SHOULD (or MUST) invalidate existing cached entries.
+     * Invalidation is always determined by the response
+     *
+     * RFC 2616 defines invalidate as either immediate purge
+     * or delayed explicit revalidate all stored copies on next use.
+     *
+     * \retval true   SHOULD invalidate. Response details can raise this to a MUST.
+     * \retval false  Other details will determine. Method is not a factor.
+     */
+    bool shouldInvalidate() const;
+
+    /* Whether this method invalidates existing cached entries.
+     * Kept for backward-compatibility. This is the old 2.x-3.2 invalidation behaviour.
+     *
+     * NOTE:
+     *    purgesOthers differs from shouldInvalidate() in that purgesOthers() returns
+     *    true on any methods the MAY invalidate (Squid opts to do so).
+     *    shouldInvalidate() only returns true on methods which SHOULD invalidate.
+     */
     bool purgesOthers() const;
 
 private:
     static const char *RequestMethodStr[];
 
-    _method_t theMethod; ///< Method type
-    String theImage;     ///< Used for store METHOD_OTHER only
+    Http::MethodType theMethod; ///< Method type
+    String theImage;     ///< Used for storing the Http::METHOD_OTHER only. A copy of the parsed method text.
 };
 
 inline std::ostream &
@@ -158,7 +126,7 @@ operator << (std::ostream &os, HttpRequestMethod const &method)
 }
 
 inline const char*
-RequestMethodStr(const _method_t m)
+RequestMethodStr(const Http::MethodType m)
 {
     return HttpRequestMethod(m).image();
 }
@@ -0,0 +1,53 @@
+#ifndef SQUID_HTTPSTATEFLAGS_H_
+#define SQUID_HTTPSTATEFLAGS_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+// POD
+class HttpStateFlags
+{
+public:
+    bool proxying:1;
+    bool keepalive:1;
+    bool only_if_cached:1;
+    bool handling1xx:1; ///< we are ignoring or forwarding 1xx response
+    bool headers_parsed:1;
+    unsigned int front_end_https:2; //XXX: huh?
+    bool originpeer:1;
+    bool keepalive_broken:1;
+    bool abuse_detected:1;
+    bool request_sent:1;
+    bool do_next_read:1;
+    bool consume_body_data:1; //XXX: seems unused
+    bool chunked:1; ///< reading a chunked response; TODO: rename
+    bool chunked_request:1; ///< writing a chunked request
+    bool sentLastChunk:1; ///< do not try to write last-chunk again
+};
+
+#endif /* SQUID_HTTPSTATEFLAGS_H_ */
@@ -62,19 +62,19 @@ class HttpStatusLine
 };
 
 /* init/clean */
-SQUIDCEXTERN void httpStatusLineInit(HttpStatusLine * sline);
-SQUIDCEXTERN void httpStatusLineClean(HttpStatusLine * sline);
+void httpStatusLineInit(HttpStatusLine * sline);
+void httpStatusLineClean(HttpStatusLine * sline);
 /* set/get values */
-SQUIDCEXTERN void httpStatusLineSet(HttpStatusLine * sline, HttpVersion version,
-                                    http_status status, const char *reason);
-SQUIDCEXTERN const char *httpStatusLineReason(const HttpStatusLine * sline);
+void httpStatusLineSet(HttpStatusLine * sline, HttpVersion version,
+                       http_status status, const char *reason);
+const char *httpStatusLineReason(const HttpStatusLine * sline);
 /* parse/pack */
 /* parse a 0-terminating buffer and fill internal structires; returns true on success */
-SQUIDCEXTERN int httpStatusLineParse(HttpStatusLine * sline, const String &protoPrefix,
-                                     const char *start, const char *end);
+int httpStatusLineParse(HttpStatusLine * sline, const String &protoPrefix,
+                        const char *start, const char *end);
 /* pack fields using Packer */
-SQUIDCEXTERN void httpStatusLinePackInto(const HttpStatusLine * sline, Packer * p);
+void httpStatusLinePackInto(const HttpStatusLine * sline, Packer * p);
 
-SQUIDCEXTERN const char *httpStatusString(http_status status);
+const char *httpStatusString(http_status status);
 
 #endif /* SQUID_HTTPSTATUSLINE_H */
@@ -76,6 +76,7 @@ struct _icp_common_t {
     icp_opcode getOpCode() const;
 #endif
 };
+typedef struct _icp_common_t icp_common_t;
 
 #ifdef __cplusplus
 
@@ -131,51 +132,51 @@ extern Comm::ConnectionPointer icpOutgoingConn;
 extern Ip::Address theIcpPublicHostID;
 
 /// \ingroup ServerProtocolICPAPI
-extern HttpRequest* icpGetRequest(char *url, int reqnum, int fd, Ip::Address &from);
+HttpRequest* icpGetRequest(char *url, int reqnum, int fd, Ip::Address &from);
 
 /// \ingroup ServerProtocolICPAPI
-extern bool icpAccessAllowed(Ip::Address &from, HttpRequest * icp_request);
+bool icpAccessAllowed(Ip::Address &from, HttpRequest * icp_request);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN void icpCreateAndSend(icp_opcode, int flags, char const *url, int reqnum, int pad, int fd, const Ip::Address &from);
+void icpCreateAndSend(icp_opcode, int flags, char const *url, int reqnum, int pad, int fd, const Ip::Address &from);
 
 /// \ingroup ServerProtocolICPAPI
-extern icp_opcode icpGetCommonOpcode();
+icp_opcode icpGetCommonOpcode();
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN int icpUdpSend(int, const Ip::Address &, icp_common_t *, log_type, int);
+int icpUdpSend(int, const Ip::Address &, icp_common_t *, log_type, int);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN log_type icpLogFromICPCode(icp_opcode opcode);
+log_type icpLogFromICPCode(icp_opcode opcode);
 
 /// \ingroup ServerProtocolICPAPI
 void icpDenyAccess(Ip::Address &from, char *url, int reqnum, int fd);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN PF icpHandleUdp;
+PF icpHandleUdp;
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN PF icpUdpSendQueue;
+PF icpUdpSendQueue;
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN void icpHandleIcpV3(int, Ip::Address &, char *, int);
+void icpHandleIcpV3(int, Ip::Address &, char *, int);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN int icpCheckUdpHit(StoreEntry *, HttpRequest * request);
+int icpCheckUdpHit(StoreEntry *, HttpRequest * request);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN void icpOpenPorts(void);
+void icpOpenPorts(void);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN void icpConnectionShutdown(void);
+void icpConnectionShutdown(void);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN void icpClosePorts(void);
+void icpClosePorts(void);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN int icpSetCacheKey(const cache_key * key);
+int icpSetCacheKey(const cache_key * key);
 
 /// \ingroup ServerProtocolICPAPI
-SQUIDCEXTERN const cache_key *icpGetCacheKey(const char *url, int reqnum);
+const cache_key *icpGetCacheKey(const char *url, int reqnum);
 
 #endif /* SQUID_ICP_H */
@@ -1,6 +1,6 @@
+#ifndef SQUID_IOSTATS_H_
+#define SQUID_IOSTATS_H_
 /*
- * AUTHOR: Guido Serassio <serassio@squid-cache.org>
- *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
  * ----------------------------------------------------------
  *
@@ -28,20 +28,21 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
  *
  */
-#ifndef _INC_SQUID_WINDOWS_H
-#define _INC_SQUID_WINDOWS_H
 
-#if _SQUID_WINDOWS_
+/// IO statistics. Currently a POD.
+class IoStats
+{
+public:
+    static const int histSize=16;
 
-#ifndef ACL
-#define ACL WindowsACL
-#define _MSWIN_ACL_WAS_NOT_DEFINED 1
-#endif
-#include <windows.h>
-#if _MSWIN_ACL_WAS_NOT_DEFINED
-#undef ACL
-#undef _MSWIN_ACL_WAS_NOT_DEFINED
-#endif
+    struct {
+        int reads;
+        int reads_deferred;
+        int read_hist[histSize];
+        int writes;
+        int write_hist[histSize];
+    }
+    Http, Ftp, Gopher;
+};
 
-#endif /* _SQUID_WINDOWS_ */
-#endif /* _INC_SQUID_WINDOWS_H */
+#endif /* SQUID_IOSTATS_H_ */
@@ -5,6 +5,6 @@
 // TODO: add reconfiguration support
 
 class wordlist;
-extern void LoadableModulesConfigure(const wordlist *names);
+void LoadableModulesConfigure(const wordlist *names);
 
 #endif /* SQUID_LOADABLE_MODULES_H */
@@ -43,8 +43,8 @@ check_PROGRAMS+= tests/testACLMaxUserIP
 endif
 DIST_SUBDIRS += auth
 
-SUBDIRS	+= ip icmp ident log ipc mgr
-DIST_SUBDIRS += ip icmp ident log ipc mgr
+SUBDIRS	+= http ip icmp ident log ipc mgr
+DIST_SUBDIRS += http ip icmp ident log ipc mgr
 
 if ENABLE_SSL
 SUBDIRS += ssl
@@ -57,6 +57,7 @@ endif
 DIST_SUBDIRS += ssl
 
 SNMP_ALL_SOURCE = \
+	SnmpRequest.h \
 	snmp_core.h \
 	snmp_core.cc \
 	snmp_agent.h \
@@ -196,7 +197,6 @@ EXTRA_PROGRAMS = \
 	tests/testUfs \
 	tests/testCoss \
 	tests/testRock \
-	tests/testNull \
 	ufsdump
 
 ## cfgen is used when building squid
@@ -258,6 +258,7 @@ libsquid_la_SOURCES = \
 	CommCalls.h \
 	DescriptorSet.cc \
 	DescriptorSet.h \
+	SquidConfig.h \
 	SquidConfig.cc
 
 squid_SOURCES = \
@@ -268,10 +269,16 @@ squid_SOURCES = \
 	AsyncEngine.h \
 	cache_cf.h \
 	AuthReg.h \
+	YesNoNone.h \
+	YesNoNone.cc \
+	RefreshPattern.h \
 	cache_cf.cc \
 	CacheDigest.h \
 	CacheDigest.cc \
 	cache_manager.cc \
+	NeighborTypeDomainList.h \
+	CachePeerDomainList.h \
+	CachePeer.h \
 	CacheManager.h \
 	carp.h \
 	carp.cc \
@@ -334,6 +341,8 @@ squid_SOURCES = \
 	ExternalACLEntry.h \
 	FadingCounter.h \
 	FadingCounter.cc \
+	fatal.h \
+	fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.cc \
@@ -359,11 +368,13 @@ squid_SOURCES = \
 	hier_code.h \
 	HierarchyLogEntry.h \
 	$(HTCPSOURCE) \
+	HttpStateFlags.h \
 	http.cc \
 	http.h \
 	HttpStatusCode.h \
 	HttpStatusLine.cc \
 	HttpStatusLine.h \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -379,6 +390,7 @@ squid_SOURCES = \
 	HttpHeader.cc \
 	HttpHeaderMask.h \
 	HttpHeaderRange.h \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpBody.h \
@@ -390,6 +402,8 @@ squid_SOURCES = \
 	HttpParser.h \
 	HttpReply.cc \
 	HttpReply.h \
+	RequestFlags.h \
+	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequest.h \
 	HttpRequestMethod.cc \
@@ -427,6 +441,8 @@ squid_SOURCES = \
 	multicast.cc \
 	neighbors.h \
 	neighbors.cc \
+	Notes.cc \
+	Notes.h \
 	Packer.cc \
 	Packer.h \
 	Parsing.cc \
@@ -459,6 +475,7 @@ squid_SOURCES = \
 	SquidMath.h \
 	SquidMath.cc \
 	SquidNew.cc \
+	IoStats.h \
 	stat.h \
 	stat.cc \
 	StatCounters.h \
@@ -517,7 +534,6 @@ squid_SOURCES = \
 	StoreSwapLogData.h \
 	Server.cc \
 	Server.h \
-	structs.h \
 	swap_log_op.h \
 	SwapDir.cc \
 	SwapDir.h \
@@ -615,6 +631,7 @@ squid_LDADD = \
 	anyp/libanyp.la \
 	comm/libcomm.la \
 	eui/libeui.la \
+	http/libsquid-http.la \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	log/liblog.la \
 	format/libformat.la \
@@ -706,7 +723,6 @@ recv_announce_SOURCES = recv-announce.cc
 ## mem.cc wants ClientInfo.h
 ## libbase.la wants cbdata.*
 ## libbase.la wants MemBuf.*
-## structs.h wants HelperChildConfig.* (stub it)
 ufsdump_SOURCES = \
 	ClientInfo.h \
 	cbdata.h \
@@ -1105,9 +1121,13 @@ TESTS += $(check_PROGRAMS)
 tests_testHttpReply_SOURCES=\
 	cbdata.cc \
 	cbdata.h \
+	ConfigParser.cc \
 	ETag.cc \
+	fatal.h \
+	tests/stub_fatal.cc \
 	HttpBody.h \
 	HttpBody.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -1121,6 +1141,7 @@ tests_testHttpReply_SOURCES=\
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpHeaderMask.h \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpControlMsg.h \
@@ -1133,6 +1154,8 @@ tests_testHttpReply_SOURCES=\
 	HttpStatusLine.h \
 	Mem.h \
 	mem.cc \
+	RegexList.h \
+	RegexList.cc \
 	MemBuf.cc \
 	MemBuf.h \
 	mime_header.h \
@@ -1147,6 +1170,7 @@ tests_testHttpReply_SOURCES=\
 	log/access_log.h \
 	tests/stub_access_log.cc \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_debug.cc \
@@ -1202,17 +1226,21 @@ tests_testACLMaxUserIP_SOURCES= \
 	DiskIO/WriteRequest.cc \
 	ETag.cc \
 	event.cc \
+	fatal.h \
+	tests/stub_fatal.cc \
 	FileMap.h \
 	filemap.cc \
 	HelperChildConfig.h \
 	HelperChildConfig.cc \
 	HttpBody.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpHdrContRange.cc \
 	HttpHdrRange.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -1255,6 +1283,7 @@ tests_testACLMaxUserIP_SOURCES= \
 	log/access_log.h \
 	tests/stub_access_log.cc \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_debug.cc \
 	tests/stub_DelayId.cc \
@@ -1300,6 +1329,7 @@ tests_testACLMaxUserIP_SOURCES= \
 nodist_tests_testACLMaxUserIP_SOURCES= \
 	$(TESTSOURCES)
 tests_testACLMaxUserIP_LDADD= \
+	http/libsquid-http.la \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
@@ -1351,6 +1381,8 @@ tests_testCacheManager_SOURCES = \
 	debug.cc \
 	HttpParser.cc \
 	HttpParser.h \
+	RequestFlags.h \
+	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
 	Mem.h \
@@ -1367,6 +1399,9 @@ tests_testCacheManager_SOURCES = \
 	cache_manager.cc \
 	cache_cf.h \
 	AuthReg.h \
+	YesNoNone.h \
+	YesNoNone.cc \
+	RefreshPattern.h \
 	cache_cf.cc \
 	CacheDigest.h \
 	CacheDigest.cc \
@@ -1400,6 +1435,8 @@ tests_testCacheManager_SOURCES = \
 	event.cc \
 	external_acl.cc \
 	ExternalACLEntry.cc \
+	fatal.h \
+	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.cc \
@@ -1419,13 +1456,16 @@ tests_testCacheManager_SOURCES = \
 	HelperReply.cc \
 	HelperReply.h \
 	$(HTCPSOURCE) \
+	HttpStateFlags.h \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -1457,6 +1497,8 @@ tests_testCacheManager_SOURCES = \
 	mime_header.cc \
 	neighbors.h \
 	neighbors.cc \
+	Notes.cc \
+	Notes.h \
 	Packer.cc \
 	Parsing.cc \
 	pconn.cc \
@@ -1477,6 +1519,7 @@ tests_testCacheManager_SOURCES = \
 	$(SNMP_SOURCE) \
 	SquidMath.h \
 	SquidMath.cc \
+	IoStats.h \
 	stat.h \
 	stat.cc \
 	StatCounters.h \
@@ -1536,6 +1579,7 @@ nodist_tests_testCacheManager_SOURCES = \
 	$(DISKIO_GEN_SOURCE)
 # comm.cc only requires comm/libcomm.la until fdc_table is dead.
 tests_testCacheManager_LDADD = \
+	http/libsquid-http.la \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
@@ -1591,19 +1635,23 @@ tests_testDiskIO_SOURCES = \
 	ETag.cc \
 	EventLoop.cc \
 	event.cc \
+	fatal.h \
+	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	FileMap.h \
 	filemap.cc \
 	HttpBody.h \
 	HttpBody.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
 	HttpHdrContRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
 	HttpHdrRange.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpHeader.h \
@@ -1626,6 +1674,8 @@ tests_testDiskIO_SOURCES = \
 	refresh.h \
 	refresh.cc \
 	RemovalPolicy.cc \
+	RequestFlags.h \
+	RequestFlags.cc \
 	StatCounters.h \
 	StatCounters.cc \
 	StatHist.h \
@@ -1657,9 +1707,11 @@ tests_testDiskIO_SOURCES = \
 	tests/stub_access_log.cc \
 	tests/stub_acl.cc \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_client_db.cc \
+	client_side_request.h \
 	tests/stub_client_side_request.cc \
 	tests/stub_debug.cc \
 	tests/stub_errorpage.cc \
@@ -1705,6 +1757,7 @@ nodist_tests_testDiskIO_SOURCES= \
 	SquidMath.h \
 	swap_log_op.cc
 tests_testDiskIO_LDADD = \
+	http/libsquid-http.la \
 	SquidConfig.o \
 	CommCalls.o \
 	DnsLookupDetails.o \
@@ -1752,6 +1805,9 @@ tests_testEvent_SOURCES = \
 	CacheDigest.cc \
 	cache_cf.h \
 	AuthReg.h \
+	YesNoNone.h \
+	YesNoNone.cc \
+	RefreshPattern.h \
 	cache_cf.cc \
 	cache_manager.cc \
 	carp.h \
@@ -1788,6 +1844,8 @@ tests_testEvent_SOURCES = \
 	external_acl.cc \
 	ExternalACLEntry.cc \
 	FadingCounter.cc \
+	fatal.h \
+	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.cc \
@@ -1812,8 +1870,10 @@ tests_testEvent_SOURCES = \
 	HttpBody.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -1825,6 +1885,8 @@ tests_testEvent_SOURCES = \
 	HttpParser.cc \
 	HttpParser.h \
 	HttpReply.cc \
+	RequestFlags.h \
+	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
 	HttpStatusLine.cc \
@@ -1851,6 +1913,8 @@ tests_testEvent_SOURCES = \
 	multicast.cc \
 	neighbors.h \
 	neighbors.cc \
+	Notes.cc \
+	Notes.h \
 	Packer.cc \
 	Parsing.cc \
 	pconn.cc \
@@ -1873,6 +1937,7 @@ tests_testEvent_SOURCES = \
 	$(SNMP_SOURCE) \
 	SquidMath.cc \
 	SquidMath.h \
+	IoStats.h \
 	stat.h \
 	stat.cc \
 	StatCounters.h \
@@ -1937,6 +2002,7 @@ nodist_tests_testEvent_SOURCES = \
 	$(BUILT_SOURCES) \
 	$(DISKIO_GEN_SOURCE)
 tests_testEvent_LDADD = \
+	http/libsquid-http.la \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
@@ -1987,6 +2053,9 @@ tests_testEventLoop_SOURCES = \
 	cache_manager.cc \
 	cache_cf.h \
 	AuthReg.h \
+	YesNoNone.h \
+	YesNoNone.cc \
+	RefreshPattern.h \
 	cache_cf.cc \
 	carp.h \
 	carp.cc \
@@ -2022,6 +2091,8 @@ tests_testEventLoop_SOURCES = \
 	external_acl.cc \
 	ExternalACLEntry.cc \
 	FadingCounter.cc \
+	fatal.h \
+	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.cc \
@@ -2046,8 +2117,10 @@ tests_testEventLoop_SOURCES = \
 	HttpBody.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -2059,6 +2132,8 @@ tests_testEventLoop_SOURCES = \
 	HttpParser.cc \
 	HttpParser.h \
 	HttpReply.cc \
+	RequestFlags.h \
+	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
 	HttpStatusLine.cc \
@@ -2085,6 +2160,8 @@ tests_testEventLoop_SOURCES = \
 	multicast.cc \
 	neighbors.h \
 	neighbors.cc \
+	Notes.cc \
+	Notes.h \
 	Packer.cc \
 	Parsing.cc \
 	pconn.cc \
@@ -2105,6 +2182,7 @@ tests_testEventLoop_SOURCES = \
 	$(SNMP_SOURCE) \
 	SquidMath.h \
 	SquidMath.cc \
+	IoStats.h \
 	stat.h \
 	stat.cc \
 	StatCounters.h \
@@ -2171,6 +2249,7 @@ nodist_tests_testEventLoop_SOURCES = \
 	$(BUILT_SOURCES) \
 	$(DISKIO_GEN_SOURCE)
 tests_testEventLoop_LDADD = \
+	http/libsquid-http.la \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
@@ -2217,6 +2296,9 @@ tests_test_http_range_SOURCES = \
 	BodyPipe.cc \
 	cache_cf.h \
 	AuthReg.h \
+	YesNoNone.h \
+	YesNoNone.cc \
+	RefreshPattern.h \
 	cache_cf.cc \
 	cache_manager.cc \
 	CacheDigest.h \
@@ -2253,6 +2335,8 @@ tests_test_http_range_SOURCES = \
 	external_acl.cc \
 	ExternalACLEntry.cc \
 	FadingCounter.cc \
+	fatal.h \
+	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.cc \
@@ -2275,6 +2359,7 @@ tests_test_http_range_SOURCES = \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -2284,12 +2369,15 @@ tests_test_http_range_SOURCES = \
 	HttpHdrScTarget.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpMsg.cc \
 	HttpParser.cc \
 	HttpParser.h \
 	HttpReply.cc \
+	RequestFlags.h \
+	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
 	HttpStatusLine.cc \
@@ -2316,6 +2404,8 @@ tests_test_http_range_SOURCES = \
 	multicast.cc \
 	neighbors.h \
 	neighbors.cc \
+	Notes.cc \
+	Notes.h \
 	Packer.cc \
 	Parsing.cc \
 	peer_digest.cc \
@@ -2336,6 +2426,7 @@ tests_test_http_range_SOURCES = \
 	$(SNMP_SOURCE) \
 	SquidMath.h \
 	SquidMath.cc \
+	IoStats.h \
 	stat.h \
 	stat.cc \
 	StatCounters.h \
@@ -2399,6 +2490,7 @@ nodist_tests_test_http_range_SOURCES = \
 	$(BUILT_SOURCES) \
 	$(DISKIO_GEN_SOURCE)
 tests_test_http_range_LDADD = \
+	http/libsquid-http.la \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
@@ -2438,7 +2530,6 @@ tests_test_http_range_LDFLAGS = $(LIBADD_DL)
 tests_test_http_range_DEPENDENCIES = \
 	$(SQUID_CPPUNIT_LA)
 
-
 tests_testHttpParser_SOURCES = \
 	Debug.h \
 	HttpParser.cc \
@@ -2448,8 +2539,8 @@ tests_testHttpParser_SOURCES = \
 	Mem.h \
 	mem.cc \
 	String.cc \
-	structs.h \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_debug.cc \
@@ -2466,6 +2557,7 @@ tests_testHttpParser_SOURCES = \
 nodist_tests_testHttpParser_SOURCES = \
 	$(TESTSOURCES)
 tests_testHttpParser_LDADD= \
+	http/libsquid-http.la \
 	SquidConfig.o \
 	base/libbase.la \
 	ip/libip.la \
@@ -2483,6 +2575,8 @@ tests_testHttpRequest_SOURCES = \
 	$(ACL_REGISTRATION_SOURCES) \
 	HttpParser.cc \
 	HttpParser.h \
+	RequestFlags.h \
+	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
 	Mem.h \
@@ -2502,6 +2596,9 @@ tests_testHttpRequest_SOURCES = \
 	cache_manager.cc \
 	cache_cf.h \
 	AuthReg.h \
+	YesNoNone.h \
+	YesNoNone.cc \
+	RefreshPattern.h \
 	cache_cf.cc \
 	debug.cc \
 	CacheDigest.h \
@@ -2534,6 +2631,8 @@ tests_testHttpRequest_SOURCES = \
 	ETag.cc \
 	external_acl.cc \
 	ExternalACLEntry.cc \
+	fatal.h \
+	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.cc \
@@ -2556,8 +2655,10 @@ tests_testHttpRequest_SOURCES = \
 	HttpBody.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -2589,6 +2690,8 @@ tests_testHttpRequest_SOURCES = \
 	mime_header.cc \
 	neighbors.h \
 	neighbors.cc \
+	Notes.cc \
+	Notes.h \
 	Packer.cc \
 	Parsing.cc \
 	pconn.cc \
@@ -2609,6 +2712,7 @@ tests_testHttpRequest_SOURCES = \
 	$(SNMP_SOURCE) \
 	SquidMath.h \
 	SquidMath.cc \
+	IoStats.h \
 	stat.h \
 	stat.cc \
 	StatCounters.h \
@@ -2685,6 +2789,7 @@ tests_testHttpRequest_LDADD = \
 	comm/libcomm.la \
 	log/liblog.la \
 	format/libformat.la \
+	http/libsquid-http.la \
 	$(REPL_OBJS) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
@@ -2722,21 +2827,27 @@ tests_testStore_SOURCES= \
 	ETag.cc \
 	event.cc \
 	EventLoop.cc \
+	fatal.h \
+	tests/stub_fatal.cc \
 	FileMap.h \
 	filemap.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
 	HttpHdrContRange.cc \
 	HttpHdrRange.cc \
 	HttpHdrSc.cc \
 	HttpHdrScTarget.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
 	HttpMsg.cc \
 	HttpRequestMethod.cc \
+	RequestFlags.cc \
+	RequestFlags.h \
 	int.h \
 	int.cc \
 	SquidList.h \
@@ -2781,6 +2892,7 @@ tests_testStore_SOURCES= \
 	tests/stub_access_log.cc \
 	tests/stub_acl.cc \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_client_side_request.cc \
@@ -2837,6 +2949,7 @@ nodist_tests_testStore_SOURCES= \
 	swap_log_op.cc
 
 tests_testStore_LDADD= \
+	http/libsquid-http.la \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
@@ -2879,6 +2992,7 @@ tests_testString_SOURCES = \
 	tests/testString.cc \
 	tests/testString.h \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_debug.cc \
@@ -2942,6 +3056,8 @@ tests_testUfs_SOURCES = \
 	store_rebuild.h \
 	tests/stub_store_rebuild.cc \
 	tests/stub_store_stats.cc \
+	fatal.h \
+	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	client_db.h \
@@ -2955,6 +3071,8 @@ tests_testUfs_SOURCES = \
 	HttpStatusLine.cc \
 	int.h \
 	int.cc \
+	RequestFlags.h \
+	RequestFlags.cc \
 	SquidList.h \
 	SquidList.cc \
 	MemObject.cc \
@@ -2992,6 +3110,7 @@ tests_testUfs_SOURCES = \
 	SwapDir.cc \
 	tests/stub_acl.cc \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_helper.cc \
 	cbdata.cc \
@@ -3003,6 +3122,7 @@ tests_testUfs_SOURCES = \
 	stmem.cc \
 	mime.h \
 	tests/stub_mime.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpHeader.h \
@@ -3013,6 +3133,7 @@ tests_testUfs_SOURCES = \
 	MemBuf.cc \
 	HttpHdrContRange.cc \
 	Packer.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -3051,6 +3172,7 @@ nodist_tests_testUfs_SOURCES = \
 	SquidMath.h \
 	swap_log_op.cc
 tests_testUfs_LDADD = \
+	http/libsquid-http.la \
 	CommCalls.o \
 	DnsLookupDetails.o \
 	$(AUTH_ACL_LIBS) \
@@ -3087,6 +3209,20 @@ tests_testUfs_LDFLAGS = $(LIBADD_DL)
 tests_testUfs_DEPENDENCIES = \
 	$(SWAP_TEST_DS)
 
+check_PROGRAMS += testRefCount
+testRefCount_SOURCES= \
+	base/Lock.h \
+	base/RefCount.h \
+	tests/stub_cbdata.cc \
+	tests/stub_debug.cc \
+	tests/stub_MemBuf.cc \
+	tests/testRefCount.cc
+testRefCount_LDADD = \
+	base/libbase.la \
+	$(top_builddir)/lib/libmiscutil.la \
+	$(COMPAT_LIB) \
+	$(XTRA_LIBS)
+
 tests_testRock_SOURCES = \
 	cbdata.cc \
 	CacheDigest.h \
@@ -3098,10 +3234,13 @@ tests_testRock_SOURCES = \
 	ETag.cc \
 	EventLoop.cc \
 	event.cc \
+	fatal.h \
+	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	FileMap.h \
 	filemap.cc \
+	HttpHeaderFieldStat.h \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHdrCc.cc \
@@ -3111,6 +3250,7 @@ tests_testRock_SOURCES = \
 	HttpHdrScTarget.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpMsg.cc \
@@ -3129,6 +3269,8 @@ tests_testRock_SOURCES = \
 	Packer.cc \
 	Parsing.cc \
 	RemovalPolicy.cc \
+	RequestFlags.cc \
+	RequestFlags.h \
 	StatCounters.h \
 	StatCounters.cc \
 	StatHist.h \
@@ -3164,6 +3306,7 @@ tests_testRock_SOURCES = \
 	log/access_log.h \
 	tests/stub_access_log.cc \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	client_db.h \
@@ -3205,6 +3348,7 @@ nodist_tests_testRock_SOURCES = \
 	SquidMath.h \
 	$(TESTSOURCES)
 tests_testRock_LDADD = \
+	http/libsquid-http.la \
 	libsquid.la \
 	comm/libcomm.la \
 	anyp/libanyp.la \
@@ -3251,6 +3395,8 @@ tests_testCoss_SOURCES = \
 	store_rebuild.h \
 	tests/stub_store_rebuild.cc \
 	tests/stub_store_stats.cc \
+	fatal.h \
+	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	disk.h \
@@ -3300,6 +3446,7 @@ tests_testCoss_SOURCES = \
 	SwapDir.cc \
 	tests/stub_acl.cc \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_helper.cc \
 	cbdata.cc \
@@ -3310,6 +3457,7 @@ tests_testCoss_SOURCES = \
 	stmem.cc \
 	mime.h \
 	tests/stub_mime.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpHeader.h \
@@ -3320,6 +3468,7 @@ tests_testCoss_SOURCES = \
 	MemBuf.cc \
 	HttpHdrContRange.cc \
 	Packer.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -3393,147 +3542,6 @@ tests_testCoss_LDFLAGS = $(LIBADD_DL)
 tests_testCoss_DEPENDENCIES = \
 	$(SWAP_TEST_DS)
 
-tests_testNull_SOURCES = \
-	tests/testNull.cc \
-	tests/testMain.cc \
-	tests/testNull.h \
-	internal.h \
-	tests/stub_internal.cc \
-	store_rebuild.h \
-	tests/stub_store_rebuild.cc \
-	tests/stub_store_stats.cc \
-	fd.h \
-	fd.cc \
-	disk.h \
-	disk.cc \
-	FileMap.h \
-	filemap.cc \
-	HttpBody.h \
-	HttpBody.cc \
-	HttpReply.cc \
-	HttpStatusLine.cc \
-	int.h \
-	int.cc \
-	SquidList.h \
-	SquidList.cc \
-	MemObject.cc \
-	StoreSwapLogData.cc \
-	StoreIOState.cc \
-	StoreMeta.cc \
-	StoreMetaMD5.cc \
-	StoreMetaSTD.cc \
-	StoreMetaSTDLFS.cc \
-	StoreMetaUnpacker.cc \
-	StoreMetaURL.cc \
-	StoreMetaVary.cc \
-	StoreFileSystem.cc \
-	store_io.cc \
-	store_swapout.cc \
-	store_swapmeta.cc \
-	$(UNLINKDSOURCE) \
-	$(WIN32_SOURCE) \
-	event.cc \
-	$(DELAY_POOL_SOURCE) \
-	CacheDigest.h \
-	CacheDigest.cc \
-	ConfigParser.cc \
-	EventLoop.cc \
-	HttpMsg.cc \
-	RemovalPolicy.cc \
-	store_dir.cc \
-	repl_modules.h \
-	store.cc \
-	HttpRequestMethod.cc \
-	store_key_md5.h \
-	store_key_md5.cc \
-	Parsing.cc \
-	ConfigOption.cc \
-	SwapDir.cc \
-	tests/stub_acl.cc \
-	cache_cf.h \
-	tests/stub_cache_cf.cc \
-	tests/stub_helper.cc \
-	cbdata.cc \
-	String.cc \
-	tests/stub_comm.cc \
-	tests/stub_debug.cc \
-	tests/stub_client_side_request.cc \
-	tests/stub_http.cc \
-	mem_node.cc \
-	stmem.cc \
-	mime.h \
-	tests/stub_mime.cc \
-	HttpHeaderTools.h \
-	HttpHeaderTools.cc \
-	HttpHeader.h \
-	HttpHeader.cc \
-	Mem.h \
-	mem.cc \
-	ClientInfo.h \
-	MemBuf.cc \
-	HttpHdrContRange.cc \
-	Packer.cc \
-	HttpHdrCc.h \
-	HttpHdrCc.cc \
-	HttpHdrCc.cci \
-	HttpHdrSc.cc \
-	HttpHdrScTarget.cc \
-	url.cc \
-	StatCounters.h \
-	StatCounters.cc \
-	StatHist.h \
-	tests/stub_StatHist.cc \
-	tests/stub_errorpage.cc \
-	tests/stub_HttpRequest.cc \
-	log/access_log.h \
-	tests/stub_access_log.cc \
-	refresh.h \
-	refresh.cc \
-	tests/stub_store_client.cc \
-	tests/stub_store_stats.cc \
-	tools.h \
-	tests/stub_tools.cc \
-	tests/testStoreSupport.cc \
-	tests/testStoreSupport.h \
-	time.cc \
-	URLScheme.cc \
-	wordlist.h \
-	wordlist.cc \
-	$(DISKIO_SOURCE)
-
-nodist_tests_testNull_SOURCES = \
-	$(TESTSOURCES) \
-	$(DISKIO_GEN_SOURCE)
-tests_testNull_LDADD = \
-	$(REGEXLIB) \
-	$(AUTH_ACL_LIBS) \
-	ident/libident.la \
-	acl/libacls.la \
-	eui/libeui.la \
-	acl/libstate.la \
-	$(AUTH_LIBS) \
-	acl/libapi.la \
-	base/libbase.la \
-	libsquid.la \
-	ip/libip.la \
-	fs/libfs.la \
-	ipc/libipc.la \
-	mgr/libmgr.la \
-	$(REPL_OBJS) \
-	$(DISK_LIBS) \
-	$(DISK_OS_LIBS) \
-	acl/libapi.la \
-	$(top_builddir)/lib/libmisccontainers.la \
-	$(top_builddir)/lib/libmiscencoding.la \
-	$(top_builddir)/lib/libmiscutil.la \
-	$(SQUID_CPPUNIT_LIBS) \
-	$(SSLLIB) \
-	$(COMPAT_LIB) \
-	$(XTRA_LIBS)
-tests_testNull_LDFLAGS = $(LIBADD_DL)
-tests_testNull_DEPENDENCIES = \
-	$(SWAP_TEST_DS)
-
 ## Tests of the URL module.
 ## TODO: Trim this down once the insanity is over.
 tests_testURL_SOURCES = \
@@ -3542,6 +3550,9 @@ tests_testURL_SOURCES = \
 	BodyPipe.cc \
 	cache_cf.h \
 	AuthReg.h \
+	YesNoNone.h \
+	YesNoNone.cc \
+	RefreshPattern.h \
 	cache_cf.cc \
 	cache_manager.cc \
 	CacheDigest.h \
@@ -3577,6 +3588,8 @@ tests_testURL_SOURCES = \
 	event.cc \
 	external_acl.cc \
 	ExternalACLEntry.cc \
+	fatal.h \
+	tests/stub_fatal.cc \
 	fd.h \
 	fd.cc \
 	fde.cc \
@@ -3599,6 +3612,7 @@ tests_testURL_SOURCES = \
 	http.cc \
 	HttpBody.h \
 	HttpBody.cc \
+	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
 	HttpHdrCc.cci \
@@ -3608,12 +3622,15 @@ tests_testURL_SOURCES = \
 	HttpHdrScTarget.cc \
 	HttpHeader.h \
 	HttpHeader.cc \
+	HttpHeaderFieldInfo.h \
 	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpMsg.cc \
 	HttpParser.cc \
 	HttpParser.h \
 	HttpReply.cc \
+	RequestFlags.h \
+	RequestFlags.cc \
 	HttpRequest.cc \
 	HttpRequestMethod.cc \
 	HttpStatusLine.cc \
@@ -3640,6 +3657,8 @@ tests_testURL_SOURCES = \
 	mime_header.cc \
 	neighbors.h \
 	neighbors.cc \
+	Notes.cc \
+	Notes.h \
 	Packer.cc \
 	Parsing.cc \
 	pconn.cc \
@@ -3660,6 +3679,7 @@ tests_testURL_SOURCES = \
 	$(SNMP_SOURCE) \
 	SquidMath.h \
 	SquidMath.cc \
+	IoStats.h \
 	stat.h \
 	stat.cc \
 	StatCounters.h \
@@ -3695,8 +3715,8 @@ tests_testURL_SOURCES = \
 	StoreMetaVary.cc \
 	StoreSwapLogData.cc \
 	String.cc \
-    StrList.h \
-    StrList.cc \
+	StrList.h \
+	StrList.cc \
 	SwapDir.cc \
 	MemStore.cc \
 	tests/stub_debug.cc \
@@ -3728,6 +3748,7 @@ tests_testURL_SOURCES = \
 nodist_tests_testURL_SOURCES = \
 	$(BUILT_SOURCES)
 tests_testURL_LDADD = \
+	http/libsquid-http.la \
 	anyp/libanyp.la \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
@@ -3775,10 +3796,13 @@ tests_testConfigParser_SOURCES = \
 	MemBuf.cc \
 	String.cc \
 	ConfigParser.cc \
+	fatal.h \
+	tests/stub_fatal.cc \
 	tests/testMain.cc \
 	tests/testConfigParser.cc \
 	tests/testConfigParser.h \
 	cache_cf.h \
+	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_debug.cc \
@@ -3806,6 +3830,8 @@ tests_testConfigParser_DEPENDENCIES = \
 	
 tests_testStatHist_SOURCES = \
 	cbdata.cc \
+	fatal.h \
+	tests/stub_fatal.cc \
 	MemBuf.cc \
 	StatHist.cc \
 	StatHist.h \
@@ -3837,6 +3863,7 @@ tests_testStatHist_LDFLAGS = $(LIBADD_DL)
 tests_testStatHist_LDADD = \
 	base/libbase.la \
 	$(top_builddir)/lib/libmiscutil.la \
+	$(top_builddir)/lib/libmisccontainers.la \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
 	$(COMPAT_LIB)
@@ -62,21 +62,21 @@ class Mem
 
 extern const size_t squidSystemPageSize;
 
-extern void memClean(void);
-extern void memInitModule(void);
-extern void memCleanModule(void);
-extern void memConfigure(void);
-extern void *memAllocate(mem_type);
-extern void *memAllocString(size_t net_size, size_t * gross_size);
-extern void *memAllocBuf(size_t net_size, size_t * gross_size);
-extern void *memReallocBuf(void *buf, size_t net_size, size_t * gross_size);
-extern void memFree(void *, int type);
-extern void memFreeString(size_t size, void *);
-extern void memFreeBuf(size_t size, void *);
-extern FREE *memFreeBufFunc(size_t size);
-extern int memInUse(mem_type);
-extern void memDataInit(mem_type, const char *, size_t, int, bool zeroOnPush = true);
-extern void memCheckInit(void);
-extern void memConfigure(void);
+void memClean(void);
+void memInitModule(void);
+void memCleanModule(void);
+void memConfigure(void);
+void *memAllocate(mem_type);
+void *memAllocString(size_t net_size, size_t * gross_size);
+void *memAllocBuf(size_t net_size, size_t * gross_size);
+void *memReallocBuf(void *buf, size_t net_size, size_t * gross_size);
+void memFree(void *, int type);
+void memFreeString(size_t size, void *);
+void memFreeBuf(size_t size, void *);
+FREE *memFreeBufFunc(size_t size);
+int memInUse(mem_type);
+void memDataInit(mem_type, const char *, size_t, int, bool zeroOnPush = true);
+void memCheckInit(void);
+void memConfigure(void);
 
 #endif /* SQUID_MEM */
@@ -142,6 +142,6 @@ MemBlob::dump(std::ostream &os) const
     << "mem:" << static_cast<void*>(mem)
     << ",capacity:" << capacity
     << ",size:" << size
-    << ",refs:" << RefCountCount() << "; ";
+    << ",refs:" << LockCount() << "; ";
     return os;
 }
@@ -34,8 +34,8 @@
 #define MEMBLOB_DEBUGSECTION 24
 
 #include "base/InstanceId.h"
+#include "base/RefCount.h"
 #include "MemPool.h"
-#include "RefCount.h"
 
 /// Various MemBlob class-wide statistics.
 class MemBlobStats
@@ -175,8 +175,8 @@ class MemBuf
 #endif
 
 /** returns free() function to be used, _freezes_ the object! */
-SQUIDCEXTERN void memBufReport(MemBuf * mb);
+void memBufReport(MemBuf * mb);
 /** pack content into a mem buf. */
-SQUIDCEXTERN void packerToMemInit(Packer * p, MemBuf * mb);
+void packerToMemInit(Packer * p, MemBuf * mb);
 
 #endif /* SQUID_MEM_H */
@@ -40,6 +40,7 @@
 #include "MemBuf.h"
 #include "MemObject.h"
 #include "profiler/Profiler.h"
+#include "SquidConfig.h"
 #include "Store.h"
 #include "StoreClient.h"
 
@@ -31,20 +31,23 @@
 #ifndef SQUID_MEMOBJECT_H
 #define SQUID_MEMOBJECT_H
 
-#include "StoreIOBuffer.h"
-#include "StoreIOState.h"
-#include "stmem.h"
 #include "CommRead.h"
-#include "RemovalPolicy.h"
+#include "dlink.h"
 #include "HttpRequestMethod.h"
+#include "RemovalPolicy.h"
+#include "stmem.h"
+#include "StoreIOBuffer.h"
+#include "StoreIOState.h"
+
+#if USE_DELAY_POOLS
+#include "DelayId.h"
+#endif
 
 typedef void STMCB (void *data, StoreIOBuffer wroteBuffer);
 
 class store_client;
 class HttpRequest;
-#if USE_DELAY_POOLS
-#include "DelayId.h"
-#endif
+class HttpReply;
 
 class MemObject
 {
@@ -11,6 +11,7 @@
 #include "MemObject.h"
 #include "MemStore.h"
 #include "mime_header.h"
+#include "SquidConfig.h"
 #include "StoreStats.h"
 #include "tools.h"
 
@@ -129,7 +130,7 @@ MemStore::reference(StoreEntry &)
 }
 
 bool
-MemStore::dereference(StoreEntry &)
+MemStore::dereference(StoreEntry &, bool)
 {
     // no need to keep e in the global store_table for us; we have our own map
     return false;
@@ -1,7 +1,3 @@
-/*
- * $Id$
- */
-
 #ifndef SQUID_MEMSTORE_H
 #define SQUID_MEMSTORE_H
 
@@ -44,7 +40,7 @@ class MemStore: public Store, public Ipc::StoreMapCleaner
     virtual void stat(StoreEntry &) const;
     virtual StoreSearch *search(String const url, HttpRequest *);
     virtual void reference(StoreEntry &);
-    virtual bool dereference(StoreEntry &);
+    virtual bool dereference(StoreEntry &, bool);
     virtual void maintain();
 
     static int64_t EntryLimit();
@@ -0,0 +1,41 @@
+#ifndef SQUID_NEIGHBORTYPEDOMAINLIST_H_
+#define SQUID_NEIGHBORTYPEDOMAINLIST_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+/// representation of a neighbor_type_domain configuration directive. A POD
+class NeighborTypeDomainList
+{
+public:
+    char *domain;
+    peer_t type;
+    NeighborTypeDomainList *next;
+};
+
+#endif /* SQUID_NEIGHBORTYPEDOMAINLIST_H_ */
@@ -0,0 +1,131 @@
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "squid.h"
+#include "globals.h"
+#include "acl/FilledChecklist.h"
+#include "acl/Gadgets.h"
+#include "ConfigParser.h"
+#include "HttpRequest.h"
+#include "HttpReply.h"
+#include "SquidConfig.h"
+#include "Store.h"
+
+#include <algorithm>
+#include <string>
+
+Note::Value::~Value()
+{
+    aclDestroyAclList(&aclList);
+}
+
+Note::Value::Pointer
+Note::addValue(const String &value)
+{
+    Value::Pointer v = new Value(value);
+    values.push_back(v);
+    return v;
+}
+
+const char *
+Note::match(HttpRequest *request, HttpReply *reply)
+{
+
+    typedef Values::iterator VLI;
+    ACLFilledChecklist ch(NULL, request, NULL);
+    if (reply)
+        ch.reply = HTTPMSGLOCK(reply);
+
+    for (VLI i = values.begin(); i != values.end(); ++i ) {
+        const int ret= ch.fastCheck((*i)->aclList);
+        debugs(93, 5, HERE << "Check for header name: " << key << ": " << (*i)->value
+               <<", HttpRequest: " << request << " HttpReply: " << reply << " matched: " << ret);
+        if (ret == ACCESS_ALLOWED)
+            return (*i)->value.termedBuf();
+    }
+    return NULL;
+}
+
+Note::Pointer
+Notes::add(const String &noteKey)
+{
+    typedef Notes::NotesList::iterator AMLI;
+    for (AMLI i = notes.begin(); i != notes.end(); ++i) {
+        if ((*i)->key == noteKey)
+            return (*i);
+    }
+
+    Note::Pointer note = new Note(noteKey);
+    notes.push_back(note);
+    return note;
+}
+
+Note::Pointer
+Notes::parse(ConfigParser &parser)
+{
+    String key, value;
+    ConfigParser::ParseString(&key);
+    ConfigParser::ParseQuotedString(&value);
+    Note::Pointer note = add(key);
+    Note::Value::Pointer noteValue = note->addValue(value);
+    aclParseAclList(parser, &noteValue->aclList);
+
+    if (blacklisted) {
+        for (int i = 0; blacklisted[i] != NULL; ++i) {
+            if (note->key.caseCmp(blacklisted[i]) == 0) {
+                fatalf("%s:%d: meta key \"%s\" is a reserved %s name",
+                       cfg_filename, config_lineno, note->key.termedBuf(),
+                       descr ? descr : "");
+            }
+        }
+    }
+
+    return note;
+}
+
+void
+Notes::dump(StoreEntry *entry, const char *key)
+{
+    typedef Notes::NotesList::iterator AMLI;
+    for (AMLI m = notes.begin(); m != notes.end(); ++m) {
+        typedef Note::Values::iterator VLI;
+        for (VLI v =(*m)->values.begin(); v != (*m)->values.end(); ++v ) {
+            storeAppendPrintf(entry, "%s " SQUIDSTRINGPH " %s",
+                              key, SQUIDSTRINGPRINT((*m)->key), ConfigParser::QuoteString((*v)->value));
+            dump_acl_list(entry, (*v)->aclList);
+            storeAppendPrintf(entry, "\n");
+        }
+    }
+}
+
+void
+Notes::clean()
+{
+    notes.clean();
+}
@@ -0,0 +1,104 @@
+#ifndef SQUID_NOTES_H
+#define SQUID_NOTES_H
+
+#include "HttpHeader.h"
+#include "HttpHeaderTools.h"
+#include "typedefs.h"
+
+#if HAVE_STRING
+#include <string>
+#endif
+
+class HttpRequest;
+class HttpReply;
+
+/**
+ * Used to store notes. The notes are custom key:value pairs
+ * ICAP request headers or ECAP options used to pass
+ * custom transaction-state related meta information to squid
+ * internal subsystems or to addaptation services.
+ */
+class Note: public RefCountable
+{
+public:
+    typedef RefCount<Note> Pointer;
+    /// Stores a value for the note.
+    class Value: public RefCountable
+    {
+    public:
+        typedef RefCount<Value> Pointer;
+        String value; ///< a note value
+        ACLList *aclList; ///< The access list used to determine if this value is valid for a request
+        explicit Value(const String &aVal) : value(aVal), aclList(NULL) {}
+        ~Value();
+    };
+    typedef Vector<Value::Pointer> Values;
+
+    explicit Note(const String &aKey): key(aKey) {}
+
+    /**
+     * Adds a value to the note and returns a  pointer to the
+     * related Value object.
+     */
+    Value::Pointer addValue(const String &value);
+
+    /**
+     * Walks through the  possible values list of the note and selects
+     * the first value which matches the given HttpRequest and HttpReply
+     * or NULL if none matches.
+     */
+    const char *match(HttpRequest *request, HttpReply *reply);
+    String key; ///< The note key
+    Values values; ///< The possible values list for the note
+};
+
+class ConfigParser;
+/**
+ * Used to store a notes list.
+ */
+class Notes
+{
+public:
+    typedef Vector<Note::Pointer> NotesList;
+    typedef NotesList::iterator iterator; ///< iterates over the notes list
+
+    Notes(const char *aDescr, const char **metasBlacklist): descr(aDescr), blacklisted(metasBlacklist) {}
+    Notes(): descr(NULL), blacklisted(NULL) {}
+    ~Notes() { notes.clean(); }
+    /**
+     * Parse a notes line and returns a pointer to the
+     * parsed Note object.
+     */
+    Note::Pointer parse(ConfigParser &parser);
+    /**
+     * Dump the notes list to the given StoreEntry object.
+     */
+    void dump(StoreEntry *entry, const char *name);
+    void clean(); /// clean the notes list
+
+    /// points to the first argument
+    iterator begin() { return notes.begin(); }
+    /// points to the end of list
+    iterator end() { return notes.end(); }
+    /// return true if the notes list is empty
+    bool empty() { return notes.empty(); }
+
+    NotesList notes; ///< The Note::Pointer objects array list
+    const char *descr; ///< A short description for notes list
+    const char **blacklisted; ///< Null terminated list of blacklisted note keys
+private:
+    /**
+     * Adds a note to the notes list and returns a pointer to the
+     * related Note object. If the note key already exists in list,
+     * returns a pointer to the existing object.
+     */
+    Note::Pointer add(const String &noteKey);
+};
+
+class NotePairs : public HttpHeader
+{
+public:
+    NotePairs() : HttpHeader(hoNote) {}
+};
+
+#endif
@@ -38,7 +38,7 @@
 #define NULLDELAYID_H
 
 #if USE_DELAY_POOLS
-#include "RefCount.h"
+#include "base/RefCount.h"
 #include "DelayIdComposite.h"
 
 class NullDelayId : public DelayIdComposite
@@ -53,9 +53,8 @@ class Packer
     void *real_handler;		/* first parameter to real append and vprintf */
 };
 
-SQUIDCEXTERN void packerClean(Packer * p);
-SQUIDCEXTERN void packerAppend(Packer * p, const char *buf, int size);
-SQUIDCEXTERN void
-packerPrintf(Packer * p, const char *fmt,...) PRINTF_FORMAT_ARG2;
+void packerClean(Packer * p);
+void packerAppend(Packer * p, const char *buf, int size);
+void packerPrintf(Packer * p, const char *fmt,...) PRINTF_FORMAT_ARG2;
 
 #endif /* SQUID_PACKER_H */
@@ -36,34 +36,34 @@
 
 #include "ip/Address.h"
 
-extern double xatof(const char *token);
-extern int xatoi(const char *token);
-extern long xatol(const char *token);
-extern unsigned short xatos(const char *token);
+double xatof(const char *token);
+int xatoi(const char *token);
+long xatol(const char *token);
+unsigned short xatos(const char *token);
 
 /**
  * Parse a 64-bit integer value.
  */
-extern int64_t GetInteger64(void);
+int64_t GetInteger64(void);
 
 /**
  * Parses an integer value.
  * Uses a method that obeys hexadecimal 0xN syntax needed for certain bitmasks.
  */
-extern int GetInteger(void);
+int GetInteger(void);
 
-extern unsigned short GetShort(void);
+unsigned short GetShort(void);
 
 // on success, returns true and sets *p (if any) to the end of the integer
-extern bool StringToInt(const char *str, int &result, const char **p, int base);
-extern bool StringToInt64(const char *str, int64_t &result, const char **p, int base);
+bool StringToInt(const char *str, int &result, const char **p, int base);
+bool StringToInt64(const char *str, int64_t &result, const char **p, int base);
 
 /**
  * Parse a socket address (host:port), fill the given Ip::Address object
  * \retval false     Failure.
  * \retval true      Success.
  * Destroys token during parse.
  */
-extern bool GetHostWithPort(char *token, Ip::Address *ipa);
+bool GetHostWithPort(char *token, Ip::Address *ipa);
 
 #endif /* SQUID_PARSING_H */
@@ -38,7 +38,9 @@
 /* for CacheDigestGuessStats */
 #include "StatCounters.h"
 
-struct _Version {
+class Version
+{
+public:
     short int current;		/* current version */
     short int required;		/* minimal version that can safely handle current version */
 };
@@ -59,7 +61,13 @@ class StoreDigestCBlock
     int reserved[32 - 6];
 };
 
-struct _DigestFetchState {
+class HttpRequest;
+class PeerDigest;
+class store_client;
+
+class DigestFetchState
+{
+public:
     PeerDigest *pd;
     StoreEntry *entry;
     StoreEntry *old_entry;
@@ -90,7 +98,7 @@ class PeerDigest
     void *operator new (size_t);
     void operator delete(void *);
 
-    struct peer *peer;          /**< pointer back to peer structure, argh */
+    CachePeer *peer;          /**< pointer back to peer structure, argh */
     CacheDigest *cd;            /**< actual digest structure */
     String host;                /**< copy of peer->host */
     const char *req_result;     /**< text status of the last request */
@@ -129,10 +137,10 @@ class PeerDigest
 
 extern const Version CacheDigestVer;
 
-extern PeerDigest *peerDigestCreate(peer * p);
-extern void peerDigestNeeded(PeerDigest * pd);
-extern void peerDigestNotePeerGone(PeerDigest * pd);
-extern void peerDigestStatsReport(const PeerDigest * pd, StoreEntry * e);
+PeerDigest *peerDigestCreate(CachePeer * p);
+void peerDigestNeeded(PeerDigest * pd);
+void peerDigestNotePeerGone(PeerDigest * pd);
+void peerDigestStatsReport(const PeerDigest * pd, StoreEntry * e);
 
 #endif /* USE_CACHE_DIGESTS */
 
@@ -47,22 +47,22 @@ class ErrorState;
 
 typedef void PSC(Comm::ConnectionList *, ErrorState *, void *);
 
-SQUIDCEXTERN void peerSelect(Comm::ConnectionList *, HttpRequest *, StoreEntry *, PSC *, void *data);
-SQUIDCEXTERN void peerSelectInit(void);
+void peerSelect(Comm::ConnectionList *, HttpRequest *, StoreEntry *, PSC *, void *data);
+void peerSelectInit(void);
 
 /**
- * A peer which has been selected as a possible destination.
+ * A CachePeer which has been selected as a possible destination.
  * Listed as pointers here so as to prevent duplicates being added but will
  * be converted to a set of IP address path options before handing back out
  * to the caller.
  *
  * Certain connection flags and outgoing settings will also be looked up and
- * set based on the received request and peer settings before handing back.
+ * set based on the received request and CachePeer settings before handing back.
  */
 class FwdServer
 {
 public:
-    peer *_peer;                /* NULL --> origin server */
+    CachePeer *_peer;                /* NULL --> origin server */
     hier_code code;
     FwdServer *next;
 };
@@ -86,21 +86,21 @@ class ps_state
     FwdServer *servers;    ///< temporary linked list of peers we will pass back.
 
     /*
-     * Why are these Ip::Address instead of peer *?  Because a
-     * peer structure can become invalid during the peer selection
+     * Why are these Ip::Address instead of CachePeer *?  Because a
+     * CachePeer structure can become invalid during the CachePeer selection
      * phase, specifically after a reconfigure.  Thus we need to lookup
-     * the peer * based on the address when we are finally ready to
-     * reference the peer structure.
+     * the CachePeer * based on the address when we are finally ready to
+     * reference the CachePeer structure.
      */
 
     Ip::Address first_parent_miss;
 
     Ip::Address closest_parent_miss;
     /*
-     * ->hit can be peer* because it should only be
+     * ->hit can be CachePeer* because it should only be
      * accessed during the thread when it is set
      */
-    peer *hit;
+    CachePeer *hit;
     peer_t hit_type;
     ping_data ping;
     ACLChecklist *acl_checklist;
@@ -0,0 +1,61 @@
+#ifndef SQUID_REFRESHPATTERN_H_
+#define SQUID_REFRESHPATTERN_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+/// a representation of a refresh pattern. Currently a POD.
+class RefreshPattern
+{
+public:
+    const char *pattern;
+    regex_t compiled_pattern;
+    time_t min;
+    double pct;
+    time_t max;
+    RefreshPattern *next;
+
+    struct {
+        unsigned int icase:1;
+        unsigned int refresh_ims:1;
+        unsigned int store_stale:1;
+#if USE_HTTP_VIOLATIONS
+        unsigned int override_expire:1;
+        unsigned int override_lastmod:1;
+        unsigned int reload_into_ims:1;
+        unsigned int ignore_reload:1;
+        unsigned int ignore_no_store:1;
+        unsigned int ignore_must_revalidate:1;
+        unsigned int ignore_private:1;
+        unsigned int ignore_auth:1;
+#endif
+    } flags;
+    int max_stale;
+};
+
+#endif /* SQUID_REFRESHPATTERN_H_ */
@@ -0,0 +1,32 @@
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "squid.h"
+#include "RegexList.h"
+
@@ -0,0 +1,42 @@
+#ifndef SQUID_REGEXLIST_H_
+#define SQUID_REGEXLIST_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+/// list of regular expressions. Currently a POD.
+class RegexList
+{
+public:
+    int flags;
+    char *pattern;
+    regex_t regex;
+    RegexList *next;
+};
+
+#endif /* SQUID_REGEXLIST_H_ */
@@ -97,7 +97,7 @@ class RemovalPurgeWalker
     CBDATA_CLASS2(RemovalPurgeWalker);
 };
 
-extern RemovalPolicy *createRemovalPolicy(RemovalPolicySettings * settings);
+RemovalPolicy *createRemovalPolicy(RemovalPolicySettings * settings);
 
 typedef RemovalPolicy *REMOVALPOLICYCREATE(wordlist * args);
 
@@ -0,0 +1,46 @@
+/*
+ * DEBUG: section 73    HTTP Request
+ * AUTHOR: Duane Wessels
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "squid.h"
+#include "RequestFlags.h"
+
+// When adding new flags, please update cloneAdaptationImmune() as needed.
+// returns a partial copy of the flags that includes only those flags
+// that are safe for a related (e.g., ICAP-adapted) request to inherit
+RequestFlags
+RequestFlags::cloneAdaptationImmune() const
+{
+    // At the time of writing, all flags where either safe to copy after
+    // adaptation or were not set at the time of the adaptation. If there
+    // are flags that are different, they should be cleared in the clone.
+    return *this;
+}
@@ -0,0 +1,150 @@
+#ifndef SQUID_REQUESTFLAGS_H_
+#define SQUID_REQUESTFLAGS_H_
+/*
+ * DEBUG: section 73    HTTP Request
+ * AUTHOR: Duane Wessels
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+/** request-related flags
+ *
+ * The bit-field contains both flags marking a request's current state,
+ * and flags requesting some processing to be done at a later stage.
+ * TODO: better distinguish the two cases.
+ */
+class RequestFlags
+{
+public:
+    RequestFlags() {
+        memset(this,0,sizeof(RequestFlags));
+    }
+
+    /** true if the response to this request may not be READ from cache */
+    bool noCache :1;
+    /** request is if-modified-since */
+    bool ims :1;
+    /** request is authenticated */
+    bool auth :1;
+    /** he response to the request may be stored in the cache */
+    bool cachable :1;
+    /** the request can be forwarded through the hierarchy */
+    bool hierarchical :1;
+    /** a loop was detected on this request */
+    bool loopDetected :1;
+    /** the connection can be kept alive */
+    bool proxyKeepalive :1;
+    /* this should be killed, also in httpstateflags */
+    bool proxying :1;
+    /** content has expired, need to refresh it */
+    bool refresh :1;
+    /** request was redirected by redirectors */
+    bool redirected :1;
+    /** the requested object needs to be validated. See client_side_reply.cc
+     * for further information.
+     */
+    bool needValidation :1;
+    /** whether we should fail if validation fails */
+    bool failOnValidationError :1;
+    /** reply is stale if it is a hit */
+    bool staleIfHit :1;
+    /** request to override no-cache directives
+     *
+     * always use noCacheHack() for reading.
+     * \note only meaningful if USE_HTTP_VIOLATIONS is defined at build time
+     */
+    bool nocacheHack :1;
+    /** this request is accelerated (reverse-proxy) */
+    bool accelerated :1;
+    /** if set, ignore Cache-Control headers */
+    bool ignoreCc :1;
+    /** set for intercepted requests */
+    bool intercepted :1;
+    /** set if the Host: header passed verification */
+    bool hostVerified :1;
+    /** request to spoof the client ip */
+    bool spoofClientIp :1;
+    /** set if the request is internal (\see ClientHttpRequest::flags.internal)*/
+    bool internal :1;
+    /** set for internally-generated requests */
+    //XXX this is set in in clientBeginRequest, but never tested.
+    bool internalClient :1;
+    /** if set, request to try very hard to keep the connection alive */
+    bool mustKeepalive :1;
+    /** set if the rquest wants connection oriented auth */
+    bool connectionAuth :1;
+    /** set if connection oriented auth can not be supported */
+    bool connectionAuthDisabled :1;
+    /** Request wants connection oriented auth */
+    // XXX This is set in clientCheckPinning but never tested
+    bool connectionProxyAuth :1;
+    /** set if the request was sent on a pinned connection */
+    bool pinned :1;
+    /** OK to reopen a failed pinned connection */
+    bool canRePin :1;
+    /** Authentication was already sent upstream (e.g. due tcp-level auth) */
+    bool authSent :1;
+    /** Deny direct forwarding unless overriden by always_direct
+     * Used in accelerator mode */
+    bool noDirect :1;
+    /** Reply with chunked transfer encoding */
+    bool chunkedReply :1;
+    /** set if stream error has occured */
+    bool streamError :1;
+    /** internal ssl-bump request to get server cert */
+    bool sslPeek :1;
+    /** set if X-Forwarded-For checking is complete
+     *
+     * do not read directly; use doneFollowXff for reading
+     */
+    bool done_follow_x_forwarded_for :1;
+    /** set for ssl-bumped requests */
+    bool sslBumped :1;
+    bool destinationIpLookedUp:1;
+    /** request to reset the TCP stream */
+    bool resetTcp:1;
+    /** set if the request is ranged */
+    bool isRanged :1;
+
+    /** clone the flags, resetting to default those which are not safe in
+     *  a related (e.g. ICAP-adapted) request.
+     */
+    RequestFlags cloneAdaptationImmune() const;
+
+    // if FOLLOW_X_FORWARDED_FOR is not set, we always return "done".
+    bool doneFollowXff() const {
+        return done_follow_x_forwarded_for || !FOLLOW_X_FORWARDED_FOR;
+    }
+
+    // if USE_HTTP_VIOLATIONS is not set, never allow this
+    bool noCacheHack() const {
+        return USE_HTTP_VIOLATIONS && nocacheHack;
+    }
+};
+
+#endif /* SQUID_REQUESTFLAGS_H_ */
@@ -53,10 +53,11 @@
 #include "adaptation/Answer.h"
 #include "adaptation/Iterator.h"
 #include "base/AsyncCall.h"
+#include "SquidConfig.h"
 #endif
 
 // implemented in client_side_reply.cc until sides have a common parent
-extern void purgeEntriesByUrl(HttpRequest * req, const char *url);
+void purgeEntriesByUrl(HttpRequest * req, const char *url);
 
 ServerStateData::ServerStateData(FwdState *theFwdState): AsyncJob("ServerStateData"),
         requestSender(NULL),
@@ -43,6 +43,7 @@
 #endif
 
 class HttpMsg;
+class HttpReply;
 
 /**
  * ServerStateData is a common base for server-side classes such as
@@ -0,0 +1,60 @@
+#ifndef SQUID_SNMPREQUEST_H_
+#define SQUID_SNMPREQUEST_H_
+/*
+ * DEBUG: section
+ * AUTHOR:
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#if SQUID_SNMP
+#include "snmp_session.h"
+
+// POD
+class SnmpRequest
+{
+public:
+    u_char *buf;
+    u_char *outbuf;
+    int len;
+    int sock;
+    long reqid;
+    int outlen;
+
+    Ip::Address from;
+
+    struct snmp_pdu *PDU;
+    ACLChecklist *acl_checklist;
+    u_char *community;
+
+    struct snmp_session session;
+};
+
+#endif /* SQUID_SNMP */
+
+#endif /* SQUID_SNMPREQUEST_H_ */
@@ -1,12 +1,7 @@
-/*
- * $Id$
- */
-
 #include "squid.h"
-#include "ip/Address.h"
-// just for the global definition of Config and Config2
-#include "structs.h"
+#include "SquidConfig.h"
+
+class SquidConfig Config;
 
-struct SquidConfig Config;
+class SquidConfig2 Config2;
 
-struct SquidConfig2 Config2;
@@ -0,0 +1,567 @@
+#ifndef SQUID_SQUIDCONFIG_H_
+#define SQUID_SQUIDCONFIG_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "acl/AclAddress.h"
+#include "base/RefCount.h"
+#include "ClientDelayConfig.h"
+#include "DelayConfig.h"
+#include "HelperChildConfig.h"
+#include "HttpHeaderTools.h"
+#include "icmp/IcmpConfig.h"
+#include "ip/Address.h"
+#include "Notes.h"
+#include "YesNoNone.h"
+
+#if USE_SSL
+#include <openssl/ssl.h>
+class sslproxy_cert_sign;
+class sslproxy_cert_adapt;
+#endif
+
+class acl_access;
+class AclSizeLimit;
+class AclDenyInfoList;
+namespace Mgr
+{
+class ActionPasswordList;
+} // namespace Mgr
+class CustomLog;
+class CpuAffinityMap;
+class external_acl;
+class HeaderManglers;
+class RefreshPattern;
+class RemovalPolicySettings;
+class SwapDir;
+
+namespace AnyP
+{
+class PortCfg;
+}
+
+/// the representation of the configuration. POD.
+class SquidConfig
+{
+public:
+    struct {
+        /* These should be for the Store::Root instance.
+        * this needs pluggable parsing to be done smoothly.
+        */
+        int highWaterMark;
+        int lowWaterMark;
+    } Swap;
+
+    YesNoNone memShared; ///< whether the memory cache is shared among workers
+    size_t memMaxSize;
+
+    struct {
+        int64_t min;
+        int pct;
+        int64_t max;
+    } quickAbort;
+    int64_t readAheadGap;
+    RemovalPolicySettings *replPolicy;
+    RemovalPolicySettings *memPolicy;
+#if USE_HTTP_VIOLATIONS
+    time_t negativeTtl;
+#endif
+    time_t maxStale;
+    time_t negativeDnsTtl;
+    time_t positiveDnsTtl;
+    time_t shutdownLifetime;
+    time_t backgroundPingRate;
+
+    struct {
+        time_t read;
+        time_t write;
+        time_t lifetime;
+        time_t connect;
+        time_t forward;
+        time_t peer_connect;
+        time_t request;
+        time_t clientIdlePconn;
+        time_t serverIdlePconn;
+        time_t siteSelect;
+        time_t deadPeer;
+        int icp_query;      /* msec */
+        int icp_query_max;  /* msec */
+        int icp_query_min;  /* msec */
+        int mcast_icp_query;    /* msec */
+
+#if !USE_DNSHELPER
+        time_msec_t idns_retransmit;
+        time_msec_t idns_query;
+#endif
+
+    } Timeout;
+    size_t maxRequestHeaderSize;
+    int64_t maxRequestBodySize;
+    int64_t maxChunkedRequestBodySize;
+    size_t maxRequestBufferSize;
+    size_t maxReplyHeaderSize;
+    AclSizeLimit *ReplyBodySize;
+
+    struct {
+        unsigned short icp;
+#if USE_HTCP
+
+        unsigned short htcp;
+#endif
+#if SQUID_SNMP
+
+        unsigned short snmp;
+#endif
+    } Port;
+
+    struct {
+        AnyP::PortCfg *http;
+#if USE_SSL
+        AnyP::PortCfg *https;
+#endif
+    } Sockaddr;
+#if SQUID_SNMP
+
+    struct {
+        char *configFile;
+        char *agentInfo;
+    } Snmp;
+#endif
+#if USE_WCCP
+
+    struct {
+        Ip::Address router;
+        Ip::Address address;
+        int version;
+    } Wccp;
+#endif
+#if USE_WCCPv2
+
+    struct {
+        Ip::Address_list *router;
+        Ip::Address address;
+        int forwarding_method;
+        int return_method;
+        int assignment_method;
+        int weight;
+        int rebuildwait;
+        void *info;
+    } Wccp2;
+#endif
+
+#if USE_ICMP
+    IcmpConfig pinger;
+#endif
+
+    char *as_whois_server;
+
+    struct {
+        char *store;
+        char *swap;
+        CustomLog *accesslogs;
+#if ICAP_CLIENT
+        CustomLog *icaplogs;
+#endif
+        int rotateNumber;
+    } Log;
+    char *adminEmail;
+    char *EmailFrom;
+    char *EmailProgram;
+    char *effectiveUser;
+    char *visible_appname_string;
+    char *effectiveGroup;
+
+    struct {
+#if USE_DNSHELPER
+        char *dnsserver;
+#endif
+
+        wordlist *redirect;
+#if USE_UNLINKD
+
+        char *unlinkd;
+#endif
+
+        char *diskd;
+#if USE_SSL
+
+        char *ssl_password;
+#endif
+
+    } Program;
+#if USE_DNSHELPER
+    HelperChildConfig dnsChildren;
+#endif
+
+    HelperChildConfig redirectChildren;
+    time_t authenticateGCInterval;
+    time_t authenticateTTL;
+    time_t authenticateIpTTL;
+
+    struct {
+        char *surrogate_id;
+    } Accel;
+    char *appendDomain;
+    size_t appendDomainLen;
+    char *pidFilename;
+    char *netdbFilename;
+    char *mimeTablePathname;
+    char *etcHostsPath;
+    char *visibleHostname;
+    char *uniqueHostname;
+    wordlist *hostnameAliases;
+    char *errHtmlText;
+
+    struct {
+        char *host;
+        char *file;
+        time_t period;
+        unsigned short port;
+    } Announce;
+
+    struct {
+
+        Ip::Address udp_incoming;
+        Ip::Address udp_outgoing;
+#if SQUID_SNMP
+        Ip::Address snmp_incoming;
+        Ip::Address snmp_outgoing;
+#endif
+        /* FIXME INET6 : this should really be a CIDR value */
+        Ip::Address client_netmask;
+    } Addrs;
+    size_t tcpRcvBufsz;
+    size_t udpMaxHitObjsz;
+    wordlist *hierarchy_stoplist;
+    wordlist *mcast_group_list;
+    wordlist *dns_nameservers;
+    CachePeer *peers;
+    int npeers;
+
+    struct {
+        int size;
+        int low;
+        int high;
+    } ipcache;
+
+    struct {
+        int size;
+    } fqdncache;
+    int minDirectHops;
+    int minDirectRtt;
+    Mgr::ActionPasswordList *passwd_list;
+
+    struct {
+        int objectsPerBucket;
+        int64_t avgObjectSize;
+        int64_t maxObjectSize;
+        int64_t minObjectSize;
+        size_t maxInMemObjSize;
+    } Store;
+
+    struct {
+        int high;
+        int low;
+        time_t period;
+    } Netdb;
+
+    struct {
+        int log_udp;
+        int res_defnames;
+        int anonymizer;
+        int client_db;
+        int query_icmp;
+        int icp_hit_stale;
+        int buffered_logs;
+        int common_log;
+        int log_mime_hdrs;
+        int log_fqdn;
+        int announce;
+        int mem_pools;
+        int test_reachability;
+        int half_closed_clients;
+        int refresh_all_ims;
+#if USE_HTTP_VIOLATIONS
+
+        int reload_into_ims;
+#endif
+
+        int offline;
+        int redir_rewrites_host;
+        int prefer_direct;
+        int nonhierarchical_direct;
+        int strip_query_terms;
+        int redirector_bypass;
+        int ignore_unknown_nameservers;
+        int client_pconns;
+        int server_pconns;
+        int error_pconns;
+#if USE_CACHE_DIGESTS
+
+        int digest_generation;
+#endif
+
+        int ie_refresh;
+        int vary_ignore_expire;
+        int pipeline_prefetch;
+        int surrogate_is_remote;
+        int request_entities;
+        int detect_broken_server_pconns;
+        int balance_on_multiple_ip;
+        int relaxed_header_parser;
+        int check_hostnames;
+        int allow_underscore;
+        int via;
+        int emailErrData;
+        int httpd_suppress_version_string;
+        int global_internal_static;
+
+#if FOLLOW_X_FORWARDED_FOR
+        int acl_uses_indirect_client;
+        int delay_pool_uses_indirect_client;
+        int log_uses_indirect_client;
+#if LINUX_NETFILTER
+        int tproxy_uses_indirect_client;
+#endif
+#endif /* FOLLOW_X_FORWARDED_FOR */
+
+        int WIN32_IpAddrChangeMonitor;
+        int memory_cache_first;
+        int memory_cache_disk;
+        int hostStrictVerify;
+        int client_dst_passthru;
+    } onoff;
+
+    int forward_max_tries;
+    int connect_retries;
+
+    class ACL *aclList;
+
+    struct {
+        acl_access *http;
+        acl_access *adapted_http;
+        acl_access *icp;
+        acl_access *miss;
+        acl_access *NeverDirect;
+        acl_access *AlwaysDirect;
+        acl_access *ASlists;
+        acl_access *noCache;
+        acl_access *log;
+#if SQUID_SNMP
+
+        acl_access *snmp;
+#endif
+#if USE_HTTP_VIOLATIONS
+        acl_access *brokenPosts;
+#endif
+        acl_access *redirector;
+        acl_access *reply;
+        AclAddress *outgoing_address;
+#if USE_HTCP
+
+        acl_access *htcp;
+        acl_access *htcp_clr;
+#endif
+
+#if USE_SSL
+        acl_access *ssl_bump;
+#endif
+#if FOLLOW_X_FORWARDED_FOR
+        acl_access *followXFF;
+#endif /* FOLLOW_X_FORWARDED_FOR */
+
+#if ICAP_CLIENT
+        acl_access* icap;
+#endif
+    } accessList;
+    AclDenyInfoList *denyInfoList;
+
+    struct {
+        size_t list_width;
+        int list_wrap;
+        char *anon_user;
+        int passive;
+        int epsv_all;
+        int epsv;
+        int eprt;
+        int sanitycheck;
+        int telnet;
+    } Ftp;
+    RefreshPattern *Refresh;
+
+    struct _cacheSwap {
+        RefCount<SwapDir> *swapDirs;
+        int n_allocated;
+        int n_configured;
+        /// number of disk processes required to support all cache_dirs
+        int n_strands;
+    } cacheSwap;
+    /*
+     * I'm sick of having to keep doing this ..
+     */
+#define INDEXSD(i)   (Config.cacheSwap.swapDirs[(i)].getRaw())
+
+    struct {
+        char *directory;
+        int use_short_names;
+    } icons;
+    char *errorDirectory;
+#if USE_ERR_LOCALES
+    char *errorDefaultLanguage;
+    int errorLogMissingLanguages;
+#endif
+    char *errorStylesheet;
+
+    struct {
+        int onerror;
+    } retry;
+
+    struct {
+        int64_t limit;
+    } MemPools;
+#if USE_DELAY_POOLS
+
+    DelayConfig Delay;
+    ClientDelayConfig ClientDelay;
+#endif
+
+    struct {
+        struct {
+            int average;
+            int min_poll;
+        } dns, udp, tcp;
+    } comm_incoming;
+    int max_open_disk_fds;
+    int uri_whitespace;
+    AclSizeLimit *rangeOffsetLimit;
+#if MULTICAST_MISS_STREAM
+
+    struct {
+
+        Ip::Address addr;
+        int ttl;
+        unsigned short port;
+        char *encode_key;
+    } mcast_miss;
+#endif
+
+    /// request_header_access and request_header_replace
+    HeaderManglers *request_header_access;
+    /// reply_header_access and reply_header_replace
+    HeaderManglers *reply_header_access;
+    ///request_header_add access list
+    HeaderWithAclList *request_header_add;
+    ///note
+    Notes notes;
+    char *coredump_dir;
+    char *chroot_dir;
+#if USE_CACHE_DIGESTS
+
+    struct {
+        int bits_per_entry;
+        time_t rebuild_period;
+        time_t rewrite_period;
+        size_t swapout_chunk_size;
+        int rebuild_chunk_percentage;
+    } digest;
+#endif
+#if USE_SSL
+
+    struct {
+        int unclean_shutdown;
+        char *ssl_engine;
+    } SSL;
+#endif
+
+    wordlist *ext_methods;
+
+    struct {
+        int high_rptm;
+        int high_pf;
+        size_t high_memory;
+    } warnings;
+    char *store_dir_select_algorithm;
+    int sleep_after_fork;   /* microseconds */
+    time_t minimum_expiry_time; /* seconds */
+    external_acl *externalAclHelperList;
+
+#if USE_SSL
+
+    struct {
+        char *cert;
+        char *key;
+        int version;
+        char *options;
+        char *cipher;
+        char *cafile;
+        char *capath;
+        char *crlfile;
+        char *flags;
+        acl_access *cert_error;
+        SSL_CTX *sslContext;
+        sslproxy_cert_sign *cert_sign;
+        sslproxy_cert_adapt *cert_adapt;
+    } ssl_client;
+#endif
+
+    char *accept_filter;
+    int umask;
+    int max_filedescriptors;
+    int workers;
+    CpuAffinityMap *cpuAffinityMap;
+
+#if USE_LOADABLE_MODULES
+    wordlist *loadable_module_names;
+#endif
+
+    int client_ip_max_connections;
+
+    struct {
+        int v4_first;       ///< Place IPv4 first in the order of DNS results.
+        ssize_t packet_max; ///< maximum size EDNS advertised for DNS replies.
+    } dns;
+
+};
+
+extern SquidConfig Config;
+
+class SquidConfig2
+{
+public:
+    struct {
+        int enable_purge;
+        int mangle_request_headers;
+    } onoff;
+    uid_t effectiveUserID;
+    gid_t effectiveGroupID;
+};
+
+extern SquidConfig2 Config2;
+
+#endif /* SQUID_SQUIDCONFIG_H_ */
@@ -11,16 +11,16 @@ class Address;
 }
 
 // generic DNS API
-extern void dnsInit(void);
-extern void dnsShutdown(void);
+void dnsInit(void);
+void dnsShutdown(void);
 
 #if USE_DNSHELPER
 // external DNS helper API
-extern void dnsSubmit(const char *lookup, HLPCB * callback, void *data);
+void dnsSubmit(const char *lookup, HLPCB * callback, void *data);
 #else
 // internal DNS client API
-extern void idnsALookup(const char *, IDNSCB *, void *);
-extern void idnsPTRLookup(const Ip::Address &, IDNSCB *, void *);
+void idnsALookup(const char *, IDNSCB *, void *);
+void idnsPTRLookup(const Ip::Address &, IDNSCB *, void *);
 #endif
 
 #endif /* SQUID_DNS_H */
@@ -36,13 +36,13 @@ namespace Ip
 {
 class Address;
 }
-extern pid_t ipcCreate(int type,
-                       const char *prog,
-                       const char *const args[],
-                       const char *name,
-                       Ip::Address &local_addr,
-                       int *rfd,
-                       int *wfd,
-                       void **hIpc);
+pid_t ipcCreate(int type,
+                const char *prog,
+                const char *const args[],
+                const char *name,
+                Ip::Address &local_addr,
+                int *rfd,
+                int *wfd,
+                void **hIpc);
 
 #endif /* SQUID_SQUIDIPC_H_ */
@@ -39,7 +39,7 @@ class link_list
     link_list *next;
 };
 
-extern void linklistPush(link_list **, void *);
-extern void *linklistShift(link_list **);
+void linklistPush(link_list **, void *);
+void *linklistShift(link_list **);
 
 #endif /* SQUID_SQUIDLIST_H_ */
@@ -5,11 +5,11 @@
 namespace Math
 {
 
-extern int intPercent(const int a, const int b);
-extern int64_t int64Percent(const int64_t a, const int64_t b);
-extern double doublePercent(const double, const double);
-extern int intAverage(const int, const int, int, const int);
-extern double doubleAverage(const double, const double, int, const int);
+int intPercent(const int a, const int b);
+int64_t int64Percent(const int64_t a, const int64_t b);
+double doublePercent(const double, const double);
+int intAverage(const int, const int, int, const int);
+double doubleAverage(const double, const double, int, const int);
 
 } // namespace Math
 
@@ -55,13 +55,11 @@ class StringRegistry
 public:
     static StringRegistry &Instance();
 
-    void add
-    (String const *);
+    void add(String const *);
 
     StringRegistry();
 
-    void remove
-    (String const *);
+    void remove(String const *);
 
 private:
     static OBJH Stat;
@@ -84,8 +82,8 @@ class String
 
 public:
     _SQUID_INLINE_ String();
-    String (char const *);
-    String (String const &);
+    String(char const *);
+    String(String const &);
     ~String();
 
     typedef size_t size_type; //storage size intentionally unspecified
@@ -131,7 +129,7 @@ class String
     void append(char const *buf, int len);
     void append(char const *buf);
     void append(char const);
-    void append (String const &);
+    void append(String const &);
     void absorb(String &old);
     const char * pos(char const *aString) const;
     const char * pos(char const ch) const;
@@ -141,19 +139,19 @@ class String
     size_type find(char const *aString) const;
     const char * rpos(char const ch) const;
     size_type rfind(char const ch) const;
-    _SQUID_INLINE_ int cmp (char const *) const;
-    _SQUID_INLINE_ int cmp (char const *, size_type count) const;
-    _SQUID_INLINE_ int cmp (String const &) const;
-    _SQUID_INLINE_ int caseCmp (char const *) const;
-    _SQUID_INLINE_ int caseCmp (char const *, size_type count) const;
-    _SQUID_INLINE_ int caseCmp (String const &) const;
+    _SQUID_INLINE_ int cmp(char const *) const;
+    _SQUID_INLINE_ int cmp(char const *, size_type count) const;
+    _SQUID_INLINE_ int cmp(String const &) const;
+    _SQUID_INLINE_ int caseCmp(char const *) const;
+    _SQUID_INLINE_ int caseCmp(char const *, size_type count) const;
+    _SQUID_INLINE_ int caseCmp(String const &) const;
 
     String substr(size_type from, size_type to) const;
 
     _SQUID_INLINE_ void cut(size_type newLength);
 
 #if DEBUGSTRINGS
-    void stat (StoreEntry *) const;
+    void stat(StoreEntry *) const;
 #endif
 
 private:
@@ -183,9 +181,9 @@ _SQUID_INLINE_ bool operator<(const String &a, const String &b);
 #include "String.cci"
 #endif
 
-extern const char *checkNullString(const char *p);
-extern int stringHasWhitespace(const char *);
-extern int stringHasCntl(const char *);
-extern char *strwordtok(char *buf, char **t);
+const char *checkNullString(const char *p);
+int stringHasWhitespace(const char *);
+int stringHasCntl(const char *);
+char *strwordtok(char *buf, char **t);
 
 #endif /* SQUID_STRING_H */
@@ -31,6 +31,7 @@
  */
 
 #include "MemObject.h"
+#include "HttpReply.h"
 
 /**
  \retval true	Store contains 0 bytes of data.
@@ -35,12 +35,13 @@
  \ingroup FileSystems
  */
 
+#include "base/RefCount.h"
 #include "comm/forward.h"
 #include "CommRead.h"
+#include "hash.h"
+#include "HttpReply.h"
 #include "HttpRequestMethod.h"
-#include "Packer.h"
 #include "Range.h"
-#include "RefCount.h"
 #include "RemovalPolicy.h"
 #include "StoreIOBuffer.h"
 #include "StoreStats.h"
@@ -56,6 +57,8 @@
 class AsyncCall;
 class HttpRequest;
 class MemObject;
+class Packer;
+class RequestFlags;
 class StoreClient;
 class StoreSearch;
 class SwapDir;
@@ -338,7 +341,7 @@ class Store : public RefCountable
     virtual void reference(StoreEntry &) = 0;	/* Reference this object */
 
     /// Undo reference(), returning false iff idle e should be destroyed
-    virtual bool dereference(StoreEntry &e) = 0;
+    virtual bool dereference(StoreEntry &e, bool wantsLocalMemory) = 0;
 
     virtual void maintain() = 0; /* perform regular maintenance should be private and self registered ... */
 
@@ -360,62 +363,62 @@ class Store : public RefCountable
 typedef RefCount<Store> StorePointer;
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN size_t storeEntryInUse();
+size_t storeEntryInUse();
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN const char *storeEntryFlags(const StoreEntry *);
+const char *storeEntryFlags(const StoreEntry *);
 
 /// \ingroup StoreAPI
-extern void storeEntryReplaceObject(StoreEntry *, HttpReply *);
+void storeEntryReplaceObject(StoreEntry *, HttpReply *);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN StoreEntry *storeGetPublic(const char *uri, const HttpRequestMethod& method);
+StoreEntry *storeGetPublic(const char *uri, const HttpRequestMethod& method);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN StoreEntry *storeGetPublicByRequest(HttpRequest * request);
+StoreEntry *storeGetPublicByRequest(HttpRequest * request);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN StoreEntry *storeGetPublicByRequestMethod(HttpRequest * request, const HttpRequestMethod& method);
+StoreEntry *storeGetPublicByRequestMethod(HttpRequest * request, const HttpRequestMethod& method);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN StoreEntry *storeCreateEntry(const char *, const char *, request_flags, const HttpRequestMethod&);
+StoreEntry *storeCreateEntry(const char *, const char *, const RequestFlags &, const HttpRequestMethod&);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN void storeInit(void);
+void storeInit(void);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN void storeConfigure(void);
+void storeConfigure(void);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN void storeFreeMemory(void);
+void storeFreeMemory(void);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN int expiresMoreThan(time_t, time_t);
+int expiresMoreThan(time_t, time_t);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN void storeAppendPrintf(StoreEntry *, const char *,...) PRINTF_FORMAT_ARG2;
+void storeAppendPrintf(StoreEntry *, const char *,...) PRINTF_FORMAT_ARG2;
 
 /// \ingroup StoreAPI
-extern void storeAppendVPrintf(StoreEntry *, const char *, va_list ap);
+void storeAppendVPrintf(StoreEntry *, const char *, va_list ap);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN int storeTooManyDiskFilesOpen(void);
+int storeTooManyDiskFilesOpen(void);
 
 class SwapDir;
 /// \ingroup StoreAPI
-SQUIDCEXTERN void storeHeapPositionUpdate(StoreEntry *, SwapDir *);
+void storeHeapPositionUpdate(StoreEntry *, SwapDir *);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN void storeSwapFileNumberSet(StoreEntry * e, sfileno filn);
+void storeSwapFileNumberSet(StoreEntry * e, sfileno filn);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN void storeFsInit(void);
+void storeFsInit(void);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN void storeFsDone(void);
+void storeFsDone(void);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN void storeReplAdd(const char *, REMOVALPOLICYCREATE *);
+void storeReplAdd(const char *, REMOVALPOLICYCREATE *);
 
 /// \ingroup StoreAPI
 extern FREE destroyStoreEntry;
@@ -424,10 +427,10 @@ extern FREE destroyStoreEntry;
  \ingroup StoreAPI
  \todo should be a subclass of Packer perhaps ?
  */
-SQUIDCEXTERN void packerToStoreInit(Packer * p, StoreEntry * e);
+void packerToStoreInit(Packer * p, StoreEntry * e);
 
 /// \ingroup StoreAPI
-SQUIDCEXTERN void storeGetMemSpace(int size);
+void storeGetMemSpace(int size);
 
 #if _USE_INLINE_
 #include "Store.cci"
@@ -125,11 +125,11 @@ class store_client
     CBDATA_CLASS(store_client);
 };
 
-extern void storeClientCopy(store_client *, StoreEntry *, StoreIOBuffer, STCB *, void *);
-extern store_client* storeClientListAdd(StoreEntry * e, void *data);
-extern int storeClientCopyPending(store_client *, StoreEntry * e, void *data);
-extern int storeUnregister(store_client * sc, StoreEntry * e, void *data);
-extern int storePendingNClients(const StoreEntry * e);
-extern int storeClientIsThisAClient(store_client * sc, void *someClient);
+void storeClientCopy(store_client *, StoreEntry *, StoreIOBuffer, STCB *, void *);
+store_client* storeClientListAdd(StoreEntry * e, void *data);
+int storeClientCopyPending(store_client *, StoreEntry * e, void *data);
+int storeUnregister(store_client * sc, StoreEntry * e, void *data);
+int storePendingNClients(const StoreEntry * e);
+int storeClientIsThisAClient(store_client * sc, void *someClient);
 
 #endif /* SQUID_STORECLIENT_H */
@@ -76,7 +76,7 @@ class StoreHashIndex : public Store
 
     virtual void reference(StoreEntry&);
 
-    virtual bool dereference(StoreEntry&);
+    virtual bool dereference(StoreEntry&, bool);
 
     virtual void maintain();
 
@@ -32,8 +32,8 @@
 #ifndef SQUID_STOREIOSTATE_H
 #define SQUID_STOREIOSTATE_H
 
+#include "base/RefCount.h"
 #include "cbdata.h"
-#include "RefCount.h"
 
 class StoreIOState : public RefCountable
 {
@@ -111,8 +111,8 @@ class StoreIOState : public RefCountable
 
 StoreIOState::Pointer storeCreate(StoreEntry *, StoreIOState::STFNCB *, StoreIOState::STIOCB *, void *);
 StoreIOState::Pointer storeOpen(StoreEntry *, StoreIOState::STFNCB *, StoreIOState::STIOCB *, void *);
-SQUIDCEXTERN void storeClose(StoreIOState::Pointer, int how);
-SQUIDCEXTERN void storeRead(StoreIOState::Pointer, char *, size_t, off_t, StoreIOState::STRCB *, void *);
-SQUIDCEXTERN void storeIOWrite(StoreIOState::Pointer, char const *, size_t, off_t, FREE *);
+void storeClose(StoreIOState::Pointer, int how);
+void storeRead(StoreIOState::Pointer, char *, size_t, off_t, StoreIOState::STRCB *, void *);
+void storeIOWrite(StoreIOState::Pointer, char const *, size_t, off_t, FREE *);
 
 #endif /* SQUID_STOREIOSTATE_H */
@@ -151,10 +151,10 @@ class StoreMeta
 };
 
 /// \ingroup SwapStoreAPI
-SQUIDCEXTERN char *storeSwapMetaPack(tlv * tlv_list, int *length);
+char *storeSwapMetaPack(tlv * tlv_list, int *length);
 /// \ingroup SwapStoreAPI
-SQUIDCEXTERN tlv *storeSwapMetaBuild(StoreEntry * e);
+tlv *storeSwapMetaBuild(StoreEntry * e);
 /// \ingroup SwapStoreAPI
-SQUIDCEXTERN void storeSwapTLVFree(tlv * n);
+void storeSwapTLVFree(tlv * n);
 
 #endif /* SQUID_TYPELENGTHVALUE_H */
@@ -64,10 +64,10 @@ class StoreMetaUnpacker
 /*
  * store_swapmeta.c
  */
-SQUIDCEXTERN char *storeSwapMetaPack(StoreMeta * tlv_list, int *length);
-SQUIDCEXTERN StoreMeta *storeSwapMetaBuild(StoreEntry * e);
-SQUIDCEXTERN StoreMeta *storeSwapMetaUnpack(const char *buf, int *hdrlen);
-SQUIDCEXTERN void storeSwapTLVFree(StoreMeta * n);
+char *storeSwapMetaPack(StoreMeta * tlv_list, int *length);
+StoreMeta *storeSwapMetaBuild(StoreEntry * e);
+StoreMeta *storeSwapMetaUnpack(const char *buf, int *hdrlen);
+void storeSwapTLVFree(StoreMeta * n);
 StoreMeta ** storeSwapTLVAdd(int type, const void *ptr, size_t len, StoreMeta ** tail);
 
 #endif /* SQUID_TYPELENGTHVALUEUNPACKER_H */
@@ -31,7 +31,7 @@
 #ifndef SQUID_STORESEARCH_H
 #define SQUID_STORESEARCH_H
 
-#include "RefCount.h"
+#include "base/RefCount.h"
 #include "Store.h"
 
 class StoreSearch : public RefCountable
@@ -35,9 +35,9 @@
 
 class String;
 
-extern void strListAdd(String * str, const char *item, char del);
-extern int strListIsMember(const String * str, const char *item, char del);
-extern int strListIsSubstr(const String * list, const char *s, char del);
-extern int strListGetItem(const String * str, char del, const char **item, int *ilen, const char **pos);
+void strListAdd(String * str, const char *item, char del);
+int strListIsMember(const String * str, const char *item, char del);
+int strListIsSubstr(const String * list, const char *s, char del);
+int strListGetItem(const String * str, char del, const char **item, int *ilen, const char **pos);
 
 #endif /* SQUID_STRLIST_H_ */
@@ -72,7 +72,7 @@ String::setBuffer(char *aBuf, String::size_type aSize)
     size_ = aSize;
 }
 
-String::String (char const *aString) : size_(0), len_(0), buf_(NULL)
+String::String(char const *aString) : size_(0), len_(0), buf_(NULL)
 {
     if (aString)
         allocAndFill(aString, strlen(aString));
@@ -90,7 +90,7 @@ String::operator =(char const *aString)
 }
 
 String &
-String::operator = (String const &old)
+String::operator =(String const &old)
 {
     clean(); // TODO: optimize to avoid cleaning the buffer we can use
     if (old.size() > 0)
@@ -99,7 +99,7 @@ String::operator = (String const &old)
 }
 
 bool
-String::operator == (String const &that) const
+String::operator ==(String const &that) const
 {
     if (0 == this->cmp(that))
         return true;
@@ -108,7 +108,7 @@ String::operator == (String const &that) const
 }
 
 bool
-String::operator != (String const &that) const
+String::operator !=(String const &that) const
 {
     if (0 == this->cmp(that))
         return false;
@@ -138,7 +138,7 @@ String::allocAndFill(const char *str, int len)
     PROF_stop(StringAllocAndFill);
 }
 
-String::String (String const &old) : size_(0), len_(0), buf_(NULL)
+String::String(String const &old) : size_(0), len_(0), buf_(NULL)
 {
     if (old.size() > 0)
         allocAndFill(old.rawBuf(), old.size());
@@ -176,7 +176,7 @@ String::~String()
 }
 
 void
-String::reset(const char *str)
+String::reset(char const *str)
 {
     PROF_start(StringReset);
     clean(); // TODO: optimize to avoid cleaning the buffer if we can reuse it
@@ -186,7 +186,7 @@ String::reset(const char *str)
 }
 
 void
-String::append(const char *str, int len)
+String::append( char const *str, int len)
 {
     assert(this);
     assert(str && len >= 0);
@@ -218,23 +218,23 @@ String::append(const char *str, int len)
 void
 String::append(char const *str)
 {
-    assert (str);
-    append (str, strlen(str));
+    assert(str);
+    append(str, strlen(str));
 }
 
 void
-String::append (char chr)
+String::append(char const chr)
 {
     char myString[2];
     myString[0]=chr;
     myString[1]='\0';
-    append (myString, 1);
+    append(myString, 1);
 }
 
 void
 String::append(String const &old)
 {
-    append (old.rawBuf(), old.len_);
+    append(old.rawBuf(), old.len_);
 }
 
 void
@@ -303,7 +303,7 @@ StringRegistry::remove(String const *entry)
 
 StringRegistry StringRegistry::Instance_;
 
-extern String::size_type memStringCount();
+String::size_type memStringCount();
 
 void
 StringRegistry::Stat(StoreEntry *entry)
@@ -40,7 +40,7 @@
 #endif /* INT_MAX */
 #endif /* HAVE_STDINT_H */
 
-String::String() : size_(0), len_(0), buf_ (NULL)
+String::String() : size_(0), len_(0), buf_(NULL)
 {
 #if DEBUGSTRINGS
     StringRegistry::Instance().add(this);
@@ -102,7 +102,7 @@ String::nilCmp(const bool thisIsNilOrEmpty, const bool otherIsNilOrEmpty, int &r
 }
 
 int
-String::cmp (char const *aString) const
+String::cmp(char const *aString) const
 {
     int result = 0;
     if (nilCmp(!size(), (!aString || !*aString), result))
@@ -112,7 +112,7 @@ String::cmp (char const *aString) const
 }
 
 int
-String::cmp (char const *aString, String::size_type count) const
+String::cmp(char const *aString, String::size_type count) const
 {
     int result = 0;
     if (nilCmp((!size() || !count), (!aString || !*aString || !count), result))
@@ -122,7 +122,7 @@ String::cmp (char const *aString, String::size_type count) const
 }
 
 int
-String::cmp (String const &aString) const
+String::cmp(String const &aString) const
 {
     int result = 0;
     if (nilCmp(!size(), !aString.size(), result))
@@ -36,6 +36,7 @@
 #include "ConfigOption.h"
 #include "globals.h"
 #include "Parsing.h"
+#include "SquidConfig.h"
 #include "StoreFileSystem.h"
 #include "SwapDir.h"
 #include "tools.h"
@@ -117,7 +118,7 @@ void
 SwapDir::reference(StoreEntry &) {}
 
 bool
-SwapDir::dereference(StoreEntry &)
+SwapDir::dereference(StoreEntry &, bool)
 {
     return true; // keep in global store_table
 }
@@ -30,6 +30,7 @@
 #ifndef SQUID_SWAPDIR_H
 #define SQUID_SWAPDIR_H
 
+#include "SquidConfig.h"
 #include "Store.h"
 #include "StoreIOState.h"
 
@@ -83,7 +84,7 @@ class StoreController : public Store
 
     virtual void reference(StoreEntry &);	/* Reference this object */
 
-    virtual bool dereference(StoreEntry &);	/* Unreference this object */
+    virtual bool dereference(StoreEntry &, bool);	/* Unreference this object */
 
     /* the number of store dirs being rebuilt. */
     static int store_dirs_rebuilding;
@@ -97,25 +98,25 @@ class StoreController : public Store
 };
 
 /* migrating from the Config based list of swapdirs */
-extern void allocate_new_swapdir(SquidConfig::_cacheSwap *);
-extern void free_cachedir(SquidConfig::_cacheSwap * swap);
-SQUIDCEXTERN OBJH storeDirStats;
-SQUIDCEXTERN char *storeDirSwapLogFile(int, const char *);
-SQUIDCEXTERN char *storeSwapFullPath(int, char *);
-SQUIDCEXTERN char *storeSwapSubSubDir(int, char *);
-SQUIDCEXTERN const char *storeSwapPath(int);
-SQUIDCEXTERN int storeDirWriteCleanLogs(int reopen);
-SQUIDCEXTERN STDIRSELECT *storeDirSelectSwapDir;
-SQUIDCEXTERN int storeVerifySwapDirs(void);
-SQUIDCEXTERN void storeDirCloseSwapLogs(void);
-SQUIDCEXTERN void storeDirCloseTmpSwapLog(int dirn);
-SQUIDCEXTERN void storeDirDiskFull(sdirno);
-SQUIDCEXTERN void storeDirOpenSwapLogs(void);
-SQUIDCEXTERN void storeDirSwapLog(const StoreEntry *, int op);
-SQUIDCEXTERN void storeDirLRUDelete(StoreEntry *);
-SQUIDCEXTERN void storeDirLRUAdd(StoreEntry *);
-SQUIDCEXTERN int storeDirGetBlkSize(const char *path, int *blksize);
-SQUIDCEXTERN int storeDirGetUFSStats(const char *, int *, int *, int *, int *);
+void allocate_new_swapdir(SquidConfig::_cacheSwap *);
+void free_cachedir(SquidConfig::_cacheSwap * swap);
+extern OBJH storeDirStats;
+char *storeDirSwapLogFile(int, const char *);
+char *storeSwapFullPath(int, char *);
+char *storeSwapSubSubDir(int, char *);
+const char *storeSwapPath(int);
+int storeDirWriteCleanLogs(int reopen);
+extern STDIRSELECT *storeDirSelectSwapDir;
+int storeVerifySwapDirs(void);
+void storeDirCloseSwapLogs(void);
+void storeDirCloseTmpSwapLog(int dirn);
+void storeDirDiskFull(sdirno);
+void storeDirOpenSwapLogs(void);
+void storeDirSwapLog(const StoreEntry *, int op);
+void storeDirLRUDelete(StoreEntry *);
+void storeDirLRUAdd(StoreEntry *);
+int storeDirGetBlkSize(const char *path, int *blksize);
+int storeDirGetUFSStats(const char *, int *, int *, int *, int *);
 
 /// manages a single cache_dir
 class SwapDir : public Store
@@ -205,7 +206,7 @@ class SwapDir : public Store
     virtual bool canStore(const StoreEntry &e, int64_t diskSpaceNeeded, int &load) const = 0;
     /* These two are notifications */
     virtual void reference(StoreEntry &);	/* Reference this object */
-    virtual bool dereference(StoreEntry &);	/* Unreference this object */
+    virtual bool dereference(StoreEntry &, bool);	/* Unreference this object */
     virtual int callback();	/* Handle pending callbacks */
     virtual void sync();	/* Sync the store prior to shutdown */
     virtual StoreIOState::Pointer createStoreIO(StoreEntry &, StoreIOState::STFNCB *, StoreIOState::STIOCB *, void *) = 0;
@@ -79,20 +79,20 @@ MEMPROXY_CLASS_INLINE(URL);
 class HttpRequest;
 class HttpRequestMethod;
 
-extern AnyP::ProtocolType urlParseProtocol(const char *, const char *e = NULL);
-extern void urlInitialize(void);
-extern HttpRequest *urlParse(const HttpRequestMethod&, char *, HttpRequest *request = NULL);
-extern const char *urlCanonical(HttpRequest *);
-extern char *urlCanonicalClean(const HttpRequest *);
-extern const char *urlCanonicalFakeHttps(const HttpRequest * request);
-extern bool urlIsRelative(const char *);
-extern char *urlMakeAbsolute(const HttpRequest *, const char *);
-extern char *urlRInternal(const char *host, unsigned short port, const char *dir, const char *name);
-extern char *urlInternal(const char *dir, const char *name);
-extern int matchDomainName(const char *host, const char *domain);
-extern int urlCheckRequest(const HttpRequest *);
-extern int urlDefaultPort(AnyP::ProtocolType p);
-extern char *urlHostname(const char *url);
-extern void urlExtMethodConfigure(void);
+AnyP::ProtocolType urlParseProtocol(const char *, const char *e = NULL);
+void urlInitialize(void);
+HttpRequest *urlParse(const HttpRequestMethod&, char *, HttpRequest *request = NULL);
+const char *urlCanonical(HttpRequest *);
+char *urlCanonicalClean(const HttpRequest *);
+const char *urlCanonicalFakeHttps(const HttpRequest * request);
+bool urlIsRelative(const char *);
+char *urlMakeAbsolute(const HttpRequest *, const char *);
+char *urlRInternal(const char *host, unsigned short port, const char *dir, const char *name);
+char *urlInternal(const char *dir, const char *name);
+int matchDomainName(const char *host, const char *domain);
+int urlCheckRequest(const HttpRequest *);
+int urlDefaultPort(AnyP::ProtocolType p);
+char *urlHostname(const char *url);
+void urlExtMethodConfigure(void);
 
 #endif /* SQUID_SRC_URL_H_H */
@@ -33,9 +33,8 @@
 
 #include "squid.h"
 #include "protos.h"
-#include "squid_windows.h"
 
-#if _SQUID_MSWIN_
+#if _SQUID_WINDOWS_
 #ifndef _MSWSOCK_
 #include <mswsock.h>
 #endif
@@ -33,12 +33,12 @@
  */
 
 #if _SQUID_WINDOWS_
-extern int WIN32_Subsystem_Init(int *, char ***);
-extern void WIN32_sendSignal(int);
-extern void WIN32_SetServiceCommandLine(void);
-extern void WIN32_InstallService(void);
-extern void WIN32_RemoveService(void);
-extern int SquidMain(int, char **);
+int WIN32_Subsystem_Init(int *, char ***);
+void WIN32_sendSignal(int);
+void WIN32_SetServiceCommandLine(void);
+void WIN32_InstallService(void);
+void WIN32_RemoveService(void);
+int SquidMain(int, char **);
 #else /* _SQUID_WINDOWS_ */
 inline int WIN32_Subsystem_Init(int *foo, char ***bar) {return 0; } /* NOP */
 inline void WIN32_sendSignal(int foo) { return; } /* NOP */
@@ -0,0 +1,43 @@
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "squid.h"
+#include "YesNoNone.h"
+
+YesNoNone::operator void*() const
+{
+    assert(option != 0); // must call configure() first
+    return option > 0 ? (void*)this : NULL;
+}
+
+void
+YesNoNone::configure(bool beSet)
+{
+    option = beSet ? +1 : -1;
+}
@@ -0,0 +1,55 @@
+#ifndef SQUID_YESNONONE_H_
+#define SQUID_YESNONONE_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+/// Used for boolean enabled/disabled options with complex default logic.
+/// Allows Squid to compute the right default after configuration.
+/// Checks that not-yet-defined option values are not used.
+class YesNoNone
+{
+// TODO: generalize to non-boolean option types
+public:
+    YesNoNone(): option(0) {}
+
+    /// returns true iff enabled; asserts if the option has not been configured
+    operator void *() const; // TODO: use a fancy/safer version of the operator
+
+    /// enables or disables the option;
+    void configure(bool beSet);
+
+    /// whether the option was enabled or disabled, by user or Squid
+    bool configured() const { return option != 0; }
+
+private:
+    enum { optUnspecified = -1, optDisabled = 0, optEnabled = 1 };
+    int option; ///< configured value or zero
+};
+
+#endif /* SQUID_YESNONONE_H_ */
@@ -37,6 +37,7 @@
 #include "Debug.h"
 #include "dlink.h"
 #include "globals.h"
+#include "SquidConfig.h"
 
 const char *AclMatchedName = NULL;
 
@@ -38,14 +38,14 @@
 #include "defines.h"
 #include "dlink.h"
 #include "MemPool.h"
-#include "structs.h"
 
 #if HAVE_OSTREAM
 #include <ostream>
 #endif
 
 class ConfigParser;
 class ACLChecklist;
+class ACLList;
 
 /// \ingroup ACLAPI
 class ACL
@@ -0,0 +1,32 @@
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ */
+
+#include "squid.h"
+#include "AclAddress.h"
+
+//TODO: fill in
@@ -0,0 +1,45 @@
+#ifndef ACLADDRESS_H_
+#define ACLADDRESS_H_
+#include "Acl.h"
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ */
+
+#include "ip/Address.h"
+#include "acl/Acl.h"
+
+/// list of address-based ACLs. Currently a POD.
+class AclAddress
+{
+public:
+    AclAddress *next;
+    ACLList *aclList;
+
+    Ip::Address addr;
+};
+
+#endif /* ACLADDRESS_H_ */
@@ -0,0 +1,46 @@
+#ifndef SQUID_ACLDENYINFOLIST_H_
+#define SQUID_ACLDENYINFOLIST_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "err_type.h"
+
+class AclNameList;
+
+/// deny_info representation. Currently a POD.
+class AclDenyInfoList
+{
+public:
+    err_type err_page_id;
+    char *err_page_name;
+    AclNameList *acl_list;
+    AclDenyInfoList *next;
+};
+
+#endif /* SQUID_ACLDENYINFOLIST_H_ */
@@ -0,0 +1,43 @@
+#ifndef SQUID_ACL_ACLNAMELIST_H_
+#define SQUID_ACL_ACLNAMELIST_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "defines.h"
+
+/// list of name-based ACLs. Currently a POD.
+class AclNameList
+{
+public:
+    char name[ACL_NAME_SZ];
+    AclNameList *next;
+};
+// TODO: convert to a std::list<string>
+
+#endif /* SQUID_ACLNAMELIST_H_ */
@@ -0,0 +1,43 @@
+#ifndef SQUID_ACLSIZELIMIT_H_
+#define SQUID_ACLSIZELIMIT_H_
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+class ACLList;
+/// representation of a class of Size-limit ACLs
+// a POD. TODO: convert to new ACL framework
+class AclSizeLimit
+{
+public:
+    AclSizeLimit *next;
+    ACLList *aclList;
+    int64_t size;
+};
+
+#endif /* SQUID_ACLSIZELIMIT_H_ */
@@ -32,21 +32,23 @@
  */
 
 #include "squid.h"
-#include "mgr/Registration.h"
-#include "radix.h"
-#include "HttpRequest.h"
-#include "StoreClient.h"
-#include "Store.h"
 #include "acl/Acl.h"
 #include "acl/Asn.h"
 #include "acl/Checklist.h"
-#include "acl/SourceAsn.h"
 #include "acl/DestinationAsn.h"
 #include "acl/DestinationIp.h"
+#include "acl/SourceAsn.h"
 #include "cache_cf.h"
+#include "forward.h"
 #include "HttpReply.h"
+#include "HttpRequest.h"
 #include "ipcache.h"
-#include "forward.h"
+#include "mgr/Registration.h"
+#include "radix.h"
+#include "RequestFlags.h"
+#include "SquidConfig.h"
+#include "Store.h"
+#include "StoreClient.h"
 #include "StoreClient.h"
 #include "wordlist.h"
 
@@ -246,8 +248,8 @@ asnCacheStart(int as)
     assert(NULL != req);
     asState->request = HTTPMSGLOCK(req);
 
-    if ((e = storeGetPublic(asres, METHOD_GET)) == NULL) {
-        e = storeCreateEntry(asres, asres, request_flags(), METHOD_GET);
+    if ((e = storeGetPublic(asres, Http::METHOD_GET)) == NULL) {
+        e = storeCreateEntry(asres, asres, RequestFlags(), Http::METHOD_GET);
         asState->sc = storeClientListAdd(e, asState);
         FwdState::fwdStart(Comm::ConnectionPointer(), e, asState->request);
     } else {
@@ -639,7 +641,7 @@ ACLDestinationASNStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist
 
         return 0;
 
-    } else if (!checklist->request->flags.destinationIPLookedUp()) {
+    } else if (!checklist->request->flags.destinationIpLookedUp) {
         /* No entry in cache, lookup not attempted */
         /* XXX FIXME: allow accessing the acl name here */
         debugs(28, 3, "asnMatchAcl: Can't yet compare '" << "unknown" /*name*/ << "' ACL for '" << checklist->request->GetHost() << "'");
@@ -38,13 +38,13 @@
 #include "acl/Checklist.h"
 #include "ip/Address.h"
 
-SQUIDCEXTERN int asnMatchIp(CbDataList<int> *, Ip::Address &);
+int asnMatchIp(CbDataList<int> *, Ip::Address &);
 
 /// \ingroup ACLAPI
-SQUIDCEXTERN void asnInit(void);
+void asnInit(void);
 
 /// \ingroup ACLAPI
-SQUIDCEXTERN void asnFreeMemory(void);
+void asnFreeMemory(void);
 
 /// \ingroup ACLAPI
 class ACLASN : public ACLData<Ip::Address>
@@ -37,7 +37,7 @@
 #include "client_side.h"
 #include "comm/Connection.h"
 #include "HttpRequest.h"
-#include "structs.h"
+#include "SquidConfig.h"
 
 char const *
 ACLDestinationIP::typeString() const
@@ -55,7 +55,7 @@ ACLDestinationIP::match(ACLChecklist *cl)
     // To resolve this we will force DIRECT and only to the original client destination.
     // In which case, we also need this ACL to accurately match the destination
     if (Config.onoff.client_dst_passthru && checklist->request &&
-            (checklist->request->flags.intercepted || checklist->request->flags.spoof_client_ip)) {
+            (checklist->request->flags.intercepted || checklist->request->flags.spoofClientIp)) {
         assert(checklist->conn() && checklist->conn()->clientConnection != NULL);
         return ACLIP::match(checklist->conn()->clientConnection->local);
     }
@@ -71,7 +71,7 @@ ACLDestinationIP::match(ACLChecklist *cl)
         }
 
         return 0;
-    } else if (!checklist->request->flags.destinationIPLookedUp()) {
+    } else if (!checklist->request->flags.destinationIpLookedUp) {
         /* No entry in cache, lookup not attempted */
         debugs(28, 3, "aclMatchAcl: Can't yet compare '" << name << "' ACL for '" << checklist->request->GetHost() << "'");
         checklist->changeState (DestinationIPLookup::Instance());
@@ -102,7 +102,7 @@ DestinationIPLookup::LookupDone(const ipcache_addrs *, const DnsLookupDetails &d
 {
     ACLFilledChecklist *checklist = Filled((ACLChecklist*)data);
     assert (checklist->asyncState() == DestinationIPLookup::Instance());
-    checklist->request->flags.destinationIPLookupCompleted();
+    checklist->request->flags.destinationIpLookedUp=true;
     checklist->request->recordLookup(details);
     checklist->asyncInProgress(false);
     checklist->changeState (ACLChecklist::NullState::Instance());
@@ -98,16 +98,24 @@ aclDomainCompare(T const &a, T const &b)
         if (ret == 0) {
             // When a.example.com comes after .example.com in an ACL
             // sub-domain is ignored. That is okay. Just important
-            debugs(28, DBG_IMPORTANT, "WARNING: '" << d3 << "' is a subdomain of '" << d4 << "'");
-            debugs(28, DBG_IMPORTANT, "WARNING: because of this '" << d3 << "' is ignored to keep splay tree searching predictable");
-            debugs(28, DBG_IMPORTANT, "WARNING: You should remove '" << (*d3=='.'?d4:d3) << "' from the ACL named '" << AclMatchedName << "'");
+            bool d3big = (strlen(d3) > strlen(d4)); // Always suggest removing the longer one.
+            debugs(28, DBG_IMPORTANT, "WARNING: '" << (d3big?d3:d4) << "' is a subdomain of '" << (d3big?d4:d3) << "'");
+            debugs(28, DBG_IMPORTANT, "WARNING: You should remove '" << (d3big?d3:d4) << "' from the ACL named '" << AclMatchedName << "'");
+            debugs(28, 2, HERE << "Ignore '" << d3 << "' to keep splay tree searching predictable");
         }
     } else if (ret == 0) {
+        // It may be an exact duplicate. No problem. Just drop.
+        if (strcmp(d1,d2)==0) {
+            debugs(28, 2, "WARNING: '" << d2 << "' is duplicated in the list.");
+            debugs(28, 2, "WARNING: You should remove one '" << d2 << "' from the ACL named '" << AclMatchedName << "'");
+            return ret;
+        }
         // When a.example.com comes before .example.com in an ACL
         // discarding the wildcard is critically bad.
-        debugs(28, DBG_CRITICAL, "ERROR: '" << d1 << "' is a subdomain of '" << d2 << "'");
-        debugs(28, DBG_CRITICAL, "ERROR: because of this '" << d2 << "' is ignored to keep splay tree searching predictable");
-        debugs(28, DBG_CRITICAL, "ERROR: You should remove '" << (*d1=='.'?d2:d1) << "' from the ACL named '" << AclMatchedName << "'");
+        // or Maybe even both are wildcards. Things are very weird in those cases.
+        bool d1big = (strlen(d1) > strlen(d2)); // Always suggest removing the longer one.
+        debugs(28, DBG_CRITICAL, "ERROR: '" << (d1big?d1:d2) << "' is a subdomain of '" << (d1big?d2:d1) << "'");
+        debugs(28, DBG_CRITICAL, "ERROR: You need to remove '" << (d1big?d1:d2) << "' from the ACL named '" << AclMatchedName << "'");
         self_destruct();
     }
 
@@ -5,6 +5,7 @@
 #include "comm/forward.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
+#include "SquidConfig.h"
 #if USE_AUTH
 #include "auth/UserRequest.h"
 #include "auth/AclProxyAuth.h"
@@ -2,16 +2,19 @@
 #define SQUID_ACLFILLED_CHECKLIST_H
 
 #include "acl/Checklist.h"
+#include "ip/Address.h"
 #if USE_AUTH
 #include "auth/UserRequest.h"
 #endif
 #if USE_SSL
 #include "ssl/support.h"
 #endif
 
-class ExternalACLEntry;
+class CachePeer;
 class ConnStateData;
+class ExternalACLEntry;
 class HttpRequest;
+class HttpReply;
 
 /** \ingroup ACLAPI
     ACLChecklist filled with specific data, representing Squid and transaction
@@ -27,14 +30,15 @@ class ACLFilledChecklist: public ACLChecklist
     ~ACLFilledChecklist();
 
 public:
+    /// The client connection manager
     ConnStateData * conn() const;
 
-    /// uses conn() if available
+    /// The client side fd. It uses conn() if available
     int fd() const;
 
     /// set either conn
     void conn(ConnStateData *);
-    /// set FD
+    /// set the client side FD
     void fd(int aDescriptor);
 
     //int authenticated();
@@ -52,7 +56,7 @@ class ACLFilledChecklist: public ACLChecklist
     Ip::Address src_addr;
     Ip::Address dst_addr;
     Ip::Address my_addr;
-    struct peer *dst_peer;
+    CachePeer *dst_peer;
     char *dst_rdns;
 
     HttpRequest *request;
@@ -38,6 +38,8 @@
 
 #include "squid.h"
 #include "acl/Acl.h"
+#include "acl/AclNameList.h"
+#include "acl/AclDenyInfoList.h"
 #include "acl/Checklist.h"
 #include "acl/Strategised.h"
 #include "acl/Gadgets.h"
@@ -49,14 +51,14 @@
 
 /* does name lookup, returns page_id */
 err_type
-aclGetDenyInfoPage(acl_deny_info_list ** head, const char *name, int redirect_allowed)
+aclGetDenyInfoPage(AclDenyInfoList ** head, const char *name, int redirect_allowed)
 {
-    acl_deny_info_list *A = NULL;
+    AclDenyInfoList *A = NULL;
 
     debugs(28, 8, HERE << "got called for " << name);
 
     for (A = *head; A; A = A->next) {
-        acl_name_list *L = NULL;
+        AclNameList *L = NULL;
 
         if (!redirect_allowed && strchr(A->err_page_name, ':') ) {
             debugs(28, 8, HERE << "Skip '" << A->err_page_name << "' 30x redirects not allowed as response here.");
@@ -106,14 +108,14 @@ aclIsProxyAuth(const char *name)
  */
 
 void
-aclParseDenyInfoLine(acl_deny_info_list ** head)
+aclParseDenyInfoLine(AclDenyInfoList ** head)
 {
     char *t = NULL;
-    acl_deny_info_list *A = NULL;
-    acl_deny_info_list *B = NULL;
-    acl_deny_info_list **T = NULL;
-    acl_name_list *L = NULL;
-    acl_name_list **Tail = NULL;
+    AclDenyInfoList *A = NULL;
+    AclDenyInfoList *B = NULL;
+    AclDenyInfoList **T = NULL;
+    AclNameList *L = NULL;
+    AclNameList **Tail = NULL;
 
     /* first expect a page name */
 
@@ -123,15 +125,15 @@ aclParseDenyInfoLine(acl_deny_info_list ** head)
         return;
     }
 
-    A = (acl_deny_info_list *)memAllocate(MEM_ACL_DENY_INFO_LIST);
+    A = (AclDenyInfoList *)memAllocate(MEM_ACL_DENY_INFO_LIST);
     A->err_page_id = errorReservePageId(t);
     A->err_page_name = xstrdup(t);
-    A->next = (acl_deny_info_list *) NULL;
+    A->next = (AclDenyInfoList *) NULL;
     /* next expect a list of ACL names */
     Tail = &A->acl_list;
 
     while ((t = strtok(NULL, w_space))) {
-        L = (acl_name_list *)memAllocate(MEM_ACL_NAME_LIST);
+        L = (AclNameList *)memAllocate(MEM_ACL_NAME_LIST);
         xstrncpy(L->name, t, ACL_NAME_SZ);
         *Tail = L;
         Tail = &L->next;
@@ -280,15 +282,15 @@ aclDestroyAccessList(acl_access ** list)
 }
 
 /* maex@space.net (06.09.1996)
- *    destroy an acl_deny_info_list */
+ *    destroy an AclDenyInfoList */
 
 void
-aclDestroyDenyInfoList(acl_deny_info_list ** list)
+aclDestroyDenyInfoList(AclDenyInfoList ** list)
 {
-    acl_deny_info_list *a = NULL;
-    acl_deny_info_list *a_next = NULL;
-    acl_name_list *l = NULL;
-    acl_name_list *l_next = NULL;
+    AclDenyInfoList *a = NULL;
+    AclDenyInfoList *a_next = NULL;
+    AclNameList *l = NULL;
+    AclNameList *l_next = NULL;
 
     debugs(28, 8, "aclDestroyDenyInfoList: invoked");
 
@@ -4,39 +4,39 @@
 #include "err_type.h"
 
 struct dlink_list;
-class StoreEntry;
-class ConfigParser;
 class acl_access;
 class ACL;
+class AclDenyInfoList;
 class ACLList;
-struct acl_deny_info_list;
+class ConfigParser;
+class StoreEntry;
 class wordlist;
 
 /// \ingroup ACLAPI
-extern void aclDestroyAccessList(acl_access **list);
+void aclDestroyAccessList(acl_access **list);
 /// \ingroup ACLAPI
-extern void aclDestroyAcls(ACL **);
+void aclDestroyAcls(ACL **);
 /// \ingroup ACLAPI
-extern void aclDestroyAclList(ACLList **);
+void aclDestroyAclList(ACLList **);
 /// \ingroup ACLAPI
-extern void aclParseAccessLine(ConfigParser &parser, acl_access **);
+void aclParseAccessLine(ConfigParser &parser, acl_access **);
 /// \ingroup ACLAPI
-extern void aclParseAclList(ConfigParser &parser, ACLList **);
+void aclParseAclList(ConfigParser &parser, ACLList **);
 /// \ingroup ACLAPI
-extern int aclIsProxyAuth(const char *name);
+int aclIsProxyAuth(const char *name);
 /// \ingroup ACLAPI
-extern err_type aclGetDenyInfoPage(acl_deny_info_list ** head, const char *name, int redirect_allowed);
+err_type aclGetDenyInfoPage(AclDenyInfoList ** head, const char *name, int redirect_allowed);
 /// \ingroup ACLAPI
-extern void aclParseDenyInfoLine(acl_deny_info_list **);
+void aclParseDenyInfoLine(AclDenyInfoList **);
 /// \ingroup ACLAPI
-extern void aclDestroyDenyInfoList(acl_deny_info_list **);
+void aclDestroyDenyInfoList(AclDenyInfoList **);
 /// \ingroup ACLAPI
-extern wordlist *aclDumpGeneric(const ACL *);
+wordlist *aclDumpGeneric(const ACL *);
 /// \ingroup ACLAPI
-extern void aclCacheMatchFlush(dlink_list * cache);
+void aclCacheMatchFlush(dlink_list * cache);
 /// \ingroup ACLAPI
-extern void dump_acl_access(StoreEntry * entry, const char *name, acl_access * head);
+void dump_acl_access(StoreEntry * entry, const char *name, acl_access * head);
 /// \ingroup ACLAPI
-extern void dump_acl_list(StoreEntry * entry, ACLList * head);
+void dump_acl_list(StoreEntry * entry, ACLList * head);
 
 #endif /* SQUID_ACL_GADGETS_H */
@@ -469,6 +469,7 @@ acl_ip_data::FactoryParse(const char *t)
     /* ignore IPv6 addresses when built with IPv4-only */
     if ( iptype == AF_INET6 && !Ip::EnableIpv6) {
         debugs(28, DBG_IMPORTANT, "aclIpParseIpData: IPv6 has not been enabled.");
+        delete q;
         return NULL;
     }
 
@@ -17,9 +17,10 @@ libstate_la_SOURCES = \
 	Strategy.h \
 	Strategised.cc \
 	Strategised.h \
-	\
 	FilledChecklist.cc \
-	FilledChecklist.h
+	FilledChecklist.h \
+	AclAddress.h \
+	AclAddress.cc
 
 ## data-specific ACLs
 libacls_la_SOURCES = \
@@ -33,7 +34,6 @@ libacls_la_SOURCES = \
 	Time.h \
 	TimeData.cc \
 	TimeData.h \
-	\
 	Asn.cc \
 	Asn.h \
 	Browser.cc \
@@ -98,15 +98,19 @@ libacls_la_SOURCES = \
 	Tag.h \
 	Url.cc \
 	Url.h \
+	UrlLogin.cc \
+	UrlLogin.h \
 	UrlPath.cc \
 	UrlPath.h \
 	UrlPort.cc \
 	UrlPort.h \
 	UserData.cc \
 	UserData.h \
-	\
+	AclNameList.h \
+	AclDenyInfoList.h \
 	Gadgets.cc \
-	Gadgets.h
+	Gadgets.h \
+	AclSizeLimit.h
 
 ## Add conditional sources
 ## TODO: move these to their respectful dirs when those dirs are created
@@ -38,6 +38,7 @@
 #include "cache_cf.h"
 #include "client_db.h"
 #include "Debug.h"
+#include "SquidConfig.h"
 #include "wordlist.h"
 
 ACL *
@@ -3,6 +3,7 @@
 #include "acl/RegexData.h"
 #include "acl/StringData.h"
 #include "acl/Checklist.h"
+#include "CachePeer.h"
 
 int
 ACLPeerNameStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist)
@@ -41,12 +41,13 @@
 #include "ConfigParser.h"
 #include "Debug.h"
 #include "Mem.h"
+#include "RegexList.h"
 #include "wordlist.h"
 
 static void
-aclDestroyRegexList(relist * data)
+aclDestroyRegexList(RegexList * data)
 {
-    relist *next = NULL;
+    RegexList *next = NULL;
 
     for (; data; data = next) {
         next = data->next;
@@ -69,13 +70,13 @@ ACLRegexData::match(char const *word)
 
     debugs(28, 3, "aclRegexData::match: checking '" << word << "'");
 
-    relist *first, *prev;
+    RegexList *first, *prev;
 
     first = data;
 
     prev = NULL;
 
-    relist *current = first;
+    RegexList *current = first;
 
     while (current) {
         debugs(28, 3, "aclRegexData::match: looking for '" << current->pattern << "'");
@@ -104,7 +105,7 @@ wordlist *
 ACLRegexData::dump()
 {
     wordlist *W = NULL;
-    relist *temp = data;
+    RegexList *temp = data;
     int flags = REG_EXTENDED | REG_NOSUB;
 
     while (temp != NULL) {
@@ -152,11 +153,11 @@ removeUnnecessaryWildcards(char * t)
     return t;
 }
 
-static relist **
-compileRE(relist **Tail, char * RE, int flags)
+static RegexList **
+compileRE(RegexList **Tail, char * RE, int flags)
 {
     int errcode;
-    relist *q;
+    RegexList *q;
     regex_t comp;
 
     if (RE == NULL  ||  *RE == '\0')
@@ -171,7 +172,7 @@ compileRE(relist **Tail, char * RE, int flags)
     }
     debugs(28, 2, "compileRE: compiled '" << RE << "' with flags " << flags );
 
-    q = (relist *) memAllocate(MEM_RELIST);
+    q = (RegexList *) memAllocate(MEM_RELIST);
     q->pattern = xstrdup(RE);
     q->regex = comp;
     q->flags = flags;
@@ -186,11 +187,11 @@ compileRE(relist **Tail, char * RE, int flags)
  * called only once per ACL.
  */
 static int
-compileOptimisedREs(relist **curlist, wordlist * wl)
+compileOptimisedREs(RegexList **curlist, wordlist * wl)
 {
-    relist **Tail;
-    relist *newlist;
-    relist **newlistp;
+    RegexList **Tail;
+    RegexList *newlist;
+    RegexList **newlistp;
     int numREs = 0;
     int flags = REG_EXTENDED | REG_NOSUB;
     int largeREindex = 0;
@@ -288,10 +289,10 @@ compileOptimisedREs(relist **curlist, wordlist * wl)
 }
 
 static void
-compileUnoptimisedREs(relist **curlist, wordlist * wl)
+compileUnoptimisedREs(RegexList **curlist, wordlist * wl)
 {
-    relist **Tail;
-    relist **newTail;
+    RegexList **Tail;
+    RegexList **newTail;
     int flags = REG_EXTENDED | REG_NOSUB;
 
     for (Tail = curlist; *Tail != NULL; Tail = &((*Tail)->next))
@@ -314,7 +315,7 @@ compileUnoptimisedREs(relist **curlist, wordlist * wl)
 }
 
 static void
-aclParseRegexList(relist **curlist)
+aclParseRegexList(RegexList **curlist)
 {
     char *t;
     wordlist *wl = NULL;
@@ -35,8 +35,7 @@
 #include "acl/Data.h"
 #include "MemPool.h"
 
-/** \todo CLEANUP: break out relist, we don't need the rest. */
-#include "structs.h"
+class RegexList;
 
 class ACLRegexData : public ACLData<char const *>
 {
@@ -52,7 +51,7 @@ class ACLRegexData : public ACLData<char const *>
     virtual ACLData<char const *> *clone() const;
 
 private:
-    relist *data;
+    RegexList *data;
 };
 
 MEMPROXY_CLASS_INLINE(ACLRegexData);
@@ -1,8 +1,3 @@
-
-/*
- * $Id$
- */
-
 #include "squid.h"
 #include "acl/SslError.h"
 #include "acl/SslErrorData.h"
@@ -1,8 +1,3 @@
-
-/*
- * $Id$
- */
-
 #ifndef SQUID_ACLSSL_ERROR_H
 #define SQUID_ACLSSL_ERROR_H
 #include "acl/Strategy.h"
@@ -1,8 +1,3 @@
-
-/*
- * $Id$
- */
-
 #ifndef SQUID_ACLSSL_ERRORDATA_H
 #define SQUID_ACLSSL_ERRORDATA_H
 #include "acl/Acl.h"
@@ -34,6 +34,7 @@
 
 #include "squid.h"
 #include "acl/Strategised.h"
+#include "HttpHeader.h"
 
 /*
  *  moved template instantiation into ACLStrategized.cc
@@ -0,0 +1,56 @@
+/*
+ * DEBUG: section 28    Access Control
+ * AUTHOR: Duane Wessels
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+
+#include "squid.h"
+#include "acl/UrlLogin.h"
+#include "acl/Checklist.h"
+#include "acl/RegexData.h"
+#include "HttpRequest.h"
+#include "rfc1738.h"
+
+int
+ACLUrlLoginStrategy::match (ACLData<char const *> * &data, ACLFilledChecklist *checklist)
+{
+    char *esc_buf = xstrdup(checklist->request->login);
+    rfc1738_unescape(esc_buf);
+    int result = data->match(esc_buf);
+    safe_free(esc_buf);
+    return result;
+}
+
+ACLUrlLoginStrategy *
+ACLUrlLoginStrategy::Instance()
+{
+    return &Instance_;
+}
+
+ACLUrlLoginStrategy ACLUrlLoginStrategy::Instance_;
@@ -0,0 +1,73 @@
+
+/*
+ * $Id$
+ *
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ *
+ * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
+ */
+
+#ifndef SQUID_ACLURLLOGIN_H
+#define SQUID_ACLURLLOGIN_H
+
+#include "acl/Acl.h"
+#include "acl/Data.h"
+#include "acl/Strategy.h"
+#include "acl/Strategised.h"
+
+class ACLUrlLoginStrategy : public ACLStrategy<char const *>
+{
+
+public:
+    virtual int match (ACLData<char const *> * &, ACLFilledChecklist *);
+    virtual bool requiresRequest() const {return true;}
+
+    static ACLUrlLoginStrategy *Instance();
+    /* Not implemented to prevent copies of the instance. */
+    /* Not private to prevent brain dead g+++ warnings about
+     * private constructors with no friends */
+    ACLUrlLoginStrategy(ACLUrlLoginStrategy const &);
+
+private:
+    static ACLUrlLoginStrategy Instance_;
+    ACLUrlLoginStrategy() {}
+
+    ACLUrlLoginStrategy&operator=(ACLUrlLoginStrategy const &);
+};
+
+class ACLUrlLogin
+{
+
+public:
+    static ACL::Prototype RegistryProtoype;
+    static ACL::Prototype LegacyRegistryProtoype;
+    static ACLStrategised<char const *> RegistryEntry_;
+};
+
+#endif /* SQUID_ACLURLLOGIN_H */
@@ -12,7 +12,6 @@
 #include "globals.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
-#include "structs.h"
 
 /** \cond AUTODOCS-IGNORE */
 cbdata_type Adaptation::AccessCheck::CBDATA_AccessCheck = CBDATA_UNKNOWN;
@@ -1,10 +1,9 @@
 #include "squid.h"
-#include "structs.h"
-#include "ConfigParser.h"
 #include "acl/Gadgets.h"
 #include "adaptation/AccessRule.h"
 #include "adaptation/Service.h"
 #include "adaptation/ServiceGroups.h"
+#include "ConfigParser.h"
 #include "Debug.h"
 
 int Adaptation::AccessRule::LastId = 0;
@@ -35,9 +35,9 @@ class AccessRule
 };
 
 typedef Vector<Adaptation::AccessRule*> AccessRules;
-extern AccessRules &AllRules();
-extern AccessRule *FindRule(const AccessRule::Id &id);
-extern AccessRule *FindRuleByGroupId(const String &groupId);
+AccessRules &AllRules();
+AccessRule *FindRule(const AccessRule::Id &id);
+AccessRule *FindRuleByGroupId(const String &groupId);
 
 } // namespace Adaptation
 
@@ -42,61 +42,31 @@
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "Store.h"
-#include "structs.h"
 
 bool Adaptation::Config::Enabled = false;
 char *Adaptation::Config::masterx_shared_name = NULL;
 int Adaptation::Config::service_iteration_limit = 16;
 int Adaptation::Config::send_client_ip = false;
 int Adaptation::Config::send_username = false;
 int Adaptation::Config::use_indirect_client = true;
-Adaptation::Config::MetaHeaders Adaptation::Config::metaHeaders;
-
-Adaptation::Config::MetaHeader::Value::~Value()
-{
-    aclDestroyAclList(&aclList);
-}
-
-Adaptation::Config::MetaHeader::Value::Pointer
-Adaptation::Config::MetaHeader::addValue(const String &value)
-{
-    Value::Pointer v = new Value(value);
-    values.push_back(v);
-    return v;
-}
-
-const char *
-Adaptation::Config::MetaHeader::match(HttpRequest *request, HttpReply *reply)
-{
-
-    typedef Values::iterator VLI;
-    ACLFilledChecklist ch(NULL, request, NULL);
-    if (reply)
-        ch.reply = HTTPMSGLOCK(reply);
-
-    for (VLI i = values.begin(); i != values.end(); ++i ) {
-        const int ret= ch.fastCheck((*i)->aclList);
-        debugs(93, 5, HERE << "Check for header name: " << name << ": " << (*i)->value
-               <<", HttpRequest: " << request << " HttpReply: " << reply << " matched: " << ret);
-        if (ret == ACCESS_ALLOWED)
-            return (*i)->value.termedBuf();
-    }
-    return NULL;
-}
-
-Adaptation::Config::MetaHeader::Pointer
-Adaptation::Config::addMetaHeader(const String &headerName)
-{
-    typedef MetaHeaders::iterator AMLI;
-    for (AMLI i = metaHeaders.begin(); i != metaHeaders.end(); ++i) {
-        if ((*i)->name == headerName)
-            return (*i);
-    }
-
-    MetaHeader::Pointer meta = new MetaHeader(headerName);
-    metaHeaders.push_back(meta);
-    return meta;
-}
+const char *metasBlacklist[] = {
+    "Methods",
+    "Service",
+    "ISTag",
+    "Encapsulated",
+    "Opt-body-type",
+    "Max-Connections",
+    "Options-TTL",
+    "Date",
+    "Service-ID",
+    "Allow",
+    "Preview",
+    "Transfer-Preview",
+    "Transfer-Ignore",
+    "Transfer-Complete",
+    NULL
+};
+Notes Adaptation::Config::metaHeaders("ICAP header", metasBlacklist);
 
 Adaptation::ServiceConfig*
 Adaptation::Config::newServiceConfig() const
@@ -181,8 +151,6 @@ Adaptation::Config::freeService()
     DetachServices();
 
     serviceConfigs.clean();
-
-    FreeMetaHeader();
 }
 
 void
@@ -256,64 +224,6 @@ Adaptation::Config::Finalize(bool enabled)
     FinalizeEach(AllRules(), "message adaptation access rules");
 }
 
-void
-Adaptation::Config::ParseMetaHeader(ConfigParser &parser)
-{
-    String name, value;
-    const char *warnFor[] = {
-        "Methods",
-        "Service",
-        "ISTag",
-        "Encapsulated",
-        "Opt-body-type",
-        "Max-Connections",
-        "Options-TTL",
-        "Date",
-        "Service-ID",
-        "Allow",
-        "Preview",
-        "Transfer-Preview",
-        "Transfer-Ignore",
-        "Transfer-Complete",
-        NULL
-    };
-    ConfigParser::ParseString(&name);
-    ConfigParser::ParseQuotedString(&value);
-
-    // TODO: Find a way to move this check to ICAP
-    for (int i = 0; warnFor[i] != NULL; ++i) {
-        if (name.caseCmp(warnFor[i]) == 0) {
-            fatalf("%s:%d: meta name \"%s\" is a reserved ICAP header name",
-                   cfg_filename, config_lineno, name.termedBuf());
-        }
-    }
-
-    MetaHeader::Pointer meta = addMetaHeader(name);
-    MetaHeader::Value::Pointer headValue = meta->addValue(value);
-    aclParseAclList(parser, &headValue->aclList);
-}
-
-void
-Adaptation::Config::DumpMetaHeader(StoreEntry *entry, const char *name)
-{
-    typedef MetaHeaders::iterator AMLI;
-    for (AMLI m = metaHeaders.begin(); m != metaHeaders.end(); ++m) {
-        typedef MetaHeader::Values::iterator VLI;
-        for (VLI v =(*m)->values.begin(); v != (*m)->values.end(); ++v ) {
-            storeAppendPrintf(entry, "%s " SQUIDSTRINGPH " %s",
-                              name, SQUIDSTRINGPRINT((*m)->name), ConfigParser::QuoteString((*v)->value));
-            dump_acl_list(entry, (*v)->aclList);
-            storeAppendPrintf(entry, "\n");
-        }
-    }
-}
-
-void
-Adaptation::Config::FreeMetaHeader()
-{
-    metaHeaders.clean();
-}
-
 void
 Adaptation::Config::ParseServiceSet()
 {
@@ -6,6 +6,7 @@
 #include "base/AsyncCall.h"
 #include "adaptation/forward.h"
 #include "adaptation/Elements.h"
+#include "Notes.h"
 #include "SquidString.h"
 
 class acl_access;
@@ -23,9 +24,6 @@ class Config
 
     static void ParseServiceSet(void);
     static void ParseServiceChain(void);
-    static void ParseMetaHeader(ConfigParser &parser);
-    static void FreeMetaHeader();
-    static void DumpMetaHeader(StoreEntry *, const char *);
 
     static void ParseAccess(ConfigParser &parser);
     static void FreeAccess(void);
@@ -50,53 +48,7 @@ class Config
     time_t oldest_service_failure;
     int service_revival_delay;
 
-    /**
-     * Used to store meta headers. The meta headers are custom
-     * ICAP request headers or ECAP options used to pass custom
-     * transaction-state related meta information to a service.
-     */
-    class MetaHeader: public RefCountable
-    {
-    public:
-        typedef RefCount<MetaHeader> Pointer;
-        /// Stores a value for the meta header.
-        class Value: public RefCountable
-        {
-        public:
-            typedef RefCount<Value> Pointer;
-            String value; ///< a header value
-            ACLList *aclList; ///< The access list used to determine if this value is valid for a request
-            explicit Value(const String &aVal) : value(aVal), aclList(NULL) {}
-            ~Value();
-        };
-        typedef Vector<Value::Pointer> Values;
-
-        explicit MetaHeader(const String &aName): name(aName) {}
-
-        /**
-         * Adds a value to the meta header and returns a  pointer to the
-         * related Value object.
-         */
-        Value::Pointer addValue(const String &value);
-
-        /**
-         * Walks through the  possible values list of the  meta and selects
-         * the first value which matches the given HttpRequest and HttpReply
-         * or NULL if none matches.
-         */
-        const char *match(HttpRequest *request, HttpReply *reply);
-        String name; ///< The meta header name
-        Values values; ///< The possible values list for the meta header
-    };
-    typedef Vector<MetaHeader::Pointer> MetaHeaders;
-    static MetaHeaders metaHeaders; ///< The list of configured meta headers
-
-    /**
-     * Adds a header to the meta headers list and returns a pointer to the
-     * related metaHeaders object. If the header name already exists in list,
-     * returns a pointer to the existing object.
-     */
-    static MetaHeader::Pointer addMetaHeader(const String &header);
+    static Notes metaHeaders; ///< The list of configured meta headers
 
     typedef Vector<ServiceConfigPointer> ServiceConfigs;
     ServiceConfigs serviceConfigs;
@@ -11,8 +11,8 @@ typedef enum { pointNone, pointPreCache, pointPostCache } VectPoint;
 typedef enum { srvBlock, srvBypass, srvWait, srvForce} SrvBehaviour;
 
 extern const char *crlf;
-extern const char *methodStr(Method); // TODO: make into a stream operator?
-extern const char *vectPointStr(VectPoint); // TODO: make into a stream op?
+const char *methodStr(Method); // TODO: make into a stream operator?
+const char *vectPointStr(VectPoint); // TODO: make into a stream op?
 
 } // namespace Adaptation
 
@@ -3,8 +3,9 @@
 
 #include "adaptation/DynamicGroupCfg.h"
 #include "Array.h"
+#include "base/RefCount.h"
 #include "HttpHeader.h"
-#include "RefCount.h"
+#include "Notes.h"
 #include "SquidString.h"
 
 namespace Adaptation
@@ -50,6 +51,9 @@ class History: public RefCountable
     HttpHeader lastMeta;
     /// All REQMOD and RESPMOD meta headers merged. Last field wins conflicts.
     HttpHeader allMeta;
+    /// key:value pairs set by adaptation_meta, to be added to
+    /// AccessLogEntry::notes when ALE becomes available
+    NotePairs metaHeaders;
 
     /// sets future services for the Adaptation::AccessCheck to notice
     void setFutureServices(const DynamicGroupCfg &services);
@@ -1,12 +1,7 @@
-
-/*
- * $Id$
- */
-
 #ifndef SQUID__ADAPTATION__MESSAGE_H
 #define SQUID__ADAPTATION__MESSAGE_H
 
-#include "RefCount.h"
+#include "base/RefCount.h"
 
 class HttpMsg;
 class BodyPipe;
@@ -2,10 +2,10 @@
 #define SQUID_ADAPTATION__SERVICE_H
 
 #include "SquidString.h"
-#include "RefCount.h"
 #include "adaptation/forward.h"
 #include "adaptation/Elements.h"
 #include "adaptation/ServiceConfig.h"
+#include "base/RefCount.h"
 
 // TODO: Move src/ICAP/ICAPServiceRep.h API comments here and update them
 
@@ -61,11 +61,11 @@ class Service: public RefCountable
 typedef Service::Pointer ServicePointer;
 
 typedef Vector<Adaptation::ServicePointer> Services;
-extern Services &AllServices();
-extern ServicePointer FindService(const Service::Id &key);
+Services &AllServices();
+ServicePointer FindService(const Service::Id &key);
 
 /// detach all adaptation services from current configuration
-extern void DetachServices();
+void DetachServices();
 
 } // namespace Adaptation
 
@@ -82,11 +82,11 @@ Adaptation::ServiceConfig::parse()
         if (strcmp(option, "0") == 0) { // backward compatibility
             name = "bypass";
             value = "off";
-            debugs(3, opt_parse_cfg_only?0:1, "UPGRADE: Please use 'bypass=off' option to disable service bypass");
+            debugs(3, DBG_PARSE_NOTE(DBG_IMPORTANT), "UPGRADE: Please use 'bypass=off' option to disable service bypass");
         }  else if (strcmp(option, "1") == 0) { // backward compatibility
             name = "bypass";
             value = "on";
-            debugs(3, opt_parse_cfg_only?0:1, "UPGRADE: Please use 'bypass=on' option to enable service bypass");
+            debugs(3, DBG_PARSE_NOTE(DBG_IMPORTANT), "UPGRADE: Please use 'bypass=on' option to enable service bypass");
         } else {
             char *eq = strstr(option, "=");
             const char *sffx = strstr(option, "://");
@@ -117,7 +117,7 @@ Adaptation::ServiceConfig::parse()
         else if (strcmp(name, "ipv6") == 0) {
             grokked = grokBool(ipv6, name, value);
             if (grokked && ipv6 && !Ip::EnableIpv6)
-                debugs(3, DBG_IMPORTANT, "WARNING: IPv6 is disabled. ICAP service option ignored.");
+                debugs(3, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: IPv6 is disabled. ICAP service option ignored.");
         } else if (strcmp(name, "max-conn") == 0)
             grokked = grokLong(maxConn, name, value);
         else if (strcmp(name, "on-overload") == 0) {
@@ -2,7 +2,7 @@
 #define SQUID_ADAPTATION__SERVICE_CONFIG_H
 
 #include "SquidString.h"
-#include "RefCount.h"
+#include "base/RefCount.h"
 #include "adaptation/Elements.h"
 
 namespace Adaptation
@@ -3,9 +3,9 @@
 
 #include "SquidString.h"
 #include "Array.h"
-#include "RefCount.h"
 #include "adaptation/Elements.h"
 #include "adaptation/forward.h"
+#include "base/RefCount.h"
 
 namespace Adaptation
 {
@@ -142,8 +142,8 @@ std::ostream &operator <<(std::ostream &os, const ServicePlan &p)
 }
 
 typedef Vector<ServiceGroupPointer> Groups;
-extern Groups &AllGroups();
-extern ServiceGroupPointer FindGroup(const ServiceGroup::Id &id);
+Groups &AllGroups();
+ServiceGroupPointer FindGroup(const ServiceGroup::Id &id);
 
 } // namespace Adaptation
 
@@ -1,5 +1,4 @@
 /*
- * $Id$
  * DEBUG: section 93    eCAP Interface
  */
 #include "squid.h"
@@ -1,5 +1,4 @@
 /*
- * $Id$
  * DEBUG: section 93    eCAP Interface
  */
 
@@ -1,5 +1,4 @@
 /*
- * $Id$
  * DEBUG: section 93    eCAP Interface
  */
 
@@ -225,9 +225,9 @@ Adaptation::Ecap::RequestLineRep::method(const Name &aMethod)
 {
     if (aMethod.assignedHostId()) {
         const int id = aMethod.hostId();
-        Must(METHOD_NONE < id && id < METHOD_ENUM_END);
-        Must(id != METHOD_OTHER);
-        theMessage.method = HttpRequestMethod(static_cast<_method_t>(id));
+        Must(Http::METHOD_NONE < id && id < Http::METHOD_ENUM_END);
+        Must(id != Http::METHOD_OTHER);
+        theMessage.method = HttpRequestMethod(static_cast<Http::MethodType>(id));
     } else {
         const std::string &image = aMethod.image();
         theMessage.method = HttpRequestMethod(image.data(),
@@ -239,19 +239,19 @@ Adaptation::Ecap::RequestLineRep::Name
 Adaptation::Ecap::RequestLineRep::method() const
 {
     switch (theMessage.method.id()) {
-    case METHOD_GET:
+    case Http::METHOD_GET:
         return libecap::methodGet;
-    case METHOD_POST:
+    case Http::METHOD_POST:
         return libecap::methodPost;
-    case METHOD_PUT:
+    case Http::METHOD_PUT:
         return libecap::methodPut;
-    case METHOD_HEAD:
+    case Http::METHOD_HEAD:
         return libecap::methodHead;
-    case METHOD_CONNECT:
+    case Http::METHOD_CONNECT:
         return libecap::methodConnect;
-    case METHOD_DELETE:
+    case Http::METHOD_DELETE:
         return libecap::methodDelete;
-    case METHOD_TRACE:
+    case Http::METHOD_TRACE:
         return libecap::methodTrace;
     default:
         return Name(theMessage.method.image());
@@ -1,5 +1,4 @@
 /*
- * $Id$
  * DEBUG: section 93    eCAP Interface
  */
 
@@ -1,5 +1,4 @@
 /*
- * $Id$
  * DEBUG: section 93    eCAP Interface
  */
 
@@ -49,15 +48,15 @@ class ServiceRep : public Adaptation::Service
 };
 
 /// register loaded eCAP module service
-extern void RegisterAdapterService(const ServiceRep::AdapterService& adapterService);
+void RegisterAdapterService(const ServiceRep::AdapterService& adapterService);
 /// unregister loaded eCAP module service by service uri
-extern void UnregisterAdapterService(const String& serviceUri);
+void UnregisterAdapterService(const String& serviceUri);
 
 /// returns loaded eCAP module service by service uri
-extern ServiceRep::AdapterService FindAdapterService(const String& serviceUri);
+ServiceRep::AdapterService FindAdapterService(const String& serviceUri);
 
 /// check for loaded eCAP services without matching ecap_service in squid.conf
-extern void CheckUnusedAdapterServices(const Services& services);
+void CheckUnusedAdapterServices(const Services& services);
 } // namespace Ecap
 } // namespace Adaptation
 
@@ -177,9 +177,9 @@ Adaptation::Ecap::XactionRep::metaValue(const libecap::Name &name) const
     HttpReply *reply = dynamic_cast<HttpReply*>(theVirginRep.raw().header);
 
     if (name.known()) { // must check to avoid empty names matching unset cfg
-        typedef Adaptation::Config::MetaHeaders::iterator ACAMLI;
+        typedef Notes::iterator ACAMLI;
         for (ACAMLI i = Adaptation::Config::metaHeaders.begin(); i != Adaptation::Config::metaHeaders.end(); ++i) {
-            if (name == (*i)->name.termedBuf()) {
+            if (name == (*i)->key.termedBuf()) {
                 if (const char *value = (*i)->match(request, reply))
                     return libecap::Area::FromTempString(value);
                 else
@@ -199,11 +199,11 @@ Adaptation::Ecap::XactionRep::visitEachMetaHeader(libecap::NamedValueVisitor &vi
     Must(request);
     HttpReply *reply = dynamic_cast<HttpReply*>(theVirginRep.raw().header);
 
-    typedef Adaptation::Config::MetaHeaders::iterator ACAMLI;
+    typedef Notes::iterator ACAMLI;
     for (ACAMLI i = Adaptation::Config::metaHeaders.begin(); i != Adaptation::Config::metaHeaders.end(); ++i) {
         const char *v = (*i)->match(request, reply);
         if (v) {
-            const libecap::Name name((*i)->name.termedBuf());
+            const libecap::Name name((*i)->key.termedBuf());
             const libecap::Area value = libecap::Area::FromTempString(v);
             visitor.visit(name, value);
         }
@@ -218,13 +218,23 @@ Adaptation::Ecap::XactionRep::start()
     if (!theVirginRep.raw().body_pipe)
         makingVb = opNever; // there is nothing to deliver
 
-    const HttpRequest *request = dynamic_cast<const HttpRequest*> (theCauseRep ?
-                                 theCauseRep->raw().header : theVirginRep.raw().header);
+    HttpRequest *request = dynamic_cast<HttpRequest*> (theCauseRep ?
+                           theCauseRep->raw().header : theVirginRep.raw().header);
     Must(request);
+
+    HttpReply *reply = dynamic_cast<HttpReply*>(theVirginRep.raw().header);
+
     Adaptation::History::Pointer ah = request->adaptLogHistory();
     if (ah != NULL) {
         // retrying=false because ecap never retries transactions
         adaptHistoryId = ah->recordXactStart(service().cfg().key, current_time, false);
+        typedef Notes::iterator ACAMLI;
+        for (ACAMLI i = Adaptation::Config::metaHeaders.begin(); i != Adaptation::Config::metaHeaders.end(); ++i) {
+            const char *v = (*i)->match(request, reply);
+            if (v && !ah->metaHeaders.hasByNameListMember((*i)->key.termedBuf(), v, ',')) {
+                ah->metaHeaders.addEntry(new HttpHeaderEntry(HDR_OTHER, (*i)->key.termedBuf(), v));
+            }
+        }
     }
 
     theMaster->start();
@@ -1,5 +1,4 @@
 /*
- * $Id$
  * DEBUG: section 93    eCAP Interface
  */
 
@@ -39,8 +39,8 @@ namespace Adaptation
 namespace Icap
 {
 
-extern void InitModule();
-extern void CleanModule();
+void InitModule();
+void CleanModule();
 
 } // namespace Icap
 } // namespace Adaptation
@@ -38,6 +38,7 @@
 #include "adaptation/icap/ServiceRep.h"
 #include "HttpRequest.h"
 #include "HttpReply.h"
+#include "SquidConfig.h"
 #include "wordlist.h"
 
 Adaptation::Icap::Config Adaptation::Icap::TheConfig;
@@ -1,8 +1,8 @@
 #ifndef SQUID_ICAPHISTORY_H
 #define SQUID_ICAPHISTORY_H
 
+#include "base/RefCount.h"
 #include "enums.h"
-#include "RefCount.h"
 #include "SquidString.h"
 
 namespace Adaptation
@@ -1420,16 +1420,20 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
         makeUsernameHeader(request, buf);
 
     // Adaptation::Config::metaHeaders
-    typedef Adaptation::Config::MetaHeaders::iterator ACAMLI;
+    typedef Notes::iterator ACAMLI;
     for (ACAMLI i = Adaptation::Config::metaHeaders.begin(); i != Adaptation::Config::metaHeaders.end(); ++i) {
         HttpRequest *r = virgin.cause ?
                          virgin.cause : dynamic_cast<HttpRequest*>(virgin.header);
         Must(r);
 
         HttpReply *reply = dynamic_cast<HttpReply*>(virgin.header);
 
-        if (const char *value = (*i)->match(r, reply))
-            buf.Printf("%s: %s\r\n", (*i)->name.termedBuf(), value);
+        if (const char *value = (*i)->match(r, reply)) {
+            buf.Printf("%s: %s\r\n", (*i)->key.termedBuf(), value);
+            Adaptation::History::Pointer ah = request->adaptHistory(false);
+            if (ah != NULL && !ah->metaHeaders.hasByNameListMember((*i)->key.termedBuf(), value, ','))
+                ah->metaHeaders.addEntry(new HttpHeaderEntry(HDR_OTHER, (*i)->key.termedBuf(), value));
+        }
     }
 
     // fprintf(stderr, "%s\n", buf.content());
@@ -1746,12 +1750,12 @@ void Adaptation::Icap::ModXact::estimateVirginBody()
     else if (HttpRequest *req = dynamic_cast<HttpRequest*>(msg))
         method = req->method;
     else
-        method = METHOD_NONE;
+        method = Http::METHOD_NONE;
 
     int64_t size;
     // expectingBody returns true for zero-sized bodies, but we will not
     // get a pipe for that body, so we treat the message as bodyless
-    if (method != METHOD_NONE && msg->expectingBody(method, size) && size) {
+    if (method != Http::METHOD_NONE && msg->expectingBody(method, size) && size) {
         debugs(93, 6, HERE << "expects virgin body from " <<
                virgin.body_pipe << "; size: " << size);
 
@@ -17,6 +17,7 @@
 #include "globals.h"
 #include "HttpReply.h"
 #include "ip/tools.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 
 CBDATA_NAMESPACED_CLASS_INIT(Adaptation::Icap, ServiceRep);
@@ -24,6 +24,7 @@
 #include "ipcache.h"
 #include "Mem.h"
 #include "pconn.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 
 //CBDATA_NAMESPACED_CLASS_INIT(Adaptation::Icap, Xaction);
@@ -1,15 +1,17 @@
 #include "squid.h"
 #include "icap_log.h"
 #include "AccessLogEntry.h"
+#include "log/CustomLog.h"
 #include "log/File.h"
 #include "log/Formats.h"
+#include "SquidConfig.h"
 
 int IcapLogfileStatus = LOG_DISABLE;
 
 void
 icapLogOpen()
 {
-    customlog *log;
+    CustomLog *log;
 
     for (log = Config.Log.icaplogs; log; log = log->next) {
         if (log->type == Log::Format::CLF_NONE)
@@ -24,7 +26,7 @@ icapLogOpen()
 void
 icapLogClose()
 {
-    customlog *log;
+    CustomLog *log;
 
     for (log = Config.Log.icaplogs; log; log = log->next) {
         if (log->logfile) {
@@ -37,7 +39,7 @@ icapLogClose()
 void
 icapLogRotate()
 {
-    for (customlog* log = Config.Log.icaplogs; log; log = log->next) {
+    for (CustomLog* log = Config.Log.icaplogs; log; log = log->next) {
         if (log->logfile) {
             logfileRotate(log->logfile);
         }
@@ -2,7 +2,7 @@
 #define ICAP_LOG_H_
 
 #include "AccessLogEntry.h"
-#include "RefCount.h"
+#include "base/RefCount.h"
 
 typedef RefCount<AccessLogEntry> AccessLogEntryPointer;
 class AccessLogEntry;
@@ -11,7 +11,9 @@
 namespace AnyP
 {
 
-struct PortCfg {
+class PortCfg
+{
+public:
     PortCfg(const char *aProtocol);
     ~PortCfg();
     AnyP::PortCfg *clone() const;
@@ -34,7 +34,7 @@ AuthenticateAcl(ACLChecklist *ch)
     } else if (request->flags.accelerated) {
         /* WWW authorization on accelerated requests */
         headertype = HDR_AUTHORIZATION;
-    } else if (request->flags.intercepted || request->flags.spoof_client_ip) {
+    } else if (request->flags.intercepted || request->flags.spoofClientIp) {
         debugs(28, DBG_IMPORTANT, "NOTICE: Authentication not applicable on intercepted requests.");
         return ACCESS_DENIED;
     } else {
@@ -11,7 +11,7 @@
 
 class ACLChecklist;
 /// \ingroup AuthAPI
-extern allow_t AuthenticateAcl(ACLChecklist *ch);
+allow_t AuthenticateAcl(ACLChecklist *ch);
 
 #endif /* USE_AUTH */
 #endif /* SQUID_AUTH_ACL_H */
@@ -82,7 +82,7 @@ class StoreEntry;
 typedef void AUTHSSTATS(StoreEntry *);
 
 /// \ingroup AuthAPI
-extern void authenticateInit(Auth::ConfigVector *);
+void authenticateInit(Auth::ConfigVector *);
 
 /** \ingroup AuthAPI
  * Remove all idle authentication state. Intended for use by reconfigure.
@@ -94,19 +94,19 @@ extern void authenticateInit(Auth::ConfigVector *);
  * authentication unless something causes the global config to be rebuilt.
  * Such as a configure load action adding config and re-running authenticateInit().
  */
-extern void authenticateReset(void);
+void authenticateReset(void);
 
-extern void authenticateRotate(void);
+void authenticateRotate(void);
 
 /// \ingroup AuthAPI
-extern void authenticateFreeProxyAuthUserACLResults(void *data);
+void authenticateFreeProxyAuthUserACLResults(void *data);
 /// \ingroup AuthAPI
-extern int authenticateActiveSchemeCount(void);
+int authenticateActiveSchemeCount(void);
 /// \ingroup AuthAPI
-extern int authenticateSchemeCount(void);
+int authenticateSchemeCount(void);
 
 /// \ingroup AuthAPI
-extern void authenticateOnCloseConnection(ConnStateData * conn);
+void authenticateOnCloseConnection(ConnStateData * conn);
 
 #endif /* USE_AUTH */
 #endif /* SQUID_AUTH_GADGETS_H */
@@ -34,7 +34,7 @@
 #if USE_AUTH
 
 #include "Array.h"
-#include "RefCount.h"
+#include "base/RefCount.h"
 
 /**
  \defgroup AuthSchemeAPI	Authentication Scheme API
@@ -40,6 +40,7 @@
 #include "acl/Gadgets.h"
 #include "event.h"
 #include "globals.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 
@@ -150,7 +151,7 @@ Auth::User::absorb(Auth::User::Pointer from)
 Auth::User::~User()
 {
     debugs(29, 5, HERE << "Freeing auth_user '" << this << "'.");
-    assert(RefCountCount() == 0);
+    assert(LockCount() == 0);
 
     /* free cached acl results */
     aclCacheMatchFlush(&proxy_match_cache);
@@ -222,7 +223,7 @@ Auth::User::cacheCleanup(void *datanotused)
                auth_user->auth_type << "\n\tUsername: " << username <<
                "\n\texpires: " <<
                (long int) (auth_user->expiretime + ::Config.authenticateTTL) <<
-               "\n\treferences: " << (long int) auth_user->RefCountCount());
+               "\n\treferences: " << auth_user->LockCount());
 
         if (auth_user->expiretime + ::Config.authenticateTTL <= current_time.tv_sec) {
             debugs(29, 5, HERE << "Removing user " << username << " from cache due to timeout.");
@@ -36,9 +36,9 @@
 
 #include "auth/CredentialState.h"
 #include "auth/Type.h"
+#include "base/RefCount.h"
 #include "dlink.h"
 #include "ip/Address.h"
-#include "RefCount.h"
 
 class AuthUserHashPointer;
 class StoreEntry;
@@ -117,7 +117,7 @@ Auth::UserRequest::UserRequest():
 
 Auth::UserRequest::~UserRequest()
 {
-    assert(RefCountCount()==0);
+    assert(LockCount()==0);
     debugs(29, 5, HERE << "freeing request " << this);
 
     if (user() != NULL) {
@@ -227,20 +227,20 @@ class UserRequest : public RefCountable
 /* AuthUserRequest */
 
 /// \ingroup AuthAPI
-extern void authenticateFixHeader(HttpReply *, Auth::UserRequest::Pointer, HttpRequest *, int, int);
+void authenticateFixHeader(HttpReply *, Auth::UserRequest::Pointer, HttpRequest *, int, int);
 /// \ingroup AuthAPI
-extern void authenticateAddTrailer(HttpReply *, Auth::UserRequest::Pointer, HttpRequest *, int);
+void authenticateAddTrailer(HttpReply *, Auth::UserRequest::Pointer, HttpRequest *, int);
 
 /// \ingroup AuthAPI
-extern void authenticateAuthUserRequestRemoveIp(Auth::UserRequest::Pointer, Ip::Address const &);
+void authenticateAuthUserRequestRemoveIp(Auth::UserRequest::Pointer, Ip::Address const &);
 /// \ingroup AuthAPI
-extern void authenticateAuthUserRequestClearIp(Auth::UserRequest::Pointer);
+void authenticateAuthUserRequestClearIp(Auth::UserRequest::Pointer);
 /// \ingroup AuthAPI
-extern int authenticateAuthUserRequestIPCount(Auth::UserRequest::Pointer);
+int authenticateAuthUserRequestIPCount(Auth::UserRequest::Pointer);
 
 /// \ingroup AuthAPI
 /// See Auth::UserRequest::authenticated()
-extern int authenticateUserAuthenticated(Auth::UserRequest::Pointer);
+int authenticateUserAuthenticated(Auth::UserRequest::Pointer);
 
 #endif /* USE_AUTH */
 #endif /* SQUID_AUTHUSERREQUEST_H */
@@ -2,8 +2,8 @@
 #include "auth/basic/auth_basic.h"
 #include "auth/basic/User.h"
 #include "Debug.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
-#include "structs.h"
 
 Auth::Basic::User::User(Auth::Config *aConfig) :
         Auth::User(aConfig),
@@ -21,7 +21,7 @@ class UserRequest : public Auth::UserRequest
     MEMPROXY_CLASS(Auth::Basic::UserRequest);
 
     UserRequest() {}
-    virtual ~UserRequest() { assert(RefCountCount()==0); }
+    virtual ~UserRequest() { assert(LockCount()==0); }
 
     virtual int authenticated() const;
     virtual void authenticate(HttpRequest * request, ConnStateData *conn, http_hdr_type type);
@@ -3,8 +3,8 @@
 #include "auth/digest/User.h"
 #include "Debug.h"
 #include "dlink.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
-#include "structs.h"
 
 Auth::Digest::User::User(Auth::Config *aConfig) :
         Auth::User(aConfig),
@@ -28,7 +28,7 @@ Auth::Digest::UserRequest::UserRequest() :
  */
 Auth::Digest::UserRequest::~UserRequest()
 {
-    assert(RefCountCount()==0);
+    assert(LockCount()==0);
 
     safe_free(nonceb64);
     safe_free(cnonce);
@@ -104,7 +104,7 @@ Auth::Digest::UserRequest::authenticate(HttpRequest * request, ConnStateData * c
             return;
         }
 
-        if (static_cast<Auth::Digest::Config*>(Auth::Config::Find("digest"))->PostWorkaround && request->method != METHOD_GET) {
+        if (static_cast<Auth::Digest::Config*>(Auth::Config::Find("digest"))->PostWorkaround && request->method != Http::METHOD_GET) {
             /* Ugly workaround for certain very broken browsers using the
              * wrong method to calculate the request-digest on POST request.
              * This should be deleted once Digest authentication becomes more
@@ -113,7 +113,7 @@ Auth::Digest::UserRequest::authenticate(HttpRequest * request, ConnStateData * c
              */
             DigestCalcResponse(SESSIONKEY, authenticateDigestNonceNonceb64(digest_request->nonce),
                                digest_request->nc, digest_request->cnonce, digest_request->qop,
-                               RequestMethodStr(METHOD_GET), digest_request->uri, HA2, Response);
+                               RequestMethodStr(Http::METHOD_GET), digest_request->uri, HA2, Response);
 
             if (strcasecmp(digest_request->response, Response)) {
                 auth_user->credentials(Auth::Failed);
@@ -280,10 +280,8 @@ Auth::Digest::UserRequest::HandleReply(void *data, const HelperReply &reply)
     assert(replyData->auth_user_request != NULL);
     Auth::UserRequest::Pointer auth_user_request = replyData->auth_user_request;
 
-    switch(reply.result)
-    {
-    case HelperReply::Error:
-    {
+    switch (reply.result) {
+    case HelperReply::Error: {
         /* allow this because the digest_request pointer is purely local */
         Auth::Digest::UserRequest *digest_request = dynamic_cast<Auth::Digest::UserRequest *>(auth_user_request.getRaw());
         assert(digest_request);
@@ -294,19 +292,18 @@ Auth::Digest::UserRequest::HandleReply(void *data, const HelperReply &reply)
         if (reply.other().hasContent())
             digest_request->setDenyMessage(reply.other().content());
     }
-        break;
+    break;
 
     case HelperReply::Unknown: // Squid 3.2 and older the digest helper only returns a HA1 hash (no "OK")
-    case HelperReply::Okay:
-    {
+    case HelperReply::Okay: {
         /* allow this because the digest_request pointer is purely local */
         Auth::Digest::User *digest_user = dynamic_cast<Auth::Digest::User *>(auth_user_request->user().getRaw());
         assert(digest_user != NULL);
 
         CvtBin(reply.other().content(), digest_user->HA1);
         digest_user->HA1created = 1;
     }
-        break;
+    break;
 
     default:
         ; // XXX: handle other states properly.
@@ -91,6 +91,7 @@ static const HttpHeaderFieldAttrs DigestAttrs[DIGEST_ENUM_END] = {
     {"response", (http_hdr_type)DIGEST_RESPONSE},
 };
 
+class HttpHeaderFieldInfo;
 static HttpHeaderFieldInfo *DigestFieldsInfo = NULL;
 
 /*
@@ -50,12 +50,12 @@ struct _digest_nonce_h : public hash_link {
     } flags;
 };
 
-extern void authDigestNonceUnlink(digest_nonce_h * nonce);
-extern int authDigestNonceIsValid(digest_nonce_h * nonce, char nc[9]);
-extern const char *authenticateDigestNonceNonceb64(const digest_nonce_h * nonce);
-extern int authDigestNonceLastRequest(digest_nonce_h * nonce);
-extern void authenticateDigestNonceShutdown(void);
-extern void authDigestNoncePurge(digest_nonce_h * nonce);
+void authDigestNonceUnlink(digest_nonce_h * nonce);
+int authDigestNonceIsValid(digest_nonce_h * nonce, char nc[9]);
+const char *authenticateDigestNonceNonceb64(const digest_nonce_h * nonce);
+int authDigestNonceLastRequest(digest_nonce_h * nonce);
+void authenticateDigestNonceShutdown(void);
+void authDigestNoncePurge(digest_nonce_h * nonce);
 
 namespace Auth
 {
@@ -22,7 +22,7 @@ Auth::Negotiate::UserRequest::UserRequest()
 
 Auth::Negotiate::UserRequest::~UserRequest()
 {
-    assert(RefCountCount()==0);
+    assert(LockCount()==0);
     safe_free(server_blob);
     safe_free(client_blob);
 
@@ -260,7 +260,7 @@ Auth::Negotiate::UserRequest::HandleReply(void *data, const HelperReply &reply)
     if (lm_request->authserver == NULL)
         lm_request->authserver = reply.whichServer.get(); // XXX: no locking?
     else
-        assert(lm_request->authserver == reply.whichServer.raw());
+        assert(reply.whichServer == lm_request->authserver);
 
     /* seperate out the useful data */
     char *modifiableBlob = reply.modifiableOther().content();
@@ -274,13 +274,12 @@ Auth::Negotiate::UserRequest::HandleReply(void *data, const HelperReply &reply)
     }
     const char *blob = modifiableBlob;
 
-    switch(reply.result)
-    {
+    switch (reply.result) {
     case HelperReply::TT:
         /* we have been given a blob to send to the client */
         safe_free(lm_request->server_blob);
-        lm_request->request->flags.must_keepalive = 1;
-        if (lm_request->request->flags.proxy_keepalive) {
+        lm_request->request->flags.mustKeepalive = 1;
+        if (lm_request->request->flags.proxyKeepalive) {
             lm_request->server_blob = xstrdup(reply.authToken.content());
             auth_user_request->user()->credentials(Auth::Handshake);
             auth_user_request->denyMessage("Authentication in progress");
@@ -291,8 +290,7 @@ Auth::Negotiate::UserRequest::HandleReply(void *data, const HelperReply &reply)
         }
         break;
 
-    case HelperReply::Okay:
-    {
+    case HelperReply::Okay: {
         if (!reply.user.hasContent()) {
             // XXX: handle a success with no username better
             /* protocol error */
@@ -335,7 +333,7 @@ Auth::Negotiate::UserRequest::HandleReply(void *data, const HelperReply &reply)
         auth_user_request->user()->credentials(Auth::Ok);
         debugs(29, 4, HERE << "Successfully validated user via Negotiate. Username '" << reply.user << "'");
     }
-        break;
+    break;
 
     case HelperReply::NA:
     case HelperReply::Error:
@@ -218,7 +218,7 @@ Auth::Negotiate::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request,
         return;
 
     /* Need keep-alive */
-    if (!request->flags.proxy_keepalive && request->flags.must_keepalive)
+    if (!request->flags.proxyKeepalive && request->flags.mustKeepalive)
         return;
 
     /* New request, no user details */
@@ -229,7 +229,7 @@ Auth::Negotiate::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request,
         if (!keep_alive) {
             /* drop the connection */
             rep->header.delByName("keep-alive");
-            request->flags.proxy_keepalive = 0;
+            request->flags.proxyKeepalive = 0;
         }
     } else {
         Auth::Negotiate::UserRequest *negotiate_request = dynamic_cast<Auth::Negotiate::UserRequest *>(auth_user_request.getRaw());
@@ -241,7 +241,7 @@ Auth::Negotiate::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request,
             /* here it makes sense to drop the connection, as auth is
              * tied to it, even if MAYBE the client could handle it - Kinkie */
             rep->header.delByName("keep-alive");
-            request->flags.proxy_keepalive = 0;
+            request->flags.proxyKeepalive = 0;
             /* fall through */
 
         case Auth::Ok:
@@ -19,7 +19,7 @@ Auth::Ntlm::UserRequest::UserRequest()
 
 Auth::Ntlm::UserRequest::~UserRequest()
 {
-    assert(RefCountCount()==0);
+    assert(LockCount()==0);
     safe_free(server_blob);
     safe_free(client_blob);
 
@@ -253,18 +253,17 @@ Auth::Ntlm::UserRequest::HandleReply(void *data, const HelperReply &reply)
     if (lm_request->authserver == NULL)
         lm_request->authserver = reply.whichServer.get(); // XXX: no locking?
     else
-        assert(lm_request->authserver == reply.whichServer.raw());
+        assert(reply.whichServer == lm_request->authserver);
 
     /* seperate out the useful data */
     const char *blob = reply.other().content();
 
-    switch(reply.result)
-    {
+    switch (reply.result) {
     case HelperReply::TT:
         /* we have been given a blob to send to the client */
         safe_free(lm_request->server_blob);
-        lm_request->request->flags.must_keepalive = 1;
-        if (lm_request->request->flags.proxy_keepalive) {
+        lm_request->request->flags.mustKeepalive = 1;
+        if (lm_request->request->flags.proxyKeepalive) {
             lm_request->server_blob = xstrdup(reply.authToken.content());
             auth_user_request->user()->credentials(Auth::Handshake);
             auth_user_request->denyMessage("Authentication in progress");
@@ -275,8 +274,8 @@ Auth::Ntlm::UserRequest::HandleReply(void *data, const HelperReply &reply)
         }
         break;
 
-    case HelperReply::Okay:
-    {
+    case HelperReply::AF:
+    case HelperReply::Okay: {
         /* we're finished, release the helper */
         auth_user_request->user()->username(reply.user.content());
         auth_user_request->denyMessage("Login successful");
@@ -312,7 +311,7 @@ Auth::Ntlm::UserRequest::HandleReply(void *data, const HelperReply &reply)
         auth_user_request->user()->credentials(Auth::Ok);
         debugs(29, 4, HERE << "Successfully validated user via NTLM. Username '" << reply.user << "'");
     }
-        break;
+    break;
 
     case HelperReply::NA:
     case HelperReply::Error:
@@ -205,7 +205,7 @@ Auth::Ntlm::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, Http
         return;
 
     /* Need keep-alive */
-    if (!request->flags.proxy_keepalive && request->flags.must_keepalive)
+    if (!request->flags.proxyKeepalive && request->flags.mustKeepalive)
         return;
 
     /* New request, no user details */
@@ -215,7 +215,7 @@ Auth::Ntlm::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, Http
 
         if (!keep_alive) {
             /* drop the connection */
-            request->flags.proxy_keepalive = 0;
+            request->flags.proxyKeepalive = 0;
         }
     } else {
         Auth::Ntlm::UserRequest *ntlm_request = dynamic_cast<Auth::Ntlm::UserRequest *>(auth_user_request.getRaw());
@@ -226,7 +226,7 @@ Auth::Ntlm::Config::fixHeader(Auth::UserRequest::Pointer auth_user_request, Http
         case Auth::Failed:
             /* here it makes sense to drop the connection, as auth is
              * tied to it, even if MAYBE the client could handle it - Kinkie */
-            request->flags.proxy_keepalive = 0;
+            request->flags.proxyKeepalive = 0;
             /* fall through */
 
         case Auth::Ok:
@@ -1,8 +1,5 @@
-/*
- * $Id$
- */
-
 #include "squid.h"
+#include "AsyncCall.h"
 #include "base/AsyncCall.h"
 #include "base/AsyncCallQueue.h"
 #include "cbdata.h"
@@ -1,14 +1,9 @@
-/*
- * $Id$
- */
-
 #ifndef SQUID_ASYNCCALL_H
 #define SQUID_ASYNCCALL_H
 
-//#include "cbdata.h"
 #include "base/InstanceId.h"
 #include "event.h"
-//#include "TextException.h"
+#include "RefCount.h"
 
 /**
  \defgroup AsynCallsAPI Async-Calls API
@@ -157,7 +152,7 @@ asyncCall(int aDebugSection, int aDebugLevel, const char *aName,
 }
 
 /** Call scheduling helper. Use ScheduleCallHere if you can. */
-extern bool ScheduleCall(const char *fileName, int fileLine, AsyncCall::Pointer &call);
+bool ScheduleCall(const char *fileName, int fileLine, AsyncCall::Pointer &call);
 
 /** Call scheduling helper. */
 #define ScheduleCallHere(call) ScheduleCall(__FILE__, __LINE__, (call))
@@ -1,7 +1,3 @@
-/*
- * $Id$
- */
-
 #ifndef SQUID_ASYNC_JOB_H
 #define SQUID_ASYNC_JOB_H
 
@@ -1,8 +1,3 @@
-
-/*
- * $Id$
- */
-
 #ifndef SQUID_ASYNCJOBCALLS_H
 #define SQUID_ASYNCJOBCALLS_H
 
@@ -1,7 +1,3 @@
-/*
- * $Id$
- */
-
 #ifndef SQUID_CBC_POINTER_H
 #define SQUID_CBC_POINTER_H
 
@@ -0,0 +1,59 @@
+#ifndef SQUID_SRC_BASE_LOCK_H
+#define SQUID_SRC_BASE_LOCK_H
+
+/**
+ * This class provides a tracking counter and presents
+ * lock(), unlock() and LockCount() accessors.
+ *
+ * All locks must be cleared with unlock() before this object
+ * is destroyed.
+ *
+ * Accessors provided by this interface are not private,
+ * to allow class hierarchies.
+ *
+ * Build with -DLOCKCOUNT_DEBUG flag to enable lock debugging.
+ * It is disabled by default due to the cost of debug output.
+ */
+class Lock
+{
+public:
+    Lock():count_(0) {}
+
+    virtual ~Lock() { assert(count_ == 0); }
+
+    /// Register one lock / reference against this object.
+    /// All locks must be cleared before it may be destroyed.
+    void lock() const {
+#if defined(LOCKCOUNT_DEBUG)
+        old_debug(0,1)("Incrementing this %p from count %u\n",this,count_);
+#endif
+        ++count_;
+    }
+
+    /// Clear one lock / reference against this object.
+    /// All locks must be cleared before it may be destroyed.
+    unsigned unlock() const {
+#if defined(LOCKCOUNT_DEBUG)
+        old_debug(0,1)("Decrementing this %p from count %u\n",this,count_);
+#endif
+        assert(count_ > 0);
+        return --count_;
+    }
+
+    /// Inspect the current count of references.
+    unsigned LockCount() const { return count_; }
+
+private:
+    mutable unsigned count_; ///< number of references currently being tracked
+};
+
+// For clarity we provide some aliases for the tracking mechanisms
+// using Lock so that we can easily see what type of smart pointers
+// are to be used for the child object.
+// NP: CbcPointer<> and RefCount<> pointers should be used consistently
+//     for any given child class type
+
+/// The locking interface for use on Reference-Counted classes
+#define RefCountable virtual Lock
+
+#endif /* SQUID_SRC_BASE_LOCK_H */
@@ -1,4 +1,3 @@
-
 include $(top_srcdir)/src/Common.am
 include $(top_srcdir)/src/TestHeaders.am
 
@@ -16,6 +15,7 @@ libbase_la_SOURCES = \
 	TidyPointer.h \
 	CbcPointer.h \
 	InstanceId.h \
+	Lock.h \
 	RunnersRegistry.cc \
 	RunnersRegistry.h \
 	Subscription.h \
@@ -33,10 +33,19 @@
 #ifndef SQUID_REFCOUNT_H_
 #define SQUID_REFCOUNT_H_
 
+// reference counting requires the Lock API on base classes
+#include "base/Lock.h"
+
 #if HAVE_IOSTREAM
 #include <iostream>
 #endif
 
+/**
+ * Template for Reference Counting pointers.
+ *
+ * Objects of type 'C' must inherit from 'Lockable' in base/Lock.h
+ * which provides the locking interface used by reference counting.
+ */
 template <class C>
 class RefCount
 {
@@ -90,54 +99,24 @@ class RefCount
         C const (*tempP_) (p_);
         p_ = newP;
 
-        if (tempP_ && tempP_->RefCountDereference() == 0)
+        if (tempP_ && tempP_->unlock() == 0)
             delete tempP_;
     }
 
     void reference (const RefCount& p) {
         if (p.p_)
-            p.p_->RefCountReference();
+            p.p_->lock();
     }
 
     C const *p_;
 
 };
 
-struct RefCountable_ {
-    RefCountable_():count_(0) {}
-
-    virtual ~RefCountable_() { assert(count_ == 0); }
-
-    /* Not private, to allow class hierarchies */
-    void RefCountReference() const {
-#if REFCOUNT_DEBUG
-        old_debug(0,1)("Incrementing this %p from count %u\n",this,count_);
-#endif
-
-        ++count_;
-    }
-
-    unsigned RefCountDereference() const {
-#if REFCOUNT_DEBUG
-        old_debug(0,1)("Decrementing this %p from count %u\n",this,count_);
-#endif
-
-        return --count_;
-    }
-
-    unsigned RefCountCount() const { return count_; } // for debugging only
-
-private:
-    mutable unsigned count_;
-};
-
-#define RefCountable virtual RefCountable_
-
 template <class C>
 inline std::ostream &operator <<(std::ostream &os, const RefCount<C> &p)
 {
     if (p != NULL)
-        return os << p.getRaw() << '*' << p->RefCountCount();
+        return os << p.getRaw() << '*' << p->LockCount();
     else
         return os << "NULL";
 }
@@ -71,7 +71,7 @@ class FileNameHashCacheUser
                                          (FileNameHashCached(__FILE__)<<14) | (__LINE__ & 0x3FFF))
 #endif
 
-extern void Throw(const char *message, const char *fileName, int lineNo, unsigned int id);
+void Throw(const char *message, const char *fileName, int lineNo, unsigned int id);
 
 // Must(condition) is like assert(condition) but throws an exception instead
 #if !defined(Must)
@@ -1,7 +1,3 @@
-/*
- * $Id$
- */
-
 #ifndef SQUID_BASE_TIDYPOINTER_H
 #define SQUID_BASE_TIDYPOINTER_H
 
@@ -32,11 +32,18 @@
 
 #include "squid.h"
 #include "acl/Acl.h"
+#include "acl/AclAddress.h"
+#include "acl/AclDenyInfoList.h"
+#include "acl/AclNameList.h"
+#include "acl/AclSizeLimit.h"
 #include "acl/Gadgets.h"
 #include "acl/MethodData.h"
 #include "anyp/PortCfg.h"
 #include "AuthReg.h"
 #include "base/RunnersRegistry.h"
+#include "mgr/ActionPasswordList.h"
+#include "CachePeer.h"
+#include "CachePeerDomainList.h"
 #include "cache_cf.h"
 #include "ConfigParser.h"
 #include "CpuAffinityMap.h"
@@ -53,16 +60,20 @@
 #include "ip/tools.h"
 #include "ipc/Kids.h"
 #include "log/Config.h"
+#include "log/CustomLog.h"
 #include "Mem.h"
 #include "MemBuf.h"
 #include "mgr/Registration.h"
+#include "NeighborTypeDomainList.h"
 #include "Parsing.h"
 #include "PeerDigest.h"
+#include "RefreshPattern.h"
 #include "rfc1738.h"
+#include "SquidConfig.h"
 #include "SquidString.h"
+#include "ssl/ProxyCerts.h"
 #include "Store.h"
 #include "StoreFileSystem.h"
-#include "structs.h"
 #include "SwapDir.h"
 #include "wordlist.h"
 #include "neighbors.h"
@@ -123,9 +134,6 @@
 static void parse_adaptation_service_set_type();
 static void parse_adaptation_service_chain_type();
 static void parse_adaptation_access_type();
-static void parse_adaptation_meta_type(Adaptation::Config::MetaHeaders *);
-static void dump_adaptation_meta_type(StoreEntry *, const char *, Adaptation::Config::MetaHeaders &);
-static void free_adaptation_meta_type(Adaptation::Config::MetaHeaders *);
 #endif
 
 #if ICAP_CLIENT
@@ -148,7 +156,7 @@ static void free_ecap_service_type(Adaptation::Ecap::Config *);
 
 static peer_t parseNeighborType(const char *s);
 
-CBDATA_TYPE(peer);
+CBDATA_TYPE(CachePeer);
 
 static const char *const T_MILLISECOND_STR = "millisecond";
 static const char *const T_SECOND_STR = "second";
@@ -168,14 +176,14 @@ static const char *const B_GBYTES_STR = "GB";
 
 static const char *const list_sep = ", \t\n\r";
 
-static void parse_access_log(customlog ** customlog_definitions);
-static int check_null_access_log(customlog *customlog_definitions);
-static void dump_access_log(StoreEntry * entry, const char *name, customlog * definitions);
-static void free_access_log(customlog ** definitions);
+static void parse_access_log(CustomLog ** customlog_definitions);
+static int check_null_access_log(CustomLog *customlog_definitions);
+static void dump_access_log(StoreEntry * entry, const char *name, CustomLog * definitions);
+static void free_access_log(CustomLog ** definitions);
 
 static void update_maxobjsize(void);
 static void configDoConfigure(void);
-static void parse_refreshpattern(refresh_t **);
+static void parse_refreshpattern(RefreshPattern **);
 static uint64_t parseTimeUnits(const char *unit,  bool allowMsec);
 static void parseTimeLine(time_msec_t * tptr, const char *units, bool allowMsec);
 static void parse_u_short(unsigned short * var);
@@ -208,9 +216,12 @@ static void parse_http_header_replace(HeaderManglers **manglers);
 static void dump_HeaderWithAclList(StoreEntry * entry, const char *name, HeaderWithAclList *headers);
 static void parse_HeaderWithAclList(HeaderWithAclList **header);
 static void free_HeaderWithAclList(HeaderWithAclList **header);
-static void parse_denyinfo(acl_deny_info_list ** var);
-static void dump_denyinfo(StoreEntry * entry, const char *name, acl_deny_info_list * var);
-static void free_denyinfo(acl_deny_info_list ** var);
+static void parse_note(Notes *);
+static void dump_note(StoreEntry *, const char *, Notes &);
+static void free_note(Notes *);
+static void parse_denyinfo(AclDenyInfoList ** var);
+static void dump_denyinfo(StoreEntry * entry, const char *name, AclDenyInfoList * var);
+static void free_denyinfo(AclDenyInfoList ** var);
 
 #if USE_WCCPv2
 static void parse_IpAddress_list(Ip::Address_list **);
@@ -759,7 +770,7 @@ configDoConfigure(void)
 #if USE_HTTP_VIOLATIONS
 
     {
-        const refresh_t *R;
+        const RefreshPattern *R;
 
         for (R = Config.Refresh; R; R = R->next) {
             if (!R->flags.override_expire)
@@ -797,15 +808,6 @@ configDoConfigure(void)
             break;
         }
 
-        for (R = Config.Refresh; R; R = R->next) {
-            if (!R->flags.ignore_no_cache)
-                continue;
-
-            debugs(22, DBG_IMPORTANT, "WARNING: use of 'ignore-no-cache' in 'refresh_pattern' violates HTTP");
-
-            break;
-        }
-
         for (R = Config.Refresh; R; R = R->next) {
             if (!R->flags.ignore_no_store)
                 continue;
@@ -911,14 +913,13 @@ configDoConfigure(void)
         Config2.effectiveGroupID = grp->gr_gid;
     }
 
-    HttpRequestMethod::Configure(Config);
 #if USE_SSL
 
     debugs(3, DBG_IMPORTANT, "Initializing https proxy context");
 
     Config.ssl_client.sslContext = sslCreateClientContext(Config.ssl_client.cert, Config.ssl_client.key, Config.ssl_client.version, Config.ssl_client.cipher, Config.ssl_client.options, Config.ssl_client.flags, Config.ssl_client.cafile, Config.ssl_client.capath, Config.ssl_client.crlfile);
 
-    for (peer *p = Config.peers; p != NULL; p = p->next) {
+    for (CachePeer *p = Config.peers; p != NULL; p = p->next) {
         if (p->use_ssl) {
             debugs(3, DBG_IMPORTANT, "Initializing cache_peer " << p->name << " SSL context");
             p->sslContext = sslCreateClientContext(p->sslcert, p->sslkey, p->sslversion, p->sslcipher, p->ssloptions, p->sslflags, p->sslcafile, p->sslcapath, p->sslcrlfile);
@@ -1360,13 +1361,13 @@ free_address(Ip::Address *addr)
     addr->SetEmpty();
 }
 
-CBDATA_TYPE(acl_address);
+CBDATA_TYPE(AclAddress);
 
 static void
-dump_acl_address(StoreEntry * entry, const char *name, acl_address * head)
+dump_acl_address(StoreEntry * entry, const char *name, AclAddress * head)
 {
     char buf[MAX_IPSTRLEN];
-    acl_address *l;
+    AclAddress *l;
 
     for (l = head; l; l = l->next) {
         if (!l->addr.IsAnyAddr())
@@ -1383,17 +1384,17 @@ dump_acl_address(StoreEntry * entry, const char *name, acl_address * head)
 static void
 freed_acl_address(void *data)
 {
-    acl_address *l = static_cast<acl_address *>(data);
+    AclAddress *l = static_cast<AclAddress *>(data);
     aclDestroyAclList(&l->aclList);
 }
 
 static void
-parse_acl_address(acl_address ** head)
+parse_acl_address(AclAddress ** head)
 {
-    acl_address *l;
-    acl_address **tail = head;	/* sane name below */
-    CBDATA_INIT_TYPE_FREECB(acl_address, freed_acl_address);
-    l = cbdataAlloc(acl_address);
+    AclAddress *l;
+    AclAddress **tail = head;	/* sane name below */
+    CBDATA_INIT_TYPE_FREECB(AclAddress, freed_acl_address);
+    l = cbdataAlloc(AclAddress);
     parse_address(&l->addr);
     aclParseAclList(LegacyParser, &l->aclList);
 
@@ -1404,10 +1405,10 @@ parse_acl_address(acl_address ** head)
 }
 
 static void
-free_acl_address(acl_address ** head)
+free_acl_address(AclAddress ** head)
 {
     while (*head) {
-        acl_address *l = *head;
+        AclAddress *l = *head;
         *head = l->next;
         cbdataFree(l);
     }
@@ -1554,12 +1555,12 @@ free_acl_nfmark(acl_nfmark ** head)
 }
 #endif /* SO_MARK */
 
-CBDATA_TYPE(acl_size_t);
+CBDATA_TYPE(AclSizeLimit);
 
 static void
-dump_acl_b_size_t(StoreEntry * entry, const char *name, acl_size_t * head)
+dump_acl_b_size_t(StoreEntry * entry, const char *name, AclSizeLimit * head)
 {
-    acl_size_t *l;
+    AclSizeLimit *l;
 
     for (l = head; l; l = l->next) {
         if (l->size != -1)
@@ -1576,19 +1577,19 @@ dump_acl_b_size_t(StoreEntry * entry, const char *name, acl_size_t * head)
 static void
 freed_acl_b_size_t(void *data)
 {
-    acl_size_t *l = static_cast<acl_size_t *>(data);
+    AclSizeLimit *l = static_cast<AclSizeLimit *>(data);
     aclDestroyAclList(&l->aclList);
 }
 
 static void
-parse_acl_b_size_t(acl_size_t ** head)
+parse_acl_b_size_t(AclSizeLimit ** head)
 {
-    acl_size_t *l;
-    acl_size_t **tail = head;	/* sane name below */
+    AclSizeLimit *l;
+    AclSizeLimit **tail = head;	/* sane name below */
 
-    CBDATA_INIT_TYPE_FREECB(acl_size_t, freed_acl_b_size_t);
+    CBDATA_INIT_TYPE_FREECB(AclSizeLimit, freed_acl_b_size_t);
 
-    l = cbdataAlloc(acl_size_t);
+    l = cbdataAlloc(AclSizeLimit);
 
     parse_b_int64_t(&l->size);
 
@@ -1601,10 +1602,10 @@ parse_acl_b_size_t(acl_size_t ** head)
 }
 
 static void
-free_acl_b_size_t(acl_size_t ** head)
+free_acl_b_size_t(AclSizeLimit ** head)
 {
     while (*head) {
-        acl_size_t *l = *head;
+        AclSizeLimit *l = *head;
         *head = l->next;
         l->next = NULL;
         cbdataFree(l);
@@ -1727,7 +1728,7 @@ parse_http_header_access(HeaderManglers **pm)
     if (!*pm)
         *pm = new HeaderManglers;
     HeaderManglers *manglers = *pm;
-    header_mangler *mangler = manglers->track(t);
+    headerMangler *mangler = manglers->track(t);
     assert(mangler);
     parse_acl_access(&mangler->access_list);
 }
@@ -1965,10 +1966,10 @@ peer_type_str(const peer_t type)
 }
 
 static void
-dump_peer(StoreEntry * entry, const char *name, peer * p)
+dump_peer(StoreEntry * entry, const char *name, CachePeer * p)
 {
-    domain_ping *d;
-    domain_type *t;
+    CachePeerDomainList *d;
+    NeighborTypeDomainList *t;
     LOCAL_ARRAY(char, xname, 128);
 
     while (p != NULL) {
@@ -2065,12 +2066,12 @@ GetUdpService(void)
 }
 
 static void
-parse_peer(peer ** head)
+parse_peer(CachePeer ** head)
 {
     char *token = NULL;
-    peer *p;
-    CBDATA_INIT_TYPE_FREECB(peer, peerDestroy);
-    p = cbdataAlloc(peer);
+    CachePeer *p;
+    CBDATA_INIT_TYPE_FREECB(CachePeer, peerDestroy);
+    p = cbdataAlloc(CachePeer);
     p->http_port = CACHE_HTTP_PORT;
     p->icp.port = CACHE_ICP_PORT;
     p->weight = 1;
@@ -2344,9 +2345,9 @@ parse_peer(peer ** head)
 }
 
 static void
-free_peer(peer ** P)
+free_peer(CachePeer ** P)
 {
-    peer *p;
+    CachePeer *p;
 
     while ((p = *P) != NULL) {
         *P = p->next;
@@ -2362,7 +2363,7 @@ free_peer(peer ** P)
 }
 
 static void
-dump_cachemgrpasswd(StoreEntry * entry, const char *name, cachemgr_passwd * list)
+dump_cachemgrpasswd(StoreEntry * entry, const char *name, Mgr::ActionPasswordList * list)
 {
     wordlist *w;
 
@@ -2382,15 +2383,15 @@ dump_cachemgrpasswd(StoreEntry * entry, const char *name, cachemgr_passwd * list
 }
 
 static void
-parse_cachemgrpasswd(cachemgr_passwd ** head)
+parse_cachemgrpasswd(Mgr::ActionPasswordList ** head)
 {
     char *passwd = NULL;
     wordlist *actions = NULL;
-    cachemgr_passwd *p;
-    cachemgr_passwd **P;
+    Mgr::ActionPasswordList *p;
+    Mgr::ActionPasswordList **P;
     parse_string(&passwd);
     parse_wordlist(&actions);
-    p = static_cast<cachemgr_passwd *>(xcalloc(1, sizeof(cachemgr_passwd)));
+    p = new Mgr::ActionPasswordList;
     p->passwd = passwd;
     p->actions = actions;
 
@@ -2399,7 +2400,7 @@ parse_cachemgrpasswd(cachemgr_passwd ** head)
          * See if any of the actions from this line already have a
          * password from previous lines.  The password checking
          * routines in cache_manager.c take the the password from
-         * the first cachemgr_passwd struct that contains the
+         * the first Mgr::ActionPasswordList that contains the
          * requested action.  Thus, we should warn users who might
          * think they can have two passwords for the same action.
          */
@@ -2420,9 +2421,9 @@ parse_cachemgrpasswd(cachemgr_passwd ** head)
 }
 
 static void
-free_cachemgrpasswd(cachemgr_passwd ** head)
+free_cachemgrpasswd(Mgr::ActionPasswordList ** head)
 {
-    cachemgr_passwd *p;
+    Mgr::ActionPasswordList *p;
 
     while ((p = *head) != NULL) {
         *head = p->next;
@@ -2433,9 +2434,9 @@ free_cachemgrpasswd(cachemgr_passwd ** head)
 }
 
 static void
-dump_denyinfo(StoreEntry * entry, const char *name, acl_deny_info_list * var)
+dump_denyinfo(StoreEntry * entry, const char *name, AclDenyInfoList * var)
 {
-    acl_name_list *a;
+    AclNameList *a;
 
     while (var != NULL) {
         storeAppendPrintf(entry, "%s %s", name, var->err_page_name);
@@ -2450,18 +2451,18 @@ dump_denyinfo(StoreEntry * entry, const char *name, acl_deny_info_list * var)
 }
 
 static void
-parse_denyinfo(acl_deny_info_list ** var)
+parse_denyinfo(AclDenyInfoList ** var)
 {
     aclParseDenyInfoLine(var);
 }
 
 void
-free_denyinfo(acl_deny_info_list ** list)
+free_denyinfo(AclDenyInfoList ** list)
 {
-    acl_deny_info_list *a = NULL;
-    acl_deny_info_list *a_next = NULL;
-    acl_name_list *l = NULL;
-    acl_name_list *l_next = NULL;
+    AclDenyInfoList *a = NULL;
+    AclDenyInfoList *a_next = NULL;
+    AclNameList *l = NULL;
+    AclNameList *l_next = NULL;
 
     for (a = *list; a; a = a_next) {
         for (l = a->acl_list; l; l = l_next) {
@@ -2482,7 +2483,7 @@ static void
 parse_peer_access(void)
 {
     char *host = NULL;
-    peer *p;
+    CachePeer *p;
 
     if (!(host = strtok(NULL, w_space)))
         self_destruct();
@@ -2505,20 +2506,20 @@ parse_hostdomain(void)
         self_destruct();
 
     while ((domain = strtok(NULL, list_sep))) {
-        domain_ping *l = NULL;
-        domain_ping **L = NULL;
-        peer *p;
+        CachePeerDomainList *l = NULL;
+        CachePeerDomainList **L = NULL;
+        CachePeer *p;
 
         if ((p = peerFindByName(host)) == NULL) {
             debugs(15, DBG_CRITICAL, "" << cfg_filename << ", line " << config_lineno << ": No cache_peer '" << host << "'");
             continue;
         }
 
-        l = static_cast<domain_ping *>(xcalloc(1, sizeof(domain_ping)));
-        l->do_ping = 1;
+        l = static_cast<CachePeerDomainList *>(xcalloc(1, sizeof(CachePeerDomainList)));
+        l->do_ping = true;
 
         if (*domain == '!') {	/* check for !.edu */
-            l->do_ping = 0;
+            l->do_ping = false;
             ++domain;
         }
 
@@ -2543,16 +2544,16 @@ parse_hostdomaintype(void)
         self_destruct();
 
     while ((domain = strtok(NULL, list_sep))) {
-        domain_type *l = NULL;
-        domain_type **L = NULL;
-        peer *p;
+        NeighborTypeDomainList *l = NULL;
+        NeighborTypeDomainList **L = NULL;
+        CachePeer *p;
 
         if ((p = peerFindByName(host)) == NULL) {
             debugs(15, DBG_CRITICAL, "" << cfg_filename << ", line " << config_lineno << ": No cache_peer '" << host << "'");
             return;
         }
 
-        l = static_cast<domain_type *>(xcalloc(1, sizeof(domain_type)));
+        l = static_cast<NeighborTypeDomainList *>(xcalloc(1, sizeof(NeighborTypeDomainList)));
         l->type = parseNeighborType(type);
         l->domain = xstrdup(domain);
 
@@ -2637,7 +2638,7 @@ parse_tristate(int *var)
 #define free_tristate free_int
 
 static void
-dump_refreshpattern(StoreEntry * entry, const char *name, refresh_t * head)
+dump_refreshpattern(StoreEntry * entry, const char *name, RefreshPattern * head)
 {
     while (head != NULL) {
         storeAppendPrintf(entry, "%s%s %s %d %d%% %d",
@@ -2671,9 +2672,6 @@ dump_refreshpattern(StoreEntry * entry, const char *name, refresh_t * head)
         if (head->flags.ignore_reload)
             storeAppendPrintf(entry, " ignore-reload");
 
-        if (head->flags.ignore_no_cache)
-            storeAppendPrintf(entry, " ignore-no-cache");
-
         if (head->flags.ignore_no_store)
             storeAppendPrintf(entry, " ignore-no-store");
 
@@ -2695,7 +2693,7 @@ dump_refreshpattern(StoreEntry * entry, const char *name, refresh_t * head)
 }
 
 static void
-parse_refreshpattern(refresh_t ** head)
+parse_refreshpattern(RefreshPattern ** head)
 {
     char *token;
     char *pattern;
@@ -2712,15 +2710,14 @@ parse_refreshpattern(refresh_t ** head)
     int override_lastmod = 0;
     int reload_into_ims = 0;
     int ignore_reload = 0;
-    int ignore_no_cache = 0;
     int ignore_no_store = 0;
     int ignore_must_revalidate = 0;
     int ignore_private = 0;
     int ignore_auth = 0;
 #endif
 
     int i;
-    refresh_t *t;
+    RefreshPattern *t;
     regex_t comp;
     int errcode;
     int flags = REG_EXTENDED | REG_NOSUB;
@@ -2791,8 +2788,6 @@ parse_refreshpattern(refresh_t ** head)
             override_expire = 1;
         else if (!strcmp(token, "override-lastmod"))
             override_lastmod = 1;
-        else if (!strcmp(token, "ignore-no-cache"))
-            ignore_no_cache = 1;
         else if (!strcmp(token, "ignore-no-store"))
             ignore_no_store = 1;
         else if (!strcmp(token, "ignore-must-revalidate"))
@@ -2811,6 +2806,8 @@ parse_refreshpattern(refresh_t ** head)
             /* tell client_side.c that this is used */
 #endif
 
+        } else if (!strcmp(token, "ignore-no-cache")) {
+            debugs(22, DBG_PARSE_NOTE(2), "UPGRADE: refresh_pattern option 'ignore-no-cache' is obsolete. Remove it.");
         } else
             debugs(22, DBG_CRITICAL, "refreshAddToList: Unknown option '" << pattern << "': " << token);
     }
@@ -2825,7 +2822,7 @@ parse_refreshpattern(refresh_t ** head)
 
     pct = pct < 0.0 ? 0.0 : pct;
     max = max < 0 ? 0 : max;
-    t = static_cast<refresh_t *>(xcalloc(1, sizeof(refresh_t)));
+    t = static_cast<RefreshPattern *>(xcalloc(1, sizeof(RefreshPattern)));
     t->pattern = (char *) xstrdup(pattern);
     t->compiled_pattern = comp;
     t->min = min;
@@ -2857,9 +2854,6 @@ parse_refreshpattern(refresh_t ** head)
     if (ignore_reload)
         t->flags.ignore_reload = 1;
 
-    if (ignore_no_cache)
-        t->flags.ignore_no_cache = 1;
-
     if (ignore_no_store)
         t->flags.ignore_no_store = 1;
 
@@ -2885,9 +2879,9 @@ parse_refreshpattern(refresh_t ** head)
 }
 
 static void
-free_refreshpattern(refresh_t ** head)
+free_refreshpattern(RefreshPattern ** head)
 {
-    refresh_t *t;
+    RefreshPattern *t;
 
     while ((t = *head) != NULL) {
         *head = t->next;
@@ -3294,18 +3288,6 @@ dump_removalpolicy(StoreEntry * entry, const char *name, RemovalPolicySettings *
     storeAppendPrintf(entry, "\n");
 }
 
-void
-YesNoNone::configure(bool beSet)
-{
-    option = beSet ? +1 : -1;
-}
-
-YesNoNone::operator void*() const
-{
-    assert(option != 0); // must call configure() first
-    return option > 0 ? (void*)this : NULL;
-}
-
 inline void
 free_YesNoNone(YesNoNone *)
 {
@@ -3666,7 +3648,7 @@ parse_port_option(AnyP::PortCfg * s, char *token)
         if (t) {
             ++t;
             s->tcp_keepalive.timeout = atoi(t);
-            t = strchr(t, ',');
+            // t = strchr(t, ','); // not really needed, left in as documentation
         }
 #if USE_SSL
     } else if (strcasecmp(token, "sslBump") == 0) {
@@ -3981,11 +3963,11 @@ strtokFile(void)
 #include "AccessLogEntry.h"
 
 static void
-parse_access_log(customlog ** logs)
+parse_access_log(CustomLog ** logs)
 {
     const char *filename, *logdef_name;
 
-    customlog *cl = (customlog *)xcalloc(1, sizeof(*cl));
+    CustomLog *cl = (CustomLog *)xcalloc(1, sizeof(*cl));
 
     if ((filename = strtok(NULL, w_space)) == NULL) {
         self_destruct();
@@ -4055,15 +4037,15 @@ parse_access_log(customlog ** logs)
 }
 
 static int
-check_null_access_log(customlog *customlog_definitions)
+check_null_access_log(CustomLog *customlog_definitions)
 {
     return customlog_definitions == NULL;
 }
 
 static void
-dump_access_log(StoreEntry * entry, const char *name, customlog * logs)
+dump_access_log(StoreEntry * entry, const char *name, CustomLog * logs)
 {
-    customlog *log;
+    CustomLog *log;
 
     for (log = logs; log; log = log->next) {
         storeAppendPrintf(entry, "%s ", name);
@@ -4115,10 +4097,10 @@ dump_access_log(StoreEntry * entry, const char *name, customlog * logs)
 }
 
 static void
-free_access_log(customlog ** definitions)
+free_access_log(CustomLog ** definitions)
 {
     while (*definitions) {
-        customlog *log = *definitions;
+        CustomLog *log = *definitions;
         *definitions = log->next;
 
         log->logFormat = NULL;
@@ -4229,24 +4211,6 @@ parse_adaptation_access_type()
 {
     Adaptation::Config::ParseAccess(LegacyParser);
 }
-
-static void
-parse_adaptation_meta_type(Adaptation::Config::MetaHeaders *)
-{
-    Adaptation::Config::ParseMetaHeader(LegacyParser);
-}
-
-static void
-dump_adaptation_meta_type(StoreEntry *entry, const char *name, Adaptation::Config::MetaHeaders &)
-{
-    Adaptation::Config::DumpMetaHeader(entry, name);
-}
-
-static void
-free_adaptation_meta_type(Adaptation::Config::MetaHeaders *)
-{
-    // Nothing to do, it is released inside Adaptation::Config::freeService()
-}
 #endif /* USE_ADAPTATION */
 
 #if ICAP_CLIENT
@@ -4678,3 +4642,19 @@ static void free_HeaderWithAclList(HeaderWithAclList **header)
     delete *header;
     *header = NULL;
 }
+
+static void parse_note(Notes *notes)
+{
+    assert(notes);
+    notes->parse(LegacyParser);
+}
+
+static void dump_note(StoreEntry *entry, const char *name, Notes &notes)
+{
+    notes.dump(entry, name);
+}
+
+static void free_note(Notes *notes)
+{
+    notes->clean();
+}
@@ -35,17 +35,17 @@
 
 class wordlist;
 
-extern void configFreeMemory(void);
-extern void self_destruct(void);
-extern void add_http_port(char *portspec);
+void configFreeMemory(void);
+void self_destruct(void);
+void add_http_port(char *portspec);
 
 /* extra functions from cache_cf.c useful for lib modules */
-extern void parse_int(int *var);
-extern void parse_onoff(int *var);
-extern void parse_eol(char *volatile *var);
-extern void parse_wordlist(wordlist ** list);
-extern void requirePathnameExists(const char *name, const char *path);
-extern void parse_time_t(time_t * var);
-extern char *strtokFile(void);
+void parse_int(int *var);
+void parse_onoff(int *var);
+void parse_eol(char *volatile *var);
+void parse_wordlist(wordlist ** list);
+void requirePathnameExists(const char *name, const char *path);
+void parse_time_t(time_t * var);
+char *strtokFile(void);
 
 #endif /* SQUID_CACHE_CF_H_ */
@@ -32,6 +32,7 @@
 
 #include "squid.h"
 #include "base/TextException.h"
+#include "mgr/ActionPasswordList.h"
 #include "CacheManager.h"
 #include "comm/Connection.h"
 #include "Debug.h"
@@ -49,6 +50,7 @@
 #include "mgr/QueryParams.h"
 #include "protos.h"
 #include "tools.h"
+#include "SquidConfig.h"
 #include "SquidTime.h"
 #include "Store.h"
 #include "wordlist.h"
@@ -458,12 +460,12 @@ CacheManager::ActionProtection(const Mgr::ActionProfile::Pointer &profile)
 }
 
 /*
- \ingroup CacheManagerInternal
+ * \ingroup CacheManagerInternal
  * gets from the global Config the password the user would need to supply
  * for the action she queried
  */
 char *
-CacheManager::PasswdGet(cachemgr_passwd * a, const char *action)
+CacheManager::PasswdGet(Mgr::ActionPasswordList * a, const char *action)
 {
     wordlist *w;
 
@@ -33,9 +33,11 @@
  */
 
 #include "squid.h"
+#include "CachePeer.h"
 #include "HttpRequest.h"
 #include "mgr/Registration.h"
 #include "neighbors.h"
+#include "SquidConfig.h"
 #include "Store.h"
 #include "URL.h"
 #include "URLScheme.h"
@@ -47,14 +49,14 @@
 #define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
 
 static int n_carp_peers = 0;
-static peer **carp_peers = NULL;
+static CachePeer **carp_peers = NULL;
 static OBJH carpCachemgr;
 
 static int
 peerSortWeight(const void *a, const void *b)
 {
-    const peer *const *p1 = (const peer *const *)a;
-    const peer *const *p2 = (const peer *const *)b;
+    const CachePeer *const *p1 = (const CachePeer *const *)a;
+    const CachePeer *const *p2 = (const CachePeer *const *)b;
     return (*p1)->weight - (*p2)->weight;
 }
 
@@ -71,8 +73,8 @@ carpInit(void)
     int K;
     int k;
     double P_last, X_last, Xn;
-    peer *p;
-    peer **P;
+    CachePeer *p;
+    CachePeer **P;
     char *t;
     /* Clean up */
 
@@ -105,7 +107,7 @@ carpInit(void)
     if (n_carp_peers == 0)
         return;
 
-    carp_peers = (peer **)xcalloc(n_carp_peers, sizeof(*carp_peers));
+    carp_peers = (CachePeer **)xcalloc(n_carp_peers, sizeof(*carp_peers));
 
     /* Build a list of the found peers and calculate hashes and load factors */
     for (P = carp_peers, p = Config.peers; p; p = p->next) {
@@ -167,12 +169,12 @@ carpInit(void)
     }
 }
 
-peer *
+CachePeer *
 carpSelectParent(HttpRequest * request)
 {
     int k;
-    peer *p = NULL;
-    peer *tp;
+    CachePeer *p = NULL;
+    CachePeer *tp;
     unsigned int user_hash = 0;
     unsigned int combined_hash;
     double score;
@@ -184,7 +186,7 @@ carpSelectParent(HttpRequest * request)
     /* calculate hash key */
     debugs(39, 2, "carpSelectParent: Calculating hash for " << urlCanonical(request));
 
-    /* select peer */
+    /* select CachePeer */
     for (k = 0; k < n_carp_peers; ++k) {
         String key;
         tp = carp_peers[k];
@@ -250,7 +252,7 @@ carpSelectParent(HttpRequest * request)
 static void
 carpCachemgr(StoreEntry * sentry)
 {
-    peer *p;
+    CachePeer *p;
     int sumfetches = 0;
     storeAppendPrintf(sentry, "%24s %10s %10s %10s %10s\n",
                       "Hostname",
@@ -33,10 +33,10 @@
 #ifndef SQUID_CARP_H_
 #define SQUID_CARP_H_
 
-class peer;
+class CachePeer;
 class HttpRequest;
 
-extern void carpInit(void);
-extern peer *carpSelectParent(HttpRequest *);
+void carpInit(void);
+CachePeer *carpSelectParent(HttpRequest *);
 
 #endif /* SQUID_CARP_H_ */
@@ -234,30 +234,30 @@ typedef enum {
 } cbdata_type;
 
 /// \ingroup CBDATAAPI
-extern void cbdataRegisterWithCacheManager(void);
+void cbdataRegisterWithCacheManager(void);
 
 #if USE_CBDATA_DEBUG
-extern void *cbdataInternalAllocDbg(cbdata_type type, const char *, int);
-extern void *cbdataInternalFreeDbg(void *p, const char *, int);
-extern void cbdataInternalLockDbg(const void *p, const char *, int);
-extern void cbdataInternalUnlockDbg(const void *p, const char *, int);
-extern int cbdataInternalReferenceDoneValidDbg(void **p, void **tp, const char *, int);
+void *cbdataInternalAllocDbg(cbdata_type type, const char *, int);
+void *cbdataInternalFreeDbg(void *p, const char *, int);
+void cbdataInternalLockDbg(const void *p, const char *, int);
+void cbdataInternalUnlockDbg(const void *p, const char *, int);
+int cbdataInternalReferenceDoneValidDbg(void **p, void **tp, const char *, int);
 #else
 
 /// \ingroup CBDATAAPI
-extern void *cbdataInternalAlloc(cbdata_type type);
+void *cbdataInternalAlloc(cbdata_type type);
 
 /// \ingroup CBDATAAPI
-extern void *cbdataInternalFree(void *p);
+void *cbdataInternalFree(void *p);
 
 /// \ingroup CBDATAAPI
-extern void cbdataInternalLock(const void *p);
+void cbdataInternalLock(const void *p);
 
 /// \ingroup CBDATAAPI
-extern void cbdataInternalUnlock(const void *p);
+void cbdataInternalUnlock(const void *p);
 
 /// \ingroup CBDATAAPI
-extern int cbdataInternalReferenceDoneValid(void **p, void **tp);
+int cbdataInternalReferenceDoneValid(void **p, void **tp);
 
 #endif /* !CBDATA_DEBUG */
 
@@ -269,10 +269,10 @@ extern int cbdataInternalReferenceDoneValid(void **p, void **tp);
  \retval 0	A reference is stale. The pointer refers to a entry freed by cbdataFree().
  \retval true	The reference is valid and active.
  */
-extern int cbdataReferenceValid(const void *p);
+int cbdataReferenceValid(const void *p);
 
 /// \ingroup CBDATAAPI
-extern cbdata_type cbdataInternalAddType(cbdata_type type, const char *label, int size, FREE * free_func);
+cbdata_type cbdataInternalAddType(cbdata_type type, const char *label, int size, FREE * free_func);
 
 /* cbdata macros */
 #if USE_CBDATA_DEBUG
@@ -35,7 +35,6 @@ HeaderWithAclList	acl
 adaptation_access_type	adaptation_service_set adaptation_service_chain acl icap_service icap_class
 adaptation_service_set_type	icap_service ecap_service
 adaptation_service_chain_type	icap_service ecap_service
-adaptation_meta_type	acl
 icap_access_type	icap_class acl
 icap_class_type		icap_service
 icap_service_type
@@ -47,6 +46,7 @@ kb_size_t
 logformat
 YesNoNone
 memcachemode
+note			acl
 obsolete
 onoff
 peer
@@ -754,6 +754,8 @@ DOC_START
 
 	acl aclname url_regex [-i] ^http:// ...
 	  # regex matching on whole URL [fast]
+	acl aclname urllogin [-i] [^a-zA-Z0-9] ...
+	  # regex matching on URL login field
 	acl aclname urlpath_regex [-i] \.gif$ ...
 	  # regex matching on URL path [fast]
 
@@ -3273,6 +3275,10 @@ DOC_START
 		err_code    The ID of an error response served by Squid or
 				a similar internal error identifier.
 		err_detail  Additional err_code-dependent error information.
+		note	The meta header specified by the argument. Also
+			logs the adaptation meta headers set by the
+			adaptation_meta configuration parameter.
+			If no argument given all meta headers logged.
 
 	Connection related format codes:
 
@@ -3642,12 +3648,16 @@ LOC: Config.Log.store
 DOC_START
 	Logs the activities of the storage manager.  Shows which
 	objects are ejected from the cache, and which objects are
-	saved and for how long.  To disable, enter "none" or remove the line.
+	saved and for how long.
 	There are not really utilities to analyze this data, so you can safely
-	disable it.
-
+	disable it (the default).
+	
+	Store log uses modular logging outputs. See access_log for the list
+	of modules supported.
+	
 	Example:
-		cache_store_log @DEFAULT_STORE_LOG@
+		cache_store_log stdio:@DEFAULT_STORE_LOG@
+		cache_store_log daemon:@DEFAULT_STORE_LOG@
 DOC_END
 
 NAME: cache_swap_state cache_swap_log
@@ -4224,7 +4234,6 @@ DOC_START
 		 override-lastmod
 		 reload-into-ims
 		 ignore-reload
-		 ignore-no-cache
 		 ignore-no-store
 		 ignore-must-revalidate
 		 ignore-private
@@ -4257,12 +4266,6 @@ DOC_START
 		this feature could make you liable for problems which
 		it causes.
 
-		ignore-no-cache ignores any ``Pragma: no-cache'' and
-		``Cache-control: no-cache'' headers received from a server.
-		The HTTP RFC never allows the use of this (Pragma) header
-		from a server, only a client, though plenty of servers
-		send it anyway.
-
 		ignore-no-store ignores any ``Cache-control: no-store''
 		headers received from a server. Doing this VIOLATES
 		the HTTP standard. Enabling this feature could make you
@@ -4924,6 +4927,22 @@ DOC_START
 	only.
 DOC_END
 
+NAME: note
+TYPE: note
+LOC: Config.notes
+DEFAULT: none
+DOC_START
+	This option used to log custom information about the master
+	transaction. For example, an admin may configure Squid to log
+	which "user group" the transaction belongs to, where "user group"
+	will be determined based on a set of ACLs and not [just]
+	authentication information.
+	Values of key/value pairs can be logged using %{key}note macros:
+
+	    note key value acl ...
+	    logformat myFormat ... %{key}note ...
+DOC_END
+
 NAME: relaxed_header_parser
 COMMENT: on|off|warn
 TYPE: tristate
@@ -7402,7 +7421,7 @@ adaptation_masterx_shared_names X-Subscriber-ID
 DOC_END
 
 NAME: adaptation_meta
-TYPE: adaptation_meta_type
+TYPE: note
 IFDEF: USE_ADAPTATION
 LOC: Adaptation::Config::metaHeaders
 DEFAULT: none
@@ -7434,6 +7453,12 @@ DOC_START
 	any character, which is currently only useful for escaping backslashes
 	and double quotes. For example,
 	    "this string has one backslash (\\) and two \"quotes\""
+
+	Used adaptation_meta header values may be logged via %note
+	logformat code. If multiple adaptation_meta headers with the same name
+	are used during master transaction lifetime, the header values are
+	logged in the order they were used and duplicate values are ignored
+	(only the first repeated value will be logged).
 DOC_END
 
 NAME: icap_retry
@@ -8076,7 +8101,7 @@ DOC_START
 DOC_END
 
 NAME: windows_ipaddrchangemonitor
-IFDEF: _SQUID_MSWIN_
+IFDEF: _SQUID_WINDOWS_
 COMMENT: on|off
 TYPE: onoff
 DEFAULT: on
@@ -157,6 +157,7 @@ static void gen_conf(const EntryList &, std::ostream&, bool verbose_output);
 static void gen_default_if_none(const EntryList &, std::ostream&);
 static void gen_default_postscriptum(const EntryList &, std::ostream&);
 static bool isDefined(const std::string &name);
+static const char *available_if(const std::string &name);
 
 static void
 checkDepend(const std::string &directive, const char *name, const TypeList &types, const EntryList &entries)
@@ -551,7 +552,9 @@ gen_default_if_none(const EntryList &head, std::ostream &fout)
 {
     fout << "static void" << std::endl <<
     "defaults_if_none(void)" << std::endl <<
-    "{" << std::endl;
+    "{" << std::endl <<
+    "    cfg_filename = \"Default Configuration (if absent)\";" << std::endl <<
+    "    config_lineno = 0;" << std::endl;
 
     for (EntryList::const_iterator entry = head.begin(); entry != head.end(); ++entry) {
         assert(entry->name.size());
@@ -579,7 +582,8 @@ gen_default_if_none(const EntryList &head, std::ostream &fout)
             fout << "#endif" << std::endl;
     }
 
-    fout << "}" << std::endl << std::endl;
+    fout << "    cfg_filename = NULL;" << std::endl <<
+    "}" << std::endl << std::endl;
 }
 
 /// append configuration options specified by POSTSCRIPTUM lines
@@ -588,7 +592,9 @@ gen_default_postscriptum(const EntryList &head, std::ostream &fout)
 {
     fout << "static void" << std::endl <<
     "defaults_postscriptum(void)" << std::endl <<
-    "{" << std::endl;
+    "{" << std::endl <<
+    "    cfg_filename = \"Default Configuration (postscriptum)\";" << std::endl <<
+    "    config_lineno = 0;" << std::endl;
 
     for (EntryList::const_iterator entry = head.begin(); entry != head.end(); ++entry) {
         assert(entry->name.size());
@@ -609,19 +615,22 @@ gen_default_postscriptum(const EntryList &head, std::ostream &fout)
             fout << "#endif" << std::endl;
     }
 
-    fout << "}" << std::endl << std::endl;
+    fout << "    cfg_filename = NULL;" << std::endl <<
+    "}" << std::endl << std::endl;
 }
 
 void
 Entry::genParseAlias(const std::string &aName, std::ostream &fout) const
 {
     fout << "    if (!strcmp(token, \"" << aName << "\")) {" << std::endl;
+    if (ifdef.size())
+        fout << "#if " << ifdef << std::endl;
     fout << "        ";
     if (type.compare("obsolete") == 0) {
         fout << "debugs(0, DBG_CRITICAL, \"ERROR: Directive '" << aName << "' is obsolete.\");\n";
         for (LineList::const_iterator l = doc.begin(); l != doc.end(); ++l) {
             // offset line to strip initial whitespace tab byte
-            fout << "        debugs(0, opt_parse_cfg_only?0:1, \"" << aName << " : " << &(*l)[1] << "\");" << std::endl;
+            fout << "        debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), \"" << aName << " : " << &(*l)[1] << "\");" << std::endl;
         }
         fout << "        parse_obsolete(token);";
     } else if (!loc.size() || loc.compare("none") == 0) {
@@ -630,6 +639,12 @@ Entry::genParseAlias(const std::string &aName, std::ostream &fout) const
         fout << "parse_" << type << "(&" << loc << (array_flag ? "[0]" : "") << ");";
     }
     fout << std::endl;
+    if (ifdef.size()) {
+        fout <<
+        "#else" << std::endl <<
+        "    debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), \"ERROR: '" << name << "' requires " << available_if(ifdef) << "\");" << std::endl <<
+        "#endif" << std::endl;
+    }
     fout << "        return 1;" << std::endl;
     fout << "    };" << std::endl;
 }
@@ -640,19 +655,13 @@ Entry::genParse(std::ostream &fout) const
     if (name.compare("comment") == 0)
         return;
 
-    if (ifdef.size())
-        fout << "#if " << ifdef << std::endl;
-
     // Once for the current directive name
     genParseAlias(name, fout);
 
     // All accepted aliases
     for (EntryAliasList::const_iterator a = alias.begin(); a != alias.end(); ++a) {
         genParseAlias(*a, fout);
     }
-
-    if (ifdef.size())
-        fout << "#endif\n";
 }
 
 static void