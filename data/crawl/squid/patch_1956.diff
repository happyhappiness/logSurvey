@@ -1,5 +1,6 @@
 Changes to squid-1.1.beta2 (:
 
+	- Fixed UDP_HIT_OBJ objects ignoring 'proxy-only' setting.
 	- Added setting cachemgr.cgi fields from query string
 	  (Neil Murray).
 	- Split log type TCP_IFMODSINCE into TCP_IMS_HIT and
@@ -1,144 +1,144 @@
 /* Definitions for data structures and routines for the regular
-   expression library, version 0.12.
-
-   Copyright (C) 1985, 1989, 1990, 1991, 1992, 1993 Free Software Foundation, Inc.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
+ * expression library, version 0.12.
+ * 
+ * Copyright (C) 1985, 1989, 1990, 1991, 1992, 1993 Free Software Foundation, Inc.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
 
 #ifndef __REGEXP_LIBRARY_H__
 #define __REGEXP_LIBRARY_H__
 
 /* POSIX says that <sys/types.h> must be included (by the caller) before
-   <regex.h>.  */
+ * <regex.h>.  */
 
 #ifdef VMS
 /* VMS doesn't have `size_t' in <sys/types.h>, even though POSIX says it
-   should be there.  */
+ * should be there.  */
 #include <stddef.h>
 #endif
 
 
 /* The following bits are used to determine the regexp syntax we
-   recognize.  The set/not-set meanings are chosen so that Emacs syntax
-   remains the value 0.  The bits are given in alphabetical order, and
-   the definitions shifted by one from the previous bit; thus, when we
-   add or remove a bit, only one other definition need change.  */
+ * recognize.  The set/not-set meanings are chosen so that Emacs syntax
+ * remains the value 0.  The bits are given in alphabetical order, and
+ * the definitions shifted by one from the previous bit; thus, when we
+ * add or remove a bit, only one other definition need change.  */
 typedef unsigned reg_syntax_t;
 
 /* If this bit is not set, then \ inside a bracket expression is literal.
-   If set, then such a \ quotes the following character.  */
+ * If set, then such a \ quotes the following character.  */
 #define RE_BACKSLASH_ESCAPE_IN_LISTS (1)
 
 /* If this bit is not set, then + and ? are operators, and \+ and \? are
-     literals. 
-   If set, then \+ and \? are operators and + and ? are literals.  */
+ * literals. 
+ * If set, then \+ and \? are operators and + and ? are literals.  */
 #define RE_BK_PLUS_QM (RE_BACKSLASH_ESCAPE_IN_LISTS << 1)
 
 /* If this bit is set, then character classes are supported.  They are:
-     [:alpha:], [:upper:], [:lower:],  [:digit:], [:alnum:], [:xdigit:],
-     [:space:], [:print:], [:punct:], [:graph:], and [:cntrl:].
-   If not set, then character classes are not supported.  */
+ * [:alpha:], [:upper:], [:lower:],  [:digit:], [:alnum:], [:xdigit:],
+ * [:space:], [:print:], [:punct:], [:graph:], and [:cntrl:].
+ * If not set, then character classes are not supported.  */
 #define RE_CHAR_CLASSES (RE_BK_PLUS_QM << 1)
 
 /* If this bit is set, then ^ and $ are always anchors (outside bracket
-     expressions, of course).
-   If this bit is not set, then it depends:
-        ^  is an anchor if it is at the beginning of a regular
-           expression or after an open-group or an alternation operator;
-        $  is an anchor if it is at the end of a regular expression, or
-           before a close-group or an alternation operator.  
-
-   This bit could be (re)combined with RE_CONTEXT_INDEP_OPS, because
-   POSIX draft 11.2 says that * etc. in leading positions is undefined.
-   We already implemented a previous draft which made those constructs
-   invalid, though, so we haven't changed the code back.  */
+ * expressions, of course).
+ * If this bit is not set, then it depends:
+ * ^  is an anchor if it is at the beginning of a regular
+ * expression or after an open-group or an alternation operator;
+ * $  is an anchor if it is at the end of a regular expression, or
+ * before a close-group or an alternation operator.  
+ * 
+ * This bit could be (re)combined with RE_CONTEXT_INDEP_OPS, because
+ * POSIX draft 11.2 says that * etc. in leading positions is undefined.
+ * We already implemented a previous draft which made those constructs
+ * invalid, though, so we haven't changed the code back.  */
 #define RE_CONTEXT_INDEP_ANCHORS (RE_CHAR_CLASSES << 1)
 
 /* If this bit is set, then special characters are always special
-     regardless of where they are in the pattern.
-   If this bit is not set, then special characters are special only in
-     some contexts; otherwise they are ordinary.  Specifically, 
-     * + ? and intervals are only special when not after the beginning,
-     open-group, or alternation operator.  */
+ * regardless of where they are in the pattern.
+ * If this bit is not set, then special characters are special only in
+ * some contexts; otherwise they are ordinary.  Specifically, 
+ * * + ? and intervals are only special when not after the beginning,
+ * open-group, or alternation operator.  */
 #define RE_CONTEXT_INDEP_OPS (RE_CONTEXT_INDEP_ANCHORS << 1)
 
 /* If this bit is set, then *, +, ?, and { cannot be first in an re or
-     immediately after an alternation or begin-group operator.  */
+ * immediately after an alternation or begin-group operator.  */
 #define RE_CONTEXT_INVALID_OPS (RE_CONTEXT_INDEP_OPS << 1)
 
 /* If this bit is set, then . matches newline.
-   If not set, then it doesn't.  */
+ * If not set, then it doesn't.  */
 #define RE_DOT_NEWLINE (RE_CONTEXT_INVALID_OPS << 1)
 
 /* If this bit is set, then . doesn't match NUL.
-   If not set, then it does.  */
+ * If not set, then it does.  */
 #define RE_DOT_NOT_NULL (RE_DOT_NEWLINE << 1)
 
 /* If this bit is set, nonmatching lists [^...] do not match newline.
-   If not set, they do.  */
+ * If not set, they do.  */
 #define RE_HAT_LISTS_NOT_NEWLINE (RE_DOT_NOT_NULL << 1)
 
 /* If this bit is set, either \{...\} or {...} defines an
-     interval, depending on RE_NO_BK_BRACES. 
-   If not set, \{, \}, {, and } are literals.  */
+ * interval, depending on RE_NO_BK_BRACES. 
+ * If not set, \{, \}, {, and } are literals.  */
 #define RE_INTERVALS (RE_HAT_LISTS_NOT_NEWLINE << 1)
 
 /* If this bit is set, +, ? and | aren't recognized as operators.
-   If not set, they are.  */
+ * If not set, they are.  */
 #define RE_LIMITED_OPS (RE_INTERVALS << 1)
 
 /* If this bit is set, newline is an alternation operator.
-   If not set, newline is literal.  */
+ * If not set, newline is literal.  */
 #define RE_NEWLINE_ALT (RE_LIMITED_OPS << 1)
 
 /* If this bit is set, then `{...}' defines an interval, and \{ and \}
-     are literals.
-  If not set, then `\{...\}' defines an interval.  */
+ * are literals.
+ * If not set, then `\{...\}' defines an interval.  */
 #define RE_NO_BK_BRACES (RE_NEWLINE_ALT << 1)
 
 /* If this bit is set, (...) defines a group, and \( and \) are literals.
-   If not set, \(...\) defines a group, and ( and ) are literals.  */
+ * If not set, \(...\) defines a group, and ( and ) are literals.  */
 #define RE_NO_BK_PARENS (RE_NO_BK_BRACES << 1)
 
 /* If this bit is set, then \<digit> matches <digit>.
-   If not set, then \<digit> is a back-reference.  */
+ * If not set, then \<digit> is a back-reference.  */
 #define RE_NO_BK_REFS (RE_NO_BK_PARENS << 1)
 
 /* If this bit is set, then | is an alternation operator, and \| is literal. 
-   If not set, then \| is an alternation operator, and | is literal.  */
+ * If not set, then \| is an alternation operator, and | is literal.  */
 #define RE_NO_BK_VBAR (RE_NO_BK_REFS << 1)
 
 /* If this bit is set, then an ending range point collating higher
-     than the starting range point, as in [z-a], is invalid.
-   If not set, then when ending range point collates higher than the
-     starting range point, the range is ignored.  */
+ * than the starting range point, as in [z-a], is invalid.
+ * If not set, then when ending range point collates higher than the
+ * starting range point, the range is ignored.  */
 #define RE_NO_EMPTY_RANGES (RE_NO_BK_VBAR << 1)
 
 /* If this bit is set, then an unmatched ) is ordinary.
-   If not set, then an unmatched ) is invalid.  */
+ * If not set, then an unmatched ) is invalid.  */
 #define RE_UNMATCHED_RIGHT_PAREN_ORD (RE_NO_EMPTY_RANGES << 1)
 
 /* This global variable defines the particular regexp syntax to use (for
-   some interfaces).  When a regexp is compiled, the syntax used is
-   stored in the pattern buffer, so changing this does not affect
-   already-compiled regexps.  */
+ * some interfaces).  When a regexp is compiled, the syntax used is
+ * stored in the pattern buffer, so changing this does not affect
+ * already-compiled regexps.  */
 extern reg_syntax_t re_syntax_options;
 
 /* Define combinations of the above bits for the standard possibilities.
-   (The [[[ comments delimit what gets put into the Texinfo file, so
-   don't delete them!)  */ 
+ * (The [[[ comments delimit what gets put into the Texinfo file, so
+ * don't delete them!)  */
 /* [[[begin syntaxes]]] */
 #define RE_SYNTAX_EMACS 0
 
@@ -179,8 +179,8 @@ extern reg_syntax_t re_syntax_options;
   (_RE_SYNTAX_POSIX_COMMON | RE_BK_PLUS_QM)
 
 /* Differs from ..._POSIX_BASIC only in that RE_BK_PLUS_QM becomes
-   RE_LIMITED_OPS, i.e., \? \+ \| are not recognized.  Actually, this
-   isn't minimal, since other operators, such as \`, aren't disabled.  */
+ * RE_LIMITED_OPS, i.e., \? \+ \| are not recognized.  Actually, this
+ * isn't minimal, since other operators, such as \`, aren't disabled.  */
 #define RE_SYNTAX_POSIX_MINIMAL_BASIC					\
   (_RE_SYNTAX_POSIX_COMMON | RE_LIMITED_OPS)
 
@@ -191,7 +191,7 @@ extern reg_syntax_t re_syntax_options;
    | RE_UNMATCHED_RIGHT_PAREN_ORD)
 
 /* Differs from ..._POSIX_EXTENDED in that RE_CONTEXT_INVALID_OPS
-   replaces RE_CONTEXT_INDEP_OPS and RE_NO_BK_REFS is added.  */
+ * replaces RE_CONTEXT_INDEP_OPS and RE_NO_BK_REFS is added.  */
 #define RE_SYNTAX_POSIX_MINIMAL_EXTENDED				\
   (_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS			\
    | RE_CONTEXT_INVALID_OPS | RE_NO_BK_BRACES				\
@@ -200,145 +200,143 @@ extern reg_syntax_t re_syntax_options;
 /* [[[end syntaxes]]] */
 
 /* Maximum number of duplicates an interval can allow.  Some systems
-   (erroneously) define this in other header files, but we want our
-   value, so remove any previous define.  */
+ * (erroneously) define this in other header files, but we want our
+ * value, so remove any previous define.  */
 #ifdef RE_DUP_MAX
 #undef RE_DUP_MAX
 #endif
-#define RE_DUP_MAX ((1 << 15) - 1) 
+#define RE_DUP_MAX ((1 << 15) - 1)
 
 
 /* POSIX `cflags' bits (i.e., information for `regcomp').  */
 
 /* If this bit is set, then use extended regular expression syntax.
-   If not set, then use basic regular expression syntax.  */
+ * If not set, then use basic regular expression syntax.  */
 #define REG_EXTENDED 1
 
 /* If this bit is set, then ignore case when matching.
-   If not set, then case is significant.  */
+ * If not set, then case is significant.  */
 #define REG_ICASE (REG_EXTENDED << 1)
- 
+
 /* If this bit is set, then anchors do not match at newline
-     characters in the string.
-   If not set, then anchors do match at newlines.  */
+ * characters in the string.
+ * If not set, then anchors do match at newlines.  */
 #define REG_NEWLINE (REG_ICASE << 1)
 
 /* If this bit is set, then report only success or fail in regexec.
-   If not set, then returns differ between not matching and errors.  */
+ * If not set, then returns differ between not matching and errors.  */
 #define REG_NOSUB (REG_NEWLINE << 1)
 
 
 /* POSIX `eflags' bits (i.e., information for regexec).  */
 
 /* If this bit is set, then the beginning-of-line operator doesn't match
-     the beginning of the string (presumably because it's not the
-     beginning of a line).
-   If not set, then the beginning-of-line operator does match the
-     beginning of the string.  */
+ * the beginning of the string (presumably because it's not the
+ * beginning of a line).
+ * If not set, then the beginning-of-line operator does match the
+ * beginning of the string.  */
 #define REG_NOTBOL 1
 
 /* Like REG_NOTBOL, except for the end-of-line.  */
 #define REG_NOTEOL (1 << 1)
 
 
 /* If any error codes are removed, changed, or added, update the
-   `re_error_msg' table in regex.c.  */
-typedef enum
-{
-  REG_NOERROR = 0,	/* Success.  */
-  REG_NOMATCH,		/* Didn't find a match (for regexec).  */
-
-  /* POSIX regcomp return error codes.  (In the order listed in the
-     standard.)  */
-  REG_BADPAT,		/* Invalid pattern.  */
-  REG_ECOLLATE,		/* Not implemented.  */
-  REG_ECTYPE,		/* Invalid character class name.  */
-  REG_EESCAPE,		/* Trailing backslash.  */
-  REG_ESUBREG,		/* Invalid back reference.  */
-  REG_EBRACK,		/* Unmatched left bracket.  */
-  REG_EPAREN,		/* Parenthesis imbalance.  */ 
-  REG_EBRACE,		/* Unmatched \{.  */
-  REG_BADBR,		/* Invalid contents of \{\}.  */
-  REG_ERANGE,		/* Invalid range end.  */
-  REG_ESPACE,		/* Ran out of memory.  */
-  REG_BADRPT,		/* No preceding re for repetition op.  */
-
-  /* Error codes we've added.  */
-  REG_EEND,		/* Premature end.  */
-  REG_ESIZE,		/* Compiled pattern bigger than 2^16 bytes.  */
-  REG_ERPAREN		/* Unmatched ) or \); not returned from regcomp.  */
+ * `re_error_msg' table in regex.c.  */
+typedef enum {
+    REG_NOERROR = 0,		/* Success.  */
+    REG_NOMATCH,		/* Didn't find a match (for regexec).  */
+
+    /* POSIX regcomp return error codes.  (In the order listed in the
+     * standard.)  */
+    REG_BADPAT,			/* Invalid pattern.  */
+    REG_ECOLLATE,		/* Not implemented.  */
+    REG_ECTYPE,			/* Invalid character class name.  */
+    REG_EESCAPE,		/* Trailing backslash.  */
+    REG_ESUBREG,		/* Invalid back reference.  */
+    REG_EBRACK,			/* Unmatched left bracket.  */
+    REG_EPAREN,			/* Parenthesis imbalance.  */
+    REG_EBRACE,			/* Unmatched \{.  */
+    REG_BADBR,			/* Invalid contents of \{\}.  */
+    REG_ERANGE,			/* Invalid range end.  */
+    REG_ESPACE,			/* Ran out of memory.  */
+    REG_BADRPT,			/* No preceding re for repetition op.  */
+
+    /* Error codes we've added.  */
+    REG_EEND,			/* Premature end.  */
+    REG_ESIZE,			/* Compiled pattern bigger than 2^16 bytes.  */
+    REG_ERPAREN			/* Unmatched ) or \); not returned from regcomp.  */
 } reg_errcode_t;
 
 /* This data structure represents a compiled pattern.  Before calling
-   the pattern compiler, the fields `buffer', `allocated', `fastmap',
-   `translate', and `no_sub' can be set.  After the pattern has been
-   compiled, the `re_nsub' field is available.  All other fields are
-   private to the regex routines.  */
+ * the pattern compiler, the fields `buffer', `allocated', `fastmap',
+ * `translate', and `no_sub' can be set.  After the pattern has been
+ * compiled, the `re_nsub' field is available.  All other fields are
+ * private to the regex routines.  */
 
-struct re_pattern_buffer
-{
+struct re_pattern_buffer {
 /* [[[begin pattern_buffer]]] */
-	/* Space that holds the compiled pattern.  It is declared as
-          `unsigned char *' because its elements are
-           sometimes used as array indexes.  */
-  unsigned char *buffer;
-
-	/* Number of bytes to which `buffer' points.  */
-  unsigned long allocated;
-
-	/* Number of bytes actually used in `buffer'.  */
-  unsigned long used;	
-
-        /* Syntax setting with which the pattern was compiled.  */
-  reg_syntax_t syntax;
-
-        /* Pointer to a fastmap, if any, otherwise zero.  re_search uses
-           the fastmap, if there is one, to skip over impossible
-           starting points for matches.  */
-  char *fastmap;
-
-        /* Either a translate table to apply to all characters before
-           comparing them, or zero for no translation.  The translation
-           is applied to a pattern when it is compiled and to a string
-           when it is matched.  */
-  char *translate;
-
-	/* Number of subexpressions found by the compiler.  */
-  size_t re_nsub;
-
-        /* Zero if this pattern cannot match the empty string, one else.
-           Well, in truth it's used only in `re_search_2', to see
-           whether or not we should use the fastmap, so we don't set
-           this absolutely perfectly; see `re_compile_fastmap' (the
-           `duplicate' case).  */
-  unsigned can_be_null : 1;
-
-        /* If REGS_UNALLOCATED, allocate space in the `regs' structure
-             for `max (RE_NREGS, re_nsub + 1)' groups.
-           If REGS_REALLOCATE, reallocate space if necessary.
-           If REGS_FIXED, use what's there.  */
+    /* Space that holds the compiled pattern.  It is declared as
+     * `unsigned char *' because its elements are
+     * sometimes used as array indexes.  */
+    unsigned char *buffer;
+
+    /* Number of bytes to which `buffer' points.  */
+    unsigned long allocated;
+
+    /* Number of bytes actually used in `buffer'.  */
+    unsigned long used;
+
+    /* Syntax setting with which the pattern was compiled.  */
+    reg_syntax_t syntax;
+
+    /* Pointer to a fastmap, if any, otherwise zero.  re_search uses
+     * the fastmap, if there is one, to skip over impossible
+     * starting points for matches.  */
+    char *fastmap;
+
+    /* Either a translate table to apply to all characters before
+     * comparing them, or zero for no translation.  The translation
+     * is applied to a pattern when it is compiled and to a string
+     * when it is matched.  */
+    char *translate;
+
+    /* Number of subexpressions found by the compiler.  */
+    size_t re_nsub;
+
+    /* Zero if this pattern cannot match the empty string, one else.
+     * Well, in truth it's used only in `re_search_2', to see
+     * whether or not we should use the fastmap, so we don't set
+     * this absolutely perfectly; see `re_compile_fastmap' (the
+     * `duplicate' case).  */
+    unsigned can_be_null:1;
+
+    /* If REGS_UNALLOCATED, allocate space in the `regs' structure
+     * for `max (RE_NREGS, re_nsub + 1)' groups.
+     * If REGS_REALLOCATE, reallocate space if necessary.
+     * If REGS_FIXED, use what's there.  */
 #define REGS_UNALLOCATED 0
 #define REGS_REALLOCATE 1
 #define REGS_FIXED 2
-  unsigned regs_allocated : 2;
+    unsigned regs_allocated:2;
 
-        /* Set to zero when `regex_compile' compiles a pattern; set to one
-           by `re_compile_fastmap' if it updates the fastmap.  */
-  unsigned fastmap_accurate : 1;
+    /* Set to zero when `regex_compile' compiles a pattern; set to one
+     * by `re_compile_fastmap' if it updates the fastmap.  */
+    unsigned fastmap_accurate:1;
 
-        /* If set, `re_match_2' does not return information about
-           subexpressions.  */
-  unsigned no_sub : 1;
+    /* If set, `re_match_2' does not return information about
+     * subexpressions.  */
+    unsigned no_sub:1;
 
-        /* If set, a beginning-of-line anchor doesn't match at the
-           beginning of the string.  */ 
-  unsigned not_bol : 1;
+    /* If set, a beginning-of-line anchor doesn't match at the
+     * beginning of the string.  */
+    unsigned not_bol:1;
 
-        /* Similarly for an end-of-line anchor.  */
-  unsigned not_eol : 1;
+    /* Similarly for an end-of-line anchor.  */
+    unsigned not_eol:1;
 
-        /* If true, an anchor at a newline matches.  */
-  unsigned newline_anchor : 1;
+    /* If true, an anchor at a newline matches.  */
+    unsigned newline_anchor:1;
 
 /* [[[end pattern_buffer]]] */
 };
@@ -347,47 +345,45 @@ typedef struct re_pattern_buffer regex_t;
 
 
 /* search.c (search_buffer) in Emacs needs this one opcode value.  It is
-   defined both in `regex.c' and here.  */
+ * defined both in `regex.c' and here.  */
 #define RE_EXACTN_VALUE 1
 
 /* Type for byte offsets within the string.  POSIX mandates this.  */
 typedef int regoff_t;
 
 
 /* This is the structure we store register match data in.  See
-   regex.texinfo for a full description of what registers match.  */
-struct re_registers
-{
-  unsigned num_regs;
-  regoff_t *start;
-  regoff_t *end;
+ * regex.texinfo for a full description of what registers match.  */
+struct re_registers {
+    unsigned num_regs;
+    regoff_t *start;
+    regoff_t *end;
 };
 
 
 /* If `regs_allocated' is REGS_UNALLOCATED in the pattern buffer,
-   `re_match_2' returns information about at least this many registers
-   the first time a `regs' structure is passed.  */
+ * `re_match_2' returns information about at least this many registers
+ * the first time a `regs' structure is passed.  */
 #ifndef RE_NREGS
 #define RE_NREGS 30
 #endif
 
 
 /* POSIX specification for registers.  Aside from the different names than
-   `re_registers', POSIX uses an array of structures, instead of a
-   structure of arrays.  */
-typedef struct
-{
-  regoff_t rm_so;  /* Byte offset from string's start to substring's start.  */
-  regoff_t rm_eo;  /* Byte offset from string's start to substring's end.  */
+ * `re_registers', POSIX uses an array of structures, instead of a
+ * structure of arrays.  */
+typedef struct {
+    regoff_t rm_so;		/* Byte offset from string's start to substring's start.  */
+    regoff_t rm_eo;		/* Byte offset from string's start to substring's end.  */
 } regmatch_t;
 
 /* Declarations for routines.  */
 
 /* To avoid duplicating every routine declaration -- once with a
-   prototype (if we are ANSI), and once without (if we aren't) -- we
-   use the following macro to declare argument types.  This
-   unfortunately clutters up the declarations a bit, but I think it's
-   worth it.  */
+ * prototype (if we are ANSI), and once without (if we aren't) -- we
+ * use the following macro to declare argument types.  This
+ * unfortunately clutters up the declarations a bit, but I think it's
+ * worth it.  */
 
 #if __STDC__
 
@@ -400,91 +396,91 @@ typedef struct
 #endif /* not __STDC__ */
 
 /* Sets the current default syntax to SYNTAX, and return the old syntax.
-   You can also simply assign to the `re_syntax_options' variable.  */
-extern reg_syntax_t re_set_syntax _RE_ARGS ((reg_syntax_t syntax));
+ * You can also simply assign to the `re_syntax_options' variable.  */
+extern reg_syntax_t re_set_syntax _RE_ARGS((reg_syntax_t syntax));
 
 /* Compile the regular expression PATTERN, with length LENGTH
-   and syntax given by the global `re_syntax_options', into the buffer
-   BUFFER.  Return NULL if successful, and an error string if not.  */
+ * and syntax given by the global `re_syntax_options', into the buffer
+ * BUFFER.  Return NULL if successful, and an error string if not.  */
 extern const char *re_compile_pattern
-  _RE_ARGS ((const char *pattern, int length,
-             struct re_pattern_buffer *buffer));
+     _RE_ARGS((const char *pattern, int length,
+	struct re_pattern_buffer * buffer));
 
 
 /* Compile a fastmap for the compiled pattern in BUFFER; used to
-   accelerate searches.  Return 0 if successful and -2 if was an
-   internal error.  */
-extern int re_compile_fastmap _RE_ARGS ((struct re_pattern_buffer *buffer));
+ * accelerate searches.  Return 0 if successful and -2 if was an
+ * internal error.  */
+extern int re_compile_fastmap _RE_ARGS((struct re_pattern_buffer * buffer));
 
 
 /* Search in the string STRING (with length LENGTH) for the pattern
-   compiled into BUFFER.  Start searching at position START, for RANGE
-   characters.  Return the starting position of the match, -1 for no
-   match, or -2 for an internal error.  Also return register
-   information in REGS (if REGS and BUFFER->no_sub are nonzero).  */
+ * compiled into BUFFER.  Start searching at position START, for RANGE
+ * characters.  Return the starting position of the match, -1 for no
+ * match, or -2 for an internal error.  Also return register
+ * information in REGS (if REGS and BUFFER->no_sub are nonzero).  */
 extern int re_search
-  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string,
-            int length, int start, int range, struct re_registers *regs));
+    _RE_ARGS((struct re_pattern_buffer * buffer, const char *string,
+	int length, int start, int range, struct re_registers * regs));
 
 
 /* Like `re_search', but search in the concatenation of STRING1 and
-   STRING2.  Also, stop searching at index START + STOP.  */
+ * STRING2.  Also, stop searching at index START + STOP.  */
 extern int re_search_2
-  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string1,
-             int length1, const char *string2, int length2,
-             int start, int range, struct re_registers *regs, int stop));
+    _RE_ARGS((struct re_pattern_buffer * buffer, const char *string1,
+	int length1, const char *string2, int length2,
+	int start, int range, struct re_registers * regs, int stop));
 
 
 /* Like `re_search', but return how many characters in STRING the regexp
-   in BUFFER matched, starting at position START.  */
+ * in BUFFER matched, starting at position START.  */
 extern int re_match
-  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string,
-             int length, int start, struct re_registers *regs));
+    _RE_ARGS((struct re_pattern_buffer * buffer, const char *string,
+	int length, int start, struct re_registers * regs));
 
 
 /* Relates to `re_match' as `re_search_2' relates to `re_search'.  */
-extern int re_match_2 
-  _RE_ARGS ((struct re_pattern_buffer *buffer, const char *string1,
-             int length1, const char *string2, int length2,
-             int start, struct re_registers *regs, int stop));
+extern int re_match_2
+    _RE_ARGS((struct re_pattern_buffer * buffer, const char *string1,
+	int length1, const char *string2, int length2,
+	int start, struct re_registers * regs, int stop));
 
 
 /* Set REGS to hold NUM_REGS registers, storing them in STARTS and
-   ENDS.  Subsequent matches using BUFFER and REGS will use this memory
-   for recording register information.  STARTS and ENDS must be
-   allocated with malloc, and must each be at least `NUM_REGS * sizeof
-   (regoff_t)' bytes long.
-
-   If NUM_REGS == 0, then subsequent matches should allocate their own
-   register data.
-
-   Unless this function is called, the first search or match using
-   PATTERN_BUFFER will allocate its own register data, without
-   freeing the old data.  */
+ * ENDS.  Subsequent matches using BUFFER and REGS will use this memory
+ * for recording register information.  STARTS and ENDS must be
+ * allocated with malloc, and must each be at least `NUM_REGS * sizeof
+ * (regoff_t)' bytes long.
+ * 
+ * If NUM_REGS == 0, then subsequent matches should allocate their own
+ * register data.
+ * 
+ * Unless this function is called, the first search or match using
+ * PATTERN_BUFFER will allocate its own register data, without
+ * freeing the old data.  */
 extern void re_set_registers
-  _RE_ARGS ((struct re_pattern_buffer *buffer, struct re_registers *regs,
-             unsigned num_regs, regoff_t *starts, regoff_t *ends));
+     _RE_ARGS((struct re_pattern_buffer * buffer, struct re_registers * regs,
+	unsigned num_regs, regoff_t * starts, regoff_t * ends));
 
 /* 4.2 bsd compatibility.  */
-extern char *re_comp _RE_ARGS ((const char *));
-extern int re_exec _RE_ARGS ((const char *));
+extern char *re_comp _RE_ARGS((const char *));
+extern int re_exec _RE_ARGS((const char *));
 
 /* POSIX compatibility.  */
-extern int regcomp _RE_ARGS ((regex_t *preg, const char *pattern, int cflags));
+extern int regcomp _RE_ARGS((regex_t * preg, const char *pattern, int cflags));
 extern int regexec
-  _RE_ARGS ((const regex_t *preg, const char *string, size_t nmatch,
-             regmatch_t pmatch[], int eflags));
+    _RE_ARGS((const regex_t * preg, const char *string, size_t nmatch,
+	regmatch_t pmatch[], int eflags));
 extern size_t regerror
-  _RE_ARGS ((int errcode, const regex_t *preg, char *errbuf,
-             size_t errbuf_size));
-extern void regfree _RE_ARGS ((regex_t *preg));
+       _RE_ARGS((int errcode, const regex_t * preg, char *errbuf,
+	size_t errbuf_size));
+extern void regfree _RE_ARGS((regex_t * preg));
 
 #endif /* not __REGEXP_LIBRARY_H__ */
 
 /*
-Local variables:
-make-backup-files: t
-version-control: t
-trim-versions-without-asking: nil
-End:
-*/
+ * Local variables:
+ * make-backup-files: t
+ * version-control: t
+ * trim-versions-without-asking: nil
+ * End:
+ */
@@ -1,21 +1,21 @@
 /* Copyright (C) 1991, 1992, 1993 Free Software Foundation, Inc.
-This file is part of the GNU C Library.
-The GNU C Library is free software; you can redistribute it and/or
-modify it under the terms of the GNU Library General Public License as
-published by the Free Software Foundation; either version 2 of the
-License, or (at your option) any later version.
-
-The GNU C Library is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-Library General Public License for more details.
-
-You should have received a copy of the GNU Library General Public
-License along with the GNU C Library; see the file COPYING.LIB.  If
-not, write to the Free Software Foundation, Inc., 675 Mass Ave,
-Cambridge, MA 02139, USA.  */
+ * This file is part of the GNU C Library.
+ * The GNU C Library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ * 
+ * The GNU C Library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Library General Public
+ * License along with the GNU C Library; see the file COPYING.LIB.  If
+ * not, write to the Free Software Foundation, Inc., 675 Mass Ave,
+ * Cambridge, MA 02139, USA.  */
 
 #ifndef _TEMPNAM_H
 #define _TEMPNAM_H
-extern char *tempnam (const char *, const char *);
+extern char *tempnam(const char *, const char *);
 #endif /* _TEMPNAM_H */
@@ -1,5 +1,5 @@
 /*
- * $Id: util.h,v 1.11 1996/09/04 22:51:13 wessels Exp $
+ * $Id: util.h,v 1.12 1996/09/14 08:50:43 wessels Exp $
  *
  * AUTHOR: Harvest Derived
  *
@@ -130,7 +130,7 @@
 #endif /* _PARAMS */
 
 #if !HAVE_STRDUP
-extern char *strdup _PARAMS((char *));
+extern char *strdup(char *);
 #endif
 extern char *xstrdup _PARAMS((char *));		/* Duplicate a string */
 
@@ -140,13 +140,13 @@ void *xrealloc _PARAMS((void *, size_t));	/* Wrapper for realloc(3) */
 void *xcalloc _PARAMS((int, size_t));	/* Wrapper for calloc(3) */
 void xfree _PARAMS((void *));	/* Wrapper for free(3) */
 void xxfree _PARAMS((void *));	/* Wrapper for free(3) */
-char *xstrdup _PARAMS((char *));
-char *xstrerror _PARAMS((void));
-char *getfullhostname _PARAMS((void));
-void xmemcpy _PARAMS((void *, void*, int));
+char *xstrdup(char *);
+char *xstrerror(void);
+char *getfullhostname(void);
+void xmemcpy(void *, void *, int);
 
 #if XMALLOC_STATISTICS
-void malloc_statistics _PARAMS((void (*)(int, int, void *), void *));
+void malloc_statistics(void (*)(int, int, void *), void *);
 #endif
 
 /* from debug.c */
@@ -180,25 +180,25 @@ extern int Harvest_debug_levels[];
         {if (debug_ok_fast((section),(level))) {Log X;}}
 #endif
 
-void debug_flag _PARAMS((char *));
+void debug_flag(char *);
 
-char *mkhttpdlogtime _PARAMS((time_t *));
-extern char *mkrfc850 _PARAMS((time_t));
-extern time_t parse_rfc850 _PARAMS((char *str));
-extern void init_log3 _PARAMS((char *pn, FILE * a, FILE * b));
+char *mkhttpdlogtime(time_t *);
+extern char *mkrfc850(time_t);
+extern time_t parse_rfc850(char *str);
+extern void init_log3(char *pn, FILE * a, FILE * b);
 extern void debug_init();
-extern void log_errno2 _PARAMS((char *, int, char *));
+extern void log_errno2(char *, int, char *);
 
 #if defined(__STRICT_ANSI__)
-extern void Log _PARAMS((char *,...));
-extern void errorlog _PARAMS((char *,...));
+extern void Log(char *,...);
+extern void errorlog(char *,...);
 #else
 extern void Log();
 extern void errorlog();
 #endif /* __STRICT_ANSI__ */
 
-extern void Tolower _PARAMS((char *));
+extern void Tolower(char *);
 
-extern char *uudecode _PARAMS((char *));
+extern char *uudecode(char *);
 
 #endif /* ndef _UTIL_H_ */
@@ -11,7 +11,8 @@ static int base64_initialized = 0;
 int base64_value[256];
 char base64_code[] = "ABCDEFGHIJKLMNOPQRSTUVWZYZabcdefghijklmnopqrstuvwxyz0123456789+/";
 
-static void base64_init()
+static void
+base64_init()
 {
     int i;
 
@@ -25,8 +26,8 @@ static void base64_init()
     base64_initialized = 1;
 }
 
-char *base64_decode(p)
-     char *p;
+char *
+base64_decode(char *p)
 {
     static char result[8192];
     int c;
@@ -1,5 +1,6 @@
+
 /*
- * $Id: getfullhostname.c,v 1.5 1996/07/09 03:41:11 wessels Exp $
+ * $Id: getfullhostname.c,v 1.6 1996/09/14 08:50:47 wessels Exp $
  *
  * DEBUG: 
  * AUTHOR: Harvest Derived
@@ -27,7 +28,7 @@
  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *  
  */
- 
+
 
 /*
  * Copyright (c) 1994, 1995.  All rights reserved.
@@ -142,7 +143,8 @@
  *  host, or NULL on error.  Pointer is only valid until the next call
  *  to the gethost*() functions.
  */
-char *getfullhostname()
+char *
+getfullhostname()
 {
     struct hostent *hp = NULL;
     static char buf[SQUIDHOSTNAMELEN + 1];
@@ -1,5 +1,5 @@
 /*
- * $Id: rfc1738.c,v 1.3 1996/07/09 03:41:13 wessels Exp $
+ * $Id: rfc1738.c,v 1.4 1996/09/14 08:50:50 wessels Exp $
  *
  * DEBUG: 
  * AUTHOR: Harvest Derived
@@ -27,7 +27,7 @@
  *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *  
  */
- 
+
 /*
  * Copyright (c) 1994, 1995.  All rights reserved.
  *  
@@ -143,8 +143,8 @@ static char rfc1738_unsafe_chars[] =
  *  rfc1738_escape - Returns a static buffer contains the RFC 1738 
  *  compliant, escaped version of the given url.
  */
-char *rfc1738_escape(url)
-     char *url;
+char *
+rfc1738_escape(char *url)
 {
     static char buf[BIG_BUFSIZ];
     char *p, *q;
@@ -188,8 +188,8 @@ char *rfc1738_escape(url)
  *  rfc1738_unescape() - Converts escaped characters (%xy numbers) in 
  *  given the string.  %% is a %. %ab is the 8-bit hexadecimal number "ab"
  */
-void rfc1738_unescape(s)
-     char *s;
+void
+rfc1738_unescape(char *s)
 {
     char hexnum[3];
     int i, j;			/* i is write, j is read */
@@ -70,7 +70,9 @@ static const char letters[] =
 "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
 
 /* Return nonzero if DIR is an existent directory.  */
-static int diraccess (const char *dir) {
+static int
+diraccess(const char *dir)
+{
     struct stat buf;
     uid_t euid;
 
@@ -95,7 +97,9 @@ static int diraccess (const char *dir) {
 }
 
 /* Return nonzero if FILE exists.  */
-static int exists(const char *file) {
+static int
+exists(const char *file)
+{
     /* We can stat the file even if we can't read its data.  */
     struct stat st;
     int save = errno;
@@ -119,28 +123,30 @@ static int exists(const char *file) {
 
 
 /* Generate a temporary filename and return it (in a static buffer).  If
-  STREAMPTR is not NULL, open a stream "w+b" on the file and set
-  *STREAMPTR to it.  If DIR_SEARCH is nonzero, DIR and PFX are used as
-  described for tempnam.  If not, a temporary filename in P_tmpdir with
-  no special prefix is generated.  If LENPTR is not NULL, *LENPTR is
-  set the to length (including the terminating '\0') of the resultant
-  filename, which is returned.  This goes through a cyclic pattern of
-  all possible filenames consisting of five decimal digits of the
-  current pid and three of the characters in `letters'.  Data for
-  tempnam and tmpnam is kept separate, but when tempnam is using
-  P_tmpdir and no prefix (i.e, it is identical to tmpnam), the same
-  data is used.  Each potential filename is tested for an
-  already-existing file of the same name, and no name of an existing
-  file will be returned.  When the cycle reaches its end (12345ZZZ),
-  NULL is returned. */
-
-static char *gen_tempname (
+ * STREAMPTR is not NULL, open a stream "w+b" on the file and set
+ * *STREAMPTR to it.  If DIR_SEARCH is nonzero, DIR and PFX are used as
+ * described for tempnam.  If not, a temporary filename in P_tmpdir with
+ * no special prefix is generated.  If LENPTR is not NULL, *LENPTR is
+ * set the to length (including the terminating '\0') of the resultant
+ * filename, which is returned.  This goes through a cyclic pattern of
+ * all possible filenames consisting of five decimal digits of the
+ * current pid and three of the characters in `letters'.  Data for
+ * tempnam and tmpnam is kept separate, but when tempnam is using
+ * P_tmpdir and no prefix (i.e, it is identical to tmpnam), the same
+ * data is used.  Each potential filename is tested for an
+ * already-existing file of the same name, and no name of an existing
+ * file will be returned.  When the cycle reaches its end (12345ZZZ),
+ * NULL is returned. */
+
+static char *
+gen_tempname(
     const char *dir,
     const char *pfx,
     int dir_search,
     size_t * lenptr,
     FILE ** streamptr
-) {
+)
+{
     int saverrno = errno;
     static const char tmpdir[] = P_tmpdir;
     static struct {
@@ -240,7 +246,9 @@ static char *gen_tempname (
     return buf;
 }
 
-char *tempnam(const char *dir, const char *pfx) {
+char *
+tempnam(const char *dir, const char *pfx)
+{
     size_t len;
     register char *s;
     register char *t = gen_tempname(dir, pfx, 1, &len, (FILE **)
@@ -1,5 +1,5 @@
 /*
- * $Id: util.c,v 1.11 1996/07/22 16:40:58 wessels Exp $
+ * $Id: util.c,v 1.12 1996/09/14 08:50:52 wessels Exp $
  *
  * DEBUG: 
  * AUTHOR: Harvest Derived
@@ -145,25 +145,25 @@ extern char *sys_errlist[];
 static int malloc_sizes[DBG_MAXINDEX + 1];
 static int dbg_stat_init = 0;
 
-static void stat_init()
+static void
+stat_init()
 {
     int i;
     for (i = 0; i <= DBG_MAXINDEX; i++)
 	malloc_sizes[i] = 0;
     dbg_stat_init = 1;
 }
 
-static int malloc_stat(sz)
-     int sz;
+static int
+malloc_stat(int sz)
 {
     if (!dbg_stat_init)
 	stat_init();
     return malloc_sizes[DBG_INDEX(sz)] += 1;
 }
 
-void malloc_statistics(func, data)
-     void (*func) _PARAMS((int, int, void *));
-     void *data;
+void
+malloc_statistics(void (*func) _PARAMS((int, int, void *)), void *data)
 {
     int i;
     for (i = 0; i <= DBG_MAXSIZE; i += DBG_GRAIN)
@@ -184,7 +184,8 @@ static int I = 0;
 static void *P;
 static void *Q;
 
-static void check_init()
+static void
+check_init()
 {
     for (B = 0; B < DBG_ARRY_BKTS; B++) {
 	for (I = 0; I < DBG_ARRY_SZ; I++) {
@@ -195,8 +196,8 @@ static void check_init()
     dbg_initd = 1;
 }
 
-static void check_free(s)
-     void *s;
+static void
+check_free(void *s)
 {
     B = (((int) s) >> 4) & 0xFF;
     for (I = 0; I < DBG_ARRY_SZ; I++) {
@@ -212,9 +213,8 @@ static void check_free(s)
     }
 }
 
-static void check_malloc(p, sz)
-     void *p;
-     size_t sz;
+static void
+check_malloc(void *p, size_t sz)
 {
     if (!dbg_initd)
 	check_init();
@@ -242,8 +242,8 @@ static void check_malloc(p, sz)
 #endif
 
 #if XMALLOC_COUNT && !HAVE_MALLOCBLKSIZE
-int mallocblksize(p)
-     void *p;
+int
+mallocblksize(void *p)
 {
     B = (((int) p) >> 4) & 0xFF;
     for (I = 0; I < DBG_ARRY_SZ; I++) {
@@ -255,9 +255,8 @@ int mallocblksize(p)
 #endif
 
 #ifdef XMALLOC_COUNT
-static void xmalloc_count(p, sign)
-     void *p;
-     int sign;
+static void
+xmalloc_count(void *p, int sign)
 {
     size_t sz;
     static size_t total = 0;
@@ -270,14 +269,15 @@ static void xmalloc_count(p, sign)
 	memoryAccounted(),
 	mallinfoTotal());
 }
+
 #endif /* XMALLOC_COUNT */
 
 /*
  *  xmalloc() - same as malloc(3).  Used for portability.
  *  Never returns NULL; fatal on error.
  */
-void *xmalloc(sz)
-     size_t sz;
+void *
+xmalloc(size_t sz)
 {
     static void *p;
 
@@ -308,8 +308,8 @@ void *xmalloc(sz)
 /*
  *  xfree() - same as free(3).  Will not call free(3) if s == NULL.
  */
-void xfree(s)
-     void *s;
+void
+xfree(void *s)
 {
 #if XMALLOC_COUNT
     xmalloc_count(s, -1);
@@ -322,8 +322,8 @@ void xfree(s)
 }
 
 /* xxfree() - like xfree(), but we already know s != NULL */
-void xxfree(s)
-     void *s;
+void
+xxfree(void *s)
 {
 #if XMALLOC_COUNT
     xmalloc_count(s, -1);
@@ -338,9 +338,8 @@ void xxfree(s)
  *  xrealloc() - same as realloc(3). Used for portability.
  *  Never returns NULL; fatal on error.
  */
-void *xrealloc(s, sz)
-     void *s;
-     size_t sz;
+void *
+xrealloc(void *s, size_t sz)
 {
     static void *p;
 
@@ -376,9 +375,8 @@ void *xrealloc(s, sz)
  *  xcalloc() - same as calloc(3).  Used for portability.
  *  Never returns NULL; fatal on error.
  */
-void *xcalloc(n, sz)
-     int n;
-     size_t sz;
+void *
+xcalloc(int n, size_t sz)
 {
     static void *p;
 
@@ -412,8 +410,8 @@ void *xcalloc(n, sz)
  *  xstrdup() - same as strdup(3).  Used for portability.
  *  Never returns NULL; fatal on error.
  */
-char *xstrdup(s)
-     char *s;
+char *
+xstrdup(char *s)
 {
     static char *p = NULL;
     size_t sz;
@@ -436,7 +434,8 @@ char *xstrdup(s)
 /*
  * xstrerror() - return sys_errlist[errno];
  */
-char *xstrerror()
+char *
+xstrerror()
 {
     static char xstrerror_buf[BUFSIZ];
 
@@ -449,17 +448,15 @@ char *xstrerror()
 
 #if !HAVE_STRDUP
 /* define for systems that don't have strdup */
-char *strdup(s)
-     char *s;
+char *
+strdup(char *s)
 {
     return (xstrdup(s));
 }
 #endif
 
-void xmemcpy(from, to, len)
-     void *from;
-     void *to;
-     int len;
+void
+xmemcpy(void *from, void *to, int len)
 {
 #if HAVE_MEMMOVE
     (void) memmove(from, to, len);
@@ -470,12 +467,12 @@ void xmemcpy(from, to, len)
 #endif
 }
 
-void Tolower(q)
-     char *q;
+void
+Tolower(char *q)
 {
     char *s = q;
     while (*s) {
-        *s = tolower((unsigned char) *s);
-        s++;
+	*s = tolower((unsigned char) *s);
+	s++;
     }
 }
@@ -1,64 +1,69 @@
+
 #include "util.h"
 
-extern char** environ;
+extern char **environ;
 
 /* aaaack but it's fast and const should make it shared text page. */
-const int pr2six[256]={
-    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
-    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
-    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
-    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
-    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
-    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
-    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
-    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
-    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
-    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
-    64,64,64,64,64,64,64,64,64,64,64,64,64
+const int pr2six[256] =
+{
+    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
+    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 64, 64, 63,
+    52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64, 64, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
+    10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 64, 64, 26, 27,
+    28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
+    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
+    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
+    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
+    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
+    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
+    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64
 };
 
-char *uudecode(char *bufcoded) {
+char *
+uudecode(char *bufcoded)
+{
     int nbytesdecoded;
     register unsigned char *bufin;
     register char *bufplain;
     register unsigned char *bufout;
     register int nprbytes;
-    
+
     /* Strip leading whitespace. */
-    
-    while(*bufcoded==' ' || *bufcoded == '\t') bufcoded++;
-    
+
+    while (*bufcoded == ' ' || *bufcoded == '\t')
+	bufcoded++;
+
     /* Figure out how many characters are in the input buffer.
      * Allocate this many from the per-transaction pool for the result.
      */
-    bufin = (unsigned char *)bufcoded;
-    while(pr2six[*(bufin++)] <= 63);
-    nprbytes = (char *)bufin - bufcoded - 1;
-    nbytesdecoded = ((nprbytes+3)/4) * 3;
+    bufin = (unsigned char *) bufcoded;
+    while (pr2six[*(bufin++)] <= 63);
+    nprbytes = (char *) bufin - bufcoded - 1;
+    nbytesdecoded = ((nprbytes + 3) / 4) * 3;
 
     bufplain = xmalloc(nbytesdecoded + 1);
     if (bufplain == NULL)
-      return(NULL);
-    bufout = (unsigned char *)bufplain;
-    
-    bufin = (unsigned char *)bufcoded;
-    
+	return (NULL);
+    bufout = (unsigned char *) bufplain;
+
+    bufin = (unsigned char *) bufcoded;
+
     while (nprbytes > 0) {
-        *(bufout++) = 
-            (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);
-        *(bufout++) = 
-            (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);
-        *(bufout++) = 
-            (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);
-        bufin += 4;
-        nprbytes -= 4;
+	*(bufout++) =
+	    (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);
+	*(bufout++) =
+	    (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);
+	*(bufout++) =
+	    (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);
+	bufin += 4;
+	nprbytes -= 4;
     }
-    
-    if(nprbytes & 03) {
-        if(pr2six[bufin[-2]] > 63)
-            nbytesdecoded -= 2;
-        else
-            nbytesdecoded -= 1;
+
+    if (nprbytes & 03) {
+	if (pr2six[bufin[-2]] > 63)
+	    nbytesdecoded -= 2;
+	else
+	    nbytesdecoded -= 1;
     }
     bufplain[nbytesdecoded] = '\0';
     return bufplain;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client.cc,v 1.8 1996/09/04 22:03:19 wessels Exp $
+ * $Id: client.cc,v 1.9 1996/09/14 08:45:41 wessels Exp $
  *
  * DEBUG: section 0     WWW Client
  * AUTHOR: Harvest Derived
@@ -111,11 +111,11 @@
 #endif
 
 /* Local functions */
-static int client_comm_connect();
-static void usage();
+static int client_comm_connect(int sock, char *dest_host, u_short dest_port);
+static void usage(char *progname);
 
-static void usage(progname)
-     char *progname;
+static void
+usage(char *progname)
 {
     fprintf(stderr, "\
 Usage: %s [-rs] [-i IMS_time] [-h host] [-p port] [-m method] url\n\
@@ -130,9 +130,8 @@ Options:\n\
     exit(1);
 }
 
-int main(argc, argv)
-     int argc;
-     char *argv[];
+int
+main(int argc, char *argv[])
 {
     int conn, c, len, bytesWritten;
     int port, to_stdout, reload;
@@ -235,10 +234,8 @@ int main(argc, argv)
     return 0;
 }
 
-static int client_comm_connect(sock, dest_host, dest_port)
-     int sock;			/* Type of communication to use. */
-     char *dest_host;		/* Server's host name. */
-     u_short dest_port;		/* Server's port. */
+static int
+client_comm_connect(int sock, char *dest_host, u_short dest_port)
 {
     struct hostent *hp;
     static struct sockaddr_in to_addr;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side.cc,v 1.22 1996/09/12 03:24:01 wessels Exp $
+ * $Id: client_side.cc,v 1.23 1996/09/14 08:45:41 wessels Exp $
  *
  * DEBUG: section 33    Client-side Routines
  * AUTHOR: Duane Wessels
@@ -31,14 +31,12 @@
 
 #include "squid.h"
 
-static void clientRedirectDone _PARAMS((void *data, char *result));
-static int icpHandleIMSReply _PARAMS((int fd, StoreEntry * entry, void *data));
+static void clientRedirectDone(void *data, char *result);
+static int icpHandleIMSReply(int fd, StoreEntry * entry, void *data);
 
 
-static int clientLookupDstIPDone(fd, hp, data)
-     int fd;
-     struct hostent *hp;
-     void *data;
+static int
+clientLookupDstIPDone(int fd, struct hostent *hp, void *data)
 {
     icpStateData *icpState = data;
     debug(33, 5, "clientLookupDstIPDone: FD %d, '%s'\n",
@@ -57,10 +55,8 @@ static int clientLookupDstIPDone(fd, hp, data)
     return 1;
 }
 
-static void clientLookupSrcFQDNDone(fd, fqdn, data)
-     int fd;
-     char *fqdn;
-     void *data;
+static void
+clientLookupSrcFQDNDone(int fd, char *fqdn, void *data)
 {
     icpStateData *icpState = data;
     debug(33, 5, "clientLookupSrcFQDNDone: FD %d, '%s', FQDN %s\n",
@@ -72,17 +68,17 @@ static void clientLookupSrcFQDNDone(fd, fqdn, data)
 }
 
 #ifdef UNUSED_CODE
-static void clientLookupIdentDone(data)
-     void *data;
+static void
+clientLookupIdentDone(void *data)
 {
 }
 
 #endif
 
 #if USE_PROXY_AUTH
 /* return 1 if allowed, 0 if denied */
-static int clientProxyAuthCheck(icpState)
-     icpStateData *icpState;
+static int
+clientProxyAuthCheck(icpStateData * icpState)
 {
     char *proxy_user;
 
@@ -106,9 +102,8 @@ static int clientProxyAuthCheck(icpState)
 }
 #endif /* USE_PROXY_AUTH */
 
-void clientAccessCheck(icpState, handler)
-     icpStateData *icpState;
-     void (*handler) _PARAMS((icpStateData *, int));
+void
+clientAccessCheck(icpStateData * icpState, void (*handler) _PARAMS((icpStateData *, int)))
 {
     int answer = 1;
     request_t *r = icpState->request;
@@ -166,9 +161,8 @@ void clientAccessCheck(icpState, handler)
     handler(icpState, answer);
 }
 
-void clientAccessCheckDone(icpState, answer)
-     icpStateData *icpState;
-     int answer;
+void
+clientAccessCheckDone(icpStateData * icpState, int answer)
 {
     int fd = icpState->fd;
     char *buf = NULL;
@@ -198,9 +192,8 @@ void clientAccessCheckDone(icpState, answer)
     }
 }
 
-static void clientRedirectDone(data, result)
-     void *data;
-     char *result;
+static void
+clientRedirectDone(void *data, char *result)
 {
     icpStateData *icpState = data;
     int fd = icpState->fd;
@@ -231,7 +224,8 @@ static void clientRedirectDone(data, result)
  */
 #define CHECK_PROXY_FILE_TIME 300
 
-char *proxyAuthenticate(char *headers)
+char *
+proxyAuthenticate()
 {
     /* Keep the time measurements and the hash
      * table of users and passwords handy */
@@ -363,9 +357,8 @@ char *proxyAuthenticate(char *headers)
 #endif /* USE_PROXY_AUTH */
 }
 
-int icpProcessExpired(fd, icpState)
-     int fd;
-     icpStateData *icpState;
+int
+icpProcessExpired(int fd, icpStateData * icpState)
 {
     char *url = icpState->url;
     char *request_hdr = icpState->request_hdr;
@@ -394,10 +387,8 @@ int icpProcessExpired(fd, icpState)
 }
 
 
-static int icpHandleIMSReply(fd, entry, data)
-     int fd;
-     StoreEntry *entry;
-     void *data;
+static int
+icpHandleIMSReply(int fd, StoreEntry * entry, void *data)
 {
     icpStateData *icpState = data;
     MemObject *mem = entry->mem_obj;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: comm.cc,v 1.66 1996/09/12 22:17:58 wessels Exp $
+ * $Id: comm.cc,v 1.67 1996/09/14 08:45:43 wessels Exp $
  *
  * DEBUG: section 5     Socket Functions
  * AUTHOR: Harvest Derived
@@ -137,26 +137,25 @@ struct _RWStateData {
 FD_ENTRY *fd_table = NULL;	/* also used in disk.c */
 
 /* STATIC */
-static void checkTimeouts _PARAMS((void));
-static void checkLifetimes _PARAMS((void));
-static void Reserve_More_FDs _PARAMS((void));
-static void commSetReuseAddr _PARAMS((int));
-static int examine_select _PARAMS((fd_set *, fd_set *, fd_set *));
-static void commSetNoLinger _PARAMS((int));
-static void comm_select_incoming _PARAMS((void));
-static int commBind _PARAMS((int s, struct in_addr, u_short port));
-static void RWStateCallbackAndFree _PARAMS((int fd, int code));
+static void checkTimeouts(void);
+static void checkLifetimes(void);
+static void Reserve_More_FDs(void);
+static void commSetReuseAddr(int);
+static int examine_select(fd_set *, fd_set *, fd_set *);
+static void commSetNoLinger(int);
+static void comm_select_incoming(void);
+static int commBind(int s, struct in_addr, u_short port);
+static void RWStateCallbackAndFree(int fd, int code);
 #ifdef TCP_NODELAY
-static void commSetTcpNoDelay _PARAMS((int));
+static void commSetTcpNoDelay(int);
 #endif
-static void commSetTcpRcvbuf _PARAMS((int, int));
+static void commSetTcpRcvbuf(int, int);
 
 static int *fd_lifetime = NULL;
 static struct timeval zero_tv;
 
-static void RWStateCallbackAndFree(fd, code)
-     int fd;
-     int code;
+static void
+RWStateCallbackAndFree(int fd, int code)
 {
     RWStateData *RWState = fd_table[fd].rwstate;
     rw_complete_handler *callback = NULL;
@@ -180,8 +179,8 @@ static void RWStateCallbackAndFree(fd, code)
 }
 
 /* Return the local port associated with fd. */
-u_short comm_local_port(fd)
-     int fd;
+u_short
+comm_local_port(int fd)
 {
     struct sockaddr_in addr;
     int addr_len = 0;
@@ -204,14 +203,8 @@ u_short comm_local_port(fd)
     return fde->local_port;
 }
 
-#ifdef __STDC__
-static int commBind(int s, struct in_addr in_addr, u_short port)
-#else /* K&R C */
-static int commBind(s, in_addr, port)
-     int s;
-     struct in_addr in_addr;
-     u_short port;
-#endif
+static int
+commBind(int s, struct in_addr in_addr, u_short port)
 {
     struct sockaddr_in S;
 
@@ -230,15 +223,8 @@ static int commBind(s, in_addr, port)
 
 /* Create a socket. Default is blocking, stream (TCP) socket.  IO_TYPE
  * is OR of flags specified in comm.h. */
-#ifdef __STDC__
-int comm_open(unsigned int io_type, struct in_addr addr, u_short port, char *note)
-#else /* K&R C */
-int comm_open(io_type, addr, port, note)
-     unsigned int io_type;
-     struct in_addr addr;
-     u_short port;
-     char *note;
-#endif
+int
+comm_open(unsigned int io_type, struct in_addr addr, u_short port, char *note)
 {
     int new_socket;
     FD_ENTRY *conn = NULL;
@@ -302,8 +288,8 @@ int comm_open(io_type, addr, port, note)
     * to 5.  HP-UX currently has a limit of 20.  SunOS is 5 and
     * OSF 3.0 is 8.
     */
-int comm_listen(sock)
-     int sock;
+int
+comm_listen(int sock)
 {
     int x;
     if ((x = listen(sock, FD_SETSIZE >> 2)) < 0) {
@@ -316,10 +302,8 @@ int comm_listen(sock)
 }
 
 /* Connect SOCK to specified DEST_PORT at DEST_HOST. */
-int comm_connect(sock, dest_host, dest_port)
-     int sock;			/* Type of communication to use. */
-     char *dest_host;		/* Server's host name. */
-     u_short dest_port;		/* Server's port. */
+int 
+comm_connect(int sock, char *dest_host, u_short dest_port)
 {
     struct hostent *hp = NULL;
     static struct sockaddr_in to_addr;
@@ -338,9 +322,8 @@ int comm_connect(sock, dest_host, dest_port)
     return comm_connect_addr(sock, &to_addr);
 }
 
-int comm_set_fd_lifetime(fd, lifetime)
-     int fd;
-     int lifetime;
+int
+comm_set_fd_lifetime(int fd, int lifetime)
 {
     debug(5, 3, "comm_set_fd_lifetime: FD %d lft %d\n", fd, lifetime);
     if (fd < 0 || fd > FD_SETSIZE)
@@ -355,25 +338,24 @@ int comm_set_fd_lifetime(fd, lifetime)
     return fd_lifetime[fd] = (int) squid_curtime + lifetime;
 }
 
-int comm_get_fd_lifetime(fd)
-     int fd;
+int
+comm_get_fd_lifetime(int fd)
 {
     if (fd < 0)
 	return 0;
     return fd_lifetime[fd];
 }
 
-int comm_get_fd_timeout(fd)
-     int fd;
+int
+comm_get_fd_timeout(int fd)
 {
     if (fd < 0)
 	return 0;
     return fd_table[fd].timeout_time;
 }
 
-int comm_connect_addr(sock, address)
-     int sock;
-     struct sockaddr_in *address;
+int
+comm_connect_addr(int sock, struct sockaddr_in *address)
 {
     int status = COMM_OK;
     FD_ENTRY *conn = &fd_table[sock];
@@ -434,10 +416,8 @@ int comm_connect_addr(sock, address)
 
 /* Wait for an incoming connection on FD.  FD should be a socket returned
  * from comm_listen. */
-int comm_accept(fd, peer, me)
-     int fd;
-     struct sockaddr_in *peer;
-     struct sockaddr_in *me;
+int
+comm_accept(int fd, struct sockaddr_in *peer, struct sockaddr_in *me)
 {
     int sock;
     struct sockaddr_in P;
@@ -490,8 +470,8 @@ int comm_accept(fd, peer, me)
     return sock;
 }
 
-void comm_close(fd)
-     int fd;
+void
+comm_close(int fd)
 {
     FD_ENTRY *conn = NULL;
     struct close_handler *ch = NULL;
@@ -520,8 +500,8 @@ void comm_close(fd)
 
 /* use to clean up fdtable when socket is closed without
  * using comm_close */
-int comm_cleanup_fd_entry(fd)
-     int fd;
+int
+comm_cleanup_fd_entry(int fd)
 {
     FD_ENTRY *conn = &fd_table[fd];
     RWStateCallbackAndFree(fd, COMM_ERROR);
@@ -531,16 +511,8 @@ int comm_cleanup_fd_entry(fd)
 
 
 /* Send a udp datagram to specified PORT at HOST. */
-#ifdef __STDC__
-int comm_udp_send(int fd, char *host, u_short port, char *buf, int len)
-#else /* K&R C */
-int comm_udp_send(fd, host, port, buf, len)
-     int fd;
-     char *host;
-     u_short port;
-     char *buf;
-     int len;
-#endif
+int
+comm_udp_send(int fd, char *host, u_short port, char *buf, int len)
 {
     struct hostent *hp = NULL;
     static struct sockaddr_in to_addr;
@@ -566,12 +538,8 @@ int comm_udp_send(fd, host, port, buf, len)
 }
 
 /* Send a udp datagram to specified TO_ADDR. */
-int comm_udp_sendto(fd, to_addr, addr_len, buf, len)
-     int fd;
-     struct sockaddr_in *to_addr;
-     int addr_len;
-     char *buf;
-     int len;
+int
+comm_udp_sendto(int fd, struct sockaddr_in *to_addr, int addr_len, char *buf, int len)
 {
     int bytes_sent;
 
@@ -586,12 +554,8 @@ int comm_udp_sendto(fd, to_addr, addr_len, buf, len)
     return bytes_sent;
 }
 
-int comm_udp_recv(fd, buf, size, from_addr, from_size)
-     int fd;
-     char *buf;
-     int size;
-     struct sockaddr_in *from_addr;
-     int *from_size;		/* in: size of from_addr; out: size filled in. */
+int
+comm_udp_recv(int fd, char *buf, int size, struct sockaddr_in *from_addr, int *from_size)
 {
     int len = recvfrom(fd, buf, size, 0, (struct sockaddr *) from_addr,
 	from_size);
@@ -603,16 +567,16 @@ int comm_udp_recv(fd, buf, size, from_addr, from_size)
     return len;
 }
 
-void comm_set_stall(fd, delta)
-     int fd;
-     int delta;
+void
+comm_set_stall(int fd, int delta)
 {
     if (fd < 0)
 	return;
     fd_table[fd].stall_until = squid_curtime + delta;
 }
 
-static void comm_select_incoming()
+static void
+comm_select_incoming()
 {
     fd_set read_mask;
     fd_set write_mask;
@@ -667,8 +631,8 @@ static void comm_select_incoming()
 
 
 /* Select on all sockets; call handlers for those that are ready. */
-int comm_select(sec)
-     time_t sec;
+int
+comm_select(time_t sec)
 {
     fd_set exceptfds;
     fd_set readfds;
@@ -832,21 +796,14 @@ int comm_select(sec)
     return COMM_TIMEOUT;
 }
 
-void comm_set_select_handler(fd, type, handler, client_data)
-     int fd;
-     unsigned int type;
-     PF handler;
-     void *client_data;
+void
+comm_set_select_handler(int fd, unsigned int type, PF handler, void *client_data)
 {
     comm_set_select_handler_plus_timeout(fd, type, handler, client_data, 0);
 }
 
-void comm_set_select_handler_plus_timeout(fd, type, handler, client_data, timeout)
-     int fd;
-     unsigned int type;
-     PF handler;
-     void *client_data;
-     time_t timeout;
+void
+comm_set_select_handler_plus_timeout(int fd, unsigned int type, PF handler, void *client_data, time_t timeout)
 {
     if (type & COMM_SELECT_TIMEOUT) {
 	fd_table[fd].timeout_time = (getCurrentTime() + timeout);
@@ -875,11 +832,8 @@ void comm_set_select_handler_plus_timeout(fd, type, handler, client_data, timeou
     }
 }
 
-int comm_get_select_handler(fd, type, handler_ptr, client_data_ptr)
-     int fd;
-     unsigned int type;
-     int (**handler_ptr) ();
-     void **client_data_ptr;
+int
+comm_get_select_handler(int fd, unsigned int type, int (**handler_ptr) (), void **client_data_ptr)
 {
     if (type & COMM_SELECT_TIMEOUT) {
 	*handler_ptr = fd_table[fd].timeout_handler;
@@ -904,10 +858,8 @@ int comm_get_select_handler(fd, type, handler_ptr, client_data_ptr)
     return 0;			/* XXX What is meaningful? */
 }
 
-void comm_add_close_handler(fd, handler, data)
-     int fd;
-     PF handler;
-     void *data;
+void
+comm_add_close_handler(int fd, PF handler, void *data)
 {
     struct close_handler *new = xmalloc(sizeof(*new));
 
@@ -919,10 +871,8 @@ void comm_add_close_handler(fd, handler, data)
     fd_table[fd].close_handler = new;
 }
 
-void comm_remove_close_handler(fd, handler, data)
-     int fd;
-     PF handler;
-     void *data;
+void
+comm_remove_close_handler(int fd, PF handler, void *data)
 {
     struct close_handler *p, *last = NULL;
 
@@ -941,8 +891,8 @@ void comm_remove_close_handler(fd, handler, data)
     safe_free(p);
 }
 
-static void commSetNoLinger(fd)
-     int fd;
+static void
+commSetNoLinger(int fd)
 {
     struct linger L;
     L.l_onoff = 0;		/* off */
@@ -952,8 +902,8 @@ static void commSetNoLinger(fd)
 	debug(5, 0, "commSetNoLinger: FD %d: %s\n", fd, xstrerror());
 }
 
-static void commSetReuseAddr(fd)
-     int fd;
+static void
+commSetReuseAddr(int fd)
 {
     int on = 1;
     debug(5, 10, "commSetReuseAddr: turning on SO_REUSEADDR on FD %d\n", fd);
@@ -962,26 +912,25 @@ static void commSetReuseAddr(fd)
 }
 
 #ifdef TCP_NODELAY
-static void commSetTcpNoDelay(fd)
-     int fd;
+static void
+commSetTcpNoDelay(int fd)
 {
     int on = 1;
     if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (char *) &on, sizeof(on)) < 0)
 	debug(5, 1, "commSetTcpNoDelay: FD %d: %s\n", fd, xstrerror());
 }
 #endif
 
-static void commSetTcpRcvbuf(fd, size)
-     int fd;
-     int size;
+static void
+commSetTcpRcvbuf(int fd, int size)
 {
     if (setsockopt(fd, SOL_SOCKET, SO_RCVBUF, (char *) &size, sizeof(size)) < 0)
 	debug(5, 1, "commSetTcpRcvbuf: FD %d, SIZE %d: %s\n",
 	    fd, size, xstrerror());
 }
 
-int commSetNonBlocking(fd)
-     int fd;
+int
+commSetNonBlocking(int fd)
 {
 #if defined(O_NONBLOCK) && !defined(_SQUID_SUNOS_) && !defined(_SQUID_SOLARIS_)
     if (fcntl(fd, F_SETFL, O_NONBLOCK)) {
@@ -999,8 +948,8 @@ int commSetNonBlocking(fd)
     return 0;
 }
 
-void commSetCloseOnExec(fd)
-     int fd;
+void
+commSetCloseOnExec(int fd)
 {
 #ifdef FD_CLOEXEC
     if (fcntl(fd, F_SETFD, FD_CLOEXEC) < 0) {
@@ -1010,8 +959,8 @@ void commSetCloseOnExec(fd)
 #endif
 }
 
-char **getAddressList(name)
-     char *name;
+char **
+getAddressList(char *name)
 {
     struct hostent *hp = NULL;
     if (name == NULL)
@@ -1023,8 +972,8 @@ char **getAddressList(name)
     return NULL;
 }
 
-struct in_addr *getAddress(name)
-     char *name;
+struct in_addr *
+getAddress(char *name)
 {
     static struct in_addr first;
     char **list = NULL;
@@ -1046,7 +995,8 @@ struct in_addr *getAddress(name)
  *  we can find a better solution, we give all asciiPort or
  *  squid initiated clients a maximum lifetime.
  */
-int comm_init()
+int
+comm_init()
 {
     int i;
 
@@ -1079,8 +1029,8 @@ int comm_init()
  * 
  * Call this from where the select loop fails.
  */
-static int examine_select(readfds, writefds, exceptfds)
-     fd_set *readfds, *writefds, *exceptfds;
+static int
+examine_select(fd_set * readfds, fd_set * writefds, fd_set * exceptfds)
 {
     int fd = 0;
     fd_set read_x;
@@ -1149,17 +1099,17 @@ static int examine_select(readfds, writefds, exceptfds)
     return 0;
 }
 
-char *fd_note(fd, s)
-     int fd;
-     char *s;
+char *
+fd_note(int fd, char *s)
 {
     if (s == NULL)
 	return (fd_table[fd].ascii_note);
     strncpy(fd_table[fd].ascii_note, s, FD_ASCII_NOTE_SZ - 1);
     return (NULL);
 }
 
-static void checkTimeouts()
+static void
+checkTimeouts()
 {
     int fd;
     int (*hdl) () = NULL;
@@ -1180,7 +1130,8 @@ static void checkTimeouts()
     }
 }
 
-static void checkLifetimes()
+static void
+checkLifetimes()
 {
     int fd;
     time_t lft;
@@ -1228,7 +1179,8 @@ static void checkLifetimes()
 /*
  * Reserve_More_FDs() called when acceopt(), open(), or socket is failing
  */
-static void Reserve_More_FDs()
+static void
+Reserve_More_FDs()
 {
     if (RESERVED_FD < FD_SETSIZE - 64) {
 	RESERVED_FD = RESERVED_FD + 1;
@@ -1240,9 +1192,8 @@ static void Reserve_More_FDs()
 }
 
 /* Read from FD. */
-static int commHandleRead(fd, state)
-     int fd;
-     RWStateData *state;
+static int
+commHandleRead(int fd, RWStateData * state)
 {
     int len;
 
@@ -1285,14 +1236,14 @@ static int commHandleRead(fd, state)
 
 /* Select for reading on FD, until SIZE bytes are received.  Call
  * HANDLER when complete. */
-void comm_read(fd, buf, size, timeout, immed, handler, handler_data)
-     int fd;
-     char *buf;
-     int size;
-     int timeout;
-     int immed;			/* Call handler immediately when data available */
-     rw_complete_handler *handler;
-     void *handler_data;
+void
+comm_read(int fd,
+    char *buf,
+    int size,
+    int timeout,
+    int immed,
+    rw_complete_handler * handler,
+    void *handler_data)
 {
     RWStateData *state = NULL;
 
@@ -1321,9 +1272,8 @@ void comm_read(fd, buf, size, timeout, immed, handler, handler_data)
 }
 
 /* Write to FD. */
-static void commHandleWrite(fd, state)
-     int fd;
-     RWStateData *state;
+static void
+commHandleWrite(int fd, RWStateData * state)
 {
     int len = 0;
     int nleft;
@@ -1373,14 +1323,8 @@ static void commHandleWrite(fd, state)
 
 /* Select for Writing on FD, until SIZE bytes are sent.  Call
  * * HANDLER when complete. */
-void comm_write(fd, buf, size, timeout, handler, handler_data, free)
-     int fd;
-     char *buf;
-     int size;
-     int timeout;
-     rw_complete_handler *handler;
-     void *handler_data;
-     void (*free) (void *);
+void
+comm_write(int fd, char *buf, int size, int timeout, rw_complete_handler * handler, void *handler_data, void (*free) (void *))
 {
     RWStateData *state = NULL;
 
@@ -1,5 +1,5 @@
 /*
- * $Id: debug.cc,v 1.22 1996/09/11 22:39:24 wessels Exp $
+ * $Id: debug.cc,v 1.23 1996/09/14 08:45:45 wessels Exp $
  *
  * DEBUG: section 0     Debug Routines
  * AUTHOR: Harvest Derived
@@ -115,11 +115,13 @@ static char *debug_log_file = NULL;
 static int debugLevels[MAX_DEBUG_SECTIONS];
 
 #if defined(__STRICT_ANSI__)
-void _db_print(int section, int level, char *format,...)
+void
+_db_print(int section, int level, char *format,...)
 {
     va_list args;
 #else
-void _db_print(va_alist)
+void
+_db_print(va_alist)
      va_dcl
 {
     va_list args;
@@ -174,8 +176,8 @@ void _db_print(va_alist)
     va_end(args);
 }
 
-static void debugArg(arg)
-     char *arg;
+static void
+debugArg(char *arg)
 {
     int s = 0;
     int l = 0;
@@ -198,8 +200,8 @@ static void debugArg(arg)
 	debugLevels[i] = l;
 }
 
-static void debugOpenLog(logfile)
-     char *logfile;
+static void
+debugOpenLog(char *logfile)
 {
     if (logfile == NULL) {
 	debug_log = stderr;
@@ -220,9 +222,8 @@ static void debugOpenLog(logfile)
     }
 }
 
-void _db_init(logfile, options)
-     char *logfile;
-     char *options;
+void
+_db_init(char *logfile, char *options)
 {
     int i;
     char *p = NULL;
@@ -246,7 +247,8 @@ void _db_init(logfile, options)
 
 }
 
-void _db_rotate_log()
+void
+_db_rotate_log()
 {
     int i;
     LOCAL_ARRAY(char, from, MAXPATHLEN);
@@ -1,5 +1,5 @@
 /*
- * $Id: disk.cc,v 1.22 1996/08/30 22:36:28 wessels Exp $
+ * $Id: disk.cc,v 1.23 1996/09/14 08:45:47 wessels Exp $
  *
  * DEBUG: section 6     Disk I/O Routines
  * AUTHOR: Harvest Derived
@@ -112,17 +112,18 @@ typedef struct _dwalk_ctrl {
     off_t offset;
     char *buf;			/* line buffer */
     int cur_len;		/* line len */
-    int (*handler) _PARAMS((int fd, int errflag, void *data));
+    int (*handler) (int fd, int errflag, void *data);
     void *client_data;
-    int (*line_handler) _PARAMS((int fd, char *buf, int size, void *line_data));
+    int (*line_handler) (int fd, char *buf, int size, void *line_data);
     void *line_data;
 } dwalk_ctrl;
 
 /* table for FILE variable, write lock and queue. Indexed by fd. */
 FileEntry *file_table;
 
 /* initialize table */
-int disk_init()
+int
+disk_init()
 {
     int fd;
 
@@ -143,10 +144,8 @@ int disk_init()
 }
 
 /* Open a disk file. Return a file descriptor */
-int file_open(path, handler, mode)
-     char *path;		/* path to file */
-     int (*handler) ();		/* Interrupt handler. */
-     int mode;
+int 
+file_open(char *path, int (*handler) (), int mode)
 {
     FD_ENTRY *conn;
     int fd;
@@ -187,10 +186,8 @@ int file_open(path, handler, mode)
 }
 
 #ifdef UNUSED_CODE
-int file_update_open(fd, path)
-     int fd;
-     char *path;		/* path to file */
-{
+int file_update_open(int fd, char *path;	/* path to file */
+) {
     FD_ENTRY *conn;
 
     /* update fdstat */
@@ -216,8 +213,8 @@ int file_update_open(fd, path)
 
 
 /* close a disk file. */
-int file_close(fd)
-     int fd;			/* file descriptor */
+int 
+file_close(int fd)
 {
     FD_ENTRY *conn = NULL;
 
@@ -257,8 +254,8 @@ int file_close(fd)
 }
 
 /* grab a writing lock for file */
-int file_write_lock(fd)
-     int fd;
+int
+file_write_lock(int fd)
 {
     if (file_table[fd].write_lock == LOCK) {
 	debug(6, 0, "trying to lock a locked file\n");
@@ -273,9 +270,8 @@ int file_write_lock(fd)
 
 
 /* release a writing lock for file */
-int file_write_unlock(fd, access_code)
-     int fd;
-     int access_code;
+int
+file_write_unlock(int fd, int access_code)
 {
     if (file_table[fd].access_code == access_code) {
 	file_table[fd].write_lock = UNLOCK;
@@ -288,9 +284,8 @@ int file_write_unlock(fd, access_code)
 
 
 /* write handler */
-int diskHandleWrite(fd, entry)
-     int fd;
-     FileEntry *entry;
+int
+diskHandleWrite(int fd, FileEntry * entry)
 {
     int len;
     dwrite_q *q = NULL;
@@ -362,14 +357,8 @@ int diskHandleWrite(fd, entry)
 /* write block to a file */
 /* write back queue. Only one writer at a time. */
 /* call a handle when writing is complete. */
-int file_write(fd, ptr_to_buf, len, access_code, handle, handle_data, free)
-     int fd;
-     char *ptr_to_buf;
-     int len;
-     int access_code;
-     void (*handle) ();
-     void *handle_data;
-     void (*free) _PARAMS((void *));
+int
+file_write(int fd, char *ptr_to_buf, int len, int access_code, void (*handle) (), void *handle_data, void (*free) _PARAMS((void *)))
 {
     dwrite_q *wq = NULL;
 
@@ -418,9 +407,8 @@ int file_write(fd, ptr_to_buf, len, access_code, handle, handle_data, free)
 
 
 /* Read from FD */
-int diskHandleRead(fd, ctrl_dat)
-     int fd;
-     dread_ctrl *ctrl_dat;
+int
+diskHandleRead(int fd, dread_ctrl * ctrl_dat)
 {
     int len;
 
@@ -484,13 +472,8 @@ int diskHandleRead(fd, ctrl_dat)
 /* buffer must be allocated from the caller. 
  * It must have at least req_len space in there. 
  * call handler when a reading is complete. */
-int file_read(fd, buf, req_len, offset, handler, client_data)
-     int fd;
-     char *buf;
-     int req_len;
-     int offset;
-     FILE_READ_HD handler;
-     void *client_data;
+int
+file_read(int fd, char *buf, int req_len, int offset, FILE_READ_HD handler, void *client_data)
 {
     dread_ctrl *ctrl_dat;
 
@@ -517,9 +500,8 @@ int file_read(fd, buf, req_len, offset, handler, client_data)
 
 
 /* Read from FD and pass a line to routine. Walk to EOF. */
-int diskHandleWalk(fd, walk_dat)
-     int fd;
-     dwalk_ctrl *walk_dat;
+int
+diskHandleWalk(int fd, dwalk_ctrl * walk_dat)
 {
     int len;
     int end_pos;
@@ -586,13 +568,12 @@ int diskHandleWalk(fd, walk_dat)
  * read one block and chop it to a line and pass it to provided 
  * handler one line at a time.
  * call a completion handler when done. */
-int file_walk(fd, handler, client_data, line_handler, line_data)
-     int fd;
-     FILE_WALK_HD handler;
-     void *client_data;
-     FILE_WALK_LHD line_handler;
-     void *line_data;
-
+int
+file_walk(int fd,
+    FILE_WALK_HD handler,
+    void *client_data,
+    FILE_WALK_LHD line_handler,
+    void *line_data)
 {
     dwalk_ctrl *walk_dat;
 
@@ -611,16 +592,17 @@ int file_walk(fd, handler, client_data, line_handler, line_data)
     return DISK_OK;
 }
 
-char *diskFileName(fd)
-     int fd;
+char *
+diskFileName(int fd)
 {
     if (file_table[fd].filename[0])
 	return (file_table[fd].filename);
     else
 	return (0);
 }
 
-int diskWriteIsComplete(fd)
+int
+diskWriteIsComplete(int fd)
 {
     return file_table[fd].write_q ? 0 : 1;
 }
@@ -1,5 +1,5 @@
 /*
- * $Id: dns.cc,v 1.6 1996/08/30 22:37:23 wessels Exp $
+ * $Id: dns.cc,v 1.7 1996/09/14 08:45:48 wessels Exp $
  *
  * DEBUG: section 34    Dnsserver interface
  * AUTHOR: Harvest Derived
@@ -110,16 +110,16 @@ struct dnsQueueData {
     void *data;
 };
 
-static int dnsOpenServer _PARAMS((char *command));
+static int dnsOpenServer(char *command);
 
 static dnsserver_t **dns_child_table = NULL;
 static int NDnsServersAlloc = 0;
 
 char *dns_error_message = NULL;	/* possible error message */
 struct _dnsStats DnsStats;
 
-static int dnsOpenServer(command)
-     char *command;
+static int
+dnsOpenServer(char *command)
 {
     int pid;
     u_short port;
@@ -187,7 +187,8 @@ static int dnsOpenServer(command)
     return 0;
 }
 
-dnsserver_t *dnsGetFirstAvailable()
+dnsserver_t *
+dnsGetFirstAvailable()
 {
     int k;
     dnsserver_t *dns = NULL;
@@ -200,7 +201,8 @@ dnsserver_t *dnsGetFirstAvailable()
 }
 
 
-void dnsOpenServers()
+void
+dnsOpenServers()
 {
     int N = Config.dnsChildren;
     char *prg = Config.Program.dnsserver;
@@ -249,8 +251,8 @@ void dnsOpenServers()
 }
 
 
-void dnsStats(sentry)
-     StoreEntry *sentry;
+void
+dnsStats(StoreEntry * sentry)
 {
     int k;
 
@@ -271,7 +273,8 @@ void dnsStats(sentry)
     storeAppendPrintf(sentry, close_bracket);
 }
 
-void dnsShutdownServers()
+void
+dnsShutdownServers()
 {
     dnsserver_t *dnsData = NULL;
     int k;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: dnsserver.cc,v 1.21 1996/09/12 03:24:02 wessels Exp $
+ * $Id: dnsserver.cc,v 1.22 1996/09/14 08:45:50 wessels Exp $
  *
  * DEBUG: section 0     DNS Resolver
  * AUTHOR: Harvest Derived
@@ -223,8 +223,8 @@ extern int _dns_ttl_;		/* this is a really *dirty* hack - bne */
 int do_debug = 0;
 
 /* error messages from gethostbyname() */
-static char *my_h_msgs(x)
-     int x;
+static char *
+my_h_msgs(int x)
 {
     if (x == HOST_NOT_FOUND)
 	return "Host not found (authoritative)";
@@ -238,9 +238,8 @@ static char *my_h_msgs(x)
 	return "Unknown DNS problem";
 }
 
-int main(argc, argv)
-     int argc;
-     char *argv[];
+int
+main(int argc, char *argv[])
 {
     char request[256];
     char msg[256];
@@ -1,6 +1,6 @@
 
 /*
- * $Id: errorpage.cc,v 1.37 1996/09/11 22:31:06 wessels Exp $
+ * $Id: errorpage.cc,v 1.38 1996/09/14 08:45:52 wessels Exp $
  *
  * DEBUG: section 4     Error Generation
  * AUTHOR: Duane Wessels
@@ -134,7 +134,8 @@ char *tmp_error_buf;
 static char *tbuf = NULL;
 static char *auth_msg = NULL;
 
-void errorInitialize()
+void
+errorInitialize()
 {
 #ifndef USE_PROXY_AUTH
     tmp_error_buf = xmalloc(MAX_URL * 4);
@@ -148,10 +149,8 @@ void errorInitialize()
     meta_data.misc += MAX_URL * 3;
 }
 
-void squid_error_entry(entry, type, msg)
-     StoreEntry *entry;
-     log_type type;
-     char *msg;
+void
+squid_error_entry(StoreEntry * entry, log_type type, char *msg)
 {
     int index;
 
@@ -184,13 +183,8 @@ void squid_error_entry(entry, type, msg)
 
 
 
-char *squid_error_url(url, method, type, address, code, msg)
-     char *url;
-     int method;
-     int type;
-     char *address;
-     int code;
-     char *msg;
+char *
+squid_error_url(char *url, int method, int type, char *address, int code, char *msg)
 {
     int index;
 
@@ -236,11 +230,8 @@ Generated by %s/%s@%s\n\
 </ADDRESS></BODY></HTML>\n\
 \n"
 
-char *squid_error_request(request, type, address, code)
-     char *request;
-     int type;
-     char *address;
-     int code;
+char *
+squid_error_request(char *request, int type, char *address, int code)
 {
     int index;
 
@@ -260,11 +251,8 @@ char *squid_error_request(request, type, address, code)
     return tmp_error_buf;
 }
 
-char *access_denied_msg(code, method, url, client)
-     int code;
-     int method;
-     char *url;
-     char *client;
+char *
+access_denied_msg(int code, int method, char *url, char *client)
 {
     sprintf(tmp_error_buf, "\
 HTTP/1.0 %d Cache Access Denied\r\n\
@@ -300,12 +288,8 @@ Generated by %s/%s@%s\n\
  *    the message that is sent on deny_info
  *      add a Location: and for old browsers a HREF to the info page
  */
-char *access_denied_redirect(code, method, url, client, redirect)
-     int code;
-     int method;
-     char *url;
-     char *client;
-     char *redirect;
+char *
+access_denied_redirect(int code, int method, char *url, char *client, char *redirect)
 {
     sprintf(tmp_error_buf, "\
 HTTP/1.0 %d Cache Access Deny Redirect\r\n\
@@ -343,9 +327,8 @@ Generated by %s/%s@%s\n\
     return tmp_error_buf;
 }
 
-char *authorization_needed_msg(request, realm)
-     request_t *request;
-     char *realm;
+char *
+authorization_needed_msg(request_t * request, char *realm)
 {
     sprintf(auth_msg, "<HTML><HEAD><TITLE>Authorization needed</TITLE>\n\
 </HEAD><BODY><H1>Authorization needed</H1>\n\
@@ -371,10 +354,10 @@ Generated by %s/%s@%s\n\
 	getMyHostname());
 
     mk_mime_hdr(tbuf,
-	(time_t) Config.negativeTtl,
+	"text/html",
 	strlen(auth_msg),
-	0,
-	"text/html");
+	squid_curtime,
+	squid_curtime + Config.negativeTtl);
     sprintf(tmp_error_buf, "HTTP/1.0 401 Unauthorized\r\n\
 %s\
 WWW-Authenticate: Basic realm=\"%s\"\r\n\
@@ -411,11 +394,8 @@ Generated by %s/%s@%s\n\
 </ADDRESS>\n\
 "
 
-char *proxy_denied_msg(code, method, url, client)
-     int code;
-     int method;
-     char *url;
-     char *client;
+char *
+proxy_denied_msg(int code, int method, char *url, char *client)
 {
     sprintf(tmp_error_buf, PROXY_AUTH_ERR_MSG,
 	code,
@@ -1,5 +1,5 @@
 /*
- * $Id: filemap.cc,v 1.8 1996/07/09 03:41:24 wessels Exp $
+ * $Id: filemap.cc,v 1.9 1996/09/14 08:45:56 wessels Exp $
  *
  * DEBUG: section 8     Swap File Bitmap
  * AUTHOR: Harvest Derived
@@ -123,13 +123,13 @@
 #define ALL_ONES (unsigned long) 0xFFFFFFFF
 #endif
 
-extern int storeGetSwapSpace _PARAMS((int));
-extern void fatal_dump _PARAMS((char *));
+extern int storeGetSwapSpace(int);
+extern void fatal_dump(char *);
 
 static fileMap *fm = NULL;
 
-fileMap *file_map_create(n)
-     int n;			/* Number of files */
+fileMap *
+file_map_create(int n)
 {
     fm = xcalloc(1, sizeof(fileMap));
     fm->max_n_files = n;
@@ -142,8 +142,8 @@ fileMap *file_map_create(n)
     return (fm);
 }
 
-int file_map_bit_set(file_number)
-     int file_number;
+int
+file_map_bit_set(int file_number)
 {
     unsigned long bitmask = (1L << (file_number & LONG_BIT_MASK));
 
@@ -166,25 +166,25 @@ int file_map_bit_set(file_number)
     return (file_number);
 }
 
-void file_map_bit_reset(file_number)
-     int file_number;
+void
+file_map_bit_reset(int file_number)
 {
     unsigned long bitmask = (1L << (file_number & LONG_BIT_MASK));
 
     fm->file_map[file_number >> LONG_BIT_SHIFT] &= ~bitmask;
     fm->n_files_in_map--;
 }
 
-int file_map_bit_test(file_number)
-     int file_number;
+int
+file_map_bit_test(int file_number)
 {
     unsigned long bitmask = (1L << (file_number & LONG_BIT_MASK));
     /* be sure the return value is an int, not a u_long */
     return (fm->file_map[file_number >> LONG_BIT_SHIFT] & bitmask ? 1 : 0);
 }
 
-int file_map_allocate(suggestion)
-     int suggestion;
+int
+file_map_allocate(int suggestion)
 {
     int word;
     int bit;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: fqdncache.cc,v 1.16 1996/09/12 03:24:03 wessels Exp $
+ * $Id: fqdncache.cc,v 1.17 1996/09/14 08:45:58 wessels Exp $
  *
  * DEBUG: section 35    FQDN Cache
  * AUTHOR: Harvest Derived
@@ -137,26 +137,26 @@ static struct {
     int ghba_calls;		/* # calls to blocking gethostbyaddr() */
 } FqdncacheStats;
 
-static int fqdncache_compareLastRef _PARAMS((fqdncache_entry **, fqdncache_entry **));
-static int fqdncache_dnsHandleRead _PARAMS((int, dnsserver_t *));
-static fqdncache_entry *fqdncache_parsebuffer _PARAMS((char *buf, dnsserver_t *));
-static int fqdncache_purgelru _PARAMS((void));
-static void fqdncache_release _PARAMS((fqdncache_entry *));
-static fqdncache_entry *fqdncache_GetFirst _PARAMS((void));
-static fqdncache_entry *fqdncache_GetNext _PARAMS((void));
-static fqdncache_entry *fqdncache_create _PARAMS((void));
-static void fqdncache_add_to_hash _PARAMS((fqdncache_entry *));
-static void fqdncache_call_pending _PARAMS((fqdncache_entry *));
-static void fqdncache_call_pending_badname _PARAMS((int fd, FQDNH handler, void *));
-static void fqdncache_add _PARAMS((char *, fqdncache_entry *, struct hostent *, int));
-static int fqdncacheHasPending _PARAMS((fqdncache_entry *));
-static fqdncache_entry *fqdncache_get _PARAMS((char *));
-static void dummy_handler _PARAMS((int, char *, void *));
-static int fqdncacheExpiredEntry _PARAMS((fqdncache_entry *));
-static void fqdncacheAddPending _PARAMS((fqdncache_entry *, int fd, FQDNH, void *));
-static void fqdncacheEnqueue _PARAMS((fqdncache_entry *));
-static void *fqdncacheDequeue _PARAMS((void));
-static void fqdncache_dnsDispatch _PARAMS((dnsserver_t *, fqdncache_entry *));
+static int fqdncache_compareLastRef(fqdncache_entry **, fqdncache_entry **);
+static int fqdncache_dnsHandleRead(int, dnsserver_t *);
+static fqdncache_entry *fqdncache_parsebuffer(char *buf, dnsserver_t *);
+static int fqdncache_purgelru(void);
+static void fqdncache_release(fqdncache_entry *);
+static fqdncache_entry *fqdncache_GetFirst(void);
+static fqdncache_entry *fqdncache_GetNext(void);
+static fqdncache_entry *fqdncache_create(void);
+static void fqdncache_add_to_hash(fqdncache_entry *);
+static void fqdncache_call_pending(fqdncache_entry *);
+static void fqdncache_call_pending_badname(int fd, FQDNH handler, void *);
+static void fqdncache_add(char *, fqdncache_entry *, struct hostent *, int);
+static int fqdncacheHasPending(fqdncache_entry *);
+static fqdncache_entry *fqdncache_get(char *);
+static void dummy_handler(int, char *, void *);
+static int fqdncacheExpiredEntry(fqdncache_entry *);
+static void fqdncacheAddPending(fqdncache_entry *, int fd, FQDNH, void *);
+static void fqdncacheEnqueue(fqdncache_entry *);
+static void *fqdncacheDequeue(void);
+static void fqdncache_dnsDispatch(dnsserver_t *, fqdncache_entry *);
 
 static struct hostent *static_result = NULL;
 static HashID fqdn_table = 0;
@@ -174,16 +174,17 @@ static char fqdncache_status_char[] =
 long fqdncache_low = 180;
 long fqdncache_high = 200;
 
-static void fqdncacheEnqueue(f)
-     fqdncache_entry *f;
+static void
+fqdncacheEnqueue(fqdncache_entry * f)
 {
     struct fqdncacheQueueData *new = xcalloc(1, sizeof(struct fqdncacheQueueData));
     new->f = f;
     *fqdncacheQueueTailP = new;
     fqdncacheQueueTailP = &new->next;
 }
 
-static void *fqdncacheDequeue()
+static void *
+fqdncacheDequeue()
 {
     struct fqdncacheQueueData *old = NULL;
     fqdncache_entry *f = NULL;
@@ -199,8 +200,8 @@ static void *fqdncacheDequeue()
 }
 
 /* removes the given fqdncache entry */
-static void fqdncache_release(f)
-     fqdncache_entry *f;
+static void
+fqdncache_release(fqdncache_entry * f)
 {
     fqdncache_entry *result = NULL;
     hash_link *table_entry = NULL;
@@ -241,8 +242,8 @@ static void fqdncache_release(f)
 }
 
 /* return match for given name */
-static fqdncache_entry *fqdncache_get(name)
-     char *name;
+static fqdncache_entry *
+fqdncache_get(char *name)
 {
     hash_link *e;
     static fqdncache_entry *f;
@@ -255,18 +256,20 @@ static fqdncache_entry *fqdncache_get(name)
     return f;
 }
 
-static fqdncache_entry *fqdncache_GetFirst()
+static fqdncache_entry *
+fqdncache_GetFirst()
 {
     return (fqdncache_entry *) hash_first(fqdn_table);
 }
 
-static fqdncache_entry *fqdncache_GetNext()
+static fqdncache_entry *
+fqdncache_GetNext()
 {
     return (fqdncache_entry *) hash_next(fqdn_table);
 }
 
-static int fqdncache_compareLastRef(e1, e2)
-     fqdncache_entry **e1, **e2;
+static int
+fqdncache_compareLastRef(fqdncache_entry ** e1, fqdncache_entry ** e2)
 {
     if (!e1 || !e2)
 	fatal_dump(NULL);
@@ -277,8 +280,8 @@ static int fqdncache_compareLastRef(e1, e2)
     return (0);
 }
 
-static int fqdncacheExpiredEntry(f)
-     fqdncache_entry *f;
+static int
+fqdncacheExpiredEntry(fqdncache_entry * f)
 {
     if (f->status == FQDN_PENDING)
 	return 0;
@@ -290,7 +293,8 @@ static int fqdncacheExpiredEntry(f)
 }
 
 /* finds the LRU and deletes */
-static int fqdncache_purgelru()
+static int
+fqdncache_purgelru()
 {
     fqdncache_entry *f = NULL;
     int local_fqdn_count = 0;
@@ -353,7 +357,8 @@ static int fqdncache_purgelru()
 
 
 /* create blank fqdncache_entry */
-static fqdncache_entry *fqdncache_create()
+static fqdncache_entry *
+fqdncache_create()
 {
     static fqdncache_entry *new;
 
@@ -367,8 +372,8 @@ static fqdncache_entry *fqdncache_create()
 
 }
 
-static void fqdncache_add_to_hash(f)
-     fqdncache_entry *f;
+static void
+fqdncache_add_to_hash(fqdncache_entry * f)
 {
     if (hash_join(fqdn_table, (hash_link *) f)) {
 	debug(35, 1, "fqdncache_add_to_hash: Cannot add %s (%p) to hash table %d.\n",
@@ -378,11 +383,8 @@ static void fqdncache_add_to_hash(f)
 }
 
 
-static void fqdncache_add(name, f, hp, cached)
-     char *name;
-     fqdncache_entry *f;
-     struct hostent *hp;
-     int cached;
+static void
+fqdncache_add(char *name, fqdncache_entry * f, struct hostent *hp, int cached)
 {
     int k;
 
@@ -411,8 +413,8 @@ static void fqdncache_add(name, f, hp, cached)
 }
 
 /* walks down the pending list, calling handlers */
-static void fqdncache_call_pending(f)
-     fqdncache_entry *f;
+static void
+fqdncache_call_pending(fqdncache_entry * f)
 {
     struct _fqdn_pending *p = NULL;
     int nhandler = 0;
@@ -436,18 +438,15 @@ static void fqdncache_call_pending(f)
     debug(35, 10, "fqdncache_call_pending: Called %d handlers.\n", nhandler);
 }
 
-static void fqdncache_call_pending_badname(fd, handler, data)
-     int fd;
-     FQDNH handler;
-     void *data;
+static void
+fqdncache_call_pending_badname(int fd, FQDNH handler, void *data)
 {
     debug(35, 0, "fqdncache_call_pending_badname: Bad Name: Calling handler with NULL result.\n");
     handler(fd, NULL, data);
 }
 
-static fqdncache_entry *fqdncache_parsebuffer(inbuf, dnsData)
-     char *inbuf;
-     dnsserver_t *dnsData;
+static fqdncache_entry *
+fqdncache_parsebuffer(char *inbuf, dnsserver_t * dnsData)
 {
     char *buf = xstrdup(inbuf);
     char *token;
@@ -513,9 +512,8 @@ static fqdncache_entry *fqdncache_parsebuffer(inbuf, dnsData)
     return &f;
 }
 
-static int fqdncache_dnsHandleRead(fd, dnsData)
-     int fd;
-     dnsserver_t *dnsData;
+static int
+fqdncache_dnsHandleRead(int fd, dnsserver_t * dnsData)
 {
     int len;
     int svc_time;
@@ -576,11 +574,8 @@ static int fqdncache_dnsHandleRead(fd, dnsData)
     return 0;
 }
 
-static void fqdncacheAddPending(f, fd, handler, handlerData)
-     fqdncache_entry *f;
-     int fd;
-     FQDNH handler;
-     void *handlerData;
+static void
+fqdncacheAddPending(fqdncache_entry * f, int fd, FQDNH handler, void *handlerData)
 {
     struct _fqdn_pending *pending = xcalloc(1, sizeof(struct _fqdn_pending));
     struct _fqdn_pending **I = NULL;
@@ -593,11 +588,8 @@ static void fqdncacheAddPending(f, fd, handler, handlerData)
     *I = pending;
 }
 
-int fqdncache_nbgethostbyaddr(addr, fd, handler, handlerData)
-     struct in_addr addr;
-     int fd;
-     FQDNH handler;
-     void *handlerData;
+int
+fqdncache_nbgethostbyaddr(struct in_addr addr, int fd, FQDNH handler, void *handlerData)
 {
     fqdncache_entry *f = NULL;
     dnsserver_t *dnsData = NULL;
@@ -657,9 +649,8 @@ int fqdncache_nbgethostbyaddr(addr, fd, handler, handlerData)
     return 0;
 }
 
-static void fqdncache_dnsDispatch(dns, f)
-     dnsserver_t *dns;
-     fqdncache_entry *f;
+static void
+fqdncache_dnsDispatch(dnsserver_t * dns, fqdncache_entry * f)
 {
     char *buf = NULL;
     if (!fqdncacheHasPending(f)) {
@@ -694,7 +685,8 @@ static void fqdncache_dnsDispatch(dns, f)
 
 
 /* initialize the fqdncache */
-void fqdncache_init()
+void
+fqdncache_init()
 {
     debug(35, 3, "Initializing FQDN Cache...\n");
 
@@ -716,9 +708,8 @@ void fqdncache_init()
 
 /* clean up the pending entries in dnsserver */
 /* return 1 if we found the host, 0 otherwise */
-int fqdncacheUnregister(addr, fd)
-     struct in_addr addr;
-     int fd;
+int
+fqdncacheUnregister(struct in_addr addr, int fd)
 {
     char *name = inet_ntoa(addr);
     fqdncache_entry *f = NULL;
@@ -741,9 +732,8 @@ int fqdncacheUnregister(addr, fd)
     return n;
 }
 
-char *fqdncache_gethostbyaddr(addr, flags)
-     struct in_addr addr;
-     int flags;
+char *
+fqdncache_gethostbyaddr(struct in_addr addr, int flags)
 {
     char *name = inet_ntoa(addr);
     fqdncache_entry *f = NULL;
@@ -794,8 +784,8 @@ char *fqdncache_gethostbyaddr(addr, flags)
 
 
 /* process objects list */
-void fqdnStats(sentry)
-     StoreEntry *sentry;
+void
+fqdnStats(StoreEntry * sentry)
 {
     fqdncache_entry *f = NULL;
     int k;
@@ -841,16 +831,14 @@ void fqdnStats(sentry)
     storeAppendPrintf(sentry, close_bracket);
 }
 
-static void dummy_handler(u1, u2, u3)
-     int u1;
-     char *u2;
-     void *u3;
+static void
+dummy_handler(int u1, char *u2, void *u3)
 {
     return;
 }
 
-static int fqdncacheHasPending(f)
-     fqdncache_entry *f;
+static int
+fqdncacheHasPending(fqdncache_entry * f)
 {
     struct _fqdn_pending *p = NULL;
     if (f->status != FQDN_PENDING)
@@ -861,8 +849,8 @@ static int fqdncacheHasPending(f)
     return 0;
 }
 
-void fqdncacheReleaseInvalid(name)
-     char *name;
+void
+fqdncacheReleaseInvalid(char *name)
 {
     fqdncache_entry *f;
     if ((f = fqdncache_get(name)) == NULL)
@@ -872,8 +860,8 @@ void fqdncacheReleaseInvalid(name)
     fqdncache_release(f);
 }
 
-char *fqdnFromAddr(addr)
-     struct in_addr addr;
+char *
+fqdnFromAddr(struct in_addr addr)
 {
     char *n;
     static char buf[32];
@@ -883,7 +871,8 @@ char *fqdnFromAddr(addr)
     return buf;
 }
 
-int fqdncacheQueueDrain()
+int
+fqdncacheQueueDrain()
 {
     fqdncache_entry *i;
     dnsserver_t *dnsData;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ftp.cc,v 1.54 1996/09/12 16:39:53 wessels Exp $
+ * $Id: ftp.cc,v 1.55 1996/09/14 08:45:59 wessels Exp $
  *
  * DEBUG: section 9     File Transfer Protocol (FTP)
  * AUTHOR: Harvest Derived
@@ -127,26 +127,25 @@ typedef struct _Ftpdata {
 } FtpData;
 
 /* Local functions */
-static int ftpStateFree _PARAMS((int fd, FtpData * ftpState));
-static void ftpProcessReplyHeader _PARAMS((FtpData * data, char *buf, int size));
-static void ftpServerClosed _PARAMS((int fd, void *nodata));
-static void ftp_login_parser _PARAMS((char *login, FtpData * data));
-static char *ftpTransferMode _PARAMS((char *urlpath));
+static int ftpStateFree(int fd, FtpData * ftpState);
+static void ftpProcessReplyHeader(FtpData * data, char *buf, int size);
+static void ftpServerClosed(int fd, void *nodata);
+static void ftp_login_parser(char *login, FtpData * data);
+static char *ftpTransferMode(char *urlpath);
 
 /* Global functions not declared in ftp.h */
-void ftpLifetimeExpire _PARAMS((int fd, FtpData * data));
-int ftpReadReply _PARAMS((int fd, FtpData * data));
-void ftpSendComplete _PARAMS((int fd, char *buf, int size, int errflag, void *ftpData));
-void ftpSendRequest _PARAMS((int fd, FtpData * data));
-void ftpConnInProgress _PARAMS((int fd, FtpData * data));
-void ftpServerClose _PARAMS((void));
+void ftpLifetimeExpire(int fd, FtpData * data);
+int ftpReadReply(int fd, FtpData * data);
+void ftpSendComplete(int fd, char *buf, int size, int errflag, void *ftpData);
+void ftpSendRequest(int fd, FtpData * data);
+void ftpConnInProgress(int fd, FtpData * data);
+void ftpServerClose(void);
 
 /* External functions */
-extern char *base64_decode _PARAMS((char *coded));
+extern char *base64_decode(char *coded);
 
-static int ftpStateFree(fd, ftpState)
-     int fd;
-     FtpData *ftpState;
+static int
+ftpStateFree(int fd, FtpData * ftpState)
 {
     if (ftpState == NULL)
 	return 1;
@@ -160,9 +159,8 @@ static int ftpStateFree(fd, ftpState)
     return 0;
 }
 
-static void ftp_login_parser(login, data)
-     char *login;
-     FtpData *data;
+static void
+ftp_login_parser(char *login, FtpData * data)
 {
     char *user = data->user;
     char *password = data->password;
@@ -184,9 +182,8 @@ static void ftp_login_parser(login, data)
 }
 
 /* This will be called when socket lifetime is expired. */
-void ftpLifetimeExpire(fd, data)
-     int fd;
-     FtpData *data;
+void
+ftpLifetimeExpire(int fd, FtpData * data)
 {
     StoreEntry *entry = NULL;
     entry = data->entry;
@@ -198,10 +195,8 @@ void ftpLifetimeExpire(fd, data)
 
 /* This is too much duplicated code from httpProcessReplyHeader.  Only
  * difference is FtpData vs HttpData. */
-static void ftpProcessReplyHeader(data, buf, size)
-     FtpData *data;
-     char *buf;			/* chunk just read by ftpReadReply() */
-     int size;
+static void
+ftpProcessReplyHeader(FtpData * data, char *buf, int size)
 {
     char *t = NULL;
     StoreEntry *entry = data->entry;
@@ -279,9 +274,8 @@ static void ftpProcessReplyHeader(data, buf, size)
 
 /* This will be called when data is ready to be read from fd.  Read until
  * error or connection closed. */
-int ftpReadReply(fd, data)
-     int fd;
-     FtpData *data;
+int
+ftpReadReply(int fd, FtpData * data)
 {
     LOCAL_ARRAY(char, buf, SQUID_TCP_SO_RCVBUF);
     int len;
@@ -409,12 +403,8 @@ int ftpReadReply(fd, data)
     return 0;
 }
 
-void ftpSendComplete(fd, buf, size, errflag, data)
-     int fd;
-     char *buf;
-     int size;
-     int errflag;
-     void *data;
+void
+ftpSendComplete(int fd, char *buf, int size, int errflag, void *data)
 {
     FtpData *ftpState = (FtpData *) data;
     StoreEntry *entry = NULL;
@@ -443,8 +433,8 @@ void ftpSendComplete(fd, buf, size, errflag, data)
     }
 }
 
-static char *ftpTransferMode(urlpath)
-     char *urlpath;
+static char *
+ftpTransferMode(char *urlpath)
 {
     static char ftpASCII[] = "A";
     static char ftpBinary[] = "I";
@@ -463,9 +453,8 @@ static char *ftpTransferMode(urlpath)
     return ftpBinary;
 }
 
-void ftpSendRequest(fd, data)
-     int fd;
-     FtpData *data;
+void
+ftpSendRequest(int fd, FtpData * data)
 {
     char *path = NULL;
     char *mode = NULL;
@@ -541,9 +530,8 @@ void ftpSendRequest(fd, data)
 	put_free_8k_page);
 }
 
-void ftpConnInProgress(fd, data)
-     int fd;
-     FtpData *data;
+void
+ftpConnInProgress(int fd, FtpData * data)
 {
     StoreEntry *entry = data->entry;
 
@@ -575,11 +563,8 @@ void ftpConnInProgress(fd, data)
 }
 
 
-int ftpStart(unusedfd, url, request, entry)
-     int unusedfd;
-     char *url;
-     request_t *request;
-     StoreEntry *entry;
+int
+ftpStart(int unusedfd, char *url, request_t * request, StoreEntry * entry)
 {
     LOCAL_ARRAY(char, realm, 8192);
     FtpData *data = NULL;
@@ -682,9 +667,8 @@ int ftpStart(unusedfd, url, request, entry)
     return COMM_OK;
 }
 
-static void ftpServerClosed(fd, nodata)
-     int fd;
-     void *nodata;
+static void
+ftpServerClosed(int fd, void *nodata)
 {
     static time_t last_restart = 0;
     comm_close(fd);
@@ -698,7 +682,8 @@ static void ftpServerClosed(fd, nodata)
     (void) ftpInitialize();
 }
 
-void ftpServerClose()
+void
+ftpServerClose()
 {
     /* NOTE: this function will be called repeatedly while shutdown is
      * pending */
@@ -717,7 +702,8 @@ void ftpServerClose()
 }
 
 
-int ftpInitialize()
+int
+ftpInitialize()
 {
     int pid;
     int cfd;
@@ -1,5 +1,5 @@
 /*
- * $Id: gopher.cc,v 1.42 1996/09/12 16:39:53 wessels Exp $
+ * $Id: gopher.cc,v 1.43 1996/09/14 08:46:02 wessels Exp $
  *
  * DEBUG: section 10    Gopher
  * AUTHOR: Harvest Derived
@@ -158,33 +158,32 @@ typedef struct gopher_ds {
     char *buf;			/* pts to a 4k page */
 } GopherStateData;
 
-static int gopherStateFree _PARAMS((int fd, GopherStateData *));
-static void gopher_mime_content _PARAMS((char *buf, char *name, char *def));
-static void gopherMimeCreate _PARAMS((GopherStateData *));
+static int gopherStateFree(int fd, GopherStateData *);
+static void gopher_mime_content(char *buf, char *name, char *def);
+static void gopherMimeCreate(GopherStateData *);
 static int gopher_url_parser _PARAMS((char *url,
 	char *host,
 	int *port,
 	char *type_id,
 	char *request));
-static void gopherEndHTML _PARAMS((GopherStateData *));
-static void gopherToHTML _PARAMS((GopherStateData *, char *inbuf, int len));
-static int gopherReadReplyTimeout _PARAMS((int fd, GopherStateData *));
-static void gopherLifetimeExpire _PARAMS((int fd, GopherStateData *));
-static void gopherReadReply _PARAMS((int fd, GopherStateData *));
+static void gopherEndHTML(GopherStateData *);
+static void gopherToHTML(GopherStateData *, char *inbuf, int len);
+static int gopherReadReplyTimeout(int fd, GopherStateData *);
+static void gopherLifetimeExpire(int fd, GopherStateData *);
+static void gopherReadReply(int fd, GopherStateData *);
 static void gopherSendComplete _PARAMS((int fd,
 	char *buf,
 	int size,
 	int errflag,
 	void *data));
-static void gopherSendRequest _PARAMS((int fd, GopherStateData *));
-static GopherStateData *CreateGopherStateData _PARAMS((void));
+static void gopherSendRequest(int fd, GopherStateData *);
+static GopherStateData *CreateGopherStateData(void);
 
 static char def_gopher_bin[] = "www/unknown";
 static char def_gopher_text[] = "text/plain";
 
-static int gopherStateFree(fd, gopherState)
-     int fd;
-     GopherStateData *gopherState;
+static int
+gopherStateFree(int fd, GopherStateData * gopherState)
 {
     if (gopherState == NULL)
 	return 1;
@@ -197,10 +196,8 @@ static int gopherStateFree(fd, gopherState)
 
 
 /* figure out content type from file extension */
-static void gopher_mime_content(buf, name, def)
-     char *buf;
-     char *name;
-     char *def;
+static void
+gopher_mime_content(char *buf, char *name, char *def)
 {
     LOCAL_ARRAY(char, temp, MAX_URL + 1);
     char *ext1 = NULL;
@@ -249,8 +246,8 @@ static void gopher_mime_content(buf, name, def)
 
 
 /* create MIME Header for Gopher Data */
-static void gopherMimeCreate(data)
-     GopherStateData *data;
+static void
+gopherMimeCreate(GopherStateData * data)
 {
     LOCAL_ARRAY(char, tempMIME, MAX_MIME);
 
@@ -300,12 +297,8 @@ MIME-version: 1.0\r\n", version_string);
 }
 
 /* Parse a gopher url into components.  By Anawat. */
-static int gopher_url_parser(url, host, port, type_id, request)
-     char *url;
-     char *host;
-     int *port;
-     char *type_id;
-     char *request;
+static int
+gopher_url_parser(char *url, char *host, int *port, char *type_id, char *request)
 {
     LOCAL_ARRAY(char, proto, MAX_URL);
     LOCAL_ARRAY(char, hostbuf, MAX_URL);
@@ -337,8 +330,8 @@ static int gopher_url_parser(url, host, port, type_id, request)
     return 0;
 }
 
-int gopherCachable(url)
-     char *url;
+int
+gopherCachable(char *url)
 {
     GopherStateData *data = NULL;
     int cachable = 1;
@@ -364,8 +357,8 @@ int gopherCachable(url)
     return cachable;
 }
 
-static void gopherEndHTML(data)
-     GopherStateData *data;
+static void
+gopherEndHTML(GopherStateData * data)
 {
     LOCAL_ARRAY(char, tmpbuf, TEMP_BUF_SIZE);
 
@@ -380,10 +373,8 @@ static void gopherEndHTML(data)
 
 /* Convert Gopher to HTML */
 /* Borrow part of code from libwww2 came with Mosaic distribution */
-static void gopherToHTML(data, inbuf, len)
-     GopherStateData *data;
-     char *inbuf;
-     int len;
+static void
+gopherToHTML(GopherStateData * data, char *inbuf, int len)
 {
     char *pos = inbuf;
     char *lpos = NULL;
@@ -682,9 +673,8 @@ static void gopherToHTML(data, inbuf, len)
     return;
 }
 
-static int gopherReadReplyTimeout(fd, data)
-     int fd;
-     GopherStateData *data;
+static int
+gopherReadReplyTimeout(int fd, GopherStateData * data)
 {
     StoreEntry *entry = NULL;
     entry = data->entry;
@@ -695,9 +685,8 @@ static int gopherReadReplyTimeout(fd, data)
 }
 
 /* This will be called when socket lifetime is expired. */
-static void gopherLifetimeExpire(fd, data)
-     int fd;
-     GopherStateData *data;
+static void
+gopherLifetimeExpire(int fd, GopherStateData * data)
 {
     StoreEntry *entry = NULL;
     entry = data->entry;
@@ -715,9 +704,8 @@ static void gopherLifetimeExpire(fd, data)
 
 /* This will be called when data is ready to be read from fd.  Read until
  * error or connection closed. */
-static void gopherReadReply(fd, data)
-     int fd;
-     GopherStateData *data;
+static void
+gopherReadReply(int fd, GopherStateData * data)
 {
     char *buf = NULL;
     int len;
@@ -866,12 +854,8 @@ static void gopherReadReply(fd, data)
 
 /* This will be called when request write is complete. Schedule read of
  * reply. */
-static void gopherSendComplete(fd, buf, size, errflag, data)
-     int fd;
-     char *buf;
-     int size;
-     int errflag;
-     void *data;
+static void
+gopherSendComplete(int fd, char *buf, int size, int errflag, void *data)
 {
     GopherStateData *gopherState = (GopherStateData *) data;
     StoreEntry *entry = NULL;
@@ -939,9 +923,8 @@ static void gopherSendComplete(fd, buf, size, errflag, data)
 }
 
 /* This will be called when connect completes. Write request. */
-static void gopherSendRequest(fd, data)
-     int fd;
-     GopherStateData *data;
+static void
+gopherSendRequest(int fd, GopherStateData * data)
 {
     int len;
     LOCAL_ARRAY(char, query, MAX_URL);
@@ -975,10 +958,8 @@ static void gopherSendRequest(fd, data)
 	storeSetPublicKey(data->entry);		/* Make it public */
 }
 
-int gopherStart(unusedfd, url, entry)
-     int unusedfd;
-     char *url;
-     StoreEntry *entry;
+int
+gopherStart(int unusedfd, char *url, StoreEntry * entry)
 {
     /* Create state structure. */
     int sock, status;
@@ -1062,7 +1043,8 @@ int gopherStart(unusedfd, url, entry)
 }
 
 
-static GopherStateData *CreateGopherStateData()
+static GopherStateData *
+CreateGopherStateData()
 {
     GopherStateData *gd = xcalloc(1, sizeof(GopherStateData));
     gd->buf = get_free_4k_page();
@@ -1,5 +1,5 @@
 /*
- * $Id: http.cc,v 1.73 1996/09/12 16:39:54 wessels Exp $
+ * $Id: http.cc,v 1.74 1996/09/14 08:46:05 wessels Exp $
  *
  * DEBUG: section 11    Hypertext Transfer Protocol (HTTP)
  * AUTHOR: Harvest Derived
@@ -116,21 +116,20 @@ struct {
     int ctype;
 } ReplyHeaderStats;
 
-static int httpStateFree _PARAMS((int fd, HttpStateData *));
-static void httpReadReplyTimeout _PARAMS((int fd, HttpStateData *));
-static void httpLifetimeExpire _PARAMS((int fd, HttpStateData *));
-static void httpMakePublic _PARAMS((StoreEntry *));
-static void httpMakePrivate _PARAMS((StoreEntry *));
-static void httpCacheNegatively _PARAMS((StoreEntry *));
-static void httpReadReply _PARAMS((int fd, HttpStateData *));
-static void httpSendComplete _PARAMS((int fd, char *, int, int, void *));
-static void httpSendRequest _PARAMS((int fd, HttpStateData *));
-static void httpConnInProgress _PARAMS((int fd, HttpStateData *));
-static int httpConnect _PARAMS((int fd, struct hostent *, void *));
-
-static int httpStateFree(fd, httpState)
-     int fd;
-     HttpStateData *httpState;
+static int httpStateFree(int fd, HttpStateData *);
+static void httpReadReplyTimeout(int fd, HttpStateData *);
+static void httpLifetimeExpire(int fd, HttpStateData *);
+static void httpMakePublic(StoreEntry *);
+static void httpMakePrivate(StoreEntry *);
+static void httpCacheNegatively(StoreEntry *);
+static void httpReadReply(int fd, HttpStateData *);
+static void httpSendComplete(int fd, char *, int, int, void *);
+static void httpSendRequest(int fd, HttpStateData *);
+static void httpConnInProgress(int fd, HttpStateData *);
+static int httpConnect(int fd, struct hostent *, void *);
+
+static int
+httpStateFree(int fd, HttpStateData * httpState)
 {
     if (httpState == NULL)
 	return 1;
@@ -144,9 +143,8 @@ static int httpStateFree(fd, httpState)
     return 0;
 }
 
-int httpCachable(url, method)
-     char *url;
-     int method;
+int
+httpCachable(char *url, int method)
 {
     /* GET and HEAD are cachable. Others are not. */
     if (method != METHOD_GET && method != METHOD_HEAD)
@@ -156,9 +154,8 @@ int httpCachable(url, method)
 }
 
 /* This will be called when timeout on read. */
-static void httpReadReplyTimeout(fd, httpState)
-     int fd;
-     HttpStateData *httpState;
+static void
+httpReadReplyTimeout(int fd, HttpStateData * httpState)
 {
     StoreEntry *entry = NULL;
 
@@ -170,9 +167,8 @@ static void httpReadReplyTimeout(fd, httpState)
 }
 
 /* This will be called when socket lifetime is expired. */
-static void httpLifetimeExpire(fd, httpState)
-     int fd;
-     HttpStateData *httpState;
+static void
+httpLifetimeExpire(int fd, HttpStateData * httpState)
 {
     StoreEntry *entry = NULL;
 
@@ -185,17 +181,17 @@ static void httpLifetimeExpire(fd, httpState)
 }
 
 /* This object can be cached for a long time */
-static void httpMakePublic(entry)
-     StoreEntry *entry;
+static void
+httpMakePublic(StoreEntry * entry)
 {
     ttlSet(entry);
     if (BIT_TEST(entry->flag, ENTRY_CACHABLE))
 	storeSetPublicKey(entry);
 }
 
 /* This object should never be cached at all */
-static void httpMakePrivate(entry)
-     StoreEntry *entry;
+static void
+httpMakePrivate(StoreEntry * entry)
 {
     storeSetPrivateKey(entry);
     storeExpireNow(entry);
@@ -204,8 +200,8 @@ static void httpMakePrivate(entry)
 }
 
 /* This object may be negatively cached */
-static void httpCacheNegatively(entry)
-     StoreEntry *entry;
+static void
+httpCacheNegatively(StoreEntry * entry)
 {
     storeNegativeCache(entry);
     if (BIT_TEST(entry->flag, ENTRY_CACHABLE))
@@ -214,9 +210,8 @@ static void httpCacheNegatively(entry)
 
 
 /* Build a reply structure from HTTP reply headers */
-void httpParseHeaders(buf, reply)
-     char *buf;
-     struct _http_reply *reply;
+void
+httpParseHeaders(char *buf, struct _http_reply *reply)
 {
     char *headers = NULL;
     char *t = NULL;
@@ -279,10 +274,8 @@ void httpParseHeaders(buf, reply)
 }
 
 
-void httpProcessReplyHeader(httpState, buf, size)
-     HttpStateData *httpState;
-     char *buf;			/* chunk just read by httpReadReply() */
-     int size;
+void
+httpProcessReplyHeader(HttpStateData * httpState, char *buf, int size)
 {
     char *t = NULL;
     StoreEntry *entry = httpState->entry;
@@ -393,9 +386,8 @@ void httpProcessReplyHeader(httpState, buf, size)
 /* This will be called when data is ready to be read from fd.  Read until
  * error or connection closed. */
 /* XXX this function is too long! */
-static void httpReadReply(fd, httpState)
-     int fd;
-     HttpStateData *httpState;
+static void
+httpReadReply(int fd, HttpStateData * httpState)
 {
     LOCAL_ARRAY(char, buf, SQUID_TCP_SO_RCVBUF);
     int len;
@@ -517,12 +509,8 @@ static void httpReadReply(fd, httpState)
 
 /* This will be called when request write is complete. Schedule read of
  * reply. */
-static void httpSendComplete(fd, buf, size, errflag, data)
-     int fd;
-     char *buf;
-     int size;
-     int errflag;
-     void *data;
+static void
+httpSendComplete(int fd, char *buf, int size, int errflag, void *data)
 {
     HttpStateData *httpState = data;
     StoreEntry *entry = NULL;
@@ -551,9 +539,8 @@ static void httpSendComplete(fd, buf, size, errflag, data)
 }
 
 /* This will be called when connect completes. Write request. */
-static void httpSendRequest(fd, httpState)
-     int fd;
-     HttpStateData *httpState;
+static void
+httpSendRequest(int fd, HttpStateData * httpState)
 {
     char *xbuf = NULL;
     char *ybuf = NULL;
@@ -648,9 +635,8 @@ static void httpSendRequest(fd, httpState)
 	buftype == BUF_TYPE_8K ? put_free_8k_page : xfree);
 }
 
-static void httpConnInProgress(fd, httpState)
-     int fd;
-     HttpStateData *httpState;
+static void
+httpConnInProgress(int fd, HttpStateData * httpState)
 {
     StoreEntry *entry = httpState->entry;
     request_t *req = httpState->request;
@@ -681,10 +667,8 @@ static void httpConnInProgress(fd, httpState)
 	(PF) httpSendRequest, (void *) httpState);
 }
 
-int proxyhttpStart(e, url, entry)
-     edge *e;
-     char *url;
-     StoreEntry *entry;
+int
+proxyhttpStart(edge * e, char *url, StoreEntry * entry)
 {
     int sock;
     HttpStateData *httpState = NULL;
@@ -727,10 +711,8 @@ int proxyhttpStart(e, url, entry)
     return COMM_OK;
 }
 
-static int httpConnect(fd, hp, data)
-     int fd;
-     struct hostent *hp;
-     void *data;
+static int
+httpConnect(int fd, struct hostent *hp, void *data)
 {
     HttpStateData *httpState = data;
     request_t *request = httpState->request;
@@ -773,12 +755,8 @@ static int httpConnect(fd, hp, data)
     return COMM_OK;
 }
 
-int httpStart(unusedfd, url, request, req_hdr, entry)
-     int unusedfd;
-     char *url;
-     request_t *request;
-     char *req_hdr;
-     StoreEntry *entry;
+int
+httpStart(int unusedfd, char *url, request_t * request, char *req_hdr, StoreEntry * entry)
 {
     /* Create state structure. */
     int sock;
@@ -810,8 +788,8 @@ int httpStart(unusedfd, url, request, req_hdr, entry)
     return COMM_OK;
 }
 
-void httpReplyHeaderStats(entry)
-     StoreEntry *entry;
+void
+httpReplyHeaderStats(StoreEntry * entry)
 {
     storeAppendPrintf(entry, open_bracket);
     storeAppendPrintf(entry, "{HTTP Reply Headers}\n");
@@ -1,5 +1,5 @@
 /*
- * $Id: ident.cc,v 1.10 1996/08/31 06:40:19 wessels Exp $
+ * $Id: ident.cc,v 1.11 1996/09/14 08:46:09 wessels Exp $
  *
  * DEBUG: section 30    Ident (RFC 931)
  * AUTHOR: Duane Wessels
@@ -32,20 +32,19 @@
 
 #define IDENT_PORT 113
 
-static void identRequestComplete _PARAMS((int, char *, int, int, void *));
-static void identReadReply _PARAMS((int, icpStateData *));
-static void identClose _PARAMS((int, icpStateData *));
+static void identRequestComplete(int, char *, int, int, void *);
+static void identReadReply(int, icpStateData *);
+static void identClose(int, icpStateData *);
 
-static void identClose(fd, icpState)
-     int fd;
-     icpStateData *icpState;
+static void
+identClose(int fd, icpStateData * icpState)
 {
     icpState->ident_fd = -1;
 }
 
 /* start a TCP connection to the peer host on port 113 */
-void identStart(sock, icpState)
-     icpStateData *icpState;
+void
+identStart(int sock, icpStateData * icpState)
 {
     char *host;
     u_short port;
@@ -91,19 +90,14 @@ void identStart(sock, icpState)
 	(void *) icpState);
 }
 
-static void identRequestComplete(fd, buf, size, errflag, data)
-     int fd;
-     char *buf;
-     int size;
-     int errflag;
-     void *data;
+static void
+identRequestComplete(int fd, char *buf, int size, int errflag, void *data)
 {
     debug(30, 5, "identRequestComplete: FD %d: wrote %d bytes\n", fd, size);
 }
 
-static void identReadReply(fd, icpState)
-     int fd;
-     icpStateData *icpState;
+static void
+identReadReply(int fd, icpStateData * icpState)
 {
     LOCAL_ARRAY(char, buf, BUFSIZ);
     char *t = NULL;
@@ -1,5 +1,5 @@
 /*
- * $Id: ipcache.cc,v 1.55 1996/09/04 22:03:26 wessels Exp $
+ * $Id: ipcache.cc,v 1.56 1996/09/14 08:46:10 wessels Exp $
  *
  * DEBUG: section 14    IP Cache
  * AUTHOR: Harvest Derived
@@ -135,30 +135,30 @@ static struct {
     int ghbn_calls;		/* # calls to blocking gethostbyname() */
 } IpcacheStats;
 
-static int ipcache_testname _PARAMS((void));
-static int ipcache_compareLastRef _PARAMS((ipcache_entry **, ipcache_entry **));
-static int ipcache_reverseLastRef _PARAMS((ipcache_entry **, ipcache_entry **));
-static int ipcache_dnsHandleRead _PARAMS((int, dnsserver_t *));
-static ipcache_entry *ipcache_parsebuffer _PARAMS((char *buf, dnsserver_t *));
-static void ipcache_release _PARAMS((ipcache_entry *));
-static ipcache_entry *ipcache_GetFirst _PARAMS((void));
-static ipcache_entry *ipcache_GetNext _PARAMS((void));
-static ipcache_entry *ipcache_create _PARAMS((void));
-static void ipcache_add_to_hash _PARAMS((ipcache_entry *));
-static void ipcache_call_pending _PARAMS((ipcache_entry *));
-static void ipcache_add _PARAMS((char *, ipcache_entry *, struct hostent *, int));
-static int ipcacheHasPending _PARAMS((ipcache_entry *));
-static ipcache_entry *ipcache_get _PARAMS((char *));
-static int dummy_handler _PARAMS((int, struct hostent * hp, void *));
-static int ipcacheExpiredEntry _PARAMS((ipcache_entry *));
-static void ipcacheAddPending _PARAMS((ipcache_entry *, int fd, IPH, void *));
-static void ipcacheEnqueue _PARAMS((ipcache_entry *));
-static void *ipcacheDequeue _PARAMS((void));
-static void ipcache_dnsDispatch _PARAMS((dnsserver_t *, ipcache_entry *));
-static struct hostent *ipcacheCheckNumeric _PARAMS((char *name));
-static void ipcacheStatPrint _PARAMS((ipcache_entry *, StoreEntry *));
-static void ipcacheUnlockEntry _PARAMS((ipcache_entry *));
-static void ipcacheLockEntry _PARAMS((ipcache_entry *));
+static int ipcache_testname(void);
+static int ipcache_compareLastRef(ipcache_entry **, ipcache_entry **);
+static int ipcache_reverseLastRef(ipcache_entry **, ipcache_entry **);
+static int ipcache_dnsHandleRead(int, dnsserver_t *);
+static ipcache_entry *ipcache_parsebuffer(char *buf, dnsserver_t *);
+static void ipcache_release(ipcache_entry *);
+static ipcache_entry *ipcache_GetFirst(void);
+static ipcache_entry *ipcache_GetNext(void);
+static ipcache_entry *ipcache_create(void);
+static void ipcache_add_to_hash(ipcache_entry *);
+static void ipcache_call_pending(ipcache_entry *);
+static void ipcache_add(char *, ipcache_entry *, struct hostent *, int);
+static int ipcacheHasPending(ipcache_entry *);
+static ipcache_entry *ipcache_get(char *);
+static int dummy_handler(int, struct hostent *hp, void *);
+static int ipcacheExpiredEntry(ipcache_entry *);
+static void ipcacheAddPending(ipcache_entry *, int fd, IPH, void *);
+static void ipcacheEnqueue(ipcache_entry *);
+static void *ipcacheDequeue(void);
+static void ipcache_dnsDispatch(dnsserver_t *, ipcache_entry *);
+static struct hostent *ipcacheCheckNumeric(char *name);
+static void ipcacheStatPrint(ipcache_entry *, StoreEntry *);
+static void ipcacheUnlockEntry(ipcache_entry *);
+static void ipcacheLockEntry(ipcache_entry *);
 
 static struct hostent *static_result = NULL;
 static HashID ip_table = 0;
@@ -176,16 +176,17 @@ static char ipcache_status_char[] =
 long ipcache_low = 180;
 long ipcache_high = 200;
 
-static void ipcacheEnqueue(i)
-     ipcache_entry *i;
+static void
+ipcacheEnqueue(ipcache_entry * i)
 {
     struct ipcacheQueueData *new = xcalloc(1, sizeof(struct ipcacheQueueData));
     new->i = i;
     *ipcacheQueueTailP = new;
     ipcacheQueueTailP = &new->next;
 }
 
-static void *ipcacheDequeue()
+static void *
+ipcacheDequeue()
 {
     struct ipcacheQueueData *old = NULL;
     ipcache_entry *i = NULL;
@@ -200,7 +201,8 @@ static void *ipcacheDequeue()
     return i;
 }
 
-static int ipcache_testname()
+static int
+ipcache_testname()
 {
     wordlist *w = NULL;
     debug(14, 1, "Performing DNS Tests...\n");
@@ -215,8 +217,8 @@ static int ipcache_testname()
 }
 
 /* removes the given ipcache entry */
-static void ipcache_release(i)
-     ipcache_entry *i;
+static void
+ipcache_release(ipcache_entry * i)
 {
     hash_link *table_entry = NULL;
     int k;
@@ -260,8 +262,8 @@ static void ipcache_release(i)
 }
 
 /* return match for given name */
-static ipcache_entry *ipcache_get(name)
-     char *name;
+static ipcache_entry *
+ipcache_get(char *name)
 {
     hash_link *e;
     static ipcache_entry *i;
@@ -275,19 +277,21 @@ static ipcache_entry *ipcache_get(name)
 }
 
 /* get the first ip entry in the storage */
-static ipcache_entry *ipcache_GetFirst()
+static ipcache_entry *
+ipcache_GetFirst()
 {
     return (ipcache_entry *) hash_first(ip_table);
 }
 
 /* get the next ip entry in the storage for a given search pointer */
-static ipcache_entry *ipcache_GetNext()
+static ipcache_entry *
+ipcache_GetNext()
 {
     return (ipcache_entry *) hash_next(ip_table);
 }
 
-static int ipcache_compareLastRef(e1, e2)
-     ipcache_entry **e1, **e2;
+static int
+ipcache_compareLastRef(ipcache_entry ** e1, ipcache_entry ** e2)
 {
     if (!e1 || !e2)
 	fatal_dump(NULL);
@@ -298,8 +302,8 @@ static int ipcache_compareLastRef(e1, e2)
     return (0);
 }
 
-static int ipcache_reverseLastRef(e1, e2)
-     ipcache_entry **e1, **e2;
+static int
+ipcache_reverseLastRef(ipcache_entry ** e1, ipcache_entry ** e2)
 {
     if ((*e1)->lastref < (*e2)->lastref)
 	return (1);
@@ -308,8 +312,8 @@ static int ipcache_reverseLastRef(e1, e2)
     return (0);
 }
 
-static int ipcacheExpiredEntry(i)
-     ipcache_entry *i;
+static int
+ipcacheExpiredEntry(ipcache_entry * i)
 {
     if (i->status == IP_PENDING)
 	return 0;
@@ -323,7 +327,8 @@ static int ipcacheExpiredEntry(i)
 }
 
 /* finds the LRU and deletes */
-int ipcache_purgelru()
+int
+ipcache_purgelru()
 {
     ipcache_entry *i = NULL;
     int local_ip_notpending_count = 0;
@@ -377,7 +382,8 @@ int ipcache_purgelru()
 
 
 /* create blank ipcache_entry */
-static ipcache_entry *ipcache_create()
+static ipcache_entry *
+ipcache_create()
 {
     static ipcache_entry *new;
 
@@ -395,8 +401,8 @@ static ipcache_entry *ipcache_create()
 
 }
 
-static void ipcache_add_to_hash(i)
-     ipcache_entry *i;
+static void
+ipcache_add_to_hash(ipcache_entry * i)
 {
     if (hash_join(ip_table, (hash_link *) i)) {
 	debug(14, 1, "ipcache_add_to_hash: Cannot add %s (%p) to hash table %d.\n",
@@ -406,11 +412,8 @@ static void ipcache_add_to_hash(i)
 }
 
 
-static void ipcache_add(name, i, hp, cached)
-     char *name;
-     ipcache_entry *i;
-     struct hostent *hp;
-     int cached;
+static void
+ipcache_add(char *name, ipcache_entry * i, struct hostent *hp, int cached)
 {
     int addr_count;
     int alias_count;
@@ -464,8 +467,8 @@ static void ipcache_add(name, i, hp, cached)
 }
 
 /* walks down the pending list, calling handlers */
-static void ipcache_call_pending(i)
-     ipcache_entry *i;
+static void
+ipcache_call_pending(ipcache_entry * i)
 {
     struct _ip_pending *p = NULL;
     int nhandler = 0;
@@ -491,9 +494,8 @@ static void ipcache_call_pending(i)
     ipcacheUnlockEntry(i);
 }
 
-static ipcache_entry *ipcache_parsebuffer(inbuf, dnsData)
-     char *inbuf;
-     dnsserver_t *dnsData;
+static ipcache_entry *
+ipcache_parsebuffer(char *inbuf, dnsserver_t * dnsData)
 {
     char *buf = xstrdup(inbuf);
     char *token;
@@ -575,9 +577,8 @@ static ipcache_entry *ipcache_parsebuffer(inbuf, dnsData)
     return &i;
 }
 
-static int ipcache_dnsHandleRead(fd, dnsData)
-     int fd;
-     dnsserver_t *dnsData;
+static int
+ipcache_dnsHandleRead(int fd, dnsserver_t * dnsData)
 {
     int len;
     int svc_time;
@@ -645,11 +646,8 @@ static int ipcache_dnsHandleRead(fd, dnsData)
     return 0;
 }
 
-static void ipcacheAddPending(i, fd, handler, handlerData)
-     ipcache_entry *i;
-     int fd;
-     IPH handler;
-     void *handlerData;
+static void
+ipcacheAddPending(ipcache_entry * i, int fd, IPH handler, void *handlerData)
 {
     struct _ip_pending *pending = xcalloc(1, sizeof(struct _ip_pending));
     struct _ip_pending **I = NULL;
@@ -661,11 +659,8 @@ static void ipcacheAddPending(i, fd, handler, handlerData)
     *I = pending;
 }
 
-void ipcache_nbgethostbyname(name, fd, handler, handlerData)
-     char *name;
-     int fd;
-     IPH handler;
-     void *handlerData;
+void
+ipcache_nbgethostbyname(char *name, int fd, IPH handler, void *handlerData)
 {
     ipcache_entry *i = NULL;
     dnsserver_t *dnsData = NULL;
@@ -728,9 +723,8 @@ void ipcache_nbgethostbyname(name, fd, handler, handlerData)
 	ipcacheEnqueue(i);
 }
 
-static void ipcache_dnsDispatch(dns, i)
-     dnsserver_t *dns;
-     ipcache_entry *i;
+static void
+ipcache_dnsDispatch(dnsserver_t * dns, ipcache_entry * i)
 {
     char *buf = NULL;
     if (!ipcacheHasPending(i)) {
@@ -765,7 +759,8 @@ static void ipcache_dnsDispatch(dns, i)
 
 
 /* initialize the ipcache */
-void ipcache_init()
+void
+ipcache_init()
 {
     debug(14, 3, "Initializing IP Cache...\n");
 
@@ -796,9 +791,8 @@ void ipcache_init()
 
 /* clean up the pending entries in dnsserver */
 /* return 1 if we found the host, 0 otherwise */
-int ipcache_unregister(name, fd)
-     char *name;
-     int fd;
+int
+ipcache_unregister(char *name, int fd)
 {
     ipcache_entry *i = NULL;
     struct _ip_pending *p = NULL;
@@ -820,9 +814,8 @@ int ipcache_unregister(name, fd)
     return n;
 }
 
-struct hostent *ipcache_gethostbyname(name, flags)
-     char *name;
-     int flags;
+struct hostent *
+ipcache_gethostbyname(char *name, int flags)
 {
     ipcache_entry *i = NULL;
     struct hostent *hp = NULL;
@@ -878,9 +871,8 @@ struct hostent *ipcache_gethostbyname(name, flags)
     return NULL;
 }
 
-static void ipcacheStatPrint(i, sentry)
-     ipcache_entry *i;
-     StoreEntry *sentry;
+static void
+ipcacheStatPrint(ipcache_entry * i, StoreEntry * sentry)
 {
     int k;
     storeAppendPrintf(sentry, " {%-32.32s  %c %6d %6d %d",
@@ -904,8 +896,8 @@ static void ipcacheStatPrint(i, sentry)
 }
 
 /* process objects list */
-void stat_ipcache_get(sentry)
-     StoreEntry *sentry;
+void
+stat_ipcache_get(StoreEntry * sentry)
 {
     int k;
     int N;
@@ -954,16 +946,14 @@ void stat_ipcache_get(sentry)
     storeAppendPrintf(sentry, close_bracket);
 }
 
-static int dummy_handler(u1, u2, u3)
-     int u1;
-     struct hostent *u2;
-     void *u3;
+static int
+dummy_handler(int u1, struct hostent *u2, void *u3)
 {
     return 0;
 }
 
-static int ipcacheHasPending(i)
-     ipcache_entry *i;
+static int
+ipcacheHasPending(ipcache_entry * i)
 {
     struct _ip_pending *p = NULL;
     if (i->status != IP_PENDING)
@@ -974,8 +964,8 @@ static int ipcacheHasPending(i)
     return 0;
 }
 
-void ipcacheReleaseInvalid(name)
-     char *name;
+void
+ipcacheReleaseInvalid(char *name)
 {
     ipcache_entry *i;
     if ((i = ipcache_get(name)) == NULL)
@@ -985,8 +975,8 @@ void ipcacheReleaseInvalid(name)
     ipcache_release(i);
 }
 
-void ipcacheInvalidate(name)
-     char *name;
+void
+ipcacheInvalidate(char *name)
 {
     ipcache_entry *i;
     if ((i = ipcache_get(name)) == NULL)
@@ -997,8 +987,8 @@ void ipcacheInvalidate(name)
      * FMR */
 }
 
-static struct hostent *ipcacheCheckNumeric(name)
-     char *name;
+static struct hostent *
+ipcacheCheckNumeric(char *name)
 {
     unsigned int ip;
     /* check if it's already a IP address in text form. */
@@ -1009,7 +999,8 @@ static struct hostent *ipcacheCheckNumeric(name)
     return static_result;
 }
 
-int ipcacheQueueDrain()
+int
+ipcacheQueueDrain()
 {
     ipcache_entry *i;
     dnsserver_t *dnsData;
@@ -1020,14 +1011,14 @@ int ipcacheQueueDrain()
     return 1;
 }
 
-static void ipcacheLockEntry(i)
-     ipcache_entry *i;
+static void
+ipcacheLockEntry(ipcache_entry * i)
 {
     i->locks++;
 }
 
-static void ipcacheUnlockEntry(i)
-     ipcache_entry *i;
+static void
+ipcacheUnlockEntry(ipcache_entry * i)
 {
     i->locks--;
     if (ipcacheExpiredEntry(i))
@@ -1,5 +1,5 @@
 /*
- * $Id: main.cc,v 1.72 1996/09/13 23:16:39 wessels Exp $
+ * $Id: main.cc,v 1.73 1996/09/14 08:46:12 wessels Exp $
  *
  * DEBUG: section 1     Startup and Main Loop
  * AUTHOR: Harvest Derived
@@ -130,7 +130,7 @@ struct in_addr local_addr;
 char *dash_str = "-";
 
 /* for error reporting from xmalloc and friends */
-extern void (*failure_notify) _PARAMS((char *));
+extern void (*failure_notify) (char *);
 
 static int rotate_pending = 0;	/* set by SIGUSR1 handler */
 static int httpPortNumOverride = 1;
@@ -145,16 +145,17 @@ static time_t next_dirclean;
 static time_t next_announce;
 static time_t next_ip_purge;
 
-static void rotate_logs _PARAMS((int));
-static void reconfigure _PARAMS((int));
-static void mainInitialize _PARAMS((void));
-static void mainReinitialize _PARAMS((void));
-static time_t mainMaintenance _PARAMS((void));
-static void usage _PARAMS((void));
-static void mainParseOptions _PARAMS((int, char **));
-static void sendSignal _PARAMS((void));
-
-static void usage()
+static void rotate_logs(int);
+static void reconfigure(int);
+static void mainInitialize(void);
+static void mainReinitialize(void);
+static time_t mainMaintenance(void);
+static void usage(void);
+static void mainParseOptions(int, char **);
+static void sendSignal(void);
+
+static void
+usage()
 {
     fprintf(stderr, "\
 Usage: %s [-hsvzCDFRUVY] [-f config-file] [-[au] port] [-k signal]\n\
@@ -180,9 +181,8 @@ Usage: %s [-hsvzCDFRUVY] [-f config-file] [-[au] port] [-k signal]\n\
     exit(1);
 }
 
-static void mainParseOptions(argc, argv)
-     int argc;
-     char *argv[];
+static void
+mainParseOptions(int argc, char *argv[])
 {
     extern char *optarg;
     int c;
@@ -275,8 +275,8 @@ static void mainParseOptions(argc, argv)
     }
 }
 
-static void rotate_logs(sig)
-     int sig;
+static void
+rotate_logs(int sig)
 {
     debug(21, 1, "rotate_logs: SIGUSR1 received.\n");
     rotate_pending = 1;
@@ -285,8 +285,8 @@ static void rotate_logs(sig)
 #endif
 }
 
-static void reconfigure(sig)
-     int sig;
+static void
+reconfigure(int sig)
 {
     debug(21, 1, "reconfigure: SIGHUP received\n");
     debug(21, 1, "Waiting %d seconds for active connections to finish\n",
@@ -297,8 +297,8 @@ static void reconfigure(sig)
 #endif
 }
 
-void shut_down(sig)
-     int sig;
+void
+shut_down(int sig)
 {
     debug(21, 1, "Preparing for shutdown after %d connections\n",
 	ntcpconn + nudpconn);
@@ -311,7 +311,8 @@ void shut_down(sig)
 #endif
 }
 
-void serverConnectionsOpen()
+void
+serverConnectionsOpen()
 {
     struct in_addr addr;
     u_short port;
@@ -374,7 +375,8 @@ void serverConnectionsOpen()
     }
 }
 
-void serverConnectionsClose()
+void
+serverConnectionsClose()
 {
     /* NOTE, this function will be called repeatedly while shutdown
      * is pending */
@@ -408,7 +410,8 @@ void serverConnectionsClose()
     }
 }
 
-static void mainReinitialize()
+static void
+mainReinitialize()
 {
     debug(1, 0, "Restarting Squid Cache (version %s)...\n", version_string);
     /* Already called serverConnectionsClose and ipcacheShutdownServers() */
@@ -425,7 +428,8 @@ static void mainReinitialize()
     debug(1, 0, "Ready to serve requests.\n");
 }
 
-static void mainInitialize()
+static void
+mainInitialize()
 {
     static int first_time = 1;
     if (opt_catch_signals) {
@@ -520,7 +524,8 @@ static void mainInitialize()
     first_time = 0;
 }
 
-static time_t mainMaintenance()
+static time_t
+mainMaintenance()
 {
     time_t next;
     int n;
@@ -556,9 +561,8 @@ static time_t mainMaintenance()
     return next - squid_curtime;
 }
 
-int main(argc, argv)
-     int argc;
-     char **argv;
+int
+main(int argc, char **argv)
 {
     int errcount = 0;
     int n;			/* # of GC'd objects */
@@ -673,7 +677,8 @@ int main(argc, argv)
     return 0;
 }
 
-static void sendSignal()
+static void
+sendSignal()
 {
     int pid;
     debug_log = stderr;
@@ -1,5 +1,5 @@
 /*
- * $Id: mime.cc,v 1.15 1996/09/04 22:03:27 wessels Exp $
+ * $Id: mime.cc,v 1.16 1996/09/14 08:46:13 wessels Exp $
  *
  * DEBUG: section 25    MIME Parsing
  * AUTHOR: Harvest Derived
@@ -108,7 +108,8 @@
 
 #define GET_HDR_SZ 1024
 
-char *mime_get_header(char *mime, char *name)
+char *
+mime_get_header(char *mime, char *name)
 {
     LOCAL_ARRAY(char, header, GET_HDR_SZ);
     char *p = NULL;
@@ -150,7 +151,8 @@ char *mime_get_header(char *mime, char *name)
 
 /* need to take the lowest, non-zero pointer to the end of the headers.
  * The headers end at the first empty line */
-char *mime_headers_end(char *mime)
+char *
+mime_headers_end(char *mime)
 {
     char *p1, *p2;
     char *end = NULL;
@@ -168,7 +170,8 @@ char *mime_headers_end(char *mime)
     return end;
 }
 
-int mime_headers_size(char *mime)
+int
+mime_headers_size(char *mime)
 {
     char *end;
 
@@ -180,8 +183,8 @@ int mime_headers_size(char *mime)
 	return 0;
 }
 
-ext_table_entry *mime_ext_to_type(extension)
-     char *extension;
+ext_table_entry *
+mime_ext_to_type(char *extension)
 {
     int i;
     int low;
@@ -220,12 +223,8 @@ ext_table_entry *mime_ext_to_type(extension)
  *  Returns the MIME header in the provided 'result' buffer, and
  *  returns non-zero on error, or 0 on success.
  */
-int mk_mime_hdr(result, ttl, size, lmt, type)
-     char *result;
-     char *type;
-     int size;
-     time_t ttl;
-     time_t lmt;
+int
+mk_mime_hdr(char *result, char *type, int size, time_t ttl, time_t lmt)
 {
     time_t expiretime;
     time_t t;
@@ -1,5 +1,5 @@
 /*
- * $Id: neighbors.cc,v 1.50 1996/09/13 23:20:49 wessels Exp $
+ * $Id: neighbors.cc,v 1.51 1996/09/14 08:46:15 wessels Exp $
  *
  * DEBUG: section 15    Neighbor Routines
  * AUTHOR: Harvest Derived
@@ -105,9 +105,9 @@
 
 #include "squid.h"
 
-static int edgeWouldBePinged _PARAMS((edge *, request_t *));
-static void neighborRemove _PARAMS((edge *));
-static edge *whichEdge _PARAMS((icp_common_t *, struct sockaddr_in *));
+static int edgeWouldBePinged(edge *, request_t *);
+static void neighborRemove(edge *);
+static edge *whichEdge(icp_common_t *, struct sockaddr_in *);
 
 static neighbors *friends = NULL;
 static struct neighbor_cf *Neighbor_cf = NULL;
@@ -134,9 +134,8 @@ char *hier_strings[] =
 };
 
 
-static edge *whichEdge(header, from)
-     icp_common_t *header;
-     struct sockaddr_in *from;
+static edge *
+whichEdge(icp_common_t * header, struct sockaddr_in *from)
 {
     int j;
     u_short port;
@@ -158,11 +157,8 @@ static edge *whichEdge(header, from)
     return (NULL);
 }
 
-void hierarchyNote(request, code, timeout, cache_host)
-     request_t *request;
-     hier_code code;
-     int timeout;
-     char *cache_host;
+void
+hierarchyNote(request_t * request, hier_code code, int timeout, char *cache_host)
 {
     if (request) {
 	request->hierarchy.code = code;
@@ -171,9 +167,8 @@ void hierarchyNote(request, code, timeout, cache_host)
     }
 }
 
-static int edgeWouldBePinged(e, request)
-     edge *e;
-     request_t *request;
+static int
+edgeWouldBePinged(edge * e, request_t * request)
 {
     dom_list *d = NULL;
     int do_ping = 1;
@@ -198,9 +193,8 @@ static int edgeWouldBePinged(e, request)
     return do_ping;
 }
 
-edge *getSingleParent(request, n)
-     request_t *request;
-     int *n;
+edge *
+getSingleParent(request_t * request, int *n)
 {
     edge *p = NULL;
     edge *e = NULL;
@@ -237,8 +231,8 @@ edge *getSingleParent(request, n)
     return NULL;
 }
 
-edge *getFirstUpParent(request)
-     request_t *request;
+edge *
+getFirstUpParent(request_t * request)
 {
     edge *e = NULL;
     if (friends->n_parent < 1)
@@ -254,18 +248,20 @@ edge *getFirstUpParent(request)
     return NULL;
 }
 
-edge *getNextEdge(edge * e)
+edge *
+getNextEdge(edge * e)
 {
     return e->next;
 }
 
-edge *getFirstEdge()
+edge *
+getFirstEdge(void)
 {
     return friends->edges_head;
 }
 
-static void neighborRemove(target)
-     edge *target;
+static void
+neighborRemove(edge * target)
 {
     edge *e = NULL;
     edge **E = NULL;
@@ -285,7 +281,8 @@ static void neighborRemove(target)
     }
 }
 
-void neighborsDestroy()
+void
+neighborsDestroy()
 {
     edge *e = NULL;
     edge *next = NULL;
@@ -302,8 +299,8 @@ void neighborsDestroy()
     friends = NULL;
 }
 
-void neighbors_open(fd)
-     int fd;
+void
+neighbors_open(int fd)
 {
     int j;
     struct sockaddr_in name;
@@ -398,8 +395,8 @@ void neighbors_open(fd)
 }
 
 
-int neighborsUdpPing(proto)
-     protodispatch_data *proto;
+int
+neighborsUdpPing(protodispatch_data * proto)
 {
     char *host = proto->request->host;
     char *url = proto->url;
@@ -536,14 +533,8 @@ int neighborsUdpPing(proto)
  * 
  * If a hit process is already started, then sobeit
  */
-void neighborsUdpAck(fd, url, header, from, entry, data, data_sz)
-     int fd;
-     char *url;
-     icp_common_t *header;
-     struct sockaddr_in *from;
-     StoreEntry *entry;
-     char *data;
-     int data_sz;
+void
+neighborsUdpAck(int fd, char *url, icp_common_t * header, struct sockaddr_in *from, StoreEntry * entry, char *data, int data_sz)
 {
     edge *e = NULL;
     MemObject *mem = entry->mem_obj;
@@ -612,8 +603,8 @@ void neighborsUdpAck(fd, url, header, from, entry, data, data_sz)
 	} else if (entry->object_len != 0) {
 	    debug(15, 1, "Too late UDP_HIT_OBJ '%s'?\n", entry->url);
 	} else {
-            if (e->options & NEIGHBOR_PROXY_ONLY)
-                storeReleaseRequest(entry);
+	    if (e->options & NEIGHBOR_PROXY_ONLY)
+		storeReleaseRequest(entry);
 	    protoCancelTimeout(0, entry);
 	    entry->ping_status = PING_DONE;
 	    httpState = xcalloc(1, sizeof(HttpStateData));
@@ -695,13 +686,8 @@ void neighborsUdpAck(fd, url, header, from, entry, data, data_sz)
     }
 }
 
-void neighbors_cf_add(host, type, http_port, icp_port, options, weight)
-     char *host;
-     char *type;
-     int http_port;
-     int icp_port;
-     int options;
-     int weight;
+void
+neighbors_cf_add(char *host, char *type, int http_port, int icp_port, int options, int weight)
 {
     struct neighbor_cf *t, *u;
 
@@ -722,9 +708,8 @@ void neighbors_cf_add(host, type, http_port, icp_port, options, weight)
     }
 }
 
-void neighbors_cf_domain(host, domain)
-     char *host;
-     char *domain;
+void
+neighbors_cf_domain(char *host, char *domain)
 {
     struct neighbor_cf *t = NULL;
     dom_list *l = NULL;
@@ -751,9 +736,8 @@ void neighbors_cf_domain(host, domain)
     *L = l;
 }
 
-void neighbors_cf_acl(host, aclname)
-     char *host;
-     char *aclname;
+void
+neighbors_cf_acl(char *host, char *aclname)
 {
     struct neighbor_cf *t = NULL;
     struct _acl_list *L = NULL;
@@ -796,7 +780,8 @@ void neighbors_cf_acl(host, aclname)
     *Tail = L;
 }
 
-void neighbors_init()
+void
+neighbors_init()
 {
     struct neighbor_cf *t = NULL;
     struct neighbor_cf *next = NULL;
@@ -850,8 +835,8 @@ void neighbors_init()
     any_addr.s_addr = inet_addr("0.0.0.0");
 }
 
-edge *neighborFindByName(name)
-     char *name;
+edge *
+neighborFindByName(char *name)
 {
     edge *e = NULL;
     for (e = friends->edges_head; e; e = e->next) {
@@ -1,5 +1,5 @@
 /*
- * $Id: recv-announce.cc,v 1.6 1996/07/19 17:35:36 wessels Exp $
+ * $Id: recv-announce.cc,v 1.7 1996/09/14 08:46:20 wessels Exp $
  *
  * DEBUG: section 0     Announement Server
  * AUTHOR: Harvest Derived
@@ -117,7 +117,7 @@
 
 #define RECV_BUF_SIZE 8192
 
-extern void xmemcpy _PARAMS((void *from, void *to, int len));
+extern void xmemcpy(void *from, void *to, int len);
 
 /*
  * This program must be run from inetd.  First add something like this
@@ -140,7 +140,8 @@ extern void xmemcpy _PARAMS((void *from, void *to, int len));
  * usage: recv-announce logfile
  */
 
-void sig_handle()
+void
+sig_handle()
 {
     fflush(stdout);
     close(2);
@@ -150,9 +151,8 @@ void sig_handle()
 }
 
 
-int main(argc, argv)
-     int argc;
-     char *argv[];
+int
+main(int argc, char *argv[])
 {
     char buf[RECV_BUF_SIZE];
     struct sockaddr_in R;
@@ -1,5 +1,5 @@
 /*
- * $Id: redirect.cc,v 1.13 1996/08/30 22:44:11 wessels Exp $
+ * $Id: redirect.cc,v 1.14 1996/09/14 08:46:21 wessels Exp $
  *
  * DEBUG: section 29    Redirector
  * AUTHOR: Duane Wessels
@@ -70,12 +70,12 @@ struct redirectQueueData {
     redirectStateData *redirectState;
 };
 
-static redirector_t *GetFirstAvailable _PARAMS((void));
-static int redirectCreateRedirector _PARAMS((char *command));
-static int redirectHandleRead _PARAMS((int, redirector_t *));
-static redirectStateData *Dequeue _PARAMS(());
-static void Enqueue _PARAMS((redirectStateData *));
-static void redirectDispatch _PARAMS((redirector_t *, redirectStateData *));
+static redirector_t *GetFirstAvailable(void);
+static int redirectCreateRedirector(char *command);
+static int redirectHandleRead(int, redirector_t *);
+static redirectStateData *Dequeue();
+static void Enqueue(redirectStateData *);
+static void redirectDispatch(redirector_t *, redirectStateData *);
 
 
 static redirector_t **redirect_child_table = NULL;
@@ -84,8 +84,8 @@ static int NRedirectorsOpen = 0;
 static struct redirectQueueData *redirectQueueHead = NULL;
 static struct redirectQueueData **redirectQueueTailP = &redirectQueueHead;
 
-static int redirectCreateRedirector(command)
-     char *command;
+static int
+redirectCreateRedirector(char *command)
 {
     int pid;
     u_short port;
@@ -155,9 +155,8 @@ static int redirectCreateRedirector(command)
     return 0;
 }
 
-static int redirectHandleRead(fd, redirector)
-     int fd;
-     redirector_t *redirector;
+static int
+redirectHandleRead(int fd, redirector_t * redirector)
 {
     int len;
     redirectStateData *r = redirector->redirectState;
@@ -216,8 +215,8 @@ static int redirectHandleRead(fd, redirector)
     return 0;
 }
 
-static void Enqueue(r)
-     redirectStateData *r;
+static void
+Enqueue(redirectStateData * r)
 {
     struct redirectQueueData *new = xcalloc(1, sizeof(struct redirectQueueData));
     new->redirectState = r;
@@ -226,7 +225,8 @@ static void Enqueue(r)
     RedirectStats.queue_size++;
 }
 
-static redirectStateData *Dequeue()
+static redirectStateData *
+Dequeue()
 {
     struct redirectQueueData *old = NULL;
     redirectStateData *r = NULL;
@@ -242,7 +242,8 @@ static redirectStateData *Dequeue()
     return r;
 }
 
-static redirector_t *GetFirstAvailable()
+static redirector_t *
+GetFirstAvailable()
 {
     int k;
     redirector_t *redirect = NULL;
@@ -255,9 +256,8 @@ static redirector_t *GetFirstAvailable()
 }
 
 
-static void redirectDispatch(redirect, r)
-     redirector_t *redirect;
-     redirectStateData *r;
+static void
+redirectDispatch(redirector_t * redirect, redirectStateData * r)
 {
     char *buf = NULL;
     char *fqdn = NULL;
@@ -298,11 +298,8 @@ static void redirectDispatch(redirect, r)
 /**** PUBLIC FUNCTIONS ****/
 
 
-void redirectStart(cfd, icpState, handler, data)
-     int cfd;
-     icpStateData *icpState;
-     RH handler;
-     void *data;
+void
+redirectStart(int cfd, icpStateData * icpState, RH handler, void *data)
 {
     redirectStateData *r = NULL;
     redirector_t *redirector = NULL;
@@ -332,7 +329,8 @@ void redirectStart(cfd, icpState, handler, data)
 	Enqueue(r);
 }
 
-void redirectOpenServers()
+void
+redirectOpenServers()
 {
     char *prg = Config.Program.redirect;
     int k;
@@ -384,7 +382,8 @@ void redirectOpenServers()
     }
 }
 
-void redirectShutdownServers()
+void
+redirectShutdownServers()
 {
     redirector_t *redirect = NULL;
     redirectStateData *r = NULL;
@@ -412,9 +411,8 @@ void redirectShutdownServers()
 }
 
 
-int redirectUnregister(url, fd)
-     char *url;
-     int fd;
+int
+redirectUnregister(char *url, int fd)
 {
     redirector_t *redirect = NULL;
     redirectStateData *r = NULL;
@@ -451,8 +449,8 @@ int redirectUnregister(url, fd)
     return n;
 }
 
-void redirectStats(sentry)
-     StoreEntry *sentry;
+void
+redirectStats(StoreEntry * sentry)
 {
     int k;
     storeAppendPrintf(sentry, open_bracket);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: send-announce.cc,v 1.16 1996/07/25 07:10:40 wessels Exp $
+ * $Id: send-announce.cc,v 1.17 1996/09/14 08:46:22 wessels Exp $
  *
  * DEBUG: section 27    Cache Announcer
  * AUTHOR: Duane Wessels
@@ -31,7 +31,8 @@
 
 #include "squid.h"
 
-void send_announce()
+void
+send_announce()
 {
     LOCAL_ARRAY(char, tbuf, 256);
     LOCAL_ARRAY(char, sndbuf, BUFSIZ);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: squid.h,v 1.44 1996/09/03 19:24:04 wessels Exp $
+ * $Id: squid.h,v 1.45 1996/09/14 08:46:23 wessels Exp $
  *
  * AUTHOR: Duane Wessels
  *
@@ -217,7 +217,7 @@ typedef unsigned long u_num32;
 #include "ansihelp.h"
 
 typedef void (*SIH) _PARAMS((int, void *));	/* swap in */
-typedef int (*QS) _PARAMS((const void *, const void *));
+typedef int (*QS) (const void *, const void *);
 
 #include "cache_cf.h"
 #include "comm.h"
@@ -255,8 +255,8 @@ typedef int (*QS) _PARAMS((const void *, const void *));
 #include "tempnam.h"
 #endif
 
-extern void serverConnectionsClose _PARAMS((void));
-extern void shut_down _PARAMS((int));
+extern void serverConnectionsClose(void);
+extern void shut_down(int);
 
 
 extern time_t squid_starttime;	/* main.c */
@@ -287,14 +287,14 @@ extern struct in_addr no_addr;	/* comm.c */
 
 #define  CONNECT_PORT        443
 
-extern int objcacheStart _PARAMS((int, char *, StoreEntry *));
-extern void send_announce _PARAMS((void));
-extern int sslStart _PARAMS((int fd, char *, request_t *, char *, int *sz));
-extern char *storeToString _PARAMS((StoreEntry *));
-extern void ttlSet _PARAMS((StoreEntry *));
-extern void ttlFreeList _PARAMS((void));
-extern void ttlAddToList _PARAMS((char *, int, int, time_t, int, time_t));
-extern void ttlAddToForceList _PARAMS((char *, time_t, time_t));
-extern int waisStart _PARAMS((int, char *, method_t, char *, StoreEntry *));
-extern void storeDirClean _PARAMS((void));
+extern int objcacheStart(int, char *, StoreEntry *);
+extern void send_announce(void);
+extern int sslStart(int fd, char *, request_t *, char *, int *sz);
+extern char *storeToString(StoreEntry *);
+extern void ttlSet(StoreEntry *);
+extern void ttlFreeList(void);
+extern void ttlAddToList(char *, int, int, time_t, int, time_t);
+extern void ttlAddToForceList(char *, time_t, time_t);
+extern int waisStart(int, char *, method_t, char *, StoreEntry *);
+extern void storeDirClean(void);
 extern char *dash_str;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ssl.cc,v 1.13 1996/08/31 06:40:20 wessels Exp $
+ * $Id: ssl.cc,v 1.14 1996/09/14 08:46:24 wessels Exp $
  *
  * DEBUG: section 26    Secure Sockets Layer Proxy
  * AUTHOR: Duane Wessels
@@ -49,22 +49,22 @@ typedef struct {
 
 static char conn_established[] = "HTTP/1.0 200 Connection established\r\n\r\n";
 
-static void sslLifetimeExpire _PARAMS((int fd, SslStateData * sslState));
-static void sslReadTimeout _PARAMS((int fd, SslStateData * sslState));
-static void sslReadServer _PARAMS((int fd, SslStateData * sslState));
-static void sslReadClient _PARAMS((int fd, SslStateData * sslState));
-static void sslWriteServer _PARAMS((int fd, SslStateData * sslState));
-static void sslWriteClient _PARAMS((int fd, SslStateData * sslState));
-static void sslConnected _PARAMS((int fd, SslStateData * sslState));
-static void sslProxyConnected _PARAMS((int fd, SslStateData * sslState));
-static int sslConnect _PARAMS((int fd, struct hostent *, SslStateData *));
-static void sslConnInProgress _PARAMS((int fd, SslStateData * sslState));
-static void sslErrorComplete _PARAMS((int, char *, int, int, void *));
-static void sslClose _PARAMS((SslStateData * sslState));
-static int sslClientClosed _PARAMS((int fd, SslStateData * sslState));
+static void sslLifetimeExpire(int fd, SslStateData * sslState);
+static void sslReadTimeout(int fd, SslStateData * sslState);
+static void sslReadServer(int fd, SslStateData * sslState);
+static void sslReadClient(int fd, SslStateData * sslState);
+static void sslWriteServer(int fd, SslStateData * sslState);
+static void sslWriteClient(int fd, SslStateData * sslState);
+static void sslConnected(int fd, SslStateData * sslState);
+static void sslProxyConnected(int fd, SslStateData * sslState);
+static int sslConnect(int fd, struct hostent *, SslStateData *);
+static void sslConnInProgress(int fd, SslStateData * sslState);
+static void sslErrorComplete(int, char *, int, int, void *);
+static void sslClose(SslStateData * sslState);
+static int sslClientClosed(int fd, SslStateData * sslState);
 
-static void sslClose(sslState)
-     SslStateData *sslState;
+static void
+sslClose(SslStateData * sslState)
 {
     if (sslState->client.fd > -1) {
 	/* remove the "unexpected" client close handler */
@@ -81,9 +81,8 @@ static void sslClose(sslState)
 
 /* This is called only if the client connect closes unexpectedly,
  * ie from icpDetectClientClose() */
-static int sslClientClosed(fd, sslState)
-     int fd;
-     SslStateData *sslState;
+static int
+sslClientClosed(int fd, SslStateData * sslState)
 {
     debug(26, 3, "sslClientClosed: FD %d\n", fd);
     /* we have been called from comm_close for the client side, so
@@ -96,9 +95,8 @@ static int sslClientClosed(fd, sslState)
     return 0;
 }
 
-static int sslStateFree(fd, sslState)
-     int fd;
-     SslStateData *sslState;
+static int
+sslStateFree(int fd, SslStateData * sslState)
 {
     debug(26, 3, "sslStateFree: FD %d, sslState=%p\n", fd, sslState);
     if (sslState == NULL)
@@ -119,19 +117,17 @@ static int sslStateFree(fd, sslState)
 }
 
 /* This will be called when the server lifetime is expired. */
-static void sslLifetimeExpire(fd, sslState)
-     int fd;
-     SslStateData *sslState;
+static void
+sslLifetimeExpire(int fd, SslStateData * sslState)
 {
     debug(26, 4, "sslLifeTimeExpire: FD %d: URL '%s'>\n",
 	fd, sslState->url);
     sslClose(sslState);
 }
 
 /* Read from server side and queue it for writing to the client */
-static void sslReadServer(fd, sslState)
-     int fd;
-     SslStateData *sslState;
+static void
+sslReadServer(int fd, SslStateData * sslState)
 {
     int len;
     len = read(sslState->server.fd, sslState->server.buf, SQUID_TCP_SO_RCVBUF);
@@ -168,9 +164,8 @@ static void sslReadServer(fd, sslState)
 }
 
 /* Read from client side and queue it for writing to the server */
-static void sslReadClient(fd, sslState)
-     int fd;
-     SslStateData *sslState;
+static void
+sslReadClient(int fd, SslStateData * sslState)
 {
     int len;
     len = read(sslState->client.fd, sslState->client.buf, SQUID_TCP_SO_RCVBUF);
@@ -203,9 +198,8 @@ static void sslReadClient(fd, sslState)
 }
 
 /* Writes data from the client buffer to the server side */
-static void sslWriteServer(fd, sslState)
-     int fd;
-     SslStateData *sslState;
+static void
+sslWriteServer(int fd, SslStateData * sslState)
 {
     int len;
     len = write(sslState->server.fd,
@@ -239,9 +233,8 @@ static void sslWriteServer(fd, sslState)
 }
 
 /* Writes data from the server buffer to the client side */
-static void sslWriteClient(fd, sslState)
-     int fd;
-     SslStateData *sslState;
+static void
+sslWriteClient(int fd, SslStateData * sslState)
 {
     int len;
     debug(26, 5, "sslWriteClient FD %d len=%d offset=%d\n",
@@ -275,17 +268,15 @@ static void sslWriteClient(fd, sslState)
     }
 }
 
-static void sslReadTimeout(fd, sslState)
-     int fd;
-     SslStateData *sslState;
+static void
+sslReadTimeout(int fd, SslStateData * sslState)
 {
     debug(26, 3, "sslReadTimeout: FD %d\n", fd);
     sslClose(sslState);
 }
 
-static void sslConnected(fd, sslState)
-     int fd;
-     SslStateData *sslState;
+static void
+sslConnected(int fd, SslStateData * sslState)
 {
     debug(26, 3, "sslConnected: FD %d sslState=%p\n", fd, sslState);
     strcpy(sslState->server.buf, conn_established);
@@ -302,21 +293,16 @@ static void sslConnected(fd, sslState)
 	(void *) sslState);
 }
 
-static void sslErrorComplete(fd, buf, size, errflag, sslState)
-     int fd;
-     char *buf;
-     int size;
-     int errflag;
-     void *sslState;
+static void
+sslErrorComplete(int fd, char *buf, int size, int errflag, void *sslState)
 {
     safe_free(buf);
     sslClose(sslState);
 }
 
 
-static void sslConnInProgress(fd, sslState)
-     int fd;
-     SslStateData *sslState;
+static void
+sslConnInProgress(int fd, SslStateData * sslState)
 {
     char *buf = NULL;
     debug(26, 5, "sslConnInProgress: FD %d sslState=%p\n", fd, sslState);
@@ -360,10 +346,8 @@ static void sslConnInProgress(fd, sslState)
     return;
 }
 
-static int sslConnect(fd, hp, sslState)
-     int fd;
-     struct hostent *hp;
-     SslStateData *sslState;
+static int
+sslConnect(int fd, struct hostent *hp, SslStateData * sslState)
 {
     request_t *request = sslState->request;
     int status;
@@ -437,12 +421,8 @@ static int sslConnect(fd, hp, sslState)
     return COMM_OK;
 }
 
-int sslStart(fd, url, request, mime_hdr, size_ptr)
-     int fd;
-     char *url;
-     request_t *request;
-     char *mime_hdr;
-     int *size_ptr;
+int
+sslStart(int fd, char *url, request_t * request, char *mime_hdr, int *size_ptr)
 {
     /* Create state structure. */
     SslStateData *sslState = NULL;
@@ -506,9 +486,8 @@ int sslStart(fd, url, request, mime_hdr, size_ptr)
     return COMM_OK;
 }
 
-static void sslProxyConnected(fd, sslState)
-     int fd;
-     SslStateData *sslState;
+static void
+sslProxyConnected(int fd, SslStateData * sslState)
 {
     debug(26, 3, "sslProxyConnected: FD %d sslState=%p\n", fd, sslState);
     sprintf(sslState->client.buf, "CONNECT %s HTTP/1.0\r\n\r\n", sslState->url);
@@ -1,5 +1,5 @@
 /*
- * $Id: stat.cc,v 1.66 1996/09/13 23:16:42 wessels Exp $
+ * $Id: stat.cc,v 1.67 1996/09/14 08:46:26 wessels Exp $
  *
  * DEBUG: section 18    Cache Manager Statistics
  * AUTHOR: Harvest Derived
@@ -135,39 +135,37 @@ char *diskFileName();
 char *open_bracket = "{\n";
 char *close_bracket = "}\n";
 
-static void dummyhandler _PARAMS((cacheinfo *, StoreEntry *));
-static void info_get _PARAMS((cacheinfo *, StoreEntry *));
-static void info_get_mallstat _PARAMS((int, int, StoreEntry *));
-static void logReadEndHandler _PARAMS((int, int, log_read_data_t *));
-static void log_clear _PARAMS((cacheinfo *, StoreEntry *));
-static void log_disable _PARAMS((cacheinfo *, StoreEntry *));
-static void log_enable _PARAMS((cacheinfo *, StoreEntry *));
-static void log_get_start _PARAMS((cacheinfo *, StoreEntry *));
-static void log_status_get _PARAMS((cacheinfo *, StoreEntry *));
-static void parameter_get _PARAMS((cacheinfo *, StoreEntry *));
-static void proto_count _PARAMS((cacheinfo *, protocol_t, log_type));
-static void proto_newobj _PARAMS((cacheinfo *, protocol_t, int, int));
-static void proto_purgeobj _PARAMS((cacheinfo *, protocol_t, int));
-static void proto_touchobj _PARAMS((cacheinfo *, protocol_t, int));
-static void server_list _PARAMS((cacheinfo *, StoreEntry *));
-static void squidReadEndHandler _PARAMS((int, int, squid_read_data_t *));
-static void squid_get_start _PARAMS((cacheinfo *, StoreEntry *));
-static void statFiledescriptors _PARAMS((StoreEntry *));
-static void stat_get _PARAMS((cacheinfo *, char *req, StoreEntry *));
-static void stat_io_get _PARAMS((StoreEntry *));
-static void stat_obj _PARAMS((cacheinfo *, StoreEntry *, int vm_or_not));
-static void stat_utilization_get _PARAMS((cacheinfo *, StoreEntry *, char *desc));
-static int cache_size_get _PARAMS((cacheinfo *));
-static int logReadHandler _PARAMS((int, char *, int, log_read_data_t *));
-static int squidReadHandler _PARAMS((int, char *, int, squid_read_data_t *));
-static int memoryAccounted _PARAMS((void));
-static int mallinfoTotal _PARAMS((void));
+static void dummyhandler(cacheinfo *, StoreEntry *);
+static void info_get(cacheinfo *, StoreEntry *);
+static void info_get_mallstat(int, int, StoreEntry *);
+static void logReadEndHandler(int, int, log_read_data_t *);
+static void log_clear(cacheinfo *, StoreEntry *);
+static void log_disable(cacheinfo *, StoreEntry *);
+static void log_enable(cacheinfo *, StoreEntry *);
+static void log_get_start(cacheinfo *, StoreEntry *);
+static void log_status_get(cacheinfo *, StoreEntry *);
+static void parameter_get(cacheinfo *, StoreEntry *);
+static void proto_count(cacheinfo *, protocol_t, log_type);
+static void proto_newobj(cacheinfo *, protocol_t, int, int);
+static void proto_purgeobj(cacheinfo *, protocol_t, int);
+static void proto_touchobj(cacheinfo *, protocol_t, int);
+static void server_list(cacheinfo *, StoreEntry *);
+static void squidReadEndHandler(int, int, squid_read_data_t *);
+static void squid_get_start(cacheinfo *, StoreEntry *);
+static void statFiledescriptors(StoreEntry *);
+static void stat_get(cacheinfo *, char *req, StoreEntry *);
+static void stat_io_get(StoreEntry *);
+static void stat_obj(cacheinfo *, StoreEntry *, int vm_or_not);
+static void stat_utilization_get(cacheinfo *, StoreEntry *, char *desc);
+static int cache_size_get(cacheinfo *);
+static int logReadHandler(int, char *, int, log_read_data_t *);
+static int squidReadHandler(int, char *, int, squid_read_data_t *);
+static int memoryAccounted(void);
+static int mallinfoTotal(void);
 
 /* process utilization information */
-static void stat_utilization_get(obj, sentry, desc)
-     cacheinfo *obj;
-     StoreEntry *sentry;
-     char *desc;
+static void
+stat_utilization_get(cacheinfo * obj, StoreEntry * sentry, char *desc)
 {
     protocol_t proto_id;
     proto_stat *p = &obj->proto_stat_data[PROTO_MAX];
@@ -222,8 +220,8 @@ static void stat_utilization_get(obj, sentry, desc)
     storeAppendPrintf(sentry, close_bracket);
 }
 
-static void stat_io_get(sentry)
-     StoreEntry *sentry;
+static void
+stat_io_get(StoreEntry * sentry)
 {
     int i;
 
@@ -294,8 +292,8 @@ static void stat_io_get(sentry)
 /* return total bytes of all registered and known objects.
  * may not reflect the retrieving object....
  * something need to be done here to get more accurate cache size */
-static int cache_size_get(obj)
-     cacheinfo *obj;
+static int
+cache_size_get(cacheinfo * obj)
 {
     int size = 0;
     protocol_t proto_id;
@@ -306,10 +304,8 @@ static int cache_size_get(obj)
 }
 
 /* process objects list */
-static void stat_objects_get(obj, sentry, vm_or_not)
-     cacheinfo *obj;
-     StoreEntry *sentry;
-     int vm_or_not;
+static void
+stat_objects_get(cacheinfo * obj, StoreEntry * sentry, int vm_or_not)
 {
     LOCAL_ARRAY(char, space, 40);
     LOCAL_ARRAY(char, space2, 40);
@@ -351,10 +347,8 @@ static void stat_objects_get(obj, sentry, vm_or_not)
 
 
 /* process a requested object into a manager format */
-static void stat_get(obj, req, sentry)
-     cacheinfo *obj;
-     char *req;
-     StoreEntry *sentry;
+static void
+stat_get(cacheinfo * obj, char *req, StoreEntry * sentry)
 {
 
     if (strcmp(req, "objects") == 0) {
@@ -383,9 +377,8 @@ static void stat_get(obj, req, sentry)
 
 
 /* generate logfile status information */
-static void log_status_get(obj, sentry)
-     cacheinfo *obj;
-     StoreEntry *sentry;
+static void
+log_status_get(cacheinfo * obj, StoreEntry * sentry)
 {
     if (obj->logfile_status == LOG_ENABLE) {
 	storeAppendPrintf(sentry, "{\"Logfile is Enabled. Filename: %s\"}\n",
@@ -399,22 +392,17 @@ static void log_status_get(obj, sentry)
 
 /* log convert handler */
 /* call for each line in file, use fileWalk routine */
-static int logReadHandler(fd_unused, buf, size_unused, data)
-     int fd_unused;
-     char *buf;
-     int size_unused;
-     log_read_data_t *data;
+static int
+logReadHandler(int fd_unused, char *buf, int size_unused, log_read_data_t * data)
 {
     storeAppendPrintf(data->sentry, "{%s}\n", buf);
     return 0;
 }
 
 /* log convert end handler */
 /* call when a walk is completed or error. */
-static void logReadEndHandler(fd, errflag_unused, data)
-     int fd;
-     int errflag_unused;
-     log_read_data_t *data;
+static void
+logReadEndHandler(int fd, int errflag_unused, log_read_data_t * data)
 {
     storeAppendPrintf(data->sentry, close_bracket);
     storeComplete(data->sentry);
@@ -425,9 +413,8 @@ static void logReadEndHandler(fd, errflag_unused, data)
 
 
 /* start converting logfile to processed format */
-static void log_get_start(obj, sentry)
-     cacheinfo *obj;
-     StoreEntry *sentry;
+static void
+log_get_start(cacheinfo * obj, StoreEntry * sentry)
 {
     log_read_data_t *data = NULL;
     int fd;
@@ -458,22 +445,17 @@ static void log_get_start(obj, sentry)
 
 /* squid convert handler */
 /* call for each line in file, use fileWalk routine */
-static int squidReadHandler(fd_unused, buf, size_unused, data)
-     int fd_unused;
-     char *buf;
-     int size_unused;
-     squid_read_data_t *data;
+static int
+squidReadHandler(int fd_unused, char *buf, int size_unused, squid_read_data_t * data)
 {
     storeAppendPrintf(data->sentry, "{\"%s\"}\n", buf);
     return 0;
 }
 
 /* squid convert end handler */
 /* call when a walk is completed or error. */
-static void squidReadEndHandler(fd_unused, errflag_unused, data)
-     int fd_unused;
-     int errflag_unused;
-     squid_read_data_t *data;
+static void
+squidReadEndHandler(int fd_unused, int errflag_unused, squid_read_data_t * data)
 {
     storeAppendPrintf(data->sentry, close_bracket);
     storeComplete(data->sentry);
@@ -483,9 +465,8 @@ static void squidReadEndHandler(fd_unused, errflag_unused, data)
 
 
 /* start convert squid.conf file to processed format */
-static void squid_get_start(obj, sentry)
-     cacheinfo *obj;
-     StoreEntry *sentry;
+static void
+squid_get_start(cacheinfo * obj, StoreEntry * sentry)
 {
     squid_read_data_t *data;
 
@@ -498,16 +479,14 @@ static void squid_get_start(obj, sentry)
 }
 
 
-static void dummyhandler(obj, sentry)
-     cacheinfo *obj;
-     StoreEntry *sentry;
+static void
+dummyhandler(cacheinfo * obj, StoreEntry * sentry)
 {
     storeAppendPrintf(sentry, "{ \"Not_Implemented_yet.\"}\n");
 }
 
-static void server_list(obj, sentry)
-     cacheinfo *obj;
-     StoreEntry *sentry;
+static void
+server_list(cacheinfo * obj, StoreEntry * sentry)
 {
     edge *e = NULL;
     dom_list *d = NULL;
@@ -563,26 +542,24 @@ static void server_list(obj, sentry)
 }
 
 #if XMALLOC_STATISTICS
-static void info_get_mallstat(size, number, sentry)
-     int size, number;
-     StoreEntry *sentry;
+static void
+info_get_mallstat(int size, number, StoreEntry * sentry)
 {
     if (number > 0)
 	storeAppendPrintf(sentry, "{\t%d = %d}\n", size, number);
 }
 #endif
 
-static char *host_port_fmt(host, port)
-     char *host;
-     u_short port;
+static char *
+host_port_fmt(char *host, u_short port)
 {
     LOCAL_ARRAY(char, buf, 32);
     sprintf(buf, "%s.%d", host, (int) port);
     return buf;
 }
 
-static void statFiledescriptors(sentry)
-     StoreEntry *sentry;
+static void
+statFiledescriptors(StoreEntry * sentry)
 {
     int i;
     int j;
@@ -644,7 +621,8 @@ static void statFiledescriptors(sentry)
     storeAppendPrintf(sentry, close_bracket);
 }
 
-static int memoryAccounted()
+static int
+memoryAccounted()
 {
     return (int)
 	meta_data.store_entries * sizeof(StoreEntry) +
@@ -659,7 +637,8 @@ static int memoryAccounted()
 	meta_data.misc;
 }
 
-static int mallinfoTotal()
+static int
+mallinfoTotal()
 {
     int total = 0;
 #if HAVE_MALLINFO
@@ -670,9 +649,8 @@ static int mallinfoTotal()
     return total;
 }
 
-static void info_get(obj, sentry)
-     cacheinfo *obj;
-     StoreEntry *sentry;
+static void
+info_get(cacheinfo * obj, StoreEntry * sentry)
 {
     char *tod = NULL;
     float f;
@@ -862,9 +840,8 @@ static void info_get(obj, sentry)
     storeAppendPrintf(sentry, close_bracket);
 }
 
-static void parameter_get(obj, sentry)
-     cacheinfo *obj;
-     StoreEntry *sentry;
+static void
+parameter_get(cacheinfo * obj, StoreEntry * sentry)
 {
     storeAppendPrintf(sentry, open_bracket);
     storeAppendPrintf(sentry,
@@ -945,8 +922,8 @@ static char c2x[] =
 
 /* log_quote -- URL-style encoding on MIME headers. */
 
-char *log_quote(header)
-     char *header;
+char *
+log_quote(char *header)
 {
     int c, i;
     char *buf, *buf_cursor;
@@ -996,25 +973,24 @@ char *log_quote(header)
 #endif /* LOG_FULL_HEADERS */
 
 
-#if LOG_FULL_HEADERS
-static void log_append(obj, url, caddr, size, action, method, http_code, msec, ident, hierData, request_hdr, reply_hdr)
+static void
+log_append(cacheinfo * obj,
+    char *url,
+    struct in_addr caddr,
+    int size,
+    char *action,
+    char *method,
+    int http_code,
+    int msec,
+    char *ident,
+#if !LOG_FULL_HEADERS
+    struct _hierarchyLogData *hierData
 #else
-static void log_append(obj, url, caddr, size, action, method, http_code, msec, ident, hierData)
+    struct _hierarchyLogData *hierData,
+    char *request_hdr,
+    char *reply_hdr
 #endif				/* LOG_FULL_HEADERS */
-     cacheinfo *obj;
-     char *url;
-     struct in_addr caddr;
-     int size;
-     char *action;
-     char *method;
-     int http_code;
-     int msec;
-     char *ident;
-     struct _hierarchyLogData *hierData;
-#if LOG_FULL_HEADERS
-     char *request_hdr;
-     char *reply_hdr;
-#endif /* LOG_FULL_HEADERS */
+)
 {
 #if LOG_FULL_HEADERS
     LOCAL_ARRAY(char, tmp, 10000);	/* MAX_URL is 4096 */
@@ -1096,9 +1072,8 @@ static void log_append(obj, url, caddr, size, action, method, http_code, msec, i
     }
 }
 
-static void log_enable(obj, sentry)
-     cacheinfo *obj;
-     StoreEntry *sentry;
+static void
+log_enable(cacheinfo * obj, StoreEntry * sentry)
 {
     if (obj->logfile_status == LOG_DISABLE) {
 	obj->logfile_status = LOG_ENABLE;
@@ -1116,9 +1091,8 @@ static void log_enable(obj, sentry)
     storeAppendPrintf(sentry, " ");
 }
 
-static void log_disable(obj, sentry)
-     cacheinfo *obj;
-     StoreEntry *sentry;
+static void
+log_disable(cacheinfo * obj, StoreEntry * sentry)
 {
     if (obj->logfile_status == LOG_ENABLE)
 	file_close(obj->logfile_fd);
@@ -1130,9 +1104,8 @@ static void log_disable(obj, sentry)
 
 
 
-static void log_clear(obj, sentry)
-     cacheinfo *obj;
-     StoreEntry *sentry;
+static void
+log_clear(cacheinfo * obj, StoreEntry * sentry)
 {
     /* what should be done here. Erase file ??? or move it to another name?  At the moment, just erase it.  bug here need to be fixed. what if there are still data in memory. Need flush here */
     if (obj->logfile_status == LOG_ENABLE)
@@ -1152,11 +1125,8 @@ static void log_clear(obj, sentry)
 
 
 
-static void proto_newobject(obj, proto_id, size, restart)
-     cacheinfo *obj;
-     protocol_t proto_id;
-     int size;
-     int restart;
+static void
+proto_newobject(cacheinfo * obj, protocol_t proto_id, int size, int restart)
 {
     proto_stat *p = &obj->proto_stat_data[proto_id];
 
@@ -1172,10 +1142,8 @@ static void proto_newobject(obj, proto_id, size, restart)
 }
 
 
-static void proto_purgeobject(obj, proto_id, size)
-     cacheinfo *obj;
-     protocol_t proto_id;
-     int size;
+static void
+proto_purgeobject(cacheinfo * obj, protocol_t proto_id, int size)
 {
     proto_stat *p = &obj->proto_stat_data[proto_id];
 
@@ -1189,19 +1157,15 @@ static void proto_purgeobject(obj, proto_id, size)
 }
 
 /* update stat for each particular protocol when an object is fetched */
-static void proto_touchobject(obj, proto_id, size)
-     cacheinfo *obj;
-     protocol_t proto_id;
-     int size;
+static void
+proto_touchobject(cacheinfo * obj, protocol_t proto_id, int size)
 {
     obj->proto_stat_data[proto_id].refcount++;
     obj->proto_stat_data[proto_id].transferbyte += (1023 + size) >> 10;
 }
 
-static void proto_count(obj, proto_id, type)
-     cacheinfo *obj;
-     protocol_t proto_id;
-     log_type type;
+static void
+proto_count(cacheinfo * obj, protocol_t proto_id, log_type type)
 {
     switch (type) {
     case LOG_TCP_HIT:
@@ -1218,9 +1182,8 @@ static void proto_count(obj, proto_id, type)
 }
 
 
-void stat_init(object, logfilename)
-     cacheinfo **object;
-     char *logfilename;
+void
+stat_init(cacheinfo ** object, char *logfilename)
 {
     cacheinfo *obj = NULL;
     int i;
@@ -1296,8 +1259,8 @@ void stat_init(object, logfilename)
     *object = obj;
 }
 
-char *stat_describe(entry)
-     StoreEntry *entry;
+char *
+stat_describe(StoreEntry * entry)
 {
     LOCAL_ARRAY(char, state, 256);
 
@@ -1308,8 +1271,8 @@ char *stat_describe(entry)
     return (state);
 }
 
-char *mem_describe(entry)
-     StoreEntry *entry;
+char *
+mem_describe(StoreEntry * entry)
 {
     LOCAL_ARRAY(char, where, 100);
 
@@ -1322,8 +1285,8 @@ char *mem_describe(entry)
 }
 
 
-char *ttl_describe(entry)
-     StoreEntry *entry;
+char *
+ttl_describe(StoreEntry * entry)
 {
     int hh, mm, ss;
     LOCAL_ARRAY(char, TTL, 60);
@@ -1347,10 +1310,8 @@ char *ttl_describe(entry)
     return (TTL);
 }
 
-char *elapsed_time(entry, since, TTL)
-     StoreEntry *entry;
-     int since;
-     char *TTL;
+char *
+elapsed_time(StoreEntry * entry, int since, char *TTL)
 {
     int hh, mm, ss, ttl;
 
@@ -1373,8 +1334,8 @@ char *elapsed_time(entry, since, TTL)
 }
 
 
-char *flags_describe(entry)
-     StoreEntry *entry;
+char *
+flags_describe(StoreEntry * entry)
 {
     LOCAL_ARRAY(char, FLAGS, 32);
     char LOCK_CNT[32];
@@ -1403,7 +1364,8 @@ char *flags_describe(entry)
     return (FLAGS);
 }
 
-void stat_rotate_log()
+void
+stat_rotate_log()
 {
     int i;
     LOCAL_ARRAY(char, from, MAXPATHLEN);
@@ -1439,7 +1401,8 @@ void stat_rotate_log()
     HTTPCacheInfo->logfile_access = file_write_lock(HTTPCacheInfo->logfile_fd);
 }
 
-void statCloseLog()
+void
+statCloseLog()
 {
     file_close(HTTPCacheInfo->logfile_fd);
 }
@@ -1,5 +1,5 @@
 /*
- * $Id: stmem.cc,v 1.19 1996/08/27 05:17:50 wessels Exp $
+ * $Id: stmem.cc,v 1.20 1996/09/14 08:46:28 wessels Exp $
  *
  * DEBUG: section 19    Memory Primitives
  * AUTHOR: Harvest Derived
@@ -116,12 +116,12 @@ stmem_stats mem_obj_pool;
 #define USE_MEMALIGN 0
 #endif
 
-static void *get_free_thing _PARAMS((stmem_stats * thing));
-static void put_free_thing _PARAMS((stmem_stats * thing, void *p));
+static void *get_free_thing(stmem_stats * thing);
+static void put_free_thing(stmem_stats * thing, void *p);
 
 
-void memFree(mem)
-     mem_ptr mem;
+void
+memFree(mem_ptr mem)
 {
     mem_node lastp, p = mem->head;
 
@@ -144,8 +144,8 @@ void memFree(mem)
     safe_free(mem);
 }
 
-void memFreeData(mem)
-     mem_ptr mem;
+void
+memFreeData(mem_ptr mem)
 {
     mem_node lastp, p = mem->head;
 
@@ -165,9 +165,8 @@ void memFreeData(mem)
     mem->origin_offset = 0;
 }
 
-int memFreeDataUpto(mem, target_offset)
-     mem_ptr mem;
-     int target_offset;
+int
+memFreeDataUpto(mem_ptr mem, int target_offset)
 {
     int current_offset = mem->origin_offset;
     mem_node lastp, p = mem->head;
@@ -204,10 +203,8 @@ int memFreeDataUpto(mem, target_offset)
 
 
 /* Append incoming data. */
-int memAppend(mem, data, len)
-     mem_ptr mem;
-     char *data;
-     int len;
+int
+memAppend(mem_ptr mem, char *data, int len)
 {
     mem_node p;
     int avail_len;
@@ -251,10 +248,8 @@ int memAppend(mem, data, len)
 }
 
 #ifdef UNUSED_CODE
-int memGrep(mem, string, nbytes)
-     mem_ptr mem;
-     char *string;
-     int nbytes;
+int
+memGrep(mem_ptr mem, char *string, int nbytes)
 {
     mem_node p = mem->head;
     char *str_i, *mem_i;
@@ -303,11 +298,8 @@ int memGrep(mem, string, nbytes)
 }
 #endif
 
-int memCopy(mem, offset, buf, size)
-     mem_ptr mem;
-     int offset;
-     char *buf;
-     int size;
+int
+memCopy(mem_ptr mem, int offset, char *buf, int size)
 {
     mem_node p = mem->head;
     int t_off = mem->origin_offset;
@@ -364,7 +356,8 @@ int memCopy(mem, offset, buf, size)
 
 
 /* Do whatever is necessary to begin storage of new object */
-mem_ptr memInit()
+mem_ptr
+memInit()
 {
     mem_ptr new = xcalloc(1, sizeof(Mem_Hdr));
     new->tail = new->head = NULL;
@@ -379,8 +372,8 @@ mem_ptr memInit()
     return new;
 }
 
-static void *get_free_thing(thing)
-     stmem_stats *thing;
+static void *
+get_free_thing(stmem_stats * thing)
 {
     void *p = NULL;
     if (!empty_stack(&thing->free_page_stack)) {
@@ -396,29 +389,32 @@ static void *get_free_thing(thing)
     return p;
 }
 
-void *get_free_request_t()
+void *
+get_free_request_t()
 {
     return get_free_thing(&request_pool);
 }
 
-void *get_free_mem_obj()
+void *
+get_free_mem_obj()
 {
     return get_free_thing(&mem_obj_pool);
 }
 
-char *get_free_4k_page()
+char *
+get_free_4k_page()
 {
     return (char *) get_free_thing(&sm_stats);
 }
 
-char *get_free_8k_page()
+char *
+get_free_8k_page()
 {
     return (char *) get_free_thing(&disk_stats);
 }
 
-static void put_free_thing(thing, p)
-     stmem_stats *thing;
-     void *p;
+static void
+put_free_thing(stmem_stats * thing, void *p)
 {
     if (p == NULL)
 	fatal_dump("Somebody is putting a NULL pointer!");
@@ -434,31 +430,32 @@ static void put_free_thing(thing, p)
     }
 }
 
-void put_free_request_t(req)
-     void *req;
+void
+put_free_request_t(void *req)
 {
     put_free_thing(&request_pool, req);
 }
 
-void put_free_mem_obj(mem)
-     void *mem;
+void
+put_free_mem_obj(void *mem)
 {
     put_free_thing(&mem_obj_pool, mem);
 }
 
-void put_free_4k_page(page)
-     void *page;
+void
+put_free_4k_page(void *page)
 {
     put_free_thing(&sm_stats, page);
 }
 
-void put_free_8k_page(page)
-     void *page;
+void
+put_free_8k_page(void *page)
 {
     put_free_thing(&disk_stats, page);
 }
 
-void stmemInit()
+void
+stmemInit()
 {
     sm_stats.page_size = SM_PAGE_SIZE;
     sm_stats.total_pages_allocated = 0;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store.cc,v 1.108 1996/09/14 07:22:04 wessels Exp $
+ * $Id: store.cc,v 1.109 1996/09/14 08:46:30 wessels Exp $
  *
  * DEBUG: section 20    Storeage Manager
  * AUTHOR: Harvest Derived
@@ -202,24 +202,24 @@ struct storeRebuild_data {
 int store_rebuilding = STORE_REBUILDING_SLOW;
 
 /* Static Functions */
-static int storeSwapInStart _PARAMS((StoreEntry *, SIH, void *));
-static void destroy_MemObject _PARAMS((MemObject *));
-static void destroy_MemObjectData _PARAMS((MemObject *));
-static void destroy_StoreEntry _PARAMS((StoreEntry *));
-static MemObject *new_MemObject _PARAMS((void));
-static mem_ptr new_MemObjectData _PARAMS((void));
-static StoreEntry *new_StoreEntry _PARAMS((int mem_obj_flag));
-static int storeCheckPurgeMem _PARAMS((StoreEntry * e));
-static int storeCheckExpired _PARAMS((StoreEntry * e));
-static void storeSwapLog _PARAMS((StoreEntry *));
-static int storeHashDelete _PARAMS((StoreEntry *));
-static char *storeDescribeStatus _PARAMS((StoreEntry *));
-static int compareLastRef _PARAMS((StoreEntry ** e1, StoreEntry ** e2));
-static int compareSize _PARAMS((StoreEntry ** e1, StoreEntry ** e2));
-static int storeClientListSearch _PARAMS((MemObject *, int fd));
-static void storeHashMemInsert _PARAMS((StoreEntry *));
-static void storeHashMemDelete _PARAMS((StoreEntry *));
-static int storeCopy _PARAMS((StoreEntry *, int, int, char *, int *));
+static int storeSwapInStart(StoreEntry *, SIH, void *);
+static void destroy_MemObject(MemObject *);
+static void destroy_MemObjectData(MemObject *);
+static void destroy_StoreEntry(StoreEntry *);
+static MemObject *new_MemObject(void);
+static mem_ptr new_MemObjectData(void);
+static StoreEntry *new_StoreEntry(int mem_obj_flag);
+static int storeCheckPurgeMem(StoreEntry * e);
+static int storeCheckExpired(StoreEntry * e);
+static void storeSwapLog(StoreEntry *);
+static int storeHashDelete(StoreEntry *);
+static char *storeDescribeStatus(StoreEntry *);
+static int compareLastRef(StoreEntry ** e1, StoreEntry ** e2);
+static int compareSize(StoreEntry ** e1, StoreEntry ** e2);
+static int storeClientListSearch(MemObject *, int fd);
+static void storeHashMemInsert(StoreEntry *);
+static void storeHashMemDelete(StoreEntry *);
+static int storeCopy(StoreEntry *, int, int, char *, int *);
 
 /* Now, this table is inaccessible to outsider. They have to use a method
  * to access a value in internal storage data structure. */
@@ -257,7 +257,8 @@ char **CacheDirs = NULL;
 static int CacheDirsAllocated = 0;
 int ncache_dirs = 0;
 
-static MemObject *new_MemObject()
+static MemObject *
+new_MemObject(void)
 {
     MemObject *mem = get_free_mem_obj();
     mem->reply = xcalloc(1, sizeof(struct _http_reply));
@@ -267,8 +268,8 @@ static MemObject *new_MemObject()
     return mem;
 }
 
-static StoreEntry *new_StoreEntry(mem_obj_flag)
-     int mem_obj_flag;
+static StoreEntry *
+new_StoreEntry(int mem_obj_flag)
 {
     StoreEntry *e = NULL;
 
@@ -280,8 +281,8 @@ static StoreEntry *new_StoreEntry(mem_obj_flag)
     return e;
 }
 
-static void destroy_MemObject(mem)
-     MemObject *mem;
+static void
+destroy_MemObject(MemObject * mem)
 {
     int i;
     debug(20, 3, "destroy_MemObject: destroying %p\n", mem);
@@ -303,8 +304,8 @@ static void destroy_MemObject(mem)
     meta_data.misc -= sizeof(struct _http_reply);
 }
 
-static void destroy_StoreEntry(e)
-     StoreEntry *e;
+static void
+destroy_StoreEntry(StoreEntry * e)
 {
     debug(20, 3, "destroy_StoreEntry: destroying %p\n", e);
     if (!e) {
@@ -328,15 +329,16 @@ static void destroy_StoreEntry(e)
     meta_data.store_entries--;
 }
 
-static mem_ptr new_MemObjectData()
+static mem_ptr
+new_MemObjectData(void)
 {
     debug(20, 3, "new_MemObjectData: calling memInit()\n");
     meta_data.mem_data_count++;
     return memInit();
 }
 
-static void destroy_MemObjectData(mem)
-     MemObject *mem;
+static void
+destroy_MemObjectData(MemObject * mem)
 {
     debug(20, 3, "destroy_MemObjectData: destroying %p\n", mem->data);
     store_mem_size -= mem->e_current_len - mem->e_lowest_offset;
@@ -359,23 +361,23 @@ static void destroy_MemObjectData(mem)
  * objects in the memory.
  */
 
-HashID storeCreateHashTable(cmp_func)
-     int (*cmp_func) (char *, char *);
+HashID
+storeCreateHashTable(int (*cmp_func) (char *, char *))
 {
     store_table = hash_create(cmp_func, STORE_BUCKETS, hash_url);
     in_mem_table = hash_create(cmp_func, STORE_IN_MEM_BUCKETS, hash_url);
     return store_table;
 }
 
-static void storeHashMemInsert(e)
-     StoreEntry *e;
+static void
+storeHashMemInsert(StoreEntry * e)
 {
     hash_insert(in_mem_table, e->key, e);
     meta_data.hot_vm++;
 }
 
-static void storeHashMemDelete(e)
-     StoreEntry *e;
+static void
+storeHashMemDelete(StoreEntry * e)
 {
     hash_link *hptr = hash_lookup(in_mem_table, e->key);
     if (hptr == NULL) {
@@ -386,8 +388,8 @@ static void storeHashMemDelete(e)
     meta_data.hot_vm--;
 }
 
-static int storeHashInsert(e)
-     StoreEntry *e;
+static int
+storeHashInsert(StoreEntry * e)
 {
     debug(20, 3, "storeHashInsert: Inserting Entry %p key '%s'\n",
 	e, e->key);
@@ -396,8 +398,8 @@ static int storeHashInsert(e)
     return hash_join(store_table, (hash_link *) e);
 }
 
-static int storeHashDelete(e)
-     StoreEntry *e;
+static int
+storeHashDelete(StoreEntry * e)
 {
     if (e->mem_status == IN_MEMORY)
 	storeHashMemDelete(e);
@@ -408,9 +410,8 @@ static int storeHashDelete(e)
  * maintain the in-mem hash table according to the changes of mem_status
  * This routine replaces the instruction "e->store_status = status;"
  */
-void storeSetMemStatus(e, status)
-     StoreEntry *e;
-     mem_status_t status;
+void
+storeSetMemStatus(StoreEntry * e, mem_status_t status)
 {
     if (e->key == NULL) {
 	debug_trap("storeSetMemStatus: NULL key");
@@ -424,8 +425,8 @@ void storeSetMemStatus(e, status)
 
 /* -------------------------------------------------------------------------- */
 
-static char *time_describe(t)
-     time_t t;
+static char *
+time_describe(time_t t)
 {
     LOCAL_ARRAY(char, buf, 128);
 
@@ -447,9 +448,8 @@ static char *time_describe(t)
     return buf;
 }
 
-static void storeLog(tag, e)
-     int tag;
-     StoreEntry *e;
+static void
+storeLog(int tag, StoreEntry * e)
 {
     LOCAL_ARRAY(char, logmsg, MAX_URL << 1);
     time_t t;
@@ -486,8 +486,8 @@ static void storeLog(tag, e)
 
 /* get rid of memory copy of the object */
 /* Only call this if storeCheckPurgeMem(e) returns 1 */
-void storePurgeMem(e)
-     StoreEntry *e;
+void
+storePurgeMem(StoreEntry * e)
 {
     debug(20, 3, "storePurgeMem: Freeing memory-copy of %s\n", e->key);
     if (e->mem_obj == NULL)
@@ -503,10 +503,8 @@ void storePurgeMem(e)
  * storeAbort()
  * {http,ftp,gopher,wais}Start()
  */
-int storeLockObject(e, handler, data)
-     StoreEntry *e;
-     SIH handler;
-     void *data;
+int
+storeLockObject(StoreEntry * e, SIH handler, void *data)
 {
     int status = 0;
     e->lock_count++;
@@ -546,8 +544,8 @@ int storeLockObject(e, handler, data)
     return status;
 }
 
-void storeReleaseRequest(e)
-     StoreEntry *e;
+void
+storeReleaseRequest(StoreEntry * e)
 {
     if (e->flag & RELEASE_REQUEST)
 	return;
@@ -561,8 +559,8 @@ void storeReleaseRequest(e)
 
 /* unlock object, return -1 if object get released after unlock
  * otherwise lock_count */
-int storeUnlockObject(e)
-     StoreEntry *e;
+int
+storeUnlockObject(StoreEntry * e)
 {
     MemObject *mem = e->mem_obj;
     e->lock_count--;
@@ -591,8 +589,8 @@ int storeUnlockObject(e)
 
 /* Lookup an object in the cache. 
  * return just a reference to object, don't start swapping in yet. */
-StoreEntry *storeGet(url)
-     char *url;
+StoreEntry *
+storeGet(char *url)
 {
     hash_link *hptr = NULL;
 
@@ -603,18 +601,17 @@ StoreEntry *storeGet(url)
     return NULL;
 }
 
-unsigned int getKeyCounter()
+unsigned int
+getKeyCounter(void)
 {
     static unsigned int key_counter = 0;
     if (++key_counter == 0)
 	++key_counter;
     return key_counter;
 }
 
-char *storeGeneratePrivateKey(url, method, num)
-     char *url;
-     method_t method;
-     int num;
+char *
+storeGeneratePrivateKey(char *url, method_t method, int num)
 {
     if (num == 0)
 	num = getKeyCounter();
@@ -627,9 +624,8 @@ char *storeGeneratePrivateKey(url, method, num)
     return key_temp_buffer;
 }
 
-char *storeGeneratePublicKey(url, method)
-     char *url;
-     method_t method;
+char *
+storeGeneratePublicKey(char *url, method_t method)
 {
     debug(20, 3, "storeGeneratePublicKey: type=%d %s\n", method, url);
     switch (method) {
@@ -664,8 +660,8 @@ char *storeGeneratePublicKey(url, method)
     return NULL;
 }
 
-void storeSetPrivateKey(e)
-     StoreEntry *e;
+void
+storeSetPrivateKey(StoreEntry * e)
 {
     StoreEntry *e2 = NULL;
     hash_link *table_entry = NULL;
@@ -694,8 +690,8 @@ void storeSetPrivateKey(e)
     BIT_SET(e->flag, KEY_PRIVATE);
 }
 
-void storeSetPublicKey(e)
-     StoreEntry *e;
+void
+storeSetPublicKey(StoreEntry * e)
 {
     StoreEntry *e2 = NULL;
     hash_link *table_entry = NULL;
@@ -732,11 +728,8 @@ void storeSetPublicKey(e)
     storeHashInsert(e);
 }
 
-StoreEntry *storeCreateEntry(url, req_hdr, flags, method)
-     char *url;
-     char *req_hdr;
-     int flags;
-     method_t method;
+StoreEntry *
+storeCreateEntry(char *url, char *req_hdr, int flags, method_t method)
 {
     StoreEntry *e = NULL;
     MemObject *mem = NULL;
@@ -795,13 +788,8 @@ StoreEntry *storeCreateEntry(url, req_hdr, flags, method)
 
 /* Add a new object to the cache with empty memory copy and pointer to disk
  * use to rebuild store from disk. */
-StoreEntry *storeAddDiskRestore(url, file_number, size, expires, timestamp, lastmod)
-     char *url;
-     int file_number;
-     int size;
-     time_t expires;
-     time_t timestamp;
-     time_t lastmod;
+StoreEntry *
+storeAddDiskRestore(char *url, int file_number, int size, time_t expires, time_t timestamp, time_t lastmod)
 {
     StoreEntry *e = NULL;
 
@@ -838,11 +826,8 @@ StoreEntry *storeAddDiskRestore(url, file_number, size, expires, timestamp, last
 }
 
 /* Register interest in an object currently being retrieved. */
-int storeRegister(e, fd, handler, data)
-     StoreEntry *e;
-     int fd;
-     PIF handler;
-     void *data;
+int
+storeRegister(StoreEntry * e, int fd, PIF handler, void *data)
 {
     PendingEntry *pe = NULL;
     int old_size;
@@ -898,9 +883,8 @@ int storeRegister(e, fd, handler, data)
 /* remove handler assoicate to that fd from store pending list */
 /* Also remove entry from client_list if exist. */
 /* return number of successfully free pending entries */
-int storeUnregister(e, fd)
-     StoreEntry *e;
-     int fd;
+int
+storeUnregister(StoreEntry * e, int fd)
 {
     int i;
     int freed = 0;
@@ -928,8 +912,8 @@ int storeUnregister(e, fd)
     return freed;
 }
 
-int storeGetLowestReaderOffset(entry)
-     StoreEntry *entry;
+int
+storeGetLowestReaderOffset(StoreEntry * entry)
 {
     MemObject *mem = entry->mem_obj;
     int lowest = mem->e_current_len;
@@ -945,8 +929,8 @@ int storeGetLowestReaderOffset(entry)
 
 /* Call to delete behind upto "target lowest offset"
  * also, update e_lowest_offset  */
-void storeDeleteBehind(e)
-     StoreEntry *e;
+void
+storeDeleteBehind(StoreEntry * e)
 {
     MemObject *mem = e->mem_obj;
     int free_up_to;
@@ -970,8 +954,8 @@ void storeDeleteBehind(e)
 }
 
 /* Call handlers waiting for  data to be appended to E. */
-static void InvokeHandlers(e)
-     StoreEntry *e;
+static void
+InvokeHandlers(StoreEntry * e)
 {
     int i;
     int fd;
@@ -996,17 +980,17 @@ static void InvokeHandlers(e)
 }
 
 /* Mark object as expired */
-void storeExpireNow(e)
-     StoreEntry *e;
+void
+storeExpireNow(StoreEntry * e)
 {
     debug(20, 3, "storeExpireNow: '%s'\n", e->key);
     e->expires = squid_curtime;
 }
 
 /* switch object to deleting behind mode call by
  * retrieval module when object gets too big.  */
-void storeStartDeleteBehind(e)
-     StoreEntry *e;
+void
+storeStartDeleteBehind(StoreEntry * e)
 {
     debug(20, 2, "storeStartDeleteBehind: Object: %s\n", e->key);
     if (e->flag & DELETE_BEHIND)
@@ -1021,10 +1005,8 @@ void storeStartDeleteBehind(e)
 }
 
 /* Append incoming data from a primary server to an entry. */
-void storeAppend(e, data, len)
-     StoreEntry *e;
-     char *data;
-     int len;
+void
+storeAppend(StoreEntry * e, char *data, int len)
 {
     /* sanity check */
     if (e == NULL) {
@@ -1049,13 +1031,15 @@ void storeAppend(e, data, len)
 }
 
 #if defined(__STRICT_ANSI__)
-void storeAppendPrintf(StoreEntry * e, char *fmt,...)
+void
+storeAppendPrintf(StoreEntry * e, char *fmt,...)
 {
     va_list args;
     LOCAL_ARRAY(char, buf, 4096);
     va_start(args, fmt);
 #else
-void storeAppendPrintf(va_alist)
+void
+storeAppendPrintf(va_alist)
      va_dcl
 {
     va_list args;
@@ -1073,8 +1057,8 @@ void storeAppendPrintf(va_alist)
 }
 
 /* add directory to swap disk */
-int storeAddSwapDisk(path)
-     char *path;
+int
+storeAddSwapDisk(char *path)
 {
     char **tmp = NULL;
     int i;
@@ -1095,17 +1079,16 @@ int storeAddSwapDisk(path)
 }
 
 /* return the nth swap directory */
-char *swappath(n)
-     int n;
+char *
+swappath(int n)
 {
     return *(CacheDirs + (n % ncache_dirs));
 }
 
 
 /* return full name to swapfile */
-char *storeSwapFullPath(fn, fullpath)
-     int fn;
-     char *fullpath;
+char *
+storeSwapFullPath(int fn, char *fullpath)
 {
     LOCAL_ARRAY(char, fullfilename, MAX_FILE_NAME_LEN);
     if (!fullpath)
@@ -1120,13 +1103,8 @@ char *storeSwapFullPath(fn, fullpath)
 }
 
 /* swapping in handle */
-int storeSwapInHandle(fd_notused, buf, len, flag, e, offset_notused)
-     int fd_notused;
-     char *buf;
-     int len;
-     int flag;
-     StoreEntry *e;
-     int offset_notused;
+int
+storeSwapInHandle(int fd_notused, char *buf, int len, int flag, StoreEntry * e, int offset_notused)
 {
     MemObject *mem = e->mem_obj;
     SIH handler = NULL;
@@ -1193,10 +1171,8 @@ int storeSwapInHandle(fd_notused, buf, len, flag, e, offset_notused)
 }
 
 /* start swapping in */
-static int storeSwapInStart(e, swapin_complete_handler, swapin_complete_data)
-     StoreEntry *e;
-     SIH swapin_complete_handler;
-     void *swapin_complete_data;
+static int
+storeSwapInStart(StoreEntry * e, SIH swapin_complete_handler, void *swapin_complete_data)
 {
     int fd;
     char *path = NULL;
@@ -1242,8 +1218,8 @@ static int storeSwapInStart(e, swapin_complete_handler, swapin_complete_data)
     return 0;
 }
 
-static void storeSwapLog(e)
-     StoreEntry *e;
+static void
+storeSwapLog(StoreEntry * e)
 {
     LOCAL_ARRAY(char, logmsg, MAX_URL << 1);
     /* Note this printf format appears in storeWriteCleanLog() too */
@@ -1263,10 +1239,8 @@ static void storeSwapLog(e)
 	xfree);
 }
 
-void storeSwapOutHandle(fd, flag, e)
-     int fd;
-     int flag;
-     StoreEntry *e;
+void
+storeSwapOutHandle(int fd, int flag, StoreEntry * e)
 {
     LOCAL_ARRAY(char, filename, MAX_FILE_NAME_LEN);
     MemObject *mem = e->mem_obj;
@@ -1345,8 +1319,8 @@ void storeSwapOutHandle(fd, flag, e)
 
 
 /* start swapping object to disk */
-static int storeSwapOutStart(e)
-     StoreEntry *e;
+static int
+storeSwapOutStart(StoreEntry * e)
 {
     int fd;
     int x;
@@ -1401,8 +1375,8 @@ static int storeSwapOutStart(e)
 /* recreate meta data from disk image in swap directory */
 
 /* Add one swap file at a time from disk storage */
-static int storeDoRebuildFromDisk(data)
-     struct storeRebuild_data *data;
+static int
+storeDoRebuildFromDisk(struct storeRebuild_data *data)
 {
     LOCAL_ARRAY(char, swapfile, MAXPATHLEN);
     LOCAL_ARRAY(char, url, MAX_URL + 1);
@@ -1548,8 +1522,8 @@ static int storeDoRebuildFromDisk(data)
 }
 
 /* meta data recreated from disk image in swap directory */
-static void storeRebuiltFromDisk(data)
-     struct storeRebuild_data *data;
+static void
+storeRebuiltFromDisk(struct storeRebuild_data *data)
 {
     time_t r;
     time_t stop;
@@ -1584,7 +1558,8 @@ static void storeRebuiltFromDisk(data)
     swaplog_lock = file_write_lock(swaplog_fd);
 }
 
-void storeStartRebuildFromDisk()
+void
+storeStartRebuildFromDisk(void)
 {
     struct stat sb;
     int i;
@@ -1653,19 +1628,21 @@ void storeStartRebuildFromDisk()
 }
 
 /* return current swap size in kilo-bytes */
-int storeGetSwapSize()
+int
+storeGetSwapSize(void)
 {
     return store_swap_size;
 }
 
 /* return current swap size in bytes */
-int storeGetMemSize()
+int
+storeGetMemSize(void)
 {
     return store_mem_size;
 }
 
-static int storeCheckSwapable(e)
-     StoreEntry *e;
+static int
+storeCheckSwapable(StoreEntry * e)
 {
 
     if (squid_curtime - e->expires > Config.expireAge) {
@@ -1692,8 +1669,8 @@ static int storeCheckSwapable(e)
 
 
 /* Complete transfer into the local cache.  */
-void storeComplete(e)
-     StoreEntry *e;
+void
+storeComplete(StoreEntry * e)
 {
     debug(20, 3, "storeComplete: '%s'\n", e->key);
     e->object_len = e->mem_obj->e_current_len;
@@ -1714,9 +1691,8 @@ void storeComplete(e)
  * Fetch aborted.  Tell all clients to go home.  Negatively cache
  * abort message, freeing the data for this object 
  */
-void storeAbort(e, msg)
-     StoreEntry *e;
-     char *msg;
+void
+storeAbort(StoreEntry * e, char *msg)
 {
     LOCAL_ARRAY(char, mime_hdr, 300);
     LOCAL_ARRAY(char, abort_msg, 2000);
@@ -1749,10 +1725,10 @@ void storeAbort(e, msg)
 	mem->request ? mem->request->protocol : PROTO_NONE,
 	mem->e_current_len);
     mk_mime_hdr(mime_hdr,
-	(time_t) Config.negativeTtl,
-	6 + strlen(msg),
+	"text/html",
+	strlen(msg),
 	squid_curtime,
-	"text/html");
+	squid_curtime + Config.negativeTtl);
     if (msg) {
 	/* This can run off the end here. Be careful */
 	if ((int) (strlen(msg) + strlen(mime_hdr) + 50) < 2000) {
@@ -1778,8 +1754,8 @@ void storeAbort(e, msg)
 }
 
 /* get the first in memory object entry in the storage */
-hash_link *storeFindFirst(id)
-     HashID id;
+hash_link *
+storeFindFirst(HashID id)
 {
     if (id == (HashID) 0)
 	return NULL;
@@ -1788,16 +1764,17 @@ hash_link *storeFindFirst(id)
 
 /* get the next in memory object entry in the storage for a given
  * search pointer */
-hash_link *storeFindNext(id)
-     HashID id;
+hash_link *
+storeFindNext(HashID id)
 {
     if (id == (HashID) 0)
 	return NULL;
     return (hash_next(id));
 }
 
 /* get the first in memory object entry in the storage */
-StoreEntry *storeGetInMemFirst()
+StoreEntry *
+storeGetInMemFirst(void)
 {
     hash_link *first = NULL;
     first = storeFindFirst(in_mem_table);
@@ -1807,28 +1784,32 @@ StoreEntry *storeGetInMemFirst()
 
 /* get the next in memory object entry in the storage for a given
  * search pointer */
-StoreEntry *storeGetInMemNext()
+StoreEntry *
+storeGetInMemNext(void)
 {
     hash_link *next = NULL;
     next = storeFindNext(in_mem_table);
     return (next ? ((StoreEntry *) next->item) : NULL);
 }
 
 /* get the first entry in the storage */
-StoreEntry *storeGetFirst()
+StoreEntry *
+storeGetFirst(void)
 {
     return ((StoreEntry *) storeFindFirst(store_table));
 }
 
 
 /* get the next entry in the storage for a given search pointer */
-StoreEntry *storeGetNext()
+StoreEntry *
+storeGetNext(void)
 {
     return ((StoreEntry *) storeFindNext(store_table));
 }
 
 /* free up all ttl-expired objects */
-int storePurgeOld()
+int
+storePurgeOld(void)
 {
     StoreEntry *e = NULL;
     int n = 0;
@@ -1850,9 +1831,8 @@ int storePurgeOld()
 
 
 /* Clear Memory storage to accommodate the given object len */
-int storeGetMemSpace(size, check_vm_number)
-     int size;
-     int check_vm_number;
+int
+storeGetMemSpace(int size, int check_vm_number)
 {
     StoreEntry *e = NULL;
     StoreEntry **list = NULL;
@@ -1947,8 +1927,8 @@ int storeGetMemSpace(size, check_vm_number)
     return 0;
 }
 
-static int compareSize(e1, e2)
-     StoreEntry **e1, **e2;
+static int
+compareSize(StoreEntry ** e1, StoreEntry ** e2)
 {
     if (!e1 || !e2)
 	fatal_dump(NULL);
@@ -1959,8 +1939,8 @@ static int compareSize(e1, e2)
     return (0);
 }
 
-static int compareLastRef(e1, e2)
-     StoreEntry **e1, **e2;
+static int
+compareLastRef(StoreEntry ** e1, StoreEntry ** e2)
 {
     if (!e1 || !e2)
 	fatal_dump(NULL);
@@ -1974,7 +1954,8 @@ static int compareLastRef(e1, e2)
 /* returns the bucket number to work on,
  * pointer to next bucket after each calling
  */
-unsigned int storeGetBucketNum()
+unsigned int
+storeGetBucketNum(void)
 {
     static unsigned int bucket = 0;
     if (bucket >= STORE_BUCKETS)
@@ -1990,8 +1971,8 @@ unsigned int storeGetBucketNum()
 #define SWAP_LRU_REMOVE_COUNT	8
 
 /* Clear Swap storage to accommodate the given object len */
-int storeGetSwapSpace(size)
-     int size;
+int
+storeGetSwapSpace(int size)
 {
     static int fReduceSwap = 0;
     static int swap_help = 0;
@@ -2134,8 +2115,8 @@ int storeGetSwapSpace(size)
 
 /* release an object from a cache */
 /* return 0 when success. */
-int storeRelease(e)
-     StoreEntry *e;
+int
+storeRelease(StoreEntry * e)
 {
     StoreEntry *result = NULL;
     StoreEntry *head_result = NULL;
@@ -2208,17 +2189,17 @@ int storeRelease(e)
 
 
 /* return if the current key is the original one. */
-int storeOriginalKey(e)
-     StoreEntry *e;
+int
+storeOriginalKey(StoreEntry * e)
 {
     if (!e)
 	return 1;
     return !(e->flag & KEY_CHANGE);
 }
 
 /* return 1 if a store entry is locked */
-int storeEntryLocked(e)
-     StoreEntry *e;
+int
+storeEntryLocked(StoreEntry * e)
 {
     if (e->lock_count)
 	return 1;
@@ -2232,12 +2213,8 @@ int storeEntryLocked(e)
 }
 
 /*  use this for internal call only */
-static int storeCopy(e, stateoffset, maxSize, buf, size)
-     StoreEntry *e;
-     int stateoffset;
-     int maxSize;
-     char *buf;
-     int *size;
+static int
+storeCopy(StoreEntry * e, int stateoffset, int maxSize, char *buf, int *size)
 {
     int available_to_write = 0;
 
@@ -2265,8 +2242,8 @@ static int storeCopy(e, stateoffset, maxSize, buf, size)
 
 /* check if there is any client waiting for this object at all */
 /* return 1 if there is at least one client */
-int storeClientWaiting(e)
-     StoreEntry *e;
+int
+storeClientWaiting(StoreEntry * e)
 {
     int i;
     MemObject *mem = e->mem_obj;
@@ -2286,9 +2263,8 @@ int storeClientWaiting(e)
 }
 
 /* return index to matched clientstatus in client_list, -1 on NOT_FOUND */
-static int storeClientListSearch(mem, fd)
-     MemObject *mem;
-     int fd;
+static int
+storeClientListSearch(MemObject * mem, int fd)
 {
     int i;
     if (mem->client_list) {
@@ -2304,10 +2280,8 @@ static int storeClientListSearch(mem, fd)
 }
 
 /* add client with fd to client list */
-void storeClientListAdd(e, fd, last_offset)
-     StoreEntry *e;
-     int fd;
-     int last_offset;
+void
+storeClientListAdd(StoreEntry * e, int fd, int last_offset)
 {
     int i;
     MemObject *mem = e->mem_obj;
@@ -2342,13 +2316,8 @@ void storeClientListAdd(e, fd, last_offset)
 
 /* same to storeCopy but also register client fd and last requested offset
  * for each client */
-int storeClientCopy(e, stateoffset, maxSize, buf, size, fd)
-     StoreEntry *e;
-     int stateoffset;
-     int maxSize;
-     char *buf;
-     int *size;
-     int fd;
+int
+storeClientCopy(StoreEntry * e, int stateoffset, int maxSize, char *buf, int *size, int fd)
 {
     int next_offset;
     int client_list_index;
@@ -2389,8 +2358,8 @@ int storeClientCopy(e, stateoffset, maxSize, buf, size, fd)
 }
 
 
-int storeEntryValidToSend(e)
-     StoreEntry *e;
+int
+storeEntryValidToSend(StoreEntry * e)
 {
     if (squid_curtime < e->expires)
 	return 1;
@@ -2403,8 +2372,8 @@ int storeEntryValidToSend(e)
     return 1;			/* STORE_PENDING, IN_MEMORY, exp=0 */
 }
 
-int storeEntryValidLength(e)
-     StoreEntry *e;
+int
+storeEntryValidLength(StoreEntry * e)
 {
     int diff;
     int hdr_sz;
@@ -2442,8 +2411,8 @@ int storeEntryValidLength(e)
     return 1;
 }
 
-static int storeVerifySwapDirs(clean)
-     int clean;
+static int
+storeVerifySwapDirs(int clean)
 {
     int inx;
     char *path = NULL;
@@ -2488,7 +2457,8 @@ static int storeVerifySwapDirs(clean)
     return directory_created;
 }
 
-static void storeCreateSwapSubDirs()
+static void
+storeCreateSwapSubDirs(void)
 {
     int i, j, k;
     LOCAL_ARRAY(char, name, MAXPATHLEN);
@@ -2519,7 +2489,8 @@ static void storeCreateSwapSubDirs()
     }
 }
 
-void storeInit()
+void
+storeInit(void)
 {
     int dir_created;
     wordlist *w = NULL;
@@ -2558,7 +2529,8 @@ void storeInit()
 	storeCreateSwapSubDirs();
 }
 
-void storeConfigure()
+void
+storeConfigure(void)
 {
     store_mem_high = (long) (Config.Mem.maxSize / 100) *
 	Config.Mem.highWaterMark;
@@ -2592,7 +2564,8 @@ void storeConfigure()
  *  storeSanityCheck - verify that all swap storage areas exist, and
  *  are writable; otherwise, force -z.
  */
-void storeSanityCheck()
+void
+storeSanityCheck(void)
 {
     LOCAL_ARRAY(char, name, 4096);
     int i;
@@ -2620,8 +2593,8 @@ void storeSanityCheck()
     }
 }
 
-int urlcmp(url1, url2)
-     char *url1, *url2;
+int
+urlcmp(char *url1, char *url2)
 {
     if (!url1 || !url2)
 	fatal_dump("urlcmp: Got a NULL url pointer.");
@@ -2635,7 +2608,8 @@ int urlcmp(url1, url2)
  *
  * This should get called 1/s from main().
  */
-int storeMaintainSwapSpace()
+int
+storeMaintainSwapSpace(void)
 {
     static time_t last_time = 0;
     static unsigned int bucket = 0;
@@ -2677,7 +2651,8 @@ int storeMaintainSwapSpace()
  * 
  *  Writes a "clean" swap log file from in-memory metadata.
  */
-int storeWriteCleanLog()
+int
+storeWriteCleanLog(void)
 {
     StoreEntry *e = NULL;
     LOCAL_ARRAY(char, swapfilename, MAX_FILE_NAME_LEN);
@@ -2762,16 +2737,15 @@ int storeWriteCleanLog()
     return n;
 }
 
-int swapInError(fd_unused, entry)
-     int fd_unused;
-     StoreEntry *entry;
+int
+swapInError(int fd_unused, StoreEntry * entry)
 {
     squid_error_entry(entry, ERR_DISK_IO, xstrerror());
     return 0;
 }
 
-int storePendingNClients(e)
-     StoreEntry *e;
+int
+storePendingNClients(StoreEntry * e)
 {
     int npend = 0;
     int i;
@@ -2785,7 +2759,8 @@ int storePendingNClients(e)
     return npend;
 }
 
-void storeRotateLog()
+void
+storeRotateLog(void)
 {
     char *fname = NULL;
     int i;
@@ -2828,8 +2803,8 @@ void storeRotateLog()
  * leave the StoreEntry around.  Designed to be called from
  * storeUnlockObject() and storeSwapOutHandle().
  */
-static int storeCheckPurgeMem(e)
-     StoreEntry *e;
+static int
+storeCheckPurgeMem(StoreEntry * e)
 {
     if (storeEntryLocked(e))
 	return 0;
@@ -2840,8 +2815,8 @@ static int storeCheckPurgeMem(e)
     return 1;
 }
 
-static int storeCheckExpired(e)
-     StoreEntry *e;
+static int
+storeCheckExpired(StoreEntry * e)
 {
     if (storeEntryLocked(e))
 	return 0;
@@ -2850,8 +2825,8 @@ static int storeCheckExpired(e)
     return 1;
 }
 
-static char *storeDescribeStatus(e)
-     StoreEntry *e;
+static char *
+storeDescribeStatus(StoreEntry * e)
 {
     static char buf[MAX_URL << 1];
     sprintf(buf, "mem:%13s ping:%12s store:%13s swap:%12s locks:%d %s\n",
@@ -2864,14 +2839,15 @@ static char *storeDescribeStatus(e)
     return buf;
 }
 
-void storeCloseLog()
+void
+storeCloseLog(void)
 {
     file_close(swaplog_fd);
     file_close(storelog_fd);
 }
 
-void storeNegativeCache(e)
-     StoreEntry *e;
+void
+storeNegativeCache(StoreEntry * e)
 {
     e->expires = squid_curtime + Config.negativeTtl;
     BIT_SET(e->flag, ENTRY_NEGCACHED);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: tools.cc,v 1.56 1996/09/12 22:18:01 wessels Exp $
+ * $Id: tools.cc,v 1.57 1996/09/14 08:46:34 wessels Exp $
  *
  * DEBUG: section 21    Misc Functions
  * AUTHOR: Harvest Derived
@@ -120,14 +120,16 @@ and report the trace back to squid-bugs@nlanr.net.\n\
 \n\
 Thanks!\n"
 
-static char *dead_msg()
+static char *
+dead_msg()
 {
     LOCAL_ARRAY(char, msg, 1024);
     sprintf(msg, DEAD_MSG, version_string, version_string);
     return msg;
 }
 
-void mail_warranty()
+void
+mail_warranty()
 {
     FILE *fp = NULL;
     char *filename;
@@ -145,8 +147,8 @@ void mail_warranty()
     unlink(filename);
 }
 
-static void dumpMallocStats(f)
-     FILE *f;
+static void
+dumpMallocStats(FILE * f)
 {
 #if HAVE_MALLINFO
     struct mallinfo mp;
@@ -197,9 +199,8 @@ static void dumpMallocStats(f)
 #endif /* HAVE_MALLINFO */
 }
 
-static int PrintRusage(f, lf)
-     void (*f) ();
-     FILE *lf;
+static int
+PrintRusage(void (*f) (), FILE * lf)
 {
 #if HAVE_GETRUSAGE && defined(RUSAGE_SELF)
     struct rusage rusage;
@@ -217,8 +218,8 @@ static int PrintRusage(f, lf)
     return 0;
 }
 
-void death(sig)
-     int sig;
+void
+death(int sig)
 {
     if (sig == SIGSEGV)
 	fprintf(debug_log, "FATAL: Received Segment Violation...dying.\n");
@@ -244,8 +245,8 @@ void death(sig)
 }
 
 
-void sigusr2_handle(sig)
-     int sig;
+void
+sigusr2_handle(int sig)
 {
     static int state = 0;
     debug(21, 1, "sigusr2_handle: SIGUSR2 received.\n");
@@ -261,7 +262,8 @@ void sigusr2_handle(sig)
 #endif
 }
 
-void setSocketShutdownLifetimes()
+void
+setSocketShutdownLifetimes()
 {
     FD_ENTRY *f = NULL;
     int lft = Config.lifetimeShutdown;
@@ -280,7 +282,8 @@ void setSocketShutdownLifetimes()
     }
 }
 
-void normal_shutdown()
+void
+normal_shutdown()
 {
     debug(21, 1, "Shutting down...\n");
     if (Config.pidFilename) {
@@ -298,8 +301,8 @@ void normal_shutdown()
     exit(0);
 }
 
-void fatal_common(message)
-     char *message;
+void
+fatal_common(char *message)
 {
 #if HAVE_SYSLOG
     if (opt_syslog_enable)
@@ -313,16 +316,16 @@ void fatal_common(message)
 }
 
 /* fatal */
-void fatal(message)
-     char *message;
+void
+fatal(char *message)
 {
     fatal_common(message);
     exit(1);
 }
 
 /* fatal with dumping core */
-void fatal_dump(message)
-     char *message;
+void
+fatal_dump(char *message)
 {
     if (message)
 	fatal_common(message);
@@ -332,16 +335,16 @@ void fatal_dump(message)
 }
 
 /* fatal with dumping core */
-void _debug_trap(message)
-     char *message;
+void
+_debug_trap(char *message)
 {
     if (opt_catch_signals)
 	fatal_dump(message);
     _db_print(0, 0, "WARNING: %s\n", message);
 }
 
-void sig_child(sig)
-     int sig;
+void
+sig_child(int sig)
 {
 #ifdef _SQUID_NEXT_
     union wait status;
@@ -365,7 +368,8 @@ void sig_child(sig)
 #endif
 }
 
-char *getMyHostname()
+char *
+getMyHostname()
 {
     LOCAL_ARRAY(char, host, SQUIDHOSTNAMELEN + 1);
     static int present = 0;
@@ -394,9 +398,8 @@ char *getMyHostname()
     return host;
 }
 
-int safeunlink(s, quiet)
-     char *s;
-     int quiet;
+int
+safeunlink(char *s, int quiet)
 {
     int err;
     if ((err = unlink(s)) < 0)
@@ -410,7 +413,8 @@ int safeunlink(s, quiet)
  * and leave_suid()
  * To give upp all posibilites to gain privilegies use no_suid()
  */
-void leave_suid()
+void
+leave_suid()
 {
     struct passwd *pwd = NULL;
     struct group *grp = NULL;
@@ -439,7 +443,8 @@ void leave_suid()
 }
 
 /* Enter a privilegied section */
-void enter_suid()
+void
+enter_suid()
 {
     debug(21, 3, "enter_suid: PID %d taking root priveleges\n", getpid());
 #if HAVE_SETRESUID
@@ -452,7 +457,8 @@ void enter_suid()
 /* Give up the posibility to gain privilegies.
  * this should be used before starting a sub process
  */
-void no_suid()
+void
+no_suid()
 {
     uid_t uid;
     leave_suid();
@@ -466,7 +472,8 @@ void no_suid()
 #endif
 }
 
-void writePidFile()
+void
+writePidFile()
 {
     FILE *pid_fp = NULL;
     char *f = NULL;
@@ -486,7 +493,8 @@ void writePidFile()
 }
 
 
-int readPidFile()
+int
+readPidFile()
 {
     FILE *pid_fp = NULL;
     char *f = NULL;
@@ -512,7 +520,8 @@ int readPidFile()
 }
 
 
-void setMaxFD()
+void
+setMaxFD()
 {
 #if HAVE_SETRLIMIT
     /* try to use as many file descriptors as possible */
@@ -560,7 +569,8 @@ void setMaxFD()
 #endif /* RLIMIT_DATA */
 }
 
-time_t getCurrentTime()
+time_t
+getCurrentTime()
 {
 #if GETTIMEOFDAY_NO_TZP
     gettimeofday(&current_time);
@@ -570,25 +580,21 @@ time_t getCurrentTime()
     return squid_curtime = current_time.tv_sec;
 }
 
-int tvSubMsec(t1, t2)
-     struct timeval t1;
-     struct timeval t2;
+int
+tvSubMsec(struct timeval t1, struct timeval t2)
 {
     return (t2.tv_sec - t1.tv_sec) * 1000 +
 	(t2.tv_usec - t1.tv_usec) / 1000;
 }
 
-int percent(a, b)
-     int a;
-     int b;
+int
+percent(int a, int b)
 {
     return b ? ((int) (100.0 * a / b + 0.5)) : 0;
 }
 
-void squid_signal(sig, func, flags)
-     int sig;
-     void (*func) ();
-     int flags;
+void
+squid_signal(int sig, void (*func) (), int flags)
 {
 #if HAVE_SIGACTION
     struct sigaction sa;
@@ -602,8 +608,8 @@ void squid_signal(sig, func, flags)
 #endif
 }
 
-char *accessLogTime(t)
-     time_t t;
+char *
+accessLogTime(time_t t)
 {
     struct tm *tm;
     static char buf[128];
@@ -1,6 +1,6 @@
 
 /*
- * $Id: tunnel.cc,v 1.13 1996/08/31 06:40:20 wessels Exp $
+ * $Id: tunnel.cc,v 1.14 1996/09/14 08:46:24 wessels Exp $
  *
  * DEBUG: section 26    Secure Sockets Layer Proxy
  * AUTHOR: Duane Wessels
@@ -49,22 +49,22 @@ typedef struct {
 
 static char conn_established[] = "HTTP/1.0 200 Connection established\r\n\r\n";
 
-static void sslLifetimeExpire _PARAMS((int fd, SslStateData * sslState));
-static void sslReadTimeout _PARAMS((int fd, SslStateData * sslState));
-static void sslReadServer _PARAMS((int fd, SslStateData * sslState));
-static void sslReadClient _PARAMS((int fd, SslStateData * sslState));
-static void sslWriteServer _PARAMS((int fd, SslStateData * sslState));
-static void sslWriteClient _PARAMS((int fd, SslStateData * sslState));
-static void sslConnected _PARAMS((int fd, SslStateData * sslState));
-static void sslProxyConnected _PARAMS((int fd, SslStateData * sslState));
-static int sslConnect _PARAMS((int fd, struct hostent *, SslStateData *));
-static void sslConnInProgress _PARAMS((int fd, SslStateData * sslState));
-static void sslErrorComplete _PARAMS((int, char *, int, int, void *));
-static void sslClose _PARAMS((SslStateData * sslState));
-static int sslClientClosed _PARAMS((int fd, SslStateData * sslState));
+static void sslLifetimeExpire(int fd, SslStateData * sslState);
+static void sslReadTimeout(int fd, SslStateData * sslState);
+static void sslReadServer(int fd, SslStateData * sslState);
+static void sslReadClient(int fd, SslStateData * sslState);
+static void sslWriteServer(int fd, SslStateData * sslState);
+static void sslWriteClient(int fd, SslStateData * sslState);
+static void sslConnected(int fd, SslStateData * sslState);
+static void sslProxyConnected(int fd, SslStateData * sslState);
+static int sslConnect(int fd, struct hostent *, SslStateData *);
+static void sslConnInProgress(int fd, SslStateData * sslState);
+static void sslErrorComplete(int, char *, int, int, void *);
+static void sslClose(SslStateData * sslState);
+static int sslClientClosed(int fd, SslStateData * sslState);
 
-static void sslClose(sslState)
-     SslStateData *sslState;
+static void
+sslClose(SslStateData * sslState)
 {
     if (sslState->client.fd > -1) {
 	/* remove the "unexpected" client close handler */
@@ -81,9 +81,8 @@ static void sslClose(sslState)
 
 /* This is called only if the client connect closes unexpectedly,
  * ie from icpDetectClientClose() */
-static int sslClientClosed(fd, sslState)
-     int fd;
-     SslStateData *sslState;
+static int
+sslClientClosed(int fd, SslStateData * sslState)
 {
     debug(26, 3, "sslClientClosed: FD %d\n", fd);
     /* we have been called from comm_close for the client side, so
@@ -96,9 +95,8 @@ static int sslClientClosed(fd, sslState)
     return 0;
 }
 
-static int sslStateFree(fd, sslState)
-     int fd;
-     SslStateData *sslState;
+static int
+sslStateFree(int fd, SslStateData * sslState)
 {
     debug(26, 3, "sslStateFree: FD %d, sslState=%p\n", fd, sslState);
     if (sslState == NULL)
@@ -119,19 +117,17 @@ static int sslStateFree(fd, sslState)
 }
 
 /* This will be called when the server lifetime is expired. */
-static void sslLifetimeExpire(fd, sslState)
-     int fd;
-     SslStateData *sslState;
+static void
+sslLifetimeExpire(int fd, SslStateData * sslState)
 {
     debug(26, 4, "sslLifeTimeExpire: FD %d: URL '%s'>\n",
 	fd, sslState->url);
     sslClose(sslState);
 }
 
 /* Read from server side and queue it for writing to the client */
-static void sslReadServer(fd, sslState)
-     int fd;
-     SslStateData *sslState;
+static void
+sslReadServer(int fd, SslStateData * sslState)
 {
     int len;
     len = read(sslState->server.fd, sslState->server.buf, SQUID_TCP_SO_RCVBUF);
@@ -168,9 +164,8 @@ static void sslReadServer(fd, sslState)
 }
 
 /* Read from client side and queue it for writing to the server */
-static void sslReadClient(fd, sslState)
-     int fd;
-     SslStateData *sslState;
+static void
+sslReadClient(int fd, SslStateData * sslState)
 {
     int len;
     len = read(sslState->client.fd, sslState->client.buf, SQUID_TCP_SO_RCVBUF);
@@ -203,9 +198,8 @@ static void sslReadClient(fd, sslState)
 }
 
 /* Writes data from the client buffer to the server side */
-static void sslWriteServer(fd, sslState)
-     int fd;
-     SslStateData *sslState;
+static void
+sslWriteServer(int fd, SslStateData * sslState)
 {
     int len;
     len = write(sslState->server.fd,
@@ -239,9 +233,8 @@ static void sslWriteServer(fd, sslState)
 }
 
 /* Writes data from the server buffer to the client side */
-static void sslWriteClient(fd, sslState)
-     int fd;
-     SslStateData *sslState;
+static void
+sslWriteClient(int fd, SslStateData * sslState)
 {
     int len;
     debug(26, 5, "sslWriteClient FD %d len=%d offset=%d\n",
@@ -275,17 +268,15 @@ static void sslWriteClient(fd, sslState)
     }
 }
 
-static void sslReadTimeout(fd, sslState)
-     int fd;
-     SslStateData *sslState;
+static void
+sslReadTimeout(int fd, SslStateData * sslState)
 {
     debug(26, 3, "sslReadTimeout: FD %d\n", fd);
     sslClose(sslState);
 }
 
-static void sslConnected(fd, sslState)
-     int fd;
-     SslStateData *sslState;
+static void
+sslConnected(int fd, SslStateData * sslState)
 {
     debug(26, 3, "sslConnected: FD %d sslState=%p\n", fd, sslState);
     strcpy(sslState->server.buf, conn_established);
@@ -302,21 +293,16 @@ static void sslConnected(fd, sslState)
 	(void *) sslState);
 }
 
-static void sslErrorComplete(fd, buf, size, errflag, sslState)
-     int fd;
-     char *buf;
-     int size;
-     int errflag;
-     void *sslState;
+static void
+sslErrorComplete(int fd, char *buf, int size, int errflag, void *sslState)
 {
     safe_free(buf);
     sslClose(sslState);
 }
 
 
-static void sslConnInProgress(fd, sslState)
-     int fd;
-     SslStateData *sslState;
+static void
+sslConnInProgress(int fd, SslStateData * sslState)
 {
     char *buf = NULL;
     debug(26, 5, "sslConnInProgress: FD %d sslState=%p\n", fd, sslState);
@@ -360,10 +346,8 @@ static void sslConnInProgress(fd, sslState)
     return;
 }
 
-static int sslConnect(fd, hp, sslState)
-     int fd;
-     struct hostent *hp;
-     SslStateData *sslState;
+static int
+sslConnect(int fd, struct hostent *hp, SslStateData * sslState)
 {
     request_t *request = sslState->request;
     int status;
@@ -437,12 +421,8 @@ static int sslConnect(fd, hp, sslState)
     return COMM_OK;
 }
 
-int sslStart(fd, url, request, mime_hdr, size_ptr)
-     int fd;
-     char *url;
-     request_t *request;
-     char *mime_hdr;
-     int *size_ptr;
+int
+sslStart(int fd, char *url, request_t * request, char *mime_hdr, int *size_ptr)
 {
     /* Create state structure. */
     SslStateData *sslState = NULL;
@@ -506,9 +486,8 @@ int sslStart(fd, url, request, mime_hdr, size_ptr)
     return COMM_OK;
 }
 
-static void sslProxyConnected(fd, sslState)
-     int fd;
-     SslStateData *sslState;
+static void
+sslProxyConnected(int fd, SslStateData * sslState)
 {
     debug(26, 3, "sslProxyConnected: FD %d sslState=%p\n", fd, sslState);
     sprintf(sslState->client.buf, "CONNECT %s HTTP/1.0\r\n\r\n", sslState->url);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: url.cc,v 1.32 1996/09/03 19:24:08 wessels Exp $
+ * $Id: url.cc,v 1.33 1996/09/14 08:46:36 wessels Exp $
  *
  * DEBUG: section 23    URL Parsing
  * AUTHOR: Duane Wessels
@@ -58,9 +58,8 @@ static char hex[17] = "0123456789abcdef";
 /* convert %xx in url string to a character 
  * Allocate a new string and return a pointer to converted string */
 
-char *url_convert_hex(org_url, allocate)
-     char *org_url;
-     int allocate;
+char *
+url_convert_hex(char *org_url, int allocate)
 {
     static char code[] = "00";
     char *url = NULL;
@@ -90,7 +89,8 @@ char *url_convert_hex(org_url, allocate)
 
 /* INIT Acceptable table. 
  * Borrow from libwww2 with Mosaic2.4 Distribution   */
-void urlInitialize()
+void
+urlInitialize()
 {
     unsigned int i;
     char *good =
@@ -105,8 +105,8 @@ void urlInitialize()
 
 /* Encode prohibited char in string */
 /* return the pointer to new (allocated) string */
-char *url_escape(url)
-     char *url;
+char *
+url_escape(char *url)
 {
     char *p, *q;
     char *tmpline = xcalloc(1, MAX_URL);
@@ -125,8 +125,8 @@ char *url_escape(url)
     return tmpline;
 }
 
-method_t urlParseMethod(s)
-     char *s;
+method_t
+urlParseMethod(char *s)
 {
     if (strcasecmp(s, "GET") == 0) {
 	return METHOD_GET;
@@ -143,8 +143,8 @@ method_t urlParseMethod(s)
 }
 
 
-protocol_t urlParseProtocol(s)
-     char *s;
+protocol_t
+urlParseProtocol(char *s)
 {
     if (strncasecmp(s, "http", 4) == 0)
 	return PROTO_HTTP;
@@ -166,8 +166,8 @@ protocol_t urlParseProtocol(s)
 }
 
 
-int urlDefaultPort(p)
-     protocol_t p;
+int
+urlDefaultPort(protocol_t p)
 {
     switch (p) {
     case PROTO_HTTP:
@@ -185,9 +185,8 @@ int urlDefaultPort(p)
     }
 }
 
-request_t *urlParse(method, url)
-     method_t method;
-     char *url;
+request_t *
+urlParse(method_t method, char *url)
 {
     LOCAL_ARRAY(char, proto, MAX_URL + 1);
     LOCAL_ARRAY(char, login, MAX_URL + 1);
@@ -247,9 +246,8 @@ request_t *urlParse(method, url)
     return request;
 }
 
-char *urlCanonical(request, buf)
-     request_t *request;
-     char *buf;
+char *
+urlCanonical(request_t * request, char *buf)
 {
     LOCAL_ARRAY(char, urlbuf, MAX_URL + 1);
     LOCAL_ARRAY(char, portbuf, 32);
@@ -275,15 +273,15 @@ char *urlCanonical(request, buf)
     return buf;
 }
 
-request_t *requestLink(request)
-     request_t *request;
+request_t *
+requestLink(request_t * request)
 {
     request->link_count++;
     return request;
 }
 
-void requestUnlink(request)
-     request_t *request;
+void
+requestUnlink(request_t * request)
 {
     if (request == NULL)
 	return;
@@ -294,9 +292,8 @@ void requestUnlink(request)
     put_free_request_t(request);
 }
 
-int matchDomainName(domain, host)
-     char *domain;
-     char *host;
+int
+matchDomainName(char *domain, char *host)
 {
     int offset;
     if ((offset = strlen(host) - strlen(domain)) < 0)
@@ -312,8 +309,8 @@ int matchDomainName(domain, host)
     return 0;
 }
 
-int urlCheckRequest(r)
-     request_t *r;
+int
+urlCheckRequest(request_t * r)
 {
     int rc = 0;
     if (r->method == METHOD_CONNECT)
@@ -1,6 +1,6 @@
 
 /*
- * $Id: wais.cc,v 1.39 1996/09/12 22:18:01 wessels Exp $
+ * $Id: wais.cc,v 1.40 1996/09/14 08:46:38 wessels Exp $
  *
  * DEBUG: section 24    WAIS Relay
  * AUTHOR: Harvest Derived
@@ -118,18 +118,17 @@ typedef struct {
     char request[MAX_URL + 1];
 } WaisStateData;
 
-static int waisStateFree _PARAMS((int, WaisStateData *));
-static void waisReadReplyTimeout _PARAMS((int, WaisStateData *));
-static void waisLifetimeExpire _PARAMS((int, WaisStateData *));
-static void waisReadReply _PARAMS((int, WaisStateData *));
-static void waisSendComplete _PARAMS((int, char *, int, int, void *));
-static void waisSendRequest _PARAMS((int, WaisStateData *));
-static void waisConnInProgress _PARAMS((int, WaisStateData *));
-static int waisConnect _PARAMS((int, struct hostent *, WaisStateData *));
+static int waisStateFree(int, WaisStateData *);
+static void waisReadReplyTimeout(int, WaisStateData *);
+static void waisLifetimeExpire(int, WaisStateData *);
+static void waisReadReply(int, WaisStateData *);
+static void waisSendComplete(int, char *, int, int, void *);
+static void waisSendRequest(int, WaisStateData *);
+static void waisConnInProgress(int, WaisStateData *);
+static int waisConnect(int, struct hostent *, WaisStateData *);
 
-static int waisStateFree(fd, waisState)
-     int fd;
-     WaisStateData *waisState;
+static int
+waisStateFree(int fd, WaisStateData * waisState)
 {
     if (waisState == NULL)
 	return 1;
@@ -139,9 +138,8 @@ static int waisStateFree(fd, waisState)
 }
 
 /* This will be called when timeout on read. */
-static void waisReadReplyTimeout(fd, waisState)
-     int fd;
-     WaisStateData *waisState;
+static void
+waisReadReplyTimeout(int fd, WaisStateData * waisState)
 {
     StoreEntry *entry = NULL;
 
@@ -153,9 +151,8 @@ static void waisReadReplyTimeout(fd, waisState)
 }
 
 /* This will be called when socket lifetime is expired. */
-static void waisLifetimeExpire(fd, waisState)
-     int fd;
-     WaisStateData *waisState;
+static void
+waisLifetimeExpire(int fd, WaisStateData * waisState)
 {
     StoreEntry *entry = NULL;
 
@@ -170,9 +167,8 @@ static void waisLifetimeExpire(fd, waisState)
 
 /* This will be called when data is ready to be read from fd.  Read until
  * error or connection closed. */
-static void waisReadReply(fd, waisState)
-     int fd;
-     WaisStateData *waisState;
+static void
+waisReadReply(int fd, WaisStateData * waisState)
 {
     LOCAL_ARRAY(char, buf, 4096);
     int len;
@@ -286,12 +282,8 @@ static void waisReadReply(fd, waisState)
 
 /* This will be called when request write is complete. Schedule read of
  * reply. */
-static void waisSendComplete(fd, buf, size, errflag, data)
-     int fd;
-     char *buf;
-     int size;
-     int errflag;
-     void *data;
+static void
+waisSendComplete(int fd, char *buf, int size, int errflag, void *data)
 {
     StoreEntry *entry = NULL;
     WaisStateData *waisState = data;
@@ -316,9 +308,8 @@ static void waisSendComplete(fd, buf, size, errflag, data)
 }
 
 /* This will be called when connect completes. Write request. */
-static void waisSendRequest(fd, waisState)
-     int fd;
-     WaisStateData *waisState;
+static void
+waisSendRequest(int fd, WaisStateData * waisState)
 {
     int len = strlen(waisState->request) + 4;
     char *buf = NULL;
@@ -350,9 +341,8 @@ static void waisSendRequest(fd, waisState)
 	storeSetPublicKey(waisState->entry);	/* Make it public */
 }
 
-static void waisConnInProgress(fd, waisState)
-     int fd;
-     WaisStateData *waisState;
+static void
+waisConnInProgress(int fd, WaisStateData * waisState)
 {
     StoreEntry *entry = waisState->entry;
 
@@ -382,12 +372,8 @@ static void waisConnInProgress(fd, waisState)
 	(PF) waisSendRequest, (void *) waisState);
 }
 
-int waisStart(unusedfd, url, method, mime_hdr, entry)
-     int unusedfd;
-     char *url;
-     method_t method;
-     char *mime_hdr;
-     StoreEntry *entry;
+int
+waisStart(int unusedfd, char *url, method_t method, char *mime_hdr, StoreEntry * entry)
 {
     WaisStateData *waisState = NULL;
     int fd;
@@ -424,10 +410,8 @@ int waisStart(unusedfd, url, method, mime_hdr, entry)
 }
 
 
-static int waisConnect(fd, hp, waisState)
-     int fd;
-     struct hostent *hp;
-     WaisStateData *waisState;
+static int
+waisConnect(int fd, struct hostent *hp, WaisStateData * waisState)
 {
     int status;
     char *host = waisState->relayhost;