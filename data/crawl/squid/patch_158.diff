@@ -444,19 +444,19 @@ const char *BodyPipe::status() const
 
     outputBuffer.append(" [", 2);
 
-    outputBuffer.Printf("%" PRIu64 "<=%" PRIu64, theGetSize, thePutSize);
+    outputBuffer.appendf("%" PRIu64 "<=%" PRIu64, theGetSize, thePutSize);
     if (theBodySize >= 0)
-        outputBuffer.Printf("<=%" PRId64, theBodySize);
+        outputBuffer.appendf("<=%" PRId64, theBodySize);
     else
         outputBuffer.append("<=?", 3);
 
-    outputBuffer.Printf(" %d+%d", (int)theBuf.contentSize(), (int)theBuf.spaceSize());
+    outputBuffer.appendf(" %" PRId64 "+%" PRId64, static_cast<int64_t>(theBuf.contentSize()), static_cast<int64_t>(theBuf.spaceSize()));
 
-    outputBuffer.Printf(" pipe%p", this);
+    outputBuffer.appendf(" pipe%p", this);
     if (theProducer.set())
-        outputBuffer.Printf(" prod%p", theProducer.get());
+        outputBuffer.appendf(" prod%p", theProducer.get());
     if (theConsumer.set())
-        outputBuffer.Printf(" cons%p", theConsumer.get());
+        outputBuffer.appendf(" cons%p", theConsumer.get());
 
     if (mustAutoConsume)
         outputBuffer.append(" A", 2);
@@ -39,11 +39,11 @@ HttpBody::setMb(MemBuf * mb_)
 }
 
 void
-HttpBody::packInto(Packer * p) const
+HttpBody::packInto(Packable * p) const
 {
     assert(p);
 
     if (mb->contentSize())
-        packerAppend(p, mb->content(), mb->contentSize());
+        p->append(mb->content(), mb->contentSize());
 }
 
@@ -10,7 +10,6 @@
 #define HTTPBODY_H_
 
 #include "MemBuf.h"
-class Packer;
 
 /** Representation of a short predetermined message
  *
@@ -28,11 +27,12 @@ class HttpBody
      * by the HttpBody.
      */
     void setMb(MemBuf *);
-    /** output the HttpBody contents into the supplied packer
+
+    /** output the HttpBody contents into the supplied container
      *
      * \note content is not cleared by the output operation
      */
-    void packInto(Packer *) const;
+    void packInto(Packable *) const;
 
     /// clear the HttpBody content
     void clear();
@@ -251,7 +251,7 @@ HttpHdrCc::parse(const String & str)
 }
 
 void
-HttpHdrCc::packInto(Packer * p) const
+HttpHdrCc::packInto(Packable * p) const
 {
     // optimization: if the mask is empty do nothing
     if (mask==0)
@@ -265,24 +265,24 @@ HttpHdrCc::packInto(Packer * p) const
         if (isSet(flag) && flag != CC_OTHER) {
 
             /* print option name for all options */
-            packerPrintf(p, (pcount ? ", %s": "%s") , CcAttrs[flag].name);
+            p->appendf((pcount ? ", %s": "%s") , CcAttrs[flag].name);
 
             /* for all options having values, "=value" after the name */
             switch (flag) {
             case CC_MAX_AGE:
-                packerPrintf(p, "=%d", (int) maxAge());
+                p->appendf("=%d", maxAge());
                 break;
             case CC_S_MAXAGE:
-                packerPrintf(p, "=%d", (int) sMaxAge());
+                p->appendf("=%d", sMaxAge());
                 break;
             case CC_MAX_STALE:
                 /* max-stale's value is optional.
                   If we didn't receive it, don't send it */
                 if (maxStale()!=MAX_STALE_ANY)
-                    packerPrintf(p, "=%d", (int) maxStale());
+                    p->appendf("=%d", maxStale());
                 break;
             case CC_MIN_FRESH:
-                packerPrintf(p, "=%d", (int) minFresh());
+                p->appendf("=%d", minFresh());
                 break;
             default:
                 /* do nothing, directive was already printed */
@@ -294,8 +294,7 @@ HttpHdrCc::packInto(Packer * p) const
     }
 
     if (other.size() != 0)
-        packerPrintf(p, (pcount ? ", " SQUIDSTRINGPH : SQUIDSTRINGPH),
-                     SQUIDSTRINGPRINT(other));
+        p->appendf((pcount ? ", " SQUIDSTRINGPH : SQUIDSTRINGPH), SQUIDSTRINGPRINT(other));
 }
 
 void
@@ -13,7 +13,7 @@
 #include "mem/forward.h"
 #include "SquidString.h"
 
-class Packer;
+class Packable;
 
 /** Http Cache-Control header representation
  *
@@ -144,7 +144,7 @@ class HttpHdrCc
     /// check whether the attribute value supplied by id is set
     _SQUID_INLINE_ bool isSet(http_hdr_cc_type id) const;
 
-    void packInto(Packer * p) const;
+    void packInto(Packable * p) const;
 
     /** bit-mask representing what header values are set among those
      * recognized by squid.
@@ -9,6 +9,7 @@
 /* DEBUG: section 68    HTTP Content-Range Header */
 
 #include "squid.h"
+#include "base/Packable.h"
 #include "Debug.h"
 #include "enums.h"
 #include "HttpHdrContRange.h"
@@ -98,16 +99,15 @@ httpHdrRangeRespSpecParseInit(HttpHdrRangeSpec * spec, const char *field, int fl
 }
 
 static void
-httpHdrRangeRespSpecPackInto(const HttpHdrRangeSpec * spec, Packer * p)
+httpHdrRangeRespSpecPackInto(const HttpHdrRangeSpec * spec, Packable * p)
 {
     /* Ensure typecast is safe */
     assert (spec->length >= 0);
 
     if (!known_spec(spec->offset) || !known_spec(spec->length))
-        packerPrintf(p, "*");
+        p->append("*", 1);
     else
-        packerPrintf(p, "bytes %" PRId64 "-%" PRId64,
-                     spec->offset, spec->offset + spec->length - 1);
+        p->appendf("bytes %" PRId64 "-%" PRId64, spec->offset, spec->offset + spec->length - 1);
 }
 
 /*
@@ -200,17 +200,17 @@ httpHdrContRangeDup(const HttpHdrContRange * range)
 }
 
 void
-httpHdrContRangePackInto(const HttpHdrContRange * range, Packer * p)
+httpHdrContRangePackInto(const HttpHdrContRange * range, Packable * p)
 {
     assert(range && p);
     httpHdrRangeRespSpecPackInto(&range->spec, p);
     /* Ensure typecast is safe */
     assert (range->elength >= 0);
 
     if (!known_spec(range->elength))
-        packerPrintf(p, "/*");
+        p->append("/*", 2);
     else
-        packerPrintf(p, "/%" PRId64, range->elength);
+        p->appendf("/%" PRId64, range->elength);
 }
 
 void
@@ -31,7 +31,7 @@ HttpHdrContRange *httpHdrContRangeParseCreate(const char *crange_spec);
 int httpHdrContRangeParseInit(HttpHdrContRange * crange, const char *crange_spec);
 void httpHdrContRangeDestroy(HttpHdrContRange * crange);
 HttpHdrContRange *httpHdrContRangeDup(const HttpHdrContRange * crange);
-void httpHdrContRangePackInto(const HttpHdrContRange * crange, Packer * p);
+void httpHdrContRangePackInto(const HttpHdrContRange * crange, Packable * p);
 /** inits with given spec */
 void httpHdrContRangeSet(HttpHdrContRange *, HttpHdrRangeSpec, int64_t);
 void httpHeaderAddContRange(HttpHeader *, HttpHdrRangeSpec, int64_t);
@@ -105,15 +105,14 @@ HttpHdrRangeSpec::parseInit(const char *field, int flen)
 }
 
 void
-HttpHdrRangeSpec::packInto(Packer * packer) const
+HttpHdrRangeSpec::packInto(Packable * p) const
 {
     if (!known_spec(offset))    /* suffix */
-        packerPrintf(packer, "-%" PRId64,  length);
+        p->appendf("-%" PRId64, length);
     else if (!known_spec(length))       /* trailer */
-        packerPrintf(packer, "%" PRId64 "-", offset);
+        p->appendf("%" PRId64 "-", offset);
     else            /* range */
-        packerPrintf(packer, "%" PRId64 "-%" PRId64,
-                     offset, offset + length - 1);
+        p->appendf("%" PRId64 "-%" PRId64, offset, offset + length - 1);
 }
 
 void
@@ -303,13 +302,13 @@ HttpHdrRange::end() const
 }
 
 void
-HttpHdrRange::packInto(Packer * packer) const
+HttpHdrRange::packInto(Packable * packer) const
 {
     const_iterator pos = begin();
 
     while (pos != end()) {
         if (pos != begin())
-            packerAppend(packer, ",", 1);
+            packer->append(",", 1);
 
         (*pos)->packInto(packer);
 
@@ -235,7 +235,7 @@ HttpHdrSc::HttpHdrSc(const HttpHdrSc &sc)
 }
 
 void
-HttpHdrScTarget::packInto(Packer * p) const
+HttpHdrScTarget::packInto(Packable * p) const
 {
     http_hdr_sc_type flag;
     int pcount = 0;
@@ -245,27 +245,27 @@ HttpHdrScTarget::packInto(Packer * p) const
         if (isSet(flag) && flag != SC_OTHER) {
 
             /* print option name */
-            packerPrintf(p, (pcount ? ", " SQUIDSTRINGPH : SQUIDSTRINGPH),
+            p->appendf((pcount ? ", " SQUIDSTRINGPH : SQUIDSTRINGPH),
                          SQUIDSTRINGPRINT(ScFieldsInfo[flag].name));
 
             /* handle options with values */
 
             if (flag == SC_MAX_AGE)
-                packerPrintf(p, "=%d", (int) max_age);
+                p->appendf("=%d", (int) max_age);
 
             if (flag == SC_CONTENT)
-                packerPrintf(p, "=\"" SQUIDSTRINGPH "\"", SQUIDSTRINGPRINT(content_));
+                p->appendf("=\"" SQUIDSTRINGPH "\"", SQUIDSTRINGPRINT(content_));
 
             ++pcount;
         }
     }
 
     if (hasTarget())
-        packerPrintf (p, ";" SQUIDSTRINGPH, SQUIDSTRINGPRINT(target));
+        p->appendf(";" SQUIDSTRINGPH, SQUIDSTRINGPRINT(target));
 }
 
 void
-HttpHdrSc::packInto(Packer * p) const
+HttpHdrSc::packInto(Packable * p) const
 {
     dlink_node *node;
     assert(p);
@@ -25,7 +25,7 @@ class HttpHdrSc
     ~HttpHdrSc();
 
     bool parse(const String *str);
-    void packInto(Packer * p) const;
+    void packInto(Packable * p) const;
     void updateStats(StatHist *) const;
     HttpHdrScTarget * getMergedTarget (const char *ourtarget); //todo: make const?
     void setMaxAge(char const *target, int max_age);
@@ -15,8 +15,8 @@
 #include "SquidString.h"
 #include "typedefs.h"
 
+class Packable;
 class StatHist;
-class Packer;
 class StoreEntry;
 
 /** Representation of HTTP Surogate-Control header field targeted directive
@@ -82,7 +82,7 @@ class HttpHdrScTarget
     String Target() const { return target; }
 
     void mergeWith(const HttpHdrScTarget * new_sc);
-    void packInto (Packer *p) const;
+    void packInto(Packable *p) const;
     void updateStats(StatHist *) const;
 
 private:
@@ -735,7 +735,7 @@ HttpHeader::parse(const char *header_start, size_t hdrLen)
 
 /* packs all the entries using supplied packer */
 void
-HttpHeader::packInto(Packer * p, bool mask_sensitive_info) const
+HttpHeader::packInto(Packable * p, bool mask_sensitive_info) const
 {
     HttpHeaderPos pos = HttpHeaderInitPos;
     const HttpHeaderEntry *e;
@@ -765,8 +765,8 @@ HttpHeader::packInto(Packer * p, bool mask_sensitive_info) const
             break;
         }
         if (maskThisEntry) {
-            packerAppend(p, e->name.rawBuf(), e->name.size());
-            packerAppend(p, ": ** NOT DISPLAYED **\r\n", 23);
+            p->append(e->name.rawBuf(), e->name.size());
+            p->append(": ** NOT DISPLAYED **\r\n", 23);
         } else {
             e->packInto(p);
         }
@@ -1230,76 +1230,64 @@ HttpHeader::putAuth(const char *auth_scheme, const char *realm)
 void
 HttpHeader::putCc(const HttpHdrCc * cc)
 {
-    MemBuf mb;
-    Packer p;
     assert(cc);
     /* remove old directives if any */
     delById(HDR_CACHE_CONTROL);
     /* pack into mb */
+    MemBuf mb;
     mb.init();
-    packerToMemInit(&p, &mb);
-    cc->packInto(&p);
+    cc->packInto(&mb);
     /* put */
     addEntry(new HttpHeaderEntry(HDR_CACHE_CONTROL, NULL, mb.buf));
     /* cleanup */
-    packerClean(&p);
     mb.clean();
 }
 
 void
 HttpHeader::putContRange(const HttpHdrContRange * cr)
 {
-    MemBuf mb;
-    Packer p;
     assert(cr);
     /* remove old directives if any */
     delById(HDR_CONTENT_RANGE);
     /* pack into mb */
+    MemBuf mb;
     mb.init();
-    packerToMemInit(&p, &mb);
-    httpHdrContRangePackInto(cr, &p);
+    httpHdrContRangePackInto(cr, &mb);
     /* put */
     addEntry(new HttpHeaderEntry(HDR_CONTENT_RANGE, NULL, mb.buf));
     /* cleanup */
-    packerClean(&p);
     mb.clean();
 }
 
 void
 HttpHeader::putRange(const HttpHdrRange * range)
 {
-    MemBuf mb;
-    Packer p;
     assert(range);
     /* remove old directives if any */
     delById(HDR_RANGE);
     /* pack into mb */
+    MemBuf mb;
     mb.init();
-    packerToMemInit(&p, &mb);
-    range->packInto(&p);
+    range->packInto(&mb);
     /* put */
     addEntry(new HttpHeaderEntry(HDR_RANGE, NULL, mb.buf));
     /* cleanup */
-    packerClean(&p);
     mb.clean();
 }
 
 void
 HttpHeader::putSc(HttpHdrSc *sc)
 {
-    MemBuf mb;
-    Packer p;
     assert(sc);
     /* remove old directives if any */
     delById(HDR_SURROGATE_CONTROL);
     /* pack into mb */
+    MemBuf mb;
     mb.init();
-    packerToMemInit(&p, &mb);
-    sc->packInto(&p);
+    sc->packInto(&mb);
     /* put */
     addEntry(new HttpHeaderEntry(HDR_SURROGATE_CONTROL, NULL, mb.buf));
     /* cleanup */
-    packerClean(&p);
     mb.clean();
 }
 
@@ -1686,13 +1674,13 @@ HttpHeaderEntry::clone() const
 }
 
 void
-HttpHeaderEntry::packInto(Packer * p) const
+HttpHeaderEntry::packInto(Packable * p) const
 {
     assert(p);
-    packerAppend(p, name.rawBuf(), name.size());
-    packerAppend(p, ": ", 2);
-    packerAppend(p, value.rawBuf(), value.size());
-    packerAppend(p, "\r\n", 2);
+    p->append(name.rawBuf(), name.size());
+    p->append(": ", 2);
+    p->append(value.rawBuf(), value.size());
+    p->append("\r\n", 2);
 }
 
 int
@@ -22,7 +22,7 @@ class HttpHdrCc;
 class HttpHdrContRange;
 class HttpHdrRange;
 class HttpHdrSc;
-class Packer;
+class Packable;
 class StoreEntry;
 class SBuf;
 
@@ -87,7 +87,7 @@ class HttpHeaderEntry
     ~HttpHeaderEntry();
     static HttpHeaderEntry *parse(const char *field_start, const char *field_end);
     HttpHeaderEntry *clone() const;
-    void packInto(Packer *p) const;
+    void packInto(Packable *p) const;
     int getInt() const;
     int64_t getInt64() const;
 
@@ -117,7 +117,7 @@ class HttpHeader
     void compact();
     int reset();
     int parse(const char *header_start, size_t len);
-    void packInto(Packer * p, bool mask_sensitive_info=false) const;
+    void packInto(Packable * p, bool mask_sensitive_info=false) const;
     HttpHeaderEntry *getEntry(HttpHeaderPos * pos) const;
     HttpHeaderEntry *findEntry(http_hdr_type id) const;
     int delByName(const char *name);
@@ -10,13 +10,14 @@
 #define SQUID_HTTPHEADERRANGE_H
 
 #include "mem/forward.h"
-#include "Packer.h"
 #include "Range.h"
 #include "SquidString.h"
 
 #include <vector>
 
 class HttpReply;
+class Packable;
+
 /* http byte-range-spec */
 
 class HttpHdrRangeSpec
@@ -33,7 +34,7 @@ class HttpHdrRangeSpec
     bool parseInit(const char *field, int flen);
     int canonize(int64_t clen);
     void outputInfo( char const *note) const;
-    void packInto(Packer * p) const;
+    void packInto(Packable * p) const;
     bool mergeWith(const HttpHdrRangeSpec * donor);
     int64_t offset;
     int64_t length;
@@ -70,7 +71,7 @@ class HttpHdrRange
     int canonize(HttpReply *rep);
     /* returns true if ranges are valid; inits HttpHdrRange */
     bool parseInit(const String * range_spec);
-    void packInto(Packer * p) const;
+    void packInto(Packable * p) const;
     /* other */
     bool isComplex() const;
     bool willBeComplex() const;
@@ -114,7 +114,7 @@ httpHeaderPutStrvf(HttpHeader * hdr, http_hdr_type id, const char *fmt, va_list
 {
     MemBuf mb;
     mb.init();
-    mb.vPrintf(fmt, vargs);
+    mb.vappendf(fmt, vargs);
     hdr->putStr(id, mb.buf);
     mb.clean();
 }
@@ -312,11 +312,11 @@ HttpMsg::persistent() const
     }
 }
 
-void HttpMsg::packInto(Packer *p, bool full_uri) const
+void HttpMsg::packInto(Packable *p, bool full_uri) const
 {
     packFirstLineInto(p, full_uri);
     header.packInto(p);
-    packerAppend(p, "\r\n", 2);
+    p->append("\r\n", 2);
 }
 
 void HttpMsg::hdrCacheInit()
@@ -331,9 +331,6 @@ void HttpMsg::hdrCacheInit()
  */
 void HttpMsg::firstLineBuf(MemBuf& mb)
 {
-    Packer p;
-    packerToMemInit(&p, &mb);
-    packFirstLineInto(&p, true);
-    packerClean(&p);
+    packFirstLineInto(&mb, true);
 }
 
@@ -28,7 +28,7 @@ class HttpMsg : public RefCountable
 
     virtual void reset() = 0; // will have body when http*Clean()s are gone
 
-    void packInto(Packer * p, bool full_uri) const;
+    void packInto(Packable * p, bool full_uri) const;
 
     ///< produce a message copy, except for a few connection-specific settings
     virtual HttpMsg *clone() const = 0; ///< \todo rename: not a true copy?
@@ -91,7 +91,7 @@ class HttpMsg : public RefCountable
      */
     virtual bool sanityCheckStartLine(const char *buf, const size_t hdr_len, Http::StatusCode *error) = 0;
 
-    virtual void packFirstLineInto(Packer * p, bool full_uri) const = 0;
+    virtual void packFirstLineInto(Packable * p, bool full_uri) const = 0;
 
     virtual bool parseFirstLine(const char *blk_start, const char *blk_end) = 0;
 
@@ -108,15 +108,15 @@ HttpReply::clean()
 }
 
 void
-HttpReply::packHeadersInto(Packer * p) const
+HttpReply::packHeadersInto(Packable * p) const
 {
     sline.packInto(p);
     header.packInto(p);
-    packerAppend(p, "\r\n", 2);
+    p->append("\r\n", 2);
 }
 
 void
-HttpReply::packInto(Packer * p)
+HttpReply::packInto(Packable * p)
 {
     packHeadersInto(p);
     body.packInto(p);
@@ -127,12 +127,8 @@ MemBuf *
 HttpReply::pack()
 {
     MemBuf *mb = new MemBuf;
-    Packer p;
-
     mb->init();
-    packerToMemInit(&p, mb);
-    packInto(&p);
-    packerClean(&p);
+    packInto(mb);
     return mb;
 }
 
@@ -100,7 +100,7 @@ class HttpReply: public HttpMsg
 
     int validatorsMatch (HttpReply const *other) const;
 
-    void packHeadersInto(Packer * p) const;
+    void packHeadersInto(Packable * p) const;
 
     /** Clone this reply.
      *  Could be done as a copy-contructor but we do not want to accidently copy a HttpReply..
@@ -120,7 +120,7 @@ class HttpReply: public HttpMsg
 
     void hdrCacheClean();
 
-    void packInto(Packer * p);
+    void packInto(Packable * p);
 
     /* ez-routines */
     /** \return construct 304 reply and pack it into a MemBuf */
@@ -139,7 +139,7 @@ class HttpReply: public HttpMsg
     mutable int64_t bodySizeMax; /**< cached result of calcMaxBodySize */
 
 protected:
-    virtual void packFirstLineInto(Packer * p, bool) const { sline.packInto(p); }
+    virtual void packFirstLineInto(Packable * p, bool) const { sline.packInto(p); }
 
     virtual bool parseFirstLine(const char *start, const char *end);
 };
@@ -365,33 +365,31 @@ HttpRequest::parseHeader(Http1::RequestParser &hp)
 void
 HttpRequest::swapOut(StoreEntry * e)
 {
-    Packer p;
     assert(e);
-    packerToStoreInit(&p, e);
-    pack(&p);
-    packerClean(&p);
+    e->buffer();
+    pack(e);
 }
 
 /* packs request-line and headers, appends <crlf> terminator */
 void
-HttpRequest::pack(Packer * p)
+HttpRequest::pack(Packable * p)
 {
     assert(p);
     /* pack request-line */
-    packerPrintf(p, SQUIDSBUFPH " " SQUIDSTRINGPH " HTTP/%d.%d\r\n",
-                 SQUIDSBUFPRINT(method.image()), SQUIDSTRINGPRINT(urlpath),
-                 http_ver.major, http_ver.minor);
+    p->appendf(SQUIDSBUFPH " " SQUIDSTRINGPH " HTTP/%d.%d\r\n",
+               SQUIDSBUFPRINT(method.image()), SQUIDSTRINGPRINT(urlpath),
+               http_ver.major, http_ver.minor);
     /* headers */
     header.packInto(p);
     /* trailer */
-    packerAppend(p, "\r\n", 2);
+    p->append("\r\n", 2);
 }
 
 /*
  * A wrapper for debugObj()
  */
 void
-httpRequestPack(void *obj, Packer *p)
+httpRequestPack(void *obj, Packable *p)
 {
     HttpRequest *request = static_cast<HttpRequest*>(obj);
     request->pack(p);
@@ -508,13 +506,13 @@ const char *HttpRequest::packableURI(bool full_uri) const
     return "/";
 }
 
-void HttpRequest::packFirstLineInto(Packer * p, bool full_uri) const
+void HttpRequest::packFirstLineInto(Packable * p, bool full_uri) const
 {
     // form HTTP request-line
-    packerPrintf(p, SQUIDSBUFPH " %s HTTP/%d.%d\r\n",
-                 SQUIDSBUFPRINT(method.image()),
-                 packableURI(full_uri),
-                 http_ver.major, http_ver.minor);
+    p->appendf(SQUIDSBUFPH " %s HTTP/%d.%d\r\n",
+               SQUIDSBUFPRINT(method.image()),
+               packableURI(full_uri),
+               http_ver.major, http_ver.minor);
 }
 
 /*
@@ -37,7 +37,7 @@
 class ConnStateData;
 
 /*  Http Request */
-void httpRequestPack(void *obj, Packer *p);
+void httpRequestPack(void *obj, Packable *p);
 
 class HttpHdrRange;
 
@@ -220,9 +220,9 @@ class HttpRequest: public HttpMsg
 
     void swapOut(StoreEntry * e);
 
-    void pack(Packer * p);
+    void pack(Packable * p);
 
-    static void httpRequestPack(void *obj, Packer *p);
+    static void httpRequestPack(void *obj, Packable *p);
 
     static HttpRequest * CreateFromUrlAndMethod(char * url, const HttpRequestMethod& method);
 
@@ -255,7 +255,7 @@ class HttpRequest: public HttpMsg
     mutable int64_t rangeOffsetLimit;  /* caches the result of getRangeOffsetLimit */
 
 protected:
-    virtual void packFirstLineInto(Packer * p, bool full_uri) const;
+    virtual void packFirstLineInto(Packable * p, bool full_uri) const;
 
     virtual bool sanityCheckStartLine(const char *buf, const size_t hdr_len, Http::StatusCode *error);
 
@@ -440,8 +440,6 @@ squid_SOURCES = \
 	neighbors.cc \
 	Notes.h \
 	Notes.cc \
-	Packer.cc \
-	Packer.h \
 	Parsing.cc \
 	Parsing.h \
 	$(XPROF_STATS_SOURCE) \
@@ -1146,8 +1144,6 @@ tests_testHttpReply_SOURCES=\
 	mime_header.cc \
 	Notes.h \
 	Notes.cc \
-	Packer.cc \
-	Packer.h \
 	SquidString.h \
 	SquidTime.h \
 	$(SBUF_SOURCE) \
@@ -1253,7 +1249,6 @@ tests_testACLMaxUserIP_SOURCES= \
 	SquidList.h \
 	SquidList.cc \
 	mem_node.cc \
-	Packer.cc \
 	Parsing.cc \
 	SquidMath.cc \
 	StatCounters.cc \
@@ -1496,7 +1491,6 @@ tests_testCacheManager_SOURCES = \
 	neighbors.cc \
 	Notes.cc \
 	Notes.h \
-	Packer.cc \
 	Parsing.cc \
 	pconn.cc \
 	peer_digest.cc \
@@ -1676,7 +1670,6 @@ tests_testDiskIO_SOURCES = \
 	mem_node.cc \
 	Notes.h \
 	Notes.cc \
-	Packer.cc \
 	Parsing.cc \
 	refresh.h \
 	refresh.cc \
@@ -1937,7 +1930,6 @@ tests_testEvent_SOURCES = \
 	neighbors.cc \
 	Notes.cc \
 	Notes.h \
-	Packer.cc \
 	Parsing.cc \
 	pconn.cc \
 	peer_digest.cc \
@@ -2184,7 +2176,6 @@ tests_testEventLoop_SOURCES = \
 	neighbors.cc \
 	Notes.cc \
 	Notes.h \
-	Packer.cc \
 	Parsing.cc \
 	pconn.cc \
 	peer_digest.cc \
@@ -2426,7 +2417,6 @@ tests_test_http_range_SOURCES = \
 	neighbors.cc \
 	Notes.cc \
 	Notes.h \
-	Packer.cc \
 	Parsing.cc \
 	peer_digest.cc \
 	peer_proxy_negotiate_auth.h \
@@ -2722,7 +2712,6 @@ tests_testHttpRequest_SOURCES = \
 	neighbors.cc \
 	Notes.cc \
 	Notes.h \
-	Packer.cc \
 	Parsing.cc \
 	pconn.cc \
 	peer_digest.cc \
@@ -2894,7 +2883,6 @@ tests_testStore_SOURCES= \
 	MemObject.cc \
 	Notes.h \
 	Notes.cc \
-	Packer.cc \
 	Parsing.cc \
 	RemovalPolicy.cc \
 	refresh.h \
@@ -3034,6 +3022,7 @@ tests_testString_SOURCES = \
 	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
+	tests/stub_cbdata.cc \
 	tests/stub_debug.cc \
 	tests/stub_HelperChildConfig.cc \
 	tools.h \
@@ -3175,7 +3164,6 @@ tests_testUfs_SOURCES = \
 	ClientInfo.h \
 	MemBuf.cc \
 	HttpHdrContRange.cc \
-	Packer.cc \
 	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
@@ -3312,7 +3300,6 @@ tests_testRock_SOURCES = \
 	mem_node.cc \
 	Notes.h \
 	Notes.cc \
-	Packer.cc \
 	Parsing.cc \
 	RemovalPolicy.cc \
 	RequestFlags.cc \
@@ -3543,7 +3530,6 @@ tests_testURL_SOURCES = \
 	neighbors.cc \
 	Notes.h \
 	Notes.cc \
-	Packer.cc \
 	Parsing.cc \
 	pconn.cc \
 	peer_digest.cc \
@@ -3693,6 +3679,7 @@ tests_testSBuf_SOURCES= \
 	tests/stub_libmem.cc \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
+	tests/stub_cbdata.cc \
 	tests/stub_store.cc \
 	tests/stub_store_stats.cc \
 	tests/stub_tools.cc \
@@ -3776,6 +3763,7 @@ tests_testConfigParser_SOURCES = \
 	YesNoNone.h \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
+	tests/stub_cbdata.cc \
 	tests/stub_debug.cc \
 	tests/stub_HelperChildConfig.cc \
 	tools.h \
@@ -222,7 +222,7 @@ void MemBuf::truncate(mb_size_t tailSize)
  * calls memcpy, appends exactly size bytes,
  * extends buffer or creates buffer if needed.
  */
-void MemBuf::append(const char *newContent, mb_size_t sz)
+void MemBuf::append(const char *newContent, int sz)
 {
     assert(sz >= 0);
     assert(buf || (0==capacity && 0==size));
@@ -262,21 +262,11 @@ void MemBuf::terminate()
     *space() = '\0';
 }
 
-/* calls memBufVPrintf */
-void
-MemBuf::Printf(const char *fmt,...)
-{
-    va_list args;
-    va_start(args, fmt);
-    vPrintf(fmt, args);
-    va_end(args);
-}
-
 /**
- * vPrintf for other printf()'s to use; calls vsnprintf, extends buf if needed
+ * vappendf for other printf()'s to use; calls vsnprintf, extends buf if needed
  */
 void
-MemBuf::vPrintf(const char *fmt, va_list vargs)
+MemBuf::vappendf(const char *fmt, va_list vargs)
 {
 #ifdef VA_COPY
     va_list ap;
@@ -397,6 +387,6 @@ void
 memBufReport(MemBuf * mb)
 {
     assert(mb);
-    mb->Printf("memBufReport is not yet implemented @?@\n");
+    mb->appendf("memBufReport is not yet implemented @?@\n");
 }
 
@@ -9,14 +9,14 @@
 #ifndef SQUID_MEMBUF_H
 #define SQUID_MEMBUF_H
 
+#include "base/Packable.h"
 #include "cbdata.h"
-#include "Packer.h"
 
 /**
- * Auto-growing memory-resident buffer with printf interface
+ * Auto-growing memory-resident buffer with Packable interface
  * \deprecated Use SBuf instead.
  */
-class MemBuf
+class MemBuf : public Packable
 {
     CBDATA_CLASS(MemBuf);
 
@@ -28,7 +28,7 @@ class MemBuf
         capacity(0),
         stolen(0)
     {}
-    ~MemBuf() {
+    virtual ~MemBuf() {
         if (!stolen && buf)
             clean();
     }
@@ -75,7 +75,6 @@ class MemBuf
     void consume(mb_size_t sz);  // removes sz bytes, moving content left
     void consumeWhitespacePrefix();    ///< removes all prefix whitespace, moving content left
 
-    void append(const char *c, mb_size_t sz); // grows if needed and possible
     void appended(mb_size_t sz); // updates content size after external append
     void truncate(mb_size_t sz);  // removes sz last bytes
 
@@ -98,23 +97,17 @@ class MemBuf
     /** unfirtunate hack to test if the buffer has been Init()ialized */
     int isNull();
 
-    /**
-     * calls snprintf, extends buffer if needed
-     \note  we use Printf instead of printf so the compiler won't
-     *      think we're calling the libc printf()
-     */
-    void Printf(const char *fmt,...) PRINTF_FORMAT_ARG2;
-
-    /** vPrintf for other printf()'s to use */
-    void vPrintf(const char *fmt, va_list ap);
-
     /**
      * freezes the object! and returns function to clear it up.
      *
      \retval free() function to be used.
      */
     FREE *freeFunc();
 
+    /* Packable API */
+    virtual void append(const char *c, int sz);
+    virtual void vappendf(const char *fmt, va_list ap);
+
 private:
     /**
      * private copy constructor and assignment operator generates
@@ -161,8 +154,6 @@ class MemBuf
 
 /** returns free() function to be used, _freezes_ the object! */
 void memBufReport(MemBuf * mb);
-/** pack content into a mem buf. */
-void packerToMemInit(Packer * p, MemBuf * mb);
 
 #endif /* SQUID_MEMBUF_H */
 
@@ -229,28 +229,24 @@ struct StoreClientStats : public unary_function<store_client, void> {
 void
 MemObject::stat(MemBuf * mb) const
 {
-    mb->Printf("\t" SQUIDSBUFPH " %s\n", SQUIDSBUFPRINT(method.image()), logUri());
+    mb->appendf("\t" SQUIDSBUFPH " %s\n", SQUIDSBUFPRINT(method.image()), logUri());
     if (vary_headers)
-        mb->Printf("\tvary_headers: %s\n", vary_headers);
-    mb->Printf("\tinmem_lo: %" PRId64 "\n", inmem_lo);
-    mb->Printf("\tinmem_hi: %" PRId64 "\n", data_hdr.endOffset());
-    mb->Printf("\tswapout: %" PRId64 " bytes queued\n",
-               swapout.queue_offset);
+        mb->appendf("\tvary_headers: %s\n", vary_headers);
+    mb->appendf("\tinmem_lo: %" PRId64 "\n", inmem_lo);
+    mb->appendf("\tinmem_hi: %" PRId64 "\n", data_hdr.endOffset());
+    mb->appendf("\tswapout: %" PRId64 " bytes queued\n", swapout.queue_offset);
 
     if (swapout.sio.getRaw())
-        mb->Printf("\tswapout: %" PRId64 " bytes written\n",
-                   (int64_t) swapout.sio->offset());
+        mb->appendf("\tswapout: %" PRId64 " bytes written\n", (int64_t) swapout.sio->offset());
 
     if (xitTable.index >= 0)
-        mb->Printf("\ttransient index: %d state: %d\n",
-                   xitTable.index, xitTable.io);
+        mb->appendf("\ttransient index: %d state: %d\n", xitTable.index, xitTable.io);
     if (memCache.index >= 0)
-        mb->Printf("\tmem-cache index: %d state: %d offset: %" PRId64 "\n",
-                   memCache.index, memCache.io, memCache.offset);
+        mb->appendf("\tmem-cache index: %d state: %d offset: %" PRId64 "\n", memCache.index, memCache.io, memCache.offset);
     if (object_sz >= 0)
-        mb->Printf("\tobject_sz: %" PRId64 "\n", object_sz);
+        mb->appendf("\tobject_sz: %" PRId64 "\n", object_sz);
     if (smpCollapsed)
-        mb->Printf("\tsmp-collapsed\n");
+        mb->appendf("\tsmp-collapsed\n");
 
     StoreClientStats statsVisitor(mb);
 
@@ -1,141 +0,0 @@
-/*
- * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-/* DEBUG: section 60    Packer: A uniform interface to store-like modules */
-
-/*
- * Rationale:
- * ----------
- *
- * OK, we have two major interfaces comm.c and store.c.
- *
- * Store.c has a nice storeAppend[Printf] capability which makes "storing"
- * things easy and painless.
- *
- * Comm.c lacks commAppend[Printf] because comm does not handle its own
- * buffers (no mem_obj equivalent for comm.c).
- *
- * Thus, if one wants to be able to store _and_ Comm::Write an object, s/he
- * has to implement two almost identical functions.
- *
- * Packer
- * ------
- *
- * Packer provides for a more uniform interface to store and comm modules.
- * Packer has its own append and printf routines that "know" where to send
- * incoming data. In case of store interface, Packer sends data to
- * storeAppend.  Otherwise, Packer uses a MemBuf that can be flushed later to
- * Comm::Write.
- *
- * Thus, one can write just one function that will either "pack" things for
- * Comm::Write or "append" things to store, depending on actual packer
- * supplied.
- *
- * It is amazing how much work a tiny object can save. :)
- */
-
-#include "squid.h"
-#include "MemBuf.h"
-#include "Store.h"
-
-/*
- * We do have one potential problem here. Both append_f and vprintf_f types
- * cannot match real functions precisely (at least because of the difference in
- * the type of the first parameter). Thus, we have to use type cast. If somebody
- * changes the prototypes of real functions, Packer will not notice that because
- * of the type cast.
- *
- * Solution: we use the constants below to *hard code* current prototypes of
- * real functions. If real prototypes change, these constants will produce a
- * warning (e.g., "warning: assignment from incompatible pointer type").
- */
-
-static void
-memBufAppend(MemBuf *mb, const char *buf, mb_size_t len)
-{
-    mb->append(buf, len);
-}
-
-static void
-memBufVPrintf(MemBuf * mb, const char *fmt, va_list vargs)
-{
-    mb->vPrintf(fmt, vargs);
-}
-
-static void
-storeEntryAppend(StoreEntry *e, const char *buf, int len)
-{
-    e->append(buf, len);
-}
-
-/* append()'s */
-static void (*const store_append) (StoreEntry *, const char *, int) = &storeEntryAppend;
-static void (*const memBuf_append) (MemBuf *, const char *, mb_size_t) = &memBufAppend;
-
-/* vprintf()'s */
-static void (*const store_vprintf) (StoreEntry *, const char *, va_list ap) = &storeAppendVPrintf;
-static void (*const memBuf_vprintf) (MemBuf *, const char *, va_list ap) = &memBufVPrintf;
-
-/* init/clean */
-
-/* init with this to forward data to StoreEntry */
-void
-packerToStoreInit(Packer * p, StoreEntry * e)
-{
-    assert(p && e);
-    p->append = (append_f) store_append;
-    p->packer_vprintf = (vprintf_f) store_vprintf;
-    p->real_handler = e;
-    e->buffer();
-}
-
-/* init with this to accumulate data in MemBuf */
-void
-packerToMemInit(Packer * p, MemBuf * mb)
-{
-    assert(p && mb);
-    p->append = (append_f) memBuf_append;
-    p->packer_vprintf = (vprintf_f) memBuf_vprintf;
-    p->real_handler = mb;
-}
-
-/* call this when you are done */
-void
-packerClean(Packer * p)
-{
-    assert(p);
-
-    if (p->append == (append_f) store_append && p->real_handler)
-        static_cast<StoreEntry*>(p->real_handler)->flush();
-
-    /* it is not really necessary to do this, but, just in case... */
-    p->append = NULL;
-    p->packer_vprintf = NULL;
-    p->real_handler = NULL;
-}
-
-void
-packerAppend(Packer * p, const char *buf, int sz)
-{
-    assert(p);
-    assert(p->real_handler && p->append);
-    p->append(p->real_handler, buf, sz);
-}
-
-void
-packerPrintf(Packer * p, const char *fmt,...)
-{
-    va_list args;
-    va_start(args, fmt);
-
-    assert(p);
-    assert(p->real_handler && p->packer_vprintf);
-    p->packer_vprintf(p->real_handler, fmt, args);
-    va_end(args);
-}
-
@@ -1,37 +0,0 @@
-/*
- * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-#ifndef SQUID_PACKER_H
-#define SQUID_PACKER_H
-
-/* see Packer.cc for description */
-class Packer;
-
-/* a common objPackInto interface; used by debugObj */
-typedef void (*ObjPackMethod) (void *obj, Packer * p);
-
-/* append/vprintf's for Packer */
-typedef void (*append_f) (void *, const char *buf, int size);
-typedef void (*vprintf_f) (void *, const char *fmt, va_list args);
-
-class Packer
-{
-
-public:
-    /* protected, use interface functions instead */
-    append_f append;
-    vprintf_f packer_vprintf;
-    void *real_handler;     /* first parameter to real append and vprintf */
-};
-
-void packerClean(Packer * p);
-void packerAppend(Packer * p, const char *buf, int size);
-void packerPrintf(Packer * p, const char *fmt,...) PRINTF_FORMAT_ARG2;
-
-#endif /* SQUID_PACKER_H */
-
@@ -9,11 +9,7 @@
 #ifndef SQUID_STORE_H
 #define SQUID_STORE_H
 
-/**
- \defgroup StoreAPI  Store API
- \ingroup FileSystems
- */
-
+#include "base/Packable.h"
 #include "base/RefCount.h"
 #include "comm/forward.h"
 #include "CommRead.h"
@@ -35,7 +31,6 @@
 
 class AsyncCall;
 class HttpRequest;
-class Packer;
 class RequestFlags;
 class StoreClient;
 class StoreSearch;
@@ -46,10 +41,7 @@ extern StoreIoStats store_io_stats;
 /// maximum number of entries per cache_dir
 enum { SwapFilenMax = 0xFFFFFF }; // keep in sync with StoreEntry::swap_filen
 
-/**
- \ingroup StoreAPI
- */
-class StoreEntry : public hash_link
+class StoreEntry : public hash_link, public Packable
 {
 
 public:
@@ -190,8 +182,6 @@ class StoreEntry : public hash_link
 
     ESIElement::Pointer cachedESITree;
 #endif
-    /** append bytes to the buffer */
-    virtual void append(char const *, int len);
     /** disable sending content to the clients */
     virtual void buffer();
     /** flush any buffered content */
@@ -222,6 +212,10 @@ class StoreEntry : public hash_link
     void kickProducer();
 #endif
 
+    /* Packable API */
+    virtual void append(char const *, int);
+    virtual void vappendf(const char *, va_list);
+
 protected:
     void transientsAbandonmentCheck();
 
@@ -502,12 +496,6 @@ void storeReplAdd(const char *, REMOVALPOLICYCREATE *);
 /// \ingroup StoreAPI
 extern FREE destroyStoreEntry;
 
-/**
- \ingroup StoreAPI
- \todo should be a subclass of Packer perhaps ?
- */
-void packerToStoreInit(Packer * p, StoreEntry * e);
-
 /// \ingroup StoreAPI
 void storeGetMemSpace(int size);
 
@@ -62,7 +62,7 @@ Acl::AllOf::parse()
 
         MemBuf wholeCtx;
         wholeCtx.init();
-        wholeCtx.Printf("(%s lines)", name);
+        wholeCtx.appendf("(%s lines)", name);
         wholeCtx.terminate();
 
         Acl::OrNode *newWhole = new Acl::OrNode;
@@ -79,7 +79,7 @@ Acl::AllOf::parse()
 
     MemBuf lineCtx;
     lineCtx.init();
-    lineCtx.Printf("(%s line #%d)", name, lineId);
+    lineCtx.appendf("(%s line #%d)", name, lineId);
     lineCtx.terminate();
 
     Acl::AndNode *line = new AndNode;
@@ -172,7 +172,7 @@ aclParseAccessLine(const char *directive, ConfigParser &, acl_access **treep)
     const int ruleId = ((treep && *treep) ? (*treep)->childrenCount() : 0) + 1;
     MemBuf ctxBuf;
     ctxBuf.init();
-    ctxBuf.Printf("%s#%d", directive, ruleId);
+    ctxBuf.appendf("%s#%d", directive, ruleId);
     ctxBuf.terminate();
 
     Acl::AndNode *rule = new Acl::AndNode;
@@ -208,7 +208,7 @@ aclParseAclList(ConfigParser &, Acl::Tree **treep, const char *label)
 
     MemBuf ctxLine;
     ctxLine.init();
-    ctxLine.Printf("(%s %s line)", cfg_directive, label);
+    ctxLine.appendf("(%s %s line)", cfg_directive, label);
     ctxLine.terminate();
 
     Acl::AndNode *rule = new Acl::AndNode;
@@ -217,7 +217,7 @@ aclParseAclList(ConfigParser &, Acl::Tree **treep, const char *label)
 
     MemBuf ctxTree;
     ctxTree.init();
-    ctxTree.Printf("%s %s", cfg_directive, label);
+    ctxTree.appendf("%s %s", cfg_directive, label);
     ctxTree.terminate();
 
     // We want a cbdata-protected Tree (despite giving it only one child node).
@@ -91,11 +91,7 @@ Adaptation::Ecap::HeaderRep::image() const
 {
     MemBuf mb;
     mb.init();
-
-    Packer p;
-    packerToMemInit(&p, &mb);
-    theMessage.packInto(&p, true);
-    packerClean(&p);
+    theMessage.packInto(&mb, true);
     return Area::FromTempBuffer(mb.content(), mb.contentSize());
 }
 
@@ -375,7 +375,7 @@ void Adaptation::Icap::ModXact::addLastRequestChunk(MemBuf &buf)
 
 void Adaptation::Icap::ModXact::openChunk(MemBuf &buf, size_t chunkSize, bool ieof)
 {
-    buf.Printf((ieof ? "%x; ieof\r\n" : "%x\r\n"), (int) chunkSize);
+    buf.appendf((ieof ? "%x; ieof\r\n" : "%x\r\n"), (int) chunkSize);
 }
 
 void Adaptation::Icap::ModXact::closeChunk(MemBuf &buf)
@@ -1326,16 +1326,10 @@ void Adaptation::Icap::ModXact::finalizeLogInfo()
         }
         //don't set al.cache.objectSize because it hasn't exist yet
 
-        Packer p;
         MemBuf mb;
-
         mb.init();
-        packerToMemInit(&p, &mb);
-
-        reply_->header.packInto(&p);
+        reply_->header.packInto(&mb);
         al.headers.reply = xstrdup(mb.buf);
-
-        packerClean(&p);
         mb.clean();
     }
     prepareLogWithRequestDetails(adapted_request_, alep);
@@ -1349,25 +1343,25 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
      * XXX These should use HttpHdr interfaces instead of Printfs
      */
     const Adaptation::ServiceConfig &s = service().cfg();
-    buf.Printf("%s " SQUIDSTRINGPH " ICAP/1.0\r\n", s.methodStr(), SQUIDSTRINGPRINT(s.uri));
-    buf.Printf("Host: " SQUIDSTRINGPH ":%d\r\n", SQUIDSTRINGPRINT(s.host), s.port);
-    buf.Printf("Date: %s\r\n", mkrfc1123(squid_curtime));
+    buf.appendf("%s " SQUIDSTRINGPH " ICAP/1.0\r\n", s.methodStr(), SQUIDSTRINGPRINT(s.uri));
+    buf.appendf("Host: " SQUIDSTRINGPH ":%d\r\n", SQUIDSTRINGPRINT(s.host), s.port);
+    buf.appendf("Date: %s\r\n", mkrfc1123(squid_curtime));
 
     if (!TheConfig.reuse_connections)
-        buf.Printf("Connection: close\r\n");
+        buf.appendf("Connection: close\r\n");
 
     const HttpRequest *request = &virginRequest();
 
     // we must forward "Proxy-Authenticate" and "Proxy-Authorization"
     // as ICAP headers.
     if (virgin.header->header.has(HDR_PROXY_AUTHENTICATE)) {
         String vh=virgin.header->header.getByName("Proxy-Authenticate");
-        buf.Printf("Proxy-Authenticate: " SQUIDSTRINGPH "\r\n",SQUIDSTRINGPRINT(vh));
+        buf.appendf("Proxy-Authenticate: " SQUIDSTRINGPH "\r\n",SQUIDSTRINGPRINT(vh));
     }
 
     if (virgin.header->header.has(HDR_PROXY_AUTHORIZATION)) {
         String vh=virgin.header->header.getByName("Proxy-Authorization");
-        buf.Printf("Proxy-Authorization: " SQUIDSTRINGPH "\r\n", SQUIDSTRINGPRINT(vh));
+        buf.appendf("Proxy-Authorization: " SQUIDSTRINGPH "\r\n", SQUIDSTRINGPRINT(vh));
     } else if (request->extacl_user.size() > 0 && request->extacl_passwd.size() > 0) {
         struct base64_encode_ctx ctx;
         base64_encode_init(&ctx);
@@ -1376,7 +1370,7 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
         resultLen += base64_encode_update(&ctx, base64buf+resultLen, 1, reinterpret_cast<const uint8_t*>(":"));
         resultLen += base64_encode_update(&ctx, base64buf+resultLen, request->extacl_passwd.size(), reinterpret_cast<const uint8_t*>(request->extacl_passwd.rawBuf()));
         resultLen += base64_encode_final(&ctx, base64buf+resultLen);
-        buf.Printf("Proxy-Authorization: Basic %.*s\r\n", (int)resultLen, base64buf);
+        buf.appendf("Proxy-Authorization: Basic %.*s\r\n", (int)resultLen, base64buf);
     }
 
     // share the cross-transactional database records if needed
@@ -1385,13 +1379,12 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
         if (ah != NULL) {
             String name, value;
             if (ah->getXxRecord(name, value)) {
-                buf.Printf(SQUIDSTRINGPH ": " SQUIDSTRINGPH "\r\n",
-                           SQUIDSTRINGPRINT(name), SQUIDSTRINGPRINT(value));
+                buf.appendf(SQUIDSTRINGPH ": " SQUIDSTRINGPH "\r\n", SQUIDSTRINGPRINT(name), SQUIDSTRINGPRINT(value));
             }
         }
     }
 
-    buf.Printf("Encapsulated: ");
+    buf.append("Encapsulated: ", 14);
 
     MemBuf httpBuf;
 
@@ -1416,16 +1409,16 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
             encapsulateHead(buf, "res-hdr", httpBuf, prime);
 
     if (!virginBody.expected())
-        buf.Printf("null-body=%d", (int) httpBuf.contentSize());
+        buf.appendf("null-body=%d", (int) httpBuf.contentSize());
     else if (ICAP::methodReqmod == m)
-        buf.Printf("req-body=%d", (int) httpBuf.contentSize());
+        buf.appendf("req-body=%d", (int) httpBuf.contentSize());
     else
-        buf.Printf("res-body=%d", (int) httpBuf.contentSize());
+        buf.appendf("res-body=%d", (int) httpBuf.contentSize());
 
     buf.append(ICAP::crlf, 2); // terminate Encapsulated line
 
     if (preview.enabled()) {
-        buf.Printf("Preview: %d\r\n", (int)preview.ad());
+        buf.appendf("Preview: %d\r\n", (int)preview.ad());
         if (!virginBody.expected()) // there is no body to preview
             finishNullOrEmptyBodyPreview(httpBuf);
     }
@@ -1441,7 +1434,7 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
 #endif
             client_addr = request->client_addr;
         if (!client_addr.isAnyAddr() && !client_addr.isNoAddr())
-            buf.Printf("X-Client-IP: %s\r\n", client_addr.toStr(ntoabuf,MAX_IPSTRLEN));
+            buf.appendf("X-Client-IP: %s\r\n", client_addr.toStr(ntoabuf,MAX_IPSTRLEN));
     }
 
     if (TheConfig.send_username && request)
@@ -1457,7 +1450,7 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
         HttpReply *reply = dynamic_cast<HttpReply*>(virgin.header);
 
         if (const char *value = (*i)->match(r, reply, alMaster)) {
-            buf.Printf("%s: %s\r\n", (*i)->key.termedBuf(), value);
+            buf.appendf("%s: %s\r\n", (*i)->key.termedBuf(), value);
             Adaptation::History::Pointer ah = request->adaptHistory(false);
             if (ah != NULL) {
                 if (ah->metaHeaders == NULL)
@@ -1537,17 +1530,17 @@ void Adaptation::Icap::ModXact::makeUsernameHeader(const HttpRequest *request, M
             uint8_t base64buf[base64_encode_len(MAX_LOGIN_SZ)];
             size_t resultLen = base64_encode_update(&ctx, base64buf, strlen(value), reinterpret_cast<const uint8_t*>(value));
             resultLen += base64_encode_final(&ctx, base64buf+resultLen);
-            buf.Printf("%s: %.*s\r\n", TheConfig.client_username_header, (int)resultLen, base64buf);
+            buf.appendf("%s: %.*s\r\n", TheConfig.client_username_header, (int)resultLen, base64buf);
         } else
-            buf.Printf("%s: %s\r\n", TheConfig.client_username_header, value);
+            buf.appendf("%s: %s\r\n", TheConfig.client_username_header, value);
     }
 #endif
 }
 
 void Adaptation::Icap::ModXact::encapsulateHead(MemBuf &icapBuf, const char *section, MemBuf &httpBuf, const HttpMsg *head)
 {
     // update ICAP header
-    icapBuf.Printf("%s=%d, ", section, (int) httpBuf.contentSize());
+    icapBuf.appendf("%s=%d, ", section, (int) httpBuf.contentSize());
 
     // begin cloning
     HttpMsg::Pointer headClone;
@@ -1585,10 +1578,7 @@ void Adaptation::Icap::ModXact::encapsulateHead(MemBuf &icapBuf, const char *sec
 
 void Adaptation::Icap::ModXact::packHead(MemBuf &httpBuf, const HttpMsg *head)
 {
-    Packer p;
-    packerToMemInit(&p, &httpBuf);
-    head->packInto(&p, true);
-    packerClean(&p);
+    head->packInto(&httpBuf, true);
 }
 
 // decides whether to offer a preview and calculates its size
@@ -1717,21 +1707,21 @@ void Adaptation::Icap::ModXact::fillPendingStatus(MemBuf &buf) const
         buf.append("r", 1);
 
     if (!state.doneWriting() && state.writing != State::writingInit)
-        buf.Printf("w(%d)", state.writing);
+        buf.appendf("w(%d)", state.writing);
 
     if (preview.enabled()) {
         if (!preview.done())
-            buf.Printf("P(%d)", (int) preview.debt());
+            buf.appendf("P(%d)", (int) preview.debt());
     }
 
     if (virginBodySending.active())
         buf.append("B", 1);
 
     if (!state.doneParsing() && state.parsing != State::psIcapHeader)
-        buf.Printf("p(%d)", state.parsing);
+        buf.appendf("p(%d)", state.parsing);
 
     if (!doneSending() && state.sending != State::sendingUndecided)
-        buf.Printf("S(%d)", state.sending);
+        buf.appendf("S(%d)", state.sending);
 
     if (state.readyForUob)
         buf.append("6", 1);
@@ -1755,7 +1745,7 @@ void Adaptation::Icap::ModXact::fillDoneStatus(MemBuf &buf) const
 
     if (preview.enabled()) {
         if (preview.done())
-            buf.Printf("P%s", preview.ieof() ? "(ieof)" : "");
+            buf.appendf("P%s", preview.ieof() ? "(ieof)" : "");
     }
 
     if (doneReading())
@@ -54,15 +54,15 @@ void Adaptation::Icap::OptXact::makeRequest(MemBuf &buf)
 {
     const Adaptation::Service &s = service();
     const String uri = s.cfg().uri;
-    buf.Printf("OPTIONS " SQUIDSTRINGPH " ICAP/1.0\r\n", SQUIDSTRINGPRINT(uri));
+    buf.appendf("OPTIONS " SQUIDSTRINGPH " ICAP/1.0\r\n", SQUIDSTRINGPRINT(uri));
     const String host = s.cfg().host;
-    buf.Printf("Host: " SQUIDSTRINGPH ":%d\r\n", SQUIDSTRINGPRINT(host), s.cfg().port);
+    buf.appendf("Host: " SQUIDSTRINGPH ":%d\r\n", SQUIDSTRINGPRINT(host), s.cfg().port);
 
     if (!TheConfig.reuse_connections)
-        buf.Printf("Connection: close\r\n");
+        buf.append("Connection: close\r\n", 19);
 
     if (TheConfig.allow206_enable)
-        buf.Printf("Allow: 206\r\n");
+        buf.append("Allow: 206\r\n", 12);
     buf.append(ICAP::crlf, 2);
 
     // XXX: HttpRequest cannot fully parse ICAP Request-Line
@@ -717,7 +717,7 @@ const char *Adaptation::Icap::ServiceRep::status() const
         buf.append(",notif", 6);
 
     if (const int failures = theSessionFailures.remembered())
-        buf.Printf(",fail%d", failures);
+        buf.appendf(",fail%d", failures);
 
     buf.append("]", 1);
     buf.terminate();
@@ -656,15 +656,11 @@ const char *Adaptation::Icap::Xaction::status() const
 {
     static MemBuf buf;
     buf.reset();
-
     buf.append(" [", 2);
-
     fillPendingStatus(buf);
     buf.append("/", 1);
     fillDoneStatus(buf);
-
-    buf.Printf(" %s%u]", id.Prefix, id.value);
-
+    buf.appendf(" %s%u]", id.Prefix, id.value);
     buf.terminate();
 
     return buf.content();
@@ -673,7 +669,7 @@ const char *Adaptation::Icap::Xaction::status() const
 void Adaptation::Icap::Xaction::fillPendingStatus(MemBuf &buf) const
 {
     if (haveConnection()) {
-        buf.Printf("FD %d", connection->fd);
+        buf.appendf("FD %d", connection->fd);
 
         if (writer != NULL)
             buf.append("w", 1);
@@ -688,10 +684,10 @@ void Adaptation::Icap::Xaction::fillPendingStatus(MemBuf &buf) const
 void Adaptation::Icap::Xaction::fillDoneStatus(MemBuf &buf) const
 {
     if (haveConnection() && commEof)
-        buf.Printf("Comm(%d)", connection->fd);
+        buf.appendf("Comm(%d)", connection->fd);
 
     if (stopReason != NULL)
-        buf.Printf("Stopped");
+        buf.append("Stopped", 7);
 }
 
 bool Adaptation::Icap::Xaction::fillVirginHttpHeader(MemBuf &) const
@@ -162,10 +162,9 @@ const char *AsyncJob::status() const
 
     buf.append(" [", 2);
     if (stopReason != NULL) {
-        buf.Printf("Stopped, reason:");
-        buf.Printf("%s",stopReason);
+        buf.appendf("Stopped, reason:%s", stopReason);
     }
-    buf.Printf(" %s%u]", id.Prefix, id.value);
+    buf.appendf(" %s%u]", id.Prefix, id.value);
     buf.terminate();
 
     return buf.content();
@@ -26,6 +26,7 @@ libbase_la_SOURCES = \
 	InstanceId.h \
 	Lock.h \
 	LruMap.h \
+	Packable.h \
 	RunnersRegistry.cc \
 	RunnersRegistry.h \
 	Subscription.h \
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_SRC_BASE_PACKABLE_H
+#define SQUID_SRC_BASE_PACKABLE_H
+
+/**
+ * A uniform interface to store-like modules
+ *
+ * Rationale:
+ * ----------
+ *
+ * We have two major interfaces Comm and Store, which take a variety of
+ * different data buffering objects and have different output actions
+ * to be performed on data.
+ *
+ * Store has a nice storeAppend[Printf] capability which makes "storing"
+ * things easy and painless.
+ *
+ * Comm lacks commAppend[Printf] because Comm does not handle its own
+ * buffers (no mem_obj equivalent for Comm).
+ *
+ * Thus, if one wants to be able to Store _and_ Comm::Write an object, 'e
+ * has to implement almost identical functions for using all the data
+ * storage objects and their associated actions. Doing this for all the
+ * available data storage types is a tedious nightmare of almost-duplicated
+ * code.
+ *
+ * Packer
+ * ------
+ *
+ * Objects inheriting from Packable provide a uniform interface for code to
+ * assemble data before passing to Store and Comm modules.
+ *
+ * Packable objects have their own append and printf routines that "know"
+ * where to send incoming data. In case of Store interface, sending data to
+ * storeAppend. Packable buffer objects retain the data such that it can be
+ * flushed later to Comm::Write.
+ *
+ * Thus, one can write just one function that will take a Packable object
+ * and either "pack" things for Comm::Write or "append" things to Store,
+ * depending on actual Packable object supplied.
+ */
+class Packable
+{
+public:
+    /// Appends a c-string to existing packed data.
+    virtual void append(const char *buf, int size) = 0;
+
+    /// Append operation with printf-style arguments.
+    void appendf(const char *fmt,...) PRINTF_FORMAT_ARG2
+    {
+        va_list args;
+        va_start(args, fmt);
+        vappendf(fmt, args);
+        va_end(args);
+    }
+
+    /** Append operation, with vsprintf(3)-style arguments.
+     *
+     * \note arguments may be evaluated more than once, be careful
+     *       of side-effects
+     */
+    virtual void vappendf(const char *fmt, va_list ap) = 0;
+};
+
+#endif /* SQUID_SRC_BASE_PACKABLE_H */
+
@@ -516,35 +516,28 @@ prepareLogWithRequestDetails(HttpRequest * request, AccessLogEntry::Pointer &aLo
     assert(aLogEntry != NULL);
 
     if (Config.onoff.log_mime_hdrs) {
-        Packer p;
         MemBuf mb;
         mb.init();
-        packerToMemInit(&p, &mb);
-        request->header.packInto(&p);
+        request->header.packInto(&mb);
         //This is the request after adaptation or redirection
         aLogEntry->headers.adapted_request = xstrdup(mb.buf);
 
         // the virgin request is saved to aLogEntry->request
         if (aLogEntry->request) {
-            packerClean(&p);
             mb.reset();
-            packerToMemInit(&p, &mb);
-            aLogEntry->request->header.packInto(&p);
+            aLogEntry->request->header.packInto(&mb);
             aLogEntry->headers.request = xstrdup(mb.buf);
         }
 
 #if USE_ADAPTATION
         const Adaptation::History::Pointer ah = request->adaptLogHistory();
         if (ah != NULL) {
-            packerClean(&p);
             mb.reset();
-            packerToMemInit(&p, &mb);
-            ah->lastMeta.packInto(&p);
+            ah->lastMeta.packInto(&mb);
             aLogEntry->adapt.last_meta = xstrdup(mb.buf);
         }
 #endif
 
-        packerClean(&p);
         mb.clean();
     }
 
@@ -1025,16 +1018,16 @@ ClientSocketContext::packChunk(const StoreIOBuffer &bodyData, MemBuf &mb)
         static_cast<uint64_t>(lengthToSend(bodyData.range()));
     noteSentBodyBytes(length);
 
-    mb.Printf("%" PRIX64 "\r\n", length);
+    mb.appendf("%" PRIX64 "\r\n", length);
     mb.append(bodyData.data, length);
-    mb.Printf("\r\n");
+    mb.append("\r\n", 2);
 }
 
 /** put terminating boundary for multiparts */
 static void
 clientPackTermBound(String boundary, MemBuf * mb)
 {
-    mb->Printf("\r\n--" SQUIDSTRINGPH "--\r\n", SQUIDSTRINGPRINT(boundary));
+    mb->appendf("\r\n--" SQUIDSTRINGPH "--\r\n", SQUIDSTRINGPRINT(boundary));
     debugs(33, 6, "clientPackTermBound: buf offset: " << mb->size);
 }
 
@@ -1043,14 +1036,13 @@ static void
 clientPackRangeHdr(const HttpReply * rep, const HttpHdrRangeSpec * spec, String boundary, MemBuf * mb)
 {
     HttpHeader hdr(hoReply);
-    Packer p;
     assert(rep);
     assert(spec);
 
     /* put boundary */
     debugs(33, 5, "clientPackRangeHdr: appending boundary: " << boundary);
     /* rfc2046 requires to _prepend_ boundary with <crlf>! */
-    mb->Printf("\r\n--" SQUIDSTRINGPH "\r\n", SQUIDSTRINGPRINT(boundary));
+    mb->appendf("\r\n--" SQUIDSTRINGPH "\r\n", SQUIDSTRINGPRINT(boundary));
 
     /* stuff the header with required entries and pack it */
 
@@ -1059,16 +1051,11 @@ clientPackRangeHdr(const HttpReply * rep, const HttpHdrRangeSpec * spec, String
 
     httpHeaderAddContRange(&hdr, *spec, rep->content_length);
 
-    packerToMemInit(&p, mb);
-
-    hdr.packInto(&p);
-
-    packerClean(&p);
-
+    hdr.packInto(mb);
     hdr.clean();
 
     /* append <crlf> (we packed a header, not a reply) */
-    mb->Printf("\r\n");
+    mb->append("\r\n", 2);
 }
 
 /**
@@ -587,7 +587,7 @@ Ftp::Client::sendEprt()
     /* RFC 2428 defines EPRT as IPv6 equivalent to IPv4 PORT command. */
     /* Which can be used by EITHER protocol. */
     debugs(9, 3, "Listening for FTP data connection on port" << comm_local_port(data.conn->fd) << " or port?" << data.conn->local.port());
-    mb.Printf("EPRT |%d|%s|%d|%s",
+    mb.appendf("EPRT |%d|%s|%d|%s",
               ( data.conn->local.isIPv6() ? 2 : 1 ),
               data.conn->local.toStr(buf,MAX_IPSTRLEN),
               comm_local_port(data.conn->fd), Ftp::crlf );
@@ -647,7 +647,7 @@ Ftp::Client::sendPassive()
     case SENT_EPSV_ALL: /* EPSV ALL resulted in a bad response. Try ther EPSV methods. */
         if (ctrl.conn->local.isIPv6()) {
             debugs(9, 5, "FTP Channel is IPv6 (" << ctrl.conn->remote << ") attempting EPSV 2 after EPSV ALL has failed.");
-            mb.Printf("EPSV 2%s", Ftp::crlf);
+            mb.appendf("EPSV 2%s", Ftp::crlf);
             state = SENT_EPSV_2;
             break;
         }
@@ -656,7 +656,7 @@ Ftp::Client::sendPassive()
     case SENT_EPSV_2: /* EPSV IPv6 failed. Try EPSV IPv4 */
         if (ctrl.conn->local.isIPv4()) {
             debugs(9, 5, "FTP Channel is IPv4 (" << ctrl.conn->remote << ") attempting EPSV 1 after EPSV ALL has failed.");
-            mb.Printf("EPSV 1%s", Ftp::crlf);
+            mb.appendf("EPSV 1%s", Ftp::crlf);
             state = SENT_EPSV_1;
             break;
         } else if (Config.Ftp.epsv_all) {
@@ -668,7 +668,7 @@ Ftp::Client::sendPassive()
 
     case SENT_EPSV_1: /* EPSV options exhausted. Try PASV now. */
         debugs(9, 5, "FTP Channel (" << ctrl.conn->remote << ") rejects EPSV connection attempts. Trying PASV instead.");
-        mb.Printf("PASV%s", Ftp::crlf);
+        mb.appendf("PASV%s", Ftp::crlf);
         state = SENT_PASV;
         break;
 
@@ -680,21 +680,21 @@ Ftp::Client::sendPassive()
         }
         if (!doEpsv) {
             debugs(9, 5, "EPSV support manually disabled. Sending PASV for FTP Channel (" << ctrl.conn->remote <<")");
-            mb.Printf("PASV%s", Ftp::crlf);
+            mb.appendf("PASV%s", Ftp::crlf);
             state = SENT_PASV;
         } else if (Config.Ftp.epsv_all) {
             debugs(9, 5, "EPSV ALL manually enabled. Attempting with FTP Channel (" << ctrl.conn->remote <<")");
-            mb.Printf("EPSV ALL%s", Ftp::crlf);
+            mb.appendf("EPSV ALL%s", Ftp::crlf);
             state = SENT_EPSV_ALL;
         } else {
             if (ctrl.conn->local.isIPv6()) {
                 debugs(9, 5, "FTP Channel (" << ctrl.conn->remote << "). Sending default EPSV 2");
-                mb.Printf("EPSV 2%s", Ftp::crlf);
+                mb.appendf("EPSV 2%s", Ftp::crlf);
                 state = SENT_EPSV_2;
             }
             if (ctrl.conn->local.isIPv4()) {
                 debugs(9, 5, "Channel (" << ctrl.conn->remote <<"). Sending default EPSV 1");
-                mb.Printf("EPSV 1%s", Ftp::crlf);
+                mb.appendf("EPSV 1%s", Ftp::crlf);
                 state = SENT_EPSV_1;
             }
         }
@@ -771,7 +771,7 @@ Ftp::Gateway::htmlifyListEntry(const char *line)
     if (strlen(line) > 1024) {
         html = new MemBuf();
         html->init();
-        html->Printf("<tr><td colspan=\"5\">%s</td></tr>\n", line);
+        html->appendf("<tr><td colspan=\"5\">%s</td></tr>\n", line);
         return html;
     }
 
@@ -785,7 +785,7 @@ Ftp::Gateway::htmlifyListEntry(const char *line)
 
         html = new MemBuf();
         html->init();
-        html->Printf("<tr class=\"entry\"><td colspan=\"5\">%s</td></tr>\n", line);
+        html->appendf("<tr class=\"entry\"><td colspan=\"5\">%s</td></tr>\n", line);
 
         for (p = line; *p && xisspace(*p); ++p);
         if (*p && !xisspace(*p))
@@ -870,7 +870,7 @@ Ftp::Gateway::htmlifyListEntry(const char *line)
     /* construct the table row from parts. */
     html = new MemBuf();
     html->init();
-    html->Printf("<tr class=\"entry\">"
+    html->appendf("<tr class=\"entry\">"
                  "<td class=\"icon\"><a href=\"%s%s\">%s</a></td>"
                  "<td class=\"filename\"><a href=\"%s%s\">%s</a></td>"
                  "<td class=\"date\">%s</td>"
@@ -132,7 +132,7 @@ Comm::TcpAcceptor::status() const
 
     static MemBuf buf;
     buf.reset();
-    buf.Printf(" FD %d, %s",conn->fd, ipbuf);
+    buf.appendf(" FD %d, %s",conn->fd, ipbuf);
 
     const char *jobStatus = AsyncJob::status();
     buf.append(jobStatus, strlen(jobStatus));
@@ -204,7 +204,7 @@ errorInitialize(void)
     if (Config.errorStylesheet) {
         ErrorPageFile tmpl("StylesSheet", ERR_MAX);
         tmpl.loadFromFile(Config.errorStylesheet);
-        error_stylesheet.Printf("%s",tmpl.text());
+        error_stylesheet.appendf("%s",tmpl.text());
     }
 
 #if USE_OPENSSL
@@ -702,72 +702,69 @@ ErrorState::Dump(MemBuf * mb)
 
     str.reset();
     /* email subject line */
-    str.Printf("CacheErrorInfo - %s", errorPageName(type));
-    mb->Printf("?subject=%s", rfc1738_escape_part(str.buf));
+    str.appendf("CacheErrorInfo - %s", errorPageName(type));
+    mb->appendf("?subject=%s", rfc1738_escape_part(str.buf));
     str.reset();
     /* email body */
-    str.Printf("CacheHost: %s\r\n", getMyHostname());
+    str.appendf("CacheHost: %s\r\n", getMyHostname());
     /* - Err Msgs */
-    str.Printf("ErrPage: %s\r\n", errorPageName(type));
+    str.appendf("ErrPage: %s\r\n", errorPageName(type));
 
     if (xerrno) {
-        str.Printf("Err: (%d) %s\r\n", xerrno, strerror(xerrno));
+        str.appendf("Err: (%d) %s\r\n", xerrno, strerror(xerrno));
     } else {
-        str.Printf("Err: [none]\r\n");
+        str.append("Err: [none]\r\n", 13);
     }
 #if USE_AUTH
     if (auth_user_request.getRaw() && auth_user_request->denyMessage())
-        str.Printf("Auth ErrMsg: %s\r\n", auth_user_request->denyMessage());
+        str.appendf("Auth ErrMsg: %s\r\n", auth_user_request->denyMessage());
 #endif
     if (dnsError.size() > 0)
-        str.Printf("DNS ErrMsg: %s\r\n", dnsError.termedBuf());
+        str.appendf("DNS ErrMsg: %s\r\n", dnsError.termedBuf());
 
     /* - TimeStamp */
-    str.Printf("TimeStamp: %s\r\n\r\n", mkrfc1123(squid_curtime));
+    str.appendf("TimeStamp: %s\r\n\r\n", mkrfc1123(squid_curtime));
 
     /* - IP stuff */
-    str.Printf("ClientIP: %s\r\n", src_addr.toStr(ntoabuf,MAX_IPSTRLEN));
+    str.appendf("ClientIP: %s\r\n", src_addr.toStr(ntoabuf,MAX_IPSTRLEN));
 
     if (request && request->hier.host[0] != '\0') {
-        str.Printf("ServerIP: %s\r\n", request->hier.host);
+        str.appendf("ServerIP: %s\r\n", request->hier.host);
     }
 
-    str.Printf("\r\n");
+    str.append("\r\n", 2);
     /* - HTTP stuff */
-    str.Printf("HTTP Request:\r\n");
+    str.append("HTTP Request:\r\n", 15);
 
     if (NULL != request) {
-        Packer pck;
         String urlpath_or_slash;
 
         if (request->urlpath.size() != 0)
             urlpath_or_slash = request->urlpath;
         else
             urlpath_or_slash = "/";
 
-        str.Printf(SQUIDSBUFPH " " SQUIDSTRINGPH " %s/%d.%d\n",
-                   SQUIDSBUFPRINT(request->method.image()),
-                   SQUIDSTRINGPRINT(urlpath_or_slash),
-                   AnyP::ProtocolType_str[request->http_ver.protocol],
-                   request->http_ver.major, request->http_ver.minor);
-        packerToMemInit(&pck, &str);
-        request->header.packInto(&pck);
-        packerClean(&pck);
+        str.appendf(SQUIDSBUFPH " " SQUIDSTRINGPH " %s/%d.%d\n",
+                    SQUIDSBUFPRINT(request->method.image()),
+                    SQUIDSTRINGPRINT(urlpath_or_slash),
+                    AnyP::ProtocolType_str[request->http_ver.protocol],
+                    request->http_ver.major, request->http_ver.minor);
+        request->header.packInto(&str);
     }
 
-    str.Printf("\r\n");
+    str.append("\r\n", 2);
     /* - FTP stuff */
 
     if (ftp.request) {
-        str.Printf("FTP Request: %s\r\n", ftp.request);
-        str.Printf("FTP Reply: %s\r\n", (ftp.reply? ftp.reply:"[none]"));
-        str.Printf("FTP Msg: ");
+        str.appendf("FTP Request: %s\r\n", ftp.request);
+        str.appendf("FTP Reply: %s\r\n", (ftp.reply? ftp.reply:"[none]"));
+        str.append("FTP Msg: ", 9);
         wordlistCat(ftp.server_msg, &str);
-        str.Printf("\r\n");
+        str.append("\r\n", 2);
     }
 
-    str.Printf("\r\n");
-    mb->Printf("&body=%s", rfc1738_escape_part(str.buf));
+    str.append("\r\n", 2);
+    mb->appendf("&body=%s", rfc1738_escape_part(str.buf));
     str.clean();
     return 0;
 }
@@ -798,7 +795,7 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
         break;
 
     case 'b':
-        mb.Printf("%d", getMyPort());
+        mb.appendf("%u", getMyPort());
         break;
 
     case 'B':
@@ -828,18 +825,18 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
         }
 #endif
         if (!mb.contentSize())
-            mb.Printf("[No Error Detail]");
+            mb.append("[No Error Detail]", 17);
         break;
 
     case 'e':
-        mb.Printf("%d", xerrno);
+        mb.appendf("%d", xerrno);
         break;
 
     case 'E':
         if (xerrno)
-            mb.Printf("(%d) %s", xerrno, strerror(xerrno));
+            mb.appendf("(%d) %s", xerrno, strerror(xerrno));
         else
-            mb.Printf("[No Error]");
+            mb.append("[No Error]", 10);
         break;
 
     case 'f':
@@ -872,7 +869,7 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
         break;
 
     case 'h':
-        mb.Printf("%s", getMyHostname());
+        mb.appendf("%s", getMyHostname());
         break;
 
     case 'H':
@@ -886,7 +883,7 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
         break;
 
     case 'i':
-        mb.Printf("%s", src_addr.toStr(ntoabuf,MAX_IPSTRLEN));
+        mb.appendf("%s", src_addr.toStr(ntoabuf,MAX_IPSTRLEN));
         break;
 
     case 'I':
@@ -905,7 +902,7 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
     case 'L':
         if (building_deny_info_url) break;
         if (Config.errHtmlText) {
-            mb.Printf("%s", Config.errHtmlText);
+            mb.appendf("%s", Config.errHtmlText);
             do_quote = 0;
         } else
             p = "[not available]";
@@ -939,7 +936,7 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
 
     case 'p':
         if (request) {
-            mb.Printf("%d", (int) request->port);
+            mb.appendf("%u", request->port);
         } else if (!building_deny_info_url) {
             p = "[unknown port]";
         }
@@ -963,22 +960,19 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
             break;
         }
         if (NULL != request) {
-            Packer pck;
             String urlpath_or_slash;
 
             if (request->urlpath.size() != 0)
                 urlpath_or_slash = request->urlpath;
             else
                 urlpath_or_slash = "/";
 
-            mb.Printf(SQUIDSBUFPH " " SQUIDSTRINGPH " %s/%d.%d\n",
-                      SQUIDSBUFPRINT(request->method.image()),
-                      SQUIDSTRINGPRINT(urlpath_or_slash),
-                      AnyP::ProtocolType_str[request->http_ver.protocol],
-                      request->http_ver.major, request->http_ver.minor);
-            packerToMemInit(&pck, &mb);
-            request->header.packInto(&pck, true); //hide authorization data
-            packerClean(&pck);
+            mb.appendf(SQUIDSBUFPH " " SQUIDSTRINGPH " %s/%d.%d\n",
+                       SQUIDSBUFPRINT(request->method.image()),
+                       SQUIDSTRINGPRINT(urlpath_or_slash),
+                       AnyP::ProtocolType_str[request->http_ver.protocol],
+                       request->http_ver.major, request->http_ver.minor);
+            request->header.packInto(&mb, true); //hide authorization data
         } else if (request_hdrs) {
             p = request_hdrs;
         } else {
@@ -1005,7 +999,7 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
             const int saved_id = page_id;
             page_id = ERR_SQUID_SIGNATURE;
             MemBuf *sign_mb = BuildContent();
-            mb.Printf("%s", sign_mb->content());
+            mb.append(sign_mb->content(), sign_mb->contentSize());
             sign_mb->clean();
             delete sign_mb;
             page_id = saved_id;
@@ -1017,11 +1011,11 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
         break;
 
     case 't':
-        mb.Printf("%s", Time::FormatHttpd(squid_curtime));
+        mb.appendf("%s", Time::FormatHttpd(squid_curtime));
         break;
 
     case 'T':
-        mb.Printf("%s", mkrfc1123(squid_curtime));
+        mb.appendf("%s", mkrfc1123(squid_curtime));
         break;
 
     case 'U':
@@ -1046,7 +1040,7 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
 
     case 'w':
         if (Config.adminEmail)
-            mb.Printf("%s", Config.adminEmail);
+            mb.appendf("%s", Config.adminEmail);
         else if (!building_deny_info_url)
             p = "[unknown]";
         break;
@@ -1061,7 +1055,7 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
     case 'x':
 #if USE_OPENSSL
         if (detail)
-            mb.Printf("%s", detail->errorName());
+            mb.appendf("%s", detail->errorName());
         else
 #endif
             if (!building_deny_info_url)
@@ -1091,7 +1085,7 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
         break;
 
     default:
-        mb.Printf("%%%c", token);
+        mb.appendf("%%%c", token);
         do_quote = 0;
         break;
     }
@@ -1125,12 +1119,12 @@ ErrorState::DenyInfoLocation(const char *name, HttpRequest *, MemBuf &result)
     while ((p = strchr(m, '%'))) {
         result.append(m, p - m);       /* copy */
         t = Convert(*++p, true, true);       /* convert */
-        result.Printf("%s", t);        /* copy */
+        result.appendf("%s", t);        /* copy */
         m = p + 1;                     /* advance */
     }
 
     if (*m)
-        result.Printf("%s", m);        /* copy tail */
+        result.appendf("%s", m);        /* copy tail */
 
     assert((size_t)result.contentSize() == strlen(result.content()));
 }
@@ -1284,12 +1278,12 @@ MemBuf *ErrorState::ConvertText(const char *text, bool allowRecursion)
     while ((p = strchr(m, '%'))) {
         content->append(m, p - m);  /* copy */
         const char *t = Convert(*++p, false, allowRecursion);   /* convert */
-        content->Printf("%s", t);   /* copy */
+        content->appendf("%s", t);   /* copy */
         m = p + 1;          /* advance */
     }
 
     if (*m)
-        content->Printf("%s", m);   /* copy tail */
+        content->appendf("%s", m);   /* copy tail */
 
     content->terminate();
 
@@ -1439,9 +1439,7 @@ ExternalACLLookup::Start(ACLChecklist *checklist, external_acl_data *acl, bool i
 
         MemBuf buf;
         buf.init();
-
-        buf.Printf("%s\n", key);
-
+        buf.appendf("%s\n", key);
         debugs(82, 4, "externalAclLookup: looking up for '" << key << "' in '" << def->name << "'.");
 
         if (!def->theHelper->trySubmit(buf.buf, externalAclHandleReply, state)) {
@@ -1307,9 +1307,9 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
                                      fmt->widthMax : strlen(out);
 
                 if (fmt->left)
-                    mb.Printf("%-*.*s", minWidth, maxWidth, out);
+                    mb.appendf("%-*.*s", minWidth, maxWidth, out);
                 else
-                    mb.Printf("%*.*s", minWidth, maxWidth, out);
+                    mb.appendf("%*.*s", minWidth, maxWidth, out);
             } else
                 mb.append(out, strlen(out));
         } else {
@@ -1386,7 +1386,7 @@ helperDispatch(helper_server * srv, Helper::Request * r)
     if (hlp->childs.concurrency) {
         srv->requestsIndex.insert(helper_server::RequestIndex::value_type(reqId, it));
         assert(srv->requestsIndex.size() == srv->requests.size());
-        srv->wqueue->Printf("%" PRIu64 " %s", reqId, r->buf);
+        srv->wqueue->appendf("%" PRIu64 " %s", reqId, r->buf);
     } else
         srv->wqueue->append(r->buf, strlen(r->buf));
 
@@ -849,17 +849,13 @@ htcpTstReply(htcpDataHeader * dhdr, StoreEntry * e, htcpSpecifier * spec, Ip::Ad
 {
     static char pkt[8192];
     HttpHeader hdr(hoHtcpReply);
-    MemBuf mb;
-    Packer p;
     ssize_t pktlen;
 
     htcpStuff stuff(dhdr->msg_id, HTCP_TST, RR_RESPONSE, 0);
     stuff.response = e ? 0 : 1;
     debugs(31, 3, "htcpTstReply: response = " << stuff.response);
 
     if (spec) {
-        mb.init();
-        packerToMemInit(&p, &mb);
         stuff.S.method = spec->method;
         stuff.S.uri = spec->uri;
         stuff.S.version = spec->version;
@@ -869,7 +865,9 @@ htcpTstReply(htcpDataHeader * dhdr, StoreEntry * e, htcpSpecifier * spec, Ip::Ad
             hdr.putInt(HDR_AGE, (e->timestamp <= squid_curtime ? (squid_curtime - e->timestamp) : 0) );
         else
             hdr.putInt(HDR_AGE, 0);
-        hdr.packInto(&p);
+        MemBuf mb;
+        mb.init();
+        hdr.packInto(&mb);
         stuff.D.resp_hdrs = xstrdup(mb.buf);
         stuff.D.respHdrsSz = mb.contentSize();
         debugs(31, 3, "htcpTstReply: resp_hdrs = {" << stuff.D.resp_hdrs << "}");
@@ -882,7 +880,7 @@ htcpTstReply(htcpDataHeader * dhdr, StoreEntry * e, htcpSpecifier * spec, Ip::Ad
         if (e && e->lastmod > -1)
             hdr.putTime(HDR_LAST_MODIFIED, e->lastmod);
 
-        hdr.packInto(&p);
+        hdr.packInto(&mb);
 
         stuff.D.entity_hdrs = xstrdup(mb.buf);
         stuff.D.entityHdrsSz = mb.contentSize();
@@ -909,13 +907,12 @@ htcpTstReply(htcpDataHeader * dhdr, StoreEntry * e, htcpSpecifier * spec, Ip::Ad
         }
 #endif /* USE_ICMP */
 
-        hdr.packInto(&p);
+        hdr.packInto(&mb);
         stuff.D.cache_hdrs = xstrdup(mb.buf);
         stuff.D.cacheHdrsSz = mb.contentSize();
         debugs(31, 3, "htcpTstReply: cache_hdrs = {" << stuff.D.cache_hdrs << "}");
         mb.clean();
         hdr.clean();
-        packerClean(&p);
     }
 
     pktlen = htcpBuildPacket(pkt, sizeof(pkt), &stuff);
@@ -1519,8 +1516,6 @@ htcpQuery(StoreEntry * e, HttpRequest * req, CachePeer * p)
     ssize_t pktlen;
     char vbuf[32];
     HttpHeader hdr(hoRequest);
-    Packer pa;
-    MemBuf mb;
     HttpStateFlags flags;
 
     if (!Comm::IsConnOpen(htcpIncomingConn))
@@ -1537,11 +1532,10 @@ htcpQuery(StoreEntry * e, HttpRequest * req, CachePeer * p)
     stuff.S.uri = (char *) e->url();
     stuff.S.version = vbuf;
     HttpStateData::httpBuildRequestHeader(req, e, NULL, &hdr, flags);
+    MemBuf mb;
     mb.init();
-    packerToMemInit(&pa, &mb);
-    hdr.packInto(&pa);
+    hdr.packInto(&mb);
     hdr.clean();
-    packerClean(&pa);
     stuff.S.req_hdrs = mb.buf;
     pktlen = htcpBuildPacket(pkt, sizeof(pkt), &stuff);
     mb.clean();
@@ -1571,7 +1565,6 @@ htcpClear(StoreEntry * e, const char *uri, HttpRequest * req, const HttpRequestM
     ssize_t pktlen;
     char vbuf[32];
     HttpHeader hdr(hoRequest);
-    Packer pa;
     MemBuf mb;
     HttpStateFlags flags;
 
@@ -1601,10 +1594,8 @@ htcpClear(StoreEntry * e, const char *uri, HttpRequest * req, const HttpRequestM
     if (reason != HTCP_CLR_INVALIDATION) {
         HttpStateData::httpBuildRequestHeader(req, e, NULL, &hdr, flags);
         mb.init();
-        packerToMemInit(&pa, &mb);
-        hdr.packInto(&pa);
+        hdr.packInto(&mb);
         hdr.clean();
-        packerClean(&pa);
         stuff.S.req_hdrs = mb.buf;
     } else {
         stuff.S.req_hdrs = NULL;
@@ -2186,26 +2186,23 @@ HttpStateData::buildRequestPrefix(MemBuf * mb)
         url = urlCanonical(request);
     else
         url = request->urlpath.termedBuf();
-    mb->Printf(SQUIDSBUFPH " %s %s/%d.%d\r\n",
-               SQUIDSBUFPRINT(request->method.image()),
-               url && *url ? url : "/",
-               AnyP::ProtocolType_str[httpver.protocol],
-               httpver.major,httpver.minor);
+    mb->appendf(SQUIDSBUFPH " %s %s/%d.%d\r\n",
+                SQUIDSBUFPRINT(request->method.image()),
+                url && *url ? url : "/",
+                AnyP::ProtocolType_str[httpver.protocol],
+                httpver.major,httpver.minor);
     /* build and pack headers */
     {
         HttpHeader hdr(hoRequest);
-        Packer p;
         httpBuildRequestHeader(request, entry, fwd->al, &hdr, flags);
 
         if (request->flags.pinned && request->flags.connectionAuth)
             request->flags.authSent = true;
         else if (hdr.has(HDR_AUTHORIZATION))
             request->flags.authSent = true;
 
-        packerToMemInit(&p, mb);
-        hdr.packInto(&p);
+        hdr.packInto(mb);
         hdr.clean();
-        packerClean(&p);
     }
     /* append header terminator */
     mb->append(crlf, 2);
@@ -2319,9 +2316,9 @@ HttpStateData::getMoreRequestBody(MemBuf &buf)
     // we may need to send: hex-chunk-size CRLF raw-data CRLF last-chunk
     buf.init(16 + 2 + rawDataSize + 2 + 5, raw.max_capacity);
 
-    buf.Printf("%x\r\n", static_cast<unsigned int>(rawDataSize));
+    buf.appendf("%x\r\n", static_cast<unsigned int>(rawDataSize));
     buf.append(raw.content(), rawDataSize);
-    buf.Printf("\r\n");
+    buf.append("\r\n", 2);
 
     Must(rawDataSize > 0); // we did not accidently created last-chunk above
 
@@ -9,9 +9,9 @@
 /* DEBUG: section 57    HTTP Status-line */
 
 #include "squid.h"
+#include "base/Packable.h"
 #include "Debug.h"
 #include "http/StatusLine.h"
-#include "Packer.h"
 
 void
 Http::StatusLine::init()
@@ -43,7 +43,7 @@ Http::StatusLine::reason() const
 }
 
 void
-Http::StatusLine::packInto(Packer * p) const
+Http::StatusLine::packInto(Packable * p) const
 {
     assert(p);
 
@@ -57,14 +57,14 @@ Http::StatusLine::packInto(Packer * p) const
         debugs(57, 9, "packing sline " << this << " using " << p << ":");
         debugs(57, 9, "FORMAT=" << IcyStatusLineFormat );
         debugs(57, 9, "ICY " << status() << " " << reason());
-        packerPrintf(p, IcyStatusLineFormat, status(), reason());
+        p->appendf(IcyStatusLineFormat, status(), reason());
         return;
     }
 
     debugs(57, 9, "packing sline " << this << " using " << p << ":");
     debugs(57, 9, "FORMAT=" << Http1StatusLineFormat );
     debugs(57, 9, "HTTP/" << version.major << "." << version.minor << " " << status() << " " << reason());
-    packerPrintf(p, Http1StatusLineFormat, version.major, version.minor, status(), reason());
+    p->appendf(Http1StatusLineFormat, version.major, version.minor, status(), reason());
 }
 
 /*
@@ -13,7 +13,7 @@
 #include "http/StatusCode.h"
 #include "SquidString.h"
 
-class Packer;
+class Packable;
 class String;
 
 namespace Http
@@ -43,8 +43,8 @@ class StatusLine
     /// retrieve the reason string for this status line
     const char *reason() const;
 
-    /// pack fields using Packer
-    void packInto(Packer * p) const;
+    /// pack fields into a Packable object
+    void packInto(Packable *) const;
 
     /**
      * Parse a buffer and fill internal structures;
@@ -264,7 +264,7 @@ Ident::Start(const Comm::ConnectionPointer &conn, IDCB * callback, void *data)
 
     // build our query from the original connection details
     state->queryMsg.init();
-    state->queryMsg.Printf("%d, %d\r\n", conn->remote.port(), conn->local.port());
+    state->queryMsg.appendf("%d, %d\r\n", conn->remote.port(), conn->local.port());
 
     ClientAdd(state, callback, data);
     hash_join(ident_hash, &state->hash);
@@ -105,17 +105,16 @@ internalRemoteUri(const char *host, unsigned short port, const char *dir, const
     static MemBuf mb;
 
     mb.reset();
-
-    mb.Printf("http://%s", lc_host);
+    mb.appendf("http://%s", lc_host);
 
     /* append port if not default */
     if (port && port != urlDefaultPort(AnyP::PROTO_HTTP))
-        mb.Printf(":%d", port);
+        mb.appendf(":%u", port);
 
     if (dir)
-        mb.Printf("%s", dir);
+        mb.append(dir, strlen(dir));
 
-    mb.Printf("%s", name);
+    mb.append(name, strlen(name));
 
     /* return a pointer to a local static buffer */
     return mb.buf;
@@ -203,7 +203,7 @@ Ipc::Inquirer::status() const
 {
     static MemBuf buf;
     buf.reset();
-    buf.Printf(" [request->requestId %u]", request->requestId);
+    buf.appendf(" [request->requestId %u]", request->requestId);
     buf.terminate();
     return buf.content();
 }
@@ -165,7 +165,7 @@ mimeGetIconURL(const char *fn)
     if (Config.icons.use_short_names) {
         static MemBuf mb;
         mb.reset();
-        mb.Printf("/squid-internal-static/icons/%s", icon);
+        mb.appendf("/squid-internal-static/icons/%s", icon);
         return mb.content();
     } else {
         return internalLocalUri("/squid-internal-static/icons/", icon);
@@ -417,7 +417,7 @@ Ftp::Server::acceptDataConnection(const CommAcceptCbParams &params)
                 Must(master->serverState == fssHandleDataRequest);
             MemBuf mb;
             mb.init();
-            mb.Printf("150 Data connection opened.\r\n");
+            mb.appendf("150 Data connection opened.\r\n");
             Comm::Write(clientConnection, &mb, call);
         }
     }
@@ -462,7 +462,7 @@ Ftp::Server::writeEarlyReply(const int code, const char *msg)
 
     MemBuf mb;
     mb.init();
-    mb.Printf("%i %s\r\n", code, msg);
+    mb.appendf("%i %s\r\n", code, msg);
 
     typedef CommCbMemFunT<Server, CommIoCbParams> Dialer;
     AsyncCall::Pointer call = JobCallback(33, 5, Dialer, this, Ftp::Server::wroteEarlyReply);
@@ -497,12 +497,12 @@ Ftp::Server::writeCustomReply(const int code, const char *msg, const HttpReply *
     MemBuf mb;
     mb.init();
     if (sendDetails) {
-        mb.Printf("%i-%s\r\n", code, msg);
-        mb.Printf(" Server reply:\r\n");
+        mb.appendf("%i-%s\r\n", code, msg);
+        mb.appendf(" Server reply:\r\n");
         Ftp::PrintReply(mb, reply, " ");
-        mb.Printf("%i \r\n", code);
+        mb.appendf("%i \r\n", code);
     } else
-        mb.Printf("%i %s\r\n", code, msg);
+        mb.appendf("%i %s\r\n", code, msg);
 
     writeReply(mb);
 }
@@ -892,7 +892,7 @@ Ftp::Server::handlePasvReply(const HttpReply *reply, StoreIOBuffer)
     // versions block responses that use those alternative syntax rules!
     MemBuf mb;
     mb.init();
-    mb.Printf("227 Entering Passive Mode (%s,%i,%i).\r\n",
+    mb.appendf("227 Entering Passive Mode (%s,%i,%i).\r\n",
               addr,
               static_cast<int>(localPort / 256),
               static_cast<int>(localPort % 256));
@@ -1063,7 +1063,7 @@ Ftp::Server::handleEpsvReply(const HttpReply *reply, StoreIOBuffer)
     // traffic will be redirected to us.
     MemBuf mb;
     mb.init();
-    mb.Printf("229 Entering Extended Passive Mode (|||%u|)\r\n", localPort);
+    mb.appendf("229 Entering Extended Passive Mode (|||%u|)\r\n", localPort);
 
     debugs(9, 3, Raw("writing", mb.buf, mb.size));
     writeReply(mb);
@@ -1080,11 +1080,11 @@ Ftp::Server::writeErrorReply(const HttpReply *reply, const int scode)
     mb.init();
 
     if (request->errType != ERR_NONE)
-        mb.Printf("%i-%s\r\n", scode, errorPageName(request->errType));
+        mb.appendf("%i-%s\r\n", scode, errorPageName(request->errType));
 
     if (request->errDetail > 0) {
         // XXX: > 0 may not always mean that this is an errno
-        mb.Printf("%i-Error: (%d) %s\r\n", scode,
+        mb.appendf("%i-Error: (%d) %s\r\n", scode,
                   request->errDetail,
                   strerror(request->errDetail));
     }
@@ -1096,9 +1096,9 @@ Ftp::Server::writeErrorReply(const HttpReply *reply, const int scode)
         const String info = ah->allMeta.getByName("X-Response-Info");
         const String desc = ah->allMeta.getByName("X-Response-Desc");
         if (info.size())
-            mb.Printf("%i-Information: %s\r\n", scode, info.termedBuf());
+            mb.appendf("%i-Information: %s\r\n", scode, info.termedBuf());
         if (desc.size())
-            mb.Printf("%i-Description: %s\r\n", scode, desc.termedBuf());
+            mb.appendf("%i-Description: %s\r\n", scode, desc.termedBuf());
     }
 #endif
 
@@ -1107,7 +1107,7 @@ Ftp::Server::writeErrorReply(const HttpReply *reply, const int scode)
                          reply->header.getStr(HDR_FTP_REASON):
                          reply->sline.reason();
 
-    mb.Printf("%i %s\r\n", scode, reason); // error terminating line
+    mb.appendf("%i %s\r\n", scode, reason); // error terminating line
 
     // TODO: errorpage.cc should detect FTP client and use
     // configurable FTP-friendly error templates which we should
@@ -1197,13 +1197,13 @@ Ftp::PrintReply(MemBuf &mb, const HttpReply *reply, const char *const)
         if (e->id == HDR_FTP_PRE) {
             String raw;
             if (httpHeaderParseQuotedString(e->value.rawBuf(), e->value.size(), &raw))
-                mb.Printf("%s\r\n", raw.termedBuf());
+                mb.appendf("%s\r\n", raw.termedBuf());
         }
     }
 
     if (header.has(HDR_FTP_STATUS)) {
         const char *reason = header.getStr(HDR_FTP_REASON);
-        mb.Printf("%i %s\r\n", header.getInt(HDR_FTP_STATUS),
+        mb.appendf("%i %s\r\n", header.getInt(HDR_FTP_STATUS),
                   (reason ? reason : 0));
     }
 }
@@ -1286,11 +1286,8 @@ Ftp::Server::handleRequest(HttpRequest *request)
 
     if (do_debug(9, 2)) {
         MemBuf mb;
-        Packer p;
         mb.init();
-        packerToMemInit(&p, &mb);
-        request->pack(&p);
-        packerClean(&p);
+        request->pack(&mb);
 
         debugs(9, 2, "FTP Client " << clientConnection);
         debugs(9, 2, "FTP Client REQUEST:\n---------\n" << mb.buf <<
@@ -541,12 +541,12 @@ Ssl::PeerConnector::status() const
     // id and stop reason reporting duplication.
     buf.append(" [", 2);
     if (stopReason != NULL) {
-        buf.Printf("Stopped, reason:");
-        buf.Printf("%s",stopReason);
+        buf.append("Stopped, reason:", 16);
+        buf.appendf("%s",stopReason);
     }
     if (serverConn != NULL)
-        buf.Printf(" FD %d", serverConn->fd);
-    buf.Printf(" %s%u]", id.Prefix, id.value);
+        buf.appendf(" FD %d", serverConn->fd);
+    buf.appendf(" %s%u]", id.Prefix, id.value);
     buf.terminate();
 
     return buf.content();
@@ -342,21 +342,17 @@ static void
 statStoreEntry(MemBuf * mb, StoreEntry * e)
 {
     MemObject *mem = e->mem_obj;
-    mb->Printf("KEY %s\n", e->getMD5Text());
-    mb->Printf("\t%s\n", describeStatuses(e));
-    mb->Printf("\t%s\n", storeEntryFlags(e));
-    mb->Printf("\t%s\n", describeTimestamps(e));
-    mb->Printf("\t%d locks, %d clients, %d refs\n",
-               (int) e->locks(),
-               storePendingNClients(e),
-               (int) e->refcount);
-    mb->Printf("\tSwap Dir %d, File %#08X\n",
-               e->swap_dirn, e->swap_filen);
+    mb->appendf("KEY %s\n", e->getMD5Text());
+    mb->appendf("\t%s\n", describeStatuses(e));
+    mb->appendf("\t%s\n", storeEntryFlags(e));
+    mb->appendf("\t%s\n", describeTimestamps(e));
+    mb->appendf("\t%d locks, %d clients, %d refs\n", (int) e->locks(), storePendingNClients(e), (int) e->refcount);
+    mb->appendf("\tSwap Dir %d, File %#08X\n", e->swap_dirn, e->swap_filen);
 
     if (mem != NULL)
         mem->stat (mb);
 
-    mb->Printf("\n");
+    mb->append("\n", 1);
 }
 
 /* process objects list */
@@ -865,24 +865,62 @@ StoreEntry::append(char const *buf, int len)
     write(tempBuffer);
 }
 
+void
+StoreEntry::vappendf(const char *fmt, va_list vargs)
+{
+    LOCAL_ARRAY(char, buf, 4096);
+    *buf = 0;
+    int x;
+
+#ifdef VA_COPY
+    va_args ap;
+    /* Fix of bug 753r. The value of vargs is undefined
+     * after vsnprintf() returns. Make a copy of vargs
+     * incase we loop around and call vsnprintf() again.
+     */
+    VA_COPY(ap,vargs);
+    errno = 0;
+    if ((x = vsnprintf(buf, sizeof(buf), fmt, ap)) < 0) {
+        fatal(xstrerr(errno));
+        return;
+    }
+    va_end(ap);
+#else /* VA_COPY */
+    errno = 0;
+    if ((x = vsnprintf(buf, sizeof(buf), fmt, vargs)) < 0) {
+        fatal(xstrerr(errno));
+        return;
+    }
+#endif /*VA_COPY*/
+
+    if (x < static_cast<int>(sizeof(buf))) {
+        append(buf, x);
+        return;
+    }
+
+    // okay, do it the slow way.
+    char *buf2 = new char[x+1];
+    int y = vsnprintf(buf2, x+1, fmt, vargs);
+    assert(y >= 0 && y == x);
+    append(buf2, y);
+    delete[] buf2;
+}
+
+// deprecated. use StoreEntry::appendf() instead.
 void
 storeAppendPrintf(StoreEntry * e, const char *fmt,...)
 {
     va_list args;
     va_start(args, fmt);
-
-    storeAppendVPrintf(e, fmt, args);
+    e->vappendf(fmt, args);
     va_end(args);
 }
 
-/* used be storeAppendPrintf and Packer */
+// deprecated. use StoreEntry::appendf() instead.
 void
 storeAppendVPrintf(StoreEntry * e, const char *fmt, va_list vargs)
 {
-    LOCAL_ARRAY(char, buf, 4096);
-    buf[0] = '\0';
-    vsnprintf(buf, 4096, fmt, vargs);
-    e->append(buf, strlen(buf));
+    e->vappendf(fmt, vargs);
 }
 
 struct _store_check_cachable_hist {
@@ -1880,26 +1918,22 @@ StoreEntry::replaceHttpReply(HttpReply *rep, bool andStartWriting)
 void
 StoreEntry::startWriting()
 {
-    Packer p;
-
     /* TODO: when we store headers serparately remove the header portion */
     /* TODO: mark the length of the headers ? */
     /* We ONLY want the headers */
-    packerToStoreInit(&p, this);
 
     assert (isEmpty());
     assert(mem_obj);
 
     const HttpReply *rep = getReply();
     assert(rep);
 
-    rep->packHeadersInto(&p);
+    buffer();
+    rep->packHeadersInto(this);
     mem_obj->markEndOfReplyHeaders();
     EBIT_CLR(flags, ENTRY_FWD_HDR_WAIT);
 
-    rep->body.packInto(&p);
-
-    packerClean(&p);
+    rep->body.packInto(this);
 }
 
 char const *
@@ -853,26 +853,21 @@ store_client::dumpStats(MemBuf * output, int clientNumber) const
     if (_callback.pending())
         return;
 
-    output->Printf("\tClient #%d, %p\n", clientNumber, _callback.callback_data);
-
-    output->Printf("\t\tcopy_offset: %" PRId64 "\n",
-                   copyInto.offset);
-
-    output->Printf("\t\tcopy_size: %d\n",
-                   (int) copyInto.length);
-
-    output->Printf("\t\tflags:");
+    output->appendf("\tClient #%d, %p\n", clientNumber, _callback.callback_data);
+    output->appendf("\t\tcopy_offset: %" PRId64 "\n", copyInto.offset);
+    output->appendf("\t\tcopy_size: %" PRIuSIZE "\n", copyInto.length);
+    output->append("\t\tflags:", 8);
 
     if (flags.disk_io_pending)
-        output->Printf(" disk_io_pending");
+        output->append(" disk_io_pending", 16);
 
     if (flags.store_copying)
-        output->Printf(" store_copying");
+        output->append(" store_copying", 14);
 
     if (flags.copy_event_pending)
-        output->Printf(" copy_event_pending");
+        output->append(" copy_event_pending", 19);
 
-    output->Printf("\n");
+    output->append("\n",1);
 }
 
 bool
@@ -18,9 +18,9 @@ HttpReply::HttpReply() : HttpMsg(hoReply), date (0), last_modified (0),
     STUB_NOP
     HttpReply::~HttpReply() STUB
     void HttpReply::setHeaders(Http::StatusCode status, const char *reason, const char *ctype, int64_t clen, time_t lmt, time_t expires_) STUB
-    void HttpReply::packHeadersInto(Packer * p) const STUB
+    void HttpReply::packHeadersInto(Packable *) const STUB
     void HttpReply::reset() STUB
-    void httpBodyPackInto(const HttpBody * body, Packer * p) STUB
+    void httpBodyPackInto(const HttpBody *, Packable *) STUB
     bool HttpReply::sanityCheckStartLine(const char *buf, const size_t hdr_len, Http::StatusCode *error) STUB_RETVAL(false)
     int HttpReply::httpMsgParseError() STUB_RETVAL(0)
     bool HttpReply::expectingBody(const HttpRequestMethod&, int64_t&) const STUB_RETVAL(false)
@@ -16,7 +16,7 @@
 HttpRequest::HttpRequest() : HttpMsg(hoRequest) STUB
     HttpRequest::HttpRequest(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath) : HttpMsg(hoRequest) STUB
     HttpRequest::~HttpRequest() STUB
-    void HttpRequest::packFirstLineInto(Packer * p, bool full_uri) const STUB
+    void HttpRequest::packFirstLineInto(Packable *, bool) const STUB
     bool HttpRequest::sanityCheckStartLine(const char*buf, const size_t hdr_len, Http::StatusCode *error) STUB_RETVAL(false)
     void HttpRequest::hdrCacheInit() STUB
     void HttpRequest::reset() STUB
@@ -15,7 +15,6 @@
 mb_size_t MemBuf::spaceSize() const STUB_RETVAL(0)
 mb_size_t MemBuf::potentialSpaceSize() const STUB_RETVAL(0)
 void MemBuf::consume(mb_size_t sz) STUB
-void MemBuf::append(const char *c, mb_size_t sz) STUB
 void MemBuf::appended(mb_size_t sz) STUB
 void MemBuf::truncate(mb_size_t sz) STUB
 void MemBuf::terminate() STUB
@@ -24,10 +23,9 @@ void MemBuf::init() STUB
 void MemBuf::clean() STUB
 void MemBuf::reset() STUB
 int MemBuf::isNull() STUB_RETVAL(1)
-void MemBuf::Printf(const char *fmt,...) STUB
-void MemBuf::vPrintf(const char *fmt, va_list ap) STUB
 FREE *MemBuf::freeFunc() STUB_RETVAL(NULL)
+void MemBuf::append(const char *, int) STUB
+void MemBuf::vappendf(const char *fmt, va_list ap) STUB
 
 void memBufReport(MemBuf * mb) STUB
-void packerToMemInit(Packer * p, MemBuf * mb) STUB
 
@@ -91,7 +91,6 @@ void StoreEntry::setReleaseFlag() STUB
 //#if USE_SQUID_ESI
 //ESIElement::Pointer StoreEntry::cachedESITree STUB_RETVAL(NULL)
 //#endif
-void StoreEntry::append(char const *, int len) STUB
 void StoreEntry::buffer() STUB
 void StoreEntry::flush() STUB
 int StoreEntry::unlock(const char *) STUB_RETVAL(0)
@@ -100,6 +99,8 @@ int64_t StoreEntry::contentLen() const STUB_RETVAL(0)
 void StoreEntry::lock(const char *) STUB
 void StoreEntry::touch() STUB
 void StoreEntry::release() STUB
+void StoreEntry::append(char const *, int) STUB
+void StoreEntry::vappendf(const char *, va_list) STUB
 
 NullStoreEntry *NullStoreEntry::getInstance() STUB_RETVAL(NULL)
 const char *NullStoreEntry::getMD5Text() const STUB_RETVAL(NULL)
@@ -142,6 +143,5 @@ void storeFsInit(void) STUB
 void storeFsDone(void) STUB
 void storeReplAdd(const char *, REMOVALPOLICYCREATE *) STUB
 void destroyStoreEntry(void *) STUB
-// in Packer.cc !? void packerToStoreInit(Packer * p, StoreEntry * e) STUB
 void storeGetMemSpace(int size) STUB
 
@@ -201,14 +201,7 @@ testRock::addEntry(const int i)
     StoreEntry *const pe = createEntry(i);
 
     pe->buffer();
-    /* TODO: remove this when the metadata is separated */
-    {
-        Packer p;
-        packerToStoreInit(&p, pe);
-        pe->getReply()->packHeadersInto(&p);
-        packerClean(&p);
-    }
-
+    pe->getReply()->packHeadersInto(pe);
     pe->flush();
     pe->timestampsSet();
     pe->complete();
@@ -152,14 +152,7 @@ testUfs::testUfsSearch()
         pe->setPublicKey();
 
         pe->buffer();
-        /* TODO: remove this when the metadata is separated */
-        {
-            Packer p;
-            packerToStoreInit(&p, pe);
-            pe->getReply()->packHeadersInto(&p);
-            packerClean(&p);
-        }
-
+        pe->getReply()->packHeadersInto(pe);
         pe->flush();
         pe->timestampsSet();
         pe->complete();
@@ -971,14 +971,11 @@ kb_incr(kb_t * k, size_t v)
 void
 debugObj(int section, int level, const char *label, void *obj, ObjPackMethod pm)
 {
-    MemBuf mb;
-    Packer p;
     assert(label && obj && pm);
+    MemBuf mb;
     mb.init();
-    packerToMemInit(&p, &mb);
-    (*pm) (obj, &p);
+    (*pm) (obj, &mb);
     debugs(section, level, "" << label << "" << mb.buf << "");
-    packerClean(&p);
     mb.clean();
 }
 
@@ -11,7 +11,6 @@
 #ifndef SQUID_TOOLS_H_
 #define SQUID_TOOLS_H_
 
-#include "Packer.h"
 #include "SBuf.h"
 #include "SquidString.h"
 #include "typedefs.h"
@@ -30,6 +29,11 @@ int getMyPort(void);
 void setUmask(mode_t mask);
 void strwordquote(MemBuf * mb, const char *str);
 
+class Packable;
+
+/* a common objPackInto interface; used by debugObj */
+typedef void (*ObjPackMethod) (void *obj, Packable * p);
+
 /* packs, then prints an object using debugs() */
 void debugObj(int section, int level, const char *label, void *obj, ObjPackMethod pm);
 
@@ -1055,23 +1055,20 @@ tunnelRelayConnectRequest(const Comm::ConnectionPointer &srv, void *data)
     TunnelStateData *tunnelState = (TunnelStateData *)data;
     assert(!tunnelState->waitingForConnectExchange());
     HttpHeader hdr_out(hoRequest);
-    Packer p;
     HttpStateFlags flags;
     debugs(26, 3, HERE << srv << ", tunnelState=" << tunnelState);
     memset(&flags, '\0', sizeof(flags));
     flags.proxying = tunnelState->request->flags.proxying;
     MemBuf mb;
     mb.init();
-    mb.Printf("CONNECT %s HTTP/1.1\r\n", tunnelState->url);
+    mb.appendf("CONNECT %s HTTP/1.1\r\n", tunnelState->url);
     HttpStateData::httpBuildRequestHeader(tunnelState->request.getRaw(),
                                           NULL,         /* StoreEntry */
                                           tunnelState->al,          /* AccessLogEntry */
                                           &hdr_out,
                                           flags);           /* flags */
-    packerToMemInit(&p, &mb);
-    hdr_out.packInto(&p);
+    hdr_out.packInto(&mb);
     hdr_out.clean();
-    packerClean(&p);
     mb.append("\r\n", 2);
 
     debugs(11, 2, "Tunnel Server REQUEST: " << tunnelState->server.conn << ":\n----------\n" <<
@@ -367,28 +367,27 @@ urnHandleReply(void *data, StoreIOBuffer result)
     e->buffer();
     mb = new MemBuf;
     mb->init();
-    mb->Printf( "<TITLE>Select URL for %s</TITLE>\n"
+    mb->appendf( "<TITLE>Select URL for %s</TITLE>\n"
                 "<STYLE type=\"text/css\"><!--BODY{background-color:#ffffff;font-family:verdana,sans-serif}--></STYLE>\n"
                 "<H2>Select URL for %s</H2>\n"
                 "<TABLE BORDER=\"0\" WIDTH=\"100%%\">\n", e->url(), e->url());
 
     for (i = 0; i < urlcnt; ++i) {
         u = &urls[i];
         debugs(52, 3, "URL {" << u->url << "}");
-        mb->Printf(
+        mb->appendf(
             "<TR><TD><A HREF=\"%s\">%s</A></TD>", u->url, u->url);
 
         if (urls[i].rtt > 0)
-            mb->Printf(
+            mb->appendf(
                 "<TD align=\"right\">%4d <it>ms</it></TD>", u->rtt);
         else
-            mb->Printf("<TD align=\"right\">Unknown</TD>");
+            mb->appendf("<TD align=\"right\">Unknown</TD>");
 
-        mb->Printf(
-            "<TD>%s</TD></TR>\n", u->flags.cached ? "    [cached]" : " ");
+        mb->appendf("<TD>%s</TD></TR>\n", u->flags.cached ? "    [cached]" : " ");
     }
 
-    mb->Printf(
+    mb->appendf(
         "</TABLE>"
         "<HR noshade size=\"1px\">\n"
         "<ADDRESS>\n"
@@ -69,7 +69,7 @@ void
 wordlistCat(const wordlist * w, MemBuf * mb)
 {
     while (NULL != w) {
-        mb->Printf("%s\n", w->key);
+        mb->appendf("%s\n", w->key);
         w = w->next;
     }
 }