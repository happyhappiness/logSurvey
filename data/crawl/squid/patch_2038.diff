@@ -1,4 +1,4 @@
-/* $Id: errorpage.cc,v 1.10 1996/04/02 21:50:22 wessels Exp $ */
+/* $Id: errorpage.cc,v 1.11 1996/04/04 01:30:42 wessels Exp $ */
 
 /* DEBUG: Section 4             cached_error: Error printing routines */
 
@@ -62,6 +62,9 @@ error_data ErrorData[] =
     {"ERR_CONNECT_FAIL",
 	"Connection Failed",
 	"The remote site or server may be down.  Please try again soon."},
+    {"ERR_INVALID_REQUEST",
+	"Invalid HTTP request",
+	"Please double check it, or ask for assistance."},
     {"ERR_INVALID_URL",
 	"Invalid URL syntax",
 	"Please double check it, or ask for assistance."},
@@ -131,9 +134,11 @@ void cached_error_entry(entry, type, msg)
 
 
 
-char *cached_error_url(url, type, msg)
+char *cached_error_url(url, method, type, address, msg)
      char *url;
+     int method;
      int type;
+     char *address;
      char *msg;
 {
     int index;
@@ -157,13 +162,40 @@ char *cached_error_url(url, type, msg)
 	getMyHostname());
     if (!log_errors)
 	return tmp_error_buf;
-    CacheInfo->log_append(CacheInfo,
-	url,
-	"0.0.0.0",
-	0,
-	ErrorData[index].tag,
-	"GET",
-	0,
-	0);
+    return tmp_error_buf;
+}
+
+
+#define CACHED_REQUEST_ERROR_MSG "\
+<TITLE>ERROR: Invalid HTTP Request</TITLE>\n\
+<H2>Invalid HTTP Request</H2>\n\
+<HR>\n\
+<PRE>\n\
+%s\n\
+</PRE>\n\
+<HR>\n\
+<ADDRESS>\n\
+Generated by cached/%s@%s\n\
+</ADDRESS>\n\
+\n"
+
+char *cached_error_request(request, type, address)
+     char *request;
+     int type;
+     char *address;
+{
+    int index;
+
+    tmp_error_buf[0] = '\0';
+    if (type == ERR_MIN || type > ERR_MAX)
+	fatal_dump("cached_error_url: type out of range.");
+    index = (int) (type - ERR_MIN);
+
+    sprintf(tmp_error_buf, CACHED_REQUEST_ERROR_MSG,
+	request,
+	SQUID_VERSION,
+	getMyHostname());
+    if (!log_errors)
+	return tmp_error_buf;
     return tmp_error_buf;
 }
@@ -1,4 +1,4 @@
-/* $Id: ftp.cc,v 1.17 1996/04/02 00:51:53 wessels Exp $ */
+/* $Id: ftp.cc,v 1.18 1996/04/04 01:30:43 wessels Exp $ */
 
 /*
  * DEBUG: Section 9           ftp: FTP
@@ -98,10 +98,8 @@ int ftp_url_parser(url, data)
     return 0;
 }
 
-int ftpCachable(url, type, mime_hdr)
+int ftpCachable(url)
      char *url;
-     char *type;
-     char *mime_hdr;
 {
     stoplist *p = NULL;
 
@@ -467,7 +465,8 @@ int ftpStart(unusedfd, url, entry)
 	COMM_SELECT_LIFETIME,
 	(PF) ftpLifetimeExpire,
 	(caddr_t) data);
-    storeAddEntry(entry);	/* Make it public */
+    if (!BIT_TEST(entry->flag, ENTRY_PRIVATE))
+	storeSetPublicKey(entry);	/* Make it public */
 
     return COMM_OK;
 }
@@ -1,4 +1,4 @@
-/* $Id: gopher.cc,v 1.13 1996/04/02 00:51:54 wessels Exp $ */
+/* $Id: gopher.cc,v 1.14 1996/04/04 01:30:44 wessels Exp $ */
 
 /*
  * DEBUG: Section 10          gopher: GOPHER
@@ -224,10 +224,8 @@ int gopher_url_parser(url, host, port, type_id, request)
     return 0;
 }
 
-int gopherCachable(url, type, mime_hdr)
+int gopherCachable(url)
      char *url;
-     char *type;
-     char *mime_hdr;
 {
     stoplist *p = NULL;
     GopherData *data = NULL;
@@ -772,7 +770,7 @@ void gopherSendComplete(fd, buf, size, errflag, data)
      */
     gopherMimeCreate(data);
 
-    if (!BIT_TEST(entry->flag, REQ_HTML))
+    if (!BIT_TEST(entry->flag, ENTRY_HTML))
 	data->conversion = NORMAL;
     else
 	switch (data->type_id) {
@@ -899,7 +897,7 @@ int gopherStart(unusedfd, url, entry)
     }
     if (((data->type_id == GOPHER_INDEX) || (data->type_id == GOPHER_CSO))
 	&& (strchr(data->request, '?') == NULL)
-	&& (BIT_TEST(entry->flag, REQ_HTML))) {
+	&& (BIT_TEST(entry->flag, ENTRY_HTML))) {
 	/* Index URL without query word */
 	/* We have to generate search page back to client. No need for connection */
 	gopherMimeCreate(data);
@@ -937,7 +935,8 @@ int gopherStart(unusedfd, url, entry)
 	COMM_SELECT_WRITE,
 	(PF) gopherSendRequest,
 	(caddr_t) data);
-    storeAddEntry(entry);	/* Make it public */
+    if (!BIT_TEST(entry->flag, ENTRY_PRIVATE))
+	storeSetPublicKey(entry);	/* Make it public */
 
     return COMM_OK;
 }
@@ -1,4 +1,4 @@
-/* $Id: http.cc,v 1.24 1996/04/02 21:50:22 wessels Exp $ */
+/* $Id: http.cc,v 1.25 1996/04/04 01:30:45 wessels Exp $ */
 
 /*
  * DEBUG: Section 11          http: HTTP
@@ -34,8 +34,13 @@ typedef struct _httpdata {
     char content_type[128];
 } HttpData;
 
-char *HTTP_OPS[] =
-{"GET", "POST", "HEAD", ""};
+char *RequestMethodStr[] =
+{
+    "NONE",
+    "GET",
+    "POST",
+    "HEAD"
+};
 
 static void httpCloseAndFree(fd, data)
      int fd;
@@ -75,28 +80,21 @@ static int http_url_parser(url, host, port, request)
     return 0;
 }
 
-int httpCachable(url, type, req_hdr)
+int httpCachable(url, method, req_hdr)
      char *url;
-     char *type;
+     int method;
      char *req_hdr;
 {
     stoplist *p = NULL;
 
     /* GET and HEAD are cachable. Others are not. */
-    if (((strncasecmp(type, "GET", 3) != 0)) &&
-	(strncasecmp(type, "HEAD", 4) != 0))
-	return 0;
-
-    /* url's requiring authentication are uncachable */
-    if (req_hdr && (strstr(req_hdr, "Authorization")))
+    if (method != METHOD_GET && method != METHOD_HEAD)
 	return 0;
 
     /* scan stop list */
-    p = http_stoplist;
-    while (p) {
+    for (p = http_stoplist; p; p = p->next) {
 	if (strstr(url, p->key))
 	    return 0;
-	p = p->next;
     }
 
     /* else cachable */
@@ -210,19 +208,23 @@ static void httpProcessReplyHeader(data, buf)
 	case 410:		/* Gone */
 	    /* These can be cached for a long time, make the key public */
 	    entry->expires = cached_curtime + ttlSet(entry);
-	    storeAddEntry(entry);
+	    if (!BIT_TEST(entry->flag, ENTRY_PRIVATE))
+		storeSetPublicKey(entry);
 	    break;
 	case 401:		/* Unauthorized */
 	case 407:		/* Proxy Authentication Required */
 	    /* These should never be cached at all */
+	    if (BIT_TEST(entry->flag, ENTRY_PRIVATE))
+		storeSetPrivateKey(entry);
 	    storeExpireNow(entry);
 	    BIT_RESET(entry->flag, CACHABLE);
 	    BIT_SET(entry->flag, RELEASE_REQUEST);
 	    break;
 	default:
 	    /* These can be negative cached, make key public */
 	    entry->expires = cached_curtime + getNegativeTTL();
-	    storeAddEntry(entry);
+	    if (!BIT_TEST(entry->flag, ENTRY_PRIVATE))
+		storeSetPublicKey(entry);
 	    break;
 	}
 	entry->mem_obj->http_code = data->http_code;
@@ -424,7 +426,7 @@ static void httpSendRequest(fd, data)
     }
     memset(buf, '\0', buflen);
 
-    sprintf(buf, "%s %s ", data->type, data->request);
+    sprintf(buf, "%s %s HTTP/1.0\r\n", data->type, data->request);
     len = strlen(buf);
     if (data->req_hdr) {	/* we have to parse the request header */
 	xbuf = xstrdup(data->req_hdr);
@@ -435,10 +437,6 @@ static void httpSendRequest(fd, data)
 		sprintf(ybuf, "%s %s %s", t, HARVEST_PROXY_TEXT, SQUID_VERSION);
 		t = ybuf;
 	    }
-#ifdef 0
-	    if (strncasecmp(t, "If-Modified-Since:", 18) == 0)
-		continue;
-#endif
 	    if (len + (int) strlen(t) > buflen - 10)
 		continue;
 	    strcat(buf, t);
@@ -511,7 +509,7 @@ int proxyhttpStart(e, url, entry)
     data->entry = entry;
 
     strncpy(data->request, url, sizeof(data->request) - 1);
-    data->type = HTTP_OPS[entry->type_id];
+    data->type = RequestMethodStr[entry->type_id];
     data->port = e->ascii_port;
     data->req_hdr = entry->mem_obj->mime_hdr;
     strncpy(data->host, e->host, sizeof(data->host) - 1);
@@ -1,4 +1,4 @@
-/* $Id: ipcache.cc,v 1.10 1996/03/29 21:19:22 wessels Exp $ */
+/* $Id: ipcache.cc,v 1.11 1996/04/04 01:30:47 wessels Exp $ */
 
 /*
  * DEBUG: Section 14          ipcache: IP Cache
@@ -98,6 +98,7 @@ void update_dns_child_alive()
 int ipcache_testname()
 {
     int success, i;
+    debug(14, 1, "Performing DNS Tests...\n");
 
     for (success = i = 0; i < TEST_SITE; i++) {
 	if (gethostbyname(test_site[i]) != NULL)
@@ -1085,7 +1086,7 @@ void ipcache_init()
 	fprintf(stderr, "ipcache_init: DNS name lookup appears to be broken on this machine.\n");
 	exit(-1);
     } else {
-	debug(14, 4, "ipcache_init: Successful DNS name lookup tests...\n");
+	debug(14, 1, "ipcache_init: Successful DNS name lookup tests...\n");
     }
 
     ip_table = hash_create(urlcmp, 229);	/* small hash table */
@@ -1,4 +1,4 @@
-/* $Id: main.cc,v 1.17 1996/04/01 18:23:52 wessels Exp $ */
+/* $Id: main.cc,v 1.18 1996/04/04 01:30:48 wessels Exp $ */
 
 /* DEBUG: Section 1             main: startup and main loop */
 
@@ -191,7 +191,7 @@ int main(argc, argv)
 	0,
 	"Ascii Port");
     if (theAsciiConnection < 0) {
-	fatal("Cannot open ascii Port\n");
+	fatal("Cannot open ascii Port");
     }
     fdstat_open(theAsciiConnection, Socket);
     fd_note(theAsciiConnection, "HTTP (Ascii) socket");
@@ -210,7 +210,7 @@ int main(argc, argv)
 		0,
 		"Ping Port");
 	    if (theUdpConnection < 0)
-		fatal("Cannot open UDP Port\n");
+		fatal("Cannot open UDP Port");
 	    fdstat_open(theUdpConnection, Socket);
 	    fd_note(theUdpConnection, "ICP (UDP) socket");
 	    comm_set_select_handler(theUdpConnection,
@@ -258,7 +258,7 @@ int main(argc, argv)
 	    errcount++;
 	    debug(1, 0, "Select loop Error. Retry. %d\n", errcount);
 	    if (errcount == 10)
-		fatal_dump("Select Loop failed.!\n");
+		fatal_dump("Select Loop failed.!");
 	    break;
 	case COMM_TIMEOUT:
 	    /* this happens after 1 minute of idle time, or
@@ -273,7 +273,7 @@ int main(argc, argv)
 	    /* house keeping */
 	    break;
 	default:
-	    fatal_dump("MAIN: Internal error -- this should never happen.\n");
+	    fatal_dump("MAIN: Internal error -- this should never happen.");
 	    break;
 	}
     }
@@ -1,41 +1,50 @@
 
-/* $Id: mime.cc,v 1.10 1996/04/01 04:56:50 wessels Exp $ */
+/* $Id: mime.cc,v 1.11 1996/04/04 01:30:48 wessels Exp $ */
+
+/*
+ * DEBUG: Section 25          mime
+ */
 
 #include "squid.h"
 #include "mime_table.h"
 
 #define GET_HDR_SZ 1024
 
-/* XXX This function frightens me for performance reasons.  It uses
- * lots of strcmp, strlen, and strcspn.  Can there be a better way? - DPW */
-
 char *mime_get_header(char *mime, char *name)
 {
     static char header[GET_HDR_SZ];
     char *p = NULL;
+    char *q = NULL;
     char got = 0;
+    int namelen = strlen(name);
 
     if (!mime || !name)
 	return NULL;
 
+    debug(25, 5, "mime_get_header: looking for '%s'\n", name);
+
     for (p = mime; *p; p += strcspn(p, "\n\r")) {
 	if (strcmp(p, "\r\n\r\n") == 0 || strcmp(p, "\n\n") == 0)
 	    return NULL;
 	while (isspace(*p))
 	    p++;
-	if (strncasecmp(p, name, strlen(name)) == 0 &&
-	    (isspace(p[strlen(name)]) || p[strlen(name)] == ':')) {
-	    strncpy(header, p, GET_HDR_SZ);
-	    header[GET_HDR_SZ - 1] = 0;
-	    header[strcspn(header, "\n\r")] = 0;
-	    p = header;
-	    p += strlen(name);
-	    if (*p == ':')
-		p++, got = 1;
-	    while (isspace(*p))
-		p++, got = 1;
-	    if (got)
-		return p;
+	if (strncasecmp(p, name, namelen))
+	    continue;
+	if (!isspace(p[namelen]) && p[namelen] != ':')
+	    continue;
+	strncpy(header, p, GET_HDR_SZ);
+	debug(25, 5, "mime_get_header: checking '%s'\n", header);
+	header[GET_HDR_SZ - 1] = 0;
+	header[strcspn(header, "\n\r")] = 0;
+	q = header;
+	q += namelen;
+	if (*q == ':')
+	    q++, got = 1;
+	while (isspace(*q))
+	    q++, got = 1;
+	if (got) {
+	    debug(25, 5, "mime_get_header: returning '%s'\n", q);
+	    return q;
 	}
     }
     return NULL;
@@ -50,8 +59,7 @@ int mime_refresh_request(mime)
     if (mime_get_header(mime, "If-Modified-Since"))
 	return 1;
     if ((pr = mime_get_header(mime, "pragma"))) {
-	/* why strstr and not strcmp? -DPW */
-	if (strstr(pr, "no-cache"))
+	if (strcasecmp(pr, "no-cache"))
 	    return 1;
     }
     return 0;
@@ -1,4 +1,4 @@
-/* $Id: neighbors.cc,v 1.8 1996/03/29 21:19:24 wessels Exp $ */
+/* $Id: neighbors.cc,v 1.9 1996/04/04 01:30:49 wessels Exp $ */
 
 /*
  * DEBUG: Section 15          neighbors:
@@ -405,7 +405,10 @@ int neighborsUdpPing(proto)
 	debug(15, 4, "neighborsUdpPing: pinging cache %s for <URL:%s>\n",
 	    e->host, url);
 
-	e->header.reqnum++;
+	/* e->header.reqnum++; */
+	e->header.reqnum = atoi(entry->key);
+	debug(15, 1, "neighborsUdpPing: key = '%s'\n", entry->key);
+	debug(15, 1, "neighborsUdpPing: reqnum = %d\n", e->header.reqnum);
 
 	if (e->udp_port == echo_port) {
 	    debug(15, 4, "neighborsUdpPing: Looks like a dumb cache, send DECHO ping\n");
@@ -512,18 +515,18 @@ void neighborsUdpAck(fd, url, header, from, entry)
 	e->pings_acked++;
     }
     /* check if someone is already fetching it */
-    if (BIT_TEST(entry->flag, REQ_DISPATCHED) || (entry->ping_status != WAITING)) {
+    if (BIT_TEST(entry->flag, ENTRY_DISPATCHED) || (entry->ping_status != WAITING)) {
 	if (entry->ping_status == DONE) {
 	    debug(15, 5, "There is already a cache/source dispatched for this object\n");
 	    debug(15, 5, "--> <URL:%s>\n", entry->url);
-	    debug(15, 5, "--> entry->flag & REQ_DISPATCHED = %d\n",
-		BIT_TEST(entry->flag, REQ_DISPATCHED));
+	    debug(15, 5, "--> entry->flag & ENTRY_DISPATCHED = %d\n",
+		BIT_TEST(entry->flag, ENTRY_DISPATCHED));
 	    debug(15, 5, "--> entry->ping_status = %d\n", entry->ping_status);
 	} else {
 	    debug(15, 5, "The ping already timed out.\n");
 	    debug(15, 5, "--> <URL:%s>\n", entry->url);
-	    debug(15, 5, "--> entry->flag & REQ_DISPATCHED = %lx\n",
-		BIT_TEST(entry->flag, REQ_DISPATCHED));
+	    debug(15, 5, "--> entry->flag & ENTRY_DISPATCHED = %lx\n",
+		BIT_TEST(entry->flag, ENTRY_DISPATCHED));
 	    debug(15, 5, "--> entry->ping_status = %d\n", entry->ping_status);
 	}
 	return;
@@ -545,7 +548,7 @@ void neighborsUdpAck(fd, url, header, from, entry)
 		HIER_SOURCE_FASTEST,
 		0,
 		inet_ntoa(from->sin_addr));
-	    BIT_SET(entry->flag, REQ_DISPATCHED);
+	    BIT_SET(entry->flag, ENTRY_DISPATCHED);
 	    entry->ping_status = DONE;
 	    getFromOrgSource(0, entry);
 	}
@@ -565,7 +568,7 @@ void neighborsUdpAck(fd, url, header, from, entry)
 	} else {
 	    hierarchy_log_append(entry->url, HIER_PARENT_HIT, 0, e->host);
 	}
-	BIT_SET(entry->flag, REQ_DISPATCHED);
+	BIT_SET(entry->flag, ENTRY_DISPATCHED);
 	entry->ping_status = DONE;
 	getFromCache(0, entry, e);
 	e->hits++;
@@ -609,7 +612,7 @@ void neighborsUdpAck(fd, url, header, from, entry)
 	}
 
 	if (entry->mem_obj->e_pings_n_acks == entry->mem_obj->e_pings_n_pings) {
-	    BIT_SET(entry->flag, REQ_DISPATCHED);
+	    BIT_SET(entry->flag, ENTRY_DISPATCHED);
 	    entry->ping_status = DONE;
 	    debug(15, 6, "Receive MISSes from all neighbors and parents\n");
 	    /* pass in fd=0 here so getFromCache() looks up the real FD
@@ -1,4 +1,4 @@
-/* $Id: stat.cc,v 1.14 1996/04/02 21:50:24 wessels Exp $ */
+/* $Id: stat.cc,v 1.15 1996/04/04 01:30:51 wessels Exp $ */
 
 /*
  * DEBUG: Section 18          stat
@@ -348,7 +348,7 @@ void server_list(obj, sentry)
     }
     for (e = getFirstEdge(); e; e = getNextEdge(e)) {
 	if (e->host == NULL)
-	    fatal_dump("Found an edge without a hostname!\n");
+	    fatal_dump("Found an edge without a hostname!");
 	sprintf(tempbuf, "\n{Hostname:    %s}\n", e->host);
 	storeAppend(sentry, tempbuf, strlen(tempbuf));
 	sprintf(tempbuf, "{Edge type:   %s}\n",
@@ -781,6 +781,8 @@ void log_append(obj, url, id, size, action, method, http_code, msec)
 
     if (!method)
 	method = "-";
+    if (!url)
+	url = "-";
 
     if (obj->logfile_status == LOG_ENABLE) {
 	if (emulate_httpd_log)
@@ -989,7 +991,7 @@ void stat_init(object, logfilename)
     if (obj->logfile_fd == DISK_ERROR) {
 	debug(18, 0, "Cannot open logfile: %s\n", obj->logfilename);
 	obj->logfile_status = LOG_DISABLE;
-	fatal("Cannot open logfile.\n");
+	fatal("Cannot open logfile.");
     }
     obj->logfile_access = file_write_lock(obj->logfile_fd);
 
@@ -1232,7 +1234,7 @@ void stat_rotate_log()
     if (CacheInfo->logfile_fd == DISK_ERROR) {
 	debug(18, 0, "rotate_logs: Cannot open logfile: %s\n", fname);
 	CacheInfo->logfile_status = LOG_DISABLE;
-	fatal("Cannot open logfile.\n");
+	fatal("Cannot open logfile.");
     }
     CacheInfo->logfile_access = file_write_lock(CacheInfo->logfile_fd);
 }
@@ -1,5 +1,5 @@
 
-/* $Id: store.cc,v 1.23 1996/04/02 21:50:25 wessels Exp $ */
+/* $Id: store.cc,v 1.24 1996/04/04 01:30:52 wessels Exp $ */
 
 /*
  * DEBUG: Section 20          store
@@ -11,7 +11,7 @@
  * 
  * Routine                  mem_status      swap_status         status 
  * ---------------------------------------------------------------------------
- * storeAdd                 NOT_IN_MEMORY   NO_SWAP
+ * storeCreateEntry         NOT_IN_MEMORY   NO_SWAP
  * storeComplete            IN_MEMORY       NO_SWAP
  * storeSwapOutStart                        SWAPPING_OUT
  * storeSwapOutHandle(fail)                 NO_SWAP
@@ -80,7 +80,7 @@ static int swaplog_lock;
 FILE *swaplog_stream = NULL;
 
 /* counter for uncachable objects */
-static int keychange_count = 0;
+static int key_counter = 0;
 
 /* key temp buffer */
 static char key_temp_buffer[MAX_URL];
@@ -127,7 +127,7 @@ static void destroy_StoreEntry(e)
 {
     debug(20, 3, "destroy_StoreEntry: destroying %p\n", e);
     if (!e)
-	fatal_dump("destroy_StoreEntry: NULL Entry\n");
+	fatal_dump("destroy_StoreEntry: NULL Entry");
     if (e->mem_obj)
 	destroy_MemObject(e->mem_obj);
     xfree(e);
@@ -163,7 +163,7 @@ int has_mem_obj(e)
      StoreEntry *e;
 {
     if (!e)
-	fatal_dump("has_mem_obj: NULL Entry\n");
+	fatal_dump("has_mem_obj: NULL Entry");
     if (e->mem_obj)
 	return 1;
     return 0;
@@ -227,14 +227,14 @@ void storeSetMemStatus(e, status)
 {
     hash_link *ptr = NULL;
 
-    /* It is not an error to call this with a NULL e->key */
-    if (e->key != NULL) {
-	if (status != IN_MEMORY && e->mem_status == IN_MEMORY) {
-	    if ((ptr = hash_lookup(in_mem_table, e->key)))
-		hash_delete_link(in_mem_table, ptr);
-	} else if (status == IN_MEMORY && e->mem_status != IN_MEMORY) {
-	    hash_insert(in_mem_table, e->key, e);
-	}
+    if (e->key == NULL)
+	fatal_dump("storeSetMemStatus: NULL key");
+
+    if (status != IN_MEMORY && e->mem_status == IN_MEMORY) {
+	if ((ptr = hash_lookup(in_mem_table, e->key)))
+	    hash_delete_link(in_mem_table, ptr);
+    } else if (status == IN_MEMORY && e->mem_status != IN_MEMORY) {
+	hash_insert(in_mem_table, e->key, e);
     }
     e->mem_status = status;
 }
@@ -248,7 +248,7 @@ void storeFreeEntry(e)
     int i;
 
     if (!e)
-	fatal_dump("storeFreeEntry: NULL Entry\n");
+	fatal_dump("storeFreeEntry: NULL Entry");
 
     debug(20, 5, "storeFreeEntry: Freeing %s\n", e->url);
 
@@ -404,215 +404,169 @@ StoreEntry *storeGet(url)
     return NULL;
 }
 
-char *storeGenerateKey(url, request_type_id)
+char *storeGeneratePrivateKey(url, type_id, num)
+     char *url;
+     int type_id;
+     int num;
+{
+    if (key_counter == 0)
+	key_counter++;
+    if (num == 0)
+	num = key_counter++;
+    debug(20, 3, "storeGeneratePrivateKey: '%s'\n", url);
+    key_temp_buffer[0] = '\0';
+    sprintf(key_temp_buffer, "%d/%s/%s",
+	num,
+	RequestMethodStr[type_id],
+	url);
+    return key_temp_buffer;
+}
+
+char *storeGeneratePublicKey(url, request_type_id)
      char *url;
      int request_type_id;
 {
-    debug(20, 5, "storeGenerateKey: type=%d %s\n", request_type_id, url);
+    debug(20, 5, "storeGeneratePublicKey: type=%d %s\n", request_type_id, url);
     switch (request_type_id) {
-    case REQUEST_OP_GET:
+    case METHOD_GET:
 	return url;
 	break;
-    case REQUEST_OP_POST:
+    case METHOD_POST:
 	sprintf(key_temp_buffer, "/post/%s", url);
 	return key_temp_buffer;
 	break;
-    case REQUEST_OP_HEAD:
+    case METHOD_HEAD:
 	sprintf(key_temp_buffer, "/head/%s", url);
 	return key_temp_buffer;
 	break;
     default:
-	fatal_dump("storeGenerateKey: Unsupported request_type_id\n");
+	fatal_dump("storeGeneratePublicKey: Unsupported request method");
 	break;
     }
     return NULL;
 }
 
-StoreEntry *storeCreateEntry(url, req_hdr, cachable, html_req, method)
-     char *url;
-     char *req_hdr;
-     int cachable;
-     int html_req;
-     int method;
+void storeSetPrivateKey(e)
+     StoreEntry *e;
 {
-    StoreEntry *e = NULL;
-    MemObject *m = NULL;
-    debug(20, 5, "storeCreateEntry: '%s'\n", url);
-    debug(20, 5, "storeCreateEntry: cachable=%d\n", cachable);
-
-    if (meta_data.hot_vm > store_hotobj_high)
-	storeGetMemSpace(0, 1);
-    e = new_StoreEntry(WITH_MEMOBJ);
-    m = e->mem_obj;
-    e->url = xstrdup(url);
-    meta_data.url_strings += strlen(url);
-    e->type_id = method;
-    if (req_hdr) {
-	m->mime_hdr = xstrdup(req_hdr);
-	if (mime_refresh_request(req_hdr))
-	    BIT_SET(e->flag, REFRESH_REQUEST);
-    }
-    if (cachable)
-	BIT_SET(e->flag, CACHABLE);
-    else
-	BIT_SET(e->flag, RELEASE_REQUEST);
-
-    if (html_req)
-	BIT_SET(e->flag, REQ_HTML);
-
-    e->status = STORE_PENDING;
-    storeSetMemStatus(e, NOT_IN_MEMORY);
-    e->swap_status = NO_SWAP;
-    e->swap_file_number = -1;
-    e->lock_count = 0;
-    m->data = new_MemObjectData();
-    e->refcount = 0;
-    e->lastref = cached_curtime;
-    e->timestamp = 0;		/* set in storeSwapOutHandle() */
-    e->ping_status = NOPING;
-
-    /* allocate pending list */
-    m->pending_list_size = MIN_PENDING;
-    m->pending = (struct pentry **)
-	xcalloc(m->pending_list_size, sizeof(struct pentry *));
-
-    /* allocate client list */
-    m->client_list_size = MIN_CLIENT;
-    m->client_list = (ClientStatusEntry **)
-	xcalloc(m->client_list_size, sizeof(ClientStatusEntry *));
-
-    return e;
+    StoreEntry *e2 = NULL;
+    hash_link *table_entry = NULL;
 
-}
+    if (e->key && BIT_TEST(e->flag, KEY_PRIVATE))
+	return;			/* is already private */
 
-static void storeSetKey(e)
-     StoreEntry *e;
-{
-    debug(20, 3, "storeSetKey: '%s'\n", e->url);
-    if (e->type_id == REQUEST_OP_GET) {
-	e->key = e->url;
-	BIT_SET(e->flag, KEY_URL);
-	return;
+    if (e->key) {
+	if ((table_entry = hash_lookup(table, e->key)))
+	    e2 = (StoreEntry *) table_entry;
+	if (e2 != e) {
+	    debug(20, 0, "storeSetPrivateKey: non-unique key: '%s'\n", e->key);
+	    return;
+	}
+	storeHashDelete(table_entry);
+	if (!BIT_TEST(e->flag, KEY_URL))
+	    safe_free(e->key);
     }
-    e->key = xstrdup(storeGenerateKey(e->url, e->type_id));
+    e->key = xstrdup(storeGeneratePrivateKey(e->url, e->type_id, 0));
+    storeHashInsert(e);
     BIT_RESET(e->flag, KEY_URL);
+    BIT_SET(e->flag, KEY_CHANGE);
+    BIT_SET(e->flag, KEY_PRIVATE);
 }
 
-void storeAddEntry(e)
+void storeSetPublicKey(e)
      StoreEntry *e;
 {
-    debug(20, 3, "storeAddEntry: '%s'\n", e->url);
-    if (!BIT_TEST(e->flag, CACHABLE)) {
-	debug(20, 0, "storeAddEntry: Called for UN-CACHABLE '%s'\n",
-	    e->url);
-	return;
+    StoreEntry *e2 = NULL;
+    hash_link *table_entry = NULL;
+
+    if (e->key && !BIT_TEST(e->flag, KEY_PRIVATE))
+	return;			/* is already public */
+
+    if (e->key) {
+	if ((table_entry = hash_lookup(table, e->key)))
+	    e2 = (StoreEntry *) table_entry;
+	if (e2 != e) {
+	    debug(20, 0, "storeSetPublicKey: non-unique key: '%s'\n", e->key);
+	    return;
+	}
+	storeHashDelete(table_entry);
+	if (!BIT_TEST(e->flag, KEY_URL))
+	    safe_free(e->key);
+    }
+    if (e->type_id == METHOD_GET) {
+	e->key = e->url;
+	BIT_SET(e->flag, KEY_URL);
+	BIT_RESET(e->flag, KEY_CHANGE);
+    } else {
+	e->key = xstrdup(storeGeneratePublicKey(e->url, e->type_id));
+	BIT_RESET(e->flag, KEY_URL);
+	BIT_SET(e->flag, KEY_CHANGE);
     }
-    storeSetKey(e);
     storeHashInsert(e);
 }
 
-
-#ifdef OLD_CODE
-/*
- * Add a new object to the cache.
- * 
- * storeAdd() is only called by icpProcessMISS()
- */
-StoreEntry *storeAdd(url, type_notused, mime_hdr, cachable, html_request, request_type_id)
+StoreEntry *storeCreateEntry(url, req_hdr, flags, method)
      char *url;
-     char *type_notused;
-     char *mime_hdr;
-     int cachable;
-     int html_request;
-     int request_type_id;
+     char *req_hdr;
+     int flags;
+     int method;
 {
-    static char key[MAX_URL + 16];
     StoreEntry *e = NULL;
-
-    debug(20, 5, "storeAdd: %s\n", url);
-
-    meta_data.store_entries++;
-    meta_data.url_strings += strlen(url);
+    MemObject *m = NULL;
+    debug(20, 5, "storeCreateEntry: '%s'\n", url);
+    debug(20, 5, "storeCreateEntry: public=%d\n",
+	BIT_TEST(flags, REQ_PUBLIC) ? 1 : 0);
 
     if (meta_data.hot_vm > store_hotobj_high)
 	storeGetMemSpace(0, 1);
-    e = create_StoreEntry();
+    e = new_StoreEntry(WITH_MEMOBJ);
+    m = e->mem_obj;
     e->url = xstrdup(url);
-    e->key = NULL;
-    e->flag = 0;
-    e->type_id = request_type_id;
-    if (mime_hdr) {
-	e->mem_obj->mime_hdr = xstrdup(mime_hdr);
-	if (mime_refresh_request(mime_hdr))
-	    BIT_SET(e->flag, REFRESH_REQUEST);
-	else
-	    BIT_RESET(e->flag, REFRESH_REQUEST);
-    }
-    if (cachable) {
+    meta_data.url_strings += strlen(url);
+    e->type_id = method;
+    if (req_hdr)
+	m->mime_hdr = xstrdup(req_hdr);
+    if (BIT_TEST(flags, REQ_NOCACHE))
+	BIT_SET(e->flag, REFRESH_REQUEST);
+    if (BIT_TEST(flags, REQ_PUBLIC)) {
 	BIT_SET(e->flag, CACHABLE);
 	BIT_RESET(e->flag, RELEASE_REQUEST);
+	BIT_RESET(e->flag, ENTRY_PRIVATE);
     } else {
 	BIT_RESET(e->flag, CACHABLE);
 	BIT_SET(e->flag, RELEASE_REQUEST);
-	/*after a lock is release, it will be released by storeUnlock */
+	BIT_SET(e->flag, ENTRY_PRIVATE);
     }
-
-    if (html_request)
-	BIT_SET(e->flag, REQ_HTML);
+    if (neighbors_do_private_keys || !BIT_TEST(flags, REQ_PUBLIC))
+	storeSetPrivateKey(e);
     else
-	BIT_RESET(e->flag, REQ_HTML);
+	storeSetPublicKey(e);
+    if (BIT_TEST(flags, REQ_HTML))
+	BIT_SET(e->flag, ENTRY_HTML);
 
     e->status = STORE_PENDING;
     storeSetMemStatus(e, NOT_IN_MEMORY);
     e->swap_status = NO_SWAP;
     e->swap_file_number = -1;
     e->lock_count = 0;
-    BIT_RESET(e->flag, KEY_CHANGE);
-    BIT_RESET(e->flag, CLIENT_ABORT_REQUEST);
-    e->mem_obj->data = memInit();
-    meta_data.hot_vm++;
+    m->data = new_MemObjectData();
     e->refcount = 0;
     e->lastref = cached_curtime;
     e->timestamp = 0;		/* set in storeSwapOutHandle() */
     e->ping_status = NOPING;
 
-    if (e->flag & CACHABLE) {
-	if (request_type_id == REQUEST_OP_GET) {
-	    e->key = e->url;
-	    BIT_SET(e->flag, KEY_URL);
-	} else {
-	    e->key = xstrdup(storeGenerateKey(e->url, request_type_id));
-	    BIT_RESET(e->flag, KEY_URL);
-	}
-    } else {
-	/* prepend a uncache count number to url for a key */
-	key[0] = '\0';
-	sprintf(key, "/%d/%s", uncache_count, url);
-	uncache_count++;
-	e->key = xstrdup(key);
-	BIT_RESET(e->flag, KEY_URL);
-    }
-
     /* allocate pending list */
-    e->mem_obj->pending_list_size = MIN_PENDING;
-    e->mem_obj->pending = (struct pentry **)
-	xcalloc(e->mem_obj->pending_list_size, sizeof(struct pentry *));
+    m->pending_list_size = MIN_PENDING;
+    m->pending = (struct pentry **)
+	xcalloc(m->pending_list_size, sizeof(struct pentry *));
 
     /* allocate client list */
-    e->mem_obj->client_list_size = MIN_CLIENT;
-    e->mem_obj->client_list = (ClientStatusEntry **)
-	xcalloc(e->mem_obj->client_list_size, sizeof(ClientStatusEntry *));
-
-    storeHashInsert(e);
-
-    /* Change the key to something private until we know it is safe
-     * to share */
-    if (!strncmp(url, "http", 4))
-	storeChangeKey(e);
-
+    m->client_list_size = MIN_CLIENT;
+    m->client_list = (ClientStatusEntry **)
+	xcalloc(m->client_list_size, sizeof(ClientStatusEntry *));
     return e;
+
 }
-#endif
 
 /* Add a new object to the cache with empty memory copy and pointer to disk
  * use to rebuild store from disk. */
@@ -639,31 +593,26 @@ StoreEntry *storeAddDiskRestore(url, file_number, size, expires, timestamp)
 
     e = new_StoreEntry(WITHOUT_MEMOBJ);
     e->url = xstrdup(url);
-    e->key = NULL;
+    BIT_RESET(e->flag, ENTRY_PRIVATE);
+    e->type_id = METHOD_GET;
+    storeSetPublicKey(e);
     e->flag = 0;
-    e->type_id = REQUEST_OP_GET;
     BIT_SET(e->flag, CACHABLE);
     BIT_RESET(e->flag, RELEASE_REQUEST);
-    BIT_SET(e->flag, REQ_HTML);
+    BIT_SET(e->flag, ENTRY_HTML);
     e->status = STORE_OK;
     storeSetMemStatus(e, NOT_IN_MEMORY);
     e->swap_status = SWAP_OK;
     e->swap_file_number = file_number;
     file_map_bit_set(file_number);
     e->object_len = size;
     e->lock_count = 0;
-    BIT_RESET(e->flag, KEY_CHANGE);
     BIT_RESET(e->flag, CLIENT_ABORT_REQUEST);
     e->refcount = 0;
     e->lastref = cached_curtime;
     e->timestamp = (u_num32) timestamp;
     e->expires = (u_num32) expires;
     e->ping_status = NOPING;
-
-    e->key = e->url;
-    BIT_SET(e->flag, KEY_URL);
-
-    storeHashInsert(e);
     return e;
 }
 
@@ -825,18 +774,16 @@ static void InvokeHandlers(e)
 
 }
 
-/* Mark object as expired
- */
+/* Mark object as expired */
 void storeExpireNow(e)
      StoreEntry *e;
 {
     debug(20, 3, "storeExpireNow: Object %s\n", e->url);
     e->expires = cached_curtime;
 }
 
-/* switch object to deleting behind mode 
- * call by retrieval module when object gets too big.
- */
+/* switch object to deleting behind mode call by
+ * retrieval module when object gets too big.  */
 void storeStartDeleteBehind(e)
      StoreEntry *e;
 {
@@ -847,7 +794,7 @@ void storeStartDeleteBehind(e)
     }
     debug(20, 2, "storeStartDeleteBehind:\tis now in delete behind mode.\n");
     /* change its key, so it couldn't be found by other client */
-    storeChangeKey(e);
+    storeSetPrivateKey(e);
     BIT_SET(e->flag, DELETE_BEHIND);
     BIT_SET(e->flag, RELEASE_REQUEST);
     BIT_RESET(e->flag, CACHABLE);
@@ -1384,8 +1331,8 @@ void storeComplete(e)
 {
     debug(20, 5, "storeComplete: <URL:%s>\n", e->url);
 
-    if (!e->key || e->flag & KEY_CHANGE) {
-	debug(20, 5, "storeComplete: No key, setting RELEASE_REQUEST\n");
+    if (e->flag & ENTRY_PRIVATE) {
+	debug(20, 5, "storeComplete: Private object, set RELEASE_REQUEST\n");
 	/* Never cache private objects */
 	BIT_SET(e->flag, RELEASE_REQUEST);
 	BIT_RESET(e->flag, CACHABLE);
@@ -1399,7 +1346,7 @@ void storeComplete(e)
     /* start writing it to disk */
     if ((e->flag & CACHABLE) &&
 	!(e->flag & RELEASE_REQUEST) &&
-	(e->type_id == REQ_GET)) {
+	(e->type_id == METHOD_GET)) {
 	storeSwapOutStart(e);
     }
     /* free up incoming MIME */
@@ -1432,7 +1379,7 @@ int storeAbort(e, msg)
      * tries to restart the fetch, say that it's been
      * dispatched already.
      */
-    BIT_SET(e->flag, REQ_DISPATCHED);
+    BIT_SET(e->flag, ENTRY_DISPATCHED);
 
     storeLockObject(e);
 
@@ -1994,10 +1941,10 @@ int storeRelease(e)
 	    fatal_dump(NULL);
 	}
     }
-    if (e->type_id == REQUEST_OP_GET) {
+    if (e->type_id == METHOD_GET) {
 	/* check if coresponding HEAD object exists. */
 	head_table_entry = hash_lookup(table,
-	    storeGenerateKey(e->url, REQUEST_OP_HEAD));
+	    storeGeneratePublicKey(e->url, METHOD_HEAD));
 	if (head_table_entry) {
 	    head_result = (StoreEntry *) head_table_entry;
 	    if (head_result) {
@@ -2028,92 +1975,6 @@ int storeRelease(e)
 }
 
 
-/* store change key */
-void storeChangeKey(e)
-     StoreEntry *e;
-{
-    StoreEntry *result = NULL;
-    static char key[MAX_URL + 32];
-    hash_link *table_entry = NULL;
-
-    if (!e)
-	return;
-
-    if (e->key == NULL) {
-	debug(25, 0, "storeChangeKey: NULL key for %s\n", e->url);
-	return;
-    }
-    if ((table_entry = hash_lookup(table, e->key)))
-	result = (StoreEntry *) table_entry;
-    if (result != e) {
-	debug(25, 1, "storeChangeKey: Key is not unique for key: %s\n", e->key);
-	return;
-    }
-    storeHashDelete(table_entry);
-    key[0] = '\0';
-    sprintf(key, "/x%d/%s", keychange_count++, e->key);
-    if (!(result->flag & KEY_URL))
-	safe_free(result->key);
-    result->key = xstrdup(key);
-    storeHashInsert(e);
-    BIT_SET(result->flag, KEY_CHANGE);
-    BIT_RESET(result->flag, KEY_URL);
-}
-
-#ifdef OLD_CODE
-void storeUnChangeKey(e)
-     StoreEntry *e;
-{
-    StoreEntry *E1 = NULL;
-    StoreEntry *E2 = NULL;
-    static char key[MAX_URL + 32];
-    hash_link *table_entry = NULL;
-    char *t = NULL;
-
-    if (!e)
-	return;
-
-    if (e->key == NULL) {
-	debug(25, 0, "storeUnChangeKey: NULL key for %s\n", e->url);
-	return;
-    }
-    if ((table_entry = hash_lookup(table, e->key)))
-	E1 = (StoreEntry *) table_entry;
-    if (E1 != e) {
-	debug(25, 1, "storeUnChangeKey: Key is not unique for key: %s\n",
-	    e->key);
-	return;
-    }
-    storeHashDelete(table_entry);
-    key[0] = '\0';
-    /* find second slash */
-    t = strchr(e->key + 1, '/');
-    if (t == NULL)
-	fatal_dump("storeUnChangeKey: Can't find a second slash.\n");
-    strcpy(key, t + 1);
-    if ((table_entry = hash_lookup(table, key))) {
-	debug(25, 0, "storeUnChangeKey: '%s' already exists!  Releasing/Moving.\n",
-	    key);
-	E2 = (StoreEntry *) table_entry;
-	/* get rid of the old entry */
-	if (storeEntryLocked(E2)) {
-	    /* change original hash key to get out of the new object's way */
-	    storeChangeKey(E2);
-	    BIT_SET(E2->flag, RELEASE_REQUEST);
-	} else {
-	    storeRelease(E2);
-	}
-    }
-    if (!(E1->flag & KEY_URL))
-	safe_free(E1->key);
-    E1->key = xstrdup(key);
-    storeHashInsert(e);
-    BIT_RESET(E1->flag, KEY_CHANGE);
-    BIT_SET(E1->flag, KEY_URL);
-    debug(25, 1, "storeUnChangeKey: Changed back to '%s'\n", key);
-}
-#endif
-
 /* return if the current key is the original one. */
 int storeOriginalKey(e)
      StoreEntry *e;
@@ -2502,7 +2363,7 @@ int urlcmp(url1, url2)
      char *url1, *url2;
 {
     if (!url1 || !url2)
-	fatal_dump("urlcmp: Got a NULL url pointer.\n");
+	fatal_dump("urlcmp: Got a NULL url pointer.");
     return (strcmp(url1, url2));
 }
 
@@ -1,4 +1,4 @@
-/* $Id: url.cc,v 1.5 1996/03/29 21:19:28 wessels Exp $ */
+/* $Id: url.cc,v 1.6 1996/04/04 01:30:53 wessels Exp $ */
 
 /* 
  * DEBUG: Section 23          url
@@ -114,16 +114,16 @@ char *the_url(e)
 	strcpy(token, e->key);
     }
 
-    if (e->type_id == REQUEST_OP_GET) {
+    if (e->type_id == METHOD_GET) {
 	/* key is url */
 	return token;
-    } else if ((e->type_id == REQUEST_OP_POST) &&
+    } else if ((e->type_id == METHOD_POST) &&
 	(!(strncmp(token, "post/", 5)) || !(strncmp(token, "/post/", 6)))) {
 	URL = strtok(token, delim);
 	URL = strtok(NULL, "~");
 	/* discard "/post/" or "post/" from the key and get url */
 	return URL;
-    } else if ((e->type_id == REQUEST_OP_HEAD) &&
+    } else if ((e->type_id == METHOD_HEAD) &&
 	(!(strncmp(token, "head/", 5)) || !(strncmp(token, "/head/", 6)))) {
 	URL = strtok(token, delim);
 	URL = strtok(NULL, "~");
@@ -1,4 +1,4 @@
-/* $Id: wais.cc,v 1.16 1996/04/02 00:51:56 wessels Exp $ */
+/* $Id: wais.cc,v 1.17 1996/04/04 01:30:54 wessels Exp $ */
 
 /*
  * DEBUG: Section 24          wais
@@ -300,6 +300,7 @@ int waisStart(unusedfd, url, type, mime_hdr, entry)
 	(PF) waisLifetimeExpire, (caddr_t) data);
     comm_set_select_handler(sock, COMM_SELECT_WRITE,
 	(PF) waisSendRequest, (caddr_t) data);
-    storeAddEntry(entry);	/* XXX Make it public */
+    if (!BIT_TEST(entry->flag, ENTRY_PRIVATE))
+	storeSetPublicKey(entry);	/* Make it public */
     return COMM_OK;
 }