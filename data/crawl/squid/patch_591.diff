@@ -1,3 +1,29 @@
+Changes to squid-3.2.0.14 (12 Dec 2011):
+
+	- Bug 3433: Segfault closing SNMP
+	- Bug 3420: Request body consumption races and !theConsumer exception.
+	- Bug 3406: SSL Log Error in debug
+	- Bug 3383: store.cc:1631: "new_status != IN_MEMORY" assertion
+	- Bug 3383: unhandled exception: theGroupBSize > 0
+	- Bug 3377: assertion failed: store.cc:885: "store_status == STORE_PENDING"
+	- Bug 3367: fix inverted check on host_strict_verify
+	- Bug 3366: assertion comm.cc:1276: isOpen(fd) via CompositePoolNode::kickReads
+	- Bug 3364: SNMP Orphans
+	- Bug 3301: ERR_DNS_FAIL never shown
+	- Bug 3150: do not start useless unlinkd
+	- ext_session_acl: version 1.2
+	- Add adaptation_meta option
+	- Add a mask on the qos_flows miss configuration value
+	- Support intermediate CA in ssl-bump traffic certificates
+	- Support SSL certificate failure details on error page
+	- Fix flags for NAT intercept and TPROXY not set correctly
+	- Fix fastCheck() default result on multi-line actions
+	- Fix missing SMP shared memory statistics
+	- Fix Comm::Write closing() assertion when retrying a failed UDP DNS query
+	- ... and several other TCP and SMP support behaviour fixes
+	- ... and many code polishing cleanups and fixed build errors
+	- ... and several documentation polishings
+
 Changes to squid-3.2.0.13 (14 Oct 2011):
 
 	- Regression Bug 3363: never_direct always 'unable to forward this request at this time'
@@ -113,7 +113,6 @@ section 65    HTTP Cache Control Header
 section 66    HTTP Header Tools
 section 67    String
 section 68    HTTP Content-Range Header
-section 69    HTTP Header: Extension Field
 section 70    Cache Digest
 section 71    Store Digest Manager
 section 72    Peer Digest Routines
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.2.0.13 release notes</title>
+<title>Squid 3.2.0.14 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.2.0.13 for testing.
+The Squid Team are pleased to announce the release of Squid-3.2.0.14 for testing.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.2/"> or the <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
 
@@ -214,6 +214,7 @@ Most user-facing changes are reflected in squid.conf (see below).
 	<item>squid_ldap_group - ext_ldap_group_acl - Check logged in users Group membership using LDAP.
 	<item>mswin_check_lm_group - ext_lm_group_acl - Check logged in users Group membership using LanManager.
 	<item>squid_session - ext_session_acl - Maintain a session cache of client identifiers (usually IP address).
+			This helper has also gone through a version update and now uses more current BerkeleyDB 4.1+ APIs.
 	<item>squid_unix_group - ext_unix_group_acl - Check logged in users Group membership using local UNIX groups.
 	<item>wbinfo_group.pl - ext_wbinfo_group_acl - Check logged in users Group membership using wbinfo.
 </itemize>
@@ -377,6 +378,10 @@ This section gives a thorough account of those changes in three categories:
 <sect1>New tags<label id="newtags">
 <p>
 <descrip>
+	<tag>adaptation_meta</tag>
+	<p>This option allows Squid administrator to add custom ICAP request
+	   headers or eCAP options to Squid ICAP requests or eCAP transactions.
+
 	<tag>adaptation_send_client_ip</tag>
 	<p>Same as depricated icap_send_client_ip
 	   but applies to both ICAP and eCAP.</p>
@@ -0,0 +1,102 @@
+/*
+ * FileMap.h
+ *
+ * DEBUG: section 08    Swap File Bitmap
+ * AUTHOR: Harvest Derived
+ *
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ */
+
+#ifndef FILEMAP_H_
+#define FILEMAP_H_
+
+#include "typedefs.h"
+
+/** A bitmap used for managing UFS StoreEntry "file numbers".
+ *
+ * Nth bit represents whether file number N is used.
+ * The map automatically grows to hold up to 2^24 bits.
+ * New bit is "off" or zero by default, representing unused fileno.
+ * TODO: consider using std::bitset instead.
+ */
+class FileMap
+{
+public:
+    FileMap();
+    ~FileMap();
+
+    /** Set the num-th bit in the FileMap
+     *
+     * \warning FileMap's backing storage will be extended as needed to
+     * hold the representation, but  if the bit is already set
+     * it will break the file number accounting, so the caller must
+     * ensure that setBit is only called if the bit is not already set,
+     * by using testBit on it before.
+     */
+    bool setBit(sfileno num);
+
+    /// Test whether the num-th bit in the FileMap is set
+    bool testBit(sfileno num) const;
+
+    /** Clear the num-th bit in the FileMap
+     *
+     * \warning that clearBit doesn't do any bounds checking, nor it
+     * checks that the bit is set before clearing. The caller will have
+     * to ensure that both are true using testBit before clearing.
+     */
+    void clearBit(sfileno num);
+
+    /** locate an unused slot in the FileMap, possibly at or after position suggestion
+     *
+     * Obtain the location of an unused slot in the FileMap,
+     * growing it if needed.
+     * The suggestion is only an advice; there is no guarantee
+     * that it will be followed.
+     */
+    sfileno allocate(sfileno suggestion);
+
+    /// return the max number of slots in the FileMap
+    int capacity() const {return capacity_;}
+
+    /// return the number of used slots in the FileMap
+    int numFilesInMap() const {return usedSlots_;}
+private:
+    /// grow the FileMap (size is doubled each time, up to 2^24 bits)
+    void grow();
+    FileMap(const FileMap &); //no copying
+    FileMap& operator=(const FileMap &); //no assignments
+
+    /// max number of files which can be tracked in the current store
+    sfileno capacity_;
+    /// used slots in the map
+    unsigned int usedSlots_;
+    /// number of "long ints" making up the filemap
+    unsigned int nwords;
+    unsigned long *bitmap;
+};
+
+#endif /* FILEMAP_H_ */
@@ -43,22 +43,19 @@ HttpBody::HttpBody() : mb(new MemBuf)
 
 HttpBody::~HttpBody()
 {
-	clear();
-	delete mb;
+    delete mb;
 }
 
 void
 HttpBody::clear()
 {
-    if(!mb->isNull())
-        mb->clean();
+    mb->clean();
 }
 
 /* set body by absorbing mb */
 void
 HttpBody::setMb(MemBuf * mb_)
 {
-    clear();
     delete mb;
     /* note: protection against assign-to-self is not needed
      * as MemBuf doesn't have a copy-constructor. If such a constructor
@@ -40,7 +40,8 @@ class Packer;
  * This class is useful to represent short HTTP messages, whose
  * contents are known in advance, e.g. error messages
  */
-class HttpBody {
+class HttpBody
+{
 public:
     HttpBody();
     ~HttpBody();
@@ -1,101 +0,0 @@
-
-/*
- * $Id$
- *
- * DEBUG: section 69    HTTP Header: Extension Field
- * AUTHOR: Alex Rousskov
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- */
-
-#include "squid.h"
-
-/* local prototypes */
-static HttpHdrExtField *httpHdrExtFieldDoCreate(const char *name, int name_len, const char *value, int val_len);
-
-
-/* implementation */
-
-static HttpHdrExtField *
-httpHdrExtFieldDoCreate(const char *name, int name_len,
-                        const char *value, int value_len)
-{
-    HttpHdrExtField *f = new HttpHdrExtField;
-    stringLimitInit(&f->name, name, name_len);
-    stringLimitInit(&f->value, value, value_len);
-    return f;
-}
-
-HttpHdrExtField *
-httpHdrExtFieldCreate(const char *name, const char *value)
-{
-    return httpHdrExtFieldDoCreate(
-               name, strlen(name),
-               value, strlen(value));
-}
-
-/* parses ext field; returns fresh ext field on success and NULL on failure */
-HttpHdrExtField *
-httpHdrExtFieldParseCreate(const char *field_start, const char *field_end)
-{
-    /* note: name_start == field_start */
-    const char *name_end = strchr(field_start, ':');
-    const char *value_start;
-    /* note: value_end == field_end */
-
-    if (!name_end || name_end <= field_start || name_end > field_end)
-        return NULL;
-
-    value_start = name_end + 1;	/* skip ':' */
-
-    /* skip white space */
-    while (value_start < field_end && xisspace(*value_start))
-        value_start++;
-
-    return httpHdrExtFieldDoCreate(
-               field_start, name_end - field_start,
-               value_start, field_end - value_start);
-}
-
-void
-httpHdrExtFieldDestroy(HttpHdrExtField * f)
-{
-    assert(f);
-    f->name.clean();
-    f->value.clean();
-    delete f;
-}
-
-HttpHdrExtField *
-httpHdrExtFieldDup(HttpHdrExtField * f)
-{
-    assert(f);
-    return httpHdrExtFieldDoCreate(
-               f->name.rawBuf(), f->name.size(),
-               f->value.rawBuf(), f->value.size());
-}
@@ -323,6 +323,7 @@ squid_SOURCES = \
 	fd.cc \
 	fde.cc \
 	fde.h \
+	FileMap.h \
 	filemap.cc \
 	forward.cc \
 	forward.h \
@@ -1144,6 +1145,7 @@ tests_testACLMaxUserIP_SOURCES= \
 	DiskIO/WriteRequest.cc \
 	ETag.cc \
 	event.cc \
+	FileMap.h \
 	filemap.cc \
 	HelperChildConfig.h \
 	HelperChildConfig.cc \
@@ -1308,6 +1310,7 @@ tests_testCacheManager_SOURCES = \
 	ExternalACLEntry.cc \
 	fd.cc \
 	fde.cc \
+	FileMap.h \
 	filemap.cc \
 	forward.cc \
 	fqdncache.cc \
@@ -1462,6 +1465,7 @@ tests_testDiskIO_SOURCES = \
 	EventLoop.cc \
 	event.cc \
 	fd.cc \
+	FileMap.h \
 	filemap.cc \
 	HttpBody.h \
 	HttpBody.cc \
@@ -1632,6 +1636,7 @@ tests_testEvent_SOURCES = \
 	FadingCounter.cc \
 	fd.cc \
 	fde.cc \
+	FileMap.h \
 	filemap.cc \
 	forward.cc \
 	fqdncache.cc \
@@ -1824,6 +1829,7 @@ tests_testEventLoop_SOURCES = \
 	FadingCounter.cc \
 	fd.cc \
 	fde.cc \
+	FileMap.h \
 	filemap.cc \
 	forward.cc \
 	fqdncache.cc \
@@ -2014,6 +2020,7 @@ tests_test_http_range_SOURCES = \
 	FadingCounter.cc \
 	fd.cc \
 	fde.cc \
+	FileMap.h \
 	filemap.cc \
 	forward.cc \
 	fqdncache.cc \
@@ -2397,6 +2404,7 @@ tests_testStore_SOURCES= \
 	ETag.cc \
 	event.cc \
 	EventLoop.cc \
+	FileMap.h \
 	filemap.cc \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
@@ -2591,6 +2599,7 @@ tests_testUfs_SOURCES = \
 	tests/stub_store_stats.cc \
 	fd.cc \
 	disk.cc \
+	FileMap.h \
 	filemap.cc \
 	HttpBody.h \
 	HttpBody.cc \
@@ -2724,6 +2733,7 @@ tests_testRock_SOURCES = \
 	EventLoop.cc \
 	event.cc \
 	fd.cc \
+	FileMap.h \
 	filemap.cc \
 	HttpBody.h \
 	HttpBody.cc \
@@ -2857,6 +2867,7 @@ tests_testCoss_SOURCES = \
 	tests/stub_store_stats.cc \
 	fd.cc \
 	disk.cc \
+	FileMap.h \
 	filemap.cc \
 	HttpBody.h \
 	HttpBody.cc \
@@ -2992,6 +3003,7 @@ tests_testNull_SOURCES = \
 	tests/stub_store_stats.cc \
 	fd.cc \
 	disk.cc \
+	FileMap.h \
 	filemap.cc \
 	HttpBody.h \
 	HttpBody.cc \
@@ -3144,6 +3156,7 @@ tests_testURL_SOURCES = \
 	ExternalACLEntry.cc \
 	fd.cc \
 	fde.cc \
+	FileMap.h \
 	filemap.cc \
 	forward.cc \
 	fqdncache.cc \
@@ -216,7 +216,6 @@ ACLChecklist::matchAclList(const ACLList * head, bool const fast)
         }
 
         if (!nodeMatched || state_ != NullState::Instance()) {
-            debugs(28, 3, "aclmatchAclList: " << this << " returning false (AND list entry failed to match)");
 
             bool async = state_ != NullState::Instance();
 
@@ -230,6 +229,7 @@ ACLChecklist::matchAclList(const ACLList * head, bool const fast)
                    " finished() = " << finished());
 
             if (finished()) {
+                debugs(28, 3, "aclmatchAclList: " << this << " returning (AND list entry failed to match)");
                 PROF_stop(aclMatchAclList);
                 return;
             }
@@ -240,8 +240,8 @@ ACLChecklist::matchAclList(const ACLList * head, bool const fast)
                 continue;
             }
 
+            debugs(28, 3, "aclmatchAclList: " << this << " returning (AND list entry awaiting an async lookup)");
             PROF_stop(aclMatchAclList);
-
             return;
         }
 
@@ -14,9 +14,8 @@ class UnaryCbdataDialer : public CallDialer
 
     UnaryCbdataDialer(Handler *aHandler, Argument1 *aArg) :
             arg1(aArg),
-            handler(aHandler)
-    {}
-    
+            handler(aHandler) {}
+
     virtual bool canDial(AsyncCall &call) { return arg1.valid(); }
     void dial(AsyncCall &call) { handler(arg1.get()); }
     virtual void print(std::ostream &os) const {  os << '(' << arg1 << ')'; }
@@ -1521,6 +1521,7 @@ ClientSocketContextPushDeferredIfNeeded(ClientSocketContext::Pointer deferredReq
      */
 }
 
+/// called when we have successfully finished writing the response
 void
 ClientSocketContext::keepaliveNextRequest()
 {
@@ -1535,6 +1536,26 @@ ClientSocketContext::keepaliveNextRequest()
         return;
     }
 
+    /** \par
+     * We are done with the response, and we are either still receiving request
+     * body (early response!) or have already stopped receiving anything.
+     *
+     * If we are still receiving, then clientParseRequest() below will fail.
+     * (XXX: but then we will call readNextRequest() which may succeed and
+     * execute a smuggled request as we are not done with the current request).
+     *
+     * If we stopped because we got everything, then try the next request.
+     *
+     * If we stopped receiving because of an error, then close now to avoid
+     * getting stuck and to prevent accidental request smuggling.
+     */
+
+    if (const char *reason = conn->stoppedReceiving()) {
+        debugs(33, 3, HERE << "closing for earlier request error: " << reason);
+        conn->clientConnection->close();
+        return;
+    }
+
     /** \par
      * Attempt to parse a request from the request buffer.
      * If we've been fed a pipelined request it may already
@@ -1779,44 +1800,35 @@ ClientSocketContext::doClose()
     clientConnection->close();
 }
 
-/** Called to initiate (and possibly complete) closing of the context.
- * The underlying socket may be already closed */
+/// called when we encounter a response-related error
 void
 ClientSocketContext::initiateClose(const char *reason)
 {
-    debugs(33, 5, HERE << "initiateClose: closing for " << reason);
-
-    if (http != NULL) {
-        ConnStateData * conn = http->getConn();
-
-        if (conn != NULL) {
-            if (const int64_t expecting = conn->mayNeedToReadMoreBody()) {
-                debugs(33, 5, HERE << "ClientSocketContext::initiateClose: " <<
-                       "closing, but first " << conn << " needs to read " <<
-                       expecting << " request body bytes with " <<
-                       conn->in.notYetUsed << " notYetUsed");
+    http->getConn()->stopSending(reason); // closes ASAP
+}
 
-                if (conn->closing()) {
-                    debugs(33, 2, HERE << "avoiding double-closing " << conn);
-                    return;
-                }
+void
+ConnStateData::stopSending(const char *error)
+{
+    debugs(33, 4, HERE << "sending error (" << clientConnection << "): " << error <<
+           "; old receiving error: " <<
+           (stoppedReceiving() ? stoppedReceiving_ : "none"));
 
-                /*
-                * XXX We assume the reply fits in the TCP transmit
-                * window.  If not the connection may stall while sending
-                * the reply (before reaching here) if the client does not
-                * try to read the response while sending the request body.
-                * As of yet we have not received any complaints indicating
-                * this may be an issue.
-                */
-                conn->startClosing(reason);
+    if (const char *oldError = stoppedSending()) {
+        debugs(33, 3, HERE << "already stopped sending: " << oldError);
+        return; // nothing has changed as far as this connection is concerned
+    }
+    stoppedSending_ = error;
 
-                return;
-            }
+    if (!stoppedReceiving()) {
+        if (const int64_t expecting = mayNeedToReadMoreBody()) {
+            debugs(33, 5, HERE << "must still read " << expecting <<
+                   " request body bytes with " << in.notYetUsed << " unused");
+            return; // wait for the request receiver to finish reading
         }
     }
 
-    doClose();
+    clientConnection->close();
 }
 
 void
@@ -2937,10 +2949,11 @@ ConnStateData::handleRequestBodyData()
     if (!bodyPipe) {
         debugs(33,5, HERE << "produced entire request body for " << clientConnection);
 
-        if (closing()) {
+        if (const char *reason = stoppedSending()) {
             /* we've finished reading like good clients,
              * now do the close that initiateClose initiated.
              */
+            debugs(33, 3, HERE << "closing for earlier sending error: " << reason);
             clientConnection->close();
             return false;
         }
@@ -3037,7 +3050,7 @@ ConnStateData::noteMoreBodySpaceAvailable(BodyPipe::Pointer )
         return;
 
     // too late to read more body
-    if (!isOpen() || closing())
+    if (!isOpen() || stoppedReceiving())
         return;
 
     readSomeData();
@@ -3046,8 +3059,11 @@ ConnStateData::noteMoreBodySpaceAvailable(BodyPipe::Pointer )
 void
 ConnStateData::noteBodyConsumerAborted(BodyPipe::Pointer )
 {
-    if (!closing())
-        startClosing("body consumer aborted");
+    // request reader may get stuck waiting for space if nobody consumes body
+    if (bodyPipe != NULL)
+        bodyPipe->enableAutoConsumption();
+
+    stopReceiving("virgin request body consumer aborted"); // closes ASAP
 }
 
 /** general lifetime handler for HTTP requests */
@@ -3857,8 +3873,9 @@ CBDATA_CLASS_INIT(ConnStateData);
 
 ConnStateData::ConnStateData() :
         AsyncJob("ConnStateData"),
-        closing_(false),
-        switchedToHttps_(false)
+        switchedToHttps_(false),
+        stoppedSending_(NULL),
+        stoppedReceiving_(NULL)
 {
     pinning.pinned = false;
     pinning.auth = false;
@@ -3915,32 +3932,24 @@ ConnStateData::mayNeedToReadMoreBody() const
     return needToProduce - haveAvailable;
 }
 
-bool
-ConnStateData::closing() const
-{
-    return closing_;
-}
-
-/**
- * Called by ClientSocketContext to give the connection a chance to read
- * the entire body before closing the socket.
- */
 void
-ConnStateData::startClosing(const char *reason)
+ConnStateData::stopReceiving(const char *error)
 {
-    debugs(33, 5, HERE << "startClosing " << this << " for " << reason);
-    assert(!closing());
-    closing_ = true;
+    debugs(33, 4, HERE << "receiving error (" << clientConnection << "): " << error <<
+           "; old sending error: " <<
+           (stoppedSending() ? stoppedSending_ : "none"));
 
-    assert(bodyPipe != NULL);
+    if (const char *oldError = stoppedReceiving()) {
+        debugs(33, 3, HERE << "already stopped receiving: " << oldError);
+        return; // nothing has changed as far as this connection is concerned
+    }
 
-    // We do not have to abort the body pipeline because we are going to
-    // read the entire body anyway.
-    // Perhaps an ICAP server wants to log the complete request.
+    stoppedReceiving_ = error;
 
-    // If a consumer abort have caused this closing, we may get stuck
-    // as nobody is consuming our data. Allow auto-consumption.
-    bodyPipe->enableAutoConsumption();
+    if (const char *sendError = stoppedSending()) {
+        debugs(33, 3, HERE << "closing because also stopped sending: " << sendError);
+        clientConnection->close();
+    }
 }
 
 void
@@ -260,8 +260,15 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
     bool reading() const;
     void stopReading(); ///< cancels comm_read if it is scheduled
 
-    bool closing() const;
-    void startClosing(const char *reason);
+    /// true if we stopped receiving the request
+    const char *stoppedReceiving() const { return stoppedReceiving_; }
+    /// true if we stopped sending the response
+    const char *stoppedSending() const { return stoppedSending_; }
+    /// note request receiving error and close as soon as we write the response
+    void stopReceiving(const char *error);
+    /// note response sending error and close as soon as we read the request
+    void stopSending(const char *error);
+
     void expectNoForwarding(); ///< cleans up virgin request [body] forwarding state
 
     BodyPipe::Pointer expectRequestBody(int64_t size);
@@ -341,9 +348,14 @@ class ConnStateData : public BodyProducer, public HttpControlMsgSink
 
     // XXX: CBDATA plays with public/private and leaves the following 'private' fields all public... :(
     CBDATA_CLASS2(ConnStateData);
-    bool closing_;
 
     bool switchedToHttps_;
+
+    /// the reason why we no longer write the response or nil
+    const char *stoppedSending_;
+    /// the reason why we no longer read the request or nil
+    const char *stoppedReceiving_;
+
     String sslHostName; ///< Host name for SSL certificate generation
     AsyncCall::Pointer reader; ///< set when we are reading
     BodyPipe::Pointer bodyPipe; // set when we are reading request body
@@ -1,6 +1,4 @@
 /*
- * $Id$
- *
  * DEBUG: section 08    Swap File Bitmap
  * AUTHOR: Harvest Derived
  *
@@ -32,7 +30,9 @@
  *
  */
 
-#include "squid.h"
+#include "config.h"
+#include "Debug.h"
+#include "FileMap.h"
 
 /* Number of bits in a long */
 #if SIZEOF_LONG == 8
@@ -54,133 +54,107 @@
 
 #define FM_INITIAL_NUMBER (1<<14)
 
-fileMap *
-file_map_create(void)
+FileMap::FileMap() :
+        capacity_(FM_INITIAL_NUMBER), usedSlots_(0),
+        nwords(capacity_ >> LONG_BIT_SHIFT)
 {
-    fileMap *fm = (fileMap *)xcalloc(1, sizeof(fileMap));
-    fm->max_n_files = FM_INITIAL_NUMBER;
-    fm->nwords = fm->max_n_files >> LONG_BIT_SHIFT;
-    debugs(8, 3, "file_map_create: creating space for " << fm->max_n_files << " files");
-    debugs(8, 5, "--> " << fm->nwords << " words of " << sizeof(*fm->file_map) << " bytes each");
-    fm->file_map = (unsigned long *)xcalloc(fm->nwords, sizeof(*fm->file_map));
-    /* XXX account fm->file_map */
-    return fm;
+    debugs(8, 3, HERE << "creating space for " << capacity_ << " files");
+    debugs(8, 5, "--> " << nwords << " words of " << sizeof(*bitmap) << " bytes each");
+    bitmap = (unsigned long *)xcalloc(nwords, sizeof(*bitmap));
 }
 
-static void
-file_map_grow(fileMap * fm)
+void
+FileMap::grow()
 {
-    int old_sz = fm->nwords * sizeof(*fm->file_map);
-    void *old_map = fm->file_map;
-    fm->max_n_files <<= 1;
-    assert(fm->max_n_files <= (1 << 24));	/* swap_filen is 25 bits, signed */
-    fm->nwords = fm->max_n_files >> LONG_BIT_SHIFT;
-    debugs(8, 3, "file_map_grow: creating space for " << fm->max_n_files << " files");
-    debugs(8, 5, "--> " << fm->nwords << " words of " << sizeof(*fm->file_map) << " bytes each");
-    fm->file_map = (unsigned long *)xcalloc(fm->nwords, sizeof(*fm->file_map));
+    int old_sz = nwords * sizeof(*bitmap);
+    void *old_map = bitmap;
+    capacity_ <<= 1;
+    assert(capacity_ <= (1 << 24));	/* swap_filen is 25 bits, signed */
+    nwords = capacity_ >> LONG_BIT_SHIFT;
+    debugs(8, 3, HERE << " creating space for " << capacity_ << " files");
+    debugs(8, 5, "--> " << nwords << " words of " << sizeof(*bitmap) << " bytes each");
+    bitmap = (unsigned long *)xcalloc(nwords, sizeof(*bitmap));
     debugs(8, 3, "copying " << old_sz << " old bytes");
-    memcpy(fm->file_map, old_map, old_sz);
+    memcpy(bitmap, old_map, old_sz);
     xfree(old_map);
-    /* XXX account fm->file_map */
+    /* XXX account fm->bitmap */
 }
 
-int
-file_map_bit_set(fileMap * fm, int file_number)
+bool
+FileMap::setBit(sfileno file_number)
 {
     unsigned long bitmask = (1L << (file_number & LONG_BIT_MASK));
 
-    while (file_number >= fm->max_n_files)
-        file_map_grow(fm);
+    while (file_number >= capacity_)
+        grow();
 
-    fm->file_map[file_number >> LONG_BIT_SHIFT] |= bitmask;
+    bitmap[file_number >> LONG_BIT_SHIFT] |= bitmask;
 
-    fm->n_files_in_map++;
+    usedSlots_++;
 
     return file_number;
 }
 
 /*
- * WARNING: file_map_bit_reset does not perform array bounds
+ * WARNING: clearBit does not perform array bounds
  * checking!  It assumes that 'file_number' is valid, and that the
  * bit is already set.  The caller must verify both of those
- * conditions by calling file_map_bit_test() first.
+ * conditions by calling testBit
+ * () first.
  */
 void
-file_map_bit_reset(fileMap * fm, int file_number)
+FileMap::clearBit(sfileno file_number)
 {
     unsigned long bitmask = (1L << (file_number & LONG_BIT_MASK));
-    fm->file_map[file_number >> LONG_BIT_SHIFT] &= ~bitmask;
-    fm->n_files_in_map--;
+    bitmap[file_number >> LONG_BIT_SHIFT] &= ~bitmask;
+    usedSlots_--;
 }
 
-int
-file_map_bit_test(fileMap * fm, int file_number)
+bool
+FileMap::testBit(sfileno file_number) const
 {
     unsigned long bitmask = (1L << (file_number & LONG_BIT_MASK));
 
-    if (file_number >= fm->max_n_files)
+    if (file_number >= capacity_)
         return 0;
 
     /* be sure the return value is an int, not a u_long */
-    return (fm->file_map[file_number >> LONG_BIT_SHIFT] & bitmask ? 1 : 0);
+    return (bitmap[file_number >> LONG_BIT_SHIFT] & bitmask ? 1 : 0);
 }
 
-int
-file_map_allocate(fileMap * fm, int suggestion)
+sfileno
+FileMap::allocate(sfileno suggestion)
 {
     int word;
-    int bit;
-    int count;
 
-    if (suggestion >= fm->max_n_files)
+    if (suggestion >= capacity_)
         suggestion = 0;
 
-    if (!file_map_bit_test(fm, suggestion))
+    if (!testBit(suggestion))
         return suggestion;
 
     word = suggestion >> LONG_BIT_SHIFT;
 
-    for (count = 0; count < fm->nwords; count++) {
-        if (fm->file_map[word] != ALL_ONES)
+    for (unsigned int count = 0; count < nwords; count++) {
+        if (bitmap[word] != ALL_ONES)
             break;
 
-        word = (word + 1) % fm->nwords;
+        word = (word + 1) % nwords;
     }
 
-    for (bit = 0; bit < BITS_IN_A_LONG; bit++) {
+    for (unsigned char bit = 0; bit < BITS_IN_A_LONG; bit++) {
         suggestion = ((unsigned long) word << LONG_BIT_SHIFT) | bit;
 
-        if (!file_map_bit_test(fm, suggestion)) {
+        if (!testBit(suggestion)) {
             return suggestion;
         }
     }
 
-    debugs(8, 3, "growing from file_map_allocate");
-    file_map_grow(fm);
-    return file_map_allocate(fm, fm->max_n_files >> 1);
-}
-
-void
-filemapFreeMemory(fileMap * fm)
-{
-    safe_free(fm->file_map);
-    safe_free(fm);
+    grow();
+    return allocate(capacity_ >> 1);
 }
 
-#ifdef TEST
-
-#define TEST_SIZE 1<<16
-main(argc, argv)
+FileMap::~FileMap()
 {
-    int i;
-
-    fm = file_map_create(TEST_SIZE);
-
-    for (i = 0; i < TEST_SIZE; ++i) {
-        file_map_bit_set(i);
-        assert(file_map_bit_test(i));
-        file_map_bit_reset(i);
-    }
+    safe_free(bitmap);
 }
-
-#endif
@@ -981,8 +981,8 @@ CossSwapDir::statfs(StoreEntry & sentry) const
 #if 0
     /* is this applicable? I Hope not .. */
     storeAppendPrintf(sentry, "Filemap bits in use: %d of %d (%d%%)\n",
-                      SD->map->n_files_in_map, SD->map->max_n_files,
-                      Math::intPercent(SD->map->n_files_in_map, SD->map->max_n_files));
+                      SD->map->numFilesInMap(), SD->map->capacity(),
+                      Math::intPercent(SD->map->numFilesInMap(), SD->map->capacity()));
 #endif
 
     //    storeAppendPrintf(&sentry, "Pending operations: %d out of %d\n", io->aq.aq_numpending, MAX_ASYNCOP);
@@ -41,6 +41,7 @@
 #include "ConfigOption.h"
 #include "DiskIO/DiskIOStrategy.h"
 #include "DiskIO/DiskIOModule.h"
+#include "FileMap.h"
 #include "Parsing.h"
 #include "SquidMath.h"
 #include "SquidTime.h"
@@ -247,7 +248,7 @@ UFSSwapDir::create()
     createSwapSubDirs();
 }
 
-UFSSwapDir::UFSSwapDir(char const *aType, const char *anIOType) : SwapDir(aType), IO(NULL), map(file_map_create()), suggest(0), swaplog_fd (-1), currentIOOptions(new ConfigOptionVector()), ioType(xstrdup(anIOType)), cur_size(0), n_disk_objects(0)
+UFSSwapDir::UFSSwapDir(char const *aType, const char *anIOType) : SwapDir(aType), IO(NULL), map(new FileMap()), suggest(0), swaplog_fd (-1), currentIOOptions(new ConfigOptionVector()), ioType(xstrdup(anIOType)), cur_size(0), n_disk_objects(0)
 {
     /* modulename is only set to disk modules that are built, by configure,
      * so the Find call should never return NULL here.
@@ -262,7 +263,7 @@ UFSSwapDir::~UFSSwapDir()
         swaplog_fd = -1;
     }
 
-    filemapFreeMemory(map);
+    delete map;
 
     if (IO)
         delete IO;
@@ -322,8 +323,8 @@ UFSSwapDir::statfs(StoreEntry & sentry) const
     storeAppendPrintf(&sentry, "Percent Used: %0.2f%%\n",
                       Math::doublePercent(currentSize(), maxSize()));
     storeAppendPrintf(&sentry, "Filemap bits in use: %d of %d (%d%%)\n",
-                      map->n_files_in_map, map->max_n_files,
-                      Math::intPercent(map->n_files_in_map, map->max_n_files));
+                      map->numFilesInMap(), map->capacity(),
+                      Math::intPercent(map->numFilesInMap(), map->capacity()));
     x = storeDirGetUFSStats(path, &totl_kb, &free_kb, &totl_in, &free_in);
 
     if (0 == x) {
@@ -451,36 +452,36 @@ UFSSwapDir::openStoreIO(StoreEntry &e, StoreIOState::STFNCB * file_callback, Sto
 int
 UFSSwapDir::mapBitTest(sfileno filn)
 {
-    return file_map_bit_test(map, filn);
+    return map->testBit(filn);
 }
 
 void
 UFSSwapDir::mapBitSet(sfileno filn)
 {
-    file_map_bit_set(map, filn);
+    map->setBit(filn);
 }
 
 void
 UFSSwapDir::mapBitReset(sfileno filn)
 {
     /*
-     * We have to test the bit before calling file_map_bit_reset.
-     * file_map_bit_reset doesn't do bounds checking.  It assumes
+     * We have to test the bit before calling clearBit as
+     * it doesn't do bounds checking and blindly assumes
      * filn is a valid file number, but it might not be because
      * the map is dynamic in size.  Also clearing an already clear
      * bit puts the map counter of-of-whack.
      */
 
-    if (file_map_bit_test(map, filn))
-        file_map_bit_reset(map, filn);
+    if (map->testBit(filn))
+        map->clearBit(filn);
 }
 
 int
 UFSSwapDir::mapBitAllocate()
 {
     int fn;
-    fn = file_map_allocate(map, suggest);
-    file_map_bit_set(map, fn);
+    fn = map->allocate(suggest);
+    map->setBit(fn);
     suggest = fn + 1;
     return fn;
 }
@@ -1264,7 +1265,7 @@ UFSSwapDir::validFileno(sfileno filn, int flag) const
      * be considered invalid.
      */
     if (flag)
-        if (filn > map->max_n_files)
+        if (filn > map->capacity())
             return 0;
 
     return 1;
@@ -40,6 +40,7 @@ class UFSStrategy;
 class ConfigOptionVector;
 class DiskIOModule;
 class StoreSearch;
+class FileMap;
 
 #include "SwapDir.h"
 
@@ -116,7 +117,7 @@ class UFSSwapDir : public SwapDir
     void replacementRemove(StoreEntry *e);
 
 protected:
-    fileMap *map;
+    FileMap *map;
     int suggest;
     int l1;
     int l2;
@@ -195,7 +195,7 @@ StoreMapWithExtras<ExtrasT>::extras(const sfileno fileno) const
 
 } // namespace Ipc
 
-// We do not reuse struct _fileMap because we cannot control its size,
+// We do not reuse FileMap because we cannot control its size,
 // resulting in sfilenos that are pointing beyond the database.
 
 #endif /* SQUID_IPC_STORE_MAP_H */
@@ -144,14 +144,6 @@ SQUIDCEXTERN void fdDumpOpen(void);
 SQUIDCEXTERN int fdUsageHigh(void);
 SQUIDCEXTERN void fdAdjustReserved(void);
 
-SQUIDCEXTERN fileMap *file_map_create(void);
-SQUIDCEXTERN int file_map_allocate(fileMap *, int);
-SQUIDCEXTERN int file_map_bit_set(fileMap *, int);
-SQUIDCEXTERN int file_map_bit_test(fileMap *, int);
-SQUIDCEXTERN void file_map_bit_reset(fileMap *, int);
-SQUIDCEXTERN void filemapFreeMemory(fileMap *);
-
-
 SQUIDCEXTERN void fqdncache_nbgethostbyaddr(const Ip::Address &, FQDNH *, void *);
 
 SQUIDCEXTERN const char *fqdncache_gethostbyaddr(const Ip::Address &, int flags);
@@ -214,9 +206,6 @@ SQUIDCEXTERN mb_size_t httpBuildRequestPrefix(HttpRequest * request,
         StoreEntry * entry,
         MemBuf * mb,
         http_state_flags);
-SQUIDCEXTERN void httpAnonInitModule(void);
-SQUIDCEXTERN int httpAnonHdrAllowed(http_hdr_type hdr_id);
-SQUIDCEXTERN int httpAnonHdrDenied(http_hdr_type hdr_id);
 SQUIDCEXTERN const char *httpMakeVaryMark(HttpRequest * request, HttpReply const * reply);
 
 #include "HttpStatusCode.h"
@@ -88,6 +88,16 @@ Display the binary version details using stderr.
 .
 .SH KNOWN ISSUES
 .PP
+.B SSL errors after changing the CA
+.
+.PP
+Certificates are stored in this database in signed form.
+After any change to the signing CA in squid.conf be sure to erase and re-initialize the certificate database.
+.
+.PP
+.B Certificate chaining
+.
+.PP
 The version 1.0 of this helper will not add chained intermediate CA certificates.
 The client must have a full chain of trust from the root CA all the way
 down to the end certificate generated by this program.
@@ -109,6 +119,10 @@ For example:
 .if !'po4a'hide' .RE
 .
 .PP
+Certificates are stored in this database in signed form.
+After any change to the signing CA in squid.conf be sure to erase and re-initialize the certificate database.
+.
+.PP
 For simple configuration the helper defaults can be used.
 Only HTTP listening port options are required to enable generation and set the signign CA certificate.
 For Example:
@@ -696,22 +696,6 @@ struct _fde_disk {
     off_t offset;
 };
 
-struct _fileMap {
-    int max_n_files;
-    int n_files_in_map;
-    int toggle;
-    int nwords;
-    unsigned long *file_map;
-};
-
-#include "SquidString.h"
-/* http header extention field */
-
-class HttpHdrExtField
-{
-    String name;		/* field-name  from HTTP/1.1 (no column after name) */
-    String value;		/* field-value from HTTP/1.1 */
-};
 
 /* per field statistics */
 
@@ -729,6 +713,7 @@ class HttpHeaderFieldStat
 };
 
 /* compiled version of HttpHeaderFieldAttrs plus stats */
+#include "SquidString.h"
 
 class HttpHeaderFieldInfo
 {
@@ -56,8 +56,6 @@ typedef struct _dread_ctrl dread_ctrl;
 
 typedef struct _dwrite_q dwrite_q;
 
-typedef struct _fileMap fileMap;
-
 typedef struct _HttpHeaderFieldAttrs HttpHeaderFieldAttrs;
 
 typedef struct _domain_ping domain_ping;