@@ -1,12 +1,12 @@
-		    GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 2, June 1991
 
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.
-           59 Temple Place, Suite 330, Boston, MA 02111, USA
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  Everyone is permitted to copy and distribute verbatim copies
  of this license document, but changing it is not allowed.
 
-			    Preamble
+                            Preamble
 
   The licenses for most software are designed to take away your
 freedom to share and change it.  By contrast, the GNU General Public
@@ -15,7 +15,7 @@ software--to make sure the software is free for all its users.  This
 General Public License applies to most of the Free Software
 Foundation's software and to any other program whose authors commit to
 using it.  (Some other Free Software Foundation software is covered by
-the GNU Library General Public License instead.)  You can apply it to
+the GNU Lesser General Public License instead.)  You can apply it to
 your programs, too.
 
   When we speak of free software, we are referring to freedom, not
@@ -55,8 +55,8 @@ patent must be licensed for everyone's free use or not licensed at all.
 
   The precise terms and conditions for copying, distribution and
 modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
+
+                    GNU GENERAL PUBLIC LICENSE
    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
 
   0. This License applies to any program or other work which contains
@@ -110,7 +110,7 @@ above, provided that you also meet all of these conditions:
     License.  (Exception: if the Program itself is interactive but
     does not normally print such an announcement, your work based on
     the Program is not required to print an announcement.)
-
+
 These requirements apply to the modified work as a whole.  If
 identifiable sections of that work are not derived from the Program,
 and can be reasonably considered independent and separate works in
@@ -168,7 +168,7 @@ access to copy from a designated place, then offering equivalent
 access to copy the source code from the same place counts as
 distribution of the source code, even though third parties are not
 compelled to copy the source along with the object code.
-
+
   4. You may not copy, modify, sublicense, or distribute the Program
 except as expressly provided under this License.  Any attempt
 otherwise to copy, modify, sublicense or distribute the Program is
@@ -225,7 +225,7 @@ impose that choice.
 
 This section is intended to make thoroughly clear what is believed to
 be a consequence of the rest of this License.
-
+
   8. If the distribution and/or use of the Program is restricted in
 certain countries either by patents or by copyrighted interfaces, the
 original copyright holder who places the Program under this License
@@ -255,7 +255,7 @@ make exceptions for this.  Our decision will be guided by the two goals
 of preserving the free status of all derivatives of our free software and
 of promoting the sharing and reuse of software generally.
 
-			    NO WARRANTY
+                            NO WARRANTY
 
   11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
 FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
@@ -277,9 +277,9 @@ YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
 PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
 POSSIBILITY OF SUCH DAMAGES.
 
-		     END OF TERMS AND CONDITIONS
-
-	Appendix: How to Apply These Terms to Your New Programs
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
 
   If you develop a new program, and you want it to be of the greatest
 possible use to the public, the best way to achieve this is to make it
@@ -291,7 +291,7 @@ convey the exclusion of warranty; and each file should have at least
 the "copyright" line and a pointer to where the full notice is found.
 
     <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) 19yy  <name of author>
+    Copyright (C) <year>  <name of author>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
@@ -303,16 +303,16 @@ the "copyright" line and a pointer to where the full notice is found.
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 
 Also add information on how to contact you by electronic and paper mail.
 
 If the program is interactive, make it output a short notice like this
 when it starts in an interactive mode:
 
-    Gnomovision version 69, Copyright (C) 19yy name of author
+    Gnomovision version 69, Copyright (C) year name of author
     Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type `show c' for details.
@@ -335,5 +335,5 @@ necessary.  Here is a sample; alter the names:
 This General Public License does not permit incorporating your program into
 proprietary programs.  If your program is a subroutine library, you may
 consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Library General
+library.  If this is what you want to do, use the GNU Lesser General
 Public License instead of this License.
@@ -1006,7 +1006,7 @@ helpers/basic_auth/SSPI/:
     Bill Welliver 1999
 
  * Distributed freely under the terms of the GNU General Public License,
- * version 2. See the file COPYING for licensing details
+ * version 2 or later. See the file COPYING for licensing details
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -1373,7 +1373,7 @@ helpers/ntlm_auth/fake/ntlm_fake_auth.pl.in:
 
 # (C) 2000 Francesco Chemolli <kinkie@kame.usr.dsi.unimi.it>
 # Distributed freely under the terms of the GNU General Public License,
-# version 2. For the licensing terms, see the file COPYING that
+# version 2 or later. For the licensing terms, see the file COPYING that
 # came with Squid.
 
 ==============================================================================
@@ -1382,7 +1382,7 @@ helpers/ntlm_auth/smb_lm/:
 
  * (C) 2000 Francesco Chemolli <kinkie@kame.usr.dsi.unimi.it>
  * Distributed freely under the terms of the GNU General Public License,
- * version 2. See the file COPYING for licensing details
+ * version 2 or later. See the file COPYING for licensing details
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -1799,6 +1799,34 @@ lib/Splay.cc:
  * based on ftp://ftp.cs.cmu.edu/user/sleator/splaying/top-down-splay.c
  * http://bobo.link.cs.cmu.edu/cgi-bin/splay/splay-cgi.pl
 
+==============================================================================
+
+libltdl/:
+
+   Copyright (C) Free Software Foundation, Inc.
+
+GNU Libltdl is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2 of the License, or (at your option) any later version.
+
+As a special exception to the GNU Lesser General Public License,
+if you distribute this file as part of a program or library that
+is built using GNU Libtool, you may include this file under the
+same distribution terms that you use for the rest of that program.
+
+GNU Libltdl is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with GNU Libltdl; see the file COPYING.LIB.  If not, a
+copy can be downloaded from  http://www.gnu.org/licenses/lgpl.html,
+or obtained by writing to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+
+
 ==============================================================================
 
 src/access_log.cc:
@@ -1829,12 +1857,6 @@ src/external_acl.c:
 
 ==============================================================================
 
-src/mk-string-arrays.pl:
-
-# Author:       Max Okumoto <okumoto@ucsd.edu>
-
-==============================================================================
-
 src/repl/heap/store_heap_replacement.cc:
 
  * AUTHOR: John Dilley
@@ -1,3 +1,33 @@
+Changes to squid-3.5.9 (17 Sep 2015):
+
+	- Regression Bug 3618: ntlm_smb_lm_auth rejects correct passwords
+	- Bug 4309: incorrect extensions detection in SSL Hello messages
+	- Bug 4309: crash during Skype login
+	- Bug 4284: missing sanity checks for malloc
+	- Regression Fix: CONNECT request debugging 11,2 traces
+	- Regression Fix: Quieten UFS cache maintenance skipped warnings
+	- TLS: Support SNI on generated CONNECT after peek
+	- ... and some documentation updates
+
+Changes to squid-3.5.8 (02 Sep 2015):
+
+	- Regression Bug 4306: build portability fix in Kerberos helpers
+	- Bug 4302: IPFilter v5 transparent interception
+	- Bug 4301: compile errors with IPFilter interception
+	- Bug 4285 partial: %us is not supported in access.log
+	- Bug 4278: Docs: typo in the refresh_pattern freshness algorithm
+	- Bug 4242: compile errors with eCAP using clang-3.6
+	- Bug 3696: crash when client delay pools are activated
+	- Bug 3553: cache_swap_high ignored and maxCapacity used instead
+	- Regression Fix: FtpServer.cc:1024: "reply != NULL" assertion
+	- Fix ignore of impossible SSL bumping actions, as intended and documented
+	- Fix memory leak in Surrogate-Capability header detection
+	- Fix truncated body length when RESPMOD service aborts
+	- Reject non-chunked HTTP messages with conflicting Content-Length values
+	- Support splice for SSLv3 and TLSv1 sessions that start with an SSLv2 Hello
+	- ... and several portability and compile fixes
+	- ... and several documentation updates
+
 Changes to squid-3.5.7 (01 Aug 2015):
 
 	- Bug 4293: wrong SNI sent to server after URL-rewrite
@@ -27,16 +27,6 @@ dist-hook:
 	    rm -f $(distdir)/$$subdir/autoconf.h; \
 	  fi; \
 	done
-	@if [ -f $(top_srcdir)/RELEASENOTES.html ]; then \
-	  cp -p $(top_srcdir)/RELEASENOTES.html $(distdir)/RELEASENOTES.html; \
-	else \
-	  notes=`ls -1rt $(top_srcdir)/doc/release-notes/*.html | head -1`; \
-	  if [ -f $$notes ]; then \
-	    cp $$notes $(distdir)/RELEASENOTES.html; \
-	  else \
-	    touch $(distdir)/RELEASENOTES.html; \
-	  fi; \
-	fi
 
 EXTRA_DIST = \
 	ChangeLog \
@@ -55,23 +55,51 @@ AC_DEFUN([AX_CXX_TYPE_UNIQUE_PTR],[
 AC_DEFUN([AX_CXX_TYPE_UNIFORM_DISTRIBUTIONS],[
   AC_REQUIRE([AC_PROG_CXX])
   AC_LANG_PUSH([C++])
-  AC_MSG_CHECKING([whether std::uniform_int_distribution<T> is supported])
-  AC_TRY_COMPILE([#include <random>],[std::uniform_int_distribution<int> c;], [
-    HAVE_UNIFORM_INT_DISTRIBUTION=yes
-    AC_MSG_RESULT(yes)], [
-    HAVE_UNIFORM_INT_DISTRIBUTION=no
-    AC_MSG_RESULT(no)])
-  if test "x$HAVE_UNIFORM_INT_DISTRIBUTION" = xno; then
-    AC_DEFINE(uniform_int_distributon, tr1::uniform_int, [Leave undefined if std::uniform_int_distribution<T> is supported])
-  fi
-  AC_MSG_CHECKING([whether std::uniform_real_distribution<T> is supported])
-  AC_TRY_COMPILE([#include <random>],[std::uniform_real_distribution<double> c;], [
-    HAVE_UNIFORM_REAL_DISTRIBUTION=yes
-    AC_MSG_RESULT(yes)], [
-    HAVE_UNIFORM_REAL_DISTRIBUTION=no
-    AC_MSG_RESULT(no)])
-  if test "x$HAVE_UNIFORM_REAL_DISTRIBUTION" = xno; then
-    AC_DEFINE(uniform_real_distributon, tr1::uniform_real, [Leave undefined if std::uniform_real_distribution<T> is supported])
-  fi
+  AC_CHECK_HEADERS(tr1/random)
+  AC_CACHE_CHECK([whether std::uniform_int_distribution<T> is supported],
+                 [squid_cv_std_uniform_int_distribution_works],[
+    AC_TRY_COMPILE([#include <random>],[std::uniform_int_distribution<int> c;],
+      [squid_cv_std_uniform_int_distribution_works=yes],
+      [squid_cv_std_uniform_int_distribution_works=no])
+    ])
+  SQUID_DEFINE_BOOL([HAVE_STD_UNIFORM_INT_DISTRIBUTION],
+      [$squid_cv_std_uniform_int_distribution_works],
+      [Define if c++11 std::uniform_int_distribution is supported])
+
+  AC_CACHE_CHECK([whether std::uniform_real_distribution<T> is supported],
+                 [squid_cv_std_uniform_real_distribution_works],[
+    AC_REQUIRE([AC_PROG_CXX])
+    AC_LANG_PUSH([C++])
+    AC_TRY_COMPILE([#include <random>],[std::uniform_real_distribution<double> c;],
+      [squid_cv_std_uniform_real_distribution_works=yes],
+      [squid_cv_std_uniform_real_distribution_works=no])
+    ])
+  SQUID_DEFINE_BOOL([HAVE_STD_UNIFORM_REAL_DISTRIBUTION],
+      [$squid_cv_std_uniform_real_distribution_works],
+      [Define if c++11 std::uniform_real_distribution is supported])
+
   AC_LANG_POP
 ])
+
+## SQUID_CXX_STD_UNDERLYING_TYPE
+## checks whether the std::underlying_type<enumType>::type trait exists
+AC_DEFUN([SQUID_CXX_STD_UNDERLYING_TYPE],[
+  AC_CACHE_CHECK([whether compiler supports std::underlying_type],
+    [squid_cv_have_std_underlying_type],[
+      AC_REQUIRE([AC_PROG_CXX])
+      AC_LANG_PUSH([C++])
+      AC_COMPILE_IFELSE([
+        AC_LANG_PROGRAM([
+#include <type_traits>
+enum class testEnum { one, two, three };
+        ],[
+        std::underlying_type<testEnum>::type testNum = 0;
+        ])],
+        [squid_cv_have_std_underlying_type=yes],
+        [squid_cv_have_std_underlying_type=no])
+      AC_LANG_POP
+  ])
+  SQUID_DEFINE_BOOL([HAVE_STD_UNDERLYING_TYPE],
+     [$squid_cv_have_std_underlying_type],
+     [Define if stdlibc support std::underlying_type for enums])
+])
@@ -888,6 +888,7 @@ AC_DEFUN([SQUID_CHECK_BROKEN_SOLARIS_IPFILTER],[
   if test "x$squid_cv_broken_ipfilter_minor_t" = "x"; then
     AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
 #     include <sys/types.h>
+#     include <sys/time.h>
 #     include <sys/ioccom.h>
 #     include <netinet/in.h>
 
@@ -902,6 +903,7 @@ AC_DEFUN([SQUID_CHECK_BROKEN_SOLARIS_IPFILTER],[
       AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
 #define minor_t fubaar
 #       include <sys/types.h>
+#       include <sys/time.h>
 #       include <sys/ioccom.h>
 #       include <netinet/in.h>
 #undef minor_t
@@ -912,7 +914,7 @@ AC_DEFUN([SQUID_CHECK_BROKEN_SOLARIS_IPFILTER],[
         AC_MSG_RESULT(yes)
         squid_cv_broken_ipfilter_minor_t=1
       ],[
-        AC_MSG_RESULT(unable to make IPFilter work with netinet/ headers)
+        AC_MSG_ERROR(unable to make IPFilter work with netinet/ headers)
       ])
     ])
   fi
@@ -940,6 +942,9 @@ AC_DEFUN([SQUID_CHECK_BROKEN_SOLARIS_IPFILTER],[
 #if HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
+#if HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
 #if HAVE_NETINET_IN_H
 #include <netinet/in.h>
 #endif
@@ -85,20 +85,6 @@ bootstrap_libtoolize() {
     ltdl="--ltdl"
 
     bootstrap $tool $ltdl --force --copy --automake
-
-    # customize generated libltdl, if any
-    if test -d libltdl
-    then
-        src=libltdl
-
-        # do not bundle with the huge standard license text
-        rm -f $src/COPYING.LIB
-        makefile=$src/Makefile.in
-        sed 's/COPYING.LIB/ /g' $makefile > $makefile.new;
-        chmod u+w $makefile
-        mv $makefile.new $makefile
-        chmod u-w $makefile
-    fi
 }
 
 # On MAC OS X, GNU libtool is named 'glibtool':
@@ -29,6 +29,21 @@
 #define HAVE_RES_INIT  HAVE___RES_INIT
 #endif
 
+/*
+ * Netfilter header madness. (see Bug 4323)
+ *
+ * Netfilter have a history of defining their own versions of network protocol
+ * primitives without sufficient protection against the POSIX defines which are
+ * aways present in Linux.
+ *
+ * netinet/in.h must be included before any other sys header in order to properly
+ * activate include guards in <linux/libc-compat.h> the kernel maintainers added
+ * to workaround it.
+ */
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+
 /*
  * sys/capability.h is only needed in Linux apparently.
  *
@@ -45,6 +45,12 @@
 #include <netinet/in_systm.h>
 #endif
 
+#if __cplusplus && HAVE_TR1_RANDOM
+#if !HAVE_STD_UNIFORM_INT_DISTRIBUTION && !HAVE_STD_UNIFORM_REAL_DISTRIBUTION
+#include <tr1/random>
+#endif
+#endif
+
 /******************************************************/
 /* Typedefs for missing entries on a system           */
 /******************************************************/
@@ -160,5 +166,20 @@ typedef long mtyp_t;
 #define NULL 0
 #endif
 
+/***********************************************************/
+/* uniform_int_distribution backward compatibility wrapper */
+/***********************************************************/
+#if HAVE_STD_UNIFORM_INT_DISTRIBUTION
+#define xuniform_int_distribution std::uniform_int_distribution
+#else
+#define xuniform_int_distribution std::tr1::uniform_int
+#endif
+
+#if HAVE_STD_UNIFORM_REAL_DISTRIBUTION
+#define xuniform_real_distribution std::uniform_real_distribution
+#else
+#define xuniform_real_distribution std::tr1::uniform_real
+#endif
+
 #endif /* SQUID_TYPES_H */
 
@@ -129,6 +129,9 @@ fi
 AR_R="$AR r"
 AC_SUBST(AR_R)
 
+AC_PATH_PROG(LINUXDOC, linuxdoc, $FALSE)
+AM_CONDITIONAL(ENABLE_RELEASE_DOCS, test "x${ac_cv_path_LINUXDOC}" != "x$FALSE")
+
 # pre-define DEFAULT_PREFIX, some modules need it.
 if test "${prefix}" = "NONE" ; then
   squid_prefix=$ac_default_prefix
@@ -293,21 +296,6 @@ case $withval in
 ])
 AC_SUBST(DEFAULT_SWAP_DIR)
 
-if test "$squid_cv_compiler" = "gcc"; then
-  GCCVER=`$CC -v 2>&1 | awk '$2 ==  "version" {print $3}'`
-  GCCVER2=`echo $GCCVER | awk '{print $1 * 100}'`
-  case "$host" in
-    i386-*-freebsd*)
-      if test $GCCVER2 -lt 300 ; then
-        AC_MSG_FAILURE([GCC $GCCVER causes a coredump on $host.
-          Please use a more recent GCC version])
-      fi
-      ;;
-    esac
-  unset GCCVER
-  unset GCCVER2
-fi
-
 dnl Set Default CFLAGS
 if test "x$PRESET_CFLAGS" = "x"; then
   if test "$squid_cv_compiler" = "gcc"; then
@@ -2951,6 +2939,7 @@ dnl Some C++11 types we try to use
 AX_CXX_TYPE_NULLPTR
 AX_CXX_TYPE_UNIQUE_PTR
 AX_CXX_TYPE_UNIFORM_DISTRIBUTIONS
+SQUID_CXX_STD_UNDERLYING_TYPE
 
 dnl On Solaris 9 x86, gcc may includes a "fixed" set of old system include files
 dnl that is incompatible with the updated Solaris header files.
@@ -3264,18 +3253,6 @@ assert(myBar != NULL);
     ;;
   esac
 
-# Remove optimization for GCC 2.95.[123]
-# gcc -O[2] on *BSD and Linux (x86) causes pointers to magically become NULL
-if test "x$GCC" = "xyes"; then
-	GCCVER=`$CC -v 2>&1 | awk '$2 == "version" {print $3}'`
-	case "$GCCVER" in
-	[2.95.[123]])
-		AC_MSG_NOTICE([Removing -O for gcc on $host with GCC $GCCVER])
-		CFLAGS="`echo $CFLAGS | sed -e 's/-O[[0-9]]*//'`"
-		;;
-	esac
-fi
-
 dnl This has to be before AC_CHECK_FUNCS
 # Disable poll() on certain platforms. Override by setting ac_cv_func_poll
 # when running configure.
@@ -3780,6 +3757,7 @@ AC_CONFIG_FILES([
 	contrib/Makefile
 	doc/Makefile
 	doc/manuals/Makefile
+	doc/release-notes/Makefile
 	errors/Makefile
 	helpers/Makefile
 	helpers/basic_auth/Makefile
@@ -5,7 +5,7 @@
 ## Please see the COPYING and CONTRIBUTORS files for details.
 ##
 
-SUBDIRS = manuals
+SUBDIRS = manuals release-notes
 
 DEFAULT_CONFIG_FILE = $(sysconfdir)/squid.conf
 DEFAULT_MIME_TABLE      = $(sysconfdir)/mime.conf
@@ -5,11 +5,12 @@
 ## Please see the COPYING and CONTRIBUTORS files for details.
 ##
 
-all: release-4.html
+# requires the linuxdoc tools
+if ENABLE_RELEASE_DOCS
 
 DOC= release-4
 
-$(DOC).ps: $(DOC).sgml
+%.ps: %.sgml
 	linuxdoc -B latex -o ps $(DOC)
 
 #$(DOC).dvi: $(DOC).tex
@@ -24,11 +25,22 @@ $(DOC).ps: $(DOC).sgml
 %.html: %.sgml
 	linuxdoc -B html -T 2 --split=0 $<
 	perl -i -p -e "s%$@%%" $@
+	cp -p $@ $(top_builddir)/RELEASENOTES.html
 
 %.man: %.sgml
 	linuxdoc -B txt -T 2 -m $(DOC)
 
-clean:
-	rm -f *.html
-	rm -f *.tex *.ps *.dvi *.aux *.log *.toc
-	rm -f *.txt *.man
+dist-hook: $(DOC).html
+	@if test -f $(builddir)/$(DOC).html; then \
+	  cp -p $(builddir)/$(DOC).html $(top_distdir)/RELEASENOTES.html; \
+	fi
+
+EXTRA_DIST= $(DOC).html
+
+CLEANFILES= \
+	*.html \
+	*.tex *.ps *.dvi *.aux *.log *.toc \
+	*.txt *.man \
+	$(top_builddir)/RELEASENOTES.html
+
+endif
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.5.7 release notes</title>
+<title>Squid 3.5.9 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.5.7.
+The Squid Team are pleased to announce the release of Squid-3.5.9.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.5/"> or the
  <url url="http://www.squid-cache.org/Download/http-mirrors.html" name="mirrors">.
@@ -1,376 +0,0 @@
-<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
-<HTML>
-<HEAD>
- <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.69">
- <TITLE>Squid 4.0.0 release notes</TITLE>
-</HEAD>
-<BODY>
-<H1>Squid 4.0.0 release notes</H1>
-
-<H2>Squid Developers</H2>
-<HR>
-<EM>This document contains the release notes for version 4 of Squid.
-Squid is a WWW Cache application developed by the National Laboratory
-for Applied Network Research and members of the Web Caching community.</EM>
-<HR>
-<P>
-<H2><A NAME="toc1">1.</A> <A HREF="#s1">Notice</A></H2>
-
-<UL>
-<LI><A NAME="toc1.1">1.1</A> <A HREF="#ss1.1">Known issues</A>
-<LI><A NAME="toc1.2">1.2</A> <A HREF="#ss1.2">Changes since earlier releases of Squid-4</A>
-</UL>
-<P>
-<H2><A NAME="toc2">2.</A> <A HREF="#s2">Major new features since Squid-3.5</A></H2>
-
-<UL>
-<LI><A NAME="toc2.1">2.1</A> <A HREF="#ss2.1">Configurable helper queue size</A>
-<LI><A NAME="toc2.2">2.2</A> <A HREF="#ss2.2">Helper concurrency channels changes</A>
-<LI><A NAME="toc2.3">2.3</A> <A HREF="#ss2.3">SSLv2 support removal</A>
-<LI><A NAME="toc2.4">2.4</A> <A HREF="#ss2.4">MSNT-multi-domain helper removal</A>
-</UL>
-<P>
-<H2><A NAME="toc3">3.</A> <A HREF="#s3">Changes to squid.conf since Squid-3.5</A></H2>
-
-<UL>
-<LI><A NAME="toc3.1">3.1</A> <A HREF="#ss3.1">New tags</A>
-<LI><A NAME="toc3.2">3.2</A> <A HREF="#ss3.2">Changes to existing tags</A>
-<LI><A NAME="toc3.3">3.3</A> <A HREF="#ss3.3">Removed tags</A>
-</UL>
-<P>
-<H2><A NAME="toc4">4.</A> <A HREF="#s4">Changes to ./configure options since Squid-3.5</A></H2>
-
-<UL>
-<LI><A NAME="toc4.1">4.1</A> <A HREF="#ss4.1">New options</A>
-<LI><A NAME="toc4.2">4.2</A> <A HREF="#ss4.2">Changes to existing options</A>
-<LI><A NAME="toc4.3">4.3</A> <A HREF="#ss4.3">Removed options</A>
-</UL>
-<P>
-<H2><A NAME="toc5">5.</A> <A HREF="#s5">Regressions since Squid-2.7</A></H2>
-
-<UL>
-<LI><A NAME="toc5.1">5.1</A> <A HREF="#ss5.1">Missing squid.conf options available in Squid-2.7</A>
-</UL>
-<P>
-<H2><A NAME="toc6">6.</A> <A HREF="#s6">Copyright</A></H2>
-
-
-<HR>
-<H2><A NAME="s1">1.</A> <A HREF="#toc1">Notice</A></H2>
-
-<P>The Squid Team are pleased to announce the release of Squid-4.0.0 for testing.</P>
-<P>This new release is available for download from 
-<A HREF="http://www.squid-cache.org/Versions/v4/">http://www.squid-cache.org/Versions/v4/</A> or the
-<A HREF="http://www.squid-cache.org/Download/http-mirrors.html">mirrors</A>.</P>
-
-<P>While this release is not deemed ready for production use, we believe it is ready for wider testing by the community.</P>
-
-<P>We welcome feedback and bug reports. If you find a bug, please see 
-<A HREF="http://wiki.squid-cache.org/SquidFaq/BugReporting">http://wiki.squid-cache.org/SquidFaq/BugReporting</A>
-for how to submit a report with a stack trace.</P>
-
-<H2><A NAME="ss1.1">1.1</A> <A HREF="#toc1.1">Known issues</A>
-</H2>
-
-<P>Although this release is deemed good enough for use in many setups, please note the existence of 
-<A HREF="http://bugs.squid-cache.org/buglist.cgi?query_format=advanced&amp;product=Squid&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;version=4">open bugs against Squid-4</A>.</P>
-
-<H2><A NAME="ss1.2">1.2</A> <A HREF="#toc1.2">Changes since earlier releases of Squid-4</A>
-</H2>
-
-<P>The Squid-4 change history can be 
-<A HREF="http://www.squid-cache.org/Versions/v4/changesets/">viewed here</A>.</P>
-
-
-<H2><A NAME="s2">2.</A> <A HREF="#toc2">Major new features since Squid-3.5</A></H2>
-
-<P>Squid 4 represents a new feature release above 3.5.</P>
-
-<P>The most important of these new features are:
-<UL>
-<LI>Helper concurrency channels changes</LI>
-<LI>Configurable helper queue size</LI>
-<LI>SSLv2 support removal</LI>
-<LI>MSNT-multi-domain helper removal</LI>
-</UL>
-</P>
-<P>Most user-facing changes are reflected in squid.conf (see below).</P>
-
-
-<H2><A NAME="ss2.1">2.1</A> <A HREF="#toc2.1">Configurable helper queue size</A>
-</H2>
-
-<P>The new queue-size=N option to helpers configuration, allows users 
-to configure the maximum number of queued requests to busy helpers.</P>
-
-<H2><A NAME="ss2.2">2.2</A> <A HREF="#toc2.2">Helper concurrency channels changes</A>
-</H2>
-
-<P> helper-mux.pl we have been distributing for the past few years to
-encourage use of concurrency is no longer compatible with Squid. If
-used it will spawn up to 2^64 helpers and DoS the Squid server.</P>
-
-<P> Helpers utilizing arrays to handle fixed amounts of concurrency
-channels MUST be re-written to use queues and capable of handling a
-64-bit int as index or they will be vulnerable to buffer overrun and
-arbitrary memory accesses.</P>
-
-<P> 32-bit helpers need re-writing to handle the concurrency channel ID
-as a 64-bit integer value. If not updated they will cause proxies to
-return unexpected results or timeout once crossing the 32-bit wrap
-boundary. Leading to undefined behaviour in the client HTTP traffic.</P>
-
-<H2><A NAME="ss2.3">2.3</A> <A HREF="#toc2.3">SSLv2 support removal</A>
-</H2>
-
-<P>Details in 
-<A HREF="https://tools.ietf.org/html/rfc6176">RFC 6176</A></P>
-
-<P>SSLv2 is not fit for purpose. Squid no longer supports being configured with
-any settings regarding this protocol. That includes settings manually disabling
-its use since it is now forced to disable by default. Also settings enabling
-various client/server workarounds specific to SSLv2 are removed.</P>
-
-
-<H2><A NAME="ss2.4">2.4</A> <A HREF="#toc2.4">MSNT-multi-domain helper removal</A>
-</H2>
-
-<P>The <EM>basic_msnt_multi_domain_auth</EM> helper has been removed. The
-<EM>basic_smb_lm_auth</EM> helper performs the same actions without extra
-Perl and Samba dependencies.</P>
-
-
-<H2><A NAME="s3">3.</A> <A HREF="#toc3">Changes to squid.conf since Squid-3.5</A></H2>
-
-<P>There have been changes to Squid's configuration file since Squid-3.5.</P>
-<P>This section gives a thorough account of those changes in three categories:</P>
-<P>
-<UL>
-<LI>
-<A HREF="#newtags">New tags</A></LI>
-<LI>
-<A HREF="#modifiedtags">Changes to existing tags</A></LI>
-<LI>
-<A HREF="#removedtags">Removed tags</A></LI>
-</UL>
-</P>
-
-
-<H2><A NAME="newtags"></A> <A NAME="ss3.1">3.1</A> <A HREF="#toc3.1">New tags</A>
-</H2>
-
-<P>
-<DL>
-<DT><B>tls_outgoing_options</B><DD>
-<P>New tag to define TLS security context options for outgoing
-connections. For example to HTTPS servers.</P>
-
-<DT><B>url_rewrite_timeout</B><DD>
-<P>Squid times active requests to redirector. This option sets
-the timeout value and the Squid reaction to a timed out
-request.</P>
-
-</DL>
-</P>
-
-<H2><A NAME="modifiedtags"></A> <A NAME="ss3.2">3.2</A> <A HREF="#toc3.2">Changes to existing tags</A>
-</H2>
-
-<P>
-<DL>
-<DT><B>auth_param</B><DD>
-<P>New parameter <EM>queue-size=</EM> to set the maximum number
-of queued requests.</P>
-
-<DT><B>cache_peer</B><DD>
-<P>All <EM>ssloption=</EM> and <EM>sslversion=</EM> values for
-SSLv2 configuration or disabling have been removed.</P>
-<P>Manual squid.conf update may be required on upgrade.</P>
-
-<DT><B>external_acl_type</B><DD>
-<P>New parameter <EM>queue-size=</EM> to set the maximum number
-of queued requests.</P>
-
-<DT><B>http_port</B><DD>
-<P>All <EM>version=</EM> <EM>option=</EM> values for SSLv2
-configuration or disabling have been removed.</P>
-<P>Manual squid.conf update may be required on upgrade.</P>
-
-<DT><B>https_port</B><DD>
-<P>All <EM>version=</EM> <EM>option=</EM> values for SSLv2
-configuration or disabling have been removed.</P>
-<P>Manual squid.conf update may be required on upgrade.</P>
-
-<DT><B>sslcrtd_children</B><DD>
-<P>New parameter <EM>queue-size=</EM> to set the maximum number
-of queued requests.</P>
-
-<DT><B>sslcrtvalidator_children</B><DD>
-<P>New parameter <EM>queue-size=</EM> to set the maximum number
-of queued requests.</P>
-
-<DT><B>sslproxy_options</B><DD>
-<P>All values for SSLv2 configuration or disabling have been removed.</P>
-<P>Manual squid.conf update may be required on upgrade.</P>
-
-<DT><B>sslproxy_version</B><DD>
-<P>Value '2' for SSLv2-only operation is no longer supported.</P>
-
-<DT><B>url_rewrite_children</B><DD>
-<P>New parameter <EM>queue-size=</EM> to set the maximum number
-of queued requests.</P>
-
-</DL>
-</P>
-
-<H2><A NAME="removedtags"></A> <A NAME="ss3.3">3.3</A> <A HREF="#toc3.3">Removed tags</A>
-</H2>
-
-<P>
-<DL>
-<DT><B>cache_peer_domain</B><DD>
-<P>Superceded by <EM>cache_peer_access</EM>. Use dstdomain ACL
-in the access control list to restrict domains requested.</P>
-
-<DT><B>refresh_pattern</B><DD>
-<P>Option <EM>ignore-auth</EM> removed. Its original intent was
-to improve caching. HTTP/1.1 permits caching of authenticated
-messages under conditions which Squid does check for and obey.</P>
-
-<DT><B>sslproxy_cafile</B><DD>
-<P>Replaced by <EM>tls_outgoing_options cafile=</EM>.</P>
-
-<DT><B>sslproxy_capath</B><DD>
-<P>Replaced by <EM>tls_outgoing_options capath=</EM>.</P>
-
-<DT><B>sslproxy_cipher</B><DD>
-<P>Replaced by <EM>tls_outgoing_options cipher=</EM>.</P>
-
-<DT><B>sslproxy_client_certificate</B><DD>
-<P>Replaced by <EM>tls_outgoing_options cert=</EM>.</P>
-
-<DT><B>sslproxy_client_key</B><DD>
-<P>Replaced by <EM>tls_outgoing_options key=</EM>.</P>
-
-<DT><B>sslproxy_flags</B><DD>
-<P>Replaced by <EM>tls_outgoing_options flags=</EM>.</P>
-
-<DT><B>sslproxy_options</B><DD>
-<P>Replaced by <EM>tls_outgoing_options options=</EM>.</P>
-
-<DT><B>sslproxy_version</B><DD>
-<P>Replaced by <EM>tls_outgoing_options version=</EM>.</P>
-
-</DL>
-</P>
-
-
-<H2><A NAME="s4">4.</A> <A HREF="#toc4">Changes to ./configure options since Squid-3.5</A></H2>
-
-<P>There have been some changes to Squid's build configuration since Squid-3.5.</P>
-<P>This section gives an account of those changes in three categories:</P>
-<P>
-<UL>
-<LI>
-<A HREF="#newoptions">New options</A></LI>
-<LI>
-<A HREF="#modifiedoptions">Changes to existing options</A></LI>
-<LI>
-<A HREF="#removedoptions">Removed options</A></LI>
-</UL>
-</P>
-
-
-<H2><A NAME="newoptions"></A> <A NAME="ss4.1">4.1</A> <A HREF="#toc4.1">New options</A>
-</H2>
-
-<P>
-<DL>
-
-</DL>
-</P>
-
-<H2><A NAME="modifiedoptions"></A> <A NAME="ss4.2">4.2</A> <A HREF="#toc4.2">Changes to existing options</A>
-</H2>
-
-<P>
-<DL>
-<DT><B>--enable-auth-basic</B><DD>
-<P>The <EM>MSNT-multi-domain</EM> helper has been removed.</P>
-
-</DL>
-</P>
-<H2><A NAME="removedoptions"></A> <A NAME="ss4.3">4.3</A> <A HREF="#toc4.3">Removed options</A>
-</H2>
-
-<P>
-<DL>
-
-</DL>
-</P>
-
-
-<H2><A NAME="s5">5.</A> <A HREF="#toc5">Regressions since Squid-2.7</A></H2>
-
-<P>Some squid.conf options which were available in Squid-2.7 are not yet available in Squid-4</P>
-
-<P>If you need something to do then porting one of these from Squid-2 to Squid-3 is most welcome.</P>
-
-<H2><A NAME="ss5.1">5.1</A> <A HREF="#toc5.1">Missing squid.conf options available in Squid-2.7</A>
-</H2>
-
-<P>
-<DL>
-<DT><B>broken_vary_encoding</B><DD>
-<P>Not yet ported from 2.6</P>
-
-<DT><B>cache_peer</B><DD>
-<P><EM>monitorinterval=</EM> not yet ported from 2.6</P>
-<P><EM>monitorsize=</EM> not yet ported from 2.6</P>
-<P><EM>monitortimeout=</EM> not yet ported from 2.6</P>
-<P><EM>monitorurl=</EM> not yet ported from 2.6</P>
-
-<DT><B>cache_vary</B><DD>
-<P>Not yet ported from 2.6</P>
-
-<DT><B>error_map</B><DD>
-<P>Not yet ported from 2.6</P>
-
-<DT><B>external_refresh_check</B><DD>
-<P>Not yet ported from 2.7</P>
-
-<DT><B>location_rewrite_access</B><DD>
-<P>Not yet ported from 2.6</P>
-
-<DT><B>location_rewrite_children</B><DD>
-<P>Not yet ported from 2.6</P>
-
-<DT><B>location_rewrite_concurrency</B><DD>
-<P>Not yet ported from 2.6</P>
-
-<DT><B>location_rewrite_program</B><DD>
-<P>Not yet ported from 2.6</P>
-
-<DT><B>refresh_pattern</B><DD>
-<P><EM>stale-while-revalidate=</EM> not yet ported from 2.7</P>
-<P><EM>ignore-stale-while-revalidate=</EM> not yet ported from 2.7</P>
-<P><EM>negative-ttl=</EM> not yet ported from 2.7</P>
-
-<DT><B>refresh_stale_hit</B><DD>
-<P>Not yet ported from 2.7</P>
-
-<DT><B>update_headers</B><DD>
-<P>Not yet ported from 2.7</P>
-
-</DL>
-</P>
-
-<H2><A NAME="s6">6.</A> <A HREF="#toc6">Copyright</A></H2>
-
-<P>Copyright (C) 1996-2015 The Squid Software Foundation and contributors</P>
-<P>Squid software is distributed under GPLv2+ license and includes
-contributions from numerous individuals and organizations.
-Please see the COPYING and CONTRIBUTORS files for details.</P>
-
-</BODY>
-</HTML>
@@ -12,8 +12,7 @@ for Applied Network Research and members of the Web Caching community.
 <toc>
 
 <sect>Notice
-<p>
-The Squid Team are pleased to announce the release of Squid-4.0.0 for testing.
+<p>The Squid Team are pleased to announce the release of Squid-4.0.0 for testing.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v4/"> or the
  <url url="http://www.squid-cache.org/Download/http-mirrors.html" name="mirrors">.
@@ -24,10 +23,14 @@ This new release is available for download from <url url="http://www.squid-cache
    for how to submit a report with a stack trace.
 
 <sect1>Known issues
-<p>
-Although this release is deemed good enough for use in many setups, please note the existence of 
+<p>Although this release is deemed good enough for use in many setups, please note the existence of 
 <url url="http://bugs.squid-cache.org/buglist.cgi?query_format=advanced&amp;product=Squid&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;version=4" name="open bugs against Squid-4">.
 
+<p>This release addsa dependency on C++11 support in any cmpiler used to build Squid.
+  As a result older C++03 -only and most C++0x compilers will no longer build successfully.
+  GCC 4.9+ and Clang 3.5+ are known to have working C++11 support and are usable.
+  GCC-4.8 will also build for now despite lack of full C++11 support, but some future features may not be available.
+
 <sect1>Changes since earlier releases of Squid-4
 <p>
 The Squid-4 change history can be <url url="http://www.squid-cache.org/Versions/v4/changesets/" name="viewed here">.
@@ -42,52 +45,95 @@ The Squid-4 change history can be <url url="http://www.squid-cache.org/Versions/
 	<item>Configurable helper queue size
 	<item>SSL support removal
 	<item>MSNT-multi-domain helper removal
+	<item>Secure ICAP
+	<item>Elliptic Curve Diffie-Hellman (ECDH)
+	<item>Improved SMP support
 </itemize>
 
 Most user-facing changes are reflected in squid.conf (see below).
 
 
 <sect1>Configurable helper queue size
 <p>The new queue-size=N option to helpers configuration, allows users 
-to configure the maximum number of queued requests to busy helpers.
+   to configure the maximum number of queued requests to busy helpers.
 
 <sect1>Helper concurrency channels changes
-<p> helper-mux.pl we have been distributing for the past few years to
-    encourage use of concurrency is no longer compatible with Squid. If
-    used it will spawn up to 2^64 helpers and DoS the Squid server.
+<p>helper-mux.pl we have been distributing for the past few years to
+   encourage use of concurrency is no longer compatible with Squid. If
+   used it will spawn up to 2^64 helpers and DoS the Squid server.
+
+<p>Helpers utilizing arrays to handle fixed amounts of concurrency
+   channels MUST be re-written to use queues and capable of handling a
+   64-bit int as index or they will be vulnerable to buffer overrun and
+   arbitrary memory accesses.
 
-<p> Helpers utilizing arrays to handle fixed amounts of concurrency
-    channels MUST be re-written to use queues and capable of handling a
-    64-bit int as index or they will be vulnerable to buffer overrun and
-    arbitrary memory accesses.
+<p>32-bit helpers need re-writing to handle the concurrency channel ID
+   as a 64-bit integer value. If not updated they will cause proxies to
+   return unexpected results or timeout once crossing the 32-bit wrap
+   boundary. Leading to undefined behaviour in the client HTTP traffic.
 
-<p> 32-bit helpers need re-writing to handle the concurrency channel ID
-    as a 64-bit integer value. If not updated they will cause proxies to
-    return unexpected results or timeout once crossing the 32-bit wrap
-    boundary. Leading to undefined behaviour in the client HTTP traffic.
 
 <sect1>SSL support removal
 <p>Details in <url url="https://tools.ietf.org/html/rfc6176" name="RFC 6176">
    and <url url="https://tools.ietf.org/html/rfc7568" name="RFC 7568">
 
 <p>SSLv2 is not fit for purpose. Squid no longer supports being configured with
-any settings regarding this protocol. That includes settings manually disabling
-its use since it is now forced to disable by default. Also settings enabling
-various client/server workarounds specific to SSLv2 are removed.
+   any settings regarding this protocol. That includes settings manually disabling
+   its use since it is now forced to disable by default. Also settings enabling
+   various client/server workarounds specific to SSLv2 are removed.
 
 <p>SSLv3 is not fit for purpose. Squid still accepts configuration, but use
-is deprecated and will be removed entirely in a future version.
-Squid default behavour is to follow the TLS built in negotiation mechanism
-which prefers the latest TLS version.
+   is deprecated and will be removed entirely in a future version.
+   Squid default behavour is to follow the TLS built in negotiation mechanism
+   which prefers the latest TLS version. But also to accept downgrades to SSLv3.
+   Use <em>tls-options=NO_SSLv3</em> to disable SSLv3 support completely.
 
+<p>A new option <em>tls-min-version=1.N</em> is added in place of <em>sslversion=</em>
+   to configure the minimum version the TLS negotiation will allow to be used
+   when an old TLS version is requested by the remote endpoint.
 
-<sect1>MSNT-multi-domain helper removal
 
+<sect1>MSNT-multi-domain helper removal
 <p>The <em>basic_msnt_multi_domain_auth</em> helper has been removed. The
    <em>basic_smb_lm_auth</em> helper performs the same actions without extra
    Perl and Samba dependencies.
 
 
+<sect1>Secure ICAP
+<p>ICAP services can now be used over TLS connections.
+
+<p>To mark an ICAP service as secure, use an <em>icaps://</em> service URI scheme when
+   listing your service via an icap_service directive. The industry is using a
+   <em>Secure ICAP</em> term, and Squid follows that convention, but <em>icaps</em> seems more
+   appropriate for a <em>scheme</em> name.
+
+<p>Squid uses <em>port 11344</em> for Secure ICAP by default, following another popular
+   proxy convention. The old 1344 default for plain ICAP ports has not changed.
+
+
+<sect1>Elliptic Curve Diffie-Hellman (ECDH)
+<p>All listening port which supported Diffie-Hellman key exchange are now updated
+   to support Elliptic Curve configuration which allows for forward secrecy with
+   better performance than traditional ephemeral Diffie-Hellman.
+
+<p>The http(s)_port <em>dhparams=</em> option is replaced with <em>tls-dh=</em> that
+   takes an optional curve name as well as filename for curve parameters. The new
+   option configured without a curve name uses the traditional ephemeral DH.
+
+<p>A new <em>options=SINGLE_ECDH_USE</em> parameter is added to enable ephemeral
+   key exchanges for Elliptic Curve DH.
+
+
+<sect1>Improved SMP support
+<p>Use of C++11 atomic operations instead of GNU atomics allows a wider range of
+   operating systems and compilers to build Squid SMP and multi-process features.
+   However this does require a C++11 or C++0x compiler with a recent version of
+   the C++ standard library.
+
+<p>IpcIo and Mmapped disk I/O modules are now auto-detected properly which
+   enables Rock storage on more systems by default than previously.
+
+
 <sect>Changes to squid.conf since Squid-3.5
 <p>
 There have been changes to Squid's configuration file since Squid-3.5.
@@ -138,6 +184,12 @@ This section gives a thorough account of those changes in three categories:
 	<p>All <em>option=</em> values for SSLv2 configuration or disabling
 	   have been removed.
 	<p>Removed <em>version=</em> option. Use <em>tls-options=</em> instead.
+	<p>New <em>options=SINGLE_ECDH_USE</em> parameter to enable ephemeral
+	   ECDH key exchange.
+	<p>Deprecated <em>dhparams=</em> option. Use <em>tls-dh=</em> instead.
+	   The new option allows to optionally specify an elliptic curve for
+	   ephemeral ECDH by adding <em>curve-name:</em> in front of the
+	   parameter file name.
 	<p>Manual squid.conf update may be required on upgrade.
 
 	<tag>https_port</tag>
@@ -153,6 +205,23 @@ This section gives a thorough account of those changes in three categories:
 	   parameter file name.
 	<p>Manual squid.conf update may be required on upgrade.
 
+	<tag>icap_service</tag>
+	<p>New scheme <em>icaps://</em> to enable TLS/SSL connections to Secure ICAP
+	   servers on port 11344.
+	<p>New <em>tls-cert=</em> option to set TLS client certificate to use.
+	<p>New <em>tls-key=</em> option to set TLS private key matching the client
+	   certificate used.
+	<p>New <em>tls-min-version=1.N</em> option to set minimum TLS version allowed
+	   on server connections.
+	<p>New <em>tls-options=</em> option to set OpenSSL library parameters.
+	<p>New <em>tls-flags=</em> option to set flags modifying Squid TLS operations.
+	<p>New <em>tls-cipher=</em> option to set a list of ciphers permitted.
+	<p>New <em>tls-cafile=</em> option to set a file with additional CA
+	   certificate(s) to verify the server certificate.
+	<p>New <em>tls-crlfile=</em> option to set a file with a CRL to verify the
+	   server certificate.
+	<p>New <em>tls-domain=</em> option to verify the server certificate domain.
+
 	<tag>refresh_pattern</tag>
 	<p>Removed <em>ignore-auth</em>. Its commonly desired behaviour is
 	   performed by default with correct HTTP/1.1 revalidation.
@@ -241,6 +310,11 @@ This section gives an account of those changes in three categories:
 	<tag>--enable-auth-basic</tag>
 	<p>The <em>MSNT-multi-domain</em> helper has been removed.
 
+	<tag>--enable-diskio</tag>
+	<p>Auto-detection of SMP related modules has been fixed to
+	   actually auto-detect them without configuring the module
+	   list manually.
+
 </descrip>
 </p>
 
@@ -392,7 +392,7 @@ main(int argc, char **argv)
         case 'h':
             if (ldapServer) {
                 int len = strlen(ldapServer) + 1 + strlen(value) + 1;
-                char *newhost = static_cast<char*>(malloc(len));
+                char *newhost = static_cast<char*>(xmalloc(len));
                 snprintf(newhost, len, "%s %s", ldapServer, value);
                 free(ldapServer);
                 ldapServer = newhost;
@@ -512,7 +512,7 @@ main(int argc, char **argv)
         char *value = argv[1];
         if (ldapServer) {
             int len = strlen(ldapServer) + 1 + strlen(value) + 1;
-            char *newhost = static_cast<char*>(malloc(len));
+            char *newhost = static_cast<char*>(xmalloc(len));
             snprintf(newhost, len, "%s %s", ldapServer, value);
             free(ldapServer);
             ldapServer = newhost;
@@ -207,7 +207,7 @@ static void
 random_vector(char *aVector)
 {
     static std::mt19937 mt(time(0));
-    static std::uniform_int_distribution<uint8_t> dist;
+    static xuniform_int_distribution<uint8_t> dist;
 
     for (int i = 0; i < AUTH_VECTOR_LEN; ++i)
         aVector[i] = static_cast<char>(dist(mt) & 0xFF);
@@ -111,8 +111,7 @@ main(int argc, char *argv[])
             break;
 
         if (strcmp(argv[i], "-W") == 0) {
-            if ((dom = (struct SMBDOMAIN *) malloc(sizeof(struct SMBDOMAIN))) == NULL)
-                return 1;
+            dom = static_cast<struct SMBDOMAIN *>(xmalloc(sizeof(struct SMBDOMAIN)));
 
             dom->name = dom->sname = argv[++i];
             dom->passthrough = "";
@@ -20,7 +20,7 @@
     Bill Welliver 1999
 
  * Distributed freely under the terms of the GNU General Public License,
- * version 2. See the file COPYING for licensing details
+ * version 2 or later. See the file COPYING for licensing details
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -22,7 +22,7 @@
     Bill Welliver 1999
 
  * Distributed freely under the terms of the GNU General Public License,
- * version 2. See the file COPYING for licensing details
+ * version 2 or later. See the file COPYING for licensing details
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -21,7 +21,7 @@
     Bill Welliver 1999
 
  * Distributed freely under the terms of the GNU General Public License,
- * version 2. See the file COPYING for licensing details
+ * version 2 or later. See the file COPYING for licensing details
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -434,7 +434,7 @@ LDAPArguments(int argc, char **argv)
         case 'h':
             if (ldapServer) {
                 int len = strlen(ldapServer) + 1 + strlen(value) + 1;
-                char *newhost = (char*)malloc(len);
+                char *newhost = static_cast<char*>(xmalloc(len));
                 snprintf(newhost, len, "%s %s", ldapServer, value);
                 free(ldapServer);
                 ldapServer = newhost;
@@ -560,7 +560,7 @@ LDAPArguments(int argc, char **argv)
         char *value = argv[1];
         if (ldapServer) {
             int len = strlen(ldapServer) + 1 + strlen(value) + 1;
-            char *newhost = (char*)malloc(len);
+            char *newhost = static_cast<char*>(xmalloc(len));
             snprintf(newhost, len, "%s %s", ldapServer, value);
             free(ldapServer);
             ldapServer = newhost;
@@ -461,7 +461,7 @@ LDAPArguments(int argc, char **argv)
         case 'h':
             if (ldapServer) {
                 int len = strlen(ldapServer) + 1 + strlen(value) + 1;
-                char *newhost = (char*)malloc(len);
+                char *newhost = static_cast<char*>(xmalloc(len));
                 snprintf(newhost, len, "%s %s", ldapServer, value);
                 free(ldapServer);
                 ldapServer = newhost;
@@ -590,7 +590,7 @@ LDAPArguments(int argc, char **argv)
         char *value = argv[1];
         if (ldapServer) {
             int len = strlen(ldapServer) + 1 + strlen(value) + 1;
-            char *newhost = (char*)malloc(len);
+            char *newhost = static_cast<char*>(xmalloc(len));
             snprintf(newhost, len, "%s %s", ldapServer, value);
             free(ldapServer);
             ldapServer = newhost;
@@ -118,7 +118,7 @@ read_passwd_file(const char *passwordFile, int isHa1Mode)
             u = static_cast<user_data*>(xcalloc(1, sizeof(*u)));
             if (realm) {
                 int len = strlen(user) + strlen(realm) + 2;
-                u->hash.key = malloc(len);
+                u->hash.key = xmalloc(len);
                 snprintf(static_cast<char*>(u->hash.key), len, "%s:%s", user, realm);
             } else {
                 u->hash.key = xstrdup(user);
@@ -261,7 +261,7 @@ main(int argc, char **argv)
         case 'h':
             if (ldapServer) {
                 int len = strlen(ldapServer) + 1 + strlen(value) + 1;
-                char *newhost = (char*)malloc(len);
+                char *newhost = static_cast<char*>(xmalloc(len));
                 snprintf(newhost, len, "%s %s", ldapServer, value);
                 free(ldapServer);
                 ldapServer = newhost;
@@ -390,7 +390,7 @@ main(int argc, char **argv)
         char *value = argv[1];
         if (ldapServer) {
             int len = strlen(ldapServer) + 1 + strlen(value) + 1;
-            char *newhost = (char*)malloc(len);
+            char *newhost = static_cast<char*>(xmalloc(len));
             snprintf(newhost, len, "%s %s", ldapServer, value);
             free(ldapServer);
             ldapServer = newhost;
@@ -80,7 +80,7 @@ load_dict(FILE * FH) {
                    bitwise AND */
 
     /* the pointer to the first entry in the linked list */
-    first_entry = (struct ip_user_dict*)malloc(sizeof(struct ip_user_dict));
+    first_entry = static_cast<struct ip_user_dict*>(xmalloc(sizeof(struct ip_user_dict)));
     current_entry = first_entry;
 
     unsigned int lineCount = 0;
@@ -128,7 +128,7 @@ load_dict(FILE * FH) {
 
             /* get space and point current_entry to the new entry */
             current_entry->next_entry =
-                (struct ip_user_dict*)malloc(sizeof(struct ip_user_dict));
+                static_cast<struct ip_user_dict*>(xmalloc(sizeof(struct ip_user_dict)));
             current_entry = current_entry->next_entry;
         }
 
@@ -5,7 +5,7 @@
 ## Please see the COPYING and CONTRIBUTORS files for details.
 ##
 
-if test "x$with_krb5" == "xyes"; then
+if test "x$with_krb5" = "xyes"; then
   BUILD_HELPER="kerberos_ldap_group"
   if test "x$with_apple_krb5" = "xyes" ; then
     AC_CHECK_LIB(resolv, [main], [XTRA_LIBS="$XTRA_LIBS -lresolv"],[
@@ -237,10 +237,11 @@ getdomaingids(char *ad_groups, uint32_t DomainLogonId, char **Rids, uint32_t Gro
             }
             struct base64_encode_ctx ctx;
             base64_encode_init(&ctx);
-            uint8_t *b64buf = (uint8_t *)xcalloc(base64_encode_len(length+4)*sizeof(uint8_t),1);
+            const uint32_t expectedSz = base64_encode_len(length+4) +1 /* terminator */;
+            uint8_t *b64buf = (uint8_t *)xcalloc(expectedSz, 1);
             size_t blen = base64_encode_update(&ctx, b64buf, length+4, reinterpret_cast<uint8_t*>(ag));
             blen += base64_encode_final(&ctx, b64buf+blen);
-            b64buf[sizeof(*b64buf)-1] = '\0';
+            b64buf[expectedSz-1] = '\0';
             if (!pstrcat(ad_groups, reinterpret_cast<char*>(b64buf))) {
                 debug((char *) "%s| %s: WARN: Too many groups ! size > %d : %s\n",
                       LogTime(), PROGRAM, MAX_PAC_GROUP_SIZE, ad_groups);
@@ -318,10 +319,11 @@ getextrasids(char *ad_groups, uint32_t ExtraSids, uint32_t SidCount)
 
                 struct base64_encode_ctx ctx;
                 base64_encode_init(&ctx);
-                uint8_t *b64buf = (uint8_t *)xcalloc(base64_encode_len(length)*sizeof(uint8_t),1);
+                const uint32_t expectedSz = base64_encode_len(length) +1 /* terminator */;
+                uint8_t *b64buf = (uint8_t *)xcalloc(expectedSz, 1);
                 size_t blen = base64_encode_update(&ctx, b64buf, length, reinterpret_cast<uint8_t*>(ag));
                 blen += base64_encode_final(&ctx, b64buf+blen);
-                b64buf[sizeof(*b64buf)-1] = '\0';
+                b64buf[expectedSz-1] = '\0';
                 if (!pstrcat(ad_groups, reinterpret_cast<char*>(b64buf))) {
                     debug((char *) "%s| %s: WARN: Too many groups ! size > %d : %s\n",
                           LogTime(), PROGRAM, MAX_PAC_GROUP_SIZE, ad_groups);
@@ -5,6 +5,6 @@
 ## Please see the COPYING and CONTRIBUTORS files for details.
 ##
 
-if test "x$with_krb5" == "xyes"; then
+if test "x$with_krb5" = "xyes"; then
   BUILD_HELPER="kerberos"
 fi
@@ -92,22 +92,185 @@ void usage(void)
     fprintf(stderr, "--kerberos full kerberos helper path with arguments\n");
 }
 
-int
-main(int argc, char *const argv[])
+static void
+closeFds(FILE *a, FILE *b, FILE *c, FILE *d)
+{
+    if (a >= 0)
+        fclose(a);
+    if (b >= 0)
+        fclose(b);
+    if (c >= 0)
+        fclose(c);
+    if (d >= 0)
+        fclose(d);
+}
+
+static int
+processingLoop(FILE *FDKIN, FILE *FDKOUT, FILE *FDNIN, FILE *FDNOUT)
 {
     char buf[MAX_AUTHTOKEN_LEN];
     char tbuff[MAX_AUTHTOKEN_LEN];
     char buff[MAX_AUTHTOKEN_LEN+2];
     char *c;
-    int debug = 0;
     int length;
+    uint8_t *token = NULL;
+
+    while (1) {
+        if (fgets(buf, sizeof(buf) - 1, stdin) == NULL) {
+            xfree(token);
+            if (ferror(stdin)) {
+                if (debug_enabled)
+                    fprintf(stderr,
+                            "%s| %s: fgets() failed! dying..... errno=%d (%s)\n",
+                            LogTime(), PROGRAM, ferror(stdin),
+                            strerror(ferror(stdin)));
+
+                fprintf(stdout, "BH input error\n");
+                return 1;        /* BIIG buffer */
+            }
+            fprintf(stdout, "BH input error\n");
+            return 0;
+        }
+        c = static_cast<char*>(memchr(buf, '\n', sizeof(buf) - 1));
+        if (c) {
+            *c = '\0';
+            length = c - buf;
+            if (debug_enabled)
+                fprintf(stderr, "%s| %s: Got '%s' from squid (length: %d).\n",
+                        LogTime(), PROGRAM, buf, length);
+        } else {
+            if (debug_enabled)
+                fprintf(stderr, "%s| %s: Oversized message\n", LogTime(),
+                        PROGRAM);
+            fprintf(stdout, "BH Oversized message\n");
+            continue;
+        }
+
+        if (buf[0] == '\0') {
+            if (debug_enabled)
+                fprintf(stderr, "%s| %s: Invalid request\n", LogTime(),
+                        PROGRAM);
+            fprintf(stdout, "BH Invalid request\n");
+            continue;
+        }
+        if (strlen(buf) < 2) {
+            if (debug_enabled)
+                fprintf(stderr, "%s| %s: Invalid request [%s]\n", LogTime(),
+                        PROGRAM, buf);
+            fprintf(stdout, "BH Invalid request\n");
+            continue;
+        }
+        if (!strncmp(buf, "QQ", 2)) {
+            fprintf(stdout, "BH quit command\n");
+            return 0;
+        }
+        if (strncmp(buf, "YR", 2) && strncmp(buf, "KK", 2)) {
+            if (debug_enabled)
+                fprintf(stderr, "%s| %s: Invalid request [%s]\n", LogTime(),
+                        PROGRAM, buf);
+            fprintf(stdout, "BH Invalid request\n");
+            continue;
+        }
+        if (strlen(buf) <= 3) {
+            if (debug_enabled)
+                fprintf(stderr, "%s| %s: Invalid negotiate request [%s]\n",
+                        LogTime(), PROGRAM, buf);
+            fprintf(stdout, "BH Invalid negotiate request\n");
+            continue;
+        }
+        length = BASE64_DECODE_LENGTH(strlen(buf+3));
+        if (debug_enabled)
+            fprintf(stderr, "%s| %s: Decode '%s' (decoded length: %d).\n",
+                    LogTime(), PROGRAM, buf + 3, (int) length);
+
+        safe_free(token);
+        if (!(token = static_cast<uint8_t *>(xmalloc(length)))) {
+            fprintf(stderr, "%s| %s: Error allocating memory for token\n", LogTime(), PROGRAM);
+            return 1;
+        }
+
+        struct base64_decode_ctx ctx;
+        base64_decode_init(&ctx);
+        size_t dstLen = 0;
+        if (!base64_decode_update(&ctx, &dstLen, token, strlen(buf+3), reinterpret_cast<const uint8_t*>(buf+3)) ||
+                !base64_decode_final(&ctx)) {
+            if (debug_enabled)
+                fprintf(stderr, "%s| %s: Invalid base64 token [%s]\n", LogTime(), PROGRAM, buf+3);
+            fprintf(stdout, "BH Invalid negotiate request token\n");
+            continue;
+        }
+        length = dstLen;
+        token[dstLen] = '\0';
+
+        if ((static_cast<size_t>(length) >= sizeof(ntlmProtocol) + 1) &&
+                (!memcmp(token, ntlmProtocol, sizeof ntlmProtocol))) {
+            if (debug_enabled)
+                fprintf(stderr, "%s| %s: received type %d NTLM token\n",
+                        LogTime(), PROGRAM, (int) *((unsigned char *) token +
+                                                    sizeof ntlmProtocol));
+            fprintf(FDNIN, "%s\n",buf);
+            if (fgets(tbuff, sizeof(tbuff) - 1, FDNOUT) == NULL) {
+                xfree(token);
+                if (ferror(FDNOUT)) {
+                    fprintf(stderr,
+                            "fgets() failed! dying..... errno=%d (%s)\n",
+                            ferror(FDNOUT), strerror(ferror(FDNOUT)));
+                    return 1;
+                }
+                fprintf(stderr, "%s| %s: Error reading NTLM helper response\n",
+                        LogTime(), PROGRAM);
+                return 0;
+            }
+            /*
+             * Need to translate NTLM reply to Negotiate reply:
+             *  AF user => AF blob user
+             *  NA reason => NA blob reason
+             *  Set blob to '='
+             */
+            if (strlen(tbuff) >= 3 && (!strncmp(tbuff,"AF ",3) || !strncmp(tbuff,"NA ",3))) {
+                strncpy(buff,tbuff,3);
+                buff[3]='=';
+                for (unsigned int i=2; i<=strlen(tbuff); ++i)
+                    buff[i+2] = tbuff[i];
+            } else {
+                strcpy(buff,tbuff);
+            }
+        } else {
+            if (debug_enabled)
+                fprintf(stderr, "%s| %s: received Kerberos token\n",
+                        LogTime(), PROGRAM);
+
+            fprintf(FDKIN, "%s\n",buf);
+            if (fgets(buff, sizeof(buff) - 1, FDKOUT) == NULL) {
+                xfree(token);
+                if (ferror(FDKOUT)) {
+                    fprintf(stderr,
+                            "fgets() failed! dying..... errno=%d (%s)\n",
+                            ferror(FDKOUT), strerror(ferror(FDKOUT)));
+                    return 1;
+                }
+                fprintf(stderr, "%s| %s: Error reading Kerberos helper response\n",
+                        LogTime(), PROGRAM);
+                return 0;
+            }
+        }
+        fprintf(stdout,"%s",buff);
+        if (debug_enabled)
+            fprintf(stderr, "%s| %s: Return '%s'\n",
+                    LogTime(), PROGRAM, buff);
+    }
+
+    xfree(token);
+    return 1;
+}
+
+int
+main(int argc, char *const argv[])
+{
     int nstart = 0, kstart = 0;
     int nend = 0, kend = 0;
-    uint8_t *token;
     char **nargs, **kargs;
     int fpid;
-    FILE *FDKIN,*FDKOUT;
-    FILE *FDNIN,*FDNOUT;
     int pkin[2];
     int pkout[2];
     int pnin[2];
@@ -123,7 +286,7 @@ main(int argc, char *const argv[])
 
     int j = 1;
     if (!strncasecmp(argv[1],"-d",2)) {
-        debug = 1;
+        debug_enabled = 1;
         j = 2;
     }
 
@@ -145,7 +308,7 @@ main(int argc, char *const argv[])
         return 0;
     }
 
-    if (debug)
+    if (debug_enabled)
         fprintf(stderr, "%s| %s: Starting version %s\n", LogTime(), PROGRAM,
                 VERSION);
 
@@ -155,7 +318,7 @@ main(int argc, char *const argv[])
     }
     memcpy(nargs,argv+nstart+1,(nend-nstart)*sizeof(char *));
     nargs[nend-nstart]=NULL;
-    if (debug) {
+    if (debug_enabled) {
         fprintf(stderr, "%s| %s: NTLM command: ", LogTime(), PROGRAM);
         for (int i=0; i<nend-nstart; ++i)
             fprintf(stderr, "%s ", nargs[i]);
@@ -167,7 +330,7 @@ main(int argc, char *const argv[])
     }
     memcpy(kargs,argv+kstart+1,(kend-kstart)*sizeof(char *));
     kargs[kend-kstart]=NULL;
-    if (debug) {
+    if (debug_enabled) {
         fprintf(stderr, "%s| %s: Kerberos command: ", LogTime(), PROGRAM);
         for (int i=0; i<kend-kstart; ++i)
             fprintf(stderr, "%s ", kargs[i]);
@@ -209,7 +372,6 @@ main(int argc, char *const argv[])
         execv(kargs[0], kargs);
         fprintf(stderr, "%s| %s: Failed execv for %s: %s\n", LogTime(), PROGRAM, kargs[0], strerror(errno));
         return 1;
-
     }
 
     close(pkin[0]);
@@ -251,14 +413,15 @@ main(int argc, char *const argv[])
     close(pnin[0]);
     close(pnout[1]);
 
-    FDKIN=fdopen(pkin[1],"w");
-    FDKOUT=fdopen(pkout[0],"r");
+    FILE *FDKIN=fdopen(pkin[1],"w");
+    FILE *FDKOUT=fdopen(pkout[0],"r");
 
-    FDNIN=fdopen(pnin[1],"w");
-    FDNOUT=fdopen(pnout[0],"r");
+    FILE *FDNIN=fdopen(pnin[1],"w");
+    FILE *FDNOUT=fdopen(pnout[0],"r");
 
     if (!FDKIN || !FDKOUT || !FDNIN || !FDNOUT) {
         fprintf(stderr, "%s| %s: Could not assign streams for FDKIN/FDKOUT/FDNIN/FDNOUT\n", LogTime(), PROGRAM);
+        closeFds(FDKIN, FDKOUT, FDNIN, FDNOUT);
         return 1;
     }
 
@@ -267,149 +430,8 @@ main(int argc, char *const argv[])
     setbuf(FDNIN, NULL);
     setbuf(FDNOUT, NULL);
 
-    while (1) {
-        if (fgets(buf, sizeof(buf) - 1, stdin) == NULL) {
-            if (ferror(stdin)) {
-                if (debug)
-                    fprintf(stderr,
-                            "%s| %s: fgets() failed! dying..... errno=%d (%s)\n",
-                            LogTime(), PROGRAM, ferror(stdin),
-                            strerror(ferror(stdin)));
-
-                fprintf(stdout, "BH input error\n");
-                return 1;        /* BIIG buffer */
-            }
-            fprintf(stdout, "BH input error\n");
-            return 0;
-        }
-        c = static_cast<char*>(memchr(buf, '\n', sizeof(buf) - 1));
-        if (c) {
-            *c = '\0';
-            length = c - buf;
-            if (debug)
-                fprintf(stderr, "%s| %s: Got '%s' from squid (length: %d).\n",
-                        LogTime(), PROGRAM, buf, length);
-        } else {
-            if (debug)
-                fprintf(stderr, "%s| %s: Oversized message\n", LogTime(),
-                        PROGRAM);
-            fprintf(stdout, "BH Oversized message\n");
-            continue;
-        }
-
-        if (buf[0] == '\0') {
-            if (debug)
-                fprintf(stderr, "%s| %s: Invalid request\n", LogTime(),
-                        PROGRAM);
-            fprintf(stdout, "BH Invalid request\n");
-            continue;
-        }
-        if (strlen(buf) < 2) {
-            if (debug)
-                fprintf(stderr, "%s| %s: Invalid request [%s]\n", LogTime(),
-                        PROGRAM, buf);
-            fprintf(stdout, "BH Invalid request\n");
-            continue;
-        }
-        if (!strncmp(buf, "QQ", 2)) {
-            fprintf(stdout, "BH quit command\n");
-            return 0;
-        }
-        if (strncmp(buf, "YR", 2) && strncmp(buf, "KK", 2)) {
-            if (debug)
-                fprintf(stderr, "%s| %s: Invalid request [%s]\n", LogTime(),
-                        PROGRAM, buf);
-            fprintf(stdout, "BH Invalid request\n");
-            continue;
-        }
-        if (strlen(buf) <= 3) {
-            if (debug)
-                fprintf(stderr, "%s| %s: Invalid negotiate request [%s]\n",
-                        LogTime(), PROGRAM, buf);
-            fprintf(stdout, "BH Invalid negotiate request\n");
-            continue;
-        }
-        length = BASE64_DECODE_LENGTH(strlen(buf+3));
-        if (debug)
-            fprintf(stderr, "%s| %s: Decode '%s' (decoded length: %d).\n",
-                    LogTime(), PROGRAM, buf + 3, (int) length);
-
-        if ((token = static_cast<uint8_t *>(xmalloc(length))) == NULL) {
-            fprintf(stderr, "%s| %s: Error allocating memory for token\n", LogTime(), PROGRAM);
-            return 1;
-        }
-
-        struct base64_decode_ctx ctx;
-        base64_decode_init(&ctx);
-        size_t dstLen = 0;
-        if (!base64_decode_update(&ctx, &dstLen, token, strlen(buf+3), reinterpret_cast<const uint8_t*>(buf+3)) ||
-                !base64_decode_final(&ctx)) {
-            if (debug)
-                fprintf(stderr, "%s| %s: Invalid base64 token [%s]\n", LogTime(), PROGRAM, buf+3);
-            fprintf(stdout, "BH Invalid negotiate request token\n");
-            continue;
-        }
-        length = dstLen;
-        token[dstLen] = '\0';
-
-        if ((static_cast<size_t>(length) >= sizeof(ntlmProtocol) + 1) &&
-                (!memcmp(token, ntlmProtocol, sizeof ntlmProtocol))) {
-            free(token);
-            if (debug)
-                fprintf(stderr, "%s| %s: received type %d NTLM token\n",
-                        LogTime(), PROGRAM, (int) *((unsigned char *) token +
-                                                    sizeof ntlmProtocol));
-            fprintf(FDNIN, "%s\n",buf);
-            if (fgets(tbuff, sizeof(tbuff) - 1, FDNOUT) == NULL) {
-                if (ferror(FDNOUT)) {
-                    fprintf(stderr,
-                            "fgets() failed! dying..... errno=%d (%s)\n",
-                            ferror(FDNOUT), strerror(ferror(FDNOUT)));
-                    return 1;
-                }
-                fprintf(stderr, "%s| %s: Error reading NTLM helper response\n",
-                        LogTime(), PROGRAM);
-                return 0;
-            }
-            /*
-                   Need to translate NTLM reply to Negotiate reply
-                   AF user => AF blob user
-               NA reason => NA blob reason
-               Set blob to '='
-                */
-            if (strlen(tbuff) >= 3 && (!strncmp(tbuff,"AF ",3) || !strncmp(tbuff,"NA ",3))) {
-                strncpy(buff,tbuff,3);
-                buff[3]='=';
-                for (unsigned int i=2; i<=strlen(tbuff); ++i)
-                    buff[i+2] = tbuff[i];
-            } else {
-                strcpy(buff,tbuff);
-            }
-        } else {
-            xfree(token);
-            if (debug)
-                fprintf(stderr, "%s| %s: received Kerberos token\n",
-                        LogTime(), PROGRAM);
-
-            fprintf(FDKIN, "%s\n",buf);
-            if (fgets(buff, sizeof(buff) - 1, FDKOUT) == NULL) {
-                if (ferror(FDKOUT)) {
-                    fprintf(stderr,
-                            "fgets() failed! dying..... errno=%d (%s)\n",
-                            ferror(FDKOUT), strerror(ferror(FDKOUT)));
-                    return 1;
-                }
-                fprintf(stderr, "%s| %s: Error reading Kerberos helper response\n",
-                        LogTime(), PROGRAM);
-                return 0;
-            }
-        }
-        fprintf(stdout,"%s",buff);
-        if (debug)
-            fprintf(stderr, "%s| %s: Return '%s'\n",
-                    LogTime(), PROGRAM, buff);
-    }
-
-    return 1;
+    int result = processingLoop(FDKIN, FDKOUT, FDNIN, FDNOUT);
+    closeFds(FDKIN, FDKOUT, FDNIN, FDNOUT);
+    return result;
 }
 
@@ -9,7 +9,7 @@
 #
 # (C) 2000 Francesco Chemolli <kinkie@kame.usr.dsi.unimi.it>
 # Distributed freely under the terms of the GNU General Public License,
-# version 2. For the licensing terms, see the file COPYING that
+# version 2 or later. For the licensing terms, see the file COPYING that
 # came with Squid.
 #
 # This is a dummy NTLM authentication module for Squid.
@@ -9,7 +9,7 @@
 /*
  * (C) 2000 Francesco Chemolli <kinkie@kame.usr.dsi.unimi.it>
  * Distributed freely under the terms of the GNU General Public License,
- * version 2. See the file COPYING for licensing details
+ * version 2 or later. See the file COPYING for licensing details
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -262,23 +262,32 @@ ntlm_check_auth(ntlm_authenticate * auth, int auth_length)
     memcpy(user, tmp.str, tmp.l);
     *(user + tmp.l) = '\0';
 
-    /* Authenticating against the NT response doesn't seem to work... */
-    tmp = ntlm_fetch_string(&(auth->hdr), auth_length, &auth->lmresponse, auth->flags);
-    if (tmp.str == NULL || tmp.l == 0) {
-        fprintf(stderr, "No auth at all. Returning no-auth\n");
-        ntlm_errno = NTLM_ERR_LOGON;
-        return NULL;
+    // grab the *response blobs. these are fixed length 24 bytes of binary
+    const ntlmhdr *packet = &(auth->hdr);
+    {
+        const strhdr * str = &auth->lmresponse;
+
+        int16_t len = le16toh(str->len);
+        int32_t offset = le32toh(str->offset);
+
+        if (len != ENCODED_PASS_LEN || offset + len > auth_length || offset == 0) {
+            debug("LM response: insane data (pkt-sz: %d, fetch len: %d, offset: %d)\n", auth_length, len, offset);
+            ntlm_errno = NTLM_ERR_LOGON;
+            return NULL;
+        }
+        tmp.str = (char *)packet + offset;
+        tmp.l = len;
     }
     if (tmp.l > MAX_PASSWD_LEN) {
         debug("Password string exceeds %d bytes, rejecting\n", MAX_PASSWD_LEN);
         ntlm_errno = NTLM_ERR_LOGON;
         return NULL;
     }
 
+    /* Authenticating against the NT response doesn't seem to work... in SMB LM helper. */
     memcpy(pass, tmp.str, tmp.l);
     pass[min(MAX_PASSWD_LEN,tmp.l)] = '\0';
 
-#if 1
     debug("Empty LM pass detection: user: '%s', ours:'%s', his: '%s' (length: %d)\n",
           user,lmencoded_empty_pass,tmp.str,tmp.l);
     if (memcmp(tmp.str,lmencoded_empty_pass,ENCODED_PASS_LEN)==0) {
@@ -288,19 +297,31 @@ ntlm_check_auth(ntlm_authenticate * auth, int auth_length)
         return NULL;
     }
 
-    tmp = ntlm_fetch_string(&(auth->hdr), auth_length, &auth->ntresponse, auth->flags);
-    if (tmp.str != NULL && tmp.l != 0) {
-        debug("Empty NT pass detection: user: '%s', ours:'%s', his: '%s' (length: %d)\n",
-              user,ntencoded_empty_pass,tmp.str,tmp.l);
-        if (memcmp(tmp.str,lmencoded_empty_pass,ENCODED_PASS_LEN)==0) {
-            fprintf(stderr,"ERROR: Empty NT password supplied for user %s\\%s. No-auth\n", domain, user);
-            ntlm_errno = NTLM_ERR_LOGON;
-            return NULL;
+    /* still fetch the NT response and check validity against empty password */
+    {
+        const strhdr * str = &auth->ntresponse;
+        int16_t len = le16toh(str->len);
+        // NT response field may be absent. that is okay.
+        if (len != 0) {
+            int32_t offset = le32toh(str->offset);
+
+            if (len != ENCODED_PASS_LEN || offset + len > auth_length || offset == 0) {
+                debug("NT response: insane data (pkt-sz: %d, fetch len: %d, offset: %d)\n", auth_length, len, offset);
+                ntlm_errno = NTLM_ERR_LOGON;
+                return NULL;
+            }
+            tmp.str = (char *)packet + offset;
+            tmp.l = len;
+
+            debug("Empty NT pass detection: user: '%s', ours:'%s', his: '%s' (length: %d)\n",
+                  user,ntencoded_empty_pass,tmp.str,tmp.l);
+            if (memcmp(tmp.str,lmencoded_empty_pass,ENCODED_PASS_LEN)==0) {
+                fprintf(stderr,"ERROR: Empty NT password supplied for user %s\\%s. No-auth\n", domain, user);
+                ntlm_errno = NTLM_ERR_LOGON;
+                return NULL;
+            }
         }
     }
-#endif
-
-    /* TODO: check against empty password!!!!! */
 
     debug("checking domain: '%s', user: '%s', pass='%s'\n", domain, user, pass);
 
@@ -385,7 +406,7 @@ process_options(int argc, char *argv[])
         char *d, *c;
         /* d will not be freed in case of non-error. Since we don't reconfigure,
          * it's going to live as long as the process anyways */
-        d = (char*)malloc(strlen(argv[j]) + 1);
+        d = static_cast<char*>(xmalloc(strlen(argv[j]) + 1));
         strcpy(d, argv[j]);
         debug("Adding domain-controller %s\n", d);
         if (NULL == (c = strchr(d, '\\')) && NULL == (c = strchr(d, '/'))) {
@@ -401,7 +422,7 @@ process_options(int argc, char *argv[])
         }
         *c= '\0';
         ++c;
-        new_dc = (dc *) malloc(sizeof(dc));
+        new_dc = static_cast<dc *>(xmalloc(sizeof(dc)));
         if (!new_dc) {
             fprintf(stderr, "Malloc error while parsing DC options\n");
             free(d);
@@ -12,15 +12,16 @@
 typedef void HASHFREE(void *);
 typedef int HASHCMP(const void *, const void *);
 typedef unsigned int HASHHASH(const void *, unsigned int);
-typedef struct _hash_link hash_link;
-typedef struct _hash_table hash_table;
 
-struct _hash_link {
+class hash_link {
+public:
+    hash_link() : key(nullptr), next(nullptr) {}
     void *key;
     hash_link *next;
 };
 
-struct _hash_table {
+class hash_table {
+public:
     hash_link **buckets;
     HASHCMP *cmp;
     HASHHASH *hash;
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-#ifndef _MEM_METER_H_
-#define _MEM_METER_H_
-
-/* object to track per-action memory usage (e.g. #idle objects) */
-class MemMeter
-{
-public:
-    MemMeter() : level(0), hwater_level(0), hwater_stamp(0) {}
-    ssize_t level;              /* current level (count or volume) */
-    ssize_t hwater_level;       /* high water mark */
-    time_t hwater_stamp;        /* timestamp of last high water mark change */
-};
-
-#define memMeterSyncHWater(m)  { (m).hwater_level = (m).level; (m).hwater_stamp = squid_curtime ? squid_curtime : time(NULL); }
-#define memMeterCheckHWater(m) { if ((m).hwater_level < (m).level) memMeterSyncHWater((m)); }
-#define memMeterInc(m) { (m).level++; memMeterCheckHWater(m); }
-#define memMeterDec(m) { (m).level--; }
-#define memMeterAdd(m, sz) { (m).level += (sz); memMeterCheckHWater(m); }
-#define memMeterDel(m, sz) { (m).level -= (sz); }
-
-#endif /* _MEM_METER_H_ */
-
@@ -344,7 +344,7 @@ main(void)
     printf("done creating hash table: %d\n", hid);
 
     std::mt19937 mt;
-    std::uniform_int_distribution<> dist(0,16);
+    xuniform_int_distribution<> dist(0,16);
 
     while (fgets(buf, BUFSIZ, stdin)) {
         buf[strlen(buf) - 1] = '\0';
@@ -185,7 +185,7 @@ void
 ntlm_make_nonce(char *nonce)
 {
     static std::mt19937 mt(time(0));
-    static std::uniform_int_distribution<uint8_t> dist;
+    static xuniform_int_distribution<uint8_t> dist;
 
     for (int i = 0; i < NTLM_NONCE_LEN; ++i)
         nonce[i] = static_cast<char>(dist(mt) & 0xFF);
@@ -60,8 +60,8 @@ if [ ${name} != ${PACKAGE}-${VERSION} ]; then
 	echo "${name} != ${PACKAGE}-${VERSION}"
 	exit 1
 fi
-RELEASE=`echo $VERSION | cut -d. -f1,2 | cut -d- -f1`
-NOTES_VERSION=`grep "$VERSION" doc/release-notes/release-${RELEASE}.html`
+RELEASE=`echo $VERSION | cut -d. -f1,1 | cut -d- -f1`
+NOTES_VERSION=`grep "$VERSION" doc/release-notes/release-${RELEASE}.sgml`
 if test "x$NOTES_VERSION" = "x"; then
 	echo "ERROR! Release Notes HTML version numbers do not match!"
 	exit 1
@@ -94,7 +94,12 @@ if [ -f ${tmpdir}/${PACKAGE}-${VERSION}-${suffix}.diff ]; then
     echo ${PACKAGE}-${VERSION}-${suffix}.diff >>${tag}.out
 fi
 
-relnotes=${tmpdir}/doc/release-notes/release-`echo ${VERSION} | cut -d. -f1,2 | cut -d- -f1`.html
+# latest Squid 'make' builds a RELEASENOTES.html at top directory
+relnotes=${tmpdir}/RELEASENOTES.html
+if [ ! -f ${relnotes} ]; then
+	# for older Squid-3.x versions we may need to move find the release notes by version
+	relnotes=${tmpdir}/doc/release-notes/release-`echo ${VERSION} | cut -d. -f1,2 | cut -d- -f1`.html
+fi
 if [ -f ${relnotes} ]; then
 	cp -p ${relnotes} ${PACKAGE}-${VERSION}-${suffix}-RELEASENOTES.html
 	echo ${PACKAGE}-${VERSION}-${suffix}-RELEASENOTES.html >>${tag}.out
@@ -277,6 +277,9 @@ done
 echo " "
 )| sed s%${ROOT}/src/%%g >${ROOT}/src/tests/Stub.list
 
+# Build the GPERF generated content
+make -C src/http gperf-files
+
 # Run formating
 echo "" >${ROOT}/doc/debug-sections.tmp
 srcformat || exit 1
@@ -158,7 +158,7 @@ class AccessLogEntry: public RefCountable
 #if USE_OPENSSL
 
         const char *ssluser;
-        Ssl::X509_Pointer sslClientCert; ///< cert received from the client
+        Security::CertPointer sslClientCert; ///< cert received from the client
 #endif
         AnyP::PortCfgPointer port;
 
@@ -11,8 +11,7 @@
 #ifndef SQUID_CACHEDIGEST_H_
 #define SQUID_CACHEDIGEST_H_
 
-/* for cache_key */
-#include "typedefs.h"
+#include "store_key_md5.h"
 
 class CacheDigestGuessStats;
 class StoreEntry;
@@ -9,12 +9,14 @@
 #ifndef SQUID__SRC_CLIENTINFO_H
 #define SQUID__SRC_CLIENTINFO_H
 
+#include "base/ByteCounter.h"
 #include "cbdata.h"
 #include "enums.h"
 #include "hash.h"
 #include "ip/Address.h"
 #include "LogTags.h"
 #include "typedefs.h"
+
 #include <deque>
 
 #if USE_DELAY_POOLS
@@ -31,9 +33,9 @@ class ClientInfo
     struct {
         int result_hist[LOG_TYPE_MAX];
         int n_requests;
-        kb_t kbytes_in;
-        kb_t kbytes_out;
-        kb_t hit_kbytes_out;
+        ByteCounter kbytes_in;
+        ByteCounter kbytes_out;
+        ByteCounter hit_kbytes_out;
     } Http, Icp;
 
     struct {
@@ -13,7 +13,6 @@
 
 #include "ipc/forward.h"
 #include "ipc/Queue.h"
-#include "typedefs.h"
 
 #include <memory>
 
@@ -11,6 +11,9 @@
 #ifndef SQUID_DEBUG_H
 #define SQUID_DEBUG_H
 
+// XXX should be mem/forward.h once it removes dependencies on typedefs.h
+#include "mem/AllocatorProxy.h"
+
 #include <iostream>
 #undef assert
 #include <sstream>
@@ -71,12 +74,10 @@ class Debug
     /// with the libc++6 std::ostringstream definitions
     class OutStream : public std::ostringstream
     {
-        // XXX: use MEMPROXY_CLASS() once that no longer pulls in typedefs.h and enums.h and globals.h
+        MEMPROXY_CLASS(OutStream);
     public:
-        void *operator new(size_t size) throw(std::bad_alloc) {return xmalloc(size);}
-        void operator delete(void *address) throw() {xfree(address);}
-        void *operator new[] (size_t size) throw(std::bad_alloc) ; //{return xmalloc(size);}
-        void operator delete[] (void *address) throw() ; // {xfree(address);}
+        void *operator new[] (size_t size) throw(std::bad_alloc) = delete; //{return xmalloc(size);}
+        void operator delete[] (void *address) throw() = delete; // {xfree(address);}
     };
 
     static OutStream *CurrentDebug;
@@ -99,8 +100,10 @@ const char * SkipBuildPrefix(const char* path);
         if ((Debug::level = (LEVEL)) <= Debug::Levels[SECTION]) { \
             Debug::sectionLevel = Debug::Levels[SECTION]; \
             std::ostream &_dbo=Debug::getDebugOut(); \
-            if (Debug::level > DBG_IMPORTANT) \
-                _dbo << SkipBuildPrefix(__FILE__)<<"("<<__LINE__<<") "<<__FUNCTION__<<": "; \
+            if (Debug::level > DBG_IMPORTANT) { \
+                _dbo << (SECTION) << ',' << (LEVEL) << "| " \
+                     << SkipBuildPrefix(__FILE__)<<"("<<__LINE__<<") "<<__FUNCTION__<<": "; \
+            } \
             _dbo << CONTENT; \
             Debug::finishDebug(); \
         } \
@@ -19,8 +19,7 @@
 #endif
 #endif
 
-/* for FREE* */
-#include "typedefs.h"
+#include "mem/forward.h"
 
 #define MAX_ASYNCOP     128
 
@@ -14,6 +14,7 @@
 #include "cbdata.h"
 #include "DiskIO/DiskFile.h"
 #include "DiskIO/IORequestor.h"
+#include "typedefs.h" //DRCB, DWCB
 
 class BlockingFile : public DiskFile
 {
@@ -10,7 +10,7 @@
 #define SQUID_DISKFILE_H
 
 #include "base/RefCount.h"
-#include "typedefs.h"
+#include "SquidTime.h"
 
 class IORequestor;
 
@@ -16,7 +16,7 @@
 #define __DISKTHREADS_H__
 
 #include "dlink.h"
-#include "typedefs.h"
+#include "mem/forward.h"
 
 /* this non-standard-conformant include is needed in order to have stat(2) and struct stat
    properly defined on some systems (e.g. OpenBSD 5.4) */
@@ -10,9 +10,11 @@
 
 #ifndef SQUID_DISKTHREADSDISKFILE_H
 #define SQUID_DISKTHREADSDISKFILE_H
+
 #include "cbdata.h"
 #include "DiskIO/DiskFile.h"
 #include "DiskThreads.h"
+#include "typedefs.h" //for DWCB
 
 class DiskThreadsDiskFile : public DiskFile
 {
@@ -11,6 +11,7 @@
 
 #include "base/RefCount.h"
 #include "cbdata.h"
+#include "mem/forward.h"
 
 class WriteRequest : public RefCountable
 {
@@ -11,7 +11,7 @@
 #ifndef FILEMAP_H_
 #define FILEMAP_H_
 
-#include "typedefs.h"
+#include "fs/forward.h"
 
 /** A bitmap used for managing UFS StoreEntry "file numbers".
  *
@@ -9,7 +9,7 @@
 /* DEBUG: section 55    HTTP Header */
 
 #include "squid.h"
-//#include "base/LookupTable.h" // pulled by HttpHdrCc.h
+#include "base/EnumIterator.h"
 #include "base64.h"
 #include "globals.h"
 #include "HttpHdrCc.h"
@@ -61,160 +61,13 @@
  */
 
 // statistics counters for headers. clients must not allow Http::HdrType::BAD_HDR to be counted
-std::vector<HttpHeaderFieldStat> headerStatsTable(Http::HdrType::ENUM_END);
+std::vector<HttpHeaderFieldStat> headerStatsTable(Http::HdrType::enumEnd_);
 
-/*
- * headers with field values defined as #(values) in HTTP/1.1
- * Headers that are currently not recognized, are commented out.
- */
-static HttpHeaderMask ListHeadersMask;  /* set run-time using  ListHeadersArr */
-static Http::HdrType ListHeadersArr[] = {
-    Http::HdrType::ACCEPT,
-    Http::HdrType::ACCEPT_CHARSET,
-    Http::HdrType::ACCEPT_ENCODING,
-    Http::HdrType::ACCEPT_LANGUAGE,
-    Http::HdrType::ACCEPT_RANGES,
-    Http::HdrType::ALLOW,
-    Http::HdrType::CACHE_CONTROL,
-    Http::HdrType::CONTENT_ENCODING,
-    Http::HdrType::CONTENT_LANGUAGE,
-    Http::HdrType::CONNECTION,
-    Http::HdrType::EXPECT,
-    Http::HdrType::IF_MATCH,
-    Http::HdrType::IF_NONE_MATCH,
-    Http::HdrType::KEY,
-    Http::HdrType::LINK,
-    Http::HdrType::PRAGMA,
-    Http::HdrType::PROXY_CONNECTION,
-    Http::HdrType::PROXY_SUPPORT,
-    Http::HdrType::TRANSFER_ENCODING,
-    Http::HdrType::UPGRADE,
-    Http::HdrType::VARY,
-    Http::HdrType::VIA,
-    Http::HdrType::WARNING,
-    Http::HdrType::WWW_AUTHENTICATE,
-    Http::HdrType::AUTHENTICATION_INFO,
-    Http::HdrType::PROXY_AUTHENTICATION_INFO,
-    /* Http::HdrType::TE, Http::HdrType::TRAILER */
-#if X_ACCELERATOR_VARY
-    Http::HdrType::HDR_X_ACCELERATOR_VARY,
-#endif
-#if USE_ADAPTATION
-    Http::HdrType::X_NEXT_SERVICES,
-#endif
-    Http::HdrType::SURROGATE_CAPABILITY,
-    Http::HdrType::SURROGATE_CONTROL,
-    Http::HdrType::FORWARDED,
-    Http::HdrType::X_FORWARDED_FOR
-};
-
-/* general-headers */
-static Http::HdrType GeneralHeadersArr[] = {
-    Http::HdrType::CACHE_CONTROL,
-    Http::HdrType::CONNECTION,
-    Http::HdrType::DATE,
-    Http::HdrType::FORWARDED,
-    Http::HdrType::X_FORWARDED_FOR,
-    Http::HdrType::MIME_VERSION,
-    Http::HdrType::PRAGMA,
-    Http::HdrType::PROXY_CONNECTION,
-    Http::HdrType::TRANSFER_ENCODING,
-    Http::HdrType::UPGRADE,
-    /* Http::HdrType::TRAILER, */
-    Http::HdrType::VIA,
-};
-
-/* entity-headers */
-static Http::HdrType EntityHeadersArr[] = {
-    Http::HdrType::ALLOW,
-    Http::HdrType::CONTENT_BASE,
-    Http::HdrType::CONTENT_ENCODING,
-    Http::HdrType::CONTENT_LANGUAGE,
-    Http::HdrType::CONTENT_LENGTH,
-    Http::HdrType::CONTENT_LOCATION,
-    Http::HdrType::CONTENT_MD5,
-    Http::HdrType::CONTENT_RANGE,
-    Http::HdrType::CONTENT_TYPE,
-    Http::HdrType::ETAG,
-    Http::HdrType::EXPIRES,
-    Http::HdrType::LAST_MODIFIED,
-    Http::HdrType::LINK,
-    Http::HdrType::OTHER
-};
-
-/* request-only headers */
+/* request-only headers. Used for cachemgr */
 static HttpHeaderMask RequestHeadersMask;   /* set run-time using RequestHeaders */
-static Http::HdrType RequestHeadersArr[] = {
-    Http::HdrType::ACCEPT,
-    Http::HdrType::ACCEPT_CHARSET,
-    Http::HdrType::ACCEPT_ENCODING,
-    Http::HdrType::ACCEPT_LANGUAGE,
-    Http::HdrType::AUTHORIZATION,
-    Http::HdrType::EXPECT,
-    Http::HdrType::FROM,
-    Http::HdrType::HOST,
-    Http::HdrType::HTTP2_SETTINGS,
-    Http::HdrType::IF_MATCH,
-    Http::HdrType::IF_MODIFIED_SINCE,
-    Http::HdrType::IF_NONE_MATCH,
-    Http::HdrType::IF_RANGE,
-    Http::HdrType::IF_UNMODIFIED_SINCE,
-    Http::HdrType::MAX_FORWARDS,
-    Http::HdrType::ORIGIN,
-    Http::HdrType::PROXY_AUTHORIZATION,
-    Http::HdrType::RANGE,
-    Http::HdrType::REFERER,
-    Http::HdrType::REQUEST_RANGE,
-    Http::HdrType::TE,
-    Http::HdrType::USER_AGENT,
-    Http::HdrType::SURROGATE_CAPABILITY
-};
 
-/* reply-only headers */
+/* reply-only headers. Used for cachemgr */
 static HttpHeaderMask ReplyHeadersMask;     /* set run-time using ReplyHeaders */
-static Http::HdrType ReplyHeadersArr[] = {
-    Http::HdrType::ACCEPT_ENCODING,
-    Http::HdrType::ACCEPT_RANGES,
-    Http::HdrType::AGE,
-    Http::HdrType::KEY,
-    Http::HdrType::LOCATION,
-    Http::HdrType::PROXY_AUTHENTICATE,
-    Http::HdrType::PUBLIC,
-    Http::HdrType::RETRY_AFTER,
-    Http::HdrType::SERVER,
-    Http::HdrType::SET_COOKIE,
-    Http::HdrType::SET_COOKIE2,
-    Http::HdrType::VARY,
-    Http::HdrType::WARNING,
-    Http::HdrType::WWW_AUTHENTICATE,
-    Http::HdrType::X_CACHE,
-    Http::HdrType::X_CACHE_LOOKUP,
-    Http::HdrType::X_REQUEST_URI,
-#if X_ACCELERATOR_VARY
-    Http::HdrType::HDR_X_ACCELERATOR_VARY,
-#endif
-#if USE_ADAPTATION
-    Http::HdrType::X_NEXT_SERVICES,
-#endif
-    Http::HdrType::X_SQUID_ERROR,
-    Http::HdrType::SURROGATE_CONTROL
-};
-
-/* hop-by-hop headers */
-static HttpHeaderMask HopByHopHeadersMask;
-static Http::HdrType HopByHopHeadersArr[] = {
-    Http::HdrType::ALTERNATE_PROTOCOL,
-    Http::HdrType::CONNECTION,
-    Http::HdrType::HTTP2_SETTINGS,
-    Http::HdrType::KEEP_ALIVE,
-    /*Http::HdrType::PROXY_AUTHENTICATE, // removal handled specially for peer login */
-    Http::HdrType::PROXY_AUTHORIZATION,
-    Http::HdrType::TE,
-    Http::HdrType::TRAILER,
-    Http::HdrType::TRANSFER_ENCODING,
-    Http::HdrType::UPGRADE,
-    Http::HdrType::PROXY_CONNECTION
-};
 
 /* header accounting */
 // NP: keep in sync with enum http_hdr_owner_type
@@ -240,7 +93,9 @@ static int HeaderEntryParsedCount = 0;
 
 class StoreEntry;
 
-static void httpHeaderNoteParsedEntry(Http::HdrType id, String const &value, int error);
+// update parse statistics for header id; if error is true also account
+// for errors and write to debug log what happened
+static void httpHeaderNoteParsedEntry(Http::HdrType id, String const &value, bool error);
 static void httpHeaderStatDump(const HttpHeaderStat * hs, StoreEntry * e);
 /** store report about current header usage and other stats */
 static void httpHeaderStoreReport(StoreEntry * e);
@@ -261,28 +116,15 @@ void
 httpHeaderInitModule(void)
 {
     /* check that we have enough space for masks */
-    assert(8 * sizeof(HttpHeaderMask) >= Http::HdrType::ENUM_END);
-
-    // check invariant: for each index in headerTable, (int)headerTable[index] = index
-    for (int i = 0; Http::HeaderTable[i].name; ++i)
-        assert(Http::HeaderTable[i].id == i);
-
-    /* create masks. XXX: migrate to std::vector<bool>? */
-    httpHeaderMaskInit(&ListHeadersMask, 0);
-    httpHeaderCalcMask(&ListHeadersMask, ListHeadersArr, countof(ListHeadersArr));
-
-    httpHeaderMaskInit(&ReplyHeadersMask, 0);
-    httpHeaderCalcMask(&ReplyHeadersMask, ReplyHeadersArr, countof(ReplyHeadersArr));
-    httpHeaderCalcMask(&ReplyHeadersMask, GeneralHeadersArr, countof(GeneralHeadersArr));
-    httpHeaderCalcMask(&ReplyHeadersMask, EntityHeadersArr, countof(EntityHeadersArr));
-
-    httpHeaderMaskInit(&RequestHeadersMask, 0);
-    httpHeaderCalcMask(&RequestHeadersMask, RequestHeadersArr, countof(RequestHeadersArr));
-    httpHeaderCalcMask(&RequestHeadersMask, GeneralHeadersArr, countof(GeneralHeadersArr));
-    httpHeaderCalcMask(&RequestHeadersMask, EntityHeadersArr, countof(EntityHeadersArr));
-
-    httpHeaderMaskInit(&HopByHopHeadersMask, 0);
-    httpHeaderCalcMask(&HopByHopHeadersMask, HopByHopHeadersArr, countof(HopByHopHeadersArr));
+    assert(8 * sizeof(HttpHeaderMask) >= Http::HdrType::enumEnd_);
+
+    // masks are needed for stats page still
+    for (auto h : WholeEnum<Http::HdrType>()) {
+        if (Http::HeaderLookupTable.lookup(h).request)
+            CBIT_SET(RequestHeadersMask,h);
+        if (Http::HeaderLookupTable.lookup(h).reply)
+            CBIT_SET(ReplyHeadersMask,h);
+    }
 
     /* header stats initialized by class constructor */
     assert(HttpHeaderStatCount == hoReply + 1);
@@ -298,19 +140,19 @@ httpHeaderInitModule(void)
  * HttpHeader Implementation
  */
 
-HttpHeader::HttpHeader() : owner (hoNone), len (0)
+HttpHeader::HttpHeader() : owner (hoNone), len (0), conflictingContentLength_(false)
 {
     httpHeaderMaskInit(&mask, 0);
 }
 
-HttpHeader::HttpHeader(const http_hdr_owner_type anOwner): owner(anOwner), len(0)
+HttpHeader::HttpHeader(const http_hdr_owner_type anOwner): owner(anOwner), len(0), conflictingContentLength_(false)
 {
     assert(anOwner > hoNone && anOwner < hoEnd);
     debugs(55, 7, "init-ing hdr: " << this << " owner: " << owner);
     httpHeaderMaskInit(&mask, 0);
 }
 
-HttpHeader::HttpHeader(const HttpHeader &other): owner(other.owner), len(other.len)
+HttpHeader::HttpHeader(const HttpHeader &other): owner(other.owner), len(other.len), conflictingContentLength_(false)
 {
     httpHeaderMaskInit(&mask, 0);
     update(&other, NULL); // will update the mask as well
@@ -330,6 +172,7 @@ HttpHeader::operator =(const HttpHeader &other)
         clean();
         update(&other, NULL); // will update the mask as well
         len = other.len;
+        conflictingContentLength_ = other.conflictingContentLength_;
     }
     return *this;
 }
@@ -362,7 +205,7 @@ HttpHeader::clean()
         HttpHeaderStats[owner].busyDestroyedCount += entries.size() > 0;
     } // if (owner <= hoReply)
 
-    for(HttpHeaderEntry *e : entries) {
+    for (HttpHeaderEntry *e : entries) {
         if (e == nullptr)
             continue;
         if (!Http::any_valid_header(e->id)) {
@@ -377,32 +220,24 @@ HttpHeader::clean()
     entries.clear();
     httpHeaderMaskInit(&mask, 0);
     len = 0;
+    conflictingContentLength_ = false;
     PROF_stop(HttpHeaderClean);
 }
 
 /* append entries (also see httpHeaderUpdate) */
 void
 HttpHeader::append(const HttpHeader * src)
 {
-    const HttpHeaderEntry *e;
-    HttpHeaderPos pos = HttpHeaderInitPos;
     assert(src);
     assert(src != this);
     debugs(55, 7, "appending hdr: " << this << " += " << src);
 
-    while ((e = src->getEntry(&pos))) {
-        addEntry(e->clone());
+    for (auto e : src->entries) {
+        if (e)
+            addEntry(e->clone());
     }
 }
 
-/* use fresh entries to replace old ones */
-void
-httpHeaderUpdate(HttpHeader * old, const HttpHeader * fresh, const HttpHeaderMask * denied_mask)
-{
-    assert (old);
-    old->update (fresh, denied_mask);
-}
-
 void
 HttpHeader::update (HttpHeader const *fresh, HttpHeaderMask const *denied_mask)
 {
@@ -430,20 +265,12 @@ HttpHeader::update (HttpHeader const *fresh, HttpHeaderMask const *denied_mask)
         if (denied_mask && CBIT_TEST(*denied_mask, e->id))
             continue;
 
-        debugs(55, 7, "Updating header '" << Http::HeaderTable[e->id].name << "' in cached entry");
+        debugs(55, 7, "Updating header '" << Http::HeaderLookupTable.lookup(e->id).name << "' in cached entry");
 
         addEntry(e->clone());
     }
 }
 
-/* just handy in parsing: resets and returns false */
-int
-HttpHeader::reset()
-{
-    clean();
-    return 0;
-}
-
 int
 HttpHeader::parse(const char *header_start, size_t hdrLen)
 {
@@ -463,7 +290,8 @@ HttpHeader::parse(const char *header_start, size_t hdrLen)
         debugs(55, DBG_IMPORTANT, "WARNING: HTTP header contains NULL characters {" <<
                getStringPrefix(header_start, nulpos-header_start) << "}\nNULL\n{" << getStringPrefix(nulpos+1, hdrLen-(nulpos-header_start)-1));
         PROF_stop(HttpHeaderParse);
-        return reset();
+        clean();
+        return 0;
     }
 
     /* common format headers are "<name>:[ws]<value>" lines delimited by <CRLF>.
@@ -479,7 +307,8 @@ HttpHeader::parse(const char *header_start, size_t hdrLen)
             if (!field_ptr) {
                 // missing <LF>
                 PROF_stop(HttpHeaderParse);
-                return reset();
+                clean();
+                return 0;
             }
 
             field_end = field_ptr;
@@ -500,7 +329,8 @@ HttpHeader::parse(const char *header_start, size_t hdrLen)
                                "header field to prevent request smuggling attacks: {" <<
                                getStringPrefix(header_start, hdrLen) << "}");
                         PROF_stop(HttpHeaderParse);
-                        return reset();
+                        clean();
+                        return 0;
                     }
                 }
             }
@@ -519,15 +349,17 @@ HttpHeader::parse(const char *header_start, size_t hdrLen)
                     }
                 } else {
                     PROF_stop(HttpHeaderParse);
-                    return reset();
+                    clean();
+                    return 0;
                 }
             }
 
             if (this_line + 1 == field_end && this_line > field_start) {
                 debugs(55, warnOnError, "WARNING: Blank continuation line in HTTP header {" <<
                        getStringPrefix(header_start, hdrLen) << "}");
                 PROF_stop(HttpHeaderParse);
-                return reset();
+                clean();
+                return 0;
             }
         } while (field_ptr < header_end && (*field_ptr == ' ' || *field_ptr == '\t'));
 
@@ -536,7 +368,8 @@ HttpHeader::parse(const char *header_start, size_t hdrLen)
                 debugs(55, warnOnError, "WARNING: unparseable HTTP header field near {" <<
                        getStringPrefix(field_start, hdrLen-(field_start-header_start)) << "}");
                 PROF_stop(HttpHeaderParse);
-                return reset();
+                clean();
+                return 0;
             }
 
             break;      /* terminating blank line */
@@ -551,9 +384,12 @@ HttpHeader::parse(const char *header_start, size_t hdrLen)
                 continue;
 
             PROF_stop(HttpHeaderParse);
-            return reset();
+            clean();
+            return 0;
         }
 
+        // XXX: RFC 7230 Section 3.3.3 item #4 requires sending a 502 error in
+        // several cases that we do not yet cover. TODO: Rewrite to cover more.
         if (e->id == Http::HdrType::CONTENT_LENGTH && (e2 = findEntry(e->id)) != nullptr) {
             if (e->value != e2->value) {
                 int64_t l1, l2;
@@ -563,7 +399,8 @@ HttpHeader::parse(const char *header_start, size_t hdrLen)
                 if (!Config.onoff.relaxed_header_parser) {
                     delete e;
                     PROF_stop(HttpHeaderParse);
-                    return reset();
+                    clean();
+                    return 0;
                 }
 
                 if (!httpHeaderParseOffset(e->value.termedBuf(), &l1)) {
@@ -573,9 +410,9 @@ HttpHeader::parse(const char *header_start, size_t hdrLen)
                 } else if (!httpHeaderParseOffset(e2->value.termedBuf(), &l2)) {
                     debugs(55, DBG_IMPORTANT, "WARNING: Unparseable content-length '" << e2->value << "'");
                     delById(e2->id);
-                } else if (l1 > l2) {
-                    delById(e2->id);
                 } else {
+                    if (l1 != l2)
+                        conflictingContentLength_ = true;
                     delete e;
                     continue;
                 }
@@ -587,7 +424,8 @@ HttpHeader::parse(const char *header_start, size_t hdrLen)
                     continue;
 
                 PROF_stop(HttpHeaderParse);
-                return reset();
+                clean();
+                return 0;
             }
         }
 
@@ -598,7 +436,8 @@ HttpHeader::parse(const char *header_start, size_t hdrLen)
             if (!Config.onoff.relaxed_header_parser) {
                 delete e;
                 PROF_stop(HttpHeaderParse);
-                return reset();
+                clean();
+                return 0;
             }
         }
 
@@ -608,6 +447,11 @@ HttpHeader::parse(const char *header_start, size_t hdrLen)
     if (chunked()) {
         // RFC 2616 section 4.4: ignore Content-Length with Transfer-Encoding
         delById(Http::HdrType::CONTENT_LENGTH);
+        // RFC 7230 section 3.3.3 #4: ignore Content-Length conflicts with Transfer-Encoding
+        conflictingContentLength_ = false;
+    } else if (conflictingContentLength_) {
+        // ensure our callers do not see the conflicting Content-Length value
+        delById(Http::HdrType::CONTENT_LENGTH);
     }
 
     PROF_stop(HttpHeaderParse);
@@ -681,26 +525,23 @@ HttpHeader::getEntry(HttpHeaderPos * pos) const
 HttpHeaderEntry *
 HttpHeader::findEntry(Http::HdrType id) const
 {
-    HttpHeaderPos pos = HttpHeaderInitPos;
-    HttpHeaderEntry *e;
     assert(any_registered_header(id));
-    assert(!CBIT_TEST(ListHeadersMask, id));
+    assert(!Http::HeaderLookupTable.lookup(id).list);
 
     /* check mask first */
 
     if (!CBIT_TEST(mask, id))
         return NULL;
 
     /* looks like we must have it, do linear search */
-    while ((e = getEntry(&pos))) {
-        if (e->id == id)
+    for (auto e : entries) {
+        if (e && e->id == id)
             return e;
     }
 
     /* hm.. we thought it was there, but it was not found */
-    assert(0);
-
-    return NULL;        /* not reached */
+    assert(false);
+    return nullptr;        /* not reached */
 }
 
 /*
@@ -709,25 +550,21 @@ HttpHeader::findEntry(Http::HdrType id) const
 HttpHeaderEntry *
 HttpHeader::findLastEntry(Http::HdrType id) const
 {
-    HttpHeaderPos pos = HttpHeaderInitPos;
-    HttpHeaderEntry *e;
-    HttpHeaderEntry *result = NULL;
     assert(any_registered_header(id));
-    assert(!CBIT_TEST(ListHeadersMask, id));
+    assert(!Http::HeaderLookupTable.lookup(id).list);
 
     /* check mask first */
-
     if (!CBIT_TEST(mask, id))
         return NULL;
 
-    /* looks like we must have it, do linear search */
-    while ((e = getEntry(&pos))) {
-        if (e->id == id)
-            result = e;
+    for (auto e = entries.rbegin(); e != entries.rend(); ++e) {
+        if (*e && (*e)->id == id)
+            return *e;
     }
 
-    assert(result);     /* must be there! */
-    return result;
+    /* hm.. we thought it was there, but it was not found */
+    assert(false);
+    return nullptr; /* not reached */
 }
 
 /*
@@ -756,19 +593,23 @@ HttpHeader::delByName(const char *name)
 int
 HttpHeader::delById(Http::HdrType id)
 {
-    int count = 0;
-    HttpHeaderPos pos = HttpHeaderInitPos;
-    HttpHeaderEntry *e;
     debugs(55, 8, this << " del-by-id " << id);
     assert(any_registered_header(id));
+    int count=0;
 
     if (!CBIT_TEST(mask, id))
         return 0;
 
-    while ((e = getEntry(&pos))) {
-        if (e->id == id)
-            delAt(pos, count);
-    }
+    //replace matching items with nil and count them
+    std::replace_if(entries.begin(), entries.end(),
+    [&](const HttpHeaderEntry *e) {
+        if (e && e->id == id) {
+            ++count;
+            return true;
+        }
+        return false;
+    },
+    nullptr);
 
     CBIT_CLR(mask, id);
     assert(count);
@@ -802,9 +643,8 @@ void
 HttpHeader::compact()
 {
     // TODO: optimize removal, or possibly make it so that's not needed.
-    std::vector<HttpHeaderEntry *>::iterator newend;
-    newend = std::remove(entries.begin(), entries.end(), static_cast<HttpHeaderEntry *>(NULL));
-    entries.resize(newend-entries.begin());
+    entries.erase( std::remove(entries.begin(), entries.end(), nullptr),
+                   entries.end());
 }
 
 /*
@@ -815,9 +655,9 @@ HttpHeader::refreshMask()
 {
     httpHeaderMaskInit(&mask, 0);
     debugs(55, 7, "refreshing the mask in hdr " << this);
-    HttpHeaderPos pos = HttpHeaderInitPos;
-    while (HttpHeaderEntry *e = getEntry(&pos)) {
-        CBIT_SET(mask, e->id);
+    for (auto e : entries) {
+        if (e)
+            CBIT_SET(mask, e->id);
     }
 }
 
@@ -874,17 +714,15 @@ HttpHeader::insertEntry(HttpHeaderEntry * e)
 bool
 HttpHeader::getList(Http::HdrType id, String *s) const
 {
-    HttpHeaderEntry *e;
-    HttpHeaderPos pos = HttpHeaderInitPos;
     debugs(55, 9, this << " joining for id " << id);
     /* only fields from ListHeaders array can be "listed" */
-    assert(CBIT_TEST(ListHeadersMask, id));
+    assert(Http::HeaderLookupTable.lookup(id).list);
 
     if (!CBIT_TEST(mask, id))
         return false;
 
-    while ((e = getEntry(&pos))) {
-        if (e->id == id)
+    for (auto e: entries) {
+        if (e && e->id == id)
             strListAdd(s, e->value.termedBuf(), ',');
     }
 
@@ -895,7 +733,7 @@ HttpHeader::getList(Http::HdrType id, String *s) const
      */
     /* temporary warning: remove it? (Is it useful for diagnostics ?) */
     if (!s->size())
-        debugs(55, 3, "empty list header: " << Http::HeaderTable[id].name << "(" << id << ")");
+        debugs(55, 3, "empty list header: " << Http::HeaderLookupTable.lookup(id).name << "(" << id << ")");
     else
         debugs(55, 6, this << ": joined for id " << id << ": " << s);
 
@@ -910,7 +748,7 @@ HttpHeader::getList(Http::HdrType id) const
     HttpHeaderPos pos = HttpHeaderInitPos;
     debugs(55, 9, this << "joining for id " << id);
     /* only fields from ListHeaders array can be "listed" */
-    assert(CBIT_TEST(ListHeadersMask, id));
+    assert(Http::HeaderLookupTable.lookup(id).list);
 
     if (!CBIT_TEST(mask, id))
         return String();
@@ -929,7 +767,7 @@ HttpHeader::getList(Http::HdrType id) const
      */
     /* temporary warning: remove it? (Is it useful for diagnostics ?) */
     if (!s.size())
-        debugs(55, 3, "empty list header: " << Http::HeaderTable[id].name << "(" << id << ")");
+        debugs(55, 3, "empty list header: " << Http::HeaderLookupTable.lookup(id).name << "(" << id << ")");
     else
         debugs(55, 6, this << ": joined for id " << id << ": " << s);
 
@@ -942,7 +780,7 @@ HttpHeader::getStrOrList(Http::HdrType id) const
 {
     HttpHeaderEntry *e;
 
-    if (CBIT_TEST(ListHeadersMask, id))
+    if (Http::HeaderLookupTable.lookup(id).list)
         return getList(id);
 
     if ((e = findEntry(id)))
@@ -956,15 +794,49 @@ HttpHeader::getStrOrList(Http::HdrType id) const
  */
 String
 HttpHeader::getByName(const char *name) const
+{
+    String result;
+    // ignore presence: return undefined string if an empty header is present
+    (void)getByNameIfPresent(name, strlen(name), result);
+    return result;
+}
+
+String
+HttpHeader::getByName(const SBuf &name) const
 {
     String result;
     // ignore presence: return undefined string if an empty header is present
     (void)getByNameIfPresent(name, result);
     return result;
 }
 
+String
+HttpHeader::getById(Http::HdrType id) const
+{
+    String result;
+    (void)getByIdIfPresent(id,result);
+    return result;
+}
+
+bool
+HttpHeader::getByNameIfPresent(const SBuf &s, String &result) const
+{
+    return getByNameIfPresent(s.rawContent(), s.length(), result);
+}
+
+bool
+HttpHeader::getByIdIfPresent(Http::HdrType id, String &result) const
+{
+    if (id == Http::HdrType::BAD_HDR)
+        return false;
+    if (!has(id))
+        return false;
+    result = getStrOrList(id);
+    return true;
+}
+
 bool
-HttpHeader::getByNameIfPresent(const char *name, String &result) const
+HttpHeader::getByNameIfPresent(const char *name, int namelen, String &result) const
 {
     Http::HdrType id;
     HttpHeaderPos pos = HttpHeaderInitPos;
@@ -973,13 +845,11 @@ HttpHeader::getByNameIfPresent(const char *name, String &result) const
     assert(name);
 
     /* First try the quick path */
-    id = Http::HeaderLookupTable.lookup(SBuf(name));
+    id = Http::HeaderLookupTable.lookup(name,namelen).id;
 
     if (id != Http::HdrType::BAD_HDR) {
-        if (!has(id))
-            return false;
-        result = getStrOrList(id);
-        return true;
+        if (getByIdIfPresent(id, result))
+            return true;
     }
 
     /* Sorry, an unknown header name. Do linear search */
@@ -1063,7 +933,7 @@ void
 HttpHeader::putInt(Http::HdrType id, int number)
 {
     assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftInt);  /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftInt);  /* must be of an appropriate type */
     assert(number >= 0);
     addEntry(new HttpHeaderEntry(id, NULL, xitoa(number)));
 }
@@ -1072,7 +942,7 @@ void
 HttpHeader::putInt64(Http::HdrType id, int64_t number)
 {
     assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftInt64);    /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftInt64);    /* must be of an appropriate type */
     assert(number >= 0);
     addEntry(new HttpHeaderEntry(id, NULL, xint64toa(number)));
 }
@@ -1081,25 +951,16 @@ void
 HttpHeader::putTime(Http::HdrType id, time_t htime)
 {
     assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftDate_1123);    /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftDate_1123);    /* must be of an appropriate type */
     assert(htime >= 0);
     addEntry(new HttpHeaderEntry(id, NULL, mkrfc1123(htime)));
 }
 
-void
-HttpHeader::insertTime(Http::HdrType id, time_t htime)
-{
-    assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftDate_1123);    /* must be of an appropriate type */
-    assert(htime >= 0);
-    insertEntry(new HttpHeaderEntry(id, NULL, mkrfc1123(htime)));
-}
-
 void
 HttpHeader::putStr(Http::HdrType id, const char *str)
 {
     assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftStr);  /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftStr);  /* must be of an appropriate type */
     assert(str);
     addEntry(new HttpHeaderEntry(id, NULL, str));
 }
@@ -1196,7 +1057,7 @@ int
 HttpHeader::getInt(Http::HdrType id) const
 {
     assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftInt);  /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftInt);  /* must be of an appropriate type */
     HttpHeaderEntry *e;
 
     if ((e = findEntry(id)))
@@ -1209,7 +1070,7 @@ int64_t
 HttpHeader::getInt64(Http::HdrType id) const
 {
     assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftInt64);    /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftInt64);    /* must be of an appropriate type */
     HttpHeaderEntry *e;
 
     if ((e = findEntry(id)))
@@ -1224,7 +1085,7 @@ HttpHeader::getTime(Http::HdrType id) const
     HttpHeaderEntry *e;
     time_t value = -1;
     assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftDate_1123);    /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftDate_1123);    /* must be of an appropriate type */
 
     if ((e = findEntry(id))) {
         value = parse_rfc1123(e->value.termedBuf());
@@ -1240,10 +1101,10 @@ HttpHeader::getStr(Http::HdrType id) const
 {
     HttpHeaderEntry *e;
     assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftStr);  /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftStr);  /* must be of an appropriate type */
 
     if ((e = findEntry(id))) {
-        httpHeaderNoteParsedEntry(e->id, e->value, 0);  /* no errors are possible */
+        httpHeaderNoteParsedEntry(e->id, e->value, false);  /* no errors are possible */
         return e->value.termedBuf();
     }
 
@@ -1256,10 +1117,10 @@ HttpHeader::getLastStr(Http::HdrType id) const
 {
     HttpHeaderEntry *e;
     assert(any_registered_header(id));
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftStr);  /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftStr);  /* must be of an appropriate type */
 
     if ((e = findLastEntry(id))) {
-        httpHeaderNoteParsedEntry(e->id, e->value, 0);  /* no errors are possible */
+        httpHeaderNoteParsedEntry(e->id, e->value, false);  /* no errors are possible */
         return e->value.termedBuf();
     }
 
@@ -1394,7 +1255,7 @@ HttpHeader::getETag(Http::HdrType id) const
 {
     ETag etag = {NULL, -1};
     HttpHeaderEntry *e;
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftETag);     /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftETag);     /* must be of an appropriate type */
 
     if ((e = findEntry(id)))
         etagParseInit(&etag, e->value.termedBuf());
@@ -1407,7 +1268,7 @@ HttpHeader::getTimeOrTag(Http::HdrType id) const
 {
     TimeOrTag tot;
     HttpHeaderEntry *e;
-    assert(Http::HeaderTable[id].type == Http::HdrFieldType::ftDate_1123_or_ETag);    /* must be of an appropriate type */
+    assert(Http::HeaderLookupTable.lookup(id).type == Http::HdrFieldType::ftDate_1123_or_ETag);    /* must be of an appropriate type */
     memset(&tot, 0, sizeof(tot));
 
     if ((e = findEntry(id))) {
@@ -1439,7 +1300,7 @@ HttpHeaderEntry::HttpHeaderEntry(Http::HdrType anId, const char *aName, const ch
     id = anId;
 
     if (id != Http::HdrType::OTHER)
-        name = Http::HeaderTable[id].name;
+        name = Http::HeaderLookupTable.lookup(id).name;
     else
         name = aName;
 
@@ -1502,7 +1363,7 @@ HttpHeaderEntry::parse(const char *field_start, const char *field_end)
     debugs(55, 9, "parsing HttpHeaderEntry: near '" <<  getStringPrefix(field_start, field_end-field_start) << "'");
 
     /* is it a "known" field? */
-    Http::HdrType id = Http::HeaderLookupTable.lookup(SBuf(field_start,name_len));
+    Http::HdrType id = Http::HeaderLookupTable.lookup(field_start,name_len).id;
     debugs(55, 9, "got hdr-id=" << id);
 
     String name;
@@ -1516,7 +1377,7 @@ HttpHeaderEntry::parse(const char *field_start, const char *field_end)
     if (id == Http::HdrType::OTHER)
         name.limitInit(field_start, name_len);
     else
-        name = Http::HeaderTable[id].name;
+        name = Http::HeaderLookupTable.lookup(id).name;
 
     /* trim field value */
     while (value_start < field_end && xisspace(*value_start))
@@ -1567,7 +1428,7 @@ HttpHeaderEntry::getInt() const
 {
     int val = -1;
     int ok = httpHeaderParseInt(value.termedBuf(), &val);
-    httpHeaderNoteParsedEntry(id, value, !ok);
+    httpHeaderNoteParsedEntry(id, value, ok == 0);
     /* XXX: Should we check ok - ie
      * return ok ? -1 : value;
      */
@@ -1579,23 +1440,23 @@ HttpHeaderEntry::getInt64() const
 {
     int64_t val = -1;
     int ok = httpHeaderParseOffset(value.termedBuf(), &val);
-    httpHeaderNoteParsedEntry(id, value, !ok);
+    httpHeaderNoteParsedEntry(id, value, ok == 0);
     /* XXX: Should we check ok - ie
      * return ok ? -1 : value;
      */
     return val;
 }
 
 static void
-httpHeaderNoteParsedEntry(Http::HdrType id, String const &context, int error)
+httpHeaderNoteParsedEntry(Http::HdrType id, String const &context, bool error)
 {
     if (id != Http::HdrType::BAD_HDR)
         ++ headerStatsTable[id].parsCount;
 
     if (error) {
         if (id != Http::HdrType::BAD_HDR)
             ++ headerStatsTable[id].errCount;
-        debugs(55, 2, "cannot parse hdr field: '" << Http::HeaderTable[id].name << ": " << context << "'");
+        debugs(55, 2, "cannot parse hdr field: '" << Http::HeaderLookupTable.lookup(id).name << ": " << context << "'");
     }
 }
 
@@ -1612,7 +1473,7 @@ httpHeaderFieldStatDumper(StoreEntry * sentry, int, double val, double, int coun
 {
     const int id = static_cast<int>(val);
     const bool valid_id = Http::any_valid_header(static_cast<Http::HdrType>(id));
-    const char *name = valid_id ? Http::HeaderTable[id].name : "INVALID";
+    const char *name = valid_id ? Http::HeaderLookupTable.lookup(static_cast<Http::HdrType>(id)).name : "INVALID";
     int visible = count > 0;
     /* for entries with zero count, list only those that belong to current type of message */
 
@@ -1687,11 +1548,11 @@ httpHeaderStoreReport(StoreEntry * e)
                       "id", "name", "#alive", "%err", "%repeat");
 
     // scan heaaderTable and output
-    for (int j = 0; Http::HeaderTable[j].name != nullptr; ++j) {
-        auto stats = headerStatsTable[j];
+    for (auto h : WholeEnum<Http::HdrType>()) {
+        auto stats = headerStatsTable[h];
         storeAppendPrintf(e, "%2d\t %-25s\t %5d\t %6.3f\t %6.3f\n",
-                          Http::HeaderTable[j].id,
-                          Http::HeaderTable[j].name,
+                          Http::HeaderLookupTable.lookup(h).id,
+                          Http::HeaderLookupTable.lookup(h).name,
                           stats.aliveCount,
                           xpercent(stats.errCount, stats.parsCount),
                           xpercent(stats.repCount, stats.seenCount));
@@ -1762,7 +1623,7 @@ HttpHeader::removeHopByHopEntries()
     int headers_deleted = 0;
     while ((e = getEntry(&pos))) {
         Http::HdrType id = e->id;
-        if (CBIT_TEST(HopByHopHeadersMask, id)) {
+        if (Http::HeaderLookupTable.lookup(id).hopbyhop) {
             delAt(pos, headers_deleted);
             CBIT_CLR(mask, id);
         }
@@ -83,7 +83,6 @@ class HttpHeader
     void append(const HttpHeader * src);
     void update (HttpHeader const *fresh, HttpHeaderMask const *denied_mask);
     void compact();
-    int reset();
     int parse(const char *header_start, size_t len);
     void packInto(Packable * p, bool mask_sensitive_info=false) const;
     HttpHeaderEntry *getEntry(HttpHeaderPos * pos) const;
@@ -96,17 +95,22 @@ class HttpHeader
     void insertEntry(HttpHeaderEntry * e);
     String getList(Http::HdrType id) const;
     bool getList(Http::HdrType id, String *s) const;
+    bool conflictingContentLength() const { return conflictingContentLength_; }
     String getStrOrList(Http::HdrType id) const;
+    String getByName(const SBuf &name) const;
     String getByName(const char *name) const;
+    String getById(Http::HdrType id) const;
+    /// sets value and returns true iff a [possibly empty] field identified by id is there
+    bool getByIdIfPresent(Http::HdrType id, String &result) const;
     /// sets value and returns true iff a [possibly empty] named field is there
-    bool getByNameIfPresent(const char *name, String &value) const;
+    bool getByNameIfPresent(const SBuf &s, String &value) const;
+    bool getByNameIfPresent(const char *name, int namelen, String &value) const;
     String getByNameListMember(const char *name, const char *member, const char separator) const;
     String getListMember(Http::HdrType id, const char *member, const char separator) const;
     int has(Http::HdrType id) const;
     void putInt(Http::HdrType id, int number);
     void putInt64(Http::HdrType id, int64_t number);
     void putTime(Http::HdrType id, time_t htime);
-    void insertTime(Http::HdrType id, time_t htime);
     void putStr(Http::HdrType id, const char *str);
     void putAuth(const char *auth_scheme, const char *realm);
     void putCc(const HttpHdrCc * cc);
@@ -144,15 +148,14 @@ class HttpHeader
 
 private:
     HttpHeaderEntry *findLastEntry(Http::HdrType id) const;
+    bool conflictingContentLength_; ///< found different Content-Length fields
 };
 
 int httpHeaderParseQuotedString(const char *start, const int len, String *val);
 
 /// quotes string using RFC 7230 quoted-string rules
 SBuf httpHeaderQuoteString(const char *raw);
 
-int httpHeaderHasByNameListMember(const HttpHeader * hdr, const char *name, const char *member, const char separator);
-void httpHeaderUpdate(HttpHeader * old, const HttpHeader * fresh, const HttpHeaderMask * denied_mask);
 void httpHeaderCalcMask(HttpHeaderMask * mask, Http::HdrType http_hdr_type_enums[], size_t count);
 
 inline bool
@@ -27,7 +27,7 @@ class HttpHeaderStat
         busyDestroyedCount(0)
     {
         hdrUCountDistr.enumInit(32);    /* not a real enum */
-        fieldTypeDistr.enumInit(Http::HdrType::ENUM_END);
+        fieldTypeDistr.enumInit(Http::HdrType::enumEnd_);
         ccTypeDistr.enumInit(HttpHdrCcType::CC_ENUM_END);
         scTypeDistr.enumInit(SC_ENUM_END);
     }
@@ -43,7 +43,7 @@ class HttpHeaderStat
     {
         assert(label);
         hdrUCountDistr.enumInit(32);    /* not a real enum */
-        fieldTypeDistr.enumInit(Http::HdrType::ENUM_END);
+        fieldTypeDistr.enumInit(Http::HdrType::enumEnd_);
         ccTypeDistr.enumInit(HttpHdrCcType::CC_ENUM_END);
         scTypeDistr.enumInit(SC_ENUM_END);
     }
@@ -11,6 +11,7 @@
 #include "squid.h"
 #include "acl/FilledChecklist.h"
 #include "acl/Gadgets.h"
+#include "base/EnumIterator.h"
 #include "client_side.h"
 #include "client_side_request.h"
 #include "comm/Connection.h"
@@ -45,21 +46,6 @@ httpHeaderMaskInit(HttpHeaderMask * mask, int value)
     memset(mask, value, sizeof(*mask));
 }
 
-/** calculates a bit mask of a given array; does not reset mask! */
-void
-httpHeaderCalcMask(HttpHeaderMask * mask, Http::HdrType http_hdr_type_enums[], size_t count)
-{
-    size_t i;
-    const int * enums = (const int *) http_hdr_type_enums;
-    assert(mask && enums);
-    assert(count < sizeof(*mask) * 8);  /* check for overflow */
-
-    for (i = 0; i < count; ++i) {
-        assert(!CBIT_TEST(*mask, enums[i]));    /* check for duplicates */
-        CBIT_SET(*mask, enums[i]);
-    }
-}
-
 /* same as httpHeaderPutStr, but formats the string using snprintf first */
 void
 httpHeaderPutStrf(HttpHeader * hdr, Http::HdrType id, const char *fmt,...)
@@ -155,9 +141,12 @@ httpHeaderParseOffset(const char *start, int64_t * value)
 {
     errno = 0;
     int64_t res = strtoll(start, NULL, 10);
-    if (!res && EINVAL == errno)    /* maybe not portable? */
+    if (!res && EINVAL == errno) {   /* maybe not portable? */
+        debugs(66, 7, "failed to parse offset in " << start);
         return 0;
+    }
     *value = res;
+    debugs(66, 7, "offset " << start << " parsed as " << res);
     return 1;
 }
 
@@ -295,29 +284,35 @@ httpHdrMangle(HttpHeaderEntry * e, HttpRequest * request, int req_or_rep)
     }
 
     /* manglers are not configured for this message kind */
-    if (!hms)
+    if (!hms) {
+        debugs(66, 7, "no manglers configured for message kind " << req_or_rep);
         return 1;
+    }
 
     const headerMangler *hm = hms->find(*e);
 
     /* mangler or checklist went away. default allow */
     if (!hm || !hm->access_list) {
+        debugs(66, 7, "couldn't find mangler or access list. Allowing");
         return 1;
     }
 
     ACLFilledChecklist checklist(hm->access_list, request, NULL);
 
     if (checklist.fastCheck() == ACCESS_ALLOWED) {
         /* aclCheckFast returns true for allow. */
+        debugs(66, 7, "checklist for mangler is positive. Mangle");
         retval = 1;
     } else if (NULL == hm->replacement) {
         /* It was denied, and we don't have any replacement */
+        debugs(66, 7, "checklist denied, we have no replacement. Pass");
         retval = 0;
     } else {
         /* It was denied, but we have a replacement. Replace the
          * header on the fly, and return that the new header
          * is allowed.
          */
+        debugs(66, 7, "checklist denied but we have replacement. Replace");
         e->value = hm->replacement;
         retval = 1;
     }
@@ -374,41 +369,36 @@ HeaderManglers::HeaderManglers()
 
 HeaderManglers::~HeaderManglers()
 {
-    for (int i = 0; i < Http::HdrType::ENUM_END; ++i)
+    for (auto i : WholeEnum<Http::HdrType>())
         header_mangler_clean(known[i]);
 
-    typedef ManglersByName::iterator MBNI;
-    for (MBNI i = custom.begin(); i != custom.end(); ++i)
-        header_mangler_clean(i->second);
+    for (auto i : custom)
+        header_mangler_clean(i.second);
 
     header_mangler_clean(all);
 }
 
 void
 HeaderManglers::dumpAccess(StoreEntry * entry, const char *name) const
 {
-    for (int i = 0; Http::HeaderTable[i].name != nullptr; ++i) {
-        header_mangler_dump_access(entry, name, known[i], Http::HeaderTable[i].name);
-    }
+    for (auto id : WholeEnum<Http::HdrType>())
+        header_mangler_dump_access(entry, name, known[id], Http::HeaderLookupTable.lookup(id).name);
 
-    typedef ManglersByName::const_iterator MBNCI;
-    for (MBNCI i = custom.begin(); i != custom.end(); ++i)
-        header_mangler_dump_access(entry, name, i->second, i->first.c_str());
+    for (auto i : custom)
+        header_mangler_dump_access(entry, name, i.second, i.first.c_str());
 
     header_mangler_dump_access(entry, name, all, "All");
 }
 
 void
 HeaderManglers::dumpReplacement(StoreEntry * entry, const char *name) const
 {
-    for (int i = 0; Http::HeaderTable[i].name != nullptr; ++i) {
-        header_mangler_dump_replacement(entry, name, known[i],Http::HeaderTable[i].name);
+    for (auto id : WholeEnum<Http::HdrType>()) {
+        header_mangler_dump_replacement(entry, name, known[id], Http::HeaderLookupTable.lookup(id).name);
     }
 
-    typedef ManglersByName::const_iterator MBNCI;
-    for (MBNCI i = custom.begin(); i != custom.end(); ++i) {
-        header_mangler_dump_replacement(entry, name, i->second,
-                                        i->first.c_str());
+    for (auto i: custom) {
+        header_mangler_dump_replacement(entry, name, i.second, i.first.c_str());
     }
 
     header_mangler_dump_replacement(entry, name, all, "All");
@@ -417,26 +407,18 @@ HeaderManglers::dumpReplacement(StoreEntry * entry, const char *name) const
 headerMangler *
 HeaderManglers::track(const char *name)
 {
-    Http::HdrType id = Http::HeaderLookupTable.lookup(SBuf(name));
+    if (strcmp(name, "All") == 0)
+        return &all;
 
-    if (id == Http::HdrType::BAD_HDR) { // special keyword or a custom header
-        if (strcmp(name, "All") == 0)
-            id = Http::HdrType::ENUM_END;
-        else if (strcmp(name, "Other") == 0)
-            id = Http::HdrType::OTHER;
-    }
+    const Http::HdrType id = Http::HeaderLookupTable.lookup(SBuf(name)).id;
 
-    headerMangler *m = NULL;
-    if (id == Http::HdrType::ENUM_END) {
-        m = &all;
-    } else if (id == Http::HdrType::BAD_HDR) {
-        m = &custom[name];
-    } else {
-        m = &known[id]; // including Http::HdrType::OTHER
-    }
+    if (id != Http::HdrType::BAD_HDR)
+        return &known[id];
+
+    if (strcmp(name, "Other") == 0)
+        return &known[Http::HdrType::OTHER];
 
-    assert(m);
-    return m;
+    return &custom[name];
 }
 
 void
@@ -12,7 +12,6 @@
 #include "acl/forward.h"
 #include "format/Format.h"
 #include "HttpHeader.h"
-#include "typedefs.h"
 
 #include <functional>
 #include <list>
@@ -74,7 +73,7 @@ class HeaderManglers
     typedef std::map<std::string, headerMangler, NoCaseLessThan> ManglersByName;
 
     /// one mangler for each known header
-    headerMangler known[static_cast<int>(Http::HdrType::ENUM_END)];
+    headerMangler known[static_cast<int>(Http::HdrType::enumEnd_)];
 
     /// one mangler for each custom header
     ManglersByName custom;
@@ -11,6 +11,7 @@
 
 #include "base/Lock.h"
 #include "BodyPipe.h"
+#include "enums.h"
 #include "http/forward.h"
 #include "http/ProtocolVersion.h"
 #include "http/StatusCode.h"
@@ -11,6 +11,7 @@
 #include "squid.h"
 #include "acl/AclSizeLimit.h"
 #include "acl/FilledChecklist.h"
+#include "base/EnumIterator.h"
 #include "globals.h"
 #include "HttpBody.h"
 #include "HttpHdrCc.h"
@@ -38,24 +39,23 @@
  * The list of headers we don't update is made up of:
  *     all hop-by-hop headers
  *     all entity-headers except Expires and Content-Location
+ *
+ * These headers are now stored in RegisteredHeadersHash.gperf and accessible
+ * as Http::HeaderLookupTable.lookup(id).denied304
  */
 static HttpHeaderMask Denied304HeadersMask;
-static Http::HdrType Denied304HeadersArr[] = {
-    // hop-by-hop headers
-    Http::HdrType::CONNECTION, Http::HdrType::KEEP_ALIVE, Http::HdrType::PROXY_AUTHENTICATE, Http::HdrType::PROXY_AUTHORIZATION,
-    Http::HdrType::TE, Http::HdrType::TRAILER, Http::HdrType::TRANSFER_ENCODING, Http::HdrType::UPGRADE,
-    // entity headers
-    Http::HdrType::ALLOW, Http::HdrType::CONTENT_ENCODING, Http::HdrType::CONTENT_LANGUAGE, Http::HdrType::CONTENT_LENGTH,
-    Http::HdrType::CONTENT_MD5, Http::HdrType::CONTENT_RANGE, Http::HdrType::CONTENT_TYPE, Http::HdrType::LAST_MODIFIED
-};
 
 /* module initialization */
 void
 httpReplyInitModule(void)
 {
     assert(Http::scNone == 0); // HttpReply::parse() interface assumes that
     httpHeaderMaskInit(&Denied304HeadersMask, 0);
-    httpHeaderCalcMask(&Denied304HeadersMask, Denied304HeadersArr, countof(Denied304HeadersArr));
+
+    for (auto id : WholeEnum<Http::HdrType>()) {
+        if (Http::HeaderLookupTable.lookup(id).denied304)
+            CBIT_SET(Denied304HeadersMask, id);
+    }
 }
 
 HttpReply::HttpReply() : HttpMsg(hoReply), date (0), last_modified (0),
@@ -151,9 +151,10 @@ HttpReply::make304() const
     /* rv->keep_alive */
     rv->sline.set(Http::ProtocolVersion(), Http::scNotModified, NULL);
 
-    for (t = 0; ImsEntries[t] != Http::HdrType::OTHER; ++t)
+    for (t = 0; ImsEntries[t] != Http::HdrType::OTHER; ++t) {
         if ((e = header.findEntry(ImsEntries[t])))
             rv->header.addEntry(e->clone());
+    }
 
     /* rv->body */
     return rv;
@@ -18,6 +18,7 @@
 #include "icp_opcode.h"
 #include "ip/Address.h"
 #include "LogTags.h"
+#include "store_key_md5.h"
 #include "StoreClient.h"
 
 class HttpRequest;
@@ -59,14 +60,6 @@ typedef struct _icp_common_t icp_common_t;
 
 #ifdef __cplusplus
 
-/// \ingroup ServerProtocolICPAPI
-inline icp_opcode & operator++ (icp_opcode & aCode)
-{
-    int tmp = (int) aCode;
-    aCode = (icp_opcode) (++tmp);
-    return aCode;
-}
-
 /**
  \ingroup ServerProtocolICPAPI
  \todo mempool this
@@ -312,6 +312,7 @@ squid_SOURCES = \
 	filemap.cc \
 	fqdncache.h \
 	fqdncache.cc \
+	fs/forward.h \
 	FwdState.cc \
 	FwdState.h \
 	Generic.h \
@@ -420,6 +421,8 @@ squid_SOURCES = \
 	send-announce.h \
 	send-announce.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	SBufDetailedStats.cc \
 	SBufStatsAction.h \
@@ -521,7 +524,6 @@ EXTRA_squid_SOURCES = \
 noinst_HEADERS = \
 	client_side_request.cci \
 	MemBuf.h \
-	StoreEntryStream.h \
 	String.cci \
 	SquidString.h \
 	SquidTime.h
@@ -733,9 +735,7 @@ EXTRA_DIST = \
 	cf_gen_defines \
 	cf.data.pre \
 	cf.data.depend \
-	mk-globals-c.pl \
 	mk-globals-c.awk \
-	mk-string-arrays.pl \
 	mk-string-arrays.awk \
 	repl_modules.sh \
 	$(STUB_SOURCE) \
@@ -904,6 +904,7 @@ check_PROGRAMS+=\
 	tests/testCharacterSet \
 	tests/testDiskIO \
 	tests/testDns \
+	tests/testEnumIterator \
 	tests/testEvent \
 	tests/testEventLoop \
 	tests/test_http_range \
@@ -945,6 +946,7 @@ TESTS += $(check_PROGRAMS)
 #	X.h \
 #	X.cc
 #nodist_tests_testX_SOURCES=\
+#   tests/stubs_as_needed.cc\
 #	$(TESTSOURCES)
 #tests_testX_LDFLAGS = $(LIBADD_DL)
 #tests_testX_LDADD=\
@@ -997,6 +999,8 @@ tests_testHttpReply_SOURCES=\
 	SquidString.h \
 	SquidTime.h \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	String.cc \
@@ -1109,6 +1113,8 @@ tests_testACLMaxUserIP_SOURCES= \
 	tests/stub_StatHist.cc \
 	stmem.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	String.cc \
@@ -1142,6 +1148,7 @@ tests_testACLMaxUserIP_SOURCES= \
 	tests/stub_libcomm.cc \
 	tests/stub_libdiskio.cc \
 	tests/stub_libformat.cc \
+	tests/stub_libmem.cc \
 	tests/stub_libsslsquid.cc \
 	tests/stub_MemObject.cc \
 	tests/stub_MemStore.cc \
@@ -1165,7 +1172,6 @@ tests_testACLMaxUserIP_SOURCES= \
 	tests/stub_time.cc \
 	url.cc \
 	URL.h \
-	tests/stub_libmem.cc \
 	MemBuf.cc \
 	wordlist.h \
 	wordlist.cc
@@ -1206,6 +1212,7 @@ tests_testBoilerplate_SOURCES = \
 	tests/testBoilerplate.cc \
 	tests/testBoilerplate.h \
 	tests/stub_debug.cc \
+	tests/stub_libmem.cc \
 	tests/stub_time.cc
 nodist_tests_testBoilerplate_SOURCES = \
 	tests/stub_cbdata.cc \
@@ -1230,6 +1237,7 @@ nodist_tests_testCharacterSet_SOURCES = \
 	$(TESTSOURCES) \
 	tests/stub_cbdata.cc \
 	tests/stub_debug.cc \
+	tests/stub_libmem.cc \
 	tests/stub_MemBuf.cc
 tests_testCharacterSet_LDFLAGS = $(LIBADD_DL)
 tests_testCharacterSet_LDADD= \
@@ -1304,6 +1312,7 @@ tests_testCacheManager_SOURCES = \
 	filemap.cc \
 	fqdncache.h \
 	fqdncache.cc \
+	fs/forward.h \
 	FwdState.cc \
 	FwdState.h \
 	gopher.h \
@@ -1375,6 +1384,8 @@ tests_testCacheManager_SOURCES = \
 	refresh.cc \
 	RemovalPolicy.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
@@ -1505,6 +1516,7 @@ tests_testDiskIO_SOURCES = \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
+	fs/forward.h \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpHeaderFieldStat.h \
@@ -1546,6 +1558,8 @@ tests_testDiskIO_SOURCES = \
 	tests/stub_StatHist.cc \
 	stmem.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	StoreFileSystem.cc \
@@ -1665,6 +1679,7 @@ tests_testDns_SOURCES= \
 	tests/testRFC1035.h
 nodist_tests_testDns_SOURCES= \
 	tests/stub_debug.cc \
+	tests/stub_libmem.cc \
 	tests/stub_SBuf.cc \
 	tests/stub_tools.cc
 tests_testDns_LDADD= \
@@ -1733,6 +1748,7 @@ tests_testEvent_SOURCES = \
 	filemap.cc \
 	fqdncache.h \
 	fqdncache.cc \
+	fs/forward.h \
 	FwdState.cc \
 	FwdState.h \
 	gopher.h \
@@ -1809,6 +1825,8 @@ tests_testEvent_SOURCES = \
 	StrList.h \
 	StrList.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
@@ -1976,6 +1994,7 @@ tests_testEventLoop_SOURCES = \
 	filemap.cc \
 	fqdncache.h \
 	fqdncache.cc \
+	fs/forward.h \
 	FwdState.cc \
 	FwdState.h \
 	gopher.h \
@@ -2049,6 +2068,8 @@ tests_testEventLoop_SOURCES = \
 	refresh.h \
 	refresh.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
@@ -2214,6 +2235,7 @@ tests_test_http_range_SOURCES = \
 	filemap.cc \
 	fqdncache.h \
 	fqdncache.cc \
+	fs/forward.h \
 	FwdState.cc \
 	FwdState.h \
 	gopher.h \
@@ -2287,6 +2309,8 @@ tests_test_http_range_SOURCES = \
 	refresh.cc \
 	RemovalPolicy.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
@@ -2427,13 +2451,14 @@ tests_testHttp1Parser_SOURCES = \
 	MemBuf.cc \
 	MemBuf.h \
 	tests/stub_MemObject.cc \
-	tests/stub_libmem.cc \
 	mime_header.cc \
 	mime_header.h \
 	String.cc \
 	cache_cf.h \
 	YesNoNone.h \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	tests/stub_SBufDetailedStats.cc \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
@@ -2442,6 +2467,7 @@ tests_testHttp1Parser_SOURCES = \
 	tests/stub_debug.cc \
 	tests/stub_event.cc \
 	tests/stub_HelperChildConfig.cc \
+	tests/stub_libmem.cc \
 	tests/stub_libsecurity.cc \
 	tests/stub_stmem.cc \
 	tests/stub_store.cc \
@@ -2464,6 +2490,7 @@ tests_testHttp1Parser_LDADD= \
 	ip/libip.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(SQUID_CPPUNIT_LIBS) \
+	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testHttp1Parser_LDFLAGS = $(LIBADD_DL)
@@ -2538,6 +2565,7 @@ tests_testHttpRequest_SOURCES = \
 	fde.cc \
 	fqdncache.h \
 	fqdncache.cc \
+	fs/forward.h \
 	FwdState.cc \
 	FwdState.h \
 	gopher.h \
@@ -2609,6 +2637,8 @@ tests_testHttpRequest_SOURCES = \
 	refresh.cc \
 	RemovalPolicy.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
@@ -2720,6 +2750,7 @@ nodist_tests_testIcmp_SOURCES = \
 	icmp/Icmp.h \
 	SquidTime.h \
 	tests/stub_debug.cc \
+	tests/stub_libmem.cc \
 	time.cc \
 	globals.cc
 tests_testIcmp_LDFLAGS = $(LIBADD_DL)
@@ -2739,6 +2770,7 @@ tests_testIpAddress_SOURCES= \
 nodist_tests_testIpAddress_SOURCES= \
 	ip/Address.h \
 	tests/stub_debug.cc \
+	tests/stub_libmem.cc \
 	tests/stub_tools.cc
 tests_testIpAddress_LDADD= \
 	ip/libip.la \
@@ -2769,6 +2801,7 @@ tests_testStore_SOURCES= \
 	tests/stub_fatal.cc \
 	FileMap.h \
 	filemap.cc \
+	fs/forward.h \
 	HttpHeaderFieldStat.h \
 	HttpHdrCc.h \
 	HttpHdrCc.cc \
@@ -2817,6 +2850,8 @@ tests_testStore_SOURCES= \
 	store_key_md5.h \
 	store_key_md5.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	String.cc \
@@ -2866,10 +2901,10 @@ tests_testStore_SOURCES= \
 	Transients.cc \
 	tests/stub_tools.cc \
 	tests/stub_UdsOp.cc \
+	tests/testPackableStream.cc \
+	tests/testPackableStream.h \
 	tests/testStore.cc \
 	tests/testStore.h \
-	tests/testStoreEntryStream.cc \
-	tests/testStoreEntryStream.h \
 	tests/testStoreController.cc \
 	tests/testStoreController.h \
 	tests/testStoreHashIndex.cc \
@@ -2925,7 +2960,6 @@ tests_testStore_DEPENDENCIES = \
 ## libsquid pulls in SquidConfig and children. stub them.
 tests_testString_SOURCES = \
 	ClientInfo.h \
-	tests/stub_libmem.cc \
 	MemBuf.cc \
 	String.cc \
 	$(SBUF_SOURCE) \
@@ -2940,6 +2974,7 @@ tests_testString_SOURCES = \
 	tests/stub_cbdata.cc \
 	tests/stub_debug.cc \
 	tests/stub_HelperChildConfig.cc \
+	tests/stub_libmem.cc \
 	tools.h \
 	tests/stub_tools.cc \
 	tests/stub_time.cc \
@@ -3013,6 +3048,7 @@ tests_testUfs_SOURCES = \
 	disk.cc \
 	FileMap.h \
 	filemap.cc \
+	fs/forward.h \
 	HttpBody.h \
 	HttpBody.cc \
 	HttpReply.cc \
@@ -3061,6 +3097,8 @@ tests_testUfs_SOURCES = \
 	tests/stub_helper.cc \
 	cbdata.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	String.cc \
@@ -3158,6 +3196,7 @@ testRefCount_SOURCES= \
 	base/RefCount.h \
 	tests/stub_cbdata.cc \
 	tests/stub_debug.cc \
+	tests/stub_libmem.cc \
 	tests/stub_MemBuf.cc \
 	tests/testRefCount.cc
 testRefCount_LDADD = \
@@ -3187,6 +3226,7 @@ tests_testRock_SOURCES = \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
+	fs/forward.h \
 	HttpHeaderFieldStat.h \
 	HttpBody.h \
 	HttpBody.cc \
@@ -3237,6 +3277,8 @@ tests_testRock_SOURCES = \
 	store_swapmeta.cc \
 	store_swapout.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	String.cc \
@@ -3381,6 +3423,7 @@ tests_testURL_SOURCES = \
 	filemap.cc \
 	fqdncache.h \
 	fqdncache.cc \
+	fs/forward.h \
 	FwdState.cc \
 	FwdState.h \
 	gopher.h \
@@ -3427,7 +3470,6 @@ tests_testURL_SOURCES = \
 	MasterXaction.h \
 	multicast.h \
 	multicast.cc \
-	tests/stub_libmem.cc \
 	mem_node.cc \
 	MemBuf.cc \
 	MemObject.cc \
@@ -3455,6 +3497,8 @@ tests_testURL_SOURCES = \
 	refresh.cc \
 	RemovalPolicy.cc \
 	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc \
 	SBufDetailedStats.h \
 	tests/stub_SBufDetailedStats.cc \
 	$(SNMP_SOURCE) \
@@ -3500,6 +3544,7 @@ tests_testURL_SOURCES = \
 	tests/stub_libauth_acls.cc \
 	tests/stub_libauth.cc \
 	tests/stub_libdiskio.cc \
+	tests/stub_libmem.cc \
 	tests/stub_libsecurity.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_ipc_Forwarder.cc \
@@ -3659,7 +3704,6 @@ tests_testSBufList_DEPENDENCIES= $(SQUID_CPPUNIT_LA)
 
 tests_testConfigParser_SOURCES = \
 	ClientInfo.h \
-	tests/stub_libmem.cc \
 	tests/stub_MemBuf.cc \
 	tests/stub_time.cc \
 	$(SBUF_SOURCE) \
@@ -3677,6 +3721,7 @@ tests_testConfigParser_SOURCES = \
 	tests/stub_cache_manager.cc \
 	tests/stub_cbdata.cc \
 	tests/stub_debug.cc \
+	tests/stub_libmem.cc \
 	tests/stub_HelperChildConfig.cc \
 	tools.h \
 	tests/stub_tools.cc \
@@ -3748,7 +3793,9 @@ tests_testLookupTable_SOURCES = \
 	tests/stub_SBufDetailedStats.cc \
 	base/LookupTable.h \
 	String.cc \
-	$(SBUF_SOURCE)
+	$(SBUF_SOURCE) \
+	SBufAlgos.h \
+	SBufAlgos.cc
 nodist_tests_testLookupTable_SOURCES = $(TESTSOURCES)
 tests_testLookupTable_LDFLAGS = $(LIBADD_DL)
 tests_testLookupTable_LDADD = \
@@ -3758,6 +3805,23 @@ tests_testLookupTable_LDADD = \
 	$(XTRA_LIBS)
 tests_testLookupTable_DEPENDENCIES = $(SQUID_CPPUNIT_LA)
 
+tests_testEnumIterator_SOURCES = \
+	base/EnumIterator.h \
+	tests/stub_debug.cc \
+	tests/stub_libmem.cc \
+	tests/testEnumIterator.h \
+	tests/testEnumIterator.cc
+nodist_tests_testEnumIterator_SOURCES = \
+	$(TESTSOURCES)
+tests_testEnumIterator_LDFLAGS = $(LIBADD_DL)
+tests_testEnumIterator_LDADD = \
+	base/libbase.la \
+	$(SQUID_CPPUNIT_LIBS) \
+	$(COMPAT_LIB) \
+	$(SQUID_CPPUNIT_LA) \
+	$(XTRA_LIBS)
+tests_testEnumIterator_DEPENDENCIES =
+
 TESTS += testHeaders
 
 ## Special Universal .h dependency test script
@@ -11,6 +11,10 @@
 
 #include "base/Packable.h"
 #include "cbdata.h"
+#include "mem/forward.h"
+
+/* in case we want to change it later */
+typedef ssize_t mb_size_t;
 
 /**
  * Auto-growing memory-resident buffer with Packable interface
@@ -96,16 +96,16 @@ MemObject::MemObject() :
     inmem_lo(0),
     nclients(0),
     smpCollapsed(false),
-    request(NULL),
-    ping_reply_callback(NULL),
-    ircb_data(NULL),
+    request(nullptr),
+    ping_reply_callback(nullptr),
+    ircb_data(nullptr),
     id(0),
     object_sz(-1),
     swap_hdr_sz(0),
 #if URL_CHECKSUM_DEBUG
     chksum(0),
 #endif
-    vary_headers(NULL)
+    vary_headers(nullptr)
 {
     debugs(20, 3, "new MemObject " << this);
     memset(&start_ping, 0, sizeof(start_ping));
@@ -16,12 +16,14 @@
 #include "stmem.h"
 #include "StoreIOBuffer.h"
 #include "StoreIOState.h"
+#include "typedefs.h" //for IRCB
 
 #if USE_DELAY_POOLS
 #include "DelayId.h"
 #endif
 
 typedef void STMCB (void *data, StoreIOBuffer wroteBuffer);
+typedef void STABH(void *);
 
 class store_client;
 class HttpRequest;
@@ -14,7 +14,6 @@
 #include "format/Format.h"
 #include "mem/forward.h"
 #include "SquidString.h"
-#include "typedefs.h"
 
 #include <string>
 #include <vector>
@@ -12,7 +12,6 @@
 #if USE_CACHE_DIGESTS
 
 #include "cbdata.h"
-/* for CacheDigestGuessStats */
 #include "StatCounters.h"
 
 class Version
@@ -106,7 +105,7 @@ class PeerDigest
 
         struct {
             int msgs;
-            kb_t kbytes;
+            ByteCounter kbytes;
         } sent, recv;
     } stats;
 };
@@ -62,12 +62,15 @@ xprof_move(xprof_stats_data * head, xprof_stats_data * hist)
 }
 
 static int
-xprof_comp(xprof_stats_node ** ii, xprof_stats_node ** jj)
+xprof_comp(const void *A, const void *B)
 {
-    if ((*ii)->hist.summ < (*jj)->hist.summ)
+    const xprof_stats_node *ii = *(static_cast<const xprof_stats_node * const *>(A));
+    const xprof_stats_node *jj = *(static_cast<const xprof_stats_node * const *>(B));
+
+    if (ii->hist.summ < jj->hist.summ)
         return (1);
 
-    if ((*ii)->hist.summ > (*jj)->hist.summ)
+    if (ii->hist.summ > jj->hist.summ)
         return (-1);
 
     return (0);
@@ -80,7 +83,7 @@ xprof_sorthist(TimersArray * xprof_list)
         sortlist[i] = xprof_list[i];
     }
 
-    qsort(&sortlist[XPROF_PROF_UNACCOUNTED+1], XPROF_LAST - XPROF_PROF_UNACCOUNTED+1, sizeof(xprof_stats_node *), (QS *) xprof_comp);
+    qsort(&sortlist[XPROF_PROF_UNACCOUNTED+1], XPROF_LAST - XPROF_PROF_UNACCOUNTED+1, sizeof(xprof_stats_node *), xprof_comp);
 }
 
 static double time_frame;
@@ -13,6 +13,8 @@
 
 class RemovalPolicyWalker;
 class RemovalPurgeWalker;
+class wordlist;
+class StoreEntry;
 
 class RemovalPolicySettings
 {
@@ -802,6 +802,48 @@ SBuf::findFirstNotOf(const CharacterSet &set, size_type startPos) const
     return npos;
 }
 
+SBuf::size_type
+SBuf::findLastOf(const CharacterSet &set, size_type endPos) const
+{
+    ++stats.find;
+
+    if (isEmpty())
+        return npos;
+
+    if (endPos == npos || endPos >= length())
+        endPos = length() - 1;
+
+    debugs(24, 7, "last of characterset " << set.name << " in id " << id);
+    const char *start = buf();
+    for (const char *cur = start + endPos; cur >= start; --cur) {
+        if (set[*cur])
+            return cur - start;
+    }
+    debugs(24, 7, "not found");
+    return npos;
+}
+
+SBuf::size_type
+SBuf::findLastNotOf(const CharacterSet &set, size_type endPos) const
+{
+    ++stats.find;
+
+    if (isEmpty())
+        return npos;
+
+    if (endPos == npos || endPos >= length())
+        endPos = length() - 1;
+
+    debugs(24, 7, "last not of characterset " << set.name << " in id " << id);
+    const char *start = buf();
+    for (const char *cur = start + endPos; cur >= start; --cur) {
+        if (!set[*cur])
+            return cur - start;
+    }
+    debugs(24, 7, "not found");
+    return npos;
+}
+
 /*
  * TODO: borrow a sscanf implementation from Linux or similar?
  * we'd really need a vsnscanf(3)... ? As an alternative, a
@@ -596,6 +596,16 @@ class SBuf
      */
     size_type findFirstOf(const CharacterSet &set, size_type startPos = 0) const;
 
+    /** Find last occurrence of character of set in SBuf
+     *
+     * Finds the last occurrence of ANY of the characters in the supplied set in
+     * the SBuf.
+     * \return npos if no character in the set could be found
+     * \param endPos if specified, ignore any occurrences after that position
+     *   if npos, the entire SBuf is searched
+     */
+    size_type findLastOf(const CharacterSet &set, size_type endPos = npos) const;
+
     /** Find first occurrence character NOT in character set
      *
      * \return npos if all characters in the SBuf are from set
@@ -606,6 +616,14 @@ class SBuf
      */
     size_type findFirstNotOf(const CharacterSet &set, size_type startPos = 0) const;
 
+    /** Find last occurrence character NOT in character set
+     *
+     * \return npos if all characters in the SBuf are from set
+     * \param endPos if specified, ignore any occurrences after that position
+     *   if npos, then the entire SBuf is searched
+     */
+    size_type findLastNotOf(const CharacterSet &set, size_type endPos = npos) const;
+
     /** sscanf-alike
      *
      * sscanf re-implementation. Non-const, and not \0-clean.
@@ -9,17 +9,31 @@
 #include "squid.h"
 #include "SBufAlgos.h"
 
-std::size_t std::hash<SBuf>::operator() (const SBuf & sbuf) const noexcept
+// private common implementation for SBuf hash variants
+static std::size_t
+SBufHashCommon_ (const SBuf & sbuf, bool caseInsensitive) noexcept
 {
     //ripped and adapted from hash_string
     const char *s = sbuf.rawContent();
     size_t rv = 0;
     SBuf::size_type len=sbuf.length();
     while (len != 0) {
-        rv ^= 271 * *s;
+        rv ^= 271 * (caseInsensitive? xtolower(*s) : *s);
         ++s;
         --len;
     }
     return rv ^ (sbuf.length() * 271);
 }
 
+std::size_t
+std::hash<SBuf>::operator() (const SBuf & sbuf) const noexcept
+{
+    return SBufHashCommon_(sbuf, false);
+}
+
+std::size_t
+CaseInsensitiveSBufHash::operator() (const SBuf & sbuf) const noexcept
+{
+    return SBufHashCommon_(sbuf, true);
+}
+
@@ -90,5 +90,18 @@ struct hash<SBuf>
 };
 }
 
+/** hash functor for SBufs, meant so support case-insensitive std::unordered_map
+ *
+ * Typical use:
+ * \code
+ * auto m = std::unordered_map<SBuf, ValueType, CaseInsensitiveSBufHash>();
+ * \endcode
+ */
+class CaseInsensitiveSBufHash
+{
+public:
+    std::size_t operator()(const SBuf &) const noexcept;
+};
+
 #endif /* SQUID_SBUFALGOS_H_ */
 
@@ -7,12 +7,12 @@
  */
 
 #include "squid.h"
+#include "base/PackableStream.h"
 #include "ipc/Messages.h"
 #include "ipc/TypedMsgHdr.h"
 #include "mgr/Registration.h"
 #include "SBufDetailedStats.h"
 #include "SBufStatsAction.h"
-#include "StoreEntryStream.h"
 
 SBufStatsAction::SBufStatsAction(const Mgr::CommandPointer &cmd_):
     Action(cmd_)
@@ -53,7 +53,7 @@ statHistSBufDumper(StoreEntry * sentry, int, double val, double size, int count)
 void
 SBufStatsAction::dump(StoreEntry* entry)
 {
-    StoreEntryStream ses(entry);
+    PackableStream ses(*entry);
     ses << "\n\n\nThese statistics are experimental; their format and contents "
         "should not be relied upon, they are bound to change as "
         "the SBuf feature is evolved\n";
@@ -18,6 +18,7 @@
 #include "ip/Address.h"
 #include "Notes.h"
 #include "security/forward.h"
+#include "SquidTime.h"
 #include "YesNoNone.h"
 
 #if USE_OPENSSL
@@ -29,6 +30,7 @@ namespace Mgr
 {
 class ActionPasswordList;
 } // namespace Mgr
+class CachePeer;
 class CustomLog;
 class CpuAffinityMap;
 class external_acl;
@@ -11,7 +11,6 @@
 #include "squid.h"
 #include "mem/forward.h"
 #include "SquidList.h"
-#include "typedefs.h"
 
 /* This should go away, in favour of the List template class */
 
@@ -16,6 +16,9 @@
 #include <ctime>
 /* NP: sys/time.h is provided by libcompat */
 
+/* Use uint64_t to store milliseconds */
+typedef uint64_t time_msec_t;
+
 /* globals for accessing time */
 extern struct timeval current_time;
 extern double current_dtime;
@@ -9,6 +9,7 @@
 #ifndef STATCOUNTERS_H_
 #define STATCOUNTERS_H_
 
+#include "base/ByteCounter.h"
 #include "StatHist.h"
 
 #if USE_CACHE_DIGESTS
@@ -39,9 +40,9 @@ class StatCounters
         int mem_hits;
         int disk_hits;
         int errors;
-        kb_t kbytes_in;
-        kb_t kbytes_out;
-        kb_t hit_kbytes_out;
+        ByteCounter kbytes_in;
+        ByteCounter kbytes_out;
+        ByteCounter hit_kbytes_out;
         StatHist missSvcTime;
         StatHist nearMissSvcTime;
         StatHist nearHitSvcTime;
@@ -54,8 +55,8 @@ class StatCounters
         struct {
             int requests;
             int errors;
-            kb_t kbytes_in;
-            kb_t kbytes_out;
+            ByteCounter kbytes_in;
+            ByteCounter kbytes_out;
         } all , http, ftp, other;
     } server;
 
@@ -70,12 +71,12 @@ class StatCounters
         int hits_recv;
         int replies_queued;
         int replies_dropped;
-        kb_t kbytes_sent;
-        kb_t q_kbytes_sent;
-        kb_t r_kbytes_sent;
-        kb_t kbytes_recv;
-        kb_t q_kbytes_recv;
-        kb_t r_kbytes_recv;
+        ByteCounter kbytes_sent;
+        ByteCounter q_kbytes_sent;
+        ByteCounter r_kbytes_sent;
+        ByteCounter kbytes_recv;
+        ByteCounter q_kbytes_recv;
+        ByteCounter r_kbytes_recv;
         StatHist querySvcTime;
         StatHist replySvcTime;
         int query_timeouts;
@@ -97,9 +98,9 @@ class StatCounters
 
     struct {
         int times_used;
-        kb_t kbytes_sent;
-        kb_t kbytes_recv;
-        kb_t memory;
+        ByteCounter kbytes_sent;
+        ByteCounter kbytes_recv;
+        ByteCounter memory;
         int msgs_sent;
         int msgs_recv;
 #if USE_CACHE_DIGESTS
@@ -20,6 +20,7 @@
 #include "MemObject.h"
 #include "Range.h"
 #include "RemovalPolicy.h"
+#include "store_key_md5.h"
 #include "StoreIOBuffer.h"
 #include "StoreStats.h"
 
@@ -43,6 +44,7 @@ enum { SwapFilenMax = 0xFFFFFF }; // keep in sync with StoreEntry::swap_filen
 
 class StoreEntry : public hash_link, public Packable
 {
+    MEMPROXY_CLASS(StoreEntry);
 
 public:
     static DeferredRead::DeferrableRead DeferReader;
@@ -66,6 +68,8 @@ class StoreEntry : public hash_link, public Packable
     }
     virtual bool isAccepting() const;
     virtual size_t bytesWanted(Range<size_t> const aRange, bool ignoreDelayPool = false) const;
+    /// flags [truncated or too big] entry with ENTRY_BAD_LENGTH and releases it
+    void lengthWentBad(const char *reason);
     virtual void complete();
     virtual store_client_t storeClientType() const;
     virtual char const *getSerialisedMetaData();
@@ -175,17 +179,11 @@ class StoreEntry : public hash_link, public Packable
         return false;
     };
 
-    void *operator new(size_t byteCount);
-    void operator delete(void *address);
     void setReleaseFlag();
 #if USE_SQUID_ESI
 
     ESIElement::Pointer cachedESITree;
 #endif
-    /** disable sending content to the clients */
-    virtual void buffer();
-    /** flush any buffered content */
-    virtual void flush();
     virtual int64_t objectLen() const;
     virtual int64_t contentLen() const;
 
@@ -215,6 +213,8 @@ class StoreEntry : public hash_link, public Packable
     /* Packable API */
     virtual void append(char const *, int);
     virtual void vappendf(const char *, va_list);
+    virtual void buffer();
+    virtual void flush();
 
 protected:
     void transientsAbandonmentCheck();
@@ -1,102 +0,0 @@
-/*
- * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-#ifndef SQUID_STORE_ENTRY_STREAM_H
-#define SQUID_STORE_ENTRY_STREAM_H
-
-#include "Store.h"
-
-#include <ostream>
-
-/*
- * This class provides a streambuf interface for writing
- * to StoreEntries. Typical use is via a StoreEntryStream
- * rather than direct manipulation
- */
-
-class StoreEntryStreamBuf : public std::streambuf
-{
-
-public:
-    StoreEntryStreamBuf(StoreEntry *anEntry) : theEntry(anEntry) {
-        theEntry->lock("StoreEntryStreamBuf");
-        theEntry->buffer();
-    }
-
-    ~StoreEntryStreamBuf() {
-        theEntry->unlock("StoreEntryStreamBuf");
-    }
-
-protected:
-    /* flush the current buffer and the character that is overflowing
-     * to the store entry.
-     */
-    virtual int_type overflow(int_type aChar = traits_type::eof()) {
-        std::streamsize pending(pptr() - pbase());
-
-        if (pending && sync ())
-            return traits_type::eof();
-
-        if (aChar != traits_type::eof()) {
-            // NP: cast because GCC promotes int_type to 32-bit type
-            //     std::basic_streambuf<char>::int_type {aka int}
-            //     despite the definition with 8-bit type value.
-            char chars[1] = {char(aChar)};
-
-            if (aChar != traits_type::eof())
-                theEntry->append(chars, 1);
-        }
-
-        pbump (-pending);  // Reset pptr().
-        return aChar;
-    }
-
-    /* push the buffer to the store */
-    virtual int sync() {
-        std::streamsize pending(pptr() - pbase());
-
-        if (pending)
-            theEntry->append(pbase(), pending);
-
-        theEntry->flush();
-
-        return 0;
-    }
-
-    /* write multiple characters to the store entry
-     * - this is an optimisation method.
-     */
-    virtual std::streamsize xsputn(const char * chars, std::streamsize number) {
-        if (number)
-            theEntry->append(chars, number);
-
-        return number;
-    }
-
-private:
-    StoreEntry *theEntry;
-
-};
-
-class StoreEntryStream : public std::ostream
-{
-
-public:
-    /* create a stream for writing text etc into theEntry */
-    // See http://www.codecomments.com/archive292-2005-2-396222.html
-    StoreEntryStream(StoreEntry *entry): std::ostream(0), theBuffer(entry) {
-        rdbuf(&theBuffer); // set the buffer to now-initialized theBuffer
-        clear(); //clear badbit set by calling init(0)
-    }
-
-private:
-    StoreEntryStreamBuf theBuffer;
-};
-
-#endif /* SQUID_STORE_ENTRY_STREAM_H */
-
@@ -11,6 +11,8 @@
 
 #include "base/RefCount.h"
 #include "cbdata.h"
+#include "fs/forward.h"
+#include "mem/forward.h"
 
 class StoreIOState : public RefCountable
 {
@@ -186,3 +186,17 @@ StoreMeta::checkConsistency(StoreEntry *) const
     return true;
 }
 
+StoreMeta::StoreMeta(const StoreMeta &s) :
+    length(s.length),
+    value(s.value),
+    next(s.next)
+{}
+
+StoreMeta& StoreMeta::operator=(const StoreMeta &s)
+{
+    length=s.length;
+    value=s.value;
+    next=s.next;
+    return *this;
+}
+
@@ -111,6 +111,11 @@ enum {
 /// \ingroup SwapStoreAPI
 class StoreMeta
 {
+protected:
+    StoreMeta() : length(-1), value(nullptr), next(nullptr) { }
+    StoreMeta(const StoreMeta &);
+    StoreMeta& operator=(const StoreMeta &);
+
 public:
     static bool validType(char);
     static int const MaximumTLVLength;
@@ -35,9 +35,9 @@
  *      the value for MemObject->swap_hdr_sz.
  */
 
+#include "fs/forward.h"
 #include "md5.h"
 #include "mem/forward.h"
-#include "typedefs.h"
 
 /// maintains a 24-bit checksum over integer fields
 class SwapChecksum24
@@ -24,6 +24,8 @@ class HttpRequestMethod;
 /* Store dir configuration routines */
 /* SwapDir *sd, char *path ( + char *opt later when the strtok mess is gone) */
 
+typedef int STDIRSELECT(const StoreEntry *);
+
 class ConfigOption;
 
 /// hides memory/disk cache distinction from callers
@@ -26,8 +26,8 @@ class URL
     MEMPROXY_CLASS(URL);
 
 public:
-    URL() : scheme_(), hostIsNumeric_(false), port_(0) {*host_=0;}
-    URL(AnyP::UriScheme const &aScheme) : scheme_(aScheme), hostIsNumeric_(false), port_(0) {*host_=0;}
+    URL() : hostIsNumeric_(false), port_(0) {*host_=0;}
+    URL(AnyP::UriScheme const &aScheme);
 
     void clear() {
         scheme_=AnyP::PROTO_NONE;
@@ -120,8 +120,17 @@ ACL::Factory (char const *type)
 }
 
 ACL::ACL() :
+    cfgline(nullptr),
+    next(nullptr),
+    registered(false)
+{
+    *name = 0;
+}
+
+ACL::ACL(const ACLFlag flgs[]) :
     cfgline(NULL),
     next(NULL),
+    flags(flgs),
     registered(false)
 {
     *name = 0;
@@ -337,9 +346,7 @@ ACL::cacheMatchAcl(dlink_list * cache, ACLChecklist *checklist)
         link = link->next;
     }
 
-    auth_match = new acl_proxy_auth_match_cache();
-    auth_match->matchrv = matchForCache (checklist);
-    auth_match->acl_data = this;
+    auth_match = new acl_proxy_auth_match_cache(matchForCache(checklist), this);
     dlinkAddTail(auth_match, &auth_match->link, cache);
     debugs(28, 4, "ACL::cacheMatchAcl: miss for '" << name << "'. Adding result " << auth_match->matchrv);
     return auth_match->matchrv;
@@ -80,9 +80,7 @@ class ACL
     static ACL *FindByName(const char *name);
 
     ACL();
-    explicit ACL(const ACLFlag flgs[]) : cfgline(NULL), next(NULL), flags(flgs), registered(false) {
-        *name = 0;
-    }
+    explicit ACL(const ACLFlag flgs[]);
     virtual ~ACL();
 
     /// sets user-specified ACL name and squid.conf context
@@ -168,7 +166,7 @@ class allow_t
 {
 public:
     // not explicit: allow "aclMatchCode to allow_t" conversions (for now)
-    allow_t(const aclMatchCode aCode): code(aCode), kind(0) {}
+    allow_t(const aclMatchCode aCode, int aKind = 0): code(aCode), kind(aKind) {}
 
     allow_t(): code(ACCESS_DUNNO), kind(0) {}
 
@@ -180,6 +178,10 @@ class allow_t
         return !(*this == aCode);
     }
 
+    bool operator ==(const allow_t allow) const {
+        return code == allow.code && kind == allow.kind;
+    }
+
     operator aclMatchCode() const {
         return code;
     }
@@ -214,6 +216,11 @@ class acl_proxy_auth_match_cache
     MEMPROXY_CLASS(acl_proxy_auth_match_cache);
 
 public:
+    acl_proxy_auth_match_cache(int matchRv, void * aclData) :
+        matchrv(matchRv),
+        acl_data(aclData)
+    {}
+
     dlink_node link;
     int matchrv;
     void *acl_data;
@@ -29,6 +29,7 @@ class ACLASN : public ACLData<Ip::Address>
     MEMPROXY_CLASS(ACLASN);
 
 public:
+    ACLASN() : data(nullptr) {}
     virtual ~ACLASN();
 
     virtual bool match(Ip::Address);
@@ -115,13 +115,21 @@ Acl::OrNode::clone() const
     return new OrNode;
 }
 
+bool
+Acl::OrNode::bannedAction(ACLChecklist *, Nodes::const_iterator) const
+{
+    return false;
+}
+
 int
 Acl::OrNode::doMatch(ACLChecklist *checklist, Nodes::const_iterator start) const
 {
     lastMatch_ = nodes.end();
 
     // find the first node that matches, but stop if things go wrong
     for (Nodes::const_iterator i = start; i != nodes.end(); ++i) {
+        if (bannedAction(checklist, i))
+            continue;
         if (checklist->matchChild(this, i, *i)) {
             lastMatch_ = i;
             return 1;
@@ -62,6 +62,10 @@ class OrNode: public InnerNode
     MEMPROXY_CLASS(OrNode);
 
 public:
+    /// whether the given rule should be excluded from matching tests based
+    /// on its action
+    virtual bool bannedAction(ACLChecklist *, Nodes::const_iterator) const;
+
     /* ACL API */
     virtual char const *typeString() const;
     virtual ACL *clone() const;
@@ -14,6 +14,8 @@
 #include "Debug.h"
 #include "profiler/Profiler.h"
 
+#include <algorithm>
+
 /// common parts of nonBlockingCheck() and resumeNonBlockingCheck()
 bool
 ACLChecklist::prepNonBlocking()
@@ -190,7 +192,7 @@ ACLChecklist::~ACLChecklist()
 {
     assert (!asyncInProgress());
 
-    cbdataReferenceDone(accessList);
+    changeAcl(nullptr);
 
     debugs(28, 4, "ACLChecklist::~ACLChecklist: destroyed " << this);
 }
@@ -312,9 +314,7 @@ ACLChecklist::fastCheck(const Acl::Tree * list)
 
     // Concurrent checks are not supported, but sequential checks are, and they
     // may use a mixture of fastCheck(void) and fastCheck(list) calls.
-    const Acl::Tree * const savedList = accessList;
-
-    accessList = cbdataReference(list);
+    const Acl::Tree * const savedList = changeAcl(list);
 
     // assume DENY/ALLOW on mis/matches due to action-free accessList
     // matchAndFinish() takes care of the ALLOW case
@@ -323,8 +323,7 @@ ACLChecklist::fastCheck(const Acl::Tree * list)
     if (!finished())
         markFinished(ACCESS_DENIED, "ACLs failed to match");
 
-    cbdataReferenceDone(accessList);
-    accessList = savedList;
+    changeAcl(savedList);
     occupied_ = false;
     PROF_stop(aclCheckFast);
     return currentAnswer();
@@ -391,3 +390,17 @@ ACLChecklist::callerGone()
     return !cbdataReferenceValid(callback_data);
 }
 
+bool
+ACLChecklist::bannedAction(const allow_t &action) const
+{
+    const bool found = std::find(bannedActions_.begin(), bannedActions_.end(), action) != bannedActions_.end();
+    debugs(28, 5, "Action '" << action << "/" << action.kind << (found ? " is " : "is not") << " banned");
+    return found;
+}
+
+void
+ACLChecklist::banAction(const allow_t &action)
+{
+    bannedActions_.push_back(action);
+}
+
@@ -11,6 +11,7 @@
 
 #include "acl/InnerNode.h"
 #include <stack>
+#include <vector>
 
 /// ACL checklist callback
 typedef void ACLCB(allow_t, void *);
@@ -152,13 +153,29 @@ class ACLChecklist
 
     const allow_t &currentAnswer() const { return allow_; }
 
+    /// whether the action is banned or not
+    bool bannedAction(const allow_t &action) const;
+    /// add action to the list of banned actions
+    void banAction(const allow_t &action);
+
     // XXX: ACLs that need request or reply have to use ACLFilledChecklist and
     // should do their own checks so that we do not have to povide these two
     // for ACL::checklistMatches to use
     virtual bool hasRequest() const = 0;
     virtual bool hasReply() const = 0;
     virtual bool hasAleXXX() const = 0;
 
+    /// change the current ACL list
+    /// \return a pointer to the old list value (may be nullptr)
+    const Acl::Tree *changeAcl(const Acl::Tree *t) {
+        const Acl::Tree *old = accessList;
+        if (t != accessList) {
+            cbdataReferenceDone(accessList);
+            accessList = cbdataReference(t);
+        }
+        return old;
+    }
+
 private:
     /// Calls non-blocking check callback with the answer and destroys self.
     void checkCallback(allow_t answer);
@@ -168,8 +185,8 @@ class ACLChecklist
     void changeState(AsyncState *);
     AsyncState *asyncState() const;
 
-public:
     const Acl::Tree *accessList;
+public:
 
     ACLCB *callback;
     void *callback_data;
@@ -218,6 +235,8 @@ class ACLChecklist
 
     /// suspended (due to an async lookup) matches() in the ACL tree
     std::stack<Breadcrumb> matchPath;
+    /// the list of actions which must ignored during acl checks
+    std::vector<allow_t> bannedActions_;
 };
 
 #endif /* SQUID_ACLCHECKLIST_H */
@@ -13,6 +13,7 @@
 #include "acl/Checklist.h"
 #include "acl/Data.h"
 #include "acl/Strategised.h"
+#include "dns/forward.h"
 
 /// \ingroup ACLAPI
 class ACLDestinationDomainStrategy : public ACLStrategy<char const *>
@@ -18,6 +18,7 @@ class ACLDomainData : public ACLData<char const *>
     MEMPROXY_CLASS(ACLDomainData);
 
 public:
+    ACLDomainData() : domains(nullptr) {}
     virtual ~ACLDomainData();
     virtual bool match(char const *);
     virtual SBufList dump() const;
@@ -158,9 +158,7 @@ ACLFilledChecklist::ACLFilledChecklist(const acl_access *A, HttpRequest *http_re
     dst_addr.setEmpty();
     rfc931[0] = '\0';
 
-    // cbdataReferenceDone() is in either fastCheck() or the destructor
-    if (A)
-        accessList = cbdataReference(A);
+    changeAcl(A);
 
     if (http_request != NULL) {
         request = http_request;
@@ -86,7 +86,7 @@ class ACLFilledChecklist: public ACLChecklist
     /// SSL [certificate validation] errors, in undefined order
     Ssl::CertErrors *sslErrors;
     /// The peer certificate
-    Ssl::X509_Pointer serverCert;
+    Security::CertPointer serverCert;
 #endif
 
     AccessLogEntry::Pointer al; ///< info for the future access.log, and external ACL
@@ -47,7 +47,7 @@ ACLHTTPHeaderData::match(HttpHeader* hdr)
             return false;
         value = hdr->getStrOrList(hdrId);
     } else {
-        if (!hdr->getByNameIfPresent(hdrName.termedBuf(), value))
+        if (!hdr->getByNameIfPresent(hdrName, value))
             return false;
     }
 
@@ -76,14 +76,14 @@ ACLHTTPHeaderData::parse()
     char* t = ConfigParser::strtokFile();
     assert (t != NULL);
     hdrName = t;
-    hdrId = Http::HeaderLookupTable.lookup(SBuf(hdrName));
+    hdrId = Http::HeaderLookupTable.lookup(hdrName).id;
     regex_rule->parse();
 }
 
 bool
 ACLHTTPHeaderData::empty() const
 {
-    return (hdrId == Http::HdrType::BAD_HDR && hdrName.size()==0) || regex_rule->empty();
+    return (hdrId == Http::HdrType::BAD_HDR && hdrName.isEmpty()) || regex_rule->empty();
 }
 
 ACLData<HttpHeader*> *
@@ -11,6 +11,7 @@
 
 #include "acl/Data.h"
 #include "HttpHeader.h"
+#include "SBuf.h"
 #include "SquidString.h"
 
 class ACLHTTPHeaderData : public ACLData<HttpHeader*>
@@ -27,8 +28,8 @@ class ACLHTTPHeaderData : public ACLData<HttpHeader*>
     virtual ACLData<HttpHeader*> *clone() const;
 
 private:
-    Http::HdrType hdrId;                /**< set if header is known */
-    String hdrName;                     /**< always set */
+    Http::HdrType hdrId;            /**< set if header is known */
+    SBuf hdrName;                   /**< always set */
     ACLData<char const *> * regex_rule;
 };
 
@@ -108,7 +108,7 @@ ACLRandom::match(ACLChecklist *)
     // actually matching whether the random value is above
     // or below the configured threshold ratio.
     static std::mt19937 mt;
-    static std::uniform_real_distribution<> dist(0, 1);
+    static xuniform_real_distribution<> dist(0, 1);
 
     const double random = dist(mt);
 
@@ -12,6 +12,7 @@
 #include "acl/Checklist.h"
 #include "acl/Data.h"
 #include "acl/Strategised.h"
+#include "dns/forward.h"
 
 class ACLSourceDomainStrategy : public ACLStrategy<char const *>
 {
@@ -7,6 +7,7 @@
  */
 
 #include "squid.h"
+#include "acl/Checklist.h"
 #include "acl/Tree.h"
 #include "wordlist.h"
 
@@ -85,3 +86,14 @@ Acl::Tree::treeDump(const char *prefix, const ActionToString &convert) const
     return text;
 }
 
+bool
+Acl::Tree::bannedAction(ACLChecklist *checklist, Nodes::const_iterator node) const
+{
+    if (actions.size()) {
+        assert(actions.size() == nodes.size());
+        const Nodes::size_type pos = node - nodes.begin();
+        return checklist->bannedAction(actions.at(pos));
+    }
+    return false;
+}
+
@@ -40,6 +40,8 @@ class Tree: public OrNode
     void add(ACL *rule); ///< same as InnerNode::add()
 
 protected:
+    /// Acl::OrNode API
+    virtual bool bannedAction(ACLChecklist *, Nodes::const_iterator) const override;
     allow_t actionAt(const Nodes::size_type pos) const;
 
     /// if not empty, contains actions corresponding to InnerNode::nodes
@@ -60,13 +60,8 @@ CaseInsensitveSBufCompare(const SBuf &lhs, const SBuf &rhs)
     return (lhs.caseCmp(rhs) < 0);
 }
 
-static bool
-CaseSensitveSBufCompare(const SBuf &lhs, const SBuf &rhs)
-{
-    return (lhs < rhs);
-}
-
-ACLUserData::ACLUserData() : userDataNames(CaseSensitveSBufCompare)
+ACLUserData::ACLUserData() :
+    userDataNames()
 {
     flags.case_insensitive = false;
     flags.required = false;
@@ -136,7 +136,6 @@ Adaptation::ServiceConfig::parse()
             tmp += "=";
             tmp += value;
             secure.parse(tmp.c_str());
-            secure.encryptTransport = true;
             grokked = true;
 #endif
         } else
@@ -353,7 +353,7 @@ Adaptation::Ecap::BodyRep::tie(const BodyPipe::Pointer &aBody)
 Adaptation::Ecap::BodyRep::BodySize
 Adaptation::Ecap::BodyRep::bodySize() const
 {
-    return !theBody ? BodySize() : BodySize(theBody->bodySize());
+    return (theBody != nullptr && theBody->bodySizeKnown()) ? BodySize(theBody->bodySize()) : BodySize();
 }
 
 /* MessageRep */
@@ -234,7 +234,7 @@ bool Adaptation::Ecap::ServiceRep::probed() const
 
 bool Adaptation::Ecap::ServiceRep::up() const
 {
-    return theService != NULL;
+    return theService;
 }
 
 bool Adaptation::Ecap::ServiceRep::wantsUrl(const SBuf &urlPath) const
@@ -72,7 +72,7 @@ void
 Adaptation::Ecap::XactionRep::master(const AdapterXaction &x)
 {
     Must(!theMaster);
-    Must(x != NULL);
+    Must(x);
     theMaster = x;
 }
 
@@ -259,7 +259,7 @@ Adaptation::Ecap::XactionRep::swanSong()
     // clear body_pipes, if any
     // this code does not maintain proxying* and canAccessVb states; should it?
 
-    if (theAnswerRep != NULL) {
+    if (theAnswerRep) {
         BodyPipe::Pointer body_pipe = answer().body_pipe;
         if (body_pipe != NULL) {
             Must(body_pipe->stillProducing(this));
@@ -318,7 +318,7 @@ Adaptation::Ecap::XactionRep::cause()
 libecap::Message &
 Adaptation::Ecap::XactionRep::adapted()
 {
-    Must(theAnswerRep != NULL);
+    Must(theAnswerRep);
     return *theAnswerRep;
 }
 
@@ -1342,12 +1342,12 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
     // we must forward "Proxy-Authenticate" and "Proxy-Authorization"
     // as ICAP headers.
     if (virgin.header->header.has(Http::HdrType::PROXY_AUTHENTICATE)) {
-        String vh=virgin.header->header.getByName("Proxy-Authenticate");
+        String vh=virgin.header->header.getById(Http::HdrType::PROXY_AUTHENTICATE);
         buf.appendf("Proxy-Authenticate: " SQUIDSTRINGPH "\r\n",SQUIDSTRINGPRINT(vh));
     }
 
     if (virgin.header->header.has(Http::HdrType::PROXY_AUTHORIZATION)) {
-        String vh=virgin.header->header.getByName("Proxy-Authorization");
+        String vh=virgin.header->header.getById(Http::HdrType::PROXY_AUTHORIZATION);
         buf.appendf("Proxy-Authorization: " SQUIDSTRINGPH "\r\n", SQUIDSTRINGPRINT(vh));
     } else if (request->extacl_user.size() > 0 && request->extacl_passwd.size() > 0) {
         struct base64_encode_ctx ctx;
@@ -57,7 +57,6 @@ AnyP::PortCfg::PortCfg() :
     certsToChain(),
     untrustedSigningCert(),
     untrustedSignPkey(),
-    clientVerifyCrls(),
     clientCA(),
     dhParams(),
     eecdhCurve(NULL)
@@ -150,9 +149,6 @@ AnyP::PortCfg::configureSslServerContext()
         fatalf("Unable to generate signing SSL certificate for untrusted sites for %s_port %s", AnyP::ProtocolType_str[transport.protocol], s.toUrl(buf, sizeof(buf)));
     }
 
-    if (!secure.crlFile.isEmpty())
-        clientVerifyCrls.reset(Ssl::loadCrl(secure.crlFile.c_str(), secure.parsedFlags));
-
     if (clientca) {
         clientCA.reset(SSL_load_client_CA_file(clientca));
         if (clientCA.get() == NULL) {
@@ -81,13 +81,12 @@ class PortCfg : public RefCountable
     size_t dynamicCertMemCacheSize; ///< max size of generated certificates memory cache
 
     Ssl::SSL_CTX_Pointer staticSslContext; ///< for HTTPS accelerator or static sslBump
-    Ssl::X509_Pointer signingCert; ///< x509 certificate for signing generated certificates
+    Security::CertPointer signingCert; ///< x509 certificate for signing generated certificates
     Ssl::EVP_PKEY_Pointer signPkey; ///< private key for sighing generated certificates
     Ssl::X509_STACK_Pointer certsToChain; ///<  x509 certificates to send with the generated cert
-    Ssl::X509_Pointer untrustedSigningCert; ///< x509 certificate for signing untrusted generated certificates
+    Security::CertPointer untrustedSigningCert; ///< x509 certificate for signing untrusted generated certificates
     Ssl::EVP_PKEY_Pointer untrustedSignPkey; ///< private key for signing untrusted generated certificates
 
-    Ssl::X509_CRL_STACK_Pointer clientVerifyCrls; ///< additional CRL lists to use when verifying the client certificate
     Ssl::X509_NAME_STACK_Pointer clientCA; ///< CA certificates to use when verifying client certificates
     Ssl::DH_Pointer dhParams; ///< DH parameters for temporary/ephemeral DH key exchanges
     char *eecdhCurve; ///< Elliptic curve for ephemeral EC-based DH key exchanges
@@ -25,9 +25,14 @@ ACLProxyAuth::~ACLProxyAuth()
     delete data;
 }
 
-ACLProxyAuth::ACLProxyAuth(ACLData<char const *> *newData, char const *theType) : data(newData), type_(theType) {}
+ACLProxyAuth::ACLProxyAuth(ACLData<char const *> *newData, char const *theType) :
+    data(newData),
+    type_(theType)
+{}
 
-ACLProxyAuth::ACLProxyAuth(ACLProxyAuth const &old) : data(old.data->clone()), type_(old.type_)
+ACLProxyAuth::ACLProxyAuth(ACLProxyAuth const &old) :
+    data(old.data->clone()),
+    type_(old.type_)
 {}
 
 ACLProxyAuth &
@@ -28,9 +28,8 @@ Auth::User::User(Auth::Config *aConfig, const char *aRequestRealm) :
     config(aConfig),
     ipcount(0),
     expiretime(0),
-    notes(),
     credentials_state(Auth::Unchecked),
-    username_(NULL),
+    username_(nullptr),
     requestRealm_(aRequestRealm)
 {
     proxy_match_cache.head = proxy_match_cache.tail = NULL;
@@ -481,11 +481,11 @@ Auth::UserRequest::addReplyAuthHeader(HttpReply * rep, Auth::UserRequest::Pointe
     default:
         /* Keep GCC happy */
         /* some other HTTP status */
-        type = Http::HdrType::ENUM_END;
+        type = Http::HdrType::BAD_HDR;
         break;
     }
 
-    debugs(29, 9, HERE << "headertype:" << type << " authuser:" << auth_user_request);
+    debugs(29, 9, "headertype:" << type << " authuser:" << auth_user_request);
 
     if (((rep->sline.status() == Http::scProxyAuthenticationRequired)
             || (rep->sline.status() == Http::scUnauthorized)) && internal)
@@ -159,7 +159,7 @@ authenticateDigestNonceNew(void)
     // NP: this will likely produce the same randomness sequences for each worker
     // since they should all start within the 1-second resolution of seed value.
     static std::mt19937 mt(static_cast<uint32_t>(getCurrentTime() & 0xFFFFFFFF));
-    static std::uniform_int_distribution<uint32_t> newRandomData;
+    static xuniform_int_distribution<uint32_t> newRandomData;
 
     /* create a new nonce */
     newnonce->nc = 0;
@@ -24,14 +24,13 @@
 #include "MemBuf.h"
 #include "SquidTime.h"
 
-Auth::Negotiate::UserRequest::UserRequest()
-{
-    waiting=0;
-    client_blob=0;
-    server_blob=0;
-    authserver=NULL;
-    request=NULL;
-}
+Auth::Negotiate::UserRequest::UserRequest() :
+    authserver(nullptr),
+    server_blob(nullptr),
+    client_blob(nullptr),
+    waiting(0),
+    request(nullptr)
+{}
 
 Auth::Negotiate::UserRequest::~UserRequest()
 {
@@ -23,14 +23,13 @@
 #include "MemBuf.h"
 #include "SquidTime.h"
 
-Auth::Ntlm::UserRequest::UserRequest()
-{
-    waiting=0;
-    client_blob=0;
-    server_blob=0;
-    authserver=NULL;
-    request=NULL;
-}
+Auth::Ntlm::UserRequest::UserRequest() :
+    authserver(nullptr),
+    server_blob(nullptr),
+    client_blob(nullptr),
+    waiting(0),
+    request(nullptr)
+{}
 
 Auth::Ntlm::UserRequest::~UserRequest()
 {
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_SRC_BYTECOUNTER_H
+#define SQUID_SRC_BYTECOUNTER_H
+
+/// counter for accumulating byte values
+class ByteCounter
+{
+public:
+    ByteCounter() : bytes(0), kb(0) {}
+
+    ByteCounter &operator +=(size_t v) {
+        bytes += v;
+        kb += (bytes >> 10);
+        bytes &= 0x3FF;
+        return *this;
+    }
+
+public:
+    size_t bytes;
+    size_t kb;
+};
+
+#endif /* SQUID_SRC_BYTECOUNTER_H */
+
@@ -0,0 +1,226 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_BASE_ENUMITERATOR_H
+#define SQUID_BASE_ENUMITERATOR_H
+
+#include <iterator>
+#include <type_traits>
+
+/** Shared functionality between forward and reverse enum iterators
+ *
+ * This class is not very useful by itself, it contains code shared by
+ * EnumIterator and ReverseEnumIterator.
+ *
+ * \see EnumIterator, ReverseEnumIterator
+ */
+template <typename EnumType>
+class EnumIteratorBase : public std::iterator<std::bidirectional_iterator_tag, EnumType>
+{
+protected:
+#if HAVE_STD_UNDERLYING_TYPE
+    typedef typename std::underlying_type<EnumType>::type iterator_type;
+#else
+    typedef int iterator_type;
+#endif
+
+public:
+    explicit EnumIteratorBase(EnumType e) : current(static_cast<iterator_type>(e)) {}
+
+    bool operator==(const EnumIteratorBase &i) const {
+        return current == i.current;
+    }
+
+    bool operator!=(const EnumIteratorBase &i) const {
+        return current != i.current;
+    }
+
+    EnumType operator*() const {
+        return static_cast<EnumType>(current);
+    }
+protected:
+    iterator_type current;
+};
+
+/** bidirectional iterator over an enum type
+ *
+ * It can be instantiated using any enum (or C++11 strongly-typed enum)
+ * value; the most common expected use scenario has iterators emitted by
+ * EnumRange and WholeEnum via standard begin() and end() calls.
+ *
+ * In order for the iterator to work, it is mandatory that the underlying
+ * enum type's representation values be sequential.
+ *
+ * The iterator does not check for bounds when incrementing or decrementing,
+ * that responsibility is left to the caller.
+ *
+ * \see EnumRange, WholeEnum, ReverseEnumIterator
+ */
+template <typename EnumType>
+class EnumIterator : public EnumIteratorBase<EnumType>
+{
+public:
+    explicit EnumIterator(EnumType e) : EnumIteratorBase<EnumType>(e) {}
+
+    EnumIterator& operator++() {
+        ++ EnumIteratorBase<EnumType>::current;
+        return *this;
+    }
+
+    EnumIterator& operator++(int) {
+        EnumIterator rv(*this);
+        ++ EnumIteratorBase<EnumType>::current;
+        return rv;
+    }
+
+    EnumIterator& operator--() {
+        -- EnumIteratorBase<EnumType>::current;
+        return *this;
+    }
+
+    EnumIterator& operator--(int) {
+        EnumIterator rv(*this);
+        -- EnumIteratorBase<EnumType>::current;
+        return rv;
+    }
+};
+
+/** bidirectional reverse iterator over an enum type
+ *
+ * It can be instantiated using any enum (or C++11 strongly-typed enum)
+ * value; the most common expected use scenario has iterators emitted by
+ * EnumRange and WholeEnum via standard rbegin() and rend() calls.
+ *
+ * In order for the iterator to work, it is mandatory that the underlying
+ * enum type's representation values be sequential.
+ *
+ * The iterator does not check for bounds; behavior is undefined if the iterator
+ * is incremented (or decremented) outside the range representing valid
+ * enum symbols (remember: an enum is not a data structure).
+ *
+ * \see EnumRange, WholeEnum, EnumIterator
+ */
+template <typename EnumType>
+class ReverseEnumIterator : public EnumIteratorBase<EnumType>
+{
+public:
+    explicit ReverseEnumIterator(EnumType e) : EnumIteratorBase<EnumType>(e) {}
+
+    // prefix increment
+    ReverseEnumIterator& operator++() {
+        -- EnumIteratorBase<EnumType>::current;
+        return *this;
+    }
+
+    // postfix increment
+    ReverseEnumIterator& operator++(int) {
+        ReverseEnumIterator rv(*this);
+        -- EnumIteratorBase<EnumType>::current;
+        return rv;
+    }
+
+    // prefix decrement
+    ReverseEnumIterator& operator--() {
+        ++ EnumIteratorBase<EnumType>::current;
+        return *this;
+    }
+
+    // postfix decrement
+    ReverseEnumIterator& operator--(int) {
+        ReverseEnumIterator rv(*this);
+        ++ EnumIteratorBase<EnumType>::current;
+        return rv;
+    }
+};
+
+/** Class expressing a continuous range of an enum for range-for expressions
+ *
+ * This class requires that the underlying enum values be represented by
+ * continuous values of an integral type.
+ * Users will usually not rely on this class directly but on the more convenient
+ * EnumRange function
+ *
+ * \note EnumIterator<enum>(EnumType::firstmember,EnumType::lastmember)
+ * will miss EnumType::lastmember while iterating. If you need to iterate
+ * over all of EnumType, use class WholeEnum.
+ *
+ * \see EnumRange, WholeEnum
+ */
+template <typename EnumType>
+class EnumRangeT
+{
+public:
+    typedef EnumIterator<EnumType> iterator;
+    typedef ReverseEnumIterator<EnumType> reverse_iterator;
+    EnumRangeT(EnumType first, EnumType one_past_last) : begin_(first), end_(one_past_last) { }
+    iterator begin() const { return iterator(begin_);}
+    iterator end() const { return iterator(end_);}
+    reverse_iterator rbegin() const { return ++reverse_iterator(end_); }
+    reverse_iterator rend() const { return ++reverse_iterator(begin_); }
+private:
+    EnumType begin_;
+    EnumType end_;
+};
+
+/** Generate a continuous range of an enum for range-for expressions
+ *
+ * convenience function to deduce the right type for instantiating EnumRangeT.
+ * See EnumRangeT for more detailed documentation and caveats.
+ *
+ * Typical use:
+ * \code
+ * enum class EnumType {
+ *   blue, red, yellow, green, pink
+ * };
+ * for (auto enumvalue : EnumRange(EnumType::red,EnumType::green)) {
+ *   do_stuff(enumvalue); // will be called twice, with arguments red and yellow
+ * }
+ * \endcode
+ */
+template <typename EnumType>
+EnumRangeT<EnumType> EnumRange(EnumType begin, EnumType one_past_end)
+{
+    return EnumRangeT<EnumType>(begin,one_past_end);
+}
+
+/** Class expressing a continuous range of a whole enum for range-for expressions
+ *
+ * Class for iterating all enum values, from EnumType::enumBegin_ up to, but
+ * not including, EnumType::enumEnd_.
+ *
+ * This class requires that:
+ * - the underlying enum values be represented by continuous values of
+ *   an integral type.
+ * - both enumBegin_ and enumEnd_ markers must be present as EnumType values;
+ * - enumBegin_ must have the same representation as the first element of the
+ *   enum
+ * - enumEnd_ must have a representation that is one past the last
+ *   user-accessible value of the enum.
+ *
+ * Typical use:
+ * \code
+ * enum class EnumType {
+ *   enumBegin_ = 0,
+ *   first_value = enumBegin_,
+ *   second_value,
+ *   enumEnd_
+ * };
+ * for(auto enumvalue : WholeEnum<EnumType>()) {
+ *   do_stuff();
+ * }
+ * \endcode
+ */
+template <typename EnumType>
+class WholeEnum : public EnumRangeT<EnumType>
+{
+public:
+    WholeEnum() : EnumRangeT<EnumType>(EnumType::enumBegin_, EnumType::enumEnd_) {}
+};
+
+#endif /* SQUID_BASE_ENUMITERATOR_H */
+
@@ -10,8 +10,9 @@
 #define SQUID_LOOKUPTABLE_H_
 
 #include "SBuf.h"
+#include "SBufAlgos.h"
 
-#include <map>
+#include <unordered_map>
 
 /**
  * a record in the initializer list for a LookupTable
@@ -53,7 +54,7 @@ class SBufCaseInsensitiveLess : public std::binary_function<SBuf, SBuf, bool> {
     }
 };
 
-template<typename EnumType, typename RecordType = LookupTableRecord<EnumType> >
+template<typename EnumType, typename RecordType = LookupTableRecord<EnumType>, typename Hasher = CaseInsensitiveSBufHash >
 class LookupTable
 {
 public:
@@ -76,7 +77,7 @@ class LookupTable
     }
 
 private:
-    typedef std::map<const SBuf, EnumType, SBufCaseInsensitiveLess> lookupTable_t;
+    typedef std::unordered_map<const SBuf, EnumType, Hasher> lookupTable_t;
     lookupTable_t lookupTable;
     EnumType invalidValue;
 };
@@ -19,15 +19,18 @@ libbase_la_SOURCES = \
 	AsyncJobCalls.h \
 	AsyncCallQueue.cc \
 	AsyncCallQueue.h \
+	ByteCounter.h \
 	CbcPointer.h \
 	CbDataList.h \
 	CharacterSet.h \
 	CharacterSet.cc \
+	EnumIterator.h \
 	InstanceId.h \
 	Lock.h \
 	LookupTable.h \
 	LruMap.h \
 	Packable.h \
+	PackableStream.h \
 	RegexPattern.cc \
 	RegexPattern.h \
 	RunnersRegistry.cc \
@@ -49,6 +49,8 @@
 class Packable
 {
 public:
+    virtual ~Packable() {}
+
     /// Appends a c-string to existing packed data.
     virtual void append(const char *buf, int size) = 0;
 
@@ -67,6 +69,21 @@ class Packable
      *       of side-effects
      */
     virtual void vappendf(const char *fmt, va_list ap) = 0;
+
+    /** start buffering appends (if relevant)
+     *
+     * Indicates that a number of small appends are about to
+     * follow so would be detrimental to trigger expensive
+     * activity on each.
+     */
+    virtual void buffer() {}
+
+    /** perform a buffer flush (if relevant)
+     *
+     * Used by code such as PackableStream, that assumes the
+     * Packable leads to some form of output buffer.
+     */
+    virtual void flush() {}
 };
 
 #endif /* SQUID_SRC_BASE_PACKABLE_H */
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_SRC_BASE_PACKABLESTREAM_H
+#define SQUID_SRC_BASE_PACKABLESTREAM_H
+
+#include "base/Packable.h"
+
+#include <ostream>
+
+/**
+ * Provides a streambuf interface for writing to Packable objects.
+ * Typical use is via a PackableStream rather than direct manipulation
+ */
+class PackableStreamBuf : public std::streambuf
+{
+public:
+    explicit PackableStreamBuf(Packable &p) : buf_(p) { buf_.buffer(); }
+    virtual ~PackableStreamBuf() = default;
+
+protected:
+    /** flush the current buffer and the character that is overflowing
+     * to the Packable.
+     */
+    virtual int_type overflow(int_type aChar = traits_type::eof()) override {
+        std::streamsize pending(pptr() - pbase());
+
+        if (pending && sync())
+            return traits_type::eof();
+
+        if (aChar != traits_type::eof()) {
+            const char C = static_cast<char>(aChar);
+            lowAppend(&C, 1);
+        }
+
+        pbump(-pending);  // Reset pptr().
+        return aChar;
+    }
+
+    /** push the buffer to the Packable */
+    virtual int sync() override {
+        std::streamsize pending(pptr() - pbase());
+        lowAppend(pbase(), pending);
+        buf_.flush();
+        return 0;
+    }
+
+    /** write multiple characters to the Packable
+     * - this is an optimisation method.
+     */
+    virtual std::streamsize xsputn(const char * chars, std::streamsize number) override {
+        lowAppend(chars, number);
+        return number;
+    }
+
+private:
+    void lowAppend(const char *s, const std::streamsize n) {buf_.append(s,n);}
+
+    Packable &buf_;
+};
+
+class PackableStream : public std::ostream
+{
+public:
+    /* create a stream for writing text etc into theBuffer */
+    // See http://www.codecomments.com/archive292-2005-2-396222.html
+    explicit PackableStream(Packable &p) : std::ostream(0), theBuffer(p) {
+        rdbuf(&theBuffer); // set the buffer to now-initialized theBuffer
+        clear(); //clear badbit set by calling init(0)
+    }
+
+private:
+    PackableStreamBuf theBuffer;
+};
+
+#endif /* SQUID_SRC_BASE_PACKABLESTREAM_H */
+
@@ -869,8 +869,11 @@ configDoConfigure(void)
         debugs(3, DBG_IMPORTANT, "Initializing https:// proxy context");
         Config.ssl_client.sslContext = Security::ProxyOutgoingConfig.createClientContext(false);
         if (!Config.ssl_client.sslContext) {
-            debugs(3, DBG_CRITICAL, "ERROR: Could not initialize https:// proxy context");
-            self_destruct();
+#if USE_OPENSSL
+            fatal("ERROR: Could not initialize https:// proxy context");
+#else
+            debugs(3, DBG_IMPORTANT, "ERROR: proxying https:// currently still requires --with-openssl");
+#endif
         }
     }
 
@@ -2193,11 +2196,9 @@ parse_peer(CachePeer ** head)
 #if !USE_OPENSSL
             debugs(0, DBG_CRITICAL, "WARNING: cache_peer option '" << token << "' requires --with-openssl");
 #else
-            p->secure.encryptTransport = true;
             p->secure.parse(token+3);
 #endif
         } else if (strncmp(token, "tls-", 4) == 0) {
-            p->secure.encryptTransport = true;
             p->secure.parse(token+4);
         } else if (strcmp(token, "front-end-https") == 0) {
             p->front_end_https = 1;
@@ -4608,7 +4609,7 @@ static void parse_HeaderWithAclList(HeaderWithAclList **headers)
     }
     HeaderWithAcl hwa;
     hwa.fieldName = fn;
-    hwa.fieldId = Http::HeaderLookupTable.lookup(SBuf(fn));
+    hwa.fieldId = Http::HeaderLookupTable.lookup(hwa.fieldName).id;
     if (hwa.fieldId == Http::HdrType::BAD_HDR)
         hwa.fieldId = Http::HdrType::OTHER;
 
@@ -500,7 +500,7 @@ cbdataDump(StoreEntry * sentry)
 #else
             int obj_size = pool->objectSize() - cbdata::Offset;
 #endif
-            storeAppendPrintf(sentry, "%s\t%d\t%ld\t%ld\n", pool->objectType() + 7, obj_size, (long int)pool->getMeter().inuse.level, (long int)obj_size * pool->getMeter().inuse.level);
+            storeAppendPrintf(sentry, "%s\t%d\t%ld\t%ld\n", pool->objectType() + 7, obj_size, (long int)pool->getMeter().inuse.currentLevel(), (long int)obj_size * pool->getMeter().inuse.currentLevel());
         }
     }
 
@@ -9,8 +9,6 @@
 #ifndef SQUID_SRC_CBDATA_H
 #define SQUID_SRC_CBDATA_H
 
-#include "typedefs.h"
-
 /**
 \page CBDATA Callback Data Allocator API
 
@@ -966,15 +966,17 @@ DOC_START
 	acl aclname localip ip-address/mask ... # IP address the client connected to [fast]
 
 	acl aclname arp      mac-address ... (xx:xx:xx:xx:xx:xx notation)
-	  # The arp ACL requires the special configure option --enable-arp-acl.
-	  # Furthermore, the ARP ACL code is not portable to all operating systems.
-	  # It works on Linux, Solaris, Windows, FreeBSD, and some
-	  # other *BSD variants.
 	  # [fast]
+	  # The 'arp' ACL code is not portable to all operating systems.
+	  # It works on Linux, Solaris, Windows, FreeBSD, and some other
+	  # BSD variants.
 	  #
-	  # NOTE: Squid can only determine the MAC address for clients that are on
-	  # the same subnet. If the client is on a different subnet,
-	  # then Squid cannot find out its MAC address.
+	  # NOTE: Squid can only determine the MAC/EUI address for IPv4
+	  # clients that are on the same subnet. If the client is on a
+	  # different subnet, then Squid cannot find out its address.
+	  #
+	  # NOTE 2: IPv6 protocol does not contain ARP. MAC/EUI is either
+	  # encoded directly in the IPv6 address or not available.
 
 	acl aclname srcdomain   .foo.com ...
 	  # reverse lookup, from client IP [slow]
@@ -1448,7 +1450,7 @@ DOC_START
 
 	SECURITY WARNING: Usage of this option is dangerous
 	and should not be used trivially. Correct configuration
-	of follow_x_forewarded_for with a limited set of trusted
+	of follow_x_forwarded_for with a limited set of trusted
 	sources is required to prevent abuse of your proxy.
 DOC_END
 
@@ -1647,7 +1649,7 @@ LOC: Config.accessList.miss
 DEFAULT: none
 DEFAULT_DOC: Allow, unless rules exist in squid.conf.
 DOC_START
-	Determins whether network access is permitted when satisfying a request.
+	Determines whether network access is permitted when satisfying a request.
 
 	For example;
 	    to force your neighbors to use you as a sibling instead of
@@ -1826,13 +1828,13 @@ DOC_START
 
 	Modes:
 
-	   intercept	Support for IP-Layer interception of
-			outgoing requests without browser settings.
-			NP: disables authentication and IPv6 on the port.
+	   intercept	Support for IP-Layer NAT interception delivering
+			traffic to this Squid port.
+			NP: disables authentication on the port.
 
-	   tproxy	Support Linux TPROXY for spoofing outgoing
-			connections using the client IP address.
-			NP: disables authentication and maybe IPv6 on the port.
+	   tproxy	Support Linux TPROXY (or BSD divert-to) with spoofing
+			of outgoing connections using the client IP address.
+			NP: disables authentication on the port.
 
 	   accel	Accelerator / reverse proxy mode
 
@@ -4004,18 +4006,26 @@ TYPE: int
 DEFAULT: 90
 LOC: Config.Swap.lowWaterMark
 DOC_START
-	The low-water mark for cache object replacement.
-	Replacement begins when the swap (disk) usage is above the
-	low-water mark and attempts to maintain utilization near the
-	low-water mark.  As swap utilization gets close to high-water
-	mark object eviction becomes more aggressive.  If utilization is
-	close to the low-water mark less replacement is done each time.
+	The low-water mark for AUFS/UFS/diskd cache object eviction by
+	the cache_replacement_policy algorithm.
+
+	Removal begins when the swap (disk) usage of a cache_dir is
+	above this low-water mark and attempts to maintain utilization
+	near the low-water mark.
+
+	As swap utilization increases towards the high-water mark set
+	by cache_swap_high object eviction becomes more agressive.
+
+	The value difference in percentages between low- and high-water
+	marks represent an eviction rate of 300 objects per second and
+	the rate continues to scale in agressiveness by multiples of
+	this above the high-water mark.
 
 	Defaults are 90% and 95%. If you have a large cache, 5% could be
 	hundreds of MB. If this is the case you may wish to set these
 	numbers closer together.
 
-	See also cache_swap_high
+	See also cache_swap_high and cache_replacement_policy
 DOC_END
 
 NAME: cache_swap_high
@@ -4024,18 +4034,26 @@ TYPE: int
 DEFAULT: 95
 LOC: Config.Swap.highWaterMark
 DOC_START
-	The high-water mark for cache object replacement.
-	Replacement begins when the swap (disk) usage is above the
-	low-water mark and attempts to maintain utilization near the
-	low-water mark.  As swap utilization gets close to high-water
-	mark object eviction becomes more aggressive.  If utilization is
-	close to the low-water mark less replacement is done each time.
+	The high-water mark for AUFS/UFS/diskd cache object eviction by
+	the cache_replacement_policy algorithm.
+
+	Removal begins when the swap (disk) usage of a cache_dir is
+	above the low-water mark set by cache_swap_low and attempts to
+	maintain utilization near the low-water mark.
+
+	As swap utilization increases towards this high-water mark object
+	eviction becomes more agressive.
+
+	The value difference in percentages between low- and high-water
+	marks represent an eviction rate of 300 objects per second and
+	the rate continues to scale in agressiveness by multiples of
+	this above the high-water mark.
 
 	Defaults are 90% and 95%. If you have a large cache, 5% could be
 	hundreds of MB. If this is the case you may wish to set these
 	numbers closer together.
 
-	See also cache_swap_low
+	See also cache_swap_low and cache_replacement_policy
 DOC_END
 
 COMMENT_START
@@ -4155,7 +4173,6 @@ DOC_START
 		ul	User name from authentication
 		ue	User name from external acl helper
 		ui	User name from ident
-		us	User name from SSL
 		un	A user name. Expands to the first available name
 			from the following list of information sources:
 			- authenticated user name, like %ul
@@ -5522,7 +5539,7 @@ DOC_START
 
 	Basically a cached object is:
 
-		FRESH if expires < now, else STALE
+		FRESH if expire > now, else STALE
 		STALE if age > max
 		FRESH if lm-factor < percent, else STALE
 		FRESH if age < min
@@ -8482,67 +8499,74 @@ DOC_START
 		Use the given number as the Max-Connections limit, regardless
 		of the Max-Connections value given by the service, if any.
 
-	==== SSL / ICAPS / TLS OPTIONS ====
+	==== ICAPS / TLS OPTIONS ====
 
 	These options are used for Secure ICAP (icaps://....) services only.
 
-	sslcert=/path/to/ssl/certificate
+	tls-cert=/path/to/ssl/certificate
 			A client SSL certificate to use when connecting to
 			this icap server.
 
-	sslkey=/path/to/ssl/key
-			The private SSL key corresponding to sslcert above.
-			If 'sslkey' is not specified 'sslcert' is assumed to
-			reference a combined file containing both the
+	tls-key=/path/to/ssl/key
+			The private TLS/SSL key corresponding to sslcert above.
+			If 'tls-key' is not specified 'tls-cert' is assumed to
+			reference a combined PEM format file containing both the
 			certificate and the key.
 
-	sslcipher=...	The list of valid SSL ciphers to use when connecting
+	tls-cipher=...	The list of valid TLS/SSL ciphers to use when connecting
 			to this icap server.
 
 	tls-min-version=1.N
 			The minimum TLS protocol version to permit. To control
 			SSLv3 use the ssloptions= parameter.
 			Supported Values: 1.0 (default), 1.1, 1.2
 
-	ssloptions=...	Specify various SSL implementation options:
+	tls-options=...	Specify various OpenSSL library options:
 
 			    NO_SSLv3    Disallow the use of SSLv3
+
 			    NO_TLSv1    Disallow the use of TLSv1.0
 			    NO_TLSv1_1  Disallow the use of TLSv1.1
 			    NO_TLSv1_2  Disallow the use of TLSv1.2
+
 			    SINGLE_DH_USE
 				      Always create a new key when using
 				      temporary/ephemeral DH key exchanges
+
 			    ALL       Enable various bug workarounds
-			    suggested as "harmless" by OpenSSL
-			    Be warned that this reduces SSL/TLS
-			    strength to some attacks.
+				      suggested as "harmless" by OpenSSL
+				      Be warned that this reduces SSL/TLS
+				      strength to some attacks.
 
 			See the OpenSSL SSL_CTX_set_options documentation for a
-			more complete list.
+			more complete list. Options relevant only to SSLv2 are
+			not supported.
 
-	sslcafile=...	A file containing additional CA certificates to use
-			when verifying the icap server certificate.
+	tls-cafile=...	A PEM file containing additional CA certificates to use
+			when verifying the icap server certificate. Used
+			to specify intermediate CA certificate(s) if not sent
+			by the server. Or the full CA chain for the server
+			when using the NO_DEFAULT_CA flag.
 
-	sslcapath=...	A directory containing additional CA certificates to
+	tls-capath=...	A directory containing additional CA certificates to
 			use when verifying the icap server certificate.
 
-	sslcrlfile=...	A certificate revocation list file to use when
+	tls-crlfile=...	A certificate revocation list file to use when
 			verifying the icap server certificate.
 
-	sslflags=...	Specify various flags modifying the SSL implementation:
+	tls-flags=...	Specify various flags modifying the Squid TLS implementation:
 
 			DONT_VERIFY_PEER
 				Accept certificates even if they fail to
 				verify.
 			NO_DEFAULT_CA
-				Don't use the default CA list built in
-				to OpenSSL.
+				Don't use the default CA list built into
+				OpenSSL.
 			DONT_VERIFY_DOMAIN
 				Don't verify the icap server certificate
 				matches the server name
 
-	ssldomain=	The icap server name as advertised in it's certificate.
+	tls-domain=	The icap server name as advertised in it's certificate.
 			Used for verifying the correctness of the received icap
 			server certificate. If not specified the icap server
 			hostname extracted from ICAP URI will be used.
@@ -158,17 +158,17 @@ clientdbUpdate(const Ip::Address &addr, const LogTags &ltype, AnyP::ProtocolType
     if (p == AnyP::PROTO_HTTP) {
         ++ c->Http.n_requests;
         ++ c->Http.result_hist[ltype.oldType];
-        kb_incr(&c->Http.kbytes_out, size);
+        c->Http.kbytes_out += size;
 
         if (ltype.isTcpHit())
-            kb_incr(&c->Http.hit_kbytes_out, size);
+            c->Http.hit_kbytes_out += size;
     } else if (p == AnyP::PROTO_ICP) {
         ++ c->Icp.n_requests;
         ++ c->Icp.result_hist[ltype.oldType];
-        kb_incr(&c->Icp.kbytes_out, size);
+        c->Icp.kbytes_out += size;
 
         if (LOG_UDP_HIT == ltype.oldType)
-            kb_incr(&c->Icp.hit_kbytes_out, size);
+            c->Icp.hit_kbytes_out += size;
     }
 
     c->last_seen = squid_curtime;
@@ -872,9 +872,15 @@ clientSetKeepaliveFlag(ClientHttpRequest * http)
     request->flags.proxyKeepalive = request->persistent();
 }
 
+/// checks body length of non-chunked requests
 static int
 clientIsContentLengthValid(HttpRequest * r)
 {
+    // No Content-Length means this request just has no body, but conflicting
+    // Content-Lengths mean a message framing error (RFC 7230 Section 3.3.3 #4).
+    if (r->header.conflictingContentLength())
+        return 0;
+
     switch (r->method.id()) {
 
     case Http::METHOD_GET:
@@ -952,6 +958,8 @@ ClientSocketContext::lengthToSend(Range<int64_t> const &available)
 void
 ClientSocketContext::noteSentBodyBytes(size_t bytes)
 {
+    debugs(33, 7, bytes << " body bytes");
+
     http->out.offset += bytes;
 
     if (!http->request->range)
@@ -1603,10 +1611,10 @@ clientUpdateSocketStats(const LogTags &logType, size_t size)
     if (size == 0)
         return;
 
-    kb_incr(&statCounter.client_http.kbytes_out, size);
+    statCounter.client_http.kbytes_out += size;
 
     if (logType.isTcpHit())
-        kb_incr(&statCounter.client_http.hit_kbytes_out, size);
+        statCounter.client_http.hit_kbytes_out += size;
 }
 
 /**
@@ -3114,7 +3122,7 @@ ConnStateData::clientReadRequest(const CommIoCbParams &io)
         return;
 
     case Comm::OK:
-        kb_incr(&(statCounter.client_http.kbytes_in), rd.size);
+        statCounter.client_http.kbytes_in += rd.size;
         if (!receivedFirstByte_)
             receivedFirstByte();
         // may comm_close or setReplyToError
@@ -3476,7 +3484,7 @@ ConnStateData::start()
 
             /* pools require explicit 'allow' to assign a client into them */
             if (pools[pool].access) {
-                ch.accessList = pools[pool].access;
+                ch.changeAcl(pools[pool].access);
                 allow_t answer = ch.fastCheck();
                 if (answer == ACCESS_ALLOWED) {
 
@@ -4192,12 +4200,7 @@ void httpsSslBumpStep2AccessCheckDone(allow_t answer, void *data)
     assert(connState->serverBump());
     Ssl::BumpMode bumpAction;
     if (answer == ACCESS_ALLOWED) {
-        if (answer.kind == Ssl::bumpNone)
-            bumpAction = Ssl::bumpSplice;
-        else if (answer.kind == Ssl::bumpClientFirst || answer.kind == Ssl::bumpServerFirst)
-            bumpAction = Ssl::bumpBump;
-        else
-            bumpAction = (Ssl::BumpMode)answer.kind;
+        bumpAction = (Ssl::BumpMode)answer.kind;
     } else
         bumpAction = Ssl::bumpSplice;
 
@@ -4242,7 +4245,7 @@ ConnStateData::splice()
         in.buf.append(rbuf.content(), rbuf.contentSize());
         ClientSocketContext::Pointer context = getCurrentContext();
         ClientHttpRequest *http = context->http;
-        tunnelStart(http, &http->out.size, &http->al->http.code, http->al);
+        tunnelStart(http);
     }
 }
 
@@ -4258,6 +4261,9 @@ ConnStateData::startPeekAndSpliceDone()
         ACLFilledChecklist *acl_checklist = new ACLFilledChecklist(Config.accessList.ssl_bump, sslServerBump->request.getRaw(), NULL);
         //acl_checklist->src_addr = params.conn->remote;
         //acl_checklist->my_addr = s->s;
+        acl_checklist->banAction(allow_t(ACCESS_ALLOWED, Ssl::bumpNone));
+        acl_checklist->banAction(allow_t(ACCESS_ALLOWED, Ssl::bumpClientFirst));
+        acl_checklist->banAction(allow_t(ACCESS_ALLOWED, Ssl::bumpServerFirst));
         acl_checklist->nonBlockingCheck(httpsSslBumpStep2AccessCheckDone, this);
         return;
     }
@@ -4306,14 +4312,24 @@ void
 ConnStateData::fakeAConnectRequest(const char *reason, const SBuf &payload)
 {
     // fake a CONNECT request to force connState to tunnel
-    static char ip[MAX_IPSTRLEN];
-    clientConnection->local.toUrl(ip, sizeof(ip));
+    SBuf connectHost;
+#if USE_OPENSSL
+    if (serverBump() && !serverBump()->clientSni.isEmpty()) {
+        connectHost.assign(serverBump()->clientSni);
+        if (clientConnection->local.port() > 0)
+            connectHost.appendf(":%d",clientConnection->local.port());
+    } else
+#endif
+    {
+        static char ip[MAX_IPSTRLEN];
+        connectHost.assign(clientConnection->local.toUrl(ip, sizeof(ip)));
+    }
     // Pre-pend this fake request to the TLS bits already in the buffer
     SBuf retStr;
     retStr.append("CONNECT ");
-    retStr.append(ip);
+    retStr.append(connectHost);
     retStr.append(" HTTP/1.1\r\nHost: ");
-    retStr.append(ip);
+    retStr.append(connectHost);
     retStr.append("\r\n\r\n");
     retStr.append(payload);
     in.buf = retStr;
@@ -1147,7 +1147,7 @@ clientReplyContext::storeNotOKTransferDone() const
     if (curReply->content_length < 0)
         return 0;
 
-    int64_t expectedLength = curReply->content_length + http->out.headers_sz;
+    uint64_t expectedLength = curReply->content_length + http->out.headers_sz;
 
     if (http->out.size < expectedLength)
         return 0;
@@ -1238,6 +1238,11 @@ clientReplyContext::replyStatus()
             return STREAM_FAILED;
         }
 
+        if (EBIT_TEST(http->storeEntry()->flags, ENTRY_BAD_LENGTH)) {
+            debugs(88, 5, "clientReplyStatus: truncated response body");
+            return STREAM_UNPLANNED_COMPLETE;
+        }
+
         if (!done) {
             debugs(88, 5, "clientReplyStatus: closing, !done, but read 0 bytes");
             return STREAM_FAILED;
@@ -1348,19 +1353,19 @@ clientReplyContext::buildReplyHeader()
          */
         if (EBIT_TEST(http->storeEntry()->flags, ENTRY_SPECIAL)) {
             hdr->delById(Http::HdrType::DATE);
-            hdr->insertTime(Http::HdrType::DATE, squid_curtime);
+            hdr->putTime(Http::HdrType::DATE, squid_curtime);
         } else if (http->getConn() && http->getConn()->port->actAsOrigin) {
             // Swap the Date: header to current time if we are simulating an origin
             HttpHeaderEntry *h = hdr->findEntry(Http::HdrType::DATE);
             if (h)
                 hdr->putExt("X-Origin-Date", h->value.termedBuf());
             hdr->delById(Http::HdrType::DATE);
-            hdr->insertTime(Http::HdrType::DATE, squid_curtime);
+            hdr->putTime(Http::HdrType::DATE, squid_curtime);
             h = hdr->findEntry(Http::HdrType::EXPIRES);
             if (h && http->storeEntry()->expires >= 0) {
                 hdr->putExt("X-Origin-Expires", h->value.termedBuf());
                 hdr->delById(Http::HdrType::EXPIRES);
-                hdr->insertTime(Http::HdrType::EXPIRES, squid_curtime + http->storeEntry()->expires - http->storeEntry()->timestamp);
+                hdr->putTime(Http::HdrType::EXPIRES, squid_curtime + http->storeEntry()->expires - http->storeEntry()->timestamp);
             }
             if (http->storeEntry()->timestamp <= squid_curtime) {
                 // put X-Cache-Age: instead of Age:
@@ -1399,9 +1404,9 @@ clientReplyContext::buildReplyHeader()
      */
     if ( !hdr->has(Http::HdrType::DATE) ) {
         if (!http->storeEntry())
-            hdr->insertTime(Http::HdrType::DATE, squid_curtime);
+            hdr->putTime(Http::HdrType::DATE, squid_curtime);
         else if (http->storeEntry()->timestamp > 0)
-            hdr->insertTime(Http::HdrType::DATE, http->storeEntry()->timestamp);
+            hdr->putTime(Http::HdrType::DATE, http->storeEntry()->timestamp);
         else {
             debugs(88,DBG_IMPORTANT,"BUG 3279: HTTP reply without Date:");
             /* dump something useful about the problem */
@@ -1514,7 +1514,7 @@ ClientHttpRequest::processRequest()
         }
 #endif
         getConn()->stopReading(); // tunnels read for themselves
-        tunnelStart(this, &out.size, &al->http.code, al);
+        tunnelStart(this);
         return;
     }
 
@@ -76,7 +76,7 @@ class ClientHttpRequest
         Out() : offset(0), size(0), headers_sz(0) {}
 
         int64_t offset;
-        int64_t size;
+        uint64_t size;
         size_t headers_sz;
     } out;
 
@@ -186,7 +186,7 @@ int clientHttpRequestStatus(int fd, ClientHttpRequest const *http);
 void clientAccessCheck(ClientHttpRequest *);
 
 /* ones that should be elsewhere */
-void tunnelStart(ClientHttpRequest *, int64_t *, int *, const AccessLogEntry::Pointer &al);
+void tunnelStart(ClientHttpRequest *);
 
 #if _USE_INLINE_
 #include "client_side_request.cci"
@@ -349,7 +349,7 @@ Client::sentRequestBody(const CommIoCbParams &io)
 
     if (io.size > 0) {
         fd_bytes(io.fd, io.size, FD_WRITE);
-        kb_incr(&(statCounter.server.all.kbytes_out), io.size);
+        statCounter.server.all.kbytes_out += io.size;
         // kids should increment their counters
     }
 
@@ -798,8 +798,22 @@ Client::endAdaptedBodyConsumption()
 // premature end of the adapted response body
 void Client::handleAdaptedBodyProducerAborted()
 {
+    if (abortOnBadEntry("entry went bad while waiting for the now-aborted adapted body"))
+        return;
+
+    Must(adaptedBodySource != nullptr);
+    if (!adaptedBodySource->exhausted()) {
+        debugs(11,5, "waiting to consume the remainder of the aborted adapted body");
+        return; // resumeBodyStorage() should eventually consume the rest
+    }
+
     stopConsumingFrom(adaptedBodySource);
-    handleAdaptationAborted();
+
+    if (handledEarlyAdaptationAbort())
+        return;
+
+    entry->lengthWentBad("body adaptation aborted");
+    handleAdaptationCompleted(); // the user should get a truncated response
 }
 
 // common part of noteAdaptationAnswer and handleAdaptedBodyProductionEnded
@@ -832,18 +846,29 @@ Client::handleAdaptationAborted(bool bypassable)
         return;
 
     // TODO: bypass if possible
+    if (!handledEarlyAdaptationAbort())
+        abortTransaction("adaptation failure with a filled entry");
+}
 
+/// If the store entry is still empty, fully handles adaptation abort, returning
+/// true. Otherwise just updates the request error detail and returns false.
+bool
+Client::handledEarlyAdaptationAbort()
+{
     if (entry->isEmpty()) {
-        debugs(11,9, HERE << "creating ICAP error entry after ICAP failure");
+        debugs(11,8, "adaptation failure with an empty entry: " << *entry);
         ErrorState *err = new ErrorState(ERR_ICAP_FAILURE, Http::scInternalServerError, request);
         err->detailError(ERR_DETAIL_ICAP_RESPMOD_EARLY);
         fwd->fail(err);
         fwd->dontRetry(true);
-    } else if (request) { // update logged info directly
-        request->detailError(ERR_ICAP_FAILURE, ERR_DETAIL_ICAP_RESPMOD_LATE);
+        abortTransaction("adaptation failure with an empty entry");
+        return true; // handled
     }
 
-    abortTransaction("ICAP failure");
+    if (request) // update logged info directly
+        request->detailError(ERR_ICAP_FAILURE, ERR_DETAIL_ICAP_RESPMOD_LATE);
+
+    return false; // the caller must handle
 }
 
 // adaptation service wants us to deny HTTP client access to this response
@@ -124,6 +124,7 @@ class Client:
     void handleAdaptationCompleted();
     void handleAdaptationBlocked(const Adaptation::Answer &answer);
     void handleAdaptationAborted(bool bypassable = false);
+    bool handledEarlyAdaptationAbort();
 
     /// called by StoreEntry when it has more buffer space available
     void resumeBodyStorage();
@@ -331,8 +331,8 @@ Ftp::Client::readControlReply(const CommIoCbParams &io)
     debugs(9, 3, "FD " << io.fd << ", Read " << io.size << " bytes");
 
     if (io.size > 0) {
-        kb_incr(&(statCounter.server.all.kbytes_in), io.size);
-        kb_incr(&(statCounter.server.ftp.kbytes_in), io.size);
+        statCounter.server.all.kbytes_in += io.size;
+        statCounter.server.ftp.kbytes_in += io.size;
     }
 
     if (io.flag == Comm::ERR_CLOSING)
@@ -808,8 +808,8 @@ Ftp::Client::writeCommandCallback(const CommIoCbParams &io)
 
     if (io.size > 0) {
         fd_bytes(io.fd, io.size, FD_WRITE);
-        kb_incr(&(statCounter.server.all.kbytes_out), io.size);
-        kb_incr(&(statCounter.server.ftp.kbytes_out), io.size);
+        statCounter.server.all.kbytes_out += io.size;
+        statCounter.server.ftp.kbytes_out += io.size;
     }
 
     if (io.flag == Comm::ERR_CLOSING)
@@ -894,8 +894,8 @@ Ftp::Client::dataRead(const CommIoCbParams &io)
     debugs(9, 3, "FD " << io.fd << " Read " << io.size << " bytes");
 
     if (io.size > 0) {
-        kb_incr(&(statCounter.server.all.kbytes_in), io.size);
-        kb_incr(&(statCounter.server.ftp.kbytes_in), io.size);
+        statCounter.server.all.kbytes_in += io.size;
+        statCounter.server.ftp.kbytes_in += io.size;
     }
 
     if (io.flag == Comm::ERR_CLOSING)
@@ -1020,7 +1020,7 @@ void
 Ftp::Client::sentRequestBody(const CommIoCbParams &io)
 {
     if (io.size > 0)
-        kb_incr(&(statCounter.server.ftp.kbytes_out), io.size);
+        statCounter.server.ftp.kbytes_out += io.size;
     ::Client::sentRequestBody(io);
 }
 
@@ -1452,7 +1452,6 @@ ftpReadType(Ftp::Gateway * ftpState)
 static void
 ftpTraverseDirectory(Ftp::Gateway * ftpState)
 {
-    wordlist *w;
     debugs(9, 4, HERE << (ftpState->filepath ? ftpState->filepath : "<NULL>"));
 
     safe_free(ftpState->dirpath);
@@ -1468,13 +1467,7 @@ ftpTraverseDirectory(Ftp::Gateway * ftpState)
     }
 
     /* Go to next path component */
-    w = ftpState->pathcomps;
-
-    ftpState->filepath = w->key;
-
-    ftpState->pathcomps = w->next;
-
-    delete w;
+    ftpState->filepath = wordlistChopHead(& ftpState->pathcomps);
 
     /* Check if we are to CWD or RETR */
     if (ftpState->pathcomps != NULL || ftpState->flags.isdir) {
@@ -24,14 +24,12 @@ Comm::IsConnOpen(const Comm::ConnectionPointer &conn)
 }
 
 Comm::Connection::Connection() :
-    local(),
-    remote(),
     peerType(HIER_NONE),
     fd(-1),
     tos(0),
     nfmark(0),
     flags(COMM_NONBLOCKING),
-    peer_(NULL),
+    peer_(nullptr),
     startTime_(squid_curtime)
 {
     *rfc931 = 0; // quick init the head. the rest does not matter.
@@ -13,14 +13,14 @@
 
 #include "comm/forward.h"
 #include "defines.h"
-#include "hier_code.h"
-#include "ip/Address.h"
-#include "mem/forward.h"
-#include "typedefs.h"
 #if USE_SQUID_EUI
 #include "eui/Eui48.h"
 #include "eui/Eui64.h"
 #endif
+#include "hier_code.h"
+#include "ip/Address.h"
+#include "ip/forward.h"
+#include "mem/forward.h"
 #include "SquidTime.h"
 
 #include <iosfwd>
@@ -12,7 +12,7 @@
 #include "base/AsyncCall.h"
 #include "comm/Flag.h"
 #include "comm/forward.h"
-#include "typedefs.h"
+#include "mem/forward.h"
 
 class SBuf;
 
@@ -10,9 +10,7 @@
 #define _SQUID_SRC_COMM_LOOPS_H
 
 #include "comm/Flag.h"
-
-// for PF
-#include "typedefs.h"
+#include "comm/forward.h"
 
 /* Comm layer select loops API.
  *
@@ -11,7 +11,7 @@
 
 #include "base/AsyncCall.h"
 #include "comm/forward.h"
-#include "typedefs.h"
+#include "mem/forward.h"
 
 class MemBuf;
 namespace Comm
@@ -28,5 +28,9 @@ bool IsConnOpen(const Comm::ConnectionPointer &conn);
 
 }; // namespace Comm
 
+/// legacy CBDATA callback functions ABI definition for read or write I/O events
+/// \deprecated use CommCalls API instead where possible
+typedef void PF(int, void *);
+
 #endif /* _SQUID_COMM_FORWARD_H */
 
@@ -11,7 +11,8 @@
 #ifndef SQUID_DISK_H_
 #define SQUID_DISK_H_
 
-#include "typedefs.h"
+#include "mem/forward.h"
+#include "typedefs.h" //DRCB, DWCB
 
 class MemBuf;
 
@@ -24,6 +24,9 @@
 #include "ssl/ErrorDetail.h"
 #endif
 
+/// error page callback
+typedef void ERCB(int fd, void *, size_t);
+
 /**
  \defgroup ErrorPageAPI Error Pages API
  \ingroup Components
@@ -69,6 +72,8 @@
 class HttpReply;
 class HttpRequest;
 class MemBuf;
+class StoreEntry;
+class wordlist;
 
 /// \ingroup ErrorPageAPI
 class ErrorState
@@ -1484,11 +1484,10 @@ esiLiteral::~esiLiteral()
     cbdataReferenceDone (varState);
 }
 
-esiLiteral::esiLiteral(ESISegment::Pointer aSegment)
+esiLiteral::esiLiteral(ESISegment::Pointer aSegment) :
+    buffer(aSegment),
+    varState(nullptr)
 {
-    buffer = aSegment;
-    /* we've been handed a complete, processed string */
-    varState = NULL;
     /* Nothing to do */
     flags.donevars = 1;
 }
@@ -1881,7 +1880,10 @@ esiChoose::~esiChoose()
     debugs(86, 5, "esiChoose::~esiChoose " << this);
 }
 
-esiChoose::esiChoose(esiTreeParentPtr aParent) : elements (), chosenelement (-1),parent (aParent)
+esiChoose::esiChoose(esiTreeParentPtr aParent) :
+    elements(),
+    chosenelement(-1),
+    parent(aParent)
 {}
 
 void
@@ -2281,14 +2283,12 @@ esiEnableProcessing (HttpReply *rep)
         HttpHdrScTarget *sctusable =
             rep->surrogate_control->getMergedTarget(Config.Accel.surrogate_id);
 
-        if (!sctusable || !sctusable->hasContent())
-            /* Nothing generic or targeted at us, or no
-             * content processing requested
-             */
-            return 0;
-
-        if (sctusable->content().pos("ESI/1.0") != NULL)
+        // found something targeted at us
+        if (sctusable &&
+                sctusable->hasContent() &&
+                sctusable->content().pos("ESI/1.0")) {
             rv = 1;
+        }
 
         delete sctusable;
     }
@@ -24,6 +24,15 @@
 #define OLD_FREE free
 #undef free
 #endif
+
+#if __clang__
+// workaround for clang complaining of unknown attributes in libxml2 on fedora22
+#ifdef LIBXML_ATTR_ALLOC_SIZE
+#undef LIBXML_ATTR_ALLOC_SIZE
+#endif
+#define LIBXML_ATTR_ALLOC_SIZE(x)
+#endif /* __clang__ */
+
 #if HAVE_LIBXML_PARSER_H
 #include <libxml/parser.h>
 #endif
@@ -120,7 +120,7 @@ eventAddIsh(const char *name, EVH * func, void *arg, double delta_ish, int weigh
         // relative to each other to prevent waves of synchronised activity.
         static std::mt19937 rng;
         auto third = (delta_ish/3.0);
-        std::uniform_real_distribution<> thirdIsh(delta_ish - third, delta_ish + third);
+        xuniform_real_distribution<> thirdIsh(delta_ish - third, delta_ish + third);
         delta_ish = thirdIsh(rng);
     }
 
@@ -10,6 +10,7 @@
 
 #include "squid.h"
 #include "comm/Read.h"
+#include "fd.h"
 #include "fde.h"
 #include "globals.h"
 #include "SquidTime.h"
@@ -12,12 +12,26 @@
 #include "comm.h"
 #include "defines.h"
 #include "ip/Address.h"
+#include "ip/forward.h"
 #include "security/forward.h"
+#include "typedefs.h" //DRCB, DWCB
 
 #if USE_DELAY_POOLS
 class ClientInfo;
 #endif
 
+/**
+ * READ_HANDLER functions return < 0 if, and only if, they fail with an error.
+ * On error, they must pass back an error code in 'errno'.
+ */
+typedef int READ_HANDLER(int, char *, int);
+
+/**
+ * WRITE_HANDLER functions return < 0 if, and only if, they fail with an error.
+ * On error, they must pass back an error code in 'errno'.
+ */
+typedef int WRITE_HANDLER(int, const char *, int);
+
 class dwrite_q;
 class _fde_disk
 {
@@ -103,7 +117,6 @@ class fde
     void *lifetime_data;
     AsyncCall::Pointer closeHandler;
     AsyncCall::Pointer halfClosedReader; /// read handler for half-closed fds
-    CommWriteStateData *wstate;         /* State data for comm_write */
     READ_HANDLER *read_method;
     WRITE_HANDLER *write_method;
     Security::SessionPointer ssl;
@@ -153,7 +166,6 @@ class fde
         lifetime_data = NULL;
         closeHandler = NULL;
         halfClosedReader = NULL;
-        wstate = NULL;
         read_method = NULL;
         write_method = NULL;
         ssl = NULL;
@@ -14,6 +14,7 @@
 #include "dns/LookupDetails.h"
 #include "dns/rfc1035.h"
 #include "event.h"
+#include "fqdncache.h"
 #include "helper.h"
 #include "mgr/Registration.h"
 #include "SquidConfig.h"
@@ -12,10 +12,15 @@
 #define SQUID_FQDNCACHE_H_
 
 #include "ip/Address.h"
-#include "typedefs.h"
 
 class StoreEntry;
 class wordlist;
+namespace Dns
+{
+class LookupDetails;
+}
+
+typedef void FQDNH(const char *, const Dns::LookupDetails &details, void *);
 
 void fqdncache_init(void);
 void fqdnStats(StoreEntry *);
@@ -35,9 +35,9 @@ libufs_la_SOURCES = \
 	ufs/RebuildState.cc
 
 librock_la_SOURCES = \
+	rock/forward.h \
 	rock/RockDbCell.cc \
 	rock/RockDbCell.h \
-	rock/RockForward.h \
 	rock/RockIoState.cc \
 	rock/RockIoState.h \
 	rock/RockIoRequests.cc \
@@ -0,0 +1,16 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_FORWARD_H_
+#define SQUID_FORWARD_H_
+
+typedef int32_t sfileno;
+typedef signed int sdirno;
+
+#endif /* SQUID_FORWARD_H_ */
+
@@ -9,7 +9,7 @@
 #ifndef SQUID_FS_ROCK_DB_CELL_H
 #define SQUID_FS_ROCK_DB_CELL_H
 
-#include "typedefs.h"
+#include "fs/forward.h"
 
 namespace Rock
 {
@@ -19,7 +19,6 @@
 #include "SquidTime.h"
 #include "store_rebuild.h"
 #include "tools.h"
-#include "typedefs.h"
 
 #include <cerrno>
 
@@ -11,7 +11,7 @@
 
 #include "base/AsyncJob.h"
 #include "cbdata.h"
-#include "fs/rock/RockForward.h"
+#include "fs/rock/forward.h"
 #include "MemBuf.h"
 #include "store_rebuild.h"
 
@@ -11,8 +11,8 @@
 
 #include "DiskIO/DiskFile.h"
 #include "DiskIO/IORequestor.h"
+#include "fs/rock/forward.h"
 #include "fs/rock/RockDbCell.h"
-#include "fs/rock/RockForward.h"
 #include "ipc/mem/Page.h"
 #include "ipc/mem/PageStack.h"
 #include "ipc/StoreMap.h"
@@ -9,6 +9,8 @@
 #ifndef SQUID_FS_ROCK_FORWARD_H
 #define SQUID_FS_ROCK_FORWARD_H
 
+#include "fs/forward.h"
+
 namespace Ipc
 {
 
@@ -48,7 +48,13 @@ class UFSStoreState : public StoreIOState, public IORequestor
     {
         MEMPROXY_CLASS(UFSStoreState::_queued_read);
     public:
-        _queued_read() : buf(NULL), size(0), offset(0), callback(NULL), callback_data(NULL) {}
+        _queued_read() :
+            buf(nullptr),
+            size(0),
+            offset(0),
+            callback(nullptr),
+            callback_data(nullptr)
+        {}
 
         char *buf;
         size_t size;
@@ -61,7 +67,12 @@ class UFSStoreState : public StoreIOState, public IORequestor
     {
         MEMPROXY_CLASS(UFSStoreState::_queued_write);
     public:
-        _queued_write() : buf(NULL), size(0), offset(0), free_func(NULL) {}
+        _queued_write() :
+            buf(nullptr),
+            size(0),
+            offset(0),
+            free_func(nullptr)
+        {}
 
         char const *buf;
         size_t size;
@@ -135,7 +135,6 @@ FreeObject(void *address)
     delete anObject;
 }
 
-static QS rev_int_sort;
 static int
 rev_int_sort(const void *A, const void *B)
 {
@@ -413,44 +412,96 @@ Fs::Ufs::UFSSwapDir::statfs(StoreEntry & sentry) const
 void
 Fs::Ufs::UFSSwapDir::maintain()
 {
-    /* We can't delete objects while rebuilding swap */
+    /* TODO: possible options for improvement;
+     *
+     * Note that too much aggression here is not good. It means that disk
+     * controller is getting a long queue of removals to act on, along
+     * with its regular I/O queue, and that client traffic is 'paused'
+     * and growing the network I/O queue as well while the scan happens.
+     * Possibly bad knock-on effects as Squid catches up on all that.
+     *
+     * Bug 2448 may have been a sign of what can wrong. At the least it
+     * provides a test case for aggression effects in overflow conditions.
+     *
+     * - base removal limit on space saved, instead of count ?
+     *
+     * - base removal rate on a traffic speed counter ?
+     *   as the purge took up more time out of the second it would grow to
+     *   a graceful full pause
+     *
+     * - pass out a value to cause another event to be scheduled immediately
+     *   instead of waiting a whole second more ?
+     *   knock on; schedule less if all caches are under low-water
+     *
+     * - admin configurable removal rate or count ?
+     *   the current numbers are arbitrary, config helps with experimental
+     *   trials and future-proofing the install base.
+     *   we also have this indirectly by shifting the relative positions
+     *   of low-, high- water and the total capacity limit.
+     */
 
-    /* XXX FIXME each store should start maintaining as it comes online. */
+    // minSize() is swap_low_watermark in bytes
+    const uint64_t lowWaterSz = minSize();
 
-    if (StoreController::store_dirs_rebuilding)
+    if (currentSize() < lowWaterSz) {
+        debugs(47, 5, "space still available in " << path);
         return;
+    }
 
-    StoreEntry *e = NULL;
-
-    int removed = 0;
-
-    RemovalPurgeWalker *walker;
-
-    double f = (double) (currentSize() - minSize()) / (maxSize() - minSize());
+    /* We can't delete objects while rebuilding swap */
+    /* XXX each store should start maintaining as it comes online. */
+    if (StoreController::store_dirs_rebuilding) {
+        // suppress the warnings, except once each minute
+        static int64_t lastWarn = 0;
+        int warnLevel = 3;
+        if (lastWarn+60 < squid_curtime) {
+            lastWarn = squid_curtime;
+            warnLevel = DBG_IMPORTANT;
+        }
+        debugs(47, warnLevel, StoreController::store_dirs_rebuilding << " cache_dir still rebuilding. Skip GC for " << path);
+        return;
+    }
 
-    f = f < 0.0 ? 0.0 : f > 1.0 ? 1.0 : f;
+    // maxSize() is cache_dir total size in bytes
+    const uint64_t highWaterSz = ((maxSize() * Config.Swap.highWaterMark) / 100);
+
+    // f is percentage of 'gap' filled between low- and high-water.
+    // Used to reduced purge rate when between water markers, and
+    // to multiply it more agressively the further above high-water
+    // it reaches. But in a graceful linear growth curve.
+    double f = 1.0;
+    if (highWaterSz > lowWaterSz) {
+        // might be equal. n/0 is bad.
+        f = (double) (currentSize() - lowWaterSz) / (highWaterSz - lowWaterSz);
+    }
 
+    // how deep to look for a single object that can be removed
     int max_scan = (int) (f * 400.0 + 100.0);
 
-    int max_remove = (int) (f * 70.0 + 10.0);
+    // try to purge only this many objects this cycle.
+    int max_remove = (int) (f * 300.0 + 20.0);
 
     /*
      * This is kinda cheap, but so we need this priority hack?
      */
+    debugs(47, 3, "f=" << f << ", max_scan=" << max_scan << ", max_remove=" << max_remove);
 
-    debugs(47, 3, HERE << "f=" << f << ", max_scan=" << max_scan << ", max_remove=" << max_remove  );
+    RemovalPurgeWalker *walker = repl->PurgeInit(repl, max_scan);
 
-    walker = repl->PurgeInit(repl, max_scan);
-
-    while (1) {
-        if (currentSize() < minSize())
-            break;
+    int removed = 0;
+    // only purge while above low-water
+    while (currentSize() >= lowWaterSz) {
 
+        // stop if we reached max removals for this cycle,
+        // Bug 2448 may be from this not clearing enough,
+        // but it predates the current algorithm so not sure
         if (removed >= max_remove)
             break;
 
-        e = walker->Next(walker);
+        StoreEntry *e = walker->Next(walker);
 
+        // stop if all objects are locked / in-use,
+        // or the cache is empty
         if (!e)
             break;      /* no more objects */
 
@@ -460,9 +511,12 @@ Fs::Ufs::UFSSwapDir::maintain()
     }
 
     walker->Done(walker);
-    debugs(47, (removed ? 2 : 3), HERE << path <<
+    debugs(47, (removed ? 2 : 3), path <<
            " removed " << removed << "/" << max_remove << " f=" <<
            std::setprecision(4) << f << " max_scan=" << max_scan);
+
+    // what if cache is still over the high watermark ?
+    // Store::Maintain() schedules another purge in 1 second.
 }
 
 void
@@ -1044,7 +1098,7 @@ Fs::Ufs::UFSSwapDir::CleanEvent(void *)
          * swap directories
          */
         std::mt19937 mt(static_cast<uint32_t>(getCurrentTime() & 0xFFFFFFFF));
-        std::uniform_int_distribution<> dist(0, j);
+        xuniform_int_distribution<> dist(0, j);
         swap_index = dist(mt);
     }
 
@@ -752,8 +752,8 @@ gopherReadReply(const Comm::ConnectionPointer &conn, char *buf, size_t len, Comm
         delayId.bytesIn(len);
 #endif
 
-        kb_incr(&(statCounter.server.all.kbytes_in), len);
-        kb_incr(&(statCounter.server.other.kbytes_in), len);
+        statCounter.server.all.kbytes_in += len;
+        statCounter.server.other.kbytes_in += len;
     }
 
     debugs(10, 5, HERE << conn << " read len=" << len);
@@ -826,8 +826,8 @@ gopherSendComplete(const Comm::ConnectionPointer &conn, char *buf, size_t size,
 
     if (size > 0) {
         fd_bytes(conn->fd, size, FD_WRITE);
-        kb_incr(&(statCounter.server.all.kbytes_out), size);
-        kb_incr(&(statCounter.server.other.kbytes_out), size);
+        statCounter.server.all.kbytes_out += size;
+        statCounter.server.other.kbytes_out += size;
     }
 
     if (errflag) {
@@ -510,8 +510,6 @@ helperStatefulReleaseServer(helper_stateful_server * srv)
     ++ srv->stats.releases;
 
     srv->flags.reserved = false;
-    if (srv->parent->OnEmptyQueue != NULL && srv->data)
-        srv->parent->OnEmptyQueue(srv->data);
 
     helperStatefulServerDone(srv);
 }
@@ -1262,9 +1260,6 @@ StatefulGetFirstAvailable(statefulhelper * hlp)
         if (srv->flags.shutdown)
             continue;
 
-        if ((hlp->IsAvailable != NULL) && (srv->data != NULL) && !(hlp->IsAvailable(srv->data)))
-            continue;
-
         debugs(84, 5, "StatefulGetFirstAvailable: returning srv-" << srv->index);
         return srv;
     }
@@ -25,6 +25,7 @@
 #include <map>
 
 class Packable;
+class wordlist;
 
 /**
  * Managers a set of individual helper processes with a common queue of requests.
@@ -110,13 +111,11 @@ class statefulhelper : public helper
     CBDATA_CLASS(statefulhelper);
 
 public:
-    inline statefulhelper(const char *name) : helper(name), datapool(NULL), IsAvailable(NULL), OnEmptyQueue(NULL) {}
+    inline statefulhelper(const char *name) : helper(name), datapool(NULL) {}
     inline ~statefulhelper() {}
 
 public:
     MemAllocator *datapool;
-    HLPSAVAIL *IsAvailable;
-    HLPSONEQ *OnEmptyQueue;
 
 private:
     friend void helperStatefulSubmit(statefulhelper * hlp, const char *buf, HLPCB * callback, void *data, helper_stateful_server * lastserver);
@@ -853,7 +853,7 @@ htcpTstReply(htcpDataHeader * dhdr, StoreEntry * e, htcpSpecifier * spec, Ip::Ad
         stuff.D.respHdrsSz = mb.contentSize();
         debugs(31, 3, "htcpTstReply: resp_hdrs = {" << stuff.D.resp_hdrs << "}");
         mb.reset();
-        hdr.reset();
+        hdr.clean();
 
         if (e && e->expires > -1)
             hdr.putTime(Http::HdrType::EXPIRES, e->expires);
@@ -869,8 +869,7 @@ htcpTstReply(htcpDataHeader * dhdr, StoreEntry * e, htcpSpecifier * spec, Ip::Ad
         debugs(31, 3, "htcpTstReply: entity_hdrs = {" << stuff.D.entity_hdrs << "}");
 
         mb.reset();
-
-        hdr.reset();
+        hdr.clean();
 
 #if USE_ICMP
         if (char *host = urlHostname(spec->uri)) {
@@ -14,6 +14,7 @@
 #include "http/forward.h"
 #include "HttpHeader.h"
 #include "ip/forward.h"
+#include "store_key_md5.h"
 
 /// \ingroup ServerProtocolHTCP
 class HtcpReplyData
@@ -589,22 +589,16 @@ httpMakeVaryMark(HttpRequest * request, HttpReply const * reply)
     vary = reply->header.getList(Http::HdrType::VARY);
 
     while (strListGetItem(&vary, ',', &item, &ilen, &pos)) {
-        char *name = (char *)xmalloc(ilen + 1);
-        xstrncpy(name, item, ilen + 1);
-        Tolower(name);
-
-        if (strcmp(name, "*") == 0) {
-            /* Can not handle "Vary: *" withtout ETag support */
-            safe_free(name);
+        static const SBuf asterisk("*");
+        SBuf name(item, ilen);
+        if (name == asterisk) {
             vstr.clean();
             break;
         }
-
-        strListAdd(&vstr, name, ',');
+        name.toLower();
+        strListAdd(&vstr, name.c_str(), ',');
         hdr = request->header.getByName(name);
-        safe_free(name);
         value = hdr.termedBuf();
-
         if (value) {
             value = rfc1738_escape_part(value);
             vstr.append("=\"", 2);
@@ -1204,8 +1198,8 @@ HttpStateData::readReply(const CommIoCbParams &io)
         delayId.bytesIn(rd.size);
 #endif
 
-        kb_incr(&(statCounter.server.all.kbytes_in), rd.size);
-        kb_incr(&(statCounter.server.http.kbytes_in), rd.size);
+        statCounter.server.all.kbytes_in += rd.size;
+        statCounter.server.http.kbytes_in += rd.size;
         ++ IOStats.Http.reads;
 
         int bin = 0;
@@ -1314,6 +1308,9 @@ HttpStateData::continueAfterParsingHeader()
             } else if (s == Http::scHeaderTooLarge) {
                 fwd->dontRetry(true);
                 error = ERR_TOO_BIG;
+            } else if (vrep->header.conflictingContentLength()) {
+                fwd->dontRetry(true);
+                error = ERR_INVALID_RESP;
             } else {
                 return true; // done parsing, got reply, and no error
             }
@@ -1590,8 +1587,8 @@ HttpStateData::wroteLast(const CommIoCbParams &io)
 
     if (io.size > 0) {
         fd_bytes(io.fd, io.size, FD_WRITE);
-        kb_incr(&(statCounter.server.all.kbytes_out), io.size);
-        kb_incr(&(statCounter.server.http.kbytes_out), io.size);
+        statCounter.server.all.kbytes_out += io.size;
+        statCounter.server.http.kbytes_out += io.size;
     }
 
     if (io.flag == Comm::ERR_CLOSING)
@@ -2455,7 +2452,7 @@ void
 HttpStateData::sentRequestBody(const CommIoCbParams &io)
 {
     if (io.size > 0)
-        kb_incr(&statCounter.server.http.kbytes_out, io.size);
+        statCounter.server.http.kbytes_out += io.size;
 
     Client::sentRequestBody(io);
 }
@@ -20,6 +20,7 @@ libsquid_http_la_SOURCES = \
 	ProtocolVersion.h \
 	RegisteredHeaders.h \
 	RegisteredHeaders.cc \
+	RegisteredHeadersHash.cci \
 	RequestMethod.cc \
 	RequestMethod.h \
 	StatusCode.cc \
@@ -34,3 +35,10 @@ MethodType.cc: MethodType.h $(top_srcdir)/src/mk-string-arrays.awk
 		sed -e 's%METHOD_%%' -e 's%_C%-C%' >$@) || ($(RM) -f $@ && exit 1)
 
 CLEANFILES += MethodType.cc
+
+gperf-files: RegisteredHeadersHash.gperf
+	if test $(srcdir)/RegisteredHeadersHash.gperf -nt $(srcdir)/RegisteredHeadersHash.cci; then gperf -m 100000 $(srcdir)/RegisteredHeadersHash.gperf | sed 's/register //g' > $(srcdir)/RegisteredHeadersHash.cci; fi
+
+EXTRA_DIST = RegisteredHeadersHash.gperf
+
+.PHONY: gperf-files
@@ -10,122 +10,68 @@
 #include "RegisteredHeaders.h"
 
 #include <ostream>
+#include <vector>
 
 namespace Http
 {
-/*
- * A table with major attributes for every known field.
- *
- * Invariant on this table:
- * for each index in HeaderTable, (int)HeaderTable[index] = index
- *
- * To be kept in sync with Http::HdrType
- */
-const HeaderTableRecord HeaderTable[] = {
-    {"Accept", Http::HdrType::ACCEPT, Http::HdrFieldType::ftStr},
-    {"Accept-Charset", Http::HdrType::ACCEPT_CHARSET, Http::HdrFieldType::ftStr},
-    {"Accept-Encoding", Http::HdrType::ACCEPT_ENCODING, Http::HdrFieldType::ftStr},
-    {"Accept-Language", Http::HdrType::ACCEPT_LANGUAGE, Http::HdrFieldType::ftStr},
-    {"Accept-Ranges", Http::HdrType::ACCEPT_RANGES, Http::HdrFieldType::ftStr},
-    {"Age", Http::HdrType::AGE, Http::HdrFieldType::ftInt},
-    {"Allow", Http::HdrType::ALLOW, Http::HdrFieldType::ftStr},
-    {"Alternate-Protocol", Http::HdrType::ALTERNATE_PROTOCOL, Http::HdrFieldType::ftStr},
-    {"Authentication-Info", Http::HdrType::AUTHENTICATION_INFO, Http::HdrFieldType::ftStr},
-    {"Authorization", Http::HdrType::AUTHORIZATION, Http::HdrFieldType::ftStr},    /* for now */
-    {"Cache-Control", Http::HdrType::CACHE_CONTROL, Http::HdrFieldType::ftPCc},
-    {"Connection", Http::HdrType::CONNECTION, Http::HdrFieldType::ftStr},
-    {"Content-Base", Http::HdrType::CONTENT_BASE, Http::HdrFieldType::ftStr},
-    {"Content-Disposition", Http::HdrType::CONTENT_DISPOSITION, Http::HdrFieldType::ftStr},  /* for now */
-    {"Content-Encoding", Http::HdrType::CONTENT_ENCODING, Http::HdrFieldType::ftStr},
-    {"Content-Language", Http::HdrType::CONTENT_LANGUAGE, Http::HdrFieldType::ftStr},
-    {"Content-Length", Http::HdrType::CONTENT_LENGTH, Http::HdrFieldType::ftInt64},
-    {"Content-Location", Http::HdrType::CONTENT_LOCATION, Http::HdrFieldType::ftStr},
-    {"Content-MD5", Http::HdrType::CONTENT_MD5, Http::HdrFieldType::ftStr},    /* for now */
-    {"Content-Range", Http::HdrType::CONTENT_RANGE, Http::HdrFieldType::ftPContRange},
-    {"Content-Type", Http::HdrType::CONTENT_TYPE, Http::HdrFieldType::ftStr},
-    {"Cookie", Http::HdrType::COOKIE, Http::HdrFieldType::ftStr},
-    {"Cookie2", Http::HdrType::COOKIE2, Http::HdrFieldType::ftStr},
-    {"Date", Http::HdrType::DATE, Http::HdrFieldType::ftDate_1123},
-    {"ETag", Http::HdrType::ETAG, Http::HdrFieldType::ftETag},
-    {"Expect", Http::HdrType::EXPECT, Http::HdrFieldType::ftStr},
-    {"Expires", Http::HdrType::EXPIRES, Http::HdrFieldType::ftDate_1123},
-    {"Forwarded", Http::HdrType::FORWARDED, Http::HdrFieldType::ftStr},
-    {"From", Http::HdrType::FROM, Http::HdrFieldType::ftStr},
-    {"Host", Http::HdrType::HOST, Http::HdrFieldType::ftStr},
-    {"HTTP2-Settings", Http::HdrType::HTTP2_SETTINGS, Http::HdrFieldType::ftStr}, /* for now */
-    {"If-Match", Http::HdrType::IF_MATCH, Http::HdrFieldType::ftStr},  /* for now */
-    {"If-Modified-Since", Http::HdrType::IF_MODIFIED_SINCE, Http::HdrFieldType::ftDate_1123},
-    {"If-None-Match", Http::HdrType::IF_NONE_MATCH, Http::HdrFieldType::ftStr},    /* for now */
-    {"If-Range", Http::HdrType::IF_RANGE, Http::HdrFieldType::ftDate_1123_or_ETag},
-    {"If-Unmodified-Since", Http::HdrType::IF_UNMODIFIED_SINCE, Http::HdrFieldType::ftDate_1123},
-    {"Keep-Alive", Http::HdrType::KEEP_ALIVE, Http::HdrFieldType::ftStr},
-    {"Key", Http::HdrType::KEY, Http::HdrFieldType::ftStr},
-    {"Last-Modified", Http::HdrType::LAST_MODIFIED, Http::HdrFieldType::ftDate_1123},
-    {"Link", Http::HdrType::LINK, Http::HdrFieldType::ftStr},
-    {"Location", Http::HdrType::LOCATION, Http::HdrFieldType::ftStr},
-    {"Max-Forwards", Http::HdrType::MAX_FORWARDS, Http::HdrFieldType::ftInt64},
-    {"Mime-Version", Http::HdrType::MIME_VERSION, Http::HdrFieldType::ftStr},  /* for now */
-    {"Negotiate", Http::HdrType::NEGOTIATE, Http::HdrFieldType::ftStr},
-    {"Origin", Http::HdrType::ORIGIN, Http::HdrFieldType::ftStr},
-    {"Pragma", Http::HdrType::PRAGMA, Http::HdrFieldType::ftStr},
-    {"Proxy-Authenticate", Http::HdrType::PROXY_AUTHENTICATE, Http::HdrFieldType::ftStr},
-    {"Proxy-Authentication-Info", Http::HdrType::PROXY_AUTHENTICATION_INFO, Http::HdrFieldType::ftStr},
-    {"Proxy-Authorization", Http::HdrType::PROXY_AUTHORIZATION, Http::HdrFieldType::ftStr},
-    {"Proxy-Connection", Http::HdrType::PROXY_CONNECTION, Http::HdrFieldType::ftStr},
-    {"Proxy-support", Http::HdrType::PROXY_SUPPORT, Http::HdrFieldType::ftStr},
-    {"Public", Http::HdrType::PUBLIC, Http::HdrFieldType::ftStr},
-    {"Range", Http::HdrType::RANGE, Http::HdrFieldType::ftPRange},
-    {"Referer", Http::HdrType::REFERER, Http::HdrFieldType::ftStr},
-    {"Request-Range", Http::HdrType::REQUEST_RANGE, Http::HdrFieldType::ftPRange}, /* usually matches Http::HdrType::RANGE */
-    {"Retry-After", Http::HdrType::RETRY_AFTER, Http::HdrFieldType::ftStr},    /* for now (Http::HdrFieldType::ftDate_1123 or Http::HdrFieldType::ftInt!} */
-    {"Server", Http::HdrType::SERVER, Http::HdrFieldType::ftStr},
-    {"Set-Cookie", Http::HdrType::SET_COOKIE, Http::HdrFieldType::ftStr},
-    {"Set-Cookie2", Http::HdrType::SET_COOKIE2, Http::HdrFieldType::ftStr},
-    {"TE", Http::HdrType::TE, Http::HdrFieldType::ftStr},
-    {"Title", Http::HdrType::TITLE, Http::HdrFieldType::ftStr},
-    {"Trailer", Http::HdrType::TRAILER, Http::HdrFieldType::ftStr},
-    {"Transfer-Encoding", Http::HdrType::TRANSFER_ENCODING, Http::HdrFieldType::ftStr},
-    {"Translate", Http::HdrType::TRANSLATE, Http::HdrFieldType::ftStr},    /* for now. may need to crop */
-    {"Unless-Modified-Since", Http::HdrType::UNLESS_MODIFIED_SINCE, Http::HdrFieldType::ftStr},  /* for now ignore. may need to crop */
-    {"Upgrade", Http::HdrType::UPGRADE, Http::HdrFieldType::ftStr},    /* for now */
-    {"User-Agent", Http::HdrType::USER_AGENT, Http::HdrFieldType::ftStr},
-    {"Vary", Http::HdrType::VARY, Http::HdrFieldType::ftStr},  /* for now */
-    {"Via", Http::HdrType::VIA, Http::HdrFieldType::ftStr},    /* for now */
-    {"Warning", Http::HdrType::WARNING, Http::HdrFieldType::ftStr},    /* for now */
-    {"WWW-Authenticate", Http::HdrType::WWW_AUTHENTICATE, Http::HdrFieldType::ftStr},
-    {"X-Cache", Http::HdrType::X_CACHE, Http::HdrFieldType::ftStr},
-    {"X-Cache-Lookup", Http::HdrType::X_CACHE_LOOKUP, Http::HdrFieldType::ftStr},
-    {"X-Forwarded-For", Http::HdrType::X_FORWARDED_FOR, Http::HdrFieldType::ftStr},
-    {"X-Request-URI", Http::HdrType::X_REQUEST_URI, Http::HdrFieldType::ftStr},
-    {"X-Squid-Error", Http::HdrType::X_SQUID_ERROR, Http::HdrFieldType::ftStr},
-#if X_ACCELERATOR_VARY
-    {"X-Accelerator-Vary", Http::HdrType::HDR_X_ACCELERATOR_VARY, Http::HdrFieldType::ftStr},
-#endif
-#if USE_ADAPTATION
-    {"X-Next-Services", Http::HdrType::X_NEXT_SERVICES, Http::HdrFieldType::ftStr},
-#endif
-    {"Surrogate-Capability", Http::HdrType::SURROGATE_CAPABILITY, Http::HdrFieldType::ftStr},
-    {"Surrogate-Control", Http::HdrType::SURROGATE_CONTROL, Http::HdrFieldType::ftPSc},
-    {"Front-End-Https", Http::HdrType::FRONT_END_HTTPS, Http::HdrFieldType::ftStr},
-    {"FTP-Command", Http::HdrType::FTP_COMMAND, Http::HdrFieldType::ftStr},
-    {"FTP-Arguments", Http::HdrType::FTP_ARGUMENTS, Http::HdrFieldType::ftStr},
-    {"FTP-Pre", Http::HdrType::FTP_PRE, Http::HdrFieldType::ftStr},
-    {"FTP-Status", Http::HdrType::FTP_STATUS, Http::HdrFieldType::ftInt},
-    {"FTP-Reason", Http::HdrType::FTP_REASON, Http::HdrFieldType::ftStr},
-    {"Other:", Http::HdrType::OTHER, Http::HdrFieldType::ftStr},    /* ':' will not allow matches */
-    {"*INVALID*:", Http::HdrType::BAD_HDR, Http::HdrFieldType::ftInvalid}, /* ':' will not allow matches */
-    {nullptr, Http::HdrType::ENUM_END, Http::HdrFieldType::ftInvalid}    /* end of table */
-};
+/* glue to code generated by gperf */
+#include "http/RegisteredHeadersHash.cci"
+
+HeaderTableRecord::HeaderTableRecord() :
+    name(""), id(HdrType::BAD_HDR), type(HdrFieldType::ftInvalid),
+    list(false), request(false), reply(false), hopbyhop(false), denied304(false)
+{}
+
+HeaderTableRecord::HeaderTableRecord(const char *n) :
+    name(n), id(HdrType::BAD_HDR), type(HdrFieldType::ftInvalid),
+    list(false), request(false), reply(false), hopbyhop(false), denied304(false)
+{}
+
+HeaderTableRecord::HeaderTableRecord(const char *n, HdrType theId, HdrFieldType theType, int theKind) :
+    name(n), id(theId), type(theType),
+    list(theKind & HdrKind::ListHeader), request(theKind & HdrKind::RequestHeader),
+    reply(theKind & HdrKind::ReplyHeader), hopbyhop(theKind & HdrKind::HopByHopHeader),
+    denied304(theKind & HdrKind::Denied304Header)
+{}
 
-const LookupTable<Http::HdrType, HeaderTableRecord> HeaderLookupTable(Http::HdrType::BAD_HDR, HeaderTable);
+const HeaderTableRecord&
+HeaderLookupTable_t::lookup (const char *buf, const std::size_t len) const {
+    const HeaderTableRecord *r = HttpHeaderHashTable::lookup(buf, len);
+    if (!r)
+        return BadHdr;
+    return *r;
+}
+const HeaderTableRecord HeaderLookupTable_t::BadHdr {"*INVALID*:", Http::HdrType::BAD_HDR, Http::HdrFieldType::ftInvalid, HdrKind::None};
+
+HeaderLookupTable_t::HeaderLookupTable_t()
+{
+    initCache();
+}
+
+void
+HeaderLookupTable_t::initCache()
+{
+    idCache.resize(TOTAL_KEYWORDS);
+    for (int j = MIN_HASH_VALUE; j <= MAX_HASH_VALUE; ++j) { //MAX_HASH_VALUE is exported by gperf
+        if (HttpHeaderDefinitionsTable[j].name[0] != '\0') { //some slots are empty
+            idCache[static_cast<int>(HttpHeaderDefinitionsTable[j].id)] =
+                & HttpHeaderDefinitionsTable[j];
+        }
+    }
+    //check after the fact. The cache array must be full
+    for (auto e : idCache) {
+        assert(e->name);
+    }
+}
+const HeaderLookupTable_t HeaderLookupTable;
 
 }; /* namespace Http */
 
 std::ostream&
 operator<< (std::ostream &s, Http::HdrType id)
 {
     if (Http::any_HdrType_enum_value(id))
-        s << Http::HeaderTable[id].name << '[' << static_cast<int>(id) << ']';
+        s << Http::HeaderLookupTable.lookup(id).name << '[' << static_cast<int>(id) << ']';
     else
         s << "Invalid-Header[" << static_cast<int>(id) << ']';
     return s;
@@ -17,7 +17,8 @@ namespace Http
 /// recognized or "known" header fields; and the RFC which defines them (or not)
 /// http://www.iana.org/assignments/message-headers/message-headers.xhtml
 enum HdrType {
-    ACCEPT = 0,                     /**< RFC 7231 */ /* MUST BE FIRST */
+    enumBegin_ = 0,                 // service value for WholeEnum iteration
+    ACCEPT = enumBegin_,            /**< RFC 7231 */ /* MUST BE FIRST */
     ACCEPT_CHARSET,                 /**< RFC 7231 */
     ACCEPT_ENCODING,                /**< RFC 7231 */
     /*ACCEPT_FEATURES,*/            /* RFC 2295 */
@@ -105,12 +106,8 @@ enum HdrType {
     X_FORWARDED_FOR,                /**< obsolete Squid custom header, RFC 7239 */
     X_REQUEST_URI,                  /**< Squid custom header appended if ADD_X_REQUEST_URI is defined */
     X_SQUID_ERROR,                  /**< Squid custom header on generated error responses */
-#if X_ACCELERATOR_VARY
     HDR_X_ACCELERATOR_VARY,             /**< obsolete Squid custom header. */
-#endif
-#if USE_ADAPTATION
     X_NEXT_SERVICES,                /**< Squid custom ICAP header */
-#endif
     SURROGATE_CAPABILITY,           /**< Edge Side Includes (ESI) header */
     SURROGATE_CONTROL,              /**< Edge Side Includes (ESI) header */
     FRONT_END_HTTPS,                /**< MS Exchange custom header we may have to add */
@@ -120,8 +117,8 @@ enum HdrType {
     FTP_STATUS,                     /**< Internal header for FTP reply status */
     FTP_REASON,                     /**< Internal header for FTP reply reason */
     OTHER,                          /**< internal tag value for "unknown" headers */
-    BAD_HDR,                        /**< Invalid header. Must be after ENUM_END */
-    ENUM_END                        /**< internal tag for end-of-headers */
+    BAD_HDR,                        /**< Invalid header */
+    enumEnd_                        // internal tag for end-of-headers
 };
 
 /** possible types for http header fields */
@@ -139,31 +136,74 @@ enum class HdrFieldType {
     ftDate_1123_or_ETag
 };
 
+enum HdrKind {
+    None = 0,
+    ListHeader = 1,
+    RequestHeader = 1 << 1,
+    ReplyHeader = 1 << 2,
+    HopByHopHeader = 1 << 3,
+    Denied304Header = 1 << 4, //see comment in HttpReply.cc for meaning
+    GeneralHeader = RequestHeader | ReplyHeader,
+    EntityHeader = RequestHeader | ReplyHeader
+};
+
 /* POD for HeaderTable */
 class HeaderTableRecord {
+public:
+    HeaderTableRecord();
+    HeaderTableRecord(const char *n);
+    HeaderTableRecord(const char *, Http::HdrType, Http::HdrFieldType, int /* HdrKind */);
+
 public:
     const char *name;
     Http::HdrType id;
     Http::HdrFieldType type;
+    // flags set by constructor from HdrKind parameter
+    bool list;       ///<header with field values defined as #(values) in HTTP/1.1
+    bool request;    ///<header is a request header
+    bool reply;      ///<header is a reply header
+    bool hopbyhop;   ///<header is hop by hop
+    bool denied304;  ///<header is not to be updated on receiving a 304 in cache revalidation (see HttpReply.cc)
 };
 
-/// header ID->namelookup table.
-extern const HeaderTableRecord HeaderTable[];
-
-/** LookupTable for HTTP Header name -> Http::HdrType lookup.
+/** Class for looking up registered header definitions
  *
- * use as HeaderLookupTable.lookup(header-as-sbuf).
- * It will return Http::HdrType::HDR_BAD if the header is unknown/not registered,
- * including the case of Http::HdrType::OTHER, which will have to be handled
- * by the caller.
+ * Look up HeaderTableRecord's by name or registered header ID.
+ *
+ * Actual records are defined in file RegisteredHeadersHash.gperf, which is
+ * compiled using gperf to RegisteredHeadersHash.cci which is then included
+ * in RegisteredHeaders.cc.
  */
-extern const LookupTable<Http::HdrType, HeaderTableRecord> HeaderLookupTable;
+class HeaderLookupTable_t {
+public:
+    HeaderLookupTable_t();
+    /// look record type up by name (C-string and length)
+    const HeaderTableRecord& lookup (const char *buf, const std::size_t len) const;
+    /// look record type up by name (std::string)
+    const HeaderTableRecord& lookup (const std::string &key) const {
+        return lookup(key.data(), key.length());
+    }
+    /// look record type up by name (SBuf)
+    const HeaderTableRecord& lookup (const SBuf &key) const {
+        return lookup(key.rawContent(), key.length());
+    }
+    /// look record type up by header ID
+    const HeaderTableRecord& lookup (Http::HdrType id) const {
+        return *(idCache[static_cast<int>(id)]);
+    }
+
+private:
+    void initCache();
+    std::vector<const HeaderTableRecord *> idCache;
+    static const HeaderTableRecord BadHdr; ///<used to signal "not found" from lookups
+};
+extern const HeaderLookupTable_t HeaderLookupTable;
 
 /// match any known header type, including OTHER and BAD
 inline bool
 any_HdrType_enum_value (const Http::HdrType id)
 {
-    return (id >= Http::HdrType::ACCEPT && id < Http::HdrType::ENUM_END);
+    return (id >= Http::HdrType::enumBegin_ && id < Http::HdrType::enumEnd_);
 }
 
 /// match any valid header type, including OTHER but not BAD
@@ -0,0 +1,381 @@
+/* C++ code produced by gperf version 3.0.4 */
+/* Command-line: gperf --output-file=RegisteredHeadersHash.cci -m 100000 RegisteredHeadersHash.gperf  */
+/* Computed positions: -k'1,9,$' */
+
+#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
+&& ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
+&& (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
+&& ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
+&& ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
+&& ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
+&& ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
+&& ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
+&& ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
+&& ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
+&& ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
+&& ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
+&& ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
+&& ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
+&& ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
+&& ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
+&& ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
+&& ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
+&& ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
+&& ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
+&& ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
+&& ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
+&& ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
+/* The character set is not based on ISO-646.  */
+#error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
+#endif
+
+#line 1 "RegisteredHeadersHash.gperf"
+
+/* AUTO GENERATED FROM RegisteredHeadersHash.gperf. DO NOT EDIT */
+
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+#line 24 "RegisteredHeadersHash.gperf"
+struct HeaderTableRecord;
+        enum
+{
+    TOTAL_KEYWORDS = 88,
+    MIN_WORD_LENGTH = 2,
+    MAX_WORD_LENGTH = 25,
+    MIN_HASH_VALUE = 7,
+    MAX_HASH_VALUE = 113
+};
+
+/* maximum key range = 107, duplicates = 0 */
+
+#ifndef GPERF_DOWNCASE
+#define GPERF_DOWNCASE 1
+static unsigned char gperf_downcase[256] =
+{
+    0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,
+    15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
+    30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,
+    45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
+    60,  61,  62,  63,  64,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106,
+    107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121,
+    122,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103, 104,
+    105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
+    120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134,
+    135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149,
+    150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164,
+    165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179,
+    180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194,
+    195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209,
+    210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224,
+    225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
+    240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254,
+    255
+};
+#endif
+
+#ifndef GPERF_CASE_MEMCMP
+#define GPERF_CASE_MEMCMP 1
+static int
+gperf_case_memcmp (const char *s1, const char *s2, unsigned int n)
+{
+    for (; n > 0;)
+    {
+        unsigned char c1 = gperf_downcase[(unsigned char)*s1++];
+        unsigned char c2 = gperf_downcase[(unsigned char)*s2++];
+        if (c1 == c2)
+        {
+            n--;
+            continue;
+        }
+        return (int)c1 - (int)c2;
+    }
+    return 0;
+}
+#endif
+
+class HttpHeaderHashTable
+{
+private:
+    static inline unsigned int HttpHeaderHash (const char *str, unsigned int len);
+public:
+    static const struct HeaderTableRecord *lookup (const char *str, unsigned int len);
+};
+
+inline unsigned int
+HttpHeaderHashTable::HttpHeaderHash (const char *str, unsigned int len)
+{
+    static const unsigned char asso_values[] =
+    {
+        114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+        114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+        114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+        114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+        114, 114,  14, 114, 114,   5, 114, 114, 114, 114,
+        64, 114, 114,  14, 114, 114, 114, 114,   1, 114,
+        114, 114, 114, 114, 114,   4,   5,  15,  29,   1,
+        17,  60,  35,  19, 114,  51,  15,  42,   8,  50,
+        11, 114,   1,  19,   7,  28,   4,  41,  33,  15,
+        114, 114, 114, 114, 114, 114, 114,   4,   5,  15,
+        29,   1,  17,  60,  35,  19, 114,  51,  15,  42,
+        8,  50,  11, 114,   1,  19,   7,  28,   4,  41,
+        33,  15, 114, 114, 114, 114, 114, 114, 114, 114,
+        114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+        114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+        114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+        114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+        114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+        114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+        114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+        114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+        114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+        114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+        114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+        114, 114, 114, 114, 114, 114, 114, 114, 114, 114,
+        114, 114, 114, 114, 114, 114
+    };
+    int hval = len;
+
+    switch (hval)
+    {
+    default:
+        hval += asso_values[(unsigned char)str[8]];
+    /*FALLTHROUGH*/
+    case 8:
+    case 7:
+    case 6:
+    case 5:
+    case 4:
+    case 3:
+    case 2:
+    case 1:
+        hval += asso_values[(unsigned char)str[0]];
+        break;
+    }
+    return hval + asso_values[(unsigned char)str[len - 1]];
+}
+
+static const unsigned char lengthtable[] =
+{
+    0,  0,  0,  0,  0,  0,  0,  5,  3,  7,  2,  3,  0,  5,
+    6,  7, 13,  6,  9,  9, 11,  6,  6,  4, 15,  7,  6,  7,
+    8, 13, 13,  8,  6, 12,  4, 12,  7, 18, 18, 10, 13,  7,
+    13, 16,  0, 19,  4, 16, 13, 10,  5, 13, 17, 10, 16, 20,
+    17,  6, 19, 16, 14, 11,  8,  4,  6,  4, 10, 18, 15,  3,
+    4, 19, 13, 14, 10, 14, 13, 12, 15, 14, 15, 12, 11, 10,
+    9, 10,  7, 15, 19, 17,  0, 13, 16, 25,  0,  0,  0,  0,
+    0,  0, 21,  0,  0,  0,  0,  0,  0,  0,  7, 13,  0,  0,
+    0, 11
+};
+
+static const struct HeaderTableRecord HttpHeaderDefinitionsTable[] =
+{
+    {""}, {""}, {""}, {""}, {""}, {""}, {""},
+#line 78 "RegisteredHeadersHash.gperf"
+    {"Range", Http::HdrType::RANGE, Http::HdrFieldType::ftPRange, HdrKind::RequestHeader},
+#line 31 "RegisteredHeadersHash.gperf"
+    {"Age", Http::HdrType::AGE, Http::HdrFieldType::ftInt, HdrKind::ReplyHeader},
+#line 79 "RegisteredHeadersHash.gperf"
+    {"Referer", Http::HdrType::REFERER, Http::HdrFieldType::ftStr, HdrKind::RequestHeader},
+#line 85 "RegisteredHeadersHash.gperf"
+    {"TE", Http::HdrType::TE, Http::HdrFieldType::ftStr, HdrKind::RequestHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header},
+#line 94 "RegisteredHeadersHash.gperf"
+    {"Via", Http::HdrType::VIA, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader},
+    {""},
+#line 86 "RegisteredHeadersHash.gperf"
+    {"Title", Http::HdrType::TITLE, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 51 "RegisteredHeadersHash.gperf"
+    {"Expect", Http::HdrType::EXPECT, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader},
+#line 87 "RegisteredHeadersHash.gperf"
+    {"Trailer", Http::HdrType::TRAILER, Http::HdrFieldType::ftStr, HdrKind::HopByHopHeader|HdrKind::Denied304Header},
+#line 80 "RegisteredHeadersHash.gperf"
+    {"Request-Range", Http::HdrType::REQUEST_RANGE, Http::HdrFieldType::ftPRange, HdrKind::None},
+#line 26 "RegisteredHeadersHash.gperf"
+    {"Accept", Http::HdrType::ACCEPT, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader},
+#line 89 "RegisteredHeadersHash.gperf"
+    {"Translate", Http::HdrType::TRANSLATE, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 69 "RegisteredHeadersHash.gperf"
+    {"Negotiate", Http::HdrType::NEGOTIATE, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 81 "RegisteredHeadersHash.gperf"
+    {"Retry-After", Http::HdrType::RETRY_AFTER, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
+#line 71 "RegisteredHeadersHash.gperf"
+    {"Pragma", Http::HdrType::PRAGMA, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader},
+#line 47 "RegisteredHeadersHash.gperf"
+    {"Cookie", Http::HdrType::COOKIE, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 93 "RegisteredHeadersHash.gperf"
+    {"Vary", Http::HdrType::VARY, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader},
+#line 29 "RegisteredHeadersHash.gperf"
+    {"Accept-Language", Http::HdrType::ACCEPT_LANGUAGE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader},
+#line 109 "RegisteredHeadersHash.gperf"
+    {"FTP-Pre", Http::HdrType::FTP_PRE, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 82 "RegisteredHeadersHash.gperf"
+    {"Server", Http::HdrType::SERVER, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
+#line 52 "RegisteredHeadersHash.gperf"
+    {"Expires", Http::HdrType::EXPIRES, Http::HdrFieldType::ftDate_1123, HdrKind::EntityHeader},
+#line 60 "RegisteredHeadersHash.gperf"
+    {"If-Range", Http::HdrType::IF_RANGE, Http::HdrFieldType::ftDate_1123_or_ETag, HdrKind::None},
+#line 35 "RegisteredHeadersHash.gperf"
+    {"Authorization", Http::HdrType::AUTHORIZATION, Http::HdrFieldType::ftStr, HdrKind::RequestHeader},
+#line 45 "RegisteredHeadersHash.gperf"
+    {"Content-Range", Http::HdrType::CONTENT_RANGE, Http::HdrFieldType::ftPContRange, HdrKind::EntityHeader|HdrKind::Denied304Header},
+#line 66 "RegisteredHeadersHash.gperf"
+    {"Location", Http::HdrType::LOCATION, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
+#line 77 "RegisteredHeadersHash.gperf"
+    {"Public", Http::HdrType::PUBLIC, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
+#line 38 "RegisteredHeadersHash.gperf"
+    {"Content-Base", Http::HdrType::CONTENT_BASE, Http::HdrFieldType::ftStr, HdrKind::EntityHeader},
+#line 49 "RegisteredHeadersHash.gperf"
+    {"Date", Http::HdrType::DATE, Http::HdrFieldType::ftDate_1123, HdrKind::GeneralHeader},
+#line 46 "RegisteredHeadersHash.gperf"
+    {"Content-Type", Http::HdrType::CONTENT_TYPE, Http::HdrFieldType::ftStr, HdrKind::EntityHeader|HdrKind::Denied304Header},
+#line 91 "RegisteredHeadersHash.gperf"
+    {"Upgrade", Http::HdrType::UPGRADE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header},
+#line 72 "RegisteredHeadersHash.gperf"
+    {"Proxy-Authenticate", Http::HdrType::PROXY_AUTHENTICATE, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader|HdrKind::Denied304Header},
+#line 33 "RegisteredHeadersHash.gperf"
+    {"Alternate-Protocol", Http::HdrType::ALTERNATE_PROTOCOL, Http::HdrFieldType::ftStr, HdrKind::HopByHopHeader},
+#line 113 "RegisteredHeadersHash.gperf"
+    {"*INVALID*:", Http::HdrType::BAD_HDR, Http::HdrFieldType::ftInvalid, HdrKind::None},
+#line 30 "RegisteredHeadersHash.gperf"
+    {"Accept-Ranges", Http::HdrType::ACCEPT_RANGES, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader},
+#line 97 "RegisteredHeadersHash.gperf"
+    {"X-Cache", Http::HdrType::X_CACHE, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
+#line 76 "RegisteredHeadersHash.gperf"
+    {"Proxy-support", Http::HdrType::PROXY_SUPPORT, Http::HdrFieldType::ftStr, HdrKind::ListHeader},
+#line 75 "RegisteredHeadersHash.gperf"
+    {"Proxy-Connection", Http::HdrType::PROXY_CONNECTION, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader},
+    {""},
+#line 74 "RegisteredHeadersHash.gperf"
+    {"Proxy-Authorization", Http::HdrType::PROXY_AUTHORIZATION, Http::HdrFieldType::ftStr, HdrKind::RequestHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header},
+#line 55 "RegisteredHeadersHash.gperf"
+    {"Host", Http::HdrType::HOST, Http::HdrFieldType::ftStr, HdrKind::RequestHeader},
+#line 41 "RegisteredHeadersHash.gperf"
+    {"Content-Language", Http::HdrType::CONTENT_LANGUAGE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader|HdrKind::Denied304Header},
+#line 101 "RegisteredHeadersHash.gperf"
+    {"X-Squid-Error", Http::HdrType::X_SQUID_ERROR, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
+#line 83 "RegisteredHeadersHash.gperf"
+    {"Set-Cookie", Http::HdrType::SET_COOKIE, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
+#line 32 "RegisteredHeadersHash.gperf"
+    {"Allow", Http::HdrType::ALLOW, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader|HdrKind::Denied304Header},
+#line 36 "RegisteredHeadersHash.gperf"
+    {"Cache-Control", Http::HdrType::CACHE_CONTROL, Http::HdrFieldType::ftPCc, HdrKind::ListHeader|HdrKind::GeneralHeader},
+#line 105 "RegisteredHeadersHash.gperf"
+    {"Surrogate-Control", Http::HdrType::SURROGATE_CONTROL, Http::HdrFieldType::ftPSc, HdrKind::ListHeader|HdrKind::ReplyHeader},
+#line 92 "RegisteredHeadersHash.gperf"
+    {"User-Agent", Http::HdrType::USER_AGENT, Http::HdrFieldType::ftStr, HdrKind::RequestHeader},
+#line 43 "RegisteredHeadersHash.gperf"
+    {"Content-Location", Http::HdrType::CONTENT_LOCATION, Http::HdrFieldType::ftStr, HdrKind::EntityHeader},
+#line 104 "RegisteredHeadersHash.gperf"
+    {"Surrogate-Capability", Http::HdrType::SURROGATE_CAPABILITY, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader},
+#line 58 "RegisteredHeadersHash.gperf"
+    {"If-Modified-Since", Http::HdrType::IF_MODIFIED_SINCE, Http::HdrFieldType::ftDate_1123, HdrKind::RequestHeader},
+#line 112 "RegisteredHeadersHash.gperf"
+    {"Other:", Http::HdrType::OTHER, Http::HdrFieldType::ftStr, HdrKind::EntityHeader},
+#line 61 "RegisteredHeadersHash.gperf"
+    {"If-Unmodified-Since", Http::HdrType::IF_UNMODIFIED_SINCE, Http::HdrFieldType::ftDate_1123, HdrKind::None},
+#line 96 "RegisteredHeadersHash.gperf"
+    {"WWW-Authenticate", Http::HdrType::WWW_AUTHENTICATE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader},
+#line 27 "RegisteredHeadersHash.gperf"
+    {"Accept-Charset", Http::HdrType::ACCEPT_CHARSET, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader},
+#line 107 "RegisteredHeadersHash.gperf"
+    {"FTP-Command", Http::HdrType::FTP_COMMAND, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 57 "RegisteredHeadersHash.gperf"
+    {"If-Match", Http::HdrType::IF_MATCH, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader},
+#line 54 "RegisteredHeadersHash.gperf"
+    {"From", Http::HdrType::FROM, Http::HdrFieldType::ftStr, HdrKind::RequestHeader},
+#line 70 "RegisteredHeadersHash.gperf"
+    {"Origin", Http::HdrType::ORIGIN, Http::HdrFieldType::ftStr, HdrKind::RequestHeader},
+#line 50 "RegisteredHeadersHash.gperf"
+    {"ETag", Http::HdrType::ETAG, Http::HdrFieldType::ftETag, HdrKind::EntityHeader},
+#line 62 "RegisteredHeadersHash.gperf"
+    {"Keep-Alive", Http::HdrType::KEEP_ALIVE, Http::HdrFieldType::ftStr, HdrKind::HopByHopHeader|HdrKind::Denied304Header},
+#line 102 "RegisteredHeadersHash.gperf"
+    {"X-Accelerator-Vary", Http::HdrType::HDR_X_ACCELERATOR_VARY, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader},
+#line 103 "RegisteredHeadersHash.gperf"
+    {"X-Next-Services", Http::HdrType::X_NEXT_SERVICES, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader},
+#line 63 "RegisteredHeadersHash.gperf"
+    {"Key", Http::HdrType::KEY, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader},
+#line 65 "RegisteredHeadersHash.gperf"
+    {"Link", Http::HdrType::LINK, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader},
+#line 39 "RegisteredHeadersHash.gperf"
+    {"Content-Disposition", Http::HdrType::CONTENT_DISPOSITION, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 100 "RegisteredHeadersHash.gperf"
+    {"X-Request-URI", Http::HdrType::X_REQUEST_URI, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
+#line 98 "RegisteredHeadersHash.gperf"
+    {"X-Cache-Lookup", Http::HdrType::X_CACHE_LOOKUP, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader},
+#line 110 "RegisteredHeadersHash.gperf"
+    {"FTP-Status", Http::HdrType::FTP_STATUS, Http::HdrFieldType::ftInt, HdrKind::None},
+#line 56 "RegisteredHeadersHash.gperf"
+    {"HTTP2-Settings", Http::HdrType::HTTP2_SETTINGS, Http::HdrFieldType::ftStr, HdrKind::RequestHeader|HdrKind::HopByHopHeader},
+#line 64 "RegisteredHeadersHash.gperf"
+    {"Last-Modified", Http::HdrType::LAST_MODIFIED, Http::HdrFieldType::ftDate_1123, HdrKind::EntityHeader|HdrKind::Denied304Header},
+#line 67 "RegisteredHeadersHash.gperf"
+    {"Max-Forwards", Http::HdrType::MAX_FORWARDS, Http::HdrFieldType::ftInt64, HdrKind::RequestHeader},
+#line 99 "RegisteredHeadersHash.gperf"
+    {"X-Forwarded-For", Http::HdrType::X_FORWARDED_FOR, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader},
+#line 42 "RegisteredHeadersHash.gperf"
+    {"Content-Length", Http::HdrType::CONTENT_LENGTH, Http::HdrFieldType::ftInt64, HdrKind::EntityHeader|HdrKind::Denied304Header},
+#line 106 "RegisteredHeadersHash.gperf"
+    {"Front-End-Https", Http::HdrType::FRONT_END_HTTPS, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 68 "RegisteredHeadersHash.gperf"
+    {"Mime-Version", Http::HdrType::MIME_VERSION, Http::HdrFieldType::ftStr, HdrKind::GeneralHeader},
+#line 44 "RegisteredHeadersHash.gperf"
+    {"Content-MD5", Http::HdrType::CONTENT_MD5, Http::HdrFieldType::ftStr, HdrKind::EntityHeader|HdrKind::Denied304Header},
+#line 37 "RegisteredHeadersHash.gperf"
+    {"Connection", Http::HdrType::CONNECTION, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header},
+#line 53 "RegisteredHeadersHash.gperf"
+    {"Forwarded", Http::HdrType::FORWARDED, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader},
+#line 111 "RegisteredHeadersHash.gperf"
+    {"FTP-Reason", Http::HdrType::FTP_REASON, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 48 "RegisteredHeadersHash.gperf"
+    {"Cookie2", Http::HdrType::COOKIE2, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 28 "RegisteredHeadersHash.gperf"
+    {"Accept-Encoding", Http::HdrType::ACCEPT_ENCODING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader|HdrKind::ReplyHeader},
+#line 34 "RegisteredHeadersHash.gperf"
+    {"Authentication-Info", Http::HdrType::AUTHENTICATION_INFO, Http::HdrFieldType::ftStr, HdrKind::ListHeader},
+#line 88 "RegisteredHeadersHash.gperf"
+    {"Transfer-Encoding", Http::HdrType::TRANSFER_ENCODING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header},
+    {""},
+#line 108 "RegisteredHeadersHash.gperf"
+    {"FTP-Arguments", Http::HdrType::FTP_ARGUMENTS, Http::HdrFieldType::ftStr, HdrKind::None},
+#line 40 "RegisteredHeadersHash.gperf"
+    {"Content-Encoding", Http::HdrType::CONTENT_ENCODING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader|HdrKind::Denied304Header},
+#line 73 "RegisteredHeadersHash.gperf"
+    {"Proxy-Authentication-Info", Http::HdrType::PROXY_AUTHENTICATION_INFO, Http::HdrFieldType::ftStr, HdrKind::ListHeader},
+    {""}, {""}, {""}, {""}, {""}, {""},
+#line 90 "RegisteredHeadersHash.gperf"
+    {"Unless-Modified-Since", Http::HdrType::UNLESS_MODIFIED_SINCE, Http::HdrFieldType::ftStr, HdrKind::None},
+    {""}, {""}, {""}, {""}, {""}, {""}, {""},
+#line 95 "RegisteredHeadersHash.gperf"
+    {"Warning", Http::HdrType::WARNING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader},
+#line 59 "RegisteredHeadersHash.gperf"
+    {"If-None-Match", Http::HdrType::IF_NONE_MATCH, Http::HdrFieldType::ftStr, HdrKind::ListHeader},
+    {""}, {""}, {""},
+#line 84 "RegisteredHeadersHash.gperf"
+    {"Set-Cookie2", Http::HdrType::SET_COOKIE2, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader}
+};
+
+const struct HeaderTableRecord *
+HttpHeaderHashTable::lookup (const char *str, unsigned int len)
+{
+    if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
+    {
+        int key = HttpHeaderHash (str, len);
+
+        if (key <= MAX_HASH_VALUE && key >= 0)
+            if (len == lengthtable[key])
+            {
+                const char *s = HttpHeaderDefinitionsTable[key].name;
+
+                if ((((unsigned char)*str ^ (unsigned char)*s) & ~32) == 0 && !gperf_case_memcmp (str, s, len))
+                    return &HttpHeaderDefinitionsTable[key];
+            }
+    }
+    return 0;
+}
+#line 114 "RegisteredHeadersHash.gperf"
+
@@ -0,0 +1,114 @@
+%{
+/* AUTO GENERATED FROM RegisteredHeadersHash.gperf. DO NOT EDIT */
+
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+%}
+%language=C++
+%define hash-function-name HttpHeaderHash
+%define lookup-function-name lookup
+%define class-name HttpHeaderHashTable
+%define word-array-name HttpHeaderDefinitionsTable
+%compare-lengths
+%compare-strncmp
+%readonly-tables
+%enum
+%global-table
+%ignore-case
+%struct-type 
+struct HeaderTableRecord;
+%%
+Accept, Http::HdrType::ACCEPT, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader
+Accept-Charset, Http::HdrType::ACCEPT_CHARSET, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader
+Accept-Encoding, Http::HdrType::ACCEPT_ENCODING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader|HdrKind::ReplyHeader
+Accept-Language, Http::HdrType::ACCEPT_LANGUAGE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader
+Accept-Ranges, Http::HdrType::ACCEPT_RANGES, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader
+Age, Http::HdrType::AGE, Http::HdrFieldType::ftInt, HdrKind::ReplyHeader
+Allow, Http::HdrType::ALLOW, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader|HdrKind::Denied304Header
+Alternate-Protocol, Http::HdrType::ALTERNATE_PROTOCOL, Http::HdrFieldType::ftStr, HdrKind::HopByHopHeader
+Authentication-Info, Http::HdrType::AUTHENTICATION_INFO, Http::HdrFieldType::ftStr, HdrKind::ListHeader
+Authorization, Http::HdrType::AUTHORIZATION, Http::HdrFieldType::ftStr, HdrKind::RequestHeader
+Cache-Control, Http::HdrType::CACHE_CONTROL, Http::HdrFieldType::ftPCc, HdrKind::ListHeader|HdrKind::GeneralHeader
+Connection, Http::HdrType::CONNECTION, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header
+Content-Base, Http::HdrType::CONTENT_BASE, Http::HdrFieldType::ftStr, HdrKind::EntityHeader
+Content-Disposition, Http::HdrType::CONTENT_DISPOSITION, Http::HdrFieldType::ftStr, HdrKind::None
+Content-Encoding, Http::HdrType::CONTENT_ENCODING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader|HdrKind::Denied304Header
+Content-Language, Http::HdrType::CONTENT_LANGUAGE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader|HdrKind::Denied304Header
+Content-Length, Http::HdrType::CONTENT_LENGTH, Http::HdrFieldType::ftInt64, HdrKind::EntityHeader|HdrKind::Denied304Header
+Content-Location, Http::HdrType::CONTENT_LOCATION, Http::HdrFieldType::ftStr, HdrKind::EntityHeader
+Content-MD5, Http::HdrType::CONTENT_MD5, Http::HdrFieldType::ftStr, HdrKind::EntityHeader|HdrKind::Denied304Header
+Content-Range, Http::HdrType::CONTENT_RANGE, Http::HdrFieldType::ftPContRange, HdrKind::EntityHeader|HdrKind::Denied304Header
+Content-Type, Http::HdrType::CONTENT_TYPE, Http::HdrFieldType::ftStr, HdrKind::EntityHeader|HdrKind::Denied304Header
+Cookie, Http::HdrType::COOKIE, Http::HdrFieldType::ftStr, HdrKind::None
+Cookie2, Http::HdrType::COOKIE2, Http::HdrFieldType::ftStr, HdrKind::None
+Date, Http::HdrType::DATE, Http::HdrFieldType::ftDate_1123, HdrKind::GeneralHeader
+ETag, Http::HdrType::ETAG, Http::HdrFieldType::ftETag, HdrKind::EntityHeader
+Expect, Http::HdrType::EXPECT, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader
+Expires, Http::HdrType::EXPIRES, Http::HdrFieldType::ftDate_1123, HdrKind::EntityHeader
+Forwarded, Http::HdrType::FORWARDED, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader
+From, Http::HdrType::FROM, Http::HdrFieldType::ftStr, HdrKind::RequestHeader
+Host, Http::HdrType::HOST, Http::HdrFieldType::ftStr, HdrKind::RequestHeader
+HTTP2-Settings, Http::HdrType::HTTP2_SETTINGS, Http::HdrFieldType::ftStr, HdrKind::RequestHeader|HdrKind::HopByHopHeader
+If-Match, Http::HdrType::IF_MATCH, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader
+If-Modified-Since, Http::HdrType::IF_MODIFIED_SINCE, Http::HdrFieldType::ftDate_1123, HdrKind::RequestHeader
+If-None-Match, Http::HdrType::IF_NONE_MATCH, Http::HdrFieldType::ftStr, HdrKind::ListHeader
+If-Range, Http::HdrType::IF_RANGE, Http::HdrFieldType::ftDate_1123_or_ETag, HdrKind::None
+If-Unmodified-Since, Http::HdrType::IF_UNMODIFIED_SINCE, Http::HdrFieldType::ftDate_1123, HdrKind::None
+Keep-Alive, Http::HdrType::KEEP_ALIVE, Http::HdrFieldType::ftStr, HdrKind::HopByHopHeader|HdrKind::Denied304Header
+Key, Http::HdrType::KEY, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader
+Last-Modified, Http::HdrType::LAST_MODIFIED, Http::HdrFieldType::ftDate_1123, HdrKind::EntityHeader|HdrKind::Denied304Header
+Link, Http::HdrType::LINK, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::EntityHeader
+Location, Http::HdrType::LOCATION, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+Max-Forwards, Http::HdrType::MAX_FORWARDS, Http::HdrFieldType::ftInt64, HdrKind::RequestHeader
+Mime-Version, Http::HdrType::MIME_VERSION, Http::HdrFieldType::ftStr, HdrKind::GeneralHeader
+Negotiate, Http::HdrType::NEGOTIATE, Http::HdrFieldType::ftStr, HdrKind::None
+Origin, Http::HdrType::ORIGIN, Http::HdrFieldType::ftStr, HdrKind::RequestHeader
+Pragma, Http::HdrType::PRAGMA, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader
+Proxy-Authenticate, Http::HdrType::PROXY_AUTHENTICATE, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader|HdrKind::Denied304Header
+Proxy-Authentication-Info, Http::HdrType::PROXY_AUTHENTICATION_INFO, Http::HdrFieldType::ftStr, HdrKind::ListHeader
+Proxy-Authorization, Http::HdrType::PROXY_AUTHORIZATION, Http::HdrFieldType::ftStr, HdrKind::RequestHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header
+Proxy-Connection, Http::HdrType::PROXY_CONNECTION, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader
+Proxy-support, Http::HdrType::PROXY_SUPPORT, Http::HdrFieldType::ftStr, HdrKind::ListHeader
+Public, Http::HdrType::PUBLIC, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+Range, Http::HdrType::RANGE, Http::HdrFieldType::ftPRange, HdrKind::RequestHeader
+Referer, Http::HdrType::REFERER, Http::HdrFieldType::ftStr, HdrKind::RequestHeader
+Request-Range, Http::HdrType::REQUEST_RANGE, Http::HdrFieldType::ftPRange, HdrKind::None
+Retry-After, Http::HdrType::RETRY_AFTER, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+Server, Http::HdrType::SERVER, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+Set-Cookie, Http::HdrType::SET_COOKIE, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+Set-Cookie2, Http::HdrType::SET_COOKIE2, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+TE, Http::HdrType::TE, Http::HdrFieldType::ftStr, HdrKind::RequestHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header
+Title, Http::HdrType::TITLE, Http::HdrFieldType::ftStr, HdrKind::None
+Trailer, Http::HdrType::TRAILER, Http::HdrFieldType::ftStr, HdrKind::HopByHopHeader|HdrKind::Denied304Header
+Transfer-Encoding, Http::HdrType::TRANSFER_ENCODING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header
+Translate, Http::HdrType::TRANSLATE, Http::HdrFieldType::ftStr, HdrKind::None
+Unless-Modified-Since, Http::HdrType::UNLESS_MODIFIED_SINCE, Http::HdrFieldType::ftStr, HdrKind::None
+Upgrade, Http::HdrType::UPGRADE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader|HdrKind::HopByHopHeader|HdrKind::Denied304Header
+User-Agent, Http::HdrType::USER_AGENT, Http::HdrFieldType::ftStr, HdrKind::RequestHeader
+Vary, Http::HdrType::VARY, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader
+Via, Http::HdrType::VIA, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader
+Warning, Http::HdrType::WARNING, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader
+WWW-Authenticate, Http::HdrType::WWW_AUTHENTICATE, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader
+X-Cache, Http::HdrType::X_CACHE, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+X-Cache-Lookup, Http::HdrType::X_CACHE_LOOKUP, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+X-Forwarded-For, Http::HdrType::X_FORWARDED_FOR, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::GeneralHeader
+X-Request-URI, Http::HdrType::X_REQUEST_URI, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+X-Squid-Error, Http::HdrType::X_SQUID_ERROR, Http::HdrFieldType::ftStr, HdrKind::ReplyHeader
+X-Accelerator-Vary, Http::HdrType::HDR_X_ACCELERATOR_VARY, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader
+X-Next-Services, Http::HdrType::X_NEXT_SERVICES, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::ReplyHeader
+Surrogate-Capability, Http::HdrType::SURROGATE_CAPABILITY, Http::HdrFieldType::ftStr, HdrKind::ListHeader|HdrKind::RequestHeader
+Surrogate-Control, Http::HdrType::SURROGATE_CONTROL, Http::HdrFieldType::ftPSc, HdrKind::ListHeader|HdrKind::ReplyHeader
+Front-End-Https, Http::HdrType::FRONT_END_HTTPS, Http::HdrFieldType::ftStr, HdrKind::None
+FTP-Command, Http::HdrType::FTP_COMMAND, Http::HdrFieldType::ftStr, HdrKind::None
+FTP-Arguments, Http::HdrType::FTP_ARGUMENTS, Http::HdrFieldType::ftStr, HdrKind::None
+FTP-Pre, Http::HdrType::FTP_PRE, Http::HdrFieldType::ftStr, HdrKind::None
+FTP-Status, Http::HdrType::FTP_STATUS, Http::HdrFieldType::ftInt, HdrKind::None
+FTP-Reason, Http::HdrType::FTP_REASON, Http::HdrFieldType::ftStr, HdrKind::None
+Other:, Http::HdrType::OTHER, Http::HdrFieldType::ftStr, HdrKind::EntityHeader
+*INVALID*:, Http::HdrType::BAD_HDR, Http::HdrFieldType::ftInvalid, HdrKind::None
+%%
@@ -44,6 +44,8 @@ COPIED_SOURCE= \
 	SquidConfig.cc \
 	SquidNew.cc \
 	stub_HelperChildConfig.cc \
+	stub_libmem.cc \
+	STUB.h \
 	time.cc
 
 # ICMP lookup helper
@@ -83,19 +85,25 @@ CLEANFILES += $(COPIED_SOURCE)
 ## files we need to pull in from other locations
 ## copied like this to avoid subdir-objects collisions on 'make clean'
 debug.cc: $(top_srcdir)/src/debug.cc
-	cp $(top_srcdir)/src/debug.cc .
+	cp $(top_srcdir)/src/debug.cc $@
 
 globals.cc: $(top_srcdir)/src/globals.h
-	cp $(top_builddir)/src/globals.cc .
+	cp $(top_builddir)/src/globals.cc $@
 
 time.cc: $(top_srcdir)/src/time.cc
-	cp $(top_srcdir)/src/time.cc .
+	cp $(top_srcdir)/src/time.cc $@
 
 SquidConfig.cc: $(top_srcdir)/src/SquidConfig.cc
-	cp $(top_srcdir)/src/SquidConfig.cc .
+	cp $(top_srcdir)/src/SquidConfig.cc $@
 
 SquidNew.cc: $(top_srcdir)/src/SquidNew.cc
-	cp $(top_srcdir)/src/SquidNew.cc .
+	cp $(top_srcdir)/src/SquidNew.cc $@
 
 stub_HelperChildConfig.cc: $(top_srcdir)/src/tests/stub_HelperChildConfig.cc
-	cp $(top_srcdir)/src/tests/stub_HelperChildConfig.cc .
+	cp $(top_srcdir)/src/tests/stub_HelperChildConfig.cc $@
+
+stub_libmem.cc: $(top_srcdir)/src/tests/stub_libmem.cc STUB.h
+	cp $(top_srcdir)/src/tests/stub_libmem.cc $@
+
+STUB.h: $(top_srcdir)/src/tests/STUB.h
+	cp $(top_srcdir)/src/tests/STUB.h $@
@@ -118,9 +118,6 @@ static net_db_peer *netdbPeerByName(const netdbEntry * n, const char *);
 static net_db_peer *netdbPeerAdd(netdbEntry * n, CachePeer * e);
 static const char *netdbPeerName(const char *name);
 static IPH netdbSendPing;
-static QS sortPeerByRtt;
-static QS sortByRtt;
-static QS netdbLRU;
 static FREE netdbFreeNameEntry;
 static FREE netdbFreeNetdbEntry;
 static STCB netdbExchangeHandleReply;
@@ -10,8 +10,9 @@
 #define _SQUID_ICP_OPCODE_H
 
 /// \ingroup ServerProtocolICPAPI
-typedef enum {
-    ICP_INVALID,
+enum icp_opcode {
+    enumBegin_ = 0,
+    ICP_INVALID = enumBegin_,
     ICP_QUERY,
     ICP_HIT,
     ICP_MISS,
@@ -35,8 +36,9 @@ typedef enum {
     ICP_MISS_NOFETCH,
     ICP_DENIED,
     ICP_HIT_OBJ,
-    ICP_END
-} icp_opcode;
+    ICP_END,
+    enumEnd_ = ICP_END // We misuse ICP_END in stats. Do not do this elsewhere.
+};
 
 extern const char *icp_opcode_str[];
 
@@ -101,10 +101,10 @@ _icp_common_t::_icp_common_t(char *buf, unsigned int len) :
 icp_opcode
 _icp_common_t::getOpCode() const
 {
-    if (opcode > (char)ICP_END)
+    if (opcode > static_cast<char>(icp_opcode::ICP_END))
         return ICP_INVALID;
 
-    return (icp_opcode)opcode;
+    return static_cast<icp_opcode>(opcode);
 }
 
 /* ICPState */
@@ -777,14 +777,14 @@ icpCount(void *buf, int which, size_t len, int delay)
 
     if (SENT == which) {
         ++statCounter.icp.pkts_sent;
-        kb_incr(&statCounter.icp.kbytes_sent, len);
+        statCounter.icp.kbytes_sent += len;
 
         if (ICP_QUERY == icp->opcode) {
             ++statCounter.icp.queries_sent;
-            kb_incr(&statCounter.icp.q_kbytes_sent, len);
+            statCounter.icp.q_kbytes_sent += len;
         } else {
             ++statCounter.icp.replies_sent;
-            kb_incr(&statCounter.icp.r_kbytes_sent, len);
+            statCounter.icp.r_kbytes_sent += len;
             /* this is the sent-reply service time */
             statCounter.icp.replySvcTime.count(delay);
         }
@@ -793,14 +793,14 @@ icpCount(void *buf, int which, size_t len, int delay)
             ++statCounter.icp.hits_sent;
     } else if (RECV == which) {
         ++statCounter.icp.pkts_recv;
-        kb_incr(&statCounter.icp.kbytes_recv, len);
+        statCounter.icp.kbytes_recv += len;
 
         if (ICP_QUERY == icp->opcode) {
             ++statCounter.icp.queries_recv;
-            kb_incr(&statCounter.icp.q_kbytes_recv, len);
+            statCounter.icp.q_kbytes_recv += len;
         } else {
             ++statCounter.icp.replies_recv;
-            kb_incr(&statCounter.icp.r_kbytes_recv, len);
+            statCounter.icp.r_kbytes_recv += len;
             /* statCounter.icp.querySvcTime set in clientUpdateCounters */
         }
 
@@ -200,6 +200,19 @@ Ip::Intercept::IpfInterception(const Comm::ConnectionPointer &newConn, int silen
     // all fields must be set to 0
     memset(&natLookup, 0, sizeof(natLookup));
     // for NAT lookup set local and remote IP:port's
+    if (newConn->remote.isIPv6()) {
+#if IPFILTER_VERSION < 5000003
+        // warn once every 10 at critical level, then push down a level each repeated event
+        static int warningLevel = DBG_CRITICAL;
+        debugs(89, warningLevel, "IPF (IPFilter v4) NAT does not support IPv6. Please upgrade to IPFilter v5.1");
+        warningLevel = ++warningLevel % 10;
+        return false;
+#else
+        natLookup.nl_v = 6;
+    } else {
+        natLookup.nl_v = 4;
+#endif
+    }
     natLookup.nl_inport = htons(newConn->local.port());
     newConn->local.getInAddr(natLookup.nl_inip);
     natLookup.nl_outport = htons(newConn->remote.port());
@@ -17,5 +17,9 @@ namespace Ip
 {
 class Address;
 }
+
+typedef uint32_t nfmark_t;
+typedef unsigned char tos_t;
+
 #endif /* _SQUID_IP_FORWARD_H */
 
@@ -10,12 +10,13 @@
 #define SQUID_IPC_STORE_MAP_H
 
 #include "Debug.h"
+#include "fs/forward.h"
 #include "ipc/mem/FlexibleArray.h"
 #include "ipc/mem/Pointer.h"
 #include "ipc/ReadWriteLock.h"
 #include "SBuf.h"
+#include "store_key_md5.h"
 #include "tools.h"
-#include "typedefs.h"
 
 #include <atomic>
 
@@ -21,6 +21,7 @@
 #include "ipc/TypedMsgHdr.h"
 #include "tools.h"
 
+#include <list>
 #include <map>
 
 /// holds information necessary to handle JoinListen response
@@ -35,6 +36,10 @@ class PendingOpenRequest
 typedef std::map<int, PendingOpenRequest> SharedListenRequestMap;
 static SharedListenRequestMap TheSharedListenRequestMap;
 
+/// accumulates delayed requests until they are ready to be sent, in FIFO order
+typedef std::list<PendingOpenRequest> DelayedSharedListenRequests;
+static DelayedSharedListenRequests TheDelayedRequests;
+
 static int
 AddToMap(const PendingOpenRequest &por)
 {
@@ -106,31 +111,59 @@ void Ipc::SharedListenResponse::pack(TypedMsgHdr &hdrMsg) const
     hdrMsg.putFd(fd);
 }
 
-void Ipc::JoinSharedListen(const OpenListenerParams &params,
-                           AsyncCall::Pointer &callback)
+static void
+SendSharedListenRequest(const PendingOpenRequest &por)
 {
-    PendingOpenRequest por;
-    por.params = params;
-    por.callback = callback;
-
-    SharedListenRequest request;
+    Ipc::SharedListenRequest request;
     request.requestorId = KidIdentifier;
     request.params = por.params;
     request.mapId = AddToMap(por);
 
-    debugs(54, 3, HERE << "getting listening FD for " << request.params.addr <<
+    debugs(54, 3, "getting listening FD for " << request.params.addr <<
            " mapId=" << request.mapId);
 
-    TypedMsgHdr message;
+    Ipc::TypedMsgHdr message;
     request.pack(message);
     SendMessage(Ipc::Port::CoordinatorAddr(), message);
 }
 
+static void
+kickDelayedRequest()
+{
+    if (TheDelayedRequests.empty())
+        return; // no pending requests to resume
+
+    debugs(54, 3, "resuming with " << TheSharedListenRequestMap.size() <<
+           " active + " << TheDelayedRequests.size() << " delayed requests");
+
+    SendSharedListenRequest(*TheDelayedRequests.begin());
+    TheDelayedRequests.pop_front();
+}
+
+void
+Ipc::JoinSharedListen(const OpenListenerParams &params, AsyncCall::Pointer &cb)
+{
+    PendingOpenRequest por;
+    por.params = params;
+    por.callback = cb;
+
+    const DelayedSharedListenRequests::size_type concurrencyLimit = 1;
+    if (TheSharedListenRequestMap.size() >= concurrencyLimit) {
+        debugs(54, 3, "waiting for " << TheSharedListenRequestMap.size() <<
+               " active + " << TheDelayedRequests.size() << " delayed requests");
+        TheDelayedRequests.push_back(por);
+    } else {
+        SendSharedListenRequest(por);
+    }
+}
+
 void Ipc::SharedListenJoined(const SharedListenResponse &response)
 {
     // Dont debugs c fully since only FD is filled right now.
-    debugs(54, 3, HERE << "got listening FD " << response.fd << " errNo=" <<
-           response.errNo << " mapId=" << response.mapId);
+    debugs(54, 3, "got listening FD " << response.fd << " errNo=" <<
+           response.errNo << " mapId=" << response.mapId << " with " <<
+           TheSharedListenRequestMap.size() << " active + " <<
+           TheDelayedRequests.size() << " delayed requests");
 
     Must(TheSharedListenRequestMap.find(response.mapId) != TheSharedListenRequestMap.end());
     PendingOpenRequest por = TheSharedListenRequestMap[response.mapId];
@@ -158,5 +191,7 @@ void Ipc::SharedListenJoined(const SharedListenResponse &response)
     cbd->errNo = response.errNo;
     cbd->handlerSubscription = por.params.handlerSubscription;
     ScheduleCallHere(por.callback);
+
+    kickDelayedRequest();
 }
 
@@ -9,11 +9,12 @@
 #ifndef SQUID_IPC_STORE_MAP_H
 #define SQUID_IPC_STORE_MAP_H
 
+#include "fs/forward.h"
 #include "ipc/mem/FlexibleArray.h"
 #include "ipc/mem/Pointer.h"
 #include "ipc/ReadWriteLock.h"
 #include "SBuf.h"
-#include "typedefs.h"
+#include "store_key_md5.h"
 
 namespace Ipc
 {
@@ -28,8 +28,10 @@ Mem::AllocatorProxy::freeOne(void *address)
 MemAllocator *
 Mem::AllocatorProxy::getAllocator() const
 {
-    if (!theAllocator)
+    if (!theAllocator) {
         theAllocator = MemPools::GetInstance().create(objectType(), size);
+        theAllocator->zeroBlocks(doZero);
+    }
     return theAllocator;
 }
 
@@ -42,6 +44,12 @@ Mem::AllocatorProxy::inUseCount() const
         return memPoolInUseCount(theAllocator);
 }
 
+void
+Mem::AllocatorProxy::zeroBlocks(bool doIt)
+{
+    getAllocator()->zeroBlocks(doIt);
+}
+
 MemPoolMeter const &
 Mem::AllocatorProxy::getMeter() const
 {
@@ -18,11 +18,15 @@ class MemPoolMeter;
  *
  * Pool and account the memory used for the CLASS object.
  * This macro is intended for use within the declaration of a class.
+ *
+ * The memory block allocated by operator new is not zeroed; it is the
+ * responsibility of users to ensure that constructors correctly
+ * initialize all data members.
  */
 #define MEMPROXY_CLASS(CLASS) \
     private: \
     static inline Mem::AllocatorProxy &Pool() { \
-        static Mem::AllocatorProxy thePool(#CLASS, sizeof(CLASS)); \
+        static Mem::AllocatorProxy thePool(#CLASS, sizeof(CLASS), false); \
         return thePool; \
     } \
     public: \
@@ -43,10 +47,11 @@ namespace Mem
 class AllocatorProxy
 {
 public:
-    AllocatorProxy(char const *aLabel, size_t const &aSize):
+    AllocatorProxy(char const *aLabel, size_t const &aSize, bool doZeroBlocks = true):
         label(aLabel),
         size(aSize),
-        theAllocator(NULL)
+        theAllocator(nullptr),
+        doZero(doZeroBlocks)
     {}
 
     /// Allocate one element from the pool
@@ -67,12 +72,15 @@ class AllocatorProxy
      */
     int getStats(MemPoolStats * stats);
 
+    void zeroBlocks(bool doIt);
+
 private:
     MemAllocator *getAllocator() const;
 
     const char *label;
     size_t size;
     mutable MemAllocator *theAllocator;
+    bool doZero;
 };
 
 } // namespace Mem
@@ -15,6 +15,7 @@ libmem_la_SOURCES = \
 	AllocatorProxy.h \
 	forward.h \
 	old_api.cc \
+	Meter.h \
 	Pool.cc \
 	Pool.h \
 	PoolChunked.cc \
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_SRC_MEM_METER_H
+#define SQUID_SRC_MEM_METER_H
+
+#include "SquidTime.h"
+
+namespace Mem
+{
+
+/**
+ * object to track per-action memory usage (e.g. #idle objects)
+ */
+class Meter
+{
+public:
+    Meter() : level(0), hwater_level(0), hwater_stamp(0) {}
+
+    /// flush the meter level back to 0, but leave peak records
+    void flush() {level=0;}
+
+    ssize_t currentLevel() const {return level;}
+    ssize_t peak() const {return hwater_level;}
+    time_t peakTime() const {return hwater_stamp;}
+
+    Meter &operator ++() {++level; checkHighWater(); return *this;}
+    Meter &operator --() {--level; return *this;}
+
+    Meter &operator +=(ssize_t n) { level += n; checkHighWater(); return *this;}
+    Meter &operator -=(ssize_t n) { level -= n; return *this;}
+
+private:
+    /// check the high-water level of this meter and raise if necessary
+    /// recording the timestamp of last high-water peak change
+    void checkHighWater() {
+        if (hwater_level < level) {
+            hwater_level = level;
+            hwater_stamp = squid_curtime ? squid_curtime : time(NULL);
+        }
+    }
+
+    ssize_t level;          ///< current level (count or volume)
+    ssize_t hwater_level;   ///< high water mark
+    time_t hwater_stamp;    ///< timestamp of last high water mark change
+};
+
+} // namespace Mem
+
+#endif /* SQUID_SRC_MEM_METER_H */
+
@@ -154,9 +154,9 @@ MemImplementingAllocator::flushMetersFull()
 void
 MemPoolMeter::flush()
 {
-    alloc.level = 0;
-    inuse.level = 0;
-    idle.level = 0;
+    alloc.flush();
+    inuse.flush();
+    idle.flush();
     gb_allocated.count = 0;
     gb_allocated.bytes = 0;
     gb_oallocated.count = 0;
@@ -178,17 +178,16 @@ MemPoolMeter::MemPoolMeter()
 void
 MemPools::flushMeters()
 {
-    MemImplementingAllocator *pool;
-    MemPoolIterator *iter;
-
     TheMeter.flush();
 
-    iter = memPoolIterate();
-    while ((pool = memPoolIterateNext(iter))) {
+    MemPoolIterator *iter = memPoolIterate();
+    while (MemImplementingAllocator *pool = memPoolIterateNext(iter)) {
         pool->flushMetersFull();
-        memMeterAdd(TheMeter.alloc, pool->getMeter().alloc.level * pool->obj_size);
-        memMeterAdd(TheMeter.inuse, pool->getMeter().inuse.level * pool->obj_size);
-        memMeterAdd(TheMeter.idle, pool->getMeter().idle.level * pool->obj_size);
+        // are these TheMeter grow() operations or accumulated volumes ?
+        TheMeter.alloc += pool->getMeter().alloc.currentLevel() * pool->obj_size;
+        TheMeter.inuse += pool->getMeter().inuse.currentLevel() * pool->obj_size;
+        TheMeter.idle += pool->getMeter().idle.currentLevel() * pool->obj_size;
+
         TheMeter.gb_allocated.count += pool->getMeter().gb_allocated.count;
         TheMeter.gb_saved.count += pool->getMeter().gb_saved.count;
         TheMeter.gb_freed.count += pool->getMeter().gb_freed.count;
@@ -234,7 +233,7 @@ MemPools::clean(time_t maxage)
         return;
 
     int shift = 1;
-    if (TheMeter.idle.level > mem_idle_limit)
+    if (TheMeter.idle.currentLevel() > mem_idle_limit)
         maxage = shift = 0;
 
     MemImplementingAllocator *pool;
@@ -312,7 +311,7 @@ memPoolsTotalAllocated(void)
 {
     MemPoolGlobalStats stats;
     memPoolGetGlobalStats(&stats);
-    return stats.TheMeter->alloc.level;
+    return stats.TheMeter->alloc.currentLevel();
 }
 
 MemImplementingAllocator::MemImplementingAllocator(char const *aLabel, size_t aSize) : MemAllocator(aLabel),
@@ -28,7 +28,7 @@
  *     might be the way to go.
  */
 
-#include "memMeter.h"
+#include "mem/Meter.h"
 #include "splay.h"
 #include "util.h"
 
@@ -95,9 +95,10 @@ class MemPoolMeter
 public:
     MemPoolMeter();
     void flush();
-    MemMeter alloc;
-    MemMeter inuse;
-    MemMeter idle;
+
+    Mem::Meter alloc;
+    Mem::Meter inuse;
+    Mem::Meter idle;
 
     /** history Allocations */
     mgb_t gb_allocated;
@@ -128,8 +128,8 @@ MemChunk::MemChunk(MemPoolChunked *aPool)
     nextFreeChunk = pool->nextFreeChunk;
     pool->nextFreeChunk = this;
 
-    memMeterAdd(pool->getMeter().alloc, pool->chunk_capacity);
-    memMeterAdd(pool->getMeter().idle, pool->chunk_capacity);
+    pool->getMeter().alloc += pool->chunk_capacity;
+    pool->getMeter().idle += pool->chunk_capacity;
     ++pool->chunkCount;
     lastref = squid_curtime;
     pool->allChunks.insert(this, memCompChunks);
@@ -149,8 +149,8 @@ MemPoolChunked::MemPoolChunked(const char *aLabel, size_t aSize) :
 
 MemChunk::~MemChunk()
 {
-    memMeterDel(pool->getMeter().alloc, pool->chunk_capacity);
-    memMeterDel(pool->getMeter().idle, pool->chunk_capacity);
+    pool->getMeter().alloc -= pool->chunk_capacity;
+    pool->getMeter().idle -= pool->chunk_capacity;
     -- pool->chunkCount;
     pool->allChunks.remove(this, memCompChunks);
     xfree(objCache);
@@ -288,7 +288,7 @@ MemPoolChunked::~MemPoolChunked()
 
     flushMetersFull();
     clean(0);
-    assert(meter.inuse.level == 0);
+    assert(meter.inuse.currentLevel() == 0);
 
     chunk = Chunks;
     while ( (fchunk = chunk) != NULL) {
@@ -302,26 +302,26 @@ MemPoolChunked::~MemPoolChunked()
 int
 MemPoolChunked::getInUseCount()
 {
-    return meter.inuse.level;
+    return meter.inuse.currentLevel();
 }
 
 void *
 MemPoolChunked::allocate()
 {
     void *p = get();
-    assert(meter.idle.level > 0);
-    memMeterDec(meter.idle);
-    memMeterInc(meter.inuse);
+    assert(meter.idle.currentLevel() > 0);
+    --meter.idle;
+    ++meter.inuse;
     return p;
 }
 
 void
 MemPoolChunked::deallocate(void *obj, bool)
 {
     push(obj);
-    assert(meter.inuse.level > 0);
-    memMeterDec(meter.inuse);
-    memMeterInc(meter.idle);
+    assert(meter.inuse.currentLevel() > 0);
+    --meter.inuse;
+    ++meter.idle;
 }
 
 void
@@ -417,7 +417,7 @@ MemPoolChunked::clean(time_t maxage)
 bool
 MemPoolChunked::idleTrigger(int shift) const
 {
-    return meter.idle.level > (chunk_capacity << shift);
+    return meter.idle.currentLevel() > (chunk_capacity << shift);
 }
 
 /*
@@ -456,12 +456,12 @@ MemPoolChunked::getStats(MemPoolStats * stats, int accumulate)
     stats->chunks_partial += chunks_partial;
     stats->chunks_free += chunks_free;
 
-    stats->items_alloc += meter.alloc.level;
-    stats->items_inuse += meter.inuse.level;
-    stats->items_idle += meter.idle.level;
+    stats->items_alloc += meter.alloc.currentLevel();
+    stats->items_inuse += meter.inuse.currentLevel();
+    stats->items_idle += meter.idle.currentLevel();
 
     stats->overhead += sizeof(MemPoolChunked) + chunkCount * sizeof(MemChunk) + strlen(objectType()) + 1;
 
-    return meter.inuse.level;
+    return meter.inuse.currentLevel();
 }
 
@@ -28,30 +28,30 @@ MemPoolMalloc::allocate()
         freelist.pop();
     }
     if (obj) {
-        memMeterDec(meter.idle);
+        --meter.idle;
         ++saved_calls;
     } else {
         if (doZero)
             obj = xcalloc(1, obj_size);
         else
             obj = xmalloc(obj_size);
-        memMeterInc(meter.alloc);
+        ++meter.alloc;
     }
-    memMeterInc(meter.inuse);
+    ++meter.inuse;
     return obj;
 }
 
 void
 MemPoolMalloc::deallocate(void *obj, bool aggressive)
 {
-    memMeterDec(meter.inuse);
+    --meter.inuse;
     if (aggressive) {
         xfree(obj);
-        memMeterDec(meter.alloc);
+        --meter.alloc;
     } else {
         if (doZero)
             memset(obj, 0, obj_size);
-        memMeterInc(meter.idle);
+        ++meter.idle;
         freelist.push(obj);
     }
 }
@@ -74,19 +74,19 @@ MemPoolMalloc::getStats(MemPoolStats * stats, int accumulate)
     stats->chunks_partial += 0;
     stats->chunks_free += 0;
 
-    stats->items_alloc += meter.alloc.level;
-    stats->items_inuse += meter.inuse.level;
-    stats->items_idle += meter.idle.level;
+    stats->items_alloc += meter.alloc.currentLevel();
+    stats->items_inuse += meter.inuse.currentLevel();
+    stats->items_idle += meter.idle.currentLevel();
 
     stats->overhead += sizeof(MemPoolMalloc) + strlen(objectType()) + 1;
 
-    return meter.inuse.level;
+    return meter.inuse.currentLevel();
 }
 
 int
 MemPoolMalloc::getInUseCount()
 {
-    return meter.inuse.level;
+    return meter.inuse.currentLevel();
 }
 
 MemPoolMalloc::MemPoolMalloc(char const *aLabel, size_t aSize) : MemImplementingAllocator(aLabel, aSize)
@@ -95,7 +95,7 @@ MemPoolMalloc::MemPoolMalloc(char const *aLabel, size_t aSize) : MemImplementing
 
 MemPoolMalloc::~MemPoolMalloc()
 {
-    assert(meter.inuse.level == 0);
+    assert(meter.inuse.currentLevel() == 0);
     clean(0);
 }
 
@@ -111,8 +111,8 @@ MemPoolMalloc::clean(time_t)
     while (!freelist.empty()) {
         void *obj = freelist.top();
         freelist.pop();
-        memMeterDec(meter.idle);
-        memMeterDec(meter.alloc);
+        --meter.idle;
+        --meter.alloc;
         xfree(obj);
     }
 }
@@ -12,15 +12,14 @@
 #define _SQUID_SRC_MEM_FORWARD_H
 
 #include "mem/AllocatorProxy.h"
-/* for FREE */
-#include "typedefs.h"
 
 #include <iosfwd>
 
 class StoreEntry;
 class MemPoolStats;
 class MemPoolMeter;
 
+/// Memory Management
 namespace Mem
 {
 void Init();
@@ -33,6 +32,9 @@ void PoolReport(const MemPoolStats * mp_st, const MemPoolMeter * AllMeter, std::
 
 extern const size_t squidSystemPageSize;
 
+/// \deprecated use MEMPROXY_CLASS instead.
+typedef void FREE(void *);
+
 /// Types of memory pool which do not yet use MEMPROXY_CLASS() API
 typedef enum {
     MEM_NONE,
@@ -11,6 +11,7 @@
 #include "squid.h"
 #include "acl/AclDenyInfoList.h"
 #include "acl/AclNameList.h"
+#include "base/PackableStream.h"
 #include "CacheDigest.h"
 #include "ClientInfo.h"
 #include "disk.h"
@@ -19,18 +20,16 @@
 #include "icmp/net_db.h"
 #include "md5.h"
 #include "mem/forward.h"
+#include "mem/Meter.h"
 #include "mem/Pool.h"
 #include "MemBuf.h"
-#include "memMeter.h"
 #include "mgr/Registration.h"
 #include "SquidConfig.h"
 #include "SquidList.h"
 #include "SquidTime.h"
 #include "Store.h"
-#include "StoreEntryStream.h"
 
 #include <iomanip>
-#include <ostream>
 
 /* forward declarations */
 static void memFree2K(void *);
@@ -94,11 +93,11 @@ static struct {
 }
 
 StrPools[mem_str_pool_count];
-static MemMeter StrCountMeter;
-static MemMeter StrVolumeMeter;
+static Mem::Meter StrCountMeter;
+static Mem::Meter StrVolumeMeter;
 
-static MemMeter HugeBufCountMeter;
-static MemMeter HugeBufVolumeMeter;
+static Mem::Meter HugeBufCountMeter;
+static Mem::Meter HugeBufVolumeMeter;
 
 /* local routines */
 
@@ -114,36 +113,33 @@ memStringStats(std::ostream &stream)
 
     for (i = 0; i < mem_str_pool_count; ++i) {
         const MemAllocator *pool = StrPools[i].pool;
-        const int plevel = pool->getMeter().inuse.level;
+        const auto plevel = pool->getMeter().inuse.currentLevel();
         stream << std::setw(20) << std::left << pool->objectType();
-        stream << std::right << "\t " << xpercentInt(plevel, StrCountMeter.level);
-        stream << "\t " << xpercentInt(plevel * pool->objectSize(), StrVolumeMeter.level) << "\n";
+        stream << std::right << "\t " << xpercentInt(plevel, StrCountMeter.currentLevel());
+        stream << "\t " << xpercentInt(plevel * pool->objectSize(), StrVolumeMeter.currentLevel()) << "\n";
         pooled_count += plevel;
         pooled_volume += plevel * pool->objectSize();
     }
 
     /* malloc strings */
     stream << std::setw(20) << std::left << "Other Strings";
-
     stream << std::right << "\t ";
-
-    stream << xpercentInt(StrCountMeter.level - pooled_count, StrCountMeter.level) << "\t ";
-
-    stream << xpercentInt(StrVolumeMeter.level - pooled_volume, StrVolumeMeter.level) << "\n\n";
+    stream << xpercentInt(StrCountMeter.currentLevel() - pooled_count, StrCountMeter.currentLevel()) << "\t ";
+    stream << xpercentInt(StrVolumeMeter.currentLevel() - pooled_volume, StrVolumeMeter.currentLevel()) << "\n\n";
 }
 
 static void
 memBufStats(std::ostream & stream)
 {
     stream << "Large buffers: " <<
-           HugeBufCountMeter.level << " (" <<
-           HugeBufVolumeMeter.level / 1024 << " KB)\n";
+           HugeBufCountMeter.currentLevel() << " (" <<
+           HugeBufVolumeMeter.currentLevel() / 1024 << " KB)\n";
 }
 
 void
 Mem::Stats(StoreEntry * sentry)
 {
-    StoreEntryStream stream(sentry);
+    PackableStream stream(*sentry);
     Report(stream);
     memStringStats(stream);
     memBufStats(stream);
@@ -227,8 +223,8 @@ memAllocString(size_t net_size, size_t * gross_size)
     *gross_size = pool ? StrPoolsAttrs[i].obj_size : net_size;
     assert(*gross_size >= net_size);
     // may forget [de]allocations until MemIsInitialized
-    memMeterInc(StrCountMeter);
-    memMeterAdd(StrVolumeMeter, *gross_size);
+    ++StrCountMeter;
+    StrVolumeMeter += *gross_size;
     return pool ? pool->alloc() : xcalloc(1, net_size);
 }
 
@@ -261,8 +257,8 @@ memFreeString(size_t size, void *buf)
     }
 
     // may forget [de]allocations until MemIsInitialized
-    memMeterDec(StrCountMeter);
-    memMeterDel(StrVolumeMeter, size);
+    --StrCountMeter;
+    StrVolumeMeter -= size;
     pool ? pool->freeOne(buf) : xfree(buf);
 }
 
@@ -311,8 +307,8 @@ memAllocBuf(size_t net_size, size_t * gross_size)
     if (type != MEM_NONE)
         return memAllocate(type);
     else {
-        memMeterInc(HugeBufCountMeter);
-        memMeterAdd(HugeBufVolumeMeter, *gross_size);
+        ++HugeBufCountMeter;
+        HugeBufVolumeMeter += *gross_size;
         return xcalloc(1, net_size);
     }
 }
@@ -351,8 +347,8 @@ memFreeBuf(size_t size, void *buf)
         memFree(buf, type);
     else {
         xfree(buf);
-        memMeterDec(HugeBufCountMeter);
-        memMeterDel(HugeBufVolumeMeter, size);
+        --HugeBufCountMeter;
+        HugeBufVolumeMeter -= size;
     }
 }
 
@@ -586,8 +582,8 @@ memFreeBufFunc(size_t size)
         return memFree64K;
 
     default:
-        memMeterDec(HugeBufCountMeter);
-        memMeterDel(HugeBufVolumeMeter, size);
+        --HugeBufCountMeter;
+        HugeBufVolumeMeter -= size;
         return cxx_xfree;
     }
 }
@@ -634,28 +630,28 @@ Mem::PoolReport(const MemPoolStats * mp_st, const MemPoolMeter * AllMeter, std::
     }
     /*
      *  Fragmentation calculation:
-     *    needed = inuse.level / chunk_capacity
+     *    needed = inuse.currentLevel() / chunk_capacity
      *    excess = used - needed
      *    fragmentation = excess / needed * 100%
      *
      *    Fragm = (alloced - (inuse / obj_ch) ) / alloced
      */
     /* allocated */
     stream << mp_st->items_alloc << delim;
-    stream << toKB(mp_st->obj_size * pm->alloc.level) << delim;
-    stream << toKB(mp_st->obj_size * pm->alloc.hwater_level) << delim;
-    stream << std::setprecision(2) << ((squid_curtime - pm->alloc.hwater_stamp) / 3600.) << delim;
-    stream << std::setprecision(3) << xpercent(mp_st->obj_size * pm->alloc.level, AllMeter->alloc.level) << delim;
+    stream << toKB(mp_st->obj_size * pm->alloc.currentLevel()) << delim;
+    stream << toKB(mp_st->obj_size * pm->alloc.peak()) << delim;
+    stream << std::setprecision(2) << ((squid_curtime - pm->alloc.peakTime()) / 3600.) << delim;
+    stream << std::setprecision(3) << xpercent(mp_st->obj_size * pm->alloc.currentLevel(), AllMeter->alloc.currentLevel()) << delim;
     /* in use */
     stream << mp_st->items_inuse << delim;
-    stream << toKB(mp_st->obj_size * pm->inuse.level) << delim;
-    stream << toKB(mp_st->obj_size * pm->inuse.hwater_level) << delim;
-    stream << std::setprecision(2) << ((squid_curtime - pm->inuse.hwater_stamp) / 3600.) << delim;
-    stream << std::setprecision(3) << xpercent(pm->inuse.level, pm->alloc.level) << delim;
+    stream << toKB(mp_st->obj_size * pm->inuse.currentLevel()) << delim;
+    stream << toKB(mp_st->obj_size * pm->inuse.peak()) << delim;
+    stream << std::setprecision(2) << ((squid_curtime - pm->inuse.peakTime()) / 3600.) << delim;
+    stream << std::setprecision(3) << xpercent(pm->inuse.currentLevel(), pm->alloc.currentLevel()) << delim;
     /* idle */
     stream << mp_st->items_idle << delim;
-    stream << toKB(mp_st->obj_size * pm->idle.level) << delim;
-    stream << toKB(mp_st->obj_size * pm->idle.hwater_level) << delim;
+    stream << toKB(mp_st->obj_size * pm->idle.currentLevel()) << delim;
+    stream << toKB(mp_st->obj_size * pm->idle.peak()) << delim;
     /* saved */
     stream << (int)pm->gb_saved.count << delim;
     stream << std::setprecision(3) << xpercent(pm->gb_saved.count, AllMeter->gb_allocated.count) << delim;
@@ -672,8 +668,8 @@ MemPoolReportSorter(const void *a, const void *b)
 
     // use this to sort on %Total Allocated
     //
-    double pa = (double) A->obj_size * A->meter->alloc.level;
-    double pb = (double) B->obj_size * B->meter->alloc.level;
+    double pa = (double) A->obj_size * A->meter->alloc.currentLevel();
+    double pb = (double) B->obj_size * B->meter->alloc.currentLevel();
 
     if (pa > pb)
         return -1;
@@ -684,10 +680,10 @@ MemPoolReportSorter(const void *a, const void *b)
 #if 0
     // use this to sort on In Use high(hrs)
     //
-    if (A->meter->inuse.hwater_stamp > B->meter->inuse.hwater_stamp)
+    if (A->meter->inuse.peakTime() > B->meter->inuse.peakTime())
         return -1;
 
-    if (B->meter->inuse.hwater_stamp > A->meter->inuse.hwater_stamp)
+    if (B->meter->inuse.peakTime() > A->meter->inuse.peakTime())
         return 1;
 
 #endif
@@ -783,7 +779,7 @@ Mem::Report(std::ostream &stream)
     stream << "Cumulative allocated volume: "<< double_to_str(buf, 64, mp_total.TheMeter->gb_allocated.bytes) << "\n";
     /* overhead */
     stream << "Current overhead: " << mp_total.tot_overhead << " bytes (" <<
-           std::setprecision(3) << xpercent(mp_total.tot_overhead, mp_total.TheMeter->inuse.level) << "%)\n";
+           std::setprecision(3) << xpercent(mp_total.tot_overhead, mp_total.TheMeter->inuse.currentLevel()) << "%)\n";
     /* limits */
     if (mp_total.mem_idle_limit >= 0)
         stream << "Idle pool limit: " << std::setprecision(2) << toMB(mp_total.mem_idle_limit) << " MB\n";
@@ -116,9 +116,9 @@ mimeGetEntry(const char *fn, int skip_encodings)
 }
 
 MimeIcon::MimeIcon(const char *aName) :
-    icon_(aName)
+    url_(nullptr)
 {
-    url_ = xstrdup(internalLocalUri("/squid-internal-static/icons/", icon_));
+    setName(aName);
 }
 
 MimeIcon::~MimeIcon()
@@ -6,11 +6,9 @@
 ##
 
 # tested with gawk, mawk, and nawk.
-# drop-in replacement for mk-globals-c.pl.
 # modified to work with Solaris awk (junk).
 # creates "globals.c" (on stdout) from "globals.h".
-# invoke similarly:  perl mk-globals-c.pl globals.h
-#		-->  awk -f mk-globals-c.awk globals.h
+# when invoked:  awk -f mk-globals-c.awk globals.h
 #
 # 2006 by Christopher Kerr.
 
@@ -1,49 +0,0 @@
-## Copyright (C) 1996-2015 The Squid Software Foundation and contributors
-##
-## Squid software is distributed under GPLv2+ license and includes
-## contributions from numerous individuals and organizations.
-## Please see the COPYING and CONTRIBUTORS files for details.
-##
-
-print "#include \"squid.h\"\n";
-while (<>) {
-	$init = undef;
-	next if (/ SQUID_GLOBALS_H/);
-	if (/^#/) {
-		print;
-		next;
-	}
-	if (/^.\*/) {
-		print;
-		next;
-	}
-	if (/extern \"C\"/) {
-		print;
-		next;
-	}
-	if (/^}/) {
-		print;
-		next;
-	}
-	if (/^{/) {
-		print;
-		next;
-	}
-	next unless (/./);
-	next if (/\[\];$/);
-#
-# Check exactly for lines beginning with "    extern", generated
-# from astyle (grrrrr ...)
-#
-	die unless (/^    extern\s+([^;]+);(.*)$/);
-	$var = $1;
-	$comments = $2;
-	if ($comments =~ m+/\*\s*(.*)\s*\*/+) {
-		$init = $1;
-		$init =~ s/\s$// while ($init =~ /\s$/);
-	}
-	print $var;
-	print " = $init" if (defined $init);
-	print ";\n";
-}
-exit 0;
@@ -6,10 +6,8 @@
 ##
 
 # tested with gawk, mawk, and nawk.
-# drop-in replacement for mk-string-arrays.pl.
 # creates "enum.c" (on stdout) from "enum.h".
-# invoke similarly: perl -f mk-string-arrays.pl	 enum.h
-#		-->  awk -f mk-string-arrays.awk enum.h
+# when invoked:  awk -f mk-string-arrays.awk enum.h
 #
 # 2006 by Christopher Kerr.
 #
@@ -36,6 +34,16 @@ BEGIN {
 
 # Skip all lines outside of typedef {}
 /^typedef/		{ codeSkip = 0; next }
+/^enum class / {
+  codeSkip = 0
+  type = $3
+  next;
+}
+/^enum / {
+  codeSkip = 0
+  type = $2
+  next;
+}
 codeSkip == 1		{ next }
 
 /^[ \t]*[A-Z]/ {
@@ -52,11 +60,19 @@ codeSkip == 1		{ next }
 	next
 }
 
+/};/ {
+  codeSkip = 1;
+}
+
 /^} / {
 	split($2, t, ";")			# remove ;
-	type = t[1]
-        codeSkip = 1
+  if (!type)
+    type = t[1]
+  codeSkip = 1
+  next
+}
 
+END {
 	if (sbuf) print "#include \"SBuf.h\""
 	print "#include \"" nspath type ".h\""
 
@@ -73,5 +89,4 @@ codeSkip == 1		{ next }
 	print "\t" Element[i]
 	print "};"
 	if (namespace) print "}; // namespace " namespace
-	next
 }
@@ -1,62 +0,0 @@
-#
-## Copyright (C) 1996-2015 The Squid Software Foundation and contributors
-##
-## Squid software is distributed under GPLv2+ license and includes
-## contributions from numerous individuals and organizations.
-## Please see the COPYING and CONTRIBUTORS files for details.
-##
-
-#******************************************************************************
-# File:		mk-strs.pl
-#
-# Author:	Max Okumoto <okumoto@ucsd.edu>
-#
-# Abstract:	This perl script parses enums and builds an array of
-#		printable strings.
-#
-# Warning:	The parser is very simplistic, and will prob not work for
-#		things other than squid.
-#******************************************************************************
-
-$pat{'err_type'} = "err_type_str";
-$pat{'icp_opcode'} = "icp_opcode_str";
-$pat{'swap_log_op'} = "swap_log_op_str";
-$pat{'lookup_t'} = "lookup_t_str";
-
-$state = 0;	# start state
-while (<>) {
-	if ($state == 0) {
-		# Looking for start of typedef
-		if (/^typedef enum /) {
-			$count = 0;	# enum index
-			$state = 1;
-		}
-		next;
-
-	} elsif ($state == 1) {
-		# Looking for end of typedef
-		if (/^} /) {
-			($b, $t) = split(/[ \t;]/, $_);
-			if (defined($pat{$t})) {
-				print "const char *$pat{$t}\[\] = \n";
-				print "{\n";
-				for ($i = 0; $i < $count; $i++) {
-					printf "\t\"%s\"%s\n",
-						$ea[$i],
-						$i == $count - 1 ? '' : ',';
-				}
-				print "};\n";
-				print "\n";
-			}
-			$state = 0;
-		} else {
-			($e) = split(' ', $_);
-			$e =~ s/,//;
-			$ea[$count] = $e;
-			$count++;
-		}
-		next;
-	}
-}
-
-exit 0;
@@ -11,6 +11,7 @@
 #include "squid.h"
 #include "acl/FilledChecklist.h"
 #include "anyp/PortCfg.h"
+#include "base/EnumIterator.h"
 #include "CacheDigest.h"
 #include "CachePeer.h"
 #include "comm/Connection.h"
@@ -1572,7 +1573,6 @@ static void
 dump_peers(StoreEntry * sentry, CachePeer * peers)
 {
     char ntoabuf[MAX_IPSTRLEN];
-    icp_opcode op;
     int i;
 
     if (peers == NULL)
@@ -1634,7 +1634,7 @@ dump_peers(StoreEntry * sentry, CachePeer * peers)
             } else {
 #endif
 
-                for (op = ICP_INVALID; op < ICP_END; ++op) {
+                for (auto op : WholeEnum<icp_opcode>()) {
                     if (e->icp.counts[op] == 0)
                         continue;
 
@@ -14,6 +14,7 @@
 #include "enums.h"
 #include "ICP.h"
 #include "lookup_t.h"
+#include "typedefs.h" //for IRCB
 
 class HttpRequest;
 class HttpRequestMethod;
@@ -35,6 +35,28 @@ Parser::Tokenizer::success(const SBuf::size_type n)
     return consume(n).length();
 }
 
+/// convenience method: consumes up to n last bytes and returns them
+SBuf
+Parser::Tokenizer::consumeTrailing(const SBuf::size_type n)
+{
+    debugs(24, 5, "consuming " << n << " bytes");
+
+    // If n is npos, we consume everything from buf_ (and nothing from result).
+    const SBuf::size_type parsed = (n == SBuf::npos) ? buf_.length() : n;
+
+    SBuf result = buf_;
+    buf_ = result.consume(buf_.length() - parsed);
+    parsed_ += parsed;
+    return result;
+}
+
+/// convenience method: consumes up to n last bytes and returns their count
+SBuf::size_type
+Parser::Tokenizer::successTrailing(const SBuf::size_type n)
+{
+    return consumeTrailing(n).length();
+}
+
 bool
 Parser::Tokenizer::token(SBuf &returnedToken, const CharacterSet &delimiters)
 {
@@ -90,8 +112,7 @@ Parser::Tokenizer::suffix(SBuf &returnedToken, const CharacterSet &tokenChars, c
     }
     if (!found)
         return false;
-    returnedToken = buf_;
-    buf_ = returnedToken.consume(buf_.length() - found);
+    returnedToken = consumeTrailing(found);
     return true;
 }
 
@@ -129,8 +150,8 @@ Parser::Tokenizer::skipSuffix(const SBuf &tokenToSkip)
         offset = buf_.length() - tokenToSkip.length();
 
     if (buf_.substr(offset, SBuf::npos).cmp(tokenToSkip) == 0) {
-        buf_ = buf_.substr(0,offset);
-        return true;
+        debugs(24, 8, "skipping " << tokenToSkip.length());
+        return successTrailing(tokenToSkip.length());
     }
     return false;
 }
@@ -157,6 +178,32 @@ Parser::Tokenizer::skip(const char tokenChar)
     return false;
 }
 
+bool
+Parser::Tokenizer::skipOneTrailing(const CharacterSet &skippable)
+{
+    if (!buf_.isEmpty() && skippable[buf_[buf_.length()-1]]) {
+        debugs(24, 8, "skipping one-of " << skippable.name);
+        return successTrailing(1);
+    }
+    debugs(24, 8, "no match while skipping one-of " << skippable.name);
+    return false;
+}
+
+SBuf::size_type
+Parser::Tokenizer::skipAllTrailing(const CharacterSet &skippable)
+{
+    const SBuf::size_type prefixEnd = buf_.findLastNotOf(skippable);
+    const SBuf::size_type prefixLen = prefixEnd == SBuf::npos ?
+                                      0 : (prefixEnd + 1);
+    const SBuf::size_type suffixLen = buf_.length() - prefixLen;
+    if (suffixLen == 0) {
+        debugs(24, 8, "no match when trying to skip " << skippable.name);
+        return 0;
+    }
+    debugs(24, 8, "skipping in " << skippable.name << " len " << suffixLen);
+    return successTrailing(suffixLen);
+}
+
 /* reworked from compat/strtoll.c */
 bool
 Parser::Tokenizer::int64(int64_t & result, int base, bool allowSign, const SBuf::size_type limit)
@@ -115,6 +115,18 @@ class Tokenizer
      */
     SBuf::size_type skipAll(const CharacterSet &discardables);
 
+    /** Removes a single trailing character from the set.
+     *
+     * \return whether a character was removed
+     */
+    bool skipOneTrailing(const CharacterSet &discardables);
+
+    /** Removes all sequential trailing characters from the set, in any order.
+     *
+     * \returns the number of characters removed
+     */
+    SBuf::size_type skipAllTrailing(const CharacterSet &discardables);
+
     /** Extracts an unsigned int64_t at the beginning of the buffer.
      *
      * strtoll(3)-alike function: tries to parse unsigned 64-bit integer
@@ -134,6 +146,8 @@ class Tokenizer
 protected:
     SBuf consume(const SBuf::size_type n);
     SBuf::size_type success(const SBuf::size_type n);
+    SBuf consumeTrailing(const SBuf::size_type n);
+    SBuf::size_type successTrailing(const SBuf::size_type n);
 
     /// reset the buffer and parsed stats to a saved checkpoint
     void undoParse(const SBuf &newBuf, SBuf::size_type cParsed) { buf_ = newBuf; parsed_ = cParsed; }
@@ -853,8 +853,8 @@ peerDigestPDFinish(DigestFetchState * fetch, int pcb_valid, int err)
 
     pd->times.received = squid_curtime;
     pd->times.req_delay = fetch->resp_time;
-    kb_incr(&pd->stats.sent.kbytes, (size_t) fetch->sent.bytes);
-    kb_incr(&pd->stats.recv.kbytes, (size_t) fetch->recv.bytes);
+    pd->stats.sent.kbytes += fetch->sent.bytes;
+    pd->stats.recv.kbytes += fetch->recv.bytes;
     pd->stats.sent.msgs += fetch->sent.msg;
     pd->stats.recv.msgs += fetch->recv.msg;
 
@@ -902,12 +902,9 @@ peerDigestFetchFinish(DigestFetchState * fetch, int err)
     }
 
     /* update global stats */
-    kb_incr(&statCounter.cd.kbytes_sent, (size_t) fetch->sent.bytes);
-
-    kb_incr(&statCounter.cd.kbytes_recv, (size_t) fetch->recv.bytes);
-
+    statCounter.cd.kbytes_sent += fetch->sent.bytes;
+    statCounter.cd.kbytes_recv += fetch->recv.bytes;
     statCounter.cd.msgs_sent += fetch->sent.msg;
-
     statCounter.cd.msgs_recv += fetch->recv.msg;
 
     delete fetch;
@@ -1028,7 +1025,7 @@ peerDigestSetCBlock(PeerDigest * pd, const char *buf)
         pd->cd = cacheDigestCreate(cblock.capacity, cblock.bits_per_entry);
 
         if (cblock.mask_size >= freed_size)
-            kb_incr(&statCounter.cd.memory, cblock.mask_size - freed_size);
+            statCounter.cd.memory += (cblock.mask_size - freed_size);
     }
 
     assert(pd->cd);
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_SRC_SECURITY_LOCKINGPOINTER_H
+#define SQUID_SRC_SECURITY_LOCKINGPOINTER_H
+
+#include "base/TidyPointer.h"
+
+namespace Security
+{
+
+/**
+ * Add SSL locking (a.k.a. reference counting) and assignment to TidyPointer
+ */
+template <typename T, void (*DeAllocator)(T *t), int lock>
+class LockingPointer: public TidyPointer<T, DeAllocator>
+{
+public:
+    typedef TidyPointer<T, DeAllocator> Parent;
+    typedef LockingPointer<T, DeAllocator, lock> SelfType;
+
+    explicit LockingPointer(T *t = nullptr): Parent(t) {}
+
+    explicit LockingPointer(const SelfType &o): Parent() {
+        resetAndLock(o.get());
+    }
+
+    SelfType &operator =(const SelfType & o) {
+        resetAndLock(o.get());
+        return *this;
+    }
+
+#if __cplusplus >= 201103L
+    explicit LockingPointer(LockingPointer<T, DeAllocator, lock> &&o): Parent(o.get()) {
+        *o.addr() = nullptr;
+    }
+
+    LockingPointer<T, DeAllocator, lock> &operator =(LockingPointer<T, DeAllocator, lock> &&o) {
+        if (o.get() != this->get()) {
+            this->reset(o.get());
+            *o.addr() = nullptr;
+        }
+        return *this;
+    }
+#endif
+
+    void resetAndLock(T *t) {
+        if (t != this->get()) {
+            this->reset(t);
+#if USE_OPENSSL
+            if (t)
+                CRYPTO_add(&t->references, 1, lock);
+#elif USE_GNUTLS
+            // XXX: GnuTLS does not provide locking ?
+#else
+            assert(false);
+#endif
+        }
+    }
+};
+
+} // namespace Security
+
+#endif /* SQUID_SRC_SECURITY_LOCKINGPOINTER_H */
+
@@ -15,6 +15,7 @@ libsecurity_la_SOURCES= \
 	EncryptorAnswer.cc \
 	EncryptorAnswer.h \
 	forward.h \
+	LockingPointer.h \
 	PeerOptions.cc \
 	PeerOptions.h \
 	Session.h
@@ -34,6 +34,7 @@ Security::PeerOptions::PeerOptions(const Security::PeerOptions &p) :
     sslDomain(p.sslDomain),
     parsedOptions(p.parsedOptions),
     parsedFlags(p.parsedFlags),
+    parsedCrl(p.parsedCrl),
     sslVersion(p.sslVersion),
     encryptTransport(p.encryptTransport)
 {
@@ -42,9 +43,18 @@ Security::PeerOptions::PeerOptions(const Security::PeerOptions &p) :
 void
 Security::PeerOptions::parse(const char *token)
 {
+    if (!*token) {
+        // config says just "ssl" or "tls" (or "tls-")
+        encryptTransport = true;
+        return;
+    }
+
     if (strncmp(token, "disable", 7) == 0) {
         clear();
-    } else if (strncmp(token, "cert=", 5) == 0) {
+        return;
+    }
+
+    if (strncmp(token, "cert=", 5) == 0) {
         certFile = SBuf(token + 5);
         if (privateKeyFile.isEmpty())
             privateKeyFile = certFile;
@@ -70,6 +80,7 @@ Security::PeerOptions::parse(const char *token)
         caDir = SBuf(token + 7);
     } else if (strncmp(token, "crlfile=", 8) == 0) {
         crlFile = SBuf(token + 8);
+        loadCrlFile();
     } else if (strncmp(token, "flags=", 6) == 0) {
         if (parsedFlags != 0) {
             debugs(3, DBG_PARSE_NOTE(1), "WARNING: Overwriting flags=" << sslFlags << " with " << SBuf(token + 6));
@@ -80,7 +91,10 @@ Security::PeerOptions::parse(const char *token)
         sslDomain = SBuf(token + 7);
     } else {
         debugs(3, DBG_CRITICAL, "ERROR: Unknown TLS option '" << token << "'");
+        return;
     }
+
+    encryptTransport = true;
 }
 
 void
@@ -184,9 +198,11 @@ Security::PeerOptions::createClientContext(bool setOptions)
     // XXX: temporary performance regression. c_str() data copies and prevents this being a const method
     t = sslCreateClientContext(certFile.c_str(), privateKeyFile.c_str(), sslCipher.c_str(),
                                (setOptions ? parsedOptions : 0), parsedFlags,
-                               caFile.c_str(), caDir.c_str(), crlFile.c_str());
+                               caFile.c_str(), caDir.c_str());
 #endif
 
+    updateContextCrl(t);
+
     return t;
 }
 
@@ -436,6 +452,54 @@ Security::PeerOptions::parseFlags()
     return fl;
 }
 
+/// Load a CRLs list stored in the file whose /path/name is in crlFile
+/// replaces any CRL loaded previously
+void
+Security::PeerOptions::loadCrlFile()
+{
+    parsedCrl.clear();
+    if (crlFile.isEmpty())
+        return;
+
+#if USE_OPENSSL
+    BIO *in = BIO_new_file(crlFile.c_str(), "r");
+    if (!in) {
+        debugs(83, 2, "WARNING: Failed to open CRL file " << crlFile);
+        return;
+    }
+
+    while (X509_CRL *crl = PEM_read_bio_X509_CRL(in,NULL,NULL,NULL)) {
+        parsedCrl.emplace_back(Security::CrlPointer(crl));
+    }
+    BIO_free(in);
+#endif
+}
+
+void
+Security::PeerOptions::updateContextCrl(Security::ContextPointer &ctx)
+{
+#if USE_OPENSSL
+    bool verifyCrl = false;
+    X509_STORE *st = SSL_CTX_get_cert_store(ctx);
+    if (parsedCrl.size()) {
+        for (auto &i : parsedCrl) {
+            if (!X509_STORE_add_crl(st, i.get()))
+                debugs(83, 2, "WARNING: Failed to add CRL");
+            else
+                verifyCrl = true;
+        }
+    }
+
+#if X509_V_FLAG_CRL_CHECK
+    if ((parsedFlags & SSL_FLAG_VERIFY_CRL_ALL))
+        X509_STORE_set_flags(st, X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL);
+    else if (verifyCrl || (parsedFlags & SSL_FLAG_VERIFY_CRL))
+        X509_STORE_set_flags(st, X509_V_FLAG_CRL_CHECK);
+#endif
+
+#endif /* USE_OPENSSL */
+}
+
 void
 parse_securePeerOptions(Security::PeerOptions *opt)
 {
@@ -37,12 +37,16 @@ class PeerOptions
     /// sync the context options with tls-min-version=N configuration
     void updateTlsVersionLimits();
 
+    /// setup the CRL details for the given context
+    void updateContextCrl(Security::ContextPointer &);
+
     /// output squid.conf syntax with 'pfx' prefix on parameters for the stored settings
     void dumpCfg(Packable *, const char *pfx) const;
 
 private:
     long parseOptions();
     long parseFlags();
+    void loadCrlFile();
 
 public:
     SBuf certFile;       ///< path of file containing PEM format X509 certificate
@@ -61,6 +65,8 @@ class PeerOptions
     long parsedOptions; ///< parsed value of sslOptions
     long parsedFlags;   ///< parsed value of sslFlags
 
+    Security::CertRevokeList parsedCrl; ///< CRL to use when verifying the remote end certificate
+
 private:
     int sslVersion;
 
@@ -10,8 +10,16 @@
 #define SQUID_SRC_SECURITY_FORWARD_H
 
 #include "security/Context.h"
+#include "security/LockingPointer.h"
 #include "security/Session.h"
 
+#if USE_GNUTLS
+#if HAVE_GNUTLS_X509_H
+#include <gnutls/x509.h>
+#endif
+#endif
+#include <list>
+
 /* flags a SSL connection can be configured with */
 #define SSL_FLAG_NO_DEFAULT_CA      (1<<0)
 #define SSL_FLAG_DELAYED_AUTH       (1<<1)
@@ -21,13 +29,52 @@
 #define SSL_FLAG_VERIFY_CRL         (1<<5)
 #define SSL_FLAG_VERIFY_CRL_ALL     (1<<6)
 
+// Macro to be used to define the C++ equivalent function of an extern "C"
+// function. The C++ function suffixed with the _cpp extension
+#define CtoCpp1(function, argument) \
+        extern "C++" inline void function ## _cpp(argument a) { \
+            function(a); \
+        }
+
+#if USE_OPENSSL
+// Macro to be used to define the C++ wrapper function of a sk_*_pop_free
+// openssl family functions. The C++ function suffixed with the _free_wrapper
+// extension
+#define sk_free_wrapper(sk_object, argument, freefunction) \
+        extern "C++" inline void sk_object ## _free_wrapper(argument a) { \
+            sk_object ## _pop_free(a, freefunction); \
+        }
+#endif
+
 /// Network/connection security abstraction layer
 namespace Security
 {
 
 class EncryptorAnswer;
 class PeerOptions;
 
+#if USE_OPENSSL
+CtoCpp1(X509_free, X509 *)
+typedef Security::LockingPointer<X509, X509_free_cpp, CRYPTO_LOCK_X509> CertPointer;
+#elif USE_GNUTLS
+CtoCpp1(gnutls_x509_crt_deinit, gnutls_x509_crt_t)
+typedef Security::LockingPointer<struct gnutls_x509_crt_int, gnutls_x509_crt_deinit, -1> CertPointer;
+#else
+typedef void * CertPointer;
+#endif
+
+#if USE_OPENSSL
+CtoCpp1(X509_CRL_free, X509_CRL *)
+typedef LockingPointer<X509_CRL, X509_CRL_free_cpp, CRYPTO_LOCK_X509_CRL> CrlPointer;
+#elif USE_GNUTLS
+CtoCpp1(gnutls_x509_crl_deinit, gnutls_x509_crl_t)
+typedef Security::LockingPointer<struct gnutls_x509_crl_int, gnutls_x509_crl_deinit, -1> CrlPointer;
+#else
+typedef void *CrlPointer;
+#endif
+
+typedef std::list<Security::CrlPointer> CertRevokeList;
+
 } // namespace Security
 
 #endif /* SQUID_SRC_SECURITY_FORWARD_H */
@@ -172,7 +172,7 @@ Ftp::Server::readUploadData(const CommIoCbParams &io)
 
     if (io.flag == Comm::OK && bodyPipe != NULL) {
         if (io.size > 0) {
-            kb_incr(&(statCounter.client_http.kbytes_in), io.size);
+            statCounter.client_http.kbytes_in += io.size;
 
             char *const current_buf = uploadBuf + uploadAvailSize;
             if (io.buf != current_buf)
@@ -557,43 +557,43 @@ Ftp::Server::earlyError(const EarlyErrorKind eek)
     const char *errUri = "error:ftp-internal-early-error";
 
     switch (eek) {
-    case eekHugeRequest:
+    case EarlyErrorKind::HugeRequest:
         scode = 421;
         reason = "Huge request";
         errUri = "error:ftp-huge-request";
         break;
 
-    case eekMissingLogin:
+    case EarlyErrorKind::MissingLogin:
         scode = 530;
         reason = "Must login first";
         errUri = "error:ftp-must-login-first";
         break;
 
-    case eekMissingUsername:
+    case EarlyErrorKind::MissingUsername:
         scode = 501;
         reason = "Missing username";
         errUri = "error:ftp-missing-username";
         break;
 
-    case eekMissingHost:
+    case EarlyErrorKind::MissingHost:
         scode = 501;
         reason = "Missing host";
         errUri = "error:ftp-missing-host";
         break;
 
-    case eekUnsupportedCommand:
+    case EarlyErrorKind::UnsupportedCommand:
         scode = 502;
         reason = "Unknown or unsupported command";
         errUri = "error:ftp-unsupported-command";
         break;
 
-    case eekInvalidUri:
+    case EarlyErrorKind::InvalidUri:
         scode = 501;
         reason = "Invalid URI";
         errUri = "error:ftp-invalid-uri";
         break;
 
-    case eekMalformedCommand:
+    case EarlyErrorKind::MalformedCommand:
         scode = 421;
         reason = "Malformed command";
         errUri = "error:ftp-malformed-command";
@@ -661,7 +661,7 @@ Ftp::Server::parseOneRequest()
     if (cmd.length() > tokenMax || params.length() > tokenMax) {
         changeState(fssError, "huge req token");
         quitAfterError(NULL);
-        return earlyError(eekHugeRequest);
+        return earlyError(EarlyErrorKind::HugeRequest);
     }
 
     // technically, we may skip multiple NLs below, but that is OK
@@ -670,7 +670,7 @@ Ftp::Server::parseOneRequest()
         if (in.buf.length() >= Config.maxRequestHeaderSize) {
             changeState(fssError, "huge req");
             quitAfterError(NULL);
-            return earlyError(eekHugeRequest);
+            return earlyError(EarlyErrorKind::HugeRequest);
         } else {
             flags.readMore = true;
             debugs(33, 5, "Waiting for more, up to " <<
@@ -691,7 +691,7 @@ Ftp::Server::parseOneRequest()
         if (!master->clientReadGreeting) {
             // the first command must be USER
             if (!pinning.pinned && cmd != cmdUser())
-                return earlyError(eekMissingLogin);
+                return earlyError(EarlyErrorKind::MissingLogin);
         }
 
         // process USER request now because it sets FTP peer host name
@@ -702,7 +702,7 @@ Ftp::Server::parseOneRequest()
     }
 
     if (!Ftp::SupportedCommand(cmd))
-        return earlyError(eekUnsupportedCommand);
+        return earlyError(EarlyErrorKind::UnsupportedCommand);
 
     const HttpRequestMethod method =
         cmd == cmdAppe() || cmd == cmdStor() || cmd == cmdStou() ?
@@ -717,7 +717,7 @@ Ftp::Server::parseOneRequest()
         debugs(33, 5, "Invalid FTP URL: " << uri);
         uri.clear();
         safe_free(newUri);
-        return earlyError(eekInvalidUri);
+        return earlyError(EarlyErrorKind::InvalidUri);
     }
 
     request->flags.ftpNative = true;
@@ -785,11 +785,16 @@ Ftp::Server::handleReply(HttpReply *reply, StoreIOBuffer data)
         NULL, // fssHandleCdup
         &Ftp::Server::handleErrorReply // fssError
     };
-    const Server &server = dynamic_cast<const Ftp::Server&>(*context->getConn());
-    if (const ReplyHandler handler = handlers[server.master->serverState])
-        (this->*handler)(reply, data);
-    else
-        writeForwardedReply(reply);
+    try {
+        const Server &server = dynamic_cast<const Ftp::Server&>(*context->getConn());
+        if (const ReplyHandler handler = handlers[server.master->serverState])
+            (this->*handler)(reply, data);
+        else
+            writeForwardedReply(reply);
+    } catch (const std::exception &e) {
+        callException(e);
+        throw TexcHere(e.what());
+    }
 }
 
 void
@@ -800,6 +805,7 @@ Ftp::Server::handleFeatReply(const HttpReply *reply, StoreIOBuffer)
         return;
     }
 
+    Must(reply);
     HttpReply::Pointer featReply = Ftp::HttpReplyWrapper(211, "End", Http::scNoContent, 0);
     HttpHeader const &serverReplyHeader = reply->header;
 
@@ -1021,7 +1027,8 @@ Ftp::Server::handleUploadReply(const HttpReply *reply, StoreIOBuffer)
 void
 Ftp::Server::writeForwardedReply(const HttpReply *reply)
 {
-    assert(reply != NULL);
+    Must(reply);
+
     const HttpHeader &header = reply->header;
     // adaptation and forwarding errors lack Http::HdrType::FTP_STATUS
     if (!header.has(Http::HdrType::FTP_STATUS)) {
@@ -1102,7 +1109,7 @@ Ftp::Server::writeErrorReply(const HttpReply *reply, const int scode)
     }
 #endif
 
-    assert(reply != NULL);
+    Must(reply);
     const char *reason = reply->header.has(Http::HdrType::FTP_REASON) ?
                          reply->header.getStr(Http::HdrType::FTP_REASON):
                          reply->sline.reason();
@@ -1335,12 +1342,12 @@ ClientSocketContext *
 Ftp::Server::handleUserRequest(const SBuf &, SBuf &params)
 {
     if (params.isEmpty())
-        return earlyError(eekMissingUsername);
+        return earlyError(EarlyErrorKind::MissingUsername);
 
     // find the [end of] user name
     const SBuf::size_type eou = params.rfind('@');
     if (eou == SBuf::npos || eou + 1 >= params.length())
-        return earlyError(eekMissingHost);
+        return earlyError(EarlyErrorKind::MissingHost);
 
     // Determine the intended destination.
     host = params.substr(eou + 1, params.length());
@@ -1693,6 +1700,17 @@ Ftp::Server::setReply(const int code, const char *msg)
     http->storeEntry()->replaceHttpReply(reply);
 }
 
+void
+Ftp::Server::callException(const std::exception &e)
+{
+    debugs(33, 2, "FTP::Server job caught: " << e.what());
+    closeDataConnection();
+    unpinConnection(true);
+    if (Comm::IsConnOpen(clientConnection))
+        clientConnection->close();
+    AsyncJob::callException(e);
+}
+
 /// Whether Squid FTP Relay supports a named feature (e.g., a command).
 static bool
 Ftp::SupportedCommand(const SBuf &name)
@@ -53,10 +53,14 @@ class MasterState: public RefCountable
 class Server: public ConnStateData
 {
     CBDATA_CLASS(Server);
+    // XXX CBDATA_CLASS expands to nonvirtual toCbdata, AsyncJob::toCbdata
+    //     is pure virtual. breaks build on clang if override is used
 
 public:
     explicit Server(const MasterXaction::Pointer &xact);
     virtual ~Server();
+    /* AsyncJob API */
+    virtual void callException(const std::exception &e);
 
     // This is a pointer in hope to minimize future changes when MasterState
     // becomes a part of MasterXaction. Guaranteed not to be nil.
@@ -66,15 +70,15 @@ class Server: public ConnStateData
     friend void StartListening();
 
     // errors detected before it is possible to create an HTTP request wrapper
-    typedef enum {
-        eekHugeRequest,
-        eekMissingLogin,
-        eekMissingUsername,
-        eekMissingHost,
-        eekUnsupportedCommand,
-        eekInvalidUri,
-        eekMalformedCommand
-    } EarlyErrorKind;
+    enum class EarlyErrorKind {
+        HugeRequest,
+        MissingLogin,
+        MissingUsername,
+        MissingHost,
+        UnsupportedCommand,
+        InvalidUri,
+        MalformedCommand
+    };
 
     /* ConnStateData API */
     virtual ClientSocketContext *parseOneRequest();
@@ -19,6 +19,7 @@
 #include "profiler/Profiler.h"
 #include "servers/Http1Server.h"
 #include "SquidConfig.h"
+#include "Store.h"
 
 CBDATA_NAMESPACED_CLASS_INIT(Http1, Server);
 
@@ -250,6 +251,7 @@ Http::One::Server::handleReply(HttpReply *rep, StoreIOBuffer receivedData)
     // the last-chunk if there was no error, ignoring responseFinishedOrFailed.
     const bool mustSendLastChunk = http->request->flags.chunkedReply &&
                                    !http->request->flags.streamError &&
+                                   !EBIT_TEST(http->storeEntry()->flags, ENTRY_BAD_LENGTH) &&
                                    !context->startOfOutput();
     const bool responseFinishedOrFailed = !rep &&
                                           !receivedData.data &&
@@ -13,6 +13,7 @@
 
 #if SQUID_SNMP
 
+#include "cache_snmp.h"
 #include "snmp_vars.h"
 
 variable_list *snmp_confFn(variable_list *, snint *);
@@ -13,17 +13,14 @@
 
 #include "cache_snmp.h"
 #include "comm/forward.h"
-#include "typedefs.h"
+#include "ip/forward.h"
 
-namespace Ip
-{
-class Address;
-}
 class MemBuf;
 
 #define SNMP_REQUEST_SIZE 4096
 #define MAX_PROTOSTAT 5
 
+typedef variable_list *(oid_ParseFn) (variable_list *, snint *);
 typedef struct _mib_tree_entry mib_tree_entry;
 typedef oid *(instance_Fn) (oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn);
 typedef enum {atNone = 0, atSum, atAverage, atMax, atMin} AggrType;
@@ -12,10 +12,7 @@
 #include "err_detail_type.h"
 #include "ErrorDetailManager.h"
 #include "HttpRequest.h"
-
-#if HAVE_OPENSSL_SSL_H
-#include <openssl/ssl.h>
-#endif
+#include "security/forward.h"
 
 namespace Ssl
 {
@@ -105,8 +102,8 @@ class ErrorDetail
     mutable String errDetailStr; ///< Caches the error detail message
     ssl_error_t error_no;   ///< The error code
     unsigned long lib_error_no; ///< low-level error returned by OpenSSL ERR_get_error(3SSL)
-    X509_Pointer peer_cert; ///< A pointer to the peer certificate
-    X509_Pointer broken_cert; ///< A pointer to the broken certificate (peer or intermediate)
+    Security::CertPointer peer_cert; ///< A pointer to the peer certificate
+    Security::CertPointer broken_cert; ///< A pointer to the broken certificate (peer or intermediate)
     String errReason; ///< A custom reason for error, else retrieved from OpenSSL.
     mutable ErrorDetailEntry detailEntry;
     HttpRequest::Pointer request;
@@ -213,7 +213,17 @@ void
 Ssl::PeekingPeerConnector::cbCheckForPeekAndSpliceDone(allow_t answer, void *data)
 {
     Ssl::PeekingPeerConnector *peerConnect = (Ssl::PeekingPeerConnector *) data;
-    peerConnect->checkForPeekAndSpliceDone((Ssl::BumpMode)answer.kind);
+    // Use job calls to add done() checks and other job logic/protections.
+    CallJobHere1(83, 7, CbcPointer<PeekingPeerConnector>(peerConnect), Ssl::PeekingPeerConnector, checkForPeekAndSpliceDone, answer);
+}
+
+void
+Ssl::PeekingPeerConnector::checkForPeekAndSpliceDone(allow_t answer)
+{
+    const Ssl::BumpMode finalAction = (answer.code == ACCESS_ALLOWED) ?
+                                      static_cast<Ssl::BumpMode>(answer.kind):
+                                      checkForPeekAndSpliceGuess();
+    checkForPeekAndSpliceMatched(finalAction);
 }
 
 void
@@ -231,27 +241,31 @@ Ssl::PeekingPeerConnector::checkForPeekAndSplice()
     ACLFilledChecklist *acl_checklist = new ACLFilledChecklist(
         ::Config.accessList.ssl_bump,
         request.getRaw(), NULL);
+    acl_checklist->banAction(allow_t(ACCESS_ALLOWED, Ssl::bumpNone));
+    acl_checklist->banAction(allow_t(ACCESS_ALLOWED, Ssl::bumpPeek));
+    acl_checklist->banAction(allow_t(ACCESS_ALLOWED, Ssl::bumpStare));
+    acl_checklist->banAction(allow_t(ACCESS_ALLOWED, Ssl::bumpClientFirst));
+    acl_checklist->banAction(allow_t(ACCESS_ALLOWED, Ssl::bumpServerFirst));
+    SSL *ssl = fd_table[serverConn->fd].ssl;
+    BIO *b = SSL_get_rbio(ssl);
+    Ssl::ServerBio *srvBio = static_cast<Ssl::ServerBio *>(b->ptr);
+    if (!srvBio->canSplice())
+        acl_checklist->banAction(allow_t(ACCESS_ALLOWED, Ssl::bumpSplice));
+    if (!srvBio->canBump())
+        acl_checklist->banAction(allow_t(ACCESS_ALLOWED, Ssl::bumpBump));
     acl_checklist->nonBlockingCheck(Ssl::PeekingPeerConnector::cbCheckForPeekAndSpliceDone, this);
 }
 
 void
-Ssl::PeekingPeerConnector::checkForPeekAndSpliceDone(Ssl::BumpMode const action)
+Ssl::PeekingPeerConnector::checkForPeekAndSpliceMatched(const Ssl::BumpMode action)
 {
     SSL *ssl = fd_table[serverConn->fd].ssl;
     BIO *b = SSL_get_rbio(ssl);
     Ssl::ServerBio *srvBio = static_cast<Ssl::ServerBio *>(b->ptr);
     debugs(83,5, "Will check for peek and splice on FD " << serverConn->fd);
 
     Ssl::BumpMode finalAction = action;
-    // adjust the final bumping mode if needed
-    if (finalAction < Ssl::bumpSplice)
-        finalAction = Ssl::bumpBump;
-
-    if (finalAction == Ssl::bumpSplice && !srvBio->canSplice())
-        finalAction = Ssl::bumpBump;
-    else if (finalAction == Ssl::bumpBump && !srvBio->canBump())
-        finalAction = Ssl::bumpSplice;
-
+    Must(finalAction == Ssl::bumpSplice || finalAction == Ssl::bumpBump || finalAction == Ssl::bumpTerminate);
     // Record final decision
     if (request->clientConnectionManager.valid()) {
         request->clientConnectionManager->sslBumpMode = finalAction;
@@ -277,6 +291,23 @@ Ssl::PeekingPeerConnector::checkForPeekAndSpliceDone(Ssl::BumpMode const action)
     }
 }
 
+Ssl::BumpMode
+Ssl::PeekingPeerConnector::checkForPeekAndSpliceGuess() const
+{
+    if (const ConnStateData *csd = request->clientConnectionManager.valid()) {
+        const Ssl::BumpMode currentMode = csd->sslBumpMode;
+        if (currentMode == Ssl::bumpStare) {
+            debugs(83,5, "default to bumping after staring");
+            return Ssl::bumpBump;
+        }
+        debugs(83,5, "default to splicing after " << currentMode);
+    } else {
+        debugs(83,3, "default to splicing due to missing info");
+    }
+
+    return Ssl::bumpSplice;
+}
+
 void
 Ssl::PeerConnector::sslCrtvdHandleReplyWrapper(void *data, Ssl::CertValidationResponse const &validationResponse)
 {
@@ -362,7 +393,7 @@ Ssl::PeerConnector::sslCrtvdCheckForErrors(Ssl::CertValidationResponse const &re
             } else {
                 debugs(83, 5, "confirming SSL error " << i->error_no);
                 X509 *brokenCert = i->cert.get();
-                Ssl::X509_Pointer peerCert(SSL_get_peer_certificate(ssl));
+                Security::CertPointer peerCert(SSL_get_peer_certificate(ssl));
                 const char *aReason = i->error_reason.empty() ? NULL : i->error_reason.c_str();
                 errDetails = new Ssl::ErrorDetail(i->error_no, peerCert.get(), brokenCert, aReason);
             }
@@ -528,7 +559,13 @@ Ssl::PeerConnector::swanSong()
 {
     // XXX: unregister fd-closure monitoring and CommSetSelect interest, if any
     AsyncJob::swanSong();
-    assert(!callback); // paranoid: we have not left the caller waiting
+    if (callback != NULL) { // paranoid: we have left the caller waiting
+        debugs(83, DBG_IMPORTANT, "BUG: Unexpected state while connecting to a cache_peer or origin server");
+        ErrorState *anErr = new ErrorState(ERR_GATEWAY_FAILURE, Http::scInternalServerError, request.getRaw());
+        bail(anErr);
+        assert(!callback);
+        return;
+    }
 }
 
 const char *
@@ -785,7 +822,7 @@ Ssl::PeekingPeerConnector::noteSslNegotiationError(const int result, const int s
         // we currently splice all resumed sessions unconditionally
         if (const bool spliceResumed = true) {
             bypassCertValidator();
-            checkForPeekAndSpliceDone(Ssl::bumpSplice);
+            checkForPeekAndSpliceMatched(Ssl::bumpSplice);
             return;
         } // else fall through to find a matching ssl_bump action (with limited info)
     }
@@ -801,7 +838,7 @@ Ssl::PeekingPeerConnector::noteSslNegotiationError(const int result, const int s
     // unsupported server Hello message (TODO: make configurable).
     if (!SSL_get_ex_data(ssl, ssl_ex_index_ssl_error_detail) &&
             (srvBio->bumpMode() == Ssl::bumpPeek  || srvBio->bumpMode() == Ssl::bumpStare) && srvBio->holdWrite()) {
-        Ssl::X509_Pointer serverCert(SSL_get_peer_certificate(ssl));
+        Security::CertPointer serverCert(SSL_get_peer_certificate(ssl));
         if (serverCert.get()) {
             debugs(81, 3, "Error ("  << ERR_error_string(ssl_lib_error, NULL) <<  ") but, hold write on SSL connection on FD " << fd);
             checkForPeekAndSplice();
@@ -822,7 +859,7 @@ Ssl::PeekingPeerConnector::handleServerCertificate()
     if (ConnStateData *csd = request->clientConnectionManager.valid()) {
         const int fd = serverConnection()->fd;
         SSL *ssl = fd_table[fd].ssl;
-        Ssl::X509_Pointer serverCert(SSL_get_peer_certificate(ssl));
+        Security::CertPointer serverCert(SSL_get_peer_certificate(ssl));
         if (!serverCert.get())
             return;
 
@@ -839,7 +876,7 @@ void
 Ssl::PeekingPeerConnector::serverCertificateVerified()
 {
     if (ConnStateData *csd = request->clientConnectionManager.valid()) {
-        Ssl::X509_Pointer serverCert;
+        Security::CertPointer serverCert;
         if(Ssl::ServerBump *serverBump = csd->serverBump())
             serverCert.resetAndLock(serverBump->serverCert.get());
         else {
@@ -238,8 +238,13 @@ class PeekingPeerConnector: public PeerConnector {
     void checkForPeekAndSplice();
 
     /// Callback function for ssl_bump acl check in step3  SSL bump step.
+    void checkForPeekAndSpliceDone(allow_t answer);
+
     /// Handles the final bumping decision.
-    void checkForPeekAndSpliceDone(Ssl::BumpMode const);
+    void checkForPeekAndSpliceMatched(const Ssl::BumpMode finalMode);
+
+    /// Guesses the final bumping decision when no ssl_bump rules match.
+    Ssl::BumpMode checkForPeekAndSpliceGuess() const;
 
     /// Runs after the server certificate verified to update client
     /// connection manager members
@@ -14,6 +14,7 @@
 #include "comm/forward.h"
 #include "HttpRequest.h"
 #include "ip/Address.h"
+#include "security/forward.h"
 
 class ConnStateData;
 class store_client;
@@ -35,7 +36,7 @@ class ServerBump
     /// faked, minimal request; required by Client API
     HttpRequest::Pointer request;
     StoreEntry *entry; ///< for receiving Squid-generated error messages
-    Ssl::X509_Pointer serverCert; ///< HTTPS server certificate
+    Security::CertPointer serverCert; ///< HTTPS server certificate
     Ssl::CertErrors *sslErrors; ///< SSL [certificate validation] errors
     struct {
         Ssl::BumpMode step1; ///< The SSL bump mode at step1
@@ -24,8 +24,6 @@
 #include <openssl/ssl.h>
 #endif
 
-#undef DO_SSLV23
-
 #if _SQUID_WINDOWS_
 extern int socket_read_method(int, char *, int);
 extern int socket_write_method(int, const char *, int);
@@ -778,15 +776,13 @@ Ssl::Bio::sslFeatures::parseMsgHead(const MemBuf &buf)
         helloMsgSize = (head[3] << 8) + head[4];
         debugs(83, 7, "SSL Header Size: " << helloMsgSize);
         helloMsgSize +=5;
-#if defined(DO_SSLV23)
     } else if ((head[0] & 0x80) && head[2] == 0x01 && head[3] == 0x03) {
         debugs(83, 7, "SSL version 2 handshake message with v3 support");
-        sslVersion = (hello[3] << 8) | hello[4];
+        sslVersion = (head[3] << 8) | head[4];
         debugs(83, 7, "SSL Version :" << std::hex << std::setw(8) << std::setfill('0') << sslVersion);
         // The hello message size exist in 2nd byte
         helloMsgSize = head[1];
         helloMsgSize +=2;
-#endif
     } else {
         debugs(83, 7, "Not an SSL acceptable handshake message (SSLv2 message?)");
         return (helloMsgSize = -1);
@@ -851,12 +847,9 @@ Ssl::Bio::sslFeatures::get(const MemBuf &buf, bool record)
     }
 
     const unsigned char *msg = (const unsigned char *)buf.content();
-#if defined(DO_SSLV23)
     if (msg[0] & 0x80)
         return parseV23Hello(msg, (size_t)msgSize);
-    else
-#endif
-    {
+    else {
         // Hello messages require 5 bytes header + 1 byte Msg type + 3 bytes for Msg size
         if (buf.contentSize() < 9)
             return false;
@@ -877,15 +870,17 @@ Ssl::Bio::sslFeatures::get(const MemBuf &buf, bool record)
 }
 
 bool
-Ssl::Bio::sslFeatures::parseV3ServerHello(const unsigned char *hello, size_t size)
+Ssl::Bio::sslFeatures::parseV3ServerHello(const unsigned char *messageContainer, size_t messageContainerSize)
 {
     // Parse a ServerHello Handshake message
     // RFC5246 section 7.4, 7.4.1.3
-    // The ServerHello starts at hello+5
-    const size_t helloSize = (hello[6] << 16) | (hello[7] << 8) | hello[8];
+    // The ServerHello starts at messageContainer + 5
+    const unsigned char *serverHello = messageContainer + 5;
+
+    // The Length field (bytes 1-3) plus 4 bytes of the serverHello message header (1 handshake type + 3 hello length)
+    const size_t helloSize = ((serverHello[1] << 16) | (serverHello[2] << 8) | serverHello[3]) + 4;
     debugs(83, 7, "ServerHello message size: " << helloSize);
-    // helloSize should be msgSize + hello Header (4 bytes)
-    if (helloSize + 4 > size) {
+    if (helloSize > messageContainerSize) {
         debugs(83, 2, "ServerHello parse error");
         return false;
     }
@@ -899,42 +894,42 @@ Ssl::Bio::sslFeatures::parseV3ServerHello(const unsigned char *hello, size_t siz
 
     debugs(83, 7, "Get fake features from v3 ServerHello message.");
     // Get the correct version of the sub-hello message
-    sslVersion = (hello[9] << 8) | hello[10];
-    // At the position 43 (MsgHeader(5 bytes) + HelloHeader (6bytes) + SSL3_RANDOM_SIZE (32bytes))
-    const size_t sessIdLen = (size_t)hello[43];
+    sslVersion = (serverHello[4] << 8) | serverHello[5];
+    // At the position 38 (HelloHeader (6bytes) + SSL3_RANDOM_SIZE (32bytes))
+    const size_t sessIdLen = static_cast<size_t>(serverHello[38]);
     debugs(83, 7, "Session ID Length: " <<  sessIdLen);
 
     // The size should be enough to hold at least the following
-    // 5 MsgHelloHeader + 4 (hello header)
+    // 4 (hello header)
     // + 2 (SSL Version) + 32 (random) + 1 (sessionId length)
     // + sessIdLength + 2 (cipher suite) + 1 (compression method)
-    // = 47 + sessIdLength
-    if (47 + sessIdLen > size) {
+    // = 42 + sessIdLength
+    if (42 + sessIdLen > helloSize) {
         debugs(83, 2, "ciphers length parse error");
         return false;
     }
 
-    // The sessionID stored at 44 position, after sessionID length field
-    sessionId.assign((const char *)(hello + 44), sessIdLen);
+    // The sessionID stored at 39 position, after sessionID length field
+    sessionId.assign(reinterpret_cast<const char *>(serverHello + 39), sessIdLen);
 
     // Check if there are extensions in hello message
     // RFC5246 section 7.4.1.4
-    if (size > 47 + sessIdLen + 2) {
-        // 47 + sessIdLen
-        const unsigned char *pToExtensions = hello + 47 + sessIdLen;
+    if (helloSize > 42 + sessIdLen + 2) {
+        // 42 + sessIdLen
+        const unsigned char *pToExtensions = serverHello + 42 + sessIdLen;
         const size_t extensionsLen = (pToExtensions[0] << 8) | pToExtensions[1];
         // Check if the hello size can hold extensions
-        if (47 + 2 + sessIdLen + extensionsLen > size ) {
+        if (42 + 2 + sessIdLen + extensionsLen > helloSize ) {
             debugs(83, 2, "Extensions length parse error");
             return false;
         }
 
         pToExtensions += 2;
         const unsigned char *ext = pToExtensions;
         while (ext + 4 <= pToExtensions + extensionsLen) {
-            const short extType = (ext[0] << 8) | ext[1];
+            const size_t extType = (ext[0] << 8) | ext[1];
             ext += 2;
-            const short extLen = (ext[0] << 8) | ext[1];
+            const size_t extLen = (ext[0] << 8) | ext[1];
             ext += 2;
             debugs(83, 7, "TLS Extension: " << std::hex << extType << " of size:" << extLen);
             // SessionTicket TLS Extension, RFC5077 section 3.2
@@ -948,17 +943,18 @@ Ssl::Bio::sslFeatures::parseV3ServerHello(const unsigned char *hello, size_t siz
 }
 
 bool
-Ssl::Bio::sslFeatures::parseV3Hello(const unsigned char *hello, size_t size)
+Ssl::Bio::sslFeatures::parseV3Hello(const unsigned char *messageContainer, size_t messageContainerSize)
 {
     // Parse a ClientHello Handshake message
     // RFC5246 section 7.4, 7.4.1.2
-    // The ClientHello starts at hello+5
+    // The ClientHello starts at messageContainer + 5
+    const unsigned char * clientHello = messageContainer + 5;
 
     debugs(83, 7, "Get fake features from v3 ClientHello message.");
-    const size_t helloSize = (hello[6] << 16) | (hello[7] << 8) | hello[8];
+    // The Length field (bytes 1-3) plus 4 bytes of the clientHello message header (1 handshake type + 3 hello length)
+    const size_t helloSize = ((clientHello[1] << 16) | (clientHello[2] << 8) | clientHello[3]) + 4;
     debugs(83, 7, "ClientHello message size: " << helloSize);
-    // helloSize should be size + hello Header (4 bytes)
-    if (helloSize + 4 > size) {
+    if (helloSize > messageContainerSize) {
         debugs(83, 2, "ClientHello parse error");
         return false;
     }
@@ -971,118 +967,124 @@ Ssl::Bio::sslFeatures::parseV3Hello(const unsigned char *hello, size_t size)
     }
 
     //For SSLv3 or TLSv1.* protocols we can get some more informations
-    if (hello[1] == 0x3 && hello[5] == 0x1 /*HELLO A message*/) {
-        // Get the correct version of the sub-hello message
-        sslVersion = (hello[9] << 8) | hello[10];
-        //Get Client Random number. It starts on the position 11 of hello message
-        memcpy(client_random, hello + 11, SSL3_RANDOM_SIZE);
-        debugs(83, 7, "Client random: " <<  objToString(client_random, SSL3_RANDOM_SIZE));
-
-        // At the position 43 (11+SSL3_RANDOM_SIZE)
-        const size_t sessIDLen = (size_t)hello[43];
-        debugs(83, 7, "Session ID Length: " <<  sessIDLen);
-
-        // The size should be enough to hold at least the following
-        // 5 MsgHelloHeader + 4 (hello header)
-        // + 2 (SSL Version) + 32 (random) + 1 (sessionId length)
-        // + sessIdLength + 2 (cipher suite length) + 1 (compression method length)
-        // = 47 + sessIdLength
-        if (47 + sessIDLen > size)
-            return false;
+    if (messageContainer[1] != 0x3 || clientHello[0] != 0x1 /*HELLO A message*/) {
+        debugs(83, 2, "Not an SSLv3/TLSv1.x client hello message, stop parsing here");
+        return true;
+    }
 
-        // The sessionID stored art 44 position, after sessionID length field
-        sessionId.assign((const char *)(hello + 44), sessIDLen);
+    // Get the correct version of the sub-hello message
+    sslVersion = (clientHello[4] << 8) | clientHello[5];
+    //Get Client Random number. It starts on the position 6 of clientHello message
+    memcpy(client_random, clientHello + 6, SSL3_RANDOM_SIZE);
+    debugs(83, 7, "Client random: " <<  objToString(client_random, SSL3_RANDOM_SIZE));
 
-        //Ciphers list. It is stored after the Session ID.
-        // It is a variable-length vector(RFC5246 section 4.3)
-        const unsigned char *ciphers = hello + 44 + sessIDLen;
-        const size_t ciphersLen = (ciphers[0] << 8) | ciphers[1];
-        if (47 + sessIDLen + ciphersLen > size) {
-            debugs(83, 2, "ciphers length parse error");
-            return false;
+    // At the position 38 (6+SSL3_RANDOM_SIZE)
+    const size_t sessIDLen = static_cast<size_t>(clientHello[38]);
+    debugs(83, 7, "Session ID Length: " <<  sessIDLen);
+
+    // The helloSize should be enough to hold at least the following
+    // 1 handshake type + 3 hello Length
+    // + 2 (SSL Version) + 32 (random) + 1 (sessionId length)
+    // + sessIdLength + 2 (cipher suite length) + 1 (compression method length)
+    // = 42 + sessIdLength
+    if (42 + sessIDLen > helloSize) {
+        debugs(83, 2, "Session ID length parse error");
+        return false;
+    }
+
+    // The sessionID stored art 39 position, after sessionID length field
+    sessionId.assign(reinterpret_cast<const char *>(clientHello + 39), sessIDLen);
+
+    //Ciphers list. It is stored after the Session ID.
+    // It is a variable-length vector(RFC5246 section 4.3)
+    const unsigned char *ciphers = clientHello + 39 + sessIDLen;
+    const size_t ciphersLen = (ciphers[0] << 8) | ciphers[1];
+    if (42 + sessIDLen + ciphersLen > helloSize) {
+        debugs(83, 2, "ciphers length parse error");
+        return false;
+    }
+
+    ciphers += 2;
+    if (ciphersLen) {
+        const SSL_METHOD *method = SSLv3_method();
+        const int cs = method->put_cipher_by_char(NULL, NULL);
+        assert(cs > 0);
+        for (size_t i = 0; i < ciphersLen; i += cs) {
+            const SSL_CIPHER *c = method->get_cipher_by_char((ciphers + i));
+            if (c != NULL) {
+                if (!clientRequestedCiphers.empty())
+                    clientRequestedCiphers.append(":");
+                clientRequestedCiphers.append(c->name);
+            } else
+                unknownCiphers = true;
         }
+    }
+    debugs(83, 7, "Ciphers requested by client: " << clientRequestedCiphers);
 
-        ciphers += 2;
-        if (ciphersLen) {
-            const SSL_METHOD *method = SSLv3_method();
-            const int cs = method->put_cipher_by_char(NULL, NULL);
-            assert(cs > 0);
-            for (size_t i = 0; i < ciphersLen; i += cs) {
-                const SSL_CIPHER *c = method->get_cipher_by_char((ciphers + i));
-                if (c != NULL) {
-                    if (!clientRequestedCiphers.empty())
-                        clientRequestedCiphers.append(":");
-                    clientRequestedCiphers.append(c->name);
-                } else
-                    unknownCiphers = true;
-            }
+    // Compression field: 1 bytes the number of compression methods and
+    // 1 byte for each compression method
+    const unsigned char *compression = ciphers + ciphersLen;
+    if (compression[0] > 1)
+        compressMethod = 1;
+    else
+        compressMethod = 0;
+    debugs(83, 7, "SSL compression methods number: " << static_cast<int>(compression[0]));
+
+    // Parse Extensions, RFC5246 section 7.4.1.4
+    const unsigned char *pToExtensions = compression + 1 + static_cast<int>(compression[0]);
+    if ((size_t)((pToExtensions - clientHello) + 2) < helloSize) {
+        const size_t extensionsLen = (pToExtensions[0] << 8) | pToExtensions[1];
+        if ((pToExtensions - clientHello) + 2 + extensionsLen > helloSize) {
+            debugs(83, 2, "Extensions length parse error");
+            return false;
         }
-        debugs(83, 7, "Ciphers requested by client: " << clientRequestedCiphers);
 
-        // Compression field: 1 bytes the number of compression methods and
-        // 1 byte for each compression method
-        const unsigned char *compression = ciphers + ciphersLen;
-        if (compression[0] > 1)
-            compressMethod = 1;
-        else
-            compressMethod = 0;
-        debugs(83, 7, "SSL compression methods number: " << (int)compression[0]);
-
-        // Parse Extensions, RFC5246 section 7.4.1.4
-        const unsigned char *pToExtensions = compression + 1 + (int)compression[0];
-        if ((size_t)((pToExtensions - hello) + 2) < size) {
-            const size_t extensionsLen = (pToExtensions[0] << 8) | pToExtensions[1];
-            if ((pToExtensions - hello) + 2 + extensionsLen > size) {
-                debugs(83, 2, "Extensions length parse error");
+        pToExtensions += 2;
+        const unsigned char *ext = pToExtensions;
+        while (ext + 4 <= pToExtensions + extensionsLen) {
+            const size_t extType = (ext[0] << 8) | ext[1];
+            ext += 2;
+            const size_t extLen = (ext[0] << 8) | ext[1];
+            ext += 2;
+            debugs(83, 7, "TLS Extension: " << std::hex << extType << " of size:" << extLen);
+
+            if (ext + extLen > pToExtensions + extensionsLen) {
+                debugs(83, 2, "Extension " << std::hex << extType << " length parser error");
                 return false;
             }
 
-            pToExtensions += 2;
-            const unsigned char *ext = pToExtensions;
-            while (ext + 4 <= pToExtensions + extensionsLen) {
-                const short extType = (ext[0] << 8) | ext[1];
-                ext += 2;
-                const short extLen = (ext[0] << 8) | ext[1];
-                ext += 2;
-                debugs(83, 7, "TLS Extension: " << std::hex << extType << " of size:" << extLen);
-
-                if (ext + extLen > pToExtensions + extensionsLen) {
-                    debugs(83, 2, "Extension " << std::hex << extType << " length parser error");
-                    return false;
-                }
+            //The SNI extension has the type 0 (extType == 0)
+            // RFC6066 sections 3, 10.2
+            // The two first bytes indicates the length of the SNI data (should be extLen-2)
+            // The next byte is the hostname type, it should be '0' for normal hostname (ext[2] == 0)
+            // The 3rd and 4th bytes are the length of the hostname
+            if (extType == 0 && ext[2] == 0) {
+                const size_t hostLen = (ext[3] << 8) | ext[4];
+                if (hostLen < extLen)
+                    serverName.assign(reinterpret_cast<const char *>(ext+5), hostLen);
+                debugs(83, 7, "Found server name: " << serverName);
+            } else if (extType == 15 && ext[0] != 0) {
+                // The heartBeats are the type 15, RFC6520
+                doHeartBeats = true;
+            } else if (extType == 0x23) {
+                //SessionTicket TLS Extension RFC5077
+                tlsTicketsExtension = true;
+                if (extLen != 0)
+                    hasTlsTicket = true;
+            } else if (extType == 0x05) {
+                // RFC6066 sections 8, 10.2
+                tlsStatusRequest = true;
+            } else if (extType == 0x3374) {
+                // detected TLS next protocol negotiate extension
+            } else if (extType == 0x10) {
+                // Application-Layer Protocol Negotiation Extension, RFC7301
+                const size_t listLen = (ext[0] << 8) | ext[1];
+                if (listLen < extLen)
+                    tlsAppLayerProtoNeg.assign(reinterpret_cast<const char *>(ext+5), listLen);
+            } else
+                extensions.push_back(extType);
 
-                //The SNI extension has the type 0 (extType == 0)
-                // RFC6066 sections 3, 10.2
-                // The two first bytes indicates the length of the SNI data (should be extLen-2)
-                // The next byte is the hostname type, it should be '0' for normal hostname (ext[2] == 0)
-                // The 3rd and 4th bytes are the length of the hostname
-                if (extType == 0 && ext[2] == 0) {
-                    const int hostLen = (ext[3] << 8) | ext[4];
-                    serverName.assign((const char *)(ext+5), hostLen);
-                    debugs(83, 7, "Found server name: " << serverName);
-                } else if (extType == 15 && ext[0] != 0) {
-                    // The heartBeats are the type 15, RFC6520
-                    doHeartBeats = true;
-                } else if (extType == 0x23) {
-                    //SessionTicket TLS Extension RFC5077
-                    tlsTicketsExtension = true;
-                    if (extLen != 0)
-                        hasTlsTicket = true;
-                } else if (extType == 0x05) {
-                    // RFC6066 sections 8, 10.2
-                    tlsStatusRequest = true;
-                } else if (extType == 0x3374) {
-                    // detected TLS next protocol negotiate extension
-                } else if (extType == 0x10) {
-                    // Application-Layer Protocol Negotiation Extension, RFC7301
-                    const int listLen = (ext[0] << 8) | ext[1];
-                    if (listLen < extLen)
-                        tlsAppLayerProtoNeg.assign((const char *)(ext+5), listLen);
-                } else
-                    extensions.push_back(extType);
-
-                ext += extLen;
-            }
+            ext += extLen;
         }
     }
     return true;
@@ -1091,22 +1093,21 @@ Ssl::Bio::sslFeatures::parseV3Hello(const unsigned char *hello, size_t size)
 bool
 Ssl::Bio::sslFeatures::parseV23Hello(const unsigned char *hello, size_t size)
 {
-#if defined(DO_SSLV23)
     debugs(83, 7, "Get fake features from v23 ClientHello message.");
     if (size < 7)
         return false;
     //Ciphers list. It is stored after the Session ID.
-    const int ciphersLen = (hello[5] << 8) | hello[6];
+    const unsigned int ciphersLen = (hello[5] << 8) | hello[6];
     const unsigned char *ciphers = hello + 11;
 
-    if (size < ciphersLen + 11 + SSL3_RANDOM_SIZE)
+    if (size < ciphersLen + 11)
         return false;
 
     if (ciphersLen) {
         const SSL_METHOD *method = SSLv23_method();
         int cs = method->put_cipher_by_char(NULL, NULL);
         assert(cs > 0);
-        for (int i = 0; i < ciphersLen; i += cs) {
+        for (unsigned int i = 0; i < ciphersLen; i += cs) {
             // The v2 hello messages cipher has 3 bytes.
             // The v2 cipher has the first byte not null
             // Because we are going to sent only v3 message we
@@ -1123,15 +1124,18 @@ Ssl::Bio::sslFeatures::parseV23Hello(const unsigned char *hello, size_t size)
     }
     debugs(83, 7, "Ciphers requested by client: " << clientRequestedCiphers);
 
-    //Get Client Random number. It starts on the position 11 of hello message
-    memcpy(client_random, ciphers + ciphersLen, SSL3_RANDOM_SIZE);
-    debugs(83, 7, "Client random: " <<  objToString(client_random, SSL3_RANDOM_SIZE));
+    const unsigned int sessionIdLength = (hello[7] << 8) | hello[8];
+    debugs(83, 7, "SessionID length: " << sessionIdLength);
+    // SessionID starts at: hello+11+ciphersLen
+    if (sessionIdLength)
+        sessionId.assign((const char *)(hello + 11 + ciphersLen), sessionIdLength);
+
+    const unsigned int challengeLength = (hello[5] << 9) | hello[10];
+    debugs(83, 7, "Challenge Length: " << challengeLength);
+    //challenge starts at: hello+11+ciphersLen+sessionIdLength
 
     compressMethod = 0;
     return true;
-#else
-    return false;
-#endif
 }
 
 void
@@ -95,7 +95,7 @@ Ssl::CertValidationMsg::parseResponse(CertValidationResponse &resp, STACK_OF(X50
                 strncmp(param, param_cert.c_str(), param_cert.length()) == 0) {
             CertItem ci;
             ci.name.assign(param, param_len);
-            X509_Pointer x509;
+            Security::CertPointer x509;
             readCertFromMemory(x509, value);
             ci.setCert(x509.get());
             certs.push_back(ci);
@@ -52,7 +52,7 @@ class CertValidationResponse
         int id; ///<  The id of the error
         ssl_error_t error_no; ///< The OpenSSL error code
         std::string error_reason; ///< A string describing the error
-        X509_Pointer cert; ///< The broken certificate
+        Security::CertPointer cert; ///< The broken certificate
     };
 
     typedef std::vector<RecvdError> RecvdErrors;
@@ -81,7 +81,7 @@ class CertValidationMsg : public CrtdMessage
     {
     public:
         std::string name; ///< The certificate Id to use
-        X509_Pointer cert;       ///< A pointer to certificate
+        Security::CertPointer cert;       ///< A pointer to certificate
         CertItem(): cert(NULL) {}
         CertItem(const CertItem &);
         CertItem & operator =(const CertItem &);
@@ -263,7 +263,7 @@ Ssl::CertificateDb::CertificateDb(std::string const & aDb_path, size_t aMax_db_s
         throw std::runtime_error("ssl_crtd is missing the required parameter. There should be -s and -M parameters together.");
 }
 
-bool Ssl::CertificateDb::find(std::string const & host_name, Ssl::X509_Pointer & cert, Ssl::EVP_PKEY_Pointer & pkey) {
+bool Ssl::CertificateDb::find(std::string const & host_name, Security::CertPointer & cert, Ssl::EVP_PKEY_Pointer & pkey) {
     const Locker locker(dbLock, Here);
     load();
     return pure_find(host_name, cert, pkey);
@@ -282,7 +282,7 @@ bool Ssl::CertificateDb::purgeCert(std::string const & key) {
     return true;
 }
 
-bool Ssl::CertificateDb::addCertAndPrivateKey(Ssl::X509_Pointer & cert, Ssl::EVP_PKEY_Pointer & pkey, std::string const & useName) {
+bool Ssl::CertificateDb::addCertAndPrivateKey(Security::CertPointer & cert, Ssl::EVP_PKEY_Pointer & pkey, std::string const & useName) {
     const Locker locker(dbLock, Here);
     load();
     if (!db || !cert || !pkey)
@@ -306,7 +306,7 @@ bool Ssl::CertificateDb::addCertAndPrivateKey(Ssl::X509_Pointer & cert, Ssl::EVP
 
     {
         TidyPointer<char, tidyFree> subject(X509_NAME_oneline(X509_get_subject_name(cert.get()), NULL, 0));
-        Ssl::X509_Pointer findCert;
+        Security::CertPointer findCert;
         Ssl::EVP_PKEY_Pointer findPkey;
         if (pure_find(useName.empty() ? subject.get() : useName, findCert, findPkey)) {
             // Replace with database certificate
@@ -427,7 +427,7 @@ size_t Ssl::CertificateDb::rebuildSize()
     return dbSize;
 }
 
-bool Ssl::CertificateDb::pure_find(std::string const & host_name, Ssl::X509_Pointer & cert, Ssl::EVP_PKEY_Pointer & pkey) {
+bool Ssl::CertificateDb::pure_find(std::string const & host_name, Security::CertPointer & cert, Ssl::EVP_PKEY_Pointer & pkey) {
     if (!db)
         return false;
 
@@ -98,11 +98,11 @@ class CertificateDb
 
     CertificateDb(std::string const & db_path, size_t aMax_db_size, size_t aFs_block_size);
     /// Find certificate and private key for host name
-    bool find(std::string const & host_name, Ssl::X509_Pointer & cert, Ssl::EVP_PKEY_Pointer & pkey);
+    bool find(std::string const & host_name, Security::CertPointer & cert, Ssl::EVP_PKEY_Pointer & pkey);
     /// Delete a certificate from database
     bool purgeCert(std::string const & key);
     /// Save certificate to disk.
-    bool addCertAndPrivateKey(Ssl::X509_Pointer & cert, Ssl::EVP_PKEY_Pointer & pkey, std::string const & useName);
+    bool addCertAndPrivateKey(Security::CertPointer & cert, Ssl::EVP_PKEY_Pointer & pkey, std::string const & useName);
     /// Create and initialize a database  under the  db_path
     static void create(std::string const & db_path);
     /// Check the database stored under the db_path.
@@ -121,7 +121,7 @@ class CertificateDb
     size_t getFileSize(std::string const & filename); ///< get file size on disk.
     size_t rebuildSize(); ///< Rebuild size_file
     /// Only find certificate in current db and return it.
-    bool pure_find(std::string const & host_name, Ssl::X509_Pointer & cert, Ssl::EVP_PKEY_Pointer & pkey);
+    bool pure_find(std::string const & host_name, Security::CertPointer & cert, Ssl::EVP_PKEY_Pointer & pkey);
 
     void deleteRow(const char **row, int rowIndex); ///< Delete a row from TXT_DB
     bool deleteInvalidCertificate(); ///< Delete invalid certificate.
@@ -7,10 +7,10 @@
  */
 
 #include "squid.h"
+#include "base/PackableStream.h"
 #include "mgr/Registration.h"
 #include "ssl/context_storage.h"
 #include "Store.h"
-#include "StoreEntryStream.h"
 
 #include <limits>
 #if HAVE_OPENSSL_SSL_H
@@ -29,7 +29,7 @@ Ssl::CertificateStorageAction::Create(const Mgr::Command::Pointer &aCmd)
 
 void Ssl::CertificateStorageAction::dump (StoreEntry *sentry)
 {
-    StoreEntryStream stream(sentry);
+    PackableStream stream(*sentry);
     const char delimiter = '\t';
     const char endString = '\n';
     // Page title.
@@ -56,7 +56,7 @@ static bool setSerialNumber(ASN1_INTEGER *ai, BIGNUM const* serial)
     return true;
 }
 
-bool Ssl::writeCertAndPrivateKeyToMemory(Ssl::X509_Pointer const & cert, Ssl::EVP_PKEY_Pointer const & pkey, std::string & bufferToWrite)
+bool Ssl::writeCertAndPrivateKeyToMemory(Security::CertPointer const & cert, Ssl::EVP_PKEY_Pointer const & pkey, std::string & bufferToWrite)
 {
     bufferToWrite.clear();
     if (!pkey || !cert)
@@ -80,7 +80,7 @@ bool Ssl::writeCertAndPrivateKeyToMemory(Ssl::X509_Pointer const & cert, Ssl::EV
     return true;
 }
 
-bool Ssl::appendCertToMemory(Ssl::X509_Pointer const & cert, std::string & bufferToWrite)
+bool Ssl::appendCertToMemory(Security::CertPointer const & cert, std::string & bufferToWrite)
 {
     if (!cert)
         return false;
@@ -104,7 +104,7 @@ bool Ssl::appendCertToMemory(Ssl::X509_Pointer const & cert, std::string & buffe
     return true;
 }
 
-bool Ssl::writeCertAndPrivateKeyToFile(Ssl::X509_Pointer const & cert, Ssl::EVP_PKEY_Pointer const & pkey, char const * filename)
+bool Ssl::writeCertAndPrivateKeyToFile(Security::CertPointer const & cert, Ssl::EVP_PKEY_Pointer const & pkey, char const * filename)
 {
     if (!pkey || !cert)
         return false;
@@ -124,7 +124,7 @@ bool Ssl::writeCertAndPrivateKeyToFile(Ssl::X509_Pointer const & cert, Ssl::EVP_
     return true;
 }
 
-bool Ssl::readCertAndPrivateKeyFromMemory(Ssl::X509_Pointer & cert, Ssl::EVP_PKEY_Pointer & pkey, char const * bufferToRead)
+bool Ssl::readCertAndPrivateKeyFromMemory(Security::CertPointer & cert, Ssl::EVP_PKEY_Pointer & pkey, char const * bufferToRead)
 {
     Ssl::BIO_Pointer bio(BIO_new(BIO_s_mem()));
     BIO_puts(bio.get(), bufferToRead);
@@ -142,7 +142,7 @@ bool Ssl::readCertAndPrivateKeyFromMemory(Ssl::X509_Pointer & cert, Ssl::EVP_PKE
     return true;
 }
 
-bool Ssl::readCertFromMemory(X509_Pointer & cert, char const * bufferToRead)
+bool Ssl::readCertFromMemory(Security::CertPointer & cert, char const * bufferToRead)
 {
     Ssl::BIO_Pointer bio(BIO_new(BIO_s_mem()));
     BIO_puts(bio.get(), bufferToRead);
@@ -160,7 +160,7 @@ bool Ssl::readCertFromMemory(X509_Pointer & cert, char const * bufferToRead)
 static const size_t MaxCnLen = 64;
 
 // Replace certs common name with the given
-static bool replaceCommonName(Ssl::X509_Pointer & cert, std::string const &rawCn)
+static bool replaceCommonName(Security::CertPointer & cert, std::string const &rawCn)
 {
     std::string cn = rawCn;
 
@@ -270,7 +270,7 @@ std::string & Ssl::CertificateProperties::dbKey() const
 // mimicked. More safe to mimic extensions would be added here if users request
 // them.
 static int
-mimicExtensions(Ssl::X509_Pointer & cert, Ssl::X509_Pointer const & mimicCert)
+mimicExtensions(Security::CertPointer & cert, Security::CertPointer const & mimicCert)
 {
     static int extensions[]= {
         NID_key_usage,
@@ -339,7 +339,7 @@ mimicExtensions(Ssl::X509_Pointer & cert, Ssl::X509_Pointer const & mimicCert)
     return added;
 }
 
-static bool buildCertificate(Ssl::X509_Pointer & cert, Ssl::CertificateProperties const &properties)
+static bool buildCertificate(Security::CertPointer & cert, Ssl::CertificateProperties const &properties)
 {
     // not an Ssl::X509_NAME_Pointer because X509_REQ_get_subject_name()
     // returns a pointer to the existing subject name. Nothing to clean here.
@@ -419,7 +419,7 @@ static bool buildCertificate(Ssl::X509_Pointer & cert, Ssl::CertificatePropertie
     return true;
 }
 
-static bool generateFakeSslCertificate(Ssl::X509_Pointer & certToStore, Ssl::EVP_PKEY_Pointer & pkeyToStore, Ssl::CertificateProperties const &properties,  Ssl::BIGNUM_Pointer const &serial)
+static bool generateFakeSslCertificate(Security::CertPointer & certToStore, Ssl::EVP_PKEY_Pointer & pkeyToStore, Ssl::CertificateProperties const &properties,  Ssl::BIGNUM_Pointer const &serial)
 {
     Ssl::EVP_PKEY_Pointer pkey;
     // Use signing certificates private key as generated certificate private key
@@ -431,7 +431,7 @@ static bool generateFakeSslCertificate(Ssl::X509_Pointer & certToStore, Ssl::EVP
     if (!pkey)
         return false;
 
-    Ssl::X509_Pointer cert(X509_new());
+    Security::CertPointer cert(X509_new());
     if (!cert)
         return false;
 
@@ -499,7 +499,7 @@ static  BIGNUM *createCertSerial(unsigned char *md, unsigned int n)
 
 /// Return the SHA1 digest of the DER encoded version of the certificate
 /// stored in a BIGNUM
-static BIGNUM *x509Digest(Ssl::X509_Pointer const & cert)
+static BIGNUM *x509Digest(Security::CertPointer const & cert)
 {
     unsigned int n;
     unsigned char md[EVP_MAX_MD_SIZE];
@@ -510,7 +510,7 @@ static BIGNUM *x509Digest(Ssl::X509_Pointer const & cert)
     return createCertSerial(md, n);
 }
 
-static BIGNUM *x509Pubkeydigest(Ssl::X509_Pointer const & cert)
+static BIGNUM *x509Pubkeydigest(Security::CertPointer const & cert)
 {
     unsigned int n;
     unsigned char md[EVP_MAX_MD_SIZE];
@@ -526,7 +526,7 @@ static BIGNUM *x509Pubkeydigest(Ssl::X509_Pointer const & cert)
 static bool createSerial(Ssl::BIGNUM_Pointer &serial, Ssl::CertificateProperties const &properties)
 {
     Ssl::EVP_PKEY_Pointer fakePkey;
-    Ssl::X509_Pointer fakeCert;
+    Security::CertPointer fakeCert;
 
     serial.reset(x509Pubkeydigest(properties.signWithX509));
     if (!serial.get()) {
@@ -547,7 +547,7 @@ static bool createSerial(Ssl::BIGNUM_Pointer &serial, Ssl::CertificateProperties
     return true;
 }
 
-bool Ssl::generateSslCertificate(Ssl::X509_Pointer & certToStore, Ssl::EVP_PKEY_Pointer & pkeyToStore, Ssl::CertificateProperties const &properties)
+bool Ssl::generateSslCertificate(Security::CertPointer & certToStore, Ssl::EVP_PKEY_Pointer & pkeyToStore, Ssl::CertificateProperties const &properties)
 {
     Ssl::BIGNUM_Pointer serial;
 
@@ -587,7 +587,7 @@ EVP_PKEY * Ssl::readSslPrivateKey(char const * keyFilename, pem_password_cb *pas
     return pkey;
 }
 
-void Ssl::readCertAndPrivateKeyFromFiles(Ssl::X509_Pointer & cert, Ssl::EVP_PKEY_Pointer & pkey, char const * certFilename, char const * keyFilename)
+void Ssl::readCertAndPrivateKeyFromFiles(Security::CertPointer & cert, Ssl::EVP_PKEY_Pointer & pkey, char const * certFilename, char const * keyFilename)
 {
     if (keyFilename == NULL)
         keyFilename = certFilename;
@@ -9,12 +9,9 @@
 #ifndef SQUID_SSL_GADGETS_H
 #define SQUID_SSL_GADGETS_H
 
-#include "base/TidyPointer.h"
+#include "security/forward.h"
 #include "ssl/crtd_message.h"
 
-#if HAVE_OPENSSL_SSL_H
-#include <openssl/ssl.h>
-#endif
 #if HAVE_OPENSSL_TXT_DB_H
 #include <openssl/txt_db.h>
 #endif
@@ -38,55 +35,15 @@ typedef SSL_METHOD * ContextMethod;
 #define SQUID_SSL_SIGN_HASH_IF_NONE "sha256"
 #endif
 
-/**
-   \ingroup SslCrtdSslAPI
-  * Add SSL locking (a.k.a. reference counting) to TidyPointer
-  */
-template <typename T, void (*DeAllocator)(T *t), int lock>
-class LockingPointer: public TidyPointer<T, DeAllocator>
-{
-public:
-    typedef TidyPointer<T, DeAllocator> Parent;
-
-    LockingPointer(T *t = NULL): Parent(t) {
-    }
-
-    void resetAndLock(T *t) {
-        if (t != this->get()) {
-            this->reset(t);
-            if (t)
-                CRYPTO_add(&t->references, 1, lock);
-        }
-    }
-};
-
-// Macro to be used to define the C++ equivalent function of an extern "C"
-// function. The C++ function suffixed with the _cpp extension
-#define CtoCpp1(function, argument) \
-        extern "C++" inline void function ## _cpp(argument a) { \
-            function(a); \
-        }
-
-// Macro to be used to define the C++ wrapper function of a sk_*_pop_free
-// openssl family functions. The C++ function suffixed with the _free_wrapper
-// extension
-#define sk_free_wrapper(sk_object, argument, freefunction) \
-        extern "C++" inline void sk_object ## _free_wrapper(argument a) { \
-            sk_object ## _pop_free(a, freefunction); \
-        }
-
 /**
  \ingroup SslCrtdSslAPI
  * TidyPointer typedefs for  common SSL objects
  */
-CtoCpp1(X509_free, X509 *)
-typedef LockingPointer<X509, X509_free_cpp, CRYPTO_LOCK_X509> X509_Pointer;
-
 sk_free_wrapper(sk_X509, STACK_OF(X509) *, X509_free)
 typedef TidyPointer<STACK_OF(X509), sk_X509_free_wrapper> X509_STACK_Pointer;
 
 CtoCpp1(EVP_PKEY_free, EVP_PKEY *)
-typedef LockingPointer<EVP_PKEY, EVP_PKEY_free_cpp, CRYPTO_LOCK_EVP_PKEY> EVP_PKEY_Pointer;
+typedef Security::LockingPointer<EVP_PKEY, EVP_PKEY_free_cpp, CRYPTO_LOCK_EVP_PKEY> EVP_PKEY_Pointer;
 
 CtoCpp1(BN_free, BIGNUM *)
 typedef TidyPointer<BIGNUM, BN_free_cpp> BIGNUM_Pointer;
@@ -118,9 +75,6 @@ typedef TidyPointer<SSL, SSL_free_cpp> SSL_Pointer;
 CtoCpp1(DH_free, DH *);
 typedef TidyPointer<DH, DH_free_cpp> DH_Pointer;
 
-sk_free_wrapper(sk_X509_CRL, STACK_OF(X509_CRL) *, X509_CRL_free)
-typedef TidyPointer<STACK_OF(X509_CRL), sk_X509_CRL_free_wrapper> X509_CRL_STACK_Pointer;
-
 sk_free_wrapper(sk_X509_NAME, STACK_OF(X509_NAME) *, X509_NAME_free)
 typedef TidyPointer<STACK_OF(X509_NAME), sk_X509_NAME_free_wrapper> X509_NAME_STACK_Pointer;
 
@@ -134,31 +88,31 @@ EVP_PKEY * createSslPrivateKey();
  \ingroup SslCrtdSslAPI
  * Write private key and SSL certificate to memory.
  */
-bool writeCertAndPrivateKeyToMemory(X509_Pointer const & cert, EVP_PKEY_Pointer const & pkey, std::string & bufferToWrite);
+bool writeCertAndPrivateKeyToMemory(Security::CertPointer const & cert, EVP_PKEY_Pointer const & pkey, std::string & bufferToWrite);
 
 /**
  \ingroup SslCrtdSslAPI
  * Append SSL certificate to bufferToWrite.
  */
-bool appendCertToMemory(X509_Pointer const & cert, std::string & bufferToWrite);
+bool appendCertToMemory(Security::CertPointer const & cert, std::string & bufferToWrite);
 
 /**
  \ingroup SslCrtdSslAPI
  * Write private key and SSL certificate to file.
  */
-bool writeCertAndPrivateKeyToFile(X509_Pointer const & cert, EVP_PKEY_Pointer const & pkey, char const * filename);
+bool writeCertAndPrivateKeyToFile(Security::CertPointer const & cert, EVP_PKEY_Pointer const & pkey, char const * filename);
 
 /**
  \ingroup SslCrtdSslAPI
  * Write private key and SSL certificate to memory.
  */
-bool readCertAndPrivateKeyFromMemory(X509_Pointer & cert, EVP_PKEY_Pointer & pkey, char const * bufferToRead);
+bool readCertAndPrivateKeyFromMemory(Security::CertPointer & cert, EVP_PKEY_Pointer & pkey, char const * bufferToRead);
 
 /**
  \ingroup SslCrtdSslAPI
  * Read SSL certificate from memory.
  */
-bool readCertFromMemory(X509_Pointer & cert, char const * bufferToRead);
+bool readCertFromMemory(Security::CertPointer & cert, char const * bufferToRead);
 
 /**
   \ingroup SslCrtdSslAPI
@@ -230,8 +184,8 @@ class CertificateProperties
 {
 public:
     CertificateProperties();
-    X509_Pointer mimicCert; ///< Certificate to mimic
-    X509_Pointer signWithX509; ///< Certificate to sign the generated request
+    Security::CertPointer mimicCert; ///< Certificate to mimic
+    Security::CertPointer signWithX509; ///< Certificate to sign the generated request
     EVP_PKEY_Pointer signWithPkey; ///< The key of the signing certificate
     bool setValidAfter; ///< Do not mimic "Not Valid After" field
     bool setValidBefore; ///< Do not mimic "Not Valid Before" field
@@ -254,7 +208,7 @@ class CertificateProperties
  * Return generated certificate and private key in resultX509 and resultPkey
  * variables.
  */
-bool generateSslCertificate(X509_Pointer & cert, EVP_PKEY_Pointer & pkey, CertificateProperties const &properties);
+bool generateSslCertificate(Security::CertPointer & cert, EVP_PKEY_Pointer & pkey, CertificateProperties const &properties);
 
 /**
  \ingroup SslCrtdSslAPI
@@ -268,7 +222,7 @@ EVP_PKEY * readSslPrivateKey(char const * keyFilename, pem_password_cb *passwd_c
  * \param certFilename name of file with certificate.
  * \param keyFilename name of file with private key.
  */
-void readCertAndPrivateKeyFromFiles(X509_Pointer & cert, EVP_PKEY_Pointer & pkey, char const * certFilename, char const * keyFilename);
+void readCertAndPrivateKeyFromFiles(Security::CertPointer & cert, EVP_PKEY_Pointer & pkey, char const * certFilename, char const * keyFilename);
 
 /**
  \ingroup SslCrtdSslAPI
@@ -201,7 +201,7 @@ static bool proccessNewRequest(Ssl::CrtdMessage & request_message, std::string c
 
     Ssl::CertificateDb db(db_path, max_db_size, fs_block_size);
 
-    Ssl::X509_Pointer cert;
+    Security::CertPointer cert;
     Ssl::EVP_PKEY_Pointer pkey;
     std::string &cert_subject = certProperties.dbKey();
 
@@ -31,14 +31,14 @@ void Ssl::CrtdMessage::parseBody(BodyParams & map, std::string & other_part) con
 void Ssl::CrtdMessage::composeBody(BodyParams const & map, std::string const & other_part) STUB
 
 #include "ssl/gadgets.h"
-X509_REQ * Ssl::createNewX509Request(EVP_PKEY_Pointer const & pkey, const char * hostname) STUB_RETVAL(NULL)
-bool Ssl::writeCertAndPrivateKeyToMemory(X509_Pointer const & cert, EVP_PKEY_Pointer const & pkey, std::string & bufferToWrite) STUB_RETVAL(false)
-bool Ssl::writeCertAndPrivateKeyToFile(X509_Pointer const & cert, EVP_PKEY_Pointer const & pkey, char const * filename) STUB_RETVAL(false)
-bool Ssl::readCertAndPrivateKeyFromMemory(X509_Pointer & cert, EVP_PKEY_Pointer & pkey, char const * bufferToRead) STUB_RETVAL(false)
-X509 * Ssl::signRequest(X509_REQ_Pointer const & request, X509_Pointer const & x509, EVP_PKEY_Pointer const & pkey, ASN1_TIME * timeNotAfter, BIGNUM const * serial) STUB_RETVAL(NULL)
-bool Ssl::generateSslCertificateAndPrivateKey(char const *host, X509_Pointer const & signedX509, EVP_PKEY_Pointer const & signedPkey, X509_Pointer & cert, EVP_PKEY_Pointer & pkey, BIGNUM const* serial) STUB_RETVAL(false)
-void Ssl::readCertAndPrivateKeyFromFiles(X509_Pointer & cert, EVP_PKEY_Pointer & pkey, char const * certFilename, char const * keyFilename) STUB
-bool Ssl::sslDateIsInTheFuture(char const * date) STUB_RETVAL(false)
+X509_REQ * Ssl::createNewX509Request(EVP_PKEY_Pointer const &, const char *) STUB_RETVAL(NULL)
+bool Ssl::writeCertAndPrivateKeyToMemory(Security::CertPointer const &, EVP_PKEY_Pointer const &, std::string &) STUB_RETVAL(false)
+bool Ssl::writeCertAndPrivateKeyToFile(Security::CertPointer const &, EVP_PKEY_Pointer const &, char const *) STUB_RETVAL(false)
+bool Ssl::readCertAndPrivateKeyFromMemory(Security::CertPointer &, EVP_PKEY_Pointer &, char const *) STUB_RETVAL(false)
+X509 * Ssl::signRequest(X509_REQ_Pointer const &, Security::CertPointer const &, EVP_PKEY_Pointer const &, ASN1_TIME *, BIGNUM const *) STUB_RETVAL(NULL)
+bool Ssl::generateSslCertificateAndPrivateKey(char const *, Security::CertPointer const &, EVP_PKEY_Pointer const &, Security::CertPointer &, EVP_PKEY_Pointer &, BIGNUM const *) STUB_RETVAL(false)
+void Ssl::readCertAndPrivateKeyFromFiles(Security::CertPointer &, EVP_PKEY_Pointer &, char const *, char const *) STUB
+bool Ssl::sslDateIsInTheFuture(char const *) STUB_RETVAL(false)
 
 #include "ssl/helper.h"
 Ssl::Helper * Ssl::Helper::GetInstance() STUB_RETVAL(NULL)
@@ -471,64 +471,6 @@ ssl_initialize(void)
     ssl_ex_index_ssl_validation_counter = SSL_get_ex_new_index(0, (void *) "ssl_validation_counter", NULL, NULL, &ssl_free_int);
 }
 
-/// \ingroup ServerProtocolSSLInternal
-static int
-ssl_load_crl(SSL_CTX *sslContext, const char *CRLfile)
-{
-    X509_STORE *st = SSL_CTX_get_cert_store(sslContext);
-    X509_CRL *crl;
-    BIO *in = BIO_new_file(CRLfile, "r");
-    int count = 0;
-
-    if (!in) {
-        debugs(83, 2, "WARNING: Failed to open CRL file '" << CRLfile << "'");
-        return 0;
-    }
-
-    while ((crl = PEM_read_bio_X509_CRL(in,NULL,NULL,NULL))) {
-        if (!X509_STORE_add_crl(st, crl))
-            debugs(83, 2, "WARNING: Failed to add CRL from file '" << CRLfile << "'");
-        else
-            ++count;
-
-        X509_CRL_free(crl);
-    }
-
-    BIO_free(in);
-    return count;
-}
-
-STACK_OF(X509_CRL) *
-Ssl::loadCrl(const char *CRLFile, long &flags)
-{
-    X509_CRL *crl;
-    BIO *in = BIO_new_file(CRLFile, "r");
-    if (!in) {
-        debugs(83, 2, "WARNING: Failed to open CRL file '" << CRLFile << "'");
-        return NULL;
-    }
-
-    STACK_OF(X509_CRL) *CRLs = sk_X509_CRL_new_null();
-    if (!CRLs) {
-        debugs(83, 2, "WARNING: Failed to allocate X509_CRL stack  to load file '" << CRLFile << "'");
-        return NULL;
-    }
-
-    int count = 0;
-    while ((crl = PEM_read_bio_X509_CRL(in,NULL,NULL,NULL))) {
-        if (!sk_X509_CRL_push(CRLs, crl))
-            debugs(83, 2, "WARNING: Failed to add CRL from file '" << CRLFile << "'");
-        else
-            ++count;
-    }
-    BIO_free(in);
-
-    if (count)
-        flags |= SSL_FLAG_VERIFY_CRL;
-
-    return CRLs;
-}
-
 DH *
 Ssl::readDHParams(const char *dhfile)
 {
@@ -666,21 +608,7 @@ configureSslContext(SSL_CTX *sslContext, AnyP::PortCfg &port)
             SSL_CTX_set_verify(sslContext, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, ssl_verify_cb);
         }
 
-        if (port.clientVerifyCrls.get()) {
-            X509_STORE *st = SSL_CTX_get_cert_store(sslContext);
-            for (int i = 0; i < sk_X509_CRL_num(port.clientVerifyCrls.get()); ++i) {
-                X509_CRL *crl = sk_X509_CRL_value(port.clientVerifyCrls.get(), i);
-                if (!X509_STORE_add_crl(st, crl))
-                    debugs(83, 2, "WARNING: Failed to add CRL");
-            }
-        }
-
-#if X509_V_FLAG_CRL_CHECK
-        if (port.secure.parsedFlags & SSL_FLAG_VERIFY_CRL_ALL)
-            X509_STORE_set_flags(SSL_CTX_get_cert_store(sslContext), X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL);
-        else if (port.secure.parsedFlags & SSL_FLAG_VERIFY_CRL)
-            X509_STORE_set_flags(SSL_CTX_get_cert_store(sslContext), X509_V_FLAG_CRL_CHECK);
-#endif
+        port.secure.updateContextCrl(sslContext);
 
     } else {
         debugs(83, 9, "Not requiring any client certificates");
@@ -784,7 +712,7 @@ ssl_next_proto_cb(SSL *s, unsigned char **out, unsigned char *outlen, const unsi
 #endif
 
 SSL_CTX *
-sslCreateClientContext(const char *certfile, const char *keyfile, const char *cipher, long options, long fl, const char *CAfile, const char *CApath, const char *CRLfile)
+sslCreateClientContext(const char *certfile, const char *keyfile, const char *cipher, long options, long fl, const char *CAfile, const char *CApath)
 {
     ssl_initialize();
 
@@ -861,19 +789,6 @@ sslCreateClientContext(const char *certfile, const char *keyfile, const char *ci
         debugs(83, DBG_IMPORTANT, "WARNING: Ignoring error setting CA certificate locations: " << ERR_error_string(ssl_error, NULL));
     }
 
-    if (*CRLfile) {
-        ssl_load_crl(sslContext, CRLfile);
-        fl |= SSL_FLAG_VERIFY_CRL;
-    }
-
-#if X509_V_FLAG_CRL_CHECK
-    if (fl & SSL_FLAG_VERIFY_CRL_ALL)
-        X509_STORE_set_flags(SSL_CTX_get_cert_store(sslContext), X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL);
-    else if (fl & SSL_FLAG_VERIFY_CRL)
-        X509_STORE_set_flags(SSL_CTX_get_cert_store(sslContext), X509_V_FLAG_CRL_CHECK);
-
-#endif
-
     if (!(fl & SSL_FLAG_NO_DEFAULT_CA) &&
             !SSL_CTX_set_default_verify_paths(sslContext)) {
         const int ssl_error = ERR_get_error();
@@ -1132,7 +1047,7 @@ sslGetUserCertificateChainPEM(SSL *ssl)
 /// \ingroup ServerProtocolSSLInternal
 /// Create SSL context and apply ssl certificate and private key to it.
 SSL_CTX *
-Ssl::createSSLContext(Ssl::X509_Pointer & x509, Ssl::EVP_PKEY_Pointer & pkey, AnyP::PortCfg &port)
+Ssl::createSSLContext(Security::CertPointer & x509, Ssl::EVP_PKEY_Pointer & pkey, AnyP::PortCfg &port)
 {
 #if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
     Ssl::SSL_CTX_Pointer sslContext(SSL_CTX_new(TLS_server_method()));
@@ -1155,7 +1070,7 @@ Ssl::createSSLContext(Ssl::X509_Pointer & x509, Ssl::EVP_PKEY_Pointer & pkey, An
 SSL_CTX *
 Ssl::generateSslContextUsingPkeyAndCertFromMemory(const char * data, AnyP::PortCfg &port)
 {
-    Ssl::X509_Pointer cert;
+    Security::CertPointer cert;
     Ssl::EVP_PKEY_Pointer pkey;
     if (!readCertAndPrivateKeyFromMemory(cert, pkey, data))
         return NULL;
@@ -1169,7 +1084,7 @@ Ssl::generateSslContextUsingPkeyAndCertFromMemory(const char * data, AnyP::PortC
 SSL_CTX *
 Ssl::generateSslContext(CertificateProperties const &properties, AnyP::PortCfg &port)
 {
-    Ssl::X509_Pointer cert;
+    Security::CertPointer cert;
     Ssl::EVP_PKEY_Pointer pkey;
     if (!generateSslCertificate(cert, pkey, properties))
         return NULL;
@@ -1186,7 +1101,7 @@ Ssl::generateSslContext(CertificateProperties const &properties, AnyP::PortCfg &
 bool
 Ssl::configureSSL(SSL *ssl, CertificateProperties const &properties, AnyP::PortCfg &port)
 {
-    Ssl::X509_Pointer cert;
+    Security::CertPointer cert;
     Ssl::EVP_PKEY_Pointer pkey;
     if (!generateSslCertificate(cert, pkey, properties))
         return false;
@@ -1209,7 +1124,7 @@ Ssl::configureSSL(SSL *ssl, CertificateProperties const &properties, AnyP::PortC
 bool
 Ssl::configureSSLUsingPkeyAndCertFromMemory(SSL *ssl, const char *data, AnyP::PortCfg &port)
 {
-    Ssl::X509_Pointer cert;
+    Security::CertPointer cert;
     Ssl::EVP_PKEY_Pointer pkey;
     if (!readCertAndPrivateKeyFromMemory(cert, pkey, data))
         return false;
@@ -1320,7 +1235,7 @@ static X509 * readSslX509CertificatesChain(char const * certFilename,  STACK_OF(
     return certificate;
 }
 
-void Ssl::readCertChainAndPrivateKeyFromFiles(X509_Pointer & cert, EVP_PKEY_Pointer & pkey, X509_STACK_Pointer & chain, char const * certFilename, char const * keyFilename)
+void Ssl::readCertChainAndPrivateKeyFromFiles(Security::CertPointer & cert, EVP_PKEY_Pointer & pkey, X509_STACK_Pointer & chain, char const * certFilename, char const * keyFilename)
 {
     if (keyFilename == NULL)
         keyFilename = certFilename;
@@ -1345,7 +1260,7 @@ void Ssl::readCertChainAndPrivateKeyFromFiles(X509_Pointer & cert, EVP_PKEY_Poin
     }
 }
 
-bool Ssl::generateUntrustedCert(X509_Pointer &untrustedCert, EVP_PKEY_Pointer &untrustedPkey, X509_Pointer const  &cert, EVP_PKEY_Pointer const & pkey)
+bool Ssl::generateUntrustedCert(Security::CertPointer &untrustedCert, EVP_PKEY_Pointer &untrustedPkey, Security::CertPointer const  &cert, EVP_PKEY_Pointer const & pkey)
 {
     // Generate the self-signed certificate, using a hard-coded subject prefix
     Ssl::CertificateProperties certProperties;
@@ -12,11 +12,9 @@
 #define SQUID_SSL_SUPPORT_H
 
 #include "base/CbDataList.h"
+#include "security/forward.h"
 #include "ssl/gadgets.h"
 
-#if HAVE_OPENSSL_SSL_H
-#include <openssl/ssl.h>
-#endif
 #if HAVE_OPENSSL_X509V3_H
 #include <openssl/x509v3.h>
 #endif
@@ -75,7 +73,7 @@ class CertError
 {
 public:
     ssl_error_t code; ///< certificate error code
-    X509_Pointer cert; ///< certificate with the above error code
+    Security::CertPointer cert; ///< certificate with the above error code
     CertError(ssl_error_t anErr, X509 *aCert);
     CertError(CertError const &err);
     CertError & operator = (const CertError &old);
@@ -92,7 +90,7 @@ typedef CbDataList<Ssl::CertError> CertErrors;
 SSL_CTX *sslCreateServerContext(AnyP::PortCfg &port);
 
 /// \ingroup ServerProtocolSSLAPI
-SSL_CTX *sslCreateClientContext(const char *certfile, const char *keyfile, const char *cipher, long options, long flags, const char *CAfile, const char *CApath, const char *CRLfile);
+SSL_CTX *sslCreateClientContext(const char *certfile, const char *keyfile, const char *cipher, long options, long flags, const char *CAfile, const char *CApath);
 
 /// \ingroup ServerProtocolSSLAPI
 int ssl_read_method(int, char *, int);
@@ -157,12 +155,6 @@ inline const char *bumpMode(int bm)
     return (0 <= bm && bm < Ssl::bumpEnd) ? Ssl::BumpModeStr[bm] : NULL;
 }
 
-/**
- \ingroup ServerProtocolSSLAPI
- * Load a CRLs list stored in a file
- */
-STACK_OF(X509_CRL) *loadCrl(const char *CRLFile, long &flags);
-
 /**
  \ingroup ServerProtocolSSLAPI
  * Load DH params from file
@@ -173,7 +165,7 @@ DH *readDHParams(const char *dhfile);
   \ingroup ServerProtocolSSLAPI
   * Generate a certificate to be used as untrusted signing certificate, based on a trusted CA
 */
-bool generateUntrustedCert(X509_Pointer & untrustedCert, EVP_PKEY_Pointer & untrustedPkey, X509_Pointer const & cert, EVP_PKEY_Pointer const & pkey);
+bool generateUntrustedCert(Security::CertPointer & untrustedCert, EVP_PKEY_Pointer & untrustedPkey, Security::CertPointer const & cert, EVP_PKEY_Pointer const & pkey);
 
 /**
   \ingroup ServerProtocolSSLAPI
@@ -201,7 +193,7 @@ SSL_CTX * generateSslContextUsingPkeyAndCertFromMemory(const char * data, AnyP::
   \ingroup ServerProtocolSSLAPI
   * Create an SSL context using the provided certificate and key
  */
-SSL_CTX * createSSLContext(Ssl::X509_Pointer & x509, Ssl::EVP_PKEY_Pointer & pkey, AnyP::PortCfg &port);
+SSL_CTX * createSSLContext(Security::CertPointer & x509, Ssl::EVP_PKEY_Pointer & pkey, AnyP::PortCfg &port);
 
 /**
   \ingroup ServerProtocolSSLAPI
@@ -230,7 +222,7 @@ void addChainToSslContext(SSL_CTX *sslContext, STACK_OF(X509) *certList);
  * \param certFilename name of file with certificate and certificates which must be chainned.
  * \param keyFilename name of file with private key.
  */
-void readCertChainAndPrivateKeyFromFiles(X509_Pointer & cert, EVP_PKEY_Pointer & pkey, X509_STACK_Pointer & chain, char const * certFilename, char const * keyFilename);
+void readCertChainAndPrivateKeyFromFiles(Security::CertPointer & cert, EVP_PKEY_Pointer & pkey, X509_STACK_Pointer & chain, char const * certFilename, char const * keyFilename);
 
 /**
    \ingroup ServerProtocolSSLAPI
@@ -149,25 +149,6 @@ Store::unlink(StoreEntry &)
     fatal("Store::unlink on invalid Store\n");
 }
 
-void *
-StoreEntry::operator new (size_t bytecount)
-{
-    assert(bytecount == sizeof (StoreEntry));
-
-    if (!pool) {
-        pool = memPoolCreate ("StoreEntry", bytecount);
-        pool->setChunkSize(2048 * 1024);
-    }
-
-    return pool->alloc();
-}
-
-void
-StoreEntry::operator delete (void *address)
-{
-    pool->freeOne(address);
-}
-
 void
 StoreEntry::makePublic()
 {
@@ -1083,6 +1064,14 @@ storeCheckCachableStats(StoreEntry *sentry)
                       store_check_cachable_hist.yes.Default);
 }
 
+void
+StoreEntry::lengthWentBad(const char *reason)
+{
+    debugs(20, 3, "because " << reason << ": " << *this);
+    EBIT_SET(flags, ENTRY_BAD_LENGTH);
+    releaseRequest();
+}
+
 void
 StoreEntry::complete()
 {
@@ -1107,10 +1096,8 @@ StoreEntry::complete()
 
     assert(mem_status == NOT_IN_MEMORY);
 
-    if (!validLength()) {
-        EBIT_SET(flags, ENTRY_BAD_LENGTH);
-        releaseRequest();
-    }
+    if (!EBIT_TEST(flags, ENTRY_BAD_LENGTH) && !validLength())
+        lengthWentBad("!validLength() in complete()");
 
 #if USE_CACHE_DIGESTS
     if (mem_obj->request)
@@ -1750,14 +1737,21 @@ StoreEntry::createMemObject(const char *aUrl, const char *aLogUrl, const HttpReq
     mem_obj->setUris(aUrl, aLogUrl, aMethod);
 }
 
-/* this just sets DELAY_SENDING */
+/** disable sending content to the clients.
+ *
+ * This just sets DELAY_SENDING.
+ */
 void
 StoreEntry::buffer()
 {
     EBIT_SET(flags, DELAY_SENDING);
 }
 
-/* this just clears DELAY_SENDING and Invokes the handlers */
+/** flush any buffered content.
+ *
+ * This just clears DELAY_SENDING and Invokes the handlers
+ * to begin sending anything that may be buffered.
+ */
 void
 StoreEntry::flush()
 {
@@ -12,11 +12,13 @@
 #define SQUID_STORE_KEY_MD5_H_
 
 #include "hash.h"
-#include "typedefs.h"
 
 class HttpRequestMethod;
 class HttpRequest;
 
+/* MD5 cache keys */
+typedef unsigned char cache_key;
+
 cache_key *storeKeyDup(const cache_key *);
 cache_key *storeKeyCopy(cache_key *, const cache_key *);
 void storeKeyFree(const cache_key *);
@@ -11,6 +11,8 @@
 #ifndef SQUID_STORE_REBUILD_H_
 #define SQUID_STORE_REBUILD_H_
 
+#include "store_key_md5.h"
+
 class StoreRebuildData
 {
 public:
@@ -33,6 +33,8 @@ class CapturingStoreEntry : public StoreEntry
     }
 
     virtual void append(char const * buf, int len) {
+        if (!buf || len < 0) // old 'String' can't handle these cases
+            return;
         _appended_text.append(buf, len);
     }
 };
@@ -385,7 +385,7 @@ SBufFindTest::RandomSBuf(const int length)
     // sizeof() counts the terminating zero at the end of characters
     // and the distribution is an 'inclusive' value range, so -2
     // TODO: add \0 character (needs reporting adjustments to print it as \0)
-    static std::uniform_int_distribution<uint8_t> dist(0, sizeof(characters)-2);
+    static xuniform_int_distribution<uint8_t> dist(0, sizeof(characters)-2);
 
     SBuf buf;
     buf.reserveCapacity(length);
@@ -7,7 +7,7 @@
  */
 
 #include "squid.h"
-#include "typedefs.h" /* for cache_key */
+#include "store_key_md5.h"
 
 #define STUB_API "CacheDigest.cc"
 #include "tests/STUB.h"
@@ -74,7 +74,12 @@ MemPoolMeter::MemPoolMeter() STUB_NOP
 void MemPoolMeter::flush() STUB
 static MemPools tmpMemPools;
 MemPools &MemPools::GetInstance() {return tmpMemPools;}
-MemPools::MemPools() STUB_NOP
+MemPools::MemPools() :
+    pools(nullptr),
+    mem_idle_limit(0),
+    poolCount(0),
+    defaultIsChunked(false)
+{}
 void MemPools::init() STUB_NOP
 void MemPools::flushMeters() STUB
 MemImplementingAllocator * MemPools::create(const char *label, size_t obj_size) STUB_RETVAL(NULL);
@@ -21,6 +21,7 @@ Security::PeerOptions Security::ProxyOutgoingConfig;
 void Security::PeerOptions::parse(char const*) STUB
 Security::ContextPointer Security::PeerOptions::createClientContext(bool) STUB_RETVAL(NULL)
 void Security::PeerOptions::updateTlsVersionLimits() STUB
+void Security::PeerOptions::updateContextCrl(Security::ContextPointer &) STUB
 void Security::PeerOptions::dumpCfg(Packable*, char const*) const STUB
 long Security::PeerOptions::parseOptions() STUB_RETVAL(0)
 long Security::PeerOptions::parseFlags() STUB_RETVAL(0)
@@ -57,7 +57,7 @@ bool CertError::operator == (const CertError &ce) const STUB_RETVAL(false)
 bool CertError::operator != (const CertError &ce) const STUB_RETVAL(false)
 } // namespace Ssl
 SSL_CTX *sslCreateServerContext(AnyP::PortCfg &port) STUB_RETVAL(NULL)
-SSL_CTX *sslCreateClientContext(const char *certfile, const char *keyfile, const char *cipher, long options, const char *flags, const char *CAfile, const char *CApath, const char *CRLfile) STUB_RETVAL(NULL)
+SSL_CTX *sslCreateClientContext(const char *certfile, const char *keyfile, const char *cipher, long options, const char *flags, const char *CAfile, const char *CApath) STUB_RETVAL(NULL)
 int ssl_read_method(int, char *, int) STUB_RETVAL(0)
 int ssl_write_method(int, const char *, int) STUB_RETVAL(0)
 void ssl_shutdown_method(SSL *ssl) STUB
@@ -72,14 +72,13 @@ namespace Ssl
 //GETX509ATTRIBUTE GetX509CAAttribute;
 //GETX509ATTRIBUTE GetX509Fingerprint;
 const char *BumpModeStr[] = {""};
-STACK_OF(X509_CRL) *loadCrl(const char *CRLFile, long &flags) STUB_RETVAL(NULL)
 DH *readDHParams(const char *dhfile) STUB_RETVAL(NULL)
-bool generateUntrustedCert(X509_Pointer & untrustedCert, EVP_PKEY_Pointer & untrustedPkey, X509_Pointer const & cert, EVP_PKEY_Pointer const & pkey) STUB_RETVAL(false)
+bool generateUntrustedCert(Security::CertPointer & untrustedCert, EVP_PKEY_Pointer & untrustedPkey, Security::CertPointer const & cert, EVP_PKEY_Pointer const & pkey) STUB_RETVAL(false)
 SSL_CTX * generateSslContext(CertificateProperties const &properties, AnyP::PortCfg &port) STUB_RETVAL(NULL)
 bool verifySslCertificate(SSL_CTX * sslContext,  CertificateProperties const &properties) STUB_RETVAL(false)
 SSL_CTX * generateSslContextUsingPkeyAndCertFromMemory(const char * data, AnyP::PortCfg &port) STUB_RETVAL(NULL)
 void addChainToSslContext(SSL_CTX *sslContext, STACK_OF(X509) *certList) STUB
-void readCertChainAndPrivateKeyFromFiles(X509_Pointer & cert, EVP_PKEY_Pointer & pkey, X509_STACK_Pointer & chain, char const * certFilename, char const * keyFilename) STUB
+void readCertChainAndPrivateKeyFromFiles(Security::CertPointer & cert, EVP_PKEY_Pointer & pkey, X509_STACK_Pointer & chain, char const * certFilename, char const * keyFilename) STUB
 int matchX509CommonNames(X509 *peer_cert, void *check_data, int (*check_func)(void *check_data,  ASN1_STRING *cn_data)) STUB_RETVAL(0)
 bool checkX509ServerValidity(X509 *cert, const char *server) STUB_RETVAL(false)
 int asn1timeToString(ASN1_TIME *tm, char *buf, int len) STUB_RETVAL(0)
@@ -81,12 +81,6 @@ size_t StoreEntry::inUseCount() STUB_RETVAL(0)
 void StoreEntry::getPublicByRequestMethod(StoreClient * aClient, HttpRequest * request, const HttpRequestMethod& method) STUB
 void StoreEntry::getPublicByRequest(StoreClient * aClient, HttpRequest * request) STUB
 void StoreEntry::getPublic(StoreClient * aClient, const char *uri, const HttpRequestMethod& method) STUB
-void *StoreEntry::operator new(size_t byteCount)
-{
-    STUB
-    return new StoreEntry();
-}
-void StoreEntry::operator delete(void *address) STUB
 void StoreEntry::setReleaseFlag() STUB
 //#if USE_SQUID_ESI
 //ESIElement::Pointer StoreEntry::cachedESITree STUB_RETVAL(NULL)
@@ -68,7 +68,6 @@ void setMaxFD(void) STUB
 void setSystemLimits(void) STUB
 void squid_signal(int sig, SIGHDLR * func, int flags) STUB
 void logsFlush(void) STUB
-void kb_incr(kb_t * k, size_t v) STUB
 void debugObj(int section, int level, const char *label, void *obj, ObjPackMethod pm) STUB
 void parseEtcHosts(void) STUB
 int getMyPort(void) STUB_RETVAL(0)
@@ -14,7 +14,7 @@
 #include "FwdState.h"
 class ClientHttpRequest;
 
-void tunnelStart(ClientHttpRequest *, int64_t *, int *, const AccessLogEntryPointer &al) STUB
+void tunnelStart(ClientHttpRequest *) STUB
 
 void switchToTunnel(HttpRequest *request, Comm::ConnectionPointer &clientConn, Comm::ConnectionPointer &srvConn) STUB
 
@@ -15,6 +15,5 @@
 const char *wordlistAdd(wordlist **, const char *) STUB_RETVAL(NULL)
 void wordlistAddWl(wordlist **, wordlist *) STUB
 void wordlistJoin(wordlist **, wordlist **) STUB
-wordlist *wordlistDup(const wordlist *) STUB_RETVAL(NULL)
 void wordlistDestroy(wordlist **) STUB
 
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#include "squid.h"
+#include "tests/testEnumIterator.h"
+#include "unitTestMain.h"
+
+#include <cppunit/TestAssert.h>
+
+CPPUNIT_TEST_SUITE_REGISTRATION( testEnumIterator );
+
+enum class TestEnum {
+    enumBegin_ = 0,
+    zero = enumBegin_,
+    one,
+    two,
+    three,
+    four,
+    enumEnd_
+};
+
+enum class UnsignedTestEnum : unsigned char {
+    enumBegin_ = 0,
+    zero = enumBegin_,
+    one,
+    two,
+    three,
+    four,
+    enumEnd_
+};
+
+void
+testEnumIterator::testForwardIter()
+{
+    WholeEnum<TestEnum>::iterator i = WholeEnum<TestEnum>().begin();
+    CPPUNIT_ASSERT(*i == TestEnum::zero);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::one);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::two);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::three);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::four);
+    ++i;
+    CPPUNIT_ASSERT(i == WholeEnum<TestEnum>().end());
+}
+
+void
+testEnumIterator::testReverseIter()
+{
+    WholeEnum<TestEnum>::reverse_iterator i = WholeEnum<TestEnum>().rbegin();
+    CPPUNIT_ASSERT(*i == TestEnum::four);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::three);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::two);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::one);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::zero);
+    ++i;
+    CPPUNIT_ASSERT(i == WholeEnum<TestEnum>().rend());
+}
+
+void
+testEnumIterator::testBidirectionalIter()
+{
+    WholeEnum<TestEnum>::iterator i = WholeEnum<TestEnum>().begin();
+    CPPUNIT_ASSERT(*i == TestEnum::zero);
+    ++i;
+    CPPUNIT_ASSERT(*i == TestEnum::one);
+    --i;
+    CPPUNIT_ASSERT(*i == TestEnum::zero);
+
+    auto enumBegin=WholeEnum<TestEnum>().begin();
+    auto enumEnd=WholeEnum<TestEnum>().end();
+    i=enumBegin;
+    int count=0;
+    while (i != enumEnd) {
+        ++i;
+        ++count;
+        if (count > 20) // prevent infinite loops in test
+            break;
+    }
+    while (i != enumBegin) {
+        --i;
+        ++count;
+        if (count > 20) // prevent infinite loops in test
+            break;
+    }
+    CPPUNIT_ASSERT_EQUAL(10, count);
+
+    --i; //intentional out-of-bounds
+    CPPUNIT_ASSERT(i != enumBegin);
+    CPPUNIT_ASSERT(*i != TestEnum::zero);
+}
+
+void
+testEnumIterator::testRangeFor()
+{
+    int j = 0;
+    for (auto e : WholeEnum<TestEnum>()) {
+        (void)e;
+        ++j;
+        if (j > 20) // prevent infinite loops in test
+            break;
+    }
+    CPPUNIT_ASSERT_EQUAL(5,j);
+}
+
+void
+testEnumIterator::testRangeForRange()
+{
+    int j = 0;
+    // free function-based range
+    for (auto e : EnumRange(TestEnum::two, TestEnum::four)) {
+        (void)e;
+        ++j;
+        if (j > 20) // prevent infinite loops in test
+            break;
+    }
+    CPPUNIT_ASSERT_EQUAL(2,j);
+}
+
+void
+testEnumIterator::testUnsignedEnum()
+{
+    int j = 0;
+    for (auto e = WholeEnum<TestEnum>().rbegin(); e != WholeEnum<TestEnum>().rend(); ++e ) {
+        (void)e;
+        ++j;
+        if (j > 20) // prevent infinite loops in test
+            break;
+    }
+    CPPUNIT_ASSERT_EQUAL(5,j);
+}
+
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 1996-2015 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_TESTENUMITERATOR_H_
+#define SQUID_TESTENUMITERATOR_H_
+
+#include "base/EnumIterator.h"
+
+#include <cppunit/extensions/HelperMacros.h>
+
+class testEnumIterator : public CPPUNIT_NS::TestFixture
+{
+    CPPUNIT_TEST_SUITE( testEnumIterator );
+    CPPUNIT_TEST( testForwardIter );
+    CPPUNIT_TEST( testReverseIter );
+    CPPUNIT_TEST( testBidirectionalIter );
+    CPPUNIT_TEST( testRangeFor );
+    CPPUNIT_TEST( testRangeForRange );
+    CPPUNIT_TEST( testUnsignedEnum );
+    CPPUNIT_TEST_SUITE_END();
+
+protected:
+    void testForwardIter();
+    void testReverseIter();
+    void testBidirectionalIter();
+    void testRangeFor();
+    void testRangeForRange();
+    void testUnsignedEnum();
+};
+
+#endif /* SQUID_TESTENUMITERATOR_H_ */
+
@@ -7,34 +7,37 @@
  */
 
 #include "squid.h"
+#include "base/PackableStream.h"
 #include "CapturingStoreEntry.h"
 #include "Store.h"
-#include "StoreEntryStream.h"
+#include "testPackableStream.h"
 #include "testStore.h"
-#include "testStoreEntryStream.h"
 
 #include <iomanip>
 #include <cppunit/TestAssert.h>
 
-CPPUNIT_TEST_SUITE_REGISTRATION( testStoreEntryStream );
+CPPUNIT_TEST_SUITE_REGISTRATION( testPackableStream );
 
 /* init memory pools */
 
-void testStoreEntryStream::setUp()
+void testPackableStream::setUp()
 {
     Mem::Init();
 }
 
+// TODO: test streaming to a MemBuf as well.
+
 void
-testStoreEntryStream::testGetStream()
+testPackableStream::testGetStream()
 {
     /* Setup a store root so we can create a StoreEntry */
     StorePointer aStore (new TestStore);
     Store::Root(aStore);
 
     CapturingStoreEntry * anEntry = new CapturingStoreEntry();
     {
-        StoreEntryStream stream(anEntry); // locks and unlocks/deletes anEntry
+        anEntry->lock("test");
+        PackableStream stream(*anEntry);
         CPPUNIT_ASSERT_EQUAL(1, anEntry->_buffer_calls);
         CPPUNIT_ASSERT_EQUAL(0, anEntry->_flush_calls);
 
@@ -51,10 +54,9 @@ testStoreEntryStream::testGetStream()
         CPPUNIT_ASSERT(anEntry->_flush_calls > preFlushCount);
 
         CPPUNIT_ASSERT_EQUAL(1, anEntry->_buffer_calls);
-
-        CPPUNIT_ASSERT_EQUAL(String("12345677.7 some text   !."),
-                             anEntry->_appended_text);
+        CPPUNIT_ASSERT_EQUAL(String("12345677.7 some text   !."), anEntry->_appended_text);
     }
+    delete anEntry; // does the unlock()
     Store::Root(NULL);
 }
 
@@ -6,18 +6,18 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-#ifndef SQUID_SRC_TEST_STORE_ENTRY_STREAM_H
-#define SQUID_SRC_TEST_STORE_ENTRY_STREAM_H
+#ifndef SQUID_SRC_TESTS_TESTPACKABLESTREAM_H
+#define SQUID_SRC_TESTS_TESTPACKABLESTREAM_H
 
 #include <cppunit/extensions/HelperMacros.h>
 
 /*
- * test StoreEntryStream
+ * test PackableStream
  */
 
-class testStoreEntryStream : public CPPUNIT_NS::TestFixture
+class testPackableStream : public CPPUNIT_NS::TestFixture
 {
-    CPPUNIT_TEST_SUITE( testStoreEntryStream );
+    CPPUNIT_TEST_SUITE( testPackableStream );
     CPPUNIT_TEST( testGetStream );
     CPPUNIT_TEST_SUITE_END();
 
@@ -28,5 +28,5 @@ class testStoreEntryStream : public CPPUNIT_NS::TestFixture
     void testGetStream();
 };
 
-#endif
+#endif /* SQUID_SRC_TESTS_TESTPACKABLESTREAM_H */
 
@@ -128,6 +128,66 @@ testTokenizer::testTokenizerToken()
 
 }
 
+void
+testTokenizer::testTokenizerSuffix()
+{
+    const SBuf canary("This text should not be changed.");
+
+    Parser::Tokenizer t(text);
+    SBuf s;
+
+    CharacterSet all(whitespace);
+    all += alpha;
+    all += crlf;
+    all += numbers;
+    all.add(':').add('.').add('/');
+
+    // an empty suffix should return false (the full output buffer case)
+    s = canary;
+    const SBuf before = t.remaining();
+    CPPUNIT_ASSERT(!t.suffix(s, all, 0));
+    // ... and a false return value means no parameter changes
+    CPPUNIT_ASSERT_EQUAL(canary, s);
+    // ... and a false return value means no input buffer changes
+    CPPUNIT_ASSERT_EQUAL(before, t.remaining());
+
+    // consume suffix until the last CRLF, including that last CRLF
+    SBuf::size_type remaining = t.remaining().length();
+    while (t.remaining().findLastOf(crlf) != SBuf::npos) {
+        CPPUNIT_ASSERT(t.remaining().length() > 0);
+        CPPUNIT_ASSERT(t.skipOneTrailing(all));
+        // ensure steady progress
+        CPPUNIT_ASSERT_EQUAL(remaining, t.remaining().length() + 1);
+        --remaining;
+    }
+
+    // no match (last char is not in the suffix set)
+    CPPUNIT_ASSERT(!t.suffix(s, crlf));
+    CPPUNIT_ASSERT(!t.suffix(s, whitespace));
+
+    // successful suffix tokenization
+    CPPUNIT_ASSERT(t.suffix(s, numbers));
+    CPPUNIT_ASSERT_EQUAL(SBuf("1"), s);
+    CPPUNIT_ASSERT(t.skipSuffix(SBuf("1.")));
+    CPPUNIT_ASSERT(t.skipSuffix(SBuf("/")));
+    CPPUNIT_ASSERT(t.suffix(s, alpha));
+    CPPUNIT_ASSERT_EQUAL(SBuf("HTTP"), s);
+    CPPUNIT_ASSERT(t.suffix(s, whitespace));
+    CPPUNIT_ASSERT_EQUAL(SBuf(" "), s);
+
+    // match until the end of the sample
+    CPPUNIT_ASSERT(t.suffix(s, all));
+    CPPUNIT_ASSERT_EQUAL(SBuf(), t.remaining());
+
+    // an empty buffer does not end with a token
+    s = canary;
+    CPPUNIT_ASSERT(!t.suffix(s, all));
+    CPPUNIT_ASSERT_EQUAL(canary, s); // no parameter changes
+
+    // we cannot skip an empty suffix, even in an empty buffer
+    CPPUNIT_ASSERT(!t.skipSuffix(SBuf()));
+}
+
 void
 testTokenizer::testCharacterSet()
 {
@@ -16,13 +16,15 @@ class testTokenizer : public CPPUNIT_NS::TestFixture
     CPPUNIT_TEST_SUITE( testTokenizer );
     CPPUNIT_TEST ( testCharacterSet );
     CPPUNIT_TEST ( testTokenizerPrefix );
+    CPPUNIT_TEST ( testTokenizerSuffix );
     CPPUNIT_TEST ( testTokenizerSkip );
     CPPUNIT_TEST ( testTokenizerToken );
     CPPUNIT_TEST ( testTokenizerInt64 );
     CPPUNIT_TEST_SUITE_END();
 
 protected:
     void testTokenizerPrefix();
+    void testTokenizerSuffix();
     void testTokenizerSkip();
     void testTokenizerToken();
     void testCharacterSet();
@@ -960,14 +960,6 @@ logsFlush(void)
         fflush(debug_log);
 }
 
-void
-kb_incr(kb_t * k, size_t v)
-{
-    k->bytes += v;
-    k->kb += (k->bytes >> 10);
-    k->bytes &= 0x3FF;
-}
-
 void
 debugObj(int section, int level, const char *label, void *obj, ObjPackMethod pm)
 {
@@ -22,7 +22,6 @@ extern int DebugSignal;
 /// Default is APP_SHORTNAME ('squid').
 extern SBuf service_name;
 
-void kb_incr(kb_t *, size_t);
 void parseEtcHosts(void);
 int getMyPort(void);
 void setUmask(mode_t mask);
@@ -36,6 +35,9 @@ typedef void (*ObjPackMethod) (void *obj, Packable * p);
 /* packs, then prints an object using debugs() */
 void debugObj(int section, int level, const char *label, void *obj, ObjPackMethod pm);
 
+/// callback type for signal handlers
+typedef void SIGHDLR(int sig);
+
 const char *getMyHostname(void);
 const char *uniqueHostname(void);
 
@@ -116,7 +116,7 @@ class TunnelStateData
 
     /// Sends "502 Bad Gateway" error response to the client,
     /// if it is waiting for Squid CONNECT response, closing connections.
-    void informUserOfPeerError(const char *errMsg);
+    void informUserOfPeerError(const char *errMsg, size_t);
 
     class Connection
     {
@@ -143,7 +143,7 @@ class TunnelStateData
         int len;
         char *buf;
         AsyncCall::Pointer writer; ///< pending Comm::Write callback
-        int64_t *size_ptr;      /* pointer to size in an ConnStateData for logging */
+        uint64_t *size_ptr;      /* pointer to size in an ConnStateData for logging */
 
         Comm::ConnectionPointer conn;    ///< The currently connected connection.
         uint8_t delayedLoops; ///< how many times a read on this connection has been postponed.
@@ -368,8 +368,8 @@ TunnelStateData::readServer(char *, size_t len, Comm::Flag errcode, int xerrno)
 
     if (len > 0) {
         server.bytesIn(len);
-        kb_incr(&(statCounter.server.all.kbytes_in), len);
-        kb_incr(&(statCounter.server.other.kbytes_in), len);
+        statCounter.server.all.kbytes_in += len;
+        statCounter.server.other.kbytes_in += len;
     }
 
     if (keepGoingAfterRead(len, errcode, xerrno, server, client))
@@ -389,29 +389,45 @@ TunnelStateData::readConnectResponseDone(char *, size_t len, Comm::Flag errcode,
     if (len > 0) {
         connectRespBuf->appended(len);
         server.bytesIn(len);
-        kb_incr(&(statCounter.server.all.kbytes_in), len);
-        kb_incr(&(statCounter.server.other.kbytes_in), len);
+        statCounter.server.all.kbytes_in += len;
+        statCounter.server.other.kbytes_in += len;
     }
 
     if (keepGoingAfterRead(len, errcode, xerrno, server, client))
         handleConnectResponse(len);
 }
 
 void
-TunnelStateData::informUserOfPeerError(const char *errMsg)
+TunnelStateData::informUserOfPeerError(const char *errMsg, const size_t sz)
 {
     server.len = 0;
+
+    if (logTag_ptr)
+        *logTag_ptr = LOG_TCP_TUNNEL;
+
     if (!clientExpectsConnectResponse()) {
         // closing the connection is the best we can do here
         debugs(50, 3, server.conn << " closing on error: " << errMsg);
         server.conn->close();
         return;
     }
-    ErrorState *err  = new ErrorState(ERR_CONNECT_FAIL, Http::scBadGateway, request.getRaw());
-    err->callback = tunnelErrorComplete;
-    err->callback_data = this;
-    *status_ptr = Http::scBadGateway;
-    errorSend(http->getConn()->clientConnection, err);
+
+    // if we have no reply suitable to relay, use 502 Bad Gateway
+    if (!sz || sz > static_cast<size_t>(connectRespBuf->contentSize())) {
+        ErrorState *err = new ErrorState(ERR_CONNECT_FAIL, Http::scBadGateway, request.getRaw());
+        *status_ptr = Http::scBadGateway;
+        err->callback = tunnelErrorComplete;
+        err->callback_data = this;
+        errorSend(http->getConn()->clientConnection, err);
+        return;
+    }
+
+    // if we need to send back the server response. write its headers to the client
+    server.len = sz;
+    memcpy(server.buf, connectRespBuf->content(), server.len);
+    copy(server.len, server, client, TunnelStateData::WriteClientDone);
+    // then close the server FD to prevent any relayed keep-alive causing CVE-2015-5400
+    server.closeIfOpen();
 }
 
 /* Read from client side and queue it for writing to the server */
@@ -446,7 +462,7 @@ TunnelStateData::handleConnectResponse(const size_t chunkSize)
     const bool parsed = rep.parse(connectRespBuf->content(), connectRespBuf->contentSize(), eof, &parseErr);
     if (!parsed) {
         if (parseErr > 0) { // unrecoverable parsing error
-            informUserOfPeerError("malformed CONNECT response from peer");
+            informUserOfPeerError("malformed CONNECT response from peer", 0);
             return;
         }
 
@@ -455,7 +471,7 @@ TunnelStateData::handleConnectResponse(const size_t chunkSize)
         assert(!parseErr);
 
         if (!connectRespBuf->hasSpace()) {
-            informUserOfPeerError("huge CONNECT response from peer");
+            informUserOfPeerError("huge CONNECT response from peer", 0);
             return;
         }
 
@@ -467,10 +483,16 @@ TunnelStateData::handleConnectResponse(const size_t chunkSize)
     // CONNECT response was successfully parsed
     *status_ptr = rep.sline.status();
 
+    // we need to relay the 401/407 responses when login=PASS(THRU)
+    const char *pwd = server.conn->getPeer()->login;
+    const bool relay = pwd && (strcmp(pwd, "PASS") != 0 || strcmp(pwd, "PASSTHRU") != 0) &&
+                       (*status_ptr == Http::scProxyAuthenticationRequired ||
+                        *status_ptr == Http::scUnauthorized);
+
     // bail if we did not get an HTTP 200 (Connection Established) response
     if (rep.sline.status() != Http::scOkay) {
         // if we ever decide to reuse the peer connection, we must extract the error response first
-        informUserOfPeerError("unsupported CONNECT response status code");
+        informUserOfPeerError("unsupported CONNECT response status code", (relay ? rep.hdr_sz : 0));
         return;
     }
 
@@ -526,7 +548,7 @@ TunnelStateData::readClient(char *, size_t len, Comm::Flag errcode, int xerrno)
 
     if (len > 0) {
         client.bytesIn(len);
-        kb_incr(&(statCounter.client_http.kbytes_in), len);
+        statCounter.client_http.kbytes_in += len;
     }
 
     if (keepGoingAfterRead(len, errcode, xerrno, client, server))
@@ -620,8 +642,8 @@ TunnelStateData::writeServerDone(char *, size_t len, Comm::Flag flag, int xerrno
     }
 
     /* Valid data */
-    kb_incr(&(statCounter.server.all.kbytes_out), len);
-    kb_incr(&(statCounter.server.other.kbytes_out), len);
+    statCounter.server.all.kbytes_out += len;
+    statCounter.server.other.kbytes_out += len;
     client.dataSent(len);
 
     /* If the other end has closed, so should we */
@@ -689,7 +711,7 @@ TunnelStateData::writeClientDone(char *, size_t len, Comm::Flag flag, int xerrno
     }
 
     /* Valid data */
-    kb_incr(&(statCounter.client_http.kbytes_out), len);
+    statCounter.client_http.kbytes_out += len;
     server.dataSent(len);
 
     /* If the other end has closed, so should we */
@@ -988,7 +1010,7 @@ tunnelConnectDone(const Comm::ConnectionPointer &conn, Comm::Flag status, int xe
 }
 
 void
-tunnelStart(ClientHttpRequest * http, int64_t * size_ptr, int *status_ptr, const AccessLogEntryPointer &al)
+tunnelStart(ClientHttpRequest * http)
 {
     debugs(26, 3, HERE);
     /* Create state structure. */
@@ -1014,7 +1036,7 @@ tunnelStart(ClientHttpRequest * http, int64_t * size_ptr, int *status_ptr, const
         if (ch.fastCheck() == ACCESS_DENIED) {
             debugs(26, 4, HERE << "MISS access forbidden.");
             err = new ErrorState(ERR_FORWARDING_DENIED, Http::scForbidden, request);
-            *status_ptr = Http::scForbidden;
+            http->al->http.code = Http::scForbidden;
             errorSend(http->getConn()->clientConnection, err);
             return;
         }
@@ -1030,12 +1052,13 @@ tunnelStart(ClientHttpRequest * http, int64_t * size_ptr, int *status_ptr, const
 #endif
     tunnelState->url = xstrdup(url);
     tunnelState->request = request;
-    tunnelState->server.size_ptr = size_ptr;
-    tunnelState->status_ptr = status_ptr;
+    tunnelState->server.size_ptr = &http->out.size;
+    tunnelState->client.size_ptr = &http->al->http.clientRequestSz.payloadData;
+    tunnelState->status_ptr = &http->al->http.code;
     tunnelState->logTag_ptr = &http->logType;
     tunnelState->client.conn = http->getConn()->clientConnection;
     tunnelState->http = http;
-    tunnelState->al = al;
+    tunnelState->al = http->al;
     //tunnelState->started is set in TunnelStateData ctor
 
     comm_add_close_handler(tunnelState->client.conn->fd,
@@ -1046,7 +1069,7 @@ tunnelStart(ClientHttpRequest * http, int64_t * size_ptr, int *status_ptr, const
                                      CommTimeoutCbPtrFun(tunnelTimeout, tunnelState));
     commSetConnTimeout(tunnelState->client.conn, Config.Timeout.lifetime, timeoutCall);
 
-    peerSelect(&(tunnelState->serverDestinations), request, al,
+    peerSelect(&(tunnelState->serverDestinations), request, http->al,
                NULL,
                tunnelPeerSelectComplete,
                tunnelState);
@@ -1110,8 +1133,8 @@ tunnelRelayConnectRequest(const Comm::ConnectionPointer &srv, void *data)
     hdr_out.clean();
     mb.append("\r\n", 2);
 
-    debugs(11, 2, "Tunnel Server REQUEST: " << tunnelState->server.conn << ":\n----------\n" <<
-           Raw("tunnelRelayConnectRequest", mb.content(), mb.contentSize()) << "\n----------");
+    debugs(11, 2, "Tunnel Server REQUEST: " << tunnelState->server.conn <<
+           ":\n----------\n" << mb.buf << "\n----------");
 
     AsyncCall::Pointer writeCall = commCbCall(5,5, "tunnelConnectReqWriteDone",
                                    CommIoCbPtrFun(tunnelConnectReqWriteDone,
@@ -6,88 +6,20 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
-#include "enums.h"
-
 #ifndef SQUID_TYPEDEFS_H
 #define SQUID_TYPEDEFS_H
 
-typedef int32_t sfileno;
-typedef signed int sdirno;
-
-typedef uint32_t nfmark_t;
-typedef unsigned char tos_t;
-
-typedef struct {
-    size_t bytes;
-    size_t kb;
-} kb_t;
-
-typedef struct _CommWriteStateData CommWriteStateData;
-
-#if SQUID_SNMP
-#include "cache_snmp.h"
-typedef variable_list *(oid_ParseFn) (variable_list *, snint *);
-#endif
-
-typedef void FREE(void *);
-typedef void FOCB(void *, int fd, int errcode);
-typedef void PF(int, void *);
+#include "anyp/ProtocolType.h"
+#include "enums.h"
 
 /* disk.c / diskd.c callback typedefs */
 typedef void DRCB(int, const char *buf, int size, int errflag, void *data);
 /* Disk read CB */
 typedef void DWCB(int, int, size_t, void *);    /* disk write CB */
-typedef void DOCB(int, int errflag, void *data);    /* disk open CB */
-typedef void DCCB(int, int errflag, void *data);    /* disk close CB */
-typedef void DUCB(int errflag, void *data); /* disk unlink CB */
-typedef void DTCB(int errflag, void *data); /* disk trunc CB */
-
-namespace Dns
-{
-class LookupDetails;
-}
-typedef void FQDNH(const char *, const Dns::LookupDetails &details, void *);
 
 #include "anyp/ProtocolType.h"
 class CachePeer;
 typedef void IRCB(CachePeer *, peer_t, AnyP::ProtocolType, void *, void *data);
 
-/* in wordlist.h */
-
-class wordlist;
-typedef void UH(void *data, wordlist *);
-
-/**
- * READ_HANDLER functions return < 0 if, and only if, they fail with an error.
- * On error, they must pass back an error code in 'errno'.
- */
-typedef int READ_HANDLER(int, char *, int);
-
-/**
- * WRITE_HANDLER functions return < 0 if, and only if, they fail with an error.
- * On error, they must pass back an error code in 'errno'.
- */
-typedef int WRITE_HANDLER(int, const char *, int);
-
-typedef int QS(const void *, const void *); /* qsort */
-typedef void STABH(void *);
-typedef void ERCB(int fd, void *, size_t);
-class StoreEntry;
-typedef void SIGHDLR(int sig);
-typedef void STVLDCB(void *, int, int);
-typedef int HLPSAVAIL(void *);
-typedef void HLPSONEQ(void *);
-typedef void HLPCMDOPTS(int *argc, char **argv);
-
-/* MD5 cache keys */
-typedef unsigned char cache_key;
-
-/* in case we want to change it later */
-typedef ssize_t mb_size_t;
-
-typedef int STDIRSELECT(const StoreEntry *);
-
-/*Use uint64_t to store miliseconds*/
-typedef uint64_t time_msec_t;
 #endif /* SQUID_TYPEDEFS_H */
 
@@ -916,3 +916,11 @@ URLHostName::extract(char const *aUrl)
     return Host;
 }
 
+URL::URL(AnyP::UriScheme const &aScheme) :
+    scheme_(aScheme),
+    hostIsNumeric_(false),
+    port_(0)
+{
+    *host_=0;
+}
+
@@ -69,7 +69,6 @@ typedef struct {
 static STCB urnHandleReply;
 static url_entry *urnParseReply(const char *inbuf, const HttpRequestMethod&);
 static const char *const crlf = "\r\n";
-static QS url_entry_sort;
 
 CBDATA_CLASS_INIT(UrnState);
 
@@ -2234,12 +2234,19 @@ parse_wccp2_service_ports(char *options, int portlist[])
 
     int i = 0;
     char *tmp = options;
+    static char copy[10];
 
     while (size_t len = strcspn(tmp, ",")) {
         if (i >= WCCP2_NUMPORTS) {
             fatalf("parse_wccp2_service_ports: too many ports (maximum: 8) in list '%s'\n", options);
         }
-        int p = xatoi(tmp);
+        if (len > 6) { // 6 because "65535,"
+            fatalf("parse_wccp2_service_ports: port value '%s' isn't valid (1..65535)\n", tmp);
+        }
+
+        memcpy(copy, tmp, len);
+        copy[len] = '\0';
+        int p = xatoi(copy);
 
         if (p < 1 || p > 65535) {
             fatalf("parse_wccp2_service_ports: port value '%s' isn't valid (1..65535)\n", tmp);
@@ -139,8 +139,8 @@ WhoisState::readReply(const Comm::ConnectionPointer &conn, char *aBuffer, size_t
         if (!dataWritten)
             setReplyToOK(entry);
 
-        kb_incr(&(statCounter.server.all.kbytes_in), aBufferLength);
-        kb_incr(&(statCounter.server.http.kbytes_in), aBufferLength);
+        statCounter.server.all.kbytes_in += aBufferLength;
+        statCounter.server.http.kbytes_in += aBufferLength;
 
         /* No range support, we always grab it all */
         dataWritten = true;
@@ -15,15 +15,10 @@
 void
 wordlistDestroy(wordlist ** list)
 {
-    wordlist *w = NULL;
-
-    while ((w = *list) != NULL) {
-        *list = w->next;
-        safe_free(w->key);
-        delete w;
+    while (*list != nullptr) {
+        const char *k = wordlistChopHead(list);
+        safe_free(k);
     }
-
-    *list = NULL;
 }
 
 const char *
@@ -32,12 +27,7 @@ wordlistAdd(wordlist ** list, const char *key)
     while (*list)
         list = &(*list)->next;
 
-    *list = new wordlist;
-
-    (*list)->key = xstrdup(key);
-
-    (*list)->next = NULL;
-
+    *list = new wordlist(key);
     return (*list)->key;
 }
 
@@ -59,9 +49,7 @@ wordlistAddWl(wordlist ** list, wordlist * wl)
         list = &(*list)->next;
 
     for (; wl; wl = wl->next, list = &(*list)->next) {
-        *list = new wordlist();
-        (*list)->key = xstrdup(wl->key);
-        (*list)->next = NULL;
+        *list = new wordlist(wl->key);
     }
 }
 
@@ -74,19 +62,6 @@ wordlistCat(const wordlist * w, MemBuf * mb)
     }
 }
 
-wordlist *
-wordlistDup(const wordlist * w)
-{
-    wordlist *D = NULL;
-
-    while (NULL != w) {
-        wordlistAdd(&D, w->key);
-        w = w->next;
-    }
-
-    return D;
-}
-
 SBufList
 ToSBufList(wordlist *wl)
 {
@@ -98,3 +73,16 @@ ToSBufList(wordlist *wl)
     return rv;
 }
 
+char *
+wordlistChopHead(wordlist **wl)
+{
+    if (*wl == nullptr)
+        return nullptr;
+
+    wordlist *w = *wl;
+    char *rv = w->key;
+    *wl = w->next;
+    delete w;
+    return rv;
+}
+
@@ -20,10 +20,22 @@
 class wordlist
 {
     MEMPROXY_CLASS(wordlist);
+    friend char *wordlistChopHead(wordlist **);
 
 public:
+    wordlist() : key(nullptr), next(nullptr) {}
+    // create a new wordlist node, with a copy of k as key
+    explicit wordlist(const char *k) : key(xstrdup(k)), next(nullptr) {}
+
+    wordlist(const wordlist &) = delete;
+    wordlist &operator=(const wordlist &) = delete;
+
     char *key;
     wordlist *next;
+
+private:
+    // does not free data members.
+    ~wordlist() = default;
 };
 
 class MemBuf;
@@ -52,12 +64,17 @@ void wordlistAddWl(wordlist **, wordlist *);
  */
 void wordlistJoin(wordlist **, wordlist **);
 
-/// duplicate a wordlist
-wordlist *wordlistDup(const wordlist *);
-
 /// destroy a wordlist
 void wordlistDestroy(wordlist **);
 
+/**  Remove and destroy the first element while preserving and returning its key
+ *
+ * \note the returned key must be freed by the caller using safe_free
+ * \note wl is altered so that it points to the second element
+ * \return nullptr if pointed-to wordlist is nullptr.
+ */
+char *wordlistChopHead(wordlist **);
+
 /// convert a wordlist to a SBufList
 SBufList ToSBufList(wordlist *);
 
@@ -57,34 +57,49 @@ check_PROGRAMS += debug \
 
 tcp_banger2_LDADD = $(top_builddir)/lib/libmiscutil.la
 
-STUBS = stub_cbdata.cc stub_debug.cc stub_MemBuf.cc stub_SBuf.cc stub_tools.cc stub_fatal.cc
+#do not include stub_libmem.cc here, as it would override libmem.la in
+# several tests whose purpose is testing libmem itself.
+STUBS = \
+	stub_cbdata.cc \
+	stub_debug.cc \
+	stub_MemBuf.cc \
+	stub_SBuf.cc \
+	stub_tools.cc \
+	stub_fatal.cc \
+	STUB.h
 DEBUG_SOURCE = test_tools.cc $(STUBS)
-CLEANFILES += $(STUBS)
+CLEANFILES += $(STUBS) stub_libmem.cc
 
 stub_cbdata.cc: $(top_srcdir)/src/tests/stub_cbdata.cc
-	cp $(top_srcdir)/src/tests/stub_cbdata.cc .
+	cp $(top_srcdir)/src/tests/stub_cbdata.cc $@
 
 stub_debug.cc: $(top_srcdir)/src/tests/stub_debug.cc
-	cp $(top_srcdir)/src/tests/stub_debug.cc .
+	cp $(top_srcdir)/src/tests/stub_debug.cc $@
 
 stub_MemBuf.cc: $(top_srcdir)/src/tests/stub_MemBuf.cc
-	cp $(top_srcdir)/src/tests/stub_MemBuf.cc .
+	cp $(top_srcdir)/src/tests/stub_MemBuf.cc $@
 
 stub_SBuf.cc: $(top_srcdir)/src/tests/stub_SBuf.cc
-	cp $(top_srcdir)/src/tests/stub_SBuf.cc .
+	cp $(top_srcdir)/src/tests/stub_SBuf.cc $@
 
 stub_tools.cc: $(top_srcdir)/src/tests/stub_tools.cc
-	cp $(top_srcdir)/src/tests/stub_tools.cc .
+	cp $(top_srcdir)/src/tests/stub_tools.cc $@
 
 stub_fatal.cc: $(top_srcdir)/src/tests/stub_fatal.cc
-	cp $(top_srcdir)/src/tests/stub_fatal.cc .
+	cp $(top_srcdir)/src/tests/stub_fatal.cc $@
+
+stub_libmem.cc: $(top_srcdir)/src/tests/stub_libmem.cc STUB.h
+	cp $(top_srcdir)/src/tests/stub_libmem.cc $@
+	
+STUB.h: $(top_srcdir)/src/tests/STUB.h
+	cp $(top_srcdir)/src/tests/STUB.h $@
 
 ## XXX: somewhat broken. Its meant to test our debugs() implementation.
 ## but it has never been linked to the actual src/debug.cc implementation !!
 ## all it tests are the stream operators and macro in src/Debug.h
-debug_SOURCES = debug.cc $(DEBUG_SOURCE)
+debug_SOURCES = debug.cc stub_libmem.cc $(DEBUG_SOURCE) 
 
-ESIExpressions_SOURCES = ESIExpressions.cc $(DEBUG_SOURCE)
+ESIExpressions_SOURCES = ESIExpressions.cc stub_libmem.cc $(DEBUG_SOURCE)
 ESIExpressions_LDADD = $(top_builddir)/src/esi/Expression.o \
 		$(LDADD)
 
@@ -102,12 +117,15 @@ mem_hdr_test_LDADD = \
 	$(LDADD)
 
 MemPoolTest_SOURCES = MemPoolTest.cc $(DEBUG_SOURCE)
+MemPoolTest_LDADD = \
+	$(top_builddir)/src/mem/libmem.la \
+	$(LDADD)
 
-splay_SOURCES = splay.cc $(DEBUG_SOURCE)
+splay_SOURCES = splay.cc stub_libmem.cc $(DEBUG_SOURCE)
 
-syntheticoperators_SOURCES = syntheticoperators.cc $(DEBUG_SOURCE)
+syntheticoperators_SOURCES = syntheticoperators.cc stub_libmem.cc $(DEBUG_SOURCE)
 
-VirtualDeleteOperator_SOURCES = VirtualDeleteOperator.cc $(DEBUG_SOURCE)
+VirtualDeleteOperator_SOURCES = VirtualDeleteOperator.cc stub_libmem.cc $(DEBUG_SOURCE)
 
 ## membanger won't link today. Bitrot..
 ##CC	= gcc
@@ -355,7 +355,7 @@ main(void)
     printf("done creating hash table: %d\n", hid);
 
     std::mt19937 mt;
-    std::uniform_int_distribution<> dist(0,16);
+    xuniform_int_distribution<> dist(0,16);
 
     while (fgets(buf, BUFSIZ, stdin)) {
         buf[strlen(buf) - 1] = '\0';
@@ -130,7 +130,7 @@ int
 main(int argc, char *argv[])
 {
     std::mt19937 generator;
-    std::uniform_int_distribution<int> distribution;
+    xuniform_int_distribution<int> distribution;
     auto nextRandom = std::bind (distribution, generator);
 
     {
@@ -29,25 +29,30 @@ include $(top_srcdir)/doc/manuals/Substitute.am
 ## Several files need to be shared but we cannot depend on the other
 ## directories to be built.
 test_tools.cc: $(top_srcdir)/test-suite/test_tools.cc
-	cp $(top_srcdir)/test-suite/test_tools.cc .
+	cp $(top_srcdir)/test-suite/test_tools.cc $@
 
 stub_debug.cc: $(top_srcdir)/src/tests/stub_debug.cc
-	cp $(top_srcdir)/src/tests/stub_debug.cc .
+	cp $(top_srcdir)/src/tests/stub_debug.cc $@
 
 time.cc: $(top_srcdir)/src/time.cc
-	cp $(top_srcdir)/src/time.cc .
+	cp $(top_srcdir)/src/time.cc $@
+
+stub_libmem.cc: $(top_srcdir)/src/tests/stub_libmem.cc STUB.h
+	cp $(top_srcdir)/src/tests/stub_libmem.cc $@
+	
+STUB.h: $(top_srcdir)/src/tests/STUB.h
+	cp $(top_srcdir)/src/tests/STUB.h $@
 
 # stock tools for unit tests - library independent versions of dlink_list
 # etc.
 # globals.cc is needed by test_tools.cc.
 # Neither of these should be disted from here.
 TESTSOURCES= test_tools.cc
-CLEANFILES += test_tools.cc stub_debug.cc time.cc
+CLEANFILES += test_tools.cc stub_debug.cc time.cc stub_libmem.cc STUB.h
 
 ## Test Scripts
 EXTRA_DIST += helper-ok-dying.pl helper-ok.pl
 
-
 ## ##### cachemgr.cgi  #####
 
 DEFAULT_CACHEMGR_CONFIG = $(sysconfdir)/cachemgr.conf
@@ -56,7 +61,9 @@ libexec_PROGRAMS = cachemgr$(CGIEXT)
 
 cachemgr__CGIEXT__SOURCES = cachemgr.cc \
 	stub_debug.cc \
+	stub_libmem.cc \
 	test_tools.cc \
+	STUB.h \
 	time.cc
 
 cachemgr__CGIEXT__CXXFLAGS = -DDEFAULT_CACHEMGR_CONFIG=\"$(DEFAULT_CACHEMGR_CONFIG)\" $(AM_CXXFLAGS)
@@ -68,8 +75,6 @@ man_MANS += cachemgr.cgi.8
 cachemgr.cgi.8: $(srcdir)/cachemgr.cgi.8.in Makefile
 	$(SUBSTITUTE) < $(srcdir)/cachemgr.cgi.8.in > $@
 
-
-
 ## Shared
 
 install-data-local:
@@ -27,20 +27,27 @@ include $(top_srcdir)/doc/manuals/Substitute.am
 ## Several files need to be shared but we cannot depend on the other
 ## directories to be built.
 test_tools.cc: $(top_srcdir)/test-suite/test_tools.cc
-	cp $(top_srcdir)/test-suite/test_tools.cc .
+	cp $(top_srcdir)/test-suite/test_tools.cc $@
 
 stub_debug.cc: $(top_srcdir)/src/tests/stub_debug.cc
-	cp $(top_srcdir)/src/tests/stub_debug.cc .
+	cp $(top_srcdir)/src/tests/stub_debug.cc $@
 
 time.cc: $(top_srcdir)/src/time.cc
-	cp $(top_srcdir)/src/time.cc .
+	cp $(top_srcdir)/src/time.cc $@
+
+stub_libmem.cc: $(top_srcdir)/src/tests/stub_libmem.cc STUB.h
+	cp $(top_srcdir)/src/tests/stub_libmem.cc $@
+	
+STUB.h: $(top_srcdir)/src/tests/STUB.h
+	cp $(top_srcdir)/src/tests/STUB.h $@
+	
 
 # stock tools for unit tests - library independent versions of dlink_list
 # etc.
 # globals.cc is needed by test_tools.cc.
 # Neither of these should be disted from here.
 TESTSOURCES= test_tools.cc
-CLEANFILES += test_tools.cc stub_debug.cc time.cc
+CLEANFILES += test_tools.cc stub_debug.cc time.cc stub_libmem.cc STUB.h
 
 ## ##### squidclient  #####
 
@@ -55,6 +62,8 @@ squidclient_SOURCES = \
 	squidclient.cc \
 	stub_debug.cc \
 	test_tools.cc \
+	stub_libmem.cc \
+	STUB.h \
 	time.cc \
 	Transport.cc \
 	Transport.h