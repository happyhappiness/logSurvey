@@ -1,20 +1,30 @@
 Special thanks go to people who have volunteered their time, effort,
 and ideas to make this software available.
 
+    'noloader' <noloader@gmail.com>
     Adam Ciarcinski
     Adrian Chadd <adrian@squid-cache.org>
+    Alan Mizrahi <alan@mizrahi.com.ve>
     Alex Rousskov <rousskov@measurement-factory.com>
     Alexander B. Demenshin <aldem@barnet.kharkov.ua>
+    Alexander Komyagin <komyagin@altell.ru>
     Alexander Lukyanov <lav@yar.ru>
+    Alexandre Chappaz <alexandrechappaz@gmail.com>
     Alexey Veselovsky <alexey.veselovsky@eykontech.com>
+    Alexis Robert <alexis.robert@gmail.com>
     Alin Nastac <mrness@gentoo.org>
     Alter <alter@alter.org.ua>
     Amos Jeffries <amosjeffries@squid-cache.org>
     Amos Jeffries <squid3@treenet.co.nz>
+    Anatoli <me@anatoli.ws>
+    Andrea Gagliardi <andrea@netlite.it>
+    Andreas Jaeger <aj@suse.com>
     Andreas Lamprecht <Andreas.Lamprecht@siemens.at>
     Andres Kroonmaa <andre@ml.ee>
+    Andrew Beverley <andy@andybev.com>
     Andrew Hoying <andrew_hoying@blm.gov>
     Andrey Shorin <tolsty@tushino.com>
+    Anonymous <redskilldough@gmail.com>
     Ansgar Hockmann <Ansgar.Hockmann@hrz.uni-dortmund.de>
     Anthony Baxter <arb@connect.com.au>
     Arjan de Vet <Arjan.deVet@adv.IAEhv.nl>
@@ -23,7 +33,9 @@ and ideas to make this software available.
     Assar Westerlund <assar@pdc.kth.se>
     Automatic source maintenance <squidadm@squid-cache.org>
     Axel Westerhold <ml.awesterhold@dts.de>
+    Benjamin Kerensa <bkerensa@ubuntu.com>
     Benno Rice <benno@squid-cache.org>
+    Bernard <fli4l.charrier@free.fr>
     Bertrand Jacquin <beber@meleeweb.net>
     Bojan Smojver <bojan@rexursive.com>
     Brad Smith <brad@comstyle.com>
@@ -32,13 +44,17 @@ and ideas to make this software available.
     Brian Denehy <B-Denehy@adfa.oz.au>
     Bruce Murphy <pack-squid@rattus.net>
     Carson Gaspar (carson@lehman.com, carson@cs.columbia.edu)
+    Changming <me@sunchangming.com>
     Chris Hills <chaz@chaz6.com>
     Christos Tsantilas <chtsanti@users.sourceforge.net>
     Cloyce <cloyce.spradling@sun.com>
     Constantin Rack
     Cord Beermann <cord@cc.fh-lippe.de>
+    Daniel Beschorner <daniel.beschorner@evlks.de>
     Daniel O'Callaghan <danny@miriworld.its.unimelb.EDU.AU>
+    David Isaacs <david.isaacs@sbhs.nsw.edu.au>
     David Luyer <luyer@ucs.uwa.edu.au>
+    Dennis Glatting
     Dhaval Varia
     Diego Woitasen <diegows@xtech.com.ar>
     Dmitry Kurochkin
@@ -50,20 +66,26 @@ and ideas to make this software available.
     Dustin J. Mitchell
     Ed Knowles <ed@fatboy.geog.unsw.edu.au>
     Edward Moy <moy@parc.xerox.com>
+    Eliezer Croitoru <eliezer@ngtech.co.il>
+    Elmar Vonlanthen <Elmar.Vonlanthen@united-security-providers.ch>
     Emilio Casbas <ecasbas@unav.es>
     Endre Balint Nagy <bne@CareNet.hu>
+    Eray Aslan <eray.aslan@caf.com.tr>
     Eric Stern <estern@logisense.com>
     Eugene Gladchenko <eugene@donpac.ru>
     Evan Jones <ejones@uwaterloo.ca>
+    Eygene Ryabinkin <rea@freebsd.org>
     Felix Meschberger <felix.meschberger@day.com>
     Finn Thain <fthain@telegraphics.com.au>
     Flavio Pescuma <flavio@marasystems.com>
+    Francesco <kinkie@squid-cache.org>
     Francesco Chemolli <kinkie@squid-cache.org>
     Francesco Salvestrini
     Francis Daly <francis@daoine.org>
     Francois Cami <fcami@winsoft.fr>
     Frank Balluffi
     Frank Schmirler <squid@schmirler.de>
+    Frederic Bourgeois <fredbmail@free.fr>
     Geoff Keating <Geoff.Keating@anu.edu.au>
     George Michaelson <ggm@connect.com.au>
     Georgy Salnikov <sge@nmr.nioch.nsc.ru>
@@ -85,24 +107,29 @@ and ideas to make this software available.
     Igor Vinokurov <igor@cs.ibank.ru>
     Isnard <isnardjaquet@gmail.com>
     JPP <jpp1@frws.com>
+    Jakob Bohm <jb-debbugs@wisemo.com>
     Jakub Wilk <ubanus@users.sf.net>
     James Brotchie <brotchie@gmail.com>
     James R Grinter <jrg@demon.net>
     Jan Niehusmann <jan@anduin.gondor.mcs.de>
+    Jan Sievers <sievers@zedat.fu-berlin.de>
     Jean-Francois Micouleau <Jean-Francois.Micouleau@utc.fr>
     Jean-Gabriel Dick <jean-gabriel.dick@curie.fr>
+    Jean-Philippe Menil <jean-philippe.menil@univ-nantes.fr>
     Jerry Murdock <jmurdock@itraktech.com>
     Joachim Bauch <jojo@fistofbenztown.de>
     Joao Alves Neto <alves_joao@hotmail.com>
     Jochen Voss <voss@seehuhn.de>
     Joe Ramey <ramey@jello.csc.ti.com>
     John Dilley <jad@hpl.hp.com>
     John Saunders <johns@rd.scitec.com.au>
+    John Xue <xgxjohn@gmail.com>
     Johnathan Conley <johnathan.conley@gmail.com>
     Jon Thackray <jrmt@uk.gdscorp.com>
     Jonathan Larmour <JLarmour@origin-at.co.uk>
     Joshua Root <josh+squid@root.id.au>
     Kieran Whitbread <k.j.whitbread@qmul.ac.uk>
+    Kinkie <kinkie@squid-cache.org>
     Klaubert Herr <klaubert@gmail.com>
     Klaus Singvogel <kssingvo@suse.de>
     Kolics Bertold <bertold@tohotom.vein.hu>
@@ -115,15 +142,19 @@ and ideas to make this software available.
     Lutz Donnerhacke <lutz@iks-jena.de>
     Manu Garg <manugarg@gmail.com>
     Marin Stavrev <mstavrev@gmail.com>
+    Marios Makassikis <mmakassikis@gmail.com>
     Mark Bergsma <mark@nedworks.org>
     Mark Nottingham <mnot@pobox.com>
     Mark Treacy <mark@aone.com.au>
     Marko <mr_4u2@yahoo.com>
+    Marko Cupac <marko.cupac@mimar.rs>
     Markus Gyger <mgyger@itr.ch>
     Markus Moeller <huaraz@moeller.plus.com>
+    Markus Rietzler <markus.rietzler@rzf.fin-nrw.de>
     Markus Stumpf <maex@Space.NET>
     Martin Hamilton <martin@mrrl.lut.ac.uk>
     Martin Huter <m.huter@phion.com>
+    Martin Stolle <martin.stolle@ekom21.de>
     Masashi Fujita <objectx@bandit.co.jp>
     Massimo Zito <zmax.linkedin at gmail dot com>
     Matthew Morgan <atcs.matthew@gmail.com>
@@ -134,16 +165,22 @@ and ideas to make this software available.
     Michael O'Reilly <michael@metal.iinet.net.au>
     Michael Pelletier <mikep@comshare.com>
     Michael van Elst
+    Michal Luscon <mluscon@redhat.com>
     Miguel A.L. Paraz <map@iphil.net>
     Mike Groeneweg <mikeg@scorpion.murdoch.edu.au>
     Mike Mitchell <Mike.Mitchell@sas.com>
     Mikio Kishi <mkishi@104.net>
+    Ming Fu <mfu@watchguard.com>
     Miquel van Smoorenburg <miquels@cistron.nl>
     Moez Mahfoudh <moez.mahfoudh@imag.fr>
     Mukaigawa Shin'ichi <shin@nff.ncl.omron.co.jp>
+    Nathan Hoad <nathan@getoffmalawn.com>
     Neil Murray <neil@aone.com.au>
     Niall Doherty <ndoherty@eei.ericsson.se>
+    Nick Rogers <ncrogers@gmail.com>
+    Nikolai Gorchilov <niki@x3me.net>
     Oskar Pearson <oskar@is.co.za>
+    Paul Z <paulz42@gmail.com>
     Pawel Worach <pawel.worach@gmail.com>
     Pedro Lineu Orso <orso@pop.hsbcbamerindus.com.br>
     Pedro Ribeiro <pribeiro@isel.pt>
@@ -153,47 +190,72 @@ and ideas to make this software available.
     Philip Allison <philip.allison@smoothwall.net>
     Philippe Lantin <plantin@cobaltgroup.com>
     Pierangelo Masarati <ando@sys-net.it>
+    Pierre-Louis BRENAC <brenacp@esiee.fr>
     Pierre-Louis Brenac <brenacp@esiee.fr>
+    Priyanka Gupta <priyanka@icelero.com>
     Przemek Czerkas <pczerkas@mgmnet.pl>
     Rafael Martinez Torres <rmartine@fdi.ucm.es>
     Rafal Ramocki <maniac@sistbg.net>
+    Rajiv Desai <rajiv@maginatics.com>
     Ralf Wildenhues <Ralf.Wildenhues@gmx.de>
     Ralph Loader <loader@maths.ox.ac.uk>
     Regardt van de Vyver <squid@vdvyver.net>
     Reinhard Sojka <reinhard.sojka@parlament.gv.at>
     Rene Geile <rene.geile@t-online.de>
     Reuben Farrelly <reuben@reub.net>
     Richard Huveneers <Richard.Huveneers@hekkihek.hacom.nl>
+    Richard Wall <richard.wall@appliansys.com>
     Robert Collins <robertc@robertcollins.net>
     Robert Forster
+    Rodrigo Campos (rodrigo@geekbunker.org)
     Rodrigo Campos <rodrigo@geekbunker.org>
     Ron Gomes <rrg@ny.ubs.com>
     Russell Street <r.street@auckland.ac.nz>
     Russell Vincent <vincent@ucthpx.uct.ac.za>
     Ryan Troll <ryan+@andrew.cmu.edu>
     Scott Schram <scott@schram.net>
+    Sebastien Wenske <sebastien@wenske.fr>
     Sergio Rabellino <rabellino@di.unito.it>
     Shigechika Aikawa <shige@luck.imasy.or.jp>
+    Silamael <Silamael@coronamundi.de>
     Stefan Fritsch <sf@sfritsch.de>
+    Stefano Cordibella <stefano.cordibella@edalab.it>
     Stephen R. van den Berg <srb@cuci.nl>
     Steve Bennett <S.Bennett@lancaster.ac.uk>
+    Steve Hill <steve@opendium.com>
     Steve Snyder <swsnyder@snydernet.net>
     Steven Wilton <swilton@q-net.net.au>
     Stewart Forster <slf@connect.com.au>
+    Stuart Henderson <sthen@openbsd.org>
+    Susant Sahani <ssahani@redhat.com>
     Svenx <svensven@gmail.com>
     Taavi Talvik <taavi@uninet.ee>
     Taketo Kabe <kabe@shiratori.riec.tohoku.ac.jp>
+    Thomas De Schampheleire <thomas.de.schampheleire@gmail.com>
+    Thomas Hozza <thozza@redhat.com>
     Thomas Ristic <thr@bootet.net>
+    Thomas Weber <x@4t2.com>
     Thomas-Martin Seck <tmseck@netcologne.de>
+    Tianyin Xu <tixu@cs.ucsd.edu>
     Tim Starling <tstarling@wikimedia.org>
+    Tomas Hozza <thozza@redhat.com>
     Tony Lorimer <tlorimer@au.mdis.com>
     Unknown - NetBSD Project
+    Unknown FreeBSD Contributor
     Vincent Regnard
+    Vitaliy Matytsyn (main) <vm@if.bank.gov.ua>
     Vitaliy Matytsyn <vm@if.bank.gov.ua>
     Wesha <wesha@iname.com>
+    Will Roberts <squid@bigwillystyle42.com>
     Wojtek Sylwestrzak <W.Sylwestrzak@icm.edu.pl>
+    Wolfgang Breyha <wbreyha@gmx.net>
     Wolfgang Nothdurft <wolfgang@linogate.de>
+    Zhanpeng Chen <lowstz@gmail.com>
     benno@jeamland.net
     fancyrabbit <fancyrabbit@gmail.com>
+    folkert <folkert@vanheusden.com>
+    hno
+    kinkie@squid-cache.org
+    libit <sambabug.lb@gmail.com>
+    rousskov
     vollkommen <vollkommen@gmx.net>
-    Benjamin Kerensa <bkerensa@ubuntu.com>
@@ -1,3 +1,32 @@
+Changes to squid-3.4.5 (02 May 2014):
+
+	- Regression Bug 4051: inverted test on CONNECT payload existence
+	- Regression Fix: order dependency between cache_dir and maximum_object_size
+	- Fix logformat %note display
+	- Resolve 'dying from an unhandled exception: c'
+
+Changes to squid-3.4.4.2 (23 Apr 2014):
+
+	- version bump for packaging re-build with altered toolchain
+
+Changes to squid-3.4.4.1 (23 Apr 2014):
+
+	- Regression Bug 4019: Cache digest exchange segmentation fault
+	- Regression Bug 3982: EUI logging and helpers show blank MAC address
+	- Bug 4047: Support Android builds
+	- Bug 4043: Remove XMALLOC_TRACE and references to sbrk(2)
+	- Bug 4041: Missing files in compat/Makefile.am
+	- Bug 4014: Build failure with --disable-optimizations --disable-auth
+	- Bug 3986: (partial) assertion due to incorrect error page buffer size
+	- Bug 3955: Solaris EUI-48 lookup leaks FDs
+	- Bug 3371: CONNECT with data sent at once loses data
+	- C++11: Upgrade auto-detection to use the formal -std=c++11
+	- Crypto-NG: libnettle MD5 algorithm support
+	- SSL-Bump: Fix Basic auth caching on bumped connections
+	- Store-ID: Fix request URI when forwarding requests to peers
+	- ... and fix several other build errors
+	- ... and some documentation updates
+
 Changes to squid-3.4.4 (09 Mar 2014):
 
 	- Bug 4029: intercepted HTTPS requests bypass caching checks
@@ -56,6 +56,7 @@ libcompat_squid_la_SOURCES = \
 	xstrto.h \
 	\
 	os/aix.h \
+	os/android.h \
 	os/dragonfly.h \
 	os/freebsd.h \
 	os/hpux.h \
@@ -56,6 +56,7 @@
 /*****************************************************/
 
 #include "compat/os/aix.h"
+#include "compat/os/android.h"
 #include "compat/os/dragonfly.h"
 #include "compat/os/freebsd.h"
 #include "compat/os/hpux.h"
@@ -0,0 +1,13 @@
+#ifndef SQUID_OS_ANDROID_H
+#define SQUID_OS_ANDROID_H
+
+#if defined(__ANDROID__)
+/****************************************************************************
+ *--------------------------------------------------------------------------*
+ * DO *NOT* MAKE ANY CHANGES below here unless you know what you're doing...*
+ *--------------------------------------------------------------------------*
+ ****************************************************************************/
+#define _SQUID_ANDROID_ 1
+
+#endif /* _SQUID_ANDROID_ */
+#endif /* SQUID_OS_ANDROID_H */
@@ -5,7 +5,7 @@
 #include "squid.h"
 #include "psignal.h"
 
-#if _SQUID_AIX_ || _SQUID_MINGW_
+#if _SQUID_AIX_ || _SQUID_ANDROID_ || _SQUID_MINGW_
 extern const char* const sys_siglist[];
 #define _sys_nsig 64
 #define _sys_siglist sys_siglist
@@ -1213,6 +1213,55 @@ dnl Solaris10 provides MD5 natively through libmd5
 AC_CHECK_LIB(md5, MD5Init, [CRYPTLIB="$CRYPTLIB -lmd5"])
 AC_SUBST(CRYPTLIB)
 
+SSLLIB=""
+
+dnl User may want to disable GnuTLS
+AC_ARG_WITH(gnutls,
+  AS_HELP_STRING([--without-gnutls],
+                 [Do not use GnuTLS for SSL. Default: auto-detect]), [ 
+case "$with_gnutls" in
+  yes|no)
+    : # Nothing special to do here
+    ;;
+  *)
+    if test ! -d "$withval" ; then
+      AC_MSG_ERROR([--with-gnutls path does not point to a directory])
+    fi
+    LIBGNUTLS_PATH="-L$with_gnutls/lib"
+    CPPFLAGS="-I$with_gnutls/include $CPPFLAGS"
+  esac
+])
+AH_TEMPLATE(USE_GNUTLS,[GnuTLS support is available])
+if test "x$with_gnutls" != "xno"; then
+  AC_CHECK_HEADERS(gnutls/gnutls.h gnutls/x509.h)
+
+  # User may have provided a custom location for GnuTLS. Otherwise...
+  SQUID_STATE_SAVE(squid_gnutls_state)
+  LIBS="$LIBS $LIBGNUTLS_PATH"
+
+  # auto-detect using pkg-config
+  PKG_CHECK_MODULES([LIBGNUTLS],[gnutls >= 3.1.5],,[
+    ## find the package without pkg-config
+    ## check that the library is actually new enough.
+    ## by testing for a 3.1.5+ function which we use
+    AC_CHECK_LIB(gnutls,gnutls_certificate_verify_peers3,[LIBGNUTLS_LIBS="-lgnutls"])
+  ])
+
+  SQUID_STATE_ROLLBACK(squid_gnutls_state) #de-pollute LIBS
+
+  if test "x$with_gnutls" = "xyes" -a "x$LIBGNUTLS_LIBS" = "x"; then
+    AC_MSG_ERROR([Required GnuTLS library not found])
+  fi
+  if test "x$LIBGNUTLS_LIBS" != "x" ; then
+    CXXFLAGS="$LIBGNUTLS_CFLAGS $CXXFLAGS"
+    SSLLIB="$LIBGNUTLS_PATH $LIBGNUTLS_LIBS $SSLLIB"
+    AC_DEFINE(USE_GNUTLS,1,[GnuTLS support is available])
+  else
+    with_gnutls=no
+  fi
+fi
+AC_MSG_NOTICE([GnuTLS library support: ${with_gnutls:=auto} ${LIBGNUTLS_PATH} ${LIBGNUTLS_LIBS}])
+
 dnl User may specify OpenSSL is needed from a non-standard location
 AC_ARG_WITH(openssl,
   AS_HELP_STRING([--with-openssl=PATH],
@@ -3455,6 +3504,7 @@ AC_CONFIG_FILES([
 	helpers/negotiate_auth/wrapper/Makefile
 	helpers/external_acl/Makefile
 	helpers/external_acl/AD_group/Makefile
+	helpers/external_acl/delayer/Makefile
 	helpers/external_acl/eDirectory_userip/Makefile
 	helpers/external_acl/file_userip/Makefile
 	helpers/external_acl/kerberos_ldap_group/Makefile
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.4.4 release notes</title>
+<title>Squid 3.4.5 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.4.4 for testing.
+The Squid Team are pleased to announce the release of Squid-3.4.5 for testing.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.4/"> or the
  <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
@@ -40,6 +40,9 @@ The 3.5 change history can be <url url="http://www.squid-cache.org/Versions/v3/3
 <itemize>
 	<item>Support libecap v1.0
 	<item>Authentication helper query extensions
+	<item>Support named services
+	<item>Upgraded squidclient tool
+	<item>Helper support for concurrency channels
 </itemize>
 
 Most user-facing changes are reflected in squid.conf (see below).
@@ -71,6 +74,95 @@ Most user-facing changes are reflected in squid.conf (see below).
   will send any meaningful detail.
 
 
+<sect1>Support named services
+<p>Details at <url url="http://wiki.squid-cache.org/MultipleInstances">.
+<p>Terminology details at <url url="http://wiki.squid-cache.org/Features/SmpScale#Terminology">.
+
+<p>The command line option <em>-n</em> assigns a name to the Squid service
+   instance to be used as a unique identifier for all SMP processes run as
+   part of that instance. This allows multiple instances of Squid service to
+   be run on a single machine without background SMP systems such as shared
+   memory and inter-process communication becoming confused or requiring
+   additional configuration.
+
+<p>A service name is always used. When the <em>-n</em> option is missing
+   from the command line the default service name is <em>squid</em>.
+
+<p>When multiple instances are being run the <em>-n</em> service name is
+   required to target all other options such as <em>-z</em> or <em>-k</em>
+   commands at the correct service.
+
+<p>The squid.conf macro ${service_name} is added to provide the service name
+   of the process parsing the config.
+
+
+<sect1>Upgraded squidclient tool
+<p>The <em>squidclient</em> has begun the process of upgrading to support
+   protocols other than HTTP.
+
+<sect2>Debug levels
+<p>The tool displays the server response message on STDOUT unless the <em>-q</em>
+   command line option is used. Error messages will be output to STDERR.
+   All other possible output is considered debug and output to STDERR using
+   a range of debug verbosity levels (currently 1, 2 and 3).
+
+<p>When the <em>-v</em> command line option is used debugging is enabled.
+   The level of debug display is raised for each repetition of the option.
+
+<sect2>PING
+<p>When <em>--ping</em> is given the tool will send its message repeatedly
+   using whichever protocol that message has been formatted for.
+   Optional parameters to limit the number of pings and their frequency are
+   available.
+
+<p>Older tool versions also provide this feature but require the loop count
+   parameter to be set to enable use of the feature.
+
+<sect2>HTTPS
+<p>When Squid is built with the GnuTLS encryption library the tool is able
+   to open TLS (or SSL/3.0) connections to servers.
+
+<p>The <em>--https</em> option enables TLS using default values.
+
+<p>The <em>--cert</em> option specifies a file containing X.509 client
+   certificate and private key in PEM format to be loaded for use. Multiple
+   certificates are supported and the option may be used multiple times to
+   load certificates.
+   The default is not to use a client certificate.
+
+<p>The <em>--params</em> option specifies a library specific set of parameters
+   to be sent to the library for configuring the security context.
+   See <url url="http://gnutls.org/manual/html_node/Priority-Strings.html"> for
+   available GnuTLS parameters.
+
+<p>The <em>--trusted-ca</em> option specifies a file in PEM format containing
+   one or more Certificate Authority (CA) certificates used to verify the
+   remote server. This option may be used multiple times to load additional
+   CA certificate lists.
+   The default is not to use any CA, nor trust any server.
+
+<p>Anonymous TLS (using non-authenticated Diffi-Hellman or Elliptic Curve
+   encryption) is available with the <em>--anonymous-tls</em> option.
+   The default is to use X.509 certificate encryption instead.
+
+<p>When performing TLS/SSL server certificates are always verified, the
+   results shown at debug level 3. The encrypted type is displayed at debug
+   level 2 and the connection is used to send and receive the messages
+   regardless of verification results.
+
+
+<sect1>Helper support for concurrency channels
+<p>Helper concurrency greatly reduces the communication lag between Squid
+   and its helpers allowing faster transaction speeds even on sequential
+   helpers.
+
+<p>The Digest authentication, Store-ID, and URL-rewrite helpers packaged
+   with Squid have been updated to support concurrency channels. They will
+   auto-detect the <em>channel-ID</em> field and will produce the appropriate
+   response format.
+   With these helpers concurrency may now be set to 0 or any higher number as desired.
+
+
 <sect>Changes to squid.conf since Squid-3.4
 <p>
 There have been changes to Squid's configuration file since Squid-3.4.
@@ -81,6 +173,9 @@ There have been changes to Squid's configuration file since Squid-3.4.
     acl whitelist dstdomain parameters("/etc/squid/whitelist.txt")
 </verb>
 
+<p>The squid.conf macro ${service_name} is added to provide the service name
+   of the process parsing the config.
+
 <p>There have also been changes to individual directives in the config file.
 
 This section gives a thorough account of those changes in three categories:
@@ -104,10 +199,35 @@ This section gives a thorough account of those changes in three categories:
 	   based on ACL selection. ACL can be based on client request or cached
 	   response details.
 
+	<tag>sslproxy_session_cache_size</tag>
+	<p>New directive which sets the cache size to use for TLS/SSL sessions cache.
+
+	<tag>sslproxy_session_ttl</tag>
+	<p>New directive to specify the time in seconds the TLS/SSL session is valid.
+
+	<tag>store_id_extras</tag>
+	<p>New directive to send additional lookup parameters to the configured
+	   Store-ID helper program. It takes a string which may contain logformat %macros.
+	<p>The Store-ID helper input format is now:
+	<verb>
+         [channel-ID] url [extras]
+	</verb>
+	<p>The default value for extras is: "%&gt;a/%>A %un %>rm myip=%la myport=%lp"
+
 	<tag>store_miss</tag>
 	<p>New configuration directive to enable/disable caching of MISS responses.
 	   ACL can be based on any request or response details.
 
+	<tag>url_rewrite_extras</tag>
+	<p>New directive to send additional lookup parameters to the configured
+	   URL-rewriter/redirector helper program. It takes a string which may
+	   contain logformat %macros.
+	<p>The url rewrite and redirector helper input format is now:
+	<verb>
+         [channel-ID] url [extras]
+	</verb>
+	<p>The default value for extras is: "%>a/%>A %un %>rm myip=%la myport=%lp"
+
 </descrip>
 
 <sect1>Changes to existing tags<label id="modifiedtags">
@@ -123,15 +243,44 @@ This section gives a thorough account of those changes in three categories:
 	<p>New parameter <em>key_extras</em> to send additional parameters to
 	   the authentication helper.
 
+	<tag>cache_dir</tag>
+	<p>New support for larger than 32KB objects in both <em>rock</em> type
+	   cache and shared memory cache.
+	<p>New <em>slot-size=N</em> option for rock cache to specify the database
+	   slot/page size when small slot sizes are desired. The default and
+	   maximum slot size is 32KB.
+	<p>Removal of old rock cache dir followed by <em>squid -z</em> is required
+	   when upgrading from earlier versions of Squid.
+
+	<tag>cache_peer</tag>
+	<p>New <em>standby=N</em> option to retain a set of N open and unused
+	   connections to the peer at virtually all times to reduce TCP handshake
+	   delays.
+	<p>These connections differ from HTTP persistent connections in that they
+	   have not been used for HTTP messaging (and may never be). They may be
+	   turned into persistent connections after their first use subject to the
+	   same keep-alive critera any HTTP connection is checked for.
+
 	<tag>forward_max_tries</tag>
-	<p>Default value increased to <em>25 destinations/em> to allow better
+	<p>Default value increased to <em>25 destinations</em> to allow better
 	   contact and IPv4 failover with domains using long lists of IPv6
 	   addresses.
 
+	<tag>ftp_epsv</tag>
+	<p>Converted into an Access List with allow/deny value driven by ACLs
+	   using Squid standard first line wins matching basis.
+	<p>The old values of <em>on</em> and <em>off</em> imply <em>allow all</em>
+	    and <em>deny all</em> respectively and are now deprecated.
+	   Do not combine use of on/off values with ACL configuration.
+
 	<tag>http_port</tag>
 	<p><em>protocol=</em> option altered to accept protocol version details.
 	   Currently supported values are: HTTP, HTTP/1.1, HTTPS, HTTPS/1.1
 
+	<tag>https_port</tag>
+	<p><em>protocol=</em> option altered to accept protocol version details.
+	   Currently supported values are: HTTP, HTTP/1.1, HTTPS, HTTPS/1.1
+
 	<tag>logformat</tag>
 	<p>New format code <em>%credentials</em> to log the client credentials
 	   token.
@@ -146,13 +295,19 @@ This section gives a thorough account of those changes in three categories:
 <p>
 <descrip>
 	<tag>cache_dir</tag>
-	<p><em>COSS</em> storage type is formally replaced by Rosk storage type.
+	<p><em>COSS</em> storage type is formally replaced by Rock storage type.
 
 	<tag>cache_dns_program</tag>
 	<p>DNS external helper interface has been removed. It was no longer
 	   able to provide high performance service and the internal DNS
 	   client library with multicast DNS cover all modern use-cases.
 
+	<tag>cache_peer</tag>
+	<p><em>idle=</em> replaced by <em>standby=</em>.
+	<p>NOTE that standby connections are started earlier and available in
+	   more circumstances than squid-2 idle connections were. They are
+	   also spread over all IPs of the peer.
+
 	<tag>dns_children</tag>
 	<p>DNS external helper interface has been removed.
 
@@ -177,6 +332,11 @@ This section gives an account of those changes in three categories:
 <descrip>
 	<p><em>There are no new ./configure options in Squid-3.5.</em>
 
+	<tag>--without-gnutls</tag>
+	<p>New option to explicitly disable use of GnuTLS encryption library.
+	   Use of this library is auto-enabled if v3.1.5 or later is available.
+	<p>It is currently only used by the squidclient tool.
+
 </descrip>
 
 <sect1>Changes to existing options<label id="modifiedoptions">
@@ -198,6 +358,10 @@ This section gives an account of those changes in three categories:
 	<tag>--enable-ssl</tag>
 	<p>Removed. Use <em>--with-openssl</em> to enable OpenSSL library support.
 
+	<tag>--with-coss-membuf-size</tag>
+	<p>The COSS cache type has been removed.
+	   It has been replaced by <em>rock</em> cache type.
+
 </descrip>
 
 
@@ -214,7 +378,6 @@ This section gives an account of those changes in three categories:
 	<p>Not yet ported from 2.6
 
 	<tag>cache_peer</tag>
-	<p><em>idle=</em> not yet ported from 2.7
 	<p><em>monitorinterval=</em> not yet ported from 2.6
 	<p><em>monitorsize=</em> not yet ported from 2.6
 	<p><em>monitortimeout=</em> not yet ported from 2.6
@@ -20,6 +20,7 @@ TRANSLATE_LANGUAGES= \
     id.lang \
     it.lang \
     ja.lang \
+    ka.lang \
     ko.lang \
     lt.lang \
     lv.lang \
@@ -73,7 +73,8 @@ main(int argc, char **argv)
             /* Password incorrect */
             printf("ERR Wrong password\n");
 #else
-        } else {
+        }
+        else {
             /* Password incorrect */
             printf("BH message=\"Missing crypto capability\"\n");
 #endif
@@ -32,6 +32,7 @@
 #include "util.h"
 
 typedef struct _request_data {
+    int channelId;
     char *user;
     char *realm;
     char *password;
@@ -49,6 +49,14 @@ ParseBuffer(char *buf, RequestData * requestData)
     requestData->parsed = 0;
     if ((p = strchr(buf, '\n')) != NULL)
         *p = '\0';		/* strip \n */
+
+    p = NULL;
+    requestData->channelId = strtoll(buf, &p, 10);
+    if (*p != ' ') // not a channel-ID
+        requestData->channelId = -1;
+    else
+        buf = ++p;
+
     if ((requestData->user = strtok(buf, "\"")) == NULL)
         return;
     if ((requestData->realm = strtok(NULL, "\"")) == NULL)
@@ -63,6 +71,8 @@ OutputHHA1(RequestData * requestData)
 {
     requestData->error = 0;
     GetHHA1(requestData);
+    if (requestData->channelId >= 0)
+        printf("%u ", requestData->channelId);
     if (requestData->error) {
         SEND_ERR("message=\"No such user\"");
         return;
@@ -76,6 +86,8 @@ DoOneRequest(char *buf)
     RequestData requestData;
     ParseBuffer(buf, &requestData);
     if (!requestData.parsed) {
+        if (requestData.channelId >= 0)
+            printf("%u ", requestData.channelId);
         SEND_BH("message=\"Invalid line received\"");
         return;
     }
@@ -35,6 +35,7 @@
 #include "util.h"
 
 typedef struct _request_data {
+    int channelId;
     char *user;
     char *realm;
     char *password;
@@ -49,6 +49,14 @@ ParseBuffer(char *buf, RequestData * requestData)
     requestData->parsed = 0;
     if ((p = strchr(buf, '\n')) != NULL)
         *p = '\0';		/* strip \n */
+
+    p = NULL;
+    requestData->channelId = strtoll(buf, &p, 10);
+    if (*p != ' ') // not a channel-ID
+        requestData->channelId = -1;
+    else
+        buf = ++p;
+
     if ((requestData->user = strtok(buf, "\"")) == NULL)
         return;
     if ((requestData->realm = strtok(NULL, "\"")) == NULL)
@@ -63,6 +71,8 @@ OutputHHA1(RequestData * requestData)
 {
     requestData->error = 0;
     GetHHA1(requestData);
+    if (requestData->channelId >= 0)
+        printf("%u ", requestData->channelId);
     if (requestData->error) {
         SEND_ERR("message=\"No such user\"");
         return;
@@ -76,6 +86,8 @@ DoOneRequest(char *buf)
     RequestData requestData;
     ParseBuffer(buf, &requestData);
     if (!requestData.parsed) {
+        if (requestData.channelId >= 0)
+            printf("%u ", requestData.channelId);
         SEND_BH("message=\"Invalid line received\"");
         return;
     }
@@ -27,6 +27,7 @@
 #endif
 
 typedef struct _request_data {
+    int channelId;
     char *user;
     char *realm;
     char *password;
@@ -5,7 +5,7 @@
 .if !'po4a'hide' \-
 File based digest authentication helper for Squid.
 .PP
-Version 1.0
+Version 1.1
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B digest_file_auth
@@ -17,6 +17,9 @@ file
 is an installed binary authentication program for Squid. It handles digest 
 authentication protocol and authenticates against a text file backend.
 .
+This program will automatically detect the existence of a concurrecy channel-ID and adjust appropriately.
+It may be used with any value 0 or above for the auth_param children concurrency= parameter.
+.
 .SH OPTIONS
 .if !'po4a'hide' .TP 12
 .if !'po4a'hide' .B \-c
@@ -51,6 +51,14 @@ ParseBuffer(char *buf, RequestData * requestData)
     requestData->parsed = 0;
     if ((p = strchr(buf, '\n')) != NULL)
         *p = '\0';		/* strip \n */
+
+    p = NULL;
+    requestData->channelId = strtoll(buf, &p, 10);
+    if (*p != ' ') // not a channel-ID
+        requestData->channelId = -1;
+    else
+        buf = ++p;
+
     if ((requestData->user = strtok(buf, "\"")) == NULL)
         return;
     if ((requestData->realm = strtok(NULL, "\"")) == NULL)
@@ -65,6 +73,8 @@ OutputHHA1(RequestData * requestData)
 {
     requestData->error = 0;
     GetHHA1(requestData);
+    if (requestData->channelId >= 0)
+        printf("%u ", requestData->channelId);
     if (requestData->error) {
         SEND_ERR("message=\"No such user\"");
         return;
@@ -78,6 +88,8 @@ DoOneRequest(char *buf)
     RequestData requestData;
     ParseBuffer(buf, &requestData);
     if (!requestData.parsed) {
+        if (requestData.channelId >= 0)
+            printf("%u ", requestData.channelId);
         SEND_BH("message=\"Invalid line received\"");
         return;
     }
@@ -1,5 +1,6 @@
 DIST_SUBDIRS= \
 	AD_group \
+	delayer \
 	eDirectory_userip \
 	file_userip \
 	kerberos_ldap_group \
@@ -0,0 +1,12 @@
+include $(top_srcdir)/src/Common.am
+
+libexec_SCRIPTS = ext_delayer_acl
+CLEANFILES += ext_delayer_acl ext_delayer_acl.8
+man_MANS = ext_delayer_acl.8
+EXTRA_DIST = ext_delayer_acl.pl.in ext_delayer_acl.8 required.m4
+
+ext_delayer_acl.8: ext_delayer_acl
+	pod2man ext_delayer_acl ext_delayer_acl.8
+
+ext_delayer_acl: ext_delayer_acl.pl.in
+	$(subst_perlshell)
@@ -0,0 +1,257 @@
+#!@PERL@
+=pod
+
+=head1 NAME
+
+delayer - Squid external acl helper adding artificial delay to requests
+
+=head1 SYNOPSIS
+
+delayer [--help] [--debug] [--log file] [--wait msec]
+
+=head1 OPTIONS
+
+=over 8
+
+=item B<--help> or B<-h>
+
+Print help message to stdout
+
+=item B<--debug> or B<-d>
+
+Emit debugging output to STDERR and ultimately cache.log
+
+=item B<--log /path/to/file> or B<-l /path/to/file>
+
+Emit debugging output to specified file instead of STDERR. Also turns on debugging
+
+=item B<--wait msec> or B<-w msec>
+
+Delay each request by the specified amount of msec.
+Unless this option is specified, by default each submitted request
+will be delayed by half a second (500 msec).
+
+=back
+
+=head1 DESCRIPTION
+
+Squid external acl helper; causes squid to delay responding to HTTP requests.
+
+By carefully crafting the ACLs of a Squid setup it is possible to
+selectively delay requests received by a proxy. After the configured amount
+of time, it will always return "true".
+
+=head1 CONFIGURATION
+
+To engage it, this snippet of configuration template can be used in squid.conf:
+
+ external_acl_type delayer concurrency=100000 children-max=2 children-startup=1 children-idle=1 cache=10 %URI /path/to/delayer -w 200
+ acl delay external delayer
+ http_access allow acl1 acl2 acl3 delay !all
+
+It is important that the acl referencing the delayer be the penultimate clause in the
+http_access line. It will cause delay to all requests that match all the
+preceding acls in the line. The !all clause at the end of the line will make it
+so that no traffic is authorized by this ACL, only the delay to evaluate
+the delay clause will be inserted before evaluating following http_access lines.
+It is also important to place the http_access line carefully in the sequence
+of all http_access_lines; it should be near the beginning, but be careful
+not to insert unwanted slow acls (especially proxy_auth).
+
+It is possible to customize how delay is calculated for each request by
+modifying the "calc_delay" PERL function in the script, documentation on this
+is embedded in the source code comments.
+
+=head1 AUTHOR
+
+This software is written by Francesco Chemolli <kinkie@squid-cache.org>
+
+=head1 COPYRIGHT
+
+(C) 2014 Francesco Chemolli <kinkie@squid-cache.org>
+
+This program is free software. You may redistribute copies of it under the
+terms of the GNU General Public License version 2, or (at your opinion) any
+later version.
+
+=head1 QUESTIONS
+
+Questions on this code are best addressed on the Squid-users mailing list
+<squid-users@squid-cache.org>
+
+=head1 REPORTING BUGS
+
+Bug reports need to be made in English.
+See http://wiki.squid-cache.org/SquidFaq/BugReporting for details of what you
+need to include with your bug report.
+Report bugs or bug fixes using http://bugs.squid-cache.org/
+
+=head1 SEE ALSO
+
+B<squid>(8), B<GPL>(7), B<Squid Wiki> http://wiki.squid-cache.org/ ,
+B<Squid Configuration Manual> http://www.squid-cache.org/Doc/config/
+
+=cut
+
+use strict;
+use warnings;
+use Getopt::Long qw(:config auto_version auto_help);
+use Data::Dumper;
+use Time::HiRes qw(gettimeofday tv_interval);
+
+# options handling
+my %opts = (); #for getopt
+my $debug = 0; #debug
+my $logfile = *STDERR; #filehandle to logfile
+my $logfilename;
+my $delay = 500; #in milliseconds. Configurable with the -w option.
+#for custom delay algorithms, you can customize the dispatch_request function
+
+#calculate the delay for the request.
+# Gets as input the verbatim full line received from squid
+# (channel number and all, as configured in squid.conf) and returns
+# a floating point number >= 0 which is the delay to be applied to the request
+# in seconds.
+# Notice that in order to have efficient data structures, the delay is
+# assumed to be monotonously growing. In other words, a long-delay
+# item will stall the queue until completed. Supporting generic delays
+# requires transforming @queue from a FIFO to a priority queue.
+sub calc_delay {
+  return $delay;
+}
+
+GetOptions("debug|d" => \$debug,
+           "wait|w=i" => \$delay,
+           "log|l=s" => \$logfilename)
+or die("Error in parsing command line arguments");
+if (defined $opts{h}) {
+  HELP_MESSAGE();
+  exit 0;
+}
+$delay /= 1000.0; # transform msec into sec
+if ($logfilename) {
+  open ($logfile,">>", "$opts{l}");
+  $debug=1;
+} 
+
+my @p=split(/[\\\/]/,$0);
+my $prg_basename=pop @p;
+$prg_basename .= "[$$]";
+undef @p;
+my $reqid=0; #sequence number for requests
+
+# variables initialization for select
+my $rvec = '';
+vec($rvec,0,1) = 1; #stdin
+my ($nfound, $rd, $nread, $req);
+
+#requests queue
+my @queue = (); # array of references to hashes, with keys chan, when, req, reqid
+
+# signal handlers
+$SIG{HUP} = \&dump_state;
+
+#disable IO buffering
+$| = 1;
+my $fh=select($logfile); $|=1; select($fh); undef($fh);
+
+# takes a result from a gettimeofday call and turns it into a
+# floating-point number suitable for approximate time calculations and select
+sub fract_time {
+  return $_[0]+$_[1]/1000000;
+}
+
+sub dispatch_request {
+  my $r = $_[0];
+  chomp $r;
+  &debug("got request: '$r'");
+  my %evt = ();
+  my @fields;
+  @fields = split (/\s+/, $r);
+  $evt{when} = &calc_delay($r)+fract_time(gettimeofday());
+  $evt{reqid}=$reqid++;
+  $evt{req} = $r;
+  $evt{chan} = $fields[0];
+  &debug("Dispatching: reqid $evt{reqid}, chan $evt{chan}, when $evt{when}, raw {$evt{req}}");
+  push @queue,\%evt;
+}
+
+sub next_event {
+  my $now = fract_time(gettimeofday());
+  if (@queue) {
+    my $when = $queue[0]->{when} - $now;
+    &debug("Next event is in $when seconds");
+    return $when;
+  }
+  &debug("No events in queue");
+  return undef;
+}
+
+sub handle_events {
+  my $now = fract_time(gettimeofday());
+  while ( @queue ) {
+    &debug("Queue length is $#queue");
+    last if ($queue[0]->{when} > $now);
+    my %evt = %{shift @queue};
+    &debug("Event: reqid $evt{reqid}, chan $evt{chan}, when $evt{when}, raw {$evt{req}}");
+    print $evt{chan} , " OK\n";
+  }
+}
+
+# main loop
+while(1) {
+  &debug("selecting");
+  $nfound = select($rd = $rvec,undef,undef,&next_event());
+  &debug("found $nfound bits set");
+  if ($nfound == -1 ) {
+    next if ($!{ERESTART} || $!{EAGAIN} || $!{EINTR});
+    &debug("error in select: $!");
+    exit 1;
+  }
+  if (vec($rd,0,1)==1) { #got stuff from stdin
+    my $d; #data
+    $nread = sysread(STDIN,$d,40960); # read 40kb
+    # clear the signal-bit, stdin is special
+    vec($rd,0,1) = 0;
+    if ($nread==0) {
+      &debug("nothing read from stdin, exiting");
+      exit 0;
+    }
+    my $i;
+    while ($i = index($d,"\n")) { #BUG: assumption of no spill-over
+      last if ($i == -1);
+      &dispatch_request(substr($d,0,$i));
+      $d=substr($d,$i+1);
+    }
+  }
+  &handle_events();
+}
+
+my $doc = <<_EOF;
+delay-adding external acl helper
+authorizes all requests, adding a delay before doing so.
+supports multiplexed helper protocol.
+Options:
+  -h, --help: this help message
+  -d, --debug: enable debug output
+  -l <file>, --log <file>: log output to named file instead of stderr (implies debug)
+  -w <num>, --wait <num> delay each request by this number milliseconds
+
+AUTHOR: Francesco Chemolli <kinkie\@squid-cache.org>
+Licensed under the terms of the GNU GPL v2 or later (see source for details)
+_EOF
+our $VERSION = "1.0";
+
+sub HELP_MESSAGE {
+  print STDERR $doc;
+}
+
+sub dump_state {
+  $SIG{HUP} = \&dump_state;
+  print STDERR "Queue:\n",Dumper(\@queue),"\n";
+}
+
+sub debug {
+  return unless ($debug);
+  print $logfile $prg_basename , ": ", @_, "\n";
+}
@@ -0,0 +1,3 @@
+if test "x$PERL" != "x" -a "x$POD2MAN" != "x"; then
+  BUILD_HELPER="delayer"
+fi
@@ -27,6 +27,9 @@ if test "x$enable_external_acl_helpers" != "xno" ; then
       elif test "x$helper" = "xLM_group" ; then
         m4_include([helpers/external_acl/LM_group/required.m4])
 
+      elif test "x$helper" = "xdelayer" ; then
+        m4_include([helpers/external_acl/delayer/required.m4])
+
       elif test "x$helper" = "xSQL_session" ; then
         m4_include([helpers/external_acl/SQL_session/required.m4])
 
@@ -13,7 +13,7 @@ storeid_file_rewrite - File based Store-ID helper for Squid
 
 storeid_file_rewrite filepath
 
-=head1 DESCRIPTOIN
+=head1 DESCRIPTION
 
 This program acts as a store_id helper program, rewriting URLs passed
 by Squid into storage-ids that can be used to achieve better caching
@@ -28,6 +28,9 @@ Eg:
 Rewrite rules are matched in the same order as they appear in the rules file.
 So for best performance, sort it in order of frequency of occurrence.
 
+This program will automatically detect the existence of a concurrecy channel-ID and adjust appropriately.
+It may be used with any value 0 or above for the store_id_children concurrency= parameter.
+
 For more information please see http://wiki.squid-cache.org/Features/StoreID
 
 =cut
@@ -109,9 +109,16 @@ main(int argc, char *argv[])
 
         debug("Got %d bytes '%s' from Squid\n", buflen, buf);
 
-        /* send 'no-change' result back to Squid */
-        fprintf(stdout,"\n");
+        p = NULL;
+        int64_t channelId = strtoll(buf, &p, 10);
+        if (*p != ' ') {
+            /* send 'no-change' result back to Squid in non-concurrent format */
+            fprintf(stdout,"ERR\n");
+        } else {
+            /* send 'no-change' result back to Squid in concurrent format */
+            fprintf(stdout, "%" PRId64 " ERR\n", channelId);
+        }
     }
     debug("%s build " __DATE__ ", " __TIME__ " shutting down...\n", my_program_name);
-    exit(0);
+    return 0;
 }
@@ -223,8 +223,7 @@ class AccessLogEntry: public RefCountable
 #endif
 
     // Why is this a sub-class and not a set of real "private:" fields?
-    // It looks like its duplicating HTTPRequestMethod anyway!
-    // TODO: shuffle this to the relevant protocol section OR replace with request->method
+    // TODO: shuffle this to the relevant ICP/HTCP protocol section
     class Private
     {
 
@@ -30,6 +30,7 @@
  */
 
 #include "acl/forward.h"
+#include "base/CbcPointer.h"
 #include "enums.h"
 #include "icp_opcode.h"
 #include "ip/Address.h"
@@ -43,7 +44,9 @@
 
 class CachePeerDomainList;
 class NeighborTypeDomainList;
+class PconnPool;
 class PeerDigest;
+class PeerPoolMgr;
 
 // currently a POD
 class CachePeer
@@ -186,6 +189,12 @@ class CachePeer
     time_t connect_timeout;
     int connect_fail_limit;
     int max_conn;
+    struct {
+        PconnPool *pool; ///< idle connection pool for this peer
+        CbcPointer<PeerPoolMgr> mgr; ///< pool manager
+        int limit; ///< the limit itself
+        bool waitingForClose; ///< a conn must close before we open a standby conn
+    } standby; ///< optional "cache_peer standby=limit" feature
     char *domain;       /* Forced domain */
 #if USE_OPENSSL
 
@@ -106,20 +106,20 @@ int aioQueueSize(void);
 class DiskThreadsIOStrategy;
 
 struct AIOCounts {
-    int open_start;
-    int open_finish;
-    int close_start;
-    int close_finish;
-    int cancel;
-    int write_start;
-    int write_finish;
-    int read_start;
-    int read_finish;
-    int stat_start;
-    int stat_finish;
-    int unlink_start;
-    int unlink_finish;
-    int check_callback;
+    uint64_t open_start;
+    uint64_t open_finish;
+    uint64_t close_start;
+    uint64_t close_finish;
+    uint64_t cancel;
+    uint64_t write_start;
+    uint64_t write_finish;
+    uint64_t read_start;
+    uint64_t read_finish;
+    uint64_t stat_start;
+    uint64_t stat_finish;
+    uint64_t unlink_start;
+    uint64_t unlink_finish;
+    uint64_t check_callback;
 };
 
 extern AIOCounts squidaio_counts;
@@ -196,16 +196,16 @@ void
 DiskThreadsIOStrategy::aioStats(StoreEntry * sentry)
 {
     storeAppendPrintf(sentry, "ASYNC IO Counters:\n");
-    storeAppendPrintf(sentry, "Operation\t# Requests\tNumber serviced\n");
-    storeAppendPrintf(sentry, "open\t%d\t%d\n", squidaio_counts.open_start, squidaio_counts.open_finish);
-    storeAppendPrintf(sentry, "close\t%d\t%d\n", squidaio_counts.close_start, squidaio_counts.close_finish);
-    storeAppendPrintf(sentry, "cancel\t%d\t-\n", squidaio_counts.cancel);
-    storeAppendPrintf(sentry, "write\t%d\t%d\n", squidaio_counts.write_start, squidaio_counts.write_finish);
-    storeAppendPrintf(sentry, "read\t%d\t%d\n", squidaio_counts.read_start, squidaio_counts.read_finish);
-    storeAppendPrintf(sentry, "stat\t%d\t%d\n", squidaio_counts.stat_start, squidaio_counts.stat_finish);
-    storeAppendPrintf(sentry, "unlink\t%d\t%d\n", squidaio_counts.unlink_start, squidaio_counts.unlink_finish);
-    storeAppendPrintf(sentry, "check_callback\t%d\t-\n", squidaio_counts.check_callback);
-    storeAppendPrintf(sentry, "queue\t%d\t-\n", squidaio_get_queue_len());
+    storeAppendPrintf(sentry, "  Operation\t# Requests\tNumber serviced\n");
+    storeAppendPrintf(sentry, "  open\t%" PRIu64 "\t%" PRIu64 "\n", squidaio_counts.open_start, squidaio_counts.open_finish);
+    storeAppendPrintf(sentry, "  close\t%" PRIu64 "\t%" PRIu64 "\n", squidaio_counts.close_start, squidaio_counts.close_finish);
+    storeAppendPrintf(sentry, "  cancel\t%" PRIu64 "\t-\n", squidaio_counts.cancel);
+    storeAppendPrintf(sentry, "  write\t%" PRIu64 "\t%" PRIu64 "\n", squidaio_counts.write_start, squidaio_counts.write_finish);
+    storeAppendPrintf(sentry, "  read\t%" PRIu64 "\t%" PRIu64 "\n", squidaio_counts.read_start, squidaio_counts.read_finish);
+    storeAppendPrintf(sentry, "  stat\t%" PRIu64 "\t%" PRIu64 "\n", squidaio_counts.stat_start, squidaio_counts.stat_finish);
+    storeAppendPrintf(sentry, "  unlink\t%" PRIu64 "\t%" PRIu64 "\n", squidaio_counts.unlink_start, squidaio_counts.unlink_finish);
+    storeAppendPrintf(sentry, "  check_callback\t%" PRIu64 "\t-\n", squidaio_counts.check_callback);
+    storeAppendPrintf(sentry, "  queue\t%d\t-\n", squidaio_get_queue_len());
     squidaio_stats(sentry);
 }
 
@@ -65,6 +65,7 @@
 #include "mgr/Registration.h"
 #include "neighbors.h"
 #include "pconn.h"
+#include "PeerPoolMgr.h"
 #include "PeerSelectState.h"
 #include "SquidConfig.h"
 #include "SquidTime.h"
@@ -77,6 +78,7 @@
 #include "ssl/Config.h"
 #include "ssl/ErrorDetail.h"
 #include "ssl/helper.h"
+#include "ssl/PeerConnector.h"
 #include "ssl/ServerBump.h"
 #include "ssl/support.h"
 #endif
@@ -86,37 +88,66 @@
 
 static PSC fwdPeerSelectionCompleteWrapper;
 static CLCB fwdServerClosedWrapper;
-#if USE_OPENSSL
-static PF fwdNegotiateSSLWrapper;
-#endif
 static CNCB fwdConnectDoneWrapper;
 
 static OBJH fwdStats;
 
 #define MAX_FWD_STATS_IDX 9
 static int FwdReplyCodes[MAX_FWD_STATS_IDX + 1][Http::scInvalidHeader + 1];
 
-static PconnPool *fwdPconnPool = new PconnPool("server-side");
+static PconnPool *fwdPconnPool = new PconnPool("server-side", NULL);
 CBDATA_CLASS_INIT(FwdState);
 
+#if USE_OPENSSL
+class FwdStatePeerAnswerDialer: public CallDialer, public Ssl::PeerConnector::CbDialer
+{
+public:
+    typedef void (FwdState::*Method)(Ssl::PeerConnectorAnswer &);
+
+    FwdStatePeerAnswerDialer(Method method, FwdState *fwd):
+            method_(method), fwd_(fwd), answer_() {}
+
+    /* CallDialer API */
+    virtual bool canDial(AsyncCall &call) { return fwd_.valid(); }
+    void dial(AsyncCall &call) { ((&(*fwd_))->*method_)(answer_); }
+    virtual void print(std::ostream &os) const {
+        os << '(' << fwd_.get() << ", " << answer_ << ')';
+    }
+
+    /* Ssl::PeerConnector::CbDialer API */
+    virtual Ssl::PeerConnectorAnswer &answer() { return answer_; }
+
+private:
+    Method method_;
+    CbcPointer<FwdState> fwd_;
+    Ssl::PeerConnectorAnswer answer_;
+};
+#endif
+
 void
 FwdState::abort(void* d)
 {
     FwdState* fwd = (FwdState*)d;
     Pointer tmp = fwd; // Grab a temporary pointer to keep the object alive during our scope.
 
     if (Comm::IsConnOpen(fwd->serverConnection())) {
-        comm_remove_close_handler(fwd->serverConnection()->fd, fwdServerClosedWrapper, fwd);
-        debugs(17, 3, HERE << "store entry aborted; closing " <<
-               fwd->serverConnection());
-        fwd->serverConnection()->close();
+        fwd->closeServerConnection("store entry aborted");
     } else {
         debugs(17, 7, HERE << "store entry aborted; no connection to close");
     }
     fwd->serverDestinations.clear();
     fwd->self = NULL;
 }
 
+void
+FwdState::closeServerConnection(const char *reason)
+{
+    debugs(17, 3, "because " << reason << "; " << serverConn);
+    comm_remove_close_handler(serverConn->fd, fwdServerClosedWrapper, this);
+    fwdPconnPool->noteUses(fd_table[serverConn->fd].pconn.uses);
+    serverConn->close();
+}
+
 /**** PUBLIC INTERFACE ********************************************************/
 
 FwdState::FwdState(const Comm::ConnectionPointer &client, StoreEntry * e, HttpRequest * r, const AccessLogEntryPointer &alp):
@@ -272,11 +303,8 @@ FwdState::~FwdState()
         calls.connector = NULL;
     }
 
-    if (Comm::IsConnOpen(serverConn)) {
-        comm_remove_close_handler(serverConnection()->fd, fwdServerClosedWrapper, this);
-        debugs(17, 3, HERE << "closing FD " << serverConnection()->fd);
-        serverConn->close();
-    }
+    if (Comm::IsConnOpen(serverConn))
+        closeServerConnection("~FwdState");
 
     serverDestinations.clear();
 
@@ -298,7 +326,7 @@ FwdState::Start(const Comm::ConnectionPointer &clientConn, StoreEntry *entry, Ht
      */
 
     if ( Config.accessList.miss && !request->client_addr.isNoAddr() &&
-            request->protocol != AnyP::PROTO_INTERNAL && request->protocol != AnyP::PROTO_CACHE_OBJECT) {
+            !request->flags.internal && request->url.getScheme() != AnyP::PROTO_CACHE_OBJECT) {
         /**
          * Check if this host is allowed to fetch MISSES from us (miss_access).
          * Intentionally replace the src_addr automatically selected by the checklist code
@@ -338,13 +366,16 @@ FwdState::Start(const Comm::ConnectionPointer &clientConn, StoreEntry *entry, Ht
         return;
     }
 
-    switch (request->protocol) {
-
-    case AnyP::PROTO_INTERNAL:
+    if (request->flags.internal) {
+        debugs(17, 2, "calling internalStart() due to request flag");
         internalStart(clientConn, request, entry);
         return;
+    }
+
+    switch (request->url.getScheme()) {
 
     case AnyP::PROTO_CACHE_OBJECT:
+        debugs(17, 2, "calling CacheManager due to request scheme " << request->url.getScheme());
         CacheManager::GetInstance()->Start(clientConn, request, entry);
         return;
 
@@ -509,16 +540,6 @@ fwdServerClosedWrapper(const CommCloseCbParams &params)
     fwd->serverClosed(params.fd);
 }
 
-#if USE_OPENSSL
-static void
-fwdNegotiateSSLWrapper(int fd, void *data)
-{
-    FwdState *fwd = (FwdState *) data;
-    fwd->negotiateSSL(fd);
-}
-
-#endif
-
 void
 fwdConnectDoneWrapper(const Comm::ConnectionPointer &conn, comm_err_t status, int xerrno, void *data)
 {
@@ -599,7 +620,11 @@ FwdState::checkRetriable()
 void
 FwdState::serverClosed(int fd)
 {
-    debugs(17, 2, HERE << "FD " << fd << " " << entry->url());
+    // XXX: fd is often -1 here
+    debugs(17, 2, "FD " << fd << " " << entry->url() << " after " <<
+           (fd >= 0 ? fd_table[fd].pconn.uses : -1) << " requests");
+    if (fd >= 0 && serverConnection()->fd == fd)
+        fwdPconnPool->noteUses(fd_table[fd].pconn.uses);
     retryOrBail();
 }
 
@@ -647,363 +672,6 @@ FwdState::handleUnregisteredServerEnd()
     retryOrBail();
 }
 
-#if USE_OPENSSL
-void
-FwdState::negotiateSSL(int fd)
-{
-    unsigned long ssl_lib_error = SSL_ERROR_NONE;
-    SSL *ssl = fd_table[fd].ssl;
-    int ret;
-
-    if ((ret = SSL_connect(ssl)) <= 0) {
-        int ssl_error = SSL_get_error(ssl, ret);
-#ifdef EPROTO
-        int sysErrNo = EPROTO;
-#else
-        int sysErrNo = EACCES;
-#endif
-
-        switch (ssl_error) {
-
-        case SSL_ERROR_WANT_READ:
-            Comm::SetSelect(fd, COMM_SELECT_READ, fwdNegotiateSSLWrapper, this, 0);
-            return;
-
-        case SSL_ERROR_WANT_WRITE:
-            Comm::SetSelect(fd, COMM_SELECT_WRITE, fwdNegotiateSSLWrapper, this, 0);
-            return;
-
-        case SSL_ERROR_SSL:
-        case SSL_ERROR_SYSCALL:
-            ssl_lib_error = ERR_get_error();
-            debugs(81, DBG_IMPORTANT, "fwdNegotiateSSL: Error negotiating SSL connection on FD " << fd <<
-                   ": " << ERR_error_string(ssl_lib_error, NULL) << " (" << ssl_error <<
-                   "/" << ret << "/" << errno << ")");
-
-            // store/report errno when ssl_error is SSL_ERROR_SYSCALL, ssl_lib_error is 0, and ret is -1
-            if (ssl_error == SSL_ERROR_SYSCALL && ret == -1 && ssl_lib_error == 0)
-                sysErrNo = errno;
-
-            // falling through to complete error handling
-
-        default:
-            // TODO: move into a method before merge
-            Ssl::ErrorDetail *errDetails;
-            Ssl::ErrorDetail *errFromFailure = (Ssl::ErrorDetail *)SSL_get_ex_data(ssl, ssl_ex_index_ssl_error_detail);
-            if (errFromFailure != NULL) {
-                // The errFromFailure is attached to the ssl object
-                // and will be released when ssl object destroyed.
-                // Copy errFromFailure to a new Ssl::ErrorDetail object.
-                errDetails = new Ssl::ErrorDetail(*errFromFailure);
-            } else {
-                // server_cert can be NULL here
-                X509 *server_cert = SSL_get_peer_certificate(ssl);
-                errDetails = new Ssl::ErrorDetail(SQUID_ERR_SSL_HANDSHAKE, server_cert, NULL);
-                X509_free(server_cert);
-            }
-
-            if (ssl_lib_error != SSL_ERROR_NONE)
-                errDetails->setLibError(ssl_lib_error);
-
-            if (request->clientConnectionManager.valid()) {
-                // remember the server certificate from the ErrorDetail object
-                if (Ssl::ServerBump *serverBump = request->clientConnectionManager->serverBump()) {
-                    serverBump->serverCert.resetAndLock(errDetails->peerCert());
-
-                    // remember validation errors, if any
-                    if (Ssl::CertErrors *errs = static_cast<Ssl::CertErrors*>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors)))
-                        serverBump->sslErrors = cbdataReference(errs);
-                }
-
-                // For intercepted connections, set the host name to the server
-                // certificate CN. Otherwise, we just hope that CONNECT is using
-                // a user-entered address (a host name or a user-entered IP).
-                const bool isConnectRequest = !request->clientConnectionManager->port->flags.isIntercepted();
-                if (request->flags.sslPeek && !isConnectRequest) {
-                    if (X509 *srvX509 = errDetails->peerCert()) {
-                        if (const char *name = Ssl::CommonHostName(srvX509)) {
-                            request->SetHost(name);
-                            debugs(83, 3, HERE << "reset request host: " << name);
-                        }
-                    }
-                }
-            }
-
-            ErrorState *const anErr = makeConnectingError(ERR_SECURE_CONNECT_FAIL);
-            anErr->xerrno = sysErrNo;
-            anErr->detail = errDetails;
-            fail(anErr);
-
-            if (serverConnection()->getPeer()) {
-                peerConnectFailed(serverConnection()->getPeer());
-            }
-
-            serverConn->close();
-            return;
-        }
-    }
-
-    if (request->clientConnectionManager.valid()) {
-        // remember the server certificate from the ErrorDetail object
-        if (Ssl::ServerBump *serverBump = request->clientConnectionManager->serverBump()) {
-            serverBump->serverCert.reset(SSL_get_peer_certificate(ssl));
-
-            // remember validation errors, if any
-            if (Ssl::CertErrors *errs = static_cast<Ssl::CertErrors *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors)))
-                serverBump->sslErrors = cbdataReference(errs);
-        }
-    }
-
-    if (serverConnection()->getPeer() && !SSL_session_reused(ssl)) {
-        if (serverConnection()->getPeer()->sslSession)
-            SSL_SESSION_free(serverConnection()->getPeer()->sslSession);
-
-        serverConnection()->getPeer()->sslSession = SSL_get1_session(ssl);
-    }
-
-    if (Ssl::TheConfig.ssl_crt_validator) {
-        Ssl::CertValidationRequest validationRequest;
-        // WARNING: Currently we do not use any locking for any of the
-        // members of the Ssl::CertValidationRequest class. In this code the
-        // Ssl::CertValidationRequest object used only to pass data to
-        // Ssl::CertValidationHelper::submit method.
-        validationRequest.ssl = ssl;
-        validationRequest.domainName = request->GetHost();
-        if (Ssl::CertErrors *errs = static_cast<Ssl::CertErrors *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors)))
-            // validationRequest disappears on return so no need to cbdataReference
-            validationRequest.errors = errs;
-        else
-            validationRequest.errors = NULL;
-        try {
-            debugs(83, 5, "Sending SSL certificate for validation to ssl_crtvd.");
-            Ssl::CertValidationHelper::GetInstance()->sslSubmit(validationRequest, sslCrtvdHandleReplyWrapper, this);
-            return;
-        } catch (const std::exception &e) {
-            debugs(33, DBG_IMPORTANT, "ERROR: Failed to compose ssl_crtvd " <<
-                   "request for " << validationRequest.domainName <<
-                   " certificate: " << e.what() << "; will now block to " <<
-                   "validate that certificate.");
-            // fall through to do blocking in-process generation.
-            ErrorState *anErr = new ErrorState(ERR_GATEWAY_FAILURE, Http::scInternalServerError, request);
-            fail(anErr);
-            if (serverConnection()->getPeer()) {
-                peerConnectFailed(serverConnection()->getPeer());
-            }
-            serverConn->close();
-            self = NULL;
-            return;
-        }
-    }
-
-    dispatch();
-}
-
-void
-FwdState::sslCrtvdHandleReplyWrapper(void *data, Ssl::CertValidationResponse const &validationResponse)
-{
-    FwdState * fwd = (FwdState *)(data);
-    fwd->sslCrtvdHandleReply(validationResponse);
-}
-
-void
-FwdState::sslCrtvdHandleReply(Ssl::CertValidationResponse const &validationResponse)
-{
-    Ssl::CertErrors *errs = NULL;
-    Ssl::ErrorDetail *errDetails = NULL;
-    bool validatorFailed = false;
-    if (!Comm::IsConnOpen(serverConnection())) {
-        return;
-    }
-
-    debugs(83,5, request->GetHost() << " cert validation result: " << validationResponse.resultCode);
-
-    if (validationResponse.resultCode == HelperReply::Error)
-        errs = sslCrtvdCheckForErrors(validationResponse, errDetails);
-    else if (validationResponse.resultCode != HelperReply::Okay)
-        validatorFailed = true;
-
-    if (!errDetails && !validatorFailed) {
-        dispatch();
-        return;
-    }
-
-    ErrorState *anErr = NULL;
-    if (validatorFailed) {
-        anErr = new ErrorState(ERR_GATEWAY_FAILURE, Http::scInternalServerError, request);
-    }  else {
-
-        // Check the list error with
-        if (errDetails && request->clientConnectionManager.valid()) {
-            // remember the server certificate from the ErrorDetail object
-            if (Ssl::ServerBump *serverBump = request->clientConnectionManager->serverBump()) {
-                // remember validation errors, if any
-                if (errs) {
-                    if (serverBump->sslErrors)
-                        cbdataReferenceDone(serverBump->sslErrors);
-                    serverBump->sslErrors = cbdataReference(errs);
-                }
-            }
-        }
-
-        anErr = makeConnectingError(ERR_SECURE_CONNECT_FAIL);
-        anErr->detail = errDetails;
-        /*anErr->xerrno= Should preserved*/
-    }
-
-    fail(anErr);
-    if (serverConnection()->getPeer()) {
-        peerConnectFailed(serverConnection()->getPeer());
-    }
-    serverConn->close();
-    self = NULL;
-    return;
-}
-
-/// Checks errors in the cert. validator response against sslproxy_cert_error.
-/// The first honored error, if any, is returned via errDetails parameter.
-/// The method returns all seen errors except SSL_ERROR_NONE as Ssl::CertErrors.
-Ssl::CertErrors *
-FwdState::sslCrtvdCheckForErrors(Ssl::CertValidationResponse const &resp, Ssl::ErrorDetail *& errDetails)
-{
-    Ssl::CertErrors *errs = NULL;
-
-    ACLFilledChecklist *check = NULL;
-    if (acl_access *acl = Config.ssl_client.cert_error)
-        check = new ACLFilledChecklist(acl, request, dash_str);
-
-    SSL *ssl = fd_table[serverConnection()->fd].ssl;
-    typedef Ssl::CertValidationResponse::RecvdErrors::const_iterator SVCRECI;
-    for (SVCRECI i = resp.errors.begin(); i != resp.errors.end(); ++i) {
-        debugs(83, 7, "Error item: " << i->error_no << " " << i->error_reason);
-
-        assert(i->error_no != SSL_ERROR_NONE);
-
-        if (!errDetails) {
-            bool allowed = false;
-            if (check) {
-                check->sslErrors = new Ssl::CertErrors(Ssl::CertError(i->error_no, i->cert.get()));
-                if (check->fastCheck() == ACCESS_ALLOWED)
-                    allowed = true;
-            }
-            // else the Config.ssl_client.cert_error access list is not defined
-            // and the first error will cause the error page
-
-            if (allowed) {
-                debugs(83, 3, "bypassing SSL error " << i->error_no << " in " << "buffer");
-            } else {
-                debugs(83, 5, "confirming SSL error " << i->error_no);
-                X509 *brokenCert = i->cert.get();
-                Ssl::X509_Pointer peerCert(SSL_get_peer_certificate(ssl));
-                const char *aReason = i->error_reason.empty() ? NULL : i->error_reason.c_str();
-                errDetails = new Ssl::ErrorDetail(i->error_no, peerCert.get(), brokenCert, aReason);
-            }
-            if (check) {
-                delete check->sslErrors;
-                check->sslErrors = NULL;
-            }
-        }
-
-        if (!errs)
-            errs = new Ssl::CertErrors(Ssl::CertError(i->error_no, i->cert.get()));
-        else
-            errs->push_back_unique(Ssl::CertError(i->error_no, i->cert.get()));
-    }
-    if (check)
-        delete check;
-
-    return errs;
-}
-
-void
-FwdState::initiateSSL()
-{
-    SSL *ssl;
-    SSL_CTX *sslContext = NULL;
-    const CachePeer *peer = serverConnection()->getPeer();
-    int fd = serverConnection()->fd;
-
-    if (peer) {
-        assert(peer->use_ssl);
-        sslContext = peer->sslContext;
-    } else {
-        sslContext = Config.ssl_client.sslContext;
-    }
-
-    assert(sslContext);
-
-    if ((ssl = SSL_new(sslContext)) == NULL) {
-        debugs(83, DBG_IMPORTANT, "fwdInitiateSSL: Error allocating handle: " << ERR_error_string(ERR_get_error(), NULL)  );
-        ErrorState *anErr = new ErrorState(ERR_SOCKET_FAILURE, Http::scInternalServerError, request);
-        // TODO: create Ssl::ErrorDetail with OpenSSL-supplied error code
-        fail(anErr);
-        self = NULL;		// refcounted
-        return;
-    }
-
-    SSL_set_fd(ssl, fd);
-
-    if (peer) {
-        if (peer->ssldomain)
-            SSL_set_ex_data(ssl, ssl_ex_index_server, peer->ssldomain);
-
-#if NOT_YET
-
-        else if (peer->name)
-            SSL_set_ex_data(ssl, ssl_ex_index_server, peer->name);
-
-#endif
-
-        else
-            SSL_set_ex_data(ssl, ssl_ex_index_server, peer->host);
-
-        if (peer->sslSession)
-            SSL_set_session(ssl, peer->sslSession);
-
-    } else {
-        // While we are peeking at the certificate, we may not know the server
-        // name that the client will request (after interception or CONNECT)
-        // unless it was the CONNECT request with a user-typed address.
-        const char *hostname = request->GetHost();
-        const bool hostnameIsIp = request->GetHostIsNumeric();
-        const bool isConnectRequest = request->clientConnectionManager.valid() &&
-                                      !request->clientConnectionManager->port->flags.isIntercepted();
-        if (!request->flags.sslPeek || isConnectRequest)
-            SSL_set_ex_data(ssl, ssl_ex_index_server, (void*)hostname);
-
-        // Use SNI TLS extension only when we connect directly
-        // to the origin server and we know the server host name.
-        if (!hostnameIsIp)
-            Ssl::setClientSNI(ssl, hostname);
-    }
-
-    // If CertValidation Helper used do not lookup checklist for errors,
-    // but keep a list of errors to send it to CertValidator
-    if (!Ssl::TheConfig.ssl_crt_validator) {
-        // Create the ACL check list now, while we have access to more info.
-        // The list is used in ssl_verify_cb() and is freed in ssl_free().
-        if (acl_access *acl = Config.ssl_client.cert_error) {
-            ACLFilledChecklist *check = new ACLFilledChecklist(acl, request, dash_str);
-            SSL_set_ex_data(ssl, ssl_ex_index_cert_error_check, check);
-        }
-    }
-
-    // store peeked cert to check SQUID_X509_V_ERR_CERT_CHANGE
-    X509 *peeked_cert;
-    if (request->clientConnectionManager.valid() &&
-            request->clientConnectionManager->serverBump() &&
-            (peeked_cert = request->clientConnectionManager->serverBump()->serverCert.get())) {
-        CRYPTO_add(&(peeked_cert->references),1,CRYPTO_LOCK_X509);
-        SSL_set_ex_data(ssl, ssl_ex_index_ssl_peeked_cert, peeked_cert);
-    }
-
-    fd_table[fd].ssl = ssl;
-    fd_table[fd].read_method = &ssl_read_method;
-    fd_table[fd].write_method = &ssl_write_method;
-    negotiateSSL(fd);
-}
-
-#endif
-
 void
 FwdState::connectDone(const Comm::ConnectionPointer &conn, comm_err_t status, int xerrno)
 {
@@ -1036,9 +704,16 @@ FwdState::connectDone(const Comm::ConnectionPointer &conn, comm_err_t status, in
 #if USE_OPENSSL
     if (!request->flags.pinned) {
         if ((serverConnection()->getPeer() && serverConnection()->getPeer()->use_ssl) ||
-                (!serverConnection()->getPeer() && request->protocol == AnyP::PROTO_HTTPS) ||
+                (!serverConnection()->getPeer() && request->url.getScheme() == AnyP::PROTO_HTTPS) ||
                 request->flags.sslPeek) {
-            initiateSSL();
+
+            HttpRequest::Pointer requestPointer = request;
+            AsyncCall::Pointer callback = asyncCall(17,4,
+                                                    "FwdState::ConnectedToPeer",
+                                                    FwdStatePeerAnswerDialer(&FwdState::connectedToPeer, this));
+            Ssl::PeerConnector *connector =
+                new Ssl::PeerConnector(requestPointer, serverConnection(), callback);
+            AsyncJob::Start(connector); // will call our callback
             return;
         }
     }
@@ -1057,6 +732,21 @@ FwdState::connectDone(const Comm::ConnectionPointer &conn, comm_err_t status, in
     dispatch();
 }
 
+#if USE_OPENSSL
+void
+FwdState::connectedToPeer(Ssl::PeerConnectorAnswer &answer)
+{
+    if (ErrorState *error = answer.error.get()) {
+        fail(error);
+        answer.error.clear(); // preserve error for errorSendComplete()
+        self = NULL;
+        return;
+    }
+
+    dispatch();
+}
+#endif
+
 void
 FwdState::connectTimeout(int fd)
 {
@@ -1163,7 +853,7 @@ FwdState::connectStart()
     // This does not increase the total number of connections because we just
     // closed the connection that failed the race. And re-pinning assumes this.
     if (pconnRace != raceHappened)
-        temp = fwdPconnPool->pop(serverDestinations[0], host, checkRetriable());
+        temp = pconnPop(serverDestinations[0], host);
 
     const bool openedPconn = Comm::IsConnOpen(temp);
     pconnRace = openedPconn ? racePossible : raceImpossible;
@@ -1215,7 +905,7 @@ FwdState::connectStart()
 void
 FwdState::dispatch()
 {
-    debugs(17, 3, HERE << clientConn << ": Fetching '" << RequestMethodStr(request->method) << " " << entry->url() << "'");
+    debugs(17, 3, clientConn << ": Fetching " << request->method << ' ' << entry->url());
     /*
      * Assert that server_fd is set.  This is to guarantee that fwdState
      * is attached to something and will be deallocated when server_fd
@@ -1225,7 +915,7 @@ FwdState::dispatch()
 
     fd_note(serverConnection()->fd, entry->url());
 
-    fd_table[serverConnection()->fd].noteUse(fwdPconnPool);
+    fd_table[serverConnection()->fd].noteUse();
 
     /*assert(!EBIT_TEST(entry->flags, ENTRY_DISPATCHED)); */
     assert(entry->ping_status != PING_WAITING);
@@ -1279,7 +969,7 @@ FwdState::dispatch()
         request->peer_login = NULL;
         request->peer_domain = NULL;
 
-        switch (request->protocol) {
+        switch (request->url.getScheme()) {
 #if USE_OPENSSL
 
         case AnyP::PROTO_HTTPS:
@@ -1304,8 +994,6 @@ FwdState::dispatch()
 
         case AnyP::PROTO_CACHE_OBJECT:
 
-        case AnyP::PROTO_INTERNAL:
-
         case AnyP::PROTO_URN:
             fatal_dump("Should never get here");
             break;
@@ -1463,6 +1151,22 @@ FwdState::pconnPush(Comm::ConnectionPointer &conn, const char *domain)
     }
 }
 
+Comm::ConnectionPointer
+FwdState::pconnPop(const Comm::ConnectionPointer &dest, const char *domain)
+{
+    // always call shared pool first because we need to close an idle
+    // connection there if we have to use a standby connection.
+    Comm::ConnectionPointer conn = fwdPconnPool->pop(dest, domain, checkRetriable());
+    if (!Comm::IsConnOpen(conn)) {
+        // either there was no pconn to pop or this is not a retriable xaction
+        if (CachePeer *peer = dest->getPeer()) {
+            if (peer->standby.pool)
+                conn = peer->standby.pool->pop(dest, domain, true);
+        }
+    }
+    return conn; // open, closed, or nil
+}
+
 void
 FwdState::initModule()
 {
@@ -16,6 +16,8 @@
 
 class AccessLogEntry;
 typedef RefCount<AccessLogEntry> AccessLogEntryPointer;
+class PconnPool;
+typedef RefCount<PconnPool> PconnPoolPointer;
 class ErrorState;
 class HttpRequest;
 
@@ -24,6 +26,7 @@ namespace Ssl
 {
 class ErrorDetail;
 class CertValidationResponse;
+class PeerConnectorAnswer;
 };
 #endif
 
@@ -72,11 +75,12 @@ class FwdState : public RefCountable
     void connectStart();
     void connectDone(const Comm::ConnectionPointer & conn, comm_err_t status, int xerrno);
     void connectTimeout(int fd);
-    void initiateSSL();
-    void negotiateSSL(int fd);
     bool checkRetry();
     bool checkRetriable();
     void dispatch();
+    /// Pops a connection from connection pool if available. If not
+    /// checks the peer stand-by connection pool for available connection.
+    Comm::ConnectionPointer pconnPop(const Comm::ConnectionPointer &dest, const char *domain);
     void pconnPush(Comm::ConnectionPointer & conn, const char *domain);
 
     bool dontRetry() { return flags.dont_retry; }
@@ -86,14 +90,6 @@ class FwdState : public RefCountable
     /** return a ConnectionPointer to the current server connection (may or may not be open) */
     Comm::ConnectionPointer const & serverConnection() const { return serverConn; };
 
-#if USE_OPENSSL
-    /// Callback function called when squid receive message from cert validator helper
-    static void sslCrtvdHandleReplyWrapper(void *data, Ssl::CertValidationResponse const &);
-    /// Process response from cert validator helper
-    void sslCrtvdHandleReply(Ssl::CertValidationResponse const &);
-    /// Check SSL errors returned from cert validator against sslproxy_cert_error access list
-    Ssl::CertErrors *sslCrtvdCheckForErrors(Ssl::CertValidationResponse const &, Ssl::ErrorDetail *&);
-#endif
 private:
     // hidden for safer management of self; use static fwdStart
     FwdState(const Comm::ConnectionPointer &client, StoreEntry *, HttpRequest *, const AccessLogEntryPointer &alp);
@@ -107,8 +103,14 @@ class FwdState : public RefCountable
     void completed();
     void retryOrBail();
     ErrorState *makeConnectingError(const err_type type) const;
+#if USE_OPENSSL
+    void connectedToPeer(Ssl::PeerConnectorAnswer &answer);
+#endif
     static void RegisterWithCacheManager(void);
 
+    /// stops monitoring server connection for closure and updates pconn stats
+    void closeServerConnection(const char *reason);
+
 public:
     StoreEntry *entry;
     HttpRequest *request;
@@ -41,7 +41,7 @@
 #include "SquidConfig.h"
 
 HttpMsg::HttpMsg(http_hdr_owner_type owner): header(owner),
-        cache_control(NULL), hdr_sz(0), content_length(0), protocol(AnyP::PROTO_NONE),
+        cache_control(NULL), hdr_sz(0), content_length(0),
         pstate(psReadyToParseStartLine)
 {}
 
@@ -67,6 +67,8 @@ class HttpMsg : public RefCountable
     bool persistent() const;
 
 public:
+    /// HTTP-Version field in the first line of the message.
+    /// see draft-ietf-httpbis-p1-messaging-26 section 3.1
     Http::ProtocolVersion http_ver;
 
     HttpHeader header;
@@ -80,8 +82,6 @@ class HttpMsg : public RefCountable
 
     int64_t content_length;
 
-    AnyP::ProtocolType protocol;
-
     HttpMsgParseState pstate;   /* the current parsing state */
 
     BodyPipe::Pointer body_pipe; // optional pipeline to receive message body
@@ -604,7 +604,6 @@ HttpReply::clone() const
     rep->pstate = pstate;
     rep->body_pipe = body_pipe;
 
-    rep->protocol = protocol;
     // keep_alive is handled in hdrCacheInit()
     return rep;
 }
@@ -82,15 +82,15 @@ void
 HttpRequest::initHTTP(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath)
 {
     method = aMethod;
-    protocol = aProtocol;
+    url.setScheme(aProtocol);
     urlpath = aUrlpath;
 }
 
 void
 HttpRequest::init()
 {
     method = Http::METHOD_NONE;
-    protocol = AnyP::PROTO_NONE;
+    url.clear();
     urlpath = NULL;
     login[0] = '\0';
     host[0] = '\0';
@@ -150,6 +150,7 @@ HttpRequest::clean()
 
     safe_free(vary_headers);
 
+    url.clear();
     urlpath.clean();
 
     header.clean();
@@ -197,7 +198,7 @@ HttpRequest::reset()
 HttpRequest *
 HttpRequest::clone() const
 {
-    HttpRequest *copy = new HttpRequest(method, protocol, urlpath.termedBuf());
+    HttpRequest *copy = new HttpRequest(method, url.getScheme(), urlpath.termedBuf());
     // TODO: move common cloning clone to Msg::copyTo() or copy ctor
     copy->header.append(&header);
     copy->hdrCacheInit();
@@ -391,8 +392,8 @@ HttpRequest::pack(Packer * p)
 {
     assert(p);
     /* pack request-line */
-    packerPrintf(p, "%s " SQUIDSTRINGPH " HTTP/%d.%d\r\n",
-                 RequestMethodStr(method), SQUIDSTRINGPRINT(urlpath),
+    packerPrintf(p, SQUIDSBUFPH " " SQUIDSTRINGPH " HTTP/%d.%d\r\n",
+                 SQUIDSBUFPRINT(method.image()), SQUIDSTRINGPRINT(urlpath),
                  http_ver.major, http_ver.minor);
     /* headers */
     header.packInto(p);
@@ -414,7 +415,7 @@ httpRequestPack(void *obj, Packer *p)
 int
 HttpRequest::prefixLen()
 {
-    return strlen(RequestMethodStr(method)) + 1 +
+    return method.image().length() + 1 +
            urlpath.size() + 1 +
            4 + 1 + 3 + 2 +
            header.len + 2;
@@ -524,8 +525,8 @@ const char *HttpRequest::packableURI(bool full_uri) const
 void HttpRequest::packFirstLineInto(Packer * p, bool full_uri) const
 {
     // form HTTP request-line
-    packerPrintf(p, "%s %s HTTP/%d.%d\r\n",
-                 RequestMethodStr(method),
+    packerPrintf(p, SQUIDSBUFPH " %s HTTP/%d.%d\r\n",
+                 SQUIDSBUFPRINT(method.image()),
                  packableURI(full_uri),
                  http_ver.major, http_ver.minor);
 }
@@ -594,7 +595,7 @@ HttpRequest::maybeCacheable()
     if (!flags.hostVerified && (flags.intercepted || flags.interceptTproxy))
         return false;
 
-    switch (protocol) {
+    switch (url.getScheme()) {
     case AnyP::PROTO_HTTP:
     case AnyP::PROTO_HTTPS:
         if (!method.respMaybeCacheable())
@@ -39,6 +39,7 @@
 #include "HttpRequestMethod.h"
 #include "Notes.h"
 #include "RequestFlags.h"
+#include "URL.h"
 
 #if USE_AUTH
 #include "auth/UserRequest.h"
@@ -136,6 +137,9 @@ class HttpRequest: public HttpMsg
 public:
     HttpRequestMethod method;
 
+    // TODO expand to include all URI parts
+    URL url; ///< the request URI (scheme only)
+
     char login[MAX_LOGIN_SZ];
 
 private:
@@ -20,20 +20,11 @@ operator++ (Http::MethodType &aMethod)
  * or from a range of chars, * such as "GET" from "GETFOOBARBAZ"
  * (pass in pointer to G and pointer to F.)
  */
-HttpRequestMethod::HttpRequestMethod(char const *begin, char const *end) : theMethod (Http::METHOD_NONE)
+HttpRequestMethod::HttpRequestMethod(char const *begin, char const *end) : theMethod(Http::METHOD_NONE)
 {
     if (begin == NULL)
         return;
 
-    /*
-     * This check for '%' makes sure that we don't
-     * match one of the extension method placeholders,
-     * which have the form %EXT[0-9][0-9]
-     */
-
-    if (*begin == '%')
-        return;
-
     /*
      * if e is NULL, b must be NULL terminated and we
      * make e point to the first whitespace character
@@ -42,40 +33,40 @@ HttpRequestMethod::HttpRequestMethod(char const *begin, char const *end) : theMe
     if (NULL == end)
         end = begin + strcspn(begin, w_space);
 
-    if (end == begin) {
-        theMethod = Http::METHOD_NONE;
+    if (end == begin)
         return;
-    }
 
+    // TODO: Optimize this linear search.
     for (++theMethod; theMethod < Http::METHOD_ENUM_END; ++theMethod) {
         // RFC 2616 section 5.1.1 - Method names are case-sensitive
         // NP: this is not a HTTP_VIOLATIONS case since there is no MUST/SHOULD involved.
-        if (0 == strncasecmp(begin, Http::MethodType_str[theMethod], end-begin)) {
+        if (0 == image().caseCmp(begin, end-begin)) {
 
             // relaxed parser allows mixed-case and corrects them on output
             if (Config.onoff.relaxed_header_parser)
                 return;
 
-            if (0 == strncmp(begin, Http::MethodType_str[theMethod], end-begin))
+            if (0 == image().cmp(begin, end-begin))
                 return;
         }
     }
 
     // if method not found and method string is not null then it is other method
     theMethod = Http::METHOD_OTHER;
-    theImage.limitInit(begin,end-begin);
+    theImage.assign(begin, end-begin);
 }
 
-char const*
+const SBuf &
 HttpRequestMethod::image() const
 {
+    static const SBuf methodOther("METHOD_OTHER");
     if (Http::METHOD_OTHER != theMethod) {
-        return Http::MethodType_str[theMethod];
+        return Http::MethodType_sb[theMethod];
     } else {
-        if (theImage.size()>0) {
-            return theImage.termedBuf();
+        if (!theImage.isEmpty()) {
+            return theImage;
         } else {
-            return "METHOD_OTHER";
+            return methodOther;
         }
     }
 }
@@ -2,8 +2,7 @@
 #define SQUID_HTTPREQUESTMETHOD_H
 
 #include "http/MethodType.h"
-#include "SquidString.h"
-#include "SquidString.h"
+#include "SBuf.h"
 
 class SquidConfig;
 
@@ -41,7 +40,7 @@ class HttpRequestMethod
 
     HttpRequestMethod & operator = (Http::MethodType const aMethod) {
         theMethod = aMethod;
-        theImage.clean();
+        theImage.clear();
         return *this;
     }
 
@@ -73,8 +72,8 @@ class HttpRequestMethod
      */
     Http::MethodType id() const { return theMethod; }
 
-    /** Get a char string representation of the method. */
-    char const * image() const;
+    /** Get a string representation of the method. */
+    const SBuf &image() const;
 
     /// Whether this method is defined as a "safe" in HTTP/1.1
     /// see RFC 2616 section 9.1.1
@@ -112,10 +111,8 @@ class HttpRequestMethod
     bool purgesOthers() const;
 
 private:
-    static const char *RequestMethodStr[];
-
     Http::MethodType theMethod; ///< Method type
-    String theImage;     ///< Used for storing the Http::METHOD_OTHER only. A copy of the parsed method text.
+    SBuf theImage;     ///< Used for storing the Http::METHOD_OTHER only. A copy of the parsed method text.
 };
 
 inline std::ostream &
@@ -125,16 +122,4 @@ operator << (std::ostream &os, HttpRequestMethod const &method)
     return os;
 }
 
-inline const char*
-RequestMethodStr(const Http::MethodType m)
-{
-    return HttpRequestMethod(m).image();
-}
-
-inline const char*
-RequestMethodStr(const HttpRequestMethod& m)
-{
-    return m.image();
-}
-
 #endif /* SQUID_HTTPREQUESTMETHOD_H */
@@ -476,6 +476,8 @@ squid_SOURCES = \
 	peer_sourcehash.cc \
 	peer_userhash.h \
 	peer_userhash.cc \
+	PeerPoolMgr.h \
+	PeerPoolMgr.cc \
 	PeerSelectState.h \
 	PingData.h \
 	protos.h \
@@ -1526,6 +1528,8 @@ tests_testCacheManager_SOURCES = \
 	peer_sourcehash.cc \
 	peer_userhash.h \
 	peer_userhash.cc \
+	PeerPoolMgr.h \
+	PeerPoolMgr.cc \
 	redirect.h \
 	tests/stub_redirect.cc \
 	refresh.h \
@@ -1752,6 +1756,7 @@ tests_testDiskIO_SOURCES = \
 	tests/stub_MemStore.cc \
 	mime.h \
 	tests/stub_mime.cc \
+	tests/stub_neighbors.cc \
 	tests/stub_pconn.cc \
 	tests/stub_Port.cc \
 	tests/stub_stat.cc \
@@ -1911,6 +1916,8 @@ tests_testEvent_SOURCES = \
 	HttpParser.cc \
 	HttpParser.h \
 	HttpReply.cc \
+	PeerPoolMgr.h \
+	PeerPoolMgr.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
@@ -2163,6 +2170,8 @@ tests_testEventLoop_SOURCES = \
 	HttpParser.cc \
 	HttpParser.h \
 	HttpReply.cc \
+	PeerPoolMgr.h \
+	PeerPoolMgr.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
@@ -2411,6 +2420,8 @@ tests_test_http_range_SOURCES = \
 	HttpParser.cc \
 	HttpParser.h \
 	HttpReply.cc \
+	PeerPoolMgr.h \
+	PeerPoolMgr.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
@@ -2755,6 +2766,8 @@ tests_testHttpRequest_SOURCES = \
 	peer_sourcehash.cc \
 	peer_userhash.h \
 	peer_userhash.cc \
+	PeerPoolMgr.h \
+	PeerPoolMgr.cc \
 	redirect.h \
 	tests/stub_libauth_acls.cc \
 	tests/stub_redirect.cc \
@@ -3105,6 +3118,7 @@ tests_testUfs_SOURCES = \
 	tests/stub_libeui.cc \
 	tests/stub_libicmp.cc \
 	tests/stub_MemStore.cc \
+	tests/stub_neighbors.cc \
 	tests/stub_pconn.cc \
 	tests/stub_Port.cc \
 	tests/stub_UdsOp.cc \
@@ -3397,6 +3411,7 @@ tests_testRock_SOURCES = \
 	tests/stub_MemStore.cc \
 	mime.h \
 	tests/stub_mime.cc \
+	tests/stub_neighbors.cc \
 	tests/stub_Port.cc \
 	tests/stub_pconn.cc \
 	tests/stub_store_client.cc \
@@ -3541,6 +3556,8 @@ tests_testURL_SOURCES = \
 	HttpParser.cc \
 	HttpParser.h \
 	HttpReply.cc \
+	PeerPoolMgr.h \
+	PeerPoolMgr.cc \
 	RequestFlags.h \
 	RequestFlags.cc \
 	HttpRequest.cc \
@@ -3832,6 +3849,9 @@ tests_testStatHist_SOURCES = \
 	fatal.h \
 	tests/stub_fatal.cc \
 	tests/stub_MemBuf.cc \
+	$(SBUF_SOURCE) \
+	SBufDetailedStats.h \
+	tests/stub_SBufDetailedStats.cc \
 	StatHist.cc \
 	StatHist.h \
 	String.cc \
@@ -3850,6 +3870,7 @@ tests_testStatHist_SOURCES = \
 	repl_modules.h \
 	tests/stub_store.cc \
 	tests/stub_store_stats.cc \
+	time.cc \
 	tools.h \
 	tests/stub_tools.cc \
 	tests/testMain.cc \
@@ -243,8 +243,7 @@ struct StoreClientStats : public unary_function<store_client, void> {
 void
 MemObject::stat(MemBuf * mb) const
 {
-    mb->Printf("\t%s %s\n",
-               RequestMethodStr(method), logUri());
+    mb->Printf("\t" SQUIDSBUFPH " %s\n", SQUIDSBUFPRINT(method.image()), logUri());
     if (vary_headers)
         mb->Printf("\tvary_headers: %s\n", vary_headers);
     mb->Printf("\tinmem_lo: %" PRId64 "\n", inmem_lo);
@@ -158,15 +158,15 @@ NotePairs::~NotePairs()
 }
 
 const char *
-NotePairs::find(const char *noteKey) const
+NotePairs::find(const char *noteKey, const char *sep) const
 {
     static String value;
     value.clean();
     for (std::vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
         if ((*i)->name.cmp(noteKey) == 0) {
             if (value.size())
-                value.append(", ");
-            value.append(ConfigParser::QuoteString((*i)->value));
+                value.append(sep);
+            value.append((*i)->value);
         }
     }
     return value.size() ? value.termedBuf() : NULL;
@@ -180,7 +180,7 @@ NotePairs::toString(const char *sep) const
     for (std::vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
         value.append((*i)->name);
         value.append(": ");
-        value.append(ConfigParser::QuoteString((*i)->value));
+        value.append((*i)->value);
         value.append(sep);
     }
     return value.size() ? value.termedBuf() : NULL;
@@ -145,7 +145,7 @@ class NotePairs: public RefCountable
      * Returns a comma separated list of notes with key 'noteKey'.
      * Use findFirst instead when a unique kv-pair is needed.
      */
-    const char *find(const char *noteKey) const;
+    const char *find(const char *noteKey, const char *sep = ",") const;
 
     /**
      * Returns the first note value for this key or an empty string.
@@ -0,0 +1,284 @@
+#include "squid.h"
+#include "base/AsyncJobCalls.h"
+#include "base/RunnersRegistry.h"
+#include "CachePeer.h"
+#include "comm/Connection.h"
+#include "comm/ConnOpener.h"
+#include "Debug.h"
+#include "fd.h"
+#include "FwdState.h"
+#include "globals.h"
+#include "HttpRequest.h"
+#include "neighbors.h"
+#include "pconn.h"
+#include "PeerPoolMgr.h"
+#include "SquidConfig.h"
+#if USE_OPENSSL
+#include "ssl/PeerConnector.h"
+#endif
+
+CBDATA_CLASS_INIT(PeerPoolMgr);
+
+#if USE_OPENSSL
+/// Gives Ssl::PeerConnector access to Answer in the PeerPoolMgr callback dialer.
+class MyAnswerDialer: public UnaryMemFunT<PeerPoolMgr, Ssl::PeerConnectorAnswer, Ssl::PeerConnectorAnswer&>,
+        public Ssl::PeerConnector::CbDialer
+{
+public:
+    MyAnswerDialer(const JobPointer &aJob, Method aMethod):
+            UnaryMemFunT<PeerPoolMgr, Ssl::PeerConnectorAnswer, Ssl::PeerConnectorAnswer&>(aJob, aMethod, Ssl::PeerConnectorAnswer()) {}
+
+    /* Ssl::PeerConnector::CbDialer API */
+    virtual Ssl::PeerConnectorAnswer &answer() { return arg1; }
+};
+#endif
+
+PeerPoolMgr::PeerPoolMgr(CachePeer *aPeer): AsyncJob("PeerPoolMgr"),
+        peer(cbdataReference(aPeer)),
+        request(),
+        opener(),
+        securer(),
+        closer(),
+        addrUsed(0)
+{
+}
+
+PeerPoolMgr::~PeerPoolMgr()
+{
+    cbdataReferenceDone(peer);
+}
+
+void
+PeerPoolMgr::start()
+{
+    AsyncJob::start();
+
+    // ErrorState, getOutgoingAddress(), and other APIs may require a request.
+    // We fake one. TODO: Optionally send this request to peers?
+    request = new HttpRequest(Http::METHOD_OPTIONS, AnyP::PROTO_HTTP, "*");
+    request->SetHost(peer->host);
+
+    checkpoint("peer initialized");
+}
+
+void
+PeerPoolMgr::swanSong()
+{
+    AsyncJob::swanSong();
+}
+
+bool
+PeerPoolMgr::validPeer() const
+{
+    return peer && cbdataReferenceValid(peer) && peer->standby.pool;
+}
+
+bool
+PeerPoolMgr::doneAll() const
+{
+    return !(validPeer() && peer->standby.limit) && AsyncJob::doneAll();
+}
+
+void
+PeerPoolMgr::handleOpenedConnection(const CommConnectCbParams &params)
+{
+    opener = NULL;
+
+    if (!validPeer()) {
+        debugs(48, 3, "peer gone");
+        if (params.conn != NULL)
+            params.conn->close();
+        return;
+    }
+
+    if (params.flag != COMM_OK) {
+        /* it might have been a timeout with a partially open link */
+        if (params.conn != NULL)
+            params.conn->close();
+        peerConnectFailed(peer);
+        checkpoint("conn opening failure"); // may retry
+        return;
+    }
+
+    Must(params.conn != NULL);
+
+#if USE_OPENSSL
+    // Handle SSL peers.
+    if (peer->use_ssl) {
+        typedef CommCbMemFunT<PeerPoolMgr, CommCloseCbParams> CloserDialer;
+        closer = JobCallback(48, 3, CloserDialer, this,
+                             PeerPoolMgr::handleSecureClosure);
+        comm_add_close_handler(params.conn->fd, closer);
+
+        securer = asyncCall(48, 4, "PeerPoolMgr::handleSecuredPeer",
+                            MyAnswerDialer(this, &PeerPoolMgr::handleSecuredPeer));
+        Ssl::PeerConnector *connector =
+            new Ssl::PeerConnector(request, params.conn, securer);
+        AsyncJob::Start(connector); // will call our callback
+        return;
+    }
+#endif
+
+    pushNewConnection(params.conn);
+}
+
+void
+PeerPoolMgr::pushNewConnection(const Comm::ConnectionPointer &conn)
+{
+    Must(validPeer());
+    Must(Comm::IsConnOpen(conn));
+    peer->standby.pool->push(conn, NULL /* domain */);
+    // push() will trigger a checkpoint()
+}
+
+#if USE_OPENSSL
+void
+PeerPoolMgr::handleSecuredPeer(Ssl::PeerConnectorAnswer &answer)
+{
+    Must(securer != NULL);
+    securer = NULL;
+
+    if (closer != NULL) {
+        if (answer.conn != NULL)
+            comm_remove_close_handler(answer.conn->fd, closer);
+        else
+            closer->cancel("securing completed");
+        closer = NULL;
+    }
+
+    if (!validPeer()) {
+        debugs(48, 3, "peer gone");
+        if (answer.conn != NULL)
+            answer.conn->close();
+        return;
+    }
+
+    if (answer.error.get()) {
+        if (answer.conn != NULL)
+            answer.conn->close();
+        // PeerConnector calls peerConnectFailed() for us;
+        checkpoint("conn securing failure"); // may retry
+        return;
+    }
+
+    pushNewConnection(answer.conn);
+}
+
+void
+PeerPoolMgr::handleSecureClosure(const CommCloseCbParams &params)
+{
+    Must(closer != NULL);
+    Must(securer != NULL);
+    securer->cancel("conn closed by a 3rd party");
+    securer = NULL;
+    closer = NULL;
+    // allow the closing connection to fully close before we check again
+    Checkpoint(this, "conn closure while securing");
+}
+#endif
+
+void
+PeerPoolMgr::openNewConnection()
+{
+    // KISS: Do nothing else when we are already doing something.
+    if (opener != NULL || securer != NULL || shutting_down) {
+        debugs(48, 7, "busy: " << opener << '|' << securer << '|' << shutting_down);
+        return; // there will be another checkpoint when we are done opening/securing
+    }
+
+    // Do not talk to a peer until it is ready.
+    if (!neighborUp(peer)) // provides debugging
+        return; // there will be another checkpoint when peer is up
+
+    // Do not violate peer limits.
+    if (!peerCanOpenMore(peer)) { // provides debugging
+        peer->standby.waitingForClose = true; // may already be true
+        return; // there will be another checkpoint when a peer conn closes
+    }
+
+    // Do not violate global restrictions.
+    if (fdUsageHigh()) {
+        debugs(48, 7, "overwhelmed");
+        peer->standby.waitingForClose = true; // may already be true
+        // There will be another checkpoint when a peer conn closes OR when
+        // a future pop() fails due to an empty pool. See PconnPool::pop().
+        return;
+    }
+
+    peer->standby.waitingForClose = false;
+
+    Comm::ConnectionPointer conn = new Comm::Connection;
+    Must(peer->n_addresses); // guaranteed by neighborUp() above
+    // cycle through all available IP addresses
+    conn->remote = peer->addresses[addrUsed++ % peer->n_addresses];
+    conn->remote.port(peer->http_port);
+    conn->peerType = STANDBY_POOL; // should be reset by peerSelect()
+    conn->setPeer(peer);
+    getOutgoingAddress(request.getRaw(), conn);
+    GetMarkingsToServer(request.getRaw(), *conn);
+
+    const int ctimeout = peer->connect_timeout > 0 ?
+                         peer->connect_timeout : Config.Timeout.peer_connect;
+    typedef CommCbMemFunT<PeerPoolMgr, CommConnectCbParams> Dialer;
+    opener = JobCallback(48, 5, Dialer, this, PeerPoolMgr::handleOpenedConnection);
+    Comm::ConnOpener *cs = new Comm::ConnOpener(conn, opener, ctimeout);
+    AsyncJob::Start(cs);
+}
+
+void
+PeerPoolMgr::closeOldConnections(const int howMany)
+{
+    debugs(48, 8, howMany);
+    peer->standby.pool->closeN(howMany);
+}
+
+void
+PeerPoolMgr::checkpoint(const char *reason)
+{
+    if (!validPeer()) {
+        debugs(48, 3, reason << " and peer gone");
+        return; // nothing to do after our owner dies; the job will quit
+    }
+
+    const int count = peer->standby.pool->count();
+    const int limit = peer->standby.limit;
+    debugs(48, 7, reason << " with " << count << " ? " << limit);
+
+    if (count < limit)
+        openNewConnection();
+    else if (count > limit)
+        closeOldConnections(count - limit);
+}
+
+void
+PeerPoolMgr::Checkpoint(const Pointer &mgr, const char *reason)
+{
+    CallJobHere1(48, 5, mgr, PeerPoolMgr, checkpoint, reason);
+}
+
+/// launches PeerPoolMgrs for peers configured with standby.limit
+class PeerPoolMgrsRr: public RegisteredRunner
+{
+public:
+    /* RegisteredRunner API */
+    virtual void useConfig() { syncConfig(); }
+    virtual void syncConfig();
+};
+
+RunnerRegistrationEntry(PeerPoolMgrsRr);
+
+void
+PeerPoolMgrsRr::syncConfig()
+{
+    for (CachePeer *p = Config.peers; p; p = p->next) {
+        // On reconfigure, Squid deletes the old config (and old peers in it),
+        // so should always be dealing with a brand new configuration.
+        assert(!p->standby.mgr);
+        assert(!p->standby.pool);
+        if (p->standby.limit) {
+            p->standby.mgr = new PeerPoolMgr(p);
+            p->standby.pool = new PconnPool(p->name, p->standby.mgr);
+            AsyncJob::Start(p->standby.mgr.get());
+        }
+    }
+}
@@ -0,0 +1,69 @@
+#ifndef SQUID_PEERPOOLMGR_H
+#define SQUID_PEERPOOLMGR_H
+
+#include "base/AsyncJob.h"
+#include "comm/forward.h"
+
+class HttpRequest;
+class CachePeer;
+class CommConnectCbParams;
+
+#if USE_OPENSSL
+namespace Ssl
+{
+class PeerConnectorAnswer;
+}
+#endif
+
+/// Maintains an fixed-size "standby" PconnPool for a single CachePeer.
+class PeerPoolMgr: public AsyncJob
+{
+public:
+    typedef CbcPointer<PeerPoolMgr> Pointer;
+
+    // syncs mgr state whenever connection-related peer or pool state changes
+    static void Checkpoint(const Pointer &mgr, const char *reason);
+
+    explicit PeerPoolMgr(CachePeer *aPeer);
+    virtual ~PeerPoolMgr();
+
+protected:
+    /* AsyncJob API */
+    virtual void start();
+    virtual void swanSong();
+    virtual bool doneAll() const;
+
+    /// whether the peer is still out there and in a valid state we can safely use
+    bool validPeer() const;
+
+    /// Starts new connection, or closes the excess connections
+    /// according pool configuration
+    void checkpoint(const char *reason);
+    /// starts the process of opening a new standby connection (if possible)
+    void openNewConnection();
+    /// closes 'howMany' standby connections
+    void closeOldConnections(const int howMany);
+
+    /// Comm::ConnOpener calls this when done opening a connection for us
+    void handleOpenedConnection(const CommConnectCbParams &params);
+#if USE_OPENSSL
+    /// Ssl::PeerConnector callback
+    void handleSecuredPeer(Ssl::PeerConnectorAnswer &answer);
+    /// called when the connection we are trying to secure is closed by a 3rd party
+    void handleSecureClosure(const CommCloseCbParams &params);
+#endif
+    /// the final step in connection opening (and, optionally, securing) sequence
+    void pushNewConnection(const Comm::ConnectionPointer &conn);
+
+private:
+    CachePeer *peer; ///< the owner of the pool we manage
+    RefCount<HttpRequest> request; ///< fake HTTP request for conn opening code
+    AsyncCall::Pointer opener; ///< whether we are opening a connection
+    AsyncCall::Pointer securer; ///< whether we are securing a connection
+    AsyncCall::Pointer closer; ///< monitors conn while we are securing it
+    unsigned int addrUsed; ///< counter for cycling through peer addresses
+
+    CBDATA_CLASS2(PeerPoolMgr);
+};
+
+#endif /* SQUID_PEERPOOLMGR_H */
@@ -377,12 +377,12 @@ memcasecmp(const char *b1, const char *b2, SBuf::size_type len)
 }
 
 int
-SBuf::compare(const SBuf &S, SBufCaseSensitive isCaseSensitive, size_type n) const
+SBuf::compare(const SBuf &S, const SBufCaseSensitive isCaseSensitive, const size_type n) const
 {
     if (n != npos)
         return substr(0,n).compare(S.substr(0,n),isCaseSensitive);
 
-    size_type byteCompareLen = min(S.length(), length());
+    const size_type byteCompareLen = min(S.length(), length());
     ++stats.compareSlow;
     int rv = 0;
     if (isCaseSensitive == caseSensitive) {
@@ -399,8 +399,61 @@ SBuf::compare(const SBuf &S, SBufCaseSensitive isCaseSensitive, size_type n) con
     return -1;
 }
 
+int
+SBuf::compare(const char *s, const SBufCaseSensitive isCaseSensitive, const size_type n) const
+{
+    // 0-length comparison is always true regardless of buffer states
+    if (!n) {
+        ++stats.compareFast;
+        return 0;
+    }
+
+    // N-length compare MUST provide a non-NULL C-string pointer
+    assert(s);
+
+    // when this is a 0-length string, no need for any complexity.
+    if (!length()) {
+        ++stats.compareFast;
+        return '\0' - *s;
+    }
+
+    // brute-force scan in order to avoid ever needing strlen() on a c-string.
+    ++stats.compareSlow;
+    const char *left = buf();
+    const char *right = s;
+    int rv = 0;
+    // what area to scan.
+    // n may be npos, but we treat that as a huge positive value
+    size_type byteCount = min(length(), n);
+
+    // loop until we find a difference, a '\0', or reach the end of area to scan
+    if (isCaseSensitive == caseSensitive) {
+        while ((rv = *left - *right++) == 0) {
+            if (*left++ == '\0' || --byteCount == 0)
+                break;
+        }
+    } else {
+        while ((rv = tolower(*left) - tolower(*right++)) == 0) {
+            if (*left++ == '\0' || --byteCount == 0)
+                break;
+        }
+    }
+
+    // If we stopped scanning because we reached the end
+    //  of buf() before we reached the end of s,
+    // pretend we have a 0-terminator there to compare.
+    // NP: the loop already incremented "right" ready for this comparison
+    if (!byteCount && length() < n)
+        return '\0' - *right;
+
+    // If we found a difference within the scan area,
+    // or we found a '\0',
+    // or all n characters were identical (and none was \0).
+    return rv;
+}
+
 bool
-SBuf::startsWith(const SBuf &S, SBufCaseSensitive isCaseSensitive) const
+SBuf::startsWith(const SBuf &S, const SBufCaseSensitive isCaseSensitive) const
 {
     debugs(24, 8, id << " startsWith " << S.id << ", caseSensitive: " <<
            isCaseSensitive);
@@ -445,6 +498,7 @@ SBuf::consume(size_type n)
         n = length();
     else
         n = min(n, length());
+    debugs(24, 8, "consume " << n);
     SBuf rv(substr(0, n));
     chop(n);
     return rv;
@@ -255,15 +255,28 @@ class SBuf
      * \retval <0 argument of the call is smaller than called SBuf
      * \retval 0  argument of the call has the same contents of called SBuf
      */
-    int compare(const SBuf &S, SBufCaseSensitive isCaseSensitive, size_type n = npos) const;
+    int compare(const SBuf &S, const SBufCaseSensitive isCaseSensitive, const size_type n = npos) const;
 
-    /// shorthand version for compare
-    inline int cmp(const SBuf &S, size_type n = npos) const {
+    /// shorthand version for compare()
+    inline int cmp(const SBuf &S, const size_type n = npos) const {
         return compare(S,caseSensitive,n);
     }
 
-    /// shorthand version for case-insensitive comparison
-    inline int caseCmp(const SBuf &S, size_type n = npos) const {
+    /// shorthand version for case-insensitive compare()
+    inline int caseCmp(const SBuf &S, const size_type n = npos) const {
+        return compare(S,caseInsensitive,n);
+    }
+
+    /// Comparison with a C-string.
+    int compare(const char *s, const SBufCaseSensitive isCaseSensitive, const size_type n = npos) const;
+
+    /// Shorthand version for C-string compare().
+    inline int cmp(const char *S, const size_type n = npos) const {
+        return compare(S,caseSensitive,n);
+    }
+
+    /// Shorthand version for case-insensitive C-string compare().
+    inline int caseCmp(const char *S, const size_type n = npos) const {
         return compare(S,caseInsensitive,n);
     }
 
@@ -272,7 +285,7 @@ class SBuf
      *  \param isCaseSensitive one of caseSensitive or caseInsensitive
      *  \retval true argument is a prefix of the SBuf
      */
-    bool startsWith(const SBuf &S, SBufCaseSensitive isCaseSensitive = caseSensitive) const;
+    bool startsWith(const SBuf &S, const SBufCaseSensitive isCaseSensitive = caseSensitive) const;
 
     bool operator ==(const SBuf & S) const;
     bool operator !=(const SBuf & S) const;
@@ -517,7 +517,7 @@ ServerStateData::maybePurgeOthers()
 
     // XXX: should we use originalRequest() here?
     const char *reqUrl = urlCanonical(request);
-    debugs(88, 5, "maybe purging due to " << RequestMethodStr(request->method) << ' ' << reqUrl);
+    debugs(88, 5, "maybe purging due to " << request->method << ' ' << reqUrl);
     purgeEntriesByUrl(request, reqUrl);
     purgeEntriesByHeader(request, reqUrl, theFinalReply, HDR_LOCATION);
     purgeEntriesByHeader(request, reqUrl, theFinalReply, HDR_CONTENT_LOCATION);
@@ -45,8 +45,16 @@ class URL
     MEMPROXY_CLASS(URL);
     URL() : scheme_() {}
     URL(AnyP::UriScheme const &aScheme) : scheme_(aScheme) {}
+
+    void clear() {
+        scheme_=AnyP::PROTO_NONE;
+    }
+
     AnyP::UriScheme const & getScheme() const {return scheme_;}
 
+    /// convert the URL scheme to that given
+    void setScheme(const AnyP::ProtocolType &p) {scheme_=p;}
+
 private:
     /**
      \par
@@ -68,7 +76,7 @@ class URL
      * In order to make taking any of these routes easy, scheme is private
      * and immutable, only settable at construction time,
      */
-    AnyP::UriScheme const scheme_;
+    AnyP::UriScheme scheme_;
 };
 
 MEMPROXY_CLASS_INLINE(URL);
@@ -111,7 +111,6 @@ acl_ip_data::toSBuf() const
     return SBuf(tmpbuf);
 }
 
-
 /*
  * aclIpAddrNetworkCompare - The guts of the comparison for IP ACLs
  * matching checks.  The first argument (p) is a "host" address,
@@ -74,7 +74,7 @@ ACLMethodData::dump() const
     CbDataList<HttpRequestMethod> *data = values;
 
     while (data != NULL) {
-        sl.push_back(SBuf(RequestMethodStr(data->element)));
+        sl.push_back(data->element.image());
         data = data->next;
     }
 
@@ -89,9 +89,9 @@ ACLMethodData::parse()
 
     for (Tail = &values; *Tail; Tail = &((*Tail)->next));
     while ((t = strtokFile())) {
-        if (strcmp(t, "PURGE") == 0)
-            ++ThePurgeCount; // configuration code wants to know
         CbDataList<HttpRequestMethod> *q = new CbDataList<HttpRequestMethod> (HttpRequestMethod(t, NULL));
+        if (q->element == Http::METHOD_PURGE)
+            ++ThePurgeCount; // configuration code wants to know
         *(Tail) = q;
         Tail = &q->next;
     }
@@ -42,9 +42,9 @@
 template class ACLStrategised<AnyP::ProtocolType>;
 
 int
-ACLProtocolStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+ACLProtocolStrategy::match(ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
-    return data->match (checklist->request->protocol);
+    return data->match(checklist->request->url.getScheme());
 }
 
 ACLProtocolStrategy *
@@ -51,8 +51,8 @@ Adaptation::AccessRule::group()
 Adaptation::AccessRules &
 Adaptation::AllRules()
 {
-    static AccessRules TheRules;
-    return TheRules;
+    static AccessRules *TheRules = new AccessRules;
+    return *TheRules;
 }
 
 // TODO: make AccessRules::find work
@@ -54,8 +54,8 @@ Adaptation::Service::wants(const ServiceFilter &filter) const
 Adaptation::Services &
 Adaptation::AllServices()
 {
-    static Services TheServices;
-    return TheServices;
+    static Services *TheServices = new Services;
+    return *TheServices;
 }
 
 Adaptation::ServicePointer
@@ -315,8 +315,8 @@ Adaptation::ServicePlan::print(std::ostream &os) const
 Adaptation::Groups &
 Adaptation::AllGroups()
 {
-    static Groups TheGroups;
-    return TheGroups;
+    static Groups *TheGroups = new Groups;
+    return *TheGroups;
 }
 
 Adaptation::ServiceGroupPointer
@@ -45,7 +45,6 @@ Adaptation::Ecap::Host::Host()
     libecap::protocolWais.assignHostId(AnyP::PROTO_WAIS);
     libecap::protocolUrn.assignHostId(AnyP::PROTO_URN);
     libecap::protocolWhois.assignHostId(AnyP::PROTO_WHOIS);
-    protocolInternal.assignHostId(AnyP::PROTO_INTERNAL);
     protocolCacheObj.assignHostId(AnyP::PROTO_CACHE_OBJECT);
     protocolIcp.assignHostId(AnyP::PROTO_ICP);
 #if USE_HTCP
@@ -135,7 +135,7 @@ libecap::Name
 Adaptation::Ecap::FirstLineRep::protocol() const
 {
     // TODO: optimize?
-    switch (theMessage.protocol) {
+    switch (theMessage.http_ver.protocol) {
     case AnyP::PROTO_HTTP:
         return libecap::protocolHttp;
     case AnyP::PROTO_HTTPS:
@@ -158,8 +158,6 @@ Adaptation::Ecap::FirstLineRep::protocol() const
 #endif
     case AnyP::PROTO_CACHE_OBJECT:
         return protocolCacheObj;
-    case AnyP::PROTO_INTERNAL:
-        return protocolInternal;
     case AnyP::PROTO_ICY:
         return protocolIcy;
     case AnyP::PROTO_COAP:
@@ -181,7 +179,7 @@ void
 Adaptation::Ecap::FirstLineRep::protocol(const Name &p)
 {
     // TODO: what happens if we fail to translate some protocol?
-    theMessage.protocol = TranslateProtocolId(p);
+    theMessage.http_ver.protocol = TranslateProtocolId(p);
 }
 
 AnyP::ProtocolType
@@ -254,7 +252,7 @@ Adaptation::Ecap::RequestLineRep::method() const
     case Http::METHOD_TRACE:
         return libecap::methodTrace;
     default:
-        return Name(theMessage.method.image());
+        return Name(theMessage.method.image().toStdString());
     }
 }
 
@@ -147,7 +147,7 @@ void Adaptation::Icap::ServiceRep::putConnection(const Comm::ConnectionPointer &
 void Adaptation::Icap::ServiceRep::noteConnectionUse(const Comm::ConnectionPointer &conn)
 {
     Must(Comm::IsConnOpen(conn));
-    fd_table[conn->fd].noteUse(NULL); // pconn re-use but not via PconnPool API
+    fd_table[conn->fd].noteUse(); // pconn re-use, albeit not via PconnPool API
 }
 
 void Adaptation::Icap::ServiceRep::noteConnectionFailed(const char *comment)
@@ -27,7 +27,6 @@ typedef enum {
 #endif
     PROTO_URN,
     PROTO_WHOIS,
-    PROTO_INTERNAL,
     PROTO_ICY,
     PROTO_UNKNOWN,
     PROTO_MAX
@@ -59,7 +59,6 @@ Auth::User::User(Auth::Config *aConfig, const char *aRequestRealm) :
         username_(NULL),
         requestRealm_(aRequestRealm)
 {
-    proxy_auth_list.head = proxy_auth_list.tail = NULL;
     proxy_match_cache.head = proxy_match_cache.tail = NULL;
     ip_list.head = ip_list.tail = NULL;
     debugs(29, 5, HERE << "Initialised auth_user '" << this << "'.");
@@ -91,7 +90,6 @@ Auth::User::absorb(Auth::User::Pointer from)
 {
     /*
      * XXX Incomplete: it should merge in hash references too and ask the module to merge in scheme data
-     *  dlink_list proxy_auth_list;
      *  dlink_list proxy_match_cache;
      */
 
@@ -71,8 +71,6 @@ class User : public RefCountable
     Auth::Type auth_type;
     /** the config for this user */
     Auth::Config *config;
-    /** we may have many proxy-authenticate strings that decode to the same user */
-    dlink_list proxy_auth_list;
     dlink_list proxy_match_cache;
     size_t ipcount;
     long expiretime;
@@ -65,8 +65,8 @@ Auth::UserRequest::start(HttpRequest *request, AccessLogEntry::Pointer &al, AUTH
 {
     assert(handler);
     assert(data);
-    debugs(29, 9, HERE << "auth_user_request '" << this << "'");
-    module_start(request, al, handler, data);
+    debugs(29, 9, this);
+    startHelperLookup(request, al, handler, data);
 }
 
 bool
@@ -158,15 +158,6 @@ class UserRequest : public RefCountable
 
     virtual void releaseAuthServer();
 
-    /**
-     * Called when squid is ready to put the request on hold and wait for a callback from the auth module
-     * when the auth module has performed it's external activities.
-     *
-     * \param handler	Handler to process the callback when its run
-     * \param data	CBDATA for handler
-     */
-    virtual void module_start(HttpRequest *request, AccessLogEntry::Pointer &al, AUTHCB *handler, void *data) = 0;
-
     // User credentials object this UserRequest is managing
     virtual User::Pointer user() {return _auth_user;}
     virtual const User::Pointer user() const {return _auth_user;}
@@ -195,7 +186,18 @@ class UserRequest : public RefCountable
     /// Add the appropriate [Proxy-]Authenticate header to the given reply
     static void addReplyAuthHeader(HttpReply * rep, UserRequest::Pointer auth_user_request, HttpRequest * request, int accelerated, int internal);
 
+    /** Start an asynchronous helper lookup to verify the user credentials
+     *
+     * Uses startHelperLookup() for scheme-specific actions.
+     *
+     * The given callback will be called when the auth module has performed
+     * it's external activities.
+     *
+     * \param handler	Handler to process the callback when its run
+     * \param data	CBDATA for handler
+     */
     void start(HttpRequest *request, AccessLogEntry::Pointer &al, AUTHCB *handler, void *data);
+
     char const * denyMessage(char const * const default_message = NULL);
 
     /** Possibly overrideable in future */
@@ -224,6 +226,15 @@ class UserRequest : public RefCountable
     virtual const char *credentialsStr() = 0;
 
     const char *helperRequestKeyExtras(HttpRequest *, AccessLogEntry::Pointer &al);
+
+protected:
+    /**
+     * The scheme-specific actions to be performed when sending helper lookup.
+     *
+     * \see void start(HttpRequest *, AccessLogEntry::Pointer &, AUTHCB *, void *);
+     */
+    virtual void startHelperLookup(HttpRequest *request, AccessLogEntry::Pointer &al, AUTHCB *handler, void *data) = 0;
+
 private:
 
     static AuthAclState authenticate(UserRequest::Pointer * auth_user_request, http_hdr_type headertype, HttpRequest * request, ConnStateData * conn, Ip::Address &src_addr, AccessLogEntry::Pointer &al);
@@ -93,7 +93,7 @@ Auth::Basic::UserRequest::module_direction()
 
 /* send the initial data to a basic authenticator module */
 void
-Auth::Basic::UserRequest::module_start(HttpRequest *request, AccessLogEntry::Pointer &al, AUTHCB * handler, void *data)
+Auth::Basic::UserRequest::startHelperLookup(HttpRequest *request, AccessLogEntry::Pointer &al, AUTHCB * handler, void *data)
 {
     assert(user()->auth_type == Auth::AUTH_BASIC);
     Auth::Basic::User *basic_auth = dynamic_cast<Auth::Basic::User *>(user().getRaw());
@@ -26,7 +26,7 @@ class UserRequest : public Auth::UserRequest
     virtual int authenticated() const;
     virtual void authenticate(HttpRequest * request, ConnStateData *conn, http_hdr_type type);
     virtual Auth::Direction module_direction();
-    virtual void module_start(HttpRequest * request, AccessLogEntry::Pointer &al, AUTHCB *, void *);
+    virtual void startHelperLookup(HttpRequest * request, AccessLogEntry::Pointer &al, AUTHCB *, void *);
     virtual const char *credentialsStr();
 
 private:
@@ -102,9 +102,10 @@ Auth::Digest::UserRequest::authenticate(HttpRequest * request, ConnStateData * c
                   authenticateDigestNonceNonceb64(digest_request->nonce),
                   digest_request->cnonce,
                   digest_user->HA1, SESSIONKEY);
+    SBuf sTmp = request->method.image();
     DigestCalcResponse(SESSIONKEY, authenticateDigestNonceNonceb64(digest_request->nonce),
                        digest_request->nc, digest_request->cnonce, digest_request->qop,
-                       RequestMethodStr(request->method), digest_request->uri, HA2, Response);
+                       sTmp.c_str(), digest_request->uri, HA2, Response);
 
     debugs(29, 9, "\nResponse = '" << digest_request->response << "'\nsquid is = '" << Response << "'");
 
@@ -123,9 +124,10 @@ Auth::Digest::UserRequest::authenticate(HttpRequest * request, ConnStateData * c
              * widespread and such broken browsers no longer are commonly
              * used.
              */
+            sTmp = HttpRequestMethod(Http::METHOD_GET).image();
             DigestCalcResponse(SESSIONKEY, authenticateDigestNonceNonceb64(digest_request->nonce),
                                digest_request->nc, digest_request->cnonce, digest_request->qop,
-                               RequestMethodStr(Http::METHOD_GET), digest_request->uri, HA2, Response);
+                               sTmp.c_str(), digest_request->uri, HA2, Response);
 
             if (strcasecmp(digest_request->response, Response)) {
                 auth_user->credentials(Auth::Failed);
@@ -270,7 +272,7 @@ Auth::Digest::UserRequest::addAuthenticationInfoTrailer(HttpReply * rep, int acc
 
 /* send the initial data to a digest authenticator module */
 void
-Auth::Digest::UserRequest::module_start(HttpRequest *request, AccessLogEntry::Pointer &al, AUTHCB * handler, void *data)
+Auth::Digest::UserRequest::startHelperLookup(HttpRequest *request, AccessLogEntry::Pointer &al, AUTHCB * handler, void *data)
 {
     char buf[8192];
 
@@ -34,7 +34,7 @@ class UserRequest : public Auth::UserRequest
     virtual void addAuthenticationInfoTrailer(HttpReply * rep, int accel);
 #endif
 
-    virtual void module_start(HttpRequest *request, AccessLogEntry::Pointer &al, AUTHCB *, void *);
+    virtual void startHelperLookup(HttpRequest *request, AccessLogEntry::Pointer &al, AUTHCB *, void *);
     virtual const char *credentialsStr();
 
     char *nonceb64;             /* "dcd98b7102dd2f0e8b11d0f600bfb0c093" */
@@ -6,7 +6,6 @@
 Auth::Negotiate::User::User(Auth::Config *aConfig, const char *aRequestRealm) :
         Auth::User(aConfig, aRequestRealm)
 {
-    proxy_auth_list.head = proxy_auth_list.tail = NULL;
 }
 
 Auth::Negotiate::User::~User()
@@ -97,7 +97,7 @@ Auth::Negotiate::UserRequest::module_direction()
 }
 
 void
-Auth::Negotiate::UserRequest::module_start(HttpRequest *req, AccessLogEntry::Pointer &al, AUTHCB * handler, void *data)
+Auth::Negotiate::UserRequest::startHelperLookup(HttpRequest *req, AccessLogEntry::Pointer &al, AUTHCB * handler, void *data)
 {
     static char buf[MAX_AUTHTOKEN_LEN];
 
@@ -26,7 +26,7 @@ class UserRequest : public Auth::UserRequest
     virtual int authenticated() const;
     virtual void authenticate(HttpRequest * request, ConnStateData * conn, http_hdr_type type);
     virtual Direction module_direction();
-    virtual void module_start(HttpRequest *request, AccessLogEntry::Pointer &al, AUTHCB *, void *);
+    virtual void startHelperLookup(HttpRequest *request, AccessLogEntry::Pointer &al, AUTHCB *, void *);
     virtual const char *credentialsStr();
 
     virtual void addAuthenticationInfoHeader(HttpReply * rep, int accel);
@@ -6,7 +6,6 @@
 Auth::Ntlm::User::User(Auth::Config *aConfig, const char *aRequestRealm) :
         Auth::User(aConfig, aRequestRealm)
 {
-    proxy_auth_list.head = proxy_auth_list.tail = NULL;
 }
 
 Auth::Ntlm::User::~User()
@@ -95,7 +95,7 @@ Auth::Ntlm::UserRequest::module_direction()
 }
 
 void
-Auth::Ntlm::UserRequest::module_start(HttpRequest *req, AccessLogEntry::Pointer &al, AUTHCB * handler, void *data)
+Auth::Ntlm::UserRequest::startHelperLookup(HttpRequest *req, AccessLogEntry::Pointer &al, AUTHCB * handler, void *data)
 {
     static char buf[MAX_AUTHTOKEN_LEN];
 
@@ -26,7 +26,7 @@ class UserRequest : public Auth::UserRequest
     virtual int authenticated() const;
     virtual void authenticate(HttpRequest * request, ConnStateData * conn, http_hdr_type type);
     virtual Auth::Direction module_direction();
-    virtual void module_start(HttpRequest *req, AccessLogEntry::Pointer &al, AUTHCB *, void *);
+    virtual void startHelperLookup(HttpRequest *req, AccessLogEntry::Pointer &al, AUTHCB *, void *);
     virtual const char *credentialsStr();
 
     virtual const char * connLastHeader();
@@ -135,7 +135,7 @@ Cbc &
 CbcPointer<Cbc>::operator *() const
 {
     Cbc *c = get();
-    Must(c);
+    assert(c);
     return *c;
 }
 
@@ -144,7 +144,7 @@ Cbc *
 CbcPointer<Cbc>::operator ->() const
 {
     Cbc *c = get();
-    Must(c);
+    assert(c);
     return c;
 }
 
@@ -60,7 +60,7 @@ class RegisteredRunner
     /// Meant for cleanup and state saving that may require other modules.
     virtual void startShutdown() {}
 
-    /// Called after stopping the main loop.
+    /// Called after stopping the main loop and before releasing memory.
     /// Meant for quick/basic cleanup that does not require any other modules.
     virtual ~RegisteredRunner() {}
     /// exists to simplify caller interface; override the destructor instead
@@ -69,7 +69,9 @@
 #include "neighbors.h"
 #include "NeighborTypeDomainList.h"
 #include "Parsing.h"
+#include "pconn.h"
 #include "PeerDigest.h"
+#include "PeerPoolMgr.h"
 #include "RefreshPattern.h"
 #include "rfc1738.h"
 #include "SBufList.h"
@@ -723,6 +725,7 @@ configDoConfigure(void)
 #endif
 
     storeConfigure();
+    update_maxobjsize(); // check for late maximum_object_size directive
 
     snprintf(ThisCache, sizeof(ThisCache), "%s (%s)",
              uniqueHostname(),
@@ -2266,6 +2269,8 @@ parse_peer(CachePeer ** head)
             p->options.allow_miss = true;
         } else if (!strncmp(token, "max-conn=", 9)) {
             p->max_conn = xatoi(token + 9);
+        } else if (!strncmp(token, "standby=", 8)) {
+            p->standby.limit = xatoi(token + 8);
         } else if (!strcmp(token, "originserver")) {
             p->options.originserver = true;
         } else if (!strncmp(token, "name=", 5)) {
@@ -2339,6 +2344,9 @@ parse_peer(CachePeer ** head)
     if (peerFindByName(p->name))
         fatalf("ERROR: cache_peer %s specified twice\n", p->name);
 
+    if (p->max_conn > 0 && p->max_conn < p->standby.limit)
+        fatalf("ERROR: cache_peer %s max-conn=%d is lower than its standby=%d\n", p->host, p->max_conn, p->standby.limit);
+
     if (p->weight < 1)
         p->weight = 1;
 
@@ -2383,6 +2391,9 @@ free_peer(CachePeer ** P)
         cbdataReferenceDone(p->digest);
 #endif
 
+        // the mgr job will notice that its owner is gone and stop
+        PeerPoolMgr::Checkpoint(p->standby.mgr, "peer gone");
+        delete p->standby.pool;
         cbdataFree(p);
     }
 
@@ -4829,7 +4840,7 @@ static void parse_ftp_epsv(acl_access **ftp_epsv)
     bool ftpEpsvIsDeprecatedRule = false;
 
     char *t = ConfigParser::PeekAtToken();
-    if (!t){
+    if (!t) {
         self_destruct();
         return;
     }
@@ -4849,7 +4860,7 @@ static void parse_ftp_epsv(acl_access **ftp_epsv)
     //   2) if this line is "ftp_epsv on|off" and already exist rules of "ftp_epsv allow|deny ..."
     // then abort
     if ((!ftpEpsvIsDeprecatedRule && FtpEspvDeprecated) ||
-        (ftpEpsvIsDeprecatedRule && !FtpEspvDeprecated && *ftp_epsv != NULL)) {
+            (ftpEpsvIsDeprecatedRule && !FtpEspvDeprecated && *ftp_epsv != NULL)) {
         debugs(3, DBG_CRITICAL, "FATAL: do not mix \"ftp_epsv on|off\" cfg lines with \"ftp_epsv allow|deny ...\" cfg lines. Update your ftp_epsv rules.");
         self_destruct();
     }
@@ -59,18 +59,6 @@ typedef struct _CacheEntry {
     unsigned char key_arr[SQUID_MD5_DIGEST_LENGTH];
 } CacheEntry;
 
-/* copied from url.c */
-const char *RequestMethodStr[] = {
-    "NONE",
-    "GET",
-    "POST",
-    "PUT",
-    "HEAD",
-    "CONNECT",
-    "TRACE",
-    "PURGE"
-};
-
 static int cacheIndexScan(CacheIndex * idx, const char *fname, FILE * file);
 
 static CacheEntry *
@@ -185,16 +185,14 @@ carpSelectParent(HttpRequest * request)
 
     /* select CachePeer */
     for (k = 0; k < n_carp_peers; ++k) {
-        String key;
+        SBuf key;
         tp = carp_peers[k];
         if (tp->options.carp_key.set) {
             //this code follows urlCanonical's pattern.
             //   corner cases should use the canonical URL
             if (tp->options.carp_key.scheme) {
-                // temporary, until bug 1961 URL handling is fixed.
-                const AnyP::UriScheme sch(request->protocol);
-                key.append(sch.c_str());
-                if (key.size()) //if the scheme is not empty
+                key.append(request->url.getScheme().c_str());
+                if (key.length()) //if the scheme is not empty
                     key.append("://");
             }
             if (tp->options.carp_key.host) {
@@ -208,24 +206,24 @@ carpSelectParent(HttpRequest * request)
             if (tp->options.carp_key.path) {
                 String::size_type pos;
                 if ((pos=request->urlpath.find('?'))!=String::npos)
-                    key.append(request->urlpath.substr(0,pos));
+                    key.append(SBuf(request->urlpath.substr(0,pos)));
                 else
-                    key.append(request->urlpath);
+                    key.append(SBuf(request->urlpath));
             }
             if (tp->options.carp_key.params) {
                 String::size_type pos;
                 if ((pos=request->urlpath.find('?'))!=String::npos)
-                    key.append(request->urlpath.substr(pos,request->urlpath.size()));
+                    key.append(SBuf(request->urlpath.substr(pos,request->urlpath.size())));
             }
         }
         // if the url-based key is empty, e.g. because the user is
         // asking to balance on the path but the request doesn't supply any,
         // then fall back to canonical URL
 
-        if (key.size()==0)
-            key=urlCanonical(request);
+        if (key.isEmpty())
+            key=SBuf(urlCanonical(request));
 
-        for (const char *c = key.rawBuf(), *e=key.rawBuf()+key.size(); c < e; ++c)
+        for (const char *c = key.rawContent(), *e=key.rawContent()+key.length(); c < e; ++c)
             user_hash += ROTATE_LEFT(user_hash, 19) + *c;
         combined_hash = (user_hash ^ tp->carp.hash);
         combined_hash += combined_hash * 0x62531965;
@@ -48,9 +48,9 @@
 
 #include "squid.h"
 #include "cbdata.h"
+#include "Generic.h"
 #include "mgr/Registration.h"
 #include "Store.h"
-#include "Generic.h"
 
 #include <climits>
 #if USE_CBDATA_DEBUG
@@ -64,6 +64,17 @@ COMMENT_START
   from causing Squid entering an infinite loop whilst trying to load
   configuration files.
 
+  Values with byte units
+
+	Squid accepts size units on some size related directives. All
+	such directives are documented with a default value displaying
+	a unit.
+
+	Units accepted by Squid are:
+		bytes - byte
+		KB - Kilobyte (1024 bytes)
+		MB - Megabyte
+		GB - Gigabyte
 
   Values with spaces, quotes, and other special characters
 
@@ -349,8 +360,8 @@ DOC_START
 
 	"program" cmdline
 	Specify the command for the external authenticator.  Such a program
-	reads a request_format line ("username password" by default) and
-	replies with one of three results:
+	reads a request line ("username password" by default) and replies
+	with one of three results:
 
 	  OK
 		the user exists.
@@ -718,7 +729,7 @@ DOC_START
 	  %SRCPORT	Client source port
 	  %URI		Requested URI
 	  %DST		Requested host
-	  %PROTO	Requested protocol
+	  %PROTO	Requested URL scheme
 	  %PORT		Requested port
 	  %PATH		Requested URL path
 	  %METHOD	Request method
@@ -3089,7 +3100,8 @@ DOC_START
 	
 	connect-fail-limit=N
 			How many times connecting to a peer must fail before
-			it is marked as down. Default is 10.
+			it is marked as down. Standby connection failures
+			count towards this limit. Default is 10.
 	
 	allow-miss	Disable Squid's use of only-if-cached when forwarding
 			requests to siblings. This is primarily useful when
@@ -3099,8 +3111,50 @@ DOC_START
 			For example to deny peer usage on requests from peer
 			by denying cache_peer_access if the source is a peer.
 	
-	max-conn=N	Limit the amount of connections Squid may open to this
-			peer. see also 
+	max-conn=N 	Limit the number of concurrent connections the Squid
+			may open to this peer, including already opened idle
+			and standby connections. There is no peer-specific
+			connection limit by default.
+	
+			A peer exceeding the limit is not used for new
+			requests unless a standby connection is available.
+	
+			max-conn currently works poorly with idle persistent
+			connections: When a peer reaches its max-conn limit,
+			and there are idle persistent connections to the peer,
+			the peer may not be selected because the limiting code
+			does not know whether Squid can reuse those idle
+			connections.
+	
+	standby=N	Maintain a pool of N "hot standby" connections to an
+			UP peer, available for requests when no idle
+			persistent connection is available (or safe) to use.
+			By default and with zero N, no such pool is maintained.
+			N must not exceed the max-conn limit (if any).
+	
+			At start or after reconfiguration, Squid opens new TCP
+			standby connections until there are N connections
+			available and then replenishes the standby pool as
+			opened connections are used up for requests. A used
+			connection never goes back to the standby pool, but
+			may go to the regular idle persistent connection pool
+			shared by all peers and origin servers.
+	
+			Squid never opens multiple new standby connections
+			concurrently.  This one-at-a-time approach minimizes
+			flooding-like effect on peers. Furthermore, just a few
+			standby connections should be sufficient in most cases
+			to supply most new requests with a ready-to-use
+			connection.
+	
+			Standby connections obey server_idle_pconn_timeout.
+			For the feature to work as intended, the peer must be
+			configured to accept and keep them open longer than
+			the idle timeout at the connecting Squid, to minimize
+			race conditions typical to idle used persistent
+			connections. Default request_timeout and
+			server_idle_pconn_timeout values ensure such a
+			configuration.
 	
 	name=xxx	Unique name for the peer.
 			Required if you have multiple peers on the same host
@@ -3397,6 +3451,39 @@ DOC_START
 	and http://fog.hpl.external.hp.com/techreports/98/HPL-98-173.html.
 DOC_END
 
+NAME: minimum_object_size
+COMMENT: (bytes)
+TYPE: b_int64_t
+DEFAULT: 0 KB
+DEFAULT_DOC: no limit
+LOC: Config.Store.minObjectSize
+DOC_START
+	Objects smaller than this size will NOT be saved on disk.  The
+	value is specified in bytes, and the default is 0 KB, which
+	means all responses can be stored.
+DOC_END
+
+NAME: maximum_object_size
+COMMENT: (bytes)
+TYPE: b_int64_t
+DEFAULT: 4 MB
+LOC: Config.Store.maxObjectSize
+DOC_START
+	Set the default value for max-size parameter on any cache_dir.
+	The value is specified in bytes, and the default is 4 MB.
+	
+	If you wish to get a high BYTES hit ratio, you should probably
+	increase this (one 32 MB object hit counts for 3200 10KB
+	hits).
+	
+	If you wish to increase hit ratio more than you want to
+	save bandwidth you should leave this low.
+	
+	NOTE: if using the LFUDA replacement policy you should increase
+	this value to maximize the byte hit rate improvement of LFUDA!
+	See cache_replacement_policy for a discussion of this policy.
+DOC_END
+
 NAME: cache_dir
 TYPE: cachedir
 DEFAULT: none
@@ -3546,9 +3633,9 @@ DOC_START
 
 	max-size=n	the maximum object size in bytes this cache_dir
 			supports.
-			The value in maximum_object_size directive, sets
-			a default unless more specific details are available
-			about the cache_dir (ie a small store capacity).
+			The value in maximum_object_size directive sets
+			the default unless more specific details are
+			available (ie a small store capacity).
 
 	Note: To make optimal use of the max-size limits you should order
 	the cache_dir lines with the smallest max-size value first.
@@ -3621,40 +3708,6 @@ DOC_START
 	A value of 0 indicates no limit.
 DOC_END
 
-NAME: minimum_object_size
-COMMENT: (bytes)
-TYPE: b_int64_t
-DEFAULT: 0 KB
-DEFAULT_DOC: no limit
-LOC: Config.Store.minObjectSize
-DOC_START
-	Objects smaller than this size will NOT be saved on disk.  The
-	value is specified in bytes, and the default is 0 KB, which
-	means all responses can be stored.
-DOC_END
-
-NAME: maximum_object_size
-COMMENT: (bytes)
-TYPE: b_int64_t
-DEFAULT: 4 MB
-LOC: Config.Store.maxObjectSize
-DOC_START
-	The default limit on size of objects stored to disk.
-	This size is used for cache_dir where max-size is not set.
-	The value is specified in bytes, and the default is 4 MB.
-
-	If you wish to get a high BYTES hit ratio, you should probably
-	increase this (one 32 MB object hit counts for 3200 10KB
-	hits).
-
-	If you wish to increase hit ratio more than you want to
-	save bandwidth you should leave this low.
-
-	NOTE: if using the LFUDA replacement policy you should increase
-	this value to maximize the byte hit rate improvement of LFUDA!
-	See replacement_policy below for a discussion of this policy.
-DOC_END
-
 NAME: cache_swap_low
 COMMENT: (percent, 0-100)
 TYPE: int
@@ -3743,10 +3796,22 @@ DOC_START
 		err_code    The ID of an error response served by Squid or
 				a similar internal error identifier.
 		err_detail  Additional err_code-dependent error information.
-		note	The meta header specified by the argument. Also
+		note	The annotation specified by the argument. Also
 			logs the adaptation meta headers set by the
 			adaptation_meta configuration parameter.
-			If no argument given all meta headers logged.
+			If no argument given all annotations logged.
+			The argument may include a separator to use with
+			annotation values:
+                            name[:separator]
+			By default, multiple note values are separated with ","
+			and multiple notes are separated with "\r\n".
+			When logging named notes with %{name}note, the
+			explicitly configured separator is used between note
+			values. When logging all notes with %note, the
+			explicitly configured separator is used between
+			individual notes. There is currently no way to
+			specify both value and notes separators when logging
+			all notes with %note.
 
 	Connection related format codes:
 
@@ -3816,15 +3881,20 @@ DOC_START
 		[http::]ru	Request URL from client (historic, filtered for logging)
 		[http::]>ru	Request URL from client
 		[http::]<ru	Request URL sent to server or peer
+		[http::]>rs	Request URL scheme from client
+		[http::]<rs	Request URL scheme sent to server or peer
 		[http::]>rd	Request URL domain from client
-		[http::]rp	Request URL-Path excluding hostname
-		[http::]>rp	Request URL-Path excluding hostname from client
-		[http::]<rp	Request URL-Path excluding hostname sent to server or peer
+		[http::]>rd	Request URL domain sent to server or peer
+		[http::]>rP	Request URL port from client
+		[http::]<rP	Request URL port sent to server or peer
+		[http::]rp	Request URL path excluding hostname
+		[http::]>rp	Request URL path excluding hostname from client
+		[http::]<rp	Request URL path excluding hostname sent to server or peer
 		[http::]rv	Request protocol version
 		[http::]>rv	Request protocol version from client
 		[http::]<rv	Request protocol version sent to server or peer
 
-		[http::]>h	Original received request header. 
+		[http::]>h	Original received request header.
 				Usually differs from the request header sent by
 				Squid, although most fields are often preserved.
 				Accepts optional header field name/value filter
@@ -9048,7 +9118,7 @@ DOC_END
 NAME: high_memory_warning
 TYPE: b_size_t
 LOC: Config.warnings.high_memory
-IFDEF: HAVE_MSTATS && HAVE_GNUMALLOC_H
+IFDEF: HAVE_MSTATS&&HAVE_GNUMALLOC_H
 DEFAULT: 0 KB
 DEFAULT_DOC: disabled.
 DOC_START
@@ -874,11 +874,11 @@ gen_quote_escape(const std::string &var)
 
     for (int i = 0; i < var.length(); ++i) {
         switch (var[i]) {
-            case '"':
-            case '\\':
-                esc += '\\';
-            default:
-                esc += var[i];
+        case '"':
+        case '\\':
+            esc += '\\';
+        default:
+            esc += var[i];
         }
     }
 
@@ -5,33 +5,34 @@ BEGIN {
 	print "*/"
 	print "#include \"autoconf.h\""
 	print "static struct { const char *name; const char *enable; int defined;} defines[] = {"
-	define["USE_DELAY_POOLS"]="--enable-delay-pools"
+	define["_SQUID_WINDOWS_"]="MS Windows"
 	define["FOLLOW_X_FORWARDED_FOR"]="--enable-follow-x-forwarded-for"
-	define["FOLLOW_X_FORWARDED_FOR&&USE_DELAY_POOLS"]="--enable-follow-x-forwarded-for and --enable-delay-pools"
-	define["FOLLOW_X_FORWARDED_FOR&&USE_ADAPTATION"]="--enable-follow-x-forwarded-for and (--enable-icap-client and/or --enable-ecap)"
 	define["FOLLOW_X_FORWARDED_FOR&&LINUX_NETFILTER"]="--enable-follow-x-forwarded-for and --enable-linux-netfilter"
-	define["USE_HTTP_VIOLATIONS"]="--enable-http-violations"
+	define["FOLLOW_X_FORWARDED_FOR&&USE_ADAPTATION"]="--enable-follow-x-forwarded-for and (--enable-icap-client and/or --enable-ecap)"
+	define["FOLLOW_X_FORWARDED_FOR&&USE_DELAY_POOLS"]="--enable-follow-x-forwarded-for and --enable-delay-pools"
+	define["HAVE_MSTATS&&HAVE_GNUMALLOC_H"]="GNU Malloc with mstats()"
 	define["ICAP_CLIENT"]="--enable-icap-client"
+	define["SO_MARK&&USE_LIBCAP"]="Packet MARK (Linux)"
 	define["SQUID_SNMP"]="--enable-snmp"
 	define["USE_ADAPTATION"]="--enable-ecap or --enable-icap-client"
 	define["USE_AUTH"]="--enable-auth"
 	define["USE_CACHE_DIGESTS"]="--enable-cache-digests"
+	define["USE_DELAY_POOLS"]="--enable-delay-pools"
 	define["USE_ECAP"]="--enable-ecap"
 	define["USE_ERR_LOCALES"]="--enable-auto-locale"
 	define["USE_HTCP"]="--enable-htcp"
+	define["USE_HTTP_VIOLATIONS"]="--enable-http-violations"
 	define["USE_ICMP"]="--enable-icmp"
 	define["USE_IDENT"]="--enable-ident-lookups"
 	define["USE_LOADABLE_MODULES"]="--enable-loadable-modules"
+	define["USE_OPENSSL"]="--with-openssl"
+	define["USE_QOS_TOS"]="--enable-zph-qos"
 	define["USE_SQUID_ESI"]="--enable-esi"
 	define["USE_SQUID_EUI"]="--enable-eui"
 	define["USE_SSL_CRTD"]="--enable-ssl-crtd"
-	define["USE_OPENSSL"]="--with-openssl"
 	define["USE_UNLINKD"]="--enable-unlinkd"
 	define["USE_WCCP"]="--enable-wccp"
 	define["USE_WCCPv2"]="--enable-wccpv2"
-	define["USE_QOS_TOS"]="--enable-zph-qos"
-	define["_SQUID_WINDOWS_"]="MS Windows"
-	define["SO_MARK&&USE_LIBCAP"]="Packet MARK (Linux)"
 }
 /^IFDEF:/ {
 	if (define[$2] != "")
@@ -987,10 +987,8 @@ clientSetKeepaliveFlag(ClientHttpRequest * http)
 {
     HttpRequest *request = http->request;
 
-    debugs(33, 3, "clientSetKeepaliveFlag: http_ver = " <<
-           request->http_ver.major << "." << request->http_ver.minor);
-    debugs(33, 3, "clientSetKeepaliveFlag: method = " <<
-           RequestMethodStr(request->method));
+    debugs(33, 3, "http_ver = " << request->http_ver);
+    debugs(33, 3, "method = " << request->method);
 
     // TODO: move to HttpRequest::hdrCacheInit, just like HttpReply.
     request->flags.proxyKeepalive = request->persistent();
@@ -2828,20 +2826,23 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
     }
 
     if (internalCheck(request->urlpath.termedBuf())) {
-        if (internalHostnameIs(request->GetHost()) &&
-                request->port == getMyPort()) {
+        if (internalHostnameIs(request->GetHost()) && request->port == getMyPort()) {
+            debugs(33, 2, "internal URL found: " << request->url.getScheme() << "://" << request->GetHost() <<
+                   ':' << request->port);
             http->flags.internal = true;
         } else if (Config.onoff.global_internal_static && internalStaticCheck(request->urlpath.termedBuf())) {
+            debugs(33, 2, "internal URL found: " << request->url.getScheme() << "://" << request->GetHost() <<
+                   ':' << request->port << " (global_internal_static on)");
             request->SetHost(internalHostname());
             request->port = getMyPort();
             http->flags.internal = true;
-        }
+        } else
+            debugs(33, 2, "internal URL found: " << request->url.getScheme() << "://" << request->GetHost() <<
+                   ':' << request->port << " (not this proxy)");
     }
 
-    if (http->flags.internal) {
-        request->protocol = AnyP::PROTO_HTTP;
+    if (http->flags.internal)
         request->login[0] = '\0';
-    }
 
     request->flags.internal = http->flags.internal;
     setLogUri (http, urlCanonicalClean(request.getRaw()));
@@ -2920,6 +2921,10 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
     if (http->request->method == Http::METHOD_CONNECT) {
         context->mayUseConnection(true);
         conn->flags.readMore = false;
+
+        // consume header early so that tunnel gets just the body
+        connNoteUseOfBuffer(conn, http->req_sz);
+        notedUseOfBuffer = true;
     }
 
 #if USE_OPENSSL
@@ -3860,9 +3865,8 @@ httpsSslBumpAccessCheckDone(allow_t answer, void *data)
         // fake a CONNECT request to force connState to tunnel
         static char ip[MAX_IPSTRLEN];
         connState->clientConnection->local.toUrl(ip, sizeof(ip));
-        SBuf reqStr;
-        reqStr.append("CONNECT ").append(ip).append(" HTTP/1.1\r\nHost: ").append(ip).append("\r\n\r\n");
-        bool ret = connState->handleReadData(&reqStr);
+        connState->in.buf.append("CONNECT ").append(ip).append(" HTTP/1.1\r\nHost: ").append(ip).append("\r\n\r\n");
+        bool ret = connState->handleReadData(&connState->in.buf);
         if (ret)
             ret = connState->clientParseRequests();
 
@@ -583,7 +583,7 @@ clientReplyContext::cacheHit(StoreIOBuffer result)
              */
             http->logType = LOG_TCP_CLIENT_REFRESH_MISS;
             processMiss();
-        } else if (r->protocol == AnyP::PROTO_HTTP) {
+        } else if (r->url.getScheme() == AnyP::PROTO_HTTP) {
             debugs(88, 3, "validate HIT object? YES.");
             /*
              * Object needs to be revalidated
@@ -631,7 +631,7 @@ clientReplyContext::processMiss()
     char *url = http->uri;
     HttpRequest *r = http->request;
     ErrorState *err = NULL;
-    debugs(88, 4, "clientProcessMiss: '" << RequestMethodStr(r->method) << " " << url << "'");
+    debugs(88, 4, r->method << ' ' << url);
 
     /**
      * We might have a left-over StoreEntry from a failed cache hit
@@ -687,10 +687,6 @@ clientReplyContext::processMiss()
             return;
         }
 
-        /** Check for internal requests. Update Protocol info if so. */
-        if (http->flags.internal)
-            r->protocol = AnyP::PROTO_INTERNAL;
-
         assert(r->clientConnectionManager == http->getConn());
 
         /** Start forwarding to get the new object from network */
@@ -708,8 +704,7 @@ clientReplyContext::processMiss()
 void
 clientReplyContext::processOnlyIfCachedMiss()
 {
-    debugs(88, 4, "clientProcessOnlyIfCachedMiss: '" <<
-           RequestMethodStr(http->request->method) << " " << http->uri << "'");
+    debugs(88, 4, http->request->method << ' ' << http->uri);
     http->al->http.code = Http::scGatewayTimeout;
     ErrorState *err = clientBuildError(ERR_ONLY_IF_CACHED_MISS, Http::scGatewayTimeout, NULL,
                                        http->getConn()->clientConnection->remote, http->request);
@@ -835,7 +830,7 @@ purgeEntriesByUrl(HttpRequest * req, const char *url)
     for (HttpRequestMethod m(Http::METHOD_NONE); m != Http::METHOD_ENUM_END; ++m) {
         if (m.respMaybeCacheable()) {
             if (StoreEntry *entry = storeGetPublic(url, m)) {
-                debugs(88, 5, "purging " << *entry << ' ' << RequestMethodStr(m) << ' ' << url);
+                debugs(88, 5, "purging " << *entry << ' ' << m << ' ' << url);
 #if USE_HTCP
                 neighborsHtcpClear(entry, url, req, m, HTCP_CLR_INVALIDATION);
                 if (m == Http::METHOD_GET || m == Http::METHOD_HEAD) {
@@ -1995,9 +1990,9 @@ clientReplyContext::ProcessReplyAccessResult(allow_t rv, void *voidMe)
 void
 clientReplyContext::processReplyAccessResult(const allow_t &accessAllowed)
 {
-    debugs(88, 2, "The reply for " << RequestMethodStr(http->request->method)
-           << " " << http->uri << " is " << accessAllowed << ", because it matched '"
-           << (AclMatchedName ? AclMatchedName : "NO ACL's") << "'" );
+    debugs(88, 2, "The reply for " << http->request->method
+           << ' ' << http->uri << " is " << accessAllowed << ", because it matched "
+           << (AclMatchedName ? AclMatchedName : "NO ACL's"));
 
     if (accessAllowed != ACCESS_ALLOWED) {
         ErrorState *err;
@@ -678,10 +678,10 @@ ClientRequestContext::hostHeaderVerify()
         // Verify forward-proxy requested URL domain matches the Host: header
         debugs(85, 3, HERE << "FAIL on validate URL port " << http->request->port << " matches Host: port " << portStr);
         hostHeaderVerifyFailed("URL port", portStr);
-    } else if (!portStr && http->request->method != Http::METHOD_CONNECT && http->request->port != urlDefaultPort(http->request->protocol)) {
+    } else if (!portStr && http->request->method != Http::METHOD_CONNECT && http->request->port != urlDefaultPort(http->request->url.getScheme())) {
         // Verify forward-proxy requested URL domain matches the Host: header
         // Special case: we don't have a default-port to check for CONNECT. Assume URL is correct.
-        debugs(85, 3, HERE << "FAIL on validate URL port " << http->request->port << " matches Host: default port " << urlDefaultPort(http->request->protocol));
+        debugs(85, 3, "FAIL on validate URL port " << http->request->port << " matches Host: default port " << urlDefaultPort(http->request->url.getScheme()));
         hostHeaderVerifyFailed("URL port", "default port");
     } else {
         // Okay no problem.
@@ -758,8 +758,7 @@ ClientRequestContext::clientAccessCheckDone(const allow_t &answer)
     acl_checklist = NULL;
     err_type page_id;
     Http::StatusCode status;
-    debugs(85, 2, "The request " <<
-           RequestMethodStr(http->request->method) << " " <<
+    debugs(85, 2, "The request " << http->request->method << ' ' <<
            http->uri << " is " << answer <<
            "; last ACL checked: " << (AclMatchedName ? AclMatchedName : "[none]"));
 
@@ -984,13 +983,13 @@ clientHierarchical(ClientHttpRequest * http)
     if (request->flags.loopDetected)
         return 0;
 
-    if (request->protocol == AnyP::PROTO_HTTP)
+    if (request->url.getScheme() == AnyP::PROTO_HTTP)
         return method.respMaybeCacheable();
 
-    if (request->protocol == AnyP::PROTO_GOPHER)
+    if (request->url.getScheme() == AnyP::PROTO_GOPHER)
         return gopherCachable(request);
 
-    if (request->protocol == AnyP::PROTO_CACHE_OBJECT)
+    if (request->url.getScheme() == AnyP::PROTO_CACHE_OBJECT)
         return 0;
 
     return 1;
@@ -1516,7 +1515,7 @@ ClientRequestContext::sslBumpAccessCheckDone(const allow_t &answer)
 void
 ClientHttpRequest::processRequest()
 {
-    debugs(85, 4, "clientProcessRequest: " << RequestMethodStr(request->method) << " '" << uri << "'");
+    debugs(85, 4, request->method << ' ' << uri);
 
     if (request->method == Http::METHOD_CONNECT && !redirect.status) {
 #if USE_OPENSSL
@@ -1180,9 +1180,6 @@ _comm_close(int fd, char const *file, int line)
 
     commCallCloseHandlers(fd);
 
-    if (F->pconn.uses && F->pconn.pool)
-        F->pconn.pool->noteUses(F->pconn.uses);
-
     comm_empty_os_read_buffers(fd);
 
     AsyncCall::Pointer completeCall=commCbCall(5,4, "comm_close_complete",
@@ -4,6 +4,7 @@
 #include "comm.h"
 #include "comm/Connection.h"
 #include "fde.h"
+#include "neighbors.h"
 #include "SquidTime.h"
 
 class CachePeer;
@@ -66,7 +67,7 @@ Comm::Connection::close()
         comm_close(fd);
         fd = -1;
         if (CachePeer *p=getPeer())
-            -- p->stats.conn_open;
+            peerConnClosed(p);
     }
 }
 
@@ -568,6 +568,15 @@ errorPageName(int pageId)
     return "ERR_UNKNOWN";	/* should not happen */
 }
 
+ErrorState *
+ErrorState::NewForwarding(err_type type, HttpRequest *request)
+{
+    assert(request);
+    const Http::StatusCode status = request->flags.needValidation ?
+                                    Http::scGatewayTimeout : Http::scServiceUnavailable;
+    return new ErrorState(type, status, request);
+}
+
 ErrorState::ErrorState(err_type t, Http::StatusCode status, HttpRequest * req) :
         type(t),
         page_id(t),
@@ -764,8 +773,8 @@ ErrorState::Dump(MemBuf * mb)
         else
             urlpath_or_slash = "/";
 
-        str.Printf("%s " SQUIDSTRINGPH " %s/%d.%d\n",
-                   RequestMethodStr(request->method),
+        str.Printf(SQUIDSBUFPH " " SQUIDSTRINGPH " %s/%d.%d\n",
+                   SQUIDSBUFPRINT(request->method.image()),
                    SQUIDSTRINGPRINT(urlpath_or_slash),
                    AnyP::ProtocolType_str[request->http_ver.protocol],
                    request->http_ver.major, request->http_ver.minor);
@@ -940,10 +949,11 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
         break;
 
     case 'M':
-        if (request)
-            p = RequestMethodStr(request->method);
-        else if (!building_deny_info_url)
-            p= "[unknown method]";
+        if (request) {
+            const SBuf &m = request->method.image();
+            mb.append(m.rawContent(), m.length());
+        } else if (!building_deny_info_url)
+            p = "[unknown method]";
         break;
 
     case 'o':
@@ -962,7 +972,7 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
 
     case 'P':
         if (request) {
-            p = AnyP::ProtocolType_str[request->protocol];
+            p = request->url.getScheme().c_str();
         } else if (!building_deny_info_url) {
             p = "[unknown protocol]";
         }
@@ -983,8 +993,8 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
             else
                 urlpath_or_slash = "/";
 
-            mb.Printf("%s " SQUIDSTRINGPH " %s/%d.%d\n",
-                      RequestMethodStr(request->method),
+            mb.Printf(SQUIDSBUFPH " " SQUIDSTRINGPH " %s/%d.%d\n",
+                      SQUIDSBUFPRINT(request->method.image()),
                       SQUIDSTRINGPRINT(urlpath_or_slash),
                       AnyP::ProtocolType_str[request->http_ver.protocol],
                       request->http_ver.major, request->http_ver.minor);
@@ -101,6 +101,9 @@ class ErrorState
     ErrorState(); // not implemented.
     ~ErrorState();
 
+    /// Creates a general request forwarding error with the right http_status.
+    static ErrorState *NewForwarding(err_type type, HttpRequest *request);
+
     /**
      * Allocates and initializes an error response
      */
@@ -19,8 +19,8 @@ bool
 Eui::Eui64::decode(const char *asc)
 {
     if (eui64_aton(asc, (struct eui64 *)eui) != 0) {
-       debugs(28, 4, "id=" << (void*)this << " decode fail on " << asc);
-       return false;
+        debugs(28, 4, "id=" << (void*)this << " decode fail on " << asc);
+        return false;
     }
 
     debugs(28, 4, "id=" << (void*)this << " ATON decoded " << asc);
@@ -48,6 +48,7 @@
 #include "ExternalACL.h"
 #include "ExternalACLEntry.h"
 #include "fde.h"
+#include "format/ByteCode.h"
 #include "helper.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
@@ -150,55 +151,7 @@ class external_acl
 };
 
 struct _external_acl_format {
-    enum format_type {
-        EXT_ACL_UNKNOWN,
-#if USE_AUTH
-        EXT_ACL_LOGIN,
-#endif
-#if USE_IDENT
-        EXT_ACL_IDENT,
-#endif
-        EXT_ACL_SRC,
-        EXT_ACL_SRCPORT,
-#if USE_SQUID_EUI
-        EXT_ACL_SRCEUI48,
-        EXT_ACL_SRCEUI64,
-#endif
-        EXT_ACL_MYADDR,
-        EXT_ACL_MYPORT,
-        EXT_ACL_URI,
-        EXT_ACL_DST,
-        EXT_ACL_PROTO,
-        EXT_ACL_PORT,
-        EXT_ACL_PATH,
-        EXT_ACL_METHOD,
-
-        EXT_ACL_HEADER_REQUEST,
-        EXT_ACL_HEADER_REQUEST_MEMBER,
-        EXT_ACL_HEADER_REQUEST_ID,
-        EXT_ACL_HEADER_REQUEST_ID_MEMBER,
-
-        EXT_ACL_HEADER_REPLY,
-        EXT_ACL_HEADER_REPLY_MEMBER,
-        EXT_ACL_HEADER_REPLY_ID,
-        EXT_ACL_HEADER_REPLY_ID_MEMBER,
-
-#if USE_OPENSSL
-        EXT_ACL_USER_CERT,
-        EXT_ACL_USER_CA_CERT,
-        EXT_ACL_USER_CERT_RAW,
-        EXT_ACL_USER_CERTCHAIN_RAW,
-#endif
-#if USE_AUTH
-        EXT_ACL_EXT_USER,
-#endif
-        EXT_ACL_EXT_LOG,
-        EXT_ACL_TAG,
-        EXT_ACL_ACLNAME,
-        EXT_ACL_ACLDATA,
-        EXT_ACL_PERCENT,
-        EXT_ACL_END
-    } type;
+    Format::ByteCode_t type;
     external_acl_format *next;
     char *header;
     char *member;
@@ -254,7 +207,7 @@ free_external_acl(void *data)
  \param format   - structure to contain all the info about this format element.
  */
 void
-parse_header_token(external_acl_format *format, char *header, const _external_acl_format::format_type type)
+parse_header_token(external_acl_format *format, char *header, const Format::ByteCode_t type)
 {
     /* header format */
     char *member, *end;
@@ -282,30 +235,17 @@ parse_header_token(external_acl_format *format, char *header, const _external_ac
 
         format->member = xstrdup(member);
 
-        if (type == _external_acl_format::EXT_ACL_HEADER_REQUEST)
-            format->type = _external_acl_format::EXT_ACL_HEADER_REQUEST_MEMBER;
+        if (type == Format::LFT_ADAPTED_REQUEST_HEADER)
+            format->type = Format::LFT_ADAPTED_REQUEST_HEADER_ELEM;
         else
-            format->type = _external_acl_format::EXT_ACL_HEADER_REQUEST_MEMBER;
+            format->type = Format::LFT_REPLY_HEADER_ELEM;
+
     } else {
         format->type = type;
     }
 
     format->header = xstrdup(header);
     format->header_id = httpHeaderIdByNameDef(header, strlen(header));
-
-    if (format->header_id != -1) {
-        if (member) {
-            if (type == _external_acl_format::EXT_ACL_HEADER_REQUEST)
-                format->type = _external_acl_format::EXT_ACL_HEADER_REQUEST_ID_MEMBER;
-            else
-                format->type = _external_acl_format::EXT_ACL_HEADER_REPLY_ID_MEMBER;
-        } else {
-            if (type == _external_acl_format::EXT_ACL_HEADER_REQUEST)
-                format->type = _external_acl_format::EXT_ACL_HEADER_REQUEST_ID;
-            else
-                format->type = _external_acl_format::EXT_ACL_HEADER_REPLY_ID;
-        }
-    }
 }
 
 void
@@ -421,84 +361,84 @@ parse_externalAclHelper(external_acl ** list)
         if (strncmp(token, "%{", 2) == 0) {
             // deprecated. but assume the old configs all referred to request headers.
             debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type format %{...} is being replaced by %>ha{...} for : " << token);
-            parse_header_token(format, (token+2), _external_acl_format::EXT_ACL_HEADER_REQUEST);
+            parse_header_token(format, (token+2), Format::LFT_ADAPTED_REQUEST_HEADER);
         } else if (strncmp(token, "%>{", 3) == 0) {
             debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type format %>{...} is being replaced by %>ha{...} for : " << token);
-            parse_header_token(format, (token+3), _external_acl_format::EXT_ACL_HEADER_REQUEST);
+            parse_header_token(format, (token+3), Format::LFT_ADAPTED_REQUEST_HEADER);
         } else if (strncmp(token, "%>ha{", 5) == 0) {
-            parse_header_token(format, (token+3), _external_acl_format::EXT_ACL_HEADER_REQUEST);
+            parse_header_token(format, (token+3), Format::LFT_ADAPTED_REQUEST_HEADER);
         } else if (strncmp(token, "%<{", 3) == 0) {
             debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type format %<{...} is being replaced by %<h{...} for : " << token);
-            parse_header_token(format, (token+3), _external_acl_format::EXT_ACL_HEADER_REPLY);
+            parse_header_token(format, (token+3), Format::LFT_REPLY_HEADER);
         } else if (strncmp(token, "%<h{", 4) == 0) {
-            parse_header_token(format, (token+3), _external_acl_format::EXT_ACL_HEADER_REPLY);
+            parse_header_token(format, (token+3), Format::LFT_REPLY_HEADER);
 #if USE_AUTH
         } else if (strcmp(token, "%LOGIN") == 0 || strcmp(token, "%ul") == 0) {
-            format->type = _external_acl_format::EXT_ACL_LOGIN;
+            format->type = Format::LFT_USER_LOGIN;
             a->require_auth = true;
 #endif
         }
 #if USE_IDENT
         else if (strcmp(token, "%IDENT") == 0 || strcmp(token, "%ui") == 0)
-            format->type = _external_acl_format::EXT_ACL_IDENT;
+            format->type = Format::LFT_USER_IDENT;
 #endif
         else if (strcmp(token, "%SRC") == 0 || strcmp(token, "%>a") == 0)
-            format->type = _external_acl_format::EXT_ACL_SRC;
+            format->type = Format::LFT_CLIENT_IP_ADDRESS;
         else if (strcmp(token, "%SRCPORT") == 0 || strcmp(token, "%>p") == 0)
-            format->type = _external_acl_format::EXT_ACL_SRCPORT;
+            format->type = Format::LFT_CLIENT_PORT;
 #if USE_SQUID_EUI
         else if (strcmp(token, "%SRCEUI48") == 0)
-            format->type = _external_acl_format::EXT_ACL_SRCEUI48;
+            format->type = Format::LFT_EXT_ACL_CLIENT_EUI48;
         else if (strcmp(token, "%SRCEUI64") == 0)
-            format->type = _external_acl_format::EXT_ACL_SRCEUI64;
+            format->type = Format::LFT_EXT_ACL_CLIENT_EUI64;
 #endif
         else if (strcmp(token, "%MYADDR") == 0 || strcmp(token, "%la") == 0)
-            format->type = _external_acl_format::EXT_ACL_MYADDR;
+            format->type = Format::LFT_LOCAL_LISTENING_IP;
         else if (strcmp(token, "%MYPORT") == 0 || strcmp(token, "%lp") == 0)
-            format->type = _external_acl_format::EXT_ACL_MYPORT;
+            format->type = Format::LFT_LOCAL_LISTENING_PORT;
         else if (strcmp(token, "%URI") == 0 || strcmp(token, "%>ru") == 0)
-            format->type = _external_acl_format::EXT_ACL_URI;
-        else if (strcmp(token, "%DST") == 0)
-            format->type = _external_acl_format::EXT_ACL_DST;
-        else if (strcmp(token, "%PROTO") == 0)
-            format->type = _external_acl_format::EXT_ACL_PROTO;
-        else if (strcmp(token, "%PORT") == 0)
-            format->type = _external_acl_format::EXT_ACL_PORT;
+            format->type = Format::LFT_CLIENT_REQ_URI;
+        else if (strcmp(token, "%DST") == 0 || strcmp(token, "%>rd") == 0)
+            format->type = Format::LFT_CLIENT_REQ_URLDOMAIN;
+        else if (strcmp(token, "%PROTO") == 0 || strcmp(token, "%>rs") == 0)
+            format->type = Format::LFT_CLIENT_REQ_URLSCHEME;
+        else if (strcmp(token, "%PORT") == 0) // XXX: add a logformat token
+            format->type = Format::LFT_CLIENT_REQ_URLPORT;
         else if (strcmp(token, "%PATH") == 0 || strcmp(token, "%>rp") == 0)
-            format->type = _external_acl_format::EXT_ACL_PATH;
+            format->type = Format::LFT_CLIENT_REQ_URLPATH;
         else if (strcmp(token, "%METHOD") == 0 || strcmp(token, "%>rm") == 0)
-            format->type = _external_acl_format::EXT_ACL_METHOD;
+            format->type = Format::LFT_CLIENT_REQ_METHOD;
 #if USE_OPENSSL
         else if (strcmp(token, "%USER_CERT") == 0)
-            format->type = _external_acl_format::EXT_ACL_USER_CERT_RAW;
+            format->type = Format::LFT_EXT_ACL_USER_CERT_RAW;
         else if (strcmp(token, "%USER_CERTCHAIN") == 0)
-            format->type = _external_acl_format::EXT_ACL_USER_CERTCHAIN_RAW;
+            format->type = Format::LFT_EXT_ACL_USER_CERTCHAIN_RAW;
         else if (strncmp(token, "%USER_CERT_", 11) == 0) {
-            format->type = _external_acl_format::EXT_ACL_USER_CERT;
+            format->type = Format::LFT_EXT_ACL_USER_CERT;
             format->header = xstrdup(token + 11);
         } else if (strncmp(token, "%USER_CA_CERT_", 11) == 0) {
-            format->type = _external_acl_format::EXT_ACL_USER_CA_CERT;
+            format->type = Format::LFT_EXT_ACL_USER_CA_CERT;
             format->header = xstrdup(token + 11);
         } else if (strncmp(token, "%CA_CERT_", 11) == 0) {
             debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type %CA_CERT_* code is obsolete. Use %USER_CA_CERT_* instead");
-            format->type = _external_acl_format::EXT_ACL_USER_CA_CERT;
+            format->type = Format::LFT_EXT_ACL_USER_CA_CERT;
             format->header = xstrdup(token + 11);
         }
 #endif
 #if USE_AUTH
-        else if (strcmp(token, "%EXT_USER") == 0)
-            format->type = _external_acl_format::EXT_ACL_EXT_USER;
+        else if (strcmp(token, "%EXT_USER") == 0 || strcmp(token, "%ue") == 0)
+            format->type = Format::LFT_USER_EXTERNAL;
 #endif
-        else if (strcmp(token, "%EXT_LOG") == 0)
-            format->type = _external_acl_format::EXT_ACL_EXT_LOG;
-        else if (strcmp(token, "%TAG") == 0)
-            format->type = _external_acl_format::EXT_ACL_TAG;
+        else if (strcmp(token, "%EXT_LOG") == 0 || strcmp(token, "%ea") == 0)
+            format->type = Format::LFT_EXT_LOG;
+        else if (strcmp(token, "%TAG") == 0  || strcmp(token, "%et") == 0)
+            format->type = Format::LFT_TAG;
         else if (strcmp(token, "%ACL") == 0)
-            format->type = _external_acl_format::EXT_ACL_ACLNAME;
+            format->type = Format::LFT_EXT_ACL_NAME;
         else if (strcmp(token, "%DATA") == 0)
-            format->type = _external_acl_format::EXT_ACL_ACLDATA;
+            format->type = Format::LFT_EXT_ACL_DATA;
         else if (strcmp(token, "%%") == 0)
-            format->type = _external_acl_format::EXT_ACL_PERCENT;
+            format->type = Format::LFT_PERCENT;
         else {
             debugs(0, DBG_CRITICAL, "ERROR: Unknown Format token " << token);
             self_destruct();
@@ -573,67 +513,60 @@ dump_externalAclHelper(StoreEntry * sentry, const char *name, const external_acl
         for (format = node->format; format; format = format->next) {
             switch (format->type) {
 
-            case _external_acl_format::EXT_ACL_HEADER_REQUEST:
-            case _external_acl_format::EXT_ACL_HEADER_REQUEST_ID:
-                storeAppendPrintf(sentry, " %%>{%s}", format->header);
+            case Format::LFT_ADAPTED_REQUEST_HEADER:
+                storeAppendPrintf(sentry, " %%>ha{%s}", format->header);
                 break;
 
-            case _external_acl_format::EXT_ACL_HEADER_REQUEST_MEMBER:
-            case _external_acl_format::EXT_ACL_HEADER_REQUEST_ID_MEMBER:
-                storeAppendPrintf(sentry, " %%>{%s:%s}", format->header, format->member);
+            case Format::LFT_ADAPTED_REQUEST_HEADER_ELEM:
+                storeAppendPrintf(sentry, " %%>ha{%s:%s}", format->header, format->member);
                 break;
 
-            case _external_acl_format::EXT_ACL_HEADER_REPLY:
-            case _external_acl_format::EXT_ACL_HEADER_REPLY_ID:
-                storeAppendPrintf(sentry, " %%<{%s}", format->header);
+            case Format::LFT_REPLY_HEADER:
+                storeAppendPrintf(sentry, " %%<h{%s}", format->header);
                 break;
 
-            case _external_acl_format::EXT_ACL_HEADER_REPLY_MEMBER:
-            case _external_acl_format::EXT_ACL_HEADER_REPLY_ID_MEMBER:
-                storeAppendPrintf(sentry, " %%<{%s:%s}", format->header, format->member);
+            case Format::LFT_REPLY_HEADER_ELEM:
+                storeAppendPrintf(sentry, " %%<h{%s:%s}", format->header, format->member);
                 break;
-#define DUMP_EXT_ACL_TYPE(a) \
-            case _external_acl_format::EXT_ACL_##a: \
-                storeAppendPrintf(sentry, " %%%s", #a); \
-                break
+
 #define DUMP_EXT_ACL_TYPE_FMT(a, fmt, ...) \
-            case _external_acl_format::EXT_ACL_##a: \
+            case Format::LFT_##a: \
                 storeAppendPrintf(sentry, fmt, ##__VA_ARGS__); \
                 break
 #if USE_AUTH
-                DUMP_EXT_ACL_TYPE(LOGIN);
+                DUMP_EXT_ACL_TYPE_FMT(USER_LOGIN," %%ul");
 #endif
 #if USE_IDENT
 
-                DUMP_EXT_ACL_TYPE(IDENT);
+                DUMP_EXT_ACL_TYPE_FMT(USER_IDENT," %%ui");
 #endif
-
-                DUMP_EXT_ACL_TYPE(SRC);
-                DUMP_EXT_ACL_TYPE(SRCPORT);
+                DUMP_EXT_ACL_TYPE_FMT(CLIENT_IP_ADDRESS," %%>a");
+                DUMP_EXT_ACL_TYPE_FMT(CLIENT_PORT," %%>p");
 #if USE_SQUID_EUI
-                DUMP_EXT_ACL_TYPE(SRCEUI48);
-                DUMP_EXT_ACL_TYPE(SRCEUI64);
+                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_CLIENT_EUI48," %%SRCEUI48");
+                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_CLIENT_EUI64," %%SRCEUI64");
 #endif
-
-                DUMP_EXT_ACL_TYPE(MYADDR);
-                DUMP_EXT_ACL_TYPE(MYPORT);
-                DUMP_EXT_ACL_TYPE(URI);
-                DUMP_EXT_ACL_TYPE(DST);
-                DUMP_EXT_ACL_TYPE(PROTO);
-                DUMP_EXT_ACL_TYPE(PORT);
-                DUMP_EXT_ACL_TYPE(PATH);
-                DUMP_EXT_ACL_TYPE(METHOD);
+                DUMP_EXT_ACL_TYPE_FMT(LOCAL_LISTENING_IP," %%>la");
+                DUMP_EXT_ACL_TYPE_FMT(LOCAL_LISTENING_PORT," %%>lp");
+                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URI," %%>ru");
+                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URLDOMAIN," %%>rd");
+                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URLSCHEME," %%>rs");
+                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URLPORT," %%>rP");
+                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URLPATH," %%>rp");
+                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_METHOD," %%>rm");
 #if USE_OPENSSL
-                DUMP_EXT_ACL_TYPE_FMT(USER_CERT_RAW, " %%USER_CERT_RAW");
-                DUMP_EXT_ACL_TYPE_FMT(USER_CERTCHAIN_RAW, " %%USER_CERTCHAIN_RAW");
-                DUMP_EXT_ACL_TYPE_FMT(USER_CERT, " %%USER_CERT_%s", format->header);
-                DUMP_EXT_ACL_TYPE_FMT(USER_CA_CERT, " %%USER_CA_CERT_%s", format->header);
+                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_USER_CERT_RAW, " %%USER_CERT_RAW");
+                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_USER_CERTCHAIN_RAW, " %%USER_CERTCHAIN_RAW");
+                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_USER_CERT, " %%USER_CERT_%s", format->header);
+                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_USER_CA_CERT, " %%USER_CA_CERT_%s", format->header);
 #endif
 #if USE_AUTH
-                DUMP_EXT_ACL_TYPE(EXT_USER);
+                DUMP_EXT_ACL_TYPE_FMT(USER_EXTERNAL," %%ue");
 #endif
-                DUMP_EXT_ACL_TYPE(EXT_LOG);
-                DUMP_EXT_ACL_TYPE(TAG);
+                DUMP_EXT_ACL_TYPE_FMT(EXT_LOG," %%ea");
+                DUMP_EXT_ACL_TYPE_FMT(TAG," %%et");
+                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_NAME," %%ACL");
+                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_DATA," %%DATA");
                 DUMP_EXT_ACL_TYPE_FMT(PERCENT, " %%%%");
             default:
                 fatal("unknown external_acl format error");
@@ -980,7 +913,7 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
 
         switch (format->type) {
 #if USE_AUTH
-        case _external_acl_format::EXT_ACL_LOGIN:
+        case Format::LFT_USER_LOGIN:
             // if this ACL line was the cause of credentials fetch
             // they may not already be in the checklist
             if (ch->auth_user_request == NULL && ch->request)
@@ -991,7 +924,7 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
             break;
 #endif
 #if USE_IDENT
-        case _external_acl_format::EXT_ACL_IDENT:
+        case Format::LFT_USER_IDENT:
             str = ch->rfc931;
 
             if (!str || !*str) {
@@ -1004,113 +937,105 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
             break;
 #endif
 
-        case _external_acl_format::EXT_ACL_SRC:
+        case Format::LFT_CLIENT_IP_ADDRESS:
             str = ch->src_addr.toStr(buf,sizeof(buf));
             break;
 
-        case _external_acl_format::EXT_ACL_SRCPORT:
+        case Format::LFT_CLIENT_PORT:
             snprintf(buf, sizeof(buf), "%d", request->client_addr.port());
             str = buf;
             break;
 
 #if USE_SQUID_EUI
-        case _external_acl_format::EXT_ACL_SRCEUI48:
+        case Format::LFT_EXT_ACL_CLIENT_EUI48:
             if (request->clientConnectionManager.valid() && request->clientConnectionManager->clientConnection != NULL &&
                     request->clientConnectionManager->clientConnection->remoteEui48.encode(buf, sizeof(buf)))
                 str = buf;
             break;
 
-        case _external_acl_format::EXT_ACL_SRCEUI64:
+        case Format::LFT_EXT_ACL_CLIENT_EUI64:
             if (request->clientConnectionManager.valid() && request->clientConnectionManager->clientConnection != NULL &&
                     request->clientConnectionManager->clientConnection->remoteEui64.encode(buf, sizeof(buf)))
                 str = buf;
             break;
 #endif
 
-        case _external_acl_format::EXT_ACL_MYADDR:
+        case Format::LFT_LOCAL_LISTENING_IP:
             str = request->my_addr.toStr(buf, sizeof(buf));
             break;
 
-        case _external_acl_format::EXT_ACL_MYPORT:
+        case Format::LFT_LOCAL_LISTENING_PORT:
             snprintf(buf, sizeof(buf), "%d", request->my_addr.port());
             str = buf;
             break;
 
-        case _external_acl_format::EXT_ACL_URI:
+        case Format::LFT_CLIENT_REQ_URI:
             str = urlCanonical(request);
             break;
 
-        case _external_acl_format::EXT_ACL_DST:
+        case Format::LFT_CLIENT_REQ_URLDOMAIN:
             str = request->GetHost();
             break;
 
-        case _external_acl_format::EXT_ACL_PROTO:
-            str = AnyP::ProtocolType_str[request->protocol];
+        case Format::LFT_CLIENT_REQ_URLSCHEME:
+            str = request->url.getScheme().c_str();
             break;
 
-        case _external_acl_format::EXT_ACL_PORT:
+        case Format::LFT_CLIENT_REQ_URLPORT:
             snprintf(buf, sizeof(buf), "%d", request->port);
             str = buf;
             break;
 
-        case _external_acl_format::EXT_ACL_PATH:
+        case Format::LFT_CLIENT_REQ_URLPATH:
             str = request->urlpath.termedBuf();
             break;
 
-        case _external_acl_format::EXT_ACL_METHOD:
-            str = RequestMethodStr(request->method);
-            break;
-
-        case _external_acl_format::EXT_ACL_HEADER_REQUEST:
-            sb = request->header.getByName(format->header);
-            str = sb.termedBuf();
-            break;
-
-        case _external_acl_format::EXT_ACL_HEADER_REQUEST_ID:
-            sb = request->header.getStrOrList(format->header_id);
-            str = sb.termedBuf();
-            break;
+        case Format::LFT_CLIENT_REQ_METHOD: {
+            const SBuf &s = request->method.image();
+            sb.append(s.rawContent(), s.length());
+        }
+        str = sb.termedBuf();
+        break;
 
-        case _external_acl_format::EXT_ACL_HEADER_REQUEST_MEMBER:
-            sb = request->header.getByNameListMember(format->header, format->member, format->separator);
+        case Format::LFT_ADAPTED_REQUEST_HEADER:
+            if (format->header_id == -1)
+                sb = request->header.getByName(format->header);
+            else
+                sb = request->header.getStrOrList(format->header_id);
             str = sb.termedBuf();
             break;
 
-        case _external_acl_format::EXT_ACL_HEADER_REQUEST_ID_MEMBER:
-            sb = request->header.getListMember(format->header_id, format->member, format->separator);
+        case Format::LFT_ADAPTED_REQUEST_HEADER_ELEM:
+            if (format->header_id == -1)
+                sb = request->header.getByNameListMember(format->header, format->member, format->separator);
+            else
+                sb = request->header.getListMember(format->header_id, format->member, format->separator);
             str = sb.termedBuf();
             break;
 
-        case _external_acl_format::EXT_ACL_HEADER_REPLY:
+        case Format::LFT_REPLY_HEADER:
             if (reply) {
-                sb = reply->header.getByName(format->header);
+                if (format->header_id == -1)
+                    sb = reply->header.getByName(format->header);
+                else
+                    sb = reply->header.getStrOrList(format->header_id);
                 str = sb.termedBuf();
             }
             break;
 
-        case _external_acl_format::EXT_ACL_HEADER_REPLY_ID:
+        case Format::LFT_REPLY_HEADER_ELEM:
             if (reply) {
-                sb = reply->header.getStrOrList(format->header_id);
+                if (format->header_id == -1)
+                    sb = reply->header.getByNameListMember(format->header, format->member, format->separator);
+                else
+                    sb = reply->header.getListMember(format->header_id, format->member, format->separator);
                 str = sb.termedBuf();
             }
             break;
 
-        case _external_acl_format::EXT_ACL_HEADER_REPLY_MEMBER:
-            if (reply) {
-                sb = reply->header.getByNameListMember(format->header, format->member, format->separator);
-                str = sb.termedBuf();
-            }
-            break;
-
-        case _external_acl_format::EXT_ACL_HEADER_REPLY_ID_MEMBER:
-            if (reply) {
-                sb = reply->header.getListMember(format->header_id, format->member, format->separator);
-                str = sb.termedBuf();
-            }
-            break;
 #if USE_OPENSSL
 
-        case _external_acl_format::EXT_ACL_USER_CERT_RAW:
+        case Format::LFT_EXT_ACL_USER_CERT_RAW:
 
             if (ch->conn() != NULL && Comm::IsConnOpen(ch->conn()->clientConnection)) {
                 SSL *ssl = fd_table[ch->conn()->clientConnection->fd].ssl;
@@ -1121,7 +1046,7 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
 
             break;
 
-        case _external_acl_format::EXT_ACL_USER_CERTCHAIN_RAW:
+        case Format::LFT_EXT_ACL_USER_CERTCHAIN_RAW:
 
             if (ch->conn() != NULL && Comm::IsConnOpen(ch->conn()->clientConnection)) {
                 SSL *ssl = fd_table[ch->conn()->clientConnection->fd].ssl;
@@ -1132,7 +1057,7 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
 
             break;
 
-        case _external_acl_format::EXT_ACL_USER_CERT:
+        case Format::LFT_EXT_ACL_USER_CERT:
 
             if (ch->conn() != NULL && Comm::IsConnOpen(ch->conn()->clientConnection)) {
                 SSL *ssl = fd_table[ch->conn()->clientConnection->fd].ssl;
@@ -1143,7 +1068,7 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
 
             break;
 
-        case _external_acl_format::EXT_ACL_USER_CA_CERT:
+        case Format::LFT_EXT_ACL_USER_CA_CERT:
 
             if (ch->conn() != NULL && Comm::IsConnOpen(ch->conn()->clientConnection)) {
                 SSL *ssl = fd_table[ch->conn()->clientConnection->fd].ssl;
@@ -1155,20 +1080,20 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
             break;
 #endif
 #if USE_AUTH
-        case _external_acl_format::EXT_ACL_EXT_USER:
+        case Format::LFT_USER_EXTERNAL:
             str = request->extacl_user.termedBuf();
             break;
 #endif
-        case _external_acl_format::EXT_ACL_EXT_LOG:
+        case Format::LFT_EXT_LOG:
             str = request->extacl_log.termedBuf();
             break;
-        case _external_acl_format::EXT_ACL_TAG:
+        case Format::LFT_TAG:
             str = request->tag.termedBuf();
             break;
-        case _external_acl_format::EXT_ACL_ACLNAME:
+        case Format::LFT_EXT_ACL_NAME:
             str = acl_data->name;
             break;
-        case _external_acl_format::EXT_ACL_ACLDATA:
+        case Format::LFT_EXT_ACL_DATA:
             data_used = true;
             for (arg = acl_data->arguments; arg; arg = arg->next) {
                 if (!first)
@@ -1188,13 +1113,14 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
                 first = 0;
             }
             break;
-        case _external_acl_format::EXT_ACL_PERCENT:
+        case Format::LFT_PERCENT:
             str = "%";
             break;
-        case _external_acl_format::EXT_ACL_UNKNOWN:
 
-        case _external_acl_format::EXT_ACL_END:
-            fatal("unknown external_acl format error");
+        default:
+            // TODO: replace this function with Format::assemble()
+            // For now die on unsupported logformat codes.
+            fatalf("ERROR: unknown external_acl_type format %u", (uint8_t)format->type);
             break;
         }
 
@@ -1603,14 +1529,16 @@ ExternalACLLookup::LookupDone(void *data, void *result)
     checklist->extacl_entry = cbdataReference((external_acl_entry *)result);
 
     // attach the helper kv-pair to the transaction
-    if (HttpRequest * req = checklist->request) {
-        // XXX: we have no access to the transaction / AccessLogEntry so cant SyncNotes().
-        // workaround by using anything already set in HttpRequest
-        // OR use new and rely on a later Sync copying these to AccessLogEntry
-        if (!req->notes)
-            req->notes = new NotePairs;
-
-        req->notes->appendNewOnly(&checklist->extacl_entry->notes);
+    if (checklist->extacl_entry) {
+        if (HttpRequest * req = checklist->request) {
+            // XXX: we have no access to the transaction / AccessLogEntry so cant SyncNotes().
+            // workaround by using anything already set in HttpRequest
+            // OR use new and rely on a later Sync copying these to AccessLogEntry
+            if (!req->notes)
+                req->notes = new NotePairs;
+
+            req->notes->appendNewOnly(&checklist->extacl_entry->notes);
+        }
     }
 
     checklist->resumeNonBlockingCheck(ExternalACLLookup::Instance());
@@ -122,8 +122,7 @@ fde::remoteAddr() const
 }
 
 void
-fde::noteUse(PconnPool *pool)
+fde::noteUse()
 {
     ++ pconn.uses;
-    pconn.pool = pool;
 }
@@ -42,7 +42,6 @@
 class ClientInfo;
 #endif
 
-class PconnPool;
 class dwrite_q;
 class _fde_disk
 {
@@ -70,7 +69,7 @@ class fde
     char const *remoteAddr() const;
     void dumpStats (StoreEntry &, int);
     bool readPending(int);
-    void noteUse(PconnPool *);
+    void noteUse();
 
 public:
 
@@ -110,7 +109,6 @@ class fde
 
     struct {
         int uses;                   /* ie # req's over persistent conn */
-        PconnPool *pool;
     } pconn;
 
 #if USE_DELAY_POOLS
@@ -167,7 +165,6 @@ class fde
         bytes_read = 0;
         bytes_written = 0;
         pconn.uses = 0;
-        pconn.pool = NULL;
 #if USE_DELAY_POOLS
         clientInfo = NULL;
 #endif
@@ -58,7 +58,9 @@ typedef enum {
     /* original Request-Line details recieved from client */
     LFT_CLIENT_REQ_METHOD,
     LFT_CLIENT_REQ_URI,
+    LFT_CLIENT_REQ_URLSCHEME,
     LFT_CLIENT_REQ_URLDOMAIN,
+    LFT_CLIENT_REQ_URLPORT,
     LFT_CLIENT_REQ_URLPATH,
     /* LFT_CLIENT_REQ_QUERY, */
     LFT_CLIENT_REQ_VERSION,
@@ -70,6 +72,7 @@ typedef enum {
     /*LFT_REQUEST_QUERY, */
     LFT_REQUEST_VERSION_OLD_2X,
     LFT_REQUEST_VERSION,
+    LFT_REQUEST_URLGROUP_OLD_2X,
 
     /* request header details pre-adaptation */
     LFT_REQUEST_HEADER,
@@ -84,6 +87,9 @@ typedef enum {
     /* Request-Line details sent to the server/peer */
     LFT_SERVER_REQ_METHOD,
     LFT_SERVER_REQ_URI,
+    LFT_SERVER_REQ_URLSCHEME,
+    LFT_SERVER_REQ_URLDOMAIN,
+    LFT_SERVER_REQ_URLPORT,
     LFT_SERVER_REQ_URLPATH,
     /*LFT_SERVER_REQ_QUERY, */
     LFT_SERVER_REQ_VERSION,
@@ -203,7 +209,18 @@ typedef enum {
 #endif
 
     LFT_NOTE,
-    LFT_PERCENT			/* special string cases for escaped chars */
+    LFT_PERCENT,			/* special string cases for escaped chars */
+
+    // TODO assign better bytecode names and Token strings for these
+    LFT_EXT_ACL_USER_CERT_RAW,
+    LFT_EXT_ACL_USER_CERTCHAIN_RAW,
+    LFT_EXT_ACL_USER_CERT,
+    LFT_EXT_ACL_USER_CA_CERT,
+    LFT_EXT_ACL_CLIENT_EUI48,
+    LFT_EXT_ACL_CLIENT_EUI64,
+    LFT_EXT_ACL_NAME,
+    LFT_EXT_ACL_DATA
+
 } ByteCode_t;
 
 /// Quoting style for a format output.
@@ -475,7 +475,7 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             const char *spec;
 
             struct tm *t;
-            spec = fmt->data.timespec;
+            spec = fmt->data.string;
 
             if (fmt->type == LFT_TIME_LOCALTIME) {
                 if (!spec)
@@ -916,7 +916,9 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
 
         case LFT_CLIENT_REQ_METHOD:
             if (al->request) {
-                out = al->request->method.image();
+                const SBuf &s = al->request->method.image();
+                sb.append(s.rawContent(), s.length());
+                out = sb.termedBuf();
                 quote = 1;
             }
             break;
@@ -929,13 +931,27 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             }
             break;
 
+        case LFT_CLIENT_REQ_URLSCHEME:
+            if (al->request) {
+                out = al->request->url.getScheme().c_str();
+                quote = 1;
+            }
+            break;
+
         case LFT_CLIENT_REQ_URLDOMAIN:
             if (al->request) {
                 out = al->request->GetHost();
                 quote = 1;
             }
             break;
 
+        case LFT_CLIENT_REQ_URLPORT:
+            if (al->request) {
+                outint = al->request->port;
+                doint = 1;
+            }
+            break;
+
         case LFT_REQUEST_URLPATH_OLD_31:
         case LFT_CLIENT_REQ_URLPATH:
             if (al->request) {
@@ -952,7 +968,14 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             break;
 
         case LFT_REQUEST_METHOD:
-            out = al->_private.method_str;
+            if (al->_private.method_str) // ICP, HTCP method code
+                out = al->_private.method_str;
+            else {
+                const SBuf &s = al->http.method.image();
+                sb.append(s.rawContent(), s.length());
+                out = sb.termedBuf();
+                quote = 1;
+            }
             break;
 
         case LFT_REQUEST_URI:
@@ -967,7 +990,9 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
 
         case LFT_SERVER_REQ_METHOD:
             if (al->adapted_request) {
-                out = al->adapted_request->method.image();
+                const SBuf &s = al->adapted_request->method.image();
+                sb.append(s.rawContent(), s.length());
+                out = sb.termedBuf();
                 quote = 1;
             }
             break;
@@ -980,6 +1005,27 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             }
             break;
 
+        case LFT_SERVER_REQ_URLSCHEME:
+            if (al->adapted_request) {
+                out = al->adapted_request->url.getScheme().c_str();
+                quote = 1;
+            }
+            break;
+
+        case LFT_SERVER_REQ_URLDOMAIN:
+            if (al->adapted_request) {
+                out = al->adapted_request->GetHost();
+                quote = 1;
+            }
+            break;
+
+        case LFT_SERVER_REQ_URLPORT:
+            if (al->adapted_request) {
+                outint = al->adapted_request->port;
+                doint = 1;
+            }
+            break;
+
         case LFT_SERVER_REQ_URLPATH:
             if (al->adapted_request) {
                 out = al->adapted_request->urlpath.termedBuf();
@@ -1090,32 +1136,40 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             break;
 #endif
 
+        case LFT_REQUEST_URLGROUP_OLD_2X:
+            assert(LFT_REQUEST_URLGROUP_OLD_2X == 0); // should never happen.
+
         case LFT_NOTE:
-            if (fmt->data.string) {
+            tmp[0] = fmt->data.header.separator;
+            tmp[1] = '\0';
+            if (fmt->data.header.header && *fmt->data.header.header) {
+                const char *separator = tmp;
 #if USE_ADAPTATION
                 Adaptation::History::Pointer ah = al->request ? al->request->adaptHistory() : Adaptation::History::Pointer();
                 if (ah != NULL && ah->metaHeaders != NULL) {
-                    if (const char *meta = ah->metaHeaders->find(fmt->data.string))
+                    if (const char *meta = ah->metaHeaders->find(fmt->data.header.header, separator))
                         sb.append(meta);
                 }
 #endif
                 if (al->notes != NULL) {
-                    if (const char *note = al->notes->find(fmt->data.string)) {
+                    if (const char *note = al->notes->find(fmt->data.header.header, separator)) {
                         if (sb.size())
-                            sb.append(", ");
+                            sb.append(separator);
                         sb.append(note);
                     }
                 }
                 out = sb.termedBuf();
                 quote = 1;
             } else {
+                // if no argument given use default "\r\n" as notes separator
+                const char *separator = fmt->data.string ? tmp : "\r\n";
 #if USE_ADAPTATION
                 Adaptation::History::Pointer ah = al->request ? al->request->adaptHistory() : Adaptation::History::Pointer();
                 if (ah != NULL && ah->metaHeaders != NULL && !ah->metaHeaders->empty())
-                    sb.append(ah->metaHeaders->toString());
+                    sb.append(ah->metaHeaders->toString(separator));
 #endif
                 if (al->notes != NULL && !al->notes->empty())
-                    sb.append(al->notes->toString());
+                    sb.append(al->notes->toString(separator));
 
                 out = sb.termedBuf();
                 quote = 1;
@@ -1132,7 +1186,20 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
 
         case LFT_PERCENT:
             out = "%";
+            break;
 
+            // XXX: external_acl_type format tokens which are not output by logformat.
+            // They are listed here because the switch requires
+            // every ByteCode_t to be explicitly enumerated.
+            // But do not output due to lack of access to the values.
+        case LFT_EXT_ACL_USER_CERT_RAW:
+        case LFT_EXT_ACL_USER_CERTCHAIN_RAW:
+        case LFT_EXT_ACL_USER_CERT:
+        case LFT_EXT_ACL_USER_CA_CERT:
+        case LFT_EXT_ACL_CLIENT_EUI48:
+        case LFT_EXT_ACL_CLIENT_EUI64:
+        case LFT_EXT_ACL_NAME:
+        case LFT_EXT_ACL_DATA:
             break;
         }
 
@@ -81,7 +81,9 @@ static TokenTableEntry TokenTable2C[] = {
 
     {">rm", LFT_CLIENT_REQ_METHOD},
     {">ru", LFT_CLIENT_REQ_URI},
+    {">rs", LFT_CLIENT_REQ_URLSCHEME},
     {">rd", LFT_CLIENT_REQ_URLDOMAIN},
+    {">rP", LFT_CLIENT_REQ_URLPORT},
     {">rp", LFT_CLIENT_REQ_URLPATH},
     /*{">rq", LFT_CLIENT_REQ_QUERY},*/
     {">rv", LFT_CLIENT_REQ_VERSION},
@@ -91,9 +93,13 @@ static TokenTableEntry TokenTable2C[] = {
     {"rp", LFT_REQUEST_URLPATH_OLD_31},
     /* { "rq", LFT_REQUEST_QUERY }, * /     / * the query-string, INCLUDING the leading ? */
     {"rv", LFT_REQUEST_VERSION},
+    {"rG", LFT_REQUEST_URLGROUP_OLD_2X},
 
     {"<rm", LFT_SERVER_REQ_METHOD},
     {"<ru", LFT_SERVER_REQ_URI},
+    {"<rs", LFT_SERVER_REQ_URLSCHEME},
+    {"<rd", LFT_SERVER_REQ_URLDOMAIN},
+    {"<rP", LFT_SERVER_REQ_URLPORT},
     {"<rp", LFT_SERVER_REQ_URLPATH},
     /*{"<rq", LFT_SERVER_REQ_QUERY},*/
     {"<rv", LFT_SERVER_REQ_VERSION},
@@ -407,6 +413,8 @@ Format::Token::parse(const char *def, Quoting *quoting)
 
     case LFT_REPLY_HEADER:
 
+    case LFT_NOTE:
+
         if (data.string) {
             char *header = data.string;
             char *cp = strchr(header, ':');
@@ -534,13 +542,36 @@ Format::Token::parse(const char *def, Quoting *quoting)
         break;
 #endif
 
+    case LFT_REQUEST_URLGROUP_OLD_2X:
+        debugs(46, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: The \"rG\" formatting code is deprecated. Use \"note{urlgroup}\" instead.");
+        type = LFT_NOTE;
+        data.header.header = xstrdup("urlgroup");
+        break;
+
     default:
         break;
     }
 
     return (cur - def);
 }
 
+Format::Token::Token() : type(LFT_NONE),
+        label(NULL),
+        widthMin(-1),
+        widthMax(-1),
+        quote(LOG_QUOTE_NONE),
+        left(false),
+        space(false),
+        zero(false),
+        divisor(1),
+        next(NULL)
+{
+    data.string = NULL;
+    data.header.header = NULL;
+    data.header.element = NULL;
+    data.header.separator = ',';
+}
+
 Format::Token::~Token()
 {
     label = NULL; // drop reference to global static.
@@ -27,18 +27,7 @@ class TokenTableEntry;
 class Token
 {
 public:
-    Token() : type(LFT_NONE),
-            label(NULL),
-            widthMin(-1),
-            widthMax(-1),
-            quote(LOG_QUOTE_NONE),
-            left(false),
-            space(false),
-            zero(false),
-            divisor(1),
-            next(NULL)
-    { data.string = NULL; }
-
+    Token();
     ~Token();
 
     /// Initialize the format token registrations
@@ -52,15 +41,14 @@ class Token
 
     ByteCode_t type;
     const char *label;
-    union {
+    struct {
         char *string;
 
         struct {
             char *header;
             char *element;
             char separator;
         } header;
-        char *timespec;
     } data;
     int widthMin; ///< minimum field width
     int widthMax; ///< maximum field width
@@ -2747,7 +2747,7 @@ ftpUrlWith2f(HttpRequest * request)
 {
     String newbuf = "%2f";
 
-    if (request->protocol != AnyP::PROTO_FTP)
+    if (request->url.getScheme() != AnyP::PROTO_FTP)
         return NULL;
 
     if ( request->urlpath[0]=='/' ) {
@@ -26,6 +26,7 @@ typedef enum {
     SOURCEHASH_PARENT,
     PINNED,
     ORIGINAL_DST,
+    STANDBY_POOL,
     HIER_MAX
 } hier_code;
 
@@ -168,7 +168,7 @@ class htcpSpecifier : public StoreClient
 
     void setFrom(Ip::Address &from);
     void setDataHeader(htcpDataHeader *);
-    char *method;
+    const char *method;
     char *uri;
     char *version;
     char *req_hdrs;
@@ -1577,7 +1577,8 @@ htcpQuery(StoreEntry * e, HttpRequest * req, CachePeer * p)
     stuff.f1 = 1;
     stuff.response = 0;
     stuff.msg_id = ++msg_id_counter;
-    stuff.S.method = (char *) RequestMethodStr(req->method);
+    SBuf sb = req->method.image();
+    stuff.S.method = sb.c_str();
     stuff.S.uri = (char *) e->url();
     stuff.S.version = vbuf;
     HttpStateData::httpBuildRequestHeader(req, e, NULL, &hdr, flags);
@@ -1640,7 +1641,8 @@ htcpClear(StoreEntry * e, const char *uri, HttpRequest * req, const HttpRequestM
         stuff.reason = 0;
         break;
     }
-    stuff.S.method = (char *) RequestMethodStr(req->method);
+    SBuf sb = req->method.image();
+    stuff.S.method = sb.c_str();
     if (e == NULL || e->mem_obj == NULL) {
         if (uri == NULL) {
             return;
@@ -1046,7 +1046,7 @@ HttpStateData::statusIfComplete() const
      * connection.
      */
     if (!flags.request_sent) {
-        debugs(11, 2, "statusIfComplete: Request not yet fully sent \"" << RequestMethodStr(request->method) << " " << entry->url() << "\"" );
+        debugs(11, 2, "Request not yet fully sent " << request->method << ' ' << entry->url());
         return COMPLETE_NONPERSISTENT_MSG;
     }
 
@@ -1807,7 +1807,7 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
     if (!hdr_out->has(HDR_HOST)) {
         if (request->peer_domain) {
             hdr_out->putStr(HDR_HOST, request->peer_domain);
-        } else if (request->port == urlDefaultPort(request->protocol)) {
+        } else if (request->port == urlDefaultPort(request->url.getScheme())) {
             /* use port# only if not default */
             hdr_out->putStr(HDR_HOST, request->GetHost());
         } else {
@@ -1865,7 +1865,7 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
 
     /* append Front-End-Https */
     if (flags.front_end_https) {
-        if (flags.front_end_https == 1 || request->protocol == AnyP::PROTO_HTTPS)
+        if (flags.front_end_https == 1 || request->url.getScheme() == AnyP::PROTO_HTTPS)
             hdr_out->putStr(HDR_FRONT_END_HTTPS, "On");
     }
 
@@ -1958,7 +1958,7 @@ copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, co
         else {
             /* use port# only if not default */
 
-            if (request->port == urlDefaultPort(request->protocol)) {
+            if (request->port == urlDefaultPort(request->url.getScheme())) {
                 hdr_out->putStr(HDR_HOST, request->GetHost());
             } else {
                 httpHeaderPutStrf(hdr_out, HDR_HOST, "%s:%d",
@@ -2117,8 +2117,8 @@ HttpStateData::buildRequestPrefix(MemBuf * mb)
         url = urlCanonical(request);
     else
         url = request->urlpath.termedBuf();
-    mb->Printf("%s %s %s/%d.%d\r\n",
-               RequestMethodStr(request->method),
+    mb->Printf(SQUIDSBUFPH " %s %s/%d.%d\r\n",
+               SQUIDSBUFPRINT(request->method.image()),
                url && *url ? url : "/",
                AnyP::ProtocolType_str[httpver.protocol],
                httpver.major,httpver.minor);
@@ -2269,7 +2269,7 @@ HttpStateData::getMoreRequestBody(MemBuf &buf)
 void
 httpStart(FwdState *fwd)
 {
-    debugs(11, 3, "httpStart: \"" << RequestMethodStr(fwd->request->method) << " " << fwd->entry->url() << "\"" );
+    debugs(11, 3, fwd->request->method << ' ' << fwd->entry->url());
     AsyncJob::Start(new HttpStateData(fwd));
 }
 
@@ -13,7 +13,7 @@ libsquid_http_la_SOURCES = \
 	StatusLine.h
 
 MethodType.cc: MethodType.h $(top_srcdir)/src/mk-string-arrays.awk
-	($(AWK) -f $(top_srcdir)/src/mk-string-arrays.awk < $(srcdir)/MethodType.h | \
+	($(AWK) -f $(top_srcdir)/src/mk-string-arrays.awk sbuf=1 < $(srcdir)/MethodType.h | \
 		sed -e 's%METHOD_%%' -e 's%_C%-C%' >$@) || ($(RM) -f $@ && exit 1)
 
 CLEANFILES += MethodType.cc
@@ -1,6 +1,8 @@
 #ifndef SQUID_SRC_HTTP_METHODTYPE_H
 #define SQUID_SRC_HTTP_METHODTYPE_H
 
+#include "SBuf.h"
+
 namespace Http
 {
 
@@ -11,12 +13,6 @@ namespace Http
 typedef enum _method_t {
     METHOD_NONE = 0,
 
-#if NO_SPECIAL_HANDLING
-    // RFC 2068
-    METHOD_LINK,
-    METHOD_UNLINK,
-#endif
-
     // RFC 2616 (HTTP)
     METHOD_GET,
     METHOD_POST,
@@ -27,6 +23,12 @@ typedef enum _method_t {
     METHOD_OPTIONS,
     METHOD_DELETE,
 
+#if NO_SPECIAL_HANDLING
+    // RFC 2068
+    METHOD_LINK,
+    METHOD_UNLINK,
+#endif
+
     // RFC 3253
     METHOD_CHECKOUT,
     METHOD_CHECKIN,
@@ -83,12 +85,12 @@ typedef enum _method_t {
     METHOD_ENUM_END  // MUST be last, (yuck) this is used as an array-initialization index constant!
 } MethodType;
 
-extern const char *MethodType_str[];
+extern const SBuf MethodType_sb[];
 
-inline const char*
+inline const SBuf &
 MethodStr(const MethodType m)
 {
-    return MethodType_str[m];
+    return MethodType_sb[m];
 }
 
 }; // namespace Http
@@ -8,12 +8,15 @@ namespace Http
 
 /**
  * Stores HTTP version label information.
- * For example HTTP/1.0
+ *
+ * Squid being conditionally compliant with RFC 2616
+ * on both client and server connections the default
+ * value is HTTP/1.1.
  */
 class ProtocolVersion : public AnyP::ProtocolVersion
 {
 public:
-    ProtocolVersion() : AnyP::ProtocolVersion(AnyP::PROTO_HTTP,0,0) {}
+    ProtocolVersion() : AnyP::ProtocolVersion(AnyP::PROTO_HTTP,1,1) {}
 
     ProtocolVersion(unsigned int aMajor, unsigned int aMinor) : AnyP::ProtocolVersion(AnyP::PROTO_HTTP,aMajor,aMinor) {}
 };
@@ -7,12 +7,12 @@ Http::StatusCodeString(const Http::StatusCode status)
 {
     switch (status) {
 
-    // 000
+        // 000
     case Http::scNone:
         return "Init";		/* we init .status with code 0 */
         break;
 
-    // 100-199
+        // 100-199
     case Http::scContinue:
         return "Continue";
         break;
@@ -25,7 +25,7 @@ Http::StatusCodeString(const Http::StatusCode status)
         return "Processing";
         break;
 
-    // 200-299
+        // 200-299
     case Http::scOkay:
         return "OK";
         break;
@@ -66,7 +66,7 @@ Http::StatusCodeString(const Http::StatusCode status)
         return "IM Used";
         break;
 
-    // 300-399
+        // 300-399
     case Http::scMultipleChoices:
         return "Multiple Choices";
         break;
@@ -99,7 +99,7 @@ Http::StatusCodeString(const Http::StatusCode status)
         return "Permanent Redirect";
         break;
 
-    // 400-499
+        // 400-499
     case Http::scBadRequest:
         return "Bad Request";
         break;
@@ -200,7 +200,7 @@ Http::StatusCodeString(const Http::StatusCode status)
         return "Request Header Fields Too Large";
         break;
 
-    // 500-599
+        // 500-599
     case Http::scInternalServerError:
         return "Internal Server Error";
         break;
@@ -245,7 +245,7 @@ Http::StatusCodeString(const Http::StatusCode status)
         return "Network Authentication Required";
         break;
 
-    // 600+
+        // 600+
     case Http::scInvalidHeader:
     case Http::scHeaderTooLarge:
         // fall through to default.
@@ -73,6 +73,7 @@ internalStart(const Comm::ConnectionPointer &clientConn, HttpRequest * request,
         entry->append(msgbuf, strlen(msgbuf));
         entry->complete();
     } else if (0 == strncmp(upath, "/squid-internal-mgr/", 20)) {
+        debugs(17, 2, "calling CacheManager due to URL-path /squid-internal-mgr/");
         CacheManager::GetInstance()->Start(clientConn, request, entry);
     } else {
         debugObj(76, 1, "internalStart: unknown request:\n",
@@ -67,12 +67,18 @@ Log::Format::HttpdCombined(const AccessLogEntry::Pointer &al, Logfile * logfile)
     char clientip[MAX_IPSTRLEN];
     al->getLogClientIp(clientip, MAX_IPSTRLEN);
 
-    logfilePrintf(logfile, "%s %s %s [%s] \"%s %s %s/%d.%d\" %d %" PRId64 " \"%s\" \"%s\" %s%s:%s%s",
+    static SBuf method;
+    if (al->_private.method_str)
+        method.assign(al->_private.method_str);
+    else
+        method = al->http.method.image();
+
+    logfilePrintf(logfile, "%s %s %s [%s] \"" SQUIDSBUFPH " %s %s/%d.%d\" %d %" PRId64 " \"%s\" \"%s\" %s%s:%s%s",
                   clientip,
                   user_ident ? user_ident : dash_str,
                   user_auth ? user_auth : dash_str,
                   Time::FormatHttpd(squid_curtime),
-                  al->_private.method_str,
+                  SQUIDSBUFPRINT(method),
                   al->url,
                   AnyP::ProtocolType_str[al->http.version.protocol],
                   al->http.version.major, al->http.version.minor,
@@ -54,12 +54,18 @@ Log::Format::HttpdCommon(const AccessLogEntry::Pointer &al, Logfile * logfile)
     char clientip[MAX_IPSTRLEN];
     al->getLogClientIp(clientip, MAX_IPSTRLEN);
 
-    logfilePrintf(logfile, "%s %s %s [%s] \"%s %s %s/%d.%d\" %d %" PRId64 " %s%s:%s%s",
+    static SBuf method;
+    if (al->_private.method_str)
+        method.assign(al->_private.method_str);
+    else
+        method = al->http.method.image();
+
+    logfilePrintf(logfile, "%s %s %s [%s] \"" SQUIDSBUFPH " %s %s/%d.%d\" %d %" PRId64 " %s%s:%s%s",
                   clientip,
                   user_ident ? user_ident : dash_str,
                   user_auth ? user_auth : dash_str,
                   Time::FormatHttpd(squid_curtime),
-                  al->_private.method_str,
+                  SQUIDSBUFPRINT(method),
                   al->url,
                   AnyP::ProtocolType_str[al->http.version.protocol],
                   al->http.version.major, al->http.version.minor,
@@ -70,7 +70,13 @@ Log::Format::SquidNative(const AccessLogEntry::Pointer &al, Logfile * logfile)
     char clientip[MAX_IPSTRLEN];
     al->getLogClientIp(clientip, MAX_IPSTRLEN);
 
-    logfilePrintf(logfile, "%9ld.%03d %6d %s %s%s/%03d %" PRId64 " %s %s %s %s%s/%s %s%s",
+    static SBuf method;
+    if (al->_private.method_str)
+        method.assign(al->_private.method_str);
+    else
+        method = al->http.method.image();
+
+    logfilePrintf(logfile, "%9ld.%03d %6d %s %s%s/%03d %" PRId64 " " SQUIDSBUFPH " %s %s %s%s/%s %s%s",
                   (long int) current_time.tv_sec,
                   (int) current_time.tv_usec / 1000,
                   al->cache.msec,
@@ -79,7 +85,7 @@ Log::Format::SquidNative(const AccessLogEntry::Pointer &al, Logfile * logfile)
                   al->http.statusSfx(),
                   al->http.code,
                   al->http.clientReplySz.messageTotal(),
-                  al->_private.method_str,
+                  SQUIDSBUFPRINT(method),
                   al->url,
                   user ? user : dash_str,
                   al->hier.ping.timedout ? "TIMEOUT_" : "",
@@ -109,7 +109,7 @@ accessLogLogTo(CustomLog* log, AccessLogEntry::Pointer &al, ACLChecklist * check
     else if (al->htcp.opcode)
         al->_private.method_str = al->htcp.opcode;
     else
-        al->_private.method_str = RequestMethodStr(al->http.method);
+        al->_private.method_str = NULL;
 
     if (al->hier.host[0] == '\0')
         xstrncpy(al->hier.host, dash_str, SQUIDHOSTNAMELEN);
@@ -292,7 +292,11 @@ usage(void)
 #if USE_WIN32_SERVICE
             "       -i        Installs as a Windows Service (see -n option).\n"
 #endif
-            "       -k reconfigure|rotate|shutdown|interrupt|kill|debug|check|parse\n"
+            "       -k reconfigure|rotate|shutdown|"
+#ifdef SIGTTIN
+            "restart|"
+#endif
+            "interrupt|kill|debug|check|parse\n"
             "                 Parse configuration file, then send signal to \n"
             "                 running copy (except -k parse) and exit.\n"
             "       -n name   Specify service name to use for service operations\n"
@@ -497,7 +501,7 @@ mainParseOptions(int argc, char *argv[])
                 fatal("Need to add -DMALLOC_DBG when compiling to use -mX option");
 #endif
 
-            } 
+            }
             break;
 
         case 'n':
@@ -1907,10 +1911,10 @@ SquidShutdown()
 
     comm_exit();
 
-    memClean();
-
     RunRegisteredHere(RegisteredRunner::finishShutdown);
 
+    memClean();
+
     if (IamPrimaryProcess()) {
         if (Config.pidFilename && strcmp(Config.pidFilename, "none") != 0) {
             enter_suid();
@@ -33,7 +33,7 @@ void
 Mgr::ActionParams::pack(Ipc::TypedMsgHdr &msg) const
 {
     msg.putString(httpUri);
-    String foo(httpMethod.image());
+    String foo(httpMethod.image().toString());
     msg.putString(foo);
     msg.putPod(httpFlags);
     msg.putString(httpOrigin);
@@ -21,7 +21,7 @@ BEGIN {
 }
 
 # when namespace is encountered store it
-/^namespace [a-zA-Z]+/	{
+/^namespace *[a-zA-Z]+/	{
 	nspath = tolower($2) "/"		# nested folder
 	namespace = $2				# code namespace reconstruct
 	next
@@ -33,7 +33,8 @@ codeSkip == 1		{ next }
 
 /^[ \t]*[A-Z]/ {
 	split($1, t, ",")			# remove ,
-	Element[++e] = t[1]
+	if (sbuf) Element[++e] = "SBuf(\"" t[1] "\")"
+	else Element[++e] = "\"" t[1] "\""
 	next
 }
 
@@ -49,18 +50,20 @@ codeSkip == 1		{ next }
 	type = t[1]
         codeSkip = 1
 
+	if (sbuf) print "#include \"SBuf.h\""
 	print "#include \"" nspath type ".h\""
 
 	# if namesapce is not empty ??
 	if (namespace) print "namespace " namespace
 	if (namespace) print "{"
 
-	print "\nconst char *" type "_str[] = {"
+	if (sbuf) print "\nconst SBuf " type "_sb[] = {"
+	else print "\nconst char * " type "_str[] = {"
 	for ( i = 1; i < e; ++i)
 		if (Wrapper[i]) print Wrapper[i]
-		else print "\t\"" Element[i] "\","
+		else print "\t" Element[i] ","
 
-	print "\t\"" Element[i] "\""
+	print "\t" Element[i]
 	print "};"
 	if (namespace) print "}; // namespace " namespace
 	next
@@ -54,7 +54,9 @@
 #include "multicast.h"
 #include "neighbors.h"
 #include "NeighborTypeDomainList.h"
+#include "pconn.h"
 #include "PeerDigest.h"
+#include "PeerPoolMgr.h"
 #include "PeerSelectState.h"
 #include "RequestFlags.h"
 #include "SquidConfig.h"
@@ -246,13 +248,46 @@ peerWouldBePinged(const CachePeer * p, HttpRequest * request)
     return 1;
 }
 
+bool
+peerCanOpenMore(const CachePeer *p)
+{
+    const int effectiveLimit = p->max_conn <= 0 ? Squid_MaxFD : p->max_conn;
+    const int remaining = effectiveLimit - p->stats.conn_open;
+    debugs(15, 7, remaining << '=' << effectiveLimit << '-' << p->stats.conn_open);
+    return remaining > 0;
+}
+
+bool
+peerHasConnAvailable(const CachePeer *p)
+{
+    // Standby connections can be used without opening new connections.
+    const int standbys = p->standby.pool ? p->standby.pool->count() : 0;
+
+    // XXX: Some idle pconns can be used without opening new connections.
+    // Complication: Idle pconns cannot be reused for some requests.
+    const int usableIdles = 0;
+
+    const int available = standbys + usableIdles;
+    debugs(15, 7, available << '=' << standbys << '+' << usableIdles);
+    return available > 0;
+}
+
+void
+peerConnClosed(CachePeer *p)
+{
+    --p->stats.conn_open;
+    if (p->standby.waitingForClose && peerCanOpenMore(p)) {
+        p->standby.waitingForClose = false;
+        PeerPoolMgr::Checkpoint(p->standby.mgr, "conn closed");
+    }
+}
+
 /* Return TRUE if it is okay to send an HTTP request to this CachePeer. */
 int
 peerHTTPOkay(const CachePeer * p, HttpRequest * request)
 {
-    if (p->max_conn)
-        if (p->stats.conn_open >= p->max_conn)
-            return 0;
+    if (!peerCanOpenMore(p) && !peerHasConnAvailable(p))
+        return 0;
 
     if (!peerAllowedToUse(p, request))
         return 0;
@@ -432,7 +467,7 @@ peerClearRR()
 {
     CachePeer *p = NULL;
     for (p = Config.peers; p; p = p->next) {
-        p->rr_count = 0;
+        p->rr_count = 1;
     }
 }
 
@@ -446,6 +481,8 @@ peerAlive(CachePeer *p)
         debugs(15, DBG_IMPORTANT, "Detected REVIVED " << neighborTypeStr(p) << ": " << p->name);
         p->stats.logged_state = PEER_ALIVE;
         peerClearRR();
+        if (p->standby.mgr.valid())
+            PeerPoolMgr::Checkpoint(p->standby.mgr, "revived peer");
     }
 
     p->stats.last_reply = squid_curtime;
@@ -1190,6 +1227,9 @@ peerNoteDigestGone(CachePeer * p)
 static void
 peerDNSConfigure(const ipcache_addrs *ia, const DnsLookupDetails &, void *data)
 {
+    // TODO: connections to no-longer valid IP addresses should be
+    // closed when we can detect such IP addresses.
+
     CachePeer *p = (CachePeer *)data;
 
     int j;
@@ -1229,11 +1269,13 @@ peerDNSConfigure(const ipcache_addrs *ia, const DnsLookupDetails &, void *data)
         peerCountMcastPeersSchedule(p, 10);
 
 #if USE_ICMP
-    if (p->type != PEER_MULTICAST)
+    if (p->type != PEER_MULTICAST && IamWorkerProcess())
         if (!p->options.no_netdb_exchange)
             eventAddIsh("netdbExchangeStart", netdbExchangeStart, p, 30.0, 1);
 #endif
 
+    if (p->standby.mgr.valid())
+        PeerPoolMgr::Checkpoint(p->standby.mgr, "resolved peer");
 }
 
 static void
@@ -1565,6 +1607,8 @@ dump_peer_options(StoreEntry * sentry, CachePeer * p)
 
     if (p->max_conn > 0)
         storeAppendPrintf(sentry, " max-conn=%d", p->max_conn);
+    if (p->standby.limit > 0)
+        storeAppendPrintf(sentry, " standby=%d", p->standby.limit);
 
     if (p->options.originserver)
         storeAppendPrintf(sentry, " originserver");
@@ -81,6 +81,13 @@ void peerConnectSucceded(CachePeer *);
 void dump_peer_options(StoreEntry *, CachePeer *);
 int peerHTTPOkay(const CachePeer *, HttpRequest *);
 
+/// Whether we can open new connections to the peer (e.g., despite max-conn)
+bool peerCanOpenMore(const CachePeer *p);
+/// Whether the peer has idle or standby connections that can be used now
+bool peerHasConnAvailable(const CachePeer *p);
+/// Notifies peer of an associated connection closure.
+void peerConnClosed(CachePeer *p);
+
 CachePeer *whichPeer(const Ip::Address &from);
 
 #endif /* SQUID_NEIGHBORS_H_ */
@@ -31,13 +31,16 @@
  */
 
 #include "squid.h"
+#include "CachePeer.h"
 #include "comm.h"
 #include "comm/Connection.h"
 #include "fd.h"
 #include "fde.h"
 #include "globals.h"
 #include "mgr/Registration.h"
+#include "neighbors.h"
 #include "pconn.h"
+#include "PeerPoolMgr.h"
 #include "SquidConfig.h"
 #include "Store.h"
 
@@ -64,6 +67,11 @@ IdleConnList::~IdleConnList()
     if (parent_)
         parent_->unlinkList(this);
 
+    if (size_) {
+        parent_ = NULL; // prevent reentrant notifications and deletions
+        closeN(size_);
+    }
+
     delete[] theList_;
 
     xfree(hash.key);
@@ -292,6 +300,8 @@ IdleConnList::findAndClose(const Comm::ConnectionPointer &conn)
 {
     const int index = findIndexOf(conn);
     if (index >= 0) {
+        if (parent_)
+            parent_->notifyManager("idle conn closure");
         /* might delete this */
         removeAt(index);
         clearHandlers(conn);
@@ -366,15 +376,17 @@ PconnPool::dumpHash(StoreEntry *e) const
     hash_first(hid);
 
     int i = 0;
-    for (hash_link *walker = hid->next; walker; walker = hash_next(hid)) {
+    for (hash_link *walker = hash_next(hid); walker; walker = hash_next(hid)) {
         storeAppendPrintf(e, "\t item %d:\t%s\n", i, (char *)(walker->key));
         ++i;
     }
 }
 
 /* ========== PconnPool PUBLIC FUNCTIONS ============================================ */
 
-PconnPool::PconnPool(const char *aDescr) : table(NULL), descr(aDescr),
+PconnPool::PconnPool(const char *aDescr, const CbcPointer<PeerPoolMgr> &aMgr):
+        table(NULL), descr(aDescr),
+        mgr(aMgr),
         theCount(0)
 {
     int i;
@@ -386,10 +398,18 @@ PconnPool::PconnPool(const char *aDescr) : table(NULL), descr(aDescr),
     PconnModule::GetInstance()->add(this);
 }
 
+static void
+DeleteIdleConnList(void *hashItem)
+{
+    delete reinterpret_cast<IdleConnList*>(hashItem);
+}
+
 PconnPool::~PconnPool()
 {
-    descr = NULL;
+    PconnModule::GetInstance()->remove(this);
+    hashFreeItems(table, &DeleteIdleConnList);
     hashFreeMemory(table);
+    descr = NULL;
 }
 
 void
@@ -404,6 +424,7 @@ PconnPool::push(const Comm::ConnectionPointer &conn, const char *domain)
         debugs(48, 3, HERE << "Squid is shutting down. Refusing to do anything");
         return;
     }
+    // TODO: also close used pconns if we exceed peer max-conn limit
 
     const char *aKey = key(conn, domain);
     IdleConnList *list = (IdleConnList *) hash_lookup(table, aKey);
@@ -423,35 +444,64 @@ PconnPool::push(const Comm::ConnectionPointer &conn, const char *domain)
     snprintf(desc, FD_DESC_SZ, "Idle server: %s", aKey);
     fd_note(conn->fd, desc);
     debugs(48, 3, HERE << "pushed " << conn << " for " << aKey);
+
+    // successful push notifications resume multi-connection opening sequence
+    notifyManager("push");
 }
 
 Comm::ConnectionPointer
-PconnPool::pop(const Comm::ConnectionPointer &destLink, const char *domain, bool isRetriable)
+PconnPool::pop(const Comm::ConnectionPointer &dest, const char *domain, bool keepOpen)
 {
-    const char * aKey = key(destLink, domain);
+
+    const char * aKey = key(dest, domain);
 
     IdleConnList *list = (IdleConnList *)hash_lookup(table, aKey);
     if (list == NULL) {
         debugs(48, 3, HERE << "lookup for key {" << aKey << "} failed.");
+        // failure notifications resume standby conn creation after fdUsageHigh
+        notifyManager("pop failure");
         return Comm::ConnectionPointer();
     } else {
-        debugs(48, 3, HERE << "found " << hashKeyStr(&list->hash) << (isRetriable?"(to use)":"(to kill)") );
+        debugs(48, 3, HERE << "found " << hashKeyStr(&list->hash) <<
+               (keepOpen ? " to use" : " to kill"));
     }
 
     /* may delete list */
-    Comm::ConnectionPointer temp = list->findUseable(destLink);
-    if (!isRetriable && Comm::IsConnOpen(temp))
-        temp->close();
+    Comm::ConnectionPointer popped = list->findUseable(dest);
+    if (!keepOpen && Comm::IsConnOpen(popped))
+        popped->close();
+
+    // successful pop notifications replenish standby connections pool
+    notifyManager("pop");
+    return popped;
+}
 
-    return temp;
+void
+PconnPool::notifyManager(const char *reason)
+{
+    if (mgr.valid())
+        PeerPoolMgr::Checkpoint(mgr, reason);
 }
 
 void
-PconnPool::closeN(int n, const Comm::ConnectionPointer &destLink, const char *domain)
+PconnPool::closeN(int n)
 {
-    // TODO: optimize: we can probably do hash_lookup just once
-    for (int i = 0; i < n; ++i)
-        pop(destLink, domain, false); // may fail!
+    hash_table *hid = table;
+    hash_first(hid);
+
+    // close N connections, one per list, to treat all lists "fairly"
+    for (int i = 0; i < n && count(); ++i) {
+
+        hash_link *current = hash_next(hid);
+        if (!current) {
+            hash_first(hid);
+            current = hash_next(hid);
+            Must(current); // must have one because the count() was positive
+        }
+
+        // may delete current
+        reinterpret_cast<IdleConnList*>(current)->closeN(1);
+    }
 }
 
 void
@@ -477,11 +527,8 @@ PconnPool::noteUses(int uses)
  * This simple class exists only for the cache manager
  */
 
-PconnModule::PconnModule() : pools(NULL), poolCount(0)
+PconnModule::PconnModule(): pools()
 {
-    pools = (PconnPool **) xcalloc(MAX_NUM_PCONN_POOLS, sizeof(*pools));
-//TODO: re-link to MemPools. WAS:    pconn_fds_pool = memPoolCreate("pconn_fds", PCONN_FDS_SZ * sizeof(int));
-    debugs(48, DBG_CRITICAL, "persistent connection module initialized");
     registerWithCacheManager();
 }
 
@@ -505,21 +552,26 @@ PconnModule::registerWithCacheManager(void)
 void
 PconnModule::add(PconnPool *aPool)
 {
-    assert(poolCount < MAX_NUM_PCONN_POOLS);
-    *(pools+poolCount) = aPool;
-    ++poolCount;
+    pools.insert(aPool);
 }
 
 void
-PconnModule::dump(StoreEntry *e)
+PconnModule::remove(PconnPool *aPool)
 {
-    int i;
+    pools.erase(aPool);
+}
 
-    for (i = 0; i < poolCount; ++i) {
+void
+PconnModule::dump(StoreEntry *e)
+{
+    typedef Pools::const_iterator PCI;
+    int i = 0; // TODO: Why number pools if they all have names?
+    for (PCI p = pools.begin(); p != pools.end(); ++p, ++i) {
+        // TODO: Let each pool dump itself the way it wants to.
         storeAppendPrintf(e, "\n Pool %d Stats\n", i);
-        (*(pools+i))->dumpHist(e);
+        (*p)->dumpHist(e);
         storeAppendPrintf(e, "\n Pool %d Hash Table\n",i);
-        (*(pools+i))->dumpHash(e);
+        (*p)->dumpHash(e);
     }
 }
 
@@ -1,6 +1,9 @@
 #ifndef SQUID_PCONN_H
 #define SQUID_PCONN_H
 
+#include "base/CbcPointer.h"
+#include <set>
+
 /**
  \defgroup PConnAPI Persistent Connection API
  \ingroup Component
@@ -9,6 +12,7 @@
  */
 
 class PconnPool;
+class PeerPoolMgr;
 
 /* for CBDATA_CLASS2() macros */
 #include "cbdata.h"
@@ -17,9 +21,6 @@ class PconnPool;
 /* for IOCB */
 #include "comm.h"
 
-/// \ingroup PConnAPI
-#define MAX_NUM_PCONN_POOLS 10
-
 /// \ingroup PConnAPI
 #define PCONN_HIST_SZ (1<<16)
 
@@ -106,38 +107,46 @@ class PconnPool
 {
 
 public:
-    PconnPool(const char *);
+    PconnPool(const char *aDescription, const CbcPointer<PeerPoolMgr> &aMgr);
     ~PconnPool();
 
     void moduleInit();
     void push(const Comm::ConnectionPointer &serverConn, const char *domain);
 
     /**
-     * Updates destLink to point at an existing open connection if available and retriable.
-     * Otherwise, return false.
+     * Returns either a pointer to a popped connection to dest or nil.
+     * Closes the connection before returning its pointer unless keepOpen.
      *
-     * We close available persistent connection if the caller transaction is not
-     * retriable to avoid having a growing number of open connections when many
-     * transactions create persistent connections but are not retriable.
+     * A caller with a non-retriable transaction should set keepOpen to false
+     * and call pop() anyway, even though the caller does not want a pconn.
+     * This forces us to close an available persistent connection, avoiding
+     * creating a growing number of open connections when many transactions
+     * create (and push) persistent connections but are not retriable and,
+     * hence, do not need to pop a connection.
      */
-    Comm::ConnectionPointer pop(const Comm::ConnectionPointer &destLink, const char *domain, bool retriable);
+    Comm::ConnectionPointer pop(const Comm::ConnectionPointer &dest, const char *domain, bool keepOpen);
     void count(int uses);
     void dumpHist(StoreEntry *e) const;
     void dumpHash(StoreEntry *e) const;
     void unlinkList(IdleConnList *list);
     void noteUses(int uses);
-    void closeN(int n, const Comm::ConnectionPointer &destLink, const char *domain);
+    /// closes any n connections, regardless of their destination
+    void closeN(int n);
     int count() const { return theCount; }
     void noteConnectionAdded() { ++theCount; }
     void noteConnectionRemoved() { assert(theCount > 0); --theCount; }
 
+    // sends an async message to the pool manager, if any
+    void notifyManager(const char *reason);
+
 private:
 
     static const char *key(const Comm::ConnectionPointer &destLink, const char *domain);
 
     int hist[PCONN_HIST_SZ];
     hash_table *table;
     const char *descr;
+    CbcPointer<PeerPoolMgr> mgr; ///< optional pool manager (for notifications)
     int theCount; ///< the number of pooled connections
 };
 
@@ -162,15 +171,15 @@ class PconnModule
     void registerWithCacheManager(void);
 
     void add(PconnPool *);
+    void remove(PconnPool *); ///< unregister and forget about this pool object
 
     OBJH dump;
 
 private:
-    PconnPool **pools;
+    typedef std::set<PconnPool*> Pools; ///< unordered PconnPool collection
+    Pools pools; ///< all live pools
 
     static PconnModule * instance;
-
-    int poolCount;
 };
 
 #endif /* SQUID_PCONN_H */
@@ -156,9 +156,9 @@ peerSelect(Comm::ConnectionList * paths,
     ps_state *psstate;
 
     if (entry)
-        debugs(44, 3, "peerSelect: " << entry->url()  );
+        debugs(44, 3, *entry << ' ' << entry->url());
     else
-        debugs(44, 3, "peerSelect: " << RequestMethodStr(request->method));
+        debugs(44, 3, request->method);
 
     psstate = new ps_state;
 
@@ -257,7 +257,7 @@ peerSelectDnsPaths(ps_state *psstate)
             // construct a "result" adding the ORIGINAL_DST to the set instead of DIRECT
             Comm::ConnectionPointer p = new Comm::Connection();
             p->remote = req->clientConnectionManager->clientConnection->local;
-            p->peerType = fs->code;
+            p->peerType = ORIGINAL_DST; // fs->code is DIRECT. This fixes the display.
             p->setPeer(fs->_peer);
 
             // check for a configured outgoing address for this destination...
@@ -459,7 +459,7 @@ peerSelectFoo(ps_state * ps)
 
     StoreEntry *entry = ps->entry;
     HttpRequest *request = ps->request;
-    debugs(44, 3, "peerSelectFoo: '" << RequestMethodStr(request->method) << " " << request->GetHost() << "'");
+    debugs(44, 3, request->method << ' ' << request->GetHost());
 
     /** If we don't know whether DIRECT is permitted ... */
     if (ps->direct == DIRECT_UNKNOWN) {
@@ -691,7 +691,7 @@ peerGetSomeDirect(ps_state * ps)
         return;
 
     /* WAIS is not implemented natively */
-    if (ps->request->protocol == AnyP::PROTO_WAIS)
+    if (ps->request->url.getScheme() == AnyP::PROTO_WAIS)
         return;
 
     peerAddFwdServer(&ps->servers, NULL, HIER_DIRECT);
@@ -703,7 +703,7 @@ peerGetSomeParent(ps_state * ps)
     CachePeer *p;
     HttpRequest *request = ps->request;
     hier_code code = HIER_NONE;
-    debugs(44, 3, "peerGetSomeParent: " << RequestMethodStr(request->method) << " " << request->GetHost());
+    debugs(44, 3, request->method << ' ' << request->GetHost());
 
     if (ps->direct == DIRECT_YES)
         return;
@@ -131,8 +131,7 @@ redirectHandleReply(void *data, const HelperReply &reply)
                  * At this point altering the helper buffer in that way is not harmful, but annoying.
                  * When Bug 1961 is resolved and urlParse has a const API, this needs to die.
                  */
-                const char * result = reply.other().content();
-                const Http::StatusCode status = static_cast<Http::StatusCode>(atoi(result));
+                char * result = reply.modifiableOther().content();
 
                 HelperReply newReply;
                 // BACKWARD COMPATIBILITY 2012-06-15:
@@ -142,6 +141,20 @@ redirectHandleReply(void *data, const HelperReply &reply)
                 newReply.result = HelperReply::Okay;
                 newReply.notes.append(&reply.notes);
 
+                // check and parse for obsoleted Squid-2 urlgroup feature
+                if (*result == '!') {
+                    static int urlgroupWarning = 0;
+                    if (!urlgroupWarning++)
+                        debugs(85, DBG_IMPORTANT, "UPGRADE WARNING: URL rewriter using obsolete Squid-2 urlgroup feature needs updating.");
+                    if (char *t = strchr(result+1, '!')) {
+                        *t = '\0';
+                        newReply.notes.add("urlgroup", result+1);
+                        result = t + 1;
+                    }
+                }
+
+                const Http::StatusCode status = static_cast<Http::StatusCode>(atoi(result));
+
                 if (status == Http::scMovedPermanently
                         || status == Http::scFound
                         || status == Http::scSeeOther
@@ -162,7 +175,8 @@ redirectHandleReply(void *data, const HelperReply &reply)
                     // status code is not a redirect code (or does not exist)
                     // treat as a re-write URL request
                     // TODO: validate the URL produced here is RFC 2616 compliant URI
-                    newReply.notes.add("rewrite-url", reply.other().content());
+                    if (*result)
+                        newReply.notes.add("rewrite-url", result);
                 }
 
                 void *cbdata;
@@ -27,6 +27,8 @@ libsslsquid_la_SOURCES = \
 	ErrorDetail.h \
 	ErrorDetailManager.cc \
 	ErrorDetailManager.h \
+	PeerConnector.cc \
+	PeerConnector.h \
 	ProxyCerts.h \
 	ServerBump.cc \
 	ServerBump.h \
@@ -0,0 +1,544 @@
+/*
+ * DEBUG: section 17    Request Forwarding
+ *
+ */
+
+#include "squid.h"
+#include "acl/FilledChecklist.h"
+#include "base/AsyncCbdataCalls.h"
+#include "CachePeer.h"
+#include "client_side.h"
+#include "comm/Loops.h"
+#include "errorpage.h"
+#include "fde.h"
+#include "globals.h"
+#include "HttpRequest.h"
+#include "neighbors.h"
+#include "SquidConfig.h"
+#include "ssl/cert_validate_message.h"
+#include "ssl/Config.h"
+#include "ssl/ErrorDetail.h"
+#include "ssl/helper.h"
+#include "ssl/PeerConnector.h"
+#include "ssl/ServerBump.h"
+#include "ssl/support.h"
+
+CBDATA_NAMESPACED_CLASS_INIT(Ssl, PeerConnector);
+
+Ssl::PeerConnector::PeerConnector(
+    HttpRequestPointer &aRequest,
+    const Comm::ConnectionPointer &aServerConn,
+    AsyncCall::Pointer &aCallback):
+        AsyncJob("Ssl::PeerConnector"),
+        request(aRequest),
+        serverConn(aServerConn),
+        callback(aCallback)
+{
+    // if this throws, the caller's cb dialer is not our CbDialer
+    Must(dynamic_cast<CbDialer*>(callback->getDialer()));
+}
+
+Ssl::PeerConnector::~PeerConnector()
+{
+    debugs(83, 5, "Peer connector " << this << " gone");
+}
+
+bool Ssl::PeerConnector::doneAll() const
+{
+    return (!callback || callback->canceled()) && AsyncJob::doneAll();
+}
+
+/// Preps connection and SSL state. Calls negotiate().
+void
+Ssl::PeerConnector::start()
+{
+    AsyncJob::start();
+
+    if (prepareSocket()) {
+        initializeSsl();
+        negotiateSsl();
+    }
+}
+
+void
+Ssl::PeerConnector::commCloseHandler(const CommCloseCbParams &params)
+{
+    debugs(83, 5, "FD " << params.fd << ", Ssl::PeerConnector=" << params.data);
+    connectionClosed("Ssl::PeerConnector::commCloseHandler");
+}
+
+void
+Ssl::PeerConnector::connectionClosed(const char *reason)
+{
+    mustStop(reason);
+    callback = NULL;
+}
+
+bool
+Ssl::PeerConnector::prepareSocket()
+{
+    const int fd = serverConnection()->fd;
+    if (!Comm::IsConnOpen(serverConn) || fd_table[serverConn->fd].closing()) {
+        connectionClosed("Ssl::PeerConnector::prepareSocket");
+        return false;
+    }
+
+    // watch for external connection closures
+    typedef CommCbMemFunT<Ssl::PeerConnector, CommCloseCbParams> Dialer;
+    closeHandler = JobCallback(9, 5, Dialer, this, Ssl::PeerConnector::commCloseHandler);
+    comm_add_close_handler(fd, closeHandler);
+    return true;
+}
+
+void
+Ssl::PeerConnector::initializeSsl()
+{
+    SSL *ssl;
+    SSL_CTX *sslContext = NULL;
+    const CachePeer *peer = serverConnection()->getPeer();
+    const int fd = serverConnection()->fd;
+
+    if (peer) {
+        assert(peer->use_ssl);
+        sslContext = peer->sslContext;
+    } else {
+        sslContext = ::Config.ssl_client.sslContext;
+    }
+
+    assert(sslContext);
+
+    if ((ssl = SSL_new(sslContext)) == NULL) {
+        ErrorState *anErr = new ErrorState(ERR_SOCKET_FAILURE, Http::scInternalServerError, request.getRaw());
+        anErr->xerrno = errno;
+        debugs(83, DBG_IMPORTANT, "Error allocating SSL handle: " << ERR_error_string(ERR_get_error(), NULL));
+        bail(anErr);
+        return;
+    }
+
+    SSL_set_fd(ssl, fd);
+
+    if (peer) {
+        if (peer->ssldomain)
+            SSL_set_ex_data(ssl, ssl_ex_index_server, peer->ssldomain);
+
+#if NOT_YET
+
+        else if (peer->name)
+            SSL_set_ex_data(ssl, ssl_ex_index_server, peer->name);
+
+#endif
+
+        else
+            SSL_set_ex_data(ssl, ssl_ex_index_server, peer->host);
+
+        if (peer->sslSession)
+            SSL_set_session(ssl, peer->sslSession);
+
+    } else {
+        // While we are peeking at the certificate, we may not know the server
+        // name that the client will request (after interception or CONNECT)
+        // unless it was the CONNECT request with a user-typed address.
+        const char *hostname = request->GetHost();
+        const bool hostnameIsIp = request->GetHostIsNumeric();
+        const bool isConnectRequest = request->clientConnectionManager.valid() &&
+                                      !request->clientConnectionManager->port->flags.isIntercepted();
+        if (!request->flags.sslPeek || isConnectRequest)
+            SSL_set_ex_data(ssl, ssl_ex_index_server, (void*)hostname);
+
+        // Use SNI TLS extension only when we connect directly
+        // to the origin server and we know the server host name.
+        if (!hostnameIsIp)
+            Ssl::setClientSNI(ssl, hostname);
+    }
+
+    // If CertValidation Helper used do not lookup checklist for errors,
+    // but keep a list of errors to send it to CertValidator
+    if (!Ssl::TheConfig.ssl_crt_validator) {
+        // Create the ACL check list now, while we have access to more info.
+        // The list is used in ssl_verify_cb() and is freed in ssl_free().
+        if (acl_access *acl = ::Config.ssl_client.cert_error) {
+            ACLFilledChecklist *check = new ACLFilledChecklist(acl, request.getRaw(), dash_str);
+            // check->fd(fd); XXX: need client FD here
+            SSL_set_ex_data(ssl, ssl_ex_index_cert_error_check, check);
+        }
+    }
+
+    // store peeked cert to check SQUID_X509_V_ERR_CERT_CHANGE
+    X509 *peeked_cert;
+    if (request->clientConnectionManager.valid() &&
+            request->clientConnectionManager->serverBump() &&
+            (peeked_cert = request->clientConnectionManager->serverBump()->serverCert.get())) {
+        CRYPTO_add(&(peeked_cert->references),1,CRYPTO_LOCK_X509);
+        SSL_set_ex_data(ssl, ssl_ex_index_ssl_peeked_cert, peeked_cert);
+    }
+
+    fd_table[fd].ssl = ssl;
+    fd_table[fd].read_method = &ssl_read_method;
+    fd_table[fd].write_method = &ssl_write_method;
+}
+
+void
+Ssl::PeerConnector::negotiateSsl()
+{
+    if (!Comm::IsConnOpen(serverConnection()) || fd_table[serverConnection()->fd].closing())
+        return;
+
+    const int fd = serverConnection()->fd;
+    SSL *ssl = fd_table[fd].ssl;
+    const int result = SSL_connect(ssl);
+    if (result <= 0) {
+        handleNegotiateError(result);
+        return; // we might be gone by now
+    }
+
+    if (request->clientConnectionManager.valid()) {
+        // remember the server certificate from the ErrorDetail object
+        if (Ssl::ServerBump *serverBump = request->clientConnectionManager->serverBump()) {
+            serverBump->serverCert.reset(SSL_get_peer_certificate(ssl));
+
+            // remember validation errors, if any
+            if (Ssl::CertErrors *errs = static_cast<Ssl::CertErrors *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors)))
+                serverBump->sslErrors = cbdataReference(errs);
+        }
+    }
+
+    if (serverConnection()->getPeer() && !SSL_session_reused(ssl)) {
+        if (serverConnection()->getPeer()->sslSession)
+            SSL_SESSION_free(serverConnection()->getPeer()->sslSession);
+
+        serverConnection()->getPeer()->sslSession = SSL_get1_session(ssl);
+    }
+
+    if (Ssl::TheConfig.ssl_crt_validator) {
+        Ssl::CertValidationRequest validationRequest;
+        // WARNING: Currently we do not use any locking for any of the
+        // members of the Ssl::CertValidationRequest class. In this code the
+        // Ssl::CertValidationRequest object used only to pass data to
+        // Ssl::CertValidationHelper::submit method.
+        validationRequest.ssl = ssl;
+        validationRequest.domainName = request->GetHost();
+        if (Ssl::CertErrors *errs = static_cast<Ssl::CertErrors *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors)))
+            // validationRequest disappears on return so no need to cbdataReference
+            validationRequest.errors = errs;
+        else
+            validationRequest.errors = NULL;
+        try {
+            debugs(83, 5, "Sending SSL certificate for validation to ssl_crtvd.");
+            Ssl::CertValidationHelper::GetInstance()->sslSubmit(validationRequest, sslCrtvdHandleReplyWrapper, this);
+            return;
+        } catch (const std::exception &e) {
+            debugs(83, DBG_IMPORTANT, "ERROR: Failed to compose ssl_crtvd " <<
+                   "request for " << validationRequest.domainName <<
+                   " certificate: " << e.what() << "; will now block to " <<
+                   "validate that certificate.");
+            // fall through to do blocking in-process generation.
+            ErrorState *anErr = new ErrorState(ERR_GATEWAY_FAILURE, Http::scInternalServerError, request.getRaw());
+            bail(anErr);
+            if (serverConnection()->getPeer()) {
+                peerConnectFailed(serverConnection()->getPeer());
+            }
+            serverConn->close();
+            return;
+        }
+    }
+
+    callBack();
+}
+
+void
+Ssl::PeerConnector::sslCrtvdHandleReplyWrapper(void *data, Ssl::CertValidationResponse const &validationResponse)
+{
+    Ssl::PeerConnector *connector = (Ssl::PeerConnector *)(data);
+    connector->sslCrtvdHandleReply(validationResponse);
+}
+
+void
+Ssl::PeerConnector::sslCrtvdHandleReply(Ssl::CertValidationResponse const &validationResponse)
+{
+    Ssl::CertErrors *errs = NULL;
+    Ssl::ErrorDetail *errDetails = NULL;
+    bool validatorFailed = false;
+    if (!Comm::IsConnOpen(serverConnection())) {
+        return;
+    }
+
+    debugs(83,5, request->GetHost() << " cert validation result: " << validationResponse.resultCode);
+
+    if (validationResponse.resultCode == HelperReply::Error)
+        errs = sslCrtvdCheckForErrors(validationResponse, errDetails);
+    else if (validationResponse.resultCode != HelperReply::Okay)
+        validatorFailed = true;
+
+    if (!errDetails && !validatorFailed) {
+        callBack();
+        return;
+    }
+
+    ErrorState *anErr = NULL;
+    if (validatorFailed) {
+        anErr = new ErrorState(ERR_GATEWAY_FAILURE, Http::scInternalServerError, request.getRaw());
+    }  else {
+
+        // Check the list error with
+        if (errDetails && request->clientConnectionManager.valid()) {
+            // remember the server certificate from the ErrorDetail object
+            if (Ssl::ServerBump *serverBump = request->clientConnectionManager->serverBump()) {
+                // remember validation errors, if any
+                if (errs) {
+                    if (serverBump->sslErrors)
+                        cbdataReferenceDone(serverBump->sslErrors);
+                    serverBump->sslErrors = cbdataReference(errs);
+                }
+            }
+        }
+
+        anErr =  new ErrorState(ERR_SECURE_CONNECT_FAIL, Http::scServiceUnavailable, request.getRaw());
+        anErr->detail = errDetails;
+        /*anErr->xerrno= Should preserved*/
+    }
+
+    bail(anErr);
+    if (serverConnection()->getPeer()) {
+        peerConnectFailed(serverConnection()->getPeer());
+    }
+    serverConn->close();
+    return;
+}
+
+/// Checks errors in the cert. validator response against sslproxy_cert_error.
+/// The first honored error, if any, is returned via errDetails parameter.
+/// The method returns all seen errors except SSL_ERROR_NONE as Ssl::CertErrors.
+Ssl::CertErrors *
+Ssl::PeerConnector::sslCrtvdCheckForErrors(Ssl::CertValidationResponse const &resp, Ssl::ErrorDetail *& errDetails)
+{
+    Ssl::CertErrors *errs = NULL;
+
+    ACLFilledChecklist *check = NULL;
+    if (acl_access *acl = ::Config.ssl_client.cert_error)
+        check = new ACLFilledChecklist(acl, request.getRaw(), dash_str);
+
+    SSL *ssl = fd_table[serverConnection()->fd].ssl;
+    typedef Ssl::CertValidationResponse::RecvdErrors::const_iterator SVCRECI;
+    for (SVCRECI i = resp.errors.begin(); i != resp.errors.end(); ++i) {
+        debugs(83, 7, "Error item: " << i->error_no << " " << i->error_reason);
+
+        assert(i->error_no != SSL_ERROR_NONE);
+
+        if (!errDetails) {
+            bool allowed = false;
+            if (check) {
+                check->sslErrors = new Ssl::CertErrors(Ssl::CertError(i->error_no, i->cert.get()));
+                if (check->fastCheck() == ACCESS_ALLOWED)
+                    allowed = true;
+            }
+            // else the Config.ssl_client.cert_error access list is not defined
+            // and the first error will cause the error page
+
+            if (allowed) {
+                debugs(83, 3, "bypassing SSL error " << i->error_no << " in " << "buffer");
+            } else {
+                debugs(83, 5, "confirming SSL error " << i->error_no);
+                X509 *brokenCert = i->cert.get();
+                Ssl::X509_Pointer peerCert(SSL_get_peer_certificate(ssl));
+                const char *aReason = i->error_reason.empty() ? NULL : i->error_reason.c_str();
+                errDetails = new Ssl::ErrorDetail(i->error_no, peerCert.get(), brokenCert, aReason);
+            }
+            if (check) {
+                delete check->sslErrors;
+                check->sslErrors = NULL;
+            }
+        }
+
+        if (!errs)
+            errs = new Ssl::CertErrors(Ssl::CertError(i->error_no, i->cert.get()));
+        else
+            errs->push_back_unique(Ssl::CertError(i->error_no, i->cert.get()));
+    }
+    if (check)
+        delete check;
+
+    return errs;
+}
+
+/// A wrapper for Comm::SetSelect() notifications.
+void
+Ssl::PeerConnector::NegotiateSsl(int, void *data)
+{
+    PeerConnector *pc = static_cast<PeerConnector*>(data);
+    // Use job calls to add done() checks and other job logic/protections.
+    CallJobHere(83, 7, pc, Ssl::PeerConnector, negotiateSsl);
+}
+
+void
+Ssl::PeerConnector::handleNegotiateError(const int ret)
+{
+    const int fd = serverConnection()->fd;
+    unsigned long ssl_lib_error = SSL_ERROR_NONE;
+    SSL *ssl = fd_table[fd].ssl;
+    int ssl_error = SSL_get_error(ssl, ret);
+
+#ifdef EPROTO
+    int sysErrNo = EPROTO;
+#else
+    int sysErrNo = EACCES;
+#endif
+
+    switch (ssl_error) {
+
+    case SSL_ERROR_WANT_READ:
+        Comm::SetSelect(fd, COMM_SELECT_READ, &NegotiateSsl, this, 0);
+        return;
+
+    case SSL_ERROR_WANT_WRITE:
+        Comm::SetSelect(fd, COMM_SELECT_WRITE, &NegotiateSsl, this, 0);
+        return;
+
+    case SSL_ERROR_SSL:
+    case SSL_ERROR_SYSCALL:
+        ssl_lib_error = ERR_get_error();
+
+        // store/report errno when ssl_error is SSL_ERROR_SYSCALL, ssl_lib_error is 0, and ret is -1
+        if (ssl_error == SSL_ERROR_SYSCALL && ret == -1 && ssl_lib_error == 0)
+            sysErrNo = errno;
+
+        debugs(83, DBG_IMPORTANT, "Error negotiating SSL on FD " << fd <<
+               ": " << ERR_error_string(ssl_lib_error, NULL) << " (" <<
+               ssl_error << "/" << ret << "/" << errno << ")");
+
+        break; // proceed to the general error handling code
+
+    default:
+        break; // no special error handling for all other errors
+    }
+
+    ErrorState *const anErr = ErrorState::NewForwarding(ERR_SECURE_CONNECT_FAIL, request.getRaw());
+    anErr->xerrno = sysErrNo;
+
+    Ssl::ErrorDetail *errFromFailure = (Ssl::ErrorDetail *)SSL_get_ex_data(ssl, ssl_ex_index_ssl_error_detail);
+    if (errFromFailure != NULL) {
+        // The errFromFailure is attached to the ssl object
+        // and will be released when ssl object destroyed.
+        // Copy errFromFailure to a new Ssl::ErrorDetail object
+        anErr->detail = new Ssl::ErrorDetail(*errFromFailure);
+    } else {
+        // server_cert can be NULL here
+        X509 *server_cert = SSL_get_peer_certificate(ssl);
+        anErr->detail = new Ssl::ErrorDetail(SQUID_ERR_SSL_HANDSHAKE, server_cert, NULL);
+        X509_free(server_cert);
+    }
+
+    if (ssl_lib_error != SSL_ERROR_NONE)
+        anErr->detail->setLibError(ssl_lib_error);
+
+    if (request->clientConnectionManager.valid()) {
+        // remember the server certificate from the ErrorDetail object
+        if (Ssl::ServerBump *serverBump = request->clientConnectionManager->serverBump()) {
+            serverBump->serverCert.resetAndLock(anErr->detail->peerCert());
+
+            // remember validation errors, if any
+            if (Ssl::CertErrors *errs = static_cast<Ssl::CertErrors*>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors)))
+                serverBump->sslErrors = cbdataReference(errs);
+        }
+
+        // For intercepted connections, set the host name to the server
+        // certificate CN. Otherwise, we just hope that CONNECT is using
+        // a user-entered address (a host name or a user-entered IP).
+        const bool isConnectRequest = !request->clientConnectionManager->port->flags.isIntercepted();
+        if (request->flags.sslPeek && !isConnectRequest) {
+            if (X509 *srvX509 = anErr->detail->peerCert()) {
+                if (const char *name = Ssl::CommonHostName(srvX509)) {
+                    request->SetHost(name);
+                    debugs(83, 3, HERE << "reset request host: " << name);
+                }
+            }
+        }
+    }
+
+    bail(anErr);
+}
+
+void
+Ssl::PeerConnector::bail(ErrorState *error)
+{
+    Must(error); // or the recepient will not know there was a problem
+
+    // XXX: forward.cc calls peerConnectSucceeded() after an OK TCP connect but
+    // we call peerConnectFailed() if SSL failed afterwards. Is that OK?
+    // It is not clear whether we should call peerConnectSucceeded/Failed()
+    // based on TCP results, SSL results, or both. And the code is probably not
+    // consistent in this aspect across tunnelling and forwarding modules.
+    if (CachePeer *p = serverConnection()->getPeer())
+        peerConnectFailed(p);
+
+    Must(callback != NULL);
+    CbDialer *dialer = dynamic_cast<CbDialer*>(callback->getDialer());
+    Must(dialer);
+    dialer->answer().error = error;
+
+    callBack();
+    // Our job is done. The callabck recepient will probably close the failed
+    // peer connection and try another peer or go direct (if possible). We
+    // can close the connection ourselves (our error notification would reach
+    // the recepient before the fd-closure notification), but we would rather
+    // minimize the number of fd-closure notifications and let the recepient
+    // manage the TCP state of the connection.
+}
+
+void
+Ssl::PeerConnector::callBack()
+{
+    AsyncCall::Pointer cb = callback;
+    // Do this now so that if we throw below, swanSong() assert that we _tried_
+    // to call back holds.
+    callback = NULL; // this should make done() true
+
+    // remove close handler
+    comm_remove_close_handler(serverConnection()->fd, closeHandler);
+
+    CbDialer *dialer = dynamic_cast<CbDialer*>(cb->getDialer());
+    Must(dialer);
+    dialer->answer().conn = serverConnection();
+    ScheduleCallHere(cb);
+}
+
+void
+Ssl::PeerConnector::swanSong()
+{
+    // XXX: unregister fd-closure monitoring and CommSetSelect interest, if any
+    AsyncJob::swanSong();
+    assert(!callback); // paranoid: we have not left the caller waiting
+}
+
+const char *
+Ssl::PeerConnector::status() const
+{
+    static MemBuf buf;
+    buf.reset();
+
+    // TODO: redesign AsyncJob::status() API to avoid this
+    // id and stop reason reporting duplication.
+    buf.append(" [", 2);
+    if (stopReason != NULL) {
+        buf.Printf("Stopped, reason:");
+        buf.Printf("%s",stopReason);
+    }
+    if (serverConn != NULL)
+        buf.Printf(" FD %d", serverConn->fd);
+    buf.Printf(" %s%u]", id.Prefix, id.value);
+    buf.terminate();
+
+    return buf.content();
+}
+
+/* PeerConnectorAnswer */
+
+Ssl::PeerConnectorAnswer::~PeerConnectorAnswer()
+{
+    delete error.get();
+}
+
+std::ostream &
+Ssl::operator <<(std::ostream &os, const Ssl::PeerConnectorAnswer &answer)
+{
+    return os << answer.conn << ", " << answer.error;
+}
@@ -0,0 +1,173 @@
+/*
+ * SQUID Web Proxy Cache          http://www.squid-cache.org/
+ * ----------------------------------------------------------
+ *
+ *  Squid is the result of efforts by numerous individuals from
+ *  the Internet community; see the CONTRIBUTORS file for full
+ *  details.   Many organizations have provided support for Squid's
+ *  development; see the SPONSORS file for full details.  Squid is
+ *  Copyrighted (C) 2001 by the Regents of the University of
+ *  California; see the COPYRIGHT file for full details.  Squid
+ *  incorporates software developed and/or copyrighted by other
+ *  sources; see the CREDITS file for full details.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+ *
+ */
+#ifndef SQUID_SSL_PEER_CONNECTOR_H
+#define SQUID_SSL_PEER_CONNECTOR_H
+
+#include "base/AsyncCbdataCalls.h"
+#include "base/AsyncJob.h"
+#include "ssl/support.h"
+#include <iosfwd>
+
+class HttpRequest;
+class ErrorState;
+
+namespace Ssl
+{
+
+class ErrorDetail;
+class CertValidationResponse;
+
+/// PeerConnector results (supplied via a callback).
+/// The connection to peer was secured if and only if the error member is nil.
+class PeerConnectorAnswer
+{
+public:
+    ~PeerConnectorAnswer(); ///< deletes error if it is still set
+    Comm::ConnectionPointer conn; ///< peer connection (secured on success)
+
+    /// answer recepients must clear the error member in order to keep its info
+    /// XXX: We should refcount ErrorState instead of cbdata-protecting it.
+    CbcPointer<ErrorState> error; ///< problem details (nil on success)
+};
+
+/**
+ \par
+ * Connects Squid client-side to an SSL peer (cache_peer ... ssl).
+ * Handles peer certificate validation.
+ * Used by TunnelStateData, FwdState, and PeerPoolMgr to start talking to an
+ * SSL peer.
+ \par
+ * The caller receives a call back with PeerConnectorAnswer. If answer.error
+ * is not nil, then there was an error and the SSL connection to the SSL peer
+ * was not fully established. The error object is suitable for error response
+ * generation.
+ \par
+ * The caller must monitor the connection for closure because this
+ * job will not inform the caller about such events.
+ \par
+ * The caller must monitor the overall connection establishment timeout and
+ * close the connection on timeouts. This is probably better than having
+ * dedicated (or none at all!) timeouts for peer selection, DNS lookup,
+ * TCP handshake, SSL handshake, etc. Some steps may have their own timeout,
+ * but not all steps should be forced to have theirs. XXX: Neither tunnel.cc
+ * nor forward.cc have a "overall connection establishment" timeout. We need
+ * to change their code so that they start monitoring earlier and close on
+ * timeouts. This change may need to be discussed on squid-dev.
+ \par
+ * This job never closes the connection, even on errors. If a 3rd-party
+ * closes the connection, this job simply quits without informing the caller.
+*/
+class PeerConnector: virtual public AsyncJob
+{
+public:
+    /// Callback dialier API to allow PeerConnector to set the answer.
+    class CbDialer
+    {
+    public:
+        virtual ~CbDialer() {}
+        /// gives PeerConnector access to the in-dialer answer
+        virtual PeerConnectorAnswer &answer() = 0;
+    };
+
+    typedef RefCount<HttpRequest> HttpRequestPointer;
+
+public:
+    PeerConnector(HttpRequestPointer &aRequest,
+                  const Comm::ConnectionPointer &aServerConn,
+                  AsyncCall::Pointer &aCallback);
+    virtual ~PeerConnector();
+
+protected:
+    // AsyncJob API
+    virtual void start();
+    virtual bool doneAll() const;
+    virtual void swanSong();
+    virtual const char *status() const;
+
+    /// The comm_close callback handler.
+    void commCloseHandler(const CommCloseCbParams &params);
+
+    /// Inform us that the connection is closed. Does the required clean-up.
+    void connectionClosed(const char *reason);
+
+    /// Sets up TCP socket-related notification callbacks if things go wrong.
+    /// If socket already closed return false, else install the comm_close
+    /// handler to monitor the socket.
+    bool prepareSocket();
+
+    void initializeSsl(); ///< Initializes SSL state
+
+    /// Performs a single secure connection negotiation step.
+    /// It is called multiple times untill the negotiation finish or aborted.
+    void negotiateSsl();
+
+    /// Called when the SSL negotiation step aborted because data needs to
+    /// be transferred to/from SSL server or on error. In the first case
+    /// setups the appropriate Comm::SetSelect handler. In second case
+    /// fill an error and report to the PeerConnector caller.
+    void handleNegotiateError(const int result);
+
+private:
+    PeerConnector(const PeerConnector &); // not implemented
+    PeerConnector &operator =(const PeerConnector &); // not implemented
+
+    /// mimics FwdState to minimize changes to FwdState::initiate/negotiateSsl
+    Comm::ConnectionPointer const &serverConnection() const { return serverConn; }
+
+    void bail(ErrorState *error); ///< Return an error to the PeerConnector caller
+
+    /// Callback the caller class, and pass the ready to communicate secure
+    /// connection or an error if PeerConnector failed.
+    void callBack();
+
+    /// Process response from cert validator helper
+    void sslCrtvdHandleReply(Ssl::CertValidationResponse const &);
+
+    /// Check SSL errors returned from cert validator against sslproxy_cert_error access list
+    Ssl::CertErrors *sslCrtvdCheckForErrors(Ssl::CertValidationResponse const &, Ssl::ErrorDetail *&);
+
+    /// Callback function called when squid receive message from cert validator helper
+    static void sslCrtvdHandleReplyWrapper(void *data, Ssl::CertValidationResponse const &);
+
+    /// A wrapper function for negotiateSsl for use with Comm::SetSelect
+    static void NegotiateSsl(int fd, void *data);
+
+    HttpRequestPointer request; ///< peer connection trigger or cause
+    Comm::ConnectionPointer serverConn; ///< TCP connection to the peer
+    AsyncCall::Pointer callback; ///< we call this with the results
+    AsyncCall::Pointer closeHandler; ///< we call this when the connection closed
+
+    CBDATA_CLASS2(PeerConnector);
+};
+
+std::ostream &operator <<(std::ostream &os, const Ssl::PeerConnectorAnswer &a);
+
+} // namespace Ssl
+
+#endif /* SQUID_PEER_CONNECTOR_H */
@@ -80,7 +80,7 @@ storeLog(int tag, const StoreEntry * e)
         String ctype=(reply->content_type.size() ? reply->content_type.termedBuf() : str_unknown);
 
         logfileLineStart(storelog);
-        logfilePrintf(storelog, "%9d.%03d %-7s %02d %08X %s %4d %9d %9d %9d " SQUIDSTRINGPH " %" PRId64 "/%" PRId64 " %s %s\n",
+        logfilePrintf(storelog, "%9d.%03d %-7s %02d %08X %s %4d %9d %9d %9d " SQUIDSTRINGPH " %" PRId64 "/%" PRId64 " " SQUIDSBUFPH " %s\n",
                       (int) current_time.tv_sec,
                       (int) current_time.tv_usec / 1000,
                       storeLogTags[tag],
@@ -94,7 +94,7 @@ storeLog(int tag, const StoreEntry * e)
                       SQUIDSTRINGPRINT(ctype),
                       reply->content_length,
                       e->contentLen(),
-                      RequestMethodStr(mem->method),
+                      SQUIDSBUFPRINT(mem->method.image()),
                       mem->logUri());
         logfileLineEnd(storelog);
     } else {
@@ -102,18 +102,6 @@ struct _FileIterator {
 /* globals */
 static time_t cur_time = -1;	/* timestamp of the current log entry */
 
-/* copied from url.c */
-const char *RequestMethodStr[] = {
-    "NONE",
-    "GET",
-    "POST",
-    "PUT",
-    "HEAD",
-    "CONNECT",
-    "TRACE",
-    "PURGE"
-};
-
 /* copied from url.c */
 static HttpRequestMethod
 methodStrToId(const char *s)
@@ -54,6 +54,7 @@ STUB_SOURCE= tests/STUB.h \
 	tests/stub_mem.cc \
 	tests/stub_mem_node.cc \
 	tests/stub_mime.cc \
+	tests/stub_neighbors.cc \
 	tests/stub_pconn.cc \
 	tests/stub_redirect.cc \
 	tests/stub_stat.cc \
@@ -0,0 +1,9 @@
+#include "squid.h"
+
+#define STUB_API "neighbors.cc"
+#include "tests/STUB.h"
+
+#include "neighbors.h"
+
+void
+peerConnClosed(CachePeer *p) STUB
@@ -13,7 +13,7 @@ IdleConnList::~IdleConnList() STUB
 void IdleConnList::push(const Comm::ConnectionPointer &conn) STUB
 Comm::ConnectionPointer IdleConnList::findUseable(const Comm::ConnectionPointer &key) STUB_RETVAL(Comm::ConnectionPointer())
 void IdleConnList::clearHandlers(const Comm::ConnectionPointer &conn) STUB
-PconnPool::PconnPool(const char *) STUB
+PconnPool::PconnPool(const char *, const CbcPointer<PeerPoolMgr>&) STUB
 PconnPool::~PconnPool() STUB
 void PconnPool::moduleInit() STUB
 void PconnPool::push(const Comm::ConnectionPointer &serverConn, const char *domain) STUB
@@ -43,7 +43,7 @@ testHttpRequest::testCreateFromUrlAndMethod()
     CPPUNIT_ASSERT(aRequest->method == Http::METHOD_GET);
     CPPUNIT_ASSERT_EQUAL(String("foo"), String(aRequest->GetHost()));
     CPPUNIT_ASSERT_EQUAL(String("/bar"), aRequest->urlpath);
-    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, aRequest->protocol);
+    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, static_cast<AnyP::ProtocolType>(aRequest->url.getScheme()));
     CPPUNIT_ASSERT_EQUAL(String("http://foo:90/bar"), String(url));
     xfree(url);
 
@@ -55,7 +55,7 @@ testHttpRequest::testCreateFromUrlAndMethod()
     CPPUNIT_ASSERT(aRequest->method == Http::METHOD_PUT);
     CPPUNIT_ASSERT_EQUAL(String("foo"), String(aRequest->GetHost()));
     CPPUNIT_ASSERT_EQUAL(String("/bar"), aRequest->urlpath);
-    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, aRequest->protocol);
+    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, static_cast<AnyP::ProtocolType>(aRequest->url.getScheme()));
     CPPUNIT_ASSERT_EQUAL(String("http://foo/bar"), String(url));
     xfree(url);
 
@@ -73,7 +73,7 @@ testHttpRequest::testCreateFromUrlAndMethod()
     CPPUNIT_ASSERT(aRequest->method == Http::METHOD_CONNECT);
     CPPUNIT_ASSERT_EQUAL(String("foo"), String(aRequest->GetHost()));
     CPPUNIT_ASSERT_EQUAL(String(""), aRequest->urlpath);
-    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_NONE, aRequest->protocol);
+    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_NONE, static_cast<AnyP::ProtocolType>(aRequest->url.getScheme()));
     CPPUNIT_ASSERT_EQUAL(String("foo:45"), String(url));
     xfree(url);
 }
@@ -93,7 +93,7 @@ testHttpRequest::testCreateFromUrl()
     CPPUNIT_ASSERT(aRequest->method == Http::METHOD_GET);
     CPPUNIT_ASSERT_EQUAL(String("foo"), String(aRequest->GetHost()));
     CPPUNIT_ASSERT_EQUAL(String("/bar"), aRequest->urlpath);
-    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, aRequest->protocol);
+    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, static_cast<AnyP::ProtocolType>(aRequest->url.getScheme()));
     CPPUNIT_ASSERT_EQUAL(String("http://foo:90/bar"), String(url));
     xfree(url);
 }
@@ -116,7 +116,7 @@ testHttpRequest::testIPv6HostColonBug()
     CPPUNIT_ASSERT(aRequest->method == Http::METHOD_GET);
     CPPUNIT_ASSERT_EQUAL(String("[2000:800::45]"), String(aRequest->GetHost()));
     CPPUNIT_ASSERT_EQUAL(String("/foo"), aRequest->urlpath);
-    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, aRequest->protocol);
+    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, static_cast<AnyP::ProtocolType>(aRequest->url.getScheme()));
     CPPUNIT_ASSERT_EQUAL(String("http://[2000:800::45]/foo"), String(url));
     xfree(url);
 
@@ -128,7 +128,7 @@ testHttpRequest::testIPv6HostColonBug()
     CPPUNIT_ASSERT(aRequest->method == Http::METHOD_GET);
     CPPUNIT_ASSERT_EQUAL(String("[2000:800::45]"), String(aRequest->GetHost()));
     CPPUNIT_ASSERT_EQUAL(String("/foo"), aRequest->urlpath);
-    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, aRequest->protocol);
+    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, static_cast<AnyP::ProtocolType>(aRequest->url.getScheme()));
     CPPUNIT_ASSERT_EQUAL(String("http://[2000:800::45]:90/foo"), String(url));
     xfree(url);
 
@@ -140,7 +140,7 @@ testHttpRequest::testIPv6HostColonBug()
     CPPUNIT_ASSERT(aRequest->method == Http::METHOD_GET);
     CPPUNIT_ASSERT_EQUAL(String("[2000:800::45]"), String(aRequest->GetHost()));
     CPPUNIT_ASSERT_EQUAL(String("/foo"), aRequest->urlpath);
-    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, aRequest->protocol);
+    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, static_cast<AnyP::ProtocolType>(aRequest->url.getScheme()));
     CPPUNIT_ASSERT_EQUAL(String("http://2000:800::45/foo"), String(url));
     xfree(url);
 }
@@ -84,15 +84,15 @@ testHttpRequestMethod::testImage()
 {
     // relaxed RFC-compliance parse HTTP methods are upgraded to correct case
     Config.onoff.relaxed_header_parser = 1;
-    CPPUNIT_ASSERT_EQUAL(String("POST"), String(HttpRequestMethod("POST",NULL).image()));
-    CPPUNIT_ASSERT_EQUAL(String("POST"), String(HttpRequestMethod("pOsT",NULL).image()));
-    CPPUNIT_ASSERT_EQUAL(String("POST"), String(HttpRequestMethod("post",NULL).image()));
+    CPPUNIT_ASSERT_EQUAL(SBuf("POST"), HttpRequestMethod("POST",NULL).image());
+    CPPUNIT_ASSERT_EQUAL(SBuf("POST"), HttpRequestMethod("pOsT",NULL).image());
+    CPPUNIT_ASSERT_EQUAL(SBuf("POST"), HttpRequestMethod("post",NULL).image());
 
     // strict RFC-compliance parse HTTP methods are case sensitive
     Config.onoff.relaxed_header_parser = 0;
-    CPPUNIT_ASSERT_EQUAL(String("POST"), String(HttpRequestMethod("POST",NULL).image()));
-    CPPUNIT_ASSERT_EQUAL(String("pOsT"), String(HttpRequestMethod("pOsT",NULL).image()));
-    CPPUNIT_ASSERT_EQUAL(String("post"), String(HttpRequestMethod("post",NULL).image()));
+    CPPUNIT_ASSERT_EQUAL(SBuf("POST"), HttpRequestMethod("POST",NULL).image());
+    CPPUNIT_ASSERT_EQUAL(SBuf("pOsT"), HttpRequestMethod("pOsT",NULL).image());
+    CPPUNIT_ASSERT_EQUAL(SBuf("post"), HttpRequestMethod("post",NULL).image());
 }
 
 /*
@@ -244,6 +244,63 @@ static int sign(int v)
     return 0;
 }
 
+static void
+testComparisonStdFull(const char *left, const char *right)
+{
+    if (sign(strcmp(left, right)) != sign(SBuf(left).cmp(SBuf(right))))
+        std::cerr << std::endl << " cmp(SBuf) npos " << left << " ?= " << right << std::endl;
+    CPPUNIT_ASSERT_EQUAL(sign(strcmp(left, right)), sign(SBuf(left).cmp(SBuf(right))));
+
+    if (sign(strcmp(left, right)) != sign(SBuf(left).cmp(right)))
+        std::cerr << std::endl << " cmp(char*) npos " << left << " ?= " << right << std::endl;
+    CPPUNIT_ASSERT_EQUAL(sign(strcmp(left, right)), sign(SBuf(left).cmp(right)));
+
+    if (sign(strcasecmp(left, right)) != sign(SBuf(left).caseCmp(SBuf(right))))
+        std::cerr << std::endl << " caseCmp(SBuf) npos " << left << " ?= " << right << std::endl;
+    CPPUNIT_ASSERT_EQUAL(sign(strcasecmp(left, right)), sign(SBuf(left).caseCmp(SBuf(right))));
+
+    if (sign(strcasecmp(left, right)) != sign(SBuf(left).caseCmp(right)))
+        std::cerr << std::endl << " caseCmp(char*) npos " << left << " ?= " << right << std::endl;
+    CPPUNIT_ASSERT_EQUAL(sign(strcasecmp(left, right)), sign(SBuf(left).caseCmp(right)));
+}
+
+static void
+testComparisonStdN(const char *left, const char *right, const size_t n)
+{
+    if (sign(strncmp(left, right, n)) != sign(SBuf(left).cmp(SBuf(right), n)))
+        std::cerr << std::endl << " cmp(SBuf) " << n << ' ' << left << " ?= " << right << std::endl;
+    CPPUNIT_ASSERT_EQUAL(sign(strncmp(left, right, n)), sign(SBuf(left).cmp(SBuf(right), n)));
+
+    if (sign(strncmp(left, right, n)) != sign(SBuf(left).cmp(right, n)))
+        std::cerr << std::endl << " cmp(char*) " << n << ' ' << SBuf(left) << " ?= " << right << std::endl;
+    CPPUNIT_ASSERT_EQUAL(sign(strncmp(left, right, n)), sign(SBuf(left).cmp(right, n)));
+
+    if (sign(strncasecmp(left, right, n)) != sign(SBuf(left).caseCmp(SBuf(right), n)))
+        std::cerr << std::endl << " caseCmp(SBuf) " << n << ' ' << left << " ?= " << right << std::endl;
+    CPPUNIT_ASSERT_EQUAL(sign(strncasecmp(left, right, n)), sign(SBuf(left).caseCmp(SBuf(right), n)));
+
+    if (sign(strncasecmp(left, right, n)) != sign(SBuf(left).caseCmp(right, n)))
+        std::cerr << std::endl << " caseCmp(char*) " << n << ' ' << SBuf(left) << " ?= " << right << std::endl;
+    CPPUNIT_ASSERT_EQUAL(sign(strncasecmp(left, right, n)), sign(SBuf(left).caseCmp(right, n)));
+}
+
+static void
+testComparisonStdOneWay(const char *left, const char *right)
+{
+    testComparisonStdFull(left, right);
+    const size_t maxN = 2 + min(strlen(left), strlen(right));
+    for (size_t n = 0; n <= maxN; ++n) {
+        testComparisonStdN(left, right, n);
+    }
+}
+
+static void
+testComparisonStd(const char *s1, const char *s2)
+{
+    testComparisonStdOneWay(s1, s2);
+    testComparisonStdOneWay(s2, s1);
+}
+
 void
 testSBuf::testComparisons()
 {
@@ -278,6 +335,41 @@ testSBuf::testComparisons()
     CPPUNIT_ASSERT_EQUAL(0,s1.caseCmp(s2,3));
     CPPUNIT_ASSERT_EQUAL(0,s1.caseCmp(s2,2));
     CPPUNIT_ASSERT_EQUAL(0,s1.cmp(s2,2));
+
+    testComparisonStd("foo", "fooz");
+    testComparisonStd("foo", "foo");
+    testComparisonStd("foo", "f");
+    testComparisonStd("foo", "bar");
+
+    testComparisonStd("foo", "FOOZ");
+    testComparisonStd("foo", "FOO");
+    testComparisonStd("foo", "F");
+
+    testComparisonStdOneWay("", "");
+
+    // rare case C-string input matching SBuf with N>strlen(s)
+    {
+        char *right = xstrdup("foo34567890123456789012345678");
+        SBuf left("fooZYXWVUTSRQPONMLKJIHGFEDCBA");
+        // is 3 bytes in length. NEVER more.
+        right[3] = '\0';
+        left.setAt(3, '\0');
+
+        // pick another spot to truncate at if something goes horribly wrong.
+        right[14] = '\0';
+        left.setAt(14, '\0');
+
+        const SBuf::size_type maxN = 20 + min(left.length(), static_cast<SBuf::size_type>(strlen(right)));
+        for (SBuf::size_type n = 0; n <= maxN; ++n) {
+            if (sign(strncmp(left.rawContent(), right, n)) != sign(left.cmp(right, n)) )
+                std::cerr << std::endl << " cmp(char*) " << n << ' ' << left << " ?= " << right;
+            CPPUNIT_ASSERT_EQUAL(sign(strncmp(left.rawContent(), right, n)), sign(left.cmp(right, n)));
+            if (sign(strncasecmp(left.rawContent(), right, n)) != sign(left.caseCmp(right, n)))
+                std::cerr << std::endl << " caseCmp(char*) " << n << ' ' << left << " ?= " << right;
+            CPPUNIT_ASSERT_EQUAL(sign(strncasecmp(left.rawContent(), right, n)), sign(left.caseCmp(right, n)));
+        }
+        xfree(right);
+    }
 }
 
 void
@@ -33,6 +33,7 @@
 
 #include "squid.h"
 #include "acl/FilledChecklist.h"
+#include "base/CbcPointer.h"
 #include "CachePeer.h"
 #include "client_side.h"
 #include "client_side_request.h"
@@ -42,6 +43,7 @@
 #include "comm/Write.h"
 #include "errorpage.h"
 #include "fde.h"
+#include "FwdState.h"
 #include "http.h"
 #include "HttpRequest.h"
 #include "HttpStateFlags.h"
@@ -50,6 +52,9 @@
 #include "PeerSelectState.h"
 #include "SquidConfig.h"
 #include "StatCounters.h"
+#if USE_OPENSSL
+#include "ssl/PeerConnector.h"
+#endif
 #include "tools.h"
 #if USE_DELAY_POOLS
 #include "DelayId.h"
@@ -94,6 +99,7 @@ class TunnelStateData
 
     bool noConnections() const;
     char *url;
+    CbcPointer<ClientHttpRequest> http;
     HttpRequest::Pointer request;
     AccessLogEntryPointer al;
     Comm::ConnectionList serverDestinations;
@@ -157,7 +163,39 @@ class TunnelStateData
 
     void copyRead(Connection &from, IOCB *completion);
 
+    /// continue to set up connection to a peer, going async for SSL peers
+    void connectToPeer();
+
 private:
+#if USE_OPENSSL
+    /// Gives PeerConnector access to Answer in the TunnelStateData callback dialer.
+    class MyAnswerDialer: public CallDialer, public Ssl::PeerConnector::CbDialer
+    {
+    public:
+        typedef void (TunnelStateData::*Method)(Ssl::PeerConnectorAnswer &);
+
+        MyAnswerDialer(Method method, TunnelStateData *tunnel):
+                method_(method), tunnel_(tunnel), answer_() {}
+
+        /* CallDialer API */
+        virtual bool canDial(AsyncCall &call) { return tunnel_.valid(); }
+        void dial(AsyncCall &call) { ((&(*tunnel_))->*method_)(answer_); }
+        virtual void print(std::ostream &os) const {
+            os << '(' << tunnel_.get() << ", " << answer_ << ')';
+        }
+
+        /* Ssl::PeerConnector::CbDialer API */
+        virtual Ssl::PeerConnectorAnswer &answer() { return answer_; }
+
+    private:
+        Method method_;
+        CbcPointer<TunnelStateData> tunnel_;
+        Ssl::PeerConnectorAnswer answer_;
+    };
+
+    void connectedToPeer(Ssl::PeerConnectorAnswer &answer);
+#endif
+
     CBDATA_CLASS2(TunnelStateData);
     bool keepGoingAfterRead(size_t len, comm_err_t errcode, int xerrno, Connection &from, Connection &to);
     void copy(size_t len, Connection &from, Connection &to, IOCB *);
@@ -220,6 +258,7 @@ tunnelClientClosed(const CommCloseCbParams &params)
 
 TunnelStateData::TunnelStateData() :
         url(NULL),
+        http(),
         request(NULL),
         status_ptr(NULL),
         connectRespBuf(NULL),
@@ -670,11 +709,27 @@ tunnelStartShoveling(TunnelStateData *tunnelState)
     assert(!tunnelState->waitingForConnectExchange());
     *tunnelState->status_ptr = Http::scOkay;
     if (cbdataReferenceValid(tunnelState)) {
+
+        // Shovel any payload already pushed into reply buffer by the server response
         if (!tunnelState->server.len)
             tunnelState->copyRead(tunnelState->server, TunnelStateData::ReadServer);
-        else
+        else {
+            debugs(26, DBG_DATA, "Tunnel server PUSH Payload: \n" << Raw("", tunnelState->server.buf, tunnelState->server.len) << "\n----------");
             tunnelState->copy(tunnelState->server.len, tunnelState->server, tunnelState->client, TunnelStateData::WriteClientDone);
-        tunnelState->copyRead(tunnelState->client, TunnelStateData::ReadClient);
+        }
+
+        // Bug 3371: shovel any payload already pushed into ConnStateData by the client request
+        if (tunnelState->http.valid() && tunnelState->http->getConn() && !tunnelState->http->getConn()->in.buf.isEmpty()) {
+            struct ConnStateData::In *in = &tunnelState->http->getConn()->in;
+            debugs(26, DBG_DATA, "Tunnel client PUSH Payload: \n" << in->buf << "\n----------");
+
+            // We just need to ensure the bytes from ConnStateData are in client.buf already to deliver
+            memcpy(tunnelState->client.buf, in->buf.rawContent(), in->buf.length());
+            // NP: readClient() takes care of buffer length accounting.
+            tunnelState->readClient(tunnelState->client.buf, in->buf.length(), COMM_OK, 0);
+            in->buf.consume(); // ConnStateData buffer accounting after the shuffle.
+        } else
+            tunnelState->copyRead(tunnelState->client, TunnelStateData::ReadClient);
     }
 }
 
@@ -819,7 +874,7 @@ tunnelConnectDone(const Comm::ConnectionPointer &conn, comm_err_t status, int xe
     }
 
     if (tunnelState->request->flags.proxying)
-        tunnelRelayConnectRequest(conn, tunnelState);
+        tunnelState->connectToPeer();
     else {
         tunnelConnected(conn, tunnelState);
     }
@@ -829,9 +884,6 @@ tunnelConnectDone(const Comm::ConnectionPointer &conn, comm_err_t status, int xe
     commSetConnTimeout(conn, Config.Timeout.read, timeoutCall);
 }
 
-tos_t GetTosToServer(HttpRequest * request);
-nfmark_t GetNfmarkToServer(HttpRequest * request);
-
 void
 tunnelStart(ClientHttpRequest * http, int64_t * size_ptr, int *status_ptr, const AccessLogEntryPointer &al)
 {
@@ -865,7 +917,7 @@ tunnelStart(ClientHttpRequest * http, int64_t * size_ptr, int *status_ptr, const
         }
     }
 
-    debugs(26, 3, HERE << "'" << RequestMethodStr(request->method) << " " << url << " " << request->http_ver << "'");
+    debugs(26, 3, request->method << ' ' << url << ' ' << request->http_ver);
     ++statCounter.server.all.requests;
     ++statCounter.server.other.requests;
 
@@ -878,6 +930,7 @@ tunnelStart(ClientHttpRequest * http, int64_t * size_ptr, int *status_ptr, const
     tunnelState->server.size_ptr = size_ptr;
     tunnelState->status_ptr = status_ptr;
     tunnelState->client.conn = http->getConn()->clientConnection;
+    tunnelState->http = http;
     tunnelState->al = al;
 
     comm_add_close_handler(tunnelState->client.conn->fd,
@@ -894,6 +947,46 @@ tunnelStart(ClientHttpRequest * http, int64_t * size_ptr, int *status_ptr, const
                tunnelState);
 }
 
+void
+TunnelStateData::connectToPeer()
+{
+    const Comm::ConnectionPointer &srv = server.conn;
+
+#if USE_OPENSSL
+    if (CachePeer *p = srv->getPeer()) {
+        if (p->use_ssl) {
+            AsyncCall::Pointer callback = asyncCall(5,4,
+                                                    "TunnelStateData::ConnectedToPeer",
+                                                    MyAnswerDialer(&TunnelStateData::connectedToPeer, this));
+            Ssl::PeerConnector *connector =
+                new Ssl::PeerConnector(request, srv, callback);
+            AsyncJob::Start(connector); // will call our callback
+            return;
+        }
+    }
+#endif
+
+    tunnelRelayConnectRequest(srv, this);
+}
+
+#if USE_OPENSSL
+/// Ssl::PeerConnector callback
+void
+TunnelStateData::connectedToPeer(Ssl::PeerConnectorAnswer &answer)
+{
+    if (ErrorState *error = answer.error.get()) {
+        *status_ptr = error->httpStatus;
+        error->callback = tunnelErrorComplete;
+        error->callback_data = this;
+        errorSend(client.conn, error);
+        answer.error.clear(); // preserve error for errorSendComplete()
+        return;
+    }
+
+    tunnelRelayConnectRequest(server.conn, this);
+}
+#endif
+
 static void
 tunnelRelayConnectRequest(const Comm::ConnectionPointer &srv, void *data)
 {
@@ -919,6 +1012,9 @@ tunnelRelayConnectRequest(const Comm::ConnectionPointer &srv, void *data)
     packerClean(&p);
     mb.append("\r\n", 2);
 
+    debugs(11, 2, "Tunnel Server REQUEST: " << tunnelState->server.conn << ":\n----------\n" <<
+           Raw("tunnelRelayConnectRequest", mb.content(), mb.contentSize()) << "\n----------");
+
     if (tunnelState->clientExpectsConnectResponse()) {
         // hack: blindly tunnel peer response (to our CONNECT request) to the client as ours.
         AsyncCall::Pointer writeCall = commCbCall(5,5, "tunnelConnectedWriteDone",
@@ -146,9 +146,6 @@ urlParseProtocol(const char *b, const char *e)
     if (strncasecmp(b, "whois", len) == 0)
         return AnyP::PROTO_WHOIS;
 
-    if (strncasecmp(b, "internal", len) == 0)
-        return AnyP::PROTO_INTERNAL;
-
     return AnyP::PROTO_NONE;
 }
 
@@ -179,8 +176,6 @@ urlDefaultPort(AnyP::ProtocolType p)
         return 210;
 
     case AnyP::PROTO_CACHE_OBJECT:
-
-    case AnyP::PROTO_INTERNAL:
         return CACHE_HTTP_PORT;
 
     case AnyP::PROTO_WHOIS:
@@ -503,25 +498,31 @@ urlCanonical(HttpRequest * request)
     if (request->canonical)
         return request->canonical;
 
-    if (request->protocol == AnyP::PROTO_URN) {
+    if (request->url.getScheme() == AnyP::PROTO_URN) {
         snprintf(urlbuf, MAX_URL, "urn:" SQUIDSTRINGPH,
                  SQUIDSTRINGPRINT(request->urlpath));
-    } else if (request->method.id() == Http::METHOD_CONNECT) {
-        snprintf(urlbuf, MAX_URL, "%s:%d", request->GetHost(), request->port);
     } else {
-        portbuf[0] = '\0';
-
-        if (request->port != urlDefaultPort(request->protocol))
-            snprintf(portbuf, 32, ":%d", request->port);
-
-        const AnyP::UriScheme sch = request->protocol; // temporary, until bug 1961 URL handling is fixed.
-        snprintf(urlbuf, MAX_URL, "%s://%s%s%s%s" SQUIDSTRINGPH,
-                 sch.c_str(),
-                 request->login,
-                 *request->login ? "@" : null_string,
-                 request->GetHost(),
-                 portbuf,
-                 SQUIDSTRINGPRINT(request->urlpath));
+        switch (request->method.id()) {
+
+        case Http::METHOD_CONNECT:
+            snprintf(urlbuf, MAX_URL, "%s:%d", request->GetHost(), request->port);
+            break;
+
+        default: {
+            portbuf[0] = '\0';
+
+            if (request->port != urlDefaultPort(request->url.getScheme()))
+                snprintf(portbuf, 32, ":%d", request->port);
+
+            snprintf(urlbuf, MAX_URL, "%s://%s%s%s%s" SQUIDSTRINGPH,
+                     request->url.getScheme().c_str(),
+                     request->login,
+                     *request->login ? "@" : null_string,
+                     request->GetHost(),
+                     portbuf,
+                     SQUIDSTRINGPRINT(request->urlpath));
+        }
+        }
     }
 
     return (request->canonical = xstrdup(urlbuf));
@@ -539,42 +540,46 @@ urlCanonicalClean(const HttpRequest * request)
     LOCAL_ARRAY(char, loginbuf, MAX_LOGIN_SZ + 1);
     char *t;
 
-    if (request->protocol == AnyP::PROTO_URN) {
+    if (request->url.getScheme() == AnyP::PROTO_URN) {
         snprintf(buf, MAX_URL, "urn:" SQUIDSTRINGPH,
                  SQUIDSTRINGPRINT(request->urlpath));
-    } else if (request->method.id() == Http::METHOD_CONNECT) {
-        snprintf(buf, MAX_URL, "%s:%d", request->GetHost(), request->port);
     } else {
-        portbuf[0] = '\0';
+        switch (request->method.id()) {
 
-        if (request->port != urlDefaultPort(request->protocol))
-            snprintf(portbuf, 32, ":%d", request->port);
+        case Http::METHOD_CONNECT:
+            snprintf(buf, MAX_URL, "%s:%d", request->GetHost(), request->port);
+            break;
 
-        loginbuf[0] = '\0';
+        default: {
+            portbuf[0] = '\0';
 
-        if ((int) strlen(request->login) > 0) {
-            strcpy(loginbuf, request->login);
+            if (request->port != urlDefaultPort(request->url.getScheme()))
+                snprintf(portbuf, 32, ":%d", request->port);
 
-            if ((t = strchr(loginbuf, ':')))
-                *t = '\0';
+            loginbuf[0] = '\0';
 
-            strcat(loginbuf, "@");
-        }
+            if ((int) strlen(request->login) > 0) {
+                strcpy(loginbuf, request->login);
 
-        const AnyP::UriScheme sch = request->protocol; // temporary, until bug 1961 URL handling is fixed.
-        snprintf(buf, MAX_URL, "%s://%s%s%s" SQUIDSTRINGPH,
-                 sch.c_str(),
-                 loginbuf,
-                 request->GetHost(),
-                 portbuf,
-                 SQUIDSTRINGPRINT(request->urlpath));
-        /*
-         * strip arguments AFTER a question-mark
-         */
+                if ((t = strchr(loginbuf, ':')))
+                    *t = '\0';
 
-        if (Config.onoff.strip_query_terms)
-            if ((t = strchr(buf, '?')))
-                *(++t) = '\0';
+                strcat(loginbuf, "@");
+            }
+
+            snprintf(buf, MAX_URL, "%s://%s%s%s" SQUIDSTRINGPH,
+                     request->url.getScheme().c_str(),
+                     loginbuf,
+                     request->GetHost(),
+                     portbuf,
+                     SQUIDSTRINGPRINT(request->urlpath));
+
+            // strip arguments AFTER a question-mark
+            if (Config.onoff.strip_query_terms)
+                if ((t = strchr(buf, '?')))
+                    *(++t) = '\0';
+        }
+        }
     }
 
     if (stringHasCntl(buf))
@@ -653,26 +658,25 @@ urlMakeAbsolute(const HttpRequest * req, const char *relUrl)
 
     char *urlbuf = (char *)xmalloc(MAX_URL * sizeof(char));
 
-    if (req->protocol == AnyP::PROTO_URN) {
+    if (req->url.getScheme() == AnyP::PROTO_URN) {
         snprintf(urlbuf, MAX_URL, "urn:" SQUIDSTRINGPH,
                  SQUIDSTRINGPRINT(req->urlpath));
         return (urlbuf);
     }
 
     size_t urllen;
 
-    const AnyP::UriScheme sch = req->protocol; // temporary, until bug 1961 URL handling is fixed.
-    if (req->port != urlDefaultPort(req->protocol)) {
+    if (req->port != urlDefaultPort(req->url.getScheme())) {
         urllen = snprintf(urlbuf, MAX_URL, "%s://%s%s%s:%d",
-                          sch.c_str(),
+                          req->url.getScheme().c_str(),
                           req->login,
                           *req->login ? "@" : null_string,
                           req->GetHost(),
                           req->port
                          );
     } else {
         urllen = snprintf(urlbuf, MAX_URL, "%s://%s%s%s",
-                          sch.c_str(),
+                          req->url.getScheme().c_str(),
                           req->login,
                           *req->login ? "@" : null_string,
                           req->GetHost()
@@ -830,7 +834,7 @@ urlCheckRequest(const HttpRequest * r)
         return 1;
 
     /* does method match the protocol? */
-    switch (r->protocol) {
+    switch (r->url.getScheme()) {
 
     case AnyP::PROTO_URN:
 
@@ -42,7 +42,7 @@ fi
 # but skip if we have no files to remove.
 FILECOUNT=`ls -1 | grep -c .`
 if test "${FILECOUNT}" != "0" ; then
-  make -k distclean || echo "distclean done. errors are unwanted but okay here."
+  ${MAKE:-make} -k distclean || echo "distclean done. errors are unwanted but okay here."
   ls -la .
   rm -fr ./src/fs/aufs/.deps src/fs/diskd/.deps
 fi
@@ -55,7 +55,7 @@ fi
 # eval is need to correctly handle quoted arguments
 	eval "$base/../configure ${DISTCHECK_CONFIGURE_FLAGS} ${configcache}" \
 		2>&1 && \
-	make ${pjobs} ${MAKETEST} 2>&1
+	${MAKE:-make} ${pjobs} ${MAKETEST} 2>&1
 
 # Remember and then explicitly return the result of the last command
 # to the script caller. Probably not needed on most or all platforms.
@@ -12,6 +12,7 @@ LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(COMPAT_LIB) \
+	$(LIBGNUTLS_LIBS) \
 	$(NETTLELIB) \
 	$(KRB5LIBS) \
 	$(XTRA_LIBS)
@@ -49,4 +50,6 @@ squidclient_SOURCES = \
 	squidclient.cc \
 	stub_debug.cc \
 	test_tools.cc \
-	time.cc
+	time.cc \
+	Transport.cc \
+	Transport.h
@@ -19,6 +19,10 @@ class Parameters
     int verbosityLevel;
 };
 
+/// display debug messages at varying verbosity levels
+#define debugVerbose(LEVEL, MESSAGE) \
+    while ((LEVEL) <= scParams.verbosityLevel) {std::cerr << MESSAGE << std::endl; break;}
+
 /// global squidcleint parameters
 extern Parameters scParams;
 
@@ -0,0 +1,500 @@
+#include "squid.h"
+#include "ip/Address.h"
+#include "tools/squidclient/Ping.h"
+#include "tools/squidclient/Transport.h"
+
+#if HAVE_GETOPT_H
+#include <getopt.h>
+#endif
+#if HAVE_GNUTLS_X509_H
+#include <gnutls/x509.h>
+#endif
+#include <iostream>
+
+Transport::TheConfig Transport::Config;
+
+/// the current server connection FD
+int conn = -1;
+
+void
+Transport::TheConfig::usage()
+{
+    std::cerr << "Connection Settings" << std::endl
+              << "  -h | --host host     Send message to server on 'host'.  Default is localhost." << std::endl
+              << "  -l | --local host    Specify a local IP address to bind to.  Default is none." << std::endl
+              << "  -p | --port port     Port number on server to contact. Default is " << CACHE_HTTP_PORT << "." << std::endl
+              << "  -T timeout           Timeout in seconds for read/write operations" << std::endl
+#if USE_GNUTLS
+              << "  --https              Use TLS/SSL on the HTTP connection" << std::endl
+              << std::endl
+              << "  TLS options:" << std::endl
+              << "    --anonymous-tls    Use Anonymous TLS. Sets default parameters:" << std::endl
+              << "                         \"PERFORMANCE:+ANON-ECDH:+ANON-DH\"" << std::endl
+              << "    --params=\"...\"   Use the given parameters." << std::endl
+              << "    --cert=FILE        Path to a PEM file holding the client X.509 certificate chain." << std::endl
+              << "                       May be repeated if there are multiple certificates to use for the server." << std::endl
+              << "    --trusted-ca=PATH  Path to a PEM file holding trusted CA certificate(s)." << std::endl
+              << "                       May be repeated." << std::endl
+              << "                       Example path: \"/etc/ssl/certs/ca-certificates.crt\"" << std::endl
+#endif
+              << std::endl;
+}
+
+bool
+Transport::TheConfig::parseCommandOpts(int argc, char *argv[], int c, int &optIndex)
+{
+    bool tls = false;
+    const char *shortOpStr = "A:C:h:l:p:P:T:?";
+
+    // options for controlling squidclient transport connection
+    static struct option longOptions[] = {
+        {"anonymous-tls",no_argument, 0, '\1'},
+        {"https",        no_argument, 0, '\3'},
+        {"trusted-ca",   required_argument, 0, 'A'},
+        {"cert",         required_argument, 0, 'C'},
+        {"host",         required_argument, 0, 'h'},
+        {"local",        required_argument, 0, 'l'},
+        {"port",         required_argument, 0, 'p'},
+        {"params",       required_argument, 0, 'P'},
+        {0, 0, 0, 0}
+    };
+
+    int saved_opterr = opterr;
+    opterr = 0; // suppress errors from getopt
+    do {
+        switch (c) {
+        case '\1':
+            tls = true;
+            tlsAnonymous = true;
+            params = "PERFORMANCE:+ANON-ECDH:+ANON-DH";
+            break;
+
+        case '\3':
+            tls = true;
+            break;
+
+        case 'A':
+            tls = true;
+            caFiles.push_back(std::string(optarg));
+            break;
+
+        case 'C':
+            tls = true;
+            certFiles.push_back(std::string(optarg));
+            break;
+
+        case 'h':
+            hostname = optarg;
+            break;
+
+        case 'l':
+            localHost = optarg;
+            break;
+
+        case 'p':           /* port number */
+            sscanf(optarg, "%hd", &port);
+            if (port < 1)
+                port = CACHE_HTTP_PORT;     /* default */
+            break;
+
+        case 'P':
+            tls = true;
+            params = optarg;
+            break;
+
+        case 'T':
+            ioTimeout = atoi(optarg);
+            break;
+
+        default:
+            if (tls)
+                Transport::InitTls();
+
+            // rewind and let the caller handle unknown options
+            --optind;
+            opterr = saved_opterr;
+            return true;
+        }
+    } while ((c = getopt_long(argc, argv, shortOpStr, longOptions, &optIndex)) != -1);
+
+    if (tls)
+        Transport::InitTls();
+
+    opterr = saved_opterr;
+    return false;
+}
+
+/// Set up the source socket address from which to send.
+static int
+client_comm_bind(int sock, const Ip::Address &addr)
+{
+    static struct addrinfo *AI = NULL;
+    addr.getAddrInfo(AI);
+    int res = bind(sock, AI->ai_addr, AI->ai_addrlen);
+    Ip::Address::FreeAddrInfo(AI);
+    return res;
+}
+
+static void
+resolveDestination(Ip::Address &iaddr)
+{
+    struct addrinfo *AI = NULL;
+
+    if (Transport::Config.localHost) {
+        debugVerbose(2, "Resolving " << Transport::Config.localHost << " ...");
+
+        if ( !iaddr.GetHostByName(Transport::Config.localHost) ) {
+            std::cerr << "ERROR: Cannot resolve " << Transport::Config.localHost << ": Host unknown." << std::endl;
+            exit(1);
+        }
+    } else {
+        debugVerbose(2, "Resolving " << Transport::Config.hostname << " ...");
+        /* Process the remote host name to locate the Protocol required
+           in case we are being asked to link to another version of squid */
+        if ( !iaddr.GetHostByName(Transport::Config.hostname) ) {
+            std::cerr << "ERROR: Cannot resolve " << Transport::Config.hostname << ": Host unknown." << std::endl;
+            exit(1);
+        }
+    }
+
+    iaddr.getAddrInfo(AI);
+    if ((conn = socket(AI->ai_family, AI->ai_socktype, 0)) < 0) {
+        std::cerr << "ERROR: could not open socket to " << iaddr << std::endl;
+        Ip::Address::FreeAddrInfo(AI);
+        exit(1);
+    }
+    Ip::Address::FreeAddrInfo(AI);
+
+    if (Transport::Config.localHost) {
+        if (client_comm_bind(conn, iaddr) < 0) {
+            std::cerr << "ERROR: could not bind socket to " << iaddr << std::endl;
+            exit(1);
+        }
+
+        iaddr.setEmpty();
+
+        debugVerbose(2, "Resolving... " << Transport::Config.hostname);
+
+        if ( !iaddr.GetHostByName(Transport::Config.hostname) ) {
+            std::cerr << "ERROR: Cannot resolve " << Transport::Config.hostname << ": Host unknown." << std::endl;
+            exit(1);
+        }
+    }
+
+    iaddr.port(Transport::Config.port);
+}
+
+/// Set up the destination socket address for message to send to.
+static int
+client_comm_connect(int sock, const Ip::Address &addr)
+{
+    static struct addrinfo *AI = NULL;
+    addr.getAddrInfo(AI);
+    int res = connect(sock, AI->ai_addr, AI->ai_addrlen);
+    Ip::Address::FreeAddrInfo(AI);
+    Ping::TimerStart();
+    return res;
+}
+
+bool
+Transport::Connect()
+{
+    Ip::Address iaddr;
+    resolveDestination(iaddr);
+
+    debugVerbose(2, "Connecting... " << Config.hostname << " (" << iaddr << ")");
+
+    if (client_comm_connect(conn, iaddr) < 0) {
+        char hostnameBuf[MAX_IPSTRLEN];
+        iaddr.toUrl(hostnameBuf, MAX_IPSTRLEN);
+        std::cerr << "ERROR: Cannot connect to " << hostnameBuf
+                  << (!errno ?": Host unknown." : "") << std::endl;
+        exit(1);
+    }
+    debugVerbose(2, "Connected to: " << Config.hostname << " (" << iaddr << ")");
+
+    // do any TLS setup that might be needed
+    if (!Transport::MaybeStartTls(Config.hostname))
+        return false;
+
+    return true;
+}
+
+ssize_t
+Transport::Write(void *buf, size_t len)
+{
+    if (conn < 0)
+        return -1;
+
+    if (Config.tlsEnabled) {
+#if USE_GNUTLS
+        gnutls_record_send(Config.session, buf, len);
+        return len;
+#else
+        return 0;
+#endif
+    } else {
+
+#if _SQUID_WINDOWS_
+        return send(conn, buf, len, 0);
+#else
+        alarm(Config.ioTimeout);
+        return write(conn, buf, len);
+#endif
+    }
+}
+
+ssize_t
+Transport::Read(void *buf, size_t len)
+{
+    if (conn < 0)
+        return -1;
+
+    if (Config.tlsEnabled) {
+#if USE_GNUTLS
+        return gnutls_record_recv(Config.session, buf, len);
+#else
+        return 0;
+#endif
+    } else {
+
+#if _SQUID_WINDOWS_
+        return recv(conn, buf, len, 0);
+#else
+        alarm(Config.ioTimeout);
+        return read(conn, buf, len);
+#endif
+    }
+}
+
+void
+Transport::CloseConnection()
+{
+    (void) close(conn);
+    conn = -1;
+}
+
+#if USE_GNUTLS
+/* This function will verify the peer's certificate, and check
+ * if the hostname matches, as well as the activation, expiration dates.
+ */
+static int
+verifyByCA(gnutls_session_t session)
+{
+    /* read hostname */
+    const char *hostname = static_cast<const char*>(gnutls_session_get_ptr(session));
+
+    /* This verification function uses the trusted CAs in the credentials
+     * structure. So you must have installed one or more CA certificates.
+     */
+    unsigned int status;
+    if (gnutls_certificate_verify_peers3(session, hostname, &status) < 0) {
+        std::cerr << "VERIFY peers failure";
+        return GNUTLS_E_CERTIFICATE_ERROR;
+    }
+
+    gnutls_certificate_type_t type = gnutls_certificate_type_get(session);
+    gnutls_datum_t out;
+    if (gnutls_certificate_verification_status_print(status, type, &out, 0) < 0) {
+        std::cerr << "VERIFY status failure";
+        return GNUTLS_E_CERTIFICATE_ERROR;
+    }
+
+    std::cerr << "VERIFY DATUM: " << out.data << std::endl;
+    gnutls_free(out.data);
+
+    if (status != 0)        /* Certificate is not trusted */
+        return GNUTLS_E_CERTIFICATE_ERROR;
+
+    /* notify gnutls to continue handshake normally */
+    return GNUTLS_E_SUCCESS;
+}
+
+static int
+verifyTlsCertificate(gnutls_session_t session)
+{
+    // XXX: 1) try to verify using DANE -> Secure Authenticated Connection
+
+    // 2) try to verify using CA
+    if (verifyByCA(session) == GNUTLS_E_SUCCESS) {
+        std::cerr << "SUCCESS: CA verified Encrypted Connection" << std::endl;
+        return GNUTLS_E_SUCCESS;
+    }
+
+    // 3) fails both is insecure, but show the results anyway.
+    std::cerr << "WARNING: Insecure Connection" << std::endl;
+    return GNUTLS_E_SUCCESS;
+}
+#endif
+
+void
+Transport::InitTls()
+{
+#if USE_GNUTLS
+    debugVerbose(3, "Initializing TLS library...");
+    // NP: gnutls init is re-entrant and lock-counted with deinit but not thread safe.
+    if (gnutls_global_init() != GNUTLS_E_SUCCESS) {
+        std::cerr << "FATAL ERROR: TLS Initialize failed: " << xstrerror() << std::endl;
+        exit(1);
+    }
+
+    Config.tlsEnabled = true;
+
+    // Initialize for anonymous TLS
+    gnutls_anon_allocate_client_credentials(&Config.anonCredentials);
+
+    // Initialize for X.509 certificate exchange
+    gnutls_certificate_allocate_credentials(&Config.certCredentials);
+    for (std::list<std::string>::const_iterator i = Config.caFiles.begin(); i != Config.caFiles.end(); ++i) {
+        int x = gnutls_certificate_set_x509_trust_file(Config.certCredentials, (*i).c_str(), GNUTLS_X509_FMT_PEM);
+        if (x < 0) {
+            debugVerbose(3, "WARNING: Failed to load Certificate Authorities from " << *i);
+        } else {
+            debugVerbose(3, "Loaded " << x << " Certificate Authorities from " << *i);
+        }
+    }
+    gnutls_certificate_set_verify_function(Config.certCredentials, verifyTlsCertificate);
+
+    for (std::list<std::string>::const_iterator i = Config.certFiles.begin(); i != Config.certFiles.end(); ++i) {
+        if (gnutls_certificate_set_x509_key_file(Transport::Config.certCredentials, (*i).c_str(), (*i).c_str(), GNUTLS_X509_FMT_PEM) != GNUTLS_E_SUCCESS) {
+            debugVerbose(3, "WARNING: Failed to load Certificate from " << *i);
+        } else {
+            debugVerbose(3, "Loaded Certificate from " << *i);
+        }
+    }
+
+#else
+    std::cerr << "ERROR: TLS support not available." << std::endl;
+#endif
+}
+
+#if USE_GNUTLS
+
+// perform the actual handshake exchange with remote server
+static bool
+doTlsHandshake(const char *type)
+{
+    // setup the connection for TLS
+    gnutls_transport_set_int(Transport::Config.session, conn);
+    gnutls_handshake_set_timeout(Transport::Config.session, GNUTLS_DEFAULT_HANDSHAKE_TIMEOUT);
+
+    debugVerbose(2, type << " TLS handshake ... ");
+
+    int ret = 0;
+    do {
+        ret = gnutls_handshake(Transport::Config.session);
+    } while (ret < 0 && gnutls_error_is_fatal(ret) == 0);
+
+    if (ret < 0) {
+        std::cerr << "ERROR: " << type << " TLS Handshake failed (" << ret << ") "
+                  << gnutls_alert_get_name(gnutls_alert_get(Transport::Config.session))
+                  << std::endl;
+        gnutls_perror(ret);
+        gnutls_deinit(Transport::Config.session);
+        return false;
+    }
+
+    char *desc = gnutls_session_get_desc(Transport::Config.session);
+    debugVerbose(3, "TLS Session info: " << std::endl << desc << std::endl);
+    gnutls_free(desc);
+    return true;
+}
+
+static bool
+loadTlsParameters()
+{
+    const char *err = NULL;
+    int x;
+    if ((x = gnutls_priority_set_direct(Transport::Config.session, Transport::Config.params, &err)) != GNUTLS_E_SUCCESS) {
+        if (x == GNUTLS_E_INVALID_REQUEST)
+            std::cerr << "ERROR: Syntax error at: " << err << std::endl;
+        gnutls_perror(x);
+        return false;
+    }
+    return true;
+}
+
+// attempt an anonymous TLS handshake
+// this encrypts the connection but does not secure it
+// so many public servers do not support this handshake type.
+static bool
+tryTlsAnonymous()
+{
+    if (!loadTlsParameters())
+        return false;
+
+    // put the anonymous credentials to the current session
+    int x;
+    if ((x = gnutls_credentials_set(Transport::Config.session, GNUTLS_CRD_ANON, Transport::Config.anonCredentials)) != GNUTLS_E_SUCCESS) {
+        std::cerr << "ERROR: Anonymous TLS credentials setup failed (" << x << ") " << std::endl;
+        gnutls_perror(x);
+        return false;
+    }
+
+    return doTlsHandshake("Anonymous");
+}
+
+// attempt a X.509 certificate exchange
+// this both encrypts and authenticates the connection
+static bool
+tryTlsCertificate(const char *hostname)
+{
+    gnutls_session_set_ptr(Transport::Config.session, (void *) hostname);
+    gnutls_server_name_set(Transport::Config.session, GNUTLS_NAME_DNS, hostname, strlen(hostname));
+
+    if (!loadTlsParameters())
+        return false;
+
+    // put the X.509 credentials to the current session
+    gnutls_credentials_set(Transport::Config.session, GNUTLS_CRD_CERTIFICATE, Transport::Config.certCredentials);
+
+    // setup the connection for TLS
+    gnutls_transport_set_int(Transport::Config.session, conn);
+    gnutls_handshake_set_timeout(Transport::Config.session, GNUTLS_DEFAULT_HANDSHAKE_TIMEOUT);
+
+    return doTlsHandshake("X.509");
+}
+#endif
+
+bool
+Transport::MaybeStartTls(const char *hostname)
+{
+#if USE_GNUTLS
+    if (Config.tlsEnabled) {
+
+        // Initialize TLS session
+        gnutls_init(&Transport::Config.session, GNUTLS_CLIENT);
+
+        if (Transport::Config.tlsAnonymous && !tryTlsAnonymous()) {
+            gnutls_deinit(Config.session);
+            return false;
+        }
+
+        if (!tryTlsCertificate(hostname)) {
+            gnutls_deinit(Config.session);
+            return false;
+        }
+    }
+#endif
+    return true;
+}
+
+void
+Transport::ShutdownTls()
+{
+#if USE_GNUTLS
+    if (!Config.tlsEnabled)
+        return;
+
+    debugVerbose(3, "Shutting down TLS library...");
+
+    // release any existing session and credentials
+    gnutls_deinit(Config.session);
+    gnutls_anon_free_client_credentials(Config.anonCredentials);
+    gnutls_certificate_free_credentials(Config.certCredentials);
+
+    // NP: gnutls init is re-entrant and lock-counted with deinit but not thread safe.
+    gnutls_global_deinit();
+    Config.tlsEnabled = false;
+#endif
+}
@@ -0,0 +1,112 @@
+#ifndef SQUID_TOOLS_SQUIDCLIENT_TRANSPORT_H
+#define SQUID_TOOLS_SQUIDCLIENT_TRANSPORT_H
+
+#include "tools/squidclient/Parameters.h"
+
+#if HAVE_GNUTLS_GNUTLS_H
+#include <gnutls/gnutls.h>
+#endif
+#include <list>
+#include <string>
+
+namespace Transport
+{
+
+/// parameters controlling outgoing connection
+class TheConfig
+{
+public:
+    TheConfig() :
+            ioTimeout(120),
+            localHost(NULL),
+            port(CACHE_HTTP_PORT),
+            tlsEnabled(false),
+            tlsAnonymous(false) {
+        params = "NORMAL";
+        hostname = "localhost";
+    }
+
+// TODO: implicit transport options depending on the protocol-specific options
+//     ie --https enables TLS connection settings
+
+    /// display Transport Options command line help to stderr
+    void usage();
+
+    /**
+     * parse transport related command line options
+     * \return true if there are other options still to parse
+     */
+    bool parseCommandOpts(int argc, char *argv[], int c, int &optIndex);
+
+    /// I/O operation timeout
+    int ioTimeout;
+
+    /// the local hostname to bind as for outgoing IP
+    const char *localHost;
+
+    /// the destination server host name to contact
+    const char *hostname;
+
+    /// port on the server to contact
+    uint16_t port;
+
+    /// whether to enable TLS on the server connnection
+    bool tlsEnabled;
+
+    /// whether to do anonymous TLS (non-authenticated)
+    bool tlsAnonymous;
+
+    /// The TLS parameters (list of ciphers, versions, flags)
+    /// Default is "NORMAL" unless tlsAnonymous is used,
+    /// in which case it becomes "PERFORMANCE:+ANON-ECDH:+ANON-DH".
+    /// see http://gnutls.org/manual/html_node/Priority-Strings.html
+    const char *params;
+
+    // client certificate PEM file(s)
+    std::list<std::string> certFiles;
+
+    // client trusted x509 certificate authorities file
+    std::list<std::string> caFiles;
+
+#if USE_GNUTLS
+    /// anonymous client credentials
+    gnutls_anon_client_credentials_t anonCredentials;
+
+    // client x509 certificate credentials
+    gnutls_certificate_credentials_t certCredentials;
+
+    /// TLS session state
+    gnutls_session_t session;
+#endif
+};
+
+extern TheConfig Config;
+
+/// locate and connect to the configured server
+bool Connect();
+
+/// close the current connection
+void CloseConnection();
+
+/// Initialize TLS library environment when necessary.
+void InitTls();
+
+/// perform TLS handshake on the currently open connection if
+/// TLS library has been initialized.
+/// return false on errors, true otherwise even if TLS not performed.
+bool MaybeStartTls(const char *hostname);
+
+/// De-initialize TLS library environment when necessary.
+void ShutdownTls();
+
+/// write len bytes to the currently open connection.
+/// \return the number of bytes written, or -1 on errors
+ssize_t Write(void *buf, size_t len);
+
+/// read up to len bytes from the currently open connection.
+/// \return the number of bytes read, or -1 on errors
+ssize_t Read(void *buf, size_t len);
+
+} // namespace Transport
+
+#endif /* SQUID_TOOLS_SQUIDCLIENT_TRANSPORT_H */
@@ -7,22 +7,23 @@ A simple HTTP web client tool
 .
 .SH SYNOPSIS
 .if !'po4a'hide' .B squidclient
-.if !'po4a'hide' .B "[ \-\-ping [ping-options] ] "
-.if !'po4a'hide' .B "[ \-aknNrsv ] [ \-A"
+.if !'po4a'hide' .B "[ \-aknNrsv ] "
+.if !'po4a'hide' .B "[ \-\-ping [ping\-options] ] "
+.if !'po4a'hide' .B "[ \-\-https] [tls\-options] [ \-A"
 string
-.if !'po4a'hide' .B "] [ \-h"
+.if !'po4a'hide' .B "] [ \-h | \-\-host"
 remote host
 .if !'po4a'hide' .B "] [ \-H '"
 string
 .if !'po4a'hide' .B "' ] [ \-i"
 IMS
 .if !'po4a'hide' .B "] [ \-j '"
 Host header
-.if !'po4a'hide' .B "' ] [ \-l"
-local host
+.if !'po4a'hide' .B "' ] [ \-l | \-\-local"
+host
 .if !'po4a'hide' .B "] [ \-m"
 method
-.if !'po4a'hide' .B "] [ \-p"
+.if !'po4a'hide' .B "] [ \-p | \-\-port"
 port
 .if !'po4a'hide' .B "] [ \-P"
 file
@@ -49,6 +50,14 @@ count
 interval
 .if !'po4a'hide' .B "] "
 .
+.if !'po4a'hide' .B "TLS options: [ \-\-anonymous\-tls ] [ \-\-trusted\-ca"
+CA certificates file
+.if !'po4a'hide' .B "...] [ \-\-cert"
+client X.509 certificate file
+.if !'po4a'hide' .B "] [ \-\-params"
+TLS session parameters
+.if !'po4a'hide' .B "] "
+.
 .SH DESCRIPTION
 .B squidclient
 is a tool providing a command line interface for retrieving URLs.
@@ -70,8 +79,8 @@ Send
 as User-Agent: header. To omit the header completely set string to empty ('').
 .
 .if !'po4a'hide' .TP
-.if !'po4a'hide' .B "\-h host"
-Retrieve URL from cache on hostname.  Default is
+.if !'po4a'hide' .B "\-h | \-\-host host"
+Retrieve URL from server host.  Default is
 .B localhost
 .
 .if !'po4a'hide' .TP
@@ -93,7 +102,7 @@ Host header content
 Keep the connection active. Default is to do only one request then close.
 .
 .if !'po4a'hide' .TP
-.if !'po4a'hide' .B "\-l host"
+.if !'po4a'hide' .B "\-l | \-\-local host"
 Specify a local IP address to bind to.  Default is none.
 .
 .if !'po4a'hide' .TP
@@ -177,6 +186,31 @@ Proxy authentication password
 .if !'po4a'hide' .B "\-W password"
 WWW authentication password
 .
+.if !'po4a'hide' .TP
+.if !'po4a'hide' .B "\-\-https"
+Use Transport Layer Security on the HTTP connection.
+.
+.if !'po4a'hide' .TP
+.if !'po4a'hide' .B "\-\-anonymous\-tls"
+Use TLS with unauthenticated (anonymous) certificate.
+.
+.if !'po4a'hide' .TP
+.if !'po4a'hide' .B "\-\-cert file"
+File containing client X.509 certificate in PEM format.
+May be repeated to load several client certificates.
+.
+.if !'po4a'hide' .TP
+.if !'po4a'hide' .B "\-\-trusted-ca file"
+File containing trusted Certificate Authority (CA) certificates in PEM format.
+May be repeated to load any number of files.
+.
+.if !'po4a'hide' .TP
+.if !'po4a'hide' .B "\-\-params values"
+TLS library specific parameters for the communication session.
+See the library documentation for details on valid parameters.
+.if !'po4a'hide' .I "GnuTLS: http://gnutls.org/manual/html_node/Priority\-Strings.html"
+If repeated only the last value will have effect.
+.
 .if !'po4a'hide' .TP 10
 .if !'po4a'hide' .B "\-\-ping [options]"
 Enable ping mode. Optional \-g and \-I parameters must follow immediately if used.
@@ -38,6 +38,7 @@
 #include "tools/squidclient/gssapi_support.h"
 #include "tools/squidclient/Parameters.h"
 #include "tools/squidclient/Ping.h"
+#include "tools/squidclient/Transport.h"
 
 #if _SQUID_WINDOWS_
 /** \cond AUTODOCS-IGNORE */
@@ -84,20 +85,11 @@ using namespace Squid;
 #define HEADERLEN	65536
 #endif
 
-/// display debug messages at varying verbosity levels
-#define debugVerbose(LEVEL, MESSAGE) \
-    while ((LEVEL) <= scParams.verbosityLevel) {std::cerr << MESSAGE << std::endl; break;}
-
 /* Local functions */
-static int client_comm_bind(int, const Ip::Address &);
-
-static int client_comm_connect(int, const Ip::Address &);
 static void usage(const char *progname);
 
 void pipe_handler(int sig);
 static void set_our_signal(void);
-static ssize_t myread(int fd, void *buf, size_t len);
-static ssize_t mywrite(int fd, void *buf, size_t len);
 
 Parameters scParams;
 
@@ -106,7 +98,6 @@ static char *put_file = NULL;
 
 static struct stat sb;
 int total_bytes = 0;
-int io_timeout = 120;
 
 #if _SQUID_AIX_
 /* Bug 3854: AIX 6.1 tries to link in this fde.h global symbol
@@ -129,19 +120,16 @@ usage(const char *progname)
 {
     std::cerr << "Version: " << VERSION << std::endl
               << "Usage: " << progname << " [Basic Options] [HTTP Options]" << std::endl
-              << std::endl
-              << "Basic Options:" << std::endl
-              << "    -h host         Send message to server on 'host'.  Default is localhost." << std::endl
-              << "    -l host         Specify a local IP address to bind to.  Default is none." << std::endl
-              << "    -p port         Port number on server to contact. Default is " << CACHE_HTTP_PORT << "." << std::endl
-              << "    -s | --quiet    Silent.  Do not print response message to stdout." << std::endl
-              << "    -T timeout      Timeout value (seconds) for read/write operations" << std::endl
-              << "    -v | --verbose  Verbose debugging. Repeat (-vv) to increase output level." << std::endl
-              << "                    Levels:" << std::endl
-              << "                      1 - Print outgoing request message to stderr." << std::endl
-              << "                      2 - Print action trace to stderr." << std::endl
-              << "    --help          Display this help text." << std::endl
               << std::endl;
+    std::cerr
+        << "    -s | --quiet    Silent.  Do not print response message to stdout." << std::endl
+        << "    -v | --verbose  Verbose debugging. Repeat (-vv) to increase output level." << std::endl
+        << "                    Levels:" << std::endl
+        << "                      1 - Print outgoing request message to stderr." << std::endl
+        << "                      2 - Print action trace to stderr." << std::endl
+        << "    --help          Display this help text." << std::endl
+        << std::endl;
+    Transport::Config.usage();
     Ping::Config.usage();
     std::cerr
         << "HTTP Options:" << std::endl
@@ -171,16 +159,13 @@ usage(const char *progname)
 int
 main(int argc, char *argv[])
 {
-    int conn, len, bytesWritten;
-    uint16_t port;
+    int len, bytesWritten;
     bool to_stdout, reload;
     int keep_alive = 0;
     int opt_noaccept = 0;
 #if HAVE_GSSAPI
     int www_neg = 0, proxy_neg = 0;
 #endif
-    const char *hostname, *localhost;
-    Ip::Address iaddr;
     char url[BUFSIZ], msg[MESSAGELEN], buf[BUFSIZ];
     char extra_hdrs[HEADERLEN];
     const char *method = "GET";
@@ -197,10 +182,7 @@ main(int argc, char *argv[])
     const char *useragent = NULL;
 
     /* set the defaults */
-    hostname = "localhost";
-    localhost = NULL;
     extra_hdrs[0] = '\0';
-    port = CACHE_HTTP_PORT;
     to_stdout = true;
     reload = false;
 
@@ -212,15 +194,19 @@ main(int argc, char *argv[])
         url[BUFSIZ - 1] = '\0';
 
         int optIndex = 0;
-        const char *shortOpStr = "aA:h:j:V:l:P:i:kmnN:p:rsvt:p:H:T:u:U:w:W:?";
+        const char *shortOpStr = "aA:h:j:V:l:P:i:kmnN:p:rsvt:H:T:u:U:w:W:?";
 
         // options for controlling squidclient
         static struct option basicOptions[] = {
             /* These are the generic options for squidclient itself */
             {"help",    no_argument, 0, '?'},
             {"verbose", no_argument, 0, 'v'},
             {"quiet",   no_argument, 0, 's'},
+            {"host",    required_argument, 0, 'h'},
+            {"local",   required_argument, 0, 'l'},
+            {"port",    required_argument, 0, 'p'},
             {"ping",    no_argument, 0, '\1'},
+            {"https",   no_argument, 0, '\3'},
             {0, 0, 0, 0}
         };
 
@@ -231,9 +217,18 @@ main(int argc, char *argv[])
             switch (c) {
             case '\1':
                 to_stdout = 0;
-                if (Ping::Config.parseCommandOpts(argc, argv, c, optIndex))
-                    continue;
-                break;
+                Ping::Config.parseCommandOpts(argc, argv, c, optIndex);
+                continue;
+
+            case 'h':		/* remote host */
+            case 'l':		/* local host */
+            case 'p':		/* port number */
+                // rewind and let the Transport::Config parser handle
+                optind -= 2;
+
+            case '\3': // request over a TLS connection
+                Transport::Config.parseCommandOpts(argc, argv, c, optIndex);
+                continue;
 
             default: // fall through to next switch
                 break;
@@ -252,10 +247,6 @@ main(int argc, char *argv[])
                 useragent = optarg;
                 break;
 
-            case 'h':		/* remote host */
-                hostname = optarg;
-                break;
-
             case 'j':
                 host = optarg;
                 break;
@@ -264,10 +255,6 @@ main(int argc, char *argv[])
                 version = optarg;
                 break;
 
-            case 'l':		/* local host */
-                localhost = optarg;
-                break;
-
             case 's':		/* silent */
                 to_stdout = false;
                 break;
@@ -280,12 +267,6 @@ main(int argc, char *argv[])
                 reload = true;
                 break;
 
-            case 'p':		/* port number */
-                sscanf(optarg, "%hd", &port);
-                if (port < 1)
-                    port = CACHE_HTTP_PORT;	/* default */
-                break;
-
             case 'P':
                 put_file = xstrdup(optarg);
                 break;
@@ -313,7 +294,7 @@ main(int argc, char *argv[])
                 break;
 
             case 'T':
-                io_timeout = atoi(optarg);
+                Transport::Config.ioTimeout = atoi(optarg);
                 break;
 
             case 'u':
@@ -380,9 +361,9 @@ main(int argc, char *argv[])
         }
         // embed the -w proxy password into old-style cachemgr URLs
         if (at)
-            snprintf(url, BUFSIZ, "cache_object://%s/%s@%s", hostname, t, at);
+            snprintf(url, BUFSIZ, "cache_object://%s/%s@%s", Transport::Config.hostname, t, at);
         else
-            snprintf(url, BUFSIZ, "cache_object://%s/%s", hostname, t);
+            snprintf(url, BUFSIZ, "cache_object://%s/%s", Transport::Config.hostname, t);
         xfree(t);
     }
     if (put_file) {
@@ -499,8 +480,8 @@ main(int argc, char *argv[])
                 std::cerr << "ERROR: server host missing" << std::endl;
         }
         if (proxy_neg) {
-            if (hostname) {
-                snprintf(buf, BUFSIZ, "Proxy-Authorization: Negotiate %s\r\n", GSSAPI_token(hostname));
+            if (Transport::Config.hostname) {
+                snprintf(buf, BUFSIZ, "Proxy-Authorization: Negotiate %s\r\n", GSSAPI_token(Transport::Config.hostname));
                 strcat(msg, buf);
             } else
                 std::cerr << "ERROR: proxy server host missing" << std::endl;
@@ -525,61 +506,13 @@ main(int argc, char *argv[])
 
     for (uint32_t i = 0; loops == 0 || i < loops; ++i) {
         size_t fsize = 0;
-        struct addrinfo *AI = NULL;
-
-        debugVerbose(2, "Resolving... " << hostname);
-
-        /* Connect to the server */
 
-        if (localhost) {
-            if ( !iaddr.GetHostByName(localhost) ) {
-                std::cerr << "ERROR: Cannot resolve " << localhost << ": Host unknown." << std::endl;
-                exit(1);
-            }
-        } else {
-            /* Process the remote host name to locate the Protocol required
-               in case we are being asked to link to another version of squid */
-            if ( !iaddr.GetHostByName(hostname) ) {
-                std::cerr << "ERROR: Cannot resolve " << hostname << ": Host unknown." << std::endl;
-                exit(1);
-            }
-        }
-
-        iaddr.getAddrInfo(AI);
-        if ((conn = socket(AI->ai_family, AI->ai_socktype, 0)) < 0) {
-            std::cerr << "ERROR: could not open socket to " << iaddr << std::endl;
-            Ip::Address::FreeAddrInfo(AI);
-            exit(1);
-        }
-        Ip::Address::FreeAddrInfo(AI);
-
-        if (localhost && client_comm_bind(conn, iaddr) < 0) {
-            std::cerr << "ERROR: could not bind socket to " << iaddr << std::endl;
-            exit(1);
-        }
-
-        iaddr.setEmpty();
-        if ( !iaddr.GetHostByName(hostname) ) {
-            std::cerr << "ERROR: Cannot resolve " << hostname << ": Host unknown." << std::endl;
-            exit(1);
-        }
-
-        iaddr.port(port);
-
-        debugVerbose(2, "Connecting... " << hostname << " (" << iaddr << ")");
-
-        if (client_comm_connect(conn, iaddr) < 0) {
-            char hostnameBuf[MAX_IPSTRLEN];
-            iaddr.toUrl(hostnameBuf, MAX_IPSTRLEN);
-            std::cerr << "ERROR: Cannot connect to " << hostnameBuf
-                      << (!errno ?": Host unknown." : "") << std::endl;
-            exit(1);
-        }
-        debugVerbose(2, "Connected to: " << hostname << " (" << iaddr << ")");
+        if (!Transport::Connect())
+            continue;
 
         /* Send the HTTP request */
         debugVerbose(2, "Sending HTTP request ... ");
-        bytesWritten = mywrite(conn, msg, strlen(msg));
+        bytesWritten = Transport::Write(msg, strlen(msg));
 
         if (bytesWritten < 0) {
             std::cerr << "ERROR: write" << std::endl;
@@ -596,7 +529,7 @@ main(int argc, char *argv[])
             lseek(put_fd, 0, SEEK_SET);
             while ((x = read(put_fd, buf, sizeof(buf))) > 0) {
 
-                x = mywrite(conn, buf, x);
+                x = Transport::Write(buf, x);
 
                 total_bytes += x;
 
@@ -615,18 +548,30 @@ main(int argc, char *argv[])
         setmode(1, O_BINARY);
 #endif
 
-        while ((len = myread(conn, buf, sizeof(buf))) > 0) {
+        while ((len = Transport::Read(buf, sizeof(buf))) > 0) {
             fsize += len;
 
             if (to_stdout && fwrite(buf, len, 1, stdout) != 1)
                 std::cerr << "ERROR: writing to stdout: " << xstrerror() << std::endl;
         }
 
+#if USE_GNUTLS
+        if (Transport::Config.tlsEnabled) {
+            if (len == 0) {
+                std::cerr << "- Peer has closed the TLS connection" << std::endl;
+            } else if (!gnutls_error_is_fatal(len)) {
+                std::cerr << "WARNING: " << gnutls_strerror(len) << std::endl;
+            } else {
+                std::cerr << "ERROR: " << gnutls_strerror(len) << std::endl;
+            }
+        }
+#endif
+
 #if _SQUID_WINDOWS_
         setmode(1, O_TEXT);
 #endif
 
-        (void) close(conn);	/* done with socket */
+        Transport::CloseConnection();
 
         if (Ping::LoopDone(i))
             break;
@@ -635,32 +580,10 @@ main(int argc, char *argv[])
     }
 
     Ping::DisplayStats();
+    Transport::ShutdownTls();
     return 0;
 }
 
-/// Set up the source socket address from which to send.
-static int
-client_comm_bind(int sock, const Ip::Address &addr)
-{
-    static struct addrinfo *AI = NULL;
-    addr.getAddrInfo(AI);
-    int res = bind(sock, AI->ai_addr, AI->ai_addrlen);
-    Ip::Address::FreeAddrInfo(AI);
-    return res;
-}
-
-/// Set up the destination socket address for message to send to.
-static int
-client_comm_connect(int sock, const Ip::Address &addr)
-{
-    static struct addrinfo *AI = NULL;
-    addr.getAddrInfo(AI);
-    int res = connect(sock, AI->ai_addr, AI->ai_addrlen);
-    Ip::Address::FreeAddrInfo(AI);
-    Ping::TimerStart();
-    return res;
-}
-
 void
 pipe_handler(int sig)
 {
@@ -684,25 +607,3 @@ set_our_signal(void)
     signal(SIGPIPE, pipe_handler);
 #endif
 }
-
-static ssize_t
-myread(int fd, void *buf, size_t len)
-{
-#if _SQUID_WINDOWS_
-    return recv(fd, buf, len, 0);
-#else
-    alarm(io_timeout);
-    return read(fd, buf, len);
-#endif
-}
-
-static ssize_t
-mywrite(int fd, void *buf, size_t len)
-{
-#if _SQUID_WINDOWS_
-    return send(fd, buf, len, 0);
-#else
-    alarm(io_timeout);
-    return write(fd, buf, len);
-#endif
-}