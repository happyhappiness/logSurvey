----++++src/FwdState.cc
@@ -161,7 +161,10 @@ void FwdState::start(Pointer aSelf)
     // We hope that either the store entry aborts or peer is selected.
     // Otherwise we are going to leak our object.
 
-    entry-&gt;registerAbort(FwdState::abort, this);
+    // Ftp::Relay needs to preserve control connection on data aborts
+    // so it registers its own abort handler that calls ours when needed.
+    if (!request-&gt;flags.ftpNative)
+        entry-&gt;registerAbort(FwdState::abort, this);
 
 #if STRICT_ORIGINAL_DST
     // Bug 3243: CVE 2009-0801
----++++src/clients/Client.cc
@@ -247,7 +247,7 @@ Client::abortOnBadEntry(const char *abortReason)
         return false;
 
     debugs(11,5, HERE &lt;&lt; &quot;entry is not Accepting!&quot;);
-    abortTransaction(abortReason);
+    abortOnData(abortReason);
     return true;
 }
 
@@ -293,6 +293,13 @@ Client::noteBodyProducerAborted(BodyPipe::Pointer bp)
         handleRequestBodyProducerAborted();
 }
 
+bool
+Client::abortOnData(const char *reason)
+{
+    abortAll(reason);
+    return true;
+}
+
 // more origin request body data is available
 void
 Client::handleMoreRequestBodyAvailable()
@@ -367,12 +374,12 @@ Client::sentRequestBody(const CommIoCbParams &amp;io)
         err = new ErrorState(ERR_WRITE_ERROR, Http::scBadGateway, fwd-&gt;request);
         err-&gt;xerrno = io.xerrno;
         fwd-&gt;fail(err);
-        abortTransaction("I/O error while sending request body");
+        abortOnData("I/O error while sending request body");
         return;
     }
 
     if (EBIT_TEST(entry-&gt;flags, ENTRY_ABORTED)) {
-        abortTransaction("store entry aborted while sending request body");
+        abortOnData("store entry aborted while sending request body");
         return;
     }
 
@@ -847,7 +854,7 @@ Client::handleAdaptationAborted(bool bypassable)
 
     // TODO: bypass if possible
     if (!handledEarlyAdaptationAbort())
-        abortTransaction("adaptation failure with a filled entry");
+        abortAll("adaptation failure with a filled entry");
 }
 
 /// If the store entry is still empty, fully handles adaptation abort, returning
@@ -861,7 +868,7 @@ Client::handledEarlyAdaptationAbort()
         err-&gt;detailError(ERR_DETAIL_ICAP_RESPMOD_EARLY);
         fwd-&gt;fail(err);
         fwd-&gt;dontRetry(true);
-        abortTransaction("adaptation failure with an empty entry");
+        abortAll("adaptation failure with an empty entry");
         return true; // handled
     }
 
@@ -883,7 +890,7 @@ Client::handleAdaptationBlocked(const Adaptation::Answer &amp;answer)
     if (!entry-&gt;isEmpty()) { // too late to block (should not really happen)
         if (request)
             request-&gt;detailError(ERR_ICAP_FAILURE, ERR_DETAIL_RESPMOD_BLOCK_LATE);
-        abortTransaction("late adaptation block");
+        abortAll("late adaptation block");
         return;
     }
 
@@ -899,7 +906,7 @@ Client::handleAdaptationBlocked(const Adaptation::Answer &amp;answer)
     fwd-&gt;fail(err);
     fwd-&gt;dontRetry(true);
 
-    abortTransaction("timely adaptation block");
+    abortOnData("timely adaptation block");
 }
 
 void
@@ -936,7 +943,7 @@ Client::sendBodyIsTooLargeError()
     ErrorState *err = new ErrorState(ERR_TOO_BIG, Http::scForbidden, request);
     fwd-&gt;fail(err);
     fwd-&gt;dontRetry(true);
-    abortTransaction("Virgin body too large.");
+    abortOnData("Virgin body too large.");
 }
 
 // TODO: when HttpStateData sends all errors to ICAP,
----++++src/clients/Client.h
@@ -54,7 +54,12 @@ class Client:
     virtual void maybeReadVirginBody() = 0;
 
     /// abnormal transaction termination; reason is for debugging only
-    virtual void abortTransaction(const char *reason) = 0;
+    virtual void abortAll(const char *reason) = 0;
+
+    /// abnormal data transfer termination
+    /// \retval true the transaction will be terminated (abortAll called)
+    /// \reval false the transaction will survive
+    virtual bool abortOnData(const char *reason);
 
     /// a hack to reach HttpStateData::orignal_request
     virtual  HttpRequest *originalRequest();
----++++src/clients/FtpClient.cc
@@ -350,8 +350,8 @@ Ftp::Client::readControlReply(const CommIoCbParams &amp;io)
         return;
 
     if (EBIT_TEST(entry-&gt;flags, ENTRY_ABORTED)) {
-        abortTransaction("entry aborted during control reply read");
-        return;
+        if (abortOnData("entry aborted during control reply read"))
+            return;
     }
 
     assert(ctrl.offset &lt; ctrl.size);
@@ -381,7 +381,7 @@ Ftp::Client::readControlReply(const CommIoCbParams &amp;io)
         }
 
         /* XXX this may end up having to be serverComplete() .. */
-        abortTransaction("zero control reply read");
+        abortAll("zero control reply read");
         return;
     }
 
@@ -915,7 +915,7 @@ Ftp::Client::dataRead(const CommIoCbParams &amp;io)
     assert(io.fd == data.conn-&gt;fd);
 
     if (EBIT_TEST(entry-&gt;flags, ENTRY_ABORTED)) {
-        abortTransaction("entry aborted during dataRead");
+        abortOnData("entry aborted during dataRead");
         return;
     }
 
@@ -999,7 +999,7 @@ Ftp::Client::dataComplete()
  * including canceling close handlers
  */
 void
-Ftp::Client::abortTransaction(const char *reason)
+Ftp::Client::abortAll(const char *reason)
 {
     debugs(9, 3, &quot;aborting transaction for &quot; &lt;&lt; reason &lt;&lt;
            &quot;; FD &quot; &lt;&lt; (ctrl.conn!=NULL?ctrl.conn-&gt;fd:-1) &lt;&lt; &quot;, Data FD &quot; &lt;&lt; (data.conn!=NULL?data.conn-&gt;fd:-1) &lt;&lt; &quot;, this &quot; &lt;&lt; this);
----++++src/clients/FtpClient.h
@@ -167,7 +167,7 @@ class Client: public ::Client
     virtual void closeServer();
     virtual bool doneWithServer() const;
     virtual const Comm::ConnectionPointer &amp; dataConnection() const;
-    virtual void abortTransaction(const char *reason);
+    virtual void abortAll(const char *reason);
 
     virtual Http::StatusCode failedHttpStatus(err_type &amp;error);
     void ctrlClosed(const CommCloseCbParams &amp;io);
----++++src/clients/FtpGateway.cc
@@ -989,7 +989,7 @@ Ftp::Gateway::processReplyBody()
          * probably was aborted because content length exceeds one
          * of the maximum size limits.
          */
-        abortTransaction("entry aborted after calling appendSuccessHeader()");
+        abortAll("entry aborted after calling appendSuccessHeader()");
         return;
     }
 
@@ -1697,7 +1697,7 @@ Ftp::Gateway::processHeadResponse()
      * trying to write to the client.
      */
     if (EBIT_TEST(entry-&gt;flags, ENTRY_ABORTED)) {
-        abortTransaction("entry aborted while processing HEAD");
+        abortAll("entry aborted while processing HEAD");
         return;
     }
 
@@ -1914,7 +1914,7 @@ Ftp::Gateway::ftpAcceptDataConnection(const CommAcceptCbParams &amp;io)
     debugs(9, 3, HERE);
 
     if (EBIT_TEST(entry-&gt;flags, ENTRY_ABORTED)) {
-        abortTransaction("entry aborted when accepting data conn");
+        abortAll("entry aborted when accepting data conn");
         data.listenConn-&gt;close();
         data.listenConn = NULL;
         return;
----++++src/clients/FtpRelay.cc
@@ -54,6 +54,7 @@ class Relay: public Ftp::Client
     virtual void handleRequestBodyProducerAborted();
     virtual bool mayReadVirginReplyBody() const;
     virtual void completeForwarding();
+    virtual bool abortOnData(const char *reason);
 
     /* AsyncJob API */
     virtual void start();
@@ -88,6 +89,9 @@ class Relay: public Ftp::Client
     void readUserOrPassReply();
 
     void scheduleReadControlReply();
+    void finalizeDataDownload();
+
+    static void abort(void *d); // TODO: Capitalize this and FwdState::abort().
 
     bool forwardingCompleted; ///&lt; completeForwarding() has been called
 
@@ -148,6 +152,8 @@ Ftp::Relay::Relay(FwdState *const fwdState):
     // Nothing we can do at request creation time can mark the response as
     // uncachable, unfortunately. This prevents &quot;found KEY_PRIVATE&quot; WARNINGs.
     entry-&gt;releaseRequest();
+    // TODO: Convert registerAbort() to use AsyncCall
+    entry-&gt;registerAbort(Ftp::Relay::abort, this);
 }
 
 Ftp::Relay::~Relay()
@@ -281,7 +287,14 @@ Ftp::Relay::processReplyBody()
          * probably was aborted because content length exceeds one
          * of the maximum size limits.
          */
-        abortTransaction(&quot;entry aborted after calling appendSuccessHeader()&quot;);
+        abortOnData(&quot;entry aborted after calling appendSuccessHeader()&quot;);
+        return;
+    }
+
+    if (master().userDataDone) {
+        // Squid-to-client data transfer done. Abort data transfer on our
+        // side to allow new commands from ftp client
+        abortOnData(&quot;Squid-to-client data connection is closed&quot;);
         return;
     }
 
@@ -477,7 +490,7 @@ void
 Ftp::Relay::sendCommand()
 {
     if (!fwd-&gt;request-&gt;header.has(Http::HdrType::FTP_COMMAND)) {
-        abortTransaction("Internal error: FTP relay request with no command");
+        abortAll("Internal error: FTP relay request with no command");
         return;
     }
 
@@ -675,7 +688,7 @@ Ftp::Relay::readTransferDoneReply()
                &quot; after reading response data&quot;);
     }
 
-    serverComplete();
+    finalizeDataDownload();
 }
 
 void
@@ -703,6 +716,55 @@ Ftp::Relay::scheduleReadControlReply()
     Ftp::Client::scheduleReadControlReply(0);
 }
 
+void
+Ftp::Relay::finalizeDataDownload()
+{
+    debugs(9, 2, &quot;Complete data downloading/Uploading&quot;);
+
+    updateMaster().waitForOriginData = false;
+
+    CbcPointer&lt;ConnStateData&gt; &amp;mgr = fwd-&gt;request-&gt;clientConnectionManager;
+    if (mgr.valid()) {
+        if (Ftp::Server *srv = dynamic_cast&lt;Ftp::Server*&gt;(mgr.get())) {
+            typedef NullaryMemFunT&lt;Ftp::Server&gt; CbDialer;
+            AsyncCall::Pointer call = JobCallback(11, 3, CbDialer, srv,
+                                                        Ftp::Server::originDataCompletionCheckpoint);
+            ScheduleCallHere(call);
+        }
+    }
+    serverComplete();
+}
+
+bool
+Ftp::Relay::abortOnData(const char *reason)
+{
+    debugs(9, 3, &quot;aborting transaction for &quot; &lt;&lt; reason &lt;&lt;
+           &quot;; FD &quot; &lt;&lt; (ctrl.conn != NULL ? ctrl.conn-&gt;fd : -1) &lt;&lt; &quot;, Data FD &quot; &lt;&lt; (data.conn != NULL ? data.conn-&gt;fd : -1) &lt;&lt; &quot;, this &quot; &lt;&lt; this);
+    // this method is only called to handle data connection problems
+    // the control connection should keep going
+
+#if USE_ADAPTATION
+    if (adaptedBodySource != NULL)
+        stopConsumingFrom(adaptedBodySource);
+#endif
+
+    if (Comm::IsConnOpen(data.conn))
+        dataComplete();
+
+    return !Comm::IsConnOpen(ctrl.conn);
+}
+
+void
+Ftp::Relay::abort(void *d)
+{
+    Ftp::Relay *ftpClient = (Ftp::Relay *)d;
+    debugs(9, 2, &quot;Client Data connection closed!&quot;);
+    if (!cbdataReferenceValid(ftpClient))
+        return;
+    if (Comm::IsConnOpen(ftpClient-&gt;data.conn))
+        ftpClient-&gt;dataComplete();
+}
+
 AsyncJob::Pointer
 Ftp::StartRelay(FwdState *const fwdState)
 {
----++++src/http.cc
@@ -2466,7 +2466,7 @@ HttpStateData::sentRequestBody(const CommIoCbParams &amp;io)
 // TODO: destruction should be sufficient as the destructor should cleanup,
 // including canceling close handlers
 void
-HttpStateData::abortTransaction(const char *reason)
+HttpStateData::abortAll(const char *reason)
 {
     debugs(11,5, HERE &lt;&lt; &quot;aborting transaction for &quot; &lt;&lt; reason &lt;&lt;
            &quot;; &quot; &lt;&lt; serverConnection &lt;&lt; &quot;, this &quot; &lt;&lt; this);
@@ -2477,6 +2477,6 @@ HttpStateData::abortTransaction(const char *reason)
     }
 
     fwd-&gt;handleUnregisteredServerEnd();
-    mustStop("HttpStateData::abortTransaction");
+    mustStop("HttpStateData::abortAll");
 }
 
----++++src/http.h
@@ -84,9 +84,11 @@ class HttpStateData : public Client
     virtual bool getMoreRequestBody(MemBuf &amp;buf);
     virtual void closeServer(); // end communication with the server
     virtual bool doneWithServer() const; // did we end communication?
-    virtual void abortTransaction(const char *reason); // abnormal termination
+    virtual void abortAll(const char *reason); // abnormal termination
     virtual bool mayReadVirginReplyBody() const;
 
+    void abortTransaction(const char *reason) { abortAll(reason); } // abnormal termination
+
     /**
      * determine if read buffer can have space made available
      * for a read.
----++++GitHub