@@ -62,6 +62,9 @@ AccessLogEntry::~AccessLogEntry()
     safe_free(headers.adapted_request);
     HTTPMSGUNLOCK(adapted_request);
 
+    safe_free(lastAclName);
+    safe_free(lastAclData);
+
     HTTPMSGUNLOCK(reply);
     HTTPMSGUNLOCK(request);
 #if ICAP_CLIENT
@@ -39,8 +39,14 @@ class AccessLogEntry: public RefCountable
 public:
     typedef RefCount<AccessLogEntry> Pointer;
 
-    AccessLogEntry() : url(NULL), tcpClient(), reply(NULL), request(NULL),
-        adapted_request(NULL) {}
+    AccessLogEntry() :
+        url(nullptr),
+        lastAclName(nullptr),
+        lastAclData(nullptr),
+        reply(nullptr),
+        request(nullptr),
+        adapted_request(nullptr)
+    {}
     ~AccessLogEntry();
 
     /// Fetch the client IP log string into the given buffer.
@@ -207,6 +213,10 @@ class AccessLogEntry: public RefCountable
 
         const char *method_str;
     } _private;
+
+    const char *lastAclName; ///< string for external_acl_type %ACL format code
+    const char *lastAclData; ///< string for external_acl_type %DATA format code
+
     HierarchyLogEntry hier;
     HttpReply *reply;
     HttpRequest *request; //< virgin HTTP request
@@ -51,6 +51,7 @@ class ACLExternal : public ACL
     virtual void parse();
     virtual int match(ACLChecklist *checklist);
     /* This really should be dynamic based on the external class defn */
+    virtual bool requiresAle() const {return true;}
     virtual bool requiresRequest() const {return true;}
 
     /* when requiresRequest is made dynamic, review this too */
@@ -3464,6 +3464,7 @@ tests_testURL_SOURCES = \
 	int.cc \
 	internal.h \
 	internal.cc \
+	tests/stub_libeui.cc \
 	LogTags.cc \
 	SquidList.h \
 	SquidList.cc \
@@ -153,13 +153,20 @@ ACL::matches(ACLChecklist *checklist) const
     AclMatchedName = name;
 
     int result = 0;
-    if (!checklist->hasRequest() && requiresRequest()) {
+    if (!checklist->hasAle() && requiresAle()) {
+        debugs(28, DBG_IMPORTANT, "WARNING: " << name << " ACL is used in " <<
+               "context without an ALE state. Assuming mismatch.");
+    } else if (!checklist->hasRequest() && requiresRequest()) {
         debugs(28, DBG_IMPORTANT, "WARNING: " << name << " ACL is used in " <<
                "context without an HTTP request. Assuming mismatch.");
     } else if (!checklist->hasReply() && requiresReply()) {
         debugs(28, DBG_IMPORTANT, "WARNING: " << name << " ACL is used in " <<
                "context without an HTTP response. Assuming mismatch.");
     } else {
+        // make sure the ALE has as much data as possible
+        if (requiresAle())
+            checklist->syncAle();
+
         // have to cast because old match() API is missing const
         result = const_cast<ACL*>(this)->match(checklist);
     }
@@ -367,6 +374,12 @@ aclCacheMatchFlush(dlink_list * cache)
     }
 }
 
+bool
+ACL::requiresAle() const
+{
+    return false;
+}
+
 bool
 ACL::requiresReply() const
 {
@@ -141,6 +141,8 @@ class ACL
     /// Matches the actual data in checklist against this ACL.
     virtual int match(ACLChecklist *checklist) = 0; // XXX: missing const
 
+    /// whether our (i.e. shallow) match() requires checklist to have a AccessLogEntry
+    virtual bool requiresAle() const;
     /// whether our (i.e. shallow) match() requires checklist to have a request
     virtual bool requiresRequest() const;
     /// whether our (i.e. shallow) match() requires checklist to have a reply
@@ -163,6 +163,8 @@ class ACLChecklist
     // for ACL::checklistMatches to use
     virtual bool hasRequest() const = 0;
     virtual bool hasReply() const = 0;
+    virtual bool hasAle() const = 0;
+    virtual void syncAle() const = 0;
 
     /// change the current ACL list
     /// \return a pointer to the old list value (may be nullptr)
@@ -66,6 +66,62 @@ ACLFilledChecklist::~ACLFilledChecklist()
     debugs(28, 4, HERE << "ACLFilledChecklist destroyed " << this);
 }
 
+static void
+showDebugWarning(const char *msg)
+{
+    static uint16_t count = 0;
+    if (count > 100)
+        return;
+
+    ++count;
+    debugs(28, DBG_IMPORTANT, "ALE missing " << msg);
+}
+
+void
+ACLFilledChecklist::syncAle() const
+{
+    // make sure the ALE fields used by Format::assemble to
+    // fill the old external_acl_type codes are set if any
+    // data on them exists in the Checklist
+
+    if (!al->cache.port && conn()) {
+        showDebugWarning("listening port");
+        al->cache.port = conn()->port;
+    }
+
+    if (request) {
+        if (!al->request) {
+            showDebugWarning("HttpRequest object");
+            al->request = request;
+            HTTPMSGLOCK(al->request);
+        }
+
+        if (!al->adapted_request) {
+            showDebugWarning("adapted HttpRequest object");
+            al->adapted_request = request;
+            HTTPMSGLOCK(al->adapted_request);
+        }
+
+        if (!al->url) {
+            showDebugWarning("URL");
+            al->url = xstrdup(request->url.absolute().c_str());
+        }
+    }
+
+    if (reply && !al->reply) {
+        showDebugWarning("HttpReply object");
+        al->reply = reply;
+        HTTPMSGLOCK(al->reply);
+    }
+
+#if USE_IDENT
+    if (*rfc931 && !al->cache.rfc931) {
+        showDebugWarning("IDENT");
+        al->cache.rfc931 = xstrdup(rfc931);
+    }
+#endif
+}
+
 ConnStateData *
 ACLFilledChecklist::conn() const
 {
@@ -62,6 +62,8 @@ class ACLFilledChecklist: public ACLChecklist
     // ACLChecklist API
     virtual bool hasRequest() const { return request != NULL; }
     virtual bool hasReply() const { return reply != NULL; }
+    virtual bool hasAle() const { return al != NULL; }
+    virtual void syncAle() const;
 
 public:
     Ip::Address src_addr;
@@ -88,7 +90,7 @@ class ACLFilledChecklist: public ACLChecklist
     Security::CertPointer serverCert;
 #endif
 
-    AccessLogEntry::Pointer al; ///< info for the future access.log entry
+    AccessLogEntry::Pointer al; ///< info for the future access.log, and external ACL
 
     ExternalACLEntryPointer extacl_entry;
 
@@ -717,11 +717,11 @@ DOC_START
 	Options:
 
 	  ttl=n		TTL in seconds for cached results (defaults to 3600
-	  		for 1 hour)
+			for 1 hour)
 
 	  negative_ttl=n
-	  		TTL for cached negative lookups (default same
-	  		as ttl)
+			TTL for cached negative lookups (default same
+			as ttl)
 
 	  grace=n	Percentage remaining of TTL where a refresh of a
 			cached entry should be initiated without needing to
@@ -761,63 +761,33 @@ DOC_START
 			The default is to auto-detect IPv6 and use it when available.
 
 
-	FORMAT specifications
-
-	  %LOGIN	Authenticated user login name
-	  %un		A user name. Expands to the first available name
-	  		from the following list of information sources:
-			- authenticated user name, like %ul or %LOGIN
-			- user name sent by an external ACL, like %EXT_USER
-			- SSL client name, like %us in logformat
-			- ident user name, like %ui in logformat
-	  %EXT_USER	Username from previous external acl
-	  %EXT_LOG	Log details from previous external acl
-	  %EXT_TAG	Tag from previous external acl
-	  %IDENT	Ident user name
-	  %SRC		Client IP
-	  %SRCPORT	Client source port
-	  %URI		Requested URI
-	  %DST		Requested host
-	  %PROTO	Requested URL scheme
-	  %PORT		Requested port
-	  %PATH		Requested URL path
-	  %METHOD	Request method
-	  %MYADDR	Squid interface address
-	  %MYPORT	Squid http_port number
-	  %PATH		Requested URL-path (including query-string if any)
-	  %USER_CERT	SSL User certificate in PEM format
-	  %USER_CERTCHAIN SSL User certificate chain in PEM format
-	  %USER_CERT_xx	SSL User certificate subject attribute xx
-	  %USER_CA_CERT_xx SSL User certificate issuer attribute xx
-	  %ssl::>sni	SSL client SNI sent to Squid
-	  %ssl::<cert_subject SSL server certificate DN
-	  %ssl::<cert_issuer SSL server certificate issuer DN
-
-	  %>{Header}	HTTP request header "Header"
-	  %>{Hdr:member}
-	  		HTTP request header "Hdr" list member "member"
-	  %>{Hdr:;member}
-	  		HTTP request header list member using ; as
-	  		list separator. ; can be any non-alphanumeric
-			character.
-
-	  %<{Header}	HTTP reply header "Header"
-	  %<{Hdr:member}
-	  		HTTP reply header "Hdr" list member "member"
-	  %<{Hdr:;member}
-	  		HTTP reply header list member using ; as
-	  		list separator. ; can be any non-alphanumeric
-			character.
+	FORMAT is a series of %macro codes. See logformat directive for a full list
+	of the accepted codes. Although note that at the time of any external ACL
+	being tested data may not be available and thus some %macro expand to '-'.
+
+	In addition to the logformat codes; when processing external ACLs these
+	additional macros are made available:
 
 	  %ACL		The name of the ACL being tested.
-	  %DATA		The ACL arguments. If not used then any arguments
-			is automatically added at the end of the line
-			sent to the helper.
-			NOTE: this will encode the arguments as one token,
-			whereas the default will pass each separately.
 
-	  %%		The percent sign. Useful for helpers which need
-			an unchanging input format.
+	  %DATA		The ACL arguments. If a logformat encoding modifier
+			is used it will encode the whole set of arguments
+			as a single token.
+
+			If not used; then any arguments are automatically
+			added at the end of the line sent to the helper
+			as separately URL-encoded fields.
+
+	If SSL is enabled, the following formating codes become available:
+
+	  %USER_CERT		SSL User certificate in PEM format
+	  %USER_CERTCHAIN	SSL User certificate chain in PEM format
+	  %USER_CERT_xx		SSL User certificate subject attribute xx
+	  %USER_CA_CERT_xx	SSL User certificate issuer attribute xx
+
+
+	NOTE: all other format codes accepted by older Squid versions
+		are deprecated.
 
 
 	General request syntax:
@@ -885,9 +855,9 @@ DOC_START
 			does not alter existing tags.
 
 	  log=		String to be logged in access.log. Available as
-	  		%ea in logformat specifications.
+			%ea in logformat specifications.
 
-  	  clt_conn_tag= Associates a TAG with the client TCP connection.
+	  clt_conn_tag= Associates a TAG with the client TCP connection.
 			Please see url_rewrite_program related documentation
 			for this kv-pair.
 
@@ -3952,11 +3922,12 @@ DOC_START
 	modifiers are usually not needed, but can be specified if an explicit
 	output format is desired.
 
-		% ["|[|'|#] [-] [[0]width] [{argument}] formatcode
+		% ["|[|'|#|/] [-] [[0]width] [{arg}] formatcode [{arg}]
 
 		"	output in quoted string format
 		[	output in squid text log format as used by log_mime_hdrs
 		#	output in URL quoted format
+		/	output in shell \-escaped format
 		'	output as-is
 
 		-	left aligned
@@ -3966,7 +3937,8 @@ DOC_START
 			When minimum starts with 0, the field is zero-padded.
 			String values exceeding maximum width are truncated.
 
-		{arg}	argument such as header name etc
+		{arg}	argument such as header name etc. This field may be
+			placed before or after the token, but not both at once.
 
 	Format codes:
 
@@ -13,12 +13,13 @@
 #include "acl/FilledChecklist.h"
 #include "cache_cf.h"
 #include "client_side.h"
+#include "client_side_request.h"
 #include "comm/Connection.h"
 #include "ConfigParser.h"
 #include "ExternalACL.h"
 #include "ExternalACLEntry.h"
 #include "fde.h"
-#include "format/ByteCode.h"
+#include "format/Token.h"
 #include "helper.h"
 #include "helper/Reply.h"
 #include "HttpHeaderTools.h"
@@ -66,33 +67,6 @@ static ExternalACLEntryPointer external_acl_cache_add(external_acl * def, const
  * external_acl directive
  */
 
-class external_acl_format : public RefCountable
-{
-    MEMPROXY_CLASS(external_acl_format);
-
-public:
-    typedef RefCount<external_acl_format> Pointer;
-
-    external_acl_format() :
-        type(Format::LFT_NONE),
-        header(nullptr),
-        member(nullptr),
-        separator(' '),
-        header_id(Http::HdrType::BAD_HDR)
-    {}
-    ~external_acl_format() {
-        xfree(header);
-        xfree(member);
-    }
-
-    Format::ByteCode_t type;
-    external_acl_format::Pointer next;
-    char *header;
-    char *member;
-    char separator;
-    Http::HdrType header_id;
-};
-
 class external_acl
 {
     /* FIXME: These are not really cbdata, but it is an easy way
@@ -118,7 +92,7 @@ class external_acl
 
     char *name;
 
-    external_acl_format::Pointer format;
+    Format::Format format;
 
     wordlist *cmdline;
 
@@ -146,10 +120,7 @@ class external_acl
     bool require_auth;
 #endif
 
-    enum {
-        QUOTE_METHOD_SHELL = 1,
-        QUOTE_METHOD_URL
-    } quote;
+    Format::Quoting quote; // default quoting to use, set by protocol= parameter
 
     Ip::Address local_addr;
 };
@@ -162,6 +133,7 @@ external_acl::external_acl() :
     negative_ttl(-1),
     grace(1),
     name(NULL),
+    format("external_acl_type"),
     cmdline(NULL),
     children(DEFAULT_EXTERNAL_ACL_CHILDREN),
     theHelper(NULL),
@@ -171,15 +143,14 @@ external_acl::external_acl() :
 #if USE_AUTH
     require_auth(0),
 #endif
-    quote(external_acl::QUOTE_METHOD_URL)
+    quote(Format::LOG_QUOTE_URL)
 {
     local_addr.setLocalhost();
 }
 
 external_acl::~external_acl()
 {
     xfree(name);
-    format = NULL;
     wordlistDestroy(&cmdline);
 
     if (theHelper) {
@@ -203,56 +174,6 @@ external_acl::~external_acl()
     }
 }
 
-/**
- * Parse the External ACL format %<{.*} and %>{.*} token(s) to pass a specific
- * request or reply header to external helper.
- *
- \param header   - the token being parsed (without the identifying prefix)
- \param type     - format enum identifier for this element, pulled from identifying prefix
- \param format   - structure to contain all the info about this format element.
- */
-void
-parse_header_token(external_acl_format::Pointer format, char *header, const Format::ByteCode_t type)
-{
-    /* header format */
-    char *member, *end;
-
-    /** Cut away the closing brace */
-    end = strchr(header, '}');
-    if (end && strlen(end) == 1)
-        *end = '\0';
-    else
-        self_destruct();
-
-    member = strchr(header, ':');
-
-    if (member) {
-        /* Split in header and member */
-        *member = '\0';
-        ++member;
-
-        if (!xisalnum(*member)) {
-            format->separator = *member;
-            ++member;
-        } else {
-            format->separator = ',';
-        }
-
-        format->member = xstrdup(member);
-
-        if (type == Format::LFT_ADAPTED_REQUEST_HEADER)
-            format->type = Format::LFT_ADAPTED_REQUEST_HEADER_ELEM;
-        else
-            format->type = Format::LFT_REPLY_HEADER_ELEM;
-
-    } else {
-        format->type = type;
-    }
-
-    format->header = xstrdup(header);
-    format->header_id = Http::HeaderLookupTable.lookup(SBuf(header)).id;
-}
-
 void
 parse_externalAclHelper(external_acl ** list)
 {
@@ -293,16 +214,16 @@ parse_externalAclHelper(external_acl ** list)
         } else if (strncmp(token, "grace=", 6) == 0) {
             a->grace = atoi(token + 6);
         } else if (strcmp(token, "protocol=2.5") == 0) {
-            a->quote = external_acl::QUOTE_METHOD_SHELL;
+            a->quote = Format::LOG_QUOTE_SHELL;
         } else if (strcmp(token, "protocol=3.0") == 0) {
             debugs(3, DBG_PARSE_NOTE(2), "WARNING: external_acl_type option protocol=3.0 is deprecated. Remove this from your config.");
-            a->quote = external_acl::QUOTE_METHOD_URL;
+            a->quote = Format::LOG_QUOTE_URL;
         } else if (strcmp(token, "quote=url") == 0) {
             debugs(3, DBG_PARSE_NOTE(2), "WARNING: external_acl_type option quote=url is deprecated. Remove this from your config.");
-            a->quote = external_acl::QUOTE_METHOD_URL;
+            a->quote = Format::LOG_QUOTE_URL;
         } else if (strcmp(token, "quote=shell") == 0) {
             debugs(3, DBG_PARSE_NOTE(2), "WARNING: external_acl_type option quote=shell is deprecated. Use protocol=2.5 if still needed.");
-            a->quote = external_acl::QUOTE_METHOD_SHELL;
+            a->quote = Format::LOG_QUOTE_SHELL;
 
             /* INET6: allow admin to configure some helpers explicitly to
                       bind to IPv4/v6 localhost port. */
@@ -338,121 +259,75 @@ parse_externalAclHelper(external_acl ** list)
     if (a->children.defaultQueueSize)
         a->children.queue_size = 2 * a->children.n_max;
 
-    /* Parse format */
-    external_acl_format::Pointer *p = &a->format;
-
+    /* Legacy external_acl_type format parser.
+     * Handles a series of %... tokens where any non-% means
+     * the start of another parameter field (ie the path to binary).
+     */
+    enum Format::Quoting quote = Format::LOG_QUOTE_NONE;
+    Format::Token **fmt = &a->format.format;
+    bool data_used = false;
     while (token) {
-        /* stop on first non-format token found */
-
+        /* stop on first non-% token found */
         if (*token != '%')
             break;
 
-        external_acl_format::Pointer format = new external_acl_format;
-
-        if (strncmp(token, "%{", 2) == 0) {
-            // deprecated. but assume the old configs all referred to request headers.
-            debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type format %{...} is being replaced by %>ha{...} for : " << token);
-            parse_header_token(format, (token+2), Format::LFT_ADAPTED_REQUEST_HEADER);
-        } else if (strncmp(token, "%>{", 3) == 0) {
-            debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type format %>{...} is being replaced by %>ha{...} for : " << token);
-            parse_header_token(format, (token+3), Format::LFT_ADAPTED_REQUEST_HEADER);
-        } else if (strncmp(token, "%>ha{", 5) == 0) {
-            parse_header_token(format, (token+5), Format::LFT_ADAPTED_REQUEST_HEADER);
-        } else if (strncmp(token, "%<{", 3) == 0) {
-            debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type format %<{...} is being replaced by %<h{...} for : " << token);
-            parse_header_token(format, (token+3), Format::LFT_REPLY_HEADER);
-        } else if (strncmp(token, "%<h{", 4) == 0) {
-            parse_header_token(format, (token+4), Format::LFT_REPLY_HEADER);
-#if USE_AUTH
-        } else if (strcmp(token, "%LOGIN") == 0 || strcmp(token, "%ul") == 0) {
-            format->type = Format::LFT_USER_LOGIN;
-            a->require_auth = true;
-#endif
-        }
-#if USE_IDENT
-        else if (strcmp(token, "%IDENT") == 0 || strcmp(token, "%ui") == 0)
-            format->type = Format::LFT_USER_IDENT;
-#endif
-        else if (strcmp(token, "%SRC") == 0 || strcmp(token, "%>a") == 0)
-            format->type = Format::LFT_CLIENT_IP_ADDRESS;
-        else if (strcmp(token, "%SRCPORT") == 0 || strcmp(token, "%>p") == 0)
-            format->type = Format::LFT_CLIENT_PORT;
-#if USE_SQUID_EUI
-        else if (strcmp(token, "%SRCEUI48") == 0)
-            format->type = Format::LFT_EXT_ACL_CLIENT_EUI48;
-        else if (strcmp(token, "%SRCEUI64") == 0)
-            format->type = Format::LFT_EXT_ACL_CLIENT_EUI64;
-#endif
-        else if (strcmp(token, "%MYADDR") == 0 || strcmp(token, "%la") == 0)
-            format->type = Format::LFT_LOCAL_LISTENING_IP;
-        else if (strcmp(token, "%MYPORT") == 0 || strcmp(token, "%lp") == 0)
-            format->type = Format::LFT_LOCAL_LISTENING_PORT;
-        else if (strcmp(token, "%URI") == 0 || strcmp(token, "%>ru") == 0)
-            format->type = Format::LFT_CLIENT_REQ_URI;
-        else if (strcmp(token, "%DST") == 0 || strcmp(token, "%>rd") == 0)
-            format->type = Format::LFT_CLIENT_REQ_URLDOMAIN;
-        else if (strcmp(token, "%PROTO") == 0 || strcmp(token, "%>rs") == 0)
-            format->type = Format::LFT_CLIENT_REQ_URLSCHEME;
-        else if (strcmp(token, "%PORT") == 0) // XXX: add a logformat token
-            format->type = Format::LFT_CLIENT_REQ_URLPORT;
-        else if (strcmp(token, "%PATH") == 0 || strcmp(token, "%>rp") == 0)
-            format->type = Format::LFT_CLIENT_REQ_URLPATH;
-        else if (strcmp(token, "%METHOD") == 0 || strcmp(token, "%>rm") == 0)
-            format->type = Format::LFT_CLIENT_REQ_METHOD;
-#if USE_OPENSSL
-        else if (strcmp(token, "%USER_CERT") == 0)
-            format->type = Format::LFT_EXT_ACL_USER_CERT_RAW;
-        else if (strcmp(token, "%USER_CERTCHAIN") == 0)
-            format->type = Format::LFT_EXT_ACL_USER_CERTCHAIN_RAW;
-        else if (strncmp(token, "%USER_CERT_", 11) == 0) {
-            format->type = Format::LFT_EXT_ACL_USER_CERT;
-            format->header = xstrdup(token + 11);
+        *fmt = new Format::Token;
+        // these tokens are whitespace delimited
+        (*fmt)->space = true;
+
+        // set the default encoding to match the protocol= config
+        // this will be overridden by explicit %macro attributes
+        (*fmt)->quote = a->quote;
+
+        // compatibility for old tokens incompatible with Format::Token syntax
+#if USE_OPENSSL // dont bother if we dont have to.
+        if (strncmp(token, "%USER_CERT_", 11) == 0) {
+            (*fmt)->type = Format::LFT_EXT_ACL_USER_CERT;
+            (*fmt)->data.string = xstrdup(token + 11);
+            (*fmt)->data.header.header = (*fmt)->data.string;
         } else if (strncmp(token, "%USER_CA_CERT_", 14) == 0) {
-            format->type = Format::LFT_EXT_ACL_USER_CA_CERT;
-            format->header = xstrdup(token + 14);
+            (*fmt)->type = Format::LFT_EXT_ACL_USER_CA_CERT;
+            (*fmt)->data.string = xstrdup(token + 14);
+            (*fmt)->data.header.header = (*fmt)->data.string;
         } else if (strncmp(token, "%CA_CERT_", 9) == 0) {
             debugs(82, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: external_acl_type %CA_CERT_* code is obsolete. Use %USER_CA_CERT_* instead");
-            format->type = Format::LFT_EXT_ACL_USER_CA_CERT;
-            format->header = xstrdup(token + 9);
-        } else if (strcmp(token, "%ssl::>sni") == 0)
-            format->type = Format::LFT_SSL_CLIENT_SNI;
-        else if (strcmp(token, "%ssl::<cert_subject") == 0)
-            format->type = Format::LFT_SSL_SERVER_CERT_SUBJECT;
-        else if (strcmp(token, "%ssl::<cert_issuer") == 0)
-            format->type = Format::LFT_SSL_SERVER_CERT_ISSUER;
+            (*fmt)->type = Format::LFT_EXT_ACL_USER_CA_CERT;
+            (*fmt)->data.string = xstrdup(token + 9);
+            (*fmt)->data.header.header = (*fmt)->data.string;
+        } else
 #endif
+        {
+            // we can use the Format::Token::parse() method since it
+            // only pulls off one token. Since we already checked
+            // for '%' prefix above this is guaranteed to be a token.
+            const size_t len = (*fmt)->parse(token, &quote);
+            assert(len == strlen(token));
+        }
+
+        // process special token-specific actions (only if necessary)
 #if USE_AUTH
-        else if (strcmp(token, "%EXT_USER") == 0 || strcmp(token, "%ue") == 0)
-            format->type = Format::LFT_USER_EXTERNAL;
-#endif
-#if USE_AUTH || defined(USE_OPENSSL) || defined(USE_IDENT)
-        else if (strcmp(token, "%un") == 0)
-            format->type = Format::LFT_USER_NAME;
+        if ((*fmt)->type == Format::LFT_USER_LOGIN)
+            a->require_auth = true;
 #endif
-        else if (strcmp(token, "%EXT_LOG") == 0 || strcmp(token, "%ea") == 0)
-            format->type = Format::LFT_EXT_LOG;
-        else if (strcmp(token, "%TAG") == 0  || strcmp(token, "%et") == 0)
-            format->type = Format::LFT_TAG;
-        else if (strcmp(token, "%ACL") == 0)
-            format->type = Format::LFT_EXT_ACL_NAME;
-        else if (strcmp(token, "%DATA") == 0)
-            format->type = Format::LFT_EXT_ACL_DATA;
-        else if (strcmp(token, "%%") == 0)
-            format->type = Format::LFT_PERCENT;
-        else {
-            debugs(0, DBG_CRITICAL, "ERROR: Unknown Format token " << token);
-            self_destruct();
-        }
 
-        *p = format;
-        p = &format->next;
+        if ((*fmt)->type == Format::LFT_EXT_ACL_DATA)
+            data_used = true;
+
+        fmt = &((*fmt)->next);
         token = ConfigParser::NextToken();
     }
 
     /* There must be at least one format token */
-    if (!a->format)
+    if (!a->format.format)
         self_destruct();
 
+    // format has implicit %DATA on the end if not used explicitly
+    if (!data_used) {
+        *fmt = new Format::Token;
+        (*fmt)->type = Format::LFT_EXT_ACL_DATA;
+        (*fmt)->quote = Format::LOG_QUOTE_URL;
+    }
+
     /* helper */
     if (!token)
         self_destruct();
@@ -506,76 +381,10 @@ dump_externalAclHelper(StoreEntry * sentry, const char *name, const external_acl
         if (node->cache)
             storeAppendPrintf(sentry, " cache=%d", node->cache_size);
 
-        if (node->quote == external_acl::QUOTE_METHOD_SHELL)
+        if (node->quote == Format::LOG_QUOTE_SHELL)
             storeAppendPrintf(sentry, " protocol=2.5");
 
-        for (external_acl_format::Pointer format = node->format; format!= NULL; format = format->next) {
-            switch (format->type) {
-
-            case Format::LFT_ADAPTED_REQUEST_HEADER:
-                storeAppendPrintf(sentry, " %%>ha{%s}", format->header);
-                break;
-
-            case Format::LFT_ADAPTED_REQUEST_HEADER_ELEM:
-                storeAppendPrintf(sentry, " %%>ha{%s:%s}", format->header, format->member);
-                break;
-
-            case Format::LFT_REPLY_HEADER:
-                storeAppendPrintf(sentry, " %%<h{%s}", format->header);
-                break;
-
-            case Format::LFT_REPLY_HEADER_ELEM:
-                storeAppendPrintf(sentry, " %%<h{%s:%s}", format->header, format->member);
-                break;
-
-#define DUMP_EXT_ACL_TYPE_FMT(a, fmt, ...) \
-            case Format::LFT_##a: \
-                storeAppendPrintf(sentry, fmt, ##__VA_ARGS__); \
-                break
-#if USE_AUTH
-                DUMP_EXT_ACL_TYPE_FMT(USER_LOGIN," %%ul");
-                DUMP_EXT_ACL_TYPE_FMT(USER_NAME," %%un");
-#endif
-#if USE_IDENT
-
-                DUMP_EXT_ACL_TYPE_FMT(USER_IDENT," %%ui");
-#endif
-                DUMP_EXT_ACL_TYPE_FMT(CLIENT_IP_ADDRESS," %%>a");
-                DUMP_EXT_ACL_TYPE_FMT(CLIENT_PORT," %%>p");
-#if USE_SQUID_EUI
-                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_CLIENT_EUI48," %%SRCEUI48");
-                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_CLIENT_EUI64," %%SRCEUI64");
-#endif
-                DUMP_EXT_ACL_TYPE_FMT(LOCAL_LISTENING_IP," %%>la");
-                DUMP_EXT_ACL_TYPE_FMT(LOCAL_LISTENING_PORT," %%>lp");
-                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URI," %%>ru");
-                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URLDOMAIN," %%>rd");
-                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URLSCHEME," %%>rs");
-                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URLPORT," %%>rP");
-                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_URLPATH," %%>rp");
-                DUMP_EXT_ACL_TYPE_FMT(CLIENT_REQ_METHOD," %%>rm");
-#if USE_OPENSSL
-                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_USER_CERT_RAW, " %%USER_CERT_RAW");
-                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_USER_CERTCHAIN_RAW, " %%USER_CERTCHAIN_RAW");
-                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_USER_CERT, " %%USER_CERT_%s", format->header);
-                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_USER_CA_CERT, " %%USER_CA_CERT_%s", format->header);
-                DUMP_EXT_ACL_TYPE_FMT(SSL_CLIENT_SNI, "%%ssl::>sni");
-                DUMP_EXT_ACL_TYPE_FMT(SSL_SERVER_CERT_SUBJECT, "%%ssl::<cert_subject");
-                DUMP_EXT_ACL_TYPE_FMT(SSL_SERVER_CERT_ISSUER, "%%ssl::<cert_issuer");
-#endif
-#if USE_AUTH
-                DUMP_EXT_ACL_TYPE_FMT(USER_EXTERNAL," %%ue");
-#endif
-                DUMP_EXT_ACL_TYPE_FMT(EXT_LOG," %%ea");
-                DUMP_EXT_ACL_TYPE_FMT(TAG," %%et");
-                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_NAME," %%ACL");
-                DUMP_EXT_ACL_TYPE_FMT(EXT_ACL_DATA," %%DATA");
-                DUMP_EXT_ACL_TYPE_FMT(PERCENT, " %%%%");
-            default:
-                fatal("unknown external_acl format error");
-                break;
-            }
-        }
+        node->format.dump(sentry, NULL, false);
 
         for (word = node->cmdline; word; word = word->next)
             storeAppendPrintf(sentry, " %s", word->key);
@@ -898,265 +707,29 @@ external_acl_cache_touch(external_acl * def, const ExternalACLEntryPointer &entr
     dlinkAdd(e, &entry->lru, &def->lru_list);
 }
 
-#if USE_OPENSSL
-static const char *
-external_acl_ssl_get_user_attribute(const ACLFilledChecklist &ch, const char *attr)
-{
-    if (ch.conn() != NULL && Comm::IsConnOpen(ch.conn()->clientConnection)) {
-        if (SSL *ssl = fd_table[ch.conn()->clientConnection->fd].ssl)
-            return sslGetUserAttribute(ssl, attr);
-    }
-    return NULL;
-}
-#endif
-
 static char *
 makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
 {
     static MemBuf mb;
-    char buf[256];
-    int first = 1;
-    wordlist *arg;
-    HttpRequest *request = ch->request;
-    HttpReply *reply = ch->reply;
     mb.reset();
-    bool data_used = false;
-
-    for (external_acl_format::Pointer format = acl_data->def->format; format != NULL; format = format->next) {
-        const char *str = NULL;
-        String sb;
 
-        switch (format->type) {
-#if USE_AUTH
-        case Format::LFT_USER_LOGIN:
-            // if this ACL line was the cause of credentials fetch
-            // they may not already be in the checklist
-            if (ch->auth_user_request == NULL && ch->request)
-                ch->auth_user_request = ch->request->auth_user_request;
-
-            if (ch->auth_user_request != NULL)
-                str = ch->auth_user_request->username();
-            break;
-#endif
-#if USE_IDENT
-        case Format::LFT_USER_IDENT:
-            str = ch->rfc931;
-
-            if (!str || !*str) {
-                // if we fail to go async, we still return NULL and the caller
-                // will detect the failure in ACLExternal::match().
-                (void)ch->goAsync(IdentLookup::Instance());
-                return NULL;
-            }
-
-            break;
-#endif
-
-        case Format::LFT_CLIENT_IP_ADDRESS:
-            str = ch->src_addr.toStr(buf,sizeof(buf));
-            break;
+    // check for special case tokens in the format
+    for (Format::Token *t = acl_data->def->format.format; t ; t = t->next) {
 
-        case Format::LFT_CLIENT_PORT:
-            snprintf(buf, sizeof(buf), "%d", request->client_addr.port());
-            str = buf;
-            break;
-
-#if USE_SQUID_EUI
-        case Format::LFT_EXT_ACL_CLIENT_EUI48:
-            if (request->clientConnectionManager.valid() && request->clientConnectionManager->clientConnection != NULL &&
-                    request->clientConnectionManager->clientConnection->remoteEui48.encode(buf, sizeof(buf)))
-                str = buf;
-            break;
-
-        case Format::LFT_EXT_ACL_CLIENT_EUI64:
-            if (request->clientConnectionManager.valid() && request->clientConnectionManager->clientConnection != NULL &&
-                    request->clientConnectionManager->clientConnection->remoteEui64.encode(buf, sizeof(buf)))
-                str = buf;
-            break;
-#endif
-
-        case Format::LFT_LOCAL_LISTENING_IP:
-            str = request->my_addr.toStr(buf, sizeof(buf));
-            break;
-
-        case Format::LFT_LOCAL_LISTENING_PORT:
-            snprintf(buf, sizeof(buf), "%d", request->my_addr.port());
-            str = buf;
-            break;
-
-        case Format::LFT_CLIENT_REQ_URI:
-            snprintf(buf, sizeof(buf), SQUIDSBUFPH, SQUIDSBUFPRINT(request->effectiveRequestUri()));
-            str = buf;
-            break;
-
-        case Format::LFT_CLIENT_REQ_URLDOMAIN:
-            str = request->url.host();
-            break;
-
-        case Format::LFT_CLIENT_REQ_URLSCHEME:
-            str = request->url.getScheme().c_str();
-            break;
-
-        case Format::LFT_CLIENT_REQ_URLPORT:
-            snprintf(buf, sizeof(buf), "%u", request->url.port());
-            str = buf;
-            break;
-
-        case Format::LFT_CLIENT_REQ_URLPATH: {
-            SBuf tmp = request->url.path();
-            str = tmp.c_str();
+        if (t->type == Format::LFT_EXT_ACL_NAME) {
+            // setup for %ACL
+            safe_free(ch->al->lastAclName);
+            ch->al->lastAclName = xstrdup(acl_data->name);
         }
-        break;
-
-        case Format::LFT_CLIENT_REQ_METHOD: {
-            const SBuf &s = request->method.image();
-            sb.append(s.rawContent(), s.length());
-        }
-        str = sb.termedBuf();
-        break;
-
-        case Format::LFT_ADAPTED_REQUEST_HEADER:
-            if (format->header_id == Http::HdrType::BAD_HDR)
-                sb = request->header.getByName(format->header);
-            else
-                sb = request->header.getStrOrList(format->header_id);
-            str = sb.termedBuf();
-            break;
-
-        case Format::LFT_ADAPTED_REQUEST_HEADER_ELEM:
-            if (format->header_id == Http::HdrType::BAD_HDR)
-                sb = request->header.getByNameListMember(format->header, format->member, format->separator);
-            else
-                sb = request->header.getListMember(format->header_id, format->member, format->separator);
-            str = sb.termedBuf();
-            break;
-
-        case Format::LFT_REPLY_HEADER:
-            if (reply) {
-                if (format->header_id == Http::HdrType::BAD_HDR)
-                    sb = reply->header.getByName(format->header);
-                else
-                    sb = reply->header.getStrOrList(format->header_id);
-                str = sb.termedBuf();
-            }
-            break;
-
-        case Format::LFT_REPLY_HEADER_ELEM:
-            if (reply) {
-                if (format->header_id == Http::HdrType::BAD_HDR)
-                    sb = reply->header.getByNameListMember(format->header, format->member, format->separator);
-                else
-                    sb = reply->header.getListMember(format->header_id, format->member, format->separator);
-                str = sb.termedBuf();
-            }
-            break;
-
-#if USE_OPENSSL
-
-        case Format::LFT_EXT_ACL_USER_CERT_RAW:
-
-            if (ch->conn() != NULL && Comm::IsConnOpen(ch->conn()->clientConnection)) {
-                if (auto ssl = fd_table[ch->conn()->clientConnection->fd].ssl)
-                    str = sslGetUserCertificatePEM(ssl);
-            }
-
-            break;
-
-        case Format::LFT_EXT_ACL_USER_CERTCHAIN_RAW:
-
-            if (ch->conn() != NULL && Comm::IsConnOpen(ch->conn()->clientConnection)) {
-                if (auto ssl = fd_table[ch->conn()->clientConnection->fd].ssl)
-                    str = sslGetUserCertificateChainPEM(ssl);
-            }
-
-            break;
-
-        case Format::LFT_EXT_ACL_USER_CERT:
-
-            str = external_acl_ssl_get_user_attribute(*ch, format->header);
-            break;
-
-        case Format::LFT_EXT_ACL_USER_CA_CERT:
-
-            if (ch->conn() != NULL && Comm::IsConnOpen(ch->conn()->clientConnection)) {
-                if (auto ssl = fd_table[ch->conn()->clientConnection->fd].ssl)
-                    str = sslGetCAAttribute(ssl, format->header);
-            }
-
-            break;
 
-        case Format::LFT_SSL_CLIENT_SNI:
-            if (ch->conn() != NULL) {
-                if (Ssl::ServerBump * srvBump = ch->conn()->serverBump()) {
-                    if (!srvBump->clientSni.isEmpty())
-                        str = srvBump->clientSni.c_str();
-                }
-            }
-            break;
-
-        case Format::LFT_SSL_SERVER_CERT_SUBJECT:
-        case Format::LFT_SSL_SERVER_CERT_ISSUER: {
-            X509 *serverCert = NULL;
-            if (ch->serverCert.get())
-                serverCert = ch->serverCert.get();
-            else if (ch->conn() && ch->conn()->serverBump())
-                serverCert = ch->conn()->serverBump()->serverCert.get();
-
-            if (serverCert) {
-                if (format->type == Format::LFT_SSL_SERVER_CERT_SUBJECT)
-                    str = Ssl::GetX509UserAttribute(serverCert, "DN");
-                else
-                    str = Ssl::GetX509CAAttribute(serverCert, "DN");
-            }
-            break;
-        }
-
-#endif
-#if USE_AUTH
-        case Format::LFT_USER_EXTERNAL:
-            str = request->extacl_user.termedBuf();
-            break;
-#endif
-        case Format::LFT_USER_NAME:
-            /* find the first available name from various sources */
-#if USE_AUTH
-            // if this ACL line was the cause of credentials fetch
-            // they may not already be in the checklist
-            if (!ch->auth_user_request && ch->request)
-                ch->auth_user_request = ch->request->auth_user_request;
-
-            if (ch->auth_user_request != NULL)
-                str = ch->auth_user_request->username();
-
-            if ((!str || !*str) &&
-                    (request->extacl_user.size() > 0 && request->extacl_user[0] != '-'))
-                str = request->extacl_user.termedBuf();
-#endif
-#if USE_OPENSSL
-            if (!str || !*str)
-                str = external_acl_ssl_get_user_attribute(*ch, "CN");
-#endif
-#if USE_IDENT
-            if (!str || !*str)
-                str = ch->rfc931;
-#endif
-            break;
-        case Format::LFT_EXT_LOG:
-            str = request->extacl_log.termedBuf();
-            break;
-        case Format::LFT_TAG:
-            str = request->tag.termedBuf();
-            break;
-        case Format::LFT_EXT_ACL_NAME:
-            str = acl_data->name;
-            break;
-        case Format::LFT_EXT_ACL_DATA:
-            data_used = true;
-            for (arg = acl_data->arguments; arg; arg = arg->next) {
-                if (!first)
+        if (t->type == Format::LFT_EXT_ACL_DATA) {
+            // setup string for %DATA
+            SBuf sb;
+            for (auto arg = acl_data->arguments; arg; arg = arg->next) {
+                if (sb.length())
                     sb.append(" ", 1);
 
-                if (acl_data->def->quote == external_acl::QUOTE_METHOD_URL) {
+                if (acl_data->def->quote == Format::LOG_QUOTE_URL) {
                     const char *quoted = rfc1738_escape(arg->key);
                     sb.append(quoted, strlen(quoted));
                 } else {
@@ -1166,59 +739,26 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
                     sb.append(mb2.buf, mb2.size);
                     mb2.clean();
                 }
-
-                first = 0;
             }
-            break;
-        case Format::LFT_PERCENT:
-            str = "%";
-            break;
-
-        default:
-            // TODO: replace this function with Format::assemble()
-            // For now die on unsupported logformat codes.
-            fatalf("ERROR: unknown external_acl_type format %u", (uint8_t)format->type);
-            break;
-        }
 
-        if (str)
-            if (!*str)
-                str = NULL;
-
-        if (!str)
-            str = "-";
-
-        if (!first)
-            mb.append(" ", 1);
-
-        if (acl_data->def->quote == external_acl::QUOTE_METHOD_URL) {
-            const char *quoted = rfc1738_escape(str);
-            mb.append(quoted, strlen(quoted));
-        } else {
-            strwordquote(&mb, str);
+            ch->al->lastAclData = xstrdup(sb.c_str());
         }
 
-        sb.clean();
-
-        first = 0;
-    }
-
-    if (!data_used) {
-        for (arg = acl_data->arguments; arg; arg = arg->next) {
-            if (!first)
-                mb.append(" ", 1);
-
-            if (acl_data->def->quote == external_acl::QUOTE_METHOD_URL) {
-                const char *quoted = rfc1738_escape(arg->key);
-                mb.append(quoted, strlen(quoted));
-            } else {
-                strwordquote(&mb, arg->key);
+#if USE_IDENT
+        if (t->type == Format::LFT_USER_IDENT) {
+            if (!*ch->rfc931) {
+                // if we fail to go async, we still return NULL and the caller
+                // will detect the failure in ACLExternal::match().
+                (void)ch->goAsync(IdentLookup::Instance());
+                return NULL;
             }
-
-            first = 0;
         }
+#endif
     }
 
+    // assemble the full helper lookup string
+    acl_data->def->format.assemble(mb, ch->al, 0);
+
     return mb.buf;
 }
 
@@ -224,10 +224,12 @@ typedef enum {
     LFT_PERCENT,            /* special string cases for escaped chars */
 
     // TODO assign better bytecode names and Token strings for these
+#if USE_OPENSSL
     LFT_EXT_ACL_USER_CERT_RAW,
     LFT_EXT_ACL_USER_CERTCHAIN_RAW,
     LFT_EXT_ACL_USER_CERT,
     LFT_EXT_ACL_USER_CA_CERT,
+#endif
     LFT_EXT_ACL_CLIENT_EUI48,
     LFT_EXT_ACL_CLIENT_EUI64,
     LFT_EXT_ACL_NAME,
@@ -241,6 +243,7 @@ enum Quoting {
     LOG_QUOTE_QUOTES,
     LOG_QUOTE_MIMEBLOB,
     LOG_QUOTE_URL,
+    LOG_QUOTE_SHELL,
     LOG_QUOTE_RAW
 };
 
@@ -22,6 +22,7 @@
 #include "rfc1738.h"
 #include "SquidTime.h"
 #include "Store.h"
+#include "tools.h"
 #include "URL.h"
 #if USE_OPENSSL
 #include "ssl/ErrorDetail.h"
@@ -88,14 +89,15 @@ Format::Format::parse(const char *def)
 }
 
 void
-Format::Format::dump(StoreEntry * entry, const char *directiveName)
+Format::Format::dump(StoreEntry * entry, const char *directiveName, bool eol) const
 {
     debugs(46, 4, HERE);
 
     // loop rather than recursing to conserve stack space.
-    for (Format *fmt = this; fmt; fmt = fmt->next) {
+    for (const Format *fmt = this; fmt; fmt = fmt->next) {
         debugs(46, 3, HERE << "Dumping format definition for " << fmt->name);
-        storeAppendPrintf(entry, "%s %s ", directiveName, fmt->name);
+        if (directiveName)
+            storeAppendPrintf(entry, "%s %s ", directiveName, fmt->name);
 
         for (Token *t = fmt->format; t; t = t->next) {
             if (t->type == LFT_STRING)
@@ -225,6 +227,10 @@ Format::Format::dump(StoreEntry * entry, const char *directiveName)
                     entry->append("'", 1);
                     break;
 
+                case LOG_QUOTE_SHELL:
+                    entry->append("/", 1);
+                    break;
+
                 case LOG_QUOTE_NONE:
                     break;
                 }
@@ -251,7 +257,8 @@ Format::Format::dump(StoreEntry * entry, const char *directiveName)
             }
         }
 
-        entry->append("\n", 1);
+        if (eol)
+            entry->append("\n", 1);
     }
 
 }
@@ -379,8 +386,28 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
                     al->request->clientConnectionManager->clientConnection->remoteEui64.encode(tmp, 1024);
                 out = tmp;
             }
-#else
-            out = "-";
+#endif
+            break;
+
+        case LFT_EXT_ACL_CLIENT_EUI48:
+#if USE_SQUID_EUI
+            if (al->request && al->request->clientConnectionManager.valid() &&
+                    al->request->clientConnectionManager->clientConnection != NULL &&
+                    al->request->clientConnectionManager->clientConnection->remote.isIPv4()) {
+                al->request->clientConnectionManager->clientConnection->remoteEui48.encode(tmp, 1024);
+                out = tmp;
+            }
+#endif
+            break;
+
+        case LFT_EXT_ACL_CLIENT_EUI64:
+#if USE_SQUID_EUI
+            if (al->request && al->request->clientConnectionManager.valid() &&
+                    al->request->clientConnectionManager->clientConnection != NULL &&
+                    !al->request->clientConnectionManager->clientConnection->remote.isIPv4()) {
+                al->request->clientConnectionManager->clientConnection->remoteEui64.encode(tmp, 1024);
+                out = tmp;
+            }
 #endif
             break;
 
@@ -440,6 +467,9 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             if (al->cache.port != NULL) {
                 outint = al->cache.port->s.port();
                 doint = 1;
+            } else if (al->request) {
+                outint = al->request->my_addr.port();
+                doint = 1;
             }
             break;
 
@@ -846,7 +876,11 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             break;
 
         case LFT_USER_EXTERNAL:
-            out = strOrNull(al->cache.extuser);
+            if (al->request && al->request->extacl_user.size())
+                out = al->request->extacl_user.termedBuf();
+
+            if (!out)
+                out = strOrNull(al->cache.extuser);
             break;
 
         /* case LFT_USER_REALM: */
@@ -902,8 +936,7 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             } else
 #endif
                 if (al->request && al->request->errDetail != ERR_DETAIL_NONE) {
-                    if (al->request->errDetail > ERR_DETAIL_START  &&
-                            al->request->errDetail < ERR_DETAIL_MAX)
+                    if (al->request->errDetail > ERR_DETAIL_START && al->request->errDetail < ERR_DETAIL_MAX)
                         out = errorDetailName(al->request->errDetail);
                     else {
                         if (al->request->errDetail >= ERR_DETAIL_EXCEPTION_START)
@@ -1136,8 +1169,48 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             const Ssl::BumpMode mode = static_cast<Ssl::BumpMode>(al->ssl.bumpMode);
             // for Ssl::bumpEnd, Ssl::bumpMode() returns NULL and we log '-'
             out = Ssl::bumpMode(mode);
-            break;
         }
+            break;
+
+        case LFT_EXT_ACL_USER_CERT_RAW:
+            if (al->request) {
+                ConnStateData *conn = al->request->clientConnectionManager.get();
+                if (conn != NULL && Comm::IsConnOpen(conn->clientConnection)) {
+                    if (SSL *ssl = fd_table[conn->clientConnection->fd].ssl)
+                        out = sslGetUserCertificatePEM(ssl);
+                }
+            }
+            break;
+
+        case LFT_EXT_ACL_USER_CERTCHAIN_RAW:
+            if (al->request) {
+                ConnStateData *conn = al->request->clientConnectionManager.get();
+                if (conn != NULL && Comm::IsConnOpen(conn->clientConnection)) {
+                    if (SSL *ssl = fd_table[conn->clientConnection->fd].ssl)
+                        out = sslGetUserCertificatePEM(ssl);
+                }
+            }
+            break;
+
+        case LFT_EXT_ACL_USER_CERT:
+            if (al->request) {
+                ConnStateData *conn = al->request->clientConnectionManager.get();
+                if (conn != NULL && Comm::IsConnOpen(conn->clientConnection)) {
+                    if (SSL *ssl = fd_table[conn->clientConnection->fd].ssl)
+                        out = sslGetUserAttribute(ssl, format->data.header.header);
+                }
+            }
+            break;
+
+        case LFT_EXT_ACL_USER_CA_CERT:
+            if (al->request) {
+                ConnStateData *conn = al->request->clientConnectionManager.get();
+                if (conn != NULL && Comm::IsConnOpen(conn->clientConnection)) {
+                    if (SSL *ssl = fd_table[conn->clientConnection->fd].ssl)
+                       out = sslGetCAAttribute(ssl, format->data.header.header);
+                }
+            }
+            break;
 
         case LFT_SSL_USER_CERT_SUBJECT:
             if (X509 *cert = al->cache.sslClientCert.get()) {
@@ -1156,6 +1229,7 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
                 }
             }
             break;
+
         case LFT_SSL_CLIENT_SNI:
             if (al->request && al->request->clientConnectionManager.valid()) {
                 if (Ssl::ServerBump * srvBump = al->request->clientConnectionManager->serverBump()) {
@@ -1241,18 +1315,12 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
             out = "%";
             break;
 
-        // XXX: external_acl_type format tokens which are not output by logformat.
-        // They are listed here because the switch requires
-        // every ByteCode_t to be explicitly enumerated.
-        // But do not output due to lack of access to the values.
-        case LFT_EXT_ACL_USER_CERT_RAW:
-        case LFT_EXT_ACL_USER_CERTCHAIN_RAW:
-        case LFT_EXT_ACL_USER_CERT:
-        case LFT_EXT_ACL_USER_CA_CERT:
-        case LFT_EXT_ACL_CLIENT_EUI48:
-        case LFT_EXT_ACL_CLIENT_EUI64:
         case LFT_EXT_ACL_NAME:
+            out = al->lastAclName;
+            break;
+
         case LFT_EXT_ACL_DATA:
+            out = al->lastAclData;
             break;
         }
 
@@ -1308,6 +1376,15 @@ Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logS
                     newout = rfc1738_escape(out);
                     break;
 
+                case LOG_QUOTE_SHELL: {
+                    MemBuf mbq;
+                    mbq.init();
+                    strwordquote(&mbq, out);
+                    newout = mbq.content();
+                    mbq.stolen = 1;
+                    newfree = 1;
+                    } break;
+
                 case LOG_QUOTE_RAW:
                     break;
                 }
@@ -51,7 +51,7 @@ class Format
     void assemble(MemBuf &mb, const AccessLogEntryPointer &al, int logSequenceNumber) const;
 
     /// dump this whole list of formats into the provided StoreEntry
-    void dump(StoreEntry * entry, const char *directiveName);
+    void dump(StoreEntry * entry, const char *directiveName, bool eol = true) const;
 
     char *name;
     Token *format;
@@ -145,6 +145,32 @@ static TokenTableEntry TokenTableMisc[] = {
     TokenTableEntry("err_detail", LFT_SQUID_ERROR_DETAIL ),
     TokenTableEntry("note", LFT_NOTE ),
     TokenTableEntry("credentials", LFT_CREDENTIALS),
+    /*
+     * Legacy external_acl_type format tokens
+     */
+    TokenTableEntry("ACL", LFT_EXT_ACL_NAME),
+    TokenTableEntry("DATA", LFT_EXT_ACL_DATA),
+    TokenTableEntry("DST", LFT_CLIENT_REQ_URLDOMAIN),
+    TokenTableEntry("EXT_LOG", LFT_EXT_LOG),
+    TokenTableEntry("EXT_USER", LFT_USER_EXTERNAL),
+    TokenTableEntry("IDENT", LFT_USER_IDENT),
+    TokenTableEntry("LOGIN", LFT_USER_LOGIN),
+    TokenTableEntry("METHOD", LFT_CLIENT_REQ_METHOD),
+    TokenTableEntry("MYADDR", LFT_LOCAL_LISTENING_IP),
+    TokenTableEntry("MYPORT", LFT_LOCAL_LISTENING_PORT),
+    TokenTableEntry("PATH", LFT_CLIENT_REQ_URLPATH),
+    TokenTableEntry("PORT", LFT_CLIENT_REQ_URLPORT),
+    TokenTableEntry("PROTO", LFT_CLIENT_REQ_URLSCHEME),
+    TokenTableEntry("SRCEUI48", LFT_EXT_ACL_CLIENT_EUI48),
+    TokenTableEntry("SRCEUI64", LFT_EXT_ACL_CLIENT_EUI64),
+    TokenTableEntry("SRCPORT", LFT_CLIENT_PORT),
+    TokenTableEntry("SRC", LFT_CLIENT_IP_ADDRESS), // keep after longer SRC* tokens
+    TokenTableEntry("TAG", LFT_TAG),
+    TokenTableEntry("URI", LFT_CLIENT_REQ_URI),
+#if USE_OPENSSL
+    TokenTableEntry("USER_CERTCHAIN", LFT_EXT_ACL_USER_CERTCHAIN_RAW),
+    TokenTableEntry("USER_CERT", LFT_EXT_ACL_USER_CERT_RAW),
+#endif
     TokenTableEntry(NULL, LFT_NONE)        /* this must be last */
 };
 
@@ -203,7 +229,6 @@ void
 Format::Token::Init()
 {
     // TODO standard log tokens
-    // TODO external ACL fmt tokens
 
 #if USE_ADAPTATION
     TheConfig.registerTokens(String("adapt"),::Format::TokenTableAdapt);
@@ -336,6 +361,7 @@ Format::Token::parse(const char *def, Quoting *quoting)
             cur = endp;
         }
 
+        // when {arg} field is before the token (old logformat syntax)
         if (*cur == '{') {
             char *cp;
             ++cur;
@@ -396,6 +422,21 @@ Format::Token::parse(const char *def, Quoting *quoting)
             fatalf("Can't parse configuration token: '%s'\n", def);
         }
 
+        // when {arg} field is after the token (old external_acl_type token syntax)
+        // but accept only if there was none before the token
+        if (*cur == '{' && !data.string) {
+            char *cp;
+            ++cur;
+            l = strcspn(cur, "}");
+            cp = (char *)xmalloc(l + 1);
+            xstrncpy(cp, cur, l + 1);
+            data.string = cp;
+            cur += l;
+
+            if (*cur == '}')
+                ++cur;
+        }
+
         if (*cur == ' ') {
             space = true;
             ++cur;