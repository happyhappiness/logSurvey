@@ -66,6 +66,7 @@ stamp-h1
 tags
 test-suite/Makefile
 testHeaders
+testHeaders.c
 tmp
 tools/Makefile
 tools/cachemgr.cgi
@@ -6,31 +6,31 @@
  * Subject: Save 15% on your bandwidth...
  * Date:    12 Sep 1996 21:21:55 GMT
  * ===========================================================================
- * 
+ *
  * I have downloaded the multi-megabyte files from Netscape and Microsoft
  * that our users like to download from every mirror in the world,
  * defeating the usual caching.
- * 
+ *
  * I put these files in a separate directory and installed a basic
  * redirector for Squid that checks if the file (so hostname and pathname
  * are disregarded) is present in this directory.
- * 
+ *
  * After a few days of testing (the redirector looks very stable) it looks
  * like this is saving us approx. 15% on our cache flow. Also, our own WWW
  * server has become more popular than ever :)
- * 
+ *
  * I'm sure this code will be useful to others too, so I've attached it at
  * the end of this message. Improvements, extensions etc. are welcome.
- * 
+ *
  * I'm going on holidays now, so I won't be able to respond to e-mail
  * quickly.
- * 
+ *
  * Enjoy, Richard.
  */
 
 /*
  * rredir - redirect to local directory
- * 
+ *
  * version 0.1, 7 sep 1996
  * - initial version (Richard Huveneers <Richard.Huveneers@hekkihek.hacom.nl>)
  */
@@ -53,49 +53,49 @@ main()
 
     /* make standard output line buffered */
     if (setvbuf(stdout, NULL, _IOLBF, 0) != 0)
-	return 1;
+        return 1;
 
     /* speed up the access() calls below */
     if (chdir(ACCESS_LOCAL_DIR) == -1)
-	return 1;
+        return 1;
 
     /* scan standard input */
     while (fgets(buf, BUFFER_SIZE, stdin) != NULL) {
-	/* check for too long urls */
-	if (strchr(buf, '\n') == NULL) {
-	    tlu = 1;
-	    continue;
-	}
-	if (tlu)
-	    goto dont_redirect;
+        /* check for too long urls */
+        if (strchr(buf, '\n') == NULL) {
+            tlu = 1;
+            continue;
+        }
+        if (tlu)
+            goto dont_redirect;
 
-	/* determine end of url */
-	if ((s = strchr(buf, ' ')) == NULL)
-	    goto dont_redirect;
-	*s = '\0';
+        /* determine end of url */
+        if ((s = strchr(buf, ' ')) == NULL)
+            goto dont_redirect;
+        *s = '\0';
 
-	/* determine first character of filename */
-	if ((s = strrchr(buf, '/')) == NULL)
-	    goto dont_redirect;
-	s++;
+        /* determine first character of filename */
+        if ((s = strrchr(buf, '/')) == NULL)
+            goto dont_redirect;
+        s++;
 
-	/* security: do not redirect to hidden files, the current
-	 * directory or the parent directory */
-	if (*s == '.' || *s == '\0')
-	    goto dont_redirect;
+        /* security: do not redirect to hidden files, the current
+         * directory or the parent directory */
+        if (*s == '.' || *s == '\0')
+            goto dont_redirect;
 
-	/* map filename to lower case */
-	for (t = s; *t != '\0'; t++)
-	    *t = (char) tolower((int) *t);
+        /* map filename to lower case */
+        for (t = s; *t != '\0'; t++)
+            *t = (char) tolower((int) *t);
 
-	/* check for a local copy of this file */
-	if (access(s, R_OK) == 0) {
-	    (void) printf("%s/%s\n", REDIRECT_TO_URL, s);
-	    continue;
-	}
-      dont_redirect:
-	tlu = 0;
-	(void) printf("\n");
+        /* check for a local copy of this file */
+        if (access(s, R_OK) == 0) {
+            (void) printf("%s/%s\n", REDIRECT_TO_URL, s);
+            continue;
+        }
+dont_redirect:
+        tlu = 0;
+        (void) printf("\n");
     }
 
     return 0;
@@ -1,32 +1,32 @@
 /*
  * squid_ldap_auth: authentication via ldap for squid proxy server
- * 
+ *
  * Authors:
  * Henrik Nordstrom
  * hno@squid-cache.org
  *
- * Glen Newton 
+ * Glen Newton
  * glen.newton@nrc.ca
- * Advanced Services 
+ * Advanced Services
  * CISTI
  * National Research Council
  *
  * with contributions from others mentioned in the Changes section below
- * 
+ *
  * Usage: squid_ldap_auth -b basedn [-s searchscope]
  *                        [-f searchfilter] [-D binddn -w bindpasswd]
  *                        [-u attr] [-h host] [-p port] [-P] [-R] [ldap_server_name[:port]] ...
- * 
+ *
  * Dependencies: You need to get the OpenLDAP libraries
  * from http://www.openldap.org or another compatible LDAP C-API
  * implementation.
  *
  * If you want to make a TLS enabled connection you will also need the
  * OpenSSL libraries linked into openldap. See http://www.openssl.org/
- * 
- * License: squid_ldap_auth is free software; you can redistribute it 
- * and/or modify it under the terms of the GNU General Public License 
- * as published by the Free Software Foundation; either version 2, 
+ *
+ * License: squid_ldap_auth is free software; you can redistribute it
+ * and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
  * or (at your option) any later version.
  *
  * Changes:
@@ -56,7 +56,7 @@
  *             - Added support for ldap URI via the -H option
  *               (requires OpenLDAP)
  * 2001-12-12: Michael Cunningham <m.cunningham@xpedite.com>
- *             - Added TLS support and partial ldap version 3 support. 
+ *             - Added TLS support and partial ldap version 3 support.
  * 2001-10-04: Henrik Nordstrom <hno@squid-cache.org>
  *             - Be consistent with the other helpers in how
  *               spaces are managed. If there is space characters
@@ -176,7 +176,7 @@ squid_ldap_set_aliasderef(LDAP * ld, int deref)
 static void
 squid_ldap_set_referrals(LDAP * ld, int referrals)
 {
-    int *value = referrals ? LDAP_OPT_ON : LDAP_OPT_OFF;
+    int *value = referrals ? LDAP_OPT_ON :LDAP_OPT_OFF;
     ldap_set_option(ld, LDAP_OPT_REFERRALS, value);
 }
 static void
@@ -218,9 +218,9 @@ static void
 squid_ldap_set_referrals(LDAP * ld, int referrals)
 {
     if (referrals)
-	ld->ld_options |= ~LDAP_OPT_REFERRALS;
+        ld->ld_options |= ~LDAP_OPT_REFERRALS;
     else
-	ld->ld_options &= ~LDAP_OPT_REFERRALS;
+        ld->ld_options &= ~LDAP_OPT_REFERRALS;
 }
 static void
 squid_ldap_set_timelimit(LDAP * ld, int timelimit)
@@ -252,58 +252,58 @@ open_ldap_connection(const char *ldapServer, int port)
     LDAP *ld = NULL;
 #if HAS_URI_SUPPORT
     if (strstr(ldapServer, "://") != NULL) {
-	int rc = ldap_initialize(&ld, ldapServer);
-	if (rc != LDAP_SUCCESS) {
-	    fprintf(stderr, "\nUnable to connect to LDAPURI:%s\n", ldapServer);
-	    exit(1);
-	}
+        int rc = ldap_initialize(&ld, ldapServer);
+        if (rc != LDAP_SUCCESS) {
+            fprintf(stderr, "\nUnable to connect to LDAPURI:%s\n", ldapServer);
+            exit(1);
+        }
     } else
 #endif
 #if NETSCAPE_SSL
-    if (sslpath) {
-	if (!sslinit && (ldapssl_client_init(sslpath, NULL) != LDAP_SUCCESS)) {
-	    fprintf(stderr, "\nUnable to initialise SSL with cert path %s\n",
-		sslpath);
-	    exit(1);
-	} else {
-	    sslinit++;
-	}
-	if ((ld = ldapssl_init(ldapServer, port, 1)) == NULL) {
-	    fprintf(stderr, "\nUnable to connect to SSL LDAP server: %s port:%d\n",
-		ldapServer, port);
-	    exit(1);
-	}
-    } else
+        if (sslpath) {
+            if (!sslinit && (ldapssl_client_init(sslpath, NULL) != LDAP_SUCCESS)) {
+                fprintf(stderr, "\nUnable to initialise SSL with cert path %s\n",
+                        sslpath);
+                exit(1);
+            } else {
+                sslinit++;
+            }
+            if ((ld = ldapssl_init(ldapServer, port, 1)) == NULL) {
+                fprintf(stderr, "\nUnable to connect to SSL LDAP server: %s port:%d\n",
+                        ldapServer, port);
+                exit(1);
+            }
+        } else
 #endif
-    if ((ld = ldap_init(ldapServer, port)) == NULL) {
-	fprintf(stderr, "\nUnable to connect to LDAP server:%s port:%d\n",
-	    ldapServer, port);
-	exit(1);
-    }
+            if ((ld = ldap_init(ldapServer, port)) == NULL) {
+                fprintf(stderr, "\nUnable to connect to LDAP server:%s port:%d\n",
+                        ldapServer, port);
+                exit(1);
+            }
     if (connect_timeout)
-	squid_ldap_set_connect_timeout(ld, connect_timeout);
+        squid_ldap_set_connect_timeout(ld, connect_timeout);
 
 #ifdef LDAP_VERSION3
     if (version == -1) {
-	version = LDAP_VERSION2;
+        version = LDAP_VERSION2;
     }
     if (ldap_set_option(ld, LDAP_OPT_PROTOCOL_VERSION, &version) != LDAP_SUCCESS) {
-	fprintf(stderr, "Could not set LDAP_OPT_PROTOCOL_VERSION %d\n",
-	    version);
-	exit(1);
+        fprintf(stderr, "Could not set LDAP_OPT_PROTOCOL_VERSION %d\n",
+                version);
+        exit(1);
     }
     if (use_tls) {
 #ifdef LDAP_OPT_X_TLS
-	if (version != LDAP_VERSION3) {
-	    fprintf(stderr, "TLS requires LDAP version 3\n");
-	    exit(1);
-	} else if (ldap_start_tls_s(ld, NULL, NULL) != LDAP_SUCCESS) {
-	    fprintf(stderr, "Could not Activate TLS connection\n");
-	    exit(1);
-	}
+        if (version != LDAP_VERSION3) {
+            fprintf(stderr, "TLS requires LDAP version 3\n");
+            exit(1);
+        } else if (ldap_start_tls_s(ld, NULL, NULL) != LDAP_SUCCESS) {
+            fprintf(stderr, "Could not Activate TLS connection\n");
+            exit(1);
+        }
 #else
-	fprintf(stderr, "TLS not supported with your LDAP library\n");
-	exit(1);
+        fprintf(stderr, "TLS not supported with your LDAP library\n");
+        exit(1);
 #endif
     }
 #endif
@@ -321,21 +321,21 @@ validUsername(const char *user)
 
     /* Leading whitespace? */
     if (xisspace(p[0]))
-	return 0;
+        return 0;
     while (p[0] && p[1]) {
-	if (xisspace(p[0])) {
-	    /* More than one consequitive space? */
-	    if (xisspace(p[1]))
-		return 0;
-	    /* or odd space type character used? */
-	    if (p[0] != ' ')
-		return 0;
-	}
-	p++;
+        if (xisspace(p[0])) {
+            /* More than one consequitive space? */
+            if (xisspace(p[1]))
+                return 0;
+            /* or odd space type character used? */
+            if (p[0] != ' ')
+                return 0;
+        }
+        p++;
     }
     /* Trailing whitespace? */
     if (xisspace(p[0]))
-	return 0;
+        return 0;
     return 1;
 }
 
@@ -352,255 +352,255 @@ main(int argc, char **argv)
     setbuf(stdout, NULL);
 
     while (argc > 1 && argv[1][0] == '-') {
-	const char *value = "";
-	char option = argv[1][1];
-	switch (option) {
-	case 'P':
-	case 'R':
-	case 'z':
-	case 'Z':
-	case 'd':
-	case 'O':
-	    break;
-	default:
-	    if (strlen(argv[1]) > 2) {
-		value = argv[1] + 2;
-	    } else if (argc > 2) {
-		value = argv[2];
-		argv++;
-		argc--;
-	    } else
-		value = "";
-	    break;
-	}
-	argv++;
-	argc--;
-	switch (option) {
-	case 'H':
+        const char *value = "";
+        char option = argv[1][1];
+        switch (option) {
+        case 'P':
+        case 'R':
+        case 'z':
+        case 'Z':
+        case 'd':
+        case 'O':
+            break;
+        default:
+            if (strlen(argv[1]) > 2) {
+                value = argv[1] + 2;
+            } else if (argc > 2) {
+                value = argv[2];
+                argv++;
+                argc--;
+            } else
+                value = "";
+            break;
+        }
+        argv++;
+        argc--;
+        switch (option) {
+        case 'H':
 #if !HAS_URI_SUPPORT
-	    fprintf(stderr, "ERROR: Your LDAP library does not have URI support\n");
-	    exit(1);
+            fprintf(stderr, "ERROR: Your LDAP library does not have URI support\n");
+            exit(1);
 #endif
-	    /* Fall thru to -h */
-	case 'h':
-	    if (ldapServer) {
-		int len = strlen(ldapServer) + 1 + strlen(value) + 1;
-		char *newhost = malloc(len);
-		snprintf(newhost, len, "%s %s", ldapServer, value);
-		free(ldapServer);
-		ldapServer = newhost;
-	    } else {
-		ldapServer = strdup(value);
-	    }
-	    break;
-	case 'b':
-	    basedn = value;
-	    break;
-	case 'f':
-	    searchfilter = value;
-	    break;
-	case 'u':
-	    userattr = value;
-	    break;
-	case 'U':
-	    passwdattr = value;
-	    break;
-	case 's':
-	    if (strcmp(value, "base") == 0)
-		searchscope = LDAP_SCOPE_BASE;
-	    else if (strcmp(value, "one") == 0)
-		searchscope = LDAP_SCOPE_ONELEVEL;
-	    else if (strcmp(value, "sub") == 0)
-		searchscope = LDAP_SCOPE_SUBTREE;
-	    else {
-		fprintf(stderr, PROGRAM_NAME ": ERROR: Unknown search scope '%s'\n", value);
-		exit(1);
-	    }
-	    break;
-	case 'E':
+            /* Fall thru to -h */
+        case 'h':
+            if (ldapServer) {
+                int len = strlen(ldapServer) + 1 + strlen(value) + 1;
+                char *newhost = malloc(len);
+                snprintf(newhost, len, "%s %s", ldapServer, value);
+                free(ldapServer);
+                ldapServer = newhost;
+            } else {
+                ldapServer = strdup(value);
+            }
+            break;
+        case 'b':
+            basedn = value;
+            break;
+        case 'f':
+            searchfilter = value;
+            break;
+        case 'u':
+            userattr = value;
+            break;
+        case 'U':
+            passwdattr = value;
+            break;
+        case 's':
+            if (strcmp(value, "base") == 0)
+                searchscope = LDAP_SCOPE_BASE;
+            else if (strcmp(value, "one") == 0)
+                searchscope = LDAP_SCOPE_ONELEVEL;
+            else if (strcmp(value, "sub") == 0)
+                searchscope = LDAP_SCOPE_SUBTREE;
+            else {
+                fprintf(stderr, PROGRAM_NAME ": ERROR: Unknown search scope '%s'\n", value);
+                exit(1);
+            }
+            break;
+        case 'E':
 #if defined(NETSCAPE_SSL)
-	    sslpath = value;
-	    if (port == LDAP_PORT)
-		port = LDAPS_PORT;
+            sslpath = value;
+            if (port == LDAP_PORT)
+                port = LDAPS_PORT;
 #else
-	    fprintf(stderr, PROGRAM_NAME " ERROR: -E unsupported with this LDAP library\n");
-	    exit(1);
+            fprintf(stderr, PROGRAM_NAME " ERROR: -E unsupported with this LDAP library\n");
+            exit(1);
 #endif
-	    break;
-	case 'c':
-	    connect_timeout = atoi(value);
-	    break;
-	case 't':
-	    timelimit = atoi(value);
-	    break;
-	case 'a':
-	    if (strcmp(value, "never") == 0)
-		aliasderef = LDAP_DEREF_NEVER;
-	    else if (strcmp(value, "always") == 0)
-		aliasderef = LDAP_DEREF_ALWAYS;
-	    else if (strcmp(value, "search") == 0)
-		aliasderef = LDAP_DEREF_SEARCHING;
-	    else if (strcmp(value, "find") == 0)
-		aliasderef = LDAP_DEREF_FINDING;
-	    else {
-		fprintf(stderr, PROGRAM_NAME ": ERROR: Unknown alias dereference method '%s'\n", value);
-		exit(1);
-	    }
-	    break;
-	case 'D':
-	    binddn = value;
-	    break;
-	case 'w':
-	    bindpasswd = value;
-	    break;
-	case 'W':
-	    readSecret(value);
-	    break;
-	case 'P':
-	    persistent = !persistent;
-	    break;
-	case 'O':
-	    bind_once = !bind_once;
-	    break;
-	case 'p':
-	    port = atoi(value);
-	    break;
-	case 'R':
-	    noreferrals = !noreferrals;
-	    break;
+            break;
+        case 'c':
+            connect_timeout = atoi(value);
+            break;
+        case 't':
+            timelimit = atoi(value);
+            break;
+        case 'a':
+            if (strcmp(value, "never") == 0)
+                aliasderef = LDAP_DEREF_NEVER;
+            else if (strcmp(value, "always") == 0)
+                aliasderef = LDAP_DEREF_ALWAYS;
+            else if (strcmp(value, "search") == 0)
+                aliasderef = LDAP_DEREF_SEARCHING;
+            else if (strcmp(value, "find") == 0)
+                aliasderef = LDAP_DEREF_FINDING;
+            else {
+                fprintf(stderr, PROGRAM_NAME ": ERROR: Unknown alias dereference method '%s'\n", value);
+                exit(1);
+            }
+            break;
+        case 'D':
+            binddn = value;
+            break;
+        case 'w':
+            bindpasswd = value;
+            break;
+        case 'W':
+            readSecret(value);
+            break;
+        case 'P':
+            persistent = !persistent;
+            break;
+        case 'O':
+            bind_once = !bind_once;
+            break;
+        case 'p':
+            port = atoi(value);
+            break;
+        case 'R':
+            noreferrals = !noreferrals;
+            break;
 #ifdef LDAP_VERSION3
-	case 'v':
-	    switch (atoi(value)) {
-	    case 2:
-		version = LDAP_VERSION2;
-		break;
-	    case 3:
-		version = LDAP_VERSION3;
-		break;
-	    default:
-		fprintf(stderr, "Protocol version should be 2 or 3\n");
-		exit(1);
-	    }
-	    break;
-	case 'Z':
-	    if (version == LDAP_VERSION2) {
-		fprintf(stderr, "TLS (-Z) is incompatible with version %d\n",
-		    version);
-		exit(1);
-	    }
-	    version = LDAP_VERSION3;
-	    use_tls = 1;
-	    break;
+        case 'v':
+            switch (atoi(value)) {
+            case 2:
+                version = LDAP_VERSION2;
+                break;
+            case 3:
+                version = LDAP_VERSION3;
+                break;
+            default:
+                fprintf(stderr, "Protocol version should be 2 or 3\n");
+                exit(1);
+            }
+            break;
+        case 'Z':
+            if (version == LDAP_VERSION2) {
+                fprintf(stderr, "TLS (-Z) is incompatible with version %d\n",
+                        version);
+                exit(1);
+            }
+            version = LDAP_VERSION3;
+            use_tls = 1;
+            break;
 #endif
-	case 'd':
-	    debug++;
-	    break;
-	default:
-	    fprintf(stderr, PROGRAM_NAME ": ERROR: Unknown command line option '%c'\n", option);
-	    exit(1);
-	}
+        case 'd':
+            debug++;
+            break;
+        default:
+            fprintf(stderr, PROGRAM_NAME ": ERROR: Unknown command line option '%c'\n", option);
+            exit(1);
+        }
     }
 
     while (argc > 1) {
-	char *value = argv[1];
-	if (ldapServer) {
-	    int len = strlen(ldapServer) + 1 + strlen(value) + 1;
-	    char *newhost = malloc(len);
-	    snprintf(newhost, len, "%s %s", ldapServer, value);
-	    free(ldapServer);
-	    ldapServer = newhost;
-	} else {
-	    ldapServer = strdup(value);
-	}
-	argc--;
-	argv++;
+        char *value = argv[1];
+        if (ldapServer) {
+            int len = strlen(ldapServer) + 1 + strlen(value) + 1;
+            char *newhost = malloc(len);
+            snprintf(newhost, len, "%s %s", ldapServer, value);
+            free(ldapServer);
+            ldapServer = newhost;
+        } else {
+            ldapServer = strdup(value);
+        }
+        argc--;
+        argv++;
     }
     if (!ldapServer)
-	ldapServer = strdup("localhost");
+        ldapServer = strdup("localhost");
 
     if (!basedn) {
-	fprintf(stderr, "Usage: " PROGRAM_NAME " -b basedn [options] [ldap_server_name[:port]]...\n\n");
-	fprintf(stderr, "\t-b basedn (REQUIRED)\tbase dn under which to search\n");
-	fprintf(stderr, "\t-f filter\t\tsearch filter to locate user DN\n");
-	fprintf(stderr, "\t-u userattr\t\tusername DN attribute\n");
-	fprintf(stderr, "\t-s base|one|sub\t\tsearch scope\n");
-	fprintf(stderr, "\t-D binddn\t\tDN to bind as to perform searches\n");
-	fprintf(stderr, "\t-w bindpasswd\t\tpassword for binddn\n");
-	fprintf(stderr, "\t-W secretfile\t\tread password for binddn from file secretfile\n");
+        fprintf(stderr, "Usage: " PROGRAM_NAME " -b basedn [options] [ldap_server_name[:port]]...\n\n");
+        fprintf(stderr, "\t-b basedn (REQUIRED)\tbase dn under which to search\n");
+        fprintf(stderr, "\t-f filter\t\tsearch filter to locate user DN\n");
+        fprintf(stderr, "\t-u userattr\t\tusername DN attribute\n");
+        fprintf(stderr, "\t-s base|one|sub\t\tsearch scope\n");
+        fprintf(stderr, "\t-D binddn\t\tDN to bind as to perform searches\n");
+        fprintf(stderr, "\t-w bindpasswd\t\tpassword for binddn\n");
+        fprintf(stderr, "\t-W secretfile\t\tread password for binddn from file secretfile\n");
 #if HAS_URI_SUPPORT
-	fprintf(stderr, "\t-H URI\t\t\tLDAPURI (defaults to ldap://localhost)\n");
+        fprintf(stderr, "\t-H URI\t\t\tLDAPURI (defaults to ldap://localhost)\n");
 #endif
-	fprintf(stderr, "\t-h server\t\tLDAP server (defaults to localhost)\n");
-	fprintf(stderr, "\t-p port\t\t\tLDAP server port\n");
-	fprintf(stderr, "\t-P\t\t\tpersistent LDAP connection\n");
+        fprintf(stderr, "\t-h server\t\tLDAP server (defaults to localhost)\n");
+        fprintf(stderr, "\t-p port\t\t\tLDAP server port\n");
+        fprintf(stderr, "\t-P\t\t\tpersistent LDAP connection\n");
 #if defined(NETSCAPE_SSL)
-	fprintf(stderr, "\t-E sslcertpath\t\tenable LDAP over SSL\n");
+        fprintf(stderr, "\t-E sslcertpath\t\tenable LDAP over SSL\n");
 #endif
-	fprintf(stderr, "\t-c timeout\t\tconnect timeout\n");
-	fprintf(stderr, "\t-t timelimit\t\tsearch time limit\n");
-	fprintf(stderr, "\t-R\t\t\tdo not follow referrals\n");
-	fprintf(stderr, "\t-a never|always|search|find\n\t\t\t\twhen to dereference aliases\n");
+        fprintf(stderr, "\t-c timeout\t\tconnect timeout\n");
+        fprintf(stderr, "\t-t timelimit\t\tsearch time limit\n");
+        fprintf(stderr, "\t-R\t\t\tdo not follow referrals\n");
+        fprintf(stderr, "\t-a never|always|search|find\n\t\t\t\twhen to dereference aliases\n");
 #ifdef LDAP_VERSION3
-	fprintf(stderr, "\t-v 2|3\t\t\tLDAP version\n");
-	fprintf(stderr, "\t-Z\t\t\tTLS encrypt the LDAP connection, requires LDAP version 3\n");
+        fprintf(stderr, "\t-v 2|3\t\t\tLDAP version\n");
+        fprintf(stderr, "\t-Z\t\t\tTLS encrypt the LDAP connection, requires LDAP version 3\n");
 #endif
-	fprintf(stderr, "\n");
-	fprintf(stderr, "\tIf no search filter is specified, then the dn <userattr>=user,basedn\n\twill be used (same as specifying a search filter of '<userattr>=',\n\tbut quicker as as there is no need to search for the user DN)\n\n");
-	fprintf(stderr, "\tIf you need to bind as a user to perform searches then use the\n\t-D binddn -w bindpasswd or -D binddn -W secretfile options\n\n");
-	exit(1);
+        fprintf(stderr, "\n");
+        fprintf(stderr, "\tIf no search filter is specified, then the dn <userattr>=user,basedn\n\twill be used (same as specifying a search filter of '<userattr>=',\n\tbut quicker as as there is no need to search for the user DN)\n\n");
+        fprintf(stderr, "\tIf you need to bind as a user to perform searches then use the\n\t-D binddn -w bindpasswd or -D binddn -W secretfile options\n\n");
+        exit(1);
     }
-/* On Windows ldap_start_tls_s is available starting from Windows XP, 
- * so we need to bind at run-time with the function entry point
- */
+    /* On Windows ldap_start_tls_s is available starting from Windows XP,
+     * so we need to bind at run-time with the function entry point
+     */
 #ifdef _SQUID_MSWIN_
     if (use_tls) {
 
-	HMODULE WLDAP32Handle;
+        HMODULE WLDAP32Handle;
 
-	WLDAP32Handle = GetModuleHandle("wldap32");
-	if ((Win32_ldap_start_tls_s = (PFldap_start_tls_s) GetProcAddress(WLDAP32Handle, LDAP_START_TLS_S)) == NULL) {
-	    fprintf(stderr, PROGRAM_NAME ": ERROR: TLS (-Z) not supported on this platform.\n");
-	    exit(1);
-	}
+        WLDAP32Handle = GetModuleHandle("wldap32");
+        if ((Win32_ldap_start_tls_s = (PFldap_start_tls_s) GetProcAddress(WLDAP32Handle, LDAP_START_TLS_S)) == NULL) {
+            fprintf(stderr, PROGRAM_NAME ": ERROR: TLS (-Z) not supported on this platform.\n");
+            exit(1);
+        }
     }
 #endif
 
     while (fgets(buf, sizeof(buf), stdin) != NULL) {
-	user = strtok(buf, " \r\n");
-	passwd = strtok(NULL, "\r\n");
-
-	if (!user || !passwd || !passwd[0]) {
-	    printf("ERR\n");
-	    continue;
-	}
-	rfc1738_unescape(user);
-	rfc1738_unescape(passwd);
-	if (!validUsername(user)) {
-	    printf("ERR No such user\n");
-	    continue;
-	}
-	tryagain = (ld != NULL);
-      recover:
-	if (ld == NULL && persistent)
-	    ld = open_ldap_connection(ldapServer, port);
-	if (checkLDAP(ld, user, passwd, ldapServer, port) != 0) {
-	    if (tryagain && squid_ldap_errno(ld) != LDAP_INVALID_CREDENTIALS) {
-		tryagain = 0;
-		ldap_unbind(ld);
-		ld = NULL;
-		goto recover;
-	    }
-	    printf("ERR %s\n", ldap_err2string(squid_ldap_errno(ld)));
-	} else {
-	    printf("OK\n");
-	}
-	if (ld && (squid_ldap_errno(ld) != LDAP_SUCCESS && squid_ldap_errno(ld) != LDAP_INVALID_CREDENTIALS)) {
-	    ldap_unbind(ld);
-	    ld = NULL;
-	}
+        user = strtok(buf, " \r\n");
+        passwd = strtok(NULL, "\r\n");
+
+        if (!user || !passwd || !passwd[0]) {
+            printf("ERR\n");
+            continue;
+        }
+        rfc1738_unescape(user);
+        rfc1738_unescape(passwd);
+        if (!validUsername(user)) {
+            printf("ERR No such user\n");
+            continue;
+        }
+        tryagain = (ld != NULL);
+recover:
+        if (ld == NULL && persistent)
+            ld = open_ldap_connection(ldapServer, port);
+        if (checkLDAP(ld, user, passwd, ldapServer, port) != 0) {
+            if (tryagain && squid_ldap_errno(ld) != LDAP_INVALID_CREDENTIALS) {
+                tryagain = 0;
+                ldap_unbind(ld);
+                ld = NULL;
+                goto recover;
+            }
+            printf("ERR %s\n", ldap_err2string(squid_ldap_errno(ld)));
+        } else {
+            printf("OK\n");
+        }
+        if (ld && (squid_ldap_errno(ld) != LDAP_SUCCESS && squid_ldap_errno(ld) != LDAP_INVALID_CREDENTIALS)) {
+            ldap_unbind(ld);
+            ld = NULL;
+        }
     }
     if (ld)
-	ldap_unbind(ld);
+        ldap_unbind(ld);
     return 0;
 }
 
@@ -609,24 +609,24 @@ ldap_escape_value(char *escaped, int size, const char *src)
 {
     int n = 0;
     while (size > 4 && *src) {
-	switch (*src) {
-	case '*':
-	case '(':
-	case ')':
-	case '\\':
-	    n += 3;
-	    size -= 3;
-	    if (size > 0) {
-		*escaped++ = '\\';
-		snprintf(escaped, 3, "%02x", (unsigned char) *src++);
-		escaped += 2;
-	    }
-	    break;
-	default:
-	    *escaped++ = *src++;
-	    n++;
-	    size--;
-	}
+        switch (*src) {
+        case '*':
+        case '(':
+        case ')':
+        case '\\':
+            n += 3;
+            size -= 3;
+            if (size > 0) {
+                *escaped++ = '\\';
+                snprintf(escaped, 3, "%02x", (unsigned char) *src++);
+                escaped += 2;
+            }
+            break;
+        default:
+            *escaped++ = *src++;
+            n++;
+            size--;
+        }
     }
     *escaped = '\0';
     return n;
@@ -643,110 +643,109 @@ checkLDAP(LDAP * persistent_ld, const char *userid, const char *password, const
     LDAP *bind_ld = NULL;
 
     if (!*password) {
-	/* LDAP can't bind with a blank password. Seen as "anonymous"
-	 * and always granted access
-	 */
-	if (debug)
-	    fprintf(stderr, "Blank password given\n");
-	return 1;
+        /* LDAP can't bind with a blank password. Seen as "anonymous"
+         * and always granted access
+         */
+        if (debug)
+            fprintf(stderr, "Blank password given\n");
+        return 1;
     }
     if (searchfilter) {
-	char filter[16384];
-	char escaped_login[1024];
-	LDAPMessage *res = NULL;
-	LDAPMessage *entry;
-	char *searchattr[] =
-	{(char *)LDAP_NO_ATTRS, NULL};
-	char *userdn;
-	int rc;
-	LDAP *search_ld = persistent_ld;
-
-	if (!search_ld)
-	    search_ld = open_ldap_connection(ldapServer, port);
-
-	ldap_escape_value(escaped_login, sizeof(escaped_login), userid);
-	if (binddn) {
-	    rc = ldap_simple_bind_s(search_ld, binddn, bindpasswd);
-	    if (rc != LDAP_SUCCESS) {
-		fprintf(stderr, PROGRAM_NAME ": WARNING, could not bind to binddn '%s'\n", ldap_err2string(rc));
-		ret = 1;
-		goto search_done;
-	    }
-	}
-	snprintf(filter, sizeof(filter), searchfilter, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login);
-	if (debug)
-	    fprintf(stderr, "user filter '%s', searchbase '%s'\n", filter, basedn);
-	rc = ldap_search_s(search_ld, basedn, searchscope, filter, searchattr, 1, &res);
-	if (rc != LDAP_SUCCESS) {
-	    if (noreferrals && rc == LDAP_PARTIAL_RESULTS) {
-		/* Everything is fine. This is expected when referrals
-		 * are disabled.
-		 */
-		if (debug)
-		    fprintf(stderr, "noreferrals && rc == LDAP_PARTIAL_RESULTS\n");
-	    } else {
-		fprintf(stderr, PROGRAM_NAME ": WARNING, LDAP search error '%s'\n", ldap_err2string(rc));
+        char filter[16384];
+        char escaped_login[1024];
+        LDAPMessage *res = NULL;
+        LDAPMessage *entry;
+        char *searchattr[] = {(char *)LDAP_NO_ATTRS, NULL};
+        char *userdn;
+        int rc;
+        LDAP *search_ld = persistent_ld;
+
+        if (!search_ld)
+            search_ld = open_ldap_connection(ldapServer, port);
+
+        ldap_escape_value(escaped_login, sizeof(escaped_login), userid);
+        if (binddn) {
+            rc = ldap_simple_bind_s(search_ld, binddn, bindpasswd);
+            if (rc != LDAP_SUCCESS) {
+                fprintf(stderr, PROGRAM_NAME ": WARNING, could not bind to binddn '%s'\n", ldap_err2string(rc));
+                ret = 1;
+                goto search_done;
+            }
+        }
+        snprintf(filter, sizeof(filter), searchfilter, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login);
+        if (debug)
+            fprintf(stderr, "user filter '%s', searchbase '%s'\n", filter, basedn);
+        rc = ldap_search_s(search_ld, basedn, searchscope, filter, searchattr, 1, &res);
+        if (rc != LDAP_SUCCESS) {
+            if (noreferrals && rc == LDAP_PARTIAL_RESULTS) {
+                /* Everything is fine. This is expected when referrals
+                 * are disabled.
+                 */
+                if (debug)
+                    fprintf(stderr, "noreferrals && rc == LDAP_PARTIAL_RESULTS\n");
+            } else {
+                fprintf(stderr, PROGRAM_NAME ": WARNING, LDAP search error '%s'\n", ldap_err2string(rc));
 #if defined(NETSCAPE_SSL)
-		if (sslpath && ((rc == LDAP_SERVER_DOWN) || (rc == LDAP_CONNECT_ERROR))) {
-		    int sslerr = PORT_GetError();
-		    fprintf(stderr, PROGRAM_NAME ": WARNING, SSL error %d (%s)\n", sslerr, ldapssl_err2string(sslerr));
-		}
+                if (sslpath && ((rc == LDAP_SERVER_DOWN) || (rc == LDAP_CONNECT_ERROR))) {
+                    int sslerr = PORT_GetError();
+                    fprintf(stderr, PROGRAM_NAME ": WARNING, SSL error %d (%s)\n", sslerr, ldapssl_err2string(sslerr));
+                }
 #endif
-		ret = 1;
-		goto search_done;
-	    }
-	}
-	entry = ldap_first_entry(search_ld, res);
-	if (!entry) {
-	    if (debug)
-		fprintf(stderr, "Ldap search returned nothing\n");
-	    ret = 1;
-	    goto search_done;
-	}
-	userdn = ldap_get_dn(search_ld, entry);
-	if (!userdn) {
-	    fprintf(stderr, PROGRAM_NAME ": ERROR, could not get user DN for '%s'\n", userid);
-	    ret = 1;
-	    goto search_done;
-	}
-	snprintf(dn, sizeof(dn), "%s", userdn);
-	squid_ldap_memfree(userdn);
-
-	if (ret == 0 && (!binddn || !bind_once || passwdattr)) {
-	    /* Reuse the search connection for comparing the user password attribute */
-	    bind_ld = search_ld;
-	    search_ld = NULL;
-	}
-      search_done:
-	if (res) {
-	    ldap_msgfree(res);
-	    res = NULL;
-	}
-	if (search_ld && search_ld != persistent_ld) {
-	    ldap_unbind(search_ld);
-	    search_ld = NULL;
-	}
-	if (ret != 0)
-	    return ret;
+                ret = 1;
+                goto search_done;
+            }
+        }
+        entry = ldap_first_entry(search_ld, res);
+        if (!entry) {
+            if (debug)
+                fprintf(stderr, "Ldap search returned nothing\n");
+            ret = 1;
+            goto search_done;
+        }
+        userdn = ldap_get_dn(search_ld, entry);
+        if (!userdn) {
+            fprintf(stderr, PROGRAM_NAME ": ERROR, could not get user DN for '%s'\n", userid);
+            ret = 1;
+            goto search_done;
+        }
+        snprintf(dn, sizeof(dn), "%s", userdn);
+        squid_ldap_memfree(userdn);
+
+        if (ret == 0 && (!binddn || !bind_once || passwdattr)) {
+            /* Reuse the search connection for comparing the user password attribute */
+            bind_ld = search_ld;
+            search_ld = NULL;
+        }
+search_done:
+        if (res) {
+            ldap_msgfree(res);
+            res = NULL;
+        }
+        if (search_ld && search_ld != persistent_ld) {
+            ldap_unbind(search_ld);
+            search_ld = NULL;
+        }
+        if (ret != 0)
+            return ret;
     } else {
-	snprintf(dn, sizeof(dn), "%s=%s,%s", userattr, userid, basedn);
+        snprintf(dn, sizeof(dn), "%s=%s,%s", userattr, userid, basedn);
     }
 
     if (debug)
-	fprintf(stderr, "attempting to authenticate user '%s'\n", dn);
+        fprintf(stderr, "attempting to authenticate user '%s'\n", dn);
     if (!bind_ld && !bind_once)
-	bind_ld = persistent_ld;
+        bind_ld = persistent_ld;
     if (!bind_ld)
-	bind_ld = open_ldap_connection(ldapServer, port);
+        bind_ld = open_ldap_connection(ldapServer, port);
     if (passwdattr) {
-	if (ldap_compare_s(bind_ld, dn, passwdattr, password) != LDAP_COMPARE_TRUE) {
-	    ret = 1;
-	}
+        if (ldap_compare_s(bind_ld, dn, passwdattr, password) != LDAP_COMPARE_TRUE) {
+            ret = 1;
+        }
     } else if (ldap_simple_bind_s(bind_ld, dn, password) != LDAP_SUCCESS)
-	ret = 1;
+        ret = 1;
     if (bind_ld != persistent_ld) {
-	ldap_unbind(bind_ld);
-	bind_ld = NULL;
+        ldap_unbind(bind_ld);
+        bind_ld = NULL;
     }
     return ret;
 }
@@ -760,24 +759,24 @@ readSecret(const char *filename)
     char *passwd = NULL;
 
     if (!(f = fopen(filename, "r"))) {
-	fprintf(stderr, PROGRAM_NAME " ERROR: Can not read secret file %s\n", filename);
-	return 1;
+        fprintf(stderr, PROGRAM_NAME " ERROR: Can not read secret file %s\n", filename);
+        return 1;
     }
     if (!fgets(buf, sizeof(buf) - 1, f)) {
-	fprintf(stderr, PROGRAM_NAME " ERROR: Secret file %s is empty\n", filename);
-	fclose(f);
-	return 1;
+        fprintf(stderr, PROGRAM_NAME " ERROR: Secret file %s is empty\n", filename);
+        fclose(f);
+        return 1;
     }
     /* strip whitespaces on end */
     if ((e = strrchr(buf, '\n')))
-	*e = 0;
+        *e = 0;
     if ((e = strrchr(buf, '\r')))
-	*e = 0;
+        *e = 0;
 
     passwd = (char *) calloc(sizeof(char), strlen(buf) + 1);
     if (!passwd) {
-	fprintf(stderr, PROGRAM_NAME " ERROR: can not allocate memory\n");
-	exit(1);
+        fprintf(stderr, PROGRAM_NAME " ERROR: can not allocate memory\n");
+        exit(1);
     }
     strcpy(passwd, buf);
     bindpasswd = passwd;
@@ -3,7 +3,7 @@
  * allowusers.c
  * (C) 2000 Antonino Iannella, Stellar-X Pty Ltd
  * Released under GPL, see COPYING-2.0 for details.
- * 
+ *
  * These routines are to allow users attempting to use the proxy which
  * have been explicitly allowed by the system administrator.
  * The code originated from denyusers.c.
@@ -27,13 +27,13 @@ int
 Read_allowusers(void)
 {
     if (!init) {
-	memset(&AllowUsers, '\0', sizeof(AllowUsers));
-	init = 1;
+        memset(&AllowUsers, '\0', sizeof(AllowUsers));
+        init = 1;
     }
     if (*Allowuserpath)
-	return Read_usersfile(Allowuserpath, &AllowUsers);
+        return Read_usersfile(Allowuserpath, &AllowUsers);
     else
-	return 0;
+        return 0;
 }
 
 int
@@ -1,19 +1,19 @@
-/* 
+/*
  * Unix SMB/Netbios implementation.
  * Version 1.9.
  * SMB Byte handling
  * Copyright (C) Andrew Tridgell 1992-1995
- * 
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
@@ -23,13 +23,13 @@
 #define _BYTEORDER_H_
 
 /*
- * This file implements macros for machine independent short and 
+ * This file implements macros for machine independent short and
  * int manipulation
  */
 
 #undef CAREFUL_ALIGNMENT
 
-/* we know that the 386 can handle misalignment and has the "right" 
+/* we know that the 386 can handle misalignment and has the "right"
  * byteorder */
 #ifdef __i386__
 #define CAREFUL_ALIGNMENT 0
@@ -62,7 +62,7 @@ typedef unsigned int uint32;
  * alignment errors */
 /*
  * WARNING: This section is dependent on the length of int16 and int32
- * being correct 
+ * being correct
  */
 #define SVAL(buf,pos) (*(uint16 *)((char *)(buf) + (pos)))
 #define IVAL(buf,pos) (*(uint32 *)((char *)(buf) + (pos)))
@@ -3,10 +3,10 @@
  * confload.c
  * (C) 2000 Antonino Iannella, Stellar-X Pty Ltd
  * Released under GPL, see COPYING-2.0 for details.
- * 
+ *
  * These routines load the msntauth configuration file.
  * It stores the servers to query, sets the denied and
- * allowed user files, and provides the 
+ * allowed user files, and provides the
  * authenticating function.
  */
 
@@ -73,17 +73,17 @@ OpenConfigFile(void)
 
     /* Open file */
     if ((ConfigFile = fopen(CONFIGFILE, "r")) == NULL) {
-	syslog(LOG_ERR, "OpenConfigFile: Failed to open %s.", CONFIGFILE);
-	syslog(LOG_ERR, "%s", strerror(errno));
-	return 1;
+        syslog(LOG_ERR, "OpenConfigFile: Failed to open %s.", CONFIGFILE);
+        syslog(LOG_ERR, "%s", strerror(errno));
+        return 1;
     }
     /* Read in, one line at a time */
     while (!feof(ConfigFile)) {
-	Confbuf[0] = '\0';
-	if (NULL == fgets(Confbuf, 2048, ConfigFile))
-	    break;
-	Confbuf[2048] = '\0';
-	ProcessLine(Confbuf);
+        Confbuf[0] = '\0';
+        if (NULL == fgets(Confbuf, 2048, ConfigFile))
+            break;
+        Confbuf[2048] = '\0';
+        ProcessLine(Confbuf);
     }
 
     /*
@@ -92,8 +92,8 @@ OpenConfigFile(void)
      * not set in the confugration file.
      */
     if (Serversqueried == 0) {
-	syslog(LOG_ERR, "OpenConfigFile: No servers set in %s. At least one is needed.", CONFIGFILE);
-	return 1;
+        syslog(LOG_ERR, "OpenConfigFile: No servers set in %s. At least one is needed.", CONFIGFILE);
+        return 1;
     }
     fclose(ConfigFile);
     return 0;
@@ -111,59 +111,59 @@ ProcessLine(char *Linebuf)
 
     /* Ignore empty lines */
     if (strlen(Linebuf) == 0)
-	return;
+        return;
 
     /* Break up on whitespaces */
     if ((Directive = strtok(Linebuf, " \t\n")) == NULL)
-	return;
+        return;
 
     /* Check for a comment line. If found, stop . */
     if (Directive[0] == '#')
-	return;
+        return;
 
     /* Check for server line. Check for 3 parameters. */
     if (strcasecmp(Directive, "server") == 0) {
-	Param1 = strtok(NULL, " \t\n");
-	if (NULL == Param1) {
-	    syslog(LOG_ERR, "ProcessLine: 'server' missing PDC parameter.");
-	    return;
-	}
-	Param2 = strtok(NULL, " \t\n");
-	if (NULL == Param2) {
-	    syslog(LOG_ERR, "ProcessLine: 'server' missing BDC parameter.");
-	    return;
-	}
-	Param3 = strtok(NULL, " \t\n");
-	if (NULL == Param3) {
-	    syslog(LOG_ERR, "ProcessLine: 'server' missing domain parameter.");
-	    return;
-	}
-	AddServer(Param1, Param2, Param3);
-	return;
+        Param1 = strtok(NULL, " \t\n");
+        if (NULL == Param1) {
+            syslog(LOG_ERR, "ProcessLine: 'server' missing PDC parameter.");
+            return;
+        }
+        Param2 = strtok(NULL, " \t\n");
+        if (NULL == Param2) {
+            syslog(LOG_ERR, "ProcessLine: 'server' missing BDC parameter.");
+            return;
+        }
+        Param3 = strtok(NULL, " \t\n");
+        if (NULL == Param3) {
+            syslog(LOG_ERR, "ProcessLine: 'server' missing domain parameter.");
+            return;
+        }
+        AddServer(Param1, Param2, Param3);
+        return;
     }
     /* Check for denyusers line */
     if (strcasecmp(Directive, "denyusers") == 0) {
-	Param1 = strtok(NULL, " \t\n");
-
-	if (NULL == Param1) {
-	    syslog(LOG_ERR, "ProcessLine: A 'denyusers' line needs a filename parameter.");
-	    return;
-	}
-	memset(Denyuserpath, '\0', MAXPATHLEN);
-	strncpy(Denyuserpath, Param1, MAXPATHLEN - 1);
-	return;
+        Param1 = strtok(NULL, " \t\n");
+
+        if (NULL == Param1) {
+            syslog(LOG_ERR, "ProcessLine: A 'denyusers' line needs a filename parameter.");
+            return;
+        }
+        memset(Denyuserpath, '\0', MAXPATHLEN);
+        strncpy(Denyuserpath, Param1, MAXPATHLEN - 1);
+        return;
     }
     /* Check for allowusers line */
     if (strcasecmp(Directive, "allowusers") == 0) {
-	Param1 = strtok(NULL, " \t\n");
-
-	if (NULL == Param1) {
-	    syslog(LOG_ERR, "ProcessLine: An 'allowusers' line needs a filename parameter.");
-	    return;
-	}
-	memset(Allowuserpath, '\0', MAXPATHLEN);
-	strncpy(Allowuserpath, Param1, MAXPATHLEN - 1);
-	return;
+        Param1 = strtok(NULL, " \t\n");
+
+        if (NULL == Param1) {
+            syslog(LOG_ERR, "ProcessLine: An 'allowusers' line needs a filename parameter.");
+            return;
+        }
+        memset(Allowuserpath, '\0', MAXPATHLEN);
+        strncpy(Allowuserpath, Param1, MAXPATHLEN - 1);
+        return;
     }
     /* Reports error for unknown line */
     syslog(LOG_ERR, "ProcessLine: Ignoring '%s' line.", Directive);
@@ -180,19 +180,19 @@ void
 AddServer(char *ParamPDC, char *ParamBDC, char *ParamDomain)
 {
     if (Serversqueried == MAXSERVERS) {
-	syslog(LOG_ERR, "AddServer: Ignoring '%s' server line; "
-	    "too many servers.", ParamPDC);
-	return;
+        syslog(LOG_ERR, "AddServer: Ignoring '%s' server line; "
+               "too many servers.", ParamPDC);
+        return;
     }
     if (gethostbyname(ParamPDC) == NULL) {
-	syslog(LOG_ERR, "AddServer: Ignoring host '%s'. "
-	    "Cannot resolve its address.", ParamPDC);
-	return;
+        syslog(LOG_ERR, "AddServer: Ignoring host '%s'. "
+               "Cannot resolve its address.", ParamPDC);
+        return;
     }
     if (gethostbyname(ParamBDC) == NULL) {
-	syslog(LOG_USER | LOG_ERR, "AddServer: Ignoring host '%s'. "
-	    "Cannot resolve its address.", ParamBDC);
-	return;
+        syslog(LOG_USER | LOG_ERR, "AddServer: Ignoring host '%s'. "
+               "Cannot resolve its address.", ParamBDC);
+        return;
     }
     /* NOTE: ServerArray is zeroed in OpenConfigFile() */
     assert(Serversqueried < MAXSERVERS);
@@ -213,8 +213,8 @@ QueryServers(char *username, char *password)
 {
     int i;
     for (i = 0; i < Serversqueried; i++) {
-	if (0 == QueryServerForUser(i, username, password))
-	    return 0;
+        if (0 == QueryServerForUser(i, username, password))
+            return 0;
     }
     return 1;
 }
@@ -236,30 +236,30 @@ QueryServerForUser(int x, char *username, char *password)
     int result = 1;
 
     result = Valid_User(username, password, ServerArray[x].pdc,
-	ServerArray[x].bdc, ServerArray[x].domain);
+                        ServerArray[x].bdc, ServerArray[x].domain);
 
     switch (result) {		/* Write any helpful syslog messages */
     case 0:
-	break;
+        break;
     case 1:
-	syslog(LOG_AUTHPRIV | LOG_INFO, "Server error when checking %s.",
-	    username);
-	break;
+        syslog(LOG_AUTHPRIV | LOG_INFO, "Server error when checking %s.",
+               username);
+        break;
     case 2:
-	syslog(LOG_AUTHPRIV | LOG_INFO, "Protocol error when checking %s.",
-	    username);
-	break;
+        syslog(LOG_AUTHPRIV | LOG_INFO, "Protocol error when checking %s.",
+               username);
+        break;
     case 3:
-	syslog(LOG_AUTHPRIV | LOG_INFO, "Authentication failed for %s.",
-	    username);
-	break;
+        syslog(LOG_AUTHPRIV | LOG_INFO, "Authentication failed for %s.",
+               username);
+        break;
     }
 
     return result;
 }
 
 /* Valid_User return codes -
- * 
+ *
  * 0 - User authenticated successfully.
  * 1 - Server error.
  * 2 - Protocol error.
@@ -3,7 +3,7 @@
  * denyusers.c
  * (C) 2000 Antonino Iannella, Stellar-X Pty Ltd
  * Released under GPL, see COPYING-2.0 for details.
- * 
+ *
  * These routines are to block users attempting to use the proxy which
  * have been explicitly denied by the system administrator.
  * Routines at the bottom also use the allowed user functions.
@@ -28,13 +28,13 @@ int
 Read_denyusers(void)
 {
     if (!init) {
-	memset(&DenyUsers, '\0', sizeof(DenyUsers));
-	init = 1;
+        memset(&DenyUsers, '\0', sizeof(DenyUsers));
+        init = 1;
     }
     if (*Denyuserpath)
-	return Read_usersfile(Denyuserpath, &DenyUsers);
+        return Read_usersfile(Denyuserpath, &DenyUsers);
     else
-	return 0;
+        return 0;
 }
 
 static void
@@ -54,11 +54,11 @@ Check_ifuserdenied(char *ConnectingUser)
 {
     /* If user string is empty, deny */
     if (ConnectingUser[0] == '\0')
-	return 1;
+        return 1;
 
     /* If denied user list is empty, allow */
     if (DenyUsers.Inuse == 0)
-	return 0;
+        return 0;
 
     return Check_userlist(&DenyUsers, ConnectingUser);
 }
@@ -73,10 +73,10 @@ int
 Check_user(char *ConnectingUser)
 {
     if (Check_ifuserdenied(ConnectingUser) == 1)
-	return 1;
+        return 1;
 
     if (Check_ifuserallowed(ConnectingUser) == 0)
-	return 1;
+        return 1;
 
     return 0;
 }
@@ -110,9 +110,9 @@ Checktimer()
 
     /* If timeout has expired, check the denied user file, else return */
     if (difftime(Currenttime, Lasttime) < 60)
-	return;
+        return;
     else {
-	Check_forchange(-1);
-	Lasttime = Currenttime;
+        Check_forchange(-1);
+        Lasttime = Currenttime;
     }
 }
@@ -1,19 +1,19 @@
-/* 
+/*
  * Unix SMB/Netbios implementation.
  * Version 1.9.
  * a implementation of MD4 designed for use in the SMB authentication protocol
  * Copyright (C) Andrew Tridgell 1997
- * 
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
@@ -22,8 +22,8 @@
 #include <string.h>
 #include "md4.h"
 
-/* NOTE: This code makes no attempt to be fast! 
- * 
+/* NOTE: This code makes no attempt to be fast!
+ *
  * It assumes that a int is at least 32 bits long
  */
 
@@ -69,7 +69,7 @@ mdfour64(uint32 * M)
     uint32 X[16];
 
     for (j = 0; j < 16; j++)
-	X[j] = M[j];
+        X[j] = M[j];
 
     AA = A;
     BB = B;
@@ -138,7 +138,7 @@ mdfour64(uint32 * M)
     D &= 0xFFFFFFFF;
 
     for (j = 0; j < 16; j++)
-	X[j] = 0;
+        X[j] = 0;
 }
 
 static void
@@ -147,8 +147,8 @@ copy64(uint32 * M, unsigned char *in)
     int i;
 
     for (i = 0; i < 16; i++)
-	M[i] = (in[i * 4 + 3] << 24) | (in[i * 4 + 2] << 16) |
-	    (in[i * 4 + 1] << 8) | (in[i * 4 + 0] << 0);
+        M[i] = (in[i * 4 + 3] << 24) | (in[i * 4 + 2] << 16) |
+               (in[i * 4 + 1] << 8) | (in[i * 4 + 0] << 0);
 }
 
 static void
@@ -175,31 +175,31 @@ mdfour(unsigned char *out, unsigned char *in, int n)
     D = 0x10325476;
 
     while (n > 64) {
-	copy64(M, in);
-	mdfour64(M);
-	in += 64;
-	n -= 64;
+        copy64(M, in);
+        mdfour64(M);
+        in += 64;
+        n -= 64;
     }
 
     for (i = 0; i < 128; i++)
-	buf[i] = 0;
+        buf[i] = 0;
     memcpy(buf, in, n);
     buf[n] = 0x80;
 
     if (n <= 55) {
-	copy4(buf + 56, b);
-	copy64(M, buf);
-	mdfour64(M);
+        copy4(buf + 56, b);
+        copy64(M, buf);
+        mdfour64(M);
     } else {
-	copy4(buf + 120, b);
-	copy64(M, buf);
-	mdfour64(M);
-	copy64(M, buf + 64);
-	mdfour64(M);
+        copy4(buf + 120, b);
+        copy64(M, buf);
+        mdfour64(M);
+        copy64(M, buf + 64);
+        mdfour64(M);
     }
 
     for (i = 0; i < 128; i++)
-	buf[i] = 0;
+        buf[i] = 0;
     copy64(M, buf);
 
     copy4(out, A);
@@ -3,29 +3,29 @@
  * MSNT - Microsoft Windows NT domain squid authenticator module
  * Version 2.0 by Stellar-X Pty Ltd, Antonino Iannella
  * Sun Sep  2 14:39:53 CST 2001
- * 
+ *
  * Modified to act as a Squid authenticator module.
  * Removed all Pike stuff.
  * Returns OK for a successful authentication, or ERR upon error.
- * 
+ *
  * Uses code from -
  * Andrew Tridgell 1997
  * Richard Sharpe 1996
  * Bill Welliver 1999
  * Duane Wessels 2000 (wessels@squid-cache.org)
- * 
+ *
  * Released under GNU Public License
- * 
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
@@ -62,7 +62,7 @@ main(int argc, char **argv)
 
     /* Read configuration file. Abort wildly if error. */
     if (OpenConfigFile() == 1)
-	return 1;
+        return 1;
 
     /*
      * Read denied and allowed user files.
@@ -71,11 +71,11 @@ main(int argc, char **argv)
      * The msntauth process should then be killed.
      */
     if ((Read_denyusers() == 1) || (Read_allowusers() == 1)) {
-	while (1) {
-	    memset(wstr, '\0', sizeof(wstr));
-	    fgets(wstr, 255, stdin);
-	    puts("ERR");
-	}
+        while (1) {
+            memset(wstr, '\0', sizeof(wstr));
+            fgets(wstr, 255, stdin);
+            puts("ERR");
+        }
     }
     /*
      * Make Check_forchange() the handle for HUP signals.
@@ -86,57 +86,57 @@ main(int argc, char **argv)
     signal(SIGHUP, Check_forchange);
 
     while (1) {
-	int n;
-	/* Read whole line from standard input. Terminate on break. */
-	memset(wstr, '\0', sizeof(wstr));
-	if (fgets(wstr, 255, stdin) == NULL)
-	    break;
-	/* ignore this line if we didn't get the end-of-line marker */
-	if (NULL == strchr(wstr, '\n')) {
-	    err = 1;
-	    continue;
-	}
-	if (err) {
-	    syslog(LOG_WARNING, "oversized message");
-	    goto error;
-	}
+        int n;
+        /* Read whole line from standard input. Terminate on break. */
+        memset(wstr, '\0', sizeof(wstr));
+        if (fgets(wstr, 255, stdin) == NULL)
+            break;
+        /* ignore this line if we didn't get the end-of-line marker */
+        if (NULL == strchr(wstr, '\n')) {
+            err = 1;
+            continue;
+        }
+        if (err) {
+            syslog(LOG_WARNING, "oversized message");
+            goto error;
+        }
 
-	/*
-	 * extract username and password.
-	 * XXX is sscanf() safe?
-	 */
-	username[0] = '\0';
-	password[0] = '\0';
-	n = sscanf(wstr, "%s %[^\n]", username, password);
-	if (2 != n) {
-	    puts("ERR");
-	    continue;
-	}
-	/* Check for invalid or blank entries */
-	if ((username[0] == '\0') || (password[0] == '\0')) {
-	    puts("ERR");
-	    continue;
-	}
-	Checktimer();		/* Check if the user lists have changed */
+        /*
+         * extract username and password.
+         * XXX is sscanf() safe?
+         */
+        username[0] = '\0';
+        password[0] = '\0';
+        n = sscanf(wstr, "%s %[^\n]", username, password);
+        if (2 != n) {
+            puts("ERR");
+            continue;
+        }
+        /* Check for invalid or blank entries */
+        if ((username[0] == '\0') || (password[0] == '\0')) {
+            puts("ERR");
+            continue;
+        }
+        Checktimer();		/* Check if the user lists have changed */
 
-	rfc1738_unescape(username);
-	rfc1738_unescape(password);
+        rfc1738_unescape(username);
+        rfc1738_unescape(password);
 
-	/*
-	 * Check if user is explicitly denied or allowed.
-	 * If user passes both checks, they can be authenticated.
-	 */
-	if (Check_user(username) == 1) {
-	    syslog(LOG_INFO, "'%s' denied", username);
-	    puts("ERR");
-	} else if (QueryServers(username, password) == 0)
-	    puts("OK");
-	else {
-	    syslog(LOG_INFO, "'%s' login failed", username);
+        /*
+         * Check if user is explicitly denied or allowed.
+         * If user passes both checks, they can be authenticated.
+         */
+        if (Check_user(username) == 1) {
+            syslog(LOG_INFO, "'%s' denied", username);
+            puts("ERR");
+        } else if (QueryServers(username, password) == 0)
+            puts("OK");
+        else {
+            syslog(LOG_INFO, "'%s' login failed", username);
 error:
-	    puts("ERR");
-	}
-	err = 0;
+            puts("ERR");
+        }
+        err = 0;
     }
 
     return 0;
@@ -1,23 +1,23 @@
 /* UNIX RFCNB (RFC1001/RFC1002) NetBIOS implementation
- * 
+ *
  * Version 1.0
  * RFCNB Common Structures etc Defines
- * 
+ *
  * Copyright (C) Richard Sharpe 1996
- * 
+ *
  */
 
 /*
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
@@ -1,23 +1,23 @@
 /* UNIX RFCNB (RFC1001/RFC1002) NetBIOS implementation
- * 
+ *
  * Version 1.0
  * RFCNB Error Response Defines
- * 
+ *
  * Copyright (C) Richard Sharpe 1996
- * 
+ *
  */
 
 /*
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
@@ -1,23 +1,23 @@
 /* UNIX RFCNB (RFC1001/RFC1002) NEtBIOS implementation
- * 
+ *
  * Version 1.0
  * RFCNB IO Routines ...
- * 
+ *
  * Copyright (C) Richard Sharpe 1996
- * 
+ *
  */
 
 /*
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
@@ -56,7 +56,7 @@ RFCNB_Set_Timeout(int seconds)
     int x;
     RFCNB_Timeout = seconds;
     if (RFCNB_Timeout <= 0)
-	return 0;
+        return 0;
 #ifdef SA_RESTART
     sa.sa_handler = rfcnb_alarm;
     sa.sa_flags = 0;
@@ -67,8 +67,8 @@ RFCNB_Set_Timeout(int seconds)
     signal(SIGALRM, rfcnb_alarm);
 #endif
     if (x < 0) {
-	syslog(LOG_ERR, "%s:%d: signal/sigaction: %s", __FILE__, __LINE__, strerror(errno));
-	return -1;
+        syslog(LOG_ERR, "%s:%d: signal/sigaction: %s", __FILE__, __LINE__, strerror(errno));
+        return -1;
     }
     return 0;
 }
@@ -98,22 +98,22 @@ RFCNB_Discard_Rest(struct RFCNB_Con *con, int len)
 
     while (rest > 0) {
 
-	this_read = (rest > sizeof(temp) ? sizeof(temp) : rest);
+        this_read = (rest > sizeof(temp) ? sizeof(temp) : rest);
 
-	bytes_read = read(con->fd, temp, this_read);
+        bytes_read = read(con->fd, temp, this_read);
 
-	if (bytes_read <= 0) {	/* Error so return */
+        if (bytes_read <= 0) {	/* Error so return */
 
-	    if (bytes_read < 0)
-		RFCNB_errno = RFCNBE_BadRead;
-	    else
-		RFCNB_errno = RFCNBE_ConGone;
+            if (bytes_read < 0)
+                RFCNB_errno = RFCNBE_BadRead;
+            else
+                RFCNB_errno = RFCNBE_ConGone;
 
-	    RFCNB_saved_errno = errno;
-	    return (RFCNBE_Bad);
+            RFCNB_saved_errno = errno;
+            return (RFCNBE_Bad);
 
-	}
-	rest = rest - bytes_read;
+        }
+        rest = rest - bytes_read;
 
     }
 
@@ -123,11 +123,11 @@ RFCNB_Discard_Rest(struct RFCNB_Con *con, int len)
 
 
 /* Send an RFCNB packet to the connection.
- * 
- * We just send each of the blocks linked together ... 
- * 
- * If we can, try to send it as one iovec ... 
- * 
+ *
+ * We just send each of the blocks linked together ...
+ *
+ * If we can, try to send it as one iovec ...
+ *
  */
 
 int
@@ -147,23 +147,23 @@ RFCNB_Put_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len)
 
     while ((pkt_ptr != NULL) & (i < 10)) {	/* Watch that magic number! */
 
-	this_len = pkt_ptr->len;
-	this_data = pkt_ptr->data;
-	if ((tot_sent + this_len) > len)
-	    this_len = len - tot_sent;	/* Adjust so we don't send too much */
+        this_len = pkt_ptr->len;
+        this_data = pkt_ptr->data;
+        if ((tot_sent + this_len) > len)
+            this_len = len - tot_sent;	/* Adjust so we don't send too much */
 
-	/* Now plug into the iovec ... */
+        /* Now plug into the iovec ... */
 
-	io_list[i].iov_len = this_len;
-	io_list[i].iov_base = this_data;
-	i++;
+        io_list[i].iov_len = this_len;
+        io_list[i].iov_base = this_data;
+        i++;
 
-	tot_sent += this_len;
+        tot_sent += this_len;
 
-	if (tot_sent == len)
-	    break;		/* Let's not send too much */
+        if (tot_sent == len)
+            break;		/* Let's not send too much */
 
-	pkt_ptr = pkt_ptr->next;
+        pkt_ptr = pkt_ptr->next;
 
     }
 
@@ -174,29 +174,29 @@ RFCNB_Put_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len)
     /* Set up an alarm if timeouts are set ... */
 
     if (RFCNB_Timeout > 0)
-	alarm(RFCNB_Timeout);
+        alarm(RFCNB_Timeout);
 
     if ((len_sent = writev(con->fd, io_list, i)) < 0) {		/* An error */
 
-	con->rfc_errno = errno;
-	if (errno == EINTR)	/* We were interrupted ... */
-	    RFCNB_errno = RFCNBE_Timeout;
-	else
-	    RFCNB_errno = RFCNBE_BadWrite;
-	RFCNB_saved_errno = errno;
-	return (RFCNBE_Bad);
+        con->rfc_errno = errno;
+        if (errno == EINTR)	/* We were interrupted ... */
+            RFCNB_errno = RFCNBE_Timeout;
+        else
+            RFCNB_errno = RFCNBE_BadWrite;
+        RFCNB_saved_errno = errno;
+        return (RFCNBE_Bad);
 
     }
     if (len_sent < tot_sent) {	/* Less than we wanted */
-	if (errno == EINTR)	/* We were interrupted */
-	    RFCNB_errno = RFCNBE_Timeout;
-	else
-	    RFCNB_errno = RFCNBE_BadWrite;
-	RFCNB_saved_errno = errno;
-	return (RFCNBE_Bad);
+        if (errno == EINTR)	/* We were interrupted */
+            RFCNB_errno = RFCNBE_Timeout;
+        else
+            RFCNB_errno = RFCNBE_BadWrite;
+        RFCNB_saved_errno = errno;
+        return (RFCNBE_Bad);
     }
     if (RFCNB_Timeout > 0)
-	alarm(0);		/* Reset that sucker */
+        alarm(0);		/* Reset that sucker */
 
 #ifdef RFCNB_DEBUG
 
@@ -209,11 +209,11 @@ RFCNB_Put_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len)
 
 }
 
-/* Read an RFCNB packet off the connection. 
- * 
+/* Read an RFCNB packet off the connection.
+ *
  * We read the first 4 bytes, that tells us the length, then read the
- * rest. We should implement a timeout, but we don't just yet 
- * 
+ * rest. We should implement a timeout, but we don't just yet
+ *
  */
 
 
@@ -231,74 +231,74 @@ RFCNB_Get_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len)
     if (len < RFCNB_Pkt_Hdr_Len) {	/* What a bozo */
 
 #ifdef RFCNB_DEBUG
-	fprintf(stderr, "Trying to read less than a packet:");
-	perror("");
+        fprintf(stderr, "Trying to read less than a packet:");
+        perror("");
 #endif
-	RFCNB_errno = RFCNBE_BadParam;
-	return (RFCNBE_Bad);
+        RFCNB_errno = RFCNBE_BadParam;
+        return (RFCNBE_Bad);
 
     }
     /* We discard keep alives here ... */
 
     if (RFCNB_Timeout > 0)
-	alarm(RFCNB_Timeout);
+        alarm(RFCNB_Timeout);
 
     while (seen_keep_alive) {
 
-	if ((read_len = read(con->fd, hdr, sizeof(hdr))) < 0) {		/* Problems */
+        if ((read_len = read(con->fd, hdr, sizeof(hdr))) < 0) {		/* Problems */
 #ifdef RFCNB_DEBUG
-	    fprintf(stderr, "Reading the packet, we got:");
-	    perror("");
+            fprintf(stderr, "Reading the packet, we got:");
+            perror("");
 #endif
-	    if (errno == EINTR)
-		RFCNB_errno = RFCNBE_Timeout;
-	    else
-		RFCNB_errno = RFCNBE_BadRead;
-	    RFCNB_saved_errno = errno;
-	    return (RFCNBE_Bad);
+            if (errno == EINTR)
+                RFCNB_errno = RFCNBE_Timeout;
+            else
+                RFCNB_errno = RFCNBE_BadRead;
+            RFCNB_saved_errno = errno;
+            return (RFCNBE_Bad);
 
-	}
-	/* Now we check out what we got */
+        }
+        /* Now we check out what we got */
 
-	if (read_len == 0) {	/* Connection closed, send back eof?  */
+        if (read_len == 0) {	/* Connection closed, send back eof?  */
 
 #ifdef RFCNB_DEBUG
-	    fprintf(stderr, "Connection closed reading\n");
+            fprintf(stderr, "Connection closed reading\n");
 #endif
 
-	    if (errno == EINTR)
-		RFCNB_errno = RFCNBE_Timeout;
-	    else
-		RFCNB_errno = RFCNBE_ConGone;
-	    RFCNB_saved_errno = errno;
-	    return (RFCNBE_Bad);
+            if (errno == EINTR)
+                RFCNB_errno = RFCNBE_Timeout;
+            else
+                RFCNB_errno = RFCNBE_ConGone;
+            RFCNB_saved_errno = errno;
+            return (RFCNBE_Bad);
 
-	}
-	if (RFCNB_Pkt_Type(hdr) == RFCNB_SESSION_KEEP_ALIVE) {
+        }
+        if (RFCNB_Pkt_Type(hdr) == RFCNB_SESSION_KEEP_ALIVE) {
 
 #ifdef RFCNB_DEBUG
-	    fprintf(stderr, "RFCNB KEEP ALIVE received\n");
+            fprintf(stderr, "RFCNB KEEP ALIVE received\n");
 #endif
 
-	} else {
-	    seen_keep_alive = FALSE;
-	}
+        } else {
+            seen_keep_alive = FALSE;
+        }
 
     }
 
     /* What if we got less than or equal to a hdr size in bytes? */
 
     if (read_len < sizeof(hdr)) {	/* We got a small packet */
 
-	/* Now we need to copy the hdr portion we got into the supplied packet */
+        /* Now we need to copy the hdr portion we got into the supplied packet */
 
-	memcpy(pkt->data, hdr, read_len);	/*Copy data */
+        memcpy(pkt->data, hdr, read_len);	/*Copy data */
 
 #ifdef RFCNB_DEBUG
-	RFCNB_Print_Pkt(stderr, "rcvd", pkt, read_len);
+        RFCNB_Print_Pkt(stderr, "rcvd", pkt, read_len);
 #endif
 
-	return (read_len);
+        return (read_len);
 
     }
     /* Now, if we got at least a hdr size, alloc space for rest, if we need it */
@@ -318,65 +318,65 @@ RFCNB_Get_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len)
     /* use an iovec ...                                                    */
 
     if (len < pkt_len)		/* Only get as much as we have space for */
-	more = len - RFCNB_Pkt_Hdr_Len;
+        more = len - RFCNB_Pkt_Hdr_Len;
     else
-	more = pkt_len;
+        more = pkt_len;
 
     this_time = 0;
 
     /* We read for each fragment ... */
 
     if (pkt->len == read_len) {	/* If this frag was exact size */
-	pkt_frag = pkt->next;	/* Stick next lot in next frag */
-	offset = 0;		/* then we start at 0 in next  */
+        pkt_frag = pkt->next;	/* Stick next lot in next frag */
+        offset = 0;		/* then we start at 0 in next  */
     } else {
-	pkt_frag = pkt;		/* Otherwise use rest of this frag */
-	offset = RFCNB_Pkt_Hdr_Len;	/* Otherwise skip the header       */
+        pkt_frag = pkt;		/* Otherwise use rest of this frag */
+        offset = RFCNB_Pkt_Hdr_Len;	/* Otherwise skip the header       */
     }
 
     frag_len = pkt_frag->len;
 
     if (more <= frag_len)	/* If len left to get less than frag space */
-	this_len = more;	/* Get the rest ...                        */
+        this_len = more;	/* Get the rest ...                        */
     else
-	this_len = frag_len - offset;
+        this_len = frag_len - offset;
 
     while (more > 0) {
 
-	if ((this_time = read(con->fd, (pkt_frag->data) + offset, this_len)) <= 0) {	/* Problems */
+        if ((this_time = read(con->fd, (pkt_frag->data) + offset, this_len)) <= 0) {	/* Problems */
 
-	    if (errno == EINTR) {
+            if (errno == EINTR) {
 
-		RFCNB_errno = RFCNB_Timeout;
+                RFCNB_errno = RFCNB_Timeout;
 
-	    } else {
-		if (this_time < 0)
-		    RFCNB_errno = RFCNBE_BadRead;
-		else
-		    RFCNB_errno = RFCNBE_ConGone;
-	    }
+            } else {
+                if (this_time < 0)
+                    RFCNB_errno = RFCNBE_BadRead;
+                else
+                    RFCNB_errno = RFCNBE_ConGone;
+            }
 
-	    RFCNB_saved_errno = errno;
-	    return (RFCNBE_Bad);
+            RFCNB_saved_errno = errno;
+            return (RFCNBE_Bad);
 
-	}
+        }
 #ifdef RFCNB_DEBUG
-	fprintf(stderr, "Frag_Len = %i, this_time = %i, this_len = %i, more = %i\n", frag_len,
-	    this_time, this_len, more);
+        fprintf(stderr, "Frag_Len = %i, this_time = %i, this_len = %i, more = %i\n", frag_len,
+                this_time, this_len, more);
 #endif
 
-	read_len = read_len + this_time;	/* How much have we read ... */
+        read_len = read_len + this_time;	/* How much have we read ... */
 
-	/* Now set up the next part */
+        /* Now set up the next part */
 
-	if (pkt_frag->next == NULL)
-	    break;		/* That's it here */
+        if (pkt_frag->next == NULL)
+            break;		/* That's it here */
 
-	pkt_frag = pkt_frag->next;
-	this_len = pkt_frag->len;
-	offset = 0;
+        pkt_frag = pkt_frag->next;
+        this_len = pkt_frag->len;
+        offset = 0;
 
-	more = more - this_time;
+        more = more - this_time;
 
     }
 
@@ -387,11 +387,11 @@ RFCNB_Get_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len)
 
     if (read_len < (pkt_len + sizeof(hdr))) {	/* Discard the rest */
 
-	return (RFCNB_Discard_Rest(con, (pkt_len + sizeof(hdr)) - read_len));
+        return (RFCNB_Discard_Rest(con, (pkt_len + sizeof(hdr)) - read_len));
 
     }
     if (RFCNB_Timeout > 0)
-	alarm(0);		/* Reset that sucker */
+        alarm(0);		/* Reset that sucker */
 
     return (read_len + sizeof(RFCNB_Hdr));
 }
@@ -1,23 +1,23 @@
 /* UNIX RFCNB (RFC1001/RFC1002) NetBIOS implementation
- * 
+ *
  * Version 1.0
  * RFCNB IO Routines Defines
- * 
+ *
  * Copyright (C) Richard Sharpe 1996
- * 
+ *
  */
 
 /*
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
@@ -1,23 +1,23 @@
 /* UNIX RFCNB (RFC1001/RFC1002) NetBIOS implementation
- * 
+ *
  * Version 1.0
  * RFCNB Defines
- * 
+ *
  * Copyright (C) Richard Sharpe 1996
- * 
+ *
  */
 
 /*
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
@@ -73,8 +73,8 @@ typedef struct RFCNB_Con {
 } RFCNB_Con;
 
 typedef char RFCNB_Hdr[4];	/* The header is 4 bytes long with  */
-				    /* char[0] as the type, char[1] the */
-				    /* flags, and char[2..3] the length */
+/* char[0] as the type, char[1] the */
+/* flags, and char[2..3] the length */
 
 /* Macros to extract things from the header. These are for portability
  * between architecture types where we are worried about byte order     */
@@ -107,13 +107,13 @@ typedef char RFCNB_Hdr[4];	/* The header is 4 bytes long with  */
 #define RFCNB_Pkt_Type(p) (CVAL(p, RFCNB_Pkt_Type_Offset))
 
 /*typedef struct RFCNB_Hdr {
- * 
+ *
  * unsigned char type;
  * unsigned char flags;
  * int16 len;
- * 
+ *
  * } RFCNB_Hdr;
- * 
+ *
  * typedef struct RFCNB_Sess_Pkt {
  * unsigned char type;
  * unsigned char flags;
@@ -123,21 +123,21 @@ typedef char RFCNB_Hdr[4];	/* The header is 4 bytes long with  */
  * unsigned char n2_len;
  * char calling_name[33];
  * } RFCNB_Sess_Pkt;
- * 
- * 
+ *
+ *
  * typedef struct RFCNB_Nack_Pkt {
- * 
+ *
  * struct RFCNB_Hdr hdr;
  * unsigned char error;
- * 
+ *
  * } RFCNB_Nack_Pkt;
- * 
+ *
  * typedef struct RFCNB_Retarget_Pkt {
- * 
+ *
  * struct RFCNB_Hdr hdr;
  * int dest_ip;
  * unsigned char port;
- * 
+ *
  * } RFCNB_Redir_Pkt; */
 
 /* Static variables */
@@ -1,23 +1,23 @@
 /* UNIX RFCNB (RFC1001/RFC1002) NetBIOS implementation
- * 
+ *
  * Version 1.0
  * RFCNB Utility Routines ...
- * 
+ *
  * Copyright (C) Richard Sharpe 1996
- * 
+ *
  */
 
 /*
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
@@ -36,8 +36,7 @@
 #include <arpa/inet.h>
 #include <string.h>
 
-const char *RFCNB_Error_Strings[] =
-{
+const char *RFCNB_Error_Strings[] = {
 
     "RFCNBE_OK: Routine completed successfully.",
     "RFCNBE_NoSpace: No space available for a malloc call.",
@@ -77,20 +76,20 @@ RFCNB_CvtPad_Name(char *name1, char *name2)
 
     for (i = 0; i < 16; i++) {
 
-	if (i >= len) {
+        if (i >= len) {
 
-	    c1 = 'C';
-	    c2 = 'A';		/* CA is a space */
+            c1 = 'C';
+            c2 = 'A';		/* CA is a space */
 
-	} else {
+        } else {
 
-	    c = name1[i];
-	    c1 = (char) ((int) c / 16 + (int) 'A');
-	    c2 = (char) ((int) c % 16 + (int) 'A');
-	}
+            c = name1[i];
+            c1 = (char) ((int) c / 16 + (int) 'A');
+            c2 = (char) ((int) c % 16 + (int) 'A');
+        }
 
-	name2[i * 2] = c1;
-	name2[i * 2 + 1] = c2;
+        name2[i * 2] = c1;
+        name2[i * 2 + 1] = c2;
 
     }
 
@@ -101,10 +100,10 @@ RFCNB_CvtPad_Name(char *name1, char *name2)
 /* Converts an Ascii NB Name (16 chars) to an RFCNB Name (32 chars)
  * Uses the encoding in RFC1001. Each nibble of byte is added to 'A'
  * to produce the next byte in the name.
- * 
- * This routine assumes that AName is 16 bytes long and that NBName has 
- * space for 32 chars, so be careful ... 
- * 
+ *
+ * This routine assumes that AName is 16 bytes long and that NBName has
+ * space for 32 chars, so be careful ...
+ *
  */
 
 void
@@ -115,13 +114,13 @@ RFCNB_AName_To_NBName(char *AName, char *NBName)
 
     for (i = 0; i < 16; i++) {
 
-	c = AName[i];
+        c = AName[i];
 
-	c1 = (char) ((c >> 4) + 'A');
-	c2 = (char) ((c & 0xF) + 'A');
+        c1 = (char) ((c >> 4) + 'A');
+        c2 = (char) ((c & 0xF) + 'A');
 
-	NBName[i * 2] = c1;
-	NBName[i * 2 + 1] = c2;
+        NBName[i * 2] = c1;
+        NBName[i * 2 + 1] = c2;
     }
 
     NBName[32] = 0;		/* Put in a null */
@@ -138,12 +137,12 @@ RFCNB_NBName_To_AName(char *NBName, char *AName)
 
     for (i = 0; i < 16; i++) {
 
-	c1 = NBName[i * 2];
-	c2 = NBName[i * 2 + 1];
+        c1 = NBName[i * 2];
+        c2 = NBName[i * 2 + 1];
 
-	c = (char) (((int) c1 - (int) 'A') * 16 + ((int) c2 - (int) 'A'));
+        c = (char) (((int) c1 - (int) 'A') * 16 + ((int) c2 - (int) 'A'));
 
-	AName[i] = c;
+        AName[i] = c;
 
     }
 
@@ -169,36 +168,36 @@ RFCNB_Print_Hex(FILE * fd, struct RFCNB_Pkt *pkt, int Offset, int Len)
 
     while (pkt_ptr != NULL) {
 
-	for (i = 0;
-	    i < ((Len > (pkt_ptr->len) ? pkt_ptr->len : Len) - Offset);
-	    i++) {
+        for (i = 0;
+                i < ((Len > (pkt_ptr->len) ? pkt_ptr->len : Len) - Offset);
+                i++) {
 
-	    c = pkt_ptr->data[i + Offset];
-	    c1 = Hex_List[c >> 4];
-	    c2 = Hex_List[c & 0xF];
+            c = pkt_ptr->data[i + Offset];
+            c1 = Hex_List[c >> 4];
+            c2 = Hex_List[c & 0xF];
 
-	    outbuf1[j++] = c1;
-	    outbuf1[j++] = c2;
+            outbuf1[j++] = c1;
+            outbuf1[j++] = c2;
 
-	    if (j == 32) {	/* Print and reset */
-		outbuf1[j] = 0;
-		fprintf(fd, "    %s\n", outbuf1);
-		j = 0;
-	    }
-	}
+            if (j == 32) {	/* Print and reset */
+                outbuf1[j] = 0;
+                fprintf(fd, "    %s\n", outbuf1);
+                j = 0;
+            }
+        }
 
-	Offset = 0;
-	Len = Len - pkt_ptr->len;	/* Reduce amount by this much */
-	pkt_ptr = pkt_ptr->next;
+        Offset = 0;
+        Len = Len - pkt_ptr->len;	/* Reduce amount by this much */
+        pkt_ptr = pkt_ptr->next;
 
     }
 
     /* Print last lot in the buffer ... */
 
     if (j > 0) {
 
-	outbuf1[j] = 0;
-	fprintf(fd, "    %s\n", outbuf1);
+        outbuf1[j] = 0;
+        fprintf(fd, "    %s\n", outbuf1);
 
     }
     fprintf(fd, "\n");
@@ -209,26 +208,25 @@ RFCNB_Print_Hex(FILE * fd, struct RFCNB_Pkt *pkt, int Offset, int Len)
 /* Get a packet of size n */
 
 struct RFCNB_Pkt *
-RFCNB_Alloc_Pkt(int n)
-{
+            RFCNB_Alloc_Pkt(int n) {
     RFCNB_Pkt *pkt;
 
     if ((pkt = malloc(sizeof(struct RFCNB_Pkt))) == NULL) {
-	RFCNB_errno = RFCNBE_NoSpace;
-	RFCNB_saved_errno = errno;
-	return (NULL);
+        RFCNB_errno = RFCNBE_NoSpace;
+        RFCNB_saved_errno = errno;
+        return (NULL);
     }
     pkt->next = NULL;
     pkt->len = n;
 
     if (n == 0)
-	return (pkt);
+        return (pkt);
 
     if ((pkt->data = malloc(n)) == NULL) {
-	RFCNB_errno = RFCNBE_NoSpace;
-	RFCNB_saved_errno = errno;
-	free(pkt);
-	return (NULL);
+        RFCNB_errno = RFCNBE_NoSpace;
+        RFCNB_saved_errno = errno;
+        free(pkt);
+        return (NULL);
     }
     return (pkt);
 
@@ -243,14 +241,14 @@ RFCNB_Free_Pkt(struct RFCNB_Pkt *pkt)
 
     while (pkt != NULL) {
 
-	pkt_next = pkt->next;
+        pkt_next = pkt->next;
 
-	if (pkt->data != NULL)
-	    free(pkt->data);
+        if (pkt->data != NULL)
+            free(pkt->data);
 
-	free(pkt);
+        free(pkt);
 
-	pkt = pkt_next;
+        pkt = pkt_next;
 
     }
 
@@ -273,70 +271,70 @@ RFCNB_Print_Pkt(FILE * fd, char *dirn, struct RFCNB_Pkt *pkt, int len)
 
     case RFCNB_SESSION_MESSAGE:
 
-	fprintf(fd, "SESSION MESSAGE: Length = %i\n", RFCNB_Pkt_Len(pkt->data));
-	RFCNB_Print_Hex(fd, pkt, RFCNB_Pkt_Hdr_Len,
+        fprintf(fd, "SESSION MESSAGE: Length = %i\n", RFCNB_Pkt_Len(pkt->data));
+        RFCNB_Print_Hex(fd, pkt, RFCNB_Pkt_Hdr_Len,
 #ifdef RFCNB_PRINT_DATA
-	    RFCNB_Pkt_Len(pkt->data) - RFCNB_Pkt_Hdr_Len);
+                        RFCNB_Pkt_Len(pkt->data) - RFCNB_Pkt_Hdr_Len);
 #else
-	    40);
+                        40);
 #endif
 
-	if (Prot_Print_Routine != 0) {	/* Print the rest of the packet */
+        if (Prot_Print_Routine != 0) {	/* Print the rest of the packet */
 
-	    Prot_Print_Routine(fd, strcmp(dirn, "sent"), pkt, RFCNB_Pkt_Hdr_Len,
-		RFCNB_Pkt_Len(pkt->data) - RFCNB_Pkt_Hdr_Len);
+            Prot_Print_Routine(fd, strcmp(dirn, "sent"), pkt, RFCNB_Pkt_Hdr_Len,
+                               RFCNB_Pkt_Len(pkt->data) - RFCNB_Pkt_Hdr_Len);
 
-	}
-	break;
+        }
+        break;
 
     case RFCNB_SESSION_REQUEST:
 
-	fprintf(fd, "SESSION REQUEST: Length = %i\n",
-	    RFCNB_Pkt_Len(pkt->data));
-	RFCNB_NBName_To_AName((char *) (pkt->data + RFCNB_Pkt_Called_Offset), lname);
-	fprintf(fd, "  Called Name: %s\n", lname);
-	RFCNB_NBName_To_AName((char *) (pkt->data + RFCNB_Pkt_Calling_Offset), lname);
-	fprintf(fd, "  Calling Name: %s\n", lname);
+        fprintf(fd, "SESSION REQUEST: Length = %i\n",
+                RFCNB_Pkt_Len(pkt->data));
+        RFCNB_NBName_To_AName((char *) (pkt->data + RFCNB_Pkt_Called_Offset), lname);
+        fprintf(fd, "  Called Name: %s\n", lname);
+        RFCNB_NBName_To_AName((char *) (pkt->data + RFCNB_Pkt_Calling_Offset), lname);
+        fprintf(fd, "  Calling Name: %s\n", lname);
 
-	break;
+        break;
 
     case RFCNB_SESSION_ACK:
 
-	fprintf(fd, "RFCNB SESSION ACK: Length = %i\n",
-	    RFCNB_Pkt_Len(pkt->data));
+        fprintf(fd, "RFCNB SESSION ACK: Length = %i\n",
+                RFCNB_Pkt_Len(pkt->data));
 
-	break;
+        break;
 
     case RFCNB_SESSION_REJ:
-	fprintf(fd, "RFCNB SESSION REJECT: Length = %i\n",
-	    RFCNB_Pkt_Len(pkt->data));
+        fprintf(fd, "RFCNB SESSION REJECT: Length = %i\n",
+                RFCNB_Pkt_Len(pkt->data));
 
-	if (RFCNB_Pkt_Len(pkt->data) < 1) {
-	    fprintf(fd, "   Protocol Error, short Reject packet!\n");
-	} else {
-	    fprintf(fd, "   Error = %x\n", CVAL(pkt->data, RFCNB_Pkt_Error_Offset));
-	}
+        if (RFCNB_Pkt_Len(pkt->data) < 1) {
+            fprintf(fd, "   Protocol Error, short Reject packet!\n");
+        } else {
+            fprintf(fd, "   Error = %x\n", CVAL(pkt->data, RFCNB_Pkt_Error_Offset));
+        }
 
-	break;
+        break;
 
     case RFCNB_SESSION_RETARGET:
 
-	fprintf(fd, "RFCNB SESSION RETARGET: Length = %i\n",
-	    RFCNB_Pkt_Len(pkt->data));
+        fprintf(fd, "RFCNB SESSION RETARGET: Length = %i\n",
+                RFCNB_Pkt_Len(pkt->data));
 
-	/* Print out the IP address etc and the port? */
+        /* Print out the IP address etc and the port? */
 
-	break;
+        break;
 
     case RFCNB_SESSION_KEEP_ALIVE:
 
-	fprintf(fd, "RFCNB SESSION KEEP ALIVE: Length = %i\n",
-	    RFCNB_Pkt_Len(pkt->data));
-	break;
+        fprintf(fd, "RFCNB SESSION KEEP ALIVE: Length = %i\n",
+                RFCNB_Pkt_Len(pkt->data));
+        break;
 
     default:
 
-	break;
+        break;
     }
 
 }
@@ -354,20 +352,20 @@ RFCNB_Name_To_IP(char *host, struct in_addr *Dest_IP)
 
     if ((addr = inet_addr(host)) == INADDR_NONE) {	/* Oh well, a good try :-) */
 
-	/* Now try a name look up with gethostbyname */
+        /* Now try a name look up with gethostbyname */
 
-	if ((hp = gethostbyname(host)) == NULL) {	/* Not in DNS */
+        if ((hp = gethostbyname(host)) == NULL) {	/* Not in DNS */
 
-	    /* Try NetBIOS name lookup, how the hell do we do that? */
-	    RFCNB_errno = RFCNBE_BadName;	/* Is this right? */
-	    RFCNB_saved_errno = errno;
-	    return (RFCNBE_Bad);
+            /* Try NetBIOS name lookup, how the hell do we do that? */
+            RFCNB_errno = RFCNBE_BadName;	/* Is this right? */
+            RFCNB_saved_errno = errno;
+            return (RFCNBE_Bad);
 
-	} else { /* We got a name */
+        } else { /* We got a name */
             Dest_IP->s_addr = (*((struct in_addr*)hp->h_addr_list[0])).s_addr;
-	}
+        }
     } else { /* It was an IP address */
-	Dest_IP->s_addr = addr;
+        Dest_IP->s_addr = addr;
     }
 
     return 0;
@@ -401,9 +399,9 @@ RFCNB_IP_Connect(struct in_addr Dest_IP, int port)
 
     if ((fd = socket(PF_INET, SOCK_STREAM, 0)) < 0) {	/* Handle the error */
 
-	RFCNB_errno = RFCNBE_BadSocket;
-	RFCNB_saved_errno = errno;
-	return (RFCNBE_Bad);
+        RFCNB_errno = RFCNBE_BadSocket;
+        RFCNB_saved_errno = errno;
+        return (RFCNBE_Bad);
     }
     memset((char *) &Socket, 0, sizeof(Socket));
     memcpy((char *) &Socket.sin_addr, (char *) &Dest_IP, sizeof(Dest_IP));
@@ -415,27 +413,27 @@ RFCNB_IP_Connect(struct in_addr Dest_IP, int port)
 
     if (connect(fd, (struct sockaddr *) &Socket, sizeof(Socket)) < 0) {		/* Error */
 
-	close(fd);
-	RFCNB_errno = RFCNBE_ConnectFailed;
-	RFCNB_saved_errno = errno;
-	return (RFCNBE_Bad);
+        close(fd);
+        RFCNB_errno = RFCNBE_ConnectFailed;
+        RFCNB_saved_errno = errno;
+        return (RFCNBE_Bad);
     }
     return (fd);
 
 }
 
-/* handle the details of establishing the RFCNB session with remote 
- * end 
- * 
+/* handle the details of establishing the RFCNB session with remote
+ * end
+ *
  */
 
 int
 RFCNB_Session_Req(struct RFCNB_Con *con,
-    char *Called_Name,
-    char *Calling_Name,
-    BOOL * redirect,
-    struct in_addr *Dest_IP,
-    int *port)
+                  char *Called_Name,
+                  char *Calling_Name,
+                  BOOL * redirect,
+                  struct in_addr *Dest_IP,
+                  int *port)
 {
     char *sess_pkt;
 
@@ -451,7 +449,7 @@ RFCNB_Session_Req(struct RFCNB_Con *con,
 
     if (pkt == NULL) {
 
-	return (RFCNBE_Bad);	/* Leave the error that RFCNB_Alloc_Pkt gives) */
+        return (RFCNBE_Bad);	/* Leave the error that RFCNB_Alloc_Pkt gives) */
 
     }
     sess_pkt = pkt->data;	/* Get pointer to packet proper */
@@ -474,7 +472,7 @@ RFCNB_Session_Req(struct RFCNB_Con *con,
 
     if ((len = RFCNB_Put_Pkt(con, pkt, RFCNB_Pkt_Sess_Len)) < 0) {
 
-	return (RFCNBE_Bad);	/* Should be able to write that lot ... */
+        return (RFCNBE_Bad);	/* Should be able to write that lot ... */
 
     }
 #ifdef RFCNB_DEBUG
@@ -489,7 +487,7 @@ RFCNB_Session_Req(struct RFCNB_Con *con,
 
     if ((len = RFCNB_Get_Pkt(con, &res_pkt, sizeof(resp))) < 0) {
 
-	return (RFCNBE_Bad);
+        return (RFCNBE_Bad);
 
     }
     /* Now analyze the packet ... */
@@ -498,52 +496,52 @@ RFCNB_Session_Req(struct RFCNB_Con *con,
 
     case RFCNB_SESSION_REJ:	/* Didnt like us ... too bad */
 
-	/* Why did we get rejected ? */
-
-	switch (CVAL(resp, RFCNB_Pkt_Error_Offset)) {
-
-	case 0x80:
-	    RFCNB_errno = RFCNBE_CallRejNLOCN;
-	    break;
-	case 0x81:
-	    RFCNB_errno = RFCNBE_CallRejNLFCN;
-	    break;
-	case 0x82:
-	    RFCNB_errno = RFCNBE_CallRejCNNP;
-	    break;
-	case 0x83:
-	    RFCNB_errno = RFCNBE_CallRejInfRes;
-	    break;
-	case 0x8F:
-	    RFCNB_errno = RFCNBE_CallRejUnSpec;
-	    break;
-	default:
-	    RFCNB_errno = RFCNBE_ProtErr;
-	    break;
-	}
-
-	return (RFCNBE_Bad);
-	break;
+        /* Why did we get rejected ? */
+
+        switch (CVAL(resp, RFCNB_Pkt_Error_Offset)) {
+
+        case 0x80:
+            RFCNB_errno = RFCNBE_CallRejNLOCN;
+            break;
+        case 0x81:
+            RFCNB_errno = RFCNBE_CallRejNLFCN;
+            break;
+        case 0x82:
+            RFCNB_errno = RFCNBE_CallRejCNNP;
+            break;
+        case 0x83:
+            RFCNB_errno = RFCNBE_CallRejInfRes;
+            break;
+        case 0x8F:
+            RFCNB_errno = RFCNBE_CallRejUnSpec;
+            break;
+        default:
+            RFCNB_errno = RFCNBE_ProtErr;
+            break;
+        }
+
+        return (RFCNBE_Bad);
+        break;
 
     case RFCNB_SESSION_ACK:	/* Got what we wanted ...      */
 
-	return (0);
-	break;
+        return (0);
+        break;
 
     case RFCNB_SESSION_RETARGET:	/* Go elsewhere                */
 
-	*redirect = TRUE;	/* Copy port and ip addr       */
+        *redirect = TRUE;	/* Copy port and ip addr       */
 
-	memcpy(Dest_IP, (resp + RFCNB_Pkt_IP_Offset), sizeof(struct in_addr));
-	*port = SVAL(resp, RFCNB_Pkt_Port_Offset);
+        memcpy(Dest_IP, (resp + RFCNB_Pkt_IP_Offset), sizeof(struct in_addr));
+        *port = SVAL(resp, RFCNB_Pkt_Port_Offset);
 
-	return (0);
-	break;
+        return (0);
+        break;
 
     default:			/* A protocol error */
 
-	RFCNB_errno = RFCNBE_ProtErr;
-	return (RFCNBE_Bad);
-	break;
+        RFCNB_errno = RFCNBE_ProtErr;
+        return (RFCNBE_Bad);
+        break;
     }
 }
@@ -1,23 +1,23 @@
 /* UNIX RFCNB (RFC1001/RFC1002) NetBIOS implementation
- * 
+ *
  * Version 1.0
  * RFCNB Utility Defines
- * 
+ *
  * Copyright (C) Richard Sharpe 1996
- * 
+ *
  */
 
 /*
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
@@ -42,10 +42,10 @@ int RFCNB_Close(int socket);
 int RFCNB_IP_Connect(struct in_addr Dest_IP, int port);
 
 int RFCNB_Session_Req(RFCNB_Con * con,
-    char *Called_Name,
-    char *Calling_Name,
-    BOOL * redirect,
-    struct in_addr *Dest_IP,
-    int *port);
+                      char *Called_Name,
+                      char *Calling_Name,
+                      BOOL * redirect,
+                      struct in_addr *Dest_IP,
+                      int *port);
 
 void RFCNB_Free_Pkt(struct RFCNB_Pkt *pkt);
@@ -1,23 +1,23 @@
 /* UNIX RFCNB (RFC1001/RFC1002) NetBIOS implementation
- * 
+ *
  * Version 1.0
  * RFCNB Defines
- * 
+ *
  * Copyright (C) Richard Sharpe 1996
- * 
+ *
  */
 
 /*
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
@@ -37,7 +37,7 @@
 struct RFCNB_Con;
 
 void *RFCNB_Call(char *Called_Name, char *Calling_Name, char *Called_Address,
-    int port);
+                 int port);
 
 int RFCNB_Send(struct RFCNB_Con *Con_Handle, struct RFCNB_Pkt *Data, int Length);
 
@@ -1,23 +1,23 @@
 /* UNIX RFCNB (RFC1001/RFC1002) NetBIOS implementation
- * 
+ *
  * Version 1.0
  * Session Routines ...
- * 
+ *
  * Copyright (C) Richard Sharpe 1996
- * 
+ *
  */
 
 /*
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
@@ -47,13 +47,13 @@ void (*Prot_Print_Routine) () = NULL;	/* Pointer to print routine */
 /* Set up a session with a remote name. We are passed Called_Name as a
  * string which we convert to a NetBIOS name, ie space terminated, up to
  * 16 characters only if we need to. If Called_Address is not empty, then
- * we use it to connect to the remote end, but put in Called_Name ... Called 
+ * we use it to connect to the remote end, but put in Called_Name ... Called
  * Address can be a DNS based name, or a TCP/IP address ...
  */
 
 void *
 RFCNB_Call(char *Called_Name, char *Calling_Name, char *Called_Address,
-    int port)
+           int port)
 {
     struct RFCNB_Con *con;
     struct in_addr Dest_IP;
@@ -65,15 +65,15 @@ RFCNB_Call(char *Called_Name, char *Calling_Name, char *Called_Address,
     /* Now, we really should look up the port in /etc/services ... */
 
     if (port == 0)
-	port = RFCNB_Default_Port;
+        port = RFCNB_Default_Port;
 
     /* Create a connection structure first */
 
     if ((con = (struct RFCNB_Con *) malloc(sizeof(struct RFCNB_Con))) == NULL) {	/* Error in size */
 
-	RFCNB_errno = RFCNBE_NoSpace;
-	RFCNB_saved_errno = errno;
-	return (NULL);
+        RFCNB_errno = RFCNBE_NoSpace;
+        RFCNB_saved_errno = errno;
+        return (NULL);
 
     }
     con->fd = -0;		/* no descriptor yet */
@@ -86,13 +86,13 @@ RFCNB_Call(char *Called_Name, char *Calling_Name, char *Called_Address,
 
     Service_Address = Called_Name;
     if (strcmp(Called_Address, "") != 0) {	/* If the Called Address = "" */
-	Service_Address = Called_Address;
+        Service_Address = Called_Address;
     }
     if ((errno = RFCNB_Name_To_IP(Service_Address, &Dest_IP)) < 0) {	/* Error */
 
-	/* No need to modify RFCNB_errno as it was done by RFCNB_Name_To_IP */
+        /* No need to modify RFCNB_errno as it was done by RFCNB_Name_To_IP */
         free(con);
-	return (NULL);
+        return (NULL);
 
     }
     /* Now connect to the remote end */
@@ -101,76 +101,76 @@ RFCNB_Call(char *Called_Name, char *Calling_Name, char *Called_Address,
 
     while (redirect) {		/* Connect and get session info etc */
 
-	redirect = FALSE;	/* Assume all OK */
+        redirect = FALSE;	/* Assume all OK */
 
-	/* Build the redirect info. First one is first addr called */
-	/* And tack it onto the list of addresses we called        */
+        /* Build the redirect info. First one is first addr called */
+        /* And tack it onto the list of addresses we called        */
 
-	if ((redir_addr = (struct redirect_addr *) malloc(sizeof(struct redirect_addr))) == NULL) {	/* Could not get space */
+        if ((redir_addr = (struct redirect_addr *) malloc(sizeof(struct redirect_addr))) == NULL) {	/* Could not get space */
 
-	    RFCNB_errno = RFCNBE_NoSpace;
-	    RFCNB_saved_errno = errno;
+            RFCNB_errno = RFCNBE_NoSpace;
+            RFCNB_saved_errno = errno;
             free(con);
-	    return (NULL);
+            return (NULL);
 
-	}
-	memcpy((char *) &(redir_addr->ip_addr), (char *) &Dest_IP, sizeof(Dest_IP));
-	redir_addr->port = port;
-	redir_addr->next = NULL;
+        }
+        memcpy((char *) &(redir_addr->ip_addr), (char *) &Dest_IP, sizeof(Dest_IP));
+        redir_addr->port = port;
+        redir_addr->next = NULL;
 
-	if (con->redirect_list == NULL) {	/* Stick on head */
+        if (con->redirect_list == NULL) {	/* Stick on head */
 
-	    con->redirect_list = con->last_addr = redir_addr;
+            con->redirect_list = con->last_addr = redir_addr;
 
-	} else {
+        } else {
 
-	    con->last_addr->next = redir_addr;
-	    con->last_addr = redir_addr;
+            con->last_addr->next = redir_addr;
+            con->last_addr = redir_addr;
 
-	}
+        }
 
-	/* Now, make that connection */
+        /* Now, make that connection */
 
-	if ((Client = RFCNB_IP_Connect(Dest_IP, port)) < 0) {	/* Error */
+        if ((Client = RFCNB_IP_Connect(Dest_IP, port)) < 0) {	/* Error */
 
-	    /* No need to modify RFCNB_errno as it was done by RFCNB_IP_Connect */
+            /* No need to modify RFCNB_errno as it was done by RFCNB_IP_Connect */
             free(con);
-	    return (NULL);
+            return (NULL);
 
-	}
-	con->fd = Client;
+        }
+        con->fd = Client;
 
-	/* Now send and handle the RFCNB session request              */
-	/* If we get a redirect, we will comeback with redirect true 
-	 * and a new IP address in DEST_IP                            */
+        /* Now send and handle the RFCNB session request              */
+        /* If we get a redirect, we will comeback with redirect true
+         * and a new IP address in DEST_IP                            */
 
-	if ((errno = RFCNB_Session_Req(con,
-		    Called_Name,
-		    Calling_Name,
-		    &redirect, &Dest_IP, &port)) < 0) {
+        if ((errno = RFCNB_Session_Req(con,
+                                       Called_Name,
+                                       Calling_Name,
+                                       &redirect, &Dest_IP, &port)) < 0) {
 
-	    /* No need to modify RFCNB_errno as it was done by RFCNB_Session.. */
-	    RFCNB_Close(con->fd);	/* Close it */
+            /* No need to modify RFCNB_errno as it was done by RFCNB_Session.. */
+            RFCNB_Close(con->fd);	/* Close it */
             free(con);
-	    return (NULL);
+            return (NULL);
 
-	}
-	if (redirect) {
+        }
+        if (redirect) {
 
-	    /* We have to close the connection, and then try again */
+            /* We have to close the connection, and then try again */
 
-	    (con->redirects)++;
+            (con->redirects)++;
 
-	    RFCNB_Close(con->fd);	/* Close it */
+            RFCNB_Close(con->fd);	/* Close it */
 
-	}
+        }
     }
 
     return (con);
 
 }
 
-/* We send a packet to the other end ... for the moment, we treat the 
+/* We send a packet to the other end ... for the moment, we treat the
  * data as a series of pointers to blocks of data ... we should check the
  * length ... */
 
@@ -187,9 +187,9 @@ RFCNB_Send(struct RFCNB_Con *Con_Handle, struct RFCNB_Pkt *udata, int Length)
 
     if (pkt == NULL) {
 
-	RFCNB_errno = RFCNBE_NoSpace;
-	RFCNB_saved_errno = errno;
-	return (RFCNBE_Bad);
+        RFCNB_errno = RFCNBE_NoSpace;
+        RFCNB_saved_errno = errno;
+        return (RFCNBE_Bad);
 
     }
     pkt->next = udata;		/* The user data we want to send */
@@ -209,9 +209,9 @@ RFCNB_Send(struct RFCNB_Con *Con_Handle, struct RFCNB_Pkt *udata, int Length)
 
     if ((len = RFCNB_Put_Pkt(Con_Handle, pkt, Length + RFCNB_Pkt_Hdr_Len)) < 0) {
 
-	/* No need to change RFCNB_errno as it was done by put_pkt ...     */
+        /* No need to change RFCNB_errno as it was done by put_pkt ...     */
 
-	return (RFCNBE_Bad);	/* Should be able to write that lot ... */
+        return (RFCNBE_Bad);	/* Should be able to write that lot ... */
 
     }
     /* Now we have sent that lot, let's get rid of the RFCNB Header and return */
@@ -224,7 +224,7 @@ RFCNB_Send(struct RFCNB_Con *Con_Handle, struct RFCNB_Pkt *udata, int Length)
 
 }
 
-/* We pick up a message from the internet ... We have to worry about 
+/* We pick up a message from the internet ... We have to worry about
  * non-message packets ...                                           */
 
 int
@@ -235,9 +235,9 @@ RFCNB_Recv(struct RFCNB_Con *con_Handle, struct RFCNB_Pkt *Data, int Length)
 
     if (con_Handle == NULL) {
 
-	RFCNB_errno = RFCNBE_BadHandle;
-	RFCNB_saved_errno = errno;
-	return (RFCNBE_Bad);
+        RFCNB_errno = RFCNBE_BadHandle;
+        RFCNB_saved_errno = errno;
+        return (RFCNBE_Bad);
 
     }
     /* Now get a packet from below. We allocate a header first */
@@ -248,20 +248,20 @@ RFCNB_Recv(struct RFCNB_Con *con_Handle, struct RFCNB_Pkt *Data, int Length)
 
     if (pkt == NULL) {
 
-	RFCNB_errno = RFCNBE_NoSpace;
-	RFCNB_saved_errno = errno;
-	return (RFCNBE_Bad);
+        RFCNB_errno = RFCNBE_NoSpace;
+        RFCNB_saved_errno = errno;
+        return (RFCNBE_Bad);
 
     }
     pkt->next = Data;		/* Plug in the data portion */
 
     if ((ret_len = RFCNB_Get_Pkt(con_Handle, pkt, Length + RFCNB_Pkt_Hdr_Len)) < 0) {
 
 #ifdef RFCNB_DEBUG
-	fprintf(stderr, "Bad packet return in RFCNB_Recv... \n");
+        fprintf(stderr, "Bad packet return in RFCNB_Recv... \n");
 #endif
 
-	return (RFCNBE_Bad);
+        return (RFCNBE_Bad);
 
     }
     /* We should check that we go a message and not a keep alive */
@@ -282,8 +282,8 @@ RFCNB_Hangup(struct RFCNB_Con *con_Handle)
 {
 
     if (con_Handle != NULL) {
-	RFCNB_Close(con_Handle->fd);	/* Could this fail? */
-	free(con_Handle);
+        RFCNB_Close(con_Handle->fd);	/* Could this fail? */
+        free(con_Handle);
     }
     return 0;
 
@@ -297,10 +297,10 @@ void
 RFCNB_Get_Error(char *buffer, int buf_len)
 {
     if (RFCNB_saved_errno <= 0) {
-	snprintf(buffer, (buf_len-1) ,"%s", RFCNB_Error_Strings[RFCNB_errno]);
+        snprintf(buffer, (buf_len-1) ,"%s", RFCNB_Error_Strings[RFCNB_errno]);
     } else {
-	snprintf(buffer, (buf_len-1), "%s\n\terrno:%s", RFCNB_Error_Strings[RFCNB_errno],
-	    strerror(RFCNB_saved_errno));
+        snprintf(buffer, (buf_len-1), "%s\n\terrno:%s", RFCNB_Error_Strings[RFCNB_errno],
+                 strerror(RFCNB_saved_errno));
     }
 }
 
@@ -1,43 +1,43 @@
-/* 
+/*
  * Unix SMB/Netbios implementation.
  * Version 1.9.
- * 
- * a partial implementation of DES designed for use in the 
+ *
+ * a partial implementation of DES designed for use in the
  * SMB authentication protocol
- * 
+ *
  * Copyright (C) Andrew Tridgell 1997
- * 
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 
-/* NOTES: 
- * 
+/* NOTES:
+ *
  * This code makes no attempt to be fast! In fact, it is a very
- * slow implementation 
- * 
+ * slow implementation
+ *
  * This code is NOT a complete DES implementation. It implements only
  * the minimum necessary for SMB authentication, as used by all SMB
  * products (including every copy of Microsoft Windows95 ever sold)
- * 
+ *
  * In particular, it can only do a unchained forward DES pass. This
  * means it is not possible to use this code for encryption/decryption
  * of data, instead it is only useful as a "hash" algorithm.
- * 
+ *
  * There is no entry point into this code that allows normal DES operation.
- * 
+ *
  * I believe this means that this code does not come under ITAR
  * regulations but this is NOT a legal opinion. If you are concerned
  * about the applicability of ITAR regulations to this code then you
@@ -47,127 +47,126 @@
 
 #include "smbdes.h"
 
-static int perm1[56] =
-{57, 49, 41, 33, 25, 17, 9,
-    1, 58, 50, 42, 34, 26, 18,
-    10, 2, 59, 51, 43, 35, 27,
-    19, 11, 3, 60, 52, 44, 36,
-    63, 55, 47, 39, 31, 23, 15,
-    7, 62, 54, 46, 38, 30, 22,
-    14, 6, 61, 53, 45, 37, 29,
-    21, 13, 5, 28, 20, 12, 4};
-
-static int perm2[48] =
-{14, 17, 11, 24, 1, 5,
-    3, 28, 15, 6, 21, 10,
-    23, 19, 12, 4, 26, 8,
-    16, 7, 27, 20, 13, 2,
-    41, 52, 31, 37, 47, 55,
-    30, 40, 51, 45, 33, 48,
-    44, 49, 39, 56, 34, 53,
-    46, 42, 50, 36, 29, 32};
-
-static int perm3[64] =
-{58, 50, 42, 34, 26, 18, 10, 2,
-    60, 52, 44, 36, 28, 20, 12, 4,
-    62, 54, 46, 38, 30, 22, 14, 6,
-    64, 56, 48, 40, 32, 24, 16, 8,
-    57, 49, 41, 33, 25, 17, 9, 1,
-    59, 51, 43, 35, 27, 19, 11, 3,
-    61, 53, 45, 37, 29, 21, 13, 5,
-    63, 55, 47, 39, 31, 23, 15, 7};
-
-static int perm4[48] =
-{32, 1, 2, 3, 4, 5,
-    4, 5, 6, 7, 8, 9,
-    8, 9, 10, 11, 12, 13,
-    12, 13, 14, 15, 16, 17,
-    16, 17, 18, 19, 20, 21,
-    20, 21, 22, 23, 24, 25,
-    24, 25, 26, 27, 28, 29,
-    28, 29, 30, 31, 32, 1};
-
-static int perm5[32] =
-{16, 7, 20, 21,
-    29, 12, 28, 17,
-    1, 15, 23, 26,
-    5, 18, 31, 10,
-    2, 8, 24, 14,
-    32, 27, 3, 9,
-    19, 13, 30, 6,
-    22, 11, 4, 25};
-
-
-static int perm6[64] =
-{40, 8, 48, 16, 56, 24, 64, 32,
-    39, 7, 47, 15, 55, 23, 63, 31,
-    38, 6, 46, 14, 54, 22, 62, 30,
-    37, 5, 45, 13, 53, 21, 61, 29,
-    36, 4, 44, 12, 52, 20, 60, 28,
-    35, 3, 43, 11, 51, 19, 59, 27,
-    34, 2, 42, 10, 50, 18, 58, 26,
-    33, 1, 41, 9, 49, 17, 57, 25};
-
-
-static int sc[16] =
-{1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1};
-
-static int sbox[8][4][16] =
-{
+static int perm1[56] = {57, 49, 41, 33, 25, 17, 9,
+                        1, 58, 50, 42, 34, 26, 18,
+                        10, 2, 59, 51, 43, 35, 27,
+                        19, 11, 3, 60, 52, 44, 36,
+                        63, 55, 47, 39, 31, 23, 15,
+                        7, 62, 54, 46, 38, 30, 22,
+                        14, 6, 61, 53, 45, 37, 29,
+                        21, 13, 5, 28, 20, 12, 4
+                       };
+
+static int perm2[48] = {14, 17, 11, 24, 1, 5,
+                        3, 28, 15, 6, 21, 10,
+                        23, 19, 12, 4, 26, 8,
+                        16, 7, 27, 20, 13, 2,
+                        41, 52, 31, 37, 47, 55,
+                        30, 40, 51, 45, 33, 48,
+                        44, 49, 39, 56, 34, 53,
+                        46, 42, 50, 36, 29, 32
+                       };
+
+static int perm3[64] = {58, 50, 42, 34, 26, 18, 10, 2,
+                        60, 52, 44, 36, 28, 20, 12, 4,
+                        62, 54, 46, 38, 30, 22, 14, 6,
+                        64, 56, 48, 40, 32, 24, 16, 8,
+                        57, 49, 41, 33, 25, 17, 9, 1,
+                        59, 51, 43, 35, 27, 19, 11, 3,
+                        61, 53, 45, 37, 29, 21, 13, 5,
+                        63, 55, 47, 39, 31, 23, 15, 7
+                       };
+
+static int perm4[48] = {32, 1, 2, 3, 4, 5,
+                        4, 5, 6, 7, 8, 9,
+                        8, 9, 10, 11, 12, 13,
+                        12, 13, 14, 15, 16, 17,
+                        16, 17, 18, 19, 20, 21,
+                        20, 21, 22, 23, 24, 25,
+                        24, 25, 26, 27, 28, 29,
+                        28, 29, 30, 31, 32, 1
+                       };
+
+static int perm5[32] = {16, 7, 20, 21,
+                        29, 12, 28, 17,
+                        1, 15, 23, 26,
+                        5, 18, 31, 10,
+                        2, 8, 24, 14,
+                        32, 27, 3, 9,
+                        19, 13, 30, 6,
+                        22, 11, 4, 25
+                       };
+
+
+static int perm6[64] = {40, 8, 48, 16, 56, 24, 64, 32,
+                        39, 7, 47, 15, 55, 23, 63, 31,
+                        38, 6, 46, 14, 54, 22, 62, 30,
+                        37, 5, 45, 13, 53, 21, 61, 29,
+                        36, 4, 44, 12, 52, 20, 60, 28,
+                        35, 3, 43, 11, 51, 19, 59, 27,
+                        34, 2, 42, 10, 50, 18, 58, 26,
+                        33, 1, 41, 9, 49, 17, 57, 25
+                       };
+
+
+static int sc[16] = {1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1};
+
+static int sbox[8][4][16] = {
     {
-	{14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7},
-	{0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8},
-	{4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0},
-	{15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13}},
+        {14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7},
+        {0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8},
+        {4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0},
+        {15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13}},
 
     {
-	{15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10},
-	{3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5},
-	{0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15},
-	{13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9}},
+        {15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10},
+        {3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5},
+        {0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15},
+        {13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9}},
 
     {
-	{10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8},
-	{13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1},
-	{13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7},
-	{1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12}},
+        {10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8},
+        {13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1},
+        {13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7},
+        {1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12}},
 
     {
-	{7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15},
-	{13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9},
-	{10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4},
-	{3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14}},
+        {7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15},
+        {13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9},
+        {10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4},
+        {3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14}},
 
     {
-	{2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9},
-	{14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6},
-	{4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14},
-	{11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3}},
+        {2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9},
+        {14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6},
+        {4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14},
+        {11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3}},
 
     {
-	{12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11},
-	{10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8},
-	{9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6},
-	{4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13}},
+        {12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11},
+        {10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8},
+        {9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6},
+        {4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13}},
 
     {
-	{4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1},
-	{13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6},
-	{1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2},
-	{6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12}},
+        {4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1},
+        {13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6},
+        {1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2},
+        {6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12}},
 
     {
-	{13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7},
-	{1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2},
-	{7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8},
-	{2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11}}};
+        {13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7},
+        {1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2},
+        {7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8},
+        {2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11}}
+};
 
 static void
 permute(char *out, char *in, int *p, int n)
 {
     int i;
     for (i = 0; i < n; i++)
-	out[i] = in[p[i] - 1];
+        out[i] = in[p[i] - 1];
 }
 
 static void
@@ -176,26 +175,26 @@ lshift(char *d, int count, int n)
     char out[64];
     int i;
     for (i = 0; i < n; i++)
-	out[i] = d[(i + count) % n];
+        out[i] = d[(i + count) % n];
     for (i = 0; i < n; i++)
-	d[i] = out[i];
+        d[i] = out[i];
 }
 
 static void
 concat(char *out, char *in1, char *in2, int l1, int l2)
 {
     while (l1--)
-	*out++ = *in1++;
+        *out++ = *in1++;
     while (l2--)
-	*out++ = *in2++;
+        *out++ = *in2++;
 }
 
 static void
 xor(char *out, char *in1, char *in2, int n)
 {
     int i;
     for (i = 0; i < n; i++)
-	out[i] = in1[i] ^ in2[i];
+        out[i] = in1[i] ^ in2[i];
 }
 
 static void
@@ -214,63 +213,63 @@ dohash(char *out, char *in, char *key)
     permute(pk1, key, perm1, 56);
 
     for (i = 0; i < 28; i++)
-	c[i] = pk1[i];
+        c[i] = pk1[i];
     for (i = 0; i < 28; i++)
-	d[i] = pk1[i + 28];
+        d[i] = pk1[i + 28];
 
     for (i = 0; i < 16; i++) {
-	lshift(c, sc[i], 28);
-	lshift(d, sc[i], 28);
+        lshift(c, sc[i], 28);
+        lshift(d, sc[i], 28);
 
-	concat(cd, c, d, 28, 28);
-	permute(ki[i], cd, perm2, 48);
+        concat(cd, c, d, 28, 28);
+        permute(ki[i], cd, perm2, 48);
     }
 
     permute(pd1, in, perm3, 64);
 
     for (j = 0; j < 32; j++) {
-	l[j] = pd1[j];
-	r[j] = pd1[j + 32];
+        l[j] = pd1[j];
+        r[j] = pd1[j + 32];
     }
 
     for (i = 0; i < 16; i++) {
-	char er[48];
-	char erk[48];
-	char b[8][6];
-	char cb[32];
-	char pcb[32];
-	char r2[32];
+        char er[48];
+        char erk[48];
+        char b[8][6];
+        char cb[32];
+        char pcb[32];
+        char r2[32];
 
-	permute(er, r, perm4, 48);
+        permute(er, r, perm4, 48);
 
-	xor(erk, er, ki[i], 48);
+        xor(erk, er, ki[i], 48);
 
-	for (j = 0; j < 8; j++)
-	    for (k = 0; k < 6; k++)
-		b[j][k] = erk[j * 6 + k];
+        for (j = 0; j < 8; j++)
+            for (k = 0; k < 6; k++)
+                b[j][k] = erk[j * 6 + k];
 
-	for (j = 0; j < 8; j++) {
-	    int m, n;
-	    m = (b[j][0] << 1) | b[j][5];
+        for (j = 0; j < 8; j++) {
+            int m, n;
+            m = (b[j][0] << 1) | b[j][5];
 
-	    n = (b[j][1] << 3) | (b[j][2] << 2) | (b[j][3] << 1) | b[j][4];
+            n = (b[j][1] << 3) | (b[j][2] << 2) | (b[j][3] << 1) | b[j][4];
 
-	    for (k = 0; k < 4; k++)
-		b[j][k] = (sbox[j][m][n] & (1 << (3 - k))) ? 1 : 0;
-	}
+            for (k = 0; k < 4; k++)
+                b[j][k] = (sbox[j][m][n] & (1 << (3 - k))) ? 1 : 0;
+        }
 
-	for (j = 0; j < 8; j++)
-	    for (k = 0; k < 4; k++)
-		cb[j * 4 + k] = b[j][k];
-	permute(pcb, cb, perm5, 32);
+        for (j = 0; j < 8; j++)
+            for (k = 0; k < 4; k++)
+                cb[j * 4 + k] = b[j][k];
+        permute(pcb, cb, perm5, 32);
 
-	xor(r2, l, pcb, 32);
+        xor(r2, l, pcb, 32);
 
-	for (j = 0; j < 32; j++)
-	    l[j] = r[j];
+        for (j = 0; j < 32; j++)
+            l[j] = r[j];
 
-	for (j = 0; j < 32; j++)
-	    r[j] = r2[j];
+        for (j = 0; j < 32; j++)
+            r[j] = r2[j];
     }
 
     concat(rl, r, l, 32, 32);
@@ -292,7 +291,7 @@ str_to_key(unsigned char *str, unsigned char *key)
     key[6] = ((str[5] & 0x3F) << 1) | (str[6] >> 7);
     key[7] = str[6] & 0x7F;
     for (i = 0; i < 8; i++) {
-	key[i] = (key[i] << 1);
+        key[i] = (key[i] << 1);
     }
 }
 
@@ -309,28 +308,27 @@ smbhash(unsigned char *out, unsigned char *in, unsigned char *key)
     str_to_key(key, key2);
 
     for (i = 0; i < 64; i++) {
-	inb[i] = (in[i / 8] & (1 << (7 - (i % 8)))) ? 1 : 0;
-	keyb[i] = (key2[i / 8] & (1 << (7 - (i % 8)))) ? 1 : 0;
-	outb[i] = 0;
+        inb[i] = (in[i / 8] & (1 << (7 - (i % 8)))) ? 1 : 0;
+        keyb[i] = (key2[i / 8] & (1 << (7 - (i % 8)))) ? 1 : 0;
+        outb[i] = 0;
     }
 
     dohash(outb, inb, keyb);
 
     for (i = 0; i < 8; i++) {
-	out[i] = 0;
+        out[i] = 0;
     }
 
     for (i = 0; i < 64; i++) {
-	if (outb[i])
-	    out[i / 8] |= (1 << (7 - (i % 8)));
+        if (outb[i])
+            out[i / 8] |= (1 << (7 - (i % 8)));
     }
 }
 
 void
 E_P16(unsigned char *p14, unsigned char *p16)
 {
-    unsigned char sp8[8] =
-    {0x4b, 0x47, 0x53, 0x21, 0x40, 0x23, 0x24, 0x25};
+    unsigned char sp8[8] = {0x4b, 0x47, 0x53, 0x21, 0x40, 0x23, 0x24, 0x25};
     smbhash(p16, sp8, p14);
     smbhash(p16 + 8, sp8, p14 + 7);
 }
@@ -1,20 +1,20 @@
-/* 
+/*
  * Unix SMB/Netbios implementation.
  * Version 1.9.
  * SMB parameters and setup
  * Copyright (C) Andrew Tridgell 1992-1997
  * Modified by Jeremy Allison 1995.
- * 
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
@@ -50,7 +50,7 @@ static void strupper(char *s);
 
 /*
  * This implements the X/Open SMB password encryption
- * It takes a password, a 8 byte "crypt key" and puts 24 bytes of 
+ * It takes a password, a 8 byte "crypt key" and puts 24 bytes of
  * encrypted password into p24 */
 void
 SMBencrypt(uchar * passwd, uchar * c8, uchar * p24)
@@ -72,13 +72,13 @@ _my_wcslen(int16 * str)
 {
     int len = 0;
     while (*str++ != 0)
-	len++;
+        len++;
     return len;
 }
 
 /*
  * Convert a string into an NT UNICODE string.
- * Note that regardless of processor type 
+ * Note that regardless of processor type
  * this must be in intel (little-endian)
  * format.
  */
@@ -90,17 +90,17 @@ _my_mbstowcs(int16 * dst, uchar * src, int len)
     int16 val;
 
     for (i = 0; i < len; i++) {
-	val = *src;
-	SSVAL(dst, 0, val);
-	dst++;
-	src++;
-	if (val == 0)
-	    break;
+        val = *src;
+        SSVAL(dst, 0, val);
+        dst++;
+        src++;
+        if (val == 0)
+            break;
     }
     return i;
 }
 
-/* 
+/*
  * Creates the MD4 Hash of the users password in NT UNICODE.
  */
 
@@ -113,7 +113,7 @@ E_md4hash(uchar * passwd, uchar * p16)
     /* Password cannot be longer than 128 characters */
     len = strlen((char *) passwd);
     if (len > 128)
-	len = 128;
+        len = 128;
     /* Password must be converted to NT unicode */
     _my_mbstowcs(wpwd, passwd, len);
     wpwd[len] = 0;		/* Ensure string is null terminated */
@@ -169,10 +169,10 @@ StrnCpy(char *dest, char *src, int n)
 {
     char *d = dest;
     if (!dest)
-	return (NULL);
+        return (NULL);
     if (!src) {
-	*dest = 0;
-	return (dest);
+        *dest = 0;
+        return (dest);
     }
     while (n-- && (*d++ = *src++));
     *d = 0;
@@ -185,26 +185,26 @@ strupper(char *s)
     while (*s) {
 #if UNUSED_CODE
 #if !defined(KANJI_WIN95_COMPATIBILITY)
-	if (lp_client_code_page() == KANJI_CODEPAGE) {
-
-	    if (is_shift_jis(*s)) {
-		if (is_sj_lower(s[0], s[1]))
-		    s[1] = sj_toupper2(s[1]);
-		s += 2;
-	    } else if (is_kana(*s)) {
-		s++;
-	    } else {
-		if (islower((int)(unsigned char)*s))
-		    *s = toupper((int)(unsigned char)*s);
-		s++;
-	    }
-	} else
+        if (lp_client_code_page() == KANJI_CODEPAGE) {
+
+            if (is_shift_jis(*s)) {
+                if (is_sj_lower(s[0], s[1]))
+                    s[1] = sj_toupper2(s[1]);
+                s += 2;
+            } else if (is_kana(*s)) {
+                s++;
+            } else {
+                if (islower((int)(unsigned char)*s))
+                    *s = toupper((int)(unsigned char)*s);
+                s++;
+            }
+        } else
 #endif /* KANJI_WIN95_COMPATIBILITY */
 #endif /* UNUSED_CODE */
-	{
-	    if (islower((int)(unsigned char)*s))
-		*s = toupper((int)(unsigned char)*s);
-	    s++;
-	}
+        {
+            if (islower((int)(unsigned char)*s))
+                *s = toupper((int)(unsigned char)*s);
+            s++;
+        }
     }
 }
@@ -1,23 +1,23 @@
 /* UNIX SMBlib NetBIOS implementation
- * 
+ *
  * Version 1.0
  * SMBlib Common Defines
- * 
+ *
  * Copyright (C) Richard Sharpe 1996
- * 
+ *
  */
 
 /*
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
@@ -1,23 +1,23 @@
 /* UNIX SMBlib NetBIOS implementation
- * 
+ *
  * Version 1.0
  * SMBlib private Defines
- * 
+ *
  * Copyright (C) Richard Sharpe 1996
- * 
+ *
  */
 
 /*
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
@@ -282,8 +282,8 @@ typedef unsigned char UCHAR;
 #define SMB_openx_axr_offset    34	/* Reserved                */
 #define SMB_openx_axo_offset    35	/* offset of next wct      */
 #define SMB_openx_flg_offset    37	/* Flags, bit0 = need more info */
-					  /* bit1 = exclusive oplock */
-					  /* bit2 = batch oplock     */
+/* bit1 = exclusive oplock */
+/* bit2 = batch oplock     */
 #define SMB_openx_mod_offset    39	/* mode to open with       */
 #define SMB_openx_atr_offset    41	/* search attributes       */
 #define SMB_openx_fat_offset    43	/* File attributes         */
@@ -378,7 +378,7 @@ typedef unsigned char UCHAR;
 #define SMB_ssetpLM_buf_offset  55
 
 #define SMB_ssetpNTLM_mbs_offset 37	/* Max Buffer Size for NT LM 0.12  */
-					  /* and above                       */
+/* and above                       */
 #define SMB_ssetpNTLM_mmc_offset 39	/* Max Multiplex count             */
 #define SMB_ssetpNTLM_vcn_offset 41	/* VC Number                       */
 #define SMB_ssetpNTLM_snk_offset 43	/* Session key                     */
@@ -505,12 +505,12 @@ extern int SMB_Types[];
 typedef struct SMB_Status {
 
     union {
-	struct {
-	    unsigned char ErrorClass;
-	    unsigned char Reserved;
-	    unsigned short Error;
-	} DosError;
-	unsigned int NtStatus;
+        struct {
+            unsigned char ErrorClass;
+            unsigned char Reserved;
+            unsigned short Error;
+        } DosError;
+        unsigned int NtStatus;
     } status;
 } SMB_Status;
 
@@ -1,23 +1,23 @@
 /* UNIX SMBlib NetBIOS implementation
- * 
+ *
  * Version 1.0
  * SMBlib Utility Routines
- * 
+ *
  * Copyright (C) Richard Sharpe 1996
- * 
+ *
  */
 
 /*
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
@@ -35,35 +35,35 @@
 #include <string.h>
 #include <unistd.h>
 
-const char *SMB_Prots[] =
-{"PC NETWORK PROGRAM 1.0",
-    "MICROSOFT NETWORKS 1.03",
-    "MICROSOFT NETWORKS 3.0",
-    "DOS LANMAN1.0",
-    "LANMAN1.0",
-    "DOS LM1.2X002",
-    "LM1.2X002",
-    "DOS LANMAN2.1",
-    "LANMAN2.1",
-    "Samba",
-    "NT LM 0.12",
-    "NT LANMAN 1.0",
-    NULL};
-
-int SMB_Types[] =
-{SMB_P_Core,
-    SMB_P_CorePlus,
-    SMB_P_DOSLanMan1,
-    SMB_P_DOSLanMan1,
-    SMB_P_LanMan1,
-    SMB_P_DOSLanMan2,
-    SMB_P_LanMan2,
-    SMB_P_LanMan2_1,
-    SMB_P_LanMan2_1,
-    SMB_P_NT1,
-    SMB_P_NT1,
-    SMB_P_NT1,
-    -1};
+const char *SMB_Prots[] = {"PC NETWORK PROGRAM 1.0",
+                           "MICROSOFT NETWORKS 1.03",
+                           "MICROSOFT NETWORKS 3.0",
+                           "DOS LANMAN1.0",
+                           "LANMAN1.0",
+                           "DOS LM1.2X002",
+                           "LM1.2X002",
+                           "DOS LANMAN2.1",
+                           "LANMAN2.1",
+                           "Samba",
+                           "NT LM 0.12",
+                           "NT LANMAN 1.0",
+                           NULL
+                          };
+
+int SMB_Types[] = {SMB_P_Core,
+                   SMB_P_CorePlus,
+                   SMB_P_DOSLanMan1,
+                   SMB_P_DOSLanMan1,
+                   SMB_P_LanMan1,
+                   SMB_P_DOSLanMan2,
+                   SMB_P_LanMan2,
+                   SMB_P_LanMan2_1,
+                   SMB_P_LanMan2_1,
+                   SMB_P_NT1,
+                   SMB_P_NT1,
+                   SMB_P_NT1,
+                   -1
+                  };
 
 /* Figure out what protocol was accepted, given the list of dialect strings */
 /* We offered, and the index back from the server. We allow for a user      */
@@ -76,22 +76,22 @@ SMB_Figure_Protocol(const char *dialects[], int prot_index)
 
     if (dialects == SMB_Prots) {	/* The jobs is easy, just index into table */
 
-	return (SMB_Types[prot_index]);
+        return (SMB_Types[prot_index]);
     } else {			/* Search through SMB_Prots looking for a match */
 
-	for (i = 0; SMB_Prots[i] != NULL; i++) {
+        for (i = 0; SMB_Prots[i] != NULL; i++) {
 
-	    if (strcmp(dialects[prot_index], SMB_Prots[i]) == 0) {	/* A match */
+            if (strcmp(dialects[prot_index], SMB_Prots[i]) == 0) {	/* A match */
 
-		return (SMB_Types[i]);
+                return (SMB_Types[i]);
 
-	    }
-	}
+            }
+        }
 
-	/* If we got here, then we are in trouble, because the protocol was not */
-	/* One we understand ...                                                */
+        /* If we got here, then we are in trouble, because the protocol was not */
+        /* One we understand ...                                                */
 
-	return (SMB_P_Unknown);
+        return (SMB_P_Unknown);
 
     }
 
@@ -115,7 +115,7 @@ SMB_Negotiate(SMB_Handle_Type Con_Handle, const char *Prots[])
 
     for (i = 0; Prots[i] != NULL; i++) {
 
-	prots_len = prots_len + strlen(Prots[i]) + 2;	/* Account for null etc */
+        prots_len = prots_len + strlen(Prots[i]) + 2;	/* Account for null etc */
 
     }
 
@@ -129,20 +129,20 @@ SMB_Negotiate(SMB_Handle_Type Con_Handle, const char *Prots[])
 
     if (pkt_len < (SMB_hdr_wct_offset + (19 * 2) + 40)) {
 
-	alloc_len = SMB_hdr_wct_offset + (19 * 2) + 40;
+        alloc_len = SMB_hdr_wct_offset + (19 * 2) + 40;
 
     } else {
 
-	alloc_len = pkt_len;
+        alloc_len = pkt_len;
 
     }
 
     pkt = (struct RFCNB_Pkt *) RFCNB_Alloc_Pkt(alloc_len);
 
     if (pkt == NULL) {
 
-	SMBlib_errno = SMBlibE_NoSpace;
-	return (SMBlibE_BAD);
+        SMBlib_errno = SMBlibE_NoSpace;
+        return (SMBlibE_BAD);
 
     }
     /* Now plug in the bits we need */
@@ -164,9 +164,9 @@ SMB_Negotiate(SMB_Handle_Type Con_Handle, const char *Prots[])
 
     for (i = 0; Prots[i] != NULL; i++) {
 
-	*p = SMBdialectID;
-	strcpy(p + 1, Prots[i]);
-	p = p + strlen(Prots[i]) + 2;	/* Adjust len of p for null plus dialectID */
+        *p = SMBdialectID;
+        strcpy(p + 1, Prots[i]);
+        p = p + strlen(Prots[i]) + 2;	/* Adjust len of p for null plus dialectID */
 
     }
 
@@ -176,50 +176,50 @@ SMB_Negotiate(SMB_Handle_Type Con_Handle, const char *Prots[])
 
 
 #ifdef DEBUG
-	fprintf(stderr, "Error sending negotiate protocol\n");
+        fprintf(stderr, "Error sending negotiate protocol\n");
 #endif
 
-	RFCNB_Free_Pkt(pkt);
-	SMBlib_errno = -SMBlibE_SendFailed;	/* Failed, check lower layer errno */
-	return (SMBlibE_BAD);
+        RFCNB_Free_Pkt(pkt);
+        SMBlib_errno = -SMBlibE_SendFailed;	/* Failed, check lower layer errno */
+        return (SMBlibE_BAD);
 
     }
     /* Now get the response ... */
 
     if (RFCNB_Recv(Con_Handle->Trans_Connect, pkt, alloc_len) < 0) {
 
 #ifdef DEBUG
-	fprintf(stderr, "Error receiving response to negotiate\n");
+        fprintf(stderr, "Error receiving response to negotiate\n");
 #endif
 
-	RFCNB_Free_Pkt(pkt);
-	SMBlib_errno = -SMBlibE_RecvFailed;	/* Failed, check lower layer errno */
-	return (SMBlibE_BAD);
+        RFCNB_Free_Pkt(pkt);
+        SMBlib_errno = -SMBlibE_RecvFailed;	/* Failed, check lower layer errno */
+        return (SMBlibE_BAD);
 
     }
     if (CVAL(SMB_Hdr(pkt), SMB_hdr_rcls_offset) != SMBC_SUCCESS) {	/* Process error */
 
 #ifdef DEBUG
-	fprintf(stderr, "SMB_Negotiate failed with errorclass = %i, Error Code = %i\n",
-	    CVAL(SMB_Hdr(pkt), SMB_hdr_rcls_offset),
-	    SVAL(SMB_Hdr(pkt), SMB_hdr_err_offset));
+        fprintf(stderr, "SMB_Negotiate failed with errorclass = %i, Error Code = %i\n",
+                CVAL(SMB_Hdr(pkt), SMB_hdr_rcls_offset),
+                SVAL(SMB_Hdr(pkt), SMB_hdr_err_offset));
 #endif
 
-	SMBlib_SMB_Error = IVAL(SMB_Hdr(pkt), SMB_hdr_rcls_offset);
-	RFCNB_Free_Pkt(pkt);
-	SMBlib_errno = SMBlibE_Remote;
-	return (SMBlibE_BAD);
+        SMBlib_SMB_Error = IVAL(SMB_Hdr(pkt), SMB_hdr_rcls_offset);
+        RFCNB_Free_Pkt(pkt);
+        SMBlib_errno = SMBlibE_Remote;
+        return (SMBlibE_BAD);
 
     }
     if (SVAL(SMB_Hdr(pkt), SMB_negrCP_idx_offset) == 0xFFFF) {
 
 #ifdef DEBUG
-	fprintf(stderr, "None of our protocols was accepted ... ");
+        fprintf(stderr, "None of our protocols was accepted ... ");
 #endif
 
-	RFCNB_Free_Pkt(pkt);
-	SMBlib_errno = SMBlibE_NegNoProt;
-	return (SMBlibE_BAD);
+        RFCNB_Free_Pkt(pkt);
+        SMBlib_errno = SMBlibE_NegNoProt;
+        return (SMBlibE_BAD);
 
     }
     /* Now, unpack the info from the response, if any and evaluate the proto */
@@ -230,70 +230,70 @@ SMB_Negotiate(SMB_Handle_Type Con_Handle, const char *Prots[])
 
     if (Con_Handle->protocol == SMB_P_Unknown) {	/* No good ... */
 
-	RFCNB_Free_Pkt(pkt);
-	SMBlib_errno = SMBlibE_ProtUnknown;
-	return (SMBlibE_BAD);
+        RFCNB_Free_Pkt(pkt);
+        SMBlib_errno = SMBlibE_ProtUnknown;
+        return (SMBlibE_BAD);
 
     }
     switch (CVAL(SMB_Hdr(pkt), SMB_hdr_wct_offset)) {
 
     case 0x01:			/* No more info ... */
 
-	break;
+        break;
 
     case 13:			/* Up to and including LanMan 2.1 */
 
-	Con_Handle->Security = SVAL(SMB_Hdr(pkt), SMB_negrLM_sec_offset);
-	Con_Handle->encrypt_passwords = ((Con_Handle->Security & SMB_sec_encrypt_mask) != 0x00);
-	Con_Handle->Security = Con_Handle->Security & SMB_sec_user_mask;
+        Con_Handle->Security = SVAL(SMB_Hdr(pkt), SMB_negrLM_sec_offset);
+        Con_Handle->encrypt_passwords = ((Con_Handle->Security & SMB_sec_encrypt_mask) != 0x00);
+        Con_Handle->Security = Con_Handle->Security & SMB_sec_user_mask;
 
-	Con_Handle->max_xmit = SVAL(SMB_Hdr(pkt), SMB_negrLM_mbs_offset);
-	Con_Handle->MaxMPX = SVAL(SMB_Hdr(pkt), SMB_negrLM_mmc_offset);
-	Con_Handle->MaxVC = SVAL(SMB_Hdr(pkt), SMB_negrLM_mnv_offset);
-	Con_Handle->Raw_Support = SVAL(SMB_Hdr(pkt), SMB_negrLM_rm_offset);
-	Con_Handle->SessionKey = IVAL(SMB_Hdr(pkt), SMB_negrLM_sk_offset);
-	Con_Handle->SvrTZ = SVAL(SMB_Hdr(pkt), SMB_negrLM_stz_offset);
-	Con_Handle->Encrypt_Key_Len = SVAL(SMB_Hdr(pkt), SMB_negrLM_ekl_offset);
+        Con_Handle->max_xmit = SVAL(SMB_Hdr(pkt), SMB_negrLM_mbs_offset);
+        Con_Handle->MaxMPX = SVAL(SMB_Hdr(pkt), SMB_negrLM_mmc_offset);
+        Con_Handle->MaxVC = SVAL(SMB_Hdr(pkt), SMB_negrLM_mnv_offset);
+        Con_Handle->Raw_Support = SVAL(SMB_Hdr(pkt), SMB_negrLM_rm_offset);
+        Con_Handle->SessionKey = IVAL(SMB_Hdr(pkt), SMB_negrLM_sk_offset);
+        Con_Handle->SvrTZ = SVAL(SMB_Hdr(pkt), SMB_negrLM_stz_offset);
+        Con_Handle->Encrypt_Key_Len = SVAL(SMB_Hdr(pkt), SMB_negrLM_ekl_offset);
 
-	p = (SMB_Hdr(pkt) + SMB_negrLM_buf_offset);
-	memcpy(Con_Handle->Encrypt_Key, p, 8);
+        p = (SMB_Hdr(pkt) + SMB_negrLM_buf_offset);
+        memcpy(Con_Handle->Encrypt_Key, p, 8);
 
-	p = (SMB_Hdr(pkt) + SMB_negrLM_buf_offset + Con_Handle->Encrypt_Key_Len);
+        p = (SMB_Hdr(pkt) + SMB_negrLM_buf_offset + Con_Handle->Encrypt_Key_Len);
 
-	strncpy(p, Con_Handle->Svr_PDom, sizeof(Con_Handle->Svr_PDom) - 1);
+        strncpy(p, Con_Handle->Svr_PDom, sizeof(Con_Handle->Svr_PDom) - 1);
 
-	break;
+        break;
 
     case 17:			/* NT LM 0.12 and LN LM 1.0 */
 
-	Con_Handle->Security = SVAL(SMB_Hdr(pkt), SMB_negrNTLM_sec_offset);
-	Con_Handle->encrypt_passwords = ((Con_Handle->Security & SMB_sec_encrypt_mask) != 0x00);
-	Con_Handle->Security = Con_Handle->Security & SMB_sec_user_mask;
+        Con_Handle->Security = SVAL(SMB_Hdr(pkt), SMB_negrNTLM_sec_offset);
+        Con_Handle->encrypt_passwords = ((Con_Handle->Security & SMB_sec_encrypt_mask) != 0x00);
+        Con_Handle->Security = Con_Handle->Security & SMB_sec_user_mask;
 
-	Con_Handle->max_xmit = IVAL(SMB_Hdr(pkt), SMB_negrNTLM_mbs_offset);
-	Con_Handle->MaxMPX = SVAL(SMB_Hdr(pkt), SMB_negrNTLM_mmc_offset);
-	Con_Handle->MaxVC = SVAL(SMB_Hdr(pkt), SMB_negrNTLM_mnv_offset);
-	Con_Handle->MaxRaw = IVAL(SMB_Hdr(pkt), SMB_negrNTLM_mrs_offset);
-	Con_Handle->SessionKey = IVAL(SMB_Hdr(pkt), SMB_negrNTLM_sk_offset);
-	Con_Handle->SvrTZ = SVAL(SMB_Hdr(pkt), SMB_negrNTLM_stz_offset);
-	Con_Handle->Encrypt_Key_Len = CVAL(SMB_Hdr(pkt), SMB_negrNTLM_ekl_offset);
+        Con_Handle->max_xmit = IVAL(SMB_Hdr(pkt), SMB_negrNTLM_mbs_offset);
+        Con_Handle->MaxMPX = SVAL(SMB_Hdr(pkt), SMB_negrNTLM_mmc_offset);
+        Con_Handle->MaxVC = SVAL(SMB_Hdr(pkt), SMB_negrNTLM_mnv_offset);
+        Con_Handle->MaxRaw = IVAL(SMB_Hdr(pkt), SMB_negrNTLM_mrs_offset);
+        Con_Handle->SessionKey = IVAL(SMB_Hdr(pkt), SMB_negrNTLM_sk_offset);
+        Con_Handle->SvrTZ = SVAL(SMB_Hdr(pkt), SMB_negrNTLM_stz_offset);
+        Con_Handle->Encrypt_Key_Len = CVAL(SMB_Hdr(pkt), SMB_negrNTLM_ekl_offset);
 
-	p = (SMB_Hdr(pkt) + SMB_negrNTLM_buf_offset);
-	memcpy(Con_Handle->Encrypt_Key, p, 8);
-	p = (SMB_Hdr(pkt) + SMB_negrNTLM_buf_offset + Con_Handle->Encrypt_Key_Len);
+        p = (SMB_Hdr(pkt) + SMB_negrNTLM_buf_offset);
+        memcpy(Con_Handle->Encrypt_Key, p, 8);
+        p = (SMB_Hdr(pkt) + SMB_negrNTLM_buf_offset + Con_Handle->Encrypt_Key_Len);
 
-	strncpy(p, Con_Handle->Svr_PDom, sizeof(Con_Handle->Svr_PDom) - 1);
+        strncpy(p, Con_Handle->Svr_PDom, sizeof(Con_Handle->Svr_PDom) - 1);
 
-	break;
+        break;
 
     default:
 
 #ifdef DEBUG
-	fprintf(stderr, "Unknown NegProt response format ... Ignored\n");
-	fprintf(stderr, "  wct = %i\n", CVAL(SMB_Hdr(pkt), SMB_hdr_wct_offset));
+        fprintf(stderr, "Unknown NegProt response format ... Ignored\n");
+        fprintf(stderr, "  wct = %i\n", CVAL(SMB_Hdr(pkt), SMB_hdr_wct_offset));
 #endif
 
-	break;
+        break;
     }
 
 #ifdef DEBUG
@@ -313,13 +313,13 @@ SMB_Get_My_Name(char *name, int len)
 
     if (gethostname(name, len) < 0) {	/* Error getting name */
 
-	strncpy(name, "unknown", len);
+        strncpy(name, "unknown", len);
 
-	/* Should check the error */
+        /* Should check the error */
 
 #ifdef DEBUG
-	fprintf(stderr, "gethostname in SMB_Get_My_Name returned error:");
-	perror("");
+        fprintf(stderr, "gethostname in SMB_Get_My_Name returned error:");
+        perror("");
 #endif
 
     }
@@ -332,10 +332,10 @@ SMB_Get_My_Name(char *name, int len)
 
 SMB_Tree_Handle
 SMB_TreeConnect(SMB_Handle_Type Con_Handle,
-    SMB_Tree_Handle Tree_Handle,
-    char *path,
-    char *password,
-    const char *device)
+                SMB_Tree_Handle Tree_Handle,
+                char *path,
+                char *password,
+                const char *device)
 {
     struct RFCNB_Pkt *pkt;
     int param_len, pkt_len;
@@ -347,11 +347,11 @@ SMB_TreeConnect(SMB_Handle_Type Con_Handle,
     if ((path == NULL) | (password == NULL) | (device == NULL)) {
 
 #ifdef DEBUG
-	fprintf(stderr, "Bad parameter passed to SMB_TreeConnect\n");
+        fprintf(stderr, "Bad parameter passed to SMB_TreeConnect\n");
 #endif
 
-	SMBlib_errno = SMBlibE_BadParam;
-	return (NULL);
+        SMBlib_errno = SMBlibE_BadParam;
+        return (NULL);
 
     }
     /* The + 2 is because of the \0 and the marker ...                    */
@@ -367,26 +367,26 @@ SMB_TreeConnect(SMB_Handle_Type Con_Handle,
 
     if (pkt == NULL) {
 
-	SMBlib_errno = SMBlibE_NoSpace;
-	return (NULL);		/* Should handle the error */
+        SMBlib_errno = SMBlibE_NoSpace;
+        return (NULL);		/* Should handle the error */
 
     }
     /* Now allocate a tree for this to go into ... */
 
     if (Tree_Handle == NULL) {
 
-	tree = (SMB_Tree_Handle) malloc(sizeof(struct SMB_Tree_Structure));
+        tree = (SMB_Tree_Handle) malloc(sizeof(struct SMB_Tree_Structure));
 
-	if (tree == NULL) {
+        if (tree == NULL) {
 
-	    RFCNB_Free_Pkt(pkt);
-	    SMBlib_errno = SMBlibE_NoSpace;
-	    return (NULL);
+            RFCNB_Free_Pkt(pkt);
+            SMBlib_errno = SMBlibE_NoSpace;
+            return (NULL);
 
-	}
+        }
     } else {
 
-	tree = Tree_Handle;
+        tree = Tree_Handle;
 
     }
 
@@ -425,69 +425,69 @@ SMB_TreeConnect(SMB_Handle_Type Con_Handle,
     if (RFCNB_Send(Con_Handle->Trans_Connect, pkt, pkt_len) < 0) {
 
 #ifdef DEBUG
-	fprintf(stderr, "Error sending TCon request\n");
+        fprintf(stderr, "Error sending TCon request\n");
 #endif
 
-	if (Tree_Handle == NULL)
-	    free(tree);
-	RFCNB_Free_Pkt(pkt);
-	SMBlib_errno = -SMBlibE_SendFailed;
-	return (NULL);
+        if (Tree_Handle == NULL)
+            free(tree);
+        RFCNB_Free_Pkt(pkt);
+        SMBlib_errno = -SMBlibE_SendFailed;
+        return (NULL);
 
     }
     /* Now get the response ... */
 
     if (RFCNB_Recv(Con_Handle->Trans_Connect, pkt, pkt_len) < 0) {
 
 #ifdef DEBUG
-	fprintf(stderr, "Error receiving response to TCon\n");
+        fprintf(stderr, "Error receiving response to TCon\n");
 #endif
 
-	if (Tree_Handle == NULL)
-	    free(tree);
-	RFCNB_Free_Pkt(pkt);
-	SMBlib_errno = -SMBlibE_RecvFailed;
-	return (NULL);
+        if (Tree_Handle == NULL)
+            free(tree);
+        RFCNB_Free_Pkt(pkt);
+        SMBlib_errno = -SMBlibE_RecvFailed;
+        return (NULL);
 
     }
     /* Check out the response type ... */
 
     if (CVAL(SMB_Hdr(pkt), SMB_hdr_rcls_offset) != SMBC_SUCCESS) {	/* Process error */
 
 #ifdef DEBUG
-	fprintf(stderr, "SMB_TCon failed with errorclass = %i, Error Code = %i\n",
-	    CVAL(SMB_Hdr(pkt), SMB_hdr_rcls_offset),
-	    SVAL(SMB_Hdr(pkt), SMB_hdr_err_offset));
+        fprintf(stderr, "SMB_TCon failed with errorclass = %i, Error Code = %i\n",
+                CVAL(SMB_Hdr(pkt), SMB_hdr_rcls_offset),
+                SVAL(SMB_Hdr(pkt), SMB_hdr_err_offset));
 #endif
 
-	if (Tree_Handle == NULL)
-	    free(tree);
-	SMBlib_SMB_Error = IVAL(SMB_Hdr(pkt), SMB_hdr_rcls_offset);
-	RFCNB_Free_Pkt(pkt);
-	SMBlib_errno = SMBlibE_Remote;
-	return (NULL);
+        if (Tree_Handle == NULL)
+            free(tree);
+        SMBlib_SMB_Error = IVAL(SMB_Hdr(pkt), SMB_hdr_rcls_offset);
+        RFCNB_Free_Pkt(pkt);
+        SMBlib_errno = SMBlibE_Remote;
+        return (NULL);
 
     }
     tree->tid = SVAL(SMB_Hdr(pkt), SMB_tconr_tid_offset);
     tree->mbs = SVAL(SMB_Hdr(pkt), SMB_tconr_mbs_offset);
 
 #ifdef DEBUG
     fprintf(stderr, "TConn succeeded, with TID=%i, Max Xmit=%i\n",
-	tree->tid, tree->mbs);
+            tree->tid, tree->mbs);
 #endif
 
     /* Now link the Tree to the Server Structure ... */
 
     if (Con_Handle->first_tree == NULL) {
 
-	Con_Handle->first_tree = tree;
-	Con_Handle->last_tree = tree;
+        Con_Handle->first_tree = tree;
+        Con_Handle->last_tree = tree;
 
     } else {
 
-	Con_Handle->last_tree->next = tree;
-	tree->prev = Con_Handle->last_tree;
-	Con_Handle->last_tree = tree;
+        Con_Handle->last_tree->next = tree;
+        tree->prev = Con_Handle->last_tree;
+        Con_Handle->last_tree = tree;
 
     }
 
@@ -521,8 +521,7 @@ SMB_Get_Last_SMB_Err()
 
 /* Keep this table in sync with the message codes in smblib-common.h */
 
-static const char *SMBlib_Error_Messages[] =
-{
+static const char *SMBlib_Error_Messages[] = {
 
     "Request completed sucessfully.",
     "Server returned a non-zero SMB Error Class and Code.",
@@ -537,41 +536,42 @@ static const char *SMBlib_Error_Messages[] =
     "The logon request failed, but you were logged in as guest.",
     "The attempt to call the remote server failed. See protocol error info.",
     "The protocol dialect specified in a NegProt and accepted by the server is unknown.",
-  /* This next one simplifies error handling */
+    /* This next one simplifies error handling */
     "No such error code.",
-    NULL};
+    NULL
+};
 
 void
 SMB_Get_Error_Msg(int msg, char *msgbuf, int len)
 {
 
     if (msg >= 0) {
 
-	strncpy(msgbuf,
-	    SMBlib_Error_Messages[msg > SMBlibE_NoSuchMsg ? SMBlibE_NoSuchMsg : msg],
-	    len - 1);
-	msgbuf[len - 1] = 0;	/* Make sure it is a string */
+        strncpy(msgbuf,
+                SMBlib_Error_Messages[msg > SMBlibE_NoSuchMsg ? SMBlibE_NoSuchMsg : msg],
+                len - 1);
+        msgbuf[len - 1] = 0;	/* Make sure it is a string */
     } else {			/* Add the lower layer message ... */
 
-	char prot_msg[1024];
+        char prot_msg[1024];
 
-	msg = -msg;		/* Make it positive */
+        msg = -msg;		/* Make it positive */
 
-	strncpy(msgbuf,
-	    SMBlib_Error_Messages[msg > SMBlibE_NoSuchMsg ? SMBlibE_NoSuchMsg : msg],
-	    len - 1);
+        strncpy(msgbuf,
+                SMBlib_Error_Messages[msg > SMBlibE_NoSuchMsg ? SMBlibE_NoSuchMsg : msg],
+                len - 1);
 
-	msgbuf[len - 1] = 0;	/* make sure it is a string */
+        msgbuf[len - 1] = 0;	/* make sure it is a string */
 
-	if (strlen(msgbuf) < len) {	/* If there is space, put rest in */
+        if (strlen(msgbuf) < len) {	/* If there is space, put rest in */
 
-	    strncat(msgbuf, "\n\t", len - strlen(msgbuf));
+            strncat(msgbuf, "\n\t", len - strlen(msgbuf));
 
-	    RFCNB_Get_Error(prot_msg, sizeof(prot_msg) - 1);
+            RFCNB_Get_Error(prot_msg, sizeof(prot_msg) - 1);
 
-	    strncat(msgbuf, prot_msg, len - strlen(msgbuf));
+            strncat(msgbuf, prot_msg, len - strlen(msgbuf));
 
-	}
+        }
     }
 
 }
@@ -1,23 +1,23 @@
 /* UNIX SMBlib NetBIOS implementation
- * 
+ *
  * Version 1.0
  * SMBlib Routines
- * 
+ *
  * Copyright (C) Richard Sharpe 1996
- * 
+ *
  */
 
 /*
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
@@ -53,7 +53,7 @@ SMB_Init(void)
 
     signal(SIGPIPE, SIG_IGN);	/* Ignore these ... */
 
-/* If SMBLIB_Instrument is defines, turn on the instrumentation stuff */
+    /* If SMBLIB_Instrument is defines, turn on the instrumentation stuff */
 #ifdef SMBLIB_INSTRUMENT
 
     SMBlib_Instrument_Init();
@@ -81,7 +81,7 @@ SMB_Create_Con_Handle(void)
 
 SMB_Handle_Type
 SMB_Connect_Server(SMB_Handle_Type Con_Handle,
-    char *server, char *NTdomain)
+                   char *server, char *NTdomain)
 {
     SMB_Handle_Type con;
     char called[80], calling[80], *address;
@@ -93,12 +93,12 @@ SMB_Connect_Server(SMB_Handle_Type Con_Handle,
 
     if (Con_Handle == NULL) {
 
-	if ((con = (struct SMB_Connect_Def *) malloc(sizeof(struct SMB_Connect_Def))) == NULL) {
+        if ((con = (struct SMB_Connect_Def *) malloc(sizeof(struct SMB_Connect_Def))) == NULL) {
 
 
-	    SMBlib_errno = SMBlibE_NoSpace;
-	    return NULL;
-	}
+            SMBlib_errno = SMBlibE_NoSpace;
+            return NULL;
+        }
     }
     /* Init some things ... */
 
@@ -128,35 +128,35 @@ SMB_Connect_Server(SMB_Handle_Type Con_Handle,
      * service we are going to call, sine some servers want it in uppercase */
 
     for (i = 0; i < strlen(server); i++)
-	called[i] = xtoupper(server[i]);
+        called[i] = xtoupper(server[i]);
 
     called[strlen(server)] = 0;	/* Make it a string */
 
     for (i = 0; i < strlen(con->myname); i++)
-	calling[i] = xtoupper(con->myname[i]);
+        calling[i] = xtoupper(con->myname[i]);
 
     calling[strlen(con->myname)] = 0;	/* Make it a string */
 
     if (strcmp(con->address, "") == 0)
-	address = con->desthost;
+        address = con->desthost;
     else
-	address = con->address;
+        address = con->address;
 
     con->Trans_Connect = RFCNB_Call(called,
-	calling,
-	address,		/* Protocol specific */
-	con->port);
+                                    calling,
+                                    address,		/* Protocol specific */
+                                    con->port);
 
     /* Did we get one? */
 
     if (con->Trans_Connect == NULL) {
 
-	if (Con_Handle == NULL) {
-	    Con_Handle = NULL;
-	    free(con);
-	}
-	SMBlib_errno = -SMBlibE_CallFailed;
-	return NULL;
+        if (Con_Handle == NULL) {
+            Con_Handle = NULL;
+            free(con);
+        }
+        SMBlib_errno = -SMBlibE_CallFailed;
+        return NULL;
 
     }
     return (con);
@@ -167,17 +167,17 @@ SMB_Connect_Server(SMB_Handle_Type Con_Handle,
 /* If Con_Handle == NULL then create a handle and connect, otherwise  */
 /* use the handle passed                                              */
 
-const char *SMB_Prots_Restrict[] =
-{"PC NETWORK PROGRAM 1.0",
-    NULL};
+const char *SMB_Prots_Restrict[] = {"PC NETWORK PROGRAM 1.0",
+                                    NULL
+                                   };
 
 
 SMB_Handle_Type
 SMB_Connect(SMB_Handle_Type Con_Handle,
-    SMB_Tree_Handle * tree,
-    char *service,
-    char *username,
-    char *password)
+            SMB_Tree_Handle * tree,
+            char *service,
+            char *username,
+            char *password)
 {
     SMB_Handle_Type con;
     char *host, *address;
@@ -190,11 +190,11 @@ SMB_Connect(SMB_Handle_Type Con_Handle,
 
     if (Con_Handle == NULL) {
 
-	if ((con = (struct SMB_Connect_Def *) malloc(sizeof(struct SMB_Connect_Def))) == NULL) {
+        if ((con = (struct SMB_Connect_Def *) malloc(sizeof(struct SMB_Connect_Def))) == NULL) {
 
-	    SMBlib_errno = SMBlibE_NoSpace;
-	    return NULL;
-	}
+            SMBlib_errno = SMBlibE_NoSpace;
+            return NULL;
+        }
     }
     /* Init some things ... */
 
@@ -230,52 +230,52 @@ SMB_Connect(SMB_Handle_Type Con_Handle,
      * service we are going to call, sine some servers want it in uppercase */
 
     for (i = 0; i < strlen(host); i++)
-	called[i] = xtoupper(host[i]);
+        called[i] = xtoupper(host[i]);
 
     called[strlen(host)] = 0;	/* Make it a string */
 
     for (i = 0; i < strlen(con->myname); i++)
-	calling[i] = xtoupper(con->myname[i]);
+        calling[i] = xtoupper(con->myname[i]);
 
     calling[strlen(con->myname)] = 0;	/* Make it a string */
 
     if (strcmp(con->address, "") == 0)
-	address = con->desthost;
+        address = con->desthost;
     else
-	address = con->address;
+        address = con->address;
 
     con->Trans_Connect = RFCNB_Call(called,
-	calling,
-	address,		/* Protocol specific */
-	con->port);
+                                    calling,
+                                    address,		/* Protocol specific */
+                                    con->port);
 
     /* Did we get one? */
 
     if (con->Trans_Connect == NULL) {
 
-	if (Con_Handle == NULL) {
-	    free(con);
-	    Con_Handle = NULL;
-	}
-	SMBlib_errno = -SMBlibE_CallFailed;
-	return NULL;
+        if (Con_Handle == NULL) {
+            free(con);
+            Con_Handle = NULL;
+        }
+        SMBlib_errno = -SMBlibE_CallFailed;
+        return NULL;
 
     }
     /* Now, negotiate the protocol */
 
     if (SMB_Negotiate(con, SMB_Prots_Restrict) < 0) {
 
-	/* Hmmm what should we do here ... We have a connection, but could not
-	 * negotiate ...                                                      */
+        /* Hmmm what should we do here ... We have a connection, but could not
+         * negotiate ...                                                      */
 
-	return NULL;
+        return NULL;
 
     }
     /* Now connect to the service ... */
 
     if ((*tree = SMB_TreeConnect(con, NULL, service, password, "A:")) == NULL) {
 
-	return NULL;
+        return NULL;
 
     }
     return (con);
@@ -287,7 +287,7 @@ SMB_Connect(SMB_Handle_Type Con_Handle,
 
 int
 SMB_Logon_Server(SMB_Handle_Type Con_Handle, char *UserName,
-    char *PassWord)
+                 char *PassWord)
 {
     struct RFCNB_Pkt *pkt;
     int param_len, pkt_len, pass_len;
@@ -299,151 +299,151 @@ SMB_Logon_Server(SMB_Handle_Type Con_Handle, char *UserName,
 
     if (Con_Handle->protocol < SMB_P_LanMan1) {
 
-	SMBlib_errno = SMBlibE_ProtLow;
-	return (SMBlibE_BAD);
+        SMBlib_errno = SMBlibE_ProtLow;
+        return (SMBlibE_BAD);
 
     }
     strcpy(pword, PassWord);
 #ifdef PAM_SMB_ENC_PASS
     if (Con_Handle->encrypt_passwords) {
-	pass_len = 24;
-	SMBencrypt((uchar *) PassWord, (uchar *) Con_Handle->Encrypt_Key, (uchar *) pword);
+        pass_len = 24;
+        SMBencrypt((uchar *) PassWord, (uchar *) Con_Handle->Encrypt_Key, (uchar *) pword);
     } else
 #endif
-	pass_len = strlen(pword);
+        pass_len = strlen(pword);
 
 
     /* Now build the correct structure */
 
     if (Con_Handle->protocol < SMB_P_NT1) {
 
-	param_len = strlen(UserName) + 1 + pass_len + 1 +
-	    strlen(Con_Handle->PDomain) + 1 +
-	    strlen(Con_Handle->OSName) + 1;
+        param_len = strlen(UserName) + 1 + pass_len + 1 +
+                    strlen(Con_Handle->PDomain) + 1 +
+                    strlen(Con_Handle->OSName) + 1;
 
-	pkt_len = SMB_ssetpLM_len + param_len;
+        pkt_len = SMB_ssetpLM_len + param_len;
 
-	pkt = (struct RFCNB_Pkt *) RFCNB_Alloc_Pkt(pkt_len);
+        pkt = (struct RFCNB_Pkt *) RFCNB_Alloc_Pkt(pkt_len);
 
-	if (pkt == NULL) {
+        if (pkt == NULL) {
 
-	    SMBlib_errno = SMBlibE_NoSpace;
-	    return (SMBlibE_BAD);	/* Should handle the error */
+            SMBlib_errno = SMBlibE_NoSpace;
+            return (SMBlibE_BAD);	/* Should handle the error */
 
-	}
-	memset(SMB_Hdr(pkt), 0, SMB_ssetpLM_len);
-	SIVAL(SMB_Hdr(pkt), SMB_hdr_idf_offset, SMB_DEF_IDF);	/* Plunk in IDF */
-	*(SMB_Hdr(pkt) + SMB_hdr_com_offset) = SMBsesssetupX;
-	SSVAL(SMB_Hdr(pkt), SMB_hdr_pid_offset, Con_Handle->pid);
-	SSVAL(SMB_Hdr(pkt), SMB_hdr_tid_offset, 0);
-	SSVAL(SMB_Hdr(pkt), SMB_hdr_mid_offset, Con_Handle->mid);
-	SSVAL(SMB_Hdr(pkt), SMB_hdr_uid_offset, Con_Handle->uid);
-	*(SMB_Hdr(pkt) + SMB_hdr_wct_offset) = 10;
-	*(SMB_Hdr(pkt) + SMB_hdr_axc_offset) = 0xFF;	/* No extra command */
-	SSVAL(SMB_Hdr(pkt), SMB_hdr_axo_offset, 0);
+        }
+        memset(SMB_Hdr(pkt), 0, SMB_ssetpLM_len);
+        SIVAL(SMB_Hdr(pkt), SMB_hdr_idf_offset, SMB_DEF_IDF);	/* Plunk in IDF */
+        *(SMB_Hdr(pkt) + SMB_hdr_com_offset) = SMBsesssetupX;
+        SSVAL(SMB_Hdr(pkt), SMB_hdr_pid_offset, Con_Handle->pid);
+        SSVAL(SMB_Hdr(pkt), SMB_hdr_tid_offset, 0);
+        SSVAL(SMB_Hdr(pkt), SMB_hdr_mid_offset, Con_Handle->mid);
+        SSVAL(SMB_Hdr(pkt), SMB_hdr_uid_offset, Con_Handle->uid);
+        *(SMB_Hdr(pkt) + SMB_hdr_wct_offset) = 10;
+        *(SMB_Hdr(pkt) + SMB_hdr_axc_offset) = 0xFF;	/* No extra command */
+        SSVAL(SMB_Hdr(pkt), SMB_hdr_axo_offset, 0);
 
-	SSVAL(SMB_Hdr(pkt), SMB_ssetpLM_mbs_offset, SMBLIB_MAX_XMIT);
-	SSVAL(SMB_Hdr(pkt), SMB_ssetpLM_mmc_offset, 2);
-	SSVAL(SMB_Hdr(pkt), SMB_ssetpLM_vcn_offset, Con_Handle->pid);
-	SIVAL(SMB_Hdr(pkt), SMB_ssetpLM_snk_offset, 0);
-	SSVAL(SMB_Hdr(pkt), SMB_ssetpLM_pwl_offset, pass_len + 1);
-	SIVAL(SMB_Hdr(pkt), SMB_ssetpLM_res_offset, 0);
-	SSVAL(SMB_Hdr(pkt), SMB_ssetpLM_bcc_offset, param_len);
+        SSVAL(SMB_Hdr(pkt), SMB_ssetpLM_mbs_offset, SMBLIB_MAX_XMIT);
+        SSVAL(SMB_Hdr(pkt), SMB_ssetpLM_mmc_offset, 2);
+        SSVAL(SMB_Hdr(pkt), SMB_ssetpLM_vcn_offset, Con_Handle->pid);
+        SIVAL(SMB_Hdr(pkt), SMB_ssetpLM_snk_offset, 0);
+        SSVAL(SMB_Hdr(pkt), SMB_ssetpLM_pwl_offset, pass_len + 1);
+        SIVAL(SMB_Hdr(pkt), SMB_ssetpLM_res_offset, 0);
+        SSVAL(SMB_Hdr(pkt), SMB_ssetpLM_bcc_offset, param_len);
 
-	/* Now copy the param strings in with the right stuff */
+        /* Now copy the param strings in with the right stuff */
 
-	p = (char *) (SMB_Hdr(pkt) + SMB_ssetpLM_buf_offset);
+        p = (char *) (SMB_Hdr(pkt) + SMB_ssetpLM_buf_offset);
 
-	/* Copy  in password, then the rest. Password has a null at end */
+        /* Copy  in password, then the rest. Password has a null at end */
 
-	memcpy(p, pword, pass_len);
+        memcpy(p, pword, pass_len);
 
-	p = p + pass_len + 1;
+        p = p + pass_len + 1;
 
-	strcpy(p, UserName);
-	p = p + strlen(UserName);
-	*p = 0;
+        strcpy(p, UserName);
+        p = p + strlen(UserName);
+        *p = 0;
 
-	p = p + 1;
+        p = p + 1;
 
-	strcpy(p, Con_Handle->PDomain);
-	p = p + strlen(Con_Handle->PDomain);
-	*p = 0;
-	p = p + 1;
+        strcpy(p, Con_Handle->PDomain);
+        p = p + strlen(Con_Handle->PDomain);
+        *p = 0;
+        p = p + 1;
 
-	strcpy(p, Con_Handle->OSName);
-	p = p + strlen(Con_Handle->OSName);
-	*p = 0;
+        strcpy(p, Con_Handle->OSName);
+        p = p + strlen(Con_Handle->OSName);
+        *p = 0;
 
     } else {
 
-	/* We don't admit to UNICODE support ... */
+        /* We don't admit to UNICODE support ... */
 
-	param_len = strlen(UserName) + 1 + pass_len +
-	    strlen(Con_Handle->PDomain) + 1 +
-	    strlen(Con_Handle->OSName) + 1 +
-	    strlen(Con_Handle->LMType) + 1;
+        param_len = strlen(UserName) + 1 + pass_len +
+                    strlen(Con_Handle->PDomain) + 1 +
+                    strlen(Con_Handle->OSName) + 1 +
+                    strlen(Con_Handle->LMType) + 1;
 
-	pkt_len = SMB_ssetpNTLM_len + param_len;
+        pkt_len = SMB_ssetpNTLM_len + param_len;
 
-	pkt = (struct RFCNB_Pkt *) RFCNB_Alloc_Pkt(pkt_len);
+        pkt = (struct RFCNB_Pkt *) RFCNB_Alloc_Pkt(pkt_len);
 
-	if (pkt == NULL) {
+        if (pkt == NULL) {
 
-	    SMBlib_errno = SMBlibE_NoSpace;
-	    return (-1);	/* Should handle the error */
+            SMBlib_errno = SMBlibE_NoSpace;
+            return (-1);	/* Should handle the error */
 
-	}
-	memset(SMB_Hdr(pkt), 0, SMB_ssetpNTLM_len);
-	SIVAL(SMB_Hdr(pkt), SMB_hdr_idf_offset, SMB_DEF_IDF);	/* Plunk in IDF */
-	*(SMB_Hdr(pkt) + SMB_hdr_com_offset) = SMBsesssetupX;
-	SSVAL(SMB_Hdr(pkt), SMB_hdr_pid_offset, Con_Handle->pid);
-	SSVAL(SMB_Hdr(pkt), SMB_hdr_tid_offset, 0);
-	SSVAL(SMB_Hdr(pkt), SMB_hdr_mid_offset, Con_Handle->mid);
-	SSVAL(SMB_Hdr(pkt), SMB_hdr_uid_offset, Con_Handle->uid);
-	*(SMB_Hdr(pkt) + SMB_hdr_wct_offset) = 13;
-	*(SMB_Hdr(pkt) + SMB_hdr_axc_offset) = 0xFF;	/* No extra command */
-	SSVAL(SMB_Hdr(pkt), SMB_hdr_axo_offset, 0);
+        }
+        memset(SMB_Hdr(pkt), 0, SMB_ssetpNTLM_len);
+        SIVAL(SMB_Hdr(pkt), SMB_hdr_idf_offset, SMB_DEF_IDF);	/* Plunk in IDF */
+        *(SMB_Hdr(pkt) + SMB_hdr_com_offset) = SMBsesssetupX;
+        SSVAL(SMB_Hdr(pkt), SMB_hdr_pid_offset, Con_Handle->pid);
+        SSVAL(SMB_Hdr(pkt), SMB_hdr_tid_offset, 0);
+        SSVAL(SMB_Hdr(pkt), SMB_hdr_mid_offset, Con_Handle->mid);
+        SSVAL(SMB_Hdr(pkt), SMB_hdr_uid_offset, Con_Handle->uid);
+        *(SMB_Hdr(pkt) + SMB_hdr_wct_offset) = 13;
+        *(SMB_Hdr(pkt) + SMB_hdr_axc_offset) = 0xFF;	/* No extra command */
+        SSVAL(SMB_Hdr(pkt), SMB_hdr_axo_offset, 0);
 
-	SSVAL(SMB_Hdr(pkt), SMB_ssetpNTLM_mbs_offset, SMBLIB_MAX_XMIT);
-	SSVAL(SMB_Hdr(pkt), SMB_ssetpNTLM_mmc_offset, 0);
-	SSVAL(SMB_Hdr(pkt), SMB_ssetpNTLM_vcn_offset, 0);
-	SIVAL(SMB_Hdr(pkt), SMB_ssetpNTLM_snk_offset, 0);
-	SSVAL(SMB_Hdr(pkt), SMB_ssetpNTLM_cipl_offset, pass_len);
-	SSVAL(SMB_Hdr(pkt), SMB_ssetpNTLM_cspl_offset, 0);
-	SIVAL(SMB_Hdr(pkt), SMB_ssetpNTLM_res_offset, 0);
-	SIVAL(SMB_Hdr(pkt), SMB_ssetpNTLM_cap_offset, 0);
-	SSVAL(SMB_Hdr(pkt), SMB_ssetpNTLM_bcc_offset, param_len);
+        SSVAL(SMB_Hdr(pkt), SMB_ssetpNTLM_mbs_offset, SMBLIB_MAX_XMIT);
+        SSVAL(SMB_Hdr(pkt), SMB_ssetpNTLM_mmc_offset, 0);
+        SSVAL(SMB_Hdr(pkt), SMB_ssetpNTLM_vcn_offset, 0);
+        SIVAL(SMB_Hdr(pkt), SMB_ssetpNTLM_snk_offset, 0);
+        SSVAL(SMB_Hdr(pkt), SMB_ssetpNTLM_cipl_offset, pass_len);
+        SSVAL(SMB_Hdr(pkt), SMB_ssetpNTLM_cspl_offset, 0);
+        SIVAL(SMB_Hdr(pkt), SMB_ssetpNTLM_res_offset, 0);
+        SIVAL(SMB_Hdr(pkt), SMB_ssetpNTLM_cap_offset, 0);
+        SSVAL(SMB_Hdr(pkt), SMB_ssetpNTLM_bcc_offset, param_len);
 
-	/* Now copy the param strings in with the right stuff */
+        /* Now copy the param strings in with the right stuff */
 
-	p = (char *) (SMB_Hdr(pkt) + SMB_ssetpNTLM_buf_offset);
+        p = (char *) (SMB_Hdr(pkt) + SMB_ssetpNTLM_buf_offset);
 
-	/* Copy  in password, then the rest. Password has no null at end */
+        /* Copy  in password, then the rest. Password has no null at end */
 
-	memcpy(p, pword, pass_len);
+        memcpy(p, pword, pass_len);
 
-	p = p + pass_len;
+        p = p + pass_len;
 
-	strcpy(p, UserName);
-	p = p + strlen(UserName);
-	*p = 0;
+        strcpy(p, UserName);
+        p = p + strlen(UserName);
+        *p = 0;
 
-	p = p + 1;
+        p = p + 1;
 
-	strcpy(p, Con_Handle->PDomain);
-	p = p + strlen(Con_Handle->PDomain);
-	*p = 0;
-	p = p + 1;
+        strcpy(p, Con_Handle->PDomain);
+        p = p + strlen(Con_Handle->PDomain);
+        *p = 0;
+        p = p + 1;
 
-	strcpy(p, Con_Handle->OSName);
-	p = p + strlen(Con_Handle->OSName);
-	*p = 0;
-	p = p + 1;
+        strcpy(p, Con_Handle->OSName);
+        p = p + strlen(Con_Handle->OSName);
+        *p = 0;
+        p = p + 1;
 
-	strcpy(p, Con_Handle->LMType);
-	p = p + strlen(Con_Handle->LMType);
-	*p = 0;
+        strcpy(p, Con_Handle->LMType);
+        p = p + strlen(Con_Handle->LMType);
+        *p = 0;
 
     }
 
@@ -452,46 +452,46 @@ SMB_Logon_Server(SMB_Handle_Type Con_Handle, char *UserName,
     if (RFCNB_Send(Con_Handle->Trans_Connect, pkt, pkt_len) < 0) {
 
 #ifdef DEBUG
-	fprintf(stderr, "Error sending SessSetupX request\n");
+        fprintf(stderr, "Error sending SessSetupX request\n");
 #endif
 
-	RFCNB_Free_Pkt(pkt);
-	SMBlib_errno = SMBlibE_SendFailed;
-	return (SMBlibE_BAD);
+        RFCNB_Free_Pkt(pkt);
+        SMBlib_errno = SMBlibE_SendFailed;
+        return (SMBlibE_BAD);
 
     }
     /* Now get the response ... */
 
     if (RFCNB_Recv(Con_Handle->Trans_Connect, pkt, pkt_len) < 0) {
 
 #ifdef DEBUG
-	fprintf(stderr, "Error receiving response to SessSetupAndX\n");
+        fprintf(stderr, "Error receiving response to SessSetupAndX\n");
 #endif
 
-	RFCNB_Free_Pkt(pkt);
-	SMBlib_errno = SMBlibE_RecvFailed;
-	return (SMBlibE_BAD);
+        RFCNB_Free_Pkt(pkt);
+        SMBlib_errno = SMBlibE_RecvFailed;
+        return (SMBlibE_BAD);
 
     }
     /* Check out the response type ... */
 
     if (CVAL(SMB_Hdr(pkt), SMB_hdr_rcls_offset) != SMBC_SUCCESS) {	/* Process error */
 
 #ifdef DEBUG
-	fprintf(stderr, "SMB_SessSetupAndX failed with errorclass = %i, Error Code = %i\n",
-	    CVAL(SMB_Hdr(pkt), SMB_hdr_rcls_offset),
-	    SVAL(SMB_Hdr(pkt), SMB_hdr_err_offset));
+        fprintf(stderr, "SMB_SessSetupAndX failed with errorclass = %i, Error Code = %i\n",
+                CVAL(SMB_Hdr(pkt), SMB_hdr_rcls_offset),
+                SVAL(SMB_Hdr(pkt), SMB_hdr_err_offset));
 #endif
 
-	SMBlib_SMB_Error = IVAL(SMB_Hdr(pkt), SMB_hdr_rcls_offset);
-	RFCNB_Free_Pkt(pkt);
-	SMBlib_errno = SMBlibE_Remote;
-	return (SMBlibE_BAD);
+        SMBlib_SMB_Error = IVAL(SMB_Hdr(pkt), SMB_hdr_rcls_offset);
+        RFCNB_Free_Pkt(pkt);
+        SMBlib_errno = SMBlibE_Remote;
+        return (SMBlibE_BAD);
 
     }
 #ifdef DEBUG
     fprintf(stderr, "SessSetupAndX response. Action = %i\n",
-	SVAL(SMB_Hdr(pkt), SMB_ssetpr_act_offset));
+            SVAL(SMB_Hdr(pkt), SMB_ssetpr_act_offset));
 #endif
 
     /* Now pick up the UID for future reference ... */
@@ -515,7 +515,7 @@ SMB_Discon(SMB_Handle_Type Con_Handle, BOOL KeepHandle)
     RFCNB_Hangup(Con_Handle->Trans_Connect);
 
     if (!KeepHandle)
-	free(Con_Handle);
+        free(Con_Handle);
 
     return (0);
 
@@ -1,23 +1,23 @@
 /* UNIX SMBlib NetBIOS implementation
- * 
+ *
  * Version 1.0
  * SMBlib Defines
- * 
+ *
  * Copyright (C) Richard Sharpe 1996
- * 
+ *
  */
 
 /*
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
@@ -40,10 +40,10 @@ SMB_Handle_Type SMB_Connect_Server(SMB_Handle_Type, char *server, char *NTdomain
 /* The handle and populate it with defaults                              */
 
 SMB_Handle_Type SMB_Connect(SMB_Handle_Type Con_Handle,
-    SMB_Tree_Handle * tree,
-    char *service,
-    char *username,
-    char *password);
+                            SMB_Tree_Handle * tree,
+                            char *service,
+                            char *username,
+                            char *password);
 
 /* Negotiate a protocol                                                  */
 
@@ -52,7 +52,7 @@ int SMB_Negotiate(SMB_Handle_Type Con_Handle, const char *Prots[]);
 /* Connect to a tree ...                                                 */
 
 SMB_Tree_Handle SMB_TreeConnect(SMB_Handle_Type con_handle, SMB_Tree_Handle tree_handle,
-    char *path, char *password, const char *dev);
+                                char *path, char *password, const char *dev);
 
 /* Disconnect a tree ...                                                 */
 
@@ -61,10 +61,10 @@ int SMB_TreeDisconect(void *tree_handle);
 /* Open a file                                                           */
 
 void *SMB_Open(void *tree_handle,
-    void *file_handle,
-    char *file_name,
-    unsigned short mode,
-    unsigned short search);
+               void *file_handle,
+               char *file_name,
+               unsigned short mode,
+               unsigned short search);
 
 /* Close a file                                                          */
 
@@ -76,9 +76,9 @@ int SMB_Close(void *file_handle);
 int SMB_Discon(SMB_Handle_Type Con_Handle, BOOL KeepHandle);
 
 void *SMB_Create(void *Tree_Handle,
-    void *File_Handle,
-    char *file_name,
-    short search);
+                 void *File_Handle,
+                 char *file_name,
+                 short search);
 
 int SMB_Delete(void *tree, char *file_name, short search);
 
@@ -95,7 +95,7 @@ int SMB_Get_Last_SMB_Err(void);
 void SMB_Get_Error_Msg(int msg, char *msgbuf, int len);
 
 void *SMB_Logon_And_TCon(void *con, void *tree, char *user, char *pass,
-    char *service, char *st);
+                         char *service, char *st);
 
 void SMB_Get_My_Name(char *, int);
 
@@ -1,8 +1,8 @@
 /* RFCNB Standard includes ... */
 /*
- * 
+ *
  * SMBlib Standard Includes
- * 
+ *
  * Copyright (C) 1996, Richard Sharpe
  */
 /* One day we will conditionalize these on OS types ... */
@@ -12,12 +12,12 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
@@ -1,8 +1,8 @@
 /* RFCNB Standard includes ... */
 /*
- * 
+ *
  * RFCNB Standard Includes
- * 
+ *
  * Copyright (C) 1996, Richard Sharpe
  */
 /* One day we will conditionalize these on OS types ... */
@@ -12,12 +12,12 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
@@ -3,7 +3,7 @@
  * usersfile.c
  * (C) 2000 Antonino Iannella, Stellar-X Pty Ltd
  * Released under GPL, see COPYING-2.0 for details.
- * 
+ *
  * These routines are to allow users attempting to use the proxy which
  * have been explicitly allowed by the system administrator.
  * The code originated from denyusers.c.
@@ -38,9 +38,9 @@ free_names(usersfile * uf)
 {
     int i;
     for (i = 0; i < uf->Inuse; i++) {
-	if (uf->names[i])
-	    free(uf->names[i]);
-	uf->names[i] = NULL;
+        if (uf->names[i])
+            free(uf->names[i]);
+        uf->names[i] = NULL;
     }
     uf->Inuse = 0;
 }
@@ -62,59 +62,59 @@ Read_usersfile(const char *path, usersfile * uf)
     free_names(uf);
 
     if (NULL == path) {
-	path = uf->path;
+        path = uf->path;
     } else {
-	if (uf->path)
-	    free(uf->path);
-	uf->path = strdup(path);
+        if (uf->path)
+            free(uf->path);
+        uf->path = strdup(path);
     }
 
     /* Open the users file. Report any errors. */
     fp = fopen(path, "r");
     if (NULL == fp) {
-	uf->LMT = 0;
-	if (errno == ENOENT)
-	    return 0;
-	syslog(LOG_ERR, "%s: %s", path, strerror(errno));
-	return 1;
+        uf->LMT = 0;
+        if (errno == ENOENT)
+            return 0;
+        syslog(LOG_ERR, "%s: %s", path, strerror(errno));
+        return 1;
     }
     /* Stat the file. If it does not exist, save the size as zero.
      * Clear the allowed user string. Return. */
     if (fstat(fileno(fp), &FileBuf) < 0) {
-	syslog(LOG_ERR, "%s: %s", path, strerror(errno));
-	return 1;
+        syslog(LOG_ERR, "%s: %s", path, strerror(errno));
+        return 1;
     }
     /* If it exists, save the modification time and size */
     uf->LMT = FileBuf.st_mtime;
 
     /* Handle the special case of a zero length file */
     if (FileBuf.st_size == 0)
-	return 0;
+        return 0;
 
     /*
      * Read the file into memory
      * XXX assumes one username per input line
      */
     while (fgets(buf, 1024, fp) != NULL) {
-	/* ensure no names longer than our limit */
-	buf[NAMELEN] = '\0';
-	/* skip bad input lines */
-	if (NULL == strtok(buf, "\r\n"))
-	    continue;
-	/* grow the list if necessary */
-	if (0 == uf->Alloc) {
-	    uf->Alloc = 256;
-	    uf->names = calloc(uf->Alloc, sizeof(*uf->names));
-	} else if (uf->Inuse == uf->Alloc) {
-	    uf->Alloc = uf->Alloc << 1;
-	    uf->names = realloc(uf->names, uf->Alloc * sizeof(*uf->names));
-	    /* zero out the newly allocated memory */
-	    memset(&uf->names[uf->Alloc >> 1],
-		'\0',
-		(uf->Alloc >> 1) * sizeof(*uf->names));
-	}
-	uf->names[uf->Inuse] = strdup(buf);
-	uf->Inuse++;
+        /* ensure no names longer than our limit */
+        buf[NAMELEN] = '\0';
+        /* skip bad input lines */
+        if (NULL == strtok(buf, "\r\n"))
+            continue;
+        /* grow the list if necessary */
+        if (0 == uf->Alloc) {
+            uf->Alloc = 256;
+            uf->names = calloc(uf->Alloc, sizeof(*uf->names));
+        } else if (uf->Inuse == uf->Alloc) {
+            uf->Alloc = uf->Alloc << 1;
+            uf->names = realloc(uf->names, uf->Alloc * sizeof(*uf->names));
+            /* zero out the newly allocated memory */
+            memset(&uf->names[uf->Alloc >> 1],
+                   '\0',
+                   (uf->Alloc >> 1) * sizeof(*uf->names));
+        }
+        uf->names[uf->Inuse] = strdup(buf);
+        uf->Inuse++;
     }
     fclose(fp);
     fp = NULL;
@@ -137,24 +137,24 @@ Check_userlist(usersfile * uf, char *User)
 
     /* Empty users are always in the list */
     if (User[0] == '\0')
-	return 1;
+        return 1;
 
     /* If allowed user list is empty, allow all users.
      * If no users are supposed to be using the proxy, stop squid instead. */
     if (0 == uf->Inuse)
-	return 1;
+        return 1;
 
     /* Check if username string is found in the allowed user list.
      * If so, allow. If not, deny. Reconstruct the username
      * to have whitespace, to avoid finding wrong string subsets. */
 
     p = bsearch(&User,
-	uf->names,
-	uf->Inuse,
-	sizeof(*uf->names),
-	name_cmp);
+                uf->names,
+                uf->Inuse,
+                sizeof(*uf->names),
+                name_cmp);
     if (NULL == p) {
-	return 0;
+        return 0;
     }
     return 1;
 }
@@ -171,20 +171,20 @@ Check_forfilechange(usersfile * uf)
     /* Stat the allowed users file. If it cannot be accessed, return. */
 
     if (uf->path == NULL)
-	return;
+        return;
 
     if (stat(uf->path, &ChkBuf) < 0) {
-	if (errno == ENOENT) {
-	    uf->LMT = 0;
-	    free_names(uf);
-	} else {		/* Report error when accessing file */
-	    syslog(LOG_ERR, "%s: %s", uf->path, strerror(errno));
-	}
-	return;
+        if (errno == ENOENT) {
+            uf->LMT = 0;
+            free_names(uf);
+        } else {		/* Report error when accessing file */
+            syslog(LOG_ERR, "%s: %s", uf->path, strerror(errno));
+        }
+        return;
     }
     /* return if no change */
     if (ChkBuf.st_mtime == uf->LMT)
-	return;
+        return;
 
     /*
      * The file changed, so re-read it.
@@ -9,33 +9,33 @@
 int
 Valid_User(char *USERNAME, char *PASSWORD, char *SERVER, char *BACKUP, char *DOMAIN)
 {
-    const char *SMB_Prots[] =
-    {"PC NETWORK PROGRAM 1.0",
-	"MICROSOFT NETWORKS 1.03",
-	"MICROSOFT NETWORKS 3.0",
-	"LANMAN1.0",
-	"LM1.2X002",
-	"Samba",
-	"NT LM 0.12",
-	"NT LANMAN 1.0",
-	NULL};
+    const char *SMB_Prots[] = {"PC NETWORK PROGRAM 1.0",
+                               "MICROSOFT NETWORKS 1.03",
+                               "MICROSOFT NETWORKS 3.0",
+                               "LANMAN1.0",
+                               "LM1.2X002",
+                               "Samba",
+                               "NT LM 0.12",
+                               "NT LANMAN 1.0",
+                               NULL
+                              };
     void *con;
 
     SMB_Init();
     con = SMB_Connect_Server(NULL, SERVER, DOMAIN);
     if (con == NULL) {		/* Error ... */
-	con = SMB_Connect_Server(NULL, BACKUP, DOMAIN);
-	if (con == NULL) {
-	    return (NTV_SERVER_ERROR);
-	}
+        con = SMB_Connect_Server(NULL, BACKUP, DOMAIN);
+        if (con == NULL) {
+            return (NTV_SERVER_ERROR);
+        }
     }
     if (SMB_Negotiate(con, SMB_Prots) < 0) {	/* An error */
-	SMB_Discon(con, 0);
-	return (NTV_PROTOCOL_ERROR);
+        SMB_Discon(con, 0);
+        return (NTV_PROTOCOL_ERROR);
     }
     if (SMB_Logon_Server(con, USERNAME, PASSWORD) < 0) {
-	SMB_Discon(con, 0);
-	return (NTV_LOGON_ERROR);
+        SMB_Discon(con, 0);
+        return (NTV_LOGON_ERROR);
     }
     SMB_Discon(con, 0);
     return (NTV_NO_ERROR);
@@ -28,8 +28,8 @@ static unsigned char itoa64[] =	/* 0 ... 63 => ascii - 64 */
 static void md5to64(char *s, unsigned long v, int n)
 {
     while (--n >= 0) {
-	*s++ = itoa64[v & 0x3f];
-	v >>= 6;
+        *s++ = itoa64[v & 0x3f];
+        v >>= 6;
     }
 }
 
@@ -55,24 +55,24 @@ char *crypt_md5(const char *pw, const char *salt)
     unsigned long l;
 
     if (*salt == '$') {
-	magic = salt++;
-	while(*salt && *salt != '$')
-	    salt++;
-	if (*salt == '$') {
-	    salt++;
-	    magiclen = salt - magic;
-	} else {
-	    salt = magic;
-	    magic = "$1$";
-	}
+        magic = salt++;
+        while (*salt && *salt != '$')
+            salt++;
+        if (*salt == '$') {
+            salt++;
+            magiclen = salt - magic;
+        } else {
+            salt = magic;
+            magic = "$1$";
+        }
     }
 
     /* Refine the Salt first */
     sp = salt;
 
     /* It stops at the first '$', max 8 chars */
     for (ep = sp; *ep && *ep != '$' && ep < (sp + 8); ep++)
-	continue;
+        continue;
 
     /* get the length of the true salt */
     sl = ep - sp;
@@ -95,17 +95,17 @@ char *crypt_md5(const char *pw, const char *salt)
     SquidMD5Update(&ctx1, (unsigned const char *) pw, strlen(pw));
     SquidMD5Final(final, &ctx1);
     for (pl = strlen(pw); pl > 0; pl -= 16)
-	SquidMD5Update(&ctx, (unsigned const char *) final, pl > 16 ? 16 : pl);
+        SquidMD5Update(&ctx, (unsigned const char *) final, pl > 16 ? 16 : pl);
 
     /* Don't leave anything around in vm they could use. */
     memset(final, 0, sizeof final);
 
     /* Then something really weird... */
     for (j = 0, i = strlen(pw); i; i >>= 1)
-	if (i & 1)
-	    SquidMD5Update(&ctx, (unsigned const char *) final + j, 1);
-	else
-	    SquidMD5Update(&ctx, (unsigned const char *) pw + j, 1);
+        if (i & 1)
+            SquidMD5Update(&ctx, (unsigned const char *) final + j, 1);
+        else
+            SquidMD5Update(&ctx, (unsigned const char *) pw + j, 1);
 
     /* Now make the output string */
     memset(passwd, 0, sizeof(passwd));
@@ -121,23 +121,23 @@ char *crypt_md5(const char *pw, const char *salt)
      * need 30 seconds to build a 1000 entry dictionary...
      */
     for (i = 0; i < 1000; i++) {
-	SquidMD5Init(&ctx1);
-	if (i & 1)
-	    SquidMD5Update(&ctx1, (unsigned const char *) pw, strlen(pw));
-	else
-	    SquidMD5Update(&ctx1, (unsigned const char *) final, 16);
-
-	if (i % 3)
-	    SquidMD5Update(&ctx1, (unsigned const char *) sp, sl);
-
-	if (i % 7)
-	    SquidMD5Update(&ctx1, (unsigned const char *) pw, strlen(pw));
-
-	if (i & 1)
-	    SquidMD5Update(&ctx1, (unsigned const char *) final, 16);
-	else
-	    SquidMD5Update(&ctx1, (unsigned const char *) pw, strlen(pw));
-	SquidMD5Final(final, &ctx1);
+        SquidMD5Init(&ctx1);
+        if (i & 1)
+            SquidMD5Update(&ctx1, (unsigned const char *) pw, strlen(pw));
+        else
+            SquidMD5Update(&ctx1, (unsigned const char *) final, 16);
+
+        if (i % 3)
+            SquidMD5Update(&ctx1, (unsigned const char *) sp, sl);
+
+        if (i % 7)
+            SquidMD5Update(&ctx1, (unsigned const char *) pw, strlen(pw));
+
+        if (i & 1)
+            SquidMD5Update(&ctx1, (unsigned const char *) final, 16);
+        else
+            SquidMD5Update(&ctx1, (unsigned const char *) pw, strlen(pw));
+        SquidMD5Final(final, &ctx1);
     }
 
     p = passwd + strlen(passwd);
@@ -171,26 +171,27 @@ char *crypt_md5(const char *pw, const char *salt)
 /* Created by Ramon de Carvalho <ramondecarvalho@yahoo.com.br>
    Refined by Rodrigo Rubira Branco <rodrigo@kernelhacking.com>
 */
-char *md5sum(const char *s){
-   static unsigned char digest[16];
-   SquidMD5_CTX ctx;
-   int idx;
-   static char sum[33];
+char *md5sum(const char *s)
+{
+    static unsigned char digest[16];
+    SquidMD5_CTX ctx;
+    int idx;
+    static char sum[33];
 
-   memset(digest,0,16);
+    memset(digest,0,16);
 
-   SquidMD5Init(&ctx);
-   SquidMD5Update(&ctx,(const unsigned char *)s,strlen(s));
-   SquidMD5Final(digest,&ctx);
+    SquidMD5Init(&ctx);
+    SquidMD5Update(&ctx,(const unsigned char *)s,strlen(s));
+    SquidMD5Final(digest,&ctx);
 
-   for(idx=0;idx<16;idx++)
-       sprintf(&sum[idx*2],"%02x",digest[idx]);
+    for (idx=0;idx<16;idx++)
+        sprintf(&sum[idx*2],"%02x",digest[idx]);
 
-   sum[32]='\0';
+    sum[32]='\0';
 
-   /* Don't leave anything around in vm they could use. */
-   memset(digest, 0, sizeof digest);
+    /* Don't leave anything around in vm they could use. */
+    memset(digest, 0, sizeof digest);
 
-   return sum;
+    return sum;
 }
 
@@ -72,32 +72,32 @@ read_passwd_file(const char *passwdfile)
     char *user;
     char *passwd;
     if (hash != NULL) {
-	hashFreeItems(hash, my_free);
-	hashFreeMemory(hash);
+        hashFreeItems(hash, my_free);
+        hashFreeMemory(hash);
     }
     /* initial setup */
     hash = hash_create((HASHCMP *) strcmp, 7921, hash_string);
     if (NULL == hash) {
-	fprintf(stderr, "ncsa_auth: cannot create hash table\n");
-	exit(1);
+        fprintf(stderr, "ncsa_auth: cannot create hash table\n");
+        exit(1);
     }
     f = fopen(passwdfile, "r");
     if (NULL == f) {
-	fprintf(stderr, "%s: %s\n", passwdfile, xstrerror());
-	exit(1);
+        fprintf(stderr, "%s: %s\n", passwdfile, xstrerror());
+        exit(1);
     }
     while (fgets(buf, 8192, f) != NULL) {
-	if ((buf[0] == '#') || (buf[0] == ' ') || (buf[0] == '\t') ||
-	    (buf[0] == '\n'))
-	    continue;
-	user = strtok(buf, ":\n\r");
-	passwd = strtok(NULL, ":\n\r");
-	if ((strlen(user) > 0) && passwd) {
-	    u = xmalloc(sizeof(*u));
-	    u->user = xstrdup(user);
-	    u->passwd = xstrdup(passwd);
-	    hash_join(hash, (hash_link *) u);
-	}
+        if ((buf[0] == '#') || (buf[0] == ' ') || (buf[0] == '\t') ||
+                (buf[0] == '\n'))
+            continue;
+        user = strtok(buf, ":\n\r");
+        passwd = strtok(NULL, ":\n\r");
+        if ((strlen(user) > 0) && passwd) {
+            u = xmalloc(sizeof(*u));
+            u->user = xstrdup(user);
+            u->passwd = xstrdup(passwd);
+            hash_join(hash, (hash_link *) u);
+        }
     }
     fclose(f);
 }
@@ -112,50 +112,50 @@ main(int argc, char **argv)
     user_data *u;
     setbuf(stdout, NULL);
     if (argc != 2) {
-	fprintf(stderr, "Usage: ncsa_auth <passwordfile>\n");
-	exit(1);
+        fprintf(stderr, "Usage: ncsa_auth <passwordfile>\n");
+        exit(1);
     }
     if (stat(argv[1], &sb) != 0) {
-	fprintf(stderr, "cannot stat %s\n", argv[1]);
-	exit(1);
+        fprintf(stderr, "cannot stat %s\n", argv[1]);
+        exit(1);
     }
     while (fgets(buf, 256, stdin) != NULL) {
-	if ((p = strchr(buf, '\n')) != NULL)
-	    *p = '\0';		/* strip \n */
-	if (stat(argv[1], &sb) == 0) {
-	    if (sb.st_mtime != change_time) {
-		read_passwd_file(argv[1]);
-		change_time = sb.st_mtime;
-	    }
-	}
-	if ((user = strtok(buf, " ")) == NULL) {
-	    printf("ERR\n");
-	    continue;
-	}
-	if ((passwd = strtok(NULL, "")) == NULL) {
-	    printf("ERR\n");
-	    continue;
-	}
-	rfc1738_unescape(user);
-	rfc1738_unescape(passwd);
-	u = (user_data *) hash_lookup(hash, user);
-	if (u == NULL) {
-	    printf("ERR No such user\n");
+        if ((p = strchr(buf, '\n')) != NULL)
+            *p = '\0';		/* strip \n */
+        if (stat(argv[1], &sb) == 0) {
+            if (sb.st_mtime != change_time) {
+                read_passwd_file(argv[1]);
+                change_time = sb.st_mtime;
+            }
+        }
+        if ((user = strtok(buf, " ")) == NULL) {
+            printf("ERR\n");
+            continue;
+        }
+        if ((passwd = strtok(NULL, "")) == NULL) {
+            printf("ERR\n");
+            continue;
+        }
+        rfc1738_unescape(user);
+        rfc1738_unescape(passwd);
+        u = (user_data *) hash_lookup(hash, user);
+        if (u == NULL) {
+            printf("ERR No such user\n");
 #if HAVE_CRYPT
-	} else if (strcmp(u->passwd, (char *) crypt(passwd, u->passwd)) == 0) {
-	    printf("OK\n");
+        } else if (strcmp(u->passwd, (char *) crypt(passwd, u->passwd)) == 0) {
+            printf("OK\n");
 #endif
-	} else if (strcmp(u->passwd, (char *) crypt_md5(passwd, u->passwd)) == 0) {
-	    printf("OK\n");
-	} else if (strcmp(u->passwd, (char *) md5sum(passwd)) == 0) {	/* md5 without salt and magic strings - Added by Ramon de Carvalho and Rodrigo Rubira Branco */
-	    printf("OK\n");
-	} else {
-	    printf("ERR Wrong password\n");
-	}
+        } else if (strcmp(u->passwd, (char *) crypt_md5(passwd, u->passwd)) == 0) {
+            printf("OK\n");
+        } else if (strcmp(u->passwd, (char *) md5sum(passwd)) == 0) {	/* md5 without salt and magic strings - Added by Ramon de Carvalho and Rodrigo Rubira Branco */
+            printf("OK\n");
+        } else {
+            printf("ERR Wrong password\n");
+        }
     }
     if (hash != NULL) {
-	hashFreeItems(hash, my_free);
-	hashFreeMemory(hash);
+        hashFreeItems(hash, my_free);
+        hashFreeMemory(hash);
     }
     exit(0);
 }
@@ -100,32 +100,31 @@ static int
 password_conversation(int num_msg, const struct pam_message **msg, struct pam_response **resp, void *appdata_ptr)
 {
     if (num_msg != 1 || msg[0]->msg_style != PAM_PROMPT_ECHO_OFF) {
-	fprintf(stderr, "ERROR: Unexpected PAM converstaion '%d/%s'\n", msg[0]->msg_style, msg[0]->msg);
-	return PAM_CONV_ERR;
+        fprintf(stderr, "ERROR: Unexpected PAM converstaion '%d/%s'\n", msg[0]->msg_style, msg[0]->msg);
+        return PAM_CONV_ERR;
     }
     if (!appdata_ptr) {
-	/* Workaround for Solaris 2.6 where the PAM library is broken
-	 * and does not pass appdata_ptr to the conversation routine
-	 */
-	appdata_ptr = password;
+        /* Workaround for Solaris 2.6 where the PAM library is broken
+         * and does not pass appdata_ptr to the conversation routine
+         */
+        appdata_ptr = password;
     }
     if (!appdata_ptr) {
-	fprintf(stderr, "ERROR: No password available to password_converstation!\n");
-	return PAM_CONV_ERR;
+        fprintf(stderr, "ERROR: No password available to password_converstation!\n");
+        return PAM_CONV_ERR;
     }
     *resp = calloc(num_msg, sizeof(struct pam_response));
     if (!*resp) {
-	fprintf(stderr, "ERROR: Out of memory!\n");
-	return PAM_CONV_ERR;
+        fprintf(stderr, "ERROR: Out of memory!\n");
+        return PAM_CONV_ERR;
     }
     (*resp)[0].resp = strdup((char *) appdata_ptr);
     (*resp)[0].resp_retcode = 0;
 
     return ((*resp)[0].resp ? PAM_SUCCESS : PAM_CONV_ERR);
 }
 
-static struct pam_conv conv =
-{
+static struct pam_conv conv = {
     &password_conversation,
     NULL
 };
@@ -159,118 +158,118 @@ main(int argc, char *argv[])
     setvbuf(stdout, NULL, _IOLBF, 0);
 
     while (1) {
-	int ch = getopt(argc, argv, "1n:t:o");
-	switch (ch) {
-	case -1:
-		goto start;
-	case 'n':
-		service = optarg;
-		break;
-	case 't':
-		ttl = atoi(optarg);
-		break;
-	case '1':
-		ttl = 0;
-		break;
-	case 'o':
-		no_acct_mgmt = 1;
-		break;
-	default:
-		fprintf(stderr, "Unknown getopt value '%c'\n", ch);
-		usage(argv[0]);
-		exit(1);
-	}
+        int ch = getopt(argc, argv, "1n:t:o");
+        switch (ch) {
+        case -1:
+            goto start;
+        case 'n':
+            service = optarg;
+            break;
+        case 't':
+            ttl = atoi(optarg);
+            break;
+        case '1':
+            ttl = 0;
+            break;
+        case 'o':
+            no_acct_mgmt = 1;
+            break;
+        default:
+            fprintf(stderr, "Unknown getopt value '%c'\n", ch);
+            usage(argv[0]);
+            exit(1);
+        }
     }
 start:
     if (optind < argc) {
-	fprintf(stderr, "Unknown option '%s'\n", argv[optind]);
-	usage(argv[0]);
-	exit(1);
+        fprintf(stderr, "Unknown option '%s'\n", argv[optind]);
+        usage(argv[0]);
+        exit(1);
     }
 
     while (fgets(buf, BUFSIZE, stdin)) {
-	user = buf;
-	password = strchr(buf, '\n');
-	if (!password) {
-	    fprintf(stderr, "authenticator: Unexpected input '%s'\n", buf);
-	    goto error;
-	}
-	*password = '\0';
-	password = strchr(buf, ' ');
-	if (!password) {
-	    fprintf(stderr, "authenticator: Unexpected input '%s'\n", buf);
-	    goto error;
-	}
-	*password++ = '\0';
-	rfc1738_unescape(user);
-	rfc1738_unescape(password);
-	conv.appdata_ptr = (char *) password;	/* from buf above. not allocated */
+        user = buf;
+        password = strchr(buf, '\n');
+        if (!password) {
+            fprintf(stderr, "authenticator: Unexpected input '%s'\n", buf);
+            goto error;
+        }
+        *password = '\0';
+        password = strchr(buf, ' ');
+        if (!password) {
+            fprintf(stderr, "authenticator: Unexpected input '%s'\n", buf);
+            goto error;
+        }
+        *password++ = '\0';
+        rfc1738_unescape(user);
+        rfc1738_unescape(password);
+        conv.appdata_ptr = (char *) password;	/* from buf above. not allocated */
 
-	if (ttl == 0) {
-	    /* Create PAM connection */
-	    retval = pam_start(service, user, &conv, &pamh);
-	    if (retval != PAM_SUCCESS) {
-		fprintf(stderr, "ERROR: failed to create PAM authenticator\n");
-		goto error;
-	    }
-	} else if (!pamh || (time(NULL) - pamh_created) >= ttl || pamh_created > time(NULL)) {
-	    /* Close previous PAM connection */
-	    if (pamh) {
-		retval = pam_end(pamh, retval);
-		if (retval != PAM_SUCCESS) {
-		    fprintf(stderr, "WARNING: failed to release PAM authenticator\n");
-		}
-		pamh = NULL;
-	    }
-	    /* Initialize persistent PAM connection */
-	    retval = pam_start(service, "squid@", &conv, &pamh);
-	    if (retval != PAM_SUCCESS) {
-		fprintf(stderr, "ERROR: failed to create PAM authenticator\n");
-		goto error;
-	    }
-	    pamh_created = time(NULL);
-	}
-	/* Authentication */
-	retval = PAM_SUCCESS;
-	if (ttl != 0) {
-	    if (retval == PAM_SUCCESS)
-		retval = pam_set_item(pamh, PAM_USER, user);
-	    if (retval == PAM_SUCCESS)
-		retval = pam_set_item(pamh, PAM_CONV, &conv);
-	}
-	if (retval == PAM_SUCCESS)
-	    retval = pam_authenticate(pamh, 0);
-	if (retval == PAM_SUCCESS && !no_acct_mgmt)
-	    retval = pam_acct_mgmt(pamh, 0);
-	if (retval == PAM_SUCCESS) {
-	    fprintf(stdout, "OK\n");
-	} else {
+        if (ttl == 0) {
+            /* Create PAM connection */
+            retval = pam_start(service, user, &conv, &pamh);
+            if (retval != PAM_SUCCESS) {
+                fprintf(stderr, "ERROR: failed to create PAM authenticator\n");
+                goto error;
+            }
+        } else if (!pamh || (time(NULL) - pamh_created) >= ttl || pamh_created > time(NULL)) {
+            /* Close previous PAM connection */
+            if (pamh) {
+                retval = pam_end(pamh, retval);
+                if (retval != PAM_SUCCESS) {
+                    fprintf(stderr, "WARNING: failed to release PAM authenticator\n");
+                }
+                pamh = NULL;
+            }
+            /* Initialize persistent PAM connection */
+            retval = pam_start(service, "squid@", &conv, &pamh);
+            if (retval != PAM_SUCCESS) {
+                fprintf(stderr, "ERROR: failed to create PAM authenticator\n");
+                goto error;
+            }
+            pamh_created = time(NULL);
+        }
+        /* Authentication */
+        retval = PAM_SUCCESS;
+        if (ttl != 0) {
+            if (retval == PAM_SUCCESS)
+                retval = pam_set_item(pamh, PAM_USER, user);
+            if (retval == PAM_SUCCESS)
+                retval = pam_set_item(pamh, PAM_CONV, &conv);
+        }
+        if (retval == PAM_SUCCESS)
+            retval = pam_authenticate(pamh, 0);
+        if (retval == PAM_SUCCESS && !no_acct_mgmt)
+            retval = pam_acct_mgmt(pamh, 0);
+        if (retval == PAM_SUCCESS) {
+            fprintf(stdout, "OK\n");
+        } else {
 error:
-	    fprintf(stdout, "ERR\n");
-	}
-	/* cleanup */
-	retval = PAM_SUCCESS;
+            fprintf(stdout, "ERR\n");
+        }
+        /* cleanup */
+        retval = PAM_SUCCESS;
 #ifdef PAM_AUTHTOK
-	if (ttl != 0) {
-	    if (retval == PAM_SUCCESS)
-		retval = pam_set_item(pamh, PAM_AUTHTOK, NULL);
-	}
+        if (ttl != 0) {
+            if (retval == PAM_SUCCESS)
+                retval = pam_set_item(pamh, PAM_AUTHTOK, NULL);
+        }
 #endif
-	if (ttl == 0 || retval != PAM_SUCCESS) {
-	    retval = pam_end(pamh, retval);
-	    if (retval != PAM_SUCCESS) {
-		fprintf(stderr, "WARNING: failed to release PAM authenticator\n");
-	    }
-	    pamh = NULL;
-	}
+        if (ttl == 0 || retval != PAM_SUCCESS) {
+            retval = pam_end(pamh, retval);
+            if (retval != PAM_SUCCESS) {
+                fprintf(stderr, "WARNING: failed to release PAM authenticator\n");
+            }
+            pamh = NULL;
+        }
     }
 
     if (pamh) {
-	retval = pam_end(pamh, retval);
-	if (retval != PAM_SUCCESS) {
-	    pamh = NULL;
-	    fprintf(stderr, "ERROR: failed to release PAM authenticator\n");
-	}
+        retval = pam_end(pamh, retval);
+        if (retval != PAM_SUCCESS) {
+            pamh = NULL;
+            fprintf(stderr, "ERROR: failed to release PAM authenticator\n");
+        }
     }
     return 0;
 }
@@ -44,83 +44,82 @@
 int
 main(int argc, char *argv[])
 {
-	char line[8192];
-	char *username, *password;
+    char line[8192];
+    char *username, *password;
 #if SASL_VERSION_MAJOR < 2
-	const char *errstr;
+    const char *errstr;
 #endif
 
-	int rc;
-        sasl_conn_t *conn = NULL;
-
-	/* make standard output line buffered */
-	setvbuf(stdout, NULL, _IOLBF, 0);
-
-	rc = sasl_server_init( NULL, APP_NAME_SASL );
-
-	if ( rc != SASL_OK ) {
-		fprintf( stderr, "error %d %s\n", rc, sasl_errstring(rc, NULL, NULL ));
-		fprintf( stdout, "ERR\n" );
-		return 1;
-	}
-
-	#if SASL_VERSION_MAJOR < 2
-	rc = sasl_server_new( APP_NAME_SASL, NULL, NULL, NULL, 0, &conn );
-	#else
-	rc = sasl_server_new( APP_NAME_SASL, NULL, NULL, NULL, NULL, NULL, 0, &conn );
-	#endif
-
-	if ( rc != SASL_OK ) {
-		fprintf( stderr, "error %d %s\n", rc, sasl_errstring(rc, NULL, NULL ));
-		fprintf( stdout, "ERR\n" );
-		return 1;
-	}
-
-	while ( fgets( line, sizeof( line ), stdin )) {
-		username = &line[0];
-		password = strchr( line, '\n' );
-		if ( !password) {
-			fprintf( stderr, "authenticator: Unexpected input '%s'\n", line );
-			fprintf( stdout, "ERR\n" );
-			continue;
-		}
-		*password = '\0';
-		password = strchr ( line, ' ' );
-		if ( !password) {
-			fprintf( stderr, "authenticator: Unexpected input '%s'\n", line );
-			fprintf( stdout, "ERR\n" );
-			continue;
-		}
-		*password++ = '\0';
-
-		rfc1738_unescape(username);
-		rfc1738_unescape(password);
-
-		#if SASL_VERSION_MAJOR < 2
-		rc = sasl_checkpass(conn, username, strlen(username), password, strlen(password), &errstr);
-		#else
-		rc = sasl_checkpass(conn, username, strlen(username), password, strlen(password));
-		#endif
-
-		if ( rc != SASL_OK ) {
-			#if SASL_VERSION_MAJOR < 2
-			if ( errstr ) {
-				fprintf( stderr, "errstr %s\n", errstr );
-			}
-			if ( rc != SASL_BADAUTH ) {
-				fprintf( stderr, "error %d %s\n", rc, sasl_errstring(rc, NULL, NULL ));
-			}
-			#endif
-			fprintf( stdout, "ERR\n" );
-		}
-		else {
-			fprintf( stdout, "OK\n" );
-		}
-
-	}
-
-        sasl_dispose( &conn );
-        sasl_done();
-
-	return 0;
+    int rc;
+    sasl_conn_t *conn = NULL;
+
+    /* make standard output line buffered */
+    setvbuf(stdout, NULL, _IOLBF, 0);
+
+    rc = sasl_server_init( NULL, APP_NAME_SASL );
+
+    if ( rc != SASL_OK ) {
+        fprintf( stderr, "error %d %s\n", rc, sasl_errstring(rc, NULL, NULL ));
+        fprintf( stdout, "ERR\n" );
+        return 1;
+    }
+
+#if SASL_VERSION_MAJOR < 2
+    rc = sasl_server_new( APP_NAME_SASL, NULL, NULL, NULL, 0, &conn );
+#else
+    rc = sasl_server_new( APP_NAME_SASL, NULL, NULL, NULL, NULL, NULL, 0, &conn );
+#endif
+
+    if ( rc != SASL_OK ) {
+        fprintf( stderr, "error %d %s\n", rc, sasl_errstring(rc, NULL, NULL ));
+        fprintf( stdout, "ERR\n" );
+        return 1;
+    }
+
+    while ( fgets( line, sizeof( line ), stdin )) {
+        username = &line[0];
+        password = strchr( line, '\n' );
+        if ( !password) {
+            fprintf( stderr, "authenticator: Unexpected input '%s'\n", line );
+            fprintf( stdout, "ERR\n" );
+            continue;
+        }
+        *password = '\0';
+        password = strchr ( line, ' ' );
+        if ( !password) {
+            fprintf( stderr, "authenticator: Unexpected input '%s'\n", line );
+            fprintf( stdout, "ERR\n" );
+            continue;
+        }
+        *password++ = '\0';
+
+        rfc1738_unescape(username);
+        rfc1738_unescape(password);
+
+#if SASL_VERSION_MAJOR < 2
+        rc = sasl_checkpass(conn, username, strlen(username), password, strlen(password), &errstr);
+#else
+        rc = sasl_checkpass(conn, username, strlen(username), password, strlen(password));
+#endif
+
+        if ( rc != SASL_OK ) {
+#if SASL_VERSION_MAJOR < 2
+            if ( errstr ) {
+                fprintf( stderr, "errstr %s\n", errstr );
+            }
+            if ( rc != SASL_BADAUTH ) {
+                fprintf( stderr, "error %d %s\n", rc, sasl_errstring(rc, NULL, NULL ));
+            }
+#endif
+            fprintf( stdout, "ERR\n" );
+        } else {
+            fprintf( stdout, "OK\n" );
+        }
+
+    }
+
+    sasl_dispose( &conn );
+    sasl_done();
+
+    return 0;
 }
@@ -30,12 +30,12 @@
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation; either version 2 of the License, or
  *  (at your option) any later version.
- *  
+ *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
- *  
+ *
  *  You should have received a copy of the GNU General Public License
  *  along with this program; if not, write to the Free Software
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
@@ -78,20 +78,20 @@ print_esc(FILE * p, char *s)
     int i = 0;
 
     for (t = s; *t != '\0'; t++) {
-	if (i > 250) {
-	    buf[i] = '\0';
-	    (void) fputs(buf, p);
-	    i = 0;
-	}
-	if (*t == '\\')
-	    buf[i++] = '\\';
+        if (i > 250) {
+            buf[i] = '\0';
+            (void) fputs(buf, p);
+            i = 0;
+        }
+        if (*t == '\\')
+            buf[i++] = '\\';
 
-	buf[i++] = *t;
+        buf[i++] = *t;
     }
 
     if (i > 0) {
-	buf[i] = '\0';
-	(void) fputs(buf, p);
+        buf[i] = '\0';
+        (void) fputs(buf, p);
     }
 }
 
@@ -111,150 +111,150 @@ main(int argc, char *argv[])
 
     /* make standard output line buffered */
     if (setvbuf(stdout, NULL, _IOLBF, 0) != 0)
-	return 1;
+        return 1;
 
     /* parse command line arguments */
     for (i = 1; i < argc; i++) {
-	if (strcmp(argv[i], "-d") == 0) {
-	    debug = 1;
-	    continue;
-	}
-	/* the next options require an argument */
-	if (i + 1 == argc)
-	    break;
+        if (strcmp(argv[i], "-d") == 0) {
+            debug = 1;
+            continue;
+        }
+        /* the next options require an argument */
+        if (i + 1 == argc)
+            break;
 
-	if (strcmp(argv[i], "-W") == 0) {
-	    if ((dom = (struct SMBDOMAIN *) malloc(sizeof(struct SMBDOMAIN))) == NULL)
-		          return 1;
+        if (strcmp(argv[i], "-W") == 0) {
+            if ((dom = (struct SMBDOMAIN *) malloc(sizeof(struct SMBDOMAIN))) == NULL)
+                return 1;
 
-	    dom->name = dom->sname = argv[++i];
-	    dom->passthrough = "";
-	    dom->nmbaddr = "";
-	    dom->nmbcast = NMB_BROADCAST;
-	    dom->authshare = "NETLOGON";
-	    dom->authfile = "proxyauth";
-	    dom->next = NULL;
+            dom->name = dom->sname = argv[++i];
+            dom->passthrough = "";
+            dom->nmbaddr = "";
+            dom->nmbcast = NMB_BROADCAST;
+            dom->authshare = "NETLOGON";
+            dom->authfile = "proxyauth";
+            dom->next = NULL;
 
-	    /* append to linked list */
-	    if (lastdom != NULL)
-		lastdom->next = dom;
-	    else
-		firstdom = dom;
+            /* append to linked list */
+            if (lastdom != NULL)
+                lastdom->next = dom;
+            else
+                firstdom = dom;
 
-	    lastdom = dom;
-	    continue;
-	}
-	if (strcmp(argv[i], "-w") == 0) {
-	    if (lastdom != NULL)
-		lastdom->sname = argv[++i];
-	    continue;
-	}
-	if (strcmp(argv[i], "-P") == 0) {
-	    if (lastdom != NULL)
-		lastdom->passthrough = argv[++i];
-	    continue;
-	}
-	if (strcmp(argv[i], "-B") == 0) {
-	    if (lastdom != NULL) {
-		lastdom->nmbaddr = argv[++i];
-		lastdom->nmbcast = NMB_BROADCAST;
-	    }
-	    continue;
-	}
-	if (strcmp(argv[i], "-U") == 0) {
-	    if (lastdom != NULL) {
-		lastdom->nmbaddr = argv[++i];
-		lastdom->nmbcast = NMB_UNICAST;
-	    }
-	    continue;
-	}
-	if (strcmp(argv[i], "-S") == 0) {
-	    if (lastdom != NULL) {
-		if ((lastdom->authshare = strdup(argv[++i])) == NULL)
-		    return 1;
+            lastdom = dom;
+            continue;
+        }
+        if (strcmp(argv[i], "-w") == 0) {
+            if (lastdom != NULL)
+                lastdom->sname = argv[++i];
+            continue;
+        }
+        if (strcmp(argv[i], "-P") == 0) {
+            if (lastdom != NULL)
+                lastdom->passthrough = argv[++i];
+            continue;
+        }
+        if (strcmp(argv[i], "-B") == 0) {
+            if (lastdom != NULL) {
+                lastdom->nmbaddr = argv[++i];
+                lastdom->nmbcast = NMB_BROADCAST;
+            }
+            continue;
+        }
+        if (strcmp(argv[i], "-U") == 0) {
+            if (lastdom != NULL) {
+                lastdom->nmbaddr = argv[++i];
+                lastdom->nmbcast = NMB_UNICAST;
+            }
+            continue;
+        }
+        if (strcmp(argv[i], "-S") == 0) {
+            if (lastdom != NULL) {
+                if ((lastdom->authshare = strdup(argv[++i])) == NULL)
+                    return 1;
 
-		/* convert backslashes to forward slashes */
-		for (s = lastdom->authshare; *s != '\0'; s++)
-		    if (*s == '\\')
-			*s = '/';
+                /* convert backslashes to forward slashes */
+                for (s = lastdom->authshare; *s != '\0'; s++)
+                    if (*s == '\\')
+                        *s = '/';
 
-		/* strip leading forward slash from share name */
-		if (*lastdom->authshare == '/')
-		    lastdom->authshare++;
+                /* strip leading forward slash from share name */
+                if (*lastdom->authshare == '/')
+                    lastdom->authshare++;
 
-		if ((s = strchr(lastdom->authshare, '/')) != NULL) {
-		    *s = '\0';
-		    lastdom->authfile = s + 1;
-		}
-	    }
-	    continue;
-	}
+                if ((s = strchr(lastdom->authshare, '/')) != NULL) {
+                    *s = '\0';
+                    lastdom->authfile = s + 1;
+                }
+            }
+            continue;
+        }
     }
 
     shcmd = debug ? HELPERSCRIPT : HELPERSCRIPT " > /dev/null 2>&1";
 
     /* pass to helper script */
     if (putenv("SAMBAPREFIX=" SAMBAPREFIX) != 0)
-	return 1;
+        return 1;
 
     while (1) {
-	if (fgets(buf, BUFSIZE, stdin) == NULL)
-	    break;
+        if (fgets(buf, BUFSIZE, stdin) == NULL)
+            break;
 
-	if ((s = strchr(buf, '\n')) == NULL)
-	    continue;
-	*s = '\0';
+        if ((s = strchr(buf, '\n')) == NULL)
+            continue;
+        *s = '\0';
 
-	if ((s = strchr(buf, ' ')) == NULL) {
-	    (void) printf("ERR\n");
-	    continue;
-	}
-	*s = '\0';
+        if ((s = strchr(buf, ' ')) == NULL) {
+            (void) printf("ERR\n");
+            continue;
+        }
+        *s = '\0';
 
-	user = buf;
-	pass = s + 1;
-	domname = NULL;
+        user = buf;
+        pass = s + 1;
+        domname = NULL;
 
-	rfc1738_unescape(user);
-	rfc1738_unescape(pass);
+        rfc1738_unescape(user);
+        rfc1738_unescape(pass);
 
-	if ((s = strchr(user, '\\')) != NULL) {
-	    *s = '\0';
-	    domname = user;
-	    user = s + 1;
-	}
-	/* match domname with linked list */
-	if (domname != NULL && strlen(domname) > 0) {
-	    for (dom = firstdom; dom != NULL; dom = dom->next)
-		if (strcasecmp(dom->sname, domname) == 0)
-		    break;
-	} else
-	    dom = firstdom;
+        if ((s = strchr(user, '\\')) != NULL) {
+            *s = '\0';
+            domname = user;
+            user = s + 1;
+        }
+        /* match domname with linked list */
+        if (domname != NULL && strlen(domname) > 0) {
+            for (dom = firstdom; dom != NULL; dom = dom->next)
+                if (strcasecmp(dom->sname, domname) == 0)
+                    break;
+        } else
+            dom = firstdom;
 
-	if (dom == NULL) {
-	    (void) printf("ERR\n");
-	    continue;
-	}
-	if ((p = popen(shcmd, "w")) == NULL) {
-	    (void) printf("ERR\n");
-	    continue;
-	}
-	(void) fprintf(p, "%s\n", dom->name);
-	(void) fprintf(p, "%s\n", dom->passthrough);
-	(void) fprintf(p, "%s\n", dom->nmbaddr);
-	(void) fprintf(p, "%d\n", dom->nmbcast);
-	(void) fprintf(p, "%s\n", dom->authshare);
-	(void) fprintf(p, "%s\n", dom->authfile);
-	(void) fprintf(p, "%s\n", user);
-	/* the password can contain special characters */
-	print_esc(p, pass);
-	(void) fputc('\n', p);
-	(void) fflush(p);
+        if (dom == NULL) {
+            (void) printf("ERR\n");
+            continue;
+        }
+        if ((p = popen(shcmd, "w")) == NULL) {
+            (void) printf("ERR\n");
+            continue;
+        }
+        (void) fprintf(p, "%s\n", dom->name);
+        (void) fprintf(p, "%s\n", dom->passthrough);
+        (void) fprintf(p, "%s\n", dom->nmbaddr);
+        (void) fprintf(p, "%d\n", dom->nmbcast);
+        (void) fprintf(p, "%s\n", dom->authshare);
+        (void) fprintf(p, "%s\n", dom->authfile);
+        (void) fprintf(p, "%s\n", user);
+        /* the password can contain special characters */
+        print_esc(p, pass);
+        (void) fputc('\n', p);
+        (void) fflush(p);
 
-	if (pclose(p) == 0)
-	    (void) printf("OK\n");
-	else
-	    (void) printf("ERR\n");
+        if (pclose(p) == 0)
+            (void) printf("OK\n");
+        else
+            (void) printf("ERR\n");
 
     }				/* while (1) */
     return 0;
@@ -29,24 +29,25 @@ get_nis_password(char *user, char *nisdomain, char *nismap)
 
     /* Free last entry */
     if (val) {
-	free(val);
-	val = NULL;
+        free(val);
+        val = NULL;
     }
 
     /* Get NIS entry */
     res = yp_match(nisdomain, nismap, user, strlen(user), &val, &vallen);
 
     switch (res) {
     case NO_YPERR:
-	/* username = */ (void) strtok(val, ":");
-	password = strtok(NULL, ",:");
-	return password;
+        /* username = */
+        (void) strtok(val, ":");
+        password = strtok(NULL, ",:");
+        return password;
     case YPERR_YPBIND:
-	syslog(LOG_ERR, "Squid Authentication through ypbind failure: can't communicate with ypbind");
-	return NULL;
+        syslog(LOG_ERR, "Squid Authentication through ypbind failure: can't communicate with ypbind");
+        return NULL;
     case YPERR_KEY:		/* No such key in map */
-	return NULL;
+        return NULL;
     default:
-	return NULL;
+        return NULL;
     }
 }
@@ -1 +1 @@
-extern char * get_nis_password(char *user, char *nisdomain, char *nismap);
+extern char * get_nis_password(char *user, char *nisdomain, char *nismap);
@@ -43,42 +43,42 @@ main(int argc, char **argv)
     setbuf(stdout, NULL);
 
     if (argc != 3) {
-	fprintf(stderr, "Usage: yp_auth <domainname> <nis map for password>\n");
-	fprintf(stderr, "\n");
-	fprintf(stderr, "Example yp_auth mydomain.com passwd.byname\n");
-	exit(1);
+        fprintf(stderr, "Usage: yp_auth <domainname> <nis map for password>\n");
+        fprintf(stderr, "\n");
+        fprintf(stderr, "Example yp_auth mydomain.com passwd.byname\n");
+        exit(1);
     }
     nisdomain = argv[1];
     nismap = argv[2];
 
     while (fgets(buf, 256, stdin) != NULL) {
-	if ((p = strchr(buf, '\n')) != NULL)
-	    *p = '\0';		/* strip \n */
+        if ((p = strchr(buf, '\n')) != NULL)
+            *p = '\0';		/* strip \n */
 
-	if ((user = strtok(buf, " ")) == NULL) {
-	    printf("ERR\n");
-	    continue;
-	}
-	if ((passwd = strtok(NULL, "")) == NULL) {
-	    printf("ERR\n");
-	    continue;
-	}
+        if ((user = strtok(buf, " ")) == NULL) {
+            printf("ERR\n");
+            continue;
+        }
+        if ((passwd = strtok(NULL, "")) == NULL) {
+            printf("ERR\n");
+            continue;
+        }
 
-	rfc1738_unescape(user);
-	rfc1738_unescape(passwd);
+        rfc1738_unescape(user);
+        rfc1738_unescape(passwd);
 
-	nispasswd = get_nis_password(user, nisdomain, nismap);
+        nispasswd = get_nis_password(user, nisdomain, nismap);
 
-	if (!nispasswd) {
-	    /* User does not exist */
-	    printf("ERR No such user\n");
-	} else if (strcmp(nispasswd, (char *) crypt(passwd, nispasswd)) == 0) {
-	    /* All ok !, thanks... */
-	    printf("OK\n");
-	} else {
-	    /* Password incorrect */
-	    printf("ERR Wrong password\n");
-	}
+        if (!nispasswd) {
+            /* User does not exist */
+            printf("ERR No such user\n");
+        } else if (strcmp(nispasswd, (char *) crypt(passwd, nispasswd)) == 0) {
+            /* All ok !, thanks... */
+            printf("OK\n");
+        } else {
+            /* Password incorrect */
+            printf("ERR Wrong password\n");
+        }
     }
     exit(0);
 }
@@ -10,15 +10,15 @@
  *
  * Uses getpwnam() routines for authentication.
  * This has the following advantages over the NCSA module:
- * 
+ *
  * - Allow authentication of all know local users
  * - Allows authentication through nsswitch.conf
  *   + can handle NIS(+) requests
  *   + can handle LDAP request
  *   + can handle PAM request
  *
  * 2006-07: Giancarlo Razzolini <linux-fan@onda.com.br>
- * 
+ *
  * Added functionality for doing shadow authentication too,
  * using the getspnam() function on systems that support it.
  *
@@ -53,36 +53,36 @@
 #define ERR    "ERR\n"
 #define OK     "OK\n"
 
-static int 
+static int
 passwd_auth(char *user, char *passwd)
 {
     struct passwd *pwd;
     pwd = getpwnam(user);
     if (pwd == NULL) {
-	return 0;		/* User does not exist */
+        return 0;		/* User does not exist */
     } else {
-	if (strcmp(pwd->pw_passwd, (char *) crypt(passwd, pwd->pw_passwd))) {
-	    return 2;		/* Wrong password */
-	} else {
-	    return 1;		/* Authentication Sucessful */
-	}
+        if (strcmp(pwd->pw_passwd, (char *) crypt(passwd, pwd->pw_passwd))) {
+            return 2;		/* Wrong password */
+        } else {
+            return 1;		/* Authentication Sucessful */
+        }
     }
 }
 
 #if HAVE_SHADOW_H
-static int 
+static int
 shadow_auth(char *user, char *passwd)
 {
     struct spwd *pwd;
     pwd = getspnam(user);
     if (pwd == NULL) {
-	return passwd_auth(user, passwd);	/* Fall back to passwd_auth */
+        return passwd_auth(user, passwd);	/* Fall back to passwd_auth */
     } else {
-	if (strcmp(pwd->sp_pwdp, crypt(passwd, pwd->sp_pwdp))) {
-	    return 2;		/* Wrong password */
-	} else {
-	    return 1;		/* Authentication Sucessful */
-	}
+        if (strcmp(pwd->sp_pwdp, crypt(passwd, pwd->sp_pwdp))) {
+            return 2;		/* Wrong password */
+        } else {
+            return 1;		/* Authentication Sucessful */
+        }
     }
 }
 #endif
@@ -97,33 +97,33 @@ main(int argc, char **argv)
     setbuf(stdout, NULL);
     while (fgets(buf, 256, stdin) != NULL) {
 
-	if ((p = strchr(buf, '\n')) != NULL)
-	    *p = '\0';		/* strip \n */
+        if ((p = strchr(buf, '\n')) != NULL)
+            *p = '\0';		/* strip \n */
 
-	if ((user = strtok(buf, " ")) == NULL) {
-	    printf(ERR);
-	    continue;
-	}
-	if ((passwd = strtok(NULL, "")) == NULL) {
-	    printf(ERR);
-	    continue;
-	}
-	rfc1738_unescape(user);
-	rfc1738_unescape(passwd);
+        if ((user = strtok(buf, " ")) == NULL) {
+            printf(ERR);
+            continue;
+        }
+        if ((passwd = strtok(NULL, "")) == NULL) {
+            printf(ERR);
+            continue;
+        }
+        rfc1738_unescape(user);
+        rfc1738_unescape(passwd);
 #if HAVE_SHADOW_H
-	auth = shadow_auth(user, passwd);
+        auth = shadow_auth(user, passwd);
 #else
-	auth = passwd_auth(user, passwd);
+        auth = passwd_auth(user, passwd);
 #endif
-	if (auth == 0) {
-	    printf("ERR No such user\n");
-	} else {
-	    if (auth == 2) {
-		printf("ERR Wrong password\n");
-	    } else {
-		printf(OK);
-	    }
-	}
+        if (auth == 0) {
+            printf("ERR No such user\n");
+        } else {
+            if (auth == 2) {
+                printf("ERR Wrong password\n");
+            } else {
+                printf(OK);
+            }
+        }
     }
     exit(0);
 }
@@ -18,15 +18,15 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- 
+
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
 */
 
 #include "config.h"
-#include <stdio.h> 	 
-#include <getopt.h> 	 
+#include <stdio.h>
+#include <getopt.h>
 #include "util.h"
 
 /* Check if we try to compile on a Windows Platform */
@@ -53,51 +53,51 @@ void
 usage()
 {
     fprintf(stderr,
-	"%s usage:\n%s [-A|D UserGroup][-O DefaultDomain][-d]\n"
-	"-A can specify a Windows Local Group name allowed to authenticate\n"
-	"-D can specify a Windows Local Group name not allowed to authenticate\n"
-	"-O can specify the default Domain against to authenticate\n"
-	"-d enable debugging.\n"
-	"-h this message\n\n",
-	my_program_name, my_program_name);
+            "%s usage:\n%s [-A|D UserGroup][-O DefaultDomain][-d]\n"
+            "-A can specify a Windows Local Group name allowed to authenticate\n"
+            "-D can specify a Windows Local Group name not allowed to authenticate\n"
+            "-O can specify the default Domain against to authenticate\n"
+            "-d enable debugging.\n"
+            "-h this message\n\n",
+            my_program_name, my_program_name);
 }
 
 void
 process_options(int argc, char *argv[])
 {
     int opt, had_error = 0;
     while (-1 != (opt = getopt(argc, argv, "dhA:D:O:"))) {
-	switch (opt) {
-	case 'A':
-	    safe_free(NTAllowedGroup);
-	    NTAllowedGroup=xstrdup(optarg);
-	    UseAllowedGroup = 1;
-	    break;
-	case 'D':
-	    safe_free(NTDisAllowedGroup);
-	    NTDisAllowedGroup=xstrdup(optarg);
-	    UseDisallowedGroup = 1;
-	    break;
-	case 'O':
-	    strncpy(Default_NTDomain, optarg, DNLEN);
-	    break;
-	case 'd':
-	    debug_enabled = 1;
-	    break;
-	case 'h':
-	    usage(argv[0]);
-	    exit(0);
-	case '?':
-	    opt = optopt;
-	    /* fall thru to default */
-	default:
-	    fprintf(stderr, "Unknown option: -%c. Exiting\n", opt);
-	    had_error = 1;
-	}
+        switch (opt) {
+        case 'A':
+            safe_free(NTAllowedGroup);
+            NTAllowedGroup=xstrdup(optarg);
+            UseAllowedGroup = 1;
+            break;
+        case 'D':
+            safe_free(NTDisAllowedGroup);
+            NTDisAllowedGroup=xstrdup(optarg);
+            UseDisallowedGroup = 1;
+            break;
+        case 'O':
+            strncpy(Default_NTDomain, optarg, DNLEN);
+            break;
+        case 'd':
+            debug_enabled = 1;
+            break;
+        case 'h':
+            usage(argv[0]);
+            exit(0);
+        case '?':
+            opt = optopt;
+            /* fall thru to default */
+        default:
+            fprintf(stderr, "Unknown option: -%c. Exiting\n", opt);
+            had_error = 1;
+        }
     }
     if (had_error) {
-	usage();
-	exit(1);
+        usage();
+        exit(1);
     }
 }
 
@@ -121,62 +121,62 @@ main(int argc, char **argv)
     debug("%s build " __DATE__ ", " __TIME__ " starting up...\n", my_program_name);
 
     if (LoadSecurityDll(SSP_BASIC, NTLM_PACKAGE_NAME) == NULL) {
-	fprintf(stderr, "FATAL, can't initialize SSPI, exiting.\n");
-	exit(1);
+        fprintf(stderr, "FATAL, can't initialize SSPI, exiting.\n");
+        exit(1);
     }
     debug("SSPI initialized OK\n");
 
     atexit(UnloadSecurityDll);
 
-        /* initialize FDescs */
+    /* initialize FDescs */
     setbuf(stdout, NULL);
     setbuf(stderr, NULL);
 
     while (1) {
-	/* Read whole line from standard input. Terminate on break. */
-	if (fgets(wstr, 255, stdin) == NULL)
-	    break;
-
-	if (NULL == strchr(wstr, '\n')) {
-	    err = 1;
-	    continue;
-	}
-	if (err) {
-	    fprintf(stderr, "Oversized message\n");
+        /* Read whole line from standard input. Terminate on break. */
+        if (fgets(wstr, 255, stdin) == NULL)
+            break;
+
+        if (NULL == strchr(wstr, '\n')) {
+            err = 1;
+            continue;
+        }
+        if (err) {
+            fprintf(stderr, "Oversized message\n");
             puts("ERR");
-	    goto error;
-	}
-	
-	if ((p = strchr(wstr, '\n')) != NULL)
-	    *p = '\0';		/* strip \n */
-	if ((p = strchr(wstr, '\r')) != NULL)
-	    *p = '\0';		/* strip \r */
-	/* Clear any current settings */
-	username[0] = '\0';
-	password[0] = '\0';
-	sscanf(wstr, "%s %s", username, password);	/* Extract parameters */
+            goto error;
+        }
+
+        if ((p = strchr(wstr, '\n')) != NULL)
+            *p = '\0';		/* strip \n */
+        if ((p = strchr(wstr, '\r')) != NULL)
+            *p = '\0';		/* strip \r */
+        /* Clear any current settings */
+        username[0] = '\0';
+        password[0] = '\0';
+        sscanf(wstr, "%s %s", username, password);	/* Extract parameters */
 
         debug("Got %s from Squid\n", wstr);
 
-	/* Check for invalid or blank entries */
-	if ((username[0] == '\0') || (password[0] == '\0')) {
-	    fprintf(stderr, "Invalid Request\n");
-	    puts("ERR");
-	    fflush(stdout);
-	    continue;
-	}
-	rfc1738_unescape(username);
-	rfc1738_unescape(password);
+        /* Check for invalid or blank entries */
+        if ((username[0] == '\0') || (password[0] == '\0')) {
+            fprintf(stderr, "Invalid Request\n");
+            puts("ERR");
+            fflush(stdout);
+            continue;
+        }
+        rfc1738_unescape(username);
+        rfc1738_unescape(password);
 
         debug("Trying to validate; %s %s\n", username, password);
 
-	if (Valid_User(username, password, NTGroup) == NTV_NO_ERROR)
-	    puts("OK");
-	else
+        if (Valid_User(username, password, NTGroup) == NTV_NO_ERROR)
+            puts("OK");
+        else
             printf("ERR %s\n", errormsg);
 error:
-	err = 0;
-	fflush(stdout);
+        err = 0;
+        fflush(stdout);
     }
     return 0;
 }
@@ -20,7 +20,7 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- 
+
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
@@ -63,52 +63,52 @@ Valid_Group(char *UserName, char *Group)
     DWORD i;
     DWORD dwTotalCount = 0;
 
-/* Convert ANSI User Name and Group to Unicode */
+    /* Convert ANSI User Name and Group to Unicode */
 
     MultiByteToWideChar(CP_ACP, 0, UserName,
-	strlen(UserName) + 1, wszUserName,
-	sizeof(wszUserName) / sizeof(wszUserName[0]));
+                        strlen(UserName) + 1, wszUserName,
+                        sizeof(wszUserName) / sizeof(wszUserName[0]));
     MultiByteToWideChar(CP_ACP, 0, Group,
-	strlen(Group) + 1, wszGroup, sizeof(wszGroup) / sizeof(wszGroup[0]));
+                        strlen(Group) + 1, wszGroup, sizeof(wszGroup) / sizeof(wszGroup[0]));
 
     /*
-     * Call the NetUserGetLocalGroups function 
-	 * specifying information level 0.
-	 * 
-	 * The LG_INCLUDE_INDIRECT flag specifies that the 
-	 * function should also return the names of the local 
-	 * groups in which the user is indirectly a member.
-	 */
-	nStatus = NetUserGetLocalGroups(NULL,
-	    wszUserName,
-	    dwLevel,
-	    dwFlags,
-	    (LPBYTE *) & pBuf, dwPrefMaxLen, &dwEntriesRead, &dwTotalEntries);
-	/*
-	 * If the call succeeds,
-	 */
+     * Call the NetUserGetLocalGroups function
+     * specifying information level 0.
+     *
+     * The LG_INCLUDE_INDIRECT flag specifies that the
+     * function should also return the names of the local
+     * groups in which the user is indirectly a member.
+     */
+    nStatus = NetUserGetLocalGroups(NULL,
+                                    wszUserName,
+                                    dwLevel,
+                                    dwFlags,
+                                    (LPBYTE *) & pBuf, dwPrefMaxLen, &dwEntriesRead, &dwTotalEntries);
+    /*
+     * If the call succeeds,
+     */
     if (nStatus == NERR_Success) {
-	if ((pTmpBuf = pBuf) != NULL) {
-	    for (i = 0; i < dwEntriesRead; i++) {
-		if (pTmpBuf == NULL) {
-		    result = FALSE;
-		    break;
-		}
-		if (wcscmp(pTmpBuf->lgrui0_name, wszGroup) == 0) {
-		    result = TRUE;
-		    break;
-		}
-		pTmpBuf++;
-		dwTotalCount++;
-	    }
-	}
+        if ((pTmpBuf = pBuf) != NULL) {
+            for (i = 0; i < dwEntriesRead; i++) {
+                if (pTmpBuf == NULL) {
+                    result = FALSE;
+                    break;
+                }
+                if (wcscmp(pTmpBuf->lgrui0_name, wszGroup) == 0) {
+                    result = TRUE;
+                    break;
+                }
+                pTmpBuf++;
+                dwTotalCount++;
+            }
+        }
     } else
-	    result = FALSE;
-/*
- * Free the allocated memory.
- */
+        result = FALSE;
+    /*
+     * Free the allocated memory.
+     */
     if (pBuf != NULL)
-	NetApiBufferFree(pBuf);
+        NetApiBufferFree(pBuf);
     return result;
 }
 
@@ -137,40 +137,40 @@ Valid_User(char *UserName, char *Password, char *Group)
             break;
     }
     if (domain_qualify == NULL) {
-	strcpy(User, NTDomain);
-	strcpy(NTDomain, Default_NTDomain);
+        strcpy(User, NTDomain);
+        strcpy(NTDomain, Default_NTDomain);
     } else {
-	strcpy(User, domain_qualify + 1);
-	domain_qualify[0] = '\0';
+        strcpy(User, domain_qualify + 1);
+        domain_qualify[0] = '\0';
     }
     /* Log the client on to the local computer. */
     if (!SSP_LogonUser(User, Password, NTDomain)) {
-	result = NTV_LOGON_ERROR;
+        result = NTV_LOGON_ERROR;
         errormsg = NTV_LOGON_ERROR_MSG;
         debug("%s\n", errormsg);
     } else {
-	result = NTV_NO_ERROR;
-	if (strcmp(NTDomain, NTV_DEFAULT_DOMAIN) == 0)
-	    strcpy(DomainUser, User);
-	else {
-	    strcpy(DomainUser, NTDomain);
-	    strcat(DomainUser, "\\");
-	    strcat(DomainUser, User);
-	}
-	if (UseAllowedGroup) {
-	    if (!Valid_Group(DomainUser, NTAllowedGroup)) {
-		result = NTV_GROUP_ERROR;
+        result = NTV_NO_ERROR;
+        if (strcmp(NTDomain, NTV_DEFAULT_DOMAIN) == 0)
+            strcpy(DomainUser, User);
+        else {
+            strcpy(DomainUser, NTDomain);
+            strcat(DomainUser, "\\");
+            strcat(DomainUser, User);
+        }
+        if (UseAllowedGroup) {
+            if (!Valid_Group(DomainUser, NTAllowedGroup)) {
+                result = NTV_GROUP_ERROR;
                 errormsg = NTV_GROUP_ERROR_MSG;
                 debug("%s\n", errormsg);
-	    }
-	}
-	if (UseDisallowedGroup) {
-	    if (Valid_Group(DomainUser, NTDisAllowedGroup)) {
-		result = NTV_GROUP_ERROR;
+            }
+        }
+        if (UseDisallowedGroup) {
+            if (Valid_Group(DomainUser, NTDisAllowedGroup)) {
+                result = NTV_GROUP_ERROR;
                 errormsg = NTV_GROUP_ERROR_MSG;
                 debug("%s\n", errormsg);
-	    }
-	}
+            }
+        }
     }
     return result;
 }
@@ -19,7 +19,7 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- 
+
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
@@ -85,17 +85,17 @@ static char *__foo;
 #endif /* DEBUG */
 #else /* __GNUC__ */
 static void
-debug(char *format,...) 
+debug(char *format,...)
 {
 #ifdef DEBUG
 #ifdef _SQUID_MSWIN_
     if (debug_enabled) {
-	va_list args;
+        va_list args;
 
-	va_start(args,format);
-	fprintf(stderr, "nt_auth[%d]: ",getpid());
-	vfprintf(stderr, format, args);
-	va_end(args);
+        va_start(args,format);
+        fprintf(stderr, "nt_auth[%d]: ",getpid());
+        vfprintf(stderr, format, args);
+        va_end(args);
     }
 #endif /* _SQUID_MSWIN_ */
 #endif /* DEBUG */
@@ -19,7 +19,7 @@
  *	in advertising or publicity pertaining to distribution of the
  *	program without specific prior permission, and notice be given
  *	in supporting documentation that copying and distribution is by
- *	permission of Livingston Enterprises, Inc.   
+ *	permission of Livingston Enterprises, Inc.
  *
  *	Livingston Enterprises, Inc. makes no representations about
  *	the suitability of this software for any purpose.  It is
@@ -33,8 +33,8 @@
  */
 
 char util_sccsid[] =
-"@(#)util.c	1.5 Copyright 1992 Livingston Enterprises Inc\n"
-"		2.1 Copyright 1997 Cistron Internet Services B.V.";
+    "@(#)util.c	1.5 Copyright 1992 Livingston Enterprises Inc\n"
+    "		2.1 Copyright 1997 Cistron Internet Services B.V.";
 
 #include	"config.h"
 
@@ -81,33 +81,30 @@ char util_sccsid[] =
  */
 static int good_ipaddr(char *addr)
 {
-	int	dot_count;
-	int	digit_count;
+    int	dot_count;
+    int	digit_count;
 
-	dot_count = 0;
-	digit_count = 0;
-	while(*addr != '\0' && *addr != ' ') {
-		if(*addr == '.') {
-			dot_count++;
-			digit_count = 0;
-		}
-		else if(!isdigit(*addr)) {
-			dot_count = 5;
-		}
-		else {
-			digit_count++;
-			if(digit_count > 3) {
-				dot_count = 5;
-			}
-		}
-		addr++;
-	}
-	if(dot_count != 3) {
-		return(-1);
-	}
-	else {
-		return(0);
-	}
+    dot_count = 0;
+    digit_count = 0;
+    while (*addr != '\0' && *addr != ' ') {
+        if (*addr == '.') {
+            dot_count++;
+            digit_count = 0;
+        } else if (!isdigit(*addr)) {
+            dot_count = 5;
+        } else {
+            digit_count++;
+            if (digit_count > 3) {
+                dot_count = 5;
+            }
+        }
+        addr++;
+    }
+    if (dot_count != 3) {
+        return(-1);
+    } else {
+        return(0);
+    }
 }
 
 /*
@@ -116,37 +113,37 @@ static int good_ipaddr(char *addr)
  */
 static u_int32_t ipstr2long(char *ip_str)
 {
-	char	buf[6];
-	char	*ptr;
-	int	i;
-	int	count;
-	u_int32_t	ipaddr;
-	int	cur_byte;
+    char	buf[6];
+    char	*ptr;
+    int	i;
+    int	count;
+    u_int32_t	ipaddr;
+    int	cur_byte;
 
-	ipaddr = (u_int32_t)0;
-	for(i = 0;i < 4;i++) {
-		ptr = buf;
-		count = 0;
-		*ptr = '\0';
-		while(*ip_str != '.' && *ip_str != '\0' && count < 4) {
-			if(!isdigit(*ip_str)) {
-				return((u_int32_t)0);
-			}
-			*ptr++ = *ip_str++;
-			count++;
-		}
-		if(count >= 4 || count == 0) {
-			return((u_int32_t)0);
-		}
-		*ptr = '\0';
-		cur_byte = atoi(buf);
-		if(cur_byte < 0 || cur_byte > 255) {
-			return((u_int32_t)0);
-		}
-		ip_str++;
-		ipaddr = ipaddr << 8 | (u_int32_t)cur_byte;
-	}
-	return(ipaddr);
+    ipaddr = (u_int32_t)0;
+    for (i = 0;i < 4;i++) {
+        ptr = buf;
+        count = 0;
+        *ptr = '\0';
+        while (*ip_str != '.' && *ip_str != '\0' && count < 4) {
+            if (!isdigit(*ip_str)) {
+                return((u_int32_t)0);
+            }
+            *ptr++ = *ip_str++;
+            count++;
+        }
+        if (count >= 4 || count == 0) {
+            return((u_int32_t)0);
+        }
+        *ptr = '\0';
+        cur_byte = atoi(buf);
+        if (cur_byte < 0 || cur_byte > 255) {
+            return((u_int32_t)0);
+        }
+        ip_str++;
+        ipaddr = ipaddr << 8 | (u_int32_t)cur_byte;
+    }
+    return(ipaddr);
 }
 
 /*
@@ -155,23 +152,22 @@ static u_int32_t ipstr2long(char *ip_str)
  */
 u_int32_t get_ipaddr(char *host)
 {
-	struct hostent	*hp;
+    struct hostent	*hp;
 
-	if(good_ipaddr(host) == 0) {
-		return(ipstr2long(host));
-	}
-	else if((hp = gethostbyname(host)) == (struct hostent *)NULL) {
-		return((u_int32_t)0);
-	}
-	return(ntohl(*(u_int32_t *)hp->h_addr));
+    if (good_ipaddr(host) == 0) {
+        return(ipstr2long(host));
+    } else if ((hp = gethostbyname(host)) == (struct hostent *)NULL) {
+        return((u_int32_t)0);
+    }
+    return(ntohl(*(u_int32_t *)hp->h_addr));
 }
 
 
 void md5_calc(unsigned char *output, unsigned char *input, unsigned int inlen)
 {
-	SquidMD5_CTX	context;
+    SquidMD5_CTX	context;
 
-	SquidMD5Init(&context);
-	SquidMD5Update(&context, input, inlen);
-	SquidMD5Final(output, &context);
+    SquidMD5Init(&context);
+    SquidMD5Update(&context, input, inlen);
+    SquidMD5Final(output, &context);
 }
@@ -17,7 +17,7 @@
  *	in advertising or publicity pertaining to distribution of the
  *	program without specific prior permission, and notice be given
  *	in supporting documentation that copying and distribution is by
- *	permission of Livingston Enterprises, Inc.   
+ *	permission of Livingston Enterprises, Inc.
  *
  *	Livingston Enterprises, Inc. makes no representations about
  *	the suitability of this software for any purpose.  It is
@@ -35,11 +35,11 @@
 
 
 typedef struct pw_auth_hdr {
-	u_char		code;
-	u_char		id;
-	u_short		length;
-	u_char		vector[AUTH_VECTOR_LEN];
-	u_char		data[2];
+    u_char		code;
+    u_char		id;
+    u_short		length;
+    u_char		vector[AUTH_VECTOR_LEN];
+    u_char		data[2];
 } AUTH_HDR;
 
 #define AUTH_HDR_LEN			20
@@ -16,7 +16,7 @@
  *      in advertising or publicity pertaining to distribution of the
  *      program without specific prior permission, and notice be given
  *      in supporting documentation that copying and distribution is by
- *      permission of Livingston Enterprises, Inc.   
+ *      permission of Livingston Enterprises, Inc.
  *
  *      Livingston Enterprises, Inc. makes no representations about
  *      the suitability of this software for any purpose.  It is
@@ -187,14 +187,14 @@ result_recv(u_int32_t host, u_short udp_port, char *buffer, int length)
     totallen = ntohs(auth->length);
 
     if (totallen != length) {
-	fprintf(stderr,
-	    "Squid_rad_auth: Received invalid reply length from server (want %d/ got %d)\n",
-	    totallen, length);
-	return -1;
+        fprintf(stderr,
+                "Squid_rad_auth: Received invalid reply length from server (want %d/ got %d)\n",
+                totallen, length);
+        return -1;
     }
     if (auth->id != request_id) {
-	/* Duplicate response of an earlier query, ignore */
-	return -1;
+        /* Duplicate response of an earlier query, ignore */
+        return -1;
     }
     /* Verify the reply digest */
     memcpy(reply_digest, auth->vector, AUTH_VECTOR_LEN);
@@ -204,11 +204,11 @@ result_recv(u_int32_t host, u_short udp_port, char *buffer, int length)
     md5_calc(calc_digest, (unsigned char *) auth, length + secretlen);
 
     if (memcmp(reply_digest, calc_digest, AUTH_VECTOR_LEN) != 0) {
-	fprintf(stderr, "Warning: Received invalid reply digest from server\n");
-	return -1;
+        fprintf(stderr, "Warning: Received invalid reply digest from server\n");
+        return -1;
     }
     if (auth->code != PW_AUTHENTICATION_ACK)
-	return 1;
+        return 1;
 
     return 0;
 }
@@ -225,10 +225,10 @@ random_vector(char *vector)
 
     srand((time(0) ^ rand()) + rand());
     for (i = 0; i < AUTH_VECTOR_LEN;) {
-	randno = rand();
-	memcpy(vector, &randno, sizeof(int));
-	vector += sizeof(int);
-	i += sizeof(int);
+        randno = rand();
+        memcpy(vector, &randno, sizeof(int));
+        vector += sizeof(int);
+        i += sizeof(int);
     }
 }
 
@@ -247,23 +247,23 @@ rad_auth_config(const char *cfname)
     int srv = 0, crt = 0;
 
     if ((cf = fopen(cfname, "r")) == NULL) {
-	perror(cfname);
-	return -1;
+        perror(cfname);
+        return -1;
     }
     while (fgets(line, MAXLINE, cf) != NULL) {
-	if (!memcmp(line, "server", 6))
-	    srv = sscanf(line, "server %s", server);
-	if (!memcmp(line, "secret", 6))
-	    crt = sscanf(line, "secret %s", secretkey);
-	if (!memcmp(line, "identifier", 10))
-	    sscanf(line, "identifier %s", identifier);
-	if (!memcmp(line, "service", 7))
-	    sscanf(line, "service %s", svc_name);
-	if (!memcmp(line, "port", 4))
-	    sscanf(line, "port %s", svc_name);
+        if (!memcmp(line, "server", 6))
+            srv = sscanf(line, "server %s", server);
+        if (!memcmp(line, "secret", 6))
+            crt = sscanf(line, "secret %s", secretkey);
+        if (!memcmp(line, "identifier", 10))
+            sscanf(line, "identifier %s", identifier);
+        if (!memcmp(line, "service", 7))
+            sscanf(line, "service %s", svc_name);
+        if (!memcmp(line, "port", 4))
+            sscanf(line, "port %s", svc_name);
     }
     if (srv && crt)
-	return 0;
+        return 0;
     return -1;
 }
 
@@ -273,15 +273,15 @@ urldecode(char *dst, const char *src, int size)
     char tmp[3];
     tmp[2] = '\0';
     while (*src && size > 1) {
-	if (*src == '%' && src[1] != '\0' && src[2] != '\0') {
-	    src++;
-	    tmp[0] = *src++;
-	    tmp[1] = *src++;
-	    *dst++ = strtol(tmp, NULL, 16);
-	} else {
-	    *dst++ = *src++;
-	}
-	size--;
+        if (*src == '%' && src[1] != '\0' && src[2] != '\0') {
+            src++;
+            tmp[0] = *src++;
+            tmp[1] = *src++;
+            *dst++ = strtol(tmp, NULL, 16);
+        } else {
+            *dst++ = *src++;
+        }
+        size--;
     }
     *dst++ = '\0';
 }
@@ -321,7 +321,7 @@ authenticate(int sockfd, const char *username, const char *passwd)
     *ptr++ = PW_USER_NAME;
     length = strlen(username);
     if (length > MAXPWNAM) {
-	length = MAXPWNAM;
+        length = MAXPWNAM;
     }
     *ptr++ = length + 2;
     memcpy(ptr, username, length);
@@ -333,14 +333,14 @@ authenticate(int sockfd, const char *username, const char *passwd)
      */
     length = strlen(passwd);
     if (length > MAXPASS) {
-	length = MAXPASS;
+        length = MAXPASS;
     }
     memset(passbuf, 0, MAXPASS);
     memcpy(passbuf, passwd, length);
 
-    /* 
+    /*
      * Length is rounded up to multiple of 16,
-     * and the password is encoded in blocks of 16 
+     * and the password is encoded in blocks of 16
      * with cipher block chaining
      */
     length = ((length / AUTH_VECTOR_LEN) + 1) * AUTH_VECTOR_LEN;
@@ -352,15 +352,15 @@ authenticate(int sockfd, const char *username, const char *passwd)
     /* Set up the Cipher block chain */
     memcpy(cbc, auth->vector, AUTH_VECTOR_LEN);
     for (j = 0; j < length; j += AUTH_VECTOR_LEN) {
-	/* Calculate the MD5 Digest */
-	strcpy((char *) md5buf, secretkey);
-	memcpy(md5buf + secretlen, cbc, AUTH_VECTOR_LEN);
-	md5_calc(cbc, md5buf, secretlen + AUTH_VECTOR_LEN);
-
-	/* Xor the password into the MD5 digest */
-	for (i = 0; i < AUTH_VECTOR_LEN; i++) {
-	    *ptr++ = (cbc[i] ^= passbuf[j + i]);
-	}
+        /* Calculate the MD5 Digest */
+        strcpy((char *) md5buf, secretkey);
+        memcpy(md5buf + secretlen, cbc, AUTH_VECTOR_LEN);
+        md5_calc(cbc, md5buf, secretlen + AUTH_VECTOR_LEN);
+
+        /* Xor the password into the MD5 digest */
+        for (i = 0; i < AUTH_VECTOR_LEN; i++) {
+            *ptr++ = (cbc[i] ^= passbuf[j + i]);
+        }
     }
     total_length += length + 2;
 
@@ -381,66 +381,66 @@ authenticate(int sockfd, const char *username, const char *passwd)
     total_length += 6;
 
     if (*identifier) {
-	int len = strlen(identifier);
-	*ptr++ = PW_NAS_ID;
-	*ptr++ = len + 2;
-	memcpy(ptr, identifier, len);
-	ptr += len;
+        int len = strlen(identifier);
+        *ptr++ = PW_NAS_ID;
+        *ptr++ = len + 2;
+        memcpy(ptr, identifier, len);
+        ptr += len;
     } else {
-	*ptr++ = PW_NAS_IP_ADDRESS;
-	*ptr++ = 6;
+        *ptr++ = PW_NAS_IP_ADDRESS;
+        *ptr++ = 6;
 
-	ui = htonl(nas_ipaddr);
-	memcpy(ptr, &ui, 4);
-	ptr += 4;
-	total_length += 6;
+        ui = htonl(nas_ipaddr);
+        memcpy(ptr, &ui, 4);
+        ptr += 4;
+        total_length += 6;
     }
 
     /* Klaus Weidner <kw@w-m-p.com> changed this
      * from htonl to htons. It might have caused
      * you trouble or not. That depends on the byte
      * order of your system.
      * The symptom was that the radius server
-     * ignored the requests, because they had zero 
+     * ignored the requests, because they had zero
      * length according to the data header.
      */
     auth->length = htons(total_length);
 
     while (retry--) {
-	int time_spent;
-	struct timeval sent;
-	/*
-	 *    Send the request we've built.
-	 */
-	gettimeofday(&sent, NULL);
-	send(sockfd, (char *) auth, total_length, 0);
-	while ((time_spent = time_since(&sent)) < 1000000) {
-	    struct timeval tv;
-	    int rc, len;
-	    if (!time_spent) {
-		tv.tv_sec = 1;
-		tv.tv_usec = 0;
-	    } else {
-		tv.tv_sec = 0;
-		tv.tv_usec = 1000000 - time_spent;
-	    }
-	    FD_ZERO(&readfds);
-	    FD_SET(sockfd, &readfds);
-	    if (select(sockfd + 1, &readfds, NULL, NULL, &tv) == 0)	/* Select timeout */
-		break;
-	    salen = sizeof(saremote);
-	    len = recvfrom(sockfd, recv_buffer, sizeof(i_recv_buffer),
-		0, (struct sockaddr *) &saremote, &salen);
-
-	    if (len < 0)
-		continue;
-
-	    rc = result_recv(saremote.sin_addr.s_addr, saremote.sin_port, recv_buffer, len);
-	    if (rc == 0)
-		return 1;
-	    if (rc == 1)
-		return 0;
-	}
+        int time_spent;
+        struct timeval sent;
+        /*
+         *    Send the request we've built.
+         */
+        gettimeofday(&sent, NULL);
+        send(sockfd, (char *) auth, total_length, 0);
+        while ((time_spent = time_since(&sent)) < 1000000) {
+            struct timeval tv;
+            int rc, len;
+            if (!time_spent) {
+                tv.tv_sec = 1;
+                tv.tv_usec = 0;
+            } else {
+                tv.tv_sec = 0;
+                tv.tv_usec = 1000000 - time_spent;
+            }
+            FD_ZERO(&readfds);
+            FD_SET(sockfd, &readfds);
+            if (select(sockfd + 1, &readfds, NULL, NULL, &tv) == 0)	/* Select timeout */
+                break;
+            salen = sizeof(saremote);
+            len = recvfrom(sockfd, recv_buffer, sizeof(i_recv_buffer),
+                           0, (struct sockaddr *) &saremote, &salen);
+
+            if (len < 0)
+                continue;
+
+            rc = result_recv(saremote.sin_addr.s_addr, saremote.sin_port, recv_buffer, len);
+            if (rc == 0)
+                return 1;
+            if (rc == 1)
+                return 0;
+        }
     }
 
     fprintf(stderr, "%s: No response from RADIUS server\n", progname);
@@ -465,129 +465,129 @@ main(int argc, char **argv)
     int c;
 
     while ((c = getopt(argc, argv, "h:p:f:w:i:t:")) != -1) {
-	switch (c) {
-	case 'f':
-	    cfname = optarg;
-	    break;
-	case 'h':
-	    strcpy(server, optarg);
-	    break;
-	case 'p':
-	    strcpy(svc_name, optarg);
-	    break;
-	case 'w':
-	    strcpy(secretkey, optarg);
-	    break;
-	case 'i':
-	    strcpy(identifier, optarg);
-	    break;
-	case 't':
-	    retries = atoi(optarg);
-	    break;
-	}
+        switch (c) {
+        case 'f':
+            cfname = optarg;
+            break;
+        case 'h':
+            strcpy(server, optarg);
+            break;
+        case 'p':
+            strcpy(svc_name, optarg);
+            break;
+        case 'w':
+            strcpy(secretkey, optarg);
+            break;
+        case 'i':
+            strcpy(identifier, optarg);
+            break;
+        case 't':
+            retries = atoi(optarg);
+            break;
+        }
     }
     /* make standard output line buffered */
     if (setvbuf(stdout, NULL, _IOLBF, 0) != 0)
-	return 1;
+        return 1;
 
     if (cfname) {
-	if (rad_auth_config(cfname) < 0) {
-	    fprintf(stderr, "%s: can't open configuration file '%s'.\n", argv[0], cfname);
-	    exit(1);
-	}
+        if (rad_auth_config(cfname) < 0) {
+            fprintf(stderr, "%s: can't open configuration file '%s'.\n", argv[0], cfname);
+            exit(1);
+        }
     }
     if (!*server) {
-	fprintf(stderr, "%s: Server not specified\n", argv[0]);
-	exit(1);
+        fprintf(stderr, "%s: Server not specified\n", argv[0]);
+        exit(1);
     }
     if (!*secretkey) {
-	fprintf(stderr, "%s: Shared secret not specified\n", argv[0]);
-	exit(1);
+        fprintf(stderr, "%s: Shared secret not specified\n", argv[0]);
+        exit(1);
     }
 #ifdef _SQUID_MSWIN_
     {
-	WSADATA wsaData;
-	WSAStartup(2, &wsaData);
-	atexit(Win32SockCleanup);
+        WSADATA wsaData;
+        WSAStartup(2, &wsaData);
+        atexit(Win32SockCleanup);
     }
 #endif
     /*
      *    Open a connection to the server.
      */
     svp = getservbyname(svc_name, "udp");
     if (svp != NULL)
-	svc_port = ntohs((u_short) svp->s_port);
+        svc_port = ntohs((u_short) svp->s_port);
     else
-	svc_port = atoi(svc_name);
+        svc_port = atoi(svc_name);
     if (svc_port == 0)
-	svc_port = PW_AUTH_UDP_PORT;
+        svc_port = PW_AUTH_UDP_PORT;
 
     /* Get the IP address of the authentication server */
     if ((auth_ipaddr = get_ipaddr(server)) == 0) {
-	fprintf(stderr, "Couldn't find host %s\n", server);
-	exit(1);
+        fprintf(stderr, "Couldn't find host %s\n", server);
+        exit(1);
     }
     sockfd = socket(AF_INET, SOCK_DGRAM, 0);
     if (sockfd < 0) {
-	perror("socket");
-	exit(1);
+        perror("socket");
+        exit(1);
     }
     memset(&saremote, 0, sizeof(saremote));
     saremote.sin_family = AF_INET;
     saremote.sin_addr.s_addr = htonl(auth_ipaddr);
     saremote.sin_port = htons(svc_port);
 
     if (connect(sockfd, (struct sockaddr *) &saremote, sizeof(saremote)) < 0) {
-	perror("connect");
-	exit(1);
+        perror("connect");
+        exit(1);
     }
     salen = sizeof(salocal);
     if (getsockname(sockfd, (struct sockaddr *) &salocal, &salen) < 0) {
-	perror("getsockname");
-	exit(1);
+        perror("getsockname");
+        exit(1);
     }
 #ifdef O_NONBLOCK
     fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL, 0) | O_NONBLOCK);
 #endif
     nas_ipaddr = ntohl(salocal.sin_addr.s_addr);
     while (fgets(authstring, MAXLINE, stdin) != NULL) {
-	char *end;
-	/* protect me form to long lines */
-	if ((end = strchr(authstring, '\n')) == NULL) {
-	    err = 1;
-	    continue;
-	}
-	if (err) {
-	    printf("ERR\n");
-	    err = 0;
-	    continue;
-	}
-	if (strlen(authstring) > MAXLINE) {
-	    printf("ERR\n");
-	    continue;
-	}
-	/* Strip off the trailing newline */
-	*end = '\0';
-
-	/* Parse out the username and password */
-	ptr = authstring;
-	while (isspace(*ptr))
-	    ptr++;
-	if ((end = strchr(ptr, ' ')) == NULL) {
-	    printf("ERR\n");	/* No password */
-	    continue;
-	}
-	*end = '\0';
-	urldecode(username, ptr, MAXPWNAM);
-	ptr = end + 1;
-	while (isspace(*ptr))
-	    ptr++;
-	urldecode(passwd, ptr, MAXPASS);
-
-	if (authenticate(sockfd, username, passwd))
-	    printf("OK\n");
-	else
-	    printf("ERR\n");
+        char *end;
+        /* protect me form to long lines */
+        if ((end = strchr(authstring, '\n')) == NULL) {
+            err = 1;
+            continue;
+        }
+        if (err) {
+            printf("ERR\n");
+            err = 0;
+            continue;
+        }
+        if (strlen(authstring) > MAXLINE) {
+            printf("ERR\n");
+            continue;
+        }
+        /* Strip off the trailing newline */
+        *end = '\0';
+
+        /* Parse out the username and password */
+        ptr = authstring;
+        while (isspace(*ptr))
+            ptr++;
+        if ((end = strchr(ptr, ' ')) == NULL) {
+            printf("ERR\n");	/* No password */
+            continue;
+        }
+        *end = '\0';
+        urldecode(username, ptr, MAXPWNAM);
+        ptr = end + 1;
+        while (isspace(*ptr))
+            ptr++;
+        urldecode(passwd, ptr, MAXPASS);
+
+        if (authenticate(sockfd, username, passwd))
+            printf("OK\n");
+        else
+            printf("ERR\n");
     }
     close(sockfd);
     exit(1);
@@ -53,8 +53,8 @@ typedef struct _request_data {
     int error;
 } RequestData;
 
-/* to use a backend, include your backend.h file 
- * and define thusly: 
+/* to use a backend, include your backend.h file
+ * and define thusly:
  * #define ProcessArguments(A, B) MyHandleArguments(A,B)
  * #define GetHHA1(A) MyGetHHA1(A)
  */
@@ -12,7 +12,7 @@
  * - comment lines are possible and should start with a '#';
  * - empty or blank lines are possible;
  * - file format is username:password
- * 
+ *
  * To build a directory integrated backend, you need to be able to
  * calculate the HA1 returned to squid. To avoid storing a plaintext
  * password you can calculate MD5(username:realm:password) when the
@@ -47,13 +47,13 @@ ParseBuffer(char *buf, RequestData * requestData)
     char *p;
     requestData->parsed = 0;
     if ((p = strchr(buf, '\n')) != NULL)
-	*p = '\0';		/* strip \n */
+        *p = '\0';		/* strip \n */
     if ((requestData->user = strtok(buf, "\"")) == NULL)
-	return;
+        return;
     if ((requestData->realm = strtok(NULL, "\"")) == NULL)
-	return;
+        return;
     if ((requestData->realm = strtok(NULL, "\"")) == NULL)
-	return;
+        return;
     requestData->parsed = -1;
 }
 
@@ -63,8 +63,8 @@ OutputHHA1(RequestData * requestData)
     requestData->error = 0;
     GetHHA1(requestData);
     if (requestData->error) {
-	printf("ERR No such user\n");
-	return;
+        printf("ERR No such user\n");
+        return;
     }
     printf("%s\n", requestData->HHA1);
 }
@@ -75,8 +75,8 @@ DoOneRequest(char *buf)
     RequestData requestData;
     ParseBuffer(buf, &requestData);
     if (!requestData.parsed) {
-	printf("ERR\n");
-	return;
+        printf("ERR\n");
+        return;
     }
     OutputHHA1(&requestData);
 }
@@ -87,7 +87,7 @@ ProcessArguments(int argc, char **argv)
     int i;
     i = LDAPArguments(argc, argv);
     if (i)
-	exit(i);
+        exit(i);
 }
 
 int
@@ -97,6 +97,6 @@ main(int argc, char **argv)
     setbuf(stdout, NULL);
     ProcessArguments(argc, argv);
     while (fgets(buf, 256, stdin) != NULL)
-	DoOneRequest(buf);
+        DoOneRequest(buf);
     exit(0);
 }
@@ -1,26 +1,26 @@
-/* 
+/*
  * NDS LDAP helper functions
  * Copied From Samba-3.0.24 pdb_nds.c and trimmed down to the
  * limited functionality needed to access the plain text password only
  *
  * Original copyright & license follows:
  *
  * Copyright (C) Vince Brimhall			2004-2005
- *   
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- * 
+ *
 */
 
 #include "digest_common.h"
@@ -69,86 +69,73 @@
 **********************************************************************/
 
 static int berEncodePasswordData(
-	struct berval **requestBV,
-	const char    *objectDN,
-	const char    *password,
-	const char    *password2)
+    struct berval **requestBV,
+    const char    *objectDN,
+    const char    *password,
+    const char    *password2)
 {
-	int err = 0, rc=0;
-	BerElement *requestBer = NULL;
-
-	const char    * utf8ObjPtr = NULL;
-	int     utf8ObjSize = 0;
-	const char    * utf8PwdPtr = NULL;
-	int     utf8PwdSize = 0;
-	const char    * utf8Pwd2Ptr = NULL;
-	int     utf8Pwd2Size = 0;
-
-
-	/* Convert objectDN and tag strings from Unicode to UTF-8 */
-	utf8ObjSize = strlen(objectDN)+1;
-	utf8ObjPtr = objectDN;
-
-	if (password != NULL)
-	{
-		utf8PwdSize = strlen(password)+1;
-		utf8PwdPtr = password;
-	}
-
-	if (password2 != NULL)
-	{
-		utf8Pwd2Size = strlen(password2)+1;
-		utf8Pwd2Ptr = password2;
-	}
-
-	/* Allocate a BerElement for the request parameters. */
-	if((requestBer = ber_alloc()) == NULL)
-	{
-		err = LDAP_ENCODING_ERROR;
-		goto Cleanup;
-	}
-
-	if (password != NULL && password2 != NULL)
-	{
-		/* BER encode the NMAS Version, the objectDN, and the password */
-		rc = ber_printf(requestBer, "{iooo}", NMAS_LDAP_EXT_VERSION, utf8ObjPtr, utf8ObjSize, utf8PwdPtr, utf8PwdSize, utf8Pwd2Ptr, utf8Pwd2Size);
-	}
-	else if (password != NULL)
-	{
-		/* BER encode the NMAS Version, the objectDN, and the password */
-		rc = ber_printf(requestBer, "{ioo}", NMAS_LDAP_EXT_VERSION, utf8ObjPtr, utf8ObjSize, utf8PwdPtr, utf8PwdSize);
-	}
-	else
-	{
-		/* BER encode the NMAS Version and the objectDN */
-		rc = ber_printf(requestBer, "{io}", NMAS_LDAP_EXT_VERSION, utf8ObjPtr, utf8ObjSize);
-	}
-
-	if (rc < 0)
-	{
-		err = LDAP_ENCODING_ERROR;
-		goto Cleanup;
-	}
-	else
-	{
-		err = 0;
-	}
-
-	/* Convert the BER we just built to a berval that we'll send with the extended request. */
-	if(ber_flatten(requestBer, requestBV) == LBER_ERROR)
-	{
-		err = LDAP_ENCODING_ERROR;
-		goto Cleanup;
-	}
+    int err = 0, rc=0;
+    BerElement *requestBer = NULL;
+
+    const char    * utf8ObjPtr = NULL;
+    int     utf8ObjSize = 0;
+    const char    * utf8PwdPtr = NULL;
+    int     utf8PwdSize = 0;
+    const char    * utf8Pwd2Ptr = NULL;
+    int     utf8Pwd2Size = 0;
+
+
+    /* Convert objectDN and tag strings from Unicode to UTF-8 */
+    utf8ObjSize = strlen(objectDN)+1;
+    utf8ObjPtr = objectDN;
+
+    if (password != NULL) {
+        utf8PwdSize = strlen(password)+1;
+        utf8PwdPtr = password;
+    }
+
+    if (password2 != NULL) {
+        utf8Pwd2Size = strlen(password2)+1;
+        utf8Pwd2Ptr = password2;
+    }
+
+    /* Allocate a BerElement for the request parameters. */
+    if ((requestBer = ber_alloc()) == NULL) {
+        err = LDAP_ENCODING_ERROR;
+        goto Cleanup;
+    }
+
+    if (password != NULL && password2 != NULL) {
+        /* BER encode the NMAS Version, the objectDN, and the password */
+        rc = ber_printf(requestBer, "{iooo}", NMAS_LDAP_EXT_VERSION, utf8ObjPtr, utf8ObjSize, utf8PwdPtr, utf8PwdSize, utf8Pwd2Ptr, utf8Pwd2Size);
+    } else if (password != NULL) {
+        /* BER encode the NMAS Version, the objectDN, and the password */
+        rc = ber_printf(requestBer, "{ioo}", NMAS_LDAP_EXT_VERSION, utf8ObjPtr, utf8ObjSize, utf8PwdPtr, utf8PwdSize);
+    } else {
+        /* BER encode the NMAS Version and the objectDN */
+        rc = ber_printf(requestBer, "{io}", NMAS_LDAP_EXT_VERSION, utf8ObjPtr, utf8ObjSize);
+    }
+
+    if (rc < 0) {
+        err = LDAP_ENCODING_ERROR;
+        goto Cleanup;
+    } else {
+        err = 0;
+    }
+
+    /* Convert the BER we just built to a berval that we'll send with the extended request. */
+    if (ber_flatten(requestBer, requestBV) == LBER_ERROR) {
+        err = LDAP_ENCODING_ERROR;
+        goto Cleanup;
+    }
 
 Cleanup:
 
-	if(requestBer)
-	{
-		ber_free(requestBer, 1);
-	}
+    if (requestBer) {
+        ber_free(requestBer, 1);
+    }
 
-	return err;
+    return err;
 }
 
 /**********************************************************************
@@ -157,89 +144,79 @@ static int berEncodePasswordData(
 **********************************************************************/
 
 static int berEncodeLoginData(
-	struct berval **requestBV,
-	char     *objectDN,
-	unsigned int  methodIDLen,
-	unsigned int *methodID,
-	char     *tag,
-	size_t   putDataLen,
-	void     *putData)
+    struct berval **requestBV,
+    char     *objectDN,
+    unsigned int  methodIDLen,
+    unsigned int *methodID,
+    char     *tag,
+    size_t   putDataLen,
+    void     *putData)
 {
-	int err = 0;
-	BerElement *requestBer = NULL;
-
-	unsigned int i;
-	unsigned int elemCnt = methodIDLen / sizeof(unsigned int);
-
-	char	*utf8ObjPtr=NULL;
-	int     utf8ObjSize = 0;
-
-	char    *utf8TagPtr = NULL;
-	int     utf8TagSize = 0;
-
-	utf8ObjPtr = objectDN;
-	utf8ObjSize = strlen(utf8ObjPtr)+1;
-
-	utf8TagPtr = tag;
-	utf8TagSize = strlen(utf8TagPtr)+1;
-
-	/* Allocate a BerElement for the request parameters. */
-	if((requestBer = ber_alloc()) == NULL)
-	{
-		err = LDAP_ENCODING_ERROR;
-		goto Cleanup;
-	}
-
-	/* BER encode the NMAS Version and the objectDN */
-	err = (ber_printf(requestBer, "{io", NMAS_LDAP_EXT_VERSION, utf8ObjPtr, utf8ObjSize) < 0) ? LDAP_ENCODING_ERROR : 0;
-
-	/* BER encode the MethodID Length and value */
-	if (!err)
-	{
-		err = (ber_printf(requestBer, "{i{", methodIDLen) < 0) ? LDAP_ENCODING_ERROR : 0;
-	}
-
-	for (i = 0; !err && i < elemCnt; i++)
-	{
-		err = (ber_printf(requestBer, "i", methodID[i]) < 0) ? LDAP_ENCODING_ERROR : 0;
-	}
-
-	if (!err)
-	{
-		err = (ber_printf(requestBer, "}}", 0) < 0) ? LDAP_ENCODING_ERROR : 0;
-	}
-
-	if(putData)
-	{
-		/* BER Encode the the tag and data */
-		err = (ber_printf(requestBer, "oio}", utf8TagPtr, utf8TagSize, putDataLen, putData, putDataLen) < 0) ? LDAP_ENCODING_ERROR : 0;
-	}
-	else
-	{
-		/* BER Encode the the tag */
-		err = (ber_printf(requestBer, "o}", utf8TagPtr, utf8TagSize) < 0) ? LDAP_ENCODING_ERROR : 0;
-	}
-
-	if (err)
-	{
-		goto Cleanup;
-	}
-
-	/* Convert the BER we just built to a berval that we'll send with the extended request. */
-	if(ber_flatten(requestBer, requestBV) == LBER_ERROR)
-	{
-		err = LDAP_ENCODING_ERROR;
-		goto Cleanup;
-	}
+    int err = 0;
+    BerElement *requestBer = NULL;
+
+    unsigned int i;
+    unsigned int elemCnt = methodIDLen / sizeof(unsigned int);
+
+    char	*utf8ObjPtr=NULL;
+    int     utf8ObjSize = 0;
+
+    char    *utf8TagPtr = NULL;
+    int     utf8TagSize = 0;
+
+    utf8ObjPtr = objectDN;
+    utf8ObjSize = strlen(utf8ObjPtr)+1;
+
+    utf8TagPtr = tag;
+    utf8TagSize = strlen(utf8TagPtr)+1;
+
+    /* Allocate a BerElement for the request parameters. */
+    if ((requestBer = ber_alloc()) == NULL) {
+        err = LDAP_ENCODING_ERROR;
+        goto Cleanup;
+    }
+
+    /* BER encode the NMAS Version and the objectDN */
+    err = (ber_printf(requestBer, "{io", NMAS_LDAP_EXT_VERSION, utf8ObjPtr, utf8ObjSize) < 0) ? LDAP_ENCODING_ERROR : 0;
+
+    /* BER encode the MethodID Length and value */
+    if (!err) {
+        err = (ber_printf(requestBer, "{i{", methodIDLen) < 0) ? LDAP_ENCODING_ERROR : 0;
+    }
+
+    for (i = 0; !err && i < elemCnt; i++) {
+        err = (ber_printf(requestBer, "i", methodID[i]) < 0) ? LDAP_ENCODING_ERROR : 0;
+    }
+
+    if (!err) {
+        err = (ber_printf(requestBer, "}}", 0) < 0) ? LDAP_ENCODING_ERROR : 0;
+    }
+
+    if (putData) {
+        /* BER Encode the the tag and data */
+        err = (ber_printf(requestBer, "oio}", utf8TagPtr, utf8TagSize, putDataLen, putData, putDataLen) < 0) ? LDAP_ENCODING_ERROR : 0;
+    } else {
+        /* BER Encode the the tag */
+        err = (ber_printf(requestBer, "o}", utf8TagPtr, utf8TagSize) < 0) ? LDAP_ENCODING_ERROR : 0;
+    }
+
+    if (err) {
+        goto Cleanup;
+    }
+
+    /* Convert the BER we just built to a berval that we'll send with the extended request. */
+    if (ber_flatten(requestBer, requestBV) == LBER_ERROR) {
+        err = LDAP_ENCODING_ERROR;
+        goto Cleanup;
+    }
 
 Cleanup:
 
-	if(requestBer)
-	{
-		ber_free(requestBer, 1);
-	}
+    if (requestBer) {
+        ber_free(requestBer, 1);
+    }
 
-	return err;
+    return err;
 }
 
 /**********************************************************************
@@ -249,75 +226,60 @@ static int berEncodeLoginData(
 **********************************************************************/
 
 static int berDecodeLoginData(
-	struct berval *replyBV,
-	int      *serverVersion,
-	size_t   *retDataLen,
-	void     *retData )
+    struct berval *replyBV,
+    int      *serverVersion,
+    size_t   *retDataLen,
+    void     *retData )
 {
-	int err = 0;
-	BerElement *replyBer = NULL;
-	char    *retOctStr = NULL;
-	size_t  retOctStrLen = 0;
-
-	if((replyBer = ber_init(replyBV)) == NULL)
-	{
-		err = LDAP_OPERATIONS_ERROR;
-		goto Cleanup;
-	}
-
-	if(retData)
-	{
-		retOctStrLen = *retDataLen + 1;
-		retOctStr = SMB_MALLOC_ARRAY(char, retOctStrLen);
-		if(!retOctStr)
-		{
-			err = LDAP_OPERATIONS_ERROR;
-			goto Cleanup;
-		}
-	
-		if(ber_scanf(replyBer, "{iis}", serverVersion, &err, retOctStr, &retOctStrLen) != -1)
-		{
-			if (*retDataLen >= retOctStrLen)
-			{
-				memcpy(retData, retOctStr, retOctStrLen);
-			}
-			else if (!err)
-			{	
-				err = LDAP_NO_MEMORY;
-			}
-
-			*retDataLen = retOctStrLen;
-		}
-		else if (!err)
-		{
-			err = LDAP_DECODING_ERROR;
-		}
-	}
-	else
-	{
-		if(ber_scanf(replyBer, "{ii}", serverVersion, &err) == -1)
-		{
-			if (!err)
-			{
-				err = LDAP_DECODING_ERROR;
-			}
-		}
-	}
+    int err = 0;
+    BerElement *replyBer = NULL;
+    char    *retOctStr = NULL;
+    size_t  retOctStrLen = 0;
+
+    if ((replyBer = ber_init(replyBV)) == NULL) {
+        err = LDAP_OPERATIONS_ERROR;
+        goto Cleanup;
+    }
+
+    if (retData) {
+        retOctStrLen = *retDataLen + 1;
+        retOctStr = SMB_MALLOC_ARRAY(char, retOctStrLen);
+        if (!retOctStr) {
+            err = LDAP_OPERATIONS_ERROR;
+            goto Cleanup;
+        }
+
+        if (ber_scanf(replyBer, "{iis}", serverVersion, &err, retOctStr, &retOctStrLen) != -1) {
+            if (*retDataLen >= retOctStrLen) {
+                memcpy(retData, retOctStr, retOctStrLen);
+            } else if (!err) {
+                err = LDAP_NO_MEMORY;
+            }
+
+            *retDataLen = retOctStrLen;
+        } else if (!err) {
+            err = LDAP_DECODING_ERROR;
+        }
+    } else {
+        if (ber_scanf(replyBer, "{ii}", serverVersion, &err) == -1) {
+            if (!err) {
+                err = LDAP_DECODING_ERROR;
+            }
+        }
+    }
 
 Cleanup:
 
-	if(replyBer)
-	{
-		ber_free(replyBer, 1);
-	}
+    if (replyBer) {
+        ber_free(replyBer, 1);
+    }
 
-	if (retOctStr != NULL)
-	{
-		memset(retOctStr, 0, retOctStrLen);
-		free(retOctStr);
-	}
+    if (retOctStr != NULL) {
+        memset(retOctStr, 0, retOctStrLen);
+        free(retOctStr);
+    }
 
-	return err;
+    return err;
 }
 
 /**********************************************************************
@@ -326,158 +288,139 @@ static int berDecodeLoginData(
 **********************************************************************/
 
 static int getLoginConfig(
-	LDAP	 *ld,
-	char     *objectDN,
-	unsigned int  methodIDLen,
-	unsigned int *methodID,
-	char     *tag,
-	size_t   *dataLen,
-	void     *data )
+    LDAP	 *ld,
+    char     *objectDN,
+    unsigned int  methodIDLen,
+    unsigned int *methodID,
+    char     *tag,
+    size_t   *dataLen,
+    void     *data )
 {
-	int     err = 0;
-	struct  berval *requestBV = NULL;
-	char    *replyOID = NULL;
-	struct  berval *replyBV = NULL;
-	int     serverVersion = 0;
-
-	/* Validate unicode parameters. */
-	if((strlen(objectDN) == 0) || ld == NULL)
-	{
-		return LDAP_NO_SUCH_ATTRIBUTE;
-	}
-
-	err = berEncodeLoginData(&requestBV, objectDN, methodIDLen, methodID, tag, 0, NULL);
-	if(err)
-	{
-		goto Cleanup;
-	}
-
-	/* Call the ldap_extended_operation (synchronously) */
-	if((err = ldap_extended_operation_s(ld, NMASLDAP_GET_LOGIN_CONFIG_REQUEST,
-					requestBV, NULL, NULL, &replyOID, &replyBV)))
-	{
-		goto Cleanup;
-	}
-
-	/* Make sure there is a return OID */
-	if(!replyOID)
-	{
-		err = LDAP_NOT_SUPPORTED;
-		goto Cleanup;
-	}
-
-	/* Is this what we were expecting to get back. */
-	if(strcmp(replyOID, NMASLDAP_GET_LOGIN_CONFIG_RESPONSE))
-	{
-		err = LDAP_NOT_SUPPORTED;
-		goto Cleanup;
-	}
-
-	/* Do we have a good returned berval? */
-	if(!replyBV)
-	{
-		/* No; returned berval means we experienced a rather drastic error. */
-		/* Return operations error. */
-		err = LDAP_OPERATIONS_ERROR;
-		goto Cleanup;
-	}
-
-	err = berDecodeLoginData(replyBV, &serverVersion, dataLen, data);
-
-	if(serverVersion != NMAS_LDAP_EXT_VERSION)
-	{
-		err = LDAP_OPERATIONS_ERROR;
-		goto Cleanup;
-	}
+    int     err = 0;
+    struct  berval *requestBV = NULL;
+    char    *replyOID = NULL;
+    struct  berval *replyBV = NULL;
+    int     serverVersion = 0;
+
+    /* Validate unicode parameters. */
+    if ((strlen(objectDN) == 0) || ld == NULL) {
+        return LDAP_NO_SUCH_ATTRIBUTE;
+    }
+
+    err = berEncodeLoginData(&requestBV, objectDN, methodIDLen, methodID, tag, 0, NULL);
+    if (err) {
+        goto Cleanup;
+    }
+
+    /* Call the ldap_extended_operation (synchronously) */
+    if ((err = ldap_extended_operation_s(ld, NMASLDAP_GET_LOGIN_CONFIG_REQUEST,
+                                         requestBV, NULL, NULL, &replyOID, &replyBV))) {
+        goto Cleanup;
+    }
+
+    /* Make sure there is a return OID */
+    if (!replyOID) {
+        err = LDAP_NOT_SUPPORTED;
+        goto Cleanup;
+    }
+
+    /* Is this what we were expecting to get back. */
+    if (strcmp(replyOID, NMASLDAP_GET_LOGIN_CONFIG_RESPONSE)) {
+        err = LDAP_NOT_SUPPORTED;
+        goto Cleanup;
+    }
+
+    /* Do we have a good returned berval? */
+    if (!replyBV) {
+        /* No; returned berval means we experienced a rather drastic error. */
+        /* Return operations error. */
+        err = LDAP_OPERATIONS_ERROR;
+        goto Cleanup;
+    }
+
+    err = berDecodeLoginData(replyBV, &serverVersion, dataLen, data);
+
+    if (serverVersion != NMAS_LDAP_EXT_VERSION) {
+        err = LDAP_OPERATIONS_ERROR;
+        goto Cleanup;
+    }
 
 Cleanup:
 
-	if(replyBV)
-	{
-		ber_bvfree(replyBV);
-	}
-
-	/* Free the return OID string if one was returned. */
-	if(replyOID)
-	{
-		ldap_memfree(replyOID);
-	}
-
-	/* Free memory allocated while building the request ber and berval. */
-	if(requestBV)
-	{
-		ber_bvfree(requestBV);
-	}
-
-	/* Return the appropriate error/success code. */
-	return err;
+    if (replyBV) {
+        ber_bvfree(replyBV);
+    }
+
+    /* Free the return OID string if one was returned. */
+    if (replyOID) {
+        ldap_memfree(replyOID);
+    }
+
+    /* Free memory allocated while building the request ber and berval. */
+    if (requestBV) {
+        ber_bvfree(requestBV);
+    }
+
+    /* Return the appropriate error/success code. */
+    return err;
 }
 
 /**********************************************************************
  Attempts to get the Simple Password
 **********************************************************************/
 
 static int nmasldap_get_simple_pwd(
-	LDAP	 *ld,
-	char     *objectDN,
-	size_t	 pwdLen,
-	char     *pwd )
+    LDAP	 *ld,
+    char     *objectDN,
+    size_t	 pwdLen,
+    char     *pwd )
 {
-	int err = 0;
-	unsigned int methodID = 0;
-	unsigned int methodIDLen = sizeof(methodID);
-	char    tag[] = {'P','A','S','S','W','O','R','D',' ','H','A','S','H',0};
-	char    *pwdBuf=NULL;
-	size_t  pwdBufLen, bufferLen;
-
-	bufferLen = pwdBufLen = pwdLen+2;
-	pwdBuf = SMB_MALLOC_ARRAY(char, pwdBufLen); /* digest and null */
-	if(pwdBuf == NULL)
-	{
-		return LDAP_NO_MEMORY;
-	}
-
-	err = getLoginConfig(ld, objectDN, methodIDLen, &methodID, tag, &pwdBufLen, pwdBuf);
-	if (err == 0)
-	{
-		if (pwdBufLen !=0)
-		{
-			pwdBuf[pwdBufLen] = 0;       /* null terminate */
-
-			switch (pwdBuf[0])
-			{
-				case 1:  /* cleartext password  */
-					break;
-				case 2:  /* SHA1 HASH */
-				case 3:  /* MD5_ID */
-				case 4:  /* UNIXCrypt_ID */
-				case 8:  /* SSHA_ID */
-				default: /* Unknown digest */
-					err = LDAP_INAPPROPRIATE_AUTH;  /* only return clear text */
-					break;
-			}
-
-			if (!err)
-			{
-				if (pwdLen >= pwdBufLen-1)
-				{
-					memcpy(pwd, &pwdBuf[1], pwdBufLen-1);  /* skip digest tag and include null */
-				}
-				else
-				{
-					err = LDAP_NO_MEMORY;
-				}
-			}
-		}
-	}
-
-	if (pwdBuf != NULL)
-	{
-		memset(pwdBuf, 0, bufferLen);
-		free(pwdBuf);
-	}
-
-	return err;
+    int err = 0;
+    unsigned int methodID = 0;
+    unsigned int methodIDLen = sizeof(methodID);
+    char    tag[] = {'P','A','S','S','W','O','R','D',' ','H','A','S','H',0};
+    char    *pwdBuf=NULL;
+    size_t  pwdBufLen, bufferLen;
+
+    bufferLen = pwdBufLen = pwdLen+2;
+    pwdBuf = SMB_MALLOC_ARRAY(char, pwdBufLen); /* digest and null */
+    if (pwdBuf == NULL) {
+        return LDAP_NO_MEMORY;
+    }
+
+    err = getLoginConfig(ld, objectDN, methodIDLen, &methodID, tag, &pwdBufLen, pwdBuf);
+    if (err == 0) {
+        if (pwdBufLen !=0) {
+            pwdBuf[pwdBufLen] = 0;       /* null terminate */
+
+            switch (pwdBuf[0]) {
+            case 1:  /* cleartext password  */
+                break;
+            case 2:  /* SHA1 HASH */
+            case 3:  /* MD5_ID */
+            case 4:  /* UNIXCrypt_ID */
+            case 8:  /* SSHA_ID */
+            default: /* Unknown digest */
+                err = LDAP_INAPPROPRIATE_AUTH;  /* only return clear text */
+                break;
+            }
+
+            if (!err) {
+                if (pwdLen >= pwdBufLen-1) {
+                    memcpy(pwd, &pwdBuf[1], pwdBufLen-1);  /* skip digest tag and include null */
+                } else {
+                    err = LDAP_NO_MEMORY;
+                }
+            }
+        }
+    }
+
+    if (pwdBuf != NULL) {
+        memset(pwdBuf, 0, bufferLen);
+        free(pwdBuf);
+    }
+
+    return err;
 }
 
 
@@ -486,152 +429,138 @@ static int nmasldap_get_simple_pwd(
 **********************************************************************/
 
 static int nmasldap_get_password(
-	LDAP	 *ld,
-	char     *objectDN,
-	size_t   *pwdSize,	/* in bytes */
-	unsigned char     *pwd )
+    LDAP	 *ld,
+    char     *objectDN,
+    size_t   *pwdSize,	/* in bytes */
+    unsigned char     *pwd )
 {
-	int err = 0;
-
-	struct berval *requestBV = NULL;
-	char *replyOID = NULL;
-	struct berval *replyBV = NULL;
-	int serverVersion;
-	char *pwdBuf;
-	size_t pwdBufLen, bufferLen;
-
-	/* Validate char parameters. */
-	if(objectDN == NULL || (strlen(objectDN) == 0) || pwdSize == NULL || ld == NULL)
-	{
-		return LDAP_NO_SUCH_ATTRIBUTE;
-	}
-
-	bufferLen = pwdBufLen = *pwdSize;
-	pwdBuf = SMB_MALLOC_ARRAY(char, pwdBufLen+2);
-	if(pwdBuf == NULL)
-	{
-		return LDAP_NO_MEMORY;
-	}
-
-	err = berEncodePasswordData(&requestBV, objectDN, NULL, NULL);
-	if(err)
-	{
-		goto Cleanup;
-	}
-
-	/* Call the ldap_extended_operation (synchronously) */
-	if((err = ldap_extended_operation_s(ld, NMASLDAP_GET_PASSWORD_REQUEST, requestBV, NULL, NULL, &replyOID, &replyBV)))
-	{
-		goto Cleanup;
-	}
-
-	/* Make sure there is a return OID */
-	if(!replyOID)
-	{
-		err = LDAP_NOT_SUPPORTED;
-		goto Cleanup;
-	}
-
-	/* Is this what we were expecting to get back. */
-	if(strcmp(replyOID, NMASLDAP_GET_PASSWORD_RESPONSE))
-	{
-		err = LDAP_NOT_SUPPORTED;
-		goto Cleanup;
-	}
-
-	/* Do we have a good returned berval? */
-	if(!replyBV)
-	{
-		/* No; returned berval means we experienced a rather drastic error. */
-		/* Return operations error. */
-		err = LDAP_OPERATIONS_ERROR;
-		goto Cleanup;
-	}
-
-	err = berDecodeLoginData(replyBV, &serverVersion, &pwdBufLen, pwdBuf);
-
-	if(serverVersion != NMAS_LDAP_EXT_VERSION)
-	{
-		err = LDAP_OPERATIONS_ERROR;
-		goto Cleanup;
-	}
-
-	if (!err && pwdBufLen != 0)
-	{
-		if (*pwdSize >= pwdBufLen+1 && pwd != NULL)
-		{
-			memcpy(pwd, pwdBuf, pwdBufLen);
-			pwd[pwdBufLen] = 0; /* add null termination */
-		}
-		*pwdSize = pwdBufLen; /* does not include null termination */
-	}
+    int err = 0;
+
+    struct berval *requestBV = NULL;
+    char *replyOID = NULL;
+    struct berval *replyBV = NULL;
+    int serverVersion;
+    char *pwdBuf;
+    size_t pwdBufLen, bufferLen;
+
+    /* Validate char parameters. */
+    if (objectDN == NULL || (strlen(objectDN) == 0) || pwdSize == NULL || ld == NULL) {
+        return LDAP_NO_SUCH_ATTRIBUTE;
+    }
+
+    bufferLen = pwdBufLen = *pwdSize;
+    pwdBuf = SMB_MALLOC_ARRAY(char, pwdBufLen+2);
+    if (pwdBuf == NULL) {
+        return LDAP_NO_MEMORY;
+    }
+
+    err = berEncodePasswordData(&requestBV, objectDN, NULL, NULL);
+    if (err) {
+        goto Cleanup;
+    }
+
+    /* Call the ldap_extended_operation (synchronously) */
+    if ((err = ldap_extended_operation_s(ld, NMASLDAP_GET_PASSWORD_REQUEST, requestBV, NULL, NULL, &replyOID, &replyBV))) {
+        goto Cleanup;
+    }
+
+    /* Make sure there is a return OID */
+    if (!replyOID) {
+        err = LDAP_NOT_SUPPORTED;
+        goto Cleanup;
+    }
+
+    /* Is this what we were expecting to get back. */
+    if (strcmp(replyOID, NMASLDAP_GET_PASSWORD_RESPONSE)) {
+        err = LDAP_NOT_SUPPORTED;
+        goto Cleanup;
+    }
+
+    /* Do we have a good returned berval? */
+    if (!replyBV) {
+        /* No; returned berval means we experienced a rather drastic error. */
+        /* Return operations error. */
+        err = LDAP_OPERATIONS_ERROR;
+        goto Cleanup;
+    }
+
+    err = berDecodeLoginData(replyBV, &serverVersion, &pwdBufLen, pwdBuf);
+
+    if (serverVersion != NMAS_LDAP_EXT_VERSION) {
+        err = LDAP_OPERATIONS_ERROR;
+        goto Cleanup;
+    }
+
+    if (!err && pwdBufLen != 0) {
+        if (*pwdSize >= pwdBufLen+1 && pwd != NULL) {
+            memcpy(pwd, pwdBuf, pwdBufLen);
+            pwd[pwdBufLen] = 0; /* add null termination */
+        }
+        *pwdSize = pwdBufLen; /* does not include null termination */
+    }
 
 Cleanup:
 
-	if(replyBV)
-	{
-		ber_bvfree(replyBV);
-	}
-
-	/* Free the return OID string if one was returned. */
-	if(replyOID)
-	{
-		ldap_memfree(replyOID);
-	}
-
-	/* Free memory allocated while building the request ber and berval. */
-	if(requestBV)
-	{
-		ber_bvfree(requestBV);
-	}
-
-	if (pwdBuf != NULL)
-	{
-		memset(pwdBuf, 0, bufferLen);
-		free(pwdBuf);
-	}
-
-	/* Return the appropriate error/success code. */
-	return err;
+    if (replyBV) {
+        ber_bvfree(replyBV);
+    }
+
+    /* Free the return OID string if one was returned. */
+    if (replyOID) {
+        ldap_memfree(replyOID);
+    }
+
+    /* Free memory allocated while building the request ber and berval. */
+    if (requestBV) {
+        ber_bvfree(requestBV);
+    }
+
+    if (pwdBuf != NULL) {
+        memset(pwdBuf, 0, bufferLen);
+        free(pwdBuf);
+    }
+
+    /* Return the appropriate error/success code. */
+    return err;
 }
 
 /**********************************************************************
  Get the user's password from NDS.
  *********************************************************************/
 
 int nds_get_password(
-	LDAP *ld,
-	char *object_dn,
-	size_t *pwd_len,
-	char *pwd )
+    LDAP *ld,
+    char *object_dn,
+    size_t *pwd_len,
+    char *pwd )
 {
-	int rc = -1;
+    int rc = -1;
 
-	rc = nmasldap_get_password(ld, object_dn, pwd_len, (unsigned char *)pwd);
-	if (rc == LDAP_SUCCESS) {
+    rc = nmasldap_get_password(ld, object_dn, pwd_len, (unsigned char *)pwd);
+    if (rc == LDAP_SUCCESS) {
 #ifdef DEBUG_PASSWORD
-		DEBUG(100,("nmasldap_get_password returned %s for %s\n", pwd, object_dn));
-#endif    
-		DEBUG(5, ("NDS Universal Password retrieved for %s\n", object_dn));
-	} else {
-		DEBUG(3, ("NDS Universal Password NOT retrieved for %s\n", object_dn));
-	}
-
-	if (rc != LDAP_SUCCESS) {
-		rc = nmasldap_get_simple_pwd(ld, object_dn, *pwd_len, pwd);
-		if (rc == LDAP_SUCCESS) {
+        DEBUG(100,("nmasldap_get_password returned %s for %s\n", pwd, object_dn));
+#endif
+        DEBUG(5, ("NDS Universal Password retrieved for %s\n", object_dn));
+    } else {
+        DEBUG(3, ("NDS Universal Password NOT retrieved for %s\n", object_dn));
+    }
+
+    if (rc != LDAP_SUCCESS) {
+        rc = nmasldap_get_simple_pwd(ld, object_dn, *pwd_len, pwd);
+        if (rc == LDAP_SUCCESS) {
 #ifdef DEBUG_PASSWORD
-			DEBUG(100,("nmasldap_get_simple_pwd returned %s for %s\n", pwd, object_dn));
-#endif    
-			DEBUG(5, ("NDS Simple Password retrieved for %s\n", object_dn));
-		} else {
-			/* We couldn't get the password */
-			DEBUG(3, ("NDS Simple Password NOT retrieved for %s\n", object_dn));
-			return LDAP_INVALID_CREDENTIALS;
-		}
-	}
-
-	/* We got the password */
-	return LDAP_SUCCESS;
+            DEBUG(100,("nmasldap_get_simple_pwd returned %s for %s\n", pwd, object_dn));
+#endif
+            DEBUG(5, ("NDS Simple Password retrieved for %s\n", object_dn));
+        } else {
+            /* We couldn't get the password */
+            DEBUG(3, ("NDS Simple Password NOT retrieved for %s\n", object_dn));
+            return LDAP_INVALID_CREDENTIALS;
+        }
+    }
+
+    /* We got the password */
+    return LDAP_SUCCESS;
 }
 
@@ -1 +1 @@
-int nds_get_password(LDAP *ld, char *object_dn, size_t * pwd_len, char *pwd);
+int nds_get_password(LDAP *ld, char *object_dn, size_t * pwd_len, char *pwd);
@@ -93,7 +93,7 @@ squid_ldap_set_aliasderef(int deref)
 static void
 squid_ldap_set_referrals(int referrals)
 {
-    int *value = referrals ? LDAP_OPT_ON : LDAP_OPT_OFF;
+    int *value = referrals ? LDAP_OPT_ON :LDAP_OPT_OFF;
     ldap_set_option(ld, LDAP_OPT_REFERRALS, value);
 }
 static void
@@ -130,9 +130,9 @@ static void
 squid_ldap_set_referrals(int referrals)
 {
     if (referrals)
-	ld->ld_options |= ~LDAP_OPT_REFERRALS;
+        ld->ld_options |= ~LDAP_OPT_REFERRALS;
     else
-	ld->ld_options &= ~LDAP_OPT_REFERRALS;
+        ld->ld_options &= ~LDAP_OPT_REFERRALS;
 }
 static void
 squid_ldap_set_timelimit(int timelimit)
@@ -163,24 +163,24 @@ ldap_escape_value(char *escaped, int size, const char *src)
 {
     int n = 0;
     while (size > 4 && *src) {
-	switch (*src) {
-	case '*':
-	case '(':
-	case ')':
-	case '\\':
-	    n += 3;
-	    size -= 3;
-	    if (size > 0) {
-		*escaped++ = '\\';
-		snprintf(escaped, 3, "%02x", (int) *src++);
-		escaped += 2;
-	    }
-	    break;
-	default:
-	    *escaped++ = *src++;
-	    n++;
-	    size--;
-	}
+        switch (*src) {
+        case '*':
+        case '(':
+        case ')':
+        case '\\':
+            n += 3;
+            size -= 3;
+            if (size > 0) {
+                *escaped++ = '\\';
+                snprintf(escaped, 3, "%02x", (int) *src++);
+                escaped += 2;
+            }
+            break;
+        default:
+            *escaped++ = *src++;
+            n++;
+            size--;
+        }
     }
     *escaped = '\0';
     return n;
@@ -202,127 +202,127 @@ getpassword(char *login, char *realm)
     int nmas_res = 0;
     int rc = -1;
     if (ld) {
-	if (usersearchfilter) {
-	    char escaped_login[1024];
-	    snprintf(searchbase, sizeof(searchbase), "%s", userbasedn);
-	    ldap_escape_value(escaped_login, sizeof(escaped_login), login);
-	    snprintf(filter, sizeof(filter), usersearchfilter, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login);
-
-	  retrysrch:
-	    if (debug)
-		fprintf(stderr, "user filter '%s', searchbase '%s'\n", filter, searchbase);
-
-	    rc = ldap_search_s(ld, searchbase, searchscope, filter, NULL, 0, &res);
-	    if (rc != LDAP_SUCCESS) {
-		if (noreferrals && rc == LDAP_PARTIAL_RESULTS) {
-		    /* Everything is fine. This is expected when referrals
-		     * are disabled.
-		     */
-		    rc = LDAP_SUCCESS;
-		} else {
-		    fprintf(stderr, PROGRAM_NAME " WARNING, LDAP search error '%s'\n", ldap_err2string(rc));
+        if (usersearchfilter) {
+            char escaped_login[1024];
+            snprintf(searchbase, sizeof(searchbase), "%s", userbasedn);
+            ldap_escape_value(escaped_login, sizeof(escaped_login), login);
+            snprintf(filter, sizeof(filter), usersearchfilter, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login);
+
+retrysrch:
+            if (debug)
+                fprintf(stderr, "user filter '%s', searchbase '%s'\n", filter, searchbase);
+
+            rc = ldap_search_s(ld, searchbase, searchscope, filter, NULL, 0, &res);
+            if (rc != LDAP_SUCCESS) {
+                if (noreferrals && rc == LDAP_PARTIAL_RESULTS) {
+                    /* Everything is fine. This is expected when referrals
+                     * are disabled.
+                     */
+                    rc = LDAP_SUCCESS;
+                } else {
+                    fprintf(stderr, PROGRAM_NAME " WARNING, LDAP search error '%s'\n", ldap_err2string(rc));
 #if defined(NETSCAPE_SSL)
-		    if (sslpath && ((rc == LDAP_SERVER_DOWN) || (rc == LDAP_CONNECT_ERROR))) {
-			int sslerr = PORT_GetError();
-			fprintf(stderr, PROGRAM_NAME ": WARNING, SSL error %d (%s)\n", sslerr, ldapssl_err2string(sslerr));
-		    }
+                    if (sslpath && ((rc == LDAP_SERVER_DOWN) || (rc == LDAP_CONNECT_ERROR))) {
+                        int sslerr = PORT_GetError();
+                        fprintf(stderr, PROGRAM_NAME ": WARNING, SSL error %d (%s)\n", sslerr, ldapssl_err2string(sslerr));
+                    }
 #endif
-		    fprintf(stderr, PROGRAM_NAME " WARNING, LDAP search error, trying to recover'%s'\n", ldap_err2string(rc));
-		    ldap_msgfree(res);
-		    /* try to connect to the LDAP server agin, maybe my persisten conexion failed. */
-		    if (!retry) {
-			retry++;
-			ldap_unbind(ld);
-			ld = NULL;
-			ldapconnect();
-			goto retrysrch;
-		    }
-		    return NULL;
-
-		}
-	    }
-	} else if (userdnattr) {
-	    sprintf(searchbase, "%s=%s, %s", userdnattr, login, userbasedn);
-
-	  retrydnattr:
-	    if (debug)
-		fprintf(stderr, "searchbase '%s'\n", searchbase);
-	    rc = ldap_search_s(ld, searchbase, searchscope, NULL, NULL, 0, &res);
-	}
-	if (rc == LDAP_SUCCESS) {
-	    entry = ldap_first_entry(ld, res);
-	    if (entry) {
-		if (debug)
-		    printf("ldap dn: %s\n", ldap_get_dn(ld, entry));
-		if (edir_universal_passwd) {
-
-		    /* allocate some memory for the universal password returned by NMAS */
-		    universal_password = malloc(universal_password_len);
-		    memset(universal_password, 0, universal_password_len);
-		    values = malloc(sizeof(char *));
-
-		    /* actually talk to NMAS to get a password */
-		    nmas_res = nds_get_password(ld, ldap_get_dn(ld, entry), &universal_password_len, universal_password);
-		    if (nmas_res == LDAP_SUCCESS && universal_password) {
-			if (debug)
-			    printf("NMAS returned value %s\n", universal_password);
-			values[0] = universal_password;
-		    } else {
-			if (debug)
-			    printf("Error reading Universal Password: %d = %s\n", nmas_res, ldap_err2string(nmas_res));
-		    }
-		} else {
-		    values = ldap_get_values(ld, entry, passattr);
-		}
-	    } else {
-		ldap_msgfree(res);
-		return NULL;
-	    }
-	    if (!values) {
-		if (debug)
-		    printf("No attribute value found\n");
-		if (edir_universal_passwd)
-		    free(universal_password);
-		ldap_msgfree(res);
-		return NULL;
-	    }
-	    value = values;
-	    while (*value) {
-		if (encrpass) {
-		    if (strcmp(strtok(*value, delimiter), realm) == 0) {
-			password = strtok(NULL, delimiter);
-			break;
-		    }
-		} else {
-		    password = *value;
-		    break;
-		}
-		value++;
-	    }
-	    if (debug)
-		printf("password: %s\n", password);
-	    if (password)
-		password = strdup(password);
-	    if (edir_universal_passwd) {
-		free(values);
-		free(universal_password);
-	    } else {
-		ldap_value_free(values);
-	    }
-	    ldap_msgfree(res);
-	    return password;
-	} else {
-	    fprintf(stderr, PROGRAM_NAME " WARNING, LDAP error '%s'\n", ldap_err2string(rc));
-	    /* try to connect to the LDAP server agin, maybe my persisten conexion failed. */
-	    if (!retry) {
-		retry++;
-		ldap_unbind(ld);
-		ld = NULL;
-		ldapconnect();
-		goto retrydnattr;
-	    }
-	    return NULL;
-	}
+                    fprintf(stderr, PROGRAM_NAME " WARNING, LDAP search error, trying to recover'%s'\n", ldap_err2string(rc));
+                    ldap_msgfree(res);
+                    /* try to connect to the LDAP server agin, maybe my persisten conexion failed. */
+                    if (!retry) {
+                        retry++;
+                        ldap_unbind(ld);
+                        ld = NULL;
+                        ldapconnect();
+                        goto retrysrch;
+                    }
+                    return NULL;
+
+                }
+            }
+        } else if (userdnattr) {
+            sprintf(searchbase, "%s=%s, %s", userdnattr, login, userbasedn);
+
+retrydnattr:
+            if (debug)
+                fprintf(stderr, "searchbase '%s'\n", searchbase);
+            rc = ldap_search_s(ld, searchbase, searchscope, NULL, NULL, 0, &res);
+        }
+        if (rc == LDAP_SUCCESS) {
+            entry = ldap_first_entry(ld, res);
+            if (entry) {
+                if (debug)
+                    printf("ldap dn: %s\n", ldap_get_dn(ld, entry));
+                if (edir_universal_passwd) {
+
+                    /* allocate some memory for the universal password returned by NMAS */
+                    universal_password = malloc(universal_password_len);
+                    memset(universal_password, 0, universal_password_len);
+                    values = malloc(sizeof(char *));
+
+                    /* actually talk to NMAS to get a password */
+                    nmas_res = nds_get_password(ld, ldap_get_dn(ld, entry), &universal_password_len, universal_password);
+                    if (nmas_res == LDAP_SUCCESS && universal_password) {
+                        if (debug)
+                            printf("NMAS returned value %s\n", universal_password);
+                        values[0] = universal_password;
+                    } else {
+                        if (debug)
+                            printf("Error reading Universal Password: %d = %s\n", nmas_res, ldap_err2string(nmas_res));
+                    }
+                } else {
+                    values = ldap_get_values(ld, entry, passattr);
+                }
+            } else {
+                ldap_msgfree(res);
+                return NULL;
+            }
+            if (!values) {
+                if (debug)
+                    printf("No attribute value found\n");
+                if (edir_universal_passwd)
+                    free(universal_password);
+                ldap_msgfree(res);
+                return NULL;
+            }
+            value = values;
+            while (*value) {
+                if (encrpass) {
+                    if (strcmp(strtok(*value, delimiter), realm) == 0) {
+                        password = strtok(NULL, delimiter);
+                        break;
+                    }
+                } else {
+                    password = *value;
+                    break;
+                }
+                value++;
+            }
+            if (debug)
+                printf("password: %s\n", password);
+            if (password)
+                password = strdup(password);
+            if (edir_universal_passwd) {
+                free(values);
+                free(universal_password);
+            } else {
+                ldap_value_free(values);
+            }
+            ldap_msgfree(res);
+            return password;
+        } else {
+            fprintf(stderr, PROGRAM_NAME " WARNING, LDAP error '%s'\n", ldap_err2string(rc));
+            /* try to connect to the LDAP server agin, maybe my persisten conexion failed. */
+            if (!retry) {
+                retry++;
+                ldap_unbind(ld);
+                ld = NULL;
+                ldapconnect();
+                goto retrydnattr;
+            }
+            return NULL;
+        }
     }
     return NULL;
 }
@@ -334,91 +334,91 @@ ldapconnect(void)
 {
     int rc;
 
-/* On Windows ldap_start_tls_s is available starting from Windows XP, 
- * so we need to bind at run-time with the function entry point
- */
+    /* On Windows ldap_start_tls_s is available starting from Windows XP,
+     * so we need to bind at run-time with the function entry point
+     */
 #ifdef _SQUID_MSWIN_
     if (use_tls) {
 
-	HMODULE WLDAP32Handle;
+        HMODULE WLDAP32Handle;
 
-	WLDAP32Handle = GetModuleHandle("wldap32");
-	if ((Win32_ldap_start_tls_s = (PFldap_start_tls_s) GetProcAddress(WLDAP32Handle, LDAP_START_TLS_S)) == NULL) {
-	    fprintf(stderr, PROGRAM_NAME ": ERROR: TLS (-Z) not supported on this platform.\n");
-	    exit(1);
-	}
+        WLDAP32Handle = GetModuleHandle("wldap32");
+        if ((Win32_ldap_start_tls_s = (PFldap_start_tls_s) GetProcAddress(WLDAP32Handle, LDAP_START_TLS_S)) == NULL) {
+            fprintf(stderr, PROGRAM_NAME ": ERROR: TLS (-Z) not supported on this platform.\n");
+            exit(1);
+        }
     }
 #endif
 
     if (ld == NULL) {
 #if HAS_URI_SUPPORT
-	if (strstr(ldapServer, "://") != NULL) {
-	    rc = ldap_initialize(&ld, ldapServer);
-	    if (rc != LDAP_SUCCESS) {
-		fprintf(stderr, "\nUnable to connect to LDAPURI:%s\n", ldapServer);
-	    }
-	} else
+        if (strstr(ldapServer, "://") != NULL) {
+            rc = ldap_initialize(&ld, ldapServer);
+            if (rc != LDAP_SUCCESS) {
+                fprintf(stderr, "\nUnable to connect to LDAPURI:%s\n", ldapServer);
+            }
+        } else
 #endif
 #if NETSCAPE_SSL
-	if (sslpath) {
-	    if (!sslinit && (ldapssl_client_init(sslpath, NULL) != LDAP_SUCCESS)) {
-		fprintf(stderr, "\nUnable to initialise SSL with cert path %s\n",
-		    sslpath);
-		exit(1);
-	    } else {
-		sslinit++;
-	    }
-	    if ((ld = ldapssl_init(ldapServer, port, 1)) == NULL) {
-		fprintf(stderr, "\nUnable to connect to SSL LDAP server: %s port:%d\n",
-		    ldapServer, port);
-		exit(1);
-	    }
-	} else
+            if (sslpath) {
+                if (!sslinit && (ldapssl_client_init(sslpath, NULL) != LDAP_SUCCESS)) {
+                    fprintf(stderr, "\nUnable to initialise SSL with cert path %s\n",
+                            sslpath);
+                    exit(1);
+                } else {
+                    sslinit++;
+                }
+                if ((ld = ldapssl_init(ldapServer, port, 1)) == NULL) {
+                    fprintf(stderr, "\nUnable to connect to SSL LDAP server: %s port:%d\n",
+                            ldapServer, port);
+                    exit(1);
+                }
+            } else
 #endif
-	if ((ld = ldap_init(ldapServer, port)) == NULL) {
-	    fprintf(stderr, "\nUnable to connect to LDAP server:%s port:%d\n", ldapServer, port);
-	}
-	if (connect_timeout)
-	    squid_ldap_set_connect_timeout(connect_timeout);
+                if ((ld = ldap_init(ldapServer, port)) == NULL) {
+                    fprintf(stderr, "\nUnable to connect to LDAP server:%s port:%d\n", ldapServer, port);
+                }
+        if (connect_timeout)
+            squid_ldap_set_connect_timeout(connect_timeout);
 
 #ifdef LDAP_VERSION3
-	if (version == -1) {
-	    version = LDAP_VERSION2;
-	}
-	if (ldap_set_option(ld, LDAP_OPT_PROTOCOL_VERSION, &version)
-	    != LDAP_SUCCESS) {
-	    fprintf(stderr, "Could not set LDAP_OPT_PROTOCOL_VERSION %d\n",
-		version);
-	    ldap_unbind(ld);
-	    ld = NULL;
-	}
-	if (use_tls) {
+        if (version == -1) {
+            version = LDAP_VERSION2;
+        }
+        if (ldap_set_option(ld, LDAP_OPT_PROTOCOL_VERSION, &version)
+                != LDAP_SUCCESS) {
+            fprintf(stderr, "Could not set LDAP_OPT_PROTOCOL_VERSION %d\n",
+                    version);
+            ldap_unbind(ld);
+            ld = NULL;
+        }
+        if (use_tls) {
 #ifdef LDAP_OPT_X_TLS
-	    if ((version == LDAP_VERSION3) && (ldap_start_tls_s(ld, NULL, NULL) == LDAP_SUCCESS)) {
-		fprintf(stderr, "Could not Activate TLS connection\n");
-		ldap_unbind(ld);
-		ld = NULL;
-	    }
+            if ((version == LDAP_VERSION3) && (ldap_start_tls_s(ld, NULL, NULL) == LDAP_SUCCESS)) {
+                fprintf(stderr, "Could not Activate TLS connection\n");
+                ldap_unbind(ld);
+                ld = NULL;
+            }
 #else
-	    fprintf(stderr, "TLS not supported with your LDAP library\n");
-	    ldap_unbind(ld);
-	    ld = NULL;
+            fprintf(stderr, "TLS not supported with your LDAP library\n");
+            ldap_unbind(ld);
+            ld = NULL;
 #endif
-	}
+        }
 #endif
-	squid_ldap_set_timelimit(timelimit);
-	squid_ldap_set_referrals(!noreferrals);
-	squid_ldap_set_aliasderef(aliasderef);
-	if (binddn && bindpasswd && *binddn && *bindpasswd) {
-	    rc = ldap_simple_bind_s(ld, binddn, bindpasswd);
-	    if (rc != LDAP_SUCCESS) {
-		fprintf(stderr, PROGRAM_NAME " WARNING, could not bind to binddn '%s'\n", ldap_err2string(rc));
-		ldap_unbind(ld);
-		ld = NULL;
-	    }
-	}
-	if (debug)
-	    fprintf(stderr, "Connected OK\n");
+        squid_ldap_set_timelimit(timelimit);
+        squid_ldap_set_referrals(!noreferrals);
+        squid_ldap_set_aliasderef(aliasderef);
+        if (binddn && bindpasswd && *binddn && *bindpasswd) {
+            rc = ldap_simple_bind_s(ld, binddn, bindpasswd);
+            if (rc != LDAP_SUCCESS) {
+                fprintf(stderr, PROGRAM_NAME " WARNING, could not bind to binddn '%s'\n", ldap_err2string(rc));
+                ldap_unbind(ld);
+                ld = NULL;
+            }
+        }
+        if (debug)
+            fprintf(stderr, "Connected OK\n");
     }
 }
 int
@@ -427,219 +427,219 @@ LDAPArguments(int argc, char **argv)
     setbuf(stdout, NULL);
 
     while (argc > 1 && argv[1][0] == '-') {
-	const char *value = "";
-	char option = argv[1][1];
-	switch (option) {
-	case 'P':
-	case 'R':
-	case 'z':
-	case 'Z':
-	case 'g':
-	case 'e':
-	case 'S':
-	case 'n':
-	case 'd':
-	    break;
-	default:
-	    if (strlen(argv[1]) > 2) {
-		value = argv[1] + 2;
-	    } else if (argc > 2) {
-		value = argv[2];
-		argv++;
-		argc--;
-	    } else
-		value = "";
-	    break;
-	}
-	argv++;
-	argc--;
-	switch (option) {
-	case 'H':
+        const char *value = "";
+        char option = argv[1][1];
+        switch (option) {
+        case 'P':
+        case 'R':
+        case 'z':
+        case 'Z':
+        case 'g':
+        case 'e':
+        case 'S':
+        case 'n':
+        case 'd':
+            break;
+        default:
+            if (strlen(argv[1]) > 2) {
+                value = argv[1] + 2;
+            } else if (argc > 2) {
+                value = argv[2];
+                argv++;
+                argc--;
+            } else
+                value = "";
+            break;
+        }
+        argv++;
+        argc--;
+        switch (option) {
+        case 'H':
 #if !HAS_URI_SUPPORT
-	    fprintf(stderr, "ERROR: Your LDAP library does not have URI support\n");
-	    return 1;
+            fprintf(stderr, "ERROR: Your LDAP library does not have URI support\n");
+            return 1;
 #endif
-	    /* Fall thru to -h */
-	case 'h':
-	    if (ldapServer) {
-		int len = strlen(ldapServer) + 1 + strlen(value) + 1;
-		char *newhost = malloc(len);
-		snprintf(newhost, len, "%s %s", ldapServer, value);
-		free(ldapServer);
-		ldapServer = newhost;
-	    } else {
-		ldapServer = strdup(value);
-	    }
-	    break;
-	case 'A':
-	    passattr = value;
-	    break;
-	case 'e':
-	    encrpass = 1;
-	    break;
-	case 'l':
-	    delimiter = value;
-	    break;
-	case 'b':
-	    userbasedn = value;
-	    break;
-	case 'F':
-	    usersearchfilter = value;
-	    break;
-	case 'u':
-	    userdnattr = value;
-	    break;
-	case 's':
-	    if (strcmp(value, "base") == 0)
-		searchscope = LDAP_SCOPE_BASE;
-	    else if (strcmp(value, "one") == 0)
-		searchscope = LDAP_SCOPE_ONELEVEL;
-	    else if (strcmp(value, "sub") == 0)
-		searchscope = LDAP_SCOPE_SUBTREE;
-	    else {
-		fprintf(stderr, PROGRAM_NAME " ERROR: Unknown search scope '%s'\n", value);
-		return 1;
-	    }
-	    break;
-	case 'S':
+            /* Fall thru to -h */
+        case 'h':
+            if (ldapServer) {
+                int len = strlen(ldapServer) + 1 + strlen(value) + 1;
+                char *newhost = malloc(len);
+                snprintf(newhost, len, "%s %s", ldapServer, value);
+                free(ldapServer);
+                ldapServer = newhost;
+            } else {
+                ldapServer = strdup(value);
+            }
+            break;
+        case 'A':
+            passattr = value;
+            break;
+        case 'e':
+            encrpass = 1;
+            break;
+        case 'l':
+            delimiter = value;
+            break;
+        case 'b':
+            userbasedn = value;
+            break;
+        case 'F':
+            usersearchfilter = value;
+            break;
+        case 'u':
+            userdnattr = value;
+            break;
+        case 's':
+            if (strcmp(value, "base") == 0)
+                searchscope = LDAP_SCOPE_BASE;
+            else if (strcmp(value, "one") == 0)
+                searchscope = LDAP_SCOPE_ONELEVEL;
+            else if (strcmp(value, "sub") == 0)
+                searchscope = LDAP_SCOPE_SUBTREE;
+            else {
+                fprintf(stderr, PROGRAM_NAME " ERROR: Unknown search scope '%s'\n", value);
+                return 1;
+            }
+            break;
+        case 'S':
 #if defined(NETSCAPE_SSL)
-	    sslpath = value;
-	    if (port == LDAP_PORT)
-		port = LDAPS_PORT;
+            sslpath = value;
+            if (port == LDAP_PORT)
+                port = LDAPS_PORT;
 #else
-	    fprintf(stderr, PROGRAM_NAME " ERROR: -E unsupported with this LDAP library\n");
-	    return 1;
+            fprintf(stderr, PROGRAM_NAME " ERROR: -E unsupported with this LDAP library\n");
+            return 1;
 #endif
-	    break;
-	case 'c':
-	    connect_timeout = atoi(value);
-	    break;
-	case 't':
-	    timelimit = atoi(value);
-	    break;
-	case 'a':
-	    if (strcmp(value, "never") == 0)
-		aliasderef = LDAP_DEREF_NEVER;
-	    else if (strcmp(value, "always") == 0)
-		aliasderef = LDAP_DEREF_ALWAYS;
-	    else if (strcmp(value, "search") == 0)
-		aliasderef = LDAP_DEREF_SEARCHING;
-	    else if (strcmp(value, "find") == 0)
-		aliasderef = LDAP_DEREF_FINDING;
-	    else {
-		fprintf(stderr, PROGRAM_NAME " ERROR: Unknown alias dereference method '%s'\n", value);
-		return 1;
-	    }
-	    break;
-	case 'D':
-	    binddn = value;
-	    break;
-	case 'w':
-	    bindpasswd = value;
-	    break;
-	case 'W':
-	    readSecret(value);
-	    break;
-	case 'P':
-	    persistent = !persistent;
-	    break;
-	case 'p':
-	    port = atoi(value);
-	    break;
-	case 'R':
-	    noreferrals = !noreferrals;
-	    break;
+            break;
+        case 'c':
+            connect_timeout = atoi(value);
+            break;
+        case 't':
+            timelimit = atoi(value);
+            break;
+        case 'a':
+            if (strcmp(value, "never") == 0)
+                aliasderef = LDAP_DEREF_NEVER;
+            else if (strcmp(value, "always") == 0)
+                aliasderef = LDAP_DEREF_ALWAYS;
+            else if (strcmp(value, "search") == 0)
+                aliasderef = LDAP_DEREF_SEARCHING;
+            else if (strcmp(value, "find") == 0)
+                aliasderef = LDAP_DEREF_FINDING;
+            else {
+                fprintf(stderr, PROGRAM_NAME " ERROR: Unknown alias dereference method '%s'\n", value);
+                return 1;
+            }
+            break;
+        case 'D':
+            binddn = value;
+            break;
+        case 'w':
+            bindpasswd = value;
+            break;
+        case 'W':
+            readSecret(value);
+            break;
+        case 'P':
+            persistent = !persistent;
+            break;
+        case 'p':
+            port = atoi(value);
+            break;
+        case 'R':
+            noreferrals = !noreferrals;
+            break;
 #ifdef LDAP_VERSION3
-	case 'v':
-	    switch (atoi(value)) {
-	    case 2:
-		version = LDAP_VERSION2;
-		break;
-	    case 3:
-		version = LDAP_VERSION3;
-		break;
-	    default:
-		fprintf(stderr, "Protocol version should be 2 or 3\n");
-		return 1;
-	    }
-	    break;
-	case 'Z':
-	    if (version == LDAP_VERSION2) {
-		fprintf(stderr, "TLS (-Z) is incompatible with version %d\n",
-		    version);
-		return 1;
-	    }
-	    version = LDAP_VERSION3;
-	    use_tls = 1;
-	    break;
+        case 'v':
+            switch (atoi(value)) {
+            case 2:
+                version = LDAP_VERSION2;
+                break;
+            case 3:
+                version = LDAP_VERSION3;
+                break;
+            default:
+                fprintf(stderr, "Protocol version should be 2 or 3\n");
+                return 1;
+            }
+            break;
+        case 'Z':
+            if (version == LDAP_VERSION2) {
+                fprintf(stderr, "TLS (-Z) is incompatible with version %d\n",
+                        version);
+                return 1;
+            }
+            version = LDAP_VERSION3;
+            use_tls = 1;
+            break;
 #endif
-	case 'd':
-	    debug = 1;
-	    break;
-	case 'E':
-	    strip_nt_domain = 1;
-	    break;
-	case 'n':
-	    edir_universal_passwd = 1;
-	    break;
-	default:
-	    fprintf(stderr, PROGRAM_NAME " ERROR: Unknown command line option '%c'\n", option);
-	    return 1;
-	}
+        case 'd':
+            debug = 1;
+            break;
+        case 'E':
+            strip_nt_domain = 1;
+            break;
+        case 'n':
+            edir_universal_passwd = 1;
+            break;
+        default:
+            fprintf(stderr, PROGRAM_NAME " ERROR: Unknown command line option '%c'\n", option);
+            return 1;
+        }
     }
 
     while (argc > 1) {
-	char *value = argv[1];
-	if (ldapServer) {
-	    int len = strlen(ldapServer) + 1 + strlen(value) + 1;
-	    char *newhost = malloc(len);
-	    snprintf(newhost, len, "%s %s", ldapServer, value);
-	    free(ldapServer);
-	    ldapServer = newhost;
-	} else {
-	    ldapServer = strdup(value);
-	}
-	argc--;
-	argv++;
+        char *value = argv[1];
+        if (ldapServer) {
+            int len = strlen(ldapServer) + 1 + strlen(value) + 1;
+            char *newhost = malloc(len);
+            snprintf(newhost, len, "%s %s", ldapServer, value);
+            free(ldapServer);
+            ldapServer = newhost;
+        } else {
+            ldapServer = strdup(value);
+        }
+        argc--;
+        argv++;
     }
 
     if (!ldapServer)
-	ldapServer = (char *) "localhost";
+        ldapServer = (char *) "localhost";
 
     if (!userbasedn || !((passattr != NULL) || (edir_universal_passwd && usersearchfilter && version == LDAP_VERSION3 && use_tls))) {
-	fprintf(stderr, "Usage: " PROGRAM_NAME " -b basedn -f filter [options] ldap_server_name\n\n");
-	fprintf(stderr, "\t-A password attribute(REQUIRED)\t\tUser attribute that contains the password\n");
-	fprintf(stderr, "\t-l password realm delimiter(REQUIRED)\tCharater(s) that devides the password attribute\n\t\t\t\t\t\tin realm and password tokens, default ':' realm:password\n");
-	fprintf(stderr, "\t-b basedn (REQUIRED)\t\t\tbase dn under where to search for users\n");
-	fprintf(stderr, "\t-e Encrypted passwords(REQUIRED)\tPassword are stored encrypted using HHA1\n");
-	fprintf(stderr, "\t-F filter\t\t\t\tuser search filter pattern. %%s = login\n");
-	fprintf(stderr, "\t-u attribute\t\t\t\tattribute to use in combination with the basedn to create the user DN\n");
-	fprintf(stderr, "\t-s base|one|sub\t\t\t\tsearch scope\n");
-	fprintf(stderr, "\t-D binddn\t\t\t\tDN to bind as to perform searches\n");
-	fprintf(stderr, "\t-w bindpasswd\t\t\t\tpassword for binddn\n");
-	fprintf(stderr, "\t-W secretfile\t\t\t\tread password for binddn from file secretfile\n");
+        fprintf(stderr, "Usage: " PROGRAM_NAME " -b basedn -f filter [options] ldap_server_name\n\n");
+        fprintf(stderr, "\t-A password attribute(REQUIRED)\t\tUser attribute that contains the password\n");
+        fprintf(stderr, "\t-l password realm delimiter(REQUIRED)\tCharater(s) that devides the password attribute\n\t\t\t\t\t\tin realm and password tokens, default ':' realm:password\n");
+        fprintf(stderr, "\t-b basedn (REQUIRED)\t\t\tbase dn under where to search for users\n");
+        fprintf(stderr, "\t-e Encrypted passwords(REQUIRED)\tPassword are stored encrypted using HHA1\n");
+        fprintf(stderr, "\t-F filter\t\t\t\tuser search filter pattern. %%s = login\n");
+        fprintf(stderr, "\t-u attribute\t\t\t\tattribute to use in combination with the basedn to create the user DN\n");
+        fprintf(stderr, "\t-s base|one|sub\t\t\t\tsearch scope\n");
+        fprintf(stderr, "\t-D binddn\t\t\t\tDN to bind as to perform searches\n");
+        fprintf(stderr, "\t-w bindpasswd\t\t\t\tpassword for binddn\n");
+        fprintf(stderr, "\t-W secretfile\t\t\t\tread password for binddn from file secretfile\n");
 #if HAS_URI_SUPPORT
-	fprintf(stderr, "\t-H URI\t\t\t\t\tLDAPURI (defaults to ldap://localhost)\n");
+        fprintf(stderr, "\t-H URI\t\t\t\t\tLDAPURI (defaults to ldap://localhost)\n");
 #endif
-	fprintf(stderr, "\t-h server\t\t\t\tLDAP server (defaults to localhost)\n");
-	fprintf(stderr, "\t-p port\t\t\t\t\tLDAP server port (defaults to %d)\n", LDAP_PORT);
-	fprintf(stderr, "\t-P\t\t\t\t\tpersistent LDAP connection\n");
+        fprintf(stderr, "\t-h server\t\t\t\tLDAP server (defaults to localhost)\n");
+        fprintf(stderr, "\t-p port\t\t\t\t\tLDAP server port (defaults to %d)\n", LDAP_PORT);
+        fprintf(stderr, "\t-P\t\t\t\t\tpersistent LDAP connection\n");
 #if defined(NETSCAPE_SSL)
-	fprintf(stderr, "\t-E sslcertpath\t\t\t\tenable LDAP over SSL\n");
+        fprintf(stderr, "\t-E sslcertpath\t\t\t\tenable LDAP over SSL\n");
 #endif
-	fprintf(stderr, "\t-c timeout\t\t\t\tconnect timeout\n");
-	fprintf(stderr, "\t-t timelimit\t\t\t\tsearch time limit\n");
-	fprintf(stderr, "\t-R\t\t\t\t\tdo not follow referrals\n");
-	fprintf(stderr, "\t-a never|always|search|find\t\twhen to dereference aliases\n");
+        fprintf(stderr, "\t-c timeout\t\t\t\tconnect timeout\n");
+        fprintf(stderr, "\t-t timelimit\t\t\t\tsearch time limit\n");
+        fprintf(stderr, "\t-R\t\t\t\t\tdo not follow referrals\n");
+        fprintf(stderr, "\t-a never|always|search|find\t\twhen to dereference aliases\n");
 #ifdef LDAP_VERSION3
-	fprintf(stderr, "\t-v 2|3\t\t\t\t\tLDAP version\n");
-	fprintf(stderr, "\t-Z\t\t\t\t\tTLS encrypt the LDAP connection, requires\n\t\t\t\tLDAP version 3\n");
+        fprintf(stderr, "\t-v 2|3\t\t\t\t\tLDAP version\n");
+        fprintf(stderr, "\t-Z\t\t\t\t\tTLS encrypt the LDAP connection, requires\n\t\t\t\tLDAP version 3\n");
 #endif
-	fprintf(stderr, "\t-S\t\t\t\t\tStrip NT domain from usernames\n");
-	fprintf(stderr, "\t-n\t\t\t\t\tGet an eDirectory Universal Password from Novell NMAS\n\t\t\t\t\t\t(requires bind credentials, version 3, TLS, and a search filter)\n");
-	fprintf(stderr, "\n");
-	fprintf(stderr, "\tIf you need to bind as a user to perform searches then use the\n\t-D binddn -w bindpasswd or -D binddn -W secretfile options\n\n");
-	return -1;
+        fprintf(stderr, "\t-S\t\t\t\t\tStrip NT domain from usernames\n");
+        fprintf(stderr, "\t-n\t\t\t\t\tGet an eDirectory Universal Password from Novell NMAS\n\t\t\t\t\t\t(requires bind credentials, version 3, TLS, and a search filter)\n");
+        fprintf(stderr, "\n");
+        fprintf(stderr, "\tIf you need to bind as a user to perform searches then use the\n\t-D binddn -w bindpasswd or -D binddn -W secretfile options\n\n");
+        return -1;
     }
     return 0;
 }
@@ -651,23 +651,23 @@ readSecret(const char *filename)
     FILE *f;
 
     if (!(f = fopen(filename, "r"))) {
-	fprintf(stderr, PROGRAM_NAME " ERROR: Can not read secret file %s\n", filename);
-	return 1;
+        fprintf(stderr, PROGRAM_NAME " ERROR: Can not read secret file %s\n", filename);
+        return 1;
     }
     if (!fgets(buf, sizeof(buf) - 1, f)) {
-	fprintf(stderr, PROGRAM_NAME " ERROR: Secret file %s is empty\n", filename);
-	fclose(f);
-	return 1;
+        fprintf(stderr, PROGRAM_NAME " ERROR: Secret file %s is empty\n", filename);
+        fclose(f);
+        return 1;
     }
     /* strip whitespaces on end */
     if ((e = strrchr(buf, '\n')))
-	*e = 0;
+        *e = 0;
     if ((e = strrchr(buf, '\r')))
-	*e = 0;
+        *e = 0;
 
     bindpasswd = strdup(buf);
     if (!bindpasswd) {
-	fprintf(stderr, PROGRAM_NAME " ERROR: can not allocate memory\n");
+        fprintf(stderr, PROGRAM_NAME " ERROR: can not allocate memory\n");
     }
     fclose(f);
 
@@ -681,15 +681,15 @@ LDAPHHA1(RequestData * requestData)
     ldapconnect();
     password = getpassword(requestData->user, requestData->realm);
     if (password != NULL) {
-	if (encrpass)
-	    xstrncpy(requestData->HHA1, password, sizeof(requestData->HHA1));
-	else {
-	    HASH HA1;
-	    DigestCalcHA1("md5", requestData->user, requestData->realm, password, NULL, NULL, HA1, requestData->HHA1);
-	}
-	free(password);
+        if (encrpass)
+            xstrncpy(requestData->HHA1, password, sizeof(requestData->HHA1));
+        else {
+            HASH HA1;
+            DigestCalcHA1("md5", requestData->user, requestData->realm, password, NULL, NULL, HA1, requestData->HHA1);
+        }
+        free(password);
     } else {
-	requestData->error = -1;
+        requestData->error = -1;
     }
 
 }
@@ -50,8 +50,8 @@ typedef struct _request_data {
     int error;
 } RequestData;
 
-/* to use a backend, include your backend.h file 
- * and define thusly: 
+/* to use a backend, include your backend.h file
+ * and define thusly:
  * #define ProcessArguments(A, B) MyHandleArguments(A,B)
  * #define GetHHA1(A) MyGetHHA1(A)
  */
@@ -12,7 +12,7 @@
  * - comment lines are possible and should start with a '#';
  * - empty or blank lines are possible;
  * - file format is username:password
- * 
+ *
  * To build a directory integrated backend, you need to be able to
  * calculate the HA1 returned to squid. To avoid storing a plaintext
  * password you can calculate MD5(username:realm:password) when the
@@ -47,13 +47,13 @@ ParseBuffer(char *buf, RequestData * requestData)
     char *p;
     requestData->parsed = 0;
     if ((p = strchr(buf, '\n')) != NULL)
-	*p = '\0';		/* strip \n */
+        *p = '\0';		/* strip \n */
     if ((requestData->user = strtok(buf, "\"")) == NULL)
-	return;
+        return;
     if ((requestData->realm = strtok(NULL, "\"")) == NULL)
-	return;
+        return;
     if ((requestData->realm = strtok(NULL, "\"")) == NULL)
-	return;
+        return;
     requestData->parsed = -1;
 }
 
@@ -63,8 +63,8 @@ OutputHHA1(RequestData * requestData)
     requestData->error = 0;
     GetHHA1(requestData);
     if (requestData->error) {
-	printf("ERR No such user\n");
-	return;
+        printf("ERR No such user\n");
+        return;
     }
     printf("%s\n", requestData->HHA1);
 }
@@ -75,8 +75,8 @@ DoOneRequest(char *buf)
     RequestData requestData;
     ParseBuffer(buf, &requestData);
     if (!requestData.parsed) {
-	printf("ERR\n");
-	return;
+        printf("ERR\n");
+        return;
     }
     OutputHHA1(&requestData);
 }
@@ -87,7 +87,7 @@ ProcessArguments(int argc, char **argv)
     int i;
     i = LDAPArguments(argc, argv);
     if (i)
-	exit(i);
+        exit(i);
 }
 
 int
@@ -97,6 +97,6 @@ main(int argc, char **argv)
     setbuf(stdout, NULL);
     ProcessArguments(argc, argv);
     while (fgets(buf, 256, stdin) != NULL)
-	DoOneRequest(buf);
+        DoOneRequest(buf);
     exit(0);
 }
@@ -91,7 +91,7 @@ squid_ldap_set_aliasderef(int deref)
 static void
 squid_ldap_set_referrals(int referrals)
 {
-    int *value = referrals ? LDAP_OPT_ON : LDAP_OPT_OFF;
+    int *value = referrals ? LDAP_OPT_ON :LDAP_OPT_OFF;
     ldap_set_option(ld, LDAP_OPT_REFERRALS, value);
 }
 static void
@@ -128,9 +128,9 @@ static void
 squid_ldap_set_referrals(int referrals)
 {
     if (referrals)
-	ld->ld_options |= ~LDAP_OPT_REFERRALS;
+        ld->ld_options |= ~LDAP_OPT_REFERRALS;
     else
-	ld->ld_options &= ~LDAP_OPT_REFERRALS;
+        ld->ld_options &= ~LDAP_OPT_REFERRALS;
 }
 static void
 squid_ldap_set_timelimit(int timelimit)
@@ -161,24 +161,24 @@ ldap_escape_value(char *escaped, int size, const char *src)
 {
     int n = 0;
     while (size > 4 && *src) {
-	switch (*src) {
-	case '*':
-	case '(':
-	case ')':
-	case '\\':
-	    n += 3;
-	    size -= 3;
-	    if (size > 0) {
-		*escaped++ = '\\';
-		snprintf(escaped, 3, "%02x", (int) *src++);
-		escaped += 2;
-	    }
-	    break;
-	default:
-	    *escaped++ = *src++;
-	    n++;
-	    size--;
-	}
+        switch (*src) {
+        case '*':
+        case '(':
+        case ')':
+        case '\\':
+            n += 3;
+            size -= 3;
+            if (size > 0) {
+                *escaped++ = '\\';
+                snprintf(escaped, 3, "%02x", (int) *src++);
+                escaped += 2;
+            }
+            break;
+        default:
+            *escaped++ = *src++;
+            n++;
+            size--;
+        }
     }
     *escaped = '\0';
     return n;
@@ -197,99 +197,99 @@ getpassword(char *login, char *realm)
     char searchbase[8192];
     int rc = -1;
     if (ld) {
-	if (usersearchfilter) {
-	    char escaped_login[1024];
-	    snprintf(searchbase, sizeof(searchbase), "%s", userbasedn);
-	    ldap_escape_value(escaped_login, sizeof(escaped_login), login);
-	    snprintf(filter, sizeof(filter), usersearchfilter, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login);
-
-	  retrysrch:
-	    if (debug)
-		fprintf(stderr, "user filter '%s', searchbase '%s'\n", filter, searchbase);
-
-	    rc = ldap_search_s(ld, searchbase, searchscope, filter, NULL, 0, &res);
-	    if (rc != LDAP_SUCCESS) {
-		if (noreferrals && rc == LDAP_PARTIAL_RESULTS) {
-		    /* Everything is fine. This is expected when referrals
-		     * are disabled.
-		     */
-		    rc = LDAP_SUCCESS;
-		} else {
-		    fprintf(stderr, PROGRAM_NAME " WARNING, LDAP search error '%s'\n", ldap_err2string(rc));
+        if (usersearchfilter) {
+            char escaped_login[1024];
+            snprintf(searchbase, sizeof(searchbase), "%s", userbasedn);
+            ldap_escape_value(escaped_login, sizeof(escaped_login), login);
+            snprintf(filter, sizeof(filter), usersearchfilter, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login);
+
+retrysrch:
+            if (debug)
+                fprintf(stderr, "user filter '%s', searchbase '%s'\n", filter, searchbase);
+
+            rc = ldap_search_s(ld, searchbase, searchscope, filter, NULL, 0, &res);
+            if (rc != LDAP_SUCCESS) {
+                if (noreferrals && rc == LDAP_PARTIAL_RESULTS) {
+                    /* Everything is fine. This is expected when referrals
+                     * are disabled.
+                     */
+                    rc = LDAP_SUCCESS;
+                } else {
+                    fprintf(stderr, PROGRAM_NAME " WARNING, LDAP search error '%s'\n", ldap_err2string(rc));
 #if defined(NETSCAPE_SSL)
-		    if (sslpath && ((rc == LDAP_SERVER_DOWN) || (rc == LDAP_CONNECT_ERROR))) {
-			int sslerr = PORT_GetError();
-			fprintf(stderr, PROGRAM_NAME ": WARNING, SSL error %d (%s)\n", sslerr, ldapssl_err2string(sslerr));
-		    }
+                    if (sslpath && ((rc == LDAP_SERVER_DOWN) || (rc == LDAP_CONNECT_ERROR))) {
+                        int sslerr = PORT_GetError();
+                        fprintf(stderr, PROGRAM_NAME ": WARNING, SSL error %d (%s)\n", sslerr, ldapssl_err2string(sslerr));
+                    }
 #endif
-		    fprintf(stderr, PROGRAM_NAME " WARNING, LDAP search error, trying to recover'%s'\n", ldap_err2string(rc));
-		    ldap_msgfree(res);
-		    /* try to connect to the LDAP server agin, maybe my persisten conexion failed. */
-		    if (!retry) {
-			retry++;
-			ldap_unbind(ld);
-			ld = NULL;
-			ldapconnect();
-			goto retrysrch;
-		    }
-		    return NULL;
-
-		}
-	    }
-	} else if (userdnattr) {
-	    sprintf(searchbase, "%s=%s, %s", userdnattr, login, userbasedn);
-
-	  retrydnattr:
-	    if (debug)
-		fprintf(stderr, "searchbase '%s'\n", searchbase);
-	    rc = ldap_search_s(ld, searchbase, searchscope, NULL, NULL, 0, &res);
-	}
-	if (rc == LDAP_SUCCESS) {
-	    entry = ldap_first_entry(ld, res);
-	    if (entry)
-		values = ldap_get_values(ld, entry, passattr);
-	    else {
-		ldap_msgfree(res);
-		return NULL;
-	    }
-	    if (!values) {
-		if (debug)
-		    printf("No attribute value found\n");
-		ldap_msgfree(res);
-		return NULL;
-	    }
-	    value = values;
-	    while (*value) {
-		if (encrpass) {
-		    if (strcmp(strtok(*value, delimiter), realm) == 0) {
-			password = strtok(NULL, delimiter);
-			break;
-		    }
-		} else {
-		    password = *value;
-		    break;
-		}
-		value++;
-	    }
-	    if (debug)
-		printf("password: %s\n", password);
-	    if (password)
-		password = strdup(password);
-	    ldap_value_free(values);
-	    ldap_msgfree(res);
-	    return password;
-	} else {
-	    fprintf(stderr, PROGRAM_NAME " WARNING, LDAP error '%s'\n", ldap_err2string(rc));
-	    /* try to connect to the LDAP server agin, maybe my persisten conexion failed. */
-	    if (!retry) {
-		retry++;
-		ldap_unbind(ld);
-		ld = NULL;
-		ldapconnect();
-		goto retrydnattr;
-	    }
-	    return NULL;
-	}
+                    fprintf(stderr, PROGRAM_NAME " WARNING, LDAP search error, trying to recover'%s'\n", ldap_err2string(rc));
+                    ldap_msgfree(res);
+                    /* try to connect to the LDAP server agin, maybe my persisten conexion failed. */
+                    if (!retry) {
+                        retry++;
+                        ldap_unbind(ld);
+                        ld = NULL;
+                        ldapconnect();
+                        goto retrysrch;
+                    }
+                    return NULL;
+
+                }
+            }
+        } else if (userdnattr) {
+            sprintf(searchbase, "%s=%s, %s", userdnattr, login, userbasedn);
+
+retrydnattr:
+            if (debug)
+                fprintf(stderr, "searchbase '%s'\n", searchbase);
+            rc = ldap_search_s(ld, searchbase, searchscope, NULL, NULL, 0, &res);
+        }
+        if (rc == LDAP_SUCCESS) {
+            entry = ldap_first_entry(ld, res);
+            if (entry)
+                values = ldap_get_values(ld, entry, passattr);
+            else {
+                ldap_msgfree(res);
+                return NULL;
+            }
+            if (!values) {
+                if (debug)
+                    printf("No attribute value found\n");
+                ldap_msgfree(res);
+                return NULL;
+            }
+            value = values;
+            while (*value) {
+                if (encrpass) {
+                    if (strcmp(strtok(*value, delimiter), realm) == 0) {
+                        password = strtok(NULL, delimiter);
+                        break;
+                    }
+                } else {
+                    password = *value;
+                    break;
+                }
+                value++;
+            }
+            if (debug)
+                printf("password: %s\n", password);
+            if (password)
+                password = strdup(password);
+            ldap_value_free(values);
+            ldap_msgfree(res);
+            return password;
+        } else {
+            fprintf(stderr, PROGRAM_NAME " WARNING, LDAP error '%s'\n", ldap_err2string(rc));
+            /* try to connect to the LDAP server agin, maybe my persisten conexion failed. */
+            if (!retry) {
+                retry++;
+                ldap_unbind(ld);
+                ld = NULL;
+                ldapconnect();
+                goto retrydnattr;
+            }
+            return NULL;
+        }
     }
     return NULL;
 }
@@ -301,91 +301,91 @@ ldapconnect(void)
 {
     int rc;
 
-/* On Windows ldap_start_tls_s is available starting from Windows XP, 
- * so we need to bind at run-time with the function entry point
- */
+    /* On Windows ldap_start_tls_s is available starting from Windows XP,
+     * so we need to bind at run-time with the function entry point
+     */
 #ifdef _SQUID_MSWIN_
     if (use_tls) {
 
-	HMODULE WLDAP32Handle;
+        HMODULE WLDAP32Handle;
 
-	WLDAP32Handle = GetModuleHandle("wldap32");
-	if ((Win32_ldap_start_tls_s = (PFldap_start_tls_s) GetProcAddress(WLDAP32Handle, LDAP_START_TLS_S)) == NULL) {
-	    fprintf(stderr, PROGRAM_NAME ": ERROR: TLS (-Z) not supported on this platform.\n");
-	    exit(1);
-	}
+        WLDAP32Handle = GetModuleHandle("wldap32");
+        if ((Win32_ldap_start_tls_s = (PFldap_start_tls_s) GetProcAddress(WLDAP32Handle, LDAP_START_TLS_S)) == NULL) {
+            fprintf(stderr, PROGRAM_NAME ": ERROR: TLS (-Z) not supported on this platform.\n");
+            exit(1);
+        }
     }
 #endif
 
     if (ld == NULL) {
 #if HAS_URI_SUPPORT
-	if (strstr(ldapServer, "://") != NULL) {
-	    rc = ldap_initialize(&ld, ldapServer);
-	    if (rc != LDAP_SUCCESS) {
-		fprintf(stderr, "\nUnable to connect to LDAPURI:%s\n", ldapServer);
-	    }
-	} else
+        if (strstr(ldapServer, "://") != NULL) {
+            rc = ldap_initialize(&ld, ldapServer);
+            if (rc != LDAP_SUCCESS) {
+                fprintf(stderr, "\nUnable to connect to LDAPURI:%s\n", ldapServer);
+            }
+        } else
 #endif
 #if NETSCAPE_SSL
-	if (sslpath) {
-	    if (!sslinit && (ldapssl_client_init(sslpath, NULL) != LDAP_SUCCESS)) {
-		fprintf(stderr, "\nUnable to initialise SSL with cert path %s\n",
-		    sslpath);
-		exit(1);
-	    } else {
-		sslinit++;
-	    }
-	    if ((ld = ldapssl_init(ldapServer, port, 1)) == NULL) {
-		fprintf(stderr, "\nUnable to connect to SSL LDAP server: %s port:%d\n",
-		    ldapServer, port);
-		exit(1);
-	    }
-	} else
+            if (sslpath) {
+                if (!sslinit && (ldapssl_client_init(sslpath, NULL) != LDAP_SUCCESS)) {
+                    fprintf(stderr, "\nUnable to initialise SSL with cert path %s\n",
+                            sslpath);
+                    exit(1);
+                } else {
+                    sslinit++;
+                }
+                if ((ld = ldapssl_init(ldapServer, port, 1)) == NULL) {
+                    fprintf(stderr, "\nUnable to connect to SSL LDAP server: %s port:%d\n",
+                            ldapServer, port);
+                    exit(1);
+                }
+            } else
 #endif
-	if ((ld = ldap_init(ldapServer, port)) == NULL) {
-	    fprintf(stderr, "\nUnable to connect to LDAP server:%s port:%d\n", ldapServer, port);
-	}
-	if (connect_timeout)
-	    squid_ldap_set_connect_timeout(connect_timeout);
+                if ((ld = ldap_init(ldapServer, port)) == NULL) {
+                    fprintf(stderr, "\nUnable to connect to LDAP server:%s port:%d\n", ldapServer, port);
+                }
+        if (connect_timeout)
+            squid_ldap_set_connect_timeout(connect_timeout);
 
 #ifdef LDAP_VERSION3
-	if (version == -1) {
-	    version = LDAP_VERSION2;
-	}
-	if (ldap_set_option(ld, LDAP_OPT_PROTOCOL_VERSION, &version)
-	    != LDAP_SUCCESS) {
-	    fprintf(stderr, "Could not set LDAP_OPT_PROTOCOL_VERSION %d\n",
-		version);
-	    ldap_unbind(ld);
-	    ld = NULL;
-	}
-	if (use_tls) {
+        if (version == -1) {
+            version = LDAP_VERSION2;
+        }
+        if (ldap_set_option(ld, LDAP_OPT_PROTOCOL_VERSION, &version)
+                != LDAP_SUCCESS) {
+            fprintf(stderr, "Could not set LDAP_OPT_PROTOCOL_VERSION %d\n",
+                    version);
+            ldap_unbind(ld);
+            ld = NULL;
+        }
+        if (use_tls) {
 #ifdef LDAP_OPT_X_TLS
-	    if ((version == LDAP_VERSION3) && (ldap_start_tls_s(ld, NULL, NULL) == LDAP_SUCCESS)) {
-		fprintf(stderr, "Could not Activate TLS connection\n");
-		ldap_unbind(ld);
-		ld = NULL;
-	    }
+            if ((version == LDAP_VERSION3) && (ldap_start_tls_s(ld, NULL, NULL) == LDAP_SUCCESS)) {
+                fprintf(stderr, "Could not Activate TLS connection\n");
+                ldap_unbind(ld);
+                ld = NULL;
+            }
 #else
-	    fprintf(stderr, "TLS not supported with your LDAP library\n");
-	    ldap_unbind(ld);
-	    ld = NULL;
+            fprintf(stderr, "TLS not supported with your LDAP library\n");
+            ldap_unbind(ld);
+            ld = NULL;
 #endif
-	}
+        }
 #endif
-	squid_ldap_set_timelimit(timelimit);
-	squid_ldap_set_referrals(!noreferrals);
-	squid_ldap_set_aliasderef(aliasderef);
-	if (binddn && bindpasswd && *binddn && *bindpasswd) {
-	    rc = ldap_simple_bind_s(ld, binddn, bindpasswd);
-	    if (rc != LDAP_SUCCESS) {
-		fprintf(stderr, PROGRAM_NAME " WARNING, could not bind to binddn '%s'\n", ldap_err2string(rc));
-		ldap_unbind(ld);
-		ld = NULL;
-	    }
-	}
-	if (debug)
-	    fprintf(stderr, "Connected OK\n");
+        squid_ldap_set_timelimit(timelimit);
+        squid_ldap_set_referrals(!noreferrals);
+        squid_ldap_set_aliasderef(aliasderef);
+        if (binddn && bindpasswd && *binddn && *bindpasswd) {
+            rc = ldap_simple_bind_s(ld, binddn, bindpasswd);
+            if (rc != LDAP_SUCCESS) {
+                fprintf(stderr, PROGRAM_NAME " WARNING, could not bind to binddn '%s'\n", ldap_err2string(rc));
+                ldap_unbind(ld);
+                ld = NULL;
+            }
+        }
+        if (debug)
+            fprintf(stderr, "Connected OK\n");
     }
 }
 int
@@ -394,213 +394,213 @@ LDAPArguments(int argc, char **argv)
     setbuf(stdout, NULL);
 
     while (argc > 1 && argv[1][0] == '-') {
-	const char *value = "";
-	char option = argv[1][1];
-	switch (option) {
-	case 'P':
-	case 'R':
-	case 'z':
-	case 'Z':
-	case 'g':
-	case 'e':
-	case 'S':
-	    break;
-	default:
-	    if (strlen(argv[1]) > 2) {
-		value = argv[1] + 2;
-	    } else if (argc > 2) {
-		value = argv[2];
-		argv++;
-		argc--;
-	    } else
-		value = "";
-	    break;
-	}
-	argv++;
-	argc--;
-	switch (option) {
-	case 'H':
+        const char *value = "";
+        char option = argv[1][1];
+        switch (option) {
+        case 'P':
+        case 'R':
+        case 'z':
+        case 'Z':
+        case 'g':
+        case 'e':
+        case 'S':
+            break;
+        default:
+            if (strlen(argv[1]) > 2) {
+                value = argv[1] + 2;
+            } else if (argc > 2) {
+                value = argv[2];
+                argv++;
+                argc--;
+            } else
+                value = "";
+            break;
+        }
+        argv++;
+        argc--;
+        switch (option) {
+        case 'H':
 #if !HAS_URI_SUPPORT
-	    fprintf(stderr, "ERROR: Your LDAP library does not have URI support\n");
-	    return 1;
+            fprintf(stderr, "ERROR: Your LDAP library does not have URI support\n");
+            return 1;
 #endif
-	    /* Fall thru to -h */
-	case 'h':
-	    if (ldapServer) {
-		int len = strlen(ldapServer) + 1 + strlen(value) + 1;
-		char *newhost = malloc(len);
-		snprintf(newhost, len, "%s %s", ldapServer, value);
-		free(ldapServer);
-		ldapServer = newhost;
-	    } else {
-		ldapServer = strdup(value);
-	    }
-	    break;
-	case 'A':
-	    passattr = value;
-	    break;
-	case 'e':
-	    encrpass = 1;
-	    break;
-	case 'l':
-	    delimiter = value;
-	    break;
-	case 'b':
-	    userbasedn = value;
-	    break;
-	case 'F':
-	    usersearchfilter = value;
-	    break;
-	case 'u':
-	    userdnattr = value;
-	    break;
-	case 's':
-	    if (strcmp(value, "base") == 0)
-		searchscope = LDAP_SCOPE_BASE;
-	    else if (strcmp(value, "one") == 0)
-		searchscope = LDAP_SCOPE_ONELEVEL;
-	    else if (strcmp(value, "sub") == 0)
-		searchscope = LDAP_SCOPE_SUBTREE;
-	    else {
-		fprintf(stderr, PROGRAM_NAME " ERROR: Unknown search scope '%s'\n", value);
-		return 1;
-	    }
-	    break;
-	case 'S':
+            /* Fall thru to -h */
+        case 'h':
+            if (ldapServer) {
+                int len = strlen(ldapServer) + 1 + strlen(value) + 1;
+                char *newhost = malloc(len);
+                snprintf(newhost, len, "%s %s", ldapServer, value);
+                free(ldapServer);
+                ldapServer = newhost;
+            } else {
+                ldapServer = strdup(value);
+            }
+            break;
+        case 'A':
+            passattr = value;
+            break;
+        case 'e':
+            encrpass = 1;
+            break;
+        case 'l':
+            delimiter = value;
+            break;
+        case 'b':
+            userbasedn = value;
+            break;
+        case 'F':
+            usersearchfilter = value;
+            break;
+        case 'u':
+            userdnattr = value;
+            break;
+        case 's':
+            if (strcmp(value, "base") == 0)
+                searchscope = LDAP_SCOPE_BASE;
+            else if (strcmp(value, "one") == 0)
+                searchscope = LDAP_SCOPE_ONELEVEL;
+            else if (strcmp(value, "sub") == 0)
+                searchscope = LDAP_SCOPE_SUBTREE;
+            else {
+                fprintf(stderr, PROGRAM_NAME " ERROR: Unknown search scope '%s'\n", value);
+                return 1;
+            }
+            break;
+        case 'S':
 #if defined(NETSCAPE_SSL)
-	    sslpath = value;
-	    if (port == LDAP_PORT)
-		port = LDAPS_PORT;
+            sslpath = value;
+            if (port == LDAP_PORT)
+                port = LDAPS_PORT;
 #else
-	    fprintf(stderr, PROGRAM_NAME " ERROR: -E unsupported with this LDAP library\n");
-	    return 1;
+            fprintf(stderr, PROGRAM_NAME " ERROR: -E unsupported with this LDAP library\n");
+            return 1;
 #endif
-	    break;
-	case 'c':
-	    connect_timeout = atoi(value);
-	    break;
-	case 't':
-	    timelimit = atoi(value);
-	    break;
-	case 'a':
-	    if (strcmp(value, "never") == 0)
-		aliasderef = LDAP_DEREF_NEVER;
-	    else if (strcmp(value, "always") == 0)
-		aliasderef = LDAP_DEREF_ALWAYS;
-	    else if (strcmp(value, "search") == 0)
-		aliasderef = LDAP_DEREF_SEARCHING;
-	    else if (strcmp(value, "find") == 0)
-		aliasderef = LDAP_DEREF_FINDING;
-	    else {
-		fprintf(stderr, PROGRAM_NAME " ERROR: Unknown alias dereference method '%s'\n", value);
-		return 1;
-	    }
-	    break;
-	case 'D':
-	    binddn = value;
-	    break;
-	case 'w':
-	    bindpasswd = value;
-	    break;
-	case 'W':
-	    readSecret(value);
-	    break;
-	case 'P':
-	    persistent = !persistent;
-	    break;
-	case 'p':
-	    port = atoi(value);
-	    break;
-	case 'R':
-	    noreferrals = !noreferrals;
-	    break;
+            break;
+        case 'c':
+            connect_timeout = atoi(value);
+            break;
+        case 't':
+            timelimit = atoi(value);
+            break;
+        case 'a':
+            if (strcmp(value, "never") == 0)
+                aliasderef = LDAP_DEREF_NEVER;
+            else if (strcmp(value, "always") == 0)
+                aliasderef = LDAP_DEREF_ALWAYS;
+            else if (strcmp(value, "search") == 0)
+                aliasderef = LDAP_DEREF_SEARCHING;
+            else if (strcmp(value, "find") == 0)
+                aliasderef = LDAP_DEREF_FINDING;
+            else {
+                fprintf(stderr, PROGRAM_NAME " ERROR: Unknown alias dereference method '%s'\n", value);
+                return 1;
+            }
+            break;
+        case 'D':
+            binddn = value;
+            break;
+        case 'w':
+            bindpasswd = value;
+            break;
+        case 'W':
+            readSecret(value);
+            break;
+        case 'P':
+            persistent = !persistent;
+            break;
+        case 'p':
+            port = atoi(value);
+            break;
+        case 'R':
+            noreferrals = !noreferrals;
+            break;
 #ifdef LDAP_VERSION3
-	case 'v':
-	    switch (atoi(value)) {
-	    case 2:
-		version = LDAP_VERSION2;
-		break;
-	    case 3:
-		version = LDAP_VERSION3;
-		break;
-	    default:
-		fprintf(stderr, "Protocol version should be 2 or 3\n");
-		return 1;
-	    }
-	    break;
-	case 'Z':
-	    if (version == LDAP_VERSION2) {
-		fprintf(stderr, "TLS (-Z) is incompatible with version %d\n",
-		    version);
-		return 1;
-	    }
-	    version = LDAP_VERSION3;
-	    use_tls = 1;
-	    break;
+        case 'v':
+            switch (atoi(value)) {
+            case 2:
+                version = LDAP_VERSION2;
+                break;
+            case 3:
+                version = LDAP_VERSION3;
+                break;
+            default:
+                fprintf(stderr, "Protocol version should be 2 or 3\n");
+                return 1;
+            }
+            break;
+        case 'Z':
+            if (version == LDAP_VERSION2) {
+                fprintf(stderr, "TLS (-Z) is incompatible with version %d\n",
+                        version);
+                return 1;
+            }
+            version = LDAP_VERSION3;
+            use_tls = 1;
+            break;
 #endif
-	case 'd':
-	    debug = 1;
-	    break;
-	case 'E':
-	    strip_nt_domain = 1;
-	    break;
-	default:
-	    fprintf(stderr, PROGRAM_NAME " ERROR: Unknown command line option '%c'\n", option);
-	    return 1;
-	}
+        case 'd':
+            debug = 1;
+            break;
+        case 'E':
+            strip_nt_domain = 1;
+            break;
+        default:
+            fprintf(stderr, PROGRAM_NAME " ERROR: Unknown command line option '%c'\n", option);
+            return 1;
+        }
     }
 
     while (argc > 1) {
-	char *value = argv[1];
-	if (ldapServer) {
-	    int len = strlen(ldapServer) + 1 + strlen(value) + 1;
-	    char *newhost = malloc(len);
-	    snprintf(newhost, len, "%s %s", ldapServer, value);
-	    free(ldapServer);
-	    ldapServer = newhost;
-	} else {
-	    ldapServer = strdup(value);
-	}
-	argc--;
-	argv++;
+        char *value = argv[1];
+        if (ldapServer) {
+            int len = strlen(ldapServer) + 1 + strlen(value) + 1;
+            char *newhost = malloc(len);
+            snprintf(newhost, len, "%s %s", ldapServer, value);
+            free(ldapServer);
+            ldapServer = newhost;
+        } else {
+            ldapServer = strdup(value);
+        }
+        argc--;
+        argv++;
     }
 
     if (!ldapServer)
-	ldapServer = (char *) "localhost";
+        ldapServer = (char *) "localhost";
 
     if (!userbasedn || !passattr) {
-	fprintf(stderr, "Usage: " PROGRAM_NAME " -b basedn -f filter [options] ldap_server_name\n\n");
-	fprintf(stderr, "\t-A password attribute(REQUIRED)\t\tUser attribute that contains the password\n");
-	fprintf(stderr, "\t-l password realm delimiter(REQUIRED)\tCharater(s) that devides the password attribute\n\t\t\t\t\t\tin realm and password tokens, default ':' realm:password\n");
-	fprintf(stderr, "\t-b basedn (REQUIRED)\t\t\tbase dn under where to search for users\n");
-	fprintf(stderr, "\t-e Encrypted passwords(REQUIRED)\tPassword are stored encrypted using HHA1\n");
-	fprintf(stderr, "\t-F filter\t\t\t\tuser search filter pattern. %%s = login\n");
-	fprintf(stderr, "\t-u attribute\t\t\t\tattribute to use in combination with the basedn to create the user DN\n");
-	fprintf(stderr, "\t-s base|one|sub\t\t\t\tsearch scope\n");
-	fprintf(stderr, "\t-D binddn\t\t\t\tDN to bind as to perform searches\n");
-	fprintf(stderr, "\t-w bindpasswd\t\t\t\tpassword for binddn\n");
-	fprintf(stderr, "\t-W secretfile\t\t\t\tread password for binddn from file secretfile\n");
+        fprintf(stderr, "Usage: " PROGRAM_NAME " -b basedn -f filter [options] ldap_server_name\n\n");
+        fprintf(stderr, "\t-A password attribute(REQUIRED)\t\tUser attribute that contains the password\n");
+        fprintf(stderr, "\t-l password realm delimiter(REQUIRED)\tCharater(s) that devides the password attribute\n\t\t\t\t\t\tin realm and password tokens, default ':' realm:password\n");
+        fprintf(stderr, "\t-b basedn (REQUIRED)\t\t\tbase dn under where to search for users\n");
+        fprintf(stderr, "\t-e Encrypted passwords(REQUIRED)\tPassword are stored encrypted using HHA1\n");
+        fprintf(stderr, "\t-F filter\t\t\t\tuser search filter pattern. %%s = login\n");
+        fprintf(stderr, "\t-u attribute\t\t\t\tattribute to use in combination with the basedn to create the user DN\n");
+        fprintf(stderr, "\t-s base|one|sub\t\t\t\tsearch scope\n");
+        fprintf(stderr, "\t-D binddn\t\t\t\tDN to bind as to perform searches\n");
+        fprintf(stderr, "\t-w bindpasswd\t\t\t\tpassword for binddn\n");
+        fprintf(stderr, "\t-W secretfile\t\t\t\tread password for binddn from file secretfile\n");
 #if HAS_URI_SUPPORT
-	fprintf(stderr, "\t-H URI\t\t\t\t\tLDAPURI (defaults to ldap://localhost)\n");
+        fprintf(stderr, "\t-H URI\t\t\t\t\tLDAPURI (defaults to ldap://localhost)\n");
 #endif
-	fprintf(stderr, "\t-h server\t\t\t\tLDAP server (defaults to localhost)\n");
-	fprintf(stderr, "\t-p port\t\t\t\t\tLDAP server port (defaults to %d)\n", LDAP_PORT);
-	fprintf(stderr, "\t-P\t\t\t\t\tpersistent LDAP connection\n");
+        fprintf(stderr, "\t-h server\t\t\t\tLDAP server (defaults to localhost)\n");
+        fprintf(stderr, "\t-p port\t\t\t\t\tLDAP server port (defaults to %d)\n", LDAP_PORT);
+        fprintf(stderr, "\t-P\t\t\t\t\tpersistent LDAP connection\n");
 #if defined(NETSCAPE_SSL)
-	fprintf(stderr, "\t-E sslcertpath\t\t\t\tenable LDAP over SSL\n");
+        fprintf(stderr, "\t-E sslcertpath\t\t\t\tenable LDAP over SSL\n");
 #endif
-	fprintf(stderr, "\t-c timeout\t\t\t\tconnect timeout\n");
-	fprintf(stderr, "\t-t timelimit\t\t\t\tsearch time limit\n");
-	fprintf(stderr, "\t-R\t\t\t\t\tdo not follow referrals\n");
-	fprintf(stderr, "\t-a never|always|search|find\t\twhen to dereference aliases\n");
+        fprintf(stderr, "\t-c timeout\t\t\t\tconnect timeout\n");
+        fprintf(stderr, "\t-t timelimit\t\t\t\tsearch time limit\n");
+        fprintf(stderr, "\t-R\t\t\t\t\tdo not follow referrals\n");
+        fprintf(stderr, "\t-a never|always|search|find\t\twhen to dereference aliases\n");
 #ifdef LDAP_VERSION3
-	fprintf(stderr, "\t-v 2|3\t\t\t\t\tLDAP version\n");
-	fprintf(stderr, "\t-Z\t\t\t\t\tTLS encrypt the LDAP connection, requires\n\t\t\t\tLDAP version 3\n");
+        fprintf(stderr, "\t-v 2|3\t\t\t\t\tLDAP version\n");
+        fprintf(stderr, "\t-Z\t\t\t\t\tTLS encrypt the LDAP connection, requires\n\t\t\t\tLDAP version 3\n");
 #endif
-	fprintf(stderr, "\t-S\t\t\t\t\tStrip NT domain from usernames\n");
-	fprintf(stderr, "\n");
-	fprintf(stderr, "\tIf you need to bind as a user to perform searches then use the\n\t-D binddn -w bindpasswd or -D binddn -W secretfile options\n\n");
-	return -1;
+        fprintf(stderr, "\t-S\t\t\t\t\tStrip NT domain from usernames\n");
+        fprintf(stderr, "\n");
+        fprintf(stderr, "\tIf you need to bind as a user to perform searches then use the\n\t-D binddn -w bindpasswd or -D binddn -W secretfile options\n\n");
+        return -1;
     }
     return 0;
 }
@@ -612,23 +612,23 @@ readSecret(const char *filename)
     FILE *f;
 
     if (!(f = fopen(filename, "r"))) {
-	fprintf(stderr, PROGRAM_NAME " ERROR: Can not read secret file %s\n", filename);
-	return 1;
+        fprintf(stderr, PROGRAM_NAME " ERROR: Can not read secret file %s\n", filename);
+        return 1;
     }
     if (!fgets(buf, sizeof(buf) - 1, f)) {
-	fprintf(stderr, PROGRAM_NAME " ERROR: Secret file %s is empty\n", filename);
-	fclose(f);
-	return 1;
+        fprintf(stderr, PROGRAM_NAME " ERROR: Secret file %s is empty\n", filename);
+        fclose(f);
+        return 1;
     }
     /* strip whitespaces on end */
     if ((e = strrchr(buf, '\n')))
-	*e = 0;
+        *e = 0;
     if ((e = strrchr(buf, '\r')))
-	*e = 0;
+        *e = 0;
 
     bindpasswd = strdup(buf);
     if (!bindpasswd) {
-	fprintf(stderr, PROGRAM_NAME " ERROR: can not allocate memory\n");
+        fprintf(stderr, PROGRAM_NAME " ERROR: can not allocate memory\n");
     }
     fclose(f);
 
@@ -642,15 +642,15 @@ LDAPHHA1(RequestData * requestData)
     ldapconnect();
     password = getpassword(requestData->user, requestData->realm);
     if (password != NULL) {
-	if (encrpass)
-	    xstrncpy(requestData->HHA1, password, sizeof(requestData->HHA1));
-	else {
-	    HASH HA1;
-	    DigestCalcHA1("md5", requestData->user, requestData->realm, password, NULL, NULL, HA1, requestData->HHA1);
-	}
-	free(password);
+        if (encrpass)
+            xstrncpy(requestData->HHA1, password, sizeof(requestData->HHA1));
+        else {
+            HASH HA1;
+            DigestCalcHA1("md5", requestData->user, requestData->realm, password, NULL, NULL, HA1, requestData->HHA1);
+        }
+        free(password);
     } else {
-	requestData->error = -1;
+        requestData->error = -1;
     }
 
 }
@@ -47,8 +47,8 @@ typedef struct _request_data {
     int error;
 } RequestData;
 
-/* to use a backend, include your backend.h file 
- * and define thusly: 
+/* to use a backend, include your backend.h file
+ * and define thusly:
  * #define ProcessArguments(A, B) MyHandleArguments(A,B)
  * #define GetHHA1(A) MyGetHHA1(A)
  */
@@ -12,7 +12,7 @@
  * - comment lines are possible and should start with a '#';
  * - empty or blank lines are possible;
  * - file format is username:password
- * 
+ *
  * To build a directory integrated backend, you need to be able to
  * calculate the HA1 returned to squid. To avoid storing a plaintext
  * password you can calculate MD5(username:realm:password) when the
@@ -46,13 +46,13 @@ ParseBuffer(char *buf, RequestData * requestData)
     char *p;
     requestData->parsed = 0;
     if ((p = strchr(buf, '\n')) != NULL)
-	*p = '\0';		/* strip \n */
+        *p = '\0';		/* strip \n */
     if ((requestData->user = strtok(buf, "\"")) == NULL)
-	return;
+        return;
     if ((requestData->realm = strtok(NULL, "\"")) == NULL)
-	return;
+        return;
     if ((requestData->realm = strtok(NULL, "\"")) == NULL)
-	return;
+        return;
     requestData->parsed = -1;
 }
 
@@ -62,8 +62,8 @@ OutputHHA1(RequestData * requestData)
     requestData->error = 0;
     GetHHA1(requestData);
     if (requestData->error) {
-	printf("ERR No such user\n");
-	return;
+        printf("ERR No such user\n");
+        return;
     }
     printf("%s\n", requestData->HHA1);
 }
@@ -74,8 +74,8 @@ DoOneRequest(char *buf)
     RequestData requestData;
     ParseBuffer(buf, &requestData);
     if (!requestData.parsed) {
-	printf("ERR\n");
-	return;
+        printf("ERR\n");
+        return;
     }
     OutputHHA1(&requestData);
 }
@@ -93,6 +93,6 @@ main(int argc, char **argv)
     setbuf(stdout, NULL);
     ProcessArguments(argc, argv);
     while (fgets(buf, 256, stdin) != NULL)
-	DoOneRequest(buf);
+        DoOneRequest(buf);
     exit(0);
 }
@@ -11,7 +11,7 @@
  * - comment lines are possible and should start with a '#';
  * - empty or blank lines are possible;
  * - file format is username:plaintext or username:realm:HA1
- * 
+ *
  * To build a directory integrated backend, you need to be able to
  * calculate the HA1 returned to squid. To avoid storing a plaintext
  * password you can calculate MD5(username:realm:password) when the
@@ -64,55 +64,55 @@ read_passwd_file(const char *passwdfile, int ha1mode)
     char *realm;
 
     if (hash != NULL) {
-	hashFreeItems(hash, my_free);
+        hashFreeItems(hash, my_free);
     }
     /* initial setup */
     hash = hash_create((HASHCMP *) strcmp, 7921, hash_string);
     if (NULL == hash) {
-	fprintf(stderr, "digest_pw_auth: cannot create hash table\n");
-	exit(1);
+        fprintf(stderr, "digest_pw_auth: cannot create hash table\n");
+        exit(1);
     }
     f = fopen(passwdfile, "r");
     while (fgets(buf, 8192, f) != NULL) {
-	if ((buf[0] == '#') || (buf[0] == ' ') || (buf[0] == '\t') ||
-	    (buf[0] == '\n'))
-	    continue;
-	user = strtok(buf, ":\n");
-	realm = strtok(NULL, ":\n");
-	passwd = strtok(NULL, ":\n");
-	if (!passwd) {
-	    passwd = realm;
-	    realm = NULL;
-	}
-	if ((strlen(user) > 0) && passwd) {
-	    if (strncmp(passwd, "{HHA1}", 6) == 0) {
-		ha1 = passwd + 6;
-		passwd = NULL;
-	    } else if (ha1mode) {
-		ha1 = passwd;
-		passwd = NULL;
-	    }
-	    if (ha1 && strlen(ha1) != 32) {
-		/* We cannot accept plaintext passwords when using HA1 encoding,
-		 * as the passwords may be output to cache.log if debugging is on.
-		 */
-		fprintf(stderr, "digest_pw_auth: ignoring invalid password for %s\n", user);
-		continue;
-	    }
-	    u = xcalloc(1, sizeof(*u));
-	    if (realm) {
-		int len = strlen(user) + strlen(realm) + 2;
-		u->hash.key = malloc(len);
-		snprintf(u->hash.key, len, "%s:%s", user, realm);
-	    } else {
-		u->hash.key = xstrdup(user);
-	    }
-	    if (ha1)
-		u->ha1 = xstrdup(ha1);
-	    else
-		u->passwd = xstrdup(passwd);
-	    hash_join(hash, &u->hash);
-	}
+        if ((buf[0] == '#') || (buf[0] == ' ') || (buf[0] == '\t') ||
+                (buf[0] == '\n'))
+            continue;
+        user = strtok(buf, ":\n");
+        realm = strtok(NULL, ":\n");
+        passwd = strtok(NULL, ":\n");
+        if (!passwd) {
+            passwd = realm;
+            realm = NULL;
+        }
+        if ((strlen(user) > 0) && passwd) {
+            if (strncmp(passwd, "{HHA1}", 6) == 0) {
+                ha1 = passwd + 6;
+                passwd = NULL;
+            } else if (ha1mode) {
+                ha1 = passwd;
+                passwd = NULL;
+            }
+            if (ha1 && strlen(ha1) != 32) {
+                /* We cannot accept plaintext passwords when using HA1 encoding,
+                 * as the passwords may be output to cache.log if debugging is on.
+                 */
+                fprintf(stderr, "digest_pw_auth: ignoring invalid password for %s\n", user);
+                continue;
+            }
+            u = xcalloc(1, sizeof(*u));
+            if (realm) {
+                int len = strlen(user) + strlen(realm) + 2;
+                u->hash.key = malloc(len);
+                snprintf(u->hash.key, len, "%s:%s", user, realm);
+            } else {
+                u->hash.key = xstrdup(user);
+            }
+            if (ha1)
+                u->ha1 = xstrdup(ha1);
+            else
+                u->passwd = xstrdup(passwd);
+            hash_join(hash, &u->hash);
+        }
     }
     fclose(f);
 }
@@ -123,19 +123,19 @@ TextArguments(int argc, char **argv)
 {
     struct stat sb;
     if (argc == 2)
-	passwdfile = argv[1];
+        passwdfile = argv[1];
     if ((argc == 3) && !strcmp("-c", argv[1])) {
-	ha1mode = 1;
-	passwdfile = argv[2];
+        ha1mode = 1;
+        passwdfile = argv[2];
     }
     if (!passwdfile) {
-	fprintf(stderr, "Usage: digest_pw_auth [OPTIONS] <passwordfile>\n");
-	fprintf(stderr, "  -c   accept digest hashed passwords rather than plaintext in passwordfile\n");
-	exit(1);
+        fprintf(stderr, "Usage: digest_pw_auth [OPTIONS] <passwordfile>\n");
+        fprintf(stderr, "  -c   accept digest hashed passwords rather than plaintext in passwordfile\n");
+        exit(1);
     }
     if (stat(passwdfile, &sb) != 0) {
-	fprintf(stderr, "cannot stat %s\n", passwdfile);
-	exit(1);
+        fprintf(stderr, "cannot stat %s\n", passwdfile);
+        exit(1);
     }
 }
 
@@ -147,19 +147,19 @@ GetPassword(RequestData * requestData)
     char buf[256];
     int len;
     if (stat(passwdfile, &sb) == 0) {
-	if (sb.st_mtime != change_time) {
-	    read_passwd_file(passwdfile, ha1mode);
-	    change_time = sb.st_mtime;
-	}
+        if (sb.st_mtime != change_time) {
+            read_passwd_file(passwdfile, ha1mode);
+            change_time = sb.st_mtime;
+        }
     }
     if (!hash)
-	return NULL;
+        return NULL;
     len = snprintf(buf, sizeof(buf), "%s:%s", requestData->user, requestData->realm);
     if (len >= sizeof(buf))
-	return NULL;
+        return NULL;
     u = (user_data *) hash_lookup(hash, buf);
     if (u)
-	return u;
+        return u;
     u = (user_data *) hash_lookup(hash, requestData->user);
     return u;
 }
@@ -169,13 +169,13 @@ TextHHA1(RequestData * requestData)
 {
     const user_data *u = GetPassword(requestData);
     if (!u) {
-	requestData->error = -1;
-	return;
+        requestData->error = -1;
+        return;
     }
     if (u->ha1) {
-	xstrncpy(requestData->HHA1, u->ha1, sizeof(requestData->HHA1));
+        xstrncpy(requestData->HHA1, u->ha1, sizeof(requestData->HHA1));
     } else {
-	HASH HA1;
-	DigestCalcHA1("md5", requestData->user, requestData->realm, u->passwd, NULL, NULL, HA1, requestData->HHA1);
+        HASH HA1;
+        DigestCalcHA1("md5", requestData->user, requestData->realm, u->passwd, NULL, NULL, HA1, requestData->HHA1);
     }
 }
@@ -8,7 +8,7 @@
  * - comment lines are possible and should start with a '#';
  * - empty or blank lines are possible;
  * - file format is username:password
- * 
+ *
  * This implementation could be improved by using such a triple for
  * the file format.  However storing such a triple does little to
  * improve security: If compromised the username:realm:HA1 combination
@@ -1,24 +1,24 @@
-/* $Id: dict.c,v 1.2 2003/01/23 00:36:01 robertc Exp $ 
+/* $Id: dict.c,v 1.2 2003/01/23 00:36:01 robertc Exp $
 * Copyright (C) 2002 Rodrigo Campos
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
-* 
+*
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
-* 
+*
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * Author: Rodrigo Campos (rodrigo@geekbunker.org)
-* 
+*
 */
-			  
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -34,74 +34,73 @@
 #endif
 
 
-/* This function parses the dictionary file and loads it 
+/* This function parses the dictionary file and loads it
  * in memory. All IP addresses are processed with a bitwise AND
  * with their netmasks before they are stored.
  * If theres no netmask (no /) in the in the lhs , a mask
  * 255.255.255.255 is assumed.
  * It returns a pointer to the first entry of the linked list
  */
 struct ip_user_dict *
-load_dict (FILE * FH)
-{
-  struct ip_user_dict *current_entry;	/* the structure used to
+            load_dict (FILE * FH) {
+    struct ip_user_dict *current_entry;	/* the structure used to
 					   store data */
-  struct ip_user_dict *first_entry = NULL;	/* the head of the
+    struct ip_user_dict *first_entry = NULL;	/* the head of the
 						   linked list */
-  char line[BUFSIZE];		/* the buffer for the lines read
+    char line[BUFSIZE];		/* the buffer for the lines read
 				   from the dict file */
-  char *cp;			/* a char pointer used to parse
+    char *cp;			/* a char pointer used to parse
 				   each line */
-  char *username;		/* for the username */
-  char *tmpbuf;			/* for the address before the
+    char *username;		/* for the username */
+    char *tmpbuf;			/* for the address before the
 				   bitwise AND */
 
-  /* the pointer to the first entry in the linked list */
-  first_entry = malloc (sizeof (struct ip_user_dict));
-  current_entry = first_entry;
+    /* the pointer to the first entry in the linked list */
+    first_entry = malloc (sizeof (struct ip_user_dict));
+    current_entry = first_entry;
 
-  while ((cp = fgets (line, sizeof (line), FH)) != NULL) {
-		  if (line[0] == '#') {
-				  continue;
-		  }
-    if ((cp = strchr (line, '\n')) != NULL) {
-      /* chop \n characters */
-      *cp = '\0';
-    }
-    if ((cp = strtok (line, "\t ")) != NULL) {
-      /* get the username */
-      username = strtok (NULL, "\t ");
-      /* look for a netmask */
-      if ((cp = strtok (line, "/")) != NULL) {
-	/* store the ip address in a temporary buffer */
-	tmpbuf = cp;
-	cp = strtok (NULL, "/");
-	if (cp != NULL) {
-	  /* if we have a slash in the lhs, we have a netmask */
-	  current_entry->netmask = (inet_addr (cp));
-	  current_entry->address =
-	    (((inet_addr (tmpbuf))) & current_entry->netmask);
-	} else {
-	  /* when theres no slash, we figure the netmask is /32 */
-	  current_entry->address = (inet_addr (tmpbuf));
-	  current_entry->netmask = (inet_addr ("255.255.255.255"));
-	}
-      }
-      /* get space for the username */
-      current_entry->username =
-	calloc (strlen (username) + 1, sizeof (char));
-      strcpy (current_entry->username, username);
+    while ((cp = fgets (line, sizeof (line), FH)) != NULL) {
+        if (line[0] == '#') {
+            continue;
+        }
+        if ((cp = strchr (line, '\n')) != NULL) {
+            /* chop \n characters */
+            *cp = '\0';
+        }
+        if ((cp = strtok (line, "\t ")) != NULL) {
+            /* get the username */
+            username = strtok (NULL, "\t ");
+            /* look for a netmask */
+            if ((cp = strtok (line, "/")) != NULL) {
+                /* store the ip address in a temporary buffer */
+                tmpbuf = cp;
+                cp = strtok (NULL, "/");
+                if (cp != NULL) {
+                    /* if we have a slash in the lhs, we have a netmask */
+                    current_entry->netmask = (inet_addr (cp));
+                    current_entry->address =
+                        (((inet_addr (tmpbuf))) & current_entry->netmask);
+                } else {
+                    /* when theres no slash, we figure the netmask is /32 */
+                    current_entry->address = (inet_addr (tmpbuf));
+                    current_entry->netmask = (inet_addr ("255.255.255.255"));
+                }
+            }
+            /* get space for the username */
+            current_entry->username =
+                calloc (strlen (username) + 1, sizeof (char));
+            strcpy (current_entry->username, username);
 
-      /* get space and point current_entry to the new entry */
-      current_entry->next_entry =
-	malloc (sizeof (struct ip_user_dict));
-      current_entry = current_entry->next_entry;
-    }
+            /* get space and point current_entry to the new entry */
+            current_entry->next_entry =
+                malloc (sizeof (struct ip_user_dict));
+            current_entry = current_entry->next_entry;
+        }
 
-  }
+    }
 
-  /* Return a pointer to the first entry linked list */
-  return first_entry;
+    /* Return a pointer to the first entry linked list */
+    return first_entry;
 }				/* load_dict */
 
 /* This function looks for a matching ip/mask in
@@ -110,33 +109,33 @@ load_dict (FILE * FH)
  */
 int
 dict_lookup (struct ip_user_dict *first_entry, char *username,
-	     char *address)
+             char *address)
 {
-  /* Move the pointer to the first entry of the linked list. */
-  struct ip_user_dict *current_entry = first_entry;
+    /* Move the pointer to the first entry of the linked list. */
+    struct ip_user_dict *current_entry = first_entry;
 
-  while (current_entry->username != NULL) {
+    while (current_entry->username != NULL) {
 #ifdef DEBUG
-    printf ("user: %s\naddr: %lu\nmask: %lu\n\n",
-	    current_entry->username, current_entry->address,
-	    current_entry->netmask);
+        printf ("user: %s\naddr: %lu\nmask: %lu\n\n",
+                current_entry->username, current_entry->address,
+                current_entry->netmask);
 #endif
 
-    if ((inet_addr (address) & (unsigned long) current_entry->
-	 netmask) == current_entry->address) {
-      /* If the username contains an @ we assume its a group and
-         call the corresponding function */
-      if ((strchr (current_entry->username, '@')) == NULL) {
-	if ((match_user (current_entry->username, username)) == 1)
-	  return 1;
-      } else {
-	if ((match_group (current_entry->username, username)) == 1)
-	  return 1;
-      }
+        if ((inet_addr (address) & (unsigned long) current_entry->
+                netmask) == current_entry->address) {
+            /* If the username contains an @ we assume its a group and
+               call the corresponding function */
+            if ((strchr (current_entry->username, '@')) == NULL) {
+                if ((match_user (current_entry->username, username)) == 1)
+                    return 1;
+            } else {
+                if ((match_group (current_entry->username, username)) == 1)
+                    return 1;
+            }
+        }
+        current_entry = current_entry->next_entry;
     }
-    current_entry = current_entry->next_entry;
-  }
 
-  /* If no match was found we return 0 */
-  return 0;
+    /* If no match was found we return 0 */
+    return 0;
 }				/* dict_lookup */
@@ -5,29 +5,28 @@
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
-* 
+*
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
-* 
+*
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * Author: Rodrigo Campos (rodrigo@geekbunker.org)
-* 
+*
 */
 
 
 
 
-struct ip_user_dict
-{
-  unsigned long address;
-  unsigned long netmask;
-  char *username;
-  struct ip_user_dict *next_entry;
+struct ip_user_dict {
+    unsigned long address;
+    unsigned long netmask;
+    char *username;
+    struct ip_user_dict *next_entry;
 };
 
 extern int match_user(char *, char *);
@@ -1,22 +1,22 @@
-/* $Id: main.c,v 1.6 2007/07/19 03:36:12 hno Exp $ 
+/* $Id: main.c,v 1.6 2007/07/19 03:36:12 hno Exp $
 * Copyright (C) 2002 Rodrigo Campos
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
-* 
+*
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
-* 
+*
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * Author: Rodrigo Campos (rodrigo@geekbunker.org)
-* 
+*
 */
 
 #include "util.h"
@@ -31,73 +31,73 @@
 static void
 usage (char *program_name)
 {
-  fprintf (stderr, "Usage:\n%s -f <configuration file>\n",
-	   program_name);
+    fprintf (stderr, "Usage:\n%s -f <configuration file>\n",
+             program_name);
 }
 
 int
 main (int argc, char *argv[])
 {
-  FILE *FH;
-  char *filename = NULL;
-  char *program_name = argv[0];
-  char *cp;
-  char *username, *address;
-  char line[BUFSIZE];
-  struct ip_user_dict *current_entry;
-  int ch;
+    FILE *FH;
+    char *filename = NULL;
+    char *program_name = argv[0];
+    char *cp;
+    char *username, *address;
+    char line[BUFSIZE];
+    struct ip_user_dict *current_entry;
+    int ch;
 
-  setvbuf (stdout, NULL, _IOLBF, 0);
-  while ((ch = getopt (argc, argv, "f:")) != -1) {
-    switch (ch) {
-    case 'f':
-      filename = optarg;
-      break;
-    default:
-      usage (program_name);
-      exit (1);
+    setvbuf (stdout, NULL, _IOLBF, 0);
+    while ((ch = getopt (argc, argv, "f:")) != -1) {
+        switch (ch) {
+        case 'f':
+            filename = optarg;
+            break;
+        default:
+            usage (program_name);
+            exit (1);
+        }
     }
-  }
-  if (filename == NULL) {	
-    usage (program_name);
-	exit(1);
-  }
-  FH = fopen (filename, "r");
-  current_entry = load_dict (FH);
-
-  while (fgets (line, sizeof (line), stdin)) {
-    if ((cp = strchr (line, '\n')) == NULL) {
-	/* too large message received.. skip and deny */
-	fprintf(stderr, "%s: ERROR: Too large: %s\n", argv[0], line);
-	while (fgets(line, sizeof(line), stdin)) {
-	    fprintf(stderr, "%s: ERROR: Too large..: %s\n", argv[0], line);
-	    if (strchr(line, '\n') != NULL)
-		break;
-	}
-	goto error;
-    }
-    *cp = '\0';
-    address = strtok (line, " \t");
-    username = strtok (NULL, " \t");
-    if (!address || !username) {
-      fprintf (stderr, "%s: unable to read tokens\n", argv[0]);
-      goto error;
+    if (filename == NULL) {
+        usage (program_name);
+        exit(1);
     }
-    rfc1738_unescape(address);
-    rfc1738_unescape(username);
+    FH = fopen (filename, "r");
+    current_entry = load_dict (FH);
+
+    while (fgets (line, sizeof (line), stdin)) {
+        if ((cp = strchr (line, '\n')) == NULL) {
+            /* too large message received.. skip and deny */
+            fprintf(stderr, "%s: ERROR: Too large: %s\n", argv[0], line);
+            while (fgets(line, sizeof(line), stdin)) {
+                fprintf(stderr, "%s: ERROR: Too large..: %s\n", argv[0], line);
+                if (strchr(line, '\n') != NULL)
+                    break;
+            }
+            goto error;
+        }
+        *cp = '\0';
+        address = strtok (line, " \t");
+        username = strtok (NULL, " \t");
+        if (!address || !username) {
+            fprintf (stderr, "%s: unable to read tokens\n", argv[0]);
+            goto error;
+        }
+        rfc1738_unescape(address);
+        rfc1738_unescape(username);
 #ifdef DEBUG
-    printf ("result: %d\n",
-	    dict_lookup (current_entry, username, address));
+        printf ("result: %d\n",
+                dict_lookup (current_entry, username, address));
 #endif
-    if ((dict_lookup (current_entry, username, address)) != 0) {
-      printf ("OK\n");
-    } else {
+        if ((dict_lookup (current_entry, username, address)) != 0) {
+            printf ("OK\n");
+        } else {
 error:
-      printf ("ERR\n");
+            printf ("ERR\n");
+        }
     }
-  }
 
 
-  fclose (FH);
-  return 0;
+    fclose (FH);
+    return 0;
 }
@@ -1,22 +1,22 @@
-/* $Id: match.c,v 1.3 2007/07/19 03:36:12 hno Exp $ 
+/* $Id: match.c,v 1.3 2007/07/19 03:36:12 hno Exp $
 * Copyright (C) 2002 Rodrigo Campos
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
-* 
+*
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
-* 
+*
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 * Author: Rodrigo Campos (rodrigo@geekbunker.org)
-* 
+*
 */
 #include <stdio.h>
 #include <string.h>
@@ -28,35 +28,35 @@
 int
 match_user (char *dict_username, char *username)
 {
-  if ((strcmp (dict_username, username)) == 0) {
-    return 1;
-  } else {
-    if ((strcmp (dict_username, "ALL")) == 0) {
-      return 1;
+    if ((strcmp (dict_username, username)) == 0) {
+        return 1;
+    } else {
+        if ((strcmp (dict_username, "ALL")) == 0) {
+            return 1;
+        }
     }
-  }
-  return 0;
+    return 0;
 }				/* match_user */
 
 int
 match_group (char *dict_group, char *username)
 {
-  struct group *g;		/* a struct to hold group entries */
-  dict_group++;			/* the @ should be the first char
-				   so we rip it off by incrementing 
+    struct group *g;		/* a struct to hold group entries */
+    dict_group++;			/* the @ should be the first char
+				   so we rip it off by incrementing
 				   * the pointer by one */
 
-  if ((g = getgrnam (dict_group)) == NULL) {
-    fprintf (stderr, "helper: Group does not exist '%s'\n",
-	     dict_group);
-    return 0;
-  } else {
-    while (*(g->gr_mem) != NULL) {
-      if (strcmp (*((g->gr_mem)++), username) == 0) {
-	return 1;
-      }
+    if ((g = getgrnam (dict_group)) == NULL) {
+        fprintf (stderr, "helper: Group does not exist '%s'\n",
+                 dict_group);
+        return 0;
+    } else {
+        while (*(g->gr_mem) != NULL) {
+            if (strcmp (*((g->gr_mem)++), username) == 0) {
+                return 1;
+            }
+        }
     }
-  }
-  return 0;
+    return 0;
 
 }				/* match_group */
@@ -7,7 +7,7 @@
  * and/or modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2,
  * or (at your option) any later version.
- * 
+ *
  * Authors:
  *  Flavio Pescuma <flavio@marasystems.com>
  *  Henrik Nordstrom <hno@marasystems.com>
@@ -19,17 +19,17 @@
  *
  * Latest version of this program can always be found from MARA Systems
  * at http://marasystems.com/download/LDAP_Group/
- * 
+ *
  * Dependencies: You need to get the OpenLDAP libraries
  * from http://www.openldap.org or use another compatible
  * LDAP C-API library.
  *
  * If you want to make a TLS enabled connection you will also need the
  * OpenSSL libraries linked into openldap. See http://www.openssl.org/
- * 
- * License: squid_ldap_group is free software; you can redistribute it 
- * and/or modify it under the terms of the GNU General Public License 
- * as published by the Free Software Foundation; either version 2, 
+ *
+ * License: squid_ldap_group is free software; you can redistribute it
+ * and/or modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2,
  * or (at your option) any later version.
  */
 
@@ -136,7 +136,7 @@ squid_ldap_set_aliasderef(LDAP * ld, int deref)
 static void
 squid_ldap_set_referrals(LDAP * ld, int referrals)
 {
-    int *value = referrals ? LDAP_OPT_ON : LDAP_OPT_OFF;
+    int *value = referrals ? LDAP_OPT_ON :LDAP_OPT_OFF;
     ldap_set_option(ld, LDAP_OPT_REFERRALS, value);
 }
 static void
@@ -178,9 +178,9 @@ static void
 squid_ldap_set_referrals(LDAP * ld, int referrals)
 {
     if (referrals)
-	ld->ld_options |= ~LDAP_OPT_REFERRALS;
+        ld->ld_options |= ~LDAP_OPT_REFERRALS;
     else
-	ld->ld_options &= ~LDAP_OPT_REFERRALS;
+        ld->ld_options &= ~LDAP_OPT_REFERRALS;
 }
 static void
 squid_ldap_set_timelimit(LDAP * ld, int timelimit)
@@ -223,384 +223,384 @@ main(int argc, char **argv)
     setbuf(stdout, NULL);
 
     while (argc > 1 && argv[1][0] == '-') {
-	const char *value = "";
-	char option = argv[1][1];
-	switch (option) {
-	case 'P':
-	case 'R':
-	case 'z':
-	case 'Z':
-	case 'd':
-	case 'g':
-	case 'S':
-	    break;
-	default:
-	    if (strlen(argv[1]) > 2) {
-		value = argv[1] + 2;
-	    } else if (argc > 2) {
-		value = argv[2];
-		argv++;
-		argc--;
-	    } else
-		value = "";
-	    break;
-	}
-	argv++;
-	argc--;
-	switch (option) {
-	case 'H':
+        const char *value = "";
+        char option = argv[1][1];
+        switch (option) {
+        case 'P':
+        case 'R':
+        case 'z':
+        case 'Z':
+        case 'd':
+        case 'g':
+        case 'S':
+            break;
+        default:
+            if (strlen(argv[1]) > 2) {
+                value = argv[1] + 2;
+            } else if (argc > 2) {
+                value = argv[2];
+                argv++;
+                argc--;
+            } else
+                value = "";
+            break;
+        }
+        argv++;
+        argc--;
+        switch (option) {
+        case 'H':
 #if !HAS_URI_SUPPORT
-	    fprintf(stderr, "ERROR: Your LDAP library does not have URI support\n");
-	    exit(1);
+            fprintf(stderr, "ERROR: Your LDAP library does not have URI support\n");
+            exit(1);
 #endif
-	    /* Fall thru to -h */
-	case 'h':
-	    if (ldapServer) {
-		int len = strlen(ldapServer) + 1 + strlen(value) + 1;
-		char *newhost = malloc(len);
-		snprintf(newhost, len, "%s %s", ldapServer, value);
-		free(ldapServer);
-		ldapServer = newhost;
-	    } else {
-		ldapServer = strdup(value);
-	    }
-	    break;
-	case 'b':
-	    basedn = value;
-	    break;
-	case 'f':
-	    searchfilter = value;
-	    break;
-	case 'B':
-	    userbasedn = value;
-	    break;
-	case 'F':
-	    usersearchfilter = value;
-	    break;
-	case 'u':
-	    userdnattr = value;
-	    break;
-	case 's':
-	    if (strcmp(value, "base") == 0)
-		searchscope = LDAP_SCOPE_BASE;
-	    else if (strcmp(value, "one") == 0)
-		searchscope = LDAP_SCOPE_ONELEVEL;
-	    else if (strcmp(value, "sub") == 0)
-		searchscope = LDAP_SCOPE_SUBTREE;
-	    else {
-		fprintf(stderr, PROGRAM_NAME " ERROR: Unknown search scope '%s'\n", value);
-		exit(1);
-	    }
-	    break;
-	case 'E':
+            /* Fall thru to -h */
+        case 'h':
+            if (ldapServer) {
+                int len = strlen(ldapServer) + 1 + strlen(value) + 1;
+                char *newhost = malloc(len);
+                snprintf(newhost, len, "%s %s", ldapServer, value);
+                free(ldapServer);
+                ldapServer = newhost;
+            } else {
+                ldapServer = strdup(value);
+            }
+            break;
+        case 'b':
+            basedn = value;
+            break;
+        case 'f':
+            searchfilter = value;
+            break;
+        case 'B':
+            userbasedn = value;
+            break;
+        case 'F':
+            usersearchfilter = value;
+            break;
+        case 'u':
+            userdnattr = value;
+            break;
+        case 's':
+            if (strcmp(value, "base") == 0)
+                searchscope = LDAP_SCOPE_BASE;
+            else if (strcmp(value, "one") == 0)
+                searchscope = LDAP_SCOPE_ONELEVEL;
+            else if (strcmp(value, "sub") == 0)
+                searchscope = LDAP_SCOPE_SUBTREE;
+            else {
+                fprintf(stderr, PROGRAM_NAME " ERROR: Unknown search scope '%s'\n", value);
+                exit(1);
+            }
+            break;
+        case 'E':
 #if defined(NETSCAPE_SSL)
-	    sslpath = value;
-	    if (port == LDAP_PORT)
-		port = LDAPS_PORT;
+            sslpath = value;
+            if (port == LDAP_PORT)
+                port = LDAPS_PORT;
 #else
-	    fprintf(stderr, PROGRAM_NAME " ERROR: -E unsupported with this LDAP library\n");
-	    exit(1);
+            fprintf(stderr, PROGRAM_NAME " ERROR: -E unsupported with this LDAP library\n");
+            exit(1);
 #endif
-	    break;
-	case 'c':
-	    connect_timeout = atoi(value);
-	    break;
-	case 't':
-	    timelimit = atoi(value);
-	    break;
-	case 'a':
-	    if (strcmp(value, "never") == 0)
-		aliasderef = LDAP_DEREF_NEVER;
-	    else if (strcmp(value, "always") == 0)
-		aliasderef = LDAP_DEREF_ALWAYS;
-	    else if (strcmp(value, "search") == 0)
-		aliasderef = LDAP_DEREF_SEARCHING;
-	    else if (strcmp(value, "find") == 0)
-		aliasderef = LDAP_DEREF_FINDING;
-	    else {
-		fprintf(stderr, PROGRAM_NAME " ERROR: Unknown alias dereference method '%s'\n", value);
-		exit(1);
-	    }
-	    break;
-	case 'D':
-	    binddn = value;
-	    break;
-	case 'w':
-	    bindpasswd = value;
-	    break;
-	case 'W':
-	    readSecret(value);
-	    break;
-	case 'P':
-	    persistent = !persistent;
-	    break;
-	case 'p':
-	    port = atoi(value);
-	    break;
-	case 'R':
-	    noreferrals = !noreferrals;
-	    break;
+            break;
+        case 'c':
+            connect_timeout = atoi(value);
+            break;
+        case 't':
+            timelimit = atoi(value);
+            break;
+        case 'a':
+            if (strcmp(value, "never") == 0)
+                aliasderef = LDAP_DEREF_NEVER;
+            else if (strcmp(value, "always") == 0)
+                aliasderef = LDAP_DEREF_ALWAYS;
+            else if (strcmp(value, "search") == 0)
+                aliasderef = LDAP_DEREF_SEARCHING;
+            else if (strcmp(value, "find") == 0)
+                aliasderef = LDAP_DEREF_FINDING;
+            else {
+                fprintf(stderr, PROGRAM_NAME " ERROR: Unknown alias dereference method '%s'\n", value);
+                exit(1);
+            }
+            break;
+        case 'D':
+            binddn = value;
+            break;
+        case 'w':
+            bindpasswd = value;
+            break;
+        case 'W':
+            readSecret(value);
+            break;
+        case 'P':
+            persistent = !persistent;
+            break;
+        case 'p':
+            port = atoi(value);
+            break;
+        case 'R':
+            noreferrals = !noreferrals;
+            break;
 #ifdef LDAP_VERSION3
-	case 'v':
-	    switch (atoi(value)) {
-	    case 2:
-		version = LDAP_VERSION2;
-		break;
-	    case 3:
-		version = LDAP_VERSION3;
-		break;
-	    default:
-		fprintf(stderr, "Protocol version should be 2 or 3\n");
-		exit(1);
-	    }
-	    break;
-	case 'Z':
-	    if (version == LDAP_VERSION2) {
-		fprintf(stderr, "TLS (-Z) is incompatible with version %d\n",
-		    version);
-		exit(1);
-	    }
-	    version = LDAP_VERSION3;
-	    use_tls = 1;
-	    break;
+        case 'v':
+            switch (atoi(value)) {
+            case 2:
+                version = LDAP_VERSION2;
+                break;
+            case 3:
+                version = LDAP_VERSION3;
+                break;
+            default:
+                fprintf(stderr, "Protocol version should be 2 or 3\n");
+                exit(1);
+            }
+            break;
+        case 'Z':
+            if (version == LDAP_VERSION2) {
+                fprintf(stderr, "TLS (-Z) is incompatible with version %d\n",
+                        version);
+                exit(1);
+            }
+            version = LDAP_VERSION3;
+            use_tls = 1;
+            break;
 #endif
-	case 'd':
-	    debug = 1;
-	    break;
-	case 'g':
-	    use_extension_dn = 1;
-	    break;
-	case 'S':
-	    strip_nt_domain = 1;
-	    break;
-	case 'K':
-	    strip_kerberos_realm = 1;
-	    break;
-	default:
-	    fprintf(stderr, PROGRAM_NAME " ERROR: Unknown command line option '%c'\n", option);
-	    exit(1);
-	}
+        case 'd':
+            debug = 1;
+            break;
+        case 'g':
+            use_extension_dn = 1;
+            break;
+        case 'S':
+            strip_nt_domain = 1;
+            break;
+        case 'K':
+            strip_kerberos_realm = 1;
+            break;
+        default:
+            fprintf(stderr, PROGRAM_NAME " ERROR: Unknown command line option '%c'\n", option);
+            exit(1);
+        }
     }
 
     while (argc > 1) {
-	char *value = argv[1];
-	if (ldapServer) {
-	    int len = strlen(ldapServer) + 1 + strlen(value) + 1;
-	    char *newhost = malloc(len);
-	    snprintf(newhost, len, "%s %s", ldapServer, value);
-	    free(ldapServer);
-	    ldapServer = newhost;
-	} else {
-	    ldapServer = strdup(value);
-	}
-	argc--;
-	argv++;
+        char *value = argv[1];
+        if (ldapServer) {
+            int len = strlen(ldapServer) + 1 + strlen(value) + 1;
+            char *newhost = malloc(len);
+            snprintf(newhost, len, "%s %s", ldapServer, value);
+            free(ldapServer);
+            ldapServer = newhost;
+        } else {
+            ldapServer = strdup(value);
+        }
+        argc--;
+        argv++;
     }
 
     if (!ldapServer)
-	ldapServer = (char *) "localhost";
+        ldapServer = (char *) "localhost";
 
     if (!basedn || !searchfilter) {
-	fprintf(stderr, "\n" PROGRAM_NAME " version " PROGRAM_VERSION "\n\n");
-	fprintf(stderr, "Usage: " PROGRAM_NAME " -b basedn -f filter [options] ldap_server_name\n\n");
-	fprintf(stderr, "\t-b basedn (REQUIRED)\tbase dn under where to search for groups\n");
-	fprintf(stderr, "\t-f filter (REQUIRED)\tgroup search filter pattern. %%u = user,\n\t\t\t\t%%v = group\n");
-	fprintf(stderr, "\t-B basedn (REQUIRED)\tbase dn under where to search for users\n");
-	fprintf(stderr, "\t-F filter (REQUIRED)\tuser search filter pattern. %%s = login\n");
-	fprintf(stderr, "\t-s base|one|sub\t\tsearch scope\n");
-	fprintf(stderr, "\t-D binddn\t\tDN to bind as to perform searches\n");
-	fprintf(stderr, "\t-w bindpasswd\t\tpassword for binddn\n");
-	fprintf(stderr, "\t-W secretfile\t\tread password for binddn from file secretfile\n");
+        fprintf(stderr, "\n" PROGRAM_NAME " version " PROGRAM_VERSION "\n\n");
+        fprintf(stderr, "Usage: " PROGRAM_NAME " -b basedn -f filter [options] ldap_server_name\n\n");
+        fprintf(stderr, "\t-b basedn (REQUIRED)\tbase dn under where to search for groups\n");
+        fprintf(stderr, "\t-f filter (REQUIRED)\tgroup search filter pattern. %%u = user,\n\t\t\t\t%%v = group\n");
+        fprintf(stderr, "\t-B basedn (REQUIRED)\tbase dn under where to search for users\n");
+        fprintf(stderr, "\t-F filter (REQUIRED)\tuser search filter pattern. %%s = login\n");
+        fprintf(stderr, "\t-s base|one|sub\t\tsearch scope\n");
+        fprintf(stderr, "\t-D binddn\t\tDN to bind as to perform searches\n");
+        fprintf(stderr, "\t-w bindpasswd\t\tpassword for binddn\n");
+        fprintf(stderr, "\t-W secretfile\t\tread password for binddn from file secretfile\n");
 #if HAS_URI_SUPPORT
-	fprintf(stderr, "\t-H URI\t\t\tLDAPURI (defaults to ldap://localhost)\n");
+        fprintf(stderr, "\t-H URI\t\t\tLDAPURI (defaults to ldap://localhost)\n");
 #endif
-	fprintf(stderr, "\t-h server\t\tLDAP server (defaults to localhost)\n");
-	fprintf(stderr, "\t-p port\t\t\tLDAP server port (defaults to %d)\n", LDAP_PORT);
-	fprintf(stderr, "\t-P\t\t\tpersistent LDAP connection\n");
+        fprintf(stderr, "\t-h server\t\tLDAP server (defaults to localhost)\n");
+        fprintf(stderr, "\t-p port\t\t\tLDAP server port (defaults to %d)\n", LDAP_PORT);
+        fprintf(stderr, "\t-P\t\t\tpersistent LDAP connection\n");
 #if defined(NETSCAPE_SSL)
-	fprintf(stderr, "\t-E sslcertpath\t\tenable LDAP over SSL\n");
+        fprintf(stderr, "\t-E sslcertpath\t\tenable LDAP over SSL\n");
 #endif
-	fprintf(stderr, "\t-c timeout\t\tconnect timeout\n");
-	fprintf(stderr, "\t-t timelimit\t\tsearch time limit\n");
-	fprintf(stderr, "\t-R\t\t\tdo not follow referrals\n");
-	fprintf(stderr, "\t-a never|always|search|find\n\t\t\t\twhen to dereference aliases\n");
+        fprintf(stderr, "\t-c timeout\t\tconnect timeout\n");
+        fprintf(stderr, "\t-t timelimit\t\tsearch time limit\n");
+        fprintf(stderr, "\t-R\t\t\tdo not follow referrals\n");
+        fprintf(stderr, "\t-a never|always|search|find\n\t\t\t\twhen to dereference aliases\n");
 #ifdef LDAP_VERSION3
-	fprintf(stderr, "\t-v 2|3\t\t\tLDAP version\n");
-	fprintf(stderr, "\t-Z\t\t\tTLS encrypt the LDAP connection, requires\n\t\t\t\tLDAP version 3\n");
+        fprintf(stderr, "\t-v 2|3\t\t\tLDAP version\n");
+        fprintf(stderr, "\t-Z\t\t\tTLS encrypt the LDAP connection, requires\n\t\t\t\tLDAP version 3\n");
 #endif
-	fprintf(stderr, "\t-g\t\t\tfirst query parameter is base DN extension\n\t\t\t\tfor this query\n");
-	fprintf(stderr, "\t-S\t\t\tStrip NT domain from usernames\n");
-	fprintf(stderr, "\t-K\t\t\tStrip Kerberos realm from usernames\n");
-	fprintf(stderr, "\n");
-	fprintf(stderr, "\tIf you need to bind as a user to perform searches then use the\n\t-D binddn -w bindpasswd or -D binddn -W secretfile options\n\n");
-	exit(1);
+        fprintf(stderr, "\t-g\t\t\tfirst query parameter is base DN extension\n\t\t\t\tfor this query\n");
+        fprintf(stderr, "\t-S\t\t\tStrip NT domain from usernames\n");
+        fprintf(stderr, "\t-K\t\t\tStrip Kerberos realm from usernames\n");
+        fprintf(stderr, "\n");
+        fprintf(stderr, "\tIf you need to bind as a user to perform searches then use the\n\t-D binddn -w bindpasswd or -D binddn -W secretfile options\n\n");
+        exit(1);
     }
-/* On Windows ldap_start_tls_s is available starting from Windows XP, 
- * so we need to bind at run-time with the function entry point
- */
+    /* On Windows ldap_start_tls_s is available starting from Windows XP,
+     * so we need to bind at run-time with the function entry point
+     */
 #ifdef _SQUID_MSWIN_
     if (use_tls) {
 
-	HMODULE WLDAP32Handle;
+        HMODULE WLDAP32Handle;
 
-	WLDAP32Handle = GetModuleHandle("wldap32");
-	if ((Win32_ldap_start_tls_s = (PFldap_start_tls_s) GetProcAddress(WLDAP32Handle, LDAP_START_TLS_S)) == NULL) {
-	    fprintf(stderr, PROGRAM_NAME ": ERROR: TLS (-Z) not supported on this platform.\n");
-	    exit(1);
-	}
+        WLDAP32Handle = GetModuleHandle("wldap32");
+        if ((Win32_ldap_start_tls_s = (PFldap_start_tls_s) GetProcAddress(WLDAP32Handle, LDAP_START_TLS_S)) == NULL) {
+            fprintf(stderr, PROGRAM_NAME ": ERROR: TLS (-Z) not supported on this platform.\n");
+            exit(1);
+        }
     }
 #endif
 
     while (fgets(buf, 256, stdin) != NULL) {
-	int found = 0;
-	if (!strchr(buf, '\n')) {
-	    /* too large message received.. skip and deny */
-	    fprintf(stderr, "%s: ERROR: Too large: %s\n", argv[0], buf);
-	    while (fgets(buf, sizeof(buf), stdin)) {
-		fprintf(stderr, "%s: ERROR: Too large..: %s\n", argv[0], buf);
-		if (strchr(buf, '\n') != NULL)
-		    break;
-	    }
-	    goto error;
-	}
-	user = strtok(buf, " \n");
-	if (!user) {
-	    fprintf(stderr, "%s: Invalid request\n", argv[0]);
-	    goto error;
-	}
-	rfc1738_unescape(user);
-	if (strip_nt_domain) {
-	    char *u = strchr(user, '\\');
-	    if (!u)
-		u = strchr(user, '/');
-	    if (u && u[1])
-		user = u + 1;
-	}
-	if (strip_kerberos_realm) {
-	    char *u = strchr(user, '@');
-	    if (u != NULL) {
-		*u = '\0';
-	    }
-	}
-	if (use_extension_dn) {
-	    extension_dn = strtok(NULL, " \n");
-	    if (!extension_dn) {
-		fprintf(stderr, "%s: Invalid request\n", argv[0]);
-		goto error;
-	    }
-	    rfc1738_unescape(extension_dn);
-	}
-	while (!found && user && (group = strtok(NULL, " \n")) != NULL) {
-	    rfc1738_unescape(group);
-
-	  recover:
-	    if (ld == NULL) {
+        int found = 0;
+        if (!strchr(buf, '\n')) {
+            /* too large message received.. skip and deny */
+            fprintf(stderr, "%s: ERROR: Too large: %s\n", argv[0], buf);
+            while (fgets(buf, sizeof(buf), stdin)) {
+                fprintf(stderr, "%s: ERROR: Too large..: %s\n", argv[0], buf);
+                if (strchr(buf, '\n') != NULL)
+                    break;
+            }
+            goto error;
+        }
+        user = strtok(buf, " \n");
+        if (!user) {
+            fprintf(stderr, "%s: Invalid request\n", argv[0]);
+            goto error;
+        }
+        rfc1738_unescape(user);
+        if (strip_nt_domain) {
+            char *u = strchr(user, '\\');
+            if (!u)
+                u = strchr(user, '/');
+            if (u && u[1])
+                user = u + 1;
+        }
+        if (strip_kerberos_realm) {
+            char *u = strchr(user, '@');
+            if (u != NULL) {
+                *u = '\0';
+            }
+        }
+        if (use_extension_dn) {
+            extension_dn = strtok(NULL, " \n");
+            if (!extension_dn) {
+                fprintf(stderr, "%s: Invalid request\n", argv[0]);
+                goto error;
+            }
+            rfc1738_unescape(extension_dn);
+        }
+        while (!found && user && (group = strtok(NULL, " \n")) != NULL) {
+            rfc1738_unescape(group);
+
+recover:
+            if (ld == NULL) {
 #if HAS_URI_SUPPORT
-		if (strstr(ldapServer, "://") != NULL) {
-		    rc = ldap_initialize(&ld, ldapServer);
-		    if (rc != LDAP_SUCCESS) {
-			fprintf(stderr, "\nUnable to connect to LDAPURI:%s\n", ldapServer);
-			break;
-		    }
-		} else
+                if (strstr(ldapServer, "://") != NULL) {
+                    rc = ldap_initialize(&ld, ldapServer);
+                    if (rc != LDAP_SUCCESS) {
+                        fprintf(stderr, "\nUnable to connect to LDAPURI:%s\n", ldapServer);
+                        break;
+                    }
+                } else
 #endif
 #if NETSCAPE_SSL
-		if (sslpath) {
-		    if (!sslinit && (ldapssl_client_init(sslpath, NULL) != LDAP_SUCCESS)) {
-			fprintf(stderr, "\nUnable to initialise SSL with cert path %s\n",
-			    sslpath);
-			exit(1);
-		    } else {
-			sslinit++;
-		    }
-		    if ((ld = ldapssl_init(ldapServer, port, 1)) == NULL) {
-			fprintf(stderr, "\nUnable to connect to SSL LDAP server: %s port:%d\n",
-			    ldapServer, port);
-			exit(1);
-		    }
-		} else
+                    if (sslpath) {
+                        if (!sslinit && (ldapssl_client_init(sslpath, NULL) != LDAP_SUCCESS)) {
+                            fprintf(stderr, "\nUnable to initialise SSL with cert path %s\n",
+                                    sslpath);
+                            exit(1);
+                        } else {
+                            sslinit++;
+                        }
+                        if ((ld = ldapssl_init(ldapServer, port, 1)) == NULL) {
+                            fprintf(stderr, "\nUnable to connect to SSL LDAP server: %s port:%d\n",
+                                    ldapServer, port);
+                            exit(1);
+                        }
+                    } else
 #endif
-		if ((ld = ldap_init(ldapServer, port)) == NULL) {
-		    fprintf(stderr, "\nUnable to connect to LDAP server:%s port:%d\n", ldapServer, port);
-		    break;
-		}
-		if (connect_timeout)
-		    squid_ldap_set_connect_timeout(ld, connect_timeout);
+                        if ((ld = ldap_init(ldapServer, port)) == NULL) {
+                            fprintf(stderr, "\nUnable to connect to LDAP server:%s port:%d\n", ldapServer, port);
+                            break;
+                        }
+                if (connect_timeout)
+                    squid_ldap_set_connect_timeout(ld, connect_timeout);
 
 #ifdef LDAP_VERSION3
-		if (version == -1) {
-		    version = LDAP_VERSION2;
-		}
-		if (ldap_set_option(ld, LDAP_OPT_PROTOCOL_VERSION, &version) != LDAP_SUCCESS) {
-		    fprintf(stderr, "Could not set LDAP_OPT_PROTOCOL_VERSION %d\n",
-			version);
-		    ldap_unbind(ld);
-		    ld = NULL;
-		    break;
-		}
-		if (use_tls) {
+                if (version == -1) {
+                    version = LDAP_VERSION2;
+                }
+                if (ldap_set_option(ld, LDAP_OPT_PROTOCOL_VERSION, &version) != LDAP_SUCCESS) {
+                    fprintf(stderr, "Could not set LDAP_OPT_PROTOCOL_VERSION %d\n",
+                            version);
+                    ldap_unbind(ld);
+                    ld = NULL;
+                    break;
+                }
+                if (use_tls) {
 #ifdef LDAP_OPT_X_TLS
-		    if (version != LDAP_VERSION3) {
-			fprintf(stderr, "TLS requires LDAP version 3\n");
-			exit(1);
-		    } else if (ldap_start_tls_s(ld, NULL, NULL) != LDAP_SUCCESS) {
-			fprintf(stderr, "Could not Activate TLS connection\n");
-			ldap_unbind(ld);
-			ld = NULL;
-			break;
-		    }
+                    if (version != LDAP_VERSION3) {
+                        fprintf(stderr, "TLS requires LDAP version 3\n");
+                        exit(1);
+                    } else if (ldap_start_tls_s(ld, NULL, NULL) != LDAP_SUCCESS) {
+                        fprintf(stderr, "Could not Activate TLS connection\n");
+                        ldap_unbind(ld);
+                        ld = NULL;
+                        break;
+                    }
 #else
-		    fprintf(stderr, "TLS not supported with your LDAP library\n");
-		    exit(1);
+                    fprintf(stderr, "TLS not supported with your LDAP library\n");
+                    exit(1);
 #endif
-		}
+                }
 #endif
-		squid_ldap_set_timelimit(ld, timelimit);
-		squid_ldap_set_referrals(ld, !noreferrals);
-		squid_ldap_set_aliasderef(ld, aliasderef);
-		if (binddn && bindpasswd && *binddn && *bindpasswd) {
-		    rc = ldap_simple_bind_s(ld, binddn, bindpasswd);
-		    if (rc != LDAP_SUCCESS) {
-			fprintf(stderr, PROGRAM_NAME " WARNING, could not bind to binddn '%s'\n", ldap_err2string(rc));
-			ldap_unbind(ld);
-			ld = NULL;
-			break;
-		    }
-		}
-		if (debug)
-		    fprintf(stderr, "Connected OK\n");
-	    }
-	    if (searchLDAP(ld, group, user, extension_dn) == 0) {
-		found = 1;
-		break;
-	    } else {
-		if (tryagain) {
-		    tryagain = 0;
-		    ldap_unbind(ld);
-		    ld = NULL;
-		    goto recover;
-		}
-	    }
-	}
-	if (found)
-	    printf("OK\n");
-	else {
-	  error:
-	    printf("ERR\n");
-	}
-
-	if (ld != NULL) {
-	    if (!persistent || (squid_ldap_errno(ld) != LDAP_SUCCESS && squid_ldap_errno(ld) != LDAP_INVALID_CREDENTIALS)) {
-		ldap_unbind(ld);
-		ld = NULL;
-	    } else {
-		tryagain = 1;
-	    }
-	}
-	err = 0;
+                squid_ldap_set_timelimit(ld, timelimit);
+                squid_ldap_set_referrals(ld, !noreferrals);
+                squid_ldap_set_aliasderef(ld, aliasderef);
+                if (binddn && bindpasswd && *binddn && *bindpasswd) {
+                    rc = ldap_simple_bind_s(ld, binddn, bindpasswd);
+                    if (rc != LDAP_SUCCESS) {
+                        fprintf(stderr, PROGRAM_NAME " WARNING, could not bind to binddn '%s'\n", ldap_err2string(rc));
+                        ldap_unbind(ld);
+                        ld = NULL;
+                        break;
+                    }
+                }
+                if (debug)
+                    fprintf(stderr, "Connected OK\n");
+            }
+            if (searchLDAP(ld, group, user, extension_dn) == 0) {
+                found = 1;
+                break;
+            } else {
+                if (tryagain) {
+                    tryagain = 0;
+                    ldap_unbind(ld);
+                    ld = NULL;
+                    goto recover;
+                }
+            }
+        }
+        if (found)
+            printf("OK\n");
+        else {
+error:
+            printf("ERR\n");
+        }
+
+        if (ld != NULL) {
+            if (!persistent || (squid_ldap_errno(ld) != LDAP_SUCCESS && squid_ldap_errno(ld) != LDAP_INVALID_CREDENTIALS)) {
+                ldap_unbind(ld);
+                ld = NULL;
+            } else {
+                tryagain = 1;
+            }
+        }
+        err = 0;
     }
     if (ld)
-	ldap_unbind(ld);
+        ldap_unbind(ld);
     return 0;
 }
 
@@ -609,24 +609,24 @@ ldap_escape_value(char *escaped, int size, const char *src)
 {
     int n = 0;
     while (size > 4 && *src) {
-	switch (*src) {
-	case '*':
-	case '(':
-	case ')':
-	case '\\':
-	    n += 3;
-	    size -= 3;
-	    if (size > 0) {
-		*escaped++ = '\\';
-		snprintf(escaped, 3, "%02x", (unsigned char) *src++);
-		escaped += 2;
-	    }
-	    break;
-	default:
-	    *escaped++ = *src++;
-	    n++;
-	    size--;
-	}
+        switch (*src) {
+        case '*':
+        case '(':
+        case ')':
+        case '\\':
+            n += 3;
+            size -= 3;
+            if (size > 0) {
+                *escaped++ = '\\';
+                snprintf(escaped, 3, "%02x", (unsigned char) *src++);
+                escaped += 2;
+            }
+            break;
+        default:
+            *escaped++ = *src++;
+            n++;
+            size--;
+        }
     }
     *escaped = '\0';
     return n;
@@ -637,46 +637,46 @@ build_filter(char *filter, int size, const char *template, const char *user, con
 {
     int n;
     while (*template && size > 0) {
-	switch (*template) {
-	case '%':
-	    template++;
-	    switch (*template) {
-	    case 'u':
-	    case 'v':
-		template++;
-		n = ldap_escape_value(filter, size, user);
-		size -= n;
-		filter += n;
-		break;
-	    case 'g':
-	    case 'a':
-		template++;
-		n = ldap_escape_value(filter, size, group);
-		size -= n;
-		filter += n;
-		break;
-	    default:
-		fprintf(stderr, "ERROR: Unknown filter template string %%%c\n", *template);
-		return 1;
-		break;
-	    }
-	    break;
-	case '\\':
-	    template++;
-	    if (*template) {
-		*filter++ = *template++;
-		size--;
-	    }
-	    break;
-	default:
-	    *filter++ = *template++;
-	    size--;
-	    break;
-	}
+        switch (*template) {
+        case '%':
+            template++;
+            switch (*template) {
+            case 'u':
+            case 'v':
+                template++;
+                n = ldap_escape_value(filter, size, user);
+                size -= n;
+                filter += n;
+                break;
+            case 'g':
+            case 'a':
+                template++;
+                n = ldap_escape_value(filter, size, group);
+                size -= n;
+                filter += n;
+                break;
+            default:
+                fprintf(stderr, "ERROR: Unknown filter template string %%%c\n", *template);
+                return 1;
+                break;
+            }
+            break;
+        case '\\':
+            template++;
+            if (*template) {
+                *filter++ = *template++;
+                size--;
+            }
+            break;
+        default:
+            *filter++ = *template++;
+            size--;
+            break;
+        }
     }
     if (size <= 0) {
-	fprintf(stderr, "ERROR: Filter too large\n");
-	return 1;
+        fprintf(stderr, "ERROR: Filter too large\n");
+        return 1;
     }
     *filter = '\0';
     return 0;
@@ -690,43 +690,42 @@ searchLDAPGroup(LDAP * ld, char *group, char *member, char *extension_dn)
     LDAPMessage *res = NULL;
     LDAPMessage *entry;
     int rc;
-    char *searchattr[] =
-    {(char *) LDAP_NO_ATTRS, NULL};
+    char *searchattr[] = {(char *) LDAP_NO_ATTRS, NULL};
 
     if (extension_dn && *extension_dn)
-	snprintf(searchbase, sizeof(searchbase), "%s,%s", extension_dn, basedn);
+        snprintf(searchbase, sizeof(searchbase), "%s,%s", extension_dn, basedn);
     else
-	snprintf(searchbase, sizeof(searchbase), "%s", basedn);
+        snprintf(searchbase, sizeof(searchbase), "%s", basedn);
 
     if (build_filter(filter, sizeof(filter), searchfilter, member, group) != 0) {
-	fprintf(stderr, PROGRAM_NAME " ERROR, Failed to construct LDAP search filter. filter=\"%s\", user=\"%s\", group=\"%s\"\n", filter, member, group);
-	return 1;
+        fprintf(stderr, PROGRAM_NAME " ERROR, Failed to construct LDAP search filter. filter=\"%s\", user=\"%s\", group=\"%s\"\n", filter, member, group);
+        return 1;
     }
     if (debug)
-	fprintf(stderr, "group filter '%s', searchbase '%s'\n", filter, searchbase);
+        fprintf(stderr, "group filter '%s', searchbase '%s'\n", filter, searchbase);
 
     rc = ldap_search_s(ld, searchbase, searchscope, filter, searchattr, 1, &res);
     if (rc != LDAP_SUCCESS) {
-	if (noreferrals && rc == LDAP_PARTIAL_RESULTS) {
-	    /* Everything is fine. This is expected when referrals
-	     * are disabled.
-	     */
-	} else {
-	    fprintf(stderr, PROGRAM_NAME " WARNING, LDAP search error '%s'\n", ldap_err2string(rc));
+        if (noreferrals && rc == LDAP_PARTIAL_RESULTS) {
+            /* Everything is fine. This is expected when referrals
+             * are disabled.
+             */
+        } else {
+            fprintf(stderr, PROGRAM_NAME " WARNING, LDAP search error '%s'\n", ldap_err2string(rc));
 #if defined(NETSCAPE_SSL)
-	    if (sslpath && ((rc == LDAP_SERVER_DOWN) || (rc == LDAP_CONNECT_ERROR))) {
-		int sslerr = PORT_GetError();
-		fprintf(stderr, PROGRAM_NAME ": WARNING, SSL error %d (%s)\n", sslerr, ldapssl_err2string(sslerr));
-	    }
+            if (sslpath && ((rc == LDAP_SERVER_DOWN) || (rc == LDAP_CONNECT_ERROR))) {
+                int sslerr = PORT_GetError();
+                fprintf(stderr, PROGRAM_NAME ": WARNING, SSL error %d (%s)\n", sslerr, ldapssl_err2string(sslerr));
+            }
 #endif
-	    ldap_msgfree(res);
-	    return 1;
-	}
+            ldap_msgfree(res);
+            return 1;
+        }
     }
     entry = ldap_first_entry(ld, res);
     if (!entry) {
-	ldap_msgfree(res);
-	return 1;
+        ldap_msgfree(res);
+        return 1;
     }
     ldap_msgfree(res);
     return 0;
@@ -737,61 +736,60 @@ searchLDAP(LDAP * ld, char *group, char *login, char *extension_dn)
 {
 
     if (usersearchfilter) {
-	char filter[8192];
-	char searchbase[8192];
-	char escaped_login[1024];
-	LDAPMessage *res = NULL;
-	LDAPMessage *entry;
-	int rc;
-	char *userdn;
-	char *searchattr[] =
-	{(char *) LDAP_NO_ATTRS, NULL};
-	if (extension_dn && *extension_dn)
-	    snprintf(searchbase, sizeof(searchbase), "%s,%s", extension_dn, userbasedn ? userbasedn : basedn);
-	else
-	    snprintf(searchbase, sizeof(searchbase), "%s", userbasedn ? userbasedn : basedn);
-	ldap_escape_value(escaped_login, sizeof(escaped_login), login);
-	snprintf(filter, sizeof(filter), usersearchfilter, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login);
-	if (debug)
-	    fprintf(stderr, "user filter '%s', searchbase '%s'\n", filter, searchbase);
-	rc = ldap_search_s(ld, searchbase, searchscope, filter, searchattr, 1, &res);
-	if (rc != LDAP_SUCCESS) {
-	    if (noreferrals && rc == LDAP_PARTIAL_RESULTS) {
-		/* Everything is fine. This is expected when referrals
-		 * are disabled.
-		 */
-	    } else {
-		fprintf(stderr, PROGRAM_NAME " WARNING, LDAP search error '%s'\n", ldap_err2string(rc));
+        char filter[8192];
+        char searchbase[8192];
+        char escaped_login[1024];
+        LDAPMessage *res = NULL;
+        LDAPMessage *entry;
+        int rc;
+        char *userdn;
+        char *searchattr[] = {(char *) LDAP_NO_ATTRS, NULL};
+        if (extension_dn && *extension_dn)
+            snprintf(searchbase, sizeof(searchbase), "%s,%s", extension_dn, userbasedn ? userbasedn : basedn);
+        else
+            snprintf(searchbase, sizeof(searchbase), "%s", userbasedn ? userbasedn : basedn);
+        ldap_escape_value(escaped_login, sizeof(escaped_login), login);
+        snprintf(filter, sizeof(filter), usersearchfilter, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login, escaped_login);
+        if (debug)
+            fprintf(stderr, "user filter '%s', searchbase '%s'\n", filter, searchbase);
+        rc = ldap_search_s(ld, searchbase, searchscope, filter, searchattr, 1, &res);
+        if (rc != LDAP_SUCCESS) {
+            if (noreferrals && rc == LDAP_PARTIAL_RESULTS) {
+                /* Everything is fine. This is expected when referrals
+                 * are disabled.
+                 */
+            } else {
+                fprintf(stderr, PROGRAM_NAME " WARNING, LDAP search error '%s'\n", ldap_err2string(rc));
 #if defined(NETSCAPE_SSL)
-		if (sslpath && ((rc == LDAP_SERVER_DOWN) || (rc == LDAP_CONNECT_ERROR))) {
-		    int sslerr = PORT_GetError();
-		    fprintf(stderr, PROGRAM_NAME ": WARNING, SSL error %d (%s)\n", sslerr, ldapssl_err2string(sslerr));
-		}
+                if (sslpath && ((rc == LDAP_SERVER_DOWN) || (rc == LDAP_CONNECT_ERROR))) {
+                    int sslerr = PORT_GetError();
+                    fprintf(stderr, PROGRAM_NAME ": WARNING, SSL error %d (%s)\n", sslerr, ldapssl_err2string(sslerr));
+                }
 #endif
-		ldap_msgfree(res);
-		return 1;
-	    }
-	}
-	entry = ldap_first_entry(ld, res);
-	if (!entry) {
-	    fprintf(stderr, PROGRAM_NAME " WARNING, User '%s' not found in '%s'\n", login, searchbase);
-	    ldap_msgfree(res);
-	    return 1;
-	}
-	userdn = ldap_get_dn(ld, entry);
-	rc = searchLDAPGroup(ld, group, userdn, extension_dn);
-	squid_ldap_memfree(userdn);
-	ldap_msgfree(res);
-	return rc;
+                ldap_msgfree(res);
+                return 1;
+            }
+        }
+        entry = ldap_first_entry(ld, res);
+        if (!entry) {
+            fprintf(stderr, PROGRAM_NAME " WARNING, User '%s' not found in '%s'\n", login, searchbase);
+            ldap_msgfree(res);
+            return 1;
+        }
+        userdn = ldap_get_dn(ld, entry);
+        rc = searchLDAPGroup(ld, group, userdn, extension_dn);
+        squid_ldap_memfree(userdn);
+        ldap_msgfree(res);
+        return rc;
     } else if (userdnattr) {
-	char dn[8192];
-	if (extension_dn && *extension_dn)
-	    sprintf(dn, "%s=%s, %s, %s", userdnattr, login, extension_dn, userbasedn ? userbasedn : basedn);
-	else
-	    sprintf(dn, "%s=%s, %s", userdnattr, login, userbasedn ? userbasedn : basedn);
-	return searchLDAPGroup(ld, group, dn, extension_dn);
+        char dn[8192];
+        if (extension_dn && *extension_dn)
+            sprintf(dn, "%s=%s, %s, %s", userdnattr, login, extension_dn, userbasedn ? userbasedn : basedn);
+        else
+            sprintf(dn, "%s=%s, %s", userdnattr, login, userbasedn ? userbasedn : basedn);
+        return searchLDAPGroup(ld, group, dn, extension_dn);
     } else {
-	return searchLDAPGroup(ld, group, login, extension_dn);
+        return searchLDAPGroup(ld, group, login, extension_dn);
     }
 }
 
@@ -804,23 +802,23 @@ readSecret(const char *filename)
     FILE *f;
 
     if (!(f = fopen(filename, "r"))) {
-	fprintf(stderr, PROGRAM_NAME " ERROR: Can not read secret file %s\n", filename);
-	return 1;
+        fprintf(stderr, PROGRAM_NAME " ERROR: Can not read secret file %s\n", filename);
+        return 1;
     }
     if (!fgets(buf, sizeof(buf) - 1, f)) {
-	fprintf(stderr, PROGRAM_NAME " ERROR: Secret file %s is empty\n", filename);
-	fclose(f);
-	return 1;
+        fprintf(stderr, PROGRAM_NAME " ERROR: Secret file %s is empty\n", filename);
+        fclose(f);
+        return 1;
     }
     /* strip whitespaces on end */
     if ((e = strrchr(buf, '\n')))
-	*e = 0;
+        *e = 0;
     if ((e = strrchr(buf, '\r')))
-	*e = 0;
+        *e = 0;
 
     bindpasswd = strdup(buf);
     if (!bindpasswd) {
-	fprintf(stderr, PROGRAM_NAME " ERROR: can not allocate memory\n");
+        fprintf(stderr, PROGRAM_NAME " ERROR: can not allocate memory\n");
     }
     fclose(f);
 
@@ -36,7 +36,7 @@
  *              First release, based on mswin_check_lm_group.
  *
  * This is a helper for the external ACL interface for Squid Cache
- * 
+ *
  * It reads from the standard input the domain username and a list of
  * groups and tries to match it against the groups membership of the
  * specified username.
@@ -93,46 +93,46 @@ GetDomainName(void)
     DWORD netret;
 
     if ((netret = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (PBYTE *) & pDSRoleInfo) == ERROR_SUCCESS)) {
-	/* 
-	 * Check the machine role.
-	 */
-
-	if ((pDSRoleInfo->MachineRole == DsRole_RoleMemberWorkstation) ||
-	    (pDSRoleInfo->MachineRole == DsRole_RoleMemberServer) ||
-	    (pDSRoleInfo->MachineRole == DsRole_RoleBackupDomainController) ||
-	    (pDSRoleInfo->MachineRole == DsRole_RolePrimaryDomainController)) {
-
-	    size_t len = wcslen(pDSRoleInfo->DomainNameFlat);
-
-	    /* allocate buffer for str + null termination */
-	    safe_free(DomainName);
-	    DomainName = (char *) xmalloc(len + 1);
-	    if (DomainName == NULL)
-		return NULL;
-
-	    /* copy unicode buffer */
-	    WideCharToMultiByte(CP_ACP, 0, pDSRoleInfo->DomainNameFlat, -1, DomainName, len, NULL, NULL);
-
-	    /* add null termination */
-	    DomainName[len] = '\0';
-
-	    /* 
-	     * Member of a domain. Display it in debug mode.
-	     */
-	    debug("Member of Domain %s\n", DomainName);
-	    debug("Into forest %S\n", pDSRoleInfo->DomainForestName);
-
-	} else {
-	    debug("Not a Domain member\n");
-	}
+        /*
+         * Check the machine role.
+         */
+
+        if ((pDSRoleInfo->MachineRole == DsRole_RoleMemberWorkstation) ||
+                (pDSRoleInfo->MachineRole == DsRole_RoleMemberServer) ||
+                (pDSRoleInfo->MachineRole == DsRole_RoleBackupDomainController) ||
+                (pDSRoleInfo->MachineRole == DsRole_RolePrimaryDomainController)) {
+
+            size_t len = wcslen(pDSRoleInfo->DomainNameFlat);
+
+            /* allocate buffer for str + null termination */
+            safe_free(DomainName);
+            DomainName = (char *) xmalloc(len + 1);
+            if (DomainName == NULL)
+                return NULL;
+
+            /* copy unicode buffer */
+            WideCharToMultiByte(CP_ACP, 0, pDSRoleInfo->DomainNameFlat, -1, DomainName, len, NULL, NULL);
+
+            /* add null termination */
+            DomainName[len] = '\0';
+
+            /*
+             * Member of a domain. Display it in debug mode.
+             */
+            debug("Member of Domain %s\n", DomainName);
+            debug("Into forest %S\n", pDSRoleInfo->DomainForestName);
+
+        } else {
+            debug("Not a Domain member\n");
+        }
     } else
-	debug("DsRoleGetPrimaryDomainInformation Error: %ld\n", netret);
+        debug("DsRoleGetPrimaryDomainInformation Error: %ld\n", netret);
 
     /*
      * Free the allocated memory.
      */
     if (pDSRoleInfo != NULL)
-	DsRoleFreeMemory(pDSRoleInfo);
+        DsRoleFreeMemory(pDSRoleInfo);
 
     return DomainName;
 }
@@ -144,12 +144,12 @@ wcstrcmparray(const wchar_t * str, const char **array)
     WCHAR wszGroup[GNLEN + 1];	// Unicode Group
 
     while (*array) {
-	MultiByteToWideChar(CP_ACP, 0, *array,
-	    strlen(*array) + 1, wszGroup, sizeof(wszGroup) / sizeof(wszGroup[0]));
-	debug("Windows group: %S, Squid group: %S\n", str, wszGroup);
-	if ((use_case_insensitive_compare ? _wcsicmp(str, wszGroup) : wcscmp(str, wszGroup)) == 0)
-	    return 0;
-	array++;
+        MultiByteToWideChar(CP_ACP, 0, *array,
+                            strlen(*array) + 1, wszGroup, sizeof(wszGroup) / sizeof(wszGroup[0]));
+        debug("Windows group: %S, Squid group: %S\n", str, wszGroup);
+        if ((use_case_insensitive_compare ? _wcsicmp(str, wszGroup) : wcscmp(str, wszGroup)) == 0)
+            return 0;
+        array++;
     }
     return -1;
 }
@@ -175,58 +175,58 @@ Valid_Local_Groups(char *UserName, const char **Groups)
     LPBYTE pBufTmp = NULL;
 
     if ((Domain_Separator = strchr(UserName, '/')) != NULL)
-	*Domain_Separator = '\\';
+        *Domain_Separator = '\\';
 
     debug("Valid_Local_Groups: checking group membership of '%s'.\n", UserName);
 
-/* Convert ANSI User Name and Group to Unicode */
+    /* Convert ANSI User Name and Group to Unicode */
 
     MultiByteToWideChar(CP_ACP, 0, UserName,
-	strlen(UserName) + 1, wszUserName, sizeof(wszUserName) / sizeof(wszUserName[0]));
+                        strlen(UserName) + 1, wszUserName, sizeof(wszUserName) / sizeof(wszUserName[0]));
 
     /*
-     * Call the NetUserGetLocalGroups function 
+     * Call the NetUserGetLocalGroups function
      * specifying information level 0.
-     * 
-     * The LG_INCLUDE_INDIRECT flag specifies that the 
-     * function should also return the names of the local 
+     *
+     * The LG_INCLUDE_INDIRECT flag specifies that the
+     * function should also return the names of the local
      * groups in which the user is indirectly a member.
      */
     nStatus = NetUserGetLocalGroups(NULL,
-	wszUserName,
-	dwLevel,
-	dwFlags,
-	&pBufTmp,
-	dwPrefMaxLen,
-	&dwEntriesRead,
-	&dwTotalEntries);
+                                    wszUserName,
+                                    dwLevel,
+                                    dwFlags,
+                                    &pBufTmp,
+                                    dwPrefMaxLen,
+                                    &dwEntriesRead,
+                                    &dwTotalEntries);
     pBuf = (LPLOCALGROUP_USERS_INFO_0) pBufTmp;
     /*
      * If the call succeeds,
      */
     if (nStatus == NERR_Success) {
-	if ((pTmpBuf = pBuf) != NULL) {
-	    for (i = 0; i < dwEntriesRead; i++) {
-		assert(pTmpBuf != NULL);
-		if (pTmpBuf == NULL) {
-		    result = 0;
-		    break;
-		}
-		if (wcstrcmparray(pTmpBuf->lgrui0_name, Groups) == 0) {
-		    result = 1;
-		    break;
-		}
-		pTmpBuf++;
-		dwTotalCount++;
-	    }
-	}
+        if ((pTmpBuf = pBuf) != NULL) {
+            for (i = 0; i < dwEntriesRead; i++) {
+                assert(pTmpBuf != NULL);
+                if (pTmpBuf == NULL) {
+                    result = 0;
+                    break;
+                }
+                if (wcstrcmparray(pTmpBuf->lgrui0_name, Groups) == 0) {
+                    result = 1;
+                    break;
+                }
+                pTmpBuf++;
+                dwTotalCount++;
+            }
+        }
     } else
-	result = 0;
-/*
- * Free the allocated memory.
- */
+        result = 0;
+    /*
+     * Free the allocated memory.
+     */
     if (pBuf != NULL)
-	NetApiBufferFree(pBuf);
+        NetApiBufferFree(pBuf);
     return result;
 }
 
@@ -260,101 +260,101 @@ Valid_Global_Groups(char *UserName, const char **Groups)
     strncpy(NTDomain, UserName, sizeof(NTDomain));
 
     for (j = 0; j < strlen(NTV_VALID_DOMAIN_SEPARATOR); j++) {
-	if ((domain_qualify = strchr(NTDomain, NTV_VALID_DOMAIN_SEPARATOR[j])) != NULL)
-	    break;
+        if ((domain_qualify = strchr(NTDomain, NTV_VALID_DOMAIN_SEPARATOR[j])) != NULL)
+            break;
     }
     if (domain_qualify == NULL) {
-	strcpy(User, NTDomain);
-	strcpy(NTDomain, DefaultDomain);
+        strcpy(User, NTDomain);
+        strcpy(NTDomain, DefaultDomain);
     } else {
-	strcpy(User, domain_qualify + 1);
-	domain_qualify[0] = '\0';
-	strlwr(NTDomain);
+        strcpy(User, domain_qualify + 1);
+        domain_qualify[0] = '\0';
+        strlwr(NTDomain);
     }
 
     debug("Valid_Global_Groups: checking group membership of '%s\\%s'.\n", NTDomain, User);
 
     /* Convert ANSI User Name to Unicode */
 
     MultiByteToWideChar(CP_ACP, 0, User,
-	strlen(User) + 1, wszUserName,
-	sizeof(wszUserName) / sizeof(wszUserName[0]));
+                        strlen(User) + 1, wszUserName,
+                        sizeof(wszUserName) / sizeof(wszUserName[0]));
 
     /* Query AD for a DC */
 
     if (DsGetDcName(NULL, NTDomain, NULL, NULL, DS_IS_FLAT_NAME | DS_RETURN_FLAT_NAME, &pDCInfo) != NO_ERROR) {
-	fprintf(stderr, "%s DsGetDcName() failed.'\n", myname);
-	if (pDCInfo != NULL)
-	    NetApiBufferFree(pDCInfo);
-	return result;
+        fprintf(stderr, "%s DsGetDcName() failed.'\n", myname);
+        if (pDCInfo != NULL)
+            NetApiBufferFree(pDCInfo);
+        return result;
     }
     /* Convert ANSI Domain Controller Name to Unicode */
 
     MultiByteToWideChar(CP_ACP, 0, pDCInfo->DomainControllerName,
-	strlen(pDCInfo->DomainControllerName) + 1, wszDomainControllerName,
-	sizeof(wszDomainControllerName) / sizeof(wszDomainControllerName[0]));
+                        strlen(pDCInfo->DomainControllerName) + 1, wszDomainControllerName,
+                        sizeof(wszDomainControllerName) / sizeof(wszDomainControllerName[0]));
 
     debug("Using '%S' as DC for '%s' user's domain.\n", wszDomainControllerName, NTDomain);
     debug("DC Active Directory Site is %s\n", pDCInfo->DcSiteName);
     debug("Machine Active Directory Site is %s\n", pDCInfo->ClientSiteName);
 
     /*
-     * Call the NetUserGetGroups function 
+     * Call the NetUserGetGroups function
      * specifying information level 0.
      */
     dwLevel = 0;
     pBufTmp = NULL;
     nStatus = NetUserGetGroups(wszDomainControllerName,
-	wszUserName,
-	dwLevel,
-	&pBufTmp,
-	dwPrefMaxLen,
-	&dwEntriesRead,
-	&dwTotalEntries);
+                               wszUserName,
+                               dwLevel,
+                               &pBufTmp,
+                               dwPrefMaxLen,
+                               &dwEntriesRead,
+                               &dwTotalEntries);
     pUsrBuf = (LPGROUP_USERS_INFO_0) pBufTmp;
     /*
      * If the call succeeds,
      */
     if (nStatus == NERR_Success) {
-	if ((pTmpBuf = pUsrBuf) != NULL) {
-	    for (i = 0; i < dwEntriesRead; i++) {
-		assert(pTmpBuf != NULL);
-		if (pTmpBuf == NULL) {
-		    result = 0;
-		    break;
-		}
-		if (wcstrcmparray(pTmpBuf->grui0_name, Groups) == 0) {
-		    result = 1;
-		    break;
-		}
-		pTmpBuf++;
-		dwTotalCount++;
-	    }
-	}
+        if ((pTmpBuf = pUsrBuf) != NULL) {
+            for (i = 0; i < dwEntriesRead; i++) {
+                assert(pTmpBuf != NULL);
+                if (pTmpBuf == NULL) {
+                    result = 0;
+                    break;
+                }
+                if (wcstrcmparray(pTmpBuf->grui0_name, Groups) == 0) {
+                    result = 1;
+                    break;
+                }
+                pTmpBuf++;
+                dwTotalCount++;
+            }
+        }
     } else {
-	result = 0;
-	fprintf(stderr, "%s NetUserGetGroups() failed.'\n", myname);
+        result = 0;
+        fprintf(stderr, "%s NetUserGetGroups() failed.'\n", myname);
     }
     /*
      * Free the allocated memory.
      */
     if (pUsrBuf != NULL)
-	NetApiBufferFree(pUsrBuf);
+        NetApiBufferFree(pUsrBuf);
     if (pDCInfo != NULL)
-	NetApiBufferFree((LPVOID) pDCInfo);
+        NetApiBufferFree((LPVOID) pDCInfo);
     return result;
 }
 
 static void
 usage(char *program)
 {
     fprintf(stderr, "Usage: %s [-D domain][-G][-P][-c][-d][-h]\n"
-	" -D    default user Domain\n"
-	" -G    enable Domain Global group mode\n"
-	" -c    use case insensitive compare\n"
-	" -d    enable debugging\n"
-	" -h    this message\n",
-	program);
+            " -D    default user Domain\n"
+            " -G    enable Domain Global group mode\n"
+            " -c    use case insensitive compare\n"
+            " -d    enable debugging\n"
+            " -h    this message\n",
+            program);
 }
 
 void
@@ -364,32 +364,32 @@ process_options(int argc, char *argv[])
 
     opterr = 0;
     while (-1 != (opt = getopt(argc, argv, "D:Gcdh"))) {
-	switch (opt) {
-	case 'D':
-	    DefaultDomain = xstrndup(optarg, DNLEN + 1);
-	    strlwr(DefaultDomain);
-	    break;
-	case 'G':
-	    use_global = 1;
-	    break;
-	case 'c':
-	    use_case_insensitive_compare = 1;
-	    break;
-	case 'd':
-	    debug_enabled = 1;
-	    break;
-	case 'h':
-	    usage(argv[0]);
-	    exit(0);
-	case '?':
-	    opt = optopt;
-	    /* fall thru to default */
-	default:
-	    fprintf(stderr, "%s Unknown option: -%c. Exiting\n", myname, opt);
-	    usage(argv[0]);
-	    exit(1);
-	    break;		/* not reached */
-	}
+        switch (opt) {
+        case 'D':
+            DefaultDomain = xstrndup(optarg, DNLEN + 1);
+            strlwr(DefaultDomain);
+            break;
+        case 'G':
+            use_global = 1;
+            break;
+        case 'c':
+            use_case_insensitive_compare = 1;
+            break;
+        case 'd':
+            debug_enabled = 1;
+            break;
+        case 'h':
+            usage(argv[0]);
+            exit(0);
+        case '?':
+            opt = optopt;
+            /* fall thru to default */
+        default:
+            fprintf(stderr, "%s Unknown option: -%c. Exiting\n", myname, opt);
+            usage(argv[0]);
+            exit(1);
+            break;		/* not reached */
+        }
     }
     return;
 }
@@ -407,11 +407,11 @@ main(int argc, char *argv[])
     int n;
 
     if (argc > 0) {		/* should always be true */
-	myname = strrchr(argv[0], '/');
-	if (myname == NULL)
-	    myname = argv[0];
+        myname = strrchr(argv[0], '/');
+        if (myname == NULL)
+            myname = argv[0];
     } else {
-	myname = "(unknown)";
+        myname = "(unknown)";
     }
     mypid = getpid();
 
@@ -422,64 +422,64 @@ main(int argc, char *argv[])
     process_options(argc, argv);
 
     if (use_global) {
-	if ((machinedomain = GetDomainName()) == NULL) {
-	    fprintf(stderr, "%s Can't read machine domain\n", myname);
-	    exit(1);
-	}
-	strlwr(machinedomain);
-	if (!DefaultDomain)
-	    DefaultDomain = xstrdup(machinedomain);
+        if ((machinedomain = GetDomainName()) == NULL) {
+            fprintf(stderr, "%s Can't read machine domain\n", myname);
+            exit(1);
+        }
+        strlwr(machinedomain);
+        if (!DefaultDomain)
+            DefaultDomain = xstrdup(machinedomain);
     }
     debug("External ACL win32 group helper build " __DATE__ ", " __TIME__
-	" starting up...\n");
+          " starting up...\n");
     if (use_global)
-	debug("Domain Global group mode enabled using '%s' as default domain.\n", DefaultDomain);
+        debug("Domain Global group mode enabled using '%s' as default domain.\n", DefaultDomain);
     if (use_case_insensitive_compare)
-	debug("Warning: running in case insensitive mode !!!\n");
+        debug("Warning: running in case insensitive mode !!!\n");
 
     /* Main Loop */
     while (fgets(buf, sizeof(buf), stdin)) {
-	if (NULL == strchr(buf, '\n')) {
-	    /* too large message received.. skip and deny */
-	    fprintf(stderr, "%s: ERROR: Too large: %s\n", argv[0], buf);
-	    while (fgets(buf, sizeof(buf), stdin)) {
-		fprintf(stderr, "%s: ERROR: Too large..: %s\n", argv[0], buf);
-		if (strchr(buf, '\n') != NULL)
-		    break;
-	    }
-	    goto error;
-	}
-	if ((p = strchr(buf, '\n')) != NULL)
-	    *p = '\0';		/* strip \n */
-	if ((p = strchr(buf, '\r')) != NULL)
-	    *p = '\0';		/* strip \r */
-
-	debug("Got '%s' from Squid (length: %d).\n", buf, strlen(buf));
-
-	if (buf[0] == '\0') {
-	    fprintf(stderr, "Invalid Request\n");
-	    goto error;
-	}
-	username = strtok(buf, " ");
-	for (n = 0; (group = strtok(NULL, " ")) != NULL; n++) {
-	    rfc1738_unescape(group);
-	    groups[n] = group;
-	}
-	groups[n] = NULL;
-
-	if (NULL == username) {
-	    fprintf(stderr, "Invalid Request\n");
-	    goto error;
-	}
-	rfc1738_unescape(username);
-
-	if ((use_global ? Valid_Global_Groups(username, groups) : Valid_Local_Groups(username, groups))) {
-	    printf("OK\n");
-	} else {
-	  error:
-	    printf("ERR\n");
-	}
-	err = 0;
+        if (NULL == strchr(buf, '\n')) {
+            /* too large message received.. skip and deny */
+            fprintf(stderr, "%s: ERROR: Too large: %s\n", argv[0], buf);
+            while (fgets(buf, sizeof(buf), stdin)) {
+                fprintf(stderr, "%s: ERROR: Too large..: %s\n", argv[0], buf);
+                if (strchr(buf, '\n') != NULL)
+                    break;
+            }
+            goto error;
+        }
+        if ((p = strchr(buf, '\n')) != NULL)
+            *p = '\0';		/* strip \n */
+        if ((p = strchr(buf, '\r')) != NULL)
+            *p = '\0';		/* strip \r */
+
+        debug("Got '%s' from Squid (length: %d).\n", buf, strlen(buf));
+
+        if (buf[0] == '\0') {
+            fprintf(stderr, "Invalid Request\n");
+            goto error;
+        }
+        username = strtok(buf, " ");
+        for (n = 0; (group = strtok(NULL, " ")) != NULL; n++) {
+            rfc1738_unescape(group);
+            groups[n] = group;
+        }
+        groups[n] = NULL;
+
+        if (NULL == username) {
+            fprintf(stderr, "Invalid Request\n");
+            goto error;
+        }
+        rfc1738_unescape(username);
+
+        if ((use_global ? Valid_Global_Groups(username, groups) : Valid_Local_Groups(username, groups))) {
+            printf("OK\n");
+        } else {
+error:
+            printf("ERR\n");
+        }
+        err = 0;
     }
     return 0;
 }
@@ -9,7 +9,7 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- 
+
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
@@ -55,13 +55,13 @@ debug(char *format,...)
 #ifdef DEBUG
 #ifdef _SQUID_MSWIN_
     if (debug_enabled) {
-	va_list args;
+        va_list args;
 
-	va_start(args, format);
-	fprintf(stderr, "%s[%d]: ", myname, mypid);
-	vfprintf(stderr, format, args);
-	fprintf(stderr, "\n");
-	va_end(args);
+        va_start(args, format);
+        fprintf(stderr, "%s[%d]: ", myname, mypid);
+        vfprintf(stderr, format, args);
+        fprintf(stderr, "\n");
+        va_end(args);
     }
 #endif /* _SQUID_MSWIN_ */
 #endif /* DEBUG */
@@ -34,7 +34,7 @@
  * 08-07-2005 Guido Serassio
  *              Added -P option for force usage of PDCs for group validation.
  *              Added support for '/' char as domain separator.
- *              Fixed Bugzilla #1336. 
+ *              Fixed Bugzilla #1336.
  * Version 1.21
  * 23-04-2005 Guido Serassio
  *              Added -D option for specify default user's domain.
@@ -57,7 +57,7 @@
  *              from wbinfo wrote win32_group
  *
  * This is a helper for the external ACL interface for Squid Cache
- * 
+ *
  * It reads from the standard input the domain username and a list of
  * groups and tries to match it against the groups membership of the
  * specified username.
@@ -118,7 +118,7 @@ AllocStrFromLSAStr(LSA_UNICODE_STRING LsaStr)
     safe_free(target);
     target = (char *) xmalloc(len);
     if (target == NULL)
-	return NULL;
+        return NULL;
 
     /* copy unicode buffer */
     WideCharToMultiByte(CP_ACP, 0, LsaStr.Buffer, LsaStr.Length, target, len, NULL, NULL);
@@ -140,96 +140,96 @@ GetDomainName(void)
     DWORD netret;
     char *DomainName = NULL;
 
-    /* 
+    /*
      * Always initialize the object attributes to all zeroes.
      */
     memset(&ObjectAttributes, '\0', sizeof(ObjectAttributes));
 
-    /* 
+    /*
      * You need the local workstation name. Use NetWkstaGetInfo at level
      * 100 to retrieve a WKSTA_INFO_100 structure.
-     * 
+     *
      * The wki100_computername field contains a pointer to a UNICODE
      * string containing the local computer name.
      */
     netret = NetWkstaGetInfo(NULL, 100, (LPBYTE *) & pwkiWorkstationInfo);
     if (netret == NERR_Success) {
-	/* 
-	 * We have the workstation name in:
-	 * pwkiWorkstationInfo->wki100_computername
-	 * 
-	 * Next, open the policy object for the local system using
-	 * the LsaOpenPolicy function.
-	 */
-	status = LsaOpenPolicy(
-	    NULL,
-	    &ObjectAttributes,
-	    GENERIC_READ | POLICY_VIEW_LOCAL_INFORMATION,
-	    &PolicyHandle
-	    );
-
-	/* 
-	 * Error checking.
-	 */
-	if (status) {
-	    debug("OpenPolicy Error: %ld\n", status);
-	} else {
-
-	    /* 
-	     * You have a handle to the policy object. Now, get the
-	     * domain information using LsaQueryInformationPolicy.
-	     */
-	    status = LsaQueryInformationPolicy(PolicyHandle,
-		PolicyPrimaryDomainInformation,
-		(PVOID *) & ppdiDomainInfo);
-	    if (status) {
-		debug("LsaQueryInformationPolicy Error: %ld\n", status);
-	    } else {
-
-		/* Get name in useable format */
-		DomainName = AllocStrFromLSAStr(ppdiDomainInfo->Name);
-
-		/* 
-		 * Check the Sid pointer, if it is null, the
-		 * workstation is either a stand-alone computer
-		 * or a member of a workgroup.
-		 */
-		if (ppdiDomainInfo->Sid) {
-
-		    /* 
-		     * Member of a domain. Display it in debug mode.
-		     */
-		    debug("Member of Domain %s\n", DomainName);
-		} else {
-		    DomainName = NULL;
-		}
-	    }
-	}
-
-	/* 
-	 * Clean up all the memory buffers created by the LSA and
-	 * Net* APIs.
-	 */
-	NetApiBufferFree(pwkiWorkstationInfo);
-	LsaFreeMemory((LPVOID) ppdiDomainInfo);
+        /*
+         * We have the workstation name in:
+         * pwkiWorkstationInfo->wki100_computername
+         *
+         * Next, open the policy object for the local system using
+         * the LsaOpenPolicy function.
+         */
+        status = LsaOpenPolicy(
+                     NULL,
+                     &ObjectAttributes,
+                     GENERIC_READ | POLICY_VIEW_LOCAL_INFORMATION,
+                     &PolicyHandle
+                 );
+
+        /*
+         * Error checking.
+         */
+        if (status) {
+            debug("OpenPolicy Error: %ld\n", status);
+        } else {
+
+            /*
+             * You have a handle to the policy object. Now, get the
+             * domain information using LsaQueryInformationPolicy.
+             */
+            status = LsaQueryInformationPolicy(PolicyHandle,
+                                               PolicyPrimaryDomainInformation,
+                                               (PVOID *) & ppdiDomainInfo);
+            if (status) {
+                debug("LsaQueryInformationPolicy Error: %ld\n", status);
+            } else {
+
+                /* Get name in useable format */
+                DomainName = AllocStrFromLSAStr(ppdiDomainInfo->Name);
+
+                /*
+                 * Check the Sid pointer, if it is null, the
+                 * workstation is either a stand-alone computer
+                 * or a member of a workgroup.
+                 */
+                if (ppdiDomainInfo->Sid) {
+
+                    /*
+                     * Member of a domain. Display it in debug mode.
+                     */
+                    debug("Member of Domain %s\n", DomainName);
+                } else {
+                    DomainName = NULL;
+                }
+            }
+        }
+
+        /*
+         * Clean up all the memory buffers created by the LSA and
+         * Net* APIs.
+         */
+        NetApiBufferFree(pwkiWorkstationInfo);
+        LsaFreeMemory((LPVOID) ppdiDomainInfo);
     } else
-	debug("NetWkstaGetInfo Error: %ld\n", netret);
+        debug("NetWkstaGetInfo Error: %ld\n", netret);
     return DomainName;
 }
 
 /* returns 0 on match, -1 if no match */
-static int 
+static int
 wcstrcmparray(const wchar_t * str, const char **array)
 {
     WCHAR wszGroup[GNLEN + 1];	// Unicode Group
 
     while (*array) {
-	MultiByteToWideChar(CP_ACP, 0, *array,
-	    strlen(*array) + 1, wszGroup, sizeof(wszGroup) / sizeof(wszGroup[0]));
-	debug("Windows group: %S, Squid group: %S\n", str, wszGroup);
-	if ((use_case_insensitive_compare ? _wcsicmp(str, wszGroup) : wcscmp(str, wszGroup)) == 0)
-	    return 0;
-	array++;
+        MultiByteToWideChar(CP_ACP, 0, *array,
+                            strlen(*array) + 1, wszGroup, sizeof(wszGroup) / sizeof(wszGroup[0]));
+        debug("Windows group: %S, Squid group: %S\n", str, wszGroup);
+        if ((use_case_insensitive_compare ? _wcsicmp(str, wszGroup) : wcscmp(str, wszGroup)) == 0)
+            return 0;
+        array++;
     }
     return -1;
 }
@@ -254,58 +254,58 @@ Valid_Local_Groups(char *UserName, const char **Groups)
     DWORD dwTotalCount = 0;
 
     if ((Domain_Separator = strchr(UserName, '/')) != NULL)
-	*Domain_Separator = '\\';
+        *Domain_Separator = '\\';
 
     debug("Valid_Local_Groups: checking group membership of '%s'.\n", UserName);
 
-/* Convert ANSI User Name and Group to Unicode */
+    /* Convert ANSI User Name and Group to Unicode */
 
     MultiByteToWideChar(CP_ACP, 0, UserName,
-	strlen(UserName) + 1, wszUserName, sizeof(wszUserName) / sizeof(wszUserName[0]));
+                        strlen(UserName) + 1, wszUserName, sizeof(wszUserName) / sizeof(wszUserName[0]));
 
     /*
-     * Call the NetUserGetLocalGroups function 
+     * Call the NetUserGetLocalGroups function
      * specifying information level 0.
-     * 
-     * The LG_INCLUDE_INDIRECT flag specifies that the 
-     * function should also return the names of the local 
+     *
+     * The LG_INCLUDE_INDIRECT flag specifies that the
+     * function should also return the names of the local
      * groups in which the user is indirectly a member.
      */
     nStatus = NetUserGetLocalGroups(
-	NULL,
-	wszUserName,
-	dwLevel,
-	dwFlags,
-	(LPBYTE *) & pBuf,
-	dwPrefMaxLen,
-	&dwEntriesRead,
-	&dwTotalEntries);
+                  NULL,
+                  wszUserName,
+                  dwLevel,
+                  dwFlags,
+                  (LPBYTE *) & pBuf,
+                  dwPrefMaxLen,
+                  &dwEntriesRead,
+                  &dwTotalEntries);
     /*
      * If the call succeeds,
      */
     if (nStatus == NERR_Success) {
-	if ((pTmpBuf = pBuf) != NULL) {
-	    for (i = 0; i < dwEntriesRead; i++) {
-		assert(pTmpBuf != NULL);
-		if (pTmpBuf == NULL) {
-		    result = 0;
-		    break;
-		}
-		if (wcstrcmparray(pTmpBuf->lgrui0_name, Groups) == 0) {
-		    result = 1;
-		    break;
-		}
-		pTmpBuf++;
-		dwTotalCount++;
-	    }
-	}
+        if ((pTmpBuf = pBuf) != NULL) {
+            for (i = 0; i < dwEntriesRead; i++) {
+                assert(pTmpBuf != NULL);
+                if (pTmpBuf == NULL) {
+                    result = 0;
+                    break;
+                }
+                if (wcstrcmparray(pTmpBuf->lgrui0_name, Groups) == 0) {
+                    result = 1;
+                    break;
+                }
+                pTmpBuf++;
+                dwTotalCount++;
+            }
+        }
     } else
-	result = 0;
-/*
- * Free the allocated memory.
- */
+        result = 0;
+    /*
+     * Free the allocated memory.
+     */
     if (pBuf != NULL)
-	NetApiBufferFree(pBuf);
+        NetApiBufferFree(pBuf);
     return result;
 }
 
@@ -342,132 +342,132 @@ Valid_Global_Groups(char *UserName, const char **Groups)
     strncpy(NTDomain, UserName, sizeof(NTDomain));
 
     for (j = 0; j < strlen(NTV_VALID_DOMAIN_SEPARATOR); j++) {
-	if ((domain_qualify = strchr(NTDomain, NTV_VALID_DOMAIN_SEPARATOR[j])) != NULL)
-	    break;
+        if ((domain_qualify = strchr(NTDomain, NTV_VALID_DOMAIN_SEPARATOR[j])) != NULL)
+            break;
     }
     if (domain_qualify == NULL) {
-	strcpy(User, NTDomain);
-	strcpy(NTDomain, DefaultDomain);
+        strcpy(User, NTDomain);
+        strcpy(NTDomain, DefaultDomain);
     } else {
-	strcpy(User, domain_qualify + 1);
-	domain_qualify[0] = '\0';
-	strlwr(NTDomain);
+        strcpy(User, domain_qualify + 1);
+        domain_qualify[0] = '\0';
+        strlwr(NTDomain);
     }
 
     debug("Valid_Global_Groups: checking group membership of '%s\\%s'.\n", NTDomain, User);
 
     /* Convert ANSI User Name and Group to Unicode */
 
     MultiByteToWideChar(CP_ACP, 0, User,
-	strlen(User) + 1, wszUserName,
-	sizeof(wszUserName) / sizeof(wszUserName[0]));
+                        strlen(User) + 1, wszUserName,
+                        sizeof(wszUserName) / sizeof(wszUserName[0]));
     MultiByteToWideChar(CP_ACP, 0, machinedomain,
-	strlen(machinedomain) + 1, wszLocalDomain, sizeof(wszLocalDomain) / sizeof(wszLocalDomain[0]));
+                        strlen(machinedomain) + 1, wszLocalDomain, sizeof(wszLocalDomain) / sizeof(wszLocalDomain[0]));
 
 
-/* Call the NetServerGetInfo function for local computer, specifying level 101. */
+    /* Call the NetServerGetInfo function for local computer, specifying level 101. */
     dwLevel = 101;
     nStatus = NetServerGetInfo(NULL, dwLevel, (LPBYTE *) & pSrvBuf);
 
     if (nStatus == NERR_Success) {
-	/* Check if we are running on a Domain Controller */
-	if ((pSrvBuf->sv101_type & SV_TYPE_DOMAIN_CTRL) ||
-	    (pSrvBuf->sv101_type & SV_TYPE_DOMAIN_BAKCTRL)) {
-	    LclDCptr = NULL;
-	    debug("Running on a DC.\n");
-	} else
-	    nStatus = (use_PDC_only ? NetGetDCName(NULL, wszLocalDomain, (LPBYTE *) & LclDCptr) : NetGetAnyDCName(NULL, wszLocalDomain, (LPBYTE *) & LclDCptr));
+        /* Check if we are running on a Domain Controller */
+        if ((pSrvBuf->sv101_type & SV_TYPE_DOMAIN_CTRL) ||
+                (pSrvBuf->sv101_type & SV_TYPE_DOMAIN_BAKCTRL)) {
+            LclDCptr = NULL;
+            debug("Running on a DC.\n");
+        } else
+            nStatus = (use_PDC_only ? NetGetDCName(NULL, wszLocalDomain, (LPBYTE *) & LclDCptr) : NetGetAnyDCName(NULL, wszLocalDomain, (LPBYTE *) & LclDCptr));
     } else {
-	fprintf(stderr, "%s NetServerGetInfo() failed.'\n", myname);
-	if (pSrvBuf != NULL)
-	    NetApiBufferFree(pSrvBuf);
-	return result;
+        fprintf(stderr, "%s NetServerGetInfo() failed.'\n", myname);
+        if (pSrvBuf != NULL)
+            NetApiBufferFree(pSrvBuf);
+        return result;
     }
 
     if (nStatus == NERR_Success) {
-	debug("Using '%S' as DC for '%S' local domain.\n", LclDCptr, wszLocalDomain);
-
-	if (strcmp(NTDomain, machinedomain) != 0) {
-	    MultiByteToWideChar(CP_ACP, 0, NTDomain,
-		strlen(NTDomain) + 1, wszUserDomain, sizeof(wszUserDomain) / sizeof(wszUserDomain[0]));
-	    nStatus = (use_PDC_only ? NetGetDCName(LclDCptr, wszUserDomain, (LPBYTE *) & UsrDCptr) : NetGetAnyDCName(LclDCptr, wszUserDomain, (LPBYTE *) & UsrDCptr));
-	    if (nStatus != NERR_Success) {
-		fprintf(stderr, "%s Can't find DC for user's domain '%s'\n", myname, NTDomain);
-		if (pSrvBuf != NULL)
-		    NetApiBufferFree(pSrvBuf);
-		if (LclDCptr != NULL)
-		    NetApiBufferFree((LPVOID) LclDCptr);
-		if (UsrDCptr != NULL)
-		    NetApiBufferFree((LPVOID) UsrDCptr);
-		return result;
-	    }
-	} else
-	    UsrDCptr = LclDCptr;
-
-	debug("Using '%S' as DC for '%s' user's domain.\n", UsrDCptr, NTDomain);
-	/*
-	 * Call the NetUserGetGroups function 
-	 * specifying information level 0.
-	 */
-	dwLevel = 0;
-	nStatus = NetUserGetGroups(UsrDCptr,
-	    wszUserName,
-	    dwLevel,
-	    (LPBYTE *) & pUsrBuf,
-	    dwPrefMaxLen,
-	    &dwEntriesRead,
-	    &dwTotalEntries);
-	/*
-	 * If the call succeeds,
-	 */
-	if (nStatus == NERR_Success) {
-	    if ((pTmpBuf = pUsrBuf) != NULL) {
-		for (i = 0; i < dwEntriesRead; i++) {
-		    assert(pTmpBuf != NULL);
-		    if (pTmpBuf == NULL) {
-			result = 0;
-			break;
-		    }
-		    if (wcstrcmparray(pTmpBuf->grui0_name, Groups) == 0) {
-			result = 1;
-			break;
-		    }
-		    pTmpBuf++;
-		    dwTotalCount++;
-		}
-	    }
-	} else {
-	    result = 0;
-	    fprintf(stderr, "%s NetUserGetGroups() failed.'\n", myname);
-	}
+        debug("Using '%S' as DC for '%S' local domain.\n", LclDCptr, wszLocalDomain);
+
+        if (strcmp(NTDomain, machinedomain) != 0) {
+            MultiByteToWideChar(CP_ACP, 0, NTDomain,
+                                strlen(NTDomain) + 1, wszUserDomain, sizeof(wszUserDomain) / sizeof(wszUserDomain[0]));
+            nStatus = (use_PDC_only ? NetGetDCName(LclDCptr, wszUserDomain, (LPBYTE *) & UsrDCptr) : NetGetAnyDCName(LclDCptr, wszUserDomain, (LPBYTE *) & UsrDCptr));
+            if (nStatus != NERR_Success) {
+                fprintf(stderr, "%s Can't find DC for user's domain '%s'\n", myname, NTDomain);
+                if (pSrvBuf != NULL)
+                    NetApiBufferFree(pSrvBuf);
+                if (LclDCptr != NULL)
+                    NetApiBufferFree((LPVOID) LclDCptr);
+                if (UsrDCptr != NULL)
+                    NetApiBufferFree((LPVOID) UsrDCptr);
+                return result;
+            }
+        } else
+            UsrDCptr = LclDCptr;
+
+        debug("Using '%S' as DC for '%s' user's domain.\n", UsrDCptr, NTDomain);
+        /*
+         * Call the NetUserGetGroups function
+         * specifying information level 0.
+         */
+        dwLevel = 0;
+        nStatus = NetUserGetGroups(UsrDCptr,
+                                   wszUserName,
+                                   dwLevel,
+                                   (LPBYTE *) & pUsrBuf,
+                                   dwPrefMaxLen,
+                                   &dwEntriesRead,
+                                   &dwTotalEntries);
+        /*
+         * If the call succeeds,
+         */
+        if (nStatus == NERR_Success) {
+            if ((pTmpBuf = pUsrBuf) != NULL) {
+                for (i = 0; i < dwEntriesRead; i++) {
+                    assert(pTmpBuf != NULL);
+                    if (pTmpBuf == NULL) {
+                        result = 0;
+                        break;
+                    }
+                    if (wcstrcmparray(pTmpBuf->grui0_name, Groups) == 0) {
+                        result = 1;
+                        break;
+                    }
+                    pTmpBuf++;
+                    dwTotalCount++;
+                }
+            }
+        } else {
+            result = 0;
+            fprintf(stderr, "%s NetUserGetGroups() failed.'\n", myname);
+        }
     } else {
-	fprintf(stderr, "%s Can't find DC for local domain '%s'\n", myname, machinedomain);
+        fprintf(stderr, "%s Can't find DC for local domain '%s'\n", myname, machinedomain);
     }
     /*
      * Free the allocated memory.
      */
     if (pSrvBuf != NULL)
-	NetApiBufferFree(pSrvBuf);
+        NetApiBufferFree(pSrvBuf);
     if (pUsrBuf != NULL)
-	NetApiBufferFree(pUsrBuf);
+        NetApiBufferFree(pUsrBuf);
     if ((UsrDCptr != NULL) && (UsrDCptr != LclDCptr))
-	NetApiBufferFree((LPVOID) UsrDCptr);
+        NetApiBufferFree((LPVOID) UsrDCptr);
     if (LclDCptr != NULL)
-	NetApiBufferFree((LPVOID) LclDCptr);
+        NetApiBufferFree((LPVOID) LclDCptr);
     return result;
 }
 
 static void
 usage(char *program)
 {
     fprintf(stderr, "Usage: %s [-D domain][-G][-P][-c][-d][-h]\n"
-	" -D    default user Domain\n"
-	" -G    enable Domain Global group mode\n"
-	" -P    use ONLY PDCs for group validation\n"
-	" -c    use case insensitive compare\n"
-	" -d    enable debugging\n"
-	" -h    this message\n",
-	program);
+            " -D    default user Domain\n"
+            " -G    enable Domain Global group mode\n"
+            " -P    use ONLY PDCs for group validation\n"
+            " -c    use case insensitive compare\n"
+            " -d    enable debugging\n"
+            " -h    this message\n",
+            program);
 }
 
 void
@@ -477,35 +477,35 @@ process_options(int argc, char *argv[])
 
     opterr = 0;
     while (-1 != (opt = getopt(argc, argv, "D:GPcdh"))) {
-	switch (opt) {
-	case 'D':
-	    DefaultDomain = xstrndup(optarg, DNLEN + 1);
-	    strlwr(DefaultDomain);
-	    break;
-	case 'G':
-	    use_global = 1;
-	    break;
-	case 'P':
-	    use_PDC_only = 1;
-	    break;
-	case 'c':
-	    use_case_insensitive_compare = 1;
-	    break;
-	case 'd':
-	    debug_enabled = 1;
-	    break;
-	case 'h':
-	    usage(argv[0]);
-	    exit(0);
-	case '?':
-	    opt = optopt;
-	    /* fall thru to default */
-	default:
-	    fprintf(stderr, "%s Unknown option: -%c. Exiting\n", myname, opt);
-	    usage(argv[0]);
-	    exit(1);
-	    break;		/* not reached */
-	}
+        switch (opt) {
+        case 'D':
+            DefaultDomain = xstrndup(optarg, DNLEN + 1);
+            strlwr(DefaultDomain);
+            break;
+        case 'G':
+            use_global = 1;
+            break;
+        case 'P':
+            use_PDC_only = 1;
+            break;
+        case 'c':
+            use_case_insensitive_compare = 1;
+            break;
+        case 'd':
+            debug_enabled = 1;
+            break;
+        case 'h':
+            usage(argv[0]);
+            exit(0);
+        case '?':
+            opt = optopt;
+            /* fall thru to default */
+        default:
+            fprintf(stderr, "%s Unknown option: -%c. Exiting\n", myname, opt);
+            usage(argv[0]);
+            exit(1);
+            break;		/* not reached */
+        }
     }
     return;
 }
@@ -523,11 +523,11 @@ main(int argc, char *argv[])
     int n;
 
     if (argc > 0) {		/* should always be true */
-	myname = strrchr(argv[0], '/');
-	if (myname == NULL)
-	    myname = argv[0];
+        myname = strrchr(argv[0], '/');
+        if (myname == NULL)
+            myname = argv[0];
     } else {
-	myname = "(unknown)";
+        myname = "(unknown)";
     }
     mypid = getpid();
 
@@ -538,66 +538,66 @@ main(int argc, char *argv[])
     process_options(argc, argv);
 
     if (use_global) {
-	if ((machinedomain = GetDomainName()) == NULL) {
-	    fprintf(stderr, "%s Can't read machine domain\n", myname);
-	    exit(1);
-	}
-	strlwr(machinedomain);
-	if (!DefaultDomain)
-	    DefaultDomain = xstrdup(machinedomain);
+        if ((machinedomain = GetDomainName()) == NULL) {
+            fprintf(stderr, "%s Can't read machine domain\n", myname);
+            exit(1);
+        }
+        strlwr(machinedomain);
+        if (!DefaultDomain)
+            DefaultDomain = xstrdup(machinedomain);
     }
     debug("External ACL win32 group helper build " __DATE__ ", " __TIME__
-	" starting up...\n");
+          " starting up...\n");
     if (use_global)
-	debug("Domain Global group mode enabled using '%s' as default domain.\n", DefaultDomain);
+        debug("Domain Global group mode enabled using '%s' as default domain.\n", DefaultDomain);
     if (use_case_insensitive_compare)
-	debug("Warning: running in case insensitive mode !!!\n");
+        debug("Warning: running in case insensitive mode !!!\n");
     if (use_PDC_only)
-	debug("Warning: using only PDCs for group validation !!!\n");
+        debug("Warning: using only PDCs for group validation !!!\n");
 
     /* Main Loop */
     while (fgets(buf, sizeof(buf), stdin)) {
-	if (NULL == strchr(buf, '\n')) {
-	    /* too large message received.. skip and deny */
-	    fprintf(stderr, "%s: ERROR: Too large: %s\n", argv[0], buf);
-	    while (fgets(buf, sizeof(buf), stdin)) {
-		fprintf(stderr, "%s: ERROR: Too large..: %s\n", argv[0], buf);
-		if (strchr(buf, '\n') != NULL)
-		    break;
-	    }
-	    goto error;
-	}
-	if ((p = strchr(buf, '\n')) != NULL)
-	    *p = '\0';		/* strip \n */
-	if ((p = strchr(buf, '\r')) != NULL)
-	    *p = '\0';		/* strip \r */
-
-	debug("Got '%s' from Squid (length: %d).\n", buf, strlen(buf));
-
-	if (buf[0] == '\0') {
-	    fprintf(stderr, "Invalid Request\n");
-	    goto error;
-	}
-	username = strtok(buf, " ");
-	for (n = 0; (group = strtok(NULL, " ")) != NULL; n++) {
-	    rfc1738_unescape(group);
-	    groups[n] = group;
-	}
-	groups[n] = NULL;
-
-	if (NULL == username) {
-	    fprintf(stderr, "Invalid Request\n");
-	    goto error;
-	}
-	rfc1738_unescape(username);
-
-	if ((use_global ? Valid_Global_Groups(username, groups) : Valid_Local_Groups(username, groups))) {
-	    printf("OK\n");
-	} else {
-	  error:
-	    printf("ERR\n");
-	}
-	err = 0;
+        if (NULL == strchr(buf, '\n')) {
+            /* too large message received.. skip and deny */
+            fprintf(stderr, "%s: ERROR: Too large: %s\n", argv[0], buf);
+            while (fgets(buf, sizeof(buf), stdin)) {
+                fprintf(stderr, "%s: ERROR: Too large..: %s\n", argv[0], buf);
+                if (strchr(buf, '\n') != NULL)
+                    break;
+            }
+            goto error;
+        }
+        if ((p = strchr(buf, '\n')) != NULL)
+            *p = '\0';		/* strip \n */
+        if ((p = strchr(buf, '\r')) != NULL)
+            *p = '\0';		/* strip \r */
+
+        debug("Got '%s' from Squid (length: %d).\n", buf, strlen(buf));
+
+        if (buf[0] == '\0') {
+            fprintf(stderr, "Invalid Request\n");
+            goto error;
+        }
+        username = strtok(buf, " ");
+        for (n = 0; (group = strtok(NULL, " ")) != NULL; n++) {
+            rfc1738_unescape(group);
+            groups[n] = group;
+        }
+        groups[n] = NULL;
+
+        if (NULL == username) {
+            fprintf(stderr, "Invalid Request\n");
+            goto error;
+        }
+        rfc1738_unescape(username);
+
+        if ((use_global ? Valid_Global_Groups(username, groups) : Valid_Local_Groups(username, groups))) {
+            printf("OK\n");
+        } else {
+error:
+            printf("ERR\n");
+        }
+        err = 0;
     }
     return 0;
 }
@@ -9,7 +9,7 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- 
+
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
@@ -55,13 +55,13 @@ debug(char *format,...)
 #ifdef DEBUG
 #ifdef _SQUID_MSWIN_
     if (debug_enabled) {
-	va_list args;
+        va_list args;
 
-	va_start(args, format);
-	fprintf(stderr, "%s[%d]: ", myname, mypid);
-	vfprintf(stderr, format, args);
-	fprintf(stderr, "\n");
-	va_end(args);
+        va_start(args, format);
+        fprintf(stderr, "%s[%d]: ", myname, mypid);
+        vfprintf(stderr, format, args);
+        fprintf(stderr, "\n");
+        va_end(args);
     }
 #endif /* _SQUID_MSWIN_ */
 #endif /* DEBUG */
@@ -7,12 +7,12 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
@@ -54,8 +54,8 @@ static void init_db(void)
 {
     db = dbopen(db_path, O_CREAT | O_RDWR, 0666, DB_BTREE, NULL);
     if (!db) {
-	fprintf(stderr, "%s: Failed to open session db '%s'\n", program_name, db_path);
-	exit(1);
+        fprintf(stderr, "%s: Failed to open session db '%s'\n", program_name, db_path);
+        exit(1);
     }
 }
 
@@ -72,15 +72,15 @@ static int session_active(const char *details)
     key.data = (void *)details;
     key.size = strlen(details);
     if (db->get(db, &key, &data, 0) == 0) {
-	time_t timestamp;
-	if (data.size != sizeof(timestamp)) {
-	    fprintf(stderr, "%s: CORRUPTED DATABASE (%s)\n", program_name, details);
-	    db->del(db, &key, 0);
-	    return 0;
-	}
-	memcpy(&timestamp, data.data, sizeof(timestamp));
-	if (timestamp + session_ttl >= time(NULL))
-	    return 1;
+        time_t timestamp;
+        if (data.size != sizeof(timestamp)) {
+            fprintf(stderr, "%s: CORRUPTED DATABASE (%s)\n", program_name, details);
+            db->del(db, &key, 0);
+            return 0;
+        }
+        memcpy(&timestamp, data.data, sizeof(timestamp));
+        if (timestamp + session_ttl >= time(NULL))
+            return 1;
     }
     return 0;
 }
@@ -120,58 +120,58 @@ int main(int argc, char **argv)
     program_name = argv[0];
 
     while ((opt = getopt(argc, argv, "t:b:a?")) != -1) {
-	switch(opt) {
-	case 't':
-	    session_ttl = strtol(optarg, NULL, 0);
-	    break;
-	case 'b':
-	    db_path = optarg;
-	    break;
-	case 'a':
-	    default_action = 0;
-	    break;
-	case '?':
-	    usage();
-	    exit(0);
-	    break;
-	}
+        switch (opt) {
+        case 't':
+            session_ttl = strtol(optarg, NULL, 0);
+            break;
+        case 'b':
+            db_path = optarg;
+            break;
+        case 'a':
+            default_action = 0;
+            break;
+        case '?':
+            usage();
+            exit(0);
+            break;
+        }
     }
 
     setbuf(stdout, NULL);
 
     init_db();
 
     while (fgets(request, sizeof(request), stdin)) {
-	const char *index, *detail;
-	char *lastdetail;
-	int action = 0;
-	index = strtok(request, " \n");
-	detail = strtok(NULL, "\n");
-	lastdetail = strrchr(detail, ' ');
-	if (lastdetail) {
-	    if (strcmp(lastdetail, " LOGIN") == 0) {
-		*lastdetail++ = '\0';
-		action = 1;
-	    } else if (strcmp(lastdetail, " LOGOUT") == 0) {
-		action = -1;
-		*lastdetail++ = '\0';
-	    }
-	}
-	if (action == -1) {
-	    session_logout(detail);
-	    printf("%s OK message=\"Bye\"\n", index);
-	} else if (action == 1) {
-	    session_login(detail);
-	    printf("%s OK message=\"Welcome\"\n", index);
-	} else if (session_active(detail)) {
-	    session_login(detail);
-	    printf("%s OK\n", index);
-	} else if (default_action == 1) {
-	    session_login(detail);
-	    printf("%s ERR message=\"Welcome\"\n", index);
-	} else {
-	    printf("%s ERR message=\"No session available\"\n", index);
-	}
+        const char *index, *detail;
+        char *lastdetail;
+        int action = 0;
+        index = strtok(request, " \n");
+        detail = strtok(NULL, "\n");
+        lastdetail = strrchr(detail, ' ');
+        if (lastdetail) {
+            if (strcmp(lastdetail, " LOGIN") == 0) {
+                *lastdetail++ = '\0';
+                action = 1;
+            } else if (strcmp(lastdetail, " LOGOUT") == 0) {
+                action = -1;
+                *lastdetail++ = '\0';
+            }
+        }
+        if (action == -1) {
+            session_logout(detail);
+            printf("%s OK message=\"Bye\"\n", index);
+        } else if (action == 1) {
+            session_login(detail);
+            printf("%s OK message=\"Welcome\"\n", index);
+        } else if (session_active(detail)) {
+            session_login(detail);
+            printf("%s OK\n", index);
+        } else if (default_action == 1) {
+            session_login(detail);
+            printf("%s ERR message=\"Welcome\"\n", index);
+        } else {
+            printf("%s ERR message=\"No session available\"\n", index);
+        }
     }
     shutdown_db();
     return 0;
@@ -3,9 +3,9 @@
  *
  * This is a helper for the external ACL interface for Squid Cache
  * Copyright (C) 2002 Rodrigo Albani de Campos (rodrigo@geekbunker.org)
- * 
+ *
  * It reads STDIN looking for a username that matches a specified group
- * Returns `OK' if the user belongs to the group or `ERR' otherwise, as 
+ * Returns `OK' if the user belongs to the group or `ERR' otherwise, as
  * described on http://devel.squid-cache.org/external_acl/config.html
  * To compile this program, use:
  *
@@ -65,9 +65,9 @@
 
 #define BUFSIZE 8192		/* the stdin buffer size */
 #define MAX_GROUP 10		/* maximum number of groups specified 
-				 * on the command line */
+* on the command line */
 
-/* 
+/*
  * Verify if users primary group matches groupname
  * Returns 0 if user is not on the group
  * Returns 1 otherwise
@@ -79,15 +79,15 @@ validate_user_pw(char *username, char *groupname)
     struct group *g;
 
     if ((p = getpwnam(username)) == NULL) {
-	/* Returns an error if user does not exist in the /etc/passwd */
-	fprintf(stderr, "helper: User does not exist '%s'\n", username);
-	return 0;
+        /* Returns an error if user does not exist in the /etc/passwd */
+        fprintf(stderr, "helper: User does not exist '%s'\n", username);
+        return 0;
     } else {
-	/* Verify if the this is the primary user group */
-	if ((g = getgrgid(p->pw_gid)) != NULL) {
-	    if ((strcmp(groupname, g->gr_name)) == 0)
-		return 1;
-	}
+        /* Verify if the this is the primary user group */
+        if ((g = getgrgid(p->pw_gid)) != NULL) {
+            if ((strcmp(groupname, g->gr_name)) == 0)
+                return 1;
+        }
     }
 
     return 0;
@@ -96,22 +96,22 @@ validate_user_pw(char *username, char *groupname)
 static int
 validate_user_gr(char *username, char *groupname)
 {
-    /* 
+    /*
      * Verify if the user belongs to groupname as listed in the
      * /etc/group file
      */
     struct group *g;
 
     if ((g = getgrnam(groupname)) == NULL) {
-	fprintf(stderr, "helper: Group does not exist '%s'\n",
-	    groupname);
-	return 0;
+        fprintf(stderr, "helper: Group does not exist '%s'\n",
+                groupname);
+        return 0;
     } else {
-	while (*(g->gr_mem) != NULL) {
-	    if (strcmp(*((g->gr_mem)++), username) == 0) {
-		return 1;
-	    }
-	}
+        while (*(g->gr_mem) != NULL) {
+            if (strcmp(*((g->gr_mem)++), username) == 0) {
+                return 1;
+            }
+        }
     }
     return 0;
 }
@@ -120,16 +120,16 @@ static void
 usage(char *program)
 {
     fprintf(stderr, "Usage: %s -g group1 [-g group2 ...] [-p] [-s]\n\n",
-	program);
+            program);
     fprintf(stderr, "-g group\n");
     fprintf(stderr,
-	"			The group name or id that the user must belong in order to\n");
+            "			The group name or id that the user must belong in order to\n");
     fprintf(stderr,
-	"			be allowed to authenticate.\n");
+            "			be allowed to authenticate.\n");
     fprintf(stderr,
-	"-p			Verify primary user group as well\n");
+            "-p			Verify primary user group as well\n");
     fprintf(stderr,
-	"-s			Strip NT domain from usernames\n");
+            "-s			Strip NT domain from usernames\n");
 }
 
 
@@ -146,89 +146,89 @@ main(int argc, char *argv[])
 
     /* get user options */
     while ((ch = getopt(argc, argv, "spg:")) != -1) {
-  	switch (ch) {
-	case 's':
-	    strip_dm = 1;
-	    break;
-	case 'p':
-	    check_pw = 1;
-	    break;
-	case 'g':
-	    grents[i] = calloc(strlen(optarg) + 1, sizeof(char));
-	    strcpy(grents[i], optarg);
-	    if (i < MAX_GROUP) {
-		i++;
-	    } else {
-		fprintf(stderr,
-		    "Exceeded maximum number of allowed groups (%i)\n", i);
-		exit(1);
-	    }
-	    break;
-	case '?':
-	    if (xisprint(optopt)) {
-
-		fprintf(stderr, "Unknown option '-%c'.\n", optopt);
-	    } else {
-		fprintf(stderr, "Unknown option character `\\x%x'.\n", optopt);
-	    }
-
-	default:
-	    usage(argv[0]);
-	    exit(1);
-	}
+        switch (ch) {
+        case 's':
+            strip_dm = 1;
+            break;
+        case 'p':
+            check_pw = 1;
+            break;
+        case 'g':
+            grents[i] = calloc(strlen(optarg) + 1, sizeof(char));
+            strcpy(grents[i], optarg);
+            if (i < MAX_GROUP) {
+                i++;
+            } else {
+                fprintf(stderr,
+                        "Exceeded maximum number of allowed groups (%i)\n", i);
+                exit(1);
+            }
+            break;
+        case '?':
+            if (xisprint(optopt)) {
+
+                fprintf(stderr, "Unknown option '-%c'.\n", optopt);
+            } else {
+                fprintf(stderr, "Unknown option character `\\x%x'.\n", optopt);
+            }
+
+        default:
+            usage(argv[0]);
+            exit(1);
+        }
     }
     if (optind < argc) {
-	fprintf(stderr, "Unknown option '%s'\n", argv[optind]);
-	usage(argv[0]);
-	exit(1);
+        fprintf(stderr, "Unknown option '%s'\n", argv[optind]);
+        usage(argv[0]);
+        exit(1);
     }
     while (fgets(buf, sizeof(buf), stdin)) {
-	j = 0;
-	if ((p = strchr(buf, '\n')) == NULL) {
-	    /* too large message received.. skip and deny */
-	    fprintf(stderr, "%s: ERROR: Too large: %s\n", argv[0], buf);
-	    while (fgets(buf, sizeof(buf), stdin)) {
-		fprintf(stderr, "%s: ERROR: Too large..: %s\n", argv[0], buf);
-		if (strchr(buf, '\n') != NULL)
-		    break;
-	    }
-	    goto error;
-	}
-	*p = '\0';
-	if ((p = strtok(buf, " ")) == NULL) {
-	    goto error;
-	} else {
-	    user = p;
-	    rfc1738_unescape(user);
-	    if (user && strip_dm) {
-		suser = strchr(user, '\\');
-		if (!suser) suser = strchr(user, '/');
-		if (suser && suser[1]) user = suser + 1;
-	    }
-	    /* check groups supplied by Squid */
-	    while ((p = strtok(NULL, " ")) != NULL) {
-		rfc1738_unescape(p);
-		if (check_pw == 1)
-		    j += validate_user_pw(user, p);
-
-		j += validate_user_gr(user, p);
-	    }
-	}
-
-	/* check groups supplied on the command line */
-	for (i = 0; grents[i] != NULL; i++) {
-	    if (check_pw == 1) {
-		j += validate_user_pw(user, grents[i]);
-	    }
-	    j += validate_user_gr(user, grents[i]);
-	}
-
-	if (j > 0) {
-	    printf("OK\n");
-	} else {
+        j = 0;
+        if ((p = strchr(buf, '\n')) == NULL) {
+            /* too large message received.. skip and deny */
+            fprintf(stderr, "%s: ERROR: Too large: %s\n", argv[0], buf);
+            while (fgets(buf, sizeof(buf), stdin)) {
+                fprintf(stderr, "%s: ERROR: Too large..: %s\n", argv[0], buf);
+                if (strchr(buf, '\n') != NULL)
+                    break;
+            }
+            goto error;
+        }
+        *p = '\0';
+        if ((p = strtok(buf, " ")) == NULL) {
+            goto error;
+        } else {
+            user = p;
+            rfc1738_unescape(user);
+            if (user && strip_dm) {
+                suser = strchr(user, '\\');
+                if (!suser) suser = strchr(user, '/');
+                if (suser && suser[1]) user = suser + 1;
+            }
+            /* check groups supplied by Squid */
+            while ((p = strtok(NULL, " ")) != NULL) {
+                rfc1738_unescape(p);
+                if (check_pw == 1)
+                    j += validate_user_pw(user, p);
+
+                j += validate_user_gr(user, p);
+            }
+        }
+
+        /* check groups supplied on the command line */
+        for (i = 0; grents[i] != NULL; i++) {
+            if (check_pw == 1) {
+                j += validate_user_pw(user, grents[i]);
+            }
+            j += validate_user_gr(user, grents[i]);
+        }
+
+        if (j > 0) {
+            printf("OK\n");
+        } else {
 error:
-	    printf("ERR\n");
-	}
+            printf("ERR\n");
+        }
     }
     return 0;
 }
@@ -8,7 +8,7 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- 
+
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
@@ -41,13 +41,13 @@ void hex_dump(void *data, int size)
         char addrstr[10] = {0};
         char hexstr[ 16*3 + 5] = {0};
         char charstr[16*1 + 5] = {0};
-        for(n=1;n<=size;n++) {
+        for (n=1;n<=size;n++) {
             if (n%16 == 1) {
                 /* store address for this line */
                 snprintf(addrstr, sizeof(addrstr), "%.4x",
-                   ((unsigned int)p-(unsigned int)data) );
+                         ((unsigned int)p-(unsigned int)data) );
             }
-            
+
             c = *p;
             if (xisalnum(c) == 0) {
                 c = '.';
@@ -61,12 +61,12 @@ void hex_dump(void *data, int size)
             snprintf(bytestr, sizeof(bytestr), "%c", c);
             strncat(charstr, bytestr, sizeof(charstr)-strlen(charstr)-1);
 
-            if(n%16 == 0) { 
+            if (n%16 == 0) {
                 /* line completed */
                 fprintf(stderr, "[%4.4s]   %-50.50s  %s\n", addrstr, hexstr, charstr);
                 hexstr[0] = 0;
                 charstr[0] = 0;
-            } else if(n%8 == 0) {
+            } else if (n%8 == 0) {
                 /* half line: add whitespaces */
                 strncat(hexstr, "  ", sizeof(hexstr)-strlen(hexstr)-1);
                 strncat(charstr, " ", sizeof(charstr)-strlen(charstr)-1);
@@ -9,7 +9,7 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- 
+
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
@@ -60,28 +60,28 @@ static char *__foo;
 #endif /* DEBUG */
 #else /* __GNUC__ */
 static void
-debug(char *format,...) 
+debug(char *format,...)
 {
 #ifdef DEBUG
 #ifdef _SQUID_MSWIN_
 #if FAIL_DEBUG
     if (debug_enabled || fail_debug_enabled) {
 #else
-    if (debug_enabled) {
+        if (debug_enabled) {
 #endif
-	va_list args;
+            va_list args;
 
-	va_start(args,format);
-	fprintf(stderr, "negotiate-auth[%d]: ",getpid());
-	vfprintf(stderr, format, args);
-	va_end(args);
+            va_start(args,format);
+            fprintf(stderr, "negotiate-auth[%d]: ",getpid());
+            vfprintf(stderr, format, args);
+            va_end(args);
 #if FAIL_DEBUG
-        fail_debug_enabled = 0;
+            fail_debug_enabled = 0;
 #endif
-    }
+        }
 #endif /* _SQUID_MSWIN_ */
 #endif /* DEBUG */
-}
+    }
 #endif /* __GNUC__ */
 
 
@@ -59,8 +59,8 @@ uc(char *string)
 {
     char *p = string, c;
     while ((c = *p)) {
-	*p = xtoupper(c);
-	p++;
+        *p = xtoupper(c);
+        p++;
     }
 }
 
@@ -70,8 +70,8 @@ lc(char *string)
 {
     char *p = string, c;
     while ((c = *p)) {
-	*p = xtolower(c);
-	p++;
+        *p = xtolower(c);
+        p++;
     }
 }
 
@@ -95,11 +95,11 @@ void
 usage()
 {
     fprintf(stderr,
-	"Usage: %s [-d] [-v] [-h]\n"
-	" -d  enable debugging.\n"
-        " -v  enable verbose Negotiate packet debugging.\n"
-	" -h  this message\n\n",
-	my_program_name);
+            "Usage: %s [-d] [-v] [-h]\n"
+            " -d  enable debugging.\n"
+            " -v  enable verbose Negotiate packet debugging.\n"
+            " -h  this message\n\n",
+            my_program_name);
 }
 
 
@@ -110,28 +110,28 @@ process_options(int argc, char *argv[])
 
     opterr =0;
     while (-1 != (opt = getopt(argc, argv, "hdv"))) {
-	switch (opt) {
-	case 'd':
-	    debug_enabled = 1;
-	    break;
-	case 'v':
-	    debug_enabled = 1;
-	    Negotiate_packet_debug_enabled = 1;
-	    break;
-	case 'h':
-	    usage();
-	    exit(0);
-	case '?':
-	    opt = optopt;
-	    /* fall thru to default */
-	default:
-	    fprintf(stderr, "unknown option: -%c. Exiting\n", opt);
-	    usage();
-	    had_error = 1;
-	}
+        switch (opt) {
+        case 'd':
+            debug_enabled = 1;
+            break;
+        case 'v':
+            debug_enabled = 1;
+            Negotiate_packet_debug_enabled = 1;
+            break;
+        case 'h':
+            usage();
+            exit(0);
+        case '?':
+            opt = optopt;
+            /* fall thru to default */
+        default:
+            fprintf(stderr, "unknown option: -%c. Exiting\n", opt);
+            usage();
+            had_error = 1;
+        }
     }
     if (had_error)
-	exit(1);
+        exit(1);
 }
 
 int
@@ -147,21 +147,21 @@ manage_request()
     BOOL Done = FALSE;
 
 try_again:
-    if (fgets(buf, BUFFER_SIZE, stdin) == NULL) 
+    if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
         return 0;
 
     c = memchr(buf, '\n', BUFFER_SIZE);	/* safer against overrun than strchr */
     if (c) {
-	if (oversized) {
-	    helperfail("illegal request received");
-	    fprintf(stderr, "Illegal request received: '%s'\n", buf);
-	    return 1;
-	}
-	*c = '\0';
+        if (oversized) {
+            helperfail("illegal request received");
+            fprintf(stderr, "Illegal request received: '%s'\n", buf);
+            return 1;
+        }
+        *c = '\0';
     } else {
-	fprintf(stderr, "No newline in '%s'\n", buf);
-	oversized = 1;
-	goto try_again;
+        fprintf(stderr, "No newline in '%s'\n", buf);
+        oversized = 1;
+        goto try_again;
     }
 
     if ((strlen(buf) > 3) && Negotiate_packet_debug_enabled) {
@@ -173,36 +173,36 @@ manage_request()
         debug("Got '%s' from Squid\n", buf);
 
     if (memcmp(buf, "YR ", 3) == 0) {	/* refresh-request */
-	/* figure out what we got */
+        /* figure out what we got */
         decoded = base64_decode(buf + 3);
-	/*  Note: we don't need to manage memory at this point, since
-	 *  base64_decode returns a pointer to static storage.
-	 */
-	if (!decoded) {		/* decoding failure, return error */
-	    SEND("NA * Packet format error, couldn't base64-decode");
-	    return 1;
-	}
-	/* Obtain server blob against SSPI */
+        /*  Note: we don't need to manage memory at this point, since
+         *  base64_decode returns a pointer to static storage.
+         */
+        if (!decoded) {		/* decoding failure, return error */
+            SEND("NA * Packet format error, couldn't base64-decode");
+            return 1;
+        }
+        /* Obtain server blob against SSPI */
         plen = (strlen(buf) - 3) * 3 / 4;		/* we only need it here. Optimization */
         c = (char *) SSP_MakeNegotiateBlob(decoded, plen, &Done, &status, cred);
 
         if (status == SSP_OK) {
             if (Done) {
-	        lc(cred);		/* let's lowercase them for our convenience */
+                lc(cred);		/* let's lowercase them for our convenience */
                 have_serverblob = 0;
                 Done = FALSE;
                 if (Negotiate_packet_debug_enabled) {
                     printf("AF %s %s\n",c,cred);
                     decoded = base64_decode(c);
-	            debug("sending 'AF' %s to squid with data:\n", cred);
+                    debug("sending 'AF' %s to squid with data:\n", cred);
                     hex_dump(decoded, (strlen(c) * 3) / 4);
                 } else
                     SEND3("AF %s %s", c, cred);
             } else {
                 if (Negotiate_packet_debug_enabled) {
                     printf("TT %s\n",c);
                     decoded = base64_decode(c);
-	            debug("sending 'TT' to squid with data:\n");
+                    debug("sending 'TT' to squid with data:\n");
                     hex_dump(decoded, (strlen(c) * 3) / 4);
                 } else {
                     SEND2("TT %s", c);
@@ -211,33 +211,33 @@ manage_request()
             }
         } else
             helperfail("can't obtain server blob");
-	return 1;
+        return 1;
     }
 
     if (memcmp(buf, "KK ", 3) == 0) {	/* authenticate-request */
         if (!have_serverblob) {
-	    helperfail("invalid server blob");
-	    return 1;
+            helperfail("invalid server blob");
+            return 1;
+        }
+        /* figure out what we got */
+        decoded = base64_decode(buf + 3);
+        /*  Note: we don't need to manage memory at this point, since
+         *  base64_decode returns a pointer to static storage.
+         */
+        if (!decoded) {		/* decoding failure, return error */
+            SEND("NA * Packet format error, couldn't base64-decode");
+            return 1;
         }
-	/* figure out what we got */
-	decoded = base64_decode(buf + 3);
-	/*  Note: we don't need to manage memory at this point, since
-	 *  base64_decode returns a pointer to static storage.
-	 */
-	if (!decoded) {		/* decoding failure, return error */
-	    SEND("NA * Packet format error, couldn't base64-decode");
-	    return 1;
-	}
 
         /* check against SSPI */
-	plen = (strlen(buf) - 3) * 3 / 4;		/* we only need it here. Optimization */
+        plen = (strlen(buf) - 3) * 3 / 4;		/* we only need it here. Optimization */
         c = (char *) SSP_ValidateNegotiateCredentials(decoded, plen, &Done, &status, cred);
-        
+
         if (status == SSP_ERROR) {
 #if FAIL_DEBUG
             fail_debug_enabled = 1;
 #endif
-            FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | 
+            FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |
                           FORMAT_MESSAGE_IGNORE_INSERTS,
                           NULL,
                           GetLastError(),
@@ -249,43 +249,43 @@ manage_request()
                 ErrorMessage[strlen(ErrorMessage) - 1] = '\0';
             if (ErrorMessage[strlen(ErrorMessage) - 1] == '\r')
                 ErrorMessage[strlen(ErrorMessage) - 1] = '\0';
-	    SEND2("NA * %s", ErrorMessage);
+            SEND2("NA * %s", ErrorMessage);
             LocalFree(ErrorMessage);
-	    return 1;
-	}
+            return 1;
+        }
 
         if (Done) {
-	    lc(cred);		/* let's lowercase them for our convenience */
+            lc(cred);		/* let's lowercase them for our convenience */
             have_serverblob = 0;
             Done = FALSE;
             if (Negotiate_packet_debug_enabled) {
                 printf("AF %s %s\n",c,cred);
                 decoded = base64_decode(c);
-	        debug("sending 'AF' %s to squid with data:\n", cred);
+                debug("sending 'AF' %s to squid with data:\n", cred);
                 hex_dump(decoded, (strlen(c) * 3) / 4);
             } else {
                 SEND3("AF %s %s", c, cred);
             }
-	    return 1;
+            return 1;
         } else {
             if (Negotiate_packet_debug_enabled) {
                 printf("TT %s\n",c);
                 decoded = base64_decode(c);
-	        debug("sending 'TT' to squid with data:\n");
+                debug("sending 'TT' to squid with data:\n");
                 hex_dump(decoded, (strlen(c) * 3) / 4);
             } else
-               	SEND2("TT %s", c);
-	    return 1;
+                SEND2("TT %s", c);
+            return 1;
         }
 
     } else {	/* not an auth-request */
-	helperfail("illegal request received");
-	fprintf(stderr, "Illegal request received: '%s'\n", buf);
-	return 1;
+        helperfail("illegal request received");
+        fprintf(stderr, "Illegal request received: '%s'\n", buf);
+        return 1;
     }
     helperfail("detected protocol error");
     return 1;
-/********* END ********/
+    /********* END ********/
 }
 
 int
@@ -296,10 +296,10 @@ main(int argc, char *argv[])
     process_options(argc, argv);
 
     debug("%s build " __DATE__ ", " __TIME__ " starting up...\n", my_program_name);
-    
+
     if (LoadSecurityDll(SSP_NTLM, NEGOTIATE_PACKAGE_NAME) == NULL) {
-	fprintf(stderr, "FATAL, can't initialize SSPI, exiting.\n");
-	exit(1);
+        fprintf(stderr, "FATAL, can't initialize SSPI, exiting.\n");
+        exit(1);
     }
     debug("SSPI initialized OK\n");
 
@@ -310,7 +310,7 @@ main(int argc, char *argv[])
     setbuf(stderr, NULL);
 
     while (manage_request()) {
-	/* everything is done within manage_request */
+        /* everything is done within manage_request */
     }
     exit(0);
 }
@@ -22,10 +22,10 @@ ska_base64_init(void)
     int i;
 
     for (i = 0; i < BASE64_VALUE_SZ; i++)
-	base64_value[i] = -1;
+        base64_value[i] = -1;
 
     for (i = 0; i < 64; i++)
-	base64_value[(int) base64_code[i]] = i;
+        base64_value[(int) base64_code[i]] = i;
     base64_value['='] = 0;
 
     base64_initialized = 1;
@@ -37,30 +37,30 @@ void ska_base64_decode(char* result, const char *data, int result_size)
     int c;
     long val;
     if (!data)
-	return;
+        return;
     if (!base64_initialized)
-	ska_base64_init();
+        ska_base64_init();
     val = c = 0;
-    
+
     for (j = 0; *data ;data++) {
-	unsigned int k = ((unsigned char) *data) % BASE64_VALUE_SZ;
-	if (base64_value[k] < 0)
-	    continue;
-	val <<= 6;
-	val += base64_value[k];
-	if (++c < 4)
-	    continue;
-	/* One quantum of four encoding characters/24 bit */
+        unsigned int k = ((unsigned char) *data) % BASE64_VALUE_SZ;
+        if (base64_value[k] < 0)
+            continue;
+        val <<= 6;
+        val += base64_value[k];
+        if (++c < 4)
+            continue;
+        /* One quantum of four encoding characters/24 bit */
         if (j >= result_size)
-          break;
-	result[j++] = val >> 16;	/* High 8 bits */
+            break;
+        result[j++] = val >> 16;	/* High 8 bits */
         if (j >= result_size)
-          break;
-	result[j++] = (val >> 8) & 0xff;	/* Mid 8 bits */
+            break;
+        result[j++] = (val >> 8) & 0xff;	/* Mid 8 bits */
         if (j >= result_size)
-          break;
-	result[j++] = val & 0xff;	/* Low 8 bits */
-	val = c = 0;
+            break;
+        result[j++] = val & 0xff;	/* Low 8 bits */
+        val = c = 0;
     }
     return;
 }
@@ -73,80 +73,80 @@ void ska_base64_encode(char* result, const char *data, int result_size, int data
     int out_cnt = 0;
 
     if (!data)
-	return;
+        return;
 
     if (!base64_initialized)
-	ska_base64_init();
+        ska_base64_init();
 
     while (data_size--) {
         int c = (unsigned char) *data++;
-	bits += c;
-	char_count++;
-	if (char_count == 3) {
+        bits += c;
+        char_count++;
+        if (char_count == 3) {
             if (out_cnt >= result_size)
-              break;
-	    result[out_cnt++] = base64_code[bits >> 18];
+                break;
+            result[out_cnt++] = base64_code[bits >> 18];
             if (out_cnt >= result_size)
-              break;
-	    result[out_cnt++] = base64_code[(bits >> 12) & 0x3f];
+                break;
+            result[out_cnt++] = base64_code[(bits >> 12) & 0x3f];
             if (out_cnt >= result_size)
-              break;
-	    result[out_cnt++] = base64_code[(bits >> 6) & 0x3f];
+                break;
+            result[out_cnt++] = base64_code[(bits >> 6) & 0x3f];
             if (out_cnt >= result_size)
-              break;
-	    result[out_cnt++] = base64_code[bits & 0x3f];
-	    bits = 0;
-	    char_count = 0;
-	} else {
-	    bits <<= 8;
-	}
+                break;
+            result[out_cnt++] = base64_code[bits & 0x3f];
+            bits = 0;
+            char_count = 0;
+        } else {
+            bits <<= 8;
+        }
     }
     if (char_count != 0) {
-	bits <<= 16 - (8 * char_count);
+        bits <<= 16 - (8 * char_count);
         if (out_cnt >= result_size)
-          goto end;
-	result[out_cnt++] = base64_code[bits >> 18];
+            goto end;
+        result[out_cnt++] = base64_code[bits >> 18];
         if (out_cnt >= result_size)
-          goto end;
-	result[out_cnt++] = base64_code[(bits >> 12) & 0x3f];
-	if (char_count == 1) {
+            goto end;
+        result[out_cnt++] = base64_code[(bits >> 12) & 0x3f];
+        if (char_count == 1) {
             if (out_cnt >= result_size)
-              goto end;
-	    result[out_cnt++] = '=';
+                goto end;
+            result[out_cnt++] = '=';
             if (out_cnt >= result_size)
-              goto end;
-	    result[out_cnt++] = '=';
-	} else {
+                goto end;
+            result[out_cnt++] = '=';
+        } else {
             if (out_cnt >= result_size)
-              goto end;
-	    result[out_cnt++] = base64_code[(bits >> 6) & 0x3f];
+                goto end;
+            result[out_cnt++] = base64_code[(bits >> 6) & 0x3f];
             if (out_cnt >= result_size)
-              goto end;
-	    result[out_cnt++] = '=';
-	}
+                goto end;
+            result[out_cnt++] = '=';
+        }
     }
 end:
     if (out_cnt >= result_size) {
-       result[result_size-1] = '\0';	/* terminate */
+        result[result_size-1] = '\0';	/* terminate */
     } else {
-       result[out_cnt] = '\0';	/* terminate */
+        result[out_cnt] = '\0';	/* terminate */
     }
     return;
 }
 
 int ska_base64_encode_len(int len)
 {
-  return ((len+2)/3*4)+1;
+    return ((len+2)/3*4)+1;
 }
 
 int ska_base64_decode_len(const char *data)
 {
-  int i,j;
-
-  j=0;
-  for (i=strlen(data)-1;i>=0;i--) {
-   if (data[i] == '=') j++;
-   if (data[i] != '=') break;
-  }
-  return strlen(data)/4*3-j;
+    int i,j;
+
+    j=0;
+    for (i=strlen(data)-1;i>=0;i--) {
+        if (data[i] == '=') j++;
+        if (data[i] != '=') break;
+    }
+    return strlen(data)/4*3-j;
 }
@@ -32,12 +32,11 @@
 // The GSS Mechanism OID enumeration values (SPNEGO_MECH_OID) control which offset in
 // the array below, that a mechanism can be found.
 //
-MECH_OID g_stcMechOIDList [] =
-{
-   { (unsigned char*) "\x06\x09\x2a\x86\x48\x82\xf7\x12\x01\x02\x02",  11, 9, spnego_mech_oid_Kerberos_V5_Legacy  },  //  1.2.840.48018.1.2.2 
-   { (unsigned char*) "\x06\x09\x2a\x86\x48\x86\xf7\x12\x01\x02\x02",  11, 9, spnego_mech_oid_Kerberos_V5         },  //  1.2.840.113554.1.2.2
-   { (unsigned char*) "\x06\x06\x2b\x06\x01\x05\x05\x02",               8, 6, spnego_mech_oid_Spnego              },  //  1.3.6.1.1.5.5.2
-   { (unsigned char*) "",												0, 0, spnego_mech_oid_NotUsed             }   //  Placeholder
+MECH_OID g_stcMechOIDList [] = {
+    { (unsigned char*) "\x06\x09\x2a\x86\x48\x82\xf7\x12\x01\x02\x02",  11, 9, spnego_mech_oid_Kerberos_V5_Legacy  },  //  1.2.840.48018.1.2.2
+    { (unsigned char*) "\x06\x09\x2a\x86\x48\x86\xf7\x12\x01\x02\x02",  11, 9, spnego_mech_oid_Kerberos_V5         },  //  1.2.840.113554.1.2.2
+    { (unsigned char*) "\x06\x06\x2b\x06\x01\x05\x05\x02",               8, 6, spnego_mech_oid_Spnego              },  //  1.3.6.1.1.5.5.2
+    { (unsigned char*) "",												0, 0, spnego_mech_oid_NotUsed             }   //  Placeholder
 };
 
 /////////////////////////////////////////////////////////////////////////////
@@ -66,100 +65,91 @@ MECH_OID g_stcMechOIDList [] =
 int ASNDerGetLength( unsigned char* pbLengthData, long nBoundaryLength, long* pnLength,
                      long* pnNumLengthBytes )
 {
-   int   nReturn = SPNEGO_E_INVALID_LENGTH;
-   int   nNumLengthBytes = 0;
-
-   // First check if the extended length bit is set
-
-   if ( *pbLengthData & LEN_XTND )
-   {
-      // Lower 7 bits contain the number of trailing bytes that describe the length
-      nNumLengthBytes = *pbLengthData & LEN_MASK;
-
-      // Check that the number of bytes we are about to read is within our boundary
-      // constraints
-
-      if ( nNumLengthBytes <= nBoundaryLength - 1 )
-      {
-
-         // For now, our handler won't deal with lengths greater than 4 bytes
-         if ( nNumLengthBytes >= 1 && nNumLengthBytes <= 4 )
-         {
-            // 0 out the initial length
-            *pnLength = 0L;
-
-            // Bump by 1 byte
-            pbLengthData++;
-
-   #if defined(__LITTLE_ENDIAN__) || !defined(WORDS_BIGENDIAN) 
-
-            // There may be a cleaner way to do this, but for now, this seems to be
-            // an easy way to do the transformation
-            switch ( nNumLengthBytes )
-            {
-               case 1:
-               {
-                  *( ( (unsigned char*) pnLength ) ) = *pbLengthData;
-                  break;
-               }
-
-               case 2:
-               {
-                  *( ( (unsigned char*) pnLength ) ) = *(pbLengthData + 1);
-                  *( ( (unsigned char*) pnLength ) + 1 ) = *(pbLengthData);
-
-                  break;
-               }
-
-               case 3:
-               {
-                  *( ( (unsigned char*) pnLength ) ) = *(pbLengthData + 2);
-                  *( ( (unsigned char*) pnLength ) + 2 ) = *(pbLengthData + 1);
-                  *( ( (unsigned char*) pnLength ) + 3 ) = *(pbLengthData);
-                  break;
-               }
-
-               case 4:
-               {
-                  *( ( (unsigned char*) pnLength ) ) = *(pbLengthData + 3);
-                  *( ( (unsigned char*) pnLength ) + 1 ) = *(pbLengthData + 2);
-                  *( ( (unsigned char*) pnLength ) + 2 ) = *(pbLengthData + 1);
-                  *( ( (unsigned char*) pnLength ) + 3 ) = *(pbLengthData);
-                  break;
-               }
-
-            }  // SWITCH ( nNumLengthBytes )
-
-   #else
-            // We are Big-Endian, so the length can be copied in from the source
-            // as is.  Ensure that we adjust for the number of bytes we actually
-            // copy.
-
-            memcpy( ( (unsigned char *) pnLength ) + ( 4 - nNumLengthBytes ),
-                     pbLengthData, nNumLengthBytes );
-   #endif
-
-            // Account for the initial length byte
-            *pnNumLengthBytes = nNumLengthBytes + 1;
-            nReturn = SPNEGO_E_SUCCESS;
-
-         }  // IF Valid Length
-
-      }  // IF num bytes to read is within the boundary length
-
-   }  // IF xtended length
-   else
-   {
-
-      // Extended bit is not set, so the length is in the value and the one
-      // byte describes the length
-      *pnLength = *pbLengthData & LEN_MASK;
-      *pnNumLengthBytes = 1;
-      nReturn = SPNEGO_E_SUCCESS;
-
-   }
-   LOG(("ASNDerGetLength returned %d\n",nReturn));
-   return nReturn;
+    int   nReturn = SPNEGO_E_INVALID_LENGTH;
+    int   nNumLengthBytes = 0;
+
+    // First check if the extended length bit is set
+
+    if ( *pbLengthData & LEN_XTND ) {
+        // Lower 7 bits contain the number of trailing bytes that describe the length
+        nNumLengthBytes = *pbLengthData & LEN_MASK;
+
+        // Check that the number of bytes we are about to read is within our boundary
+        // constraints
+
+        if ( nNumLengthBytes <= nBoundaryLength - 1 ) {
+
+            // For now, our handler won't deal with lengths greater than 4 bytes
+            if ( nNumLengthBytes >= 1 && nNumLengthBytes <= 4 ) {
+                // 0 out the initial length
+                *pnLength = 0L;
+
+                // Bump by 1 byte
+                pbLengthData++;
+
+#if defined(__LITTLE_ENDIAN__) || !defined(WORDS_BIGENDIAN)
+
+                // There may be a cleaner way to do this, but for now, this seems to be
+                // an easy way to do the transformation
+                switch ( nNumLengthBytes ) {
+                case 1: {
+                    *( ( (unsigned char*) pnLength ) ) = *pbLengthData;
+                    break;
+                }
+
+                case 2: {
+                    *( ( (unsigned char*) pnLength ) ) = *(pbLengthData + 1);
+                    *( ( (unsigned char*) pnLength ) + 1 ) = *(pbLengthData);
+
+                    break;
+                }
+
+                case 3: {
+                    *( ( (unsigned char*) pnLength ) ) = *(pbLengthData + 2);
+                    *( ( (unsigned char*) pnLength ) + 2 ) = *(pbLengthData + 1);
+                    *( ( (unsigned char*) pnLength ) + 3 ) = *(pbLengthData);
+                    break;
+                }
+
+                case 4: {
+                    *( ( (unsigned char*) pnLength ) ) = *(pbLengthData + 3);
+                    *( ( (unsigned char*) pnLength ) + 1 ) = *(pbLengthData + 2);
+                    *( ( (unsigned char*) pnLength ) + 2 ) = *(pbLengthData + 1);
+                    *( ( (unsigned char*) pnLength ) + 3 ) = *(pbLengthData);
+                    break;
+                }
+
+                }  // SWITCH ( nNumLengthBytes )
+
+#else
+                // We are Big-Endian, so the length can be copied in from the source
+                // as is.  Ensure that we adjust for the number of bytes we actually
+                // copy.
+
+                memcpy( ( (unsigned char *) pnLength ) + ( 4 - nNumLengthBytes ),
+                        pbLengthData, nNumLengthBytes );
+#endif
+
+                // Account for the initial length byte
+                *pnNumLengthBytes = nNumLengthBytes + 1;
+                nReturn = SPNEGO_E_SUCCESS;
+
+            }  // IF Valid Length
+
+        }  // IF num bytes to read is within the boundary length
+
+    }  // IF xtended length
+    else {
+
+        // Extended bit is not set, so the length is in the value and the one
+        // byte describes the length
+        *pnLength = *pbLengthData & LEN_MASK;
+        *pnNumLengthBytes = 1;
+        nReturn = SPNEGO_E_SUCCESS;
+
+    }
+    LOG(("ASNDerGetLength returned %d\n",nReturn));
+    return nReturn;
 }
 
 
@@ -174,7 +164,7 @@ int ASNDerGetLength( unsigned char* pbLengthData, long nBoundaryLength, long* pn
 //    [in]  nLengthWithToken  -  Expected token length (with data)
 //    [in]  nBoundaryLength   -  Length that value must not exceed.
 //    [out] pnLength          -  Filled out with data length
-//    [out] pnTokenLength     -  Filled out with number of bytes 
+//    [out] pnTokenLength     -  Filled out with number of bytes
 //                               consumed by token identifier and length.
 //
 // Returns:
@@ -190,67 +180,59 @@ int ASNDerGetLength( unsigned char* pbLengthData, long nBoundaryLength, long* pn
 ////////////////////////////////////////////////////////////////////////////
 
 int ASNDerCheckToken( unsigned char* pbTokenData, unsigned char nToken,
-                        long nLengthWithToken, long nBoundaryLength,
-                        long* pnLength, long* pnTokenLength )
+                      long nLengthWithToken, long nBoundaryLength,
+                      long* pnLength, long* pnTokenLength )
 {
 
-   int   nReturn = SPNEGO_E_INVALID_LENGTH;
-   long  nNumLengthBytes = 0L;
+    int   nReturn = SPNEGO_E_INVALID_LENGTH;
+    long  nNumLengthBytes = 0L;
 
-   // Make sure that we've at least got 2 bytes of room to work with
+    // Make sure that we've at least got 2 bytes of room to work with
 
-   if ( nBoundaryLength >= 2 )
-   {
-      // The first byte of the token data MUST match the specified token
-      if ( *pbTokenData == nToken )
-      {
-         // Next byte indicates the length
-         pbTokenData++;
+    if ( nBoundaryLength >= 2 ) {
+        // The first byte of the token data MUST match the specified token
+        if ( *pbTokenData == nToken ) {
+            // Next byte indicates the length
+            pbTokenData++;
 
-         // Get the length described by the token
-         if ( ( nReturn = ASNDerGetLength( pbTokenData, nBoundaryLength, pnLength,
-                                             &nNumLengthBytes )  ) == SPNEGO_E_SUCCESS )
-         {
-            // Verify that the length is LESS THAN the boundary length
-            // (this should prevent us walking out of our buffer)
-            if ( ( nBoundaryLength - ( nNumLengthBytes + 1 ) < *pnLength ) )
-            {
+            // Get the length described by the token
+            if ( ( nReturn = ASNDerGetLength( pbTokenData, nBoundaryLength, pnLength,
+                                              &nNumLengthBytes )  ) == SPNEGO_E_SUCCESS ) {
+                // Verify that the length is LESS THAN the boundary length
+                // (this should prevent us walking out of our buffer)
+                if ( ( nBoundaryLength - ( nNumLengthBytes + 1 ) < *pnLength ) ) {
 
-               nReturn = SPNEGO_E_INVALID_LENGTH;
+                    nReturn = SPNEGO_E_INVALID_LENGTH;
 
-            }
+                }
 
-            // If we were passed a length to check, do so now
-            if ( nLengthWithToken > 0L )
-            {
+                // If we were passed a length to check, do so now
+                if ( nLengthWithToken > 0L ) {
 
-               // Check that the expected length matches
-               if ( ( nLengthWithToken - ( nNumLengthBytes + 1 ) ) != *pnLength )
-               {
+                    // Check that the expected length matches
+                    if ( ( nLengthWithToken - ( nNumLengthBytes + 1 ) ) != *pnLength ) {
 
-                  nReturn = SPNEGO_E_INVALID_LENGTH;
+                        nReturn = SPNEGO_E_INVALID_LENGTH;
 
-               }
+                    }
 
-            }  // IF need to validate length
+                }  // IF need to validate length
 
-            if ( SPNEGO_E_SUCCESS == nReturn )
-            {
-               *pnTokenLength = nNumLengthBytes + 1;
-            }
+                if ( SPNEGO_E_SUCCESS == nReturn ) {
+                    *pnTokenLength = nNumLengthBytes + 1;
+                }
 
-         }  // IF ASNDerGetLength
+            }  // IF ASNDerGetLength
 
-      }  // IF token matches
-      else
-      {
-         nReturn = SPNEGO_E_TOKEN_NOT_FOUND;
-      }
+        }  // IF token matches
+        else {
+            nReturn = SPNEGO_E_TOKEN_NOT_FOUND;
+        }
 
-   }  // IF Boundary Length is at least 2 bytes 
+    }  // IF Boundary Length is at least 2 bytes
 
-   LOG(("ASNDerCheckToken returned %d\n",nReturn));
-   return nReturn;
+    LOG(("ASNDerCheckToken returned %d\n",nReturn));
+    return nReturn;
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -275,39 +257,34 @@ int ASNDerCheckToken( unsigned char* pbTokenData, unsigned char nToken,
 ////////////////////////////////////////////////////////////////////////////
 
 int ASNDerCheckOID( unsigned char* pbTokenData, SPNEGO_MECH_OID nMechOID, long nBoundaryLength,
-                     long* pnTokenLength )
+                    long* pnTokenLength )
 {
-   int   nReturn = 0L;
-   long  nLength = 0L;
-
-   // Verify that we have an OID token
-   if ( ( nReturn = ASNDerCheckToken( pbTokenData, OID, 0L, nBoundaryLength, 
-                                       &nLength, pnTokenLength ) ) == SPNEGO_E_SUCCESS )
-   {
-      // Add the data length to the Token Length
-      *pnTokenLength += nLength;
-
-      // Token Lengths plus the actual length must match the length in our OID list element.
-      // If it doesn't, we're done
-      if ( *pnTokenLength == g_stcMechOIDList[nMechOID].iLen )
-      {
-         // Memcompare the token and the expected field
-         if ( memcmp( pbTokenData, g_stcMechOIDList[nMechOID].ucOid, *pnTokenLength ) != 0 )
-         {
-   	    LOG(("ASNDerCheckOID memcmp failed\n"));
+    int   nReturn = 0L;
+    long  nLength = 0L;
+
+    // Verify that we have an OID token
+    if ( ( nReturn = ASNDerCheckToken( pbTokenData, OID, 0L, nBoundaryLength,
+                                       &nLength, pnTokenLength ) ) == SPNEGO_E_SUCCESS ) {
+        // Add the data length to the Token Length
+        *pnTokenLength += nLength;
+
+        // Token Lengths plus the actual length must match the length in our OID list element.
+        // If it doesn't, we're done
+        if ( *pnTokenLength == g_stcMechOIDList[nMechOID].iLen ) {
+            // Memcompare the token and the expected field
+            if ( memcmp( pbTokenData, g_stcMechOIDList[nMechOID].ucOid, *pnTokenLength ) != 0 ) {
+                LOG(("ASNDerCheckOID memcmp failed\n"));
+                nReturn = SPNEGO_E_UNEXPECTED_OID;
+            }
+        } else {
+            LOG(("ASNDerCheckOID token length failed\n"));
             nReturn = SPNEGO_E_UNEXPECTED_OID;
-         }
-      }
-      else
-      {
-         LOG(("ASNDerCheckOID token length failed\n"));
-         nReturn = SPNEGO_E_UNEXPECTED_OID;
-      }
-
-   }  // IF OID Token CHecks
-
-   LOG(("ASNDerCheckOID returned %d\n",nReturn));
-   return nReturn;
+        }
+
+    }  // IF OID Token CHecks
+
+    LOG(("ASNDerCheckOID returned %d\n",nReturn));
+    return nReturn;
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -330,36 +307,27 @@ int ASNDerCheckOID( unsigned char* pbTokenData, SPNEGO_MECH_OID nMechOID, long n
 
 int ASNDerCalcNumLengthBytes( long nLength )
 {
-      if ( nLength <= 0x7F )
-      {
-         // A single byte will be sufficient for describing this length.
-         // The byte will simply contain the length
-         return 1;
-      }
-      else if ( nLength <= 0xFF )
-      {
-         // Two bytes are necessary, one to say how many following bytes
-         // describe the length, and one to give the length
-         return 2;
-      }
-      else if ( nLength <= 0xFFFF )
-      {
-         // Three bytes are necessary, one to say how many following bytes
-         // describe the length, and two to give the length
-         return 3;
-      }
-      else if ( nLength <= 0xFFFFFF )
-      {
-         // Four bytes are necessary, one to say how many following bytes
-         // describe the length, and three to give the length
-         return 4;
-      }
-      else
-      {
-         // Five bytes are necessary, one to say how many following bytes
-         // describe the length, and four to give the length
-         return 5;
-      }
+    if ( nLength <= 0x7F ) {
+        // A single byte will be sufficient for describing this length.
+        // The byte will simply contain the length
+        return 1;
+    } else if ( nLength <= 0xFF ) {
+        // Two bytes are necessary, one to say how many following bytes
+        // describe the length, and one to give the length
+        return 2;
+    } else if ( nLength <= 0xFFFF ) {
+        // Three bytes are necessary, one to say how many following bytes
+        // describe the length, and two to give the length
+        return 3;
+    } else if ( nLength <= 0xFFFFFF ) {
+        // Four bytes are necessary, one to say how many following bytes
+        // describe the length, and three to give the length
+        return 4;
+    } else {
+        // Five bytes are necessary, one to say how many following bytes
+        // describe the length, and four to give the length
+        return 5;
+    }
 }
 
 
@@ -384,11 +352,11 @@ int ASNDerCalcNumLengthBytes( long nLength )
 
 long ASNDerCalcTokenLength( long nLength, long nDataLength )
 {
-   // Add a byte to the length size to account for a single byte to
-   // hold the token type.
-   long  nTotalLength = ASNDerCalcNumLengthBytes( nLength ) + 1;
+    // Add a byte to the length size to account for a single byte to
+    // hold the token type.
+    long  nTotalLength = ASNDerCalcNumLengthBytes( nLength ) + 1;
 
-   return nTotalLength + nDataLength;
+    return nTotalLength + nDataLength;
 }
 
 
@@ -413,20 +381,19 @@ long ASNDerCalcTokenLength( long nLength, long nDataLength )
 
 long ASNDerCalcElementLength( long nDataLength, long* pnInternalLength )
 {
-   // First the type token and the actual data
-   long  nTotalLength = ASNDerCalcTokenLength( nDataLength, nDataLength );
+    // First the type token and the actual data
+    long  nTotalLength = ASNDerCalcTokenLength( nDataLength, nDataLength );
 
-   // Internal length is the length without the element sequence token
-   if ( NULL != pnInternalLength )
-   {
-      *pnInternalLength = nTotalLength;
-   }
+    // Internal length is the length without the element sequence token
+    if ( NULL != pnInternalLength ) {
+        *pnInternalLength = nTotalLength;
+    }
 
-   // Next add in the element's sequence token (remember that its
-   // length is the total length of the type token and data)
-   nTotalLength += ASNDerCalcTokenLength( nTotalLength, 0L );
+    // Next add in the element's sequence token (remember that its
+    // length is the total length of the type token and data)
+    nTotalLength += ASNDerCalcTokenLength( nTotalLength, 0L );
 
-   return nTotalLength;
+    return nTotalLength;
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -452,22 +419,21 @@ long ASNDerCalcElementLength( long nDataLength, long* pnInternalLength )
 
 long ASNDerCalcMechListLength( SPNEGO_MECH_OID mechoid, long* pnInternalLength )
 {
-   // First the OID
-   long  nTotalLength = g_stcMechOIDList[mechoid].iLen;
+    // First the OID
+    long  nTotalLength = g_stcMechOIDList[mechoid].iLen;
 
-   // Next add in a sequence token
-   nTotalLength += ASNDerCalcTokenLength( nTotalLength, 0L );
+    // Next add in a sequence token
+    nTotalLength += ASNDerCalcTokenLength( nTotalLength, 0L );
 
-   // Internal length is the length without the element sequence token
-   if ( NULL != pnInternalLength )
-   {
-      *pnInternalLength = nTotalLength;
-   }
+    // Internal length is the length without the element sequence token
+    if ( NULL != pnInternalLength ) {
+        *pnInternalLength = nTotalLength;
+    }
 
-   // Finally add in the element's sequence token
-   nTotalLength += ASNDerCalcTokenLength( nTotalLength, 0L );
+    // Finally add in the element's sequence token
+    nTotalLength += ASNDerCalcTokenLength( nTotalLength, 0L );
 
-   return nTotalLength;
+    return nTotalLength;
 }
 
 
@@ -490,79 +456,72 @@ long ASNDerCalcMechListLength( SPNEGO_MECH_OID mechoid, long* pnInternalLength )
 
 int ASNDerWriteLength( unsigned char* pbData, long nLength )
 {
-   int   nNumBytesRequired = ASNDerCalcNumLengthBytes( nLength );
-   int   nNumLengthBytes = nNumBytesRequired - 1;
+    int   nNumBytesRequired = ASNDerCalcNumLengthBytes( nLength );
+    int   nNumLengthBytes = nNumBytesRequired - 1;
 
 
-   if ( nNumBytesRequired > 1 )
-   {
+    if ( nNumBytesRequired > 1 ) {
 
-      // Write out the number of bytes following which will be used
-      *pbData = (unsigned char ) ( LEN_XTND | nNumLengthBytes );
+        // Write out the number of bytes following which will be used
+        *pbData = (unsigned char ) ( LEN_XTND | nNumLengthBytes );
 
-      // Point to where we'll actually write the length
-      pbData++;
+        // Point to where we'll actually write the length
+        pbData++;
 
-#if defined(__LITTLE_ENDIAN__) || !defined(WORDS_BIGENDIAN) 
+#if defined(__LITTLE_ENDIAN__) || !defined(WORDS_BIGENDIAN)
 
-      // There may be a cleaner way to do this, but for now, this seems to be
-      // an easy way to do the transformation
-      switch ( nNumLengthBytes )
-      {
-         case 1:
-         {
+        // There may be a cleaner way to do this, but for now, this seems to be
+        // an easy way to do the transformation
+        switch ( nNumLengthBytes ) {
+        case 1: {
             // Cast the length to a single byte, since we know that it
             // is 0x7F or less (or we wouldn't only need a single byte).
-      
+
             *pbData = (unsigned char) nLength;
             break;
-         }
+        }
 
-         case 2:
-         {
+        case 2: {
             *pbData = *( ( (unsigned char*) &nLength ) + 1 );
             *( pbData + 1) = *( ( (unsigned char*) &nLength ) );
             break;
-         }
+        }
 
-         case 3:
-         {
+        case 3: {
             *pbData = *( ( (unsigned char*) &nLength ) + 3 );
             *( pbData + 1) = *( ( (unsigned char*) &nLength ) + 2 );
             *( pbData + 2) = *( ( (unsigned char*) &nLength ) );
             break;
-         }
+        }
 
-         case 4:
-         {
+        case 4: {
             *pbData = *( ( (unsigned char*) &nLength ) + 3 );
             *( pbData + 1) = *( ( (unsigned char*) &nLength ) + 2 );
             *( pbData + 2) = *( ( (unsigned char*) &nLength ) + 1 );
             *( pbData + 3) = *( ( (unsigned char*) &nLength ) );
             break;
-         }
+        }
 
-      }  // SWITCH ( nNumLengthBytes )
+        }  // SWITCH ( nNumLengthBytes )
 
 #else
-      // We are Big-Endian, so the length can be copied in from the source
-      // as is.  Ensure that we adjust for the number of bytes we actually
-      // copy.
+        // We are Big-Endian, so the length can be copied in from the source
+        // as is.  Ensure that we adjust for the number of bytes we actually
+        // copy.
 
-      memcpy( pbData,
-               ( (unsigned char *) &nLength ) + ( 4 - nNumLengthBytes ), nNumLengthBytes );
+        memcpy( pbData,
+                ( (unsigned char *) &nLength ) + ( 4 - nNumLengthBytes ), nNumLengthBytes );
 #endif
 
-   }  // IF > 1 byte for length
-   else
-   {
-      // Cast the length to a single byte, since we know that it
-      // is 0x7F or less (or we wouldn't only need a single byte).
-      
-      *pbData = (unsigned char) nLength;
-   }
+    }  // IF > 1 byte for length
+    else {
+        // Cast the length to a single byte, since we know that it
+        // is 0x7F or less (or we wouldn't only need a single byte).
+
+        *pbData = (unsigned char) nLength;
+    }
 
-   return nNumBytesRequired;
+    return nNumBytesRequired;
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -587,34 +546,33 @@ int ASNDerWriteLength( unsigned char* pbData, long nLength )
 ////////////////////////////////////////////////////////////////////////////
 
 int ASNDerWriteToken( unsigned char* pbData, unsigned char ucType,
-                     unsigned char* pbTokenValue, long nLength )
+                      unsigned char* pbTokenValue, long nLength )
 {
-   int   nTotalBytesWrittenOut = 0L;
-   int   nNumLengthBytesWritten = 0L;
+    int   nTotalBytesWrittenOut = 0L;
+    int   nNumLengthBytesWritten = 0L;
 
-   // Write out the type
-   *pbData = ucType;
+    // Write out the type
+    *pbData = ucType;
 
-   // Wrote 1 byte, and move data pointer
-   nTotalBytesWrittenOut++;
-   pbData++;
+    // Wrote 1 byte, and move data pointer
+    nTotalBytesWrittenOut++;
+    pbData++;
 
-   // Now write out the length and adjust the number of bytes written out
-   nNumLengthBytesWritten = ASNDerWriteLength( pbData, nLength );
+    // Now write out the length and adjust the number of bytes written out
+    nNumLengthBytesWritten = ASNDerWriteLength( pbData, nLength );
 
-   nTotalBytesWrittenOut += nNumLengthBytesWritten;
-   pbData += nNumLengthBytesWritten;
+    nTotalBytesWrittenOut += nNumLengthBytesWritten;
+    pbData += nNumLengthBytesWritten;
 
-   // Write out the token value if we got one.  The assumption is that the
-   // nLength value indicates how many bytes are in pbTokenValue.
+    // Write out the token value if we got one.  The assumption is that the
+    // nLength value indicates how many bytes are in pbTokenValue.
 
-   if ( NULL != pbTokenValue )
-   {
-      memcpy( pbData, pbTokenValue, nLength );
-      nTotalBytesWrittenOut += nLength;
-   }
+    if ( NULL != pbTokenValue ) {
+        memcpy( pbData, pbTokenValue, nLength );
+        nTotalBytesWrittenOut += nLength;
+    }
 
-   return nTotalBytesWrittenOut;
+    return nTotalBytesWrittenOut;
 }
 
 
@@ -640,9 +598,9 @@ int ASNDerWriteToken( unsigned char* pbData, unsigned char ucType,
 int ASNDerWriteOID( unsigned char* pbData, SPNEGO_MECH_OID eMechOID )
 {
 
-   memcpy( pbData, g_stcMechOIDList[eMechOID].ucOid, g_stcMechOIDList[eMechOID].iLen );
+    memcpy( pbData, g_stcMechOIDList[eMechOID].ucOid, g_stcMechOIDList[eMechOID].iLen );
 
-   return g_stcMechOIDList[eMechOID].iLen;
+    return g_stcMechOIDList[eMechOID].iLen;
 }
 
 
@@ -667,25 +625,25 @@ int ASNDerWriteOID( unsigned char* pbData, SPNEGO_MECH_OID eMechOID )
 
 long ASNDerWriteMechList( unsigned char* pbData, SPNEGO_MECH_OID mechoid )
 {
-   // First get the length
-   long  nInternalLength = 0L;
-   long  nMechListLength = ASNDerCalcMechListLength( mechoid, &nInternalLength );
-   long  nTempLength = 0L;
+    // First get the length
+    long  nInternalLength = 0L;
+    long  nMechListLength = ASNDerCalcMechListLength( mechoid, &nInternalLength );
+    long  nTempLength = 0L;
 
-   nTempLength = ASNDerWriteToken( pbData, SPNEGO_NEGINIT_ELEMENT_MECHTYPES,
+    nTempLength = ASNDerWriteToken( pbData, SPNEGO_NEGINIT_ELEMENT_MECHTYPES,
                                     NULL, nInternalLength );
 
-   // Adjust the data pointer
-   pbData += nTempLength;
+    // Adjust the data pointer
+    pbData += nTempLength;
 
-   // Now write the Sequence token and the OID (the OID is a BLOB in the global
-   // structure.
+    // Now write the Sequence token and the OID (the OID is a BLOB in the global
+    // structure.
 
-   nTempLength = ASNDerWriteToken( pbData, SPNEGO_CONSTRUCTED_SEQUENCE,
+    nTempLength = ASNDerWriteToken( pbData, SPNEGO_CONSTRUCTED_SEQUENCE,
                                     g_stcMechOIDList[mechoid].ucOid,
                                     g_stcMechOIDList[mechoid].iLen );
 
-   return nMechListLength;
+    return nMechListLength;
 }
 
 
@@ -713,20 +671,20 @@ long ASNDerWriteMechList( unsigned char* pbData, SPNEGO_MECH_OID mechoid )
 int ASNDerWriteElement( unsigned char* pbData, unsigned char ucElementSequence,
                         unsigned char ucType, unsigned char* pbTokenValue, long nLength )
 {
-   // First get the length
-   long  nInternalLength = 0L;
-   long  nElementLength = ASNDerCalcElementLength( nLength, &nInternalLength );
-   long  nTempLength = 0L;
+    // First get the length
+    long  nInternalLength = 0L;
+    long  nElementLength = ASNDerCalcElementLength( nLength, &nInternalLength );
+    long  nTempLength = 0L;
 
-   // Write out the sequence byte and the length of the type and data
-   nTempLength = ASNDerWriteToken( pbData, ucElementSequence, NULL, nInternalLength );
+    // Write out the sequence byte and the length of the type and data
+    nTempLength = ASNDerWriteToken( pbData, ucElementSequence, NULL, nInternalLength );
 
-   // Adjust the data pointer
-   pbData += nTempLength;
+    // Adjust the data pointer
+    pbData += nTempLength;
 
-   // Now write the type and the data.
-   nTempLength = ASNDerWriteToken( pbData, ucType, pbTokenValue, nLength );
+    // Now write the type and the data.
+    nTempLength = ASNDerWriteToken( pbData, ucType, pbTokenValue, nLength );
 
-   return nElementLength;
+    return nElementLength;
 }
 
@@ -30,20 +30,20 @@ extern "C"
 {
 #endif
 
-/* Identifier Types */
+    /* Identifier Types */
 #define  IDENTIFIER_MASK               0xC0  // Bits 7 and 8
 #define  IDENTIFIER_UNIVERSAL          0x00  // 00 = universal
 #define  IDENTIFIER_APPLICATION        0x40  // 01 = application
 #define  IDENTIFIER_CONTEXT_SPECIFIC   0x80  // 10 = context specific
 #define  IDENTIFIER_PRIVATE            0xC0  // 11 = Private
 
-/* Encoding type */
+    /* Encoding type */
 
 #define FORM_MASK       0x20    /* Bit 6 */
 #define PRIMITIVE       0x00    /* 0 = primitive */
 #define CONSTRUCTED     0x20    /* 1 = constructed */
 
-/* Universal tags */
+    /* Universal tags */
 
 #define TAG_MASK        0x1F    /* Bits 5 - 1 */
 #define BOOLEAN         0x01    /*  1: TRUE or FALSE */
@@ -72,7 +72,7 @@ extern "C"
 #define UNIVERSALSTR    0x1C    /* 28: Universal String */
 #define BMPSTR          0x1E    /* 30: Basic Multilingual Plane String */
 
-/* Length encoding */
+    /* Length encoding */
 
 #define LEN_XTND  0x80      /* Indefinite or long form */
 #define LEN_MASK  0x7f      /* Bits 7 - 1 */
@@ -165,40 +165,39 @@ extern "C"
 // of these which we'll use for validation/searches/parsing.
 //
 
-typedef struct _mechOID
-{
-   unsigned char*    ucOid;            // Byte representation of OID
-   int               iLen;             // Length of the OID, length and identifier
-   int               iActualDataLen;   // Length of the actual OID 
-   SPNEGO_MECH_OID   eMechanismOID;     // Which OID is this?   
-} MECH_OID;
+    typedef struct _mechOID {
+        unsigned char*    ucOid;            // Byte representation of OID
+        int               iLen;             // Length of the OID, length and identifier
+        int               iActualDataLen;   // Length of the actual OID
+        SPNEGO_MECH_OID   eMechanismOID;     // Which OID is this?
+    } MECH_OID;
 
 
 //
 // ASN Der functions
 //
 
-int ASNDerGetLength( unsigned char* pbLengthData, long nBoundaryLength, long* pnLength,
-                    long* pnNumLengthBytes );
-int ASNDerCheckToken( unsigned char* pbTokenData, unsigned char nToken,
-                        long nCheckLength, long nBoundaryLength, long* pnLength,
+    int ASNDerGetLength( unsigned char* pbLengthData, long nBoundaryLength, long* pnLength,
+                         long* pnNumLengthBytes );
+    int ASNDerCheckToken( unsigned char* pbTokenData, unsigned char nToken,
+                          long nCheckLength, long nBoundaryLength, long* pnLength,
+                          long* pnTokenLength );
+    int ASNDerCheckOID( unsigned char* pbTokenData, SPNEGO_MECH_OID nMechOID, long nBoundaryLength,
                         long* pnTokenLength );
-int ASNDerCheckOID( unsigned char* pbTokenData, SPNEGO_MECH_OID nMechOID, long nBoundaryLength,
-                     long* pnTokenLength );
-int ASNDerCalcNumLengthBytes( long nLength );
-long ASNDerCalcTokenLength( long nLength, long nDataLength );
-long ASNDerCalcElementLength( long nDataLength, long* pnInternalLength );
-long ASNDerCalcMechListLength( SPNEGO_MECH_OID mechoid, long* pnInternalLength );
-int ASNDerWriteLength( unsigned char* pbData, long nLength );
-int ASNDerWriteToken( unsigned char* pbData, unsigned char ucType,
-                     unsigned char* pbTokenValue, long nLength );
-int ASNDerWriteOID( unsigned char* pbData, SPNEGO_MECH_OID eMechOID );
-long ASNDerWriteMechList( unsigned char* pbData, SPNEGO_MECH_OID mechoid );
-int ASNDerWriteElement( unsigned char* pbData, unsigned char ucElementSequence,
-                        unsigned char ucType, unsigned char* pbTokenValue, long nLength );
-
-
-   // C++ Specific
+    int ASNDerCalcNumLengthBytes( long nLength );
+    long ASNDerCalcTokenLength( long nLength, long nDataLength );
+    long ASNDerCalcElementLength( long nDataLength, long* pnInternalLength );
+    long ASNDerCalcMechListLength( SPNEGO_MECH_OID mechoid, long* pnInternalLength );
+    int ASNDerWriteLength( unsigned char* pbData, long nLength );
+    int ASNDerWriteToken( unsigned char* pbData, unsigned char ucType,
+                          unsigned char* pbTokenValue, long nLength );
+    int ASNDerWriteOID( unsigned char* pbData, SPNEGO_MECH_OID eMechOID );
+    long ASNDerWriteMechList( unsigned char* pbData, SPNEGO_MECH_OID mechoid );
+    int ASNDerWriteElement( unsigned char* pbData, unsigned char ucElementSequence,
+                            unsigned char ucType, unsigned char* pbTokenValue, long nLength );
+
+
+    // C++ Specific
 #if defined(__cplusplus)
 }
 #endif
@@ -71,18 +71,18 @@ extern MECH_OID g_stcMechOIDList [];
 
 int spnegoInitFromBinary( unsigned char* pbTokenData, unsigned long ulLength, SPNEGO_TOKEN_HANDLE* phSpnegoToken )
 {
-   int            nReturn = SPNEGO_E_INVALID_PARAMETER;
-   SPNEGO_TOKEN** ppSpnegoToken = (SPNEGO_TOKEN**) phSpnegoToken;
-
-   // Pass off to a handler function that allows tighter control over how the token structure
-   // is handled.  In this case, we want the token data copied and we want the associated buffer
-   // freed.
-   nReturn = InitTokenFromBinary( SPNEGO_TOKEN_INTERNAL_COPYDATA,
-                                 SPNEGO_TOKEN_INTERNAL_FLAGS_FREEDATA, pbTokenData,
-                                 ulLength, ppSpnegoToken );
-
-   LOG(("spnegoInitFromBinary returned %d\n",nReturn));
-   return nReturn;
+    int            nReturn = SPNEGO_E_INVALID_PARAMETER;
+    SPNEGO_TOKEN** ppSpnegoToken = (SPNEGO_TOKEN**) phSpnegoToken;
+
+    // Pass off to a handler function that allows tighter control over how the token structure
+    // is handled.  In this case, we want the token data copied and we want the associated buffer
+    // freed.
+    nReturn = InitTokenFromBinary( SPNEGO_TOKEN_INTERNAL_COPYDATA,
+                                   SPNEGO_TOKEN_INTERNAL_FLAGS_FREEDATA, pbTokenData,
+                                   ulLength, ppSpnegoToken );
+
+    LOG(("spnegoInitFromBinary returned %d\n",nReturn));
+    return nReturn;
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -113,68 +113,62 @@ int spnegoInitFromBinary( unsigned char* pbTokenData, unsigned long ulLength, SP
 ////////////////////////////////////////////////////////////////////////////
 
 int spnegoCreateNegTokenInit( SPNEGO_MECH_OID MechType,
-          unsigned char ucContextFlags, unsigned char* pbMechToken,
-          unsigned long ulMechTokenLen, unsigned char* pbMechListMIC,
-          unsigned long ulMechListMICLen, SPNEGO_TOKEN_HANDLE* phSpnegoToken )
+                              unsigned char ucContextFlags, unsigned char* pbMechToken,
+                              unsigned long ulMechTokenLen, unsigned char* pbMechListMIC,
+                              unsigned long ulMechListMICLen, SPNEGO_TOKEN_HANDLE* phSpnegoToken )
 {
-   int   nReturn = SPNEGO_E_INVALID_PARAMETER;
-   long  nTokenLength = 0L;
-   long  nInternalTokenLength = 0L;
-   unsigned char* pbTokenData = NULL;
-   SPNEGO_TOKEN** ppSpnegoToken = (SPNEGO_TOKEN**) phSpnegoToken;
-
-   if ( NULL != ppSpnegoToken &&
-         IsValidMechOid( MechType ) &&
-         IsValidContextFlags( ucContextFlags ) )
-   {
-      // Get the actual token size
-
-      if ( ( nReturn = CalculateMinSpnegoInitTokenSize( ulMechTokenLen, ulMechListMICLen, 
-                                                         MechType, ( ucContextFlags != 0L ), 
-                                                         &nTokenLength, &nInternalTokenLength ) )
-                        == SPNEGO_E_SUCCESS )
-      {
-         // Allocate a buffer to hold the data.
-         pbTokenData = calloc( 1, nTokenLength );
-
-         if ( NULL != pbTokenData )
-         {
-
-            // Now write the token
-            if ( ( nReturn = CreateSpnegoInitToken( MechType,
-                                                 ucContextFlags, pbMechToken,
-                                                 ulMechTokenLen, pbMechListMIC,
-                                                 ulMechListMICLen, pbTokenData,
-                                                 nTokenLength, nInternalTokenLength ) )
-                              == SPNEGO_E_SUCCESS )
-            {
-
-               // This will copy our allocated pointer, and ensure that the sructure cleans
-               // up the data later
-               nReturn = InitTokenFromBinary( SPNEGO_TOKEN_INTERNAL_COPYPTR,
-                                             SPNEGO_TOKEN_INTERNAL_FLAGS_FREEDATA,
-                                             pbTokenData, nTokenLength, ppSpnegoToken );
-
-            }
-
-            // Cleanup on failure
-            if ( SPNEGO_E_SUCCESS != nReturn )
-            {
-               free( pbTokenData );
+    int   nReturn = SPNEGO_E_INVALID_PARAMETER;
+    long  nTokenLength = 0L;
+    long  nInternalTokenLength = 0L;
+    unsigned char* pbTokenData = NULL;
+    SPNEGO_TOKEN** ppSpnegoToken = (SPNEGO_TOKEN**) phSpnegoToken;
+
+    if ( NULL != ppSpnegoToken &&
+            IsValidMechOid( MechType ) &&
+            IsValidContextFlags( ucContextFlags ) ) {
+        // Get the actual token size
+
+        if ( ( nReturn = CalculateMinSpnegoInitTokenSize( ulMechTokenLen, ulMechListMICLen,
+                         MechType, ( ucContextFlags != 0L ),
+                         &nTokenLength, &nInternalTokenLength ) )
+                == SPNEGO_E_SUCCESS ) {
+            // Allocate a buffer to hold the data.
+            pbTokenData = calloc( 1, nTokenLength );
+
+            if ( NULL != pbTokenData ) {
+
+                // Now write the token
+                if ( ( nReturn = CreateSpnegoInitToken( MechType,
+                                                        ucContextFlags, pbMechToken,
+                                                        ulMechTokenLen, pbMechListMIC,
+                                                        ulMechListMICLen, pbTokenData,
+                                                        nTokenLength, nInternalTokenLength ) )
+                        == SPNEGO_E_SUCCESS ) {
+
+                    // This will copy our allocated pointer, and ensure that the sructure cleans
+                    // up the data later
+                    nReturn = InitTokenFromBinary( SPNEGO_TOKEN_INTERNAL_COPYPTR,
+                                                   SPNEGO_TOKEN_INTERNAL_FLAGS_FREEDATA,
+                                                   pbTokenData, nTokenLength, ppSpnegoToken );
+
+                }
+
+                // Cleanup on failure
+                if ( SPNEGO_E_SUCCESS != nReturn ) {
+                    free( pbTokenData );
+                }
+
+            }  // IF alloc succeeded
+            else {
+                nReturn = SPNEGO_E_OUT_OF_MEMORY;
             }
 
-         }  // IF alloc succeeded
-         else
-         {
-            nReturn = SPNEGO_E_OUT_OF_MEMORY;
-         }
+        }  // If calculated token size
 
-      }  // If calculated token size
+    }  // IF Valid Parameters
 
-   }  // IF Valid Parameters
-
-   LOG(("spnegoCreateNegTokenInit returned %d\n",nReturn));
-   return nReturn;
+    LOG(("spnegoCreateNegTokenInit returned %d\n",nReturn));
+    return nReturn;
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -203,85 +197,79 @@ int spnegoCreateNegTokenInit( SPNEGO_MECH_OID MechType,
 //
 ////////////////////////////////////////////////////////////////////////////
 
-int spnegoCreateNegTokenTarg( SPNEGO_MECH_OID MechType, 
-          SPNEGO_NEGRESULT spnegoNegResult, unsigned char* pbMechToken,
-          unsigned long ulMechTokenLen, unsigned char* pbMechListMIC,
-          unsigned long ulMechListMICLen, SPNEGO_TOKEN_HANDLE* phSpnegoToken )
+int spnegoCreateNegTokenTarg( SPNEGO_MECH_OID MechType,
+                              SPNEGO_NEGRESULT spnegoNegResult, unsigned char* pbMechToken,
+                              unsigned long ulMechTokenLen, unsigned char* pbMechListMIC,
+                              unsigned long ulMechListMICLen, SPNEGO_TOKEN_HANDLE* phSpnegoToken )
 {
-   int   nReturn = SPNEGO_E_INVALID_PARAMETER;
-   long  nTokenLength = 0L;
-   long  nInternalTokenLength = 0L;
-   unsigned char* pbTokenData = NULL;
-   SPNEGO_TOKEN** ppSpnegoToken = (SPNEGO_TOKEN**) phSpnegoToken;
-
-   //
-   // spnego_mech_oid_NotUsed and spnego_negresult_NotUsed
-   // are okay here, however a valid MechOid is required
-   // if spnego_negresult_success or spnego_negresult_incomplete
-   // is specified.
-   //
-
-   if ( NULL != ppSpnegoToken &&
-
-         ( IsValidMechOid( MechType ) ||
-            spnego_mech_oid_NotUsed == MechType ) &&
-
-         ( IsValidNegResult( spnegoNegResult ) ||
-            spnego_negresult_NotUsed == spnegoNegResult ) &&
-
-         !( !IsValidMechOid( MechType ) &&
-            ( spnego_negresult_success == spnegoNegResult ||
-              spnego_negresult_incomplete == spnegoNegResult ) ) )
-   {
-
-      // Get the actual token size
-
-      if ( ( nReturn = CalculateMinSpnegoTargTokenSize( MechType, spnegoNegResult, ulMechTokenLen,
-                                                         ulMechListMICLen, &nTokenLength, 
-                                                         &nInternalTokenLength ) )
-                        == SPNEGO_E_SUCCESS )
-      {
-         // Allocate a buffer to hold the data.
-         pbTokenData = calloc( 1, nTokenLength );
-
-         if ( NULL != pbTokenData )
-         {
-
-            // Now write the token
-            if ( ( nReturn = CreateSpnegoTargToken( MechType,
-                                                 spnegoNegResult, pbMechToken,
-                                                 ulMechTokenLen, pbMechListMIC,
-                                                 ulMechListMICLen, pbTokenData,
-                                                 nTokenLength, nInternalTokenLength ) )
-                              == SPNEGO_E_SUCCESS )
-            {
-
-               // This will copy our allocated pointer, and ensure that the sructure cleans
-               // up the data later
-               nReturn = InitTokenFromBinary( SPNEGO_TOKEN_INTERNAL_COPYPTR,
-                                             SPNEGO_TOKEN_INTERNAL_FLAGS_FREEDATA,
-                                             pbTokenData, nTokenLength, ppSpnegoToken );
-
+    int   nReturn = SPNEGO_E_INVALID_PARAMETER;
+    long  nTokenLength = 0L;
+    long  nInternalTokenLength = 0L;
+    unsigned char* pbTokenData = NULL;
+    SPNEGO_TOKEN** ppSpnegoToken = (SPNEGO_TOKEN**) phSpnegoToken;
+
+    //
+    // spnego_mech_oid_NotUsed and spnego_negresult_NotUsed
+    // are okay here, however a valid MechOid is required
+    // if spnego_negresult_success or spnego_negresult_incomplete
+    // is specified.
+    //
+
+    if ( NULL != ppSpnegoToken &&
+
+            ( IsValidMechOid( MechType ) ||
+              spnego_mech_oid_NotUsed == MechType ) &&
+
+            ( IsValidNegResult( spnegoNegResult ) ||
+              spnego_negresult_NotUsed == spnegoNegResult ) &&
+
+            !( !IsValidMechOid( MechType ) &&
+               ( spnego_negresult_success == spnegoNegResult ||
+                 spnego_negresult_incomplete == spnegoNegResult ) ) ) {
+
+        // Get the actual token size
+
+        if ( ( nReturn = CalculateMinSpnegoTargTokenSize( MechType, spnegoNegResult, ulMechTokenLen,
+                         ulMechListMICLen, &nTokenLength,
+                         &nInternalTokenLength ) )
+                == SPNEGO_E_SUCCESS ) {
+            // Allocate a buffer to hold the data.
+            pbTokenData = calloc( 1, nTokenLength );
+
+            if ( NULL != pbTokenData ) {
+
+                // Now write the token
+                if ( ( nReturn = CreateSpnegoTargToken( MechType,
+                                                        spnegoNegResult, pbMechToken,
+                                                        ulMechTokenLen, pbMechListMIC,
+                                                        ulMechListMICLen, pbTokenData,
+                                                        nTokenLength, nInternalTokenLength ) )
+                        == SPNEGO_E_SUCCESS ) {
+
+                    // This will copy our allocated pointer, and ensure that the sructure cleans
+                    // up the data later
+                    nReturn = InitTokenFromBinary( SPNEGO_TOKEN_INTERNAL_COPYPTR,
+                                                   SPNEGO_TOKEN_INTERNAL_FLAGS_FREEDATA,
+                                                   pbTokenData, nTokenLength, ppSpnegoToken );
+
+                }
+
+                // Cleanup on failure
+                if ( SPNEGO_E_SUCCESS != nReturn ) {
+                    free( pbTokenData );
+                }
+
+            }  // IF alloc succeeded
+            else {
+                nReturn = SPNEGO_E_OUT_OF_MEMORY;
             }
 
-            // Cleanup on failure
-            if ( SPNEGO_E_SUCCESS != nReturn )
-            {
-               free( pbTokenData );
-            }
-
-         }  // IF alloc succeeded
-         else
-         {
-            nReturn = SPNEGO_E_OUT_OF_MEMORY;
-         }
-
-      }  // If calculated token size
+        }  // If calculated token size
 
-   }  // IF Valid Parameters
+    }  // IF Valid Parameters
 
-   LOG(("spnegoCreateNegTokenTarg returned %d\n",nReturn));
-   return nReturn;
+    LOG(("spnegoCreateNegTokenTarg returned %d\n",nReturn));
+    return nReturn;
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -308,34 +296,30 @@ int spnegoCreateNegTokenTarg( SPNEGO_MECH_OID MechType,
 ////////////////////////////////////////////////////////////////////////////
 
 int spnegoTokenGetBinary( SPNEGO_TOKEN_HANDLE hSpnegoToken, unsigned char* pbTokenData,
-                           unsigned long * pulDataLen )
+                          unsigned long * pulDataLen )
 {
-   int   nReturn = SPNEGO_E_INVALID_PARAMETER;
-   SPNEGO_TOKEN*  pSpnegoToken = (SPNEGO_TOKEN*) hSpnegoToken;
-   
-   // Check parameters - pbTokenData is optional
-   if (  IsValidSpnegoToken( pSpnegoToken ) &&
-         NULL != pulDataLen )
-   {
-
-      // Check for Buffer too small conditions
-      if ( NULL == pbTokenData ||
-            pSpnegoToken->ulBinaryDataLen > *pulDataLen )
-      {
-         *pulDataLen = pSpnegoToken->ulBinaryDataLen;
-         nReturn = SPNEGO_E_BUFFER_TOO_SMALL;
-      }
-      else
-      {
-         memcpy( pbTokenData, pSpnegoToken->pbBinaryData, pSpnegoToken->ulBinaryDataLen );
-         *pulDataLen = pSpnegoToken->ulBinaryDataLen;
-         nReturn = SPNEGO_E_SUCCESS;
-      }
-
-   }  // IF parameters OK
-
-   LOG(("spnegoTokenGetBinary returned %d\n",nReturn));
-   return nReturn;;
+    int   nReturn = SPNEGO_E_INVALID_PARAMETER;
+    SPNEGO_TOKEN*  pSpnegoToken = (SPNEGO_TOKEN*) hSpnegoToken;
+
+    // Check parameters - pbTokenData is optional
+    if (  IsValidSpnegoToken( pSpnegoToken ) &&
+            NULL != pulDataLen ) {
+
+        // Check for Buffer too small conditions
+        if ( NULL == pbTokenData ||
+                pSpnegoToken->ulBinaryDataLen > *pulDataLen ) {
+            *pulDataLen = pSpnegoToken->ulBinaryDataLen;
+            nReturn = SPNEGO_E_BUFFER_TOO_SMALL;
+        } else {
+            memcpy( pbTokenData, pSpnegoToken->pbBinaryData, pSpnegoToken->ulBinaryDataLen );
+            *pulDataLen = pSpnegoToken->ulBinaryDataLen;
+            nReturn = SPNEGO_E_SUCCESS;
+        }
+
+    }  // IF parameters OK
+
+    LOG(("spnegoTokenGetBinary returned %d\n",nReturn));
+    return nReturn;;
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -357,8 +341,8 @@ int spnegoTokenGetBinary( SPNEGO_TOKEN_HANDLE hSpnegoToken, unsigned char* pbTok
 
 void spnegoFreeData( SPNEGO_TOKEN_HANDLE hSpnegoToken )
 {
-   FreeSpnegoToken( (SPNEGO_TOKEN*) hSpnegoToken);
-   return;
+    FreeSpnegoToken( (SPNEGO_TOKEN*) hSpnegoToken);
+    return;
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -382,27 +366,25 @@ void spnegoFreeData( SPNEGO_TOKEN_HANDLE hSpnegoToken )
 
 int spnegoGetTokenType( SPNEGO_TOKEN_HANDLE hSpnegoToken, int * piTokenType )
 {
-   int   nReturn = SPNEGO_E_INVALID_PARAMETER;
-   SPNEGO_TOKEN*  pSpnegoToken = (SPNEGO_TOKEN*) hSpnegoToken;
-   
-   // Check parameters
-   if (  IsValidSpnegoToken( pSpnegoToken ) &&
-         NULL != piTokenType &&
-         pSpnegoToken)
-   {
-
-      // Check that the type in the structure makes sense
-      if ( SPNEGO_TOKEN_INIT == pSpnegoToken->ucTokenType ||
-            SPNEGO_TOKEN_TARG == pSpnegoToken->ucTokenType )
-      {
-         *piTokenType = pSpnegoToken->ucTokenType;
-         nReturn = SPNEGO_E_SUCCESS;
-      }
-
-   }  // IF parameters OK
-
-   LOG(("spnegoGetTokenType returned %d\n",nReturn));
-   return nReturn;
+    int   nReturn = SPNEGO_E_INVALID_PARAMETER;
+    SPNEGO_TOKEN*  pSpnegoToken = (SPNEGO_TOKEN*) hSpnegoToken;
+
+    // Check parameters
+    if (  IsValidSpnegoToken( pSpnegoToken ) &&
+            NULL != piTokenType &&
+            pSpnegoToken) {
+
+        // Check that the type in the structure makes sense
+        if ( SPNEGO_TOKEN_INIT == pSpnegoToken->ucTokenType ||
+                SPNEGO_TOKEN_TARG == pSpnegoToken->ucTokenType ) {
+            *piTokenType = pSpnegoToken->ucTokenType;
+            nReturn = SPNEGO_E_SUCCESS;
+        }
+
+    }  // IF parameters OK
+
+    LOG(("spnegoGetTokenType returned %d\n",nReturn));
+    return nReturn;
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -431,34 +413,30 @@ int spnegoGetTokenType( SPNEGO_TOKEN_HANDLE hSpnegoToken, int * piTokenType )
 // Returns the Initial Mech Type in the MechList element in the NegInitToken.
 int spnegoIsMechTypeAvailable( SPNEGO_TOKEN_HANDLE hSpnegoToken, SPNEGO_MECH_OID MechOID, int * piMechTypeIndex )
 {
-   int   nReturn = SPNEGO_E_INVALID_PARAMETER;
-   SPNEGO_TOKEN*  pSpnegoToken = (SPNEGO_TOKEN*) hSpnegoToken;
-   
-   // Check parameters
-   if (  IsValidSpnegoToken( pSpnegoToken ) &&
-         NULL != piMechTypeIndex &&
-         IsValidMechOid( MechOID ) && 
-         SPNEGO_TOKEN_INIT == pSpnegoToken->ucTokenType )
-   {
-
-      // Check if MechList is available
-      if ( pSpnegoToken->aElementArray[SPNEGO_INIT_MECHTYPES_ELEMENT].iElementPresent
-            == SPNEGO_TOKEN_ELEMENT_AVAILABLE )
-      {
-         // Locate the MechOID in the list element
-         nReturn = FindMechOIDInMechList(
-                     &pSpnegoToken->aElementArray[SPNEGO_INIT_MECHTYPES_ELEMENT],
-                     MechOID, piMechTypeIndex );
-      }
-      else
-      {
-         nReturn = SPNEGO_E_ELEMENT_UNAVAILABLE;
-      }
-
-   }  // IF parameters OK
-
-   LOG(("spnegoIsMechTypeAvailable returned %d\n",nReturn));
-   return nReturn;;
+    int   nReturn = SPNEGO_E_INVALID_PARAMETER;
+    SPNEGO_TOKEN*  pSpnegoToken = (SPNEGO_TOKEN*) hSpnegoToken;
+
+    // Check parameters
+    if (  IsValidSpnegoToken( pSpnegoToken ) &&
+            NULL != piMechTypeIndex &&
+            IsValidMechOid( MechOID ) &&
+            SPNEGO_TOKEN_INIT == pSpnegoToken->ucTokenType ) {
+
+        // Check if MechList is available
+        if ( pSpnegoToken->aElementArray[SPNEGO_INIT_MECHTYPES_ELEMENT].iElementPresent
+                == SPNEGO_TOKEN_ELEMENT_AVAILABLE ) {
+            // Locate the MechOID in the list element
+            nReturn = FindMechOIDInMechList(
+                          &pSpnegoToken->aElementArray[SPNEGO_INIT_MECHTYPES_ELEMENT],
+                          MechOID, piMechTypeIndex );
+        } else {
+            nReturn = SPNEGO_E_ELEMENT_UNAVAILABLE;
+        }
+
+    }  // IF parameters OK
+
+    LOG(("spnegoIsMechTypeAvailable returned %d\n",nReturn));
+    return nReturn;;
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -484,43 +462,36 @@ int spnegoIsMechTypeAvailable( SPNEGO_TOKEN_HANDLE hSpnegoToken, SPNEGO_MECH_OID
 
 int spnegoGetContextFlags( SPNEGO_TOKEN_HANDLE hSpnegoToken, unsigned char* pucContextFlags )
 {
-   int   nReturn = SPNEGO_E_INVALID_PARAMETER;
-   SPNEGO_TOKEN*  pSpnegoToken = (SPNEGO_TOKEN*) hSpnegoToken;
-   
-   // Check parameters
-   if (  IsValidSpnegoToken( pSpnegoToken ) &&
-         NULL != pucContextFlags &&
-         SPNEGO_TOKEN_INIT == pSpnegoToken->ucTokenType )
-   {
-
-      // Check if ContextFlags is available
-      if ( pSpnegoToken->aElementArray[SPNEGO_INIT_REQFLAGS_ELEMENT].iElementPresent
-            == SPNEGO_TOKEN_ELEMENT_AVAILABLE )
-      {
-         // The length should be two, the value should show a 1 bit difference in the difference byte, and
-         // the value must be valid
-         if ( pSpnegoToken->aElementArray[SPNEGO_INIT_REQFLAGS_ELEMENT].nDatalength == SPNEGO_NEGINIT_MAXLEN_REQFLAGS &&
-               pSpnegoToken->aElementArray[SPNEGO_INIT_REQFLAGS_ELEMENT].pbData[0] == SPNEGO_NEGINIT_REQFLAGS_BITDIFF &&
-               IsValidContextFlags( pSpnegoToken->aElementArray[SPNEGO_INIT_REQFLAGS_ELEMENT].pbData[1] ) )
-         {
-            *pucContextFlags = pSpnegoToken->aElementArray[SPNEGO_INIT_REQFLAGS_ELEMENT].pbData[1];
-            nReturn = SPNEGO_E_SUCCESS;
-         }
-         else
-         {
-            nReturn = SPNEGO_E_INVALID_ELEMENT;
-         }
-
-      }
-      else
-      {
-         nReturn = SPNEGO_E_ELEMENT_UNAVAILABLE;
-      }
-
-   }  // IF parameters OK
-
-   LOG(("spnegoGetContextFlags returned %d\n",nReturn));
-   return nReturn;;
+    int   nReturn = SPNEGO_E_INVALID_PARAMETER;
+    SPNEGO_TOKEN*  pSpnegoToken = (SPNEGO_TOKEN*) hSpnegoToken;
+
+    // Check parameters
+    if (  IsValidSpnegoToken( pSpnegoToken ) &&
+            NULL != pucContextFlags &&
+            SPNEGO_TOKEN_INIT == pSpnegoToken->ucTokenType ) {
+
+        // Check if ContextFlags is available
+        if ( pSpnegoToken->aElementArray[SPNEGO_INIT_REQFLAGS_ELEMENT].iElementPresent
+                == SPNEGO_TOKEN_ELEMENT_AVAILABLE ) {
+            // The length should be two, the value should show a 1 bit difference in the difference byte, and
+            // the value must be valid
+            if ( pSpnegoToken->aElementArray[SPNEGO_INIT_REQFLAGS_ELEMENT].nDatalength == SPNEGO_NEGINIT_MAXLEN_REQFLAGS &&
+                    pSpnegoToken->aElementArray[SPNEGO_INIT_REQFLAGS_ELEMENT].pbData[0] == SPNEGO_NEGINIT_REQFLAGS_BITDIFF &&
+                    IsValidContextFlags( pSpnegoToken->aElementArray[SPNEGO_INIT_REQFLAGS_ELEMENT].pbData[1] ) ) {
+                *pucContextFlags = pSpnegoToken->aElementArray[SPNEGO_INIT_REQFLAGS_ELEMENT].pbData[1];
+                nReturn = SPNEGO_E_SUCCESS;
+            } else {
+                nReturn = SPNEGO_E_INVALID_ELEMENT;
+            }
+
+        } else {
+            nReturn = SPNEGO_E_ELEMENT_UNAVAILABLE;
+        }
+
+    }  // IF parameters OK
+
+    LOG(("spnegoGetContextFlags returned %d\n",nReturn));
+    return nReturn;;
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -546,40 +517,33 @@ int spnegoGetContextFlags( SPNEGO_TOKEN_HANDLE hSpnegoToken, unsigned char* pucC
 
 int spnegoGetNegotiationResult( SPNEGO_TOKEN_HANDLE hSpnegoToken, SPNEGO_NEGRESULT* pnegResult )
 {
-   int   nReturn = SPNEGO_E_INVALID_PARAMETER;
-   SPNEGO_TOKEN*  pSpnegoToken = (SPNEGO_TOKEN*) hSpnegoToken;
-   
-   // Check parameters
-   if (  IsValidSpnegoToken( pSpnegoToken ) &&
-         NULL != pnegResult &&
-         SPNEGO_TOKEN_TARG == pSpnegoToken->ucTokenType )
-   {
-
-      // Check if NegResult is available
-      if ( pSpnegoToken->aElementArray[SPNEGO_TARG_NEGRESULT_ELEMENT].iElementPresent
-            == SPNEGO_TOKEN_ELEMENT_AVAILABLE )
-      {
-         // Must be 1 byte long and a valid value
-         if ( pSpnegoToken->aElementArray[SPNEGO_TARG_NEGRESULT_ELEMENT].nDatalength == SPNEGO_NEGTARG_MAXLEN_NEGRESULT &&
-               IsValidNegResult( *pSpnegoToken->aElementArray[SPNEGO_TARG_NEGRESULT_ELEMENT].pbData ) )
-         {
-            *pnegResult = *pSpnegoToken->aElementArray[SPNEGO_TARG_NEGRESULT_ELEMENT].pbData;
-            nReturn = SPNEGO_E_SUCCESS;
-         }
-         else
-         {
-            nReturn = SPNEGO_E_INVALID_ELEMENT;
-         }
-      }
-      else
-      {
-         nReturn = SPNEGO_E_ELEMENT_UNAVAILABLE;
-      }
-
-   }  // IF parameters OK
-
-   LOG(("spnegoGetNegotiationResult returned %d\n",nReturn));
-   return nReturn;;
+    int   nReturn = SPNEGO_E_INVALID_PARAMETER;
+    SPNEGO_TOKEN*  pSpnegoToken = (SPNEGO_TOKEN*) hSpnegoToken;
+
+    // Check parameters
+    if (  IsValidSpnegoToken( pSpnegoToken ) &&
+            NULL != pnegResult &&
+            SPNEGO_TOKEN_TARG == pSpnegoToken->ucTokenType ) {
+
+        // Check if NegResult is available
+        if ( pSpnegoToken->aElementArray[SPNEGO_TARG_NEGRESULT_ELEMENT].iElementPresent
+                == SPNEGO_TOKEN_ELEMENT_AVAILABLE ) {
+            // Must be 1 byte long and a valid value
+            if ( pSpnegoToken->aElementArray[SPNEGO_TARG_NEGRESULT_ELEMENT].nDatalength == SPNEGO_NEGTARG_MAXLEN_NEGRESULT &&
+                    IsValidNegResult( *pSpnegoToken->aElementArray[SPNEGO_TARG_NEGRESULT_ELEMENT].pbData ) ) {
+                *pnegResult = *pSpnegoToken->aElementArray[SPNEGO_TARG_NEGRESULT_ELEMENT].pbData;
+                nReturn = SPNEGO_E_SUCCESS;
+            } else {
+                nReturn = SPNEGO_E_INVALID_ELEMENT;
+            }
+        } else {
+            nReturn = SPNEGO_E_ELEMENT_UNAVAILABLE;
+        }
+
+    }  // IF parameters OK
+
+    LOG(("spnegoGetNegotiationResult returned %d\n",nReturn));
+    return nReturn;;
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -606,50 +570,44 @@ int spnegoGetNegotiationResult( SPNEGO_TOKEN_HANDLE hSpnegoToken, SPNEGO_NEGRESU
 
 int spnegoGetSupportedMechType( SPNEGO_TOKEN_HANDLE hSpnegoToken, SPNEGO_MECH_OID* pMechOID  )
 {
-   int   nReturn = SPNEGO_E_INVALID_PARAMETER;
-   int   nCtr = 0L;
-   long  nLength = 0L;
-   SPNEGO_TOKEN*  pSpnegoToken = (SPNEGO_TOKEN*) hSpnegoToken;
-   
-   // Check parameters
-   if (  IsValidSpnegoToken( pSpnegoToken ) &&
-         NULL != pMechOID &&
-         SPNEGO_TOKEN_TARG == pSpnegoToken->ucTokenType )
-   {
-
-      // Check if MechList is available
-      if ( pSpnegoToken->aElementArray[SPNEGO_TARG_SUPPMECH_ELEMENT].iElementPresent
-            == SPNEGO_TOKEN_ELEMENT_AVAILABLE )
-      {
-         
-         for ( nCtr = 0;
-               nReturn != SPNEGO_E_SUCCESS &&
-               g_stcMechOIDList[nCtr].eMechanismOID != spnego_mech_oid_NotUsed;
-               nCtr++ )
-         {
-
-            if ( ( nReturn = ASNDerCheckOID(
-                        pSpnegoToken->aElementArray[SPNEGO_TARG_SUPPMECH_ELEMENT].pbData,
-                        nCtr,
-                        pSpnegoToken->aElementArray[SPNEGO_TARG_SUPPMECH_ELEMENT].nDatalength,
-                        &nLength ) ) == SPNEGO_E_SUCCESS )
-            {
-               *pMechOID = nCtr;
-            }
+    int   nReturn = SPNEGO_E_INVALID_PARAMETER;
+    int   nCtr = 0L;
+    long  nLength = 0L;
+    SPNEGO_TOKEN*  pSpnegoToken = (SPNEGO_TOKEN*) hSpnegoToken;
+
+    // Check parameters
+    if (  IsValidSpnegoToken( pSpnegoToken ) &&
+            NULL != pMechOID &&
+            SPNEGO_TOKEN_TARG == pSpnegoToken->ucTokenType ) {
 
-         }  // For enum MechOIDs
+        // Check if MechList is available
+        if ( pSpnegoToken->aElementArray[SPNEGO_TARG_SUPPMECH_ELEMENT].iElementPresent
+                == SPNEGO_TOKEN_ELEMENT_AVAILABLE ) {
 
+            for ( nCtr = 0;
+                    nReturn != SPNEGO_E_SUCCESS &&
+                    g_stcMechOIDList[nCtr].eMechanismOID != spnego_mech_oid_NotUsed;
+                    nCtr++ ) {
 
-      }
-      else
-      {
-         nReturn = SPNEGO_E_ELEMENT_UNAVAILABLE;
-      }
+                if ( ( nReturn = ASNDerCheckOID(
+                                     pSpnegoToken->aElementArray[SPNEGO_TARG_SUPPMECH_ELEMENT].pbData,
+                                     nCtr,
+                                     pSpnegoToken->aElementArray[SPNEGO_TARG_SUPPMECH_ELEMENT].nDatalength,
+                                     &nLength ) ) == SPNEGO_E_SUCCESS ) {
+                    *pMechOID = nCtr;
+                }
 
-   }  // IF parameters OK
+            }  // For enum MechOIDs
 
-   LOG(("spnegoGetSupportedMechType returned %d\n",nReturn));
-   return nReturn;;
+
+        } else {
+            nReturn = SPNEGO_E_ELEMENT_UNAVAILABLE;
+        }
+
+    }  // IF parameters OK
+
+    LOG(("spnegoGetSupportedMechType returned %d\n",nReturn));
+    return nReturn;;
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -681,52 +639,42 @@ int spnegoGetSupportedMechType( SPNEGO_TOKEN_HANDLE hSpnegoToken, SPNEGO_MECH_OI
 
 int spnegoGetMechToken( SPNEGO_TOKEN_HANDLE hSpnegoToken, unsigned char* pbTokenData, unsigned long* pulDataLen )
 {
-   int   nReturn = SPNEGO_E_INVALID_PARAMETER;
-   SPNEGO_TOKEN*  pSpnegoToken = (SPNEGO_TOKEN*) hSpnegoToken;
-   SPNEGO_ELEMENT*   pSpnegoElement = NULL;
-   
-   // Check parameters
-   if (  IsValidSpnegoToken( pSpnegoToken ) &&
-         NULL != pulDataLen )
-   {
-
-      // Point at the proper Element
-      if ( SPNEGO_TOKEN_INIT == pSpnegoToken->ucTokenType )
-      {
-         pSpnegoElement = &pSpnegoToken->aElementArray[SPNEGO_INIT_MECHTOKEN_ELEMENT];
-      }
-      else
-      {
-         pSpnegoElement = &pSpnegoToken->aElementArray[SPNEGO_TARG_RESPTOKEN_ELEMENT];
-      }
-
-      // Check if MechType is available
-      if ( SPNEGO_TOKEN_ELEMENT_AVAILABLE == pSpnegoElement->iElementPresent  )
-      {
-         // Check for Buffer too small conditions
-         if ( NULL == pbTokenData ||
-               pSpnegoElement->nDatalength > *pulDataLen )
-         {
-            *pulDataLen = pSpnegoElement->nDatalength;
-            nReturn = SPNEGO_E_BUFFER_TOO_SMALL;
-         }
-         else
-         {
-            // Copy Memory
-            memcpy( pbTokenData, pSpnegoElement->pbData, pSpnegoElement->nDatalength );
-            *pulDataLen = pSpnegoElement->nDatalength;
-            nReturn = SPNEGO_E_SUCCESS;
-         }
-      }
-      else
-      {
-         nReturn = SPNEGO_E_ELEMENT_UNAVAILABLE;
-      }
+    int   nReturn = SPNEGO_E_INVALID_PARAMETER;
+    SPNEGO_TOKEN*  pSpnegoToken = (SPNEGO_TOKEN*) hSpnegoToken;
+    SPNEGO_ELEMENT*   pSpnegoElement = NULL;
+
+    // Check parameters
+    if (  IsValidSpnegoToken( pSpnegoToken ) &&
+            NULL != pulDataLen ) {
+
+        // Point at the proper Element
+        if ( SPNEGO_TOKEN_INIT == pSpnegoToken->ucTokenType ) {
+            pSpnegoElement = &pSpnegoToken->aElementArray[SPNEGO_INIT_MECHTOKEN_ELEMENT];
+        } else {
+            pSpnegoElement = &pSpnegoToken->aElementArray[SPNEGO_TARG_RESPTOKEN_ELEMENT];
+        }
+
+        // Check if MechType is available
+        if ( SPNEGO_TOKEN_ELEMENT_AVAILABLE == pSpnegoElement->iElementPresent  ) {
+            // Check for Buffer too small conditions
+            if ( NULL == pbTokenData ||
+                    pSpnegoElement->nDatalength > *pulDataLen ) {
+                *pulDataLen = pSpnegoElement->nDatalength;
+                nReturn = SPNEGO_E_BUFFER_TOO_SMALL;
+            } else {
+                // Copy Memory
+                memcpy( pbTokenData, pSpnegoElement->pbData, pSpnegoElement->nDatalength );
+                *pulDataLen = pSpnegoElement->nDatalength;
+                nReturn = SPNEGO_E_SUCCESS;
+            }
+        } else {
+            nReturn = SPNEGO_E_ELEMENT_UNAVAILABLE;
+        }
 
-   }  // IF parameters OK
+    }  // IF parameters OK
 
-   LOG(("spnegoGetMechToken returned %d\n",nReturn));
-   return nReturn;;
+    LOG(("spnegoGetMechToken returned %d\n",nReturn));
+    return nReturn;;
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -756,51 +704,41 @@ int spnegoGetMechToken( SPNEGO_TOKEN_HANDLE hSpnegoToken, unsigned char* pbToken
 
 int spnegoGetMechListMIC( SPNEGO_TOKEN_HANDLE hSpnegoToken, unsigned char* pbMICData, unsigned long* pulDataLen )
 {
-   int   nReturn = SPNEGO_E_INVALID_PARAMETER;
-   SPNEGO_TOKEN*  pSpnegoToken = (SPNEGO_TOKEN*) hSpnegoToken;
-   SPNEGO_ELEMENT*   pSpnegoElement = NULL;
-   
-   // Check parameters
-   if (  IsValidSpnegoToken( pSpnegoToken ) &&
-         NULL != pulDataLen )
-   {
-
-      // Point at the proper Element
-      if ( SPNEGO_TOKEN_INIT == pSpnegoToken->ucTokenType )
-      {
-         pSpnegoElement = &pSpnegoToken->aElementArray[SPNEGO_INIT_MECHLISTMIC_ELEMENT];
-      }
-      else
-      {
-         pSpnegoElement = &pSpnegoToken->aElementArray[SPNEGO_TARG_MECHLISTMIC_ELEMENT];
-      }
-
-      // Check if MechType is available
-      if ( SPNEGO_TOKEN_ELEMENT_AVAILABLE == pSpnegoElement->iElementPresent  )
-      {
-         // Check for Buffer too small conditions
-         if ( NULL == pbMICData ||
-               pSpnegoElement->nDatalength > *pulDataLen )
-         {
-            *pulDataLen = pSpnegoElement->nDatalength;
-            nReturn = SPNEGO_E_BUFFER_TOO_SMALL;
-         }
-         else
-         {
-            // Copy Memory
-            memcpy( pbMICData, pSpnegoElement->pbData, pSpnegoElement->nDatalength );
-            *pulDataLen = pSpnegoElement->nDatalength;
-            nReturn = SPNEGO_E_SUCCESS;
-         }
-      }
-      else
-      {
-         nReturn = SPNEGO_E_ELEMENT_UNAVAILABLE;
-      }
+    int   nReturn = SPNEGO_E_INVALID_PARAMETER;
+    SPNEGO_TOKEN*  pSpnegoToken = (SPNEGO_TOKEN*) hSpnegoToken;
+    SPNEGO_ELEMENT*   pSpnegoElement = NULL;
+
+    // Check parameters
+    if (  IsValidSpnegoToken( pSpnegoToken ) &&
+            NULL != pulDataLen ) {
+
+        // Point at the proper Element
+        if ( SPNEGO_TOKEN_INIT == pSpnegoToken->ucTokenType ) {
+            pSpnegoElement = &pSpnegoToken->aElementArray[SPNEGO_INIT_MECHLISTMIC_ELEMENT];
+        } else {
+            pSpnegoElement = &pSpnegoToken->aElementArray[SPNEGO_TARG_MECHLISTMIC_ELEMENT];
+        }
+
+        // Check if MechType is available
+        if ( SPNEGO_TOKEN_ELEMENT_AVAILABLE == pSpnegoElement->iElementPresent  ) {
+            // Check for Buffer too small conditions
+            if ( NULL == pbMICData ||
+                    pSpnegoElement->nDatalength > *pulDataLen ) {
+                *pulDataLen = pSpnegoElement->nDatalength;
+                nReturn = SPNEGO_E_BUFFER_TOO_SMALL;
+            } else {
+                // Copy Memory
+                memcpy( pbMICData, pSpnegoElement->pbData, pSpnegoElement->nDatalength );
+                *pulDataLen = pSpnegoElement->nDatalength;
+                nReturn = SPNEGO_E_SUCCESS;
+            }
+        } else {
+            nReturn = SPNEGO_E_ELEMENT_UNAVAILABLE;
+        }
 
-   }  // IF parameters OK
+    }  // IF parameters OK
 
-   LOG(("spnegoGetMechListMIC returned %d\n",nReturn));
-   return nReturn;;
+    LOG(("spnegoGetMechListMIC returned %d\n",nReturn));
+    return nReturn;;
 }
 
@@ -37,32 +37,31 @@ extern "C"
 // Users of SPNEGO Token Handler API will request
 // these as well as free them,
 //
-typedef void*  SPNEGO_TOKEN_HANDLE;
+    typedef void*  SPNEGO_TOKEN_HANDLE;
 
 //
 // Defines the element types that are found
 // in each of the tokens.
 //
 
-typedef enum spnego_element_type
-{
-   spnego_element_min,  // Lower bound
+    typedef enum spnego_element_type {
+        spnego_element_min,  // Lower bound
 
-   // Init token elements
-   spnego_init_mechtypes, 
-   spnego_init_reqFlags,
-   spnego_init_mechToken,
-   spnego_init_mechListMIC,
+        // Init token elements
+        spnego_init_mechtypes,
+        spnego_init_reqFlags,
+        spnego_init_mechToken,
+        spnego_init_mechListMIC,
 
-   // Targ token elements
-   spnego_targ_negResult,
-   spnego_targ_supportedMech,
-   spnego_targ_responseToken,
-   spnego_targ_mechListMIC,
+        // Targ token elements
+        spnego_targ_negResult,
+        spnego_targ_supportedMech,
+        spnego_targ_responseToken,
+        spnego_targ_mechListMIC,
 
-   spnego_element_max   // Upper bound
+        spnego_element_max   // Upper bound
 
-} SPNEGO_ELEMENT_TYPE;
+    } SPNEGO_ELEMENT_TYPE;
 
 //
 // Token Element Availability.  Elements in both
@@ -89,27 +88,25 @@ typedef enum spnego_element_type
 // defined in the parsing code.
 //
 
-typedef enum spnego_mech_oid
-{
-   // Init token elements
-   spnego_mech_oid_Kerberos_V5_Legacy, // Really V5, but OID off by 1 bit
-   spnego_mech_oid_Kerberos_V5,
-   spnego_mech_oid_Spnego,
-   spnego_mech_oid_NotUsed = -1
+    typedef enum spnego_mech_oid {
+        // Init token elements
+        spnego_mech_oid_Kerberos_V5_Legacy, // Really V5, but OID off by 1 bit
+        spnego_mech_oid_Kerberos_V5,
+        spnego_mech_oid_Spnego,
+        spnego_mech_oid_NotUsed = -1
 
-} SPNEGO_MECH_OID;
+    } SPNEGO_MECH_OID;
 
 //
 // Defines the negResult values.
 //
 
-typedef enum spnego_negResult
-{
-   spnego_negresult_success,
-   spnego_negresult_incomplete,
-   spnego_negresult_rejected,
-   spnego_negresult_NotUsed = -1
-} SPNEGO_NEGRESULT;
+    typedef enum spnego_negResult {
+        spnego_negresult_success,
+        spnego_negresult_incomplete,
+        spnego_negresult_rejected,
+        spnego_negresult_NotUsed = -1
+    } SPNEGO_NEGRESULT;
 
 //
 // Context Flags in NegTokenInit
@@ -180,68 +177,68 @@ typedef enum spnego_negResult
 // A Token Element was invalid (e.g. improper length or value)
 #define SPNEGO_E_INVALID_ELEMENT       -13
 
-/* Miscelaneous API Functions */
+    /* Miscelaneous API Functions */
 
 // Frees opaque data
-void spnegoFreeData( SPNEGO_TOKEN_HANDLE hSpnegoToken );
+    void spnegoFreeData( SPNEGO_TOKEN_HANDLE hSpnegoToken );
 
 // Initializes SPNEGO_TOKEN structure from DER encoded binary data
-int spnegoInitFromBinary( unsigned char* pbTokenData, unsigned long ulLength, SPNEGO_TOKEN_HANDLE* phSpnegoToken );
+    int spnegoInitFromBinary( unsigned char* pbTokenData, unsigned long ulLength, SPNEGO_TOKEN_HANDLE* phSpnegoToken );
 
 // Initializes SPNEGO_TOKEN structure for a NegTokenInit type using the
 // supplied parameters
-int spnegoCreateNegTokenInit( SPNEGO_MECH_OID MechType,
-          unsigned char ucContextFlags, unsigned char* pbMechToken,
-          unsigned long ulMechTokenLen, unsigned char* pbMechTokenMIC,
-          unsigned long ulMechTokenMIC, SPNEGO_TOKEN_HANDLE* phSpnegoToken );
+    int spnegoCreateNegTokenInit( SPNEGO_MECH_OID MechType,
+                                  unsigned char ucContextFlags, unsigned char* pbMechToken,
+                                  unsigned long ulMechTokenLen, unsigned char* pbMechTokenMIC,
+                                  unsigned long ulMechTokenMIC, SPNEGO_TOKEN_HANDLE* phSpnegoToken );
 
 // Initializes SPNEGO_TOKEN structure for a NegTokenTarg type using the
 // supplied parameters
-int spnegoCreateNegTokenTarg( SPNEGO_MECH_OID MechType, 
-          SPNEGO_NEGRESULT spnegoNegResult, unsigned char* pbMechToken,
-          unsigned long ulMechTokenLen, unsigned char* pbMechListMIC,
-          unsigned long ulMechListMICLen, SPNEGO_TOKEN_HANDLE* phSpnegoToken );
+    int spnegoCreateNegTokenTarg( SPNEGO_MECH_OID MechType,
+                                  SPNEGO_NEGRESULT spnegoNegResult, unsigned char* pbMechToken,
+                                  unsigned long ulMechTokenLen, unsigned char* pbMechListMIC,
+                                  unsigned long ulMechListMICLen, SPNEGO_TOKEN_HANDLE* phSpnegoToken );
 
 // Copies binary representation of SPNEGO Data into user supplied buffer
-int spnegoTokenGetBinary( SPNEGO_TOKEN_HANDLE hSpnegoToken, unsigned char* pbTokenData,
-                           unsigned long * pulDataLen );
+    int spnegoTokenGetBinary( SPNEGO_TOKEN_HANDLE hSpnegoToken, unsigned char* pbTokenData,
+                              unsigned long * pulDataLen );
 
 // Returns SPNEGO Token Type
-int spnegoGetTokenType( SPNEGO_TOKEN_HANDLE hSpnegoToken, int * piTokenType );
+    int spnegoGetTokenType( SPNEGO_TOKEN_HANDLE hSpnegoToken, int * piTokenType );
 
-/* Reading an Init Token */
+    /* Reading an Init Token */
 
 // Returns the Initial Mech Type in the MechList element in the NegInitToken.
-int spnegoIsMechTypeAvailable( SPNEGO_TOKEN_HANDLE hSpnegoToken, SPNEGO_MECH_OID MechOID, int * piMechTypeIndex );
+    int spnegoIsMechTypeAvailable( SPNEGO_TOKEN_HANDLE hSpnegoToken, SPNEGO_MECH_OID MechOID, int * piMechTypeIndex );
 
 // Returns the value from the context flags element in the NegInitToken as an unsigned long
-int spnegoGetContextFlags( SPNEGO_TOKEN_HANDLE hSpnegoToken, unsigned char* pucContextFlags );
+    int spnegoGetContextFlags( SPNEGO_TOKEN_HANDLE hSpnegoToken, unsigned char* pucContextFlags );
 
-/* Reading a Response Token */
+    /* Reading a Response Token */
 
 // Returns the value from the negResult element (Status code of GSS call - 0,1,2)
-int spnegoGetNegotiationResult( SPNEGO_TOKEN_HANDLE hSpnegoToken, SPNEGO_NEGRESULT* pnegResult );
+    int spnegoGetNegotiationResult( SPNEGO_TOKEN_HANDLE hSpnegoToken, SPNEGO_NEGRESULT* pnegResult );
 
 // Returns the Supported Mech Type from the NegTokenTarg.
-int spnegoGetSupportedMechType( SPNEGO_TOKEN_HANDLE hSpnegoToken, SPNEGO_MECH_OID* pMechOID  );
+    int spnegoGetSupportedMechType( SPNEGO_TOKEN_HANDLE hSpnegoToken, SPNEGO_MECH_OID* pMechOID  );
 
-/* Reading either Token Type */
+    /* Reading either Token Type */
 
 // Returns the actual Mechanism data from the token (this is what is passed into GSS-API functions
-int spnegoGetMechToken( SPNEGO_TOKEN_HANDLE hSpnegoToken, unsigned char* pbTokenData, unsigned long* pulDataLen );
+    int spnegoGetMechToken( SPNEGO_TOKEN_HANDLE hSpnegoToken, unsigned char* pbTokenData, unsigned long* pulDataLen );
 
 // Returns the Message Integrity BLOB in the token
-int spnegoGetMechListMIC( SPNEGO_TOKEN_HANDLE hSpnegoToken, unsigned char* pbMICData, unsigned long* pulDataLen );
+    int spnegoGetMechListMIC( SPNEGO_TOKEN_HANDLE hSpnegoToken, unsigned char* pbMICData, unsigned long* pulDataLen );
 
 // C++ Specific
 #if defined(__cplusplus)
 }
 #endif
 #ifdef DEBUG
 #include <stdio.h>
-  #define PRERR(...) fprintf(stderr, __VA_ARGS__)
-  #define LOG(x) PRERR x
+#define PRERR(...) fprintf(stderr, __VA_ARGS__)
+#define LOG(x) PRERR x
 #else
-  #define LOG(x)
+#define LOG(x)
 #endif
 #endif
@@ -39,8 +39,8 @@ int makeNegTokenTarg (const unsigned char *  kerberosToken,
     /* Check arguments. */
 
     if (!kerberosToken ||
-        !negTokenTarg  ||
-        !negTokenTargLength)
+            !negTokenTarg  ||
+            !negTokenTargLength)
         return 10;
 
     /* Does IIS reply with 1.2.840.48018.1.2.2 or 1.2.840.113554.1.2.2? */
@@ -57,8 +57,7 @@ int makeNegTokenTarg (const unsigned char *  kerberosToken,
                                     0,
                                     &hSpnegoToken);
 
-    if (rc2 != SPNEGO_E_SUCCESS)
-    {
+    if (rc2 != SPNEGO_E_SUCCESS) {
         rc1 = abs(rc2)+100;
         goto cleanup;
     }
@@ -69,29 +68,26 @@ int makeNegTokenTarg (const unsigned char *  kerberosToken,
                                 NULL,
                                 (unsigned long*) negTokenTargLength);
 
-    if (rc2 != SPNEGO_E_BUFFER_TOO_SMALL)
-    {
+    if (rc2 != SPNEGO_E_BUFFER_TOO_SMALL) {
         rc1 = abs(rc2)+200;
         goto cleanup;
     }
 
     *negTokenTarg = malloc (*negTokenTargLength);
 
-    if (!*negTokenTarg)
-    {
+    if (!*negTokenTarg) {
         rc1 = abs(rc2)+300;
         goto cleanup;
     }
 
     /* Get NegTokenTarg data. */
 
     rc2 = spnegoTokenGetBinary (hSpnegoToken,
-                              (unsigned char *) *negTokenTarg,
-                              (unsigned long*) negTokenTargLength);
+                                (unsigned char *) *negTokenTarg,
+                                (unsigned long*) negTokenTargLength);
 
 
-    if (rc2 != SPNEGO_E_SUCCESS)
-    {
+    if (rc2 != SPNEGO_E_SUCCESS) {
         rc1 = abs(rc2)+400;
         goto error;
     }
@@ -102,8 +98,7 @@ int makeNegTokenTarg (const unsigned char *  kerberosToken,
 
 error:
 
-    if (*negTokenTarg)
-    {
+    if (*negTokenTarg) {
         free ((unsigned char *) *negTokenTarg);
         *negTokenTarg = NULL;
         *negTokenTargLength = 0;
@@ -133,8 +128,8 @@ int parseNegTokenInit (const unsigned char *  negTokenInit,
     /* Check arguments. */
 
     if (!negTokenInit  ||
-        !kerberosToken ||
-        !kerberosTokenLength)
+            !kerberosToken ||
+            !kerberosTokenLength)
         return 10;
 
     /* Decode SPNEGO token. */
@@ -143,8 +138,7 @@ int parseNegTokenInit (const unsigned char *  negTokenInit,
                                 negTokenInitLength,
                                 &hSpnegoToken);
 
-    if (rc2 != SPNEGO_E_SUCCESS)
-    {
+    if (rc2 != SPNEGO_E_SUCCESS) {
         rc1 = abs(rc2)+100;
         goto cleanup;
     }
@@ -154,40 +148,36 @@ int parseNegTokenInit (const unsigned char *  negTokenInit,
     rc2 = spnegoGetTokenType (hSpnegoToken,
                               &tokenType);
 
-    if (rc2 != SPNEGO_E_SUCCESS)
-    {
+    if (rc2 != SPNEGO_E_SUCCESS) {
         rc1 = abs(rc2)+200;
         goto cleanup;
     }
 
-    if (tokenType != SPNEGO_TOKEN_INIT)
-    {
+    if (tokenType != SPNEGO_TOKEN_INIT) {
         rc1 = abs(rc2)+300;
         goto cleanup;
     }
 
-   /*
-    Check that first mechType is 1.2.840.113554.1.2.2 or 1.2.840.48018.1.2.2.
-    */
+    /*
+     Check that first mechType is 1.2.840.113554.1.2.2 or 1.2.840.48018.1.2.2.
+     */
 
-   /*
-    IE seems to reply with 1.2.840.48018.1.2.2 and then 1.2.840.113554.1.2.2.
-    */
+    /*
+     IE seems to reply with 1.2.840.48018.1.2.2 and then 1.2.840.113554.1.2.2.
+     */
 
     rc2 = spnegoIsMechTypeAvailable (hSpnegoToken,
                                      spnego_mech_oid_Kerberos_V5_Legacy,
                                      &pindex);
 
     if (rc2 != SPNEGO_E_SUCCESS ||
-        pindex != 0)
-    {
+            pindex != 0) {
         rc2 = spnegoIsMechTypeAvailable (hSpnegoToken,
                                          spnego_mech_oid_Kerberos_V5,
                                          &pindex);
 
         if (rc2 != SPNEGO_E_SUCCESS ||
-            pindex != 0)
-        {
+                pindex != 0) {
             rc1 = abs(rc2)+400;
             goto cleanup;
         }
@@ -200,8 +190,7 @@ int parseNegTokenInit (const unsigned char *  negTokenInit,
     rc2 = spnegoGetContextFlags (hSpnegoToken,
                                  &reqFlags);
 
-    if (rc2 == SPNEGO_E_SUCCESS)
-    {
+    if (rc2 == SPNEGO_E_SUCCESS) {
         rc1 = abs(rc2)+500;
         goto cleanup;
     }
@@ -212,16 +201,14 @@ int parseNegTokenInit (const unsigned char *  negTokenInit,
                               NULL,
                               (unsigned long*) kerberosTokenLength);
 
-    if (rc2 != SPNEGO_E_BUFFER_TOO_SMALL)
-    {
+    if (rc2 != SPNEGO_E_BUFFER_TOO_SMALL) {
         rc1 = abs(rc2)+600;
         goto cleanup;
     }
 
     *kerberosToken = malloc (*kerberosTokenLength);
 
-    if (!*kerberosToken)
-    {
+    if (!*kerberosToken) {
         rc1 = abs(rc2)+700;
         goto cleanup;
     }
@@ -232,8 +219,7 @@ int parseNegTokenInit (const unsigned char *  negTokenInit,
                               (unsigned char *) *kerberosToken,
                               (unsigned long*) kerberosTokenLength);
 
-    if (rc2 != SPNEGO_E_SUCCESS)
-    {
+    if (rc2 != SPNEGO_E_SUCCESS) {
         rc1 = abs(rc2)+800;
         goto error;
     }
@@ -246,8 +232,7 @@ int parseNegTokenInit (const unsigned char *  negTokenInit,
 
 error:
 
-    if (*kerberosToken)
-    {
+    if (*kerberosToken) {
         free ((unsigned char *) *kerberosToken);
         *kerberosToken = NULL;
         *kerberosTokenLength = 0;
@@ -8,51 +8,53 @@
  */
 
 #ifndef SPNEGOHELP_H
-#define SPNEGOHELP_H
+#define SPNEGOHELP_H
 
 #ifdef __cplusplus
-extern "C" {
+extern "C"
+{
 #endif
-
+
 #include <stddef.h>
 
-/* -----------------------------------------------------------------------------
- * makeNegTokenTarg makes an RFC 2478 SPNEGO NegTokenTarg (token) from an
- * RFC 1964 Kerberos GSS-API token.
- *
- * If makeNegTokenTarg is successful, call free (*negTokenTarg) to free the
- * memory allocated by parseNegTokenInit.
- *
- * Returns 0 if successful, 1 otherwise.
- * -----------------------------------------------------------------------------
- */
-
-int makeNegTokenTarg (const unsigned char *  kerberosToken,
-                      size_t                 kerberosTokenLength,
-                      const unsigned char ** negTokenTarg,
-                      size_t *               negTokenTargLength);
-
-/* -----------------------------------------------------------------------------
- * parseNegTokenInit parses an RFC 2478 SPNEGO NegTokenInit (token) to extract
- * an RFC 1964 Kerberos GSS-API token.
- *
- * If the NegTokenInit does cotain a Kerberos GSS-API token, parseNegTokenInit
- * returns an error.
- *
- * If parseNegTokenInit is successful, call free (*kerberosToken) to
- * free the memory allocated by parseNegTokenInit.
- *
- * Returns 0 if successful, 1 otherwise.
- * -----------------------------------------------------------------------------
- */
-
-int parseNegTokenInit (const unsigned char *  negTokenInit,
-                       size_t                 negTokenInitLength,
-                       const unsigned char ** kerberosToken,
-                       size_t *               kerberosTokenLength);
+    /* -----------------------------------------------------------------------------
+     * makeNegTokenTarg makes an RFC 2478 SPNEGO NegTokenTarg (token) from an
+     * RFC 1964 Kerberos GSS-API token.
+     *
+     * If makeNegTokenTarg is successful, call free (*negTokenTarg) to free the
+     * memory allocated by parseNegTokenInit.
+     *
+     * Returns 0 if successful, 1 otherwise.
+     * -----------------------------------------------------------------------------
+     */
+
+    int makeNegTokenTarg (const unsigned char *  kerberosToken,
+                          size_t                 kerberosTokenLength,
+                          const unsigned char ** negTokenTarg,
+                          size_t *               negTokenTargLength);
+
+    /* -----------------------------------------------------------------------------
+     * parseNegTokenInit parses an RFC 2478 SPNEGO NegTokenInit (token) to extract
+     * an RFC 1964 Kerberos GSS-API token.
+     *
+     * If the NegTokenInit does cotain a Kerberos GSS-API token, parseNegTokenInit
+     * returns an error.
+     *
+     * If parseNegTokenInit is successful, call free (*kerberosToken) to
+     * free the memory allocated by parseNegTokenInit.
+     *
+     * Returns 0 if successful, 1 otherwise.
+     * -----------------------------------------------------------------------------
+     */
+
+    int parseNegTokenInit (const unsigned char *  negTokenInit,
+                           size_t                 negTokenInitLength,
+                           const unsigned char ** kerberosToken,
+                           size_t *               kerberosTokenLength);
 
 #ifdef __cplusplus
-}
+}
 #endif
-
+
 #endif /* SPNEGOHELP_H */
+
\ No newline at end of file
@@ -75,128 +75,117 @@ extern MECH_OID g_stcMechOIDList [];
 ////////////////////////////////////////////////////////////////////////////
 
 int CalculateMinSpnegoInitTokenSize( long nMechTokenLength,
-                                 long nMechListMICLength, SPNEGO_MECH_OID mechOid,
-                                 int nReqFlagsAvailable, long* pnTokenSize,
-                                 long* pnInternalTokenLength )
+                                     long nMechListMICLength, SPNEGO_MECH_OID mechOid,
+                                     int nReqFlagsAvailable, long* pnTokenSize,
+                                     long* pnInternalTokenLength )
 {
-   int   nReturn = SPNEGO_E_INVALID_LENGTH;
+    int   nReturn = SPNEGO_E_INVALID_LENGTH;
 
-   // Start at 0.
-   long  nTotalLength = 0;
-   long  nTempLength= 0L;
+    // Start at 0.
+    long  nTotalLength = 0;
+    long  nTempLength= 0L;
 
-   // We will calculate this by walking the token backwards
+    // We will calculate this by walking the token backwards
 
-   // Start with MIC Element
-   if ( nMechListMICLength > 0L )
-   {
-      nTempLength = ASNDerCalcElementLength( nMechListMICLength, NULL );
+    // Start with MIC Element
+    if ( nMechListMICLength > 0L ) {
+        nTempLength = ASNDerCalcElementLength( nMechListMICLength, NULL );
 
-      // Check for rollover error
-      if ( nTempLength < nMechListMICLength )
-      {
-         goto xEndTokenInitLength;
-      }
+        // Check for rollover error
+        if ( nTempLength < nMechListMICLength ) {
+            goto xEndTokenInitLength;
+        }
 
-      nTotalLength += nTempLength;
-   }
+        nTotalLength += nTempLength;
+    }
 
-   // Next is the MechToken
-   if ( nMechTokenLength > 0L )
-   {
-      nTempLength += ASNDerCalcElementLength( nMechTokenLength, NULL );
+    // Next is the MechToken
+    if ( nMechTokenLength > 0L ) {
+        nTempLength += ASNDerCalcElementLength( nMechTokenLength, NULL );
 
-      // Check for rollover error
-      if ( nTempLength < nTotalLength )
-      {
-         goto xEndTokenInitLength;
-      }
+        // Check for rollover error
+        if ( nTempLength < nTotalLength ) {
+            goto xEndTokenInitLength;
+        }
 
-      nTotalLength = nTempLength;
-   }
+        nTotalLength = nTempLength;
+    }
 
-   // Next is the ReqFlags
-   if ( nReqFlagsAvailable )
-   {
-      nTempLength += ASNDerCalcElementLength( SPNEGO_NEGINIT_MAXLEN_REQFLAGS, NULL );
+    // Next is the ReqFlags
+    if ( nReqFlagsAvailable ) {
+        nTempLength += ASNDerCalcElementLength( SPNEGO_NEGINIT_MAXLEN_REQFLAGS, NULL );
 
-      // Check for rollover error
-      if ( nTempLength < nTotalLength )
-      {
-         goto xEndTokenInitLength;
-      }
+        // Check for rollover error
+        if ( nTempLength < nTotalLength ) {
+            goto xEndTokenInitLength;
+        }
 
-      nTotalLength = nTempLength;
-   }
+        nTotalLength = nTempLength;
+    }
 
-   // Next is the MechList - This is REQUIRED
-   nTempLength += ASNDerCalcMechListLength( mechOid, NULL );
+    // Next is the MechList - This is REQUIRED
+    nTempLength += ASNDerCalcMechListLength( mechOid, NULL );
 
-   // Check for rollover error
-   if ( nTempLength < nTotalLength )
-   {
-      goto xEndTokenInitLength;
-   }
+    // Check for rollover error
+    if ( nTempLength < nTotalLength ) {
+        goto xEndTokenInitLength;
+    }
 
-   nTotalLength = nTempLength;
+    nTotalLength = nTempLength;
 
-   // Following four fields are the basic header tokens
+    // Following four fields are the basic header tokens
 
-   // Sequence Token
-   nTempLength += ASNDerCalcTokenLength( nTotalLength, 0L );
+    // Sequence Token
+    nTempLength += ASNDerCalcTokenLength( nTotalLength, 0L );
 
-   // Check for rollover error
-   if ( nTempLength < nTotalLength )
-   {
-      goto xEndTokenInitLength;
-   }
+    // Check for rollover error
+    if ( nTempLength < nTotalLength ) {
+        goto xEndTokenInitLength;
+    }
 
-   nTotalLength = nTempLength;
+    nTotalLength = nTempLength;
 
-   // Neg Token Identifier Token
-   nTempLength += ASNDerCalcTokenLength( nTotalLength, 0L );
+    // Neg Token Identifier Token
+    nTempLength += ASNDerCalcTokenLength( nTotalLength, 0L );
 
-   // Check for rollover error
-   if ( nTempLength < nTotalLength )
-   {
-      goto xEndTokenInitLength;
-   }
+    // Check for rollover error
+    if ( nTempLength < nTotalLength ) {
+        goto xEndTokenInitLength;
+    }
 
-   nTotalLength = nTempLength;
+    nTotalLength = nTempLength;
 
-   // SPNEGO OID Token
-   nTempLength += g_stcMechOIDList[spnego_mech_oid_Spnego].iLen;
+    // SPNEGO OID Token
+    nTempLength += g_stcMechOIDList[spnego_mech_oid_Spnego].iLen;
 
-   // Check for rollover error
-   if ( nTempLength < nTotalLength )
-   {
-      goto xEndTokenInitLength;
-   }
+    // Check for rollover error
+    if ( nTempLength < nTotalLength ) {
+        goto xEndTokenInitLength;
+    }
 
-   nTotalLength = nTempLength;
+    nTotalLength = nTempLength;
 
-   // App Constructed Token
-   nTempLength += ASNDerCalcTokenLength( nTotalLength, 0L );
+    // App Constructed Token
+    nTempLength += ASNDerCalcTokenLength( nTotalLength, 0L );
 
-   // Check for rollover error
-   if ( nTempLength < nTotalLength )
-   {
-      goto xEndTokenInitLength;
-   }
+    // Check for rollover error
+    if ( nTempLength < nTotalLength ) {
+        goto xEndTokenInitLength;
+    }
 
-   // The internal length doesn't include the number of bytes
-   // for the initial token
-   *pnInternalTokenLength = nTotalLength;
-   nTotalLength = nTempLength;
+    // The internal length doesn't include the number of bytes
+    // for the initial token
+    *pnInternalTokenLength = nTotalLength;
+    nTotalLength = nTempLength;
 
-   // We're done
-   *pnTokenSize = nTotalLength;
-   nReturn = SPNEGO_E_SUCCESS;
+    // We're done
+    *pnTokenSize = nTotalLength;
+    nReturn = SPNEGO_E_SUCCESS;
 
 xEndTokenInitLength:
 
-   LOG(("CalculateMinSpnegoInitTokenSize returned %d\n",nReturn));
-   return nReturn;
+    LOG(("CalculateMinSpnegoInitTokenSize returned %d\n",nReturn));
+    return nReturn;
 
 }
 
@@ -231,201 +220,190 @@ int CalculateMinSpnegoInitTokenSize( long nMechTokenLength,
 ////////////////////////////////////////////////////////////////////////////
 
 int CreateSpnegoInitToken( SPNEGO_MECH_OID MechType,
-          unsigned char ucContextFlags, unsigned char* pbMechToken,
-          unsigned long ulMechTokenLen, unsigned char* pbMechListMIC,
-          unsigned long ulMechListMICLen, unsigned char* pbTokenData,
-          long nTokenLength, long nInternalTokenLength )
+                           unsigned char ucContextFlags, unsigned char* pbMechToken,
+                           unsigned long ulMechTokenLen, unsigned char* pbMechListMIC,
+                           unsigned long ulMechListMICLen, unsigned char* pbTokenData,
+                           long nTokenLength, long nInternalTokenLength )
 {
-   int   nReturn = SPNEGO_E_INVALID_LENGTH;
+    int   nReturn = SPNEGO_E_INVALID_LENGTH;
 
-   // Start at 0.
-   long  nTempLength= 0L;
-   long  nTotalBytesWritten = 0L;
-   long  nInternalLength = 0L;
+    // Start at 0.
+    long  nTempLength= 0L;
+    long  nTotalBytesWritten = 0L;
+    long  nInternalLength = 0L;
 
-   unsigned char* pbWriteTokenData = pbTokenData + nTokenLength;
+    unsigned char* pbWriteTokenData = pbTokenData + nTokenLength;
 
-   // Temporary buffer to hold the REQ Flags as BIT String Data
-   unsigned char  abTempReqFlags[SPNEGO_NEGINIT_MAXLEN_REQFLAGS];
+    // Temporary buffer to hold the REQ Flags as BIT String Data
+    unsigned char  abTempReqFlags[SPNEGO_NEGINIT_MAXLEN_REQFLAGS];
 
 
-   // We will write the token out backwards to properly handle the cases
-   // where the length bytes become adjustable
+    // We will write the token out backwards to properly handle the cases
+    // where the length bytes become adjustable
 
-   // Start with MIC Element
-   if ( ulMechListMICLen > 0L )
-   {
-      nTempLength = ASNDerCalcElementLength( ulMechListMICLen, &nInternalLength );
+    // Start with MIC Element
+    if ( ulMechListMICLen > 0L ) {
+        nTempLength = ASNDerCalcElementLength( ulMechListMICLen, &nInternalLength );
 
-      // Decrease the pbWriteTokenData, now we know the length and
-      // write it out.
+        // Decrease the pbWriteTokenData, now we know the length and
+        // write it out.
 
-      pbWriteTokenData -= nTempLength;
-      nTempLength = ASNDerWriteElement( pbWriteTokenData, SPNEGO_NEGINIT_ELEMENT_MECHLISTMIC,
-                              OCTETSTRING, pbMechListMIC, ulMechListMICLen );
+        pbWriteTokenData -= nTempLength;
+        nTempLength = ASNDerWriteElement( pbWriteTokenData, SPNEGO_NEGINIT_ELEMENT_MECHLISTMIC,
+                                          OCTETSTRING, pbMechListMIC, ulMechListMICLen );
 
-      // Adjust Values and sanity check
-      nTotalBytesWritten += nTempLength;
-      nInternalTokenLength -= nTempLength;
+        // Adjust Values and sanity check
+        nTotalBytesWritten += nTempLength;
+        nInternalTokenLength -= nTempLength;
 
-      if ( nTotalBytesWritten > nTokenLength || nInternalTokenLength < 0 )
-      {
-         goto xEndWriteNegTokenInit;
-      }
+        if ( nTotalBytesWritten > nTokenLength || nInternalTokenLength < 0 ) {
+            goto xEndWriteNegTokenInit;
+        }
 
-   }  // IF MechListMIC is present
+    }  // IF MechListMIC is present
 
-   // Next is the MechToken
-   if ( ulMechTokenLen > 0L )
-   {
-      nTempLength = ASNDerCalcElementLength( ulMechTokenLen, &nInternalLength );
+    // Next is the MechToken
+    if ( ulMechTokenLen > 0L ) {
+        nTempLength = ASNDerCalcElementLength( ulMechTokenLen, &nInternalLength );
 
-      // Decrease the pbWriteTokenData, now we know the length and
-      // write it out.
-      pbWriteTokenData -= nTempLength;
-      nTempLength = ASNDerWriteElement( pbWriteTokenData, SPNEGO_NEGINIT_ELEMENT_MECHTOKEN,
-                              OCTETSTRING, pbMechToken, ulMechTokenLen );
-      // Adjust Values and sanity check
-      nTotalBytesWritten += nTempLength;
-      nInternalTokenLength -= nTempLength;
+        // Decrease the pbWriteTokenData, now we know the length and
+        // write it out.
+        pbWriteTokenData -= nTempLength;
+        nTempLength = ASNDerWriteElement( pbWriteTokenData, SPNEGO_NEGINIT_ELEMENT_MECHTOKEN,
+                                          OCTETSTRING, pbMechToken, ulMechTokenLen );
+        // Adjust Values and sanity check
+        nTotalBytesWritten += nTempLength;
+        nInternalTokenLength -= nTempLength;
 
-      if ( nTotalBytesWritten > nTokenLength || nInternalTokenLength < 0 )
-      {
-         goto xEndWriteNegTokenInit;
-      }
-  
-   }  // IF MechToken Length is present
+        if ( nTotalBytesWritten > nTokenLength || nInternalTokenLength < 0 ) {
+            goto xEndWriteNegTokenInit;
+        }
 
-   // Next is the ReqFlags
-   if ( ucContextFlags > 0L )
-   {
+    }  // IF MechToken Length is present
 
-      nTempLength = ASNDerCalcElementLength( SPNEGO_NEGINIT_MAXLEN_REQFLAGS, &nInternalLength );
+    // Next is the ReqFlags
+    if ( ucContextFlags > 0L ) {
 
-      // We need a byte that indicates how many bits difference between the number
-      // of bits used in final octet (we only have one) and the max (8)
+        nTempLength = ASNDerCalcElementLength( SPNEGO_NEGINIT_MAXLEN_REQFLAGS, &nInternalLength );
 
-      abTempReqFlags[0] = SPNEGO_NEGINIT_REQFLAGS_BITDIFF;
-      abTempReqFlags[1] = ucContextFlags;
+        // We need a byte that indicates how many bits difference between the number
+        // of bits used in final octet (we only have one) and the max (8)
 
-      // Decrease the pbWriteTokenData, now we know the length and
-      // write it out.
-      pbWriteTokenData -= nTempLength;
-      nTempLength = ASNDerWriteElement( pbWriteTokenData, SPNEGO_NEGINIT_ELEMENT_REQFLAGS,
-                              BITSTRING, abTempReqFlags, SPNEGO_NEGINIT_MAXLEN_REQFLAGS );
+        abTempReqFlags[0] = SPNEGO_NEGINIT_REQFLAGS_BITDIFF;
+        abTempReqFlags[1] = ucContextFlags;
 
-      // Adjust Values and sanity check
-      nTotalBytesWritten += nTempLength;
-      nInternalTokenLength -= nTempLength;
+        // Decrease the pbWriteTokenData, now we know the length and
+        // write it out.
+        pbWriteTokenData -= nTempLength;
+        nTempLength = ASNDerWriteElement( pbWriteTokenData, SPNEGO_NEGINIT_ELEMENT_REQFLAGS,
+                                          BITSTRING, abTempReqFlags, SPNEGO_NEGINIT_MAXLEN_REQFLAGS );
 
-      if ( nTotalBytesWritten > nTokenLength || nInternalTokenLength < 0 )
-      {
-         goto xEndWriteNegTokenInit;
-      }
+        // Adjust Values and sanity check
+        nTotalBytesWritten += nTempLength;
+        nInternalTokenLength -= nTempLength;
 
-   }  // IF ContextFlags
+        if ( nTotalBytesWritten > nTokenLength || nInternalTokenLength < 0 ) {
+            goto xEndWriteNegTokenInit;
+        }
 
-   // Next is the MechList - This is REQUIRED
-   nTempLength = ASNDerCalcMechListLength( MechType, &nInternalLength );
+    }  // IF ContextFlags
 
-   // Decrease the pbWriteTokenData, now we know the length and
-   // write it out.
-   pbWriteTokenData -= nTempLength;
-   nTempLength = ASNDerWriteMechList( pbWriteTokenData, MechType );
+    // Next is the MechList - This is REQUIRED
+    nTempLength = ASNDerCalcMechListLength( MechType, &nInternalLength );
 
-   // Adjust Values and sanity check
-   nTotalBytesWritten += nTempLength;
-   nInternalTokenLength -= nTempLength;
+    // Decrease the pbWriteTokenData, now we know the length and
+    // write it out.
+    pbWriteTokenData -= nTempLength;
+    nTempLength = ASNDerWriteMechList( pbWriteTokenData, MechType );
 
-   if ( nTotalBytesWritten > nTokenLength || nInternalTokenLength < 0 )
-   {
-      goto xEndWriteNegTokenInit;
-   }
+    // Adjust Values and sanity check
+    nTotalBytesWritten += nTempLength;
+    nInternalTokenLength -= nTempLength;
 
-   // The next tokens we're writing out reflect the total number of bytes
-   // we have actually written out.
+    if ( nTotalBytesWritten > nTokenLength || nInternalTokenLength < 0 ) {
+        goto xEndWriteNegTokenInit;
+    }
 
-   // Sequence Token
-   nTempLength = ASNDerCalcTokenLength( nTotalBytesWritten, 0L );
+    // The next tokens we're writing out reflect the total number of bytes
+    // we have actually written out.
 
-   // Decrease the pbWriteTokenData, now we know the length and
-   // write it out.
-   pbWriteTokenData -= nTempLength;
-   nTempLength = ASNDerWriteToken( pbWriteTokenData, SPNEGO_CONSTRUCTED_SEQUENCE,
+    // Sequence Token
+    nTempLength = ASNDerCalcTokenLength( nTotalBytesWritten, 0L );
+
+    // Decrease the pbWriteTokenData, now we know the length and
+    // write it out.
+    pbWriteTokenData -= nTempLength;
+    nTempLength = ASNDerWriteToken( pbWriteTokenData, SPNEGO_CONSTRUCTED_SEQUENCE,
                                     NULL, nTotalBytesWritten );
 
-   // Adjust Values and sanity check
-   nTotalBytesWritten += nTempLength;
-   nInternalTokenLength -= nTempLength;
+    // Adjust Values and sanity check
+    nTotalBytesWritten += nTempLength;
+    nInternalTokenLength -= nTempLength;
 
-   if ( nTotalBytesWritten > nTokenLength || nInternalTokenLength < 0 )
-   {
-      goto xEndWriteNegTokenInit;
-   }
+    if ( nTotalBytesWritten > nTokenLength || nInternalTokenLength < 0 ) {
+        goto xEndWriteNegTokenInit;
+    }
 
-   // Neg Init Token Identifier Token
-   nTempLength = ASNDerCalcTokenLength( nTotalBytesWritten, 0L );
+    // Neg Init Token Identifier Token
+    nTempLength = ASNDerCalcTokenLength( nTotalBytesWritten, 0L );
 
-   // Decrease the pbWriteTokenData, now we know the length and
-   // write it out.
-   pbWriteTokenData -= nTempLength;
-   nTempLength = ASNDerWriteToken( pbWriteTokenData, SPNEGO_NEGINIT_TOKEN_IDENTIFIER,
+    // Decrease the pbWriteTokenData, now we know the length and
+    // write it out.
+    pbWriteTokenData -= nTempLength;
+    nTempLength = ASNDerWriteToken( pbWriteTokenData, SPNEGO_NEGINIT_TOKEN_IDENTIFIER,
                                     NULL, nTotalBytesWritten );
 
-   // Adjust Values and sanity check
-   nTotalBytesWritten += nTempLength;
-   nInternalTokenLength -= nTempLength;
-
-   if ( nTotalBytesWritten > nTokenLength || nInternalTokenLength < 0 )
-   {
-      goto xEndWriteNegTokenInit;
-   }
-
-   // SPNEGO OID Token
-   nTempLength = g_stcMechOIDList[spnego_mech_oid_Spnego].iLen;
-
-   // Decrease the pbWriteTokenData, now we know the length and
-   // write it out.
-   pbWriteTokenData -= nTempLength;
-   nTempLength = ASNDerWriteOID( pbWriteTokenData, spnego_mech_oid_Spnego );
-
-   // Adjust Values and sanity check
-   nTotalBytesWritten += nTempLength;
-   nInternalTokenLength -= nTempLength;
-
-   if ( nTotalBytesWritten > nTokenLength || nInternalTokenLength < 0 )
-   {
-      goto xEndWriteNegTokenInit;
-   }
-
-   // App Constructed Token
-   nTempLength = ASNDerCalcTokenLength( nTotalBytesWritten, 0L );
-   
-   // Decrease the pbWriteTokenData, now we know the length and
-   // write it out.
-   pbWriteTokenData -= nTempLength;
-   nTempLength = ASNDerWriteToken( pbWriteTokenData, SPNEGO_NEGINIT_APP_CONSTRUCT,
+    // Adjust Values and sanity check
+    nTotalBytesWritten += nTempLength;
+    nInternalTokenLength -= nTempLength;
+
+    if ( nTotalBytesWritten > nTokenLength || nInternalTokenLength < 0 ) {
+        goto xEndWriteNegTokenInit;
+    }
+
+    // SPNEGO OID Token
+    nTempLength = g_stcMechOIDList[spnego_mech_oid_Spnego].iLen;
+
+    // Decrease the pbWriteTokenData, now we know the length and
+    // write it out.
+    pbWriteTokenData -= nTempLength;
+    nTempLength = ASNDerWriteOID( pbWriteTokenData, spnego_mech_oid_Spnego );
+
+    // Adjust Values and sanity check
+    nTotalBytesWritten += nTempLength;
+    nInternalTokenLength -= nTempLength;
+
+    if ( nTotalBytesWritten > nTokenLength || nInternalTokenLength < 0 ) {
+        goto xEndWriteNegTokenInit;
+    }
+
+    // App Constructed Token
+    nTempLength = ASNDerCalcTokenLength( nTotalBytesWritten, 0L );
+
+    // Decrease the pbWriteTokenData, now we know the length and
+    // write it out.
+    pbWriteTokenData -= nTempLength;
+    nTempLength = ASNDerWriteToken( pbWriteTokenData, SPNEGO_NEGINIT_APP_CONSTRUCT,
                                     NULL, nTotalBytesWritten );
 
-   // Adjust Values and sanity check
-   nTotalBytesWritten += nTempLength;
+    // Adjust Values and sanity check
+    nTotalBytesWritten += nTempLength;
 
-   // Don't adjust the internal token length here, it doesn't account
-   // the initial bytes written out (we really don't need to keep
-   // a running count here, but for debugging, it helps to be able
-   // to see the total number of bytes written out as well as the
-   // number of bytes left to write).
+    // Don't adjust the internal token length here, it doesn't account
+    // the initial bytes written out (we really don't need to keep
+    // a running count here, but for debugging, it helps to be able
+    // to see the total number of bytes written out as well as the
+    // number of bytes left to write).
 
-   if ( nTotalBytesWritten == nTokenLength && nInternalTokenLength == 0 &&
-         pbWriteTokenData == pbTokenData )
-   {
-      nReturn = SPNEGO_E_SUCCESS;
-   }
+    if ( nTotalBytesWritten == nTokenLength && nInternalTokenLength == 0 &&
+            pbWriteTokenData == pbTokenData ) {
+        nReturn = SPNEGO_E_SUCCESS;
+    }
 
 xEndWriteNegTokenInit:
 
-   LOG(("CreateSpnegoInitToken returned %d\n",nReturn));
-   return nReturn;
+    LOG(("CreateSpnegoInitToken returned %d\n",nReturn));
+    return nReturn;
 
 }
 
@@ -458,114 +436,104 @@ int CreateSpnegoInitToken( SPNEGO_MECH_OID MechType,
 ////////////////////////////////////////////////////////////////////////////
 
 int CalculateMinSpnegoTargTokenSize( SPNEGO_MECH_OID MechType,
-                                    SPNEGO_NEGRESULT spnegoNegResult, long nMechTokenLen,
-                                    long nMechListMICLen, long* pnTokenSize,
-                                    long* pnInternalTokenLength )
+                                     SPNEGO_NEGRESULT spnegoNegResult, long nMechTokenLen,
+                                     long nMechListMICLen, long* pnTokenSize,
+                                     long* pnInternalTokenLength )
 {
-   int   nReturn = SPNEGO_E_INVALID_LENGTH;
+    int   nReturn = SPNEGO_E_INVALID_LENGTH;
 
-   // Start at 0.
-   long  nTotalLength = 0;
-   long  nTempLength= 0L;
+    // Start at 0.
+    long  nTotalLength = 0;
+    long  nTempLength= 0L;
 
-   // We will calculate this by walking the token backwards
+    // We will calculate this by walking the token backwards
 
-   // Start with MIC Element
-   if ( nMechListMICLen > 0L )
-   {
-      nTempLength = ASNDerCalcElementLength( nMechListMICLen, NULL );
+    // Start with MIC Element
+    if ( nMechListMICLen > 0L ) {
+        nTempLength = ASNDerCalcElementLength( nMechListMICLen, NULL );
 
-      // Check for rollover error
-      if ( nTempLength < nMechListMICLen )
-      {
-         goto xEndTokenTargLength;
-      }
+        // Check for rollover error
+        if ( nTempLength < nMechListMICLen ) {
+            goto xEndTokenTargLength;
+        }
 
-      nTotalLength += nTempLength;
-   }
+        nTotalLength += nTempLength;
+    }
 
-   // Next is the MechToken
-   if ( nMechTokenLen > 0L )
-   {
-      nTempLength += ASNDerCalcElementLength( nMechTokenLen, NULL );
+    // Next is the MechToken
+    if ( nMechTokenLen > 0L ) {
+        nTempLength += ASNDerCalcElementLength( nMechTokenLen, NULL );
 
-      // Check for rollover error
-      if ( nTempLength < nTotalLength )
-      {
-         goto xEndTokenTargLength;
-      }
+        // Check for rollover error
+        if ( nTempLength < nTotalLength ) {
+            goto xEndTokenTargLength;
+        }
 
-      nTotalLength = nTempLength;
-   }
+        nTotalLength = nTempLength;
+    }
 
-   // Supported MechType
-   if ( spnego_mech_oid_NotUsed != MechType )
-   {
-      // Supported MechOID element - we use the token function since
-      // we already know the size of the OID token and value
-      nTempLength += ASNDerCalcElementLength( g_stcMechOIDList[MechType].iActualDataLen,
-                                             NULL );
+    // Supported MechType
+    if ( spnego_mech_oid_NotUsed != MechType ) {
+        // Supported MechOID element - we use the token function since
+        // we already know the size of the OID token and value
+        nTempLength += ASNDerCalcElementLength( g_stcMechOIDList[MechType].iActualDataLen,
+                                                NULL );
 
-      // Check for rollover error
-      if ( nTempLength < nTotalLength )
-      {
-         goto xEndTokenTargLength;
-      }
+        // Check for rollover error
+        if ( nTempLength < nTotalLength ) {
+            goto xEndTokenTargLength;
+        }
 
-      nTotalLength = nTempLength;
+        nTotalLength = nTempLength;
 
-   }  // IF MechType is available
+    }  // IF MechType is available
 
-   // NegResult Element
-   if ( spnego_negresult_NotUsed != spnegoNegResult )
-   {
-      nTempLength += ASNDerCalcElementLength( SPNEGO_NEGTARG_MAXLEN_NEGRESULT, NULL );
+    // NegResult Element
+    if ( spnego_negresult_NotUsed != spnegoNegResult ) {
+        nTempLength += ASNDerCalcElementLength( SPNEGO_NEGTARG_MAXLEN_NEGRESULT, NULL );
 
-      // Check for rollover error
-      if ( nTempLength < nTotalLength )
-      {
-         goto xEndTokenTargLength;
-      }
+        // Check for rollover error
+        if ( nTempLength < nTotalLength ) {
+            goto xEndTokenTargLength;
+        }
 
-      nTotalLength = nTempLength;
+        nTotalLength = nTempLength;
 
-   }  // IF negResult is available
+    }  // IF negResult is available
 
-   // Following two fields are the basic header tokens
+    // Following two fields are the basic header tokens
 
-   // Sequence Token
-   nTempLength += ASNDerCalcTokenLength( nTotalLength, 0L );
+    // Sequence Token
+    nTempLength += ASNDerCalcTokenLength( nTotalLength, 0L );
 
-   // Check for rollover error
-   if ( nTempLength < nTotalLength )
-   {
-      goto xEndTokenTargLength;
-   }
+    // Check for rollover error
+    if ( nTempLength < nTotalLength ) {
+        goto xEndTokenTargLength;
+    }
 
-   nTotalLength = nTempLength;
+    nTotalLength = nTempLength;
 
-   // Neg Token Identifier Token
-   nTempLength += ASNDerCalcTokenLength( nTotalLength, 0L );
+    // Neg Token Identifier Token
+    nTempLength += ASNDerCalcTokenLength( nTotalLength, 0L );
 
-   // Check for rollover error
-   if ( nTempLength < nTotalLength )
-   {
-      goto xEndTokenTargLength;
-   }
+    // Check for rollover error
+    if ( nTempLength < nTotalLength ) {
+        goto xEndTokenTargLength;
+    }
 
-   // The internal length doesn't include the number of bytes
-   // for the initial token
-   *pnInternalTokenLength = nTotalLength;
-   nTotalLength = nTempLength;
+    // The internal length doesn't include the number of bytes
+    // for the initial token
+    *pnInternalTokenLength = nTotalLength;
+    nTotalLength = nTempLength;
 
-   // We're done
-   *pnTokenSize = nTotalLength;
-   nReturn = SPNEGO_E_SUCCESS;
+    // We're done
+    *pnTokenSize = nTotalLength;
+    nReturn = SPNEGO_E_SUCCESS;
 
 xEndTokenTargLength:
 
-   LOG(("CalculateMinSpnegoTargTokenSize returned %d\n",nReturn));
-   return nReturn;
+    LOG(("CalculateMinSpnegoTargTokenSize returned %d\n",nReturn));
+    return nReturn;
 
 }
 
@@ -600,171 +568,161 @@ int CalculateMinSpnegoTargTokenSize( SPNEGO_MECH_OID MechType,
 ////////////////////////////////////////////////////////////////////////////
 
 int CreateSpnegoTargToken( SPNEGO_MECH_OID MechType,
-          SPNEGO_NEGRESULT eNegResult, unsigned char* pbMechToken,
-          unsigned long ulMechTokenLen, unsigned char* pbMechListMIC,
-          unsigned long ulMechListMICLen, unsigned char* pbTokenData,
-          long nTokenLength, long nInternalTokenLength )
+                           SPNEGO_NEGRESULT eNegResult, unsigned char* pbMechToken,
+                           unsigned long ulMechTokenLen, unsigned char* pbMechListMIC,
+                           unsigned long ulMechListMICLen, unsigned char* pbTokenData,
+                           long nTokenLength, long nInternalTokenLength )
 {
-   int   nReturn = SPNEGO_E_INVALID_LENGTH;
-
-   // Start at 0.
-   long  nTempLength= 0L;
-   long  nTotalBytesWritten = 0L;
-   long  nInternalLength = 0L;
-
-   unsigned char  ucTemp = 0;
-
-   // We will write the token out backwards to properly handle the cases
-   // where the length bytes become adjustable, so the write location
-   // is initialized to point *just* past the end of the buffer.
+    int   nReturn = SPNEGO_E_INVALID_LENGTH;
+
+    // Start at 0.
+    long  nTempLength= 0L;
+    long  nTotalBytesWritten = 0L;
+    long  nInternalLength = 0L;
+
+    unsigned char  ucTemp = 0;
+
+    // We will write the token out backwards to properly handle the cases
+    // where the length bytes become adjustable, so the write location
+    // is initialized to point *just* past the end of the buffer.
+
+    unsigned char* pbWriteTokenData = pbTokenData + nTokenLength;
+
+
+    // Start with MIC Element
+    if ( ulMechListMICLen > 0L ) {
+        nTempLength = ASNDerCalcElementLength( ulMechListMICLen, &nInternalLength );
+
+        // Decrease the pbWriteTokenData, now we know the length and
+        // write it out.
+
+        pbWriteTokenData -= nTempLength;
+        nTempLength = ASNDerWriteElement( pbWriteTokenData, SPNEGO_NEGTARG_ELEMENT_MECHLISTMIC,
+                                          OCTETSTRING, pbMechListMIC, ulMechListMICLen );
+
+        // Adjust Values and sanity check
+        nTotalBytesWritten += nTempLength;
+        nInternalTokenLength -= nTempLength;
+
+        if ( nTotalBytesWritten > nTokenLength || nInternalTokenLength < 0 ) {
+            goto xEndWriteNegTokenTarg;
+        }
+
+    }  // IF MechListMIC is present
+
+    // Next is the MechToken
+    if ( ulMechTokenLen > 0L ) {
+        nTempLength = ASNDerCalcElementLength( ulMechTokenLen, &nInternalLength );
+
+        // Decrease the pbWriteTokenData, now we know the length and
+        // write it out.
+        pbWriteTokenData -= nTempLength;
+        nTempLength = ASNDerWriteElement( pbWriteTokenData, SPNEGO_NEGTARG_ELEMENT_RESPONSETOKEN,
+                                          OCTETSTRING, pbMechToken, ulMechTokenLen );
+        // Adjust Values and sanity check
+        nTotalBytesWritten += nTempLength;
+        nInternalTokenLength -= nTempLength;
+
+        if ( nTotalBytesWritten > nTokenLength || nInternalTokenLength < 0 ) {
+            goto xEndWriteNegTokenTarg;
+        }
 
-   unsigned char* pbWriteTokenData = pbTokenData + nTokenLength;
+    }  // IF MechToken Length is present
 
+    // Supported Mech Type
+    if ( spnego_mech_oid_NotUsed != MechType ) {
 
-   // Start with MIC Element
-   if ( ulMechListMICLen > 0L )
-   {
-      nTempLength = ASNDerCalcElementLength( ulMechListMICLen, &nInternalLength );
-
-      // Decrease the pbWriteTokenData, now we know the length and
-      // write it out.
-
-      pbWriteTokenData -= nTempLength;
-      nTempLength = ASNDerWriteElement( pbWriteTokenData, SPNEGO_NEGTARG_ELEMENT_MECHLISTMIC,
-                              OCTETSTRING, pbMechListMIC, ulMechListMICLen );
-
-      // Adjust Values and sanity check
-      nTotalBytesWritten += nTempLength;
-      nInternalTokenLength -= nTempLength;
-
-      if ( nTotalBytesWritten > nTokenLength || nInternalTokenLength < 0 )
-      {
-         goto xEndWriteNegTokenTarg;
-      }
-
-   }  // IF MechListMIC is present
-
-   // Next is the MechToken
-   if ( ulMechTokenLen > 0L )
-   {
-      nTempLength = ASNDerCalcElementLength( ulMechTokenLen, &nInternalLength );
-
-      // Decrease the pbWriteTokenData, now we know the length and
-      // write it out.
-      pbWriteTokenData -= nTempLength;
-      nTempLength = ASNDerWriteElement( pbWriteTokenData, SPNEGO_NEGTARG_ELEMENT_RESPONSETOKEN,
-                              OCTETSTRING, pbMechToken, ulMechTokenLen );
-      // Adjust Values and sanity check
-      nTotalBytesWritten += nTempLength;
-      nInternalTokenLength -= nTempLength;
-
-      if ( nTotalBytesWritten > nTokenLength || nInternalTokenLength < 0 )
-      {
-         goto xEndWriteNegTokenTarg;
-      }
-  
-   }  // IF MechToken Length is present
-
-   // Supported Mech Type
-   if ( spnego_mech_oid_NotUsed != MechType )
-   {
-
-      nTempLength = ASNDerCalcElementLength( g_stcMechOIDList[MechType].iActualDataLen,
-                                             &nInternalLength );
-
-      // Decrease the pbWriteTokenData, now we know the length and
-      // write it out.
-      pbWriteTokenData -= nTempLength;
-      nTempLength = ASNDerWriteToken( pbWriteTokenData, SPNEGO_NEGTARG_ELEMENT_SUPPORTEDMECH,
-                                       g_stcMechOIDList[MechType].ucOid,
-                                       g_stcMechOIDList[MechType].iLen );
-
-      // Adjust Values and sanity check
-      nTotalBytesWritten += nTempLength;
-      nInternalTokenLength -= nTempLength;
-
-      if ( nTotalBytesWritten > nTokenLength || nInternalTokenLength < 0 )
-      {
-         goto xEndWriteNegTokenTarg;
-      }
-
-   }  // IF MechType is present
-
-   // Neg Result
-   // NegResult Element
-   if ( spnego_negresult_NotUsed != eNegResult )
-   {
-      ucTemp = (unsigned char) eNegResult;
-
-      nTempLength = ASNDerCalcElementLength( SPNEGO_NEGTARG_MAXLEN_NEGRESULT, &nInternalLength );
-
-      // Decrease the pbWriteTokenData, now we know the length and
-      // write it out.
-      pbWriteTokenData -= nTempLength;
-      nTempLength = ASNDerWriteElement( pbWriteTokenData, SPNEGO_NEGTARG_ELEMENT_NEGRESULT,
-                              ENUMERATED, &ucTemp, SPNEGO_NEGTARG_MAXLEN_NEGRESULT );
-
-      // Adjust Values and sanity check
-      nTotalBytesWritten += nTempLength;
-      nInternalTokenLength -= nTempLength;
-
-      if ( nTotalBytesWritten > nTokenLength || nInternalTokenLength < 0 )
-      {
-         goto xEndWriteNegTokenTarg;
-      }
-
-   }  // If eNegResult is available
-
-   // The next tokens we're writing out reflect the total number of bytes
-   // we have actually written out.
-
-   // Sequence Token
-   nTempLength = ASNDerCalcTokenLength( nTotalBytesWritten, 0L );
-
-   // Decrease the pbWriteTokenData, now we know the length and
-   // write it out.
-   pbWriteTokenData -= nTempLength;
-   nTempLength = ASNDerWriteToken( pbWriteTokenData, SPNEGO_CONSTRUCTED_SEQUENCE,
+        nTempLength = ASNDerCalcElementLength( g_stcMechOIDList[MechType].iActualDataLen,
+                                               &nInternalLength );
+
+        // Decrease the pbWriteTokenData, now we know the length and
+        // write it out.
+        pbWriteTokenData -= nTempLength;
+        nTempLength = ASNDerWriteToken( pbWriteTokenData, SPNEGO_NEGTARG_ELEMENT_SUPPORTEDMECH,
+                                        g_stcMechOIDList[MechType].ucOid,
+                                        g_stcMechOIDList[MechType].iLen );
+
+        // Adjust Values and sanity check
+        nTotalBytesWritten += nTempLength;
+        nInternalTokenLength -= nTempLength;
+
+        if ( nTotalBytesWritten > nTokenLength || nInternalTokenLength < 0 ) {
+            goto xEndWriteNegTokenTarg;
+        }
+
+    }  // IF MechType is present
+
+    // Neg Result
+    // NegResult Element
+    if ( spnego_negresult_NotUsed != eNegResult ) {
+        ucTemp = (unsigned char) eNegResult;
+
+        nTempLength = ASNDerCalcElementLength( SPNEGO_NEGTARG_MAXLEN_NEGRESULT, &nInternalLength );
+
+        // Decrease the pbWriteTokenData, now we know the length and
+        // write it out.
+        pbWriteTokenData -= nTempLength;
+        nTempLength = ASNDerWriteElement( pbWriteTokenData, SPNEGO_NEGTARG_ELEMENT_NEGRESULT,
+                                          ENUMERATED, &ucTemp, SPNEGO_NEGTARG_MAXLEN_NEGRESULT );
+
+        // Adjust Values and sanity check
+        nTotalBytesWritten += nTempLength;
+        nInternalTokenLength -= nTempLength;
+
+        if ( nTotalBytesWritten > nTokenLength || nInternalTokenLength < 0 ) {
+            goto xEndWriteNegTokenTarg;
+        }
+
+    }  // If eNegResult is available
+
+    // The next tokens we're writing out reflect the total number of bytes
+    // we have actually written out.
+
+    // Sequence Token
+    nTempLength = ASNDerCalcTokenLength( nTotalBytesWritten, 0L );
+
+    // Decrease the pbWriteTokenData, now we know the length and
+    // write it out.
+    pbWriteTokenData -= nTempLength;
+    nTempLength = ASNDerWriteToken( pbWriteTokenData, SPNEGO_CONSTRUCTED_SEQUENCE,
                                     NULL, nTotalBytesWritten );
 
-   // Adjust Values and sanity check
-   nTotalBytesWritten += nTempLength;
-   nInternalTokenLength -= nTempLength;
+    // Adjust Values and sanity check
+    nTotalBytesWritten += nTempLength;
+    nInternalTokenLength -= nTempLength;
 
-   if ( nTotalBytesWritten > nTokenLength || nInternalTokenLength < 0 )
-   {
-      goto xEndWriteNegTokenTarg;
-   }
+    if ( nTotalBytesWritten > nTokenLength || nInternalTokenLength < 0 ) {
+        goto xEndWriteNegTokenTarg;
+    }
 
-   // Neg Targ Token Identifier Token
-   nTempLength = ASNDerCalcTokenLength( nTotalBytesWritten, 0L );
+    // Neg Targ Token Identifier Token
+    nTempLength = ASNDerCalcTokenLength( nTotalBytesWritten, 0L );
 
-   // Decrease the pbWriteTokenData, now we know the length and
-   // write it out.
-   pbWriteTokenData -= nTempLength;
-   nTempLength = ASNDerWriteToken( pbWriteTokenData, SPNEGO_NEGTARG_TOKEN_IDENTIFIER,
+    // Decrease the pbWriteTokenData, now we know the length and
+    // write it out.
+    pbWriteTokenData -= nTempLength;
+    nTempLength = ASNDerWriteToken( pbWriteTokenData, SPNEGO_NEGTARG_TOKEN_IDENTIFIER,
                                     NULL, nTotalBytesWritten );
 
-   // Adjust Values and sanity check
-   nTotalBytesWritten += nTempLength;
+    // Adjust Values and sanity check
+    nTotalBytesWritten += nTempLength;
 
-   // Don't adjust the internal token length here, it doesn't account
-   // the initial bytes written out (we really don't need to keep
-   // a running count here, but for debugging, it helps to be able
-   // to see the total number of bytes written out as well as the
-   // number of bytes left to write).
+    // Don't adjust the internal token length here, it doesn't account
+    // the initial bytes written out (we really don't need to keep
+    // a running count here, but for debugging, it helps to be able
+    // to see the total number of bytes written out as well as the
+    // number of bytes left to write).
 
-   if ( nTotalBytesWritten == nTokenLength && nInternalTokenLength == 0 &&
-         pbWriteTokenData == pbTokenData )
-   {
-      nReturn = SPNEGO_E_SUCCESS;
-   }
+    if ( nTotalBytesWritten == nTokenLength && nInternalTokenLength == 0 &&
+            pbWriteTokenData == pbTokenData ) {
+        nReturn = SPNEGO_E_SUCCESS;
+    }
 
 
 xEndWriteNegTokenTarg:
 
-   LOG(("CreateSpnegoTargToken returned %d\n",nReturn));
-   return nReturn;
+    LOG(("CreateSpnegoTargToken returned %d\n",nReturn));
+    return nReturn;
 
 
 }
@@ -794,60 +752,54 @@ int CreateSpnegoTargToken( SPNEGO_MECH_OID MechType,
 ////////////////////////////////////////////////////////////////////////////
 
 SPNEGO_TOKEN* AllocEmptySpnegoToken( unsigned char ucCopyData, unsigned long ulFlags,
-                                    unsigned char * pbTokenData, unsigned long ulTokenSize )
+                                     unsigned char * pbTokenData, unsigned long ulTokenSize )
 {
-   SPNEGO_TOKEN*  pSpnegoToken = (SPNEGO_TOKEN*) calloc( 1, sizeof(SPNEGO_TOKEN) );
-
-   if ( NULL != pSpnegoToken )
-   {
-      // Set the token size
-      pSpnegoToken->nStructSize = SPNEGO_TOKEN_SIZE;
-
-      // Initialize the element array
-      InitSpnegoTokenElementArray( pSpnegoToken );
-
-      // Assign the flags value
-      pSpnegoToken->ulFlags = ulFlags;
+    SPNEGO_TOKEN*  pSpnegoToken = (SPNEGO_TOKEN*) calloc( 1, sizeof(SPNEGO_TOKEN) );
+
+    if ( NULL != pSpnegoToken ) {
+        // Set the token size
+        pSpnegoToken->nStructSize = SPNEGO_TOKEN_SIZE;
+
+        // Initialize the element array
+        InitSpnegoTokenElementArray( pSpnegoToken );
+
+        // Assign the flags value
+        pSpnegoToken->ulFlags = ulFlags;
+
+        //
+        // IF ucCopyData is TRUE, we will allocate a buffer and copy data into it.
+        // Otherwise, we will just copy the pointer and the length.  This is so we
+        // can cut out additional allocations for performance reasons
+        //
+
+        if ( SPNEGO_TOKEN_INTERNAL_FLAGS_FREEDATA == ucCopyData ) {
+            // Alloc the internal buffer.  Cleanup on failure.
+            pSpnegoToken->pbBinaryData = (unsigned char*) calloc( ulTokenSize, sizeof(unsigned char) );
+
+            if ( NULL != pSpnegoToken->pbBinaryData ) {
+                // We must ALWAYS free this buffer
+                pSpnegoToken->ulFlags |= SPNEGO_TOKEN_INTERNAL_FLAGS_FREEDATA;
+
+                // Copy the data locally
+                memcpy( pSpnegoToken->pbBinaryData, pbTokenData, ulTokenSize );
+                pSpnegoToken->ulBinaryDataLen = ulTokenSize;
+            } else {
+                free( pSpnegoToken );
+                pSpnegoToken = NULL;
+            }
 
-      //
-      // IF ucCopyData is TRUE, we will allocate a buffer and copy data into it.
-      // Otherwise, we will just copy the pointer and the length.  This is so we
-      // can cut out additional allocations for performance reasons
-      //
+        }  // IF ucCopyData
+        else {
+            // Copy the pointer and the length directly - ulFlags will control whether or not
+            // we are allowed to free the value
 
-      if ( SPNEGO_TOKEN_INTERNAL_FLAGS_FREEDATA == ucCopyData )
-      {
-         // Alloc the internal buffer.  Cleanup on failure.
-         pSpnegoToken->pbBinaryData = (unsigned char*) calloc( ulTokenSize, sizeof(unsigned char) );
+            pSpnegoToken->pbBinaryData = pbTokenData;
+            pSpnegoToken->ulBinaryDataLen = ulTokenSize;
+        }
 
-         if ( NULL != pSpnegoToken->pbBinaryData )
-         {
-            // We must ALWAYS free this buffer
-            pSpnegoToken->ulFlags |= SPNEGO_TOKEN_INTERNAL_FLAGS_FREEDATA;
+    }
 
-            // Copy the data locally
-            memcpy( pSpnegoToken->pbBinaryData, pbTokenData, ulTokenSize );
-            pSpnegoToken->ulBinaryDataLen = ulTokenSize;
-         }
-         else
-         {
-            free( pSpnegoToken );
-            pSpnegoToken = NULL;
-         }
-
-      }  // IF ucCopyData
-      else
-      {
-         // Copy the pointer and the length directly - ulFlags will control whether or not
-         // we are allowed to free the value
-         
-         pSpnegoToken->pbBinaryData = pbTokenData;
-         pSpnegoToken->ulBinaryDataLen = ulTokenSize;
-      }
-
-   }
-
-   return pSpnegoToken;
+    return pSpnegoToken;
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -869,19 +821,17 @@ SPNEGO_TOKEN* AllocEmptySpnegoToken( unsigned char ucCopyData, unsigned long ulF
 
 void FreeSpnegoToken( SPNEGO_TOKEN* pSpnegoToken )
 {
-   if ( NULL != pSpnegoToken )
-   {
-
-      // Cleanup internal allocation per the flags
-      if ( pSpnegoToken->ulFlags & SPNEGO_TOKEN_INTERNAL_FLAGS_FREEDATA &&
-         NULL != pSpnegoToken->pbBinaryData )
-      {
-         free( pSpnegoToken->pbBinaryData );
-         pSpnegoToken->pbBinaryData = NULL;
-      }
-
-      free ( pSpnegoToken );
-   }
+    if ( NULL != pSpnegoToken ) {
+
+        // Cleanup internal allocation per the flags
+        if ( pSpnegoToken->ulFlags & SPNEGO_TOKEN_INTERNAL_FLAGS_FREEDATA &&
+                NULL != pSpnegoToken->pbBinaryData ) {
+            free( pSpnegoToken->pbBinaryData );
+            pSpnegoToken->pbBinaryData = NULL;
+        }
+
+        free ( pSpnegoToken );
+    }
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -903,22 +853,21 @@ void FreeSpnegoToken( SPNEGO_TOKEN* pSpnegoToken )
 
 void InitSpnegoTokenElementArray( SPNEGO_TOKEN* pSpnegoToken )
 {
-   int   nCtr;
-
-   // Set the number of elemnts
-   pSpnegoToken->nNumElements = MAX_NUM_TOKEN_ELEMENTS;
-
-   //
-   // Initially, all elements are unavailable
-   //
-
-   for ( nCtr = 0; nCtr < MAX_NUM_TOKEN_ELEMENTS; nCtr++ )
-   {
-      // Set the element size as well
-      pSpnegoToken->aElementArray[ nCtr ].nStructSize = SPNEGO_ELEMENT_SIZE;
-      pSpnegoToken->aElementArray[ nCtr ].iElementPresent = SPNEGO_TOKEN_ELEMENT_UNAVAILABLE;
-   }
-   
+    int   nCtr;
+
+    // Set the number of elemnts
+    pSpnegoToken->nNumElements = MAX_NUM_TOKEN_ELEMENTS;
+
+    //
+    // Initially, all elements are unavailable
+    //
+
+    for ( nCtr = 0; nCtr < MAX_NUM_TOKEN_ELEMENTS; nCtr++ ) {
+        // Set the element size as well
+        pSpnegoToken->aElementArray[ nCtr ].nStructSize = SPNEGO_ELEMENT_SIZE;
+        pSpnegoToken->aElementArray[ nCtr ].iElementPresent = SPNEGO_TOKEN_ELEMENT_UNAVAILABLE;
+    }
+
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -946,121 +895,112 @@ void InitSpnegoTokenElementArray( SPNEGO_TOKEN* pSpnegoToken )
 ////////////////////////////////////////////////////////////////////////////
 
 int InitSpnegoTokenType( SPNEGO_TOKEN* pSpnegoToken, long* pnTokenLength,
-                           long* pnRemainingTokenLength, unsigned char** ppbFirstElement )
+                         long* pnRemainingTokenLength, unsigned char** ppbFirstElement )
 {
-   int   nReturn = SPNEGO_E_INVALID_TOKEN;
-   long  nActualTokenLength = 0L;
-   long  nBoundaryLength = pSpnegoToken->ulBinaryDataLen;
-   unsigned char* pbTokenData = pSpnegoToken->pbBinaryData;
-
-   //
-   // First byte MUST be either an APP_CONSTRUCT or the NEGTARG_TOKEN_TARG
-   //
-
-   if ( SPNEGO_NEGINIT_APP_CONSTRUCT == *pbTokenData )
-   {
-      // Validate the above token - this will tell us the actual length of the token
-      // per the encoding (minus the actual token bytes)
-      if ( ( nReturn = ASNDerCheckToken( pbTokenData, SPNEGO_NEGINIT_APP_CONSTRUCT, 0L, nBoundaryLength,
-                                          pnTokenLength, &nActualTokenLength ) )
-                       == SPNEGO_E_SUCCESS )
-      {
-         // Initialize the remaining token length value.  This will be used
-         // to tell the caller how much token there is left once we've parsed
-         // the header (they could calculate it from the other values, but this
-         // is a bit friendlier)
-         *pnRemainingTokenLength = *pnTokenLength;
-
-         // Make adjustments to next token
-         pbTokenData += nActualTokenLength;
-         nBoundaryLength -= nActualTokenLength;
-
-         // The next token should be an OID
-         if ( ( nReturn = ASNDerCheckOID( pbTokenData, spnego_mech_oid_Spnego, nBoundaryLength,
-                                          &nActualTokenLength ) ) == SPNEGO_E_SUCCESS )
-         {
+    int   nReturn = SPNEGO_E_INVALID_TOKEN;
+    long  nActualTokenLength = 0L;
+    long  nBoundaryLength = pSpnegoToken->ulBinaryDataLen;
+    unsigned char* pbTokenData = pSpnegoToken->pbBinaryData;
+
+    //
+    // First byte MUST be either an APP_CONSTRUCT or the NEGTARG_TOKEN_TARG
+    //
+
+    if ( SPNEGO_NEGINIT_APP_CONSTRUCT == *pbTokenData ) {
+        // Validate the above token - this will tell us the actual length of the token
+        // per the encoding (minus the actual token bytes)
+        if ( ( nReturn = ASNDerCheckToken( pbTokenData, SPNEGO_NEGINIT_APP_CONSTRUCT, 0L, nBoundaryLength,
+                                           pnTokenLength, &nActualTokenLength ) )
+                == SPNEGO_E_SUCCESS ) {
+            // Initialize the remaining token length value.  This will be used
+            // to tell the caller how much token there is left once we've parsed
+            // the header (they could calculate it from the other values, but this
+            // is a bit friendlier)
+            *pnRemainingTokenLength = *pnTokenLength;
+
             // Make adjustments to next token
             pbTokenData += nActualTokenLength;
             nBoundaryLength -= nActualTokenLength;
-            *pnRemainingTokenLength -= nActualTokenLength;
-
-            // The next token should specify the NegTokenInit
-            if ( ( nReturn = ASNDerCheckToken( pbTokenData, SPNEGO_NEGINIT_TOKEN_IDENTIFIER,
-                                                *pnRemainingTokenLength, nBoundaryLength, pnTokenLength,
-                                                &nActualTokenLength ) )
-                             == SPNEGO_E_SUCCESS )
-            {
-               // Make adjustments to next token
-               pbTokenData += nActualTokenLength;
-               nBoundaryLength -= nActualTokenLength;
-               *pnRemainingTokenLength -= nActualTokenLength;
-
-               // The next token should specify the start of a sequence
-               if ( ( nReturn = ASNDerCheckToken( pbTokenData, SPNEGO_CONSTRUCTED_SEQUENCE,
+
+            // The next token should be an OID
+            if ( ( nReturn = ASNDerCheckOID( pbTokenData, spnego_mech_oid_Spnego, nBoundaryLength,
+                                             &nActualTokenLength ) ) == SPNEGO_E_SUCCESS ) {
+                // Make adjustments to next token
+                pbTokenData += nActualTokenLength;
+                nBoundaryLength -= nActualTokenLength;
+                *pnRemainingTokenLength -= nActualTokenLength;
+
+                // The next token should specify the NegTokenInit
+                if ( ( nReturn = ASNDerCheckToken( pbTokenData, SPNEGO_NEGINIT_TOKEN_IDENTIFIER,
                                                    *pnRemainingTokenLength, nBoundaryLength, pnTokenLength,
                                                    &nActualTokenLength ) )
-                                == SPNEGO_E_SUCCESS )
-               {
-                  // NegTokenInit header is now checked out!
+                        == SPNEGO_E_SUCCESS ) {
+                    // Make adjustments to next token
+                    pbTokenData += nActualTokenLength;
+                    nBoundaryLength -= nActualTokenLength;
+                    *pnRemainingTokenLength -= nActualTokenLength;
 
-                  // Make adjustments to next token
-                  *pnRemainingTokenLength -= nActualTokenLength;
+                    // The next token should specify the start of a sequence
+                    if ( ( nReturn = ASNDerCheckToken( pbTokenData, SPNEGO_CONSTRUCTED_SEQUENCE,
+                                                       *pnRemainingTokenLength, nBoundaryLength, pnTokenLength,
+                                                       &nActualTokenLength ) )
+                            == SPNEGO_E_SUCCESS ) {
+                        // NegTokenInit header is now checked out!
 
-                  // Store pointer to first element
-                  *ppbFirstElement = pbTokenData + nActualTokenLength;
-                  pSpnegoToken->ucTokenType = SPNEGO_TOKEN_INIT;
-               }  // IF Check Sequence Token
+                        // Make adjustments to next token
+                        *pnRemainingTokenLength -= nActualTokenLength;
 
-            }  // IF Check NegTokenInit token
+                        // Store pointer to first element
+                        *ppbFirstElement = pbTokenData + nActualTokenLength;
+                        pSpnegoToken->ucTokenType = SPNEGO_TOKEN_INIT;
+                    }  // IF Check Sequence Token
 
+                }  // IF Check NegTokenInit token
 
-         }  // IF Check for SPNEGO OID
 
+            }  // IF Check for SPNEGO OID
 
-      }  // IF check app construct token
 
-   }
-   else if ( SPNEGO_NEGTARG_TOKEN_IDENTIFIER == *pbTokenData )
-   {
+        }  // IF check app construct token
 
-      // The next token should specify the NegTokenInit
-      if ( ( nReturn = ASNDerCheckToken( pbTokenData, SPNEGO_NEGTARG_TOKEN_IDENTIFIER,
-                                          *pnRemainingTokenLength, nBoundaryLength, pnTokenLength,
-                                          &nActualTokenLength ) )
-                       == SPNEGO_E_SUCCESS )
-      {
-         // Initialize the remaining token length value.  This will be used
-         // to tell the caller how much token there is left once we've parsed
-         // the header (they could calculate it from the other values, but this
-         // is a bit friendlier)
-         *pnRemainingTokenLength = *pnTokenLength;
+    } else if ( SPNEGO_NEGTARG_TOKEN_IDENTIFIER == *pbTokenData ) {
 
-         // Make adjustments to next token
-         pbTokenData += nActualTokenLength;
-         nBoundaryLength -= nActualTokenLength;
-
-         // The next token should specify the start of a sequence
-         if ( ( nReturn = ASNDerCheckToken( pbTokenData, SPNEGO_CONSTRUCTED_SEQUENCE,
-                                             *pnRemainingTokenLength, nBoundaryLength, pnTokenLength,
-                                             &nActualTokenLength ) )
-                          == SPNEGO_E_SUCCESS )
-         {
-            // NegTokenInit header is now checked out!
+        // The next token should specify the NegTokenInit
+        if ( ( nReturn = ASNDerCheckToken( pbTokenData, SPNEGO_NEGTARG_TOKEN_IDENTIFIER,
+                                           *pnRemainingTokenLength, nBoundaryLength, pnTokenLength,
+                                           &nActualTokenLength ) )
+                == SPNEGO_E_SUCCESS ) {
+            // Initialize the remaining token length value.  This will be used
+            // to tell the caller how much token there is left once we've parsed
+            // the header (they could calculate it from the other values, but this
+            // is a bit friendlier)
+            *pnRemainingTokenLength = *pnTokenLength;
 
             // Make adjustments to next token
-            *pnRemainingTokenLength -= nActualTokenLength;
+            pbTokenData += nActualTokenLength;
+            nBoundaryLength -= nActualTokenLength;
+
+            // The next token should specify the start of a sequence
+            if ( ( nReturn = ASNDerCheckToken( pbTokenData, SPNEGO_CONSTRUCTED_SEQUENCE,
+                                               *pnRemainingTokenLength, nBoundaryLength, pnTokenLength,
+                                               &nActualTokenLength ) )
+                    == SPNEGO_E_SUCCESS ) {
+                // NegTokenInit header is now checked out!
+
+                // Make adjustments to next token
+                *pnRemainingTokenLength -= nActualTokenLength;
 
-            // Store pointer to first element
-            *ppbFirstElement = pbTokenData + nActualTokenLength;
-            pSpnegoToken->ucTokenType = SPNEGO_TOKEN_TARG;
-         }  // IF Check Sequence Token
+                // Store pointer to first element
+                *ppbFirstElement = pbTokenData + nActualTokenLength;
+                pSpnegoToken->ucTokenType = SPNEGO_TOKEN_TARG;
+            }  // IF Check Sequence Token
 
-      }  // IF Check NegTokenInit token
+        }  // IF Check NegTokenInit token
 
-   }  // ELSE IF it's a NegTokenTarg
+    }  // ELSE IF it's a NegTokenTarg
 
-   LOG(("InitSpnegoTokenType returned %d\n",nReturn));
-   return nReturn;
+    LOG(("InitSpnegoTokenType returned %d\n",nReturn));
+    return nReturn;
 }
 
 
@@ -1088,39 +1028,37 @@ int InitSpnegoTokenType( SPNEGO_TOKEN* pSpnegoToken, long* pnTokenLength,
 ////////////////////////////////////////////////////////////////////////////
 
 int GetSpnegoInitTokenMechList( unsigned char* pbTokenData, int nMechListLength,
-                                 SPNEGO_ELEMENT* pSpnegoElement )
+                                SPNEGO_ELEMENT* pSpnegoElement )
 {
-   int   nReturn = SPNEGO_E_INVALID_TOKEN;
-   long  nLength = 0L;
-   long  nActualTokenLength = 0L;
+    int   nReturn = SPNEGO_E_INVALID_TOKEN;
+    long  nLength = 0L;
+    long  nActualTokenLength = 0L;
 
-   // Actual MechList is prepended by a Constructed Sequence Token
-   if ( ( nReturn = ASNDerCheckToken( pbTokenData, SPNEGO_CONSTRUCTED_SEQUENCE,
+    // Actual MechList is prepended by a Constructed Sequence Token
+    if ( ( nReturn = ASNDerCheckToken( pbTokenData, SPNEGO_CONSTRUCTED_SEQUENCE,
                                        nMechListLength, nMechListLength,
                                        &nLength, &nActualTokenLength ) )
-                             == SPNEGO_E_SUCCESS )
-   {
-      // Adjust for this token
-      nMechListLength -= nActualTokenLength;
-      pbTokenData += nActualTokenLength;
-
-      // Perform simple validation of the actual MechList (i.e. ensure that
-      // the OIDs in the MechList are reasonable).
-
-      if ( ( nReturn = ValidateMechList( pbTokenData, nLength ) ) == SPNEGO_E_SUCCESS )
-      {
-         // Initialize the element now
-         pSpnegoElement->eElementType = spnego_init_mechtypes;
-         pSpnegoElement->iElementPresent = SPNEGO_TOKEN_ELEMENT_AVAILABLE;
-         pSpnegoElement->type = SPNEGO_MECHLIST_TYPE;
-         pSpnegoElement->nDatalength = nLength;
-         pSpnegoElement->pbData = pbTokenData;
-      }
-
-   }  // IF Check Token
-
-   LOG(("GetSpnegoInitTokenMechList returned %d\n",nReturn));
-   return nReturn;
+            == SPNEGO_E_SUCCESS ) {
+        // Adjust for this token
+        nMechListLength -= nActualTokenLength;
+        pbTokenData += nActualTokenLength;
+
+        // Perform simple validation of the actual MechList (i.e. ensure that
+        // the OIDs in the MechList are reasonable).
+
+        if ( ( nReturn = ValidateMechList( pbTokenData, nLength ) ) == SPNEGO_E_SUCCESS ) {
+            // Initialize the element now
+            pSpnegoElement->eElementType = spnego_init_mechtypes;
+            pSpnegoElement->iElementPresent = SPNEGO_TOKEN_ELEMENT_AVAILABLE;
+            pSpnegoElement->type = SPNEGO_MECHLIST_TYPE;
+            pSpnegoElement->nDatalength = nLength;
+            pSpnegoElement->pbData = pbTokenData;
+        }
+
+    }  // IF Check Token
+
+    LOG(("GetSpnegoInitTokenMechList returned %d\n",nReturn));
+    return nReturn;
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -1142,46 +1080,44 @@ int GetSpnegoInitTokenMechList( unsigned char* pbTokenData, int nMechListLength,
 //
 // Comments :
 //    Checks that pbTokenData is pointing at the specified DER type.  If so,
-//    then we verify that lengths are proper and then fill out the 
+//    then we verify that lengths are proper and then fill out the
 //    SPNEGO_ELEMENT data structure.
 //
 ////////////////////////////////////////////////////////////////////////////
 
 int InitSpnegoTokenElementFromBasicType( unsigned char* pbTokenData, int nElementLength,
-                                          unsigned char ucExpectedType,
-                                          SPNEGO_ELEMENT_TYPE spnegoElementType,
-                                          SPNEGO_ELEMENT* pSpnegoElement )
+        unsigned char ucExpectedType,
+        SPNEGO_ELEMENT_TYPE spnegoElementType,
+        SPNEGO_ELEMENT* pSpnegoElement )
 {
-   int   nReturn = SPNEGO_E_UNEXPECTED_TYPE;
-   long  nLength = 0L;
-   long  nActualTokenLength = 0L;
-
-   // The type BYTE must match our token data or something is badly wrong
-   if ( *pbTokenData == ucExpectedType )
-   {
-
-      // Check that we are pointing at the specified type
-      if ( ( nReturn = ASNDerCheckToken( pbTokenData, ucExpectedType,
-                                          nElementLength, nElementLength,
-                                          &nLength, &nActualTokenLength ) )
-                                == SPNEGO_E_SUCCESS )
-      {
-         // Adjust for this token
-         nElementLength -= nActualTokenLength;
-         pbTokenData += nActualTokenLength;
-
-         // Initialize the element now
-         pSpnegoElement->eElementType = spnegoElementType;
-         pSpnegoElement->iElementPresent = SPNEGO_TOKEN_ELEMENT_AVAILABLE;
-         pSpnegoElement->type = ucExpectedType;
-         pSpnegoElement->nDatalength = nLength;
-         pSpnegoElement->pbData = pbTokenData;
-      }
-
-   }  // IF type makes sense
-
-   LOG(("InitSpnegoTokenElementFromBasicType returned %d\n",nReturn));
-   return nReturn;
+    int   nReturn = SPNEGO_E_UNEXPECTED_TYPE;
+    long  nLength = 0L;
+    long  nActualTokenLength = 0L;
+
+    // The type BYTE must match our token data or something is badly wrong
+    if ( *pbTokenData == ucExpectedType ) {
+
+        // Check that we are pointing at the specified type
+        if ( ( nReturn = ASNDerCheckToken( pbTokenData, ucExpectedType,
+                                           nElementLength, nElementLength,
+                                           &nLength, &nActualTokenLength ) )
+                == SPNEGO_E_SUCCESS ) {
+            // Adjust for this token
+            nElementLength -= nActualTokenLength;
+            pbTokenData += nActualTokenLength;
+
+            // Initialize the element now
+            pSpnegoElement->eElementType = spnegoElementType;
+            pSpnegoElement->iElementPresent = SPNEGO_TOKEN_ELEMENT_AVAILABLE;
+            pSpnegoElement->type = ucExpectedType;
+            pSpnegoElement->nDatalength = nLength;
+            pSpnegoElement->pbData = pbTokenData;
+        }
+
+    }  // IF type makes sense
+
+    LOG(("InitSpnegoTokenElementFromBasicType returned %d\n",nReturn));
+    return nReturn;
 }
 
 
@@ -1213,34 +1149,32 @@ int InitSpnegoTokenElementFromOID( unsigned char* pbTokenData, int nElementLengt
                                    SPNEGO_ELEMENT_TYPE spnegoElementType,
                                    SPNEGO_ELEMENT* pSpnegoElement )
 {
-   int   nReturn = SPNEGO_E_UNEXPECTED_TYPE;
-   long  nLength = 0L;
-   long  nActualTokenLength = 0L;
-
-   // The type BYTE must match our token data or something is badly wrong
-   if ( *pbTokenData == OID )
-   {
-
-      // Check that we are pointing at an OID type
-      if ( ( nReturn = ASNDerCheckToken( pbTokenData, OID,
-                                          nElementLength, nElementLength,
-                                          &nLength, &nActualTokenLength ) )
-                                == SPNEGO_E_SUCCESS )
-      {
-         // Don't adjust any values for this function
-
-         // Initialize the element now
-         pSpnegoElement->eElementType = spnegoElementType;
-         pSpnegoElement->iElementPresent = SPNEGO_TOKEN_ELEMENT_AVAILABLE;
-         pSpnegoElement->type = OID;
-         pSpnegoElement->nDatalength = nElementLength;
-         pSpnegoElement->pbData = pbTokenData;
-      }
-
-   }  // IF type makes sense
-
-   LOG(("InitSpnegoTokenElementFromBasicType returned %d\n",nReturn));
-   return nReturn;
+    int   nReturn = SPNEGO_E_UNEXPECTED_TYPE;
+    long  nLength = 0L;
+    long  nActualTokenLength = 0L;
+
+    // The type BYTE must match our token data or something is badly wrong
+    if ( *pbTokenData == OID ) {
+
+        // Check that we are pointing at an OID type
+        if ( ( nReturn = ASNDerCheckToken( pbTokenData, OID,
+                                           nElementLength, nElementLength,
+                                           &nLength, &nActualTokenLength ) )
+                == SPNEGO_E_SUCCESS ) {
+            // Don't adjust any values for this function
+
+            // Initialize the element now
+            pSpnegoElement->eElementType = spnegoElementType;
+            pSpnegoElement->iElementPresent = SPNEGO_TOKEN_ELEMENT_AVAILABLE;
+            pSpnegoElement->type = OID;
+            pSpnegoElement->nDatalength = nElementLength;
+            pSpnegoElement->pbData = pbTokenData;
+        }
+
+    }  // IF type makes sense
+
+    LOG(("InitSpnegoTokenElementFromBasicType returned %d\n",nReturn));
+    return nReturn;
 }
 
 
@@ -1268,220 +1202,200 @@ int InitSpnegoTokenElementFromOID( unsigned char* pbTokenData, int nElementLengt
 ////////////////////////////////////////////////////////////////////////////
 
 int InitSpnegoTokenElements( SPNEGO_TOKEN* pSpnegoToken, unsigned char* pbTokenData,
-                           long nRemainingTokenLength  )
+                             long nRemainingTokenLength  )
 {
-   //
-   // The following arrays contain the token identifiers for the elements
-   // comprising the actual token.  All values are optional, and there are
-   // no defaults.
-   //
-
-   static unsigned char abNegTokenInitElements[] =
-      { SPNEGO_NEGINIT_ELEMENT_MECHTYPES, SPNEGO_NEGINIT_ELEMENT_REQFLAGS,
-         SPNEGO_NEGINIT_ELEMENT_MECHTOKEN, SPNEGO_NEGINIT_ELEMENT_MECHLISTMIC };
-
-   static unsigned char abNegTokenTargElements[] =
-      { SPNEGO_NEGTARG_ELEMENT_NEGRESULT, SPNEGO_NEGTARG_ELEMENT_SUPPORTEDMECH,
-         SPNEGO_NEGTARG_ELEMENT_RESPONSETOKEN, SPNEGO_NEGTARG_ELEMENT_MECHLISTMIC };
-
-   int   nReturn = SPNEGO_E_SUCCESS;
-   int   nCtr = 0L;
-   long  nElementLength = 0L;
-   long  nActualTokenLength = 0L;
-   unsigned char* pbElements = NULL;
-
-   // Point to the correct array
-   switch( pSpnegoToken->ucTokenType )
-   {
-      case SPNEGO_TOKEN_INIT:
-      {
-         pbElements = abNegTokenInitElements;
-      }
-      break;
-
-      case SPNEGO_TOKEN_TARG:
-      {
-         pbElements = abNegTokenTargElements;
-      }
-      break;
-
-   }  // SWITCH tokentype
-
-   //
-   // Enumerate the element arrays and look for the tokens at our current location
-   //
-
-   for ( nCtr = 0L;
-         SPNEGO_E_SUCCESS == nReturn &&
-         nCtr < MAX_NUM_TOKEN_ELEMENTS &&
-         nRemainingTokenLength > 0L;
-         nCtr++ )
-   {
-      
-      // Check if the token exists
-      if ( ( nReturn = ASNDerCheckToken( pbTokenData, pbElements[nCtr],
-                                          0L, nRemainingTokenLength,
-                                          &nElementLength, &nActualTokenLength ) )
-                                == SPNEGO_E_SUCCESS )
-      {
-
-         // Token data should skip over the sequence token and then
-         // call the appropriate function to initialize the element
-         pbTokenData += nActualTokenLength;
-
-         // Lengths in the elements should NOT go beyond the element
-         // length
-
-         // Different tokens mean different elements
-         if ( SPNEGO_TOKEN_INIT == pSpnegoToken->ucTokenType )
-         {
-
-            // Handle each element as appropriate
-            switch( pbElements[nCtr] )
-            {
-
-               case SPNEGO_NEGINIT_ELEMENT_MECHTYPES:
-               {
-                  //
-                  // This is a Mech List that specifies which OIDs the
-                  // originator of the Init Token supports.
-                  //
-
-                  nReturn = GetSpnegoInitTokenMechList( pbTokenData, nElementLength,
-                                                         &pSpnegoToken->aElementArray[nCtr] );
-
-               }
-               break;
-
-               case SPNEGO_NEGINIT_ELEMENT_REQFLAGS:
-               {
-                  //
-                  // This is a BITSTRING which specifies the flags that the receiver
-                  // pass to the gss_accept_sec_context() function.
-                  //
-
-                  nReturn = InitSpnegoTokenElementFromBasicType( pbTokenData, nElementLength,
-                                                                  BITSTRING, spnego_init_reqFlags,
-                                                                  &pSpnegoToken->aElementArray[nCtr] );
-               }
-               break;
-
-               case SPNEGO_NEGINIT_ELEMENT_MECHTOKEN:
-               {
-                  //
-                  // This is an OCTETSTRING which contains a GSSAPI token corresponding
-                  // to the first OID in the MechList.
-                  //
-
-                  nReturn = InitSpnegoTokenElementFromBasicType( pbTokenData, nElementLength,
-                                                                  OCTETSTRING, spnego_init_mechToken,
-                                                                  &pSpnegoToken->aElementArray[nCtr] );
-              }
-               break;
-
-               case SPNEGO_NEGINIT_ELEMENT_MECHLISTMIC:
-               {
-                  //
-                  // This is an OCTETSTRING which contains a message integrity BLOB.
-                  //
-
-                  nReturn = InitSpnegoTokenElementFromBasicType( pbTokenData, nElementLength,
-                                                                  OCTETSTRING, spnego_init_mechListMIC,
-                                                                  &pSpnegoToken->aElementArray[nCtr] );
-               }
-               break;
-
-            }  // SWITCH Element
-         }
-         else
-         {
-
-            switch( pbElements[nCtr] )
-            {
-
-               case SPNEGO_NEGTARG_ELEMENT_NEGRESULT:
-               {
-                  //
-                  // This is an ENUMERATION which specifies result of the last GSS
-                  // token negotiation call.
-                  //
-
-                  nReturn = InitSpnegoTokenElementFromBasicType( pbTokenData, nElementLength,
-                                                                  ENUMERATED, spnego_targ_negResult,
-                                                                  &pSpnegoToken->aElementArray[nCtr] );
-               }
-               break;
-
-               case SPNEGO_NEGTARG_ELEMENT_SUPPORTEDMECH:
-               {
-                  //
-                  // This is an OID which specifies a supported mechanism.
-                  //
-
-                  nReturn = InitSpnegoTokenElementFromOID( pbTokenData, nElementLength,
-                                                           spnego_targ_mechListMIC,
-                                                           &pSpnegoToken->aElementArray[nCtr] );
-               }
-               break;
-
-               case SPNEGO_NEGTARG_ELEMENT_RESPONSETOKEN:
-               {
-                  //
-                  // This is an OCTETSTRING which specifies results of the last GSS
-                  // token negotiation call.
-                  //
-
-                  nReturn = InitSpnegoTokenElementFromBasicType( pbTokenData, nElementLength,
-                                                                  OCTETSTRING, spnego_targ_responseToken,
-                                                                  &pSpnegoToken->aElementArray[nCtr] );
-               }
-               break;
-
-               case SPNEGO_NEGTARG_ELEMENT_MECHLISTMIC:
-               {
-                  //
-                  // This is an OCTETSTRING which specifies a message integrity BLOB.
-                  //
-
-                  nReturn = InitSpnegoTokenElementFromBasicType( pbTokenData, nElementLength,
-                                                                  OCTETSTRING, spnego_targ_mechListMIC,
-                                                                  &pSpnegoToken->aElementArray[nCtr] );
-               }
-               break;
-
-            }  // SWITCH Element
-
-         }  // ELSE !NegTokenInit
-
-         // Account for the entire token and following data
-         nRemainingTokenLength -= ( nActualTokenLength + nElementLength );
-
-         // Token data should skip past the element length now
-         pbTokenData += nElementLength;
-
-      }  // IF Token found
-      else if ( SPNEGO_E_TOKEN_NOT_FOUND == nReturn )
-      {
-         // For now, this is a benign error (remember, all elements are optional, so
-         // if we don't find one, it's okay).
-
-         nReturn = SPNEGO_E_SUCCESS;
-      }
-
-   }  // FOR enum elements
-
-   //
-   // We should always run down to 0 remaining bytes in the token.  If not, we've got
-   // a bad token.
-   //
-
-   if ( SPNEGO_E_SUCCESS == nReturn && nRemainingTokenLength != 0L )
-   {
-      nReturn = SPNEGO_E_INVALID_TOKEN;
-   }
-
-   LOG(("InitSpnegoTokenElements returned %d\n",nReturn));
-   return nReturn;
+    //
+    // The following arrays contain the token identifiers for the elements
+    // comprising the actual token.  All values are optional, and there are
+    // no defaults.
+    //
+
+    static unsigned char abNegTokenInitElements[] = { SPNEGO_NEGINIT_ELEMENT_MECHTYPES, SPNEGO_NEGINIT_ELEMENT_REQFLAGS,
+            SPNEGO_NEGINIT_ELEMENT_MECHTOKEN, SPNEGO_NEGINIT_ELEMENT_MECHLISTMIC
+                                                    };
+
+    static unsigned char abNegTokenTargElements[] = { SPNEGO_NEGTARG_ELEMENT_NEGRESULT, SPNEGO_NEGTARG_ELEMENT_SUPPORTEDMECH,
+            SPNEGO_NEGTARG_ELEMENT_RESPONSETOKEN, SPNEGO_NEGTARG_ELEMENT_MECHLISTMIC
+                                                    };
+
+    int   nReturn = SPNEGO_E_SUCCESS;
+    int   nCtr = 0L;
+    long  nElementLength = 0L;
+    long  nActualTokenLength = 0L;
+    unsigned char* pbElements = NULL;
+
+    // Point to the correct array
+    switch ( pSpnegoToken->ucTokenType ) {
+    case SPNEGO_TOKEN_INIT: {
+        pbElements = abNegTokenInitElements;
+    }
+    break;
+
+    case SPNEGO_TOKEN_TARG: {
+        pbElements = abNegTokenTargElements;
+    }
+    break;
+
+    }  // SWITCH tokentype
+
+    //
+    // Enumerate the element arrays and look for the tokens at our current location
+    //
+
+    for ( nCtr = 0L;
+            SPNEGO_E_SUCCESS == nReturn &&
+            nCtr < MAX_NUM_TOKEN_ELEMENTS &&
+            nRemainingTokenLength > 0L;
+            nCtr++ ) {
+
+        // Check if the token exists
+        if ( ( nReturn = ASNDerCheckToken( pbTokenData, pbElements[nCtr],
+                                           0L, nRemainingTokenLength,
+                                           &nElementLength, &nActualTokenLength ) )
+                == SPNEGO_E_SUCCESS ) {
+
+            // Token data should skip over the sequence token and then
+            // call the appropriate function to initialize the element
+            pbTokenData += nActualTokenLength;
+
+            // Lengths in the elements should NOT go beyond the element
+            // length
+
+            // Different tokens mean different elements
+            if ( SPNEGO_TOKEN_INIT == pSpnegoToken->ucTokenType ) {
+
+                // Handle each element as appropriate
+                switch ( pbElements[nCtr] ) {
+
+                case SPNEGO_NEGINIT_ELEMENT_MECHTYPES: {
+                    //
+                    // This is a Mech List that specifies which OIDs the
+                    // originator of the Init Token supports.
+                    //
+
+                    nReturn = GetSpnegoInitTokenMechList( pbTokenData, nElementLength,
+                                                          &pSpnegoToken->aElementArray[nCtr] );
+
+                }
+                break;
+
+                case SPNEGO_NEGINIT_ELEMENT_REQFLAGS: {
+                    //
+                    // This is a BITSTRING which specifies the flags that the receiver
+                    // pass to the gss_accept_sec_context() function.
+                    //
+
+                    nReturn = InitSpnegoTokenElementFromBasicType( pbTokenData, nElementLength,
+                              BITSTRING, spnego_init_reqFlags,
+                              &pSpnegoToken->aElementArray[nCtr] );
+                }
+                break;
+
+                case SPNEGO_NEGINIT_ELEMENT_MECHTOKEN: {
+                    //
+                    // This is an OCTETSTRING which contains a GSSAPI token corresponding
+                    // to the first OID in the MechList.
+                    //
+
+                    nReturn = InitSpnegoTokenElementFromBasicType( pbTokenData, nElementLength,
+                              OCTETSTRING, spnego_init_mechToken,
+                              &pSpnegoToken->aElementArray[nCtr] );
+                }
+                break;
+
+                case SPNEGO_NEGINIT_ELEMENT_MECHLISTMIC: {
+                    //
+                    // This is an OCTETSTRING which contains a message integrity BLOB.
+                    //
+
+                    nReturn = InitSpnegoTokenElementFromBasicType( pbTokenData, nElementLength,
+                              OCTETSTRING, spnego_init_mechListMIC,
+                              &pSpnegoToken->aElementArray[nCtr] );
+                }
+                break;
+
+                }  // SWITCH Element
+            } else {
+
+                switch ( pbElements[nCtr] ) {
+
+                case SPNEGO_NEGTARG_ELEMENT_NEGRESULT: {
+                    //
+                    // This is an ENUMERATION which specifies result of the last GSS
+                    // token negotiation call.
+                    //
+
+                    nReturn = InitSpnegoTokenElementFromBasicType( pbTokenData, nElementLength,
+                              ENUMERATED, spnego_targ_negResult,
+                              &pSpnegoToken->aElementArray[nCtr] );
+                }
+                break;
+
+                case SPNEGO_NEGTARG_ELEMENT_SUPPORTEDMECH: {
+                    //
+                    // This is an OID which specifies a supported mechanism.
+                    //
+
+                    nReturn = InitSpnegoTokenElementFromOID( pbTokenData, nElementLength,
+                              spnego_targ_mechListMIC,
+                              &pSpnegoToken->aElementArray[nCtr] );
+                }
+                break;
+
+                case SPNEGO_NEGTARG_ELEMENT_RESPONSETOKEN: {
+                    //
+                    // This is an OCTETSTRING which specifies results of the last GSS
+                    // token negotiation call.
+                    //
+
+                    nReturn = InitSpnegoTokenElementFromBasicType( pbTokenData, nElementLength,
+                              OCTETSTRING, spnego_targ_responseToken,
+                              &pSpnegoToken->aElementArray[nCtr] );
+                }
+                break;
+
+                case SPNEGO_NEGTARG_ELEMENT_MECHLISTMIC: {
+                    //
+                    // This is an OCTETSTRING which specifies a message integrity BLOB.
+                    //
+
+                    nReturn = InitSpnegoTokenElementFromBasicType( pbTokenData, nElementLength,
+                              OCTETSTRING, spnego_targ_mechListMIC,
+                              &pSpnegoToken->aElementArray[nCtr] );
+                }
+                break;
+
+                }  // SWITCH Element
+
+            }  // ELSE !NegTokenInit
+
+            // Account for the entire token and following data
+            nRemainingTokenLength -= ( nActualTokenLength + nElementLength );
+
+            // Token data should skip past the element length now
+            pbTokenData += nElementLength;
+
+        }  // IF Token found
+        else if ( SPNEGO_E_TOKEN_NOT_FOUND == nReturn ) {
+            // For now, this is a benign error (remember, all elements are optional, so
+            // if we don't find one, it's okay).
+
+            nReturn = SPNEGO_E_SUCCESS;
+        }
+
+    }  // FOR enum elements
+
+    //
+    // We should always run down to 0 remaining bytes in the token.  If not, we've got
+    // a bad token.
+    //
+
+    if ( SPNEGO_E_SUCCESS == nReturn && nRemainingTokenLength != 0L ) {
+        nReturn = SPNEGO_E_INVALID_TOKEN;
+    }
+
+    LOG(("InitSpnegoTokenElements returned %d\n",nReturn));
+    return nReturn;
 }
 
 
@@ -1507,33 +1421,31 @@ int InitSpnegoTokenElements( SPNEGO_TOKEN* pSpnegoToken, unsigned char* pbTokenD
 ////////////////////////////////////////////////////////////////////////////
 
 int FindMechOIDInMechList( SPNEGO_ELEMENT* pSpnegoElement, SPNEGO_MECH_OID MechOID,
-                          int * piMechTypeIndex )
+                           int * piMechTypeIndex )
 {
-   int   nReturn = SPNEGO_E_NOT_FOUND;
-   int   nCtr = 0;
-   long  nLength = 0L;
-   long  nBoundaryLength = pSpnegoElement->nDatalength;
-   unsigned char* pbMechListData = pSpnegoElement->pbData;
-
-   while( SPNEGO_E_SUCCESS != nReturn && nBoundaryLength > 0L )
-   {
-      
-      // Use the helper function to check the OID
-      if ( ( nReturn = ASNDerCheckOID( pbMechListData, MechOID, nBoundaryLength, &nLength ) )
-                     == SPNEGO_E_SUCCESS )
-      {
-         *piMechTypeIndex = nCtr;
-      }
-
-      // Adjust for the current OID
-      pbMechListData += nLength;
-      nBoundaryLength -= nLength;
-      nCtr++;
-
-   }  // WHILE enuming OIDs
-
-   LOG(("FindMechOIDInMechList returned %d\n",nReturn));
-   return nReturn;
+    int   nReturn = SPNEGO_E_NOT_FOUND;
+    int   nCtr = 0;
+    long  nLength = 0L;
+    long  nBoundaryLength = pSpnegoElement->nDatalength;
+    unsigned char* pbMechListData = pSpnegoElement->pbData;
+
+    while ( SPNEGO_E_SUCCESS != nReturn && nBoundaryLength > 0L ) {
+
+        // Use the helper function to check the OID
+        if ( ( nReturn = ASNDerCheckOID( pbMechListData, MechOID, nBoundaryLength, &nLength ) )
+                == SPNEGO_E_SUCCESS ) {
+            *piMechTypeIndex = nCtr;
+        }
+
+        // Adjust for the current OID
+        pbMechListData += nLength;
+        nBoundaryLength -= nLength;
+        nCtr++;
+
+    }  // WHILE enuming OIDs
+
+    LOG(("FindMechOIDInMechList returned %d\n",nReturn));
+    return nReturn;
 
 }
 
@@ -1560,26 +1472,25 @@ int FindMechOIDInMechList( SPNEGO_ELEMENT* pSpnegoElement, SPNEGO_MECH_OID MechO
 
 int ValidateMechList( unsigned char* pbMechListData, long nBoundaryLength )
 {
-   int   nReturn = SPNEGO_E_SUCCESS;
-   long  nLength = 0L;
-   long  nTokenLength = 0L;
-
-   while( SPNEGO_E_SUCCESS == nReturn && nBoundaryLength > 0L )
-   {
-      // Verify that we have something that at least *looks* like an OID - in other
-      // words it has an OID identifier and specifies a length that doesn't go beyond
-      // the size of the list.
-      nReturn = ASNDerCheckToken( pbMechListData, OID, 0L, nBoundaryLength, 
-                                  &nLength, &nTokenLength );
-      
-      // Adjust for the current OID
-      pbMechListData += ( nLength + nTokenLength );
-      nBoundaryLength -= ( nLength + nTokenLength );
-
-   }  // WHILE enuming OIDs
-
-   LOG(("ValidateMechList returned %d\n",nReturn));
-   return nReturn;
+    int   nReturn = SPNEGO_E_SUCCESS;
+    long  nLength = 0L;
+    long  nTokenLength = 0L;
+
+    while ( SPNEGO_E_SUCCESS == nReturn && nBoundaryLength > 0L ) {
+        // Verify that we have something that at least *looks* like an OID - in other
+        // words it has an OID identifier and specifies a length that doesn't go beyond
+        // the size of the list.
+        nReturn = ASNDerCheckToken( pbMechListData, OID, 0L, nBoundaryLength,
+                                    &nLength, &nTokenLength );
+
+        // Adjust for the current OID
+        pbMechListData += ( nLength + nTokenLength );
+        nBoundaryLength -= ( nLength + nTokenLength );
+
+    }  // WHILE enuming OIDs
+
+    LOG(("ValidateMechList returned %d\n",nReturn));
+    return nReturn;
 
 }
 
@@ -1602,10 +1513,10 @@ int ValidateMechList( unsigned char* pbMechListData, long nBoundaryLength )
 
 int IsValidMechOid( SPNEGO_MECH_OID mechOid )
 {
-   LOG(("IsValidMechOid returned %d\n",mechOid >= spnego_mech_oid_Kerberos_V5_Legacy &&
-            mechOid <= spnego_mech_oid_Spnego));
-   return ( mechOid >= spnego_mech_oid_Kerberos_V5_Legacy &&
-            mechOid <= spnego_mech_oid_Spnego );
+    LOG(("IsValidMechOid returned %d\n",mechOid >= spnego_mech_oid_Kerberos_V5_Legacy &&
+         mechOid <= spnego_mech_oid_Spnego));
+    return ( mechOid >= spnego_mech_oid_Kerberos_V5_Legacy &&
+             mechOid <= spnego_mech_oid_Spnego );
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -1627,10 +1538,10 @@ int IsValidMechOid( SPNEGO_MECH_OID mechOid )
 
 int IsValidContextFlags( unsigned char ucContextFlags )
 {
-   // Mask out our valid bits.  If there is anything leftover, this
-   // is not a valid value for Context Flags
-   LOG(("IsValidContextFlags returned %d\n",(( ucContextFlags & ~SPNEGO_NEGINIT_CONTEXT_MASK ) == 0)));
-   return ( ( ucContextFlags & ~SPNEGO_NEGINIT_CONTEXT_MASK ) == 0 );
+    // Mask out our valid bits.  If there is anything leftover, this
+    // is not a valid value for Context Flags
+    LOG(("IsValidContextFlags returned %d\n",(( ucContextFlags & ~SPNEGO_NEGINIT_CONTEXT_MASK ) == 0)));
+    return ( ( ucContextFlags & ~SPNEGO_NEGINIT_CONTEXT_MASK ) == 0 );
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -1652,10 +1563,10 @@ int IsValidContextFlags( unsigned char ucContextFlags )
 
 int IsValidNegResult( SPNEGO_NEGRESULT negResult )
 {
-   LOG(("IsValidNegResult returned %d\n",negResult >= spnego_negresult_success &&
-            negResult <= spnego_negresult_rejected ));
-   return ( negResult >= spnego_negresult_success &&
-            negResult <= spnego_negresult_rejected );
+    LOG(("IsValidNegResult returned %d\n",negResult >= spnego_negresult_success &&
+         negResult <= spnego_negresult_rejected ));
+    return ( negResult >= spnego_negresult_success &&
+             negResult <= spnego_negresult_rejected );
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -1677,32 +1588,28 @@ int IsValidNegResult( SPNEGO_NEGRESULT negResult )
 
 int IsValidSpnegoToken( SPNEGO_TOKEN* pSpnegoToken )
 {
-   int   nReturn = 0;
-
-   // Parameter should be non-NULL
-   if ( NULL != pSpnegoToken )
-   {
-      // Length should be at least the size defined in the header
-      if ( pSpnegoToken->nStructSize >= SPNEGO_TOKEN_SIZE )
-      {
-         // Number of elements should be >= our maximum - if it's greater, that's
-         // okay, since we'll only be accessing the elements up to MAX_NUM_TOKEN_ELEMENTS
-         if ( pSpnegoToken->nNumElements >= MAX_NUM_TOKEN_ELEMENTS )
-         {
-            // Check for proper token type
-            if ( SPNEGO_TOKEN_INIT == pSpnegoToken->ucTokenType ||
-               SPNEGO_TOKEN_TARG == pSpnegoToken->ucTokenType )
-            {
-               nReturn = 1;
+    int   nReturn = 0;
+
+    // Parameter should be non-NULL
+    if ( NULL != pSpnegoToken ) {
+        // Length should be at least the size defined in the header
+        if ( pSpnegoToken->nStructSize >= SPNEGO_TOKEN_SIZE ) {
+            // Number of elements should be >= our maximum - if it's greater, that's
+            // okay, since we'll only be accessing the elements up to MAX_NUM_TOKEN_ELEMENTS
+            if ( pSpnegoToken->nNumElements >= MAX_NUM_TOKEN_ELEMENTS ) {
+                // Check for proper token type
+                if ( SPNEGO_TOKEN_INIT == pSpnegoToken->ucTokenType ||
+                        SPNEGO_TOKEN_TARG == pSpnegoToken->ucTokenType ) {
+                    nReturn = 1;
+                }
             }
-         }
 
-      }  // IF struct size makes sense
+        }  // IF struct size makes sense
 
-   }  // IF non-NULL spnego Token
+    }  // IF non-NULL spnego Token
 
-   LOG(("IsValidSpnegoToken returned %d\n",nReturn));
-   return nReturn;
+    LOG(("IsValidSpnegoToken returned %d\n",nReturn));
+    return nReturn;
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -1726,29 +1633,25 @@ int IsValidSpnegoToken( SPNEGO_TOKEN* pSpnegoToken )
 
 int IsValidSpnegoElement( SPNEGO_TOKEN* pSpnegoToken,SPNEGO_ELEMENT_TYPE spnegoElement )
 {
-   int   nReturn = 0;
-
-   // Check boundaries
-   if ( spnegoElement > spnego_element_min &&
-      spnegoElement < spnego_element_max )
-   {
-
-      // Check for appropriateness to token type
-      if ( SPNEGO_TOKEN_INIT == pSpnegoToken->ucTokenType )
-      {
-         nReturn = ( spnegoElement >= spnego_init_mechtypes &&
-                     spnegoElement <= spnego_init_mechListMIC );
-      }
-      else
-      {
-         nReturn = ( spnegoElement >= spnego_targ_negResult &&
-                     spnegoElement <= spnego_targ_mechListMIC );
-      }
-
-   }  // IF boundary conditions are met
-
-   LOG(("IsValidSpnegoElement returned %d\n",nReturn));
-   return nReturn;
+    int   nReturn = 0;
+
+    // Check boundaries
+    if ( spnegoElement > spnego_element_min &&
+            spnegoElement < spnego_element_max ) {
+
+        // Check for appropriateness to token type
+        if ( SPNEGO_TOKEN_INIT == pSpnegoToken->ucTokenType ) {
+            nReturn = ( spnegoElement >= spnego_init_mechtypes &&
+                        spnegoElement <= spnego_init_mechListMIC );
+        } else {
+            nReturn = ( spnegoElement >= spnego_targ_negResult &&
+                        spnegoElement <= spnego_targ_mechListMIC );
+        }
+
+    }  // IF boundary conditions are met
+
+    LOG(("IsValidSpnegoElement returned %d\n",nReturn));
+    return nReturn;
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -1772,22 +1675,19 @@ int IsValidSpnegoElement( SPNEGO_TOKEN* pSpnegoToken,SPNEGO_ELEMENT_TYPE spnegoE
 
 int CalculateElementArrayIndex( SPNEGO_TOKEN* pSpnegoToken,SPNEGO_ELEMENT_TYPE spnegoElement )
 {
-   int   nReturn = 0;
-
-   // Offset is difference between value and initial element identifier
-   // (these differ based on ucTokenType)
-
-   if ( SPNEGO_TOKEN_INIT == pSpnegoToken->ucTokenType )
-   {
-      nReturn = spnegoElement - spnego_init_mechtypes;
-   }
-   else
-   {
-      nReturn = spnegoElement - spnego_targ_negResult;
-   }
-
-   LOG(("CalculateElementArrayIndex returned %d\n",nReturn));
-   return nReturn;
+    int   nReturn = 0;
+
+    // Offset is difference between value and initial element identifier
+    // (these differ based on ucTokenType)
+
+    if ( SPNEGO_TOKEN_INIT == pSpnegoToken->ucTokenType ) {
+        nReturn = spnegoElement - spnego_init_mechtypes;
+    } else {
+        nReturn = spnegoElement - spnego_targ_negResult;
+    }
+
+    LOG(("CalculateElementArrayIndex returned %d\n",nReturn));
+    return nReturn;
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -1816,65 +1716,58 @@ int CalculateElementArrayIndex( SPNEGO_TOKEN* pSpnegoToken,SPNEGO_ELEMENT_TYPE s
 
 // Initializes SPNEGO_TOKEN structure from DER encoded binary data
 int InitTokenFromBinary( unsigned char ucCopyData, unsigned long ulFlags,
-                        unsigned char* pbTokenData, unsigned long ulLength,
-                        SPNEGO_TOKEN** ppSpnegoToken )
+                         unsigned char* pbTokenData, unsigned long ulLength,
+                         SPNEGO_TOKEN** ppSpnegoToken )
 {
-   int            nReturn = SPNEGO_E_INVALID_PARAMETER;
-   SPNEGO_TOKEN*  pSpnegoToken = NULL;
-   unsigned char* pbFirstElement = NULL;
-   long           nTokenLength = 0L;
-   long           nRemainingTokenLength = 0L;
-   
-   // Basic Parameter Validation
-
-   if (  NULL != pbTokenData &&
-         NULL != ppSpnegoToken &&
-         0L != ulLength )
-   {
-
-      //
-      // Allocate the empty token, then initialize the data structure.
-      //
-
-      pSpnegoToken = AllocEmptySpnegoToken( ucCopyData, ulFlags, pbTokenData, ulLength );
-
-      if ( NULL != pSpnegoToken )
-      {
-
-         // Copy the binary data locally
-           
-
-         // Initialize the token type
-         if ( ( nReturn = InitSpnegoTokenType( pSpnegoToken, &nTokenLength,
-                                                &nRemainingTokenLength, &pbFirstElement ) )
-                        == SPNEGO_E_SUCCESS )
-         {
-
-            // Initialize the element array
-            if ( ( nReturn = InitSpnegoTokenElements( pSpnegoToken, pbFirstElement,
-                                                      nRemainingTokenLength ) )
-                           == SPNEGO_E_SUCCESS )
-            {
-               *ppSpnegoToken = pSpnegoToken;
-            }
+    int            nReturn = SPNEGO_E_INVALID_PARAMETER;
+    SPNEGO_TOKEN*  pSpnegoToken = NULL;
+    unsigned char* pbFirstElement = NULL;
+    long           nTokenLength = 0L;
+    long           nRemainingTokenLength = 0L;
+
+    // Basic Parameter Validation
+
+    if (  NULL != pbTokenData &&
+            NULL != ppSpnegoToken &&
+            0L != ulLength ) {
+
+        //
+        // Allocate the empty token, then initialize the data structure.
+        //
+
+        pSpnegoToken = AllocEmptySpnegoToken( ucCopyData, ulFlags, pbTokenData, ulLength );
+
+        if ( NULL != pSpnegoToken ) {
 
-         }  // IF Init Token Type
+            // Copy the binary data locally
 
-         // Cleanup on error condition
-         if ( SPNEGO_E_SUCCESS != nReturn )
-         {
-            spnegoFreeData( pSpnegoToken );
-         }
 
-      }
-      else
-      {
-         nReturn = SPNEGO_E_OUT_OF_MEMORY;
-      }
+            // Initialize the token type
+            if ( ( nReturn = InitSpnegoTokenType( pSpnegoToken, &nTokenLength,
+                                                  &nRemainingTokenLength, &pbFirstElement ) )
+                    == SPNEGO_E_SUCCESS ) {
+
+                // Initialize the element array
+                if ( ( nReturn = InitSpnegoTokenElements( pSpnegoToken, pbFirstElement,
+                                 nRemainingTokenLength ) )
+                        == SPNEGO_E_SUCCESS ) {
+                    *ppSpnegoToken = pSpnegoToken;
+                }
+
+            }  // IF Init Token Type
+
+            // Cleanup on error condition
+            if ( SPNEGO_E_SUCCESS != nReturn ) {
+                spnegoFreeData( pSpnegoToken );
+            }
+
+        } else {
+            nReturn = SPNEGO_E_OUT_OF_MEMORY;
+        }
 
-   }  // IF Valid parameters
+    }  // IF Valid parameters
 
 
-   LOG(("InitTokenFromBinary returned %d\n",nReturn));
-   return nReturn;
+    LOG(("InitTokenFromBinary returned %d\n",nReturn));
+    return nReturn;
 }
@@ -38,7 +38,7 @@ extern "C"
 // the SPNEG_TOKEN structure is destroyed
 #define  SPNEGO_TOKEN_INTERNAL_FLAGS_FREEDATA   0x1
 
-   //
+    //
 // Each SPNEGO Token Type can be broken down into a
 // maximum of 4 separate elements.
 //
@@ -65,22 +65,21 @@ extern "C"
 // Defines an individual SPNEGO Token Element.
 //
 
-typedef struct SpnegoElement
-{
-   size_t                nStructSize;        // Size of the element structure
-   int                   iElementPresent;    // Is the field present?  Must be either
-                                             // SPNEGO_TOKEN_ELEMENT_UNAVAILABLE or
-                                             // SPNEGO_TOKEN_ELEMENT_AVAILABLE
+    typedef struct SpnegoElement {
+        size_t                nStructSize;        // Size of the element structure
+        int                   iElementPresent;    // Is the field present?  Must be either
+        // SPNEGO_TOKEN_ELEMENT_UNAVAILABLE or
+        // SPNEGO_TOKEN_ELEMENT_AVAILABLE
+
+        SPNEGO_ELEMENT_TYPE   eElementType;       // The Element Type
 
-   SPNEGO_ELEMENT_TYPE   eElementType;       // The Element Type
+        unsigned char         type;               // Data Type
 
-   unsigned char         type;               // Data Type
+        unsigned char*        pbData;             // Points to actual Data
 
-   unsigned char*        pbData;             // Points to actual Data
+        unsigned long         nDatalength;        // Actual Data Length
 
-   unsigned long         nDatalength;        // Actual Data Length   
-   
-} SPNEGO_ELEMENT;
+    } SPNEGO_ELEMENT;
 
 // Structure size in case we later choose to extend the structure
 #define  SPNEGO_ELEMENT_SIZE sizeof(SPNEGO_ELEMENT)
@@ -91,20 +90,19 @@ typedef struct SpnegoElement
 // contain up to four distinct, optional elements.
 //
 
-typedef struct SpnegoToken
-{
-   size_t            nStructSize;                              // Size of the Token structure
-   unsigned long     ulFlags;                                  // Internal Structure Flags - Reserved!
-   int               ucTokenType;                              // Token Type - Must be
-                                                               // SPNEGO_TOKEN_INIT or
-                                                               // SPNEGO_TOKEN_TARG
+    typedef struct SpnegoToken {
+        size_t            nStructSize;                              // Size of the Token structure
+        unsigned long     ulFlags;                                  // Internal Structure Flags - Reserved!
+        int               ucTokenType;                              // Token Type - Must be
+        // SPNEGO_TOKEN_INIT or
+        // SPNEGO_TOKEN_TARG
 
-   unsigned char*    pbBinaryData;                             // Points to binary token data
+        unsigned char*    pbBinaryData;                             // Points to binary token data
 
-   unsigned long     ulBinaryDataLen;                          // Length of the actual binary data
-   int               nNumElements;                             // Number of elements
-   SPNEGO_ELEMENT    aElementArray [MAX_NUM_TOKEN_ELEMENTS];   // Holds the elements for the token
-} SPNEGO_TOKEN;
+        unsigned long     ulBinaryDataLen;                          // Length of the actual binary data
+        int               nNumElements;                             // Number of elements
+        SPNEGO_ELEMENT    aElementArray [MAX_NUM_TOKEN_ELEMENTS];   // Holds the elements for the token
+    } SPNEGO_TOKEN;
 
 // Structure size in case we later choose to extend the structure
 #define  SPNEGO_TOKEN_SIZE sizeof(SPNEGO_TOKEN)
@@ -113,54 +111,54 @@ typedef struct SpnegoToken
 // Function definitions
 //
 
-SPNEGO_TOKEN* AllocEmptySpnegoToken( unsigned char ucCopyData, unsigned long ulFlags,
-                                    unsigned char * pbTokenData, unsigned long ulTokenSize );
-void FreeSpnegoToken( SPNEGO_TOKEN* pSpnegoToken );
-void InitSpnegoTokenElementArray( SPNEGO_TOKEN* pSpnegoToken );
-int InitSpnegoTokenType( SPNEGO_TOKEN* pSpnegoToken, long* pnTokenLength,
-                           long* pnRemainingTokenLength, unsigned char** ppbFirstElement );
-int InitSpnegoTokenElements( SPNEGO_TOKEN* pSpnegoToken, unsigned char* pbTokenData,
-                           long nRemainingTokenLength  );
-int GetSpnegoInitTokenMechList( unsigned char* pbTokenData, int nMechListLength,
-                                 SPNEGO_ELEMENT* pSpnegoElement );
-int InitSpnegoTokenElementFromBasicType( unsigned char* pbTokenData, int nElementLength,
-                                          unsigned char ucExpectedType,
-                                          SPNEGO_ELEMENT_TYPE spnegoElementType,
-                                          SPNEGO_ELEMENT* pSpnegoElement );
-int InitSpnegoTokenElementFromOID( unsigned char* pbTokenData, int nElementLength,
-                                   SPNEGO_ELEMENT_TYPE spnegoElementType,
-                                   SPNEGO_ELEMENT* pSpnegoElement );
-int FindMechOIDInMechList( SPNEGO_ELEMENT* pSpnegoElement, SPNEGO_MECH_OID MechOID,
-                           int * piMechTypeIndex );
-int ValidateMechList( unsigned char* pbMechListData, long nBoundaryLength );
-int CalculateMinSpnegoInitTokenSize( long nMechTokenLength, long nMechListMICLength,
-                                    SPNEGO_MECH_OID mechOid, int nReqFlagsAvailable,
-                                    long* plTokenSize, long* plInternalLength );
-int CalculateMinSpnegoTargTokenSize( SPNEGO_MECH_OID MechType, SPNEGO_NEGRESULT spnegoNegResult, 
-                                    long nMechTokenLen,
-                                    long nMechTokenMIC, long* pnTokenSize,
-                                    long* pnInternalTokenLength );
-int CreateSpnegoInitToken( SPNEGO_MECH_OID MechType,
-          unsigned char ucContextFlags, unsigned char* pbMechToken,
-          unsigned long ulMechTokenLen, unsigned char* pbMechListMIC,
-          unsigned long ulMechListMICLen, unsigned char* pbTokenData,
-          long nTokenLength, long nInternalTokenLength );
-int CreateSpnegoTargToken( SPNEGO_MECH_OID MechType,
-          SPNEGO_NEGRESULT eNegResult, unsigned char* pbMechToken,
-          unsigned long ulMechTokenLen, unsigned char* pbMechListMIC,
-          unsigned long ulMechListMICLen, unsigned char* pbTokenData,
-          long nTokenLength, long nInternalTokenLength );
-int IsValidMechOid( SPNEGO_MECH_OID mechOid );
-int IsValidContextFlags( unsigned char ucContextFlags );
-int IsValidNegResult( SPNEGO_NEGRESULT negResult );
-int IsValidSpnegoToken( SPNEGO_TOKEN* pSpnegoToken );
-int IsValidSpnegoElement( SPNEGO_TOKEN* pSpnegoToken,SPNEGO_ELEMENT_TYPE spnegoElement );
-int CalculateElementArrayIndex( SPNEGO_TOKEN* pSpnegoToken,SPNEGO_ELEMENT_TYPE spnegoElement );
-int InitTokenFromBinary( unsigned char ucCopyData, unsigned long ulFlags,
-                        unsigned char* pbTokenData, unsigned long ulLength,
-                        SPNEGO_TOKEN** ppSpnegoToken );
-
-   // C++ Specific
+    SPNEGO_TOKEN* AllocEmptySpnegoToken( unsigned char ucCopyData, unsigned long ulFlags,
+                                         unsigned char * pbTokenData, unsigned long ulTokenSize );
+    void FreeSpnegoToken( SPNEGO_TOKEN* pSpnegoToken );
+    void InitSpnegoTokenElementArray( SPNEGO_TOKEN* pSpnegoToken );
+    int InitSpnegoTokenType( SPNEGO_TOKEN* pSpnegoToken, long* pnTokenLength,
+                             long* pnRemainingTokenLength, unsigned char** ppbFirstElement );
+    int InitSpnegoTokenElements( SPNEGO_TOKEN* pSpnegoToken, unsigned char* pbTokenData,
+                                 long nRemainingTokenLength  );
+    int GetSpnegoInitTokenMechList( unsigned char* pbTokenData, int nMechListLength,
+                                    SPNEGO_ELEMENT* pSpnegoElement );
+    int InitSpnegoTokenElementFromBasicType( unsigned char* pbTokenData, int nElementLength,
+            unsigned char ucExpectedType,
+            SPNEGO_ELEMENT_TYPE spnegoElementType,
+            SPNEGO_ELEMENT* pSpnegoElement );
+    int InitSpnegoTokenElementFromOID( unsigned char* pbTokenData, int nElementLength,
+                                       SPNEGO_ELEMENT_TYPE spnegoElementType,
+                                       SPNEGO_ELEMENT* pSpnegoElement );
+    int FindMechOIDInMechList( SPNEGO_ELEMENT* pSpnegoElement, SPNEGO_MECH_OID MechOID,
+                               int * piMechTypeIndex );
+    int ValidateMechList( unsigned char* pbMechListData, long nBoundaryLength );
+    int CalculateMinSpnegoInitTokenSize( long nMechTokenLength, long nMechListMICLength,
+                                         SPNEGO_MECH_OID mechOid, int nReqFlagsAvailable,
+                                         long* plTokenSize, long* plInternalLength );
+    int CalculateMinSpnegoTargTokenSize( SPNEGO_MECH_OID MechType, SPNEGO_NEGRESULT spnegoNegResult,
+                                         long nMechTokenLen,
+                                         long nMechTokenMIC, long* pnTokenSize,
+                                         long* pnInternalTokenLength );
+    int CreateSpnegoInitToken( SPNEGO_MECH_OID MechType,
+                               unsigned char ucContextFlags, unsigned char* pbMechToken,
+                               unsigned long ulMechTokenLen, unsigned char* pbMechListMIC,
+                               unsigned long ulMechListMICLen, unsigned char* pbTokenData,
+                               long nTokenLength, long nInternalTokenLength );
+    int CreateSpnegoTargToken( SPNEGO_MECH_OID MechType,
+                               SPNEGO_NEGRESULT eNegResult, unsigned char* pbMechToken,
+                               unsigned long ulMechTokenLen, unsigned char* pbMechListMIC,
+                               unsigned long ulMechListMICLen, unsigned char* pbTokenData,
+                               long nTokenLength, long nInternalTokenLength );
+    int IsValidMechOid( SPNEGO_MECH_OID mechOid );
+    int IsValidContextFlags( unsigned char ucContextFlags );
+    int IsValidNegResult( SPNEGO_NEGRESULT negResult );
+    int IsValidSpnegoToken( SPNEGO_TOKEN* pSpnegoToken );
+    int IsValidSpnegoElement( SPNEGO_TOKEN* pSpnegoToken,SPNEGO_ELEMENT_TYPE spnegoElement );
+    int CalculateElementArrayIndex( SPNEGO_TOKEN* pSpnegoToken,SPNEGO_ELEMENT_TYPE spnegoElement );
+    int InitTokenFromBinary( unsigned char ucCopyData, unsigned long ulFlags,
+                             unsigned char* pbTokenData, unsigned long ulLength,
+                             SPNEGO_TOKEN** ppSpnegoToken );
+
+    // C++ Specific
 #if defined(__cplusplus)
 }
 #endif