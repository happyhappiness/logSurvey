long int
ar_scan (const char *archive, ar_member_func_t function, const void *varg)
{
  char *vms_archive;

  static struct dsc$descriptor_s libdesc =
    { 0, DSC$K_DTYPE_T, DSC$K_CLASS_S, NULL };

  const unsigned long func = LBR$C_READ;
  const unsigned long type = LBR$C_TYP_UNK;
  const unsigned long index = 1;
  unsigned long lib_idx;
  int status;

  VMS_saved_arg = varg;

  /* Null archive string can show up in test and cause an access violation */
  if (archive == NULL)
    {
      /* Null filenames do not exist */
      return -1;
    }

  /* archive path name must be in VMS format */
  vms_archive = (char *) vmsify(archive, 0);

  status = lbr$ini_control(&VMS_lib_idx, &func, &type, 0);

  if (!$VMS_STATUS_SUCCESS(status))
    {
      ON(error, NILF, _("lbr$ini_control() failed with status = %d"), status);
      return -2;
    }

  libdesc.dsc$a_pointer = vms_archive;
  libdesc.dsc$w_length = strlen(vms_archive);

  status = lbr$open(&VMS_lib_idx, &libdesc, 0, NULL, 0, NULL, 0);

  if (!$VMS_STATUS_SUCCESS(status))
    {

      /* TODO: A library format failure could mean that this is a file
         generated by the GNU AR utility and in that case, we need to
         take the UNIX codepath.  This will also take a change to the
         GNV AR wrapper program. */

      switch (status)
        {
      case RMS$_FNF:
        /* Archive does not exist */
        return -1;
      default:
#ifndef TEST
        OSN(error, NILF,
            _("unable to open library '%s' to lookup member status %d"),
            archive, status);
#endif
        /* For library format errors, specification says to return -2 */
        return -2;
        }
    }

  VMS_function = function;

  /* Clear the return status, as we are supposed to stop calling the
     callback function if it becomes non-zero, and this is a static
     variable. */
  VMS_function_ret = 0;

  status = lbr$get_index(&VMS_lib_idx, &index, VMS_get_member_info, NULL, 0);

  lbr$close(&VMS_lib_idx);

  /* Unless a failure occurred in the lbr$ routines, return the
     the status from the 'function' routine. */
  if ($VMS_STATUS_SUCCESS(status))
    {
      return VMS_function_ret;
    }

  /* This must be something wrong with the library and an error
     message should already have been printed. */
  return -2;
}

#else /* !VMS */
