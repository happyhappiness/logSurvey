@@ -39,6 +39,7 @@ and ideas to make this software available.
     Cord Beermann <cord@cc.fh-lippe.de>
     Daniel O'Callaghan <danny@miriworld.its.unimelb.EDU.AU>
     David Luyer <luyer@ucs.uwa.edu.au>
+    Dhaval Varia
     Diego Woitasen <diegows@xtech.com.ar>
     Dmitry Kurochkin
     Don Hopkins <dhopkins@DonHopkins.com>
@@ -540,9 +540,8 @@ icons/SN.png:
   Squid NOW icon - copyright Squid Project
 
   This work is licensed under the
-  Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported Liscence
-  (CC BY-NC-SA 3.0)
-  [ http://creativecommons.org/licenses/by-nc-sa/3.0/ ]
+  Creative Commons Attribution-ShareAlike 3.0 Unported Liscence (CC BY-SA 3.0)
+  [ http://creativecommons.org/licenses/by-sa/3.0/ ]
 
 ==============================================================================
 
@@ -1,3 +1,104 @@
+Changes to squid-3.4.0.1 (-- --- 2013):
+
+	- Port from 2.7: StoreURL (renamed Store-ID) support
+	- Bug 3795: fix several mistakes in the MIB file
+	- Bug 3793: configure: improved helper detection
+	- Bug 3722: Invalid markup in Armenian hy ERR_ONLY_IF_CACHED_MISS
+	- Bug 3676: Support GCC 4.7 with -Wshadow option
+	- Bug 3643: NTLM helpers stuck in reserved state by Safari
+	- Bug 3389: Auto-reconnect for tcp access_log
+	- Bug 2066: squid does not do chdir() after chroot()
+	- Fix uninitialized fields in IcapLogEntry
+	- Fix a number of minor issues detected by Coverity Scan
+	- Fix some potential memory leaks detected by Coverity Scan
+	- Fix 64-bit support for Intel compiler suite (ICC) and other similar compilers
+	- Fix ACL matching algorithm to avoid repeating tests
+	- basic_pam_auth: Add -r option to strip NTLM/Negotiate domain from username
+	- squidpurge: fix META TLV parsing issues
+	- squid.conf: enforce all the directive and option names are lower-case
+	- Support EUI on HTTPS and FTP data connections
+	- Support OK/ERR/BH response codes from any helper
+	- Support No-lookup flag (-n) on DNS ACLs
+	- Support -march=native compiler optimization by default
+	- Support forwarding intercepted but not bumped connections to cache_peers
+	- Support IPv6 NAT interception on Linux and some BSD
+	- Deprecate log_icap and log_access configuration directives
+	- HTTP/1.1: improved method invalidation and cacheability detection
+	- HTTP/1.1: support length configuration for pipeline_prefetch queue
+	- Improved TPROXY support for OpenBSD and FreeBSD
+	- Add storeid_file_rewrite helper to perform Store-ID rewrites from a rules file
+	- Add all-of and any-of ACL types for grouping sets of ACL tests
+	- Add note directive for transaction annotations
+	- Add %note log format for transaction annotation logging
+	- Add note ACL type for matching annotated transactions with by annotation name or value
+	- Add kv-pair support to URL-rewrite/redirector interface
+	- Add SSL server certificate validator interface, helper and result cache
+	- Add SSL server certificate fingerprint ACL type
+	- Add spoof_client_ip access control
+	- Add pt-bz (Belize Portuguese) dialect to translations
+	- ... and many Windows portability changes (still incomplete)
+	- ... and many documentation changes
+	- ... and much code cleanup and polishing
+
+Changes to squid-3.3.8 (13 Jul 2013):
+
+	- Bug 3869: assertion failed: MemBuf.cc:272: size < capacity
+	- Improved handling of port values in Host: header validation
+
+Changes to squid-3.3.7 (11 Jul 2013):
+
+	- Bug 3297: Fix openSSL related build failures
+	- Fix build on FreeBSD 9.x platform with clang
+	- Protect against buffer overrun in DNS query generation
+
+Changes to squid-3.3.6 (01 Jul 2013):
+
+	- Bug 3854: pt1: compile errors on AIX
+	- Bug 3802: Fix wrong check inside Format::Format::assemble
+	- Bug 3762: remove bogus WARNING in cache.log
+	- Bug 3717: assertion failed with dstdom_regex with IP based URL
+	- Bug 1991: kqueue causes SSL to hang
+	- Ask for SSL key password when started with -N but without sslpassword_program
+	- Make sure %<tt includes all [failed] connection attempts
+	- Support HTTP reply ACLs in icap_log and log_icap
+	- Fix incorrect external_acl_type codes
+	- Fix ICAP logging request headers and segmentation faults
+	- ... and some documentation polish
+
+Changes to squid-3.3.5 (20 May 2013):
+
+	- Bug 3851: Delay Pool class 5 tag:levels displayed incorrectly in cache manager
+	- Bug 3845: http_port tcpkeepalive= option fails parsing
+	- Bug 3840: assertion failed 'sde' in UFS cache loading
+	- Bug 3836: make check failures with automake-1.13
+	- Bug 3827: Remove AccessLogEntry::cache.authuser
+	- Bug 3816 pt2: SSL_get_certificate call inside Ssl::verifySslCertificate crashes
+	- Bug 3780: cachemgr.cgi: output problem in HTTP Header Statistics
+	- Bug 3759: OpenSSL compilation error on stock Fedora17, RHEL, CentOS 6 systems
+	- Bug 3744: squid terminated: FATAL: Bungled (null) line 3: sslproxy_cert_sign signTrusted all
+	- Port from 2.6: external acl %ACL and %DATA tags
+	- Update copyright on SN.png
+	- ... and several minor memory leaks
+	- ... and some documentation polish
+
+Changes to squid-3.3.4 (27 Apr 2013):
+
+	- Bug 3831: basic_ncsa_auth Blowfish and SHA support
+	- Bug 3816: SSL_get_certificate call inside Ssl::verifySslCertificate crashes
+	- Bug 3794: MacOS: workaround compiler errors and case-insensitivity
+	- Bug 3781: Proxy Authentication not sent to cache_peer
+	- Bug 3720 pt1: SourceLayout: shuffle fd_table definition into fde.h
+	- Bug 3720 pt2: Add missing include in /dev/poll I/O module
+	- Bug 3674: Improve compiler detection, better support warnings-as-errors on clang
+	- Add support for TPROXY on BSD
+	- Fix SSL Bump bypass for intercepted traffic
+	- Fix memory leaks in ConnStateData pinning
+	- Fix external_acl.cc "inBackground" assertion on queue overloads
+	- CacheMgr: fix missing column separator in helper stats
+	- OpenBSD: libpthreads requires OpenBSD 5.2 or later
+	- ... and lots of documentation updates
+	- ... and all changes from squid 3.2.10
+
 Changes to squid-3.3.3 (12 Mar 2013):
 
 	- Bug 3720: Add missing include in /dev/poll I/O module (pt2)
@@ -55,6 +156,36 @@ Changes to squid-3.3.0.1 (21 Oct 2012):
 	- ... and many compile error fixes
 	- ... and a very large amount of code polish for faster compilation
 
+Changes to squid-3.2.13 (13 Jul 2013):
+
+	- Bug 3869: assertion failed: MemBuf.cc:272: size < capacity
+	- Improved handling of port values in Host: header validation
+
+Changes to squid-3.2.12 (11 Jul 2013):
+
+	- Protect against buffer overrun in DNS query generation
+	- Avoid !closing assertions when helpers call comm_read during reconfigure.
+	- Fix several minor memory leaks during reconfigure
+	- Remove origin_tries limiter on forwarding and permit large max_forward_tries values
+
+Changes to squid-3.2.11 (30 Apr 2013):
+
+	- Regression Bug 3839: build error: src/tools.h: No such file or directory
+	- Update copyright on SN.png
+
+Changes to squid-3.2.10 (27 Apr 2013):
+
+	- Bug 3833: squidclient: Option '-k' is not present in man(1) page
+	- Bug 3825: basic_ncsa_auth: segfaulting with glibc-2.17
+	- Bug 3822: Locate LDAP and SASL headers for BSD support
+	- Bug 3817: Memory leak in SSL cert validate for alt_name peer certs
+	- Bug 3774: 'squid -k reconfigure' drops rock cache
+	- Bug 3565: Resuming postponed accept kills Squid
+	- HTTP/1.1: partial support for no-cache and private controls with parameters
+	- ssl_crtd: fix helpers dying during startup on ARM
+	- GNU Hurd: define MAP_NORESERVE as no-op when missing
+	- BSD: fix enter_suid/leave_suid build errors in ip/Intercept.cc
+
 Changes to squid-3.2.9 (12 Mar 2013):
 
 	- Regression fix: Accept-Language header parse
@@ -2,6 +2,13 @@ In addition to the numerous volunteer developers (see CONTRIBUTORS),
 the following organizations have provided non-financial support for
 the Squid Project:
 
+@Squid-3.3:
+Netbox Blue Pty (http://netboxblue.com/)
+
+	Netbox Blue Pty. contributed development resources towards
+	testing and stabilizing of authentication systems in Squid-3.2
+	and Squid-3.3.
+
 @Squid-3.2:
 iiNet Ltd - http://www.iinet.net.au/
 
@@ -81,15 +81,12 @@ AC_DEFUN([SQUID_CC_REQUIRE_ARGUMENT],[
 #  - sunstudio
 #  - none (undetected)
 # 
-AC_DEFUN([SQUID_CC_GUESS_VARIANT], [
+AC_DEFUN([SQUID_CC_GUESS_VARIANT], [ 
  AC_CACHE_CHECK([what kind of compiler we're using],[squid_cv_compiler],
  [
   AC_REQUIRE([AC_PROG_CC])
-  if test "$GCC" = "yes" ; then
-   squid_cv_compiler="gcc"
-  fi
   dnl repeat the next block for each compiler, changing the
-  dnl preprocessor definition type so that it depends on platform-specific
+  dnl preprocessor definition so that it depends on platform-specific
   dnl predefined macros
   dnl SunPro CC
   if test -z "$squid_cv_compiler" ; then
@@ -109,12 +106,39 @@ AC_DEFUN([SQUID_CC_GUESS_VARIANT], [
 #endif
     ]])],[squid_cv_compiler="icc"],[])
   fi
+  dnl clang
+  if test -z "$squid_cv_compiler" ; then
+   AC_COMPILE_IFELSE([
+    AC_LANG_PROGRAM([[
+#if !defined(__clang__)
+#error "not clang"
+#endif
+    ]])],[squid_cv_compiler="clang"],[])
+  fi
+  dnl microsoft visual c++
+  if test -z "$squid_cv_compiler" ; then
+   AC_COMPILE_IFELSE([
+    AC_LANG_PROGRAM([[
+#if !defined(_MSC_VER)
+#error "not Microsoft VC++"
+#endif
+    ]])],[squid_cv_compiler="msvc"],[])
+  fi
+  dnl gcc. MUST BE LAST as many other compilers also define it for compatibility
+  if test -z "$squid_cv_compiler" ; then
+   AC_COMPILE_IFELSE([
+    AC_LANG_PROGRAM([[
+#if !defined(__GNUC__)
+#error "not gcc"
+#endif
+    ]])],[squid_cv_compiler="gcc"],[])
+  fi
   dnl end of block to be repeated
   if test -z "$squid_cv_compiler" ; then
    squid_cv_compiler="none"
   fi
-  ])
- ])
+  ]) dnl AC_CACHE_CHECK
+ ]) dnl AC_DEFUN
 
 # define the flag to use to have the compiler treat warnings as errors
 # requirs SQUID_CC_GUESS_VARIANT
@@ -145,6 +169,13 @@ AC_DEFUN([SQUID_CC_GUESS_OPTIONS], [
    squid_cv_cc_option_optimize="-fast"
    squid_cv_cc_arg_pipe=""
    ;;
+  clang) 
+   squid_cv_cxx_option_werror="-Werror -Wno-error=parentheses-equality -Qunused-arguments"
+   squid_cv_cc_option_werror="$squid_cv_cxx_option_werror" 
+   squid_cv_cc_option_wall="-Wall"
+   squid_cv_cc_option_optimize="-O2"
+   squid_cv_cc_arg_pipe=""
+   ;;
   icc) 
    squid_cv_cxx_option_werror="-Werror"
    squid_cv_cc_option_werror="$squid_cv_cxx_option_werror" 
@@ -94,3 +94,186 @@ AC_DEFUN([SQUID_CHECK_LIBIPHLPAPI],[
   ])
   SQUID_STATE_ROLLBACK(iphlpapi)
 ])
+
+dnl Checks whether the OpenSSL SSL_get_certificate crashes squid and if a
+dnl workaround can be used instead of using the SSL_get_certificate
+AC_DEFUN([SQUID_CHECK_OPENSSL_GETCERTIFICATE_WORKS],[
+  AH_TEMPLATE(SQUID_SSLGETCERTIFICATE_BUGGY, "Define to 1 if the SSL_get_certificate crashes squid")
+  AH_TEMPLATE(SQUID_USE_SSLGETCERTIFICATE_HACK, "Define to 1 to use squid workaround for SSL_get_certificate")
+  SQUID_STATE_SAVE(check_SSL_get_certificate)
+  LIBS="$SSLLIB $LIBS"
+  if test "x$SSLLIBDIR" != "x"; then
+     LIBS="$LIBS -Wl,-rpath -Wl,$SSLLIBDIR"
+  fi
+
+  AC_MSG_CHECKING(whether the SSL_get_certificate is buggy)
+  AC_RUN_IFELSE([
+  AC_LANG_PROGRAM(
+    [
+     #include <openssl/ssl.h>
+     #include <openssl/err.h>
+    ],
+    [
+    SSLeay_add_ssl_algorithms();
+    SSL_CTX *sslContext = SSL_CTX_new(SSLv3_method());
+    SSL *ssl = SSL_new(sslContext);
+    X509* cert = SSL_get_certificate(ssl);
+    return 0;
+    ])
+  ],
+  [
+   AC_MSG_RESULT([no])
+  ],
+  [
+   AC_DEFINE(SQUID_SSLGETCERTIFICATE_BUGGY, 1)
+   AC_MSG_RESULT([yes])
+  ],
+  [])
+
+  AC_MSG_CHECKING(whether the workaround for SSL_get_certificate works)
+  AC_RUN_IFELSE([
+  AC_LANG_PROGRAM(
+    [
+     #include <openssl/ssl.h>
+     #include <openssl/err.h>
+    ],
+    [
+    SSLeay_add_ssl_algorithms();
+    SSL_CTX *sslContext = SSL_CTX_new(SSLv3_method());
+    X509 ***pCert = (X509 ***)sslContext->cert;
+    X509 *sslCtxCert = pCert && *pCert ? **pCert : (X509 *)0x1;
+    if (sslCtxCert != NULL)
+        return 1;
+    return 0;
+    ])
+  ],
+  [
+   AC_MSG_RESULT([yes])
+   AC_DEFINE(SQUID_USE_SSLGETCERTIFICATE_HACK, 1)
+  ],
+  [
+   AC_MSG_RESULT([no])
+  ],
+[])
+
+SQUID_STATE_ROLLBACK(check_SSL_get_certificate)
+])
+
+dnl Checks whether the  SSL_CTX_new and similar functions require 
+dnl a const 'SSL_METHOD *' argument
+AC_DEFUN([SQUID_CHECK_OPENSSL_CONST_SSL_METHOD],[
+  AH_TEMPLATE(SQUID_USE_CONST_SSL_METHOD, "Define to 1 if the SSL_CTX_new and similar openSSL API functions require 'const SSL_METHOD *'")
+  SQUID_STATE_SAVE(check_const_SSL_METHOD)
+  AC_MSG_CHECKING(whether SSL_CTX_new and similar openSSL API functions require 'const SSL_METHOD *'")
+
+  AC_COMPILE_IFELSE([
+  AC_LANG_PROGRAM(
+    [
+     #include <openssl/ssl.h>
+     #include <openssl/err.h>
+    ],
+    [
+       const SSL_METHOD *method = NULL;
+       SSL_CTX *sslContext = SSL_CTX_new(method);
+       return (sslContext != NULL);
+    ])
+  ],
+  [
+   AC_DEFINE(SQUID_USE_CONST_SSL_METHOD, 1)
+   AC_MSG_RESULT([yes])
+  ],
+  [
+   AC_MSG_RESULT([no])
+  ],
+  [])
+
+SQUID_STATE_ROLLBACK(check_const_SSL_METHOD)
+]
+)
+
+dnl Try to handle TXT_DB related  problems:
+dnl 1) The type of TXT_DB::data member changed in openSSL-1.0.1 version
+dnl 2) The IMPLEMENT_LHASH_* openSSL macros in openSSL-1.0.1 and later releases is not
+dnl    implemented correctly and causes type conversion errors while compiling squid
+
+AC_DEFUN([SQUID_CHECK_OPENSSL_TXTDB],[
+  AH_TEMPLATE(SQUID_SSLTXTDB_PSTRINGDATA, "Define to 1 if the TXT_DB uses OPENSSL_PSTRING data member")
+  AH_TEMPLATE(SQUID_STACKOF_PSTRINGDATA_HACK, "Define to 1 to use squid workaround for buggy versions of sk_OPENSSL_PSTRING_value")
+  AH_TEMPLATE(SQUID_USE_SSLLHASH_HACK, "Define to 1 to use squid workaround for openssl IMPLEMENT_LHASH_* type conversion errors")
+
+  SQUID_STATE_SAVE(check_TXTDB)
+
+  LIBS="$LIBS $SSLLIB"
+  squid_cv_check_openssl_pstring="no"
+  AC_MSG_CHECKING(whether the TXT_DB use OPENSSL_PSTRING data member)
+  AC_COMPILE_IFELSE([
+  AC_LANG_PROGRAM(
+    [
+     #include <openssl/txt_db.h>
+    ],
+    [
+    TXT_DB *db = NULL;
+    int i = sk_OPENSSL_PSTRING_num(db->data);
+    return 0;
+    ])
+  ],
+  [
+   AC_DEFINE(SQUID_SSLTXTDB_PSTRINGDATA, 1)
+   AC_MSG_RESULT([yes])
+   squid_cv_check_openssl_pstring="yes"
+  ],
+  [
+   AC_MSG_RESULT([no])
+  ],
+  [])
+
+  if test x"$squid_cv_check_openssl_pstring" = "xyes"; then
+     AC_MSG_CHECKING(whether the squid workaround for buggy versions of sk_OPENSSL_PSTRING_value should used)
+     AC_COMPILE_IFELSE([
+     AC_LANG_PROGRAM(
+       [
+        #include <openssl/txt_db.h>
+       ],
+       [
+       TXT_DB *db = NULL;
+       const char ** current_row = ((const char **)sk_OPENSSL_PSTRING_value(db->data, 0));
+       return (current_row != NULL);
+       ])
+     ],
+     [
+      AC_MSG_RESULT([no])
+     ],
+     [
+      AC_DEFINE(SQUID_STACKOF_PSTRINGDATA_HACK, 1)
+      AC_MSG_RESULT([yes])
+     ],
+     [])
+  fi
+
+  AC_MSG_CHECKING(whether the workaround for OpenSSL IMPLEMENT_LHASH_  macros should used)
+  AC_COMPILE_IFELSE([
+  AC_LANG_PROGRAM(
+    [
+     #include <openssl/txt_db.h>
+
+     static unsigned long index_serial_hash(const char **a){}
+     static int index_serial_cmp(const char **a, const char **b){}
+     static IMPLEMENT_LHASH_HASH_FN(index_serial_hash,const char **)
+     static IMPLEMENT_LHASH_COMP_FN(index_serial_cmp,const char **)
+    ],
+    [
+    TXT_DB *db = NULL;
+    TXT_DB_create_index(db, 1, NULL, LHASH_HASH_FN(index_serial_hash), LHASH_COMP_FN(index_serial_cmp));
+    ])
+  ],
+  [
+   AC_MSG_RESULT([no])
+  ],
+  [
+   AC_MSG_RESULT([yes])
+   AC_DEFINE(SQUID_USE_SSLLHASH_HACK, 1)
+  ],
+[])
+
+SQUID_STATE_ROLLBACK(check_TXTDB)
+])
@@ -249,3 +249,32 @@ AS_IF([test "$ac_res" != no],
       [$4])
 AS_VAR_POPDEF([ac_Search])dnl
 ])
+
+dnl Check for Cyrus SASL
+AC_DEFUN([SQUID_CHECK_SASL],[
+  squid_cv_check_sasl="auto"
+  AC_CHECK_HEADERS([sasl/sasl.h sasl.h])
+  AC_CHECK_LIB(sasl2,sasl_errstring,[LIBSASL="-lsasl2"],[
+    AC_CHECK_LIB(sasl,sasl_errstring,[LIBSASL="-lsasl"], [
+      squid_cv_check_sasl="no"
+    ])
+  ])
+  case "$squid_host_os" in
+    Darwin)
+      if test "$ac_cv_lib_sasl2_sasl_errstring" = "yes" ; then
+        AC_DEFINE(HAVE_SASL_DARWIN,1,[Define to 1 if Mac Darwin without sasl.h])
+        echo "checking for MAC Darwin without sasl.h ... yes"
+        squid_cv_check_sasl="yes"
+      else
+        echo "checking for MAC Darwin without sasl.h ... no"
+        squid_cv_check_sasl="no"
+      fi
+      ;;
+  esac
+  if test "x$squid_cv_check_sasl" = "xno"; then
+    AC_MSG_WARN([Neither SASL nor SASL2 found])
+  else
+    squid_cv_check_sasl="yes"
+  fi
+  AC_SUBST(LIBSASL)
+])
@@ -123,8 +123,7 @@ echo "libtool  ($ltversion) : ${LIBTOOL_BIN}${ltver}"
 echo "libtool path : $ltpath"
 
 for dir in \
-	"" \
-	lib/libTrie
+	"" 
 do
     if [ -z "$dir" ] || [ -d $dir ]; then
 	if (
@@ -148,6 +148,7 @@ gettimeofday(struct timeval *pcur_time, void *tzp)
 }
 #endif /* !HAVE_GETTIMEOFDAY */
 
+#if !_SQUID_MINGW_
 int
 statfs(const char *path, struct statfs *sfs)
 {
@@ -181,6 +182,7 @@ statfs(const char *path, struct statfs *sfs)
     sfs->f_namelen = maxlen;
     return 0;
 }
+#endif
 
 #if !_SQUID_MINGW_
 int
@@ -17,5 +17,10 @@
 #define _XOPEN_SOURCE_EXTENDED 1
 #endif
 
+/* AIX 6.1 does not define recvmsg() flag MSG_DONTWAIT */
+#if !defined(MSG_DONTWAIT)
+#define MSG_DONTWAIT 0
+#endif
+
 #endif /* _SQUID_AIX_ */
 #endif /* SQUID_OS_AIX_H */
@@ -212,6 +212,7 @@ struct group {
     char    **gr_mem;      /* group members */
 };
 
+#if !_SQUID_MINGW_
 struct statfs {
     long    f_type;     /* type of filesystem (see below) */
     long    f_bsize;    /* optimal transfer block size */
@@ -224,6 +225,7 @@ struct statfs {
     long    f_namelen;  /* maximum length of filenames */
     long    f_spare[6]; /* spare for later */
 };
+#endif
 
 #if !HAVE_GETTIMEOFDAY
 struct timezone {
@@ -459,6 +461,9 @@ index(const char *s, int c)
     return (char *)strchr(s,c);
 }
 
+// stdlib <functional> definitions are required before std API redefinitions.
+#include <functional>
+
 /** \cond AUTODOCS-IGNORE */
 namespace Squid
 {
@@ -807,7 +812,9 @@ struct rusage {
 
 SQUIDCEXTERN int chroot(const char *dirname);
 SQUIDCEXTERN int kill(pid_t, int);
+#if !_SQUID_MINGW_
 SQUIDCEXTERN int statfs(const char *, struct statfs *);
+#endif
 SQUIDCEXTERN struct passwd * getpwnam(char *unused);
 SQUIDCEXTERN struct group * getgrnam(char *unused);
 
@@ -35,9 +35,20 @@ AC_PROG_CXX
 AC_LANG([C++])
 AC_CANONICAL_HOST
 
-# might be cross-compiling
+# Clang 3.2 on some CPUs requires -march-native to detect correctly
+# GCC 4.3+ can also produce faster executables when its used
+SQUID_CC_CHECK_ARGUMENT([squid_cv_check_marchnative],[-march=native])
+
+# might be cross-compiling.
 if test "x$HOSTCXX" = "x"; then
   HOSTCXX="$CXX"
+  if test "x$squid_cv_check_marchnative" = "xyes"; then
+    CXXFLAGS="$CXXFLAGS -march=native"
+  fi
+fi
+if test "x$squid_cv_check_marchnative" = "xyes"; then
+  # always valid for the Host compiler.
+  HOSTCXX="$HOSTCXX -march=native"
 fi
 AC_SUBST(HOSTCXX)
 
@@ -60,8 +71,7 @@ fi
 
 # Check for C++0x compiler support
 AX_CXX_COMPILE_STDCXX_0X
-if test "x$ax_cv_cxx_compile_cxx0x_cxx" = "xyes" -a \
-  "x$squid_host_os" != "xmingw" ; then
+if test "x$ax_cv_cxx_compile_cxx0x_cxx" = "xyes" ; then
     #BUG 3613: when clang -std=c++0x is used, it activates a "strict mode"
     # in the system libraries, which makes some c99 methods unavailable
     # (e.g. strtoll), yet configure detects them as avilable.
@@ -185,7 +195,8 @@ AM_CONDITIONAL(ENABLE_WIN32SPECIFIC,
                [test "x$squid_host_os" = "xmingw" -o "x$squid_host_os" = "xcygwin"])
 AM_CONDITIONAL(USE_IPC_WIN32,[test "x$squid_host_os" = "xmingw"])
 
-if test "x$squid_host_os" = "xmingw"; then
+case "$squid_host_os" in
+mingw)
   AC_PATH_PROG(WIN32_PSAPI, psapi.dll, none)
   CFLAGS="$CFLAGS -mthreads"
   CXXFLAGS="$CXXFLAGS -mthreads"
@@ -198,7 +209,16 @@ if test "x$squid_host_os" = "xmingw"; then
   fi
   MINGW_LIBS="-lmingwex"
   AC_SUBST(MINGW_LIBS)
-fi
+  ;;
+freebsd)
+    # FreeBSD places local libraries and packages in /usr/local
+    CFLAGS="$CFLAGS -I/usr/local/include"
+    CXXFLAGS="$CXXFLAGS -I/usr/local/include"
+    LDFLAGS="$LDFLAGS -L/usr/local/lib -Wl,-R/usr/local/lib"
+    ;;
+*)
+    ;;
+esac
 
 dnl Substitutions
 AC_DEFINE_UNQUOTED(CONFIG_HOST_TYPE, "$host",[Host type from configure])
@@ -259,7 +279,7 @@ case $withval in
 ])
 AC_SUBST(DEFAULT_SWAP_DIR)
 
-if test "x$GCC" = "xyes"; then
+if test "$squid_cv_compiler" = "gcc"; then
   GCCVER=`$CC -v 2>&1 | awk '$2 ==  "version" {print $3}'`
   GCCVER2=`echo $GCCVER | awk '{print $1 * 100}'`
   case "$host" in
@@ -276,7 +296,7 @@ fi
 
 dnl Set Default CFLAGS
 if test "x$PRESET_CFLAGS" = "x"; then
-  if test "x$GCC" = "xyes"; then
+  if test "$squid_cv_compiler" = "gcc"; then
     case "$host" in
       *-sun-sunos*)
         # sunos has too many warnings for this to be useful
@@ -310,7 +330,7 @@ if test "x$PRESET_CFLAGS" = "x"; then
 fi
 
 dnl set squid required flags
-if test "x$GCC" = "xyes"; then
+if test "$squid_cv_compiler" = "gcc"; then
   case "$squid_host_os" in
   mingw)
 dnl Guido Serassio (serassio@squid-cache.org) 20070811
@@ -319,12 +339,6 @@ dnl -Werror -Wmissing-prototypes -Wmissing-declarations
 dnl TODO: check if the problem will be present in any other newer MinGW release.
     SQUID_CFLAGS="$squid_cv_cc_option_wall -Wpointer-arith -Wwrite-strings -Wcomments -Wshadow"
     ;;
-  freebsd)
-    # FreeBSD places local libraries and packages in /usr/local
-    CFLAGS="$CFLAGS -I/usr/local/include"
-    CXXFLAGS="$CXXFLAGS -I/usr/local/include"
-    LDFLAGS="$LDFLAGS -L/usr/local/lib -Wl,-R/usr/local/lib"
-    ;;
   *)
     SQUID_CFLAGS="$squid_cv_cc_option_wall -Wpointer-arith -Wwrite-strings -Wmissing-prototypes -Wmissing-declarations -Wcomments -Wshadow"
     ;;
@@ -589,6 +603,16 @@ for module in $squid_disk_module_candidates none; do
               fi
             fi
             ;;
+          openbsd)
+            if test `echo "$squid_host_os_version" | tr -d .` -lt 52 ; then
+                AC_MSG_NOTICE(pthread library requires OpenBSD 5.2 or later)
+                squid_opt_use_diskthreads="no"
+            else
+              SQUID_CFLAGS="$SQUID_CFLAGS -D_REENTRANT"
+              SQUID_CXXFLAGS="$SQUID_CXXFLAGS -D_REENTRANT"
+              LDFLAGS="$LDFLAGS -lpthread"
+            fi
+            ;;
           solaris)
             if test "x$GCC" = "xyes" ; then
               SQUID_CFLAGS="$SQUID_CFLAGS -D_REENTRANT -pthreads"
@@ -1255,6 +1279,11 @@ if test "x$SSLLIBDIR" != "x" ; then
 fi
 AC_SUBST(SSLLIB)
 
+if test "x$with_openssl" = "xyes"; then
+SQUID_CHECK_OPENSSL_GETCERTIFICATE_WORKS
+SQUID_CHECK_OPENSSL_CONST_SSL_METHOD
+SQUID_CHECK_OPENSSL_TXTDB
+fi
 
 AC_ARG_ENABLE(forw-via-db,
   AS_HELP_STRING([--enable-forw-via-db],[Enable Forw/Via database]), [
@@ -1459,7 +1488,17 @@ AC_ARG_ENABLE(pf-transparent,
               [unrecognized argument to --enable-pf-transparent: $enableval])
 ])
 #will be AC_DEFINEd later, after checking for appropriate infrastructure
-AC_MSG_NOTICE([PF-based transparent proxying requested: ${enable_pf_transparent:=auto}])
+AC_MSG_NOTICE([PF-based transparent proxying requested: ${enable_pf_transparent:=no}])
+
+dnl Enable /dev/pf support for older PF Transparent Proxy systems (OpenBSD 4.x and older)
+AC_ARG_WITH(nat-devpf,
+  AS_HELP_STRING([--with-nat-devpf],
+    [Enable /dev/pf support for NAT on older OpenBSD and FreeBSD kernels.]), [
+  SQUID_YESNO([$enableval],
+              [unrecognized argument to --with-nat-devpf: $enableval])
+])
+#will be AC_DEFINEd later, after checking for appropriate infrastructure
+AC_MSG_NOTICE([NAT lookups via /dev/pf: ${with_nat_devpf:=no}])
 
 # Linux Netfilter Transparent Proxy
 AC_ARG_ENABLE(linux-netfilter,
@@ -1549,6 +1588,9 @@ case "$withval" in
 esac
 ])
 
+#hack. Let's early-detect sizeof(long)
+AC_CHECK_SIZEOF(long)
+
 if test "x$squid_opt_enable_large_files" = "xyes" -a "x$buildmodel" = "x"; then
   for model in POSIX_V6_LPBIG_OFFBIG XBS5_LPBIG_OFFBIG POSIX_V6_LP64_OFF64 XBS5_LP64_OFF64 POSIX_V6_ILP32_OFFBIG XBS5_ILP32_OFFBIG; do
     if test "`getconf _$model 2>/dev/null || true`" = 1 || test "`getconf $model 2>/dev/null || true`" ; then
@@ -1561,7 +1603,8 @@ if test "x$squid_opt_enable_large_files" = "xyes" -a "x$buildmodel" = "x"; then
   fi
 fi
 if test "x$buildmodel" = "xdefault" -o "x$buildmodel" = "x"; then
-  if test "x$squid_opt_enable_large_files" = "xyes" ; then
+  # define _FILE_OFFSET_BITS if requested and needed
+  if test "x$squid_opt_enable_large_files" = "xyes" -a $ac_cv_sizeof_long -le 4 ; then
     AC_MSG_NOTICE([Enabling -D_FILE_OFFSET_BITS=64])
     CFLAGS="-D_FILE_OFFSET_BITS=64 $CFLAGS"
     CXXFLAGS="-D_FILE_OFFSET_BITS=64 $CXXFLAGS"
@@ -1706,45 +1749,7 @@ AC_ARG_ENABLE(auth-basic,
       To see available helpers, see the helpers/basic_auth directory. ]),[
 #nothing to do really
 ])
-#not specified. Inherit global
-if test "x$enable_auth_basic" = "x"; then
-    enable_auth_basic=$enable_auth
-fi
-#conflicts with global
-if test "x$enable_auth_basic" != "xno" -a "x$enable_auth" = "xno" ; then
-    AC_MSG_ERROR([Basic auth requested but auth disabled])
-fi
-#define list of modules to build
-if test "x$enable_auth_basic" = "xyes" ; then
-    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/basic_auth],[enable_auth_basic])
-fi
-#handle the "none" special case
-if test "x$enable_auth_basic" = "xnone" ; then
-    enable_auth_basic=""
-fi
-BASIC_AUTH_HELPERS=""
-#enable_auth_basic contains either "no" or the list of modules to be built
-enable_auth_basic="`echo $enable_auth_basic| sed -e 's/,/ /g;s/  */ /g'`"
-if test "x$enable_auth_basic" != "xno" ; then
-    AUTH_MODULES="$AUTH_MODULES basic"
-    AC_DEFINE([HAVE_AUTH_MODULE_BASIC],1,[Basic auth module is built])
-    for helper in $enable_auth_basic
-    do
-    dir="$srcdir/helpers/basic_auth/$helper"
-    if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-      BASIC_AUTH_HELPERS="$BASIC_AUTH_HELPERS $helper"
-      # special case
-      if test "x$helper" = "xSASL" ; then
-        squid_require_sasl=yes
-      fi
-    elif test -d "$srcdir/helpers/basic_auth/$helper" ; then
-      AC_MSG_NOTICE([Basic auth helper $helper ... found but cannot be built])
-    fi
-    done
-fi
-AC_MSG_NOTICE([Basic auth helpers to be built: $BASIC_AUTH_HELPERS])
-AM_CONDITIONAL(ENABLE_AUTH_BASIC, test "x$enable_auth_basic" != "xno")
-AC_SUBST(BASIC_AUTH_HELPERS)
+m4_include([helpers/basic_auth/modules.m4])
 
 AC_ARG_ENABLE(auth-ntlm,
   AS_HELP_STRING([--enable-auth-ntlm="list of helpers"],
@@ -1755,38 +1760,7 @@ AC_ARG_ENABLE(auth-ntlm,
       To enable but build no helpers, specify "none".
       To see available helpers, see the helpers/ntlm_auth directory. ]),[
 ])
-if test "x$enable_auth_ntlm" = "x"; then
-    enable_auth_ntlm=$enable_auth
-fi
-#conflicts with global
-if test "x$enable_auth_ntlm" != "xno" -a "x$enable_auth" = "xno" ; then
-    AC_MSG_ERROR([NTLM auth requested but auth disabled])
-fi
-#define list of modules to build
-if test "x$enable_auth_ntlm" = "xyes" ; then
-    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/ntlm_auth],[enable_auth_ntlm])
-fi
-#handle the "none" special case
-if test "x$enable_auth_ntlm" = "xnone" ; then
-    enable_auth_ntlm=""
-fi
-NTLM_AUTH_HELPERS=""
-enable_auth_ntlm="`echo $enable_auth_ntlm| sed -e 's/,/ /g;s/  */ /g'`"
-if test "x$enable_auth_ntlm" != "xno" ; then
-    AUTH_MODULES="$AUTH_MODULES ntlm"
-    AC_DEFINE([HAVE_AUTH_MODULE_NTLM],1,[NTLM auth module is built])
-    for helper in $enable_auth_ntlm ; do
-        dir="$srcdir/helpers/ntlm_auth/$helper"
-        if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-            NTLM_AUTH_HELPERS="$NTLM_AUTH_HELPERS $helper"
-        elif test -d "$srcdir/helpers/ntlm_auth/$helper" ; then
-            AC_MSG_NOTICE([NTLM auth helper $helper ... found but cannot be built])
-        fi
-    done
-fi
-AC_MSG_NOTICE([NTLM auth helpers built: $NTLM_AUTH_HELPERS])
-AM_CONDITIONAL(ENABLE_AUTH_NTLM, test "x$enable_auth_ntlm" != "xno")
-AC_SUBST(NTLM_AUTH_HELPERS)
+m4_include([helpers/ntlm_auth/modules.m4])
 
 AC_ARG_ENABLE(auth-negotiate,
   AS_HELP_STRING([--enable-auth-negotiate="list of helpers"],
@@ -1800,38 +1774,7 @@ AC_ARG_ENABLE(auth-negotiate,
       To see available helpers, see the helpers/negotiate_auth directory. ]),[
 #nothing to do, really
 ])
-if test "x$enable_auth_negotiate" = "x"; then
-    enable_auth_negotiate=$enable_auth
-fi
-#conflicts with global
-if test "x$enable_auth_negotiate" != "xno" -a "x$enable_auth" = "xno" ; then
-    AC_MSG_ERROR([Negotiate auth requested but auth disabled])
-fi
-#define list of modules to build
-if test "x$enable_auth_negotiate" = "xyes" ; then
-    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/negotiate_auth],[enable_auth_negotiate])
-fi
-#handle the "none" special case
-if test "x$enable_auth_negotiate" = "xnone" ; then
-    enable_auth_negotiate=""
-fi
-NEGOTIATE_AUTH_HELPERS=""
-enable_auth_negotiate="`echo $enable_auth_negotiate| sed -e 's/,/ /g;s/  */ /g'`"
-if test "x$enable_auth_negotiate" != "xno" ; then
-    AUTH_MODULES="$AUTH_MODULES negotiate"
-    AC_DEFINE([HAVE_AUTH_MODULE_NEGOTIATE],1,[Negotiate auth module is built])
-    for helper in $enable_auth_negotiate ; do
-        dir="$srcdir/helpers/negotiate_auth/$helper"
-        if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-            NEGOTIATE_AUTH_HELPERS="$NEGOTIATE_AUTH_HELPERS $helper"
-        elif test -d "$srcdir/helpers/negotiate_auth/$helper" ; then
-            AC_MSG_NOTICE([Negotiate auth helper $helper ... found but cannot be built])
-        fi
-    done
-fi
-AC_MSG_NOTICE([Negotiate auth helpers built: $NEGOTIATE_AUTH_HELPERS])
-AM_CONDITIONAL(ENABLE_AUTH_NEGOTIATE, test "x$enable_auth_negotiate" != "xno")
-AC_SUBST(NEGOTIATE_AUTH_HELPERS)
+m4_include([helpers/negotiate_auth/modules.m4])
 
 AC_ARG_ENABLE(auth-digest,
   AS_HELP_STRING([--enable-auth-digest="list of helpers"],
@@ -1843,38 +1786,7 @@ AC_ARG_ENABLE(auth-digest,
       To see available helpers, see the helpers/digest_auth directory. ]),[
 #nothing to do, really
 ])
-if test "x$enable_auth_digest" = "x"; then
-    enable_auth_digest=$enable_auth
-fi
-#conflicts with global
-if test "x$enable_auth_digest" != "xno" -a "x$enable_auth" = "xno" ; then
-    AC_MSG_ERROR([Digest auth requested but auth disabled])
-fi
-#define list of modules to build
-if test "x$enable_auth_digest" = "xyes" ; then
-    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/digest_auth],[enable_auth_digest])
-fi
-#handle the "none" special case
-if test "x$enable_auth_digest" = "xnone" ; then
-    enable_auth_digest=""
-fi
-DIGEST_AUTH_HELPERS=""
-enable_auth_digest="`echo $enable_auth_digest| sed -e 's/,/ /g;s/  */ /g'`"
-if test "x$enable_auth_digest" != "xno" ; then
-    AUTH_MODULES="$AUTH_MODULES digest"
-    AC_DEFINE([HAVE_AUTH_MODULE_DIGEST],1,[Digest auth module is built])
-    for helper in $enable_auth_digest ; do
-        dir="$srcdir/helpers/digest_auth/$helper"
-        if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-            DIGEST_AUTH_HELPERS="$DIGEST_AUTH_HELPERS $helper"
-        elif test -d "$srcdir/helpers/digest_auth/$helper" ; then
-            AC_MSG_NOTICE([Digest auth helper $helper ... found but cannot be built])
-        fi
-    done
-fi
-AC_MSG_NOTICE([Digest auth helpers built: $DIGEST_AUTH_HELPERS])
-AM_CONDITIONAL(ENABLE_AUTH_DIGEST, test "x$enable_auth_digest" != "xno")
-AC_SUBST(DIGEST_AUTH_HELPERS)
+m4_include([helpers/digest_auth/modules.m4])
 
 dnl Authentication libraries to build
 dnl This list will not be needed when each auth library has its own Makefile
@@ -1887,33 +1799,15 @@ AC_SUBST(AUTH_MODULES)
 AC_SUBST(AUTH_LIBS_TO_BUILD)
 
 dnl Select logging daemon helpers to build
-squid_opt_logdaemon_helpers="auto"
 AC_ARG_ENABLE(log-daemon-helpers,
   AS_HELP_STRING([--enable-log-daemon-helpers="list of helpers"],
                  [This option selects which logging daemon helpers to 
                   build and install as part of the normal build process
                   For a list of available helpers see the helpers/log_daemon
                   directory.]),[
-case "$enableval" in
-  yes) : ;;
-  no)  squid_opt_logdaemon_helpers="" ;;
-  *)   squid_opt_logdaemon_helpers="`echo $enableval| sed -e 's/,/ /g;s/  */ /g'`" ;;
-  esac
+#nothing to do, really
 ])
-if test "x$squid_opt_logdaemon_helpers" = "xauto" ; then
-  squid_opt_logdaemon_helpers=""
-  SQUID_LOOK_FOR_MODULES([$srcdir/helpers/log_daemon],[squid_opt_logdaemon_helpers])
-fi
-for helper in $squid_opt_logdaemon_helpers ; do
-  dir="$srcdir/helpers/log_daemon/$helper"
-  if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-    LOG_DAEMON_HELPERS="$LOG_DAEMON_HELPERS $helper"
-  elif test -d "$srcdir/helpers/log_daemon/$helper" ; then
-    AC_MSG_NOTICE([Log daemon helper $helper ... found but cannot be built])
-  fi
-done
-AC_MSG_NOTICE([Log daemon helpers built: $LOG_DAEMON_HELPERS])
-AC_SUBST(LOG_DAEMON_HELPERS)
+m4_include([helpers/log_daemon/modules.m4])
 
 dnl
 dnl Check Kerberos/GSSAPI/SPNEGO
@@ -2060,33 +1954,7 @@ AC_ARG_ENABLE(external-acl-helpers,
                   directory]), [
 #nothing to do, really
 ])
-if test "x${enable_external_acl_helpers:=yes}" = "xyes" ;then
-  SQUID_LOOK_FOR_MODULES([$srcdir/helpers/external_acl],
-    [enable_external_acl_helpers])
-fi
-if test "x$enable_external_acl_helpers" = "xnone" ; then
-  enable_external_acl_helpers=""
-fi
-EXTERNAL_ACL_HELPERS=""
-enable_external_acl_helpers="`echo $enable_external_acl_helpers| sed -e 's/,/ /g;s/  */ /g'`"
-if test "x$enable_external_acl_helpers" != "xno" ; then
-  for helper in $enable_external_acl_helpers ; do
-    dir="$srcdir/helpers/external_acl/$helper"
-    if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-      EXTERNAL_ACL_HELPERS="$EXTERNAL_ACL_HELPERS $helper"
-      # special case
-      if test "x$helper" = "xkerberos_ldap_group" ; then
-        squid_require_sasl=yes
-      fi
-    else
-      AC_MSG_NOTICE([external acl helper $helper ... found but cannot be built])
-    fi
-  done
-fi
-AC_MSG_NOTICE([External acl helpers built: $EXTERNAL_ACL_HELPERS])
-AC_SUBST(EXTERNAL_ACL_HELPERS)
-
-
+m4_include([helpers/external_acl/modules.m4])
 
 dnl Select url_rewrite helpers to build
 AC_ARG_ENABLE(url-rewrite-helpers,
@@ -2098,28 +1966,19 @@ AC_ARG_ENABLE(url-rewrite-helpers,
                   For a list of available helpers see the
                   helpers/url_rewrite directory.]),[
 ])
-if test "x${enable_url_rewrite_helpers:=yes}" = "xyes" ; then
-    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/url_rewrite],
-                           [enable_url_rewrite_helpers])
-fi
-enable_url_rewrite_helpers="`echo $enable_url_rewrite_helpers| sed -e 's/,/ /g;s/  */ /g'`"
-AC_MSG_NOTICE([URL rewrite helper candidates: $enable_url_rewrite_helpers])
-URL_REWRITE_HELPERS=""
-if test "x$enable_url_rewrite_helpers" != "xno" ; then
-  for helper in $enable_url_rewrite_helpers; do
-    dir="$srcdir/helpers/url_rewrite/$helper"
-    if test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
-      URL_REWRITE_HELPERS="$URL_REWRITE_HELPERS $helper"
-    elif test -d "$srcdir/helpers/ntlm_auth/$helper" ; then
-      AC_MSG_NOTICE([URL rewrite helper $helper ... found but cannot be built])
-    else
-      AC_MSG_NOTICE([URL rewrite helper $helper ... not found])
-    fi
-  done
-fi
-AC_MSG_NOTICE([URL rewrite helpers built: $URL_REWRITE_HELPERS])
-AC_SUBST(URL_REWRITE_HELPERS)
+m4_include([helpers/url_rewrite/modules.m4])
 
+dnl Select storeid_rewrite helpers to build
+AC_ARG_ENABLE(storeid-rewrite-helpers,
+  AS_HELP_STRING([--enable-storeid-rewrite-helpers="list of helpers"],
+                 [This option selects which Store-ID rewrite helpers to
+                  build and install as part of the normal build
+                  process. The default is to attempt the build of all possible
+                  helpers. Use --disable-storeid-rewrite-helpers to build none.
+                  For a list of available helpers see the
+                  helpers/storeid_rewrite directory.]),[
+])
+m4_include([helpers/storeid_rewrite/modules.m4])
 
 AC_ARG_WITH(valgrind-debug,
   AS_HELP_STRING([--with-valgrind-debug],
@@ -2164,27 +2023,6 @@ SQUID_DEFINE_BOOL(USE_WIN32_SERVICE,${enable_win32_service:=no},
 AC_MSG_NOTICE([MS Windows service mode enabled: $enable_win32_service])
 
 
-# Check for Cyrus SASL
-if test "x$squid_require_sasl" = "xyes"; then
-  AC_CHECK_HEADERS(sasl/sasl.h sasl.h)
-  AC_CHECK_LIB(sasl2,sasl_errstring,[LIBSASL="-lsasl2"],[
-    AC_CHECK_LIB(sasl,sasl_errstring,[LIBSASL="-lsasl"], [
-      AC_MSG_ERROR(Neither SASL nor SASL2 found)
-    ])
-  ])
-  case "$squid_host_os" in
-    Darwin)
-      if test "$ac_cv_lib_sasl2_sasl_errstring" = "yes" ; then
-        AC_DEFINE(HAVE_SASL_DARWIN,1,[Define to 1 if Mac Darwin without sasl.h])
-        echo "checking for MAC Darwin without sasl.h ... yes"
-      else
-        echo "checking for MAC Darwin without sasl.h ... no"
-      fi
-      ;;
-  esac
-  AC_SUBST(LIBSASL)
-fi
-
 # Disable "unlinkd" code
 AC_ARG_ENABLE(unlinkd,
   AS_HELP_STRING([--disable-unlinkd],[Do not use unlinkd]), [
@@ -2381,7 +2219,6 @@ AC_CHECK_HEADERS( \
   shadow.h \
   regex.h \
   sched.h \
-  security/pam_appl.h \
   siginfo.h \
   signal.h \
   sstream \
@@ -2433,10 +2270,9 @@ AC_CHECK_HEADERS( \
   wchar.h
 )
 
-CHECK_STRUCT_PAM_CONV
-
-AC_CHECK_HEADERS(
-  linux/netfilter_ipv4.h
+AC_CHECK_HEADERS( \
+  linux/netfilter_ipv4.h \
+  linux/netfilter_ipv6/ip6_tables.h \
 ,,,
 SQUID_DEFAULT_INCLUDES
 #if HAVE_LIMITS_H
@@ -3349,22 +3185,24 @@ dnl Solaris minor version (8, 9, 10, ...)
   CXXFLAGS="-DSOLARIS2=$solrev $CXXFLAGS" 
 fi
 
-dnl PF support requires a header file.
-if test "x$enable_pf_transparent" != "xno" ; then
+dnl PF /dev/pf support requires a header file.
+if test "x$with_nat_devpf" != "xno" ; then
   if test "x$ac_cv_header_net_pfvar_h" = "xyes" -o \
     "x$ac_cv_header_net_pf_pfvar_h" = "xyes"; then
-    if test "x$enable_pf_transparent" = "xauto" ; then
-      enable_pf_transparent="yes"
+    if test "x$with_nat_devpf" = "xauto" ; then
+      with_nat_devpf="no"
     fi
   else
-    if test "x$enable_pf_transparent" = "xyes" ; then
-      AC_MSG_ERROR([PF-based transparent proxy requested but needed header not found])
+    if test "x$with_nat_devpf" = "xyes" ; then
+      AC_MSG_ERROR([PF /dev/pf based NAT requested but needed header not found])
     fi
-    enable_pf_transparent="no"
+    with_nat_devpf="no"
   fi
 fi
-SQUID_DEFINE_BOOL(PF_TRANSPARENT,$enable_pf_transparent,
+SQUID_DEFINE_BOOL(PF_TRANSPARENT,${enable_pf_transparent:=no},
   [Enable support for PF-style transparent proxying])
+SQUID_DEFINE_BOOL(USE_NAT_DEVPF,${with_nat_devpf:=no},
+  [Enable support for /dev/pf NAT lookups])
 
 if test "x$enable_linux_netfilter" != "xno" ; then
   if test "x$ac_cv_header_linux_netfilter_ipv4_h" = "xyes"; then
@@ -3553,6 +3391,8 @@ AC_CONFIG_FILES([\
 	compat/Makefile \
 	lib/Makefile \
 	lib/ntlmauth/Makefile \
+	lib/libTrie/Makefile \
+	lib/libTrie/test/Makefile \
 	lib/profiler/Makefile \
 	lib/rfcnb/Makefile \
 	lib/smblib/Makefile \
@@ -3637,12 +3477,12 @@ AC_CONFIG_FILES([\
 	helpers/url_rewrite/Makefile \
 	helpers/url_rewrite/fake/Makefile \
 	helpers/ssl/Makefile \
+	helpers/storeid_rewrite/Makefile \
+	helpers/storeid_rewrite/file/Makefile \
 	tools/Makefile
 	tools/purge/Makefile
 ])
 
-AC_CONFIG_SUBDIRS(lib/libTrie)
-
 # must configure libltdl subdir unconditionally for "make distcheck" to work
 #AC_CONFIG_SUBDIRS(libltdl)
 
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.2.9 release notes</title>
+<title>Squid 3.2.13 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.2.9.
+The Squid Team are pleased to announce the release of Squid-3.2.13.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.2/"> or the
  <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.3.3 release notes</title>
+<title>Squid 3.3.8 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.3.3.
+The Squid Team are pleased to announce the release of Squid-3.3.8.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.3/"> or the 
 <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
@@ -206,6 +206,12 @@ This section gives a thorough account of those changes in three categories:
 	   <em>ssl::certUntrusted</em>,
 	   <em>ssl::certSelfSigned</em>.
 
+	<tag>external_acl_type</tag>
+	<p><em>%ACL</em> format tag ported from 2.6.
+	   Sends the name of ACL being tested to the external helper.
+	<p><em>%DATA</em> format tag ported from 2.6.
+	   Inserts the ACL arguments into a particular location of the helper input instead of at the end of the line.
+
 	<tag>logformat</tag>
 	<p>New token <em>%ssl::bump_mode</em> to log the SSL-bump mode type performed on a request.
 	  Logs values of: <em>-</em>, <em>none</em>, <em>client-first</em>, or <em>server-first</em>.
@@ -309,16 +315,9 @@ This section gives an account of those changes in three categories:
 	<tag>error_map</tag>
 	<p>Not yet ported from 2.6
 
-	<tag>external_acl_type</tag>
-	<p><em>%ACL</em> format tag not yet ported from 2.6
-	<p><em>%DATA</em> format tag not yet ported from 2.6
-
 	<tag>external_refresh_check</tag>
 	<p>Not yet ported from 2.7
 
-	<tag>http_port</tag>
-	<p><em>act-as-origin</em> not yet ported from 2.7
-
 	<tag>ignore_ims_on_miss</tag>
 	<p>Not yet ported from 2.7
 
@@ -1,7 +1,7 @@
 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
 <HTML>
 <HEAD>
- <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.66">
+ <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.69">
  <TITLE>Squid 3.4.0.0 release notes</TITLE>
 </HEAD>
 <BODY>
@@ -26,6 +26,7 @@ <H2><A NAME="toc2">2.</A> <A HREF="#s2">Major new features since Squid-3.3</A></
 <UL>
 <LI><A NAME="toc2.1">2.1</A> <A HREF="#ss2.1">Helper protocol extensions</A>
 <LI><A NAME="toc2.2">2.2</A> <A HREF="#ss2.2">SSL Server Certificate Validator</A>
+<LI><A NAME="toc2.3">2.3</A> <A HREF="#ss2.3">TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+</A>
 </UL>
 <P>
 <H2><A NAME="toc3">3.</A> <A HREF="#s3">Changes to squid.conf since Squid-3.3</A></H2>
@@ -55,17 +56,19 @@ <H2><A NAME="s1">1.</A> <A HREF="#toc1">Notice</A></H2>
 
 <P>The Squid Team are pleased to announce the release of Squid-3.4.0.0 for testing.</P>
 <P>This new release is available for download from 
-<A HREF="http://www.squid-cache.org/Versions/v3/3.HEAD/">http://www.squid-cache.org/Versions/v3/3.HEAD/</A> or the 
+<A HREF="http://www.squid-cache.org/Versions/v3/3.HEAD/">http://www.squid-cache.org/Versions/v3/3.HEAD/</A> or the
 <A HREF="http://www.squid-cache.org/Mirrors/http-mirrors.html">mirrors</A>.</P>
 <P>While this release is not deemed ready for production use, we believe it is ready for wider testing by the community.</P>
 <P>We welcome feedback and bug reports. If you find a bug, please see 
-<A HREF="http://wiki.squid-cache.org/SquidFaq/TroubleShooting#head-7067fc0034ce967e67911becaabb8c95a34d576d">http://wiki.squid-cache.org/SquidFaq/TroubleShooting#head-7067fc0034ce967e67911becaabb8c95a34d576d</A> for how to submit a report with a stack trace.</P>
+<A HREF="http://wiki.squid-cache.org/SquidFaq/BugReporting">http://wiki.squid-cache.org/SquidFaq/BugReporting</A>
+for how to submit a report with a stack trace.</P>
 
 <H2><A NAME="ss1.1">1.1</A> <A HREF="#toc1.1">Known issues</A>
 </H2>
 
 <P>Although this release is deemed good enough for use in many setups, please note the existence of 
-<A HREF="http://www.squid-cache.org/bugs/buglist.cgi?query_format=advanced&amp;short_desc_type=allwordssubstr&amp;short_desc=&amp;target_milestone=3.4&amp;long_desc_type=allwordssubstr&amp;long_desc=&amp;bug_file_loc_type=allwordssubstr&amp;bug_file_loc=&amp;status_whiteboard_type=allwordssubstr&amp;status_whiteboard=&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;emailtype1=substring&amp;email1=&amp;emailtype2=substring&amp;email2=&amp;bugidtype=include&amp;bug_id=&amp;votes=&amp;chfieldfrom=&amp;chfieldto=Now&amp;chfieldvalue=&amp;cmdtype=doit&amp;order=bugs.bug_severity&amp;field0-0-0=noop&amp;type0-0-0=noop&amp;value0-0-0=">open bugs against Squid-3.4</A>.</P>
+<A HREF="http://bugs.squid-cache.org/buglist.cgi?query_format=advanced&amp;product=Squid&amp;bug_status=UNCONFIRMED&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;version=3.4">open bugs against Squid-3.4</A>.</P>
+
 
 <H2><A NAME="ss1.2">1.2</A> <A HREF="#toc1.2">Changes since earlier releases of Squid-3.4</A>
 </H2>
@@ -81,6 +84,7 @@ <H2><A NAME="s2">2.</A> <A HREF="#toc2">Major new features since Squid-3.3</A></
 <UL>
 <LI>Helper protocol extensions</LI>
 <LI>SSL Server Certificate Validator</LI>
+<LI>TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+</LI>
 </UL>
 </P>
 <P>Most user-facing changes are reflected in squid.conf (see below).</P>
@@ -142,6 +146,30 @@ <H2><A NAME="ss2.2">2.2</A> <A HREF="#toc2.2">SSL Server Certificate Validator</
 <EM>ssl_crtd</EM> related options. </P>
 
 
+<H2><A NAME="ss2.3">2.3</A> <A HREF="#toc2.3">TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+</A>
+</H2>
+
+<P>Details at 
+<A HREF="http://wiki.squid-cache.org/ConfigExamples/Intercept/OpenBsdPf">http://wiki.squid-cache.org/ConfigExamples/Intercept/OpenBsdPf</A>.</P>
+
+<P>The Packet Filter (PF) firewall in OpenBSD 4.4 and later offers traffic interception
+using several very simple methods. One of which is the <EM>divert-to</EM> rule type
+which acts as a simple routing diversion instead of performing NAT packet alterations.</P>
+
+<P>The IP Firewall (IPFW) on FreeBSD 9+ contains a port of the Linux Netfilter TPROXY feature.</P>
+
+<P>This version of Squid adds support for these features through the ./configure
+options --enable-pf-transparent and --enable-ipfw-transparent when Squid is built on
+systems with the required support. No special extras are required to enable
+<EM>http_port ... tproxy</EM> configuration to work.</P>
+
+<P>NOTE: To resolve NAT lookup issues on recent PF firewall versions the code behind
+<EM>./configure --enable-pf-transparent</EM> has been altered and is expected to
+break on the version of PF firewall shipped with BSD systems such as NetBSD and FreeBSD
+which do not yet support the getsockname() API.
+These systems require <EM>--with-nat-devpf</EM> to enable /dev/pf support when using PF firewall.</P>
+
+
 <H2><A NAME="s3">3.</A> <A HREF="#toc3">Changes to squid.conf since Squid-3.3</A></H2>
 
 <P>There have been changes to Squid's configuration file since Squid-3.3.</P>
@@ -167,6 +195,9 @@ <H2><A NAME="newtags"></A> <A NAME="ss3.1">3.1</A> <A HREF="#toc3.1">New tags</A
 <P>Use ACLs to annotate a transaction with customized annotations
 which can be logged in access.log</P>
 
+<DT><B>spoof_client_ip</B><DD>
+<P>Access control to determine whether to disable the TPROXY spoofing on upstream traffic.</P>
+
 <DT><B>sslcrtvalidator_children</B><DD>
 <P>Specifies the settings for how many SSL server certificate
 validator helpers are run and when they are started.</P>
@@ -203,6 +234,12 @@ <H2><A NAME="modifiedtags"></A> <A NAME="ss3.2">3.2</A> <A HREF="#toc3.2">Change
 <P>Details at 
 <A HREF="http://wiki.squid-cache.org/Features/AddonHelpers">http://wiki.squid-cache.org/Features/AddonHelpers</A>.</P>
 
+<DT><B>http_port</B><DD>
+<P>Support <EM>tproxy</EM> mode traffic on BSD systems with BINDANY support
+(OpenBSD 5+, FreeBSD 9+ so far).</P>
+<P>Changed build options behind <EM>intercept</EM> traffic mode handling on BSD.
+see <EM>--enable-pf-transparent</EM> for more details.</P>
+
 <DT><B>logformat</B><DD>
 <P>New format code <EM>%note</EM> to log a transaction annotation linked to the
 transaction by ICAP, eCAP, a helper, or the <EM>note</EM> squid.conf directive.</P>
@@ -231,6 +268,18 @@ <H2><A NAME="removedtags"></A> <A NAME="ss3.3">3.3</A> <A HREF="#toc3.3">Removed
 <DL>
 <P><EM>There are no removed squid.conf tags in Squid-3.4.</EM></P>
 
+<DT><B>storeurl_access</B><DD>
+<P>Not yet ported from 2.7</P>
+
+<DT><B>storeurl_rewrite_children</B><DD>
+<P>Not yet ported from 2.7</P>
+
+<DT><B>storeurl_rewrite_concurrency</B><DD>
+<P>Not yet ported from 2.7</P>
+
+<DT><B>storeurl_rewrite_program</B><DD>
+<P>Not yet ported from 2.7</P>
+
 </DL>
 </P>
 
@@ -256,7 +305,14 @@ <H2><A NAME="newoptions"></A> <A NAME="ss4.1">4.1</A> <A HREF="#toc4.1">New opti
 
 <P>
 <DL>
-<P><EM>There are no new ./configure options in Squid-3.4.</EM></P>
+<DT><B>--with-nat-pf</B><DD>
+<P>New option to alter the behaviour of <EM>http_port ... intercept</EM> option
+in squid.conf.</P>
+<P>When this option is used Squid performs the /dev/pf lookups required to
+support PF <EM>rdr-to</EM> rules. Otherwise Squid will perform perform the
+getsockname() API calls to support PF <EM>divert-to</EM> rules.</P>
+<P>NOTE: systems such as NetBSD and FreeBSD which do not yet support
+the getsockname() API in recent PF versions require this option.</P>
 
 </DL>
 </P>
@@ -266,7 +322,14 @@ <H2><A NAME="modifiedoptions"></A> <A NAME="ss4.2">4.2</A> <A HREF="#toc4.2">Cha
 
 <P>
 <DL>
-<P><EM>There are no changed ./configure options in Squid-3.4.</EM></P>
+<DT><B>--enable-pf-transparent</B><DD>
+<P>NAT table support updated to use the getsockname() API provided by the
+latest PF versions <EM>divert-to</EM>. This allows <EM>http_port</EM>
+in squid.conf to support both <EM>intercept</EM> and <EM>tproxy</EM> traffic
+and to silence NAT lookup failure messages on recent BSD.</P>
+<P>NOTE: systems such as NetBSD and FreeBSD which do not yet support
+the getsockname() API in recent PF versions require <EM>--with-nat-devpf</EM>
+to re-enable /dev/pf support when using PF firewall.</P>
 
 </DL>
 </P>
@@ -318,16 +381,9 @@ <H2><A NAME="ss5.1">5.1</A> <A HREF="#toc5.1">Missing squid.conf options availab
 <DT><B>error_map</B><DD>
 <P>Not yet ported from 2.6</P>
 
-<DT><B>external_acl_type</B><DD>
-<P><EM>%ACL</EM> format tag not yet ported from 2.6</P>
-<P><EM>%DATA</EM> format tag not yet ported from 2.6</P>
-
 <DT><B>external_refresh_check</B><DD>
 <P>Not yet ported from 2.7</P>
 
-<DT><B>http_port</B><DD>
-<P><EM>act-as-origin</EM> not yet ported from 2.7</P>
-
 <DT><B>ignore_ims_on_miss</B><DD>
 <P>Not yet ported from 2.7</P>
 
@@ -351,18 +407,6 @@ <H2><A NAME="ss5.1">5.1</A> <A HREF="#toc5.1">Missing squid.conf options availab
 <DT><B>refresh_stale_hit</B><DD>
 <P>Not yet ported from 2.7</P>
 
-<DT><B>storeurl_access</B><DD>
-<P>Not yet ported from 2.7</P>
-
-<DT><B>storeurl_rewrite_children</B><DD>
-<P>Not yet ported from 2.7</P>
-
-<DT><B>storeurl_rewrite_concurrency</B><DD>
-<P>Not yet ported from 2.7</P>
-
-<DT><B>storeurl_rewrite_program</B><DD>
-<P>Not yet ported from 2.7</P>
-
 <DT><B>update_headers</B><DD>
 <P>Not yet ported from 2.7</P>
 
@@ -40,6 +40,9 @@ The 3.4 change history can be <url url="http://www.squid-cache.org/Versions/v3/3
 <itemize>
 	<item>Helper protocol extensions
 	<item>SSL Server Certificate Validator
+	<item>Store-ID
+	<item>TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+
+	<item>Transaction Annotations
 </itemize>
 
 Most user-facing changes are reflected in squid.conf (see below).
@@ -93,6 +96,84 @@ Most user-facing changes are reflected in squid.conf (see below).
    <em>ssl_crtd</em> related options. 
 
 
+<sect1>Store-ID
+<p>Details at <url url="http://wiki.squid-cache.org/Features/StoreID">.
+
+<p>This feature is a redesigned equivalent to the Squid-2.7 feature known as StoreURL-rewrite.
+
+<p><em>Notice</em> that this is not a direct portage of the Squid-2.7 feature so behaviour
+  differences do exist. Although the new feature works in similar enough ways that the old
+  helper scripts used for Squid-2.7 are expected to work in this and later versions of Squid.
+
+<p>Squid traditionally uses the requested URL as an index key ID to locate objects in cache.
+   It is not the only key possible and the Store-ID feature exposes an API for external
+   helpers to provide Squid with an alternative key name for any URL.
+
+<p>When any client request is received which requires a cache lookup the URL is passed to
+   a helper specified with the <em>store_id_rewrite_program</em> directive to check for
+   an alternative Store ID. This allows the helper to identify URLs which refer to duplicate
+   resources and de-duplicate the cache content. <em>store_id_access</em> is provided to
+   allow ACL-based tuning of which traffic gets sent to the helper and reduce overheads.
+
+<p>One subtle and noteworthy difference between Squid-2 and Squid-3 which is highlighted by
+   this feature is that <em>refresh_pattern</em> applies its regex argument against the Store
+   ID key and not the transaction URL. So using the Store-ID feature to alter the value
+   affects which <em>refresh_pattern</em> directive will be matched.
+
+<p>Store-ID helpers bundled with Squid can be built with the --enable-storeid-rewrite-helpers
+   options which is added in this version. Currently there is a <em>file</em> helper
+   provided.
+
+
+<sect1>TPROXY Support for OpenBSD 5.1+ and FreeBSD 9+
+<p>Details at <url url="http://wiki.squid-cache.org/ConfigExamples/Intercept/OpenBsdPf">.
+
+<p>The Packet Filter (PF) firewall in OpenBSD 4.4 and later offers traffic interception
+   using several very simple methods. One of which is the <em>divert-to</em> rule type
+   which acts as a simple routing diversion instead of performing NAT packet alterations.
+
+<p>The IP Firewall (IPFW) on FreeBSD 9+ contains a port of the Linux Netfilter TPROXY feature.
+
+<p>This version of Squid adds support for these features through the ./configure
+   options --enable-pf-transparent and --enable-ipfw-transparent when Squid is built on
+   systems with the required support. No special extras are required to enable
+   <em>http_port ... tproxy</em> configuration to work.
+
+<p>NOTE: To resolve NAT lookup issues on recent PF firewall versions the code behind
+   <em>./configure --enable-pf-transparent</em> has been altered and is expected to
+   break on the version of PF firewall shipped with BSD systems such as NetBSD and FreeBSD
+   which do not yet support the getsockname() API.
+   These systems require <em>--with-nat-devpf</em> to enable /dev/pf support when using PF firewall.
+
+<sect1>Transaction Annotations
+<p>Previously the only annotation methods available were ICAP/eCAP HTTP header insertions
+   or external ACL <em>tag=</em> result code. Each of which had only limited possibilities
+   for use and little or no correlation.
+
+<p>It is now possible to add annotations to a client transaction from several sources:
+<itemize>
+	<item>	Directly from squid.conf using the <em>note</em> directive with
+		ACL-based selection of which annotation is linked to any
+		particular transaction.
+
+	<item>	By configured helper processes returning a key=value pair.
+		The key name becomes the annotation name.
+</itemize>
+
+<p>Annotations on the transaction can be passed to ICAP services or eCAP modules using the
+   <em>adaptation_meta</em> directive to send them as headers.
+   They can also be logged using the <em>%note</em> log format code in custom logs. With
+   the new helper response syntax changes this means all helper response key=value details
+   such as URL-rewrite or store-id changes, external ACL tag etc. are now able to be logged.
+
+<p>Annotations which are already assigned to a transaction can be checked using an ACL test
+   of the new <em>note</em> ACL type. This can match a particular note by name and value,
+   of for any notes with a given name.
+
+<p>NOTE: not all helper interfaces are yet enabled to convert key=value into annotations
+	 and the external ACL interface does not yet send annotations to the helper.
+
+
 <sect>Changes to squid.conf since Squid-3.3
 <p>
 There have been changes to Squid's configuration file since Squid-3.3.
@@ -113,6 +194,9 @@ This section gives a thorough account of those changes in three categories:
 	<p>Use ACLs to annotate a transaction with customized annotations
 	   which can be logged in access.log
 
+	<tag>spoof_client_ip</tag>
+	<p>Access control to determine whether to disable the TPROXY spoofing on upstream traffic.
+
 	<tag>sslcrtvalidator_children</tag>
 	<p>Specifies the settings for how many SSL server certificate
 	   validator helpers are run and when they are started.
@@ -125,9 +209,24 @@ This section gives a thorough account of those changes in three categories:
 <sect1>Changes to existing tags<label id="modifiedtags">
 <p>
 <descrip>
+	<tag>access_log</tag>
+	<p>Configuration syntax extended to support name=value options.
+	  <em>New Syntax:</em> access_log module:place [option ...] [acl ...]
+	<p>New option <em>logformat=</em> to specify the logging format name.
+	<p>New option <em>buffer-size=</em> to specify how large the log buffer
+	   for this log is to be when <em>buffered_logs</em> is enabled.
+	<p>New option <em>on-error=</em> to specify what handling is to be done
+	   if the logging module encounters a non-recoverable error writing logs.
+	   With the value <em>die</em> (the default) Squid halts operation.
+	   With the value <em>drop</em> Squid drops log lines and continue running.
+
 	<tag>acl</tag>
 	<p>New test type <em>server_cert_fingerprint</em> to match against 
 	   server SSL certificate fingerprint.
+	<p>New test type <em>note</em> to match against transaction annotations
+	   by name and value, or just by name.
+	<p>New test type <em>any-of</em> to match if any one of a set of named ACLs.
+	<p>New test type <em>all-of</em> to match against all of a set of named ACLs.
 
 	<tag>auth_param</tag>
 	<p>New result code <em>BH</em> to signal helper internal errors
@@ -144,10 +243,23 @@ This section gives a thorough account of those changes in three categories:
 	<p>New result code <em>BH</em> to signal helper internal errors
 	<p>Details at <url url="http://wiki.squid-cache.org/Features/AddonHelpers">.
 
+	<tag>http_port</tag>
+	<p>Support IPv6 for <em>intercept</em> mode. Requires ip6tables support on Linux,
+	   PF support on OpenBSD and IPFW support on FreeBSD. Squid will no longer complain
+	   about misconfiguration if IPv6 support is missing, we now rely on the firewall
+	   tools reporting misconfiguration when the NAT rules are created.
+	<p>Support <em>tproxy</em> mode traffic on BSD systems with BINDANY support
+	   (OpenBSD 5+, FreeBSD 9+ so far).
+	<p>Changed build options behind <em>intercept</em> traffic mode handling on BSD.
+	   see <em>--enable-pf-transparent</em> for more details.
+
 	<tag>logformat</tag>
 	<p>New format code <em>%note</em> to log a transaction annotation linked to the
 	   transaction by ICAP, eCAP, a helper, or the <em>note</em> squid.conf directive.
 
+	<tag>pipeline_prefetch</tag>
+	<p>Updated to take a numeric count of prefetched pipeline requests instead of ON/OFF.
+
 	<tag>unlinkd_program</tag>
 	<p>New helper response format utilizing result codes <em>OK</em> and <em>BH</em>,
 	   to signal helper lookup results. Also, key-value response values to return
@@ -186,14 +298,34 @@ This section gives an account of those changes in three categories:
 <sect1>New options<label id="newoptions">
 <p>
 <descrip>
-	<p><em>There are no new ./configure options in Squid-3.4.</em>
+	<tag>--enable-storeid-rewrite-helpers</tag>
+	<p>New option to control which Store-ID helpers are built. As with other
+	   helper options use --disable-* to prevent any helpers building and
+	   omit to get all helper auto-detected.
+	<p>Currenly only a helper using <em>file</em> for backend is provided.
+
+	<tag>--with-nat-pf</tag>
+	<p>New option to alter the behaviour of <em>http_port ... intercept</em> option
+	   in squid.conf.
+	<p>When this option is used Squid performs the /dev/pf lookups required to
+	   support PF <em>rdr-to</em> rules. Otherwise Squid will perform perform the
+	   getsockname() API calls to support PF <em>divert-to</em> rules.
+	<p>NOTE: systems such as NetBSD and FreeBSD which do not yet support
+	   the getsockname() API in recent PF versions require this option.
 
 </descrip>
 
 <sect1>Changes to existing options<label id="modifiedoptions">
 <p>
 <descrip>
-	<p><em>There are no changed ./configure options in Squid-3.4.</em>
+	<tag>--enable-pf-transparent</tag>
+	<p>NAT table support updated to use the getsockname() API provided by the
+	   latest PF versions <em>divert-to</em>. This allows <em>http_port</em>
+	   in squid.conf to support both <em>intercept</em> and <em>tproxy</em> traffic
+	   and to silence NAT lookup failure messages on recent BSD.
+	<p>NOTE: systems such as NetBSD and FreeBSD which do not yet support
+	   the getsockname() API in recent PF versions require <em>--with-nat-devpf</em>
+	   to re-enable /dev/pf support when using PF firewall.
 
 </descrip>
 </p>
@@ -241,16 +373,9 @@ This section gives an account of those changes in three categories:
 	<tag>error_map</tag>
 	<p>Not yet ported from 2.6
 
-	<tag>external_acl_type</tag>
-	<p><em>%ACL</em> format tag not yet ported from 2.6
-	<p><em>%DATA</em> format tag not yet ported from 2.6
-
 	<tag>external_refresh_check</tag>
 	<p>Not yet ported from 2.7
 
-	<tag>http_port</tag>
-	<p><em>act-as-origin</em> not yet ported from 2.7
-
 	<tag>ignore_ims_on_miss</tag>
 	<p>Not yet ported from 2.7
 
@@ -161,3 +161,8 @@ rfc6585.txt
 	429 (Too Many Requests),
 	431 (Request Header Fields Too Large),
 	511 (Network Authentication Required)
+
+rfc6762.txt
+	Multicast DNS
+	Details the DNS requirements on the Squid internal DNS client
+	for resolving URLs in the .local domain.
@@ -24,6 +24,7 @@ ms	ms-my
 nl	nl-nl
 pl	pl-pl
 pt	pt-pt
+pt-br	pt-bz
 ro	ro-ro ro-md
 ru	ru-ru
 sk	sk-sk
@@ -1141,7 +1141,7 @@ msgid ""
 "revalidation prohibited by the <q>only-if-cached</q> directive."
 msgstr ""
 "   <q>only-if-cached</q>   : "
-"    <em></em   <q>only-if-cached</"
+"    <em></em>   <q>only-if-cached</"
 "q>    :"
 
 #: templates/ERR_AGENT_CONFIGURE+html.body.div.blockquote.p:21
@@ -8,15 +8,17 @@ DIST_SUBDIRS = \
 	negotiate_auth \
 	ntlm_auth \
 	url_rewrite \
-	ssl
+	ssl \
+	storeid_rewrite
 
 SUBDIRS = \
 	basic_auth \
 	digest_auth \
 	external_acl \
 	log_daemon \
 	negotiate_auth \
-	url_rewrite
+	url_rewrite \
+	storeid_rewrite
 
 if ENABLE_AUTH_NTLM
 SUBDIRS += ntlm_auth
@@ -7,7 +7,7 @@ EXTRA_DIST= \
 	basic_db_auth.8 \
 	passwd.sql \
 	basic_db_auth.pl.in \
-	config.test
+	required.m4
 
 basic_db_auth.8: basic_db_auth
 	pod2man basic_db_auth basic_db_auth.8
@@ -1,7 +0,0 @@
-#!/bin/sh
-
-## Test: do we have perl to build the helper scripts?
-## Test: do we have pod2man to build the manual?
-perl --version >/dev/null && echo | pod2man >/dev/null
-
-exit $?
@@ -0,0 +1,3 @@
+if test "x$PERL" != "x" -a "x$POD2MAN" != "x"; then
+  BUILD_HELPER="DB"
+fi
@@ -2,7 +2,7 @@ include $(top_srcdir)/src/Common.am
 
 libexec_PROGRAMS 	= basic_ldap_auth
 man_MANS 		= basic_ldap_auth.8
-EXTRA_DIST		= basic_ldap_auth.8 config.test
+EXTRA_DIST		= basic_ldap_auth.8 required.m4
 basic_ldap_auth_SOURCES	= basic_ldap_auth.cc
 
 LDADD = \
@@ -1,8 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/ldap.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/winldap.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([ldap.h winldap.h],[BUILD_HELPER="LDAP"])
@@ -1,7 +1,7 @@
 include $(top_srcdir)/src/Common.am
 
 libexec_SCRIPTS	= basic_msnt_multi_domain_auth
-EXTRA_DIST = basic_msnt_multi_domain_auth.pl.in README.txt config.test
+EXTRA_DIST = basic_msnt_multi_domain_auth.pl.in README.txt required.m4
 CLEANFILES += basic_msnt_multi_domain_auth
 
 basic_msnt_multi_domain_auth: basic_msnt_multi_domain_auth.pl.in
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="MSNT-multi-domain"
@@ -19,7 +19,7 @@ EXTRA_DIST = \
 	msntauth.conf.default \
 	msntauth-v2.0.lsm \
 	README.html \
-	config.test
+	required.m4
 
 sysconf_DATA = \
 	msntauth.conf.default
@@ -1,14 +0,0 @@
-#!/bin/sh
-#
-# Don't build this helper on Windows
-#
-if test "$1" = "mingw"; then
-        exit 1
-fi
-if [ -f /usr/include/w32api/windows.h ]; then
-	exit 1
-fi
-if [ -f /usr/include/windows.h ]; then
-	exit 1
-fi
-exit 0
@@ -0,0 +1,5 @@
+#
+# DONT build this helper on Windows
+#
+BUILD_HELPER="MSNT"
+AC_CHECK_HEADERS([w32api/windows.h windows.h],[BUILD_HELPER=""])
@@ -16,3 +16,5 @@ DIST_SUBDIRS = \
 	SSPI
 
 SUBDIRS	= $(BASIC_AUTH_HELPERS)
+
+EXTRA_DIST = modules.m4
@@ -3,7 +3,7 @@ include $(top_srcdir)/src/Common.am
 libexec_PROGRAMS	= basic_ncsa_auth
 basic_ncsa_auth_SOURCES	= basic_ncsa_auth.cc crypt_md5.cc crypt_md5.h
 man_MANS 		= basic_ncsa_auth.8
-EXTRA_DIST		= basic_ncsa_auth.8 config.test
+EXTRA_DIST		= basic_ncsa_auth.8 required.m4
 LDADD = \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
@@ -20,10 +20,18 @@ This password file can be manipulated using
 .PP
 This authenticator accepts:
 .BR
+* Blowfish - for passwords 72 characters or less in length
+.BR
+* SHA256 - with salting and magic strings
+.BR
+* SHA512 - with salting and magic strings
+.BR
 * MD5 - with optional salt and magic strings
 .BR
 * DES - for passwords 8 characters or less in length
 .
+NOTE: Blowfish and SHA algorithms require system-specific support.
+.
 .SH OPTIONS
 The only parameter is the password file.
 It must have permissions to be read by the user that Squid is running as.
@@ -146,21 +146,39 @@ main(int argc, char **argv)
         u = (user_data *) hash_lookup(hash, user);
         if (u == NULL) {
             SEND_ERR("No such user");
+            continue;
+        }
+        char *crypted = NULL;
 #if HAVE_CRYPT
-        } else if (strlen(passwd) <= 8 && strcmp(u->passwd, (char *) crypt(passwd, u->passwd)) == 0) {
-            // Bug 3107: crypt() DES functionality silently truncates long passwords.
+        size_t passwordLength = strlen(passwd);
+        // Bug 3831: given algorithms more secure than DES crypt() does not truncate, so we can ignore the bug 3107 length checks below
+        // '$1$' = MD5, '$2a$' = Blowfish, '$5$' = SHA256 (Linux), '$6$' = SHA256 (BSD) and SHA512
+        if (passwordLength > 1 && u->passwd[0] == '$' &&
+                (crypted = crypt(passwd, u->passwd)) && strcmp(u->passwd, crypted) == 0) {
             SEND_OK("");
-        } else if (strlen(passwd) > 8 && strcmp(u->passwd, (char *) crypt(passwd, u->passwd)) == 0) {
+            continue;
+        }
+        // 'other' prefixes indicate DES algorithm.
+        if (passwordLength <= 8 && (crypted = crypt(passwd, u->passwd)) && (strcmp(u->passwd, crypted) == 0)) {
+            SEND_OK("");
+            continue;
+        }
+        if (passwordLength > 8 && (crypted = crypt(passwd, u->passwd)) && (strcmp(u->passwd, crypted) == 0)) {
             // Bug 3107: crypt() DES functionality silently truncates long passwords.
             SEND_ERR("Password too long. Only 8 characters accepted.");
+            continue;
+        }
+
 #endif
-        } else if (strcmp(u->passwd, (char *) crypt_md5(passwd, u->passwd)) == 0) {
+        if ( (crypted = crypt_md5(passwd, u->passwd)) && strcmp(u->passwd, crypted) == 0) {
             SEND_OK("");
-        } else if (strcmp(u->passwd, (char *) md5sum(passwd)) == 0) {
+            continue;
+        }
+        if ( (crypted = md5sum(passwd)) && strcmp(u->passwd, crypted) == 0) {
             SEND_OK("");
-        } else {
-            SEND_ERR("Wrong password");
+            continue;
         }
+        SEND_ERR("Wrong password");
     }
     if (hash != NULL) {
         hashFreeItems(hash, my_free);
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="NCSA"
@@ -16,4 +16,4 @@ basic_nis_auth_LDADD = \
 	$(CRYPTLIB) \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
@@ -1,5 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/rpcsvc/yp_prot.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([rpcsvc/yp_prot.h],[BUILD_HELPER="NIS"])
@@ -1,7 +1,7 @@
 include $(top_srcdir)/src/Common.am
 
 man_MANS		= basic_pam_auth.8
-EXTRA_DIST		= basic_pam_auth.8 config.test
+EXTRA_DIST		= basic_pam_auth.8 required.m4
 libexec_PROGRAMS	= basic_pam_auth
 basic_pam_auth_SOURCES	= basic_pam_auth.cc
 
@@ -1,5 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/security/pam_appl.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1,4 @@
+AC_CHECK_HEADERS([security/pam_appl.h],[
+  BUILD_HELPER="PAM"
+  CHECK_STRUCT_PAM_CONV
+])
@@ -1,7 +1,7 @@
 include $(top_srcdir)/src/Common.am
 
 libexec_SCRIPTS	= basic_pop3_auth
-EXTRA_DIST = basic_pop3_auth.pl.in config.test
+EXTRA_DIST = basic_pop3_auth.pl.in required.m4
 CLEANFILES += basic_pop3_auth
 
 basic_pop3_auth: basic_pop3_auth.pl.in
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="POP3"
@@ -5,7 +5,7 @@ INCLUDES += -I$(srcdir)
 
 libexec_PROGRAMS 	= basic_radius_auth
 man_MANS 		= basic_radius_auth.8
-EXTRA_DIST		= basic_radius_auth.8 config.test
+EXTRA_DIST		= basic_radius_auth.8 required.m4
 basic_radius_auth_SOURCES = \
 			basic_radius_auth.cc \
 			radius.h \
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="RADIUS"
@@ -13,4 +13,4 @@ EXTRA_DIST = \
 	basic_sasl_auth.8 \
 	basic_sasl_auth.conf \
 	basic_sasl_auth.pam \
-	config.test
+	required.m4
@@ -1,8 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/sasl.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/sasl/sasl.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1,6 @@
+SQUID_CHECK_SASL
+
+# on success, add to the built modules list
+if test "x$squid_cv_check_sasl" = "xyes"; then
+  BUILD_HELPER="SASL"
+fi
@@ -11,4 +11,4 @@ basic_smb_auth_LDADD = \
 		$(COMPAT_LIB) \
 		$(XTRA_LIBS)
 
-EXTRA_DIST = basic_smb_auth.sh COPYING-2.0 config.test
+EXTRA_DIST = basic_smb_auth.sh COPYING-2.0 required.m4
@@ -1,10 +0,0 @@
-#!/bin/sh
-for prefix in /usr/local /opt /opt/samba /usr/local/samba /usr
-do
-    if [ -x ${prefix}/bin/smbclient ]; then
-        exit 0
-    fi
-done
-echo "WARNING: Samba smbclient not found in default location. basic_smb_auth may not work on this machine"
-# allow script install anyway.
-exit 0
@@ -0,0 +1,10 @@
+#
+# The shell script helper require smbclient to be in the environment PATH.
+# We can install anyway, but warn if smbclient not found already
+#
+AC_PATH_PROG(SMBCLIENT, smbclient)
+if test "x$SMBCLIENT" = "x"; then
+  AC_MSG_WARN([Samba smbclient not found in default location. basic_smb_auth may not work on this machine])
+fi
+# allow script install anyway.
+BUILD_HELPER="SMB"
@@ -20,4 +20,4 @@ basic_sspi_auth_LDADD = \
 	$(XTRA_LIBS)
 
 man_MANS = basic_sspi_auth.8
-EXTRA_DIST = basic_sspi_auth.8 config.test
+EXTRA_DIST = basic_sspi_auth.8 required.m4
@@ -1,14 +0,0 @@
-#!/bin/sh
-#
-# Only build this helper on Windows
-#
-if test "$1" = "mingw"; then
-	exit 0
-fi
-if [ -f /usr/include/w32api/windows.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/windows.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1,4 @@
+#
+# Only build this helper on Windows
+#
+AC_CHECK_HEADERS([w32api/windows.h windows.h],[BUILD_HELPER="SSPI"])
@@ -5,4 +5,4 @@ basic_fake_auth_SOURCES = fake.cc
 
 LDADD = $(COMPAT_LIB)
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="fake"
@@ -10,4 +10,4 @@ basic_getpwnam_auth_LDADD = \
 
 man_MANS = basic_getpwnam_auth.8
 
-EXTRA_DIST = basic_getpwnam_auth.8 config.test
+EXTRA_DIST = basic_getpwnam_auth.8 required.m4
@@ -1,5 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/pwd.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([pwd.h],[BUILD_HELPER="getpwnam"])
@@ -0,0 +1,95 @@
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_auth_basic list containing double entries.
+
+#not specified. Inherit global
+if test "x$enable_auth_basic" = "x"; then
+    enable_auth_basic=$enable_auth
+fi
+#conflicts with global
+if test "x$enable_auth_basic" != "xno" -a "x$enable_auth" = "xno" ; then
+    AC_MSG_ERROR([Basic auth requested but auth disabled])
+fi
+#define list of modules to build
+if test "x$enable_auth_basic" = "xyes" ; then
+    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/basic_auth],[enable_auth_basic])
+fi
+#handle the "none" special case
+if test "x$enable_auth_basic" = "xnone" ; then
+    enable_auth_basic=""
+fi
+
+BASIC_AUTH_HELPERS=""
+#enable_auth_basic contains either "no" or the list of modules to be built
+enable_auth_basic="`echo $enable_auth_basic| sed -e 's/,/ /g;s/  */ /g'`"
+if test "x$enable_auth_basic" != "xno" ; then
+    AUTH_MODULES="$AUTH_MODULES basic"
+    AC_DEFINE([HAVE_AUTH_MODULE_BASIC],1,[Basic auth module is built])
+    for helper in $enable_auth_basic; do
+      dir="$srcdir/helpers/basic_auth/$helper"
+
+      # modules converted to autoconf macros already
+      # NP: we only need this list because m4_include() does not accept variables
+      if test "x$helper" = "xDB" ; then
+        m4_include([helpers/basic_auth/DB/required.m4])
+
+      elif test "x$helper" = "xLDAP" ; then
+        m4_include([helpers/basic_auth/LDAP/required.m4])
+
+      elif test "x$helper" = "xMSNT-multi-domain" ; then
+        m4_include([helpers/basic_auth/MSNT-multi-domain/required.m4])
+
+      elif test "x$helper" = "xMSNT" ; then
+        m4_include([helpers/basic_auth/MSNT/required.m4])
+
+      elif test "x$helper" = "xNCSA" ; then
+        m4_include([helpers/basic_auth/NCSA/required.m4])
+
+      elif test "x$helper" = "xNIS" ; then
+        m4_include([helpers/basic_auth/NIS/required.m4])
+
+      elif test "x$helper" = "xPAM" ; then
+        m4_include([helpers/basic_auth/PAM/required.m4])
+
+      elif test "x$helper" = "xPOP3" ; then
+        m4_include([helpers/basic_auth/POP3/required.m4])
+
+      elif test "x$helper" = "xRADIUS" ; then
+        m4_include([helpers/basic_auth/RADIUS/required.m4])
+
+      elif test "x$helper" = "xSASL" ; then
+        m4_include([helpers/basic_auth/SASL/required.m4])
+
+      elif test "x$helper" = "xSMB" ; then
+        m4_include([helpers/basic_auth/SMB/required.m4])
+
+      elif test "x$helper" = "xSSPI" ; then
+        m4_include([helpers/basic_auth/SSPI/required.m4])
+
+      elif test "x$helper" = "xfake" ; then
+        m4_include([helpers/basic_auth/fake/required.m4])
+
+      elif test "x$helper" = "xgetpwnam" ; then
+        m4_include([helpers/basic_auth/getpwnam/required.m4])
+
+      # modules not yet converted to autoconf macros (or third party drop-in's)
+      elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+        BUILD_HELPER="$helper"
+      fi
+
+      if test -d "$srcdir/helpers/basic_auth/$helper"; then
+        if test "$BUILD_HELPER" != "$helper"; then
+          AC_MSG_NOTICE([Basic auth helper $helper ... found but cannot be built])
+        else
+          BASIC_AUTH_HELPERS="$BASIC_AUTH_HELPERS $BUILD_HELPER"
+        fi
+      else
+        AC_MSG_ERROR([Basic auth helper $helper ... not found])
+      fi
+    done
+fi
+
+AC_MSG_NOTICE([Basic auth helpers to be built: $BASIC_AUTH_HELPERS])
+AM_CONDITIONAL(ENABLE_AUTH_BASIC, test "x$enable_auth_basic" != "xno")
+AC_SUBST(BASIC_AUTH_HELPERS)
@@ -18,4 +18,4 @@ digest_ldap_auth_LDADD = \
 	$(SSLLIB) \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
@@ -1,8 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/ldap.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/winldap.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([ldap.h winldap.h],[BUILD_HELPER="LDAP"])
@@ -5,3 +5,5 @@ DIST_SUBDIRS= \
 	LDAP
 
 SUBDIRS= $(DIGEST_AUTH_HELPERS)
+
+EXTRA_DIST = modules.m4
@@ -21,4 +21,4 @@ digest_edirectory_auth_LDADD = \
 	$(SSLLIB) \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
@@ -1,8 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/ldap.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/winldap.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([ldap.h winldap.h],[BUILD_HELPER="LDAP"])
@@ -18,4 +18,4 @@ LDADD = \
 	$(SSLLIB) \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = digest_file_auth.8 config.test
+EXTRA_DIST = digest_file_auth.8 required.m4
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="file"
@@ -0,0 +1,60 @@
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_auth_digest list containing double entries.
+
+#not specified. Inherit global
+if test "x$enable_auth_digest" = "x"; then
+    enable_auth_digest=$enable_auth
+fi
+#conflicts with global
+if test "x$enable_auth_digest" != "xno" -a "x$enable_auth" = "xno" ; then
+    AC_MSG_ERROR([Digest auth requested but auth disabled])
+fi
+#define list of modules to build
+if test "x$enable_auth_digest" = "xyes" ; then
+    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/digest_auth],[enable_auth_digest])
+fi
+#handle the "none" special case
+if test "x$enable_auth_digest" = "xnone" ; then
+    enable_auth_digest=""
+fi
+
+DIGEST_AUTH_HELPERS=""
+enable_auth_digest="`echo $enable_auth_digest| sed -e 's/,/ /g;s/  */ /g'`"
+if test "x$enable_auth_digest" != "xno" ; then
+    AUTH_MODULES="$AUTH_MODULES digest"
+    AC_DEFINE([HAVE_AUTH_MODULE_DIGEST],1,[Digest auth module is built])
+    for helper in $enable_auth_digest; do
+      dir="$srcdir/helpers/digest_auth/$helper"
+
+      # modules converted to autoconf macros already
+      # NP: we only need this list because m4_include() does not accept variables
+      if test "x$helper" = "xLDAP" ; then
+        m4_include([helpers/digest_auth/LDAP/required.m4])
+
+      elif test "x$helper" = "xeDirectory" ; then
+        m4_include([helpers/digest_auth/eDirectory/required.m4])
+
+      elif test "x$helper" = "xfile" ; then
+        m4_include([helpers/digest_auth/file/required.m4])
+
+      # modules not yet converted to autoconf macros (or third party drop-in's)
+      elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+        BUILD_HELPER="$helper"
+      fi
+
+      if test -d "$srcdir/helpers/digest_auth/$helper"; then
+        if test "$BUILD_HELPER" != "$helper"; then
+          AC_MSG_NOTICE([Digest auth helper $helper ... found but cannot be built])
+        else
+          DIGEST_AUTH_HELPERS="$DIGEST_AUTH_HELPERS $BUILD_HELPER"
+        fi
+      else
+        AC_MSG_ERROR([Digest auth helper $helper ... not found])
+      fi
+    done
+fi
+AC_MSG_NOTICE([Digest auth helpers to be built: $DIGEST_AUTH_HELPERS])
+AM_CONDITIONAL(ENABLE_AUTH_DIGEST, test "x$enable_auth_digest" != "xno")
+AC_SUBST(DIGEST_AUTH_HELPERS)
@@ -8,6 +8,7 @@ man_MANS = ext_ad_group_acl.8
 # Currently activeds and adsiid libraries are not available on MinGW or Cygwin,
 # so the following library list is just a placeholder for future MinGW/Cygwin releases.
 # This helper can be compiled only using Microsoft Visual Studio.
+# TODO: test for these libraries in required.m4
 #
 LDADD = \
 	$(COMPAT_LIB) \
@@ -20,4 +21,4 @@ LDADD = \
 	-ladsiid \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = config.test ext_ad_group_acl.8
+EXTRA_DIST = required.m4 ext_ad_group_acl.8
@@ -1,12 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/w32api/dsrole.h ]; then
-  if grep -q DsRoleGetPrimaryDomainInformation /usr/include/w32api/dsrole.h; then
-	  exit 0
-	fi
-fi
-if [ -f /usr/include/dsrole.h ]; then
-  if grep -q DsRoleGetPrimaryDomainInformation /usr/include/dsrole.h; then
-	  exit 0
-  fi
-fi
-exit 1
@@ -0,0 +1,8 @@
+for hdr in w32api/dsrole.h dsrole.h; do
+  AC_COMPILE_IFELSE([
+    AC_LANG_PROGRAM([[#include <$hdr>]], [[
+      PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pDSRoleInfo;
+      DWORD ret = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic, (PBYTE *) & pDSRoleInfo);
+    ]])
+  ],[BUILD_HELPER="AD_group"],[])
+done
@@ -4,7 +4,7 @@ libexec_PROGRAMS 		= ext_ldap_group_acl
 ext_ldap_group_acl_SOURCES	= ext_ldap_group_acl.cc
 
 man_MANS 			= ext_ldap_group_acl.8
-EXTRA_DIST			= ext_ldap_group_acl.8 config.test
+EXTRA_DIST			= ext_ldap_group_acl.8 required.m4
 
 LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
@@ -1,8 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/ldap.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/winldap.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([ldap.h winldap.h],[BUILD_HELPER="LDAP_group"])
@@ -12,4 +12,4 @@ LDADD = \
 
 man_MANS = ext_lm_group_acl.8
 
-EXTRA_DIST = config.test ext_lm_group_acl.8
+EXTRA_DIST = required.m4 ext_lm_group_acl.8
@@ -1,14 +0,0 @@
-#!/bin/sh
-#
-# Only build this helper on Windows
-#
-if test "$1" = "mingw"; then
-        exit 0
-fi
-if [ -f /usr/include/w32api/windows.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/windows.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1,4 @@
+#
+# Only build this helper on Windows
+#
+AC_CHECK_HEADERS([w32api/windows.h windows.h],[BUILD_HELPER="LM_group"])
@@ -6,7 +6,7 @@ man_MANS = ext_sql_session_acl.8
 EXTRA_DIST= \
 	ext_sql_session_acl.8 \
 	ext_sql_session_acl.pl.in \
-	config.test
+	required.m4
 
 ext_sql_session_acl.8: ext_sql_session_acl
 	pod2man ext_sql_session_acl ext_sql_session_acl.8
@@ -1,7 +0,0 @@
-#!/bin/sh
-
-## Test: do we have perl to build the helper scripts?
-## Test: do we have pod2man to build the manual?
-perl --version >/dev/null && echo | pod2man >/dev/null
-
-exit $?
@@ -0,0 +1,3 @@
+if test "x$PERL" != "x" -a "x$POD2MAN" != "x"; then
+  BUILD_HELPER="SQL_session"
+fi
@@ -13,4 +13,4 @@ ext_edirectory_userip_acl_LDADD = \
 
 man_MANS = ext_edirectory_userip_acl.8
 
-EXTRA_DIST = config.test ext_edirectory_userip_acl.8
+EXTRA_DIST = required.m4 ext_edirectory_userip_acl.8
@@ -1,9 +0,0 @@
-#!/bin/sh
-
-if [ -f /usr/include/ldap.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/winldap.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([ldap.h winldap.h],[BUILD_HELPER="eDirectory_userip"])
@@ -8,7 +8,7 @@ EXTRA_DIST = \
 	example.conf \
 	example-deny_all_but.conf \
 	ext_file_userip_acl.8 \
-	config.test
+	required.m4
 
 LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
@@ -1,5 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/sys/socket.h ]; then
-    exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([sys/socket.h],[BUILD_HELPER="file_userip"])
@@ -1,6 +1,6 @@
 include $(top_srcdir)/src/Common.am
 
-EXTRA_DIST = README config.test cert_tool ext_kerberos_ldap_group_acl.8
+EXTRA_DIST = README required.m4 cert_tool ext_kerberos_ldap_group_acl.8
 SUBDIRS = 
 
 AM_CPPFLAGS = $(INCLUDES) -I$(srcdir)
@@ -1,23 +0,0 @@
-#!/bin/sh
-# Don't build without gssapi.h
-if [ -f /usr/include/ldap.h -o -f /usr/local/include/ldap.h ]; then
-	# Won't link without SASL as well
-	if [ -f /usr/include/sasl.h -o -f /usr/include/sasl/sasl.h -o -f /usr/local/include/sasl.h -o -f /usr/local/include/sasl/sasl.h ]; then
-		if [ -f /usr/lib/libsasl.a -o -f /usr/lib/libsasl2.a ]; then
-			exit 0
-		fi
-		if [ -f /usr/lib/libsasl.la -o -f /usr/lib/libsasl2.la ]; then
-			exit 0
-		fi
-		if [ -f /usr/lib/libsasl.so -o -f /usr/lib/libsasl2.so ]; then
-			exit 0
-		fi
-		if [ -f /usr/lib64/libsasl.so -o -f /usr/lib64/libsasl2.so ]; then
-			exit 0
-		fi
-		if [ -f  /usr/local/lib/libsasl.so -o -f  /usr/local/lib/libsasl2.so ]; then
-			exit 0
-		fi
-	fi
-fi
-exit 1
@@ -425,6 +425,7 @@ main(int argc, char *const argv[])
             dp = xstrdup(rfc1738_escape(domain));
         if (!domain && margs.ddomain) {
             domain = xstrdup(margs.ddomain);
+            dp = xstrdup(rfc1738_escape(domain));
             if (debug_enabled)
                 debug((char *) "%s| %s: INFO: Got User: %s set default domain: %s\n", LogTime(), PROGRAM, up, dp);
             else
@@ -0,0 +1,2 @@
+AC_CHECK_HEADERS([ldap.h],[BUILD_HELPER="kerberos_ldap_group"])
+SQUID_CHECK_SASL
@@ -0,0 +1,71 @@
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_external_acl_helpers list containing double entries.
+
+#define list of modules to build
+if test "x${enable_external_acl_helpers:=yes}" = "xyes" ;then
+  SQUID_LOOK_FOR_MODULES([$srcdir/helpers/external_acl],[enable_external_acl_helpers])
+fi
+if test "x$enable_external_acl_helpers" = "xnone" ; then
+  enable_external_acl_helpers=""
+fi
+EXTERNAL_ACL_HELPERS=""
+enable_external_acl_helpers="`echo $enable_external_acl_helpers| sed -e 's/,/ /g;s/  */ /g'`"
+if test "x$enable_external_acl_helpers" != "xno" ; then
+  for helper in $enable_external_acl_helpers ; do
+    dir="$srcdir/helpers/external_acl/$helper"
+
+      # modules converted to autoconf macros already
+      # NP: we only need this list because m4_include() does not accept variables
+      if test "x$helper" = "xAD_group" ; then
+        m4_include([helpers/external_acl/AD_group/required.m4])
+
+      elif test "x$helper" = "xLDAP_group" ; then
+        m4_include([helpers/external_acl/LDAP_group/required.m4])
+
+      elif test "x$helper" = "xLM_group" ; then
+        m4_include([helpers/external_acl/LM_group/required.m4])
+
+      elif test "x$helper" = "xSQL_session" ; then
+        m4_include([helpers/external_acl/SQL_session/required.m4])
+
+      elif test "x$helper" = "xeDirectory_userip" ; then
+        m4_include([helpers/external_acl/eDirectory_userip/required.m4])
+
+      elif test "x$helper" = "xfile_userip" ; then
+        m4_include([helpers/external_acl/file_userip/required.m4])
+
+      elif test "x$helper" = "xkerberos_ldap_group" ; then
+        m4_include([helpers/external_acl/kerberos_ldap_group/required.m4])
+
+      elif test "x$helper" = "xsession" ; then
+        m4_include([helpers/external_acl/session/required.m4])
+
+      elif test "x$helper" = "xtime_quota" ; then
+        m4_include([helpers/external_acl/time_quota/required.m4])
+
+      elif test "x$helper" = "xunix_group" ; then
+        m4_include([helpers/external_acl/unix_group/required.m4])
+
+      elif test "x$helper" = "xwbinfo_group" ; then
+        m4_include([helpers/external_acl/wbinfo_group/required.m4])
+
+      # modules not yet converted to autoconf macros (or third party drop-in's)
+      elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+        BUILD_HELPER="$helper"
+      fi
+
+      if test -d "$srcdir/helpers/external_acl/$helper"; then
+        if test "$BUILD_HELPER" != "$helper"; then
+          AC_MSG_NOTICE([external acl helper $helper ... found but cannot be built])
+        else
+          EXTERNAL_ACL_HELPERS="$EXTERNAL_ACL_HELPERS $BUILD_HELPER"
+        fi
+      else
+        AC_MSG_ERROR([external acl helper $helper ... not found])
+      fi
+  done
+fi
+AC_MSG_NOTICE([External acl helpers to be built: $EXTERNAL_ACL_HELPERS])
+AC_SUBST(EXTERNAL_ACL_HELPERS)
@@ -2,7 +2,7 @@ include $(top_srcdir)/src/Common.am
 
 libexec_PROGRAMS 		= ext_session_acl
 man_MANS 			= ext_session_acl.8
-EXTRA_DIST			= ext_session_acl.8 config.test
+EXTRA_DIST			= ext_session_acl.8 required.m4
 ext_session_acl_SOURCES		= ext_session_acl.cc
 
 LDADD = \
@@ -1,6 +0,0 @@
-#!/bin/sh
-
-if [ -f /usr/include/db.h ] && grep db_env_create /usr/include/db.h; then
-    exit 0
-fi
-exit 1
@@ -68,7 +68,7 @@ Active mode. In this mode sessions are started by evaluating an
 acl with the argument
 .B LOGIN
 , or terminated by the argument
-.B LOGOUT .
+.B LOGOUT \.
 Without this flag the helper automatically starts the session after
 the first request.
 .SH CONFIGURATION
@@ -79,7 +79,7 @@ helper is a concurrent helper; therefore, the concurrency= option
 .B must
 be specified in the configuration.
 .PP
-Configuration example using the default automatic mode
+Passive session configuration example using the default automatic mode
 .if !'po4a'hide' .RS
 .if !'po4a'hide' .B external_acl_type session ttl=300 negative_ttl=0 children=1 concurrency=200 %LOGIN /usr/local/squid/libexec/ext_session_acl
 .if !'po4a'hide' .br
@@ -0,0 +1 @@
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <db.h>]],[[DB_ENV *db_env = NULL; db_env_create(&db_env, 0);]])],[BUILD_HELPER="session"],[])
@@ -2,7 +2,7 @@ include $(top_srcdir)/src/Common.am
 
 libexec_PROGRAMS 		= ext_time_quota_acl
 man_MANS 			= ext_time_quota_acl.8
-EXTRA_DIST			= ext_time_quota_acl.8 config.test
+EXTRA_DIST			= ext_time_quota_acl.8 required.m4
 ext_time_quota_acl_SOURCES	= ext_time_quota_acl.cc
 
 DEFS += -DDEFAULT_QUOTA_DB=\"$(localstatedir)/ext_time_quota.db\" 
@@ -1,10 +0,0 @@
-#!/bin/sh
-
-# Actual intended test
-if [ -f /usr/include/db_185.h ]; then
-    exit 0
-fi
-if [ -f /usr/include/db.h ] && grep dbopen /usr/include/db.h; then
-    exit 0
-fi
-exit 1
@@ -0,0 +1,2 @@
+AC_CHECK_HEADERS([db_185.h],[BUILD_HELPER="time_quota"])
+AC_EGREP_HEADER([dbopen],[/usr/include/db.h],[BUILD_HELPER="time_quota"])
@@ -2,7 +2,7 @@ include $(top_srcdir)/src/Common.am
 
 libexec_PROGRAMS 		= ext_unix_group_acl
 man_MANS 			= ext_unix_group_acl.8
-EXTRA_DIST			= ext_unix_group_acl.8 config.test
+EXTRA_DIST			= ext_unix_group_acl.8 required.m4
 ext_unix_group_acl_SOURCES	= check_group.cc
 
 LDADD = \
@@ -1,5 +0,0 @@
-#!/bin/sh
-if [ -f /usr/include/pwd.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1 @@
+AC_CHECK_HEADERS([pwd.h],[BUILD_HELPER="unix_group"])
@@ -1,7 +1,7 @@
 include $(top_srcdir)/src/Common.am
 
 libexec_SCRIPTS = ext_wbinfo_group_acl
-EXTRA_DIST	= ext_wbinfo_group_acl.pl.in config.test
+EXTRA_DIST	= ext_wbinfo_group_acl.pl.in required.m4
 
 ext_wbinfo_group_acl: ext_wbinfo_group_acl.pl.in
 	$(subst_perlshell)
@@ -1,18 +0,0 @@
-#!/bin/sh
-samba_found="no"
-for sambaprefix in /usr/local /opt /opt/samba /usr/local/samba /usr
-do
-    if [ -x $sambaprefix/bin/wbinfo ]; then
-      samba_found="yes"
-    fi
-done
-if test "$samba_found" = "no"; then
-    echo "WARNING: Samba wbinfo not found in default location. ext_wbinfo_group_acl may not work on this machine"
-fi
-for perlprefix in /usr /usr/local /opt /opt/perl
-do
-    if [ -x $perlprefix/bin/perl ]; then
-        exit 0
-    fi
-done
-exit 1
@@ -0,0 +1,13 @@
+#
+# The shell script helper requires wbinfo to be in the environment PATH.
+# We can install anyway, but warn if the tool is missing
+#
+AC_PATH_PROG(WBINFO, wbinfo)
+if test "x$WBINFO" = "x"; then
+  AC_MSG_WARN([Samba wbinfo not found in default location. ext_wbinfo_group_acl may not work on this machine])
+fi
+
+# allow script install anyway when perl is present
+if test "x$PERL" != "x" -a "x$POD2MAN" != "x"; then
+  BUILD_HELPER="wbinfo_group"
+fi
@@ -4,7 +4,7 @@ libexec_SCRIPTS	= log_db_daemon
 CLEANFILES += log_db_daemon log_db_daemon.8
 man_MANS = log_db_daemon.8
 EXTRA_DIST= \
-	config.test \
+	required.m4 \
 	doc/views.sql \
 	doc/date_day_column.sql \
 	log_db_daemon.8 \
@@ -1,7 +0,0 @@
-#!/bin/sh
-
-## Test: do we have perl to build the helper scripts?
-## Test: do we have pod2man to build the manual?
-perl --version >/dev/null && echo | pod2man >/dev/null
-
-exit $?
@@ -41,6 +41,8 @@ Default "DBI:mysql:database=squid"
 
 Write debug messages to Squid stderr or cache.log
 
+=back
+
 =cut
 
 # the first argument to this script is the log file path describing the DSN
@@ -196,6 +198,8 @@ $dbh->disconnect();
 
 __END__
 
+=pod
+
 =head1 DESCRIPTION
 
 This module exploits the new logfile daemon support available in squid 2.7 and 3.2 to store access log entries in a MySQL database.
@@ -0,0 +1,3 @@
+if test "x$PERL" != "x" -a "x$POD2MAN" != "x"; then
+  BUILD_HELPER="DB"
+fi
@@ -4,3 +4,4 @@ DIST_SUBDIRS = \
 	file
 
 SUBDIRS	= $(LOG_DAEMON_HELPERS)
+EXTRA_DIST = modules.m4
@@ -5,4 +5,4 @@ log_file_daemon_SOURCES = log_file_daemon.cc
 log_file_daemon_LDADD = \
 	-L$(top_builddir)/lib $(COMPAT_LIB) \
 	$(XTRA_LIBS)
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="file"
@@ -0,0 +1,46 @@
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_log_daemon_helpers list containing double entries.
+
+#define list of modules to build
+if test "x${enable_log_daemon_helpers:=yes}" = "xyes" ;then
+  enable_log_daemon_helpers=""
+  SQUID_LOOK_FOR_MODULES([$srcdir/helpers/log_daemon],[enable_log_daemon_helpers])
+fi
+if test "x$enable_log_daemon_helpers" = "xnone" ; then
+  enable_log_daemon_helpers=""
+fi
+
+LOG_DAEMON_HELPERS=""
+enable_log_daemon_helpers="`echo $enable_log_daemon_helpers| sed -e 's/,/ /g;s/  */ /g'`"
+if test "x$enable_log_daemon_helpers" != "xno"; then
+  for helper in $enable_log_daemon_helpers ; do
+    dir="$srcdir/helpers/log_daemon/$helper"
+
+    # modules converted to autoconf macros already
+    # NP: we only need this list because m4_include() does not accept variables
+    if test "x$helper" = "xDB" ; then
+      m4_include([helpers/log_daemon/DB/required.m4])
+
+    elif test "x$helper" = "xfile" ; then
+      m4_include([helpers/log_daemon/file/required.m4])
+
+    # modules not yet converted to autoconf macros (or third party drop-in's)
+    elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+      BUILD_HELPER="$helper"
+    fi
+
+    if test -d "$srcdir/helpers/log_daemon/$helper"; then
+      if test "$BUILD_HELPER" != "$helper"; then
+        AC_MSG_NOTICE([Log daemon helper $helper ... found but cannot be built])
+      else
+       LOG_DAEMON_HELPERS="$LOG_DAEMON_HELPERS $BUILD_HELPER"
+      fi
+    else
+      AC_MSG_ERROR([Log daemon helper $helper ... not found])
+    fi
+  done
+fi
+AC_MSG_NOTICE([Log daemon helpers to be built: $LOG_DAEMON_HELPERS])
+AC_SUBST(LOG_DAEMON_HELPERS)
@@ -10,4 +10,4 @@ LDADD	= \
 	-ladvapi32 \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = readme.txt config.test
+EXTRA_DIST = readme.txt required.m4
@@ -1,14 +0,0 @@
-#!/bin/sh
-#
-# Only build this helper on Windows
-#
-if test "$1" = "mingw"; then
-        exit 0
-fi
-if [ -f /usr/include/w32api/windows.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/windows.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1,4 @@
+#
+# Only build this helper on Windows
+#
+AC_CHECK_HEADERS([w32api/windows.h windows.h],[BUILD_HELPER="SSPI"])
@@ -1,6 +1,6 @@
 include $(top_srcdir)/src/Common.am
 
-EXTRA_DIST = README COPYING config.test negotiate_kerberos_auth.8
+EXTRA_DIST = README COPYING required.m4 negotiate_kerberos_auth.8
 SUBDIRS = 
 
 libexec_PROGRAMS = negotiate_kerberos_auth negotiate_kerberos_auth_test
@@ -1,6 +0,0 @@
-#!/bin/sh
-# Don't build without gssapi.h
-if test -f /usr/include/gssapi/gssapi.h || test -f  /usr/include/gssapi.h || test -f /usr/include/kerberosV/gssapi.h ; then
-       exit 0
-fi
-exit 1
@@ -0,0 +1,2 @@
+# FIXME: use other kerberos library checks from main configure.ac
+AC_CHECK_HEADERS([gssapi/gssapi.h gssapi.h kerberosV/gssapi.h],[BUILD_HELPER="kerberos"])
@@ -0,0 +1,61 @@
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_auth_negotiate list containing double entries.
+
+#not specified. Inherit global
+if test "x$enable_auth_negotiate" = "x"; then
+    enable_auth_negotiate=$enable_auth
+fi
+#conflicts with global
+if test "x$enable_auth_negotiate" != "xno" -a "x$enable_auth" = "xno" ; then
+    AC_MSG_ERROR([Negotiate auth requested but auth disabled])
+fi
+#define list of modules to build
+if test "x$enable_auth_negotiate" = "xyes" ; then
+    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/negotiate_auth],[enable_auth_negotiate])
+fi
+#handle the "none" special case
+if test "x$enable_auth_negotiate" = "xnone" ; then
+    enable_auth_negotiate=""
+fi
+
+NEGOTIATE_AUTH_HELPERS=""
+enable_auth_negotiate="`echo $enable_auth_negotiate| sed -e 's/,/ /g;s/  */ /g'`"
+if test "x$enable_auth_negotiate" != "xno" ; then
+    AUTH_MODULES="$AUTH_MODULES negotiate"
+    AC_DEFINE([HAVE_AUTH_MODULE_NEGOTIATE],1,[Negotiate auth module is built])
+    for helper in $enable_auth_negotiate; do
+      dir="$srcdir/helpers/negotiate_auth/$helper"
+
+      # modules converted to autoconf macros already
+      # NP: we only need this list because m4_include() does not accept variables
+      if test "x$helper" = "xSSPI" ; then
+        m4_include([helpers/negotiate_auth/SSPI/required.m4])
+
+      elif test "x$helper" = "xkerberos" ; then
+        m4_include([helpers/negotiate_auth/kerberos/required.m4])
+
+      elif test "x$helper" = "xwrapper" ; then
+        m4_include([helpers/negotiate_auth/wrapper/required.m4])
+
+      # modules not yet converted to autoconf macros (or third party drop-in's)
+      elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+        BUILD_HELPER="$helper"
+      fi
+
+      if test -d "$srcdir/helpers/negotiate_auth/$helper"; then
+        if test "$BUILD_HELPER" != "$helper"; then
+          AC_MSG_NOTICE([Negotiate auth helper $helper ... found but cannot be built])
+        else
+          NEGOTIATE_AUTH_HELPERS="$NEGOTIATE_AUTH_HELPERS $BUILD_HELPER"
+        fi
+      else
+        AC_MSG_ERROR([Negotiate auth helper $helper ... not found])
+      fi
+    done
+fi
+
+AC_MSG_NOTICE([Negotiate auth helpers to be built: $NEGOTIATE_AUTH_HELPERS])
+AM_CONDITIONAL(ENABLE_AUTH_NEGOTIATE, test "x$enable_auth_negotiate" != "xno")
+AC_SUBST(NEGOTIATE_AUTH_HELPERS)
@@ -1,6 +1,6 @@
 include $(top_srcdir)/src/Common.am
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
 
 libexec_PROGRAMS = negotiate_wrapper_auth
 
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="wrapper"
@@ -1,2 +1,3 @@
 DIST_SUBDIRS	= fake smb_lm SSPI
 SUBDIRS		= $(NTLM_AUTH_HELPERS)
+EXTRA_DIST	= modules.m4
@@ -14,4 +14,4 @@ LDADD = \
 	-ladvapi32 \
 	$(XTRA_LIBS)
 
-EXTRA_DIST = ntlm_sspi_auth.8 config.test
+EXTRA_DIST = ntlm_sspi_auth.8 required.m4
@@ -1,14 +0,0 @@
-#!/bin/sh
-#
-# Only build this helper on Windows
-#
-if test "$1" = "mingw"; then
-        exit 0
-fi
-if [ -f /usr/include/w32api/windows.h ]; then
-	exit 0
-fi
-if [ -f /usr/include/windows.h ]; then
-	exit 0
-fi
-exit 1
@@ -0,0 +1,4 @@
+#
+# Only build this helper on Windows
+#
+AC_CHECK_HEADERS([w32api/windows.h windows.h],[BUILD_HELPER="SSPI"])
@@ -16,5 +16,5 @@ INCLUDES += -I$(top_srcdir)/lib
 ## ntlm_fake_auth.pl: ntlm_fake_auth.pl.in
 ##	$(subst_perlshell)
 
-EXTRA_DIST = config.test \
+EXTRA_DIST = required.m4 \
 	ntlm_fake_auth.pl.in
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="fake"
@@ -0,0 +1,61 @@
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_auth_ntlm list containing double entries.
+
+#not specified. Inherit global
+if test "x$enable_auth_ntlm" = "x"; then
+    enable_auth_ntlm=$enable_auth
+fi
+#conflicts with global
+if test "x$enable_auth_ntlm" != "xno" -a "x$enable_auth" = "xno" ; then
+    AC_MSG_ERROR([NTLM auth requested but auth disabled])
+fi
+#define list of modules to build
+if test "x$enable_auth_ntlm" = "xyes" ; then
+    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/ntlm_auth],[enable_auth_ntlm])
+fi
+#handle the "none" special case
+if test "x$enable_auth_ntlm" = "xnone" ; then
+    enable_auth_ntlm=""
+fi
+
+NTLM_AUTH_HELPERS=""
+#enable_auth_ntlm contains either "no" or the list of modules to be built
+enable_auth_ntlm="`echo $enable_auth_ntlm| sed -e 's/,/ /g;s/  */ /g'`"
+if test "x$enable_auth_ntlm" != "xno" ; then
+    AUTH_MODULES="$AUTH_MODULES ntlm"
+    AC_DEFINE([HAVE_AUTH_MODULE_NTLM],1,[NTLM auth module is built])
+    for helper in $enable_auth_ntlm; do
+      dir="$srcdir/helpers/ntlm_auth/$helper"
+
+      # modules converted to autoconf macros already
+      # NP: we only need this list because m4_include() does not accept variables
+      if test "x$helper" = "xfake" ; then
+        m4_include([helpers/ntlm_auth/fake/required.m4])
+
+      elif test "x$helper" = "xSSPI" ; then
+        m4_include([helpers/ntlm_auth/SSPI/required.m4])
+
+      elif test "x$helper" = "xsmb_lm" ; then
+        m4_include([helpers/ntlm_auth/smb_lm/required.m4])
+
+      # modules not yet converted to autoconf macros (or third party drop-in's)
+      elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+        BUILD_HELPER="$helper"
+      fi
+
+      if test -d "$srcdir/helpers/ntlm_auth/$helper"; then
+        if test "$BUILD_HELPER" != "$helper"; then
+          AC_MSG_NOTICE([NTLM auth helper $helper ... found but cannot be built])
+        else
+          NTLM_AUTH_HELPERS="$NTLM_AUTH_HELPERS $BUILD_HELPER"
+        fi
+      else
+        AC_MSG_ERROR([NTLM auth helper $helper ... not found])
+      fi
+    done
+fi
+AC_MSG_NOTICE([NTLM auth helpers to be built: $NTLM_AUTH_HELPERS])
+AM_CONDITIONAL(ENABLE_AUTH_NTLM, test "x$enable_auth_ntlm" != "xno")
+AC_SUBST(NTLM_AUTH_HELPERS)
@@ -14,4 +14,4 @@ ntlm_smb_lm_auth_LDADD = \
 
 INCLUDES += -I$(top_srcdir)/lib
 
-EXTRA_DIST = config.test
+EXTRA_DIST = required.m4
@@ -1,14 +0,0 @@
-#!/bin/sh
-#
-# Don't build this helper on Windows
-#
-if test "$1" = "mingw"; then
-        exit 1
-fi
-if [ -f /usr/include/w32api/windows.h ]; then
-	exit 1
-fi
-if [ -f /usr/include/windows.h ]; then
-	exit 1
-fi
-exit 0
@@ -0,0 +1,8 @@
+#
+# DONT build this helper on Windows
+#
+# XXX: do we really need the mingw check?
+if test "$squid_host_os" != "mingw"; then
+  BUILD_HELPER="smb_lm"
+  AC_CHECK_HEADERS([w32api/windows.h windows.h],[BUILD_HELPER=""])
+fi
@@ -80,7 +80,7 @@ =head1 COPYRIGHT
     } else {
         my $readlen = length($body);
         my %certs = ();
-        my @errors = ();
+        my %errors = ();
         my @responseErrors = ();
 
         while($readlen < $bodylen) {
@@ -93,12 +93,12 @@ =head1 COPYRIGHT
 
         print(STDERR logPrefix()."GOT ". "Code=".$code." $bodylen \n") if ($debug); #.$body;
         my $hostname;
-        parseRequest($body, \$hostname, \@errors, \%certs);
+        parseRequest($body, \$hostname, \%errors, \%certs);
         print(STDERR logPrefix()."Parse result: \n") if ($debug);
         print(STDERR logPrefix()."\tFOUND host:".$hostname."\n") if ($debug);
         print(STDERR logPrefix()."\tFOUND ERRORS:") if ($debug);
-        foreach my $err (@errors) {
-            print(STDERR logPrefix()."$err ,")  if ($debug);
+        foreach my $err (keys %errors) {
+            print(STDERR logPrefix().$errors{$err}{"name"}."/".$errors{$err}{"cert"}." ,")  if ($debug);
         }
         print(STDERR "\n") if ($debug);
         foreach my $key (keys %certs) {
@@ -110,12 +110,12 @@ =head1 COPYRIGHT
         my $peerCertId = (keys %certs)[0];
 
         # Echo back the errors: fill the responseErrors array  with the errors we read.
-        foreach my $err (@errors) {
+        foreach my $err (keys %errors) {
             $haserror = 1;
             appendError (\@responseErrors, 
-                         $err, #The error name
+                         $errors{$err}{"name"}, #The error name
                          "Checked by Cert Validator", # An error reason
-                         $peerCertId # The cert ID. We are always filling with the peer certificate.
+                         $errors{$err}{"cert"} # The cert ID. We are always filling with the peer certificate.
                 );
         }
 
@@ -175,21 +175,27 @@ sub parseRequest
             my($vallen) = index($request, "\n");
             my $host = substr($request, 5, $vallen - 5);
             $$hostname = $host;
-            $request =~ s/^host=.*\n//;
+            $request =~ s/^host=.*$//m;
         }
-        if ($request =~ /^errors=/) {
-            my($vallen) = index($request, "\n");
-            my $listerrors = substr($request, 7, $vallen - 7);
-            @$errors = split /,/, $listerrors;
-            $request =~ s/^errors=.*\n//;
-        }
-        elsif ($request =~ /^cert_(\d+)=/) {
+        if ($request =~ /^cert_(\d+)=/) {
             my $certId = "cert_".$1;
             my($vallen) = index($request, "-----END CERTIFICATE-----") + length("-----END CERTIFICATE-----");
             my $x509 = Crypt::OpenSSL::X509->new_from_string(substr($request, index($request, "-----BEGIN")));
             $certs->{$certId} = $x509;
             $request = substr($request, $vallen);
         }
+        elsif ($request =~ /^error_name_(\d+)=(.*)$/m) {
+            my $errorId = $1;
+            my $errorName = $2;
+            $request =~ s/^error_name_\d+=.*$//m;
+            $errors->{$errorId}{"name"} = $errorName;
+        }
+        elsif ($request =~ /^error_cert_(\d+)=(.*)$/m) {
+            my $errorId = $1;
+            my $certId = $2;
+            $request =~ s/^error_cert_\d+=.*$//m;
+            $errors->{$errorId}{"cert"} = $certId;
+        }
         else {
             print(STDERR logPrefix()."ParseError on \"".$request."\"\n") if ($debug);
             $request = "";# finish processing....
@@ -0,0 +1,3 @@
+
+DIST_SUBDIRS	= file
+SUBDIRS		= $(STOREID_REWRITE_HELPERS)
@@ -0,0 +1,15 @@
+include $(top_srcdir)/src/Common.am
+
+libexec_SCRIPTS	= storeid_file_rewrite
+CLEANFILES += storeid_file_rewrite storeid_file_rewrite.8
+man_MANS = storeid_file_rewrite.8
+EXTRA_DIST= \
+	storeid_file_rewrite.8 \
+	storeid_file_rewrite.pl.in \
+	required.m4
+
+storeid_file_rewrite.8: storeid_file_rewrite
+	pod2man storeid_file_rewrite storeid_file_rewrite.8
+
+storeid_file_rewrite: storeid_file_rewrite.pl.in
+	$(subst_perlshell)
@@ -0,0 +1,3 @@
+if test "x$PERL" != "x" -a "x$POD2MAN" != "x"; then
+  BUILD_HELPER="file"
+fi
@@ -0,0 +1,92 @@
+#!@PERL@
+use strict;
+use warnings;
+$|=1;
+
+=pod
+
+=head1 NAME
+
+storeid_file_rewrite - File based Store-ID helper for Squid
+
+=head1 SYNOPSIS
+
+storeid_file_rewrite filepath
+
+=head1 DESCRIPTOIN
+
+This program acts as a store_id helper program, rewriting URLs passed
+by Squid into storage-ids that can be used to achieve better caching
+for websites that use different URLs for the same content.
+
+It takes a text file with two tab separated columns.
+Column 1: Regular expression to match against the URL
+Column 2: Rewrite rule to generate a Store-ID
+Eg:
+^http:\/\/[^\.]+\.dl\.sourceforge\.net\/(.*)	http://dl.sourceforge.net.squid.internal/$1
+
+Rewrite rules are matched in the same order as they appear in the rules file.
+So for best performance, sort it in order of frequency of occurrence.
+
+For more information please see http://wiki.squid-cache.org/Features/StoreID
+
+=cut
+
+my @rules; # array of [regex, replacement string]
+
+die "Usage: $0 <rewrite-file>\n" unless $#ARGV == 0;
+
+# read config file
+open RULES, $ARGV[0] or die "Error opening $ARGV[0]: $!";
+while (<RULES>) {
+	chomp;
+	next if /^\s*#?$/;
+	if (/^\s*([^\t]+?)\s*\t+\s*([^\t]+?)\s*$/) {
+		push(@rules, [qr/$1/, $2]);
+	} else {
+		print STDERR "$0: Parse error in $ARGV[0] (line $.)\n";
+	}
+}
+close RULES;
+
+# read urls from squid and do the replacement
+URL: while (<STDIN>) {
+	chomp;
+	last if $_ eq 'quit';
+	
+	foreach my $rule (@rules) {
+		if (my @match = /$rule->[0]/) {
+			$_ = $rule->[1];
+			
+			for (my $i=1; $i<=scalar(@match); $i++) {
+				s/\$$i/$match[$i-1]/g;
+			}
+			print "OK store-id=$_\n";
+			next URL;
+		}
+	}
+	print "ERR\n";
+}
+
+=pod
+
+=head1 COPYRIGHT
+
+Copyright (C) 2013 Alan Mizrahi <alan@mizrahi.com.ve>
+Based on code from Eliezer Croitoru <eliezer@ngtech.co.il>
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
+
+=cut
@@ -0,0 +1,40 @@
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_storeid_rewrite_helpers list containing double entries.
+
+#define list of modules to build
+if test "x${enable_storeid_rewrite_helpers:=yes}" = "xyes" ; then
+    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/storeid_rewrite],[enable_storeid_rewrite_helpers])
+fi
+
+enable_storeid_rewrite_helpers="`echo $enable_storeid_rewrite_helpers| sed -e 's/,/ /g;s/  */ /g'`"
+AC_MSG_NOTICE([Store-ID rewrite helper candidates: $enable_storeid_rewrite_helpers])
+STOREID_REWRITE_HELPERS=""
+if test "x$enable_storeid_rewrite_helpers" != "xno" ; then
+  for helper in $enable_storeid_rewrite_helpers; do
+    dir="$srcdir/helpers/storeid_rewrite/$helper"
+
+    # modules converted to autoconf macros already
+    # NP: we only need this list because m4_include() does not accept variables
+    if test "x$helper" = "xfile" ; then
+      m4_include([helpers/storeid_rewrite/file/required.m4])
+
+    # modules not yet converted to autoconf macros (or third party drop-in's)
+    elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+      BUILD_HELPER="$helper"
+    fi
+
+    if test -d "$srcdir/helpers/storeid_rewrite/$helper"; then
+      if test "$BUILD_HELPER" != "$helper"; then
+        AC_MSG_NOTICE([Store-ID rewrite helper $helper ... found but cannot be built])
+      else
+        STOREID_REWRITE_HELPERS="$STOREID_REWRITE_HELPERS $BUILD_HELPER"
+      fi
+    else
+      AC_MSG_ERROR([Store-ID rewrite helper $helper ... not found])
+    fi
+  done
+fi
+AC_MSG_NOTICE([Store-ID rewrite helpers to be built: $STOREID_REWRITE_HELPERS])
+AC_SUBST(STOREID_REWRITE_HELPERS)
@@ -7,4 +7,4 @@ url_fake_rewrite_LDADD = $(COMPAT_LIB)
 
 libexec_SCRIPTS = url_fake_rewrite.sh
 
-EXTRA_DIST = url_fake_rewrite.sh config.test
+EXTRA_DIST = url_fake_rewrite.sh required.m4
@@ -1,2 +0,0 @@
-#!/bin/sh
-exit 0
@@ -0,0 +1 @@
+BUILD_HELPER="fake"
@@ -0,0 +1,40 @@
+# This file is supposed to run all the tests required to identify which
+# configured modules are able to be built in this environment
+
+# FIXME: de-duplicate $enable_url_rewrite_helpers list containing double entries.
+
+#define list of modules to build
+if test "x${enable_url_rewrite_helpers:=yes}" = "xyes" ; then
+    SQUID_LOOK_FOR_MODULES([$srcdir/helpers/url_rewrite],[enable_url_rewrite_helpers])
+fi
+
+enable_url_rewrite_helpers="`echo $enable_url_rewrite_helpers| sed -e 's/,/ /g;s/  */ /g'`"
+AC_MSG_NOTICE([URL rewrite helper candidates: $enable_url_rewrite_helpers])
+URL_REWRITE_HELPERS=""
+if test "x$enable_url_rewrite_helpers" != "xno" ; then
+  for helper in $enable_url_rewrite_helpers; do
+    dir="$srcdir/helpers/url_rewrite/$helper"
+
+    # modules converted to autoconf macros already
+    # NP: we only need this list because m4_include() does not accept variables
+    if test "x$helper" = "xfake" ; then
+      m4_include([helpers/url_rewrite/fake/required.m4])
+
+    # modules not yet converted to autoconf macros (or third party drop-in's)
+    elif test -f "$dir/config.test" && sh "$dir/config.test" "$squid_host_os"; then
+      BUILD_HELPER="$helper"
+    fi
+
+    if test -d "$srcdir/helpers/url_rewrite/$helper"; then
+      if test "$BUILD_HELPER" != "$helper"; then
+        AC_MSG_NOTICE([URL rewrite helper $helper ... found but cannot be built])
+      else
+        URL_REWRITE_HELPERS="$URL_REWRITE_HELPERS $BUILD_HELPER"
+      fi
+    else
+      AC_MSG_ERROR([URL rewrite helper $helper ... not found])
+    fi
+  done
+fi
+AC_MSG_NOTICE([URL rewrite helpers to be built: $URL_REWRITE_HELPERS])
+AC_SUBST(URL_REWRITE_HELPERS)
@@ -39,8 +39,6 @@ class CbDataList
 {
 
 public:
-    void *operator new (size_t);
-    void operator delete (void *);
     CbDataList (C const &);
     ~CbDataList();
 
@@ -57,7 +55,7 @@ class CbDataList
     bool empty() const { return this == NULL; }
 
 private:
-    CBDATA_CLASS(CbDataList);
+    CBDATA_CLASS2(CbDataList);
 };
 
 /// \ingroup POD
@@ -102,24 +100,6 @@ template <class C>
 cbdata_type CbDataList<C>::CBDATA_CbDataList = CBDATA_UNKNOWN;
 /** \endcond */
 
-template <class C>
-void *
-CbDataList<C>::operator new (size_t byteCount)
-{
-    CBDATA_INIT_TYPE(CbDataList);
-
-    CbDataList<C> *result = cbdataAlloc(CbDataList);
-
-    return result;
-}
-
-template <class C>
-void
-CbDataList<C>::operator delete (void *address)
-{
-    cbdataFree(address);
-}
-
 template <class C>
 CbDataList<C>::CbDataList(C const &value) : next(NULL), element (value)
 {}
@@ -32,7 +32,7 @@
 #ifndef SQUID_STACK_H
 #define SQUID_STACK_H
 
-#include "Array.h"
+#include "base/Vector.h"
 
 /* RBC: 20030714 Composition might be better long-term, but for now,
  * there's no reason to do so.
@@ -11,13 +11,8 @@ typedef int64_t snint;
 
 #include "snmp.h"
 #include "snmp_impl.h"
-#if 0
-#include "asn1.h"
-#endif
 #include "snmp_api.h"
 
-#include "snmp_vars.h"
-
 /* MIB definitions
  * SQUID-MIB
  *      .iso.org.dod.internet.private.enterprises.nlanr.squid
@@ -37,15 +37,7 @@
 #endif
 
 /* These come first */
-#if 0
-#include "asn1.h"
-#endif
 #include "snmp_error.h"
-#if 0
-#include "mibii.h"
-#include "snmp_extra.h"
-#include "snmp_dump.h"
-#endif
 
 /* I didn't touch this */
 #include "snmp_session.h"
@@ -63,10 +55,6 @@
 /* Other stuff I didn't touch */
 #include "snmp_impl.h"
 #include "snmp_api.h"
-#if 0
-#include "snmp_client.h"
-#include "mib.h"
-#endif
 #include "snmp-internal.h"
 #include "parse.h"
 #include "snmp_debug.h"
@@ -1,8 +1,7 @@
 #ifndef SQUID_SPLAY_H
 #define SQUID_SPLAY_H
 
-#ifndef __cplusplus
-#else
+#if defined(__cplusplus)
 
 #include "Stack.h"
 
@@ -78,8 +78,6 @@ TESTS += tests/testAll
 check_PROGRAMS += tests/testAll
 
 tests_testAll_SOURCES= \
-	tests/testArray.h \
-	tests/testArray.cc \
 	tests/testRFC1035.h \
 	tests/testRFC1035.cc \
 	tests/testRFC1738.h \
@@ -1,5 +1,17 @@
-## Process this file with automake to produce Makefile.in
+include $(top_srcdir)/src/Common.am
+include $(top_srcdir)/src/TestHeaders.am
 
-AUTOMAKE_OPTIONS = dist-bzip2 subdir-objects 1.5
-DIST_SUBDIRS = include src test
-SUBDIRS = src test
+DIST_SUBDIRS = test
+SUBDIRS = test
+
+noinst_LIBRARIES = libTrie.a
+
+noinst_HEADERS = Trie.h TrieNode.h TrieCharTransform.h
+
+libTrie_a_SOURCES = Trie.cc \
+	Trie.cci \
+	Trie.h \
+	TrieNode.cc \
+	TrieNode.cci \
+	TrieNode.h \
+	TrieCharTransform.h
@@ -17,7 +17,7 @@
  *
  */
 
-#include "config.h"
+#include "squid.h"
 #include "Trie.h"
 #if HAVE_UNISTD_H
 #include <unistd.h>
@@ -17,7 +17,7 @@
  *
  */
 
-#include "config.h"
+#include "squid.h"
 #include "TrieNode.h"
 #include "TrieCharTransform.h"
 #if HAVE_UNISTD_H
@@ -1 +0,0 @@
-dnl
@@ -1,114 +0,0 @@
-# Process this file with autoconf to produce a configure script.
-AC_INIT(libTrie, 0.1, rbtcollins@squid-cache.org)
-AC_CONFIG_SRCDIR([src/Trie.cc])
-AM_CONFIG_HEADER([config.h])
-AC_CONFIG_AUX_DIR(cfgaux)
-
-enable_inline=${enable_inline:=yes}
-AC_ARG_ENABLE(optimizations,
-  AC_HELP_STRING([--disable-optimizations],
-                 [Do not compile Squid with compiler optimizations enabled.
-                  Optimization is good for production builds, but not
-                  good for debugging. During development, use
-                  --disable-optimizations to reduce compilation times
-                  and allow easier debugging. This option implicitly
-                  also enabled --disable-inline]), [
-  if test "x$enableval" = "xno" ; then
-        AC_MSG_NOTICE([Disabling compiler optimizations (-O flag)])
-        CFLAGS="`echo $CFLAGS | sed -e 's/-O[[0-9]]*//'`"
-        CXXFLAGS="`echo $CXXFLAGS | sed -e 's/-O[[0-9]]*//'`"
-        enable_inline="no"
-  fi
-])
-
-AC_ARG_ENABLE(inline,
-  AC_HELP_STRING([--disable-inline],
-                 [Do not compile trivial methods as inline. Squid
-                  is coded with much of the code able to be inlined.
-                  Inlining is good for production builds, but not
-                  good for development. During development, use
-                  --disable-inline to reduce compilation times and
-                  allow incremental builds to be quick. For
-                  production builds, or load tests, use
-                  --enable-inline to have squid make all trivial
-                  methods inlinable by the compiler.]), [
-  if test "x${enableval}" = "xno" ; then
-    enable_inline=no
-  fi
-])
-if test "x$enable_inline" = "xyes" ; then
-    AC_DEFINE(_SQUID_INLINE_, inline, 
-      [Keyword used by squid for inlining methods])
-    AC_DEFINE(_USE_INLINE_, 1, [Include inline methods into header file])
-else
-    AC_MSG_NOTICE([Inlining optimization disabled])
-    AC_DEFINE(_SQUID_INLINE_, [] , [Keyword used by squid for inlining methods])
-    AC_DEFINE(_USE_INLINE_, 0, [Include inline methods into header file])
-fi
-
-# Checks for programs.
-AC_PROG_CXX
-AC_PROG_CC
-AC_LANG_CPLUSPLUS
-AC_PROG_MAKE_SET
-# for old automakes - like squid-cache.orgs!
-AM_INIT_AUTOMAKE(libTrie, 0.1)
-AM_MAINTAINER_MODE
-AC_PROG_RANLIB
-
-AC_LIBTOOL_DLOPEN
-AC_LIBLTDL_CONVENIENCE
-AC_PROG_LIBTOOL
-AC_LTDL_DLLIB
-AC_SUBST(INCLTDL)
-AC_SUBST(LIBLTDL)
-
-dnl set useful flags
-TRIE_CFLAGS=
-TRIE_CXXFLAGS=
-if test "$GCC" = "yes"; then
-  TRIE_CFLAGS="-Wall -Wpointer-arith -Wwrite-strings -Wmissing-prototypes -Wmissing-declarations -Wcomments"
-  TRIE_CXXFLAGS="-Wall -Wpointer-arith -Wwrite-strings -Wcomments"
-
-  AC_ARG_ENABLE(strict-error-checking,
-    AS_HELP_STRING([--disable-strict-error-checking],[By default compile
-                   with all possible static compiler error-checks enabled.
-                   This flag disables the behavior]), [
-    case $enableval in
-      yes|1|true)
-	enable_strict_error_checking=yes
-	;;
-      *)
-	enable_strict_error_checking=no
-	;;
-    esac
-  ])
-  AC_MSG_NOTICE([strict error checking enabled: ${enable_strict_error_checking:=yes}])
-  if test "x${enable_strict_error_checking:=yes}" = "xyes"; then
-     TRIE_CFLAGS="-Werror $TRIE_CFLAGS"
-     TRIE_CXXFLAGS="-Werror $TRIE_CXXFLAGS"
-  fi
-
-fi
-
-AC_SUBST(TRIE_CFLAGS)
-AC_SUBST(TRIE_CXXFLAGS)
-
-# Checks for libraries.
-
-# Checks for header files.
-AC_CHECK_HEADERS( \
-	iostream \
-)
-
-# Checks for typedefs, structures, and compiler characteristics.
-AC_C_CONST
-AC_TYPE_SIZE_T
-
-# Checks for library functions.
-
-AC_CONFIG_FILES([Makefile
-                 include/Makefile
-                 src/Makefile
-                 test/Makefile])
-AC_OUTPUT
@@ -1 +0,0 @@
-noinst_HEADERS = Trie.h TrieNode.h TrieCharTransform.h
@@ -1,13 +0,0 @@
-
-INCLUDES = -I$(top_srcdir)/include
-
-AM_CFLAGS = $(TRIE_CFLAGS)
-AM_CXXFLAGS = $(TRIE_CXXFLAGS)
-
-noinst_LIBRARIES = libTrie.a
-
-libTrie_a_SOURCES = Trie.cc \
-	TrieNode.cc
-
-noinst_HEADERS = ../include/Trie.cci \
-	../include/TrieNode.cci
@@ -1,16 +1,15 @@
-INCLUDES = -I$(top_srcdir)/include
+include $(top_srcdir)/src/Common.am
 
-AM_CFLAGS = $(TRIE_CFLAGS)
-AM_CXXFLAGS = $(TRIE_CXXFLAGS)
+INCLUDES += -I$(top_srcdir)/include
 
 # TESTS = trie trie-c
-TESTS = trie
+TESTS += trie
 
 # check_PROGRAMS = trie trie-c
-check_PROGRAMS = trie
+check_PROGRAMS += trie
 
 trie_SOURCES = trie.cc
-trie_LDADD = $(top_builddir)/src/libTrie.a
+trie_LDADD = $(top_builddir)/lib/libTrie/libTrie.a
 
 #trie_c_SOURCES = trie-c.c
-#trie_c_LDADD = $(top_builddir)/src/libTrie.a -lm
+#trie_c_LDADD = $(top_builddir)/lib/libTrie/libTrie.a -lm
@@ -17,9 +17,9 @@
  *
  */
 
-#include "config.h"
-#include "Trie.h"
-#include "TrieCharTransform.h"
+#include "squid.h"
+#include "libTrie/Trie.h"
+#include "libTrie/TrieCharTransform.h"
 
 #if HAVE_IOSTREAM
 #include <iostream>
@@ -4,6 +4,7 @@
 #if USE_XPROF_STATS
 typedef enum {
     XPROF_PROF_UNACCOUNTED,
+    XPROF_ACL_matches,
     XPROF_HttpHeaderClean,
     XPROF_HttpHeaderParse,
     XPROF_HttpHeader_getCc,
@@ -27,7 +28,6 @@ typedef enum {
     XPROF_StringInitBuf,
     XPROF_StringReset,
     XPROF_aclCheckFast,
-    XPROF_aclMatchAclList,
     XPROF_calloc,
     XPROF_clientSocketRecipient,
     XPROF_commHandleWrite,
@@ -1,22 +0,0 @@
-#define SQUID_UNIT_TEST 1
-#include "squid.h"
-
-#if HAVE_ASSERT_H
-#include <assert.h>
-#endif
-
-#include "testArray.h"
-#include "Array.h"
-
-CPPUNIT_TEST_SUITE_REGISTRATION( testArray );
-
-void testArray::all()
-{
-    CPPUNIT_ASSERT( 1 == 1 );
-    Vector<int> aArray;
-    CPPUNIT_ASSERT (aArray.size() == 0);
-    aArray.push_back(2);
-    CPPUNIT_ASSERT (aArray.size() == 1);
-    CPPUNIT_ASSERT (aArray.back() == 2);
-    CPPUNIT_ASSERT (aArray.size() == 1);
-}
@@ -23,9 +23,9 @@
 		'AsyncCall.* constructed, this=(\S+)',
 		'AsyncCall.* destruct.*, this=(\S+)',
 	],
-	HttpReq => [
-		'\bHttpRequest.* constructed, this=(\S+)',
-		'\bHttpRequest.* destructed, this=(\S+)',
+	HttpHeaderEntry => [
+		'\bHttpHeaderEntry.* created HttpHeaderEntry (\S+)',
+		'\bHttpHeaderEntry.* destroying entry (\S+)',
 	],
 	ClientSocketContext => [
 		'\bClientSocketContext constructing, this=(\S+)',
@@ -85,6 +85,15 @@ for FILENAME in `ls -1`; do
 		;;
 	esac
 
+	#
+	# forward.h means different things to Squid code depending on the path
+	# require the full path is explicit for every include
+	#
+	FI=`grep "#include \"forward.h\"" ${FILENAME}`;
+	if test "x${FI}" != "x" ; then
+		echo "ERROR: ${PWD}/${FILENAME} contains reference to forward.h without path"
+	fi
+
 	#
 	# DEBUG Section list maintenance
 	#
@@ -111,7 +120,7 @@ for FILENAME in `ls -1`; do
 
     esac
 
-    if test "$FILENAME" = "libltdl" -o "$FILENAME" = "libTrie" ; then
+    if test "$FILENAME" = "libltdl" ; then
         :
     elif test -d $FILENAME ; then
 	cd $FILENAME
@@ -690,8 +690,8 @@ parse_objectid(FILE *fp, char *name) {
          */
         if (count == (length - 2)) {
             if (op->label) {
-                strncpy(np->parent, op->label, sizeof(np->parent));
-                strncpy(np->label, name, sizeof(np->label));
+                strncpy(np->parent, op->label, sizeof(np->parent)-1);
+                strncpy(np->label, name, sizeof(np->label)-1);
                 if (nop->subid != -1)
                     np->subid = nop->subid;
                 else
@@ -17,15 +17,15 @@ AccessLogEntry::getLogClientIp(char *buf, size_t bufsz) const
 {
 #if FOLLOW_X_FORWARDED_FOR
     if (Config.onoff.log_uses_indirect_client && request)
-        request->indirect_client_addr.NtoA(buf, bufsz);
+        request->indirect_client_addr.toStr(buf, bufsz);
     else
 #endif
         if (tcpClient != NULL)
-            tcpClient->remote.NtoA(buf, bufsz);
-        else if (cache.caddr.IsNoAddr()) // e.g., ICAP OPTIONS lack client
+            tcpClient->remote.toStr(buf, bufsz);
+        else if (cache.caddr.isNoAddr()) // e.g., ICAP OPTIONS lack client
             strncpy(buf, "-", bufsz);
         else
-            cache.caddr.NtoA(buf, bufsz);
+            cache.caddr.toStr(buf, bufsz);
 }
 
 AccessLogEntry::~AccessLogEntry()
@@ -37,7 +37,6 @@ AccessLogEntry::~AccessLogEntry()
 #endif
 
     safe_free(headers.reply);
-    safe_free(cache.authuser);
 
     safe_free(headers.adapted_request);
     HTTPMSGUNLOCK(adapted_request);
@@ -153,7 +153,6 @@ class AccessLogEntry: public RefCountable
                 code (LOG_TAG_NONE),
                 msec(0),
                 rfc931 (NULL),
-                authuser (NULL),
                 extuser(NULL),
 #if USE_SSL
                 ssluser(NULL),
@@ -172,7 +171,6 @@ class AccessLogEntry: public RefCountable
         LogTags code;
         int msec;
         const char *rfc931;
-        const char *authuser;
         const char *extuser;
 #if USE_SSL
 
@@ -232,9 +230,9 @@ class AccessLogEntry: public RefCountable
     HttpRequest *request; //< virgin HTTP request
     HttpRequest *adapted_request; //< HTTP request after adaptation and redirection
 
-    /// key:value pairs set by note and adaptation_meta directives
-    /// plus key=value pairs returned from URL rewrite/redirect helper
-    NotePairs notes;
+    /// key:value pairs set by squid.conf note directive and
+    /// key=value pairs returned from URL rewrite/redirect helper
+    NotePairs::Pointer notes;
 
 #if ICAP_CLIENT
     /** \brief This subclass holds log info for ICAP part of request
@@ -5,7 +5,8 @@
     does not get linked in, because nobody is using these classes by name.
 */
 
-#include "acl/Acl.h"
+#include "acl/AllOf.h"
+#include "acl/AnyOf.h"
 #if USE_SQUID_EUI
 #include "acl/Arp.h"
 #include "acl/Eui64.h"
@@ -37,6 +38,8 @@
 #include "acl/MethodData.h"
 #include "acl/Method.h"
 #include "acl/MyPortName.h"
+#include "acl/Note.h"
+#include "acl/NoteData.h"
 #include "acl/PeerName.h"
 #include "acl/ProtocolData.h"
 #include "acl/Protocol.h"
@@ -146,7 +149,7 @@ ACLStrategised<int> ACLUrlPort::RegistryEntry_(new ACLIntRange, ACLUrlPortStrate
 
 #if USE_SSL
 ACL::Prototype ACLSslError::RegistryProtoype(&ACLSslError::RegistryEntry_, "ssl_error");
-ACLStrategised<const Ssl::Errors *> ACLSslError::RegistryEntry_(new ACLSslErrorData, ACLSslErrorStrategy::Instance(), "ssl_error");
+ACLStrategised<const Ssl::CertErrors *> ACLSslError::RegistryEntry_(new ACLSslErrorData, ACLSslErrorStrategy::Instance(), "ssl_error");
 ACL::Prototype ACLCertificate::UserRegistryProtoype(&ACLCertificate::UserRegistryEntry_, "user_cert");
 ACLStrategised<X509 *> ACLCertificate::UserRegistryEntry_(new ACLCertificateData (Ssl::GetX509UserAttribute, "*"), ACLCertificateStrategy::Instance(), "user_cert");
 ACL::Prototype ACLCertificate::CARegistryProtoype(&ACLCertificate::CARegistryEntry_, "ca_cert");
@@ -181,3 +184,12 @@ ACLMaxUserIP ACLMaxUserIP::RegistryEntry_("max_user_ip");
 
 ACL::Prototype ACLTag::RegistryProtoype(&ACLTag::RegistryEntry_, "tag");
 ACLStrategised<const char *> ACLTag::RegistryEntry_(new ACLStringData, ACLTagStrategy::Instance(), "tag");
+
+ACL::Prototype Acl::AnyOf::RegistryProtoype(&Acl::AnyOf::RegistryEntry_, "any-of");
+Acl::AnyOf Acl::AnyOf::RegistryEntry_;
+
+ACL::Prototype Acl::AllOf::RegistryProtoype(&Acl::AllOf::RegistryEntry_, "all-of");
+Acl::AllOf Acl::AllOf::RegistryEntry_;
+
+ACL::Prototype ACLNote::RegistryProtoype(&ACLNote::RegistryEntry_, "note");
+ACLStrategised<HttpRequest *> ACLNote::RegistryEntry_(new ACLNoteData, ACLNoteStrategy::Instance(), "note");
@@ -29,6 +29,7 @@
  *
  */
 
+#include "acl/forward.h"
 #include "enums.h"
 #include "icp_opcode.h"
 #include "ip/Address.h"
@@ -40,7 +41,6 @@
 #include <openssl/ssl.h>
 #endif
 
-class acl_access;
 class CachePeerDomainList;
 class NeighborTypeDomainList;
 class PeerDigest;
@@ -83,7 +83,7 @@ void ClientDelayConfig::parsePoolAccess(ConfigParser &parser)
     }
 
     --pool;
-    aclParseAccessLine(parser, &pools[pool].access);
+    aclParseAccessLine("client_delay_access", parser, &pools[pool].access);
 }
 
 void ClientDelayConfig::clean()
@@ -1,9 +1,10 @@
 #ifndef SQUID_CLIENTDELAYCONFIG_H
 #define SQUID_CLIENTDELAYCONFIG_H
 
-#include "Array.h"
+#include "acl/forward.h"
+#include "base/Vector.h"
+
 class StoreEntry;
-class acl_access;
 class ConfigParser;
 
 /// \ingroup DelayPoolsAPI
@@ -20,9 +20,6 @@ class ClientRequestContext : public RefCountable
 {
 
 public:
-    void *operator new(size_t);
-    void operator delete(void *);
-
     ClientRequestContext(ClientHttpRequest *);
     ~ClientRequestContext();
 
@@ -87,7 +84,7 @@ class ClientRequestContext : public RefCountable
     bool readNextRequest; ///< whether Squid should read after error handling
 
 private:
-    CBDATA_CLASS(ClientRequestContext);
+    CBDATA_CLASS2(ClientRequestContext);
 };
 
 #endif /* SQUID_CLIENTREQUESTCONTEXT_H */
@@ -40,10 +40,19 @@ CommCommonCbParams::print(std::ostream &os) const
 /* CommAcceptCbParams */
 
 CommAcceptCbParams::CommAcceptCbParams(void *aData):
-        CommCommonCbParams(aData)
+        CommCommonCbParams(aData), xaction()
 {
 }
 
+void
+CommAcceptCbParams::print(std::ostream &os) const
+{
+    CommCommonCbParams::print(os);
+
+    if (xaction != NULL)
+        os << ", " << xaction->id;
+}
+
 /* CommConnectCbParams */
 
 CommConnectCbParams::CommConnectCbParams(void *aData):
@@ -5,6 +5,7 @@
 #include "base/AsyncJobCalls.h"
 #include "comm_err_t.h"
 #include "comm/forward.h"
+#include "MasterXaction.h"
 
 /* CommCalls implement AsyncCall interface for comm_* callbacks.
  * The classes cover two call dialer kinds:
@@ -89,6 +90,11 @@ class CommAcceptCbParams: public CommCommonCbParams
 {
 public:
     CommAcceptCbParams(void *aData);
+
+    void print(std::ostream &os) const;
+
+    /// Transaction which this call is part of.
+    MasterXaction::Pointer xaction;
 };
 
 // connect parameters
@@ -30,8 +30,7 @@
 #ifndef SQUID_CONFIGOPTION_H
 #define SQUID_CONFIGOPTION_H
 
-/* for Vector<> */
-#include "Array.h"
+#include "base/Vector.h"
 
 class StoreEntry;
 
@@ -188,7 +188,7 @@ ConfigParser::ParseQuotedString(String *var, bool *wasQuoted)
 }
 
 const char *
-ConfigParser::QuoteString(String &var)
+ConfigParser::QuoteString(const String &var)
 {
     static String quotedStr;
     const char *s = var.termedBuf();
@@ -77,7 +77,7 @@ class ConfigParser
     /// quotes. TODO: support quoted strings anywhere a token is accepted.
     static void ParseQuotedString(char **var, bool *wasQuoted = NULL);
     static void ParseQuotedString(String *var, bool *wasQuoted = NULL);
-    static const char *QuoteString(String &var);
+    static const char *QuoteString(const String &var);
     static void ParseWordList(wordlist **list);
     static char * strtokFile();
     static void strtokFileUndo();
@@ -4,7 +4,7 @@
 #ifndef SQUID_CPU_AFFINITY_MAP_H
 #define SQUID_CPU_AFFINITY_MAP_H
 
-#include "Array.h"
+#include "base/Vector.h"
 
 class CpuAffinitySet;
 
@@ -113,7 +113,7 @@ DelayConfig::parsePoolAccess(ConfigParser &parser)
     }
 
     --pool;
-    aclParseAccessLine(parser, &DelayPools::delay_data[pool].access);
+    aclParseAccessLine("delay_access", parser, &DelayPools::delay_data[pool].access);
 }
 
 void
@@ -97,7 +97,7 @@ DelayId::DelayClient(ClientHttpRequest * http)
     assert(http);
     r = http->request;
 
-    if (r->client_addr.IsNoAddr()) {
+    if (r->client_addr.isNoAddr()) {
         debugs(77, 2, "delayClient: WARNING: Called with 'NO_ADDR' address, ignoring");
         return DelayId();
     }
@@ -39,13 +39,12 @@
 
 #if USE_DELAY_POOLS
 #include "CompositePoolNode.h"
+#include "acl/forward.h"
 
 class StoreEntry;
 
 class CommonPool;
 
-class acl_access;
-
 /// \ingroup DelayPoolsAPI
 class DelayPool
 {
@@ -32,6 +32,12 @@
 #ifndef SQUID_DELAYPOOLS_H
 #define SQUID_DELAYPOOLS_H
 
+#include "base/Vector.h"
+
+class DelayPool;
+class Updateable;
+class StoreEntry;
+
 /**
  \defgroup DelayPoolsAPI Delay Pools API
  \ingroup Components
@@ -47,14 +53,6 @@ class Updateable
     virtual void update(int) = 0;
 };
 
-/* forward decls */
-class DelayPool;
-class Updateable;
-class StoreEntry;
-
-/* for Vector<> */
-#include "Array.h"
-
 /// \ingroup DelayPoolsAPI
 class DelayPools
 {
@@ -190,10 +190,10 @@ DelayTaggedBucket::~DelayTaggedBucket()
 }
 
 void
-DelayTaggedBucket::stats (StoreEntry *entry) const
+DelayTaggedBucket::stats(StoreEntry *entry) const
 {
-    storeAppendPrintf(entry, " :" SQUIDSTRINGPH , SQUIDSTRINGPRINT(tag));
-    theBucket.stats (entry);
+    storeAppendPrintf(entry, " " SQUIDSTRINGPH ":", SQUIDSTRINGPRINT(tag));
+    theBucket.stats(entry);
 }
 
 DelayTagged::Id::Id(DelayTagged::Pointer aDelayTagged, String &aTag) : theTagged(aDelayTagged)
@@ -41,7 +41,7 @@
 #include "DelayIdComposite.h"
 #include "DelayBucket.h"
 #include "DelaySpec.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "splay.h"
 
 /// \ingroup DelayPoolsAPI
@@ -42,7 +42,7 @@
 #include "DelayIdComposite.h"
 #include "DelayBucket.h"
 #include "DelaySpec.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "splay.h"
 
 /// \ingroup DelayPoolsAPI
@@ -58,18 +58,6 @@
 #endif
 
 CBDATA_CLASS_INIT(AIODiskFile);
-void *
-AIODiskFile::operator new(size_t unused)
-{
-    CBDATA_INIT_TYPE(AIODiskFile);
-    return cbdataAlloc(AIODiskFile);
-}
-
-void
-AIODiskFile::operator delete(void *address)
-{
-    cbdataFree(address);
-}
 
 AIODiskFile::AIODiskFile(char const *aPath, AIODiskIOStrategy *aStrategy) : fd(-1), closed(true), error_(false)
 {
@@ -46,8 +46,6 @@ class AIODiskFile : public DiskFile
 public:
 
     friend class AIODiskIOStrategy;
-    void * operator new (size_t);
-    void operator delete (void *);
     AIODiskFile (char const *path, AIODiskIOStrategy *);
     ~AIODiskFile();
 
@@ -77,7 +75,7 @@ class AIODiskFile : public DiskFile
     RefCount<IORequestor> ioRequestor;
     bool closed;
     bool error_;
-    CBDATA_CLASS(AIODiskFile);
+    CBDATA_CLASS2(AIODiskFile);
 };
 
 #endif /* USE_DISKIO_AIO */
@@ -43,24 +43,8 @@
 #if HAVE_ERRNO_H
 #include <errno.h>
 #endif
-CBDATA_CLASS_INIT(BlockingFile);
-
-void *
-BlockingFile::operator new(size_t sz)
-{
-    CBDATA_INIT_TYPE(BlockingFile);
-    BlockingFile *result = cbdataAlloc(BlockingFile);
-    /* Mark result as being owned - we want the refcounter to do the delete
-     * call */
-    return result;
-}
 
-void
-BlockingFile::operator delete(void *address)
-{
-    BlockingFile *t = static_cast<BlockingFile *>(address);
-    cbdataFree(t);
-}
+CBDATA_CLASS_INIT(BlockingFile);
 
 BlockingFile::BlockingFile(char const *aPath) : fd (-1), closed (true), error_(false)
 {
@@ -42,8 +42,6 @@ class BlockingFile : public DiskFile
 {
 
 public:
-    void *operator new(size_t);
-    void operator delete(void *);
     BlockingFile(char const *path);
     ~BlockingFile();
     virtual void open(int flags, mode_t mode, RefCount<IORequestor> callback);
@@ -72,7 +70,7 @@ class BlockingFile : public DiskFile
     void readDone(int fd, const char *buf, int len, int errflag);
     void writeDone(int fd, int errflag, size_t len);
 
-    CBDATA_CLASS(BlockingFile);
+    CBDATA_CLASS2(BlockingFile);
 };
 
 #endif /* SQUID_BLOCKINGFILE_H */
@@ -53,25 +53,6 @@
 
 CBDATA_CLASS_INIT(DiskdFile);
 
-void *
-DiskdFile::operator new(size_t unused)
-{
-    CBDATA_INIT_TYPE(DiskdFile);
-    DiskdFile *result = cbdataAlloc(DiskdFile);
-    /* Mark result as being owned - we want the refcounter to do the delete
-     * call */
-    debugs(79, 3, "diskdFile with base " << result << " allocating");
-    return result;
-}
-
-void
-DiskdFile::operator delete(void *address)
-{
-    DiskdFile *t = static_cast<DiskdFile *>(address);
-    debugs(79, 3, "diskdFile with base " << t << " deleting");
-    cbdataFree(t);
-}
-
 DiskdFile::DiskdFile(char const *aPath, DiskdIOStrategy *anIO) :
         errorOccured(false),
         IO(anIO),
@@ -48,8 +48,6 @@ class DiskdFile : public DiskFile
 {
 
 public:
-    void * operator new(size_t);
-    void operator delete(void *);
     DiskdFile(char const *path, DiskdIOStrategy *);
     ~DiskdFile();
     virtual void open(int flags, mode_t aMode, RefCount<IORequestor> callback);
@@ -84,7 +82,7 @@ class DiskdFile : public DiskFile
     void ioCompleted();
     size_t inProgressIOs;
 
-    CBDATA_CLASS(DiskdFile);
+    CBDATA_CLASS2(DiskdFile);
 };
 
 #endif
@@ -195,7 +195,7 @@ DiskdIOStrategy::init()
     args[2] = skey2;
     args[3] = skey3;
     args[4] = NULL;
-    localhost.SetLocalhost();
+    localhost.setLocalhost();
     pid = ipcCreate(IPC_STREAM,
                     Config.Program.diskd,
                     args,
@@ -32,7 +32,7 @@
 #ifndef SQUID_DISKIOMODULE_H
 #define SQUID_DISKIOMODULE_H
 
-#include "Array.h"
+#include "base/Vector.h"
 
 /* forward decls */
 
@@ -50,26 +50,6 @@
 /* === PUBLIC =========================================================== */
 
 CBDATA_CLASS_INIT(DiskThreadsDiskFile);
-void *
-DiskThreadsDiskFile::operator new (size_t)
-{
-    CBDATA_INIT_TYPE(DiskThreadsDiskFile);
-    DiskThreadsDiskFile *result = cbdataAlloc(DiskThreadsDiskFile);
-    /*
-     * We used to call squidaio_init() here, but if the first transaction
-     * is to unlink a file (e.g., if Squid starts up over the disk space
-     * limit) then "squidaio" won't be initialized yet.
-     */
-
-    return result;
-}
-
-void
-DiskThreadsDiskFile::operator delete(void *address)
-{
-    DiskThreadsDiskFile *t = static_cast<DiskThreadsDiskFile *>(address);
-    cbdataFree(t);
-}
 
 DiskThreadsDiskFile::DiskThreadsDiskFile(char const *aPath, DiskThreadsIOStrategy *anIO):fd(-1), errorOccured (false), IO(anIO),
         inProgressIOs (0)
@@ -374,19 +354,3 @@ DiskThreadsDiskFile::writeDone(int rvfd, int errflag, size_t len, RefCount<Write
 template <class RT>
 cbdata_type IoResult<RT>::CBDATA_IoResult = CBDATA_UNKNOWN;
 /** \endcond */
-
-template<class RT>
-void *
-IoResult<RT>::operator new(size_t unused)
-{
-    CBDATA_INIT_TYPE(IoResult);
-    IoResult<RT> *result = cbdataAlloc(IoResult);
-    return result;
-}
-
-template <class RT>
-void
-IoResult<RT>::operator delete(void *address)
-{
-    cbdataFree(address);
-}
@@ -41,8 +41,6 @@ class DiskThreadsDiskFile : public DiskFile
 {
 
 public:
-    void * operator new(size_t);
-    void operator delete(void *);
     DiskThreadsDiskFile(char const *path, DiskThreadsIOStrategy *);
     ~DiskThreadsDiskFile();
     virtual void open(int flags, mode_t mode, RefCount<IORequestor> callback);
@@ -86,7 +84,7 @@ class DiskThreadsDiskFile : public DiskFile
     void readDone(int fd, const char *buf, int len, int errflag, RefCount<ReadRequest> request);
     void writeDone(int fd, int errflag, size_t len, RefCount<WriteRequest> request);
 
-    CBDATA_CLASS(DiskThreadsDiskFile);
+    CBDATA_CLASS2(DiskThreadsDiskFile);
 };
 
 #include "DiskIO/ReadRequest.h"
@@ -96,15 +94,13 @@ class IoResult
 {
 
 public:
-    void * operator new (size_t);
-    void operator delete (void *);
     IoResult(RefCount<DiskThreadsDiskFile> aFile, RefCount<RT> aRequest) : file(aFile), request(aRequest) {}
 
     RefCount<DiskThreadsDiskFile> file;
     RefCount<RT> request;
 
 private:
-    CBDATA_CLASS(IoResult);
+    CBDATA_CLASS2(IoResult);
 };
 
 template <class RT>
@@ -21,6 +21,11 @@
 #include <errno.h>
 #endif
 
+// Some systems such as Hurd provide mmap() API but do not support MAP_NORESERVE
+#ifndef MAP_NORESERVE
+#define MAP_NORESERVE 0
+#endif
+
 CBDATA_CLASS_INIT(MmappedFile);
 
 // helper class to deal with mmap(2) offset alignment and other low-level specs
@@ -44,23 +49,6 @@ class Mmapping
     void *buf; ///< buffer returned by mmap, needed for munmap
 };
 
-void *
-MmappedFile::operator new(size_t sz)
-{
-    CBDATA_INIT_TYPE(MmappedFile);
-    MmappedFile *result = cbdataAlloc(MmappedFile);
-    /* Mark result as being owned - we want the refcounter to do the delete
-     * call */
-    return result;
-}
-
-void
-MmappedFile::operator delete(void *address)
-{
-    MmappedFile *t = static_cast<MmappedFile *>(address);
-    cbdataFree(t);
-}
-
 MmappedFile::MmappedFile(char const *aPath): fd(-1),
         minOffset(0), maxOffset(-1), error_(false)
 {
@@ -9,8 +9,6 @@ class MmappedFile : public DiskFile
 {
 
 public:
-    void *operator new(size_t);
-    void operator delete(void *);
     MmappedFile(char const *path);
     ~MmappedFile();
     virtual void open(int flags, mode_t mode, RefCount<IORequestor> callback);
@@ -40,7 +38,7 @@ class MmappedFile : public DiskFile
 
     void doClose();
 
-    CBDATA_CLASS(MmappedFile);
+    CBDATA_CLASS2(MmappedFile);
 };
 
 #endif /* SQUID_MMAPPEDFILE_H */
@@ -31,7 +31,7 @@
 #ifndef SQUID_EVENTLOOP_H
 #define SQUID_EVENTLOOP_H
 
-#include "Array.h"
+#include "base/Vector.h"
 
 #define EVENT_LOOP_TIMEOUT	1000 /* 1s timeout */
 
@@ -49,21 +49,6 @@
 
 CBDATA_CLASS_INIT(ExternalACLEntry);
 
-void *
-ExternalACLEntry::operator new (size_t byteCount)
-{
-    /* derived classes with different sizes must implement their own new */
-    assert (byteCount == sizeof (ExternalACLEntry));
-    CBDATA_INIT_TYPE(ExternalACLEntry);
-    return cbdataAlloc(ExternalACLEntry);
-}
-
-void
-ExternalACLEntry::operator delete (void *address)
-{
-    cbdataFree (address);
-}
-
 ExternalACLEntry::ExternalACLEntry()
 {
     lru.next = lru.prev = NULL;
@@ -81,9 +81,6 @@ class ExternalACLEntry: public hash_link
 {
 
 public:
-    void *operator new (size_t bytesToAllocate);
-    void operator delete (void *address);
-
     ExternalACLEntry();
     ~ExternalACLEntry();
 
@@ -101,7 +98,7 @@ class ExternalACLEntry: public hash_link
     external_acl *def;
 
 private:
-    CBDATA_CLASS(ExternalACLEntry);
+    CBDATA_CLASS2(ExternalACLEntry);
 };
 
 typedef class ExternalACLEntry external_acl_entry;
@@ -1,7 +1,7 @@
 #ifndef SQUID_FADING_COUNTER_H
 #define SQUID_FADING_COUNTER_H
 
-#include "Array.h"
+#include "base/Vector.h"
 
 /// Counts events, forgetting old ones. Usefull for "3 errors/minute" limits.
 class FadingCounter
@@ -47,8 +47,8 @@
 #include "event.h"
 #include "fd.h"
 #include "fde.h"
-#include "forward.h"
 #include "ftp.h"
+#include "FwdState.h"
 #include "globals.h"
 #include "gopher.h"
 #include "hier_code.h"
@@ -151,7 +151,7 @@ void FwdState::start(Pointer aSelf)
     // Bug 3243: CVE 2009-0801
     // Bypass of browser same-origin access control in intercepted communication
     // To resolve this we must force DIRECT and only to the original client destination.
-    const bool isIntercepted = request && !request->flags.redirected && (request->flags.intercepted || request->flags.spoofClientIp);
+    const bool isIntercepted = request && !request->flags.redirected && (request->flags.intercepted || request->flags.interceptTproxy);
     const bool useOriginalDst = Config.onoff.client_dst_passthru || (request && !request->flags.hostVerified);
     if (isIntercepted && useOriginalDst) {
         selectPeerForIntercepted();
@@ -296,7 +296,7 @@ FwdState::Start(const Comm::ConnectionPointer &clientConn, StoreEntry *entry, Ht
      * be allowed.  yuck, I know.
      */
 
-    if ( Config.accessList.miss && !request->client_addr.IsNoAddr() &&
+    if ( Config.accessList.miss && !request->client_addr.isNoAddr() &&
             request->protocol != AnyP::PROTO_INTERNAL && request->protocol != AnyP::PROTO_CACHE_OBJECT) {
         /**
          * Check if this host is allowed to fetch MISSES from us (miss_access).
@@ -552,10 +552,7 @@ FwdState::checkRetry()
     if (!entry->isEmpty())
         return false;
 
-    if (n_tries > 10)
-        return false;
-
-    if (origin_tries > 2)
+    if (n_tries > Config.forward_max_tries)
         return false;
 
     if (squid_curtime - start_t > Config.Timeout.forward)
@@ -713,7 +710,7 @@ FwdState::negotiateSSL(int fd)
                     serverBump->serverCert.resetAndLock(errDetails->peerCert());
 
                     // remember validation errors, if any
-                    if (Ssl::Errors *errs = static_cast<Ssl::Errors*>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors)))
+                    if (Ssl::CertErrors *errs = static_cast<Ssl::CertErrors*>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors)))
                         serverBump->sslErrors = cbdataReference(errs);
                 }
             }
@@ -751,7 +748,7 @@ FwdState::negotiateSSL(int fd)
             serverBump->serverCert.reset(SSL_get_peer_certificate(ssl));
 
             // remember validation errors, if any
-            if (Ssl::Errors *errs = static_cast<Ssl::Errors *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors)))
+            if (Ssl::CertErrors *errs = static_cast<Ssl::CertErrors *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors)))
                 serverBump->sslErrors = cbdataReference(errs);
         }
     }
@@ -771,7 +768,7 @@ FwdState::negotiateSSL(int fd)
         // Ssl::CertValidationHelper::submit method.
         validationRequest.ssl = ssl;
         validationRequest.domainName = request->GetHost();
-        if (Ssl::Errors *errs = static_cast<Ssl::Errors *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors)))
+        if (Ssl::CertErrors *errs = static_cast<Ssl::CertErrors *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors)))
             // validationRequest disappears on return so no need to cbdataReference
             validationRequest.errors = errs;
         else
@@ -810,7 +807,7 @@ FwdState::sslCrtvdHandleReplyWrapper(void *data, Ssl::CertValidationResponse con
 void
 FwdState::sslCrtvdHandleReply(Ssl::CertValidationResponse const &validationResponse)
 {
-    Ssl::Errors *errs = NULL;
+    Ssl::CertErrors *errs = NULL;
     Ssl::ErrorDetail *errDetails = NULL;
     bool validatorFailed = false;
     if (!Comm::IsConnOpen(serverConnection())) {
@@ -863,11 +860,11 @@ FwdState::sslCrtvdHandleReply(Ssl::CertValidationResponse const &validationRespo
 
 /// Checks errors in the cert. validator response against sslproxy_cert_error.
 /// The first honored error, if any, is returned via errDetails parameter.
-/// The method returns all seen errors except SSL_ERROR_NONE as Ssl::Errors.
-Ssl::Errors *
+/// The method returns all seen errors except SSL_ERROR_NONE as Ssl::CertErrors.
+Ssl::CertErrors *
 FwdState::sslCrtvdCheckForErrors(Ssl::CertValidationResponse const &resp, Ssl::ErrorDetail *& errDetails)
 {
-    Ssl::Errors *errs = NULL;
+    Ssl::CertErrors *errs = NULL;
 
     ACLFilledChecklist *check = NULL;
     if (acl_access *acl = Config.ssl_client.cert_error)
@@ -883,7 +880,7 @@ FwdState::sslCrtvdCheckForErrors(Ssl::CertValidationResponse const &resp, Ssl::E
         if (!errDetails) {
             bool allowed = false;
             if (check) {
-                check->sslErrors = new Ssl::Errors(i->error_no);
+                check->sslErrors = new Ssl::CertErrors(Ssl::CertError(i->error_no, i->cert.get()));
                 if (check->fastCheck() == ACCESS_ALLOWED)
                     allowed = true;
             }
@@ -906,9 +903,9 @@ FwdState::sslCrtvdCheckForErrors(Ssl::CertValidationResponse const &resp, Ssl::E
         }
 
         if (!errs)
-            errs = new Ssl::Errors(i->error_no);
+            errs = new Ssl::CertErrors(Ssl::CertError(i->error_no, i->cert.get()));
         else
-            errs->push_back_unique(i->error_no);
+            errs->push_back_unique(Ssl::CertError(i->error_no, i->cert.get()));
     }
     if (check)
         delete check;
@@ -1082,7 +1079,7 @@ FwdState::connectStart()
 
     debugs(17, 3, "fwdConnectStart: " << entry->url());
 
-    if (n_tries == 0) // first attempt
+    if (!request->hier.first_conn_start.tv_sec) // first attempt
         request->hier.first_conn_start = current_time;
 
     /* connection timeout */
@@ -1163,20 +1160,17 @@ FwdState::connectStart()
         debugs(17, 3, HERE << "reusing pconn " << serverConnection());
         ++n_tries;
 
-        if (!serverConnection()->getPeer())
-            ++origin_tries;
-
         comm_add_close_handler(serverConnection()->fd, fwdServerClosedWrapper, this);
 
         /* Update server side TOS and Netfilter mark on the connection. */
         if (Ip::Qos::TheConfig.isAclTosActive()) {
-            temp->tos = GetTosToServer(request);
-            Ip::Qos::setSockTos(temp, temp->tos);
+            const tos_t tos = GetTosToServer(request);
+            Ip::Qos::setSockTos(temp, tos);
         }
 #if SO_MARK
         if (Ip::Qos::TheConfig.isAclNfmarkActive()) {
-            temp->nfmark = GetNfmarkToServer(request);
-            Ip::Qos::setSockNfmark(temp, temp->nfmark);
+            const nfmark_t nfmark = GetNfmarkToServer(request);
+            Ip::Qos::setSockNfmark(temp, nfmark);
         }
 #endif
 
@@ -1187,7 +1181,7 @@ FwdState::connectStart()
     // We will try to open a new connection, possibly to the same destination.
     // We reset serverDestinations[0] in case we are using it again because
     // ConnOpener modifies its destination argument.
-    serverDestinations[0]->local.SetPort(0);
+    serverDestinations[0]->local.port(0);
     serverConn = NULL;
 
 #if URL_CHECKSUM_DEBUG
@@ -1364,9 +1358,6 @@ FwdState::reforward()
     if (n_tries > Config.forward_max_tries)
         return 0;
 
-    if (origin_tries > 1)
-        return 0;
-
     if (request->bodyNibbled())
         return 0;
 
@@ -1529,11 +1520,11 @@ void
 getOutgoingAddress(HttpRequest * request, Comm::ConnectionPointer conn)
 {
     // skip if an outgoing address is already set.
-    if (!conn->local.IsAnyAddr()) return;
+    if (!conn->local.isAnyAddr()) return;
 
     // ensure that at minimum the wildcard local matches remote protocol
-    if (conn->remote.IsIPv4())
-        conn->local.SetIPv4();
+    if (conn->remote.isIPv4())
+        conn->local.setIPv4();
 
     // maybe use TPROXY client address
     if (request && request->flags.spoofClientIp) {
@@ -1567,7 +1558,7 @@ getOutgoingAddress(HttpRequest * request, Comm::ConnectionPointer conn)
     for (l = Config.accessList.outgoing_address; l; l = l->next) {
 
         /* check if the outgoing address is usable to the destination */
-        if (conn->remote.IsIPv4() != l->addr.IsIPv4()) continue;
+        if (conn->remote.isIPv4() != l->addr.isIPv4()) continue;
 
         /* check ACLs for this outgoing address */
         if (!l->aclList || ch.fastCheck(l->aclList) == ACCESS_ALLOWED) {
@@ -1,7 +1,7 @@
 #ifndef SQUID_FORWARD_H
 #define SQUID_FORWARD_H
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "base/RefCount.h"
 #include "comm.h"
 #include "comm/Connection.h"
@@ -90,7 +90,7 @@ class FwdState : public RefCountable
     /// Process response from cert validator helper
     void sslCrtvdHandleReply(Ssl::CertValidationResponse const &);
     /// Check SSL errors returned from cert validator against sslproxy_cert_error access list
-    Ssl::Errors *sslCrtvdCheckForErrors(Ssl::CertValidationResponse const &, Ssl::ErrorDetail *&);
+    Ssl::CertErrors *sslCrtvdCheckForErrors(Ssl::CertValidationResponse const &, Ssl::ErrorDetail *&);
 #endif
 private:
     // hidden for safer management of self; use static fwdStart
@@ -120,7 +120,6 @@ class FwdState : public RefCountable
     Comm::ConnectionPointer clientConn;        ///< a possibly open connection to the client.
     time_t start_t;
     int n_tries;
-    int origin_tries;
 
     // AsyncCalls which we set and may need cancelling.
     struct {
@@ -145,16 +145,15 @@ HelperReply::parseResponseKeys()
         *p = '\0';
         ++p;
 
-        const String key(other().content());
+        const char *key = other().content();
 
         // the value may be a quoted string or a token
         const bool urlDecode = (*p != '"'); // check before moving p.
         char *v = strwordtok(NULL, &p);
         if (v != NULL && urlDecode && (p-v) > 2) // 1-octet %-escaped requires 3 bytes
             rfc1738_unescape(v);
-        const String value(v?v:""); // value can be empty, but must not be NULL
 
-        notes.add(key, value);
+        notes.add(key, v ? v : ""); // value can be empty, but must not be NULL
 
         modifiableOther().consume(p - other().content());
         modifiableOther().consumeWhitespacePrefix();
@@ -184,13 +183,9 @@ operator <<(std::ostream &os, const HelperReply &r)
     }
 
     // dump the helper key=pair "notes" list
-    if (r.notes.notes.size() > 0) {
+    if (!r.notes.empty()) {
         os << ", notes={";
-        for (Notes::NotesList::const_iterator m = r.notes.notes.begin(); m != r.notes.notes.end(); ++m) {
-            for (Note::Values::iterator v = (*m)->values.begin(); v != (*m)->values.end(); ++v) {
-                os << ',' << (*m)->key << '=' << ConfigParser::QuoteString((*v)->value);
-            }
-        }
+        os << r.notes.toString("; ");
         os << "}";
     }
 
@@ -65,7 +65,7 @@ class HelperReply
     } result;
 
     // list of key=value pairs the helper produced
-    Notes notes;
+    NotePairs notes;
 
     /// for stateful replies the responding helper 'server' needs to be preserved across callbacks
     CbcPointer<helper_stateful_server> whichServer;
@@ -194,15 +194,42 @@ HttpHdrCc::parse(const String & str)
             }
             break;
 
+        case CC_PRIVATE: {
+            String temp;
+            if (!p)  {
+                // Value parameter is optional.
+                private_.clean();
+            }            else if (/* p &&*/ httpHeaderParseQuotedString(p, (ilen-nlen-1), &temp)) {
+                private_.append(temp);
+            }            else {
+                debugs(65, 2, "cc: invalid private= specs near '" << item << "'");
+            }
+            // to be safe we ignore broken parameters, but always remember the 'private' part.
+            setMask(type,true);
+        }
+        break;
+
+        case CC_NO_CACHE: {
+            String temp;
+            if (!p) {
+                // On Requests, missing value parameter is expected syntax.
+                // On Responses, value parameter is optional.
+                setMask(type,true);
+                no_cache.clean();
+            } else if (/* p &&*/ httpHeaderParseQuotedString(p, (ilen-nlen-1), &temp)) {
+                // On Requests, a value parameter is invalid syntax.
+                // XXX: identify when parsing request header and dump err message here.
+                setMask(type,true);
+                no_cache.append(temp);
+            } else {
+                debugs(65, 2, "cc: invalid no-cache= specs near '" << item << "'");
+            }
+        }
+        break;
+
         case CC_PUBLIC:
             Public(true);
             break;
-        case CC_PRIVATE:
-            Private(true);
-            break;
-        case CC_NO_CACHE:
-            noCache(true);
-            break;
         case CC_NO_STORE:
             noStore(true);
             break;
@@ -74,15 +74,27 @@ class HttpHdrCc
 
     //manipulation for Cache-Control: private header
     bool hasPrivate() const {return isSet(CC_PRIVATE);}
-    bool Private() const {return isSet(CC_PRIVATE);}
-    void Private(bool v) {setMask(CC_PRIVATE,v);}
-    void clearPrivate() {setMask(CC_PRIVATE,false);}
+    const String &Private() const {return private_;}
+    void Private(String &v) {
+        setMask(CC_PRIVATE,true);
+        // uses append for multi-line headers
+        if (private_.defined())
+            private_.append(",");
+        private_.append(v);
+    }
+    void clearPrivate() {setMask(CC_PRIVATE,false); private_.clean();}
 
     //manipulation for Cache-Control: no-cache header
     bool hasNoCache() const {return isSet(CC_NO_CACHE);}
-    bool noCache() const {return isSet(CC_NO_CACHE);}
-    void noCache(bool v) {setMask(CC_NO_CACHE,v);}
-    void clearNoCache() {setMask(CC_NO_CACHE,false);}
+    const String &noCache() const {return no_cache;}
+    void noCache(String &v) {
+        setMask(CC_NO_CACHE,true);
+        // uses append for multi-line headers
+        if (no_cache.defined())
+            no_cache.append(",");
+        no_cache.append(v);
+    }
+    void clearNoCache() {setMask(CC_NO_CACHE,false); no_cache.clean();}
 
     //manipulation for Cache-Control: no-store header
     bool hasNoStore() const {return isSet(CC_NO_STORE);}
@@ -166,6 +178,9 @@ class HttpHdrCc
     int32_t max_stale;
     int32_t stale_if_error;
     int32_t min_fresh;
+    String private_; ///< List of headers sent as value for CC:private="...". May be empty/undefined if the value is missing.
+    String no_cache; ///< List of headers sent as value for CC:no-cache="...". May be empty/undefined if the value is missing.
+
     /// low-level part of the public set method, performs no checks
     _SQUID_INLINE_ void setMask(http_hdr_cc_type id, bool newval=true);
     _SQUID_INLINE_ void setValue(int32_t &value, int32_t new_value, http_hdr_cc_type hdr, bool setting=true);
@@ -32,7 +32,6 @@
 #ifndef SQUID_HTTPHDRSURROGATECONTROL_H
 #define SQUID_HTTPHDRSURROGATECONTROL_H
 
-#include "dlink.h"
 #include "HttpHdrScTarget.h"
 
 class StatHist;
@@ -112,6 +112,7 @@ static const HttpHeaderFieldAttrs HeadersAttrs[] = {
     {"If-None-Match", HDR_IF_NONE_MATCH, ftStr},	/* for now */
     {"If-Range", HDR_IF_RANGE, ftDate_1123_or_ETag},
     {"Keep-Alive", HDR_KEEP_ALIVE, ftStr},
+    {"Key", HDR_KEY, ftStr},
     {"Last-Modified", HDR_LAST_MODIFIED, ftDate_1123},
     {"Link", HDR_LINK, ftStr},
     {"Location", HDR_LOCATION, ftStr},
@@ -187,6 +188,7 @@ static http_hdr_type ListHeadersArr[] = {
     HDR_CONNECTION,
     HDR_EXPECT,
     HDR_IF_MATCH, HDR_IF_NONE_MATCH,
+    HDR_KEY,
     HDR_LINK, HDR_PRAGMA,
     HDR_PROXY_CONNECTION,
     HDR_PROXY_SUPPORT,
@@ -231,6 +233,7 @@ static HttpHeaderMask ReplyHeadersMask;		/* set run-time using ReplyHeaders */
 static http_hdr_type ReplyHeadersArr[] = {
     HDR_ACCEPT, HDR_ACCEPT_CHARSET, HDR_ACCEPT_ENCODING, HDR_ACCEPT_LANGUAGE,
     HDR_ACCEPT_RANGES, HDR_AGE,
+    HDR_KEY,
     HDR_LOCATION, HDR_MAX_FORWARDS,
     HDR_MIME_VERSION, HDR_PUBLIC, HDR_RETRY_AFTER, HDR_SERVER, HDR_SET_COOKIE, HDR_SET_COOKIE2,
     HDR_ORIGIN,
@@ -438,37 +441,37 @@ HttpHeader::clean()
 
     PROF_start(HttpHeaderClean);
 
-    /*
-     * An unfortunate bug.  The entries array is initialized
-     * such that count is set to zero.  httpHeaderClean() seems to
-     * be called both when 'hdr' is created, and destroyed.  Thus,
-     * we accumulate a large number of zero counts for 'hdr' before
-     * it is ever used.  Can't think of a good way to fix it, except
-     * adding a state variable that indicates whether or not 'hdr'
-     * has been used.  As a hack, just never count zero-sized header
-     * arrays.
-     */
-
     if (owner <= hoReply) {
+        /*
+         * An unfortunate bug.  The entries array is initialized
+         * such that count is set to zero.  httpHeaderClean() seems to
+         * be called both when 'hdr' is created, and destroyed.  Thus,
+         * we accumulate a large number of zero counts for 'hdr' before
+         * it is ever used.  Can't think of a good way to fix it, except
+         * adding a state variable that indicates whether or not 'hdr'
+         * has been used.  As a hack, just never count zero-sized header
+         * arrays.
+         */
         if (0 != entries.count)
             HttpHeaderStats[owner].hdrUCountDistr.count(entries.count);
 
         ++ HttpHeaderStats[owner].destroyedCount;
 
         HttpHeaderStats[owner].busyDestroyedCount += entries.count > 0;
+    } // if (owner <= hoReply)
 
-        while ((e = getEntry(&pos))) {
-            /* tmp hack to try to avoid coredumps */
+    while ((e = getEntry(&pos))) {
+        /* tmp hack to try to avoid coredumps */
 
-            if (e->id < 0 || e->id >= HDR_ENUM_END) {
-                debugs(55, DBG_CRITICAL, "HttpHeader::clean BUG: entry[" << pos << "] is invalid (" << e->id << "). Ignored.");
-            } else {
+        if (e->id < 0 || e->id >= HDR_ENUM_END) {
+            debugs(55, DBG_CRITICAL, "HttpHeader::clean BUG: entry[" << pos << "] is invalid (" << e->id << "). Ignored.");
+        } else {
+            if (owner <= hoReply)
                 HttpHeaderStats[owner].fieldTypeDistr.count(e->id);
-                /* yes, this deletion leaves us in an inconsistent state */
-                delete e;
-            }
+            /* yes, this deletion leaves us in an inconsistent state */
+            delete e;
         }
-    } // if (owner <= hoReply)
+    }
     entries.clean();
     httpHeaderMaskInit(&mask, 0);
     len = 0;
@@ -1738,6 +1741,7 @@ httpHeaderStatDump(const HttpHeaderStat * hs, StoreEntry * e)
     storeAppendPrintf(e, "%2s\t %-5s\t %5s\t %6s\n",
                       "id", "#flds", "count", "%total");
     hs->hdrUCountDistr.dump(e, httpHeaderFldsPerHdrDumper);
+    storeAppendPrintf(e, "\n");
     dump_stat = NULL;
 }
 
@@ -1759,7 +1763,6 @@ httpHeaderStoreReport(StoreEntry * e)
 
     for (i = 1; i < HttpHeaderStatCount; ++i) {
         httpHeaderStatDump(HttpHeaderStats + i, e);
-        storeAppendPrintf(e, "%s\n", "<br>");
     }
 
     /* field stats for all messages */
@@ -90,6 +90,7 @@ typedef enum {
     HDR_IF_RANGE,                       /**< RFC 2608, 2616 */
     /*HDR_IF_UNMODIFIED_SINCE,*/        /**< RFC 2608, 2616 */
     HDR_KEEP_ALIVE,                     /**< obsolete HTTP/1.0 header we may need to erase */
+    HDR_KEY,                            /**< experimental RFC Draft draft-fielding-http-key-02 */
     HDR_LAST_MODIFIED,                  /**< RFC 2608, 2616 */
     HDR_LINK,                           /**< RFC 2068 */
     HDR_LOCATION,                       /**< RFC 2608, 2616 */
@@ -175,7 +176,6 @@ typedef enum {
 #if USE_SSL
     hoErrorDetail,
 #endif
-    hoNote,
     hoEnd
 } http_hdr_owner_type;
 
@@ -32,7 +32,7 @@
 #ifndef SQUID_HTTPHEADERRANGE_H
 #define SQUID_HTTPHEADERRANGE_H
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "MemPool.h"
 #include "Packer.h"
 #include "Range.h"
@@ -1,10 +1,14 @@
 #ifndef SQUID_HTTPHEADERTOOLS_H
 #define SQUID_HTTPHEADERTOOLS_H
 
+#include "acl/forward.h"
 #include "format/Format.h"
 #include "HttpHeader.h"
 #include "typedefs.h"
 
+#if HAVE_FUNCTIONAL
+#include <functional>
+#endif
 #if HAVE_LIST
 #include <list>
 #endif
@@ -14,9 +18,10 @@
 #if HAVE_STRING
 #include <string>
 #endif
+#if HAVE_STRINGS_H
+#include <strings.h>
+#endif
 
-class acl_access;
-class ACLList;
 class HeaderWithAcl;
 class HttpHeader;
 class HttpHeaderFieldInfo;
@@ -56,8 +61,18 @@ class HeaderManglers
     void dumpReplacement(StoreEntry *entry, const char *optionName) const;
 
 private:
+    /// Case-insensitive std::string "less than" comparison functor.
+    /// Fast version recommended by Meyers' "Effective STL" for ASCII c-strings.
+    class NoCaseLessThan: public std::binary_function<std::string, std::string, bool>
+    {
+    public:
+        bool operator()(const std::string &lhs, const std::string &rhs) const {
+            return strcasecmp(lhs.c_str(), rhs.c_str()) < 0;
+        }
+    };
+
     /// a name:mangler map; optimize: use unordered map or some such
-    typedef std::map<std::string, headerMangler> ManglersByName;
+    typedef std::map<std::string, headerMangler, NoCaseLessThan> ManglersByName;
 
     /// one mangler for each known header
     headerMangler known[HDR_ENUM_END];
@@ -37,7 +37,6 @@
 #include "HttpRequestMethod.h"
 #include "http/StatusCode.h"
 #include "http/ProtocolVersion.h"
-#include "typedefs.h"
 
 /// common parts of HttpRequest and HttpReply
 class HttpMsg : public RefCountable
@@ -58,15 +58,13 @@
 #endif
 
 HttpRequest::HttpRequest() :
-        HttpMsg(hoRequest),
-        helperNotes(NULL)
+        HttpMsg(hoRequest)
 {
     init();
 }
 
 HttpRequest::HttpRequest(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath) :
-        HttpMsg(hoRequest),
-        helperNotes(NULL)
+        HttpMsg(hoRequest)
 {
     static unsigned int id = 1;
     debugs(93,7, HERE << "constructed, this=" << this << " id=" << ++id);
@@ -107,8 +105,8 @@ HttpRequest::init()
     ims = -1;
     imslen = 0;
     lastmod = -1;
-    client_addr.SetEmpty();
-    my_addr.SetEmpty();
+    client_addr.setEmpty();
+    my_addr.setEmpty();
     body_pipe = NULL;
     // hier
     dnsWait = -1;
@@ -128,7 +126,7 @@ HttpRequest::init()
     extacl_message = null_string;
     pstate = psReadyToParseStartLine;
 #if FOLLOW_X_FORWARDED_FOR
-    indirect_client_addr.SetEmpty();
+    indirect_client_addr.setEmpty();
 #endif /* FOLLOW_X_FORWARDED_FOR */
 #if USE_ADAPTATION
     adaptHistory_ = NULL;
@@ -168,10 +166,7 @@ HttpRequest::clean()
 
     myportname.clean();
 
-    if (helperNotes) {
-        delete helperNotes;
-        helperNotes = NULL;
-    }
+    notes = NULL;
 
     tag.clean();
 #if USE_AUTH
@@ -182,6 +177,8 @@ HttpRequest::clean()
 
     extacl_message.clean();
 
+    etag.clean();
+
 #if USE_ADAPTATION
     adaptHistory_ = NULL;
 #endif
@@ -227,23 +224,17 @@ HttpRequest::clone() const
     // XXX: what to do with copy->peer_login?
 
     copy->lastmod = lastmod;
+    copy->etag = etag;
     copy->vary_headers = vary_headers ? xstrdup(vary_headers) : NULL;
     // XXX: what to do with copy->peer_domain?
 
     copy->myportname = myportname;
-    if (helperNotes) {
-        copy->helperNotes = new Notes;
-        copy->helperNotes->notes = helperNotes->notes;
-    }
     copy->tag = tag;
-#if USE_AUTH
-    copy->extacl_user = extacl_user;
-    copy->extacl_passwd = extacl_passwd;
-#endif
     copy->extacl_log = extacl_log;
     copy->extacl_message = extacl_message;
 
-    assert(copy->inheritProperties(this));
+    const bool inheritWorked = copy->inheritProperties(this);
+    assert(inheritWorked);
 
     return copy;
 }
@@ -278,11 +269,14 @@ HttpRequest::inheritProperties(const HttpMsg *aMsg)
     errDetail = aReq->errDetail;
 #if USE_AUTH
     auth_user_request = aReq->auth_user_request;
+    extacl_user = aReq->extacl_user;
+    extacl_passwd = aReq->extacl_passwd;
 #endif
 
     // main property is which connection the request was received on (if any)
     clientConnectionManager = aReq->clientConnectionManager;
 
+    notes = aReq->notes;
     return true;
 }
 
@@ -596,7 +590,7 @@ HttpRequest::maybeCacheable()
     // Because it failed verification, or someone bypassed the security tests
     // we cannot cache the reponse for sharing between clients.
     // TODO: update cache to store for particular clients only (going to same Host: and destination IP)
-    if (!flags.hostVerified && (flags.intercepted || flags.spoofClientIp))
+    if (!flags.hostVerified && (flags.intercepted || flags.interceptTproxy))
         return false;
 
     switch (protocol) {
@@ -93,13 +93,13 @@ class HttpRequest: public HttpMsg
     /*      caused by HttpRequest being used in places it really shouldn't.        */
     /*      ideally they would be methods of URL instead. */
     inline void SetHost(const char *src) {
-        host_addr.SetEmpty();
+        host_addr.setEmpty();
         host_addr = src;
-        if ( host_addr.IsAnyAddr() ) {
+        if (host_addr.isAnyAddr()) {
             xstrncpy(host, src, SQUIDHOSTNAMELEN);
             host_is_numeric = 0;
         } else {
-            host_addr.ToHostname(host, SQUIDHOSTNAMELEN);
+            host_addr.toHostStr(host, SQUIDHOSTNAMELEN);
             debugs(23, 3, "HttpRequest::SetHost() given IP: " << host_addr);
             host_is_numeric = 1;
         }
@@ -203,7 +203,7 @@ class HttpRequest: public HttpMsg
 
     String myportname; // Internal tag name= value from port this requests arrived in.
 
-    Notes *helperNotes;         ///< collection of meta notes associated with this request by helper lookups.
+    NotePairs::Pointer notes; ///< annotations added by the note directive and helpers
 
     String tag;			/* Internal tag for this request */
 
@@ -219,6 +219,9 @@ class HttpRequest: public HttpMsg
     String x_forwarded_for_iterator; /* XXX a list of IP addresses */
 #endif /* FOLLOW_X_FORWARDED_FOR */
 
+    /// A strong etag of the cached entry. Used for refreshing that entry.
+    String etag;
+
 public:
     bool multipartRangeRequest() const;
 
@@ -80,7 +80,7 @@ if USE_ESI
 SUBDIRS += esi
 ESI_LOCAL_LIBS = \
 	esi/libesi.la \
-	$(top_builddir)/lib/libTrie/src/libTrie.a
+	$(top_builddir)/lib/libTrie/libTrie.a
 ESI_LIBS = $(ESI_LOCAL_LIBS) \
 	$(XMLLIB) \
 	$(EXPATLIB)
@@ -351,12 +351,12 @@ squid_SOURCES = \
 	fde.h \
 	FileMap.h \
 	filemap.cc \
-	forward.cc \
-	forward.h \
 	fqdncache.h \
 	fqdncache.cc \
 	ftp.h \
 	ftp.cc \
+	FwdState.cc \
+	FwdState.h \
 	Generic.h \
 	globals.h \
 	gopher.h \
@@ -424,6 +424,8 @@ squid_SOURCES = \
 	LogTags.h \
 	lookup_t.h \
 	main.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	Mem.h \
 	mem.cc \
 	mem_node.cc \
@@ -619,7 +621,6 @@ squid_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	$(DISK_LIBS) \
@@ -983,7 +984,7 @@ test_cache_digest: test_cache_digest.o CacheDigest.o debug.o globals.o store_key
 cache_cf.o: cf_parser.cci
 
 # cf_gen builds the configuration files.
-cf_gen$(EXEEXT): $(cf_gen_SOURCES) $(cf_gen_DEPENDENCIES)
+cf_gen$(EXEEXT): $(cf_gen_SOURCES) $(cf_gen_DEPENDENCIES) cf_gen_defines.cci
 	$(HOSTCXX) -o $@ $(srcdir)/cf_gen.cc -I$(srcdir) -I$(top_builddir)/include/ -I$(top_builddir)/src
 
 # squid.conf.default is built by cf_gen when making cf_parser.cci
@@ -993,7 +994,9 @@ squid.conf.default squid.conf.documented: cf_parser.cci
 cf_parser.cci: cf.data cf_gen$(EXEEXT)
 	./cf_gen$(EXEEXT) cf.data $(srcdir)/cf.data.depend
 
-cf_gen_defines.cci: $(srcdir)/cf_gen_defines $(srcdir)/cf.data.pre
+# The cf_gen_defines.cci is auto-generated and does not exist when the 
+# dependencies computed. We need to add its include files (autoconf.h) here
+cf_gen_defines.cci: $(srcdir)/cf_gen_defines $(srcdir)/cf.data.pre $(top_builddir)/include/autoconf.h
 	$(AWK) -f $(srcdir)/cf_gen_defines <$(srcdir)/cf.data.pre >$@ || ($(RM) -f $@ && exit 1)
 
 
@@ -1094,6 +1097,7 @@ check_PROGRAMS+=\
 	tests/testURL \
 	tests/testConfigParser \
 	tests/testStatHist \
+	tests/testVector \
 	$(STORE_TESTS)
 
 ## NP: required to run the above list. check_PROGRAMS only builds the binaries...
@@ -1253,6 +1257,8 @@ tests_testACLMaxUserIP_SOURCES= \
 	HttpRequestMethod.cc \
 	int.h \
 	int.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	SquidList.h \
 	SquidList.cc \
 	mem_node.cc \
@@ -1288,6 +1294,7 @@ tests_testACLMaxUserIP_SOURCES= \
 	cache_cf.h \
 	YesNoNone.h \
 	tests/stub_cache_cf.cc \
+	tests/stub_client_side.cc \
 	tests/stub_debug.cc \
 	tests/stub_DelayId.cc \
 	tests/stub_DiskIOModule.cc \
@@ -1445,11 +1452,12 @@ tests_testCacheManager_SOURCES = \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
-	forward.cc \
 	fqdncache.h \
 	fqdncache.cc \
 	ftp.h \
 	ftp.cc \
+	FwdState.cc \
+	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	hier_code.h \
@@ -1488,9 +1496,12 @@ tests_testCacheManager_SOURCES = \
 	internal.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	multicast.h \
 	multicast.cc \
 	mem_node.cc \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
@@ -1586,7 +1597,6 @@ tests_testCacheManager_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
@@ -1595,6 +1605,7 @@ tests_testCacheManager_LDADD = \
 	ip/libip.la \
 	fs/libfs.la \
 	comm/libcomm.la \
+	eui/libeui.la \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	log/liblog.la \
 	format/libformat.la \
@@ -1668,6 +1679,8 @@ tests_testDiskIO_SOURCES = \
 	int.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	MemBuf.cc \
 	MemObject.cc \
 	mem_node.cc \
@@ -1728,6 +1741,7 @@ tests_testDiskIO_SOURCES = \
 	tests/stub_internal.cc \
 	tests/stub_ipc.cc \
 	tests/stub_ipcache.cc \
+	tests/stub_libeui.cc \
 	tests/stub_libformat.cc \
 	tests/stub_libicmp.cc \
 	tests/stub_MemStore.cc \
@@ -1768,7 +1782,6 @@ tests_testDiskIO_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	libsquid.la \
@@ -1855,11 +1868,12 @@ tests_testEvent_SOURCES = \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
-	forward.cc \
 	fqdncache.h \
 	fqdncache.cc \
 	ftp.h \
 	ftp.cc \
+	FwdState.cc \
+	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
@@ -1903,9 +1917,12 @@ tests_testEvent_SOURCES = \
 	internal.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	Mem.h \
 	mem.cc \
 	mem_node.cc \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
@@ -1983,6 +2000,7 @@ tests_testEvent_SOURCES = \
 	tests/testMain.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_ipc_Forwarder.cc \
+	tests/stub_libeui.cc \
 	tests/stub_store_stats.cc \
 	time.cc \
 	tools.h \
@@ -2010,7 +2028,6 @@ tests_testEvent_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
@@ -2102,11 +2119,12 @@ tests_testEventLoop_SOURCES = \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
-	forward.cc \
 	fqdncache.h \
 	fqdncache.cc \
 	ftp.h \
 	ftp.cc \
+	FwdState.cc \
+	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
@@ -2150,6 +2168,9 @@ tests_testEventLoop_SOURCES = \
 	internal.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	Mem.h \
@@ -2230,6 +2251,7 @@ tests_testEventLoop_SOURCES = \
 	tests/testMain.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_ipc_Forwarder.cc \
+	tests/stub_libeui.cc \
 	tests/stub_store_stats.cc \
 	time.cc \
 	tools.h \
@@ -2257,7 +2279,6 @@ tests_testEventLoop_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
@@ -2346,11 +2367,12 @@ tests_test_http_range_SOURCES = \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
-	forward.cc \
 	fqdncache.h \
 	fqdncache.cc \
 	ftp.h \
 	ftp.cc \
+	FwdState.cc \
+	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
@@ -2394,6 +2416,9 @@ tests_test_http_range_SOURCES = \
 	ipcache.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	Mem.h \
@@ -2470,6 +2495,7 @@ tests_test_http_range_SOURCES = \
 	SwapDir.cc \
 	tests/test_http_range.cc \
 	tests/stub_ipc_Forwarder.cc \
+	tests/stub_libeui.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_MemStore.cc \
 	tests/stub_store_stats.cc \
@@ -2497,7 +2523,6 @@ tests_test_http_range_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
@@ -2594,6 +2619,7 @@ tests_testHttpRequest_SOURCES = \
 	tests/stub_DiskIOModule.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_ipc_Forwarder.cc \
+	tests/stub_libeui.cc \
 	tests/stub_store_stats.cc \
 	time.cc \
 	BodyPipe.cc \
@@ -2640,11 +2666,12 @@ tests_testHttpRequest_SOURCES = \
 	fd.h \
 	fd.cc \
 	fde.cc \
-	forward.cc \
 	fqdncache.h \
 	fqdncache.cc \
 	ftp.h \
 	ftp.cc \
+	FwdState.cc \
+	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
@@ -2682,9 +2709,12 @@ tests_testHttpRequest_SOURCES = \
 	internal.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	multicast.h \
 	multicast.cc \
 	mem_node.cc \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
@@ -2777,7 +2807,6 @@ tests_testHttpRequest_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
@@ -2856,6 +2885,8 @@ tests_testStore_SOURCES= \
 	int.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	Mem.h \
 	mem.cc \
 	mem_node.cc \
@@ -2910,6 +2941,7 @@ tests_testStore_SOURCES= \
 	tests/stub_helper.cc \
 	tests/stub_HelperChildConfig.cc \
 	tests/stub_http.cc \
+	tests/stub_libeui.cc \
 	tests/stub_libformat.cc \
 	HttpBody.h \
 	HttpBody.cc \
@@ -2958,7 +2990,6 @@ tests_testStore_LDADD= \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
@@ -3029,7 +3060,6 @@ SWAP_TEST_DS =\
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
@@ -3051,6 +3081,7 @@ tests_testUfs_SOURCES = \
 	tests/stub_HelperChildConfig.cc \
 	tests/stub_icp.cc \
 	tests/stub_ipc.cc \
+	tests/stub_libeui.cc \
 	tests/stub_MemStore.cc \
 	tests/stub_pconn.cc \
 	tests/stub_Port.cc \
@@ -3081,6 +3112,8 @@ tests_testUfs_SOURCES = \
 	RequestFlags.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	MemObject.cc \
 	StoreSwapLogData.cc \
 	StoreIOState.cc \
@@ -3184,7 +3217,6 @@ tests_testUfs_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
@@ -3266,9 +3298,11 @@ tests_testRock_SOURCES = \
 	HttpRequestMethod.cc \
 	int.h \
 	int.cc \
+	$(SBUF_SOURCE) \
 	SquidList.h \
 	SquidList.cc \
-	$(SBUF_SOURCE) \
+	MasterXaction.cc \
+	MasterXaction.h \
 	Mem.h \
 	mem.cc \
 	MemBuf.cc \
@@ -3328,6 +3362,7 @@ tests_testRock_SOURCES = \
 	tests/stub_icp.cc \
 	tests/stub_ipc.cc \
 	tests/stub_ipcache.cc \
+	tests/stub_libeui.cc \
 	tests/stub_libformat.cc \
 	tests/stub_libicmp.cc \
 	tests/stub_MemStore.cc \
@@ -3370,7 +3405,6 @@ tests_testRock_LDADD = \
 	acl/libacls.la \
 	acl/libapi.la \
 	acl/libstate.la \
-	eui/libeui.la \
 	ipc/libipc.la \
 	mgr/libmgr.la \
 	base/libbase.la \
@@ -3399,6 +3433,7 @@ tests_testCoss_SOURCES = \
 	internal.h \
 	tests/stub_internal.cc \
 	tests/stub_ipc.cc \
+	tests/stub_libeui.cc \
 	tests/stub_pconn.cc \
 	store_rebuild.h \
 	tests/stub_store_rebuild.cc \
@@ -3522,7 +3557,6 @@ tests_testCoss_LDADD = \
 	$(AUTH_ACL_LIBS) \
 	ident/libident.la \
 	acl/libacls.la \
-	eui/libeui.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
 	acl/libapi.la \
@@ -3604,11 +3638,12 @@ tests_testURL_SOURCES = \
 	fde.cc \
 	FileMap.h \
 	filemap.cc \
-	forward.cc \
 	fqdncache.h \
 	fqdncache.cc \
 	ftp.h \
 	ftp.cc \
+	FwdState.cc \
+	FwdState.h \
 	gopher.h \
 	gopher.cc \
 	helper.cc \
@@ -3652,11 +3687,14 @@ tests_testURL_SOURCES = \
 	internal.cc \
 	SquidList.h \
 	SquidList.cc \
+	MasterXaction.cc \
+	MasterXaction.h \
 	multicast.h \
 	multicast.cc \
 	Mem.h \
 	mem.cc \
 	mem_node.cc \
+	MemBlob.cc \
 	MemBuf.cc \
 	MemObject.cc \
 	mime.h \
@@ -3878,6 +3916,21 @@ tests_testStatHist_LDADD = \
 	$(COMPAT_LIB)
 tests_testStatHist_DEPENDENCIES = $(SQUID_CPPUNIT_LA)
 
+tests_testVector_SOURCES = \
+	tests/testVector.cc \
+	tests/testMain.cc \
+	tests/testVector.h \
+	time.cc
+nodist_tests_testVector_SOURCES = \
+	$(TESTSOURCES)
+tests_testVector_LDADD= \
+	$(SQUID_CPPUNIT_LIBS) \
+	$(COMPAT_LIB) \
+	$(XTRA_LIBS)
+tests_testVector_LDFLAGS = $(LIBADD_DL)
+tests_testVector_DEPENDENCIES = \
+	$(SQUID_CPPUNIT_LA)
+
 
 TESTS += testHeaders
 
@@ -0,0 +1,4 @@
+#include "squid.h"
+#include "MasterXaction.h"
+
+InstanceIdDefinitions(MasterXaction, "MXID_");
@@ -0,0 +1,46 @@
+#ifndef SQUID_SRC_MASTERXACTION_H
+#define SQUID_SRC_MASTERXACTION_H
+
+#include "anyp/forward.h"
+#include "base/CbcPointer.h"
+#include "base/InstanceId.h"
+#include "base/Lock.h"
+#include "comm/forward.h"
+
+/** Master transaction details.
+ *
+ * Aggregates historical data from individual related protocol-specific
+ * transactions such as an HTTP client transaction and the corresponding
+ * HTTP or FTP server transaction.
+ *
+ * Individual transaction information worth sending or logging should be
+ * recorded here, ideally without exposing other master transaction users
+ * to internal details of individual transactions. For example, storing an
+ * HTTP client IP address is a good idea but storing a pointer to some
+ * client-side job which maintains that address is not.
+ *
+ * A master transaction is created by a newly accepted client connection,
+ * a new request on the existing client connection, or an internal request
+ * generated by Squid. All client-side protocols, including HTTP, HTCP, ICP,
+ * and SNMP will eventually create master transactions.
+ *
+ * A master transaction is auto-destroyed when its last user is gone.
+ */
+class MasterXaction : public RefCountable
+{
+public:
+    typedef RefCount<MasterXaction> Pointer;
+
+    /// transaction ID.
+    InstanceId<MasterXaction> id;
+
+    /// the listening port which originated this transaction
+    AnyP::PortCfgPointer squidPort;
+
+    /// the client TCP connection which originated this transaction
+    Comm::ConnectionPointer tcpClient;
+
+    // TODO: add state from other Jobs in the transaction
+};
+
+#endif /* SQUID_SRC_MASTERXACTION_H */
@@ -62,9 +62,14 @@ class MemBuf
      */
     bool hasContent() const { return size > 0; }
 
-    /// these space-related methods assume no growth and allow 0-termination
-    char *space() { return buf + size; } // space to add data
-    char *space(mb_size_t required) { if (size + required > capacity) grow(size + required); return buf + size; } // space to add data
+    /// returns buffer after data; does not check space existence
+    char *space() { return buf + size; } ///< space to add data
+
+    /// Returns buffer following data, after possibly growing the buffer to
+    /// accommodate addition of the required bytes PLUS a 0-terminator char.
+    /// The caller is not required to terminate the buffer, but MemBuf does
+    /// terminate internally, trading termination for size calculation bugs.
+    char *space(mb_size_t required) { if (size + required >= capacity) grow(size + required + 1); return buf + size; }
 
     mb_size_t spaceSize() const;
 
@@ -29,13 +29,15 @@
 
 #include "squid.h"
 #include "globals.h"
+#include "AccessLogEntry.h"
 #include "acl/FilledChecklist.h"
 #include "acl/Gadgets.h"
 #include "ConfigParser.h"
 #include "HttpRequest.h"
 #include "HttpReply.h"
 #include "SquidConfig.h"
 #include "Store.h"
+#include "StrList.h"
 
 #include <algorithm>
 #include <string>
@@ -74,59 +76,19 @@ Note::match(HttpRequest *request, HttpReply *reply)
 }
 
 Note::Pointer
-Notes::find(const String &noteKey) const
+Notes::add(const String &noteKey)
 {
-    typedef Notes::NotesList::const_iterator AMLI;
+    typedef Notes::NotesList::iterator AMLI;
     for (AMLI i = notes.begin(); i != notes.end(); ++i) {
         if ((*i)->key == noteKey)
             return (*i);
     }
 
-    return Note::Pointer();
-}
-
-void
-Notes::add(const String &noteKey, const String &noteValue)
-{
-    Note::Pointer key = add(noteKey);
-    key->addValue(noteValue);
-}
-
-Note::Pointer
-Notes::add(const String &noteKey)
-{
-    Note::Pointer note = find(noteKey);
-    if (note == NULL) {
-        note = new Note(noteKey);
-        notes.push_back(note);
-    }
+    Note::Pointer note = new Note(noteKey);
+    notes.push_back(note);
     return note;
 }
 
-void
-Notes::add(const Notes &src)
-{
-    typedef Notes::NotesList::const_iterator AMLI;
-    typedef Note::Values::iterator VLI;
-
-    for (AMLI i = src.notes.begin(); i != src.notes.end(); ++i) {
-
-        // ensure we have a key by that name to fill out values for...
-        // NP: not sharing pointers at the key level since merging other helpers
-        // details later would affect this src objects keys, which is a bad idea.
-        Note::Pointer ourKey = add((*i)->key);
-
-        // known key names, merge the values lists...
-        for (VLI v = (*i)->values.begin(); v != (*i)->values.end(); ++v ) {
-            // 2012-11-29: values are read-only and Pointer can safely be shared
-            // for now we share pointers to save memory and gain speed.
-            // If that ever ceases to be true, convert this to a full copy.
-            ourKey->values.push_back(*v);
-            // TODO: prune/skip duplicates ?
-        }
-    }
-}
-
 Note::Pointer
 Notes::parse(ConfigParser &parser)
 {
@@ -135,7 +97,11 @@ Notes::parse(ConfigParser &parser)
     ConfigParser::ParseQuotedString(&value);
     Note::Pointer note = add(key);
     Note::Value::Pointer noteValue = note->addValue(value);
-    aclParseAclList(parser, &noteValue->aclList);
+
+    String label(key);
+    label.append('=');
+    label.append(value);
+    aclParseAclList(parser, &noteValue->aclList, label.termedBuf());
 
     if (blacklisted) {
         for (int i = 0; blacklisted[i] != NULL; ++i) {
@@ -170,3 +136,98 @@ Notes::clean()
 {
     notes.clean();
 }
+
+NotePairs::~NotePairs()
+{
+    while (!entries.empty())
+        delete entries.pop_back();
+}
+
+const char *
+NotePairs::find(const char *noteKey) const
+{
+    static String value;
+    value.clean();
+    for (Vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
+        if ((*i)->name.cmp(noteKey) == 0) {
+            if (value.size())
+                value.append(", ");
+            value.append(ConfigParser::QuoteString((*i)->value));
+        }
+    }
+    return value.size() ? value.termedBuf() : NULL;
+}
+
+const char *
+NotePairs::toString(const char *sep) const
+{
+    static String value;
+    value.clean();
+    for (Vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
+        value.append((*i)->name);
+        value.append(": ");
+        value.append(ConfigParser::QuoteString((*i)->value));
+        value.append(sep);
+    }
+    return value.size() ? value.termedBuf() : NULL;
+}
+
+const char *
+NotePairs::findFirst(const char *noteKey) const
+{
+    for (Vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
+        if ((*i)->name.cmp(noteKey) == 0)
+            return (*i)->value.termedBuf();
+    }
+    return NULL;
+}
+
+void
+NotePairs::add(const char *key, const char *note)
+{
+    entries.push_back(new NotePairs::Entry(key, note));
+}
+
+void
+NotePairs::addStrList(const char *key, const char *values)
+{
+    String strValues(values);
+    const char *item;
+    const char *pos = NULL;
+    int ilen = 0;
+    while (strListGetItem(&strValues, ',', &item, &ilen, &pos)) {
+        String v;
+        v.append(item, ilen);
+        entries.push_back(new NotePairs::Entry(key, v.termedBuf()));
+    }
+}
+
+bool
+NotePairs::hasPair(const char *key, const char *value) const
+{
+    for (Vector<NotePairs::Entry *>::const_iterator  i = entries.begin(); i != entries.end(); ++i) {
+        if ((*i)->name.cmp(key) == 0 || (*i)->value.cmp(value) == 0)
+            return true;
+    }
+    return false;
+}
+
+void
+NotePairs::append(const NotePairs *src)
+{
+    for (Vector<NotePairs::Entry *>::const_iterator  i = src->entries.begin(); i != src->entries.end(); ++i) {
+        entries.push_back(new NotePairs::Entry((*i)->name.termedBuf(), (*i)->value.termedBuf()));
+    }
+}
+
+NotePairs &
+SyncNotes(AccessLogEntry &ale, HttpRequest &request)
+{
+    if (!ale.notes) {
+        assert(!request.notes);
+        ale.notes = request.notes = new NotePairs;
+    } else {
+        assert(ale.notes == request.notes);
+    }
+    return *ale.notes;
+}
@@ -1,8 +1,12 @@
 #ifndef SQUID_NOTES_H
 #define SQUID_NOTES_H
 
-#include "HttpHeader.h"
-#include "HttpHeaderTools.h"
+#include "acl/forward.h"
+#include "base/Vector.h"
+#include "base/RefCount.h"
+#include "CbDataList.h"
+#include "MemPool.h"
+#include "SquidString.h"
 #include "typedefs.h"
 
 #if HAVE_STRING
@@ -13,10 +17,10 @@ class HttpRequest;
 class HttpReply;
 
 /**
- * Used to store notes. The notes are custom key:value pairs
- * ICAP request headers or ECAP options used to pass
+ * Used to store a note configuration. The notes are custom key:value
+ * pairs ICAP request headers or ECAP options used to pass
  * custom transaction-state related meta information to squid
- * internal subsystems or to addaptation services.
+ * internal subsystems or to adaptation services.
  */
 class Note: public RefCountable
 {
@@ -49,18 +53,13 @@ class Note: public RefCountable
      */
     const char *match(HttpRequest *request, HttpReply *reply);
 
-    /**
-     * Returns the first value for this key or an empty string.
-     */
-    const char *firstValue() const { return (values.size()>0&&values[0]->value.defined()?values[0]->value.termedBuf():""); }
-
     String key; ///< The note key
     Values values; ///< The possible values list for the note
 };
 
 class ConfigParser;
 /**
- * Used to store a notes list.
+ * Used to store a notes configuration list.
  */
 class Notes
 {
@@ -90,29 +89,6 @@ class Notes
     /// return true if the notes list is empty
     bool empty() { return notes.empty(); }
 
-    /**
-     * Adds a note key and value to the notes list.
-     * If the key name already exists in list, add the given value to its set of values.
-     */
-    void add(const String &noteKey, const String &noteValue);
-
-    /**
-     * Adds a set of notes from another notes list to this set.
-     * Creating entries for any new keys needed.
-     * If the key name already exists in list, add the given value to its set of values.
-     *
-     * WARNING:
-     * The list entries are all of shared Pointer type. Altering the src object(s) after
-     * using this function will update both Notes lists. Likewise, altering this
-     * destination NotesList will affect any relevant copies of src still in use.
-     */
-    void add(const Notes &src);
-
-    /**
-     * Returns a pointer to an existing Note with given key name or nil.
-     */
-    Note::Pointer find(const String &noteKey) const;
-
     NotesList notes; ///< The Note::Pointer objects array list
     const char *descr; ///< A short description for notes list
     const char **blacklisted; ///< Null terminated list of blacklisted note keys
@@ -126,22 +102,88 @@ class Notes
     Note::Pointer add(const String &noteKey);
 };
 
-class NotePairs : public HttpHeader
+/**
+ * Used to store list of notes
+ */
+class NotePairs: public RefCountable
 {
 public:
-    NotePairs() : HttpHeader(hoNote) {}
-
-    /// convert a NotesList into a NotesPairs
-    /// appending to any existing entries already present
-    void append(const Notes::NotesList &src) {
-        for (Notes::NotesList::const_iterator m = src.begin(); m != src.end(); ++m)
-            for (Note::Values::iterator v =(*m)->values.begin(); v != (*m)->values.end(); ++v)
-                putExt((*m)->key.termedBuf(), (*v)->value.termedBuf());
-    }
-
-    void append(const NotePairs *src) {
-        HttpHeader::append(dynamic_cast<const HttpHeader*>(src));
-    }
+    typedef RefCount<NotePairs> Pointer;
+
+    /**
+     * Used to store a note key/value pair.
+     */
+    class Entry
+    {
+    public:
+        Entry(const char *aKey, const char *aValue): name(aKey), value(aValue) {}
+        String name;
+        String value;
+        MEMPROXY_CLASS(Entry);
+    };
+
+    NotePairs() {}
+    ~NotePairs();
+
+    /**
+     * Append the entries of the src NotePairs list to our list.
+     */
+    void append(const NotePairs *src);
+
+    /**
+     * Returns a comma separated list of notes with key 'noteKey'.
+     * Use findFirst instead when a unique kv-pair is needed.
+     */
+    const char *find(const char *noteKey) const;
+
+    /**
+     * Returns the first note value for this key or an empty string.
+     */
+    const char *findFirst(const char *noteKey) const;
+
+    /**
+     * Adds a note key and value to the notes list.
+     * If the key name already exists in list, add the given value to its set
+     * of values.
+     */
+    void add(const char *key, const char *value);
+
+    /**
+     * Adds a note key and values strList to the notes list.
+     * If the key name already exists in list, add the new values to its set
+     * of values.
+     */
+    void addStrList(const char *key, const char *values);
+
+    /**
+     * Return true if the key/value pair is already stored
+     */
+    bool hasPair(const char *key, const char *value) const;
+
+    /**
+     * Convert NotePairs list to a string consist of "Key: Value"
+     * entries separated by sep string.
+     */
+    const char *toString(const char *sep = "\r\n") const;
+
+    /**
+     * True if there are not entries in the list
+     */
+    bool empty() const {return entries.empty();}
+
+    Vector<NotePairs::Entry *> entries;	  ///< The key/value pair entries
+
+private:
+    NotePairs &operator = (NotePairs const &); // Not implemented
+    NotePairs(NotePairs const &); // Not implemented
 };
 
+MEMPROXY_CLASS_INLINE(NotePairs::Entry);
+
+class AccessLogEntry;
+/**
+ * Keep in sync HttpRequest and the corresponding AccessLogEntry objects
+ */
+NotePairs &SyncNotes(AccessLogEntry &ale, HttpRequest &request);
+
 #endif
@@ -33,6 +33,7 @@
 #include "squid.h"
 #include "cache_cf.h"
 #include "compat/strtoll.h"
+#include "ConfigParser.h"
 #include "Parsing.h"
 #include "globals.h"
 #include "Debug.h"
@@ -75,9 +76,9 @@ xatoi(const char *token)
 }
 
 unsigned int
-xatoui(const char *token)
+xatoui(const char *token, char eov)
 {
-    int64_t input = xatoll(token, 10);
+    int64_t input = xatoll(token, 10, eov);
     if (input < 0) {
         debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: The input value '" << token << "' cannot be less than 0.");
         self_destruct();
@@ -107,7 +108,7 @@ xatol(const char *token)
 }
 
 int64_t
-xatoll(const char *token, int base)
+xatoll(const char *token, int base, char eov)
 {
     char *end = NULL;
     int64_t ret = strtoll(token, &end, base);
@@ -117,7 +118,7 @@ xatoll(const char *token, int base)
         self_destruct();
     }
 
-    if (*end) {
+    if (*end != eov) {
         debugs(0, DBG_PARSE_NOTE(DBG_IMPORTANT), "ERROR: Invalid value: '" << token << "' is supposed to be a number.");
         self_destruct();
     }
@@ -161,7 +162,7 @@ GetInteger64(void)
 int
 GetInteger(void)
 {
-    char *token = strtok(NULL, w_space);
+    char *token = ConfigParser::strtokFile();
     int i;
 
     if (token == NULL)
@@ -301,14 +302,14 @@ GetHostWithPort(char *token, Ip::Address *ipa)
     }
 
     if (NULL == host)
-        ipa->SetAnyAddr();
+        ipa->setAnyAddr();
     else if ( ipa->GetHostByName(host) ) /* dont use ipcache. Accept either FQDN or IPA. */
         (void) 0;
     else
         return false;
 
     /* port MUST be set after the IPA lookup/conversion is performed. */
-    ipa->SetPort(port);
+    ipa->port(port);
 
     return true;
 }
@@ -38,9 +38,9 @@
 
 double xatof(const char *token);
 int xatoi(const char *token);
-unsigned int xatoui(const char *token);
+unsigned int xatoui(const char *token, char eov = '\0');
 long xatol(const char *token);
-int64_t xatoll(const char *token, int base);
+int64_t xatoll(const char *token, int base, char eov = '\0');
 unsigned short xatos(const char *token);
 
 /**
@@ -95,9 +95,6 @@ class PeerDigest
 {
 
 public:
-    void *operator new (size_t);
-    void operator delete(void *);
-
     CachePeer *peer;          /**< pointer back to peer structure, argh */
     CacheDigest *cd;            /**< actual digest structure */
     String host;                /**< copy of peer->host */
@@ -132,7 +129,7 @@ class PeerDigest
     } stats;
 
 private:
-    CBDATA_CLASS(PeerDigest);
+    CBDATA_CLASS2(PeerDigest);
 };
 
 extern const Version CacheDigestVer;
@@ -34,7 +34,7 @@
 #define   SQUID_PEERSELECTSTATE_H
 
 #include "acl/Checklist.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "cbdata.h"
 #include "comm/forward.h"
 #include "hier_code.h"
@@ -71,8 +71,8 @@ class ps_state
 {
 
 public:
-    void *operator new(size_t);
     ps_state();
+    ~ps_state();
 
     // Produce a URL for display identifying the transaction we are
     // trying to locate a peer for.
@@ -110,7 +110,7 @@ class ps_state
     ping_data ping;
     ACLChecklist *acl_checklist;
 private:
-    CBDATA_CLASS(ps_state);
+    CBDATA_CLASS2(ps_state);
 };
 
 #endif /* SQUID_PEERSELECTSTATE_H */
@@ -87,7 +87,11 @@ class RequestFlags
     bool intercepted :1;
     /** set if the Host: header passed verification */
     bool hostVerified :1;
-    /** request to spoof the client ip */
+    /// Set for requests handled by a "tproxy" port.
+    bool interceptTproxy :1;
+    /// The client IP address should be spoofed when connecting to the web server.
+    /// This applies to TPROXY traffic that has not had spoofing disabled through
+    /// the spoof_client_ip squid.conf ACL.
     bool spoofClientIp :1;
     /** set if the request is internal (\see ClientHttpRequest::flags.internal)*/
     bool internal :1;
@@ -32,11 +32,11 @@
 #ifndef SQUID_SERVER_H
 #define SQUID_SERVER_H
 
-#include "StoreIOBuffer.h"
-#include "forward.h"
 #include "BodyPipe.h"
 #include "base/AsyncJob.h"
 #include "CommCalls.h"
+#include "FwdState.h"
+#include "StoreIOBuffer.h"
 #if USE_ADAPTATION
 #include "adaptation/forward.h"
 #include "adaptation/Initiator.h"
@@ -29,7 +29,7 @@
  *
  */
 
-#include "acl/AclAddress.h"
+#include "acl/forward.h"
 #include "base/RefCount.h"
 #include "ClientDelayConfig.h"
 #include "DelayConfig.h"
@@ -46,9 +46,6 @@ class sslproxy_cert_sign;
 class sslproxy_cert_adapt;
 #endif
 
-class acl_access;
-class AclSizeLimit;
-class AclDenyInfoList;
 namespace Mgr
 {
 class ActionPasswordList;
@@ -332,7 +329,6 @@ class SquidConfig
 
         int ie_refresh;
         int vary_ignore_expire;
-        int pipeline_prefetch;
         int surrogate_is_remote;
         int request_entities;
         int detect_broken_server_pconns;
@@ -362,6 +358,8 @@ class SquidConfig
         int client_dst_passthru;
     } onoff;
 
+    int pipeline_max_prefetch;
+
     int forward_max_tries;
     int connect_retries;
 
@@ -376,7 +374,7 @@ class SquidConfig
         acl_access *AlwaysDirect;
         acl_access *ASlists;
         acl_access *noCache;
-        acl_access *log;
+        acl_access *stats_collection;
 #if SQUID_SNMP
 
         acl_access *snmp;
@@ -401,9 +399,9 @@ class SquidConfig
         acl_access *followXFF;
 #endif /* FOLLOW_X_FORWARDED_FOR */
 
-#if ICAP_CLIENT
-        acl_access* icap;
-#endif
+        /// spoof_client_ip squid.conf acl.
+        /// nil unless configured
+        acl_access* spoof_client_ip;
     } accessList;
     AclDenyInfoList *denyInfoList;
 
@@ -144,6 +144,8 @@ class StoreEntry : public hash_link
     bool hasIfMatchEtag(const HttpRequest &request) const;
     /// has ETag matching at least one of the If-None-Match etags
     bool hasIfNoneMatchEtag(const HttpRequest &request) const;
+    /// whether this entry has an ETag; if yes, puts ETag value into parameter
+    bool hasEtag(ETag &etag) const;
 
     /** What store does this entry belong too ? */
     virtual RefCount<SwapDir> store() const;
@@ -59,8 +59,6 @@ class store_client
 {
 
 public:
-    void *operator new (size_t);
-    void operator delete (void *);
     store_client(StoreEntry *);
     ~store_client();
     bool memReaderHasLowerOffset(int64_t) const;
@@ -124,7 +122,7 @@ class store_client
     } _callback;
 
 private:
-    CBDATA_CLASS(store_client);
+    CBDATA_CLASS2(store_client);
 };
 
 void storeClientCopy(store_client *, StoreEntry *, StoreIOBuffer, STCB *, void *);
@@ -31,7 +31,7 @@
 #ifndef SQUID_STOREFILESYSTEM_H
 #define SQUID_STOREFILESYSTEM_H
 
-#include "Array.h"
+#include "base/Vector.h"
 
 /* ****** DOCUMENTATION ***** */
 
@@ -1,6 +1,5 @@
 /*
  * DEBUG: section 28    Access Control
- * AUTHOR: Duane Wessels
  *
  * SQUID Web Proxy Cache          http://www.squid-cache.org/
  * ----------------------------------------------------------
@@ -38,6 +37,7 @@
 #include "Debug.h"
 #include "dlink.h"
 #include "globals.h"
+#include "profiler/Profiler.h"
 #include "SquidConfig.h"
 
 const ACLFlag ACLFlags::NoFlags[1] = {ACL_F_END};
@@ -52,8 +52,9 @@ bool ACLFlags::supported(const ACLFlag f) const
 }
 
 void
-ACLFlags::parseFlags(char * &nextToken)
+ACLFlags::parseFlags()
 {
+    char *nextToken;
     while ((nextToken = ConfigParser::strtokFile()) != NULL && nextToken[0] == '-') {
 
         //if token is the "--" break flag
@@ -137,7 +138,8 @@ ACL::Factory (char const *type)
 
 ACL::ACL() :
         cfgline(NULL),
-        next(NULL)
+        next(NULL),
+        registered(false)
 {
     *name = 0;
 }
@@ -147,6 +149,46 @@ bool ACL::valid () const
     return true;
 }
 
+bool
+ACL::matches(ACLChecklist *checklist) const
+{
+    PROF_start(ACL_matches);
+    debugs(28, 5, "checking " << name);
+
+    // XXX: AclMatchedName does not contain a matched ACL name when the acl
+    // does not match. It contains the last (usually leaf) ACL name checked
+    // (or is NULL if no ACLs were checked).
+    AclMatchedName = name;
+
+    int result = 0;
+    if (!checklist->hasRequest() && requiresRequest()) {
+        debugs(28, DBG_IMPORTANT, "WARNING: " << name << " ACL is used in " <<
+               "context without an HTTP request. Assuming mismatch.");
+    } else if (!checklist->hasReply() && requiresReply()) {
+        debugs(28, DBG_IMPORTANT, "WARNING: " << name << " ACL is used in " <<
+               "context without an HTTP response. Assuming mismatch.");
+    } else {
+        // have to cast because old match() API is missing const
+        result = const_cast<ACL*>(this)->match(checklist);
+    }
+
+    const char *extra = checklist->asyncInProgress() ? " async" : "";
+    debugs(28, 3, "checked: " << name << " = " << result << extra);
+    PROF_stop(ACL_matches);
+    return result == 1; // true for match; false for everything else
+}
+
+void
+ACL::context(const char *aName, const char *aCfgLine)
+{
+    name[0] = '\0';
+    if (aName)
+        xstrncpy(name, aName, ACL_NAME_SZ-1);
+    safe_free(cfgline);
+    if (aCfgLine)
+        cfgline = xstrdup(aCfgLine);
+}
+
 void
 ACL::ParseAclLine(ConfigParser &parser, ACL ** head)
 {
@@ -215,8 +257,7 @@ ACL::ParseAclLine(ConfigParser &parser, ACL ** head)
     if ((A = FindByName(aclname)) == NULL) {
         debugs(28, 3, "aclParseAclLine: Creating ACL '" << aclname << "'");
         A = ACL::Factory(theType);
-        xstrncpy(A->name, aclname, ACL_NAME_SZ);
-        A->cfgline = xstrdup(config_input_line);
+        A->context(aclname, config_input_line);
         new_acl = 1;
     } else {
         if (strcmp (A->typeString(),theType) ) {
@@ -235,8 +276,7 @@ ACL::ParseAclLine(ConfigParser &parser, ACL ** head)
      */
     AclMatchedName = A->name;	/* ugly */
 
-    char *aTok;
-    A->flags.parseFlags(aTok);
+    A->flags.parseFlags();
 
     /*split the function here */
     A->parse();
@@ -259,6 +299,9 @@ ACL::ParseAclLine(ConfigParser &parser, ACL ** head)
     }
 
     /* append */
+    assert(head && *head == Config.aclList);
+    A->registered = true;
+
     while (*head)
         head = &(*head)->next;
 
@@ -271,18 +314,6 @@ ACL::isProxyAuth() const
     return false;
 }
 
-ACLList::ACLList() : op (1), _acl (NULL), next (NULL)
-{}
-
-void
-ACLList::negated(bool isNegated)
-{
-    if (isNegated)
-        op = 0;
-    else
-        op = 1;
-}
-
 /* ACL result caching routines */
 
 int
@@ -359,49 +390,6 @@ ACL::requiresRequest() const
     return false;
 }
 
-int
-ACL::checklistMatches(ACLChecklist *checklist)
-{
-    int rv;
-
-    if (!checklist->hasRequest() && requiresRequest()) {
-        debugs(28, DBG_IMPORTANT, "ACL::checklistMatches WARNING: '" << name << "' ACL is used but there is no HTTP request -- not matching.");
-        return 0;
-    }
-
-    if (!checklist->hasReply() && requiresReply()) {
-        debugs(28, DBG_IMPORTANT, "ACL::checklistMatches WARNING: '" << name << "' ACL is used but there is no HTTP reply -- not matching.");
-        return 0;
-    }
-
-    debugs(28, 3, "ACL::checklistMatches: checking '" << name << "'");
-    rv= match(checklist);
-    debugs(28, 3, "ACL::ChecklistMatches: result for '" << name << "' is " << rv);
-    return rv;
-}
-
-bool
-ACLList::matches (ACLChecklist *checklist) const
-{
-    assert (_acl);
-    // XXX: AclMatchedName does not contain a matched ACL name when the acl
-    // does not match (or contains stale name if no ACLs are checked). In
-    // either case, we get misleading debugging and possibly incorrect error
-    // messages. Unfortunately, deny_info's "when none http_access
-    // lines match" exception essentially requires this mess.
-    // TODO: Rework by using an acl-free deny_info for the no-match cases?
-    AclMatchedName = _acl->name;
-    debugs(28, 3, "ACLList::matches: checking " << (op ? null_string : "!") << _acl->name);
-
-    if (_acl->checklistMatches(checklist) != op) {
-        debugs(28, 4, "ACLList::matches: result is false");
-        return false;
-    }
-
-    debugs(28, 4, "ACLList::matches: result is true");
-    return true;
-}
-
 /*********************/
 /* Destroy functions */
 /*********************/
@@ -410,25 +398,7 @@ ACL::~ACL()
 {
     debugs(28, 3, "ACL::~ACL: '" << cfgline << "'");
     safe_free(cfgline);
-}
-
-/* to be split into separate files in the future */
-
-CBDATA_CLASS_INIT(acl_access);
-
-void *
-acl_access::operator new (size_t)
-{
-    CBDATA_INIT_TYPE(acl_access);
-    acl_access *result = cbdataAlloc(acl_access);
-    return result;
-}
-
-void
-acl_access::operator delete (void *address)
-{
-    acl_access *t = static_cast<acl_access *>(address);
-    cbdataFree(t);
+    AclMatchedName = NULL; // in case it was pointing to our name
 }
 
 ACL::Prototype::Prototype() : prototype (NULL), typeString (NULL) {}
@@ -33,7 +33,8 @@
 #ifndef SQUID_ACL_H
 #define SQUID_ACL_H
 
-#include "Array.h"
+#include "acl/forward.h"
+#include "base/Vector.h"
 #include "cbdata.h"
 #include "defines.h"
 #include "dlink.h"
@@ -47,8 +48,6 @@
 #endif
 
 class ConfigParser;
-class ACLChecklist;
-class ACLList;
 
 typedef char ACLFlag;
 // ACLData Flags
@@ -70,8 +69,8 @@ class ACLFlags
     void makeSet(const ACLFlag f) { flags_ |= flagToInt(f); } ///< Set the given flag
     /// Return true if the given flag is set
     bool isSet(const ACLFlag f) const { return flags_ & flagToInt(f);}
-    /// Parse a flags given in the form -[A..Z|a..z]
-    void parseFlags(char * &nextToken);
+    /// Parse optional flags given in the form -[A..Z|a..z]
+    void parseFlags();
     const char *flagsStr() const; ///< Convert the flags to a string representation
 
 private:
@@ -90,6 +89,9 @@ class ACLFlags
     static const ACLFlag NoFlags[1]; ///< An empty flags list
 };
 
+/// A configurable condition. A node in the ACL expression tree.
+/// Can evaluate itself in FilledChecklist context.
+/// Does not change during evaluation.
 /// \ingroup ACLAPI
 class ACL
 {
@@ -106,17 +108,25 @@ class ACL
     ACL();
     explicit ACL(const ACLFlag flgs[]) : cfgline(NULL), next(NULL), flags(flgs) { memset(name, '\0', sizeof(name)); }
     virtual ~ACL();
+
+    /// sets user-specified ACL name and squid.conf context
+    void context(const char *name, const char *configuration);
+
+    /// Orchestrates matching checklist against the ACL using match(),
+    /// after checking preconditions and while providing debugging.
+    /// Returns true if and only if there was a successful match.
+    /// Updates the checklist state on match, async, and failure.
+    bool matches(ACLChecklist *checklist) const;
+
     virtual ACL *clone()const = 0;
+
+    /// parses node represenation in squid.conf; dies on failures
     virtual void parse() = 0;
     virtual char const *typeString() const = 0;
     virtual bool isProxyAuth() const;
-    virtual bool requiresRequest() const;
-    virtual bool requiresReply() const;
-    virtual int match(ACLChecklist * checklist) = 0;
     virtual wordlist *dump() const = 0;
     virtual bool empty () const = 0;
     virtual bool valid () const;
-    int checklistMatches(ACLChecklist *);
 
     int cacheMatchAcl(dlink_list * cache, ACLChecklist *);
     virtual int matchForCache(ACLChecklist *checklist);
@@ -127,6 +137,7 @@ class ACL
     char *cfgline;
     ACL *next;
     ACLFlags flags; ///< The list of given ACL flags
+    bool registered; ///< added to Config.aclList and can be reused via by FindByName()
 
 public:
 
@@ -151,6 +162,15 @@ class ACL
         typedef Vector<Prototype const*>::const_iterator const_iterator;
         void registerMe();
     };
+
+private:
+    /// Matches the actual data in checklist against this ACL.
+    virtual int match(ACLChecklist *checklist) = 0; // XXX: missing const
+
+    /// whether our (i.e. shallow) match() requires checklist to have a request
+    virtual bool requiresRequest() const;
+    /// whether our (i.e. shallow) match() requires checklist to have a reply
+    virtual bool requiresReply() const;
 };
 
 /// \ingroup ACLAPI
@@ -210,39 +230,6 @@ operator <<(std::ostream &o, const allow_t a)
     return o;
 }
 
-/// \ingroup ACLAPI
-class acl_access
-{
-
-public:
-    void *operator new(size_t);
-    void operator delete(void *);
-    allow_t allow;
-    ACLList *aclList;
-    char *cfgline;
-    acl_access *next;
-
-private:
-    CBDATA_CLASS(acl_access);
-};
-
-/// \ingroup ACLAPI
-class ACLList
-{
-
-public:
-    MEMPROXY_CLASS(ACLList);
-
-    ACLList();
-    void negated(bool isNegated);
-    bool matches (ACLChecklist *)const;
-    int op;
-    ACL *_acl;
-    ACLList *next;
-};
-
-MEMPROXY_CLASS_INLINE(ACLList);
-
 /// \ingroup ACLAPI
 class acl_proxy_auth_match_cache
 {
@@ -29,7 +29,7 @@
  *
  */
 
-#include "defines.h"
+#include "acl/forward.h"
 
 /// list of name-based ACLs. Currently a POD.
 class AclNameList
@@ -29,7 +29,8 @@
  *
  */
 
-class ACLList;
+#include "acl/forward.h"
+
 /// representation of a class of Size-limit ACLs
 // a POD. TODO: convert to new ACL framework
 class AclSizeLimit
@@ -0,0 +1,82 @@
+#include "squid.h"
+#include "acl/AllOf.h"
+#include "acl/Checklist.h"
+#include "acl/BoolOps.h"
+#include "globals.h"
+#include "MemBuf.h"
+
+char const *
+Acl::AllOf::typeString() const
+{
+    return "all-of";
+}
+
+ACL *
+Acl::AllOf::clone() const
+{
+    return new AllOf;
+}
+
+wordlist*
+Acl::AllOf::dump() const
+{
+    return empty() ? NULL : nodes.front()->dump();
+}
+
+int
+Acl::AllOf::doMatch(ACLChecklist *checklist, Nodes::const_iterator start) const
+{
+    assert(start == nodes.begin()); // we only have one node
+
+    // avoid dereferencing invalid start
+    if (empty())
+        return 1; // not 0 because in math empty product equals identity
+
+    if (checklist->matchChild(this, start, *start))
+        return 1; // match
+
+    return checklist->keepMatching() ? 0 : -1;
+}
+
+// called once per "acl name all-of name1 name2 ...." line
+void
+Acl::AllOf::parse()
+{
+    Acl::InnerNode *whole = NULL;
+    ACL *oldNode = empty() ? NULL : nodes.front();
+
+    // optimization: this logic reduces subtree hight (number of tree levels)
+    if (Acl::OrNode *oldWhole = dynamic_cast<Acl::OrNode*>(oldNode)) {
+        // this acl saw multiple lines before; add another one to the old node
+        whole = oldWhole;
+    } else if (oldNode) {
+        // this acl saw a single line before; create a new OR inner node
+
+        MemBuf wholeCtx;
+        wholeCtx.init();
+        wholeCtx.Printf("(%s lines)", name);
+        wholeCtx.terminate();
+
+        Acl::OrNode *newWhole = new Acl::OrNode;
+        newWhole->context(wholeCtx.content(), oldNode->cfgline);
+        newWhole->add(oldNode); // old (i.e. first) line
+        nodes.front() = whole = newWhole;
+    } else {
+        // this is the first line for this acl; just use it as is
+        whole = this;
+    }
+
+    assert(whole);
+    const int lineId = whole->childrenCount() + 1;
+
+    MemBuf lineCtx;
+    lineCtx.init();
+    lineCtx.Printf("(%s line #%d)", name, lineId);
+    lineCtx.terminate();
+
+    Acl::AndNode *line = new AndNode;
+    line->context(lineCtx.content(), config_input_line);
+    line->lineParse();
+
+    whole->add(line);
+}
@@ -0,0 +1,34 @@
+#ifndef SQUID_ACL_ALL_OF_H
+#define SQUID_ACL_ALL_OF_H
+
+#include "acl/InnerNode.h"
+
+namespace Acl
+{
+
+/// Configurable all-of ACL. Each ACL line is a conjuction of ACLs.
+/// Uses AndNode and OrNode to handle squid.conf configuration where multiple
+/// acl all-of lines are always ORed together.
+class AllOf: public Acl::InnerNode
+{
+public:
+    MEMPROXY_CLASS(AllOf);
+
+    /* ACL API */
+    virtual char const *typeString() const;
+    virtual ACL *clone() const;
+    virtual void parse();
+    virtual wordlist *dump() const;
+
+private:
+    /* Acl::InnerNode API */
+    virtual int doMatch(ACLChecklist *checklist, Nodes::const_iterator start) const;
+
+    static Prototype RegistryProtoype;
+    static AllOf RegistryEntry_;
+};
+MEMPROXY_CLASS_INLINE(Acl::AllOf);
+
+} // namespace Acl
+
+#endif /* SQUID_ACL_ALL_OF_H */
@@ -0,0 +1,23 @@
+#include "squid.h"
+#include "acl/AnyOf.h"
+
+char const *
+Acl::AnyOf::typeString() const
+{
+    return "any-of";
+}
+
+ACL *
+Acl::AnyOf::clone() const
+{
+    return new AnyOf;
+}
+
+// called once per "acl name any-of name1 name2 ...." line
+// but since multiple lines are ORed, the line boundary does not matter,
+// so we flatten the tree into one line/level here to minimize overheads
+void
+Acl::AnyOf::parse()
+{
+    lineParse();
+}
@@ -0,0 +1,28 @@
+#ifndef SQUID_ACL_ANY_OF_H
+#define SQUID_ACL_ANY_OF_H
+
+#include "acl/BoolOps.h"
+
+namespace Acl
+{
+
+/// Configurable any-of ACL. Each ACL line is a disjuction of ACLs.
+class AnyOf: public Acl::OrNode
+{
+public:
+    MEMPROXY_CLASS(AnyOf);
+
+    /* ACL API */
+    virtual char const *typeString() const;
+    virtual ACL *clone() const;
+    virtual void parse();
+
+private:
+    static Prototype RegistryProtoype;
+    static AnyOf RegistryEntry_;
+};
+MEMPROXY_CLASS_INLINE(Acl::AnyOf);
+
+} // namespace Acl
+
+#endif /* SQUID_ACL_ANY_OF_H */
@@ -161,7 +161,7 @@ ACLARP::match(ACLChecklist *cl)
     ACLFilledChecklist *checklist = Filled(cl);
 
     /* IPv6 does not do ARP */
-    if (!checklist->src_addr.IsIPv4()) {
+    if (!checklist->src_addr.isIPv4()) {
         debugs(14, 3, "ACLARP::match: IPv4 Required for ARP Lookups. Skipping " << checklist->src_addr );
         return 0;
     }
@@ -39,7 +39,7 @@
 #include "acl/DestinationIp.h"
 #include "acl/SourceAsn.h"
 #include "cache_cf.h"
-#include "forward.h"
+#include "FwdState.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "ipcache.h"
@@ -149,10 +149,10 @@ asnMatchIp(CbDataList<int> *data, Ip::Address &addr)
     if (AS_tree_head == NULL)
         return 0;
 
-    if (addr.IsNoAddr())
+    if (addr.isNoAddr())
         return 0;
 
-    if (addr.IsAnyAddr())
+    if (addr.isAnyAddr())
         return 0;
 
     m_addr.addr = addr;
@@ -421,8 +421,8 @@ asnAddNet(char *as_string, int as_number)
     t = strchr(as_string, '.');
 
     // generate Netbits Format Mask
-    mask.SetNoAddr();
-    mask.ApplyMask(bitl, (t!=NULL?AF_INET:AF_INET6) );
+    mask.setNoAddr();
+    mask.applyMask(bitl, (t!=NULL?AF_INET:AF_INET6) );
 
     debugs(53, 3, "asnAddNet: called for " << addr << "/" << mask );
 
@@ -521,8 +521,8 @@ printRadixNode(struct squid_radix_node *rn, void *_sentry)
     addr = e->e_addr.addr;
     mask = e->e_mask.addr;
     storeAppendPrintf(sentry, "%s/%d\t",
-                      addr.NtoA(buf, MAX_IPSTRLEN),
-                      mask.GetCIDR() );
+                      addr.toStr(buf, MAX_IPSTRLEN),
+                      mask.cidr() );
     asinfo = e->e_info;
     assert(asinfo->as_number);
 
@@ -635,16 +635,14 @@ ACLDestinationASNStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist
 
     } else if (!checklist->request->flags.destinationIpLookedUp) {
         /* No entry in cache, lookup not attempted */
-        /* XXX FIXME: allow accessing the acl name here */
-        debugs(28, 3, "asnMatchAcl: Can't yet compare '" << "unknown" /*name*/ << "' ACL for '" << checklist->request->GetHost() << "'");
-        checklist->changeState (DestinationIPLookup::Instance());
-    } else {
-        Ip::Address noaddr;
-        noaddr.SetNoAddr();
-        return data->match(noaddr);
+        debugs(28, 3, "asnMatchAcl: Can't yet compare '" << AclMatchedName << "' ACL for '" << checklist->request->GetHost() << "'");
+        if (checklist->goAsync(DestinationIPLookup::Instance()))
+            return -1;
+        // else fall through to noaddr match, hiding the lookup failure (XXX)
     }
-
-    return 0;
+    Ip::Address noaddr;
+    noaddr.setNoAddr();
+    return data->match(noaddr);
 }
 
 ACLDestinationASNStrategy *
@@ -0,0 +1,136 @@
+#include "squid.h"
+#include "acl/BoolOps.h"
+#include "acl/Checklist.h"
+#include "Debug.h"
+#include "wordlist.h"
+
+/* Acl::NotNode */
+
+Acl::NotNode::NotNode(ACL *acl)
+{
+    assert(acl);
+    name[0] = '!';
+    strncat(&name[1], acl->name, sizeof(name)-1-1);
+    add(acl);
+}
+
+void
+Acl::NotNode::parse()
+{
+    // Not implemented: by the time an upper level parser discovers
+    // an '!' operator, there is nothing left for us to parse.
+    assert(false);
+}
+
+int
+Acl::NotNode::doMatch(ACLChecklist *checklist, Nodes::const_iterator start) const
+{
+    assert(start == nodes.begin()); // we only have one node
+
+    if (checklist->matchChild(this, start, *start))
+        return 0; // converting match into mismatch
+
+    if (!checklist->keepMatching())
+        return -1; // suspend on async calls and stop on failures
+
+    return 1; // converting mismatch into match
+}
+
+char const *
+Acl::NotNode::typeString() const
+{
+    return "!";
+}
+
+ACL *
+Acl::NotNode::clone() const
+{
+    // Not implemented: we are not a named ACL type in squid.conf so nobody
+    // should try to create a NotNode instance by ACL type name (which is
+    // what clone() API is for -- it does not really clone anything).
+    assert(false);
+    return NULL;
+}
+
+wordlist*
+Acl::NotNode::dump() const
+{
+    wordlist *text = NULL;
+    wordlistAdd(&text, name);
+    return text;
+}
+
+/* Acl::AndNode */
+
+char const *
+Acl::AndNode::typeString() const
+{
+    return "and";
+}
+
+ACL *
+Acl::AndNode::clone() const
+{
+    return new AndNode;
+}
+
+int
+Acl::AndNode::doMatch(ACLChecklist *checklist, Nodes::const_iterator start) const
+{
+    // find the first node that does not match
+    for (Nodes::const_iterator i = start; i != nodes.end(); ++i) {
+        if (!checklist->matchChild(this, i, *i))
+            return checklist->keepMatching() ? 0 : -1;
+    }
+
+    // one and not zero on empty because in math empty product equals identity
+    return 1; // no mismatches found (i.e., all kids matched)
+}
+
+void
+Acl::AndNode::parse()
+{
+    // Not implemented: AndNode cannot be configured directly. See Acl::AllOf.
+    assert(false);
+}
+
+/* Acl::OrNode */
+
+char const *
+Acl::OrNode::typeString() const
+{
+    return "any-of";
+}
+
+ACL *
+Acl::OrNode::clone() const
+{
+    return new OrNode;
+}
+
+int
+Acl::OrNode::doMatch(ACLChecklist *checklist, Nodes::const_iterator start) const
+{
+    lastMatch_ = nodes.end();
+
+    // find the first node that matches, but stop if things go wrong
+    for (Nodes::const_iterator i = start; i != nodes.end(); ++i) {
+        if (checklist->matchChild(this, i, *i)) {
+            lastMatch_ = i;
+            return 1;
+        }
+
+        if (!checklist->keepMatching())
+            return -1; // suspend on async calls and stop on failures
+    }
+
+    // zero and not one on empty because in math empty sum equals zero
+    return 0; // all nodes mismatched
+}
+
+void
+Acl::OrNode::parse()
+{
+    // Not implemented: OrNode cannot be configured directly. See Acl::AnyOf.
+    assert(false);
+}
@@ -0,0 +1,74 @@
+#ifndef SQUID_ACL_LOGIC_H
+#define SQUID_ACL_LOGIC_H
+
+#include "acl/InnerNode.h"
+
+/* ACLs defined here are used internally to construct an ACL expression tree.
+ * They cannot be specified directly in squid.conf because squid.conf ACLs are
+ * more complex than (and are implemented using) these operator-like classes.*/
+
+namespace Acl
+{
+
+/// Implements the "not" or "!" operator.
+class NotNode: public InnerNode
+{
+public:
+    MEMPROXY_CLASS(NotNode);
+
+    explicit NotNode(ACL *acl);
+
+private:
+    /* ACL API */
+    virtual char const *typeString() const;
+    virtual ACL *clone() const;
+    virtual void parse();
+    virtual wordlist *dump() const;
+
+    /* Acl::InnerNode API */
+    virtual int doMatch(ACLChecklist *checklist, Nodes::const_iterator start) const;
+};
+MEMPROXY_CLASS_INLINE(Acl::NotNode);
+
+/// An inner ACL expression tree node representing a boolean conjuction (AND)
+/// operator applied to a list of child tree nodes.
+/// For example, conditions expressed on a single http_access line are ANDed.
+class AndNode: public InnerNode
+{
+public:
+    MEMPROXY_CLASS(AndNode);
+
+    /* ACL API */
+    virtual char const *typeString() const;
+    virtual ACL *clone() const;
+    virtual void parse();
+
+private:
+    virtual int doMatch(ACLChecklist *checklist, Nodes::const_iterator start) const;
+};
+MEMPROXY_CLASS_INLINE(Acl::AndNode);
+
+/// An inner ACL expression tree node representing a boolean disjuction (OR)
+/// operator applied to a list of child tree nodes.
+/// For example, conditions expressed by multiple http_access lines are ORed.
+class OrNode: public InnerNode
+{
+public:
+    MEMPROXY_CLASS(OrNode);
+
+    /* ACL API */
+    virtual char const *typeString() const;
+    virtual ACL *clone() const;
+    virtual void parse();
+
+protected:
+    mutable Nodes::const_iterator lastMatch_;
+
+private:
+    virtual int doMatch(ACLChecklist *checklist, Nodes::const_iterator start) const;
+};
+MEMPROXY_CLASS_INLINE(Acl::OrNode);
+
+} // namespace Acl
+
+#endif /* SQUID_ACL_LOGIC_H */
@@ -1,140 +1,49 @@
 /*
  * DEBUG: section 28    Access Control
- * AUTHOR: Duane Wessels
- *
- * SQUID Web Proxy Cache          http://www.squid-cache.org/
- * ----------------------------------------------------------
- *
- *  Squid is the result of efforts by numerous individuals from
- *  the Internet community; see the CONTRIBUTORS file for full
- *  details.   Many organizations have provided support for Squid's
- *  development; see the SPONSORS file for full details.  Squid is
- *  Copyrighted (C) 2001 by the Regents of the University of
- *  California; see the COPYRIGHT file for full details.  Squid
- *  incorporates software developed and/or copyrighted by other
- *  sources; see the CREDITS file for full details.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
- *
- * Copyright (c) 2003, Robert Collins <robertc@squid-cache.org>
  */
 
 #include "squid.h"
 #include "acl/Checklist.h"
+#include "acl/Tree.h"
 #include "Debug.h"
 #include "profiler/Profiler.h"
 
-void
-ACLChecklist::matchNonBlocking()
+/// common parts of nonBlockingCheck() and resumeNonBlockingCheck()
+bool
+ACLChecklist::prepNonBlocking()
 {
-    if (checking())
-        return;
+    assert(accessList);
 
     if (callerGone()) {
         checkCallback(ACCESS_DUNNO); // the answer does not really matter
-        return;
-    }
-
-    /** The ACL List should NEVER be NULL when calling this method.
-     * Always caller should check for NULL and handle appropriate to its needs first.
-     * We cannot select a sensible default for all callers here. */
-    if (accessList == NULL) {
-        debugs(28, DBG_CRITICAL, "SECURITY ERROR: ACL " << this << " checked with nothing to match against!!");
-        checkCallback(ACCESS_DUNNO);
-        return;
+        return false;
     }
 
-    allow_t lastSeenKeyword = ACCESS_DUNNO;
-    /* NOTE: This holds a cbdata reference to the current access_list
-     * entry, not the whole list.
+    /** \par
+     * If the accessList is no longer valid (i.e. its been
+     * freed because of a reconfigure), then bail with ACCESS_DUNNO.
      */
-    while (accessList != NULL) {
-        /** \par
-         * If the _acl_access is no longer valid (i.e. its been
-         * freed because of a reconfigure), then bail with ACCESS_DUNNO.
-         */
-
-        if (!cbdataReferenceValid(accessList)) {
-            cbdataReferenceDone(accessList);
-            debugs(28, 4, "ACLChecklist::check: " << this << " accessList is invalid");
-            checkCallback(ACCESS_DUNNO);
-            return;
-        }
-
-        checking (true);
-        checkAccessList();
-        checking (false);
-
-        if (asyncInProgress()) {
-            return;
-        }
-
-        if (finished()) {
-            /** \par
-             * Either the request is allowed, denied, requires authentication.
-             */
-            debugs(28, 3, "ACLChecklist::check: " << this << " match found, calling back with " << currentAnswer());
-            cbdataReferenceDone(accessList); /* A */
-            checkCallback(currentAnswer());
-            /* From here on in, this may be invalid */
-            return;
-        }
-
-        lastSeenKeyword = accessList->allow;
-
-        /*
-         * Reference the next access entry
-         */
-        const acl_access *A = accessList;
-
-        assert (A);
 
-        accessList = cbdataReference(A->next);
-
-        cbdataReferenceDone(A);
+    if (!cbdataReferenceValid(accessList)) {
+        cbdataReferenceDone(accessList);
+        debugs(28, 4, "ACLChecklist::check: " << this << " accessList is invalid");
+        checkCallback(ACCESS_DUNNO);
+        return false;
     }
 
-    calcImplicitAnswer(lastSeenKeyword);
-    checkCallback(currentAnswer());
-}
-
-bool
-ACLChecklist::asyncNeeded() const
-{
-    return state_ != NullState::Instance();
-}
-
-bool
-ACLChecklist::asyncInProgress() const
-{
-    return async_;
+    return true;
 }
 
 void
-ACLChecklist::asyncInProgress(bool const newAsync)
+ACLChecklist::completeNonBlocking()
 {
-    assert (!finished() && !(asyncInProgress() && newAsync));
-    async_ = newAsync;
-    debugs(28, 3, "ACLChecklist::asyncInProgress: " << this <<
-           " async set to " << async_);
-}
+    assert(!asyncInProgress());
 
-bool
-ACLChecklist::finished() const
-{
-    return finished_;
+    if (!finished())
+        calcImplicitAnswer();
+
+    cbdataReferenceDone(accessList);
+    checkCallback(currentAnswer());
 }
 
 void
@@ -151,177 +60,115 @@ void
 ACLChecklist::preCheck(const char *what)
 {
     debugs(28, 3, HERE << this << " checking " << what);
-    finished_ = false;
-}
 
-void
-ACLChecklist::checkAccessList()
-{
-    debugs(28, 3, HERE << this << " checking '" << accessList->cfgline << "'");
-    /* does the current AND clause match */
-    if (matchAclList(accessList->aclList, false))
-        markFinished(accessList->allow, "first matching rule won");
+    // concurrent checks using the same Checklist are not supported
+    assert(!occupied_);
+    occupied_ = true;
 
-    // If we are not finished() here, the caller must distinguish between
-    // slow async calls and pure rule mismatches using asyncInProgress().
-}
-
-void
-ACLChecklist::checkForAsync()
-{
-    asyncState()->checkForAsync(this);
+    AclMatchedName = NULL;
+    finished_ = false;
 }
 
-// ACLFilledChecklist overwrites this to unclock something before we
-// "delete this"
-void
-ACLChecklist::checkCallback(allow_t answer)
+bool
+ACLChecklist::matchChild(const Acl::InnerNode *current, Acl::Nodes::const_iterator pos, const ACL *child)
 {
-    ACLCB *callback_;
-    void *cbdata_;
-    debugs(28, 3, "ACLChecklist::checkCallback: " << this << " answer=" << answer);
-
-    callback_ = callback;
-    callback = NULL;
-
-    if (cbdataReferenceValidDone(callback_data, &cbdata_))
-        callback_(answer, cbdata_);
+    assert(current && child);
+
+    // Remember the current tree location to prevent "async loop" cases where
+    // the same child node wants to go async more than once.
+    matchLoc_ = Breadcrumb(current, pos);
+
+    // if there are any breadcrumbs left, then follow them on the way down
+    bool result = false;
+    if (matchPath.empty()) {
+        result = child->matches(this);
+    } else {
+        const Breadcrumb top(matchPath.top());
+        assert(child == top.parent);
+        matchPath.pop();
+        result = top.parent->resumeMatchingAt(this, top.position);
+    }
 
-    delete this;
-}
+    if (asyncInProgress()) {
+        // We get here for node N that called goAsync() and then, as the call
+        // stack unwinds, for the nodes higher in the ACL tree that led to N.
+        matchPath.push(Breadcrumb(current, pos));
+    } else {
+        asyncLoc_.clear();
+    }
 
-/// An ACLChecklist::matchNodes() wrapper to simplify profiling.
-bool
-ACLChecklist::matchAclList(const ACLList * head, bool const fast)
-{
-    // TODO: remove by using object con/destruction-based PROF_* macros.
-    PROF_start(aclMatchAclList);
-    const bool result = matchNodes(head, fast);
-    PROF_stop(aclMatchAclList);
+    matchLoc_.clear();
     return result;
 }
 
-/** Returns true if and only if there was a match. If false is returned:
-    finished() indicates an error or exception of some kind, while
-    !finished() means there was a mismatch or an allowed slow async call.
-    If async calls are allowed (i.e. 'fast' was false), then those last
-    two cases can be distinguished using asyncInProgress().
-*/
 bool
-ACLChecklist::matchNodes(const ACLList * head, bool const fast)
+ACLChecklist::goAsync(AsyncState *state)
 {
-    assert(!finished());
-
-    for (const ACLList *node = head; node; node = node->next) {
-
-        const NodeMatchingResult resultBeforeAsync = matchNode(*node, fast);
-
-        if (resultBeforeAsync == nmrMatch)
-            continue;
-
-        if (resultBeforeAsync == nmrMismatch || resultBeforeAsync == nmrFinished)
-            return false;
+    assert(state);
+    assert(!asyncInProgress());
+    assert(matchLoc_.parent);
 
-        assert(resultBeforeAsync == nmrNeedsAsync);
-
-        // Ideally, this should be inside match() itself, but that requires
-        // prohibiting slow ACLs in options that do not support them.
-        // TODO: rename to maybeStartAsync()?
-        checkForAsync();
-
-        // Some match() code claims that an async lookup is needed, but then
-        // fails to start an async lookup when given a chance. We catch such
-        // cases here and call matchNode() again, hoping that some cached data
-        // prevents us from going async again.
-        // This is inefficient and ugly, but fixing all match() code, including
-        // the code it calls, such as ipcache_nbgethostbyname(), takes time.
-        if (!asyncInProgress()) { // failed to start an async operation
+    // TODO: add a once-in-a-while WARNING about fast directive using slow ACL?
+    if (!asyncCaller_) {
+        debugs(28, 2, this << " a fast-only directive uses a slow ACL!");
+        return false;
+    }
 
-            if (finished()) {
-                debugs(28, 3, HERE << this << " finished after failing to go async: " << currentAnswer());
-                return false; // an exceptional case
-            }
+    // TODO: add a once-in-a-while WARNING about async loops?
+    if (matchLoc_ == asyncLoc_) {
+        debugs(28, 2, this << " a slow ACL resumes by going async again!");
+        return false;
+    }
 
-            const NodeMatchingResult resultAfterAsync = matchNode(*node, true);
-            // the second call disables slow checks so we cannot go async again
-            assert(resultAfterAsync != nmrNeedsAsync);
-            if (resultAfterAsync == nmrMatch)
-                continue;
+    asyncLoc_ = matchLoc_; // prevent async loops
 
-            assert(resultAfterAsync == nmrMismatch || resultAfterAsync == nmrFinished);
-            return false;
-        }
+    asyncStage_ = asyncStarting;
+    changeState(state);
+    state->checkForAsync(this); // this is supposed to go async
 
-        assert(!finished()); // async operation is truly asynchronous
-        debugs(28, 3, HERE << this << " awaiting async operation");
+    // Did AsyncState object actually go async? If not, tell the caller.
+    if (asyncStage_ != asyncStarting) {
+        assert(asyncStage_ == asyncFailed);
+        asyncStage_ = asyncNone; // sanity restored
         return false;
     }
 
-    debugs(28, 3, HERE << this << " success: all ACLs matched");
+    // yes, we must pause until the async callback calls resumeNonBlockingCheck
+    asyncStage_ = asyncRunning;
     return true;
 }
 
-/// Check whether a single ACL matches, returning NodeMatchingResult
-ACLChecklist::NodeMatchingResult
-ACLChecklist::matchNode(const ACLList &node, bool const fast)
+// ACLFilledChecklist overwrites this to unclock something before we
+// "delete this"
+void
+ACLChecklist::checkCallback(allow_t answer)
 {
-    const bool nodeMatched = node.matches(this);
-    const bool needsAsync = asyncNeeded();
-    const bool matchFinished = finished();
-
-    debugs(28, 3, HERE << this <<
-           " matched=" << nodeMatched <<
-           " async=" << needsAsync <<
-           " finished=" << matchFinished);
-
-    /* There are eight possible outcomes of the matches() call based on
-       (matched, async, finished) permutations. We support these four:
-       matched,!async,!finished: a match (must check next rule node)
-       !matched,!async,!finished: a mismatch (whole rule fails to match)
-       !matched,!async,finished: error or special condition (propagate)
-       !matched,async,!finished: ACL needs to make an async call (pause)
-     */
-
-    if (nodeMatched) {
-        // matches() should return false in all special cases
-        assert(!needsAsync && !matchFinished);
-        return nmrMatch;
-    }
+    ACLCB *callback_;
+    void *cbdata_;
+    debugs(28, 3, "ACLChecklist::checkCallback: " << this << " answer=" << answer);
 
-    if (matchFinished) {
-        // we cannot be done and need an async call at the same time
-        assert(!needsAsync);
-        debugs(28, 3, HERE << this << " exception: " << currentAnswer());
-        return nmrFinished;
-    }
+    callback_ = callback;
+    callback = NULL;
 
-    if (!needsAsync) {
-        debugs(28, 3, HERE << this << " simple mismatch");
-        return nmrMismatch;
-    }
+    if (cbdataReferenceValidDone(callback_data, &cbdata_))
+        callback_(answer, cbdata_);
 
-    /* we need an async call */
+    // not really meaningful just before delete, but here for completeness sake
+    occupied_ = false;
 
-    if (fast) {
-        changeState(NullState::Instance()); // disable async checks
-        markFinished(ACCESS_DUNNO, "async required but prohibited");
-        debugs(28, 3, HERE << this << " DUNNO because cannot async");
-        return nmrFinished;
-    }
-
-    debugs(28, 3, HERE << this << " going async");
-    return nmrNeedsAsync;
+    delete this;
 }
 
 ACLChecklist::ACLChecklist() :
         accessList (NULL),
         callback (NULL),
         callback_data (NULL),
-        async_(false),
+        asyncCaller_(false),
+        occupied_(false),
         finished_(false),
         allow_(ACCESS_DENIED),
-        state_(NullState::Instance()),
-        checking_(false)
+        asyncStage_(asyncNone),
+        state_(NullState::Instance())
 {
 }
 
@@ -334,12 +181,6 @@ ACLChecklist::~ACLChecklist()
     debugs(28, 4, "ACLChecklist::~ACLChecklist: destroyed " << this);
 }
 
-void
-ACLChecklist::AsyncState::changeState (ACLChecklist *checklist, AsyncState *newState) const
-{
-    checklist->changeState(newState);
-}
-
 ACLChecklist::NullState *
 ACLChecklist::NullState::Instance()
 {
@@ -348,7 +189,9 @@ ACLChecklist::NullState::Instance()
 
 void
 ACLChecklist::NullState::checkForAsync(ACLChecklist *) const
-{}
+{
+    assert(false); // or the Checklist will never get out of the async state
+}
 
 ACLChecklist::NullState ACLChecklist::NullState::_instance;
 
@@ -381,21 +224,94 @@ ACLChecklist::nonBlockingCheck(ACLCB * callback_, void *callback_data_)
     preCheck("slow rules");
     callback = callback_;
     callback_data = cbdataReference(callback_data_);
-    matchNonBlocking();
+    asyncCaller_ = true;
+
+    /** The ACL List should NEVER be NULL when calling this method.
+     * Always caller should check for NULL and handle appropriate to its needs first.
+     * We cannot select a sensible default for all callers here. */
+    if (accessList == NULL) {
+        debugs(28, DBG_CRITICAL, "SECURITY ERROR: ACL " << this << " checked with nothing to match against!!");
+        checkCallback(ACCESS_DUNNO);
+        return;
+    }
+
+    if (prepNonBlocking()) {
+        matchAndFinish(); // calls markFinished() on success
+        if (!asyncInProgress())
+            completeNonBlocking();
+    } // else checkCallback() has been called
+}
+
+void
+ACLChecklist::resumeNonBlockingCheck(AsyncState *state)
+{
+    assert(asyncState() == state);
+    changeState(NullState::Instance());
+
+    if (asyncStage_ == asyncStarting) { // oops, we did not really go async
+        asyncStage_ = asyncFailed; // goAsync() checks for that
+        // Do not fall through to resume checks from the async callback. Let
+        // the still-pending(!) goAsync() notice and notify its caller instead.
+        return;
+    }
+    assert(asyncStage_ == asyncRunning);
+    asyncStage_ = asyncNone;
+
+    assert(!matchPath.empty());
+
+    if (!prepNonBlocking())
+        return; // checkCallback() has been called
+
+    if (!finished())
+        matchAndFinish();
+
+    if (asyncInProgress())
+        assert(!matchPath.empty()); // we have breadcrumbs to resume matching
+    else
+        completeNonBlocking();
+}
+
+/// performs (or resumes) an ACL tree match and, if successful, sets the action
+void
+ACLChecklist::matchAndFinish()
+{
+    bool result = false;
+    if (matchPath.empty()) {
+        result = accessList->matches(this);
+    } else {
+        const Breadcrumb top(matchPath.top());
+        matchPath.pop();
+        result = top.parent->resumeMatchingAt(this, top.position);
+    }
+
+    if (result) // the entire tree matched
+        markFinished(accessList->winningAction(), "match");
 }
 
 allow_t const &
-ACLChecklist::fastCheck(const ACLList * list)
+ACLChecklist::fastCheck(const Acl::Tree * list)
 {
     PROF_start(aclCheckFast);
 
     preCheck("fast ACLs");
+    asyncCaller_ = false;
+
+    // Concurrent checks are not supported, but sequential checks are, and they
+    // may use a mixture of fastCheck(void) and fastCheck(list) calls.
+    const Acl::Tree * const savedList = accessList;
+
+    accessList = cbdataReference(list);
+
+    // assume DENY/ALLOW on mis/matches due to action-free accessList
+    // matchAndFinish() takes care of the ALLOW case
+    if (accessList && cbdataReferenceValid(accessList))
+        matchAndFinish(); // calls markFinished() on success
+    if (!finished())
+        markFinished(ACCESS_DENIED, "ACLs failed to match");
 
-    // assume DENY/ALLOW on mis/matches due to not having acl_access object
-    if (matchAclList(list, true))
-        markFinished(ACCESS_ALLOWED, "all ACLs matched");
-    else if (!finished())
-        markFinished(ACCESS_DENIED, "ACL mismatched");
+    cbdataReferenceDone(accessList);
+    accessList = savedList;
+    occupied_ = false;
     PROF_stop(aclCheckFast);
     return currentAnswer();
 }
@@ -409,66 +325,52 @@ ACLChecklist::fastCheck()
     PROF_start(aclCheckFast);
 
     preCheck("fast rules");
+    asyncCaller_ = false;
 
-    allow_t lastSeenKeyword = ACCESS_DUNNO;
     debugs(28, 5, "aclCheckFast: list: " << accessList);
-    const acl_access *acl = cbdataReference(accessList);
-    while (acl != NULL && cbdataReferenceValid(acl)) {
-        // on a match, finish
-        if (matchAclList(acl->aclList, true))
-            markFinished(acl->allow, "first matching rule won");
+    const Acl::Tree *acl = cbdataReference(accessList);
+    if (acl != NULL && cbdataReferenceValid(acl)) {
+        matchAndFinish(); // calls markFinished() on success
 
         // if finished (on a match or in exceptional cases), stop
         if (finished()) {
             cbdataReferenceDone(acl);
+            occupied_ = false;
             PROF_stop(aclCheckFast);
             return currentAnswer();
         }
 
-        // on a mismatch, try the next access rule
-        lastSeenKeyword = acl->allow;
-        const acl_access *A = acl;
-        acl = cbdataReference(acl->next);
-        cbdataReferenceDone(A);
+        // fall through for mismatch handling
     }
 
     // There were no rules to match or no rules matched
-    calcImplicitAnswer(lastSeenKeyword);
+    calcImplicitAnswer();
+    cbdataReferenceDone(acl);
+    occupied_ = false;
     PROF_stop(aclCheckFast);
 
     return currentAnswer();
 }
 
-/// When no rules matched, the answer is the inversion of the last seen rule
-/// action (or ACCESS_DUNNO if the reversal is not possible). The caller
-/// should set lastSeenAction to ACCESS_DUNNO if there were no rules to see.
+/// When no rules matched, the answer is the inversion of the last rule
+/// action (or ACCESS_DUNNO if the reversal is not possible).
 void
-ACLChecklist::calcImplicitAnswer(const allow_t &lastSeenAction)
+ACLChecklist::calcImplicitAnswer()
 {
+    const allow_t lastAction = (accessList && cbdataReferenceValid(accessList)) ?
+                               accessList->lastAction() : allow_t(ACCESS_DUNNO);
     allow_t implicitRuleAnswer = ACCESS_DUNNO;
-    if (lastSeenAction == ACCESS_DENIED) // reverse last seen "deny"
+    if (lastAction == ACCESS_DENIED) // reverse last seen "deny"
         implicitRuleAnswer = ACCESS_ALLOWED;
-    else if (lastSeenAction == ACCESS_ALLOWED) // reverse last seen "allow"
+    else if (lastAction == ACCESS_ALLOWED) // reverse last seen "allow"
         implicitRuleAnswer = ACCESS_DENIED;
     // else we saw no rules and will respond with ACCESS_DUNNO
 
     debugs(28, 3, HERE << this << " NO match found, last action " <<
-           lastSeenAction << " so returning " << implicitRuleAnswer);
+           lastAction << " so returning " << implicitRuleAnswer);
     markFinished(implicitRuleAnswer, "implicit rule won");
 }
 
-bool
-ACLChecklist::checking() const
-{
-    return checking_;
-}
-
-void
-ACLChecklist::checking (bool const newValue)
-{
-    checking_ = newValue;
-}
-
 bool
 ACLChecklist::callerGone()
 {
@@ -31,7 +31,8 @@
 #ifndef SQUID_ACLCHECKLIST_H
 #define SQUID_ACLCHECKLIST_H
 
-#include "acl/Acl.h"
+#include "acl/InnerNode.h"
+#include <stack>
 
 /// ACL checklist callback
 typedef void ACLCB(allow_t, void *);
@@ -67,9 +68,6 @@ class ACLChecklist
     public:
         virtual void checkForAsync(ACLChecklist *) const = 0;
         virtual ~AsyncState() {}
-
-    protected:
-        void changeState (ACLChecklist *, AsyncState *) const;
     };
 
     class NullState : public AsyncState
@@ -153,25 +151,29 @@ class ACLChecklist
      *
      * If there are no ACLs to check at all, the result becomes ACCESS_ALLOWED.
      */
-    allow_t const & fastCheck(const ACLList * list);
+    allow_t const & fastCheck(const Acl::Tree *list);
+
+    /// If slow lookups are allowed, switches into "async in progress" state.
+    /// Otherwise, returns false; the caller is expected to handle the failure.
+    bool goAsync(AsyncState *);
+
+    /// Matches (or resumes matching of) a child node while maintaning
+    /// resumption breadcrumbs if a [grand]child node goes async.
+    bool matchChild(const Acl::InnerNode *parent, Acl::Nodes::const_iterator pos, const ACL *child);
 
-    // whether the last checked ACL of the current rule needs
-    // an async operation to determine whether there was a match
-    bool asyncNeeded() const;
-    bool asyncInProgress() const;
-    void asyncInProgress(bool const);
+    /// Whether we should continue to match tree nodes or stop/pause.
+    bool keepMatching() const { return !finished() && !asyncInProgress(); }
 
     /// whether markFinished() was called
-    bool finished() const;
+    bool finished() const { return finished_; }
+    /// async call has been started and has not finished (or failed) yet
+    bool asyncInProgress() const { return asyncStage_ != asyncNone; }
     /// called when no more ACLs should be checked; sets the final answer and
     /// prints a debugging message explaining the reason for that answer
     void markFinished(const allow_t &newAnswer, const char *reason);
 
     const allow_t &currentAnswer() const { return allow_; }
 
-    void changeState(AsyncState *);
-    AsyncState *asyncState() const;
-
     // XXX: ACLs that need request or reply have to use ACLFilledChecklist and
     // should do their own checks so that we do not have to povide these two
     // for ACL::checklistMatches to use
@@ -182,46 +184,60 @@ class ACLChecklist
     /// Calls non-blocking check callback with the answer and destroys self.
     void checkCallback(allow_t answer);
 
-    void checkAccessList();
-    void checkForAsync();
+    void matchAndFinish();
+
+    void changeState(AsyncState *);
+    AsyncState *asyncState() const;
 
 public:
-    const acl_access *accessList;
+    const Acl::Tree *accessList;
 
     ACLCB *callback;
     void *callback_data;
 
-    /**
-     * Performs non-blocking check starting with the current rule.
-     * Used by nonBlockingCheck() to initiate the checks and by
-     * async operation callbacks to resume checks after the async
-     * operation updates the current Squid state. See nonBlockingCheck()
-     * for details on final result determination.
-     */
-    void matchNonBlocking();
+    /// Resumes non-blocking check started by nonBlockingCheck() and
+    /// suspended until some async operation updated Squid state.
+    void resumeNonBlockingCheck(AsyncState *state);
 
 private: /* internal methods */
+    /// Position of a child node within an ACL tree.
+    class Breadcrumb
+    {
+    public:
+        Breadcrumb(): parent(NULL) {}
+        Breadcrumb(const Acl::InnerNode *aParent, Acl::Nodes::const_iterator aPos): parent(aParent), position(aPos) {}
+        bool operator ==(const Breadcrumb &b) const { return parent == b.parent && (!parent || position == b.position); }
+        bool operator !=(const Breadcrumb &b) const { return !this->operator ==(b); }
+        void clear() { parent = NULL; }
+        const Acl::InnerNode *parent; ///< intermediate node in the ACL tree
+        Acl::Nodes::const_iterator position; ///< child position inside parent
+    };
+
     /// possible outcomes when trying to match a single ACL node in a list
     typedef enum { nmrMatch, nmrMismatch, nmrFinished, nmrNeedsAsync }
     NodeMatchingResult;
 
     /// prepare for checking ACLs; called once per check
     void preCheck(const char *what);
-    bool matchAclList(const ACLList * list, bool const fast);
-    bool matchNodes(const ACLList * head, bool const fast);
-    NodeMatchingResult matchNode(const ACLList &node, bool const fast);
-    void calcImplicitAnswer(const allow_t &lastSeenAction);
+    bool prepNonBlocking();
+    void completeNonBlocking();
+    void calcImplicitAnswer();
 
-    bool async_;
+    bool asyncCaller_; ///< whether the caller supports async/slow ACLs
+    bool occupied_; ///< whether a check (fast or non-blocking) is in progress
     bool finished_;
     allow_t allow_;
-    AsyncState *state_;
 
-    bool checking_;
-    bool checking() const;
-    void checking (bool const);
+    enum AsyncStage { asyncNone, asyncStarting, asyncRunning, asyncFailed };
+    AsyncStage asyncStage_;
+    AsyncState *state_;
+    Breadcrumb matchLoc_; ///< location of the node running matches() now
+    Breadcrumb asyncLoc_; ///< currentNode_ that called goAsync()
 
     bool callerGone();
+
+    /// suspended (due to an async lookup) matches() in the ACL tree
+    std::stack<Breadcrumb> matchPath;
 };
 
 #endif /* SQUID_ACLCHECKLIST_H */
@@ -53,21 +53,16 @@ void
 DestinationDomainLookup::checkForAsync(ACLChecklist *cl) const
 {
     ACLFilledChecklist *checklist = Filled(cl);
-    checklist->asyncInProgress(true);
     fqdncache_nbgethostbyaddr(checklist->dst_addr, LookupDone, checklist);
 }
 
 void
 DestinationDomainLookup::LookupDone(const char *fqdn, const DnsLookupDetails &details, void *data)
 {
     ACLFilledChecklist *checklist = Filled((ACLChecklist*)data);
-    assert (checklist->asyncState() == DestinationDomainLookup::Instance());
-
-    checklist->asyncInProgress(false);
-    checklist->changeState (ACLChecklist::NullState::Instance());
     checklist->markDestinationDomainChecked();
     checklist->request->recordLookup(details);
-    checklist->matchNonBlocking();
+    checklist->resumeNonBlockingCheck(DestinationDomainLookup::Instance());
 }
 
 int
@@ -112,8 +107,9 @@ ACLDestinationDomainStrategy::match (ACLData<MatchType> * &data, ACLFilledCheckl
     } else if (!checklist->destinationDomainChecked()) {
         /* FIXME: Using AclMatchedName here is not OO correct. Should find a way to the current acl */
         debugs(28, 3, "aclMatchAcl: Can't yet compare '" << AclMatchedName << "' ACL for '" << checklist->request->GetHost() << "'");
-        checklist->changeState(DestinationDomainLookup::Instance());
-        return 0;
+        if (checklist->goAsync(DestinationDomainLookup::Instance()))
+            return -1;
+        // else fall through to "none" match, hiding the lookup failure (XXX)
     }
 
     return data->match("none");
@@ -56,7 +56,7 @@ ACLDestinationIP::match(ACLChecklist *cl)
     // Bypass of browser same-origin access control in intercepted communication
     // To resolve this we will force DIRECT and only to the original client destination.
     // In which case, we also need this ACL to accurately match the destination
-    if (Config.onoff.client_dst_passthru && (checklist->request->flags.intercepted || checklist->request->flags.spoofClientIp)) {
+    if (Config.onoff.client_dst_passthru && (checklist->request->flags.intercepted || checklist->request->flags.interceptTproxy)) {
         assert(checklist->conn() && checklist->conn()->clientConnection != NULL);
         return ACLIP::match(checklist->conn()->clientConnection->local);
     }
@@ -86,11 +86,12 @@ ACLDestinationIP::match(ACLChecklist *cl)
     } else if (!checklist->request->flags.destinationIpLookedUp) {
         /* No entry in cache, lookup not attempted */
         debugs(28, 3, "aclMatchAcl: Can't yet compare '" << name << "' ACL for '" << checklist->request->GetHost() << "'");
-        checklist->changeState (DestinationIPLookup::Instance());
-        return 0;
-    } else {
-        return 0;
+        if (checklist->goAsync(DestinationIPLookup::Instance()))
+            return -1;
+        // else fall through to mismatch, hiding the lookup failure (XXX)
     }
+
+    return 0;
 }
 
 DestinationIPLookup DestinationIPLookup::instance_;
@@ -105,20 +106,16 @@ void
 DestinationIPLookup::checkForAsync(ACLChecklist *cl)const
 {
     ACLFilledChecklist *checklist = Filled(cl);
-    checklist->asyncInProgress(true);
     ipcache_nbgethostbyname(checklist->request->GetHost(), LookupDone, checklist);
 }
 
 void
 DestinationIPLookup::LookupDone(const ipcache_addrs *, const DnsLookupDetails &details, void *data)
 {
     ACLFilledChecklist *checklist = Filled((ACLChecklist*)data);
-    assert (checklist->asyncState() == DestinationIPLookup::Instance());
     checklist->request->flags.destinationIpLookedUp = true;
     checklist->request->recordLookup(details);
-    checklist->asyncInProgress(false);
-    checklist->changeState (ACLChecklist::NullState::Instance());
-    checklist->matchNonBlocking();
+    checklist->resumeNonBlockingCheck(DestinationIPLookup::Instance());
 }
 
 ACL *
@@ -135,7 +135,7 @@ ACLEui64::match(ACLChecklist *cl)
     ACLFilledChecklist *checklist = Filled(cl);
 
     /* IPv4 does not do EUI-64 (yet) */
-    if (!checklist->src_addr.IsIPv6()) {
+    if (!checklist->src_addr.isIPv6()) {
         debugs(14, 3, "ACLEui64::match: IPv6 Required for EUI-64 Lookups. Skipping " << checklist->src_addr );
         return 0;
     }
@@ -13,22 +13,6 @@
 
 CBDATA_CLASS_INIT(ACLFilledChecklist);
 
-void *
-ACLFilledChecklist::operator new (size_t size)
-{
-    assert (size == sizeof(ACLFilledChecklist));
-    CBDATA_INIT_TYPE(ACLFilledChecklist);
-    ACLFilledChecklist *result = cbdataAlloc(ACLFilledChecklist);
-    return result;
-}
-
-void
-ACLFilledChecklist::operator delete (void *address)
-{
-    ACLFilledChecklist *t = static_cast<ACLFilledChecklist *>(address);
-    cbdataFree(t);
-}
-
 ACLFilledChecklist::ACLFilledChecklist() :
         dst_peer(NULL),
         dst_rdns(NULL),
@@ -49,9 +33,9 @@ ACLFilledChecklist::ACLFilledChecklist() :
         destinationDomainChecked_(false),
         sourceDomainChecked_(false)
 {
-    my_addr.SetEmpty();
-    src_addr.SetEmpty();
-    dst_addr.SetEmpty();
+    my_addr.setEmpty();
+    src_addr.setEmpty();
+    dst_addr.setEmpty();
     rfc931[0] = '\0';
 }
 
@@ -165,9 +149,9 @@ ACLFilledChecklist::ACLFilledChecklist(const acl_access *A, HttpRequest *http_re
         destinationDomainChecked_(false),
         sourceDomainChecked_(false)
 {
-    my_addr.SetEmpty();
-    src_addr.SetEmpty();
-    dst_addr.SetEmpty();
+    my_addr.setEmpty();
+    src_addr.setEmpty();
+    dst_addr.setEmpty();
     rfc931[0] = '\0';
 
     // cbdataReferenceDone() is in either fastCheck() or the destructor
@@ -194,4 +178,3 @@ ACLFilledChecklist::ACLFilledChecklist(const acl_access *A, HttpRequest *http_re
         xstrncpy(rfc931, ident, USER_IDENT_SZ);
 #endif
 }
-
@@ -2,6 +2,7 @@
 #define SQUID_ACLFILLED_CHECKLIST_H
 
 #include "acl/Checklist.h"
+#include "acl/forward.h"
 #include "ip/Address.h"
 #if USE_AUTH
 #include "auth/UserRequest.h"
@@ -22,9 +23,6 @@ class HttpReply;
 class ACLFilledChecklist: public ACLChecklist
 {
 public:
-    void *operator new(size_t);
-    void operator delete(void *);
-
     ACLFilledChecklist();
     ACLFilledChecklist(const acl_access *, HttpRequest *, const char *ident);
     ~ACLFilledChecklist();
@@ -72,7 +70,7 @@ class ACLFilledChecklist: public ACLChecklist
 
 #if USE_SSL
     /// SSL [certificate validation] errors, in undefined order
-    Ssl::Errors *sslErrors;
+    Ssl::CertErrors *sslErrors;
     /// The peer certificate
     Ssl::X509_Pointer serverCert;
 #endif
@@ -89,7 +87,7 @@ class ACLFilledChecklist: public ACLChecklist
     /// not implemented; will cause link failures if used
     ACLFilledChecklist &operator=(const ACLFilledChecklist &);
 
-    CBDATA_CLASS(ACLFilledChecklist);
+    CBDATA_CLASS2(ACLFilledChecklist);
 };
 
 /// convenience and safety wrapper for dynamic_cast<ACLFilledChecklist*>
@@ -41,6 +41,7 @@
 #include "acl/AclNameList.h"
 #include "acl/AclDenyInfoList.h"
 #include "acl/Checklist.h"
+#include "acl/Tree.h"
 #include "acl/Strategised.h"
 #include "acl/Gadgets.h"
 #include "ConfigParser.h"
@@ -134,7 +135,7 @@ aclParseDenyInfoLine(AclDenyInfoList ** head)
 
     while ((t = strtok(NULL, w_space))) {
         L = (AclNameList *)memAllocate(MEM_ACL_NAME_LIST);
-        xstrncpy(L->name, t, ACL_NAME_SZ);
+        xstrncpy(L->name, t, ACL_NAME_SZ-1);
         *Tail = L;
         Tail = &L->next;
     }
@@ -153,84 +154,87 @@ aclParseDenyInfoLine(AclDenyInfoList ** head)
 }
 
 void
-aclParseAccessLine(ConfigParser &parser, acl_access ** head)
+aclParseAccessLine(const char *directive, ConfigParser &, acl_access **treep)
 {
-    char *t = NULL;
-    acl_access *A = NULL;
-    acl_access *B = NULL;
-    acl_access **T = NULL;
-
     /* first expect either 'allow' or 'deny' */
+    const char *t = ConfigParser::strtokFile();
 
-    if ((t = strtok(NULL, w_space)) == NULL) {
+    if (!t) {
         debugs(28, DBG_CRITICAL, "aclParseAccessLine: " << cfg_filename << " line " << config_lineno << ": " << config_input_line);
         debugs(28, DBG_CRITICAL, "aclParseAccessLine: missing 'allow' or 'deny'.");
         return;
     }
 
-    A = new acl_access;
-
+    allow_t action = ACCESS_DUNNO;
     if (!strcmp(t, "allow"))
-        A->allow = ACCESS_ALLOWED;
+        action = ACCESS_ALLOWED;
     else if (!strcmp(t, "deny"))
-        A->allow = ACCESS_DENIED;
+        action = ACCESS_DENIED;
     else {
         debugs(28, DBG_CRITICAL, "aclParseAccessLine: " << cfg_filename << " line " << config_lineno << ": " << config_input_line);
         debugs(28, DBG_CRITICAL, "aclParseAccessLine: expecting 'allow' or 'deny', got '" << t << "'.");
-        delete A;
         return;
     }
 
-    aclParseAclList(parser, &A->aclList);
+    const int ruleId = ((treep && *treep) ? (*treep)->childrenCount() : 0) + 1;
+    MemBuf ctxBuf;
+    ctxBuf.init();
+    ctxBuf.Printf("%s#%d", directive, ruleId);
+    ctxBuf.terminate();
 
-    if (A->aclList == NULL) {
-        debugs(28, DBG_CRITICAL, "" << cfg_filename << " line " << config_lineno << ": " << config_input_line);
+    Acl::AndNode *rule = new Acl::AndNode;
+    rule->context(ctxBuf.content(), config_input_line);
+    rule->lineParse();
+    if (rule->empty()) {
+        debugs(28, DBG_CRITICAL, "aclParseAccessLine: " << cfg_filename << " line " << config_lineno << ": " << config_input_line);
         debugs(28, DBG_CRITICAL, "aclParseAccessLine: Access line contains no ACL's, skipping");
-        delete A;
+        delete rule;
         return;
     }
 
-    A->cfgline = xstrdup(config_input_line);
     /* Append to the end of this list */
 
-    for (B = *head, T = head; B; T = &B->next, B = B->next);
-    *T = A;
+    assert(treep);
+    if (!*treep) {
+        *treep = new Acl::Tree;
+        (*treep)->context(directive, config_input_line);
+    }
+
+    (*treep)->add(rule, action);
 
     /* We lock _acl_access structures in ACLChecklist::matchNonBlocking() */
 }
 
+// aclParseAclList does not expect or set actions (cf. aclParseAccessLine)
 void
-aclParseAclList(ConfigParser &parser, ACLList ** head)
+aclParseAclList(ConfigParser &, Acl::Tree **treep, const char *label)
 {
-    ACLList **Tail = head;	/* sane name in the use below */
-    ACL *a = NULL;
-    char *t;
-
-    /* next expect a list of ACL names, possibly preceeded
-     * by '!' for negation */
-
-    while ((t = strtok(NULL, w_space))) {
-        ACLList *L = new ACLList;
-
-        if (*t == '!') {
-            L->negated (true);
-            ++t;
-        }
-
-        debugs(28, 3, "aclParseAclList: looking for ACL name '" << t << "'");
-        a = ACL::FindByName(t);
-
-        if (a == NULL) {
-            debugs(28, DBG_CRITICAL, "aclParseAclList: ACL name '" << t << "' not found.");
-            delete L;
-            parser.destruct();
-            continue;
-        }
-
-        L->_acl = a;
-        *Tail = L;
-        Tail = &L->next;
-    }
+    // accomodate callers unable to convert their ACL list context to string
+    if (!label)
+        label = "...";
+
+    MemBuf ctxLine;
+    ctxLine.init();
+    ctxLine.Printf("(%s %s line)", cfg_directive, label);
+    ctxLine.terminate();
+
+    Acl::AndNode *rule = new Acl::AndNode;
+    rule->context(ctxLine.content(), config_input_line);
+    rule->lineParse();
+
+    MemBuf ctxTree;
+    ctxTree.init();
+    ctxTree.Printf("%s %s", cfg_directive, label);
+    ctxTree.terminate();
+
+    // We want a cbdata-protected Tree (despite giving it only one child node).
+    Acl::Tree *tree = new Acl::Tree;
+    tree->add(rule);
+    tree->context(ctxTree.content(), config_input_line);
+
+    assert(treep);
+    assert(!*treep);
+    *treep = tree;
 }
 
 /*********************/
@@ -253,32 +257,20 @@ aclDestroyAcls(ACL ** head)
 }
 
 void
-aclDestroyAclList(ACLList ** head)
+aclDestroyAclList(ACLList **list)
 {
-    ACLList *l;
     debugs(28, 8, "aclDestroyAclList: invoked");
-
-    for (l = *head; l; l = *head) {
-        *head = l->next;
-        delete l;
-    }
+    assert(list);
+    cbdataFree(*list);
 }
 
 void
 aclDestroyAccessList(acl_access ** list)
 {
-    acl_access *l = NULL;
-    acl_access *next = NULL;
-
-    for (l = *list; l; l = next) {
-        debugs(28, 3, "aclDestroyAccessList: '" << l->cfgline << "'");
-        next = l->next;
-        aclDestroyAclList(&l->aclList);
-        safe_free(l->cfgline);
-        cbdataFree(l);
-    }
-
-    *list = NULL;
+    assert(list);
+    if (*list)
+        debugs(28, 3, "destroying: " << *list << ' ' << (*list)->name);
+    cbdataFree(*list);
 }
 
 /* maex@space.net (06.09.1996)
@@ -2,11 +2,12 @@
 #define SQUID_ACL_GADGETS_H
 
 #include "err_type.h"
+#include "acl/forward.h"
+
+#if HAVE_SSTREAM
+#include <sstream>
+#endif
 
-class acl_access;
-class ACL;
-class AclDenyInfoList;
-class ACLList;
 class ConfigParser;
 class dlink_list;
 class StoreEntry;
@@ -18,10 +19,23 @@ void aclDestroyAccessList(acl_access **list);
 void aclDestroyAcls(ACL **);
 /// \ingroup ACLAPI
 void aclDestroyAclList(ACLList **);
-/// \ingroup ACLAPI
-void aclParseAccessLine(ConfigParser &parser, acl_access **);
-/// \ingroup ACLAPI
-void aclParseAclList(ConfigParser &parser, ACLList **);
+/// Parses a single line of a "action followed by acls" directive (e.g., http_access).
+/// \ingroup ACLAPI
+void aclParseAccessLine(const char *directive, ConfigParser &parser, Acl::Tree **);
+/// Parses a single line of a "some context followed by acls" directive (e.g., note n v).
+/// The label parameter identifies the context (for debugging).
+/// \ingroup ACLAPI
+void aclParseAclList(ConfigParser &parser, Acl::Tree **, const char *label);
+/// Template to convert various context lables to strings. \ingroup ACLAPI
+template <class Any>
+inline
+void aclParseAclList(ConfigParser &parser, Acl::Tree **tree, const Any any)
+{
+    std::ostringstream buf;
+    buf << any;
+    aclParseAclList(parser, tree, buf.str().c_str());
+}
+
 /// \ingroup ACLAPI
 int aclIsProxyAuth(const char *name);
 /// \ingroup ACLAPI
@@ -0,0 +1,108 @@
+#include "squid.h"
+#include "acl/Acl.h"
+#include "acl/BoolOps.h"
+#include "acl/Checklist.h"
+#include "acl/InnerNode.h"
+#include "cache_cf.h"
+#include "ConfigParser.h"
+#include "Debug.h"
+#include "globals.h"
+#include "wordlist.h"
+#include <algorithm>
+
+// "delete acl" class to use with std::for_each() in InnerNode::~InnerNode()
+class AclDeleter
+{
+public:
+    void operator()(ACL* acl) {
+        // Do not delete explicit ACLs; they are maintained by Config.aclList.
+        if (acl && !acl->registered)
+            delete acl;
+    }
+};
+
+Acl::InnerNode::~InnerNode()
+{
+    std::for_each(nodes.begin(), nodes.end(), AclDeleter());
+}
+
+void
+Acl::InnerNode::prepareForUse()
+{
+    std::for_each(nodes.begin(), nodes.end(), std::mem_fun(&ACL::prepareForUse));
+}
+
+bool
+Acl::InnerNode::empty() const
+{
+    return nodes.empty();
+}
+
+void
+Acl::InnerNode::add(ACL *node)
+{
+    assert(node != NULL);
+    nodes.push_back(node);
+}
+
+// one call parses one "acl name acltype name1 name2 ..." line
+// kids use this method to handle [multiple] parse() calls correctly
+void
+Acl::InnerNode::lineParse()
+{
+    // XXX: not precise, may change when looping or parsing multiple lines
+    if (!cfgline)
+        cfgline = xstrdup(config_input_line);
+
+    // expect a list of ACL names, each possibly preceeded by '!' for negation
+
+    while (const char *t = ConfigParser::strtokFile()) {
+        const bool negated = (*t == '!');
+        if (negated)
+            ++t;
+
+        debugs(28, 3, "looking for ACL " << t);
+        ACL *a = ACL::FindByName(t);
+
+        if (a == NULL) {
+            debugs(28, DBG_CRITICAL, "ACL not found: " << t);
+            self_destruct();
+            return;
+        }
+
+        // append(negated ? new NotNode(a) : a);
+        if (negated)
+            add(new NotNode(a));
+        else
+            add(a);
+    }
+
+    return;
+}
+
+wordlist*
+Acl::InnerNode::dump() const
+{
+    wordlist *values = NULL;
+    for (Nodes::const_iterator i = nodes.begin(); i != nodes.end(); ++i)
+        wordlistAdd(&values, (*i)->name);
+    return values;
+}
+
+int
+Acl::InnerNode::match(ACLChecklist *checklist)
+{
+    return doMatch(checklist, nodes.begin());
+}
+
+bool
+Acl::InnerNode::resumeMatchingAt(ACLChecklist *checklist, Nodes::const_iterator pos) const
+{
+    debugs(28, 5, "checking " << name << " at " << (pos-nodes.begin()));
+    const int result = doMatch(checklist, pos);
+    const char *extra = checklist->asyncInProgress() ? " async" : "";
+    debugs(28, 3, "checked: " << name << " = " << result << extra);
+
+    // merges async and failures (-1) into "not matched"
+    return result == 1;
+}
@@ -0,0 +1,48 @@
+#ifndef SQUID_ACL_INNER_NODE_H
+#define SQUID_ACL_INNER_NODE_H
+
+#include "acl/Acl.h"
+#include <vector>
+
+namespace Acl
+{
+
+typedef std::vector<ACL*> Nodes; ///< a collection of nodes
+
+/// An intermediate ACL tree node. Manages a collection of child tree nodes.
+class InnerNode: public ACL
+{
+public:
+    virtual ~InnerNode();
+
+    /// Resumes matching (suspended by an async call) at the given position.
+    bool resumeMatchingAt(ACLChecklist *checklist, Acl::Nodes::const_iterator pos) const;
+
+    /// the number of children nodes
+    Nodes::size_type childrenCount() const { return nodes.size(); }
+
+    /* ACL API */
+    virtual void prepareForUse();
+    virtual bool empty() const;
+    virtual wordlist *dump() const;
+
+    /// parses one "acl name type acl1 acl2..." line, appending to nodes
+    void lineParse();
+
+    /// appends the node to the collection and takes control over it
+    void add(ACL *node);
+
+protected:
+    /// checks whether the nodes match, starting with the given one
+    /// kids determine what a match means for their type of intermediate nodes
+    virtual int doMatch(ACLChecklist *checklist, Nodes::const_iterator start) const = 0;
+
+    /* ACL API */
+    virtual int match(ACLChecklist *checklist);
+
+    std::vector<ACL*> nodes; ///< children nodes of this intermediate node
+};
+
+} // namespace Acl
+
+#endif /* SQUID_ACL_INNER_NODE_H */
@@ -92,24 +92,24 @@ acl_ip_data::toStr(char *buf, int len) const
     char *b3 = NULL;
     int rlen = 0;
 
-    addr1.NtoA(b1, len - rlen );
+    addr1.toStr(b1, len - rlen );
     rlen = strlen(buf);
     b2 = buf + rlen;
 
-    if (!addr2.IsAnyAddr()) {
+    if (!addr2.isAnyAddr()) {
         b2[0] = '-';
         ++rlen;
-        addr2.NtoA(&(b2[1]), len - rlen );
+        addr2.toStr(&(b2[1]), len - rlen );
         rlen = strlen(buf);
     } else
         b2[0] = '\0';
 
     b3 = buf + rlen;
 
-    if (!mask.IsNoAddr()) {
+    if (!mask.isNoAddr()) {
         b3[0] = '/';
         ++rlen;
-        int cidr =  mask.GetCIDR() - (addr1.IsIPv4()?96:0);
+        int cidr =  mask.cidr() - (addr1.isIPv4()?96:0);
         snprintf(&(b3[1]), (len-rlen), "%u", (unsigned int)(cidr<0?0:cidr) );
     } else
         b3[0] = '\0';
@@ -128,12 +128,12 @@ aclIpAddrNetworkCompare(acl_ip_data * const &p, acl_ip_data * const &q)
     Ip::Address A = p->addr1;
 
     /* apply netmask */
-    A.ApplyMask(q->mask);
+    A.applyMask(q->mask);
 
     debugs(28,9, "aclIpAddrNetworkCompare: compare: " << p->addr1 << "/" << q->mask << " (" << A << ")  vs " <<
            q->addr1 << "-" << q->addr2 << "/" << q->mask);
 
-    if (q->addr2.IsAnyAddr()) {       /* single address check */
+    if (q->addr2.isAnyAddr()) {       /* single address check */
 
         return A.matchIPAddr( q->addr1 );
 
@@ -197,7 +197,7 @@ acl_ip_data::DecodeMask(const char *asc, Ip::Address &mask, int ctype)
     int a1 = 0;
 
     /* default is a mask that doesn't change any IP */
-    mask.SetNoAddr();
+    mask.setNoAddr();
 
     if (!asc || !*asc) {
         return true;
@@ -207,24 +207,24 @@ acl_ip_data::DecodeMask(const char *asc, Ip::Address &mask, int ctype)
     if ((sscanf(asc, "%d%c", &a1, &junk)==1) &&
             (a1 <= 128) && (a1  >= 0)
        ) {
-        return mask.ApplyMask(a1, ctype);
+        return mask.applyMask(a1, ctype);
     }
 
     /* dotted notation */
     /* assignment returns true if asc contained an IP address as text */
     if ((mask = asc)) {
         /* HACK: IPv4 netmasks don't cleanly map to IPv6 masks. */
         debugs(28, DBG_CRITICAL, "WARNING: Netmasks are deprecated. Please use CIDR masks instead.");
-        if (mask.IsIPv4()) {
+        if (mask.isIPv4()) {
             /* locate what CIDR mask was _probably_ meant to be in its native protocol format. */
             /* this will completely crap out with a security fail-open if the admin is playing mask tricks */
             /* however, thats their fault, and we do warn. see bug 2601 for the effects if we don't do this. */
-            unsigned int m = mask.GetCIDR();
+            unsigned int m = mask.cidr();
             debugs(28, DBG_CRITICAL, "WARNING: IPv4 netmasks are particularly nasty when used to compare IPv6 to IPv4 ranges.");
             debugs(28, DBG_CRITICAL, "WARNING: For now we will assume you meant to write /" << m);
             /* reset the mask completely, and crop to the CIDR boundary back properly. */
-            mask.SetNoAddr();
-            return mask.ApplyMask(m,AF_INET);
+            mask.setNoAddr();
+            return mask.applyMask(m,AF_INET);
         }
         return true;
     }
@@ -262,9 +262,9 @@ acl_ip_data::FactoryParse(const char *t)
     /* Special ACL RHS "all" matches entire Internet */
     if (strcmp(t, "all") == 0) {
         debugs(28, 9, "aclIpParseIpData: magic 'all' found.");
-        q->addr1.SetAnyAddr();
-        q->addr2.SetEmpty();
-        q->mask.SetAnyAddr();
+        q->addr1.setAnyAddr();
+        q->addr2.setEmpty();
+        q->mask.setAnyAddr();
         return q;
     }
 
@@ -275,18 +275,18 @@ acl_ip_data::FactoryParse(const char *t)
 
         debugs(28,DBG_CRITICAL, "ERROR: '" << t << "' needs to be replaced by the term 'all'.");
         debugs(28,DBG_CRITICAL, "SECURITY NOTICE: Overriding config setting. Using 'all' instead.");
-        q->addr1.SetAnyAddr();
-        q->addr2.SetEmpty();
-        q->mask.SetAnyAddr();
+        q->addr1.setAnyAddr();
+        q->addr2.setEmpty();
+        q->mask.setAnyAddr();
         return q;
     }
 
     /* Special ACL RHS "ipv4" matches IPv4 Internet
      * A nod to IANA; we include the entire class space in case
      * they manage to find a way to recover and use it */
     if (strcmp(t, "ipv4") == 0) {
-        q->mask.SetNoAddr();
-        q->mask.ApplyMask(0, AF_INET);
+        q->mask.setNoAddr();
+        q->mask.applyMask(0, AF_INET);
         return q;
     }
 
@@ -299,59 +299,59 @@ acl_ip_data::FactoryParse(const char *t)
 
         /* Future global unicast space: 1000::/4 */
         q->addr1 = "1000::";
-        q->mask.SetNoAddr();
-        q->mask.ApplyMask(4, AF_INET6);
+        q->mask.setNoAddr();
+        q->mask.applyMask(4, AF_INET6);
 
         /* Current global unicast space: 2000::/4 = (2000::/4 - 3000::/4) */
         q->next = new acl_ip_data;
         q = q->next;
         q->addr1 = "2000::";
-        q->mask.SetNoAddr();
-        q->mask.ApplyMask(3, AF_INET6);
+        q->mask.setNoAddr();
+        q->mask.applyMask(3, AF_INET6);
 
         /* Future global unicast space: 4000::/2 = (4000::/4 - 7000::/4) */
         q->next = new acl_ip_data;
         q = q->next;
         q->addr1 = "4000::";
-        q->mask.SetNoAddr();
-        q->mask.ApplyMask(2, AF_INET6);
+        q->mask.setNoAddr();
+        q->mask.applyMask(2, AF_INET6);
 
         /* Future global unicast space: 8000::/2 = (8000::/4 - B000::/4) */
         q->next = new acl_ip_data;
         q = q->next;
         q->addr1 = "8000::";
-        q->mask.SetNoAddr();
-        q->mask.ApplyMask(2, AF_INET6);
+        q->mask.setNoAddr();
+        q->mask.applyMask(2, AF_INET6);
 
         /* Future global unicast space: C000::/3 = (C000::/4 - D000::/4) */
         q->next = new acl_ip_data;
         q = q->next;
         q->addr1 = "C000::";
-        q->mask.SetNoAddr();
-        q->mask.ApplyMask(3, AF_INET6);
+        q->mask.setNoAddr();
+        q->mask.applyMask(3, AF_INET6);
 
         /* Future global unicast space: E000::/4 */
         q->next = new acl_ip_data;
         q = q->next;
         q->addr1 = "E000::";
-        q->mask.SetNoAddr();
-        q->mask.ApplyMask(4, AF_INET6);
+        q->mask.setNoAddr();
+        q->mask.applyMask(4, AF_INET6);
 
         /* F000::/4 is mostly reserved non-unicast. With some exceptions ... */
 
         /* RFC 4193 Unique-Local unicast space: FC00::/7 */
         q->next = new acl_ip_data;
         q = q->next;
         q->addr1 = "FC00::";
-        q->mask.SetNoAddr();
-        q->mask.ApplyMask(7, AF_INET6);
+        q->mask.setNoAddr();
+        q->mask.applyMask(7, AF_INET6);
 
         /* Link-Local unicast space: FE80::/10 */
         q->next = new acl_ip_data;
         q = q->next;
         q->addr1 = "FE80::";
-        q->mask.SetNoAddr();
-        q->mask.ApplyMask(10, AF_INET6);
+        q->mask.setNoAddr();
+        q->mask.applyMask(10, AF_INET6);
 
         return r;
     }
@@ -438,8 +438,8 @@ acl_ip_data::FactoryParse(const char *t)
 
             debugs(28, 3, "aclIpParseIpData: Located host/IP: '" << r->addr1 << "'");
 
-            r->addr2.SetAnyAddr();
-            r->mask.SetNoAddr();
+            r->addr2.setAnyAddr();
+            r->mask.setNoAddr();
 
             Q = &r->next;
 
@@ -474,7 +474,7 @@ acl_ip_data::FactoryParse(const char *t)
 
     /* Decode addr2 */
     if (!*addr2)
-        q->addr2.SetAnyAddr();
+        q->addr2.setAnyAddr();
     else if (!(q->addr2=addr2) ) {
         debugs(28, DBG_CRITICAL, "aclIpParseIpData: unknown second address in '" << t << "'");
         delete q;
@@ -491,13 +491,13 @@ acl_ip_data::FactoryParse(const char *t)
     }
 
     changed = 0;
-    changed += q->addr1.ApplyMask(q->mask);
-    changed += q->addr2.ApplyMask(q->mask);
+    changed += q->addr1.applyMask(q->mask);
+    changed += q->addr2.applyMask(q->mask);
 
     if (changed)
         debugs(28, DBG_CRITICAL, "aclIpParseIpData: WARNING: Netmask masks away part of the specified IP in '" << t << "'");
 
-    debugs(28,9, HERE << "Parsed: " << q->addr1 << "-" << q->addr2 << "/" << q->mask << "(/" << q->mask.GetCIDR() <<")");
+    debugs(28,9, HERE << "Parsed: " << q->addr1 << "-" << q->addr2 << "/" << q->mask << "(/" << q->mask.cidr() <<")");
 
     /* 1.2.3.4/255.255.255.0  --> 1.2.3.0 */
     /* Same as IPv6 (not so trivial to depict) */
@@ -507,14 +507,9 @@ acl_ip_data::FactoryParse(const char *t)
 void
 ACLIP::parse()
 {
-    char *t = NULL;
+    flags.parseFlags();
 
-    flags.parseFlags(t);
-
-    if (!t)
-        return;
-
-    do {
+    while (char *t = strtokFile()) {
         acl_ip_data *q = acl_ip_data::FactoryParse(t);
 
         while (q != NULL) {
@@ -524,7 +519,7 @@ ACLIP::parse()
             data = data->insert(q, acl_ip_data::NetworkCompare);
             q = next_node;
         }
-    } while ((t = strtokFile()));
+    }
 }
 
 ACLIP::~ACLIP()
@@ -558,8 +553,8 @@ ACLIP::match(Ip::Address &clientip)
      * MUST be set to empty.
      */
     ClientAddress.addr1 = clientip;
-    ClientAddress.addr2.SetEmpty();
-    ClientAddress.mask.SetEmpty();
+    ClientAddress.addr2.setEmpty();
+    ClientAddress.mask.setEmpty();
 
     data = data->splay(&ClientAddress, aclIpAddrNetworkCompare);
     debugs(28, 3, "aclIpMatchIp: '" << clientip << "' " << (splayLastResult ? "NOT found" : "found"));
@@ -39,7 +39,7 @@
 int
 ACLLocalPortStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
 {
-    return data->match (checklist->my_addr.GetPort());
+    return data->match (checklist->my_addr.port());
 }
 
 ACLLocalPortStrategy *
@@ -7,8 +7,15 @@ noinst_LTLIBRARIES = libapi.la libstate.la libacls.la
 libapi_la_SOURCES = \
 	Acl.cc \
 	Acl.h \
+	BoolOps.cc \
+	BoolOps.h \
 	Checklist.cc \
-	Checklist.h
+	Checklist.h \
+	forward.h \
+	InnerNode.cc \
+	InnerNode.h \
+	Tree.cc \
+	Tree.h
 
 ## Data-dependent Squid/transaction state used by specific ACLs.
 ## Does not refer to specific ACLs to avoid circular dependencies.
@@ -34,6 +41,10 @@ libacls_la_SOURCES = \
 	Time.h \
 	TimeData.cc \
 	TimeData.h \
+	AllOf.cc \
+	AllOf.h \
+	AnyOf.cc \
+	AnyOf.h \
 	Asn.cc \
 	Asn.h \
 	Browser.cc \
@@ -73,6 +84,10 @@ libacls_la_SOURCES = \
 	Method.h \
 	MyPortName.cc \
 	MyPortName.h \
+	Note.h \
+	Note.cc \
+	NoteData.h \
+	NoteData.cc \
 	PeerName.cc \
 	PeerName.h \
 	Protocol.cc \
@@ -0,0 +1,24 @@
+#include "squid.h"
+#include "acl/Note.h"
+#include "acl/HttpHeaderData.h"
+#include "acl/Checklist.h"
+#include "HttpRequest.h"
+#include "Notes.h"
+
+int
+ACLNoteStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
+{
+    if (checklist->request != NULL)
+        return data->match(checklist->request);
+
+    return 0;
+}
+
+ACLNoteStrategy *
+ACLNoteStrategy::Instance()
+{
+    return &Instance_;
+}
+
+ACLNoteStrategy ACLNoteStrategy::Instance_;
+
@@ -0,0 +1,39 @@
+#ifndef SQUID_ACLNOTE_H
+#define SQUID_ACLNOTE_H
+
+#include "acl/Strategy.h"
+#include "acl/Strategised.h"
+
+class HttpRequest;
+
+/// \ingroup ACLAPI
+class ACLNoteStrategy : public ACLStrategy<HttpRequest *>
+{
+
+public:
+    virtual int match (ACLData<MatchType> * &, ACLFilledChecklist *, ACLFlags &);
+    virtual bool requiresRequest() const { return true; }
+
+    static ACLNoteStrategy *Instance();
+    /* Not implemented to prevent copies of the instance. */
+    /* Not private to prevent brain dead g+++ warnings about
+     * private constructors with no friends */
+    ACLNoteStrategy(ACLNoteStrategy const &);
+
+private:
+    static ACLNoteStrategy Instance_;
+    ACLNoteStrategy() { }
+
+    ACLNoteStrategy& operator = (ACLNoteStrategy const &);
+};
+
+/// \ingroup ACLAPI
+class ACLNote
+{
+
+private:
+    static ACL::Prototype RegistryProtoype;
+    static ACLStrategised<HttpRequest *> RegistryEntry_;
+};
+
+#endif /* SQUID_ACLNOTE_H */
@@ -0,0 +1,87 @@
+#include "squid.h"
+#include "acl/Acl.h"
+#include "acl/Checklist.h"
+#include "acl/NoteData.h"
+#include "acl/StringData.h"
+#include "cache_cf.h"
+#include "ConfigParser.h"
+#include "Debug.h"
+#include "HttpRequest.h"
+#include "Notes.h"
+#include "wordlist.h"
+
+ACLNoteData::ACLNoteData() : values(new ACLStringData)
+{}
+
+ACLNoteData::~ACLNoteData()
+{
+    delete values;
+}
+
+bool
+ACLNoteData::matchNotes(NotePairs *note)
+{
+    if (note == NULL)
+        return false;
+
+    debugs(28, 3, "Checking " << name);
+
+    if (values->empty())
+        return (note->findFirst(name.termedBuf()) != NULL);
+
+    for (Vector<NotePairs::Entry *>::iterator i = note->entries.begin(); i!= note->entries.end(); ++i) {
+        if ((*i)->name.cmp(name.termedBuf()) == 0) {
+            if (values->match((*i)->value.termedBuf()))
+                return true;
+        }
+    }
+    return false;
+}
+
+bool
+ACLNoteData::match(HttpRequest *request)
+{
+    if (request->notes != NULL && matchNotes(request->notes.getRaw()))
+        return true;
+#if USE_ADAPTATION
+    const Adaptation::History::Pointer ah = request->adaptLogHistory();
+    if (ah != NULL && ah->metaHeaders != NULL && matchNotes(ah->metaHeaders.getRaw()))
+        return true;
+#endif
+    return false;
+}
+
+wordlist *
+ACLNoteData::dump()
+{
+    wordlist *W = NULL;
+    wordlistAdd(&W, name.termedBuf());
+    wordlist * dumpR = values->dump();
+    wordlistAddWl(&W, dumpR);
+    wordlistDestroy(&dumpR);
+    return W;
+}
+
+void
+ACLNoteData::parse()
+{
+    char* t = strtokFile();
+    assert (t != NULL);
+    name = t;
+    values->parse();
+}
+
+bool
+ACLNoteData::empty() const
+{
+    return name.undefined();
+}
+
+ACLData<HttpRequest *> *
+ACLNoteData::clone() const
+{
+    ACLNoteData * result = new ACLNoteData;
+    result->values = values->clone();
+    result->name = name;
+    return result;
+}
@@ -0,0 +1,33 @@
+#ifndef SQUID_ACLNOTEDATA_H
+#define SQUID_ACLNOTEDATA_H
+
+#include "acl/Data.h"
+#include "SquidString.h"
+#include "MemPool.h"
+
+class HttpRequest;
+class NotePairs;
+
+/// \ingroup ACLAPI
+class ACLNoteData : public ACLData<HttpRequest *>
+{
+public:
+    MEMPROXY_CLASS(ACLNoteData);
+
+    ACLNoteData();
+    virtual ~ACLNoteData();
+    virtual bool match(HttpRequest* request);
+    virtual wordlist *dump();
+    virtual void parse();
+    virtual bool empty() const;
+    virtual ACLData<HttpRequest *> *clone() const;
+
+private:
+    bool matchNotes(NotePairs *note);
+    String name;                   ///< Note name to check. It is always set
+    ACLData<char const *> *values; ///< if set, at least one value must match
+};
+
+MEMPROXY_CLASS_INLINE(ACLNoteData);
+
+#endif /* SQUID_ACLNOTEDATA_H */
@@ -51,21 +51,16 @@ SourceDomainLookup::Instance()
 void
 SourceDomainLookup::checkForAsync(ACLChecklist *checklist) const
 {
-    checklist->asyncInProgress(true);
     fqdncache_nbgethostbyaddr(Filled(checklist)->src_addr, LookupDone, checklist);
 }
 
 void
 SourceDomainLookup::LookupDone(const char *fqdn, const DnsLookupDetails &details, void *data)
 {
     ACLFilledChecklist *checklist = Filled((ACLChecklist*)data);
-    assert (checklist->asyncState() == SourceDomainLookup::Instance());
-
-    checklist->asyncInProgress(false);
-    checklist->changeState (ACLChecklist::NullState::Instance());
     checklist->markSourceDomainChecked();
     checklist->request->recordLookup(details);
-    checklist->matchNonBlocking();
+    checklist->resumeNonBlockingCheck(SourceDomainLookup::Instance());
 }
 
 int
@@ -79,8 +74,9 @@ ACLSourceDomainStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist *
     } else if (!checklist->sourceDomainChecked()) {
         /* FIXME: Using AclMatchedName here is not OO correct. Should find a way to the current acl */
         debugs(28, 3, "aclMatchAcl: Can't yet compare '" << AclMatchedName << "' ACL for '" << checklist->src_addr << "'");
-        checklist->changeState(SourceDomainLookup::Instance());
-        return 0;
+        if (checklist->goAsync(SourceDomainLookup::Instance()))
+            return -1;
+        // else fall through to "none" match, hiding the lookup failure (XXX)
     }
 
     return data->match("none");
@@ -4,7 +4,7 @@
 #include "acl/Strategised.h"
 #include "ssl/support.h"
 
-class ACLSslErrorStrategy : public ACLStrategy<const Ssl::Errors *>
+class ACLSslErrorStrategy : public ACLStrategy<const Ssl::CertErrors *>
 {
 
 public:
@@ -27,7 +27,7 @@ class ACLSslError
 
 private:
     static ACL::Prototype RegistryProtoype;
-    static ACLStrategised<const Ssl::Errors *> RegistryEntry_;
+    static ACLStrategised<const Ssl::CertErrors *> RegistryEntry_;
 };
 
 #endif /* SQUID_ACLSSL_ERROR_H */
@@ -52,10 +52,10 @@ ACLSslErrorData::~ACLSslErrorData()
 }
 
 bool
-ACLSslErrorData::match(const Ssl::Errors *toFind)
+ACLSslErrorData::match(const Ssl::CertErrors *toFind)
 {
-    for (const Ssl::Errors *err = toFind; err; err = err->next ) {
-        if (values->findAndTune(err->element))
+    for (const Ssl::CertErrors *err = toFind; err; err = err->next ) {
+        if (values->findAndTune(err->element.code))
             return true;
     }
     return false;
@@ -7,7 +7,7 @@
 #include "ssl/ErrorDetail.h"
 #include <vector>
 
-class ACLSslErrorData : public ACLData<const Ssl::Errors *>
+class ACLSslErrorData : public ACLData<const Ssl::CertErrors *>
 {
 
 public:
@@ -17,7 +17,7 @@ class ACLSslErrorData : public ACLData<const Ssl::Errors *>
     ACLSslErrorData(ACLSslErrorData const &);
     ACLSslErrorData &operator= (ACLSslErrorData const &);
     virtual ~ACLSslErrorData();
-    bool match(const Ssl::Errors *);
+    bool match(const Ssl::CertErrors *);
     wordlist *dump();
     void parse();
     bool empty() const;
@@ -0,0 +1,75 @@
+#include "squid.h"
+#include "acl/Tree.h"
+#include "wordlist.h"
+
+CBDATA_NAMESPACED_CLASS_INIT(Acl, Tree);
+
+allow_t
+Acl::Tree::winningAction() const
+{
+    return actionAt(lastMatch_ - nodes.begin());
+}
+
+allow_t
+Acl::Tree::lastAction() const
+{
+    if (actions.empty())
+        return ACCESS_DUNNO;
+    return actions.back();
+}
+
+/// computes action that corresponds to the position of the matched rule
+allow_t
+Acl::Tree::actionAt(const Nodes::size_type pos) const
+{
+    assert(pos < nodes.size());
+    if (actions.size()) {
+        assert(actions.size() == nodes.size());
+        return actions[pos];
+    }
+    // default for matched rules in trees without actions
+    return ACCESS_ALLOWED;
+}
+
+void
+Acl::Tree::add(ACL *rule, const allow_t &action)
+{
+    // either all rules have actions or none
+    assert(nodes.size() == actions.size());
+    InnerNode::add(rule);
+    actions.push_back(action);
+}
+
+void
+Acl::Tree::add(ACL *rule)
+{
+    // either all rules have actions or none
+    assert(actions.empty());
+    InnerNode::add(rule);
+}
+
+wordlist*
+Acl::Tree::treeDump(const char *prefix, const ActionToString &convert) const
+{
+    wordlist *text = NULL;
+    Actions::const_iterator action = actions.begin();
+    typedef Nodes::const_iterator NCI;
+    for (NCI node = nodes.begin(); node != nodes.end(); ++node) {
+
+        wordlistAdd(&text, prefix);
+
+        if (action != actions.end()) {
+            const char *act = convert ? convert[action->kind] :
+                              (*action == ACCESS_ALLOWED ? "allow" : "deny");
+            wordlistAdd(&text, act ? act : "???");
+            ++action;
+        }
+
+        wordlist *rule = (*node)->dump();
+        wordlistAddWl(&text, rule);
+        wordlistDestroy(&rule);
+
+        wordlistAdd(&text, "\n");
+    }
+    return text;
+}
@@ -0,0 +1,44 @@
+#ifndef SQUID_ACL_TREE_H
+#define SQUID_ACL_TREE_H
+
+#include "acl/BoolOps.h"
+
+namespace Acl
+{
+
+/// An ORed set of rules at the top of the ACL expression tree, providing two
+/// unique properties: cbdata protection and optional rule actions.
+class Tree: public OrNode
+{
+public:
+    /// dumps <name, action, rule, new line> tuples
+    /// action.kind is mapped to a string using the supplied conversion table
+    typedef const char **ActionToString;
+    wordlist* treeDump(const char *name, const ActionToString &convert) const;
+
+    /// Returns the corresponding action after a successful tree match.
+    allow_t winningAction() const;
+
+    /// what action to use if no nodes matched
+    allow_t lastAction() const;
+
+    /// appends and takes control over the rule with a given action
+    void add(ACL *rule, const allow_t &action);
+    void add(ACL *rule); ///< same as InnerNode::add()
+
+protected:
+    allow_t actionAt(const Nodes::size_type pos) const;
+
+    /// if not empty, contains actions corresponding to InnerNode::nodes
+    typedef std::vector<allow_t> Actions;
+    Actions actions;
+
+private:
+    // XXX: We should use refcounting instead, but it requires making ACLs
+    // refcounted as well. Otherwise, async lookups will reach deleted ACLs.
+    CBDATA_CLASS2(Tree);
+};
+
+} // namespace Acl
+
+#endif /* SQUID_ACL_TREE_H */
@@ -0,0 +1,31 @@
+#ifndef SQUID_ACL_FORWARD_H
+#define SQUID_ACL_FORWARD_H
+
+class ACL;
+class ACLChecklist;
+class ACLFilledChecklist;
+class ACLList;
+
+class AclAddress;
+class AclDenyInfoList;
+class AclSizeLimit;
+
+namespace Acl
+{
+
+class InnerNode;
+class NotNode;
+class AndNode;
+class OrNode;
+class Tree;
+
+} // namespace Acl
+
+#define ACL_NAME_SZ 64
+
+// TODO: Consider renaming all users and removing. Cons: hides the difference
+// between ACLList tree without actions and acl_access Tree with actions.
+#define acl_access Acl::Tree
+#define ACLList Acl::Tree
+
+#endif /* SQUID_ACL_FORWARD_H */
@@ -20,7 +20,7 @@ Adaptation::AccessRule::~AccessRule()
 void
 Adaptation::AccessRule::parse(ConfigParser &parser)
 {
-    aclParseAccessLine(parser, &acl);
+    aclParseAccessLine("adaptation_access", parser, &acl);
 }
 
 void
@@ -1,10 +1,10 @@
 #ifndef SQUID_ADAPTATION__ACCESS_RULE_H
 #define SQUID_ADAPTATION__ACCESS_RULE_H
 
-#include "SquidString.h"
+#include "acl/forward.h"
 #include "adaptation/forward.h"
+#include "SquidString.h"
 
-class acl_access;
 class ConfigParser;
 
 namespace Adaptation
@@ -36,7 +36,7 @@
 #include "adaptation/History.h"
 #include "adaptation/Service.h"
 #include "adaptation/ServiceGroups.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "ConfigParser.h"
 #include "globals.h"
 #include "HttpReply.h"
@@ -2,14 +2,13 @@
 #define SQUID_ADAPTATION__CONFIG_H
 
 #include "event.h"
-#include "acl/Gadgets.h"
+#include "acl/forward.h"
 #include "base/AsyncCall.h"
 #include "adaptation/forward.h"
 #include "adaptation/Elements.h"
 #include "Notes.h"
 #include "SquidString.h"
 
-class acl_access;
 class ConfigParser;
 class HttpRequest;
 class HttpReply;
@@ -1,7 +1,7 @@
 #ifndef SQUID_ADAPTATION__DYNAMIC_GROUP_CFG_H
 #define SQUID_ADAPTATION__DYNAMIC_GROUP_CFG_H
 
-#include "Array.h"
+#include "base/Vector.h"
 #include "SquidString.h"
 
 namespace Adaptation
@@ -2,7 +2,7 @@
 #define SQUID_ADAPT_HISTORY_H
 
 #include "adaptation/DynamicGroupCfg.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "base/RefCount.h"
 #include "HttpHeader.h"
 #include "Notes.h"
@@ -53,7 +53,7 @@ class History: public RefCountable
     HttpHeader allMeta;
     /// key:value pairs set by adaptation_meta, to be added to
     /// AccessLogEntry::notes when ALE becomes available
-    NotePairs metaHeaders;
+    NotePairs::Pointer metaHeaders;
 
     /// sets future services for the Adaptation::AccessCheck to notice
     void setFutureServices(const DynamicGroupCfg &services);
@@ -2,7 +2,7 @@
 #define SQUID_ADAPTATION__SERVICE_GROUPS_H
 
 #include "SquidString.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "adaptation/Elements.h"
 #include "adaptation/forward.h"
 #include "base/RefCount.h"
@@ -305,7 +305,7 @@ Adaptation::Ecap::StatusLineRep::statusCode() const
 void
 Adaptation::Ecap::StatusLineRep::reasonPhrase(const Area &str)
 {
-    theMessage.sline.set(theMessage.sline.version, theMessage.sline.status(), str.c_str());
+    theMessage.sline.set(theMessage.sline.version, theMessage.sline.status(), str.toString().c_str());
 }
 
 Adaptation::Ecap::StatusLineRep::Area
@@ -124,9 +124,9 @@ Adaptation::Ecap::XactionRep::clientIpValue() const
         } else
 #endif
             client_addr = request->client_addr;
-        if (!client_addr.IsAnyAddr() && !client_addr.IsNoAddr()) {
+        if (!client_addr.isAnyAddr() && !client_addr.isNoAddr()) {
             char ntoabuf[MAX_IPSTRLEN] = "";
-            client_addr.NtoA(ntoabuf,MAX_IPSTRLEN);
+            client_addr.toStr(ntoabuf,MAX_IPSTRLEN);
             return libecap::Area::FromTempBuffer(ntoabuf, strlen(ntoabuf));
         }
     }
@@ -231,8 +231,11 @@ Adaptation::Ecap::XactionRep::start()
         typedef Notes::iterator ACAMLI;
         for (ACAMLI i = Adaptation::Config::metaHeaders.begin(); i != Adaptation::Config::metaHeaders.end(); ++i) {
             const char *v = (*i)->match(request, reply);
-            if (v && !ah->metaHeaders.hasByNameListMember((*i)->key.termedBuf(), v, ',')) {
-                ah->metaHeaders.addEntry(new HttpHeaderEntry(HDR_OTHER, (*i)->key.termedBuf(), v));
+            if (v) {
+                if (ah->metaHeaders == NULL)
+                    ah->metaHeaders = new NotePairs();
+                if (!ah->metaHeaders->hasPair((*i)->key.termedBuf(), v))
+                    ah->metaHeaders->add((*i)->key.termedBuf(), v);
             }
         }
     }
@@ -33,7 +33,7 @@
 #include "squid.h"
 #include "ConfigParser.h"
 #include "Store.h"
-#include "Array.h"
+#include "base/Vector.h"
 #include "adaptation/icap/Config.h"
 #include "adaptation/icap/ServiceRep.h"
 #include "HttpRequest.h"
@@ -36,11 +36,10 @@
 
 #include "event.h"
 #include "base/AsyncCall.h"
+#include "acl/forward.h"
 #include "adaptation/Config.h"
 #include "adaptation/icap/ServiceRep.h"
 
-class acl_access;
-
 namespace Adaptation
 {
 namespace Icap
@@ -1253,9 +1253,11 @@ void prepareLogWithRequestDetails(HttpRequest *, AccessLogEntry::Pointer &);
 void Adaptation::Icap::ModXact::finalizeLogInfo()
 {
     HttpRequest * request_ = NULL;
+    HttpRequest * adapted_request_ = NULL;
     HttpReply * reply_ = NULL;
-    if (!(request_ = dynamic_cast<HttpRequest*>(adapted.header))) {
-        request_ = (virgin.cause? virgin.cause: dynamic_cast<HttpRequest*>(virgin.header));
+    request_ = (virgin.cause? virgin.cause: dynamic_cast<HttpRequest*>(virgin.header));
+    if (!(adapted_request_ = dynamic_cast<HttpRequest*>(adapted.header))) {
+        adapted_request_ = request_;
         reply_ = dynamic_cast<HttpReply*>(adapted.header);
     }
 
@@ -1270,6 +1272,9 @@ void Adaptation::Icap::ModXact::finalizeLogInfo()
 
     al.request = request_;
     HTTPMSGLOCK(al.request);
+    al.adapted_request = adapted_request_;
+    HTTPMSGLOCK(al.adapted_request);
+
     if (reply_) {
         al.reply = reply_;
         HTTPMSGLOCK(al.reply);
@@ -1314,7 +1319,7 @@ void Adaptation::Icap::ModXact::finalizeLogInfo()
         packerClean(&p);
         mb.clean();
     }
-    prepareLogWithRequestDetails(request_, alep);
+    prepareLogWithRequestDetails(adapted_request_, alep);
     Xaction::finalizeLogInfo();
 }
 
@@ -1413,8 +1418,8 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
         } else
 #endif
             client_addr = request->client_addr;
-        if (!client_addr.IsAnyAddr() && !client_addr.IsNoAddr())
-            buf.Printf("X-Client-IP: %s\r\n", client_addr.NtoA(ntoabuf,MAX_IPSTRLEN));
+        if (!client_addr.isAnyAddr() && !client_addr.isNoAddr())
+            buf.Printf("X-Client-IP: %s\r\n", client_addr.toStr(ntoabuf,MAX_IPSTRLEN));
     }
 
     if (TheConfig.send_username && request)
@@ -1432,8 +1437,12 @@ void Adaptation::Icap::ModXact::makeRequestHeaders(MemBuf &buf)
         if (const char *value = (*i)->match(r, reply)) {
             buf.Printf("%s: %s\r\n", (*i)->key.termedBuf(), value);
             Adaptation::History::Pointer ah = request->adaptHistory(false);
-            if (ah != NULL && !ah->metaHeaders.hasByNameListMember((*i)->key.termedBuf(), value, ','))
-                ah->metaHeaders.addEntry(new HttpHeaderEntry(HDR_OTHER, (*i)->key.termedBuf(), value));
+            if (ah != NULL) {
+                if (ah->metaHeaders == NULL)
+                    ah->metaHeaders = new NotePairs;
+                if (!ah->metaHeaders->hasPair((*i)->key.termedBuf(), value))
+                    ah->metaHeaders->add((*i)->key.termedBuf(), value);
+            }
         }
     }
 
@@ -3,7 +3,6 @@
  */
 
 #include "squid.h"
-#include "acl/FilledChecklist.h"
 #include "adaptation/icap/Config.h"
 #include "adaptation/icap/Launcher.h"
 #include "adaptation/icap/Xaction.h"
@@ -15,8 +14,7 @@
 #include "CommCalls.h"
 #include "err_detail_type.h"
 #include "fde.h"
-#include "forward.h"
-#include "globals.h"
+#include "FwdState.h"
 #include "HttpMsg.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -166,7 +164,7 @@ Adaptation::Icap::Xaction::dnsLookupDone(const ipcache_addrs *ia)
 
     connection = new Comm::Connection;
     connection->remote = ia->in_addrs[ia->cur];
-    connection->remote.SetPort(s.cfg().port);
+    connection->remote.port(s.cfg().port);
     getOutgoingAddress(NULL, connection);
 
     // TODO: service bypass status may differ from that of a transaction
@@ -550,12 +548,8 @@ void Adaptation::Icap::Xaction::tellQueryAborted()
 void Adaptation::Icap::Xaction::maybeLog()
 {
     if (IcapLogfileStatus == LOG_ENABLE) {
-        ACLChecklist *checklist = new ACLFilledChecklist(::Config.accessList.icap, al.request, dash_str);
-        if (!::Config.accessList.icap || checklist->fastCheck() == ACCESS_ALLOWED) {
-            finalizeLogInfo();
-            icapLogLog(alep, checklist);
-        }
-        delete checklist;
+        finalizeLogInfo();
+        icapLogLog(alep);
     }
 }
 
@@ -1,6 +1,9 @@
 #include "squid.h"
 #include "icap_log.h"
 #include "AccessLogEntry.h"
+#include "acl/FilledChecklist.h"
+#include "HttpReply.h"
+#include "globals.h"
 #include "log/CustomLog.h"
 #include "log/File.h"
 #include "log/Formats.h"
@@ -17,7 +20,7 @@ icapLogOpen()
         if (log->type == Log::Format::CLF_NONE)
             continue;
 
-        log->logfile = logfileOpen(log->filename, MAX_URL << 1, 1);
+        log->logfile = logfileOpen(log->filename, log->bufferSize, log->fatal);
 
         IcapLogfileStatus = LOG_ENABLE;
     }
@@ -46,8 +49,14 @@ icapLogRotate()
     }
 }
 
-void icapLogLog(AccessLogEntry::Pointer &al, ACLChecklist * checklist)
+void icapLogLog(AccessLogEntry::Pointer &al)
 {
-    if (IcapLogfileStatus == LOG_ENABLE)
-        accessLogLogTo(Config.Log.icaplogs, al, checklist);
+    if (IcapLogfileStatus == LOG_ENABLE) {
+        ACLFilledChecklist checklist(NULL, al->adapted_request, NULL);
+        if (al->reply) {
+            checklist.reply = al->reply;
+            HTTPMSGLOCK(checklist.reply);
+        }
+        accessLogLogTo(Config.Log.icaplogs, al, &checklist);
+    }
 }
@@ -11,7 +11,7 @@ class ACLChecklist;
 void icapLogClose();
 void icapLogOpen();
 void icapLogRotate();
-void icapLogLog(AccessLogEntryPointer &al, ACLChecklist * checklist);
+void icapLogLog(AccessLogEntryPointer &al);
 
 extern int IcapLogfileStatus;
 
@@ -4,6 +4,7 @@ include $(top_srcdir)/src/TestHeaders.am
 noinst_LTLIBRARIES = libanyp.la
 
 libanyp_la_SOURCES = \
+	forward.h \
 	PortCfg.cc \
 	PortCfg.h \
 	ProtocolType.cc \
@@ -99,7 +99,7 @@ AnyP::PortCfg::configureSslServerContext()
 
     if (!signingCert) {
         char buf[128];
-        fatalf("No valid signing SSL certificate configured for %s_port %s", protocol,  s.ToURL(buf, sizeof(buf)));
+        fatalf("No valid signing SSL certificate configured for %s_port %s", protocol,  s.toUrl(buf, sizeof(buf)));
     }
 
     if (!signPkey)
@@ -110,7 +110,7 @@ AnyP::PortCfg::configureSslServerContext()
 
     if (!untrustedSigningCert) {
         char buf[128];
-        fatalf("Unable to generate  signing SSL certificate for untrusted sites for %s_port %s", protocol, s.ToURL(buf, sizeof(buf)));
+        fatalf("Unable to generate  signing SSL certificate for untrusted sites for %s_port %s", protocol, s.toUrl(buf, sizeof(buf)));
     }
 
     if (crlfile)
@@ -139,7 +139,7 @@ AnyP::PortCfg::configureSslServerContext()
 
     if (!staticSslContext) {
         char buf[128];
-        fatalf("%s_port %s initialization error", protocol,  s.ToURL(buf, sizeof(buf)));
+        fatalf("%s_port %s initialization error", protocol,  s.toUrl(buf, sizeof(buf)));
     }
 }
 #endif
@@ -1,8 +1,8 @@
 #ifndef SQUID_ANYP_PORTCFG_H
 #define SQUID_ANYP_PORTCFG_H
 
+#include "anyp/forward.h"
 #include "anyp/TrafficMode.h"
-#include "cbdata.h"
 #include "comm/Connection.h"
 
 #if USE_SSL