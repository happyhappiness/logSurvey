@@ -20,6 +20,7 @@
 #include "DelayId.h"
 #include "DelayPool.h"
 #include "DelayPools.h"
+#include "http/Stream.h"
 #include "HttpRequest.h"
 #include "SquidConfig.h"
 
@@ -31,6 +31,7 @@
 #include "gopher.h"
 #include "hier_code.h"
 #include "http.h"
+#include "http/Stream.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "icmp/net_db.h"
@@ -10,6 +10,7 @@
 
 #include "squid.h"
 #include "client_side_request.h"
+#include "http/Stream.h"
 #include "HttpHeaderRange.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
@@ -20,6 +20,7 @@
 #include "fde.h"
 #include "globals.h"
 #include "http/RegisteredHeaders.h"
+#include "http/Stream.h"
 #include "HttpHdrContRange.h"
 #include "HttpHeader.h"
 #include "HttpHeaderFieldInfo.h"
@@ -19,6 +19,7 @@
 #include "gopher.h"
 #include "http.h"
 #include "http/one/RequestParser.h"
+#include "http/Stream.h"
 #include "HttpHdrCc.h"
 #include "HttpHeaderRange.h"
 #include "HttpRequest.h"
@@ -13,6 +13,7 @@
 #include "client_side.h"
 #include "ConfigParser.h"
 #include "globals.h"
+#include "http/Stream.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "SquidConfig.h"
@@ -13,22 +13,23 @@
 #include "anyp/PortCfg.h"
 #include "client_side.h"
 #include "Debug.h"
+#include "http/Stream.h"
 #include "Pipeline.h"
 
 void
-Pipeline::add(const ClientSocketContextPointer &c)
+Pipeline::add(const Http::StreamPointer &c)
 {
     requests.push_back(c);
     ++nrequests;
     debugs(33, 3, "Pipeline " << (void*)this << " add request " << nrequests << ' ' << c);
 }
 
-ClientSocketContextPointer
+Http::StreamPointer
 Pipeline::front() const
 {
     if (requests.empty()) {
         debugs(33, 3, "Pipeline " << (void*)this << " empty");
-        return ClientSocketContextPointer();
+        return Http::StreamPointer();
     }
 
     debugs(33, 3, "Pipeline " << (void*)this << " front " << requests.front());
@@ -39,7 +40,7 @@ void
 Pipeline::terminateAll(int xerrno)
 {
     while (!requests.empty()) {
-        ClientSocketContextPointer context = requests.front();
+        Http::StreamPointer context = requests.front();
         debugs(33, 3, "Pipeline " << (void*)this << " notify(" << xerrno << ") " << context);
         context->noteIoError(xerrno);
         context->finished();  // cleanup and self-deregister
@@ -48,7 +49,7 @@ Pipeline::terminateAll(int xerrno)
 }
 
 void
-Pipeline::popMe(const ClientSocketContextPointer &which)
+Pipeline::popMe(const Http::StreamPointer &which)
 {
     if (requests.empty())
         return;
@@ -10,12 +10,10 @@
 #define SQUID_SRC_PIPELINE_H
 
 #include "base/RefCount.h"
+#include "http/forward.h"
 
 #include <list>
 
-class ClientSocketContext;
-typedef RefCount<ClientSocketContext> ClientSocketContextPointer;
-
 /**
  * A queue of transactions awaiting completion.
  *
@@ -43,10 +41,10 @@ class Pipeline
     ~Pipeline() = default;
 
     /// register a new request context to the pipeline
-    void add(const ClientSocketContextPointer &);
+    void add(const Http::StreamPointer &);
 
     /// get the first request context in the pipeline
-    ClientSocketContextPointer front() const;
+    Http::StreamPointer front() const;
 
     /// how many requests are currently pipelined
     size_t count() const {return requests.size();}
@@ -58,15 +56,15 @@ class Pipeline
     void terminateAll(const int xerrno);
 
     /// deregister the front request from the pipeline
-    void popMe(const ClientSocketContextPointer &);
+    void popMe(const Http::StreamPointer &);
 
     /// Number of requests seen in this pipeline (so far).
     /// Includes incomplete transactions.
     uint32_t nrequests;
 
 private:
     /// requests parsed from the connection but not yet completed.
-    std::list<ClientSocketContextPointer> requests;
+    std::list<Http::StreamPointer> requests;
 };
 
 #endif /* SQUID_SRC_PIPELINE_H */
@@ -14,6 +14,7 @@
 #include "acl/AtStepData.h"
 #include "acl/Checklist.h"
 #include "client_side.h"
+#include "http/Stream.h"
 #include "ssl/ServerBump.h"
 
 int
@@ -21,6 +21,7 @@
 #include "client_side.h"
 #include "fde.h"
 #include "globals.h"
+#include "http/Stream.h"
 #include "HttpRequest.h"
 
 int
@@ -13,6 +13,7 @@
 #include "acl/FilledChecklist.h"
 #include "client_side.h"
 #include "comm/Connection.h"
+#include "http/Stream.h"
 #include "HttpRequest.h"
 #include "SquidConfig.h"
 
@@ -17,6 +17,7 @@
 #include "acl/RegexData.h"
 #include "acl/UserData.h"
 #include "client_side.h"
+#include "http/Stream.h"
 
 ACLExtUser::~ACLExtUser()
 {
@@ -12,6 +12,7 @@
 #include "comm/Connection.h"
 #include "comm/forward.h"
 #include "ExternalACLEntry.h"
+#include "http/Stream.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "SquidConfig.h"
@@ -11,10 +11,9 @@
 #include "acl/MyPortName.h"
 #include "acl/StringData.h"
 #include "anyp/PortCfg.h"
-#include "HttpRequest.h"
-
-/* for ConnStateData */
 #include "client_side.h"
+#include "http/Stream.h"
+#include "HttpRequest.h"
 
 int
 ACLMyPortNameStrategy::match(ACLData<MatchType> * &data, ACLFilledChecklist *checklist, ACLFlags &)
@@ -15,6 +15,7 @@
 #include "acl/ServerCertificate.h"
 #include "client_side.h"
 #include "fde.h"
+#include "http/Stream.h"
 #include "ssl/ServerBump.h"
 
 int
@@ -15,6 +15,7 @@
 #include "acl/ServerName.h"
 #include "client_side.h"
 #include "fde.h"
+#include "http/Stream.h"
 #include "HttpRequest.h"
 #include "ipcache.h"
 #include "SquidString.h"
@@ -14,6 +14,7 @@
 #include "auth/UserRequest.h"
 #include "client_side.h"
 #include "fatal.h"
+#include "http/Stream.h"
 #include "HttpRequest.h"
 
 /**
@@ -18,6 +18,7 @@
 #include "auth/User.h"
 #include "auth/UserRequest.h"
 #include "client_side.h"
+#include "http/Stream.h"
 #include "HttpRequest.h"
 
 ACLProxyAuth::~ACLProxyAuth()
@@ -28,6 +28,7 @@
 #include "auth/UserRequest.h"
 #include "client_side.h"
 #include "globals.h"
+#include "http/Stream.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 
@@ -21,6 +21,7 @@
 #include "comm/Connection.h"
 #include "fatal.h"
 #include "format/Format.h"
+#include "http/Stream.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 #include "MemBuf.h"
@@ -22,6 +22,7 @@
 #include "cache_cf.h"
 #include "client_side.h"
 #include "helper.h"
+#include "http/Stream.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -20,6 +20,7 @@
 #include "globals.h"
 #include "helper.h"
 #include "helper/Reply.h"
+#include "http/Stream.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -22,6 +22,7 @@
 #include "cache_cf.h"
 #include "client_side.h"
 #include "helper.h"
+#include "http/Stream.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -20,6 +20,7 @@
 #include "globals.h"
 #include "helper.h"
 #include "helper/Reply.h"
+#include "http/Stream.h"
 #include "HttpMsg.h"
 #include "HttpRequest.h"
 #include "MemBuf.h"
@@ -11,6 +11,7 @@
 #include "squid.h"
 #include "client_side_request.h"
 #include "clientStream.h"
+#include "http/Stream.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
 
@@ -87,6 +87,7 @@
 #include "http.h"
 #include "http/one/RequestParser.h"
 #include "http/one/TeChunkedParser.h"
+#include "http/Stream.h"
 #include "HttpHdrContRange.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
@@ -188,91 +189,10 @@ static void clientUpdateStatCounters(const LogTags &logType);
 static void clientUpdateHierCounters(HierarchyLogEntry *);
 static bool clientPingHasFinished(ping_data const *aPing);
 void prepareLogWithRequestDetails(HttpRequest *, AccessLogEntry::Pointer &);
-static void ClientSocketContextPushDeferredIfNeeded(ClientSocketContext::Pointer deferredRequest, ConnStateData * conn);
-static void clientUpdateSocketStats(const LogTags &logType, size_t size);
+static void ClientSocketContextPushDeferredIfNeeded(Http::StreamPointer deferredRequest, ConnStateData * conn);
 
 char *skipLeadingSpace(char *aString);
 
-clientStreamNode *
-ClientSocketContext::getTail() const
-{
-    if (http->client_stream.tail)
-        return (clientStreamNode *)http->client_stream.tail->data;
-
-    return NULL;
-}
-
-clientStreamNode *
-ClientSocketContext::getClientReplyContext() const
-{
-    return (clientStreamNode *)http->client_stream.tail->prev->data;
-}
-
-ConnStateData *
-ClientSocketContext::getConn() const
-{
-    return http->getConn();
-}
-
-ClientSocketContext::~ClientSocketContext()
-{
-    clientStreamNode *node = getTail();
-
-    if (node) {
-        ClientSocketContext *streamContext = dynamic_cast<ClientSocketContext *> (node->data.getRaw());
-
-        if (streamContext) {
-            /* We are *always* the tail - prevent recursive free */
-            assert(this == streamContext);
-            node->data = NULL;
-        }
-    }
-
-    httpRequestFree(http);
-}
-
-void
-ClientSocketContext::registerWithConn()
-{
-    assert (!connRegistered_);
-    assert (http);
-    assert (http->getConn() != NULL);
-    connRegistered_ = true;
-    http->getConn()->pipeline.add(ClientSocketContext::Pointer(this));
-}
-
-void
-ClientSocketContext::finished()
-{
-    assert (http);
-    assert (http->getConn() != NULL);
-    ConnStateData *conn = http->getConn();
-
-    /* we can't handle any more stream data - detach */
-    clientStreamDetach(getTail(), http);
-
-    assert(connRegistered_);
-    connRegistered_ = false;
-    assert(conn->pipeline.front() == this); // XXX: still assumes HTTP/1 semantics
-    conn->pipeline.popMe(ClientSocketContext::Pointer(this));
-}
-
-ClientSocketContext::ClientSocketContext(const Comm::ConnectionPointer &aConn, ClientHttpRequest *aReq) :
-    clientConnection(aConn),
-    http(aReq),
-    reply(NULL),
-    writtenToSocket(0),
-    mayUseConnection_ (false),
-    connRegistered_ (false)
-{
-    assert(http != NULL);
-    memset (reqbuf, '\0', sizeof (reqbuf));
-    flags.deferred = 0;
-    flags.parsed_ok = 0;
-    deferredparams.node = NULL;
-    deferredparams.rep = NULL;
-}
-
 #if USE_IDENT
 static void
 clientIdentDone(const char *ident, void *data)
@@ -765,137 +685,28 @@ clientIsRequestBodyTooLargeForPolicy(int64_t bodyLength)
     return 0;
 }
 
-void
-ClientSocketContext::deferRecipientForLater(clientStreamNode * node, HttpReply * rep, StoreIOBuffer receivedData)
-{
-    debugs(33, 2, "clientSocketRecipient: Deferring request " << http->uri);
-    assert(flags.deferred == 0);
-    flags.deferred = 1;
-    deferredparams.node = node;
-    deferredparams.rep = rep;
-    deferredparams.queuedBuffer = receivedData;
-    return;
-}
-
-bool
-ClientSocketContext::startOfOutput() const
-{
-    return http->out.size == 0;
-}
-
-size_t
-ClientSocketContext::lengthToSend(Range<int64_t> const &available)
-{
-    /*the size of available range can always fit in a size_t type*/
-    size_t maximum = (size_t)available.size();
-
-    if (!http->request->range)
-        return maximum;
-
-    assert (canPackMoreRanges());
-
-    if (http->range_iter.debt() == -1)
-        return maximum;
-
-    assert (http->range_iter.debt() > 0);
-
-    /* TODO this + the last line could be a range intersection calculation */
-    if (available.start < http->range_iter.currentSpec()->offset)
-        return 0;
-
-    return min(http->range_iter.debt(), (int64_t)maximum);
-}
-
-void
-ClientSocketContext::noteSentBodyBytes(size_t bytes)
-{
-    debugs(33, 7, bytes << " body bytes");
-
-    http->out.offset += bytes;
-
-    if (!http->request->range)
-        return;
-
-    if (http->range_iter.debt() != -1) {
-        http->range_iter.debt(http->range_iter.debt() - bytes);
-        assert (http->range_iter.debt() >= 0);
-    }
-
-    /* debt() always stops at -1, below that is a bug */
-    assert (http->range_iter.debt() >= -1);
-}
-
 bool
 ClientHttpRequest::multipartRangeRequest() const
 {
     return request->multipartRangeRequest();
 }
 
-bool
-ClientSocketContext::multipartRangeRequest() const
-{
-    return http->multipartRangeRequest();
-}
-
-void
-ClientSocketContext::sendBody(HttpReply * rep, StoreIOBuffer bodyData)
-{
-    assert(rep == NULL);
-
-    if (!multipartRangeRequest() && !http->request->flags.chunkedReply) {
-        size_t length = lengthToSend(bodyData.range());
-        noteSentBodyBytes (length);
-        getConn()->write(bodyData.data, length);
-        return;
-    }
-
-    MemBuf mb;
-    mb.init();
-    if (multipartRangeRequest())
-        packRange(bodyData, &mb);
-    else
-        packChunk(bodyData, mb);
-
-    if (mb.contentSize())
-        getConn()->write(&mb);
-    else
-        writeComplete(0);
-}
-
-/**
- * Packs bodyData into mb using chunked encoding. Packs the last-chunk
- * if bodyData is empty.
- */
 void
-ClientSocketContext::packChunk(const StoreIOBuffer &bodyData, MemBuf &mb)
-{
-    const uint64_t length =
-        static_cast<uint64_t>(lengthToSend(bodyData.range()));
-    noteSentBodyBytes(length);
-
-    mb.appendf("%" PRIX64 "\r\n", length);
-    mb.append(bodyData.data, length);
-    mb.append("\r\n", 2);
-}
-
-/** put terminating boundary for multiparts */
-static void
-clientPackTermBound(String boundary, MemBuf * mb)
+clientPackTermBound(String boundary, MemBuf *mb)
 {
     mb->appendf("\r\n--" SQUIDSTRINGPH "--\r\n", SQUIDSTRINGPRINT(boundary));
-    debugs(33, 6, "clientPackTermBound: buf offset: " << mb->size);
+    debugs(33, 6, "buf offset: " << mb->size);
 }
 
-/** appends a "part" HTTP header (as in a multi-part/range reply) to the buffer */
-static void
+void
 clientPackRangeHdr(const HttpReply * rep, const HttpHdrRangeSpec * spec, String boundary, MemBuf * mb)
 {
     HttpHeader hdr(hoReply);
     assert(rep);
     assert(spec);
 
     /* put boundary */
-    debugs(33, 5, "clientPackRangeHdr: appending boundary: " << boundary);
+    debugs(33, 5, "appending boundary: " << boundary);
     /* rfc2046 requires to _prepend_ boundary with <crlf>! */
     mb->appendf("\r\n--" SQUIDSTRINGPH "\r\n", SQUIDSTRINGPRINT(boundary));
 
@@ -913,90 +724,6 @@ clientPackRangeHdr(const HttpReply * rep, const HttpHdrRangeSpec * spec, String
     mb->append("\r\n", 2);
 }
 
-/**
- * extracts a "range" from *buf and appends them to mb, updating
- * all offsets and such.
- */
-void
-ClientSocketContext::packRange(StoreIOBuffer const &source, MemBuf * mb)
-{
-    HttpHdrRangeIter * i = &http->range_iter;
-    Range<int64_t> available (source.range());
-    char const *buf = source.data;
-
-    while (i->currentSpec() && available.size()) {
-        const size_t copy_sz = lengthToSend(available);
-
-        if (copy_sz) {
-            /*
-             * intersection of "have" and "need" ranges must not be empty
-             */
-            assert(http->out.offset < i->currentSpec()->offset + i->currentSpec()->length);
-            assert(http->out.offset + (int64_t)available.size() > i->currentSpec()->offset);
-
-            /*
-             * put boundary and headers at the beginning of a range in a
-             * multi-range
-             */
-
-            if (http->multipartRangeRequest() && i->debt() == i->currentSpec()->length) {
-                assert(http->memObject());
-                clientPackRangeHdr(
-                    http->memObject()->getReply(),  /* original reply */
-                    i->currentSpec(),       /* current range */
-                    i->boundary,    /* boundary, the same for all */
-                    mb);
-            }
-
-            /*
-             * append content
-             */
-            debugs(33, 3, "clientPackRange: appending " << copy_sz << " bytes");
-
-            noteSentBodyBytes (copy_sz);
-
-            mb->append(buf, copy_sz);
-
-            /*
-             * update offsets
-             */
-            available.start += copy_sz;
-
-            buf += copy_sz;
-
-        }
-
-        if (!canPackMoreRanges()) {
-            debugs(33, 3, "clientPackRange: Returning because !canPackMoreRanges.");
-
-            if (i->debt() == 0)
-                /* put terminating boundary for multiparts */
-                clientPackTermBound(i->boundary, mb);
-
-            return;
-        }
-
-        int64_t nextOffset = getNextRangeOffset();
-
-        assert (nextOffset >= http->out.offset);
-
-        int64_t skip = nextOffset - http->out.offset;
-
-        /* adjust for not to be transmitted bytes */
-        http->out.offset = nextOffset;
-
-        if (available.size() <= (uint64_t)skip)
-            return;
-
-        available.start += skip;
-
-        buf += skip;
-
-        if (copy_sz == 0)
-            return;
-    }
-}
-
 /** returns expected content length for multi-range replies
  * note: assumes that httpHdrRangeCanonize has already been called
  * warning: assumes that HTTP headers for individual ranges at the
@@ -1039,44 +766,6 @@ ClientHttpRequest::mRangeCLen()
     return clen;
 }
 
-/**
- * returns true if If-Range specs match reply, false otherwise
- */
-static int
-clientIfRangeMatch(ClientHttpRequest * http, HttpReply * rep)
-{
-    const TimeOrTag spec = http->request->header.getTimeOrTag(Http::HdrType::IF_RANGE);
-    /* check for parsing falure */
-
-    if (!spec.valid)
-        return 0;
-
-    /* got an ETag? */
-    if (spec.tag.str) {
-        ETag rep_tag = rep->header.getETag(Http::HdrType::ETAG);
-        debugs(33, 3, "clientIfRangeMatch: ETags: " << spec.tag.str << " and " <<
-               (rep_tag.str ? rep_tag.str : "<none>"));
-
-        if (!rep_tag.str)
-            return 0;       /* entity has no etag to compare with! */
-
-        if (spec.tag.weak || rep_tag.weak) {
-            debugs(33, DBG_IMPORTANT, "clientIfRangeMatch: Weak ETags are not allowed in If-Range: " << spec.tag.str << " ? " << rep_tag.str);
-            return 0;       /* must use strong validator for sub-range requests */
-        }
-
-        return etagIsStrongEqual(rep_tag, spec.tag);
-    }
-
-    /* got modification time? */
-    if (spec.time >= 0) {
-        return http->storeEntry()->lastmod <= spec.time;
-    }
-
-    assert(0);          /* should not happen */
-    return 0;
-}
-
 /**
  * generates a "unique" boundary string for multipart responses
  * the caller is responsible for cleaning the string */
@@ -1091,165 +780,6 @@ ClientHttpRequest::rangeBoundaryStr() const
     return b;
 }
 
-/** adds appropriate Range headers if needed */
-void
-ClientSocketContext::buildRangeHeader(HttpReply * rep)
-{
-    HttpHeader *hdr = rep ? &rep->header : 0;
-    const char *range_err = NULL;
-    HttpRequest *request = http->request;
-    assert(request->range);
-    /* check if we still want to do ranges */
-
-    int64_t roffLimit = request->getRangeOffsetLimit();
-
-    if (!rep)
-        range_err = "no [parse-able] reply";
-    else if ((rep->sline.status() != Http::scOkay) && (rep->sline.status() != Http::scPartialContent))
-        range_err = "wrong status code";
-    else if (hdr->has(Http::HdrType::CONTENT_RANGE))
-        range_err = "origin server does ranges";
-    else if (rep->content_length < 0)
-        range_err = "unknown length";
-    else if (rep->content_length != http->memObject()->getReply()->content_length)
-        range_err = "INCONSISTENT length";  /* a bug? */
-
-    /* hits only - upstream CachePeer determines correct behaviour on misses, and client_side_reply determines
-     * hits candidates
-     */
-    else if (http->logType.isTcpHit() && http->request->header.has(Http::HdrType::IF_RANGE) && !clientIfRangeMatch(http, rep))
-        range_err = "If-Range match failed";
-    else if (!http->request->range->canonize(rep))
-        range_err = "canonization failed";
-    else if (http->request->range->isComplex())
-        range_err = "too complex range header";
-    else if (!http->logType.isTcpHit() && http->request->range->offsetLimitExceeded(roffLimit))
-        range_err = "range outside range_offset_limit";
-
-    /* get rid of our range specs on error */
-    if (range_err) {
-        /* XXX We do this here because we need canonisation etc. However, this current
-         * code will lead to incorrect store offset requests - the store will have the
-         * offset data, but we won't be requesting it.
-         * So, we can either re-request, or generate an error
-         */
-        http->request->ignoreRange(range_err);
-    } else {
-        /* XXX: TODO: Review, this unconditional set may be wrong. */
-        rep->sline.set(rep->sline.version, Http::scPartialContent);
-        // web server responded with a valid, but unexpected range.
-        // will (try-to) forward as-is.
-        //TODO: we should cope with multirange request/responses
-        bool replyMatchRequest = rep->content_range != NULL ?
-                                 request->range->contains(rep->content_range->spec) :
-                                 true;
-        const int spec_count = http->request->range->specs.size();
-        int64_t actual_clen = -1;
-
-        debugs(33, 3, "clientBuildRangeHeader: range spec count: " <<
-               spec_count << " virgin clen: " << rep->content_length);
-        assert(spec_count > 0);
-        /* append appropriate header(s) */
-
-        if (spec_count == 1) {
-            if (!replyMatchRequest) {
-                hdr->delById(Http::HdrType::CONTENT_RANGE);
-                hdr->putContRange(rep->content_range);
-                actual_clen = rep->content_length;
-                //http->range_iter.pos = rep->content_range->spec.begin();
-                (*http->range_iter.pos)->offset = rep->content_range->spec.offset;
-                (*http->range_iter.pos)->length = rep->content_range->spec.length;
-
-            } else {
-                HttpHdrRange::iterator pos = http->request->range->begin();
-                assert(*pos);
-                /* append Content-Range */
-
-                if (!hdr->has(Http::HdrType::CONTENT_RANGE)) {
-                    /* No content range, so this was a full object we are
-                     * sending parts of.
-                     */
-                    httpHeaderAddContRange(hdr, **pos, rep->content_length);
-                }
-
-                /* set new Content-Length to the actual number of bytes
-                 * transmitted in the message-body */
-                actual_clen = (*pos)->length;
-            }
-        } else {
-            /* multipart! */
-            /* generate boundary string */
-            http->range_iter.boundary = http->rangeBoundaryStr();
-            /* delete old Content-Type, add ours */
-            hdr->delById(Http::HdrType::CONTENT_TYPE);
-            httpHeaderPutStrf(hdr, Http::HdrType::CONTENT_TYPE,
-                              "multipart/byteranges; boundary=\"" SQUIDSTRINGPH "\"",
-                              SQUIDSTRINGPRINT(http->range_iter.boundary));
-            /* Content-Length is not required in multipart responses
-             * but it is always nice to have one */
-            actual_clen = http->mRangeCLen();
-            /* http->out needs to start where we want data at */
-            http->out.offset = http->range_iter.currentSpec()->offset;
-        }
-
-        /* replace Content-Length header */
-        assert(actual_clen >= 0);
-
-        hdr->delById(Http::HdrType::CONTENT_LENGTH);
-
-        hdr->putInt64(Http::HdrType::CONTENT_LENGTH, actual_clen);
-
-        debugs(33, 3, "clientBuildRangeHeader: actual content length: " << actual_clen);
-
-        /* And start the range iter off */
-        http->range_iter.updateSpec();
-    }
-}
-
-void
-ClientSocketContext::prepareReply(HttpReply * rep)
-{
-    reply = rep;
-
-    if (http->request->range)
-        buildRangeHeader(rep);
-}
-
-void
-ClientSocketContext::sendStartOfMessage(HttpReply * rep, StoreIOBuffer bodyData)
-{
-    prepareReply(rep);
-    assert (rep);
-    MemBuf *mb = rep->pack();
-
-    // dump now, so we dont output any body.
-    debugs(11, 2, "HTTP Client " << clientConnection);
-    debugs(11, 2, "HTTP Client REPLY:\n---------\n" << mb->buf << "\n----------");
-
-    /* Save length of headers for persistent conn checks */
-    http->out.headers_sz = mb->contentSize();
-#if HEADERS_LOG
-
-    headersLog(0, 0, http->request->method, rep);
-#endif
-
-    if (bodyData.data && bodyData.length) {
-        if (multipartRangeRequest())
-            packRange(bodyData, mb);
-        else if (http->request->flags.chunkedReply) {
-            packChunk(bodyData, *mb);
-        } else {
-            size_t length = lengthToSend(bodyData.range());
-            noteSentBodyBytes (length);
-
-            mb->append(bodyData.data, length);
-        }
-    }
-
-    getConn()->write(mb);
-    delete mb;
-}
-
 /**
  * Write a chunk of data to a client socket. If the reply is present,
  * send the reply headers down the wire too, and clean them up when
@@ -1277,7 +807,7 @@ clientSocketRecipient(clientStreamNode * node, ClientHttpRequest * http,
      */
     assert(cbdataReferenceValid(node));
     assert(node->node.next == NULL);
-    ClientSocketContext::Pointer context = dynamic_cast<ClientSocketContext *>(node->data.getRaw());
+    Http::StreamPointer context = dynamic_cast<Http::Stream *>(node->data.getRaw());
     assert(context != NULL);
 
     /* TODO: check offset is what we asked for */
@@ -1310,7 +840,7 @@ clientSocketDetach(clientStreamNode * node, ClientHttpRequest * http)
     /* Set null by ContextFree */
     assert(node->node.next == NULL);
     /* this is the assert discussed above */
-    assert(NULL == dynamic_cast<ClientSocketContext *>(node->data.getRaw()));
+    assert(NULL == dynamic_cast<Http::Stream *>(node->data.getRaw()));
     /* We are only called when the client socket shutsdown.
      * Tell the prev pipeline member we're finished
      */
@@ -1336,7 +866,7 @@ ConnStateData::readNextRequest()
 }
 
 static void
-ClientSocketContextPushDeferredIfNeeded(ClientSocketContext::Pointer deferredRequest, ConnStateData * conn)
+ClientSocketContextPushDeferredIfNeeded(Http::StreamPointer deferredRequest, ConnStateData * conn)
 {
     debugs(33, 2, HERE << conn->clientConnection << " Sending next");
 
@@ -1425,7 +955,7 @@ ConnStateData::kick()
      * then look at processing it. If not, simply kickstart
      * another read.
      */
-    ClientSocketContext::Pointer deferredRequest = pipeline.front();
+    Http::StreamPointer deferredRequest = pipeline.front();
     if (deferredRequest != nullptr) {
         debugs(33, 3, clientConnection << ": calling PushDeferredIfNeeded");
         ClientSocketContextPushDeferredIfNeeded(deferredRequest, this);
@@ -1438,190 +968,6 @@ ConnStateData::kick()
     }
 }
 
-void
-clientUpdateSocketStats(const LogTags &logType, size_t size)
-{
-    if (size == 0)
-        return;
-
-    statCounter.client_http.kbytes_out += size;
-
-    if (logType.isTcpHit())
-        statCounter.client_http.hit_kbytes_out += size;
-}
-
-/**
- * increments iterator "i"
- * used by clientPackMoreRanges
- *
- \retval true    there is still data available to pack more ranges
- \retval false
- */
-bool
-ClientSocketContext::canPackMoreRanges() const
-{
-    /** first update iterator "i" if needed */
-
-    if (!http->range_iter.debt()) {
-        debugs(33, 5, HERE << "At end of current range spec for " << clientConnection);
-
-        if (http->range_iter.pos != http->range_iter.end)
-            ++http->range_iter.pos;
-
-        http->range_iter.updateSpec();
-    }
-
-    assert(!http->range_iter.debt() == !http->range_iter.currentSpec());
-
-    /* paranoid sync condition */
-    /* continue condition: need_more_data */
-    debugs(33, 5, "ClientSocketContext::canPackMoreRanges: returning " << (http->range_iter.currentSpec() ? true : false));
-    return http->range_iter.currentSpec() ? true : false;
-}
-
-int64_t
-ClientSocketContext::getNextRangeOffset() const
-{
-    debugs (33, 5, "range: " << http->request->range <<
-            "; http offset " << http->out.offset <<
-            "; reply " << reply);
-
-    // XXX: This method is called from many places, including pullData() which
-    // may be called before prepareReply() [on some Squid-generated errors].
-    // Hence, we may not even know yet whether we should honor/do ranges.
-
-    if (http->request->range) {
-        /* offset in range specs does not count the prefix of an http msg */
-        /* check: reply was parsed and range iterator was initialized */
-        assert(http->range_iter.valid);
-        /* filter out data according to range specs */
-        assert (canPackMoreRanges());
-        {
-            int64_t start;      /* offset of still missing data */
-            assert(http->range_iter.currentSpec());
-            start = http->range_iter.currentSpec()->offset + http->range_iter.currentSpec()->length - http->range_iter.debt();
-            debugs(33, 3, "clientPackMoreRanges: in:  offset: " << http->out.offset);
-            debugs(33, 3, "clientPackMoreRanges: out:"
-                   " start: " << start <<
-                   " spec[" << http->range_iter.pos - http->request->range->begin() << "]:" <<
-                   " [" << http->range_iter.currentSpec()->offset <<
-                   ", " << http->range_iter.currentSpec()->offset + http->range_iter.currentSpec()->length << "),"
-                   " len: " << http->range_iter.currentSpec()->length <<
-                   " debt: " << http->range_iter.debt());
-            if (http->range_iter.currentSpec()->length != -1)
-                assert(http->out.offset <= start);  /* we did not miss it */
-
-            return start;
-        }
-
-    } else if (reply && reply->content_range) {
-        /* request does not have ranges, but reply does */
-        /** \todo FIXME: should use range_iter_pos on reply, as soon as reply->content_range
-         *        becomes HttpHdrRange rather than HttpHdrRangeSpec.
-         */
-        return http->out.offset + reply->content_range->spec.offset;
-    }
-
-    return http->out.offset;
-}
-
-void
-ClientSocketContext::pullData()
-{
-    debugs(33, 5, reply << " written " << http->out.size << " into " << clientConnection);
-
-    /* More data will be coming from the stream. */
-    StoreIOBuffer readBuffer;
-    /* XXX: Next requested byte in the range sequence */
-    /* XXX: length = getmaximumrangelenfgth */
-    readBuffer.offset = getNextRangeOffset();
-    readBuffer.length = HTTP_REQBUF_SZ;
-    readBuffer.data = reqbuf;
-    /* we may note we have reached the end of the wanted ranges */
-    clientStreamRead(getTail(), http, readBuffer);
-}
-
-/** Adapt stream status to account for Range cases
- *
- */
-clientStream_status_t
-ClientSocketContext::socketState()
-{
-    switch (clientStreamStatus(getTail(), http)) {
-
-    case STREAM_NONE:
-        /* check for range support ending */
-
-        if (http->request->range) {
-            /* check: reply was parsed and range iterator was initialized */
-            assert(http->range_iter.valid);
-            /* filter out data according to range specs */
-
-            if (!canPackMoreRanges()) {
-                debugs(33, 5, HERE << "Range request at end of returnable " <<
-                       "range sequence on " << clientConnection);
-                // we got everything we wanted from the store
-                return STREAM_COMPLETE;
-            }
-        } else if (reply && reply->content_range) {
-            /* reply has content-range, but Squid is not managing ranges */
-            const int64_t &bytesSent = http->out.offset;
-            const int64_t &bytesExpected = reply->content_range->spec.length;
-
-            debugs(33, 7, HERE << "body bytes sent vs. expected: " <<
-                   bytesSent << " ? " << bytesExpected << " (+" <<
-                   reply->content_range->spec.offset << ")");
-
-            // did we get at least what we expected, based on range specs?
-
-            if (bytesSent == bytesExpected) // got everything
-                return STREAM_COMPLETE;
-
-            if (bytesSent > bytesExpected) // Error: Sent more than expected
-                return STREAM_UNPLANNED_COMPLETE;
-        }
-
-        return STREAM_NONE;
-
-    case STREAM_COMPLETE:
-        return STREAM_COMPLETE;
-
-    case STREAM_UNPLANNED_COMPLETE:
-        return STREAM_UNPLANNED_COMPLETE;
-
-    case STREAM_FAILED:
-        return STREAM_FAILED;
-    }
-
-    fatal ("unreachable code\n");
-    return STREAM_NONE;
-}
-
-/// remembers the abnormal connection termination for logging purposes
-void
-ClientSocketContext::noteIoError(const int xerrno)
-{
-    if (http) {
-        http->logType.err.timedout = (xerrno == ETIMEDOUT);
-        // aborted even if xerrno is zero (which means read abort/eof)
-        http->logType.err.aborted = (xerrno != ETIMEDOUT);
-    }
-}
-
-void
-ClientSocketContext::doClose()
-{
-    clientConnection->close();
-}
-
-/// called when we encounter a response-related error
-void
-ClientSocketContext::initiateClose(const char *reason)
-{
-    debugs(33, 4, clientConnection << " because " << reason);
-    http->getConn()->stopSending(reason); // closes ASAP
-}
-
 void
 ConnStateData::stopSending(const char *error)
 {
@@ -1652,64 +998,23 @@ ConnStateData::afterClientWrite(size_t size)
     if (pipeline.empty())
         return;
 
-    pipeline.front()->writeComplete(size);
-}
-
-// TODO: make this only need size parameter, ConnStateData handles the rest
-void
-ClientSocketContext::writeComplete(size_t size)
-{
-    const StoreEntry *entry = http->storeEntry();
-    debugs(33, 5, clientConnection << ", sz " << size <<
-           ", off " << (http->out.size + size) << ", len " <<
-           (entry ? entry->objectLen() : 0));
-
-    http->out.size += size;
-    clientUpdateSocketStats(http->logType, size);
-
-    if (clientHttpRequestStatus(clientConnection->fd, http)) {
-        initiateClose("failure or true request status");
-        /* Do we leak here ? */
-        return;
-    }
-
-    switch (socketState()) {
-
-    case STREAM_NONE:
-        pullData();
-        break;
-
-    case STREAM_COMPLETE: {
-        debugs(33, 5, clientConnection << " Stream complete, keepalive is " << http->request->flags.proxyKeepalive);
-        ConnStateData *c = http->getConn();
-        if (!http->request->flags.proxyKeepalive)
-            clientConnection->close();
-        finished();
-        c->kick();
-    }
-    return;
-
-    case STREAM_UNPLANNED_COMPLETE:
-        initiateClose("STREAM_UNPLANNED_COMPLETE");
-        return;
-
-    case STREAM_FAILED:
-        initiateClose("STREAM_FAILED");
-        return;
-
-    default:
-        fatal("Hit unreachable code in ClientSocketContext::writeComplete\n");
+    auto ctx = pipeline.front();
+    if (size) {
+        statCounter.client_http.kbytes_out += size;
+        if (ctx->http->logType.isTcpHit())
+            statCounter.client_http.hit_kbytes_out += size;
     }
+    ctx->writeComplete(size);
 }
 
-ClientSocketContext *
+Http::Stream *
 ConnStateData::abortRequestParsing(const char *const uri)
 {
     ClientHttpRequest *http = new ClientHttpRequest(this);
     http->req_sz = inBuf.length();
     http->uri = xstrdup(uri);
     setLogUri (http, uri);
-    ClientSocketContext *context = new ClientSocketContext(clientConnection, http);
+    auto *context = new Http::Stream(clientConnection, http);
     StoreIOBuffer tempBuffer;
     tempBuffer.data = context->reqbuf;
     tempBuffer.length = HTTP_REQBUF_SZ;
@@ -1985,9 +1290,9 @@ prepareTransparentURL(ConnStateData * conn, ClientHttpRequest *http, const Http1
  *          parsing failure
  *  \param[out] http_ver will be set as a side-effect of the parsing
  *  \return NULL on incomplete requests,
- *          a ClientSocketContext structure on success or failure.
+ *          a Http::Stream on success or failure.
  */
-ClientSocketContext *
+Http::Stream *
 parseHttpRequest(ConnStateData *csd, const Http1::RequestParserPointer &hp)
 {
     /* Attempt to parse the first line; this will define where the method, url, version and header begin */
@@ -2055,7 +1360,7 @@ parseHttpRequest(ConnStateData *csd, const Http1::RequestParserPointer &hp)
     ClientHttpRequest *http = new ClientHttpRequest(csd);
 
     http->req_sz = hp->messageHeaderSize();
-    ClientSocketContext *result = new ClientSocketContext(csd->clientConnection, http);
+    Http::Stream *result = new Http::Stream(csd->clientConnection, http);
 
     StoreIOBuffer tempBuffer;
     tempBuffer.data = result->reqbuf;
@@ -2166,7 +1471,7 @@ ConnStateData::quitAfterError(HttpRequest *request)
 }
 
 #if USE_OPENSSL
-bool ConnStateData::serveDelayedError(ClientSocketContext *context)
+bool ConnStateData::serveDelayedError(Http::Stream *context)
 {
     ClientHttpRequest *http = context->http;
 
@@ -2256,7 +1561,7 @@ bool ConnStateData::serveDelayedError(ClientSocketContext *context)
  * or false otherwise
  */
 bool
-clientTunnelOnError(ConnStateData *conn, ClientSocketContext *context, HttpRequest *request, const HttpRequestMethod& method, err_type requestError, Http::StatusCode errStatusCode, const char *requestErrorBytes)
+clientTunnelOnError(ConnStateData *conn, Http::Stream *context, HttpRequest *request, const HttpRequestMethod& method, err_type requestError, Http::StatusCode errStatusCode, const char *requestErrorBytes)
 {
     if (conn->port->flags.isIntercepted() &&
             Config.accessList.on_unsupported_protocol && conn->pipeline.nrequests <= 1) {
@@ -2273,7 +1578,7 @@ clientTunnelOnError(ConnStateData *conn, ClientSocketContext *context, HttpReque
                 // The below may leak client streams BodyPipe objects. BUT, we need
                 // to check if client-streams detatch is safe to do here (finished() will detatch).
                 assert(conn->pipeline.front() == context); // XXX: still assumes HTTP/1 semantics
-                conn->pipeline.popMe(ClientSocketContextPointer(context));
+                conn->pipeline.popMe(Http::StreamPointer(context));
             }
             Comm::SetSelect(conn->clientConnection->fd, COMM_SELECT_READ, NULL, NULL, 0);
             conn->fakeAConnectRequest("unknown-protocol", conn->preservedClientData);
@@ -2314,7 +1619,7 @@ clientProcessRequestFinished(ConnStateData *conn, const HttpRequest::Pointer &re
 }
 
 void
-clientProcessRequest(ConnStateData *conn, const Http1::RequestParserPointer &hp, ClientSocketContext *context)
+clientProcessRequest(ConnStateData *conn, const Http1::RequestParserPointer &hp, Http::Stream *context)
 {
     ClientHttpRequest *http = context->http;
     bool chunked = false;
@@ -2852,7 +2157,7 @@ ConnStateData::clientParseRequests()
         if (needProxyProtocolHeader_ && !parseProxyProtocolHeader())
             break;
 
-        if (ClientSocketContext *context = parseOneRequest()) {
+        if (Http::Stream *context = parseOneRequest()) {
             debugs(33, 5, clientConnection << ": done parsing a request");
 
             AsyncCall::Pointer timeoutCall = commCbCall(5, 4, "clientLifetimeTimeout",
@@ -3023,7 +2328,7 @@ ConnStateData::abortChunkedRequestBody(const err_type error)
     // but if we fail when the server connection is used already, the server may send
     // us its response too, causing various assertions. How to prevent that?
 #if WE_KNOW_HOW_TO_SEND_ERRORS
-    ClientSocketContext::Pointer context = pipeline.front();
+    Http::StreamPointer context = pipeline.front();
     if (context != NULL && !context->http->out.offset) { // output nothing yet
         clientStreamNode *node = context->getClientReplyContext();
         clientReplyContext *repContext = dynamic_cast<clientReplyContext*>(node->data.getRaw());
@@ -3970,7 +3275,7 @@ ConnStateData::splice()
         transferProtocol = Http::ProtocolVersion();
         // inBuf still has the "CONNECT ..." request data, reset it to SSL hello message
         inBuf.append(rbuf.content(), rbuf.contentSize());
-        ClientSocketContext::Pointer context = pipeline.front();
+        Http::StreamPointer context = pipeline.front();
         ClientHttpRequest *http = context->http;
         tunnelStart(http);
     }
@@ -4418,7 +3723,7 @@ ConnStateData::finishDechunkingRequest(bool withSuccess)
         Must(!bodyPipe); // we rely on it being nil after we are done with body
         if (withSuccess) {
             Must(myPipe->bodySizeKnown());
-            ClientSocketContext::Pointer context = pipeline.front();
+            Http::StreamPointer context = pipeline.front();
             if (context != NULL && context->http && context->http->request)
                 context->http->request->setContentLength(myPipe->bodySize());
         }
@@ -27,130 +27,9 @@
 #include "ssl/support.h"
 #endif
 
-class ConnStateData;
 class ClientHttpRequest;
-class clientStreamNode;
-namespace AnyP
-{
-class PortCfg;
-} // namespace Anyp
-
-/**
- * Badly named.
- * This is in fact the processing context for a single HTTP transaction.
- *
- * A context lifetime extends from directly after a request has been parsed
- * off the client connection buffer, until the last byte of both request
- * and reply payload (if any) have been written.
- *
- * (NOTE: it is not certain yet if an early reply to a POST/PUT is sent by
- * the server whether the context will remain in the pipeline until its
- * request payload has finished being read. It is supposed to, but may not)
- *
- * Contexts self-register with the Pipeline being managed by the Server
- * for the connection on which the request was received.
- *
- * When HTTP/1 pipeline is operating there may be multiple transactions using
- * the clientConnection. Only the back() context may read from the connection,
- * and only the front() context may write to it. A context which needs to read
- * or write to the connection but does not meet those criteria must be shifted
- * to the deferred state.
- *
- * When a context is completed the finished() method needs to be called which
- * will perform all cleanup and deregistration operations. If the reason for
- * finishing is an error, then notifyIoError() needs to be called prior to
- * the finished() method.
- * The caller should follow finished() with a call to ConnStateData::kick()
- * to resume processing of other transactions or I/O on the connection.
- *
- * Alternatively the initiateClose() method can be called to terminate the
- * whole client connection and all other pending contexts.
- *
- * The socket level management is done by a Server which owns us.
- * The scope of this objects control over a socket consists of the data
- * buffer received from the Server with an initially unknown length.
- * When that length is known it sets the end boundary of our access to the
- * buffer.
- *
- * The individual processing actions are done by other Jobs which we
- * kick off as needed.
- *
- * XXX: If an async call ends the ClientHttpRequest job, ClientSocketContext
- * (and ConnStateData) may not know about it, leading to segfaults and
- * assertions. This is difficult to fix
- * because ClientHttpRequest lacks a good way to communicate its ongoing
- * destruction back to the ClientSocketContext which pretends to "own" *http.
- */
-class ClientSocketContext : public RefCountable
-{
-    MEMPROXY_CLASS(ClientSocketContext);
-
-public:
-    typedef RefCount<ClientSocketContext> Pointer;
-    ClientSocketContext(const Comm::ConnectionPointer &aConn, ClientHttpRequest *aReq);
-    ~ClientSocketContext();
-    bool startOfOutput() const;
-    void writeComplete(size_t size);
+class HttpHdrRangeSpec;
 
-    Comm::ConnectionPointer clientConnection; /// details about the client connection socket.
-    ClientHttpRequest *http;    /* we pretend to own that job */
-    HttpReply *reply;
-    char reqbuf[HTTP_REQBUF_SZ];
-
-    struct {
-
-        unsigned deferred:1; /* This is a pipelined request waiting for the current object to complete */
-
-        unsigned parsed_ok:1; /* Was this parsed correctly? */
-    } flags;
-    bool mayUseConnection() const {return mayUseConnection_;}
-
-    void mayUseConnection(bool aBool) {
-        mayUseConnection_ = aBool;
-        debugs(33,3, HERE << "This " << this << " marked " << aBool);
-    }
-
-    class DeferredParams
-    {
-
-    public:
-        clientStreamNode *node;
-        HttpReply *rep;
-        StoreIOBuffer queuedBuffer;
-    };
-
-    DeferredParams deferredparams;
-    int64_t writtenToSocket;
-    void pullData();
-    int64_t getNextRangeOffset() const;
-    bool canPackMoreRanges() const;
-    clientStream_status_t socketState();
-    void sendBody(HttpReply * rep, StoreIOBuffer bodyData);
-    void sendStartOfMessage(HttpReply * rep, StoreIOBuffer bodyData);
-    size_t lengthToSend(Range<int64_t> const &available);
-    void noteSentBodyBytes(size_t);
-    void buildRangeHeader(HttpReply * rep);
-    clientStreamNode * getTail() const;
-    clientStreamNode * getClientReplyContext() const;
-    ConnStateData *getConn() const;
-    void finished(); ///< cleanup when the transaction has finished. may destroy 'this'
-    void deferRecipientForLater(clientStreamNode * node, HttpReply * rep, StoreIOBuffer receivedData);
-    bool multipartRangeRequest() const;
-    void registerWithConn();
-    void noteIoError(const int xerrno); ///< update state to reflect I/O error
-    void initiateClose(const char *reason); ///< terminate due to a send/write error (may continue reading)
-
-private:
-    void prepareReply(HttpReply * rep);
-    void packChunk(const StoreIOBuffer &bodyData, MemBuf &mb);
-    void packRange(StoreIOBuffer const &, MemBuf * mb);
-    void doClose();
-
-    bool mayUseConnection_; /* This request may use the connection. Don't read anymore requests for now */
-    bool connRegistered_;
-};
-
-class ConnectionDetail;
 #if USE_OPENSSL
 namespace Ssl
 {
@@ -174,7 +53,7 @@ class ServerBump;
  * processed.
  *
  * Performs HTTP message processing to kick off the actual HTTP request
- * handling objects (ClientSocketContext, ClientHttpRequest, HttpRequest).
+ * handling objects (Http::Stream, ClientHttpRequest, HttpRequest).
  *
  * Performs SSL-Bump processing for switching between HTTP and HTTPS protocols.
  *
@@ -372,7 +251,7 @@ class ConnStateData : public Server, public HttpControlMsgSink, public Registere
     /// Returns false if no [delayed] error should be written to the client.
     /// Otherwise, writes the error to the client and returns true. Also checks
     /// for SQUID_X509_V_ERR_DOMAIN_MISMATCH on bumped requests.
-    bool serveDelayedError(ClientSocketContext *context);
+    bool serveDelayedError(Http::Stream *);
 
     Ssl::BumpMode sslBumpMode; ///< ssl_bump decision (Ssl::bumpEnd if n/a).
 
@@ -388,7 +267,7 @@ class ConnStateData : public Server, public HttpControlMsgSink, public Registere
     virtual void writeControlMsgAndCall(HttpReply *rep, AsyncCall::Pointer &call) = 0;
 
     /// ClientStream calls this to supply response header (once) and data
-    /// for the current ClientSocketContext.
+    /// for the current Http::Stream.
     virtual void handleReply(HttpReply *header, StoreIOBuffer receivedData) = 0;
 
     /// remove no longer needed leading bytes from the input buffer
@@ -397,7 +276,7 @@ class ConnStateData : public Server, public HttpControlMsgSink, public Registere
     /* TODO: Make the methods below (at least) non-public when possible. */
 
     /// stop parsing the request and create context for relaying error info
-    ClientSocketContext *abortRequestParsing(const char *const errUri);
+    Http::Stream *abortRequestParsing(const char *const errUri);
 
     /// generate a fake CONNECT request with the given payload
     /// at the beginning of the client I/O buffer
@@ -429,10 +308,10 @@ class ConnStateData : public Server, public HttpControlMsgSink, public Registere
     /// parse input buffer prefix into a single transfer protocol request
     /// return NULL to request more header bytes (after checking any limits)
     /// use abortRequestParsing() to handle parsing errors w/o creating request
-    virtual ClientSocketContext *parseOneRequest() = 0;
+    virtual Http::Stream *parseOneRequest() = 0;
 
     /// start processing a freshly parsed request
-    virtual void processParsedRequest(ClientSocketContext *context) = 0;
+    virtual void processParsedRequest(Http::Stream *) = 0;
 
     /// returning N allows a pipeline of 1+N requests (see pipeline_prefetch)
     virtual int pipelinePrefetchMax() const;
@@ -505,6 +384,12 @@ void httpRequestFree(void *);
 /// decide whether to expect multiple requests on the corresponding connection
 void clientSetKeepaliveFlag(ClientHttpRequest *http);
 
+/// append a "part" HTTP header (as in a multi-part/range reply) to the buffer
+void clientPackRangeHdr(const HttpReply *, const HttpHdrRangeSpec *, String boundary, MemBuf *);
+
+/// put terminating boundary for multiparts to the buffer
+void clientPackTermBound(String boundary, MemBuf *);
+
 /* misplaced declaratrions of Stream callbacks provided/used by client side */
 SQUIDCEXTERN CSR clientGetMoreData;
 SQUIDCEXTERN CSS clientReplyStatus;
@@ -513,8 +398,8 @@ CSCB clientSocketRecipient;
 CSD clientSocketDetach;
 
 /* TODO: Move to HttpServer. Warning: Move requires large code nonchanges! */
-ClientSocketContext *parseHttpRequest(ConnStateData *, const Http1::RequestParserPointer &);
-void clientProcessRequest(ConnStateData *, const Http1::RequestParserPointer &, ClientSocketContext *);
+Http::Stream *parseHttpRequest(ConnStateData *, const Http1::RequestParserPointer &);
+void clientProcessRequest(ConnStateData *, const Http1::RequestParserPointer &, Http::Stream *);
 void clientPostHttpsAccept(ConnStateData *);
 
 #endif /* SQUID_CLIENTSIDE_H */
@@ -21,6 +21,7 @@
 #include "FwdState.h"
 #include "globals.h"
 #include "globals.h"
+#include "http/Stream.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -37,6 +37,7 @@
 #include "helper.h"
 #include "helper/Reply.h"
 #include "http.h"
+#include "http/Stream.h"
 #include "HttpHdrCc.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -19,6 +19,7 @@
 #include "errorpage.h"
 #include "fd.h"
 #include "ftp/Parsing.h"
+#include "http/Stream.h"
 #include "ip/tools.h"
 #include "SquidConfig.h"
 #include "SquidString.h"
@@ -15,6 +15,7 @@
 #include "clients/FtpClient.h"
 #include "ftp/Elements.h"
 #include "ftp/Parsing.h"
+#include "http/Stream.h"
 #include "HttpHdrCc.h"
 #include "HttpRequest.h"
 #include "SBuf.h"
@@ -30,6 +30,7 @@
 #include "DelayUser.h"
 #include "DelayVector.h"
 #include "event.h"
+#include "http/Stream.h"
 #include "ip/Address.h"
 #include "MemObject.h"
 #include "mgr/Registration.h"
@@ -17,6 +17,7 @@
 
 #include "client_side_request.h"
 #include "esi/Context.h"
+#include "http/Stream.h"
 #include "Store.h"
 
 void
@@ -30,6 +30,7 @@
 #include "esi/Segment.h"
 #include "esi/VarState.h"
 #include "fatal.h"
+#include "http/Stream.h"
 #include "HttpHdrSc.h"
 #include "HttpHdrScTarget.h"
 #include "HttpReply.h"
@@ -17,6 +17,7 @@
 #include "esi/Include.h"
 #include "esi/VarState.h"
 #include "fatal.h"
+#include "http/Stream.h"
 #include "HttpReply.h"
 #include "log/access_log.h"
 
@@ -22,6 +22,7 @@
 #include "format/Token.h"
 #include "helper.h"
 #include "helper/Reply.h"
+#include "http/Stream.h"
 #include "HttpHeaderTools.h"
 #include "HttpReply.h"
 #include "HttpRequest.h"
@@ -17,6 +17,7 @@
 #include "format/Quoting.h"
 #include "format/Token.h"
 #include "fqdncache.h"
+#include "http/Stream.h"
 #include "HttpRequest.h"
 #include "MemBuf.h"
 #include "rfc1738.h"
@@ -32,6 +32,7 @@
 #include "http.h"
 #include "http/one/ResponseParser.h"
 #include "http/one/TeChunkedParser.h"
+#include "http/Stream.h"
 #include "HttpControlMsg.h"
 #include "HttpHdrCc.h"
 #include "HttpHdrContRange.h"
@@ -26,7 +26,9 @@ libsquid_http_la_SOURCES = \
 	StatusCode.cc \
 	StatusCode.h \
 	StatusLine.cc \
-	StatusLine.h
+	StatusLine.h \
+	Stream.cc \
+	Stream.h
 
 libsquid_http_la_LIBADD= one/libhttp1.la
 
@@ -0,0 +1,666 @@
+/*
+ * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#include "squid.h"
+#include "client_side_request.h"
+#include "http/Stream.h"
+#include "HttpHdrContRange.h"
+#include "HttpHeaderTools.h"
+#include "Store.h"
+#include "TimeOrTag.h"
+
+Http::Stream::Stream(const Comm::ConnectionPointer &aConn, ClientHttpRequest *aReq) :
+    clientConnection(aConn),
+    http(aReq),
+    reply(nullptr),
+    writtenToSocket(0),
+    mayUseConnection_(false),
+    connRegistered_(false)
+{
+    assert(http != nullptr);
+    memset(reqbuf, '\0', sizeof (reqbuf));
+    flags.deferred = 0;
+    flags.parsed_ok = 0;
+    deferredparams.node = nullptr;
+    deferredparams.rep = nullptr;
+}
+
+Http::Stream::~Stream()
+{
+    if (auto node = getTail()) {
+        if (auto ctx = dynamic_cast<Http::Stream *>(node->data.getRaw())) {
+            /* We are *always* the tail - prevent recursive free */
+            assert(this == ctx);
+            node->data = nullptr;
+        }
+    }
+    httpRequestFree(http);
+}
+
+void
+Http::Stream::registerWithConn()
+{
+    assert(!connRegistered_);
+    assert(getConn());
+    connRegistered_ = true;
+    getConn()->pipeline.add(Http::StreamPointer(this));
+}
+
+bool
+Http::Stream::startOfOutput() const
+{
+    return http->out.size == 0;
+}
+
+void
+Http::Stream::writeComplete(size_t size)
+{
+    const StoreEntry *entry = http->storeEntry();
+    debugs(33, 5, clientConnection << ", sz " << size <<
+           ", off " << (http->out.size + size) << ", len " <<
+           (entry ? entry->objectLen() : 0));
+
+    http->out.size += size;
+
+    if (clientHttpRequestStatus(clientConnection->fd, http)) {
+        initiateClose("failure or true request status");
+        /* Do we leak here ? */
+        return;
+    }
+
+    switch (socketState()) {
+
+    case STREAM_NONE:
+        pullData();
+        break;
+
+    case STREAM_COMPLETE: {
+        debugs(33, 5, clientConnection << " Stream complete, keepalive is " <<
+               http->request->flags.proxyKeepalive);
+        ConnStateData *c = getConn();
+        if (!http->request->flags.proxyKeepalive)
+            clientConnection->close();
+        finished();
+        c->kick();
+    }
+    return;
+
+    case STREAM_UNPLANNED_COMPLETE:
+        initiateClose("STREAM_UNPLANNED_COMPLETE");
+        return;
+
+    case STREAM_FAILED:
+        initiateClose("STREAM_FAILED");
+        return;
+
+    default:
+        fatal("Hit unreachable code in Http::Stream::writeComplete\n");
+    }
+}
+
+void
+Http::Stream::pullData()
+{
+    debugs(33, 5, reply << " written " << http->out.size << " into " << clientConnection);
+
+    /* More data will be coming from the stream. */
+    StoreIOBuffer readBuffer;
+    /* XXX: Next requested byte in the range sequence */
+    /* XXX: length = getmaximumrangelenfgth */
+    readBuffer.offset = getNextRangeOffset();
+    readBuffer.length = HTTP_REQBUF_SZ;
+    readBuffer.data = reqbuf;
+    /* we may note we have reached the end of the wanted ranges */
+    clientStreamRead(getTail(), http, readBuffer);
+}
+
+bool
+Http::Stream::multipartRangeRequest() const
+{
+    return http->multipartRangeRequest();
+}
+
+int64_t
+Http::Stream::getNextRangeOffset() const
+{
+    debugs (33, 5, "range: " << http->request->range <<
+            "; http offset " << http->out.offset <<
+            "; reply " << reply);
+
+    // XXX: This method is called from many places, including pullData() which
+    // may be called before prepareReply() [on some Squid-generated errors].
+    // Hence, we may not even know yet whether we should honor/do ranges.
+
+    if (http->request->range) {
+        /* offset in range specs does not count the prefix of an http msg */
+        /* check: reply was parsed and range iterator was initialized */
+        assert(http->range_iter.valid);
+        /* filter out data according to range specs */
+        assert(canPackMoreRanges());
+        {
+            assert(http->range_iter.currentSpec());
+            /* offset of still missing data */
+            int64_t start = http->range_iter.currentSpec()->offset +
+                            http->range_iter.currentSpec()->length -
+                            http->range_iter.debt();
+            debugs(33, 3, "clientPackMoreRanges: in:  offset: " << http->out.offset);
+            debugs(33, 3, "clientPackMoreRanges: out:"
+                   " start: " << start <<
+                   " spec[" << http->range_iter.pos - http->request->range->begin() << "]:" <<
+                   " [" << http->range_iter.currentSpec()->offset <<
+                   ", " << http->range_iter.currentSpec()->offset +
+                   http->range_iter.currentSpec()->length << "),"
+                   " len: " << http->range_iter.currentSpec()->length <<
+                   " debt: " << http->range_iter.debt());
+            if (http->range_iter.currentSpec()->length != -1)
+                assert(http->out.offset <= start);  /* we did not miss it */
+
+            return start;
+        }
+
+    } else if (reply && reply->content_range) {
+        /* request does not have ranges, but reply does */
+        /** \todo FIXME: should use range_iter_pos on reply, as soon as reply->content_range
+         *        becomes HttpHdrRange rather than HttpHdrRangeSpec.
+         */
+        return http->out.offset + reply->content_range->spec.offset;
+    }
+
+    return http->out.offset;
+}
+
+/**
+ * increments iterator "i"
+ * used by clientPackMoreRanges
+ *
+ * \retval true    there is still data available to pack more ranges
+ * \retval false
+ */
+bool
+Http::Stream::canPackMoreRanges() const
+{
+    /** first update iterator "i" if needed */
+    if (!http->range_iter.debt()) {
+        debugs(33, 5, "At end of current range spec for " << clientConnection);
+
+        if (http->range_iter.pos != http->range_iter.end)
+            ++http->range_iter.pos;
+
+        http->range_iter.updateSpec();
+    }
+
+    assert(!http->range_iter.debt() == !http->range_iter.currentSpec());
+
+    /* paranoid sync condition */
+    /* continue condition: need_more_data */
+    debugs(33, 5, "returning " << (http->range_iter.currentSpec() ? true : false));
+    return http->range_iter.currentSpec() ? true : false;
+}
+
+/// Adapt stream status to account for Range cases
+clientStream_status_t
+Http::Stream::socketState()
+{
+    switch (clientStreamStatus(getTail(), http)) {
+
+    case STREAM_NONE:
+        /* check for range support ending */
+        if (http->request->range) {
+            /* check: reply was parsed and range iterator was initialized */
+            assert(http->range_iter.valid);
+            /* filter out data according to range specs */
+
+            if (!canPackMoreRanges()) {
+                debugs(33, 5, "Range request at end of returnable " <<
+                       "range sequence on " << clientConnection);
+                // we got everything we wanted from the store
+                return STREAM_COMPLETE;
+            }
+        } else if (reply && reply->content_range) {
+            /* reply has content-range, but Squid is not managing ranges */
+            const int64_t &bytesSent = http->out.offset;
+            const int64_t &bytesExpected = reply->content_range->spec.length;
+
+            debugs(33, 7, "body bytes sent vs. expected: " <<
+                   bytesSent << " ? " << bytesExpected << " (+" <<
+                   reply->content_range->spec.offset << ")");
+
+            // did we get at least what we expected, based on range specs?
+
+            if (bytesSent == bytesExpected) // got everything
+                return STREAM_COMPLETE;
+
+            if (bytesSent > bytesExpected) // Error: Sent more than expected
+                return STREAM_UNPLANNED_COMPLETE;
+        }
+
+        return STREAM_NONE;
+
+    case STREAM_COMPLETE:
+        return STREAM_COMPLETE;
+
+    case STREAM_UNPLANNED_COMPLETE:
+        return STREAM_UNPLANNED_COMPLETE;
+
+    case STREAM_FAILED:
+        return STREAM_FAILED;
+    }
+
+    fatal ("unreachable code\n");
+    return STREAM_NONE;
+}
+
+void
+Http::Stream::sendStartOfMessage(HttpReply *rep, StoreIOBuffer bodyData)
+{
+    prepareReply(rep);
+    assert(rep);
+    MemBuf *mb = rep->pack();
+
+    // dump now, so we dont output any body.
+    debugs(11, 2, "HTTP Client " << clientConnection);
+    debugs(11, 2, "HTTP Client REPLY:\n---------\n" << mb->buf << "\n----------");
+
+    /* Save length of headers for persistent conn checks */
+    http->out.headers_sz = mb->contentSize();
+#if HEADERS_LOG
+    headersLog(0, 0, http->request->method, rep);
+#endif
+
+    if (bodyData.data && bodyData.length) {
+        if (multipartRangeRequest())
+            packRange(bodyData, mb);
+        else if (http->request->flags.chunkedReply) {
+            packChunk(bodyData, *mb);
+        } else {
+            size_t length = lengthToSend(bodyData.range());
+            noteSentBodyBytes(length);
+            mb->append(bodyData.data, length);
+        }
+    }
+
+    getConn()->write(mb);
+    delete mb;
+}
+
+void
+Http::Stream::sendBody(StoreIOBuffer bodyData)
+{
+    if (!multipartRangeRequest() && !http->request->flags.chunkedReply) {
+        size_t length = lengthToSend(bodyData.range());
+        noteSentBodyBytes(length);
+        getConn()->write(bodyData.data, length);
+        return;
+    }
+
+    MemBuf mb;
+    mb.init();
+    if (multipartRangeRequest())
+        packRange(bodyData, &mb);
+    else
+        packChunk(bodyData, mb);
+
+    if (mb.contentSize())
+        getConn()->write(&mb);
+    else
+        writeComplete(0);
+}
+
+size_t
+Http::Stream::lengthToSend(Range<int64_t> const &available) const
+{
+    // the size of available range can always fit into a size_t type
+    size_t maximum = available.size();
+
+    if (!http->request->range)
+        return maximum;
+
+    assert(canPackMoreRanges());
+
+    if (http->range_iter.debt() == -1)
+        return maximum;
+
+    assert(http->range_iter.debt() > 0);
+
+    /* TODO this + the last line could be a range intersection calculation */
+    if (available.start < http->range_iter.currentSpec()->offset)
+        return 0;
+
+    return min(http->range_iter.debt(), static_cast<int64_t>(maximum));
+}
+
+void
+Http::Stream::noteSentBodyBytes(size_t bytes)
+{
+    debugs(33, 7, bytes << " body bytes");
+    http->out.offset += bytes;
+
+    if (!http->request->range)
+        return;
+
+    if (http->range_iter.debt() != -1) {
+        http->range_iter.debt(http->range_iter.debt() - bytes);
+        assert (http->range_iter.debt() >= 0);
+    }
+
+    /* debt() always stops at -1, below that is a bug */
+    assert(http->range_iter.debt() >= -1);
+}
+
+/// \return true when If-Range specs match reply, false otherwise
+static bool
+clientIfRangeMatch(ClientHttpRequest * http, HttpReply * rep)
+{
+    const TimeOrTag spec = http->request->header.getTimeOrTag(Http::HdrType::IF_RANGE);
+
+    /* check for parsing falure */
+    if (!spec.valid)
+        return false;
+
+    /* got an ETag? */
+    if (spec.tag.str) {
+        ETag rep_tag = rep->header.getETag(Http::HdrType::ETAG);
+        debugs(33, 3, "ETags: " << spec.tag.str << " and " <<
+               (rep_tag.str ? rep_tag.str : "<none>"));
+
+        if (!rep_tag.str)
+            return false; // entity has no etag to compare with!
+
+        if (spec.tag.weak || rep_tag.weak) {
+            debugs(33, DBG_IMPORTANT, "Weak ETags are not allowed in If-Range: " <<
+                   spec.tag.str << " ? " << rep_tag.str);
+            return false; // must use strong validator for sub-range requests
+        }
+
+        return etagIsStrongEqual(rep_tag, spec.tag);
+    }
+
+    /* got modification time? */
+    if (spec.time >= 0)
+        return http->storeEntry()->lastmod <= spec.time;
+
+    assert(0);          /* should not happen */
+    return false;
+}
+
+// seems to be something better suited to Server logic
+/** adds appropriate Range headers if needed */
+void
+Http::Stream::buildRangeHeader(HttpReply *rep)
+{
+    HttpHeader *hdr = rep ? &rep->header : nullptr;
+    const char *range_err = nullptr;
+    HttpRequest *request = http->request;
+    assert(request->range);
+    /* check if we still want to do ranges */
+    int64_t roffLimit = request->getRangeOffsetLimit();
+
+    if (!rep)
+        range_err = "no [parse-able] reply";
+    else if ((rep->sline.status() != Http::scOkay) && (rep->sline.status() != Http::scPartialContent))
+        range_err = "wrong status code";
+    else if (hdr->has(Http::HdrType::CONTENT_RANGE))
+        range_err = "origin server does ranges";
+    else if (rep->content_length < 0)
+        range_err = "unknown length";
+    else if (rep->content_length != http->memObject()->getReply()->content_length)
+        range_err = "INCONSISTENT length";  /* a bug? */
+
+    /* hits only - upstream CachePeer determines correct behaviour on misses,
+     * and client_side_reply determines hits candidates
+     */
+    else if (http->logType.isTcpHit() &&
+             http->request->header.has(Http::HdrType::IF_RANGE) &&
+             !clientIfRangeMatch(http, rep))
+        range_err = "If-Range match failed";
+
+    else if (!http->request->range->canonize(rep))
+        range_err = "canonization failed";
+    else if (http->request->range->isComplex())
+        range_err = "too complex range header";
+    else if (!http->logType.isTcpHit() && http->request->range->offsetLimitExceeded(roffLimit))
+        range_err = "range outside range_offset_limit";
+
+    /* get rid of our range specs on error */
+    if (range_err) {
+        /* XXX We do this here because we need canonisation etc. However, this current
+         * code will lead to incorrect store offset requests - the store will have the
+         * offset data, but we won't be requesting it.
+         * So, we can either re-request, or generate an error
+         */
+        http->request->ignoreRange(range_err);
+    } else {
+        /* XXX: TODO: Review, this unconditional set may be wrong. */
+        rep->sline.set(rep->sline.version, Http::scPartialContent);
+        // web server responded with a valid, but unexpected range.
+        // will (try-to) forward as-is.
+        //TODO: we should cope with multirange request/responses
+        bool replyMatchRequest = rep->content_range != nullptr ?
+                                 request->range->contains(rep->content_range->spec) :
+                                 true;
+        const int spec_count = http->request->range->specs.size();
+        int64_t actual_clen = -1;
+
+        debugs(33, 3, "range spec count: " << spec_count <<
+               " virgin clen: " << rep->content_length);
+        assert(spec_count > 0);
+        /* append appropriate header(s) */
+        if (spec_count == 1) {
+            if (!replyMatchRequest) {
+                hdr->delById(Http::HdrType::CONTENT_RANGE);
+                hdr->putContRange(rep->content_range);
+                actual_clen = rep->content_length;
+                //http->range_iter.pos = rep->content_range->spec.begin();
+                (*http->range_iter.pos)->offset = rep->content_range->spec.offset;
+                (*http->range_iter.pos)->length = rep->content_range->spec.length;
+
+            } else {
+                HttpHdrRange::iterator pos = http->request->range->begin();
+                assert(*pos);
+                /* append Content-Range */
+
+                if (!hdr->has(Http::HdrType::CONTENT_RANGE)) {
+                    /* No content range, so this was a full object we are
+                     * sending parts of.
+                     */
+                    httpHeaderAddContRange(hdr, **pos, rep->content_length);
+                }
+
+                /* set new Content-Length to the actual number of bytes
+                 * transmitted in the message-body */
+                actual_clen = (*pos)->length;
+            }
+        } else {
+            /* multipart! */
+            /* generate boundary string */
+            http->range_iter.boundary = http->rangeBoundaryStr();
+            /* delete old Content-Type, add ours */
+            hdr->delById(Http::HdrType::CONTENT_TYPE);
+            httpHeaderPutStrf(hdr, Http::HdrType::CONTENT_TYPE,
+                              "multipart/byteranges; boundary=\"" SQUIDSTRINGPH "\"",
+                              SQUIDSTRINGPRINT(http->range_iter.boundary));
+            /* Content-Length is not required in multipart responses
+             * but it is always nice to have one */
+            actual_clen = http->mRangeCLen();
+
+            /* http->out needs to start where we want data at */
+            http->out.offset = http->range_iter.currentSpec()->offset;
+        }
+
+        /* replace Content-Length header */
+        assert(actual_clen >= 0);
+        hdr->delById(Http::HdrType::CONTENT_LENGTH);
+        hdr->putInt64(Http::HdrType::CONTENT_LENGTH, actual_clen);
+        debugs(33, 3, "actual content length: " << actual_clen);
+
+        /* And start the range iter off */
+        http->range_iter.updateSpec();
+    }
+}
+
+clientStreamNode *
+Http::Stream::getTail() const
+{
+    if (http->client_stream.tail)
+        return static_cast<clientStreamNode *>(http->client_stream.tail->data);
+
+    return nullptr;
+}
+
+clientStreamNode *
+Http::Stream::getClientReplyContext() const
+{
+    return static_cast<clientStreamNode *>(http->client_stream.tail->prev->data);
+}
+
+ConnStateData *
+Http::Stream::getConn() const
+{
+    assert(http && http->getConn());
+    return http->getConn();
+}
+
+/// remembers the abnormal connection termination for logging purposes
+void
+Http::Stream::noteIoError(const int xerrno)
+{
+    if (http) {
+        http->logType.err.timedout = (xerrno == ETIMEDOUT);
+        // aborted even if xerrno is zero (which means read abort/eof)
+        http->logType.err.aborted = (xerrno != ETIMEDOUT);
+    }
+}
+
+void
+Http::Stream::finished()
+{
+    ConnStateData *conn = getConn();
+
+    /* we can't handle any more stream data - detach */
+    clientStreamDetach(getTail(), http);
+
+    assert(connRegistered_);
+    connRegistered_ = false;
+    conn->pipeline.popMe(Http::StreamPointer(this));
+}
+
+/// called when we encounter a response-related error
+void
+Http::Stream::initiateClose(const char *reason)
+{
+    debugs(33, 4, clientConnection << " because " << reason);
+    getConn()->stopSending(reason); // closes ASAP
+}
+
+void
+Http::Stream::deferRecipientForLater(clientStreamNode *node, HttpReply *rep, StoreIOBuffer receivedData)
+{
+    debugs(33, 2, "Deferring request " << http->uri);
+    assert(flags.deferred == 0);
+    flags.deferred = 1;
+    deferredparams.node = node;
+    deferredparams.rep = rep;
+    deferredparams.queuedBuffer = receivedData;
+}
+
+void
+Http::Stream::prepareReply(HttpReply *rep)
+{
+    reply = rep;
+    if (http->request->range)
+        buildRangeHeader(rep);
+}
+
+/**
+ * Packs bodyData into mb using chunked encoding.
+ * Packs the last-chunk if bodyData is empty.
+ */
+void
+Http::Stream::packChunk(const StoreIOBuffer &bodyData, MemBuf &mb)
+{
+    const uint64_t length =
+        static_cast<uint64_t>(lengthToSend(bodyData.range()));
+    noteSentBodyBytes(length);
+
+    mb.appendf("%" PRIX64 "\r\n", length);
+    mb.append(bodyData.data, length);
+    mb.append("\r\n", 2);
+}
+
+/**
+ * extracts a "range" from *buf and appends them to mb, updating
+ * all offsets and such.
+ */
+void
+Http::Stream::packRange(StoreIOBuffer const &source, MemBuf *mb)
+{
+    HttpHdrRangeIter * i = &http->range_iter;
+    Range<int64_t> available(source.range());
+    char const *buf = source.data;
+
+    while (i->currentSpec() && available.size()) {
+        const size_t copy_sz = lengthToSend(available);
+        if (copy_sz) {
+            // intersection of "have" and "need" ranges must not be empty
+            assert(http->out.offset < i->currentSpec()->offset + i->currentSpec()->length);
+            assert(http->out.offset + (int64_t)available.size() > i->currentSpec()->offset);
+
+            /*
+             * put boundary and headers at the beginning of a range in a
+             * multi-range
+             */
+            if (http->multipartRangeRequest() && i->debt() == i->currentSpec()->length) {
+                assert(http->memObject());
+                clientPackRangeHdr(
+                    http->memObject()->getReply(),  /* original reply */
+                    i->currentSpec(),       /* current range */
+                    i->boundary,    /* boundary, the same for all */
+                    mb);
+            }
+
+            // append content
+            debugs(33, 3, "appending " << copy_sz << " bytes");
+            noteSentBodyBytes(copy_sz);
+            mb->append(buf, copy_sz);
+
+            // update offsets
+            available.start += copy_sz;
+            buf += copy_sz;
+        }
+
+        if (!canPackMoreRanges()) {
+            debugs(33, 3, "Returning because !canPackMoreRanges.");
+            if (i->debt() == 0)
+                // put terminating boundary for multiparts
+                clientPackTermBound(i->boundary, mb);
+            return;
+        }
+
+        int64_t nextOffset = getNextRangeOffset();
+        assert(nextOffset >= http->out.offset);
+        int64_t skip = nextOffset - http->out.offset;
+        /* adjust for not to be transmitted bytes */
+        http->out.offset = nextOffset;
+
+        if (available.size() <= (uint64_t)skip)
+            return;
+
+        available.start += skip;
+        buf += skip;
+
+        if (copy_sz == 0)
+            return;
+    }
+}
+
+void
+Http::Stream::doClose()
+{
+    clientConnection->close();
+}
+
@@ -0,0 +1,166 @@
+/*
+ * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#ifndef SQUID_SRC_HTTP_STREAM_H
+#define SQUID_SRC_HTTP_STREAM_H
+
+#include "http/forward.h"
+#include "mem/forward.h"
+#include "StoreIOBuffer.h"
+
+class clientStreamNode;
+class ClientHttpRequest;
+
+namespace Http
+{
+
+/**
+ * The processing context for a single HTTP transaction (stream).
+ *
+ * A stream lifetime extends from directly after a request has been parsed
+ * off the client connection buffer, until the last byte of both request
+ * and reply payload (if any) have been written, or it is otherwise
+ * explicitly terminated.
+ *
+ * Streams self-register with the Http::Server Pipeline being managed by the
+ * Server for the connection on which the request was received.
+ *
+ * The socket level management and I/O is done by a Server which owns us.
+ * The scope of this objects control over a socket consists of the data
+ * buffer received from the Server with an initially unknown length.
+ * When that length is known it sets the end boundary of our access to the
+ * buffer.
+ *
+ * The individual processing actions are done by other Jobs which we start.
+ *
+ * When a stream is completed the finished() method needs to be called which
+ * will perform all cleanup and deregistration operations. If the reason for
+ * finishing is an error, then notifyIoError() needs to be called prior to
+ * the finished() method.
+ * The caller should follow finished() with a call to ConnStateData::kick()
+ * to resume processing of other transactions or I/O on the connection.
+ *
+ * Alternatively the initiateClose() method can be called to terminate the
+ * whole client connection and all other pending streams.
+ *
+ * HTTP/1.x:
+ *
+ * When HTTP/1 pipeline is operating there may be multiple transactions using
+ * the client connection. Only the back() stream may read from the connection,
+ * and only the front() stream may write to it. A stream which needs to read
+ * or write to the connection but does not meet those criteria must be shifted
+ * to the deferred state.
+ *
+ *
+ * XXX: If an async call ends the ClientHttpRequest job, Http::Stream
+ * (and ConnStateData) may not know about it, leading to segfaults and
+ * assertions. This is difficult to fix
+ * because ClientHttpRequest lacks a good way to communicate its ongoing
+ * destruction back to the Http::Stream which pretends to "own" *http.
+ */
+class Stream : public RefCountable
+{
+    MEMPROXY_CLASS(Stream);
+
+public:
+    /// construct with HTTP/1.x details
+    Stream(const Comm::ConnectionPointer &aConn, ClientHttpRequest *aReq);
+    ~Stream();
+
+    /// register this stream with the Server
+    void registerWithConn();
+
+    /// whether the reply has started being sent
+    bool startOfOutput() const;
+
+    /// update stream state after a write, may initiate more I/O
+    void writeComplete(size_t size);
+
+    /// get more data to send
+    void pullData();
+
+    /// \return true if the HTTP request is for multiple ranges
+    bool multipartRangeRequest() const;
+
+    int64_t getNextRangeOffset() const;
+    bool canPackMoreRanges() const;
+    size_t lengthToSend(Range<int64_t> const &available) const;
+
+    clientStream_status_t socketState();
+
+    /// send an HTTP reply message headers and maybe some initial payload
+    void sendStartOfMessage(HttpReply *, StoreIOBuffer bodyData);
+    /// send some HTTP reply message payload
+    void sendBody(StoreIOBuffer bodyData);
+    /// update stream state when N bytes are being sent.
+    /// NP: Http1Server bytes actually not sent yet, just packed into a MemBuf ready
+    void noteSentBodyBytes(size_t);
+
+    /// add Range headers (if any) to the given HTTP reply message
+    void buildRangeHeader(HttpReply *);
+
+    clientStreamNode * getTail() const;
+    clientStreamNode * getClientReplyContext() const;
+
+    ConnStateData *getConn() const;
+
+    /// update state to reflect I/O error
+    void noteIoError(const int xerrno);
+
+    /// cleanup when the transaction has finished. may destroy 'this'
+    void finished();
+
+    /// terminate due to a send/write error (may continue reading)
+    void initiateClose(const char *reason);
+
+    void deferRecipientForLater(clientStreamNode *, HttpReply *, StoreIOBuffer receivedData);
+
+public: // HTTP/1.x state data
+
+    Comm::ConnectionPointer clientConnection; ///< details about the client connection socket
+    ClientHttpRequest *http;    /* we pretend to own that Job */
+    HttpReply *reply;
+    char reqbuf[HTTP_REQBUF_SZ];
+    struct {
+        unsigned deferred:1; ///< This is a pipelined request waiting for the current object to complete
+        unsigned parsed_ok:1; ///< Was this parsed correctly?
+    } flags;
+
+    bool mayUseConnection() const {return mayUseConnection_;}
+
+    void mayUseConnection(bool aBool) {
+        mayUseConnection_ = aBool;
+        debugs(33, 3, "This " << this << " marked " << aBool);
+    }
+
+    class DeferredParams
+    {
+
+    public:
+        clientStreamNode *node;
+        HttpReply *rep;
+        StoreIOBuffer queuedBuffer;
+    };
+
+    DeferredParams deferredparams;
+    int64_t writtenToSocket;
+
+private:
+    void prepareReply(HttpReply *);
+    void packChunk(const StoreIOBuffer &bodyData, MemBuf &);
+    void packRange(StoreIOBuffer const &, MemBuf *);
+    void doClose();
+
+    bool mayUseConnection_; /* This request may use the connection. Don't read anymore requests for now */
+    bool connRegistered_;
+};
+
+} // namespace Http
+
+#endif /* SQUID_SRC_HTTP_STREAM_H */
+
@@ -11,6 +11,14 @@
 
 #include "http/one/forward.h"
 
+namespace Http
+{
+
+class Stream;
+typedef RefCount<Http::Stream> StreamPointer;
+
+} // namespace Http
+
 // TODO move these classes into Http namespace
 class HttpRequestMethod;
 typedef RefCount<HttpRequestMethod> HttpRequestMethodPointer;
@@ -18,6 +18,7 @@
 #include "client_side.h"
 #include "comm/Connection.h"
 #include "globals.h"
+#include "http/Stream.h"
 #include "ident/AclIdent.h"
 #include "ident/Ident.h"
 
@@ -37,6 +37,7 @@
 #include "FwdState.h"
 #include "globals.h"
 #include "htcp.h"
+#include "http/Stream.h"
 #include "HttpHeader.h"
 #include "HttpReply.h"
 #include "icmp/IcmpSquid.h"
@@ -20,6 +20,7 @@
 #include "globals.h"
 #include "hier_code.h"
 #include "htcp.h"
+#include "http/Stream.h"
 #include "HttpRequest.h"
 #include "icmp/net_db.h"
 #include "ICP.h"
@@ -20,6 +20,7 @@
 #include "globals.h"
 #include "helper.h"
 #include "helper/Reply.h"
+#include "http/Stream.h"
 #include "HttpRequest.h"
 #include "mgr/Registration.h"
 #include "redirect.h"
@@ -26,6 +26,7 @@
 #include "ftp/Parsing.h"
 #include "globals.h"
 #include "http/one/RequestParser.h"
+#include "http/Stream.h"
 #include "HttpHdrCc.h"
 #include "ip/tools.h"
 #include "ipc/FdNotes.h"
@@ -125,7 +126,7 @@ Ftp::Server::doProcessRequest()
 {
     // zero pipelinePrefetchMax() ensures that there is only parsed request
     Must(pipeline.count() == 1);
-    ClientSocketContext::Pointer context = pipeline.front();
+    Http::StreamPointer context = pipeline.front();
     Must(context != nullptr);
 
     ClientHttpRequest *const http = context->http;
@@ -149,7 +150,7 @@ Ftp::Server::doProcessRequest()
 }
 
 void
-Ftp::Server::processParsedRequest(ClientSocketContext *)
+Ftp::Server::processParsedRequest(Http::Stream *)
 {
     Must(pipeline.count() == 1);
 
@@ -288,7 +289,7 @@ void
 Ftp::Server::notePeerConnection(Comm::ConnectionPointer conn)
 {
     // find request
-    ClientSocketContext::Pointer context = pipeline.front();
+    Http::StreamPointer context = pipeline.front();
     Must(context != nullptr);
     ClientHttpRequest *const http = context->http;
     Must(http != NULL);
@@ -555,7 +556,7 @@ Ftp::CommandHasPathParameter(const SBuf &cmd)
 }
 
 /// creates a context filled with an error message for a given early error
-ClientSocketContext *
+Http::Stream *
 Ftp::Server::earlyError(const EarlyErrorKind eek)
 {
     /* Default values, to be updated by the switch statement below */
@@ -609,7 +610,7 @@ Ftp::Server::earlyError(const EarlyErrorKind eek)
         // no default so that a compiler can check that we have covered all cases
     }
 
-    ClientSocketContext *context = abortRequestParsing(errUri);
+    Http::Stream *context = abortRequestParsing(errUri);
     clientStreamNode *node = context->getClientReplyContext();
     Must(node);
     clientReplyContext *repContext = dynamic_cast<clientReplyContext *>(node->data.getRaw());
@@ -623,9 +624,9 @@ Ftp::Server::earlyError(const EarlyErrorKind eek)
 }
 
 /// Parses a single FTP request on the control connection.
-/// Returns a new ClientSocketContext on valid requests and all errors.
+/// Returns a new Http::Stream on valid requests and all errors.
 /// Returns NULL on incomplete requests that may still succeed given more data.
-ClientSocketContext *
+Http::Stream *
 Ftp::Server::parseOneRequest()
 {
     flags.readMore = false; // common for all but one case below
@@ -703,7 +704,7 @@ Ftp::Server::parseOneRequest()
 
         // process USER request now because it sets FTP peer host name
         if (cmd == cmdUser()) {
-            if (ClientSocketContext *errCtx = handleUserRequest(cmd, params))
+            if (Http::Stream *errCtx = handleUserRequest(cmd, params))
                 return errCtx;
         }
     }
@@ -747,8 +748,8 @@ Ftp::Server::parseOneRequest()
     http->req_sz = tok.parsedSize();
     http->uri = newUri;
 
-    ClientSocketContext *const result =
-        new ClientSocketContext(clientConnection, http);
+    Http::Stream *const result =
+        new Http::Stream(clientConnection, http);
 
     StoreIOBuffer tempBuffer;
     tempBuffer.data = result->reqbuf;
@@ -768,7 +769,7 @@ void
 Ftp::Server::handleReply(HttpReply *reply, StoreIOBuffer data)
 {
     // the caller guarantees that we are dealing with the current context only
-    ClientSocketContext::Pointer context = pipeline.front();
+    Http::StreamPointer context = pipeline.front();
     assert(context != nullptr);
 
     if (context->http && context->http->al != NULL &&
@@ -876,7 +877,7 @@ Ftp::Server::handleFeatReply(const HttpReply *reply, StoreIOBuffer)
 void
 Ftp::Server::handlePasvReply(const HttpReply *reply, StoreIOBuffer)
 {
-    const ClientSocketContext::Pointer context(pipeline.front());
+    const Http::StreamPointer context(pipeline.front());
     assert(context != nullptr);
 
     if (context->http->request->errType != ERR_NONE) {
@@ -1231,7 +1232,7 @@ Ftp::Server::wroteEarlyReply(const CommIoCbParams &io)
         return;
     }
 
-    ClientSocketContext::Pointer context = pipeline.front();
+    Http::StreamPointer context = pipeline.front();
     if (context != nullptr && context->http) {
         context->http->out.size += io.size;
         context->http->out.headers_sz += io.size;
@@ -1253,7 +1254,7 @@ Ftp::Server::wroteReply(const CommIoCbParams &io)
         return;
     }
 
-    ClientSocketContext::Pointer context = pipeline.front();
+    Http::StreamPointer context = pipeline.front();
     assert(context->http);
     context->http->out.size += io.size;
     context->http->out.headers_sz += io.size;
@@ -1343,7 +1344,7 @@ Ftp::Server::handleRequest(HttpRequest *request)
 
 /// Called to parse USER command, which is required to create an HTTP request
 /// wrapper. W/o request, the errors are handled by returning earlyError().
-ClientSocketContext *
+Http::Stream *
 Ftp::Server::handleUserRequest(const SBuf &, SBuf &params)
 {
     if (params.isEmpty())
@@ -1675,7 +1676,7 @@ Ftp::Server::connectedForData(const CommConnectCbParams &params)
         if (params.conn != NULL)
             params.conn->close();
         setReply(425, "Cannot open data connection.");
-        ClientSocketContext::Pointer context = pipeline.front();
+        Http::StreamPointer context = pipeline.front();
         Must(context->http);
         Must(context->http->storeEntry() != NULL);
     } else {
@@ -1690,7 +1691,7 @@ Ftp::Server::connectedForData(const CommConnectCbParams &params)
 void
 Ftp::Server::setReply(const int code, const char *msg)
 {
-    ClientSocketContext::Pointer context = pipeline.front();
+    Http::StreamPointer context = pipeline.front();
     ClientHttpRequest *const http = context->http;
     assert(http != NULL);
     assert(http->storeEntry() == NULL);
@@ -90,8 +90,8 @@ class Server: public ConnStateData
     };
 
     /* ConnStateData API */
-    virtual ClientSocketContext *parseOneRequest();
-    virtual void processParsedRequest(ClientSocketContext *context);
+    virtual Http::Stream *parseOneRequest();
+    virtual void processParsedRequest(Http::Stream *context);
     virtual void notePeerConnection(Comm::ConnectionPointer conn);
     virtual void clientPinnedConnectionClosed(const CommCloseCbParams &io);
     virtual void handleReply(HttpReply *header, StoreIOBuffer receivedData);
@@ -129,7 +129,7 @@ class Server: public ConnStateData
 
     void calcUri(const SBuf *file);
     void changeState(const Ftp::ServerState newState, const char *reason);
-    ClientSocketContext *handleUserRequest(const SBuf &cmd, SBuf &params);
+    Http::Stream *handleUserRequest(const SBuf &cmd, SBuf &params);
     bool checkDataConnPost() const;
     void replyDataWritingCheckpoint();
     void maybeReadUploadData();
@@ -143,7 +143,7 @@ class Server: public ConnStateData
     void writeForwardedReplyAndCall(const HttpReply *reply, AsyncCall::Pointer &call);
     void writeReply(MemBuf &mb);
 
-    ClientSocketContext *earlyError(const EarlyErrorKind eek);
+    Http::Stream *earlyError(const EarlyErrorKind eek);
     bool handleRequest(HttpRequest *);
     void setDataCommand();
     bool checkDataConnPre();
@@ -15,6 +15,7 @@
 #include "client_side_request.h"
 #include "comm/Write.h"
 #include "http/one/RequestParser.h"
+#include "http/Stream.h"
 #include "HttpHeaderTools.h"
 #include "profiler/Profiler.h"
 #include "servers/Http1Server.h"
@@ -70,7 +71,7 @@ Http::One::Server::noteMoreBodySpaceAvailable(BodyPipe::Pointer)
     readSomeData();
 }
 
-ClientSocketContext *
+Http::Stream *
 Http::One::Server::parseOneRequest()
 {
     PROF_start(HttpServer_parseOneRequest);
@@ -82,17 +83,17 @@ Http::One::Server::parseOneRequest()
         parser_ = new Http1::RequestParser();
 
     /* Process request */
-    ClientSocketContext *context = parseHttpRequest(this, parser_);
+    Http::Stream *context = parseHttpRequest(this, parser_);
 
     PROF_stop(HttpServer_parseOneRequest);
     return context;
 }
 
 void clientProcessRequestFinished(ConnStateData *conn, const HttpRequest::Pointer &request);
-bool clientTunnelOnError(ConnStateData *conn, ClientSocketContext *context, HttpRequest *request, const HttpRequestMethod& method, err_type requestError, Http::StatusCode errStatusCode, const char *requestErrorBytes);
+bool clientTunnelOnError(ConnStateData *conn, Http::Stream *context, HttpRequest *request, const HttpRequestMethod& method, err_type requestError, Http::StatusCode errStatusCode, const char *requestErrorBytes);
 
 bool
-Http::One::Server::buildHttpRequest(ClientSocketContext *context)
+Http::One::Server::buildHttpRequest(Http::Stream *context)
 {
     HttpRequest::Pointer request;
     ClientHttpRequest *http = context->http;
@@ -179,14 +180,14 @@ Http::One::Server::buildHttpRequest(ClientSocketContext *context)
 }
 
 void
-Http::One::Server::proceedAfterBodyContinuation(ClientSocketContext::Pointer context)
+Http::One::Server::proceedAfterBodyContinuation(Http::StreamPointer context)
 {
     debugs(33, 5, "Body Continuation written");
     clientProcessRequest(this, parser_, context.getRaw());
 }
 
 void
-Http::One::Server::processParsedRequest(ClientSocketContext *context)
+Http::One::Server::processParsedRequest(Http::Stream *context)
 {
     if (!buildHttpRequest(context))
         return;
@@ -221,8 +222,8 @@ Http::One::Server::processParsedRequest(ClientSocketContext *context)
                 HttpReply::Pointer rep = new HttpReply;
                 rep->sline.set(Http::ProtocolVersion(), Http::scContinue);
 
-                typedef UnaryMemFunT<Http1::Server, ClientSocketContext::Pointer> CbDialer;
-                const AsyncCall::Pointer cb = asyncCall(11, 3,  "Http1::Server::proceedAfterBodyContinuation", CbDialer(this, &Http1::Server::proceedAfterBodyContinuation, ClientSocketContext::Pointer(context)));
+                typedef UnaryMemFunT<Http1::Server, Http::StreamPointer> CbDialer;
+                const AsyncCall::Pointer cb = asyncCall(11, 3,  "Http1::Server::proceedAfterBodyContinuation", CbDialer(this, &Http1::Server::proceedAfterBodyContinuation, Http::StreamPointer(context)));
                 sendControlMsg(HttpControlMsg(rep, cb));
                 return;
             }
@@ -242,7 +243,7 @@ void
 Http::One::Server::handleReply(HttpReply *rep, StoreIOBuffer receivedData)
 {
     // the caller guarantees that we are dealing with the current context only
-    ClientSocketContext::Pointer context = pipeline.front();
+    Http::StreamPointer context = pipeline.front();
     Must(context != nullptr);
     const ClientHttpRequest *http = context->http;
     Must(http != NULL);
@@ -262,7 +263,7 @@ Http::One::Server::handleReply(HttpReply *rep, StoreIOBuffer receivedData)
     }
 
     if (!context->startOfOutput()) {
-        context->sendBody(rep, receivedData);
+        context->sendBody(receivedData);
         return;
     }
 
@@ -29,8 +29,8 @@ class Server: public ConnStateData
 
 protected:
     /* ConnStateData API */
-    virtual ClientSocketContext *parseOneRequest();
-    virtual void processParsedRequest(ClientSocketContext *context);
+    virtual Http::Stream *parseOneRequest();
+    virtual void processParsedRequest(Http::Stream *context);
     virtual void handleReply(HttpReply *rep, StoreIOBuffer receivedData);
     virtual void writeControlMsgAndCall(HttpReply *rep, AsyncCall::Pointer &call);
     virtual time_t idleTimeout() const;
@@ -42,17 +42,17 @@ class Server: public ConnStateData
     /* AsyncJob API */
     virtual void start();
 
-    void proceedAfterBodyContinuation(ClientSocketContext::Pointer context);
+    void proceedAfterBodyContinuation(Http::StreamPointer context);
 
 private:
-    void processHttpRequest(ClientSocketContext *const context);
+    void processHttpRequest(Http::Stream *const context);
     void handleHttpRequestData();
 
     /// Handles parsing results. May generate and deliver an error reply
     /// to the client if parsing is failed, or parses the url and build the
     /// HttpRequest object using parsing results.
     /// Return false if parsing is failed, true otherwise.
-    bool buildHttpRequest(ClientSocketContext *context);
+    bool buildHttpRequest(Http::Stream *context);
 
     Http1::RequestParserPointer parser_;
     HttpRequestMethod method_; ///< parsed HTTP method
@@ -14,6 +14,7 @@
 #include "Debug.h"
 #include "fd.h"
 #include "fde.h"
+#include "http/Stream.h"
 #include "MasterXaction.h"
 #include "servers/Server.h"
 #include "SquidConfig.h"
@@ -12,6 +12,7 @@
 
 #include "client_side.h"
 #include "FwdState.h"
+#include "http/Stream.h"
 #include "ssl/ServerBump.h"
 #include "Store.h"
 #include "StoreClient.h"
@@ -19,6 +19,7 @@
 #include "fde.h"
 #include "format/Token.h"
 #include "globals.h"
+#include "http/Stream.h"
 #include "HttpRequest.h"
 #include "IoStats.h"
 #include "mem/Pool.h"
@@ -7,72 +7,55 @@
  */
 
 #include "squid.h"
-#include "client_side.h"
+#include "client_side_request.h"
+#include "http/Stream.h"
 
 #define STUB_API "client_side.cc"
 #include "tests/STUB.h"
 
-//ClientSocketContext::ClientSocketContext(const ConnectionPointer&, ClientHttpRequest*) STUB
-//ClientSocketContext::~ClientSocketContext() STUB
-bool ClientSocketContext::startOfOutput() const STUB_RETVAL(false)
-void ClientSocketContext::writeComplete(size_t size) STUB
-void ClientSocketContext::pullData() STUB
-int64_t ClientSocketContext::getNextRangeOffset() const STUB_RETVAL(0)
-bool ClientSocketContext::canPackMoreRanges() const STUB_RETVAL(false)
-clientStream_status_t ClientSocketContext::socketState() STUB_RETVAL(STREAM_NONE)
-void ClientSocketContext::sendBody(HttpReply * rep, StoreIOBuffer bodyData) STUB
-void ClientSocketContext::sendStartOfMessage(HttpReply * rep, StoreIOBuffer bodyData) STUB
-size_t ClientSocketContext::lengthToSend(Range<int64_t> const &available) STUB_RETVAL(0)
-void ClientSocketContext::noteSentBodyBytes(size_t) STUB
-void ClientSocketContext::buildRangeHeader(HttpReply * rep) STUB
-clientStreamNode * ClientSocketContext::getTail() const STUB_RETVAL(NULL)
-clientStreamNode * ClientSocketContext::getClientReplyContext() const STUB_RETVAL(NULL)
-void ClientSocketContext::finished() STUB
-void ClientSocketContext::deferRecipientForLater(clientStreamNode * node, HttpReply * rep, StoreIOBuffer receivedData) STUB
-bool ClientSocketContext::multipartRangeRequest() const STUB_RETVAL(false)
-void ClientSocketContext::registerWithConn() STUB
-void ClientSocketContext::noteIoError(const int xerrno) STUB
-
+#include "client_side.h"
 bool ConnStateData::clientParseRequests() STUB_RETVAL(false)
 void ConnStateData::readNextRequest() STUB
 bool ConnStateData::isOpen() const STUB_RETVAL(false)
 void ConnStateData::kick() STUB
-void ConnStateData::sendControlMsg(HttpControlMsg msg) STUB
+void ConnStateData::sendControlMsg(HttpControlMsg) STUB
 int64_t ConnStateData::mayNeedToReadMoreBody() const STUB_RETVAL(0)
 #if USE_AUTH
-void ConnStateData::setAuth(const Auth::UserRequest::Pointer &aur, const char *cause) STUB
+void ConnStateData::setAuth(const Auth::UserRequest::Pointer &, const char *) STUB
 #endif
 bool ConnStateData::transparent() const STUB_RETVAL(false)
-void ConnStateData::stopReceiving(const char *error) STUB
-void ConnStateData::stopSending(const char *error) STUB
+void ConnStateData::stopReceiving(const char *) STUB
+void ConnStateData::stopSending(const char *) STUB
 void ConnStateData::expectNoForwarding() STUB
 void ConnStateData::noteMoreBodySpaceAvailable(BodyPipe::Pointer) STUB
 void ConnStateData::noteBodyConsumerAborted(BodyPipe::Pointer) STUB
 bool ConnStateData::handleReadData() STUB_RETVAL(false)
 bool ConnStateData::handleRequestBodyData() STUB_RETVAL(false)
-void ConnStateData::pinConnection(const Comm::ConnectionPointer &pinServerConn, HttpRequest *request, CachePeer *peer, bool auth, bool monitor) STUB
-void ConnStateData::unpinConnection(const bool andClose) STUB
-const Comm::ConnectionPointer ConnStateData::validatePinnedConnection(HttpRequest *request, const CachePeer *peer) STUB_RETVAL(NULL)
-void ConnStateData::clientPinnedConnectionClosed(const CommCloseCbParams &io) STUB
-void ConnStateData::connStateClosed(const CommCloseCbParams &io) STUB
-void ConnStateData::requestTimeout(const CommTimeoutCbParams &params) STUB
+void ConnStateData::pinConnection(const Comm::ConnectionPointer &, HttpRequest *, CachePeer *, bool, bool) STUB
+void ConnStateData::unpinConnection(const bool) STUB
+const Comm::ConnectionPointer ConnStateData::validatePinnedConnection(HttpRequest *, const CachePeer *) STUB_RETVAL(NULL)
+void ConnStateData::clientPinnedConnectionClosed(const CommCloseCbParams &) STUB
+void ConnStateData::connStateClosed(const CommCloseCbParams &) STUB
+void ConnStateData::requestTimeout(const CommTimeoutCbParams &) STUB
 void ConnStateData::swanSong() STUB
-void ConnStateData::quitAfterError(HttpRequest *request) STUB
+void ConnStateData::quitAfterError(HttpRequest *) STUB
 #if USE_OPENSSL
-void ConnStateData::httpsPeeked(Comm::ConnectionPointer serverConnection) STUB
+void ConnStateData::httpsPeeked(Comm::ConnectionPointer) STUB
 void ConnStateData::getSslContextStart() STUB
 void ConnStateData::getSslContextDone(Security::ContextPtr, bool) STUB
-void ConnStateData::sslCrtdHandleReplyWrapper(void *data, const Helper::Reply &reply) STUB
-void ConnStateData::sslCrtdHandleReply(const Helper::Reply &reply) STUB
-void ConnStateData::switchToHttps(HttpRequest *request, Ssl::BumpMode bumpServerMode) STUB
-void ConnStateData::buildSslCertGenerationParams(Ssl::CertificateProperties &certProperties) STUB
-bool ConnStateData::serveDelayedError(ClientSocketContext *context) STUB_RETVAL(false)
+void ConnStateData::sslCrtdHandleReplyWrapper(void *, const Helper::Reply &) STUB
+void ConnStateData::sslCrtdHandleReply(const Helper::Reply &) STUB
+void ConnStateData::switchToHttps(HttpRequest *, Ssl::BumpMode) STUB
+void ConnStateData::buildSslCertGenerationParams(Ssl::CertificateProperties &) STUB
+bool ConnStateData::serveDelayedError(Http::Stream *) STUB_RETVAL(false)
 #endif
 
-void setLogUri(ClientHttpRequest * http, char const *uri, bool cleanUrl) STUB
-const char *findTrailingHTTPVersion(const char *uriAndHTTPVersion, const char *end) STUB_RETVAL(NULL)
-int varyEvaluateMatch(StoreEntry * entry, HttpRequest * req) STUB_RETVAL(0)
+void setLogUri(ClientHttpRequest *, char const *, bool) STUB
+const char *findTrailingHTTPVersion(const char *, const char *) STUB_RETVAL(NULL)
+int varyEvaluateMatch(StoreEntry *, HttpRequest *) STUB_RETVAL(0)
 void clientOpenListenSockets(void) STUB
 void clientHttpConnectionsClose(void) STUB
 void httpRequestFree(void *) STUB
+void clientPackRangeHdr(const HttpReply *, const HttpHdrRangeSpec *, String, MemBuf *) STUB
+void clientPackTermBound(String, MemBuf *) STUB
 
@@ -8,6 +8,7 @@
 
 #include "squid.h"
 #include "client_side_request.h"
+#include "http/Stream.h"
 #include "Store.h"
 
 #if !_USE_INLINE_
@@ -17,6 +17,7 @@
 #include "fqdncache.h"
 #include "fs_io.h"
 #include "htcp.h"
+#include "http/Stream.h"
 #include "ICP.h"
 #include "ip/Intercept.h"
 #include "ip/QosConfig.h"
@@ -25,6 +25,7 @@
 #include "FwdState.h"
 #include "globals.h"
 #include "http.h"
+#include "http/Stream.h"
 #include "HttpRequest.h"
 #include "HttpStateFlags.h"
 #include "ip/QosConfig.h"
@@ -1238,7 +1239,7 @@ switchToTunnel(HttpRequest *request, Comm::ConnectionPointer &clientConn, Comm::
     tunnelState = new TunnelStateData;
     tunnelState->url = SBufToCstring(url);
     tunnelState->request = request;
-    tunnelState->server.size_ptr = NULL; //Set later if ClientSocketContext is available
+    tunnelState->server.size_ptr = NULL; //Set later if Http::Stream is available
 
     // Temporary static variable to store the unneeded for our case status code
     static int status_code = 0;
@@ -1247,7 +1248,7 @@ switchToTunnel(HttpRequest *request, Comm::ConnectionPointer &clientConn, Comm::
 
     ConnStateData *conn;
     if ((conn = request->clientConnectionManager.get())) {
-        ClientSocketContext::Pointer context = conn->pipeline.front();
+        Http::StreamPointer context = conn->pipeline.front();
         if (context != nullptr && context->http != nullptr) {
             tunnelState->logTag_ptr = &context->http->logType;
             tunnelState->server.size_ptr = &context->http->out.size;