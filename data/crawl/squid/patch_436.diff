@@ -1,4 +1,27 @@
-Changes to squid-3.2.0.17 (12 Apr 2011):
+Changes to squid-3.2.0.18 (29 Jun 2012):
+
+	- Bug 3576: ICY streams being Transfer-Encoding:chunked
+	- Bug 3537: statistics histogram leaks memory
+	- Bug 3526: digest authentication crash
+	- Bug 3484: Docs: sslproxy_cert_error example flawed
+	- Bug 3462: Delay Pools and ICAP
+	- Bug 3405: ssl_crtd crashes failing to remove certificate
+	- Bug 3380: Mac OSX compile errors with CMSG_SPACE
+	- Bug 3258: Requests hang when Host forgery verify fails
+	- Bug 3186: Digest auth caches failed state without revalidating
+	- Bug 2976: ERR_INVALID_URL for transparently captured requests when reconfiguring
+	- Bug 2885: AIX: check and set required compiler flags
+	- Fix ssl_crtd compile issues with libsslutil
+	- Fix build with GCC 4.7 (and probably other C++11 compilers).
+	- Fix double-escape of %R on deny_info redirect responses
+	- Support status 308 Permanent Redirect
+	- Support for TLSv1.1 and TLSv1.2 options and methods
+	- Support passing external_acl_type credentials on ICAP
+	- Language Updates: fr, hy, pt_BR
+	- ... and many compile issues on Windows
+	- ... and some minor code polish
+
+Changes to squid-3.2.0.17 (12 Apr 2012):
 
 	- Bug 3527: EUI compile errors on Mac OS X 10.5.8 PPC
 	- Bug 3509: kQueue compile error
@@ -10,7 +33,7 @@ Changes to squid-3.2.0.17 (12 Apr 2011):
 	- Solaris 9/10 various build fixes
 	- ... and some more code polish
 
-Changes to squid-3.2.0.16 (07 Mar 2011):
+Changes to squid-3.2.0.16 (07 Mar 2012):
 
 	- Bug 3508: Correct DNS timeout handling.
 	- Bug 3503: DNS PTR queries timeout due to wrong QIDs.
@@ -28,7 +51,7 @@ Changes to squid-3.2.0.16 (07 Mar 2011):
 	- ... and several fixes related to in-transit object performance
 	- ... and some structural design changes for portability
 
-Changes to squid-3.2.0.15 (06 Feb 2011):
+Changes to squid-3.2.0.15 (06 Feb 2012):
 
 	- Bug 3472: segfault with the message 'urlParse: URL too large'
 	- Bug 3471: segfault when %la formating code used
@@ -363,7 +386,7 @@ Changes to squid-3.2.0.1 (03 Aug 2010):
 	- ... and a great many testing improvements
 	- ... and many documentation updates
 
-Changes to squid-3.1.20 (08 Jun 2011):
+Changes to squid-3.1.20 (08 Jun 2012):
 
 	- Regression Bug 3545: FreeBSD dnsserver segfaults
 	- Regression Bug 3504: clientside_tos fails to mark traffic
@@ -383,7 +406,7 @@ Changes to squid-3.1.20 (08 Jun 2011):
 	- Support CoAP over HTTP (coap:// and coaps:// URLs)
 	- Support for 3.2 error template codes
 
-Changes to squid-3.1.19 (06 Feb 2011):
+Changes to squid-3.1.19 (06 Feb 2012):
 
 	- Regression Bug 3441: part 2: Prevent further cache size corruption of swap.state
 	- Bug 3473: erase last uses of obsolete auth_user_hash_pointer
@@ -520,7 +543,7 @@ Changes to squid-3.1.12 (04 Apr 2011):
 	- Bug 3164: Total memory info display 32-bit overflows
 	- Bug 3155: Werror is hard-coded in libTrie build
 	- Bug 3151: squid_kerb_auth: use autoconf LIBS instead of FLAGS for library linkage
-	- Bug 2976: invalid URL on intercepted requests during reconfigure
+	- Bug 2976: invalid URL on intercepted requests during reconfigure (workaround)
 	- Bug 2720: comment in same line as cache/mem_replacement_policy causes error
 	- Bug 2621: Provide request headers to RESPMOD when using cache_peer.
 	- Bug 2330: AuthUser objects are never unlocked
@@ -829,14 +829,21 @@ void squid_getprotobynumber(void) {
   SQUID_STATE_ROLLBACK(winsock)
 ])
 
-
 dnl check that setresuid is properly implemented.
 dnl sets squid_cv_resuid_works to "yes" or "no"
 AC_DEFUN([SQUID_CHECK_SETRESUID_WORKS],[
   AC_CACHE_CHECK(if setresuid is actually implemented, squid_cv_resuid_works,
     AC_RUN_IFELSE([
       AC_LANG_SOURCE([[
+#if HAVE_STDLIB_H
 #include <stdlib.h>
+#endif
+#if HAVE_STDIO_H
+#include <stdio.h>
+#endif
+#if HAVE_UNISTD_H
+#include <unistd.h>
+#endif
   int main(int argc, char **argv) {
     if(setresuid(-1,-1,-1)) {
       perror("setresuid:");
@@ -87,7 +87,7 @@ squid_strnstr(const char *s, const char *find, size_t slen)
             if (len > slen)
                 return (NULL);
         } while (strncmp(s, find, len) != 0);
-        s--;
+        --s;
     }
     return s;
 }
@@ -28,7 +28,7 @@ XMS_DBG_INDEX(int sz)
 static void
 stat_init(void)
 {
-    for (int i = 0; i <= XMS_DBG_MAXINDEX; i++)
+    for (int i = 0; i <= XMS_DBG_MAXINDEX; ++i)
         malloc_sizes[i] = malloc_histo[i] = 0;
 
     dbg_stat_init = 1;
@@ -83,7 +83,7 @@ xstrerr(int error)
 
 #if _SQUID_WINDOWS_
     // Description of WSAGetLastError()
-    for (size_t i = 0; i < sizeof(_wsaerrtext) / sizeof(struct _wsaerrtext); i++) {
+    for (size_t i = 0; i < sizeof(_wsaerrtext) / sizeof(struct _wsaerrtext); ++i) {
         if (_wsaerrtext[i].err == error) {
             // small optimization, save using a temporary buffer and two copies...
             snprintf(xstrerror_buf, BUFSIZ, "(%d) %s, %s", error, _wsaerrtext[i].errconst, _wsaerrtext[i].errdesc);
@@ -31,12 +31,14 @@ Although this release is deemed good enough for use in many setups, please note
 
 <itemize>
 	<item>The lack of some features available in Squid-2.x series. See the regression sections below for full details.
+	<item>eCAP library version 0.2.0 and later are not supported. See eCAP section below for details.
+	<item>CVE-2009-0801 : NAT interception vulnerability to malicious clients. This is fixed in 3.2 series.
+		Some attempts have been made to port for 3.1, but the unreliability of NAT handling in 3.1 makes this unsafe.
 </itemize>
 
 <p>Currently known issues which only depends on available developer time and may still be resolved in a future 3.1 release are:
 
 <itemize>
-	<item>CVE-2009-0801 : NAT interception vulnerability to malicious clients. This is fixed in 3.2 series.
 	<item>Windows support is still largely missing.
 	<item>AIX support for building with the IBM compiler is broken.
 	<item>OpenSSL 1.0.0 support is incomplete.
@@ -319,6 +321,9 @@ reduce the number of warnings by blocking some embedded content.
 
 <p>Currently known and available eCAP modules are listed in the wiki feature page on eCAP.
 
+<p><em>Known Issue:</em> libecap version 0.0.3 (exactly) is required to build this series
+  of Squid. Other versions of libecap contain significant interface differences.
+
 
 <sect1>ICAP Bypass and Retry enhancements
 
@@ -1,6 +1,6 @@
 <!doctype linuxdoc system>
 <article>
-<title>Squid 3.2.0.17 release notes</title>
+<title>Squid 3.2.0.18 release notes</title>
 <author>Squid Developers</author>
 
 <abstract>
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 <sect>Notice
 <p>
-The Squid Team are pleased to announce the release of Squid-3.2.0.17 for testing.
+The Squid Team are pleased to announce the release of Squid-3.2.0.18 for testing.
 
 This new release is available for download from <url url="http://www.squid-cache.org/Versions/v3/3.2/"> or the <url url="http://www.squid-cache.org/Mirrors/http-mirrors.html" name="mirrors">.
 
@@ -26,6 +26,17 @@ report with a stack trace.
 <p>
 Although this release is deemed good enough for use in many setups, please note the existence of <url url="http://bugs.squid-cache.org/buglist.cgi?query_format=advanced&amp;short_desc_type=allwordssubstr&amp;short_desc=&amp;target_milestone=3.2&amp;long_desc_type=allwordssubstr&amp;long_desc=&amp;bug_file_loc_type=allwordssubstr&amp;bug_file_loc=&amp;status_whiteboard_type=allwordssubstr&amp;status_whiteboard=&amp;bug_status=NEW&amp;bug_status=ASSIGNED&amp;bug_status=REOPENED&amp;emailtype1=substring&amp;email1=&amp;emailtype2=substring&amp;email2=&amp;bugidtype=include&amp;bug_id=&amp;votes=&amp;chfieldfrom=&amp;chfieldto=Now&amp;chfieldvalue=&amp;cmdtype=doit&amp;order=bugs.bug_severity&amp;field0-0-0=noop&amp;type0-0-0=noop&amp;value0-0-0=" name="open bugs against Squid-3.2">.
 
+<p>Currently known issues which only depends on available developer time and may still be resolved in a future 3.2 release are:
+
+<itemize>
+	<item>CVE-2009-0801 : interception proxies cannot relay certain requests to peers. see the CVE section below for details.
+	<item>SMP Support still has a number of important bugs needing to be resolved. see the bugs list above for details.
+	<item>Windows support is still incomplete.
+	<item>TCP logging of access.log does not recover from broken connections well.
+	<item>The lack of some features available in Squid-2.x series. See the regression sections below for full details.
+</itemize>
+
+
 <sect1>Changes since earlier releases of Squid-3.2
 <p>
 The 3.2 change history can be <url url="http://www.squid-cache.org/Versions/v3/3.2/changesets/" name="viewed here">.
@@ -40,7 +51,7 @@ The 3.2 change history can be <url url="http://www.squid-cache.org/Versions/v3/3
 	<item>Helper Multiplexer and On-Demand
 	<item>Helper Name Changes
 	<item>Multi-Lingual manuals
-	<item>Solaris 10 pthreads Support (Experimental)
+	<item>Solaris 10 pthreads Support
 	<item>Surrogate/1.0 protocol extensions to HTTP
 	<item>Logging Infrastructure Updated
 	<item>Client Bandwidth Limits
@@ -61,8 +72,20 @@ Most user-facing changes are reflected in squid.conf (see below).
   DNS entries.
 
 <p>When the Host: authority contradicts another authority source Squid will log
-  "SECURITY ALERT: Host: header forgery detected" and respond with a 409 Conflict
-  error status page.
+  "SECURITY ALERT: Host: header forgery detected". The response will then be determined
+  by the <url url="http://www.squid-cache.org/Doc/config/host_verify_strict/" name="host_verify_strict">
+  directive. Squid will respond with 409 Conflict error response when strict validation
+  fails and handles the request normally when strict validation succeeds or is OFF (default).
+
+<p>Relaying of messages which FAIL non-strct Host: validation are permitted through Squid but
+  only to the original destination IP the client was requesting. This means interception proxies
+  can not be used as feeder gateways into a cluster or peer hierarchy without strict validation.
+
+<p>Known Issue: When non-strict validation fails Squid will relay the request, but can only do
+  so to the orginal destination IP the client was contacting. This means that interception
+  proxy Squid are unable to pass traffic reliably to peers in a cache hierarchy.
+  Developer time is required to implement safe transit of these requests.
+  Please contact squid-dev if you are able to assist or sponsor the development.
 
 
 <sect1>SMP scalability
@@ -309,6 +332,9 @@ Most user-facing changes are reflected in squid.conf (see below).
   These logs are now created using an access_log line with the format "referrer" or "useragent".
   They also now log all client requests, if there was no Referer or User-Agent header a dash (-) is logged.
 
+<p>Known Issue: The TCP logging module does not recover from broken connections well.
+  At present it will restart the affected Squid instance if the TCP connection is broken.
+
 
 <sect1> Client Bandwidth Limits
 <p>In mobile environments, Squid may need to limit Squid-to-client bandwidth
@@ -344,6 +370,9 @@ Most user-facing changes are reflected in squid.conf (see below).
 <p>Support for libecap version 0.2.0 has been added with this series of Squid. Bringing
    better support for body handling, and logging.
 
+<p>Known Issue: Due to API changes in libecap this release of Squid will not build
+  against any older libecap releases.
+
 
 <sect1>Cache Manager access changes
 <p>The Squid Cache Manager has previously only been accessible under the cache_object://
@@ -452,6 +481,14 @@ This section gives a thorough account of those changes in three categories:
 	<tag>eui_lookup</tag>
 	<p>Whether to lookup the EUI or MAC address of a connected client.
 
+	<tag>host_verify_strict</tag>
+	<p>New option to enable super-strict HTTP and DNS information match.
+	Ensuring the HTTP URI details, DNS records, and TCP connection layers all match in a
+	three-legged security verification. Preventing domain hijacking or malicious poisoning
+	attacks by malicious scripts.
+	<p>The default is to verify only intercepted traffic, to log all issues and let failed
+	traffic through when doing so can be done safely.
+
 	<tag>icap_206_enable</tag>
 	<p>New option to toggle whether the ICAP 206 (Partial Content) responses extension.
 	   Default is on.
@@ -539,6 +576,7 @@ This section gives a thorough account of those changes in three categories:
 	   <em>idle=N</em> determines how many helper to retain as buffer against sudden traffic loads.
 	   <em>concurrency=N</em> previously called <em>auth_param ... concurrency</em> as a separate option.
 	<p>Removed Basic, Digest, NTLM, Negotiate <em>auth_param ... concurrency</em> setting option.
+	<p>Known Issue: NTLM and Negotiate protocols do not support concurrency. When set this option is ignored.
 
 	<tag>cache_dir</tag>
 	<p><em>min-size</em> option ported from Squid-2
@@ -624,6 +662,18 @@ This section gives a thorough account of those changes in three categories:
 	<p>New option <em>max-stale=</em> to provide a maximum staleness factor. Squid won't
 	   serve objects more stale than this even if it failed to validate the object.
 
+	<tag>reply_header_access</tag>
+	<p>Added support for custom response header names.</p>
+
+	<tag>request_header_access</tag>
+	<p>Added support for custom request header names.</p>
+
+	<tag>reply_header_replace</tag>
+	<p>Added support for custom response header names.</p>
+
+	<tag>request_header_replace</tag>
+	<p>Added support for custom request header names.</p>
+
 	<tag>tcp_outgoing_address</tag>
 	<p>This parameter is now compatible with persistent server connections.
 	   The IPv6 magic 'to_ipv6' hacks needed in 3.1 are now no longer necessary.
@@ -267,7 +267,7 @@ open_ldap_connection(const char *ldapServer, int port)
                         sslpath);
                 exit(1);
             } else {
-                sslinit++;
+                ++sslinit;
             }
             if ((ld = ldapssl_init(ldapServer, port, 1)) == NULL) {
                 fprintf(stderr, "\nUnable to connect to SSL LDAP server: %s port:%d\n",
@@ -332,7 +332,7 @@ validUsername(const char *user)
             if (p[0] != ' ')
                 return 0;
         }
-        p++;
+        ++p;
     }
     /* Trailing whitespace? */
     if (xisspace(p[0]))
@@ -368,14 +368,14 @@ main(int argc, char **argv)
                 value = argv[1] + 2;
             } else if (argc > 2) {
                 value = argv[2];
-                argv++;
-                argc--;
+                ++argv;
+                --argc;
             } else
                 value = "";
             break;
         }
-        argv++;
-        argc--;
+        ++argv;
+        --argc;
         switch (option) {
         case 'H':
 #if !HAS_URI_SUPPORT
@@ -513,8 +513,8 @@ main(int argc, char **argv)
         } else {
             ldapServer = xstrdup(value);
         }
-        argc--;
-        argv++;
+        --argc;
+        ++argv;
     }
     if (!ldapServer)
         ldapServer = xstrdup("localhost");
@@ -630,8 +630,8 @@ ldap_escape_value(char *escaped, int size, const char *src)
             break;
         default:
             *escaped++ = *src++;
-            n++;
-            size--;
+            ++n;
+            --size;
         }
     }
     *escaped = '\0';
@@ -199,7 +199,7 @@ AddServer(char *ParamPDC, char *ParamBDC, char *ParamDomain)
     strncpy(ServerArray[Serversqueried].pdc, ParamPDC, NTHOSTLEN - 1);
     strncpy(ServerArray[Serversqueried].bdc, ParamBDC, NTHOSTLEN - 1);
     strncpy(ServerArray[Serversqueried].domain, ParamDomain, NTHOSTLEN - 1);
-    Serversqueried++;
+    ++Serversqueried;
 }
 
 /*
@@ -212,7 +212,7 @@ int
 QueryServers(char *username, char *password)
 {
     int i;
-    for (i = 0; i < Serversqueried; i++) {
+    for (i = 0; i < Serversqueried; ++i) {
         if (0 == QueryServerForUser(i, username, password))
             return 0;
     }
@@ -38,7 +38,7 @@ static void
 free_names(usersfile * uf)
 {
     int i;
-    for (i = 0; i < uf->Inuse; i++) {
+    for (i = 0; i < uf->Inuse; ++i) {
         if (uf->names[i])
             free(uf->names[i]);
         uf->names[i] = NULL;
@@ -115,7 +115,7 @@ Read_usersfile(const char *path, usersfile * uf)
                    (uf->Alloc >> 1) * sizeof(*uf->names));
         }
         uf->names[uf->Inuse] = xstrdup(buf);
-        uf->Inuse++;
+        ++uf->Inuse;
     }
     fclose(fp);
     fp = NULL;
@@ -61,9 +61,9 @@ char *crypt_md5(const char *pw, const char *salt)
     if (*salt == '$') {
         magic = salt++;
         while (*salt && *salt != '$')
-            salt++;
+            ++salt;
         if (*salt == '$') {
-            salt++;
+            ++salt;
             magiclen = salt - magic;
         } else {
             salt = magic;
@@ -75,7 +75,7 @@ char *crypt_md5(const char *pw, const char *salt)
     sp = salt;
 
     /* It stops at the first '$', max 8 chars */
-    for (ep = sp; *ep && *ep != '$' && ep < (sp + 8); ep++)
+    for (ep = sp; *ep && *ep != '$' && ep < (sp + 8); ++ep)
         continue;
 
     /* get the length of the true salt */
@@ -124,7 +124,7 @@ char *crypt_md5(const char *pw, const char *salt)
      * On a 60 Mhz Pentium this takes 34 msec, so you would
      * need 30 seconds to build a 1000 entry dictionary...
      */
-    for (i = 0; i < 1000; i++) {
+    for (i = 0; i < 1000; ++i) {
         SquidMD5Init(&ctx1);
         if (i & 1)
             SquidMD5Update(&ctx1, (unsigned const char *) pw, strlen(pw));
@@ -188,7 +188,7 @@ char *md5sum(const char *s)
     SquidMD5Update(&ctx,(const unsigned char *)s,strlen(s));
     SquidMD5Final(digest,&ctx);
 
-    for (idx=0; idx<16; idx++)
+    for (idx=0; idx<16; ++idx)
         snprintf(&sum[idx*2],(33-(idx*2)),"%02x",digest[idx]);
 
     sum[32]='\0';
@@ -82,7 +82,7 @@ print_esc(FILE * p, char *s)
     char *t;
     int i = 0;
 
-    for (t = s; *t != '\0'; t++) {
+    for (t = s; *t != '\0'; ++t) {
         if (i > HELPER_INPUT_BUFFER-2) {
             buf[i] = '\0';
             (void) fputs(buf, p);
@@ -118,7 +118,7 @@ main(int argc, char *argv[])
         return 1;
 
     /* parse command line arguments */
-    for (i = 1; i < argc; i++) {
+    for (i = 1; i < argc; ++i) {
         if (strcmp(argv[i], "-d") == 0) {
             debug_enabled = 1;
             continue;
@@ -178,13 +178,13 @@ main(int argc, char *argv[])
                     return 1;
 
                 /* convert backslashes to forward slashes */
-                for (s = lastdom->authshare; *s != '\0'; s++)
+                for (s = lastdom->authshare; *s != '\0'; ++s)
                     if (*s == '\\')
                         *s = '/';
 
                 /* strip leading forward slash from share name */
                 if (*lastdom->authshare == '/')
-                    lastdom->authshare++;
+                    ++lastdom->authshare;
 
                 if ((s = strchr(lastdom->authshare, '/')) != NULL) {
                     *s = '\0';
@@ -93,7 +93,7 @@ Valid_Group(char *UserName, char *Group)
      */
     if (nStatus == NERR_Success) {
         if ((pTmpBuf = pBuf) != NULL) {
-            for (i = 0; i < dwEntriesRead; i++) {
+            for (i = 0; i < dwEntriesRead; ++i) {
                 if (pTmpBuf == NULL) {
                     result = FALSE;
                     break;
@@ -102,8 +102,8 @@ Valid_Group(char *UserName, char *Group)
                     result = TRUE;
                     break;
                 }
-                pTmpBuf++;
-                dwTotalCount++;
+                ++pTmpBuf;
+                ++dwTotalCount;
             }
         }
     } else
@@ -136,7 +136,7 @@ Valid_User(char *UserName, char *Password, char *Group)
     errormsg = NTV_SERVER_ERROR_MSG;
     strncpy(NTDomain, UserName, sizeof(NTDomain));
 
-    for (i=0; i < strlen(NTV_VALID_DOMAIN_SEPARATOR); i++) {
+    for (i=0; i < strlen(NTV_VALID_DOMAIN_SEPARATOR); ++i) {
         if ((domain_qualify = strchr(NTDomain, NTV_VALID_DOMAIN_SEPARATOR[i])) != NULL)
             break;
     }
@@ -177,8 +177,8 @@ ldap_escape_value(char *escaped, int size, const char *src)
             break;
         default:
             *escaped++ = *src++;
-            n++;
-            size--;
+            ++n;
+            --size;
         }
     }
     *escaped = '\0';
@@ -226,7 +226,7 @@ getpassword(char *login, char *realm)
                     ldap_msgfree(res);
                     /* try to connect to the LDAP server agin, maybe my persisten conexion failed. */
                     if (!retry) {
-                        retry++;
+                        ++retry;
                         ldap_unbind(ld);
                         ld = NULL;
                         ldapconnect();
@@ -267,7 +267,7 @@ getpassword(char *login, char *realm)
                     password = *value;
                     break;
                 }
-                value++;
+                ++value;
             }
             debug("password: %s\n", password);
             if (password)
@@ -279,7 +279,7 @@ getpassword(char *login, char *realm)
             fprintf(stderr, PROGRAM_NAME " WARNING, LDAP error '%s'\n", ldap_err2string(rc));
             /* try to connect to the LDAP server agin, maybe my persisten conexion failed. */
             if (!retry) {
-                retry++;
+                ++retry;
                 ldap_unbind(ld);
                 ld = NULL;
                 ldapconnect();
@@ -330,7 +330,7 @@ ldapconnect(void)
                             sslpath);
                     exit(1);
                 } else {
-                    sslinit++;
+                    ++sslinit;
                 }
                 if ((ld = ldapssl_init(ldapServer, port, 1)) == NULL) {
                     fprintf(stderr, "\nUnable to connect to SSL LDAP server: %s port:%d\n",
@@ -408,14 +408,14 @@ LDAPArguments(int argc, char **argv)
                 value = argv[1] + 2;
             } else if (argc > 2) {
                 value = argv[2];
-                argv++;
-                argc--;
+                ++argv;
+                --argc;
             } else
                 value = "";
             break;
         }
-        argv++;
-        argc--;
+        ++argv;
+        --argc;
         switch (option) {
         case 'H':
 #if !HAS_URI_SUPPORT
@@ -559,8 +559,8 @@ LDAPArguments(int argc, char **argv)
         } else {
             ldapServer = xstrdup(value);
         }
-        argc--;
-        argv++;
+        --argc;
+        ++argv;
     }
 
     if (!ldapServer)
@@ -181,7 +181,7 @@ static int berEncodeLoginData(
         err = (ber_printf(requestBer, "{i{", methodIDLen) < 0) ? LDAP_ENCODING_ERROR : 0;
     }
 
-    for (i = 0; !err && i < elemCnt; i++) {
+    for (i = 0; !err && i < elemCnt; ++i) {
         err = (ber_printf(requestBer, "i", methodID[i]) < 0) ? LDAP_ENCODING_ERROR : 0;
     }
 
@@ -178,8 +178,8 @@ ldap_escape_value(char *escaped, int size, const char *src)
             break;
         default:
             *escaped++ = *src++;
-            n++;
-            size--;
+            ++n;
+            --size;
         }
     }
     *escaped = '\0';
@@ -230,7 +230,7 @@ getpassword(char *login, char *realm)
                     ldap_msgfree(res);
                     /* try to connect to the LDAP server agin, maybe my persisten conexion failed. */
                     if (!retry) {
-                        retry++;
+                        ++retry;
                         ldap_unbind(ld);
                         ld = NULL;
                         ldapconnect();
@@ -290,7 +290,7 @@ getpassword(char *login, char *realm)
                     password = *value;
                     break;
                 }
-                value++;
+                ++value;
             }
             debug("password: %s\n", password);
             if (password)
@@ -307,7 +307,7 @@ getpassword(char *login, char *realm)
             fprintf(stderr, PROGRAM_NAME " WARNING, LDAP error '%s'\n", ldap_err2string(rc));
             /* try to connect to the LDAP server agin, maybe my persisten conexion failed. */
             if (!retry) {
-                retry++;
+                ++retry;
                 ldap_unbind(ld);
                 ld = NULL;
                 ldapconnect();
@@ -358,7 +358,7 @@ ldapconnect(void)
                             sslpath);
                     exit(1);
                 } else {
-                    sslinit++;
+                    ++sslinit;
                 }
                 if ((ld = ldapssl_init(ldapServer, port, 1)) == NULL) {
                     fprintf(stderr, "\nUnable to connect to SSL LDAP server: %s port:%d\n",
@@ -436,14 +436,14 @@ LDAPArguments(int argc, char **argv)
                 value = argv[1] + 2;
             } else if (argc > 2) {
                 value = argv[2];
-                argv++;
-                argc--;
+                ++argv;
+                --argc;
             } else
                 value = "";
             break;
         }
-        argv++;
-        argc--;
+        ++argv;
+        --argc;
         switch (option) {
         case 'H':
 #if !HAS_URI_SUPPORT
@@ -590,8 +590,8 @@ LDAPArguments(int argc, char **argv)
         } else {
             ldapServer = xstrdup(value);
         }
-        argc--;
-        argv++;
+        --argc;
+        ++argv;
     }
 
     if (!ldapServer)
@@ -358,19 +358,19 @@ add_User_Group(wchar_t * Group)
     if (User_Groups_Count == 0) {
         User_Groups = (wchar_t **) xmalloc(sizeof(wchar_t *));
         *User_Groups = NULL;
-        User_Groups_Count++;
+        ++User_Groups_Count;
     }
     array = User_Groups;
     while (*array) {
         if (wcscmp(Group, *array) == 0)
             return 0;
-        array++;
+        ++array;
     }
     User_Groups = (wchar_t **) xrealloc(User_Groups, sizeof(wchar_t *) * (User_Groups_Count + 1));
     User_Groups[User_Groups_Count] = NULL;
     User_Groups[User_Groups_Count - 1] = (wchar_t *) xmalloc((wcslen(Group) + 1) * sizeof(wchar_t));
     wcscpy(User_Groups[User_Groups_Count - 1], Group);
-    User_Groups_Count++;
+    ++User_Groups_Count;
 
     return 1;
 }
@@ -384,7 +384,7 @@ wccmparray(const wchar_t * str, const wchar_t ** array)
         debug("Windows group: %S, Squid group: %S\n", str, *array);
         if (wcscmp(str, *array) == 0)
             return 0;
-        array++;
+        ++array;
     }
     return -1;
 }
@@ -402,7 +402,7 @@ wcstrcmparray(const wchar_t * str, const char **array)
         debug("Windows group: %S, Squid group: %S\n", str, wszGroup);
         if ((use_case_insensitive_compare ? _wcsicmp(str, wszGroup) : wcscmp(str, wszGroup)) == 0)
             return 0;
-        array++;
+        ++array;
     }
     return -1;
 }
@@ -519,12 +519,12 @@ build_groups_DN_array(const char **array, char *userdomain)
         MultiByteToWideChar(CP_ACP, 0, Group, -1, wc, wcsize);
         *entry = My_NameTranslate(wc, source_group_format, ADS_NAME_TYPE_1779);
         safe_free(wc);
-        array++;
+        ++array;
         if (*entry == NULL) {
             debug("build_groups_DN_array: cannot get DN for '%s'.\n", Group);
             continue;
         }
-        entry++;
+        ++entry;
     }
     *entry = NULL;
     return wc_array;
@@ -593,8 +593,8 @@ Valid_Local_Groups(char *UserName, const char **Groups)
                     result = 1;
                     break;
                 }
-                pTmpBuf++;
-                dwTotalCount++;
+                ++pTmpBuf;
+                ++dwTotalCount;
             }
         }
     } else {
@@ -705,7 +705,7 @@ Valid_Global_Groups(char *UserName, const char **Groups)
                 result = 1;
                 break;
             }
-            tmp++;
+            ++tmp;
         }
     } else
         debug("Valid_Global_Groups: ADsGetObject for %S failed, ERROR: %s\n", User_LDAP_path, Get_WIN32_ErrorMessage(hr));
@@ -716,14 +716,14 @@ Valid_Global_Groups(char *UserName, const char **Groups)
     tmp = wszGroups;
     while (*tmp) {
         safe_free(*tmp);
-        tmp++;
+        ++tmp;
     }
     safe_free(wszGroups);
 
     tmp = User_Groups;
     while (*tmp) {
         safe_free(*tmp);
-        tmp++;
+        ++tmp;
     }
     safe_free(User_Groups);
     User_Groups_Count = 0;
@@ -251,14 +251,14 @@ main(int argc, char **argv)
                 value = argv[1] + 2;
             } else if (argc > 2) {
                 value = argv[2];
-                argv++;
-                argc--;
+                ++argv;
+                --argc;
             } else
                 value = "";
             break;
         }
-        argv++;
-        argc--;
+        ++argv;
+        --argc;
         switch (option) {
         case 'H':
 #if !HAS_URI_SUPPORT
@@ -405,8 +405,8 @@ main(int argc, char **argv)
         } else {
             ldapServer = xstrdup(value);
         }
-        argc--;
-        argv++;
+        --argc;
+        ++argv;
     }
 
     if (!ldapServer)
@@ -528,7 +528,7 @@ main(int argc, char **argv)
                             fprintf(stderr, "FATAL: Unable to initialise SSL with cert path %s\n", sslpath);
                             exit(1);
                         } else {
-                            sslinit++;
+                            ++sslinit;
                         }
                         if ((ld = ldapssl_init(ldapServer, port, 1)) == NULL) {
                             fprintf(stderr, "FATAL: Unable to connect to SSL LDAP server: %s port:%d\n",
@@ -638,8 +638,8 @@ ldap_escape_value(char *escaped, int size, const char *src)
             break;
         default:
             *escaped++ = *src++;
-            n++;
-            size--;
+            ++n;
+            --size;
         }
     }
     *escaped = '\0';
@@ -653,18 +653,18 @@ build_filter(char *filter, int size, const char *templ, const char *user, const
     while (*templ && size > 0) {
         switch (*templ) {
         case '%':
-            templ++;
+            ++templ;
             switch (*templ) {
             case 'u':
             case 'v':
-                templ++;
+                ++templ;
                 n = ldap_escape_value(filter, size, user);
                 size -= n;
                 filter += n;
                 break;
             case 'g':
             case 'a':
-                templ++;
+                ++templ;
                 n = ldap_escape_value(filter, size, group);
                 size -= n;
                 filter += n;
@@ -676,15 +676,15 @@ build_filter(char *filter, int size, const char *templ, const char *user, const
             }
             break;
         case '\\':
-            templ++;
+            ++templ;
             if (*templ) {
                 *filter++ = *templ++;
-                size--;
+                --size;
             }
             break;
         default:
             *filter++ = *templ++;
-            size--;
+            --size;
             break;
         }
     }
@@ -229,7 +229,7 @@ wcstrcmparray(const wchar_t * str, const char **array)
         debug("Windows group: %S, Squid group: %S\n", str, wszGroup);
         if ((use_case_insensitive_compare ? _wcsicmp(str, wszGroup) : wcscmp(str, wszGroup)) == 0)
             return 0;
-        array++;
+        ++array;
     }
     return -1;
 }
@@ -295,8 +295,8 @@ Valid_Local_Groups(char *UserName, const char **Groups)
                     result = 1;
                     break;
                 }
-                pTmpBuf++;
-                dwTotalCount++;
+                ++pTmpBuf;
+                ++dwTotalCount;
             }
         }
     } else
@@ -432,8 +432,8 @@ Valid_Global_Groups(char *UserName, const char **Groups)
                         result = 1;
                         break;
                     }
-                    pTmpBuf++;
-                    dwTotalCount++;
+                    ++pTmpBuf;
+                    ++dwTotalCount;
                 }
             }
         } else {
@@ -237,7 +237,7 @@ local_printfx(const char *msg,...)
     va_end(ap);
     if (x > 0) {
         dbuf[x] = '\0';
-        x++;
+        ++x;
         fputs(dbuf, stdout);
         *(dbuf) = '\0';
     } else {
@@ -267,7 +267,7 @@ StringSplit(char *In_Str, char chr, char *Out_Str, size_t Out_Sz)
     // find the char delimiter position...
     char *p = In_Str;
     while (*p != chr && *p != '\0' && (In_Str+In_Len) > p) {
-        p++;
+        ++p;
     }
 
     size_t i = (p-In_Str);
@@ -283,8 +283,8 @@ StringSplit(char *In_Str, char chr, char *Out_Str, size_t Out_Sz)
 
     // omit the delimiter
     if (*p == chr) {
-        p++;
-        i++;
+        ++p;
+        ++i;
     } else {
         // chr not found (or \0 found first). Wipe whole input buffer.
         memset(In_Str, 0, In_Len);
@@ -320,7 +320,7 @@ BinarySplit(void *In_Obj, size_t In_Sz, char chr, void *Out_Obj, size_t Out_Sz)
     // find the char delimiter position...
     char *p = static_cast<char*>(In_Obj);
     while (*p != chr && (in+In_Sz) > p) {
-        p++;
+        ++p;
     }
 
     size_t i = (p-in);
@@ -336,8 +336,8 @@ BinarySplit(void *In_Obj, size_t In_Sz, char chr, void *Out_Obj, size_t Out_Sz)
 
     // omit the delimiter
     if (*p == chr) {
-        p++;
-        i++;
+        ++p;
+        ++i;
     } else {
         // chr not found
         memset(In_Obj, 0, In_Sz);
@@ -853,13 +853,13 @@ ConvertIP(edui_ldap_t *l, char *ip)
             /* bufa starts with a ::, so just copy and clear */
             xstrncpy(bufb, bufa, sizeof(bufb));
             *(bufa) = '\0';
-            swi++;								/* Indicates that there is a bufb */
+            ++swi;								/* Indicates that there is a bufb */
         } else if ((bufa[0] == ':') && (bufa[1] != ':')) {
             /* bufa starts with a :, a typo so just fill in a ':', cat and clear */
             bufb[0] = ':';
             strncat(bufb, bufa, strlen(bufa));
             *(bufa) = '\0';
-            swi++;								/* Indicates that there is a bufb */
+            ++swi;								/* Indicates that there is a bufb */
         } else {
             p = strstr(bufa, "::");
             if (p != NULL) {
@@ -869,7 +869,7 @@ ConvertIP(edui_ldap_t *l, char *ip)
                 memcpy(bufb, p, i);
                 *p = '\0';
                 bufb[i] = '\0';
-                swi++;								/* Indicates that there is a bufb */
+                ++swi;								/* Indicates that there is a bufb */
             }
         }
     }
@@ -973,21 +973,21 @@ ConvertIP(edui_ldap_t *l, char *ip)
                 t = strlen(bufb);
                 /* How many ':' exist in bufb ? */
                 j = 0;
-                for (i = 0; i < t; i++) {
+                for (i = 0; i < t; ++i) {
                     if (bufb[i] == ':')
-                        j++;
+                        ++j;
                 }
-                j--;								/* Preceeding "::" doesn't count */
+                --j;								/* Preceeding "::" doesn't count */
                 t = 8 - (strlen(l->search_ip) / 4) - j;			/* Remainder */
                 if (t > 0) {
-                    for (i = 0; i < t; i++)
+                    for (i = 0; i < t; ++i)
                         strncat(l->search_ip, "0000", 4);
                 }
             }
         }
         if ((bufa[0] == '\0') && (swi > 0)) {
             s = strlen(bufb);
-            swi++;
+            ++swi;
         } else
             s = strlen(bufa);
     }
@@ -1095,14 +1095,14 @@ SearchFilterLDAP(edui_ldap_t *l, char *group)
     for (i = 0; i < s; i++) {
         if (swi == 2) {
             bufc[j] = '\134';
-            j++;
+            ++j;
             bufc[j] = l->search_ip[i];
-            j++;
+            ++j;
             swi = 1;
         } else {
             bufc[j] = l->search_ip[i];
-            j++;
-            swi++;
+            ++j;
+            ++swi;
         }
     }
     if (group == NULL) {
@@ -1570,7 +1570,7 @@ MainSafe(int argc, char **argv)
                             edui_conf.mode |= EDUI_MODE_PERSIST;	/* Don't set mode more than once */
                         break;
                     case 'v':
-                        i++;						/* Set LDAP version */
+                        ++i;						/* Set LDAP version */
                         if (argv[i] != NULL) {
                             edui_conf.ver = atoi(argv[i]);
                             if (edui_conf.ver < 1)
@@ -1584,7 +1584,7 @@ MainSafe(int argc, char **argv)
                         }
                         break;
                     case 't':
-                        i++;						/* Set Persistent timeout */
+                        ++i;						/* Set Persistent timeout */
                         if (argv[i] != NULL) {
                             edui_conf.persist_timeout = atoi(argv[i]);
                             if (edui_conf.persist_timeout < 0)
@@ -1596,7 +1596,7 @@ MainSafe(int argc, char **argv)
                         }
                         break;
                     case 'b':
-                        i++;						/* Set Base DN */
+                        ++i;						/* Set Base DN */
                         if (argv[i] != NULL)
                             xstrncpy(edui_conf.basedn, argv[i], sizeof(edui_conf.basedn));
                         else {
@@ -1606,7 +1606,7 @@ MainSafe(int argc, char **argv)
                         }
                         break;
                     case 'H':
-                        i++;						/* Set Hostname */
+                        ++i;						/* Set Hostname */
                         if (argv[i] != NULL)
                             xstrncpy(edui_conf.host, argv[i], sizeof(edui_conf.host));
                         else {
@@ -1616,7 +1616,7 @@ MainSafe(int argc, char **argv)
                         }
                         break;
                     case 'p':
-                        i++;						/* Set port */
+                        ++i;						/* Set port */
                         if (argv[i] != NULL)
                             edui_conf.port = atoi(argv[i]);
                         else {
@@ -1626,7 +1626,7 @@ MainSafe(int argc, char **argv)
                         }
                         break;
                     case 'D':
-                        i++;						/* Set Bind DN */
+                        ++i;						/* Set Bind DN */
                         if (argv[i] != NULL)
                             xstrncpy(edui_conf.dn, argv[i], sizeof(edui_conf.dn));
                         else {
@@ -1636,7 +1636,7 @@ MainSafe(int argc, char **argv)
                         }
                         break;
                     case 'W':
-                        i++;						/* Set Bind PWD */
+                        ++i;						/* Set Bind PWD */
                         if (argv[i] != NULL)
                             xstrncpy(edui_conf.passwd, argv[i], sizeof(edui_conf.passwd));
                         else {
@@ -1646,7 +1646,7 @@ MainSafe(int argc, char **argv)
                         }
                         break;
                     case 'F':
-                        i++;						/* Set Search Filter */
+                        ++i;						/* Set Search Filter */
                         if (argv[i] != NULL)
                             xstrncpy(edui_conf.search_filter, argv[i], sizeof(edui_conf.search_filter));
                         else {
@@ -1660,7 +1660,7 @@ MainSafe(int argc, char **argv)
                             edui_conf.mode |= EDUI_MODE_GROUP;		/* Don't set mode more than once */
                         break;
                     case 's':
-                        i++;						/* Set Scope Level */
+                        ++i;						/* Set Scope Level */
                         if (argv[i] != NULL) {
                             if (!strncmp(argv[i], "base", 4))
                                 edui_conf.scope = 0;
@@ -1677,7 +1677,7 @@ MainSafe(int argc, char **argv)
                         }
                         break;
                     case 'u':
-                        i++;						/* Set Search Attribute */
+                        ++i;						/* Set Search Attribute */
                         if (argv[i] != NULL) {
                             xstrncpy(edui_conf.attrib, argv[i], sizeof(edui_conf.attrib));
                         } else {
@@ -182,7 +182,7 @@ int
 match_group(char *dict_group, char *username)
 {
     struct group *g;		/* a struct to hold group entries */
-    dict_group++;			/* the @ should be the first char
+    ++dict_group;			/* the @ should be the first char
 				   so we rip it off by incrementing
 				   * the pointer by one */
 
@@ -385,7 +385,7 @@ main(int argc, char *const argv[])
         if (nuser || nuser8) {
             if (nuser) {
                 *nuser = '\0';
-                nuser++;
+                ++nuser;
             } else {
                 *nuser8 = '\0';
                 nuser = nuser8 + 3;
@@ -400,7 +400,7 @@ main(int argc, char *const argv[])
         } else if (domain) {
             strup(domain);
             *domain = '\0';
-            domain++;
+            ++domain;
         }
         if (!domain && margs.ddomain) {
             domain = xstrdup(margs.ddomain);
@@ -435,7 +435,7 @@ strup(char *s)
 {
     while (*s) {
         *s = toupper((unsigned char) *s);
-        s++;
+        ++s;
     }
 }
 
@@ -57,23 +57,23 @@ utf8dup(struct main_args *margs)
         return NULL;
     for (n = 0; n < strlen(src); n++)
         if ((unsigned char) src[n] > 127)
-            c++;
+            ++c;
     if (c != 0) {
         p = (unsigned char *) xmalloc(strlen(src) + c);
         dupp = p;
         for (n = 0; n < strlen(src); n++) {
             s = (unsigned char) src[n];
             if (s > 127 && s < 192) {
                 *p = 194;
-                p++;
+                ++p;
                 *p = s;
             } else if (s > 191 && s < 256) {
                 *p = 195;
-                p++;
+                ++p;
                 *p = s - 64;
             } else
                 *p = s;
-            p++;
+            ++p;
         }
         *p = '\0';
         debug((char *) "%s| %s: INFO: Group %s as UTF-8: %s\n", LogTime(), PROGRAM, src, dupp);
@@ -134,8 +134,8 @@ hex_utf_char(struct main_args *margs, int flag)
             break;
         if (up[n] == '@') {
             ul[nl] = '@';
-            nl++;
-            n++;
+            ++nl;
+            ++n;
             continue;
         }
         ival = up[n];
@@ -159,7 +159,7 @@ hex_utf_char(struct main_args *margs, int flag)
                 xfree(ul);
             return NULL;
         }
-        n++;
+        ++n;
         ival = up[n];
         if (ival > 64 && ival < 71)
             ichar = ichar + ival - 55;
@@ -184,7 +184,7 @@ hex_utf_char(struct main_args *margs, int flag)
             } else if (iUTF2 > 0xC3 && iUTF2 < 0xE0 && ichar > 0x7F && ichar < 0xC0) {
                 iUTF2 = 0;
                 ul[nl] = ichar;
-                nl++;
+                ++nl;
             } else {
                 iUTF2 = 0;
                 ul[nl] = ichar;
@@ -198,23 +198,23 @@ hex_utf_char(struct main_args *margs, int flag)
             if (iUTF3 == 0xE0 && ichar > 0x9F && ichar < 0xC0) {
                 iUTF3 = 1;
                 ul[nl] = ichar;
-                nl++;
+                ++nl;
             } else if (iUTF3 > 0xE0 && iUTF3 < 0xED && ichar > 0x7F && ichar < 0xC0) {
                 iUTF3 = 2;
                 ul[nl] = ichar;
-                nl++;
+                ++nl;
             } else if (iUTF3 == 0xED && ichar > 0x7F && ichar < 0xA0) {
                 iUTF3 = 3;
                 ul[nl] = ichar;
-                nl++;
+                ++nl;
             } else if (iUTF3 > 0xED && iUTF3 < 0xF0 && ichar > 0x7F && ichar < 0xC0) {
                 iUTF3 = 4;
                 ul[nl] = ichar;
-                nl++;
+                ++nl;
             } else if (iUTF3 > 0 && iUTF3 < 5 && ichar > 0x7F && ichar < 0xC0) {
                 iUTF3 = 0;
                 ul[nl] = ichar;
-                nl++;
+                ++nl;
             } else {
                 iUTF3 = 0;
                 ul[nl] = ichar;
@@ -228,22 +228,22 @@ hex_utf_char(struct main_args *margs, int flag)
             if (iUTF4 == 0xF0 && ichar > 0x8F && ichar < 0xC0) {
                 iUTF4 = 1;
                 ul[nl] = ichar;
-                nl++;
+                ++nl;
             } else if (iUTF4 > 0xF0 && iUTF3 < 0xF4 && ichar > 0x7F && ichar < 0xC0) {
                 iUTF4 = 2;
                 ul[nl] = ichar;
-                nl++;
+                ++nl;
             } else if (iUTF4 == 0xF4 && ichar > 0x7F && ichar < 0x90) {
                 iUTF4 = 3;
                 ul[nl] = ichar;
-                nl++;
+                ++nl;
             } else if (iUTF4 > 0 && iUTF4 < 5 && ichar > 0x7F && ichar < 0xC0) {
                 if (iUTF4 == 4)
                     iUTF4 = 0;
                 else
                     iUTF4 = 4;
                 ul[nl] = ichar;
-                nl++;
+                ++nl;
             } else {
                 iUTF4 = 0;
                 ul[nl] = ichar;
@@ -256,22 +256,22 @@ hex_utf_char(struct main_args *margs, int flag)
         } else if (ichar < 0x80) {
             /* UTF1 */
             ul[nl] = ichar;
-            nl++;
+            ++nl;
         } else if (ichar > 0xC1 && ichar < 0xE0) {
             /* UTF2 (Latin) */
             iUTF2 = ichar;
             ul[nl] = ichar;
-            nl++;
+            ++nl;
         } else if (ichar > 0xDF && ichar < 0xF0) {
             /* UTF3 */
             iUTF3 = ichar;
             ul[nl] = ichar;
-            nl++;
+            ++nl;
         } else if (ichar > 0xEF && ichar < 0xF5) {
             /* UTF4 */
             iUTF4 = ichar;
             ul[nl] = ichar;
-            nl++;
+            ++nl;
         } else {
             ul[nl] = ichar;
             ul[nl + 1] = '\0';
@@ -280,7 +280,7 @@ hex_utf_char(struct main_args *margs, int flag)
                 xfree(ul);
             return NULL;
         }
-        n++;
+        ++n;
     }
 
     ul[nl] = '\0';
@@ -373,7 +373,7 @@ create_gd(struct main_args *margs)
     }
     while (*p) {		/* loop over group list */
         if (*p == '\n' || *p == '\r') {		/* Ignore CR and LF if exist */
-            p++;
+            ++p;
             continue;
         }
         if (*p == '@') {	/* end of group name - start of domain name */
@@ -382,7 +382,7 @@ create_gd(struct main_args *margs)
                 return (1);
             }
             *p = '\0';
-            p++;
+            ++p;
             gdsp = init_gd();
             gdsp->group = gp;
             if (gdspn)		/* Have already an existing structure */
@@ -394,7 +394,7 @@ create_gd(struct main_args *margs)
                 return (1);
             }
             *p = '\0';
-            p++;
+            ++p;
             if (dp) {		/* end of domain name */
                 gdsp->domain = xstrdup(dp);
                 dp = NULL;
@@ -408,7 +408,7 @@ create_gd(struct main_args *margs)
             gp = p;		/* after : starts new group name */
             debug((char *) "%s| %s: INFO: Group %s  Domain %s\n", LogTime(), PROGRAM, gdsp->group, gdsp->domain ? gdsp->domain : "NULL");
         } else
-            p++;
+            ++p;
     }
     if (p == gp) {		/* empty group name not allowed */
         debug((char *) "%s| %s: ERROR: No group defined for domain %s\n", LogTime(), PROGRAM, p);
@@ -92,7 +92,7 @@ krb5_create_cache(struct main_args *margs, char *domain)
     krb5_kt_default_name(kparam.context, buf, KT_PATH_MAX);
     p = strchr(buf, ':');	/* Find the end if "FILE:" */
     if (p)
-        p++;			/* step past : */
+        ++p;			/* step past : */
     keytab_name = xstrdup(p ? p : buf);
     debug((char *) "%s| %s: DEBUG: Got default keytab file name %s\n", LogTime(), PROGRAM, keytab_name);
 
@@ -229,7 +229,7 @@ convert_domain_to_bind_path(char *domain)
 
     for (dp = domain; *dp; dp++) {
         if (*dp == '.')
-            i++;
+            ++i;
     }
     /*
      * add dc= and
@@ -282,7 +282,7 @@ escape_filter(char *filter)
             ldf = ldf + 3;
         } else {
             *ldf = *filter;
-            ldf++;
+            ++ldf;
         }
     }
     *ldf = '\0';
@@ -933,7 +933,7 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
         port = 389;
         if ((p = strchr(host, ':'))) {
             *p = '\0';
-            p++;
+            ++p;
             port = atoi(p);
         }
         nhosts = get_hostname_list(margs, &hlist, 0, host);
@@ -67,7 +67,7 @@ create_ls(struct main_args *margs)
     }
     while (*p) {		/* loop over group list */
         if (*p == '\n' || *p == '\r') {		/* Ignore CR and LF if exist */
-            p++;
+            ++p;
             continue;
         }
         if (*p == '@') {	/* end of group name - start of domain name */
@@ -76,7 +76,7 @@ create_ls(struct main_args *margs)
                 return (1);
             }
             *p = '\0';
-            p++;
+            ++p;
             lssp = init_ls();
             lssp->lserver = xstrdup(np);
             if (lsspn)		/* Have already an existing structure */
@@ -88,7 +88,7 @@ create_ls(struct main_args *margs)
                 return (1);
             }
             *p = '\0';
-            p++;
+            ++p;
             if (dp) {		/* end of domain name */
                 lssp->domain = xstrdup(dp);
                 dp = NULL;
@@ -102,7 +102,7 @@ create_ls(struct main_args *margs)
             np = p;		/* after : starts new group name */
             debug((char *) "%s| %s: DEBUG: ldap server %s Domain %s\n", LogTime(), PROGRAM, lssp->lserver, lssp->domain?lssp->domain:"NULL");
         } else
-            p++;
+            ++p;
     }
     if (p == np) {		/* empty group name not allowed */
         debug((char *) "%s| %s: DEBUG: No ldap servers defined for domain %s\n", LogTime(), PROGRAM, p);
@@ -62,7 +62,7 @@ check_memberof(struct main_args *margs, char *user, char *domain)
                     debug((char *) "%s| %s: INFO: User %s is member of group@domain %s@%s\n", LogTime(), PROGRAM, user, gr->group, gr->domain);
                 else
                     log((char *) "%s| %s: INFO: User %s is member of group@domain %s@%s\n", LogTime(), PROGRAM, user, gr->group, gr->domain);
-                found++;
+                ++found;
                 break;
             } else {
                 if (debug_enabled)
@@ -90,7 +90,7 @@ check_memberof(struct main_args *margs, char *user, char *domain)
                     debug((char *) "%s| %s: INFO: User %s is member of group@domain %s@%s\n", LogTime(), PROGRAM, user, gr->group, gr->domain);
                 else
                     log((char *) "%s| %s: INFO: User %s is member of group@domain %s@%s\n", LogTime(), PROGRAM, user, gr->group, gr->domain);
-                found++;
+                ++found;
                 break;
             } else {
                 if (debug_enabled)
@@ -118,7 +118,7 @@ check_memberof(struct main_args *margs, char *user, char *domain)
                     debug((char *) "%s| %s: INFO: User %s is member of group@domain %s@%s\n", LogTime(), PROGRAM, user, gr->group, gr->domain ? gr->domain : "NULL");
                 else
                     log((char *) "%s| %s: INFO: User %s is member of group@domain %s@%s\n", LogTime(), PROGRAM, user, gr->group, gr->domain ? gr->domain : "NULL");
-                found++;
+                ++found;
                 break;
             } else {
                 if (debug_enabled)
@@ -68,7 +68,7 @@ create_nd(struct main_args *margs)
     }
     while (*p) {		/* loop over group list */
         if (*p == '\n' || *p == '\r') {		/* Ignore CR and LF if exist */
-            p++;
+            ++p;
             continue;
         }
         if (*p == '@') {	/* end of group name - start of domain name */
@@ -77,7 +77,7 @@ create_nd(struct main_args *margs)
                 return (1);
             }
             *p = '\0';
-            p++;
+            ++p;
             ndsp = init_nd();
             ndsp->netbios = xstrdup(np);
             if (ndspn)		/* Have already an existing structure */
@@ -89,7 +89,7 @@ create_nd(struct main_args *margs)
                 return (1);
             }
             *p = '\0';
-            p++;
+            ++p;
             if (dp) {		/* end of domain name */
                 ndsp->domain = xstrdup(dp);
                 dp = NULL;
@@ -107,7 +107,7 @@ create_nd(struct main_args *margs)
             }
             debug((char *) "%s| %s: DEBUG: Netbios name %s  Domain %s\n", LogTime(), PROGRAM, ndsp->netbios, ndsp->domain);
         } else
-            p++;
+            ++p;
     }
     if (p == np) {		/* empty group name not allowed */
         debug((char *) "%s| %s: DEBUG: No netbios name defined for domain %s\n", LogTime(), PROGRAM, p);
@@ -189,7 +189,7 @@ get_hostname_list(struct main_args *margs, struct hstruct **hlist, int nhosts, c
     hres_list = hres;
     count = 0;
     while (hres_list) {
-        count++;
+        ++count;
         hres_list = hres_list->ai_next;
     }
     hres_list = hres;
@@ -202,15 +202,15 @@ get_hostname_list(struct main_args *margs, struct hstruct **hlist, int nhosts, c
             *hlist = hp;
             return (nhosts);
         }
-        count++;
+        ++count;
         debug((char *) "%s| %s: DEBUG: Resolved address %d of %s to %s\n", LogTime(), PROGRAM, count, name, host);
 
         hp = (struct hstruct *) xrealloc(hp, sizeof(struct hstruct) * (nhosts + 1));
         hp[nhosts].host = xstrdup(host);
         hp[nhosts].port = -1;
         hp[nhosts].priority = -1;
         hp[nhosts].weight = -1;
-        nhosts++;
+        ++nhosts;
 
         hres_list = hres_list->ai_next;
     }
@@ -251,15 +251,15 @@ get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, int nh,
             hp[nhosts].port = -1;
             hp[nhosts].priority = -2;
             hp[nhosts].weight = -2;
-            nhosts++;
+            ++nhosts;
         } else if ( !ls->domain || !strcasecmp(ls->domain, "") ) {
             debug((char *) "%s| %s: DEBUG: Found lserver@domain %s@%s\n", LogTime(), PROGRAM, ls->lserver, ls->domain?ls->domain:"NULL");
             hp = (struct hstruct *) xrealloc(hp, sizeof(struct hstruct) * (nhosts + 1));
             hp[nhosts].host = strdup(ls->lserver);
             hp[nhosts].port = -1;
             hp[nhosts].priority = -2;
             hp[nhosts].weight = -2;
-            nhosts++;
+            ++nhosts;
 
         }
         ls = ls->next;
@@ -381,7 +381,7 @@ get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, int nh,
             hp[nh].port = port;
             hp[nh].priority = priority;
             hp[nh].weight = weight;
-            nh++;
+            ++nh;
             p += size;
         } else {
             p += rdlength;
@@ -410,24 +410,24 @@ get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, int nh,
     hp[nhosts].port = -1;
     hp[nhosts].priority = -2;
     hp[nhosts].weight = -2;
-    nhosts++;
+    ++nhosts;
 
     /* Remove duplicates */
-    for (i = 0; i < nhosts; i++) {
-        for (j = i + 1; j < nhosts; j++) {
+    for (i = 0; i < nhosts; ++i) {
+        for (j = i + 1; j < nhosts; ++j) {
             if (!strcasecmp(hp[i].host, hp[j].host)) {
                 if (hp[i].port == hp[j].port ||
                         (hp[i].port == -1 && hp[j].port == 389) ||
                         (hp[i].port == 389 && hp[j].port == -1)) {
                     xfree(hp[j].host);
-                    for (k = j + 1; k < nhosts; k++) {
+                    for (k = j + 1; k < nhosts; ++k) {
                         hp[k - 1].host = hp[k].host;
                         hp[k - 1].port = hp[k].port;
                         hp[k - 1].priority = hp[k].priority;
                         hp[k - 1].weight = hp[k].weight;
                     }
-                    j--;
-                    nhosts--;
+                    --j;
+                    --nhosts;
                     hp = (struct hstruct *) xrealloc(hp, sizeof(struct hstruct) * (nhosts + 1));
                 }
             }
@@ -439,7 +439,7 @@ get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, int nh,
 
     if (debug_enabled) {
         debug((char *) "%s| %s: DEBUG: Sorted ldap server names for domain %s:\n", LogTime(), PROGRAM, domain);
-        for (i = 0; i < nhosts; i++) {
+        for (i = 0; i < nhosts; ++i) {
             debug((char *) "%s| %s: DEBUG: Host: %s Port: %d Priority: %d Weight: %d\n", LogTime(), PROGRAM, hp[i].host, hp[i].port, hp[i].priority, hp[i].weight);
         }
     }
@@ -187,7 +187,7 @@ lutil_sasl_interact(
 
         if (rc)
             return rc;
-        interact++;
+        ++interact;
     }
 
     return LDAP_SUCCESS;
@@ -53,7 +53,7 @@ rotate(const char *path, int rotate_count)
 #endif
     /* Rotate numbers 0 through N up one */
     for (i = rotate_count; i > 1;) {
-        i--;
+        --i;
         snprintf(from, MAXPATHLEN, "%s.%d", path, i - 1);
         snprintf(to, MAXPATHLEN, "%s.%d", path, i);
 #if _SQUID_OS2_ || _SQUID_WINDOWS_
@@ -135,7 +135,7 @@ gethost_name(void)
     hres_list = hres;
     count = 0;
     while (hres_list) {
-        count++;
+        ++count;
         hres_list = hres_list->ai_next;
     }
     rc = getnameinfo(hres->ai_addr, hres->ai_addrlen, hostname,
@@ -227,7 +227,7 @@ main(int argc, char *argv[])
         while (count > 0) {
             Token = (const char *) squid_kerb_proxy_auth(argv[1]);
             fprintf(stdout, "YR %s\n", Token ? Token : "NULL");
-            count--;
+            --count;
         }
         fprintf(stdout, "QQ\n");
     } else {
@@ -137,7 +137,7 @@ main(int argc, char *const argv[])
         j = 2;
     }
 
-    for (i=j; i<argc; i++) {
+    for (i=j; i<argc; ++i) {
         if (!strncasecmp(argv[i],"--ntlm",6))
             nstart = i;
         if (!strncasecmp(argv[i],"--kerberos",10))
@@ -167,7 +167,7 @@ main(int argc, char *const argv[])
     nargs[nend-nstart]=NULL;
     if (debug) {
         fprintf(stderr, "%s| %s: NTLM command: ", LogTime(), PROGRAM);
-        for (i=0; i<nend-nstart; i++)
+        for (i=0; i<nend-nstart; ++i)
             fprintf(stderr, "%s ", nargs[i]);
         fprintf(stderr, "\n");
     }
@@ -179,7 +179,7 @@ main(int argc, char *const argv[])
     kargs[kend-kstart]=NULL;
     if (debug) {
         fprintf(stderr, "%s| %s: Kerberos command: ", LogTime(), PROGRAM);
-        for (i=0; i<kend-kstart; i++)
+        for (i=0; i<kend-kstart; ++i)
             fprintf(stderr, "%s ", kargs[i]);
         fprintf(stderr, "\n");
     }
@@ -381,7 +381,7 @@ main(int argc, char *const argv[])
             if (strlen(tbuff) >= 3 && (!strncmp(tbuff,"AF ",3) || !strncmp(tbuff,"NA ",3))) {
                 strncpy(buff,tbuff,3);
                 buff[3]='=';
-                for (unsigned int i=2; i<=strlen(tbuff); i++)
+                for (unsigned int i=2; i<=strlen(tbuff); ++i)
                     buff[i+2] = tbuff[i];
             } else {
                 strcpy(buff,tbuff);
@@ -140,7 +140,7 @@ Valid_Group(char *UserName, char *Group)
      */
     if (nStatus == NERR_Success) {
         if ((pTmpBuf = pBuf) != NULL) {
-            for (i = 0; i < dwEntriesRead; i++) {
+            for (i = 0; i < dwEntriesRead; ++i) {
                 if (pTmpBuf == NULL) {
                     result = FALSE;
                     break;
@@ -149,8 +149,8 @@ Valid_Group(char *UserName, char *Group)
                     result = TRUE;
                     break;
                 }
-                pTmpBuf++;
-                dwTotalCount++;
+                ++pTmpBuf;
+                ++dwTotalCount;
             }
         }
     } else
@@ -411,7 +411,7 @@ process_options(int argc, char *argv[])
         exit(1);
     /* Okay, now begin filling controllers up */
     /* we can avoid memcpy-ing, and just reuse argv[] */
-    for (j = optind; j < argc; j++) {
+    for (j = optind; j < argc; ++j) {
         char *d, *c;
         /* d will not be freed in case of non-error. Since we don't reconfigure,
          * it's going to live as long as the process anyways */
@@ -439,7 +439,7 @@ process_options(int argc, char *argv[])
         /* capitalize */
         uc(c);
         uc(d);
-        numcontrollers++;
+        ++numcontrollers;
         new_dc->domain = d;
         new_dc->controller = c;
         new_dc->dead = 0;
@@ -468,7 +468,7 @@ obtain_challenge()
 {
     int j = 0;
     const char *ch = NULL;
-    for (j = 0; j < numcontrollers; j++) {
+    for (j = 0; j < numcontrollers; ++j) {
         debug("obtain_challenge: selecting %s\\%s (attempt #%d)\n",
               current_dc->domain, current_dc->controller, j + 1);
         if (current_dc->dead != 0) {
@@ -698,7 +698,7 @@ main(int argc, char *argv[])
         debug("load balancing. Selected controller #%d\n", n);
         while (n > 0) {
             current_dc = current_dc->next;
-            n--;
+            --n;
         }
     }
     while (1) {
@@ -302,7 +302,7 @@ memPoolGetGlobalStats(MemPoolGlobalStats * stats)
     iter = memPoolIterate();
     while ((pool = memPoolIterateNext(iter))) {
         if (pool->getStats(&pp_stats, 1) > 0)
-            pools_inuse++;
+            ++pools_inuse;
     }
     memPoolIterateDone(&iter);
 
@@ -147,7 +147,7 @@ MemChunk::MemChunk(MemPoolChunked *aPool)
     freeList = objCache;
     void **Free = (void **)freeList;
 
-    for (int i = 1; i < pool->chunk_capacity; i++) {
+    for (int i = 1; i < pool->chunk_capacity; ++i) {
         *Free = (void *) ((char *) Free + pool->obj_size);
         void **nextFree = (void **)*Free;
         (void) VALGRIND_MAKE_MEM_NOACCESS(Free, pool->obj_size);
@@ -158,7 +158,7 @@ MemChunk::MemChunk(MemPoolChunked *aPool)
 
     memMeterAdd(pool->getMeter().alloc, pool->chunk_capacity);
     memMeterAdd(pool->getMeter().idle, pool->chunk_capacity);
-    pool->chunkCount++;
+    ++pool->chunkCount;
     lastref = squid_curtime;
     pool->allChunks.insert(this, memCompChunks);
 }
@@ -217,7 +217,7 @@ MemPoolChunked::get()
 {
     void **Free;
 
-    saved_calls++;
+    ++saved_calls;
 
     /* first, try cache */
     if (freeCache) {
@@ -239,7 +239,7 @@ MemPoolChunked::get()
     Free = (void **)chunk->freeList;
     chunk->freeList = *Free;
     *Free = NULL;
-    chunk->inuse_count++;
+    ++chunk->inuse_count;
     chunk->lastref = squid_curtime;
 
     if (chunk->freeList == NULL) {
@@ -480,9 +480,9 @@ MemPoolChunked::getStats(MemPoolStats * stats, int accumulate)
     chunk = Chunks;
     while (chunk) {
         if (chunk->inuse_count == 0)
-            chunks_free++;
+            ++chunks_free;
         else if (chunk->inuse_count < chunk_capacity)
-            chunks_partial++;
+            ++chunks_partial;
         chunk = chunk->next;
     }
 
@@ -57,7 +57,7 @@ MemPoolMalloc::allocate()
     void *obj = freelist.pop();
     if (obj) {
         memMeterDec(meter.idle);
-        saved_calls++;
+        ++saved_calls;
     } else {
         obj = xcalloc(1, obj_size);
         memMeterInc(meter.alloc);
@@ -71,7 +71,7 @@ hash_string(const void *data, unsigned int size)
     unsigned int j = 0;
     unsigned int i = 0;
     while (*s) {
-        j++;
+        ++j;
         n ^= 271 * (*s++);
     }
     i = n ^ (j * 271);
@@ -169,7 +169,7 @@ hash_join(hash_table * hid, hash_link * lnk)
     i = hid->hash(lnk->key, hid->size);
     lnk->next = hid->buckets[i];
     hid->buckets[i] = lnk;
-    hid->count++;
+    ++hid->count;
 }
 
 /**
@@ -268,7 +268,7 @@ hash_remove_link(hash_table * hid, hash_link * hl)
             if (NULL == hid->next)
                 hash_next_bucket(hid);
         }
-        hid->count--;
+        --hid->count;
         return;
     }
     assert(0);
@@ -295,9 +295,9 @@ hashFreeItems(hash_table * hid, HASHFREE * free_func)
     hash_first(hid);
     while ((l = hash_next(hid)) && i < hid->count) {
         *(list + i) = l;
-        i++;
+        ++i;
     }
-    for (int j = 0; j < i; j++)
+    for (int j = 0; j < i; ++j)
         free_func(*(list + j));
     xfree(list);
 }
@@ -334,7 +334,7 @@ hashPrime(int n)
     int best_prime = hash_primes[0];
     double min = fabs(log((double) n) - log((double) hash_primes[0]));
     double d;
-    for (int i = 0; i < I; i++) {
+    for (int i = 0; i < I; ++i) {
         d = fabs(log((double) n) - log((double) hash_primes[i]));
         if (d > min)
             continue;
@@ -124,8 +124,8 @@ check_init(void)
     /* calloc the ptrs so that we don't see them when hunting lost memory */
     malloc_ptrs = calloc(DBG_ARRY_BKTS, sizeof(*malloc_ptrs));
 
-    for (B = 0; B < DBG_ARRY_BKTS; B++) {
-        for (I = 0; I < DBG_ARRY_SZ; I++) {
+    for (B = 0; B < DBG_ARRY_BKTS; ++B) {
+        for (I = 0; I < DBG_ARRY_SZ; ++I) {
             malloc_ptrs[B][I] = NULL;
             malloc_size[B][I] = 0;
 #if XMALLOC_TRACE
@@ -147,7 +147,7 @@ check_free(void *s)
     int B, I;
     B = DBG_HASH_BUCKET(s);
 
-    for (I = 0; I < DBG_ARRY_SZ; I++) {
+    for (I = 0; I < DBG_ARRY_SZ; ++I) {
         if (malloc_ptrs[B][I] != s)
             continue;
 
@@ -189,7 +189,7 @@ check_malloc(void *p, size_t sz)
 
     B = DBG_HASH_BUCKET(p);
 
-    for (I = 0; I < DBG_ARRY_SZ; I++) {
+    for (I = 0; I < DBG_ARRY_SZ; ++I) {
         if (!(P = malloc_ptrs[B][I]))
             continue;
 
@@ -206,7 +206,7 @@ check_malloc(void *p, size_t sz)
         }
     }
 
-    for (I = 0; I < DBG_ARRY_SZ; I++) {
+    for (I = 0; I < DBG_ARRY_SZ; ++I) {
         if (malloc_ptrs[B][I])
             continue;
 
@@ -244,7 +244,7 @@ xmallocblksize(void *p)
     int B, I;
     B = DBG_HASH_BUCKET(p);
 
-    for (I = 0; I < DBG_ARRY_SZ; I++) {
+    for (I = 0; I < DBG_ARRY_SZ; ++I) {
         if (malloc_ptrs[B][I] == p)
             return malloc_size[B][I];
     }
@@ -261,7 +261,7 @@ malloc_file_name(void *p)
     int B, I;
     B = DBG_HASH_BUCKET(p);
 
-    for (I = 0; I < DBG_ARRY_SZ; I++) {
+    for (I = 0; I < DBG_ARRY_SZ; ++I) {
         if (malloc_ptrs[B][I] == p)
             return malloc_file[B][I];
     }
@@ -275,7 +275,7 @@ malloc_line_number(void *p)
     int B, I;
     B = DBG_HASH_BUCKET(p);
 
-    for (I = 0; I < DBG_ARRY_SZ; I++) {
+    for (I = 0; I < DBG_ARRY_SZ; ++I) {
         if (malloc_ptrs[B][I] == p)
             return malloc_line[B][I];
     }
@@ -289,7 +289,7 @@ malloc_number(void *p)
     int B, I;
     B = DBG_HASH_BUCKET(p);
 
-    for (I = 0; I < DBG_ARRY_SZ; I++) {
+    for (I = 0; I < DBG_ARRY_SZ; ++I) {
         if (malloc_ptrs[B][I] == p)
             return malloc_count[B][I];
     }
@@ -350,7 +350,7 @@ xmalloc_scan_region(void *start, int size, int depth)
         if (p && p != start) {
             B = DBG_HASH_BUCKET(p);
 
-            for (I = 0; I < DBG_ARRY_SZ; I++) {
+            for (I = 0; I < DBG_ARRY_SZ; ++I) {
                 if (malloc_ptrs[B][I] == p) {
                     if (!malloc_refs[B][I]++) {
                         /* A new reference */
@@ -399,8 +399,8 @@ xmalloc_find_leaks(void)
     fprintf(stderr, "----- Memory map ----\n");
     xmalloc_scan_region(&_etext, (void *) sbrk(0) - (void *) &_etext, 0);
 
-    for (B = 0; B < DBG_ARRY_BKTS; B++) {
-        for (I = 0; I < DBG_ARRY_SZ; I++) {
+    for (B = 0; B < DBG_ARRY_BKTS; ++B) {
+        for (I = 0; I < DBG_ARRY_SZ; ++I) {
             if (malloc_ptrs[B][I] && malloc_refs[B][I] == 0) {
                 /* Found a leak... */
                 fprintf(stderr, "Leak found: %p", malloc_ptrs[B][I]);
@@ -137,25 +137,25 @@ ntlm_fetch_string(const ntlmhdr *packet, const int32_t packet_size, const strhdr
         unsigned short *s = (unsigned short *)rv.str;
         rv.str = d = buf;
 
-        for (l >>= 1; l; s++, l--) {
+        for (l >>= 1; l; ++s, --l) {
             unsigned short c = le16toh(*s);
             if (c > 254 || c == '\0') {
                 fprintf(stderr, "ntlmssp: bad unicode: %04x\n", c);
                 return rv;
             }
             *d++ = c;
-            rv.l++;
+            ++rv.l;
         }
     } else {
         /* ASCII/OEM string */
         char *sc = rv.str;
 
-        for (; l>=0; sc++, l--) {
+        for (; l>=0; ++sc, --l) {
             if (*sc == '\0' || !xisprint(*sc)) {
                 fprintf(stderr, "ntlmssp: bad ascii: %04x\n", *sc);
                 return rv;
             }
-            rv.l++;
+            ++rv.l;
         }
     }
 
@@ -209,7 +209,7 @@ ntlm_make_nonce(char *nonce)
     int r = (int) rand();
     r = (hash ^ r) + r;
 
-    for (i = 0; i < NTLM_NONCE_LEN; i++) {
+    for (i = 0; i < NTLM_NONCE_LEN; ++i) {
         nonce[i] = r;
         r = (r >> 2) ^ r;
     }
@@ -161,7 +161,7 @@ xprof_update(xprof_stats_data * head)
     if (head->worst < head->delta)
         head->worst = head->delta;
     head->summ += head->delta;
-    head->count++;
+    ++head->count;
 }
 
 static xprof_stats_data *xp_UNACCOUNTED;
@@ -209,7 +209,7 @@ xprof_start(xprof_type type, const char *timer)
     cstack[cstack_head].accum = 0;
     cstack[cstack_head].timer = type;
     cstack[cstack_head].name = timer;
-    cstack_head++;
+    ++cstack_head;
     assert(cstack_head < MAXSTACKDEPTH);
 
 }
@@ -219,7 +219,7 @@ xprof_stop(xprof_type type, const char *timer)
 {
     hrtime_t tt = get_tick();
     assert(cstack_head > 0);
-    cstack_head--;
+    --cstack_head;
     assert(cstack[cstack_head].timer == type);
 
     /* Record timer details */
@@ -51,6 +51,10 @@
 		'HttpStateData (\S+) created',
 		'cbdataFree: Freeing (\S+)',
 	],
+	FD => [
+		'fd_open.*\sFD (\d+)',
+		'fd_close\s+FD (\d+)',
+	],
 );
 
 if (!$Pairs{$Thing}) {
@@ -106,6 +106,8 @@ sub getJob {
 
 		start => undef(),
 		history => '',
+
+		reported => 0,
 	};
 
 	$Jobs{$id} = $job;
@@ -118,6 +120,10 @@ sub reportJob {
 
 	my $job = $Jobs{$id} or die("Did not see job$id\n");
 
+	# several kids may try to report their common parent
+	return if $job->{reported};
+	$job->{reported} = 1;
+
 	&reportJob($job->{parent}, 0) if $job->{parent};
 
 	&reportJobParam($id, 'parent');
@@ -4,7 +4,7 @@
 #include "ssl/support.h"
 
 #if USE_SSL
-AccessLogEntry::Ssl::Ssl(): user(NULL), bumpMode(::Ssl::bumpEnd)
+AccessLogEntry::SslDetails::SslDetails(): user(NULL), bumpMode(::Ssl::bumpEnd)
 {
 }
 #endif /* USE_SSL */
@@ -25,3 +25,26 @@ AccessLogEntry::getLogClientIp(char *buf, size_t bufsz) const
         else
             cache.caddr.NtoA(buf, bufsz);
 }
+
+AccessLogEntry::~AccessLogEntry()
+{
+    safe_free(headers.request);
+
+#if ICAP_CLIENT
+    safe_free(adapt.last_meta);
+#endif
+
+    safe_free(headers.reply);
+    safe_free(cache.authuser);
+
+    safe_free(headers.adapted_request);
+    HTTPMSGUNLOCK(adapted_request);
+
+    HTTPMSGUNLOCK(reply);
+    HTTPMSGUNLOCK(request);
+#if ICAP_CLIENT
+    HTTPMSGUNLOCK(icap.reply);
+    HTTPMSGUNLOCK(icap.request);
+#endif
+    cbdataReferenceDone(cache.port);
+}
@@ -40,17 +40,24 @@
 #if ICAP_CLIENT
 #include "adaptation/icap/Elements.h"
 #endif
+#include "RefCount.h"
+#if USE_SSL
+#include "ssl/gadgets.h"
+#endif
 
 /* forward decls */
 class HttpReply;
 class HttpRequest;
 
-class AccessLogEntry
+class AccessLogEntry: public RefCountable
 {
 
 public:
+    typedef RefCount<AccessLogEntry> Pointer;
+
     AccessLogEntry() : url(NULL), tcpClient(), reply(NULL), request(NULL),
             adapted_request(NULL) {}
+    ~AccessLogEntry();
 
     /// Fetch the client IP log string into the given buffer.
     /// Knows about several alternate locations of the IP
@@ -113,9 +120,9 @@ class AccessLogEntry
 
 #if USE_SSL
     /// logging information specific to the SSL protocol
-    class Ssl {
+    class SslDetails {
     public:
-        Ssl();
+        SslDetails();
 
         const char *user; ///< emailAddress from the SSL client certificate
         int bumpMode; ///< whether and how the request was SslBumped
@@ -142,11 +149,12 @@ class AccessLogEntry
                 msec(0),
                 rfc931 (NULL),
                 authuser (NULL),
-                extuser(NULL)
+                extuser(NULL),
 #if USE_SSL
-                ,ssluser(NULL)
+                ssluser(NULL),
 #endif
-        {;
+                port(NULL) {
+            ;
         }
 
         Ip::Address caddr;
@@ -164,6 +172,7 @@ class AccessLogEntry
 #if USE_SSL
 
         const char *ssluser;
+        Ssl::X509_Pointer sslClientCert; ///< cert received from the client
 #endif
         AnyP::PortCfg *port;
 
@@ -265,12 +274,11 @@ class ACLChecklist;
 class StoreEntry;
 
 /* Should be in 'AccessLog.h' as the driver */
-extern void accessLogLogTo(customlog* log, AccessLogEntry* al, ACLChecklist* checklist = NULL);
-extern void accessLogLog(AccessLogEntry *, ACLChecklist * checklist);
+extern void accessLogLogTo(customlog* log, AccessLogEntry::Pointer &al, ACLChecklist* checklist = NULL);
+extern void accessLogLog(AccessLogEntry::Pointer &, ACLChecklist * checklist);
 extern void accessLogRotate(void);
 extern void accessLogClose(void);
 extern void accessLogInit(void);
-extern void accessLogFreeMemory(AccessLogEntry * aLogEntry);
 extern const char *accessLogTime(time_t);
 
 #endif /* SQUID_HTTPACCESSLOGENTRY_H */
@@ -447,9 +447,9 @@ const char *BodyPipe::status() const
 
     outputBuffer.append(" [", 2);
 
-    outputBuffer.Printf("%"PRIu64"<=%"PRIu64, theGetSize, thePutSize);
+    outputBuffer.Printf("%" PRIu64 "<=%" PRIu64, theGetSize, thePutSize);
     if (theBodySize >= 0)
-        outputBuffer.Printf("<=%"PRId64, theBodySize);
+        outputBuffer.Printf("<=%" PRId64, theBodySize);
     else
         outputBuffer.append("<=?", 3);
 
@@ -12,7 +12,7 @@ void ClientDelayPool::dump(StoreEntry * entry, unsigned int poolNumberMinusOne)
     LOCAL_ARRAY(char, nom, 32);
     snprintf(nom, 32, "client_delay_access %d", poolNumberMinusOne + 1);
     dump_acl_access(entry, nom, access);
-    storeAppendPrintf(entry, "client_delay_parameters %d %d %"PRId64"\n", poolNumberMinusOne + 1, rate,highwatermark);
+    storeAppendPrintf(entry, "client_delay_parameters %d %d %" PRId64 "\n", poolNumberMinusOne + 1, rate,highwatermark);
     storeAppendPrintf(entry, "\n");
 }
 
@@ -116,15 +116,15 @@ ConfigParser::strtokFile(void)
 }
 
 void
-ConfigParser::ParseQuotedString(char **var)
+ConfigParser::ParseQuotedString(char **var, bool *wasQuoted)
 {
     String sVar;
-    ParseQuotedString(&sVar);
+    ParseQuotedString(&sVar, wasQuoted);
     *var = xstrdup(sVar.termedBuf());
 }
 
 void
-ConfigParser::ParseQuotedString(String *var)
+ConfigParser::ParseQuotedString(String *var, bool *wasQuoted)
 {
     // Get all of the remaining string
     char *token = strtok(NULL, "");
@@ -134,8 +134,11 @@ ConfigParser::ParseQuotedString(String *var)
     if (*token != '"') {
         token = strtok(token, w_space);
         var->reset(token);
+        if (wasQuoted)
+            *wasQuoted = false;
         return;
-    }
+    } else if (wasQuoted)
+        *wasQuoted = true;
 
     char  *s = token + 1;
     /* scan until the end of the quoted string, unescaping " and \  */
@@ -67,8 +67,13 @@ class ConfigParser
     static void ParseBool(bool *var);
     static void ParseString(char **var);
     static void ParseString(String *var);
-    static void ParseQuotedString(char **var);
-    static void ParseQuotedString(String *var);
+    /// Parse an unquoted token (no spaces) or a "quoted string" that
+    /// may include spaces. In some contexts, quotes strings may also
+    /// include macros. Quoted strings may escape any character with
+    /// a backslash (\), which is currently only useful for inner
+    /// quotes. TODO: support quoted strings anywhere a token is accepted.
+    static void ParseQuotedString(char **var, bool *wasQuoted = NULL);
+    static void ParseQuotedString(String *var, bool *wasQuoted = NULL);
     static const char *QuoteString(String &var);
     static void ParseWordList(wordlist **list);
     static char * strtokFile();
@@ -73,6 +73,8 @@ extern void ctx_exit(Ctx ctx);
 /* levels 2-8 are still being discussed amongst the developers */
 #define DBG_DATA	9	/**< output is a large data dump only necessary for advanced debugging */
 
+#define DBG_PARSE_NOTE(x) (opt_parse_cfg_only?0:(x)) /**< output is always to be displayed on '-k parse' but at level-x normally. */
+
 class Debug
 {
 
@@ -57,14 +57,14 @@ DelaySpec::stats (StoreEntry * sentry, char const *label) const
     }
 
     storeAppendPrintf(sentry, "\t%s:\n", label);
-    storeAppendPrintf(sentry, "\t\tMax: %"PRId64"\n", max_bytes);
+    storeAppendPrintf(sentry, "\t\tMax: %" PRId64 "\n", max_bytes);
     storeAppendPrintf(sentry, "\t\tRestore: %d\n", restore_bps);
 }
 
 void
 DelaySpec::dump (StoreEntry *entry) const
 {
-    storeAppendPrintf(entry, " %d/%"PRId64"", restore_bps, max_bytes);
+    storeAppendPrintf(entry, " %d/%" PRId64 "", restore_bps, max_bytes);
 }
 
 void
@@ -156,20 +156,20 @@ do_read(diomsg * r, int len, char *buf)
 
     if (r->offset > -1 && r->offset != fs->offset) {
         DEBUG(2) {
-            fprintf(stderr, "seeking to %"PRId64"\n", (int64_t)r->offset);
+            fprintf(stderr, "seeking to %" PRId64 "\n", (int64_t)r->offset);
         }
 
         if (lseek(fs->fd, r->offset, SEEK_SET) < 0) {
             DEBUG(1) {
-                fprintf(stderr, "%d FD %d, offset %"PRId64": ", (int) mypid, fs->fd, (int64_t)r->offset);
+                fprintf(stderr, "%d FD %d, offset %" PRId64 ": ", (int) mypid, fs->fd, (int64_t)r->offset);
                 perror("lseek");
             }
         }
     }
 
     x = read(fs->fd, buf, readlen);
     DEBUG(2) {
-        fprintf(stderr, "%d READ %d,%d,%"PRId64" ret %d\n", (int) mypid,
+        fprintf(stderr, "%d READ %d,%d,%" PRId64 " ret %d\n", (int) mypid,
                 fs->fd, readlen, (int64_t)r->offset, x);
     }
 
@@ -207,14 +207,14 @@ do_write(diomsg * r, int len, const char *buf)
     if (r->offset > -1 && r->offset != fs->offset) {
         if (lseek(fs->fd, r->offset, SEEK_SET) < 0) {
             DEBUG(1) {
-                fprintf(stderr, "%d FD %d, offset %"PRId64": ", (int) mypid, fs->fd, (int64_t)r->offset);
+                fprintf(stderr, "%d FD %d, offset %" PRId64 ": ", (int) mypid, fs->fd, (int64_t)r->offset);
                 perror("lseek");
             }
         }
     }
 
     DEBUG(2) {
-        fprintf(stderr, "%d WRITE %d,%d,%"PRId64"\n", (int) mypid,
+        fprintf(stderr, "%d WRITE %d,%d,%" PRId64 "\n", (int) mypid,
                 fs->fd, wrtlen, (int64_t)r->offset);
     }
     x = write(fs->fd, buf, wrtlen);
@@ -129,7 +129,7 @@ httpHdrRangeRespSpecPackInto(const HttpHdrRangeSpec * spec, Packer * p)
     if (!known_spec(spec->offset) || !known_spec(spec->length))
         packerPrintf(p, "*");
     else
-        packerPrintf(p, "bytes %"PRId64"-%"PRId64,
+        packerPrintf(p, "bytes %" PRId64 "-%" PRId64,
                      spec->offset, spec->offset + spec->length - 1);
 }
 
@@ -233,7 +233,7 @@ httpHdrContRangePackInto(const HttpHdrContRange * range, Packer * p)
     if (!known_spec(range->elength))
         packerPrintf(p, "/*");
     else
-        packerPrintf(p, "/%"PRId64, range->elength);
+        packerPrintf(p, "/%" PRId64, range->elength);
 }
 
 void
@@ -132,11 +132,11 @@ void
 HttpHdrRangeSpec::packInto(Packer * packer) const
 {
     if (!known_spec(offset))	/* suffix */
-        packerPrintf(packer, "-%"PRId64,  length);
+        packerPrintf(packer, "-%" PRId64,  length);
     else if (!known_spec(length))		/* trailer */
-        packerPrintf(packer, "%"PRId64"-", offset);
+        packerPrintf(packer, "%" PRId64 "-", offset);
     else			/* range */
-        packerPrintf(packer, "%"PRId64"-%"PRId64,
+        packerPrintf(packer, "%" PRId64 "-%" PRId64,
                      offset, offset + length - 1);
 }
 
@@ -34,10 +34,25 @@
 
 #include "squid-old.h"
 #include "acl/FilledChecklist.h"
+#include "acl/Gadgets.h"
+#include "client_side.h"
+#include "client_side_request.h"
+#include "comm/Connection.h"
 #include "compat/strtoll.h"
+#include "fde.h"
 #include "HttpHdrContRange.h"
 #include "HttpHeader.h"
+#include "HttpHeaderTools.h"
+#include "HttpRequest.h"
 #include "MemBuf.h"
+#if USE_SSL
+#include "ssl/support.h"
+#endif
+#include "Store.h"
+#include <algorithm>
+#if HAVE_STRING
+#include <string>
+#endif
 
 static void httpHeaderPutStrvf(HttpHeader * hdr, http_hdr_type id, const char *fmt, va_list vargs);
 
@@ -414,18 +429,24 @@ httpHdrMangle(HttpHeaderEntry * e, HttpRequest * request, int req_or_rep)
     int retval;
 
     /* check with anonymizer tables */
-    header_mangler *hm;
+    HeaderManglers *hms = NULL;
     assert(e);
 
     if (ROR_REQUEST == req_or_rep) {
-        hm = &Config.request_header_access[e->id];
+        hms = Config.request_header_access;
     } else if (ROR_REPLY == req_or_rep) {
-        hm = &Config.reply_header_access[e->id];
+        hms = Config.reply_header_access;
     } else {
         /* error. But let's call it "request". */
-        hm = &Config.request_header_access[e->id];
+        hms = Config.request_header_access;
     }
 
+    /* manglers are not configured for this message kind */
+    if (!hms)
+        return 1;
+
+    const header_mangler *hm = hms->find(*e);
+
     /* mangler or checklist went away. default allow */
     if (!hm || !hm->access_list) {
         return 1;
@@ -467,17 +488,170 @@ httpHdrMangleList(HttpHeader * l, HttpRequest * request, int req_or_rep)
         l->refreshMask();
 }
 
-/**
- * return 1 if manglers are configured.  Used to set a flag
- * for optimization during request forwarding.
- */
-int
-httpReqHdrManglersConfigured()
+static
+void header_mangler_clean(header_mangler &m)
+{
+    aclDestroyAccessList(&m.access_list);
+    safe_free(m.replacement);
+}
+
+static
+void header_mangler_dump_access(StoreEntry * entry, const char *option,
+                                const header_mangler &m, const char *name)
+{
+    if (m.access_list != NULL) {
+        storeAppendPrintf(entry, "%s ", option);
+        dump_acl_access(entry, name, m.access_list);
+    }
+}
+
+static
+void header_mangler_dump_replacement(StoreEntry * entry, const char *option,
+                                     const header_mangler &m, const char *name)
+{
+    if (m.replacement)
+        storeAppendPrintf(entry, "%s %s %s\n", option, name, m.replacement);
+}
+
+HeaderManglers::HeaderManglers()
+{
+    memset(known, 0, sizeof(known));
+    memset(&all, 0, sizeof(all));
+}
+
+HeaderManglers::~HeaderManglers()
+{
+    for (int i = 0; i < HDR_ENUM_END; i++)
+        header_mangler_clean(known[i]);
+
+    typedef ManglersByName::iterator MBNI;
+    for (MBNI i = custom.begin(); i != custom.end(); ++i)
+        header_mangler_clean(i->second);
+
+    header_mangler_clean(all);
+}
+
+void
+HeaderManglers::dumpAccess(StoreEntry * entry, const char *name) const
 {
     for (int i = 0; i < HDR_ENUM_END; i++) {
-        if (NULL != Config.request_header_access[i].access_list)
-            return 1;
+        header_mangler_dump_access(entry, name, known[i],
+                                   httpHeaderNameById(i));
     }
 
-    return 0;
+    typedef ManglersByName::const_iterator MBNCI;
+    for (MBNCI i = custom.begin(); i != custom.end(); ++i)
+        header_mangler_dump_access(entry, name, i->second, i->first.c_str());
+
+    header_mangler_dump_access(entry, name, all, "All");
+}
+
+void
+HeaderManglers::dumpReplacement(StoreEntry * entry, const char *name) const
+{
+    for (int i = 0; i < HDR_ENUM_END; i++) {
+        header_mangler_dump_replacement(entry, name, known[i],
+                                        httpHeaderNameById(i));
+    }
+
+    typedef ManglersByName::const_iterator MBNCI;
+    for (MBNCI i = custom.begin(); i != custom.end(); ++i) {
+        header_mangler_dump_replacement(entry, name, i->second,
+                                        i->first.c_str());
+    }
+
+    header_mangler_dump_replacement(entry, name, all, "All");
+}
+
+header_mangler *
+HeaderManglers::track(const char *name)
+{
+    int id = httpHeaderIdByNameDef(name, strlen(name));
+
+    if (id == HDR_BAD_HDR) { // special keyword or a custom header
+        if (strcmp(name, "All") == 0)
+            id = HDR_ENUM_END;
+        else if (strcmp(name, "Other") == 0)
+            id = HDR_OTHER;
+    }
+
+    header_mangler *m = NULL;
+    if (id == HDR_ENUM_END) {
+        m = &all;
+    } else if (id == HDR_BAD_HDR) {
+        m = &custom[name];
+    } else {
+        m = &known[id]; // including HDR_OTHER
+    }
+
+    assert(m);
+    return m;
+}
+
+void
+HeaderManglers::setReplacement(const char *name, const char *value)
+{
+    // for backword compatibility, we allow replacements to be configured
+    // for headers w/o access rules, but such replacements are ignored
+    header_mangler *m = track(name);
+
+    safe_free(m->replacement); // overwrite old value if any
+    m->replacement = xstrdup(value);
+}
+
+const header_mangler *
+HeaderManglers::find(const HttpHeaderEntry &e) const
+{
+    // a known header with a configured ACL list
+    if (e.id != HDR_OTHER && 0 <= e.id && e.id < HDR_ENUM_END &&
+            known[e.id].access_list)
+        return &known[e.id];
+
+    // a custom header
+    if (e.id == HDR_OTHER) {
+        // does it have an ACL list configured?
+        // Optimize: use a name type that we do not need to convert to here
+        const ManglersByName::const_iterator i = custom.find(e.name.termedBuf());
+        if (i != custom.end())
+            return &i->second;
+    }
+
+    // Next-to-last resort: "Other" rules match any custom header
+    if (e.id == HDR_OTHER && known[HDR_OTHER].access_list)
+        return &known[HDR_OTHER];
+
+    // Last resort: "All" rules match any header
+    if (all.access_list)
+        return &all;
+
+    return NULL;
+}
+
+void
+httpHdrAdd(HttpHeader *heads, HttpRequest *request, HeaderWithAclList &headersAdd)
+{
+    ACLFilledChecklist checklist(NULL, request, NULL);
+
+    for (HeaderWithAclList::const_iterator hwa = headersAdd.begin(); hwa != headersAdd.end(); ++hwa) {
+        if (!hwa->aclList || checklist.fastCheck(hwa->aclList) == ACCESS_ALLOWED) {
+            const char *fieldValue = NULL;
+            MemBuf mb;
+            if (hwa->quoted) {
+                if (request->al != NULL) {
+                    mb.init();
+                    hwa->valueFormat->assemble(mb, request->al, 0);
+                    fieldValue = mb.content();
+                }
+            } else {
+                fieldValue = hwa->fieldValue.c_str();
+            }
+
+            if (!fieldValue || fieldValue[0] == '\0')
+                fieldValue = "-";
+
+            HttpHeaderEntry *e = new HttpHeaderEntry(hwa->fieldId, hwa->fieldName.c_str(),
+                    fieldValue);
+            heads->addEntry(e);
+        }
+    }
 }
@@ -0,0 +1,92 @@
+#ifndef SQUID_HTTPHEADERTOOLS_H
+#define SQUID_HTTPHEADERTOOLS_H
+
+#include "format/Format.h"
+
+#if HAVE_LIST
+#include <list>
+#endif
+#if HAVE_MAP
+#include <map>
+#endif
+#if HAVE_STRING
+#include <string>
+#endif
+
+class HeaderWithAcl;
+typedef std::list<HeaderWithAcl> HeaderWithAclList;
+
+class acl_access;
+struct _header_mangler {
+    acl_access *access_list;
+    char *replacement;
+};
+typedef struct _header_mangler header_mangler;
+
+class StoreEntry;
+
+/// A collection of header_mangler objects for a given message kind.
+class HeaderManglers
+{
+public:
+    HeaderManglers();
+    ~HeaderManglers();
+
+    /// returns a header mangler for field e or nil if none was specified
+    const header_mangler *find(const HttpHeaderEntry &e) const;
+
+    /// returns a mangler for the named header (known or custom)
+    header_mangler *track(const char *name);
+
+    /// updates mangler for the named header with a replacement value
+    void setReplacement(const char *name, const char *replacementValue);
+
+    /// report the *_header_access part of the configuration
+    void dumpAccess(StoreEntry *entry, const char *optionName) const;
+    /// report the *_header_replace part of the configuration
+    void dumpReplacement(StoreEntry *entry, const char *optionName) const;
+
+private:
+    /// a name:mangler map; optimize: use unordered map or some such
+    typedef std::map<std::string, header_mangler> ManglersByName;
+
+    /// one mangler for each known header
+    header_mangler known[HDR_ENUM_END];
+
+    /// one mangler for each custom header
+    ManglersByName custom;
+
+    /// configured if some mangling ACL applies to all header names
+    header_mangler all;
+
+private:
+    /* not implemented */
+    HeaderManglers(const HeaderManglers &);
+    HeaderManglers &operator =(const HeaderManglers &);
+};
+
+class ACLList;
+class HeaderWithAcl
+{
+public:
+    HeaderWithAcl() :  aclList(NULL), fieldId (HDR_BAD_HDR), quoted(false) {}
+
+    /// HTTP header field name
+    std::string fieldName;
+
+    /// HTTP header field value, possibly with macros
+    std::string fieldValue;
+
+    /// when the header field should be added (always if nil)
+    ACLList *aclList;
+
+    /// compiled HTTP header field value (no macros)
+    Format::Format *valueFormat;
+
+    /// internal ID for "known" headers or HDR_OTHER
+    http_hdr_type fieldId;
+
+    /// whether fieldValue may contain macros
+    bool quoted;
+};
+#endif
@@ -35,6 +35,7 @@
  */
 
 #include "squid-old.h"
+#include "AccessLogEntry.h"
 #include "DnsLookupDetails.h"
 #include "HttpRequest.h"
 #include "HttpHdrCc.h"
@@ -262,6 +263,8 @@ HttpRequest::inheritProperties(const HttpMsg *aMsg)
 
     // main property is which connection the request was received on (if any)
     clientConnectionManager = aReq->clientConnectionManager;
+
+    al = aReq->al;
     return true;
 }
 
@@ -55,6 +55,8 @@ extern void httpRequestPack(void *obj, Packer *p);
 
 class HttpHdrRange;
 class DnsLookupDetails;
+class AccessLogEntry;
+typedef RefCount<AccessLogEntry> AccessLogEntryPointer;
 
 class HttpRequest: public HttpMsg
 {
@@ -242,6 +244,12 @@ class HttpRequest: public HttpMsg
      */
     CbcPointer<ConnStateData> clientConnectionManager;
 
+    /**
+     * The AccessLogEntry for the current ClientHttpRequest/Server HttpRequest
+     * pair, if known;
+     */
+    AccessLogEntryPointer al;
+
     int64_t getRangeOffsetLimit(); /* the result of this function gets cached in rangeOffsetLimit */
 
 private:
@@ -363,6 +363,7 @@ squid_SOURCES = \
 	HttpHeader.h \
 	HttpHeaderMask.h \
 	HttpHeaderRange.h \
+	HttpHeaderTools.h \
 	HttpHeaderTools.cc \
 	HttpBody.h \
 	HttpBody.cc \
@@ -1092,36 +1093,46 @@ tests_testHttpReply_SOURCES=\
 	SquidString.h \
 	SquidTime.h \
 	String.cc \
+	tests/stub_access_log.cc \
 	tests/stub_cache_cf.cc \
 	tests/stub_cache_manager.cc \
 	tests/stub_debug.cc \
+	tests/stub_errorpage.cc \
 	tests/stub_HelperChildConfig.cc \
+	tests/stub_libformat.cc \
 	StatCounters.h \
 	StatCounters.cc \
 	StatHist.h \
 	tests/stub_StatHist.cc \
 	tests/stub_store.cc \
 	tests/stub_store_stats.cc \
 	tests/stub_tools.cc \
+	tests/stub_HttpRequest.cc \
 	tests/testHttpReply.cc \
 	tests/testHttpReply.h \
 	tests/testMain.cc \
 	time.cc \
+	url.cc \
+	URLScheme.cc \
 	wordlist.cc
 nodist_tests_testHttpReply_SOURCES=\
 	$(TESTSOURCES)
 tests_testHttpReply_LDFLAGS = $(LIBADD_DL)
 tests_testHttpReply_LDADD=\
+	acl/libacls.la \
 	acl/libapi.la \
 	acl/libstate.la \
 	$(AUTH_LIBS) \
+	anyp/libanyp.la \
 	ip/libip.la \
 	base/libbase.la \
+	$(SSL_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(SQUID_CPPUNIT_LIBS) \
 	$(SQUID_CPPUNIT_LA) \
+	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(XTRA_LIBS)
 tests_testHttpReply_DEPENDENCIES= $(SQUID_CPPUNIT_LA)
@@ -1183,8 +1194,10 @@ tests_testACLMaxUserIP_SOURCES= \
 	tests/stub_debug.cc \
 	tests/stub_DelayId.cc \
 	tests/stub_DiskIOModule.cc \
+	tests/stub_errorpage.cc \
 	tests/stub_fd.cc \
 	tests/stub_HttpRequest.cc \
+	tests/stub_libformat.cc \
 	tests/stub_MemObject.cc \
 	tests/stub_MemStore.cc \
 	tests/stub_mime.cc \
@@ -1519,6 +1532,7 @@ tests_testDiskIO_SOURCES = \
 	tests/stub_internal.cc \
 	tests/stub_ipc.cc \
 	tests/stub_ipcache.cc \
+	tests/stub_libformat.cc \
 	tests/stub_libicmp.cc \
 	tests/stub_MemStore.cc \
 	tests/stub_mime.cc \
@@ -2447,6 +2461,7 @@ tests_testStore_SOURCES= \
 	tests/stub_helper.cc \
 	tests/stub_HelperChildConfig.cc \
 	tests/stub_http.cc \
+	tests/stub_libformat.cc \
 	HttpBody.h \
 	HttpBody.cc \
 	tests/stub_HttpReply.cc \
@@ -2500,6 +2515,7 @@ tests_testStore_LDADD= \
 	mgr/libmgr.la \
 	ipc/libipc.la \
 	anyp/libanyp.la \
+	$(SSL_LIBS) \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
@@ -2581,6 +2597,7 @@ tests_testUfs_SOURCES = \
 	tests/stub_Port.cc \
 	tests/stub_UdsOp.cc \
 	tests/stub_internal.cc \
+	tests/stub_libformat.cc \
 	tests/stub_store_rebuild.cc \
 	tests/stub_store_stats.cc \
 	fd.cc \
@@ -2784,6 +2801,7 @@ tests_testRock_SOURCES = \
 	tests/stub_icp.cc \
 	tests/stub_ipc.cc \
 	tests/stub_ipcache.cc \
+	tests/stub_libformat.cc \
 	tests/stub_libicmp.cc \
 	tests/stub_MemStore.cc \
 	tests/stub_mime.cc \
@@ -225,13 +225,13 @@ MemObject::stat(MemBuf * mb) const
                RequestMethodStr(method), log_url);
     if (vary_headers)
         mb->Printf("\tvary_headers: %s\n", vary_headers);
-    mb->Printf("\tinmem_lo: %"PRId64"\n", inmem_lo);
-    mb->Printf("\tinmem_hi: %"PRId64"\n", data_hdr.endOffset());
-    mb->Printf("\tswapout: %"PRId64" bytes queued\n",
+    mb->Printf("\tinmem_lo: %" PRId64 "\n", inmem_lo);
+    mb->Printf("\tinmem_hi: %" PRId64 "\n", data_hdr.endOffset());
+    mb->Printf("\tswapout: %" PRId64 " bytes queued\n",
                swapout.queue_offset);
 
     if (swapout.sio.getRaw())
-        mb->Printf("\tswapout: %"PRId64" bytes written\n",
+        mb->Printf("\tswapout: %" PRId64 " bytes written\n",
                    (int64_t) swapout.sio->offset());
 
     StoreClientStats statsVisitor(mb);
@@ -76,7 +76,7 @@ MemStore::stat(StoreEntry &e) const
         const int limit = map->entryLimit();
         storeAppendPrintf(&e, "Maximum entries: %9d\n", limit);
         if (limit > 0) {
-            storeAppendPrintf(&e, "Current entries: %"PRId64" %.2f%%\n",
+            storeAppendPrintf(&e, "Current entries: %" PRId64 " %.2f%%\n",
                               currentCount(), (100.0 * currentCount() / limit));
 
             if (limit < 100) { // XXX: otherwise too expensive to count
@@ -251,14 +251,40 @@ MemStore::copyFromShm(StoreEntry &e, const MemStoreMap::Extras &extras)
     return true;
 }
 
-void
-MemStore::considerKeeping(StoreEntry &e)
+bool
+MemStore::keepInLocalMemory(const StoreEntry &e) const
 {
     if (!e.memoryCachable()) {
         debugs(20, 7, HERE << "Not memory cachable: " << e);
-        return; // cannot keep due to entry state or properties
+        return false; // will not cache due to entry state or properties
+    }
+
+    assert(e.mem_obj);
+    const int64_t loadedSize = e.mem_obj->endOffset();
+    const int64_t expectedSize = e.mem_obj->expectedReplySize(); // may be < 0
+    const int64_t ramSize = max(loadedSize, expectedSize);
+
+    if (ramSize > static_cast<int64_t>(Config.Store.maxInMemObjSize)) {
+        debugs(20, 5, HERE << "Too big max(" <<
+               loadedSize << ", " << expectedSize << "): " << e);
+        return false; // will not cache due to cachable entry size limits
+    }
+
+    if (!willFit(ramSize)) {
+        debugs(20, 5, HERE << "Wont fit max(" <<
+               loadedSize << ", " << expectedSize << "): " << e);
+        return false; // will not cache due to memory cache slot limit
     }
 
+    return true;
+}
+
+void
+MemStore::considerKeeping(StoreEntry &e)
+{
+    if (!keepInLocalMemory(e))
+        return;
+
     // since we copy everything at once, we can only keep complete entries
     if (e.store_status != STORE_OK) {
         debugs(20, 7, HERE << "Incomplete: " << e);
@@ -270,25 +296,25 @@ MemStore::considerKeeping(StoreEntry &e)
     const int64_t loadedSize = e.mem_obj->endOffset();
     const int64_t expectedSize = e.mem_obj->expectedReplySize();
 
+    // objects of unknown size are not allowed into memory cache, for now
+    if (expectedSize < 0) {
+        debugs(20, 5, HERE << "Unknown expected size: " << e);
+        return;
+    }
+
     // since we copy everything at once, we can only keep fully loaded entries
     if (loadedSize != expectedSize) {
         debugs(20, 7, HERE << "partially loaded: " << loadedSize << " != " <<
                expectedSize);
         return;
     }
 
-    if (!willFit(expectedSize)) {
-        debugs(20, 5, HERE << "No mem-cache space for " << e);
-        return; // failed to free enough space
-    }
-
     keep(e); // may still fail
 }
 
 bool
-MemStore::willFit(int64_t need)
+MemStore::willFit(int64_t need) const
 {
-    // TODO: obey configured maximum entry size (with page-based rounding)
     return need <= static_cast<int64_t>(Ipc::Mem::PageSize());
 }
 
@@ -27,6 +27,9 @@ class MemStore: public Store, public Ipc::StoreMapCleaner
     /// cache the entry or forget about it until the next considerKeeping call
     void considerKeeping(StoreEntry &e);
 
+    /// whether e should be kept in local RAM for possible future caching
+    bool keepInLocalMemory(const StoreEntry &e) const;
+
     /* Store API */
     virtual int callback();
     virtual StoreEntry * get(const cache_key *);
@@ -47,7 +50,7 @@ class MemStore: public Store, public Ipc::StoreMapCleaner
     static int64_t EntryLimit();
 
 protected:
-    bool willFit(int64_t needed);
+    bool willFit(int64_t needed) const;
     void keep(StoreEntry &e);
 
     bool copyToShm(StoreEntry &e, MemStoreMap::Extras &extras);
@@ -351,6 +351,11 @@ class Store : public RefCountable
     /// called when the entry is no longer needed by any transaction
     virtual void handleIdleEntry(StoreEntry &e) {}
 
+    // XXX: This method belongs to Store::Root/StoreController, but it is here
+    // because test cases use non-StoreController derivatives as Root
+    /// called to get rid of no longer needed entry data in RAM, if any
+    virtual void maybeTrimMemory(StoreEntry &e, const bool preserveSwappable) {}
+
 private:
     static RefCount<Store> CurrentRoot;
 };
@@ -342,10 +342,10 @@ void
 SwapDir::optionObjectSizeDump(StoreEntry * e) const
 {
     if (min_objsize != 0)
-        storeAppendPrintf(e, " min-size=%"PRId64, min_objsize);
+        storeAppendPrintf(e, " min-size=%" PRId64, min_objsize);
 
     if (max_objsize != -1)
-        storeAppendPrintf(e, " max-size=%"PRId64, max_objsize);
+        storeAppendPrintf(e, " max-size=%" PRId64, max_objsize);
 }
 
 // some SwapDirs may maintain their indexes and be able to lookup an entry key
@@ -60,6 +60,7 @@ class StoreController : public Store
 
     /* Store parent API */
     virtual void handleIdleEntry(StoreEntry &e);
+    virtual void maybeTrimMemory(StoreEntry &e, const bool preserveSwappable);
 
     virtual void init();
 
@@ -91,6 +92,7 @@ class StoreController : public Store
 
 private:
     void createOneStore(Store &aStore);
+    bool keepForLocalMemoryCache(const StoreEntry &e) const;
 
     StorePointer swapDir; ///< summary view of all disk caches
     MemStore *memStore; ///< memory cache
@@ -201,12 +201,14 @@ CBDATA_TYPE(ASState);
 void
 asnInit(void)
 {
-    static int inited = 0;
+    static bool inited = false;
     squid_max_keylen = 40;
     CBDATA_INIT_TYPE(ASState);
 
-    if (0 == inited++)
+    if (!inited) {
+        inited = true;
         squid_rn_init();
+    }
 
     squid_rn_inithead(&AS_tree_head, 8);
 
@@ -310,9 +312,9 @@ asHandleReply(void *data, StoreIOBuffer result)
 
     while ((size_t)(s - buf) < result.length + asState->reqofs && *s != '\0') {
         while (*s && xisspace(*s))
-            s++;
+            ++s;
 
-        for (t = s; *t; t++) {
+        for (t = s; *t; ++t) {
             if (xisspace(*t))
                 break;
         }
@@ -635,7 +637,7 @@ ACLDestinationASNStrategy::match (ACLData<MatchType> * &data, ACLFilledChecklist
     const ipcache_addrs *ia = ipcache_gethostbyname(checklist->request->GetHost(), IP_LOOKUP_IF_MISS);
 
     if (ia) {
-        for (int k = 0; k < (int) ia->count; k++) {
+        for (int k = 0; k < (int) ia->count; ++k) {
             if (data->match(ia->in_addrs[k]))
                 return 1;
         }
@@ -67,7 +67,7 @@ ACLDestinationIP::match(ACLChecklist *cl)
     if (ia) {
         /* Entry in cache found */
 
-        for (int k = 0; k < (int) ia->count; k++) {
+        for (int k = 0; k < (int) ia->count; ++k) {
             if (ACLIP::match(ia->in_addrs[k]))
                 return 1;
         }
@@ -214,7 +214,7 @@ aclParseAclList(ConfigParser &parser, ACLList ** head)
 
         if (*t == '!') {
             L->negated (true);
-            t++;
+            ++t;
         }
 
         debugs(28, 3, "aclParseAclList: looking for ACL name '" << t << "'");
@@ -99,7 +99,7 @@ acl_ip_data::toStr(char *buf, int len) const
 
     if (!addr2.IsAnyAddr()) {
         b2[0] = '-';
-        rlen++;
+        ++rlen;
         addr2.NtoA(&(b2[1]), len - rlen );
         rlen = strlen(buf);
     } else
@@ -109,7 +109,7 @@ acl_ip_data::toStr(char *buf, int len) const
 
     if (!mask.IsNoAddr()) {
         b3[0] = '/';
-        rlen++;
+        ++rlen;
         int cidr =  mask.GetCIDR() - (addr1.IsIPv4()?96:0);
         snprintf(&(b3[1]), (len-rlen), "%u", (unsigned int)(cidr<0?0:cidr) );
     } else
@@ -238,11 +238,11 @@ compileOptimisedREs(relist **curlist, wordlist * wl)
             if (largeREindex > 0)
                 largeRE[largeREindex++] = '|';
             largeRE[largeREindex++] = '(';
-            for (char * t = wl->key; *t != '\0'; t++)
+            for (char * t = wl->key; *t != '\0'; ++t)
                 largeRE[largeREindex++] = *t;
             largeRE[largeREindex++] = ')';
             largeRE[largeREindex] = '\0';
-            numREs++;
+            ++numREs;
         } else {
             debugs(28, 2, "compileOptimisedREs: buffer full, generating new optimised RE..." );
             newlistp = compileRE( newlistp, largeRE, flags );
@@ -226,7 +226,7 @@ Adaptation::Config::finalize()
         ServicePointer s = createService(cfg);
         if (s != NULL) {
             AllServices().push_back(s);
-            created++;
+            ++created;
         }
     }
 
@@ -285,7 +285,7 @@ Adaptation::Config::ParseMetaHeader(ConfigParser &parser)
     ConfigParser::ParseQuotedString(&value);
 
     // TODO: Find a way to move this check to ICAP
-    for (int i = 0; warnFor[i] != NULL; i++) {
+    for (int i = 0; warnFor[i] != NULL; ++i) {
         if (name.caseCmp(warnFor[i]) == 0) {
             fatalf("%s:%d: meta name \"%s\" is a reserved ICAP header name",
                    cfg_filename, config_lineno, name.termedBuf());
@@ -187,7 +187,7 @@ Adaptation::ServiceConfig::grokUri(const char *value)
         if ((t = strchr(s, ']')) == NULL)
             return false;
 
-        s++;
+        ++s;
         len = t - s;
         if ((e = strchr(t, ':')) != NULL) {
             have_port = true;
@@ -212,7 +212,7 @@ Adaptation::ServiceConfig::grokUri(const char *value)
 
     port = -1;
     if (have_port) {
-        s++;
+        ++s;
 
         if ((e = strchr(s, '/')) != NULL) {
             char *t;
@@ -235,7 +235,7 @@ Adaptation::ServiceConfig::grokUri(const char *value)
 
     // if no port, the caller may use service_configConfigs or supply the default if neeeded
 
-    s++;
+    ++s;
     e = strchr(s, '\0');
     len = e - s;
 
@@ -1249,7 +1249,7 @@ void Adaptation::Icap::ModXact::swanSong()
     Adaptation::Icap::Xaction::swanSong();
 }
 
-void prepareLogWithRequestDetails(HttpRequest *, AccessLogEntry *);
+void prepareLogWithRequestDetails(HttpRequest *, AccessLogEntry::Pointer &);
 
 void Adaptation::Icap::ModXact::finalizeLogInfo()
 {
@@ -1313,7 +1313,7 @@ void Adaptation::Icap::ModXact::finalizeLogInfo()
         packerClean(&p);
         mb.clean();
     }
-    prepareLogWithRequestDetails(request_, &al);
+    prepareLogWithRequestDetails(request_, alep);
     Xaction::finalizeLogInfo();
 }
 
@@ -479,7 +479,7 @@ void Adaptation::Icap::ServiceRep::checkOptions()
 
             method_list.append(ICAP::methodStr(*iter));
             method_list.append(" ", 1);
-            iter++;
+            ++iter;
         }
 
         if (!method_found) {
@@ -40,7 +40,9 @@ Adaptation::Icap::Xaction::Xaction(const char *aTypeName, Adaptation::Icap::Serv
         isRetriable(true),
         isRepeatable(true),
         ignoreLastWrite(false),
-        connector(NULL), reader(NULL), writer(NULL), closer(NULL)
+        connector(NULL), reader(NULL), writer(NULL), closer(NULL),
+        alep(new AccessLogEntry),
+        al(*alep)
 {
     debugs(93,3, typeName << " constructed, this=" << this <<
            " [icapx" << id << ']'); // we should not call virtual status() here
@@ -540,9 +542,8 @@ void Adaptation::Icap::Xaction::maybeLog()
         ACLChecklist *checklist = new ACLFilledChecklist(::Config.accessList.icap, al.request, dash_str);
         if (!::Config.accessList.icap || checklist->fastCheck() == ACCESS_ALLOWED) {
             finalizeLogInfo();
-            icapLogLog(&al, checklist);
+            icapLogLog(alep, checklist);
         }
-        accessLogFreeMemory(&al);
         delete checklist;
     }
 }
@@ -182,7 +182,8 @@ class Xaction: public Adaptation::Initiate
     AsyncCall::Pointer writer;
     AsyncCall::Pointer closer;
 
-    AccessLogEntry al;
+    AccessLogEntry::Pointer alep; ///< icap.log entry
+    AccessLogEntry &al; ///< short for *alep
 
     timeval icap_tr_start;     /*time when the ICAP transaction was created */
     timeval icap_tio_start;    /*time when the first ICAP request byte was scheduled for sending*/
@@ -44,7 +44,7 @@ icapLogRotate()
     }
 }
 
-void icapLogLog(AccessLogEntry *al, ACLChecklist * checklist)
+void icapLogLog(AccessLogEntry::Pointer &al, ACLChecklist * checklist)
 {
     if (IcapLogfileStatus == LOG_ENABLE)
         accessLogLogTo(Config.Log.icaplogs, al, checklist);
@@ -1,13 +1,16 @@
 #ifndef ICAP_LOG_H_
 #define ICAP_LOG_H_
 
+#include "RefCount.h"
+
+typedef RefCount<AccessLogEntry> AccessLogEntryPointer;
 class AccessLogEntry;
 class ACLChecklist;
 
 void icapLogClose();
 void icapLogOpen();
 void icapLogRotate();
-void icapLogLog(AccessLogEntry *al, ACLChecklist * checklist);
+void icapLogLog(AccessLogEntryPointer &al, ACLChecklist * checklist);
 
 extern int IcapLogfileStatus;
 
@@ -152,15 +152,12 @@ ProxyAuthLookup::checkForAsync(ACLChecklist *cl)const
 }
 
 void
-ProxyAuthLookup::LookupDone(void *data, char *result)
+ProxyAuthLookup::LookupDone(void *data)
 {
     ACLFilledChecklist *checklist = Filled(static_cast<ACLChecklist*>(data));
 
     assert (checklist->asyncState() == ProxyAuthLookup::Instance());
 
-    if (result != NULL)
-        fatal("AclLookupProxyAuthDone: Old code floating around somewhere.\nMake clean and if that doesn't work, report a bug to the squid developers.\n");
-
     if (checklist->auth_user_request == NULL || !checklist->auth_user_request->valid() || checklist->conn() == NULL) {
         /* credentials could not be checked either way
          * restart the whole process */
@@ -50,7 +50,7 @@ class ProxyAuthLookup : public ACLChecklist::AsyncState
 
 private:
     static ProxyAuthLookup instance_;
-    static void LookupDone(void *data, char *result);
+    static void LookupDone(void *data);
 };
 
 class ACLProxyAuth : public ACL
@@ -15,7 +15,7 @@ namespace Auth
 class StateData
 {
 public:
-    StateData(const UserRequest::Pointer &r, RH *h, void *d) :
+    StateData(const UserRequest::Pointer &r, AUTHCB *h, void *d) :
             data(cbdataReference(d)),
             auth_user_request(r),
             handler(h) {}
@@ -27,7 +27,7 @@ class StateData
 
     void *data;
     UserRequest::Pointer auth_user_request;
-    RH *handler;
+    AUTHCB *handler;
 
 private:
     CBDATA_CLASS2(StateData);
@@ -140,10 +140,10 @@ Auth::User::absorb(Auth::User::Pointer from)
             if (!found) {
                 /* This ip is not in the seen list. Add it. */
                 dlinkAddTail(&new_ipdata->node, &ipdata->node, &ip_list);
-                ipcount++;
+                ++ipcount;
                 /* remove from the source list */
                 dlinkDelete(&new_ipdata->node, &(from->ip_list));
-                from->ipcount--;
+                ++from->ipcount;
             }
         }
     }
@@ -334,7 +334,7 @@ Auth::User::addIp(Ip::Address ipaddr)
 
     dlinkAddTail(ipdata, &ipdata->node, &ip_list);
 
-    ipcount++;
+    ++ipcount;
 
     debugs(29, 2, HERE << "user '" << username() << "' has been seen at a new IP address (" << ipaddr << ")");
 }
@@ -63,7 +63,7 @@ Auth::UserRequest::username() const
 
 /* send the initial data to an authenticator module */
 void
-Auth::UserRequest::start(RH * handler, void *data)
+Auth::UserRequest::start(AUTHCB * handler, void *data)
 {
     assert(handler);
     assert(data);
@@ -66,6 +66,9 @@ class AuthUserIP
     time_t ip_expiretime;
 };
 
+// TODO: make auth schedule AsyncCalls?
+typedef void AUTHCB(void*);
+
 namespace Auth
 {
 
@@ -156,7 +159,7 @@ class UserRequest : public RefCountable
      * \param handler	Handler to process the callback when its run
      * \param data	CBDATA for handler
      */
-    virtual void module_start(RH *handler, void *data) = 0;
+    virtual void module_start(AUTHCB *handler, void *data) = 0;
 
     // User credentials object this UserRequest is managing
     virtual User::Pointer user() {return _auth_user;}
@@ -186,7 +189,7 @@ class UserRequest : public RefCountable
     /// Add the appropriate [Proxy-]Authenticate header to the given reply
     static void addReplyAuthHeader(HttpReply * rep, UserRequest::Pointer auth_user_request, HttpRequest * request, int accelerated, int internal);
 
-    void start( RH * handler, void *data);
+    void start(AUTHCB *handler, void *data);
     char const * denyMessage(char const * const default_message = NULL);
 
     /** Possibly overrideable in future */
@@ -77,7 +77,7 @@ Auth::Basic::UserRequest::module_direction()
 
 /* send the initial data to a basic authenticator module */
 void
-Auth::Basic::UserRequest::module_start(RH * handler, void *data)
+Auth::Basic::UserRequest::module_start(AUTHCB * handler, void *data)
 {
     assert(user()->auth_type == Auth::AUTH_BASIC);
     Auth::Basic::User *basic_auth = dynamic_cast<Auth::Basic::User *>(user().getRaw());
@@ -86,7 +86,7 @@ Auth::Basic::UserRequest::module_start(RH * handler, void *data)
 
     if (static_cast<Auth::Basic::Config*>(Auth::Config::Find("basic"))->authenticateProgram == NULL) {
         debugs(29, DBG_CRITICAL, "ERROR: No Basic authentication program configured.");
-        handler(data, NULL);
+        handler(data);
         return;
     }
 
@@ -124,10 +124,10 @@ Auth::Basic::UserRequest::module_start(RH * handler, void *data)
     int sz = snprintf(buf, sizeof(buf), "%s %s\n", username, pass);
     if (sz<=0) {
         debugs(9, DBG_CRITICAL, "ERROR: Basic Authentication Failure. Can not build helper validation request.");
-        handler(data, NULL);
+        handler(data);
     } else if (static_cast<size_t>(sz) >= sizeof(buf)) {
         debugs(9, DBG_CRITICAL, "ERROR: Basic Authentication Failure. user:password exceeds " << sizeof(buf) << " bytes.");
-        handler(data, NULL);
+        handler(data);
     } else
         helperSubmit(basicauthenticators, buf, Auth::Basic::UserRequest::HandleReply,
                      new Auth::StateData(this, handler, data));
@@ -171,15 +171,15 @@ Auth::Basic::UserRequest::HandleReply(void *data, char *reply)
     basic_auth->expiretime = squid_curtime;
 
     if (cbdataReferenceValidDone(r->data, &cbdata))
-        r->handler(cbdata, NULL);
+        r->handler(cbdata);
 
     cbdataReferenceDone(r->data);
 
     while (basic_auth->auth_queue) {
         tmpnode = basic_auth->auth_queue->next;
 
         if (cbdataReferenceValidDone(basic_auth->auth_queue->data, &cbdata))
-            basic_auth->auth_queue->handler(cbdata, NULL);
+            basic_auth->auth_queue->handler(cbdata);
 
         xfree(basic_auth->auth_queue);
 
@@ -26,7 +26,7 @@ class UserRequest : public Auth::UserRequest
     virtual int authenticated() const;
     virtual void authenticate(HttpRequest * request, ConnStateData *conn, http_hdr_type type);
     virtual Auth::Direction module_direction();
-    virtual void module_start(RH *, void *);
+    virtual void module_start(AUTHCB *, void *);
 
 private:
     static HLPCB HandleReply;
@@ -223,11 +223,11 @@ Auth::Basic::Config::decodeCleartext(const char *httpAuthHeader)
 
     /* trim BASIC from string */
     while (xisgraph(*proxy_auth))
-        proxy_auth++;
+        ++proxy_auth;
 
     /* Trim leading whitespace before decoding */
     while (xisspace(*proxy_auth))
-        proxy_auth++;
+        ++proxy_auth;
 
     /* Trim trailing \n before decoding */
     // XXX: really? is the \n actually still there? does the header parse not drop it?
@@ -20,7 +20,7 @@ class BasicAuthQueueNode
 public:
     BasicAuthQueueNode *next;
     Auth::UserRequest::Pointer auth_user_request;
-    RH *handler;
+    AUTHCB *handler;
     void *data;
 };
 
@@ -245,7 +245,7 @@ Auth::Digest::UserRequest::addAuthenticationInfoTrailer(HttpReply * rep, int acc
 
 /* send the initial data to a digest authenticator module */
 void
-Auth::Digest::UserRequest::module_start(RH * handler, void *data)
+Auth::Digest::UserRequest::module_start(AUTHCB * handler, void *data)
 {
     char buf[8192];
 
@@ -254,7 +254,7 @@ Auth::Digest::UserRequest::module_start(RH * handler, void *data)
 
     if (static_cast<Auth::Digest::Config*>(Auth::Config::Find("digest"))->authenticateProgram == NULL) {
         debugs(29, DBG_CRITICAL, "ERROR: No Digest authentication program configured.");
-        handler(data, NULL);
+        handler(data);
         return;
     }
 
@@ -309,7 +309,7 @@ Auth::Digest::UserRequest::HandleReply(void *data, char *reply)
     }
 
     if (cbdataReferenceValidDone(replyData->data, &cbdata))
-        replyData->handler(cbdata, NULL);
+        replyData->handler(cbdata);
 
     delete replyData;
 }
@@ -34,7 +34,7 @@ class UserRequest : public Auth::UserRequest
     virtual void addAuthenticationInfoTrailer(HttpReply * rep, int accel);
 #endif
 
-    virtual void module_start(RH *, void *);
+    virtual void module_start(AUTHCB *, void *);
 
     char *nonceb64;             /* "dcd98b7102dd2f0e8b11d0f600bfb0c093" */
     char *cnonce;               /* "0a4f113b" */
@@ -186,7 +186,7 @@ authenticateDigestNonceNew(void)
         /* create a new nonce */
         newnonce->noncedata.randomdata = squid_random();
         /* Bug 3526 high performance fix: add 1 second to creationtime to avoid duplication */
-        newnonce->noncedata.creationtime++;
+        ++newnonce->noncedata.creationtime;
         authDigestNonceEncode(newnonce);
     }
 
@@ -298,7 +298,7 @@ static void
 authDigestNonceLink(digest_nonce_h * nonce)
 {
     assert(nonce != NULL);
-    nonce->references++;
+    ++nonce->references;
     debugs(29, 9, "authDigestNonceLink: nonce '" << nonce << "' now at '" << nonce->references << "'.");
 }
 
@@ -379,7 +379,7 @@ authDigestNonceIsValid(digest_nonce_h * nonce, char nc[9])
 
     /* is the nonce-count ok ? */
     if (!static_cast<Auth::Digest::Config*>(Auth::Config::Find("digest"))->CheckNonceCount) {
-        nonce->nc++;
+        ++nonce->nc;
         return -1;              /* forced OK by configuration */
     }
 
@@ -796,11 +796,11 @@ Auth::Digest::Config::decode(char const *proxy_auth)
     /* trim DIGEST from string */
 
     while (xisgraph(*proxy_auth))
-        proxy_auth++;
+        ++proxy_auth;
 
     /* Trim leading whitespace before decoding */
     while (xisspace(*proxy_auth))
-        proxy_auth++;
+        ++proxy_auth;
 
     String temp(proxy_auth);
 
@@ -79,7 +79,7 @@ Auth::Negotiate::UserRequest::module_direction()
 }
 
 void
-Auth::Negotiate::UserRequest::module_start(RH * handler, void *data)
+Auth::Negotiate::UserRequest::module_start(AUTHCB * handler, void *data)
 {
     static char buf[MAX_AUTHTOKEN_LEN];
 
@@ -91,7 +91,7 @@ Auth::Negotiate::UserRequest::module_start(RH * handler, void *data)
 
     if (static_cast<Auth::Negotiate::Config*>(Auth::Config::Find("negotiate"))->authenticateProgram == NULL) {
         debugs(29, DBG_CRITICAL, "ERROR: No Negotiate authentication program configured.");
-        handler(data, NULL);
+        handler(data);
         return;
     }
 
@@ -179,13 +179,13 @@ Auth::Negotiate::UserRequest::authenticate(HttpRequest * aRequest, ConnStateData
 
     if (blob) {
         while (xisspace(*blob) && *blob)
-            blob++;
+            ++blob;
 
         while (!xisspace(*blob) && *blob)
-            blob++;
+            ++blob;
 
         while (xisspace(*blob) && *blob)
-            blob++;
+            ++blob;
     }
 
     switch (user()->credentials()) {
@@ -360,7 +360,7 @@ Auth::Negotiate::UserRequest::HandleReply(void *data, void *lastserver, char *re
     }
 
     lm_request->request = NULL;
-    r->handler(r->data, NULL);
+    r->handler(r->data);
     delete r;
 }
 
@@ -27,7 +27,7 @@ class UserRequest : public Auth::UserRequest
     virtual void authenticate(HttpRequest * request, ConnStateData * conn, http_hdr_type type);
     virtual Direction module_direction();
     virtual void onConnectionClose(ConnStateData *);
-    virtual void module_start(RH *, void *);
+    virtual void module_start(AUTHCB *, void *);
 
     virtual void addAuthenticationInfoHeader(HttpReply * rep, int accel);
 
@@ -77,7 +77,7 @@ Auth::Ntlm::UserRequest::module_direction()
 }
 
 void
-Auth::Ntlm::UserRequest::module_start(RH * handler, void *data)
+Auth::Ntlm::UserRequest::module_start(AUTHCB * handler, void *data)
 {
     static char buf[MAX_AUTHTOKEN_LEN];
 
@@ -86,7 +86,7 @@ Auth::Ntlm::UserRequest::module_start(RH * handler, void *data)
 
     if (static_cast<Auth::Ntlm::Config*>(Auth::Config::Find("ntlm"))->authenticateProgram == NULL) {
         debugs(29, DBG_CRITICAL, "ERROR: NTLM Start: no NTLM program configured.");
-        handler(data, NULL);
+        handler(data);
         return;
     }
 
@@ -173,13 +173,13 @@ Auth::Ntlm::UserRequest::authenticate(HttpRequest * aRequest, ConnStateData * co
     /* if proxy_auth is actually NULL, we'd better not manipulate it. */
     if (blob) {
         while (xisspace(*blob) && *blob)
-            blob++;
+            ++blob;
 
         while (!xisspace(*blob) && *blob)
-            blob++;
+            ++blob;
 
         while (xisspace(*blob) && *blob)
-            blob++;
+            ++blob;
     }
 
     switch (user()->credentials()) {
@@ -262,7 +262,7 @@ Auth::Ntlm::UserRequest::HandleReply(void *data, void *lastserver, char *reply)
     /* seperate out the useful data */
     blob = strchr(reply, ' ');
     if (blob)
-        blob++;
+        ++blob;
 
     if (strncasecmp(reply, "TT ", 3) == 0) {
         /* we have been given a blob to send to the client */
@@ -340,6 +340,6 @@ Auth::Ntlm::UserRequest::HandleReply(void *data, void *lastserver, char *reply)
         HTTPMSGUNLOCK(lm_request->request);
         lm_request->request = NULL;
     }
-    r->handler(r->data, NULL);
+    r->handler(r->data);
     delete r;
 }
@@ -27,7 +27,7 @@ class UserRequest : public Auth::UserRequest
     virtual void authenticate(HttpRequest * request, ConnStateData * conn, http_hdr_type type);
     virtual Auth::Direction module_direction();
     virtual void onConnectionClose(ConnStateData *);
-    virtual void module_start(RH *, void *);
+    virtual void module_start(AUTHCB *, void *);
 
     virtual const char * connLastHeader();
 
@@ -47,9 +47,10 @@ AsyncCall::make()
 bool
 AsyncCall::cancel(const char *reason)
 {
-    if (isCanceled)
-        debugs(debugSection, debugLevel, HERE << "will not call " << name <<
-               " [" << id << ']' << " also because " << reason);
+    debugs(debugSection, debugLevel, HERE << "will not call " << name <<
+           " [" << id << "] " << (isCanceled ? "also " : "") <<
+           "because " << reason);
+
     isCanceled = reason;
     return false;
 }
@@ -51,12 +51,12 @@ unsigned int TextException::FileNameHash(const char *fname)
     s = strrchr(fname, '/');
 
     if (s)
-        s++;
+        ++s;
     else
         s = fname;
 
     while (*s) {
-        j++;
+        ++j;
         n ^= 271 * (unsigned) *s++;
     }
     i = n ^ (j * 271);
@@ -91,6 +91,10 @@
 #include <limits>
 #endif
 
+#if HAVE_LIST
+#include <list>
+#endif
+
 #if USE_SSL
 #include "ssl/gadgets.h"
 #endif
@@ -171,13 +175,17 @@ static void free_all(void);
 void requirePathnameExists(const char *name, const char *path);
 static OBJH dump_config;
 #if USE_HTTP_VIOLATIONS
-static void dump_http_header_access(StoreEntry * entry, const char *name, header_mangler header[]);
-static void parse_http_header_access(header_mangler header[]);
-static void free_http_header_access(header_mangler header[]);
-static void dump_http_header_replace(StoreEntry * entry, const char *name, header_mangler header[]);
-static void parse_http_header_replace(header_mangler * header);
-static void free_http_header_replace(header_mangler * header);
+static void free_HeaderManglers(HeaderManglers **pm);
+static void dump_http_header_access(StoreEntry * entry, const char *name, const HeaderManglers *manglers);
+static void parse_http_header_access(HeaderManglers **manglers);
+#define free_http_header_access free_HeaderManglers
+static void dump_http_header_replace(StoreEntry * entry, const char *name, const HeaderManglers *manglers);
+static void parse_http_header_replace(HeaderManglers **manglers);
+#define free_http_header_replace free_HeaderManglers
 #endif
+static void dump_HeaderWithAclList(StoreEntry * entry, const char *name, HeaderWithAclList *headers);
+static void parse_HeaderWithAclList(HeaderWithAclList **header);
+static void free_HeaderWithAclList(HeaderWithAclList **header);
 static void parse_denyinfo(acl_deny_info_list ** var);
 static void dump_denyinfo(StoreEntry * entry, const char *name, acl_deny_info_list * var);
 static void free_denyinfo(acl_deny_info_list ** var);
@@ -826,7 +834,7 @@ configDoConfigure(void)
     // TODO: replace with a dedicated "purge" ACL option?
     Config2.onoff.enable_purge = (ACLMethodData::ThePurgeCount > 0);
 
-    Config2.onoff.mangle_request_headers = httpReqHdrManglersConfigured();
+    Config2.onoff.mangle_request_headers = (Config.request_header_access != NULL);
 
     if (geteuid() == 0) {
         if (NULL != Config.effectiveUser) {
@@ -1679,23 +1687,15 @@ parse_client_delay_pool_access(ClientDelayConfig * cfg)
 
 #if USE_HTTP_VIOLATIONS
 static void
-dump_http_header_access(StoreEntry * entry, const char *name, header_mangler header[])
+dump_http_header_access(StoreEntry * entry, const char *name, const HeaderManglers *manglers)
 {
-    int i;
-
-    for (i = 0; i < HDR_ENUM_END; i++) {
-        if (header[i].access_list != NULL) {
-            storeAppendPrintf(entry, "%s ", name);
-            dump_acl_access(entry, httpHeaderNameById(i),
-                            header[i].access_list);
-        }
-    }
+    if (manglers)
+        manglers->dumpAccess(entry, name);
 }
 
 static void
-parse_http_header_access(header_mangler header[])
+parse_http_header_access(HeaderManglers **pm)
 {
-    int id, i;
     char *t = NULL;
 
     if ((t = strtok(NULL, w_space)) == NULL) {
@@ -1704,64 +1704,34 @@ parse_http_header_access(header_mangler header[])
         return;
     }
 
-    /* Now lookup index of header. */
-    id = httpHeaderIdByNameDef(t, strlen(t));
-
-    if (strcmp(t, "All") == 0)
-        id = HDR_ENUM_END;
-    else if (strcmp(t, "Other") == 0)
-        id = HDR_OTHER;
-    else if (id == -1) {
-        debugs(3, 0, "" << cfg_filename << " line " << config_lineno << ": " << config_input_line);
-        debugs(3, 0, "parse_http_header_access: unknown header name '" << t << "'");
-        return;
-    }
-
-    if (id != HDR_ENUM_END) {
-        parse_acl_access(&header[id].access_list);
-    } else {
-        char *next_string = t + strlen(t) - 1;
-        *next_string = 'A';
-        *(next_string + 1) = ' ';
-
-        for (i = 0; i < HDR_ENUM_END; i++) {
-            char *new_string = xstrdup(next_string);
-            strtok(new_string, w_space);
-            parse_acl_access(&header[i].access_list);
-            safe_free(new_string);
-        }
-    }
+    if (!*pm)
+        *pm = new HeaderManglers;
+    HeaderManglers *manglers = *pm;
+    header_mangler *mangler = manglers->track(t);
+    assert(mangler);
+    parse_acl_access(&mangler->access_list);
 }
 
 static void
-free_http_header_access(header_mangler header[])
+free_HeaderManglers(HeaderManglers **pm)
 {
-    int i;
-
-    for (i = 0; i < HDR_ENUM_END; i++) {
-        free_acl_access(&header[i].access_list);
+    // we delete the entire http_header_* mangler configuration at once
+    if (const HeaderManglers *manglers = *pm) {
+        delete manglers;
+        *pm = NULL;
     }
 }
 
 static void
-dump_http_header_replace(StoreEntry * entry, const char *name, header_mangler
-                         header[])
+dump_http_header_replace(StoreEntry * entry, const char *name, const HeaderManglers *manglers)
 {
-    int i;
-
-    for (i = 0; i < HDR_ENUM_END; i++) {
-        if (NULL == header[i].replacement)
-            continue;
-
-        storeAppendPrintf(entry, "%s %s %s\n", name, httpHeaderNameById(i),
-                          header[i].replacement);
-    }
+    if (manglers)
+        manglers->dumpReplacement(entry, name);
 }
 
 static void
-parse_http_header_replace(header_mangler header[])
+parse_http_header_replace(HeaderManglers **pm)
 {
-    int id, i;
     char *t = NULL;
 
     if ((t = strtok(NULL, w_space)) == NULL) {
@@ -1770,44 +1740,12 @@ parse_http_header_replace(header_mangler header[])
         return;
     }
 
-    /* Now lookup index of header. */
-    id = httpHeaderIdByNameDef(t, strlen(t));
-
-    if (strcmp(t, "All") == 0)
-        id = HDR_ENUM_END;
-    else if (strcmp(t, "Other") == 0)
-        id = HDR_OTHER;
-    else if (id == -1) {
-        debugs(3, 0, "" << cfg_filename << " line " << config_lineno << ": " << config_input_line);
-        debugs(3, 0, "parse_http_header_replace: unknown header name " << t << ".");
-
-        return;
-    }
-
-    if (id != HDR_ENUM_END) {
-        if (header[id].replacement != NULL)
-            safe_free(header[id].replacement);
-
-        header[id].replacement = xstrdup(t + strlen(t) + 1);
-    } else {
-        for (i = 0; i < HDR_ENUM_END; i++) {
-            if (header[i].replacement != NULL)
-                safe_free(header[i].replacement);
-
-            header[i].replacement = xstrdup(t + strlen(t) + 1);
-        }
-    }
-}
-
-static void
-free_http_header_replace(header_mangler header[])
-{
-    int i;
+    const char *value = t + strlen(t) + 1;
 
-    for (i = 0; i < HDR_ENUM_END; i++) {
-        if (header[i].replacement != NULL)
-            safe_free(header[i].replacement);
-    }
+    if (!*pm)
+        *pm = new HeaderManglers;
+    HeaderManglers *manglers = *pm;
+    manglers->setReplacement(t, value);
 }
 
 #endif
@@ -3039,7 +2977,7 @@ static void
 dump_time_msec(StoreEntry * entry, const char *name, time_msec_t var)
 {
     if (var % 1000)
-        storeAppendPrintf(entry, "%s %"PRId64" milliseconds\n", name, var);
+        storeAppendPrintf(entry, "%s %" PRId64 " milliseconds\n", name, var);
     else
         storeAppendPrintf(entry, "%s %d seconds\n", name, (int)(var/1000) );
 }
@@ -3090,13 +3028,13 @@ dump_kb_size_t(StoreEntry * entry, const char *name, size_t var)
 static void
 dump_b_int64_t(StoreEntry * entry, const char *name, int64_t var)
 {
-    storeAppendPrintf(entry, "%s %"PRId64" %s\n", name, var, B_BYTES_STR);
+    storeAppendPrintf(entry, "%s %" PRId64 " %s\n", name, var, B_BYTES_STR);
 }
 
 static void
 dump_kb_int64_t(StoreEntry * entry, const char *name, int64_t var)
 {
-    storeAppendPrintf(entry, "%s %"PRId64" %s\n", name, var, B_KBYTES_STR);
+    storeAppendPrintf(entry, "%s %" PRId64 " %s\n", name, var, B_KBYTES_STR);
 }
 
 #if UNUSED_CODE
@@ -4658,3 +4596,68 @@ static void free_sslproxy_ssl_bump(acl_access **ssl_bump)
 }
 
 #endif
+
+static void dump_HeaderWithAclList(StoreEntry * entry, const char *name, HeaderWithAclList *headers)
+{
+    if (!headers)
+        return;
+
+    for (HeaderWithAclList::iterator hwa = headers->begin(); hwa != headers->end(); ++hwa) {
+        storeAppendPrintf(entry, "%s ", hwa->fieldName.c_str());
+        storeAppendPrintf(entry, "%s ", hwa->fieldValue.c_str());
+        if (hwa->aclList)
+            dump_acl_list(entry, hwa->aclList);
+        storeAppendPrintf(entry, "\n");
+    }
+}
+
+static void parse_HeaderWithAclList(HeaderWithAclList **headers)
+{
+    char *fn;
+    if (!*headers) {
+        *headers = new HeaderWithAclList;
+    }
+    if ((fn = strtok(NULL, w_space)) == NULL) {
+        self_destruct();
+        return;
+    }
+    HeaderWithAcl hwa;
+    hwa.fieldName = fn;
+    hwa.fieldId = httpHeaderIdByNameDef(fn, strlen(fn));
+    if (hwa.fieldId == HDR_BAD_HDR)
+        hwa.fieldId = HDR_OTHER;
+
+    String buf;
+    bool wasQuoted;
+    ConfigParser::ParseQuotedString(&buf, &wasQuoted);
+    hwa.fieldValue = buf.termedBuf();
+    hwa.quoted = wasQuoted;
+    if (hwa.quoted) {
+        Format::Format *nlf =  new ::Format::Format("hdrWithAcl");
+        if (!nlf->parse(hwa.fieldValue.c_str())) {
+            self_destruct();
+            return;
+        }
+        hwa.valueFormat = nlf;
+    }
+    aclParseAclList(LegacyParser, &hwa.aclList);
+    (*headers)->push_back(hwa);
+}
+
+static void free_HeaderWithAclList(HeaderWithAclList **header)
+{
+    if (!(*header))
+        return;
+
+    for (HeaderWithAclList::iterator hwa = (*header)->begin(); hwa != (*header)->end(); ++hwa) {
+        if (hwa->aclList)
+            aclDestroyAclList(&hwa->aclList);
+
+        if (hwa->valueFormat) {
+            delete hwa->valueFormat;
+            hwa->valueFormat = NULL;
+        }
+    }
+    delete *header;
+    *header = NULL;
+}
@@ -31,6 +31,7 @@ hostdomain		cache_peer
 hostdomaintype		cache_peer
 http_header_access	acl
 http_header_replace
+HeaderWithAclList	acl
 adaptation_access_type	adaptation_service_set adaptation_service_chain acl icap_service icap_class
 adaptation_service_set_type	icap_service ecap_service
 adaptation_service_chain_type	icap_service ecap_service
@@ -3398,6 +3398,20 @@ DOC_START
 	service name in curly braces to record response time(s) specific
 	to that service. For example: %{my_service}adapt::sum_trs
 
+	If SSL is enabled, the following formating codes become available:
+
+		%ssl::>cert_subject The Subject field of the received client
+				SSL certificate or a dash ('-') if Squid has
+				received an invalid/malformed certificate or
+				no certificate at all. Consider encoding the
+				logged value because Subject often has spaces.
+
+		%ssl::>cert_issuer The Issuer field of the received client
+				SSL certificate or a dash ('-') if Squid has
+				received an invalid/malformed certificate or
+				no certificate at all. Consider encoding the
+				logged value because Issuer often has spaces.
+
 	The default formats available (which do not need re-defining) are:
 
 logformat squid      %ts.%03tu %6tr %>a %Ss/%03>Hs %<st %rm %ru %[un %Sh/%<a %mt
@@ -4661,7 +4675,7 @@ DOC_END
 
 NAME: request_header_access
 IFDEF: USE_HTTP_VIOLATIONS
-TYPE: http_header_access[]
+TYPE: http_header_access
 LOC: Config.request_header_access
 DEFAULT: none
 DOC_START
@@ -4673,16 +4687,30 @@ DOC_START
 
 	This option replaces the old 'anonymize_headers' and the
 	older 'http_anonymizer' option with something that is much
-	more configurable. This new method creates a list of ACLs
-	for each header, allowing you very fine-tuned header
-	mangling.
-
-	This option only applies to request headers, i.e., from the
-	client to the server.
-
-	You can only specify known headers for the header name.
-	Other headers are reclassified as 'Other'. You can also
-	refer to all the headers with 'All'.
+	more configurable. A list of ACLs for each header name allows
+	removal of specific header fields under specific conditions.
+
+	This option only applies to outgoing HTTP request headers (i.e.,
+	headers sent by Squid to the next HTTP hop such as a cache peer
+	or an origin server). The option has no effect during cache hit
+	detection. The equivalent adaptation vectoring point in ICAP
+	terminology is post-cache REQMOD.
+
+	The option is applied to individual outgoing request header
+	fields. For each request header field F, Squid uses the first
+	qualifying sets of request_header_access rules:
+
+	    1. Rules with header_name equal to F's name.
+	    2. Rules with header_name 'Other', provided F's name is not
+	       on the hard-coded list of commonly used HTTP header names.
+	    3. Rules with header_name 'All'.
+
+	Within that qualifying rule set, rule ACLs are checked as usual.
+	If ACLs of an "allow" rule match, the header field is allowed to
+	go through as is. If ACLs of a "deny" rule match, the header is
+	removed and request_header_replace is then checked to identify
+	if the removed header has a replacement. If no rules within the
+	set have matching ACLs, the header field is left as is.
 
 	For example, to achieve the same behavior as the old
 	'http_anonymizer standard' option, you should use:
@@ -4733,7 +4761,7 @@ DOC_END
 
 NAME: reply_header_access
 IFDEF: USE_HTTP_VIOLATIONS
-TYPE: http_header_access[]
+TYPE: http_header_access
 LOC: Config.reply_header_access
 DEFAULT: none
 DOC_START
@@ -4747,17 +4775,8 @@ DOC_START
 	server to the client.
 
 	This is the same as request_header_access, but in the other
-	direction.
-
-	This option replaces the old 'anonymize_headers' and the
-	older 'http_anonymizer' option with something that is much
-	more configurable. This new method creates a list of ACLs
-	for each header, allowing you very fine-tuned header
-	mangling.
-
-	You can only specify known headers for the header name.
-	Other headers are reclassified as 'Other'. You can also
-	refer to all the headers with 'All'.
+	direction. Please see request_header_access for detailed
+	documentation.
 
 	For example, to achieve the same behavior as the old
 	'http_anonymizer standard' option, you should use:
@@ -4808,7 +4827,7 @@ DOC_END
 
 NAME: request_header_replace header_replace
 IFDEF: USE_HTTP_VIOLATIONS
-TYPE: http_header_replace[]
+TYPE: http_header_replace
 LOC: Config.request_header_access
 DEFAULT: none
 DOC_START
@@ -4827,7 +4846,7 @@ DOC_END
 
 NAME: reply_header_replace
 IFDEF: USE_HTTP_VIOLATIONS
-TYPE: http_header_replace[]
+TYPE: http_header_replace
 LOC: Config.reply_header_access
 DEFAULT: none
 DOC_START
@@ -4843,6 +4862,47 @@ DOC_START
         By default, headers are removed if denied.
 DOC_END
 
+NAME: request_header_add
+TYPE: HeaderWithAclList
+LOC: Config.request_header_add
+DEFAULT: none
+DOC_START
+	Usage:   request_header_add field-name field-value acl1 [acl2] ...
+	Example: request_header_add X-Client-CA "CA=%ssl::>cert_issuer" all
+
+	This option adds header fields to outgoing HTTP requests (i.e.,
+	request headers sent by Squid to the next HTTP hop such as a
+	cache peer or an origin server). The option has no effect during
+	cache hit detection. The equivalent adaptation vectoring point
+	in ICAP terminology is post-cache REQMOD.
+
+	Field-name is a token specifying an HTTP header name. If a
+	standard HTTP header name is used, Squid does not check whether
+	the new header conflicts with any existing headers or violates
+	HTTP rules. If the request to be modified already contains a
+	field with the same name, the old field is preserved but the
+	header field values are not merged.
+
+	Field-value is either a token or a quoted string. If quoted
+	string format is used, then the surrounding quotes are removed
+	while escape sequences and %macros are processed.
+
+	In theory, all of the logformat codes can be used as %macros.
+	However, unlike logging (which happens at the very end of
+	transaction lifetime), the transaction may not yet have enough
+	information to expand a macro when the new header value is needed.
+	And some information may already be available to Squid but not yet
+	committed where the macro expansion code can access it (report
+	such instances!). The macro will be expanded into a single dash
+	('-') in such cases. Not all macros have been tested.
+
+	One or more Squid ACLs may be specified to restrict header
+	injection to matching requests. As always in squid.conf, all
+	ACLs in an option ACL list must be satisfied for the insertion
+	to happen. The request_header_add option supports fast ACLs
+	only.
+DOC_END
+
 NAME: relaxed_header_parser
 COMMENT: on|off|warn
 TYPE: tristate
@@ -217,7 +217,7 @@ static void clientUpdateStatHistCounters(log_type logType, int svc_time);
 static void clientUpdateStatCounters(log_type logType);
 static void clientUpdateHierCounters(HierarchyLogEntry *);
 static bool clientPingHasFinished(ping_data const *aPing);
-void prepareLogWithRequestDetails(HttpRequest *, AccessLogEntry *);
+void prepareLogWithRequestDetails(HttpRequest *, AccessLogEntry::Pointer &);
 #ifndef PURIFY
 static bool connIsUsable(ConnStateData * conn);
 #endif
@@ -551,10 +551,10 @@ ClientHttpRequest::updateCounters()
 }
 
 void
-prepareLogWithRequestDetails(HttpRequest * request, AccessLogEntry * aLogEntry)
+prepareLogWithRequestDetails(HttpRequest * request, AccessLogEntry::Pointer &aLogEntry)
 {
     assert(request);
-    assert(aLogEntry);
+    assert(aLogEntry != NULL);
 
     if (Config.onoff.log_mime_hdrs) {
         Packer p;
@@ -625,76 +625,74 @@ ClientHttpRequest::logRequest()
     if (!out.size && !logType)
         debugs(33, 5, HERE << "logging half-baked transaction: " << log_uri);
 
-    al.icp.opcode = ICP_INVALID;
-    al.url = log_uri;
-    debugs(33, 9, "clientLogRequest: al.url='" << al.url << "'");
+    al->icp.opcode = ICP_INVALID;
+    al->url = log_uri;
+    debugs(33, 9, "clientLogRequest: al.url='" << al->url << "'");
 
-    if (al.reply) {
-        al.http.code = al.reply->sline.status;
-        al.http.content_type = al.reply->content_type.termedBuf();
+    if (al->reply) {
+        al->http.code = al->reply->sline.status;
+        al->http.content_type = al->reply->content_type.termedBuf();
     } else if (loggingEntry() && loggingEntry()->mem_obj) {
-        al.http.code = loggingEntry()->mem_obj->getReply()->sline.status;
-        al.http.content_type = loggingEntry()->mem_obj->getReply()->content_type.termedBuf();
+        al->http.code = loggingEntry()->mem_obj->getReply()->sline.status;
+        al->http.content_type = loggingEntry()->mem_obj->getReply()->content_type.termedBuf();
     }
 
-    debugs(33, 9, "clientLogRequest: http.code='" << al.http.code << "'");
+    debugs(33, 9, "clientLogRequest: http.code='" << al->http.code << "'");
 
     if (loggingEntry() && loggingEntry()->mem_obj)
-        al.cache.objectSize = loggingEntry()->contentLen();
+        al->cache.objectSize = loggingEntry()->contentLen();
 
-    al.cache.caddr.SetNoAddr();
+    al->cache.caddr.SetNoAddr();
 
     if (getConn() != NULL) {
-        al.cache.caddr = getConn()->log_addr;
-        al.cache.port =  cbdataReference(getConn()->port);
+        al->cache.caddr = getConn()->log_addr;
+        al->cache.port =  cbdataReference(getConn()->port);
     }
 
-    al.cache.requestSize = req_sz;
-    al.cache.requestHeadersSize = req_sz;
+    al->cache.requestSize = req_sz;
+    al->cache.requestHeadersSize = req_sz;
 
-    al.cache.replySize = out.size;
-    al.cache.replyHeadersSize = out.headers_sz;
+    al->cache.replySize = out.size;
+    al->cache.replyHeadersSize = out.headers_sz;
 
-    al.cache.highOffset = out.offset;
+    al->cache.highOffset = out.offset;
 
-    al.cache.code = logType;
+    al->cache.code = logType;
 
-    al.cache.msec = tvSubMsec(start_time, current_time);
+    al->cache.msec = tvSubMsec(start_time, current_time);
 
     if (request)
-        prepareLogWithRequestDetails(request, &al);
+        prepareLogWithRequestDetails(request, al);
 
     if (getConn() != NULL && getConn()->clientConnection != NULL && getConn()->clientConnection->rfc931[0])
-        al.cache.rfc931 = getConn()->clientConnection->rfc931;
+        al->cache.rfc931 = getConn()->clientConnection->rfc931;
 
 #if USE_SSL && 0
 
     /* This is broken. Fails if the connection has been closed. Needs
      * to snarf the ssl details some place earlier..
      */
     if (getConn() != NULL)
-        al.cache.ssluser = sslGetUserEmail(fd_table[getConn()->fd].ssl);
+        al->cache.ssluser = sslGetUserEmail(fd_table[getConn()->fd].ssl);
 
 #endif
 
     ACLFilledChecklist *checklist = clientAclChecklistCreate(Config.accessList.log, this);
 
-    if (al.reply)
-        checklist->reply = HTTPMSGLOCK(al.reply);
+    if (al->reply)
+        checklist->reply = HTTPMSGLOCK(al->reply);
 
     if (!Config.accessList.log || checklist->fastCheck() == ACCESS_ALLOWED) {
         if (request)
-            al.adapted_request = HTTPMSGLOCK(request);
-        accessLogLog(&al, checklist);
+            al->adapted_request = HTTPMSGLOCK(request);
+        accessLogLog(al, checklist);
         updateCounters();
 
         if (getConn() != NULL && getConn()->clientConnection != NULL)
             clientdbUpdate(getConn()->clientConnection->remote, logType, AnyP::PROTO_HTTP, out.size);
     }
 
     delete checklist;
-
-    accessLogFreeMemory(&al);
 }
 
 void
@@ -1008,7 +1006,7 @@ ClientSocketContext::packChunk(const StoreIOBuffer &bodyData, MemBuf &mb)
         static_cast<uint64_t>(lengthToSend(bodyData.range()));
     noteSentBodyBytes(length);
 
-    mb.Printf("%"PRIX64"\r\n", length);
+    mb.Printf("%" PRIX64 "\r\n", length);
     mb.append(bodyData.data, length);
     mb.Printf("\r\n");
 }
@@ -1448,7 +1446,7 @@ clientSocketRecipient(clientStreamNode * node, ClientHttpRequest * http,
         context->sendBody(rep, receivedData);
     else {
         assert(rep);
-        http->al.reply = HTTPMSGLOCK(rep);
+        http->al->reply = HTTPMSGLOCK(rep);
         context->sendStartOfMessage(rep, receivedData);
     }
 
@@ -1794,9 +1792,9 @@ ClientSocketContext::noteIoError(const int xerrno)
 {
     if (http) {
         if (xerrno == ETIMEDOUT)
-            http->al.http.timedout = true;
+            http->al->http.timedout = true;
         else // even if xerrno is zero (which means read abort/eof)
-            http->al.http.aborted = true;
+            http->al->http.aborted = true;
     }
 }
 
@@ -2484,8 +2482,8 @@ bool ConnStateData::serveDelayedError(ClientSocketContext *context)
         repContext->setReplyToStoreEntry(sslServerBump->entry);
 
         // save the original request for logging purposes
-        if (!context->http->al.request)
-            context->http->al.request = HTTPMSGLOCK(http->request);
+        if (!context->http->al->request)
+            context->http->al->request = HTTPMSGLOCK(http->request);
 
         // Get error details from the fake certificate-peeking request.
         http->request->detailError(sslServerBump->request->errType, sslServerBump->request->errDetail);
@@ -2530,8 +2528,8 @@ bool ConnStateData::serveDelayedError(ClientSocketContext *context)
                     sslServerBump->serverCert.get(), NULL);
                 err->detail = errDetail;
                 // Save the original request for logging purposes.
-                if (!context->http->al.request)
-                    context->http->al.request = HTTPMSGLOCK(request);
+                if (!context->http->al->request)
+                    context->http->al->request = HTTPMSGLOCK(request);
                 repContext->setReplyToError(request->method, err);
                 assert(context->http->out.offset == 0);
                 context->pullData();
@@ -2636,6 +2634,7 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
     }
 
     request->clientConnectionManager = conn;
+    request->al = http->al;
 
     request->flags.accelerated = http->flags.accel;
     request->flags.sslBumped = conn->switchedToHttps();
@@ -3250,7 +3249,7 @@ clientLifetimeTimeout(const CommTimeoutCbParams &io)
     ClientHttpRequest *http = static_cast<ClientHttpRequest *>(io.data);
     debugs(33, DBG_IMPORTANT, "WARNING: Closing client connection due to lifetime timeout");
     debugs(33, DBG_IMPORTANT, "\t" << http->uri);
-    http->al.http.timedout = true;
+    http->al->http.timedout = true;
     if (Comm::IsConnOpen(io.conn))
         io.conn->close();
 }
@@ -125,7 +125,7 @@ void clientReplyContext::setReplyToError(const HttpRequestMethod& method, ErrorS
         /* prevent confusion over whether we default to persistent or not */
         http->request->flags.proxy_keepalive = 0;
 
-    http->al.http.code = errstate->httpStatus;
+    http->al->http.code = errstate->httpStatus;
 
     createStoreEntry(method, request_flags());
     assert(errstate->callback_data == NULL);
@@ -651,7 +651,7 @@ clientReplyContext::processMiss()
     /// Deny loops for accelerator and interceptor. TODO: deny in all modes?
     if (r->flags.loopdetect &&
             (http->flags.accel || http->flags.intercepted)) {
-        http->al.http.code = HTTP_FORBIDDEN;
+        http->al->http.code = HTTP_FORBIDDEN;
         err = clientBuildError(ERR_ACCESS_DENIED, HTTP_FORBIDDEN, NULL, http->getConn()->clientConnection->remote, http->request);
         createStoreEntry(r->method, request_flags());
         errorAppendEntry(http->storeEntry(), err);
@@ -695,7 +695,7 @@ clientReplyContext::processOnlyIfCachedMiss()
 {
     debugs(88, 4, "clientProcessOnlyIfCachedMiss: '" <<
            RequestMethodStr(http->request->method) << " " << http->uri << "'");
-    http->al.http.code = HTTP_GATEWAY_TIMEOUT;
+    http->al->http.code = HTTP_GATEWAY_TIMEOUT;
     ErrorState *err = clientBuildError(ERR_ONLY_IF_CACHED_MISS, HTTP_GATEWAY_TIMEOUT, NULL,
                                        http->getConn()->clientConnection->remote, http->request);
     removeClientStoreReference(&sc, http);
@@ -1452,6 +1452,7 @@ clientReplyContext::buildReplyHeader()
 #endif
 
     const bool maySendChunkedReply = !request->multipartRangeRequest() &&
+                                     reply->sline.protocol == AnyP::PROTO_HTTP && // response is HTTP
                                      (request->http_ver >= HttpVersion(1, 1));
 
     /* Check whether we should send keep-alive */
@@ -2143,9 +2144,9 @@ clientReplyContext::sendMoreData (StoreIOBuffer result)
         size_t k;
 
         if ((k = headersEnd(buf, reqofs))) {
-            safe_free(http->al.headers.reply);
-            http->al.headers.reply = (char *)xcalloc(k + 1, 1);
-            xstrncpy(http->al.headers.reply, buf, k);
+            safe_free(http->al->headers.reply);
+            http->al->headers.reply = (char *)xcalloc(k + 1, 1);
+            xstrncpy(http->al->headers.reply, buf, k);
         }
     }
 
@@ -181,7 +181,14 @@ ClientHttpRequest::ClientHttpRequest(ConnStateData * aConn) :
 {
     start_time = current_time;
     setConn(aConn);
-    al.tcpClient = clientConnection = aConn->clientConnection;
+    al = new AccessLogEntry;
+    al->tcpClient = clientConnection = aConn->clientConnection;
+#if USE_SSL
+    if (aConn->clientConnection != NULL && aConn->clientConnection->isOpen()) {
+        if (SSL *ssl = fd_table[aConn->clientConnection->fd].ssl)
+            al->cache.sslClientCert.reset(SSL_get_peer_certificate(ssl));
+    }
+#endif
     dlinkAdd(this, &active, &ClientActiveRequests);
 #if USE_ADAPTATION
     request_satisfaction_mode = false;
@@ -285,7 +292,7 @@ ClientHttpRequest::~ClientHttpRequest()
     loggingEntry(NULL);
 
     if (request)
-        checkFailureRatio(request->errType, al.hier.code);
+        checkFailureRatio(request->errType, al->hier.code);
 
     freeResources();
 
@@ -1282,7 +1289,7 @@ ClientRequestContext::sslBumpAccessCheck()
     if (bumpMode != Ssl::bumpEnd) {
         debugs(85, 5, HERE << "SslBump already decided (" << bumpMode <<
                "), " << "ignoring ssl_bump for " << http->getConn());
-        http->al.ssl.bumpMode = bumpMode; // inherited from bumped connection
+        http->al->ssl.bumpMode = bumpMode; // inherited from bumped connection
         return false;
     }
 
@@ -1293,15 +1300,15 @@ ClientRequestContext::sslBumpAccessCheck()
     // We also do not bump redirected CONNECT requests.
     if (http->request->method != METHOD_CONNECT || http->redirect.status ||
         !Config.accessList.ssl_bump || !http->getConn()->port->sslBump) {
-        http->al.ssl.bumpMode = Ssl::bumpEnd; // SslBump does not apply; log -
+        http->al->ssl.bumpMode = Ssl::bumpEnd; // SslBump does not apply; log -
         debugs(85, 5, HERE << "cannot SslBump this request");
         return false;
     }
 
     // Do not bump during authentication: clients would not proxy-authenticate
     // if we delay a 407 response and respond with 200 OK to CONNECT.
     if (error && error->httpStatus == HTTP_PROXY_AUTHENTICATION_REQUIRED) {
-        http->al.ssl.bumpMode = Ssl::bumpEnd; // SslBump does not apply; log -
+        http->al->ssl.bumpMode = Ssl::bumpEnd; // SslBump does not apply; log -
         debugs(85, 5, HERE << "no SslBump during proxy authentication");
         return false;
     }
@@ -1336,7 +1343,7 @@ ClientRequestContext::sslBumpAccessCheckDone(const allow_t &answer)
     const Ssl::BumpMode bumpMode = answer == ACCESS_ALLOWED ?
         static_cast<Ssl::BumpMode>(answer.kind) : Ssl::bumpNone;
     http->sslBumpNeed(bumpMode); // for processRequest() to bump if needed
-    http->al.ssl.bumpMode = bumpMode; // for logging
+    http->al->ssl.bumpMode = bumpMode; // for logging
 
     http->doCallouts();
 }
@@ -1361,7 +1368,7 @@ ClientHttpRequest::processRequest()
 #endif
         logType = LOG_TCP_MISS;
         getConn()->stopReading(); // tunnels read for themselves
-        tunnelStart(this, &out.size, &al.http.code);
+        tunnelStart(this, &out.size, &al->http.code);
         return;
     }
 
@@ -1418,7 +1425,7 @@ ClientHttpRequest::sslBumpEstablish(comm_err_t errflag)
 
     // We lack HttpReply which logRequest() uses to log the status code.
     // TODO: Use HttpReply instead of the "200 Connection established" string.
-    al.http.code = 200;
+    al->http.code = 200;
 
 #if USE_AUTH
     // Preserve authentication info for the ssl-bumped request
@@ -1520,8 +1527,8 @@ ClientHttpRequest::doCallouts()
     assert(calloutContext);
 
     /*Save the original request for logging purposes*/
-    if (!calloutContext->http->al.request)
-        calloutContext->http->al.request = HTTPMSGLOCK(request);
+    if (!calloutContext->http->al->request)
+        calloutContext->http->al->request = HTTPMSGLOCK(request);
 
     if (!calloutContext->error) {
     // CVE-2009-0801: verify the Host: header is consistent with other known details.
@@ -116,7 +116,7 @@ class ClientHttpRequest
     log_type logType;
 
     struct timeval start_time;
-    AccessLogEntry al;
+    AccessLogEntry::Pointer al; ///< access.log entry
 
     struct {
         unsigned int accel:1;
@@ -1090,7 +1090,11 @@ _comm_close(int fd, char const *file, int line)
         return;
 
     /* The following fails because ipc.c is doing calls to pipe() to create sockets! */
-    assert(isOpen(fd));
+    if (!isOpen(fd)) {
+        debugs(50, DBG_IMPORTANT, HERE << "BUG 3556: FD " << fd << " is not an open socket.");
+        // XXX: do we need to run close(fd) or fd_close(fd) here?
+        return;
+    }
 
     assert(F->type != FD_FILE);
 
@@ -14,15 +14,15 @@ Comm::AcceptLimiter &Comm::AcceptLimiter::Instance()
 void
 Comm::AcceptLimiter::defer(Comm::TcpAcceptor *afd)
 {
-    afd->isLimited++;
+    ++afd->isLimited;
     debugs(5, 5, HERE << afd->conn << " x" << afd->isLimited);
     deferred.push_back(afd);
 }
 
 void
 Comm::AcceptLimiter::removeDead(const Comm::TcpAcceptor *afd)
 {
-    for (unsigned int i = 0; i < deferred.size() && afd->isLimited > 0; i++) {
+    for (unsigned int i = 0; i < deferred.size() && afd->isLimited > 0; ++i) {
         if (deferred[i] == afd) {
             deferred[i]->isLimited--;
             deferred[i] = NULL; // fast. kick() will skip empty entries later.
@@ -131,6 +131,7 @@ Comm::ConnOpener::doneConnecting(comm_err_t status, int xerrno)
     }
 
     if (temporaryFd_ >= 0) {
+        debugs(5, 4, HERE << conn_ << " closing temp FD " << temporaryFd_);
         // it never reached fully open, so cleanup the FD handlers
         // Note that comm_close() sequence does not happen for partially open FD
         Comm::SetSelect(temporaryFd_, COMM_SELECT_WRITE, NULL, NULL, 0);
@@ -141,6 +142,7 @@ Comm::ConnOpener::doneConnecting(comm_err_t status, int xerrno)
         }
         fd_table[temporaryFd_].timeoutHandler = NULL;
         fd_table[temporaryFd_].timeout = 0;
+        close(temporaryFd_);
         fd_close(temporaryFd_);
         temporaryFd_ = -1;
     }
@@ -202,8 +204,8 @@ Comm::ConnOpener::connected()
      * based on the max-conn option.  We need to increment here,
      * even if the connection may fail.
      */
-    if (conn_->getPeer())
-        conn_->getPeer()->stats.conn_open++;
+    if (peer *peer=(conn_->getPeer()))
+        ++peer->stats.conn_open;
 
     lookupLocalAddress();
 
@@ -14,7 +14,7 @@ Comm::CallbackTableInit()
 {
     // XXX: convert this to a std::map<> ?
     iocb_table = static_cast<CbEntry*>(xcalloc(Squid_MaxFD, sizeof(CbEntry)));
-    for (int pos = 0; pos < Squid_MaxFD; pos++) {
+    for (int pos = 0; pos < Squid_MaxFD; ++pos) {
         iocb_table[pos].fd = pos;
         iocb_table[pos].readcb.type = IOCB_READ;
         iocb_table[pos].writecb.type = IOCB_WRITE;
@@ -25,7 +25,7 @@ void
 Comm::CallbackTableDestruct()
 {
     // release any Comm::Connections being held.
-    for (int pos = 0; pos < Squid_MaxFD; pos++) {
+    for (int pos = 0; pos < Squid_MaxFD; ++pos) {
         iocb_table[pos].readcb.conn = NULL;
         iocb_table[pos].writecb.conn = NULL;
     }
@@ -165,7 +165,7 @@ comm_update_fd(int fd, int events)
         comm_flush_updates();
 
     /* Push new event onto array */
-    devpoll_update.cur++;
+    ++devpoll_update.cur;
     devpoll_update.pfds[devpoll_update.cur].fd = fd;
     devpoll_update.pfds[devpoll_update.cur].events = events;
     devpoll_update.pfds[devpoll_update.cur].revents = 0;
@@ -385,7 +385,7 @@ Comm::DoSelect(int msec)
 
     PROF_start(comm_handle_ready_fd);
 
-    for (i = 0; i < num; i++) {
+    for (i = 0; i < num; ++i) {
         int fd = (int)do_poll.dp_fds[i].fd;
         F = &fd_table[fd];
         debugs(
@@ -421,7 +421,7 @@ Comm::DoSelect(int msec)
                 F->read_handler = NULL;
                 hdl(fd, F->read_data);
                 PROF_stop(comm_read_handler);
-                statCounter.select_fds++;
+                ++statCounter.select_fds;
             } else {
                 debugs(
                     5,
@@ -445,7 +445,7 @@ Comm::DoSelect(int msec)
                 F->write_handler = NULL;
                 hdl(fd, F->write_data);
                 PROF_stop(comm_write_handler);
-                statCounter.select_fds++;
+                ++statCounter.select_fds;
             } else {
                 debugs(
                     5,
@@ -283,7 +283,7 @@ Comm::DoSelect(int msec)
 
     PROF_start(comm_handle_ready_fd);
 
-    for (i = 0, cevents = pevents; i < num; i++, cevents++) {
+    for (i = 0, cevents = pevents; i < num; ++i, ++cevents) {
         fd = cevents->data.fd;
         F = &fd_table[fd];
         debugs(5, DEBUG_EPOLL ? 0 : 8, HERE << "got FD " << fd << " events=" <<
@@ -300,7 +300,7 @@ Comm::DoSelect(int msec)
                 F->read_handler = NULL;
                 hdl(fd, F->read_data);
                 PROF_stop(comm_write_handler);
-                statCounter.select_fds++;
+                ++statCounter.select_fds;
             } else {
                 debugs(5, DEBUG_EPOLL ? 0 : 8, HERE << "no read handler for FD " << fd);
                 // remove interest since no handler exist for this event.
@@ -315,7 +315,7 @@ Comm::DoSelect(int msec)
                 F->write_handler = NULL;
                 hdl(fd, F->write_data);
                 PROF_stop(comm_read_handler);
-                statCounter.select_fds++;
+                ++statCounter.select_fds;
             } else {
                 debugs(5, DEBUG_EPOLL ? 0 : 8, HERE << "no write handler for FD " << fd);
                 // remove interest since no handler exist for this event.
@@ -148,7 +148,7 @@ kq_update_events(int fd, short filter, PF * handler)
 
             kqoff = 0;
         } else {
-            kqoff++;
+            ++kqoff;
         }
     }
 }
@@ -282,7 +282,7 @@ Comm::DoSelect(int msec)
     if (num == 0)
         return COMM_OK;		/* No error.. */
 
-    for (i = 0; i < num; i++) {
+    for (i = 0; i < num; ++i) {
         int fd = (int) ke[i].ident;
         PF *hdl = NULL;
         fde *F = &fd_table[fd];
@@ -231,7 +231,7 @@ comm_check_incoming_poll_handlers(int nfds, int *fds)
             pfds[npfds].fd = fd;
             pfds[npfds].events = events;
             pfds[npfds].revents = 0;
-            npfds++;
+            ++npfds;
         }
     }
 
@@ -241,14 +241,14 @@ comm_check_incoming_poll_handlers(int nfds, int *fds)
     }
 
     getCurrentTime();
-    statCounter.syscalls.selects++;
+    ++statCounter.syscalls.selects;
 
     if (poll(pfds, npfds, 0) < 1) {
         PROF_stop(comm_check_incoming);
         return incoming_sockets_accepted;
     }
 
-    for (i = 0; i < npfds; i++) {
+    for (i = 0; i < npfds; ++i) {
         int revents;
 
         if (((revents = pfds[i].revents) == 0) || ((fd = pfds[i].fd) == -1))
@@ -396,10 +396,10 @@ Comm::DoSelect(int msec)
                 pfds[nfds].fd = i;
                 pfds[nfds].events = events;
                 pfds[nfds].revents = 0;
-                nfds++;
+                ++nfds;
 
                 if ((events & POLLRDNORM) && fd_table[i].flags.read_pending)
-                    npending++;
+                    ++npending;
             }
         }
 
@@ -498,7 +498,7 @@ Comm::DoSelect(int msec)
                     F->flags.read_pending = 0;
                     hdl(fd, F->read_data);
                     PROF_stop(comm_read_handler);
-                    statCounter.select_fds++;
+                    ++statCounter.select_fds;
 
                     if (commCheckUdpIncoming)
                         comm_poll_udp_incoming();
@@ -519,7 +519,7 @@ Comm::DoSelect(int msec)
                     F->write_handler = NULL;
                     hdl(fd, F->write_data);
                     PROF_stop(comm_write_handler);
-                    statCounter.select_fds++;
+                    ++statCounter.select_fds;
 
                     if (commCheckUdpIncoming)
                         comm_poll_udp_incoming();
@@ -238,12 +238,12 @@ comm_check_incoming_select_handlers(int nfds, int *fds)
 
     getCurrentTime();
 
-    statCounter.syscalls.selects++;
+    ++statCounter.syscalls.selects;
 
     if (select(maxfd, &read_mask, &write_mask, NULL, &zero_tv) < 1)
         return incoming_sockets_accepted;
 
-    for (i = 0; i < nfds; i++) {
+    for (i = 0; i < nfds; ++i) {
         fd = fds[i];
 
         if (FD_ISSET(fd, &read_mask)) {
@@ -967,6 +967,7 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
     case 'R':
         if (building_deny_info_url) {
             p = (request->urlpath.size() != 0 ? request->urlpath.termedBuf() : "/");
+            no_urlescape = 1;
             break;
         }
         if (NULL != request) {
@@ -56,11 +56,11 @@ fde::dumpStats (StoreEntry &dumpEntry, int fdNumber)
 
 #if _SQUID_MSWIN_
 
-    storeAppendPrintf(&dumpEntry, "%4d 0x%-8lX %-6.6s %4d %7"PRId64"%c %7"PRId64"%c %-21s %s\n",
+    storeAppendPrintf(&dumpEntry, "%4d 0x%-8lX %-6.6s %4d %7" PRId64 "%c %7" PRId64 "%c %-21s %s\n",
                       fdNumber,
                       win32.handle,
 #else
-    storeAppendPrintf(&dumpEntry, "%4d %-6.6s %4d %7"PRId64"%c %7"PRId64"%c %-21s %s\n",
+    storeAppendPrintf(&dumpEntry, "%4d %-6.6s %4d %7" PRId64 "%c %7" PRId64 "%c %-21s %s\n",
                       fdNumber,
 #endif
                       fdTypeStr[type],
@@ -192,6 +192,8 @@ typedef enum {
 
 #if USE_SSL
     LFT_SSL_BUMP_MODE,
+    LFT_SSL_USER_CERT_SUBJECT,
+    LFT_SSL_USER_CERT_ISSUER,
 #endif
 
     LFT_PERCENT			/* special string cases for escaped chars */
@@ -3,6 +3,7 @@
 #include "comm/Connection.h"
 #include "err_detail_type.h"
 #include "errorpage.h"
+#include "fde.h"
 #include "format/Format.h"
 #include "format/Quoting.h"
 #include "format/Token.h"
@@ -43,9 +44,9 @@ Format::Format::~Format()
 }
 
 bool
-Format::Format::parse(char *def)
+Format::Format::parse(const char *def)
 {
-    char *cur, *eos;
+    const char *cur, *eos;
     Token *new_lt, *last_lt;
     enum Quoting quote = LOG_QUOTE_NONE;
 
@@ -290,7 +291,7 @@ log_quoted_string(const char *str, char *out)
 }
 
 void
-Format::Format::assemble(MemBuf &mb, AccessLogEntry *al, int logSequenceNumber) const
+Format::Format::assemble(MemBuf &mb, const AccessLogEntry::Pointer &al, int logSequenceNumber) const
 {
     char tmp[1024];
     String sb;
@@ -1011,6 +1012,24 @@ Format::Format::assemble(MemBuf &mb, AccessLogEntry *al, int logSequenceNumber)
             out = Ssl::bumpMode(mode);
             break;
         }
+
+        case LFT_SSL_USER_CERT_SUBJECT:
+            if (X509 *cert = al->cache.sslClientCert.get()) {
+                if (X509_NAME *subject = X509_get_subject_name(cert)) {
+                    X509_NAME_oneline(subject, tmp, sizeof(tmp));
+                    out = tmp;
+                }
+            }
+            break;
+
+        case LFT_SSL_USER_CERT_ISSUER:
+            if (X509 *cert = al->cache.sslClientCert.get()) {
+                if (X509_NAME *issuer = X509_get_issuer_name(cert)) {
+                    X509_NAME_oneline(issuer, tmp, sizeof(tmp));
+                    out = tmp;
+                }
+            }
+            break;
 #endif
 
         case LFT_PERCENT:
@@ -1,6 +1,7 @@
 #ifndef _SQUID_FORMAT_FORMAT_H
 #define _SQUID_FORMAT_FORMAT_H
 
+#include "RefCount.h"
 /*
  * Squid configuration allows users to define custom formats in
  * several components.
@@ -14,6 +15,7 @@
  */
 
 class AccessLogEntry;
+typedef RefCount<AccessLogEntry> AccessLogEntryPointer;
 class MemBuf;
 class StoreEntry;
 
@@ -33,10 +35,10 @@ class Format
     /* First off, let's tokenize, we'll optimize in a second pass.
      * A token can either be a %-prefixed sequence (usually a dynamic
      * token but it can be an escaped sequence), or a string. */
-    bool parse(char *def);
+    bool parse(const char *def);
 
     /// assemble the state information into a formatted line.
-    void assemble(MemBuf &mb, AccessLogEntry *al, int logSequenceNumber) const;
+    void assemble(MemBuf &mb, const AccessLogEntryPointer &al, int logSequenceNumber) const;
 
     /// dump this whole list of formats into the provided StoreEntry
     void dump(StoreEntry * entry, const char *name);
@@ -190,6 +190,8 @@ static TokenTableEntry TokenTableIcap[] = {
 // SSL (ssl::) tokens
 static TokenTableEntry TokenTableSsl[] = {
     {"bump_mode", LFT_SSL_BUMP_MODE},
+    {">cert_subject", LFT_SSL_USER_CERT_SUBJECT},
+    {">cert_issuer", LFT_SSL_USER_CERT_ISSUER},
     {NULL, LFT_NONE}
 };
 #endif
@@ -215,8 +217,8 @@ Format::Token::Init()
 
 /// Scans a token table to see if the next token exists there
 /// returns a pointer to next unparsed byte and updates type member if found
-char *
-Format::Token::scanForToken(TokenTableEntry const table[], char *cur)
+const char *
+Format::Token::scanForToken(TokenTableEntry const table[], const char *cur)
 {
     for (TokenTableEntry const *lte = table; lte->configTag != NULL; lte++) {
         debugs(46, 8, HERE << "compare tokens '" << lte->configTag << "' with '" << cur << "'");
@@ -235,9 +237,9 @@ Format::Token::scanForToken(TokenTableEntry const table[], char *cur)
  * def is for sure null-terminated
  */
 int
-Format::Token::parse(char *def, Quoting *quoting)
+Format::Token::parse(const char *def, Quoting *quoting)
 {
-    char *cur = def;
+    const char *cur = def;
 
     int l;
 
@@ -326,11 +328,16 @@ Format::Token::parse(char *def, Quoting *quoting)
         cur++;
     }
 
-    if (xisdigit(*cur))
-        widthMin = strtol(cur, &cur, 10);
+    char *endp;
+    if (xisdigit(*cur)) {
+        widthMin = strtol(cur, &endp, 10);
+        cur = endp;
+    }
 
-    if (*cur == '.' && xisdigit(*(++cur)))
-        widthMax = strtol(cur, &cur, 10);
+    if (*cur == '.' && xisdigit(*(++cur))) {
+        widthMax = strtol(cur, &endp, 10);
+        cur = endp;
+    }
 
     if (*cur == '{') {
         char *cp;
@@ -48,7 +48,7 @@ class Token
      * and fills in this item with the token information.
      * def is for sure null-terminated.
      */
-    int parse(char *def, enum Quoting *quote);
+    int parse(const char *def, enum Quoting *quote);
 
     ByteCode_t type;
     const char *label;
@@ -72,7 +72,7 @@ class Token
     Token *next;	/* todo: move from linked list to array */
 
 private:
-    char *scanForToken(TokenTableEntry const table[], char *cur);
+    const char *scanForToken(TokenTableEntry const table[], const char *cur);
 };
 
 extern const char *log_tags[];
@@ -86,6 +86,11 @@ FwdState::abort(void* d)
 
     if (Comm::IsConnOpen(fwd->serverConnection())) {
         comm_remove_close_handler(fwd->serverConnection()->fd, fwdServerClosedWrapper, fwd);
+        debugs(17, 3, HERE << "store entry aborted; closing " <<
+               fwd->serverConnection());
+        fwd->serverConnection()->close();
+    } else {
+        debugs(17, 7, HERE << "store entry aborted; no connection to close");
     }
     fwd->serverDestinations.clean();
     fwd->self = NULL;
@@ -503,16 +508,16 @@ FwdState::checkRetry()
     if (flags.dont_retry)
         return false;
 
+    if (request->bodyNibbled())
+        return false;
+
     // NP: not yet actually connected anywhere. retry is safe.
     if (!flags.connected_okay)
         return true;
 
     if (!checkRetriable())
         return false;
 
-    if (request->bodyNibbled())
-        return false;
-
     return true;
 }
 
@@ -828,6 +833,7 @@ FwdState::connectDone(const Comm::ConnectionPointer &conn, comm_err_t status, in
     }
 
     serverConn = conn;
+    flags.connected_okay = true;
 
     debugs(17, 3, HERE << serverConnection() << ": '" << entry->url() << "'" );
 
@@ -857,7 +863,6 @@ FwdState::connectDone(const Comm::ConnectionPointer &conn, comm_err_t status, in
     }
 #endif
 
-    flags.connected_okay = true;
     dispatch();
 }
 
@@ -934,6 +939,7 @@ FwdState::connectStart()
         else
             serverConn = NULL;
         if (Comm::IsConnOpen(serverConn)) {
+            flags.connected_okay = true;
 #if 0
             if (!serverConn->getPeer())
                 serverConn->peerType = HIER_DIRECT;
@@ -981,6 +987,7 @@ FwdState::connectStart()
     // if we found an open persistent connection to use. use it.
     if (openedPconn) {
         serverConn = temp;
+        flags.connected_okay = true;
         debugs(17, 3, HERE << "reusing pconn " << serverConnection());
         n_tries++;
 
@@ -973,7 +973,7 @@ void
 CossSwapDir::statfs(StoreEntry & sentry) const
 {
     storeAppendPrintf(&sentry, "\n");
-    storeAppendPrintf(&sentry, "Maximum Size: %"PRIu64" KB\n", maxSize() >> 10);
+    storeAppendPrintf(&sentry, "Maximum Size: %" PRIu64 " KB\n", maxSize() >> 10);
     storeAppendPrintf(&sentry, "Current Size: %.2f KB\n", currentSize() / 1024.0);
     storeAppendPrintf(&sentry, "Percent Used: %0.2f%%\n",
                       Math::doublePercent(currentSize(), maxSize()) );
@@ -1066,7 +1066,7 @@ CossSwapDir::swappedOut(const StoreEntry &e)
 void
 CossSwapDir::dump(StoreEntry &entry)const
 {
-    storeAppendPrintf(&entry, " %"PRIu64, maxSize() >> 20);
+    storeAppendPrintf(&entry, " %" PRIu64, maxSize() >> 20);
     dumpOptions(&entry);
 }
 
@@ -351,7 +351,7 @@ void
 Rock::SwapDir::dumpTimeOption(StoreEntry * e) const
 {
     if (fileConfig.ioTimeout)
-        storeAppendPrintf(e, " swap-timeout=%"PRId64,
+        storeAppendPrintf(e, " swap-timeout=%" PRId64,
                           static_cast<int64_t>(fileConfig.ioTimeout));
 }
 
@@ -786,7 +786,7 @@ void
 Rock::SwapDir::statfs(StoreEntry &e) const
 {
     storeAppendPrintf(&e, "\n");
-    storeAppendPrintf(&e, "Maximum Size: %"PRIu64" KB\n", maxSize() >> 10);
+    storeAppendPrintf(&e, "Maximum Size: %" PRIu64 " KB\n", maxSize() >> 10);
     storeAppendPrintf(&e, "Current Size: %.2f KB %.2f%%\n",
                       currentSize() / 1024.0,
                       Math::doublePercent(currentSize(), maxSize()));
@@ -318,7 +318,7 @@ UFSSwapDir::statfs(StoreEntry & sentry) const
     int x;
     storeAppendPrintf(&sentry, "First level subdirectories: %d\n", l1);
     storeAppendPrintf(&sentry, "Second level subdirectories: %d\n", l2);
-    storeAppendPrintf(&sentry, "Maximum Size: %"PRIu64" KB\n", maxSize() >> 10);
+    storeAppendPrintf(&sentry, "Maximum Size: %" PRIu64 " KB\n", maxSize() >> 10);
     storeAppendPrintf(&sentry, "Current Size: %.2f KB\n", currentSize() / 1024.0);
     storeAppendPrintf(&sentry, "Percent Used: %0.2f%%\n",
                       Math::doublePercent(currentSize(), maxSize()));
@@ -1347,7 +1347,7 @@ UFSSwapDir::replacementRemove(StoreEntry * e)
 void
 UFSSwapDir::dump(StoreEntry & entry) const
 {
-    storeAppendPrintf(&entry, " %"PRIu64" %d %d", maxSize() >> 20, l1, l2);
+    storeAppendPrintf(&entry, " %" PRIu64 " %d %d", maxSize() >> 20, l1, l2);
     dumpOptions(&entry);
 }
 
@@ -1060,7 +1060,7 @@ FtpStateData::htmlifyListEntry(const char *line)
         snprintf(icon, 2048, "<img border=\"0\" src=\"%s\" alt=\"%-6s\">",
                  mimeGetIconURL(parts->name),
                  "[FILE]");
-        snprintf(size, 2048, " %6"PRId64"k", parts->size);
+        snprintf(size, 2048, " %6" PRId64 "k", parts->size);
         break;
     }
 
@@ -3096,7 +3096,7 @@ ftpSendRest(FtpStateData * ftpState)
 
     debugs(9, 3, HERE);
 
-    snprintf(cbuf, CTRL_BUFLEN, "REST %"PRId64"\r\n", ftpState->restart_offset);
+    snprintf(cbuf, CTRL_BUFLEN, "REST %" PRId64 "\r\n", ftpState->restart_offset);
     ftpState->writeCommand(cbuf);
     ftpState->state = SENT_REST;
 }
@@ -1717,15 +1717,15 @@ htcpClosePorts(void)
 static void
 htcpLogHtcp(Ip::Address &caddr, int opcode, log_type logcode, const char *url)
 {
-    AccessLogEntry al;
+    AccessLogEntry::Pointer al = new AccessLogEntry;
     if (LOG_TAG_NONE == logcode)
         return;
     if (!Config.onoff.log_udp)
         return;
-    al.htcp.opcode = htcpOpcodeStr[opcode];
-    al.url = url;
-    al.cache.caddr = caddr;
-    al.cache.code = logcode;
-    al.cache.msec = 0;
-    accessLogLog(&al, NULL);
+    al->htcp.opcode = htcpOpcodeStr[opcode];
+    al->url = url;
+    al->cache.caddr = caddr;
+    al->cache.code = logcode;
+    al->cache.msec = 0;
+    accessLogLog(al, NULL);
 }
@@ -88,6 +88,8 @@ static const char *const crlf = "\r\n";
 static void httpMaybeRemovePublic(StoreEntry *, http_status);
 static void copyOneHeaderFromClientsideRequestToUpstreamRequest(const HttpHeaderEntry *e, const String strConnection, const HttpRequest * request,
         HttpHeader * hdr_out, const int we_do_ranges, const http_state_flags);
+//Declared in HttpHeaderTools.cc
+void httpHdrAdd(HttpHeader *heads, HttpRequest *request, HeaderWithAclList &headers_add);
 
 HttpStateData::HttpStateData(FwdState *theFwdState) : AsyncJob("HttpStateData"), ServerStateData(theFwdState),
         lastChunk(0), header_bytes_read(0), reply_bytes_read(0),
@@ -1067,7 +1069,7 @@ HttpStateData::readReply(const CommIoCbParams &io)
     }
 
     if (EBIT_TEST(entry->flags, ENTRY_ABORTED)) {
-        // TODO: should we call abortTransaction() here?
+        abortTransaction("store entry aborted while reading reply");
         return;
     }
 
@@ -1346,12 +1348,9 @@ HttpStateData::processReplyBody()
     }
 
     if (EBIT_TEST(entry->flags, ENTRY_ABORTED)) {
-        /*
-         * The above writeReplyBody() call could ABORT this entry,
-         * in that case, the server FD should already be closed.
-         * there's nothing for us to do.
-         */
-        (void) 0;
+        // The above writeReplyBody() call may have aborted the store entry.
+        abortTransaction("store entry aborted while storing reply");
+        return;
     } else
         switch (persistentConnStatus()) {
         case INCOMPLETE_MSG: {
@@ -1785,6 +1784,9 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
     if (Config2.onoff.mangle_request_headers)
         httpHdrMangleList(hdr_out, request, ROR_REQUEST);
 
+    if (Config.request_header_add && !Config.request_header_add->empty())
+        httpHdrAdd(hdr_out, request, *Config.request_header_add);
+
     strConnection.clean();
 }
 
@@ -186,7 +186,7 @@ ICP2State::created(StoreEntry *newEntry)
 static void
 icpLogIcp(const Ip::Address &caddr, log_type logcode, int len, const char *url, int delay)
 {
-    AccessLogEntry al;
+    AccessLogEntry::Pointer al = new AccessLogEntry();
 
     if (LOG_TAG_NONE == logcode)
         return;
@@ -199,19 +199,19 @@ icpLogIcp(const Ip::Address &caddr, log_type logcode, int len, const char *url,
     if (!Config.onoff.log_udp)
         return;
 
-    al.icp.opcode = ICP_QUERY;
+    al->icp.opcode = ICP_QUERY;
 
-    al.url = url;
+    al->url = url;
 
-    al.cache.caddr = caddr;
+    al->cache.caddr = caddr;
 
-    al.cache.replySize = len;
+    al->cache.replySize = len;
 
-    al.cache.code = logcode;
+    al->cache.code = logcode;
 
-    al.cache.msec = delay;
+    al->cache.msec = delay;
 
-    accessLogLog(&al, NULL);
+    accessLogLog(al, NULL);
 }
 
 /// \ingroup ServerProtocolICPInternal2
@@ -100,6 +100,13 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
     if (hIpc)
         *hIpc = NULL;
 
+// NP: no wrapping around d and c usage since we *want* code expansion
+#define IPC_CHECK_FAIL(f,d,c) \
+    if ((f) < 0) { \
+        debugs(54, DBG_CRITICAL, "ERROR: Failed to create helper " d " FD: " << c); \
+        return ipcCloseAllFD(prfd, pwfd, crfd, cwfd); \
+    } else void(0)
+
     if (type == IPC_TCP_SOCKET) {
         crfd = cwfd = comm_open(SOCK_STREAM,
                                 0,
@@ -111,6 +118,8 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
                                 local_addr,
                                 0,			/* blocking */
                                 name);
+        IPC_CHECK_FAIL(crfd, "child read", "TCP " << local_addr);
+        IPC_CHECK_FAIL(prfd, "parent read", "TCP " << local_addr);
     } else if (type == IPC_UDP_SOCKET) {
         crfd = cwfd = comm_open(SOCK_DGRAM,
                                 0,
@@ -122,6 +131,8 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
                                 local_addr,
                                 0,
                                 name);
+        IPC_CHECK_FAIL(crfd, "child read", "UDP" << local_addr);
+        IPC_CHECK_FAIL(prfd, "parent read", "UDP" << local_addr);
     } else if (type == IPC_FIFO) {
         int p2c[2];
         int c2p[2];
@@ -140,6 +151,9 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
         fd_open(crfd = c2p[0], FD_PIPE, "IPC FIFO Child Read");
         fd_open(pwfd = c2p[1], FD_PIPE, "IPC FIFO Parent Write");
 
+        IPC_CHECK_FAIL(crfd, "child read", "FIFO pipe");
+        IPC_CHECK_FAIL(prfd, "parent read", "FIFO pipe");
+
 #if HAVE_SOCKETPAIR && defined(AF_UNIX)
 
     } else if (type == IPC_UNIX_STREAM) {
@@ -157,6 +171,9 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
         setsockopt(fds[1], SOL_SOCKET, SO_RCVBUF, (void *) &buflen, sizeof(buflen));
         fd_open(prfd = pwfd = fds[0], FD_PIPE, "IPC UNIX STREAM Parent");
         fd_open(crfd = cwfd = fds[1], FD_PIPE, "IPC UNIX STREAM Parent");
+        IPC_CHECK_FAIL(crfd, "child read", "UDS socket");
+        IPC_CHECK_FAIL(prfd, "parent read", "UDS socket");
+
     } else if (type == IPC_UNIX_DGRAM) {
         int fds[2];
 
@@ -167,6 +184,9 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
 
         fd_open(prfd = pwfd = fds[0], FD_PIPE, "IPC UNIX DGRAM Parent");
         fd_open(crfd = cwfd = fds[1], FD_PIPE, "IPC UNIX DGRAM Parent");
+
+        IPC_CHECK_FAIL(crfd, "child read", "UDS datagram");
+        IPC_CHECK_FAIL(prfd, "parent read", "UDS datagram");
 #endif
 
     } else {
@@ -178,16 +198,6 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
     debugs(54, 3, "ipcCreate: crfd FD " << crfd);
     debugs(54, 3, "ipcCreate: cwfd FD " << cwfd);
 
-    if (crfd < 0) {
-        debugs(54, 0, "ipcCreate: Failed to create child FD.");
-        return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);
-    }
-
-    if (pwfd < 0) {
-        debugs(54, 0, "ipcCreate: Failed to create server FD.");
-        return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);
-    }
-
     if (type == IPC_TCP_SOCKET || type == IPC_UDP_SOCKET) {
         PaS.InitAddrInfo(AI);
 
@@ -42,7 +42,7 @@
 #include "SquidTime.h"
 
 void
-Log::Format::HttpdCombined(AccessLogEntry * al, Logfile * logfile)
+Log::Format::HttpdCombined(const AccessLogEntry::Pointer &al, Logfile * logfile)
 {
     const char *user_ident = ::Format::QuoteUrlEncodeUsername(al->cache.rfc931);
 
@@ -51,7 +51,7 @@ Log::Format::HttpdCombined(AccessLogEntry * al, Logfile * logfile)
     const char *referer = NULL;
     const char *agent = NULL;
 
-    if (al && al->request) {
+    if (al->request) {
         referer = al->request->header.getStr(HDR_REFERER);
         agent = al->request->header.getStr(HDR_USER_AGENT);
     }
@@ -65,7 +65,7 @@ Log::Format::HttpdCombined(AccessLogEntry * al, Logfile * logfile)
     char clientip[MAX_IPSTRLEN];
     al->getLogClientIp(clientip, MAX_IPSTRLEN);
 
-    logfilePrintf(logfile, "%s %s %s [%s] \"%s %s %s/%d.%d\" %d %"PRId64" \"%s\" \"%s\" %s%s:%s%s",
+    logfilePrintf(logfile, "%s %s %s [%s] \"%s %s %s/%d.%d\" %d %" PRId64 " \"%s\" \"%s\" %s%s:%s%s",
                   clientip,
                   user_ident ? user_ident : dash_str,
                   user_auth ? user_auth : dash_str,
@@ -41,15 +41,15 @@
 #include "SquidTime.h"
 
 void
-Log::Format::HttpdCommon(AccessLogEntry * al, Logfile * logfile)
+Log::Format::HttpdCommon(const AccessLogEntry::Pointer &al, Logfile * logfile)
 {
     const char *user_auth = ::Format::QuoteUrlEncodeUsername(al->cache.authuser);
     const char *user_ident = ::Format::QuoteUrlEncodeUsername(al->cache.rfc931);
 
     char clientip[MAX_IPSTRLEN];
     al->getLogClientIp(clientip, MAX_IPSTRLEN);
 
-    logfilePrintf(logfile, "%s %s %s [%s] \"%s %s %s/%d.%d\" %d %"PRId64" %s%s:%s%s",
+    logfilePrintf(logfile, "%s %s %s [%s] \"%s %s %s/%d.%d\" %d %" PRId64 " %s%s:%s%s",
                   clientip,
                   user_ident ? user_ident : dash_str,
                   user_auth ? user_auth : dash_str,
@@ -39,7 +39,7 @@
 #include "MemBuf.h"
 
 void
-Log::Format::SquidCustom(AccessLogEntry * al, customlog * log)
+Log::Format::SquidCustom(const AccessLogEntry::Pointer &al, customlog * log)
 {
     static MemBuf mb;
     mb.reset();
@@ -44,7 +44,7 @@
 #include "SquidTime.h"
 
 void
-Log::Format::SquidIcap(AccessLogEntry * al, Logfile * logfile)
+Log::Format::SquidIcap(const AccessLogEntry::Pointer &al, Logfile * logfile)
 {
     const char *client = NULL;
     const char *user = NULL;
@@ -75,7 +75,7 @@ Log::Format::SquidIcap(AccessLogEntry * al, Logfile * logfile)
     if (user && !*user)
         safe_free(user);
 
-    logfilePrintf(logfile, "%9ld.%03d %6d %s %s/%03d %"PRId64" %s %s %s -/%s -\n",
+    logfilePrintf(logfile, "%9ld.%03d %6d %s %s/%03d %" PRId64 " %s %s %s -/%s -\n",
                   (long int) current_time.tv_sec,
                   (int) current_time.tv_usec / 1000,
                   al->icap.trTime,
@@ -41,7 +41,7 @@
 #include "SquidTime.h"
 
 void
-Log::Format::SquidNative(AccessLogEntry * al, Logfile * logfile)
+Log::Format::SquidNative(const AccessLogEntry::Pointer &al, Logfile * logfile)
 {
     char hierHost[MAX_IPSTRLEN];
 
@@ -64,7 +64,7 @@ Log::Format::SquidNative(AccessLogEntry * al, Logfile * logfile)
     char clientip[MAX_IPSTRLEN];
     al->getLogClientIp(clientip, MAX_IPSTRLEN);
 
-    logfilePrintf(logfile, "%9ld.%03d %6d %s %s%s/%03d %"PRId64" %s %s %s %s%s/%s %s%s",
+    logfilePrintf(logfile, "%9ld.%03d %6d %s %s%s/%03d %" PRId64 " %s %s %s %s%s/%s %s%s",
                   (long int) current_time.tv_sec,
                   (int) current_time.tv_usec / 1000,
                   al->cache.msec,
@@ -41,10 +41,10 @@
 #include "SquidTime.h"
 
 void
-Log::Format::SquidReferer(AccessLogEntry *al, Logfile *logfile)
+Log::Format::SquidReferer(const AccessLogEntry::Pointer &al, Logfile *logfile)
 {
     const char *referer = NULL;
-    if (al && al->request)
+    if (al->request)
         referer = al->request->header.getStr(HDR_REFERER);
 
     if (!referer || *referer == '\0')
@@ -41,11 +41,11 @@
 #include "SquidTime.h"
 
 void
-Log::Format::SquidUserAgent(AccessLogEntry * al, Logfile * logfile)
+Log::Format::SquidUserAgent(const AccessLogEntry::Pointer &al, Logfile * logfile)
 {
     const char *agent = NULL;
 
-    if (al && al->request)
+    if (al->request)
         agent = al->request->header.getStr(HDR_USER_AGENT);
 
     if (!agent || *agent == '\0')
@@ -1,6 +1,9 @@
 #ifndef _SQUID_LOG_FORMATS_H
 #define _SQUID_LOG_FORMATS_H
 
+#include "RefCount.h"
+
+typedef RefCount<AccessLogEntry> AccessLogEntryPointer;
 class AccessLogEntry;
 class Logfile;
 
@@ -25,25 +28,25 @@ typedef enum {
 } log_type;
 
 /// Native Squid Format Display
-void SquidNative(AccessLogEntry * al, Logfile * logfile);
+void SquidNative(const AccessLogEntryPointer &al, Logfile * logfile);
 
 /// Display log details in Squid ICAP format.
-void SquidIcap(AccessLogEntry * al, Logfile * logfile);
+void SquidIcap(const AccessLogEntryPointer &al, Logfile * logfile);
 
 /// Display log details in useragent format.
-void SquidUserAgent(AccessLogEntry * al, Logfile * logfile);
+void SquidUserAgent(const AccessLogEntryPointer &al, Logfile * logfile);
 
 /// Display log details in Squid old refererlog format.
-void SquidReferer(AccessLogEntry * al, Logfile * logfile);
+void SquidReferer(const AccessLogEntryPointer &al, Logfile * logfile);
 
 /// Log with a local custom format
-void SquidCustom(AccessLogEntry * al, customlog * log);
+void SquidCustom(const AccessLogEntryPointer &al, customlog * log);
 
 /// Log with Apache httpd common format
-void HttpdCommon(AccessLogEntry * al, Logfile * logfile);
+void HttpdCommon(const AccessLogEntryPointer &al, Logfile * logfile);
 
 /// Log with Apache httpd combined format
-void HttpdCombined(AccessLogEntry * al, Logfile * logfile);
+void HttpdCombined(const AccessLogEntryPointer &al, Logfile * logfile);
 
 }; // namespace Format
 }; // namespace Log
@@ -91,7 +91,7 @@ static void fvdbRegisterWithCacheManager();
 int LogfileStatus = LOG_DISABLE;
 
 void
-accessLogLogTo(customlog* log, AccessLogEntry * al, ACLChecklist * checklist)
+accessLogLogTo(customlog* log, AccessLogEntry::Pointer &al, ACLChecklist * checklist)
 {
 
     if (al->url == NULL)
@@ -167,7 +167,7 @@ accessLogLogTo(customlog* log, AccessLogEntry * al, ACLChecklist * checklist)
 }
 
 void
-accessLogLog(AccessLogEntry * al, ACLChecklist * checklist)
+accessLogLog(AccessLogEntry::Pointer &al, ACLChecklist * checklist)
 {
     if (LogfileStatus != LOG_ENABLE)
         return;
@@ -575,30 +575,6 @@ headersLog(int cs, int pq, const HttpRequestMethod& method, void *data)
 
 #endif
 
-void
-accessLogFreeMemory(AccessLogEntry * aLogEntry)
-{
-    safe_free(aLogEntry->headers.request);
-
-#if ICAP_CLIENT
-    safe_free(aLogEntry->adapt.last_meta);
-#endif
-
-    safe_free(aLogEntry->headers.reply);
-    safe_free(aLogEntry->cache.authuser);
-
-    safe_free(aLogEntry->headers.adapted_request);
-    HTTPMSGUNLOCK(aLogEntry->adapted_request);
-
-    HTTPMSGUNLOCK(aLogEntry->reply);
-    HTTPMSGUNLOCK(aLogEntry->request);
-#if ICAP_CLIENT
-    HTTPMSGUNLOCK(aLogEntry->icap.reply);
-    HTTPMSGUNLOCK(aLogEntry->icap.request);
-#endif
-    cbdataReferenceDone(aLogEntry->cache.port);
-}
-
 int
 logTypeIsATcpHit(log_type code)
 {
@@ -234,7 +234,6 @@ SQUIDCEXTERN void httpHeaderCleanModule(void);
 /* store report about current header usage and other stats */
 void httpHeaderStoreReport(StoreEntry * e);
 SQUIDCEXTERN void httpHdrMangleList(HttpHeader *, HttpRequest *, int req_or_rep);
-SQUIDCEXTERN int httpReqHdrManglersConfigured();
 
 #if SQUID_SNMP
 SQUIDCEXTERN PF snmpHandleUdp;
@@ -765,7 +765,7 @@ peer_Inst(oid * name, snint * len, mib_tree_entry * current, oid_ParseFn ** Fn)
         int no = name[current->len] ;
         int i;
         // Note: This works because the Config.peers keeps its index according to its position.
-        for ( i=0 ; peers && (i < no) ; peers = peers->next , i++ ) ;
+        for ( i=0 ; peers && (i < no) ; peers = peers->next , ++i ) ;
 
         if (peers) {
             debugs(49, 6, "snmp peer_Inst: Encode peer #" << i);
@@ -2013,7 +2013,7 @@ statClientRequests(StoreEntry * s)
 
         if (conn != NULL) {
             const int fd = conn->clientConnection->fd;
-            storeAppendPrintf(s, "\tFD %d, read %"PRId64", wrote %"PRId64"\n", fd,
+            storeAppendPrintf(s, "\tFD %d, read %" PRId64 ", wrote %" PRId64 "\n", fd,
                               fd_table[fd].bytes_read, fd_table[fd].bytes_written);
             storeAppendPrintf(s, "\tFD desc: %s\n", fd_table[fd].desc);
             storeAppendPrintf(s, "\tin: buf %p, offset %ld, size %ld\n",
@@ -1446,14 +1446,6 @@ StoreEntry::memoryCachable() const
     if (!Config.onoff.memory_cache_first && swap_status == SWAPOUT_DONE && refcount == 1)
         return 0;
 
-    if (Config.memShared && IamWorkerProcess()) {
-        const int64_t expectedSize = mem_obj->expectedReplySize();
-        // objects of unknown size are not allowed into memory cache, for now
-        if (expectedSize < 0 ||
-                expectedSize > static_cast<int64_t>(Config.Store.maxInMemObjSize))
-            return 0;
-    }
-
     return 1;
 }
 
@@ -876,7 +876,7 @@ store_client::dumpStats(MemBuf * output, int clientNumber) const
 
     output->Printf("\tClient #%d, %p\n", clientNumber, _callback.callback_data);
 
-    output->Printf("\t\tcopy_offset: %"PRId64"\n",
+    output->Printf("\t\tcopy_offset: %" PRId64 "\n",
                    copyInto.offset);
 
     output->Printf("\t\tcopy_size: %d\n",
@@ -352,7 +352,7 @@ StoreController::stat(StoreEntry &output) const
     storeAppendPrintf(&output, "Store Directory Statistics:\n");
     storeAppendPrintf(&output, "Store Entries          : %lu\n",
                       (unsigned long int)StoreEntry::inUseCount());
-    storeAppendPrintf(&output, "Maximum Swap Size      : %"PRIu64" KB\n",
+    storeAppendPrintf(&output, "Maximum Swap Size      : %" PRIu64 " KB\n",
                       maxSize() >> 10);
     storeAppendPrintf(&output, "Current Store Swap Size: %.2f KB\n",
                       currentSize() / 1024.0);
@@ -781,6 +781,40 @@ StoreController::get(String const key, STOREGETCLIENT aCallback, void *aCallback
     fatal("not implemented");
 }
 
+// move this into [non-shared] memory cache class when we have one
+/// whether e should be kept in local RAM for possible future caching
+bool
+StoreController::keepForLocalMemoryCache(const StoreEntry &e) const
+{
+    if (!e.memoryCachable())
+        return false;
+
+    // does the current and expected size obey memory caching limits?
+    assert(e.mem_obj);
+    const int64_t loadedSize = e.mem_obj->endOffset();
+    const int64_t expectedSize = e.mem_obj->expectedReplySize(); // may be < 0
+    const int64_t ramSize = max(loadedSize, expectedSize);
+    const int64_t ramLimit = min(
+                                 static_cast<int64_t>(Config.memMaxSize),
+                                 static_cast<int64_t>(Config.Store.maxInMemObjSize));
+    return ramSize <= ramLimit;
+}
+
+void
+StoreController::maybeTrimMemory(StoreEntry &e, const bool preserveSwappable)
+{
+    bool keepInLocalMemory = false;
+    if (memStore)
+        keepInLocalMemory = memStore->keepInLocalMemory(e);
+    else
+        keepInLocalMemory = keepForLocalMemoryCache(e);
+
+    debugs(20, 7, HERE << "keepInLocalMemory: " << keepInLocalMemory);
+
+    if (!keepInLocalMemory)
+        e.trimMemory(preserveSwappable);
+}
+
 void
 StoreController::handleIdleEntry(StoreEntry &e)
 {
@@ -795,7 +829,7 @@ StoreController::handleIdleEntry(StoreEntry &e)
         memStore->considerKeeping(e);
         // leave keepInLocalMemory false; memStore maintains its own cache
     } else {
-        keepInLocalMemory = e.memoryCachable() && // entry is in good shape and
+        keepInLocalMemory = keepForLocalMemoryCache(e) && // in good shape and
                             // the local memory cache is not overflowing
                             (mem_node::InUseCount() <= store_pages_max);
     }
@@ -86,7 +86,7 @@ storeLog(int tag, const StoreEntry * e)
         String ctype=(reply->content_type.size() ? reply->content_type.termedBuf() : str_unknown);
 
         logfileLineStart(storelog);
-        logfilePrintf(storelog, "%9d.%03d %-7s %02d %08X %s %4d %9d %9d %9d " SQUIDSTRINGPH " %"PRId64"/%"PRId64" %s %s\n",
+        logfilePrintf(storelog, "%9d.%03d %-7s %02d %08X %s %4d %9d %9d %9d " SQUIDSTRINGPH " %" PRId64 "/%" PRId64 " %s %s\n",
                       (int) current_time.tv_sec,
                       (int) current_time.tv_usec / 1000,
                       storeLogTags[tag],
@@ -198,7 +198,7 @@ StoreEntry::swapOut()
 
     const bool weAreOrMayBeSwappingOut = swappingOut() || mayStartSwapOut();
 
-    trimMemory(weAreOrMayBeSwappingOut);
+    Store::Root().maybeTrimMemory(*this, weAreOrMayBeSwappingOut);
 
     if (!weAreOrMayBeSwappingOut)
         return; // nothing else to do
@@ -36,6 +36,7 @@
 
 /* needed for the global config */
 #include "HttpHeader.h"
+#include "HttpHeaderTools.h"
 
 /* for ICP_END */
 #include "icp_opcode.h"
@@ -58,14 +59,6 @@ struct acl_deny_info_list {
     acl_deny_info_list *next;
 };
 
-
-class acl_access;
-
-struct _header_mangler {
-    acl_access *access_list;
-    char *replacement;
-};
-
 class ACLChecklist;
 
 #if SQUID_SNMP
@@ -577,10 +570,12 @@ struct SquidConfig {
     } mcast_miss;
 #endif
 
-    /* one access list per header type we know of */
-    header_mangler request_header_access[HDR_ENUM_END];
-    /* one access list per header type we know of */
-    header_mangler reply_header_access[HDR_ENUM_END];
+    /// request_header_access and request_header_replace
+    HeaderManglers *request_header_access;
+    /// reply_header_access and reply_header_replace
+    HeaderManglers *reply_header_access;
+    ///request_header_add access list
+    HeaderWithAclList *request_header_add;
     char *coredump_dir;
     char *chroot_dir;
 #if USE_CACHE_DIGESTS
@@ -30,6 +30,7 @@ STUB_SOURCE= tests/STUB.h \
 	tests/stub_ipc_TypedMsgHdr.cc \
 	tests/stub_ipcache.cc \
 	tests/stub_libcomm.cc \
+	tests/stub_libformat.cc \
 	tests/stub_libicmp.cc \
 	tests/stub_main_cc.cc \
 	tests/stub_mem.cc \
@@ -1,4 +1,5 @@
 #include "squid.h"
+#include "AccessLogEntry.h"
 #include "HttpRequest.h"
 
 #define STUB_API "HttpRequest.cc"
@@ -13,6 +13,7 @@
 
 MemStore::MemStore() STUB
 MemStore::~MemStore() STUB
+bool MemStore::keepInLocalMemory(const StoreEntry &) const STUB_RETVAL(false)
 void MemStore::considerKeeping(StoreEntry &) STUB
 void MemStore::reference(StoreEntry &) STUB
 void MemStore::maintain() STUB
@@ -0,0 +1,8 @@
+#include "squid.h"
+#include "format/Format.h"
+
+#define STUB_API "stub_libformat.cc"
+#include "tests/STUB.h"
+
+
+void Format::Format::assemble(MemBuf &mb, const AccessLogEntryPointer &al, int logSequenceNumber) const STUB
@@ -176,7 +176,7 @@ dumpMallocStats(void)
 
     mp = mallinfo();
 
-    fprintf(debug_log, "Memory usage for "APP_SHORTNAME" via mallinfo():\n");
+    fprintf(debug_log, "Memory usage for " APP_SHORTNAME " via mallinfo():\n");
 
     fprintf(debug_log, "\ttotal space in arena:  %6ld KB\n",
             (long)mp.arena >> 10);
@@ -267,7 +267,7 @@ log_extended( const char* fn, int code, long size, const SquidMetaList* meta )
 
     if ( meta && (findings = meta->search( STORE_META_KEY_MD5 )) ) {
         unsigned char* s = (unsigned char*) findings->data;
-        for ( int j=0; j<16; j++, s++ ) {
+        for ( int j=0; j<16; ++j, ++s ) {
             md5[j*2+0] = hexdigit[ *s >> 4 ];
             md5[j*2+1] = hexdigit[ *s & 15 ];
         }