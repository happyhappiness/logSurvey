diff --git a/src/ChangeLog b/src/ChangeLog
index 6b4b222..b871ca2 100644
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,5 +1,10 @@
 2003-10-31  Hrvoje Niksic  <hniksic@xemacs.org>
 
+	* various: Use new macros xnew, xnew0, xnew_array, and xnew0_array
+	in various places.
+
+2003-10-31  Hrvoje Niksic  <hniksic@xemacs.org>
+
 	* wget.h: Move declarations of malloc and logging code to
 	xmalloc.h and log.h respectively to unclutter this file.
 	(STRDUP_ALLOCA): Made it side-effect free.
diff --git a/src/connect.c b/src/connect.c
index 4957921..605ccb4 100644
--- a/src/connect.c
+++ b/src/connect.c
@@ -403,7 +403,7 @@ bindport (const ip_address *bind_address, int *port, int *local_sock)
   int optval;
   struct sockaddr_storage ss;
   struct sockaddr *sa = (struct sockaddr *)&ss;
-  memset (&ss, 0, sizeof (ss));
+  xzero (ss);
 
 #ifdef ENABLE_IPV6
   if (bind_address->type == IPV6_ADDRESS) 
diff --git a/src/convert.c b/src/convert.c
index 941bf05..021e8d4 100644
--- a/src/convert.c
+++ b/src/convert.c
@@ -465,8 +465,8 @@ write_backup_file (const char *file, downloaded_file_t downloaded_file_return)
          list.
 	 -- Hrvoje Niksic <hniksic@xemacs.org>
       */
-      converted_file_ptr = xmalloc(sizeof(*converted_file_ptr));
-      converted_file_ptr->string = xstrdup(file);  /* die on out-of-mem. */
+      converted_file_ptr = xmalloc (sizeof (*converted_file_ptr));
+      converted_file_ptr->string = xstrdup (file);
       converted_file_ptr->next = converted_files;
       converted_files = converted_file_ptr;
     }
diff --git a/src/cookies.c b/src/cookies.c
index 6d46123..07cfdc8 100644
--- a/src/cookies.c
+++ b/src/cookies.c
@@ -90,7 +90,7 @@ time_t cookies_now;
 struct cookie_jar *
 cookie_jar_new (void)
 {
-  struct cookie_jar *jar = xmalloc (sizeof (struct cookie_jar));
+  struct cookie_jar *jar = xnew (struct cookie_jar);
   jar->chains = make_nocase_string_hash_table (0);
   jar->cookie_count = 0;
   return jar;
@@ -130,8 +130,7 @@ struct cookie {
 static struct cookie *
 cookie_new (void)
 {
-  struct cookie *cookie = xmalloc (sizeof (struct cookie));
-  memset (cookie, '\0', sizeof (struct cookie));
+  struct cookie *cookie = xnew0 (struct cookie);
 
   /* Both cookie->permanent and cookie->expiry_time are now 0.  By
      default, we assume that the cookie is non-permanent and valid
diff --git a/src/ftp-opie.c b/src/ftp-opie.c
index eb51afb..2ea295e 100644
--- a/src/ftp-opie.c
+++ b/src/ftp-opie.c
@@ -2124,7 +2124,7 @@ btoe (char *store, const char *c)
 
   *store = '\0';
   /* Workaround for extract() reads beyond end of data */
-  memset (cp, 0, sizeof(cp));
+  xzero (cp);
   memcpy (cp, c, 8);
   /* Compute parity.  */
   for (p = 0, i = 0; i < 64; i += 2)
diff --git a/src/gen_sslfunc.c b/src/gen_sslfunc.c
index 57cdb0f..d9f1cec 100644
--- a/src/gen_sslfunc.c
+++ b/src/gen_sslfunc.c
@@ -149,8 +149,8 @@ ssl_printerrors (void)
   int ocerr = 0;
   unsigned long curerr = 0;
   char errbuff[1024];
-  memset(errbuff, 0, sizeof(errbuff));
-  while ( 0 != (curerr = ERR_get_error ()))
+  xzero (errbuff);
+  while ((curerr = ERR_get_error ()) != 0)
     {
       DEBUGP (("OpenSSL: %s\n", ERR_error_string (curerr, errbuff)));
       ++ocerr;
diff --git a/src/hash.c b/src/hash.c
index 91abee4..ba64457 100644
--- a/src/hash.c
+++ b/src/hash.c
@@ -263,8 +263,7 @@ hash_table_new (int items,
 		int (*test_function) (const void *, const void *))
 {
   int size;
-  struct hash_table *ht
-    = (struct hash_table *)xmalloc (sizeof (struct hash_table));
+  struct hash_table *ht = xnew (struct hash_table);
 
   ht->hash_function = hash_function ? hash_function : ptrhash;
   ht->test_function = test_function ? test_function : ptrcmp;
@@ -279,9 +278,7 @@ hash_table_new (int items,
   ht->resize_threshold = size * HASH_FULLNESS_THRESHOLD;
   /*assert (ht->resize_threshold >= items);*/
 
-  ht->mappings = xmalloc (ht->size * sizeof (struct mapping));
-  memset (ht->mappings, '\0', ht->size * sizeof (struct mapping));
-
+  ht->mappings = xnew0_array (struct mapping, ht->size);
   ht->count = 0;
 
   return ht;
@@ -382,9 +379,7 @@ grow_hash_table (struct hash_table *ht)
   ht->size = newsize;
   ht->resize_threshold = newsize * HASH_FULLNESS_THRESHOLD;
 
-  mappings = xmalloc (ht->size * sizeof (struct mapping));
-  memset (mappings, '\0', ht->size * sizeof (struct mapping));
-  ht->mappings = mappings;
+  ht->mappings = mappings = xnew0_array (struct mapping, ht->size);
 
   for (mp = old_mappings; mp < old_end; mp++)
     if (NON_EMPTY (mp))
diff --git a/src/host.c b/src/host.c
index b20ed3a..ab49042 100644
--- a/src/host.c
+++ b/src/host.c
@@ -236,11 +236,9 @@ address_list_from_addrinfo (const struct addrinfo *ai)
   if (cnt == 0)
     return NULL;
 
-  al = xmalloc (sizeof (struct address_list));
-  al->addresses  = xmalloc (cnt * sizeof (ip_address));
+  al = xnew0 (struct address_list);
+  al->addresses  = xnew_array (ip_address, cnt);
   al->count      = cnt;
-  al->faulty     = 0;
-  al->from_cache = 0;
   al->refcount   = 1;
 
   ip = al->addresses;
@@ -275,17 +273,15 @@ static struct address_list *
 address_list_from_ipv4_addresses (char **h_addr_list)
 {
   int count, i;
-  struct address_list *al = xmalloc (sizeof (struct address_list));
+  struct address_list *al = xnew0 (struct address_list);
 
   count = 0;
   while (h_addr_list[count])
     ++count;
   assert (count > 0);
 
+  al->addresses  = xnew_array (ip_address, count);
   al->count      = count;
-  al->faulty     = 0;
-  al->addresses  = xmalloc (count * sizeof (ip_address));
-  al->from_cache = 0;
   al->refcount   = 1;
 
   for (i = 0; i < count; i++)
@@ -496,7 +492,7 @@ lookup_host (const char *host, int flags)
      flag.  Without IPv6, we use inet_addr succeeds.  */
 
 #ifdef ENABLE_IPV6
-  memset (&hints, 0, sizeof (hints));
+  xzero (hints);
   hints.ai_family   = family;
   hints.ai_socktype = SOCK_STREAM;
   hints.ai_flags    = AI_NUMERICHOST;
@@ -549,7 +545,7 @@ lookup_host (const char *host, int flags)
 
 #ifdef ENABLE_IPV6
   {
-    memset (&hints, 0, sizeof (hints));
+    xzero (hints);
     hints.ai_family   = family;
     hints.ai_socktype = SOCK_STREAM;
     if (flags & LH_PASSIVE) 
diff --git a/src/html-url.c b/src/html-url.c
index f37ac85..e26bd17 100644
--- a/src/html-url.c
+++ b/src/html-url.c
@@ -327,9 +327,7 @@ append_url (const char *link_uri,
 
   DEBUGP (("appending \"%s\" to urlpos.\n", url->url));
 
-  newel = (struct urlpos *)xmalloc (sizeof (struct urlpos));
-  memset (newel, 0, sizeof (*newel));
-
+  newel = xnew0 (struct urlpos);
   newel->next = NULL;
   newel->url = url;
   newel->pos = tag->attrs[attrind].value_raw_beginning - ctx->text;
@@ -700,8 +698,7 @@ get_urls_file (const char *file)
 	}
       xfree (url_text);
 
-      entry = (struct urlpos *)xmalloc (sizeof (struct urlpos));
-      memset (entry, 0, sizeof (*entry));
+      entry = xnew0 (struct urlpos);
       entry->next = NULL;
       entry->url = url;
 
diff --git a/src/init.c b/src/init.c
index a10b643..688b3cf 100644
--- a/src/init.c
+++ b/src/init.c
@@ -256,10 +256,9 @@ defaults (void)
      NULL this way is technically illegal, but porting Wget to a
      machine where NULL is not all-zero bit pattern will be the least
      of the implementors' worries.  */
-  memset (&opt, 0, sizeof (opt));
+  xzero (opt);
 
   opt.cookies = 1;
-
   opt.verbose = -1;
   opt.ntry = 20;
   opt.reclevel = 5;
diff --git a/src/log.c b/src/log.c
index 5e02bac..4befb99 100644
--- a/src/log.c
+++ b/src/log.c
@@ -233,7 +233,7 @@ saved_append_1 (const char *start, const char *end)
 	    {
 	      /* Allocate memory and concatenate the old and the new
                  contents. */
-	      ln->malloced_line = xmalloc (old_len + len + 1);
+	      ln->malloced_line = (char *)xmalloc (old_len + len + 1);
 	      memcpy (ln->malloced_line, ln->static_line,
 		      old_len);
 	      memcpy (ln->malloced_line + old_len, start, len);
@@ -500,7 +500,7 @@ logprintf (enum log_options o, const char *fmt, ...)
     return;
   CHECK_VERBOSE (o);
 
-  memset (&lpstate, '\0', sizeof (lpstate));
+  xzero (lpstate);
   do
     {
       VA_START (args, fmt);
@@ -526,7 +526,7 @@ debug_logprintf (const char *fmt, ...)
       if (inhibit_logging)
 	return;
 
-      memset (&lpstate, '\0', sizeof (lpstate));
+      xzero (lpstate);
       do
 	{
 	  VA_START (args, fmt);
diff --git a/src/progress.c b/src/progress.c
index 10ce59d..99bdd5b 100644
--- a/src/progress.c
+++ b/src/progress.c
@@ -206,10 +206,7 @@ struct dot_progress {
 static void *
 dot_create (long initial, long total)
 {
-  struct dot_progress *dp = xmalloc (sizeof (struct dot_progress));
-
-  memset (dp, 0, sizeof (*dp));
-
+  struct dot_progress *dp = xnew0 (struct dot_progress);
   dp->initial_length = initial;
   dp->total_length   = total;
 
@@ -477,9 +474,7 @@ static void display_image PARAMS ((char *));
 static void *
 bar_create (long initial, long total)
 {
-  struct bar_progress *bp = xmalloc (sizeof (struct bar_progress));
-
-  memset (bp, 0, sizeof (*bp));
+  struct bar_progress *bp = xnew0 (struct bar_progress);
 
   /* In theory, our callers should take care of this pathological
      case, but it can sometimes happen. */
diff --git a/src/recur.c b/src/recur.c
index d90aead..4cf1d98 100644
--- a/src/recur.c
+++ b/src/recur.c
@@ -87,8 +87,7 @@ struct url_queue {
 static struct url_queue *
 url_queue_new (void)
 {
-  struct url_queue *queue = xmalloc (sizeof (*queue));
-  memset (queue, '\0', sizeof (*queue));
+  struct url_queue *queue = xnew0 (struct url_queue);
   return queue;
 }
 
@@ -108,7 +107,7 @@ static void
 url_enqueue (struct url_queue *queue,
 	     const char *url, const char *referer, int depth, int html_allowed)
 {
-  struct queue_element *qel = xmalloc (sizeof (*qel));
+  struct queue_element *qel = xnew (struct queue_element);
   qel->url = url;
   qel->referer = referer;
   qel->depth = depth;
@@ -605,8 +604,7 @@ descend_redirect_p (const char *redirected, const char *original, int depth,
   new_parsed = url_parse (redirected, NULL);
   assert (new_parsed != NULL);
 
-  upos = xmalloc (sizeof (struct urlpos));
-  memset (upos, 0, sizeof (*upos));
+  upos = xnew0 (struct urlpos);
   upos->url = new_parsed;
 
   success = download_child_p (upos, orig_parsed, depth,
diff --git a/src/res.c b/src/res.c
index 239666f..f8add49 100644
--- a/src/res.c
+++ b/src/res.c
@@ -167,7 +167,7 @@ prune_non_exact (struct robot_specs *specs)
   for (i = 0; i < specs->count; i++)
     if (specs->paths[i].user_agent_exact_p)
       ++cnt;
-  newpaths = xmalloc (cnt * sizeof (struct path_info));
+  newpaths = xnew_array (struct path_info, cnt);
   for (i = 0, j = 0; i < specs->count; i++)
     if (specs->paths[i].user_agent_exact_p)
       newpaths[j++] = specs->paths[i];
@@ -240,8 +240,7 @@ res_parse (const char *source, int length)
      the last `user-agent' instructions.  */
   int record_count = 0;
 
-  struct robot_specs *specs = xmalloc (sizeof (struct robot_specs));
-  memset (specs, '\0', sizeof (struct robot_specs));
+  struct robot_specs *specs = xnew0 (struct robot_specs);
 
   while (1)
     {
diff --git a/src/url.c b/src/url.c
index 1324794..40482b7 100644
--- a/src/url.c
+++ b/src/url.c
@@ -971,9 +971,7 @@ url_parse (const char *url, int *error)
 	}
     }
 
-  u = (struct url *)xmalloc (sizeof (struct url));
-  memset (u, 0, sizeof (*u));
-
+  u = xnew0 (struct url);
   u->scheme = scheme;
   u->host   = strdupdelim (host_b, host_e);
   u->port   = port;
diff --git a/src/utils.c b/src/utils.c
index 7a9ca64..a427e73 100644
--- a/src/utils.c
+++ b/src/utils.c
@@ -768,7 +768,7 @@ read_file (const char *file)
     fd = open (file, O_RDONLY);
   if (fd < 0)
     return NULL;
-  fm = xmalloc (sizeof (struct file_memory));
+  fm = xnew (struct file_memory);
 
 #ifdef HAVE_MMAP
   {
@@ -936,7 +936,7 @@ merge_vecs (char **v1, char **v2)
 slist *
 slist_append (slist *l, const char *s)
 {
-  slist *newel = (slist *)xmalloc (sizeof (slist));
+  slist *newel = xnew (slist);
   slist *beg = l;
 
   newel->string = xstrdup (s);
@@ -956,7 +956,7 @@ slist_append (slist *l, const char *s)
 slist *
 slist_prepend (slist *l, const char *s)
 {
-  slist *newel = (slist *)xmalloc (sizeof (slist));
+  slist *newel = xnew (slist);
   newel->string = xstrdup (s);
   newel->next = l;
   return newel;
@@ -1343,8 +1343,7 @@ struct wget_timer {
 struct wget_timer *
 wtimer_allocate (void)
 {
-  struct wget_timer *wt =
-    (struct wget_timer *)xmalloc (sizeof (struct wget_timer));
+  struct wget_timer *wt = xnew (struct wget_timer);
   return wt;
 }
 
@@ -1745,7 +1744,7 @@ alarm_set (double timeout)
 #ifdef ITIMER_REAL
   /* Use the modern itimer interface. */
   struct itimerval itv;
-  memset (&itv, 0, sizeof (itv));
+  xzero (itv);
   itv.it_value.tv_sec = (long) timeout;
   itv.it_value.tv_usec = 1000000L * (timeout - (long)timeout);
   if (itv.it_value.tv_sec == 0 && itv.it_value.tv_usec == 0)
@@ -1773,7 +1772,7 @@ alarm_cancel (void)
 {
 #ifdef ITIMER_REAL
   struct itimerval disable;
-  memset (&disable, 0, sizeof (disable));
+  xzero (disable);
   setitimer (ITIMER_REAL, &disable, NULL);
 #else  /* not ITIMER_REAL */
   alarm (0);
diff --git a/src/wget.h b/src/wget.h
index f3fb26f..7d69059 100644
--- a/src/wget.h
+++ b/src/wget.h
@@ -118,7 +118,7 @@ so, delete this exception statement from your version.  */
 #define countof(array) (sizeof (array) / sizeof ((array)[0]))
 
 /* Zero out a value.  */
-#define xzero(x) memset (&(x), '\0', sizeof (x))
+#define xzero(x) memset (&(x), '\0', sizeof ((x)))
 
 /* Convert an ASCII hex digit to the corresponding number between 0
    and 15.  X should be a hexadecimal digit that satisfies isxdigit;
-- 
cgit v1.0-41-gc330

