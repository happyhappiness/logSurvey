@@ -194,7 +194,7 @@ static int re_match_2(struct re_pattern_buffer * buffer, const char *string1,
 #if HAVE_ALLOCA_H
 #include <alloca.h>
 #else /* not __GNUC__ or HAVE_ALLOCA_H */
-#ifndef _AIX			/* Already did AIX, up at the top.  */
+#ifndef _AIX            /* Already did AIX, up at the top.  */
 char *alloca();
 #endif /* not _AIX */
 #endif /* not HAVE_ALLOCA_H */
@@ -205,29 +205,29 @@ char *alloca();
 #define REGEX_ALLOCATE alloca
 
 /* Assumes a `char *destination' variable.  */
-#define REGEX_REALLOCATE(source, osize, nsize)				\
-  (destination = (char *) alloca (nsize),				\
-   memcpy (destination, source, osize),				\
+#define REGEX_REALLOCATE(source, osize, nsize)              \
+  (destination = (char *) alloca (nsize),               \
+   memcpy (destination, source, osize),             \
    destination)
 
 #endif /* not REGEX_MALLOC */
 
 /* True if `size1' is non-NULL and PTR is pointing anywhere inside
  * `string1' or just past its end.  This works if PTR is NULL, which is
  * a good thing.  */
-#define FIRST_STRING_P(ptr) 					\
+#define FIRST_STRING_P(ptr)                     \
   (size1 && string1 <= (ptr) && (ptr) <= string1 + size1)
 
 /* (Re)Allocate N items of type T using malloc, or fail.  */
 #define TALLOC(n, t) ((t *) malloc ((n) * sizeof (t)))
 #define RETALLOC(addr, n, t) ((addr) = (t *) realloc (addr, (n) * sizeof (t)))
 #define REGEX_TALLOC(n, t) ((t *) REGEX_ALLOCATE ((n) * sizeof (t)))
 
-#define BYTEWIDTH 8		/* In bits.  */
+#define BYTEWIDTH 8     /* In bits.  */
 
 #define STREQ(s1, s2) ((strcmp (s1, s2) == 0))
 
-#if !defined(__MINGW32__)	/* MinGW defines boolean */
+#if !defined(__MINGW32__)   /* MinGW defines boolean */
 typedef char boolean;
 #endif
 #define false 0
@@ -348,44 +348,44 @@ typedef enum {
      * bytes of number.  */
     set_number_at,
 
-    wordchar,			/* Matches any word-constituent character.  */
-    notwordchar,		/* Matches any char that is not a word-constituent.  */
+    wordchar,           /* Matches any word-constituent character.  */
+    notwordchar,        /* Matches any char that is not a word-constituent.  */
 
-    wordbeg,			/* Succeeds if at word beginning.  */
-    wordend,			/* Succeeds if at word end.  */
+    wordbeg,            /* Succeeds if at word beginning.  */
+    wordend,            /* Succeeds if at word end.  */
 
-    wordbound,			/* Succeeds if at a word boundary.  */
-    notwordbound		/* Succeeds if not at a word boundary.  */
+    wordbound,          /* Succeeds if at a word boundary.  */
+    notwordbound        /* Succeeds if not at a word boundary.  */
 
 } re_opcode_t;
 
 /* Common operations on the compiled pattern.  */
 
 /* Store NUMBER in two contiguous bytes starting at DESTINATION.  */
 
-#define STORE_NUMBER(destination, number)				\
-  do {									\
-    (destination)[0] = (number) & 0377;					\
-    (destination)[1] = (number) >> 8;					\
+#define STORE_NUMBER(destination, number)               \
+  do {                                  \
+    (destination)[0] = (number) & 0377;                 \
+    (destination)[1] = (number) >> 8;                   \
   } while (0)
 
 /* Same as STORE_NUMBER, except increment DESTINATION to
  * the byte after where the number is stored.  Therefore, DESTINATION
  * must be an lvalue.  */
 
-#define STORE_NUMBER_AND_INCR(destination, number)			\
-  do {									\
-    STORE_NUMBER (destination, number);					\
-    (destination) += 2;							\
+#define STORE_NUMBER_AND_INCR(destination, number)          \
+  do {                                  \
+    STORE_NUMBER (destination, number);                 \
+    (destination) += 2;                         \
   } while (0)
 
 /* Put into DESTINATION a number stored in two contiguous bytes starting
  * at SOURCE.  */
 
-#define EXTRACT_NUMBER(destination, source)				\
-  do {									\
-    (destination) = *(source) & 0377;					\
-    (destination) += SIGN_EXTEND_CHAR (*((source) + 1)) << 8;		\
+#define EXTRACT_NUMBER(destination, source)             \
+  do {                                  \
+    (destination) = *(source) & 0377;                   \
+    (destination) += SIGN_EXTEND_CHAR (*((source) + 1)) << 8;       \
   } while (0)
 
 #ifdef DEBUG
@@ -399,7 +399,7 @@ unsigned char *source;
     *dest += temp << 8;
 }
 
-#ifndef EXTRACT_MACROS		/* To debug the macros.  */
+#ifndef EXTRACT_MACROS      /* To debug the macros.  */
 #undef EXTRACT_NUMBER
 #define EXTRACT_NUMBER(dest, src) extract_number (&dest, src)
 #endif /* not EXTRACT_MACROS */
@@ -409,10 +409,10 @@ unsigned char *source;
 /* Same as EXTRACT_NUMBER, except increment SOURCE to after the number.
  * SOURCE must be an lvalue.  */
 
-#define EXTRACT_NUMBER_AND_INCR(destination, source)			\
-  do {									\
-    EXTRACT_NUMBER (destination, source);				\
-    (source) += 2; 							\
+#define EXTRACT_NUMBER_AND_INCR(destination, source)            \
+  do {                                  \
+    EXTRACT_NUMBER (destination, source);               \
+    (source) += 2;                          \
   } while (0)
 
 #ifdef DEBUG
@@ -448,9 +448,9 @@ static int debug = 0;
 #define DEBUG_PRINT2(x1, x2) if (debug) printf (x1, x2)
 #define DEBUG_PRINT3(x1, x2, x3) if (debug) printf (x1, x2, x3)
 #define DEBUG_PRINT4(x1, x2, x3, x4) if (debug) printf (x1, x2, x3, x4)
-#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e) 				\
+#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e)               \
   if (debug) print_partial_compiled_pattern (s, e)
-#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)			\
+#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)          \
   if (debug) print_double_string (w, s1, sz1, s2, sz2)
 
 extern void printchar();
@@ -723,23 +723,23 @@ int size2;
 /* This table gives an error message for each of the error codes listed
  * in regex.h.  Obviously the order here has to be same as there.  */
 
-static const char *re_error_msg[] = {NULL,				/* REG_NOERROR */
-                                     "No match",			/* REG_NOMATCH */
-                                     "Invalid regular expression",	/* REG_BADPAT */
-                                     "Invalid collation character",	/* REG_ECOLLATE */
-                                     "Invalid character class name",	/* REG_ECTYPE */
-                                     "Trailing backslash",	/* REG_EESCAPE */
-                                     "Invalid back reference",	/* REG_ESUBREG */
-                                     "Unmatched [ or [^",	/* REG_EBRACK */
-                                     "Unmatched ( or \\(",	/* REG_EPAREN */
-                                     "Unmatched \\{",		/* REG_EBRACE */
-                                     "Invalid content of \\{\\}",	/* REG_BADBR */
-                                     "Invalid range end",	/* REG_ERANGE */
-                                     "Memory exhausted",		/* REG_ESPACE */
-                                     "Invalid preceding regular expression",	/* REG_BADRPT */
-                                     "Premature end of regular expression",	/* REG_EEND */
-                                     "Regular expression too big",	/* REG_ESIZE */
-                                     "Unmatched ) or \\)",	/* REG_ERPAREN */
+static const char *re_error_msg[] = {NULL,              /* REG_NOERROR */
+                                     "No match",            /* REG_NOMATCH */
+                                     "Invalid regular expression",  /* REG_BADPAT */
+                                     "Invalid collation character", /* REG_ECOLLATE */
+                                     "Invalid character class name",    /* REG_ECTYPE */
+                                     "Trailing backslash",  /* REG_EESCAPE */
+                                     "Invalid back reference",  /* REG_ESUBREG */
+                                     "Unmatched [ or [^",   /* REG_EBRACK */
+                                     "Unmatched ( or \\(",  /* REG_EPAREN */
+                                     "Unmatched \\{",       /* REG_EBRACE */
+                                     "Invalid content of \\{\\}",   /* REG_BADBR */
+                                     "Invalid range end",   /* REG_ERANGE */
+                                     "Memory exhausted",        /* REG_ESPACE */
+                                     "Invalid preceding regular expression",    /* REG_BADRPT */
+                                     "Premature end of regular expression", /* REG_EEND */
+                                     "Regular expression too big",  /* REG_ESIZE */
+                                     "Unmatched ) or \\)",  /* REG_ERPAREN */
                                     };
 
 /* Subroutine declarations and macros for regex_compile.  */
@@ -748,17 +748,17 @@ static const char *re_error_msg[] = {NULL,				/* REG_NOERROR */
  * if necessary.  Also cast from a signed character in the constant
  * string passed to us by the user to an unsigned char that we can use
  * as an array index (in, e.g., `translate').  */
-#define PATFETCH(c)							\
-  do {if (p == pend) return REG_EEND;					\
-    c = (unsigned char) *p++;						\
-    if (translate) c = translate[c]; 					\
+#define PATFETCH(c)                         \
+  do {if (p == pend) return REG_EEND;                   \
+    c = (unsigned char) *p++;                       \
+    if (translate) c = translate[c];                    \
   } while (0)
 
 /* Fetch the next character in the uncompiled pattern, with no
  * translation.  */
-#define PATFETCH_RAW(c)							\
-  do {if (p == pend) return REG_EEND;					\
-    c = (unsigned char) *p++; 						\
+#define PATFETCH_RAW(c)                         \
+  do {if (p == pend) return REG_EEND;                   \
+    c = (unsigned char) *p++;                       \
   } while (0)
 
 /* Go backwards one character in the pattern.  */
@@ -776,32 +776,32 @@ static const char *re_error_msg[] = {NULL,				/* REG_NOERROR */
 #define INIT_BUF_SIZE  32
 
 /* Make sure we have at least N more bytes of space in buffer.  */
-#define GET_BUFFER_SPACE(n)						\
-    while (b - bufp->buffer + (n) > bufp->allocated)			\
+#define GET_BUFFER_SPACE(n)                     \
+    while (b - bufp->buffer + (n) > bufp->allocated)            \
       EXTEND_BUFFER ()
 
 /* Make sure we have one more byte of buffer space and then add C to it.  */
-#define BUF_PUSH(c)							\
-  do {									\
-    GET_BUFFER_SPACE (1);						\
-    *b++ = (unsigned char) (c);						\
+#define BUF_PUSH(c)                         \
+  do {                                  \
+    GET_BUFFER_SPACE (1);                       \
+    *b++ = (unsigned char) (c);                     \
   } while (0)
 
 /* Ensure we have two more bytes of buffer space and then append C1 and C2.  */
-#define BUF_PUSH_2(c1, c2)						\
-  do {									\
-    GET_BUFFER_SPACE (2);						\
-    *b++ = (unsigned char) (c1);					\
-    *b++ = (unsigned char) (c2);					\
+#define BUF_PUSH_2(c1, c2)                      \
+  do {                                  \
+    GET_BUFFER_SPACE (2);                       \
+    *b++ = (unsigned char) (c1);                    \
+    *b++ = (unsigned char) (c2);                    \
   } while (0)
 
 /* As with BUF_PUSH_2, except for three bytes.  */
-#define BUF_PUSH_3(c1, c2, c3)						\
-  do {									\
-    GET_BUFFER_SPACE (3);						\
-    *b++ = (unsigned char) (c1);					\
-    *b++ = (unsigned char) (c2);					\
-    *b++ = (unsigned char) (c3);					\
+#define BUF_PUSH_3(c1, c2, c3)                      \
+  do {                                  \
+    GET_BUFFER_SPACE (3);                       \
+    *b++ = (unsigned char) (c1);                    \
+    *b++ = (unsigned char) (c2);                    \
+    *b++ = (unsigned char) (c3);                    \
   } while (0)
 
 /* Store a jump with opcode OP at LOC to location TO.  We store a
@@ -830,29 +830,29 @@ static const char *re_error_msg[] = {NULL,				/* REG_NOERROR */
  * reset the pointers that pointed into the old block to point to the
  * correct places in the new one.  If extending the buffer results in it
  * being larger than MAX_BUF_SIZE, then flag memory exhausted.  */
-#define EXTEND_BUFFER()							\
-  do { 									\
-    unsigned char *old_buffer = bufp->buffer;				\
-    if (bufp->allocated == MAX_BUF_SIZE) 				\
-      return REG_ESIZE;							\
-    bufp->allocated <<= 1;						\
-    if (bufp->allocated > MAX_BUF_SIZE)					\
-      bufp->allocated = MAX_BUF_SIZE; 					\
+#define EXTEND_BUFFER()                         \
+  do {                                  \
+    unsigned char *old_buffer = bufp->buffer;               \
+    if (bufp->allocated == MAX_BUF_SIZE)                \
+      return REG_ESIZE;                         \
+    bufp->allocated <<= 1;                      \
+    if (bufp->allocated > MAX_BUF_SIZE)                 \
+      bufp->allocated = MAX_BUF_SIZE;                   \
     bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated);\
-    if (bufp->buffer == NULL)						\
-      return REG_ESPACE;						\
-    /* If the buffer moved, move all the pointers into it.  */		\
-    if (old_buffer != bufp->buffer)					\
-      {									\
-        b = (b - old_buffer) + bufp->buffer;				\
-        begalt = (begalt - old_buffer) + bufp->buffer;			\
-        if (fixup_alt_jump)						\
+    if (bufp->buffer == NULL)                       \
+      return REG_ESPACE;                        \
+    /* If the buffer moved, move all the pointers into it.  */      \
+    if (old_buffer != bufp->buffer)                 \
+      {                                 \
+        b = (b - old_buffer) + bufp->buffer;                \
+        begalt = (begalt - old_buffer) + bufp->buffer;          \
+        if (fixup_alt_jump)                     \
           fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;\
-        if (laststart)							\
-          laststart = (laststart - old_buffer) + bufp->buffer;		\
-        if (pending_exact)						\
-          pending_exact = (pending_exact - old_buffer) + bufp->buffer;	\
-      }									\
+        if (laststart)                          \
+          laststart = (laststart - old_buffer) + bufp->buffer;      \
+        if (pending_exact)                      \
+          pending_exact = (pending_exact - old_buffer) + bufp->buffer;  \
+      }                                 \
   } while (0)
 
 /* Since we have one byte reserved for the register number argument to
@@ -881,7 +881,7 @@ typedef struct {
 typedef struct {
     compile_stack_elt_t *stack;
     unsigned size;
-    unsigned avail;		/* Offset of next open position.  */
+    unsigned avail;     /* Offset of next open position.  */
 } compile_stack_type;
 
 static void store_op1(re_opcode_t op, unsigned char *loc, int arg);
@@ -904,30 +904,30 @@ static reg_errcode_t compile_range(const char **p_ptr, const char *pend, char *t
    |= 1 << (((unsigned char) c) % BYTEWIDTH))
 
 /* Get the next unsigned number in the uncompiled pattern.  */
-#define GET_UNSIGNED_NUMBER(num) 					\
-  { if (p != pend)							\
-     {									\
-       PATFETCH (c); 							\
-       while (ISDIGIT (c)) 						\
-         { 								\
-           if (num < 0)							\
-              num = 0;							\
-           num = num * 10 + c - '0'; 					\
-           if (p == pend) 						\
-              break; 							\
-           PATFETCH (c);						\
-         } 								\
-       } 								\
+#define GET_UNSIGNED_NUMBER(num)                    \
+  { if (p != pend)                          \
+     {                                  \
+       PATFETCH (c);                            \
+       while (ISDIGIT (c))                      \
+         {                              \
+           if (num < 0)                         \
+              num = 0;                          \
+           num = num * 10 + c - '0';                    \
+           if (p == pend)                       \
+              break;                            \
+           PATFETCH (c);                        \
+         }                              \
+       }                                \
     }
 
-#define CHAR_CLASS_MAX_LENGTH  6	/* Namely, `xdigit'.  */
+#define CHAR_CLASS_MAX_LENGTH  6    /* Namely, `xdigit'.  */
 
-#define IS_CHAR_CLASS(string)						\
-   (STREQ (string, "alpha") || STREQ (string, "upper")			\
-    || STREQ (string, "lower") || STREQ (string, "digit")		\
-    || STREQ (string, "alnum") || STREQ (string, "xdigit")		\
-    || STREQ (string, "space") || STREQ (string, "print")		\
-    || STREQ (string, "punct") || STREQ (string, "graph")		\
+#define IS_CHAR_CLASS(string)                       \
+   (STREQ (string, "alpha") || STREQ (string, "upper")          \
+    || STREQ (string, "lower") || STREQ (string, "digit")       \
+    || STREQ (string, "alnum") || STREQ (string, "xdigit")      \
+    || STREQ (string, "space") || STREQ (string, "print")       \
+    || STREQ (string, "punct") || STREQ (string, "graph")       \
     || STREQ (string, "cntrl") || STREQ (string, "blank"))
 
 /* `regex_compile' compiles PATTERN (of length SIZE) according to SYNTAX.
@@ -1038,11 +1038,12 @@ regex_compile(const char *pattern, int size, reg_syntax_t syntax, struct re_patt
 #endif
 
     if (bufp->allocated == 0) {
-        if (bufp->buffer) {	/* If zero allocated, but buffer is non-null, try to realloc
-				 * enough space.  This loses if buffer's address is bogus, but
-				 * that is the user's responsibility.  */
+        if (bufp->buffer) {
+            /* If zero allocated, but buffer is non-null, try to realloc
+                     * enough space.  This loses if buffer's address is bogus, but
+                     * that is the user's responsibility.  */
             RETALLOC(bufp->buffer, INIT_BUF_SIZE, unsigned char);
-        } else {		/* Caller did not allocate a buffer.  Do it for them.  */
+        } else {        /* Caller did not allocate a buffer.  Do it for them.  */
             bufp->buffer = TALLOC(INIT_BUF_SIZE, unsigned char);
         }
         if (!bufp->buffer)
@@ -1058,7 +1059,7 @@ regex_compile(const char *pattern, int size, reg_syntax_t syntax, struct re_patt
 
         switch (c) {
         case '^': {
-            if (		/* If at start of pattern, it's an operator.  */
+            if (        /* If at start of pattern, it's an operator.  */
                 p == pattern + 1
                 /* If context independent, it's an operator.  */
                 || syntax & RE_CONTEXT_INDEP_ANCHORS
@@ -1071,7 +1072,7 @@ regex_compile(const char *pattern, int size, reg_syntax_t syntax, struct re_patt
         break;
 
         case '$': {
-            if (		/* If at end of pattern, it's an operator.  */
+            if (        /* If at end of pattern, it's an operator.  */
                 p == pend
                 /* If context independent, it's an operator.  */
                 || syntax & RE_CONTEXT_INDEP_ANCHORS
@@ -1146,16 +1147,17 @@ regex_compile(const char *pattern, int size, reg_syntax_t syntax, struct re_patt
 
                 /* Now we know whether or not zero matches is allowed
                  * and also whether or not two or more matches is allowed.  */
-                if (many_times_ok) {	/* More than one repetition is allowed, so put in at the
-					 * end a backward relative jump from `b' to before the next
-					 * jump we're going to put in below (which jumps from
-					 * laststart to after this jump).
-					 *
-					 * But if we are at the `*' in the exact sequence `.*\n',
-					 * insert an unconditional jump backwards to the .,
-					 * instead of the beginning of the loop.  This way we only
-					 * push a failure point once, instead of every time
-					 * through the loop.  */
+                if (many_times_ok) {
+                    /* More than one repetition is allowed, so put in at the
+                         * end a backward relative jump from `b' to before the next
+                         * jump we're going to put in below (which jumps from
+                         * laststart to after this jump).
+                         *
+                         * But if we are at the `*' in the exact sequence `.*\n',
+                         * insert an unconditional jump backwards to the .,
+                         * instead of the beginning of the loop.  This way we only
+                         * push a failure point once, instead of every time
+                         * through the loop.  */
                     assert(p - 1 > pattern);
 
                     /* Allocate the space for the jump.  */
@@ -1169,7 +1171,7 @@ regex_compile(const char *pattern, int size, reg_syntax_t syntax, struct re_patt
                     if (TRANSLATE(*(p - 2)) == TRANSLATE('.')
                             && zero_times_ok
                             && p < pend && TRANSLATE(*p) == TRANSLATE('\n')
-                            && !(syntax & RE_DOT_NEWLINE)) {	/* We have .*\n.  */
+                            && !(syntax & RE_DOT_NEWLINE)) {    /* We have .*\n.  */
                         STORE_JUMP(jump, b, laststart);
                         keep_string_p = true;
                     } else
@@ -1274,10 +1276,10 @@ regex_compile(const char *pattern, int size, reg_syntax_t syntax, struct re_patt
                         && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^')
                         && *p != ']') {
                     reg_errcode_t ret
-                    = compile_range(&p, pend, translate, syntax, b);
+                        = compile_range(&p, pend, translate, syntax, b);
                     if (ret != REG_NOERROR)
                         return ret;
-                } else if (p[0] == '-' && p[1] != ']') {	/* This handles ranges made up of characters only.  */
+                } else if (p[0] == '-' && p[1] != ']') {    /* This handles ranges made up of characters only.  */
                     reg_errcode_t ret;
 
                     /* Move past the `-'.  */
@@ -1290,7 +1292,7 @@ regex_compile(const char *pattern, int size, reg_syntax_t syntax, struct re_patt
                 /* See if we're at the beginning of a possible character
                  * class.  */
 
-                else if (syntax & RE_CHAR_CLASSES && c == '[' && *p == ':') {	/* Leave room for the null.  */
+                else if (syntax & RE_CHAR_CLASSES && c == '[' && *p == ':') {   /* Leave room for the null.  */
                     char str[CHAR_CLASS_MAX_LENGTH + 1];
 
                     PATFETCH(c);
@@ -1437,7 +1439,7 @@ regex_compile(const char *pattern, int size, reg_syntax_t syntax, struct re_patt
                  * be valid.  */
                 COMPILE_STACK_TOP.begalt_offset = begalt - bufp->buffer;
                 COMPILE_STACK_TOP.fixup_alt_jump
-                = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
+                    = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
                 COMPILE_STACK_TOP.laststart_offset = b - bufp->buffer;
                 COMPILE_STACK_TOP.regnum = regnum;
 
@@ -1471,10 +1473,11 @@ regex_compile(const char *pattern, int size, reg_syntax_t syntax, struct re_patt
                         return REG_ERPAREN;
                 }
 handle_close:
-                if (fixup_alt_jump) {	/* Push a dummy failure point at the end of the
-					 * alternative for a possible future
-					 * `pop_failure_jump' to pop.  See comments at
-					 * `push_dummy_failure' in `re_match_2'.  */
+                if (fixup_alt_jump) {
+                    /* Push a dummy failure point at the end of the
+                         * alternative for a possible future
+                         * `pop_failure_jump' to pop.  See comments at
+                         * `push_dummy_failure' in `re_match_2'.  */
                     BUF_PUSH(push_dummy_failure);
 
                     /* We allocated space for this jump when we assigned
@@ -1500,9 +1503,9 @@ regex_compile(const char *pattern, int size, reg_syntax_t syntax, struct re_patt
                     compile_stack.avail--;
                     begalt = bufp->buffer + COMPILE_STACK_TOP.begalt_offset;
                     fixup_alt_jump
-                    = COMPILE_STACK_TOP.fixup_alt_jump
-                      ? bufp->buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1
-                      : 0;
+                        = COMPILE_STACK_TOP.fixup_alt_jump
+                          ? bufp->buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1
+                          : 0;
                     laststart = bufp->buffer + COMPILE_STACK_TOP.laststart_offset;
                     this_group_regnum = COMPILE_STACK_TOP.regnum;
                     /* If we've reached MAX_REGNUM groups, then this open
@@ -1514,7 +1517,7 @@ regex_compile(const char *pattern, int size, reg_syntax_t syntax, struct re_patt
                      * groups were inside this one.  */
                     if (this_group_regnum <= MAX_REGNUM) {
                         unsigned char *inner_group_loc
-                        = bufp->buffer + COMPILE_STACK_TOP.inner_group_offset;
+                            = bufp->buffer + COMPILE_STACK_TOP.inner_group_offset;
 
                         *inner_group_loc = regnum - this_group_regnum;
                         BUF_PUSH_3(stop_memory, this_group_regnum,
@@ -1523,7 +1526,7 @@ regex_compile(const char *pattern, int size, reg_syntax_t syntax, struct re_patt
                 }
                 break;
 
-            case '|':		/* `\|'.  */
+            case '|':       /* `\|'.  */
                 if (syntax & RE_LIMITED_OPS || syntax & RE_NO_BK_VBAR)
                     goto normal_backslash;
 handle_alt:
@@ -1647,8 +1650,9 @@ handle_interval: {
                      * jump_n <succeed_n addr> <jump count>
                      * (The upper bound and `jump_n' are omitted if
                      * `upper_bound' is 1, though.)  */
-                    else {	/* If the upper bound is > 1, we need to insert
-				 * more at the end of the loop.  */
+                    else {
+                        /* If the upper bound is > 1, we need to insert
+                        * more at the end of the loop.  */
                         unsigned nbytes = 10 + (upper_bound > 1) * 10;
 
                         GET_BUFFER_SPACE(nbytes);
@@ -1670,13 +1674,14 @@ handle_interval: {
                         insert_op2(set_number_at, laststart, 5, lower_bound, b);
                         b += 5;
 
-                        if (upper_bound > 1) {	/* More than one repetition is allowed, so
-						 * append a backward jump to the `succeed_n'
-						 * that starts this interval.
-						 *
-						 * When we've reached this during matching,
-						 * we'll have matched the interval once, so
-						 * jump back only `upper_bound - 1' times.  */
+                        if (upper_bound > 1) {
+                            /* More than one repetition is allowed, so
+                             * append a backward jump to the `succeed_n'
+                             * that starts this interval.
+                             *
+                             * When we've reached this during matching,
+                             * we'll have matched the interval once, so
+                             * jump back only `upper_bound - 1' times.  */
                             STORE_JUMP2(jump_n, b, laststart + 5,
                                         upper_bound - 1);
                             b += 5;
@@ -1827,8 +1832,8 @@ handle_interval: {
             BUF_PUSH(c);
             (*pending_exact)++;
             break;
-        }			/* switch (c) */
-    }				/* while p != pend */
+        }           /* switch (c) */
+    }               /* while p != pend */
 
     /* Through the pattern now.  */
 
@@ -1851,7 +1856,7 @@ handle_interval: {
 #endif /* DEBUG */
 
     return REG_NOERROR;
-}				/* regex_compile */
+}               /* regex_compile */
 
 /* Subroutines for `regex_compile'.  */
 
@@ -2028,7 +2033,7 @@ typedef const unsigned char *fail_stack_elt_t;
 typedef struct {
     fail_stack_elt_t *stack;
     unsigned size;
-    unsigned avail;		/* Offset of next open position.  */
+    unsigned avail;     /* Offset of next open position.  */
 } fail_stack_type;
 
 #define FAIL_STACK_EMPTY()     (fail_stack.avail == 0)
@@ -2038,16 +2043,16 @@ typedef struct {
 
 /* Initialize `fail_stack'.  Do `return -2' if the alloc fails.  */
 
-#define INIT_FAIL_STACK()						\
-  do {									\
-    fail_stack.stack = (fail_stack_elt_t *)				\
-      REGEX_ALLOCATE (INIT_FAILURE_ALLOC * sizeof (fail_stack_elt_t));	\
-									\
-    if (fail_stack.stack == NULL)					\
-      return -2;							\
-									\
-    fail_stack.size = INIT_FAILURE_ALLOC;				\
-    fail_stack.avail = 0;						\
+#define INIT_FAIL_STACK()                       \
+  do {                                  \
+    fail_stack.stack = (fail_stack_elt_t *)             \
+      REGEX_ALLOCATE (INIT_FAILURE_ALLOC * sizeof (fail_stack_elt_t));  \
+                                    \
+    if (fail_stack.stack == NULL)                   \
+      return -2;                            \
+                                    \
+    fail_stack.size = INIT_FAILURE_ALLOC;               \
+    fail_stack.avail = 0;                       \
   } while (0)
 
 /* Double the size of FAIL_STACK, up to approximately `re_max_failures' items.
@@ -2057,34 +2062,34 @@ typedef struct {
  *
  * REGEX_REALLOCATE requires `destination' be declared.   */
 
-#define DOUBLE_FAIL_STACK(fail_stack)					\
-  ((fail_stack).size > re_max_failures * MAX_FAILURE_ITEMS		\
-   ? 0									\
-   : ((fail_stack).stack = (fail_stack_elt_t *)				\
-        REGEX_REALLOCATE ((fail_stack).stack, 				\
-          (fail_stack).size * sizeof (fail_stack_elt_t),		\
-          ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),	\
-									\
-      (fail_stack).stack == NULL					\
-      ? 0								\
-      : ((fail_stack).size <<= 1, 					\
+#define DOUBLE_FAIL_STACK(fail_stack)                   \
+  ((fail_stack).size > re_max_failures * MAX_FAILURE_ITEMS      \
+   ? 0                                  \
+   : ((fail_stack).stack = (fail_stack_elt_t *)             \
+        REGEX_REALLOCATE ((fail_stack).stack,               \
+          (fail_stack).size * sizeof (fail_stack_elt_t),        \
+          ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),    \
+                                    \
+      (fail_stack).stack == NULL                    \
+      ? 0                               \
+      : ((fail_stack).size <<= 1,                   \
          1)))
 
 /* Push PATTERN_OP on FAIL_STACK.
  *
  * Return 1 if was able to do so and 0 if ran out of memory allocating
  * space to do so.  */
-#define PUSH_PATTERN_OP(pattern_op, fail_stack)				\
-  ((FAIL_STACK_FULL ()							\
-    && !DOUBLE_FAIL_STACK (fail_stack))					\
-    ? 0									\
-    : ((fail_stack).stack[(fail_stack).avail++] = pattern_op,		\
+#define PUSH_PATTERN_OP(pattern_op, fail_stack)             \
+  ((FAIL_STACK_FULL ()                          \
+    && !DOUBLE_FAIL_STACK (fail_stack))                 \
+    ? 0                                 \
+    : ((fail_stack).stack[(fail_stack).avail++] = pattern_op,       \
        1))
 
 /* This pushes an item onto the failure stack.  Must be a four-byte
  * value.  Assumes the variable `fail_stack'.  Probably should only
  * be called from within `PUSH_FAILURE_POINT'.  */
-#define PUSH_FAILURE_ITEM(item)						\
+#define PUSH_FAILURE_ITEM(item)                     \
   fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) item
 
 /* The complement operation.  Assumes `fail_stack' is nonempty.  */
@@ -2108,78 +2113,78 @@ typedef struct {
  *
  * Does `return FAILURE_CODE' if runs out of memory.  */
 
-#define PUSH_FAILURE_POINT(pattern_place, string_place, failure_code)	\
-  do {									\
-    char *destination;							\
-    /* Must be int, so when we don't save any registers, the arithmetic	\
-       of 0 + -1 isn't done as unsigned.  */				\
-    int this_reg;							\
-    									\
-    DEBUG_STATEMENT (failure_id++);					\
-    DEBUG_STATEMENT (nfailure_points_pushed++);				\
-    DEBUG_PRINT2 ("\nPUSH_FAILURE_POINT #%u:\n", failure_id);		\
+#define PUSH_FAILURE_POINT(pattern_place, string_place, failure_code)   \
+  do {                                  \
+    char *destination;                          \
+    /* Must be int, so when we don't save any registers, the arithmetic \
+       of 0 + -1 isn't done as unsigned.  */                \
+    int this_reg;                           \
+                                        \
+    DEBUG_STATEMENT (failure_id++);                 \
+    DEBUG_STATEMENT (nfailure_points_pushed++);             \
+    DEBUG_PRINT2 ("\nPUSH_FAILURE_POINT #%u:\n", failure_id);       \
     DEBUG_PRINT2 ("  Before push, next avail: %d\n", (fail_stack).avail);\
     DEBUG_PRINT2 ("                     size: %d\n", (fail_stack).size);\
-									\
-    DEBUG_PRINT2 ("  slots needed: %d\n", NUM_FAILURE_ITEMS);		\
-    DEBUG_PRINT2 ("     available: %d\n", REMAINING_AVAIL_SLOTS);	\
-									\
-    /* Ensure we have enough space allocated for what we will push.  */	\
-    while (REMAINING_AVAIL_SLOTS < NUM_FAILURE_ITEMS)			\
-      {									\
-        if (!DOUBLE_FAIL_STACK (fail_stack))			\
-          return failure_code;						\
-									\
-        DEBUG_PRINT2 ("\n  Doubled stack; size now: %d\n",		\
-		       (fail_stack).size);				\
+                                    \
+    DEBUG_PRINT2 ("  slots needed: %d\n", NUM_FAILURE_ITEMS);       \
+    DEBUG_PRINT2 ("     available: %d\n", REMAINING_AVAIL_SLOTS);   \
+                                    \
+    /* Ensure we have enough space allocated for what we will push.  */ \
+    while (REMAINING_AVAIL_SLOTS < NUM_FAILURE_ITEMS)           \
+      {                                 \
+        if (!DOUBLE_FAIL_STACK (fail_stack))            \
+          return failure_code;                      \
+                                    \
+        DEBUG_PRINT2 ("\n  Doubled stack; size now: %d\n",      \
+               (fail_stack).size);              \
         DEBUG_PRINT2 ("  slots available: %d\n", REMAINING_AVAIL_SLOTS);\
-      }									\
-									\
-    /* Push the info, starting with the registers.  */			\
-    DEBUG_PRINT1 ("\n");						\
-									\
-    for (this_reg = lowest_active_reg; this_reg <= highest_active_reg;	\
-         this_reg++)							\
-      {									\
-	DEBUG_PRINT2 ("  Pushing reg: %d\n", this_reg);			\
-        DEBUG_STATEMENT (num_regs_pushed++);				\
-									\
-	DEBUG_PRINT2 ("    start: 0x%x\n", regstart[this_reg]);		\
-        PUSH_FAILURE_ITEM (regstart[this_reg]);				\
+      }                                 \
+                                    \
+    /* Push the info, starting with the registers.  */          \
+    DEBUG_PRINT1 ("\n");                        \
+                                    \
+    for (this_reg = lowest_active_reg; this_reg <= highest_active_reg;  \
+         this_reg++)                            \
+      {                                 \
+    DEBUG_PRINT2 ("  Pushing reg: %d\n", this_reg);         \
+        DEBUG_STATEMENT (num_regs_pushed++);                \
+                                    \
+    DEBUG_PRINT2 ("    start: 0x%x\n", regstart[this_reg]);     \
+        PUSH_FAILURE_ITEM (regstart[this_reg]);             \
                                                                         \
-	DEBUG_PRINT2 ("    end: 0x%x\n", regend[this_reg]);		\
-        PUSH_FAILURE_ITEM (regend[this_reg]);				\
-									\
-	DEBUG_PRINT2 ("    info: 0x%x\n      ", reg_info[this_reg]);	\
-        DEBUG_PRINT2 (" match_null=%d",					\
-                      REG_MATCH_NULL_STRING_P (reg_info[this_reg]));	\
-        DEBUG_PRINT2 (" active=%d", IS_ACTIVE (reg_info[this_reg]));	\
-        DEBUG_PRINT2 (" matched_something=%d",				\
-                      MATCHED_SOMETHING (reg_info[this_reg]));		\
-        DEBUG_PRINT2 (" ever_matched=%d",				\
-                      EVER_MATCHED_SOMETHING (reg_info[this_reg]));	\
-	DEBUG_PRINT1 ("\n");						\
-        PUSH_FAILURE_ITEM (reg_info[this_reg].word);			\
-      }									\
-									\
+    DEBUG_PRINT2 ("    end: 0x%x\n", regend[this_reg]);     \
+        PUSH_FAILURE_ITEM (regend[this_reg]);               \
+                                    \
+    DEBUG_PRINT2 ("    info: 0x%x\n      ", reg_info[this_reg]);    \
+        DEBUG_PRINT2 (" match_null=%d",                 \
+                      REG_MATCH_NULL_STRING_P (reg_info[this_reg]));    \
+        DEBUG_PRINT2 (" active=%d", IS_ACTIVE (reg_info[this_reg]));    \
+        DEBUG_PRINT2 (" matched_something=%d",              \
+                      MATCHED_SOMETHING (reg_info[this_reg]));      \
+        DEBUG_PRINT2 (" ever_matched=%d",               \
+                      EVER_MATCHED_SOMETHING (reg_info[this_reg])); \
+    DEBUG_PRINT1 ("\n");                        \
+        PUSH_FAILURE_ITEM (reg_info[this_reg].word);            \
+      }                                 \
+                                    \
     DEBUG_PRINT2 ("  Pushing  low active reg: %d\n", lowest_active_reg);\
-    PUSH_FAILURE_ITEM (lowest_active_reg);				\
-									\
+    PUSH_FAILURE_ITEM (lowest_active_reg);              \
+                                    \
     DEBUG_PRINT2 ("  Pushing high active reg: %d\n", highest_active_reg);\
-    PUSH_FAILURE_ITEM (highest_active_reg);				\
-									\
-    DEBUG_PRINT2 ("  Pushing pattern 0x%x: ", pattern_place);		\
-    DEBUG_PRINT_COMPILED_PATTERN (bufp, pattern_place, pend);		\
-    PUSH_FAILURE_ITEM (pattern_place);					\
-									\
-    DEBUG_PRINT2 ("  Pushing string 0x%x: `", string_place);		\
+    PUSH_FAILURE_ITEM (highest_active_reg);             \
+                                    \
+    DEBUG_PRINT2 ("  Pushing pattern 0x%x: ", pattern_place);       \
+    DEBUG_PRINT_COMPILED_PATTERN (bufp, pattern_place, pend);       \
+    PUSH_FAILURE_ITEM (pattern_place);                  \
+                                    \
+    DEBUG_PRINT2 ("  Pushing string 0x%x: `", string_place);        \
     DEBUG_PRINT_DOUBLE_STRING (string_place, string1, size1, string2,   \
-				 size2);				\
-    DEBUG_PRINT1 ("'\n");						\
-    PUSH_FAILURE_ITEM (string_place);					\
-									\
-    DEBUG_PRINT2 ("  Pushing failure id: %u\n", failure_id);		\
-    DEBUG_PUSH (failure_id);						\
+                 size2);                \
+    DEBUG_PRINT1 ("'\n");                       \
+    PUSH_FAILURE_ITEM (string_place);                   \
+                                    \
+    DEBUG_PRINT2 ("  Pushing failure id: %u\n", failure_id);        \
+    DEBUG_PUSH (failure_id);                        \
   } while (0)
 
 /* This is the number of items that are pushed and popped on the stack
@@ -2188,7 +2193,7 @@ typedef struct {
 
 /* Individual items aside from the registers.  */
 #ifdef DEBUG
-#define NUM_NONREG_ITEMS 5	/* Includes failure point id.  */
+#define NUM_NONREG_ITEMS 5  /* Includes failure point id.  */
 #else
 #define NUM_NONREG_ITEMS 4
 #endif
@@ -2197,8 +2202,8 @@ typedef struct {
 #define MAX_FAILURE_ITEMS ((num_regs - 1) * NUM_REG_ITEMS + NUM_NONREG_ITEMS)
 
 /* We actually push this many items.  */
-#define NUM_FAILURE_ITEMS						\
-  ((highest_active_reg - lowest_active_reg + 1) * NUM_REG_ITEMS 	\
+#define NUM_FAILURE_ITEMS                       \
+  ((highest_active_reg - lowest_active_reg + 1) * NUM_REG_ITEMS     \
     + NUM_NONREG_ITEMS)
 
 /* How many items can still be added to the stack without overflowing it.  */
@@ -2217,61 +2222,61 @@ typedef struct {
  * `pend', `string1', `size1', `string2', and `size2'.  */
 
 #define POP_FAILURE_POINT(str, pat, low_reg, high_reg, regstart, regend, reg_info)\
-{									\
-  DEBUG_STATEMENT (fail_stack_elt_t failure_id;)			\
-  int this_reg;								\
-  const unsigned char *string_temp;					\
-									\
-  assert (!FAIL_STACK_EMPTY ());					\
-									\
-  /* Remove failure points and point to how many regs pushed.  */	\
-  DEBUG_PRINT1 ("POP_FAILURE_POINT:\n");				\
-  DEBUG_PRINT2 ("  Before pop, next avail: %d\n", fail_stack.avail);	\
-  DEBUG_PRINT2 ("                    size: %d\n", fail_stack.size);	\
-									\
-  assert (fail_stack.avail >= NUM_NONREG_ITEMS);			\
-									\
-  DEBUG_POP (&failure_id);						\
-  DEBUG_PRINT2 ("  Popping failure id: %u\n", failure_id);		\
-									\
-  /* If the saved string location is NULL, it came from an		\
-     on_failure_keep_string_jump opcode, and we want to throw away the	\
-     saved NULL, thus retaining our current position in the string.  */	\
-  string_temp = POP_FAILURE_ITEM ();					\
-  if (string_temp != NULL)						\
-    str = (const char *) string_temp;					\
-									\
-  DEBUG_PRINT2 ("  Popping string 0x%x: `", str);			\
-  DEBUG_PRINT_DOUBLE_STRING (str, string1, size1, string2, size2);	\
-  DEBUG_PRINT1 ("'\n");							\
-									\
-  pat = (unsigned char *) POP_FAILURE_ITEM ();				\
-  DEBUG_PRINT2 ("  Popping pattern 0x%x: ", pat);			\
-  DEBUG_PRINT_COMPILED_PATTERN (bufp, pat, pend);			\
-									\
-  /* Restore register info.  */						\
-  high_reg = (unsigned long) POP_FAILURE_ITEM ();			\
-  DEBUG_PRINT2 ("  Popping high active reg: %d\n", high_reg);		\
-									\
-  low_reg = (unsigned long) POP_FAILURE_ITEM ();			\
-  DEBUG_PRINT2 ("  Popping  low active reg: %d\n", low_reg);		\
-									\
-  for (this_reg = high_reg; this_reg >= low_reg; this_reg--)		\
-    {									\
-      DEBUG_PRINT2 ("    Popping reg: %d\n", this_reg);			\
-									\
-      reg_info[this_reg].word = POP_FAILURE_ITEM ();			\
-      DEBUG_PRINT2 ("      info: 0x%x\n", reg_info[this_reg]);		\
-									\
-      regend[this_reg] = (const char *) POP_FAILURE_ITEM ();		\
-      DEBUG_PRINT2 ("      end: 0x%x\n", regend[this_reg]);		\
-									\
-      regstart[this_reg] = (const char *) POP_FAILURE_ITEM ();		\
-      DEBUG_PRINT2 ("      start: 0x%x\n", regstart[this_reg]);		\
-    }									\
-									\
-  DEBUG_STATEMENT (nfailure_points_popped++);				\
-}				/* POP_FAILURE_POINT */
+{                                   \
+  DEBUG_STATEMENT (fail_stack_elt_t failure_id;)            \
+  int this_reg;                             \
+  const unsigned char *string_temp;                 \
+                                    \
+  assert (!FAIL_STACK_EMPTY ());                    \
+                                    \
+  /* Remove failure points and point to how many regs pushed.  */   \
+  DEBUG_PRINT1 ("POP_FAILURE_POINT:\n");                \
+  DEBUG_PRINT2 ("  Before pop, next avail: %d\n", fail_stack.avail);    \
+  DEBUG_PRINT2 ("                    size: %d\n", fail_stack.size); \
+                                    \
+  assert (fail_stack.avail >= NUM_NONREG_ITEMS);            \
+                                    \
+  DEBUG_POP (&failure_id);                      \
+  DEBUG_PRINT2 ("  Popping failure id: %u\n", failure_id);      \
+                                    \
+  /* If the saved string location is NULL, it came from an      \
+     on_failure_keep_string_jump opcode, and we want to throw away the  \
+     saved NULL, thus retaining our current position in the string.  */ \
+  string_temp = POP_FAILURE_ITEM ();                    \
+  if (string_temp != NULL)                      \
+    str = (const char *) string_temp;                   \
+                                    \
+  DEBUG_PRINT2 ("  Popping string 0x%x: `", str);           \
+  DEBUG_PRINT_DOUBLE_STRING (str, string1, size1, string2, size2);  \
+  DEBUG_PRINT1 ("'\n");                         \
+                                    \
+  pat = (unsigned char *) POP_FAILURE_ITEM ();              \
+  DEBUG_PRINT2 ("  Popping pattern 0x%x: ", pat);           \
+  DEBUG_PRINT_COMPILED_PATTERN (bufp, pat, pend);           \
+                                    \
+  /* Restore register info.  */                     \
+  high_reg = (unsigned long) POP_FAILURE_ITEM ();           \
+  DEBUG_PRINT2 ("  Popping high active reg: %d\n", high_reg);       \
+                                    \
+  low_reg = (unsigned long) POP_FAILURE_ITEM ();            \
+  DEBUG_PRINT2 ("  Popping  low active reg: %d\n", low_reg);        \
+                                    \
+  for (this_reg = high_reg; this_reg >= low_reg; this_reg--)        \
+    {                                   \
+      DEBUG_PRINT2 ("    Popping reg: %d\n", this_reg);         \
+                                    \
+      reg_info[this_reg].word = POP_FAILURE_ITEM ();            \
+      DEBUG_PRINT2 ("      info: 0x%x\n", reg_info[this_reg]);      \
+                                    \
+      regend[this_reg] = (const char *) POP_FAILURE_ITEM ();        \
+      DEBUG_PRINT2 ("      end: 0x%x\n", regend[this_reg]);     \
+                                    \
+      regstart[this_reg] = (const char *) POP_FAILURE_ITEM ();      \
+      DEBUG_PRINT2 ("      start: 0x%x\n", regstart[this_reg]);     \
+    }                                   \
+                                    \
+  DEBUG_STATEMENT (nfailure_points_popped++);               \
+}               /* POP_FAILURE_POINT */
 
 /* re_compile_fastmap computes a ``fastmap'' for the compiled pattern in
  * BUFP.  A fastmap records which of the (1 << BYTEWIDTH) possible
@@ -2320,8 +2325,8 @@ struct re_pattern_buffer *bufp;
     assert(fastmap != NULL && p != NULL);
 
     INIT_FAIL_STACK();
-    memset(fastmap, 0, 1 << BYTEWIDTH);		/* Assume nothing's valid.  */
-    bufp->fastmap_accurate = 1;	/* It will be when we're done.  */
+    memset(fastmap, 0, 1 << BYTEWIDTH);     /* Assume nothing's valid.  */
+    bufp->fastmap_accurate = 1; /* It will be when we're done.  */
     bufp->can_be_null = 0;
 
     while (p != pend || !FAIL_STACK_EMPTY()) {
@@ -2343,17 +2348,17 @@ struct re_pattern_buffer *bufp;
 #endif
         {
 
-            /* I guess the idea here is to simply not bother with a fastmap
-             * if a backreference is used, since it's too hard to figure out
-             * the fastmap for the corresponding group.  Setting
-             * `can_be_null' stops `re_search_2' from using the fastmap, so
-             * that is all we do.  */
+        /* I guess the idea here is to simply not bother with a fastmap
+         * if a backreference is used, since it's too hard to figure out
+         * the fastmap for the corresponding group.  Setting
+         * `can_be_null' stops `re_search_2' from using the fastmap, so
+         * that is all we do.  */
         case duplicate:
             bufp->can_be_null = 1;
             return 0;
 
-            /* Following are the cases which match a character.  These end
-             * with `break'.  */
+        /* Following are the cases which match a character.  These end
+         * with `break'.  */
 
         case exactn:
             fastmap[p[1]] = 1;
@@ -2466,7 +2471,7 @@ struct re_pattern_buffer *bufp;
                 bufp->can_be_null = 1;
 
             if (succeed_n_p) {
-                EXTRACT_NUMBER_AND_INCR(k, p);	/* Skip the n.  */
+                EXTRACT_NUMBER_AND_INCR(k, p);  /* Skip the n.  */
                 succeed_n_p = false;
             }
             continue;
@@ -2479,7 +2484,7 @@ struct re_pattern_buffer *bufp;
             EXTRACT_NUMBER_AND_INCR(k, p);
             if (k == 0) {
                 p -= 4;
-                succeed_n_p = true;	/* Spaghetti code alert.  */
+                succeed_n_p = true; /* Spaghetti code alert.  */
                 goto handle_on_failure_jump;
             }
             continue;
@@ -2494,8 +2499,8 @@ struct re_pattern_buffer *bufp;
             continue;
 
         default:
-            abort();		/* We have listed all the cases.  */
-        }			/* switch *p++ */
+            abort();        /* We have listed all the cases.  */
+        }           /* switch *p++ */
 
         /* Getting here means we have found the possible starting
          * characters for one path of the pattern -- and that the empty
@@ -2505,13 +2510,13 @@ struct re_pattern_buffer *bufp;
          * does these things.  */
         path_can_be_null = false;
         p = pend;
-    }				/* while p */
+    }               /* while p */
 
     /* Set `can_be_null' for the last path (also the first path, if the
      * pattern is empty).  */
     bufp->can_be_null |= path_can_be_null;
     return 0;
-}				/* re_compile_fastmap */
+}               /* re_compile_fastmap */
 
 /* Searching routines.  */
 
@@ -2597,7 +2602,7 @@ int stop;
          * null string, however, we don't need to skip characters; we want
          * the first null string.  */
         if (fastmap && startpos < total_size && !bufp->can_be_null) {
-            if (range > 0) {	/* Searching forwards.  */
+            if (range > 0) {    /* Searching forwards.  */
                 register const char *d;
                 register int lim = 0;
                 int irange = range;
@@ -2619,7 +2624,7 @@ int stop;
                         range--;
 
                 startpos += irange - range;
-            } else {		/* Searching backwards.  */
+            } else {        /* Searching backwards.  */
                 register char c = (size1 == 0 || startpos >= size1
                                    ? string2[startpos - size1]
                                    : string1[startpos]);
@@ -2653,7 +2658,7 @@ int stop;
         }
     }
     return -1;
-}				/* re_search_2 */
+}               /* re_search_2 */
 
 /* Declarations and macros for re_match_2.  */
 
@@ -2693,22 +2698,22 @@ static boolean group_match_null_string_p(unsigned char **p, unsigned char *end,
 /* Call this when have matched a real character; it sets `matched' flags
  * for the subexpressions which we are currently inside.  Also records
  * that those subexprs have matched.  */
-#define SET_REGS_MATCHED()						\
-  do									\
-    {									\
-      unsigned r;							\
-      for (r = lowest_active_reg; r <= highest_active_reg; r++)		\
-        {								\
-          MATCHED_SOMETHING (reg_info[r])				\
-            = EVER_MATCHED_SOMETHING (reg_info[r])			\
-            = 1;							\
-        }								\
-    }									\
+#define SET_REGS_MATCHED()                      \
+  do                                    \
+    {                                   \
+      unsigned r;                           \
+      for (r = lowest_active_reg; r <= highest_active_reg; r++)     \
+        {                               \
+          MATCHED_SOMETHING (reg_info[r])               \
+            = EVER_MATCHED_SOMETHING (reg_info[r])          \
+            = 1;                            \
+        }                               \
+    }                                   \
   while (0)
 
 /* This converts PTR, a pointer into one of the search strings `string1'
  * and `string2' into an offset from the beginning of that string.  */
-#define POINTER_TO_OFFSET(ptr)						\
+#define POINTER_TO_OFFSET(ptr)                      \
   (FIRST_STRING_P (ptr) ? (ptr) - string1 : (ptr) - string2 + size1)
 
 /* Registers are set to a sentinel when they haven't yet matched.  */
@@ -2721,15 +2726,15 @@ static boolean group_match_null_string_p(unsigned char **p, unsigned char *end,
 
 /* Call before fetching a character with *d.  This switches over to
  * string2 if necessary.  */
-#define PREFETCH()							\
-  while (d == dend)						    	\
-    {									\
-      /* End of string2 => fail.  */					\
-      if (dend == end_match_2) 						\
-        goto fail;							\
-      /* End of string1 => advance to string2.  */ 			\
-      d = string2;						        \
-      dend = end_match_2;						\
+#define PREFETCH()                          \
+  while (d == dend)                             \
+    {                                   \
+      /* End of string2 => fail.  */                    \
+      if (dend == end_match_2)                      \
+        goto fail;                          \
+      /* End of string1 => advance to string2.  */          \
+      d = string2;                              \
+      dend = end_match_2;                       \
     }
 
 /* Test if at very beginning or at very end of the virtual concatenation
@@ -2744,9 +2749,9 @@ static int at_strings_end(const char *d, const char *end2)
  * two special cases to check for: if past the end of string1, look at
  * the first character in string2; and if before the beginning of
  * string2, look at the last character in string1.  */
-#define WORDCHAR_P(d)							\
-  (re_syntax_table[(d) == end1 ? *string2					\
-           : (d) == string2 - 1 ? *(end1 - 1) : *(d)]			\
+#define WORDCHAR_P(d)                           \
+  (re_syntax_table[(d) == end1 ? *string2                   \
+           : (d) == string2 - 1 ? *(end1 - 1) : *(d)]           \
    == Sword)
 static int
 wordchar_p(const char *d, const char *end1, const char *string2)
@@ -2758,25 +2763,25 @@ wordchar_p(const char *d, const char *end1, const char *string2)
 
 /* Test if the character before D and the one at D differ with respect
  * to being word-constituent.  */
-#define AT_WORD_BOUNDARY(d)						\
-  (AT_STRINGS_BEG (d) || at_strings_end(d,end2)				\
+#define AT_WORD_BOUNDARY(d)                     \
+  (AT_STRINGS_BEG (d) || at_strings_end(d,end2)             \
    || WORDCHAR_P (d - 1) != WORDCHAR_P (d))
 
 /* Free everything we malloc.  */
 #ifdef REGEX_MALLOC
 #define FREE_VAR(var) if (var) free (var); var = NULL
-#define FREE_VARIABLES()						\
-  do {									\
-    FREE_VAR (fail_stack.stack);					\
-    FREE_VAR (regstart);						\
-    FREE_VAR (regend);							\
-    FREE_VAR (old_regstart);						\
-    FREE_VAR (old_regend);						\
-    FREE_VAR (best_regstart);						\
-    FREE_VAR (best_regend);						\
-    FREE_VAR (reg_info);						\
-    FREE_VAR (reg_dummy);						\
-    FREE_VAR (reg_info_dummy);						\
+#define FREE_VARIABLES()                        \
+  do {                                  \
+    FREE_VAR (fail_stack.stack);                    \
+    FREE_VAR (regstart);                        \
+    FREE_VAR (regend);                          \
+    FREE_VAR (old_regstart);                        \
+    FREE_VAR (old_regend);                      \
+    FREE_VAR (best_regstart);                       \
+    FREE_VAR (best_regend);                     \
+    FREE_VAR (reg_info);                        \
+    FREE_VAR (reg_dummy);                       \
+    FREE_VAR (reg_info_dummy);                      \
   } while (0)
 #else /* not REGEX_MALLOC */
 /* Some MIPS systems (at least) want this to free alloca'd storage.  */
@@ -3012,15 +3017,15 @@ int stop;
     for (;;) {
         DEBUG_PRINT2("\n0x%x: ", p);
 
-        if (p == pend) {	/* End of pattern means we might have succeeded.  */
+        if (p == pend) {    /* End of pattern means we might have succeeded.  */
             DEBUG_PRINT1("end of pattern ... ");
 
             /* If we haven't matched the entire string, and we want the
              * longest match, try backtracking.  */
             if (d != end_match_2) {
                 DEBUG_PRINT1("backtracking.\n");
 
-                if (!FAIL_STACK_EMPTY()) {	/* More failure points to try.  */
+                if (!FAIL_STACK_EMPTY()) {  /* More failure points to try.  */
                     boolean same_str_p = (FIRST_STRING_P(match_end)
                                           == MATCHING_IN_FIRST_STRING);
 
@@ -3059,24 +3064,26 @@ int stop;
                         regend[mcnt] = best_regend[mcnt];
                     }
                 }
-            }			/* d != end_match_2 */
+            }           /* d != end_match_2 */
             DEBUG_PRINT1("Accepting match.\n");
 
             /* If caller wants register contents data back, do it.  */
             if (regs && !bufp->no_sub) {
                 /* Have the register data arrays been allocated?  */
-                if (bufp->regs_allocated == REGS_UNALLOCATED) {		/* No.  So allocate them with malloc.  We need one
-									 * extra element beyond `num_regs' for the `-1' marker
-									 * GNU code uses.  */
+                if (bufp->regs_allocated == REGS_UNALLOCATED) {
+                    /* No.  So allocate them with malloc.  We need one
+                                         * extra element beyond `num_regs' for the `-1' marker
+                                         * GNU code uses.  */
                     regs->num_regs = max(RE_NREGS, num_regs + 1);
                     regs->start = TALLOC(regs->num_regs, regoff_t);
                     regs->end = TALLOC(regs->num_regs, regoff_t);
                     if (regs->start == NULL || regs->end == NULL)
                         return -2;
                     bufp->regs_allocated = REGS_REALLOCATE;
-                } else if (bufp->regs_allocated == REGS_REALLOCATE) {	/* Yes.  If we need more elements than were already
-									 * allocated, reallocate them.  If we need fewer, just
-									 * leave it alone.  */
+                } else if (bufp->regs_allocated == REGS_REALLOCATE) {
+                    /* Yes.  If we need more elements than were already
+                                         * allocated, reallocate them.  If we need fewer, just
+                                         * leave it alone.  */
                     if (regs->num_regs < num_regs + 1) {
                         regs->num_regs = num_regs + 1;
                         RETALLOC(regs->start, regs->num_regs, regoff_t);
@@ -3113,7 +3120,7 @@ int stop;
                  * -1 at the end.  */
                 for (mcnt = num_regs; mcnt < regs->num_regs; mcnt++)
                     regs->start[mcnt] = regs->end[mcnt] = -1;
-            }			/* regs && !bufp->no_sub */
+            }           /* regs && !bufp->no_sub */
             FREE_VARIABLES();
             DEBUG_PRINT4("%u failure points pushed, %u popped (%u remain).\n",
                          nfailure_points_pushed, nfailure_points_popped,
@@ -3135,15 +3142,15 @@ int stop;
         switch ((re_opcode_t) * p++)
 #endif
         {
-            /* Ignore these.  Used to ignore the n of succeed_n's which
-             * currently have n == 0.  */
+        /* Ignore these.  Used to ignore the n of succeed_n's which
+         * currently have n == 0.  */
         case no_op:
             DEBUG_PRINT1("EXECUTING no_op.\n");
             break;
 
-            /* Match the next n pattern characters exactly.  The following
-             * byte in the pattern defines n, and the n bytes after that
-             * are the characters to match.  */
+        /* Match the next n pattern characters exactly.  The following
+         * byte in the pattern defines n, and the n bytes after that
+         * are the characters to match.  */
         case exactn:
             mcnt = *p++;
             DEBUG_PRINT2("EXECUTING exactn %d.\n", mcnt);
@@ -3166,7 +3173,7 @@ int stop;
             SET_REGS_MATCHED();
             break;
 
-            /* Match any character except possibly a newline or a null.  */
+        /* Match any character except possibly a newline or a null.  */
         case anychar:
             DEBUG_PRINT1("EXECUTING anychar.\n");
 
@@ -3189,7 +3196,7 @@ int stop;
             DEBUG_PRINT2("EXECUTING charset%s.\n", not ? "_not" : "");
 
             PREFETCH();
-            c = TRANSLATE(*d);	/* The character to match.  */
+            c = TRANSLATE(*d);  /* The character to match.  */
 
             /* Cast to `unsigned' instead of `unsigned char' in case the
              * bit list is a full 32 bytes long.  */
@@ -3216,11 +3223,11 @@ int stop;
             DEBUG_PRINT3("EXECUTING start_memory %d (%d):\n", *p, p[1]);
 
             /* Find out if this group can match the empty string.  */
-            p1 = p;		/* To send to group_match_null_string_p.  */
+            p1 = p;     /* To send to group_match_null_string_p.  */
 
             if (REG_MATCH_NULL_STRING_P(reg_info[*p]) == MATCH_NULL_UNSET_VALUE)
                 REG_MATCH_NULL_STRING_P(reg_info[*p])
-                = group_match_null_string_p(&p1, pend, reg_info);
+                    = group_match_null_string_p(&p1, pend, reg_info);
 
             /* Save the position in the string where we were the last time
              * we were at this open-group operator in case the group is
@@ -3229,7 +3236,7 @@ int stop;
              * the string in case this attempt to match fails.  */
             old_regstart[*p] = REG_MATCH_NULL_STRING_P(reg_info[*p])
                                ? REG_UNSET(regstart[*p]) ? d : regstart[*p]
-                   : regstart[*p];
+                               : regstart[*p];
             DEBUG_PRINT2("  old_regstart: %d\n",
                          POINTER_TO_OFFSET(old_regstart[*p]));
 
@@ -3251,9 +3258,9 @@ int stop;
             p += 2;
             break;
 
-            /* The stop_memory opcode represents the end of a group.  Its
-             * arguments are the same as start_memory's: the register
-             * number, and the number of inner groups.  */
+        /* The stop_memory opcode represents the end of a group.  Its
+         * arguments are the same as start_memory's: the register
+         * number, and the number of inner groups.  */
         case stop_memory:
             DEBUG_PRINT3("EXECUTING stop_memory %d (%d):\n", *p, p[1]);
 
@@ -3264,7 +3271,7 @@ int stop;
              * the string in case this attempt to match fails.  */
             old_regend[*p] = REG_MATCH_NULL_STRING_P(reg_info[*p])
                              ? REG_UNSET(regend[*p]) ? d : regend[*p]
-                 : regend[*p];
+                             : regend[*p];
             DEBUG_PRINT2("      old_regend: %d\n",
                          POINTER_TO_OFFSET(old_regend[*p]));
 
@@ -3279,10 +3286,11 @@ int stop;
             if (lowest_active_reg == highest_active_reg) {
                 lowest_active_reg = NO_LOWEST_ACTIVE_REG;
                 highest_active_reg = NO_HIGHEST_ACTIVE_REG;
-            } else {		/* We must scan for the new highest active register, since
-				 * it isn't necessarily one less than now: consider
-				 * (a(b)c(d(e)f)g).  When group 3 ends, after the f), the
-				 * new highest active register is 1.  */
+            } else {
+                /* We must scan for the new highest active register, since
+                     * it isn't necessarily one less than now: consider
+                     * (a(b)c(d(e)f)g).  When group 3 ends, after the f), the
+                     * new highest active register is 1.  */
                 unsigned char r = *p - 1;
                 while (r > 0 && !IS_ACTIVE(reg_info[r]))
                     r--;
@@ -3373,11 +3381,11 @@ int stop;
             p += 2;
             break;
 
-            /* \<digit> has been turned into a `duplicate' command which is
-             * followed by the numeric value of <digit> as the register number.  */
+        /* \<digit> has been turned into a `duplicate' command which is
+         * followed by the numeric value of <digit> as the register number.  */
         case duplicate: {
             register const char *d2, *dend2;
-            int regno = *p++;	/* Get which register to match against.  */
+            int regno = *p++;   /* Get which register to match against.  */
             DEBUG_PRINT2("EXECUTING duplicate %d.\n", regno);
 
             /* Can't back reference a group which we've never matched.  */
@@ -3449,7 +3457,7 @@ int stop;
             /* In all other cases, we fail.  */
             goto fail;
 
-            /* endline is the dual of begline.  */
+        /* endline is the dual of begline.  */
         case endline:
             DEBUG_PRINT1("EXECUTING endline.\n");
 
@@ -3464,36 +3472,36 @@ int stop;
             }
             goto fail;
 
-            /* Match at the very beginning of the data.  */
+        /* Match at the very beginning of the data.  */
         case begbuf:
             DEBUG_PRINT1("EXECUTING begbuf.\n");
             if (AT_STRINGS_BEG(d))
                 break;
             goto fail;
 
-            /* Match at the very end of the data.  */
+        /* Match at the very end of the data.  */
         case endbuf:
             DEBUG_PRINT1("EXECUTING endbuf.\n");
             if (at_strings_end(d,end2))
                 break;
             goto fail;
 
-            /* on_failure_keep_string_jump is used to optimize `.*\n'.  It
-             * pushes NULL as the value for the string on the stack.  Then
-             * `pop_failure_point' will keep the current value for the
-             * string, instead of restoring it.  To see why, consider
-             * matching `foo\nbar' against `.*\n'.  The .* matches the foo;
-             * then the . fails against the \n.  But the next thing we want
-             * to do is match the \n against the \n; if we restored the
-             * string value, we would be back at the foo.
-             *
-             * Because this is used only in specific cases, we don't need to
-             * check all the things that `on_failure_jump' does, to make
-             * sure the right things get saved on the stack.  Hence we don't
-             * share its code.  The only reason to push anything on the
-             * stack at all is that otherwise we would have to change
-             * `anychar's code to do something besides goto fail in this
-             * case; that seems worse than this.  */
+        /* on_failure_keep_string_jump is used to optimize `.*\n'.  It
+         * pushes NULL as the value for the string on the stack.  Then
+         * `pop_failure_point' will keep the current value for the
+         * string, instead of restoring it.  To see why, consider
+         * matching `foo\nbar' against `.*\n'.  The .* matches the foo;
+         * then the . fails against the \n.  But the next thing we want
+         * to do is match the \n against the \n; if we restored the
+         * string value, we would be back at the foo.
+         *
+         * Because this is used only in specific cases, we don't need to
+         * check all the things that `on_failure_jump' does, to make
+         * sure the right things get saved on the stack.  Hence we don't
+         * share its code.  The only reason to push anything on the
+         * stack at all is that otherwise we would have to change
+         * `anychar's code to do something besides goto fail in this
+         * case; that seems worse than this.  */
         case on_failure_keep_string_jump:
             DEBUG_PRINT1("EXECUTING on_failure_keep_string_jump");
 
@@ -3503,18 +3511,18 @@ int stop;
             PUSH_FAILURE_POINT(p + mcnt, NULL, -2);
             break;
 
-            /* Uses of on_failure_jump:
-             *
-             * Each alternative starts with an on_failure_jump that points
-             * to the beginning of the next alternative.  Each alternative
-             * except the last ends with a jump that in effect jumps past
-             * the rest of the alternatives.  (They really jump to the
-             * ending jump of the following alternative, because tensioning
-             * these jumps is a hassle.)
-             *
-             * Repeats start with an on_failure_jump that points past both
-             * the repetition text and either the following jump or
-             * pop_failure_jump back to this on_failure_jump.  */
+        /* Uses of on_failure_jump:
+         *
+         * Each alternative starts with an on_failure_jump that points
+         * to the beginning of the next alternative.  Each alternative
+         * except the last ends with a jump that in effect jumps past
+         * the rest of the alternatives.  (They really jump to the
+         * ending jump of the following alternative, because tensioning
+         * these jumps is a hassle.)
+         *
+         * Repeats start with an on_failure_jump that points past both
+         * the repetition text and either the following jump or
+         * pop_failure_jump back to this on_failure_jump.  */
         case on_failure_jump:
 on_failure:
             DEBUG_PRINT1("EXECUTING on_failure_jump");
@@ -3553,8 +3561,8 @@ int stop;
             PUSH_FAILURE_POINT(p + mcnt, d, -2);
             break;
 
-            /* A smart repeat ends with `maybe_pop_jump'.
-             * We change it to either `pop_failure_jump' or `jump'.  */
+        /* A smart repeat ends with `maybe_pop_jump'.
+         * We change it to either `pop_failure_jump' or `jump'.  */
         case maybe_pop_jump:
             EXTRACT_NUMBER_AND_INCR(mcnt, p);
             DEBUG_PRINT2("EXECUTING maybe_pop_jump %d.\n", mcnt);
@@ -3578,7 +3586,7 @@ int stop;
                 while (p2 + 2 < pend
                         && ((re_opcode_t) * p2 == stop_memory
                             || (re_opcode_t) * p2 == start_memory))
-                    p2 += 3;	/* Skip over args, too.  */
+                    p2 += 3;    /* Skip over args, too.  */
 
                 /* If we're at the end of the pattern, we can change.  */
                 if (p2 == pend) {
@@ -3591,7 +3599,7 @@ int stop;
                 } else if ((re_opcode_t) * p2 == exactn
                            || (bufp->newline_anchor && (re_opcode_t) * p2 == endline)) {
                     register unsigned char c
-                    = *p2 == (unsigned char) endline ? '\n' : p2[2];
+                        = *p2 == (unsigned char) endline ? '\n' : p2[2];
                     p1 = p + mcnt;
 
                     /* p1[0] ... p1[2] are the `on_failure_jump' corresponding
@@ -3618,20 +3626,20 @@ int stop;
                     }
                 }
             }
-            p -= 2;		/* Point at relative address again.  */
+            p -= 2;     /* Point at relative address again.  */
             if ((re_opcode_t) p[-1] != pop_failure_jump) {
                 p[-1] = (unsigned char) jump;
                 DEBUG_PRINT1("  Match => jump.\n");
                 goto unconditional_jump;
             }
-            /* Note fall through.  */
-
-            /* The end of a simple repeat has a pop_failure_jump back to
-             * its matching on_failure_jump, where the latter will push a
-             * failure point.  The pop_failure_jump takes off failure
-             * points put on by this pop_failure_jump's matching
-             * on_failure_jump; we got through the pattern to here from the
-             * matching on_failure_jump, so didn't fail.  */
+        /* Note fall through.  */
+
+        /* The end of a simple repeat has a pop_failure_jump back to
+         * its matching on_failure_jump, where the latter will push a
+         * failure point.  The pop_failure_jump takes off failure
+         * points put on by this pop_failure_jump's matching
+         * on_failure_jump; we got through the pattern to here from the
+         * matching on_failure_jump, so didn't fail.  */
         case pop_failure_jump: {
             /* We need to pass separate storage for the lowest and
              * highest registers, even though we don't care about the
@@ -3655,44 +3663,44 @@ int stop;
         /* Unconditionally jump (without popping any failure points).  */
         case jump:
 unconditional_jump:
-            EXTRACT_NUMBER_AND_INCR(mcnt, p);	/* Get the amount to jump.  */
+            EXTRACT_NUMBER_AND_INCR(mcnt, p);   /* Get the amount to jump.  */
             DEBUG_PRINT2("EXECUTING jump %d ", mcnt);
-            p += mcnt;		/* Do the jump.  */
+            p += mcnt;      /* Do the jump.  */
             DEBUG_PRINT2("(to 0x%x).\n", p);
             break;
 
-            /* We need this opcode so we can detect where alternatives end
-             * in `group_match_null_string_p' et al.  */
+        /* We need this opcode so we can detect where alternatives end
+         * in `group_match_null_string_p' et al.  */
         case jump_past_alt:
             DEBUG_PRINT1("EXECUTING jump_past_alt.\n");
             goto unconditional_jump;
 
-            /* Normally, the on_failure_jump pushes a failure point, which
-             * then gets popped at pop_failure_jump.  We will end up at
-             * pop_failure_jump, also, and with a pattern of, say, `a+', we
-             * are skipping over the on_failure_jump, so we have to push
-             * something meaningless for pop_failure_jump to pop.  */
+        /* Normally, the on_failure_jump pushes a failure point, which
+         * then gets popped at pop_failure_jump.  We will end up at
+         * pop_failure_jump, also, and with a pattern of, say, `a+', we
+         * are skipping over the on_failure_jump, so we have to push
+         * something meaningless for pop_failure_jump to pop.  */
         case dummy_failure_jump:
             DEBUG_PRINT1("EXECUTING dummy_failure_jump.\n");
             /* It doesn't matter what we push for the string here.  What
              * the code at `fail' tests is the value for the pattern.  */
             PUSH_FAILURE_POINT(0, 0, -2);
             goto unconditional_jump;
 
-            /* At the end of an alternative, we need to push a dummy failure
-             * point in case we are followed by a `pop_failure_jump', because
-             * we don't want the failure point for the alternative to be
-             * popped.  For example, matching `(a|ab)*' against `aab'
-             * requires that we match the `ab' alternative.  */
+        /* At the end of an alternative, we need to push a dummy failure
+         * point in case we are followed by a `pop_failure_jump', because
+         * we don't want the failure point for the alternative to be
+         * popped.  For example, matching `(a|ab)*' against `aab'
+         * requires that we match the `ab' alternative.  */
         case push_dummy_failure:
             DEBUG_PRINT1("EXECUTING push_dummy_failure.\n");
             /* See comments just above at `dummy_failure_jump' about the
              * two zeroes.  */
             PUSH_FAILURE_POINT(0, 0, -2);
             break;
 
-            /* Have to succeed matching what follows at least n times.
-             * After that, handle like `on_failure_jump'.  */
+        /* Have to succeed matching what follows at least n times.
+         * After that, handle like `on_failure_jump'.  */
         case succeed_n:
             EXTRACT_NUMBER(mcnt, p + 2);
             DEBUG_PRINT2("EXECUTING succeed_n %d.\n", mcnt);
@@ -3784,11 +3792,11 @@ int stop;
         default:
             abort();
         }
-        continue;		/* Successfully executed one pattern command; keep going.  */
+        continue;       /* Successfully executed one pattern command; keep going.  */
 
         /* We goto here if a matching operation fails. */
 fail:
-        if (!FAIL_STACK_EMPTY()) {	/* A restart point is known.  Restore to that state.  */
+        if (!FAIL_STACK_EMPTY()) {  /* A restart point is known.  Restore to that state.  */
             DEBUG_PRINT1("\nFAIL:\n");
             POP_FAILURE_POINT(d, p,
                               lowest_active_reg, highest_active_reg,
@@ -3828,16 +3836,16 @@ int stop;
             if (d >= string1 && d <= end1)
                 dend = end_match_1;
         } else
-            break;		/* Matching at this starting point really fails.  */
-    }				/* for (;;) */
+            break;      /* Matching at this starting point really fails.  */
+    }               /* for (;;) */
 
     if (best_regs_set)
         goto restore_best_regs;
 
     FREE_VARIABLES();
 
-    return -1;			/* Failure to match.  */
-}				/* re_match_2 */
+    return -1;          /* Failure to match.  */
+}               /* re_match_2 */
 
 /* Subroutine definitions for re_match_2.  */
 
@@ -3864,7 +3872,7 @@ group_match_null_string_p(unsigned char **p, unsigned char *end, register_info_t
          * matching stop_memory.  */
 
         switch ((re_opcode_t) * p1) {
-            /* Could be either a loop or a series of alternatives.  */
+        /* Could be either a loop or a series of alternatives.  */
         case on_failure_jump:
             p1++;
             EXTRACT_NUMBER_AND_INCR(mcnt, p1);
@@ -3927,8 +3935,8 @@ group_match_null_string_p(unsigned char **p, unsigned char *end, register_info_t
                 if (!alt_match_null_string_p(p1, p1 + mcnt, reg_info))
                     return false;
 
-                p1 += mcnt;	/* Get past the n-th alternative.  */
-            }			/* if mcnt > 0 */
+                p1 += mcnt; /* Get past the n-th alternative.  */
+            }           /* if mcnt > 0 */
             break;
 
         case stop_memory:
@@ -3940,10 +3948,10 @@ group_match_null_string_p(unsigned char **p, unsigned char *end, register_info_t
             if (!common_op_match_null_string_p(&p1, end, reg_info))
                 return false;
         }
-    }				/* while p1 < end */
+    }               /* while p1 < end */
 
     return false;
-}				/* group_match_null_string_p */
+}               /* group_match_null_string_p */
 
 /* Similar to group_match_null_string_p, but doesn't deal with alternatives:
  * It expects P to be the first byte of a single alternative and END one
@@ -3960,7 +3968,7 @@ alt_match_null_string_p(unsigned char *p, unsigned char *end, register_info_type
          * to one that can't.  */
 
         switch ((re_opcode_t) * p1) {
-            /* It's a loop.  */
+        /* It's a loop.  */
         case on_failure_jump:
             p1++;
             EXTRACT_NUMBER_AND_INCR(mcnt, p1);
@@ -3971,10 +3979,10 @@ alt_match_null_string_p(unsigned char *p, unsigned char *end, register_info_type
             if (!common_op_match_null_string_p(&p1, end, reg_info))
                 return false;
         }
-    }				/* while p1 < end */
+    }               /* while p1 < end */
 
     return true;
-}				/* alt_match_null_string_p */
+}               /* alt_match_null_string_p */
 
 /* Deals with the ops common to group_match_null_string_p and
  * alt_match_null_string_p.
@@ -4016,7 +4024,7 @@ common_op_match_null_string_p( unsigned char **p, unsigned char *end, register_i
             return false;
         break;
 
-        /* If this is an optimized succeed_n for zero times, make the jump.  */
+    /* If this is an optimized succeed_n for zero times, make the jump.  */
     case jump:
         EXTRACT_NUMBER_AND_INCR(mcnt, p1);
         if (mcnt >= 0)
@@ -4053,7 +4061,7 @@ common_op_match_null_string_p( unsigned char **p, unsigned char *end, register_i
 
     *p = p1;
     return true;
-}				/* common_op_match_null_string_p */
+}               /* common_op_match_null_string_p */
 
 /* Return zero if TRANSLATE[S1] and TRANSLATE[S2] are identical for LEN
  * bytes; nonzero otherwise.  */
@@ -4116,8 +4124,8 @@ int cflags;
 {
     reg_errcode_t ret;
     unsigned syntax
-    = (cflags & REG_EXTENDED) ?
-      RE_SYNTAX_POSIX_EXTENDED : RE_SYNTAX_POSIX_BASIC;
+        = (cflags & REG_EXTENDED) ?
+          RE_SYNTAX_POSIX_EXTENDED : RE_SYNTAX_POSIX_BASIC;
 
     /* regex_compile will allocate the space for the compiled pattern.  */
     preg->buffer = 0;
@@ -4143,7 +4151,7 @@ int cflags;
         preg->translate = NULL;
 
     /* If REG_NEWLINE is set, newlines are treated differently.  */
-    if (cflags & REG_NEWLINE) {	/* REG_NEWLINE implies neither . nor [^...] match newline.  */
+    if (cflags & REG_NEWLINE) { /* REG_NEWLINE implies neither . nor [^...] match newline.  */
         syntax &= ~RE_DOT_NEWLINE;
         syntax |= RE_HAT_LISTS_NOT_NEWLINE;
         /* It also changes the matching behavior.  */
@@ -4257,7 +4265,7 @@ regerror(int errcode, const regex_t *preg, char *errbuf, size_t errbuf_size)
     if (!msg)
         msg = "Success";
 
-    msg_size = strlen(msg) + 1;	/* Includes the null.  */
+    msg_size = strlen(msg) + 1; /* Includes the null.  */
 
     if (errbuf_size != 0) {
         if (msg_size > errbuf_size) {
@@ -4300,3 +4308,4 @@ regex_t *preg;
  * trim-versions-without-asking: nil
  * End:
  */
+
@@ -26,375 +26,375 @@
 extern "C" {
 #endif
 
-    /* Definitions for data structures and routines for the regular
-     * expression library, version 0.12.
-     *
-     * Copyright (C) 1985, 1989, 1990, 1991, 1992, 1993 Free Software Foundation, Inc.
-     *
-     * This program is free software; you can redistribute it and/or modify
-     * it under the terms of the GNU General Public License as published by
-     * the Free Software Foundation; either version 2, or (at your option)
-     * any later version.
-     *
-     * This program is distributed in the hope that it will be useful,
-     * but WITHOUT ANY WARRANTY; without even the implied warranty of
-     * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-     * GNU General Public License for more details.
-     *
-     * You should have received a copy of the GNU General Public License
-     * along with this program; if not, write to the Free Software
-     * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.  */
-
-    /* POSIX says that <sys/types.h> must be included (by the caller) before
-     * <regex.h>.  */
-
-    /* The following bits are used to determine the regexp syntax we
-     * recognize.  The set/not-set meanings are chosen so that Emacs syntax
-     * remains the value 0.  The bits are given in alphabetical order, and
-     * the definitions shifted by one from the previous bit; thus, when we
-     * add or remove a bit, only one other definition need change.  */
-    typedef unsigned reg_syntax_t;
-
-    /* If this bit is not set, then \ inside a bracket expression is literal.
-     * If set, then such a \ quotes the following character.  */
+/* Definitions for data structures and routines for the regular
+ * expression library, version 0.12.
+ *
+ * Copyright (C) 1985, 1989, 1990, 1991, 1992, 1993 Free Software Foundation, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.  */
+
+/* POSIX says that <sys/types.h> must be included (by the caller) before
+ * <regex.h>.  */
+
+/* The following bits are used to determine the regexp syntax we
+ * recognize.  The set/not-set meanings are chosen so that Emacs syntax
+ * remains the value 0.  The bits are given in alphabetical order, and
+ * the definitions shifted by one from the previous bit; thus, when we
+ * add or remove a bit, only one other definition need change.  */
+typedef unsigned reg_syntax_t;
+
+/* If this bit is not set, then \ inside a bracket expression is literal.
+ * If set, then such a \ quotes the following character.  */
 #define RE_BACKSLASH_ESCAPE_IN_LISTS (1)
 
-    /* If this bit is not set, then + and ? are operators, and \+ and \? are
-     * literals.
-     * If set, then \+ and \? are operators and + and ? are literals.  */
+/* If this bit is not set, then + and ? are operators, and \+ and \? are
+ * literals.
+ * If set, then \+ and \? are operators and + and ? are literals.  */
 #define RE_BK_PLUS_QM (RE_BACKSLASH_ESCAPE_IN_LISTS << 1)
 
-    /* If this bit is set, then character classes are supported.  They are:
-     * [:alpha:], [:upper:], [:lower:],  [:digit:], [:alnum:], [:xdigit:],
-     * [:space:], [:print:], [:punct:], [:graph:], and [:cntrl:].
-     * If not set, then character classes are not supported.  */
+/* If this bit is set, then character classes are supported.  They are:
+ * [:alpha:], [:upper:], [:lower:],  [:digit:], [:alnum:], [:xdigit:],
+ * [:space:], [:print:], [:punct:], [:graph:], and [:cntrl:].
+ * If not set, then character classes are not supported.  */
 #define RE_CHAR_CLASSES (RE_BK_PLUS_QM << 1)
 
-    /* If this bit is set, then ^ and $ are always anchors (outside bracket
-     * expressions, of course).
-     * If this bit is not set, then it depends:
-     * ^  is an anchor if it is at the beginning of a regular
-     * expression or after an open-group or an alternation operator;
-     * $  is an anchor if it is at the end of a regular expression, or
-     * before a close-group or an alternation operator.
-     *
-     * This bit could be (re)combined with RE_CONTEXT_INDEP_OPS, because
-     * POSIX draft 11.2 says that * etc. in leading positions is undefined.
-     * We already implemented a previous draft which made those constructs
-     * invalid, though, so we haven't changed the code back.  */
+/* If this bit is set, then ^ and $ are always anchors (outside bracket
+ * expressions, of course).
+ * If this bit is not set, then it depends:
+ * ^  is an anchor if it is at the beginning of a regular
+ * expression or after an open-group or an alternation operator;
+ * $  is an anchor if it is at the end of a regular expression, or
+ * before a close-group or an alternation operator.
+ *
+ * This bit could be (re)combined with RE_CONTEXT_INDEP_OPS, because
+ * POSIX draft 11.2 says that * etc. in leading positions is undefined.
+ * We already implemented a previous draft which made those constructs
+ * invalid, though, so we haven't changed the code back.  */
 #define RE_CONTEXT_INDEP_ANCHORS (RE_CHAR_CLASSES << 1)
 
-    /* If this bit is set, then special characters are always special
-     * regardless of where they are in the pattern.
-     * If this bit is not set, then special characters are special only in
-     * some contexts; otherwise they are ordinary.  Specifically,
-     * * + ? and intervals are only special when not after the beginning,
-     * open-group, or alternation operator.  */
+/* If this bit is set, then special characters are always special
+ * regardless of where they are in the pattern.
+ * If this bit is not set, then special characters are special only in
+ * some contexts; otherwise they are ordinary.  Specifically,
+ * * + ? and intervals are only special when not after the beginning,
+ * open-group, or alternation operator.  */
 #define RE_CONTEXT_INDEP_OPS (RE_CONTEXT_INDEP_ANCHORS << 1)
 
-    /* If this bit is set, then *, +, ?, and { cannot be first in an re or
-     * immediately after an alternation or begin-group operator.  */
+/* If this bit is set, then *, +, ?, and { cannot be first in an re or
+ * immediately after an alternation or begin-group operator.  */
 #define RE_CONTEXT_INVALID_OPS (RE_CONTEXT_INDEP_OPS << 1)
 
-    /* If this bit is set, then . matches newline.
-     * If not set, then it doesn't.  */
+/* If this bit is set, then . matches newline.
+ * If not set, then it doesn't.  */
 #define RE_DOT_NEWLINE (RE_CONTEXT_INVALID_OPS << 1)
 
-    /* If this bit is set, then . doesn't match NUL.
-     * If not set, then it does.  */
+/* If this bit is set, then . doesn't match NUL.
+ * If not set, then it does.  */
 #define RE_DOT_NOT_NULL (RE_DOT_NEWLINE << 1)
 
-    /* If this bit is set, nonmatching lists [^...] do not match newline.
-     * If not set, they do.  */
+/* If this bit is set, nonmatching lists [^...] do not match newline.
+ * If not set, they do.  */
 #define RE_HAT_LISTS_NOT_NEWLINE (RE_DOT_NOT_NULL << 1)
 
-    /* If this bit is set, either \{...\} or {...} defines an
-     * interval, depending on RE_NO_BK_BRACES.
-     * If not set, \{, \}, {, and } are literals.  */
+/* If this bit is set, either \{...\} or {...} defines an
+ * interval, depending on RE_NO_BK_BRACES.
+ * If not set, \{, \}, {, and } are literals.  */
 #define RE_INTERVALS (RE_HAT_LISTS_NOT_NEWLINE << 1)
 
-    /* If this bit is set, +, ? and | aren't recognized as operators.
-     * If not set, they are.  */
+/* If this bit is set, +, ? and | aren't recognized as operators.
+ * If not set, they are.  */
 #define RE_LIMITED_OPS (RE_INTERVALS << 1)
 
-    /* If this bit is set, newline is an alternation operator.
-     * If not set, newline is literal.  */
+/* If this bit is set, newline is an alternation operator.
+ * If not set, newline is literal.  */
 #define RE_NEWLINE_ALT (RE_LIMITED_OPS << 1)
 
-    /* If this bit is set, then `{...}' defines an interval, and \{ and \}
-     * are literals.
-     * If not set, then `\{...\}' defines an interval.  */
+/* If this bit is set, then `{...}' defines an interval, and \{ and \}
+ * are literals.
+ * If not set, then `\{...\}' defines an interval.  */
 #define RE_NO_BK_BRACES (RE_NEWLINE_ALT << 1)
 
-    /* If this bit is set, (...) defines a group, and \( and \) are literals.
-     * If not set, \(...\) defines a group, and ( and ) are literals.  */
+/* If this bit is set, (...) defines a group, and \( and \) are literals.
+ * If not set, \(...\) defines a group, and ( and ) are literals.  */
 #define RE_NO_BK_PARENS (RE_NO_BK_BRACES << 1)
 
-    /* If this bit is set, then \<digit> matches <digit>.
-     * If not set, then \<digit> is a back-reference.  */
+/* If this bit is set, then \<digit> matches <digit>.
+ * If not set, then \<digit> is a back-reference.  */
 #define RE_NO_BK_REFS (RE_NO_BK_PARENS << 1)
 
-    /* If this bit is set, then | is an alternation operator, and \| is literal.
-     * If not set, then \| is an alternation operator, and | is literal.  */
+/* If this bit is set, then | is an alternation operator, and \| is literal.
+ * If not set, then \| is an alternation operator, and | is literal.  */
 #define RE_NO_BK_VBAR (RE_NO_BK_REFS << 1)
 
-    /* If this bit is set, then an ending range point collating higher
-     * than the starting range point, as in [z-a], is invalid.
-     * If not set, then when ending range point collates higher than the
-     * starting range point, the range is ignored.  */
+/* If this bit is set, then an ending range point collating higher
+ * than the starting range point, as in [z-a], is invalid.
+ * If not set, then when ending range point collates higher than the
+ * starting range point, the range is ignored.  */
 #define RE_NO_EMPTY_RANGES (RE_NO_BK_VBAR << 1)
 
-    /* If this bit is set, then an unmatched ) is ordinary.
-     * If not set, then an unmatched ) is invalid.  */
+/* If this bit is set, then an unmatched ) is ordinary.
+ * If not set, then an unmatched ) is invalid.  */
 #define RE_UNMATCHED_RIGHT_PAREN_ORD (RE_NO_EMPTY_RANGES << 1)
 
-    /* Define combinations of the above bits for the standard possibilities.
-     * (The [[[ comments delimit what gets put into the Texinfo file, so
-     * don't delete them!)  */
-    /* [[[begin syntaxes]]] */
+/* Define combinations of the above bits for the standard possibilities.
+ * (The [[[ comments delimit what gets put into the Texinfo file, so
+ * don't delete them!)  */
+/* [[[begin syntaxes]]] */
 #define RE_SYNTAX_EMACS 0
 
-#define RE_SYNTAX_AWK							\
-  (RE_BACKSLASH_ESCAPE_IN_LISTS | RE_DOT_NOT_NULL			\
-   | RE_NO_BK_PARENS            | RE_NO_BK_REFS				\
-   | RE_NO_BK_VBAR               | RE_NO_EMPTY_RANGES			\
+#define RE_SYNTAX_AWK                           \
+  (RE_BACKSLASH_ESCAPE_IN_LISTS | RE_DOT_NOT_NULL           \
+   | RE_NO_BK_PARENS            | RE_NO_BK_REFS             \
+   | RE_NO_BK_VBAR               | RE_NO_EMPTY_RANGES           \
    | RE_UNMATCHED_RIGHT_PAREN_ORD)
 
-#define RE_SYNTAX_POSIX_AWK 						\
+#define RE_SYNTAX_POSIX_AWK                         \
   (RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS)
 
-#define RE_SYNTAX_GREP							\
-  (RE_BK_PLUS_QM              | RE_CHAR_CLASSES				\
-   | RE_HAT_LISTS_NOT_NEWLINE | RE_INTERVALS				\
+#define RE_SYNTAX_GREP                          \
+  (RE_BK_PLUS_QM              | RE_CHAR_CLASSES             \
+   | RE_HAT_LISTS_NOT_NEWLINE | RE_INTERVALS                \
    | RE_NEWLINE_ALT)
 
-#define RE_SYNTAX_EGREP							\
-  (RE_CHAR_CLASSES        | RE_CONTEXT_INDEP_ANCHORS			\
-   | RE_CONTEXT_INDEP_OPS | RE_HAT_LISTS_NOT_NEWLINE			\
-   | RE_NEWLINE_ALT       | RE_NO_BK_PARENS				\
+#define RE_SYNTAX_EGREP                         \
+  (RE_CHAR_CLASSES        | RE_CONTEXT_INDEP_ANCHORS            \
+   | RE_CONTEXT_INDEP_OPS | RE_HAT_LISTS_NOT_NEWLINE            \
+   | RE_NEWLINE_ALT       | RE_NO_BK_PARENS             \
    | RE_NO_BK_VBAR)
 
-#define RE_SYNTAX_POSIX_EGREP						\
+#define RE_SYNTAX_POSIX_EGREP                       \
   (RE_SYNTAX_EGREP | RE_INTERVALS | RE_NO_BK_BRACES)
 
-    /* P1003.2/D11.2, section 4.20.7.1, lines 5078ff.  */
+/* P1003.2/D11.2, section 4.20.7.1, lines 5078ff.  */
 #define RE_SYNTAX_ED RE_SYNTAX_POSIX_BASIC
 
 #define RE_SYNTAX_SED RE_SYNTAX_POSIX_BASIC
 
-    /* Syntax bits common to both basic and extended POSIX regex syntax.  */
-#define _RE_SYNTAX_POSIX_COMMON						\
-  (RE_CHAR_CLASSES | RE_DOT_NEWLINE      | RE_DOT_NOT_NULL		\
+/* Syntax bits common to both basic and extended POSIX regex syntax.  */
+#define _RE_SYNTAX_POSIX_COMMON                     \
+  (RE_CHAR_CLASSES | RE_DOT_NEWLINE      | RE_DOT_NOT_NULL      \
    | RE_INTERVALS  | RE_NO_EMPTY_RANGES)
 
-#define RE_SYNTAX_POSIX_BASIC						\
+#define RE_SYNTAX_POSIX_BASIC                       \
   (_RE_SYNTAX_POSIX_COMMON | RE_BK_PLUS_QM)
 
-    /* Differs from ..._POSIX_BASIC only in that RE_BK_PLUS_QM becomes
-     * RE_LIMITED_OPS, i.e., \? \+ \| are not recognized.  Actually, this
-     * isn't minimal, since other operators, such as \`, aren't disabled.  */
-#define RE_SYNTAX_POSIX_MINIMAL_BASIC					\
+/* Differs from ..._POSIX_BASIC only in that RE_BK_PLUS_QM becomes
+ * RE_LIMITED_OPS, i.e., \? \+ \| are not recognized.  Actually, this
+ * isn't minimal, since other operators, such as \`, aren't disabled.  */
+#define RE_SYNTAX_POSIX_MINIMAL_BASIC                   \
   (_RE_SYNTAX_POSIX_COMMON | RE_LIMITED_OPS)
 
-#define RE_SYNTAX_POSIX_EXTENDED					\
-  (_RE_SYNTAX_POSIX_COMMON | RE_CONTEXT_INDEP_ANCHORS			\
-   | RE_CONTEXT_INDEP_OPS  | RE_NO_BK_BRACES				\
-   | RE_NO_BK_PARENS       | RE_NO_BK_VBAR				\
+#define RE_SYNTAX_POSIX_EXTENDED                    \
+  (_RE_SYNTAX_POSIX_COMMON | RE_CONTEXT_INDEP_ANCHORS           \
+   | RE_CONTEXT_INDEP_OPS  | RE_NO_BK_BRACES                \
+   | RE_NO_BK_PARENS       | RE_NO_BK_VBAR              \
    | RE_UNMATCHED_RIGHT_PAREN_ORD)
 
-    /* Differs from ..._POSIX_EXTENDED in that RE_CONTEXT_INVALID_OPS
-     * replaces RE_CONTEXT_INDEP_OPS and RE_NO_BK_REFS is added.  */
-#define RE_SYNTAX_POSIX_MINIMAL_EXTENDED				\
-  (_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS			\
-   | RE_CONTEXT_INVALID_OPS | RE_NO_BK_BRACES				\
-   | RE_NO_BK_PARENS        | RE_NO_BK_REFS				\
-   | RE_NO_BK_VBAR	    | RE_UNMATCHED_RIGHT_PAREN_ORD)
-    /* [[[end syntaxes]]] */
-    
-    /* Maximum number of duplicates an interval can allow.  Some systems
-     * (erroneously) define this in other header files, but we want our
-     * value, so remove any previous define.  */
+/* Differs from ..._POSIX_EXTENDED in that RE_CONTEXT_INVALID_OPS
+ * replaces RE_CONTEXT_INDEP_OPS and RE_NO_BK_REFS is added.  */
+#define RE_SYNTAX_POSIX_MINIMAL_EXTENDED                \
+  (_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS          \
+   | RE_CONTEXT_INVALID_OPS | RE_NO_BK_BRACES               \
+   | RE_NO_BK_PARENS        | RE_NO_BK_REFS             \
+   | RE_NO_BK_VBAR      | RE_UNMATCHED_RIGHT_PAREN_ORD)
+/* [[[end syntaxes]]] */
+
+/* Maximum number of duplicates an interval can allow.  Some systems
+ * (erroneously) define this in other header files, but we want our
+ * value, so remove any previous define.  */
 #ifdef RE_DUP_MAX
 #undef RE_DUP_MAX
 #endif
 #define RE_DUP_MAX ((1 << 15) - 1)
 
-    /* POSIX `cflags' bits (i.e., information for `regcomp').  */
+/* POSIX `cflags' bits (i.e., information for `regcomp').  */
 
-    /* If this bit is set, then use extended regular expression syntax.
-     * If not set, then use basic regular expression syntax.  */
+/* If this bit is set, then use extended regular expression syntax.
+ * If not set, then use basic regular expression syntax.  */
 #define REG_EXTENDED 1
 
-    /* If this bit is set, then ignore case when matching.
-     * If not set, then case is significant.  */
+/* If this bit is set, then ignore case when matching.
+ * If not set, then case is significant.  */
 #define REG_ICASE (REG_EXTENDED << 1)
 
-    /* If this bit is set, then anchors do not match at newline
-     * characters in the string.
-     * If not set, then anchors do match at newlines.  */
+/* If this bit is set, then anchors do not match at newline
+ * characters in the string.
+ * If not set, then anchors do match at newlines.  */
 #define REG_NEWLINE (REG_ICASE << 1)
 
-    /* If this bit is set, then report only success or fail in regexec.
-     * If not set, then returns differ between not matching and errors.  */
+/* If this bit is set, then report only success or fail in regexec.
+ * If not set, then returns differ between not matching and errors.  */
 #define REG_NOSUB (REG_NEWLINE << 1)
 
-    /* POSIX `eflags' bits (i.e., information for regexec).  */
+/* POSIX `eflags' bits (i.e., information for regexec).  */
 
-    /* If this bit is set, then the beginning-of-line operator doesn't match
-     * the beginning of the string (presumably because it's not the
-     * beginning of a line).
-     * If not set, then the beginning-of-line operator does match the
-     * beginning of the string.  */
+/* If this bit is set, then the beginning-of-line operator doesn't match
+ * the beginning of the string (presumably because it's not the
+ * beginning of a line).
+ * If not set, then the beginning-of-line operator does match the
+ * beginning of the string.  */
 #define REG_NOTBOL 1
 
-    /* Like REG_NOTBOL, except for the end-of-line.  */
+/* Like REG_NOTBOL, except for the end-of-line.  */
 #define REG_NOTEOL (1 << 1)
 
-    /* If any error codes are removed, changed, or added, update the
-     * `re_error_msg' table in regex.c.  */
-    typedef enum {
-        REG_NOERROR = 0,		/* Success.  */
-        REG_NOMATCH,		/* Didn't find a match (for regexec).  */
-
-        /* POSIX regcomp return error codes.  (In the order listed in the
-         * standard.)  */
-        REG_BADPAT,			/* Invalid pattern.  */
-        REG_ECOLLATE,		/* Not implemented.  */
-        REG_ECTYPE,			/* Invalid character class name.  */
-        REG_EESCAPE,		/* Trailing backslash.  */
-        REG_ESUBREG,		/* Invalid back reference.  */
-        REG_EBRACK,			/* Unmatched left bracket.  */
-        REG_EPAREN,			/* Parenthesis imbalance.  */
-        REG_EBRACE,			/* Unmatched \{.  */
-        REG_BADBR,			/* Invalid contents of \{\}.  */
-        REG_ERANGE,			/* Invalid range end.  */
-        REG_ESPACE,			/* Ran out of memory.  */
-        REG_BADRPT,			/* No preceding re for repetition op.  */
-
-        /* Error codes we've added.  */
-        REG_EEND,			/* Premature end.  */
-        REG_ESIZE,			/* Compiled pattern bigger than 2^16 bytes.  */
-        REG_ERPAREN			/* Unmatched ) or \); not returned from regcomp.  */
-    } reg_errcode_t;
-    
-    /* This data structure represents a compiled pattern.  Before calling
-     * the pattern compiler, the fields `buffer', `allocated', `fastmap',
-     * `translate', and `no_sub' can be set.  After the pattern has been
-     * compiled, the `re_nsub' field is available.  All other fields are
-     * private to the regex routines.  */
-
-    struct re_pattern_buffer {
-        /* [[[begin pattern_buffer]]] */
-        /* Space that holds the compiled pattern.  It is declared as
-         * `unsigned char *' because its elements are
-         * sometimes used as array indexes.  */
-        unsigned char *buffer;
-
-        /* Number of bytes to which `buffer' points.  */
-        unsigned long allocated;
-
-        /* Number of bytes actually used in `buffer'.  */
-        unsigned long used;
-
-        /* Syntax setting with which the pattern was compiled.  */
-        reg_syntax_t syntax;
-
-        /* Pointer to a fastmap, if any, otherwise zero.  re_search uses
-         * the fastmap, if there is one, to skip over impossible
-         * starting points for matches.  */
-        char *fastmap;
-
-        /* Either a translate table to apply to all characters before
-         * comparing them, or zero for no translation.  The translation
-         * is applied to a pattern when it is compiled and to a string
-         * when it is matched.  */
-        char *translate;
-
-        /* Number of subexpressions found by the compiler.  */
-        size_t re_nsub;
-
-        /* Zero if this pattern cannot match the empty string, one else.
-         * Well, in truth it's used only in `re_search_2', to see
-         * whether or not we should use the fastmap, so we don't set
-         * this absolutely perfectly; see `re_compile_fastmap' (the
-         * `duplicate' case).  */
-        unsigned can_be_null:1;
-
-        /* If REGS_UNALLOCATED, allocate space in the `regs' structure
-         * for `max (RE_NREGS, re_nsub + 1)' groups.
-         * If REGS_REALLOCATE, reallocate space if necessary.
-         * If REGS_FIXED, use what's there.  */
+/* If any error codes are removed, changed, or added, update the
+ * `re_error_msg' table in regex.c.  */
+typedef enum {
+    REG_NOERROR = 0,        /* Success.  */
+    REG_NOMATCH,        /* Didn't find a match (for regexec).  */
+
+    /* POSIX regcomp return error codes.  (In the order listed in the
+     * standard.)  */
+    REG_BADPAT,         /* Invalid pattern.  */
+    REG_ECOLLATE,       /* Not implemented.  */
+    REG_ECTYPE,         /* Invalid character class name.  */
+    REG_EESCAPE,        /* Trailing backslash.  */
+    REG_ESUBREG,        /* Invalid back reference.  */
+    REG_EBRACK,         /* Unmatched left bracket.  */
+    REG_EPAREN,         /* Parenthesis imbalance.  */
+    REG_EBRACE,         /* Unmatched \{.  */
+    REG_BADBR,          /* Invalid contents of \{\}.  */
+    REG_ERANGE,         /* Invalid range end.  */
+    REG_ESPACE,         /* Ran out of memory.  */
+    REG_BADRPT,         /* No preceding re for repetition op.  */
+
+    /* Error codes we've added.  */
+    REG_EEND,           /* Premature end.  */
+    REG_ESIZE,          /* Compiled pattern bigger than 2^16 bytes.  */
+    REG_ERPAREN         /* Unmatched ) or \); not returned from regcomp.  */
+} reg_errcode_t;
+
+/* This data structure represents a compiled pattern.  Before calling
+ * the pattern compiler, the fields `buffer', `allocated', `fastmap',
+ * `translate', and `no_sub' can be set.  After the pattern has been
+ * compiled, the `re_nsub' field is available.  All other fields are
+ * private to the regex routines.  */
+
+struct re_pattern_buffer {
+    /* [[[begin pattern_buffer]]] */
+    /* Space that holds the compiled pattern.  It is declared as
+     * `unsigned char *' because its elements are
+     * sometimes used as array indexes.  */
+    unsigned char *buffer;
+
+    /* Number of bytes to which `buffer' points.  */
+    unsigned long allocated;
+
+    /* Number of bytes actually used in `buffer'.  */
+    unsigned long used;
+
+    /* Syntax setting with which the pattern was compiled.  */
+    reg_syntax_t syntax;
+
+    /* Pointer to a fastmap, if any, otherwise zero.  re_search uses
+     * the fastmap, if there is one, to skip over impossible
+     * starting points for matches.  */
+    char *fastmap;
+
+    /* Either a translate table to apply to all characters before
+     * comparing them, or zero for no translation.  The translation
+     * is applied to a pattern when it is compiled and to a string
+     * when it is matched.  */
+    char *translate;
+
+    /* Number of subexpressions found by the compiler.  */
+    size_t re_nsub;
+
+    /* Zero if this pattern cannot match the empty string, one else.
+     * Well, in truth it's used only in `re_search_2', to see
+     * whether or not we should use the fastmap, so we don't set
+     * this absolutely perfectly; see `re_compile_fastmap' (the
+     * `duplicate' case).  */
+    unsigned can_be_null:1;
+
+    /* If REGS_UNALLOCATED, allocate space in the `regs' structure
+     * for `max (RE_NREGS, re_nsub + 1)' groups.
+     * If REGS_REALLOCATE, reallocate space if necessary.
+     * If REGS_FIXED, use what's there.  */
 #define REGS_UNALLOCATED 0
 #define REGS_REALLOCATE 1
 #define REGS_FIXED 2
-        unsigned regs_allocated:2;
+    unsigned regs_allocated:2;
 
-        /* Set to zero when `regex_compile' compiles a pattern; set to one
-         * by `re_compile_fastmap' if it updates the fastmap.  */
-        unsigned fastmap_accurate:1;
+    /* Set to zero when `regex_compile' compiles a pattern; set to one
+     * by `re_compile_fastmap' if it updates the fastmap.  */
+    unsigned fastmap_accurate:1;
 
-        /* If set, `re_match_2' does not return information about
-         * subexpressions.  */
-        unsigned no_sub:1;
+    /* If set, `re_match_2' does not return information about
+     * subexpressions.  */
+    unsigned no_sub:1;
 
-        /* If set, a beginning-of-line anchor doesn't match at the
-         * beginning of the string.  */
-        unsigned not_bol:1;
+    /* If set, a beginning-of-line anchor doesn't match at the
+     * beginning of the string.  */
+    unsigned not_bol:1;
 
-        /* Similarly for an end-of-line anchor.  */
-        unsigned not_eol:1;
+    /* Similarly for an end-of-line anchor.  */
+    unsigned not_eol:1;
 
-        /* If true, an anchor at a newline matches.  */
-        unsigned newline_anchor:1;
+    /* If true, an anchor at a newline matches.  */
+    unsigned newline_anchor:1;
 
-        /* [[[end pattern_buffer]]] */
-    };
+    /* [[[end pattern_buffer]]] */
+};
 
-    typedef struct re_pattern_buffer regex_t;
+typedef struct re_pattern_buffer regex_t;
 
-    /* search.c (search_buffer) in Emacs needs this one opcode value.  It is
-     * defined both in `regex.c' and here.  */
+/* search.c (search_buffer) in Emacs needs this one opcode value.  It is
+ * defined both in `regex.c' and here.  */
 #define RE_EXACTN_VALUE 1
-    
-    /* Type for byte offsets within the string.  POSIX mandates this.  */
-    typedef int regoff_t;
-
-    /* This is the structure we store register match data in.  See
-     * regex.texinfo for a full description of what registers match.  */
-    struct re_registers {
-        unsigned num_regs;
-        regoff_t *start;
-        regoff_t *end;
-    };
-
-    /* If `regs_allocated' is REGS_UNALLOCATED in the pattern buffer,
-     * `re_match_2' returns information about at least this many registers
-     * the first time a `regs' structure is passed.  */
+
+/* Type for byte offsets within the string.  POSIX mandates this.  */
+typedef int regoff_t;
+
+/* This is the structure we store register match data in.  See
+ * regex.texinfo for a full description of what registers match.  */
+struct re_registers {
+    unsigned num_regs;
+    regoff_t *start;
+    regoff_t *end;
+};
+
+/* If `regs_allocated' is REGS_UNALLOCATED in the pattern buffer,
+ * `re_match_2' returns information about at least this many registers
+ * the first time a `regs' structure is passed.  */
 #ifndef RE_NREGS
 #define RE_NREGS 30
 #endif
 
-    /* POSIX specification for registers.  Aside from the different names than
-     * `re_registers', POSIX uses an array of structures, instead of a
-     * structure of arrays.  */
-    typedef struct {
-        regoff_t rm_so;		/* Byte offset from string's start to substring's start.  */
-        regoff_t rm_eo;		/* Byte offset from string's start to substring's end.  */
-    } regmatch_t;
-    
-    /* Declarations for routines.  */
-
-    /* To avoid duplicating every routine declaration -- once with a
-     * prototype (if we are ANSI), and once without (if we aren't) -- we
-     * use the following macro to declare argument types.  This
-     * unfortunately clutters up the declarations a bit, but I think it's
-     * worth it.  */
-
-    /* POSIX compatibility.  */
-    extern int regcomp(regex_t * preg, const char *pattern, int cflags);
-    extern int regexec(const regex_t * preg, const char *string, size_t nmatch, regmatch_t pmatch[], int eflags);
-    extern size_t regerror(int errcode, const regex_t * preg, char *errbuf, size_t errbuf_size);
-    extern void regfree(regex_t * preg);
+/* POSIX specification for registers.  Aside from the different names than
+ * `re_registers', POSIX uses an array of structures, instead of a
+ * structure of arrays.  */
+typedef struct {
+    regoff_t rm_so;     /* Byte offset from string's start to substring's start.  */
+    regoff_t rm_eo;     /* Byte offset from string's start to substring's end.  */
+} regmatch_t;
+
+/* Declarations for routines.  */
+
+/* To avoid duplicating every routine declaration -- once with a
+ * prototype (if we are ANSI), and once without (if we aren't) -- we
+ * use the following macro to declare argument types.  This
+ * unfortunately clutters up the declarations a bit, but I think it's
+ * worth it.  */
+
+/* POSIX compatibility.  */
+extern int regcomp(regex_t * preg, const char *pattern, int cflags);
+extern int regexec(const regex_t * preg, const char *string, size_t nmatch, regmatch_t pmatch[], int eflags);
+extern size_t regerror(int errcode, const regex_t * preg, char *errbuf, size_t errbuf_size);
+extern void regfree(regex_t * preg);
 
 #ifdef __cplusplus
 }
@@ -410,3 +410,4 @@ extern "C" {
  * trim-versions-without-asking: nil
  * End:
  */
+
@@ -13,3 +13,4 @@ void xassert(const char *expr, const char *file, int line)
     fprintf(stderr, "assertion failed: %s:%d: \"%s\"\n", file, line, expr);
     abort();
 }
+
@@ -25,3 +25,4 @@ extern void
 xassert(const char *, const char *, int);
 
 #endif /* SQUID_ASSERT_H */
+
@@ -140,3 +140,4 @@ struct sockaddr_un {
 #endif
 
 #endif /* SQUID_COMPAT_CMSG_H */
+
@@ -10,3 +10,4 @@
 #include "compat.h"
 
 void (*failure_notify) (const char *) = NULL;
+
@@ -116,3 +116,4 @@
 #include "compat/cppunit.h"
 
 #endif /* _SQUID_COMPAT_H */
+
@@ -273,3 +273,4 @@ const char * squid_strnstr(const char *s, const char *find, size_t slen);
 #endif
 
 #endif /* _SQUID_COMPAT_SHARED_H */
+
@@ -39,3 +39,4 @@
 #endif /* HAVE_UNIQUE_PTR */
 #endif /* HAVE_CPPUNIT_EXTENSIONS_HELPERMACROS_H */
 #endif /* SQUID_COMPAT_CPPUNIT_H */
+
@@ -69,3 +69,4 @@ inline int sched_getaffinity(int, size_t, cpu_set_t *) { return ENOTSUP; }
 #endif /* HAVE_CPU_AFFINITY */
 
 #endif /* SQUID_COMPAT_CPU_H */
+
@@ -27,3 +27,4 @@ debug(const char *format,...)
 }
 
 #endif /* __GNUC__ */
+
@@ -38,3 +38,4 @@ void debug(const char *format,...);
 #endif
 
 #endif /* COMPAT_DEBUG_H */
+
@@ -14,21 +14,21 @@
 
 #if !HAVE_DRAND48
 
-#define N	16
-#define MASK	((unsigned)(1 << (N - 1)) + (1 << (N - 1)) - 1)
-#define LOW(x)	((unsigned)(x) & MASK)
-#define HIGH(x)	LOW((x) >> N)
-#define MUL(x, y, z)	{ long l = (long)(x) * (long)(y); \
-		(z)[0] = LOW(l); (z)[1] = HIGH(l); }
-#define CARRY(x, y)	((long)(x) + (long)(y) > MASK)
-#define ADDEQU(x, y, z)	(z = CARRY(x, (y)), x = LOW(x + (y)))
-#define X0	0x330E
-#define X1	0xABCD
-#define X2	0x1234
-#define A0	0xE66D
-#define A1	0xDEEC
-#define A2	0x5
-#define C	0xB
+#define N   16
+#define MASK    ((unsigned)(1 << (N - 1)) + (1 << (N - 1)) - 1)
+#define LOW(x)  ((unsigned)(x) & MASK)
+#define HIGH(x) LOW((x) >> N)
+#define MUL(x, y, z)    { long l = (long)(x) * (long)(y); \
+        (z)[0] = LOW(l); (z)[1] = HIGH(l); }
+#define CARRY(x, y) ((long)(x) + (long)(y) > MASK)
+#define ADDEQU(x, y, z) (z = CARRY(x, (y)), x = LOW(x + (y)))
+#define X0  0x330E
+#define X1  0xABCD
+#define X2  0x1234
+#define A0  0xE66D
+#define A1  0xDEEC
+#define A2  0x5
+#define C   0xB
 
 static void next(void);
 static unsigned x[3] = {X0, X1, X2}, a[3] = {A0, A1, A2}, c = C;
@@ -61,3 +61,4 @@ next(void)
 }
 
 #endif /* HAVE_DRAND48 */
+
@@ -15,3 +15,4 @@ SQUIDCEXTERN double drand48(void);
 #endif
 
 #endif
+
@@ -144,3 +144,4 @@ eui64_aton(const char *a, struct eui64 *e)
 }
 
 #endif /* !SQUID_EUI64_ATON */
+
@@ -59,28 +59,29 @@ extern "C" {
 
 #define SQUID_EUI64_ATON 1
 
-    /**
-     * Size of the ASCII representation of an EUI-64.
-     */
+/**
+ * Size of the ASCII representation of an EUI-64.
+ */
 #define EUI64_SIZ       24
 
-    /**
-     * The number of bytes in an EUI-64.
-     */
+/**
+ * The number of bytes in an EUI-64.
+ */
 #define EUI64_LEN       8
 
-    /**
-     * Structure of an IEEE EUI-64.
-     */
-    struct eui64 {
-        uint8_t octet[EUI64_LEN];
-    };
+/**
+ * Structure of an IEEE EUI-64.
+ */
+struct eui64 {
+    uint8_t octet[EUI64_LEN];
+};
 
-    int eui64_aton(const char *a, struct eui64 *e);
+int eui64_aton(const char *a, struct eui64 *e);
 #if defined(__cplusplus)
 }
 #endif
 
 #endif /* !_SYS_EUI64_H */
 #endif /* HAVE_SYS_EUI64_H */
 #endif /* SQUID_COMPAT_EUI64_ATON_H */
+
@@ -18,8 +18,8 @@
 /* FD_SETSIZE must be redefined before including sys/types.h */
 #if 0
 /* AYJ: would dearly like to use this to enforce include order
-	but at present some helpers don't follow the squid include methodology.
-	that will need fixing later.
+    but at present some helpers don't follow the squid include methodology.
+    that will need fixing later.
 */
 #ifdef _SYS_TYPES_H
 #error squid_fdsetsize.h for FDSETSIZE must be included before sys/types.h
@@ -98,3 +98,4 @@
 #endif
 
 #endif /* SQUID_FDSETSIZE_H */
+
@@ -13,7 +13,7 @@
  * Update/Maintenance History:
  *
  *    15-Aug-2007 : Copied from fetchmail 6.3.8
- *			- added protection around libray headers
+ *          - added protection around libray headers
  *
  *    16-Aug-2007 : Altered configure checks
  *                  Un-hacked slightly to use system gethostbyname()
@@ -313,18 +313,18 @@ xgai_strerror (int ecode)
 {
     static const char *eai_descr[] = {
         "no error",
-        "address family for nodename not supported",	/* EAI_ADDRFAMILY */
-        "temporary failure in name resolution",		/* EAI_AGAIN */
-        "invalid value for ai_flags",	 		/* EAI_BADFLAGS */
-        "non-recoverable failure in name resolution",	/* EAI_FAIL */
-        "ai_family not supported",			/* EAI_FAMILY */
-        "memory allocation failure",			/* EAI_MEMORY */
-        "no address associated with nodename",		/* EAI_NODATA */
-        "nodename nor servname provided, or not known",	/* EAI_NONAME */
-        "servname not supported for ai_socktype",		/* EAI_SERVICE */
-        "ai_socktype not supported",			/* EAI_SOCKTYPE */
-        "system error returned in errno",			/* EAI_SYSTEM */
-        "argument buffer overflow",			/* EAI_OVERFLOW */
+        "address family for nodename not supported",    /* EAI_ADDRFAMILY */
+        "temporary failure in name resolution",     /* EAI_AGAIN */
+        "invalid value for ai_flags",           /* EAI_BADFLAGS */
+        "non-recoverable failure in name resolution",   /* EAI_FAIL */
+        "ai_family not supported",          /* EAI_FAMILY */
+        "memory allocation failure",            /* EAI_MEMORY */
+        "no address associated with nodename",      /* EAI_NODATA */
+        "nodename nor servname provided, or not known", /* EAI_NONAME */
+        "servname not supported for ai_socktype",       /* EAI_SERVICE */
+        "ai_socktype not supported",            /* EAI_SOCKTYPE */
+        "system error returned in errno",           /* EAI_SYSTEM */
+        "argument buffer overflow",         /* EAI_OVERFLOW */
     };
 
     if (ecode < 0 || ecode > (int) (sizeof eai_descr/ sizeof eai_descr[0]))
@@ -333,3 +333,4 @@ xgai_strerror (int ecode)
 }
 
 #endif /* HAVE_GETADDRINFO */
+
@@ -16,7 +16,7 @@
  * Update/Maintenance History:
  *
  *    15-Aug-2007 : Copied from fetchmail 6.3.8
- *			- added protection around libray headers
+ *          - added protection around libray headers
  *
  *    16-Aug-2007 : Altered configure checks
  *                  Un-hacked slightly to use system gethostbyname()
@@ -56,14 +56,14 @@ On Windows the following definitions are already available, may be that
 this could be needed on some other platform */
 #if 0
 struct addrinfo {
-    int ai_flags;  	  	/* AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST */
-    int ai_family; 	  	/* PF_xxx */
-    int ai_socktype;	 	/* SOCK_xxx */
-    int ai_protocol;	 	/* 0 or IPPROTO_xxx for IPv4 and IPv6 */
-    socklen_t ai_addrlen;	/* length of ai_addr */
-    char *ai_canonname;		/* canonical name for nodename */
-    struct sockaddr *ai_addr;	/* binary address */
-    struct addrinfo *ai_next;	/* next structure in linked list */
+    int ai_flags;       /* AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST */
+    int ai_family;      /* PF_xxx */
+    int ai_socktype;        /* SOCK_xxx */
+    int ai_protocol;        /* 0 or IPPROTO_xxx for IPv4 and IPv6 */
+    socklen_t ai_addrlen;   /* length of ai_addr */
+    char *ai_canonname;     /* canonical name for nodename */
+    struct sockaddr *ai_addr;   /* binary address */
+    struct addrinfo *ai_next;   /* next structure in linked list */
 };
 
 /* Supposed to be defined in <netdb.h> */
@@ -100,17 +100,18 @@ struct addrinfo {
 /* RFC 2553 / Posix resolver */
 SQUIDCEXTERN int xgetaddrinfo (const char *nodename, const char *servname,
                                const struct addrinfo *hints, struct addrinfo **res);
-#define getaddrinfo	xgetaddrinfo
+#define getaddrinfo xgetaddrinfo
 
 /* Free addrinfo structure and associated storage */
 SQUIDCEXTERN void xfreeaddrinfo (struct addrinfo *ai);
-#define freeaddrinfo	xfreeaddrinfo
+#define freeaddrinfo    xfreeaddrinfo
 
 /* Convert error return from getaddrinfo() to string */
 SQUIDCEXTERN const char *xgai_strerror (int code);
 #if !defined(gai_strerror)
-#define gai_strerror	xgai_strerror
+#define gai_strerror    xgai_strerror
 #endif
 
 #endif /* HAVE_GETADDRINFO */
 #endif /* _getaddrinfo_h */
+
@@ -26,7 +26,7 @@
  */
 #include "squid.h"
 
-/*	KAME: getnameinfo.c,v 1.72 2005/01/13 04:12:03 itojun Exp 	*/
+/*  KAME: getnameinfo.c,v 1.72 2005/01/13 04:12:03 itojun Exp   */
 
 /*
  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
@@ -133,13 +133,15 @@ static const struct afd {
     int a_portoff;
 } afdl [] = {
 #if INET6
-    {PF_INET6, sizeof(struct in6_addr), sizeof(struct sockaddr_in6),
+    {   PF_INET6, sizeof(struct in6_addr), sizeof(struct sockaddr_in6),
         offsetof(struct sockaddr_in6, sin6_addr),
-        offsetof(struct sockaddr_in6, sin6_port)},
+        offsetof(struct sockaddr_in6, sin6_port)
+    },
 #endif
-    {PF_INET, sizeof(struct in_addr), sizeof(struct sockaddr_in),
-     offsetof(struct sockaddr_in, sin_addr),
-     offsetof(struct sockaddr_in, sin_port)},
+    {   PF_INET, sizeof(struct in_addr), sizeof(struct sockaddr_in),
+        offsetof(struct sockaddr_in, sin_addr),
+        offsetof(struct sockaddr_in, sin_port)
+    },
     {0, 0, 0, 0, 0},
 };
 
@@ -171,7 +173,7 @@ int flags;
     if (sa == NULL)
         return EAI_FAIL;
 
-#if HAVE_SA_LEN	/*XXX*/
+#if HAVE_SA_LEN /*XXX*/
     if (sa->sa_len != salen)
         return EAI_FAIL;
 #endif
@@ -423,3 +425,4 @@ int flags;
 }
 #endif /* INET6 */
 #endif
+
@@ -20,7 +20,8 @@ SQUIDCEXTERN int xgetnameinfo(const struct sockaddr *sa,
                               char *serv,
                               size_t servlen,
                               int flags );
-#define getnameinfo	xgetnameinfo
+#define getnameinfo xgetnameinfo
 
 #endif /* HAVE_GETNAMEINFO */
 #endif /* _getnameinfo_h */
+
@@ -14,9 +14,9 @@
  * Update/Maintenance History:
  *
  *    24-Sep-2007 : Copied from bind 9.3.3
- * 			- Added protection around libray headers
- * 			- Altered configure checks
- * 			- Un-hacked slightly to use system gethostbyname()
+ *          - Added protection around libray headers
+ *          - Altered configure checks
+ *          - Un-hacked slightly to use system gethostbyname()
  *
  *    06-Oct-2007 : Various fixes to allow the build on MinGW
  *
@@ -100,11 +100,11 @@ static const char *inet_ntop6 (const u_char *src, char *dst, size_t size);
 
 /* char *
  * inet_ntop(af, src, dst, size)
- *	convert a network format address to presentation format.
+ *  convert a network format address to presentation format.
  * return:
- *	pointer to presentation format address (`dst'), or NULL (see errno).
+ *  pointer to presentation format address (`dst'), or NULL (see errno).
  * author:
- *	Paul Vixie, 1996.
+ *  Paul Vixie, 1996.
  */
 const char *
 xinet_ntop(af, src, dst, size)
@@ -127,14 +127,14 @@ size_t size;
 
 /* const char *
  * inet_ntop4(src, dst, size)
- *	format an IPv4 address
+ *  format an IPv4 address
  * return:
- *	`dst' (as a const)
+ *  `dst' (as a const)
  * notes:
- *	(1) uses no statics
- *	(2) takes a u_char* not an in_addr as input
+ *  (1) uses no statics
+ *  (2) takes a u_char* not an in_addr as input
  * author:
- *	Paul Vixie, 1996.
+ *  Paul Vixie, 1996.
  */
 static const char *
 inet_ntop4(src, dst, size)
@@ -155,9 +155,9 @@ size_t size;
 
 /* const char *
  * inet_ntop6(src, dst, size)
- *	convert IPv6 binary address into presentation (printable) format
+ *  convert IPv6 binary address into presentation (printable) format
  * author:
- *	Paul Vixie, 1996.
+ *  Paul Vixie, 1996.
  */
 static const char *
 inet_ntop6(src, dst, size)
@@ -179,8 +179,8 @@ size_t size;
 
     /*
      * Preprocess:
-     *	Copy the input (bytewise) array into a wordwise array.
-     *	Find the longest run of 0x00's in src[] for :: shorthanding.
+     *  Copy the input (bytewise) array into a wordwise array.
+     *  Find the longest run of 0x00's in src[] for :: shorthanding.
      */
     memset(words, '\0', sizeof words);
     for (i = 0; i < NS_IN6ADDRSZ; i++)
@@ -254,3 +254,4 @@ size_t size;
 }
 
 #endif /* HAVE_INET_NTOP */
+
@@ -25,3 +25,4 @@ SQUIDCEXTERN const char * xinet_ntop(int af, const void *src, char *dst, size_t
 
 #endif
 #endif /* _INC_INET_NTOP_H */
+
@@ -89,19 +89,19 @@ static const char rcsid[] = "inet_pton.c,v 1.2.206.2 2005/07/28 07:43:18 marka E
  * sizeof(int) < 4.  sizeof(int) > 4 is fine; all the world's not a VAX.
  */
 
-static int	inet_pton4 (const char *src, u_char *dst);
-static int	inet_pton6 (const char *src, u_char *dst);
+static int  inet_pton4 (const char *src, u_char *dst);
+static int  inet_pton6 (const char *src, u_char *dst);
 
 /* int
  * inet_pton(af, src, dst)
- *	convert from presentation format (which usually means ASCII printable)
- *	to network format (which is usually some kind of binary format).
+ *  convert from presentation format (which usually means ASCII printable)
+ *  to network format (which is usually some kind of binary format).
  * return:
- *	1 if the address was valid for the specified address family
- *	0 if the address wasn't valid (`dst' is untouched in this case)
- *	-1 if some other error occurred (`dst' is untouched in this case, too)
+ *  1 if the address was valid for the specified address family
+ *  0 if the address wasn't valid (`dst' is untouched in this case)
+ *  -1 if some other error occurred (`dst' is untouched in this case, too)
  * author:
- *	Paul Vixie, 1996.
+ *  Paul Vixie, 1996.
  */
 int
 xinet_pton(af, src, dst)
@@ -123,13 +123,13 @@ void *dst;
 
 /* int
  * inet_pton4(src, dst)
- *	like inet_aton() but without all the hexadecimal and shorthand.
+ *  like inet_aton() but without all the hexadecimal and shorthand.
  * return:
- *	1 if `src' is a valid dotted quad, else 0.
+ *  1 if `src' is a valid dotted quad, else 0.
  * notice:
- *	does not touch `dst' unless it's returning 1.
+ *  does not touch `dst' unless it's returning 1.
  * author:
- *	Paul Vixie, 1996.
+ *  Paul Vixie, 1996.
  */
 static int
 inet_pton4(src, dst)
@@ -175,16 +175,16 @@ u_char *dst;
 
 /* int
  * inet_pton6(src, dst)
- *	convert presentation level address to network order binary form.
+ *  convert presentation level address to network order binary form.
  * return:
- *	1 if `src' is a valid [RFC1884 2.2] address, else 0.
+ *  1 if `src' is a valid [RFC1884 2.2] address, else 0.
  * notice:
- *	(1) does not touch `dst' unless it's returning 1.
- *	(2) :: in a full address is silently ignored.
+ *  (1) does not touch `dst' unless it's returning 1.
+ *  (2) :: in a full address is silently ignored.
  * credit:
- *	inspired by Mark Andrews.
+ *  inspired by Mark Andrews.
  * author:
- *	Paul Vixie, 1996.
+ *  Paul Vixie, 1996.
  */
 static int
 inet_pton6(src, dst)
@@ -242,7 +242,7 @@ u_char *dst;
                 inet_pton4(curtok, tp) > 0) {
             tp += NS_INADDRSZ;
             seen_xdigits = 0;
-            break;	/* '\0' was seen by inet_pton4(). */
+            break;  /* '\0' was seen by inet_pton4(). */
         }
         return (0);
     }
@@ -275,3 +275,4 @@ u_char *dst;
 }
 
 #endif /* HAVE_INET_PTON */
+
@@ -28,3 +28,4 @@ SQUIDCEXTERN int xinet_pton(int af, const char *src, void *dst);
 
 #endif
 #endif /* _INC_INET_NTOP_H */
+
@@ -15,3 +15,4 @@ SQUIDCEXTERN int initgroups(const char *user, gid_t group);
 
 #endif
 #endif /* SQUID_INITGROPS_H */
+
@@ -38,13 +38,14 @@ memrchr(const void *s, int c, size_t n)
     const unsigned char *cp;
 
     if (n != 0) {
-	cp = (unsigned char *)s + n;
-	do {
-	    if (*(--cp) == (unsigned char)c)
-		return((void *)cp);
-	} while (--n != 0);
+        cp = (unsigned char *)s + n;
+        do {
+            if (*(--cp) == (unsigned char)c)
+                return((void *)cp);
+        } while (--n != 0);
     }
     return((void *)0);
 }
 
 #endif
+
@@ -35,3 +35,4 @@ void *memrchr(const void *s, int c, size_t n);
 
 #endif
 #endif /* SQUID_COMPAT_MEMRCHR_H */
+
@@ -208,8 +208,8 @@ _free_osfhnd(int filehandle)
         _osfhnd(filehandle) = (long) INVALID_HANDLE_VALUE;
         return (0);
     } else {
-        errno = EBADF;		/* bad handle */
-        _doserrno = 0L;		/* not an OS error */
+        errno = EBADF;      /* bad handle */
+        _doserrno = 0L;     /* not an OS error */
         return -1;
     }
 }
@@ -355,3 +355,4 @@ syslog(int priority, const char *fmt, ...)
 
 /* note: this is all MSWindows-specific code; all of it should be conditional */
 #endif /* _SQUID_WINDOWS_ */
+
@@ -32,3 +32,4 @@
 
 #endif /* _SQUID_AIX_ */
 #endif /* SQUID_OS_AIX_H */
+
@@ -18,3 +18,4 @@
 
 #endif /* _SQUID_ANDROID_ */
 #endif /* SQUID_OS_ANDROID_H */
+
@@ -26,3 +26,4 @@
 
 #endif /* _SQUID_DRAGONFLY_ */
 #endif /* SQUID_OS_DRAGONFLY_H */
+
@@ -41,3 +41,4 @@
 
 #endif /* _SQUID_FREEBSD_ */
 #endif /* SQUID_OS_FREEBSD_H */
+
@@ -40,3 +40,4 @@
 
 #endif /* _SQUID_HPUX_ */
 #endif /* SQUID_OS_HPUX_H */
+
@@ -72,3 +72,4 @@ typedef uint32_t __u32;
 
 #endif /* _SQUID_LINUX_ */
 #endif /* SQUID_OS_LINUX_H */
+
@@ -35,3 +35,4 @@
 
 #endif /* _SQUID_APPLE_ */
 #endif /* SQUID_OS_MACOSX_H */
+
@@ -70,7 +70,7 @@
 #endif
 
 #if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS == 64
-# define __USE_FILE_OFFSET64	1
+# define __USE_FILE_OFFSET64    1
 #endif
 
 #if defined(_MSC_VER) /* Microsoft C Compiler ONLY */
@@ -179,7 +179,7 @@ SQUIDCEXTERN int WIN32_truncate(const char *pathname, off_t length);
 #define O_RANDOM        _O_RANDOM
 #endif
 #ifndef O_NDELAY
-#define O_NDELAY	0
+#define O_NDELAY    0
 #endif
 
 #ifndef S_IFMT
@@ -226,16 +226,16 @@ SQUIDCEXTERN int WIN32_truncate(const char *pathname, off_t length);
 #endif
 
 #if defined(_MSC_VER)
-#define	S_ISDIR(m) (((m) & _S_IFDIR) == _S_IFDIR)
+#define S_ISDIR(m) (((m) & _S_IFDIR) == _S_IFDIR)
 #endif
 
-#define SIGHUP	1	/* hangup */
-#define SIGKILL	9	/* kill (cannot be caught or ignored) */
-#define SIGBUS	10	/* bus error */
-#define SIGPIPE	13	/* write on a pipe with no one to read it */
-#define SIGCHLD	20	/* to parent on child stop or exit */
-#define SIGUSR1 30	/* user defined signal 1 */
-#define SIGUSR2 31	/* user defined signal 2 */
+#define SIGHUP  1   /* hangup */
+#define SIGKILL 9   /* kill (cannot be caught or ignored) */
+#define SIGBUS  10  /* bus error */
+#define SIGPIPE 13  /* write on a pipe with no one to read it */
+#define SIGCHLD 20  /* to parent on child stop or exit */
+#define SIGUSR1 30  /* user defined signal 1 */
+#define SIGUSR2 31  /* user defined signal 2 */
 
 #if _SQUID_MINGW_
 typedef unsigned char boolean;
@@ -267,8 +267,8 @@ struct group {
 
 #if !HAVE_GETTIMEOFDAY
 struct timezone {
-    int	tz_minuteswest;	/* minutes west of Greenwich */
-    int	tz_dsttime;	/* type of dst correction */
+    int tz_minuteswest; /* minutes west of Greenwich */
+    int tz_dsttime; /* type of dst correction */
 };
 #endif
 
@@ -812,27 +812,27 @@ WSASocket(int a, int t, int p, LPWSAPROTOCOL_INFO i, GROUP g, DWORD f)
 
 #else /* #ifdef __cplusplus */
 #define connect(s,n,l) \
-	(SOCKET_ERROR == connect(_get_osfhandle(s),n,l) ? \
-	(WSAEMFILE == (errno = WSAGetLastError()) ? errno = EMFILE : -1, -1) : 0)
+    (SOCKET_ERROR == connect(_get_osfhandle(s),n,l) ? \
+    (WSAEMFILE == (errno = WSAGetLastError()) ? errno = EMFILE : -1, -1) : 0)
 #define gethostbyname(n) \
-	(NULL == ((HOSTENT FAR*)(ws32_result = (int)gethostbyname(n))) ? \
-	(errno = WSAGetLastError()), (HOSTENT FAR*)NULL : (HOSTENT FAR*)ws32_result)
+    (NULL == ((HOSTENT FAR*)(ws32_result = (int)gethostbyname(n))) ? \
+    (errno = WSAGetLastError()), (HOSTENT FAR*)NULL : (HOSTENT FAR*)ws32_result)
 #define gethostname(n,l) \
-	(SOCKET_ERROR == gethostname(n,l) ? \
-	(errno = WSAGetLastError()), -1 : 0)
+    (SOCKET_ERROR == gethostname(n,l) ? \
+    (errno = WSAGetLastError()), -1 : 0)
 #define recv(s,b,l,f) \
-	(SOCKET_ERROR == (ws32_result = recv(_get_osfhandle(s),b,l,f)) ? \
-	(errno = WSAGetLastError()), -1 : ws32_result)
+    (SOCKET_ERROR == (ws32_result = recv(_get_osfhandle(s),b,l,f)) ? \
+    (errno = WSAGetLastError()), -1 : ws32_result)
 #define sendto(s,b,l,f,t,tl) \
-	(SOCKET_ERROR == (ws32_result = sendto(_get_osfhandle(s),b,l,f,t,tl)) ? \
-	(errno = WSAGetLastError()), -1 : ws32_result)
+    (SOCKET_ERROR == (ws32_result = sendto(_get_osfhandle(s),b,l,f,t,tl)) ? \
+    (errno = WSAGetLastError()), -1 : ws32_result)
 #define select(n,r,w,e,t) \
-	(SOCKET_ERROR == (ws32_result = select(n,r,w,e,t)) ? \
-	(errno = WSAGetLastError()), -1 : ws32_result)
+    (SOCKET_ERROR == (ws32_result = select(n,r,w,e,t)) ? \
+    (errno = WSAGetLastError()), -1 : ws32_result)
 #define socket(f,t,p) \
-	(INVALID_SOCKET == ((SOCKET)(ws32_result = (int)socket(f,t,p))) ? \
-	((WSAEMFILE == (errno = WSAGetLastError()) ? errno = EMFILE : -1), -1) : \
-	(SOCKET)_open_osfhandle(ws32_result,0))
+    (INVALID_SOCKET == ((SOCKET)(ws32_result = (int)socket(f,t,p))) ? \
+    ((WSAEMFILE == (errno = WSAGetLastError()) ? errno = EMFILE : -1), -1) : \
+    (SOCKET)_open_osfhandle(ws32_result,0))
 #define write      _write /* Needed in util.c */
 #define open       _open /* Needed in win32lib.c */
 #endif /* #ifdef __cplusplus */
@@ -845,26 +845,26 @@ WSASocket(int a, int t, int p, LPWSAPROTOCOL_INFO i, GROUP g, DWORD f)
 #if HAVE_SYS_RESOURCE_H
 #include <sys/resource.h>
 #else
-#define	RUSAGE_SELF	0		/* calling process */
-#define	RUSAGE_CHILDREN	-1		/* terminated child processes */
+#define RUSAGE_SELF 0       /* calling process */
+#define RUSAGE_CHILDREN -1      /* terminated child processes */
 
 struct rusage {
-    struct timeval ru_utime;	/* user time used */
-    struct timeval ru_stime;	/* system time used */
-    long ru_maxrss;			/* integral max resident set size */
-    long ru_ixrss;			/* integral shared text memory size */
-    long ru_idrss;			/* integral unshared data size */
-    long ru_isrss;			/* integral unshared stack size */
-    long ru_minflt;			/* page reclaims */
-    long ru_majflt;			/* page faults */
-    long ru_nswap;			/* swaps */
-    long ru_inblock;		/* block input operations */
-    long ru_oublock;		/* block output operations */
-    long ru_msgsnd;			/* messages sent */
-    long ru_msgrcv;			/* messages received */
-    long ru_nsignals;		/* signals received */
-    long ru_nvcsw;			/* voluntary context switches */
-    long ru_nivcsw;			/* involuntary context switches */
+    struct timeval ru_utime;    /* user time used */
+    struct timeval ru_stime;    /* system time used */
+    long ru_maxrss;         /* integral max resident set size */
+    long ru_ixrss;          /* integral shared text memory size */
+    long ru_idrss;          /* integral unshared data size */
+    long ru_isrss;          /* integral unshared stack size */
+    long ru_minflt;         /* page reclaims */
+    long ru_majflt;         /* page faults */
+    long ru_nswap;          /* swaps */
+    long ru_inblock;        /* block input operations */
+    long ru_oublock;        /* block output operations */
+    long ru_msgsnd;         /* messages sent */
+    long ru_msgrcv;         /* messages received */
+    long ru_nsignals;       /* signals received */
+    long ru_nvcsw;          /* voluntary context switches */
+    long ru_nivcsw;         /* involuntary context switches */
 };
 #endif /* HAVE_SYS_RESOURCE_H */
 
@@ -996,3 +996,4 @@ void WIN32_maperror(unsigned long WIN32_oserrno);
 
 #endif /* _SQUID_WINDOWS_ */
 #endif /* SQUID_OS_MSWINDOWS_H */
+
@@ -31,3 +31,4 @@
 
 #endif /* _SQUID_NETBSD_ */
 #endif /* SQUID_OS_NETBSD_H */
+
@@ -55,3 +55,4 @@
 
 #endif /* _SQUID_NEXT_ */
 #endif /* SQUID_OS_NEXT_H */
+
@@ -48,3 +48,4 @@
 
 #endif /* _SQUID_OPENBSD_ */
 #endif /* SQUID_OS_OPENBSD_H */
+
@@ -15,14 +15,14 @@
  * Use is subject to license terms.
  */
 
-/*	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T	*/
-/*	  All Rights Reserved  	*/
+/*  Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T */
+/*    All Rights Reserved   */
 
 /*
  * BIND 4.9.3:
  *
  * Copyright (c) 1980, 1983, 1988, 1993
- *	The Regents of the University of California.  All rights reserved.
+ *  The Regents of the University of California.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -34,8 +34,8 @@
  *    documentation and/or other materials provided with the distribution.
  * 3. All advertising materials mentioning features or use of this software
  *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
+ *  This product includes software developed by the University of
+ *  California, Berkeley and its contributors.
  * 4. Neither the name of the University nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
@@ -81,7 +81,7 @@
  */
 
 #ifndef _NETDB_H
-#define	_NETDB_H
+#define _NETDB_H
 
 #include <sys/types.h>
 #include <netinet/in.h>
@@ -90,398 +90,399 @@
 #endif /* !defined(_XPG4_2) || defined(_XPG6) || defined(__EXTENSIONS__) */
 #include <sys/feature_tests.h>
 
-#ifdef	__cplusplus
+#ifdef  __cplusplus
 extern "C" {
 #endif
 
-#define	_PATH_HEQUIV	"/etc/hosts.equiv"
-#define	_PATH_HOSTS	"/etc/hosts"
-#define	_PATH_IPNODES	"/etc/inet/ipnodes"
-#define	_PATH_IPSECALGS	"/etc/inet/ipsecalgs"
-#define	_PATH_NETMASKS	"/etc/netmasks"
-#define	_PATH_NETWORKS	"/etc/networks"
-#define	_PATH_PROTOCOLS	"/etc/protocols"
-#define	_PATH_SERVICES	"/etc/services"
-
-    struct	hostent {
-        char	*h_name;	/* official name of host */
-        char	**h_aliases;	/* alias list */
-        int	h_addrtype;	/* host address type */
-        int	h_length;	/* length of address */
-        char	**h_addr_list;	/* list of addresses from name server */
-#define	h_addr	h_addr_list[0]	/* address, for backward compatiblity */
-    };
-
-    /*
-     * addrinfo introduced with IPv6 for Protocol-Independent Hostname
-     * and Service Name Translation.
-     */
+#define _PATH_HEQUIV    "/etc/hosts.equiv"
+#define _PATH_HOSTS "/etc/hosts"
+#define _PATH_IPNODES   "/etc/inet/ipnodes"
+#define _PATH_IPSECALGS "/etc/inet/ipsecalgs"
+#define _PATH_NETMASKS  "/etc/netmasks"
+#define _PATH_NETWORKS  "/etc/networks"
+#define _PATH_PROTOCOLS "/etc/protocols"
+#define _PATH_SERVICES  "/etc/services"
+
+struct  hostent {
+    char    *h_name;    /* official name of host */
+    char    **h_aliases;    /* alias list */
+    int h_addrtype; /* host address type */
+    int h_length;   /* length of address */
+    char    **h_addr_list;  /* list of addresses from name server */
+#define h_addr  h_addr_list[0]  /* address, for backward compatiblity */
+};
+
+/*
+ * addrinfo introduced with IPv6 for Protocol-Independent Hostname
+ * and Service Name Translation.
+ */
 
 #if !defined(_XPG4_2) || defined(_XPG6) || defined(__EXTENSIONS__)
-    struct addrinfo {
-        int ai_flags;		/* AI_PASSIVE, AI_CANONNAME, ... */
-        int ai_family;		/* PF_xxx */
-        int ai_socktype;	/* SOCK_xxx */
-        int ai_protocol;	/* 0 or IPPROTO_xxx for IPv4 and IPv6 */
+struct addrinfo {
+    int ai_flags;       /* AI_PASSIVE, AI_CANONNAME, ... */
+    int ai_family;      /* PF_xxx */
+    int ai_socktype;    /* SOCK_xxx */
+    int ai_protocol;    /* 0 or IPPROTO_xxx for IPv4 and IPv6 */
 #ifdef __sparcv9
-        int _ai_pad;		/* for backwards compat with old size_t */
+    int _ai_pad;        /* for backwards compat with old size_t */
 #endif /* __sparcv9 */
-        socklen_t ai_addrlen;
-        char *ai_canonname;	/* canonical name for hostname */
-        struct sockaddr *ai_addr;	/* binary address */
-        struct addrinfo *ai_next;	/* next structure in linked list */
-    };
-
-    /* addrinfo flags */
-#define	AI_PASSIVE	0x0008	/* intended for bind() + listen() */
-#define	AI_CANONNAME	0x0010	/* return canonical version of host */
-#define	AI_NUMERICHOST	0x0020	/* use numeric node address string */
-#define	AI_NUMERICSERV	0x0040	/* servname is assumed numeric */
-
-    /* getipnodebyname() flags */
-#define	AI_V4MAPPED	0x0001	/* IPv4 mapped addresses if no IPv6 */
-#define	AI_ALL		0x0002	/* IPv6 and IPv4 mapped addresses */
-#define	AI_ADDRCONFIG	0x0004	/* AAAA or A records only if IPv6/IPv4 cnfg'd */
-
-    /*
-     * These were defined in RFC 2553 but not SUSv3
-     * or RFC 3493 which obsoleted 2553.
-     */
+    socklen_t ai_addrlen;
+    char *ai_canonname; /* canonical name for hostname */
+    struct sockaddr *ai_addr;   /* binary address */
+    struct addrinfo *ai_next;   /* next structure in linked list */
+};
+
+/* addrinfo flags */
+#define AI_PASSIVE  0x0008  /* intended for bind() + listen() */
+#define AI_CANONNAME    0x0010  /* return canonical version of host */
+#define AI_NUMERICHOST  0x0020  /* use numeric node address string */
+#define AI_NUMERICSERV  0x0040  /* servname is assumed numeric */
+
+/* getipnodebyname() flags */
+#define AI_V4MAPPED 0x0001  /* IPv4 mapped addresses if no IPv6 */
+#define AI_ALL      0x0002  /* IPv6 and IPv4 mapped addresses */
+#define AI_ADDRCONFIG   0x0004  /* AAAA or A records only if IPv6/IPv4 cnfg'd */
+
+/*
+ * These were defined in RFC 2553 but not SUSv3
+ * or RFC 3493 which obsoleted 2553.
+ */
 #if !defined(_XPG6) || defined(__EXTENSIONS__)
-#define	AI_DEFAULT	(AI_V4MAPPED | AI_ADDRCONFIG)
+#define AI_DEFAULT  (AI_V4MAPPED | AI_ADDRCONFIG)
 
-    /* addrinfo errors */
-#define	EAI_ADDRFAMILY	1	/* address family not supported */
-#define	EAI_NODATA	7	/* no address */
+/* addrinfo errors */
+#define EAI_ADDRFAMILY  1   /* address family not supported */
+#define EAI_NODATA  7   /* no address */
 #endif /* !defined(_XPG6) || defined(__EXTENSIONS__) */
-#define	EAI_AGAIN	2	/* DNS temporary failure */
-#define	EAI_BADFLAGS	3	/* invalid ai_flags */
-#define	EAI_FAIL	4	/* DNS non-recoverable failure */
-#define	EAI_FAMILY	5	/* ai_family not supported */
-#define	EAI_MEMORY	6	/* memory allocation failure */
-#define	EAI_NONAME	8	/* host/servname not known */
-#define	EAI_SERVICE	9	/* servname not supported for ai_socktype */
-#define	EAI_SOCKTYPE	10	/* ai_socktype not supported */
-#define	EAI_SYSTEM	11	/* system error in errno */
-#define	EAI_OVERFLOW	12	/* argument buffer overflow */
-#define	EAI_PROTOCOL	13
-#define	EAI_MAX		14
-
-    /* getnameinfo flags */
-#define	NI_NOFQDN	0x0001
-#define	NI_NUMERICHOST	0x0002	/* return numeric form of address */
-#define	NI_NAMEREQD	0x0004	/* request DNS name */
-#define	NI_NUMERICSERV	0x0008
-#define	NI_DGRAM	0x0010
+#define EAI_AGAIN   2   /* DNS temporary failure */
+#define EAI_BADFLAGS    3   /* invalid ai_flags */
+#define EAI_FAIL    4   /* DNS non-recoverable failure */
+#define EAI_FAMILY  5   /* ai_family not supported */
+#define EAI_MEMORY  6   /* memory allocation failure */
+#define EAI_NONAME  8   /* host/servname not known */
+#define EAI_SERVICE 9   /* servname not supported for ai_socktype */
+#define EAI_SOCKTYPE    10  /* ai_socktype not supported */
+#define EAI_SYSTEM  11  /* system error in errno */
+#define EAI_OVERFLOW    12  /* argument buffer overflow */
+#define EAI_PROTOCOL    13
+#define EAI_MAX     14
+
+/* getnameinfo flags */
+#define NI_NOFQDN   0x0001
+#define NI_NUMERICHOST  0x0002  /* return numeric form of address */
+#define NI_NAMEREQD 0x0004  /* request DNS name */
+#define NI_NUMERICSERV  0x0008
+#define NI_DGRAM    0x0010
 
 #if !defined(_XPG6) || defined(__EXTENSIONS__)
-    /* Not listed in any standards document */
-#define	NI_WITHSCOPEID  0x0020
-#define	NI_NUMERICSCOPE 0x0040
+/* Not listed in any standards document */
+#define NI_WITHSCOPEID  0x0020
+#define NI_NUMERICSCOPE 0x0040
 
-    /* getnameinfo max sizes as defined in RFC 2553 obsoleted in RFC 3493 */
-#define	NI_MAXHOST	1025
-#define	NI_MAXSERV	32
+/* getnameinfo max sizes as defined in RFC 2553 obsoleted in RFC 3493 */
+#define NI_MAXHOST  1025
+#define NI_MAXSERV  32
 #endif /* !defined(_XPG6) || defined(__EXTENSIONS__) */
 #endif /* !defined(_XPG4_2) || defined(_XPG6) || defined(__EXTENSIONS__) */
 
-    /*
-     * Scope delimit character
-     */
-#define	SCOPE_DELIMITER	'%'
+/*
+ * Scope delimit character
+ */
+#define SCOPE_DELIMITER '%'
 
-    /*
-     * Algorithm entry for /etc/inet/ipsecalgs which defines IPsec protocols
-     * and algorithms.
-     */
+/*
+ * Algorithm entry for /etc/inet/ipsecalgs which defines IPsec protocols
+ * and algorithms.
+ */
 #if !defined(_XPG4_2) || defined(__EXTENSIONS__)
-    typedef struct ipsecalgent {
-        char **a_names;		/* algorithm names */
-        int a_proto_num;	/* protocol number */
-        int a_alg_num;		/* algorithm number */
-        char *a_mech_name;	/* encryption framework mechanism name */
-        int *a_block_sizes;	/* supported block sizes */
-        int *a_key_sizes;	/* supported key sizes */
-        int a_key_increment;	/* key size increment */
-        int *a_mech_params;	/* mechanism specific parameters */
-        int a_alg_flags;	/* algorithm flags */
-    } ipsecalgent_t;
-
-    /* well-known IPsec protocol numbers */
-
-#define	IPSEC_PROTO_AH		2
-#define	IPSEC_PROTO_ESP		3
+typedef struct ipsecalgent {
+    char **a_names;     /* algorithm names */
+    int a_proto_num;    /* protocol number */
+    int a_alg_num;      /* algorithm number */
+    char *a_mech_name;  /* encryption framework mechanism name */
+    int *a_block_sizes; /* supported block sizes */
+    int *a_key_sizes;   /* supported key sizes */
+    int a_key_increment;    /* key size increment */
+    int *a_mech_params; /* mechanism specific parameters */
+    int a_alg_flags;    /* algorithm flags */
+} ipsecalgent_t;
+
+/* well-known IPsec protocol numbers */
+
+#define IPSEC_PROTO_AH      2
+#define IPSEC_PROTO_ESP     3
 #endif /* !defined(_XPG4_2) || defined(__EXTENSIONS__) */
 
-    /*
-     * Assumption here is that a network number
-     * fits in 32 bits -- probably a poor one.
-     */
-    struct	netent {
-        char		*n_name;	/* official name of net */
-        char		**n_aliases;	/* alias list */
-        int		n_addrtype;	/* net address type */
-        in_addr_t	n_net;		/* network # */
-    };
-
-    struct	protoent {
-        char	*p_name;	/* official protocol name */
-        char	**p_aliases;	/* alias list */
-        int	p_proto;	/* protocol # */
-    };
-
-    struct	servent {
-        char	*s_name;	/* official service name */
-        char	**s_aliases;	/* alias list */
-        int	s_port;		/* port # */
-        char	*s_proto;	/* protocol to use */
-    };
-
-#ifdef	__STDC__
+/*
+ * Assumption here is that a network number
+ * fits in 32 bits -- probably a poor one.
+ */
+struct  netent {
+    char        *n_name;    /* official name of net */
+    char        **n_aliases;    /* alias list */
+    int     n_addrtype; /* net address type */
+    in_addr_t   n_net;      /* network # */
+};
+
+struct  protoent {
+    char    *p_name;    /* official protocol name */
+    char    **p_aliases;    /* alias list */
+    int p_proto;    /* protocol # */
+};
+
+struct  servent {
+    char    *s_name;    /* official service name */
+    char    **s_aliases;    /* alias list */
+    int s_port;     /* port # */
+    char    *s_proto;   /* protocol to use */
+};
+
+#ifdef  __STDC__
 #if !defined(_XPG4_2) || defined(__EXTENSIONS__)
-    struct hostent	*gethostbyname_r
-    (const char *, struct hostent *, char *, int, int *h_errnop);
-    struct hostent	*gethostbyaddr_r
-    (const char *, int, int, struct hostent *, char *, int, int *h_errnop);
-    struct hostent	*getipnodebyname(const char *, int, int, int *);
-    struct hostent	*getipnodebyaddr(const void *, size_t, int, int *);
-    void		freehostent(struct hostent *);
-    struct hostent	*gethostent_r(struct hostent *, char *, int, int *h_errnop);
-
-    struct servent	*getservbyname_r
-    (const char *name, const char *, struct servent *, char *, int);
-    struct servent	*getservbyport_r
-    (int port, const char *, struct servent *, char *, int);
-    struct servent	*getservent_r(struct	servent *, char *, int);
-
-    struct netent	*getnetbyname_r
-    (const char *, struct netent *, char *, int);
-    struct netent	*getnetbyaddr_r(long, int, struct netent *, char *, int);
-    struct netent	*getnetent_r(struct netent *, char *, int);
-
-    struct protoent	*getprotobyname_r
-    (const char *, struct protoent *, char *, int);
-    struct protoent	*getprotobynumber_r
-    (int, struct protoent *, char *, int);
-    struct protoent	*getprotoent_r(struct protoent *, char *, int);
-
-    int getnetgrent_r(char **, char **, char **, char *, int);
-    int innetgr(const char *, const char *, const char *, const char *);
+struct hostent  *gethostbyname_r
+(const char *, struct hostent *, char *, int, int *h_errnop);
+struct hostent  *gethostbyaddr_r
+(const char *, int, int, struct hostent *, char *, int, int *h_errnop);
+struct hostent  *getipnodebyname(const char *, int, int, int *);
+struct hostent  *getipnodebyaddr(const void *, size_t, int, int *);
+void        freehostent(struct hostent *);
+struct hostent  *gethostent_r(struct hostent *, char *, int, int *h_errnop);
+
+struct servent  *getservbyname_r
+(const char *name, const char *, struct servent *, char *, int);
+struct servent  *getservbyport_r
+(int port, const char *, struct servent *, char *, int);
+struct servent  *getservent_r(struct    servent *, char *, int);
+
+struct netent   *getnetbyname_r
+(const char *, struct netent *, char *, int);
+struct netent   *getnetbyaddr_r(long, int, struct netent *, char *, int);
+struct netent   *getnetent_r(struct netent *, char *, int);
+
+struct protoent *getprotobyname_r
+(const char *, struct protoent *, char *, int);
+struct protoent *getprotobynumber_r
+(int, struct protoent *, char *, int);
+struct protoent *getprotoent_r(struct protoent *, char *, int);
+
+int getnetgrent_r(char **, char **, char **, char *, int);
+int innetgr(const char *, const char *, const char *, const char *);
 #endif /* !defined(_XPG4_2) || defined(__EXTENSIONS__) */
 
-    /* Old interfaces that return a pointer to a static area;  MT-unsafe */
-    struct hostent	*gethostbyname(const char *);
-    struct hostent	*gethostent(void);
-    struct netent	*getnetbyaddr(in_addr_t, int);
-    struct netent	*getnetbyname(const char *);
-    struct netent	*getnetent(void);
-    struct protoent	*getprotobyname(const char *);
-    struct protoent	*getprotobynumber(int);
-    struct protoent	*getprotoent(void);
-    struct servent	*getservbyname(const char *, const char *);
-    struct servent	*getservbyport(int, const char *);
-    struct servent	*getservent(void);
-
-    /* gethostbyaddr() second argument is a size_t only in unix95/unix98 */
+/* Old interfaces that return a pointer to a static area;  MT-unsafe */
+struct hostent  *gethostbyname(const char *);
+struct hostent  *gethostent(void);
+struct netent   *getnetbyaddr(in_addr_t, int);
+struct netent   *getnetbyname(const char *);
+struct netent   *getnetent(void);
+struct protoent *getprotobyname(const char *);
+struct protoent *getprotobynumber(int);
+struct protoent *getprotoent(void);
+struct servent  *getservbyname(const char *, const char *);
+struct servent  *getservbyport(int, const char *);
+struct servent  *getservent(void);
+
+/* gethostbyaddr() second argument is a size_t only in unix95/unix98 */
 #if !defined(_XPG4_2) || defined(_XPG6) || defined(__EXTENSIONS__)
-    struct hostent	*gethostbyaddr(const void *, socklen_t, int);
+struct hostent  *gethostbyaddr(const void *, socklen_t, int);
 #else
-    struct hostent	*gethostbyaddr(const void *, size_t, int);
+struct hostent  *gethostbyaddr(const void *, size_t, int);
 #endif /* !defined(_XPG4_2) || defined(_XPG6) || defined(__EXTENSIONS__) */
 
 #if !defined(_XPG4_2) || defined(__EXTENSIONS__)
-    int endhostent(void);
-    int endnetent(void);
-    int endprotoent(void);
-    int endservent(void);
-    int sethostent(int);
-    int setnetent(int);
-    int setprotoent(int);
-    int setservent(int);
+int endhostent(void);
+int endnetent(void);
+int endprotoent(void);
+int endservent(void);
+int sethostent(int);
+int setnetent(int);
+int setprotoent(int);
+int setservent(int);
 #else
-    void endhostent(void);
-    void endnetent(void);
-    void endprotoent(void);
-    void endservent(void);
-    void sethostent(int);
-    void setnetent(int);
-    void setprotoent(int);
-    void setservent(int);
+void endhostent(void);
+void endnetent(void);
+void endprotoent(void);
+void endservent(void);
+void sethostent(int);
+void setnetent(int);
+void setprotoent(int);
+void setservent(int);
 #endif /* !defined(_XPG4_2) || defined(__EXTENSIONS__) */
 
 #if !defined(_XPG4_2) || defined(_XPG6) || defined(__EXTENSIONS__)
 
-#ifdef	_XPG6
-#ifdef	__PRAGMA_REDEFINE_EXTNAME
+#ifdef  _XPG6
+#ifdef  __PRAGMA_REDEFINE_EXTNAME
 #pragma redefine_extname getaddrinfo __xnet_getaddrinfo
-#else	/* __PRAGMA_REDEFINE_EXTNAME */
-#define	getaddrinfo __xnet_getaddrinfo
-#endif	/* __PRAGMA_REDEFINE_EXTNAME */
-#endif	/* _XPG6 */
-
-    int		getaddrinfo(const char *_RESTRICT_KYWD1,
-                     const char *_RESTRICT_KYWD2,
-                     const struct addrinfo *_RESTRICT_KYWD3,
-                     struct addrinfo **_RESTRICT_KYWD4);
-    void		freeaddrinfo(struct addrinfo *);
-    const char	*gai_strerror(int);
-    int		getnameinfo(const struct sockaddr *_RESTRICT_KYWD1,
-                     socklen_t, char *_RESTRICT_KYWD2, socklen_t,
-                     char *_RESTRICT_KYWD3, socklen_t, int);
+#else   /* __PRAGMA_REDEFINE_EXTNAME */
+#define getaddrinfo __xnet_getaddrinfo
+#endif  /* __PRAGMA_REDEFINE_EXTNAME */
+#endif  /* _XPG6 */
+
+int     getaddrinfo(const char *_RESTRICT_KYWD1,
+                    const char *_RESTRICT_KYWD2,
+                    const struct addrinfo *_RESTRICT_KYWD3,
+                    struct addrinfo **_RESTRICT_KYWD4);
+void        freeaddrinfo(struct addrinfo *);
+const char  *gai_strerror(int);
+int     getnameinfo(const struct sockaddr *_RESTRICT_KYWD1,
+                    socklen_t, char *_RESTRICT_KYWD2, socklen_t,
+                    char *_RESTRICT_KYWD3, socklen_t, int);
 #endif /* !defined(_XPG4_2) || defined(_XPG6) || defined(__EXTENSIONS__) */
 
 #if !defined(_XPG4_2) || defined(__EXTENSIONS__)
-    int getnetgrent(char **, char **, char **);
-    int setnetgrent(const char *);
-    int endnetgrent(void);
-    int rcmd(char **, unsigned short,
-             const char *, const char *, const char *, int *);
-    int rcmd_af(char **, unsigned short,
-                const char *, const char *, const char *, int *, int);
-    int rresvport_af(int *, int);
-    int rresvport_addr(int *, struct sockaddr_storage *);
-    int rexec(char **, unsigned short,
-              const char *, const char *, const char *, int *);
-    int rexec_af(char **, unsigned short,
-                 const char *, const char *, const char *, int *, int);
-    int rresvport(int *);
-    int ruserok(const char *, int, const char *, const char *);
-    /* BIND */
-    struct hostent	*gethostbyname2(const char *, int);
-    void		herror(const char *);
-    const char	*hstrerror(int);
-    /* End BIND */
-
-    /* IPsec algorithm prototype definitions */
-    struct ipsecalgent *getipsecalgbyname(const char *, int, int *);
-    struct ipsecalgent *getipsecalgbynum(int, int, int *);
-    int getipsecprotobyname(const char *doi_name);
-    char *getipsecprotobynum(int doi_domain);
-    void freeipsecalgent(struct ipsecalgent *ptr);
-    /* END IPsec algorithm prototype definitions */
+int getnetgrent(char **, char **, char **);
+int setnetgrent(const char *);
+int endnetgrent(void);
+int rcmd(char **, unsigned short,
+         const char *, const char *, const char *, int *);
+int rcmd_af(char **, unsigned short,
+            const char *, const char *, const char *, int *, int);
+int rresvport_af(int *, int);
+int rresvport_addr(int *, struct sockaddr_storage *);
+int rexec(char **, unsigned short,
+          const char *, const char *, const char *, int *);
+int rexec_af(char **, unsigned short,
+             const char *, const char *, const char *, int *, int);
+int rresvport(int *);
+int ruserok(const char *, int, const char *, const char *);
+/* BIND */
+struct hostent  *gethostbyname2(const char *, int);
+void        herror(const char *);
+const char  *hstrerror(int);
+/* End BIND */
+
+/* IPsec algorithm prototype definitions */
+struct ipsecalgent *getipsecalgbyname(const char *, int, int *);
+struct ipsecalgent *getipsecalgbynum(int, int, int *);
+int getipsecprotobyname(const char *doi_name);
+char *getipsecprotobynum(int doi_domain);
+void freeipsecalgent(struct ipsecalgent *ptr);
+/* END IPsec algorithm prototype definitions */
 
 #endif /* !defined(_XPG4_2) || defined(__EXTENSIONS__) */
-#else	/* __STDC__ */
-    struct hostent	*gethostbyname_r();
-    struct hostent	*gethostbyaddr_r();
-    struct hostent	*getipnodebyname();
-    struct hostent	*getipnodebyaddr();
-    void		 freehostent();
-    struct hostent	*gethostent_r();
-    struct servent	*getservbyname_r();
-    struct servent	*getservbyport_r();
-    struct servent	*getservent_r();
-    struct netent	*getnetbyname_r();
-    struct netent	*getnetbyaddr_r();
-    struct netent	*getnetent_r();
-    struct protoent	*getprotobyname_r();
-    struct protoent	*getprotobynumber_r();
-    struct protoent	*getprotoent_r();
-    int		 getnetgrent_r();
-    int		 innetgr();
-
-    /* Old interfaces that return a pointer to a static area;  MT-unsafe */
-    struct hostent	*gethostbyname();
-    struct hostent	*gethostbyaddr();
-    struct hostent	*gethostent();
-    struct netent	*getnetbyname();
-    struct netent	*getnetbyaddr();
-    struct netent	*getnetent();
-    struct servent	*getservbyname();
-    struct servent	*getservbyport();
-    struct servent	*getservent();
-    struct protoent	*getprotobyname();
-    struct protoent	*getprotobynumber();
-    struct protoent	*getprotoent();
-    int		 getnetgrent();
-
-    int sethostent();
-    int endhostent();
-    int setnetent();
-    int endnetent();
-    int setservent();
-    int endservent();
-    int setprotoent();
-    int endprotoent();
-    int setnetgrent();
-    int endnetgrent();
-    int rcmd();
-    int rcmd_af();
-    int rexec();
-    int rexec_af();
-    int rresvport();
-    int rresvport_af();
-    int rresvport_addr();
-    int ruserok();
-    /* BIND */
-    struct hostent	*gethostbyname2();
-    void		herror();
-    char		*hstrerror();
-    /* IPv6 prototype definitons */
-    int		getaddrinfo();
-    void		freeaddrinfo();
-    const char	*gai_strerror();
-    int		getnameinfo();
-    /* END IPv6 prototype definitions */
-    /* End BIND */
+#else   /* __STDC__ */
+struct hostent  *gethostbyname_r();
+struct hostent  *gethostbyaddr_r();
+struct hostent  *getipnodebyname();
+struct hostent  *getipnodebyaddr();
+void         freehostent();
+struct hostent  *gethostent_r();
+struct servent  *getservbyname_r();
+struct servent  *getservbyport_r();
+struct servent  *getservent_r();
+struct netent   *getnetbyname_r();
+struct netent   *getnetbyaddr_r();
+struct netent   *getnetent_r();
+struct protoent *getprotobyname_r();
+struct protoent *getprotobynumber_r();
+struct protoent *getprotoent_r();
+int      getnetgrent_r();
+int      innetgr();
+
+/* Old interfaces that return a pointer to a static area;  MT-unsafe */
+struct hostent  *gethostbyname();
+struct hostent  *gethostbyaddr();
+struct hostent  *gethostent();
+struct netent   *getnetbyname();
+struct netent   *getnetbyaddr();
+struct netent   *getnetent();
+struct servent  *getservbyname();
+struct servent  *getservbyport();
+struct servent  *getservent();
+struct protoent *getprotobyname();
+struct protoent *getprotobynumber();
+struct protoent *getprotoent();
+int      getnetgrent();
+
+int sethostent();
+int endhostent();
+int setnetent();
+int endnetent();
+int setservent();
+int endservent();
+int setprotoent();
+int endprotoent();
+int setnetgrent();
+int endnetgrent();
+int rcmd();
+int rcmd_af();
+int rexec();
+int rexec_af();
+int rresvport();
+int rresvport_af();
+int rresvport_addr();
+int ruserok();
+/* BIND */
+struct hostent  *gethostbyname2();
+void        herror();
+char        *hstrerror();
+/* IPv6 prototype definitons */
+int     getaddrinfo();
+void        freeaddrinfo();
+const char  *gai_strerror();
+int     getnameinfo();
+/* END IPv6 prototype definitions */
+/* End BIND */
 
 #if !defined(_XPG4_2) || defined(__EXTENSIONS__)
-    /* IPsec algorithm prototype definitions */
-    struct ipsecalgent *getalgbyname();
-    struct ipsecalgent *getalgbydoi();
-    int getdoidomainbyname();
-    const char *getdoidomainbynum();
-    void freealgent();
-    /* END IPsec algorithm prototype definitions */
+/* IPsec algorithm prototype definitions */
+struct ipsecalgent *getalgbyname();
+struct ipsecalgent *getalgbydoi();
+int getdoidomainbyname();
+const char *getdoidomainbynum();
+void freealgent();
+/* END IPsec algorithm prototype definitions */
 #endif /* !defined(_XPG4_2) || defined(__EXTENSIONS__) */
 
-#endif	/* __STDC__ */
+#endif  /* __STDC__ */
 
-    /*
-     * Error return codes from gethostbyname() and gethostbyaddr()
-     * (when using the resolver)
-     */
+/*
+ * Error return codes from gethostbyname() and gethostbyaddr()
+ * (when using the resolver)
+ */
 
-    extern  int h_errno;
+extern  int h_errno;
 
-#ifdef	_REENTRANT
-#ifdef	__STDC__
-    extern int	*__h_errno(void);
+#ifdef  _REENTRANT
+#ifdef  __STDC__
+extern int  *__h_errno(void);
 #else
-    extern int	*__h_errno();
-#endif	/* __STDC__ */
-
-    /* Only #define h_errno if there is no conflict with other use */
-#ifdef	H_ERRNO_IS_FUNCTION
-#define	h_errno	(*__h_errno())
-#endif	/* NO_H_ERRNO_DEFINE */
-#endif	/* _REENTRANT */
-
-    /*
-     * Error return codes from gethostbyname() and gethostbyaddr()
-     * (left in extern int h_errno).
-     */
-#define	HOST_NOT_FOUND	1 /* Authoritive Answer Host not found */
-#define	TRY_AGAIN	2 /* Non-Authoritive Host not found, or SERVERFAIL */
-#define	NO_RECOVERY	3 /* Non recoverable errors, FORMERR, REFUSED, NOTIMP */
-#define	NO_DATA		4 /* Valid name, no data record of requested type */
+extern int  *__h_errno();
+#endif  /* __STDC__ */
+
+/* Only #define h_errno if there is no conflict with other use */
+#ifdef  H_ERRNO_IS_FUNCTION
+#define h_errno (*__h_errno())
+#endif  /* NO_H_ERRNO_DEFINE */
+#endif  /* _REENTRANT */
+
+/*
+ * Error return codes from gethostbyname() and gethostbyaddr()
+ * (left in extern int h_errno).
+ */
+#define HOST_NOT_FOUND  1 /* Authoritive Answer Host not found */
+#define TRY_AGAIN   2 /* Non-Authoritive Host not found, or SERVERFAIL */
+#define NO_RECOVERY 3 /* Non recoverable errors, FORMERR, REFUSED, NOTIMP */
+#define NO_DATA     4 /* Valid name, no data record of requested type */
 
 #if !defined(_XPG4_2) || defined(__EXTENSIONS__)
-#define	NO_ADDRESS	NO_DATA		/* no address, look for MX record */
+#define NO_ADDRESS  NO_DATA     /* no address, look for MX record */
 
-    /* BIND */
-#define	NETDB_INTERNAL	-1	/* see errno */
-#define	NETDB_SUCCESS	0	/* no problem */
-    /* End BIND */
+/* BIND */
+#define NETDB_INTERNAL  -1  /* see errno */
+#define NETDB_SUCCESS   0   /* no problem */
+/* End BIND */
 
-#define	MAXHOSTNAMELEN	256
+#define MAXHOSTNAMELEN  256
 
-#define	MAXALIASES	35
-#define	MAXADDRS	35
+#define MAXALIASES  35
+#define MAXADDRS    35
 #endif /* !defined(_XPG4_2) || defined(__EXTENSIONS__) */
 
-#ifdef	__cplusplus
+#ifdef  __cplusplus
 }
 #endif
 
-#endif	/* _NETDB_H */
+#endif  /* _NETDB_H */
+
@@ -25,3 +25,4 @@
 
 #endif /* _SQUID_OS2_ */
 #endif /* SQUID_OS_OS2_H */
+
@@ -24,3 +24,4 @@
 
 #endif /* _SQUID_QNX_ */
 #endif /* SQUID_OS_QNX_H */
+
@@ -18,7 +18,7 @@
  ****************************************************************************/
 
 #if !defined(_SVR4_SOURCE)
-#define _SVR4_SOURCE		/* for tempnam(3) */
+#define _SVR4_SOURCE        /* for tempnam(3) */
 #endif
 
 #if USE_ASYNC_IO
@@ -36,3 +36,4 @@
 
 #endif /* _SQUID_SGI_ */
 #endif /* SQUID_OS_SGI_H */
+
@@ -28,14 +28,14 @@
 #if defined(i386) || defined(__i386)
 #if !HAVE_PAD128_T
 typedef union {
-    long double	_q;
-    int32_t		_l[4];
+    long double _q;
+    int32_t     _l[4];
 } pad128_t;
 #endif
 #if !HAVE_UPAD128_T
 typedef union {
-    long double	_q;
-    uint32_t	_l[4];
+    long double _q;
+    uint32_t    _l[4];
 } upad128_t;
 #endif
 #endif
@@ -105,3 +105,4 @@ SQUIDCEXTERN int gethostname(char *, int);
 
 #endif /* _SQUID_SOLARIS_ */
 #endif /* SQUID_OS_SOALRIS_H */
+
@@ -29,3 +29,4 @@
 
 #endif /* _SQUID_SUNOS_ */
 #endif /* SQUID_OS_SUNOS_H */
+
@@ -31,25 +31,25 @@
 #define _SQUID_SUNOS_ 1
 #endif /* __SVR4 */
 
-#elif defined(__hpux)		/* HP-UX - SysV-like? */
+#elif defined(__hpux)       /* HP-UX - SysV-like? */
 #define _SQUID_HPUX_ 1
 
-#elif defined(__osf__)		/* OSF/1 */
+#elif defined(__osf__)      /* OSF/1 */
 #define _SQUID_OSF_ 1
 
-#elif defined(_AIX)		/* AIX */
+#elif defined(_AIX)     /* AIX */
 #define _SQUID_AIX_ 1
 
-#elif defined(__linux__)	/* Linux. WARNING: solaris-x86 also sets this */
+#elif defined(__linux__)    /* Linux. WARNING: solaris-x86 also sets this */
 #define _SQUID_LINUX_ 1
 
-#elif defined(__FreeBSD__)	/* FreeBSD */
+#elif defined(__FreeBSD__)  /* FreeBSD */
 #define _SQUID_FREEBSD_ 1
 
 #elif defined(__FreeBSD_kernel__)      /* GNU/kFreeBSD */
 #define _SQUID_KFREEBSD_ 1
 
-#elif defined(__sgi__)	|| defined(sgi) || defined(__sgi)	/* SGI */
+#elif defined(__sgi__)  || defined(sgi) || defined(__sgi)   /* SGI */
 #define _SQUID_SGI_ 1
 
 #elif defined(__NeXT__)
@@ -90,3 +90,4 @@
 #endif /* OS automatic detection */
 
 #endif /* SQUID_COMPAT_OSDETECT_H */
+
@@ -27,3 +27,4 @@ psignal( int sig, const char* msg )
     else
         fputs( "(unknown)\n", stderr );
 }
+
@@ -16,3 +16,4 @@
 extern void psignal(int sig, const char* msg);
 
 #endif /* __SQUID_PSIGNAL_H */
+
@@ -33,3 +33,4 @@ shm_portable_segment_name_is_path()
     return false;
 #endif
 }
+
@@ -51,3 +51,4 @@ extern "C" {
 bool shm_portable_segment_name_is_path();
 
 #endif /* SQUID_COMPAT_CPU_H */
+
@@ -82,3 +82,4 @@ xstatvfs(const char *path, struct statvfs *sfs)
 }
 
 #endif /* HAVE_STATVFS */
+
@@ -32,7 +32,6 @@
 #endif
 #endif /* !HAVE_STATVFS */
 
-
 #if HAVE_STATVFS
 #define xstatvfs statvfs
 
@@ -63,3 +62,4 @@ int xstatvfs(const char *path, struct statvfs *buf);
 #endif
 
 #endif /* _SQUID_COMPAT_XSTATVFS_H */
+
@@ -63,3 +63,4 @@ inline FILE * tmpfile(void) { return tmpfile64(); }
 #endif
 
 #endif /* _SQUID_COMPAT_STDIO_H */
+
@@ -47,3 +47,4 @@
 #endif
 
 #endif /* _SQUID_STDVARARGS_H */
+
@@ -23,3 +23,4 @@ strerror(int ern)
 {
     return sys_errlist[ern];
 }
+
@@ -22,3 +22,4 @@ strnrchr(const char *s, size_t count, int c)
     }
     return rv;
 }
+
@@ -22,3 +22,4 @@
 SQUIDCEXTERN const char *strnrchr(const char *s, size_t count, int c);
 
 #endif /* COMPAT_STRNRCHR_H_ */
+
@@ -16,9 +16,9 @@
  * Update/Maintenance History:
  *
  *    26-Apr-2008 : Copied from FreeBSD via OpenGrok
- * 			- added protection around libray headers
- * 			- added squid_ prefix for uniqueness
- * 			  so we can use it where OS copy is broken.
+ *          - added protection around libray headers
+ *          - added squid_ prefix for uniqueness
+ *            so we can use it where OS copy is broken.
  *
  *  Original License and code follows.
  */
@@ -30,7 +30,7 @@
 /*-
  * Copyright (c) 2001 Mike Barcroft <mike@FreeBSD.org>
  * Copyright (c) 1990, 1993
- *	The Regents of the University of California.  All rights reserved.
+ *  The Regents of the University of California.  All rights reserved.
  *
  * This code is derived from software contributed to Berkeley by
  * Chris Torek.
@@ -59,7 +59,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * @(#)strstr.c	8.1 (Berkeley) 6/4/93
+ * @(#)strstr.c 8.1 (Berkeley) 6/4/93
  * $FreeBSD: src/lib/libc/string/strnstr.c,v 1.2.2.1 2001/12/09 06:50:03 mike Exp $
  * $DragonFly: src/lib/libc/string/strnstr.c,v 1.4 2006/03/20 17:24:20 dillon Exp $
  */
@@ -98,3 +98,4 @@ squid_strnstr(const char *s, const char *find, size_t slen)
 
 #endif /* !HAVE_STRNSTR */
 #endif /* SQUID_COMPAT_STRNSTR_CC_ */
+
@@ -20,8 +20,8 @@
  *    documentation and/or other materials provided with the distribution.
  * 3. All advertising materials mentioning features or use of this software
  *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
+ *  This product includes software developed by the University of
+ *  California, Berkeley and its contributors.
  * 4. Neither the name of the University nor the names of its contributors
  *    may be used to endorse or promote products derived from this software
  *    without specific prior written permission.
@@ -23,3 +23,4 @@ SQUIDCEXTERN int64_t strtoll(const char *nptr, char **endptr, int base);
 
 #endif /* !HAVE_STRTOLL */
 #endif /* _SQUID_COMPAT_STRTOLL_H */
+
@@ -31,20 +31,20 @@
 
 #undef TMP_MAX
 
-#define _tmp		"/tmp/"
-#define lengthof_tmp	5
+#define _tmp        "/tmp/"
+#define lengthof_tmp    5
 
 #ifndef LONG_BIT
-#define LONG_BIT	(CHAR_BIT * 4)	/* assume sizeof(long) == 4 */
+#define LONG_BIT    (CHAR_BIT * 4)  /* assume sizeof(long) == 4 */
 #endif
 
-#define L_tmpmin	(lengthof_tmp + 5)	/* 5 chars for pid. */
+#define L_tmpmin    (lengthof_tmp + 5)  /* 5 chars for pid. */
 
 #if (L_tmpnam > L_tmpmin)
-#if (L_tmpnam > L_tmpmin + LONG_BIT / 6)	/* base 64 */
-#define TMP_MAX	ULONG_MAX
+#if (L_tmpnam > L_tmpmin + LONG_BIT / 6)    /* base 64 */
+#define TMP_MAX ULONG_MAX
 #else
-#define TMP_MAX	((1L << (6 * (L_tmpnam - L_tmpmin))) - 1)
+#define TMP_MAX ((1L << (6 * (L_tmpnam - L_tmpmin))) - 1)
 #endif
 #else
 #ifndef L_tmpnam
@@ -60,10 +60,10 @@ _tmpnam(void)
     static const char digits[] =
 #if (L_tmpnam >= L_tmpmin + LONG_BIT / 4)
         "0123456789abcdef";
-#define TMP_BASE	16
+#define TMP_BASE    16
 #else
         "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-";
-#define TMP_BASE	64
+#define TMP_BASE    64
 #endif
     static unsigned long lastcount = 0;
     static char buffer[L_tmpnam + 1];
@@ -72,7 +72,7 @@ _tmpnam(void)
     pid_t pid = getpid();
 
     if (sizeof(_tmp) - 1 != lengthof_tmp)
-        abort();		/* Consistency error. */
+        abort();        /* Consistency error. */
 
     for (;;) {
         register int i = L_tmpnam;
@@ -135,3 +135,4 @@ main()
     return 1;
 }
 #endif
+
@@ -31,3 +31,4 @@
 extern char *tempnam(const char *, const char *);
 
 #endif /* SQUID_TEMPNAM_H */
+
@@ -30,3 +30,4 @@ class testPreCompiler : public CPPUNIT_NS::TestFixture
 };
 
 #endif /* SQUID_COMPAT_TESTS_TESTPRECOMPILER_H */
+
@@ -124,3 +124,4 @@ typedef long mtyp_t;
 #endif
 
 #endif /* SQUID_TYPES_H */
+
@@ -43,3 +43,4 @@
 #endif /* WITH_VALGRIND */
 
 #endif /* SQUID_CONFIG_H */
+
@@ -176,3 +176,4 @@ free_const(const void *s_const)
     PROF_stop(free);
     PROF_stop(free_const);
 }
+
@@ -13,63 +13,63 @@
 extern "C" {
 #endif
 
-    /**
-     * xcalloc() - same as calloc(3).  Used for portability.
-     * Never returns NULL; fatal on error.
-     *
-     * Define failure_notify to receive error message.
-     * otherwise perror() is used to display it.
-     */
-    void *xcalloc(size_t n, size_t sz);
+/**
+ * xcalloc() - same as calloc(3).  Used for portability.
+ * Never returns NULL; fatal on error.
+ *
+ * Define failure_notify to receive error message.
+ * otherwise perror() is used to display it.
+ */
+void *xcalloc(size_t n, size_t sz);
 
-    /**
-     * xmalloc() - same as malloc(3).  Used for portability.
-     * Never returns NULL; fatal on error.
-     *
-     * Define failure_notify to receive error message.
-     * otherwise perror() is used to display it.
-     */
-    void *xmalloc(size_t sz);
+/**
+ * xmalloc() - same as malloc(3).  Used for portability.
+ * Never returns NULL; fatal on error.
+ *
+ * Define failure_notify to receive error message.
+ * otherwise perror() is used to display it.
+ */
+void *xmalloc(size_t sz);
 
-    /**
-     * xrealloc() - same as realloc(3). Used for portability.
-     * Never returns NULL; fatal on error.
-     */
-    void *xrealloc(void *s, size_t sz);
+/**
+ * xrealloc() - same as realloc(3). Used for portability.
+ * Never returns NULL; fatal on error.
+ */
+void *xrealloc(void *s, size_t sz);
 
-    /**
-     * free_const() - Same as free(3).  Used for portability.
-     * Accepts pointers to dynamically allocated const data.
-     *
-     * Define failure_notify to receive error message.
-     * otherwise perror() is used to display it.
-     */
-    void free_const(const void *s);
+/**
+ * free_const() - Same as free(3).  Used for portability.
+ * Accepts pointers to dynamically allocated const data.
+ *
+ * Define failure_notify to receive error message.
+ * otherwise perror() is used to display it.
+ */
+void free_const(const void *s);
 
-    /**
-     *  xfree() - same as free(3).  Used for portability.
-     * Accepts pointers to dynamically allocated const data.
-     * Will not call free(3) if the pointer is NULL.
-     *
-     * Pointer is left with a value on completion.
-     * Use safe_free() if the pointer needs to be set to NULL afterward.
-     *
-     * Define failure_notify to receive error message.
-     * otherwise perror() is used to display it.
-     */
-    static inline void xfree(const void *p) { if (p) free_const(p); }
+/**
+ *  xfree() - same as free(3).  Used for portability.
+ * Accepts pointers to dynamically allocated const data.
+ * Will not call free(3) if the pointer is NULL.
+ *
+ * Pointer is left with a value on completion.
+ * Use safe_free() if the pointer needs to be set to NULL afterward.
+ *
+ * Define failure_notify to receive error message.
+ * otherwise perror() is used to display it.
+ */
+static inline void xfree(const void *p) { if (p) free_const(p); }
 
-    /**
-     *  safe_free() - same as free(3).  Used for portability.
-     * Accepts pointers to dynamically allocated const data.
-     * Will not call free(3) if the pointer is NULL.
-     * Sets the pointer to NULL on completion.
-     *
-     * Use xfree() if the pointer does not need to be set afterward.
-     *
-     * Define failure_notify to receive error message.
-     * otherwise perror() is used to display it.
-     */
+/**
+ *  safe_free() - same as free(3).  Used for portability.
+ * Accepts pointers to dynamically allocated const data.
+ * Will not call free(3) if the pointer is NULL.
+ * Sets the pointer to NULL on completion.
+ *
+ * Use xfree() if the pointer does not need to be set afterward.
+ *
+ * Define failure_notify to receive error message.
+ * otherwise perror() is used to display it.
+ */
 #define safe_free(x)    while ((x)) { free_const((x)); (x) = NULL; }
 
 #ifdef __cplusplus
@@ -81,3 +81,4 @@ extern void malloc_statistics(void (*func) (int, int, int, void *), void *data);
 #endif
 
 #endif /* _SQUID_COMPAT_XALLOC_H */
+
@@ -28,3 +28,4 @@
 #define xisgraph(x) isgraph((unsigned char)x)
 
 #endif /* _SQUID_COMPAT_XIS_H */
+
@@ -107,3 +107,4 @@ xstrerr(int error)
 
     return xstrerror_buf;
 }
+
@@ -27,3 +27,4 @@
 extern const char * xstrerr(int error);
 
 #endif /* _SQUID_COMPAT_XSTRERROR_H */
+
@@ -79,3 +79,4 @@ xstrndup(const char *s, size_t n)
     p = xstrncpy((char *)xmalloc(sz), s, sz);
     return p;
 }
+
@@ -17,40 +17,40 @@
 extern "C" {
 #endif
 
-    /**
-     * xstrdup() - same as strdup(3).  Used for portability.
-     * Never returns NULL; fatal on error.
-     *
-     * Sets errno to EINVAL if a NULL pointer is passed.
-     *
-     * Define failure_notify to receive error message.
-     * otherwise perror() is used to display it.
-     */
-    char *xstrdup(const char *s);
+/**
+ * xstrdup() - same as strdup(3).  Used for portability.
+ * Never returns NULL; fatal on error.
+ *
+ * Sets errno to EINVAL if a NULL pointer is passed.
+ *
+ * Define failure_notify to receive error message.
+ * otherwise perror() is used to display it.
+ */
+char *xstrdup(const char *s);
 
 #ifdef strdup
 #undef strdup
 #endif
 #define strdup(X) xstrdup((X))
 
-    /*
-     *  xstrncpy() - similar to strncpy(3) but terminates string
-     *  always with '\0' if (n != 0 and dst != NULL),
-     *  and doesn't do padding
-     */
-    char *xstrncpy(char *dst, const char *src, size_t n);
+/*
+ *  xstrncpy() - similar to strncpy(3) but terminates string
+ *  always with '\0' if (n != 0 and dst != NULL),
+ *  and doesn't do padding
+ */
+char *xstrncpy(char *dst, const char *src, size_t n);
 
-    /**
-     * xstrndup() - same as strndup(3).  Used for portability.
-     * Never returns NULL; fatal on error.
-     *
-     * Sets errno to EINVAL if a NULL pointer or negative
-     * length is passed.
-     *
-     * Define failure_notify to receive error message.
-     * otherwise perror() is used to display it.
-     */
-    char *xstrndup(const char *s, size_t n);
+/**
+ * xstrndup() - same as strndup(3).  Used for portability.
+ * Never returns NULL; fatal on error.
+ *
+ * Sets errno to EINVAL if a NULL pointer or negative
+ * length is passed.
+ *
+ * Define failure_notify to receive error message.
+ * otherwise perror() is used to display it.
+ */
+char *xstrndup(const char *s, size_t n);
 
 #ifdef strndup
 #undef strndup
@@ -62,3 +62,4 @@ extern "C" {
 #endif
 
 #endif /* SQUID_COMPAT_XSTRING_H */
+
@@ -28,8 +28,8 @@
  * Update/Maintenance History:
  *
  *    12-Sep-2010 : Copied from iptables xtables.c
- * 			- xtables_strtoui renamed to xstrtoui
- * 			- xtables_strtoul renamed to xstrtoul
+ *          - xtables_strtoui renamed to xstrtoui
+ *          - xtables_strtoul renamed to xstrtoul
  *
  *  Original License and code follows.
  */
@@ -100,3 +100,4 @@ xstrtoui(const char *s, char **end, unsigned int *value,
 }
 
 #endif /* SQUID_XSTRTO_C_ */
+
@@ -40,3 +40,4 @@ bool xstrtoui(const char *s, char **end, unsigned int *value,
 
 #endif /* __cplusplus */
 #endif /* _SQUID_XSTRTO_H */
+
@@ -6,6 +6,7 @@
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
 
+
 section 00    Announcement Server
 section 00    Client Database
 section 00    Debug Routines
@@ -388,7 +388,7 @@ main(int argc, char **argv)
             fprintf(stderr, "ERROR: Your LDAP library does not have URI support\n");
             exit(1);
 #endif
-            /* Fall thru to -h */
+        /* Fall thru to -h */
         case 'h':
             if (ldapServer) {
                 int len = strlen(ldapServer) + 1 + strlen(value) + 1;
@@ -796,3 +796,4 @@ readSecret(const char *filename)
 
     return 0;
 }
+
@@ -30,7 +30,7 @@ static usersfile AllowUsers;
 static int init = 0;
 
 /* shared */
-char Allowuserpath[MAXPATHLEN];	/* MAXPATHLEN defined in param.h */
+char Allowuserpath[MAXPATHLEN]; /* MAXPATHLEN defined in param.h */
 
 int
 Read_allowusers(void)
@@ -56,3 +56,4 @@ Check_forallowchange(void)
 {
     Check_forfilechange(&AllowUsers);
 }
+
@@ -41,7 +41,7 @@
 #define MAXSERVERS 5
 #define NTHOSTLEN 65
 
-extern char Denyuserpath[MAXPATHLEN];	/* MAXPATHLEN defined in param.h */
+extern char Denyuserpath[MAXPATHLEN];   /* MAXPATHLEN defined in param.h */
 extern char Allowuserpath[MAXPATHLEN];
 
 typedef struct _ServerTuple {
@@ -50,8 +50,8 @@ typedef struct _ServerTuple {
     char domain[NTHOSTLEN];
 } ServerTuple;
 
-ServerTuple ServerArray[MAXSERVERS];	/* Array of servers to query */
-int Serversqueried = 0;		/* Number of servers queried */
+ServerTuple ServerArray[MAXSERVERS];    /* Array of servers to query */
+int Serversqueried = 0;     /* Number of servers queried */
 
 /* Declarations */
 
@@ -68,7 +68,7 @@ int
 OpenConfigFile(void)
 {
     FILE *ConfigFile;
-    char Confbuf[2049];		/* Line reading buffer */
+    char Confbuf[2049];     /* Line reading buffer */
 
     /* Initialise defaults */
 
@@ -244,7 +244,7 @@ QueryServerForUser(int x, char *username, char *password)
     result = Valid_User(username, password, ServerArray[x].pdc,
                         ServerArray[x].bdc, ServerArray[x].domain);
 
-    switch (result) {		/* Write any helpful syslog messages */
+    switch (result) {       /* Write any helpful syslog messages */
     case 0:
         break;
     case 1:
@@ -271,3 +271,4 @@ QueryServerForUser(int x, char *username, char *password)
  * 2 - Protocol error.
  * 3 - Logon error; Incorrect password or username given.
  */
+
@@ -31,7 +31,7 @@ static usersfile DenyUsers;
 static int init = 0;
 
 /* shared */
-char Denyuserpath[MAXPATHLEN];	/* MAXPATHLEN defined in param.h */
+char Denyuserpath[MAXPATHLEN];  /* MAXPATHLEN defined in param.h */
 
 int
 Read_denyusers(void)
@@ -111,8 +111,8 @@ Check_forchange(int signal)
 void
 Checktimer()
 {
-    static time_t Lasttime;	/* The last time the timer was checked */
-    static time_t Currenttime;	/* The current time */
+    static time_t Lasttime; /* The last time the timer was checked */
+    static time_t Currenttime;  /* The current time */
 
     Currenttime = time(NULL);
 
@@ -124,3 +124,4 @@ Checktimer()
         Lasttime = Currenttime;
     }
 }
+
@@ -128,7 +128,7 @@ main(int argc, char **argv)
             puts("ERR");
             continue;
         }
-        Checktimer();		/* Check if the user lists have changed */
+        Checktimer();       /* Check if the user lists have changed */
 
         rfc1738_unescape(username);
         rfc1738_unescape(password);
@@ -151,3 +151,4 @@ main(int argc, char **argv)
 
     return 0;
 }
+
@@ -21,3 +21,4 @@ extern int Check_ifuserallowed(char *ConnectingUser);
 extern void Check_forallowchange(void);
 
 #endif /* _SQUID_HELPERS_BASIC_AUTH_MSNT_MSNTAUTH_H */
+
@@ -31,7 +31,7 @@
 
 #include "usersfile.h"
 
-#define NAMELEN     50		/* Maximum username length */
+#define NAMELEN     50      /* Maximum username length */
 
 static int
 name_cmp(const void *a, const void *b)
@@ -177,7 +177,7 @@ Check_userlist(usersfile * uf, char *User)
 void
 Check_forfilechange(usersfile * uf)
 {
-    struct stat ChkBuf;		/* Stat data buffer */
+    struct stat ChkBuf;     /* Stat data buffer */
 
     /* Stat the allowed users file. If it cannot be accessed, return. */
 
@@ -188,7 +188,7 @@ Check_forfilechange(usersfile * uf)
         if (errno == ENOENT) {
             uf->LMT = 0;
             free_names(uf);
-        } else {		/* Report error when accessing file */
+        } else {        /* Report error when accessing file */
             syslog(LOG_ERR, "%s: %s", uf->path, strerror(errno));
         }
         return;
@@ -203,3 +203,4 @@ Check_forfilechange(usersfile * uf)
     syslog(LOG_INFO, "Check_forfilechange: Reloading user list '%s'.", uf->path);
     Read_usersfile(NULL, uf);
 }
+
@@ -17,3 +17,4 @@ typedef struct {
 int Read_usersfile(const char *path, usersfile * uf);
 int Check_userlist(usersfile * uf, char *User);
 void Check_forfilechange(usersfile * uf);
+
@@ -36,13 +36,13 @@ Valid_User(char *USERNAME, char *PASSWORD, char *SERVER, char *BACKUP, char *DOM
 
     SMB_Init();
     con = SMB_Connect_Server(NULL, SERVER, DOMAIN);
-    if (con == NULL) {		/* Error ... */
+    if (con == NULL) {      /* Error ... */
         con = SMB_Connect_Server(NULL, BACKUP, DOMAIN);
         if (con == NULL) {
             return (NTV_SERVER_ERROR);
         }
     }
-    if (SMB_Negotiate(con, supportedDialects) < 0) {	/* An error */
+    if (SMB_Negotiate(con, supportedDialects) < 0) {    /* An error */
         SMB_Discon(con, 0);
         return (NTV_PROTOCOL_ERROR);
     }
@@ -53,3 +53,4 @@ Valid_User(char *USERNAME, char *PASSWORD, char *SERVER, char *BACKUP, char *DOM
     SMB_Discon(con, 0);
     return (NTV_NO_ERROR);
 }
+
@@ -18,3 +18,4 @@
 int Valid_User(char *USERNAME, char *PASSWORD, char *SERVER, char *BACKUP, char *DOMAIN);
 
 #endif
+
@@ -127,7 +127,7 @@ main(int argc, char **argv)
     }
     while (fgets(buf, HELPER_INPUT_BUFFER, stdin) != NULL) {
         if ((p = strchr(buf, '\n')) != NULL)
-            *p = '\0';		/* strip \n */
+            *p = '\0';      /* strip \n */
         if (stat(argv[1], &sb) == 0) {
             if (sb.st_mtime != change_time) {
                 read_passwd_file(argv[1]);
@@ -187,3 +187,4 @@ main(int argc, char **argv)
     }
     exit(0);
 }
+
@@ -29,7 +29,7 @@
 
 #include <cstring>
 
-static unsigned char itoa64[] =	/* 0 ... 63 => ascii - 64 */
+static unsigned char itoa64[] = /* 0 ... 63 => ascii - 64 */
     "./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
 
 static void md5to64(char *s, unsigned long v, int n)
@@ -29,3 +29,4 @@ char *crypt_md5(const char *pw, const char *salt);
 char *md5sum(const char *s);
 
 #endif /* _CRYPT_MD5_H */
+
@@ -54,7 +54,7 @@ main(int argc, char **argv)
 
     while (fgets(buf, 256, stdin) != NULL) {
         if ((p = strchr(buf, '\n')) != NULL)
-            *p = '\0';		/* strip \n */
+            *p = '\0';      /* strip \n */
 
         if ((user = strtok(buf, " ")) == NULL) {
             printf("ERR\n");
@@ -90,3 +90,4 @@ main(int argc, char **argv)
     }
     exit(0);
 }
+
@@ -37,7 +37,7 @@
 
 #include "nis_support.h"
 
-#define NO_YPERR 0		/* There is no error */
+#define NO_YPERR 0      /* There is no error */
 
 char *
 get_nis_password(char *user, char *nisdomain, char *nismap)
@@ -69,9 +69,10 @@ get_nis_password(char *user, char *nisdomain, char *nismap)
     case YPERR_YPBIND:
         syslog(LOG_ERR, "Squid Authentication through ypbind failure: can't communicate with ypbind");
         return NULL;
-    case YPERR_KEY:		/* No such key in map */
+    case YPERR_KEY:     /* No such key in map */
         return NULL;
     default:
         return NULL;
     }
 }
+
@@ -1,9 +1,10 @@
-/*
- * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-extern char * get_nis_password(char *user, char *nisdomain, char *nismap);
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+extern char * get_nis_password(char *user, char *nisdomain, char *nismap);
+
@@ -58,17 +58,17 @@
  *
  *   Version 2.0, 2002-01-07
  *      One shot mode, command line options
- *	man page
+ *  man page
  *
  *   Version 1.3, 1999-12-10
- *   	Bugfix release 1.3 to work around Solaris 2.6
+ *      Bugfix release 1.3 to work around Solaris 2.6
  *      brokenness (not sending arguments to conversation
  *      functions)
  *
  *   Version 1.2, internal release
  *
  *   Version 1.1, 1999-05-11
- *	Initial version
+ *  Initial version
  */
 #include "squid.h"
 #include "helpers/defines.h"
@@ -97,7 +97,7 @@
 #endif
 
 #if _SQUID_SOLARIS_
-static char *password = NULL;	/* Workaround for Solaris 2.6 brokenness */
+static char *password = NULL;   /* Workaround for Solaris 2.6 brokenness */
 #endif
 
 extern "C" int password_conversation(int num_msg, PAM_CONV_FUNC_CONST_PARM struct pam_message **msg,
@@ -224,7 +224,7 @@ main(int argc, char *argv[])
         ++password_buf;
         rfc1738_unescape(user);
         rfc1738_unescape(password_buf);
-        conv.appdata_ptr = (char *) password_buf;	/* from buf above. not allocated */
+        conv.appdata_ptr = (char *) password_buf;   /* from buf above. not allocated */
 
         if (no_realm) {
             /* Remove DOMAIN\.. and ...@domain from the user name in case the user
@@ -310,3 +310,4 @@ main(int argc, char *argv[])
     }
     return 0;
 }
+
@@ -92,9 +92,9 @@
 #endif
 
 /* AYJ: helper input buffer may be a lot larger than this used to expect... */
-#define MAXPWNAM	254
-#define MAXPASS		254
-#define MAXLINE		254
+#define MAXPWNAM    254
+#define MAXPASS     254
+#define MAXLINE     254
 
 static void md5_calc(uint8_t out[16], void *in, size_t len);
 
@@ -440,7 +440,7 @@ authenticate(int socket_fd, const char *username, const char *passwd)
             }
             FD_ZERO(&readfds);
             FD_SET(socket_fd, &readfds);
-            if (select(socket_fd + 1, &readfds, NULL, NULL, &tv) == 0)	/* Select timeout */
+            if (select(socket_fd + 1, &readfds, NULL, NULL, &tv) == 0)  /* Select timeout */
                 break;
             salen = sizeof(saremote);
             len = recvfrom(socket_fd, recv_buffer, sizeof(i_recv_buffer),
@@ -617,3 +617,4 @@ main(int argc, char **argv)
     close(sockfd);
     exit(1);
 }
+
@@ -9,34 +9,34 @@
 // 2008-05-14: rename to radius-util.* to avoid name clashes with squid util.*
 /*
  *
- *	RADIUS
- *	Remote Authentication Dial In User Service
+ *  RADIUS
+ *  Remote Authentication Dial In User Service
  *
  *
- *	Livingston Enterprises, Inc.
- *	6920 Koll Center Parkway
- *	Pleasanton, CA   94566
+ *  Livingston Enterprises, Inc.
+ *  6920 Koll Center Parkway
+ *  Pleasanton, CA   94566
  *
- *	Copyright 1992 Livingston Enterprises, Inc.
- *	Copyright 1997 Cistron Internet Services B.V.
+ *  Copyright 1992 Livingston Enterprises, Inc.
+ *  Copyright 1997 Cistron Internet Services B.V.
  *
- *	Permission to use, copy, modify, and distribute this software for any
- *	purpose and without fee is hereby granted, provided that this
- *	copyright and permission notice appear on all copies and supporting
- *	documentation, the name of Livingston Enterprises, Inc. not be used
- *	in advertising or publicity pertaining to distribution of the
- *	program without specific prior permission, and notice be given
- *	in supporting documentation that copying and distribution is by
- *	permission of Livingston Enterprises, Inc.
+ *  Permission to use, copy, modify, and distribute this software for any
+ *  purpose and without fee is hereby granted, provided that this
+ *  copyright and permission notice appear on all copies and supporting
+ *  documentation, the name of Livingston Enterprises, Inc. not be used
+ *  in advertising or publicity pertaining to distribution of the
+ *  program without specific prior permission, and notice be given
+ *  in supporting documentation that copying and distribution is by
+ *  permission of Livingston Enterprises, Inc.
  *
- *	Livingston Enterprises, Inc. makes no representations about
- *	the suitability of this software for any purpose.  It is
- *	provided "as is" without express or implied warranty.
+ *  Livingston Enterprises, Inc. makes no representations about
+ *  the suitability of this software for any purpose.  It is
+ *  provided "as is" without express or implied warranty.
  *
  */
 
 /*
- * util.c	Miscellanous generic functions.
+ * util.c   Miscellanous generic functions.
  *
  */
 
@@ -65,12 +65,12 @@ char util_sccsid[] =
 #endif
 
 /*
- *	Check for valid IP address in standard dot notation.
+ *  Check for valid IP address in standard dot notation.
  */
 static int good_ipaddr(char *addr)
 {
-    int	dot_count;
-    int	digit_count;
+    int dot_count;
+    int digit_count;
 
     dot_count = 0;
     digit_count = 0;
@@ -96,17 +96,17 @@ static int good_ipaddr(char *addr)
 }
 
 /*
- *	Return an IP address in host long notation from
- *	one supplied in standard dot notation.
+ *  Return an IP address in host long notation from
+ *  one supplied in standard dot notation.
  */
 static uint32_t ipstr2long(char *ip_str)
 {
-    char	buf[6];
-    char	*ptr;
-    int	i;
-    int	count;
-    uint32_t	ipaddr;
-    int	cur_byte;
+    char    buf[6];
+    char    *ptr;
+    int i;
+    int count;
+    uint32_t    ipaddr;
+    int cur_byte;
 
     ipaddr = (uint32_t)0;
     for (i = 0; i < 4; ++i) {
@@ -137,12 +137,12 @@ static uint32_t ipstr2long(char *ip_str)
 }
 
 /*
- *	Return an IP address in host long notation from a host
- *	name or address in dot notation.
+ *  Return an IP address in host long notation from a host
+ *  name or address in dot notation.
  */
 uint32_t get_ipaddr(char *host)
 {
-    struct hostent	*hp;
+    struct hostent  *hp;
 
     if (good_ipaddr(host) == 0) {
         return(ipstr2long(host));
@@ -151,3 +151,4 @@ uint32_t get_ipaddr(char *host)
     }
     return(ntohl(*(uint32_t *)hp->h_addr));
 }
+
@@ -12,4 +12,5 @@
 #include "util.h"
 
 /* util.c */
-uint32_t		get_ipaddr (char *);
+uint32_t        get_ipaddr (char *);
+
@@ -8,195 +8,195 @@
 
 /*
  *
- *	RADIUS
- *	Remote Authentication Dial In User Service
+ *  RADIUS
+ *  Remote Authentication Dial In User Service
  *
  *
- *	Livingston Enterprises, Inc.
- *	6920 Koll Center Parkway
- *	Pleasanton, CA   94566
+ *  Livingston Enterprises, Inc.
+ *  6920 Koll Center Parkway
+ *  Pleasanton, CA   94566
  *
- *	Copyright 1992 Livingston Enterprises, Inc.
+ *  Copyright 1992 Livingston Enterprises, Inc.
  *
- *	Permission to use, copy, modify, and distribute this software for any
- *	purpose and without fee is hereby granted, provided that this
- *	copyright and permission notice appear on all copies and supporting
- *	documentation, the name of Livingston Enterprises, Inc. not be used
- *	in advertising or publicity pertaining to distribution of the
- *	program without specific prior permission, and notice be given
- *	in supporting documentation that copying and distribution is by
- *	permission of Livingston Enterprises, Inc.
+ *  Permission to use, copy, modify, and distribute this software for any
+ *  purpose and without fee is hereby granted, provided that this
+ *  copyright and permission notice appear on all copies and supporting
+ *  documentation, the name of Livingston Enterprises, Inc. not be used
+ *  in advertising or publicity pertaining to distribution of the
+ *  program without specific prior permission, and notice be given
+ *  in supporting documentation that copying and distribution is by
+ *  permission of Livingston Enterprises, Inc.
  *
- *	Livingston Enterprises, Inc. makes no representations about
- *	the suitability of this software for any purpose.  It is
- *	provided "as is" without express or implied warranty.
+ *  Livingston Enterprises, Inc. makes no representations about
+ *  the suitability of this software for any purpose.  It is
+ *  provided "as is" without express or implied warranty.
  *
  */
 
 /*
- *	@(#)radius.h	2.0  03-Aug-1996
+ *  @(#)radius.h    2.0  03-Aug-1996
  */
 
-#define AUTH_VECTOR_LEN		16
-#define AUTH_PASS_LEN		16
-#define AUTH_STRING_LEN		128	/* maximum of 254 */
+#define AUTH_VECTOR_LEN     16
+#define AUTH_PASS_LEN       16
+#define AUTH_STRING_LEN     128 /* maximum of 254 */
 
 typedef struct pw_auth_hdr {
-    u_char		code;
-    u_char		id;
-    uint16_t		length;
-    u_char		vector[AUTH_VECTOR_LEN];
-    u_char		data[2];
+    u_char      code;
+    u_char      id;
+    uint16_t        length;
+    u_char      vector[AUTH_VECTOR_LEN];
+    u_char      data[2];
 } AUTH_HDR;
 
-#define AUTH_HDR_LEN			20
-#define CHAP_VALUE_LENGTH		16
-
-#define PW_AUTH_UDP_PORT		1812
-#define PW_ACCT_UDP_PORT		1813
-
-#define VENDORPEC_USR			429
-
-#define PW_TYPE_STRING			0
-#define PW_TYPE_INTEGER			1
-#define PW_TYPE_IPADDR			2
-#define PW_TYPE_DATE			3
-
-#define	PW_AUTHENTICATION_REQUEST	1
-#define	PW_AUTHENTICATION_ACK		2
-#define	PW_AUTHENTICATION_REJECT	3
-#define	PW_ACCOUNTING_REQUEST		4
-#define	PW_ACCOUNTING_RESPONSE		5
-#define	PW_ACCOUNTING_STATUS		6
-#define PW_PASSWORD_REQUEST		7
-#define PW_PASSWORD_ACK			8
-#define PW_PASSWORD_REJECT		9
-#define	PW_ACCOUNTING_MESSAGE		10
-#define PW_ACCESS_CHALLENGE		11
-
-#define	PW_USER_NAME			1
-#define	PW_PASSWORD			2
-#define	PW_CHAP_PASSWORD		3
-#define	PW_NAS_IP_ADDRESS		4
-#define	PW_NAS_PORT_ID			5
-#define	PW_SERVICE_TYPE			6
-#define	PW_FRAMED_PROTOCOL		7
-#define	PW_FRAMED_IP_ADDRESS		8
-#define	PW_FRAMED_IP_NETMASK		9
-#define	PW_FRAMED_ROUTING		10
-#define	PW_FILTER_ID			11
-#define	PW_FRAMED_MTU			12
-#define	PW_FRAMED_COMPRESSION		13
-#define	PW_LOGIN_IP_HOST		14
-#define	PW_LOGIN_SERVICE		15
-#define	PW_LOGIN_TCP_PORT		16
-#define PW_OLD_PASSWORD			17
-#define PW_REPLY_MESSAGE		18
-#define PW_CALLBACK_NUMBER		19
-#define PW_CALLBACK_ID			20
-#define PW_EXPIRATION			21
-#define PW_FRAMED_ROUTE			22
-#define PW_FRAMED_IPXNET		23
-#define PW_STATE			24
-#define PW_CLASS			25
-#define PW_VENDOR_SPECIFIC		26
-#define PW_SESSION_TIMEOUT		27
-#define PW_IDLE_TIMEOUT			28
-#define PW_CALLED_STATION_ID		30
-#define PW_CALLING_STATION_ID		31
-#define PW_NAS_ID			32
-#define PW_PROXY_STATE			33
-
-#define PW_ACCT_STATUS_TYPE		40
-#define PW_ACCT_DELAY_TIME		41
-#define PW_ACCT_INPUT_OCTETS		42
-#define PW_ACCT_OUTPUT_OCTETS		43
-#define PW_ACCT_SESSION_ID		44
-#define PW_ACCT_AUTHENTIC		45
-#define PW_ACCT_SESSION_TIME		46
-#define PW_ACCT_INPUT_PACKETS		47
-#define PW_ACCT_OUTPUT_PACKETS		48
-
-#define PW_CHAP_CHALLENGE		60
-#define PW_NAS_PORT_TYPE		61
-#define PW_PORT_LIMIT			62
-#define PW_CONNECT_INFO			77
-
-#define PW_HUNTGROUP_NAME		221
-#define PW_AUTHTYPE			1000
-#define PW_PREFIX			1003
-#define PW_SUFFIX			1004
-#define PW_GROUP			1005
-#define PW_CRYPT_PASSWORD		1006
-#define PW_CONNECT_RATE			1007
-#define PW_USER_CATEGORY		1029
-#define PW_GROUP_NAME			1030
-#define PW_SIMULTANEOUS_USE		1034
-#define PW_STRIP_USERNAME		1035
-#define PW_FALL_THROUGH			1036
-#define PW_ADD_PORT_TO_IP_ADDRESS	1037
-#define PW_EXEC_PROGRAM			1038
-#define PW_EXEC_PROGRAM_WAIT		1039
-#define PW_HINT				1040
-#define PAM_AUTH_ATTR			1041
-#define PW_LOGIN_TIME			1042
+#define AUTH_HDR_LEN            20
+#define CHAP_VALUE_LENGTH       16
+
+#define PW_AUTH_UDP_PORT        1812
+#define PW_ACCT_UDP_PORT        1813
+
+#define VENDORPEC_USR           429
+
+#define PW_TYPE_STRING          0
+#define PW_TYPE_INTEGER         1
+#define PW_TYPE_IPADDR          2
+#define PW_TYPE_DATE            3
+
+#define PW_AUTHENTICATION_REQUEST   1
+#define PW_AUTHENTICATION_ACK       2
+#define PW_AUTHENTICATION_REJECT    3
+#define PW_ACCOUNTING_REQUEST       4
+#define PW_ACCOUNTING_RESPONSE      5
+#define PW_ACCOUNTING_STATUS        6
+#define PW_PASSWORD_REQUEST     7
+#define PW_PASSWORD_ACK         8
+#define PW_PASSWORD_REJECT      9
+#define PW_ACCOUNTING_MESSAGE       10
+#define PW_ACCESS_CHALLENGE     11
+
+#define PW_USER_NAME            1
+#define PW_PASSWORD         2
+#define PW_CHAP_PASSWORD        3
+#define PW_NAS_IP_ADDRESS       4
+#define PW_NAS_PORT_ID          5
+#define PW_SERVICE_TYPE         6
+#define PW_FRAMED_PROTOCOL      7
+#define PW_FRAMED_IP_ADDRESS        8
+#define PW_FRAMED_IP_NETMASK        9
+#define PW_FRAMED_ROUTING       10
+#define PW_FILTER_ID            11
+#define PW_FRAMED_MTU           12
+#define PW_FRAMED_COMPRESSION       13
+#define PW_LOGIN_IP_HOST        14
+#define PW_LOGIN_SERVICE        15
+#define PW_LOGIN_TCP_PORT       16
+#define PW_OLD_PASSWORD         17
+#define PW_REPLY_MESSAGE        18
+#define PW_CALLBACK_NUMBER      19
+#define PW_CALLBACK_ID          20
+#define PW_EXPIRATION           21
+#define PW_FRAMED_ROUTE         22
+#define PW_FRAMED_IPXNET        23
+#define PW_STATE            24
+#define PW_CLASS            25
+#define PW_VENDOR_SPECIFIC      26
+#define PW_SESSION_TIMEOUT      27
+#define PW_IDLE_TIMEOUT         28
+#define PW_CALLED_STATION_ID        30
+#define PW_CALLING_STATION_ID       31
+#define PW_NAS_ID           32
+#define PW_PROXY_STATE          33
+
+#define PW_ACCT_STATUS_TYPE     40
+#define PW_ACCT_DELAY_TIME      41
+#define PW_ACCT_INPUT_OCTETS        42
+#define PW_ACCT_OUTPUT_OCTETS       43
+#define PW_ACCT_SESSION_ID      44
+#define PW_ACCT_AUTHENTIC       45
+#define PW_ACCT_SESSION_TIME        46
+#define PW_ACCT_INPUT_PACKETS       47
+#define PW_ACCT_OUTPUT_PACKETS      48
+
+#define PW_CHAP_CHALLENGE       60
+#define PW_NAS_PORT_TYPE        61
+#define PW_PORT_LIMIT           62
+#define PW_CONNECT_INFO         77
+
+#define PW_HUNTGROUP_NAME       221
+#define PW_AUTHTYPE         1000
+#define PW_PREFIX           1003
+#define PW_SUFFIX           1004
+#define PW_GROUP            1005
+#define PW_CRYPT_PASSWORD       1006
+#define PW_CONNECT_RATE         1007
+#define PW_USER_CATEGORY        1029
+#define PW_GROUP_NAME           1030
+#define PW_SIMULTANEOUS_USE     1034
+#define PW_STRIP_USERNAME       1035
+#define PW_FALL_THROUGH         1036
+#define PW_ADD_PORT_TO_IP_ADDRESS   1037
+#define PW_EXEC_PROGRAM         1038
+#define PW_EXEC_PROGRAM_WAIT        1039
+#define PW_HINT             1040
+#define PAM_AUTH_ATTR           1041
+#define PW_LOGIN_TIME           1042
 
 /*
- *	INTEGER TRANSLATIONS
+ *  INTEGER TRANSLATIONS
  */
 
-/*	USER TYPES	*/
+/*  USER TYPES  */
 
-#define	PW_LOGIN_USER			1
-#define	PW_FRAMED_USER			2
-#define	PW_DIALBACK_LOGIN_USER		3
-#define	PW_DIALBACK_FRAMED_USER		4
+#define PW_LOGIN_USER           1
+#define PW_FRAMED_USER          2
+#define PW_DIALBACK_LOGIN_USER      3
+#define PW_DIALBACK_FRAMED_USER     4
 
-/*	FRAMED PROTOCOLS	*/
+/*  FRAMED PROTOCOLS    */
 
-#define	PW_PPP				1
-#define	PW_SLIP				2
+#define PW_PPP              1
+#define PW_SLIP             2
 
-/*	FRAMED ROUTING VALUES	*/
+/*  FRAMED ROUTING VALUES   */
 
-#define	PW_NONE				0
-#define	PW_BROADCAST			1
-#define	PW_LISTEN			2
-#define	PW_BROADCAST_LISTEN		3
+#define PW_NONE             0
+#define PW_BROADCAST            1
+#define PW_LISTEN           2
+#define PW_BROADCAST_LISTEN     3
 
-/*	FRAMED COMPRESSION TYPES	*/
+/*  FRAMED COMPRESSION TYPES    */
 
-#define	PW_VAN_JACOBSEN_TCP_IP		1
+#define PW_VAN_JACOBSEN_TCP_IP      1
 
-/*	LOGIN SERVICES	*/
+/*  LOGIN SERVICES  */
 
-#define	PW_TELNET			0
-#define	PW_RLOGIN			1
-#define	PW_TCP_CLEAR			2
-#define	PW_PORTMASTER			3
+#define PW_TELNET           0
+#define PW_RLOGIN           1
+#define PW_TCP_CLEAR            2
+#define PW_PORTMASTER           3
 
-/*	AUTHENTICATION LEVEL	*/
+/*  AUTHENTICATION LEVEL    */
 
-#define PW_AUTHTYPE_LOCAL		0
-#define PW_AUTHTYPE_SYSTEM		1
-#define PW_AUTHTYPE_SECURID		2
-#define PW_AUTHTYPE_CRYPT		3
-#define PW_AUTHTYPE_REJECT		4
-#define PW_AUTHTYPE_PAM			253
-#define PW_AUTHTYPE_ACCEPT		254
+#define PW_AUTHTYPE_LOCAL       0
+#define PW_AUTHTYPE_SYSTEM      1
+#define PW_AUTHTYPE_SECURID     2
+#define PW_AUTHTYPE_CRYPT       3
+#define PW_AUTHTYPE_REJECT      4
+#define PW_AUTHTYPE_PAM         253
+#define PW_AUTHTYPE_ACCEPT      254
 
-/*	PORT TYPES		*/
-#define PW_NAS_PORT_ASYNC		0
-#define PW_NAS_PORT_SYNC		1
-#define PW_NAS_PORT_ISDN		2
-#define PW_NAS_PORT_ISDN_V120		3
-#define PW_NAS_PORT_ISDN_V110		4
+/*  PORT TYPES      */
+#define PW_NAS_PORT_ASYNC       0
+#define PW_NAS_PORT_SYNC        1
+#define PW_NAS_PORT_ISDN        2
+#define PW_NAS_PORT_ISDN_V120       3
+#define PW_NAS_PORT_ISDN_V110       4
 
-/*	STATUS TYPES	*/
+/*  STATUS TYPES    */
 
-#define PW_STATUS_START			1
-#define PW_STATUS_STOP			2
-#define PW_STATUS_ALIVE			3
-#define PW_STATUS_ACCOUNTING_ON		7
-#define PW_STATUS_ACCOUNTING_OFF	8
+#define PW_STATUS_START         1
+#define PW_STATUS_STOP          2
+#define PW_STATUS_ALIVE         3
+#define PW_STATUS_ACCOUNTING_ON     7
+#define PW_STATUS_ACCOUNTING_OFF    8
 
@@ -46,7 +46,7 @@
 #include <sasl.h>
 #endif
 
-#define APP_NAME_SASL	"basic_sasl_auth"
+#define APP_NAME_SASL   "basic_sasl_auth"
 
 int
 main(int argc, char *argv[])
@@ -128,3 +128,4 @@ main(int argc, char *argv[])
     sasl_done();
     return 0;
 }
+
@@ -31,18 +31,18 @@
 
 #include <cstring>
 
-#define NMB_UNICAST		1
-#define NMB_BROADCAST	2
+#define NMB_UNICAST     1
+#define NMB_BROADCAST   2
 
 struct SMBDOMAIN {
-    const char *name;		/* domain name */
-    const char *sname;		/* match this with user input */
-    const char *passthrough;	/* pass-through authentication */
-    const char *nmbaddr;	/* name service address */
-    int nmbcast;		/* broadcast or unicast */
-    char *authshare;		/* share name of auth file */
-    const char *authfile;	/* pathname of auth file */
-    struct SMBDOMAIN *next;	/* linked list */
+    const char *name;       /* domain name */
+    const char *sname;      /* match this with user input */
+    const char *passthrough;    /* pass-through authentication */
+    const char *nmbaddr;    /* name service address */
+    int nmbcast;        /* broadcast or unicast */
+    char *authshare;        /* share name of auth file */
+    const char *authfile;   /* pathname of auth file */
+    struct SMBDOMAIN *next; /* linked list */
 };
 
 struct SMBDOMAIN *firstdom = NULL;
@@ -236,6 +236,7 @@ main(int argc, char *argv[])
             SEND_OK("");
         else
             SEND_ERR("");
-    }				/* while (1) */
+    }               /* while (1) */
     return 0;
 }
+
@@ -100,7 +100,7 @@ process_options(int argc, char *argv[])
             exit(0);
         case '?':
             opt = optopt;
-            /* fall thru to default */
+        /* fall thru to default */
         default:
             fprintf(stderr, "FATAL: Unknown option: -%c\n", opt);
             usage(argv[0]);
@@ -149,13 +149,13 @@ main(int argc, char **argv)
         }
 
         if ((p = strchr(wstr, '\n')) != NULL)
-            *p = '\0';		/* strip \n */
+            *p = '\0';      /* strip \n */
         if ((p = strchr(wstr, '\r')) != NULL)
-            *p = '\0';		/* strip \r */
+            *p = '\0';      /* strip \r */
         /* Clear any current settings */
         username[0] = '\0';
         password[0] = '\0';
-        sscanf(wstr, "%s %s", username, password);	/* Extract parameters */
+        sscanf(wstr, "%s %s", username, password);  /* Extract parameters */
 
         debug("Got %s from Squid\n", wstr);
 
@@ -179,3 +179,4 @@ main(int argc, char **argv)
     }
     return 0;
 }
+
@@ -61,8 +61,8 @@ int
 Valid_Group(char *UserName, char *Group)
 {
     int result = FALSE;
-    WCHAR wszUserName[256];	// Unicode user name
-    WCHAR wszGroup[256];	// Unicode Group
+    WCHAR wszUserName[256]; // Unicode user name
+    WCHAR wszGroup[256];    // Unicode Group
 
     LPLOCALGROUP_USERS_INFO_0 pBuf = NULL;
     LPLOCALGROUP_USERS_INFO_0 pTmpBuf;
@@ -186,3 +186,4 @@ Valid_User(char *UserName, char *Password, char *Group)
     }
     return result;
 }
+
@@ -68,7 +68,7 @@ extern char Default_NTDomain[DNLEN+1];
 extern const char * errormsg;
 
 /* Debugging stuff */
-#if defined(__GNUC__)			/* this is really a gcc-ism */
+#if defined(__GNUC__)           /* this is really a gcc-ism */
 #include <unistd.h>
 static char *__foo;
 #define debug(X...) if (debug_enabled) { \
@@ -94,3 +94,4 @@ debug(char *format,...)
 int Valid_User(char *,char *, char *);
 
 #endif
+
@@ -105,7 +105,7 @@ main(int argc, char *argv[])
         char *p;
 
         if ((p = strchr(buf, '\n')) != NULL) {
-            *p = '\0';		/* strip \n */
+            *p = '\0';      /* strip \n */
             buflen = p - buf;   /* length is known already */
         } else
             buflen = strlen(buf);   /* keep this so we only scan the buffer for \0 once per loop */
@@ -118,3 +118,4 @@ main(int argc, char *argv[])
     debug("%s build " __DATE__ ", " __TIME__ " shutting down...\n", program_name);
     exit(0);
 }
+
@@ -57,12 +57,12 @@ passwd_auth(char *user, char *passwd)
     struct passwd *pwd;
     pwd = getpwnam(user);
     if (pwd == NULL) {
-        return 0;		/* User does not exist */
+        return 0;       /* User does not exist */
     } else {
         if (strcmp(pwd->pw_passwd, (char *) crypt(passwd, pwd->pw_passwd))) {
-            return 2;		/* Wrong password */
+            return 2;       /* Wrong password */
         } else {
-            return 1;		/* Authentication Sucessful */
+            return 1;       /* Authentication Sucessful */
         }
     }
 }
@@ -74,12 +74,12 @@ shadow_auth(char *user, char *passwd)
     struct spwd *pwd;
     pwd = getspnam(user);
     if (pwd == NULL) {
-        return passwd_auth(user, passwd);	/* Fall back to passwd_auth */
+        return passwd_auth(user, passwd);   /* Fall back to passwd_auth */
     } else {
         if (strcmp(pwd->sp_pwdp, crypt(passwd, pwd->sp_pwdp))) {
-            return 2;		/* Wrong password */
+            return 2;       /* Wrong password */
         } else {
-            return 1;		/* Authentication Sucessful */
+            return 1;       /* Authentication Sucessful */
         }
     }
 }
@@ -96,7 +96,7 @@ main(int argc, char **argv)
     while (fgets(buf, HELPER_INPUT_BUFFER, stdin) != NULL) {
 
         if ((p = strchr(buf, '\n')) != NULL)
-            *p = '\0';		/* strip \n */
+            *p = '\0';      /* strip \n */
 
         if ((user = strtok(buf, " ")) == NULL) {
             SEND_ERR("No Username");
@@ -125,3 +125,4 @@ main(int argc, char **argv)
     }
     return 0;
 }
+
@@ -43,18 +43,19 @@
  * useful and shared between helpers.
  */
 
-#define HELPER_INPUT_BUFFER	8196
+#define HELPER_INPUT_BUFFER 8196
 
 /* send OK result to Squid with a string parameter. */
-#define SEND_OK(x)	fprintf(stdout, "OK %s\n",x)
+#define SEND_OK(x)  fprintf(stdout, "OK %s\n",x)
 
 /* send ERR result to Squid with a string parameter. */
-#define SEND_ERR(x)	fprintf(stdout, "ERR %s\n",x)
+#define SEND_ERR(x) fprintf(stdout, "ERR %s\n",x)
 
 /* send ERR result to Squid with a string parameter. */
-#define SEND_BH(x)	fprintf(stdout, "BH %s\n",x)
+#define SEND_BH(x)  fprintf(stdout, "BH %s\n",x)
 
 /* send TT result to Squid with a string parameter. */
-#define SEND_TT(x)	fprintf(stdout, "TT %s\n",x)
+#define SEND_TT(x)  fprintf(stdout, "TT %s\n",x)
 
 #endif /* __SQUID_HELPERS_DEFINES_H */
+
@@ -52,3 +52,4 @@ typedef void HandleArguments(int, char **);
 typedef void HHA1Creator(RequestData *);
 
 #endif /* SQUID_DIGEST_COMMON_H_ */
+
@@ -55,7 +55,7 @@ ParseBuffer(char *buf, RequestData * requestData)
     char *p;
     requestData->parsed = 0;
     if ((p = strchr(buf, '\n')) != NULL)
-        *p = '\0';		/* strip \n */
+        *p = '\0';      /* strip \n */
 
     p = NULL;
     requestData->channelId = strtoll(buf, &p, 10);
@@ -120,3 +120,4 @@ main(int argc, char **argv)
         DoOneRequest(buf);
     exit(0);
 }
+
@@ -430,7 +430,7 @@ LDAPArguments(int argc, char **argv)
             fprintf(stderr, "ERROR: Your LDAP library does not have URI support\n");
             return 1;
 #endif
-            /* Fall thru to -h */
+        /* Fall thru to -h */
         case 'h':
             if (ldapServer) {
                 int len = strlen(ldapServer) + 1 + strlen(value) + 1;
@@ -660,3 +660,4 @@ LDAPHHA1(RequestData * requestData)
     }
 
 }
+
@@ -14,3 +14,4 @@
 
 extern int LDAPArguments(int argc, char **argv);
 extern void LDAPHHA1(RequestData * requestData);
+
@@ -55,3 +55,4 @@ typedef void HandleArguments(int, char **);
 typedef void HHA1Creator(RequestData *);
 
 #endif /* SQUID_DIGEST_COMMON_H_ */
+
@@ -54,7 +54,7 @@ ParseBuffer(char *buf, RequestData * requestData)
     char *p;
     requestData->parsed = 0;
     if ((p = strchr(buf, '\n')) != NULL)
-        *p = '\0';		/* strip \n */
+        *p = '\0';      /* strip \n */
 
     p = NULL;
     requestData->channelId = strtoll(buf, &p, 10);
@@ -119,3 +119,4 @@ main(int argc, char **argv)
         DoOneRequest(buf);
     exit(0);
 }
+
@@ -13,7 +13,7 @@
  *
  * Original copyright & license follows:
  *
- * Copyright (C) Vince Brimhall			2004-2005
+ * Copyright (C) Vince Brimhall         2004-2005
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -59,16 +59,16 @@
 
 #include "edir_ldapext.h"
 
-#define NMASLDAP_GET_LOGIN_CONFIG_REQUEST	"2.16.840.1.113719.1.39.42.100.3"
-#define NMASLDAP_GET_LOGIN_CONFIG_RESPONSE	"2.16.840.1.113719.1.39.42.100.4"
-#define NMASLDAP_SET_PASSWORD_REQUEST		"2.16.840.1.113719.1.39.42.100.11"
-#define NMASLDAP_SET_PASSWORD_RESPONSE		"2.16.840.1.113719.1.39.42.100.12"
-#define NMASLDAP_GET_PASSWORD_REQUEST		"2.16.840.1.113719.1.39.42.100.13"
-#define NMASLDAP_GET_PASSWORD_RESPONSE		"2.16.840.1.113719.1.39.42.100.14"
+#define NMASLDAP_GET_LOGIN_CONFIG_REQUEST   "2.16.840.1.113719.1.39.42.100.3"
+#define NMASLDAP_GET_LOGIN_CONFIG_RESPONSE  "2.16.840.1.113719.1.39.42.100.4"
+#define NMASLDAP_SET_PASSWORD_REQUEST       "2.16.840.1.113719.1.39.42.100.11"
+#define NMASLDAP_SET_PASSWORD_RESPONSE      "2.16.840.1.113719.1.39.42.100.12"
+#define NMASLDAP_GET_PASSWORD_REQUEST       "2.16.840.1.113719.1.39.42.100.13"
+#define NMASLDAP_GET_PASSWORD_RESPONSE      "2.16.840.1.113719.1.39.42.100.14"
 
-#define NMAS_LDAP_EXT_VERSION				1
+#define NMAS_LDAP_EXT_VERSION               1
 
-#define SMB_MALLOC_ARRAY(type, nelem)		calloc(sizeof(type), nelem)
+#define SMB_MALLOC_ARRAY(type, nelem)       calloc(sizeof(type), nelem)
 #define DEBUG(level, args)
 
 /**********************************************************************
@@ -161,7 +161,7 @@ static int berEncodeLoginData(
     unsigned int i;
     unsigned int elemCnt = methodIDLen / sizeof(unsigned int);
 
-    char	*utf8ObjPtr=NULL;
+    char    *utf8ObjPtr=NULL;
     int     utf8ObjSize = 0;
 
     char    *utf8TagPtr = NULL;
@@ -276,7 +276,7 @@ static int berDecodeLoginData(
 **********************************************************************/
 
 static int getLoginConfig(
-    LDAP	 *ld,
+    LDAP     *ld,
     char     *objectDN,
     unsigned int  methodIDLen,
     unsigned int *methodID,
@@ -346,9 +346,9 @@ static int getLoginConfig(
 **********************************************************************/
 
 static int nmasldap_get_simple_pwd(
-    LDAP	 *ld,
+    LDAP     *ld,
     char     *objectDN,
-    size_t	 pwdLen,
+    size_t   pwdLen,
     char     *pwd )
 {
     int err = 0;
@@ -404,9 +404,9 @@ static int nmasldap_get_simple_pwd(
 **********************************************************************/
 
 static int nmasldap_get_password(
-    LDAP	 *ld,
+    LDAP     *ld,
     char     *objectDN,
-    size_t   *pwdSize,	/* in bytes */
+    size_t   *pwdSize,  /* in bytes */
     unsigned char     *pwd )
 {
     int err = 0;
@@ -1,9 +1,10 @@
-/*
- * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-int nds_get_password(LDAP *ld, char *object_dn, size_t * pwd_len, char *pwd);
+/*
+ * Copyright (C) 1996-2014 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+int nds_get_password(LDAP *ld, char *object_dn, size_t * pwd_len, char *pwd);
+
@@ -457,7 +457,7 @@ LDAPArguments(int argc, char **argv)
             fprintf(stderr, "ERROR: Your LDAP library does not have URI support\n");
             return 1;
 #endif
-            /* Fall thru to -h */
+        /* Fall thru to -h */
         case 'h':
             if (ldapServer) {
                 int len = strlen(ldapServer) + 1 + strlen(value) + 1;
@@ -691,3 +691,4 @@ LDAPHHA1(RequestData * requestData)
     }
 
 }
+
@@ -14,3 +14,4 @@
 #include "digest_common.h"
 extern int LDAPArguments(int argc, char **argv);
 extern void LDAPHHA1(RequestData * requestData);
+
@@ -47,3 +47,4 @@ typedef void HandleArguments(int, char **);
 typedef void HHA1Creator(RequestData *);
 
 #endif /* SQUID_DIGEST_COMMON_H_ */
+
@@ -56,7 +56,7 @@ ParseBuffer(char *buf, RequestData * requestData)
     char *p;
     requestData->parsed = 0;
     if ((p = strchr(buf, '\n')) != NULL)
-        *p = '\0';		/* strip \n */
+        *p = '\0';      /* strip \n */
 
     p = NULL;
     requestData->channelId = strtoll(buf, &p, 10);
@@ -118,3 +118,4 @@ main(int argc, char **argv)
         DoOneRequest(buf);
     return 0;
 }
+
@@ -195,3 +195,4 @@ TextHHA1(RequestData * requestData)
         DigestCalcHA1("md5", requestData->user, requestData->realm, u->passwd, NULL, NULL, HA1, requestData->HHA1);
     }
 }
+
@@ -10,3 +10,4 @@
 
 extern void TextArguments(int argc, char **argv);
 extern void TextHHA1(RequestData * requestData);
+
@@ -385,7 +385,7 @@ wccmparray(const wchar_t * str, const wchar_t ** array)
 static int
 wcstrcmparray(const wchar_t * str, const char **array)
 {
-    WCHAR wszGroup[GNLEN + 1];	// Unicode Group
+    WCHAR wszGroup[GNLEN + 1];  // Unicode Group
 
     while (*array) {
         MultiByteToWideChar(CP_ACP, 0, *array,
@@ -525,7 +525,7 @@ Valid_Local_Groups(char *UserName, const char **Groups)
 {
     int result = 0;
     char *Domain_Separator;
-    WCHAR wszUserName[UNLEN + 1];	/* Unicode user name */
+    WCHAR wszUserName[UNLEN + 1];   /* Unicode user name */
 
     LPLOCALGROUP_USERS_INFO_0 pBuf;
     LPLOCALGROUP_USERS_INFO_0 pTmpBuf;
@@ -602,7 +602,7 @@ int
 Valid_Global_Groups(char *UserName, const char **Groups)
 {
     int result = 0;
-    WCHAR wszUser[DNLEN + UNLEN + 2];	/* Unicode user name */
+    WCHAR wszUser[DNLEN + UNLEN + 2];   /* Unicode user name */
     char NTDomain[DNLEN + UNLEN + 2];
 
     char *domain_qualify = NULL;
@@ -756,12 +756,12 @@ process_options(int argc, char *argv[])
             exit(0);
         case '?':
             opt = optopt;
-            /* fall thru to default */
+        /* fall thru to default */
         default:
             fprintf(stderr, "%s: FATAL: Unknown option: -%c. Exiting\n", program_name, opt);
             usage(argv[0]);
             exit(1);
-            break;		/* not reached */
+            break;      /* not reached */
         }
     }
     return;
@@ -777,7 +777,7 @@ main(int argc, char *argv[])
     const char *groups[512];
     int n;
 
-    if (argc > 0) {		/* should always be true */
+    if (argc > 0) {     /* should always be true */
         program_name = strrchr(argv[0], '/');
         if (program_name == NULL)
             program_name = argv[0];
@@ -824,9 +824,9 @@ main(int argc, char *argv[])
             continue;
         }
         if ((p = strchr(buf, '\n')) != NULL)
-            *p = '\0';		/* strip \n */
+            *p = '\0';      /* strip \n */
         if ((p = strchr(buf, '\r')) != NULL)
-            *p = '\0';		/* strip \r */
+            *p = '\0';      /* strip \r */
 
         debug("Got '%s' from Squid (length: %d).\n", buf, strlen(buf));
 
@@ -857,3 +857,4 @@ main(int argc, char *argv[])
     }
     return 0;
 }
+
@@ -257,7 +257,7 @@ main(int argc, char **argv)
             fprintf(stderr, "FATAL: Your LDAP library does not have URI support\n");
             exit(1);
 #endif
-            /* Fall thru to -h */
+        /* Fall thru to -h */
         case 'h':
             if (ldapServer) {
                 int len = strlen(ldapServer) + 1 + strlen(value) + 1;
@@ -835,3 +835,4 @@ readSecret(const char *filename)
 
     return 0;
 }
+
@@ -219,7 +219,7 @@ GetDomainName(void)
 static int
 wcstrcmparray(const wchar_t * str, const char **array)
 {
-    WCHAR wszGroup[GNLEN + 1];	// Unicode Group
+    WCHAR wszGroup[GNLEN + 1];  // Unicode Group
 
     while (*array) {
         MultiByteToWideChar(CP_ACP, 0, *array,
@@ -238,7 +238,7 @@ Valid_Local_Groups(char *UserName, const char **Groups)
 {
     int result = 0;
     char *Domain_Separator;
-    WCHAR wszUserName[UNLEN + 1];	// Unicode user name
+    WCHAR wszUserName[UNLEN + 1];   // Unicode user name
 
     LPLOCALGROUP_USERS_INFO_0 pBuf = NULL;
     LPLOCALGROUP_USERS_INFO_0 pTmpBuf;
@@ -312,11 +312,11 @@ int
 Valid_Global_Groups(char *UserName, const char **Groups)
 {
     int result = 0;
-    WCHAR wszUserName[UNLEN + 1];	// Unicode user name
+    WCHAR wszUserName[UNLEN + 1];   // Unicode user name
 
-    WCHAR wszLocalDomain[DNLEN + 1];	// Unicode Local Domain
+    WCHAR wszLocalDomain[DNLEN + 1];    // Unicode Local Domain
 
-    WCHAR wszUserDomain[DNLEN + 1];	// Unicode User Domain
+    WCHAR wszUserDomain[DNLEN + 1]; // Unicode User Domain
 
     char NTDomain[DNLEN + UNLEN + 2];
     char *domain_qualify;
@@ -495,12 +495,12 @@ process_options(int argc, char *argv[])
             exit(0);
         case '?':
             opt = optopt;
-            /* fall thru to default */
+        /* fall thru to default */
         default:
             fprintf(stderr, "%s: FATAL: Unknown option: -%c. Exiting\n", program_name, opt);
             usage(argv[0]);
             exit(1);
-            break;		/* not reached */
+            break;      /* not reached */
         }
     }
     return;
@@ -516,7 +516,7 @@ main(int argc, char *argv[])
     const char *groups[512];
     int n;
 
-    if (argc > 0) {		/* should always be true */
+    if (argc > 0) {     /* should always be true */
         program_name = strrchr(argv[0], '/');
         if (program_name == NULL)
             program_name = argv[0];
@@ -566,9 +566,9 @@ main(int argc, char *argv[])
             continue;
         }
         if ((p = strchr(buf, '\n')) != NULL)
-            *p = '\0';		/* strip \n */
+            *p = '\0';      /* strip \n */
         if ((p = strchr(buf, '\r')) != NULL)
-            *p = '\0';		/* strip \r */
+            *p = '\0';      /* strip \r */
 
         debug("Got '%s' from Squid (length: %d).\n", buf, strlen(buf));
 
@@ -597,3 +597,4 @@ main(int argc, char *argv[])
     }
     return 0;
 }
+
@@ -40,8 +40,8 @@
 #include "rfc1738.h"
 #include "util.h"
 
-#define EDUI_PROGRAM_NAME		"ext_edirectory_userip_acl"
-#define EDUI_PROGRAM_VERSION		"2.1"
+#define EDUI_PROGRAM_NAME       "ext_edirectory_userip_acl"
+#define EDUI_PROGRAM_VERSION        "2.1"
 
 /* System includes */
 #ifndef _GNU_SOURCE
@@ -69,9 +69,9 @@
 #endif
 
 #ifdef HELPER_INPUT_BUFFER
-#define EDUI_MAXLEN		HELPER_INPUT_BUFFER
+#define EDUI_MAXLEN     HELPER_INPUT_BUFFER
 #else
-#define EDUI_MAXLEN		4096		/* Modified to improve performance, unless HELPER_INPUT_BUFFER exists */
+#define EDUI_MAXLEN     4096        /* Modified to improve performance, unless HELPER_INPUT_BUFFER exists */
 #endif
 
 /* ldap compile options */
@@ -90,14 +90,14 @@
 #endif
 
 /* conf_t - status flags */
-#define EDUI_MODE_INIT		0x01
-#define EDUI_MODE_DEBUG		0x02				/* Replace with Squid's debug system */
-#define EDUI_MODE_TLS		0x04
-#define EDUI_MODE_IPV4		0x08
-#define EDUI_MODE_IPV6		0x10
-#define EDUI_MODE_GROUP		0x20				/* Group is REQUIRED */
-#define EDUI_MODE_PERSIST	0x40				/* Persistent LDAP connections */
-#define EDUI_MODE_KILL		0x80
+#define EDUI_MODE_INIT      0x01
+#define EDUI_MODE_DEBUG     0x02                /* Replace with Squid's debug system */
+#define EDUI_MODE_TLS       0x04
+#define EDUI_MODE_IPV4      0x08
+#define EDUI_MODE_IPV6      0x10
+#define EDUI_MODE_GROUP     0x20                /* Group is REQUIRED */
+#define EDUI_MODE_PERSIST   0x40                /* Persistent LDAP connections */
+#define EDUI_MODE_KILL      0x80
 
 /* conf_t - Program configuration struct typedef */
 typedef struct {
@@ -107,7 +107,7 @@ typedef struct {
     char attrib[EDUI_MAXLEN];
     char dn[EDUI_MAXLEN];
     char passwd[EDUI_MAXLEN];
-    char search_filter[EDUI_MAXLEN];				/* Base search_filter that gets copied to edui_ldap_t */
+    char search_filter[EDUI_MAXLEN];                /* Base search_filter that gets copied to edui_ldap_t */
     int ver;
     int scope;
     int port;
@@ -157,15 +157,15 @@ typedef struct {
     char host[EDUI_MAXLEN];
     char dn[EDUI_MAXLEN];
     char passwd[EDUI_MAXLEN];
-    char search_filter[EDUI_MAXLEN];                 	/* search_group gets appended here by GroupLDAP */
-    char search_ip[EDUI_MAXLEN];             	        /* Could be IPv4 or IPv6, set by ConvertIP */
+    char search_filter[EDUI_MAXLEN];                    /* search_group gets appended here by GroupLDAP */
+    char search_ip[EDUI_MAXLEN];                        /* Could be IPv4 or IPv6, set by ConvertIP */
     char userid[EDUI_MAXLEN];                           /* Resulting userid */
     unsigned int status;
     unsigned int port;
-    unsigned long type;         	                /* Type of bind */
+    unsigned long type;                             /* Type of bind */
     int ver;
     int scope;
-    int err;						/* LDAP error code */
+    int err;                        /* LDAP error code */
     time_t idle_time;
     int num_ent;                                        /* Number of entry's found via search */
     int num_val;                                        /* Number of value's found via getval */
@@ -569,11 +569,11 @@ InitLDAP(edui_ldap_t *l)
     l->port = 0;
     l->scope = -1;
     l->type = 0;
-    l->err = -1;					/* Set error to LDAP_SUCCESS by default */
+    l->err = -1;                    /* Set error to LDAP_SUCCESS by default */
     l->ver = 0;
     l->idle_time = 0;
-    l->num_ent = 0;					/* Number of entries in l->lm */
-    l->num_val = 0;					/* Number of entries in l->val */
+    l->num_ent = 0;                 /* Number of entries in l->lm */
+    l->num_val = 0;                 /* Number of entries in l->val */
 
     /* Set default settings from conf */
     if (edui_conf.basedn[0] != '\0')
@@ -601,19 +601,19 @@ static int
 OpenLDAP(edui_ldap_t *l, char *h, unsigned int p)
 {
     if ((l == NULL) || (h == NULL)) return LDAP_ERR_NULL;
-    if (!(l->status & LDAP_INIT_S)) return LDAP_ERR_INIT;		/* Not initalized, or might be in use */
-    if (l->status & LDAP_OPEN_S) return LDAP_ERR_OPEN;			/* Already open */
-    if (l->status & LDAP_BIND_S) return LDAP_ERR_BIND;			/* Already bound */
+    if (!(l->status & LDAP_INIT_S)) return LDAP_ERR_INIT;       /* Not initalized, or might be in use */
+    if (l->status & LDAP_OPEN_S) return LDAP_ERR_OPEN;          /* Already open */
+    if (l->status & LDAP_BIND_S) return LDAP_ERR_BIND;          /* Already bound */
 
     xstrncpy(l->host, h, sizeof(l->host));
     if (p > 0)
         l->port = p;
     else
-        l->port = LDAP_PORT;						/* Default is port 389 */
+        l->port = LDAP_PORT;                        /* Default is port 389 */
 
 #ifdef NETSCAPE_SSL
     if (l->port == LDAPS_PORT)
-        l->status |= (LDAP_SSL_S | LDAP_TLS_S);				/* SSL Port: 636 */
+        l->status |= (LDAP_SSL_S | LDAP_TLS_S);             /* SSL Port: 636 */
 #endif
 
 #ifdef USE_LDAP_INIT
@@ -623,7 +623,7 @@ OpenLDAP(edui_ldap_t *l, char *h, unsigned int p)
 #endif
     if (l->lp == NULL) {
         l->err = LDAP_CONNECT_ERROR;
-        return LDAP_ERR_CONNECT;					/* Unable to connect */
+        return LDAP_ERR_CONNECT;                    /* Unable to connect */
     } else {
         /* set status */
 //    l->status &= ~(LDAP_INIT_S);
@@ -644,8 +644,8 @@ CloseLDAP(edui_ldap_t *l)
     int s;
     if (l == NULL) return LDAP_ERR_NULL;
     if (l->lp == NULL) return LDAP_ERR_NULL;
-    if (!(l->status & LDAP_INIT_S)) return LDAP_ERR_INIT;		/* Connection not initalized */
-    if (!(l->status & LDAP_OPEN_S)) return LDAP_ERR_OPEN;		/* Connection not open */
+    if (!(l->status & LDAP_INIT_S)) return LDAP_ERR_INIT;       /* Connection not initalized */
+    if (!(l->status & LDAP_OPEN_S)) return LDAP_ERR_OPEN;       /* Connection not open */
 
     if (l->lm != NULL) {
         ldap_msgfree(l->lm);
@@ -661,10 +661,10 @@ CloseLDAP(edui_ldap_t *l)
     if (s == LDAP_SUCCESS) {
         l->status = LDAP_INIT_S;
         l->idle_time = 0;
-        l->err = s;							/* Set LDAP error code */
+        l->err = s;                         /* Set LDAP error code */
         return LDAP_ERR_SUCCESS;
     } else {
-        l->err = s;							/* Set LDAP error code */
+        l->err = s;                         /* Set LDAP error code */
         return LDAP_ERR_FAILED;
     }
 }
@@ -681,18 +681,18 @@ SetVerLDAP(edui_ldap_t *l, int v)
     if (l == NULL) return LDAP_ERR_NULL;
     if ((v > 3) || (v < 1)) return LDAP_ERR_PARAM;
     if (l->lp == NULL) return LDAP_ERR_POINTER;
-    if (!(l->status & LDAP_INIT_S)) return LDAP_ERR_INIT;		/* Not initalized */
-    if (!(l->status & LDAP_OPEN_S)) return LDAP_ERR_OPEN;		/* Not open */
-    if (l->status & LDAP_BIND_S) return LDAP_ERR_BIND;			/* Already bound */
+    if (!(l->status & LDAP_INIT_S)) return LDAP_ERR_INIT;       /* Not initalized */
+    if (!(l->status & LDAP_OPEN_S)) return LDAP_ERR_OPEN;       /* Not open */
+    if (l->status & LDAP_BIND_S) return LDAP_ERR_BIND;          /* Already bound */
 
     /* set version */
     x = ldap_set_option(l->lp, LDAP_OPT_PROTOCOL_VERSION, &v);
     if (x == LDAP_SUCCESS) {
         l->ver = v;
-        l->err = x;							/* Set LDAP error code */
+        l->err = x;                         /* Set LDAP error code */
         return LDAP_ERR_SUCCESS;
     } else {
-        l->err = x;							/* Set LDAP error code */
+        l->err = x;                         /* Set LDAP error code */
         return LDAP_ERR_FAILED;
     }
 }
@@ -707,10 +707,10 @@ BindLDAP(edui_ldap_t *l, char *dn, char *pw, unsigned int t)
 {
     int s;
     if (l == NULL) return LDAP_ERR_NULL;
-    if (!(l->status & LDAP_INIT_S)) return LDAP_ERR_INIT;		/* Not initalized */
-    if (!(l->status & LDAP_OPEN_S)) return LDAP_ERR_OPEN;		/* Not open */
-    if (l->status & LDAP_BIND_S) return LDAP_ERR_BIND;			/* Already bound */
-    if (l->lp == NULL) return LDAP_ERR_POINTER;				/* Error */
+    if (!(l->status & LDAP_INIT_S)) return LDAP_ERR_INIT;       /* Not initalized */
+    if (!(l->status & LDAP_OPEN_S)) return LDAP_ERR_OPEN;       /* Not open */
+    if (l->status & LDAP_BIND_S) return LDAP_ERR_BIND;          /* Already bound */
+    if (l->lp == NULL) return LDAP_ERR_POINTER;             /* Error */
 
     /* Copy details - dn and pw CAN be NULL for anonymous and/or TLS */
     if (dn != NULL) {
@@ -752,13 +752,13 @@ BindLDAP(edui_ldap_t *l, char *dn, char *pw, unsigned int t)
         break;
 #endif
 #ifdef LDAP_AUTH_TLS
-    case LDAP_AUTH_TLS:						/* Added for chicken switch to TLS-enabled without using SSL */
+    case LDAP_AUTH_TLS:                     /* Added for chicken switch to TLS-enabled without using SSL */
         l->type = t;
         break;
 #endif
     default:
         l->type = LDAP_AUTH_NONE;
-        break;							/* Default to anonymous bind */
+        break;                          /* Default to anonymous bind */
     }
 
     /* Bind */
@@ -769,11 +769,11 @@ BindLDAP(edui_ldap_t *l, char *dn, char *pw, unsigned int t)
 #endif
         s = ldap_bind_s(l->lp, l->dn, l->passwd, l->type);
     if (s == LDAP_SUCCESS) {
-        l->status |= LDAP_BIND_S;				/* Success */
-        l->err = s;						/* Set LDAP error code */
+        l->status |= LDAP_BIND_S;               /* Success */
+        l->err = s;                     /* Set LDAP error code */
         return LDAP_ERR_SUCCESS;
     } else {
-        l->err = s;						/* Set LDAP error code */
+        l->err = s;                     /* Set LDAP error code */
         return LDAP_ERR_FAILED;
     }
 }
@@ -795,12 +795,12 @@ ConvertIP(edui_ldap_t *l, char *ip)
     void *y, *z;
     size_t s;
     long x;
-    int i, j, t, swi;							/* IPv6 "::" cut over toggle */
+    int i, j, t, swi;                           /* IPv6 "::" cut over toggle */
     if (l == NULL) return LDAP_ERR_NULL;
     if (ip == NULL) return LDAP_ERR_PARAM;
-    if (!(l->status & LDAP_INIT_S)) return LDAP_ERR_INIT;		/* Not initalized */
-    if (!(l->status & LDAP_OPEN_S)) return LDAP_ERR_OPEN;		/* Not open */
-    if (!(l->status & LDAP_BIND_S)) return LDAP_ERR_BIND;		/* Not bound */
+    if (!(l->status & LDAP_INIT_S)) return LDAP_ERR_INIT;       /* Not initalized */
+    if (!(l->status & LDAP_OPEN_S)) return LDAP_ERR_OPEN;       /* Not open */
+    if (!(l->status & LDAP_BIND_S)) return LDAP_ERR_BIND;       /* Not bound */
 
     y = memchr((void *)ip, ':', EDUI_MAXLEN);
     z = memchr((void *)ip, '.', EDUI_MAXLEN);
@@ -837,21 +837,21 @@ ConvertIP(edui_ldap_t *l, char *ip)
     *(obj) = '\0';
     /* StringSplit() will zero out bufa & obj at each call */
     memset(l->search_ip, '\0', sizeof(l->search_ip));
-    xstrncpy(bufa, ip, sizeof(bufa));						/* To avoid segfaults, use bufa instead of ip */
+    xstrncpy(bufa, ip, sizeof(bufa));                       /* To avoid segfaults, use bufa instead of ip */
     swi = 0;
     if (l->status & LDAP_IPV6_S) {
         /* Search for :: in string */
         if ((bufa[0] == ':') && (bufa[1] == ':')) {
             /* bufa starts with a ::, so just copy and clear */
             xstrncpy(bufb, bufa, sizeof(bufb));
             *(bufa) = '\0';
-            ++swi;								/* Indicates that there is a bufb */
+            ++swi;                              /* Indicates that there is a bufb */
         } else if ((bufa[0] == ':') && (bufa[1] != ':')) {
             /* bufa starts with a :, a typo so just fill in a ':', cat and clear */
             bufb[0] = ':';
             strncat(bufb, bufa, strlen(bufa));
             *(bufa) = '\0';
-            ++swi;								/* Indicates that there is a bufb */
+            ++swi;                              /* Indicates that there is a bufb */
         } else {
             p = strstr(bufa, "::");
             if (p != NULL) {
@@ -861,7 +861,7 @@ ConvertIP(edui_ldap_t *l, char *ip)
                 memcpy(bufb, p, i);
                 *p = '\0';
                 bufb[i] = '\0';
-                ++swi;								/* Indicates that there is a bufb */
+                ++swi;                              /* Indicates that there is a bufb */
             }
         }
     }
@@ -876,39 +876,39 @@ ConvertIP(edui_ldap_t *l, char *ip)
                 errno = 0;
                 x = strtol(obj, (char **)NULL, 10);
                 if (((x < 0) || (x > 255)) || ((errno != 0) && (x == 0)) || ((obj[0] != '0') && (x == 0)))
-                    return LDAP_ERR_OOB;						/* Out of bounds -- Invalid address */
+                    return LDAP_ERR_OOB;                        /* Out of bounds -- Invalid address */
                 memset(hexc, '\0', sizeof(hexc));
                 int hlen = snprintf(hexc, sizeof(hexc), "%02X", (int)x);
                 strncat(l->search_ip, hexc, hlen);
             } else
-                break;								/* reached end of octet */
+                break;                              /* reached end of octet */
         } else if (l->status & LDAP_IPV6_S) {
             /* Break down IPv6 address */
             if (swi > 1)
-                t = StringSplit(bufb, ':', obj, sizeof(obj));			/* After "::" */
+                t = StringSplit(bufb, ':', obj, sizeof(obj));           /* After "::" */
             else
-                t = StringSplit(bufa, ':', obj, sizeof(obj));			/* Before "::" */
+                t = StringSplit(bufa, ':', obj, sizeof(obj));           /* Before "::" */
             /* Convert octet by size (t) - and fill 0's */
-            switch (t) {							/* IPv6 is already in HEX, copy contents */
+            switch (t) {                            /* IPv6 is already in HEX, copy contents */
             case 4:
                 hexc[0] = (char) toupper((int)obj[0]);
                 i = (int)hexc[0];
                 if (!isxdigit(i))
-                    return LDAP_ERR_OOB;					/* Out of bounds */
+                    return LDAP_ERR_OOB;                    /* Out of bounds */
                 hexc[1] = (char) toupper((int)obj[1]);
                 i = (int)hexc[1];
                 if (!isxdigit(i))
-                    return LDAP_ERR_OOB;					/* Out of bounds */
+                    return LDAP_ERR_OOB;                    /* Out of bounds */
                 hexc[2] = '\0';
                 strncat(l->search_ip, hexc, 2);
                 hexc[0] = (char) toupper((int)obj[2]);
                 i = (int)hexc[0];
                 if (!isxdigit(i))
-                    return LDAP_ERR_OOB;					/* Out of bounds */
+                    return LDAP_ERR_OOB;                    /* Out of bounds */
                 hexc[1] = (char) toupper((int)obj[3]);
                 i = (int)hexc[1];
                 if (!isxdigit(i))
-                    return LDAP_ERR_OOB;					/* Out of bounds */
+                    return LDAP_ERR_OOB;                    /* Out of bounds */
                 hexc[2] = '\0';
                 strncat(l->search_ip, hexc, 2);
                 break;
@@ -917,17 +917,17 @@ ConvertIP(edui_ldap_t *l, char *ip)
                 hexc[1] = (char) toupper((int)obj[0]);
                 i = (int)hexc[1];
                 if (!isxdigit(i))
-                    return LDAP_ERR_OOB;					/* Out of bounds */
+                    return LDAP_ERR_OOB;                    /* Out of bounds */
                 hexc[2] = '\0';
                 strncat(l->search_ip, hexc, 2);
                 hexc[0] = (char) toupper((int)obj[1]);
                 i = (int)hexc[0];
                 if (!isxdigit(i))
-                    return LDAP_ERR_OOB;					/* Out of bounds */
+                    return LDAP_ERR_OOB;                    /* Out of bounds */
                 hexc[1] = (char) toupper((int)obj[2]);
                 i = (int)hexc[1];
                 if (!isxdigit(i))
-                    return LDAP_ERR_OOB;					/* Out of bounds */
+                    return LDAP_ERR_OOB;                    /* Out of bounds */
                 hexc[2] = '\0';
                 strncat(l->search_ip, hexc, 2);
                 break;
@@ -936,11 +936,11 @@ ConvertIP(edui_ldap_t *l, char *ip)
                 hexc[0] = (char) toupper((int)obj[0]);
                 i = (int)hexc[0];
                 if (!isxdigit(i))
-                    return LDAP_ERR_OOB;					/* Out of bounds */
+                    return LDAP_ERR_OOB;                    /* Out of bounds */
                 hexc[1] = (char) toupper((int)obj[1]);
                 i = (int)hexc[1];
                 if (!isxdigit(i))
-                    return LDAP_ERR_OOB;					/* Out of bounds */
+                    return LDAP_ERR_OOB;                    /* Out of bounds */
                 hexc[2] = '\0';
                 strncat(l->search_ip, hexc, 2);
                 break;
@@ -950,7 +950,7 @@ ConvertIP(edui_ldap_t *l, char *ip)
                 hexc[1] = (char) toupper((int)obj[0]);
                 i = (int)hexc[1];
                 if (!isxdigit(i))
-                    return LDAP_ERR_OOB;					/* Out of bounds */
+                    return LDAP_ERR_OOB;                    /* Out of bounds */
                 hexc[2] = '\0';
                 strncat(l->search_ip, hexc, 2);
                 break;
@@ -969,8 +969,8 @@ ConvertIP(edui_ldap_t *l, char *ip)
                     if (bufb[i] == ':')
                         ++j;
                 }
-                --j;								/* Preceding "::" doesn't count */
-                t = 8 - (strlen(l->search_ip) / 4) - j;			/* Remainder */
+                --j;                                /* Preceding "::" doesn't count */
+                t = 8 - (strlen(l->search_ip) / 4) - j;         /* Remainder */
                 if (t > 0) {
                     for (i = 0; i < t; ++i)
                         strncat(l->search_ip, "0000", 4);
@@ -1067,10 +1067,10 @@ SearchFilterLDAP(edui_ldap_t *l, char *group)
     int swi;
     char bufa[EDUI_MAXLEN], bufb[EDUI_MAXLEN], bufc[EDUI_MAXLEN], bufd[EDUI_MAXLEN], bufg[EDUI_MAXLEN];
     if (l == NULL) return LDAP_ERR_NULL;
-    if (!(l->status & LDAP_INIT_S)) return LDAP_ERR_INIT;			/* Not initalized */
-    if (!(l->status & LDAP_OPEN_S)) return LDAP_ERR_OPEN;			/* Not open */
-    if (!(l->status & LDAP_BIND_S)) return LDAP_ERR_BIND;			/* Not Bound */
-    if (l->search_ip[0] == '\0') return LDAP_ERR_DATA;				/* Search IP is required */
+    if (!(l->status & LDAP_INIT_S)) return LDAP_ERR_INIT;           /* Not initalized */
+    if (!(l->status & LDAP_OPEN_S)) return LDAP_ERR_OPEN;           /* Not open */
+    if (!(l->status & LDAP_BIND_S)) return LDAP_ERR_BIND;           /* Not Bound */
+    if (l->search_ip[0] == '\0') return LDAP_ERR_DATA;              /* Search IP is required */
 
     /* Zero out if not already */
     memset(bufa, '\0', sizeof(bufa));
@@ -1160,15 +1160,15 @@ SearchLDAP(edui_ldap_t *l, int scope, char *filter, char **attrs)
     int s;
     char ft[EDUI_MAXLEN];
     if (l == NULL) return LDAP_ERR_NULL;
-    if ((scope < 0) || (filter == NULL)) return LDAP_ERR_PARAM;		/* If attrs is NULL, then all attrs will return */
+    if ((scope < 0) || (filter == NULL)) return LDAP_ERR_PARAM;     /* If attrs is NULL, then all attrs will return */
     if (l->lp == NULL) return LDAP_ERR_POINTER;
-    if (!(l->status & LDAP_INIT_S)) return LDAP_ERR_INIT;		/* Not initalized */
-    if (!(l->status & LDAP_OPEN_S)) return LDAP_ERR_OPEN;		/* Not open */
-    if (!(l->status & LDAP_BIND_S)) return LDAP_ERR_BIND;		/* Not bound */
-    if (l->status & LDAP_SEARCH_S) return LDAP_ERR_SEARCHED;		/* Already searching */
-    if (l->basedn[0] == '\0') return LDAP_ERR_DATA;			/* We require a basedn */
+    if (!(l->status & LDAP_INIT_S)) return LDAP_ERR_INIT;       /* Not initalized */
+    if (!(l->status & LDAP_OPEN_S)) return LDAP_ERR_OPEN;       /* Not open */
+    if (!(l->status & LDAP_BIND_S)) return LDAP_ERR_BIND;       /* Not bound */
+    if (l->status & LDAP_SEARCH_S) return LDAP_ERR_SEARCHED;        /* Already searching */
+    if (l->basedn[0] == '\0') return LDAP_ERR_DATA;         /* We require a basedn */
     if (l->lm != NULL)
-        ldap_msgfree(l->lm);						/* Make sure l->lm is empty */
+        ldap_msgfree(l->lm);                        /* Make sure l->lm is empty */
 
     xstrncpy(ft, filter, sizeof(ft));
 
@@ -1189,10 +1189,10 @@ SearchLDAP(edui_ldap_t *l, int scope, char *filter, char **attrs)
         break;
     }
     if (s == LDAP_SUCCESS) {
-        l->status |= (LDAP_SEARCH_S);					/* Mark as searched */
+        l->status |= (LDAP_SEARCH_S);                   /* Mark as searched */
         l->err = s;
-        l->idle_time = 0;						/* Connection in use, reset idle timer */
-        l->num_ent = ldap_count_entries(l->lp, l->lm);			/* Counted */
+        l->idle_time = 0;                       /* Connection in use, reset idle timer */
+        l->num_ent = ldap_count_entries(l->lp, l->lm);          /* Counted */
         return LDAP_ERR_SUCCESS;
     } else {
         l->err = s;
@@ -1219,29 +1219,29 @@ SearchIPLDAP(edui_ldap_t *l)
     LDAPMessage *ent;
     if (l == NULL) return LDAP_ERR_NULL;
     if (l->lp == NULL) return LDAP_ERR_POINTER;
-    if (!(l->status & LDAP_INIT_S)) return LDAP_ERR_INIT;				/* Not initalized */
-    if (!(l->status & LDAP_OPEN_S)) return LDAP_ERR_OPEN;				/* Not open */
-    if (!(l->status & LDAP_BIND_S)) return LDAP_ERR_BIND;				/* Not bound */
-    if (!(l->status & LDAP_SEARCH_S)) return LDAP_ERR_NOT_SEARCHED;			/* Not searched */
+    if (!(l->status & LDAP_INIT_S)) return LDAP_ERR_INIT;               /* Not initalized */
+    if (!(l->status & LDAP_OPEN_S)) return LDAP_ERR_OPEN;               /* Not open */
+    if (!(l->status & LDAP_BIND_S)) return LDAP_ERR_BIND;               /* Not bound */
+    if (!(l->status & LDAP_SEARCH_S)) return LDAP_ERR_NOT_SEARCHED;         /* Not searched */
     if (l->num_ent <= 0) {
         debug("l->num_ent: %d\n", l->num_ent);
-        return LDAP_ERR_DATA;								/* No entries found */
+        return LDAP_ERR_DATA;                               /* No entries found */
     }
     if (l->val != NULL)
-        ldap_value_free_len(l->val);							/* Clear data before populating */
+        ldap_value_free_len(l->val);                            /* Clear data before populating */
     l->num_val = 0;
     if (l->status & LDAP_VAL_S)
-        l->status &= ~(LDAP_VAL_S);							/* Clear VAL bit */
+        l->status &= ~(LDAP_VAL_S);                         /* Clear VAL bit */
     if (edui_conf.attrib[0] == '\0')
-        xstrncpy(edui_conf.attrib, "cn", sizeof(edui_conf.attrib));			/* Make sure edui_conf.attrib is set */
+        xstrncpy(edui_conf.attrib, "cn", sizeof(edui_conf.attrib));         /* Make sure edui_conf.attrib is set */
 
     /* Sift through entries */
     struct berval **ber = NULL;
     for (ent = ldap_first_entry(l->lp, l->lm); ent != NULL; ent = ldap_next_entry(l->lp, ent)) {
         l->val = ldap_get_values_len(l->lp, ent, "networkAddress");
-        ber = ldap_get_values_len(l->lp, ent, edui_conf.attrib);			/* edui_conf.attrib is the <userid> mapping */
+        ber = ldap_get_values_len(l->lp, ent, edui_conf.attrib);            /* edui_conf.attrib is the <userid> mapping */
         if (l->val != NULL) {
-            x = ldap_count_values_len(l->val);						/* We got x values ... */
+            x = ldap_count_values_len(l->val);                      /* We got x values ... */
             l->num_val = x;
             if (x > 0) {
                 /* Display all values */
@@ -1250,29 +1250,29 @@ SearchIPLDAP(edui_ldap_t *l)
                     memcpy(bufa, l->val[i]->bv_val, j);
                     z = BinarySplit(bufa, j, '#', bufb, sizeof(bufb));
                     /* BINARY DEBUGGING *
-                                        	  local_printfx("value[%" PRIuSIZE "]: BinarySplit(", (size_t) i);
-                                        	  for (k = 0; k < z; ++k) {
-                                        	    c = (int) bufb[k];
-                                        	    if (c < 0)
-                                        	      c = c + 256;
-                                        	    local_printfx("%02X", c);
-                                        	  }
-                                        	  local_printfx(", ");
-                                        	  for (k = 0; k < (j - z - 1); ++k) {
-                                        	    c = (int) bufa[k];
-                                        	    if (c < 0)
-                                        	      c = c + 256;
-                                        	    local_printfx("%02X", c);
-                                        	  }
-                                        	  local_printfx("): %" PRIuSIZE "\n", (size_t) z);
+                                              local_printfx("value[%" PRIuSIZE "]: BinarySplit(", (size_t) i);
+                                              for (k = 0; k < z; ++k) {
+                                                c = (int) bufb[k];
+                                                if (c < 0)
+                                                  c = c + 256;
+                                                local_printfx("%02X", c);
+                                              }
+                                              local_printfx(", ");
+                                              for (k = 0; k < (j - z - 1); ++k) {
+                                                c = (int) bufa[k];
+                                                if (c < 0)
+                                                  c = c + 256;
+                                                local_printfx("%02X", c);
+                                              }
+                                              local_printfx("): %" PRIuSIZE "\n", (size_t) z);
                     * BINARY DEBUGGING */
                     z = j - z - 1;
                     j = atoi(bufb);
                     if (j == 1) {
                         /* IPv4 address (eDirectory 8.7 and below) */
                         /* bufa is the address, just compare it */
                         if (!(l->status & LDAP_IPV4_S) || (l->status & LDAP_IPV6_S))
-                            break;							/* Not looking for IPv4 */
+                            break;                          /* Not looking for IPv4 */
                         for (k = 0; k < z; ++k) {
                             c = (int) bufa[k];
                             if (c < 0)
@@ -1300,14 +1300,14 @@ SearchIPLDAP(edui_ldap_t *l)
                             l->num_val = 0;
                             l->err = LDAP_SUCCESS;
                             l->status &= ~(LDAP_SEARCH_S);
-                            return LDAP_ERR_SUCCESS;				/* We got our userid */
+                            return LDAP_ERR_SUCCESS;                /* We got our userid */
                         }
                         /* Not matched, continue */
                     } else if ((j == 8) || (j == 9)) {
                         /* IPv4 (UDP/TCP) address (eDirectory 8.8 and higher) */
                         /* bufa + 2 is the address (skip 2 digit port) */
                         if (!(l->status & LDAP_IPV4_S) || (l->status & LDAP_IPV6_S))
-                            break;							/* Not looking for IPv4 */
+                            break;                          /* Not looking for IPv4 */
                         for (k = 2; k < z; ++k) {
                             c = (int) bufa[k];
                             if (c < 0)
@@ -1335,14 +1335,14 @@ SearchIPLDAP(edui_ldap_t *l)
                             l->num_val = 0;
                             l->err = LDAP_SUCCESS;
                             l->status &= ~(LDAP_SEARCH_S);
-                            return LDAP_ERR_SUCCESS;				/* We got our userid */
+                            return LDAP_ERR_SUCCESS;                /* We got our userid */
                         }
                         /* Not matched, continue */
                     } else if ((j == 10) || (j == 11)) {
                         /* IPv6 (UDP/TCP) address (eDirectory 8.8 and higher) */
                         /* bufa + 2 is the address (skip 2 digit port) */
                         if (!(l->status & LDAP_IPV6_S))
-                            break;							/* Not looking for IPv6 */
+                            break;                          /* Not looking for IPv6 */
                         for (k = 2; k < z; ++k) {
                             c = (int) bufa[k];
                             if (c < 0)
@@ -1370,11 +1370,11 @@ SearchIPLDAP(edui_ldap_t *l)
                             l->num_val = 0;
                             l->err = LDAP_SUCCESS;
                             l->status &= ~(LDAP_SEARCH_S);
-                            return LDAP_ERR_SUCCESS;				/* We got our userid */
+                            return LDAP_ERR_SUCCESS;                /* We got our userid */
                         }
                         /* Not matched, continue */
                     }
-//		    else {
+//          else {
                     /* Others are unsupported */
 //                    }
                 }
@@ -1405,7 +1405,7 @@ SearchIPLDAP(edui_ldap_t *l)
     l->num_val = 0;
     l->err = LDAP_NO_SUCH_OBJECT;
     l->status &= ~(LDAP_SEARCH_S);
-    return LDAP_ERR_NOTFOUND;						/* Not found ... Sorry :) */
+    return LDAP_ERR_NOTFOUND;                       /* Not found ... Sorry :) */
 }
 
 /*
@@ -1531,27 +1531,27 @@ MainSafe(int argc, char **argv)
                         return 1;
                     case 'd':
                         if (!(edui_conf.mode & EDUI_MODE_DEBUG))
-                            edui_conf.mode |= EDUI_MODE_DEBUG;		/* Don't set mode more than once */
-                        debug_enabled = 1;				/* Official Squid-3 Debug Mode */
+                            edui_conf.mode |= EDUI_MODE_DEBUG;      /* Don't set mode more than once */
+                        debug_enabled = 1;              /* Official Squid-3 Debug Mode */
                         break;
                     case '4':
                         if (!(edui_conf.mode & EDUI_MODE_IPV4) || !(edui_conf.mode & EDUI_MODE_IPV6))
-                            edui_conf.mode |= EDUI_MODE_IPV4;		/* Don't set mode more than once */
+                            edui_conf.mode |= EDUI_MODE_IPV4;       /* Don't set mode more than once */
                         break;
                     case '6':
                         if (!(edui_conf.mode & EDUI_MODE_IPV4) || !(edui_conf.mode & EDUI_MODE_IPV6))
-                            edui_conf.mode |= EDUI_MODE_IPV6;		/* Don't set mode more than once */
+                            edui_conf.mode |= EDUI_MODE_IPV6;       /* Don't set mode more than once */
                         break;
                     case 'Z':
                         if (!(edui_conf.mode & EDUI_MODE_TLS))
-                            edui_conf.mode |= EDUI_MODE_TLS;		/* Don't set mode more than once */
+                            edui_conf.mode |= EDUI_MODE_TLS;        /* Don't set mode more than once */
                         break;
                     case 'P':
                         if (!(edui_conf.mode & EDUI_MODE_PERSIST))
-                            edui_conf.mode |= EDUI_MODE_PERSIST;	/* Don't set mode more than once */
+                            edui_conf.mode |= EDUI_MODE_PERSIST;    /* Don't set mode more than once */
                         break;
                     case 'v':
-                        ++i;						/* Set LDAP version */
+                        ++i;                        /* Set LDAP version */
                         if (argv[i] != NULL) {
                             edui_conf.ver = atoi(argv[i]);
                             if (edui_conf.ver < 1)
@@ -1565,7 +1565,7 @@ MainSafe(int argc, char **argv)
                         }
                         break;
                     case 't':
-                        ++i;						/* Set Persistent timeout */
+                        ++i;                        /* Set Persistent timeout */
                         if (argv[i] != NULL) {
                             edui_conf.persist_timeout = atoi(argv[i]);
                             if (edui_conf.persist_timeout < 0)
@@ -1577,7 +1577,7 @@ MainSafe(int argc, char **argv)
                         }
                         break;
                     case 'b':
-                        ++i;						/* Set Base DN */
+                        ++i;                        /* Set Base DN */
                         if (argv[i] != NULL)
                             xstrncpy(edui_conf.basedn, argv[i], sizeof(edui_conf.basedn));
                         else {
@@ -1587,7 +1587,7 @@ MainSafe(int argc, char **argv)
                         }
                         break;
                     case 'H':
-                        ++i;						/* Set Hostname */
+                        ++i;                        /* Set Hostname */
                         if (argv[i] != NULL)
                             xstrncpy(edui_conf.host, argv[i], sizeof(edui_conf.host));
                         else {
@@ -1597,7 +1597,7 @@ MainSafe(int argc, char **argv)
                         }
                         break;
                     case 'p':
-                        ++i;						/* Set port */
+                        ++i;                        /* Set port */
                         if (argv[i] != NULL)
                             edui_conf.port = atoi(argv[i]);
                         else {
@@ -1607,7 +1607,7 @@ MainSafe(int argc, char **argv)
                         }
                         break;
                     case 'D':
-                        ++i;						/* Set Bind DN */
+                        ++i;                        /* Set Bind DN */
                         if (argv[i] != NULL)
                             xstrncpy(edui_conf.dn, argv[i], sizeof(edui_conf.dn));
                         else {
@@ -1617,7 +1617,7 @@ MainSafe(int argc, char **argv)
                         }
                         break;
                     case 'W':
-                        ++i;						/* Set Bind PWD */
+                        ++i;                        /* Set Bind PWD */
                         if (argv[i] != NULL)
                             xstrncpy(edui_conf.passwd, argv[i], sizeof(edui_conf.passwd));
                         else {
@@ -1627,7 +1627,7 @@ MainSafe(int argc, char **argv)
                         }
                         break;
                     case 'F':
-                        ++i;						/* Set Search Filter */
+                        ++i;                        /* Set Search Filter */
                         if (argv[i] != NULL)
                             xstrncpy(edui_conf.search_filter, argv[i], sizeof(edui_conf.search_filter));
                         else {
@@ -1638,10 +1638,10 @@ MainSafe(int argc, char **argv)
                         break;
                     case 'G':
                         if (!(edui_conf.mode & EDUI_MODE_GROUP))
-                            edui_conf.mode |= EDUI_MODE_GROUP;		/* Don't set mode more than once */
+                            edui_conf.mode |= EDUI_MODE_GROUP;      /* Don't set mode more than once */
                         break;
                     case 's':
-                        ++i;						/* Set Scope Level */
+                        ++i;                        /* Set Scope Level */
                         if (argv[i] != NULL) {
                             if (!strncmp(argv[i], "base", 4))
                                 edui_conf.scope = 0;
@@ -1650,15 +1650,15 @@ MainSafe(int argc, char **argv)
                             else if (!strncmp(argv[i], "sub", 4))
                                 edui_conf.scope = 2;
                             else
-                                edui_conf.scope = 1;			/* Default is 'one' */
+                                edui_conf.scope = 1;            /* Default is 'one' */
                         } else {
                             local_printfx("No parameters given for 's'.\n");
                             DisplayUsage();
                             return 1;
                         }
                         break;
                     case 'u':
-                        ++i;						/* Set Search Attribute */
+                        ++i;                        /* Set Search Attribute */
                         if (argv[i] != NULL) {
                             xstrncpy(edui_conf.attrib, argv[i], sizeof(edui_conf.attrib));
                         } else {
@@ -1667,7 +1667,7 @@ MainSafe(int argc, char **argv)
                             return 1;
                         }
                         break;
-                    case '-':						/* We got a second '-' ... ignore */
+                    case '-':                       /* We got a second '-' ... ignore */
                         break;
                     default:
                         local_printfx("Invalid parameter - '%c'.\n", argv[i][j]);
@@ -1683,22 +1683,22 @@ MainSafe(int argc, char **argv)
     }
 
     /* Set predefined required paremeters if none are given, localhost:LDAP_PORT, etc */
-    if (edui_conf.host[0] == '\0')				/* Default to localhost */
+    if (edui_conf.host[0] == '\0')              /* Default to localhost */
         xstrncpy(edui_conf.host, "localhost", sizeof(edui_conf.host));
     if (edui_conf.port < 0)
-        edui_conf.port = LDAP_PORT;				/* Default: LDAP_PORT */
+        edui_conf.port = LDAP_PORT;             /* Default: LDAP_PORT */
     if ((edui_conf.mode & EDUI_MODE_IPV4) && (edui_conf.mode & EDUI_MODE_IPV6))
-        edui_conf.mode &= ~(EDUI_MODE_IPV6);			/* Default to IPv4 */
+        edui_conf.mode &= ~(EDUI_MODE_IPV6);            /* Default to IPv4 */
     if (edui_conf.ver < 0)
         edui_conf.ver = 2;
     if (!(edui_conf.mode & EDUI_MODE_TLS))
-        edui_conf.mode |= EDUI_MODE_TLS;			/* eDirectory requires TLS mode */
+        edui_conf.mode |= EDUI_MODE_TLS;            /* eDirectory requires TLS mode */
     if ((edui_conf.mode & EDUI_MODE_TLS) && (edui_conf.ver < 3))
-        edui_conf.ver = 3;					/* TLS requires version 3 */
+        edui_conf.ver = 3;                  /* TLS requires version 3 */
     if (edui_conf.persist_timeout < 0)
-        edui_conf.persist_timeout = 600;			/* Default: 600 seconds (10 minutes) */
+        edui_conf.persist_timeout = 600;            /* Default: 600 seconds (10 minutes) */
     if (edui_conf.scope < 0)
-        edui_conf.scope = 1;					/* Default: one */
+        edui_conf.scope = 1;                    /* Default: one */
     if (edui_conf.search_filter[0] == '\0')
         xstrncpy(edui_conf.search_filter, "(&(objectclass=User)(networkAddress=*))", sizeof(edui_conf.search_filter));
     if (edui_conf.attrib[0] == '\0')
@@ -1766,7 +1766,7 @@ MainSafe(int argc, char **argv)
         if (!(edui_ldap.status & LDAP_INIT_S)) {
             InitLDAP(&edui_ldap);
             debug("InitLDAP() -> %s\n", ErrLDAP(LDAP_ERR_SUCCESS));
-            if (edui_conf.mode & EDUI_MODE_PERSIST)					/* Setup persistant mode */
+            if (edui_conf.mode & EDUI_MODE_PERSIST)                 /* Setup persistant mode */
                 edui_ldap.status |= LDAP_PERSIST_S;
         }
         if ((edui_ldap.status & LDAP_IDLE_S) && (edui_elap > 0)) {
@@ -1880,7 +1880,7 @@ MainSafe(int argc, char **argv)
                                 local_printfx("ERR message=\"(SearchIPLDAP: %s)\"\n", ErrLDAP(x));
                             } else {
                                 debug("SearchIPLDAP(-, %s) -> %s\n", edui_ldap.userid, ErrLDAP(x));
-                                local_printfx("OK user=%s\n", edui_ldap.userid);			/* Got userid --> OK user=<userid> */
+                                local_printfx("OK user=%s\n", edui_ldap.userid);            /* Got userid --> OK user=<userid> */
                             }
                         }
                         /* Clear for next query */
@@ -1920,7 +1920,7 @@ MainSafe(int argc, char **argv)
                             local_printfx("ERR message=\"(SearchIPLDAP: %s)\"\n", ErrLDAP(x));
                         } else {
                             debug("SearchIPLDAP(-, %s) -> %s\n", edui_ldap.userid, ErrLDAP(x));
-                            local_printfx("OK user=%s\n", edui_ldap.userid);				/* Got a userid --> OK user=<userid> */
+                            local_printfx("OK user=%s\n", edui_ldap.userid);                /* Got a userid --> OK user=<userid> */
                         }
                     }
                 }
@@ -1950,3 +1950,4 @@ main(int argc, char **argv)
     x = MainSafe(argc, argv);
     return x;
 }
+
@@ -59,7 +59,7 @@ struct ip_user_dict *load_dict(FILE *);
 int dict_lookup(struct ip_user_dict *, char *, char *);
 
 /** Size of lines read from the dictionary file */
-#define DICT_BUFFER_SIZE	8196
+#define DICT_BUFFER_SIZE    8196
 
 /** This function parses the dictionary file and loads it
  * in memory. All IP addresses are processed with a bitwise AND
@@ -70,14 +70,14 @@ int dict_lookup(struct ip_user_dict *, char *, char *);
  */
 struct ip_user_dict *
 load_dict(FILE * FH) {
-    struct ip_user_dict *current_entry;	/* the structure used to
-					   store data */
-    struct ip_user_dict *first_entry = NULL;	/* the head of the
-						   linked list */
+    struct ip_user_dict *current_entry; /* the structure used to
+                       store data */
+    struct ip_user_dict *first_entry = NULL;    /* the head of the
+                           linked list */
     char line[DICT_BUFFER_SIZE]; /* the buffer for the lines read
-				   from the dict file */
-    char *tmpbuf;			/* for the address before the
-				   bitwise AND */
+                   from the dict file */
+    char *tmpbuf;           /* for the address before the
+                   bitwise AND */
 
     /* the pointer to the first entry in the linked list */
     first_entry = (struct ip_user_dict*)malloc(sizeof(struct ip_user_dict));
@@ -184,15 +184,15 @@ match_user(char *dict_username, char *username)
         }
     }
     return 0;
-}				/* match_user */
+}               /* match_user */
 
 int
 match_group(char *dict_group, char *username)
 {
-    struct group *g;		/* a struct to hold group entries */
-    ++dict_group;			/* the @ should be the first char
-				   so we rip it off by incrementing
-				   * the pointer by one */
+    struct group *g;        /* a struct to hold group entries */
+    ++dict_group;           /* the @ should be the first char
+                   so we rip it off by incrementing
+                   * the pointer by one */
 
     if ((g = getgrnam(dict_group)) == NULL) {
         debug("Group does not exist '%s'\n", dict_group);
@@ -290,3 +290,4 @@ main (int argc, char *argv[])
     fclose (FH);
     return 0;
 }
+
@@ -346,7 +346,7 @@ main(int argc, char *const argv[])
 #if HAVE_KRB5
                 krb5_cleanup();
 #endif
-                exit(1);	/* BIIG buffer */
+                exit(1);    /* BIIG buffer */
             }
             SEND_BH("fgets NULL");
             clean_args(&margs);
@@ -483,3 +483,4 @@ main(int argc, char *const argv[])
     }
 }
 #endif
+
@@ -184,3 +184,4 @@ void krb5_cleanup(void);
 #endif
 
 #define PROGRAM "kerberos_ldap_group"
+
@@ -387,13 +387,13 @@ create_gd(struct main_args *margs)
         cleanup();
         return (1);
     }
-    while (*p) {		/* loop over group list */
-        if (*p == '\n' || *p == '\r') {		/* Ignore CR and LF if exist */
+    while (*p) {        /* loop over group list */
+        if (*p == '\n' || *p == '\r') {     /* Ignore CR and LF if exist */
             ++p;
             continue;
         }
-        if (*p == '@') {	/* end of group name - start of domain name */
-            if (p == gp) {	/* empty group name not allowed */
+        if (*p == '@') {    /* end of group name - start of domain name */
+            if (p == gp) {  /* empty group name not allowed */
                 debug((char *) "%s| %s: ERROR: No group defined for domain %s\n", LogTime(), PROGRAM, p);
                 cleanup();
                 return (1);
@@ -408,40 +408,40 @@ create_gd(struct main_args *margs)
             gdsp = init_gd();
             gdsp->group = xstrdup(gp);
             gdsp->next = gdspn;
-            dp = p;		/* after @ starts new domain name */
-        } else if (*p == ':') {	/* end of group name or end of domain name */
-            if (p == gp) {	/* empty group name not allowed */
+            dp = p;     /* after @ starts new domain name */
+        } else if (*p == ':') { /* end of group name or end of domain name */
+            if (p == gp) {  /* empty group name not allowed */
                 debug((char *) "%s| %s: ERROR: No group defined for domain %s\n", LogTime(), PROGRAM, p);
                 cleanup();
                 return (1);
             }
             *p = '\0';
             ++p;
-            if (dp) {		/* end of domain name */
+            if (dp) {       /* end of domain name */
                 gdsp->domain = xstrdup(dp);
                 dp = NULL;
-            } else {		/* end of group name and no domain name */
+            } else {        /* end of group name and no domain name */
                 gdsp = init_gd();
                 gdsp->group = xstrdup(gp);
                 gdsp->next = gdspn;
             }
             gdspn = gdsp;
-            gp = p;		/* after : starts new group name */
+            gp = p;     /* after : starts new group name */
             debug((char *) "%s| %s: INFO: Group %s  Domain %s\n", LogTime(), PROGRAM, gdsp->group, gdsp->domain ? gdsp->domain : "NULL");
         } else
             ++p;
     }
-    if (p == gp) {		/* empty group name not allowed */
+    if (p == gp) {      /* empty group name not allowed */
         debug((char *) "%s| %s: ERROR: No group defined for domain %s\n", LogTime(), PROGRAM, p);
         cleanup();
         return (1);
     }
-    if (dp) {			/* end of domain name */
+    if (dp) {           /* end of domain name */
         gdsp->domain = xstrdup(dp);
-    } else {			/* end of group name and no domain name */
+    } else {            /* end of group name and no domain name */
         gdsp = init_gd();
         gdsp->group = xstrdup(gp);
-        if (gdspn)		/* Have already an existing structure */
+        if (gdspn)      /* Have already an existing structure */
             gdsp->next = gdspn;
     }
     debug((char *) "%s| %s: INFO: Group %s  Domain %s\n", LogTime(), PROGRAM, gdsp->group, gdsp->domain ? gdsp->domain : "NULL");
@@ -452,3 +452,4 @@ create_gd(struct main_args *margs)
     return (0);
 }
 #endif
+
@@ -226,9 +226,9 @@ krb5_create_cache(char *domain)
 
         debug((char *) "%s| %s: DEBUG: Get default keytab file name\n", LogTime(), PROGRAM);
         krb5_kt_default_name(kparam.context, buf, KT_PATH_MAX);
-        p = strchr(buf, ':');	/* Find the end if "FILE:" */
+        p = strchr(buf, ':');   /* Find the end if "FILE:" */
         if (p)
-            ++p;			/* step past : */
+            ++p;            /* step past : */
         keytab_name = xstrdup(p ? p : buf);
         debug((char *) "%s| %s: DEBUG: Got default keytab file name %s\n", LogTime(), PROGRAM, keytab_name);
 
@@ -487,3 +487,4 @@ krb5_create_cache(char *domain)
     return (retval);
 }
 #endif
+
@@ -1389,3 +1389,4 @@ get_memberof(struct main_args *margs, char *user, char *domain, char *group)
     return (retval);
 }
 #endif
+
@@ -91,3 +91,4 @@ warn(char *format,...)
 
 #endif /* __GNUC__ */
 #endif
+
@@ -86,13 +86,13 @@ create_ls(struct main_args *margs)
         debug((char *) "%s| %s: DEBUG: No ldap servers defined.\n", LogTime(), PROGRAM);
         return (0);
     }
-    while (*p) {		/* loop over group list */
-        if (*p == '\n' || *p == '\r') {		/* Ignore CR and LF if exist */
+    while (*p) {        /* loop over group list */
+        if (*p == '\n' || *p == '\r') {     /* Ignore CR and LF if exist */
             ++p;
             continue;
         }
-        if (*p == '@') {	/* end of group name - start of domain name */
-            if (p == np) {	/* empty group name not allowed */
+        if (*p == '@') {    /* end of group name - start of domain name */
+            if (p == np) {  /* empty group name not allowed */
                 debug((char *) "%s| %s: DEBUG: No ldap servers defined for domain %s\n", LogTime(), PROGRAM, p);
                 free_ls(lssp);
                 return (1);
@@ -107,40 +107,40 @@ create_ls(struct main_args *margs)
             lssp = init_ls();
             lssp->lserver = xstrdup(np);
             lssp->next = lsspn;
-            dp = p;		/* after @ starts new domain name */
-        } else if (*p == ':') {	/* end of group name or end of domain name */
-            if (p == np) {	/* empty group name not allowed */
+            dp = p;     /* after @ starts new domain name */
+        } else if (*p == ':') { /* end of group name or end of domain name */
+            if (p == np) {  /* empty group name not allowed */
                 debug((char *) "%s| %s: DEBUG: No ldap servers defined for domain %s\n", LogTime(), PROGRAM, p);
                 free_ls(lssp);
                 return (1);
             }
             *p = '\0';
             ++p;
-            if (dp) {		/* end of domain name */
+            if (dp) {       /* end of domain name */
                 lssp->domain = xstrdup(dp);
                 dp = NULL;
-            } else {		/* end of group name and no domain name */
+            } else {        /* end of group name and no domain name */
                 lssp = init_ls();
                 lssp->lserver = xstrdup(np);
                 lssp->next = lsspn;
             }
             lsspn = lssp;
-            np = p;		/* after : starts new group name */
+            np = p;     /* after : starts new group name */
             debug((char *) "%s| %s: DEBUG: ldap server %s Domain %s\n", LogTime(), PROGRAM, lssp->lserver, lssp->domain?lssp->domain:"NULL");
         } else
             ++p;
     }
-    if (p == np) {		/* empty group name not allowed */
+    if (p == np) {      /* empty group name not allowed */
         debug((char *) "%s| %s: DEBUG: No ldap servers defined for domain %s\n", LogTime(), PROGRAM, p);
         free_ls(lssp);
         return (1);
     }
-    if (dp) {			/* end of domain name */
+    if (dp) {           /* end of domain name */
         lssp->domain = xstrdup(dp);
-    } else {			/* end of group name and no domain name */
+    } else {            /* end of group name and no domain name */
         lssp = init_ls();
         lssp->lserver = xstrdup(np);
-        if (lsspn)		/* Have already an existing structure */
+        if (lsspn)      /* Have already an existing structure */
             lssp->next = lsspn;
     }
     debug((char *) "%s| %s: DEBUG: ldap server %s Domain %s\n", LogTime(), PROGRAM, lssp->lserver, lssp->domain?lssp->domain:"NULL");
@@ -149,3 +149,4 @@ create_ls(struct main_args *margs)
     return (0);
 }
 #endif
+
@@ -143,3 +143,4 @@ check_memberof(struct main_args *margs, char *user, char *domain)
     return (0);
 }
 #endif
+
@@ -87,13 +87,13 @@ create_nd(struct main_args *margs)
         debug((char *) "%s| %s: DEBUG: No netbios names defined.\n", LogTime(), PROGRAM);
         return (0);
     }
-    while (*p) {		/* loop over group list */
-        if (*p == '\n' || *p == '\r') {		/* Ignore CR and LF if exist */
+    while (*p) {        /* loop over group list */
+        if (*p == '\n' || *p == '\r') {     /* Ignore CR and LF if exist */
             ++p;
             continue;
         }
-        if (*p == '@') {	/* end of group name - start of domain name */
-            if (p == np) {	/* empty group name not allowed */
+        if (*p == '@') {    /* end of group name - start of domain name */
+            if (p == np) {  /* empty group name not allowed */
                 debug((char *) "%s| %s: DEBUG: No netbios name defined for domain %s\n", LogTime(), PROGRAM, p);
                 free_nd(ndsp);
                 return (1);
@@ -108,25 +108,25 @@ create_nd(struct main_args *margs)
             ndsp = init_nd();
             ndsp->netbios = xstrdup(np);
             ndsp->next = ndspn;
-            dp = p;		/* after @ starts new domain name */
-        } else if (*p == ':') {	/* end of group name or end of domain name */
-            if (p == np) {	/* empty group name not allowed */
+            dp = p;     /* after @ starts new domain name */
+        } else if (*p == ':') { /* end of group name or end of domain name */
+            if (p == np) {  /* empty group name not allowed */
                 debug((char *) "%s| %s: DEBUG: No netbios name defined for domain %s\n", LogTime(), PROGRAM, p);
                 free_nd(ndsp);
                 return (1);
             }
             *p = '\0';
             ++p;
-            if (dp) {		/* end of domain name */
+            if (dp) {       /* end of domain name */
                 ndsp->domain = xstrdup(dp);
                 dp = NULL;
-            } else {		/* end of group name and no domain name */
+            } else {        /* end of group name and no domain name */
                 ndsp = init_nd();
                 ndsp->netbios = xstrdup(np);
                 ndsp->next = ndspn;
             }
             ndspn = ndsp;
-            np = p;		/* after : starts new group name */
+            np = p;     /* after : starts new group name */
             if (!ndsp->domain || !strcmp(ndsp->domain, "")) {
                 debug((char *) "%s| %s: DEBUG: No domain defined for netbios name %s\n", LogTime(), PROGRAM, ndsp->netbios);
                 free_nd(ndsp);
@@ -136,14 +136,14 @@ create_nd(struct main_args *margs)
         } else
             ++p;
     }
-    if (p == np) {		/* empty group name not allowed */
+    if (p == np) {      /* empty group name not allowed */
         debug((char *) "%s| %s: DEBUG: No netbios name defined for domain %s\n", LogTime(), PROGRAM, p);
         free_nd(ndsp);
         return (1);
     }
-    if (dp) {			/* end of domain name */
+    if (dp) {           /* end of domain name */
         ndsp->domain = xstrdup(dp);
-    } else {			/* end of group name and no domain name */
+    } else {            /* end of group name and no domain name */
         ndsp = init_nd();
         ndsp->netbios = xstrdup(np);
         ndsp->next = ndspn;
@@ -177,3 +177,4 @@ get_netbios_name(struct main_args *margs, char *netbios)
     return NULL;
 }
 #endif
+
@@ -316,7 +316,7 @@ get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, size_t n
         }
     }
     p = buffer;
-    p += 6 * NS_INT16SZ;	/* Header(6*16bit) = id + flags + 4*section count */
+    p += 6 * NS_INT16SZ;    /* Header(6*16bit) = id + flags + 4*section count */
     if (p > buffer + len) {
         error((char *) "%s| %s: ERROR: Message to small: %d < header size\n", LogTime(), PROGRAM, len);
         goto finalise;
@@ -325,8 +325,8 @@ get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, size_t n
         error((char *) "%s| %s: ERROR: Error while expanding query name with dn_expand:  %s\n", LogTime(), PROGRAM, strerror(errno));
         goto finalise;
     }
-    p += size;			/* Query name */
-    p += 2 * NS_INT16SZ;	/* Query type + class (2*16bit) */
+    p += size;          /* Query name */
+    p += 2 * NS_INT16SZ;    /* Query type + class (2*16bit) */
     if (p > buffer + len) {
         error((char *) "%s| %s: ERROR: Message to small: %d < header + query name,type,class \n", LogTime(), PROGRAM, len);
         goto finalise;
@@ -337,37 +337,37 @@ get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, size_t n
             error((char *) "%s| %s: ERROR: Error while expanding answer name with dn_expand:  %s\n", LogTime(), PROGRAM, strerror(errno));
             goto finalise;
         }
-        p += size;		/* Resource Record name */
+        p += size;      /* Resource Record name */
         if (p > buffer + len) {
             error((char *) "%s| %s: ERROR: Message to small: %d < header + query name,type,class + answer name\n", LogTime(), PROGRAM, len);
             goto finalise;
         }
-        NS_GET16(type, p);	/* RR type (16bit) */
-        p += NS_INT16SZ + NS_INT32SZ;	/* RR class + ttl (16bit+32bit) */
+        NS_GET16(type, p);  /* RR type (16bit) */
+        p += NS_INT16SZ + NS_INT32SZ;   /* RR class + ttl (16bit+32bit) */
         if (p > buffer + len) {
             error((char *) "%s| %s: ERROR: Message to small: %d < header + query name,type,class + answer name + RR type,class,ttl\n", LogTime(), PROGRAM, len);
             goto finalise;
         }
-        NS_GET16(rdlength, p);	/* RR data length (16bit) */
+        NS_GET16(rdlength, p);  /* RR data length (16bit) */
 
-        if (type == ns_t_srv) {	/* SRV record */
+        if (type == ns_t_srv) { /* SRV record */
             int priority, weight, port;
             char host[NS_MAXDNAME];
             if (p > buffer + len) {
                 error((char *) "%s| %s: ERROR: Message to small: %d < header + query name,type,class + answer name + RR type,class,ttl + RR data length\n", LogTime(), PROGRAM, len);
                 goto finalise;
             }
-            NS_GET16(priority, p);	/* Priority (16bit) */
+            NS_GET16(priority, p);  /* Priority (16bit) */
             if (p > buffer + len) {
                 error((char *) "%s| %s: ERROR: Message to small: %d <  SRV RR + priority\n", LogTime(), PROGRAM, len);
                 goto finalise;
             }
-            NS_GET16(weight, p);	/* Weight (16bit) */
+            NS_GET16(weight, p);    /* Weight (16bit) */
             if (p > buffer + len) {
                 error((char *) "%s| %s: ERROR: Message to small: %d <  SRV RR + priority + weight\n", LogTime(), PROGRAM, len);
                 goto finalise;
             }
-            NS_GET16(port, p);	/* Port (16bit) */
+            NS_GET16(port, p);  /* Port (16bit) */
             if (p > buffer + len) {
                 error((char *) "%s| %s: ERROR: Message to small: %d <  SRV RR + priority + weight + port\n", LogTime(), PROGRAM, len);
                 goto finalise;
@@ -451,3 +451,4 @@ get_ldap_hostname_list(struct main_args *margs, struct hstruct **hlist, size_t n
     return (nhosts);
 }
 #endif
+
@@ -43,21 +43,21 @@
 #include <sasl/sasl.h>
 #elif HAVE_SASL_DARWIN
 typedef struct sasl_interact {
-    unsigned long id;		/* same as client/user callback ID */
-    const char *challenge;	/* presented to user (e.g. OTP challenge) */
-    const char *prompt;		/* presented to user (e.g. "Username: ") */
-    const char *defresult;	/* default result string */
-    const void *result;		/* set to point to result */
-    unsigned len;		/* set to length of result */
+    unsigned long id;       /* same as client/user callback ID */
+    const char *challenge;  /* presented to user (e.g. OTP challenge) */
+    const char *prompt;     /* presented to user (e.g. "Username: ") */
+    const char *defresult;  /* default result string */
+    const void *result;     /* set to point to result */
+    unsigned len;       /* set to length of result */
 } sasl_interact_t;
 
-#define SASL_CB_USER         0x4001	/* client user identity to login as */
-#define SASL_CB_AUTHNAME     0x4002	/* client authentication name */
-#define SASL_CB_PASS         0x4004	/* client passphrase-based secret */
-#define SASL_CB_ECHOPROMPT   0x4005	/* challenge and client enterred result */
-#define SASL_CB_NOECHOPROMPT 0x4006	/* challenge and client enterred result */
-#define SASL_CB_GETREALM     0x4008	/* realm to attempt authentication in */
-#define SASL_CB_LIST_END   0	/* end of list */
+#define SASL_CB_USER         0x4001 /* client user identity to login as */
+#define SASL_CB_AUTHNAME     0x4002 /* client authentication name */
+#define SASL_CB_PASS         0x4004 /* client passphrase-based secret */
+#define SASL_CB_ECHOPROMPT   0x4005 /* challenge and client enterred result */
+#define SASL_CB_NOECHOPROMPT 0x4006 /* challenge and client enterred result */
+#define SASL_CB_GETREALM     0x4008 /* realm to attempt authentication in */
+#define SASL_CB_LIST_END   0    /* end of list */
 #endif
 
 #if HAVE_SASL_H || HAVE_SASL_SASL_H || HAVE_SASL_DARWIN
@@ -287,3 +287,4 @@ dummy(void)
 
 #endif
 #endif
+
@@ -233,3 +233,4 @@ int main(int argc, char **argv)
     shutdown_db();
     return 0;
 }
+
@@ -253,10 +253,10 @@ static void parseTime(const char *s, time_t *secs, time_t *start)
 static void readConfig(const char *filename)
 {
     char line[TQ_BUFFERSIZE];        /* the buffer for the lines read
-				   from the dict file */
-    char *cp;			/* a char pointer used to parse
-				   each line */
-    char *username;		/* for the username */
+                   from the dict file */
+    char *cp;           /* a char pointer used to parse
+                   each line */
+    char *username;     /* for the username */
     char *budget;
     char *period;
     FILE *FH;
@@ -461,3 +461,4 @@ int main(int argc, char **argv)
     shutdown_db();
     return 0;
 }
+
@@ -176,7 +176,7 @@ main(int argc, char *argv[])
             } else {
                 fprintf(stderr, "Unknown option character `\\x%x'.\n", optopt);
             }
-            // fall through to display help texts.
+        // fall through to display help texts.
 
         default:
             usage(argv[0]);
@@ -238,3 +238,4 @@ main(int argc, char *argv[])
     }
     return 0;
 }
+
@@ -31,7 +31,7 @@
 #include "defines.h"
 
 /* parse buffer - ie, length of longest expected line */
-#define	LOGFILE_BUF_LEN		65536
+#define LOGFILE_BUF_LEN     65536
 
 static void
 rotate(const char *path, int rotate_count)
@@ -176,3 +176,4 @@ main(int argc, char *argv[])
     fp = NULL;
     exit(0);
 }
+
@@ -115,7 +115,7 @@ process_options(int argc, char *argv[])
             exit(0);
         case '?':
             opt = optopt;
-            /* fall thru to default */
+        /* fall thru to default */
         default:
             fprintf(stderr, "ERROR: unknown option: -%c. Exiting\n", opt);
             usage();
@@ -166,10 +166,10 @@ manage_request()
     } else
         debug("Got '%s' from Squid\n", buf);
 
-    if (memcmp(buf, "YR ", 3) == 0) {	/* refresh-request */
+    if (memcmp(buf, "YR ", 3) == 0) {   /* refresh-request */
         /* figure out what we got */
         decodedLen = base64_decode(decoded, sizeof(decoded), buf + 3);
-        if ((size_t)decodedLen < sizeof(ntlmhdr)) {		/* decoding failure, return error */
+        if ((size_t)decodedLen < sizeof(ntlmhdr)) {     /* decoding failure, return error */
             SEND("NA * Packet format error, couldn't base64-decode");
             return 1;
         }
@@ -178,7 +178,7 @@ manage_request()
 
         if (status == SSP_OK) {
             if (Done) {
-                lc(cred);	/* let's lowercase them for our convenience */
+                lc(cred);   /* let's lowercase them for our convenience */
                 have_serverblob = 0;
                 Done = FALSE;
                 if (Negotiate_packet_debug_enabled) {
@@ -206,14 +206,14 @@ manage_request()
             SEND("BH can't obtain server blob");
         return 1;
     }
-    if (memcmp(buf, "KK ", 3) == 0) {	/* authenticate-request */
+    if (memcmp(buf, "KK ", 3) == 0) {   /* authenticate-request */
         if (!have_serverblob) {
             SEND("BH invalid server blob");
             return 1;
         }
         /* figure out what we got */
         decodedLen = base64_decode(decoded, sizeof(decoded), buf+3);
-        if ((size_t)decodedLen < sizeof(ntlmhdr)) {		/* decoding failure, return error */
+        if ((size_t)decodedLen < sizeof(ntlmhdr)) {     /* decoding failure, return error */
             SEND("NA * Packet format error, couldn't base64-decode");
             return 1;
         }
@@ -225,7 +225,7 @@ manage_request()
                           FORMAT_MESSAGE_IGNORE_INSERTS,
                           NULL,
                           GetLastError(),
-                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),	/* Default language */
+                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),    /* Default language */
                           (LPTSTR) & ErrorMessage,
                           0,
                           NULL);
@@ -238,7 +238,7 @@ manage_request()
             return 1;
         }
         if (Done) {
-            lc(cred);		/* let's lowercase them for our convenience */
+            lc(cred);       /* let's lowercase them for our convenience */
             have_serverblob = 0;
             Done = FALSE;
             if (Negotiate_packet_debug_enabled) {
@@ -264,7 +264,7 @@ manage_request()
             return 1;
         }
 
-    } else {			/* not an auth-request */
+    } else {            /* not an auth-request */
         SEND("BH illegal request received");
         fprintf(stderr, "Illegal request received: '%s'\n", buf);
         return 1;
@@ -300,3 +300,4 @@ main(int argc, char *argv[])
     }
     exit(0);
 }
+
@@ -161,3 +161,4 @@ char *get_ad_groups(char *ad_groups, krb5_context context, krb5_pac pac);
 #else
 #define HAVE_PAC_SUPPORT 0
 #endif
+
@@ -392,12 +392,12 @@ main(int argc, char *const argv[])
             struct stat fstat;
             char *ktp;
 #endif
-	    if (optarg)
+            if (optarg)
                 keytab_name = xstrdup(optarg);
-	    else {
+            else {
                 fprintf(stderr, "ERROR: keytab file not given\n");
-		exit(1);
-	    }
+                exit(1);
+            }
             /*
              * Some sanity checks
              */
@@ -428,12 +428,12 @@ main(int argc, char *const argv[])
 #if HAVE_SYS_STAT_H
             struct stat dstat;
 #endif
-	    if (optarg)
+            if (optarg)
                 rcache_dir = xstrdup(optarg);
-	    else {
+            else {
                 fprintf(stderr, "ERROR: replay cache directory not given\n");
-		exit(1);
-	    }
+                exit(1);
+            }
             /*
              * Some sanity checks
              */
@@ -457,20 +457,20 @@ main(int argc, char *const argv[])
 #endif
             break;
         case 't':
-	    if (optarg)
+            if (optarg)
                 rcache_type = xstrdup(optarg);
-	    else {
+            else {
                 fprintf(stderr, "ERROR: replay cache type not given\n");
-		exit(1);
-	    }
+                exit(1);
+            }
             break;
         case 's':
-	    if (optarg)
+            if (optarg)
                 service_principal = xstrdup(optarg);
-	    else {
+            else {
                 fprintf(stderr, "ERROR: service principal not given\n");
-		exit(1);
-	    }
+                exit(1);
+            }
             break;
         default:
             fprintf(stderr, "Usage: \n");
@@ -589,7 +589,7 @@ main(int argc, char *const argv[])
                       strerror(ferror(stdin)));
 
                 fprintf(stdout, "BH input error\n");
-                exit(1);	/* BIIG buffer */
+                exit(1);    /* BIIG buffer */
             }
             fprintf(stdout, "BH input error\n");
             exit(0);
@@ -871,3 +871,4 @@ main(int argc, char *const argv[])
     }
 }
 #endif /* HAVE_GSSAPI */
+
@@ -251,3 +251,4 @@ main(int argc, char *argv[])
 }
 
 #endif /* HAVE_GSSAPI */
+
@@ -462,3 +462,4 @@ get_ad_groups(char *ad_groups, krb5_context context, krb5_pac pac)
     return NULL;
 }
 #endif
+
@@ -401,3 +401,4 @@ main(int argc, char *const argv[])
 
     return 1;
 }
+
@@ -107,8 +107,8 @@ int
 Valid_Group(char *UserName, char *Group)
 {
     int result = FALSE;
-    WCHAR wszUserName[UNLEN+1];	// Unicode user name
-    WCHAR wszGroup[GNLEN+1];	// Unicode Group
+    WCHAR wszUserName[UNLEN+1]; // Unicode user name
+    WCHAR wszGroup[GNLEN+1];    // Unicode Group
 
     LPLOCALGROUP_USERS_INFO_0 pBuf = NULL;
     LPLOCALGROUP_USERS_INFO_0 pTmpBuf;
@@ -290,7 +290,7 @@ ntlm_check_auth(ntlm_authenticate * auth, char *user, char *domain, int auth_len
 {
     int x;
     int rv;
-    char credentials[DNLEN+UNLEN+2];	/* we can afford to waste */
+    char credentials[DNLEN+UNLEN+2];    /* we can afford to waste */
 
     if (!NTLM_LocalCall) {
 
@@ -320,7 +320,7 @@ ntlm_check_auth(ntlm_authenticate * auth, char *user, char *domain, int auth_len
 
     debug("Login attempt had result %d\n", rv);
 
-    if (!rv) {			/* failed */
+    if (!rv) {          /* failed */
         return NTLM_SSPI_ERROR;
     }
 
@@ -402,7 +402,7 @@ process_options(int argc, char *argv[])
             exit(0);
         case '?':
             opt = optopt;
-            /* fall thru to default */
+        /* fall thru to default */
         default:
             fprintf(stderr, "unknown option: -%c. Exiting\n", opt);
             usage();
@@ -430,7 +430,7 @@ manage_request()
     /* NP: for some reason this helper sometimes needs to accept
      * from clients that send no negotiate packet. */
     if (memcpy(local_nego.hdr.signature, "NTLMSSP", 8) != 0) {
-        memset(&local_nego, 0, sizeof(ntlm_negotiate));	/* reset */
+        memset(&local_nego, 0, sizeof(ntlm_negotiate)); /* reset */
         memcpy(local_nego.hdr.signature, "NTLMSSP", 8);     /* set the signature */
         local_nego.hdr.type = le32toh(NTLM_NEGOTIATE);      /* this is a challenge */
         local_nego.flags = le32toh(NTLM_NEGOTIATE_ALWAYS_SIGN |
@@ -465,7 +465,7 @@ manage_request()
         hex_dump(reinterpret_cast<unsigned char*>(decoded), decodedLen);
     } else
         debug("Got '%s' from Squid\n", buf);
-    if (memcmp(buf, "YR", 2) == 0) {	/* refresh-request */
+    if (memcmp(buf, "YR", 2) == 0) {    /* refresh-request */
         /* figure out what we got */
         if (strlen(buf) > 3)
             decodedLen = base64_decode(decoded, sizeof(decoded), buf+3);
@@ -474,7 +474,7 @@ manage_request()
             memcpy(decoded, &local_nego, sizeof(local_nego));
             decodedLen = sizeof(local_nego);
         }
-        if ((size_t)decodedLen < sizeof(ntlmhdr)) {		/* decoding failure, return error */
+        if ((size_t)decodedLen < sizeof(ntlmhdr)) {     /* decoding failure, return error */
             SEND_ERR("message=\"Packet format error, couldn't base64-decode\"");
             return 1;
         }
@@ -511,26 +511,26 @@ manage_request()
         case NTLM_CHALLENGE:
             SEND_ERR("message=\"Got a challenge. We refuse to have our authority disputed\"");
             return 1;
-            /* notreached */
+        /* notreached */
         case NTLM_AUTHENTICATE:
             SEND_ERR("message=\"Got authentication request instead of negotiate request\"");
             return 1;
-            /* notreached */
+        /* notreached */
         default:
             helperfail("message=\"unknown refresh-request packet type\"");
             return 1;
         }
         return 1;
     }
-    if (memcmp(buf, "KK ", 3) == 0) {	/* authenticate-request */
+    if (memcmp(buf, "KK ", 3) == 0) {   /* authenticate-request */
         if (!have_challenge) {
             helperfail("message=\"invalid challenge\"");
             return 1;
         }
         /* figure out what we got */
         decodedLen = base64_decode(decoded, sizeof(decoded), buf+3);
 
-        if ((size_t)decodedLen < sizeof(ntlmhdr)) {		/* decoding failure, return error */
+        if ((size_t)decodedLen < sizeof(ntlmhdr)) {     /* decoding failure, return error */
             SEND_ERR("message=\"Packet format error, couldn't base64-decode\"");
             return 1;
         }
@@ -546,11 +546,11 @@ manage_request()
         case NTLM_NEGOTIATE:
             SEND_ERR("message=\"Invalid negotiation request received\"");
             return 1;
-            /* notreached */
+        /* notreached */
         case NTLM_CHALLENGE:
             SEND_ERR("message=\"Got a challenge. We refuse to have our authority disputed\"");
             return 1;
-            /* notreached */
+        /* notreached */
         case NTLM_AUTHENTICATE: {
             /* check against SSPI */
             int err = ntlm_check_auth((ntlm_authenticate *) decoded, user, domain, decodedLen);
@@ -602,7 +602,7 @@ manage_request()
             return 1;
         }
         return 1;
-    } else {	/* not an auth-request */
+    } else {    /* not an auth-request */
         helperfail("message=\"illegal request received\"");
         fprintf(stderr, "Illegal request received: '%s'\n", buf);
         return 1;
@@ -638,3 +638,4 @@ main(int argc, char *argv[])
     }
     exit(0);
 }
+
@@ -115,7 +115,7 @@ process_options(int argc, char *argv[])
             exit(0);
         case '?':
             opt = optopt;
-            /* fall thru to default */
+        /* fall thru to default */
         default:
             fprintf(stderr, "unknown option: -%c. Exiting\n", opt);
             usage();
@@ -150,11 +150,11 @@ main(int argc, char *argv[])
     debug("%s build " __DATE__ ", " __TIME__ " starting up...\n", my_program_name);
 
     while (fgets(buf, HELPER_INPUT_BUFFER, stdin) != NULL) {
-        user[0] = '\0';		/*no user code */
-        domain[0] = '\0';		/*no domain code */
+        user[0] = '\0';     /*no user code */
+        domain[0] = '\0';       /*no domain code */
 
         if ((p = strchr(buf, '\n')) != NULL)
-            *p = '\0';		/* strip \n */
+            *p = '\0';      /* strip \n */
         buflen = strlen(buf);   /* keep this so we only scan the buffer for \0 once per loop */
         if (buflen > 3) {
             decodedLen = base64_decode(decodedBuf, sizeof(decodedBuf), buf+3);
@@ -214,3 +214,4 @@ main(int argc, char *argv[])
     }
     exit(0);
 }
+
@@ -73,7 +73,7 @@ typedef struct _dc dc;
 struct _dc {
     char *domain;
     char *controller;
-    time_t dead;		/* 0 if it's alive, otherwise time of death */
+    time_t dead;        /* 0 if it's alive, otherwise time of death */
     dc *next;
 };
 
@@ -90,10 +90,10 @@ void manage_request(void);
 
 static unsigned char challenge[NTLM_NONCE_LEN];
 static unsigned char lmencoded_empty_pass[ENCODED_PASS_LEN],
-ntencoded_empty_pass[ENCODED_PASS_LEN];
+       ntencoded_empty_pass[ENCODED_PASS_LEN];
 SMB_Handle_Type handle = NULL;
 int ntlm_errno;
-static char credentials[MAX_USERNAME_LEN+MAX_DOMAIN_LEN+2];	/* we can afford to waste */
+static char credentials[MAX_USERNAME_LEN+MAX_DOMAIN_LEN+2]; /* we can afford to waste */
 static char my_domain[100], my_domain_controller[100];
 static char errstr[1001];
 #if DEBUG
@@ -146,17 +146,17 @@ init_challenge(char *domain, char *domain_controller)
     smberr = SMB_Get_Last_Error();
     SMB_Get_Error_Msg(smberr, errstr, 1000);
 
-    if (handle == NULL) {	/* couldn't connect */
+    if (handle == NULL) {   /* couldn't connect */
         debug("Couldn't connect to SMB Server. Error:%s\n", errstr);
         return 1;
     }
-    if (SMB_Negotiate(handle, SMB_Prots) < 0) {		/* An error */
+    if (SMB_Negotiate(handle, SMB_Prots) < 0) {     /* An error */
         debug("Error negotiating protocol with SMB Server\n");
         SMB_Discon(handle, 0);
         handle = NULL;
         return 2;
     }
-    if (handle->Security == 0) {	/* share-level security, unuseable */
+    if (handle->Security == 0) {    /* share-level security, unuseable */
         debug("SMB Server uses share-level security .. we need user security.\n");
         SMB_Discon(handle, 0);
         handle = NULL;
@@ -208,7 +208,7 @@ ntlm_check_auth(ntlm_authenticate * auth, int auth_length)
     char *user;
     lstring tmp;
 
-    if (handle == NULL) {	/*if null we aren't connected, but it shouldn't happen */
+    if (handle == NULL) {   /*if null we aren't connected, but it shouldn't happen */
         debug("Weird, we've been disconnected\n");
         ntlm_errno = NTLM_ERR_NOT_CONNECTED;
         return NULL;
@@ -291,11 +291,11 @@ ntlm_check_auth(ntlm_authenticate * auth, int auth_length)
     rv = SMB_Logon_Server(handle, user, pass, domain, 1);
     debug("Login attempt had result %d\n", rv);
 
-    if (rv != NTLM_ERR_NONE) {	/* failed */
+    if (rv != NTLM_ERR_NONE) {  /* failed */
         ntlm_errno = rv;
         return NULL;
     }
-    *(user - 1) = '\\';		/* hack. Performing, but ugly. */
+    *(user - 1) = '\\';     /* hack. Performing, but ugly. */
 
     debug("credentials: %s\n", credentials);
     return credentials;
@@ -398,11 +398,11 @@ process_options(int argc, char *argv[])
         new_dc->domain = d;
         new_dc->controller = c;
         new_dc->dead = 0;
-        if (controllers == NULL) {	/* first controller */
+        if (controllers == NULL) {  /* first controller */
             controllers = new_dc;
             last_dc = new_dc;
         } else {
-            last_dc->next = new_dc;	/* can't be null */
+            last_dc->next = new_dc; /* can't be null */
             last_dc = new_dc;
         }
     }
@@ -411,7 +411,7 @@ process_options(int argc, char *argv[])
         usage();
         exit(1);
     }
-    last_dc->next = controllers;	/* close the queue, now it's circular */
+    last_dc->next = controllers;    /* close the queue, now it's circular */
 }
 
 /**
@@ -431,7 +431,7 @@ obtain_challenge()
                 /* mark helper as retry-worthy if it's so. */
                 debug("Reviving DC\n");
                 current_dc->dead = 0;
-            } else {		/* skip it */
+            } else {        /* skip it */
                 debug("Skipping it\n");
                 continue;
             }
@@ -442,7 +442,7 @@ obtain_challenge()
         debug("make_challenge retuned %p\n", ch);
         if (ch) {
             debug("Got it\n");
-            return ch;		/* All went OK, returning */
+            return ch;      /* All went OK, returning */
         }
         /* Huston, we've got a problem. Take this DC out of the loop */
         debug("Marking DC as DEAD\n");
@@ -467,21 +467,21 @@ manage_request()
     if (fgets(buf, NTLM_BLOB_BUFFER_SIZE, stdin) == NULL) {
         fprintf(stderr, "fgets() failed! dying..... errno=%d (%s)\n", errno,
                 strerror(errno));
-        exit(1);		/* BIIG buffer */
+        exit(1);        /* BIIG buffer */
     }
     debug("managing request\n");
-    ch2 = (char*)memchr(buf, '\n', NTLM_BLOB_BUFFER_SIZE);	/* safer against overrun than strchr */
+    ch2 = (char*)memchr(buf, '\n', NTLM_BLOB_BUFFER_SIZE);  /* safer against overrun than strchr */
     if (ch2) {
-        *ch2 = '\0';		/* terminate the string at newline. */
+        *ch2 = '\0';        /* terminate the string at newline. */
         ch = ch2;
     }
     debug("ntlm authenticator. Got '%s' from Squid\n", buf);
 
-    if (memcmp(buf, "KK ", 3) == 0) {	/* authenticate-request */
+    if (memcmp(buf, "KK ", 3) == 0) {   /* authenticate-request */
         /* figure out what we got */
         int decodedLen = base64_decode(decoded, sizeof(decoded), buf+3);
 
-        if ((size_t)decodedLen < sizeof(ntlmhdr)) {	/* decoding failure, return error */
+        if ((size_t)decodedLen < sizeof(ntlmhdr)) { /* decoding failure, return error */
             SEND("NA Packet format error, couldn't base64-decode");
             return;
         }
@@ -497,11 +497,11 @@ manage_request()
         case NTLM_NEGOTIATE:
             SEND("NA Invalid negotiation request received");
             return;
-            /* notreached */
+        /* notreached */
         case NTLM_CHALLENGE:
             SEND("NA Got a challenge. We refuse to have our authority disputed");
             return;
-            /* notreached */
+        /* notreached */
         case NTLM_AUTHENTICATE:
             /* check against the DC */
             signal(SIGALRM, timeout_during_auth);
@@ -517,7 +517,7 @@ manage_request()
             }
             if (cred == NULL) {
                 int smblib_err, smb_errorclass, smb_errorcode, nb_error;
-                if (ntlm_errno == NTLM_ERR_LOGON) {	/* hackish */
+                if (ntlm_errno == NTLM_ERR_LOGON) { /* hackish */
                     SEND("NA Logon Failure");
                     return;
                 }
@@ -533,7 +533,7 @@ manage_request()
                       smblib_err, smb_errorclass, smb_errorcode, nb_error);
                 /* Should I use smblib_err? Actually it seems I can do as well
                  * without it.. */
-                if (nb_error != 0) {	/* netbios-level error */
+                if (nb_error != 0) {    /* netbios-level error */
                     SEND("BH NetBios error!");
                     fprintf(stderr, "NetBios error code %d (%s)\n", nb_error,
                             RFCNB_Error_Strings[abs(nb_error)]);
@@ -548,9 +548,9 @@ manage_request()
                     /*this is the most important one for errors */
                     debug("DOS error\n");
                     switch (smb_errorcode) {
-                        /* two categories matter to us: those which could be
-                         * server errors, and those which are auth errors */
-                    case SMBD_noaccess:	/* 5 */
+                    /* two categories matter to us: those which could be
+                     * server errors, and those which are auth errors */
+                    case SMBD_noaccess: /* 5 */
                         SEND("NA Access denied");
                         return;
                     case SMBD_badformat:
@@ -566,10 +566,10 @@ manage_request()
                         SEND("BH DOS Error");
                         return;
                     }
-                case SMBC_ERRSRV:	/* server errors */
+                case SMBC_ERRSRV:   /* server errors */
                     debug("Server error");
                     switch (smb_errorcode) {
-                        /* mostly same as above */
+                    /* mostly same as above */
                     case SMBV_badpw:
                         SEND("NA Bad password");
                         return;
@@ -580,7 +580,7 @@ manage_request()
                         SEND("BH Server Error");
                         return;
                     }
-                case SMBC_ERRHRD:	/* hardware errors don't really matter */
+                case SMBC_ERRHRD:   /* hardware errors don't really matter */
                     SEND("BH Domain Controller Hardware error");
                     return;
                 case SMBC_ERRCMD:
@@ -591,7 +591,7 @@ manage_request()
                 return;
             }
 
-            lc(cred);		/* let's lowercase them for our convenience */
+            lc(cred);       /* let's lowercase them for our convenience */
             SEND2("AF %s", cred);
             return;
         default:
@@ -601,7 +601,7 @@ manage_request()
         /* notreached */
         return;
     }
-    if (memcmp(buf, "YR", 2) == 0) {	/* refresh-request */
+    if (memcmp(buf, "YR", 2) == 0) {    /* refresh-request */
         dc_disconnect();
         ch = obtain_challenge();
         /* Robert says we can afford to wait forever. I'll trust him on this
@@ -651,3 +651,4 @@ main(int argc, char *argv[])
     /* notreached */
     return 0;
 }
+
@@ -107,3 +107,4 @@ main()
 
     return 0;
 }
+
@@ -80,7 +80,7 @@ process_options(int argc, char *argv[])
             exit(0);
         case '?':
             opt = optopt;
-            /* fall thru to default */
+        /* fall thru to default */
         default:
             fprintf(stderr, "unknown option: -%c. Exiting\n", opt);
             usage();
@@ -110,7 +110,7 @@ main(int argc, char *argv[])
         char *p;
 
         if ((p = strchr(buf, '\n')) != NULL) {
-            *p = '\0';		/* strip \n */
+            *p = '\0';      /* strip \n */
             buflen = p - buf;   /* length is known already */
         } else
             buflen = strlen(buf);   /* keep this so we only scan the buffer for \0 once per loop */
@@ -130,3 +130,4 @@ main(int argc, char *argv[])
     debug("%s build " __DATE__ ", " __TIME__ " shutting down...\n", my_program_name);
     return 0;
 }
+
@@ -56,3 +56,4 @@ Range<C, S>::size() const
 }
 
 #endif /* SQUID_RANGE_H */
+
@@ -38,3 +38,4 @@ _SQUID_EXTERNNEW_ void operator delete[] (void *address) throw()
 #endif /* !__SUNPRO_CC && !__clang__*/
 
 #endif /* SQUID_NEW_H */
+
@@ -46,63 +46,64 @@ typedef u_char oid;
 #define MAX_SUBID   0xFF
 #endif
 
-#define MAX_OID_LEN	    128	/* max subid's in an oid, per SNMP spec. */
-
-#define ASN_BOOLEAN	    (0x01)
-#define ASN_INTEGER	    (0x02)
-#define ASN_BIT_STR	    (0x03)
-#define ASN_OCTET_STR	    (0x04)
-#define ASN_NULL	    (0x05)
-#define ASN_OBJECT_ID	    (0x06)
-#define ASN_SEQUENCE	    (0x10)
-#define ASN_SET		    (0x11)
-
-#define ASN_UNIVERSAL	    (0x00)
+#define MAX_OID_LEN     128 /* max subid's in an oid, per SNMP spec. */
+
+#define ASN_BOOLEAN     (0x01)
+#define ASN_INTEGER     (0x02)
+#define ASN_BIT_STR     (0x03)
+#define ASN_OCTET_STR       (0x04)
+#define ASN_NULL        (0x05)
+#define ASN_OBJECT_ID       (0x06)
+#define ASN_SEQUENCE        (0x10)
+#define ASN_SET         (0x11)
+
+#define ASN_UNIVERSAL       (0x00)
 #define ASN_APPLICATION     (0x40)
-#define ASN_CONTEXT	    (0x80)
-#define ASN_PRIVATE	    (0xC0)
+#define ASN_CONTEXT     (0x80)
+#define ASN_PRIVATE     (0xC0)
 
-#define ASN_PRIMITIVE	    (0x00)
-#define ASN_CONSTRUCTOR	    (0x20)
+#define ASN_PRIMITIVE       (0x00)
+#define ASN_CONSTRUCTOR     (0x20)
 
-#define ASN_LONG_LEN	    (0x80)
+#define ASN_LONG_LEN        (0x80)
 #define ASN_EXTENSION_ID    (0x1F)
-#define ASN_BIT8	    (0x80)
+#define ASN_BIT8        (0x80)
 
-#define IS_CONSTRUCTOR(byte)	((byte) & ASN_CONSTRUCTOR)
-#define IS_EXTENSION_ID(byte)	(((byte) & ASN_EXTENSION_ID) == ASN_EXTENSION_ID)
+#define IS_CONSTRUCTOR(byte)    ((byte) & ASN_CONSTRUCTOR)
+#define IS_EXTENSION_ID(byte)   (((byte) & ASN_EXTENSION_ID) == ASN_EXTENSION_ID)
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-    u_char *asn_build_header(u_char *, int *, u_char, int);
-    u_char *asn_parse_int(u_char *, int *, u_char *, int *, int);
-    u_char *asn_parse_unsigned_int(u_char *, int *, u_char *, u_int *, int);
-    u_char *asn_build_int(u_char *, int *, u_char, int *, int);
-    u_char *asn_build_unsigned_int(u_char *, int *, u_char, u_int *, int);
-    u_char *asn_parse_string(u_char *, int *, u_char *, u_char *, int *);
-    u_char *asn_build_string(u_char *, int *, u_char, u_char *, int);
-    u_char *asn_parse_header(u_char *, int *, u_char *);
-    u_char *asn_build_header_with_truth(u_char *, int *, u_char, int, int);
-
-    u_char *asn_parse_length(u_char *, u_int *);
-    u_char *asn_build_length(u_char *, int *, int, int);
-    u_char *asn_parse_objid(u_char *, int *, u_char *, oid *, int *);
-    u_char *asn_build_objid(u_char *, int *, u_char, oid *, int);
-    u_char *asn_parse_null(u_char *, int *, u_char *);
-    u_char *asn_build_null(u_char *, int *, u_char);
+u_char *asn_build_header(u_char *, int *, u_char, int);
+u_char *asn_parse_int(u_char *, int *, u_char *, int *, int);
+u_char *asn_parse_unsigned_int(u_char *, int *, u_char *, u_int *, int);
+u_char *asn_build_int(u_char *, int *, u_char, int *, int);
+u_char *asn_build_unsigned_int(u_char *, int *, u_char, u_int *, int);
+u_char *asn_parse_string(u_char *, int *, u_char *, u_char *, int *);
+u_char *asn_build_string(u_char *, int *, u_char, u_char *, int);
+u_char *asn_parse_header(u_char *, int *, u_char *);
+u_char *asn_build_header_with_truth(u_char *, int *, u_char, int, int);
+
+u_char *asn_parse_length(u_char *, u_int *);
+u_char *asn_build_length(u_char *, int *, int, int);
+u_char *asn_parse_objid(u_char *, int *, u_char *, oid *, int *);
+u_char *asn_build_objid(u_char *, int *, u_char, oid *, int);
+u_char *asn_parse_null(u_char *, int *, u_char *);
+u_char *asn_build_null(u_char *, int *, u_char);
 
 #if 0
-    u_char *asn_parse_bitstring(u_char *, int *, u_char *, u_char *, int *);
-    u_char *asn_build_bitstring(u_char *, int *, u_char, u_char *, int);
+u_char *asn_parse_bitstring(u_char *, int *, u_char *, u_char *, int *);
+u_char *asn_build_bitstring(u_char *, int *, u_char, u_char *, int);
 
 #endif
-    u_char *asn_build_exception(u_char *, int *, u_char);
+u_char *asn_build_exception(u_char *, int *, u_char);
 
 #ifdef __cplusplus
 }
 
 #endif
 
-#endif	/* SQUID_SNMP_ASN1_H */
+#endif  /* SQUID_SNMP_ASN1_H */
+
@@ -13,47 +13,48 @@
 extern "C" {
 #endif
 
-    // Decoding functions
-
-    /// Calculate the decoded length of a given nul-terminated encoded string.
-    /// NULL pointer and empty strings are accepted, result is zero.
-    /// Any return value <= zero means no decoded result can be produced.
-    extern int base64_decode_len(const char *encodedData);
-
-    /// Decode a base-64 encoded blob into a provided buffer.
-    /// Will not terminate the resulting string.
-    /// In-place decoding overlap is supported if result is equal or earlier that the source pointer.
-    ///
-    /// \return number of bytes filled in result.
-    extern int base64_decode(char *result, unsigned int result_max_size, const char *encoded);
-
-    // Encoding functions
-
-    /// Calculate the buffer size required to hold the encoded form of
-    /// a string of length 'decodedLen' including all terminator bytes.
-    extern int base64_encode_len(int decodedLen);
-
-    /// Base-64 encode a string into a given buffer.
-    /// Will not terminate the resulting string.
-    /// \return the number of bytes filled in result.
-    extern int base64_encode(char *result, int result_max_size, const char *data, int data_size);
-
-    /// Base-64 encode a string into a given buffer.
-    /// Will terminate the resulting string.
-    /// \return the number of bytes filled in result. Including the terminator.
-    extern int base64_encode_str(char *result, int result_max_size, const char *data, int data_size);
-
-    // Old encoder. Now a wrapper for the new. Takes a binary array of known length.
-    // Output is presented in a static buffer which will only remain valid until next call.
-    // Ensures a nul-terminated result. Will always return non-NULL.
-    extern const char *base64_encode_bin(const char *data, int len);
-
-    // Old encoder. Now a wrapper for the new.
-    // Output is presented in a static buffer which will only remain valid until next call.
-    // Ensures a nul-terminated result. Will always return non-NULL.
-    extern const char *old_base64_encode(const char *decoded);
+// Decoding functions
+
+/// Calculate the decoded length of a given nul-terminated encoded string.
+/// NULL pointer and empty strings are accepted, result is zero.
+/// Any return value <= zero means no decoded result can be produced.
+extern int base64_decode_len(const char *encodedData);
+
+/// Decode a base-64 encoded blob into a provided buffer.
+/// Will not terminate the resulting string.
+/// In-place decoding overlap is supported if result is equal or earlier that the source pointer.
+///
+/// \return number of bytes filled in result.
+extern int base64_decode(char *result, unsigned int result_max_size, const char *encoded);
+
+// Encoding functions
+
+/// Calculate the buffer size required to hold the encoded form of
+/// a string of length 'decodedLen' including all terminator bytes.
+extern int base64_encode_len(int decodedLen);
+
+/// Base-64 encode a string into a given buffer.
+/// Will not terminate the resulting string.
+/// \return the number of bytes filled in result.
+extern int base64_encode(char *result, int result_max_size, const char *data, int data_size);
+
+/// Base-64 encode a string into a given buffer.
+/// Will terminate the resulting string.
+/// \return the number of bytes filled in result. Including the terminator.
+extern int base64_encode_str(char *result, int result_max_size, const char *data, int data_size);
+
+// Old encoder. Now a wrapper for the new. Takes a binary array of known length.
+// Output is presented in a static buffer which will only remain valid until next call.
+// Ensures a nul-terminated result. Will always return non-NULL.
+extern const char *base64_encode_bin(const char *data, int len);
+
+// Old encoder. Now a wrapper for the new.
+// Output is presented in a static buffer which will only remain valid until next call.
+// Ensures a nul-terminated result. Will always return non-NULL.
+extern const char *old_base64_encode(const char *decoded);
 
 #ifdef __cplusplus
 }
 #endif
 #endif /* _SQUID_BASE64_H */
+
@@ -270,3 +270,4 @@ enum {
 #endif /* SQUID_SNMP */
 
 #endif /* SQUID_CACHE_SNMP_H */
+
@@ -18,3 +18,4 @@ extern
 char *latin1_to_utf8(char *out, size_t size, const char *in);
 
 #endif /* _SQUID_CHARSET_H */
+
@@ -12,3 +12,4 @@
 SQUIDCEXTERN const char *getfullhostname(void);
 
 #endif /* _SQUID_GETFULLHOSTNAME_H */
+
@@ -62,6 +62,7 @@ SQUIDCEXTERN const char *hashKeyStr(hash_link *);
  *  HASH_SIZE 33493             // prime number < 32768
  *  HASH_SIZE 65357             // prime number < 65536
  */
-#define  DEFAULT_HASH_SIZE 7951	/* prime number < 8192 */
+#define  DEFAULT_HASH_SIZE 7951 /* prime number < 8192 */
 
 #endif /* SQUID_HASH_H */
+
@@ -19,8 +19,8 @@
  * the top of the heap (as in the smallest object key value).  Child nodes
  * are larger than their parent.
  ****************************************************************************/
-#ifndef	SQUID_HEAP_H
-#define	SQUID_HEAP_H
+#ifndef SQUID_HEAP_H
+#define SQUID_HEAP_H
 
 /*
  * Function for generating heap keys.  The first argument will typically be
@@ -53,8 +53,8 @@ typedef struct _heap {
     heap_mutex_t lock;
     unsigned long size;
     unsigned long last;
-    heap_key_func *gen_key;	/* key generator for heap */
-    heap_key age;		/* aging factor for heap */
+    heap_key_func *gen_key; /* key generator for heap */
+    heap_key age;       /* aging factor for heap */
     heap_node **nodes;
 } heap;
 
@@ -99,10 +99,10 @@ SQUIDCEXTERN heap_t heap_update(heap *, heap_node * elm, heap_t dat);
 /*
  * Generate a heap key for a given data object.  Alternative macro form:
  */
-#ifdef	MACRO_DEBUG
+#ifdef  MACRO_DEBUG
 SQUIDCEXTERN heap_key heap_gen_key(heap * hp, heap_t dat);
 #else
-#define	heap_gen_key(hp,md)	((hp)->gen_key((md),(hp)->age))
+#define heap_gen_key(hp,md) ((hp)->gen_key((md),(hp)->age))
 #endif /* MACRO_DEBUG */
 
 /*
@@ -134,12 +134,12 @@ SQUIDCEXTERN heap_t heap_peep(heap *, int n);
 /*
  * Is the heap empty?  How many nodes (data objects) are in it?
  */
-#ifdef	MACRO_DEBUG
+#ifdef  MACRO_DEBUG
 SQUIDCEXTERN int heap_empty(heap *);
 SQUIDCEXTERN int heap_nodes(heap *);
 #else /* MACRO_DEBUG */
-#define	heap_nodes(heap)	((heap)->last)
-#define	heap_empty(heap)	((heap)->last <= 0 ? 1 : 0)
+#define heap_nodes(heap)    ((heap)->last)
+#define heap_empty(heap)    ((heap)->last <= 0 ? 1 : 0)
 #endif /* MACRO_DEBUG */
 
 /*
@@ -151,3 +151,4 @@ SQUIDCEXTERN void heap_printnode(char *msg, heap_node * elm);
 SQUIDCEXTERN int verify_heap_property(heap *);
 
 #endif /* SQUID_HEAP_H */
+
@@ -18,3 +18,4 @@ extern
 char *html_quote(const char *);
 
 #endif /* _SQUID_HTML_QUOTE_H */
+
@@ -19,3 +19,4 @@
 #endif
 
 #endif
+
@@ -68,3 +68,4 @@ SQUIDCEXTERN void SquidMD5Transform(uint32_t buf[4], uint32_t const in[16]);
 #endif /* HAVE_NETTLE_MD5_H */
 
 #endif /* SQUID_MD5_H */
+
@@ -27,3 +27,4 @@ class MemMeter
 #define memMeterDel(m, sz) { (m).level -= (sz); }
 
 #endif /* _MEM_METER_H_ */
+
@@ -10,7 +10,7 @@
 #define SQUID_PARSE_H
 
 /***********************************************************
-	Copyright 1989 by Carnegie Mellon University
+    Copyright 1989 by Carnegie Mellon University
 
                       All Rights Reserved
 
@@ -48,52 +48,53 @@ struct enum_list {
  * A tree in the format of the tree structure of the MIB.
  */
 struct snmp_mib_tree {
-    struct snmp_mib_tree *child_list;	/* list of children of this node */
-    struct snmp_mib_tree *next_peer;	/* Next node in list of peers */
+    struct snmp_mib_tree *child_list;   /* list of children of this node */
+    struct snmp_mib_tree *next_peer;    /* Next node in list of peers */
     struct snmp_mib_tree *parent;
-    char label[64];		/* This node's textual name */
-    u_int subid;		/* This node's integer subidentifier */
-    int type;			/* This node's object type */
-    struct enum_list *enums;	/* (optional) list of enumerated integers (otherwise NULL) */
-    void (*printer) (char *buf, variable_list *var, void *foo, int quiet);		/* Value printing function */
+    char label[64];     /* This node's textual name */
+    u_int subid;        /* This node's integer subidentifier */
+    int type;           /* This node's object type */
+    struct enum_list *enums;    /* (optional) list of enumerated integers (otherwise NULL) */
+    void (*printer) (char *buf, variable_list *var, void *foo, int quiet);      /* Value printing function */
 };
 
 /* non-aggregate types for tree end nodes */
-#define TYPE_OTHER	    0
-#define TYPE_OBJID	    1
-#define TYPE_OCTETSTR	    2
-#define TYPE_INTEGER	    3
-#define TYPE_NETADDR	    4
-#define	TYPE_IPADDR	    5
-#define TYPE_COUNTER	    6
-#define TYPE_GAUGE	    7
-#define TYPE_TIMETICKS	    8
-#define TYPE_OPAQUE	    9
-#define TYPE_NULL	    10
+#define TYPE_OTHER      0
+#define TYPE_OBJID      1
+#define TYPE_OCTETSTR       2
+#define TYPE_INTEGER        3
+#define TYPE_NETADDR        4
+#define TYPE_IPADDR     5
+#define TYPE_COUNTER        6
+#define TYPE_GAUGE      7
+#define TYPE_TIMETICKS      8
+#define TYPE_OPAQUE     9
+#define TYPE_NULL       10
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-    void init_mib(char *);
-    int read_objid(char *, oid *, int *);
-    void print_objid(oid *, int);
-    void sprint_objid(char *, oid *, int);
-    void print_variable(oid *, int, struct variable_list *);
-    void sprint_variable(char *, oid *, int, struct variable_list *);
-    void sprint_value(char *, oid *, int, struct variable_list *);
-    void print_value(oid *, int, struct variable_list *);
+void init_mib(char *);
+int read_objid(char *, oid *, int *);
+void print_objid(oid *, int);
+void sprint_objid(char *, oid *, int);
+void print_variable(oid *, int, struct variable_list *);
+void sprint_variable(char *, oid *, int, struct variable_list *);
+void sprint_value(char *, oid *, int, struct variable_list *);
+void print_value(oid *, int, struct variable_list *);
 
-    /*void print_variable_list(struct variable_list *); */
-    /*void print_variable_list_value(struct variable_list *); */
-    /*void print_type(struct variable_list *); */
-    void print_oid_nums(oid *, int);
+/*void print_variable_list(struct variable_list *); */
+/*void print_variable_list_value(struct variable_list *); */
+/*void print_type(struct variable_list *); */
+void print_oid_nums(oid *, int);
 
-    struct snmp_mib_tree *read_mib(char *);
+struct snmp_mib_tree *read_mib(char *);
 
 #ifdef __cplusplus
 }
 
 #endif
 
-#endif				/* SQUID_PARSE_H */
+#endif              /* SQUID_PARSE_H */
+
@@ -7,7 +7,7 @@
  */
 
 #ifndef SQUID_RADIX_H
-#define	SQUID_RADIX_H
+#define SQUID_RADIX_H
 
 /*
  * Copyright (c) 1988, 1989, 1993
@@ -51,31 +51,31 @@
 
 struct squid_radix_node {
 
-    struct squid_radix_mask *rn_mklist;	/* list of masks contained in subtree */
+    struct squid_radix_mask *rn_mklist; /* list of masks contained in subtree */
 
-    struct squid_radix_node *rn_p;	/* parent */
-    short rn_b;			/* bit offset; -1-index(netmask) */
-    char rn_bmask;		/* node: mask for bit test */
-    unsigned char rn_flags;	/* enumerated next */
-#define RNF_NORMAL	1	/* leaf contains normal route */
-#define RNF_ROOT	2	/* leaf is root leaf for tree */
-#define RNF_ACTIVE	4	/* This node is alive (for rtfree) */
+    struct squid_radix_node *rn_p;  /* parent */
+    short rn_b;         /* bit offset; -1-index(netmask) */
+    char rn_bmask;      /* node: mask for bit test */
+    unsigned char rn_flags; /* enumerated next */
+#define RNF_NORMAL  1   /* leaf contains normal route */
+#define RNF_ROOT    2   /* leaf is root leaf for tree */
+#define RNF_ACTIVE  4   /* This node is alive (for rtfree) */
 
     union {
 
-        struct {		/* leaf only data: */
-            char *rn_Key;	/* object of search */
-            char *rn_Mask;	/* netmask, if present */
+        struct {        /* leaf only data: */
+            char *rn_Key;   /* object of search */
+            char *rn_Mask;  /* netmask, if present */
 
             struct squid_radix_node *rn_Dupedkey;
         } rn_leaf;
 
-        struct {		/* node only data: */
-            int rn_Off;		/* where to start compare */
+        struct {        /* node only data: */
+            int rn_Off;     /* where to start compare */
 
-            struct squid_radix_node *rn_L;	/* progeny */
+            struct squid_radix_node *rn_L;  /* progeny */
 
-            struct squid_radix_node *rn_R;	/* progeny */
+            struct squid_radix_node *rn_R;  /* progeny */
         } rn_node;
     } rn_u;
 #ifdef RN_DEBUG
@@ -96,51 +96,51 @@ struct squid_radix_node {
  */
 
 struct squid_radix_mask {
-    short rm_b;			/* bit offset; -1-index(netmask) */
-    char rm_unused;		/* cf. rn_bmask */
-    unsigned char rm_flags;	/* cf. rn_flags */
+    short rm_b;         /* bit offset; -1-index(netmask) */
+    char rm_unused;     /* cf. rn_bmask */
+    unsigned char rm_flags; /* cf. rn_flags */
 
-    struct squid_radix_mask *rm_mklist;	/* more masks to try */
+    struct squid_radix_mask *rm_mklist; /* more masks to try */
     union {
-        char *rmu_mask;		/* the mask */
+        char *rmu_mask;     /* the mask */
 
-        struct squid_radix_node *rmu_leaf;	/* for normal routes */
+        struct squid_radix_node *rmu_leaf;  /* for normal routes */
     } rm_rmu;
-    int rm_refs;		/* # of references to this struct */
+    int rm_refs;        /* # of references to this struct */
 };
 
 struct squid_radix_node_head {
 
     struct squid_radix_node *rnh_treetop;
-    int rnh_addrsize;		/* permit, but not require fixed keys */
-    int rnh_pktsize;		/* permit, but not require fixed keys */
+    int rnh_addrsize;       /* permit, but not require fixed keys */
+    int rnh_pktsize;        /* permit, but not require fixed keys */
 
-    struct squid_radix_node *(*rnh_addaddr)	/* add based on sockaddr */
+    struct squid_radix_node *(*rnh_addaddr) /* add based on sockaddr */
     (void *v, void *mask, struct squid_radix_node_head * head, struct squid_radix_node nodes[]);
 
-    struct squid_radix_node *(*rnh_addpkt)	/* add based on packet hdr */
+    struct squid_radix_node *(*rnh_addpkt)  /* add based on packet hdr */
     (void *v, void *mask, struct squid_radix_node_head * head, struct squid_radix_node nodes[]);
 
-    struct squid_radix_node *(*rnh_deladdr)	/* remove based on sockaddr */
+    struct squid_radix_node *(*rnh_deladdr) /* remove based on sockaddr */
     (void *v, void *mask, struct squid_radix_node_head * head);
 
-    struct squid_radix_node *(*rnh_delpkt)	/* remove based on packet hdr */
+    struct squid_radix_node *(*rnh_delpkt)  /* remove based on packet hdr */
     (void *v, void *mask, struct squid_radix_node_head * head);
 
-    struct squid_radix_node *(*rnh_matchaddr)		/* locate based on sockaddr */
+    struct squid_radix_node *(*rnh_matchaddr)       /* locate based on sockaddr */
     (void *v, struct squid_radix_node_head * head);
 
-    struct squid_radix_node *(*rnh_lookup)	/* locate based on sockaddr */
+    struct squid_radix_node *(*rnh_lookup)  /* locate based on sockaddr */
 
     (void *v, void *mask, struct squid_radix_node_head * head);
 
-    struct squid_radix_node *(*rnh_matchpkt)	/* locate based on packet hdr */
+    struct squid_radix_node *(*rnh_matchpkt)    /* locate based on packet hdr */
     (void *v, struct squid_radix_node_head * head);
 
-    int (*rnh_walktree)		/* traverse tree */
+    int (*rnh_walktree)     /* traverse tree */
     (struct squid_radix_node_head * head, int (*f) (struct squid_radix_node *, void *), void *w);
 
-    struct squid_radix_node rnh_nodes[3];	/* empty tree for common case */
+    struct squid_radix_node rnh_nodes[3];   /* empty tree for common case */
 };
 
 SQUIDCEXTERN void squid_rn_init (void);
@@ -169,3 +169,4 @@ SQUIDCEXTERN struct squid_radix_node *squid_rn_search_m(void *, struct squid_rad
 SQUIDCEXTERN struct squid_radix_node *squid_rn_lookup(void *, void *, struct squid_radix_node_head *);
 
 #endif /* SQUID_RADIX_H */
+
@@ -110,3 +110,4 @@ SQUIDCEXTERN int rfc1035QuestionPack(char *buf,
 SQUIDCEXTERN int rfc1035RRPack(char *buf, size_t sz, const rfc1035_rr * RR);
 
 #endif /* SQUID_RFC1035_H */
+
@@ -13,11 +13,12 @@
 extern "C" {
 #endif
 
-    extern const char *mkhttpdlogtime(const time_t *);
-    extern const char *mkrfc1123(time_t);
-    extern time_t parse_rfc1123(const char *str);
+extern const char *mkhttpdlogtime(const time_t *);
+extern const char *mkrfc1123(time_t);
+extern time_t parse_rfc1123(const char *str);
 
 #ifdef __cplusplus
 }
 #endif
 #endif /* _SQUID_RFC1123_H */
+
@@ -13,58 +13,59 @@
 extern "C" {
 #endif
 
-    /* Encoder rfc1738_do_escape flag values. */
+/* Encoder rfc1738_do_escape flag values. */
 #define RFC1738_ESCAPE_CTRLS       1
 #define RFC1738_ESCAPE_UNSAFE      2
 #define RFC1738_ESCAPE_RESERVED    4
 #define RFC1738_ESCAPE_ALL         (RFC1738_ESCAPE_UNSAFE|RFC1738_ESCAPE_RESERVED|RFC1738_ESCAPE_CTRLS)
-    // exclusions
+// exclusions
 #define RFC1738_ESCAPE_NOSPACE     128
 #define RFC1738_ESCAPE_NOPERCENT   256
-    // Backward compatibility
+// Backward compatibility
 #define RFC1738_ESCAPE_UNESCAPED   (RFC1738_ESCAPE_UNSAFE|RFC1738_ESCAPE_CTRLS|RFC1738_ESCAPE_NOPERCENT)
 
-    /**
-     * \group rfc1738 RFC 1738 URL-escaping library
-     *
-     * Public API is formed of a triplet of encode functions mapping to the rfc1738_do_encode() engine.
-     *
-     * ASCII characters are split into four groups:
-     * \item SAFE     Characters which are safe to occur in any URL. For example A,B,C
-     * \item CTRLS    Binary control codes. Dangerous to include in URLs.
-     * \item UNSAFE   Characters which are completely usafe to occur in any URL. For example; backspace, tab, space, newline.
-     * \item RESERVED Characters which are reserved for special meaning and may only occur in certain parts of a URL.
-     *
-     * Returns a static buffer containing the RFC 1738 compliant, escaped version of the given url.
-     *
-     * \param flags  RFC1738_ESCAPE_CTRLS     Encode the blatantly dangerous binary codes.
-     * \param flags  RFC1738_ESCAPE_UNSAFE    Encode printable unsafe characters (excluding CTRLs).
-     * \param flags  RFC1738_ESCAPE_RESERVED  Encode reserved characters.
-     * \param flags  RFC1738_ESCAPE_ALL       Encode all binary CTRL, unsafe and reserved characters.
-     * \param flags  RFC1738_ESCAPE_NOSPACE   Ignore the space whitespace character.
-     * \param flags  RFC1738_ESCAPE_NOPERCENT Ignore the escaping delimiter '%'.
-     */
-    extern char *rfc1738_do_escape(const char *url, int flags);
+/**
+ * \group rfc1738 RFC 1738 URL-escaping library
+ *
+ * Public API is formed of a triplet of encode functions mapping to the rfc1738_do_encode() engine.
+ *
+ * ASCII characters are split into four groups:
+ * \item SAFE     Characters which are safe to occur in any URL. For example A,B,C
+ * \item CTRLS    Binary control codes. Dangerous to include in URLs.
+ * \item UNSAFE   Characters which are completely usafe to occur in any URL. For example; backspace, tab, space, newline.
+ * \item RESERVED Characters which are reserved for special meaning and may only occur in certain parts of a URL.
+ *
+ * Returns a static buffer containing the RFC 1738 compliant, escaped version of the given url.
+ *
+ * \param flags  RFC1738_ESCAPE_CTRLS     Encode the blatantly dangerous binary codes.
+ * \param flags  RFC1738_ESCAPE_UNSAFE    Encode printable unsafe characters (excluding CTRLs).
+ * \param flags  RFC1738_ESCAPE_RESERVED  Encode reserved characters.
+ * \param flags  RFC1738_ESCAPE_ALL       Encode all binary CTRL, unsafe and reserved characters.
+ * \param flags  RFC1738_ESCAPE_NOSPACE   Ignore the space whitespace character.
+ * \param flags  RFC1738_ESCAPE_NOPERCENT Ignore the escaping delimiter '%'.
+ */
+extern char *rfc1738_do_escape(const char *url, int flags);
 
-    /* Old API functions */
+/* Old API functions */
 
-    /* Default RFC 1738 escaping. Escape all UNSAFE characters and binary CTRL codes */
+/* Default RFC 1738 escaping. Escape all UNSAFE characters and binary CTRL codes */
 #define rfc1738_escape(x)  rfc1738_do_escape(x, RFC1738_ESCAPE_UNSAFE|RFC1738_ESCAPE_CTRLS)
 
-    /* Escape a partial URL. Encoding every binary code, unsafe or reserved character. */
+/* Escape a partial URL. Encoding every binary code, unsafe or reserved character. */
 #define rfc1738_escape_part(x)  rfc1738_do_escape(x, RFC1738_ESCAPE_ALL)
 
-    /* Escape a URL. Encoding every unsafe characters but skipping reserved and already-encoded bytes.
-     * Suitable for safely encoding an absolute URL which may be encoded but is not trusted. */
+/* Escape a URL. Encoding every unsafe characters but skipping reserved and already-encoded bytes.
+ * Suitable for safely encoding an absolute URL which may be encoded but is not trusted. */
 #define rfc1738_escape_unescaped(x)  rfc1738_do_escape(x, RFC1738_ESCAPE_UNSAFE|RFC1738_ESCAPE_CTRLS|RFC1738_ESCAPE_NOPERCENT)
 
-    /**
-     * Unescape a URL string according to RFC 1738 specification.
-     * String is unescaped in-place
-     */
-    extern void rfc1738_unescape(char *url);
+/**
+ * Unescape a URL string according to RFC 1738 specification.
+ * String is unescaped in-place
+ */
+extern void rfc1738_unescape(char *url);
 
 #ifdef __cplusplus
 }
 #endif
 #endif /* _SQUID_INCLUDE_RFC1738_H */
+
@@ -24,9 +24,10 @@
  *  Squid accepts up to 255 character Hostname and Fully-Qualified Domain Names.
  *  Squid still NULL-terminates its FQDN and hotsname strings.
  */
-#define RFC2181_MAXHOSTNAMELEN	256
+#define RFC2181_MAXHOSTNAMELEN  256
 
 /** Back-port macro for old squid code still using SQUIDHOSTNAMELEN without RFC reference. */
-#define SQUIDHOSTNAMELEN	RFC2181_MAXHOSTNAMELEN
+#define SQUIDHOSTNAMELEN    RFC2181_MAXHOSTNAMELEN
 
 #endif /* _SQUID_INCLUDE_RFC1123_H */
+
@@ -28,40 +28,41 @@ extern "C" {
 #endif
 
 #define HASHLEN 16
-    typedef char HASH[HASHLEN];
+typedef char HASH[HASHLEN];
 #define HASHHEXLEN 32
-    typedef char HASHHEX[HASHHEXLEN + 1];
+typedef char HASHHEX[HASHHEXLEN + 1];
 
-    /* calculate H(A1) as per HTTP Digest spec */
-    extern void DigestCalcHA1(
-        const char *pszAlg,
-        const char *pszUserName,
-        const char *pszRealm,
-        const char *pszPassword,
-        const char *pszNonce,
-        const char *pszCNonce,
-        HASH HA1,
-        HASHHEX SessionKey
-    );
+/* calculate H(A1) as per HTTP Digest spec */
+extern void DigestCalcHA1(
+    const char *pszAlg,
+    const char *pszUserName,
+    const char *pszRealm,
+    const char *pszPassword,
+    const char *pszNonce,
+    const char *pszCNonce,
+    HASH HA1,
+    HASHHEX SessionKey
+);
 
-    /* calculate request-digest/response-digest as per HTTP Digest spec */
-    extern void DigestCalcResponse(
-        const HASHHEX HA1,		/* H(A1) */
-        const char *pszNonce,	/* nonce from server */
-        const char *pszNonceCount,	/* 8 hex digits */
-        const char *pszCNonce,	/* client nonce */
-        const char *pszQop,		/* qop-value: "", "auth", "auth-int" */
-        const char *pszMethod,	/* method from the request */
-        const char *pszDigestUri,	/* requested URL */
-        const HASHHEX HEntity,	/* H(entity body) if qop="auth-int" */
-        HASHHEX Response		/* request-digest or response-digest */
-    );
+/* calculate request-digest/response-digest as per HTTP Digest spec */
+extern void DigestCalcResponse(
+    const HASHHEX HA1,      /* H(A1) */
+    const char *pszNonce,   /* nonce from server */
+    const char *pszNonceCount,  /* 8 hex digits */
+    const char *pszCNonce,  /* client nonce */
+    const char *pszQop,     /* qop-value: "", "auth", "auth-int" */
+    const char *pszMethod,  /* method from the request */
+    const char *pszDigestUri,   /* requested URL */
+    const HASHHEX HEntity,  /* H(entity body) if qop="auth-int" */
+    HASHHEX Response        /* request-digest or response-digest */
+);
 
-    extern void CvtHex(const HASH Bin, HASHHEX Hex);
+extern void CvtHex(const HASH Bin, HASHHEX Hex);
 
-    extern void CvtBin(const HASHHEX Hex, HASH Bin);
+extern void CvtBin(const HASHHEX Hex, HASH Bin);
 
 #ifdef __cplusplus
 }
 #endif
 #endif /* SQUID_RFC2617_H */
+
@@ -15,3 +15,4 @@
 SQUIDCEXTERN int rfc2671RROptPack(char *buf, size_t sz, ssize_t edns_sz);
 
 #endif /* SQUID_RFC3596_H */
+
@@ -53,3 +53,4 @@ SQUIDCEXTERN ssize_t rfc3596BuildHostQuery(const char *hostname,
 #define RFC1035_TYPE_AAAA 28
 
 #endif /* SQUID_RFC3596_H */
+
@@ -33,8 +33,9 @@
  *
  **********************************************************************/
 
-#define SNMP_PORT	    161
-#define SNMP_TRAP_PORT	    162
-#define SNMP_MAX_LEN	    484
+#define SNMP_PORT       161
+#define SNMP_TRAP_PORT      162
+#define SNMP_MAX_LEN        484
 
 #endif /* SQUID_SNMP_INTERNAL_H */
+
@@ -35,10 +35,11 @@
  *
  ***************************************************************************/
 
-#include <asn1.h>		/* Need OID Definition */
-#include <snmp_vars.h>		/* Need variable_list */
+#include <asn1.h>       /* Need OID Definition */
+#include <snmp_vars.h>      /* Need variable_list */
 #if 0
-#include <mib.h>		/* Then the function definitions */
+#include <mib.h>        /* Then the function definitions */
 #endif
 
 #endif /* SQUID_SNMP_MIB_H */
+
@@ -68,3 +68,4 @@
 #include "snmp_impl.h"
 
 #endif /* SQUID_SNMP_H */
+
@@ -10,7 +10,7 @@
 #define SQUID_SNMP_API_H
 
 /***********************************************************
-	Copyright 1989 by Carnegie Mellon University
+    Copyright 1989 by Carnegie Mellon University
 
                       All Rights Reserved
 
@@ -38,142 +38,143 @@ SOFTWARE.
 /*
  * Set fields in session and pdu to the following to get a default or unconfigured value.
  */
-#define SNMP_DEFAULT_COMMUNITY_LEN  0	/* to get a default community name */
-#define SNMP_DEFAULT_RETRIES	    3
-#define SNMP_DEFAULT_TIMEOUT	    1
-#define SNMP_DEFAULT_REMPORT	    0
-#define SNMP_DEFAULT_PEERNAME	    NULL
-#define SNMP_DEFAULT_ENTERPRISE_LENGTH	0
-#define SNMP_DEFAULT_TIME	    0
+#define SNMP_DEFAULT_COMMUNITY_LEN  0   /* to get a default community name */
+#define SNMP_DEFAULT_RETRIES        3
+#define SNMP_DEFAULT_TIMEOUT        1
+#define SNMP_DEFAULT_REMPORT        0
+#define SNMP_DEFAULT_PEERNAME       NULL
+#define SNMP_DEFAULT_ENTERPRISE_LENGTH  0
+#define SNMP_DEFAULT_TIME       0
 #define SNMP_DEFAULT_MAXREPETITIONS 5
 #define SNMP_DEFAULT_MACREPEATERS   0
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-    /* Parse the buffer pointed to by arg3, of length arg4, into pdu arg2.
-     *
-     * Returns the community of the incoming PDU, or NULL
-     */
-    u_char *snmp_parse(struct snmp_session *, struct snmp_pdu *, u_char *, int);
-
-    /* Encode pdu arg2 into buffer arg3.  arg4 contains the size of
-     * the buffer.
-     */
-    int snmp_build(struct snmp_session *, struct snmp_pdu *, u_char *, int *);
-
-    /*
-     * struct snmp_session *snmp_open(session)
-     *      struct snmp_session *session;
-     *
-     * Sets up the session with the snmp_session information provided
-     * by the user.  Then opens and binds the necessary UDP port.
-     * A handle to the created session is returned (this is different than
-     * the pointer passed to snmp_open()).  On any error, NULL is returned
-     * and snmp_errno is set to the appropriate error code.
-     */
+/* Parse the buffer pointed to by arg3, of length arg4, into pdu arg2.
+ *
+ * Returns the community of the incoming PDU, or NULL
+ */
+u_char *snmp_parse(struct snmp_session *, struct snmp_pdu *, u_char *, int);
+
+/* Encode pdu arg2 into buffer arg3.  arg4 contains the size of
+ * the buffer.
+ */
+int snmp_build(struct snmp_session *, struct snmp_pdu *, u_char *, int *);
+
+/*
+ * struct snmp_session *snmp_open(session)
+ *      struct snmp_session *session;
+ *
+ * Sets up the session with the snmp_session information provided
+ * by the user.  Then opens and binds the necessary UDP port.
+ * A handle to the created session is returned (this is different than
+ * the pointer passed to snmp_open()).  On any error, NULL is returned
+ * and snmp_errno is set to the appropriate error code.
+ */
 #if 0
-    struct snmp_session *snmp_open(struct snmp_session *);
-
-    /*
-     * int snmp_close(session)
-     *     struct snmp_session *session;
-     *
-     * Close the input session.  Frees all data allocated for the session,
-     * dequeues any pending requests, and closes any sockets allocated for
-     * the session.  Returns 0 on error, 1 otherwise.
-     */
-    int snmp_close(struct snmp_session *);
-
-    /*
-     * int snmp_send(session, pdu)
-     *     struct snmp_session *session;
-     *     struct snmp_pdu  *pdu;
-     *
-     * Sends the input pdu on the session after calling snmp_build to create
-     * a serialized packet.  If necessary, set some of the pdu data from the
-     * session defaults.  Add a request corresponding to this pdu to the list
-     * of outstanding requests on this session, then send the pdu.
-     * Returns the request id of the generated packet if applicable, otherwise 1.
-     * On any error, 0 is returned.
-     * The pdu is freed by snmp_send() unless a failure occured.
-     */
-    int snmp_send(struct snmp_session *, struct snmp_pdu *);
-
-    /*
-     * void snmp_read(fdset)
-     *     fd_set  *fdset;
-     *
-     * Checks to see if any of the fd's set in the fdset belong to
-     * snmp.  Each socket with it's fd set has a packet read from it
-     * and snmp_parse is called on the packet received.  The resulting pdu
-     * is passed to the callback routine for that session.  If the callback
-     * routine returns successfully, the pdu and it's request are deleted.
-     */
-    void snmp_read(fd_set *);
-
-    /*
-     * int snmp_select_info(numfds, fdset, timeout, block)
-     * int *numfds;
-     * fd_set   *fdset;
-     * struct timeval *timeout;
-     * int *block;
-     *
-     * Returns info about what snmp requires from a select statement.
-     * numfds is the number of fds in the list that are significant.
-     * All file descriptors opened for SNMP are OR'd into the fdset.
-     * If activity occurs on any of these file descriptors, snmp_read
-     * should be called with that file descriptor set.
-     *
-     * The timeout is the latest time that SNMP can wait for a timeout.  The
-     * select should be done with the minimum time between timeout and any other
-     * timeouts necessary.  This should be checked upon each invocation of select.
-     * If a timeout is received, snmp_timeout should be called to check if the
-     * timeout was for SNMP.  (snmp_timeout is idempotent)
-     *
-     * Block is 1 if the select is requested to block indefinitely, rather than time out.
-     * If block is input as 1, the timeout value will be treated as undefined, but it must
-     * be available for setting in snmp_select_info.  On return, if block is true, the value
-     * of timeout will be undefined.
-     *
-     * snmp_select_info returns the number of open sockets.  (i.e. The number of sessions open)
-     */
-    int snmp_select_info(int *, fd_set *, struct timeval *, int *);
-
-    /*
-     * void snmp_timeout();
-     *
-     * snmp_timeout should be called whenever the timeout from snmp_select_info expires,
-     * but it is idempotent, so snmp_timeout can be polled (probably a cpu expensive
-     * proposition).  snmp_timeout checks to see if any of the sessions have an
-     * outstanding request that has timed out.  If it finds one (or more), and that
-     * pdu has more retries available, a new packet is formed from the pdu and is
-     * resent.  If there are no more retries available, the callback for the session
-     * is used to alert the user of the timeout.
-     */
-    void snmp_timeout(void);
-
-    /*
-     * This routine must be supplied by the application:
-     *
-     * int callback(operation, session, reqid, pdu, magic)
-     * int operation;
-     * struct snmp_session *session;    The session authenticated under.
-     * int reqid;                       The request id of this pdu (0 for TRAP)
-     * struct snmp_pdu *pdu;            The pdu information.
-     * void *magic                      A link to the data for this routine.
-     *
-     * Returns 1 if request was successful, 0 if it should be kept pending.
-     * Any data in the pdu must be copied because it will be freed elsewhere.
-     * Operations are defined below:
-     */
-
-    void snmp_api_stats(void *);
+struct snmp_session *snmp_open(struct snmp_session *);
+
+/*
+ * int snmp_close(session)
+ *     struct snmp_session *session;
+ *
+ * Close the input session.  Frees all data allocated for the session,
+ * dequeues any pending requests, and closes any sockets allocated for
+ * the session.  Returns 0 on error, 1 otherwise.
+ */
+int snmp_close(struct snmp_session *);
+
+/*
+ * int snmp_send(session, pdu)
+ *     struct snmp_session *session;
+ *     struct snmp_pdu  *pdu;
+ *
+ * Sends the input pdu on the session after calling snmp_build to create
+ * a serialized packet.  If necessary, set some of the pdu data from the
+ * session defaults.  Add a request corresponding to this pdu to the list
+ * of outstanding requests on this session, then send the pdu.
+ * Returns the request id of the generated packet if applicable, otherwise 1.
+ * On any error, 0 is returned.
+ * The pdu is freed by snmp_send() unless a failure occured.
+ */
+int snmp_send(struct snmp_session *, struct snmp_pdu *);
+
+/*
+ * void snmp_read(fdset)
+ *     fd_set  *fdset;
+ *
+ * Checks to see if any of the fd's set in the fdset belong to
+ * snmp.  Each socket with it's fd set has a packet read from it
+ * and snmp_parse is called on the packet received.  The resulting pdu
+ * is passed to the callback routine for that session.  If the callback
+ * routine returns successfully, the pdu and it's request are deleted.
+ */
+void snmp_read(fd_set *);
+
+/*
+ * int snmp_select_info(numfds, fdset, timeout, block)
+ * int *numfds;
+ * fd_set   *fdset;
+ * struct timeval *timeout;
+ * int *block;
+ *
+ * Returns info about what snmp requires from a select statement.
+ * numfds is the number of fds in the list that are significant.
+ * All file descriptors opened for SNMP are OR'd into the fdset.
+ * If activity occurs on any of these file descriptors, snmp_read
+ * should be called with that file descriptor set.
+ *
+ * The timeout is the latest time that SNMP can wait for a timeout.  The
+ * select should be done with the minimum time between timeout and any other
+ * timeouts necessary.  This should be checked upon each invocation of select.
+ * If a timeout is received, snmp_timeout should be called to check if the
+ * timeout was for SNMP.  (snmp_timeout is idempotent)
+ *
+ * Block is 1 if the select is requested to block indefinitely, rather than time out.
+ * If block is input as 1, the timeout value will be treated as undefined, but it must
+ * be available for setting in snmp_select_info.  On return, if block is true, the value
+ * of timeout will be undefined.
+ *
+ * snmp_select_info returns the number of open sockets.  (i.e. The number of sessions open)
+ */
+int snmp_select_info(int *, fd_set *, struct timeval *, int *);
+
+/*
+ * void snmp_timeout();
+ *
+ * snmp_timeout should be called whenever the timeout from snmp_select_info expires,
+ * but it is idempotent, so snmp_timeout can be polled (probably a cpu expensive
+ * proposition).  snmp_timeout checks to see if any of the sessions have an
+ * outstanding request that has timed out.  If it finds one (or more), and that
+ * pdu has more retries available, a new packet is formed from the pdu and is
+ * resent.  If there are no more retries available, the callback for the session
+ * is used to alert the user of the timeout.
+ */
+void snmp_timeout(void);
+
+/*
+ * This routine must be supplied by the application:
+ *
+ * int callback(operation, session, reqid, pdu, magic)
+ * int operation;
+ * struct snmp_session *session;    The session authenticated under.
+ * int reqid;                       The request id of this pdu (0 for TRAP)
+ * struct snmp_pdu *pdu;            The pdu information.
+ * void *magic                      A link to the data for this routine.
+ *
+ * Returns 1 if request was successful, 0 if it should be kept pending.
+ * Any data in the pdu must be copied because it will be freed elsewhere.
+ * Operations are defined below:
+ */
+
+void snmp_api_stats(void *);
 #endif
 #ifdef __cplusplus
 }
 
 #endif
 
-#endif				/* SQUID_SNMP_API_H */
+#endif              /* SQUID_SNMP_API_H */
+
@@ -36,11 +36,11 @@
  ***************************************************************************/
 
 /* Error return values */
-#define SNMPERR_GENERR		-1
-#define SNMPERR_BAD_LOCPORT	-2	/* local port was already in use */
-#define SNMPERR_BAD_ADDRESS	-3
-#define SNMPERR_BAD_SESSION	-4
-#define SNMPERR_TOO_LONG	-5	/* data too long for provided buffer */
+#define SNMPERR_GENERR      -1
+#define SNMPERR_BAD_LOCPORT -2  /* local port was already in use */
+#define SNMPERR_BAD_ADDRESS -3
+#define SNMPERR_BAD_SESSION -4
+#define SNMPERR_TOO_LONG    -5  /* data too long for provided buffer */
 
 #define SNMPERR_ASN_ENCODE      -6
 #define SNMPERR_ASN_DECODE      -7
@@ -54,23 +54,24 @@
 #define SNMPERR_PACKET_ERR      -14
 #define SNMPERR_NO_RESPONSE     -15
 
-#define SNMPERR_LAST            -16	/* Last error message */
+#define SNMPERR_LAST            -16 /* Last error message */
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-    /* extern int snmp_errno */
+/* extern int snmp_errno */
 
-    const char *snmp_api_error(int);
-    int snmp_api_errno(void);
+const char *snmp_api_error(int);
+int snmp_api_errno(void);
 
-    const char *api_errstring(int);	/* Backwards compatibility */
-    void snmp_set_api_error(int);
+const char *api_errstring(int); /* Backwards compatibility */
+void snmp_set_api_error(int);
 
 #ifdef __cplusplus
 }
 
 #endif
 
-#endif				/* SQUID_SNMP_API_ERROR_H */
+#endif              /* SQUID_SNMP_API_ERROR_H */
+
@@ -13,7 +13,7 @@
 #include "snmp_pdu.h"
 
 /***********************************************************
-	Copyright 1997 by Carnegie Mellon University
+    Copyright 1997 by Carnegie Mellon University
 
                       All Rights Reserved
 
@@ -46,12 +46,12 @@ SOFTWARE.
  */
 struct request_list {
     struct request_list *next_request;
-    int request_id;		/* request id */
-    int retries;		/* Number of retries */
-    u_int timeout;		/* length to wait for timeout */
-    struct timeval time;	/* Time this request was made */
-    struct timeval expire;	/* time this request is due to expire */
-    struct snmp_pdu *pdu;	/* The pdu for this request (saved so it can be retransmitted */
+    int request_id;     /* request id */
+    int retries;        /* Number of retries */
+    u_int timeout;      /* length to wait for timeout */
+    struct timeval time;    /* Time this request was made */
+    struct timeval expire;  /* time this request is due to expire */
+    struct snmp_pdu *pdu;   /* The pdu for this request (saved so it can be retransmitted */
 };
 
 /*
@@ -64,9 +64,9 @@ struct session_list {
 };
 
 struct snmp_internal_session {
-    int sd;			/* socket descriptor for this connection */
-    struct sockaddr_in addr;		/* address of connected peer */
-    struct request_list *requests;	/* Info about outstanding requests */
+    int sd;         /* socket descriptor for this connection */
+    struct sockaddr_in addr;        /* address of connected peer */
+    struct request_list *requests;  /* Info about outstanding requests */
 };
 
 /* Define these here, as they aren't defined normall under
@@ -93,13 +93,14 @@ struct snmp_internal_session {
 extern "C" {
 #endif
 
-    int snmp_get_socket_session(struct snmp_session *session_);
-    int snmp_select_info_session(struct snmp_session *session_, struct timeval *timeout);
-    int snmp_timeout_session(struct snmp_session *sp_);
+int snmp_get_socket_session(struct snmp_session *session_);
+int snmp_select_info_session(struct snmp_session *session_, struct timeval *timeout);
+int snmp_timeout_session(struct snmp_session *sp_);
 
 #ifdef __cplusplus
 }
 
 #endif
 
-#endif				/* SQUID_SNMP_API_UTIL_H */
+#endif              /* SQUID_SNMP_API_UTIL_H */
+
@@ -10,7 +10,7 @@
 #define SQUID_SNMP_CLIENT_H
 
 /***********************************************************
-	Copyright 1988, 1989 by Carnegie Mellon University
+    Copyright 1988, 1989 by Carnegie Mellon University
 
                       All Rights Reserved
 
@@ -34,8 +34,8 @@ struct synch_state {
     int waiting;
     int status;
     /* status codes */
-#define STAT_SUCCESS	0
-#define STAT_ERROR	1
+#define STAT_SUCCESS    0
+#define STAT_ERROR  1
 #define STAT_TIMEOUT 2
     int reqid;
     struct snmp_pdu *pdu;
@@ -45,21 +45,22 @@ struct synch_state {
 extern "C" {
 #endif
 
-    extern struct synch_state snmp_synch_state;
+extern struct synch_state snmp_synch_state;
 
-    /* Synchronize Input with Agent */
-    int snmp_synch_input(int, struct snmp_session *, int,
-                         struct snmp_pdu *, void *);
+/* Synchronize Input with Agent */
+int snmp_synch_input(int, struct snmp_session *, int,
+                     struct snmp_pdu *, void *);
 
-    /* Synchronize Response with Agent */
-    int snmp_synch_response(struct snmp_session *, struct snmp_pdu *,
-                            struct snmp_pdu **);
+/* Synchronize Response with Agent */
+int snmp_synch_response(struct snmp_session *, struct snmp_pdu *,
+                        struct snmp_pdu **);
 
-    /* Synchronize Setup */
-    void snmp_synch_setup(struct snmp_session *);
+/* Synchronize Setup */
+void snmp_synch_setup(struct snmp_session *);
 
 #ifdef __cplusplus
 }
 #endif
 
-#endif				/* SQUID_SNMP_CLIENT_H */
+#endif              /* SQUID_SNMP_CLIENT_H */
+
@@ -39,11 +39,12 @@
 extern "C" {
 #endif
 
-    int snmp_coexist_V2toV1(struct snmp_pdu *);
-    int snmp_coexist_V1toV2(struct snmp_pdu *);
+int snmp_coexist_V2toV1(struct snmp_pdu *);
+int snmp_coexist_V1toV2(struct snmp_pdu *);
 
 #ifdef __cplusplus
 }
 #endif
 
 #endif /* SQUID_SNMP_COEXISTANCE_H */
+
@@ -12,3 +12,4 @@
 SQUIDCEXTERN void snmplib_debug(int, const char *,...) PRINTF_FORMAT_ARG2;
 
 #endif /* SQUID_SNMP_DEBUG_H */
+
@@ -65,10 +65,11 @@
 extern "C" {
 #endif
 
-    const char *snmp_errstring(int);
+const char *snmp_errstring(int);
 
 #ifdef __cplusplus
 }
 #endif
 
-#endif				/* SQUID_SNMP_ERROR_H */
+#endif              /* SQUID_SNMP_ERROR_H */
+
@@ -17,7 +17,7 @@
  *
  */
 /***********************************************************
-	Copyright 1988, 1989 by Carnegie Mellon University
+    Copyright 1988, 1989 by Carnegie Mellon University
 
                       All Rights Reserved
 
@@ -50,19 +50,19 @@ SOFTWARE.
 #endif
 #endif
 
-#define SID_MAX_LEN	64
+#define SID_MAX_LEN 64
 
-#define READ	    1
-#define WRITE	    0
+#define READ        1
+#define WRITE       0
 
 #define SNMP_RESERVE1    0
 #define SNMP_RESERVE2    1
 #define SNMP_COMMIT      2
 #define SNMP_FREE        3
 
-#define RONLY	0xAAAA		/* read access for everyone */
-#define RWRITE	0xAABA		/* add write access for community private */
-#define NOACCESS 0x0000		/* no access for anybody */
+#define RONLY   0xAAAA      /* read access for everyone */
+#define RWRITE  0xAABA      /* add write access for community private */
+#define NOACCESS 0x0000     /* no access for anybody */
 
 struct trapVar {
     oid *varName;
@@ -74,3 +74,4 @@ struct trapVar {
 };
 
 #endif /* SQUID_SNMP_IMPL_H */
+
@@ -37,19 +37,20 @@
 
 #include "snmp_pdu.h"
 
-#define SNMP_VERSION_1	    0	/* RFC 1157 */
-#define SNMP_VERSION_2	    1	/* RFC 1901 */
+#define SNMP_VERSION_1      0   /* RFC 1157 */
+#define SNMP_VERSION_2      1   /* RFC 1901 */
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-    u_char *snmp_msg_Encode(u_char *, int *, u_char *, int, int, struct snmp_pdu *);
-    u_char *snmp_msg_Decode(u_char *, int *, u_char *, int *, int *, struct snmp_pdu *);
+u_char *snmp_msg_Encode(u_char *, int *, u_char *, int, int, struct snmp_pdu *);
+u_char *snmp_msg_Decode(u_char *, int *, u_char *, int *, int *, struct snmp_pdu *);
 
 #ifdef __cplusplus
 }
 
 #endif
 
-#endif	/* SQUID_SNMP_MSG_H */
+#endif  /* SQUID_SNMP_MSG_H */
+
@@ -46,74 +46,74 @@
 extern "C" {
 #endif
 
-    /* An SNMP PDU */
-    struct snmp_pdu {
-        int command;		/* Type of this PDU */
-        struct sockaddr_in address;		/* Address of peer */
-
-        int reqid;			/* Integer32: Request id */
-        int errstat;		/* INTEGER:   Error status */
-        int errindex;		/* INTEGER:   Error index */
-
-        /* SNMPv2 Bulk Request */
-        int non_repeaters;		/* INTEGER: */
-        int max_repetitions;	/* INTEGER: */
-
-        struct variable_list *variables;	/* Variable Bindings */
-
-        /* Trap information */
-        oid *enterprise;		/* System OID */
-        int enterprise_length;
-        struct sockaddr_in agent_addr;		/* address of object generating trap */
-        int trap_type;		/* generic trap type */
-        int specific_type;		/* specific type */
-        u_int time;			/* Uptime */
-    };
-
-    struct snmp_pdu *snmp_pdu_create(int);
-    struct snmp_pdu *snmp_pdu_clone(struct snmp_pdu *);
-    struct snmp_pdu *snmp_pdu_fix(struct snmp_pdu *, int);
-    struct snmp_pdu *snmp_fix_pdu(struct snmp_pdu *, int);
-    void snmp_free_pdu(struct snmp_pdu *);
-    void snmp_pdu_free(struct snmp_pdu *);
-
-    u_char *snmp_pdu_encode(u_char *, int *, struct snmp_pdu *);
-    u_char *snmp_pdu_decode(u_char *, int *, struct snmp_pdu *);
-
-    /* Add a NULL Variable to a PDU */
-    void snmp_add_null_var(struct snmp_pdu *, oid *, int);
-
-    /* RFC 1905: Protocol Operations for SNMPv2
-     *
-     * RFC 1157: A Simple Network Management Protocol (SNMP)
-     *
-     * PDU Types
-     */
-#define SNMP_PDU_GET	    (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x0)
+/* An SNMP PDU */
+struct snmp_pdu {
+    int command;        /* Type of this PDU */
+    struct sockaddr_in address;     /* Address of peer */
+
+    int reqid;          /* Integer32: Request id */
+    int errstat;        /* INTEGER:   Error status */
+    int errindex;       /* INTEGER:   Error index */
+
+    /* SNMPv2 Bulk Request */
+    int non_repeaters;      /* INTEGER: */
+    int max_repetitions;    /* INTEGER: */
+
+    struct variable_list *variables;    /* Variable Bindings */
+
+    /* Trap information */
+    oid *enterprise;        /* System OID */
+    int enterprise_length;
+    struct sockaddr_in agent_addr;      /* address of object generating trap */
+    int trap_type;      /* generic trap type */
+    int specific_type;      /* specific type */
+    u_int time;         /* Uptime */
+};
+
+struct snmp_pdu *snmp_pdu_create(int);
+struct snmp_pdu *snmp_pdu_clone(struct snmp_pdu *);
+struct snmp_pdu *snmp_pdu_fix(struct snmp_pdu *, int);
+struct snmp_pdu *snmp_fix_pdu(struct snmp_pdu *, int);
+void snmp_free_pdu(struct snmp_pdu *);
+void snmp_pdu_free(struct snmp_pdu *);
+
+u_char *snmp_pdu_encode(u_char *, int *, struct snmp_pdu *);
+u_char *snmp_pdu_decode(u_char *, int *, struct snmp_pdu *);
+
+/* Add a NULL Variable to a PDU */
+void snmp_add_null_var(struct snmp_pdu *, oid *, int);
+
+/* RFC 1905: Protocol Operations for SNMPv2
+ *
+ * RFC 1157: A Simple Network Management Protocol (SNMP)
+ *
+ * PDU Types
+ */
+#define SNMP_PDU_GET        (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x0)
 #define SNMP_PDU_GETNEXT    (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x1)
 #define SNMP_PDU_RESPONSE   (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x2)
 #ifdef UNUSED_CODE
 #define SNMP_PDU_SET        (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x3)
-#define TRP_REQ_MSG	    (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x4)	/*Obsolete */
+#define TRP_REQ_MSG     (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x4)   /*Obsolete */
 #endif
 #define SNMP_PDU_GETBULK    (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x5)
 #ifdef UNUSED_CODE
 #define SNMP_PDU_INFORM     (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x6)
 #define SNMP_PDU_V2TRAP     (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x7)
 #define SNMP_PDU_REPORT     (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x8)
 #endif
-#define MAX_BINDINGS 2147483647	/* PDU Defaults */
-#define SNMP_DEFAULT_ERRSTAT	    -1
-#define SNMP_DEFAULT_ERRINDEX	    -1
-#define SNMP_DEFAULT_ADDRESS	    0
-#define SNMP_DEFAULT_REQID	    0
-
-    /* RFC 1907: Management Information Base for SNMPv2
-     *
-     * RFC 1157: A Simple Network Management Protocol (SNMP)
-     *
-     * Trap Types
-     */
+#define MAX_BINDINGS 2147483647 /* PDU Defaults */
+#define SNMP_DEFAULT_ERRSTAT        -1
+#define SNMP_DEFAULT_ERRINDEX       -1
+#define SNMP_DEFAULT_ADDRESS        0
+#define SNMP_DEFAULT_REQID      0
+
+/* RFC 1907: Management Information Base for SNMPv2
+ *
+ * RFC 1157: A Simple Network Management Protocol (SNMP)
+ *
+ * Trap Types
+ */
 #if UNUSED_CODE
 #define SNMP_TRAP_COLDSTART             (0x0)
 #define SNMP_TRAP_WARMSTART             (0x1)
@@ -129,3 +129,4 @@ extern "C" {
 #endif
 
 #endif /* SQUID_SNMP_PDU_H */
+
@@ -34,18 +34,19 @@
  **********************************************************************/
 
 struct snmp_session {
-    int Version;		/* SNMP Version for this session */
+    int Version;        /* SNMP Version for this session */
 
-    u_char *community;		/* community for outgoing requests. */
-    int community_len;		/* Length of community name. */
-    int retries;		/* Number of retries before timeout. */
-    int timeout;		/* Number of uS until first timeout, then exponential backoff */
-    char *peername;		/* Domain name or dotted IP address of default peer */
-    unsigned short remote_port;	/* UDP port number of peer. */
-    unsigned short local_port;		/* My UDP port number, 0 for default, picked randomly */
+    u_char *community;      /* community for outgoing requests. */
+    int community_len;      /* Length of community name. */
+    int retries;        /* Number of retries before timeout. */
+    int timeout;        /* Number of uS until first timeout, then exponential backoff */
+    char *peername;     /* Domain name or dotted IP address of default peer */
+    unsigned short remote_port; /* UDP port number of peer. */
+    unsigned short local_port;      /* My UDP port number, 0 for default, picked randomly */
 };
 
 #define RECEIVED_MESSAGE   1
-#define TIMED_OUT	   2
+#define TIMED_OUT      2
 
 #endif /* SQUID_SNMP_SESSION_H */
+
@@ -13,46 +13,47 @@
 extern "C" {
 #endif
 
-    /* call a function at regular intervals (in seconds): */
-    extern void snmp_alarm(int ival, void (*handler) (void));
+/* call a function at regular intervals (in seconds): */
+extern void snmp_alarm(int ival, void (*handler) (void));
 
-    /* service for filedescriptors: */
+/* service for filedescriptors: */
 
-    extern void fd_add(int fd, void (*func) (int fd));
-    extern void fd_service(void);
+extern void fd_add(int fd, void (*func) (int fd));
+extern void fd_service(void);
 
-    /* ---------------------------------------------------------------------- */
+/* ---------------------------------------------------------------------- */
 
-    /*
-     * SNMP Agent extension for Spacer-Controler Management
-     *
-     * Copyright (c) 1997 FT/CNET/DES/GRL Olivier Montanuy
-     */
+/*
+ * SNMP Agent extension for Spacer-Controler Management
+ *
+ * Copyright (c) 1997 FT/CNET/DES/GRL Olivier Montanuy
+ */
 
-    /* Function to safely copy a string, and ensure the last
-     * character is always '\0'. */
-    void strcpy_safe(char *str, int str_len, char *val);
+/* Function to safely copy a string, and ensure the last
+ * character is always '\0'. */
+void strcpy_safe(char *str, int str_len, char *val);
 
-    /* Function to get IP address of this agent
-     * WARNING: this scans all interfaces (slow) */
-    u_long Util_local_ip_address(void);
+/* Function to get IP address of this agent
+ * WARNING: this scans all interfaces (slow) */
+u_long Util_local_ip_address(void);
 
-    /* Function to get the current time in seconds */
-    long Util_time_now(void);
+/* Function to get the current time in seconds */
+long Util_time_now(void);
 
-    /* Function to determine how long the agent has been running
-     * (WARNING: this seems rather slow) */
-    long Util_time_running();
+/* Function to determine how long the agent has been running
+ * (WARNING: this seems rather slow) */
+long Util_time_running();
 
-    /* Read data from file */
-    int Util_file_read(char *file, int offset, char *data, int dataSz);
+/* Read data from file */
+int Util_file_read(char *file, int offset, char *data, int dataSz);
 
-    /* Write data into file */
-    int Util_file_write(char *file, int offset, char *data, int dataSz);
+/* Write data into file */
+int Util_file_write(char *file, int offset, char *data, int dataSz);
 
-    /* ---------------------------------------------------------------------- */
+/* ---------------------------------------------------------------------- */
 
 #ifdef __cplusplus
 }
 #endif
 #endif /* SQUID_SNMP_UTIL_H */
+
@@ -41,50 +41,50 @@
 extern "C" {
 #endif
 
-    struct variable_list {
-        struct variable_list *next_variable;	/* NULL for last variable */
-        oid *name;			/* Object identifier of variable */
-        int name_length;		/* number of subid's in name */
-        u_char type;		/* ASN type of variable */
-        union {			/* value of variable */
-            int *integer;
-            u_char *string;
-            oid *objid;
-        } val;
-        int val_len;
-    };
-
-    struct variable_list *snmp_var_new(oid *, int);
-    struct variable_list *snmp_var_new_integer(oid *, int, int, unsigned char);
-    struct variable_list *snmp_var_clone(struct variable_list *);
-    void snmp_var_free(struct variable_list *);
-
-    u_char *snmp_var_EncodeVarBind(u_char *, int *, struct variable_list *, int);
-    u_char *snmp_var_DecodeVarBind(u_char *, int *, struct variable_list **, int);
-
-#define MAX_NAME_LEN	64	/* number of subid's in a objid */
-
-    /* RFC 1902: Structure of Management Information for SNMPv2
-     *
-     * Defined Types
-     */
+struct variable_list {
+    struct variable_list *next_variable;    /* NULL for last variable */
+    oid *name;          /* Object identifier of variable */
+    int name_length;        /* number of subid's in name */
+    u_char type;        /* ASN type of variable */
+    union {         /* value of variable */
+        int *integer;
+        u_char *string;
+        oid *objid;
+    } val;
+    int val_len;
+};
+
+struct variable_list *snmp_var_new(oid *, int);
+struct variable_list *snmp_var_new_integer(oid *, int, int, unsigned char);
+struct variable_list *snmp_var_clone(struct variable_list *);
+void snmp_var_free(struct variable_list *);
+
+u_char *snmp_var_EncodeVarBind(u_char *, int *, struct variable_list *, int);
+u_char *snmp_var_DecodeVarBind(u_char *, int *, struct variable_list **, int);
+
+#define MAX_NAME_LEN    64  /* number of subid's in a objid */
+
+/* RFC 1902: Structure of Management Information for SNMPv2
+ *
+ * Defined Types
+ */
 #define SMI_INTEGER     ASN_INTEGER
 #define SMI_STRING      ASN_OCTET_STR
 #define SMI_OBJID       ASN_OBJECT_ID
 #define SMI_NULLOBJ     ASN_NULL
-#define SMI_IPADDRESS  (ASN_APPLICATION | 0)	/* OCTET STRING, net byte order */
-#define SMI_COUNTER32  (ASN_APPLICATION | 1)	/* INTEGER */
-#define SMI_GAUGE32    (ASN_APPLICATION | 2)	/* INTEGER */
+#define SMI_IPADDRESS  (ASN_APPLICATION | 0)    /* OCTET STRING, net byte order */
+#define SMI_COUNTER32  (ASN_APPLICATION | 1)    /* INTEGER */
+#define SMI_GAUGE32    (ASN_APPLICATION | 2)    /* INTEGER */
 #define SMI_UNSIGNED32 SMI_GAUGE32
-#define SMI_TIMETICKS  (ASN_APPLICATION | 3)	/* INTEGER */
-#define SMI_OPAQUE     (ASN_APPLICATION | 4)	/* OCTET STRING */
-#define SMI_COUNTER64  (ASN_APPLICATION | 6)	/* INTEGER */
-
-    /* constants for enums for the MIB nodes
-     * cachePeerAddressType (InetAddressType / ASN_INTEGER)
-     * cacheClientAddressType (InetAddressType / ASN_INTEGER)
-     * Defined Types
-     */
+#define SMI_TIMETICKS  (ASN_APPLICATION | 3)    /* INTEGER */
+#define SMI_OPAQUE     (ASN_APPLICATION | 4)    /* OCTET STRING */
+#define SMI_COUNTER64  (ASN_APPLICATION | 6)    /* INTEGER */
+
+/* constants for enums for the MIB nodes
+ * cachePeerAddressType (InetAddressType / ASN_INTEGER)
+ * cacheClientAddressType (InetAddressType / ASN_INTEGER)
+ * Defined Types
+ */
 
 #ifndef INETADDRESSTYPE_ENUMS
 #define INETADDRESSTYPE_ENUMS
@@ -98,31 +98,32 @@ extern "C" {
 
 #endif                          /* INETADDRESSTYPE_ENUMS */
 
-    /*
-     * RFC 1905: Protocol Operations for SNMPv2
-     *
-     * Variable binding.
-     *
-     * VarBind ::=
-     *   SEQUENCE {
-     *     name ObjectName
-     *     CHOICE {
-     *       value ObjectSyntax
-     *       unSpecified NULL
-     *       noSuchObject[0] NULL
-     *       noSuchInstance[1] NULL
-     *       endOfMibView[2] NULL
-     *     }
-     *   }
-     */
+/*
+ * RFC 1905: Protocol Operations for SNMPv2
+ *
+ * Variable binding.
+ *
+ * VarBind ::=
+ *   SEQUENCE {
+ *     name ObjectName
+ *     CHOICE {
+ *       value ObjectSyntax
+ *       unSpecified NULL
+ *       noSuchObject[0] NULL
+ *       noSuchInstance[1] NULL
+ *       endOfMibView[2] NULL
+ *     }
+ *   }
+ */
 #define SMI_NOSUCHOBJECT   (ASN_CONTEXT | ASN_PRIMITIVE | 0x0) /* noSuchObject[0] */
 #define SMI_NOSUCHINSTANCE (ASN_CONTEXT | ASN_PRIMITIVE | 0x1) /* noSuchInstance[1] */
 #define SMI_ENDOFMIBVIEW   (ASN_CONTEXT | ASN_PRIMITIVE | 0x2) /* endOfMibView[2] */
-    typedef struct variable variable;
-    typedef struct variable_list variable_list;
+typedef struct variable variable;
+typedef struct variable_list variable_list;
 
 #ifdef __cplusplus
 }
 #endif
 
 #endif /* SQUID_SNMP_VARS_H */
+
@@ -169,7 +169,7 @@ SplayNode<V>::remove(Value const dataToRemove, SPLAYCMP * compare)
 
     SplayNode<V> *result = splay(dataToRemove, compare);
 
-    if (splayLastResult == 0) {	/* found it */
+    if (splayLastResult == 0) { /* found it */
         SplayNode<V> *newTop;
 
         if (result->left == NULL) {
@@ -185,7 +185,7 @@ SplayNode<V>::remove(Value const dataToRemove, SPLAYCMP * compare)
         return newTop;
     }
 
-    return result;			/* It wasn't there */
+    return result;          /* It wasn't there */
 }
 
 template<class V>
@@ -249,7 +249,7 @@ SplayNode<V>::splay(FindValue const &dataToFind, int( * compare)(FindValue const
                 break;
 
             if ((splayLastResult = compare(dataToFind, top->left->data)) < 0) {
-                y = top->left;	/* rotate right */
+                y = top->left;  /* rotate right */
                 top->left = y->right;
                 y->right = top;
                 top = y;
@@ -258,15 +258,15 @@ SplayNode<V>::splay(FindValue const &dataToFind, int( * compare)(FindValue const
                     break;
             }
 
-            r->left = top;	/* link right */
+            r->left = top;  /* link right */
             r = top;
             top = top->left;
         } else if (splayLastResult > 0) {
             if (top->right == NULL)
                 break;
 
             if ((splayLastResult = compare(dataToFind, top->right->data)) > 0) {
-                y = top->right;	/* rotate left */
+                y = top->right; /* rotate left */
                 top->right = y->left;
                 y->left = top;
                 top = y;
@@ -275,15 +275,15 @@ SplayNode<V>::splay(FindValue const &dataToFind, int( * compare)(FindValue const
                     break;
             }
 
-            l->right = top;	/* link left */
+            l->right = top; /* link left */
             l = top;
             top = top->right;
         } else {
             break;
         }
     }
 
-    l->right = top->left;	/* assemble */
+    l->right = top->left;   /* assemble */
     r->left = top->right;
     top->left = N.right;
     top->right = N.left;
@@ -516,3 +516,4 @@ SplayConstIterator<V>::operator * () const
 #endif /* cplusplus */
 
 #endif /* SQUID_SPLAY_H */
+
@@ -9,7 +9,7 @@
 #ifndef SQUID_CONFIG_H
 #define SQUID_CONFIG_H
 
-#include "autoconf.h"		/* For GNU autoconf variables */
+#include "autoconf.h"       /* For GNU autoconf variables */
 
 #if !defined(HAVE_SQUID)
 /* sub-packages define their own version details */
@@ -44,7 +44,7 @@
 
 #ifdef USE_POSIX_REGEX
 #ifndef USE_RE_SYNTAX
-#define USE_RE_SYNTAX	REG_EXTENDED	/* default Syntax */
+#define USE_RE_SYNTAX   REG_EXTENDED    /* default Syntax */
 #endif
 #endif
 
@@ -98,3 +98,4 @@ using namespace Squid;
 #include "leakcheck.h"
 
 #endif /* SQUID_CONFIG_H */
+
@@ -35,7 +35,7 @@ extern "C" {
 #include <security.h>
 #include <sspi.h>
 
-    typedef char * SSP_blobP;
+typedef char * SSP_blobP;
 
 #define WINNT_SECURITY_DLL "security.dll"
 #define WIN2K_SECURITY_DLL "secur32.dll"
@@ -50,20 +50,21 @@ extern "C" {
 #define SSP_OK 1
 #define SSP_ERROR 2
 
-    HMODULE LoadSecurityDll(int, const char *);
-    void UnloadSecurityDll(void);
-    BOOL WINAPI SSP_LogonUser(PTSTR, PTSTR, PTSTR);
-    BOOL WINAPI SSP_ValidateNTLMCredentials(PVOID, int, char *);
-    const char * WINAPI SSP_ValidateNegotiateCredentials(PVOID, int, PBOOL, int *, char *);
-    const char * WINAPI SSP_MakeChallenge(PVOID, int);
-    const char * WINAPI SSP_MakeNegotiateBlob(PVOID, int, PBOOL, int *, char *);
+HMODULE LoadSecurityDll(int, const char *);
+void UnloadSecurityDll(void);
+BOOL WINAPI SSP_LogonUser(PTSTR, PTSTR, PTSTR);
+BOOL WINAPI SSP_ValidateNTLMCredentials(PVOID, int, char *);
+const char * WINAPI SSP_ValidateNegotiateCredentials(PVOID, int, PBOOL, int *, char *);
+const char * WINAPI SSP_MakeChallenge(PVOID, int);
+const char * WINAPI SSP_MakeNegotiateBlob(PVOID, int, PBOOL, int *, char *);
 
-    extern BOOL Use_Unicode;
-    extern BOOL NTLM_LocalCall;
+extern BOOL Use_Unicode;
+extern BOOL NTLM_LocalCall;
 
 #if defined(__cplusplus)
 }
 #endif
 
 #endif /* _SQUID_WINDOWS_ */
 #endif /* LIBSSPWIN32_H_ */
+
@@ -70,3 +70,4 @@ int statMemoryAccounted(void);
 SQUIDCEXTERN unsigned int RoundTo(const unsigned int num, const unsigned int what);
 
 #endif /* SQUID_UTIL_H */
+
@@ -18,3 +18,4 @@ extern
 char *uudecode(const char *);
 
 #endif /* _SQUID_UUDECODE_H */
+
@@ -21,3 +21,4 @@
 #ifndef APP_FULLNAME
 #define APP_FULLNAME  PACKAGE "/" VERSION
 #endif
+
@@ -12,3 +12,4 @@
 SQUIDCEXTERN int xusleep(unsigned int);
 
 #endif /* _INC_XUSLEEP_H */
+
@@ -22,3 +22,4 @@
 #include "util.h"
 
 int splayLastResult = 0;
+
@@ -81,18 +81,18 @@ base64_decode(char *result, unsigned int result_size, const char *p)
         /* One quantum of four encoding characters/24 bit */
         if (j+4 <= result_size) {
             // Speed optimization: plenty of space, avoid some per-byte checks.
-            result[j++] = (val >> 16) & 0xff;	/* High 8 bits */
-            result[j++] = (val >> 8) & 0xff;	/* Mid 8 bits */
-            result[j++] = val & 0xff;		/* Low 8 bits */
+            result[j++] = (val >> 16) & 0xff;   /* High 8 bits */
+            result[j++] = (val >> 8) & 0xff;    /* Mid 8 bits */
+            result[j++] = val & 0xff;       /* Low 8 bits */
         } else {
             // part-quantum goes a bit slower with per-byte checks
-            result[j++] = (val >> 16) & 0xff;	/* High 8 bits */
+            result[j++] = (val >> 16) & 0xff;   /* High 8 bits */
             if (j == result_size)
                 return j;
-            result[j++] = (val >> 8) & 0xff;	/* Mid 8 bits */
+            result[j++] = (val >> 8) & 0xff;    /* Mid 8 bits */
             if (j == result_size)
                 return j;
-            result[j++] = val & 0xff;		/* Low 8 bits */
+            result[j++] = val & 0xff;       /* Low 8 bits */
         }
         if (j == result_size)
             return j;
@@ -212,3 +212,4 @@ base64_encode(char *result, int result_size, const char *data, int data_size)
     }
     return (out_cnt >= result_size?result_size:out_cnt);
 }
+
@@ -31,3 +31,4 @@ latin1_to_utf8(char *out, size_t size, const char *in)
         return NULL;
     return out;
 }
+
@@ -42,10 +42,10 @@
 #include <dirent.h>
 
 #define WIN32_LEAN_AND_MEAN
-#include <windows.h>		/* for GetFileAttributes */
+#include <windows.h>        /* for GetFileAttributes */
 
-#define SUFFIX	("*")
-#define	SLASH	("\\")
+#define SUFFIX  ("*")
+#define SLASH   ("\\")
 
 /*
  * opendir
@@ -293,3 +293,4 @@ seekdir(DIR * dirp, long lPos)
     }
 }
 #endif /* _SQUID_WINDOWS_ */
+
@@ -302,3 +302,4 @@ crypt(const char *wort, const char *salt)
 
     return retkey;
 }
+
@@ -44,3 +44,4 @@ getfullhostname(void)
         xstrncpy(buf, hp->h_name, RFC2181_MAXHOSTNAMELEN);
     return buf;
 }
+
@@ -44,15 +44,15 @@ static char sccsid[] = "@(#)getopt.c	8.3 (Berkeley) 4/27/95";
 #include <stdlib.h>
 #include <string.h>
 
-int opterr = 1,			/* if error message should be printed */
-             optind = 1,			/* index into parent argv vector */
-                      optopt,			/* character checked for validity */
-                      optreset;			/* reset getopt */
-char *optarg;			/* argument associated with option */
+int opterr = 1,         /* if error message should be printed */
+    optind = 1,            /* index into parent argv vector */
+    optopt,           /* character checked for validity */
+    optreset;         /* reset getopt */
+char *optarg;           /* argument associated with option */
 
-#define	BADCH	(int)'?'
-#define	BADARG	(int)':'
-#define	EMSG	(char*)""
+#define BADCH   (int)'?'
+#define BADARG  (int)':'
+#define EMSG    (char*)""
 
 /*
  * getopt --
@@ -64,21 +64,21 @@ int nargc;
 char *const *nargv;
 const char *ostr;
 {
-    static char *place = EMSG;	/* option letter processing */
-    char *oli;			/* option letter list index */
+    static char *place = EMSG;  /* option letter processing */
+    char *oli;          /* option letter list index */
 
-    if (optreset || !*place) {	/* update scanning pointer */
+    if (optreset || !*place) {  /* update scanning pointer */
         optreset = 0;
         if (optind >= nargc || *(place = nargv[optind]) != '-') {
             place = EMSG;
             return (-1);
         }
-        if (place[1] && *++place == '-') {	/* found "--" */
+        if (place[1] && *++place == '-') {  /* found "--" */
             ++optind;
             place = EMSG;
             return (-1);
         }
-    }				/* option letter okay? */
+    }               /* option letter okay? */
     if ((optopt = (int) *place++) == (int) ':' ||
             !(oli = strchr(ostr, optopt))) {
         /*
@@ -94,14 +94,14 @@ const char *ostr;
                            "%s: illegal option -- %c\n", __FILE__, optopt);
         return (BADCH);
     }
-    if (*++oli != ':') {	/* don't need argument */
+    if (*++oli != ':') {    /* don't need argument */
         optarg = NULL;
         if (!*place)
             ++optind;
-    } else {			/* need an argument */
-        if (*place)		/* no white space */
+    } else {            /* need an argument */
+        if (*place)     /* no white space */
             optarg = place;
-        else if (nargc <= ++optind) {	/* no arg */
+        else if (nargc <= ++optind) {   /* no arg */
             place = EMSG;
             if (*ostr == ':')
                 return (BADARG);
@@ -110,10 +110,11 @@ const char *ostr;
                                "%s: option requires an argument -- %c\n",
                                __FILE__, optopt);
             return (BADCH);
-        } else			/* white space */
+        } else          /* white space */
             optarg = nargv[optind];
         place = EMSG;
         ++optind;
     }
-    return (optopt);		/* dump back option letter */
+    return (optopt);        /* dump back option letter */
 }
+
@@ -67,22 +67,22 @@ hash4(const void *data, unsigned int size)
         break;
     case 7:
         HASH4;
-        /* FALLTHROUGH */
+    /* FALLTHROUGH */
     case 6:
         HASH4;
-        /* FALLTHROUGH */
+    /* FALLTHROUGH */
     case 5:
         HASH4;
-        /* FALLTHROUGH */
+    /* FALLTHROUGH */
     case 4:
         HASH4;
-        /* FALLTHROUGH */
+    /* FALLTHROUGH */
     case 3:
         HASH4;
-        /* FALLTHROUGH */
+    /* FALLTHROUGH */
     case 2:
         HASH4;
-        /* FALLTHROUGH */
+    /* FALLTHROUGH */
     case 1:
         HASH4;
     }
@@ -375,3 +375,4 @@ main(void)
     exit(0);
 }
 #endif
+
@@ -48,7 +48,7 @@ static void _heap_grow(heap * hp);
 static void _heap_swap_element(heap * hp, heap_node * elm1, heap_node * elm2);
 static int _heap_node_exist(heap * hp, int id);
 
-#ifdef	HEAP_DEBUG
+#ifdef  HEAP_DEBUG
 void _heap_print_tree(heap * hp, heap_node * node);
 #endif /* HEAP_DEBUG */
 
@@ -158,7 +158,7 @@ heap_delete(heap * hp, heap_node * elm)
         (void) 0;
     } else if (hp->last > 0) {
         if (lastNode->key < hp->nodes[Parent(lastNode->id)]->key)
-            _heap_ify_up(hp, lastNode);		/* COOL! */
+            _heap_ify_up(hp, lastNode);     /* COOL! */
         _heap_ify_down(hp, lastNode);
     }
     return data;
@@ -169,7 +169,7 @@ heap_delete(heap * hp, heap_node * elm)
  * heapify operation.
  */
 
-#ifndef	heap_gen_key
+#ifndef heap_gen_key
 /*
  * Function to generate keys.  See macro definition in heap.h.
  */
@@ -195,7 +195,7 @@ heap_extractmin(heap * hp)
     mutex_lock(hp->lock);
 
     data = hp->nodes[0]->data;
-    heap_delete(hp, hp->nodes[0]);	/* Delete the root */
+    heap_delete(hp, hp->nodes[0]);  /* Delete the root */
 
     mutex_unlock(hp->lock);
 
@@ -286,7 +286,7 @@ heap_peep(heap * hp, int n)
     return data;
 }
 
-#ifndef	heap_nodes
+#ifndef heap_nodes
 /*
  * Current number of nodes in HP.
  */
@@ -297,7 +297,7 @@ heap_nodes(heap * hp)
 }
 #endif /* heap_nodes */
 
-#ifndef	heap_empty
+#ifndef heap_empty
 /*
  * Determine if the heap is empty.  Returns 1 if HP has no elements and 0
  * otherwise.
@@ -356,7 +356,7 @@ _heap_ify_up(heap * hp, heap_node * elm)
         parentNode = hp->nodes[Parent(elm->id)];
         if (parentNode->key <= elm->key)
             break;
-        _heap_swap_element(hp, parentNode, elm);	/* Demote the parent. */
+        _heap_swap_element(hp, parentNode, elm);    /* Demote the parent. */
     }
 }
 
@@ -374,7 +374,7 @@ _heap_swap_element(heap * hp, heap_node * elm1, heap_node * elm2)
     hp->nodes[elm2->id] = elm2;
 }
 
-#ifdef	NOTDEF
+#ifdef  NOTDEF
 /*
  * Copy KEY and DATA fields of SRC to DEST. ID field is NOT copied.
  */
@@ -473,7 +473,7 @@ verify_heap_property(heap * hp)
     return correct;
 }
 
-#ifdef	MEASURE_HEAP_SKEW
+#ifdef  MEASURE_HEAP_SKEW
 
 /****************************************************************************
  * Heap skew computation
@@ -506,7 +506,7 @@ calc_heap_skew(heap * heap, int replace)
 {
     heap_node **nodes;
     long id, diff, skew = 0;
-#ifdef	HEAP_DEBUG_SKEW
+#ifdef  HEAP_DEBUG_SKEW
     long skewsq = 0;
 #endif /* HEAP_DEBUG_SKEW */
     float norm = 0;
@@ -540,9 +540,9 @@ calc_heap_skew(heap * heap, int replace)
         diff = id - nodes[id]->id;
         skew += abs(diff);
 
-#ifdef	HEAP_DEBUG_SKEW
+#ifdef  HEAP_DEBUG_SKEW
         skewsq += diff * diff;
-#ifdef	HEAP_DEBUG_ALL
+#ifdef  HEAP_DEBUG_ALL
         printf("%d\tKey = %f, diff = %d\n", id, nodes[id]->key, diff);
 #endif /* HEAP_DEBUG */
 #endif /* HEAP_DEBUG_SKEW */
@@ -582,3 +582,4 @@ calc_heap_skew(heap * heap, int replace)
 }
 
 #endif /* MEASURE_HEAP_SKEW */
+
@@ -101,3 +101,4 @@ html_quote(const char *string)
     *dst = '\0';
     return (buf);
 }
+
@@ -48,3 +48,4 @@ parse_iso3307_time(const char *buf)
 #endif
     return t;
 }
+
@@ -41,3 +41,4 @@ Trie::add(char const *aString, size_t theLength, void *privatedata)
 
     return head->add(aString, theLength, privatedata, transform);
 }
+
@@ -72,3 +72,4 @@ Trie::findPrefix (char const *aString, size_t theLength)
 }
 
 #endif /* LIBTRIE_SQUID_H */
+
@@ -46,3 +46,4 @@ class TrieCaseless : public TrieCharTransform
 #endif /* __cplusplus */
 
 #endif /* LIBTRIE_TRIECHARTRANSFORM_H */
+
@@ -49,3 +49,4 @@ TrieNode::add(char const *aString, size_t theLength, void *privatedata, TrieChar
         return true;
     }
 }
+
@@ -82,3 +82,4 @@ TrieNode::find (char const *aString, size_t theLength, TrieCharTransform *transf
     }
 }
 #endif /* LIBTRIE_TRIENODE_H */
+
@@ -122,3 +122,4 @@ int main (int argc, char **argv)
 
     return 0;
 }
+
@@ -48,3 +48,4 @@ main(int argc, char **argv)
              "1234567890123456789012345678901234567890");
     return 0;
 }
+
@@ -43,10 +43,10 @@
 #if !HAVE_NETTLE_MD5_H
 
 #if HAVE_STRING_H
-#include <string.h>		/* for memcpy() */
+#include <string.h>     /* for memcpy() */
 #endif
 #if HAVE_SYS_TYPES_H
-#include <sys/types.h>		/* for stupid systems */
+#include <sys/types.h>      /* for stupid systems */
 #endif
 
 #ifdef WORDS_BIGENDIAN
@@ -95,9 +95,9 @@ SquidMD5Update(struct SquidMD5Context *ctx, const void *_buf, unsigned len)
 
     t = ctx->bytes[0];
     if ((ctx->bytes[0] = t + len) < t)
-        ctx->bytes[1]++;	/* Carry from low to high */
+        ctx->bytes[1]++;    /* Carry from low to high */
 
-    t = 64 - (t & 0x3f);	/* Space available in ctx->in (at least 1) */
+    t = 64 - (t & 0x3f);    /* Space available in ctx->in (at least 1) */
     if (t > len) {
         memcpy((uint8_t *) ctx->in + 64 - t, buf, len);
         return;
@@ -129,7 +129,7 @@ SquidMD5Update(struct SquidMD5Context *ctx, const void *_buf, unsigned len)
 void
 SquidMD5Final(unsigned char digest[16], struct SquidMD5Context *ctx)
 {
-    int count = ctx->bytes[0] & 0x3f;	/* Number of bytes in ctx->in */
+    int count = ctx->bytes[0] & 0x3f;   /* Number of bytes in ctx->in */
     uint8_t *p = (uint8_t *) ctx->in + count;
 
     /* Set the first char of padding to 0x80.  There is always room. */
@@ -138,7 +138,7 @@ SquidMD5Final(unsigned char digest[16], struct SquidMD5Context *ctx)
     /* Bytes of padding needed to make 56 bytes (-8..55) */
     count = 56 - 1 - count;
 
-    if (count < 0) {		/* Padding forces an extra block */
+    if (count < 0) {        /* Padding forces an extra block */
         memset(p, 0, count + 8);
         byteSwap(ctx->in, 16);
         SquidMD5Transform(ctx->buf, ctx->in);
@@ -155,7 +155,7 @@ SquidMD5Final(unsigned char digest[16], struct SquidMD5Context *ctx)
 
     byteSwap(ctx->buf, 4);
     memcpy(digest, ctx->buf, 16);
-    memset(ctx, 0, sizeof(*ctx));	/* In case it's sensitive */
+    memset(ctx, 0, sizeof(*ctx));   /* In case it's sensitive */
 }
 
 #ifndef ASM_MD5
@@ -170,7 +170,7 @@ SquidMD5Final(unsigned char digest[16], struct SquidMD5Context *ctx)
 
 /* This is the central step in the MD5 algorithm. */
 #define MD5STEP(f,w,x,y,z,in,s) \
-	 (w += f(x,y,z) + in, w = (w<<s | w>>(32-s)) + x)
+     (w += f(x,y,z) + in, w = (w<<s | w>>(32-s)) + x)
 
 /*
  * The core of the MD5 algorithm, this alters an existing MD5 hash to
@@ -263,3 +263,4 @@ SquidMD5Transform(uint32_t buf[4], uint32_t const in[16])
 
 #endif /* !ASM_MD5 */
 #endif /* HAVE_ETTLE_MD5_H */
+
@@ -17,7 +17,7 @@
 #endif
 
 #include "ntlmauth/ntlmauth.h"
-#include "util.h"		/* for base64-related stuff */
+#include "util.h"       /* for base64-related stuff */
 
 /* ************************************************************************* */
 /* DEBUG functions */
@@ -206,17 +206,17 @@ ntlm_make_challenge(ntlm_challenge *ch,
                     const uint32_t flags)
 {
     int pl = 0;
-    memset(ch, 0, sizeof(ntlm_challenge));	/* reset */
-    memcpy(ch->hdr.signature, "NTLMSSP", 8);		/* set the signature */
-    ch->hdr.type = htole32(NTLM_CHALLENGE);	/* this is a challenge */
+    memset(ch, 0, sizeof(ntlm_challenge));  /* reset */
+    memcpy(ch->hdr.signature, "NTLMSSP", 8);        /* set the signature */
+    ch->hdr.type = htole32(NTLM_CHALLENGE); /* this is a challenge */
     if (domain != NULL) {
         // silently truncate the domain if it exceeds 2^16-1 bytes.
         // NTLM packets normally expect 2^8 bytes of domain.
         const uint16_t dlen = strlen(domain) & 0xFFFF;
         ntlm_add_to_payload(&ch->hdr, ch->payload, &pl, &ch->target, domain, dlen);
     }
     ch->flags = htole32(flags);
-    ch->context_low = 0;		/* check this out */
+    ch->context_low = 0;        /* check this out */
     ch->context_high = 0;
     memcpy(ch->challenge, challenge_nonce, challenge_nonce_len);
 }
@@ -231,10 +231,10 @@ ntlm_make_challenge(ntlm_challenge *ch,
  * this function will only insert data if the packet contains any. Otherwise
  * the buffers will be left untouched.
  *
- * \retval NTLM_ERR_NONE	username present, maybe also domain.
- * \retval NTLM_ERR_PROTOCOL	packet type is not an authentication packet.
- * \retval NTLM_ERR_LOGON	no username.
- * \retval NTLM_ERR_BLOB	domain field is apparently larger than the packet.
+ * \retval NTLM_ERR_NONE    username present, maybe also domain.
+ * \retval NTLM_ERR_PROTOCOL    packet type is not an authentication packet.
+ * \retval NTLM_ERR_LOGON   no username.
+ * \retval NTLM_ERR_BLOB    domain field is apparently larger than the packet.
  */
 int
 ntlm_unpack_auth(const ntlm_authenticate *auth, char *user, char *domain, const int32_t size)
@@ -275,3 +275,4 @@ ntlm_unpack_auth(const ntlm_authenticate *auth, char *user, char *domain, const
 
     return NTLM_ERR_NONE;
 }
+
@@ -17,93 +17,93 @@
 extern "C" {
 #endif
 
-    /* Used internally. Microsoft seems to think this is right, I believe them.
-     * Right. */
-#define NTLM_MAX_FIELD_LENGTH 300	/* max length of an NTLMSSP field */
+/* Used internally. Microsoft seems to think this is right, I believe them.
+ * Right. */
+#define NTLM_MAX_FIELD_LENGTH 300   /* max length of an NTLMSSP field */
 
-    /* max length of the BLOB data. (and helper input/output buffer) */
+/* max length of the BLOB data. (and helper input/output buffer) */
 #define NTLM_BLOB_BUFFER_SIZE 10240
 
-    /* Here start the NTLMSSP definitions */
+/* Here start the NTLMSSP definitions */
 
-    /* these are marked as "extra" fields */
+/* these are marked as "extra" fields */
 #define NTLM_REQUEST_INIT_RESPONSE          0x100000
 #define NTLM_REQUEST_ACCEPT_RESPONSE        0x200000
 #define NTLM_REQUEST_NON_NT_SESSION_KEY     0x400000
 
-    /* NTLM error codes */
+/* NTLM error codes */
 #define NTLM_ERR_INTERNAL         -3
 #define NTLM_ERR_BLOB             -2
 #define NTLM_ERR_BAD_PROTOCOL     -1
 #define NTLM_ERR_NONE              0    /* aka. SMBLM_ERR_NONE */
-    /* codes used by smb_lm helper */
+/* codes used by smb_lm helper */
 #define NTLM_ERR_SERVER            1    /* aka. SMBLM_ERR_SERVER   */
 #define NTLM_ERR_PROTOCOL          2    /* aka. SMBLM_ERR_PROTOCOL */
 #define NTLM_ERR_LOGON             3    /* aka. SMBLM_ERR_LOGON    */
 #define NTLM_ERR_UNTRUSTED_DOMAIN  4
 #define NTLM_ERR_NOT_CONNECTED     10
-    /* codes used by mswin_ntlmsspi helper */
+/* codes used by mswin_ntlmsspi helper */
 #define NTLM_SSPI_ERROR         1
 #define NTLM_BAD_NTGROUP        2
 #define NTLM_BAD_REQUEST        3
-    /* TODO: reduce the above codes down to one set non-overlapping. */
-
-    /** String header. String data resides at the end of the request */
-    typedef struct _strhdr {
-        int16_t len;		/**< Length in bytes */
-        int16_t maxlen;		/**< Allocated space in bytes */
-        int32_t offset;		/**< Offset from start of request */
-    } strhdr;
-
-    /** We use this to keep data/length couples. */
-    typedef struct _lstring {
-        int32_t l;			/**< length, -1 if empty */
-        char *str;			/**< the string. NULL if not initialized */
-    } lstring;
-
-    /** Debug dump the given flags field to stderr */
-    void ntlm_dump_ntlmssp_flags(const uint32_t flags);
-
-    /* ************************************************************************* */
-    /* Packet and Payload structures and handling functions */
-    /* ************************************************************************* */
-
-    /* NTLM request types that we know about */
-#define NTLM_ANY			0
-#define NTLM_NEGOTIATE			1
-#define NTLM_CHALLENGE			2
-#define NTLM_AUTHENTICATE		3
-
-    /** This is an header common to all packets, it's used to discriminate
-     * among the different packet signature types.
-     */
-    typedef struct _ntlmhdr {
-        char signature[8];		/**< "NTLMSSP" */
-        int32_t type;		/**< One of the NTLM_* types above. */
-    } ntlmhdr;
-
-    /** Validate the packet type matches one we want. */
-    int ntlm_validate_packet(const ntlmhdr *packet, const int32_t type);
-
-    /** Retrieve a string from the NTLM packet payload. */
-    lstring ntlm_fetch_string(const ntlmhdr *packet,
-                              const int32_t packet_length,
-                              const strhdr *str,
-                              const uint32_t flags);
-
-    /** Append a string to the NTLM packet payload. */
-    void ntlm_add_to_payload(const ntlmhdr *packet_hdr,
-                             char *payload,
-                             int *payload_length,
-                             strhdr * hdr,
-                             const char *toadd,
-                             const uint16_t toadd_length);
-
-    /* ************************************************************************* */
-    /* Negotiate Packet structures and functions */
-    /* ************************************************************************* */
-
-    /* negotiate request flags */
+/* TODO: reduce the above codes down to one set non-overlapping. */
+
+/** String header. String data resides at the end of the request */
+typedef struct _strhdr {
+    int16_t len;        /**< Length in bytes */
+    int16_t maxlen;     /**< Allocated space in bytes */
+    int32_t offset;     /**< Offset from start of request */
+} strhdr;
+
+/** We use this to keep data/length couples. */
+typedef struct _lstring {
+    int32_t l;          /**< length, -1 if empty */
+    char *str;          /**< the string. NULL if not initialized */
+} lstring;
+
+/** Debug dump the given flags field to stderr */
+void ntlm_dump_ntlmssp_flags(const uint32_t flags);
+
+/* ************************************************************************* */
+/* Packet and Payload structures and handling functions */
+/* ************************************************************************* */
+
+/* NTLM request types that we know about */
+#define NTLM_ANY            0
+#define NTLM_NEGOTIATE          1
+#define NTLM_CHALLENGE          2
+#define NTLM_AUTHENTICATE       3
+
+/** This is an header common to all packets, it's used to discriminate
+ * among the different packet signature types.
+ */
+typedef struct _ntlmhdr {
+    char signature[8];      /**< "NTLMSSP" */
+    int32_t type;       /**< One of the NTLM_* types above. */
+} ntlmhdr;
+
+/** Validate the packet type matches one we want. */
+int ntlm_validate_packet(const ntlmhdr *packet, const int32_t type);
+
+/** Retrieve a string from the NTLM packet payload. */
+lstring ntlm_fetch_string(const ntlmhdr *packet,
+                          const int32_t packet_length,
+                          const strhdr *str,
+                          const uint32_t flags);
+
+/** Append a string to the NTLM packet payload. */
+void ntlm_add_to_payload(const ntlmhdr *packet_hdr,
+                         char *payload,
+                         int *payload_length,
+                         strhdr * hdr,
+                         const char *toadd,
+                         const uint16_t toadd_length);
+
+/* ************************************************************************* */
+/* Negotiate Packet structures and functions */
+/* ************************************************************************* */
+
+/* negotiate request flags */
 #define NTLM_NEGOTIATE_UNICODE              0x0001
 #define NTLM_NEGOTIATE_ASCII                0x0002
 #define NTLM_NEGOTIATE_REQUEST_TARGET       0x0004
@@ -118,78 +118,79 @@ extern "C" {
 #define NTLM_NEGOTIATE_THIS_IS_LOCAL_CALL   0x4000
 #define NTLM_NEGOTIATE_ALWAYS_SIGN          0x8000
 
-    /** Negotiation request sent by client */
-    typedef struct _ntlm_negotiate {
-        ntlmhdr hdr;		/**< "NTLMSSP" , LSWAP(0x1) */
-        uint32_t flags;	/**< Request flags */
-        strhdr domain;		/**< Domain we wish to authenticate in */
-        strhdr workstation;	/**< Client workstation name */
-        char payload[256];	/**< String data */
-    } ntlm_negotiate;
+/** Negotiation request sent by client */
+typedef struct _ntlm_negotiate {
+    ntlmhdr hdr;        /**< "NTLMSSP" , LSWAP(0x1) */
+    uint32_t flags; /**< Request flags */
+    strhdr domain;      /**< Domain we wish to authenticate in */
+    strhdr workstation; /**< Client workstation name */
+    char payload[256];  /**< String data */
+} ntlm_negotiate;
 
-    /* ************************************************************************* */
-    /* Challenge Packet structures and functions */
-    /* ************************************************************************* */
+/* ************************************************************************* */
+/* Challenge Packet structures and functions */
+/* ************************************************************************* */
 
 #define NTLM_NONCE_LEN 8
 
-    /* challenge request flags */
+/* challenge request flags */
 #define NTLM_CHALLENGE_TARGET_IS_DOMAIN     0x10000
 #define NTLM_CHALLENGE_TARGET_IS_SERVER     0x20000
 #define NTLM_CHALLENGE_TARGET_IS_SHARE      0x40000
 
-    /** Challenge request sent by server. */
-    typedef struct _ntlm_challenge {
-        ntlmhdr hdr;		/**< "NTLMSSP" , LSWAP(0x2) */
-        strhdr target;		/**< Authentication target (domain/server ...) */
-        uint32_t flags;		/**< Request flags */
-        u_char challenge[NTLM_NONCE_LEN];	/**< Challenge string */
-        uint32_t context_low;	/**< LS part of the server context handle */
-        uint32_t context_high;	/**< MS part of the server context handle */
-        char payload[256];		/**< String data */
-    } ntlm_challenge;
-
-    /* Size of the ntlm_challenge structures formatted fields (excluding payload) */
-#define NTLM_CHALLENGE_HEADER_OFFSET	(sizeof(ntlm_challenge)-256)
-
-    /** Generate a challenge request nonce. */
-    void ntlm_make_nonce(char *nonce);
-
-    /** Generate a challenge request Blob to be sent to the client.
-     * Will silently truncate the domain value at 2^16-1 bytes if larger.
-     */
-    void ntlm_make_challenge(ntlm_challenge *ch,
-                             const char *domain,
-                             const char *domain_controller,
-                             const char *challenge_nonce,
-                             const int challenge_nonce_len,
-                             const uint32_t flags);
-
-    /* ************************************************************************* */
-    /* Authenticate Packet structures and functions */
-    /* ************************************************************************* */
-
-    /** Authentication request sent by client in response to challenge */
-    typedef struct _ntlm_authenticate {
-        ntlmhdr hdr;		/**< "NTLMSSP" , LSWAP(0x3) */
-        strhdr lmresponse;		/**< LANMAN challenge response */
-        strhdr ntresponse;		/**< NT challenge response */
-        strhdr domain;		/**< Domain to authenticate against */
-        strhdr user;		/**< Username */
-        strhdr workstation;		/**< Workstation name */
-        strhdr sessionkey;		/**< Session key for server's use */
-        uint32_t flags;		/**< Request flags */
-        char payload[256 * 6];	/**< String data */
-    } ntlm_authenticate;
-
-    /** Unpack username and domain out of a packet payload. */
-    int ntlm_unpack_auth(const ntlm_authenticate *auth,
-                         char *user,
-                         char *domain,
-                         const int32_t size);
+/** Challenge request sent by server. */
+typedef struct _ntlm_challenge {
+    ntlmhdr hdr;        /**< "NTLMSSP" , LSWAP(0x2) */
+    strhdr target;      /**< Authentication target (domain/server ...) */
+    uint32_t flags;     /**< Request flags */
+    u_char challenge[NTLM_NONCE_LEN];   /**< Challenge string */
+    uint32_t context_low;   /**< LS part of the server context handle */
+    uint32_t context_high;  /**< MS part of the server context handle */
+    char payload[256];      /**< String data */
+} ntlm_challenge;
+
+/* Size of the ntlm_challenge structures formatted fields (excluding payload) */
+#define NTLM_CHALLENGE_HEADER_OFFSET    (sizeof(ntlm_challenge)-256)
+
+/** Generate a challenge request nonce. */
+void ntlm_make_nonce(char *nonce);
+
+/** Generate a challenge request Blob to be sent to the client.
+ * Will silently truncate the domain value at 2^16-1 bytes if larger.
+ */
+void ntlm_make_challenge(ntlm_challenge *ch,
+                         const char *domain,
+                         const char *domain_controller,
+                         const char *challenge_nonce,
+                         const int challenge_nonce_len,
+                         const uint32_t flags);
+
+/* ************************************************************************* */
+/* Authenticate Packet structures and functions */
+/* ************************************************************************* */
+
+/** Authentication request sent by client in response to challenge */
+typedef struct _ntlm_authenticate {
+    ntlmhdr hdr;        /**< "NTLMSSP" , LSWAP(0x3) */
+    strhdr lmresponse;      /**< LANMAN challenge response */
+    strhdr ntresponse;      /**< NT challenge response */
+    strhdr domain;      /**< Domain to authenticate against */
+    strhdr user;        /**< Username */
+    strhdr workstation;     /**< Workstation name */
+    strhdr sessionkey;      /**< Session key for server's use */
+    uint32_t flags;     /**< Request flags */
+    char payload[256 * 6];  /**< String data */
+} ntlm_authenticate;
+
+/** Unpack username and domain out of a packet payload. */
+int ntlm_unpack_auth(const ntlm_authenticate *auth,
+                     char *user,
+                     char *domain,
+                     const int32_t size);
 
 #if __cplusplus
 }
 #endif
 
 #endif /* SQUID_NTLMAUTH_H */
+
@@ -106,3 +106,4 @@ hex_dump(unsigned char *data, int size)
 }
 
 #endif /* SQUID_LIBNTLMAUTH_SUPPORT_BITS_CCI */
+
@@ -93,3 +93,4 @@
 #endif
 
 #endif /* SQUID_LIB_NTLMAUTH_SUPPORT_ENDIAN_H */
+
@@ -110,10 +110,10 @@ TimersArray *xprof_Timers = NULL;
 /* Private stuff */
 
 /* new stuff */
-#define	MAXSTACKDEPTH	512
+#define MAXSTACKDEPTH   512
 
 struct _callstack_entry {
-    int timer;		/* index into timers array */
+    int timer;      /* index into timers array */
     const char *name;
     hrtime_t start, stop, accum;
 };
@@ -213,3 +213,4 @@ xprof_stop(xprof_type type, const char *timer)
 }
 
 #endif /* USE_XPROF_STATS */
+
@@ -28,36 +28,36 @@ extern "C" {
 
 #define XP_NOBEST (hrtime_t)-1
 
-    typedef struct _xprof_stats_node xprof_stats_node;
+typedef struct _xprof_stats_node xprof_stats_node;
 
-    typedef struct _xprof_stats_data xprof_stats_data;
+typedef struct _xprof_stats_data xprof_stats_data;
 
-    struct _xprof_stats_data {
-        hrtime_t start;
-        hrtime_t stop;
-        hrtime_t delta;
-        hrtime_t best;
-        hrtime_t worst;
-        hrtime_t count;
-        hrtime_t accum;
-        int64_t summ;
-    };
+struct _xprof_stats_data {
+    hrtime_t start;
+    hrtime_t stop;
+    hrtime_t delta;
+    hrtime_t best;
+    hrtime_t worst;
+    hrtime_t count;
+    hrtime_t accum;
+    int64_t summ;
+};
 
-    struct _xprof_stats_node {
-        const char *name;
-        xprof_stats_data accu;
-        xprof_stats_data hist;
-    };
+struct _xprof_stats_node {
+    const char *name;
+    xprof_stats_data accu;
+    xprof_stats_data hist;
+};
 
-    typedef xprof_stats_node TimersArray[1];
+typedef xprof_stats_node TimersArray[1];
 
-    /* public Data */
-    extern TimersArray *xprof_Timers;
+/* public Data */
+extern TimersArray *xprof_Timers;
 
-    /* Exported functions */
-    extern void xprof_start(xprof_type type, const char *timer);
-    extern void xprof_stop(xprof_type type, const char *timer);
-    extern void xprof_event(void *data);
+/* Exported functions */
+extern void xprof_start(xprof_type type, const char *timer);
+extern void xprof_stop(xprof_type type, const char *timer);
+extern void xprof_event(void *data);
 
 #define PROF_start(probename) xprof_start(XPROF_##probename, #probename)
 #define PROF_stop(probename) xprof_stop(XPROF_##probename, #probename)
@@ -68,3 +68,4 @@ extern "C" {
 }
 #endif
 #endif /* _PROFILING_H_ */
+
@@ -25,7 +25,7 @@ get_tick(void)
 {
     hrtime_t regs;
 
-asm volatile ("rdtsc":"=A" (regs));
+    asm volatile ("rdtsc":"=A" (regs));
     return regs;
     /* We need return value, we rely on CC to optimise out needless subf calls */
     /* Note that "rdtsc" is relatively slow OP and stalls the CPU pipes, so use it wisely */
@@ -38,7 +38,7 @@ get_tick(void)
     uint32_t lo, hi;
     // Based on an example in Wikipedia
     /* We cannot use "=A", since this would use %rax on x86_64 */
-asm volatile ("rdtsc" : "=a" (lo), "=d" (hi));
+    asm volatile ("rdtsc" : "=a" (lo), "=d" (hi));
     return (hrtime_t)hi << 32 | lo;
 }
 
@@ -48,7 +48,7 @@ get_tick(void)
 {
     hrtime_t regs;
 
-asm volatile ("rpcc %0" : "=r" (regs));
+    asm volatile ("rpcc %0" : "=r" (regs));
     return regs;
 }
 
@@ -75,3 +75,4 @@ get_tick(void)
 
 #endif /* USE_XPROF_STATS */
 #endif /* _PROFILING_H_ */
+
@@ -10,77 +10,79 @@
 /* AUTO-GENERATED FILE */
 #if USE_XPROF_STATS
 typedef enum {
-  XPROF_PROF_UNACCOUNTED,
-XPROF_aclCheckFast,
-XPROF_ACL_matches,
-XPROF_calloc,
-XPROF_clientSocketRecipient,
-XPROF_comm_accept,
-XPROF_comm_check_incoming,
-XPROF_comm_close,
-XPROF_comm_connect_addr,
-XPROF_comm_handle_ready_fd,
-XPROF_commHandleWrite,
-XPROF_comm_open,
-XPROF_comm_poll_normal,
-XPROF_comm_poll_prep_pfds,
-XPROF_comm_read_handler,
-XPROF_comm_udp_sendto,
-XPROF_comm_write_handler,
-XPROF_diskHandleRead,
-XPROF_diskHandleWrite,
-XPROF_esiExpressionEval,
-XPROF_esiParsing,
-XPROF_esiProcessing,
-XPROF_eventRun,
-XPROF_file_close,
-XPROF_file_open,
-XPROF_file_read,
-XPROF_file_write,
-XPROF_free,
-XPROF_free_const,
-XPROF_hash_lookup,
-XPROF_headersEnd,
-XPROF_HttpHeaderClean,
-XPROF_HttpHeader_getCc,
-XPROF_HttpHeaderParse,
-XPROF_HttpMsg_httpMsgParseStep,
-XPROF_HttpParserParseReqLine,
-XPROF_httpRequestFree,
-XPROF_HttpServer_parseOneRequest,
-XPROF_httpStart,
-XPROF_HttpStateData_processReplyBody,
-XPROF_HttpStateData_processReplyHeader,
-XPROF_InvokeHandlers,
-XPROF_malloc,
-XPROF_MemBuf_append,
-XPROF_MemBuf_consume,
-XPROF_MemBuf_consumeWhitespace,
-XPROF_MemBuf_grow,
-XPROF_mem_hdr_write,
-XPROF_MemObject_write,
-XPROF_PROF_OVERHEAD,
-XPROF_read,
-XPROF_realloc,
-XPROF_recv,
-XPROF_send,
-XPROF_SignalEngine_checkEvents,
-XPROF_storeClient_kickReads,
-XPROF_storeDirCallback,
-XPROF_StoreEntry_write,
-XPROF_storeGet,
-XPROF_storeGetMemSpace,
-XPROF_storeMaintainSwapSpace,
-XPROF_storeRelease,
-XPROF_StringAllocAndFill,
-XPROF_StringAppend,
-XPROF_StringClean,
-XPROF_StringInitBuf,
-XPROF_StringReset,
-XPROF_write,
-XPROF_xcalloc,
-XPROF_xmalloc,
-XPROF_xrealloc,
-  XPROF_LAST } xprof_type;
+    XPROF_PROF_UNACCOUNTED,
+    XPROF_aclCheckFast,
+    XPROF_ACL_matches,
+    XPROF_calloc,
+    XPROF_clientSocketRecipient,
+    XPROF_comm_accept,
+    XPROF_comm_check_incoming,
+    XPROF_comm_close,
+    XPROF_comm_connect_addr,
+    XPROF_comm_handle_ready_fd,
+    XPROF_commHandleWrite,
+    XPROF_comm_open,
+    XPROF_comm_poll_normal,
+    XPROF_comm_poll_prep_pfds,
+    XPROF_comm_read_handler,
+    XPROF_comm_udp_sendto,
+    XPROF_comm_write_handler,
+    XPROF_diskHandleRead,
+    XPROF_diskHandleWrite,
+    XPROF_esiExpressionEval,
+    XPROF_esiParsing,
+    XPROF_esiProcessing,
+    XPROF_eventRun,
+    XPROF_file_close,
+    XPROF_file_open,
+    XPROF_file_read,
+    XPROF_file_write,
+    XPROF_free,
+    XPROF_free_const,
+    XPROF_hash_lookup,
+    XPROF_headersEnd,
+    XPROF_HttpHeaderClean,
+    XPROF_HttpHeader_getCc,
+    XPROF_HttpHeaderParse,
+    XPROF_HttpMsg_httpMsgParseStep,
+    XPROF_HttpParserParseReqLine,
+    XPROF_httpRequestFree,
+    XPROF_HttpServer_parseOneRequest,
+    XPROF_httpStart,
+    XPROF_HttpStateData_processReplyBody,
+    XPROF_HttpStateData_processReplyHeader,
+    XPROF_InvokeHandlers,
+    XPROF_malloc,
+    XPROF_MemBuf_append,
+    XPROF_MemBuf_consume,
+    XPROF_MemBuf_consumeWhitespace,
+    XPROF_MemBuf_grow,
+    XPROF_mem_hdr_write,
+    XPROF_MemObject_write,
+    XPROF_PROF_OVERHEAD,
+    XPROF_read,
+    XPROF_realloc,
+    XPROF_recv,
+    XPROF_send,
+    XPROF_SignalEngine_checkEvents,
+    XPROF_storeClient_kickReads,
+    XPROF_storeDirCallback,
+    XPROF_StoreEntry_write,
+    XPROF_storeGet,
+    XPROF_storeGetMemSpace,
+    XPROF_storeMaintainSwapSpace,
+    XPROF_storeRelease,
+    XPROF_StringAllocAndFill,
+    XPROF_StringAppend,
+    XPROF_StringClean,
+    XPROF_StringInitBuf,
+    XPROF_StringReset,
+    XPROF_write,
+    XPROF_xcalloc,
+    XPROF_xmalloc,
+    XPROF_xrealloc,
+    XPROF_LAST
+} xprof_type;
 #endif
 #endif
+
@@ -95,19 +95,19 @@ static char *rn_zeros, *rn_ones;
 #define rn_l rn_u.rn_node.rn_L
 #define rn_r rn_u.rn_node.rn_R
 #define rm_mask rm_rmu.rmu_mask
-#define rm_leaf rm_rmu.rmu_leaf	/* extra field would make 32 bytes */
+#define rm_leaf rm_rmu.rmu_leaf /* extra field would make 32 bytes */
 
 /* Helper macros */
 #define squid_Bcmp(a, b, l) (l == 0 ? 0 : memcmp((caddr_t)(a), (caddr_t)(b), (u_long)l))
 #define squid_R_Malloc(p, t, n) (p = (t) xmalloc((unsigned int)(n)))
 #define squid_Free(p) xfree((char *)p)
 #define squid_MKGet(m) {\
-	if (squid_rn_mkfreelist) {\
-		m = squid_rn_mkfreelist; \
-		squid_rn_mkfreelist = (m)->rm_mklist; \
-	} else \
-		squid_R_Malloc(m, struct squid_radix_mask *, sizeof (*(m)));\
-	}
+    if (squid_rn_mkfreelist) {\
+        m = squid_rn_mkfreelist; \
+        squid_rn_mkfreelist = (m)->rm_mklist; \
+    } else \
+        squid_R_Malloc(m, struct squid_radix_mask *, sizeof (*(m)));\
+    }
 
 #define squid_MKFree(m) { (m)->rm_mklist = squid_rn_mkfreelist; squid_rn_mkfreelist = (m);}
 
@@ -288,7 +288,7 @@ squid_rn_match(void *v_arg, struct squid_radix_node_head *head) {
         t = t->rn_dupedkey;
     return t;
 on1:
-    test = (*cp ^ *cp2) & 0xff;	/* find first bit that differs */
+    test = (*cp ^ *cp2) & 0xff; /* find first bit that differs */
     for (b = 7; (test >>= 1) > 0;)
         b--;
     matched_off = cp - v;
@@ -405,7 +405,7 @@ squid_rn_insert(void *v_arg, struct squid_radix_node_head *head, int *dupentry,
                 x = x->rn_r;
             else
                 x = x->rn_l;
-        } while (b > (unsigned) x->rn_b);	/* x->rn_b < b && x->rn_b >= 0 */
+        } while (b > (unsigned) x->rn_b);   /* x->rn_b < b && x->rn_b >= 0 */
 #ifdef RN_DEBUG
         if (rn_debug)
             fprintf(stderr, "squid_rn_insert: Going In:\n");
@@ -418,7 +418,7 @@ squid_rn_insert(void *v_arg, struct squid_radix_node_head *head, int *dupentry,
         else
             p->rn_r = t;
         x->rn_p = t;
-        t->rn_p = p;		/* frees x, p as temp vars below */
+        t->rn_p = p;        /* frees x, p as temp vars below */
         if ((cp[t->rn_off] & t->rn_bmask) == 0) {
             t->rn_r = x;
         } else {
@@ -504,13 +504,13 @@ squid_rn_addmask(void *n_arg, int search, int skip) {
     return (x);
 }
 
-static int			/* XXX: arbitrary ordering for non-contiguous masks */
+static int          /* XXX: arbitrary ordering for non-contiguous masks */
 rn_lexobetter(void *m_arg, void *n_arg)
 {
     register u_char *mp = m_arg, *np = n_arg, *lim;
 
     if (*mp > *np)
-        return 1;		/* not really, but need to check longer one first */
+        return 1;       /* not really, but need to check longer one first */
     if (*mp == *np)
         for (lim = mp + *mp; mp < lim;)
             if (*mp++ > *np++)
@@ -573,7 +573,7 @@ squid_rn_addroute(void *v_arg, void *n_arg, struct squid_radix_node_head *head,
                 return (0);
             if (netmask == 0 ||
                     (tt->rn_mask &&
-                     ((b_leaf < tt->rn_b) ||	/* index(netmask) > node */
+                     ((b_leaf < tt->rn_b) ||    /* index(netmask) > node */
                       squid_rn_refines(netmask, tt->rn_mask) ||
                       rn_lexobetter(netmask, tt->rn_mask))))
                 break;
@@ -654,7 +654,7 @@ squid_rn_addroute(void *v_arg, void *n_arg, struct squid_radix_node_head *head,
 on2:
     /* Add new route to highest possible ancestor's list */
     if ((netmask == 0) || (b > t->rn_b))
-        return tt;		/* can't lift at all */
+        return tt;      /* can't lift at all */
     b_leaf = tt->rn_b;
     do {
         x = t;
@@ -727,7 +727,7 @@ squid_rn_delete(void *v_arg, void *netmask_arg, struct squid_radix_node_head *he
     if (tt->rn_flags & RNF_NORMAL) {
         if (m->rm_leaf != tt || m->rm_refs > 0) {
             fprintf(stderr, "squid_rn_delete: inconsistent annotation\n");
-            return 0;		/* dangling ref could cause disaster */
+            return 0;       /* dangling ref could cause disaster */
         }
     } else {
         if (m->rm_mask != tt->rn_mask) {
@@ -740,7 +740,7 @@ squid_rn_delete(void *v_arg, void *netmask_arg, struct squid_radix_node_head *he
     b = -1 - tt->rn_b;
     t = saved_tt->rn_p;
     if (b > t->rn_b)
-        goto on1;		/* Wasn't lifted at all */
+        goto on1;       /* Wasn't lifted at all */
     do {
         x = t;
         t = t->rn_p;
@@ -754,7 +754,7 @@ squid_rn_delete(void *v_arg, void *netmask_arg, struct squid_radix_node_head *he
     if (m == 0) {
         fprintf(stderr, "squid_rn_delete: couldn't find our annotation\n");
         if (tt->rn_flags & RNF_NORMAL)
-            return (0);		/* Dangling ref to us */
+            return (0);     /* Dangling ref to us */
     }
 on1:
     /*
@@ -968,3 +968,4 @@ squid_rn_init(void)
         exit(-1);
     }
 }
+
@@ -261,7 +261,7 @@ rfc1035NameUnpack(const char *buf, size_t sz, unsigned int *off, unsigned short
             /* blasted compression */
             unsigned short s;
             unsigned int ptr;
-            if (rdepth > 64) {	/* infinite pointer loop */
+            if (rdepth > 64) {  /* infinite pointer loop */
                 RFC1035_UNPACK_DEBUG;
                 return 1;
             }
@@ -291,11 +291,11 @@ rfc1035NameUnpack(const char *buf, size_t sz, unsigned int *off, unsigned short
             len = (size_t) c;
             if (len == 0)
                 break;
-            if (len > (ns - no - 1)) {	/* label won't fit */
+            if (len > (ns - no - 1)) {  /* label won't fit */
                 RFC1035_UNPACK_DEBUG;
                 return 1;
             }
-            if ((*off) + len >= sz) {	/* message is too short */
+            if ((*off) + len >= sz) {   /* message is too short */
                 RFC1035_UNPACK_DEBUG;
                 return 1;
             }
@@ -420,7 +420,7 @@ rfc1035RRUnpack(const char *buf, size_t sz, unsigned int *off, rfc1035_rr * RR)
     case RFC1035_TYPE_PTR:
         RR->rdata = (char*)xmalloc(RFC1035_MAXHOSTNAMESZ);
         rdata_off = *off;
-        RR->rdlength = 0;	/* Filled in by rfc1035NameUnpack */
+        RR->rdlength = 0;   /* Filled in by rfc1035NameUnpack */
         if (rfc1035NameUnpack(buf, sz, &rdata_off, &RR->rdlength, RR->rdata, RFC1035_MAXHOSTNAMESZ, 0)) {
             RFC1035_UNPACK_DEBUG;
             return 1;
@@ -630,11 +630,11 @@ rfc1035MessageUnpack(const char *buf,
     i = (unsigned int) msg->ancount;
     recs = msg->answer = (rfc1035_rr*)xcalloc(i, sizeof(*recs));
     for (j = 0; j < i; j++) {
-        if (off >= sz) {	/* corrupt packet */
+        if (off >= sz) {    /* corrupt packet */
             RFC1035_UNPACK_DEBUG;
             break;
         }
-        if (rfc1035RRUnpack(buf, sz, &off, &recs[j])) {		/* corrupt RR */
+        if (rfc1035RRUnpack(buf, sz, &off, &recs[j])) {     /* corrupt RR */
             RFC1035_UNPACK_DEBUG;
             break;
         }
@@ -671,7 +671,7 @@ rfc1035BuildAQuery(const char *hostname, char *buf, size_t sz, unsigned short qi
     h.id = qid;
     h.qr = 0;
     h.rd = 1;
-    h.opcode = 0;		/* QUERY */
+    h.opcode = 0;       /* QUERY */
     h.qdcount = (unsigned int) 1;
     h.arcount = (edns_sz > 0 ? 1 : 0);
     offset += rfc1035HeaderPack(buf + offset, sz - offset, &h);
@@ -718,7 +718,7 @@ rfc1035BuildPTRQuery(const struct in_addr addr, char *buf, size_t sz, unsigned s
     h.id = qid;
     h.qr = 0;
     h.rd = 1;
-    h.opcode = 0;		/* QUERY */
+    h.opcode = 0;       /* QUERY */
     h.qdcount = (unsigned int) 1;
     h.arcount = (edns_sz > 0 ? 1 : 0);
     offset += rfc1035HeaderPack(buf + offset, sz - offset, &h);
@@ -840,3 +840,4 @@ main(int argc, char *argv[])
     return 0;
 }
 #endif
+
@@ -191,7 +191,7 @@ parse_rfc1123(const char *str)
 #if defined(_timezone) || _SQUID_WINDOWS_
         t -= (_timezone + dst);
 #else
-    t -= (timezone + dst);
+        t -= (timezone + dst);
 #endif
     }
 #endif
@@ -226,3 +226,4 @@ main()
 }
 
 #endif
+
@@ -18,34 +18,34 @@
  *  any non-US-ASCII character or anything between 0x00 - 0x1F.
  */
 static char rfc1738_unsafe_chars[] = {
-    (char) 0x3C,		/* < */
-    (char) 0x3E,		/* > */
-    (char) 0x22,		/* " */
-    (char) 0x23,		/* # */
-#if 0				/* done in code */
-    (char) 0x20,		/* space */
-    (char) 0x25,		/* % */
+    (char) 0x3C,        /* < */
+    (char) 0x3E,        /* > */
+    (char) 0x22,        /* " */
+    (char) 0x23,        /* # */
+#if 0               /* done in code */
+    (char) 0x20,        /* space */
+    (char) 0x25,        /* % */
 #endif
-    (char) 0x7B,		/* { */
-    (char) 0x7D,		/* } */
-    (char) 0x7C,		/* | */
-    (char) 0x5C,		/* \ */
-    (char) 0x5E,		/* ^ */
-    (char) 0x7E,		/* ~ */
-    (char) 0x5B,		/* [ */
-    (char) 0x5D,		/* ] */
-    (char) 0x60,		/* ` */
-    (char) 0x27 		/* ' */
+    (char) 0x7B,        /* { */
+    (char) 0x7D,        /* } */
+    (char) 0x7C,        /* | */
+    (char) 0x5C,        /* \ */
+    (char) 0x5E,        /* ^ */
+    (char) 0x7E,        /* ~ */
+    (char) 0x5B,        /* [ */
+    (char) 0x5D,        /* ] */
+    (char) 0x60,        /* ` */
+    (char) 0x27         /* ' */
 };
 
 static char rfc1738_reserved_chars[] = {
-    (char) 0x3b,		/* ; */
-    (char) 0x2f,		/* / */
-    (char) 0x3f,		/* ? */
-    (char) 0x3a,		/* : */
-    (char) 0x40,		/* @ */
-    (char) 0x3d,		/* = */
-    (char) 0x26			/* & */
+    (char) 0x3b,        /* ; */
+    (char) 0x2f,        /* / */
+    (char) 0x3f,        /* ? */
+    (char) 0x3a,        /* : */
+    (char) 0x40,        /* @ */
+    (char) 0x3d,        /* = */
+    (char) 0x26         /* & */
 };
 
 /*
@@ -145,13 +145,13 @@ fromhex(char ch)
 void
 rfc1738_unescape(char *s)
 {
-    int i, j;			/* i is write, j is read */
+    int i, j;           /* i is write, j is read */
     for (i = j = 0; s[j]; i++, j++) {
         s[i] = s[j];
         if (s[j] != '%') {
             /* normal case, nothing more to do */
-        } else if (s[j + 1] == '%') {	/* %% case */
-            j++;		/* Skip % */
+        } else if (s[j + 1] == '%') {   /* %% case */
+            j++;        /* Skip % */
         } else {
             /* decode */
             int v1, v2, x;
@@ -170,3 +170,4 @@ rfc1738_unescape(char *s)
     }
     s[i] = '\0';
 }
+
@@ -103,7 +103,7 @@ DigestCalcHA1(
     }
     if (strcasecmp(pszAlg, "md5-sess") == 0) {
         HASHHEX HA1Hex;
-        CvtHex(HA1, HA1Hex);	/* RFC2617 errata */
+        CvtHex(HA1, HA1Hex);    /* RFC2617 errata */
         SquidMD5Init(&Md5Ctx);
         SquidMD5Update(&Md5Ctx, HA1Hex, HASHHEXLEN);
         SquidMD5Update(&Md5Ctx, ":", 1);
@@ -118,15 +118,15 @@ DigestCalcHA1(
 /* calculate request-digest/response-digest as per HTTP Digest spec */
 void
 DigestCalcResponse(
-    const HASHHEX HA1,		/* H(A1) */
-    const char *pszNonce,	/* nonce from server */
-    const char *pszNonceCount,	/* 8 hex digits */
-    const char *pszCNonce,	/* client nonce */
-    const char *pszQop,		/* qop-value: "", "auth", "auth-int" */
-    const char *pszMethod,	/* method from the request */
-    const char *pszDigestUri,	/* requested URL */
-    const HASHHEX HEntity,	/* H(entity body) if qop="auth-int" */
-    HASHHEX Response		/* request-digest or response-digest */
+    const HASHHEX HA1,      /* H(A1) */
+    const char *pszNonce,   /* nonce from server */
+    const char *pszNonceCount,  /* 8 hex digits */
+    const char *pszCNonce,  /* client nonce */
+    const char *pszQop,     /* qop-value: "", "auth", "auth-int" */
+    const char *pszMethod,  /* method from the request */
+    const char *pszDigestUri,   /* requested URL */
+    const HASHHEX HEntity,  /* H(entity body) if qop="auth-int" */
+    HASHHEX Response        /* request-digest or response-digest */
 )
 {
     SquidMD5_CTX Md5Ctx;
@@ -166,3 +166,4 @@ DigestCalcResponse(
     SquidMD5Final((unsigned char *) RespHash, &Md5Ctx);
     CvtHex(RespHash, Response);
 }
+
@@ -26,3 +26,4 @@ rfc2671RROptPack(char *buf, size_t sz, ssize_t edns_sz)
 
     return rfc1035RRPack(buf, sz, &opt);
 }
+
@@ -171,7 +171,7 @@ rfc3596BuildPTRQuery6(const struct in6_addr addr, char *buf, size_t sz, unsigned
 int
 main(int argc, char *argv[])
 {
-#define PACKET_BUFSZ		1024
+#define PACKET_BUFSZ        1024
     char input[PACKET_BUFSZ];
     char buf[PACKET_BUFSZ];
     char rbuf[PACKET_BUFSZ];
@@ -336,3 +336,4 @@ return 0;
 }
 
 #endif
+
@@ -86,3 +86,4 @@
 #define RIVAL(buf,pos) IREV(IVAL(buf,pos))
 #define RSSVAL(buf,pos,val) SSVAL(buf,pos,SREV(val))
 #define RSIVAL(buf,pos,val) SIVAL(buf,pos,IREV(val))
+
@@ -37,17 +37,18 @@
 extern "C" {
 #endif
 
-    /* A data structure we need */
+/* A data structure we need */
 
-    typedef struct RFCNB_Pkt {
+typedef struct RFCNB_Pkt {
 
-        char *data;             /* The data in this portion */
-        int len;
-        struct RFCNB_Pkt *next;
+    char *data;             /* The data in this portion */
+    int len;
+    struct RFCNB_Pkt *next;
 
-    } RFCNB_Pkt;
+} RFCNB_Pkt;
 
 #if defined(__cplusplus)
 }
 #endif
 #endif /* _RFCNB_RFCNB_COMMON_H */
+
@@ -37,12 +37,12 @@
 extern "C" {
 #endif
 
-    /* Error responses */
+/* Error responses */
 
 #define RFCNBE_Bad -1           /* Bad response */
 #define RFCNBE_OK 0
 
-    /* these should follow the spec ... is there one ? */
+/* these should follow the spec ... is there one ? */
 
 #define RFCNBE_NoSpace 1        /* Could not allocate space for a struct */
 #define RFCNBE_BadName 2        /* Could not translate a name            */
@@ -61,12 +61,13 @@ extern "C" {
 #define RFCNBE_BadParam      15 /* Bad parameters passed ...             */
 #define RFCNBE_Timeout       16 /* IO Timed out                          */
 
-    /* Text strings for the error responses                                 */
+/* Text strings for the error responses                                 */
 
-    extern const char *RFCNB_Error_Strings[];
+extern const char *RFCNB_Error_Strings[];
 
 #ifdef __cplusplus
 }
 
 #endif
 #endif                          /* _RFCNB_ERROR_H_ */
+
@@ -120,12 +120,12 @@ RFCNB_Set_Timeout(int seconds)
         if (sigaction(SIGALRM, &inact, &outact) < 0)
             return (-1);
 #else /* !HAVE_SIGACTION */
-    invec.sv_handler = (void (*)()) rfcnb_alarm;
-    invec.sv_mask = 0;
-    invec.sv_flags = SV_INTERRUPT;
+        invec.sv_handler = (void (*)()) rfcnb_alarm;
+        invec.sv_mask = 0;
+        invec.sv_flags = SV_INTERRUPT;
 
-    if (sigvec(SIGALRM, &invec, &outvec) < 0)
-        return (-1);
+        if (sigvec(SIGALRM, &invec, &outvec) < 0)
+            return (-1);
 #endif /* !HAVE_SIGACTION */
     }
 #endif /* !ORIGINAL_SAMBA_CODE ADAPTED SQUID CODE */
@@ -449,3 +449,4 @@ RFCNB_Get_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len)
 
     return (read_len + sizeof(RFCNB_Hdr));
 }
+
@@ -40,3 +40,4 @@ int RFCNB_Put_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len);
 int RFCNB_Get_Pkt(struct RFCNB_Con *con, struct RFCNB_Pkt *pkt, int len);
 
 #endif
+
@@ -160,3 +160,4 @@ extern int RFCNB_saved_errno;   /* Save this from point of error */
 #endif
 
 #endif /* _RFCNB_RFCNB_PRIV_H */
+
@@ -532,3 +532,4 @@ RFCNB_Session_Req(struct RFCNB_Con *con,
     RFCNB_Free_Pkt(pkt);
     return result;
 }
+
@@ -62,3 +62,4 @@ typedef void RFCNB_Prot_Print_Routine(FILE * fd, int dir, struct RFCNB_Pkt *pkt,
 extern RFCNB_Prot_Print_Routine *Prot_Print_Routine;
 
 #endif /* _RFCNB_RFCNB_UTIL_H */
+
@@ -42,37 +42,38 @@
 extern "C" {
 #endif
 
-    /* Defines we need */
+/* Defines we need */
 
 #define RFCNB_Default_Port 139
 
-    struct RFCNB_Con;
+struct RFCNB_Con;
 
-    /* Definition of routines we define */
+/* Definition of routines we define */
 
-    void *RFCNB_Call(char *Called_Name, char *Calling_Name, char *Called_Address,
-                     int port);
+void *RFCNB_Call(char *Called_Name, char *Calling_Name, char *Called_Address,
+                 int port);
 
-    int RFCNB_Send(struct RFCNB_Con *Con_Handle, struct RFCNB_Pkt *udata, int Length);
+int RFCNB_Send(struct RFCNB_Con *Con_Handle, struct RFCNB_Pkt *udata, int Length);
 
-    int RFCNB_Recv(void *Con_Handle, struct RFCNB_Pkt *Data, int Length);
+int RFCNB_Recv(void *Con_Handle, struct RFCNB_Pkt *Data, int Length);
 
-    int RFCNB_Hangup(struct RFCNB_Con *con_Handle);
+int RFCNB_Hangup(struct RFCNB_Con *con_Handle);
 
-    void *RFCNB_Listen(void);
+void *RFCNB_Listen(void);
 
-    void RFCNB_Get_Error(char *buffer, int buf_len);
+void RFCNB_Get_Error(char *buffer, int buf_len);
 
-    int RFCNB_Get_Last_Error(void);
+int RFCNB_Get_Last_Error(void);
 
-    void RFCNB_Free_Pkt(struct RFCNB_Pkt *pkt);
+void RFCNB_Free_Pkt(struct RFCNB_Pkt *pkt);
 
-    int RFCNB_Set_Sock_NoDelay(struct RFCNB_Con *con_Handle, int yn);
+int RFCNB_Set_Sock_NoDelay(struct RFCNB_Con *con_Handle, int yn);
 
-    struct RFCNB_Pkt *RFCNB_Alloc_Pkt(int n);
+struct RFCNB_Pkt *RFCNB_Alloc_Pkt(int n);
 
 #ifdef __cplusplus
 }
 
 #endif
 #endif                          /* _RFCNB_RFCNB_H */
+
@@ -330,3 +330,4 @@ RFCNB_Get_Last_Error()
 {
     return (RFCNB_errno);
 }
+
@@ -62,3 +62,4 @@ typedef short int16;
 #endif
 
 #endif /* _RFCNB_STD_INCLUDES_H */
+
@@ -371,7 +371,7 @@ int SMB_Logon_TCon_Open(SMB_Handle_Type Con_Handle, char *UserName,
 {
     struct RFCNB_Pkt *pkt;
     int param_len, i, pkt_len, tcon_len, tcon_param_len, open_len,
-    open_param_len, header_len;
+        open_param_len, header_len;
     struct SMB_File_Def *file_tmp;
     SMB_Tree_Handle tree;
     char *p, *AndXCom;
@@ -1323,3 +1323,4 @@ int SMB_Search(SMB_Tree_Handle tree,
     return(ret_count);
 
 }
+
@@ -288,3 +288,4 @@ main(int argc, char *argv[])
     fprintf(stderr, "Passwords exhausted.");
 
 }
+
@@ -220,3 +220,4 @@ mdfour(unsigned char *out, unsigned char *in, int n)
 
     A = B = C = D = 0;
 }
+
@@ -12,3 +12,4 @@
 extern void mdfour(unsigned char *out, unsigned char *in, int n);
 
 #endif /* __SMB_LM_SMBVAL_MD4_H */
+
@@ -226,3 +226,4 @@ int SMB_Get_SMB_Error_Msg(int err_class, int err_code, char *msg_buf, int len)
     return(strlen(msg_buf));
 
 }
+
@@ -125,49 +125,57 @@ static int sbox[8][4][16] = {
         {14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7},
         {0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8},
         {4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0},
-        {15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13}},
+        {15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13}
+    },
 
     {
         {15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10},
         {3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5},
         {0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15},
-        {13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9}},
+        {13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9}
+    },
 
     {
         {10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8},
         {13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1},
         {13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7},
-        {1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12}},
+        {1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12}
+    },
 
     {
         {7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15},
         {13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9},
         {10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4},
-        {3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14}},
+        {3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14}
+    },
 
     {
         {2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9},
         {14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6},
         {4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14},
-        {11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3}},
+        {11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3}
+    },
 
     {
         {12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11},
         {10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8},
         {9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6},
-        {4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13}},
+        {4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13}
+    },
 
     {
         {4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1},
         {13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6},
         {1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2},
-        {6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12}},
+        {6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12}
+    },
 
     {
         {13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7},
         {1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2},
         {7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8},
-        {2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11}}
+        {2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11}
+    }
 };
 
 static void
@@ -368,3 +376,4 @@ cred_hash2(unsigned char *out, unsigned char *in, unsigned char *key)
     key2[0] = key[7];
     smbhash(out, buf, key2);
 }
+
@@ -11,3 +11,4 @@ void E_P16(unsigned char *p14, unsigned char *p16);
 void E_P24(unsigned char *p21, unsigned char *c8, unsigned char *p24);
 void cred_hash1(unsigned char *out, unsigned char *in, unsigned char *key);
 void cred_hash2(unsigned char *out, unsigned char *in, unsigned char *key);
+
@@ -127,7 +127,7 @@ E_md4hash(uchar * passwd, uchar * p16)
         len = 128;
     /* Password must be converted to NT unicode */
     _my_mbstowcs(wpwd, passwd, len);
-    wpwd[len] = 0;		/* Ensure string is null terminated */
+    wpwd[len] = 0;      /* Ensure string is null terminated */
     /* Calculate length in bytes */
     len = _my_wcslen(wpwd) * sizeof(int16_t);
 
@@ -219,3 +219,4 @@ strupper(char *s)
         }
     }
 }
+
@@ -13,11 +13,12 @@
 extern "C" {
 #endif
 
-    void SMBencrypt(unsigned char *passwd, unsigned char *c8, unsigned char *p24);
-    void SMBNTencrypt(unsigned char *passwd, unsigned char *c8, unsigned char *p24);
-    void nt_lm_owf_gen(char *pwd, char *nt_p16, char *p16);
+void SMBencrypt(unsigned char *passwd, unsigned char *c8, unsigned char *p24);
+void SMBNTencrypt(unsigned char *passwd, unsigned char *c8, unsigned char *p24);
+void nt_lm_owf_gen(char *pwd, char *nt_p16, char *p16);
 
 #ifdef __cplusplus
 }
 #endif
 #endif /* _SMBLIB_SMBENCRYPT_H */
+
@@ -388,3 +388,4 @@ int SMBapi_NetShareEnum(SMB_Tree_Handle tree, char *enum_buf, int bufsiz,
 {
 
 }
+
@@ -37,31 +37,31 @@
 extern "C" {
 #endif
 
-    /* To get the error class we want the first 8 bits */
-    /* Because we just grab 4bytes from the SMB header, we have to re-order */
-    /* here, but it makes the NtStatus part easier in future                */
+/* To get the error class we want the first 8 bits */
+/* Because we just grab 4bytes from the SMB header, we have to re-order */
+/* here, but it makes the NtStatus part easier in future                */
 
 #define SMBlib_Error_Class(p) (p & 0x000000FF)
 
-    /* To get the error code, we want the bottom 16 bits */
+/* To get the error code, we want the bottom 16 bits */
 
 #define SMBlib_Error_Code(p) (((unsigned int)p & 0xFFFF0000) >>16)
 
-    /* Error CLASS codes and etc ... */
+/* Error CLASS codes and etc ... */
 
 #define SMBC_SUCCESS        0
 #define SMBC_ERRDOS         0x01
 #define SMBC_ERRSRV         0x02
 #define SMBC_ERRHRD         0x03
 #define SMBC_ERRCMD         0xFF
 
-    /* Success error codes    */
+/* Success error codes    */
 
 #define SMBS_BUFFERED       0x54
 #define SMBS_LOGGED         0x55
 #define SMBS_DISPLAYED      0x56
 
-    /* ERRDOS Error codes     */
+/* ERRDOS Error codes     */
 
 #define SMBD_badfunc        0x01
 #define SMBD_badfile        0x02
@@ -85,7 +85,7 @@ extern "C" {
 #define SMBD_errlock        0x21
 #define SMBD_filexists      0x50
 
-    /* Server errors ... */
+/* Server errors ... */
 
 #define SMBV_error          0x01         /* Generic error */
 #define SMBV_badpw          0x02
@@ -104,7 +104,7 @@ extern "C" {
 #define SMBV_rmuns          0x57
 #define SMBV_nosupport      0xFFFF
 
-    /* Hardware error codes ... */
+/* Hardware error codes ... */
 
 #define SMBH_nowrite        0x13
 #define SMBH_badunit        0x14
@@ -121,7 +121,7 @@ extern "C" {
 #define SMBH_general        0x1F
 #define SMBH_badshare       0x20
 
-    /* Access mode defines ... */
+/* Access mode defines ... */
 
 #define SMB_AMODE_WTRU      0x4000
 #define SMB_AMODE_NOCACHE   0x1000
@@ -140,7 +140,7 @@ extern "C" {
 #define SMB_AMODE_LOCMRAN   0x0200
 #define SMB_AMODE_LOCRAL    0x0300
 
-    /* File attribute encoding ... */
+/* File attribute encoding ... */
 
 #define SMB_FA_ORD          0x00
 #define SMB_FA_ROF          0x01
@@ -150,7 +150,7 @@ extern "C" {
 #define SMB_FA_DIR          0x10
 #define SMB_FA_ARC          0x20
 
-    /* Define the protocol types ... */
+/* Define the protocol types ... */
 
 #define SMB_P_Unknown      -1        /* Hmmm, is this smart? */
 #define SMB_P_Core         0
@@ -163,13 +163,13 @@ extern "C" {
 #define SMB_P_LanMan2_1    7
 #define SMB_P_NT1          8
 
-    /* SMBlib return codes */
-    /* We want something that indicates whether or not the return code was a   */
-    /* remote error, a local error in SMBlib or returned from lower layer ...  */
-    /* Wonder if this will work ...                                            */
-    /* SMBlibE_Remote = 1 indicates remote error                               */
-    /* SMBlibE_ values < 0 indicate local error with more info available       */
-    /* SMBlibE_ values >1 indicate local from SMBlib code errors?              */
+/* SMBlib return codes */
+/* We want something that indicates whether or not the return code was a   */
+/* remote error, a local error in SMBlib or returned from lower layer ...  */
+/* Wonder if this will work ...                                            */
+/* SMBlibE_Remote = 1 indicates remote error                               */
+/* SMBlibE_ values < 0 indicate local error with more info available       */
+/* SMBlibE_ values >1 indicate local from SMBlib code errors?              */
 
 #define SMBlibE_Success 0
 #define SMBlibE_Remote  1    /* Remote error, get more info from con        */
@@ -187,74 +187,75 @@ extern "C" {
 #define SMBlibE_ProtUnknown 12 /* Protocol unknown                          */
 #define SMBlibE_NoSuchMsg  13 /* Keep this up to date                       */
 
-    /* the default SMB protocols supported by this library. */
-    extern const char *SMB_Prots[];
+/* the default SMB protocols supported by this library. */
+extern const char *SMB_Prots[];
 
-    typedef struct {                       /* A structure for a Dirent */
+typedef struct {                       /* A structure for a Dirent */
 
-        unsigned char resume_key[21];        /* Don't touch this          */
-        unsigned char file_attributes;       /* Attributes of file        */
-        unsigned int date_time;              /* date and time of last mod */
-        unsigned int size;
-        char filename[13];                   /* The name of the file      */
+    unsigned char resume_key[21];        /* Don't touch this          */
+    unsigned char file_attributes;       /* Attributes of file        */
+    unsigned int date_time;              /* date and time of last mod */
+    unsigned int size;
+    char filename[13];                   /* The name of the file      */
 
-    } SMB_CP_dirent;
+} SMB_CP_dirent;
 
-    typedef struct SMB_Connect_Def * SMB_Handle_Type;
+typedef struct SMB_Connect_Def * SMB_Handle_Type;
 
-    typedef struct SMB_Tree_Structure * SMB_Tree_Handle;
+typedef struct SMB_Tree_Structure * SMB_Tree_Handle;
 
-    /* A Tree_Structure                       */
+/* A Tree_Structure                       */
 
-    struct SMB_Tree_Structure {
+struct SMB_Tree_Structure {
 
-        SMB_Tree_Handle next, prev;
-        SMB_Handle_Type con;
-        char path[129];
-        char device_type[20];
-        int mbs;                   /* Local MBS */
-        int tid;
+    SMB_Tree_Handle next, prev;
+    SMB_Handle_Type con;
+    char path[129];
+    char device_type[20];
+    int mbs;                   /* Local MBS */
+    int tid;
 
-    };
+};
 
-    struct SMB_Connect_Def {
-        SMB_Handle_Type Next_Con, Prev_Con;          /* Next and previous conn */
-        int protocol;                                /* What is the protocol   */
-        int prot_IDX;                                /* And what is the index  */
-        void *Trans_Connect;                         /* The connection         */
+struct SMB_Connect_Def {
+    SMB_Handle_Type Next_Con, Prev_Con;          /* Next and previous conn */
+    int protocol;                                /* What is the protocol   */
+    int prot_IDX;                                /* And what is the index  */
+    void *Trans_Connect;                         /* The connection         */
 
-        /* All these strings should be malloc'd */
+    /* All these strings should be malloc'd */
 
-        char service[80], username[80], password[80], desthost[80], sock_options[80];
-        char address[80], myname[80];
+    char service[80], username[80], password[80], desthost[80], sock_options[80];
+    char address[80], myname[80];
 
-        SMB_Tree_Handle first_tree, last_tree;  /* List of trees on this server */
+    SMB_Tree_Handle first_tree, last_tree;  /* List of trees on this server */
 
-        int gid;         /* Group ID, do we need it?                      */
-        int mid;         /* Multiplex ID? We might need one per con       */
-        int pid;         /* Process ID                                    */
+    int gid;         /* Group ID, do we need it?                      */
+    int mid;         /* Multiplex ID? We might need one per con       */
+    int pid;         /* Process ID                                    */
 
-        int uid;         /* Authenticated user id.                        */
+    int uid;         /* Authenticated user id.                        */
 
-        /* It is pretty clear that we need to bust some of */
-        /* these out into a per TCon record, as there may  */
-        /* be multiple TCon's per server, etc ... later    */
+    /* It is pretty clear that we need to bust some of */
+    /* these out into a per TCon record, as there may  */
+    /* be multiple TCon's per server, etc ... later    */
 
-        int port;        /* port to use in case not default, this is a TCPism! */
+    int port;        /* port to use in case not default, this is a TCPism! */
 
-        int max_xmit;    /* Max xmit permitted by server                  */
-        int Security;    /* 0 = share, 1 = user                           */
-        int Raw_Support; /* bit 0 = 1 = Read Raw supported, 1 = 1 Write raw */
-        int encrypt_passwords; /* 1 = do , 0 = don't                      */
-        int MaxMPX, MaxVC, MaxRaw;
-        unsigned int SessionKey, Capabilities;
-        int SvrTZ;                                 /* Server Time Zone */
-        int Encrypt_Key_Len;
-        char Encrypt_Key[80], Domain[80], PDomain[80], OSName[80], LMType[40];
-        char Svr_OS[80], Svr_LMType[80], Svr_PDom[80];
-    };
+    int max_xmit;    /* Max xmit permitted by server                  */
+    int Security;    /* 0 = share, 1 = user                           */
+    int Raw_Support; /* bit 0 = 1 = Read Raw supported, 1 = 1 Write raw */
+    int encrypt_passwords; /* 1 = do , 0 = don't                      */
+    int MaxMPX, MaxVC, MaxRaw;
+    unsigned int SessionKey, Capabilities;
+    int SvrTZ;                                 /* Server Time Zone */
+    int Encrypt_Key_Len;
+    char Encrypt_Key[80], Domain[80], PDomain[80], OSName[80], LMType[40];
+    char Svr_OS[80], Svr_LMType[80], Svr_PDom[80];
+};
 
 #ifdef __cplusplus
 }
 #endif
 #endif /* _SMBLIB_SMBLIB_COMMON_H */
+
@@ -552,3 +552,4 @@ extern int SMBlib_SMB_Error;          /* last Error             */
 void SMB_Get_My_Name(char *name, int len);
 
 #endif /* _SMBLIB_PRIV_H_ */
+
@@ -825,3 +825,4 @@ void SMB_Get_Error_Msg(int msg, char *msgbuf, int len)
     }
 
 }
+
@@ -588,3 +588,4 @@ int SMB_Discon(SMB_Handle_Type Con_Handle, BOOL KeepHandle)
     return(0);
 
 }
+
@@ -41,91 +41,92 @@
 extern "C" {
 #endif
 
-    /* Just define all the entry points */
+/* Just define all the entry points */
 
-    /* Create a handle to allow us to set/override some parameters ...       */
+/* Create a handle to allow us to set/override some parameters ...       */
 
-    SMB_Handle_Type SMB_Create_Con_Handle(void);
+SMB_Handle_Type SMB_Create_Con_Handle(void);
 
-    /* Connect to a server, but do not do a tree con etc ... */
+/* Connect to a server, but do not do a tree con etc ... */
 
-    SMB_Handle_Type SMB_Connect_Server(SMB_Handle_Type Con_Handle,
-                                       char *server,
-                                       const char *NTdomain);
+SMB_Handle_Type SMB_Connect_Server(SMB_Handle_Type Con_Handle,
+                                   char *server,
+                                   const char *NTdomain);
 
-    /* Connect to a server and give us back a handle. If Con == NULL, create */
-    /* The handle and populate it with defaults                              */
+/* Connect to a server and give us back a handle. If Con == NULL, create */
+/* The handle and populate it with defaults                              */
 
-    SMB_Handle_Type SMB_Connect(SMB_Handle_Type Con_Handle,
-                                SMB_Tree_Handle *tree,
-                                char *service,
-                                char *username,
-                                char *password);
+SMB_Handle_Type SMB_Connect(SMB_Handle_Type Con_Handle,
+                            SMB_Tree_Handle *tree,
+                            char *service,
+                            char *username,
+                            char *password);
 
-    int SMB_Init(void);
+int SMB_Init(void);
 
-    int SMB_Logon_Server(SMB_Handle_Type Con_Handle,
-                         char *UserName,
-                         char *PassWord,
-                         const char *NtDomain,
-                         int PreCrypted);
+int SMB_Logon_Server(SMB_Handle_Type Con_Handle,
+                     char *UserName,
+                     char *PassWord,
+                     const char *NtDomain,
+                     int PreCrypted);
 
-    /* Negotiate a protocol                                                  */
+/* Negotiate a protocol                                                  */
 
-    int SMB_Negotiate(SMB_Handle_Type Con_Handle, const char *Prots[]);
+int SMB_Negotiate(SMB_Handle_Type Con_Handle, const char *Prots[]);
 
-    /* Connect to a tree ...                                                 */
+/* Connect to a tree ...                                                 */
 
-    SMB_Tree_Handle SMB_TreeConnect(SMB_Handle_Type con,
-                                    SMB_Tree_Handle tree,
-                                    const char *path,
-                                    const char *password,
-                                    const char *dev);
+SMB_Tree_Handle SMB_TreeConnect(SMB_Handle_Type con,
+                                SMB_Tree_Handle tree,
+                                const char *path,
+                                const char *password,
+                                const char *dev);
 
-    /* Disconnect a tree ...                                                 */
+/* Disconnect a tree ...                                                 */
 
-    int SMB_TreeDisconect(void *tree_handle);
+int SMB_TreeDisconect(void *tree_handle);
 
-    /* Open a file                                                           */
+/* Open a file                                                           */
 
-    void *SMB_Open(void *tree_handle,
-                   void *file_handle,
-                   char *file_name,
-                   unsigned short mode,
-                   unsigned short search);
+void *SMB_Open(void *tree_handle,
+               void *file_handle,
+               char *file_name,
+               unsigned short mode,
+               unsigned short search);
 
-    /* Close a file                                                          */
+/* Close a file                                                          */
 
-    int SMB_Close(void *file_handle);
+int SMB_Close(void *file_handle);
 
-    /* Disconnect from server. Has flag to specify whether or not we keep the */
-    /* handle.                                                                */
+/* Disconnect from server. Has flag to specify whether or not we keep the */
+/* handle.                                                                */
 
-    int SMB_Discon(SMB_Handle_Type Con_Handle, BOOL KeepHandle);
+int SMB_Discon(SMB_Handle_Type Con_Handle, BOOL KeepHandle);
 
-    void *SMB_Create(void *Tree_Handle,
-                     void *File_Handle,
-                     char *file_name,
-                     short search);
+void *SMB_Create(void *Tree_Handle,
+                 void *File_Handle,
+                 char *file_name,
+                 short search);
 
-    int SMB_Delete(void *tree, char *file_name, short search);
+int SMB_Delete(void *tree, char *file_name, short search);
 
-    int SMB_Create_Dir(void *tree, char *dir_name);
+int SMB_Create_Dir(void *tree, char *dir_name);
 
-    int SMB_Delete_Dir(void *tree, char *dir_name);
+int SMB_Delete_Dir(void *tree, char *dir_name);
 
-    int SMB_Check_Dir(void *tree, char *dir_name);
+int SMB_Check_Dir(void *tree, char *dir_name);
 
-    int SMB_Get_Last_Error(void);
+int SMB_Get_Last_Error(void);
 
-    int SMB_Get_Last_SMB_Err(void);
+int SMB_Get_Last_SMB_Err(void);
 
-    void SMB_Get_Error_Msg(int msg, char *msgbuf, int len);
+void SMB_Get_Error_Msg(int msg, char *msgbuf, int len);
 
-    void *SMB_Logon_And_TCon(void *con, void *tree, char *user, char *pass,
-                             char *service, char *st);
+void *SMB_Logon_And_TCon(void *con, void *tree, char *user, char *pass,
+                         char *service, char *st);
 
 #ifdef __cplusplus
 }
 #endif
 #endif /* _SMBLIB_SMBLIB_H */
+
@@ -49,3 +49,4 @@
 #define FALSE 0
 
 #endif /* _SMBLIB_STD_DEFINES_H */
+
@@ -90,12 +90,12 @@
 #include "snmp_api_error.h"
 
 u_char *
-asn_build_header(u_char * data,	/* IN - ptr to start of object */
-                 int *datalength,		/* IN/OUT - # of valid bytes */
+asn_build_header(u_char * data, /* IN - ptr to start of object */
+                 int *datalength,       /* IN/OUT - # of valid bytes */
                  /*          left in buffer */
-                 u_char type,		/* IN - ASN type of object */
+                 u_char type,       /* IN - ASN type of object */
                  int length)
-{				/* IN - length of object */
+{   /* IN - length of object */
     /* Truth is 0 'cause we don't know yet */
     return (asn_build_header_with_truth(data, datalength, type, length, 0));
 }
@@ -154,7 +154,7 @@ asn_parse_int(u_char * data, int *datalength,
 
     /* Is the int negative? */
     if (*bufp & 0x80)
-        value = -1;		/* integer is negative */
+        value = -1;     /* integer is negative */
 
     /* Extract the bytes */
     while (asn_length--)
@@ -220,7 +220,7 @@ asn_parse_unsigned_int(u_char * data, int *datalength,
 
     /* Is the int negative? */
     if (*bufp & 0x80)
-        value = -1;		/* integer is negative */
+        value = -1;     /* integer is negative */
 
     /* Extract the bytes */
     while (asn_length--)
@@ -551,7 +551,7 @@ asn_build_sequence(u_char * data, int *datalength,
 {
     *datalength -= 4;
     if (*datalength < 0) {
-        *datalength += 4;	/* fix up before punting */
+        *datalength += 4;   /* fix up before punting */
         snmp_set_api_error(SNMPERR_ASN_ENCODE);
         return (NULL);
     }
@@ -579,7 +579,7 @@ asn_parse_length(u_char * data, u_int * length)
     u_char lengthbyte = *data;
 
     if (lengthbyte & ASN_LONG_LEN) {
-        lengthbyte &= ~ASN_LONG_LEN;	/* turn MSb off */
+        lengthbyte &= ~ASN_LONG_LEN;    /* turn MSb off */
 
         if (lengthbyte == 0) {
             snmp_set_api_error(SNMPERR_ASN_DECODE);
@@ -629,7 +629,7 @@ asn_build_length(u_char * data, int *datalength,
             }
             *data++ = (u_char) (0x01 | ASN_LONG_LEN);
             *data++ = (u_char) length;
-        } else {		/* 0xFF < length <= 0xFFFF */
+        } else {        /* 0xFF < length <= 0xFFFF */
             if (*datalength < 3) {
                 snmp_set_api_error(SNMPERR_ASN_ENCODE);
                 return (NULL);
@@ -707,11 +707,11 @@ asn_parse_objid(u_char * data, int *datalength,
         objid[0] = objid[1] = 0;
 
     length = asn_length;
-    (*objidlength)--;		/* account for expansion of first byte */
+    (*objidlength)--;       /* account for expansion of first byte */
     while (length > 0 && (*objidlength)-- > 0) {
         subidentifier = 0;
 
-        do {			/* shift and add in low order 7 bits */
+        do {            /* shift and add in low order 7 bits */
             subidentifier = (subidentifier << 7)
                             + (*(u_char *) bufp & ~ASN_BIT8);
             length--;
@@ -788,15 +788,15 @@ asn_build_objid(u_char * data, int *datalength,
 
     while (objidlength-- > 0) {
         subid = *op++;
-        if (subid < 127) {	/* off by one? */
+        if (subid < 127) {  /* off by one? */
             *bp++ = subid;
         } else {
-            mask = 0x7F;	/* handle subid == 0 case */
+            mask = 0x7F;    /* handle subid == 0 case */
             bits = 0;
             /* testmask *MUST* !!!! be of an unsigned type */
             for (testmask = 0x7F, testbits = 0; testmask != 0;
                     testmask <<= 7, testbits += 7) {
-                if (subid & testmask) {		/* if any bits set */
+                if (subid & testmask) {     /* if any bits set */
                     mask = testmask;
                     bits = testbits;
                 }
@@ -1012,3 +1012,4 @@ asn_build_exception(u_char * data, int *datalength, u_char type)
 {
     return (asn_build_header_with_truth(data, datalength, type, 0, 1));
 }
+
@@ -132,3 +132,4 @@ snmp_coexist_V2toV1(struct snmp_pdu *PDU)
         return (0);
     }
 }
+
@@ -7,7 +7,7 @@
  */
 
 /***********************************************************
-	Copyright 1988, 1989 by Carnegie Mellon University
+    Copyright 1988, 1989 by Carnegie Mellon University
 
                       All Rights Reserved
 
@@ -229,7 +229,7 @@ int
 read_objid(input, output, out_len)
 char *input;
 oid *output;
-int *out_len;		/* number of subid's in "output" */
+int *out_len;       /* number of subid's in "output" */
 {
     struct snmp_mib_tree *root = Mib;
     oid *op = output;
@@ -263,12 +263,12 @@ int *out_len;		/* number of subid's in "output" */
 void
 print_objid(objid, objidlen)
 oid *objid;
-int objidlen;		/* number of subidentifiers */
+int objidlen;       /* number of subidentifiers */
 {
     char buf[256];
     struct snmp_mib_tree *subtree = Mib;
 
-    *buf = '.';			/* this is a fully qualified name */
+    *buf = '.';         /* this is a fully qualified name */
     get_symbol(objid, objidlen, subtree, buf + 1);
     snmplib_debug(7, "%s\n", buf);
 
@@ -278,11 +278,11 @@ void
 sprint_objid(buf, objid, objidlen)
 char *buf;
 oid *objid;
-int objidlen;		/* number of subidentifiers */
+int objidlen;       /* number of subidentifiers */
 {
     struct snmp_mib_tree *subtree = Mib;
 
-    *buf = '.';			/* this is a fully qualified name */
+    *buf = '.';         /* this is a fully qualified name */
     get_symbol(objid, objidlen, subtree, buf + 1);
 }
 
@@ -303,12 +303,12 @@ char *buf;
     }
 
     /* subtree not found */
-    while (objidlen--) {	/* output rest of name, uninterpreted */
+    while (objidlen--) {    /* output rest of name, uninterpreted */
         sprintf(buf, "%u.", *objid++);
         while (*buf)
             buf++;
     }
-    *(buf - 1) = '\0';		/* remove trailing dot */
+    *(buf - 1) = '\0';      /* remove trailing dot */
     return NULL;
 
 found:
@@ -333,3 +333,4 @@ print_oid_nums(oid * O, int len)
     for (x = 0; x < len; x++)
         printf(".%u", O[x]);
 }
+
@@ -7,7 +7,7 @@
  */
 
 /***********************************************************
-	Copyright 1989 by Carnegie Mellon University
+    Copyright 1989 by Carnegie Mellon University
 
                       All Rights Reserved
 
@@ -103,66 +103,66 @@ struct subid {
  */
 struct node {
     struct node *next;
-    char label[64];		/* This node's (unique) textual name */
-    u_int subid;		/* This node's integer subidentifier */
-    char parent[64];		/* The parent's textual name */
-    int type;			/* The type of object this represents */
-    struct enum_list *enums;	/* (optional) list of enumerated integers (otherwise NULL) */
+    char label[64];     /* This node's (unique) textual name */
+    u_int subid;        /* This node's integer subidentifier */
+    char parent[64];        /* The parent's textual name */
+    int type;           /* The type of object this represents */
+    struct enum_list *enums;    /* (optional) list of enumerated integers (otherwise NULL) */
 };
 
 int Line = 1;
 
 /* types of tokens */
-#define	CONTINUE    -1
+#define CONTINUE    -1
 #define ENDOFFILE   0
-#define LABEL	    1
-#define SUBTREE	    2
-#define SYNTAX	    3
+#define LABEL       1
+#define SUBTREE     2
+#define SYNTAX      3
 #undef OBJID
-#define OBJID	    4
+#define OBJID       4
 #define OCTETSTR    5
 #undef INTEGER
-#define INTEGER	    6
-#define NETADDR	    7
-#define	IPADDR	    8
-#define COUNTER	    9
-#define GAUGE	    10
+#define INTEGER     6
+#define NETADDR     7
+#define IPADDR      8
+#define COUNTER     9
+#define GAUGE       10
 #define TIMETICKS   11
-#define SNMP_OPAQUE	    12
-#define NUL	    13
+#define SNMP_OPAQUE     12
+#define NUL     13
 #define SEQUENCE    14
-#define OF	    15		/* SEQUENCE OF */
-#define OBJTYPE	    16
-#define ACCESS	    17
+#define OF      15      /* SEQUENCE OF */
+#define OBJTYPE     16
+#define ACCESS      17
 #define READONLY    18
 #define READWRITE   19
-#define	WRITEONLY   20
+#define WRITEONLY   20
 #undef NOACCESS
 #define NOACCESS    21
 #define SNMP_STATUS 22
 #define MANDATORY   23
 #define SNMP_OPTIONAL    24
 #define OBSOLETE    25
 #define RECOMMENDED 26
-#define PUNCT	    27
-#define EQUALS	    28
-#define NUMBER	    29
+#define PUNCT       27
+#define EQUALS      28
+#define NUMBER      29
 #define LEFTBRACKET 30
 #define RIGHTBRACKET 31
-#define	LEFTPAREN   32
+#define LEFTPAREN   32
 #define RIGHTPAREN  33
-#define COMMA	    34
+#define COMMA       34
 /* For SNMPv2 SMI pseudo-compliance */
 #define DESCRIPTION 35
 #define INDEX       36
 #define QUOTE       37
 
 struct tok {
-    const char *name;			/* token name */
-    int len;			/* length not counting nul */
-    int token;			/* value */
-    int hash;			/* hash of name */
-    struct tok *next;		/* pointer to next in hash table */
+    const char *name;           /* token name */
+    int len;            /* length not counting nul */
+    int token;          /* value */
+    int hash;           /* hash of name */
+    struct tok *next;       /* pointer to next in hash table */
 };
 
 struct tok tokens[] = {
@@ -213,8 +213,8 @@ struct tok tokens[] = {
     {NULL}
 };
 
-#define	HASHSIZE	32
-#define	BUCKET(x)	(x & 0x01F)
+#define HASHSIZE    32
+#define BUCKET(x)   (x & 0x01F)
 
 static struct tok *buckets[HASHSIZE];
 
@@ -233,7 +233,7 @@ hash_init(void)
         tp->hash = h;
         b = BUCKET(h);
         if (buckets[b])
-            tp->next = buckets[b];	/* BUG ??? */
+            tp->next = buckets[b];  /* BUG ??? */
         buckets[b] = tp;
     }
 }
@@ -378,21 +378,21 @@ do_subtree(struct snmp_mib_tree *root, struct node **nodes)
             oldnp = np;
         } else {
             if (child_list == NULL) {
-                child_list = childp = np;	/* first entry in child list */
+                child_list = childp = np;   /* first entry in child list */
             } else {
                 childp->next = np;
                 childp = np;
             }
             /* take this node out of the node list */
             if (oldnp == NULL) {
-                *headp = np->next;	/* fix root of node list */
+                *headp = np->next;  /* fix root of node list */
             } else {
-                oldnp->next = np->next;		/* link around this node */
+                oldnp->next = np->next;     /* link around this node */
             }
         }
     }
     if (childp)
-        childp->next = 0;	/* re-terminate list */
+        childp->next = 0;   /* re-terminate list */
     /*
      * Take each element in the child list and place it into the tree.
      */
@@ -405,15 +405,15 @@ do_subtree(struct snmp_mib_tree *root, struct node **nodes)
         tp->subid = np->subid;
         tp->type = translation_table[np->type];
         tp->enums = np->enums;
-        np->enums = NULL;	/* so we don't free them later */
+        np->enums = NULL;   /* so we don't free them later */
         if (root->child_list == NULL) {
             root->child_list = tp;
         } else if (peer) {
             peer->next_peer = tp;
         }
         peer = tp;
         /*      if (tp->type == TYPE_OTHER) */
-        do_subtree(tp, nodes);	/* recurse on this child if it isn't an end node */
+        do_subtree(tp, nodes);  /* recurse on this child if it isn't an end node */
     }
     /* free all nodes that were copied into tree */
     oldnp = NULL;
@@ -558,8 +558,8 @@ get_token(register FILE *fp, register char *token)
  * { iso org(3) dod(6) 1 }
  * and creates several nodes, one for each parent-child pair.
  * Returns NULL on error.
- *   register struct subid *SubOid;	an array of subids
- *   int length;			the length of the array
+ *   register struct subid *SubOid; an array of subids
+ *   int length;            the length of the array
  */
 static int
 getoid(register FILE *fp, register struct subid *SubOid, int length)
@@ -740,7 +740,7 @@ parse_asntype(FILE *fp)
 
     type = get_token(fp, token);
     if (type != SEQUENCE) {
-        print_error("Not a sequence", token, type);	/* should we handle this */
+        print_error("Not a sequence", token, type); /* should we handle this */
         return ENDOFFILE;
     }
     while ((type = get_token(fp, token)) != ENDOFFILE) {
@@ -1115,3 +1115,4 @@ read_mib(char *filename) {
     tree = build_tree(nodes);
     return (tree);
 }
+
@@ -158,3 +158,4 @@ snmp_parse(struct snmp_session * session,
 
     return (bufp);
 }
+
@@ -51,8 +51,8 @@ static const char *api_errors[17] = {
     "Unknown session",
     "Too Long",
 
-    "Encoding ASN.1 Information",	/* 6 */
-    "Decoding ASN.1 Information",	/* 7 */
+    "Encoding ASN.1 Information",   /* 6 */
+    "Decoding ASN.1 Information",   /* 7 */
     "PDU Translation error",
     "OS Error",
     "Invalid Textual OID",
@@ -94,3 +94,4 @@ api_errstring(int snmp_errnumber)
 {
     return (snmp_api_error(snmp_errnumber));
 }
+
@@ -84,3 +84,4 @@ snmp_errstring(int errstat)
         return "Unknown Error";
     }
 }
+
@@ -194,7 +194,7 @@ snmp_msg_Encode(u_char * Buffer, int *BufLenP,
     PDUDataStart = bufp;
     bufp = snmp_pdu_encode(bufp, BufLenP, PDU);
     if (bufp == NULL)
-        return (NULL);		/* snmp_pdu_encode registered failure */
+        return (NULL);      /* snmp_pdu_encode registered failure */
 
     VARHeaderPtr = bufp;
     bufp = asn_build_header(bufp, BufLenP,
@@ -207,7 +207,7 @@ snmp_msg_Encode(u_char * Buffer, int *BufLenP,
     /* And build the variables */
     bufp = snmp_var_EncodeVarBind(bufp, BufLenP, PDU->variables, Version);
     if (bufp == NULL)
-        return (NULL);		/* snmp_var_EncodeVarBind registered failure */
+        return (NULL);      /* snmp_var_EncodeVarBind registered failure */
 
     /* Cool.  Now insert the appropriate lengths.
      */
@@ -231,14 +231,14 @@ snmp_msg_Encode(u_char * Buffer, int *BufLenP,
     tmp = asn_build_header(Buffer,
                            &FakeArg,
                            (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR),
-                           (bufp - MsgPtr));	/* Length of everything */
+                           (bufp - MsgPtr));    /* Length of everything */
     if (tmp == NULL)
         return (NULL);
 
     tmp = asn_build_header(VARHeaderPtr,
                            &FakeArg,
                            (u_char) (ASN_SEQUENCE | ASN_CONSTRUCTOR),
-                           (bufp - VARDataStart));	/* Length of everything */
+                           (bufp - VARDataStart));  /* Length of everything */
     if (tmp == NULL)
         return (NULL);
 
@@ -301,3 +301,4 @@ snmp_msg_Decode(u_char * Packet, int *PacketLenP,
 
     return (u_char *) bufp;
 }
+
@@ -404,7 +404,7 @@ snmp_pdu_encode(u_char * DestBuf, int *DestBufLen,
         break;
 #endif
 
-        /**********************************************************************/
+    /**********************************************************************/
 
     case SNMP_PDU_GETBULK:
 
@@ -434,7 +434,7 @@ snmp_pdu_encode(u_char * DestBuf, int *DestBufLen,
             return (NULL);
         break;
 
-        /**********************************************************************/
+    /**********************************************************************/
 
     default:
 
@@ -470,7 +470,7 @@ snmp_pdu_encode(u_char * DestBuf, int *DestBufLen,
         if (bufp == NULL)
             return (NULL);
         break;
-    }				/* End of encoding */
+    }               /* End of encoding */
 
     return (bufp);
 }
@@ -483,10 +483,10 @@ snmp_pdu_encode(u_char * DestBuf, int *DestBufLen,
  * Variable Bindings start.
  */
 u_char *
-snmp_pdu_decode(u_char * Packet,	/* data */
-                int *Length,		/* &length */
+snmp_pdu_decode(u_char * Packet,    /* data */
+                int *Length,        /* &length */
                 struct snmp_pdu * PDU)
-{				/* pdu */
+{   /* pdu */
     u_char *bufp;
     u_char PDUType;
     u_char ASNType;
@@ -560,7 +560,7 @@ snmp_pdu_decode(u_char * Packet,	/* data */
         break;
 #endif
 
-        /**********************************************************************/
+    /**********************************************************************/
 
     case SNMP_PDU_GETBULK:
 
@@ -588,7 +588,7 @@ snmp_pdu_decode(u_char * Packet,	/* data */
             ASN_PARSE_ERROR(NULL);
         break;
 
-        /**********************************************************************/
+    /**********************************************************************/
 
     default:
 
@@ -662,3 +662,4 @@ snmp_add_null_var(struct snmp_pdu *pdu, oid * name, int name_length)
 
     return;
 }
+
@@ -304,7 +304,7 @@ snmp_var_EncodeVarBind(u_char * Buffer, int *BufLenP,
 
         case SMI_COUNTER32:
         case SMI_GAUGE32:
-            /*  case SMI_UNSIGNED32: */
+        /*  case SMI_UNSIGNED32: */
         case SMI_TIMETICKS:
             bufp = asn_build_unsigned_int(bufp, BufLenP,
                                           Vars->type,
@@ -340,7 +340,7 @@ snmp_var_EncodeVarBind(u_char * Buffer, int *BufLenP,
 
         case SMI_COUNTER64:
             snmplib_debug(2, "Unable to encode type SMI_COUNTER64!\n");
-            /* Fall through */
+        /* Fall through */
 
         default:
             snmp_set_api_error(SNMPERR_UNSUPPORTED_TYPE);
@@ -485,7 +485,7 @@ snmp_var_DecodeVarBind(u_char * Buffer, int *BufLen,
 
         case SMI_COUNTER32:
         case SMI_GAUGE32:
-            /*  case SMI_UNSIGNED32: */
+        /*  case SMI_UNSIGNED32: */
         case SMI_TIMETICKS:
             Var->val.integer = (int *) xmalloc(sizeof(u_int));
             if (Var->val.integer == NULL) {
@@ -505,7 +505,7 @@ snmp_var_DecodeVarBind(u_char * Buffer, int *BufLen,
         case ASN_OCTET_STR:
         case SMI_IPADDRESS:
         case SMI_OPAQUE:
-            Var->val_len = *&ThisVarLen;	/* String is this at most */
+            Var->val_len = *&ThisVarLen;    /* String is this at most */
             Var->val.string = (u_char *) xmalloc((unsigned) Var->val_len);
             if (Var->val.string == NULL) {
                 snmp_set_api_error(SNMPERR_OS_ERR);
@@ -555,7 +555,7 @@ snmp_var_DecodeVarBind(u_char * Buffer, int *BufLen,
             snmplib_debug(2, "bad type returned (%x)\n", Var->type);
             snmp_set_api_error(SNMPERR_PDU_PARSE);
             PARSE_ERROR;
-        }			/* End of var type switch */
+        }           /* End of var type switch */
 
         if (bufp == NULL)
             PARSE_ERROR;
@@ -571,3 +571,4 @@ snmp_var_DecodeVarBind(u_char * Buffer, int *BufLen,
 
     return (bufp);
 }
+
@@ -32,3 +32,4 @@ snmplib_debug(int lvl, const char *fmt,...)
     }
     va_end(args);
 }
+
@@ -579,3 +579,4 @@ const char * WINAPI SSP_ValidateNegotiateCredentials(PVOID PAutenticateBuf, int
         encoded = base64_encode_bin((char *) pServerBuf, cbOut);
     return encoded;
 }
+
@@ -15,3 +15,4 @@ statMemoryAccounted(void)
 {
     return -1;
 }
+
@@ -18,8 +18,8 @@
 CPPUNIT_TEST_SUITE_REGISTRATION( testRFC1035 );
 
 // TODO Test each function in the Library independently
-//	Just because we can for global functions.
-//	It's good for the code too.
+//  Just because we can for global functions.
+//  It's good for the code too.
 
 void testRFC1035::testHeaderUnpack()
 {
@@ -139,3 +139,4 @@ void testRFC1035::testBugPacketHeadersOnly()
     CPPUNIT_ASSERT(res < 0);
     CPPUNIT_ASSERT(msg == NULL);
 }
+
@@ -37,3 +37,4 @@ class testRFC1035 : public CPPUNIT_NS::TestFixture
 };
 
 #endif /* SQUID_SRC_TEST_IPADDRESS_H */
+
@@ -151,3 +151,4 @@ void testRFC1738::PercentZeroNullDecoding()
     CPPUNIT_ASSERT(memcmp(unescaped_str, "w%%00%rd",9)==0);
     xfree(unescaped_str);
 }
+
@@ -34,3 +34,4 @@ class testRFC1738 : public CPPUNIT_NS::TestFixture
 };
 
 #endif /* SQUID_LIB_TEST_RFC1738_H */
+
@@ -78,7 +78,7 @@ xdiv(double nom, double denom)
 const char *
 xitoa(int num)
 {
-    static char buf[24];	/* 2^64 = 18446744073709551616 */
+    static char buf[24];    /* 2^64 = 18446744073709551616 */
     snprintf(buf, sizeof(buf), "%d", num);
     return buf;
 }
@@ -87,7 +87,7 @@ xitoa(int num)
 const char *
 xint64toa(int64_t num)
 {
-    static char buf[24];	/* 2^64 = 18446744073709551616 */
+    static char buf[24];    /* 2^64 = 18446744073709551616 */
     snprintf(buf, sizeof(buf), "%" PRId64, num);
     return buf;
 }
@@ -154,3 +154,4 @@ unsigned int RoundTo(const unsigned int num, const unsigned int what)
 {
     return what * ((num + what -1)/what);
 }
+
@@ -70,3 +70,4 @@ uudecode(const char *bufcoded)
     bufplain[nbytesdecoded] = '\0';
     return bufplain;
 }
+
@@ -25,3 +25,4 @@ xusleep(unsigned int usec)
     sl.tv_usec = usec % 1000000;
     return select(0, NULL, NULL, NULL, &sl);
 }
+
@@ -5,3 +5,4 @@
  * contributions from numerous individuals and organizations.
  * Please see the COPYING and CONTRIBUTORS files for details.
  */
+
@@ -69,3 +69,4 @@ AccessLogEntry::~AccessLogEntry()
     HTTPMSGUNLOCK(icap.request);
 #endif
 }
+
@@ -40,7 +40,7 @@ class AccessLogEntry: public RefCountable
     typedef RefCount<AccessLogEntry> Pointer;
 
     AccessLogEntry() : url(NULL), tcpClient(), reply(NULL), request(NULL),
-            adapted_request(NULL) {}
+        adapted_request(NULL) {}
     ~AccessLogEntry();
 
     /// Fetch the client IP log string into the given buffer.
@@ -64,10 +64,10 @@ class AccessLogEntry: public RefCountable
 
     public:
         HttpDetails() : method(Http::METHOD_NONE), code(0), content_type(NULL),
-                timedout(false),
-                aborted(false),
-                clientRequestSz(),
-                clientReplySz() {}
+            timedout(false),
+            aborted(false),
+            clientRequestSz(),
+            clientReplySz() {}
 
         HttpRequestMethod method;
         int code;
@@ -138,15 +138,15 @@ class AccessLogEntry: public RefCountable
 
     public:
         CacheDetails() : caddr(),
-                highOffset(0),
-                objectSize(0),
-                code (LOG_TAG_NONE),
-                rfc931 (NULL),
-                extuser(NULL),
+            highOffset(0),
+            objectSize(0),
+            code (LOG_TAG_NONE),
+            rfc931 (NULL),
+            extuser(NULL),
 #if USE_OPENSSL
-                ssluser(NULL),
+            ssluser(NULL),
 #endif
-                port(NULL)
+            port(NULL)
         {
             caddr.setNoAddr();
             memset(&start_time, 0, sizeof(start_time));
@@ -178,8 +178,8 @@ class AccessLogEntry: public RefCountable
 
     public:
         Headers() : request(NULL),
-                adapted_request(NULL),
-                reply(NULL) {}
+            adapted_request(NULL),
+            reply(NULL) {}
 
         char *request; //< virgin HTTP request headers
 
@@ -230,8 +230,8 @@ class AccessLogEntry: public RefCountable
     {
     public:
         IcapLogEntry() : reqMethod(Adaptation::methodNone), bytesSent(0), bytesRead(0),
-                bodyBytesRead(-1), request(NULL), reply(NULL),
-                outcome(Adaptation::Icap::xoUnknown), resStatus(Http::scNone)
+            bodyBytesRead(-1), request(NULL), reply(NULL),
+            outcome(Adaptation::Icap::xoUnknown), resStatus(Http::scNone)
         {
             memset(&trTime, 0, sizeof(trTime));
             memset(&ioTime, 0, sizeof(ioTime));
@@ -283,3 +283,4 @@ void accessLogInit(void);
 const char *accessLogTime(time_t);
 
 #endif /* SQUID_HTTPACCESSLOGENTRY_H */
+
@@ -217,3 +217,4 @@ ACLStrategised<HttpRequest *> ACLNote::RegistryEntry_(new ACLNoteData, ACLNoteSt
 ACL::Prototype ACLAdaptationService::RegistryProtoype(&ACLAdaptationService::RegistryEntry_, "adaptation_service");
 ACLStrategised<const char *> ACLAdaptationService::RegistryEntry_(new ACLAdaptationServiceData, ACLAdaptationServiceStrategy::Instance(), "adaptation_service");
 #endif
+
@@ -8,3 +8,4 @@
 
 #include "squid.h"
 #include "AsyncEngine.h"
+
@@ -56,3 +56,4 @@ class AsyncEngine
 };
 
 #endif /* SQUID_ASYNCENGINE_H */
+
@@ -54,3 +54,4 @@ Auth::Init()
 }
 
 #endif /* USE_AUTH */
+
@@ -23,3 +23,4 @@ inline void Init(void) {} /* NOP if not USE_AUTH */
 
 } // namespace Auth
 #endif /* SQUID_AUTHREG_H_ */
+
@@ -51,7 +51,7 @@ class BodyProducerDialer: public UnaryMemFunT<BodyProducer, BodyPipe::Pointer>
 
     BodyProducerDialer(const BodyProducer::Pointer &aProducer,
                        Parent::Method aHandler, BodyPipe::Pointer bp):
-            Parent(aProducer, aHandler, bp) {}
+        Parent(aProducer, aHandler, bp) {}
 
     virtual bool canDial(AsyncCall &call);
 };
@@ -66,7 +66,7 @@ class BodyConsumerDialer: public UnaryMemFunT<BodyConsumer, BodyPipe::Pointer>
 
     BodyConsumerDialer(const BodyConsumer::Pointer &aConsumer,
                        Parent::Method aHandler, BodyPipe::Pointer bp):
-            Parent(aConsumer, aHandler, bp) {}
+        Parent(aConsumer, aHandler, bp) {}
 
     virtual bool canDial(AsyncCall &call);
 };
@@ -128,9 +128,9 @@ void BodyConsumer::stopConsumingFrom(RefCount<BodyPipe> &p)
 /* BodyPipe */
 
 BodyPipe::BodyPipe(Producer *aProducer): theBodySize(-1),
-        theProducer(aProducer), theConsumer(0),
-        thePutSize(0), theGetSize(0),
-        mustAutoConsume(false), abortedConsumption(false), isCheckedOut(false)
+    theProducer(aProducer), theConsumer(0),
+    thePutSize(0), theGetSize(0),
+    mustAutoConsume(false), abortedConsumption(false), isCheckedOut(false)
 {
     // TODO: teach MemBuf to start with zero minSize
     // TODO: limit maxSize by theBodySize, when known?
@@ -283,7 +283,7 @@ BodyPipe::expectNoConsumption()
         AsyncCall::Pointer call= asyncCall(91, 7,
                                            "BodyProducer::noteBodyConsumerAborted",
                                            BodyProducerDialer(theProducer,
-                                                              &BodyProducer::noteBodyConsumerAborted, this));
+                                                   &BodyProducer::noteBodyConsumerAborted, this));
         ScheduleCallHere(call);
         abortedConsumption = true;
 
@@ -383,7 +383,7 @@ BodyPipe::postConsume(size_t size)
         AsyncCall::Pointer call=  asyncCall(91, 7,
                                             "BodyProducer::noteMoreBodySpaceAvailable",
                                             BodyProducerDialer(theProducer,
-                                                               &BodyProducer::noteMoreBodySpaceAvailable, this));
+                                                    &BodyProducer::noteMoreBodySpaceAvailable, this));
         ScheduleCallHere(call);
     }
 }
@@ -413,7 +413,7 @@ BodyPipe::scheduleBodyDataNotification()
         AsyncCall::Pointer call = asyncCall(91, 7,
                                             "BodyConsumer::noteMoreBodyDataAvailable",
                                             BodyConsumerDialer(theConsumer,
-                                                               &BodyConsumer::noteMoreBodyDataAvailable, this));
+                                                    &BodyConsumer::noteMoreBodyDataAvailable, this));
         ScheduleCallHere(call);
     }
 }
@@ -426,13 +426,13 @@ BodyPipe::scheduleBodyEndNotification()
             AsyncCall::Pointer call = asyncCall(91, 7,
                                                 "BodyConsumer::noteBodyProductionEnded",
                                                 BodyConsumerDialer(theConsumer,
-                                                                   &BodyConsumer::noteBodyProductionEnded, this));
+                                                        &BodyConsumer::noteBodyProductionEnded, this));
             ScheduleCallHere(call);
         } else {
             AsyncCall::Pointer call = asyncCall(91, 7,
                                                 "BodyConsumer::noteBodyProducerAborted",
                                                 BodyConsumerDialer(theConsumer,
-                                                                   &BodyConsumer::noteBodyProducerAborted, this));
+                                                        &BodyConsumer::noteBodyProducerAborted, this));
             ScheduleCallHere(call);
         }
     }
@@ -477,8 +477,8 @@ const char *BodyPipe::status() const
 /* BodyPipeCheckout */
 
 BodyPipeCheckout::BodyPipeCheckout(BodyPipe &aPipe): thePipe(aPipe),
-        buf(aPipe.checkOut()), offset(aPipe.consumedSize()),
-        checkedOutSize(buf.contentSize()), checkedIn(false)
+    buf(aPipe.checkOut()), offset(aPipe.consumedSize()),
+    checkedOutSize(buf.contentSize()), checkedIn(false)
 {
 }
 
@@ -502,8 +502,8 @@ BodyPipeCheckout::checkIn()
 }
 
 BodyPipeCheckout::BodyPipeCheckout(const BodyPipeCheckout &c): thePipe(c.thePipe),
-        buf(c.buf), offset(c.offset), checkedOutSize(c.checkedOutSize),
-        checkedIn(c.checkedIn)
+    buf(c.buf), offset(c.offset), checkedOutSize(c.checkedOutSize),
+    checkedIn(c.checkedIn)
 {
     assert(false); // prevent copying
 }
@@ -514,3 +514,4 @@ BodyPipeCheckout::operator =(const BodyPipeCheckout &)
     assert(false); // prevent assignment
     return *this;
 }
+
@@ -169,3 +169,4 @@ class BodyPipe: public RefCountable
 };
 
 #endif /* SQUID_BODY_PIPE_H */
+
@@ -22,10 +22,10 @@
 /* local types */
 
 typedef struct {
-    int bit_count;		/* total number of bits */
-    int bit_on_count;		/* #bits turned on */
-    int bseq_len_sum;		/* sum of all bit seq length */
-    int bseq_count;		/* number of bit seqs */
+    int bit_count;      /* total number of bits */
+    int bit_on_count;       /* #bits turned on */
+    int bseq_len_sum;       /* sum of all bit seq length */
+    int bseq_count;     /* number of bit seqs */
 } CacheDigestStats;
 
 /* local functions */
@@ -53,7 +53,7 @@ CacheDigest *
 cacheDigestCreate(int capacity, int bpe)
 {
     CacheDigest *cd = (CacheDigest *)memAllocate(MEM_CACHE_DIGEST);
-    assert(SQUID_MD5_DIGEST_LENGTH == 16);	/* our hash functions rely on 16 byte keys */
+    assert(SQUID_MD5_DIGEST_LENGTH == 16);  /* our hash functions rely on 16 byte keys */
     cacheDigestInit(cd, capacity, bpe);
     return cd;
 }
@@ -243,7 +243,7 @@ cacheDigestGuessStatsReport(const CacheDigestGuessStats * stats, StoreEntry * se
     const int tot_count = true_count + false_count;
 
     assert(label);
-    assert(tot_count == hit_count + miss_count);	/* paranoid */
+    assert(tot_count == hit_count + miss_count);    /* paranoid */
 
     if (!tot_count) {
         storeAppendPrintf(sentry, "no guess stats for %s available\n", label);
@@ -320,3 +320,4 @@ cacheDigestHashKey(const CacheDigest * cd, const cache_key * key)
 }
 
 #endif
+
@@ -45,3 +45,4 @@ void cacheDigestGuessStatsReport(const CacheDigestGuessStats * stats, StoreEntry
 void cacheDigestReport(CacheDigest * cd, const char *label, StoreEntry * e);
 
 #endif /* SQUID_CACHEDIGEST_H_ */
+
@@ -77,3 +77,4 @@ class CacheManager
 };
 
 #endif /* SQUID_CACHEMANAGER_H */
+
@@ -198,3 +198,4 @@ class CachePeer
 };
 
 #endif /* SQUID_CACHEPEER_H_ */
+
@@ -19,3 +19,4 @@ class CachePeerDomainList
 };
 
 #endif /* SQUID_CACHEPEERDOMAINLIST_H_ */
+
@@ -308,3 +308,4 @@ void ChunkedCodingParser::parseLastChunkExtension()
     theIn->consume(crlfEnd);
     theStep = theChunkSize ? psChunkBody : psTrailer;
 }
+
@@ -81,3 +81,4 @@ class ChunkedCodingParser
 };
 
 #endif /* SQUID_CHUNKEDCODINGPARSER_H */
+
@@ -100,3 +100,4 @@ void ClientDelayConfig::clean()
         aclDestroyAccessList(&pools[i].access);
     }
 }
+
@@ -23,7 +23,7 @@ class ClientDelayPool
 {
 public:
     ClientDelayPool()
-            :   access(NULL), rate(0), highwatermark(0) {}
+        :   access(NULL), rate(0), highwatermark(0) {}
     void dump (StoreEntry * entry, unsigned int poolNumberMinusOne) const;
     acl_access *access;
     int rate;
@@ -37,7 +37,7 @@ class ClientDelayConfig
 {
 public:
     ClientDelayConfig()
-            :   initial(50) {}
+        :   initial(50) {}
     void freePoolCount();
     void dumpPoolCount(StoreEntry * entry, const char *name) const;
     /* parsing of client_delay_pools - number of pools */
@@ -57,3 +57,4 @@ class ClientDelayConfig
 };
 
 #endif // SQUID_CLIENTDELAYCONFIG_H
+
@@ -114,3 +114,4 @@ class CommQuotaQueue
 #endif /* USE_DELAY_POOLS */
 
 #endif
+
@@ -84,3 +84,4 @@ class ClientRequestContext : public RefCountable
 };
 
 #endif /* SQUID_CLIENTREQUESTCONTEXT_H */
+
@@ -165,3 +165,4 @@ CollapsedForwardingRr::~CollapsedForwardingRr()
 {
     delete owner;
 }
+
@@ -44,3 +44,4 @@ class CollapsedForwarding
 };
 
 #endif /* SQUID_COLLAPSED_FORWARDING_H */
+