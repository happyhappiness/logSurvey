----++++ChangeLog
@@ -1,3 +1,19 @@
+Changes to squid-4.0.12 (01 Jul 2016):
+
+	- Regression Fix: shell issues with require_smblib definition
+	- Regression Bug 4532: pid_filename not working as documented
+	- Regression Bug 4504: Too many WARNING: Ignoring error setting CA certificate locations
+	- Bug 4516: security_file_certgen man page update
+	- Bug 4446: undefined reference to &#39;libecap::Name::Name&#39;
+	- Bug 4376: clang cannot build Squid eCAP code
+	- HTTP/1.1: Update all stored headers on 304 revalidation
+	- TLS: Authority Key Identifier certificate extension
+	- Add a script to find kid-specific cache.log lines
+	- Cleanup cppunit detection and use
+	- ... and several performance improvements
+	- ... and some unit test updates
+	- ... and all fixes from 3.5.20
+
 Changes to squid-4.0.11 (09 Jun 2016):
 
 	- Bug 4517: error: comparison between signed and unsigned integer
@@ -172,6 +188,25 @@ Changes to squid-4.0.1 (14 Oct 2015):
 	- ... and many documentation changes
 	- ... and much code cleanup and polishing
 
+Changes to squid-3.5.20 (01 Jul 2016):
+
+	- Bug 4523: smblib compile fails on NetBSD
+	- Bug 4485: off-by-one out-of-bounds Parser::Tokenizer::int64() read errors
+	- Bug 3579: assertion failed &#39;MemPools[type]&#39; from dst_as ACL
+	- Fix icons loading speed
+	- Fix OpenSSL detection on FreeBSD
+	- Fix assertion failed: Write.cc:38: &#39;fd_table[conn-&gt;fd].flags.open&#39;
+	- Fix SEGFAULT parsing malformed adaptation service configuration
+	- Fix ConnStateData::In::maybeMakeSpaceAvailable() logic
+	- Do not override user defined -std option
+	- Do not allow low-level debugging to hide important/critical messages
+	- Do not make bogus recvmsg(2) calls when closing UDS sockets
+	- Support unified EUI format code in external_acl_type
+
+Changes to squid-3.5.19 (09 May 2016):
+
+	- Regression Bug 4515: interception proxy hangs
+
 Changes to squid-3.5.18 (06 May 2016):
 
 	- Bug 4510: stale comment about 32KB limit on shared memory cache entries
----++++configure.ac
@@ -5,7 +5,7 @@
 ## Please see the COPYING and CONTRIBUTORS files for details.
 ##
 
-AC_INIT([Squid Web Proxy],[4.0.11-BZR],[http://bugs.squid-cache.org/],[squid])
+AC_INIT([Squid Web Proxy],[4.0.12-BZR],[http://bugs.squid-cache.org/],[squid])
 AC_PREREQ(2.61)
 AC_CONFIG_HEADERS([include/autoconf.h])
 AC_CONFIG_AUX_DIR(cfgaux)
----++++doc/release-notes/release-3.5.sgml
@@ -1,6 +1,6 @@
 &lt;!doctype linuxdoc system&gt;
 &lt;article&gt;
-&lt;title&gt;Squid 3.5.18 release notes&lt;/title&gt;
+&lt;title&gt;Squid 3.5.20 release notes&lt;/title&gt;
 &lt;author&gt;Squid Developers&lt;/author&gt;
 
 &lt;abstract&gt;
@@ -13,7 +13,7 @@ for Applied Network Research and members of the Web Caching community.
 
 &lt;sect&gt;Notice
 &lt;p&gt;
-The Squid Team are pleased to announce the release of Squid-3.5.18.
+The Squid Team are pleased to announce the release of Squid-3.5.20.
 
 This new release is available for download from &lt;url url=&quot;http://www.squid-cache.org/Versions/v3/3.5/&quot;&gt; or the
  &lt;url url=&quot;http://www.squid-cache.org/Download/http-mirrors.html&quot; name=&quot;mirrors&quot;&gt;.
@@ -364,6 +364,10 @@ This section gives a thorough account of those changes in three categories:
 	&lt;tag&gt;sslproxy_cert_sign_hash&lt;/tag&gt;
 	&lt;p&gt;New directive to set the hashing algorithm to use when signing generated certificates.
 
+	&lt;tag&gt;sslproxy_foreign_intermediate_certs&lt;/tag&gt;
+	&lt;p&gt;New directive to load intermediate certificates for validating server
+	   certificate chains. This directive is only available in 3.5.13 and later.
+
 	&lt;tag&gt;sslproxy_session_cache_size&lt;/tag&gt;
 	&lt;p&gt;New directive which sets the cache size to use for TLS/SSL sessions cache.
 
@@ -452,6 +456,7 @@ This section gives a thorough account of those changes in three categories:
 	&lt;p&gt;New format code &lt;em&gt;%ssl::&amp;lt;cert_subject&lt;/em&gt; to send SSL server certificate DN.
 	&lt;p&gt;New format code &lt;em&gt;%ssl::&amp;lt;cert_issuer&lt;/em&gt; to send SSL server certificate issuer DN.
 	&lt;p&gt;New format code &lt;em&gt;%un&lt;/em&gt; to send any available user name (requires 3.5.7 or later).
+	&lt;p&gt;New format code &lt;em&gt;%&amp;gt;eui&lt;/em&gt; to send either EUI-48 or EUI-64 (requires 3.5.20 or later).
 	&lt;p&gt;New response kv-pair &lt;em&gt;clt_conn_tag=&lt;/em&gt; to associates a given tag with the client TCP connection.
 
 	&lt;tag&gt;forward_max_tries&lt;/tag&gt;
----++++doc/release-notes/release-4.sgml
@@ -1,6 +1,6 @@
 &lt;!doctype linuxdoc system&gt;
 &lt;article&gt;
-&lt;title&gt;Squid 4.0.11 release notes&lt;/title&gt;
+&lt;title&gt;Squid 4.0.12 release notes&lt;/title&gt;
 &lt;author&gt;Squid Developers&lt;/author&gt;
 
 &lt;abstract&gt;
@@ -12,7 +12,7 @@ for Applied Network Research and members of the Web Caching community.
 &lt;toc&gt;
 
 &lt;sect&gt;Notice
-&lt;p&gt;The Squid Team are pleased to announce the release of Squid-4.0.11 for testing.
+&lt;p&gt;The Squid Team are pleased to announce the release of Squid-4.0.12 for testing.
 
 This new release is available for download from &lt;url url=&quot;http://www.squid-cache.org/Versions/v4/&quot;&gt; or the
  &lt;url url=&quot;http://www.squid-cache.org/Download/http-mirrors.html&quot; name=&quot;mirrors&quot;&gt;.
----++++lib/smblib/smblib.c
@@ -150,12 +150,12 @@ SMB_Handle_Type SMB_Connect_Server(SMB_Handle_Type Con_Handle,
        service we are going to call, sine some servers want it in uppercase */
 
     for (i=0; i &lt; strlen(server); i++)
-        called[i] = toupper(server[i]);
+        called[i] = xtoupper(server[i]);
 
     called[strlen(server)] = 0;    /* Make it a string */
 
     for (i=0; i &lt; strlen(con -&gt; myname); i++)
-        calling[i] = toupper(con -&gt; myname[i]);
+        calling[i] = xtoupper(con -&gt; myname[i]);
 
     calling[strlen(con -&gt; myname)] = 0;    /* Make it a string */
 
@@ -266,12 +266,12 @@ SMB_Handle_Type SMB_Connect(SMB_Handle_Type Con_Handle,
        service we are going to call, sine some servers want it in uppercase */
 
     for (i=0; i &lt; strlen(host); i++)
-        called[i] = toupper(host[i]);
+        called[i] = xtoupper(host[i]);
 
     called[strlen(host)] = 0;    /* Make it a string */
 
     for (i=0; i &lt; strlen(con -&gt; myname); i++)
-        calling[i] = toupper(con -&gt; myname[i]);
+        calling[i] = xtoupper(con -&gt; myname[i]);
 
     calling[strlen(con -&gt; myname)] = 0;    /* Make it a string */
 
----++++src/CachePeer.cc
@@ -42,7 +42,6 @@ CachePeer::CachePeer() :
     domain(NULL),
 #if USE_OPENSSL
     sslContext(NULL),
-    sslSession(NULL),
 #endif
     front_end_https(0),
     connection_auth(2 /* auto */)
@@ -102,9 +101,6 @@ CachePeer::~CachePeer()
 #if USE_OPENSSL
     if (sslContext)
         SSL_CTX_free(sslContext);
-
-    if (sslSession)
-        SSL_SESSION_free(sslSession);
 #endif
 }
 
----++++src/CachePeer.h
@@ -184,9 +184,7 @@ class CachePeer
     /// security settings for peer connection
     Security::PeerOptions secure;
     Security::ContextPtr sslContext;
-#if USE_OPENSSL
-    SSL_SESSION *sslSession;
-#endif
+    Security::SessionStatePointer sslSession;
 
     int front_end_https;
     int connection_auth;
----++++src/adaptation/ecap/ServiceRep.cc
@@ -236,7 +236,7 @@ bool Adaptation::Ecap::ServiceRep::probed() const
 
 bool Adaptation::Ecap::ServiceRep::up() const
 {
-    return theService;
+    return bool(theService);
 }
 
 bool Adaptation::Ecap::ServiceRep::wantsUrl(const SBuf &amp;urlPath) const
----++++src/adaptation/icap/ServiceRep.cc
@@ -34,9 +34,6 @@ CBDATA_NAMESPACED_CLASS_INIT(Adaptation::Icap, ServiceRep);
 Adaptation::Icap::ServiceRep::ServiceRep(const ServiceConfigPointer &amp;svcCfg):
     AsyncJob(&quot;Adaptation::Icap::ServiceRep&quot;), Adaptation::Service(svcCfg),
     sslContext(NULL),
-#if USE_OPENSSL
-    sslSession(NULL),
-#endif
     theOptions(NULL), theOptionsFetcher(0), theLastUpdate(0),
     theBusyConns(0),
     theAllWaiters(0),
----++++src/adaptation/icap/ServiceRep.h
@@ -111,9 +111,7 @@ class ServiceRep : public RefCountable, public Adaptation::Service,
     virtual void noteAdaptationAnswer(const Answer &amp;answer);
 
     Security::ContextPtr sslContext;
-#if USE_OPENSSL
-    SSL_SESSION *sslSession;
-#endif
+    Security::SessionStatePointer sslSession;
 
 private:
     // stores Prepare() callback info
----++++src/adaptation/icap/Xaction.cc
@@ -725,8 +725,7 @@ Ssl::IcapPeerConnector::initializeSsl()
     if (check)
         check-&gt;dst_peer_name = *host;
 
-    if (icapService-&gt;sslSession)
-        SSL_set_session(ssl, icapService-&gt;sslSession);
+    Security::GetSessionResumeData(Security::SessionPointer(ssl), icapService-&gt;sslSession);
 
     return ssl;
 }
@@ -738,13 +737,7 @@ Ssl::IcapPeerConnector::noteNegotiationDone(ErrorState *error)
         return;
 
     const int fd = serverConnection()-&gt;fd;
-    auto ssl = fd_table[fd].ssl.get();
-    assert(ssl);
-    if (!SSL_session_reused(ssl)) {
-        if (icapService-&gt;sslSession)
-            SSL_SESSION_free(icapService-&gt;sslSession);
-        icapService-&gt;sslSession = SSL_get1_session(ssl);
-    }
+    Security::GetSessionResumeData(fd_table[fd].ssl, icapService-&gt;sslSession);
 }
 
 void
----++++src/anyp/PortCfg.cc
@@ -143,8 +143,7 @@ AnyP::PortCfg::configureSslServerContext()
         }
     }
 
-    secure.staticContext.resetWithoutLocking(secure.createStaticServerContext(*this));
-    if (!secure.staticContext) {
+    if (!secure.createStaticServerContext(*this)) {
         char buf[128];
         fatalf(&quot;%s_port %s initialization error&quot;, AnyP::ProtocolType_str[transport.protocol], s.toUrl(buf, sizeof(buf)));
     }
----++++src/auth/User.cc
@@ -201,7 +201,7 @@ Auth::User::addIp(Ip::Address ipaddr)
             /* This ip has already been seen. */
             found = 1;
             /* update IP ttl */
-            ipdata-&gt;ip_expiretime = squid_curtime;
+            ipdata-&gt;ip_expiretime = squid_curtime + ::Config.authenticateIpTTL;
         } else if (ipdata-&gt;ip_expiretime &lt;= squid_curtime) {
             /* This IP has expired - remove from the seen list */
             dlinkDelete(&amp;ipdata-&gt;node, &amp;ip_list);
----++++src/cache_cf.cc
@@ -946,10 +946,6 @@ configDoConfigure(void)
         }
     }
 #endif
-
-    if (Config.readAheadGap &lt;= 0) {
-        fatalf(&quot;read_ahead_gap must be greater than 0 bytes&quot;);
-    }
 }
 
 /** Parse a line containing an obsolete directive.
----++++src/cf.data.pre
@@ -5650,17 +5650,6 @@ DEFAULT: 16 KB
 DOC_START
 	The amount of data the cache will buffer ahead of what has been
 	sent to the client when retrieving an object from another server.
-	
-	This also influences the maximum network read(2)/write(2) sizes in some
-	circumstances. Reducing the size of this buffer will decrease
-	per-connection memory usage at the cost of more read(2)/write(2) calls.
-	Conversely, increasing the size of this buffer will decrease the number of
-	read(2)/write(2) calls at the cost of memory usage, potentially improving
-	performance.
-
-	Squid does not slow does the response delivery to the client in order to
-	fill the buffer.
-
 DOC_END
 
 NAME: negative_ttl
----++++src/client_side.cc
@@ -1012,9 +1012,12 @@ ConnStateData::abortRequestParsing(const char *const uri)
     http-&gt;uri = xstrdup(uri);
     setLogUri (http, uri);
     auto *context = new Http::Stream(clientConnection, http);
+    StoreIOBuffer tempBuffer;
+    tempBuffer.data = context-&gt;reqbuf;
+    tempBuffer.length = HTTP_REQBUF_SZ;
     clientStreamInit(&amp;http-&gt;client_stream, clientGetMoreData, clientReplyDetach,
                      clientReplyStatus, new clientReplyContext(http), clientSocketRecipient,
-                     clientSocketDetach, context, context-&gt;getClientStreamBuffer());
+                     clientSocketDetach, context, tempBuffer);
     return context;
 }
 
@@ -1356,11 +1359,15 @@ parseHttpRequest(ConnStateData *csd, const Http1::RequestParserPointer &amp;hp)
     http-&gt;req_sz = hp-&gt;messageHeaderSize();
     Http::Stream *result = new Http::Stream(csd-&gt;clientConnection, http);
 
+    StoreIOBuffer tempBuffer;
+    tempBuffer.data = result-&gt;reqbuf;
+    tempBuffer.length = HTTP_REQBUF_SZ;
+
     ClientStreamData newServer = new clientReplyContext(http);
     ClientStreamData newClient = result;
     clientStreamInit(&amp;http-&gt;client_stream, clientGetMoreData, clientReplyDetach,
                      clientReplyStatus, newServer, clientSocketRecipient,
-                     clientSocketDetach, newClient, result-&gt;getClientStreamBuffer());
+                     clientSocketDetach, newClient, tempBuffer);
 
     /* set url */
     debugs(33,5, &quot;Prepare absolute URL from &quot; &lt;&lt;
@@ -2563,8 +2570,8 @@ httpAccept(const CommAcceptCbParams &amp;params)
     ++incoming_sockets_accepted;
 
     // Socket is ready, setup the connection manager to start using it
-    ConnStateData *connState = Http::NewServer(xact);
-    AsyncJob::Start(connState); // usually async-calls readSomeData()
+    auto *srv = Http::NewServer(xact);
+    AsyncJob::Start(srv); // usually async-calls readSomeData()
 }
 
 #if USE_OPENSSL
@@ -2650,7 +2657,7 @@ clientNegotiateSSL(int fd, void *data)
         return;
     }
 
-    if (SSL_session_reused(ssl)) {
+    if (Security::SessionIsResumed(fd_table[fd].ssl)) {
         debugs(83, 2, &quot;clientNegotiateSSL: Session &quot; &lt;&lt; SSL_get_session(ssl) &lt;&lt;
                &quot; reused on FD &quot; &lt;&lt; fd &lt;&lt; &quot; (&quot; &lt;&lt; fd_table[fd].ipaddr &lt;&lt; &quot;:&quot; &lt;&lt; (int)fd_table[fd].remote_port &lt;&lt; &quot;)&quot;);
     } else {
@@ -2791,8 +2798,8 @@ httpsAccept(const CommAcceptCbParams &amp;params)
     ++incoming_sockets_accepted;
 
     // Socket is ready, setup the connection manager to start using it
-    ConnStateData *connState = Https::NewServer(xact);
-    AsyncJob::Start(connState); // usually async-calls postHttpsAccept()
+    auto *srv = Https::NewServer(xact);
+    AsyncJob::Start(srv); // usually async-calls postHttpsAccept()
 }
 
 void
----++++src/http/Stream.cc
@@ -11,7 +11,6 @@
 #include &quot;http/Stream.h&quot;
 #include &quot;HttpHdrContRange.h&quot;
 #include &quot;HttpHeaderTools.h&quot;
-#include &quot;SquidConfig.h&quot;
 #include &quot;Store.h&quot;
 #include &quot;TimeOrTag.h&quot;
 
@@ -21,10 +20,10 @@ Http::Stream::Stream(const Comm::ConnectionPointer &amp;aConn, ClientHttpRequest *aR
     reply(nullptr),
     writtenToSocket(0),
     mayUseConnection_(false),
-    connRegistered_(false),
-    requestBuffer(nullptr)
+    connRegistered_(false)
 {
     assert(http != nullptr);
+    memset(reqbuf, &#39;\0&#39;, sizeof (reqbuf));
     flags.deferred = 0;
     flags.parsed_ok = 0;
     deferredparams.node = nullptr;
@@ -110,10 +109,12 @@ Http::Stream::pullData()
     debugs(33, 5, reply &lt;&lt; &quot; written &quot; &lt;&lt; http-&gt;out.size &lt;&lt; &quot; into &quot; &lt;&lt; clientConnection);
 
     /* More data will be coming from the stream. */
-    StoreIOBuffer readBuffer = getClientStreamBuffer();
+    StoreIOBuffer readBuffer;
     /* XXX: Next requested byte in the range sequence */
     /* XXX: length = getmaximumrangelenfgth */
     readBuffer.offset = getNextRangeOffset();
+    readBuffer.length = HTTP_REQBUF_SZ;
+    readBuffer.data = reqbuf;
     /* we may note we have reached the end of the wanted ranges */
     clientStreamRead(getTail(), http, readBuffer);
 }
@@ -567,18 +568,6 @@ Http::Stream::deferRecipientForLater(clientStreamNode *node, HttpReply *rep, Sto
     deferredparams.queuedBuffer = receivedData;
 }
 
-StoreIOBuffer
-Http::Stream::getClientStreamBuffer()
-{
-    if (!requestBuffer) {
-        requestBuffer = new MemBlob(Config.readAheadGap);
-    }
-    StoreIOBuffer tempBuffer;
-    tempBuffer.data = requestBuffer-&gt;mem;
-    tempBuffer.length = requestBuffer-&gt;spaceSize();
-    return tempBuffer;
-}
-
 void
 Http::Stream::prepareReply(HttpReply *rep)
 {
----++++GitHub