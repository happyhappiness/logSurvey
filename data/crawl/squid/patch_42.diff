@@ -383,46 +383,6 @@ compat/getnameinfo.c:
 
 ==============================================================================
 
-compat/GnuRegex.h:
-
- * Copyright (C) 1985, 1989, 1990, 1991, 1992, 1993 Free Software Foundation, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
-
-==============================================================================
-
-compat/GnuRegex.c:
-
- * Copyright (C) 1993 Free Software Foundation, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
-
-==============================================================================
-
 compat/inet_ntop.c:
 
 /*
@@ -32,26 +32,6 @@ AC_DEFUN([SQUID_CHECK_DBOPEN_NEEDS_LIBDB],[
 ])
 
 
-dnl check whether regex works by actually compiling one
-dnl sets squid_cv_regex_works to either yes or no
-
-AC_DEFUN([SQUID_CHECK_REGEX_WORKS],[
-  AC_CACHE_CHECK([if the system-supplied regex lib actually works],squid_cv_regex_works,[
-    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
-#if HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
-#if HAVE_REGEX_H
-#include <regex.h> 
-#endif
-]], [[
-regex_t t; regcomp(&t,"",0);]])],
-    [ squid_cv_regex_works=yes ],
-    [ squid_cv_regex_works=no ])
-  ])
-])
-
-
 AC_DEFUN([SQUID_CHECK_LIBIPHLPAPI],[
   AC_CACHE_CHECK([for libIpHlpApi],squid_cv_have_libiphlpapi,[
     SQUID_STATE_SAVE(iphlpapi)
@@ -1,413 +0,0 @@
-/*
- * Copyright (C) 1996-2016 The Squid Software Foundation and contributors
- *
- * Squid software is distributed under GPLv2+ license and includes
- * contributions from numerous individuals and organizations.
- * Please see the COPYING and CONTRIBUTORS files for details.
- */
-
-#ifndef SQUID_REGEXP_LIBRARY_H
-#define SQUID_REGEXP_LIBRARY_H
-
-#if !USE_GNUREGEX /* try the system one by default */
-
-/* POSIX says that <sys/types.h> must be included (by the caller) before
- * <regex.h>.  */
-#if HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
-#if HAVE_REGEX_H
-#include <regex.h>
-#endif
-
-#else  /* USE_GNUREGEX */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/* Definitions for data structures and routines for the regular
- * expression library, version 0.12.
- *
- * Copyright (C) 1985, 1989, 1990, 1991, 1992, 1993 Free Software Foundation, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.  */
-
-/* POSIX says that <sys/types.h> must be included (by the caller) before
- * <regex.h>.  */
-
-/* The following bits are used to determine the regexp syntax we
- * recognize.  The set/not-set meanings are chosen so that Emacs syntax
- * remains the value 0.  The bits are given in alphabetical order, and
- * the definitions shifted by one from the previous bit; thus, when we
- * add or remove a bit, only one other definition need change.  */
-typedef unsigned reg_syntax_t;
-
-/* If this bit is not set, then \ inside a bracket expression is literal.
- * If set, then such a \ quotes the following character.  */
-#define RE_BACKSLASH_ESCAPE_IN_LISTS (1)
-
-/* If this bit is not set, then + and ? are operators, and \+ and \? are
- * literals.
- * If set, then \+ and \? are operators and + and ? are literals.  */
-#define RE_BK_PLUS_QM (RE_BACKSLASH_ESCAPE_IN_LISTS << 1)
-
-/* If this bit is set, then character classes are supported.  They are:
- * [:alpha:], [:upper:], [:lower:],  [:digit:], [:alnum:], [:xdigit:],
- * [:space:], [:print:], [:punct:], [:graph:], and [:cntrl:].
- * If not set, then character classes are not supported.  */
-#define RE_CHAR_CLASSES (RE_BK_PLUS_QM << 1)
-
-/* If this bit is set, then ^ and $ are always anchors (outside bracket
- * expressions, of course).
- * If this bit is not set, then it depends:
- * ^  is an anchor if it is at the beginning of a regular
- * expression or after an open-group or an alternation operator;
- * $  is an anchor if it is at the end of a regular expression, or
- * before a close-group or an alternation operator.
- *
- * This bit could be (re)combined with RE_CONTEXT_INDEP_OPS, because
- * POSIX draft 11.2 says that * etc. in leading positions is undefined.
- * We already implemented a previous draft which made those constructs
- * invalid, though, so we haven't changed the code back.  */
-#define RE_CONTEXT_INDEP_ANCHORS (RE_CHAR_CLASSES << 1)
-
-/* If this bit is set, then special characters are always special
- * regardless of where they are in the pattern.
- * If this bit is not set, then special characters are special only in
- * some contexts; otherwise they are ordinary.  Specifically,
- * * + ? and intervals are only special when not after the beginning,
- * open-group, or alternation operator.  */
-#define RE_CONTEXT_INDEP_OPS (RE_CONTEXT_INDEP_ANCHORS << 1)
-
-/* If this bit is set, then *, +, ?, and { cannot be first in an re or
- * immediately after an alternation or begin-group operator.  */
-#define RE_CONTEXT_INVALID_OPS (RE_CONTEXT_INDEP_OPS << 1)
-
-/* If this bit is set, then . matches newline.
- * If not set, then it doesn't.  */
-#define RE_DOT_NEWLINE (RE_CONTEXT_INVALID_OPS << 1)
-
-/* If this bit is set, then . doesn't match NUL.
- * If not set, then it does.  */
-#define RE_DOT_NOT_NULL (RE_DOT_NEWLINE << 1)
-
-/* If this bit is set, nonmatching lists [^...] do not match newline.
- * If not set, they do.  */
-#define RE_HAT_LISTS_NOT_NEWLINE (RE_DOT_NOT_NULL << 1)
-
-/* If this bit is set, either \{...\} or {...} defines an
- * interval, depending on RE_NO_BK_BRACES.
- * If not set, \{, \}, {, and } are literals.  */
-#define RE_INTERVALS (RE_HAT_LISTS_NOT_NEWLINE << 1)
-
-/* If this bit is set, +, ? and | aren't recognized as operators.
- * If not set, they are.  */
-#define RE_LIMITED_OPS (RE_INTERVALS << 1)
-
-/* If this bit is set, newline is an alternation operator.
- * If not set, newline is literal.  */
-#define RE_NEWLINE_ALT (RE_LIMITED_OPS << 1)
-
-/* If this bit is set, then `{...}' defines an interval, and \{ and \}
- * are literals.
- * If not set, then `\{...\}' defines an interval.  */
-#define RE_NO_BK_BRACES (RE_NEWLINE_ALT << 1)
-
-/* If this bit is set, (...) defines a group, and \( and \) are literals.
- * If not set, \(...\) defines a group, and ( and ) are literals.  */
-#define RE_NO_BK_PARENS (RE_NO_BK_BRACES << 1)
-
-/* If this bit is set, then \<digit> matches <digit>.
- * If not set, then \<digit> is a back-reference.  */
-#define RE_NO_BK_REFS (RE_NO_BK_PARENS << 1)
-
-/* If this bit is set, then | is an alternation operator, and \| is literal.
- * If not set, then \| is an alternation operator, and | is literal.  */
-#define RE_NO_BK_VBAR (RE_NO_BK_REFS << 1)
-
-/* If this bit is set, then an ending range point collating higher
- * than the starting range point, as in [z-a], is invalid.
- * If not set, then when ending range point collates higher than the
- * starting range point, the range is ignored.  */
-#define RE_NO_EMPTY_RANGES (RE_NO_BK_VBAR << 1)
-
-/* If this bit is set, then an unmatched ) is ordinary.
- * If not set, then an unmatched ) is invalid.  */
-#define RE_UNMATCHED_RIGHT_PAREN_ORD (RE_NO_EMPTY_RANGES << 1)
-
-/* Define combinations of the above bits for the standard possibilities.
- * (The [[[ comments delimit what gets put into the Texinfo file, so
- * don't delete them!)  */
-/* [[[begin syntaxes]]] */
-#define RE_SYNTAX_EMACS 0
-
-#define RE_SYNTAX_AWK                           \
-  (RE_BACKSLASH_ESCAPE_IN_LISTS | RE_DOT_NOT_NULL           \
-   | RE_NO_BK_PARENS            | RE_NO_BK_REFS             \
-   | RE_NO_BK_VBAR               | RE_NO_EMPTY_RANGES           \
-   | RE_UNMATCHED_RIGHT_PAREN_ORD)
-
-#define RE_SYNTAX_POSIX_AWK                         \
-  (RE_SYNTAX_POSIX_EXTENDED | RE_BACKSLASH_ESCAPE_IN_LISTS)
-
-#define RE_SYNTAX_GREP                          \
-  (RE_BK_PLUS_QM              | RE_CHAR_CLASSES             \
-   | RE_HAT_LISTS_NOT_NEWLINE | RE_INTERVALS                \
-   | RE_NEWLINE_ALT)
-
-#define RE_SYNTAX_EGREP                         \
-  (RE_CHAR_CLASSES        | RE_CONTEXT_INDEP_ANCHORS            \
-   | RE_CONTEXT_INDEP_OPS | RE_HAT_LISTS_NOT_NEWLINE            \
-   | RE_NEWLINE_ALT       | RE_NO_BK_PARENS             \
-   | RE_NO_BK_VBAR)
-
-#define RE_SYNTAX_POSIX_EGREP                       \
-  (RE_SYNTAX_EGREP | RE_INTERVALS | RE_NO_BK_BRACES)
-
-/* P1003.2/D11.2, section 4.20.7.1, lines 5078ff.  */
-#define RE_SYNTAX_ED RE_SYNTAX_POSIX_BASIC
-
-#define RE_SYNTAX_SED RE_SYNTAX_POSIX_BASIC
-
-/* Syntax bits common to both basic and extended POSIX regex syntax.  */
-#define _RE_SYNTAX_POSIX_COMMON                     \
-  (RE_CHAR_CLASSES | RE_DOT_NEWLINE      | RE_DOT_NOT_NULL      \
-   | RE_INTERVALS  | RE_NO_EMPTY_RANGES)
-
-#define RE_SYNTAX_POSIX_BASIC                       \
-  (_RE_SYNTAX_POSIX_COMMON | RE_BK_PLUS_QM)
-
-/* Differs from ..._POSIX_BASIC only in that RE_BK_PLUS_QM becomes
- * RE_LIMITED_OPS, i.e., \? \+ \| are not recognized.  Actually, this
- * isn't minimal, since other operators, such as \`, aren't disabled.  */
-#define RE_SYNTAX_POSIX_MINIMAL_BASIC                   \
-  (_RE_SYNTAX_POSIX_COMMON | RE_LIMITED_OPS)
-
-#define RE_SYNTAX_POSIX_EXTENDED                    \
-  (_RE_SYNTAX_POSIX_COMMON | RE_CONTEXT_INDEP_ANCHORS           \
-   | RE_CONTEXT_INDEP_OPS  | RE_NO_BK_BRACES                \
-   | RE_NO_BK_PARENS       | RE_NO_BK_VBAR              \
-   | RE_UNMATCHED_RIGHT_PAREN_ORD)
-
-/* Differs from ..._POSIX_EXTENDED in that RE_CONTEXT_INVALID_OPS
- * replaces RE_CONTEXT_INDEP_OPS and RE_NO_BK_REFS is added.  */
-#define RE_SYNTAX_POSIX_MINIMAL_EXTENDED                \
-  (_RE_SYNTAX_POSIX_COMMON  | RE_CONTEXT_INDEP_ANCHORS          \
-   | RE_CONTEXT_INVALID_OPS | RE_NO_BK_BRACES               \
-   | RE_NO_BK_PARENS        | RE_NO_BK_REFS             \
-   | RE_NO_BK_VBAR      | RE_UNMATCHED_RIGHT_PAREN_ORD)
-/* [[[end syntaxes]]] */
-
-/* Maximum number of duplicates an interval can allow.  Some systems
- * (erroneously) define this in other header files, but we want our
- * value, so remove any previous define.  */
-#ifdef RE_DUP_MAX
-#undef RE_DUP_MAX
-#endif
-#define RE_DUP_MAX ((1 << 15) - 1)
-
-/* POSIX `cflags' bits (i.e., information for `regcomp').  */
-
-/* If this bit is set, then use extended regular expression syntax.
- * If not set, then use basic regular expression syntax.  */
-#define REG_EXTENDED 1
-
-/* If this bit is set, then ignore case when matching.
- * If not set, then case is significant.  */
-#define REG_ICASE (REG_EXTENDED << 1)
-
-/* If this bit is set, then anchors do not match at newline
- * characters in the string.
- * If not set, then anchors do match at newlines.  */
-#define REG_NEWLINE (REG_ICASE << 1)
-
-/* If this bit is set, then report only success or fail in regexec.
- * If not set, then returns differ between not matching and errors.  */
-#define REG_NOSUB (REG_NEWLINE << 1)
-
-/* POSIX `eflags' bits (i.e., information for regexec).  */
-
-/* If this bit is set, then the beginning-of-line operator doesn't match
- * the beginning of the string (presumably because it's not the
- * beginning of a line).
- * If not set, then the beginning-of-line operator does match the
- * beginning of the string.  */
-#define REG_NOTBOL 1
-
-/* Like REG_NOTBOL, except for the end-of-line.  */
-#define REG_NOTEOL (1 << 1)
-
-/* If any error codes are removed, changed, or added, update the
- * `re_error_msg' table in regex.c.  */
-typedef enum {
-    REG_NOERROR = 0,        /* Success.  */
-    REG_NOMATCH,        /* Didn't find a match (for regexec).  */
-
-    /* POSIX regcomp return error codes.  (In the order listed in the
-     * standard.)  */
-    REG_BADPAT,         /* Invalid pattern.  */
-    REG_ECOLLATE,       /* Not implemented.  */
-    REG_ECTYPE,         /* Invalid character class name.  */
-    REG_EESCAPE,        /* Trailing backslash.  */
-    REG_ESUBREG,        /* Invalid back reference.  */
-    REG_EBRACK,         /* Unmatched left bracket.  */
-    REG_EPAREN,         /* Parenthesis imbalance.  */
-    REG_EBRACE,         /* Unmatched \{.  */
-    REG_BADBR,          /* Invalid contents of \{\}.  */
-    REG_ERANGE,         /* Invalid range end.  */
-    REG_ESPACE,         /* Ran out of memory.  */
-    REG_BADRPT,         /* No preceding re for repetition op.  */
-
-    /* Error codes we've added.  */
-    REG_EEND,           /* Premature end.  */
-    REG_ESIZE,          /* Compiled pattern bigger than 2^16 bytes.  */
-    REG_ERPAREN         /* Unmatched ) or \); not returned from regcomp.  */
-} reg_errcode_t;
-
-/* This data structure represents a compiled pattern.  Before calling
- * the pattern compiler, the fields `buffer', `allocated', `fastmap',
- * `translate', and `no_sub' can be set.  After the pattern has been
- * compiled, the `re_nsub' field is available.  All other fields are
- * private to the regex routines.  */
-
-struct re_pattern_buffer {
-    /* [[[begin pattern_buffer]]] */
-    /* Space that holds the compiled pattern.  It is declared as
-     * `unsigned char *' because its elements are
-     * sometimes used as array indexes.  */
-    unsigned char *buffer;
-
-    /* Number of bytes to which `buffer' points.  */
-    unsigned long allocated;
-
-    /* Number of bytes actually used in `buffer'.  */
-    unsigned long used;
-
-    /* Syntax setting with which the pattern was compiled.  */
-    reg_syntax_t syntax;
-
-    /* Pointer to a fastmap, if any, otherwise zero.  re_search uses
-     * the fastmap, if there is one, to skip over impossible
-     * starting points for matches.  */
-    char *fastmap;
-
-    /* Either a translate table to apply to all characters before
-     * comparing them, or zero for no translation.  The translation
-     * is applied to a pattern when it is compiled and to a string
-     * when it is matched.  */
-    char *translate;
-
-    /* Number of subexpressions found by the compiler.  */
-    size_t re_nsub;
-
-    /* Zero if this pattern cannot match the empty string, one else.
-     * Well, in truth it's used only in `re_search_2', to see
-     * whether or not we should use the fastmap, so we don't set
-     * this absolutely perfectly; see `re_compile_fastmap' (the
-     * `duplicate' case).  */
-    unsigned can_be_null:1;
-
-    /* If REGS_UNALLOCATED, allocate space in the `regs' structure
-     * for `max (RE_NREGS, re_nsub + 1)' groups.
-     * If REGS_REALLOCATE, reallocate space if necessary.
-     * If REGS_FIXED, use what's there.  */
-#define REGS_UNALLOCATED 0
-#define REGS_REALLOCATE 1
-#define REGS_FIXED 2
-    unsigned regs_allocated:2;
-
-    /* Set to zero when `regex_compile' compiles a pattern; set to one
-     * by `re_compile_fastmap' if it updates the fastmap.  */
-    unsigned fastmap_accurate:1;
-
-    /* If set, `re_match_2' does not return information about
-     * subexpressions.  */
-    unsigned no_sub:1;
-
-    /* If set, a beginning-of-line anchor doesn't match at the
-     * beginning of the string.  */
-    unsigned not_bol:1;
-
-    /* Similarly for an end-of-line anchor.  */
-    unsigned not_eol:1;
-
-    /* If true, an anchor at a newline matches.  */
-    unsigned newline_anchor:1;
-
-    /* [[[end pattern_buffer]]] */
-};
-
-typedef struct re_pattern_buffer regex_t;
-
-/* search.c (search_buffer) in Emacs needs this one opcode value.  It is
- * defined both in `regex.c' and here.  */
-#define RE_EXACTN_VALUE 1
-
-/* Type for byte offsets within the string.  POSIX mandates this.  */
-typedef int regoff_t;
-
-/* This is the structure we store register match data in.  See
- * regex.texinfo for a full description of what registers match.  */
-struct re_registers {
-    unsigned num_regs;
-    regoff_t *start;
-    regoff_t *end;
-};
-
-/* If `regs_allocated' is REGS_UNALLOCATED in the pattern buffer,
- * `re_match_2' returns information about at least this many registers
- * the first time a `regs' structure is passed.  */
-#ifndef RE_NREGS
-#define RE_NREGS 30
-#endif
-
-/* POSIX specification for registers.  Aside from the different names than
- * `re_registers', POSIX uses an array of structures, instead of a
- * structure of arrays.  */
-typedef struct {
-    regoff_t rm_so;     /* Byte offset from string's start to substring's start.  */
-    regoff_t rm_eo;     /* Byte offset from string's start to substring's end.  */
-} regmatch_t;
-
-/* Declarations for routines.  */
-
-/* To avoid duplicating every routine declaration -- once with a
- * prototype (if we are ANSI), and once without (if we aren't) -- we
- * use the following macro to declare argument types.  This
- * unfortunately clutters up the declarations a bit, but I think it's
- * worth it.  */
-
-/* POSIX compatibility.  */
-extern int regcomp(regex_t * preg, const char *pattern, int cflags);
-extern int regexec(const regex_t * preg, const char *string, size_t nmatch, regmatch_t pmatch[], int eflags);
-extern size_t regerror(int errcode, const regex_t * preg, char *errbuf, size_t errbuf_size);
-extern void regfree(regex_t * preg);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* USE_GNUREGEX */
-#endif /* SQUID_REGEXP_LIBRARY_H */
-
-/*
- * Local variables:
- * make-backup-files: t
- * version-control: t
- * trim-versions-without-asking: nil
- * End:
- */
-
@@ -33,8 +33,6 @@ libcompatsquid_la_SOURCES = \
 	getaddrinfo.h \
 	getnameinfo.cc \
 	getnameinfo.h \
-	GnuRegex.c \
-	GnuRegex.h \
 	inet_ntop.cc \
 	inet_ntop.h \
 	inet_pton.cc \
@@ -107,13 +107,6 @@
 /* Valgrind API macros changed between two versions squid supports */
 #include "compat/valgrind.h"
 
-/**
- * A Regular Expression library is bundled with Squid.
- * Default is to use a system provided one, but the bundle
- * may be used instead with explicit configuration.
- */
-#include "compat/GnuRegex.h"
-
 /* cppunit is not quite C++0x compatible yet */
 #include "compat/cppunit.h"
 
@@ -2807,7 +2807,6 @@ AC_CHECK_HEADERS( \
   paths.h \
   poll.h \
   pwd.h \
-  regex.h \
   sched.h \
   siginfo.h \
   signal.h \
@@ -3342,9 +3341,6 @@ AC_CHECK_FUNCS(\
 	pthread_setschedparam \
 	pthread_sigmask \
 	putenv \
-	regcomp \
-	regexec \
-	regfree \
 	res_init \
 	__res_init \
 	rint \
@@ -3630,51 +3626,6 @@ if test x"$enable_zph_qos" = "xyes" ; then
                       [Enable support for QOS netfilter mark preservation])
 fi
 
-
-AC_CHECK_LIB(regex, regexec, [REGEXLIB="-lregex"],[REGEXLIB=''])
-AC_ARG_ENABLE(gnuregex,
-  AS_HELP_STRING([--enable-gnuregex],
-                 [Compile GNUregex.  Unless you have reason to use 
-                 this option, you should not enable it.
-                 This library file is usually only required on Windows and 
-                 very old Unix boxes which do not have their own regex 
-                 library built in.]), [
-SQUID_YESNO([$enableval],[unrecognized argument to --enable-gnuregex: $enableval])
-])
-# force-enable on old solaris and nextstep
-if test "x${enable_gnuregex:=auto}" = "xauto" ; then
-    case "$host" in
-    *-sun-solaris2.[[0-4]])
-	  enable_gnuregex="yes"
-	  ;;
-    *-next-nextstep*)
-	  enable_gnuregex="yes"
-	  ;;
-    esac
-fi
-
-# try detecting if it is needed
-if test "x$enable_gnuregex" = "xauto" ; then
-  SQUID_CHECK_REGEX_WORKS
-  if test "x$squid_cv_regex_works" = "xyes" ; then
-    enable_gnuregex=no
-  else
-    enable_gnuregex=yes
-  fi
-fi
-AC_MSG_CHECKING(if GNUregex needs to be compiled)
-AC_MSG_RESULT($enable_gnuregex)
-if test "x$enable_gnuregex" = "xyes"; then
-  # for some reason (force-enable, test..) gnuregex was found as needed. Override any system lib
-  REGEXLIB=""
-fi
-#if no reason was found to enable gnuregex, disable it
-if test "x$enable_gnuregex" = "xauto" ; then
-  enable_gnuregex=no
-fi
-SQUID_DEFINE_BOOL(USE_GNUREGEX,$enable_gnuregex,[Define if we should use GNU regex])
-AC_SUBST(REGEXLIB)
-
 SQUID_DETECT_UDP_SND_BUFSIZE
 SQUID_DETECT_UDP_RECV_BUFSIZE
 SQUID_DETECT_TCP_SND_BUFSIZE
@@ -82,7 +82,16 @@ This section gives a thorough account of those changes in three categories:
 <sect1>Changes to existing directives<label id="modifieddirectives">
 <p>
 <descrip>
-	<p>No changes to existing directives in this version.
+	<tag>acl</tag>
+	<p>Due to differences between GNU Regex and libc regular expressions
+	   patterns escaping the double quote (") character escaped by a slash (\)
+	   will now be rejected. Use without the escaping is still accepted.
+	   This affects all *_regex and regular expression based ACL types.
+
+	<tag>refresh_pattern</tag>
+	<p>Due to differences between GNU Regex and libc regular expressions
+	   patterns escaping the double quote (") character with a slash (\)
+	   will now be rejected. Use without the escaping is still accepted.
 
 </descrip>
 
@@ -125,7 +134,19 @@ This section gives an account of those changes in three categories:
 <sect1>Removed options<label id="removedoptions">
 <p>
 <descrip>
-	<p>No removed options in this version.
+	<tag>--enable-gnuregex</tag>
+	<p>Squid now uses C++11 std::regex instead of GNU Regex. Removed.
+
+	<tag>LDFLAGS</tag>
+	<p>Squid now uses C++11 std::regex API instead of the C regex.h API.
+	   This means that linker overrides for -lregex and regex.h no longer exist.
+	<p>Custom regex libraries need to provide bindings for the std::regex
+	   API to link with Squid. This may require additional -I path to be
+	   provided in CXXFLAGS to the library headers. Refer to the chosen
+	   library documentation for more details.
+	<p>Note that popular modern high performance regex libraries should
+	   already be used by the STL internal implementation and no longer
+	   need manually linking.
 
 </descrip>
 
@@ -1275,7 +1275,6 @@ PREDEFINED             = __cplusplus \
                          USE_DELAY_POOLS \
                          USE_DLMALLOC \
                          USE_EPOLL \
-                         USE_GNUREGEX \
                          USE_HEXDUMP \
                          USE_HTCP \
                          USE_ICMP \
@@ -559,7 +559,6 @@ squid_LDADD = \
 	$(REPL_OBJS) \
 	$(NETTLELIB) \
 	$(CRYPTLIB) \
-	$(REGEXLIB) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
 	$(SNMP_LIBS) \
@@ -658,7 +657,6 @@ ufsdump_LDADD = \
 	$(REPL_OBJS) \
 	$(NETTLELIB) \
 	$(CRYPTLIB) \
-	$(REGEXLIB) \
 	$(SSLLIB) \
 	$(COMPAT_LIB) \
 	$(EPOLL_LIBS) \
@@ -1146,7 +1144,6 @@ tests_testACLMaxUserIP_LDADD= \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
-	$(REGEXLIB) \
 	$(SSLLIB) \
 	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
@@ -1419,7 +1416,6 @@ tests_testCacheManager_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
-	$(REGEXLIB) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(LIBCPPUNIT_LIBS) \
@@ -1593,7 +1589,6 @@ tests_testDiskIO_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
-	$(REGEXLIB) \
 	$(SSLLIB) \
 	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
@@ -1848,7 +1843,6 @@ tests_testEvent_LDADD = \
 	sbuf/libsbuf.la \
 	$(SNMP_LIBS) \
 	$(NETTLELIB) \
-	$(REGEXLIB) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(LIBCPPUNIT_LIBS) \
@@ -2084,7 +2078,6 @@ tests_testEventLoop_LDADD = \
 	store/libstore.la \
 	$(SNMP_LIBS) \
 	$(NETTLELIB) \
-	$(REGEXLIB) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(LIBCPPUNIT_LIBS) \
@@ -2316,7 +2309,6 @@ tests_test_http_range_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
-	$(REGEXLIB) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(LIBCPPUNIT_LIBS) \
@@ -2620,7 +2612,6 @@ tests_testHttpRequest_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
-	$(REGEXLIB) \
 	$(SSLLIB) \
 	$(KRB5LIBS) \
 	$(LIBCPPUNIT_LIBS) \
@@ -2841,7 +2832,6 @@ tests_testStore_LDADD= \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
-	$(REGEXLIB) \
 	$(SSLLIB) \
 	CommCalls.o \
 	$(LIBCPPUNIT_LIBS) \
@@ -2879,7 +2869,6 @@ tests_testString_LDADD = \
 	ip/libip.la \
 	sbuf/libsbuf.la \
 	$(top_builddir)/lib/libmiscutil.la \
-	$(REGEXLIB) \
 	$(SSLLIB) \
 	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
@@ -3066,7 +3055,6 @@ tests_testUfs_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
-	$(REGEXLIB) \
 	$(SSLLIB) \
 	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
@@ -3241,7 +3229,6 @@ tests_testRock_LDADD = \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
 	$(NETTLELIB) \
-	$(REGEXLIB) \
 	$(SSLLIB) \
 	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
@@ -3473,7 +3460,6 @@ tests_testURL_LDADD = \
 	format/libformat.la \
 	store/libstore.la \
 	sbuf/libsbuf.la \
-	$(REGEXLIB) \
 	$(REPL_OBJS) \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
@@ -3553,7 +3539,6 @@ tests_testConfigParser_LDADD = \
 	sbuf/libsbuf.la \
 	base/libbase.la \
 	$(top_builddir)/lib/libmiscutil.la \
-	$(REGEXLIB) \
 	$(SSLLIB) \
 	$(LIBCPPUNIT_LIBS) \
 	$(COMPAT_LIB) \
@@ -52,13 +52,13 @@ SBufList
 ACLRegexData::dump() const
 {
     SBufList sl;
-    int flags = REG_EXTENDED | REG_NOSUB;
+    auto flags = std::regex::extended | std::regex::nosubs;
 
     // walk and dump the list
     // keeping the flags values consistent
     for (auto &i : data) {
         if (i.flags != flags) {
-            if ((i.flags&REG_ICASE) != 0) {
+            if ((i.flags & std::regex::icase)) {
                 sl.emplace_back("-i");
             } else {
                 sl.emplace_back("+i");
@@ -101,24 +101,27 @@ removeUnnecessaryWildcards(char * t)
 }
 
 static bool
-compileRE(std::list<RegexPattern> &curlist, const char * RE, int flags)
+compileRE(std::list<RegexPattern> &curlist, const char * RE, const decltype(RegexPattern::flags) &flags)
 {
     if (RE == NULL || *RE == '\0')
         return curlist.empty(); // XXX: old code did this. It looks wrong.
 
-    regex_t comp;
-    if (int errcode = regcomp(&comp, RE, flags)) {
-        char errbuf[256];
-        regerror(errcode, &comp, errbuf, sizeof errbuf);
+    // std::regex constructor does the actual compile and throws on invalid patterns
+    try {
+        curlist.emplace_back(flags, RE);
+
+    } catch(std::regex_error &e) {
         debugs(28, DBG_CRITICAL, cfg_filename << " line " << config_lineno << ": " << config_input_line);
-        debugs(28, DBG_CRITICAL, "ERROR: invalid regular expression: '" << RE << "': " << errbuf);
+        debugs(28, DBG_CRITICAL, "ERROR: invalid regular expression: '" << RE << "': " << e.code());
         return false;
-    }
-    debugs(28, 2, "compiled '" << RE << "' with flags " << flags);
 
-    curlist.emplace_back(flags, RE);
-    curlist.back().regex = comp;
+    } catch(...) {
+        debugs(28, DBG_CRITICAL, cfg_filename << " line " << config_lineno << ": " << config_input_line);
+        debugs(28, DBG_CRITICAL, "ERROR: invalid regular expression: '" << RE << "': (unknown error)");
+        return false;
+    }
 
+    debugs(28, 2, "compiled '" << RE << "' with flags " << flags);
     return true;
 }
 
@@ -131,7 +134,7 @@ compileOptimisedREs(std::list<RegexPattern> &curlist, const SBufList &sl)
 {
     std::list<RegexPattern> newlist;
     int numREs = 0;
-    int flags = REG_EXTENDED | REG_NOSUB;
+    auto flags = std::regex::extended | std::regex::nosubs;
     int largeREindex = 0;
     char largeRE[BUFSIZ];
     *largeRE = 0;
@@ -143,25 +146,25 @@ compileOptimisedREs(std::list<RegexPattern> &curlist, const SBufList &sl)
         static const SBuf minus_i("-i");
         static const SBuf plus_i("+i");
         if (configurationLineWord == minus_i) {
-            if (flags & REG_ICASE) {
+            if ((flags & std::regex::icase)) {
                 /* optimisation of  -i ... -i */
                 debugs(28, 2, "optimisation of -i ... -i" );
             } else {
                 debugs(28, 2, "-i" );
                 if (!compileRE(newlist, largeRE, flags))
                     return 0;
-                flags |= REG_ICASE;
+                flags |= std::regex::icase;
                 largeRE[largeREindex=0] = '\0';
             }
         } else if (configurationLineWord == plus_i) {
-            if ((flags & REG_ICASE) == 0) {
+            if (!(flags & std::regex::icase)) {
                 /* optimisation of  +i ... +i */
                 debugs(28, 2, "optimisation of +i ... +i");
             } else {
                 debugs(28, 2, "+i");
                 if (!compileRE(newlist, largeRE, flags))
                     return 0;
-                flags &= ~REG_ICASE;
+                flags &= ~std::regex::icase;
                 largeRE[largeREindex=0] = '\0';
             }
         } else if (RElen + largeREindex + 3 < BUFSIZ-1) {
@@ -206,14 +209,14 @@ compileOptimisedREs(std::list<RegexPattern> &curlist, const SBufList &sl)
 static void
 compileUnoptimisedREs(std::list<RegexPattern> &curlist, const SBufList &sl)
 {
-    int flags = REG_EXTENDED | REG_NOSUB;
+    auto flags = std::regex::extended | std::regex::nosubs;
 
     static const SBuf minus_i("-i"), plus_i("+i");
     for (auto configurationLineWord : sl) {
         if (configurationLineWord == minus_i) {
-            flags |= REG_ICASE;
+            flags |= std::regex::icase;
         } else if (configurationLineWord == plus_i) {
-            flags &= ~REG_ICASE;
+            flags &= ~std::regex::icase;
         } else {
             if (!compileRE(curlist, configurationLineWord.c_str() , flags))
                 debugs(28, DBG_CRITICAL, "ERROR: Skipping regular expression. "
@@ -10,35 +10,18 @@
 #include "base/RegexPattern.h"
 #include <utility>
 
-RegexPattern::RegexPattern(int aFlags, const char *aPattern) :
-    flags(aFlags),
-    pattern(xstrdup(aPattern))
-{
-    memset(&regex, 0, sizeof(regex));
-}
-
-RegexPattern::RegexPattern(RegexPattern &&o) :
-    flags(std::move(o.flags)),
-    regex(std::move(o.regex)),
-    pattern(std::move(o.pattern))
-{
-    memset(&o.regex, 0, sizeof(o.regex));
-    o.pattern = nullptr;
-}
-
-RegexPattern::~RegexPattern()
-{
-    xfree(pattern);
-    regfree(&regex);
-}
+RegexPattern::RegexPattern(const std::regex_constants::syntax_option_type &aFlags, const char *aPattern) :
+        flags(aFlags),
+        pattern(xstrdup(aPattern)),
+        regex(pattern, flags)
+{}
 
 RegexPattern &
 RegexPattern::operator =(RegexPattern &&o)
 {
     flags = std::move(o.flags);
     regex = std::move(o.regex);
-    memset(&o.regex, 0, sizeof(o.regex));
-    pattern = std::move(o.pattern);
+    pattern = o.pattern;
     o.pattern = nullptr;
     return *this;
 }
@@ -9,9 +9,10 @@
 #ifndef SQUID_SRC_BASE_REGEXPATTERN_H
 #define SQUID_SRC_BASE_REGEXPATTERN_H
 
-#include "compat/GnuRegex.h"
 #include "mem/forward.h"
 
+#include <regex>
+
 /**
  * A regular expression,
  * plain text and compiled representations
@@ -22,25 +23,22 @@ class RegexPattern
 
 public:
     RegexPattern() = delete;
-    RegexPattern(int aFlags, const char *aPattern);
-    ~RegexPattern();
-
-    // regex type varies by library, usually not safe to copy
+    RegexPattern(const std::regex_constants::syntax_option_type &aFlags, const char *aPattern); // throws std::regex_error
     RegexPattern(const RegexPattern &) = delete;
     RegexPattern &operator =(const RegexPattern &) = delete;
-
-    RegexPattern(RegexPattern &&);
+    RegexPattern(RegexPattern &&) = default; // throws std::regex_error
     RegexPattern &operator =(RegexPattern &&);
+    ~RegexPattern() { xfree(pattern); }
 
-    const char * c_str() const {return pattern;}
-    bool match(const char *str) const {return regexec(&regex,str,0,NULL,0)==0;}
+    const char * c_str() const { return pattern; }
+    bool match(const char *str) const { return std::regex_search(str, regex); }
 
 public:
-    int flags;
-    regex_t regex;
+    std::regex_constants::syntax_option_type flags;
 
 private:
     char *pattern;
+    std::regex regex;
 };
 
 #endif /* SQUID_SRC_BASE_REGEXPATTERN_H */
@@ -2577,7 +2577,7 @@ dump_refreshpattern(StoreEntry * entry, const char *name, RefreshPattern * head)
     while (head != NULL) {
         storeAppendPrintf(entry, "%s%s %s %d %d%% %d",
                           name,
-                          head->pattern.flags&REG_ICASE ? " -i" : null_string,
+                          head->pattern.flags & std::regex::icase ? " -i" : null_string,
                           head->pattern.c_str(),
                           (int) head->min / 60,
                           (int) (100.0 * head->pct + 0.5),
@@ -2623,7 +2623,6 @@ static void
 parse_refreshpattern(RefreshPattern ** head)
 {
     char *token;
-    char *pattern;
     time_t min = 0;
     double pct = 0.0;
     time_t max = 0;
@@ -2641,33 +2640,25 @@ parse_refreshpattern(RefreshPattern ** head)
     int ignore_private = 0;
 #endif
 
-    int i;
-    RefreshPattern *t;
-    regex_t comp;
-    int errcode;
-    int flags = REG_EXTENDED | REG_NOSUB;
-
-    if ((token = ConfigParser::RegexPattern()) != NULL) {
+    auto flags = std::regex::extended | std::regex::nosubs;
 
+    if ((token = ConfigParser::RegexPattern())) {
         if (strcmp(token, "-i") == 0) {
-            flags |= REG_ICASE;
+            flags |= std::regex::icase;
             token = ConfigParser::RegexPattern();
         } else if (strcmp(token, "+i") == 0) {
-            flags &= ~REG_ICASE;
+            flags &= ~std::regex::icase;
             token = ConfigParser::RegexPattern();
         }
-
-    }
-
-    if (token == NULL) {
+    } else {
         debugs(3, DBG_CRITICAL, "FATAL: refresh_pattern missing the regex pattern parameter");
         self_destruct();
         return;
     }
 
-    pattern = xstrdup(token);
+    char *pattern = xstrdup(token);
 
-    i = GetInteger();       /* token: min */
+    int i = GetInteger();       /* token: min */
 
     /* catch negative and insanely huge values close to 32-bit wrap */
     if (i < 0) {
@@ -2698,7 +2689,7 @@ parse_refreshpattern(RefreshPattern ** head)
     max = (time_t) (i * 60);    /* convert minutes to seconds */
 
     /* Options */
-    while ((token = ConfigParser::NextToken()) != NULL) {
+    while ((token = ConfigParser::NextToken())) {
         if (!strcmp(token, "refresh-ims")) {
             refresh_ims = 1;
         } else if (!strcmp(token, "store-stale")) {
@@ -2735,19 +2726,19 @@ parse_refreshpattern(RefreshPattern ** head)
             debugs(22, DBG_CRITICAL, "refreshAddToList: Unknown option '" << pattern << "': " << token);
     }
 
-    if ((errcode = regcomp(&comp, pattern, flags)) != 0) {
-        char errbuf[256];
-        regerror(errcode, &comp, errbuf, sizeof errbuf);
+    RefreshPattern *t = nullptr;
+    try { // RegexPattern constructor throws on pattern errors
+        t = new RefreshPattern(pattern, flags);
+
+    } catch (std::regex_error &e) {
         debugs(22, DBG_CRITICAL, "" << cfg_filename << " line " << config_lineno << ": " << config_input_line);
-        debugs(22, DBG_CRITICAL, "refreshAddToList: Invalid regular expression '" << pattern << "': " << errbuf);
+        debugs(22, DBG_CRITICAL, "ERROR: Invalid regular expression '" << pattern << "': " << e.code());
         xfree(pattern);
         return;
     }
 
     pct = pct < 0.0 ? 0.0 : pct;
     max = max < 0 ? 0 : max;
-    t = new RefreshPattern(pattern, flags);
-    t->pattern.regex = comp;
     t->min = min;
     t->pct = pct;
     t->max = max;
@@ -48,6 +48,7 @@
 #endif
 
 #include <cerrno>
+#include <regex>
 
 namespace Ftp
 {
@@ -530,6 +531,11 @@ ftpListPartsFree(ftpListParts ** parts)
 static ftpListParts *
 ftpListParseParts(const char *buf, struct Ftp::GatewayFlags flags)
 {
+    static const std::regex scan_ftp_integer("^[0-9]+$", std::regex::extended | std::regex::nosubs);
+    static const std::regex scan_ftp_time("^[0-9:]+$", std::regex::extended | std::regex::nosubs);
+    static const std::regex scan_ftp_dostime("^[0-9]+-[0-9]+-[0-9]+$", std::regex::extended | std::regex::nosubs);
+    static const std::regex scan_ftp_dosdate("^[0-9]+:[0-9]+[AP]M$", std::regex::extended | std::regex::nosubs | std::regex::icase);
+
     ftpListParts *p = NULL;
     char *t = NULL;
     const char *ct = NULL;
@@ -538,19 +544,6 @@ ftpListParseParts(const char *buf, struct Ftp::GatewayFlags flags)
     int n_tokens;
     static char tbuf[128];
     char *xbuf = NULL;
-    static int scan_ftp_initialized = 0;
-    static regex_t scan_ftp_integer;
-    static regex_t scan_ftp_time;
-    static regex_t scan_ftp_dostime;
-    static regex_t scan_ftp_dosdate;
-
-    if (!scan_ftp_initialized) {
-        scan_ftp_initialized = 1;
-        regcomp(&scan_ftp_integer, "^[0123456789]+$", REG_EXTENDED | REG_NOSUB);
-        regcomp(&scan_ftp_time, "^[0123456789:]+$", REG_EXTENDED | REG_NOSUB);
-        regcomp(&scan_ftp_dosdate, "^[0123456789]+-[0123456789]+-[0123456789]+$", REG_EXTENDED | REG_NOSUB);
-        regcomp(&scan_ftp_dostime, "^[0123456789]+:[0123456789]+[AP]M$", REG_EXTENDED | REG_NOSUB | REG_ICASE);
-    }
 
     if (buf == NULL)
         return NULL;
@@ -587,16 +580,17 @@ ftpListParseParts(const char *buf, struct Ftp::GatewayFlags flags)
         char *day = tokens[i + 1];
         char *year = tokens[i + 2];
 
+        // checking that the other bits are all of the right pattern...
         if (!is_month(month))
             continue;
 
-        if (regexec(&scan_ftp_integer, size, 0, NULL, 0) != 0)
+        if (!std::regex_match(size, scan_ftp_integer))
             continue;
 
-        if (regexec(&scan_ftp_integer, day, 0, NULL, 0) != 0)
+        if (!std::regex_match(day, scan_ftp_integer))
             continue;
 
-        if (regexec(&scan_ftp_time, year, 0, NULL, 0) != 0) /* Yr | hh:mm */
+        if (!std::regex_match(year, scan_ftp_time)) /* Yr | hh:mm */
             continue;
 
         snprintf(tbuf, 128, "%s %2s %5s",
@@ -640,8 +634,8 @@ ftpListParseParts(const char *buf, struct Ftp::GatewayFlags flags)
 
     /* try it as a DOS listing, 04-05-70 09:33PM ... */
     if (n_tokens > 3 &&
-            regexec(&scan_ftp_dosdate, tokens[0], 0, NULL, 0) == 0 &&
-            regexec(&scan_ftp_dostime, tokens[1], 0, NULL, 0) == 0) {
+            std::regex_match(tokens[0], scan_ftp_dosdate) &&
+            std::regex_match(tokens[1], scan_ftp_dostime)) {
         if (!strcasecmp(tokens[2], "<dir>")) {
             p->type = 'd';
         } else {
@@ -15,6 +15,8 @@
 #include "mgr/QueryParams.h"
 #include "mgr/StringParam.h"
 
+#include <regex>
+
 Mgr::QueryParam::Pointer
 Mgr::QueryParams::get(const String& name) const
 {
@@ -68,34 +70,40 @@ Mgr::QueryParams::find(const String& name) const
 bool
 Mgr::QueryParams::ParseParam(const String& paramStr, Param& param)
 {
-    bool parsed = false;
-    regmatch_t pmatch[3];
-    regex_t intExpr;
-    regcomp(&intExpr, "^([a-z][a-z0-9_]*)=([0-9]+((,[0-9]+))*)$", REG_EXTENDED | REG_ICASE);
-    regex_t stringExpr;
-    regcomp(&stringExpr, "^([a-z][a-z0-9_]*)=([^&= ]+)$", REG_EXTENDED | REG_ICASE);
-    if (regexec(&intExpr, paramStr.termedBuf(), 3, pmatch, 0) == 0) {
-        param.first = paramStr.substr(pmatch[1].rm_so, pmatch[1].rm_eo);
+    std::regex intExpr("^([a-z][a-z0-9_]*)=([0-9]+((,[0-9]+))*)$", std::regex::extended | std::regex::icase);
+    std::regex stringExpr("^([a-z][a-z0-9_]*)=([^&= ]+)$", std::regex::extended | std::regex::icase);
+    std::smatch pmatch;
+
+    std::string temp(paramStr.termedBuf());
+    if (std::regex_match(temp, pmatch, intExpr)) {
+
+        auto itr = pmatch.begin();
+        ++itr; // move to [1] - first actual sub-match
+
+        // match [1] is the key name
+        param.first = itr->str().c_str();
+        ++itr;
+
+        // match [2] and later are a series of N,N,N,N,N values
         std::vector<int> array;
-        int n = pmatch[2].rm_so;
-        for (int i = n; i < pmatch[2].rm_eo; ++i) {
-            if (paramStr[i] == ',') {
-                array.push_back(atoi(paramStr.substr(n, i).termedBuf()));
-                n = i + 1;
-            }
+        while (itr != pmatch.end()) {
+            if (itr->str().c_str()[0] == ',')
+                array.push_back(atoi(itr->str().c_str()+1));
+            else
+                array.push_back(atoi(itr->str().c_str()));
+            ++itr;
         }
-        if (n < pmatch[2].rm_eo)
-            array.push_back(atoi(paramStr.substr(n, pmatch[2].rm_eo).termedBuf()));
         param.second = new IntParam(array);
-        parsed = true;
-    } else if (regexec(&stringExpr, paramStr.termedBuf(), 3, pmatch, 0) == 0) {
-        param.first = paramStr.substr(pmatch[1].rm_so, pmatch[1].rm_eo);
-        param.second = new StringParam(paramStr.substr(pmatch[2].rm_so, pmatch[2].rm_eo));
-        parsed = true;
+        return true;
     }
-    regfree(&stringExpr);
-    regfree(&intExpr);
-    return parsed;
+
+    if (std::regex_match(temp, pmatch, stringExpr)) {
+        param.first = pmatch[1].str().c_str();
+        param.second = new StringParam(pmatch[2].str().c_str());
+        return true;
+    }
+
+    return false;
 }
 
 bool
@@ -9,6 +9,7 @@
 /* DEBUG: section 25    MIME Parsing and Internal Icons */
 
 #include "squid.h"
+#include "base/RegexPattern.h"
 #include "fde.h"
 #include "fs_io.h"
 #include "globals.h"
@@ -58,15 +59,16 @@ class MimeEntry
     MEMPROXY_CLASS(MimeEntry);
 
 public:
-    explicit MimeEntry(const char *aPattern, const regex_t &compiledPattern,
+    MimeEntry(const char *aPattern, const decltype(RegexPattern::flags) &reFlags,
                        const char *aContentType,
                        const char *aContentEncoding, const char *aTransferMode,
                        bool optionViewEnable, bool optionDownloadEnable,
                        const char *anIconName);
+    MimeEntry(const MimeEntry &) = delete;
+    MimeEntry(const MimeEntry &&) = delete;
     ~MimeEntry();
 
-    const char *pattern;
-    regex_t compiled_pattern;
+    RegexPattern pattern;
     const char *content_type;
     const char *content_encoding;
     char transfer_mode;
@@ -90,7 +92,7 @@ mimeGetEntry(const char *fn, int skip_encodings)
         t = NULL;
 
         for (m = MimeTable; m; m = m->next) {
-            if (regexec(&m->compiled_pattern, name, 0, 0, 0) == 0)
+            if (m->pattern.match(name))
                 break;
         }
 
@@ -233,17 +235,14 @@ mimeInit(char *filename)
     char buf[BUFSIZ];
     char chopbuf[BUFSIZ];
     char *t;
-    char *pattern;
     char *icon;
     char *type;
     char *encoding;
     char *mode;
     char *option;
     int view_option;
     int download_option;
-    regex_t re;
     MimeEntry *m;
-    int re_flags = REG_EXTENDED | REG_NOSUB | REG_ICASE;
 
     if (filename == NULL)
         return;
@@ -260,6 +259,8 @@ mimeInit(char *filename)
 
     mimeFreeMemory();
 
+    const auto re_flags = std::regex::extended | std::regex::nosubs | std::regex::icase;
+
     while (fgets(buf, BUFSIZ, fp)) {
         if ((t = strchr(buf, '#')))
             *t = '\0';
@@ -275,6 +276,7 @@ mimeInit(char *filename)
 
         xstrncpy(chopbuf, buf, BUFSIZ);
 
+        char *pattern;
         if ((pattern = strtok(chopbuf, w_space)) == NULL) {
             debugs(25, DBG_IMPORTANT, "mimeInit: parse error: '" << buf << "'");
             continue;
@@ -312,14 +314,14 @@ mimeInit(char *filename)
                 debugs(25, DBG_IMPORTANT, "mimeInit: unknown option: '" << buf << "' (" << option << ")");
         }
 
-        if (regcomp(&re, pattern, re_flags) != 0) {
-            debugs(25, DBG_IMPORTANT, "mimeInit: regcomp error: '" << buf << "'");
+        try {
+            m = new MimeEntry(pattern, re_flags, type, encoding, mode, view_option, download_option, icon);
+
+        } catch (std::regex_error &e) {
+            debugs(25, DBG_IMPORTANT, "mimeInit: invalid regular expression: '" << buf << "'");
             continue;
         }
 
-        m = new MimeEntry(pattern,re,type,encoding,mode,view_option,
-                          download_option,icon);
-
         *MimeTableTail = m;
 
         MimeTableTail = &m->next;
@@ -440,23 +442,21 @@ MimeIcon::created(StoreEntry *newEntry)
 
 MimeEntry::~MimeEntry()
 {
-    xfree(pattern);
     xfree(content_type);
     xfree(content_encoding);
-    regfree(&compiled_pattern);
 }
 
-MimeEntry::MimeEntry(const char *aPattern, const regex_t &compiledPattern,
+MimeEntry::MimeEntry(const char *aPattern, const decltype(RegexPattern::flags) &reFlags,
                      const char *aContentType, const char *aContentEncoding,
                      const char *aTransferMode, bool optionViewEnable,
                      bool optionDownloadEnable, const char *anIconName) :
-    pattern(xstrdup(aPattern)),
-    compiled_pattern(compiledPattern),
+    pattern(reFlags, aPattern),
     content_type(xstrdup(aContentType)),
     content_encoding(xstrdup(aContentEncoding)),
     view_option(optionViewEnable),
     download_option(optionDownloadEnable),
-    theIcon(anIconName), next(NULL)
+    theIcon(anIconName),
+    next(nullptr)
 {
     if (!strcasecmp(aTransferMode, "ascii"))
         transfer_mode = 'A';
@@ -8,10 +8,6 @@
 
 /* DEBUG: section 22    Refresh Calculation */
 
-#ifndef USE_POSIX_REGEX
-#define USE_POSIX_REGEX     /* put before includes; always use POSIX */
-#endif
-
 #include "squid.h"
 #include "HttpHdrCc.h"
 #include "HttpReply.h"
@@ -83,7 +79,7 @@ static const RefreshPattern *refreshUncompiledPattern(const char *);
 static OBJH refreshStats;
 static int refreshStaleness(const StoreEntry * entry, time_t check_time, const time_t age, const RefreshPattern * R, stale_flags * sf);
 
-static RefreshPattern DefaultRefresh("<none>", 0);
+static RefreshPattern DefaultRefresh(".",std::regex_constants::syntax_option_type());
 
 /** Locate the first refresh_pattern rule that matches the given URL by regex.
  *
@@ -697,7 +693,7 @@ refreshStats(StoreEntry * sentry)
                           R->stats.matchCount,
                           R->stats.matchTests,
                           xpercent(R->stats.matchCount, R->stats.matchTests),
-                          (R->pattern.flags&REG_ICASE ? "-i " : ""),
+                          (R->pattern.flags & std::regex::icase ? "-i " : ""),
                           R->pattern.c_str());
     }
 
@@ -37,7 +37,6 @@ MAKETEST="distcheck"
 DISTCHECK_CONFIGURE_FLAGS=" \
 	--disable-build-info \
 	--disable-loadable-modules \
-	--disable-gnuregex \
 	--disable-optimizations \
 	--disable-inline \
 	--disable-debug-cbdata \
@@ -52,7 +52,6 @@ MAKETEST="distcheck"
 #     we use it to perform the same duty between our nested scripts.
 DISTCHECK_CONFIGURE_FLAGS=" \
 	--enable-loadable-modules \
-	--enable-gnuregex \
 	--enable-optimizations \
 	--enable-inline \
 	--enable-debug-cbdata \
@@ -52,7 +52,6 @@ MAKETEST="distcheck"
 #     we use it to perform the same duty between our nested scripts.
 DISTCHECK_CONFIGURE_FLAGS=" \
 	--enable-loadable-modules \
-	--enable-gnuregex \
 	--enable-optimizations \
 	--enable-inline \
 	--enable-debug-cbdata \
@@ -19,6 +19,13 @@ acl G dstdom_regex \.g...le\.com$
 acl B browser ^Mozilla
 acl B browser ^Java/[0-9]+(\.[0-9]+)?
 
+# double-quotes 'regression' from GNU regex library
+refresh_pattern "foo 0 80% 20160
+refresh_pattern ["] 0 80% 20160
+refresh_pattern "foo\" 0 80% 20160
+refresh_pattern "foo["] 0 80% 20160
+refresh_pattern foo\" 0 80% 20160
+
 # invalid pattern - this should ERROR
 acl foo browser *
 
@@ -47,6 +47,7 @@
 #include <cstdlib>
 #include <cstring>
 #include <fstream>
+#include <regex>
 #include <sys/types.h>
 #include <memory.h>
 
@@ -57,9 +58,6 @@ readConfigFile( CacheDirVector& cachedir, const char* fn, FILE* debug )
 //          fn (IN): file name of squid.conf to use
 // returns: number of entries, or negative to warn of errors
 {
-    static const char* expression =
-        "^[ \t]*cache_dir([ \t]+([[:alpha:]]+))?[ \t]+([[:graph:]]+)[ \t]+([0-9]+)[ \t]+([0-9]+)[ \t]+([0-9]+)";
-
     // try to open file
     if ( debug ) fprintf( debug, "# trying to open %s\n", fn ? fn : "(null)" );
     std::ifstream cfgin(fn);
@@ -69,20 +67,15 @@ readConfigFile( CacheDirVector& cachedir, const char* fn, FILE* debug )
     }
 
     // prepare regular expression for matching
+    static const char * expression = "^[ \t]*cache_dir([ \t]+([[:alpha:]]+))?[ \t]+([[:graph:]]+)[ \t]+([0-9]+)[ \t]+([0-9]+)[ \t]+([0-9]+)";
     if ( debug ) fprintf( debug, "# trying to compile \"%s\"\n", expression );
-    regex_t rexp;
-    int result = regcomp( &rexp, expression, REG_EXTENDED );
-    if ( result != 0 ) {
-        char buffer[256];
-        regerror( result, &rexp, buffer, sizeof(buffer) );
-        fprintf( stderr, "regular expression \"%s\": %s\n", expression, buffer );
-        return -1;
-    }
+
+    static const std::regex rexp(expression, std::regex::extended);
 
     // read line by line
     if ( debug ) fputs( "# trying to read lines\n", debug );
 
-    regmatch_t subs[8];
+    std::smatch subs; // set of std::string so we can use ==
     char *s, line[1024];
     CacheDir cd;
     while ( cfgin.getline( line, sizeof(line)) ) {
@@ -95,93 +88,62 @@ readConfigFile( CacheDirVector& cachedir, const char* fn, FILE* debug )
         if ( *line == '\0' || *line == '\n' ) continue;
 
         // test line
-        if ( (result=regexec( &rexp, line, 7, subs, 0 )) != 0 ) {
-            // error or no match
-            if ( result != REG_NOMATCH ) {
-                char buffer[256];
-                regerror( result, &rexp, buffer, sizeof(buffer) );
-                fprintf( stderr, "while matching \"%s\" against %s%s\n",
-                         expression, line, buffer );
-                regfree(&rexp);
-                cfgin.close();
-                return -1;
-            }
+        std::string tmpLine(line);
+        if (!std::regex_search(tmpLine, subs, rexp))
+            continue;
+
+        // match, please record
+        memset( &cd, 0, sizeof(cd) );
+        if ( debug ) fprintf( debug, "# match '%s' on line %s", subs[0].str().c_str(), line);
+
+        // extract information. If 6th parenthesis is filled, this is
+        // a new squid with disk types, otherwise it is an older version
+        int offset = 2;
+        if (subs[6].str().empty()) {
+            // old version, disk type at position 2 is always UFS
+            cd.type = CacheDir::CDT_UFS;
         } else {
-            // match, please record
-            memset( &cd, 0, sizeof(cd) );
-            if ( debug ) fprintf( debug, "# match from %d-%d on line %s",
-                                      (int)subs[0].rm_so, (int)subs[0].rm_eo,
-                                      line );
-
-            // terminate line after matched expression
-            line[ subs[0].rm_eo ] = '\0';
-
-            // extract information. If 6th parenthesis is filled, this is
-            // a new squid with disk types, otherwise it is an older version
-            int offset = 2;
-            if ( subs[6].rm_so == -1 ) {
-                // old version, disk type at position 2 is always UFS
+            // new version, disk type at position 2
+            if ( debug ) fprintf( debug, "# match '%s' in \"%s\"\n", subs[offset].str().c_str(), subs[0].str().c_str());
+            static const std::string ufsDir("ufs",3);
+            static const std::string aufsDir("aufs",4);
+            static const std::string asyncUfsDir("asyncufs",8);
+            static const std::string diskdDir("diskd",5);
+            if (subs[offset] == ufsDir)
                 cd.type = CacheDir::CDT_UFS;
-            } else {
-                // new version, disk type at position 2
-                line[ subs[offset].rm_eo ] = '\0';
-                if ( debug ) fprintf( debug, "# match from %d-%d on \"%s\"\n",
-                                          (int)subs[offset].rm_so,
-                                          (int)subs[offset].rm_eo,
-                                          line+subs[offset].rm_so );
-                if ( strcmp( line + subs[offset].rm_so, "ufs" ) == 0 )
-                    cd.type = CacheDir::CDT_UFS;
-                else if ( strcmp( line + subs[offset].rm_so, "asyncufs" ) == 0 )
-                    cd.type = CacheDir::CDT_AUFS;
-                else if ( strcmp( line + subs[offset].rm_so, "diskd" ) == 0 )
-                    cd.type = CacheDir::CDT_DISKD;
-                else
-                    cd.type = CacheDir::CDT_OTHER;
-                ++offset;
-            }
-
-            // extract base directory
-            line[ subs[offset].rm_eo ] = '\0';
-            if ( debug ) fprintf( debug, "# match from %d-%d on \"%s\"\n",
-                                      (int)subs[offset].rm_so,
-                                      (int)subs[offset].rm_eo,
-                                      line+subs[offset].rm_so );
-            cd.base = xstrdup( line+subs[offset].rm_so );
+            else if (subs[offset] == aufsDir || subs[offset] == asyncUfsDir)
+                cd.type = CacheDir::CDT_AUFS;
+            else if (subs[offset] == diskdDir)
+                cd.type = CacheDir::CDT_DISKD;
+            else
+                cd.type = CacheDir::CDT_OTHER;
             ++offset;
+        }
 
-            // extract size information
-            line[ subs[offset].rm_eo ] = '\0';
-            if ( debug ) fprintf( debug, "# match from %d-%d on \"%s\"\n",
-                                      (int)subs[offset].rm_so,
-                                      (int)subs[offset].rm_eo,
-                                      line+subs[offset].rm_so );
-            cd.size = strtoul( line+subs[offset].rm_so, 0, 10 );
-            ++offset;
+        // extract base directory
+        if ( debug ) fprintf( debug, "# match '%s' in \"%s\"\n", subs[offset].str().c_str(), subs[0].str().c_str());
+        cd.base = xstrdup(subs[offset].str().c_str());
+        ++offset;
 
-            // extract 1st level directories
-            line[ subs[offset].rm_eo ] = '\0';
-            if ( debug ) fprintf( debug, "# match from %d-%d on \"%s\"\n",
-                                      (int)subs[offset].rm_so,
-                                      (int)subs[offset].rm_eo,
-                                      line+subs[offset].rm_so );
-            cd.level[0] = strtoul( line+subs[offset].rm_so, 0, 10 );
-            ++offset;
+        // extract size information
+        if ( debug ) fprintf( debug, "# match '%s' in \"%s\"\n", subs[offset].str().c_str(), subs[0].str().c_str());
+        cd.size = strtoul(subs[offset].str().c_str(), 0, 10);
+        ++offset;
 
-            // extract 2nd level directories
-            line[ subs[offset].rm_eo ] = '\0';
-            if ( debug ) fprintf( debug, "# match from %d-%d on \"%s\"\n",
-                                      (int)subs[offset].rm_so,
-                                      (int)subs[offset].rm_eo,
-                                      line+subs[offset].rm_so );
-            cd.level[1] = strtoul( line+subs[offset].rm_so, 0, 10 );
-            ++offset;
+        // extract 1st level directories
+        if ( debug ) fprintf( debug, "# match '%s' in \"%s\"\n", subs[offset].str().c_str(), subs[0].str().c_str());
+        cd.level[0] = strtoul(subs[offset].str().c_str(), 0, 10);
+        ++offset;
 
-            cachedir.push_back( cd );
-        }
+        // extract 2nd level directories
+        if ( debug ) fprintf( debug, "# match '%s' in \"%s\"\n", subs[offset].str().c_str(), subs[0].str().c_str());
+        cd.level[1] = strtoul(subs[offset].str().c_str(), 0, 10);
+        ++offset;
+
+        cachedir.push_back( cd );
     }
 
     cfgin.close();
-    regfree(&rexp);
     return cachedir.size();
 }
 
@@ -108,6 +108,7 @@
 #include <cstdlib>
 #include <cstring>
 #include <dirent.h>
+#include <regex>
 #include <sys/stat.h>
 #include <sys/wait.h>
 #include <fcntl.h>
@@ -152,49 +153,28 @@ static const char* programname = 0;
 
 // ----------------------------------------------------------------------
 
-struct REList {
-    REList( const char* what, bool doCase );
-    ~REList();
-    bool match( const char* check ) const;
-
-    REList*     next;
-    const char* data;
-    regex_t     rexp;
-};
-
-REList::REList( const char* what, bool doCase )
-    :next(0),data(xstrdup(what))
+class REList
 {
-    int result = regcomp( &rexp, what,
-                          REG_EXTENDED | REG_NOSUB | (doCase ? 0 : REG_ICASE) );
-    if ( result != 0 ) {
-        char buffer[256];
-        regerror( result, &rexp, buffer, 256 );
-        fprintf( stderr, "unable to compile re \"%s\": %s\n", what, buffer );
-        exit(1);
+public:
+    REList( const char* what, bool doCase ) :
+        next(nullptr),
+        data(xstrdup(what)),
+        rexp(data, std::regex::extended | std::regex::nosubs |
+             (doCase ? std::regex_constants::syntax_option_type() : std::regex::icase) )
+    {}
+
+    ~REList() {
+        if (next) delete next;
+        xfree(data);
     }
-}
 
-REList::~REList()
-{
-    if ( next ) delete next;
-    if ( data ) xfree((void*) data);
-    regfree(&rexp);
-}
+    bool match(const char *check) const {return std::regex_match(check, rexp);}
 
-bool
-REList::match( const char* check ) const
-{
-    int result = regexec( &rexp, check, 0, 0, 0 );
-    if ( result != 0 && result != REG_NOMATCH ) {
-        char buffer[256];
-        regerror( result, &rexp, buffer, 256 );
-        fprintf( stderr, "unable to execute re \"%s\"\n+ on line \"%s\": %s\n",
-                 data, check, buffer );
-        exit(1);
-    }
-    return ( result == 0 );
-}
+    REList*     next;
+    const char* data;
+private:
+    std::regex  rexp;
+};
 
 // ----------------------------------------------------------------------
 
@@ -450,12 +430,12 @@ match( const char* fn, const REList* list )
                 if ( list == 0 )
                     flag = action( fd, datastart, fn, (char*) urlmeta->data, meta );
                 else {
-                    REList* head = (REList*) list; // YUCK!
-                    while ( head != 0 ) {
+                    const REList * head = list;
+                    while (head) {
                         if ( head->match( (char*) urlmeta->data ) ) break;
                         head = head->next;
                     }
-                    if ( head != 0 )
+                    if (head)
                         flag = action( fd, datastart, fn, (char*) urlmeta->data, meta );
                     else flag = true;
                 }
@@ -640,7 +620,7 @@ parseCommandline( int argc, char* argv[], REList*& head,
     ::programname = ptr;
 
     // extract commandline parameters
-    REList* tail = head = 0;
+    REList* tail = head = nullptr;
     opterr = 0;
     while ( (option = getopt( argc, argv, "ac:C:d:E:e:F:f:Hnp:P:sv" )) != -1 ) {
         switch ( option ) {
@@ -678,11 +658,16 @@ parseCommandline( int argc, char* argv[], REList*& head,
                 fprintf( stderr, "%c requires a regex pattern argument!\n", option );
                 exit(1);
             }
-            if ( head == 0 )
-                tail = head = new REList( optarg, option=='E' );
-            else {
-                tail->next = new REList( optarg, option=='E' );
-                tail = tail->next;
+            try { // std::regex constructor throws on pattern errors
+                if (!head)
+                    tail = head = new REList( optarg, option=='E' );
+                else {
+                    tail->next = new REList( optarg, option=='E' );
+                    tail = tail->next;
+                }
+            } catch (std::regex_error &e) {
+                fprintf(stderr, "%c contains invalid regular expression: %s\n", option, optarg);
+                exit(1);
             }
             break;
 
@@ -710,11 +695,17 @@ parseCommandline( int argc, char* argv[], REList*& head,
                         --len;
                     }
 
-                    // insert into list of expressions
-                    if ( head == 0 ) tail = head = new REList(line,option=='F');
-                    else {
-                        tail->next = new REList(line,option=='F');
-                        tail = tail->next;
+                    try { // std::regex constructor throws on pattern errors
+                        // insert into list of expressions
+                        if (!head)
+                            tail = head = new REList(line,option=='F');
+                        else {
+                            tail->next = new REList(line,option=='F');
+                            tail = tail->next;
+                        }
+                    } catch (std::regex_error &e) {
+                        fprintf(stderr, "%s:%lu: invalid regular expression\n", optarg, lineno);
+                        exit(1);
                     }
                 }
                 fclose(rfile);
@@ -889,7 +880,7 @@ int
 main( int argc, char* argv[] )
 {
     // setup variables
-    REList* list = 0;
+    REList* list = nullptr;
     char* conffile = xstrdup( DEFAULT_SQUID_CONF );
     serverPort = htons(DEFAULTPORT);
     if ( convertHostname(DEFAULTHOST,serverHost) == -1 ) {