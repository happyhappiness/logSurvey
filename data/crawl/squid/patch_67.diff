----++++src/client_side.cc
@@ -176,8 +176,6 @@ static void clientListenerConnectionOpened(AnyP::PortCfgPointer &amp;s, const Ipc::F
 CBDATA_CLASS_INIT(ClientSocketContext);
 
 /* Local functions */
-static IOCB clientWriteComplete;
-static IOCB clientWriteBodyComplete;
 static IOACB httpAccept;
 #if USE_OPENSSL
 static IOACB httpsAccept;
@@ -851,9 +849,7 @@ ClientSocketContext::sendBody(HttpReply * rep, StoreIOBuffer bodyData)
     if (!multipartRangeRequest() &amp;&amp; !http-&gt;request-&gt;flags.chunkedReply) {
         size_t length = lengthToSend(bodyData.range());
         noteSentBodyBytes (length);
-        AsyncCall::Pointer call = commCbCall(33, 5, &quot;clientWriteBodyComplete&quot;,
-                                             CommIoCbPtrFun(clientWriteBodyComplete, this));
-        Comm::Write(clientConnection, bodyData.data, length, call, NULL);
+        getConn()-&gt;write(bodyData.data, length);
         return;
     }
 
@@ -864,13 +860,10 @@ ClientSocketContext::sendBody(HttpReply * rep, StoreIOBuffer bodyData)
     else
         packChunk(bodyData, mb);
 
-    if (mb.contentSize()) {
-        /* write */
-        AsyncCall::Pointer call = commCbCall(33, 5, &quot;clientWriteComplete&quot;,
-                                             CommIoCbPtrFun(clientWriteComplete, this));
-        Comm::Write(clientConnection, &amp;mb, call);
-    }  else
-        writeComplete(clientConnection, NULL, 0, Comm::OK);
+    if (mb.contentSize())
+        getConn()-&gt;write(&amp;mb);
+    else
+        writeComplete(0);
 }
 
 /**
@@ -1257,11 +1250,7 @@ ClientSocketContext::sendStartOfMessage(HttpReply * rep, StoreIOBuffer bodyData)
         }
     }
 
-    /* write */
-    debugs(33,7, HERE &lt;&lt; &quot;sendStartOfMessage schedules clientWriteComplete&quot;);
-    AsyncCall::Pointer call = commCbCall(33, 5, &quot;clientWriteComplete&quot;,
-                                         CommIoCbPtrFun(clientWriteComplete, this));
-    Comm::Write(clientConnection, mb, call);
+    getConn()-&gt;write(mb);
     delete mb;
 }
 
@@ -1332,13 +1321,6 @@ clientSocketDetach(clientStreamNode * node, ClientHttpRequest * http)
     clientStreamDetach(node, http);
 }
 
-static void
-clientWriteBodyComplete(const Comm::ConnectionPointer &amp;conn, char *, size_t size, Comm::Flag errflag, int xerrno, void *data)
-{
-    debugs(33,7, &quot;schedule clientWriteComplete&quot;);
-    clientWriteComplete(conn, NULL, size, errflag, xerrno, data);
-}
-
 void
 ConnStateData::readNextRequest()
 {
@@ -1619,17 +1601,6 @@ ClientSocketContext::socketState()
     return STREAM_NONE;
 }
 
-/**
- * A write has just completed to the client, or we have just realised there is
- * no more data to send.
- */
-void
-clientWriteComplete(const Comm::ConnectionPointer &amp;conn, char *bufnotused, size_t size, Comm::Flag errflag, int, void *data)
-{
-    ClientSocketContext *context = (ClientSocketContext *)data;
-    context-&gt;writeComplete(conn, bufnotused, size, errflag);
-}
-
 /// remembers the abnormal connection termination for logging purposes
 void
 ClientSocketContext::noteIoError(const int xerrno)
@@ -1680,21 +1651,27 @@ ConnStateData::stopSending(const char *error)
 }
 
 void
-ClientSocketContext::writeComplete(const Comm::ConnectionPointer &amp;conn, char *, size_t size, Comm::Flag errflag)
+ConnStateData::afterClientWrite(size_t size)
+{
+    if (pipeline.empty())
+        return;
+
+    pipeline.front()-&gt;writeComplete(size);
+}
+
+// TODO: make this only need size parameter, ConnStateData handles the rest
+void
+ClientSocketContext::writeComplete(size_t size)
 {
     const StoreEntry *entry = http-&gt;storeEntry();
-    http-&gt;out.size += size;
-    debugs(33, 5, HERE &lt;&lt; conn &lt;&lt; &quot;, sz &quot; &lt;&lt; size &lt;&lt;
-           &quot;, err &quot; &lt;&lt; errflag &lt;&lt; &quot;, off &quot; &lt;&lt; http-&gt;out.size &lt;&lt; &quot;, len &quot; &lt;&lt;
+    debugs(33, 5, clientConnection &lt;&lt; &quot;, sz &quot; &lt;&lt; size &lt;&lt;
+           &quot;, off &quot; &lt;&lt; (http-&gt;out.size + size) &lt;&lt; &quot;, len &quot; &lt;&lt;
            (entry ? entry-&gt;objectLen() : 0));
-    clientUpdateSocketStats(http-&gt;logType, size);
-
-    /* Bail out quickly on Comm::ERR_CLOSING - close handlers will tidy up */
 
-    if (errflag == Comm::ERR_CLOSING || !Comm::IsConnOpen(conn))
-        return;
+    http-&gt;out.size += size;
+    clientUpdateSocketStats(http-&gt;logType, size);
 
-    if (errflag || clientHttpRequestStatus(conn-&gt;fd, http)) {
+    if (clientHttpRequestStatus(clientConnection-&gt;fd, http)) {
         initiateClose(&quot;failure or true request status&quot;);
         /* Do we leak here ? */
         return;
@@ -1707,7 +1684,7 @@ ClientSocketContext::writeComplete(const Comm::ConnectionPointer &amp;conn, char *,
         break;
 
     case STREAM_COMPLETE: {
-        debugs(33, 5, conn &lt;&lt; " Stream complete, keepalive is " &lt;&lt; http-&gt;request-&gt;flags.proxyKeepalive);
+        debugs(33, 5, clientConnection &lt;&lt; " Stream complete, keepalive is " &lt;&lt; http-&gt;request-&gt;flags.proxyKeepalive);
         ConnStateData *c = http-&gt;getConn();
         if (!http-&gt;request-&gt;flags.proxyKeepalive)
             clientConnection-&gt;close();
@@ -1725,7 +1702,7 @@ ClientSocketContext::writeComplete(const Comm::ConnectionPointer &amp;conn, char *,
         return;
 
     default:
-        fatal("Hit unreachable code in clientWriteComplete\n");
+        fatal("Hit unreachable code in ClientSocketContext::writeComplete\n");
     }
 }
 
----++++src/client_side.h
@@ -90,7 +90,7 @@ class ClientSocketContext : public RefCountable
     ClientSocketContext(const Comm::ConnectionPointer &amp;aConn, ClientHttpRequest *aReq);
     ~ClientSocketContext();
     bool startOfOutput() const;
-    void writeComplete(const Comm::ConnectionPointer &amp;conn, char *bufnotused, size_t size, Comm::Flag errflag);
+    void writeComplete(size_t size);
 
     Comm::ConnectionPointer clientConnection; /// details about the client connection socket.
     ClientHttpRequest *http;    /* we pretend to own that job */
@@ -138,13 +138,13 @@ class ClientSocketContext : public RefCountable
     bool multipartRangeRequest() const;
     void registerWithConn();
     void noteIoError(const int xerrno); ///&lt; update state to reflect I/O error
+    void initiateClose(const char *reason); ///&lt; terminate due to a send/write error (may continue reading)
 
 private:
     void prepareReply(HttpReply * rep);
     void packChunk(const StoreIOBuffer &amp;bodyData, MemBuf &amp;mb);
     void packRange(StoreIOBuffer const &amp;, MemBuf * mb);
     void doClose();
-    void initiateClose(const char *reason);
 
     bool mayUseConnection_; /* This request may use the connection. Don&#39;t read anymore requests for now */
     bool connRegistered_;
@@ -193,6 +193,7 @@ class ConnStateData : public Server, public HttpControlMsgSink, public Registere
     virtual void receivedFirstByte();
     virtual bool handleReadData();
     virtual void afterClientRead();
+    virtual void afterClientWrite(size_t);
 
     /* HttpControlMsgSink API */
     virtual void sendControlMsg(HttpControlMsg);
----++++src/servers/Http1Server.cc
@@ -257,7 +257,7 @@ Http::One::Server::handleReply(HttpReply *rep, StoreIOBuffer receivedData)
                                           !receivedData.data &amp;&amp;
                                           !receivedData.length;
     if (responseFinishedOrFailed &amp;&amp; !mustSendLastChunk) {
-        context-&gt;writeComplete(context-&gt;clientConnection, NULL, 0, Comm::OK);
+        context-&gt;writeComplete(0);
         return;
     }
 
----++++src/servers/Server.cc
@@ -176,22 +176,31 @@ Server::doClientRead(const CommIoCbParams &amp;io)
     afterClientRead();
 }
 
+/** callback handling the Comm::Write completion
+ *
+ * Will call afterClientWrite(size_t) to sync the I/O state.
+ * Then writeSomeData() to initiate any followup writes that
+ * could be immediately done.
+ */
 void
 Server::clientWriteDone(const CommIoCbParams &amp;io)
 {
     debugs(33,5, io.conn);
-    Must(writer != NULL);
-    writer = NULL;
+    Must(writer != nullptr);
+    writer = nullptr;
 
     /* Bail out quickly on Comm::ERR_CLOSING - close handlers will tidy up */
-    if (io.flag == Comm::ERR_CLOSING) {
+    if (io.flag == Comm::ERR_CLOSING || !Comm::IsConnOpen(clientConnection)) {
         debugs(33,5, io.conn &lt;&lt; &quot; closing Bailout.&quot;);
         return;
     }
 
-    assert(Comm::IsConnOpen(clientConnection));
-    assert(io.conn-&gt;fd == clientConnection-&gt;fd);
+    Must(io.conn-&gt;fd == clientConnection-&gt;fd);
+
+    if (io.flag &amp;&amp; pipeline.front())
+        pipeline.front()-&gt;initiateClose(&quot;write failure&quot;);
 
+    afterClientWrite(io.size); // update state
     writeSomeData(); // maybe schedules another write
 }
 
----++++src/servers/Server.h
@@ -15,7 +15,7 @@
 #include &quot;anyp/ProtocolVersion.h&quot;
 #include &quot;base/AsyncJob.h&quot;
 #include &quot;BodyPipe.h&quot;
-#include "comm/forward.h"
+#include "comm/Write.h"
 #include &quot;CommCalls.h&quot;
 #include &quot;Pipeline.h&quot;
 #include &quot;SBuf.h&quot;
@@ -38,9 +38,6 @@ class Server : virtual public AsyncJob, public BodyProducer
     /// ??
     virtual bool connFinishedWithConn(int size) = 0;
 
-    /// processing to be done after a Comm::Read()
-    virtual void afterClientRead() = 0;
-
     /// maybe grow the inBuf and schedule Comm::Read()
     void readSomeData();
 
@@ -52,6 +49,9 @@ class Server : virtual public AsyncJob, public BodyProducer
      */
     virtual bool handleReadData() = 0;
 
+    /// processing to be done after a Comm::Read()
+    virtual void afterClientRead() = 0;
+
     /// whether Comm::Read() is scheduled
     bool reading() const {return reader != NULL;}
 
@@ -61,10 +61,26 @@ class Server : virtual public AsyncJob, public BodyProducer
     /// Update flags and timeout after the first byte received
     virtual void receivedFirstByte() = 0;
 
-    /// maybe schedule another Comm::Write() and perform any
-    /// processing to be done after previous Comm::Write() completes
+    /// maybe find some data to send and schedule a Comm::Write()
     virtual void writeSomeData() {}
 
+    /// schedule some data for a Comm::Write()
+    void write(MemBuf *mb) {
+        typedef CommCbMemFunT&lt;Server, CommIoCbParams&gt; Dialer;
+        writer = JobCallback(33, 5, Dialer, this, Server::clientWriteDone);
+        Comm::Write(clientConnection, mb, writer);
+    }
+
+    /// schedule some data for a Comm::Write()
+    void write(char *buf, int len) {
+        typedef CommCbMemFunT&lt;Server, CommIoCbParams&gt; Dialer;
+        writer = JobCallback(33, 5, Dialer, this, Server::clientWriteDone);
+        Comm::Write(clientConnection, buf, len, writer, nullptr);
+    }
+
+    /// processing to sync state after a Comm::Write()
+    virtual void afterClientWrite(size_t) {}
+
     /// whether Comm::Write() is scheduled
     bool writing() const {return writer != NULL;}
 
----++++src/tests/stub_client_side.cc
@@ -15,7 +15,7 @@
 //ClientSocketContext::ClientSocketContext(const ConnectionPointer&amp;, ClientHttpRequest*) STUB
 //ClientSocketContext::~ClientSocketContext() STUB
 bool ClientSocketContext::startOfOutput() const STUB_RETVAL(false)
-void ClientSocketContext::writeComplete(const Comm::ConnectionPointer &amp;conn, char *bufnotused, size_t size, Comm::Flag errflag) STUB
+void ClientSocketContext::writeComplete(size_t size) STUB
 void ClientSocketContext::pullData() STUB
 int64_t ClientSocketContext::getNextRangeOffset() const STUB_RETVAL(0)
 bool ClientSocketContext::canPackMoreRanges() const STUB_RETVAL(false)
----++++GitHub