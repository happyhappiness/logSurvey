@@ -105,7 +105,7 @@ gethost_name(void)
         return NULL;
     }
     rc = getaddrinfo(hostname, NULL, NULL, &hres);
-    if (rc != 0) {
+    if (rc != 0 || hres == NULL ) {
         debug((char *) "%s| %s: ERROR: resolving hostname with getaddrinfo: %s failed\n",
               LogTime(), PROGRAM, gai_strerror(rc));
         fprintf(stderr,
@@ -339,10 +339,8 @@ main(int argc, char *const argv[])
     gss_buffer_desc type_id = GSS_C_EMPTY_BUFFER;
 #endif
 #endif
-#if HAVE_PAC_SUPPORT || HAVE_KRB5_MEMORY_KEYTAB
     krb5_context context = NULL;
     krb5_error_code ret;
-#endif
     long length = 0;
     static int err = 0;
     int opt, log = 0, norealm = 0;
@@ -352,6 +350,7 @@ main(int argc, char *const argv[])
     char *service_principal = NULL;
     char *keytab_name = NULL;
     char *keytab_name_env = NULL;
+    char default_keytab[MAXPATHLEN];
 #if HAVE_KRB5_MEMORY_KEYTAB
     char *memory_keytab_name = NULL;
 #endif
@@ -536,9 +535,14 @@ main(int argc, char *const argv[])
         putenv(keytab_name_env);
     } else {
         keytab_name_env = getenv("KRB5_KTNAME");
-        if (!keytab_name_env)
-            keytab_name = xstrdup("/etc/krb5.keytab");
-        else
+        if (!keytab_name_env) {
+            ret = krb5_init_context(&context);
+            if (!check_k5_err(context, "krb5_init_context", ret)) {
+                krb5_kt_default_name(context, default_keytab, MAXPATHLEN);
+            }
+            keytab_name = default_keytab;
+            krb5_free_context(context);
+        } else
             keytab_name = xstrdup(keytab_name_env);
     }
     debug((char *) "%s| %s: INFO: Setting keytab to %s\n", LogTime(), PROGRAM, keytab_name);
@@ -141,9 +141,9 @@ pstrcat( char *src, const char *dst)
 int
 checkustr(RPC_UNICODE_STRING *string)
 {
-    uint32_t size,off,len;
 
     if (string->pointer != 0) {
+        uint32_t size,off,len;
         align(4);
         size = (uint32_t)((p[bpos]<<0) | (p[bpos+1]<<8) | (p[bpos+2]<<16) | (p[bpos+3]<<24));
         bpos = bpos+4;
@@ -168,7 +168,6 @@ getgids(char **Rids, uint32_t GroupIds, uint32_t  GroupCount)
 {
     if (GroupIds!= 0) {
         uint32_t ngroup;
-        uint32_t sauth;
         int l;
 
         align(4);
@@ -182,6 +181,7 @@ getgids(char **Rids, uint32_t GroupIds, uint32_t  GroupCount)
 
         Rids=(char **)xcalloc(GroupCount*sizeof(char*),1);
         for ( l=0; l<(int)GroupCount; l++) {
+            uint32_t sauth;
             Rids[l]=(char *)xcalloc(4*sizeof(char),1);
             memcpy((void *)Rids[l],(void *)&p[bpos],4);
             sauth = get4byt();
@@ -196,11 +196,16 @@ getgids(char **Rids, uint32_t GroupIds, uint32_t  GroupCount)
 char *
 getdomaingids(char *ad_groups, uint32_t DomainLogonId, char **Rids, uint32_t GroupCount)
 {
+    if (!ad_groups) {
+        debug((char *) "%s| %s: ERR: No space to store groups\n",
+              LogTime(), PROGRAM);
+        return NULL;
+    }
+
     if (DomainLogonId!= 0) {
         uint32_t nauth;
         uint8_t rev;
         uint64_t idauth;
-        uint32_t sauth;
         char dli[256];
         char *ag;
         size_t length;
@@ -251,6 +256,7 @@ getdomaingids(char *ad_groups, uint32_t DomainLogonId, char **Rids, uint32_t Gro
 
         snprintf(dli,sizeof(dli),"S-%d-%lu",rev,(long unsigned int)idauth);
         for ( l=0; l<(int)nauth; l++ ) {
+            uint32_t sauth;
             sauth = get4byt();
             snprintf((char *)&dli[strlen(dli)],sizeof(dli)-strlen(dli),"-%u",sauth);
         }
@@ -286,23 +292,23 @@ getextrasids(char *ad_groups, uint32_t ExtraSids, uint32_t SidCount)
 
         for ( l=0; l<(int)SidCount; l++ ) {
             char es[256];
-            uint32_t nauth;
-            uint8_t rev;
-            uint64_t idauth;
-            uint32_t sauth;
-            int k;
 
             if (pa[l] != 0) {
+                uint32_t nauth;
+                uint8_t rev;
+                uint64_t idauth;
+
                 nauth = get4byt();
 
                 length = 1+1+6+nauth*4;
                 ag = (char *)xcalloc((length)*sizeof(char),1);
                 memcpy((void *)ag,(const void*)&p[bpos],length);
                 if (!ad_groups) {
-                    if (!pstrcpy(ad_groups,"group=")) {
-                        debug((char *) "%s| %s: WARN: Too many groups ! size > %d : %s\n",
-                              LogTime(), PROGRAM, MAX_PAC_GROUP_SIZE, ad_groups);
-                    }
+                    debug((char *) "%s| %s: ERR: No space to store groups\n",
+                          LogTime(), PROGRAM);
+                    xfree(pa);
+                    xfree(ag);
+                    return NULL;
                 } else {
                     if (!pstrcat(ad_groups," group=")) {
                         debug((char *) "%s| %s: WARN: Too many groups ! size > %d : %s\n",
@@ -328,7 +334,8 @@ getextrasids(char *ad_groups, uint32_t ExtraSids, uint32_t SidCount)
                 idauth = get6byt_be();
 
                 snprintf(es,sizeof(es),"S-%d-%lu",rev,(long unsigned int)idauth);
-                for ( k=0; k<(int)nauth; k++ ) {
+                for (int k=0; k<(int)nauth; k++ ) {
+                    uint32_t sauth;
                     sauth = get4byt();
                     snprintf((char *)&es[strlen(es)],sizeof(es)-strlen(es),"-%u",sauth);
                 }
@@ -365,6 +372,12 @@ get_ad_groups(char *ad_groups, krb5_context context, krb5_pac pac)
     char **Rids=NULL;
     int l=0;
 
+    if (!ad_groups) {
+        debug((char *) "%s| %s: ERR: No space to store groups\n",
+              LogTime(), PROGRAM);
+        return NULL;
+    }
+
     ad_data = (krb5_data *)xcalloc(1,sizeof(krb5_data));
 
 #define KERB_LOGON_INFO 1
@@ -60,6 +60,16 @@ CaseInsensitveSBufCompare(const SBuf &lhs, const SBuf &rhs)
     return (lhs.caseCmp(rhs) < 0);
 }
 
+static bool
+CaseSensitveSBufCompare(const SBuf &lhs, const SBuf &rhs)
+{
+    return (lhs < rhs);
+}
+
+ACLUserData::ACLUserData() : userDataNames(CaseSensitveSBufCompare)
+{
+}
+
 void
 ACLUserData::parse()
 {
@@ -21,6 +21,7 @@ class ACLUserData : public ACLData<char const *>
 
 public:
     virtual ~ACLUserData() {}
+    ACLUserData();
     bool match(char const *user);
     virtual SBufList dump() const;
     void parse();
@@ -309,7 +309,10 @@ SBuf
 Auth::User::BuildUserKey(const char *username, const char *realm)
 {
     SBuf key;
-    key.Printf("%s:%s", username, realm);
+    if (realm)
+        key.Printf("%s:%s", username, realm);
+    else
+        key.append(username, strlen(username));
     return key;
 }
 
@@ -365,10 +368,11 @@ Auth::User::username(char const *aString)
     if (aString) {
         assert(!username_);
         username_ = xstrdup(aString);
-        if (!requestRealm_.isEmpty())
-            userKey_ = BuildUserKey(username_, requestRealm_.c_str());
+        // NP: param #2 is working around a c_str() data-copy performance regression
+        userKey_ = BuildUserKey(username_, (!requestRealm_.isEmpty() ? requestRealm_.c_str() : NULL));
     } else {
         safe_free(username_);
+        userKey_.clear();
     }
 }
 
@@ -63,9 +63,10 @@ class User : public RefCountable
     void absorb(Auth::User::Pointer from);
     virtual ~User();
     char const *username() const { return username_; }
-    void username(char const *);
+    void username(char const *); ///< set stored username and userKey
 
-    const char *userKey() {return !userKey_.isEmpty() ? userKey_.c_str() : username_;}
+    // NP: key is set at the same time as username_. Until then both are empty/NULL.
+    const char *userKey() {return !userKey_.isEmpty() ? userKey_.c_str() : NULL;}
 
     /**
      * How long these credentials are still valid for.
@@ -984,43 +984,37 @@ parse_obsolete(const char *name)
 static void
 parseTimeLine(time_msec_t * tptr, const char *units,  bool allowMsec,  bool expectMoreArguments = false)
 {
-    char *token;
-    double d;
-    time_msec_t m;
     time_msec_t u;
-
     if ((u = parseTimeUnits(units, allowMsec)) == 0)
         self_destruct();
 
+    char *token;
     if ((token = ConfigParser::NextToken()) == NULL)
         self_destruct();
 
-    d = xatof(token);
+    double d = xatof(token);
 
-    m = u;          /* default to 'units' if none specified */
+    time_msec_t m = u; /* default to 'units' if none specified */
 
-    bool hasUnits = false;
-    if (0 == d)
-        (void) 0;
-    else if ((token = ConfigParser::PeekAtToken()) == NULL)
-        (void) 0;
-    else if ((m = parseTimeUnits(token, allowMsec)) == 0) {
-        if (!expectMoreArguments)
+    if (d) {
+        if ((token = ConfigParser::PeekAtToken()) && (m = parseTimeUnits(token, allowMsec))) {
+            (void)ConfigParser::NextToken();
+
+        } else if (!expectMoreArguments) {
             self_destruct();
-    } else { //pop the token
-        (void)ConfigParser::NextToken();
-        hasUnits = true;
-    }
-    if (!hasUnits)
-        debugs(3, DBG_CRITICAL, "WARNING: No units on '" <<
-               config_input_line << "', assuming " <<
-               d << " " << units  );
+
+        } else {
+            token = NULL; // show default units if dying below
+            debugs(3, DBG_CRITICAL, "WARNING: No units on '" << config_input_line << "', assuming " << d << " " << units);
+        }
+    } else
+        token = NULL; // show default units if dying below.
 
     *tptr = static_cast<time_msec_t>(m * d);
 
     if (static_cast<double>(*tptr) * 2 != m * d * 2) {
-        debugs(3, DBG_CRITICAL, "ERROR: Invalid value '" <<
-               d << " " << token << ": integer overflow (time_msec_t).");
+        debugs(3, DBG_CRITICAL, "FATAL: Invalid value '" <<
+               d << " " << (token ? token : units) << ": integer overflow (time_msec_t).");
         self_destruct();
     }
 }
@@ -276,38 +276,14 @@ cbdataInternalAlloc(cbdata_type type, const char *file, int line)
     return p;
 }
 
-void *
-cbdataInternalFree(void *p, const char *file, int line)
+void
+cbdataRealFree(cbdata *c, const char *file, const int line)
 {
-    cbdata *c;
-#if HASHED_CBDATA
-    c = (cbdata *) hash_lookup(cbdata_htable, p);
-#else
-    c = (cbdata *) (((char *) p) - cbdata::Offset);
-#endif
-#if USE_CBDATA_DEBUG
-    debugs(45, 3, p << " " << file << ":" << line);
-#else
-    debugs(45, 9, p);
-#endif
-
-    c->check(__LINE__);
-    assert(c->valid);
-    c->valid = 0;
-#if USE_CBDATA_DEBUG
-
-    c->addHistory("Free", file, line);
-#endif
-
-    if (c->locks) {
-        debugs(45, 9, p << " has " << c->locks << " locks, not freeing");
-        return NULL;
-    }
+    void *p = c;
 
     --cbdataCount;
     debugs(45, 9, "Freeing " << p);
 #if USE_CBDATA_DEBUG
-
     dlinkDelete(&c->link, &cbdataEntries);
 #endif
 
@@ -325,17 +301,47 @@ cbdataInternalFree(void *p, const char *file, int line)
 #if HASHED_CBDATA
     hash_remove_link(cbdata_htable, &c->hash);
 #if USE_CBDATA_DEBUG
-    debugs(45, 3, "Call delete " << (void*)c << " " << file << ":" << line);
+    debugs(45, 3, "Call delete " << p << " " << file << ":" << line);
 #endif
     delete c;
-    cbdata_index[theType].pool->freeOne((void *)p);
 #else
 #if USE_CBDATA_DEBUG
-    debugs(45, 3, "Call cbdata::~cbdata() " << (void*)c << " " << file << ":" << line);
+    debugs(45, 3, "Call cbdata::~cbdata() " << p << " " << file << ":" << line);
 #endif
     c->cbdata::~cbdata();
-    cbdata_index[theType].pool->freeOne(c);
 #endif
+    cbdata_index[theType].pool->freeOne(p);
+}
+
+void *
+cbdataInternalFree(void *p, const char *file, int line)
+{
+    cbdata *c;
+#if HASHED_CBDATA
+    c = (cbdata *) hash_lookup(cbdata_htable, p);
+#else
+    c = (cbdata *) (((char *) p) - cbdata::Offset);
+#endif
+#if USE_CBDATA_DEBUG
+    debugs(45, 3, p << " " << file << ":" << line);
+#else
+    debugs(45, 9, p);
+#endif
+
+    c->check(__LINE__);
+    assert(c->valid);
+    c->valid = 0;
+#if USE_CBDATA_DEBUG
+
+    c->addHistory("Free", file, line);
+#endif
+
+    if (c->locks) {
+        debugs(45, 9, p << " has " << c->locks << " locks, not freeing");
+        return NULL;
+    }
+
+    cbdataRealFree(c, file, line);
     return NULL;
 }
 
@@ -409,45 +415,15 @@ cbdataInternalUnlock(const void *p)
 
     if (c->valid) {
 #if USE_CBDATA_DEBUG
-        debugs(45, DBG_IMPORTANT, "CBDATA memory leak. cbdata=" << p << " " << file << ":" << line);
+        debugs(45, 3, "CBDATA valid with no references ... cbdata=" << p << " " << file << ":" << line);
 #endif
         return;
     }
 
-    --cbdataCount;
-
-    debugs(45, 9, "Freeing " << p);
-
 #if USE_CBDATA_DEBUG
-
-    dlinkDelete(&c->link, &cbdataEntries);
-
-#endif
-
-    /* This is ugly. But: operator delete doesn't get
-     * the type parameter, so we can't use that
-     * to free the memory.
-     * So, we free it ourselves.
-     * Note that this means a non-placement
-     * new would be a seriously bad idea.
-     * Lastly, if we where a templated class,
-     * we could use the normal delete operator
-     * and it would Just Work. RBC 20030902
-     */
-    cbdata_type theType = c->type;
-#if HASHED_CBDATA
-    hash_remove_link(cbdata_htable, &c->hash);
-#if USE_CBDATA_DEBUG
-    debugs(45, 3, "Call delete " << (void*)c << " " << file << ":" << line);
-#endif
-    delete c;
-    cbdata_index[theType].pool->freeOne((void *)p);
+    cbdataRealFree(c, file, line);
 #else
-#if USE_CBDATA_DEBUG
-    debugs(45, 3, "Call cbdata::~cbdata() " << (void*)c << " " << file << ":" << line);
-#endif
-    c->cbdata::~cbdata();
-    cbdata_index[theType].pool->freeOne(c);
+    cbdataRealFree(c, NULL, 0);
 #endif
 }
 
@@ -623,15 +623,16 @@ ClientHttpRequest::logRequest()
 
 #endif
 
-    /*Add notes*/
-    // The al->notes and request->notes must point to the same object.
-    (void)SyncNotes(*al, *request);
-    typedef Notes::iterator ACAMLI;
-    for (ACAMLI i = Config.notes.begin(); i != Config.notes.end(); ++i) {
-        if (const char *value = (*i)->match(request, al->reply, NULL)) {
-            NotePairs &notes = SyncNotes(*al, *request);
-            notes.add((*i)->key.termedBuf(), value);
-            debugs(33, 3, HERE << (*i)->key.termedBuf() << " " << value);
+    /* Add notes (if we have a request to annotate) */
+    if (request) {
+        // The al->notes and request->notes must point to the same object.
+        (void)SyncNotes(*al, *request);
+        for (auto i = Config.notes.begin(); i != Config.notes.end(); ++i) {
+            if (const char *value = (*i)->match(request, al->reply, NULL)) {
+                NotePairs &notes = SyncNotes(*al, *request);
+                notes.add((*i)->key.termedBuf(), value);
+                debugs(33, 3, (*i)->key.termedBuf() << " " << value);
+            }
         }
     }
 