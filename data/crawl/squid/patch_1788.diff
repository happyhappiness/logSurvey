@@ -1,6 +1,6 @@
 
 /*
- * $Id: access_log.cc,v 1.7 1997/11/05 00:39:49 wessels Exp $
+ * $Id: access_log.cc,v 1.8 1997/11/05 05:29:16 wessels Exp $
  *
  * DEBUG: section 46    Access Log
  * AUTHOR: Duane Wessels
@@ -102,7 +102,7 @@ log_quote(const char *header)
      * modulo the inclusion of space (x40) to make the raw logs a bit
      * more readable.
      */
-    while ((c = *(const unsigned char *) header++)) {
+    while ((c = *(const unsigned char *) header++) != '\0') {
 	if (c <= 0x1F
 	    || c >= 0x7F
 	    || c == '"'
@@ -126,7 +126,7 @@ log_quote(const char *header)
 	    *buf_cursor++ = c2x[i];
 	    *buf_cursor++ = c2x[i + 1];
 	} else {
-	    *buf_cursor++ = c;
+	    *buf_cursor++ = (char) c;
 	}
     }
     *buf_cursor = '\0';
@@ -297,5 +297,5 @@ hierarchyNote(HierarchyLogEntry * hl,
 void
 accessLogInit(void)
 {
-	assert(sizeof(log_tags) == (LOG_TYPE_MAX + 1) * sizeof(char *));
+    assert(sizeof(log_tags) == (LOG_TYPE_MAX + 1) * sizeof(char *));
 }
@@ -1,5 +1,6 @@
+
 /*
- * $Id: acl.cc,v 1.112 1997/11/03 20:05:36 wessels Exp $
+ * $Id: acl.cc,v 1.113 1997/11/05 05:29:17 wessels Exp $
  *
  * DEBUG: section 28    Access Control
  * AUTHOR: Duane Wessels
@@ -1278,7 +1279,7 @@ aclCheck(aclCheck_t * checklist)
     const struct _acl_access *A;
     int match;
     ipcache_addrs *ia;
-    while ((A = checklist->access_list)) {
+    while ((A = checklist->access_list) != NULL) {
 	debug(28, 3) ("aclCheck: checking '%s'\n", A->cfgline);
 	allow = A->allow;
 	match = aclMatchAclList(A->acl_list, checklist);
@@ -1461,10 +1462,9 @@ aclDestroyRegexList(struct _relist *data)
 static void
 aclDestroyProxyAuth(struct _acl_proxy_auth *p)
 {
-    int i;
     hash_link *hashr = NULL;
     /* destroy hash list contents */
-    for (i = 0, hashr = hash_first(p->hash); hashr; hashr = hash_next(p->hash))
+    for (hashr = hash_first(p->hash); hashr; hashr = hash_next(p->hash))
 	hash_delete(p->hash, hashr->key);
     /* destroy and free the hash table itself */
     hashFreeMemory(p->hash);
@@ -1633,7 +1633,6 @@ aclReadProxyAuth(struct _acl_proxy_auth *p)
     static char *passwords = NULL;
     char *user = NULL;
     char *passwd = NULL;
-    int i;
     hash_link *hashr = NULL;
     FILE *f = NULL;
     if ((squid_curtime - p->last_time) >= p->check_interval) {
@@ -1643,7 +1642,7 @@ aclReadProxyAuth(struct _acl_proxy_auth *p)
 		p->change_time = buf.st_mtime;
 		if (p->hash != 0) {
 		    debug(28, 5) ("aclReadProxyAuth: invalidating old entries\n");
-		    for (i = 0, hashr = hash_first(p->hash); hashr; hashr = hash_next(p->hash)) {
+		    for (hashr = hash_first(p->hash); hashr; hashr = hash_next(p->hash)) {
 			debug(28, 6) ("aclReadProxyAuth: deleting %s\n", hashr->key);
 			hash_delete(p->hash, hashr->key);
 		    }
@@ -1,5 +1,5 @@
 /*
- * $Id: cache_cf.cc,v 1.229 1997/11/04 23:29:35 wessels Exp $
+ * $Id: cache_cf.cc,v 1.230 1997/11/05 05:29:18 wessels Exp $
  *
  * DEBUG: section 3     Configuration File Parsing
  * AUTHOR: Harvest Derived
@@ -79,7 +79,7 @@ void
 wordlistDestroy(wordlist ** list)
 {
     wordlist *w = NULL;
-    while ((w = *list)) {
+    while ((w = *list) != NULL) {
 	*list = w->next;
 	safe_free(w->key);
 	safe_free(w);
@@ -586,7 +586,7 @@ static void
 free_peer(peer ** P)
 {
     peer *p;
-    while ((p = *P)) {
+    while ((p = *P) != NULL) {
 	*P = p->next;
 	peerDestroy(p);
     }
@@ -613,7 +613,7 @@ static void
 free_cachemgrpasswd(cachemgr_passwd ** head)
 {
     cachemgr_passwd *p;
-    while ((p = *head)) {
+    while ((p = *head) != NULL) {
 	*head = p->next;
 	xfree(p->passwd);
 	xfree(p);
@@ -814,7 +814,7 @@ static void
 free_ushortlist(ushortlist ** P)
 {
     ushortlist *u;
-    while ((u = *P)) {
+    while ((u = *P) != NULL) {
 	*P = u->next;
 	xfree(u);
     }
@@ -943,7 +943,7 @@ static void
 free_refreshpattern(refresh_t ** head)
 {
     refresh_t *t;
-    while ((t = *head)) {
+    while ((t = *head) != NULL) {
 	*head = t->next;
 	safe_free(t->pattern);
 	regfree(&t->compiled_pattern);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: cachemgr.cc,v 1.63 1997/10/25 17:22:34 wessels Exp $
+ * $Id: cachemgr.cc,v 1.64 1997/11/05 05:29:19 wessels Exp $
  *
  * DEBUG: section 0     CGI Cache Manager
  * AUTHOR: Harvest Derived
@@ -646,8 +646,8 @@ main(int argc, char *argv[])
     strcpy(hostname, CACHEMGR_HOSTNAME);
 
     /* a POST request */
-    if ((s = getenv("REQUEST_METHOD")) && !strcasecmp(s, "POST") &&
-	(s = getenv("CONTENT_LENGTH")) && (len = atoi(s)) > 0) {
+    if ((s = getenv("REQUEST_METHOD")) != NULL && !strcasecmp(s, "POST") &&
+	(s = getenv("CONTENT_LENGTH")) != NULL && (len = atoi(s)) > 0) {
 	buffer = xmalloc(len + 1);
 	fread(buffer, len, 1, stdin);
 	buffer[len] = '\0';
@@ -1,5 +1,5 @@
 /*
- * $Id: cf_gen.cc,v 1.14 1997/11/04 23:21:12 wessels Exp $
+ * $Id: cf_gen.cc,v 1.15 1997/11/05 05:29:19 wessels Exp $
  *
  * DEBUG: section 1     Startup and Main Loop
  * AUTHOR: Max Okumoto
@@ -78,7 +78,6 @@ typedef struct Entry {
 
 
 static const char WS[] = " \t";
-static const char NS[] = "";
 static int gen_default(Entry *, FILE *);
 static void gen_parse(Entry *, FILE *);
 static void gen_dump(Entry *, FILE *);
@@ -120,6 +119,7 @@ main(int argc, char *argv[])
 	case sSTART:
 	    if ((strlen(buff) == 0) || (!strncmp(buff, "#", 1))) {
 		/* ignore empty and comment lines */
+		(void) 0;
 	    } else if (!strncmp(buff, "NAME:", 5)) {
 		char *name;
 		if ((name = strtok(buff + 5, WS)) == NULL) {
@@ -145,6 +145,7 @@ main(int argc, char *argv[])
 	case s1:
 	    if ((strlen(buff) == 0) || (!strncmp(buff, "#", 1))) {
 		/* ignore empty and comment lines */
+		(void) 0;
 	    } else if (!strncmp(buff, "COMMENT:", 8)) {
 		ptr = buff + 8;
 		while (isspace(*ptr))
@@ -366,6 +367,7 @@ gen_parse(Entry * head, FILE * fp)
 	"\tdebug(0,10)(\"parse_line: %%s\\n\", buff);\n"
 	"\tif ((token = strtok(buff, w_space)) == NULL) {\n"
 	"\t\t/* ignore empty lines */\n"
+	"\t\t(void) 0;\n"
 	);
 
     for (entry = head; entry != NULL; entry = entry->next) {
@@ -1,6 +1,6 @@
 
 /*
- * $Id: client_side.cc,v 1.140 1997/11/05 00:39:50 wessels Exp $
+ * $Id: client_side.cc,v 1.141 1997/11/05 05:29:20 wessels Exp $
  *
  * DEBUG: section 33    Client-side Routines
  * AUTHOR: Duane Wessels
@@ -433,7 +433,7 @@ httpRequestFree(void *data)
 	entry = http->entry;	/* reset, IMS might have changed it */
 	if (entry && entry->ping_status == PING_WAITING)
 	    storeReleaseRequest(entry);
-	protoUnregister(entry, request, conn->peer.sin_addr);
+	protoUnregister(entry, request);
     }
     assert(http->log_type < LOG_TYPE_MAX);
     if (entry)
@@ -504,7 +504,7 @@ connStateFree(int fd, void *data)
     clientHttpRequest *http;
     debug(12, 3) ("connStateFree: FD %d\n", fd);
     assert(connState != NULL);
-    while ((http = connState->chr)) {
+    while ((http = connState->chr) != NULL) {
 	assert(http->conn == connState);
 	assert(connState->chr != connState->chr->next);
 	httpRequestFree(http);
@@ -865,7 +865,7 @@ clientSendMoreData(void *data, char *buf, ssize_t size)
 }
 
 void
-clientWriteComplete(int fd, char *buf, int size, int errflag, void *data)
+clientWriteComplete(int fd, char *bufnotused, int size, int errflag, void *data)
 {
     clientHttpRequest *http = data;
     ConnStateData *conn;
@@ -897,7 +897,7 @@ clientWriteComplete(int fd, char *buf, int size, int errflag, void *data)
 	    debug(12, 5) ("clientWriteComplete: FD %d Keeping Alive\n", fd);
 	    conn = http->conn;
 	    httpRequestFree(http);
-	    if ((http = conn->chr)) {
+	    if ((http = conn->chr) != NULL) {
 		debug(12, 1) ("clientWriteComplete: FD %d Sending next request\n", fd);
 		storeClientCopy(entry,
 		    http->out.offset,
@@ -1007,7 +1007,7 @@ icpGetHeadersForIMS(void *data, char *buf, ssize_t size)
 }
 
 static void
-icpHandleIMSComplete(int fd, char *buf_unused, int size, int errflag, void *data)
+icpHandleIMSComplete(int fd, char *bufnotused, int size, int errflag, void *data)
 {
     clientHttpRequest *http = data;
     StoreEntry *entry = http->entry;
@@ -1396,7 +1396,7 @@ parseHttpRequest(ConnStateData * conn, method_t * method_p, int *status,
 }
 
 static int
-clientReadDefer(int fd, void *data)
+clientReadDefer(int fdnotused, void *data)
 {
     ConnStateData *conn = data;
     return conn->defer.until > squid_curtime;
@@ -1581,7 +1581,7 @@ requestTimeout(int fd, void *data)
 }
 
 int
-httpAcceptDefer(int fd, void *notused)
+httpAcceptDefer(int fdnotused, void *notused)
 {
     return !fdstat_are_n_free_fd(RESERVED_FD);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: comm.cc,v 1.200 1997/10/28 06:46:51 wessels Exp $
+ * $Id: comm.cc,v 1.201 1997/11/05 05:29:21 wessels Exp $
  *
  * DEBUG: section 5     Socket Functions
  * AUTHOR: Harvest Derived
@@ -162,7 +162,7 @@ static int ignoreErrno(int errno);
 static void commSetConnectTimeout(int fd, time_t timeout);
 static int commResetFD(ConnectStateData * cs);
 static int commRetryConnect(ConnectStateData * cs);
-static time_t commBackoffTimeout(unsigned char numaddrs);
+static time_t commBackoffTimeout(int);
 
 static struct timeval zero_tv;
 
@@ -344,7 +344,7 @@ commConnectDnsHandle(const ipcache_addrs * ia, void *data)
     ipcacheCycleAddr(cs->host);
     cs->addrcount = ia->count;
     cs->connstart = squid_curtime;
-    commSetConnectTimeout(cs->fd, commBackoffTimeout(ia->count));
+    commSetConnectTimeout(cs->fd, commBackoffTimeout((int) ia->count));
     commConnectHandle(cs->fd, cs);
 }
 
@@ -362,7 +362,7 @@ commConnectCallback(ConnectStateData * cs, int status)
 }
 
 static void
-commConnectFree(int fdunused, void *data)
+commConnectFree(int fdnotused, void *data)
 {
     ConnectStateData *cs = data;
     if (cs->locks)
@@ -388,7 +388,7 @@ commResetFD(ConnectStateData * cs)
 	return 0;
     }
     close(fd2);
-    commSetConnectTimeout(cs->fd, commBackoffTimeout(cs->addrcount));
+    commSetConnectTimeout(cs->fd, commBackoffTimeout((int) cs->addrcount));
     commSetNonBlocking(cs->fd);
     return 1;
 }
@@ -402,7 +402,7 @@ commRetryConnect(ConnectStateData * cs)
 	    return 0;
 	if (squid_curtime - cs->connstart > Config.Timeout.connect)
 	    return 0;
-	commSetConnectTimeout(cs->fd, commBackoffTimeout((unsigned char) 100));
+	commSetConnectTimeout(cs->fd, commBackoffTimeout(100));
     } else {
 	if (cs->tries > cs->addrcount)
 	    return 0;
@@ -412,7 +412,7 @@ commRetryConnect(ConnectStateData * cs)
 
 /* Back off the socket timeout if there are several addresses available */
 static time_t
-commBackoffTimeout(unsigned char numaddrs)
+commBackoffTimeout(int numaddrs)
 {
     time_t timeout;
     timeout = (time_t) Config.Timeout.connect;
@@ -560,6 +560,7 @@ comm_accept(int fd, struct sockaddr_in *peer, struct sockaddr_in *me)
 		fd, xstrerror());
 	    return COMM_ERROR;
 	}
+	/* NOTREACHED */
     }
 
     if (peer)
@@ -1,5 +1,5 @@
 /*
- * $Id: disk.cc,v 1.90 1997/10/30 18:42:55 wessels Exp $
+ * $Id: disk.cc,v 1.91 1997/11/05 05:29:22 wessels Exp $
  *
  * DEBUG: section 6     Disk I/O Routines
  * AUTHOR: Harvest Derived
@@ -167,7 +167,6 @@ static void
 file_open_complete(void *data, int fd, int errcode)
 {
     open_ctrl_t *ctrlp = (open_ctrl_t *) data;
-    fde *F;
     if (fd < 0) {
 	errno = errcode;
 	debug(50, 0) ("file_open: error opening file %s: %s\n", ctrlp->path,
@@ -181,7 +180,6 @@ file_open_complete(void *data, int fd, int errcode)
     debug(6, 5) ("file_open: FD %d\n", fd);
     commSetCloseOnExec(fd);
     fd_open(fd, FD_FILE, ctrlp->path);
-    F = &fd_table[fd];
     if (ctrlp->callback)
 	(ctrlp->callback) (ctrlp->callback_data, fd);
     xfree(ctrlp->path);
@@ -215,7 +213,7 @@ file_close(int fd)
 
 /* write handler */
 static void
-diskHandleWrite(int fd, void *unused)
+diskHandleWrite(int fd, void *notused)
 {
     int len = 0;
     disk_ctrl_t *ctrlp;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: errorpage.cc,v 1.99 1997/11/04 19:54:46 wessels Exp $
+ * $Id: errorpage.cc,v 1.100 1997/11/05 05:29:22 wessels Exp $
  *
  * DEBUG: section 4     Error Generation
  * AUTHOR: Duane Wessels
@@ -181,7 +181,7 @@ errorSend(int fd, ErrorState * err)
  *            closeing the FD, otherwise we do it ourseves.
  */
 static void
-errorSendComplete(int fd, char *buf, int size, int errflag, void *data)
+errorSendComplete(int fd, char *bufnotused, int size, int errflag, void *data)
 {
     ErrorState *err = data;
     debug(4, 3) ("errorSendComplete: FD %d, size=%d\n", fd, size);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: event.cc,v 1.8 1997/06/04 06:15:51 wessels Exp $
+ * $Id: event.cc,v 1.9 1997/11/05 05:29:23 wessels Exp $
  *
  * DEBUG: section 41    Event Processing
  * AUTHOR: Henrik Nordstrom
@@ -66,7 +66,7 @@ eventDelete(EVH * func, void *arg)
 {
     struct ev_entry **E;
     struct ev_entry *event;
-    for (E = &tasks; (event = *E); E = &(*E)->next) {
+    for (E = &tasks; (event = *E) != NULL; E = &(*E)->next) {
 	if (event->func != func)
 	    continue;
 	if (event->arg != arg)
@@ -1,6 +1,6 @@
 
 /*
- * $Id: fqdncache.cc,v 1.64 1997/10/30 02:40:59 wessels Exp $
+ * $Id: fqdncache.cc,v 1.65 1997/11/05 05:29:23 wessels Exp $
  *
  * DEBUG: section 35    FQDN Cache
  * AUTHOR: Harvest Derived
@@ -135,7 +135,7 @@ static struct {
     int ghba_calls;		/* # calls to blocking gethostbyaddr() */
 } FqdncacheStats;
 
-static int fqdncache_compareLastRef(fqdncache_entry **, fqdncache_entry **);
+static QS fqdncache_compareLastRef;
 static void fqdncache_dnsHandleRead(int, void *);
 static fqdncache_entry *fqdncache_parsebuffer(const char *buf, dnsserver_t *);
 static int fqdncache_purgelru(void);
@@ -269,10 +269,11 @@ fqdncache_GetNext(void)
 }
 
 static int
-fqdncache_compareLastRef(fqdncache_entry ** e1, fqdncache_entry ** e2)
+fqdncache_compareLastRef(const void *A, const void *B)
 {
-    if (!e1 || !e2)
-	fatal_dump(NULL);
+    fqdncache_entry *const *e1 = A;
+    fqdncache_entry *const *e2 = B;
+    assert(e1 != NULL && e2 != NULL);
     if ((*e1)->lastref > (*e2)->lastref)
 	return (1);
     if ((*e1)->lastref < (*e2)->lastref)
@@ -344,7 +345,7 @@ fqdncache_purgelru(void)
     qsort((char *) LRU_list,
 	LRU_list_count,
 	sizeof(fqdncache_entry *),
-	(QS *) fqdncache_compareLastRef);
+	fqdncache_compareLastRef);
     for (k = 0; k < LRU_list_count; k++) {
 	if (meta_data.fqdncache_count < fqdncache_low)
 	    break;
@@ -843,7 +844,7 @@ fqdnStats(StoreEntry * sentry)
 }
 
 static void
-dummy_handler(const char *u2, void *u3)
+dummy_handler(const char *bufnotused, void *datanotused)
 {
     return;
 }
@@ -977,7 +978,7 @@ fqdncache_restart(void)
 	fatal_dump("fqdncache_restart: fqdn_table == 0\n");
     while (fqdncacheDequeue());
     next = (fqdncache_entry *) hash_first(fqdn_table);
-    while ((this = next)) {
+    while ((this = next) != NULL) {
 	next = (fqdncache_entry *) hash_next(fqdn_table);
 	if (this->status == FQDN_CACHED)
 	    continue;
@@ -1,5 +1,5 @@
 /*
- * $Id: ftp.cc,v 1.164 1997/11/03 22:43:10 wessels Exp $
+ * $Id: ftp.cc,v 1.165 1997/11/05 05:29:24 wessels Exp $
  *
  * DEBUG: section 9     File Transfer Protocol (FTP)
  * AUTHOR: Harvest Derived
@@ -178,7 +178,7 @@ FTPSM *FTP_SM_FUNCS[] =
 };
 
 static void
-ftpStateFree(int fd, void *data)
+ftpStateFree(int fdnotused, void *data)
 {
     FtpStateData *ftpState = data;
     if (ftpState == NULL)
@@ -622,7 +622,6 @@ ftpParseListing(FtpStateData * ftpState, int len)
     if (usable < len) {
 	/* must copy partial line to beginning of buf */
 	linelen = len - usable;
-	assert(linelen > 0);
 	if (linelen > 4096)
 	    linelen = 4096;
 	xstrncpy(line, end, linelen);
@@ -638,7 +637,6 @@ ftpReadData(int fd, void *data)
     FtpStateData *ftpState = data;
     int len;
     int clen;
-    int off;
     int bin;
     StoreEntry *entry = ftpState->entry;
     ErrorState *err;
@@ -650,7 +648,6 @@ ftpReadData(int fd, void *data)
     }
     /* check if we want to defer reading */
     clen = entry->mem_obj->inmem_hi;
-    off = storeLowestMemReaderOffset(entry);
     if (EBIT_TEST(ftpState->flags, FTP_ISDIR))
 	if (!EBIT_TEST(ftpState->flags, FTP_HTML_HEADER_SENT))
 	    ftpListingStart(ftpState);
@@ -1000,7 +997,7 @@ ftpWriteCommand(const char *buf, FtpStateData * ftpState)
 }
 
 static void
-ftpWriteCommandCallback(int fd, char *buf, int size, int errflag, void *data)
+ftpWriteCommandCallback(int fd, char *bufnotused, int size, int errflag, void *data)
 {
     FtpStateData *ftpState = data;
     StoreEntry *entry = ftpState->entry;
@@ -1427,7 +1424,7 @@ ftpSendPort(FtpStateData * ftpState)
 }
 
 static void
-ftpReadPort(FtpStateData * ftpState)
+ftpReadPort(FtpStateData * ftpStateNotUsed)
 {
     debug(9, 3) ("This is ftpReadPort\n");
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: globals.h,v 1.16 1997/11/05 00:39:51 wessels Exp $
+ * $Id: globals.h,v 1.17 1997/11/05 05:29:25 wessels Exp $
  */
 
 extern FILE *debug_log;		/* NULL */
@@ -94,9 +94,9 @@ extern int store_rebuilding;	/* 1 */
 extern int store_swap_size;	/* 0 */
 extern int client_info_sz;	/* 0 */
 extern unsigned long store_mem_size;	/* 0 */
-extern icpUdpData *UdpQueueHead; /* NULL */
-extern icpUdpData *UdpQueueTail; /* NULL */
-extern time_t hit_only_mode_until; /* 0 */
+extern icpUdpData *UdpQueueHead;	/* NULL */
+extern icpUdpData *UdpQueueTail;	/* NULL */
+extern time_t hit_only_mode_until;	/* 0 */
 
 #ifdef HAVE_SYSLOG
 extern int _db_level;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: gopher.cc,v 1.110 1997/11/03 22:43:11 wessels Exp $
+ * $Id: gopher.cc,v 1.111 1997/11/05 05:29:26 wessels Exp $
  *
  * DEBUG: section 10    Gopher
  * AUTHOR: Harvest Derived
@@ -185,7 +185,7 @@ static char def_gopher_bin[] = "www/unknown";
 static char def_gopher_text[] = "text/plain";
 
 static void
-gopherStateFree(int fd, void *data)
+gopherStateFree(int fdnotused, void *data)
 {
     GopherStateData *gopherState = data;
     if (gopherState == NULL)
@@ -670,7 +670,6 @@ gopherReadReply(int fd, void *data)
     char *buf = NULL;
     int len;
     int clen;
-    int off;
     int bin;
     if (protoAbortFetch(entry)) {
 	storeAbort(entry, 0);
@@ -679,7 +678,6 @@ gopherReadReply(int fd, void *data)
     }
     /* check if we want to defer reading */
     clen = entry->mem_obj->inmem_hi;
-    off = storeLowestMemReaderOffset(entry);
     buf = get_free_4k_page();
     errno = 0;
     /* leave one space for \0 in gopherToHTML */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: http.cc,v 1.216 1997/11/04 22:14:17 wessels Exp $
+ * $Id: http.cc,v 1.217 1997/11/05 05:29:27 wessels Exp $
  *
  * DEBUG: section 11    Hypertext Transfer Protocol (HTTP)
  * AUTHOR: Harvest Derived
@@ -216,7 +216,7 @@ static void httpRestart(HttpStateData *);
 static int httpCachableReply(HttpStateData *);
 
 static void
-httpStateFree(int fd, void *data)
+httpStateFree(int fdnotused, void *data)
 {
     HttpStateData *httpState = data;
     if (httpState == NULL)
@@ -453,13 +453,15 @@ httpCachableReply(HttpStateData * httpState)
 	    return 1;
 	else
 	    return 0;
+	/* NOTREACHED */
 	break;
 	/* Responses that only are cacheable if the server says so */
     case 302:			/* Moved temporarily */
 	if (reply->expires > -1)
 	    return 1;
 	else
 	    return 0;
+	/* NOTREACHED */
 	break;
 	/* Errors can be negatively cached */
     case 204:			/* No Content */
@@ -475,6 +477,7 @@ httpCachableReply(HttpStateData * httpState)
     case 503:			/* Service Unavailable */
     case 504:			/* Gateway Timeout */
 	return -1;
+	/* NOTREACHED */
 	break;
 	/* Some responses can never be cached */
     case 206:			/* Partial Content -- Not yet supported */
@@ -485,9 +488,10 @@ httpCachableReply(HttpStateData * httpState)
     case 600:			/* Squid header parsing error */
     default:			/* Unknown status code */
 	return 0;
+	/* NOTREACHED */
 	break;
     }
-    assert(0);
+    /* NOTREACHED */
 }
 
 void
@@ -600,7 +604,6 @@ httpReadReply(int fd, void *data)
     int len;
     int bin;
     int clen;
-    int off;
     ErrorState *err;
     if (protoAbortFetch(entry)) {
 	storeAbort(entry, 0);
@@ -609,7 +612,6 @@ httpReadReply(int fd, void *data)
     }
     /* check if we want to defer reading */
     clen = entry->mem_obj->inmem_hi;
-    off = storeLowestMemReaderOffset(entry);
     errno = 0;
     len = read(fd, buf, SQUID_TCP_SO_RCVBUF);
     fd_bytes(fd, len, FD_READ);
@@ -678,7 +680,7 @@ httpReadReply(int fd, void *data)
 /* This will be called when request write is complete. Schedule read of
  * reply. */
 static void
-httpSendComplete(int fd, char *buf, int size, int errflag, void *data)
+httpSendComplete(int fd, char *bufnotused, int size, int errflag, void *data)
 {
     HttpStateData *httpState = data;
     StoreEntry *entry = httpState->entry;
@@ -835,9 +837,8 @@ httpBuildRequestHeader(request_t * request,
 	url = entry ? storeUrl(entry) : urlCanonical(orig_request, NULL);
 	snprintf(ybuf, YBUF_SZ, "Cache-control: Max-age=%d", (int) getMaxAge(url));
 	httpAppendRequestHeader(hdr_out, ybuf, &len, out_sz, 1);
-	if (request->urlpath) {
+	if (request->urlpath[0])
 	    assert(strstr(url, request->urlpath));
-	}
     }
     /* maybe append Connection: Keep-Alive */
     if (BIT_TEST(flags, HTTP_KEEPALIVE)) {
@@ -35,7 +35,7 @@ icpUdpReply(int fd, void *data)
     int x;
     /* Disable handler, in case of errors. */
     commSetSelect(fd, COMM_SELECT_WRITE, NULL, NULL, 0);
-    while ((queue = UdpQueueHead)) {
+    while ((queue = UdpQueueHead) != NULL) {
 	debug(12, 5) ("icpUdpReply: FD %d sending %d bytes to %s port %d\n",
 	    fd,
 	    queue->len,
@@ -80,9 +80,9 @@ icpCreateMessage(
 	buf_len += sizeof(u_num32);
     buf = xcalloc(buf_len, 1);
     headerp = (icp_common_t *) (void *) buf;
-    headerp->opcode = opcode;
+    headerp->opcode = (char) opcode;
     headerp->version = ICP_VERSION_CURRENT;
-    headerp->length = htons(buf_len);
+    headerp->length = (u_short) htons(buf_len);
     headerp->reqnum = htonl(reqnum);
     headerp->flags = htonl(flags);
     headerp->pad = htonl(pad);
@@ -336,13 +336,7 @@ icpHandleIcpV2(int fd, struct sockaddr_in from, char *buf, int len)
 		IcpOpcodeStr[header.opcode]);
 	} else {
 	    /* call neighborsUdpAck even if ping_status != PING_WAITING */
-	    neighborsUdpAck(fd,
-		url,
-		&header,
-		&from,
-		entry,
-		data,
-		(int) data_sz);
+	    neighborsUdpAck(url, &header, &from, entry);
 	}
 	break;
 
@@ -379,7 +373,7 @@ icpPktDump(icp_common_t * pkt)
 #endif
 
 void
-icpHandleUdp(int sock, void *not_used)
+icpHandleUdp(int sock, void *datanotused)
 {
     struct sockaddr_in from;
     int from_len;
@@ -108,13 +108,7 @@ icpHandleIcpV3(int fd, struct sockaddr_in from, char *buf, int len)
 		IcpOpcodeStr[header.opcode]);
 	} else {
 	    /* call neighborsUdpAck even if ping_status != PING_WAITING */
-	    neighborsUdpAck(fd,
-		url,
-		&header,
-		&from,
-		entry,
-		data,
-		(int) data_sz);
+	    neighborsUdpAck(url, &header, &from, entry);
 	}
 	break;
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ident.cc,v 1.35 1997/10/25 17:22:47 wessels Exp $
+ * $Id: ident.cc,v 1.36 1997/11/05 05:29:29 wessels Exp $
  *
  * DEBUG: section 30    Ident (RFC 931)
  * AUTHOR: Duane Wessels
@@ -40,7 +40,7 @@ static CNCB identConnectDone;
 static void identCallback(ConnStateData * connState);
 
 static void
-identClose(int fd, void *data)
+identClose(int fdnotused, void *data)
 {
     ConnStateData *connState = data;
     connState->ident.fd = -1;
@@ -101,7 +101,12 @@ identConnectDone(int fd, int status, void *data)
 }
 
 static void
-identRequestComplete(int fd, char *buf, int size, int errflag, void *data)
+identRequestComplete(
+    int fd,
+    char *bufnotused,
+    int size,
+    int flagnotused,
+    void *datanotused)
 {
     debug(30, 5) ("identRequestComplete: FD %d: wrote %d bytes\n", fd, size);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ipcache.cc,v 1.140 1997/10/30 02:41:04 wessels Exp $
+ * $Id: ipcache.cc,v 1.141 1997/11/05 05:29:30 wessels Exp $
  *
  * DEBUG: section 14    IP Cache
  * AUTHOR: Harvest Derived
@@ -131,8 +131,8 @@ static struct {
 } IpcacheStats;
 
 static int ipcache_testname(void);
-static int ipcache_compareLastRef(ipcache_entry **, ipcache_entry **);
-static int ipcache_reverseLastRef(ipcache_entry **, ipcache_entry **);
+static QS ipcache_compareLastRef;
+static QS ipcache_reverseLastRef;
 static PF ipcache_dnsHandleRead;
 static ipcache_entry *ipcache_parsebuffer(const char *buf, dnsserver_t *);
 static void ipcache_release(ipcache_entry *);
@@ -297,10 +297,11 @@ ipcache_GetNext(void)
 }
 
 static int
-ipcache_compareLastRef(ipcache_entry ** e1, ipcache_entry ** e2)
+ipcache_compareLastRef(const void *A, const void *B)
 {
-    if (!e1 || !e2)
-	fatal_dump(NULL);
+    const ipcache_entry *const *e1 = A;
+    const ipcache_entry *const *e2 = B;
+    assert(e1 != NULL && e2 != NULL);
     if ((*e1)->lastref > (*e2)->lastref)
 	return (1);
     if ((*e1)->lastref < (*e2)->lastref)
@@ -309,8 +310,11 @@ ipcache_compareLastRef(ipcache_entry ** e1, ipcache_entry ** e2)
 }
 
 static int
-ipcache_reverseLastRef(ipcache_entry ** e1, ipcache_entry ** e2)
+ipcache_reverseLastRef(const void *A, const void *B)
 {
+    const ipcache_entry *const *e1 = A;
+    const ipcache_entry *const *e2 = B;
+    assert(e1 != NULL && e2 != NULL);
     if ((*e1)->lastref < (*e2)->lastref)
 	return (1);
     if ((*e1)->lastref > (*e2)->lastref)
@@ -336,7 +340,7 @@ ipcacheExpiredEntry(ipcache_entry * i)
 
 /* finds the LRU and deletes */
 void
-ipcache_purgelru(void *unused)
+ipcache_purgelru(void *voidnotused)
 {
     ipcache_entry *i = NULL;
     int local_ip_notpending_count = 0;
@@ -370,7 +374,7 @@ ipcache_purgelru(void *unused)
     qsort((char *) LRU_list,
 	LRU_list_count,
 	sizeof(ipcache_entry *),
-	(QS *) ipcache_compareLastRef);
+	ipcache_compareLastRef);
     for (k = 0; k < LRU_list_count; k++) {
 	if (meta_data.ipcache_count < ipcache_low)
 	    break;
@@ -910,15 +914,15 @@ stat_ipcache_get(StoreEntry * sentry)
     qsort((char *) list,
 	N,
 	sizeof(ipcache_entry *),
-	(QS *) ipcache_reverseLastRef);
+	ipcache_reverseLastRef);
     for (k = 0; k < N; k++)
 	ipcacheStatPrint(*(list + k), sentry);
     storeAppendPrintf(sentry, close_bracket);
     xfree(list);
 }
 
 static void
-dummy_handler(const ipcache_addrs * addrs, void *u3)
+dummy_handler(const ipcache_addrs * addrsnotused, void *datanotused)
 {
     return;
 }
@@ -1145,7 +1149,7 @@ ipcache_restart(void)
     assert(ip_table != NULL);
     while (ipcacheDequeue());
     next = (ipcache_entry *) hash_first(ip_table);
-    while ((this = next)) {
+    while ((this = next) != NULL) {
 	next = (ipcache_entry *) hash_next(ip_table);
 	if (this->status == IP_CACHED)
 	    continue;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: multicast.cc,v 1.3 1997/07/07 05:29:49 wessels Exp $
+ * $Id: multicast.cc,v 1.4 1997/11/05 05:29:31 wessels Exp $
  *
  * DEBUG: section 5     Socket Functions
  * AUTHOR: Martin Hamilton
@@ -44,7 +44,7 @@ mcastSetTtl(int fd, int mcast_ttl)
 }
 
 void
-mcastJoinGroups(const ipcache_addrs * ia, void *data)
+mcastJoinGroups(const ipcache_addrs * ia, void *datanotused)
 {
 #ifdef IP_MULTICAST_TTL
     int fd = theInIcpConnection;
@@ -1,5 +1,5 @@
 /*
- * $Id: neighbors.cc,v 1.165 1997/11/03 22:43:16 wessels Exp $
+ * $Id: neighbors.cc,v 1.166 1997/11/05 05:29:31 wessels Exp $
  *
  * DEBUG: section 15    Neighbor Routines
  * AUTHOR: Harvest Derived
@@ -546,7 +546,7 @@ neighborAlive(peer * p, const MemObject * mem, const icp_common_t * header)
 }
 
 static void
-neighborCountIgnored(peer * p, icp_opcode op_unused)
+neighborCountIgnored(peer * p, icp_opcode opnotused)
 {
     if (p == NULL)
 	return;
@@ -618,7 +618,7 @@ ignoreMulticastReply(peer * p, MemObject * mem)
  * If a hit process is already started, then sobeit
  */
 void
-neighborsUdpAck(int fd, const char *url, icp_common_t * header, const struct sockaddr_in *from, StoreEntry * entry, char *data, int data_sz)
+neighborsUdpAck(const char *url, icp_common_t * header, const struct sockaddr_in *from, StoreEntry * entry)
 {
     peer *p = NULL;
     MemObject *mem = entry->mem_obj;
@@ -807,11 +807,11 @@ peerDNSConfigure(const ipcache_addrs * ia, void *data)
 }
 
 static void
-peerRefreshDNS(void *junk)
+peerRefreshDNS(void *datanotused)
 {
     peer *p = NULL;
     peer *next = Config.peers;
-    while ((p = next)) {
+    while ((p = next) != NULL) {
 	next = p->next;
 	p->ip_lookup_pending = 1;
 	/* some random, bogus FD for ipcache */
@@ -840,7 +840,7 @@ peerCheckConnect(void *data)
 }
 
 static void
-peerCheckConnect2(const ipcache_addrs * ia, void *data)
+peerCheckConnect2(const ipcache_addrs * ianotused, void *data)
 {
     peer *p = data;
     p->ip_lookup_pending = 0;
@@ -959,7 +959,7 @@ peerCountMcastPeersDone(void *data)
 }
 
 static void
-peerCountHandleIcpReply(peer * p, peer_t type, icp_common_t * hdr, void *data)
+peerCountHandleIcpReply(peer * pnotused, peer_t type, icp_common_t * hdrnotused, void *data)
 {
     ps_state *psstate = data;
     psstate->icp.n_recv++;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: net_db.cc,v 1.50 1997/10/25 17:22:51 wessels Exp $
+ * $Id: net_db.cc,v 1.51 1997/11/05 05:29:32 wessels Exp $
  *
  * DEBUG: section 37    Network Measurement Database
  * AUTHOR: Duane Wessels
@@ -49,6 +49,9 @@ static net_db_peer *netdbPeerByName(const netdbEntry * n, const char *);
 static net_db_peer *netdbPeerAdd(netdbEntry * n, peer * e);
 static char *netdbPeerName(const char *name);
 static IPH netdbSendPing;
+static QS sortPeerByRtt;
+static QS sortByRtt;
+static QS netdbLRU;
 
 /* We have to keep a local list of peer names.  The Peers structure
  * gets freed during a reconfigure.  We want this database to
@@ -148,8 +151,10 @@ netdbRelease(netdbEntry * n)
 }
 
 static int
-netdbLRU(netdbEntry ** n1, netdbEntry ** n2)
+netdbLRU(const void *A, const void *B)
 {
+    const netdbEntry *const *n1 = A;
+    const netdbEntry *const *n2 = B;
     if ((*n1)->last_use_time > (*n2)->last_use_time)
 	return (1);
     if ((*n1)->last_use_time < (*n2)->last_use_time)
@@ -175,7 +180,7 @@ netdbPurgeLRU(void)
     qsort((char *) list,
 	list_count,
 	sizeof(netdbEntry *),
-	(QS *) netdbLRU);
+	netdbLRU);
     for (k = 0; k < list_count; k++) {
 	if (meta_data.netdb_addrs < Config.Netdb.low)
 	    break;
@@ -249,8 +254,10 @@ networkFromInaddr(struct in_addr a)
 }
 
 static int
-sortByRtt(netdbEntry ** n1, netdbEntry ** n2)
+sortByRtt(const void *A, const void *B)
 {
+    const netdbEntry *const *n1 = A;
+    const netdbEntry *const *n2 = B;
     if ((*n1)->rtt > (*n2)->rtt)
 	return 1;
     else if ((*n1)->rtt < (*n2)->rtt)
@@ -303,8 +310,10 @@ netdbPeerAdd(netdbEntry * n, peer * e)
 }
 
 static int
-sortPeerByRtt(net_db_peer * p1, net_db_peer * p2)
+sortPeerByRtt(const void *A, const void *B)
 {
+    const net_db_peer *p1 = A;
+    const net_db_peer *p2 = B;
     if (p1->rtt > p2->rtt)
 	return 1;
     else if (p1->rtt < p2->rtt)
@@ -575,7 +584,7 @@ netdbDump(StoreEntry * sentry)
     qsort((char *) list,
 	i,
 	sizeof(netdbEntry *),
-	(QS *) sortByRtt);
+	sortByRtt);
     for (k = 0; k < i; k++) {
 	n = *(list + k);
 	storeAppendPrintf(sentry, "{%-16.16s %4d/%4d %7.1f %5.1f",	/* } */
@@ -653,6 +662,6 @@ netdbUpdatePeer(request_t * r, peer * e, int irtt, int ihops)
     qsort((char *) n->peers,
 	n->n_peers,
 	sizeof(net_db_peer),
-	(QS *) sortPeerByRtt);
+	sortPeerByRtt);
 #endif
 }
@@ -318,7 +318,7 @@ extern int neighborsUdpPing(request_t *,
     void *data,
     int *exprep);
 extern void neighborAddAcl(const char *, const char *);
-extern void neighborsUdpAck(int, const char *, icp_common_t *, const struct sockaddr_in *, StoreEntry *, char *, int);
+extern void neighborsUdpAck(const char *, icp_common_t *, const struct sockaddr_in *, StoreEntry *);
 extern void neighborAdd(const char *, const char *, int, int, int, int, int);
 extern void neighbors_open(int);
 extern peer *peerFindByName(const char *);
@@ -350,7 +350,7 @@ extern void peerSelectInit(void);
 
 extern void protoDispatch(int, StoreEntry *, request_t *);
 
-extern int protoUnregister(StoreEntry *, request_t *, struct in_addr);
+extern int protoUnregister(StoreEntry *, request_t *);
 extern void protoStart(int, StoreEntry *, peer *, request_t *);
 extern int protoAbortFetch(StoreEntry * entry);
 extern DEFER protoCheckDeferRead;
@@ -469,6 +469,7 @@ extern const cache_key *storeKeyScan(const char *);
 extern const char *storeKeyText(const cache_key *);
 extern const cache_key *storeKeyPublic(const char *, method_t);
 extern const cache_key *storeKeyPrivate(const char *, method_t, int);
+extern int storeKeyHashBuckets(int);
 extern HASHHASH storeKeyHashHash;
 extern HASHCMP storeKeyHashCmp;
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: send-announce.cc,v 1.44 1997/10/17 00:00:45 wessels Exp $
+ * $Id: send-announce.cc,v 1.45 1997/11/05 05:29:35 wessels Exp $
  *
  * DEBUG: section 27    Cache Announcer
  * AUTHOR: Duane Wessels
@@ -34,7 +34,7 @@
 static IPH send_announce;
 
 void
-start_announce(void *unused)
+start_announce(void *datanotused)
 {
     if (!Config.onoff.announce)
 	return;
@@ -43,7 +43,7 @@ start_announce(void *unused)
 }
 
 static void
-send_announce(const ipcache_addrs * ia, void *data)
+send_announce(const ipcache_addrs * ia, void *datanotused)
 {
     LOCAL_ARRAY(char, tbuf, 256);
     LOCAL_ARRAY(char, sndbuf, BUFSIZ);
@@ -77,7 +77,7 @@ send_announce(const ipcache_addrs * ia, void *data)
 	mkhttpdlogtime(&squid_curtime));
     strcat(sndbuf, tbuf);
     l = strlen(sndbuf);
-    if ((file = Config.Announce.file)) {
+    if ((file = Config.Announce.file) != NULL) {
 	fd = file_open(file, O_RDONLY, NULL, NULL);
 	if (fd > -1 && (n = read(fd, sndbuf + l, BUFSIZ - l - 1)) > 0) {
 	    fd_bytes(fd, n, FD_READ);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: ssl.cc,v 1.68 1997/11/04 18:43:29 wessels Exp $
+ * $Id: ssl.cc,v 1.69 1997/11/05 05:29:36 wessels Exp $
  *
  * DEBUG: section 26    Secure Sockets Layer Proxy
  * AUTHOR: Duane Wessels
@@ -88,7 +88,7 @@ sslClientClosed(int fd, void *data)
     debug(26, 3) ("sslClientClosed: FD %d\n", fd);
     /* we have been called from comm_close for the client side, so
      * just need to clean up the server side */
-    protoUnregister(NULL, sslState->request, no_addr);
+    protoUnregister(NULL, sslState->request);
     comm_close(sslState->server.fd);
 }
 
@@ -306,15 +306,15 @@ sslConnected(int fd, void *data)
 }
 
 static void
-sslErrorComplete(int fd, void *sslState, int size)
+sslErrorComplete(int fdnotused, void *sslState, int sizenotused)
 {
     assert(sslState != NULL);
     sslClose(sslState);
 }
 
 
 static void
-sslConnectDone(int fd, int status, void *data)
+sslConnectDone(int fdnotused, int status, void *data)
 {
     SslStateData *sslState = data;
     request_t *request = sslState->request;
@@ -448,7 +448,7 @@ sslPeerSelectComplete(peer * p, void *data)
 }
 
 static void
-sslPeerSelectFail(peer * p, void *data)
+sslPeerSelectFail(peer * peernotused, void *data)
 {
     SslStateData *sslState = data;
     ErrorState *err;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: stat.cc,v 1.167 1997/11/03 23:18:17 wessels Exp $
+ * $Id: stat.cc,v 1.168 1997/11/05 05:29:37 wessels Exp $
  *
  * DEBUG: section 18    Cache Manager Statistics
  * AUTHOR: Harvest Derived
@@ -446,7 +446,7 @@ dump_peers(StoreEntry * sentry, peer * peers)
 	}
 	storeAppendPrintf(sentry, close_bracket);	/* } */
 	storeAppendPrintf(sentry, "{Keep-Alive Ratio: %d%%}\n",
-		percent(e->stats.n_keepalives_recv, e->stats.n_keepalives_sent));
+	    percent(e->stats.n_keepalives_recv, e->stats.n_keepalives_sent));
     }
     storeAppendPrintf(sentry, close_bracket);
 }
@@ -1,6 +1,6 @@
 
 /*
- * $Id: store.cc,v 1.334 1997/11/03 23:18:18 wessels Exp $
+ * $Id: store.cc,v 1.335 1997/11/05 05:29:38 wessels Exp $
  *
  * DEBUG: section 20    Storeage Manager
  * AUTHOR: Harvest Derived
@@ -272,7 +272,6 @@ static hash_table *store_table = NULL;
 static dlink_list inmem_list;
 static dlink_list all_list;
 
-static int store_pages_max = 0;
 static int store_pages_high = 0;
 static int store_pages_low = 0;
 
@@ -654,7 +653,7 @@ storeUnregister(StoreEntry * e, void *data)
     if (mem == NULL)
 	return 0;
     debug(20, 3) ("storeUnregister: called for '%s'\n", storeKeyText(e->key));
-    for (S = &mem->clients; (sc = *S); S = &(*S)->next) {
+    for (S = &mem->clients; (sc = *S) != NULL; S = &(*S)->next) {
 	if (sc->callback_data == data)
 	    break;
     }
@@ -668,7 +667,7 @@ storeUnregister(StoreEntry * e, void *data)
 	commSetSelect(sc->swapin_fd, COMM_SELECT_READ, NULL, NULL, 0);
 	file_close(sc->swapin_fd);
     }
-    if ((callback = sc->callback)) {
+    if ((callback = sc->callback) != NULL) {
 	/* callback with ssize = -1 to indicate unexpected termination */
 	debug(20, 3) ("storeUnregister: store_client for %s has a callback\n",
 	    mem->url);
@@ -780,7 +779,7 @@ storeSwapOutStart(StoreEntry * e)
 }
 
 static void
-storeSwapOutHandle(int fd, int flag, size_t len, void *data)
+storeSwapOutHandle(int fdnotused, int flag, size_t len, void *data)
 {
     StoreEntry *e = data;
     MemObject *mem = e->mem_obj;
@@ -834,7 +833,7 @@ storeCheckSwapOut(StoreEntry * e)
     off_t new_mem_lo;
     size_t swapout_size;
     char *swap_buf;
-    size_t swap_buf_len;
+    ssize_t swap_buf_len;
     int x;
     assert(mem != NULL);
     /* should we swap something out to disk? */
@@ -1205,7 +1204,7 @@ storeDoRebuildFromDisk(void *data)
 }
 
 static void
-storeCleanup(void *data)
+storeCleanup(void *datanotused)
 {
     static storeCleanList *list = NULL;
     storeCleanList *curr;
@@ -1490,7 +1489,7 @@ storeGetMemSpace(int size)
     static time_t last_check = 0;
     int pages_needed;
     dlink_node *m;
-    dlink_node *prev;
+    dlink_node *prev = NULL;
     if (squid_curtime == last_check)
 	return;
     last_check = squid_curtime;
@@ -1527,10 +1526,10 @@ storeGetMemSpace(int size)
  * This should get called 1/s from main().
  */
 void
-storeMaintainSwapSpace(void *NOTUSED)
+storeMaintainSwapSpace(void *datanotused)
 {
     dlink_node *m;
-    dlink_node *prev;
+    dlink_node *prev = NULL;
     StoreEntry *e = NULL;
     int scanned = 0;
     int locked = 0;
@@ -1781,7 +1780,7 @@ storeClientCopyFileRead(store_client * sc)
 }
 
 static void
-storeClientCopyHandleRead(int fd, const char *buf, int len, int flag, void *data)
+storeClientCopyHandleRead(int fd, const char *buf, int len, int flagnotused, void *data)
 {
     store_client *sc = data;
     MemObject *mem = sc->mem;
@@ -1896,7 +1895,6 @@ storeConfigure(void)
     store_swap_low = (long) (((float) Config.Swap.maxSize *
 	    (float) Config.Swap.lowWaterMark) / (float) 100);
 
-    store_pages_max = Config.Mem.maxSize / SM_PAGE_SIZE;
     store_pages_high = store_mem_high / SM_PAGE_SIZE;
     store_pages_low = store_mem_low / SM_PAGE_SIZE;
 }
@@ -747,7 +747,7 @@ struct _store_client {
     STCB *callback;
     void *callback_data;
     MemObject *mem;		/* ptr to the parent structure, argh! */
-    short swapin_fd;
+    int swapin_fd;
     struct _store_client *next;
 };
 
@@ -1,6 +1,6 @@
 
 /*
- * $Id: tools.cc,v 1.128 1997/10/30 18:37:08 wessels Exp $
+ * $Id: tools.cc,v 1.129 1997/11/05 05:29:40 wessels Exp $
  *
  * DEBUG: section 21    Misc Functions
  * AUTHOR: Harvest Derived
@@ -302,7 +302,7 @@ death(int sig)
 
 
 void
-sigusr2_handle(int sig)
+sigusr2_handle(int signotused)
 {
     static int state = 0;
     /* no debug() here; bad things happen if the signal is delivered during _db_print() */
@@ -319,7 +319,7 @@ sigusr2_handle(int sig)
 }
 
 static void
-shutdownTimeoutHandler(int fd, void *data)
+shutdownTimeoutHandler(int fd, void *datanotused)
 {
     debug(21, 1) ("Forcing close of FD %d\n", fd);
     comm_close(fd);
@@ -434,7 +434,7 @@ debug_trap(const char *message)
 }
 
 void
-sig_child(int sig)
+sig_child(int signotused)
 {
 #ifdef _SQUID_NEXT_
     union wait status;
@@ -466,7 +466,7 @@ getMyHostname(void)
     const struct hostent *h = NULL;
     char *t = NULL;
 
-    if ((t = Config.visibleHostname))
+    if ((t = Config.visibleHostname) != NULL)
 	return t;
 
     /* Get the host name and store it in host to return */
@@ -1,6 +1,6 @@
 
 /*
- * $Id: tunnel.cc,v 1.68 1997/11/04 18:43:29 wessels Exp $
+ * $Id: tunnel.cc,v 1.69 1997/11/05 05:29:36 wessels Exp $
  *
  * DEBUG: section 26    Secure Sockets Layer Proxy
  * AUTHOR: Duane Wessels
@@ -88,7 +88,7 @@ sslClientClosed(int fd, void *data)
     debug(26, 3) ("sslClientClosed: FD %d\n", fd);
     /* we have been called from comm_close for the client side, so
      * just need to clean up the server side */
-    protoUnregister(NULL, sslState->request, no_addr);
+    protoUnregister(NULL, sslState->request);
     comm_close(sslState->server.fd);
 }
 
@@ -306,15 +306,15 @@ sslConnected(int fd, void *data)
 }
 
 static void
-sslErrorComplete(int fd, void *sslState, int size)
+sslErrorComplete(int fdnotused, void *sslState, int sizenotused)
 {
     assert(sslState != NULL);
     sslClose(sslState);
 }
 
 
 static void
-sslConnectDone(int fd, int status, void *data)
+sslConnectDone(int fdnotused, int status, void *data)
 {
     SslStateData *sslState = data;
     request_t *request = sslState->request;
@@ -448,7 +448,7 @@ sslPeerSelectComplete(peer * p, void *data)
 }
 
 static void
-sslPeerSelectFail(peer * p, void *data)
+sslPeerSelectFail(peer * peernotused, void *data)
 {
     SslStateData *sslState = data;
     ErrorState *err;
@@ -1,6 +1,6 @@
 
 /*
- * $Id: url.cc,v 1.65 1997/10/17 00:00:49 wessels Exp $
+ * $Id: url.cc,v 1.66 1997/11/05 05:29:40 wessels Exp $
  *
  * DEBUG: section 23    URL Parsing
  * AUTHOR: Duane Wessels
@@ -235,7 +235,7 @@ urlParse(method_t method, char *url)
     for (t = host; *t; t++)
 	*t = tolower(*t);
     /* remove trailing dots from hostnames */
-    while ((l = strlen(host)) && host[--l] == '.')
+    while ((l = strlen(host)) > 0 && host[--l] == '.')
 	host[l] = '\0';
     if (Config.appendDomain && !strchr(host, '.'))
 	strncat(host, Config.appendDomain, SQUIDHOSTNAMELEN);
@@ -1,6 +1,6 @@
 
 /*
- * $Id: wais.cc,v 1.95 1997/11/03 22:43:26 wessels Exp $
+ * $Id: wais.cc,v 1.96 1997/11/05 05:29:41 wessels Exp $
  *
  * DEBUG: section 24    WAIS Relay
  * AUTHOR: Harvest Derived
@@ -125,7 +125,7 @@ static CNCB waisConnectDone;
 static STABH waisAbort;
 
 static void
-waisStateFree(int fd, void *data)
+waisStateFree(int fdnotused, void *data)
 {
     WaisStateData *waisState = data;
     if (waisState == NULL)
@@ -227,7 +227,7 @@ waisReadReply(int fd, void *data)
 /* This will be called when request write is complete. Schedule read of
  * reply. */
 static void
-waisSendComplete(int fd, char *buf, int size, int errflag, void *data)
+waisSendComplete(int fd, char *bufnotused, int size, int errflag, void *data)
 {
     WaisStateData *waisState = data;
     StoreEntry *entry = waisState->entry;