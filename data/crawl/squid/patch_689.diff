@@ -273,6 +273,9 @@ typedef char * caddr_t;
 #ifndef EAFNOSUPPORT
 #define EAFNOSUPPORT WSAEAFNOSUPPORT
 #endif
+#ifndef ENETUNREACH
+#define ENETUNREACH WSAENETUNREACH
+#endif
 
 #undef h_errno
 #define h_errno errno /* we'll set it ourselves */
@@ -1821,9 +1821,6 @@ if test x"$krb5confpath" != "xno"; then
     fi
 fi
 if test "x$ac_krb5_config" = "xyes" ; then
-  # Kerberos helpers use res_search() from libresolv or libc
-  AC_SEARCH_LIBS([__res_search],[resolv])
-
   ac_heimdal="`$krb5confpath --version 2>/dev/null | grep -i heimdal`"
   ac_solaris="`$krb5confpath --version 2>/dev/null | grep -i solaris`"
   if test "x$ac_heimdal" != "x" ; then
@@ -2514,6 +2511,7 @@ AC_MSG_NOTICE([libcap2 headers are ok: $squid_cv_sys_capability_works])
 dnl Check for needed libraries
 AC_SEARCH_LIBS([gethostbyname],[nsl resolv bind])
 AC_SEARCH_LIBS([res_init],[resolv])
+AC_SEARCH_LIBS([__res_search],[resolv])
 AC_SEARCH_LIBS([bind],[socket])
 AC_SEARCH_LIBS([opcom_stack_trace],[opcom_stack])
 AC_SEARCH_LIBS([strlcpy], [bsd])
@@ -3368,6 +3366,7 @@ AC_CONFIG_FILES([\
 	lib/smblib/Makefile \
 	scripts/Makefile \
 	src/Makefile \
+	src/anyp/Makefile \
 	src/base/Makefile \
 	src/acl/Makefile \
 	src/fs/Makefile \
@@ -3,7 +3,7 @@ msgstr ""
 "Project-Id-Version: Squid-3\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2011-02-06 22:39+1300\n"
-"PO-Revision-Date: 2011-02-14 23:49+0200\n"
+"PO-Revision-Date: 2011-02-24 19:27+0200\n"
 "Last-Translator: Bernard <fli4l.charrier@free.fr>\n"
 "Language-Team: Squid Developers <squid-dev@squid-cache.org>\n"
 "Language: fr\n"
@@ -262,7 +262,7 @@ msgstr "Transmission interdite."
 
 #: templates/ERR_GATEWAY_FAILURE:5
 msgid "Gateway Proxy Failure"
-msgstr "Défaillance de la passerelle Proxy "
+msgstr "Défaillance de la passerelle Proxy"
 
 #: templates/ERR_ACCESS_DENIED:8 templates/ERR_AGENT_CONFIGURE:16
 #: templates/ERR_AGENT_WPAD:15 templates/ERR_CACHE_ACCESS_DENIED:8
@@ -793,7 +793,7 @@ msgstr ""
 #: templates/ERR_URN_RESOLVE:7 templates/ERR_WRITE_ERROR:8
 #: templates/ERR_ZERO_SIZE_OBJECT:7
 msgid "Your cache administrator is <a href=\"mailto:%w%W\">%w</a>."
-msgstr "Votre administrateur proxy est <a href=\"mailto:%w\">%w</a>."
+msgstr "Votre administrateur proxy est <a href=\"mailto:%w%W\">%w</a>."
 
 #: templates/ERR_INVALID_RESP:6
 msgid ""
@@ -6,33 +6,49 @@ extern "C" {
 #endif
 
     /* Encoder rfc1738_do_escape flag values. */
-#define RFC1738_ESCAPE_UNSAFE     0
-#define RFC1738_ESCAPE_RESERVED   1
-#define RFC1738_ESCAPE_UNESCAPED -1
-
+#define RFC1738_ESCAPE_CTRLS       1
+#define RFC1738_ESCAPE_UNSAFE      2
+#define RFC1738_ESCAPE_RESERVED    4
+#define RFC1738_ESCAPE_ALL         (RFC1738_ESCAPE_UNSAFE|RFC1738_ESCAPE_RESERVED|RFC1738_ESCAPE_CTRLS)
+    // exclusions
+#define RFC1738_ESCAPE_NOSPACE     128
+#define RFC1738_ESCAPE_NOPERCENT   256
+    // Backward compatibility
+#define RFC1738_ESCAPE_UNESCAPED   (RFC1738_ESCAPE_UNSAFE|RFC1738_ESCAPE_CTRLS|RFC1738_ESCAPE_NOPERCENT)
 
     /**
      * \group rfc1738 RFC 1738 URL-escaping library
      *
      * Public API is formed of a triplet of encode functions mapping to the rfc1738_do_encode() engine.
      *
-     * ASCII characters are split into three groups:
+     * ASCII characters are split into four groups:
      * \item SAFE     Characters which are safe to occur in any URL. For example A,B,C
-     * \item UNSAFE   Characters which are completely usafe to occur in any URL. For example; backspace, tab, space, newline
+     * \item CTRLS    Binary control codes. Dangerous to include in URLs.
+     * \item UNSAFE   Characters which are completely usafe to occur in any URL. For example; backspace, tab, space, newline.
      * \item RESERVED Characters which are reserved for special meaning and may only occur in certain parts of a URL.
      *
      * Returns a static buffer containing the RFC 1738 compliant, escaped version of the given url.
      *
-     * \param flags  RFC1738_ESCAPE_UNSAFE    Only encode unsafe characters. Ignore reserved.
-     * \param flags  RFC1738_ESCAPE_RESERVED  Encode all unsafe and reserved characters.
-     * \param flags  RFC1738_ESCAPE_UNESCAPED Encode all unsafe characters which have not already been encoded.
+     * \param flags  RFC1738_ESCAPE_CTRLS     Encode the blatantly dangerous binary codes.
+     * \param flags  RFC1738_ESCAPE_UNSAFE    Encode printable unsafe characters (excluding CTRLs).
+     * \param flags  RFC1738_ESCAPE_RESERVED  Encode reserved characters.
+     * \param flags  RFC1738_ESCAPE_ALL       Encode all binary CTRL, unsafe and reserved characters.
+     * \param flags  RFC1738_ESCAPE_NOSPACE   Ignore the space whitespace character.
+     * \param flags  RFC1738_ESCAPE_NOPERCENT Ignore the escaping delimiter '%'.
      */
     extern char *rfc1738_do_escape(const char *url, int flags);
 
     /* Old API functions */
-#define rfc1738_escape(x)  rfc1738_do_escape(x, RFC1738_ESCAPE_UNSAFE)
-#define rfc1738_escape_part(x)  rfc1738_do_escape(x, RFC1738_ESCAPE_RESERVED)
-#define rfc1738_escape_unescaped(x)  rfc1738_do_escape(x, RFC1738_ESCAPE_UNESCAPED)
+
+    /* Default RFC 1738 escaping. Escape all UNSAFE characters and binary CTRL codes */
+#define rfc1738_escape(x)  rfc1738_do_escape(x, RFC1738_ESCAPE_UNSAFE|RFC1738_ESCAPE_CTRLS)
+
+    /* Escape a partial URL. Encoding every binary code, unsafe or reserved character. */
+#define rfc1738_escape_part(x)  rfc1738_do_escape(x, RFC1738_ESCAPE_ALL)
+
+    /* Escape a URL. Encoding every unsafe characters but skipping reserved and already-encoded bytes.
+     * Suitable for safely encoding an absolute URL which may be encoded but is not trusted. */
+#define rfc1738_escape_unescaped(x)  rfc1738_do_escape(x, RFC1738_ESCAPE_UNSAFE|RFC1738_ESCAPE_CTRLS|RFC1738_ESCAPE_NOPERCENT)
 
 
     /**
@@ -4,7 +4,7 @@ AC_CONFIG_SRCDIR([src/Trie.cc])
 AM_CONFIG_HEADER([config.h])
 AC_CONFIG_AUX_DIR(cfgaux)
 
-enable_inline=${enable_inine:=yes}
+enable_inline=${enable_inline:=yes}
 AC_ARG_ENABLE(optimizations,
   AC_HELP_STRING([--disable-optimizations],
                  [Do not compile Squid with compiler optimizations enabled.
@@ -13,7 +13,7 @@ AC_ARG_ENABLE(optimizations,
                   --disable-optimizations to reduce compilation times
                   and allow easier debugging. This option implicitly
                   also enabled --disable-inline]), [
-if test "x$enableval" = "xno" ; then
+  if test "x$enableval" = "xno" ; then
         AC_MSG_NOTICE([Disabling compiler optimizations (-O flag)])
         CFLAGS="`echo $CFLAGS | sed -e 's/-O[[0-9]]*//'`"
         CXXFLAGS="`echo $CXXFLAGS | sed -e 's/-O[[0-9]]*//'`"
@@ -32,9 +32,11 @@ AC_ARG_ENABLE(inline,
                   production builds, or load tests, use
                   --enable-inline to have squid make all trivial
                   methods inlinable by the compiler.]), [
+  if test "x${enableval}" = "xno" ; then
+    enable_inline=no
+  fi
 ])
-
-if test "$enable_inline" = "yes" ; then
+if test "x$enable_inline" = "xyes" ; then
     AC_DEFINE(_SQUID_INLINE_, inline, 
       [Keyword used by squid for inlining methods])
     AC_DEFINE(_USE_INLINE_, 1, [Include inline methods into header file])
@@ -44,7 +46,6 @@ else
     AC_DEFINE(_USE_INLINE_, 0, [Include inline methods into header file])
 fi
 
-
 # Checks for programs.
 AC_PROG_CXX
 AC_PROG_CC
@@ -34,7 +34,6 @@
 
 #include "config.h"
 #include "rfc1738.h"
-//#include "util.h"
 
 #if HAVE_STDIO_H
 #include <stdio.h>
@@ -53,6 +52,7 @@ static char rfc1738_unsafe_chars[] = {
     (char) 0x22,		/* " */
     (char) 0x23,		/* # */
 #if 0				/* done in code */
+    (char) 0x20,		/* space */
     (char) 0x25,		/* % */
 #endif
     (char) 0x7B,		/* { */
@@ -64,8 +64,7 @@ static char rfc1738_unsafe_chars[] = {
     (char) 0x5B,		/* [ */
     (char) 0x5D,		/* ] */
     (char) 0x60,		/* ` */
-    (char) 0x27,		/* ' */
-    (char) 0x20			/* space */
+    (char) 0x27 		/* ' */
 };
 
 static char rfc1738_reserved_chars[] = {
@@ -97,36 +96,49 @@ rfc1738_do_escape(const char *url, int flags)
         buf = (char*)xcalloc(bufsize, 1);
     }
     for (p = url, q = buf; *p != '\0' && q < (buf + bufsize - 1); p++, q++) {
+
+        /* a-z, A-Z and 0-9 are SAFE. */
+        if ((*p >= 'a' && *p <= 'z') || (*p >= 'A' && *p <= 'Z') || (*p >= '0' && *p <= '9')) {
+            *q = *p;
+            continue;
+        }
+
         do_escape = 0;
 
         /* RFC 1738 defines these chars as unsafe */
-        for (i = 0; i < sizeof(rfc1738_unsafe_chars); i++) {
-            if (*p == rfc1738_unsafe_chars[i]) {
-                do_escape = 1;
-                break;
+        if ((flags & RFC1738_ESCAPE_UNSAFE)) {
+            for (i = 0; i < sizeof(rfc1738_unsafe_chars); i++) {
+                if (*p == rfc1738_unsafe_chars[i]) {
+                    do_escape = 1;
+                    break;
+                }
             }
+            /* Handle % separately */
+            if (!(flags & RFC1738_ESCAPE_NOPERCENT) && *p == '%')
+                do_escape = 1;
+            /* Handle space separately */
+            else if (!(flags & RFC1738_ESCAPE_NOSPACE) && *p <= ' ')
+                do_escape = 1;
         }
-        /* Handle % separately */
-        if (flags != RFC1738_ESCAPE_UNESCAPED && *p == '%')
-            do_escape = 1;
         /* RFC 1738 defines these chars as reserved */
-        for (i = 0; i < sizeof(rfc1738_reserved_chars) && flags == RFC1738_ESCAPE_RESERVED; i++) {
-            if (*p == rfc1738_reserved_chars[i]) {
-                do_escape = 1;
-                break;
+        if ((flags & RFC1738_ESCAPE_RESERVED) && do_escape == 0) {
+            for (i = 0; i < sizeof(rfc1738_reserved_chars); i++) {
+                if (*p == rfc1738_reserved_chars[i]) {
+                    do_escape = 1;
+                    break;
+                }
             }
         }
-        /* RFC 1738 says any control chars (0x00-0x1F) are encoded */
-        if ((unsigned char) *p <= (unsigned char) 0x1F) {
-            do_escape = 1;
-        }
-        /* RFC 1738 says 0x7f is encoded */
-        if (*p == (char) 0x7F) {
-            do_escape = 1;
-        }
-        /* RFC 1738 says any non-US-ASCII are encoded */
-        if (((unsigned char) *p >= (unsigned char) 0x80)) {
-            do_escape = 1;
+        if ((flags & RFC1738_ESCAPE_CTRLS) && do_escape == 0) {
+            /* RFC 1738 says any control chars (0x00-0x1F) are encoded */
+            if ((unsigned char) *p <= (unsigned char) 0x1F)
+                do_escape = 1;
+            /* RFC 1738 says 0x7f is encoded */
+            else if (*p == (char) 0x7F)
+                do_escape = 1;
+            /* RFC 1738 says any non-US-ASCII are encoded */
+            else if (((unsigned char) *p >= (unsigned char) 0x80))
+                do_escape = 1;
         }
         /* Do the triplet encoding, or just copy the char */
         /* note: we do not need snprintf here as q is appropriately
@@ -87,10 +87,6 @@ void testRFC1738::testUrlEncode()
 {
     char *result;
 
-#define RFC1738_ESCAPE_UNSAFE     0
-#define RFC1738_ESCAPE_RESERVED   1
-#define RFC1738_ESCAPE_UNESCAPED -1
-
     /* TEST: Escaping only unsafe characters */
 
     /* regular URL (no encoding needed) */
@@ -110,7 +110,7 @@ ACLStrategised<const char *> ACLMyPortName::RegistryEntry_(new ACLStringData, AC
 ACL::Prototype ACLPeerName::RegistryProtoype(&ACLPeerName::RegistryEntry_, "peername");
 ACLStrategised<const char *> ACLPeerName::RegistryEntry_(new ACLStringData, ACLPeerNameStrategy::Instance(), "peername");
 ACL::Prototype ACLProtocol::RegistryProtoype(&ACLProtocol::RegistryEntry_, "proto");
-ACLStrategised<protocol_t> ACLProtocol::RegistryEntry_(new ACLProtocolData, ACLProtocolStrategy::Instance(), "proto");
+ACLStrategised<AnyP::ProtocolType> ACLProtocol::RegistryEntry_(new ACLProtocolData, ACLProtocolStrategy::Instance(), "proto");
 ACL::Prototype ACLRandom::RegistryProtoype(&ACLRandom::RegistryEntry_, "random");
 ACLRandom ACLRandom::RegistryEntry_("random");
 ACL::Prototype ACLReferer::RegistryProtoype(&ACLReferer::RegistryEntry_, "referer_regex");
@@ -149,7 +149,6 @@ BodyPipe::~BodyPipe()
 void BodyPipe::setBodySize(uint64_t aBodySize)
 {
     assert(!bodySizeKnown());
-    assert(aBodySize >= 0);
     assert(thePutSize <= aBodySize);
 
     // If this assert fails, we need to add code to check for eof and inform
@@ -38,7 +38,7 @@
 #include "MemBuf.h"
 
 HttpMsg::HttpMsg(http_hdr_owner_type owner): header(owner),
-        cache_control(NULL), hdr_sz(0), content_length(0), protocol(PROTO_NONE),
+        cache_control(NULL), hdr_sz(0), content_length(0), protocol(AnyP::PROTO_NONE),
         pstate(psReadyToParseStartLine), lock_count(0)
 {}
 
@@ -89,7 +89,7 @@ class HttpMsg
 
     int64_t content_length;
 
-    protocol_t protocol;
+    AnyP::ProtocolType protocol;
 
     HttpMsgParseState pstate;   /* the current parsing state */
 
@@ -53,7 +53,7 @@ HttpRequest::HttpRequest() : HttpMsg(hoRequest)
     init();
 }
 
-HttpRequest::HttpRequest(const HttpRequestMethod& aMethod, protocol_t aProtocol, const char *aUrlpath) : HttpMsg(hoRequest)
+HttpRequest::HttpRequest(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath) : HttpMsg(hoRequest)
 {
     static unsigned int id = 1;
     debugs(93,7, HERE << "constructed, this=" << this << " id=" << ++id);
@@ -68,7 +68,7 @@ HttpRequest::~HttpRequest()
 }
 
 void
-HttpRequest::initHTTP(const HttpRequestMethod& aMethod, protocol_t aProtocol, const char *aUrlpath)
+HttpRequest::initHTTP(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath)
 {
     method = aMethod;
     protocol = aProtocol;
@@ -79,7 +79,7 @@ void
 HttpRequest::init()
 {
     method = METHOD_NONE;
-    protocol = PROTO_NONE;
+    protocol = AnyP::PROTO_NONE;
     urlpath = NULL;
     login[0] = '\0';
     host[0] = '\0';
@@ -565,7 +565,7 @@ HttpRequest::CreateFromUrl(char * url)
 bool
 HttpRequest::cacheable() const
 {
-    if (protocol == PROTO_HTTP)
+    if (protocol == AnyP::PROTO_HTTP)
         return httpCachable(method);
 
     /*
@@ -580,10 +580,10 @@ HttpRequest::cacheable() const
      * XXX POST may be cached sometimes.. ignored
      * for now
      */
-    if (protocol == PROTO_GOPHER)
+    if (protocol == AnyP::PROTO_GOPHER)
         return gopherCachable(this);
 
-    if (protocol == PROTO_CACHEOBJ)
+    if (protocol == AnyP::PROTO_CACHE_OBJECT)
         return false;
 
     return true;
@@ -73,7 +73,7 @@ class HttpRequest: public HttpMsg
 
     MEMPROXY_CLASS(HttpRequest);
     HttpRequest();
-    HttpRequest(const HttpRequestMethod& aMethod, protocol_t aProtocol, const char *aUrlpath);
+    HttpRequest(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath);
     ~HttpRequest();
     virtual void reset();
 
@@ -82,7 +82,7 @@ class HttpRequest: public HttpMsg
         return static_cast<HttpRequest*>(HttpMsg::_lock());
     };
 
-    void initHTTP(const HttpRequestMethod& aMethod, protocol_t aProtocol, const char *aUrlpath);
+    void initHTTP(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath);
 
     virtual HttpRequest *clone() const;
 
@@ -111,7 +111,7 @@ class HttpRequest: public HttpMsg
         }
     };
     inline const char* GetHost(void) const { return host; };
-    inline const int GetHostIsNumeric(void) const { return host_is_numeric; };
+    inline int GetHostIsNumeric(void) const { return host_is_numeric; };
 
 #if USE_ADAPTATION
     /// Returns possibly nil history, creating it if adapt. logging is enabled
@@ -137,10 +137,10 @@ class HttpRequestMethod
      \retval METHOD_OTHER  the method is not recognized and has no unique ID
      \retval *             the method is on of the recognized HTTP methods.
      */
-    _method_t const id() const { return theMethod; }
+    _method_t id() const { return theMethod; }
 
     /** Get a char string representation of the method. */
-    char const* image() const;
+    char const * image() const;
 
     bool isCacheble() const;
     bool purgesOthers() const;
@@ -60,7 +60,7 @@ void
 httpStatusLineSet(HttpStatusLine * sline, HttpVersion version, http_status status, const char *reason)
 {
     assert(sline);
-    sline->protocol = PROTO_HTTP;
+    sline->protocol = AnyP::PROTO_HTTP;
     sline->version = version;
     sline->status = status;
     /* Note: no xstrdup for 'reason', assumes constant 'reasons' */
@@ -77,7 +77,7 @@ httpStatusLinePackInto(const HttpStatusLine * sline, Packer * p)
     assert(sline && p);
 
     /* handle ICY protocol status line specially. Pass on the bad format. */
-    if (sline->protocol == PROTO_ICY) {
+    if (sline->protocol == AnyP::PROTO_ICY) {
         debugs(57, 9, "packing sline " << sline << " using " << p << ":");
         debugs(57, 9, "FORMAT=" << IcyStatusLineFormat );
         debugs(57, 9, "ICY " << sline->status << " " << (sline->reason ? sline->reason : httpStatusString(sline->status)) );
@@ -108,7 +108,7 @@ httpStatusLineParse(HttpStatusLine * sline, const String &protoPrefix, const cha
 
     if (protoPrefix.cmp("ICY", 3) == 0) {
         debugs(57, 3, "httpStatusLineParse: Invalid HTTP identifier. Detected ICY protocol istead.");
-        sline->protocol = PROTO_ICY;
+        sline->protocol = AnyP::PROTO_ICY;
         start += protoPrefix.size();
     } else if (protoPrefix.caseCmp(start, protoPrefix.size()) == 0) {
 
@@ -36,10 +36,9 @@
 class Packer;
 class String;
 
-/* for http_status and protocol_t */
-#include "enums.h"
-
+#include "HttpStatusCode.h"
 #include "HttpVersion.h"
+#include "anyp/ProtocolType.h"
 #include "SquidString.h"
 
 /**
@@ -54,10 +53,10 @@ class HttpStatusLine
 
     /**
      * By rights protocol name should be a constant "HTTP", with no need for this field to exist.
-     * However there are protocols which violate HTTP by sending their wn custom formats
-     * back with other protocol names (ICY streaming format being the current major problem)
+     * However there are protocols which violate HTTP by sending their own custom formats
+     * back with other protocol names (ICY streaming format being the current major problem).
      */
-    protocol_t protocol;
+    AnyP::ProtocolType protocol;
 
     HttpVersion version;     ///< breakdown of protocol version labels: 0.9 1.0 1.1
     http_status status;      ///< status code. ie 200 404
@@ -30,8 +30,8 @@ LOADABLE_MODULES_SOURCES = \
 	LoadableModules.h \
 	LoadableModules.cc
 
-SUBDIRS	= base comm eui acl fs repl
-DIST_SUBDIRS = base comm eui acl fs repl
+SUBDIRS	= base anyp comm eui acl fs repl
+DIST_SUBDIRS = base anyp comm eui acl fs repl
 
 if ENABLE_AUTH
 SUBDIRS += auth
@@ -554,6 +554,7 @@ nodist_squid_SOURCES = \
 
 squid_LDADD = \
 	$(COMMON_LIBS) \
+	anyp/libanyp.la \
 	comm/libcomm.la \
 	eui/libeui.la \
 	icmp/libicmp.la icmp/libicmp-core.la \
@@ -1044,6 +1045,7 @@ nodist_tests_testAuth_SOURCES = \
 
 tests_testAuth_LDADD= \
 	$(COMMON_LIBS) \
+	anyp/libanyp.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
@@ -1310,6 +1312,7 @@ tests_testCacheManager_LDADD = \
 	$(ADAPTATION_LIBS) \
 	$(ESI_LIBS) \
 	$(SSL_LIBS) \
+	anyp/libanyp.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
@@ -1341,6 +1344,7 @@ nodist_tests_testDiskIO_SOURCES= \
 	SquidMath.h \
 	swap_log_op.cc
 tests_testDiskIO_LDADD = \
+	anyp/libanyp.la \
 	SquidConfig.o \
 	CommCalls.o \
 	DnsLookupDetails.o \
@@ -1513,6 +1517,7 @@ nodist_tests_testEvent_SOURCES = \
 	$(BUILT_SOURCES)
 tests_testEvent_LDADD = \
 	$(COMMON_LIBS) \
+	anyp/libanyp.la \
 	$(SNMP_LIBS) \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	comm/libcomm.la \
@@ -1674,6 +1679,7 @@ nodist_tests_testEventLoop_SOURCES = \
 	$(BUILT_SOURCES)
 tests_testEventLoop_LDADD = \
 	$(COMMON_LIBS) \
+	anyp/libanyp.la \
 	$(SNMP_LIBS) \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	comm/libcomm.la \
@@ -1830,6 +1836,7 @@ nodist_tests_test_http_range_SOURCES = \
 	$(BUILT_SOURCES)
 tests_test_http_range_LDADD = \
 	$(COMMON_LIBS) \
+	anyp/libanyp.la \
 	$(SNMP_LIBS) \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	comm/libcomm.la \
@@ -1991,6 +1998,7 @@ nodist_tests_testHttpRequest_SOURCES = \
 	$(BUILT_SOURCES)
 tests_testHttpRequest_LDADD = \
 	$(COMMON_LIBS) \
+	anyp/libanyp.la \
 	$(SNMP_LIBS) \
 	icmp/libicmp.la icmp/libicmp-core.la \
 	comm/libcomm.la \
@@ -2089,6 +2097,7 @@ nodist_tests_testStore_SOURCES= \
 
 tests_testStore_LDADD= \
 	$(COMMON_LIBS) \
+	anyp/libanyp.la \
 	$(top_builddir)/lib/libmisccontainers.la \
 	$(top_builddir)/lib/libmiscencoding.la \
 	$(top_builddir)/lib/libmiscutil.la \
@@ -2191,6 +2200,7 @@ nodist_tests_testUfs_SOURCES = \
 	SquidMath.h \
 	swap_log_op.cc
 tests_testUfs_LDADD = \
+	anyp/libanyp.la \
 	CommCalls.o \
 	DnsLookupDetails.o \
 	$(COMMON_LIBS) \
@@ -2405,6 +2415,7 @@ tests_testURL_SOURCES = \
 nodist_tests_testURL_SOURCES = \
 	$(BUILT_SOURCES)
 tests_testURL_LDADD = \
+	anyp/libanyp.la \
 	$(COMMON_LIBS) \
 	$(SNMP_LIBS) \
 	icmp/libicmp.la icmp/libicmp-core.la \
@@ -875,7 +875,7 @@ ServerStateData::adaptOrFinalizeReply()
     // The callback can be called with a NULL service if adaptation is off.
     adaptationAccessCheckPending = Adaptation::AccessCheck::Start(
                                        Adaptation::methodRespmod, Adaptation::pointPreCache,
-                                       request, virginReply(), adaptationAclCheckDoneWrapper, this);
+                                       originalRequest(), virginReply(), adaptationAclCheckDoneWrapper, this);
     debugs(11,5, HERE << "adaptationAccessCheckPending=" << adaptationAccessCheckPending);
     if (adaptationAccessCheckPending)
         return;
@@ -33,25 +33,24 @@
  *
  */
 
-#include "squid.h"
+#include "config.h"
 #include "URLScheme.h"
 #include "wordlist.h"
 
-const char *ProtocolStr[] = {
-    "NONE",
-    "http",
-    "ftp",
-    "gopher",
-    "wais",
-    "cache_object",
-    "icp",
-#if USE_HTCP
-    "htcp",
-#endif
-    "urn",
-    "whois",
-    "internal",
-    "https",
-    "icy",
-    "TOTAL"
-};
+char const *
+URLScheme::const_str() const
+{
+    if (theScheme_ == AnyP::PROTO_UNKNOWN)
+        return "(unknown)";
+
+    static char out[BUFSIZ];
+    int p = 0;
+
+    if (theScheme_ > AnyP::PROTO_NONE && theScheme_ < AnyP::PROTO_MAX) {
+        const char *in = AnyP::ProtocolType_str[theScheme_];
+        for (; p < (BUFSIZ-1) && in[p] != '\0'; ++p)
+            out[p] = xtolower(in[p]);
+    }
+    out[p] = '\0';
+    return out;
+}
@@ -34,40 +34,36 @@
 #ifndef SQUID_URLSCHEME_H
 #define SQUID_URLSCHEME_H
 
-/* For the definition of NULL and protocol_t */
-#include "squid.h"
-
+#include "anyp/ProtocolType.h"
+#if HAVE_IOSFWD
 #include <iosfwd>
+#endif
 
-extern const char *ProtocolStr[];
-
-/* This class represents a URL Scheme such as HTTPS, HTTP, WAIS etc.
+/** This class represents a URL Scheme such as HTTPS, HTTP, WAIS etc.
  * It does not represent the PROTOCOL that such schemes refer to.
  */
-
 class URLScheme
 {
 
 public:
-    URLScheme() : theScheme(PROTO_NONE) {}
+    URLScheme() : theScheme_(AnyP::PROTO_NONE) {}
+    URLScheme(AnyP::ProtocolType const aScheme) : theScheme_(aScheme) {}
+    ~URLScheme() {}
 
-    URLScheme(protocol_t const aScheme) : theScheme(aScheme) {}
+    operator AnyP::ProtocolType() const { return theScheme_; }
 
-    operator protocol_t() const { return theScheme; }
+    bool operator != (AnyP::ProtocolType const & aProtocol) const { return theScheme_ != aProtocol; }
 
-    bool operator != (protocol_t const & aProtocol) const { return theScheme != aProtocol;}
-
-    /* Get a char string representation of the scheme. */
-    char const *const_str() const { return ProtocolStr[theScheme]; }
+    /** Get a char string representation of the scheme.
+     * An upper bound length of BUFSIZ bytes converted. Remainder will be truncated.
+     * The result of this call will remain usable only until any subsequest call
+     * and must be copied if persistence is needed.
+     */
+    char const *const_str() const;
 
 private:
-    /* This is a typecode for now - TODO make the varying methods virtual
-     * Doing that without doubling the storage size will require having
-     * something like a flyweight. perhaps the strategy pattern is appropiate:
-     * one strategy per scheme, and an object that is nothing but a pointer
-     * into the registry of schemes.
-     */
-    protocol_t theScheme;
+    /// This is a typecode pointer into the enum/registry of protocols handled.
+    AnyP::ProtocolType theScheme_;
 };
 
 inline std::ostream &
@@ -74,8 +74,8 @@ splaystrcmp (T&l, T&r)
 static int
 aclHostDomainCompare( char *const &a, char * const &b)
 {
-    const char *h = (const char *)a;
-    const char *d = (const char *)b;
+    const char *h = static_cast<const char *>(a);
+    const char *d = static_cast<const char *>(b);
     return matchDomainName(h, d);
 }
 
@@ -86,22 +86,29 @@ template<class T>
 int
 aclDomainCompare(T const &a, T const &b)
 {
-    char * const d1 = (char *const)b;
-    char * const d2 = (char *const )a;
+    char * const d1 = static_cast<char *>(b);
+    char * const d2 = static_cast<char *>(a);
     int ret;
     ret = aclHostDomainCompare(d1, d2);
 
     if (ret != 0) {
         char *const d3 = d2;
         char *const d4 = d1;
         ret = aclHostDomainCompare(d3, d4);
-    }
-
-    /* FIXME this warning may display d1 and d2 when it should display d3 and d4 */
-    if (ret == 0) {
-        debugs(28, 0, "WARNING: '" << d1 << "' is a subdomain of '" << d2 << "'");
-        debugs(28, 0, "WARNING: because of this '" << (char *) a << "' is ignored to keep splay tree searching predictable");
-        debugs(28, 0, "WARNING: You should probably remove '" << d1 << "' from the ACL named '" << AclMatchedName << "'");
+        if (ret == 0) {
+            // When a.example.com comes after .example.com in an ACL
+            // sub-domain is ignored. That is okay. Just important
+            debugs(28, DBG_IMPORTANT, "WARNING: '" << d3 << "' is a subdomain of '" << d4 << "'");
+            debugs(28, DBG_IMPORTANT, "WARNING: because of this '" << d3 << "' is ignored to keep splay tree searching predictable");
+            debugs(28, DBG_IMPORTANT, "WARNING: You should remove '" << (*d3=='.'?d4:d3) << "' from the ACL named '" << AclMatchedName << "'");
+        }
+    } else if (ret == 0) {
+        // When a.example.com comes before .example.com in an ACL
+        // discarding the wildcard is critically bad.
+        debugs(28, DBG_CRITICAL, "ERROR: '" << d1 << "' is a subdomain of '" << d2 << "'");
+        debugs(28, DBG_CRITICAL, "ERROR: because of this '" << d2 << "' is ignored to keep splay tree searching predictable");
+        debugs(28, DBG_CRITICAL, "ERROR: You should remove '" << (*d1=='.'?d2:d1) << "' from the ACL named '" << AclMatchedName << "'");
+        self_destruct();
     }
 
     return ret;
@@ -41,7 +41,7 @@
 
 /* explicit template instantiation required for some systems */
 
-template class ACLStrategised<protocol_t>;
+template class ACLStrategised<AnyP::ProtocolType>;
 
 
 
@@ -35,10 +35,12 @@
 
 #ifndef SQUID_ACLPROTOCOL_H
 #define SQUID_ACLPROTOCOL_H
+
 #include "acl/Strategy.h"
 #include "acl/Strategised.h"
+#include "anyp/ProtocolType.h"
 
-class ACLProtocolStrategy : public ACLStrategy<protocol_t>
+class ACLProtocolStrategy : public ACLStrategy<AnyP::ProtocolType>
 {
 
 public:
@@ -63,7 +65,7 @@ class ACLProtocol
 
 private:
     static ACL::Prototype RegistryProtoype;
-    static ACLStrategised<protocol_t> RegistryEntry_;
+    static ACLStrategised<AnyP::ProtocolType> RegistryEntry_;
 };
 
 #endif /* SQUID_ACLPROTOCOL_H */
@@ -55,25 +55,25 @@ ACLProtocolData::~ACLProtocolData()
 }
 
 bool
-ACLProtocolData::match(protocol_t toFind)
+ACLProtocolData::match(AnyP::ProtocolType toFind)
 {
     return values->findAndTune (toFind);
 }
 
 /* explicit instantiation required for some systems */
 
 /// \cond AUTODOCS-IGNORE
-template cbdata_type CbDataList<protocol_t>::CBDATA_CbDataList;
+template cbdata_type CbDataList<AnyP::ProtocolType>::CBDATA_CbDataList;
 /// \endcond
 
 wordlist *
 ACLProtocolData::dump()
 {
     wordlist *W = NULL;
-    CbDataList<protocol_t> *data = values;
+    CbDataList<AnyP::ProtocolType> *data = values;
 
     while (data != NULL) {
-        wordlistAdd(&W, ProtocolStr[data->element]);
+        wordlistAdd(&W, AnyP::ProtocolType_str[data->element]);
         data = data->next;
     }
 
@@ -83,14 +83,21 @@ ACLProtocolData::dump()
 void
 ACLProtocolData::parse()
 {
-    CbDataList<protocol_t> **Tail;
+    CbDataList<AnyP::ProtocolType> **Tail;
     char *t = NULL;
 
     for (Tail = &values; *Tail; Tail = &((*Tail)->next));
     while ((t = strtokFile())) {
-        CbDataList<protocol_t> *q = new CbDataList<protocol_t> (urlParseProtocol(t));
-        *(Tail) = q;
-        Tail = &q->next;
+        for (int p = AnyP::PROTO_NONE; p < AnyP::PROTO_UNKNOWN; ++p) {
+            if (strcasecmp(t, AnyP::ProtocolType_str[p]) == 0) {
+                CbDataList<AnyP::ProtocolType> *q = new CbDataList<AnyP::ProtocolType>(static_cast<AnyP::ProtocolType>(p));
+                *(Tail) = q;
+                Tail = &q->next;
+                break;
+            } else {
+                debugs(28, DBG_IMPORTANT, "WARNING: Ignoring unknown protocol '" << t << "' in the ACL named '" << AclMatchedName << "'");
+            }
+        }
     }
 }
 
@@ -100,7 +107,7 @@ ACLProtocolData::empty() const
     return values == NULL;
 }
 
-ACLData<protocol_t> *
+ACLData<AnyP::ProtocolType> *
 ACLProtocolData::clone() const
 {
     /* Splay trees don't clone yet. */
@@ -35,11 +35,13 @@
 
 #ifndef SQUID_ACLPROTOCOLDATA_H
 #define SQUID_ACLPROTOCOLDATA_H
+
 #include "acl/Acl.h"
 #include "acl/Data.h"
+#include "anyp/ProtocolType.h"
 #include "CbDataList.h"
 
-class ACLProtocolData : public ACLData<protocol_t>
+class ACLProtocolData : public ACLData<AnyP::ProtocolType>
 {
 
 public:
@@ -49,13 +51,13 @@ class ACLProtocolData : public ACLData<protocol_t>
     ACLProtocolData(ACLProtocolData const &);
     ACLProtocolData &operator= (ACLProtocolData const &);
     virtual ~ACLProtocolData();
-    bool match(protocol_t);
+    bool match(AnyP::ProtocolType);
     wordlist *dump();
     void parse();
     bool empty() const;
-    virtual ACLData<protocol_t> *clone() const;
+    virtual ACLData<AnyP::ProtocolType> *clone() const;
 
-    CbDataList<protocol_t> *values;
+    CbDataList<AnyP::ProtocolType> *values;
 };
 
 MEMPROXY_CLASS_INLINE(ACLProtocolData);
@@ -18,6 +18,9 @@ const libecap::Name Adaptation::Ecap::protocolIcp("ICP", libecap::Name::NextId()
 #if USE_HTCP
 const libecap::Name Adaptation::Ecap::protocolHtcp("Htcp", libecap::Name::NextId());
 #endif
+const libecap::Name Adaptation::Ecap::protocolIcy("ICY", libecap::Name::NextId());
+const libecap::Name Adaptation::Ecap::protocolUnknown("_unknown_", libecap::Name::NextId());
+
 const libecap::Name Adaptation::Ecap::metaBypassable("bypassable", libecap::Name::NextId());
 
 /// the host application (i.e., Squid) wrapper registered with libecap
@@ -35,19 +38,21 @@ Adaptation::Ecap::Host::Host()
     // TODO: libecap::headerXClientIp.assignHostId(HDR_X_CLIENT_IP);
     // TODO: libecap::headerXServerIp.assignHostId(HDR_X_SERVER_IP);
 
-    libecap::protocolHttp.assignHostId(PROTO_HTTP);
-    libecap::protocolHttps.assignHostId(PROTO_HTTPS);
-    libecap::protocolFtp.assignHostId(PROTO_FTP);
-    libecap::protocolGopher.assignHostId(PROTO_GOPHER);
-    libecap::protocolWais.assignHostId(PROTO_WAIS);
-    libecap::protocolUrn.assignHostId(PROTO_URN);
-    libecap::protocolWhois.assignHostId(PROTO_WHOIS);
-    protocolInternal.assignHostId(PROTO_INTERNAL);
-    protocolCacheObj.assignHostId(PROTO_CACHEOBJ);
-    protocolIcp.assignHostId(PROTO_ICP);
+    libecap::protocolHttp.assignHostId(AnyP::PROTO_HTTP);
+    libecap::protocolHttps.assignHostId(AnyP::PROTO_HTTPS);
+    libecap::protocolFtp.assignHostId(AnyP::PROTO_FTP);
+    libecap::protocolGopher.assignHostId(AnyP::PROTO_GOPHER);
+    libecap::protocolWais.assignHostId(AnyP::PROTO_WAIS);
+    libecap::protocolUrn.assignHostId(AnyP::PROTO_URN);
+    libecap::protocolWhois.assignHostId(AnyP::PROTO_WHOIS);
+    protocolInternal.assignHostId(AnyP::PROTO_INTERNAL);
+    protocolCacheObj.assignHostId(AnyP::PROTO_CACHE_OBJECT);
+    protocolIcp.assignHostId(AnyP::PROTO_ICP);
 #if USE_HTCP
-    protocolHtcp.assignHostId(PROTO_HTCP);
+    protocolHtcp.assignHostId(AnyP::PROTO_HTCP);
 #endif
+    protocolIcy.assignHostId(AnyP::PROTO_ICY);
+    protocolUnknown.assignHostId(AnyP::PROTO_UNKNOWN);
 
     // allows adapter to safely ignore this in adapter::Service::configure()
     metaBypassable.assignHostId(1);
@@ -44,6 +44,8 @@ class Host : public libecap::host::Host
 extern const libecap::Name protocolInternal;
 extern const libecap::Name protocolCacheObj;
 extern const libecap::Name protocolIcp;
+extern const libecap::Name protocolIcy;
+extern const libecap::Name protocolUnknown;
 #if USE_HTCP
 extern const libecap::Name protocolHtcp;
 #endif
@@ -136,38 +136,40 @@ Adaptation::Ecap::FirstLineRep::protocol() const
 {
     // TODO: optimize?
     switch (theMessage.protocol) {
-    case PROTO_HTTP:
+    case AnyP::PROTO_HTTP:
         return libecap::protocolHttp;
-    case PROTO_HTTPS:
+    case AnyP::PROTO_HTTPS:
         return libecap::protocolHttps;
-    case PROTO_FTP:
+    case AnyP::PROTO_FTP:
         return libecap::protocolFtp;
-    case PROTO_GOPHER:
+    case AnyP::PROTO_GOPHER:
         return libecap::protocolGopher;
-    case PROTO_WAIS:
+    case AnyP::PROTO_WAIS:
         return libecap::protocolWais;
-    case PROTO_WHOIS:
+    case AnyP::PROTO_WHOIS:
         return libecap::protocolWhois;
-    case PROTO_URN:
+    case AnyP::PROTO_URN:
         return libecap::protocolUrn;
-    case PROTO_ICP:
+    case AnyP::PROTO_ICP:
         return protocolIcp;
 #if USE_HTCP
-    case PROTO_HTCP:
+    case AnyP::PROTO_HTCP:
         return protocolHtcp;
 #endif
-    case PROTO_CACHEOBJ:
+    case AnyP::PROTO_CACHE_OBJECT:
         return protocolCacheObj;
-    case PROTO_INTERNAL:
+    case AnyP::PROTO_INTERNAL:
         return protocolInternal;
-    case PROTO_ICY:
-        return Name();
-    case PROTO_NONE:
+    case AnyP::PROTO_ICY:
+        return protocolIcy;
+    case AnyP::PROTO_UNKNOWN:
+        return protocolUnknown; // until we remember the protocol image
+    case AnyP::PROTO_NONE:
         return Name();
 
-    case PROTO_MAX:
+    case AnyP::PROTO_MAX:
         break; // should not happen
-        // no default to catch PROTO_ additions
+        // no default to catch AnyP::PROTO_ additions
     }
     Must(false); // not reached
     return Name();
@@ -180,12 +182,12 @@ Adaptation::Ecap::FirstLineRep::protocol(const Name &p)
     theMessage.protocol = TranslateProtocolId(p);
 }
 
-protocol_t
+AnyP::ProtocolType
 Adaptation::Ecap::FirstLineRep::TranslateProtocolId(const Name &name)
 {
     if (name.assignedHostId())
-        return static_cast<protocol_t>(name.hostId());
-    return PROTO_NONE; // no PROTO_OTHER
+        return static_cast<AnyP::ProtocolType>(name.hostId());
+    return AnyP::PROTO_UNKNOWN;
 }
 
 
@@ -211,8 +213,10 @@ Adaptation::Ecap::RequestLineRep::uri(const Area &aUri)
 Adaptation::Ecap::RequestLineRep::Area
 Adaptation::Ecap::RequestLineRep::uri() const
 {
-    return Area::FromTempBuffer(theMessage.urlpath.rawBuf(),
-                                theMessage.urlpath.size());
+    const char *fullUrl = urlCanonical(&theMessage);
+    Must(fullUrl);
+    // optimize: avoid copying by having an Area::Detail that locks theMessage
+    return Area::FromTempBuffer(fullUrl, strlen(fullUrl));
 }
 
 void
@@ -10,6 +10,7 @@
 #include "BodyPipe.h"
 #include "adaptation/forward.h"
 #include "adaptation/Message.h"
+#include "anyp/ProtocolType.h"
 #include <libecap/common/message.h>
 #include <libecap/common/header.h>
 #include <libecap/common/body.h>
@@ -70,7 +71,7 @@ class FirstLineRep
     void protocol(const Name &aProtocol);
 
 protected:
-    static protocol_t TranslateProtocolId(const Name &name);
+    static AnyP::ProtocolType TranslateProtocolId(const Name &name);
 
 private:
     HttpMsg &theMessage; // the message which first line is being translated
@@ -1421,13 +1421,15 @@ void Adaptation::Icap::ModXact::makeAllowHeader(MemBuf &buf)
 
 void Adaptation::Icap::ModXact::makeUsernameHeader(const HttpRequest *request, MemBuf &buf)
 {
+#if USE_AUTH
     if (request->auth_user_request != NULL) {
         char const *name = request->auth_user_request->username();
         if (name) {
             const char *value = TheConfig.client_username_encode ? base64_encode(name) : name;
             buf.Printf("%s: %s\r\n", TheConfig.client_username_header, value);
         }
     }
+#endif
 }
 
 void Adaptation::Icap::ModXact::encapsulateHead(MemBuf &icapBuf, const char *section, MemBuf &httpBuf, const HttpMsg *head)
@@ -0,0 +1,13 @@
+include $(top_srcdir)/src/Common.am
+include $(top_srcdir)/src/TestHeaders.am
+
+noinst_LTLIBRARIES = libanyp.la
+
+libanyp_la_SOURCES = \
+	ProtocolType.cc \
+	ProtocolType.h
+
+ProtocolType.cc: ProtocolType.h $(top_srcdir)/src/mk-string-arrays.awk
+	($(AWK) -f $(top_srcdir)/src/mk-string-arrays.awk <$(srcdir)/ProtocolType.h | sed -e 's%PROTO_%%' >$@) || ($(RM) -f $@ && exit 1)
+
+CLEANFILES += ProtocolType.cc
@@ -0,0 +1,54 @@
+#ifndef _SQUID_SRC_ANYP_PROTOCOLTYPE_H
+#define _SQUID_SRC_ANYP_PROTOCOLTYPE_H
+
+#if HAVE_OSTREAM
+#include <ostream>
+#endif
+
+namespace AnyP
+{
+
+/**
+ * List of all protocols known and supported.
+ * This is a combined list. It is used as type-codes where needed and
+ * the AnyP::ProtocolType_Str array of strings may be used for display
+ */
+typedef enum {
+    PROTO_NONE = 0,
+    PROTO_HTTP,
+    PROTO_FTP,
+    PROTO_HTTPS,
+    PROTO_GOPHER,
+    PROTO_WAIS,
+    PROTO_CACHE_OBJECT,
+    PROTO_ICP,
+#if USE_HTCP
+    PROTO_HTCP,
+#endif
+    PROTO_URN,
+    PROTO_WHOIS,
+    PROTO_INTERNAL,
+    PROTO_ICY,
+    PROTO_UNKNOWN,
+    PROTO_MAX
+} ProtocolType;
+
+extern const char *ProtocolType_str[];
+
+/** Display the registered Protocol Type (in upper case).
+ *  If the protocol is not a registered AnyP::ProtocolType nothing will be displayed.
+ * The caller is responsible for any alternative text.
+ */
+inline std::ostream &
+operator <<(std::ostream &os, ProtocolType const &p)
+{
+    if (PROTO_NONE <= p && p < PROTO_MAX)
+        os << ProtocolType_str[p];
+    else
+        os << static_cast<int>(p);
+    return os;
+}
+
+} // namespace AnyP
+
+#endif /* _SQUID_SRC_ANYP_PROTOCOLTYPE_H */
@@ -443,7 +443,7 @@ authDigestNonceIsStale(digest_nonce_h * nonce)
  * \retval  0    the digest is not stale yet
  * \retval -1    the digest will be stale on the next request
  */
-const int
+int
 authDigestNonceLastRequest(digest_nonce_h * nonce)
 {
     if (!nonce)
@@ -73,7 +73,7 @@ struct _digest_nonce_h : public hash_link {
 extern void authDigestNonceUnlink(digest_nonce_h * nonce);
 extern int authDigestNonceIsValid(digest_nonce_h * nonce, char nc[9]);
 extern const char *authenticateDigestNonceNonceb64(const digest_nonce_h * nonce);
-extern const int authDigestNonceLastRequest(digest_nonce_h * nonce);
+extern int authDigestNonceLastRequest(digest_nonce_h * nonce);
 
 /* configuration runtime data */
 
@@ -5,9 +5,6 @@
 
 #include <exception>
 
-#if __GNUC__
-__attribute__((unused))
-#endif
 static unsigned int FileNameHashCached(const char *fname);
 
 // simple exception to report custom errors
@@ -63,6 +60,12 @@ FileNameHashCached(const char *fname)
     return lastHash;
 }
 
+///  Avoids "defined but not used" warnings for FileNameHashCached
+class FileNameHashCacheUser
+{
+    bool use(void *ptr=NULL) { return ptr != (void*)&FileNameHashCached; }
+};
+
 #if !defined(TexcHere)
 #    define TexcHere(msg) TextException((msg), __FILE__, __LINE__, \
                                          (FileNameHashCached(__FILE__)<<14) | (__LINE__ & 0x3FFF))
@@ -48,6 +48,7 @@
 #include "mgr/Command.h"
 #include "mgr/Forwarder.h"
 #include "mgr/FunAction.h"
+#include "mgr/QueryParams.h"
 #include "protos.h" /* rotate_logs() */
 #include "SquidTime.h"
 #include "Store.h"
@@ -176,7 +177,21 @@ CacheManager::ParseUrl(const char *url)
     LOCAL_ARRAY(char, host, MAX_URL);
     LOCAL_ARRAY(char, request, MAX_URL);
     LOCAL_ARRAY(char, password, MAX_URL);
-    t = sscanf(url, "cache_object://%[^/]/%[^@]@%s", host, request, password);
+    LOCAL_ARRAY(char, params, MAX_URL);
+    host[0] = 0;
+    request[0] = 0;
+    password[0] = 0;
+    params[0] = 0;
+    int pos = -1;
+    int len = strlen(url);
+    Must(len > 0);
+    t = sscanf(url, "cache_object://%[^/]/%[^@?]%n@%[^?]?%s", host, request, &pos, password, params);
+
+    if (pos >0 && url[pos] == '?') {
+        ++pos;
+        if (pos < len)
+            xstrncpy(params, url + pos, sizeof(params));
+    }
 
     if (t < 2)
         xstrncpy(request, "menu", MAX_URL);
@@ -204,10 +219,12 @@ CacheManager::ParseUrl(const char *url)
     }
 
     Mgr::Command::Pointer cmd = new Mgr::Command;
+    if (!Mgr::QueryParams::Parse(params, cmd->params.queryParams))
+        return NULL;
     cmd->profile = profile;
     cmd->params.httpUri = url;
     cmd->params.userName = String();
-    cmd->params.password = t == 3 ? String(password) : String();
+    cmd->params.password = password;
     cmd->params.actionName = request;
     return cmd;
 }
@@ -143,7 +143,7 @@ ClientInfo * clientdbGetInfo(const Ip::Address &addr)
 }
 #endif
 void
-clientdbUpdate(const Ip::Address &addr, log_type ltype, protocol_t p, size_t size)
+clientdbUpdate(const Ip::Address &addr, log_type ltype, AnyP::ProtocolType p, size_t size)
 {
     char key[MAX_IPSTRLEN];
     ClientInfo *c;
@@ -161,14 +161,14 @@ clientdbUpdate(const Ip::Address &addr, log_type ltype, protocol_t p, size_t siz
     if (c == NULL)
         debug_trap("clientdbUpdate: Failed to add entry");
 
-    if (p == PROTO_HTTP) {
+    if (p == AnyP::PROTO_HTTP) {
         c->Http.n_requests++;
         c->Http.result_hist[ltype]++;
         kb_incr(&c->Http.kbytes_out, size);
 
         if (logTypeIsATcpHit(ltype))
             kb_incr(&c->Http.hit_kbytes_out, size);
-    } else if (p == PROTO_ICP) {
+    } else if (p == AnyP::PROTO_ICP) {
         c->Icp.n_requests++;
         c->Icp.result_hist[ltype]++;
         kb_incr(&c->Icp.kbytes_out, size);
@@ -678,7 +678,7 @@ ClientHttpRequest::logRequest()
             updateCounters();
 
             if (getConn() != NULL)
-                clientdbUpdate(getConn()->peer, logType, PROTO_HTTP, out.size);
+                clientdbUpdate(getConn()->peer, logType, AnyP::PROTO_HTTP, out.size);
         }
 
         delete checklist;
@@ -1089,11 +1089,6 @@ ClientSocketContext::packRange(StoreIOBuffer const &source, MemBuf * mb)
 
         }
 
-        /*
-         * paranoid check
-         */
-        assert((available.size() >= 0 && i->debt() >= 0) || i->debt() == -1);
-
         if (!canPackMoreRanges()) {
             debugs(33, 3, "clientPackRange: Returning because !canPackMoreRanges.");
 
@@ -2020,21 +2015,21 @@ prepareTransparentURL(ConnStateData * conn, ClientHttpRequest *http, char *url,
         return; /* already in good shape */
 
     /* BUG: Squid cannot deal with '*' URLs (RFC2616 5.1.2) */
+    // BUG 2976: Squid only accepts intercepted HTTP.
 
     if ((host = mime_get_header(req_hdr, "Host")) != NULL) {
         int url_sz = strlen(url) + 32 + Config.appendDomainLen +
                      strlen(host);
         http->uri = (char *)xcalloc(url_sz, 1);
-        snprintf(http->uri, url_sz, "%s://%s%s",
-                 conn->port->protocol, host, url);
+        snprintf(http->uri, url_sz, "http://%s%s", /*conn->port->protocol,*/ host, url);
         debugs(33, 5, "TRANSPARENT HOST REWRITE: '" << http->uri <<"'");
     } else {
         /* Put the local socket IP address as the hostname.  */
         int url_sz = strlen(url) + 32 + Config.appendDomainLen;
         http->uri = (char *)xcalloc(url_sz, 1);
         http->getConn()->me.ToHostname(ipbuf,MAX_IPSTRLEN),
-        snprintf(http->uri, url_sz, "%s://%s:%d%s",
-                 http->getConn()->port->protocol,
+        snprintf(http->uri, url_sz, "http://%s:%d%s",
+                 // http->getConn()->port->protocol,
                  ipbuf, http->getConn()->me.GetPort(), url);
         debugs(33, 5, "TRANSPARENT REWRITE: '" << http->uri << "'");
     }
@@ -2489,7 +2484,7 @@ clientProcessRequest(ConnStateData *conn, HttpParser *hp, ClientSocketContext *c
     }
 
     if (http->flags.internal) {
-        request->protocol = PROTO_HTTP;
+        request->protocol = AnyP::PROTO_HTTP;
         request->login[0] = '\0';
     }
 
@@ -551,7 +551,7 @@ clientReplyContext::cacheHit(StoreIOBuffer result)
              */
             http->logType = LOG_TCP_CLIENT_REFRESH_MISS;
             processMiss();
-        } else if (r->protocol == PROTO_HTTP) {
+        } else if (r->protocol == AnyP::PROTO_HTTP) {
             /*
              * Object needs to be revalidated
              * XXX This could apply to FTP as well, if Last-Modified is known.
@@ -658,7 +658,7 @@ clientReplyContext::processMiss()
 
         /** Check for internal requests. Update Protocol info if so. */
         if (http->flags.internal)
-            r->protocol = PROTO_INTERNAL;
+            r->protocol = AnyP::PROTO_INTERNAL;
 
         r->clientConnection = http->getConn();
 
@@ -1504,7 +1504,7 @@ clientReplyContext::cloneReply()
 
     reply = HTTPMSGLOCK(rep);
 
-    if (reply->sline.protocol == PROTO_HTTP) {
+    if (reply->sline.protocol == AnyP::PROTO_HTTP) {
         /* RFC 2616 requires us to advertise our 1.1 version (but only on real HTTP traffic) */
         reply->sline.version = HttpVersion(1,1);
     }
@@ -2148,7 +2148,7 @@ clientReplyContext::createStoreEntry(const HttpRequestMethod& m, request_flags r
      */
 
     if (http->request == NULL)
-        http->request = HTTPMSGLOCK(new HttpRequest(m, PROTO_NONE, null_string));
+        http->request = HTTPMSGLOCK(new HttpRequest(m, AnyP::PROTO_NONE, null_string));
 
     StoreEntry *e = storeCreateEntry(http->uri, http->log_uri, reqFlags, m);
 
@@ -763,19 +763,18 @@ clientHierarchical(ClientHttpRequest * http)
     if (request->flags.loopdetect)
         return 0;
 
-    if (request->protocol == PROTO_HTTP)
+    if (request->protocol == AnyP::PROTO_HTTP)
         return httpCachable(method);
 
-    if (request->protocol == PROTO_GOPHER)
+    if (request->protocol == AnyP::PROTO_GOPHER)
         return gopherCachable(request);
 
-    if (request->protocol == PROTO_CACHEOBJ)
+    if (request->protocol == AnyP::PROTO_CACHE_OBJECT)
         return 0;
 
     return 1;
 }
 
-
 static void
 clientCheckPinning(ClientHttpRequest * http)
 {
@@ -124,7 +124,7 @@ struct _idns_query {
     char buf[RESOLV_BUFSZ];
     char name[NS_MAXDNAME + 1];
     char orig[NS_MAXDNAME + 1];
-    size_t sz;
+    ssize_t sz;
     unsigned short msg_id; /// random query ID sent to server; changes with every query sent
     InstanceId<idns_query> xact_id; /// identifies our "transaction", stays constant when query is retried
 
@@ -1145,6 +1145,14 @@ idnsGrokReply(const char *buf, size_t sz, int from_ns)
                 // see EDNS notes at top of file why this sends 0
                 q->sz = rfc3596BuildAQuery(q->name, q->buf, sizeof(q->buf), 0, &q->query, 0);
             }
+
+            if (q->sz < 0) {
+                /* problem with query data -- query not sent */
+                idnsCallback(static_cast<idns_query *>(q->callback_data), NULL, 0, "Internal error");
+                cbdataFree(q);
+                return;
+            }
+
             idnsCacheQuery(q);
             idnsSendQuery(q);
             return;
@@ -1181,6 +1189,14 @@ idnsGrokReply(const char *buf, size_t sz, int from_ns)
         // see EDNS notes at top of file why this sends 0
         q->sz = rfc3596BuildAQuery(q->name, q->buf, sizeof(q->buf), 0, &q->query, 0);
         q->need_A = false;
+
+        if (q->sz < 0) {
+            /* problem with query data -- query not sent */
+            idnsCallback(static_cast<idns_query *>(q->callback_data), NULL, 0, "Internal error");
+            cbdataFree(q);
+            return;
+        }
+
         idnsCacheQuery(q);
         idnsSendQuery(q);
         return;
@@ -1659,11 +1675,9 @@ idnsALookup(const char *name, IDNSCB * callback, void *data)
            ", id = 0x" << std::hex << q->msg_id);
 
     q->callback = callback;
-
     q->callback_data = cbdataReference(data);
 
     idnsCacheQuery(q);
-
     idnsSendQuery(q);
 }
 
@@ -1711,11 +1725,9 @@ idnsPTRLookup(const Ip::Address &addr, IDNSCB * callback, void *data)
            ", id = 0x" << std::hex << q->msg_id);
 
     q->callback = callback;
-
     q->callback_data = cbdataReference(data);
 
     idnsCacheQuery(q);
-
     idnsSendQuery(q);
 }
 
@@ -143,25 +143,6 @@ typedef enum {
     STORE_DISK_CLIENT
 } store_client_t;
 
-typedef enum {
-    PROTO_NONE,
-    PROTO_HTTP,
-    PROTO_FTP,
-    PROTO_GOPHER,
-    PROTO_WAIS,
-    PROTO_CACHEOBJ,
-    PROTO_ICP,
-#if USE_HTCP
-    PROTO_HTCP,
-#endif
-    PROTO_URN,
-    PROTO_WHOIS,
-    PROTO_INTERNAL,
-    PROTO_HTTPS,
-    PROTO_ICY,
-    PROTO_MAX
-} protocol_t;
-
 /*
  * These are for StoreEntry->flag, which is defined as a SHORT
  *
@@ -808,7 +808,7 @@ ErrorState::Convert(char token, bool building_deny_info_url, bool allowRecursion
 
     case 'P':
         if (request) {
-            p = ProtocolStr[request->protocol];
+            p = AnyP::ProtocolType_str[request->protocol];
         } else if (!building_deny_info_url) {
             p = "[unknown protocol]";
         }
@@ -954,7 +954,7 @@ makeExternalAclKey(ACLFilledChecklist * ch, external_acl_data * acl_data)
             break;
 
         case _external_acl_format::EXT_ACL_PROTO:
-            str = ProtocolStr[request->protocol];
+            str = AnyP::ProtocolType_str[request->protocol];
             break;
 
         case _external_acl_format::EXT_ACL_PORT:
@@ -203,7 +203,7 @@ FwdState::fwdStart(int client_fd, StoreEntry *entry, HttpRequest *request)
      */
 
     if ( Config.accessList.miss && !request->client_addr.IsNoAddr() &&
-            request->protocol != PROTO_INTERNAL && request->protocol != PROTO_CACHEOBJ) {
+            request->protocol != AnyP::PROTO_INTERNAL && request->protocol != AnyP::PROTO_CACHE_OBJECT) {
         /**
          * Check if this host is allowed to fetch MISSES from us (miss_access)
          */
@@ -247,15 +247,15 @@ FwdState::fwdStart(int client_fd, StoreEntry *entry, HttpRequest *request)
 
     switch (request->protocol) {
 
-    case PROTO_INTERNAL:
+    case AnyP::PROTO_INTERNAL:
         internalStart(request, entry);
         return;
 
-    case PROTO_CACHEOBJ:
+    case AnyP::PROTO_CACHE_OBJECT:
         CacheManager::GetInstance()->Start(client_fd, request, entry);
         return;
 
-    case PROTO_URN:
+    case AnyP::PROTO_URN:
         urnStart(request, entry);
         return;
 
@@ -752,7 +752,7 @@ FwdState::connectDone(int aServerFD, const DnsLookupDetails &dns, comm_err_t sta
 #if USE_SSL
 
         if ((fs->_peer && fs->_peer->use_ssl) ||
-                (!fs->_peer && request->protocol == PROTO_HTTPS)) {
+                (!fs->_peer && request->protocol == AnyP::PROTO_HTTPS)) {
             initiateSSL();
             return;
         }
@@ -1069,36 +1069,36 @@ FwdState::dispatch()
         switch (request->protocol) {
 #if USE_SSL
 
-        case PROTO_HTTPS:
+        case AnyP::PROTO_HTTPS:
             httpStart(this);
             break;
 #endif
 
-        case PROTO_HTTP:
+        case AnyP::PROTO_HTTP:
             httpStart(this);
             break;
 
-        case PROTO_GOPHER:
+        case AnyP::PROTO_GOPHER:
             gopherStart(this);
             break;
 
-        case PROTO_FTP:
+        case AnyP::PROTO_FTP:
             ftpStart(this);
             break;
 
-        case PROTO_CACHEOBJ:
+        case AnyP::PROTO_CACHE_OBJECT:
 
-        case PROTO_INTERNAL:
+        case AnyP::PROTO_INTERNAL:
 
-        case PROTO_URN:
+        case AnyP::PROTO_URN:
             fatal_dump("Should never get here");
             break;
 
-        case PROTO_WHOIS:
+        case AnyP::PROTO_WHOIS:
             whoisStart(this);
             break;
 
-        case PROTO_WAIS:	/* Not implemented */
+        case AnyP::PROTO_WAIS:	/* Not implemented */
 
         default:
             debugs(17, 1, "fwdDispatch: Cannot retrieve '" << entry->url() << "'" );
@@ -1471,7 +1471,7 @@ FtpStateData::buildTitleUrl()
 
     title_url.append(request->GetHost());
 
-    if (request->port != urlDefaultPort(PROTO_FTP)) {
+    if (request->port != urlDefaultPort(AnyP::PROTO_FTP)) {
         title_url.append(":");
         title_url.append(xitoa(request->port));
     }
@@ -1493,7 +1493,7 @@ FtpStateData::buildTitleUrl()
 
     base_href.append(request->GetHost());
 
-    if (request->port != urlDefaultPort(PROTO_FTP)) {
+    if (request->port != urlDefaultPort(AnyP::PROTO_FTP)) {
         base_href.append(":");
         base_href.append(xitoa(request->port));
     }
@@ -3773,7 +3773,7 @@ ftpUrlWith2f(HttpRequest * request)
 {
     String newbuf = "%2f";
 
-    if (request->protocol != PROTO_FTP)
+    if (request->protocol != AnyP::PROTO_FTP)
         return NULL;
 
     if ( request->urlpath[0]=='/' ) {
@@ -30,6 +30,6 @@ typedef enum {
 
 extern const char *hier_code_str[];
 
-inline const hier_code operator++(hier_code &i) { return (hier_code)(i+1); }
+inline hier_code operator++(hier_code &i) { return (hier_code)(i+1); }
 
 #endif /* SQUID__HIER_CODE_H */
@@ -717,14 +717,14 @@ HttpStateData::processReplyHeader()
 
     newrep->removeStaleWarnings();
 
-    if (newrep->sline.protocol == PROTO_HTTP && newrep->sline.status >= 100 && newrep->sline.status < 200) {
+    if (newrep->sline.protocol == AnyP::PROTO_HTTP && newrep->sline.status >= 100 && newrep->sline.status < 200) {
         handle1xx(newrep);
         ctx_exit(ctx);
         return;
     }
 
     flags.chunked = 0;
-    if (newrep->sline.protocol == PROTO_HTTP && newrep->header.chunked()) {
+    if (newrep->sline.protocol == AnyP::PROTO_HTTP && newrep->header.chunked()) {
         flags.chunked = 1;
         httpChunkDecoder = new ChunkedCodingParser;
     }
@@ -769,7 +769,7 @@ HttpStateData::handle1xx(HttpReply *reply)
 #if USE_HTTP_VIOLATIONS
     // check whether the 1xx response forwarding is allowed by squid.conf
     if (Config.accessList.reply) {
-        ACLFilledChecklist ch(Config.accessList.reply, request, NULL);
+        ACLFilledChecklist ch(Config.accessList.reply, originalRequest(), NULL);
         ch.reply = HTTPMSGLOCK(reply);
         if (!ch.fastCheck()) { // TODO: support slow lookups?
             debugs(11, 3, HERE << "ignoring denied 1xx");
@@ -1816,7 +1816,7 @@ HttpStateData::httpBuildRequestHeader(HttpRequest * request,
 
     /* append Front-End-Https */
     if (flags.front_end_https) {
-        if (flags.front_end_https == 1 || request->protocol == PROTO_HTTPS)
+        if (flags.front_end_https == 1 || request->protocol == AnyP::PROTO_HTTPS)
             hdr_out->putStr(HDR_FRONT_END_HTTPS, "On");
     }
 
@@ -2208,7 +2208,7 @@ HttpStateData::finishingBrokenPost()
         return false;
     }
 
-    ACLFilledChecklist ch(Config.accessList.brokenPosts, request, NULL);
+    ACLFilledChecklist ch(Config.accessList.brokenPosts, originalRequest(), NULL);
     if (!ch.fastCheck()) {
         debugs(11, 5, HERE << "didn't match brokenPosts");
         return false;
@@ -214,7 +214,7 @@ icpLogIcp(const Ip::Address &caddr, log_type logcode, int len, const char *url,
     if (LOG_ICP_QUERY == logcode)
         return;
 
-    clientdbUpdate(caddr, logcode, PROTO_ICP, len);
+    clientdbUpdate(caddr, logcode, AnyP::PROTO_ICP, len);
 
     if (!Config.onoff.log_udp)
         return;
@@ -425,7 +425,7 @@ icpDenyAccess(Ip::Address &from, char *url, int reqnum, int fd)
          * count this DENIED query in the clientdb, even though
          * we're not sending an ICP reply...
          */
-        clientdbUpdate(from, LOG_UDP_DENIED, PROTO_ICP, 0);
+        clientdbUpdate(from, LOG_UDP_DENIED, AnyP::PROTO_ICP, 0);
     } else {
         icpCreateAndSend(ICP_DENIED, 0, url, reqnum, 0, fd, from);
     }
@@ -125,7 +125,7 @@ internalRemoteUri(const char *host, u_short port, const char *dir, const char *n
     mb.Printf("http://%s", lc_host);
 
     /* append port if not default */
-    if (port && port != urlDefaultPort(PROTO_HTTP))
+    if (port && port != urlDefaultPort(AnyP::PROTO_HTTP))
         mb.Printf(":%d", port);
 
     if (dir)
@@ -212,6 +212,14 @@ Ip::Address::SetEmpty()
     memset(&m_SocketAddr, 0, sizeof(m_SocketAddr) );
 }
 
+#if _SQUID_AIX_
+// Bug 2885 comment 78 explains.
+// In short AIX has a different netinet/in.h union definition
+const struct in6_addr Ip::Address::v4_localhost = {{{ 0x00000000, 0x00000000, 0x0000ffff, 0x7f000001 }}};
+const struct in6_addr Ip::Address::v4_anyaddr = {{{ 0x00000000, 0x00000000, 0x0000ffff, 0x00000000 }}};
+const struct in6_addr Ip::Address::v4_noaddr = {{{ 0x00000000, 0x00000000, 0x0000ffff, 0xffffffff }}};
+const struct in6_addr Ip::Address::v6_noaddr = {{{ 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff }}};
+#else
 const struct in6_addr Ip::Address::v4_localhost = {{{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x01 }}
 };
@@ -224,7 +232,7 @@ const struct in6_addr Ip::Address::v4_noaddr = {{{ 0x00, 0x00, 0x00, 0x00, 0x00,
 const struct in6_addr Ip::Address::v6_noaddr = {{{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
             0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }}
 };
-
+#endif
 
 bool
 Ip::Address::SetIPv4()
@@ -398,7 +406,7 @@ Ip::Address::LookupHostIP(const char *s, bool nodns)
 #endif
 
     if ( (err = getaddrinfo(s, NULL, &want, &res)) != 0) {
-        debugs(14,3, HERE << "Given Bad IP '" << s << "': " << gai_strerror(err) );
+        debugs(14,3, HERE << "Given Non-IP '" << s << "': " << gai_strerror(err) );
         /* free the memory getaddrinfo() dynamically allocated. */
         if (res) {
             freeaddrinfo(res);
@@ -822,7 +830,7 @@ Ip::Address::NtoA(char* buf, const unsigned int blen, int force) const
     /* some external code may have blindly memset a parent. */
     /* thats okay, our default is known */
     if ( IsAnyAddr() ) {
-        memcpy(buf,"::\0", min((const unsigned int)3,blen));
+        memcpy(buf,"::\0", min(static_cast<unsigned int>(3),blen));
         return buf;
     }
 
@@ -832,7 +840,7 @@ Ip::Address::NtoA(char* buf, const unsigned int blen, int force) const
     /* However IPv4 CAN. */
     if ( force == AF_INET && !IsIPv4() ) {
         if ( IsIPv6() ) {
-            memcpy(buf, "{!IPv4}\0", min((const unsigned int)8,blen));
+            memcpy(buf, "{!IPv4}\0", min(static_cast<unsigned int>(8),blen));
         }
         return buf;
     }
@@ -851,7 +859,7 @@ Ip::Address::NtoA(char* buf, const unsigned int blen, int force) const
                force << "). accepted={" << AF_UNSPEC << "," << AF_INET << "," << AF_INET6 << "}");
         fprintf(stderr,"WARNING: Corrupt IP Address details OR required to display in unknown format (%d). accepted={%d,%d,%d} ",
                 force, AF_UNSPEC, AF_INET, AF_INET6);
-        memcpy(buf,"dead:beef::\0", min((const unsigned int)13,blen));
+        memcpy(buf,"dead:beef::\0", min(static_cast<unsigned int>(13),blen));
         assert(false);
     }
 
@@ -56,7 +56,7 @@ Kid* Kids::find(pid_t pid)
 /// returns the kid by index, useful for kids iteration
 Kid& Kids::get(size_t i)
 {
-    assert(i >= 0 && i < count());
+    assert(i < count());
     return storage[i];
 }
 
@@ -153,7 +153,6 @@ Ipc::TypedMsgHdr::putFixed(const void *raw, size_t size)
 void
 Ipc::TypedMsgHdr::getRaw(void *raw, size_t size) const
 {
-    Must(size >= 0);
     if (size > 0) {
         Must(size <= data.size - offset);
         memcpy(raw, data.raw + offset, size);
@@ -165,7 +164,6 @@ Ipc::TypedMsgHdr::getRaw(void *raw, size_t size) const
 void
 Ipc::TypedMsgHdr::putRaw(const void *raw, size_t size)
 {
-    Must(size >= 0);
     if (size > 0) {
         Must(size <= sizeof(data.raw) - data.size);
         memcpy(data.raw + data.size, raw, size);
@@ -36,6 +36,8 @@
 #include "squid.h"
 #include "comm.h"
 #include "fde.h"
+#include "ip/Address.h"
+#include "rfc1738.h"
 #include "SquidTime.h"
 
 #ifndef _MSWSOCK_
@@ -27,6 +27,7 @@ Mgr::ActionParams::ActionParams(const Ipc::TypedMsgHdr &msg)
     msg.getString(actionName);
     msg.getString(userName);
     msg.getString(password);
+    queryParams.unpack(msg);
 }
 
 void
@@ -39,4 +40,5 @@ Mgr::ActionParams::pack(Ipc::TypedMsgHdr &msg) const
     msg.putString(actionName);
     msg.putString(userName);
     msg.putString(password);
+    queryParams.pack(msg);
 }
@@ -10,6 +10,7 @@
 
 #include "HttpRequestMethod.h"
 #include "ipc/forward.h"
+#include "mgr/QueryParams.h"
 
 namespace Mgr
 {
@@ -33,7 +34,7 @@ class ActionParams
     String actionName; ///< action name (and credentials realm)
     String userName; ///< user login name; currently only used for logging
     String password; ///< user password; used for acceptance check and cleared
-
+    QueryParams queryParams;
 };
 
 } // namespace Mgr
@@ -10,21 +10,26 @@
 #include "comm/Write.h"
 #include "CommCalls.h"
 #include "HttpReply.h"
+#include "HttpRequest.h"
 #include "ipc/UdsOp.h"
 #include "mgr/ActionWriter.h"
+#include "mgr/IntParam.h"
 #include "mgr/Inquirer.h"
+#include "mgr/Command.h"
 #include "mgr/Request.h"
 #include "mgr/Response.h"
 #include "SquidTime.h"
+#include "errorpage.h"
 #include <memory>
+#include <algorithm>
 
 
 CBDATA_NAMESPACED_CLASS_INIT(Mgr, Inquirer);
 
 
 Mgr::Inquirer::Inquirer(Action::Pointer anAction,
                         const Request &aCause, const Ipc::StrandCoords &coords):
-        Ipc::Inquirer(aCause.clone(), coords, anAction->atomic() ? 10 : 100),
+        Ipc::Inquirer(aCause.clone(), applyQueryParams(coords, aCause.params.queryParams), anAction->atomic() ? 10 : 100),
         aggrAction(anAction),
         fd(Ipc::ImportFdIntoComm(aCause.fd, SOCK_STREAM, IPPROTO_TCP, Ipc::fdnHttpSocket))
 {
@@ -63,10 +68,21 @@ Mgr::Inquirer::start()
     Must(fd >= 0);
     Must(aggrAction != NULL);
 
-    std::auto_ptr<HttpReply> reply(new HttpReply);
-    reply->setHeaders(HTTP_OK, NULL, "text/plain", -1, squid_curtime, squid_curtime);
-    reply->header.putStr(HDR_CONNECTION, "close"); // until we chunk response
-    std::auto_ptr<MemBuf> replyBuf(reply->pack());
+    std::auto_ptr<MemBuf> replyBuf;
+    if (strands.empty()) {
+        LOCAL_ARRAY(char, url, MAX_URL);
+        snprintf(url, MAX_URL, "%s", aggrAction->command().params.httpUri.termedBuf());
+        HttpRequest *req = HttpRequest::CreateFromUrl(url);
+        ErrorState *err = errorCon(ERR_INVALID_URL, HTTP_NOT_FOUND, req);
+        std::auto_ptr<HttpReply> reply(err->BuildHttpReply());
+        replyBuf.reset(reply->pack());
+        errorStateFree(err);
+    } else {
+        std::auto_ptr<HttpReply> reply(new HttpReply);
+        reply->setHeaders(HTTP_OK, NULL, "text/plain", -1, squid_curtime, squid_curtime);
+        reply->header.putStr(HDR_CONNECTION, "close"); // until we chunk response
+        replyBuf.reset(reply->pack());
+    }
     writer = asyncCall(16, 5, "Mgr::Inquirer::noteWroteHeader",
                        CommCbMemFunT<Inquirer, CommIoCbParams>(this, &Inquirer::noteWroteHeader));
     Comm::Write(fd, replyBuf.get(), writer);
@@ -107,7 +123,7 @@ Mgr::Inquirer::aggregate(Ipc::Response::Pointer aResponse)
 void
 Mgr::Inquirer::sendResponse()
 {
-    if (aggrAction->aggregatable()) {
+    if (!strands.empty() && aggrAction->aggregatable()) {
         removeCloseHandler();
         AsyncJob::Start(new ActionWriter(aggrAction, fd));
         fd = -1; // should not close fd because we passed it to ActionWriter
@@ -119,3 +135,44 @@ Mgr::Inquirer::doneAll() const
 {
     return !writer && Ipc::Inquirer::doneAll();
 }
+
+Ipc::StrandCoords
+Mgr::Inquirer::applyQueryParams(const Ipc::StrandCoords& aStrands, const QueryParams& aParams)
+{
+    Ipc::StrandCoords sc;
+
+    QueryParam::Pointer processesParam = aParams.get("processes");
+    QueryParam::Pointer workersParam = aParams.get("workers");
+
+    if (processesParam == NULL || workersParam == NULL) {
+        if (processesParam != NULL) {
+            IntParam* param = dynamic_cast<IntParam*>(processesParam.getRaw());
+            if (param != NULL && param->type == QueryParam::ptInt) {
+                const std::vector<int>& processes = param->value();
+                for (Ipc::StrandCoords::const_iterator iter = aStrands.begin();
+                        iter != aStrands.end(); ++iter) {
+                    if (std::find(processes.begin(), processes.end(), iter->kidId) != processes.end())
+                        sc.push_back(*iter);
+                }
+            }
+        } else if (workersParam != NULL) {
+            IntParam* param = dynamic_cast<IntParam*>(workersParam.getRaw());
+            if (param != NULL && param->type == QueryParam::ptInt) {
+                const std::vector<int>& workers = param->value();
+                for (int i = 0; i < (int)aStrands.size(); ++i) {
+                    if (std::find(workers.begin(), workers.end(), i + 1) != workers.end())
+                        sc.push_back(aStrands[i]);
+                }
+            }
+        } else {
+            sc = aStrands;
+        }
+    }
+
+    debugs(0, 0, HERE << "strands kid IDs = ");
+    for (Ipc::StrandCoords::const_iterator iter = sc.begin(); iter != sc.end(); ++iter) {
+        debugs(0, 0, HERE << iter->kidId);
+    }
+
+    return sc;
+}
@@ -39,7 +39,8 @@ class Inquirer: public Ipc::Inquirer
     void noteWroteHeader(const CommIoCbParams& params);
     void noteCommClosed(const CommCloseCbParams& params);
     void removeCloseHandler();
-
+    Ipc::StrandCoords applyQueryParams(const Ipc::StrandCoords& aStrands,
+                                       const QueryParams& aParams);
 private:
     Action::Pointer aggrAction; //< action to aggregate
 
@@ -0,0 +1,48 @@
+/*
+ * $Id$
+ *
+ * DEBUG: section 16    Cache Manager API
+ *
+ */
+
+#include "config.h"
+#include "base/TextException.h"
+#include "ipc/TypedMsgHdr.h"
+#include "mgr/IntParam.h"
+
+
+Mgr::IntParam::IntParam():
+        QueryParam(QueryParam::ptInt), array()
+{
+}
+
+Mgr::IntParam::IntParam(const std::vector<int>& anArray):
+        QueryParam(QueryParam::ptInt), array(anArray)
+{
+}
+
+void
+Mgr::IntParam::pack(Ipc::TypedMsgHdr& msg) const
+{
+    msg.putPod(type);
+    msg.putInt(array.size());
+    typedef std::vector<int>::const_iterator Iterator;
+    for (Iterator iter = array.begin(); iter != array.end(); ++iter)
+        msg.putInt(*iter);
+}
+
+void
+Mgr::IntParam::unpackValue(const Ipc::TypedMsgHdr& msg)
+{
+    array.clear();
+    int count = msg.getInt();
+    Must(count >= 0);
+    for ( ; count > 0; --count)
+        array.push_back(msg.getInt());
+}
+
+const std::vector<int>&
+Mgr::IntParam::value() const
+{
+    return array;
+}
@@ -0,0 +1,35 @@
+/*
+ * $Id$
+ *
+ * DEBUG: section 16    Cache Manager API
+ *
+ */
+
+#ifndef SQUID_MGR_INT_PARAM_H
+#define SQUID_MGR_INT_PARAM_H
+
+#include "ipc/forward.h"
+#include "mgr/forward.h"
+#include "mgr/QueryParam.h"
+#include <vector>
+
+
+namespace Mgr
+{
+
+class IntParam: public QueryParam
+{
+public:
+    IntParam();
+    IntParam(const std::vector<int>& anArray);
+    virtual void pack(Ipc::TypedMsgHdr& msg) const;
+    virtual void unpackValue(const Ipc::TypedMsgHdr& msg);
+    const std::vector<int>& value() const;
+
+private:
+    std::vector<int> array;
+};
+
+} // namespace Mgr
+
+#endif /* SQUID_MGR_INT_PARAM_H */
@@ -44,4 +44,11 @@ libmgr_la_SOURCES = \
 	StoreIoAction.cc \
 	StoreIoAction.h \
 	StoreToCommWriter.cc \
-	StoreToCommWriter.h
+	StoreToCommWriter.h \
+	QueryParam.h \
+	QueryParams.cc \
+	QueryParams.h \
+	IntParam.cc \
+	IntParam.h \
+	StringParam.cc \
+	StringParam.h
@@ -0,0 +1,40 @@
+/*
+ * $Id$
+ *
+ * DEBUG: section 16    Cache Manager API
+ *
+ */
+
+#ifndef SQUID_MGR_QUERY_PARAM_H
+#define SQUID_MGR_QUERY_PARAM_H
+
+#include "ipc/forward.h"
+#include "RefCount.h"
+
+
+namespace Mgr
+{
+
+class QueryParam: public RefCountable
+{
+public:
+    typedef enum {ptInt = 1, ptString} Type;
+    typedef RefCount<QueryParam> Pointer;
+
+public:
+    QueryParam(Type aType): type(aType) {}
+    virtual ~QueryParam() {}
+    virtual void pack(Ipc::TypedMsgHdr& msg) const = 0; ///< store parameter into msg
+    virtual void unpackValue(const Ipc::TypedMsgHdr& msg) = 0; ///< load parameter value from msg
+
+private:
+    QueryParam(const QueryParam&); // not implemented
+    QueryParam& operator= (const QueryParam&); // not implemented
+
+public:
+    Type type;
+};
+
+} // namespace Mgr
+
+#endif /* SQUID_MGR_QUERY_PARAM_H */
@@ -0,0 +1,138 @@
+/*
+ * $Id$
+ *
+ * DEBUG: section 16    Cache Manager API
+ *
+ */
+
+#include "config.h"
+#include "base/TextException.h"
+#include "ipc/TypedMsgHdr.h"
+#include "mgr/IntParam.h"
+#include "mgr/StringParam.h"
+#include "mgr/QueryParams.h"
+
+
+Mgr::QueryParam::Pointer
+Mgr::QueryParams::get(const String& name) const
+{
+    Must(name.size() != 0);
+    Params::const_iterator pos = find(name);
+    return (pos == params.end() ? NULL : pos->second);
+}
+
+void
+Mgr::QueryParams::pack(Ipc::TypedMsgHdr& msg) const
+{
+    msg.putInt(params.size());
+    for (Params::const_iterator iter = params.begin(); iter != params.end(); ++iter) {
+        Must(iter->first.size() != 0);
+        msg.putString(iter->first);
+        Must(iter->second != NULL);
+        iter->second->pack(msg);
+    }
+}
+
+void
+Mgr::QueryParams::unpack(const Ipc::TypedMsgHdr& msg)
+{
+    int count = msg.getInt();
+    Must(count >= 0);
+    params.clear();
+    for ( ; count > 0; --count) {
+        String name;
+        msg.getString(name);
+        Must(name.size() != 0);
+        QueryParam::Type type;
+        msg.getPod(type);
+        QueryParam::Pointer value = CreateParam(type);
+        value->unpackValue(msg);
+        params.push_back(Param(name, value));
+    }
+}
+
+Mgr::QueryParams::Params::const_iterator
+Mgr::QueryParams::find(const String& name) const
+{
+    Must(name.size() != 0);
+    Params::const_iterator iter = params.begin();
+    for ( ; iter != params.end(); ++iter) {
+        if (name.caseCmp(iter->first) == 0)
+            break;
+    }
+    return iter;
+}
+
+bool
+Mgr::QueryParams::ParseParam(const String& paramStr, Param& param)
+{
+    bool parsed = false;
+    regmatch_t pmatch[3];
+    regex_t intExpr;
+    regcomp(&intExpr, "^([a-z][a-z0-9_]*)=([0-9]+((,[0-9]+))*)$", REG_EXTENDED | REG_ICASE);
+    regex_t stringExpr;
+    regcomp(&stringExpr, "^([a-z][a-z0-9_]*)=([^&= ]+)$", REG_EXTENDED | REG_ICASE);
+    if (regexec(&intExpr, paramStr.termedBuf(), 3, pmatch, 0) == 0) {
+        param.first = paramStr.substr(pmatch[1].rm_so, pmatch[1].rm_eo);
+        std::vector<int> array;
+        int n = pmatch[2].rm_so;
+        for (int i = n; i < pmatch[2].rm_eo; ++i) {
+            if (paramStr[i] == ',') {
+                array.push_back(atoi(paramStr.substr(n, i).termedBuf()));
+                n = i + 1;
+            }
+        }
+        if (n < pmatch[2].rm_eo)
+            array.push_back(atoi(paramStr.substr(n, pmatch[2].rm_eo).termedBuf()));
+        param.second = new IntParam(array);
+        parsed = true;
+    } else if (regexec(&stringExpr, paramStr.termedBuf(), 3, pmatch, 0) == 0) {
+        param.first = paramStr.substr(pmatch[1].rm_so, pmatch[1].rm_eo);
+        param.second = new StringParam(paramStr.substr(pmatch[2].rm_so, pmatch[2].rm_eo));
+        parsed = true;
+    }
+    regfree(&stringExpr);
+    regfree(&intExpr);
+    return parsed;
+}
+
+bool
+Mgr::QueryParams::Parse(const String& aParamsStr, QueryParams& aParams)
+{
+    if (aParamsStr.size() != 0) {
+        Param param;
+        size_t n = 0;
+        size_t len = aParamsStr.size();
+        for (size_t i = n; i < len; ++i) {
+            if (aParamsStr[i] == '&') {
+                if (!ParseParam(aParamsStr.substr(n, i), param))
+                    return false;
+                aParams.params.push_back(param);
+                n = i + 1;
+            }
+        }
+        if (n < len) {
+            if (!ParseParam(aParamsStr.substr(n, len), param))
+                return false;
+            aParams.params.push_back(param);
+        }
+    }
+    return true;
+}
+
+Mgr::QueryParam::Pointer
+Mgr::QueryParams::CreateParam(QueryParam::Type aType)
+{
+    switch (aType) {
+    case QueryParam::ptInt:
+        return new IntParam();
+
+    case QueryParam::ptString:
+        return new StringParam();
+
+    default:
+        throw TexcHere("unknown parameter type");
+        break;
+    }
+    return NULL;
+}
@@ -0,0 +1,49 @@
+/*
+ * $Id$
+ *
+ * DEBUG: section 16    Cache Manager API
+ *
+ */
+
+#ifndef SQUID_MGR_QUERY_PARAMS_H
+#define SQUID_MGR_QUERY_PARAMS_H
+
+#include "ipc/forward.h"
+#include "mgr/QueryParam.h"
+#include "SquidString.h"
+#include <vector>
+#include <utility>
+
+
+namespace Mgr
+{
+
+class QueryParams
+{
+public:
+    typedef std::pair<String, QueryParam::Pointer> Param;
+    typedef std::vector<Param> Params;
+
+public:
+    /// returns query parameter by name
+    QueryParam::Pointer get(const String& name) const;
+    void pack(Ipc::TypedMsgHdr& msg) const; ///< store params into msg
+    void unpack(const Ipc::TypedMsgHdr& msg); ///< load params from msg
+    /// parses the query string parameters
+    static bool Parse(const String& aParamsStr, QueryParams& aParams);
+
+private:
+    /// find query parameter by name
+    Params::const_iterator find(const String& name) const;
+    /// creates a parameter of the specified type
+    static QueryParam::Pointer CreateParam(QueryParam::Type aType);
+    /// parses string like "param=value"; returns true if success
+    static bool ParseParam(const String& paramStr, Param& param);
+
+private:
+    Params params;
+};
+
+} // namespace Mgr
+
+#endif /* SQUID_MGR_QUERY_PARAMS_H */
@@ -0,0 +1,40 @@
+/*
+ * $Id$
+ *
+ * DEBUG: section 16    Cache Manager API
+ *
+ */
+
+#include "config.h"
+#include "ipc/TypedMsgHdr.h"
+#include "mgr/StringParam.h"
+
+
+Mgr::StringParam::StringParam():
+        QueryParam(QueryParam::ptString), str()
+{
+}
+
+Mgr::StringParam::StringParam(const String& aString):
+        QueryParam(QueryParam::ptString), str(aString)
+{
+}
+
+void
+Mgr::StringParam::pack(Ipc::TypedMsgHdr& msg) const
+{
+    msg.putPod(type);
+    msg.putString(str);
+}
+
+void
+Mgr::StringParam::unpackValue(const Ipc::TypedMsgHdr& msg)
+{
+    msg.getString(str);
+}
+
+const String&
+Mgr::StringParam::value() const
+{
+    return str;
+}
@@ -0,0 +1,35 @@
+/*
+ * $Id$
+ *
+ * DEBUG: section 16    Cache Manager API
+ *
+ */
+
+#ifndef SQUID_MGR_STRING_PARAM_H
+#define SQUID_MGR_STRING_PARAM_H
+
+#include "ipc/forward.h"
+#include "mgr/forward.h"
+#include "mgr/QueryParam.h"
+#include "SquidString.h"
+
+
+namespace Mgr
+{
+
+class StringParam: public QueryParam
+{
+public:
+    StringParam();
+    StringParam(const String& aString);
+    virtual void pack(Ipc::TypedMsgHdr& msg) const;
+    virtual void unpackValue(const Ipc::TypedMsgHdr& msg);
+    const String& value() const;
+
+private:
+    String str;
+};
+
+} // namespace Mgr
+
+#endif /* SQUID_MGR_STRING_PARAM_H */
@@ -20,6 +20,8 @@ class ActionWriter;
 class Command;
 class Request;
 class Response;
+class QueryParam;
+class QueryParams;
 
 typedef RefCount<Action> ActionPointer;
 typedef RefCount<ActionProfile> ActionProfilePointer;
@@ -1093,14 +1093,14 @@ neighborsUdpAck(const cache_key * key, icp_common_t * header, const Ip::Address
         if (p == NULL) {
             neighborIgnoreNonPeer(from, opcode);
         } else {
-            mem->ping_reply_callback(p, ntype, PROTO_ICP, header, mem->ircb_data);
+            mem->ping_reply_callback(p, ntype, AnyP::PROTO_ICP, header, mem->ircb_data);
         }
     } else if (opcode == ICP_HIT) {
         if (p == NULL) {
             neighborIgnoreNonPeer(from, opcode);
         } else {
             header->opcode = ICP_HIT;
-            mem->ping_reply_callback(p, ntype, PROTO_ICP, header, mem->ircb_data);
+            mem->ping_reply_callback(p, ntype, AnyP::PROTO_ICP, header, mem->ircb_data);
         }
     } else if (opcode == ICP_DECHO) {
         if (p == NULL) {
@@ -1109,7 +1109,7 @@ neighborsUdpAck(const cache_key * key, icp_common_t * header, const Ip::Address
             debug_trap("neighborsUdpAck: Found non-ICP cache as SIBLING\n");
             debug_trap("neighborsUdpAck: non-ICP neighbors must be a PARENT\n");
         } else {
-            mem->ping_reply_callback(p, ntype, PROTO_ICP, header, mem->ircb_data);
+            mem->ping_reply_callback(p, ntype, AnyP::PROTO_ICP, header, mem->ircb_data);
         }
     } else if (opcode == ICP_SECHO) {
         if (p) {
@@ -1132,7 +1132,7 @@ neighborsUdpAck(const cache_key * key, icp_common_t * header, const Ip::Address
             }
         }
     } else if (opcode == ICP_MISS_NOFETCH) {
-        mem->ping_reply_callback(p, ntype, PROTO_ICP, header, mem->ircb_data);
+        mem->ping_reply_callback(p, ntype, AnyP::PROTO_ICP, header, mem->ircb_data);
     } else {
         debugs(15, 0, "neighborsUdpAck: Unexpected ICP reply: " << opcode_d);
     }
@@ -1523,15 +1523,15 @@ peerCountMcastPeersDone(void *data)
 }
 
 static void
-peerCountHandleIcpReply(peer * p, peer_t type, protocol_t proto, void *hdrnotused, void *data)
+peerCountHandleIcpReply(peer * p, peer_t type, AnyP::ProtocolType proto, void *hdrnotused, void *data)
 {
     int rtt_av_factor;
 
     ps_state *psstate = (ps_state *)data;
     StoreEntry *fake = psstate->entry;
     MemObject *mem = fake->mem_obj;
     int rtt = tvSubMsec(mem->start_ping, current_time);
-    assert(proto == PROTO_ICP);
+    assert(proto == AnyP::PROTO_ICP);
     assert(fake);
     assert(mem);
     psstate->ping.n_recv++;
@@ -1838,7 +1838,7 @@ neighborsHtcpReply(const cache_key * key, htcpReplyData * htcp, const Ip::Addres
     }
 
     debugs(15, 3, "neighborsHtcpReply: e = " << e);
-    mem->ping_reply_callback(p, ntype, PROTO_HTCP, htcp, mem->ircb_data);
+    mem->ping_reply_callback(p, ntype, AnyP::PROTO_HTCP, htcp, mem->ircb_data);
 }
 
 /*
@@ -497,7 +497,7 @@ peerGetSomeDirect(ps_state * ps)
         return;
 
     /* WAIS is not implemented natively */
-    if (ps->request->protocol == PROTO_WAIS)
+    if (ps->request->protocol == AnyP::PROTO_WAIS)
         return;
 
     peerAddFwdServer(&ps->servers, NULL, HIER_DIRECT);
@@ -745,20 +745,20 @@ peerHtcpParentMiss(peer * p, htcpReplyData * htcp, ps_state * ps)
 #endif
 
 static void
-peerHandlePingReply(peer * p, peer_t type, protocol_t proto, void *pingdata, void *data)
+peerHandlePingReply(peer * p, peer_t type, AnyP::ProtocolType proto, void *pingdata, void *data)
 {
-    if (proto == PROTO_ICP)
+    if (proto == AnyP::PROTO_ICP)
         peerHandleIcpReply(p, type, (icp_common_t *)pingdata, data);
 
 #if USE_HTCP
 
-    else if (proto == PROTO_HTCP)
+    else if (proto == AnyP::PROTO_HTCP)
         peerHandleHtcpReply(p, type, (htcpReplyData *)pingdata, data);
 
 #endif
 
     else
-        debugs(44, 1, "peerHandlePingReply: unknown protocol_t " << proto);
+        debugs(44, 1, "peerHandlePingReply: unknown protocol " << proto);
 }
 
 static void
@@ -84,7 +84,8 @@ SQUIDCEXTERN void parse_time_t(time_t * var);
 
 SQUIDCEXTERN void clientdbInit(void);
 
-SQUIDCEXTERN void clientdbUpdate(const Ip::Address &, log_type, protocol_t, size_t);
+#include "anyp/ProtocolType.h"
+SQUIDCEXTERN void clientdbUpdate(const Ip::Address &, log_type, AnyP::ProtocolType, size_t);
 
 SQUIDCEXTERN int clientdbCutoffDenied(const Ip::Address &);
 void clientdbDump(StoreEntry *);
@@ -614,7 +615,7 @@ SQUIDCEXTERN void unlinkdClose(void);
 SQUIDCEXTERN void unlinkdUnlink(const char *);
 #endif
 
-SQUIDCEXTERN protocol_t urlParseProtocol(const char *, const char *e = NULL);
+SQUIDCEXTERN AnyP::ProtocolType urlParseProtocol(const char *, const char *e = NULL);
 SQUIDCEXTERN void urlInitialize(void);
 SQUIDCEXTERN HttpRequest *urlParse(const HttpRequestMethod&, char *, HttpRequest *request = NULL);
 SQUIDCEXTERN const char *urlCanonical(HttpRequest *);
@@ -626,7 +627,7 @@ SQUIDCEXTERN char *urlRInternal(const char *host, u_short port, const char *dir,
 SQUIDCEXTERN char *urlInternal(const char *dir, const char *name);
 SQUIDCEXTERN int matchDomainName(const char *host, const char *domain);
 SQUIDCEXTERN int urlCheckRequest(const HttpRequest *);
-SQUIDCEXTERN int urlDefaultPort(protocol_t p);
+SQUIDCEXTERN int urlDefaultPort(AnyP::ProtocolType p);
 SQUIDCEXTERN char *urlHostname(const char *url);
 SQUIDCEXTERN void urlExtMethodConfigure(void);
 
@@ -41,7 +41,7 @@ HttpRequest::HttpRequest() : HttpMsg(hoRequest)
     fatal("Not implemented");
 }
 
-HttpRequest::HttpRequest(const HttpRequestMethod& method, protocol_t protocol, const char *aUrlpath) : HttpMsg(hoRequest)
+HttpRequest::HttpRequest(const HttpRequestMethod& method, AnyP::ProtocolType protocol, const char *aUrlpath) : HttpMsg(hoRequest)
 {
     fatal("Not implemented");
 }
@@ -82,7 +82,7 @@ HttpRequest::expectingBody(const HttpRequestMethod& unused, int64_t&) const
 }
 
 void
-HttpRequest::initHTTP(const HttpRequestMethod& aMethod, protocol_t aProtocol, const char *aUrlpath)
+HttpRequest::initHTTP(const HttpRequestMethod& aMethod, AnyP::ProtocolType aProtocol, const char *aUrlpath)
 {
     fatal("Not implemented");
 }
@@ -42,7 +42,7 @@ testHttpRequest::testCreateFromUrlAndMethod()
     CPPUNIT_ASSERT(aRequest->method == METHOD_GET);
     CPPUNIT_ASSERT_EQUAL(String("foo"), String(aRequest->GetHost()));
     CPPUNIT_ASSERT_EQUAL(String("/bar"), aRequest->urlpath);
-    CPPUNIT_ASSERT_EQUAL(PROTO_HTTP, aRequest->protocol);
+    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, aRequest->protocol);
     CPPUNIT_ASSERT_EQUAL(String("http://foo:90/bar"), String(url));
     xfree(url);
 
@@ -54,7 +54,7 @@ testHttpRequest::testCreateFromUrlAndMethod()
     CPPUNIT_ASSERT(aRequest->method == METHOD_PUT);
     CPPUNIT_ASSERT_EQUAL(String("foo"), String(aRequest->GetHost()));
     CPPUNIT_ASSERT_EQUAL(String("/bar"), aRequest->urlpath);
-    CPPUNIT_ASSERT_EQUAL(PROTO_HTTP, aRequest->protocol);
+    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, aRequest->protocol);
     CPPUNIT_ASSERT_EQUAL(String("http://foo/bar"), String(url));
 
     /* a connect url with non-CONNECT data */
@@ -71,7 +71,7 @@ testHttpRequest::testCreateFromUrlAndMethod()
     CPPUNIT_ASSERT(aRequest->method == METHOD_CONNECT);
     CPPUNIT_ASSERT_EQUAL(String("foo"), String(aRequest->GetHost()));
     CPPUNIT_ASSERT_EQUAL(String(""), aRequest->urlpath);
-    CPPUNIT_ASSERT_EQUAL(PROTO_NONE, aRequest->protocol);
+    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_NONE, aRequest->protocol);
     CPPUNIT_ASSERT_EQUAL(String("foo:45"), String(url));
     xfree(url);
 }
@@ -91,7 +91,7 @@ testHttpRequest::testCreateFromUrl()
     CPPUNIT_ASSERT(aRequest->method == METHOD_GET);
     CPPUNIT_ASSERT_EQUAL(String("foo"), String(aRequest->GetHost()));
     CPPUNIT_ASSERT_EQUAL(String("/bar"), aRequest->urlpath);
-    CPPUNIT_ASSERT_EQUAL(PROTO_HTTP, aRequest->protocol);
+    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, aRequest->protocol);
     CPPUNIT_ASSERT_EQUAL(String("http://foo:90/bar"), String(url));
     xfree(url);
 }
@@ -114,7 +114,7 @@ testHttpRequest::testIPv6HostColonBug()
     CPPUNIT_ASSERT(aRequest->method == METHOD_GET);
     CPPUNIT_ASSERT_EQUAL(String("[2000:800::45]"), String(aRequest->GetHost()));
     CPPUNIT_ASSERT_EQUAL(String("/foo"), aRequest->urlpath);
-    CPPUNIT_ASSERT_EQUAL(PROTO_HTTP, aRequest->protocol);
+    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, aRequest->protocol);
     CPPUNIT_ASSERT_EQUAL(String("http://[2000:800::45]/foo"), String(url));
     xfree(url);
 
@@ -126,7 +126,7 @@ testHttpRequest::testIPv6HostColonBug()
     CPPUNIT_ASSERT(aRequest->method == METHOD_GET);
     CPPUNIT_ASSERT_EQUAL(String("[2000:800::45]"), String(aRequest->GetHost()));
     CPPUNIT_ASSERT_EQUAL(String("/foo"), aRequest->urlpath);
-    CPPUNIT_ASSERT_EQUAL(PROTO_HTTP, aRequest->protocol);
+    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, aRequest->protocol);
     CPPUNIT_ASSERT_EQUAL(String("http://[2000:800::45]:90/foo"), String(url));
     xfree(url);
 
@@ -138,7 +138,7 @@ testHttpRequest::testIPv6HostColonBug()
     CPPUNIT_ASSERT(aRequest->method == METHOD_GET);
     CPPUNIT_ASSERT_EQUAL(String("[2000:800::45]"), String(aRequest->GetHost()));
     CPPUNIT_ASSERT_EQUAL(String("/foo"), aRequest->urlpath);
-    CPPUNIT_ASSERT_EQUAL(PROTO_HTTP, aRequest->protocol);
+    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, aRequest->protocol);
     CPPUNIT_ASSERT_EQUAL(String("http://2000:800::45/foo"), String(url));
     xfree(url);
 }
@@ -29,11 +29,11 @@ void
 testURL::testConstructScheme()
 {
     URLScheme empty_scheme;
-    URL protoless_url(PROTO_NONE);
+    URL protoless_url(AnyP::PROTO_NONE);
     CPPUNIT_ASSERT_EQUAL(empty_scheme, protoless_url.getScheme());
 
-    URLScheme ftp_scheme(PROTO_FTP);
-    URL ftp_url(PROTO_FTP);
+    URLScheme ftp_scheme(AnyP::PROTO_FTP);
+    URL ftp_url(AnyP::PROTO_FTP);
     CPPUNIT_ASSERT_EQUAL(ftp_scheme, ftp_url.getScheme());
 }
 
@@ -55,11 +55,11 @@ testURLScheme::testAssignFromprotocol_t()
 {
     URLScheme empty_scheme;
     URLScheme scheme;
-    scheme = PROTO_NONE;
+    scheme = AnyP::PROTO_NONE;
     CPPUNIT_ASSERT_EQUAL(empty_scheme, scheme);
 
-    URLScheme https_scheme(PROTO_HTTPS);
-    scheme = PROTO_HTTPS;
+    URLScheme https_scheme(AnyP::PROTO_HTTPS);
+    scheme = AnyP::PROTO_HTTPS;
     CPPUNIT_ASSERT_EQUAL(https_scheme, scheme);
 }
 
@@ -71,21 +71,21 @@ void
 testURLScheme::testCastToprotocol_t()
 {
     /* explicit cast */
-    protocol_t protocol = (protocol_t) URLScheme();
-    CPPUNIT_ASSERT_EQUAL(PROTO_NONE, protocol);
+    AnyP::ProtocolType protocol = static_cast<AnyP::ProtocolType>(URLScheme());
+    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_NONE, protocol);
     /* and implicit */
-    protocol = URLScheme(PROTO_HTTP);
-    CPPUNIT_ASSERT_EQUAL(PROTO_HTTP, protocol);
+    protocol = URLScheme(AnyP::PROTO_HTTP);
+    CPPUNIT_ASSERT_EQUAL(AnyP::PROTO_HTTP, protocol);
 }
 
 /*
- * a default constructed URLScheme is == PROTO_NONE
+ * a default constructed URLScheme is == AnyP::PROTO_NONE
  */
 void
 testURLScheme::testDefaultConstructor()
 {
     URLScheme lhs;
-    URLScheme rhs(PROTO_NONE);
+    URLScheme rhs(AnyP::PROTO_NONE);
     CPPUNIT_ASSERT_EQUAL(lhs, rhs);
 }
 
@@ -95,10 +95,10 @@ testURLScheme::testDefaultConstructor()
 void
 testURLScheme::testConstructprotocol_t()
 {
-    URLScheme lhs_none(PROTO_NONE), rhs_none(PROTO_NONE);
+    URLScheme lhs_none(AnyP::PROTO_NONE), rhs_none(AnyP::PROTO_NONE);
     CPPUNIT_ASSERT_EQUAL(lhs_none, rhs_none);
 
-    URLScheme lhs_cacheobj(PROTO_CACHEOBJ), rhs_cacheobj(PROTO_CACHEOBJ);
+    URLScheme lhs_cacheobj(AnyP::PROTO_CACHE_OBJECT), rhs_cacheobj(AnyP::PROTO_CACHE_OBJECT);
     CPPUNIT_ASSERT_EQUAL(lhs_cacheobj, rhs_cacheobj);
     CPPUNIT_ASSERT(lhs_none != rhs_cacheobj);
 }
@@ -110,7 +110,7 @@ void
 testURLScheme::testConst_str()
 {
     String lhs("wais");
-    URLScheme wais(PROTO_WAIS);
+    URLScheme wais(AnyP::PROTO_WAIS);
     String rhs(wais.const_str());
     CPPUNIT_ASSERT_EQUAL(lhs, rhs);
 }
@@ -122,10 +122,10 @@ testURLScheme::testConst_str()
 void
 testURLScheme::testEqualprotocol_t()
 {
-    CPPUNIT_ASSERT(URLScheme() == PROTO_NONE);
-    CPPUNIT_ASSERT(not (URLScheme(PROTO_WAIS) == PROTO_HTTP));
-    CPPUNIT_ASSERT(PROTO_HTTP == URLScheme(PROTO_HTTP));
-    CPPUNIT_ASSERT(not (PROTO_CACHEOBJ == URLScheme(PROTO_HTTP)));
+    CPPUNIT_ASSERT(URLScheme() == AnyP::PROTO_NONE);
+    CPPUNIT_ASSERT(not (URLScheme(AnyP::PROTO_WAIS) == AnyP::PROTO_HTTP));
+    CPPUNIT_ASSERT(AnyP::PROTO_HTTP == URLScheme(AnyP::PROTO_HTTP));
+    CPPUNIT_ASSERT(not (AnyP::PROTO_CACHE_OBJECT == URLScheme(AnyP::PROTO_HTTP)));
 }
 
 /*
@@ -134,10 +134,10 @@ testURLScheme::testEqualprotocol_t()
 void
 testURLScheme::testNotEqualprotocol_t()
 {
-    CPPUNIT_ASSERT(URLScheme(PROTO_NONE) != PROTO_HTTP);
-    CPPUNIT_ASSERT(not (URLScheme(PROTO_HTTP) != PROTO_HTTP));
-    CPPUNIT_ASSERT(PROTO_NONE != URLScheme(PROTO_HTTP));
-    CPPUNIT_ASSERT(not (PROTO_WAIS != URLScheme(PROTO_WAIS)));
+    CPPUNIT_ASSERT(URLScheme(AnyP::PROTO_NONE) != AnyP::PROTO_HTTP);
+    CPPUNIT_ASSERT(not (URLScheme(AnyP::PROTO_HTTP) != AnyP::PROTO_HTTP));
+    CPPUNIT_ASSERT(AnyP::PROTO_NONE != URLScheme(AnyP::PROTO_HTTP));
+    CPPUNIT_ASSERT(not (AnyP::PROTO_WAIS != URLScheme(AnyP::PROTO_WAIS)));
 }
 
 /*
@@ -147,7 +147,7 @@ void
 testURLScheme::testStream()
 {
     std::ostringstream buffer;
-    buffer << URLScheme(PROTO_HTTP);
+    buffer << URLScheme(AnyP::PROTO_HTTP);
     String http_str("http");
     String from_buf(buffer.str().c_str());
     CPPUNIT_ASSERT_EQUAL(http_str, from_buf);
@@ -154,7 +154,9 @@ class DnsLookupDetails;
 typedef void FQDNH(const char *, const DnsLookupDetails &details, void *);
 typedef void IDCB(const char *ident, void *data);
 typedef void IPH(const ipcache_addrs *, const DnsLookupDetails &details, void *);
-typedef void IRCB(struct peer *, peer_t, protocol_t, void *, void *data);
+
+#include "anyp/ProtocolType.h"
+typedef void IRCB(struct peer *, peer_t, AnyP::ProtocolType, void *, void *data);
 
 class FwdServer;
 typedef void PSC(FwdServer *, void *);
@@ -40,7 +40,7 @@
 #include "rfc1738.h"
 
 static HttpRequest *urlParseFinish(const HttpRequestMethod& method,
-                                   const protocol_t protocol,
+                                   const AnyP::ProtocolType protocol,
                                    const char *const urlpath,
                                    const char *const host,
                                    const char *const login,
@@ -65,9 +65,9 @@ urlInitialize(void)
 {
     debugs(23, 5, "urlInitialize: Initializing...");
     /* this ensures that the number of protocol strings is the same as
-     * the enum slots allocated because the last enum is always 'TOTAL'.
+     * the enum slots allocated because the last enum is always 'MAX'.
      */
-    assert(strcmp(ProtocolStr[PROTO_MAX], "TOTAL") == 0);
+    assert(strcmp(AnyP::ProtocolType_str[AnyP::PROTO_MAX], "MAX") == 0);
     /*
      * These test that our matchDomainName() function works the
      * way we expect it to.
@@ -97,7 +97,7 @@ urlInitialize(void)
  * backwards compatibility, e defaults to NULL, in which case we
  * assume b is NULL-terminated.
  */
-protocol_t
+AnyP::ProtocolType
 urlParseProtocol(const char *b, const char *e)
 {
     /*
@@ -114,64 +114,64 @@ urlParseProtocol(const char *b, const char *e)
     /* test common stuff first */
 
     if (strncasecmp(b, "http", len) == 0)
-        return PROTO_HTTP;
+        return AnyP::PROTO_HTTP;
 
     if (strncasecmp(b, "ftp", len) == 0)
-        return PROTO_FTP;
+        return AnyP::PROTO_FTP;
 
     if (strncasecmp(b, "https", len) == 0)
-        return PROTO_HTTPS;
+        return AnyP::PROTO_HTTPS;
 
     if (strncasecmp(b, "file", len) == 0)
-        return PROTO_FTP;
+        return AnyP::PROTO_FTP;
 
     if (strncasecmp(b, "gopher", len) == 0)
-        return PROTO_GOPHER;
+        return AnyP::PROTO_GOPHER;
 
     if (strncasecmp(b, "wais", len) == 0)
-        return PROTO_WAIS;
+        return AnyP::PROTO_WAIS;
 
     if (strncasecmp(b, "cache_object", len) == 0)
-        return PROTO_CACHEOBJ;
+        return AnyP::PROTO_CACHE_OBJECT;
 
     if (strncasecmp(b, "urn", len) == 0)
-        return PROTO_URN;
+        return AnyP::PROTO_URN;
 
     if (strncasecmp(b, "whois", len) == 0)
-        return PROTO_WHOIS;
+        return AnyP::PROTO_WHOIS;
 
     if (strncasecmp(b, "internal", len) == 0)
-        return PROTO_INTERNAL;
+        return AnyP::PROTO_INTERNAL;
 
-    return PROTO_NONE;
+    return AnyP::PROTO_NONE;
 }
 
 int
-urlDefaultPort(protocol_t p)
+urlDefaultPort(AnyP::ProtocolType p)
 {
     switch (p) {
 
-    case PROTO_HTTP:
+    case AnyP::PROTO_HTTP:
         return 80;
 
-    case PROTO_HTTPS:
+    case AnyP::PROTO_HTTPS:
         return 443;
 
-    case PROTO_FTP:
+    case AnyP::PROTO_FTP:
         return 21;
 
-    case PROTO_GOPHER:
+    case AnyP::PROTO_GOPHER:
         return 70;
 
-    case PROTO_WAIS:
+    case AnyP::PROTO_WAIS:
         return 210;
 
-    case PROTO_CACHEOBJ:
+    case AnyP::PROTO_CACHE_OBJECT:
 
-    case PROTO_INTERNAL:
+    case AnyP::PROTO_INTERNAL:
         return CACHE_HTTP_PORT;
 
-    case PROTO_WHOIS:
+    case AnyP::PROTO_WHOIS:
         return 43;
 
     default:
@@ -210,7 +210,7 @@ urlParse(const HttpRequestMethod& method, char *url, HttpRequest *request)
     char *t = NULL;
     char *q = NULL;
     int port;
-    protocol_t protocol = PROTO_NONE;
+    AnyP::ProtocolType protocol = AnyP::PROTO_NONE;
     int l;
     int i;
     const char *src;
@@ -232,7 +232,7 @@ urlParse(const HttpRequestMethod& method, char *url, HttpRequest *request)
 
     } else if ((method == METHOD_OPTIONS || method == METHOD_TRACE) &&
                strcmp(url, "*") == 0) {
-        protocol = PROTO_HTTP;
+        protocol = AnyP::PROTO_HTTP;
         port = urlDefaultPort(protocol);
         return urlParseFinish(method, protocol, url, host, login, port, request);
     } else if (!strncmp(url, "urn:", 4)) {
@@ -425,7 +425,7 @@ urlParse(const HttpRequestMethod& method, char *url, HttpRequest *request)
  */
 static HttpRequest *
 urlParseFinish(const HttpRequestMethod& method,
-               const protocol_t protocol,
+               const AnyP::ProtocolType protocol,
                const char *const urlpath,
                const char *const host,
                const char *const login,
@@ -448,7 +448,7 @@ static HttpRequest *
 urnParse(const HttpRequestMethod& method, char *urn)
 {
     debugs(50, 5, "urnParse: " << urn);
-    return new HttpRequest(method, PROTO_URN, urn + 4);
+    return new HttpRequest(method, AnyP::PROTO_URN, urn + 4);
 }
 
 const char *
@@ -461,7 +461,7 @@ urlCanonical(HttpRequest * request)
     if (request->canonical)
         return request->canonical;
 
-    if (request->protocol == PROTO_URN) {
+    if (request->protocol == AnyP::PROTO_URN) {
         snprintf(urlbuf, MAX_URL, "urn:" SQUIDSTRINGPH,
                  SQUIDSTRINGPRINT(request->urlpath));
     } else {
@@ -478,8 +478,9 @@ urlCanonical(HttpRequest * request)
             if (request->port != urlDefaultPort(request->protocol))
                 snprintf(portbuf, 32, ":%d", request->port);
 
+            const URLScheme sch = request->protocol; // temporary, until bug 1961 URL handling is fixed.
             snprintf(urlbuf, MAX_URL, "%s://%s%s%s%s" SQUIDSTRINGPH,
-                     ProtocolStr[request->protocol],
+                     sch.const_str(),
                      request->login,
                      *request->login ? "@" : null_string,
                      request->GetHost(),
@@ -505,7 +506,7 @@ urlCanonicalClean(const HttpRequest * request)
     LOCAL_ARRAY(char, loginbuf, MAX_LOGIN_SZ + 1);
     char *t;
 
-    if (request->protocol == PROTO_URN) {
+    if (request->protocol == AnyP::PROTO_URN) {
         snprintf(buf, MAX_URL, "urn:" SQUIDSTRINGPH,
                  SQUIDSTRINGPRINT(request->urlpath));
     } else {
@@ -535,8 +536,9 @@ urlCanonicalClean(const HttpRequest * request)
                 strcat(loginbuf, "@");
             }
 
+            const URLScheme sch = request->protocol; // temporary, until bug 1961 URL handling is fixed.
             snprintf(buf, MAX_URL, "%s://%s%s%s" SQUIDSTRINGPH,
-                     ProtocolStr[request->protocol],
+                     sch.const_str(),
                      loginbuf,
                      request->GetHost(),
                      portbuf,
@@ -630,25 +632,26 @@ urlMakeAbsolute(const HttpRequest * req, const char *relUrl)
 
     char *urlbuf = (char *)xmalloc(MAX_URL * sizeof(char));
 
-    if (req->protocol == PROTO_URN) {
+    if (req->protocol == AnyP::PROTO_URN) {
         snprintf(urlbuf, MAX_URL, "urn:" SQUIDSTRINGPH,
                  SQUIDSTRINGPRINT(req->urlpath));
         return (urlbuf);
     }
 
     size_t urllen;
 
+    const URLScheme sch = req->protocol; // temporary, until bug 1961 URL handling is fixed.
     if (req->port != urlDefaultPort(req->protocol)) {
         urllen = snprintf(urlbuf, MAX_URL, "%s://%s%s%s:%d",
-                          ProtocolStr[req->protocol],
+                          sch.const_str(),
                           req->login,
                           *req->login ? "@" : null_string,
                           req->GetHost(),
                           req->port
                          );
     } else {
         urllen = snprintf(urlbuf, MAX_URL, "%s://%s%s%s",
-                          ProtocolStr[req->protocol],
+                          sch.const_str(),
                           req->login,
                           *req->login ? "@" : null_string,
                           req->GetHost()
@@ -808,32 +811,32 @@ urlCheckRequest(const HttpRequest * r)
     /* does method match the protocol? */
     switch (r->protocol) {
 
-    case PROTO_URN:
+    case AnyP::PROTO_URN:
 
-    case PROTO_HTTP:
+    case AnyP::PROTO_HTTP:
 
-    case PROTO_CACHEOBJ:
+    case AnyP::PROTO_CACHE_OBJECT:
         rc = 1;
         break;
 
-    case PROTO_FTP:
+    case AnyP::PROTO_FTP:
 
         if (r->method == METHOD_PUT)
             rc = 1;
 
-    case PROTO_GOPHER:
+    case AnyP::PROTO_GOPHER:
 
-    case PROTO_WAIS:
+    case AnyP::PROTO_WAIS:
 
-    case PROTO_WHOIS:
+    case AnyP::PROTO_WHOIS:
         if (r->method == METHOD_GET)
             rc = 1;
         else if (r->method == METHOD_HEAD)
             rc = 1;
 
         break;
 
-    case PROTO_HTTPS:
+    case AnyP::PROTO_HTTPS:
 #if USE_SSL
 
         rc = 1;
@@ -132,6 +132,8 @@ typedef struct {
     char *user_name;
     char *passwd;
     char *pub_auth;
+    char *workers;
+    char *processes;
 } cachemgr_request;
 
 /*
@@ -839,12 +841,14 @@ process_request(cachemgr_request * req)
     S.FreeAddrInfo(AI);
 
     l = snprintf(buf, sizeof(buf),
-                 "GET cache_object://%s/%s HTTP/1.0\r\n"
+                 "GET cache_object://%s/%s%s%s HTTP/1.0\r\n"
                  "Accept: */*\r\n"
                  "%s"			/* Authentication info or nothing */
                  "\r\n",
                  req->hostname,
                  req->action,
+                 req->workers? "?workers=" : (req->processes ? "?processes=" : ""),
+                 req->workers? req->workers : (req->processes ? req->processes: ""),
                  make_auth_header(req));
     if (write(s, buf, l) < 0) {
         fprintf(stderr,"ERROR: (%d) writing request: '%s'\n", errno, buf);
@@ -1009,6 +1013,10 @@ read_request(void)
             req->pub_auth = xstrdup(q), decode_pub_auth(req);
         else if (0 == strcasecmp(t, "operation"))
             req->action = xstrdup(q);
+        else if (0 == strcasecmp(t, "workers") && strlen(q))
+            req->workers = xstrdup(q);
+        else if (0 == strcasecmp(t, "processes") && strlen(q))
+            req->processes = xstrdup(q);
     }
 
     if (req->server && !req->hostname) {
@@ -1020,8 +1028,8 @@ read_request(void)
     }
 
     make_pub_auth(req);
-    debug("cmgr: got req: host: '%s' port: %d uname: '%s' passwd: '%s' auth: '%s' oper: '%s'\n",
-          safe_str(req->hostname), req->port, safe_str(req->user_name), safe_str(req->passwd), safe_str(req->pub_auth), safe_str(req->action));
+    debug("cmgr: got req: host: '%s' port: %d uname: '%s' passwd: '%s' auth: '%s' oper: '%s' workers: '%s' processes: '%s'\n",
+          safe_str(req->hostname), req->port, safe_str(req->user_name), safe_str(req->passwd), safe_str(req->pub_auth), safe_str(req->action), safe_str(req->workers), safe_str(req->processes));
     return req;
 }
 