diff --git a/.gitignore b/.gitignore
index 89036d4..596f33d 100644
--- a/.gitignore
+++ b/.gitignore
@@ -22,6 +22,8 @@ config.log
 config.status
 configure
 stamp-h1
+.dirstamp
+mk/Posix.mk
 
 # Build artifacts
 .deps
diff --git a/Basic.mk.template b/Basic.mk.template
index ab45f87..64cd9c3 100644
--- a/Basic.mk.template
+++ b/Basic.mk.template
@@ -28,20 +28,40 @@
 
 all:
 
-make_SOURCES = %make_SOURCES% remote-stub.c
+src = src/
+glob = glob/
+
+make_SOURCES = %make_SOURCES%
 glob_SOURCES = %glob_SOURCES%
+loadavg_SOURCES = %loadavg_SOURCES%
+alloca_SOURCES = %alloca_SOURCES%
 w32_SOURCES = %w32_SOURCES%
 vms_SOURCES = %vms_SOURCES%
 amiga_SOURCES = %amiga_SOURCES%
 
-OUTDIR = .
+posix_SOURCES = $(src)posixos.c
+remote_SOURCES = $(src)remote-stub.c
+
+OUTDIR =
 SRCDIR = .
 
 OBJEXT = o
 EXEEXT =
 
-PROG = $(OUTDIR)/make$(EXEEXT)
+PREFIX = /usr/local
+INCLUDEDIR = $(PREFIX)/include
+LIBDIR = $(PREFIX)/lib
+LOCALEDIR = $(PREFIX)/share
+
+PROG = $(OUTDIR)make$(EXEEXT)
+
+prog_SOURCES = $(make_SOURCES) $(remote_SOURCES)
+
+OBJECTS = $(patsubst %.c,$(OUTDIR)%.$(OBJEXT),$(prog_SOURCES))
 
+OBJDIRS = $(addsuffix .,$(sort $(dir $(OBJECTS))))
+
+# Use the default value of CC
 LD = $(CC)
 
 # Reserved for command-line override
@@ -49,9 +69,8 @@ CPPFLAGS =
 CFLAGS = -g -O2
 LDFLAGS =
 
-prog_SOURCES = $(make_SOURCES)
-
-extra_CPPFLAGS = -DHAVE_CONFIG_H -I$(OUTDIR) -I$(SRCDIR)
+extra_CPPFLAGS = -DHAVE_CONFIG_H -I$(OUTDIR)src -I$(SRCDIR)/src \
+	-DLIBDIR=\"$(LIBDIR)\" -DINCLUDEDIR=\"$(INCLUDEDIR)\" -DLOCALEDIR=\"$(LOCALDIR)\"
 extra_CFLAGS =
 extra_LDFLAGS = $(extra_CFLAGS) $(CFLAGS)
 
@@ -65,7 +84,10 @@ COMPILE.cmd = $(CC) $(extra_CFLAGS) $(CFLAGS) $(extra_CPPFLAGS) $(CPPFLAGS) $(TA
 
 LINK.cmd = $(LD) $(extra_LDFLAGS) $(LDFLAGS) $(TARGET_ARCH) $^ $(LDLIBS) $(LINK_OUTPUT)
 
-CHECK.cmd = cd tests && ./run_make_tests -make $(shell cd $(<D) && pwd)/$(<F)
+CHECK.cmd = cd $(SRCDIR)/tests && ./run_make_tests -make $(shell cd $(<D) && pwd)/$(<F)
+
+CP = cp
+CP.cmd = $(CP) $< $@
 
 MKDIR = mkdir -p
 MKDIR.cmd = $(MKDIR) $@
@@ -74,7 +96,7 @@ RM = rm -f
 RM.cmd = $(RM) $(OBJECTS) $(PROG)
 
 # Load overrides for the above variables.
-include $(wildcard mk/$(lastword $(subst -, ,$(MAKE_HOST)).mk))
+include $(firstword $(wildcard $(SRCDIR)/mk/$(lastword $(subst -, ,$(MAKE_HOST)).mk) $(OUTDIR)mk/Posix.mk $(SRCDIR)/mk/Posix.mk))
 
 VERSION = %VERSION%
 
@@ -82,16 +104,15 @@ VPATH = $(SRCDIR)
 
 all: $(PROG)
 
-OBJECTS = $(patsubst %.c,$(OUTDIR)/%.$(OBJEXT),$(prog_SOURCES))
-
 $(PROG): $(OBJECTS)
 	$(LINK.cmd)
 
-.SECONDEXPANSION:
-$(OBJECTS): $(OUTDIR)/%.$(OBJEXT): %.c | $$(@D)/.
+$(OBJECTS): $(OUTDIR)%.$(OBJEXT): %.c
 	$(COMPILE.cmd)
 
-$(addsuffix .,$(sort $(dir $(OBJECTS)))):
+$(OBJECTS): | $(OBJDIRS)
+
+$(OBJDIRS):
 	$(MKDIR.cmd)
 
 check: $(PROG)
diff --git a/Makefile.am b/Makefile.am
index 89e345e..28e21a5 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -16,7 +16,7 @@
 # You should have received a copy of the GNU General Public License along with
 # this program.  If not, see <http://www.gnu.org/licenses/>.
 
-AUTOMAKE_OPTIONS = dist-bzip2 silent-rules std-options subdir-objects
+AUTOMAKE_OPTIONS = dist-bzip2 silent-rules std-options subdir-objects nostdinc
 ACLOCAL_AMFLAGS = -I config
 
 MAKE_HOST =	@MAKE_HOST@
@@ -24,29 +24,37 @@ MAKE_HOST =	@MAKE_HOST@
 SUBDIRS =	glob config po doc
 
 bin_PROGRAMS =	make
-include_HEADERS = gnumake.h
+include_HEADERS = src/gnumake.h
 
-man_MANS =	make.1
+man_MANS =	doc/make.1
 
-make_SRCS =	ar.c arscan.c commands.c commands.h debug.h default.c dep.h \
-		dir.c expand.c file.c filedef.h function.c getopt.c getopt.h \
-		getopt1.c gettext.h guile.c hash.c hash.h implicit.c job.c \
-		job.h load.c loadapi.c main.c makeint.h misc.c os.h output.c \
-		output.h read.c remake.c rule.c rule.h signame.c strcache.c \
-		variable.c variable.h version.c vpath.c
+make_SRCS =	src/ar.c src/arscan.c src/commands.c src/commands.h \
+		src/debug.h src/default.c src/dep.h src/dir.c src/expand.c \
+		src/file.c src/filedef.h src/function.c src/getopt.c \
+		src/getopt.h src/getopt1.c src/gettext.h src/guile.c \
+		src/hash.c src/hash.h src/implicit.c src/job.c src/job.h \
+		src/load.c src/loadapi.c src/main.c src/makeint.h src/misc.c \
+		src/os.h src/output.c src/output.h src/read.c src/remake.c \
+		src/rule.c src/rule.h src/signame.c src/strcache.c \
+		src/variable.c src/variable.h src/version.c src/vpath.c
 
 glob_SRCS =	glob/fnmatch.c glob/fnmatch.h glob/glob.c glob/glob.h
 
-w32_SRCS =	w32/pathstuff.c w32/w32os.c w32/compat/dirent.c \
-		w32/compat/posixfcn.c w32/include/dirent.h w32/include/dlfcn.h \
-		w32/include/pathstuff.h w32/include/sub_proc.h \
-		w32/include/w32err.h w32/subproc/misc.c w32/subproc/proc.h \
-		w32/subproc/sub_proc.c w32/subproc/w32err.c
+loadavg_SRCS =	src/getloadavg.c
 
-vms_SRCS =	vms_exit.c vms_export_symbol.c vms_progname.c vmsdir.h \
-		vmsfunctions.c vmsify.c vmsjobs.c
+alloca_SRCS =	src/alloca.c
 
-amiga_SRCS =	amiga.c amiga.h
+w32_SRCS =	src/w32/pathstuff.c src/w32/w32os.c src/w32/compat/dirent.c \
+		src/w32/compat/posixfcn.c src/w32/include/dirent.h \
+		src/w32/include/dlfcn.h src/w32/include/pathstuff.h \
+		src/w32/include/sub_proc.h src/w32/include/w32err.h \
+		src/w32/subproc/misc.c src/w32/subproc/proc.h \
+		src/w32/subproc/sub_proc.c src/w32/subproc/w32err.c
+
+vms_SRCS =	src/vms_exit.c src/vms_export_symbol.c src/vms_progname.c \
+		src/vmsdir.h src/vmsfunctions.c src/vmsify.c
+
+amiga_SRCS =	src/amiga.c src/amiga.h
 
 make_SOURCES =	$(make_SRCS)
 EXTRA_make_SOURCES = $(amiga_SRCS) $(vms_SRCS)
@@ -56,42 +64,44 @@ make_LDADD =	$(GUILE_LIBS) $(LIBOBJS) $(ALLOCA) $(GLOBLIB) \
 
 localedir =	$(datadir)/locale
 
-AM_CPPFLAGS =	-DLIBDIR=\"$(libdir)\" -DINCLUDEDIR=\"$(includedir)\" \
-		-DLOCALEDIR=\"$(localedir)\" $(GLOBINC)
+AM_CPPFLAGS =	-Isrc -I$(srcdir)/src $(GLOBINC) -DLIBDIR=\"$(libdir)\" \
+		-DINCLUDEDIR=\"$(includedir)\" -DLOCALEDIR=\"$(localedir)\"
 
 AM_CFLAGS =	$(GUILE_CFLAGS)
 
 if WINDOWSENV
   make_SOURCES += $(w32_SRCS)
-  AM_CPPFLAGS  += -I $(top_srcdir)/w32/include
+  AM_CPPFLAGS  += -I $(top_srcdir)/src/w32/include
 else
-  make_SOURCES += posixos.c
+  make_SOURCES += src/posixos.c
 endif
 
 if USE_CUSTOMS
-  make_SOURCES += remote-cstms.c
+  make_SOURCES += src/remote-cstms.c
 else
-  make_SOURCES += remote-stub.c
+  make_SOURCES += src/remote-stub.c
 endif
 
 # Extra stuff to include in the distribution.
 
-mk_FILES =	Basic.mk mk/Amiga.mk mk/Windows32.mk mk/msdosdjgpp.mk
+mk_FILES =	Basic.mk mk/msdosdjgpp.mk mk/Amiga.mk mk/VMS.mk mk/Windows32.mk
+# We don't need this, since the standard automake output will do.
+#mk/Posix.mk.in
 
-# test/scripts are added via dist-hook below.
 test_FILES =	tests/run_make_tests tests/run_make_tests.bat \
 		tests/run_make_tests.pl tests/test_driver.pl \
 		tests/config-flags.pm.in tests/config_flags_pm.com \
 		tests/mkshadow tests/jhelp.pl tests/guile.supp tests/README
+# test/scripts are added via dist-hook below.
 
 EXTRA_DIST =	ChangeLog README build.sh.in $(man_MANS) \
 		README.customs README.OS2 \
-		README.Amiga SCOPTIONS config.ami \
-		README.DOS builddos.bat configh.dos \
-		README.W32 config.h.W32 build_w32.bat \
-		README.VMS makefile.vms makefile.com config.h-vms \
+		README.Amiga SCOPTIONS src/config.ami \
+		README.DOS builddos.bat src/configh.dos \
+		README.W32 build_w32.bat src/config.h.W32 \
+		README.VMS makefile.com src/config.h-vms src/vmsjobs.c \
 		vms_export_symbol_test.com \
-		gmk-default.scm gmk-default.h \
+		src/gmk-default.scm src/gmk-default.h \
 		$(mk_FILES) $(test_FILES)
 
 
@@ -130,12 +140,12 @@ install-exec-local:
 
 # --------------- Generate the Guile default module content
 
-guile.$(OBJEXT): gmk-default.h
-gmk-default.h: $(srcdir)/gmk-default.scm
+src/guile.$(OBJEXT): src/gmk-default.h
+src/gmk-default.h: $(srcdir)/src/gmk-default.scm
 	(echo 'static const char *const GUILE_module_defn = " '\\ \
 	  && sed -e 's/;.*//' -e '/^[ \t]*$$/d' -e 's/"/\\"/g' -e 's/$$/ \\/' \
-		 $(srcdir)/gmk-default.scm \
-	  && echo '";') > $@
+		 $(srcdir)/src/gmk-default.scm \
+	  && echo '";') > src/gmk-default.h
 
 # --------------- Local DIST Section
 
@@ -169,8 +179,8 @@ check-loadavg: loadavg$(EXEEXT)
 
 # The loadavg function is invoked during "make check" to test getloadavg.
 check_PROGRAMS = loadavg
-nodist_loadavg_SOURCES = getloadavg.c
-loadavg_CPPFLAGS = -DTEST
+nodist_loadavg_SOURCES = $(loadavg_SRCS)
+loadavg_CPPFLAGS = -Isrc -I$(srcdir)/src -DTEST
 loadavg_LDADD = @GETLOADAVG_LIBS@
 
 # > check-regression
diff --git a/NEWS b/NEWS
index a452fae..aa01191 100644
--- a/NEWS
+++ b/NEWS
@@ -43,6 +43,9 @@ http://sv.gnu.org/bugs/index.php?group=make&report_id=111&fix_release_id=108&set
   N-processor systems with less fear of overload.
   Patch provided by Sven C. Dack <sven.c.dack@sky.com>
 
+* Rework the source distribution to move source files into the src/*
+  subdirectory.  This aligns with modern best practices in GNU.
+
 * The previous limit of 63 jobs under -jN on MS-Windows is now
   increased to 4095.  That limit includes the subprocess started by
   the $(shell) function.
diff --git a/README.DOS.template b/README.DOS.template
index ae15bd7..5e75f9f 100644
--- a/README.DOS.template
+++ b/README.DOS.template
@@ -67,7 +67,7 @@ To build from sources:
    4. If you are building from outside of the source directory, you
       need to tell Make where the sources are, like this:
 
-          make srcdir=c:/djgpp/gnu/make
+          make -f c:/djgpp/gnu/make/Basic.mk SRCDIR=c:/djgpp/gnu/make
 
       or:
 
diff --git a/SCOPTIONS b/SCOPTIONS
index 3d69fb4..758f82f 100644
--- a/SCOPTIONS
+++ b/SCOPTIONS
@@ -3,6 +3,7 @@ OPTIMIZE
 NOVERSION
 OPTIMIZERTIME
 OPTIMIZERALIAS
+DEFINE HAVE_CONFIG_H
 DEFINE INCLUDEDIR="include:"
 DEFINE LIBDIR="lib:"
 DEFINE NO_ALLOCA
diff --git a/acinclude.m4 b/acinclude.m4
deleted file mode 100644
index 544fd86..0000000
--- a/acinclude.m4
+++ /dev/null
@@ -1,132 +0,0 @@
-dnl acinclude.m4 -- Extra macros needed for GNU make.
-dnl
-dnl Automake will incorporate this into its generated aclocal.m4.
-dnl Copyright (C) 1998-2017 Free Software Foundation, Inc.
-dnl This file is part of GNU Make.
-dnl
-dnl GNU Make is free software; you can redistribute it and/or modify it under
-dnl the terms of the GNU General Public License as published by the Free
-dnl Software Foundation; either version 3 of the License, or (at your option)
-dnl any later version.
-dnl
-dnl GNU Make is distributed in the hope that it will be useful, but WITHOUT
-dnl ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-dnl FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for.
-dnl more details.
-dnl
-dnl You should have received a copy of the GNU General Public License along
-dnl with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-dnl ---------------------------------------------------------------------------
-dnl Got this from the lynx 2.8 distribution.
-dnl by T.E.Dickey <dickey@clark.net>
-dnl and Jim Spath <jspath@mail.bcpl.lib.md.us>
-dnl and Philippe De Muyter <phdm@macqel.be>
-dnl
-dnl Created: 1997/1/28
-dnl Updated: 1997/12/23
-dnl ---------------------------------------------------------------------------
-dnl After checking for functions in the default $LIBS, make a further check
-dnl for the functions that are netlib-related (these aren't always in the
-dnl libc, etc., and have to be handled specially because there are conflicting
-dnl and broken implementations.
-dnl Common library requirements (in order):
-dnl	-lresolv -lsocket -lnsl
-dnl	-lnsl -lsocket
-dnl	-lsocket
-dnl	-lbsd
-AC_DEFUN([CF_NETLIBS],[
-cf_test_netlibs=no
-AC_MSG_CHECKING(for network libraries)
-AC_CACHE_VAL(cf_cv_netlibs,[
-AC_MSG_RESULT(working...)
-cf_cv_netlibs=""
-cf_test_netlibs=yes
-AC_CHECK_FUNCS(gethostname,,[
-	CF_RECHECK_FUNC(gethostname,nsl,cf_cv_netlibs,[
-		CF_RECHECK_FUNC(gethostname,socket,cf_cv_netlibs)])])
-#
-# FIXME:  sequent needs this library (i.e., -lsocket -linet -lnsl), but
-# I don't know the entrypoints - 97/7/22 TD
-AC_CHECK_LIB(inet,main,cf_cv_netlibs="-linet $cf_cv_netlibs")
-#
-if test "$ac_cv_func_lsocket" != no ; then
-AC_CHECK_FUNCS(socket,,[
-	CF_RECHECK_FUNC(socket,socket,cf_cv_netlibs,[
-		CF_RECHECK_FUNC(socket,bsd,cf_cv_netlibs)])])
-fi
-#
-AC_CHECK_FUNCS(gethostbyname,,[
-	CF_RECHECK_FUNC(gethostbyname,nsl,cf_cv_netlibs)])
-])
-LIBS="$LIBS $cf_cv_netlibs"
-test $cf_test_netlibs = no && echo "$cf_cv_netlibs" >&AC_FD_MSG
-])dnl
-dnl ---------------------------------------------------------------------------
-dnl Re-check on a function to see if we can pick it up by adding a library.
-dnl	$1 = function to check
-dnl	$2 = library to check in
-dnl	$3 = environment to update (e.g., $LIBS)
-dnl	$4 = what to do if this fails
-dnl
-dnl This uses 'unset' if the shell happens to support it, but leaves the
-dnl configuration variable set to 'unknown' if not.  This is a little better
-dnl than the normal autoconf test, which gives misleading results if a test
-dnl for the function is made (e.g., with AC_CHECK_FUNC) after this macro is
-dnl used (autoconf does not distinguish between a null token and one that is
-dnl set to 'no').
-AC_DEFUN([CF_RECHECK_FUNC],[
-AC_CHECK_LIB($2,$1,[
-	CF_UPPER(cf_tr_func,$1)
-	AC_DEFINE_UNQUOTED(HAVE_$cf_tr_func,1,[Define if you have function $1])
-	ac_cv_func_$1=yes
-	$3="-l$2 [$]$3"],[
-	ac_cv_func_$1=unknown
-	unset ac_cv_func_$1 2>/dev/null
-	$4],
-	[[$]$3])
-])dnl
-dnl ---------------------------------------------------------------------------
-dnl Make an uppercase version of a variable
-dnl $1=uppercase($2)
-AC_DEFUN([CF_UPPER],
-[
-changequote(,)dnl
-$1=`echo $2 | tr '[a-z]' '[A-Z]'`
-changequote([,])dnl
-])dnl
-
-
-dnl ---------------------------------------------------------------------------
-dnl From Paul Eggert <eggert@twinsun.com>
-dnl Update for Darwin by Troy Runkel <Troy.Runkel@mathworks.com>
-dnl Update for AIX by Olexiy Buyanskyy (Savannah bug 32485)
-
-AC_DEFUN([AC_STRUCT_ST_MTIM_NSEC],
- [AC_CACHE_CHECK([for nanoseconds field of struct stat],
-   ac_cv_struct_st_mtim_nsec,
-   [ac_save_CPPFLAGS="$CPPFLAGS"
-    ac_cv_struct_st_mtim_nsec=no
-    # st_mtim.tv_nsec -- the usual case
-    # st_mtim._tv_nsec -- Solaris 2.6, if
-    #	(defined _XOPEN_SOURCE && _XOPEN_SOURCE_EXTENDED == 1
-    #	 && !defined __EXTENSIONS__)
-    # st_mtim.st__tim.tv_nsec -- UnixWare 2.1.2
-    # st_mtime_n -- AIX 5.2 and above
-    # st_mtimespec.tv_nsec -- Darwin (Mac OSX)
-    for ac_val in st_mtim.tv_nsec st_mtim._tv_nsec st_mtim.st__tim.tv_nsec st_mtime_n st_mtimespec.tv_nsec; do
-      CPPFLAGS="$ac_save_CPPFLAGS -DST_MTIM_NSEC=$ac_val"
-      AC_TRY_COMPILE([#include <sys/types.h>
-#include <sys/stat.h>
-	], [struct stat s; s.ST_MTIM_NSEC;],
-        [ac_cv_struct_st_mtim_nsec=$ac_val; break])
-    done
-    CPPFLAGS="$ac_save_CPPFLAGS"
-   ])
-
-  if test $ac_cv_struct_st_mtim_nsec != no; then
-    AC_DEFINE_UNQUOTED([ST_MTIM_NSEC], [$ac_cv_struct_st_mtim_nsec],
-	[Define if struct stat contains a nanoseconds field])
-  fi
- ]
-)
diff --git a/alloca.c b/alloca.c
deleted file mode 100644
index 02ac921..0000000
--- a/alloca.c
+++ /dev/null
@@ -1,503 +0,0 @@
-/* alloca.c -- allocate automatically reclaimed memory
-   (Mostly) portable public-domain implementation -- D A Gwyn
-
-   This implementation of the PWB library alloca function,
-   which is used to allocate space off the run-time stack so
-   that it is automatically reclaimed upon procedure exit,
-   was inspired by discussions with J. Q. Johnson of Cornell.
-   J.Otto Tennant <jot@cray.com> contributed the Cray support.
-
-   There are some preprocessor constants that can
-   be defined when compiling for your specific system, for
-   improved efficiency; however, the defaults should be okay.
-
-   The general concept of this implementation is to keep
-   track of all alloca-allocated blocks, and reclaim any
-   that are found to be deeper in the stack than the current
-   invocation.  This heuristic does not reclaim storage as
-   soon as it becomes invalid, but it will do so eventually.
-
-   As a special case, alloca(0) reclaims storage without
-   allocating any.  It is a good idea to use alloca(0) in
-   your main control loop, etc. to force garbage collection.  */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#ifdef HAVE_STRING_H
-#include <string.h>
-#endif
-#ifdef HAVE_STDLIB_H
-#include <stdlib.h>
-#endif
-
-#ifdef emacs
-#include "blockinput.h"
-#endif
-
-/* If compiling with GCC 2, this file's not needed.  */
-#if !defined (__GNUC__) || __GNUC__ < 2
-
-/* If someone has defined alloca as a macro,
-   there must be some other way alloca is supposed to work.  */
-#ifndef alloca
-
-#ifdef emacs
-#ifdef static
-/* actually, only want this if static is defined as ""
-   -- this is for usg, in which emacs must undefine static
-   in order to make unexec workable
-   */
-#ifndef STACK_DIRECTION
-you
-lose
--- must know STACK_DIRECTION at compile-time
-#endif /* STACK_DIRECTION undefined */
-#endif /* static */
-#endif /* emacs */
-
-/* If your stack is a linked list of frames, you have to
-   provide an "address metric" ADDRESS_FUNCTION macro.  */
-
-#if defined (CRAY) && defined (CRAY_STACKSEG_END)
-long i00afunc ();
-#define ADDRESS_FUNCTION(arg) (char *) i00afunc (&(arg))
-#else
-#define ADDRESS_FUNCTION(arg) &(arg)
-#endif
-
-#if __STDC__
-typedef void *pointer;
-#else
-typedef char *pointer;
-#endif
-
-#ifndef NULL
-#define	NULL	0
-#endif
-
-/* Different portions of Emacs need to call different versions of
-   malloc.  The Emacs executable needs alloca to call xmalloc, because
-   ordinary malloc isn't protected from input signals.  On the other
-   hand, the utilities in lib-src need alloca to call malloc; some of
-   them are very simple, and don't have an xmalloc routine.
-
-   Non-Emacs programs expect this to call use xmalloc.
-
-   Callers below should use malloc.  */
-
-#ifndef emacs
-#define malloc xmalloc
-#endif
-extern pointer malloc ();
-
-/* Define STACK_DIRECTION if you know the direction of stack
-   growth for your system; otherwise it will be automatically
-   deduced at run-time.
-
-   STACK_DIRECTION > 0 => grows toward higher addresses
-   STACK_DIRECTION < 0 => grows toward lower addresses
-   STACK_DIRECTION = 0 => direction of growth unknown  */
-
-#ifndef STACK_DIRECTION
-#define	STACK_DIRECTION	0	/* Direction unknown.  */
-#endif
-
-#if STACK_DIRECTION != 0
-
-#define	STACK_DIR	STACK_DIRECTION	/* Known at compile-time.  */
-
-#else /* STACK_DIRECTION == 0; need run-time code.  */
-
-static int stack_dir;		/* 1 or -1 once known.  */
-#define	STACK_DIR	stack_dir
-
-static void
-find_stack_direction (void)
-{
-  static char *addr = NULL;	/* Address of first 'dummy', once known.  */
-  auto char dummy;		/* To get stack address.  */
-
-  if (addr == NULL)
-    {				/* Initial entry.  */
-      addr = ADDRESS_FUNCTION (dummy);
-
-      find_stack_direction ();	/* Recurse once.  */
-    }
-  else
-    {
-      /* Second entry.  */
-      if (ADDRESS_FUNCTION (dummy) > addr)
-	stack_dir = 1;		/* Stack grew upward.  */
-      else
-	stack_dir = -1;		/* Stack grew downward.  */
-    }
-}
-
-#endif /* STACK_DIRECTION == 0 */
-
-/* An "alloca header" is used to:
-   (a) chain together all alloca'ed blocks;
-   (b) keep track of stack depth.
-
-   It is very important that sizeof(header) agree with malloc
-   alignment chunk size.  The following default should work okay.  */
-
-#ifndef	ALIGN_SIZE
-#define	ALIGN_SIZE	sizeof(double)
-#endif
-
-typedef union hdr
-{
-  char align[ALIGN_SIZE];	/* To force sizeof(header).  */
-  struct
-    {
-      union hdr *next;		/* For chaining headers.  */
-      char *deep;		/* For stack depth measure.  */
-    } h;
-} header;
-
-static header *last_alloca_header = NULL;	/* -> last alloca header.  */
-
-/* Return a pointer to at least SIZE bytes of storage,
-   which will be automatically reclaimed upon exit from
-   the procedure that called alloca.  Originally, this space
-   was supposed to be taken from the current stack frame of the
-   caller, but that method cannot be made to work for some
-   implementations of C, for example under Gould's UTX/32.  */
-
-pointer
-alloca (unsigned size)
-{
-  auto char probe;		/* Probes stack depth: */
-  register char *depth = ADDRESS_FUNCTION (probe);
-
-#if STACK_DIRECTION == 0
-  if (STACK_DIR == 0)		/* Unknown growth direction.  */
-    find_stack_direction ();
-#endif
-
-  /* Reclaim garbage, defined as all alloca'd storage that
-     was allocated from deeper in the stack than currently.  */
-
-  {
-    register header *hp;	/* Traverses linked list.  */
-
-#ifdef emacs
-    BLOCK_INPUT;
-#endif
-
-    for (hp = last_alloca_header; hp != NULL;)
-      if ((STACK_DIR > 0 && hp->h.deep > depth)
-	  || (STACK_DIR < 0 && hp->h.deep < depth))
-	{
-	  register header *np = hp->h.next;
-
-	  free ((pointer) hp);	/* Collect garbage.  */
-
-	  hp = np;		/* -> next header.  */
-	}
-      else
-	break;			/* Rest are not deeper.  */
-
-    last_alloca_header = hp;	/* -> last valid storage.  */
-
-#ifdef emacs
-    UNBLOCK_INPUT;
-#endif
-  }
-
-  if (size == 0)
-    return NULL;		/* No allocation required.  */
-
-  /* Allocate combined header + user data storage.  */
-
-  {
-    register pointer new = malloc (sizeof (header) + size);
-    /* Address of header.  */
-
-    if (new == 0)
-      abort();
-
-    ((header *) new)->h.next = last_alloca_header;
-    ((header *) new)->h.deep = depth;
-
-    last_alloca_header = (header *) new;
-
-    /* User storage begins just after header.  */
-
-    return (pointer) ((char *) new + sizeof (header));
-  }
-}
-
-#if defined (CRAY) && defined (CRAY_STACKSEG_END)
-
-#ifdef DEBUG_I00AFUNC
-#include <stdio.h>
-#endif
-
-#ifndef CRAY_STACK
-#define CRAY_STACK
-#ifndef CRAY2
-/* Stack structures for CRAY-1, CRAY X-MP, and CRAY Y-MP */
-struct stack_control_header
-  {
-    long shgrow:32;		/* Number of times stack has grown.  */
-    long shaseg:32;		/* Size of increments to stack.  */
-    long shhwm:32;		/* High water mark of stack.  */
-    long shsize:32;		/* Current size of stack (all segments).  */
-  };
-
-/* The stack segment linkage control information occurs at
-   the high-address end of a stack segment.  (The stack
-   grows from low addresses to high addresses.)  The initial
-   part of the stack segment linkage control information is
-   0200 (octal) words.  This provides for register storage
-   for the routine which overflows the stack.  */
-
-struct stack_segment_linkage
-  {
-    long ss[0200];		/* 0200 overflow words.  */
-    long sssize:32;		/* Number of words in this segment.  */
-    long ssbase:32;		/* Offset to stack base.  */
-    long:32;
-    long sspseg:32;		/* Offset to linkage control of previous
-				   segment of stack.  */
-    long:32;
-    long sstcpt:32;		/* Pointer to task common address block.  */
-    long sscsnm;		/* Private control structure number for
-				   microtasking.  */
-    long ssusr1;		/* Reserved for user.  */
-    long ssusr2;		/* Reserved for user.  */
-    long sstpid;		/* Process ID for pid based multi-tasking.  */
-    long ssgvup;		/* Pointer to multitasking thread giveup.  */
-    long sscray[7];		/* Reserved for Cray Research.  */
-    long ssa0;
-    long ssa1;
-    long ssa2;
-    long ssa3;
-    long ssa4;
-    long ssa5;
-    long ssa6;
-    long ssa7;
-    long sss0;
-    long sss1;
-    long sss2;
-    long sss3;
-    long sss4;
-    long sss5;
-    long sss6;
-    long sss7;
-  };
-
-#else /* CRAY2 */
-/* The following structure defines the vector of words
-   returned by the STKSTAT library routine.  */
-struct stk_stat
-  {
-    long now;			/* Current total stack size.  */
-    long maxc;			/* Amount of contiguous space which would
-				   be required to satisfy the maximum
-				   stack demand to date.  */
-    long high_water;		/* Stack high-water mark.  */
-    long overflows;		/* Number of stack overflow ($STKOFEN) calls.  */
-    long hits;			/* Number of internal buffer hits.  */
-    long extends;		/* Number of block extensions.  */
-    long stko_mallocs;		/* Block allocations by $STKOFEN.  */
-    long underflows;		/* Number of stack underflow calls ($STKRETN).  */
-    long stko_free;		/* Number of deallocations by $STKRETN.  */
-    long stkm_free;		/* Number of deallocations by $STKMRET.  */
-    long segments;		/* Current number of stack segments.  */
-    long maxs;			/* Maximum number of stack segments so far.  */
-    long pad_size;		/* Stack pad size.  */
-    long current_address;	/* Current stack segment address.  */
-    long current_size;		/* Current stack segment size.  This
-				   number is actually corrupted by STKSTAT to
-				   include the fifteen word trailer area.  */
-    long initial_address;	/* Address of initial segment.  */
-    long initial_size;		/* Size of initial segment.  */
-  };
-
-/* The following structure describes the data structure which trails
-   any stack segment.  I think that the description in 'asdef' is
-   out of date.  I only describe the parts that I am sure about.  */
-
-struct stk_trailer
-  {
-    long this_address;		/* Address of this block.  */
-    long this_size;		/* Size of this block (does not include
-				   this trailer).  */
-    long unknown2;
-    long unknown3;
-    long link;			/* Address of trailer block of previous
-				   segment.  */
-    long unknown5;
-    long unknown6;
-    long unknown7;
-    long unknown8;
-    long unknown9;
-    long unknown10;
-    long unknown11;
-    long unknown12;
-    long unknown13;
-    long unknown14;
-  };
-
-#endif /* CRAY2 */
-#endif /* not CRAY_STACK */
-
-#ifdef CRAY2
-/* Determine a "stack measure" for an arbitrary ADDRESS.
-   I doubt that "lint" will like this much.  */
-
-static long
-i00afunc (long *address)
-{
-  struct stk_stat status;
-  struct stk_trailer *trailer;
-  long *block, size;
-  long result = 0;
-
-  /* We want to iterate through all of the segments.  The first
-     step is to get the stack status structure.  We could do this
-     more quickly and more directly, perhaps, by referencing the
-     $LM00 common block, but I know that this works.  */
-
-  STKSTAT (&status);
-
-  /* Set up the iteration.  */
-
-  trailer = (struct stk_trailer *) (status.current_address
-				    + status.current_size
-				    - 15);
-
-  /* There must be at least one stack segment.  Therefore it is
-     a fatal error if "trailer" is null.  */
-
-  if (trailer == 0)
-    abort ();
-
-  /* Discard segments that do not contain our argument address.  */
-
-  while (trailer != 0)
-    {
-      block = (long *) trailer->this_address;
-      size = trailer->this_size;
-      if (block == 0 || size == 0)
-	abort ();
-      trailer = (struct stk_trailer *) trailer->link;
-      if ((block <= address) && (address < (block + size)))
-	break;
-    }
-
-  /* Set the result to the offset in this segment and add the sizes
-     of all predecessor segments.  */
-
-  result = address - block;
-
-  if (trailer == 0)
-    {
-      return result;
-    }
-
-  do
-    {
-      if (trailer->this_size <= 0)
-	abort ();
-      result += trailer->this_size;
-      trailer = (struct stk_trailer *) trailer->link;
-    }
-  while (trailer != 0);
-
-  /* We are done.  Note that if you present a bogus address (one
-     not in any segment), you will get a different number back, formed
-     from subtracting the address of the first block.  This is probably
-     not what you want.  */
-
-  return (result);
-}
-
-#else /* not CRAY2 */
-/* Stack address function for a CRAY-1, CRAY X-MP, or CRAY Y-MP.
-   Determine the number of the cell within the stack,
-   given the address of the cell.  The purpose of this
-   routine is to linearize, in some sense, stack addresses
-   for alloca.  */
-
-static long
-i00afunc (long address)
-{
-  long stkl = 0;
-
-  long size, pseg, this_segment, stack;
-  long result = 0;
-
-  struct stack_segment_linkage *ssptr;
-
-  /* Register B67 contains the address of the end of the
-     current stack segment.  If you (as a subprogram) store
-     your registers on the stack and find that you are past
-     the contents of B67, you have overflowed the segment.
-
-     B67 also points to the stack segment linkage control
-     area, which is what we are really interested in.  */
-
-  stkl = CRAY_STACKSEG_END ();
-  ssptr = (struct stack_segment_linkage *) stkl;
-
-  /* If one subtracts 'size' from the end of the segment,
-     one has the address of the first word of the segment.
-
-     If this is not the first segment, 'pseg' will be
-     nonzero.  */
-
-  pseg = ssptr->sspseg;
-  size = ssptr->sssize;
-
-  this_segment = stkl - size;
-
-  /* It is possible that calling this routine itself caused
-     a stack overflow.  Discard stack segments which do not
-     contain the target address.  */
-
-  while (!(this_segment <= address && address <= stkl))
-    {
-#ifdef DEBUG_I00AFUNC
-      fprintf (stderr, "%011o %011o %011o\n", this_segment, address, stkl);
-#endif
-      if (pseg == 0)
-	break;
-      stkl = stkl - pseg;
-      ssptr = (struct stack_segment_linkage *) stkl;
-      size = ssptr->sssize;
-      pseg = ssptr->sspseg;
-      this_segment = stkl - size;
-    }
-
-  result = address - this_segment;
-
-  /* If you subtract pseg from the current end of the stack,
-     you get the address of the previous stack segment's end.
-     This seems a little convoluted to me, but I'll bet you save
-     a cycle somewhere.  */
-
-  while (pseg != 0)
-    {
-#ifdef DEBUG_I00AFUNC
-      fprintf (stderr, "%011o %011o\n", pseg, size);
-#endif
-      stkl = stkl - pseg;
-      ssptr = (struct stack_segment_linkage *) stkl;
-      size = ssptr->sssize;
-      pseg = ssptr->sspseg;
-      result += size;
-    }
-  return (result);
-}
-
-#endif /* not CRAY2 */
-#endif /* CRAY */
-
-#endif /* no alloca */
-#endif /* not GCC version 2 */
diff --git a/amiga.c b/amiga.c
deleted file mode 100644
index c1b31db..0000000
--- a/amiga.c
+++ /dev/null
@@ -1,117 +0,0 @@
-/* Running commands on Amiga
-Copyright (C) 1995-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-#include "variable.h"
-#include "amiga.h"
-#include <assert.h>
-#include <exec/memory.h>
-#include <dos/dostags.h>
-#include <proto/exec.h>
-#include <proto/dos.h>
-
-static const char Amiga_version[] = "$VER: Make 3.74.3 (12.05.96) \n"
-                    "Amiga Port by A. Digulla (digulla@home.lake.de)";
-
-int
-MyExecute (char **argv)
-{
-    char * buffer, * ptr;
-    char ** aptr;
-    int len = 0;
-    int status;
-
-    for (aptr=argv; *aptr; aptr++)
-    {
-        len += strlen (*aptr) + 4;
-    }
-
-    buffer = AllocMem (len, MEMF_ANY);
-
-    if (!buffer)
-      O (fatal, NILF, "MyExecute: Cannot allocate space for calling a command\n");
-
-    ptr = buffer;
-
-    for (aptr=argv; *aptr; aptr++)
-    {
-        if (((*aptr)[0] == ';' && !(*aptr)[1]))
-        {
-            *ptr ++ = '"';
-            strcpy (ptr, *aptr);
-            ptr += strlen (ptr);
-            *ptr ++ = '"';
-        }
-        else if ((*aptr)[0] == '@' && (*aptr)[1] == '@' && !(*aptr)[2])
-        {
-            *ptr ++ = '\n';
-            continue;
-        }
-        else
-        {
-            strcpy (ptr, *aptr);
-            ptr += strlen (ptr);
-        }
-        *ptr ++ = ' ';
-        *ptr = 0;
-    }
-
-    ptr[-1] = '\n';
-
-    status = SystemTags (buffer,
-        SYS_UserShell, TRUE,
-        TAG_END);
-
-    FreeMem (buffer, len);
-
-    if (SetSignal (0L,0L) & SIGBREAKF_CTRL_C)
-        status = 20;
-
-    /* Warnings don't count */
-    if (status == 5)
-        status = 0;
-
-    return status;
-}
-
-char *
-wildcard_expansion (char *wc, char *o)
-{
-#   define PATH_SIZE    1024
-    struct AnchorPath * apath;
-
-    if ( (apath = AllocMem (sizeof (struct AnchorPath) + PATH_SIZE,
-            MEMF_CLEAR))
-        )
-    {
-        apath->ap_Strlen = PATH_SIZE;
-
-        if (MatchFirst (wc, apath) == 0)
-        {
-            do
-            {
-                o = variable_buffer_output (o, apath->ap_Buf,
-                        strlen (apath->ap_Buf));
-                o = variable_buffer_output (o, " ",1);
-            } while (MatchNext (apath) == 0);
-        }
-
-        MatchEnd (apath);
-        FreeMem (apath, sizeof (struct AnchorPath) + PATH_SIZE);
-    }
-
-    return o;
-}
diff --git a/amiga.h b/amiga.h
deleted file mode 100644
index 940bc3a..0000000
--- a/amiga.h
+++ /dev/null
@@ -1,18 +0,0 @@
-/* Definitions for amiga specific things
-Copyright (C) 1995-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-int MyExecute (char ** argv);
-char * wildcard_expansion (char * wc, char * o);
diff --git a/ar.c b/ar.c
deleted file mode 100644
index 65ea01c..0000000
--- a/ar.c
+++ /dev/null
@@ -1,328 +0,0 @@
-/* Interface to 'ar' archives for GNU Make.
-Copyright (C) 1988-2017 Free Software Foundation, Inc.
-
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-
-#ifndef NO_ARCHIVES
-
-#include "filedef.h"
-#include "dep.h"
-#include <fnmatch.h>
-
-/* Return nonzero if NAME is an archive-member reference, zero if not.  An
-   archive-member reference is a name like 'lib(member)' where member is a
-   non-empty string.
-   If a name like 'lib((entry))' is used, a fatal error is signaled at
-   the attempt to use this unsupported feature.  */
-
-int
-ar_name (const char *name)
-{
-  const char *p = strchr (name, '(');
-  const char *end;
-
-  if (p == 0 || p == name)
-    return 0;
-
-  end = p + strlen (p) - 1;
-  if (*end != ')' || end == p + 1)
-    return 0;
-
-  if (p[1] == '(' && end[-1] == ')')
-    OS (fatal, NILF, _("attempt to use unsupported feature: '%s'"), name);
-
-  return 1;
-}
-
-
-/* Parse the archive-member reference NAME into the archive and member names.
-   Creates one allocated string containing both names, pointed to by ARNAME_P.
-   MEMNAME_P points to the member.  */
-
-void
-ar_parse_name (const char *name, char **arname_p, char **memname_p)
-{
-  char *p;
-
-  *arname_p = xstrdup (name);
-  p = strchr (*arname_p, '(');
-  *(p++) = '\0';
-  p[strlen (p) - 1] = '\0';
-  *memname_p = p;
-}
-
-
-/* This function is called by 'ar_scan' to find which member to look at.  */
-
-/* ARGSUSED */
-static long int
-ar_member_date_1 (int desc UNUSED, const char *mem, int truncated,
-                  long int hdrpos UNUSED, long int datapos UNUSED,
-                  long int size UNUSED, long int date,
-                  int uid UNUSED, int gid UNUSED, unsigned int mode UNUSED,
-                  const void *name)
-{
-  return ar_name_equal (name, mem, truncated) ? date : 0;
-}
-
-/* Return the modtime of NAME.  */
-
-time_t
-ar_member_date (const char *name)
-{
-  char *arname;
-  char *memname;
-  long int val;
-
-  ar_parse_name (name, &arname, &memname);
-
-  /* Make sure we know the modtime of the archive itself because we are
-     likely to be called just before commands to remake a member are run,
-     and they will change the archive itself.
-
-     But we must be careful not to enter_file the archive itself if it does
-     not exist, because pattern_search assumes that files found in the data
-     base exist or can be made.  */
-  {
-    struct file *arfile;
-    arfile = lookup_file (arname);
-    if (arfile == 0 && file_exists_p (arname))
-      arfile = enter_file (strcache_add (arname));
-
-    if (arfile != 0)
-      (void) f_mtime (arfile, 0);
-  }
-
-  val = ar_scan (arname, ar_member_date_1, memname);
-
-  free (arname);
-
-  return (val <= 0 ? (time_t) -1 : (time_t) val);
-}
-
-/* Set the archive-member NAME's modtime to now.  */
-
-#ifdef VMS
-int
-ar_touch (const char *name)
-{
-  O (error, NILF, _("touch archive member is not available on VMS"));
-  return -1;
-}
-#else
-int
-ar_touch (const char *name)
-{
-  char *arname, *memname;
-  int val;
-
-  ar_parse_name (name, &arname, &memname);
-
-  /* Make sure we know the modtime of the archive itself before we
-     touch the member, since this will change the archive modtime.  */
-  {
-    struct file *arfile;
-    arfile = enter_file (strcache_add (arname));
-    f_mtime (arfile, 0);
-  }
-
-  val = 1;
-  switch (ar_member_touch (arname, memname))
-    {
-    case -1:
-      OS (error, NILF, _("touch: Archive '%s' does not exist"), arname);
-      break;
-    case -2:
-      OS (error, NILF, _("touch: '%s' is not a valid archive"), arname);
-      break;
-    case -3:
-      perror_with_name ("touch: ", arname);
-      break;
-    case 1:
-      OSS (error, NILF,
-           _("touch: Member '%s' does not exist in '%s'"), memname, arname);
-      break;
-    case 0:
-      val = 0;
-      break;
-    default:
-      OS (error, NILF,
-          _("touch: Bad return code from ar_member_touch on '%s'"), name);
-    }
-
-  free (arname);
-
-  return val;
-}
-#endif /* !VMS */
-
-/* State of an 'ar_glob' run, passed to 'ar_glob_match'.  */
-
-/* On VMS, (object) modules in libraries do not have suffixes. That is, to
-   find a match for a pattern, the pattern must not have any suffix. So the
-   suffix of the pattern is saved and the pattern is stripped (ar_glob).
-   If there is a match and the match, which is a module name, is added to
-   the chain, the saved suffix is added back to construct a source filename
-   (ar_glob_match). */
-
-struct ar_glob_state
-  {
-    const char *arname;
-    const char *pattern;
-#ifdef VMS
-    char *suffix;
-#endif
-    unsigned int size;
-    struct nameseq *chain;
-    unsigned int n;
-  };
-
-/* This function is called by 'ar_scan' to match one archive
-   element against the pattern in STATE.  */
-
-static long int
-ar_glob_match (int desc UNUSED, const char *mem, int truncated UNUSED,
-               long int hdrpos UNUSED, long int datapos UNUSED,
-               long int size UNUSED, long int date UNUSED, int uid UNUSED,
-               int gid UNUSED, unsigned int mode UNUSED, const void *arg)
-{
-  struct ar_glob_state *state = (struct ar_glob_state *)arg;
-
-  if (fnmatch (state->pattern, mem, FNM_PATHNAME|FNM_PERIOD) == 0)
-    {
-      /* We have a match.  Add it to the chain.  */
-      struct nameseq *new = xcalloc (state->size);
-#ifdef VMS
-      if (state->suffix)
-        new->name = strcache_add(
-            concat(5, state->arname, "(", mem, state->suffix, ")"));
-      else
-#endif
-        new->name = strcache_add(concat(4, state->arname, "(", mem, ")"));
-      new->next = state->chain;
-      state->chain = new;
-      ++state->n;
-    }
-
-  return 0L;
-}
-
-/* Return nonzero if PATTERN contains any metacharacters.
-   Metacharacters can be quoted with backslashes if QUOTE is nonzero.  */
-static int
-ar_glob_pattern_p (const char *pattern, int quote)
-{
-  const char *p;
-  int opened = 0;
-
-  for (p = pattern; *p != '\0'; ++p)
-    switch (*p)
-      {
-      case '?':
-      case '*':
-        return 1;
-
-      case '\\':
-        if (quote)
-          ++p;
-        break;
-
-      case '[':
-        opened = 1;
-        break;
-
-      case ']':
-        if (opened)
-          return 1;
-        break;
-      }
-
-  return 0;
-}
-
-/* Glob for MEMBER_PATTERN in archive ARNAME.
-   Return a malloc'd chain of matching elements (or nil if none).  */
-
-struct nameseq *
-ar_glob (const char *arname, const char *member_pattern, unsigned int size)
-{
-  struct ar_glob_state state;
-  struct nameseq *n;
-  const char **names;
-  unsigned int i;
-#ifdef VMS
-  char *vms_member_pattern;
-#endif
-  if (! ar_glob_pattern_p (member_pattern, 1))
-    return 0;
-
-  /* Scan the archive for matches.
-     ar_glob_match will accumulate them in STATE.chain.  */
-  state.arname = arname;
-  state.pattern = member_pattern;
-#ifdef VMS
-    {
-      /* In a copy of the pattern, find the suffix, save it and  remove it from
-         the pattern */
-      char *lastdot;
-      vms_member_pattern = xstrdup(member_pattern);
-      lastdot = strrchr(vms_member_pattern, '.');
-      state.suffix = lastdot;
-      if (lastdot)
-        {
-          state.suffix = xstrdup(lastdot);
-          *lastdot = 0;
-        }
-      state.pattern = vms_member_pattern;
-    }
-#endif
-  state.size = size;
-  state.chain = 0;
-  state.n = 0;
-  ar_scan (arname, ar_glob_match, &state);
-
-#ifdef VMS
-  /* Deallocate any duplicated string */
-  free(vms_member_pattern);
-  if (state.suffix)
-    {
-      free(state.suffix);
-    }
-#endif
-
-  if (state.chain == 0)
-    return 0;
-
-  /* Now put the names into a vector for sorting.  */
-  names = alloca (state.n * sizeof (const char *));
-  i = 0;
-  for (n = state.chain; n != 0; n = n->next)
-    names[i++] = n->name;
-
-  /* Sort them alphabetically.  */
-  /* MSVC erroneously warns without a cast here.  */
-  qsort ((void *)names, i, sizeof (*names), alpha_compare);
-
-  /* Put them back into the chain in the sorted order.  */
-  i = 0;
-  for (n = state.chain; n != 0; n = n->next)
-    n->name = names[i++];
-
-  return state.chain;
-}
-
-#endif  /* Not NO_ARCHIVES.  */
diff --git a/arscan.c b/arscan.c
deleted file mode 100644
index af3c96f..0000000
--- a/arscan.c
+++ /dev/null
@@ -1,959 +0,0 @@
-/* Library function for scanning an archive file.
-Copyright (C) 1987-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-
-#ifdef TEST
-/* Hack, the real error() routine eventually pulls in die from main.c */
-#define error(a, b, c, d)
-#endif
-
-#ifdef HAVE_FCNTL_H
-#include <fcntl.h>
-#else
-#include <sys/file.h>
-#endif
-
-#ifndef NO_ARCHIVES
-
-#ifdef VMS
-#include <lbrdef.h>
-#include <mhddef.h>
-#include <credef.h>
-#include <descrip.h>
-#include <ctype.h>
-#include <ssdef.h>
-#include <stsdef.h>
-#include <rmsdef.h>
-
-/* This symbol should be present in lbrdef.h. */
-#ifndef LBR$_HDRTRUNC
-#pragma extern_model save
-#pragma extern_model globalvalue
-extern unsigned int LBR$_HDRTRUNC;
-#pragma extern_model restore
-#endif
-
-#include <unixlib.h>
-#include <lbr$routines.h>
-
-const char *
-vmsify (const char *name, int type);
-
-/* Time conversion from VMS to Unix
-   Conversion from local time (stored in library) to GMT (needed for gmake)
-   Note: The tm_gmtoff element is a VMS extension to the ANSI standard. */
-static time_t
-vms_time_to_unix(void *vms_time)
-{
-  struct tm *tmp;
-  time_t unix_time;
-
-  unix_time = decc$fix_time(vms_time);
-  tmp = localtime(&unix_time);
-  unix_time -= tmp->tm_gmtoff;
-
-  return unix_time;
-}
-
-
-/* VMS library routines need static variables for callback */
-static void *VMS_lib_idx;
-
-static const void *VMS_saved_arg;
-
-static long int (*VMS_function) ();
-
-static long int VMS_function_ret;
-
-
-/* This is a callback procedure for lib$get_index */
-static int
-VMS_get_member_info(struct dsc$descriptor_s *module, unsigned long *rfa)
-{
-  int status, i;
-  const int truncated = 0; /* Member name may be truncated */
-  time_t member_date; /* Member date */
-  char *filename;
-  unsigned int buffer_length; /* Actual buffer length */
-
-  /* Unused constants - Make does not actually use most of these */
-  const int file_desc = -1; /* archive file descriptor for reading the data */
-  const int header_position = 0; /* Header position */
-  const int data_position = 0; /* Data position in file */
-  const int data_size = 0; /* Data size */
-  const int uid = 0; /* member gid */
-  const int gid = 0; /* member gid */
-  const int mode = 0; /* member protection mode */
-  /* End of unused constants */
-
-  static struct dsc$descriptor_s bufdesc =
-    { 0, DSC$K_DTYPE_T, DSC$K_CLASS_S, NULL };
-
-  /* Only need the module definition */
-  struct mhddef *mhd;
-
-  /* If a previous callback is non-zero, just return that status */
-  if (VMS_function_ret)
-    {
-      return SS$_NORMAL;
-    }
-
-  /* lbr_set_module returns more than just the module header. So allocate
-     a buffer which is big enough: the maximum LBR$C_MAXHDRSIZ. That's at
-     least bigger than the size of struct mhddef.
-     If the request is too small, a buffer truncated warning is issued so
-     it can be reissued with a larger buffer.
-     We do not care if the buffer is truncated, so that is still a success. */
-  mhd = xmalloc(LBR$C_MAXHDRSIZ);
-  bufdesc.dsc$a_pointer = (char *) mhd;
-  bufdesc.dsc$w_length = LBR$C_MAXHDRSIZ;
-
-  status = lbr$set_module(&VMS_lib_idx, rfa, &bufdesc, &buffer_length, 0);
-
-  if ((status != LBR$_HDRTRUNC) && !$VMS_STATUS_SUCCESS(status))
-    {
-      ON(error, NILF,
-          _("lbr$set_module() failed to extract module info, status = %d"),
-          status);
-
-      lbr$close(&VMS_lib_idx);
-
-      return status;
-    }
-
-#ifdef TEST
-  /* When testing this code, it is useful to know the length returned */
-  printf ("Input length = %d, actual = %u\n",
-          bufdesc.dsc$w_length, buffer_length);
-#endif
-
-  /* Conversion from VMS time to C time.
-     VMS defectlet - mhddef is sub-optimal, for the time, it has a 32 bit
-     longword, mhd$l_datim, and a 32 bit fill instead of two longwords, or
-     equivalent. */
-  member_date = vms_time_to_unix(&mhd->mhd$l_datim);
-  free(mhd);
-
-  /* Here we have a problem.  The module name on VMS does not have
-     a file type, but the filename pattern in the "VMS_saved_arg"
-     may have one.
-     But only the method being called knows how to interpret the
-     filename pattern.
-     There are currently two different formats being used.
-     This means that we need a VMS specific code in those methods
-     to handle it. */
-  filename = xmalloc(module->dsc$w_length + 1);
-
-  /* TODO: We may need an option to preserve the case of the module
-     For now force the module name to lower case */
-  for (i = 0; i < module->dsc$w_length; i++)
-    filename[i] = _tolower((unsigned char )module->dsc$a_pointer[i]);
-
-  filename[i] = '\0';
-
-  VMS_function_ret = (*VMS_function)(file_desc, filename, truncated,
-      header_position, data_position, data_size, member_date, uid, gid, mode,
-      VMS_saved_arg);
-
-  free(filename);
-  return SS$_NORMAL;
-}
-
-
-/* Takes three arguments ARCHIVE, FUNCTION and ARG.
-
-   Open the archive named ARCHIVE, find its members one by one,
-   and for each one call FUNCTION with the following arguments:
-     archive file descriptor for reading the data,
-     member name,
-     member name might be truncated flag,
-     member header position in file,
-     member data position in file,
-     member data size,
-     member date,
-     member uid,
-     member gid,
-     member protection mode,
-     ARG.
-
-   NOTE: on VMS systems, only name, date, and arg are meaningful!
-
-   The descriptor is poised to read the data of the member
-   when FUNCTION is called.  It does not matter how much
-   data FUNCTION reads.
-
-   If FUNCTION returns nonzero, we immediately return
-   what FUNCTION returned.
-
-   Returns -1 if archive does not exist,
-   Returns -2 if archive has invalid format.
-   Returns 0 if have scanned successfully.  */
-
-long int
-ar_scan (const char *archive, ar_member_func_t function, const void *varg)
-{
-  char *vms_archive;
-
-  static struct dsc$descriptor_s libdesc =
-    { 0, DSC$K_DTYPE_T, DSC$K_CLASS_S, NULL };
-
-  const unsigned long func = LBR$C_READ;
-  const unsigned long type = LBR$C_TYP_UNK;
-  const unsigned long index = 1;
-  unsigned long lib_idx;
-  int status;
-
-  VMS_saved_arg = varg;
-
-  /* Null archive string can show up in test and cause an access violation */
-  if (archive == NULL)
-    {
-      /* Null filenames do not exist */
-      return -1;
-    }
-
-  /* archive path name must be in VMS format */
-  vms_archive = (char *) vmsify(archive, 0);
-
-  status = lbr$ini_control(&VMS_lib_idx, &func, &type, 0);
-
-  if (!$VMS_STATUS_SUCCESS(status))
-    {
-      ON(error, NILF, _("lbr$ini_control() failed with status = %d"), status);
-      return -2;
-    }
-
-  libdesc.dsc$a_pointer = vms_archive;
-  libdesc.dsc$w_length = strlen(vms_archive);
-
-  status = lbr$open(&VMS_lib_idx, &libdesc, 0, NULL, 0, NULL, 0);
-
-  if (!$VMS_STATUS_SUCCESS(status))
-    {
-
-      /* TODO: A library format failure could mean that this is a file
-         generated by the GNU AR utility and in that case, we need to
-         take the UNIX codepath.  This will also take a change to the
-         GNV AR wrapper program. */
-
-      switch (status)
-        {
-      case RMS$_FNF:
-        /* Archive does not exist */
-        return -1;
-      default:
-#ifndef TEST
-        OSN(error, NILF,
-            _("unable to open library '%s' to lookup member status %d"),
-            archive, status);
-#endif
-        /* For library format errors, specification says to return -2 */
-        return -2;
-        }
-    }
-
-  VMS_function = function;
-
-  /* Clear the return status, as we are supposed to stop calling the
-     callback function if it becomes non-zero, and this is a static
-     variable. */
-  VMS_function_ret = 0;
-
-  status = lbr$get_index(&VMS_lib_idx, &index, VMS_get_member_info, NULL, 0);
-
-  lbr$close(&VMS_lib_idx);
-
-  /* Unless a failure occurred in the lbr$ routines, return the
-     the status from the 'function' routine. */
-  if ($VMS_STATUS_SUCCESS(status))
-    {
-      return VMS_function_ret;
-    }
-
-  /* This must be something wrong with the library and an error
-     message should already have been printed. */
-  return -2;
-}
-
-#else /* !VMS */
-
-/* SCO Unix's compiler defines both of these.  */
-#ifdef  M_UNIX
-#undef  M_XENIX
-#endif
-
-/* On the sun386i and in System V rel 3, ar.h defines two different archive
-   formats depending upon whether you have defined PORTAR (normal) or PORT5AR
-   (System V Release 1).  There is no default, one or the other must be defined
-   to have a nonzero value.  */
-
-#if (!defined (PORTAR) || PORTAR == 0) && (!defined (PORT5AR) || PORT5AR == 0)
-#undef  PORTAR
-#ifdef M_XENIX
-/* According to Jim Sievert <jas1@rsvl.unisys.com>, for SCO XENIX defining
-   PORTAR to 1 gets the wrong archive format, and defining it to 0 gets the
-   right one.  */
-#define PORTAR 0
-#else
-#define PORTAR 1
-#endif
-#endif
-
-/* On AIX, define these symbols to be sure to get both archive formats.
-   AIX 4.3 introduced the "big" archive format to support 64-bit object
-   files, so on AIX 4.3 systems we need to support both the "normal" and
-   "big" archive formats.  An archive's format is indicated in the
-   "fl_magic" field of the "FL_HDR" structure.  For a normal archive,
-   this field will be the string defined by the AIAMAG symbol.  For a
-   "big" archive, it will be the string defined by the AIAMAGBIG symbol
-   (at least on AIX it works this way).
-
-   Note: we'll define these symbols regardless of which AIX version
-   we're compiling on, but this is okay since we'll use the new symbols
-   only if they're present.  */
-#ifdef _AIX
-# define __AR_SMALL__
-# define __AR_BIG__
-#endif
-
-#ifndef WINDOWS32
-# if !defined (__ANDROID__) && !defined (__BEOS__)
-#  include <ar.h>
-# else
-   /* These platforms don't have <ar.h> but have archives in the same format
-    * as many other Unices.  This was taken from GNU binutils for BeOS.
-    */
-#  define ARMAG "!<arch>\n"     /* String that begins an archive file.  */
-#  define SARMAG 8              /* Size of that string.  */
-#  define ARFMAG "`\n"          /* String in ar_fmag at end of each header.  */
-struct ar_hdr
-  {
-    char ar_name[16];           /* Member file name, sometimes / terminated. */
-    char ar_date[12];           /* File date, decimal seconds since Epoch.  */
-    char ar_uid[6], ar_gid[6];  /* User and group IDs, in ASCII decimal.  */
-    char ar_mode[8];            /* File mode, in ASCII octal.  */
-    char ar_size[10];           /* File size, in ASCII decimal.  */
-    char ar_fmag[2];            /* Always contains ARFMAG.  */
-  };
-# endif
-# define TOCHAR(_m)     (_m)
-#else
-/* These should allow us to read Windows (VC++) libraries (according to Frank
- * Libbrecht <frankl@abzx.belgium.hp.com>)
- */
-# include <windows.h>
-# include <windef.h>
-# include <io.h>
-# define ARMAG      IMAGE_ARCHIVE_START
-# define SARMAG     IMAGE_ARCHIVE_START_SIZE
-# define ar_hdr     _IMAGE_ARCHIVE_MEMBER_HEADER
-# define ar_name    Name
-# define ar_mode    Mode
-# define ar_size    Size
-# define ar_date    Date
-# define ar_uid     UserID
-# define ar_gid     GroupID
-/* In Windows the member names have type BYTE so we must cast them.  */
-# define TOCHAR(_m)     ((char *)(_m))
-#endif
-
-/* Cray's <ar.h> apparently defines this.  */
-#ifndef AR_HDR_SIZE
-# define   AR_HDR_SIZE  (sizeof (struct ar_hdr))
-#endif
-
-#include "output.h"
-
-/* Takes three arguments ARCHIVE, FUNCTION and ARG.
-
-   Open the archive named ARCHIVE, find its members one by one,
-   and for each one call FUNCTION with the following arguments:
-     archive file descriptor for reading the data,
-     member name,
-     member name might be truncated flag,
-     member header position in file,
-     member data position in file,
-     member data size,
-     member date,
-     member uid,
-     member gid,
-     member protection mode,
-     ARG.
-
-   The descriptor is poised to read the data of the member
-   when FUNCTION is called.  It does not matter how much
-   data FUNCTION reads.
-
-   If FUNCTION returns nonzero, we immediately return
-   what FUNCTION returned.
-
-   Returns -1 if archive does not exist,
-   Returns -2 if archive has invalid format.
-   Returns 0 if have scanned successfully.  */
-
-long int
-ar_scan (const char *archive, ar_member_func_t function, const void *arg)
-{
-#ifdef AIAMAG
-  FL_HDR fl_header;
-# ifdef AIAMAGBIG
-  int big_archive = 0;
-  FL_HDR_BIG fl_header_big;
-# endif
-#endif
-  char *namemap = 0;
-  int desc = open (archive, O_RDONLY, 0);
-  if (desc < 0)
-    return -1;
-
-#ifdef SARMAG
-  {
-    char buf[SARMAG];
-    int nread;
-    EINTRLOOP (nread, read (desc, buf, SARMAG));
-    if (nread != SARMAG || memcmp (buf, ARMAG, SARMAG))
-      goto invalid;
-  }
-#else
-#ifdef AIAMAG
-  {
-    int nread;
-    EINTRLOOP (nread, read (desc, &fl_header, FL_HSZ));
-    if (nread != FL_HSZ)
-      goto invalid;
-
-#ifdef AIAMAGBIG
-    /* If this is a "big" archive, then set the flag and
-       re-read the header into the "big" structure. */
-    if (!memcmp (fl_header.fl_magic, AIAMAGBIG, SAIAMAG))
-      {
-        off_t o;
-
-        big_archive = 1;
-
-        /* seek back to beginning of archive */
-        EINTRLOOP (o, lseek (desc, 0, 0));
-        if (o < 0)
-          goto invalid;
-
-        /* re-read the header into the "big" structure */
-        EINTRLOOP (nread, read (desc, &fl_header_big, FL_HSZ_BIG));
-        if (nread != FL_HSZ_BIG)
-          goto invalid;
-      }
-    else
-#endif
-       /* Check to make sure this is a "normal" archive. */
-      if (memcmp (fl_header.fl_magic, AIAMAG, SAIAMAG))
-        goto invalid;
-  }
-#else
-  {
-#ifndef M_XENIX
-    int buf;
-#else
-    unsigned short int buf;
-#endif
-    int nread;
-    EINTRLOOP (nread, read (desc, &buf, sizeof (buf)));
-    if (nread != sizeof (buf) || buf != ARMAG)
-      goto invalid;
-  }
-#endif
-#endif
-
-  /* Now find the members one by one.  */
-  {
-#ifdef SARMAG
-    long int member_offset = SARMAG;
-#else
-#ifdef AIAMAG
-    long int member_offset;
-    long int last_member_offset;
-
-#ifdef AIAMAGBIG
-    if ( big_archive )
-      {
-        sscanf (fl_header_big.fl_fstmoff, "%20ld", &member_offset);
-        sscanf (fl_header_big.fl_lstmoff, "%20ld", &last_member_offset);
-      }
-    else
-#endif
-      {
-        sscanf (fl_header.fl_fstmoff, "%12ld", &member_offset);
-        sscanf (fl_header.fl_lstmoff, "%12ld", &last_member_offset);
-      }
-
-    if (member_offset == 0)
-      {
-        /* Empty archive.  */
-        close (desc);
-        return 0;
-      }
-#else
-#ifndef M_XENIX
-    long int member_offset = sizeof (int);
-#else   /* Xenix.  */
-    long int member_offset = sizeof (unsigned short int);
-#endif  /* Not Xenix.  */
-#endif
-#endif
-
-    while (1)
-      {
-        int nread;
-        struct ar_hdr member_header;
-#ifdef AIAMAGBIG
-        struct ar_hdr_big member_header_big;
-#endif
-#ifdef AIAMAG
-# define ARNAME_MAX 255
-        char name[ARNAME_MAX + 1];
-        int name_len;
-        long int dateval;
-        int uidval, gidval;
-        long int data_offset;
-#else
-# define ARNAME_MAX (int)sizeof(member_header.ar_name)
-        char namebuf[ARNAME_MAX + 1];
-        char *name;
-        int is_namemap;         /* Nonzero if this entry maps long names.  */
-        int long_name = 0;
-#endif
-        long int eltsize;
-        unsigned int eltmode;
-        long int fnval;
-        off_t o;
-
-        EINTRLOOP (o, lseek (desc, member_offset, 0));
-        if (o < 0)
-          goto invalid;
-
-#ifdef AIAMAG
-#define       AR_MEMHDR_SZ(x) (sizeof(x) - sizeof (x._ar_name))
-
-#ifdef AIAMAGBIG
-        if (big_archive)
-          {
-            EINTRLOOP (nread, read (desc, &member_header_big,
-                                    AR_MEMHDR_SZ(member_header_big)));
-
-            if (nread != AR_MEMHDR_SZ(member_header_big))
-              goto invalid;
-
-            sscanf (member_header_big.ar_namlen, "%4d", &name_len);
-            if (name_len < 1 || name_len > ARNAME_MAX)
-              goto invalid;
-
-            EINTRLOOP (nread, read (desc, name, name_len));
-            if (nread != name_len)
-              goto invalid;
-
-            name[name_len] = '\0';
-
-            sscanf (member_header_big.ar_date, "%12ld", &dateval);
-            sscanf (member_header_big.ar_uid, "%12d", &uidval);
-            sscanf (member_header_big.ar_gid, "%12d", &gidval);
-            sscanf (member_header_big.ar_mode, "%12o", &eltmode);
-            sscanf (member_header_big.ar_size, "%20ld", &eltsize);
-
-            data_offset = (member_offset + AR_MEMHDR_SZ(member_header_big)
-                           + name_len + 2);
-          }
-        else
-#endif
-          {
-            EINTRLOOP (nread, read (desc, &member_header,
-                                    AR_MEMHDR_SZ(member_header)));
-
-            if (nread != AR_MEMHDR_SZ(member_header))
-              goto invalid;
-
-            sscanf (member_header.ar_namlen, "%4d", &name_len);
-            if (name_len < 1 || name_len > ARNAME_MAX)
-              goto invalid;
-
-            EINTRLOOP (nread, read (desc, name, name_len));
-            if (nread != name_len)
-              goto invalid;
-
-            name[name_len] = '\0';
-
-            sscanf (member_header.ar_date, "%12ld", &dateval);
-            sscanf (member_header.ar_uid, "%12d", &uidval);
-            sscanf (member_header.ar_gid, "%12d", &gidval);
-            sscanf (member_header.ar_mode, "%12o", &eltmode);
-            sscanf (member_header.ar_size, "%12ld", &eltsize);
-
-            data_offset = (member_offset + AR_MEMHDR_SZ(member_header)
-                           + name_len + 2);
-          }
-        data_offset += data_offset % 2;
-
-        fnval =
-          (*function) (desc, name, 0,
-                       member_offset, data_offset, eltsize,
-                       dateval, uidval, gidval,
-                       eltmode, arg);
-
-#else   /* Not AIAMAG.  */
-        EINTRLOOP (nread, read (desc, &member_header, AR_HDR_SIZE));
-        if (nread == 0)
-          /* No data left means end of file; that is OK.  */
-          break;
-
-        if (nread != AR_HDR_SIZE
-#if defined(ARFMAG) || defined(ARFZMAG)
-            || (
-# ifdef ARFMAG
-                memcmp (member_header.ar_fmag, ARFMAG, 2)
-# else
-                1
-# endif
-                &&
-# ifdef ARFZMAG
-                memcmp (member_header.ar_fmag, ARFZMAG, 2)
-# else
-                1
-# endif
-               )
-#endif
-            )
-          goto invalid;
-
-        name = namebuf;
-        memcpy (name, member_header.ar_name, sizeof member_header.ar_name);
-        {
-          char *p = name + sizeof member_header.ar_name;
-          do
-            *p = '\0';
-          while (p > name && *--p == ' ');
-
-#ifndef AIAMAG
-          /* If the member name is "//" or "ARFILENAMES/" this may be
-             a list of file name mappings.  The maximum file name
-             length supported by the standard archive format is 14
-             characters.  This member will actually always be the
-             first or second entry in the archive, but we don't check
-             that.  */
-          is_namemap = (!strcmp (name, "//")
-                        || !strcmp (name, "ARFILENAMES/"));
-#endif  /* Not AIAMAG. */
-
-          /* On some systems, there is a slash after each member name.  */
-          if (*p == '/')
-            *p = '\0';
-
-#ifndef AIAMAG
-          /* If the member name starts with a space or a slash, this
-             is an index into the file name mappings (used by GNU ar).
-             Otherwise if the member name looks like #1/NUMBER the
-             real member name appears in the element data (used by
-             4.4BSD).  */
-          if (! is_namemap
-              && (name[0] == ' ' || name[0] == '/')
-              && namemap != 0)
-            {
-              int name_off = atoi (name + 1);
-              if (name_off < 1 || name_off > ARNAME_MAX)
-                goto invalid;
-
-              name = namemap + name_off;
-              long_name = 1;
-            }
-          else if (name[0] == '#'
-                   && name[1] == '1'
-                   && name[2] == '/')
-            {
-              int name_len = atoi (name + 3);
-              if (name_len < 1 || name_len > ARNAME_MAX)
-                goto invalid;
-
-              name = alloca (name_len + 1);
-              EINTRLOOP (nread, read (desc, name, name_len));
-              if (nread != name_len)
-                goto invalid;
-
-              name[name_len] = '\0';
-
-              long_name = 1;
-            }
-#endif /* Not AIAMAG. */
-        }
-
-#ifndef M_XENIX
-        sscanf (TOCHAR (member_header.ar_mode), "%o", &eltmode);
-        eltsize = atol (TOCHAR (member_header.ar_size));
-#else   /* Xenix.  */
-        eltmode = (unsigned short int) member_header.ar_mode;
-        eltsize = member_header.ar_size;
-#endif  /* Not Xenix.  */
-
-        fnval =
-          (*function) (desc, name, ! long_name, member_offset,
-                       member_offset + AR_HDR_SIZE, eltsize,
-#ifndef M_XENIX
-                       atol (TOCHAR (member_header.ar_date)),
-                       atoi (TOCHAR (member_header.ar_uid)),
-                       atoi (TOCHAR (member_header.ar_gid)),
-#else   /* Xenix.  */
-                       member_header.ar_date,
-                       member_header.ar_uid,
-                       member_header.ar_gid,
-#endif  /* Not Xenix.  */
-                       eltmode, arg);
-
-#endif  /* AIAMAG.  */
-
-        if (fnval)
-          {
-            (void) close (desc);
-            return fnval;
-          }
-
-#ifdef AIAMAG
-        if (member_offset == last_member_offset)
-          /* End of the chain.  */
-          break;
-
-#ifdef AIAMAGBIG
-        if (big_archive)
-         sscanf (member_header_big.ar_nxtmem, "%20ld", &member_offset);
-        else
-#endif
-          sscanf (member_header.ar_nxtmem, "%12ld", &member_offset);
-
-        if (lseek (desc, member_offset, 0) != member_offset)
-          goto invalid;
-#else
-
-        /* If this member maps archive names, we must read it in.  The
-           name map will always precede any members whose names must
-           be mapped.  */
-        if (is_namemap)
-          {
-            char *clear;
-            char *limit;
-
-            namemap = alloca (eltsize);
-            EINTRLOOP (nread, read (desc, namemap, eltsize));
-            if (nread != eltsize)
-              goto invalid;
-
-            /* The names are separated by newlines.  Some formats have
-               a trailing slash.  Null terminate the strings for
-               convenience.  */
-            limit = namemap + eltsize;
-            for (clear = namemap; clear < limit; clear++)
-              {
-                if (*clear == '\n')
-                  {
-                    *clear = '\0';
-                    if (clear[-1] == '/')
-                      clear[-1] = '\0';
-                  }
-              }
-
-            is_namemap = 0;
-          }
-
-        member_offset += AR_HDR_SIZE + eltsize;
-        if (member_offset % 2 != 0)
-          member_offset++;
-#endif
-      }
-  }
-
-  close (desc);
-  return 0;
-
- invalid:
-  close (desc);
-  return -2;
-}
-#endif /* !VMS */
-
-/* Return nonzero iff NAME matches MEM.
-   If TRUNCATED is nonzero, MEM may be truncated to
-   sizeof (struct ar_hdr.ar_name) - 1.  */
-
-int
-ar_name_equal (const char *name, const char *mem, int truncated)
-{
-  const char *p;
-
-  p = strrchr (name, '/');
-  if (p != 0)
-    name = p + 1;
-
-#ifndef VMS
-  if (truncated)
-    {
-#ifdef AIAMAG
-      /* TRUNCATED should never be set on this system.  */
-      abort ();
-#else
-      struct ar_hdr hdr;
-#if !defined (__hpux) && !defined (cray)
-      return strneq (name, mem, sizeof (hdr.ar_name) - 1);
-#else
-      return strneq (name, mem, sizeof (hdr.ar_name) - 2);
-#endif /* !__hpux && !cray */
-#endif /* !AIAMAG */
-    }
-
-  return !strcmp (name, mem);
-#else
-  /* VMS members do not have suffixes, but the filenames usually
-     have.
-     Do we need to strip VMS disk/directory format paths?
-
-     Most VMS compilers etc. by default are case insensitive
-     but produce uppercase external names, incl. module names.
-     However the VMS librarian (ar) and the linker by default
-     are case sensitive: they take what they get, usually
-     uppercase names. So for the non-default settings of the
-     compilers etc. there is a need to have a case sensitive
-     mode. */
-  {
-    int len;
-    len = strlen(mem);
-    int match;
-    char *dot;
-    if ((dot=strrchr(name,'.')))
-      match = (len == dot - name) && !strncasecmp(name, mem, len);
-    else
-      match = !strcasecmp (name, mem);
-    return match;
-  }
-#endif /* !VMS */
-}
-
-#ifndef VMS
-/* ARGSUSED */
-static long int
-ar_member_pos (int desc UNUSED, const char *mem, int truncated,
-               long int hdrpos, long int datapos UNUSED, long int size UNUSED,
-               long int date UNUSED, int uid UNUSED, int gid UNUSED,
-               unsigned int mode UNUSED, const void *name)
-{
-  if (!ar_name_equal (name, mem, truncated))
-    return 0;
-  return hdrpos;
-}
-
-/* Set date of member MEMNAME in archive ARNAME to current time.
-   Returns 0 if successful,
-   -1 if file ARNAME does not exist,
-   -2 if not a valid archive,
-   -3 if other random system call error (including file read-only),
-   1 if valid but member MEMNAME does not exist.  */
-
-int
-ar_member_touch (const char *arname, const char *memname)
-{
-  long int pos = ar_scan (arname, ar_member_pos, memname);
-  int fd;
-  struct ar_hdr ar_hdr;
-  off_t o;
-  int r;
-  unsigned int ui;
-  struct stat statbuf;
-
-  if (pos < 0)
-    return (int) pos;
-  if (!pos)
-    return 1;
-
-  EINTRLOOP (fd, open (arname, O_RDWR, 0666));
-  if (fd < 0)
-    return -3;
-  /* Read in this member's header */
-  EINTRLOOP (o, lseek (fd, pos, 0));
-  if (o < 0)
-    goto lose;
-  EINTRLOOP (r, read (fd, &ar_hdr, AR_HDR_SIZE));
-  if (r != AR_HDR_SIZE)
-    goto lose;
-  /* Write back the header, thus touching the archive file.  */
-  EINTRLOOP (o, lseek (fd, pos, 0));
-  if (o < 0)
-    goto lose;
-  r = output_write (fd, &ar_hdr, AR_HDR_SIZE);
-  if (r != AR_HDR_SIZE)
-    goto lose;
-  /* The file's mtime is the time we we want.  */
-  EINTRLOOP (r, fstat (fd, &statbuf));
-  if (r < 0)
-    goto lose;
-#if defined(ARFMAG) || defined(ARFZMAG) || defined(AIAMAG) || defined(WINDOWS32)
-  /* Advance member's time to that time */
-  for (ui = 0; ui < sizeof ar_hdr.ar_date; ui++)
-    ar_hdr.ar_date[ui] = ' ';
-  sprintf (TOCHAR (ar_hdr.ar_date), "%lu", (long unsigned) statbuf.st_mtime);
-#ifdef AIAMAG
-  ar_hdr.ar_date[strlen (ar_hdr.ar_date)] = ' ';
-#endif
-#else
-  ar_hdr.ar_date = statbuf.st_mtime;
-#endif
-  /* Write back this member's header */
-  EINTRLOOP (o, lseek (fd, pos, 0));
-  if (o < 0)
-    goto lose;
-  r = output_write (fd, &ar_hdr, AR_HDR_SIZE);
-  if (r != AR_HDR_SIZE)
-    goto lose;
-  close (fd);
-  return 0;
-
- lose:
-  r = errno;
-  close (fd);
-  errno = r;
-  return -3;
-}
-#endif
-
-#ifdef TEST
-
-long int
-describe_member (int desc, const char *name, int truncated,
-                 long int hdrpos, long int datapos, long int size,
-                 long int date, int uid, int gid, unsigned int mode,
-                 const void *arg)
-{
-  extern char *ctime ();
-
-  printf (_("Member '%s'%s: %ld bytes at %ld (%ld).\n"),
-          name, truncated ? _(" (name might be truncated)") : "",
-          size, hdrpos, datapos);
-  printf (_("  Date %s"), ctime (&date));
-  printf (_("  uid = %d, gid = %d, mode = 0%o.\n"), uid, gid, mode);
-
-  return 0;
-}
-
-int
-main (int argc, char **argv)
-{
-  ar_scan (argv[1], describe_member, NULL);
-  return 0;
-}
-
-#endif  /* TEST.  */
-#endif  /* NO_ARCHIVES.  */
diff --git a/build.template b/build.template
index 4b14693..b16d397 100644
--- a/build.template
+++ b/build.template
@@ -44,7 +44,6 @@ libdir=${exec_prefix}/lib
 includedir=${prefix}/include
 
 localedir=${prefix}/share/locale
-aliaspath=${localedir}${PATH_SEPARATOR}.
 
 defines="-DLOCALEDIR=\"${localedir}\" -DLIBDIR=\"${libdir}\" -DINCLUDEDIR=\"${includedir}\""' @DEFS@'
 
@@ -52,7 +51,7 @@ defines="-DLOCALEDIR=\"${localedir}\" -DLIBDIR=\"${libdir}\" -DINCLUDEDIR=\"${in
 set -e
 
 # These are all the objects we need to link together.
-objs="%objs% remote-${REMOTE}.${OBJEXT} ${extras} ${ALLOCA}"
+objs="%objs% src/remote-${REMOTE}.${OBJEXT} ${extras} ${ALLOCA}"
 
 if [ x"$GLOBLIB" != x ]; then
   objs="$objs %globobjs%"
@@ -63,7 +62,7 @@ fi
 for file in `echo ${objs} | sed 's/\.'${OBJEXT}'/.c/g'`; do
   echo compiling ${file}...
   $CC $defines $CPPFLAGS $CFLAGS \
-      -c -I. -I${srcdir} ${globinc} ${srcdir}/$file
+      -c -Isrc -I${srcdir}/src ${globinc} ${srcdir}/$file
 done
 
 # The object files were actually all put in the current directory.
diff --git a/build_w32.bat b/build_w32.bat
index 73afa5d..12a1d93 100755
--- a/build_w32.bat
+++ b/build_w32.bat
@@ -24,6 +24,7 @@ if "%1" == "--help" goto Usage
 set MAKE=gnumake
 set GUILE=Y
 set COMPILER=cl.exe
+set O=obj
 set ARCH=x64
 set DEBUG=N
 
@@ -53,6 +54,7 @@ goto ParseSW
 
 :SetCC
 set COMPILER=gcc
+set O=o
 echo Building with GCC
 shift
 goto ParseSW
@@ -146,58 +148,61 @@ if exist %OUTDIR%\nul rmdir /S /Q %OUTDIR%
 
 :: Recreate it
 mkdir %OUTDIR%
+mkdir %OUTDIR%\src
+mkdir %OUTDIR%\src\w32
+mkdir %OUTDIR%\src\w32\compat
+mkdir %OUTDIR%\src\w32\subproc
 mkdir %OUTDIR%\glob
-mkdir %OUTDIR%\w32
-mkdir %OUTDIR%\w32\compat
-mkdir %OUTDIR%\w32\subproc
 
 if "%GUILE%" == "Y" call :ChkGuile
 
 echo.
 echo Compiling %OUTDIR% version
 
-if exist config.h.W32.template call :ConfigSCM
-copy config.h.W32 %OUTDIR%\config.h
-
-call :Compile ar
-call :Compile arscan
-call :Compile commands
-call :Compile default
-call :Compile dir
-call :Compile expand
-call :Compile file
-call :Compile function
-call :Compile getloadavg
-call :Compile getopt
-call :Compile getopt1
+if exist src\config.h.W32.template call :ConfigSCM
+copy src\config.h.W32 %OUTDIR%\src\config.h
+
+if exist %OUTDIR%\link.sc del %OUTDIR%\link.sc
+
+call :Compile src\ar
+call :Compile src\arscan
+call :Compile src\commands
+call :Compile src\default
+call :Compile src\dir
+call :Compile src\expand
+call :Compile src\file
+call :Compile src\function
+call :Compile src\getloadavg
+call :Compile src\getopt
+call :Compile src\getopt1
+call :Compile src\guile GUILE
+call :Compile src\hash
+call :Compile src\implicit
+call :Compile src\job
+call :Compile src\load
+call :Compile src\loadapi
+call :Compile src\main GUILE
+call :Compile src\misc
+call :Compile src\output
+call :Compile src\read
+call :Compile src\remake
+call :Compile src\remote-stub
+call :Compile src\rule
+call :Compile src\signame
+call :Compile src\strcache
+call :Compile src\variable
+call :Compile src\version
+call :Compile src\vpath
+call :Compile src\w32\pathstuff
+call :Compile src\w32\w32os
+call :Compile src\w32\compat\posixfcn
+call :Compile src\w32\subproc\misc
+call :Compile src\w32\subproc\sub_proc
+call :Compile src\w32\subproc\w32err
 call :Compile glob\fnmatch
 call :Compile glob\glob
-call :Compile guile GUILE
-call :Compile hash
-call :Compile implicit
-call :Compile job
-call :Compile load
-call :Compile loadapi
-call :Compile main GUILE
-call :Compile misc
-call :Compile output
-call :Compile read
-call :Compile remake
-call :Compile remote-stub
-call :Compile rule
-call :Compile signame
-call :Compile strcache
-call :Compile variable
-call :Compile version
-call :Compile vpath
-call :Compile w32\pathstuff
-call :Compile w32\w32os
-call :Compile w32\compat\posixfcn
-call :Compile w32\subproc\misc
-call :Compile w32\subproc\sub_proc
-call :Compile w32\subproc\w32err
-
-if not "%COMPILER%" == "gcc" call :Compile w32\compat\dirent
+
+if not "%COMPILER%" == "gcc" call :Compile src\w32\compat\dirent
 
 call :Link
 
@@ -208,21 +213,21 @@ if exist %OUTDIR%\%MAKE%.exe copy /Y Basic.mk Makefile
 goto :EOF
 
 :Compile
+echo %OUTDIR%\%1.%O% >>%OUTDIR%\link.sc
 set EXTRAS=
 if "%2" == "GUILE" set "EXTRAS=%GUILECFLAGS%"
 if "%COMPILER%" == "gcc" goto GccCompile
 
 :: MSVC Compile
 echo on
-%COMPILER% /nologo /MT /W4 /EHsc %OPTS% /I %OUTDIR% /I . /I glob /I w32/include /D WINDOWS32 /D WIN32 /D _CONSOLE /D HAVE_CONFIG_H /FR%OUTDIR% /Fp%OUTDIR%\%MAKE%.pch /Fo%OUTDIR%\%1.obj /Fd%OUTDIR%\%MAKE%.pdb %EXTRAS% /c %1.c
+%COMPILER% /nologo /MT /W4 /EHsc %OPTS% /I %OUTDIR%/src /I src /I glob /I src/w32/include /D WINDOWS32 /D WIN32 /D _CONSOLE /D HAVE_CONFIG_H /FR%OUTDIR% /Fp%OUTDIR%\%MAKE%.pch /Fo%OUTDIR%\%1.%O% /Fd%OUTDIR%\%MAKE%.pdb %EXTRAS% /c %1.c
 @echo off
-echo %OUTDIR%\%1.obj >>%OUTDIR%\link.sc
 goto :EOF
 
 :GccCompile
 :: GCC Compile
 echo on
-gcc -mthreads -Wall -std=gnu99 -gdwarf-2 -g3 %OPTS% -I%OUTDIR% -I. -I./glob -I./w32/include -DWINDOWS32 -DHAVE_CONFIG_H %EXTRAS% -o %OUTDIR%\%1.o -c %1.c
+gcc -mthreads -Wall -std=gnu99 -gdwarf-2 -g3 %OPTS% -I%OUTDIR%/src -I./src -I./glob -I./src/w32/include -DWINDOWS32 -DHAVE_CONFIG_H %EXTRAS% -o %OUTDIR%\%1.%O% -c %1.c
 @echo off
 goto :EOF
 
@@ -240,18 +245,19 @@ goto :EOF
 :GccLink
 :: GCC Link
 echo on
-gcc -mthreads -gdwarf-2 -g3 -o %OUTDIR%\%MAKE%.exe %OUTDIR%\variable.o %OUTDIR%\rule.o %OUTDIR%\remote-stub.o %OUTDIR%\commands.o %OUTDIR%\file.o %OUTDIR%\getloadavg.o %OUTDIR%\default.o %OUTDIR%\signame.o %OUTDIR%\expand.o %OUTDIR%\dir.o %OUTDIR%\main.o %OUTDIR%\getopt1.o %OUTDIR%\guile.o %OUTDIR%\job.o %OUTDIR%\output.o %OUTDIR%\read.o %OUTDIR%\version.o %OUTDIR%\getopt.o %OUTDIR%\arscan.o %OUTDIR%\remake.o %OUTDIR%\misc.o %OUTDIR%\hash.o %OUTDIR%\strcache.o %OUTDIR%\ar.o %OUTDIR%\function.o %OUTDIR%\vpath.o %OUTDIR%\implicit.o %OUTDIR%\loadapi.o %OUTDIR%\load.o %OUTDIR%\glob\glob.o %OUTDIR%\glob\fnmatch.o %OUTDIR%\w32\pathstuff.o %OUTDIR%\w32\compat\posixfcn.o %OUTDIR%\w32\w32os.o %OUTDIR%\w32\subproc\misc.o %OUTDIR%\w32\subproc\sub_proc.o %OUTDIR%\w32\subproc\w32err.o %GUILELIBS% -lkernel32 -luser32 -lgdi32 -lwinspool -lcomdlg32 -ladvapi32 -lshell32 -lole32 -loleaut32 -luuid -lodbc32 -lodbccp32 -Wl,--out-implib=%OUTDIR%\libgnumake-1.dll.a
+echo %GUILELIBS% -lkernel32 -luser32 -lgdi32 -lwinspool -lcomdlg32 -ladvapi32 -lshell32 -lole32 -loleaut32 -luuid -lodbc32 -lodbccp32 >>%OUTDIR%\link.sc
+gcc -mthreads -gdwarf-2 -g3 %OPTS% -o %OUTDIR%\%MAKE%.exe @%OUTDIR%\link.sc -Wl,--out-implib=%OUTDIR%\libgnumake-1.dll.a
 @echo off
 goto :EOF
 
 :ConfigSCM
 echo Generating config from SCM templates
-sed -n "s/^AC_INIT(\[GNU make\],\[\([^]]\+\)\].*/s,%%VERSION%%,\1,g/p" configure.ac > %OUTDIR%\config.h.W32.sed
-echo s,%%PACKAGE%%,make,g >> %OUTDIR%\config.h.W32.sed
-sed -f %OUTDIR%\config.h.W32.sed config.h.W32.template > config.h.W32
-echo static const char *const GUILE_module_defn = ^" \> gmk-default.h
-sed -e "s/;.*//" -e "/^[ \t]*$/d" -e "s/\"/\\\\\"/g" -e "s/$/ \\\/" gmk-default.scm >> gmk-default.h
-echo ^";>> gmk-default.h
+sed -n "s/^AC_INIT(\[GNU make\],\[\([^]]\+\)\].*/s,%%VERSION%%,\1,g/p" configure.ac > %OUTDIR%\src\config.h.W32.sed
+echo s,%%PACKAGE%%,make,g >> %OUTDIR%\src\config.h.W32.sed
+sed -f %OUTDIR%\src\config.h.W32.sed src\config.h.W32.template > src\config.h.W32
+echo static const char *const GUILE_module_defn = ^" \ > src\gmk-default.h
+sed -e "s/;.*//" -e "/^[ \t]*$/d" -e "s/\"/\\\\\"/g" -e "s/$/ \\\/" src\gmk-default.scm >> src\gmk-default.h
+echo ^";>> src\gmk-default.h
 goto :EOF
 
 :ChkGuile
@@ -318,6 +324,7 @@ set GUILELIBS=
 set LINKOPTS=
 set MAKE=
 set NOGUILE=
+set O=
 set OPTS=
 set OUTDIR=
 set PKGMSC=
diff --git a/builddos.bat b/builddos.bat
index b96318d..0902b0d 100644
--- a/builddos.bat
+++ b/builddos.bat
@@ -31,39 +31,39 @@ if not "%XSRC%"=="%1" goto SmallEnv
 
 :SrcDone
 
-copy /Y %XSRC%/configh.dos ./config.h
+copy /Y %XSRC%/src/configh.dos ./src/config.h
 
 if not exist glob mkdir glob
 
 rem Echo ON so they will see what is going on.
 @echo on
-gcc -c -I%XSRC% -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/commands.c -o commands.o
-gcc -c -I%XSRC% -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/output.c -o output.o
-gcc -c -I%XSRC% -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/job.c -o job.o
-gcc -c -I%XSRC% -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/dir.c -o dir.o
-gcc -c -I%XSRC% -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/file.c -o file.o
-gcc -c -I%XSRC% -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/misc.c -o misc.o
-gcc -c -I%XSRC% -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/main.c -o main.o
-gcc -c -I%XSRC% -I%XSRC%/glob -DHAVE_CONFIG_H -DINCLUDEDIR=\"c:/djgpp/include\" -O2 -g %XSRC%/read.c -o read.o
-gcc -c -I%XSRC% -I%XSRC%/glob -DHAVE_CONFIG_H -DLIBDIR=\"c:/djgpp/lib\" -O2 -g %XSRC%/remake.c -o remake.o
-gcc -c -I%XSRC% -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/rule.c -o rule.o
-gcc -c -I%XSRC% -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/implicit.c -o implicit.o
-gcc -c -I%XSRC% -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/default.c -o default.o
-gcc -c -I%XSRC% -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/variable.c -o variable.o
-gcc -c -I%XSRC% -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/expand.c -o expand.o
-gcc -c -I%XSRC% -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/function.c -o function.o
-gcc -c -I%XSRC% -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/vpath.c -o vpath.o
-gcc -c -I%XSRC% -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/hash.c -o hash.o
-gcc -c -I%XSRC% -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/strcache.c -o strcache.o
-gcc -c -I%XSRC% -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/version.c -o version.o
-gcc -c -I%XSRC% -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/ar.c -o ar.o
-gcc -c -I%XSRC% -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/arscan.c -o arscan.o
-gcc -c -I%XSRC% -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/signame.c -o signame.o
-gcc -c -I%XSRC% -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/remote-stub.c -o remote-stub.o
-gcc -c -I%XSRC% -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/getopt.c -o getopt.o
-gcc -c -I%XSRC% -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/getopt1.c -o getopt1.o
-gcc -c -I%XSRC% -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/glob/glob.c -o glob/glob.o
-gcc -c -I%XSRC% -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/glob/fnmatch.c -o glob/fnmatch.o
+gcc -c -I%XSRC%/src -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/src/commands.c -o commands.o
+gcc -c -I%XSRC%/src -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/src/output.c -o output.o
+gcc -c -I%XSRC%/src -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/src/job.c -o job.o
+gcc -c -I%XSRC%/src -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/src/dir.c -o dir.o
+gcc -c -I%XSRC%/src -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/src/file.c -o file.o
+gcc -c -I%XSRC%/src -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/src/misc.c -o misc.o
+gcc -c -I%XSRC%/src -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/src/main.c -o main.o
+gcc -c -I%XSRC%/src -I%XSRC%/glob -DHAVE_CONFIG_H -DINCLUDEDIR=\"c:/djgpp/include\" -O2 -g %XSRC%/src/read.c -o read.o
+gcc -c -I%XSRC%/src -I%XSRC%/glob -DHAVE_CONFIG_H -DLIBDIR=\"c:/djgpp/lib\" -O2 -g %XSRC%/src/remake.c -o remake.o
+gcc -c -I%XSRC%/src -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/src/rule.c -o rule.o
+gcc -c -I%XSRC%/src -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/src/implicit.c -o implicit.o
+gcc -c -I%XSRC%/src -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/src/default.c -o default.o
+gcc -c -I%XSRC%/src -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/src/variable.c -o variable.o
+gcc -c -I%XSRC%/src -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/src/expand.c -o expand.o
+gcc -c -I%XSRC%/src -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/src/function.c -o function.o
+gcc -c -I%XSRC%/src -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/src/vpath.c -o vpath.o
+gcc -c -I%XSRC%/src -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/src/hash.c -o hash.o
+gcc -c -I%XSRC%/src -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/src/strcache.c -o strcache.o
+gcc -c -I%XSRC%/src -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/src/version.c -o version.o
+gcc -c -I%XSRC%/src -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/src/ar.c -o ar.o
+gcc -c -I%XSRC%/src -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/src/arscan.c -o arscan.o
+gcc -c -I%XSRC%/src -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/src/signame.c -o signame.o
+gcc -c -I%XSRC%/src -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/src/remote-stub.c -o remote-stub.o
+gcc -c -I%XSRC%/src -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/src/getopt.c -o getopt.o
+gcc -c -I%XSRC%/src -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/src/getopt1.c -o getopt1.o
+gcc -c -I%XSRC%/src -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/glob/glob.c -o glob/glob.o
+gcc -c -I%XSRC%/src -I%XSRC%/glob -DHAVE_CONFIG_H -O2 -g %XSRC%/glob/fnmatch.c -o glob/fnmatch.o
 @echo off
 echo commands.o > respf.$$$
 for %%f in (job output dir file misc main read remake rule implicit default variable) do echo %%f.o >> respf.$$$
diff --git a/commands.c b/commands.c
deleted file mode 100644
index 75a9d2d..0000000
--- a/commands.c
+++ /dev/null
@@ -1,710 +0,0 @@
-/* Command processing for GNU Make.
-Copyright (C) 1988-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-#include "filedef.h"
-#include "dep.h"
-#include "variable.h"
-#include "job.h"
-#include "commands.h"
-#ifdef WINDOWS32
-#include <windows.h>
-#include "w32err.h"
-#endif
-
-#if VMS
-# define FILE_LIST_SEPARATOR (vms_comma_separator ? ',' : ' ')
-#else
-# define FILE_LIST_SEPARATOR ' '
-#endif
-
-#ifndef HAVE_UNISTD_H
-int getpid ();
-#endif
-
-
-static unsigned long
-dep_hash_1 (const void *key)
-{
-  const struct dep *d = key;
-  return_STRING_HASH_1 (dep_name (d));
-}
-
-static unsigned long
-dep_hash_2 (const void *key)
-{
-  const struct dep *d = key;
-  return_STRING_HASH_2 (dep_name (d));
-}
-
-static int
-dep_hash_cmp (const void *x, const void *y)
-{
-  const struct dep *dx = x;
-  const struct dep *dy = y;
-  return strcmp (dep_name (dx), dep_name (dy));
-}
-
-/* Set FILE's automatic variables up.  */
-
-void
-set_file_variables (struct file *file)
-{
-  struct dep *d;
-  const char *at, *percent, *star, *less;
-
-#ifndef NO_ARCHIVES
-  /* If the target is an archive member 'lib(member)',
-     then $@ is 'lib' and $% is 'member'.  */
-
-  if (ar_name (file->name))
-    {
-      unsigned int len;
-      const char *cp;
-      char *p;
-
-      cp = strchr (file->name, '(');
-      p = alloca (cp - file->name + 1);
-      memcpy (p, file->name, cp - file->name);
-      p[cp - file->name] = '\0';
-      at = p;
-      len = strlen (cp + 1);
-      p = alloca (len);
-      memcpy (p, cp + 1, len - 1);
-      p[len - 1] = '\0';
-      percent = p;
-    }
-  else
-#endif  /* NO_ARCHIVES.  */
-    {
-      at = file->name;
-      percent = "";
-    }
-
-  /* $* is the stem from an implicit or static pattern rule.  */
-  if (file->stem == 0)
-    {
-      /* In Unix make, $* is set to the target name with
-         any suffix in the .SUFFIXES list stripped off for
-         explicit rules.  We store this in the 'stem' member.  */
-      const char *name;
-      unsigned int len;
-
-#ifndef NO_ARCHIVES
-      if (ar_name (file->name))
-        {
-          name = strchr (file->name, '(') + 1;
-          len = strlen (name) - 1;
-        }
-      else
-#endif
-        {
-          name = file->name;
-          len = strlen (name);
-        }
-
-      for (d = enter_file (strcache_add (".SUFFIXES"))->deps; d ; d = d->next)
-        {
-          unsigned int slen = strlen (dep_name (d));
-          if (len > slen && strneq (dep_name (d), name + (len - slen), slen))
-            {
-              file->stem = strcache_add_len (name, len - slen);
-              break;
-            }
-        }
-      if (d == 0)
-        file->stem = "";
-    }
-  star = file->stem;
-
-  /* $< is the first not order-only dependency.  */
-  less = "";
-  for (d = file->deps; d != 0; d = d->next)
-    if (!d->ignore_mtime)
-      {
-        if (!d->need_2nd_expansion)
-          less = dep_name (d);
-        break;
-      }
-
-  if (file->cmds == default_file->cmds)
-    /* This file got its commands from .DEFAULT.
-       In this case $< is the same as $@.  */
-    less = at;
-
-#define DEFINE_VARIABLE(name, len, value) \
-  (void) define_variable_for_file (name,len,value,o_automatic,0,file)
-
-  /* Define the variables.  */
-
-  DEFINE_VARIABLE ("<", 1, less);
-  DEFINE_VARIABLE ("*", 1, star);
-  DEFINE_VARIABLE ("@", 1, at);
-  DEFINE_VARIABLE ("%", 1, percent);
-
-  /* Compute the values for $^, $+, $?, and $|.  */
-
-  {
-    static char *plus_value=0, *bar_value=0, *qmark_value=0;
-    static unsigned int plus_max=0, bar_max=0, qmark_max=0;
-
-    unsigned int qmark_len, plus_len, bar_len;
-    char *cp;
-    char *caret_value;
-    char *qp;
-    char *bp;
-    unsigned int len;
-
-    struct hash_table dep_hash;
-    void **slot;
-
-    /* Compute first the value for $+, which is supposed to contain
-       duplicate dependencies as they were listed in the makefile.  */
-
-    plus_len = 0;
-    bar_len = 0;
-    for (d = file->deps; d != 0; d = d->next)
-      {
-        if (!d->need_2nd_expansion)
-          {
-            if (d->ignore_mtime)
-              bar_len += strlen (dep_name (d)) + 1;
-            else
-              plus_len += strlen (dep_name (d)) + 1;
-          }
-      }
-
-    if (bar_len == 0)
-      bar_len++;
-
-    if (plus_len == 0)
-      plus_len++;
-
-    if (plus_len > plus_max)
-      plus_value = xrealloc (plus_value, plus_max = plus_len);
-
-    cp = plus_value;
-
-    qmark_len = plus_len + 1;   /* Will be this or less.  */
-    for (d = file->deps; d != 0; d = d->next)
-      if (! d->ignore_mtime && ! d->need_2nd_expansion)
-        {
-          const char *c = dep_name (d);
-
-#ifndef NO_ARCHIVES
-          if (ar_name (c))
-            {
-              c = strchr (c, '(') + 1;
-              len = strlen (c) - 1;
-            }
-          else
-#endif
-            len = strlen (c);
-
-          memcpy (cp, c, len);
-          cp += len;
-          *cp++ = FILE_LIST_SEPARATOR;
-          if (! (d->changed || always_make_flag))
-            qmark_len -= len + 1;       /* Don't space in $? for this one.  */
-        }
-
-    /* Kill the last space and define the variable.  */
-
-    cp[cp > plus_value ? -1 : 0] = '\0';
-    DEFINE_VARIABLE ("+", 1, plus_value);
-
-    /* Compute the values for $^, $?, and $|.  */
-
-    cp = caret_value = plus_value; /* Reuse the buffer; it's big enough.  */
-
-    if (qmark_len > qmark_max)
-      qmark_value = xrealloc (qmark_value, qmark_max = qmark_len);
-    qp = qmark_value;
-
-    if (bar_len > bar_max)
-      bar_value = xrealloc (bar_value, bar_max = bar_len);
-    bp = bar_value;
-
-    /* Make sure that no dependencies are repeated in $^, $?, and $|.  It
-       would be natural to combine the next two loops but we can't do it
-       because of a situation where we have two dep entries, the first
-       is order-only and the second is normal (see below).  */
-
-    hash_init (&dep_hash, 500, dep_hash_1, dep_hash_2, dep_hash_cmp);
-
-    for (d = file->deps; d != 0; d = d->next)
-      {
-        if (d->need_2nd_expansion)
-          continue;
-
-        slot = hash_find_slot (&dep_hash, d);
-        if (HASH_VACANT (*slot))
-          hash_insert_at (&dep_hash, d, slot);
-        else
-          {
-            /* Check if the two prerequisites have different ignore_mtime.
-               If so then we need to "upgrade" one that is order-only.  */
-
-            struct dep* hd = (struct dep*) *slot;
-
-            if (d->ignore_mtime != hd->ignore_mtime)
-              d->ignore_mtime = hd->ignore_mtime = 0;
-          }
-      }
-
-    for (d = file->deps; d != 0; d = d->next)
-      {
-        const char *c;
-
-        if (d->need_2nd_expansion || hash_find_item (&dep_hash, d) != d)
-          continue;
-
-        c = dep_name (d);
-#ifndef NO_ARCHIVES
-        if (ar_name (c))
-          {
-            c = strchr (c, '(') + 1;
-            len = strlen (c) - 1;
-          }
-        else
-#endif
-          len = strlen (c);
-
-        if (d->ignore_mtime)
-          {
-            memcpy (bp, c, len);
-            bp += len;
-            *bp++ = FILE_LIST_SEPARATOR;
-          }
-        else
-          {
-            memcpy (cp, c, len);
-            cp += len;
-            *cp++ = FILE_LIST_SEPARATOR;
-            if (d->changed || always_make_flag)
-              {
-                memcpy (qp, c, len);
-                qp += len;
-                *qp++ = FILE_LIST_SEPARATOR;
-              }
-          }
-      }
-
-    hash_free (&dep_hash, 0);
-
-    /* Kill the last spaces and define the variables.  */
-
-    cp[cp > caret_value ? -1 : 0] = '\0';
-    DEFINE_VARIABLE ("^", 1, caret_value);
-
-    qp[qp > qmark_value ? -1 : 0] = '\0';
-    DEFINE_VARIABLE ("?", 1, qmark_value);
-
-    bp[bp > bar_value ? -1 : 0] = '\0';
-    DEFINE_VARIABLE ("|", 1, bar_value);
-  }
-
-#undef  DEFINE_VARIABLE
-}
-
-/* Chop CMDS up into individual command lines if necessary.
-   Also set the 'lines_flags' and 'any_recurse' members.  */
-
-void
-chop_commands (struct commands *cmds)
-{
-  unsigned int nlines, idx;
-  char **lines;
-
-  /* If we don't have any commands,
-     or we already parsed them, never mind.  */
-
-  if (!cmds || cmds->command_lines != 0)
-    return;
-
-  /* Chop CMDS->commands up into lines in CMDS->command_lines.  */
-
-  if (one_shell)
-    {
-      int l = strlen (cmds->commands);
-
-      nlines = 1;
-      lines = xmalloc (nlines * sizeof (char *));
-      lines[0] = xstrdup (cmds->commands);
-
-      /* Strip the trailing newline.  */
-      if (l > 0 && lines[0][l-1] == '\n')
-        lines[0][l-1] = '\0';
-    }
-  else
-    {
-      const char *p;
-
-      nlines = 5;
-      lines = xmalloc (nlines * sizeof (char *));
-      idx = 0;
-      p = cmds->commands;
-      while (*p != '\0')
-        {
-          const char *end = p;
-        find_end:;
-          end = strchr (end, '\n');
-          if (end == 0)
-            end = p + strlen (p);
-          else if (end > p && end[-1] == '\\')
-            {
-              int backslash = 1;
-              const char *b;
-              for (b = end - 2; b >= p && *b == '\\'; --b)
-                backslash = !backslash;
-              if (backslash)
-                {
-                  ++end;
-                  goto find_end;
-                }
-            }
-
-          if (idx == nlines)
-            {
-              nlines += 2;
-              lines = xrealloc (lines, nlines * sizeof (char *));
-            }
-          lines[idx++] = xstrndup (p, end - p);
-          p = end;
-          if (*p != '\0')
-            ++p;
-        }
-
-      if (idx != nlines)
-        {
-          nlines = idx;
-          lines = xrealloc (lines, nlines * sizeof (char *));
-        }
-    }
-
-  /* Finally, set the corresponding CMDS->lines_flags elements and the
-     CMDS->any_recurse flag.  */
-
-  if (nlines > USHRT_MAX)
-    ON (fatal, &cmds->fileinfo, _("Recipe has too many lines (%ud)"), nlines);
-
-  cmds->ncommand_lines = nlines;
-  cmds->command_lines = lines;
-
-  cmds->any_recurse = 0;
-  cmds->lines_flags = xmalloc (nlines);
-
-  for (idx = 0; idx < nlines; ++idx)
-    {
-      unsigned char flags = 0;
-      const char *p = lines[idx];
-
-      while (ISBLANK (*p) || *p == '-' || *p == '@' || *p == '+')
-        switch (*(p++))
-          {
-          case '+':
-            flags |= COMMANDS_RECURSE;
-            break;
-          case '@':
-            flags |= COMMANDS_SILENT;
-            break;
-          case '-':
-            flags |= COMMANDS_NOERROR;
-            break;
-          }
-
-      /* If no explicit '+' was given, look for MAKE variable references.  */
-      if (!(flags & COMMANDS_RECURSE)
-          && (strstr (p, "$(MAKE)") != 0 || strstr (p, "${MAKE}") != 0))
-        flags |= COMMANDS_RECURSE;
-
-      cmds->lines_flags[idx] = flags;
-      cmds->any_recurse |= flags & COMMANDS_RECURSE ? 1 : 0;
-    }
-}
-
-/* Execute the commands to remake FILE.  If they are currently executing,
-   return or have already finished executing, just return.  Otherwise,
-   fork off a child process to run the first command line in the sequence.  */
-
-void
-execute_file_commands (struct file *file)
-{
-  const char *p;
-
-  /* Don't go through all the preparations if
-     the commands are nothing but whitespace.  */
-
-  for (p = file->cmds->commands; *p != '\0'; ++p)
-    if (!ISSPACE (*p) && *p != '-' && *p != '@' && *p != '+')
-      break;
-  if (*p == '\0')
-    {
-      /* If there are no commands, assume everything worked.  */
-      set_command_state (file, cs_running);
-      file->update_status = us_success;
-      notice_finished_file (file);
-      return;
-    }
-
-  /* First set the automatic variables according to this file.  */
-
-  initialize_file_variables (file, 0);
-
-  set_file_variables (file);
-
-  /* If this is a loaded dynamic object, unload it before remaking.
-     Some systems don't support overwriting a loaded object.  */
-  if (file->loaded)
-    unload_file (file->name);
-
-  /* Start the commands running.  */
-  new_job (file);
-}
-
-/* This is set while we are inside fatal_error_signal,
-   so things can avoid nonreentrant operations.  */
-
-int handling_fatal_signal = 0;
-
-/* Handle fatal signals.  */
-
-RETSIGTYPE
-fatal_error_signal (int sig)
-{
-#ifdef __MSDOS__
-  extern int dos_status, dos_command_running;
-
-  if (dos_command_running)
-    {
-      /* That was the child who got the signal, not us.  */
-      dos_status |= (sig << 8);
-      return;
-    }
-  remove_intermediates (1);
-  exit (EXIT_FAILURE);
-#else /* not __MSDOS__ */
-#ifdef _AMIGA
-  remove_intermediates (1);
-  if (sig == SIGINT)
-     fputs (_("*** Break.\n"), stderr);
-
-  exit (10);
-#else /* not Amiga */
-#ifdef WINDOWS32
-  extern HANDLE main_thread;
-
-  /* Windows creates a sperate thread for handling Ctrl+C, so we need
-     to suspend the main thread, or else we will have race conditions
-     when both threads call reap_children.  */
-  if (main_thread)
-    {
-      DWORD susp_count = SuspendThread (main_thread);
-
-      if (susp_count != 0)
-        fprintf (stderr, "SuspendThread: suspend count = %ld\n", susp_count);
-      else if (susp_count == (DWORD)-1)
-        {
-          DWORD ierr = GetLastError ();
-
-          fprintf (stderr, "SuspendThread: error %ld: %s\n",
-                   ierr, map_windows32_error_to_string (ierr));
-        }
-    }
-#endif
-  handling_fatal_signal = 1;
-
-  /* Set the handling for this signal to the default.
-     It is blocked now while we run this handler.  */
-  signal (sig, SIG_DFL);
-
-  /* A termination signal won't be sent to the entire
-     process group, but it means we want to kill the children.  */
-
-  if (sig == SIGTERM)
-    {
-      struct child *c;
-      for (c = children; c != 0; c = c->next)
-        if (!c->remote)
-          (void) kill (c->pid, SIGTERM);
-    }
-
-  /* If we got a signal that means the user
-     wanted to kill make, remove pending targets.  */
-
-  if (sig == SIGTERM || sig == SIGINT
-#ifdef SIGHUP
-    || sig == SIGHUP
-#endif
-#ifdef SIGQUIT
-    || sig == SIGQUIT
-#endif
-    )
-    {
-      struct child *c;
-
-      /* Remote children won't automatically get signals sent
-         to the process group, so we must send them.  */
-      for (c = children; c != 0; c = c->next)
-        if (c->remote)
-          (void) remote_kill (c->pid, sig);
-
-      for (c = children; c != 0; c = c->next)
-        delete_child_targets (c);
-
-      /* Clean up the children.  We don't just use the call below because
-         we don't want to print the "Waiting for children" message.  */
-      while (job_slots_used > 0)
-        reap_children (1, 0);
-    }
-  else
-    /* Wait for our children to die.  */
-    while (job_slots_used > 0)
-      reap_children (1, 1);
-
-  /* Delete any non-precious intermediate files that were made.  */
-
-  remove_intermediates (1);
-
-#ifdef SIGQUIT
-  if (sig == SIGQUIT)
-    /* We don't want to send ourselves SIGQUIT, because it will
-       cause a core dump.  Just exit instead.  */
-    exit (MAKE_TROUBLE);
-#endif
-
-#ifdef WINDOWS32
-  if (main_thread)
-    CloseHandle (main_thread);
-  /* Cannot call W32_kill with a pid (it needs a handle).  The exit
-     status of 130 emulates what happens in Bash.  */
-  exit (130);
-#else
-  /* Signal the same code; this time it will really be fatal.  The signal
-     will be unblocked when we return and arrive then to kill us.  */
-  if (kill (getpid (), sig) < 0)
-    pfatal_with_name ("kill");
-#endif /* not WINDOWS32 */
-#endif /* not Amiga */
-#endif /* not __MSDOS__  */
-}
-
-/* Delete FILE unless it's precious or not actually a file (phony),
-   and it has changed on disk since we last stat'd it.  */
-
-static void
-delete_target (struct file *file, const char *on_behalf_of)
-{
-  struct stat st;
-  int e;
-
-  if (file->precious || file->phony)
-    return;
-
-#ifndef NO_ARCHIVES
-  if (ar_name (file->name))
-    {
-      time_t file_date = (file->last_mtime == NONEXISTENT_MTIME
-                          ? (time_t) -1
-                          : (time_t) FILE_TIMESTAMP_S (file->last_mtime));
-      if (ar_member_date (file->name) != file_date)
-        {
-          if (on_behalf_of)
-            OSS (error, NILF,
-                 _("*** [%s] Archive member '%s' may be bogus; not deleted"),
-                 on_behalf_of, file->name);
-          else
-            OS (error, NILF,
-                _("*** Archive member '%s' may be bogus; not deleted"),
-                file->name);
-        }
-      return;
-    }
-#endif
-
-  EINTRLOOP (e, stat (file->name, &st));
-  if (e == 0
-      && S_ISREG (st.st_mode)
-      && FILE_TIMESTAMP_STAT_MODTIME (file->name, st) != file->last_mtime)
-    {
-      if (on_behalf_of)
-        OSS (error, NILF,
-             _("*** [%s] Deleting file '%s'"), on_behalf_of, file->name);
-      else
-        OS (error, NILF, _("*** Deleting file '%s'"), file->name);
-      if (unlink (file->name) < 0
-          && errno != ENOENT)   /* It disappeared; so what.  */
-        perror_with_name ("unlink: ", file->name);
-    }
-}
-
-
-/* Delete all non-precious targets of CHILD unless they were already deleted.
-   Set the flag in CHILD to say they've been deleted.  */
-
-void
-delete_child_targets (struct child *child)
-{
-  struct dep *d;
-
-  if (child->deleted)
-    return;
-
-  /* Delete the target file if it changed.  */
-  delete_target (child->file, NULL);
-
-  /* Also remove any non-precious targets listed in the 'also_make' member.  */
-  for (d = child->file->also_make; d != 0; d = d->next)
-    delete_target (d->file, child->file->name);
-
-  child->deleted = 1;
-}
-
-/* Print out the commands in CMDS.  */
-
-void
-print_commands (const struct commands *cmds)
-{
-  const char *s;
-
-  fputs (_("#  recipe to execute"), stdout);
-
-  if (cmds->fileinfo.filenm == 0)
-    puts (_(" (built-in):"));
-  else
-    printf (_(" (from '%s', line %lu):\n"),
-            cmds->fileinfo.filenm, cmds->fileinfo.lineno);
-
-  s = cmds->commands;
-  while (*s != '\0')
-    {
-      const char *end;
-      int bs;
-
-      /* Print one full logical recipe line: find a non-escaped newline.  */
-      for (end = s, bs = 0; *end != '\0'; ++end)
-        {
-          if (*end == '\n' && !bs)
-            break;
-
-          bs = *end == '\\' ? !bs : 0;
-        }
-
-      printf ("%c%.*s\n", cmd_prefix, (int) (end - s), s);
-
-      s = end + (end[0] == '\n');
-    }
-}
diff --git a/commands.h b/commands.h
deleted file mode 100644
index 5983829..0000000
--- a/commands.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/* Definition of data structures describing shell commands for GNU Make.
-Copyright (C) 1988-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-/* Structure that gives the commands to make a file
-   and information about where these commands came from.  */
-
-struct commands
-  {
-    floc fileinfo;              /* Where commands were defined.  */
-    char *commands;             /* Commands text.  */
-    char **command_lines;       /* Commands chopped up into lines.  */
-    unsigned char *lines_flags; /* One set of flag bits for each line.  */
-    unsigned short ncommand_lines;/* Number of command lines.  */
-    char recipe_prefix;         /* Recipe prefix for this command set.  */
-    unsigned int any_recurse:1; /* Nonzero if any 'lines_flags' elt has */
-                                /* the COMMANDS_RECURSE bit set.  */
-  };
-
-/* Bits in 'lines_flags'.  */
-#define COMMANDS_RECURSE        1 /* Recurses: + or $(MAKE).  */
-#define COMMANDS_SILENT         2 /* Silent: @.  */
-#define COMMANDS_NOERROR        4 /* No errors: -.  */
-
-RETSIGTYPE fatal_error_signal (int sig);
-void execute_file_commands (struct file *file);
-void print_commands (const struct commands *cmds);
-void delete_child_targets (struct child *child);
-void chop_commands (struct commands *cmds);
-void set_file_variables (struct file *file);
diff --git a/config.ami.template b/config.ami.template
deleted file mode 100644
index 8141f0d..0000000
--- a/config.ami.template
+++ /dev/null
@@ -1,340 +0,0 @@
-/* config.h -- hand-massaged for Amiga                                  -*-C-*-
-Copyright (C) 1995-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-/* Define if on AIX 3.
-   System headers sometimes define this.
-   We just want to avoid a redefinition error message.  */
-#ifndef _ALL_SOURCE
-/* #undef _ALL_SOURCE */
-#endif
-
-/* Define if using alloca.c.  */
-#define C_ALLOCA
-
-/* Define if the closedir function returns void instead of int.  */
-/* #undef CLOSEDIR_VOID */
-
-/* Define to empty if the keyword does not work.  */
-/* #undef const */
-
-/* Define to one of _getb67, GETB67, getb67 for Cray-2 and Cray-YMP systems.
-   This function is required for alloca.c support on those systems.  */
-/* #undef CRAY_STACKSEG_END */
-
-/* Define for DGUX with <sys/dg_sys_info.h>.  */
-/* #undef DGUX */
-
-/* Define if the 'getloadavg' function needs to be run setuid or setgid.  */
-/* #undef GETLOADAVG_PRIVILEGED */
-
-/* Define to 'unsigned long' or 'unsigned long long'
-   if <inttypes.h> doesn't define.  */
-#define uintmax_t unsigned long
-
-/* Define to 'int' if <sys/types.h> doesn't define.  */
-#define gid_t int
-
-/* Define if you have alloca, as a function or macro.  */
-/* #undef HAVE_ALLOCA */
-
-/* Define if you have <alloca.h> and it should be used (not on Ultrix).  */
-/* #undef HAVE_ALLOCA_H */
-
-/* Define if your system has a working fnmatch function.  */
-/* #undef HAVE_FNMATCH */
-
-/* Define if your system has its own 'getloadavg' function.  */
-/* #undef HAVE_GETLOADAVG */
-
-/* Define if you have the getmntent function.  */
-/* #undef HAVE_GETMNTENT */
-
-/* Embed GNU Guile support */
-/* #undef HAVE_GUILE */
-
-/* Define if the 'long double' type works.  */
-/* #undef HAVE_LONG_DOUBLE */
-
-/* Define if you support file names longer than 14 characters.  */
-#define HAVE_LONG_FILE_NAMES 1
-
-/* Define if you have a working 'mmap' system call.  */
-/* #undef HAVE_MMAP */
-
-/* Define if system calls automatically restart after interruption
-   by a signal.  */
-/* #undef HAVE_RESTARTABLE_SYSCALLS */
-
-/* Define if your struct stat has st_blksize.  */
-/* #undef HAVE_ST_BLKSIZE */
-
-/* Define if your struct stat has st_blocks.  */
-/* #undef HAVE_ST_BLOCKS */
-
-/* Define if you have the strcoll function and it is properly defined.  */
-#define HAVE_STRCOLL 1
-
-/* Define if your struct stat has st_rdev.  */
-#define HAVE_ST_RDEV 1
-
-/* Define if you have the strftime function.  */
-#define HAVE_STRFTIME 1
-
-/* Define if you have <sys/wait.h> that is POSIX.1 compatible.  */
-/* #undef HAVE_SYS_WAIT_H */
-
-/* Define if your struct tm has tm_zone.  */
-/* #undef HAVE_TM_ZONE */
-
-/* Define if you don't have tm_zone but do have the external array
-   tzname.  */
-#define HAVE_TZNAME 1
-
-/* Define if you have <unistd.h>.  */
-#define HAVE_UNISTD_H 1
-
-/* Define if utime(file, NULL) sets file's timestamp to the present.  */
-/* #undef HAVE_UTIME_NULL */
-
-/* Define if you have the wait3 system call.  */
-/* #undef HAVE_WAIT3 */
-
-/* Define if on MINIX.  */
-/* #undef _MINIX */
-
-/* Define if your struct nlist has an n_un member.  */
-/* #undef NLIST_NAME_UNION */
-
-/* Define if you have <nlist.h>.  */
-/* #undef NLIST_STRUCT */
-
-/* Define if your C compiler doesn't accept -c and -o together.  */
-/* #undef NO_MINUS_C_MINUS_O */
-
-/* Define to 'int' if <sys/types.h> doesn't define.  */
-#define pid_t int
-
-/* Define if the system does not provide POSIX.1 features except
-   with this defined.  */
-/* #undef _POSIX_1_SOURCE */
-
-/* Define if you need to in order for stat and other things to work.  */
-/* #undef _POSIX_SOURCE */
-
-/* Define as the return type of signal handlers (int or void).  */
-#define RETSIGTYPE void
-
-/* Define if the setvbuf function takes the buffering type as its second
-   argument and the buffer pointer as the third, as on System V
-   before release 3.  */
-/* #undef SETVBUF_REVERSED */
-
-/* If using the C implementation of alloca, define if you know the
-   direction of stack growth for your system; otherwise it will be
-   automatically deduced at run-time.
-        STACK_DIRECTION > 0 => grows toward higher addresses
-        STACK_DIRECTION < 0 => grows toward lower addresses
-        STACK_DIRECTION = 0 => direction of growth unknown
- */
-#define STACK_DIRECTION -1
-
-/* Define if the 'S_IS*' macros in <sys/stat.h> do not work properly.  */
-/* #undef STAT_MACROS_BROKEN */
-
-/* Define if you have the ANSI C header files.  */
-#define STDC_HEADERS
-
-/* Define on System V Release 4.  */
-/* #undef SVR4 */
-
-/* Define if 'sys_siglist' is declared by <signal.h>.  */
-/* #undef SYS_SIGLIST_DECLARED */
-
-/* Define to 'int' if <sys/types.h> doesn't define.  */
-#define uid_t int
-
-/* Define for Encore UMAX.  */
-/* #undef UMAX */
-
-/* Define for Encore UMAX 4.3 that has <inq_status/cpustats.h>
-   instead of <sys/cpustats.h>.  */
-/* #undef UMAX4_3 */
-
-/* Name of this package (needed by automake) */
-#define PACKAGE "%PACKAGE%"
-
-/* Version of this package (needed by automake) */
-#define VERSION "%VERSION%"
-
-/* Define to the name of the SCCS 'get' command.  */
-#define SCCS_GET "get"
-
-/* Define this if the SCCS 'get' command understands the '-G<file>' option.  */
-/* #undef SCCS_GET_MINUS_G */
-
-/* Define this to enable job server support in GNU make.  */
-/* #undef MAKE_JOBSERVER */
-
-/* Define to be the nanoseconds member of struct stat's st_mtim,
-   if it exists.  */
-/* #undef ST_MTIM_NSEC */
-
-/* Define this if the C library defines the variable 'sys_siglist'.  */
-/* #undef HAVE_SYS_SIGLIST */
-
-/* Define this if the C library defines the variable '_sys_siglist'.  */
-/* #undef HAVE__SYS_SIGLIST */
-
-/* Define this if you have the 'union wait' type in <sys/wait.h>.  */
-/* #undef HAVE_UNION_WAIT */
-
-/* Define if you have the dup2 function.  */
-/* #undef HAVE_DUP2 */
-
-/* Define if you have the getcwd function.  */
-#define HAVE_GETCWD 1
-
-/* Define if you have the getgroups function.  */
-/* #undef HAVE_GETGROUPS */
-
-/* Define if you have the gethostbyname function.  */
-/* #undef HAVE_GETHOSTBYNAME */
-
-/* Define if you have the gethostname function.  */
-/* #undef HAVE_GETHOSTNAME */
-
-/* Define if you have the memmove function.  */
-#define HAVE_MEMMOVE 1
-
-/* Define if you have the mktemp function.  */
-#define HAVE_MKTEMP 1
-
-/* Define if you have the psignal function.  */
-/* #undef HAVE_PSIGNAL */
-
-/* Define if you have the pstat_getdynamic function.  */
-/* #undef HAVE_PSTAT_GETDYNAMIC */
-
-/* Define if you have the setegid function.  */
-/* #undef HAVE_SETEGID */
-
-/* Define if you have the seteuid function.  */
-/* #undef HAVE_SETEUID */
-
-/* Define if you have the setlinebuf function.  */
-/* #undef HAVE_SETLINEBUF */
-
-/* Define if you have the setregid function.  */
-/* #undef HAVE_SETREGID */
-
-/* Define if you have the setreuid function.  */
-/* #undef HAVE_SETREUID */
-
-/* Define if you have the sigsetmask function.  */
-/* #undef HAVE_SIGSETMASK */
-
-/* Define if you have the socket function.  */
-/* #undef HAVE_SOCKET */
-
-/* Define to 1 if you have the strcasecmp function.  */
-/* #undef HAVE_STRCASECMP */
-
-/* Define to 1 if you have the strcmpi function.  */
-/* #undef HAVE_STRCMPI */
-
-/* Define to 1 if you have the stricmp function.  */
-/* #undef HAVE_STRICMP */
-
-/* Define if you have the strerror function.  */
-#define HAVE_STRERROR 1
-
-/* Define if you have the strsignal function.  */
-/* #undef HAVE_STRSIGNAL */
-
-/* Define if you have the wait3 function.  */
-/* #undef HAVE_WAIT3 */
-
-/* Define if you have the waitpid function.  */
-/* #undef HAVE_WAITPID */
-
-/* Define if you have the <dirent.h> header file.  */
-#define HAVE_DIRENT_H 1
-
-/* Define if you have the <fcntl.h> header file.  */
-#define HAVE_FCNTL_H 1
-
-/* Define if you have the <limits.h> header file.  */
-#define HAVE_LIMITS_H 1
-
-/* Define if you have the <mach/mach.h> header file.  */
-/* #undef HAVE_MACH_MACH_H */
-
-/* Define if you have the <memory.h> header file.  */
-/* #undef HAVE_MEMORY_H */
-
-/* Define if you have the <ndir.h> header file.  */
-/* #undef HAVE_NDIR_H */
-
-/* Define if you have the <stdlib.h> header file.  */
-/* #undef HAVE_STDLIB_H */
-
-/* Define if you have the <string.h> header file.  */
-#define HAVE_STRING_H 1
-
-/* Define if you have the <sys/dir.h> header file.  */
-#define HAVE_SYS_DIR_H 1
-
-/* Define if you have the <sys/ndir.h> header file.  */
-/* #undef HAVE_SYS_NDIR_H */
-
-/* Define if you have the <sys/param.h> header file.  */
-/* #undef HAVE_SYS_PARAM_H */
-
-/* Define if you have the <sys/timeb.h> header file.  */
-/* #undef HAVE_SYS_TIMEB_H */
-
-/* Define if you have the <sys/wait.h> header file.  */
-/* #undef HAVE_SYS_WAIT_H */
-
-/* Define if you have the <unistd.h> header file.  */
-#define HAVE_UNISTD_H 1
-
-/* Define if you have the dgc library (-ldgc).  */
-/* #undef HAVE_LIBDGC */
-
-/* Define if you have the kstat library (-lkstat).  */
-/* #undef HAVE_LIBKSTAT */
-
-/* Define to 1 if you have the `isatty' function. */
-/* #undef HAVE_ISATTY */
-
-/* Define to 1 if you have the `ttyname' function. */
-/* #undef HAVE_TTYNAME */
-
-/* Define if you have the sun library (-lsun).  */
-/* #undef HAVE_LIBSUN */
-
-/* Output sync sypport */
-#define NO_OUTPUT_SYNC
-
-/* Define for Case Insensitve behavior */
-#define HAVE_CASE_INSENSITIVE_FS
-
-/* Build host information. */
-#define MAKE_HOST "Amiga"
-
-/* Define to `int' if <sys/types.h> does not define. */
-#define ssize_t int
diff --git a/config.h-vms.template b/config.h-vms.template
deleted file mode 100644
index 3cb9a74..0000000
--- a/config.h-vms.template
+++ /dev/null
@@ -1,436 +0,0 @@
-/* config.h-vms. Generated by hand by Klaus Kmpf <kkaempf@rmi.de>      -*-C-*-
-
-Copyright (C) 1996-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-/* config.h.  Generated automatically by configure.  */
-/* config.h.in.  Generated automatically from configure.ac by autoheader.  */
-
-/* Pull in types.h here to get __CRTL_VER defined for old versions of the
-   compiler which don't define it. */
-#ifdef __DECC
-# include <types.h>
-#endif
-
-/* Define to 1 if on AIX 3.
-   System headers sometimes define this.
-   We just want to avoid a redefinition error message.  */
-#ifndef _ALL_SOURCE
-/* #undef _ALL_SOURCE */
-#endif
-
-/* Define to 1 if NLS is requested.  */
-/* #undef ENABLE_NLS */
-
-/* Define as 1 if you have dcgettext.  */
-/* #undef HAVE_DCGETTEXT */
-
-/* Define as 1 if you have gettext and don't want to use GNU gettext.  */
-/* #undef HAVE_GETTEXT */
-
-/* Embed GNU Guile support */
-/* #undef HAVE_GUILE */
-
-/* Define to 1 if your locale.h file contains LC_MESSAGES.  */
-/* #undef HAVE_LC_MESSAGES */
-
-/* Define to the installation directory for locales.  */
-#define LOCALEDIR ""
-
-/* Define as 1 if you have the stpcpy function.  */
-/* #undef HAVE_STPCPY */
-
-/* Define to 1 if the closedir function returns void instead of int.  */
-/* #undef CLOSEDIR_VOID */
-
-/* Define to empty if the keyword does not work.  */
-/* #undef const */
-
-/* Define to one of _getb67, GETB67, getb67 for Cray-2 and Cray-YMP systems.
-   This function is required for alloca.c support on those systems.  */
-/* #undef CRAY_STACKSEG_END */
-
-/* Define for DGUX with <sys/dg_sys_info.h>.  */
-/* #undef DGUX */
-
-/* Define to 1 if the 'getloadavg' function needs to be run setuid or setgid.  */
-/* #undef GETLOADAVG_PRIVILEGED */
-
-/* Define to 'unsigned long' or 'unsigned long long'
-   if <inttypes.h> doesn't define.  */
-#define uintmax_t unsigned long
-
-/* Define to 'int' if <sys/types.h> doesn't define.  */
-/* #undef gid_t */
-
-/* Define to 1 if you have alloca, as a function or macro.  */
-#define HAVE_ALLOCA 1
-
-/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).  */
-/* #undef HAVE_ALLOCA_H */
-
-/* Define to 1 if you have the fdopen function.  */
-#define HAVE_FDOPEN 1
-
-/* Define to 1 if your system has a working fnmatch function.  */
-/* #undef HAVE_FNMATCH */
-
-/* Define to 1 if your system has its own 'getloadavg' function.  */
-/* #undef HAVE_GETLOADAVG */
-
-/* Define to 1 if you have the getmntent function.  */
-/* #undef HAVE_GETMNTENT */
-
-/* Define to 1 if the 'long double' type works.  */
-/* #undef HAVE_LONG_DOUBLE */
-
-/* Define to 1 if you support file names longer than 14 characters.  */
-#define HAVE_LONG_FILE_NAMES 1
-
-/* Define to 1 if you have a working 'mmap' system call.  */
-/* #undef HAVE_MMAP */
-
-/* Define to 1 if system calls automatically restart after interruption
-   by a signal.  */
-/* #undef HAVE_RESTARTABLE_SYSCALLS */
-
-/* Define to 1 if your struct stat has st_blksize.  */
-/* #undef HAVE_ST_BLKSIZE */
-
-/* Define to 1 if your struct stat has st_blocks.  */
-/* #undef HAVE_ST_BLOCKS */
-
-/* Define to 1 if you have the strcoll function and it is properly defined.  */
-/* #undef HAVE_STRCOLL */
-
-/* Define to 1 if you have the strncasecmp' function. */
-#if __CRTL_VER >= 70000000
-#define HAVE_STRNCASECMP 1
-#endif
-
-/* Define to 1 if your struct stat has st_rdev.  */
-/* #undef HAVE_ST_RDEV */
-
-/* Define to 1 if you have the strftime function.  */
-/* #undef HAVE_STRFTIME */
-
-/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible.  */
-/* #undef HAVE_SYS_WAIT_H */
-
-/* Define to 1 if your struct tm has tm_zone.  */
-/* #undef HAVE_TM_ZONE */
-
-/* Define to 1 if you don't have tm_zone but do have the external array
-   tzname.  */
-/* #undef HAVE_TZNAME */
-
-/* Define to 1 if you have <unistd.h>.  */
-#ifdef __DECC
-#define HAVE_UNISTD_H 1
-#endif
-
-/* Define to 1 if utime(file, NULL) sets file's timestamp to the present.  */
-/* #undef HAVE_UTIME_NULL */
-
-/* Define to 1 if you have the wait3 system call.  */
-/* #undef HAVE_WAIT3 */
-
-/* Define to 1 if on MINIX.  */
-/* #undef _MINIX */
-
-/* Define to 1 if your struct nlist has an n_un member.  */
-/* #undef NLIST_NAME_UNION */
-
-/* Define to 1 if you have <nlist.h>.  */
-/* #undef NLIST_STRUCT */
-
-/* Define to 1 if your C compiler doesn't accept -c and -o together.  */
-/* #undef NO_MINUS_C_MINUS_O */
-
-/* Define to 'int' if <sys/types.h> doesn't define.  */
-/* I assume types.h is available for all 5.0 cc/cxx compilers */
-#if __DECC_VER < 50090000
-#define pid_t int
-#endif
-
-/* Define to 1 if the system does not provide POSIX.1 features except
-   with this defined.  */
-/* #undef _POSIX_1_SOURCE */
-
-/* Define to 1 if you need to in order for stat and other things to work.  */
-/* #undef _POSIX_SOURCE */
-
-/* Define as the return type of signal handlers (int or void).  */
-#define RETSIGTYPE void
-
-/* Define to 1 if the setvbuf function takes the buffering type as its second
-   argument and the buffer pointer as the third, as on System V
-   before release 3.  */
-/* #undef SETVBUF_REVERSED */
-
-/* If using the C implementation of alloca, define if you know the
-   direction of stack growth for your system; otherwise it will be
-   automatically deduced at run-time.
-        STACK_DIRECTION > 0 => grows toward higher addresses
-        STACK_DIRECTION < 0 => grows toward lower addresses
-        STACK_DIRECTION = 0 => direction of growth unknown
- */
-/* #undef STACK_DIRECTION */
-
-/* Define to 1 if the 'S_IS*' macros in <sys/stat.h> do not work properly.  */
-/* #undef STAT_MACROS_BROKEN */
-
-/* Define to 1 if you have the ANSI C header files.  */
-/* #undef STDC_HEADERS */
-
-/* Define on System V Release 4.  */
-/* #undef SVR4 */
-
-/* Define to 1 if 'sys_siglist' is declared by <signal.h>.  */
-/* #undef SYS_SIGLIST_DECLARED */
-
-/* Define to 'int' if <sys/types.h> doesn't define.  */
-#if __DECC_VER < 50090000
-#define uid_t int
-#endif
-
-/* Define for Encore UMAX.  */
-/* #undef UMAX */
-
-/* Define for Encore UMAX 4.3 that has <inq_status/cpustats.h>
-   instead of <sys/cpustats.h>.  */
-/* #undef UMAX4_3 */
-
-/* Name of this package (needed by automake) */
-#define PACKAGE "%PACKAGE%"
-
-/* Version of this package (needed by automake) */
-#define VERSION "%VERSION%"
-
-/* Define to the name of the SCCS 'get' command.  */
-/* #undef SCCS_GET */
-
-/* Define this if the SCCS 'get' command understands the '-G<file>' option.  */
-/* #undef SCCS_GET_MINUS_G */
-
-/* Define this to enable job server support in GNU make.  */
-/* #undef MAKE_JOBSERVER */
-
-/* Define to be the nanoseconds member of struct stat's st_mtim,
-   if it exists.  */
-/* #undef ST_MTIM_NSEC */
-
-/* Define to 1 if the C library defines the variable 'sys_siglist'.  */
-/* #undefine HAVE_SYS_SIGLIST */
-
-/* Define to 1 if the C library defines the variable '_sys_siglist'.  */
-/* #undef HAVE__SYS_SIGLIST */
-
-/* Define to 1 if you have the 'union wait' type in <sys/wait.h>.  */
-/* #undef HAVE_UNION_WAIT */
-
-/* Define to 1 if you have the dup2 function.  */
-#define HAVE_DUP2 1
-
-/* Define to 1 if you have the getcwd function.  */
-#define HAVE_GETCWD 1
-
-/* Define to 1 if you have the getgroups function.  */
-/* #undef HAVE_GETGROUPS */
-
-/* Define to 1 if you have the gethostbyname function.  */
-/* #undef HAVE_GETHOSTBYNAME */
-
-/* Define to 1 if you have the gethostname function.  */
-/* #undef HAVE_GETHOSTNAME */
-
-/* Define to 1 if you have the memmove function.  */
-#define HAVE_MEMMOVE 1
-
-/* Define to 1 if you have the mktemp function.  */
-#define HAVE_MKTEMP 1
-
-/* Define to 1 if you have the psignal function.  */
-/* #undef HAVE_PSIGNAL */
-
-/* Define to 1 if you have the pstat_getdynamic function.  */
-/* #undef HAVE_PSTAT_GETDYNAMIC */
-
-/* Define to 1 if you have the setegid function.  */
-/* #undef HAVE_SETEGID */
-
-/* Define to 1 if you have the seteuid function.  */
-/* #undef HAVE_SETEUID */
-
-/* Define to 1 if you have the setlinebuf function.  */
-/* #undef HAVE_SETLINEBUF */
-
-/* Define to 1 if you have the setregid function.  */
-/* #undefine HAVE_SETREGID */
-
-/* Define to 1 if you have the setreuid function.  */
-/* #define HAVE_SETREUID */
-
-/* Define to 1 if you have the sigsetmask function.  */
-#define HAVE_SIGSETMASK 1
-
-/* Define to 1 if you have the socket function.  */
-/* #undef HAVE_SOCKET */
-
-/* Define to 1 if you have the strcasecmp function.  */
-#define HAVE_STRCASECMP 1
-
-/* Define to 1 if you have the strcmpi function.  */
-/* #undef HAVE_STRCMPI */
-
-/* Define to 1 if you have the stricmp function.  */
-/* #undef HAVE_STRICMP */
-
-/* Define to 1 if you have the strerror function.  */
-#define HAVE_STRERROR 1
-
-/* Define to 1 if you have the strsignal function.  */
-/* #undef HAVE_STRSIGNAL */
-
-/* Define to 1 if you have the wait3 function.  */
-/* #undef HAVE_WAIT3 */
-
-/* Define to 1 if you have the waitpid function.  */
-/* #undef HAVE_WAITPID */
-
-/* Define to 1 if you have the <dirent.h> header file.  */
-#define HAVE_DIRENT_H 1
-
-/* Define to 1 if you have the <fcntl.h> header file.  */
-#ifdef __DECC
-#define HAVE_FCNTL_H 1
-#endif
-
-/* Define to 1 if you have the <limits.h> header file.  */
-#define HAVE_LIMITS_H 1
-
-/* Define to 1 if you have the <mach/mach.h> header file.  */
-/* #undef HAVE_MACH_MACH_H */
-
-/* Define to 1 if you have the <memory.h> header file.  */
-/* #undef HAVE_MEMORY_H */
-
-/* Define to 1 if you have the <ndir.h> header file.  */
-/* #undef HAVE_NDIR_H */
-
-/* Define to 1 if you have the <stdlib.h> header file.  */
-#define HAVE_STDLIB_H 1
-
-/* Define to 1 if you have the <string.h> header file.  */
-#define HAVE_STRING_H 1
-
-/* Define to 1 if you have the <sys/dir.h> header file.  */
-/* #undef HAVE_SYS_DIR_H */
-
-/* Define to 1 if you have the <sys/ndir.h> header file.  */
-/* #undef HAVE_SYS_NDIR_H */
-
-/* Define to 1 if you have the <sys/param.h> header file.  */
-/* #undef HAVE_SYS_PARAM_H */
-
-/* Define to 1 if you have the <sys/timeb.h> header file.  */
-#ifndef __GNUC__
-#define HAVE_SYS_TIMEB_H 1
-#endif
-
-/* Define to 1 if you have the <sys/wait.h> header file.  */
-/* #undef HAVE_SYS_WAIT_H */
-
-/* Define to 1 if you have the dgc library (-ldgc).  */
-/* #undef HAVE_LIBDGC */
-
-/* Define to 1 if you have the kstat library (-lkstat).  */
-/* #undef HAVE_LIBKSTAT *
-
-/* Define to 1 if you have the sun library (-lsun).  */
-/* #undef HAVE_LIBSUN */
-
-/* Define to 1 if you have the `isatty' function. */
-/* #undef HAVE_ISATTY */
-
-/* Define to 1 if you have the `ttyname' function. */
-/* #undef HAVE_TTYNAME */
-
-/* Use high resolution file timestamps if nonzero. */
-#define FILE_TIMESTAMP_HI_RES 0
-
-/* Define for case insensitve filenames */
-#define HAVE_CASE_INSENSITIVE_FS 1
-
-/* VMS specific, define it if you want to use case sensitive targets */
-/* #undef WANT_CASE_SENSITIVE_TARGETS */
-
-/* VMS specific, V7.0 has opendir() and friends, so it's undefined */
-/* If you want to use non-VMS code for opendir() etc. on V7.0 and greater
-   define the first or both macros AND change the compile command to get the
-   non-VMS versions linked: (prefix=(all,except=(opendir,...  */
-/* #undef HAVE_VMSDIR_H */
-/* #undef _DIRENT_HAVE_D_NAMLEN */
-
-/* On older systems without 7.0 backport of CRTL use non-VMS code for opendir() etc. */
-#if __CRTL_VER < 70000000
-# define HAVE_VMSDIR_H 1
-#endif
-
-#if defined(HAVE_VMSDIR_H) && defined(HAVE_DIRENT_H)
-#undef HAVE_DIRENT_H
-#endif
-
-#define HAVE_STDLIB_H 1
-#define INCLUDEDIR "sys$sysroot:[syslib]"
-#define LIBDIR "sys$sysroot:[syslib]"
-
-/* Don't use RTL functions of OpenVMS */
-#ifdef __DECC
-#include <stdio.h>
-#include <unistd.h>
-#define getopt   gnu_getopt
-#define optarg   gnu_optarg
-#define optopt   gnu_optopt
-#define optind   gnu_optind
-#define opterr   gnu_opterr
-#define globfree gnu_globfree
-#define glob     gnu_glob
-#endif
-
-/* Define if using alloca.c.  */
-/* #undef C_ALLOCA */
-/* maybe this should be placed into makeint.h */
-#if     defined(__VAX) && defined(__DECC)
-#define alloca(n)       __ALLOCA(n)
-#endif
-
-/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
-   significant byte first (like Motorola and SPARC, unlike Intel). */
-/* #  undef WORDS_BIGENDIAN */
-
-/* Output sync sypport */
-#define NO_OUTPUT_SYNC
-
-/* Define to 1 to write even short single-line actions into a VMS/DCL command
-   file; this also enables exporting make environment variables into the
-   (sub-)process, which executes the action.
-   The usual make rules apply whether a shell variable - here a DCL symbol or
-   VMS logical [see CRTL getenv()] - is added to the make environment and
-   is exported. */
-#define USE_DCL_COM_FILE 1
-
-/* Build host information. */
-#define MAKE_HOST "VMS"
diff --git a/config.h.W32.template b/config.h.W32.template
deleted file mode 100644
index 4b5da00..0000000
--- a/config.h.W32.template
+++ /dev/null
@@ -1,541 +0,0 @@
-/* config.h.W32 -- hand-massaged config.h file for Windows builds       -*-C-*-
-
-Copyright (C) 1996-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-/* Suppress some Visual C++ warnings.
-   Maybe after the code cleanup for ISO C we can remove some/all of these.  */
-#if _MSC_VER > 1000
-# pragma warning(disable:4100) /* unreferenced formal parameter */
-# pragma warning(disable:4102) /* unreferenced label */
-# pragma warning(disable:4127) /* conditional expression is constant */
-# pragma warning(disable:4131) /* uses old-style declarator */
-# pragma warning(disable:4702) /* unreachable code */
-# define _CRT_SECURE_NO_WARNINGS  /* function or variable may be unsafe */
-# define _CRT_NONSTDC_NO_WARNINGS /* functions w/o a leading underscore */
-#endif
-
-/* Define to 1 if the 'closedir' function returns void instead of 'int'. */
-/* #undef CLOSEDIR_VOID */
-
-/* Define to one of '_getb67', 'GETB67', 'getb67' for Cray-2 and Cray-YMP
-   systems. This function is required for 'alloca.c' support on those systems.
-   */
-/* #undef CRAY_STACKSEG_END */
-
-/* Define to 1 if using 'alloca.c'. */
-/* #undef C_ALLOCA */
-
-/* Define to 1 if using 'getloadavg.c'. */
-#define C_GETLOADAVG 1
-
-/* Define to 1 for DGUX with <sys/dg_sys_info.h>. */
-/* #undef DGUX */
-
-/* Define to 1 if translation of program messages to the user's native
-   language is requested. */
-/* #undef ENABLE_NLS */
-
-/* Use high resolution file timestamps if nonzero. */
-#define FILE_TIMESTAMP_HI_RES 0
-
-/* Define to 1 if the 'getloadavg' function needs to be run setuid or setgid.
-   */
-/* #undef GETLOADAVG_PRIVILEGED */
-
-/* Define to 1 if you have 'alloca', as a function or macro. */
-#define HAVE_ALLOCA 1
-
-/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
-   */
-/* #undef HAVE_ALLOCA_H */
-
-/* Define to 1 if you have the 'atexit' function. */
-#define HAVE_ATEXIT 1
-
-/* Use case insensitive file names */
-/* #undef HAVE_CASE_INSENSITIVE_FS */
-
-/* Define to 1 if you have the clock_gettime function. */
-/* #undef HAVE_CLOCK_GETTIME */
-
-/* Embed GNU Guile support.  Windows build sets this on the
-   compilation command line.  */
-/* #undef HAVE_GUILE */
-
-/* Define if the GNU dcgettext() function is already present or preinstalled.
-   */
-/* #undef HAVE_DCGETTEXT */
-
-/* Define to 1 if you have the declaration of 'bsd_signal', and to 0 if you
-   don't. */
-#define HAVE_DECL_BSD_SIGNAL 0
-
-/* Define to 1 if you have the declaration of 'sys_siglist', and to 0 if you
-   don't. */
-#define HAVE_DECL_SYS_SIGLIST 0
-
-/* Define to 1 if you have the declaration of '_sys_siglist', and to 0 if you
-   don't. */
-#define HAVE_DECL__SYS_SIGLIST 0
-
-/* Define to 1 if you have the declaration of '__sys_siglist', and to 0 if you
-   don't. */
-#define HAVE_DECL___SYS_SIGLIST 0
-
-/* Define to 1 if you have the <dirent.h> header file, and it defines 'DIR'.
-   */
-#define HAVE_DIRENT_H 1
-
-/* Define to 1 if you have the <direct.h> header file, and it defines getcwd()
-   and chdir().
-   */
-#if (defined(_MSC_VER) || defined(__BORLANDC__)) && !defined(__INTERIX)
-# define HAVE_DIRECT_H 1
-#endif
-
-/* Use platform specific coding */
-#define HAVE_DOS_PATHS 1
-
-/* Define to 1 if you have the 'dup2' function. */
-#define HAVE_DUP2 1
-
-/* Define to 1 if you have the <fcntl.h> header file. */
-#define HAVE_FCNTL_H 1
-
-/* Define to 1 if you have the 'fdopen' function. */
-#ifdef __MINGW32__
-#define HAVE_FDOPEN 1
-#endif
-
-/* Define to 1 if you have the 'fileno' function. */
-#define HAVE_FILENO 1
-
-/* Define to 1 if you have the 'getcwd' function.  */
-#define HAVE_GETCWD 1
-
-/* Define to 1 if you have the 'getgroups' function. */
-/* #undef HAVE_GETGROUPS */
-
-/* Define to 1 if you have the 'gethostbyname' function. */
-/* #undef HAVE_GETHOSTBYNAME */
-
-/* Define to 1 if you have the 'gethostname' function. */
-/* #undef HAVE_GETHOSTNAME */
-
-/* Define to 1 if you have the 'getloadavg' function. */
-/* #undef HAVE_GETLOADAVG */
-
-/* Define to 1 if you have the 'getrlimit' function. */
-/* #undef HAVE_GETRLIMIT */
-
-/* Define if the GNU gettext() function is already present or preinstalled. */
-/* #undef HAVE_GETTEXT */
-
-/* Define to 1 if you have a standard gettimeofday function */
-#ifdef __MINGW32__
-#define HAVE_GETTIMEOFDAY 1
-#endif
-
-/* Define if you have the iconv() function. */
-/* #undef HAVE_ICONV */
-
-/* Define to 1 if you have the <inttypes.h> header file. */
-#ifdef __MINGW32__
-#define HAVE_INTTYPES_H 1
-#endif
-
-/* Define to 1 if you have the 'dgc' library (-ldgc). */
-/* #undef HAVE_LIBDGC */
-
-/* Define to 1 if you have the 'kstat' library (-lkstat). */
-/* #undef HAVE_LIBKSTAT */
-
-/* Define to 1 if you have the <limits.h> header file. */
-#define HAVE_LIMITS_H 1
-
-/* Define to 1 if you have the <locale.h> header file. */
-/*#define HAVE_LOCALE_H 1*/
-
-/* Define to 1 if you have the 'lstat' function. */
-/* #undef HAVE_LSTAT */
-
-/* Define to 1 if you have the <mach/mach.h> header file. */
-/* #undef HAVE_MACH_MACH_H */
-
-/* Define to 1 if you have the <memory.h> header file. */
-#define HAVE_MEMORY_H 1
-
-/* Define to 1 if you have the 'mkstemp' function. */
-/* #undef HAVE_MKSTEMP */
-
-/* Define to 1 if you have the 'mktemp' function. */
-#define HAVE_MKTEMP 1
-
-/* Define to 1 if you have the <ndir.h> header file, and it defines 'DIR'. */
-/* #undef HAVE_NDIR_H */
-
-/* Define to 1 if you have the <nlist.h> header file. */
-/* #undef HAVE_NLIST_H */
-
-/* Define to 1 if you have the 'pipe' function. */
-/* #undef HAVE_PIPE */
-
-/* Define to 1 if you have the 'pstat_getdynamic' function. */
-/* #undef HAVE_PSTAT_GETDYNAMIC */
-
-/* Define to 1 if you have the 'readlink' function. */
-/* #undef HAVE_READLINK */
-
-/* Define to 1 if you have the 'realpath' function. */
-/* #undef HAVE_REALPATH */
-
-/* Define to 1 if <signal.h> defines the SA_RESTART constant. */
-/* #undef HAVE_SA_RESTART */
-
-/* Define to 1 if you have the 'setegid' function. */
-/* #undef HAVE_SETEGID */
-
-/* Define to 1 if you have the 'seteuid' function. */
-/* #undef HAVE_SETEUID */
-
-/* Define to 1 if you have the 'setlinebuf' function. */
-/* #undef HAVE_SETLINEBUF */
-
-/* Define to 1 if you have the 'setlocale' function. */
-/*#define HAVE_SETLOCALE 1*/
-
-/* Define to 1 if you have the 'setregid' function. */
-/* #undef HAVE_SETREGID */
-
-/* Define to 1 if you have the 'setreuid' function. */
-/* #undef HAVE_SETREUID */
-
-/* Define to 1 if you have the 'setrlimit' function. */
-/* #undef HAVE_SETRLIMIT */
-
-/* Define to 1 if you have the 'setvbuf' function. */
-#define HAVE_SETVBUF 1
-
-/* Define to 1 if you have the 'sigaction' function. */
-/* #undef HAVE_SIGACTION */
-
-/* Define to 1 if you have the 'sigsetmask' function. */
-/* #undef HAVE_SIGSETMASK */
-
-/* Define to 1 if you have the 'socket' function. */
-/* #undef HAVE_SOCKET */
-
-/* Define to 1 if you have the <stdint.h> header file. */
-#ifdef __MINGW32__
-#define HAVE_STDINT_H 1
-#endif
-
-/* Define to 1 if you have the <stdlib.h> header file. */
-#define HAVE_STDLIB_H 1
-
-/* Define to 1 if you have the 'strcasecmp' function. */
-#ifdef __MINGW32__
-#define HAVE_STRCASECMP 1
-#endif
-
-/* Define to 1 if you have the 'strcmpi' function. */
-#define HAVE_STRCMPI 1
-
-/* Define to 1 if you have the 'strcoll' function and it is properly defined.
-   */
-#define HAVE_STRCOLL 1
-
-/* Define to 1 if you have the 'strdup' function. */
-#define HAVE_STRDUP 1
-
-/* Define to 1 if you have the 'strerror' function. */
-#define HAVE_STRERROR 1
-
-/* Define to 1 if you have the 'stricmp' function. */
-#define HAVE_STRICMP 1
-
-/* Define to 1 if you have the <strings.h> header file. */
-#ifdef __MINGW32__
-#define HAVE_STRINGS_H 1
-#endif
-
-/* Define to 1 if you have the <string.h> header file. */
-#define HAVE_STRING_H 1
-
-/* Define to 1 if you have the 'strncasecmp' function. */
-#ifdef __MINGW32__
-#define HAVE_STRNCASECMP 1
-#endif
-
-/* Define to 1 if you have the 'strncmpi' function. */
-/* #undef HAVE_STRNCMPI */
-
-/* Define to 1 if you have the 'strndup' function. */
-/* #undef HAVE_STRNDUP */
-
-/* Define to 1 if you have the 'strnicmp' function. */
-#ifdef __MINGW32__
-#define HAVE_STRNICMP 1
-#endif
-
-/* Define to 1 if you have the 'strsignal' function. */
-/* #undef HAVE_STRSIGNAL */
-
-/* Define to 1 if you have the `isatty' function. */
-#define HAVE_ISATTY 1
-
-/* Define to 1 if you have the `ttyname' function. */
-#define HAVE_TTYNAME 1
-char *ttyname (int);
-
-/* Define to 1 if 'n_un.n_name' is a member of 'struct nlist'. */
-/* #undef HAVE_STRUCT_NLIST_N_UN_N_NAME */
-
-/* Define to 1 if you have the <sys/dir.h> header file, and it defines 'DIR'.
-   */
-/* #undef HAVE_SYS_DIR_H */
-
-/* Define to 1 if you have the <sys/ndir.h> header file, and it defines 'DIR'.
-   */
-/* #undef HAVE_SYS_NDIR_H */
-
-/* Define to 1 if you have the <sys/param.h> header file. */
-#ifdef __MINGW32__
-#define HAVE_SYS_PARAM_H 1
-#endif
-
-/* Define to 1 if you have the <sys/resource.h> header file. */
-/* #undef HAVE_SYS_RESOURCE_H */
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#define HAVE_SYS_STAT_H 1
-
-/* Define to 1 if you have the <sys/timeb.h> header file. */
-#define HAVE_SYS_TIMEB_H 1
-
-/* Define to 1 if you have the <sys/time.h> header file. */
-#ifdef __MINGW32__
-#define HAVE_SYS_TIME_H 1
-#endif
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#define HAVE_SYS_TYPES_H 1
-
-/* Define to 1 if you have the <sys/wait.h> header file. */
-/* #undef HAVE_SYS_WAIT_H */
-
-/* Define to 1 if you have the \'union wait' type in <sys/wait.h>. */
-/* #undef HAVE_UNION_WAIT */
-
-/* Define to 1 if you have the <unistd.h> header file. */
-#ifdef __MINGW32__
-#define HAVE_UNISTD_H 1
-#endif
-
-/* Define to 1 if you have the 'wait3' function. */
-/* #undef HAVE_WAIT3 */
-
-/* Define to 1 if you have the 'waitpid' function. */
-/* #undef HAVE_WAITPID */
-
-/* Build host information. */
-#define MAKE_HOST "Windows32"
-
-/* Define to 1 to enable job server support in GNU make. */
-#define MAKE_JOBSERVER 1
-
-/* Define to 1 to enable 'load' support in GNU make. */
-#define MAKE_LOAD 1
-
-/* Define to 1 to enable symbolic link timestamp checking. */
-/* #undef MAKE_SYMLINKS */
-
-/* Define to 1 if your 'struct nlist' has an 'n_un' member. Obsolete, depend
-   on 'HAVE_STRUCT_NLIST_N_UN_N_NAME */
-/* #undef NLIST_NAME_UNION */
-
-/* Define to 1 if struct nlist.n_name is a pointer rather than an array. */
-/* #undef NLIST_STRUCT */
-
-/* Define to 1 if your C compiler doesn't accept -c and -o together. */
-/* #undef NO_MINUS_C_MINUS_O */
-
-/* Name of this package (needed by automake) */
-#define PACKAGE "%PACKAGE%"
-
-/* Define to the address where bug reports for this package should be sent. */
-#define PACKAGE_BUGREPORT "bug-make@gnu.org"
-
-/* Define to the full name of this package. */
-#define PACKAGE_NAME "GNU make"
-
-/* Define to the home page for this package. */
-#define PACKAGE_URL "http://www.gnu.org/software/make/"
-
-/* Define to the version of this package. */
-#define PACKAGE_VERSION "%VERSION%"
-
-/* Define to the character that separates directories in PATH. */
-#define PATH_SEPARATOR_CHAR ';'
-
-/* Define as the return type of signal handlers ('int' or 'void'). */
-#define RETSIGTYPE void
-
-/* Define to the name of the SCCS 'get' command. */
-#define SCCS_GET "echo no sccs get"
-
-/* Define this if the SCCS 'get' command understands the '-G<file>' option. */
-/* #undef SCCS_GET_MINUS_G */
-
-/* Define to 1 if the 'setvbuf' function takes the buffering type as its
-   second argument and the buffer pointer as the third, as on System V before
-   release 3. */
-/* #undef SETVBUF_REVERSED */
-
-/* If using the C implementation of alloca, define if you know the
-   direction of stack growth for your system; otherwise it will be
-   automatically deduced at run time.
-        STACK_DIRECTION > 0 => grows toward higher addresses
-        STACK_DIRECTION < 0 => grows toward lower addresses
-        STACK_DIRECTION = 0 => direction of growth unknown */
-/* #undef STACK_DIRECTION */
-
-/* Define to 1 if the 'S_IS*' macros in <sys/stat.h> do not work properly. */
-/* #undef STAT_MACROS_BROKEN */
-
-/* Define to 1 if you have the ANSI C header files. */
-#define STDC_HEADERS 1
-
-/* Define if struct stat contains a nanoseconds field */
-/* #undef ST_MTIM_NSEC */
-
-/* Define to 1 on System V Release 4. */
-/* #undef SVR4 */
-
-/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
-#ifdef __MINGW32__
-#define TIME_WITH_SYS_TIME 1
-#endif
-
-/* Define to 1 for Encore UMAX. */
-/* #undef UMAX */
-
-/* Define to 1 for Encore UMAX 4.3 that has <inq_status/cpustats.h> instead of
-   <sys/cpustats.h>. */
-/* #undef UMAX4_3 */
-
-/* Version number of package */
-#define VERSION "%VERSION%"
-
-/* Define if using the dmalloc debugging malloc package */
-/* #undef WITH_DMALLOC */
-
-/* Define to 1 if on AIX 3.
-   System headers sometimes define this.
-   We just want to avoid a redefinition error message.  */
-#ifndef _ALL_SOURCE
-/* # undef _ALL_SOURCE */
-#endif
-
-/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
-   significant byte first (like Motorola and SPARC, unlike Intel). */
-/* #  undef WORDS_BIGENDIAN */
-
-/* Number of bits in a file offset, on hosts where this is settable. */
-/* #undef _FILE_OFFSET_BITS */
-
-/* Define for large files, on AIX-style hosts. */
-/* #undef _LARGE_FILES */
-
-/* Define to 1 if on MINIX. */
-/* #undef _MINIX */
-
-/* Define to 2 if the system does not provide POSIX.1 features except with
-   this defined. */
-/* #undef _POSIX_1_SOURCE */
-
-/* Define to 1 if you need to in order for 'stat' and other things to work. */
-/* #undef _POSIX_SOURCE */
-
-/* Define to empty if 'const' does not conform to ANSI C. */
-/* #undef const */
-
-#include <sys/types.h>
-
-/* Define to 'int' if <sys/types.h> doesn't define. */
-#define gid_t int
-
-/* Define to 'int' if <sys/types.h> does not define. */
-/* GCC 4.x reportedly defines pid_t.  */
-#ifndef _PID_T_
-#ifdef _WIN64
-#define pid_t __int64
-#else
-#define pid_t int
-#endif
-#endif
-
-/* Define to `int' if <sys/types.h> does not define. */
-#define ssize_t int
-
-/* Define to 'int' if <sys/types.h> doesn't define. */
-#define uid_t int
-
-/* Define uintmax_t if not defined in <stdint.h> or <inttypes.h>. */
-#if !HAVE_STDINT_H && !HAVE_INTTYPES_H
-#define uintmax_t unsigned long
-#endif
-
-/* Define if you have <sys/wait.h> that is POSIX.1 compatible.  */
-/* #undef HAVE_SYS_WAIT_H */
-
-/* Define to the installation directory for locales.  */
-#define LOCALEDIR ""
-
-/*
- * Refer to README.W32 for info on the following settings
- */
-
-
-/*
- * If you have a shell that does not grok 'sh -c quoted-command-line'
- * correctly, you need this setting. Please see below for specific
- * shell support.
- */
-/*#define BATCH_MODE_ONLY_SHELL 1 */
-
-/*
- * Define if you have the Cygnus "Cygwin" GNU Windows32 tool set.
- * Do NOT define BATCH_MODE_ONLY_SHELL if you define HAVE_CYGWIN_SHELL
- */
-/*#define HAVE_CYGWIN_SHELL 1 */
-
-/*
- * Define if you have the MKS tool set or shell. Do NOT define
- * BATCH_MODE_ONLY_SHELL if you define HAVE_MKS_SHELL
- */
-/*#define HAVE_MKS_SHELL 1 */
-
-/*
- * Enforce the mutual exclusivity restriction.
- */
-#ifdef HAVE_MKS_SHELL
-#undef BATCH_MODE_ONLY_SHELL
-#endif
-
-#ifdef HAVE_CYGWIN_SHELL
-#undef BATCH_MODE_ONLY_SHELL
-#endif
diff --git a/config/acinclude.m4 b/config/acinclude.m4
new file mode 100644
index 0000000..544fd86
--- /dev/null
+++ b/config/acinclude.m4
@@ -0,0 +1,132 @@
+dnl acinclude.m4 -- Extra macros needed for GNU make.
+dnl
+dnl Automake will incorporate this into its generated aclocal.m4.
+dnl Copyright (C) 1998-2017 Free Software Foundation, Inc.
+dnl This file is part of GNU Make.
+dnl
+dnl GNU Make is free software; you can redistribute it and/or modify it under
+dnl the terms of the GNU General Public License as published by the Free
+dnl Software Foundation; either version 3 of the License, or (at your option)
+dnl any later version.
+dnl
+dnl GNU Make is distributed in the hope that it will be useful, but WITHOUT
+dnl ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+dnl FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for.
+dnl more details.
+dnl
+dnl You should have received a copy of the GNU General Public License along
+dnl with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+dnl ---------------------------------------------------------------------------
+dnl Got this from the lynx 2.8 distribution.
+dnl by T.E.Dickey <dickey@clark.net>
+dnl and Jim Spath <jspath@mail.bcpl.lib.md.us>
+dnl and Philippe De Muyter <phdm@macqel.be>
+dnl
+dnl Created: 1997/1/28
+dnl Updated: 1997/12/23
+dnl ---------------------------------------------------------------------------
+dnl After checking for functions in the default $LIBS, make a further check
+dnl for the functions that are netlib-related (these aren't always in the
+dnl libc, etc., and have to be handled specially because there are conflicting
+dnl and broken implementations.
+dnl Common library requirements (in order):
+dnl	-lresolv -lsocket -lnsl
+dnl	-lnsl -lsocket
+dnl	-lsocket
+dnl	-lbsd
+AC_DEFUN([CF_NETLIBS],[
+cf_test_netlibs=no
+AC_MSG_CHECKING(for network libraries)
+AC_CACHE_VAL(cf_cv_netlibs,[
+AC_MSG_RESULT(working...)
+cf_cv_netlibs=""
+cf_test_netlibs=yes
+AC_CHECK_FUNCS(gethostname,,[
+	CF_RECHECK_FUNC(gethostname,nsl,cf_cv_netlibs,[
+		CF_RECHECK_FUNC(gethostname,socket,cf_cv_netlibs)])])
+#
+# FIXME:  sequent needs this library (i.e., -lsocket -linet -lnsl), but
+# I don't know the entrypoints - 97/7/22 TD
+AC_CHECK_LIB(inet,main,cf_cv_netlibs="-linet $cf_cv_netlibs")
+#
+if test "$ac_cv_func_lsocket" != no ; then
+AC_CHECK_FUNCS(socket,,[
+	CF_RECHECK_FUNC(socket,socket,cf_cv_netlibs,[
+		CF_RECHECK_FUNC(socket,bsd,cf_cv_netlibs)])])
+fi
+#
+AC_CHECK_FUNCS(gethostbyname,,[
+	CF_RECHECK_FUNC(gethostbyname,nsl,cf_cv_netlibs)])
+])
+LIBS="$LIBS $cf_cv_netlibs"
+test $cf_test_netlibs = no && echo "$cf_cv_netlibs" >&AC_FD_MSG
+])dnl
+dnl ---------------------------------------------------------------------------
+dnl Re-check on a function to see if we can pick it up by adding a library.
+dnl	$1 = function to check
+dnl	$2 = library to check in
+dnl	$3 = environment to update (e.g., $LIBS)
+dnl	$4 = what to do if this fails
+dnl
+dnl This uses 'unset' if the shell happens to support it, but leaves the
+dnl configuration variable set to 'unknown' if not.  This is a little better
+dnl than the normal autoconf test, which gives misleading results if a test
+dnl for the function is made (e.g., with AC_CHECK_FUNC) after this macro is
+dnl used (autoconf does not distinguish between a null token and one that is
+dnl set to 'no').
+AC_DEFUN([CF_RECHECK_FUNC],[
+AC_CHECK_LIB($2,$1,[
+	CF_UPPER(cf_tr_func,$1)
+	AC_DEFINE_UNQUOTED(HAVE_$cf_tr_func,1,[Define if you have function $1])
+	ac_cv_func_$1=yes
+	$3="-l$2 [$]$3"],[
+	ac_cv_func_$1=unknown
+	unset ac_cv_func_$1 2>/dev/null
+	$4],
+	[[$]$3])
+])dnl
+dnl ---------------------------------------------------------------------------
+dnl Make an uppercase version of a variable
+dnl $1=uppercase($2)
+AC_DEFUN([CF_UPPER],
+[
+changequote(,)dnl
+$1=`echo $2 | tr '[a-z]' '[A-Z]'`
+changequote([,])dnl
+])dnl
+
+
+dnl ---------------------------------------------------------------------------
+dnl From Paul Eggert <eggert@twinsun.com>
+dnl Update for Darwin by Troy Runkel <Troy.Runkel@mathworks.com>
+dnl Update for AIX by Olexiy Buyanskyy (Savannah bug 32485)
+
+AC_DEFUN([AC_STRUCT_ST_MTIM_NSEC],
+ [AC_CACHE_CHECK([for nanoseconds field of struct stat],
+   ac_cv_struct_st_mtim_nsec,
+   [ac_save_CPPFLAGS="$CPPFLAGS"
+    ac_cv_struct_st_mtim_nsec=no
+    # st_mtim.tv_nsec -- the usual case
+    # st_mtim._tv_nsec -- Solaris 2.6, if
+    #	(defined _XOPEN_SOURCE && _XOPEN_SOURCE_EXTENDED == 1
+    #	 && !defined __EXTENSIONS__)
+    # st_mtim.st__tim.tv_nsec -- UnixWare 2.1.2
+    # st_mtime_n -- AIX 5.2 and above
+    # st_mtimespec.tv_nsec -- Darwin (Mac OSX)
+    for ac_val in st_mtim.tv_nsec st_mtim._tv_nsec st_mtim.st__tim.tv_nsec st_mtime_n st_mtimespec.tv_nsec; do
+      CPPFLAGS="$ac_save_CPPFLAGS -DST_MTIM_NSEC=$ac_val"
+      AC_TRY_COMPILE([#include <sys/types.h>
+#include <sys/stat.h>
+	], [struct stat s; s.ST_MTIM_NSEC;],
+        [ac_cv_struct_st_mtim_nsec=$ac_val; break])
+    done
+    CPPFLAGS="$ac_save_CPPFLAGS"
+   ])
+
+  if test $ac_cv_struct_st_mtim_nsec != no; then
+    AC_DEFINE_UNQUOTED([ST_MTIM_NSEC], [$ac_cv_struct_st_mtim_nsec],
+	[Define if struct stat contains a nanoseconds field])
+  fi
+ ]
+)
diff --git a/configh.dos.template b/configh.dos.template
deleted file mode 100644
index 72c501c..0000000
--- a/configh.dos.template
+++ /dev/null
@@ -1,116 +0,0 @@
-/* configh.dos -- hand-massaged config.h file for MS-DOS builds         -*-C-*-
-
-Copyright (C) 1994-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-/* Include this header to make __DJGPP_MINOR__ available because DJGPP ports
-   of GCC 4.3.0 and later no longer do it automatically.  */
-#include <sys/version.h>
-
-/* Many things are defined already by a system header.  */
-#include <sys/config.h>
-
-#if __DJGPP__ > 2 || __DJGPP_MINOR__ > 1
-
-/* Define to 1 if 'sys_siglist' is declared by <signal.h> or <unistd.h>. */
-# define SYS_SIGLIST_DECLARED 1
-
-/* Define to 1 if the C library defines the variable '_sys_siglist'.  */
-# define HAVE_DECL_SYS_SIGLIST 1
-
-#else
-
-/* Define NSIG.  */
-# define NSIG SIGMAX
-
-#endif
-
-/* Use high resolution file timestamps if nonzero. */
-#define FILE_TIMESTAMP_HI_RES 0
-
-/* Define to 1 if you have 'alloca', as a function or macro. */
-#define HAVE_ALLOCA 1
-
-/* Define to 1 if you have the fdopen function.  */
-#define HAVE_FDOPEN 1
-
-/* Define to 1 if you have the 'getgroups' function. */
-#define HAVE_GETGROUPS 1
-
-/* Define to 1 if you have the <memory.h> header file.  */
-#define HAVE_MEMORY_H 1
-
-/* Define to 1 if you have the mkstemp function.  */
-#define HAVE_MKSTEMP 1
-
-/* Define to 1 if you have the 'mktemp' function. */
-#define HAVE_MKTEMP 1
-
-/* Define to 1 if you have the 'setlinebuf' function. */
-#define HAVE_SETLINEBUF 1
-
-/* Define to 1 if you have the 'setvbuf' function. */
-#define HAVE_SETVBUF 1
-
-#define SCCS_GET "get"
-
-/* Define to 'unsigned long' or 'unsigned long long'
-   if <inttypes.h> doesn't define.  */
-#define uintmax_t unsigned long long
-
-/* Define the type of the first arg to select().  */
-#define fd_set_size_t int
-
-/* Define to 1 if you have the select function.  */
-#define HAVE_SELECT 1
-
-/* Define to 1 if you have the stricmp function.  */
-#define HAVE_STRICMP 1
-
-/* Define to 1 if you have the 'strncasecmp' function. */
-#define HAVE_STRNCASECMP 1
-
-/* Name of the package */
-#define PACKAGE "%PACKAGE%"
-
-/* Define to the address where bug reports for this package should be sent. */
-#define PACKAGE_BUGREPORT "bug-%PACKAGE%@gnu.org"
-
-/* Define to the full name of this package. */
-#define PACKAGE_NAME "GNU %PACKAGE%"
-
-/* Define to the full name and version of this package. */
-#define PACKAGE_STRING "GNU %PACKAGE% %VERSION%"
-
-/* Define to the one symbol short name of this package. */
-#define PACKAGE_TARNAME "%PACKAGE%"
-
-/* Define to the version of this package. */
-#define PACKAGE_VERSION "%VERSION%"
-
-/* Output sync sypport */
-#define NO_OUTPUT_SYNC
-
-/* Version number of package */
-#define VERSION "%VERSION%"
-
-/* Build host information. */
-#define MAKE_HOST "i386-pc-msdosdjgpp"
-
-/* Grok DOS paths (drive specs and backslash path element separators) */
-#define HAVE_DOS_PATHS
-
-/* Define to `int' if <sys/types.h> does not define. */
-#define ssize_t int
diff --git a/configure.ac b/configure.ac
index b7500ce..8c72568 100644
--- a/configure.ac
+++ b/configure.ac
@@ -22,8 +22,11 @@ AC_PREREQ([2.69])
 
 # Autoconf setup
 AC_CONFIG_AUX_DIR([config])
-AC_CONFIG_SRCDIR([vpath.c])
-AC_CONFIG_HEADERS([config.h])
+AC_CONFIG_SRCDIR([src/vpath.c])
+AC_CONFIG_HEADERS([src/config.h])
+
+# For now all our libobj code is in src/
+AC_CONFIG_LIBOBJ_DIR([src])
 
 # Automake setup
 # We have to enable "foreign" because ChangeLog is auto-generated
@@ -505,6 +508,8 @@ AS_IF([test "x$make_cv_load" = xno && test "x$user_load" = xyes],
 # Specify what files are to be created.
 AC_CONFIG_FILES([Makefile glob/Makefile po/Makefile.in config/Makefile \
                  doc/Makefile tests/config-flags.pm])
+# We don't need this, since the standard automake output will do.
+#mk/Posix.mk
 
 # OK, do it!
 
diff --git a/debug.h b/debug.h
deleted file mode 100644
index 2213c95..0000000
--- a/debug.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/* Debugging macros and interface.
-Copyright (C) 1999-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#define DB_NONE         (0x000)
-#define DB_BASIC        (0x001)
-#define DB_VERBOSE      (0x002)
-#define DB_JOBS         (0x004)
-#define DB_IMPLICIT     (0x008)
-#define DB_MAKEFILES    (0x100)
-
-#define DB_ALL          (0xfff)
-
-extern int db_level;
-
-#define ISDB(_l)    ((_l)&db_level)
-
-/* When adding macros to this list be sure to update the value of
-   XGETTEXT_OPTIONS in the po/Makevars file.  */
-#define DBS(_l,_x)  do{ if(ISDB(_l)) {print_spaces (depth); \
-                                      printf _x; fflush (stdout);} }while(0)
-
-#define DBF(_l,_x)  do{ if(ISDB(_l)) {print_spaces (depth); \
-                                      printf (_x, file->name); \
-                                      fflush (stdout);} }while(0)
-
-#define DB(_l,_x)   do{ if(ISDB(_l)) {printf _x; fflush (stdout);} }while(0)
diff --git a/default.c b/default.c
deleted file mode 100644
index 483339f..0000000
--- a/default.c
+++ /dev/null
@@ -1,757 +0,0 @@
-/* Data base of default implicit rules for GNU Make.
-Copyright (C) 1988-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-
-#include <assert.h>
-
-#include "filedef.h"
-#include "variable.h"
-#include "rule.h"
-#include "dep.h"
-#include "job.h"
-#include "commands.h"
-
-/* Define GCC_IS_NATIVE if gcc is the native development environment on
-   your system (gcc/bison/flex vs cc/yacc/lex).  */
-#if defined(__MSDOS__) || defined(__EMX__)
-# define GCC_IS_NATIVE
-#endif
-
-
-/* This is the default list of suffixes for suffix rules.
-   '.s' must come last, so that a '.o' file will be made from
-   a '.c' or '.p' or ... file rather than from a .s file.  */
-
-static char default_suffixes[]
-#ifdef VMS
-  /* VMS should include all UNIX/POSIX + some VMS extensions */
-  = ".out .exe .a .olb .hlb .tlb .mlb .ln .o .obj .c .cxx .cc .cpp .pas .p \
-.for .f .r .y .l .ym .yl .mar .s .ss .i .ii .mod .sym .def .h .info .dvi \
-.tex .texinfo .texi .txinfo .mem .hlp .brn .rnh .rno .rnt .rnx .w .ch .cweb \
-.web .com .sh .elc .el";
-#elif defined(__EMX__)
-  = ".out .a .ln .o .c .cc .C .cpp .p .f .F .m .r .y .l .ym .yl .s .S \
-.mod .sym .def .h .info .dvi .tex .texinfo .texi .txinfo \
-.w .ch .web .sh .elc .el .obj .exe .dll .lib";
-#else
-  = ".out .a .ln .o .c .cc .C .cpp .p .f .F .m .r .y .l .ym .yl .s .S \
-.mod .sym .def .h .info .dvi .tex .texinfo .texi .txinfo \
-.w .ch .web .sh .elc .el";
-#endif
-
-static struct pspec default_pattern_rules[] =
-  {
-#ifdef VMS
-    { "(%)", "%",
-        "@if f$$search(\"$@\") .eqs. \"\" then $(LIBRARY)/CREATE/"
-         "$(or "
-          "$(patsubst %,TEXT,$(filter %.tlb %.TLB,$@)),"
-          "$(patsubst %,HELP,$(filter %.hlb %.HLB,$@)),"
-          "$(patsubst %,MACRO,$(filter %.mlb %.MLB,$@)),"
-          "$(and "
-           "$(patsubst %,SHARE,$(filter %.olb %.OLB,$@)),"
-           "$(patsubst %,SHARE,$(filter %.exe %.EXE,$<))),"
-          "OBJECT)"
-         " $@\n"
-        "$(AR) $(ARFLAGS) $@ $<" },
-
-#else
-    { "(%)", "%",
-        "$(AR) $(ARFLAGS) $@ $<" },
-#endif
-    /* The X.out rules are only in BSD's default set because
-       BSD Make has no null-suffix rules, so 'foo.out' and
-       'foo' are the same thing.  */
-#ifdef VMS
-    { "%.exe", "%",
-        "$(CP) $< $@" },
-
-#endif
-    { "%.out", "%",
-        "@rm -f $@ \n cp $< $@" },
-
-    /* Syntax is "ctangle foo.w foo.ch foo.c".  */
-    { "%.c", "%.w %.ch",
-        "$(CTANGLE) $^ $@" },
-    { "%.tex", "%.w %.ch",
-        "$(CWEAVE) $^ $@" },
-
-    { 0, 0, 0 }
-  };
-
-static struct pspec default_terminal_rules[] =
-  {
-#ifdef VMS
-
-    /* RCS.  */
-    { "%", "%$$5lv", /* Multinet style */
-        "if f$$search(\"$@\") .nes. \"\" then +$(CHECKOUT,v)" },
-    { "%", "[.$$rcs]%$$5lv", /* Multinet style */
-        "if f$$search(\"$@\") .nes. \"\" then +$(CHECKOUT,v)" },
-    { "%", "%_v", /* Normal style */
-        "if f$$search(\"$@\") .nes. \"\" then +$(CHECKOUT,v)" },
-    { "%", "[.rcs]%_v", /* Normal style */
-        "if f$$search(\"$@\") .nes. \"\" then +$(CHECKOUT,v)" },
-
-    /* SCCS.  */
-        /* ain't no SCCS on vms */
-
-#else
-    /* RCS.  */
-    { "%", "%,v",
-        "$(CHECKOUT,v)" },
-    { "%", "RCS/%,v",
-        "$(CHECKOUT,v)" },
-    { "%", "RCS/%",
-        "$(CHECKOUT,v)" },
-
-    /* SCCS.  */
-    { "%", "s.%",
-        "$(GET) $(GFLAGS) $(SCCS_OUTPUT_OPTION) $<" },
-    { "%", "SCCS/s.%",
-        "$(GET) $(GFLAGS) $(SCCS_OUTPUT_OPTION) $<" },
-#endif /* !VMS */
-    { 0, 0, 0 }
-  };
-
-static const char *default_suffix_rules[] =
-  {
-#ifdef VMS
-    ".o",
-    "$(LINK.obj) $^ $(LOADLIBES) $(LDLIBS) -o $@",
-    ".obj",
-    "$(LINK.obj) $^ $(LOADLIBES) $(LDLIBS) -o $@",
-    ".s",
-    "$(LINK.s) $^ $(LOADLIBES) $(LDLIBS) -o $@",
-    ".S",
-    "$(LINK.S) $^ $(LOADLIBES) $(LDLIBS) -o $@",
-    ".c",
-    "$(LINK.c) $^ $(LOADLIBES) $(LDLIBS) -o $@",
-    ".cc",
-    "$(LINK.cc) $^ $(LOADLIBES) $(LDLIBS) -o $@",
-    ".C",
-    "$(LINK.C) $^ $(LOADLIBES) $(LDLIBS) -o $@",
-    ".cpp",
-    "$(LINK.cpp) $^ $(LOADLIBES) $(LDLIBS) -o $@",
-    ".f",
-    "$(LINK.f) $^ $(LOADLIBES) $(LDLIBS) -o $@",
-    ".m",
-    "$(LINK.m) $^ $(LOADLIBES) $(LDLIBS) -o $@",
-    ".p",
-    "$(LINK.p) $^ $(LOADLIBES) $(LDLIBS) -o $@",
-    ".F",
-    "$(LINK.F) $^ $(LOADLIBES) $(LDLIBS) -o $@",
-    ".r",
-    "$(LINK.r) $^ $(LOADLIBES) $(LDLIBS) -o $@",
-    ".mod",
-    "$(COMPILE.mod) -o $@ -e $@ $^",
-
-    ".def.sym",
-    "$(COMPILE.def) -o $@ $<",
-
-    ".sh",
-    "copy $< >$@",
-
-    ".obj.exe",
-    "$(LINK.obj) $^ $(LOADLIBES) $(LDLIBS) $(CRT0) /exe=$@",
-    ".mar.exe",
-    "$(COMPILE.mar) $^ \n $(LINK.obj) $(subst .mar,.obj,$^) $(LOADLIBES) $(LDLIBS) $(CRT0) /exe=$@",
-    ".s.o",
-    "$(COMPILE.s) -o $@ $<",
-    ".s.exe",
-    "$(COMPILE.s) $^ \n $(LINK.obj) $(subst .s,.obj,$^) $(LOADLIBES) $(LDLIBS) $(CRT0) /exe=$@",
-    ".c.exe",
-    "$(COMPILE.c) $^ \n $(LINK.obj) $(subst .c,.obj,$^) $(LOADLIBES) $(LDLIBS) $(CRT0) /exe=$@",
-    ".cc.exe",
-#ifdef GCC_IS_NATIVE
-    "$(COMPILE.cc) $^ \n $(LINK.obj) $(CXXSTARTUP),sys$$disk:[]$(subst .cc,.obj,$^) $(LOADLIBES) $(LXLIBS) $(LDLIBS) $(CXXRT0) /exe=$@",
-#else
-    "$(COMPILE.cc) $^ \n $(CXXLINK.obj) $(subst .cc,.obj,$^) $(LOADLIBES) $(LXLIBS) $(LDLIBS) $(CXXRT0) /exe=$@",
-    ".cxx.exe",
-    "$(COMPILE.cxx) $^ \n $(CXXLINK.obj) $(subst .cxx,.obj,$^) $(LOADLIBES) $(LXLIBS) $(LDLIBS) $(CXXRT0) /exe=$@",
-#endif
-    ".for.exe",
-    "$(COMPILE.for) $^ \n $(LINK.obj) $(subst .for,.obj,$^) $(LOADLIBES) $(LDLIBS) /exe=$@",
-    ".pas.exe",
-    "$(COMPILE.pas) $^ \n $(LINK.obj) $(subst .pas,.obj,$^) $(LOADLIBES) $(LDLIBS) /exe=$@",
-
-    ".com",
-    "copy $< >$@",
-
-    ".mar.obj",
-    "$(COMPILE.mar) /obj=$@ $<",
-    ".s.obj",
-    "$(COMPILE.s) /obj=$@ $<",
-    ".ss.obj",
-    "$(COMPILE.s) /obj=$@ $<",
-    ".c.i",
-    "$(COMPILE.c)/prep /list=$@ $<",
-    ".c.s",
-    "$(COMPILE.c)/noobj/machine /list=$@ $<",
-    ".i.s",
-    "$(COMPILE.c)/noprep/noobj/machine /list=$@ $<",
-    ".c.obj",
-    "$(COMPILE.c) /obj=$@ $<",
-    ".c.o",
-    "$(COMPILE.c) /obj=$@ $<",
-    ".cc.ii",
-    "$(COMPILE.cc)/prep /list=$@ $<",
-    ".cc.ss",
-    "$(COMPILE.cc)/noobj/machine /list=$@ $<",
-    ".ii.ss",
-    "$(COMPILE.cc)/noprep/noobj/machine /list=$@ $<",
-    ".cc.obj",
-    "$(COMPILE.cc) /obj=$@ $<",
-    ".cc.o",
-    "$(COMPILE.cc) /obj=$@ $<",
-    ".cxx.obj",
-    "$(COMPILE.cxx) /obj=$@ $<",
-    ".cxx.o",
-    "$(COMPILE.cxx) /obj=$@ $<",
-    ".for.obj",
-    "$(COMPILE.for) /obj=$@ $<",
-    ".for.o",
-    "$(COMPILE.for) /obj=$@ $<",
-    ".pas.obj",
-    "$(COMPILE.pas) /obj=$@ $<",
-    ".pas.o",
-    "$(COMPILE.pas) /obj=$@ $<",
-
-    ".y.c",
-    "$(YACC.y) $< \n rename y_tab.c $@",
-    ".l.c",
-    "$(LEX.l) $< \n rename lexyy.c $@",
-
-    ".texinfo.info",
-    "$(MAKEINFO) $<",
-
-    ".tex.dvi",
-    "$(TEX) $<",
-
-    ".cpp.o",
-    "$(COMPILE.cpp) $(OUTPUT_OPTION) $<",
-    ".f.o",
-    "$(COMPILE.f) $(OUTPUT_OPTION) $<",
-    ".m.o",
-    "$(COMPILE.m) $(OUTPUT_OPTION) $<",
-    ".p.o",
-    "$(COMPILE.p) $(OUTPUT_OPTION) $<",
-    ".r.o",
-    "$(COMPILE.r) $(OUTPUT_OPTION) $<",
-    ".mod.o",
-    "$(COMPILE.mod) -o $@ $<",
-
-    ".c.ln",
-    "$(LINT.c) -C$* $<",
-    ".y.ln",
-    "$(YACC.y) $< \n rename y_tab.c $@",
-
-    ".l.ln",
-    "@$(RM) $*.c\n $(LEX.l) $< > $*.c\n$(LINT.c) -i $*.c -o $@\n $(RM) $*.c",
-
-#else /* ! VMS */
-
-    ".o",
-    "$(LINK.o) $^ $(LOADLIBES) $(LDLIBS) -o $@",
-    ".s",
-    "$(LINK.s) $^ $(LOADLIBES) $(LDLIBS) -o $@",
-    ".S",
-    "$(LINK.S) $^ $(LOADLIBES) $(LDLIBS) -o $@",
-    ".c",
-    "$(LINK.c) $^ $(LOADLIBES) $(LDLIBS) -o $@",
-    ".cc",
-    "$(LINK.cc) $^ $(LOADLIBES) $(LDLIBS) -o $@",
-    ".C",
-    "$(LINK.C) $^ $(LOADLIBES) $(LDLIBS) -o $@",
-    ".cpp",
-    "$(LINK.cpp) $^ $(LOADLIBES) $(LDLIBS) -o $@",
-    ".f",
-    "$(LINK.f) $^ $(LOADLIBES) $(LDLIBS) -o $@",
-    ".m",
-    "$(LINK.m) $^ $(LOADLIBES) $(LDLIBS) -o $@",
-    ".p",
-    "$(LINK.p) $^ $(LOADLIBES) $(LDLIBS) -o $@",
-    ".F",
-    "$(LINK.F) $^ $(LOADLIBES) $(LDLIBS) -o $@",
-    ".r",
-    "$(LINK.r) $^ $(LOADLIBES) $(LDLIBS) -o $@",
-    ".mod",
-    "$(COMPILE.mod) -o $@ -e $@ $^",
-
-    ".def.sym",
-    "$(COMPILE.def) -o $@ $<",
-
-    ".sh",
-    "cat $< >$@ \n chmod a+x $@",
-
-    ".s.o",
-    "$(COMPILE.s) -o $@ $<",
-    ".S.o",
-    "$(COMPILE.S) -o $@ $<",
-    ".c.o",
-    "$(COMPILE.c) $(OUTPUT_OPTION) $<",
-    ".cc.o",
-    "$(COMPILE.cc) $(OUTPUT_OPTION) $<",
-    ".C.o",
-    "$(COMPILE.C) $(OUTPUT_OPTION) $<",
-    ".cpp.o",
-    "$(COMPILE.cpp) $(OUTPUT_OPTION) $<",
-    ".f.o",
-    "$(COMPILE.f) $(OUTPUT_OPTION) $<",
-    ".m.o",
-    "$(COMPILE.m) $(OUTPUT_OPTION) $<",
-    ".p.o",
-    "$(COMPILE.p) $(OUTPUT_OPTION) $<",
-    ".F.o",
-    "$(COMPILE.F) $(OUTPUT_OPTION) $<",
-    ".r.o",
-    "$(COMPILE.r) $(OUTPUT_OPTION) $<",
-    ".mod.o",
-    "$(COMPILE.mod) -o $@ $<",
-
-    ".c.ln",
-    "$(LINT.c) -C$* $<",
-    ".y.ln",
-#ifndef __MSDOS__
-    "$(YACC.y) $< \n $(LINT.c) -C$* y.tab.c \n $(RM) y.tab.c",
-#else
-    "$(YACC.y) $< \n $(LINT.c) -C$* y_tab.c \n $(RM) y_tab.c",
-#endif
-    ".l.ln",
-    "@$(RM) $*.c\n $(LEX.l) $< > $*.c\n$(LINT.c) -i $*.c -o $@\n $(RM) $*.c",
-
-    ".y.c",
-#ifndef __MSDOS__
-    "$(YACC.y) $< \n mv -f y.tab.c $@",
-#else
-    "$(YACC.y) $< \n mv -f y_tab.c $@",
-#endif
-    ".l.c",
-    "@$(RM) $@ \n $(LEX.l) $< > $@",
-    ".ym.m",
-    "$(YACC.m) $< \n mv -f y.tab.c $@",
-    ".lm.m",
-    "@$(RM) $@ \n $(LEX.m) $< > $@",
-
-    ".F.f",
-    "$(PREPROCESS.F) $(OUTPUT_OPTION) $<",
-    ".r.f",
-    "$(PREPROCESS.r) $(OUTPUT_OPTION) $<",
-
-    /* This might actually make lex.yy.c if there's no %R% directive in $*.l,
-       but in that case why were you trying to make $*.r anyway?  */
-    ".l.r",
-    "$(LEX.l) $< > $@ \n mv -f lex.yy.r $@",
-
-    ".S.s",
-    "$(PREPROCESS.S) $< > $@",
-
-    ".texinfo.info",
-    "$(MAKEINFO) $(MAKEINFO_FLAGS) $< -o $@",
-
-    ".texi.info",
-    "$(MAKEINFO) $(MAKEINFO_FLAGS) $< -o $@",
-
-    ".txinfo.info",
-    "$(MAKEINFO) $(MAKEINFO_FLAGS) $< -o $@",
-
-    ".tex.dvi",
-    "$(TEX) $<",
-
-    ".texinfo.dvi",
-    "$(TEXI2DVI) $(TEXI2DVI_FLAGS) $<",
-
-    ".texi.dvi",
-    "$(TEXI2DVI) $(TEXI2DVI_FLAGS) $<",
-
-    ".txinfo.dvi",
-    "$(TEXI2DVI) $(TEXI2DVI_FLAGS) $<",
-
-    ".w.c",
-    "$(CTANGLE) $< - $@",       /* The '-' says there is no '.ch' file.  */
-
-    ".web.p",
-    "$(TANGLE) $<",
-
-    ".w.tex",
-    "$(CWEAVE) $< - $@",        /* The '-' says there is no '.ch' file.  */
-
-    ".web.tex",
-    "$(WEAVE) $<",
-
-#endif /* !VMS */
-
-    0, 0,
-  };
-
-static const char *default_variables[] =
-  {
-#ifdef VMS
-#ifdef __ALPHA
-    "ARCH", "ALPHA",
-#endif
-#ifdef __ia64
-    "ARCH", "IA64",
-#endif
-#ifdef __VAX
-    "ARCH", "VAX",
-#endif
-    "AR", "library",
-    "LIBRARY", "library",
-    "ARFLAGS", "/replace",
-    "AS", "macro",
-    "MACRO", "macro",
-#ifdef GCC_IS_NATIVE
-    "CC", "gcc",
-#else
-    "CC", "cc",
-#endif
-    "CD", "builtin_cd",
-    "ECHO", "builtin_echo",
-#ifdef GCC_IS_NATIVE
-    "C++", "gcc/plus",
-    "CXX", "gcc/plus",
-#else
-    "C++", "cxx",
-    "CXX", "cxx",
-#ifndef __ia64
-    "CXXLD", "cxxlink",
-    "CXXLINK", "cxxlink",
-#else
-    /* CXXLINK is not used on VMS/IA64 */
-    "CXXLD", "link",
-    "CXXLINK", "link",
-#endif
-#endif
-    "CO", "co",
-    "CPP", "$(CC) /preprocess_only",
-    "FC", "fortran",
-    /* System V uses these, so explicit rules using them should work.
-       However, there is no way to make implicit rules use them and FC.  */
-    "F77", "$(FC)",
-    "F77FLAGS", "$(FFLAGS)",
-    "LD", "link",
-    "LEX", "lex",
-    "PC", "pascal",
-    "YACC", "bison/yacc",
-    "YFLAGS", "/Define/Verbose",
-    "BISON", "bison",
-    "MAKEINFO", "makeinfo",
-    "TEX", "tex",
-    "TEXINDEX", "texindex",
-
-    "RM", "delete/nolog",
-
-    "CSTARTUP", "",
-#ifdef GCC_IS_NATIVE
-    "CRT0", ",sys$$library:vaxcrtl.olb/lib,gnu_cc_library:crt0.obj",
-    "CXXSTARTUP", "gnu_cc_library:crtbegin.obj",
-    "CXXRT0", ",sys$$library:vaxcrtl.olb/lib,gnu_cc_library:crtend.obj,gnu_cc_library:gxx_main.obj",
-    "LXLIBS", ",gnu_cc_library:libstdcxx.olb/lib,gnu_cc_library:libgccplus.olb/lib",
-    "LDLIBS", ",gnu_cc_library:libgcc.olb/lib",
-#else
-    "CRT0", "",
-    "CXXSTARTUP", "",
-    "CXXRT0", "",
-    "LXLIBS", "",
-    "LDLIBS", "",
-#endif
-
-    "LINK.o", "$(LD) $(LDFLAGS)",
-    "LINK.obj", "$(LD) $(LDFLAGS)",
-#ifndef GCC_IS_NATIVE
-    "CXXLINK.obj", "$(CXXLD) $(LDFLAGS)",
-    "COMPILE.cxx", "$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
-#endif
-    "COMPILE.c", "$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
-    "LINK.c", "$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
-    "COMPILE.m", "$(OBJC) $(OBJCFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
-    "LINK.m", "$(OBJC) $(OBJCFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
-    "COMPILE.cc", "$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
-    "COMPILE.C", "$(COMPILE.cc)",
-    "COMPILE.cpp", "$(COMPILE.cc)",
-    "LINK.C", "$(LINK.cc)",
-    "LINK.cpp", "$(LINK.cc)",
-    "YACC.y", "$(YACC) $(YFLAGS)",
-    "LEX.l", "$(LEX) $(LFLAGS)",
-    "YACC.m", "$(YACC) $(YFLAGS)",
-    "LEX.m", "$(LEX) $(LFLAGS) -t",
-    "COMPILE.for", "$(FC) $(FFLAGS) $(TARGET_ARCH)",
-    "COMPILE.f", "$(FC) $(FFLAGS) $(TARGET_ARCH) -c",
-    "LINK.f", "$(FC) $(FFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
-    "COMPILE.F", "$(FC) $(FFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
-    "LINK.F", "$(FC) $(FFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
-    "COMPILE.r", "$(FC) $(FFLAGS) $(RFLAGS) $(TARGET_ARCH) -c",
-    "LINK.r", "$(FC) $(FFLAGS) $(RFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
-    "COMPILE.pas", "$(PC) $(PFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
-    "COMPILE.def", "$(M2C) $(M2FLAGS) $(DEFFLAGS) $(TARGET_ARCH)",
-    "COMPILE.mod", "$(M2C) $(M2FLAGS) $(MODFLAGS) $(TARGET_ARCH)",
-    "COMPILE.p", "$(PC) $(PFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
-    "LINK.p", "$(PC) $(PFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
-    "COMPILE.mar", "$(MACRO) $(MACROFLAGS)",
-    "COMPILE.s", "$(AS) $(ASFLAGS) $(TARGET_MACH)",
-    "LINK.S", "$(CC) $(ASFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_MACH)",
-    "COMPILE.S", "$(CC) $(ASFLAGS) $(CPPFLAGS) $(TARGET_MACH) -c",
-    "PREPROCESS.S", "$(CC) -E $(CPPFLAGS)",
-    "PREPROCESS.F", "$(FC) $(FFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -F",
-    "PREPROCESS.r", "$(FC) $(FFLAGS) $(RFLAGS) $(TARGET_ARCH) -F",
-    "LINT.c", "$(LINT) $(LINTFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
-
-    "MV", "rename/new_version",
-    "CP", "copy",
-    ".LIBPATTERNS", "%.olb lib%.a",
-
-#else /* !VMS */
-
-    "AR", "ar",
-    "ARFLAGS", "rv",
-    "AS", "as",
-#ifdef GCC_IS_NATIVE
-    "CC", "gcc",
-# ifdef __MSDOS__
-    "CXX", "gpp",       /* g++ is an invalid name on MSDOS */
-# else
-    "CXX", "gcc",
-# endif /* __MSDOS__ */
-    "OBJC", "gcc",
-#else
-    "CC", "cc",
-    "CXX", "g++",
-    "OBJC", "cc",
-#endif
-
-    /* This expands to $(CO) $(COFLAGS) $< $@ if $@ does not exist,
-       and to the empty string if $@ does exist.  */
-    "CHECKOUT,v", "+$(if $(wildcard $@),,$(CO) $(COFLAGS) $< $@)",
-    "CO", "co",
-    "COFLAGS", "",
-
-    "CPP", "$(CC) -E",
-#ifdef  CRAY
-    "CF77PPFLAGS", "-P",
-    "CF77PP", "/lib/cpp",
-    "CFT", "cft77",
-    "CF", "cf77",
-    "FC", "$(CF)",
-#else   /* Not CRAY.  */
-#ifdef  _IBMR2
-    "FC", "xlf",
-#else
-#ifdef  __convex__
-    "FC", "fc",
-#else
-    "FC", "f77",
-#endif /* __convex__ */
-#endif /* _IBMR2 */
-    /* System V uses these, so explicit rules using them should work.
-       However, there is no way to make implicit rules use them and FC.  */
-    "F77", "$(FC)",
-    "F77FLAGS", "$(FFLAGS)",
-#endif  /* Cray.  */
-    "GET", SCCS_GET,
-    "LD", "ld",
-#ifdef GCC_IS_NATIVE
-    "LEX", "flex",
-#else
-    "LEX", "lex",
-#endif
-    "LINT", "lint",
-    "M2C", "m2c",
-#ifdef  pyr
-    "PC", "pascal",
-#else
-#ifdef  CRAY
-    "PC", "PASCAL",
-    "SEGLDR", "segldr",
-#else
-    "PC", "pc",
-#endif  /* CRAY.  */
-#endif  /* pyr.  */
-#ifdef GCC_IS_NATIVE
-    "YACC", "bison -y",
-#else
-    "YACC", "yacc",     /* Or "bison -y"  */
-#endif
-    "MAKEINFO", "makeinfo",
-    "TEX", "tex",
-    "TEXI2DVI", "texi2dvi",
-    "WEAVE", "weave",
-    "CWEAVE", "cweave",
-    "TANGLE", "tangle",
-    "CTANGLE", "ctangle",
-
-    "RM", "rm -f",
-
-    "LINK.o", "$(CC) $(LDFLAGS) $(TARGET_ARCH)",
-    "COMPILE.c", "$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
-    "LINK.c", "$(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
-    "COMPILE.m", "$(OBJC) $(OBJCFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
-    "LINK.m", "$(OBJC) $(OBJCFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
-    "COMPILE.cc", "$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
-#ifndef HAVE_CASE_INSENSITIVE_FS
-    /* On case-insensitive filesystems, treat *.C files as *.c files,
-       to avoid erroneously compiling C sources as C++, which will
-       probably fail.  */
-    "COMPILE.C", "$(COMPILE.cc)",
-#else
-    "COMPILE.C", "$(COMPILE.c)",
-#endif
-    "COMPILE.cpp", "$(COMPILE.cc)",
-    "LINK.cc", "$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
-#ifndef HAVE_CASE_INSENSITIVE_FS
-    "LINK.C", "$(LINK.cc)",
-#else
-    "LINK.C", "$(LINK.c)",
-#endif
-    "LINK.cpp", "$(LINK.cc)",
-    "YACC.y", "$(YACC) $(YFLAGS)",
-    "LEX.l", "$(LEX) $(LFLAGS) -t",
-    "YACC.m", "$(YACC) $(YFLAGS)",
-    "LEX.m", "$(LEX) $(LFLAGS) -t",
-    "COMPILE.f", "$(FC) $(FFLAGS) $(TARGET_ARCH) -c",
-    "LINK.f", "$(FC) $(FFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
-    "COMPILE.F", "$(FC) $(FFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
-    "LINK.F", "$(FC) $(FFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
-    "COMPILE.r", "$(FC) $(FFLAGS) $(RFLAGS) $(TARGET_ARCH) -c",
-    "LINK.r", "$(FC) $(FFLAGS) $(RFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
-    "COMPILE.def", "$(M2C) $(M2FLAGS) $(DEFFLAGS) $(TARGET_ARCH)",
-    "COMPILE.mod", "$(M2C) $(M2FLAGS) $(MODFLAGS) $(TARGET_ARCH)",
-    "COMPILE.p", "$(PC) $(PFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
-    "LINK.p", "$(PC) $(PFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
-    "LINK.s", "$(CC) $(ASFLAGS) $(LDFLAGS) $(TARGET_MACH)",
-    "COMPILE.s", "$(AS) $(ASFLAGS) $(TARGET_MACH)",
-    "LINK.S", "$(CC) $(ASFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_MACH)",
-    "COMPILE.S", "$(CC) $(ASFLAGS) $(CPPFLAGS) $(TARGET_MACH) -c",
-    "PREPROCESS.S", "$(CC) -E $(CPPFLAGS)",
-    "PREPROCESS.F", "$(FC) $(FFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -F",
-    "PREPROCESS.r", "$(FC) $(FFLAGS) $(RFLAGS) $(TARGET_ARCH) -F",
-    "LINT.c", "$(LINT) $(LINTFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
-
-#ifndef NO_MINUS_C_MINUS_O
-    "OUTPUT_OPTION", "-o $@",
-#endif
-
-#ifdef  SCCS_GET_MINUS_G
-    "SCCS_OUTPUT_OPTION", "-G$@",
-#endif
-
-#if defined(_AMIGA)
-    ".LIBPATTERNS", "%.lib",
-#elif defined(__MSDOS__)
-    ".LIBPATTERNS", "lib%.a $(DJDIR)/lib/lib%.a",
-#elif defined(__APPLE__)
-    ".LIBPATTERNS", "lib%.dylib lib%.a",
-#elif defined(__CYGWIN__) || defined(WINDOWS32)
-    ".LIBPATTERNS", "lib%.dll.a %.dll.a lib%.a %.lib lib%.dll %.dll",
-#else
-    ".LIBPATTERNS", "lib%.so lib%.a",
-#endif
-
-#endif /* !VMS */
-    /* Make this assignment to avoid undefined variable warnings.  */
-    "GNUMAKEFLAGS", "",
-    0, 0
-  };
-
-/* Set up the default .SUFFIXES list.  */
-
-void
-set_default_suffixes (void)
-{
-  suffix_file = enter_file (strcache_add (".SUFFIXES"));
-  suffix_file->builtin = 1;
-
-  if (no_builtin_rules_flag)
-    define_variable_cname ("SUFFIXES", "", o_default, 0);
-  else
-    {
-      struct dep *d;
-      const char *p = default_suffixes;
-      suffix_file->deps = enter_prereqs (PARSE_SIMPLE_SEQ ((char **)&p, struct dep),
-                                         NULL);
-      for (d = suffix_file->deps; d; d = d->next)
-        d->file->builtin = 1;
-
-      define_variable_cname ("SUFFIXES", default_suffixes, o_default, 0);
-    }
-}
-
-/* Enter the default suffix rules as file rules.  This used to be done in
-   install_default_implicit_rules, but that loses because we want the
-   suffix rules installed before reading makefiles, and the pattern rules
-   installed after.  */
-
-void
-install_default_suffix_rules (void)
-{
-  const char **s;
-
-  if (no_builtin_rules_flag)
-    return;
-
-  for (s = default_suffix_rules; *s != 0; s += 2)
-    {
-      struct file *f = enter_file (strcache_add (s[0]));
-      /* This function should run before any makefile is parsed.  */
-      assert (f->cmds == 0);
-      f->cmds = xmalloc (sizeof (struct commands));
-      f->cmds->fileinfo.filenm = 0;
-      f->cmds->commands = xstrdup (s[1]);
-      f->cmds->command_lines = 0;
-      f->cmds->recipe_prefix = RECIPEPREFIX_DEFAULT;
-      f->builtin = 1;
-    }
-}
-
-
-/* Install the default pattern rules.  */
-
-void
-install_default_implicit_rules (void)
-{
-  struct pspec *p;
-
-  if (no_builtin_rules_flag)
-    return;
-
-  for (p = default_pattern_rules; p->target != 0; ++p)
-    install_pattern_rule (p, 0);
-
-  for (p = default_terminal_rules; p->target != 0; ++p)
-    install_pattern_rule (p, 1);
-}
-
-void
-define_default_variables (void)
-{
-  const char **s;
-
-  if (no_builtin_variables_flag)
-    return;
-
-  for (s = default_variables; *s != 0; s += 2)
-    define_variable (s[0], strlen (s[0]), s[1], o_default, 1);
-}
-
-void
-undefine_default_variables (void)
-{
-  const char **s;
-
-  for (s = default_variables; *s != 0; s += 2)
-    undefine_variable_global (s[0], strlen (s[0]), o_default);
-}
diff --git a/dep.h b/dep.h
deleted file mode 100644
index 99d3f88..0000000
--- a/dep.h
+++ /dev/null
@@ -1,131 +0,0 @@
-/* Definitions of dependency data structures for GNU Make.
-Copyright (C) 1988-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-
-/* Structure used in chains of names, for parsing and globbing.  */
-
-#define NAMESEQ(_t)     \
-    _t *next;           \
-    const char *name
-
-struct nameseq
-  {
-    NAMESEQ (struct nameseq);
-  };
-
-/* Flag bits for the second argument to 'read_makefile'.
-   These flags are saved in the 'flags' field of each
-   'struct goaldep' in the chain returned by 'read_all_makefiles'.  */
-
-#define RM_NO_DEFAULT_GOAL      (1 << 0) /* Do not set default goal.  */
-#define RM_INCLUDED             (1 << 1) /* Search makefile search path.  */
-#define RM_DONTCARE             (1 << 2) /* No error if it doesn't exist.  */
-#define RM_NO_TILDE             (1 << 3) /* Don't expand ~ in file name.  */
-#define RM_NOFLAG               0
-
-/* Structure representing one dependency of a file.
-   Each struct file's 'deps' points to a chain of these, through 'next'.
-   'stem' is the stem for this dep line of static pattern rule or NULL.  */
-
-#define DEP(_t)                                 \
-    NAMESEQ (_t);                               \
-    struct file *file;                          \
-    const char *stem;                           \
-    unsigned short flags : 8;                   \
-    unsigned short changed : 1;                 \
-    unsigned short ignore_mtime : 1;            \
-    unsigned short staticpattern : 1;           \
-    unsigned short need_2nd_expansion : 1
-
-struct dep
-  {
-    DEP (struct dep);
-  };
-
-/* Structure representing one goal.
-   The goals to be built constitute a chain of these, chained through 'next'.
-   'stem' is not used, but it's simpler to include and ignore it.  */
-
-struct goaldep
-  {
-    DEP (struct goaldep);
-    unsigned short error;
-    floc floc;
-  };
-
-/* Options for parsing lists of filenames.  */
-
-#define PARSEFS_NONE    0x0000
-#define PARSEFS_NOSTRIP 0x0001
-#define PARSEFS_NOAR    0x0002
-#define PARSEFS_NOGLOB  0x0004
-#define PARSEFS_EXISTS  0x0008
-#define PARSEFS_NOCACHE 0x0010
-
-#define PARSE_FILE_SEQ(_s,_t,_c,_p,_f) \
-            (_t *)parse_file_seq ((_s),sizeof (_t),(_c),(_p),(_f))
-#define PARSE_SIMPLE_SEQ(_s,_t) \
-            (_t *)parse_file_seq ((_s),sizeof (_t),MAP_NUL,NULL,PARSEFS_NONE)
-
-#ifdef VMS
-void *parse_file_seq ();
-#else
-void *parse_file_seq (char **stringp, unsigned int size,
-                      int stopmap, const char *prefix, int flags);
-#endif
-
-char *tilde_expand (const char *name);
-
-#ifndef NO_ARCHIVES
-struct nameseq *ar_glob (const char *arname, const char *member_pattern, unsigned int size);
-#endif
-
-#define dep_name(d)        ((d)->name ? (d)->name : (d)->file->name)
-
-#define alloc_seq_elt(_t)   xcalloc (sizeof (_t))
-void free_ns_chain (struct nameseq *n);
-
-#if defined(MAKE_MAINTAINER_MODE) && defined(__GNUC__)
-/* Use inline to get real type-checking.  */
-#define SI static inline
-SI struct nameseq *alloc_ns()      { return alloc_seq_elt (struct nameseq); }
-SI struct dep *alloc_dep()         { return alloc_seq_elt (struct dep); }
-SI struct goaldep *alloc_goaldep() { return alloc_seq_elt (struct goaldep); }
-
-SI void free_ns(struct nameseq *n)      { free (n); }
-SI void free_dep(struct dep *d)         { free_ns ((struct nameseq *)d); }
-SI void free_goaldep(struct goaldep *g) { free_dep ((struct dep *)g); }
-
-SI void free_dep_chain(struct dep *d)      { free_ns_chain((struct nameseq *)d); }
-SI void free_goal_chain(struct goaldep *g) { free_dep_chain((struct dep *)g); }
-#else
-# define alloc_ns()          alloc_seq_elt (struct nameseq)
-# define alloc_dep()         alloc_seq_elt (struct dep)
-# define alloc_goaldep()     alloc_seq_elt (struct goaldep)
-
-# define free_ns(_n)         free (_n)
-# define free_dep(_d)        free_ns (_d)
-# define free_goaldep(_g)    free_dep (_g)
-
-# define free_dep_chain(_d)  free_ns_chain ((struct nameseq *)(_d))
-# define free_goal_chain(_g) free_ns_chain ((struct nameseq *)(_g))
-#endif
-
-struct dep *copy_dep_chain (const struct dep *d);
-
-struct goaldep *read_all_makefiles (const char **makefiles);
-void eval_buffer (char *buffer, const floc *floc);
-enum update_status update_goal_chain (struct goaldep *goals);
diff --git a/dir.c b/dir.c
deleted file mode 100644
index c343e4c..0000000
--- a/dir.c
+++ /dev/null
@@ -1,1346 +0,0 @@
-/* Directory hashing for GNU Make.
-Copyright (C) 1988-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-#include "hash.h"
-#include "filedef.h"
-#include "dep.h"
-
-#ifdef  HAVE_DIRENT_H
-# include <dirent.h>
-# define NAMLEN(dirent) strlen((dirent)->d_name)
-# ifdef VMS
-/* its prototype is in vmsdir.h, which is not needed for HAVE_DIRENT_H */
-const char *vmsify (const char *name, int type);
-# endif
-#else
-# define dirent direct
-# define NAMLEN(dirent) (dirent)->d_namlen
-# ifdef HAVE_SYS_NDIR_H
-#  include <sys/ndir.h>
-# endif
-# ifdef HAVE_SYS_DIR_H
-#  include <sys/dir.h>
-# endif
-# ifdef HAVE_NDIR_H
-#  include <ndir.h>
-# endif
-# ifdef HAVE_VMSDIR_H
-#  include "vmsdir.h"
-# endif /* HAVE_VMSDIR_H */
-#endif
-
-/* In GNU systems, <dirent.h> defines this macro for us.  */
-#ifdef _D_NAMLEN
-# undef NAMLEN
-# define NAMLEN(d) _D_NAMLEN(d)
-#endif
-
-#if (defined (POSIX) || defined (VMS) || defined (WINDOWS32)) && !defined (__GNU_LIBRARY__)
-/* Posix does not require that the d_ino field be present, and some
-   systems do not provide it. */
-# define REAL_DIR_ENTRY(dp) 1
-# define FAKE_DIR_ENTRY(dp)
-#else
-# define REAL_DIR_ENTRY(dp) (dp->d_ino != 0)
-# define FAKE_DIR_ENTRY(dp) (dp->d_ino = 1)
-#endif /* POSIX */
-
-#ifdef __MSDOS__
-#include <ctype.h>
-#include <fcntl.h>
-
-/* If it's MSDOS that doesn't have _USE_LFN, disable LFN support.  */
-#ifndef _USE_LFN
-#define _USE_LFN 0
-#endif
-
-static const char *
-dosify (const char *filename)
-{
-  static char dos_filename[14];
-  char *df;
-  int i;
-
-  if (filename == 0 || _USE_LFN)
-    return filename;
-
-  /* FIXME: what about filenames which violate
-     8+3 constraints, like "config.h.in", or ".emacs"?  */
-  if (strpbrk (filename, "\"*+,;<=>?[\\]|") != 0)
-    return filename;
-
-  df = dos_filename;
-
-  /* First, transform the name part.  */
-  for (i = 0; i < 8 && ! STOP_SET (*filename, MAP_DOT|MAP_NUL); ++i)
-    *df++ = tolower ((unsigned char)*filename++);
-
-  /* Now skip to the next dot.  */
-  while (! STOP_SET (*filename, MAP_DOT|MAP_NUL))
-    ++filename;
-  if (*filename != '\0')
-    {
-      *df++ = *filename++;
-      for (i = 0; i < 3 && ! STOP_SET (*filename, MAP_DOT|MAP_NUL); ++i)
-        *df++ = tolower ((unsigned char)*filename++);
-    }
-
-  /* Look for more dots.  */
-  while (! STOP_SET (*filename, MAP_DOT|MAP_NUL))
-    ++filename;
-  if (*filename == '.')
-    return filename;
-  *df = 0;
-  return dos_filename;
-}
-#endif /* __MSDOS__ */
-
-#ifdef WINDOWS32
-#include "pathstuff.h"
-#endif
-
-#ifdef _AMIGA
-#include <ctype.h>
-#endif
-
-#ifdef HAVE_CASE_INSENSITIVE_FS
-static const char *
-downcase (const char *filename)
-{
-  static PATH_VAR (new_filename);
-  char *df;
-
-  if (filename == 0)
-    return 0;
-
-  df = new_filename;
-  while (*filename != '\0')
-    {
-      *df++ = tolower ((unsigned char)*filename);
-      ++filename;
-    }
-
-  *df = 0;
-
-  return new_filename;
-}
-#endif /* HAVE_CASE_INSENSITIVE_FS */
-
-#ifdef VMS
-
-static char *
-downcase_inplace(char *filename)
-{
-  char *name;
-  name = filename;
-  while (*name != '\0')
-    {
-      *name = tolower ((unsigned char)*name);
-      ++name;
-    }
-  return filename;
-}
-
-#ifndef _USE_STD_STAT
-/* VMS 8.2 fixed the VMS stat output to have unique st_dev and st_ino
-   when _USE_STD_STAT is used on the compile line.
-
-   Prior to _USE_STD_STAT support, the st_dev is a pointer to thread
-   static memory containing the device of the last filename looked up.
-
-   Todo: find out if the ino_t still needs to be faked on a directory.
- */
-
-/* Define this if the older VMS_INO_T is needed */
-#define VMS_INO_T 1
-
-static int
-vms_hash (const char *name)
-{
-  int h = 0;
-
-  while (*name)
-    {
-      unsigned char uc = *name;
-      int g;
-#ifdef HAVE_CASE_INSENSITIVE_FS
-      h = (h << 4) + (isupper (uc) ? tolower (uc) : uc);
-#else
-      h = (h << 4) + uc;
-#endif
-      name++;
-      g = h & 0xf0000000;
-      if (g)
-        {
-          h = h ^ (g >> 24);
-          h = h ^ g;
-        }
-    }
-  return h;
-}
-
-/* fake stat entry for a directory */
-static int
-vmsstat_dir (const char *name, struct stat *st)
-{
-  char *s;
-  int h;
-  DIR *dir;
-
-  dir = opendir (name);
-  if (dir == 0)
-    return -1;
-  closedir (dir);
-  s = strchr (name, ':');       /* find device */
-  if (s)
-    {
-      /* to keep the compiler happy we said "const char *name", now we cheat */
-      *s++ = 0;
-      st->st_dev = (char *)vms_hash (name);
-      h = vms_hash (s);
-      *(s-1) = ':';
-    }
-  else
-    {
-      st->st_dev = 0;
-      h = vms_hash (name);
-    }
-
-  st->st_ino[0] = h & 0xff;
-  st->st_ino[1] = h & 0xff00;
-  st->st_ino[2] = h >> 16;
-
-  return 0;
-}
-
-# define stat(__path, __sbuf) vmsstat_dir (__path, __sbuf)
-
-#endif /* _USE_STD_STAT */
-#endif /* VMS */
-
-/* Hash table of directories.  */
-
-#ifndef DIRECTORY_BUCKETS
-#define DIRECTORY_BUCKETS 199
-#endif
-
-struct directory_contents
-  {
-    dev_t dev;                  /* Device and inode numbers of this dir.  */
-#ifdef WINDOWS32
-    /* Inode means nothing on WINDOWS32. Even file key information is
-     * unreliable because it is random per file open and undefined for remote
-     * filesystems. The most unique attribute I can come up with is the fully
-     * qualified name of the directory. Beware though, this is also
-     * unreliable. I'm open to suggestion on a better way to emulate inode.  */
-    char *path_key;
-    time_t ctime;
-    time_t mtime;        /* controls check for stale directory cache */
-    int fs_flags;     /* FS_FAT, FS_NTFS, ... */
-# define FS_FAT      0x1
-# define FS_NTFS     0x2
-# define FS_UNKNOWN  0x4
-#else
-# ifdef VMS_INO_T
-    ino_t ino[3];
-# else
-    ino_t ino;
-# endif
-#endif /* WINDOWS32 */
-    struct hash_table dirfiles; /* Files in this directory.  */
-    DIR *dirstream;             /* Stream reading this directory.  */
-  };
-
-static unsigned long
-directory_contents_hash_1 (const void *key_0)
-{
-  const struct directory_contents *key = key_0;
-  unsigned long hash;
-
-#ifdef WINDOWS32
-  hash = 0;
-  ISTRING_HASH_1 (key->path_key, hash);
-  hash ^= ((unsigned int) key->dev << 4) ^ (unsigned int) key->ctime;
-#else
-# ifdef VMS_INO_T
-  hash = (((unsigned int) key->dev << 4)
-          ^ ((unsigned int) key->ino[0]
-             + (unsigned int) key->ino[1]
-             + (unsigned int) key->ino[2]));
-# else
-  hash = ((unsigned int) key->dev << 4) ^ (unsigned int) key->ino;
-# endif
-#endif /* WINDOWS32 */
-  return hash;
-}
-
-static unsigned long
-directory_contents_hash_2 (const void *key_0)
-{
-  const struct directory_contents *key = key_0;
-  unsigned long hash;
-
-#ifdef WINDOWS32
-  hash = 0;
-  ISTRING_HASH_2 (key->path_key, hash);
-  hash ^= ((unsigned int) key->dev << 4) ^ (unsigned int) ~key->ctime;
-#else
-# ifdef VMS_INO_T
-  hash = (((unsigned int) key->dev << 4)
-          ^ ~((unsigned int) key->ino[0]
-              + (unsigned int) key->ino[1]
-              + (unsigned int) key->ino[2]));
-# else
-  hash = ((unsigned int) key->dev << 4) ^ (unsigned int) ~key->ino;
-# endif
-#endif /* WINDOWS32 */
-
-  return hash;
-}
-
-/* Sometimes it's OK to use subtraction to get this value:
-     result = X - Y;
-   But, if we're not sure of the type of X and Y they may be too large for an
-   int (on a 64-bit system for example).  So, use ?: instead.
-   See Savannah bug #15534.
-
-   NOTE!  This macro has side-effects!
-*/
-
-#define MAKECMP(_x,_y)  ((_x)<(_y)?-1:((_x)==(_y)?0:1))
-
-static int
-directory_contents_hash_cmp (const void *xv, const void *yv)
-{
-  const struct directory_contents *x = xv;
-  const struct directory_contents *y = yv;
-  int result;
-
-#ifdef WINDOWS32
-  ISTRING_COMPARE (x->path_key, y->path_key, result);
-  if (result)
-    return result;
-  result = MAKECMP(x->ctime, y->ctime);
-  if (result)
-    return result;
-#else
-# ifdef VMS_INO_T
-  result = MAKECMP(x->ino[0], y->ino[0]);
-  if (result)
-    return result;
-  result = MAKECMP(x->ino[1], y->ino[1]);
-  if (result)
-    return result;
-  result = MAKECMP(x->ino[2], y->ino[2]);
-  if (result)
-    return result;
-# else
-  result = MAKECMP(x->ino, y->ino);
-  if (result)
-    return result;
-# endif
-#endif /* WINDOWS32 */
-
-  return MAKECMP(x->dev, y->dev);
-}
-
-/* Table of directory contents hashed by device and inode number.  */
-static struct hash_table directory_contents;
-
-struct directory
-  {
-    const char *name;                   /* Name of the directory.  */
-
-    /* The directory's contents.  This data may be shared by several
-       entries in the hash table, which refer to the same directory
-       (identified uniquely by 'dev' and 'ino') under different names.  */
-    struct directory_contents *contents;
-  };
-
-static unsigned long
-directory_hash_1 (const void *key)
-{
-  return_ISTRING_HASH_1 (((const struct directory *) key)->name);
-}
-
-static unsigned long
-directory_hash_2 (const void *key)
-{
-  return_ISTRING_HASH_2 (((const struct directory *) key)->name);
-}
-
-static int
-directory_hash_cmp (const void *x, const void *y)
-{
-  return_ISTRING_COMPARE (((const struct directory *) x)->name,
-                          ((const struct directory *) y)->name);
-}
-
-/* Table of directories hashed by name.  */
-static struct hash_table directories;
-
-/* Never have more than this many directories open at once.  */
-
-#define MAX_OPEN_DIRECTORIES 10
-
-static unsigned int open_directories = 0;
-
-
-/* Hash table of files in each directory.  */
-
-struct dirfile
-  {
-    const char *name;           /* Name of the file.  */
-    size_t length;
-    short impossible;           /* This file is impossible.  */
-  };
-
-static unsigned long
-dirfile_hash_1 (const void *key)
-{
-  return_ISTRING_HASH_1 (((struct dirfile const *) key)->name);
-}
-
-static unsigned long
-dirfile_hash_2 (const void *key)
-{
-  return_ISTRING_HASH_2 (((struct dirfile const *) key)->name);
-}
-
-static int
-dirfile_hash_cmp (const void *xv, const void *yv)
-{
-  const struct dirfile *x = xv;
-  const struct dirfile *y = yv;
-  int result = x->length - y->length;
-  if (result)
-    return result;
-  return_ISTRING_COMPARE (x->name, y->name);
-}
-
-#ifndef DIRFILE_BUCKETS
-#define DIRFILE_BUCKETS 107
-#endif
-
-static int dir_contents_file_exists_p (struct directory_contents *dir,
-                                       const char *filename);
-static struct directory *find_directory (const char *name);
-
-/* Find the directory named NAME and return its 'struct directory'.  */
-
-static struct directory *
-find_directory (const char *name)
-{
-  struct directory *dir;
-  struct directory **dir_slot;
-  struct directory dir_key;
-
-  dir_key.name = name;
-  dir_slot = (struct directory **) hash_find_slot (&directories, &dir_key);
-  dir = *dir_slot;
-
-  if (HASH_VACANT (dir))
-    {
-      /* The directory was not found.  Create a new entry for it.  */
-      const char *p = name + strlen (name);
-      struct stat st;
-      int r;
-
-      dir = xmalloc (sizeof (struct directory));
-#if defined(HAVE_CASE_INSENSITIVE_FS) && defined(VMS)
-      /* Todo: Why is this only needed on VMS? */
-      {
-        char *lname = downcase_inplace (xstrdup (name));
-        dir->name = strcache_add_len (lname, p - name);
-        free (lname);
-      }
-#else
-      dir->name = strcache_add_len (name, p - name);
-#endif
-      hash_insert_at (&directories, dir, dir_slot);
-      /* The directory is not in the name hash table.
-         Find its device and inode numbers, and look it up by them.  */
-
-#if defined(WINDOWS32)
-      {
-        char tem[MAXPATHLEN], *tstart, *tend;
-
-        /* Remove any trailing slashes.  Windows32 stat fails even on
-           valid directories if they end in a slash. */
-        memcpy (tem, name, p - name + 1);
-        tstart = tem;
-        if (tstart[1] == ':')
-          tstart += 2;
-        for (tend = tem + (p - name - 1);
-             tend > tstart && (*tend == '/' || *tend == '\\');
-             tend--)
-          *tend = '\0';
-
-        r = stat (tem, &st);
-      }
-#else
-      EINTRLOOP (r, stat (name, &st));
-#endif
-
-      if (r < 0)
-        {
-        /* Couldn't stat the directory.  Mark this by
-           setting the 'contents' member to a nil pointer.  */
-          dir->contents = 0;
-        }
-      else
-        {
-          /* Search the contents hash table; device and inode are the key.  */
-
-#ifdef WINDOWS32
-          char *w32_path;
-#endif
-          struct directory_contents *dc;
-          struct directory_contents **dc_slot;
-          struct directory_contents dc_key;
-
-          dc_key.dev = st.st_dev;
-#ifdef WINDOWS32
-          dc_key.path_key = w32_path = w32ify (name, 1);
-          dc_key.ctime = st.st_ctime;
-#else
-# ifdef VMS_INO_T
-          dc_key.ino[0] = st.st_ino[0];
-          dc_key.ino[1] = st.st_ino[1];
-          dc_key.ino[2] = st.st_ino[2];
-# else
-          dc_key.ino = st.st_ino;
-# endif
-#endif
-          dc_slot = (struct directory_contents **) hash_find_slot (&directory_contents, &dc_key);
-          dc = *dc_slot;
-
-          if (HASH_VACANT (dc))
-            {
-              /* Nope; this really is a directory we haven't seen before.  */
-#ifdef WINDOWS32
-              char  fs_label[BUFSIZ];
-              char  fs_type[BUFSIZ];
-              unsigned long  fs_serno;
-              unsigned long  fs_flags;
-              unsigned long  fs_len;
-#endif
-              dc = (struct directory_contents *)
-                xmalloc (sizeof (struct directory_contents));
-
-              /* Enter it in the contents hash table.  */
-              dc->dev = st.st_dev;
-#ifdef WINDOWS32
-              dc->path_key = xstrdup (w32_path);
-              dc->ctime = st.st_ctime;
-              dc->mtime = st.st_mtime;
-
-              /* NTFS is the only WINDOWS32 filesystem that bumps mtime on a
-                 directory when files are added/deleted from a directory.  */
-              w32_path[3] = '\0';
-              if (GetVolumeInformation (w32_path, fs_label, sizeof (fs_label),
-                                        &fs_serno, &fs_len, &fs_flags, fs_type,
-                                        sizeof (fs_type)) == FALSE)
-                dc->fs_flags = FS_UNKNOWN;
-              else if (!strcmp (fs_type, "FAT"))
-                dc->fs_flags = FS_FAT;
-              else if (!strcmp (fs_type, "NTFS"))
-                dc->fs_flags = FS_NTFS;
-              else
-                dc->fs_flags = FS_UNKNOWN;
-#else
-# ifdef VMS_INO_T
-              dc->ino[0] = st.st_ino[0];
-              dc->ino[1] = st.st_ino[1];
-              dc->ino[2] = st.st_ino[2];
-# else
-              dc->ino = st.st_ino;
-# endif
-#endif /* WINDOWS32 */
-              hash_insert_at (&directory_contents, dc, dc_slot);
-              ENULLLOOP (dc->dirstream, opendir (name));
-              if (dc->dirstream == 0)
-                /* Couldn't open the directory.  Mark this by setting the
-                   'files' member to a nil pointer.  */
-                dc->dirfiles.ht_vec = 0;
-              else
-                {
-                  hash_init (&dc->dirfiles, DIRFILE_BUCKETS,
-                             dirfile_hash_1, dirfile_hash_2, dirfile_hash_cmp);
-                  /* Keep track of how many directories are open.  */
-                  ++open_directories;
-                  if (open_directories == MAX_OPEN_DIRECTORIES)
-                    /* We have too many directories open already.
-                       Read the entire directory and then close it.  */
-                    dir_contents_file_exists_p (dc, 0);
-                }
-            }
-
-          /* Point the name-hashed entry for DIR at its contents data.  */
-          dir->contents = dc;
-        }
-    }
-
-  return dir;
-}
-
-/* Return 1 if the name FILENAME is entered in DIR's hash table.
-   FILENAME must contain no slashes.  */
-
-static int
-dir_contents_file_exists_p (struct directory_contents *dir,
-                            const char *filename)
-{
-  struct dirfile *df;
-  struct dirent *d;
-#ifdef WINDOWS32
-  struct stat st;
-  int rehash = 0;
-#endif
-
-  if (dir == 0 || dir->dirfiles.ht_vec == 0)
-    /* The directory could not be stat'd or opened.  */
-    return 0;
-
-#ifdef __MSDOS__
-  filename = dosify (filename);
-#endif
-
-#ifdef HAVE_CASE_INSENSITIVE_FS
-  filename = downcase (filename);
-#endif
-
-#ifdef __EMX__
-  if (filename != 0)
-    _fnlwr (filename); /* lower case for FAT drives */
-#endif
-  if (filename != 0)
-    {
-      struct dirfile dirfile_key;
-
-      if (*filename == '\0')
-        {
-          /* Checking if the directory exists.  */
-          return 1;
-        }
-      dirfile_key.name = filename;
-      dirfile_key.length = strlen (filename);
-      df = hash_find_item (&dir->dirfiles, &dirfile_key);
-      if (df)
-        return !df->impossible;
-    }
-
-  /* The file was not found in the hashed list.
-     Try to read the directory further.  */
-
-  if (dir->dirstream == 0)
-    {
-#ifdef WINDOWS32
-      /*
-       * Check to see if directory has changed since last read. FAT
-       * filesystems force a rehash always as mtime does not change
-       * on directories (ugh!).
-       */
-      if (dir->path_key)
-        {
-          if ((dir->fs_flags & FS_FAT) != 0)
-            {
-              dir->mtime = time ((time_t *) 0);
-              rehash = 1;
-            }
-          else if (stat (dir->path_key, &st) == 0 && st.st_mtime > dir->mtime)
-            {
-              /* reset date stamp to show most recent re-process.  */
-              dir->mtime = st.st_mtime;
-              rehash = 1;
-            }
-
-          /* If it has been already read in, all done.  */
-          if (!rehash)
-            return 0;
-
-          /* make sure directory can still be opened; if not return.  */
-          dir->dirstream = opendir (dir->path_key);
-          if (!dir->dirstream)
-            return 0;
-        }
-      else
-#endif
-        /* The directory has been all read in.  */
-        return 0;
-    }
-
-  while (1)
-    {
-      /* Enter the file in the hash table.  */
-      unsigned int len;
-      struct dirfile dirfile_key;
-      struct dirfile **dirfile_slot;
-
-      ENULLLOOP (d, readdir (dir->dirstream));
-      if (d == 0)
-        {
-          if (errno)
-            pfatal_with_name ("INTERNAL: readdir");
-          break;
-        }
-
-#if defined(VMS) && defined(HAVE_DIRENT_H)
-      /* In VMS we get file versions too, which have to be stripped off.
-         Some versions of VMS return versions on Unix files even when
-         the feature option to strip them is set.  */
-      {
-        char *p = strrchr (d->d_name, ';');
-        if (p)
-          *p = '\0';
-      }
-#endif
-      if (!REAL_DIR_ENTRY (d))
-        continue;
-
-      len = NAMLEN (d);
-      dirfile_key.name = d->d_name;
-      dirfile_key.length = len;
-      dirfile_slot = (struct dirfile **) hash_find_slot (&dir->dirfiles, &dirfile_key);
-#ifdef WINDOWS32
-      /*
-       * If re-reading a directory, don't cache files that have
-       * already been discovered.
-       */
-      if (! rehash || HASH_VACANT (*dirfile_slot))
-#endif
-        {
-          df = xmalloc (sizeof (struct dirfile));
-#if defined(HAVE_CASE_INSENSITIVE_FS) && defined(VMS)
-          /* TODO: Why is this only needed on VMS? */
-          df->name = strcache_add_len (downcase_inplace (d->d_name), len);
-#else
-          df->name = strcache_add_len (d->d_name, len);
-#endif
-          df->length = len;
-          df->impossible = 0;
-          hash_insert_at (&dir->dirfiles, df, dirfile_slot);
-        }
-      /* Check if the name matches the one we're searching for.  */
-      if (filename != 0 && patheq (d->d_name, filename))
-        return 1;
-    }
-
-  /* If the directory has been completely read in,
-     close the stream and reset the pointer to nil.  */
-  if (d == 0)
-    {
-      --open_directories;
-      closedir (dir->dirstream);
-      dir->dirstream = 0;
-    }
-  return 0;
-}
-
-/* Return 1 if the name FILENAME in directory DIRNAME
-   is entered in the dir hash table.
-   FILENAME must contain no slashes.  */
-
-int
-dir_file_exists_p (const char *dirname, const char *filename)
-{
-#ifdef VMS
-  if ((filename != NULL) && (dirname != NULL))
-    {
-      int want_vmsify;
-      want_vmsify = (strpbrk (dirname, ":<[") != NULL);
-      if (want_vmsify)
-        filename = vmsify (filename, 0);
-    }
-#endif
-  return dir_contents_file_exists_p (find_directory (dirname)->contents,
-                                     filename);
-}
-
-/* Return 1 if the file named NAME exists.  */
-
-int
-file_exists_p (const char *name)
-{
-  const char *dirend;
-  const char *dirname;
-  const char *slash;
-
-#ifndef NO_ARCHIVES
-  if (ar_name (name))
-    return ar_member_date (name) != (time_t) -1;
-#endif
-
-  dirend = strrchr (name, '/');
-#ifdef VMS
-  if (dirend == 0)
-    {
-      dirend = strrchr (name, ']');
-      dirend == NULL ? dirend : dirend++;
-    }
-  if (dirend == 0)
-    {
-      dirend = strrchr (name, '>');
-      dirend == NULL ? dirend : dirend++;
-    }
-  if (dirend == 0)
-    {
-      dirend = strrchr (name, ':');
-      dirend == NULL ? dirend : dirend++;
-    }
-#endif /* VMS */
-#ifdef HAVE_DOS_PATHS
-  /* Forward and backslashes might be mixed.  We need the rightmost one.  */
-  {
-    const char *bslash = strrchr (name, '\\');
-    if (!dirend || bslash > dirend)
-      dirend = bslash;
-    /* The case of "d:file".  */
-    if (!dirend && name[0] && name[1] == ':')
-      dirend = name + 1;
-  }
-#endif /* HAVE_DOS_PATHS */
-  if (dirend == 0)
-#ifndef _AMIGA
-    return dir_file_exists_p (".", name);
-#else /* !AMIGA */
-    return dir_file_exists_p ("", name);
-#endif /* AMIGA */
-
-  slash = dirend;
-  if (dirend == name)
-    dirname = "/";
-  else
-    {
-      char *p;
-#ifdef HAVE_DOS_PATHS
-  /* d:/ and d: are *very* different...  */
-      if (dirend < name + 3 && name[1] == ':' &&
-          (*dirend == '/' || *dirend == '\\' || *dirend == ':'))
-        dirend++;
-#endif
-      p = alloca (dirend - name + 1);
-      memcpy (p, name, dirend - name);
-      p[dirend - name] = '\0';
-      dirname = p;
-    }
-#ifdef VMS
-  if (*slash == '/')
-    slash++;
-#else
-  slash++;
-#endif
-  return dir_file_exists_p (dirname, slash);
-}
-
-/* Mark FILENAME as 'impossible' for 'file_impossible_p'.
-   This means an attempt has been made to search for FILENAME
-   as an intermediate file, and it has failed.  */
-
-void
-file_impossible (const char *filename)
-{
-  const char *dirend;
-  const char *p = filename;
-  struct directory *dir;
-  struct dirfile *new;
-
-  dirend = strrchr (p, '/');
-#ifdef VMS
-  if (dirend == NULL)
-    {
-      dirend = strrchr (p, ']');
-      dirend == NULL ? dirend : dirend++;
-    }
-  if (dirend == NULL)
-    {
-      dirend = strrchr (p, '>');
-      dirend == NULL ? dirend : dirend++;
-    }
-  if (dirend == NULL)
-    {
-      dirend = strrchr (p, ':');
-      dirend == NULL ? dirend : dirend++;
-    }
-#endif
-#ifdef HAVE_DOS_PATHS
-  /* Forward and backslashes might be mixed.  We need the rightmost one.  */
-  {
-    const char *bslash = strrchr (p, '\\');
-    if (!dirend || bslash > dirend)
-      dirend = bslash;
-    /* The case of "d:file".  */
-    if (!dirend && p[0] && p[1] == ':')
-      dirend = p + 1;
-  }
-#endif /* HAVE_DOS_PATHS */
-  if (dirend == 0)
-#ifdef _AMIGA
-    dir = find_directory ("");
-#else /* !AMIGA */
-    dir = find_directory (".");
-#endif /* AMIGA */
-  else
-    {
-      const char *dirname;
-      const char *slash = dirend;
-      if (dirend == p)
-        dirname = "/";
-      else
-        {
-          char *cp;
-#ifdef HAVE_DOS_PATHS
-          /* d:/ and d: are *very* different...  */
-          if (dirend < p + 3 && p[1] == ':' &&
-              (*dirend == '/' || *dirend == '\\' || *dirend == ':'))
-            dirend++;
-#endif
-          cp = alloca (dirend - p + 1);
-          memcpy (cp, p, dirend - p);
-          cp[dirend - p] = '\0';
-          dirname = cp;
-        }
-      dir = find_directory (dirname);
-#ifdef VMS
-      if (*slash == '/')
-        filename = p = slash + 1;
-      else
-        filename = p = slash;
-#else
-      filename = p = slash + 1;
-#endif
-    }
-
-  if (dir->contents == 0)
-    /* The directory could not be stat'd.  We allocate a contents
-       structure for it, but leave it out of the contents hash table.  */
-    dir->contents = xcalloc (sizeof (struct directory_contents));
-
-  if (dir->contents->dirfiles.ht_vec == 0)
-    {
-      hash_init (&dir->contents->dirfiles, DIRFILE_BUCKETS,
-                 dirfile_hash_1, dirfile_hash_2, dirfile_hash_cmp);
-    }
-
-  /* Make a new entry and put it in the table.  */
-
-  new = xmalloc (sizeof (struct dirfile));
-  new->length = strlen (filename);
-#if defined(HAVE_CASE_INSENSITIVE_FS) && defined(VMS)
-  /* todo: Why is this only needed on VMS? */
-  new->name = strcache_add_len (downcase (filename), new->length);
-#else
-  new->name = strcache_add_len (filename, new->length);
-#endif
-  new->impossible = 1;
-  hash_insert (&dir->contents->dirfiles, new);
-}
-
-/* Return nonzero if FILENAME has been marked impossible.  */
-
-int
-file_impossible_p (const char *filename)
-{
-  const char *dirend;
-  struct directory_contents *dir;
-  struct dirfile *dirfile;
-  struct dirfile dirfile_key;
-#ifdef VMS
-  int want_vmsify = 0;
-#endif
-
-  dirend = strrchr (filename, '/');
-#ifdef VMS
-  if (dirend == NULL)
-    {
-      want_vmsify = (strpbrk (filename, "]>:^") != NULL);
-      dirend = strrchr (filename, ']');
-    }
-  if (dirend == NULL && want_vmsify)
-    dirend = strrchr (filename, '>');
-  if (dirend == NULL && want_vmsify)
-    dirend = strrchr (filename, ':');
-#endif
-#ifdef HAVE_DOS_PATHS
-  /* Forward and backslashes might be mixed.  We need the rightmost one.  */
-  {
-    const char *bslash = strrchr (filename, '\\');
-    if (!dirend || bslash > dirend)
-      dirend = bslash;
-    /* The case of "d:file".  */
-    if (!dirend && filename[0] && filename[1] == ':')
-      dirend = filename + 1;
-  }
-#endif /* HAVE_DOS_PATHS */
-  if (dirend == 0)
-#ifdef _AMIGA
-    dir = find_directory ("")->contents;
-#else /* !AMIGA */
-    dir = find_directory (".")->contents;
-#endif /* AMIGA */
-  else
-    {
-      const char *dirname;
-      const char *slash = dirend;
-      if (dirend == filename)
-        dirname = "/";
-      else
-        {
-          char *cp;
-#ifdef HAVE_DOS_PATHS
-          /* d:/ and d: are *very* different...  */
-          if (dirend < filename + 3 && filename[1] == ':' &&
-              (*dirend == '/' || *dirend == '\\' || *dirend == ':'))
-            dirend++;
-#endif
-          cp = alloca (dirend - filename + 1);
-          memcpy (cp, filename, dirend - filename);
-          cp[dirend - filename] = '\0';
-          dirname = cp;
-        }
-      dir = find_directory (dirname)->contents;
-#ifdef VMS
-      if (*slash == '/')
-        filename = slash + 1;
-      else
-        filename = slash;
-#else
-      filename = slash + 1;
-#endif
-    }
-
-  if (dir == 0 || dir->dirfiles.ht_vec == 0)
-    /* There are no files entered for this directory.  */
-    return 0;
-
-#ifdef __MSDOS__
-  filename = dosify (filename);
-#endif
-#ifdef HAVE_CASE_INSENSITIVE_FS
-  filename = downcase (filename);
-#endif
-#ifdef VMS
-  if (want_vmsify)
-    filename = vmsify (filename, 1);
-#endif
-
-  dirfile_key.name = filename;
-  dirfile_key.length = strlen (filename);
-  dirfile = hash_find_item (&dir->dirfiles, &dirfile_key);
-  if (dirfile)
-    return dirfile->impossible;
-
-  return 0;
-}
-
-/* Return the already allocated name in the
-   directory hash table that matches DIR.  */
-
-const char *
-dir_name (const char *dir)
-{
-  return find_directory (dir)->name;
-}
-
-/* Print the data base of directories.  */
-
-void
-print_dir_data_base (void)
-{
-  unsigned int files;
-  unsigned int impossible;
-  struct directory **dir_slot;
-  struct directory **dir_end;
-
-  puts (_("\n# Directories\n"));
-
-  files = impossible = 0;
-
-  dir_slot = (struct directory **) directories.ht_vec;
-  dir_end = dir_slot + directories.ht_size;
-  for ( ; dir_slot < dir_end; dir_slot++)
-    {
-      struct directory *dir = *dir_slot;
-      if (! HASH_VACANT (dir))
-        {
-          if (dir->contents == 0)
-            printf (_("# %s: could not be stat'd.\n"), dir->name);
-          else if (dir->contents->dirfiles.ht_vec == 0)
-            {
-#ifdef WINDOWS32
-              printf (_("# %s (key %s, mtime %I64u): could not be opened.\n"),
-                      dir->name, dir->contents->path_key,
-                      (unsigned long long)dir->contents->mtime);
-#else  /* WINDOWS32 */
-#ifdef VMS_INO_T
-              printf (_("# %s (device %d, inode [%d,%d,%d]): could not be opened.\n"),
-                      dir->name, dir->contents->dev,
-                      dir->contents->ino[0], dir->contents->ino[1],
-                      dir->contents->ino[2]);
-#else
-              printf (_("# %s (device %ld, inode %ld): could not be opened.\n"),
-                      dir->name, (long int) dir->contents->dev,
-                      (long int) dir->contents->ino);
-#endif
-#endif /* WINDOWS32 */
-            }
-          else
-            {
-              unsigned int f = 0;
-              unsigned int im = 0;
-              struct dirfile **files_slot;
-              struct dirfile **files_end;
-
-              files_slot = (struct dirfile **) dir->contents->dirfiles.ht_vec;
-              files_end = files_slot + dir->contents->dirfiles.ht_size;
-              for ( ; files_slot < files_end; files_slot++)
-                {
-                  struct dirfile *df = *files_slot;
-                  if (! HASH_VACANT (df))
-                    {
-                      if (df->impossible)
-                        ++im;
-                      else
-                        ++f;
-                    }
-                }
-#ifdef WINDOWS32
-              printf (_("# %s (key %s, mtime %I64u): "),
-                      dir->name, dir->contents->path_key,
-                      (unsigned long long)dir->contents->mtime);
-#else  /* WINDOWS32 */
-#ifdef VMS_INO_T
-              printf (_("# %s (device %d, inode [%d,%d,%d]): "),
-                      dir->name, dir->contents->dev,
-                      dir->contents->ino[0], dir->contents->ino[1],
-                      dir->contents->ino[2]);
-#else
-              printf (_("# %s (device %ld, inode %ld): "),
-                      dir->name,
-                      (long)dir->contents->dev, (long)dir->contents->ino);
-#endif
-#endif /* WINDOWS32 */
-              if (f == 0)
-                fputs (_("No"), stdout);
-              else
-                printf ("%u", f);
-              fputs (_(" files, "), stdout);
-              if (im == 0)
-                fputs (_("no"), stdout);
-              else
-                printf ("%u", im);
-              fputs (_(" impossibilities"), stdout);
-              if (dir->contents->dirstream == 0)
-                puts (".");
-              else
-                puts (_(" so far."));
-              files += f;
-              impossible += im;
-            }
-        }
-    }
-
-  fputs ("\n# ", stdout);
-  if (files == 0)
-    fputs (_("No"), stdout);
-  else
-    printf ("%u", files);
-  fputs (_(" files, "), stdout);
-  if (impossible == 0)
-    fputs (_("no"), stdout);
-  else
-    printf ("%u", impossible);
-  printf (_(" impossibilities in %lu directories.\n"), directories.ht_fill);
-}
-
-/* Hooks for globbing.  */
-
-/* Structure describing state of iterating through a directory hash table.  */
-
-struct dirstream
-  {
-    struct directory_contents *contents; /* The directory being read.  */
-    struct dirfile **dirfile_slot; /* Current slot in table.  */
-  };
-
-/* Forward declarations.  */
-static __ptr_t open_dirstream (const char *);
-static struct dirent *read_dirstream (__ptr_t);
-
-static __ptr_t
-open_dirstream (const char *directory)
-{
-  struct dirstream *new;
-  struct directory *dir = find_directory (directory);
-
-  if (dir->contents == 0 || dir->contents->dirfiles.ht_vec == 0)
-    /* DIR->contents is nil if the directory could not be stat'd.
-       DIR->contents->dirfiles is nil if it could not be opened.  */
-    return 0;
-
-  /* Read all the contents of the directory now.  There is no benefit
-     in being lazy, since glob will want to see every file anyway.  */
-
-  dir_contents_file_exists_p (dir->contents, 0);
-
-  new = xmalloc (sizeof (struct dirstream));
-  new->contents = dir->contents;
-  new->dirfile_slot = (struct dirfile **) new->contents->dirfiles.ht_vec;
-
-  return (__ptr_t) new;
-}
-
-static struct dirent *
-read_dirstream (__ptr_t stream)
-{
-  static char *buf;
-  static unsigned int bufsz;
-
-  struct dirstream *const ds = (struct dirstream *) stream;
-  struct directory_contents *dc = ds->contents;
-  struct dirfile **dirfile_end = (struct dirfile **) dc->dirfiles.ht_vec + dc->dirfiles.ht_size;
-
-  while (ds->dirfile_slot < dirfile_end)
-    {
-      struct dirfile *df = *ds->dirfile_slot++;
-      if (! HASH_VACANT (df) && !df->impossible)
-        {
-          /* The glob interface wants a 'struct dirent', so mock one up.  */
-          struct dirent *d;
-          unsigned int len = df->length + 1;
-          unsigned int sz = sizeof (*d) - sizeof (d->d_name) + len;
-          if (sz > bufsz)
-            {
-              bufsz *= 2;
-              if (sz > bufsz)
-                bufsz = sz;
-              buf = xrealloc (buf, bufsz);
-            }
-          d = (struct dirent *) buf;
-#ifdef __MINGW32__
-# if __MINGW32_MAJOR_VERSION < 3 || (__MINGW32_MAJOR_VERSION == 3 && \
-                                     __MINGW32_MINOR_VERSION == 0)
-          d->d_name = xmalloc (len);
-# endif
-#endif
-          FAKE_DIR_ENTRY (d);
-#ifdef _DIRENT_HAVE_D_NAMLEN
-          d->d_namlen = len - 1;
-#endif
-#ifdef _DIRENT_HAVE_D_TYPE
-          d->d_type = DT_UNKNOWN;
-#endif
-          memcpy (d->d_name, df->name, len);
-          return d;
-        }
-    }
-
-  return 0;
-}
-
-/* On 64 bit ReliantUNIX (5.44 and above) in LFS mode, stat() is actually a
- * macro for stat64().  If stat is a macro, make a local wrapper function to
- * invoke it.
- *
- * On MS-Windows, stat() "succeeds" for foo/bar/. where foo/bar is a
- * regular file; fix that here.
- */
-#if !defined(stat) && !defined(WINDOWS32) || defined(VMS)
-# ifndef VMS
-#  ifndef HAVE_SYS_STAT_H
-int stat (const char *path, struct stat *sbuf);
-#  endif
-# else
-    /* We are done with the fake stat.  Go back to the real stat */
-#   ifdef stat
-#     undef stat
-#   endif
-# endif
-# define local_stat stat
-#else
-static int
-local_stat (const char *path, struct stat *buf)
-{
-  int e;
-#ifdef WINDOWS32
-  size_t plen = strlen (path);
-
-  /* Make sure the parent of "." exists and is a directory, not a
-     file.  This is because 'stat' on Windows normalizes the argument
-     foo/. => foo without checking first that foo is a directory.  */
-  if (plen > 1 && path[plen - 1] == '.'
-      && (path[plen - 2] == '/' || path[plen - 2] == '\\'))
-    {
-      char parent[MAXPATHLEN];
-
-      strncpy (parent, path, plen - 2);
-      parent[plen - 2] = '\0';
-      if (stat (parent, buf) < 0 || !_S_ISDIR (buf->st_mode))
-        return -1;
-    }
-#endif
-
-  EINTRLOOP (e, stat (path, buf));
-  return e;
-}
-#endif
-
-/* Similarly for lstat.  */
-#if !defined(lstat) && !defined(WINDOWS32) || defined(VMS)
-# ifndef VMS
-#  ifndef HAVE_SYS_STAT_H
-int lstat (const char *path, struct stat *sbuf);
-#  endif
-# else
-    /* We are done with the fake lstat.  Go back to the real lstat */
-#   ifdef lstat
-#     undef lstat
-#   endif
-# endif
-# define local_lstat lstat
-#elif defined(WINDOWS32)
-/* Windows doesn't support lstat().  */
-# define local_lstat local_stat
-#else
-static int
-local_lstat (const char *path, struct stat *buf)
-{
-  int e;
-  EINTRLOOP (e, lstat (path, buf));
-  return e;
-}
-#endif
-
-void
-dir_setup_glob (glob_t *gl)
-{
-  gl->gl_opendir = open_dirstream;
-  gl->gl_readdir = read_dirstream;
-  gl->gl_closedir = free;
-  gl->gl_lstat = local_lstat;
-  gl->gl_stat = local_stat;
-}
-
-void
-hash_init_directories (void)
-{
-  hash_init (&directories, DIRECTORY_BUCKETS,
-             directory_hash_1, directory_hash_2, directory_hash_cmp);
-  hash_init (&directory_contents, DIRECTORY_BUCKETS,
-             directory_contents_hash_1, directory_contents_hash_2,
-             directory_contents_hash_cmp);
-}
diff --git a/doc/make.1 b/doc/make.1
new file mode 100644
index 0000000..031321e
--- /dev/null
+++ b/doc/make.1
@@ -0,0 +1,379 @@
+.TH MAKE 1 "28 February 2016" "GNU" "User Commands"
+.SH NAME
+make \- GNU make utility to maintain groups of programs
+.SH SYNOPSIS
+.B make
+[\fIOPTION\fR]... [\fITARGET\fR]...
+.SH DESCRIPTION
+.LP
+The
+.I make
+utility will determine automatically which pieces of a large program need to
+be recompiled, and issue the commands to recompile them.  The manual describes
+the GNU implementation of
+.BR make ,
+which was written by Richard Stallman and Roland McGrath, and is currently
+maintained by Paul Smith.  Our examples show C programs, since they are very
+common, but you can use
+.B make
+with any programming language whose compiler can be run with a shell command.
+In fact,
+.B make
+is not limited to programs.  You can use it to describe any task where some
+files must be updated automatically from others whenever the others change.
+.LP
+To prepare to use
+.BR make ,
+you must write a file called the
+.I makefile
+that describes the relationships among files in your program, and the states
+the commands for updating each file.  In a program, typically the executable
+file is updated from object files, which are in turn made by compiling source
+files.
+.LP
+Once a suitable makefile exists, each time you change some source files,
+this simple shell command:
+.sp 1
+.RS
+.B make
+.RE
+.sp 1
+suffices to perform all necessary recompilations.
+The
+.B make
+program uses the makefile description and the last-modification times of the
+files to decide which of the files need to be updated.  For each of those
+files, it issues the commands recorded in the makefile.
+.LP
+.B make
+executes commands in the
+.I makefile
+to update one or more target
+.IR names ,
+where
+.I name
+is typically a program.
+If no
+.B \-f
+option is present,
+.B make
+will look for the makefiles
+.IR GNUmakefile ,
+.IR makefile ,
+and
+.IR Makefile ,
+in that order.
+.LP
+Normally you should call your makefile either
+.I makefile
+or
+.IR Makefile .
+(We recommend
+.I Makefile
+because it appears prominently near the beginning of a directory
+listing, right near other important files such as
+.IR  README .)
+The first name checked,
+.IR GNUmakefile ,
+is not recommended for most makefiles.  You should use this name if you have a
+makefile that is specific to GNU
+.BR make ,
+and will not be understood by other versions of
+.BR make .
+If
+.I makefile
+is '\-', the standard input is read.
+.LP
+.B make
+updates a target if it depends on prerequisite files
+that have been modified since the target was last modified,
+or if the target does not exist.
+.SH OPTIONS
+.sp 1
+.TP 0.5i
+\fB\-b\fR, \fB\-m\fR
+These options are ignored for compatibility with other versions of
+.BR make .
+.TP 0.5i
+\fB\-B\fR, \fB\-\-always\-make\fR
+Unconditionally make all targets.
+.TP 0.5i
+\fB\-C\fR \fIdir\fR, \fB\-\-directory\fR=\fIdir\fR
+Change to directory
+.I dir
+before reading the makefiles or doing anything else.
+If multiple
+.B \-C
+options are specified, each is interpreted relative to the
+previous one:
+.BR "\-C " /
+.BR "\-C " etc
+is equivalent to
+.BR "\-C " /etc.
+This is typically used with recursive invocations of
+.BR make .
+.TP 0.5i
+.B \-d
+Print debugging information in addition to normal processing.
+The debugging information says which files are being considered for
+remaking, which file-times are being compared and with what results,
+which files actually need to be remade, which implicit rules are
+considered and which are applied---everything interesting about how
+.B make
+decides what to do.
+.TP 0.5i
+.BI \-\-debug "[=FLAGS]"
+Print debugging information in addition to normal processing.
+If the
+.I FLAGS
+are omitted, then the behavior is the same as if
+.B \-d
+was specified.
+.I FLAGS
+may be
+.I a
+for all debugging output (same as using
+.BR \-d ),
+.I b
+for basic debugging,
+.I v
+for more verbose basic debugging,
+.I i
+for showing implicit rules,
+.I j
+for details on invocation of commands, and
+.I m
+for debugging while remaking makefiles.  Use
+.I n
+to disable all previous debugging flags.
+.TP 0.5i
+\fB\-e\fR, \fB\-\-environment\-overrides\fR
+Give variables taken from the environment precedence over variables
+from makefiles.
+.TP 0.5i
+\fB\-E\fR \fIstring\fR, \fB\-\-eval\fR \fIstring\fR
+Interpret \fIstring\fR using the \fBeval\fR function, before parsing any
+makefiles.
+.TP 0.5i
+\fB\-f\fR \fIfile\fR, \fB\-\-file\fR=\fIfile\fR, \fB\-\-makefile\fR=\fIFILE\fR
+Use
+.I file
+as a makefile.
+.TP 0.5i
+\fB\-i\fR, \fB\-\-ignore\-errors\fR
+Ignore all errors in commands executed to remake files.
+.TP 0.5i
+\fB\-I\fR \fIdir\fR, \fB\-\-include\-dir\fR=\fIdir\fR
+Specifies a directory
+.I dir
+to search for included makefiles.
+If several
+.B \-I
+options are used to specify several directories, the directories are
+searched in the order specified.
+Unlike the arguments to other flags of
+.BR make ,
+directories given with
+.B \-I
+flags may come directly after the flag:
+.BI \-I dir
+is allowed, as well as
+.B \-I
+.IR dir .
+This syntax is allowed for compatibility with the C
+preprocessor's
+.B \-I
+flag.
+.TP 0.5i
+\fB\-j\fR [\fIjobs\fR], \fB\-\-jobs\fR[=\fIjobs\fR]
+Specifies the number of
+.I jobs
+(commands) to run simultaneously.
+If there is more than one
+.B \-j
+option, the last one is effective.
+If the
+.B \-j
+option is given without an argument,
+.BR make
+will not limit the number of jobs that can run simultaneously.
+.TP 0.5i
+\fB\-k\fR, \fB\-\-keep\-going\fR
+Continue as much as possible after an error.
+While the target that failed, and those that depend on it, cannot
+be remade, the other dependencies of these targets can be processed
+all the same.
+.TP 0.5i
+\fB\-l\fR [\fIload\fR], \fB\-\-load\-average\fR[=\fIload\fR]
+Specifies that no new jobs (commands) should be started if there are
+others jobs running and the load average is at least
+.I load
+(a floating-point number).
+With no argument, removes a previous load limit.
+.TP 0.5i
+\fB\-L\fR, \fB\-\-check\-symlink\-times\fR
+Use the latest mtime between symlinks and target.
+.TP 0.5i
+\fB\-n\fR, \fB\-\-just\-print\fR, \fB\-\-dry\-run\fR, \fB\-\-recon\fR
+Print the commands that would be executed, but do not execute them (except in
+certain circumstances).
+.TP 0.5i
+\fB\-o\fR \fIfile\fR, \fB\-\-old\-file\fR=\fIfile\fR, \fB\-\-assume\-old\fR=\fIfile\fR
+Do not remake the file
+.I file
+even if it is older than its dependencies, and do not remake anything
+on account of changes in
+.IR file .
+Essentially the file is treated as very old and its rules are ignored.
+.TP 0.5i
+\fB\-O\fR[\fItype\fR], \fB\-\-output\-sync\fR[=\fItype\fR]
+When running multiple jobs in parallel with \fB-j\fR, ensure the output of
+each job is collected together rather than interspersed with output from
+other jobs.  If
+.I type
+is not specified or is
+.B target
+the output from the entire recipe for each target is grouped together.  If
+.I type
+is
+.B line
+the output from each command line within a recipe is grouped together.
+If
+.I type
+is
+.B recurse
+output from an entire recursive make is grouped together.  If
+.I type
+is
+.B none
+output synchronization is disabled.
+.TP 0.5i
+\fB\-p\fR, \fB\-\-print\-data\-base\fR
+Print the data base (rules and variable values) that results from
+reading the makefiles; then execute as usual or as otherwise
+specified.
+This also prints the version information given by the
+.B \-v
+switch (see below).
+To print the data base without trying to remake any files, use
+.IR "make \-p \-f/dev/null" .
+.TP 0.5i
+\fB\-q\fR, \fB\-\-question\fR
+``Question mode''.
+Do not run any commands, or print anything; just return an exit status
+that is zero if the specified targets are already up to date, nonzero
+otherwise.
+.TP 0.5i
+\fB\-r\fR, \fB\-\-no\-builtin\-rules\fR
+Eliminate use of the built\-in implicit rules.
+Also clear out the default list of suffixes for suffix rules.
+.TP 0.5i
+\fB\-R\fR, \fB\-\-no\-builtin\-variables\fR
+Don't define any built\-in variables.
+.TP 0.5i
+\fB\-s\fR, \fB\-\-silent\fR, \fB\-\-quiet\fR
+Silent operation; do not print the commands as they are executed.
+.TP 0.5i
+.B \-\-no\-silent
+Cancel the effect of the \fB\-s\fR option.
+.TP 0.5i
+\fB\-S\fR, \fB\-\-no\-keep\-going\fR, \fB\-\-stop\fR
+Cancel the effect of the
+.B \-k
+option.
+.TP 0.5i
+\fB\-t\fR, \fB\-\-touch\fR
+Touch files (mark them up to date without really changing them)
+instead of running their commands.
+This is used to pretend that the commands were done, in order to fool
+future invocations of
+.BR make .
+.TP 0.5i
+.B \-\-trace
+Information about the disposition of each target is printed (why the target is
+being rebuilt and what commands are run to rebuild it).
+.TP 0.5i
+\fB\-v\fR, \fB\-\-version\fR
+Print the version of the
+.B make
+program plus a copyright, a list of authors and a notice that there
+is no warranty.
+.TP 0.5i
+\fB\-w\fR, \fB\-\-print\-directory\fR
+Print a message containing the working directory
+before and after other processing.
+This may be useful for tracking down errors from complicated nests of
+recursive
+.B make
+commands.
+.TP 0.5i
+.B \-\-no\-print\-directory
+Turn off
+.BR \-w ,
+even if it was turned on implicitly.
+.TP 0.5i
+\fB\-W\fR \fIfile\fR, \fB\-\-what\-if\fR=\fIfile\fR, \fB\-\-new\-file\fR=\fIfile\fR, \fB\-\-assume\-new\fR=\fIfile\fR
+Pretend that the target
+.I file
+has just been modified.
+When used with the
+.B \-n
+flag, this shows you what would happen if you were to modify that file.
+Without
+.BR \-n ,
+it is almost the same as running a
+.I touch
+command on the given file before running
+.BR make ,
+except that the modification time is changed only in the imagination of
+.BR make .
+.TP 0.5i
+.B \-\-warn\-undefined\-variables
+Warn when an undefined variable is referenced.
+.SH "EXIT STATUS"
+GNU
+.B make
+exits with a status of zero if all makefiles were successfully parsed
+and no targets that were built failed.  A status of one will be returned
+if the
+.B \-q
+flag was used and
+.B make
+determines that a target needs to be rebuilt.  A status of two will be
+returned if any errors were encountered.
+.SH "SEE ALSO"
+The full documentation for
+.B make
+is maintained as a Texinfo manual.  If the
+.B info
+and
+.B make
+programs are properly installed at your site, the command
+.IP
+.B info make
+.PP
+should give you access to the complete manual.
+.SH BUGS
+See the chapter ``Problems and Bugs'' in
+.IR "The GNU Make Manual" .
+.SH AUTHOR
+This manual page contributed by Dennis Morse of Stanford University.
+Further updates contributed by Mike Frysinger.  It has been reworked by Roland
+McGrath.  Maintained by Paul Smith.
+.SH "COPYRIGHT"
+Copyright \(co 1992-1993, 1996-2017 Free Software Foundation, Inc.
+This file is part of
+.IR "GNU make" .
+.LP
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+.LP
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+.LP
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see
+.IR http://www.gnu.org/licenses/ .
diff --git a/expand.c b/expand.c
deleted file mode 100644
index 3341f9e..0000000
--- a/expand.c
+++ /dev/null
@@ -1,597 +0,0 @@
-/* Variable expansion functions for GNU Make.
-Copyright (C) 1988-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-
-#include <assert.h>
-
-#include "filedef.h"
-#include "job.h"
-#include "commands.h"
-#include "variable.h"
-#include "rule.h"
-
-/* Initially, any errors reported when expanding strings will be reported
-   against the file where the error appears.  */
-const floc **expanding_var = &reading_file;
-
-/* The next two describe the variable output buffer.
-   This buffer is used to hold the variable-expansion of a line of the
-   makefile.  It is made bigger with realloc whenever it is too small.
-   variable_buffer_length is the size currently allocated.
-   variable_buffer is the address of the buffer.
-
-   For efficiency, it's guaranteed that the buffer will always have
-   VARIABLE_BUFFER_ZONE extra bytes allocated.  This allows you to add a few
-   extra chars without having to call a function.  Note you should never use
-   these bytes unless you're _sure_ you have room (you know when the buffer
-   length was last checked.  */
-
-#define VARIABLE_BUFFER_ZONE    5
-
-static unsigned int variable_buffer_length;
-char *variable_buffer;
-
-/* Subroutine of variable_expand and friends:
-   The text to add is LENGTH chars starting at STRING to the variable_buffer.
-   The text is added to the buffer at PTR, and the updated pointer into
-   the buffer is returned as the value.  Thus, the value returned by
-   each call to variable_buffer_output should be the first argument to
-   the following call.  */
-
-char *
-variable_buffer_output (char *ptr, const char *string, unsigned int length)
-{
-  unsigned int newlen = length + (ptr - variable_buffer);
-
-  if ((newlen + VARIABLE_BUFFER_ZONE) > variable_buffer_length)
-    {
-      unsigned int offset = ptr - variable_buffer;
-      variable_buffer_length = (newlen + 100 > 2 * variable_buffer_length
-                                ? newlen + 100
-                                : 2 * variable_buffer_length);
-      variable_buffer = xrealloc (variable_buffer, variable_buffer_length);
-      ptr = variable_buffer + offset;
-    }
-
-  memcpy (ptr, string, length);
-  return ptr + length;
-}
-
-/* Return a pointer to the beginning of the variable buffer.  */
-
-static char *
-initialize_variable_output (void)
-{
-  /* If we don't have a variable output buffer yet, get one.  */
-
-  if (variable_buffer == 0)
-    {
-      variable_buffer_length = 200;
-      variable_buffer = xmalloc (variable_buffer_length);
-      variable_buffer[0] = '\0';
-    }
-
-  return variable_buffer;
-}
-
-/* Recursively expand V.  The returned string is malloc'd.  */
-
-static char *allocated_variable_append (const struct variable *v);
-
-char *
-recursively_expand_for_file (struct variable *v, struct file *file)
-{
-  char *value;
-  const floc *this_var;
-  const floc **saved_varp;
-  struct variable_set_list *save = 0;
-  int set_reading = 0;
-
-  /* Don't install a new location if this location is empty.
-     This can happen for command-line variables, builtin variables, etc.  */
-  saved_varp = expanding_var;
-  if (v->fileinfo.filenm)
-    {
-      this_var = &v->fileinfo;
-      expanding_var = &this_var;
-    }
-
-  /* If we have no other file-reading context, use the variable's context. */
-  if (!reading_file)
-    {
-      set_reading = 1;
-      reading_file = &v->fileinfo;
-    }
-
-  if (v->expanding)
-    {
-      if (!v->exp_count)
-        /* Expanding V causes infinite recursion.  Lose.  */
-        OS (fatal, *expanding_var,
-            _("Recursive variable '%s' references itself (eventually)"),
-            v->name);
-      --v->exp_count;
-    }
-
-  if (file)
-    {
-      save = current_variable_set_list;
-      current_variable_set_list = file->variables;
-    }
-
-  v->expanding = 1;
-  if (v->append)
-    value = allocated_variable_append (v);
-  else
-    value = allocated_variable_expand (v->value);
-  v->expanding = 0;
-
-  if (set_reading)
-    reading_file = 0;
-
-  if (file)
-    current_variable_set_list = save;
-
-  expanding_var = saved_varp;
-
-  return value;
-}
-
-/* Expand a simple reference to variable NAME, which is LENGTH chars long.  */
-
-#ifdef __GNUC__
-__inline
-#endif
-static char *
-reference_variable (char *o, const char *name, unsigned int length)
-{
-  struct variable *v;
-  char *value;
-
-  v = lookup_variable (name, length);
-
-  if (v == 0)
-    warn_undefined (name, length);
-
-  /* If there's no variable by that name or it has no value, stop now.  */
-  if (v == 0 || (*v->value == '\0' && !v->append))
-    return o;
-
-  value = (v->recursive ? recursively_expand (v) : v->value);
-
-  o = variable_buffer_output (o, value, strlen (value));
-
-  if (v->recursive)
-    free (value);
-
-  return o;
-}
-
-/* Scan STRING for variable references and expansion-function calls.  Only
-   LENGTH bytes of STRING are actually scanned.  If LENGTH is -1, scan until
-   a null byte is found.
-
-   Write the results to LINE, which must point into 'variable_buffer'.  If
-   LINE is NULL, start at the beginning of the buffer.
-   Return a pointer to LINE, or to the beginning of the buffer if LINE is
-   NULL.
- */
-char *
-variable_expand_string (char *line, const char *string, long length)
-{
-  struct variable *v;
-  const char *p, *p1;
-  char *save;
-  char *o;
-  unsigned int line_offset;
-
-  if (!line)
-    line = initialize_variable_output ();
-  o = line;
-  line_offset = line - variable_buffer;
-
-  if (length == 0)
-    {
-      variable_buffer_output (o, "", 1);
-      return (variable_buffer);
-    }
-
-  /* We need a copy of STRING: due to eval, it's possible that it will get
-     freed as we process it (it might be the value of a variable that's reset
-     for example).  Also having a nil-terminated string is handy.  */
-  save = length < 0 ? xstrdup (string) : xstrndup (string, length);
-  p = save;
-
-  while (1)
-    {
-      /* Copy all following uninteresting chars all at once to the
-         variable output buffer, and skip them.  Uninteresting chars end
-         at the next $ or the end of the input.  */
-
-      p1 = strchr (p, '$');
-
-      o = variable_buffer_output (o, p, p1 != 0 ? (unsigned int)(p1 - p) : strlen (p) + 1);
-
-      if (p1 == 0)
-        break;
-      p = p1 + 1;
-
-      /* Dispatch on the char that follows the $.  */
-
-      switch (*p)
-        {
-        case '$':
-        case '\0':
-          /* $$ or $ at the end of the string means output one $ to the
-             variable output buffer.  */
-          o = variable_buffer_output (o, p1, 1);
-          break;
-
-        case '(':
-        case '{':
-          /* $(...) or ${...} is the general case of substitution.  */
-          {
-            char openparen = *p;
-            char closeparen = (openparen == '(') ? ')' : '}';
-            const char *begp;
-            const char *beg = p + 1;
-            char *op;
-            char *abeg = NULL;
-            const char *end, *colon;
-
-            op = o;
-            begp = p;
-            if (handle_function (&op, &begp))
-              {
-                o = op;
-                p = begp;
-                break;
-              }
-
-            /* Is there a variable reference inside the parens or braces?
-               If so, expand it before expanding the entire reference.  */
-
-            end = strchr (beg, closeparen);
-            if (end == 0)
-              /* Unterminated variable reference.  */
-              O (fatal, *expanding_var, _("unterminated variable reference"));
-            p1 = lindex (beg, end, '$');
-            if (p1 != 0)
-              {
-                /* BEG now points past the opening paren or brace.
-                   Count parens or braces until it is matched.  */
-                int count = 0;
-                for (p = beg; *p != '\0'; ++p)
-                  {
-                    if (*p == openparen)
-                      ++count;
-                    else if (*p == closeparen && --count < 0)
-                      break;
-                  }
-                /* If COUNT is >= 0, there were unmatched opening parens
-                   or braces, so we go to the simple case of a variable name
-                   such as '$($(a)'.  */
-                if (count < 0)
-                  {
-                    abeg = expand_argument (beg, p); /* Expand the name.  */
-                    beg = abeg;
-                    end = strchr (beg, '\0');
-                  }
-              }
-            else
-              /* Advance P to the end of this reference.  After we are
-                 finished expanding this one, P will be incremented to
-                 continue the scan.  */
-              p = end;
-
-            /* This is not a reference to a built-in function and
-               any variable references inside are now expanded.
-               Is the resultant text a substitution reference?  */
-
-            colon = lindex (beg, end, ':');
-            if (colon)
-              {
-                /* This looks like a substitution reference: $(FOO:A=B).  */
-                const char *subst_beg = colon + 1;
-                const char *subst_end = lindex (subst_beg, end, '=');
-                if (subst_end == 0)
-                  /* There is no = in sight.  Punt on the substitution
-                     reference and treat this as a variable name containing
-                     a colon, in the code below.  */
-                  colon = 0;
-                else
-                  {
-                    const char *replace_beg = subst_end + 1;
-                    const char *replace_end = end;
-
-                    /* Extract the variable name before the colon
-                       and look up that variable.  */
-                    v = lookup_variable (beg, colon - beg);
-                    if (v == 0)
-                      warn_undefined (beg, colon - beg);
-
-                    /* If the variable is not empty, perform the
-                       substitution.  */
-                    if (v != 0 && *v->value != '\0')
-                      {
-                        char *pattern, *replace, *ppercent, *rpercent;
-                        char *value = (v->recursive
-                                       ? recursively_expand (v)
-                                       : v->value);
-
-                        /* Copy the pattern and the replacement.  Add in an
-                           extra % at the beginning to use in case there
-                           isn't one in the pattern.  */
-                        pattern = alloca (subst_end - subst_beg + 2);
-                        *(pattern++) = '%';
-                        memcpy (pattern, subst_beg, subst_end - subst_beg);
-                        pattern[subst_end - subst_beg] = '\0';
-
-                        replace = alloca (replace_end - replace_beg + 2);
-                        *(replace++) = '%';
-                        memcpy (replace, replace_beg,
-                               replace_end - replace_beg);
-                        replace[replace_end - replace_beg] = '\0';
-
-                        /* Look for %.  Set the percent pointers properly
-                           based on whether we find one or not.  */
-                        ppercent = find_percent (pattern);
-                        if (ppercent)
-                          {
-                            ++ppercent;
-                            rpercent = find_percent (replace);
-                            if (rpercent)
-                              ++rpercent;
-                          }
-                        else
-                          {
-                            ppercent = pattern;
-                            rpercent = replace;
-                            --pattern;
-                            --replace;
-                          }
-
-                        o = patsubst_expand_pat (o, value, pattern, replace,
-                                                 ppercent, rpercent);
-
-                        if (v->recursive)
-                          free (value);
-                      }
-                  }
-              }
-
-            if (colon == 0)
-              /* This is an ordinary variable reference.
-                 Look up the value of the variable.  */
-                o = reference_variable (o, beg, end - beg);
-
-            free (abeg);
-          }
-          break;
-
-        default:
-          if (ISSPACE (p[-1]))
-            break;
-
-          /* A $ followed by a random char is a variable reference:
-             $a is equivalent to $(a).  */
-          o = reference_variable (o, p, 1);
-
-          break;
-        }
-
-      if (*p == '\0')
-        break;
-
-      ++p;
-    }
-
-  free (save);
-
-  variable_buffer_output (o, "", 1);
-  return (variable_buffer + line_offset);
-}
-
-/* Scan LINE for variable references and expansion-function calls.
-   Build in 'variable_buffer' the result of expanding the references and calls.
-   Return the address of the resulting string, which is null-terminated
-   and is valid only until the next time this function is called.  */
-
-char *
-variable_expand (const char *line)
-{
-  return variable_expand_string (NULL, line, (long)-1);
-}
-
-/* Expand an argument for an expansion function.
-   The text starting at STR and ending at END is variable-expanded
-   into a null-terminated string that is returned as the value.
-   This is done without clobbering 'variable_buffer' or the current
-   variable-expansion that is in progress.  */
-
-char *
-expand_argument (const char *str, const char *end)
-{
-  char *tmp, *alloc = NULL;
-  char *r;
-
-  if (str == end)
-    return xstrdup ("");
-
-  if (!end || *end == '\0')
-    return allocated_variable_expand (str);
-
-  if (end - str + 1 > 1000)
-    tmp = alloc = xmalloc (end - str + 1);
-  else
-    tmp = alloca (end - str + 1);
-
-  memcpy (tmp, str, end - str);
-  tmp[end - str] = '\0';
-
-  r = allocated_variable_expand (tmp);
-
-  free (alloc);
-
-  return r;
-}
-
-/* Expand LINE for FILE.  Error messages refer to the file and line where
-   FILE's commands were found.  Expansion uses FILE's variable set list.  */
-
-char *
-variable_expand_for_file (const char *line, struct file *file)
-{
-  char *result;
-  struct variable_set_list *savev;
-  const floc *savef;
-
-  if (file == 0)
-    return variable_expand (line);
-
-  savev = current_variable_set_list;
-  current_variable_set_list = file->variables;
-
-  savef = reading_file;
-  if (file->cmds && file->cmds->fileinfo.filenm)
-    reading_file = &file->cmds->fileinfo;
-  else
-    reading_file = 0;
-
-  result = variable_expand (line);
-
-  current_variable_set_list = savev;
-  reading_file = savef;
-
-  return result;
-}
-
-/* Like allocated_variable_expand, but for += target-specific variables.
-   First recursively construct the variable value from its appended parts in
-   any upper variable sets.  Then expand the resulting value.  */
-
-static char *
-variable_append (const char *name, unsigned int length,
-                 const struct variable_set_list *set, int local)
-{
-  const struct variable *v;
-  char *buf = 0;
-  int nextlocal;
-
-  /* If there's nothing left to check, return the empty buffer.  */
-  if (!set)
-    return initialize_variable_output ();
-
-  /* If this set is local and the next is not a parent, then next is local.  */
-  nextlocal = local && set->next_is_parent == 0;
-
-  /* Try to find the variable in this variable set.  */
-  v = lookup_variable_in_set (name, length, set->set);
-
-  /* If there isn't one, or this one is private, try the set above us.  */
-  if (!v || (!local && v->private_var))
-    return variable_append (name, length, set->next, nextlocal);
-
-  /* If this variable type is append, first get any upper values.
-     If not, initialize the buffer.  */
-  if (v->append)
-    buf = variable_append (name, length, set->next, nextlocal);
-  else
-    buf = initialize_variable_output ();
-
-  /* Append this value to the buffer, and return it.
-     If we already have a value, first add a space.  */
-  if (buf > variable_buffer)
-    buf = variable_buffer_output (buf, " ", 1);
-
-  /* Either expand it or copy it, depending.  */
-  if (! v->recursive)
-    return variable_buffer_output (buf, v->value, strlen (v->value));
-
-  buf = variable_expand_string (buf, v->value, strlen (v->value));
-  return (buf + strlen (buf));
-}
-
-
-static char *
-allocated_variable_append (const struct variable *v)
-{
-  char *val;
-
-  /* Construct the appended variable value.  */
-
-  char *obuf = variable_buffer;
-  unsigned int olen = variable_buffer_length;
-
-  variable_buffer = 0;
-
-  val = variable_append (v->name, strlen (v->name),
-                         current_variable_set_list, 1);
-  variable_buffer_output (val, "", 1);
-  val = variable_buffer;
-
-  variable_buffer = obuf;
-  variable_buffer_length = olen;
-
-  return val;
-}
-
-/* Like variable_expand_for_file, but the returned string is malloc'd.
-   This function is called a lot.  It wants to be efficient.  */
-
-char *
-allocated_variable_expand_for_file (const char *line, struct file *file)
-{
-  char *value;
-
-  char *obuf = variable_buffer;
-  unsigned int olen = variable_buffer_length;
-
-  variable_buffer = 0;
-
-  value = variable_expand_for_file (line, file);
-
-  variable_buffer = obuf;
-  variable_buffer_length = olen;
-
-  return value;
-}
-
-/* Install a new variable_buffer context, returning the current one for
-   safe-keeping.  */
-
-void
-install_variable_buffer (char **bufp, unsigned int *lenp)
-{
-  *bufp = variable_buffer;
-  *lenp = variable_buffer_length;
-
-  variable_buffer = 0;
-  initialize_variable_output ();
-}
-
-/* Restore a previously-saved variable_buffer setting (free the current one).
- */
-
-void
-restore_variable_buffer (char *buf, unsigned int len)
-{
-  free (variable_buffer);
-
-  variable_buffer = buf;
-  variable_buffer_length = len;
-}
diff --git a/file.c b/file.c
deleted file mode 100644
index fe58eba..0000000
--- a/file.c
+++ /dev/null
@@ -1,1148 +0,0 @@
-/* Target file management for GNU Make.
-Copyright (C) 1988-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-
-#include <assert.h>
-
-#include "filedef.h"
-#include "dep.h"
-#include "job.h"
-#include "commands.h"
-#include "variable.h"
-#include "debug.h"
-#include "hash.h"
-
-
-/* Remember whether snap_deps has been invoked: we need this to be sure we
-   don't add new rules (via $(eval ...)) afterwards.  In the future it would
-   be nice to support this, but it means we'd need to re-run snap_deps() or
-   at least its functionality... it might mean changing snap_deps() to be run
-   per-file, so we can invoke it after the eval... or remembering which files
-   in the hash have been snapped (a new boolean flag?) and having snap_deps()
-   only work on files which have not yet been snapped. */
-int snapped_deps = 0;
-
-/* Hash table of files the makefile knows how to make.  */
-
-static unsigned long
-file_hash_1 (const void *key)
-{
-  return_ISTRING_HASH_1 (((struct file const *) key)->hname);
-}
-
-static unsigned long
-file_hash_2 (const void *key)
-{
-  return_ISTRING_HASH_2 (((struct file const *) key)->hname);
-}
-
-static int
-file_hash_cmp (const void *x, const void *y)
-{
-  return_ISTRING_COMPARE (((struct file const *) x)->hname,
-                          ((struct file const *) y)->hname);
-}
-
-static struct hash_table files;
-
-/* Whether or not .SECONDARY with no prerequisites was given.  */
-static int all_secondary = 0;
-
-/* Access the hash table of all file records.
-   lookup_file  given a name, return the struct file * for that name,
-                or nil if there is none.
-*/
-
-struct file *
-lookup_file (const char *name)
-{
-  struct file *f;
-  struct file file_key;
-#ifdef VMS
-  int want_vmsify;
-#ifndef WANT_CASE_SENSITIVE_TARGETS
-  char *lname;
-#endif
-#endif
-
-  assert (*name != '\0');
-
-  /* This is also done in parse_file_seq, so this is redundant
-     for names read from makefiles.  It is here for names passed
-     on the command line.  */
-#ifdef VMS
-   want_vmsify = (strpbrk (name, "]>:^") != NULL);
-# ifndef WANT_CASE_SENSITIVE_TARGETS
-  if (*name != '.')
-    {
-      const char *n;
-      char *ln;
-      lname = xstrdup (name);
-      for (n = name, ln = lname; *n != '\0'; ++n, ++ln)
-        *ln = isupper ((unsigned char)*n) ? tolower ((unsigned char)*n) : *n;
-      *ln = '\0';
-      name = lname;
-    }
-# endif
-
-  while (name[0] == '[' && name[1] == ']' && name[2] != '\0')
-      name += 2;
-  while (name[0] == '<' && name[1] == '>' && name[2] != '\0')
-      name += 2;
-#endif
-  while (name[0] == '.'
-#ifdef HAVE_DOS_PATHS
-         && (name[1] == '/' || name[1] == '\\')
-#else
-         && name[1] == '/'
-#endif
-         && name[2] != '\0')
-    {
-      name += 2;
-      while (*name == '/'
-#ifdef HAVE_DOS_PATHS
-             || *name == '\\'
-#endif
-             )
-        /* Skip following slashes: ".//foo" is "foo", not "/foo".  */
-        ++name;
-    }
-
-  if (*name == '\0')
-    {
-      /* It was all slashes after a dot.  */
-#if defined(_AMIGA)
-      name = "";
-#else
-      name = "./";
-#endif
-#if defined(VMS)
-      /* TODO - This section is probably not needed. */
-      if (want_vmsify)
-        name = "[]";
-#endif
-    }
-  file_key.hname = name;
-  f = hash_find_item (&files, &file_key);
-#if defined(VMS) && !defined(WANT_CASE_SENSITIVE_TARGETS)
-  if (*name != '.')
-    free (lname);
-#endif
-
-  return f;
-}
-
-/* Look up a file record for file NAME and return it.
-   Create a new record if one doesn't exist.  NAME will be stored in the
-   new record so it should be constant or in the strcache etc.
- */
-
-struct file *
-enter_file (const char *name)
-{
-  struct file *f;
-  struct file *new;
-  struct file **file_slot;
-  struct file file_key;
-
-  assert (*name != '\0');
-  assert (! verify_flag || strcache_iscached (name));
-
-#if defined(VMS) && !defined(WANT_CASE_SENSITIVE_TARGETS)
-  if (*name != '.')
-    {
-      const char *n;
-      char *lname, *ln;
-      lname = xstrdup (name);
-      for (n = name, ln = lname; *n != '\0'; ++n, ++ln)
-        if (isupper ((unsigned char)*n))
-          *ln = tolower ((unsigned char)*n);
-        else
-          *ln = *n;
-
-      *ln = '\0';
-      name = strcache_add (lname);
-      free (lname);
-    }
-#endif
-
-  file_key.hname = name;
-  file_slot = (struct file **) hash_find_slot (&files, &file_key);
-  f = *file_slot;
-  if (! HASH_VACANT (f) && !f->double_colon)
-    {
-      f->builtin = 0;
-      return f;
-    }
-
-  new = xcalloc (sizeof (struct file));
-  new->name = new->hname = name;
-  new->update_status = us_none;
-
-  if (HASH_VACANT (f))
-    {
-      new->last = new;
-      hash_insert_at (&files, new, file_slot);
-    }
-  else
-    {
-      /* There is already a double-colon entry for this file.  */
-      new->double_colon = f;
-      f->last->prev = new;
-      f->last = new;
-    }
-
-  return new;
-}
-
-/* Rehash FILE to NAME.  This is not as simple as resetting
-   the 'hname' member, since it must be put in a new hash bucket,
-   and possibly merged with an existing file called NAME.  */
-
-void
-rehash_file (struct file *from_file, const char *to_hname)
-{
-  struct file file_key;
-  struct file **file_slot;
-  struct file *to_file;
-  struct file *deleted_file;
-  struct file *f;
-
-  /* If it's already that name, we're done.  */
-  from_file->builtin = 0;
-  file_key.hname = to_hname;
-  if (! file_hash_cmp (from_file, &file_key))
-    return;
-
-  /* Find the end of the renamed list for the "from" file.  */
-  file_key.hname = from_file->hname;
-  while (from_file->renamed != 0)
-    from_file = from_file->renamed;
-  if (file_hash_cmp (from_file, &file_key))
-    /* hname changed unexpectedly!! */
-    abort ();
-
-  /* Remove the "from" file from the hash.  */
-  deleted_file = hash_delete (&files, from_file);
-  if (deleted_file != from_file)
-    /* from_file isn't the one stored in files */
-    abort ();
-
-  /* Find where the newly renamed file will go in the hash.  */
-  file_key.hname = to_hname;
-  file_slot = (struct file **) hash_find_slot (&files, &file_key);
-  to_file = *file_slot;
-
-  /* Change the hash name for this file.  */
-  from_file->hname = to_hname;
-  for (f = from_file->double_colon; f != 0; f = f->prev)
-    f->hname = to_hname;
-
-  /* If the new name doesn't exist yet just set it to the renamed file.  */
-  if (HASH_VACANT (to_file))
-    {
-      hash_insert_at (&files, from_file, file_slot);
-      return;
-    }
-
-  /* TO_FILE already exists under TO_HNAME.
-     We must retain TO_FILE and merge FROM_FILE into it.  */
-
-  if (from_file->cmds != 0)
-    {
-      if (to_file->cmds == 0)
-        to_file->cmds = from_file->cmds;
-      else if (from_file->cmds != to_file->cmds)
-        {
-          size_t l = strlen (from_file->name);
-          /* We have two sets of commands.  We will go with the
-             one given in the rule explicitly mentioning this name,
-             but give a message to let the user know what's going on.  */
-          if (to_file->cmds->fileinfo.filenm != 0)
-            error (&from_file->cmds->fileinfo,
-                   l + strlen (to_file->cmds->fileinfo.filenm) + INTSTR_LENGTH,
-                   _("Recipe was specified for file '%s' at %s:%lu,"),
-                   from_file->name, to_file->cmds->fileinfo.filenm,
-                   to_file->cmds->fileinfo.lineno);
-          else
-            error (&from_file->cmds->fileinfo, l,
-                   _("Recipe for file '%s' was found by implicit rule search,"),
-                   from_file->name);
-          l += strlen (to_hname);
-          error (&from_file->cmds->fileinfo, l,
-                 _("but '%s' is now considered the same file as '%s'."),
-                 from_file->name, to_hname);
-          error (&from_file->cmds->fileinfo, l,
-                 _("Recipe for '%s' will be ignored in favor of the one for '%s'."),
-                 to_hname, from_file->name);
-        }
-    }
-
-  /* Merge the dependencies of the two files.  */
-
-  if (to_file->deps == 0)
-    to_file->deps = from_file->deps;
-  else
-    {
-      struct dep *deps = to_file->deps;
-      while (deps->next != 0)
-        deps = deps->next;
-      deps->next = from_file->deps;
-    }
-
-  merge_variable_set_lists (&to_file->variables, from_file->variables);
-
-  if (to_file->double_colon && from_file->is_target && !from_file->double_colon)
-    OSS (fatal, NILF, _("can't rename single-colon '%s' to double-colon '%s'"),
-         from_file->name, to_hname);
-  if (!to_file->double_colon  && from_file->double_colon)
-    {
-      if (to_file->is_target)
-        OSS (fatal, NILF,
-             _("can't rename double-colon '%s' to single-colon '%s'"),
-             from_file->name, to_hname);
-      else
-        to_file->double_colon = from_file->double_colon;
-    }
-
-  if (from_file->last_mtime > to_file->last_mtime)
-    /* %%% Kludge so -W wins on a file that gets vpathized.  */
-    to_file->last_mtime = from_file->last_mtime;
-
-  to_file->mtime_before_update = from_file->mtime_before_update;
-
-#define MERGE(field) to_file->field |= from_file->field
-  MERGE (precious);
-  MERGE (tried_implicit);
-  MERGE (updating);
-  MERGE (updated);
-  MERGE (is_target);
-  MERGE (cmd_target);
-  MERGE (phony);
-  MERGE (loaded);
-  MERGE (ignore_vpath);
-#undef MERGE
-
-  to_file->builtin = 0;
-  from_file->renamed = to_file;
-}
-
-/* Rename FILE to NAME.  This is not as simple as resetting
-   the 'name' member, since it must be put in a new hash bucket,
-   and possibly merged with an existing file called NAME.  */
-
-void
-rename_file (struct file *from_file, const char *to_hname)
-{
-  rehash_file (from_file, to_hname);
-  while (from_file)
-    {
-      from_file->name = from_file->hname;
-      from_file = from_file->prev;
-    }
-}
-
-/* Remove all nonprecious intermediate files.
-   If SIG is nonzero, this was caused by a fatal signal,
-   meaning that a different message will be printed, and
-   the message will go to stderr rather than stdout.  */
-
-void
-remove_intermediates (int sig)
-{
-  struct file **file_slot;
-  struct file **file_end;
-  int doneany = 0;
-
-  /* If there's no way we will ever remove anything anyway, punt early.  */
-  if (question_flag || touch_flag || all_secondary)
-    return;
-
-  if (sig && just_print_flag)
-    return;
-
-  file_slot = (struct file **) files.ht_vec;
-  file_end = file_slot + files.ht_size;
-  for ( ; file_slot < file_end; file_slot++)
-    if (! HASH_VACANT (*file_slot))
-      {
-        struct file *f = *file_slot;
-        /* Is this file eligible for automatic deletion?
-           Yes, IFF: it's marked intermediate, it's not secondary, it wasn't
-           given on the command line, and it's either a -include makefile or
-           it's not precious.  */
-        if (f->intermediate && (f->dontcare || !f->precious)
-            && !f->secondary && !f->cmd_target)
-          {
-            int status;
-            if (f->update_status == us_none)
-              /* If nothing would have created this file yet,
-                 don't print an "rm" command for it.  */
-              continue;
-            if (just_print_flag)
-              status = 0;
-            else
-              {
-                status = unlink (f->name);
-                if (status < 0 && errno == ENOENT)
-                  continue;
-              }
-            if (!f->dontcare)
-              {
-                if (sig)
-                  OS (error, NILF,
-                      _("*** Deleting intermediate file '%s'"), f->name);
-                else
-                  {
-                    if (! doneany)
-                      DB (DB_BASIC, (_("Removing intermediate files...\n")));
-                    if (!silent_flag)
-                      {
-                        if (! doneany)
-                          {
-                            fputs ("rm ", stdout);
-                            doneany = 1;
-                          }
-                        else
-                          putchar (' ');
-                        fputs (f->name, stdout);
-                        fflush (stdout);
-                      }
-                  }
-                if (status < 0)
-                  perror_with_name ("unlink: ", f->name);
-              }
-          }
-      }
-
-  if (doneany && !sig)
-    {
-      putchar ('\n');
-      fflush (stdout);
-    }
-}
-
-/* Given a string containing prerequisites (fully expanded), break it up into
-   a struct dep list.  Enter each of these prereqs into the file database.
- */
-struct dep *
-split_prereqs (char *p)
-{
-  struct dep *new = PARSE_FILE_SEQ (&p, struct dep, MAP_PIPE, NULL,
-                                    PARSEFS_NONE);
-
-  if (*p)
-    {
-      /* Files that follow '|' are "order-only" prerequisites that satisfy the
-         dependency by existing: their modification times are irrelevant.  */
-      struct dep *ood;
-
-      ++p;
-      ood = PARSE_SIMPLE_SEQ (&p, struct dep);
-
-      if (! new)
-        new = ood;
-      else
-        {
-          struct dep *dp;
-          for (dp = new; dp->next != NULL; dp = dp->next)
-            ;
-          dp->next = ood;
-        }
-
-      for (; ood != NULL; ood = ood->next)
-        ood->ignore_mtime = 1;
-    }
-
-  return new;
-}
-
-/* Given a list of prerequisites, enter them into the file database.
-   If STEM is set then first expand patterns using STEM.  */
-struct dep *
-enter_prereqs (struct dep *deps, const char *stem)
-{
-  struct dep *d1;
-
-  if (deps == 0)
-    return 0;
-
-  /* If we have a stem, expand the %'s.  We use patsubst_expand to translate
-     the prerequisites' patterns into plain prerequisite names.  */
-  if (stem)
-    {
-      const char *pattern = "%";
-      char *buffer = variable_expand ("");
-      struct dep *dp = deps, *dl = 0;
-
-      while (dp != 0)
-        {
-          char *percent;
-          int nl = strlen (dp->name) + 1;
-          char *nm = alloca (nl);
-          memcpy (nm, dp->name, nl);
-          percent = find_percent (nm);
-          if (percent)
-            {
-              char *o;
-
-              /* We have to handle empty stems specially, because that
-                 would be equivalent to $(patsubst %,dp->name,) which
-                 will always be empty.  */
-              if (stem[0] == '\0')
-                {
-                  memmove (percent, percent+1, strlen (percent));
-                  o = variable_buffer_output (buffer, nm, strlen (nm) + 1);
-                }
-              else
-                o = patsubst_expand_pat (buffer, stem, pattern, nm,
-                                         pattern+1, percent+1);
-
-              /* If the name expanded to the empty string, ignore it.  */
-              if (buffer[0] == '\0')
-                {
-                  struct dep *df = dp;
-                  if (dp == deps)
-                    dp = deps = deps->next;
-                  else
-                    dp = dl->next = dp->next;
-                  free_dep (df);
-                  continue;
-                }
-
-              /* Save the name.  */
-              dp->name = strcache_add_len (buffer, o - buffer);
-            }
-          dp->stem = stem;
-          dp->staticpattern = 1;
-          dl = dp;
-          dp = dp->next;
-        }
-    }
-
-  /* Enter them as files, unless they need a 2nd expansion.  */
-  for (d1 = deps; d1 != 0; d1 = d1->next)
-    {
-      if (d1->need_2nd_expansion)
-        continue;
-
-      d1->file = lookup_file (d1->name);
-      if (d1->file == 0)
-        d1->file = enter_file (d1->name);
-      d1->staticpattern = 0;
-      d1->name = 0;
-    }
-
-  return deps;
-}
-
-/* Set the intermediate flag.  */
-
-static void
-set_intermediate (const void *item)
-{
-  struct file *f = (struct file *) item;
-  f->intermediate = 1;
-}
-
-/* Expand and parse each dependency line. */
-static void
-expand_deps (struct file *f)
-{
-  struct dep *d;
-  struct dep **dp;
-  const char *file_stem = f->stem;
-  int initialized = 0;
-
-  f->updating = 0;
-
-  /* Walk through the dependencies.  For any dependency that needs 2nd
-     expansion, expand it then insert the result into the list.  */
-  dp = &f->deps;
-  d = f->deps;
-  while (d != 0)
-    {
-      char *p;
-      struct dep *new, *next;
-      char *name = (char *)d->name;
-
-      if (! d->name || ! d->need_2nd_expansion)
-        {
-          /* This one is all set already.  */
-          dp = &d->next;
-          d = d->next;
-          continue;
-        }
-
-      /* If it's from a static pattern rule, convert the patterns into
-         "$*" so they'll expand properly.  */
-      if (d->staticpattern)
-        {
-          char *o = variable_expand ("");
-          o = subst_expand (o, name, "%", "$*", 1, 2, 0);
-          *o = '\0';
-          free (name);
-          d->name = name = xstrdup (variable_buffer);
-          d->staticpattern = 0;
-        }
-
-      /* We're going to do second expansion so initialize file variables for
-         the file. Since the stem for static pattern rules comes from
-         individual dep lines, we will temporarily set f->stem to d->stem.  */
-      if (!initialized)
-        {
-          initialize_file_variables (f, 0);
-          initialized = 1;
-        }
-
-      if (d->stem != 0)
-        f->stem = d->stem;
-
-      set_file_variables (f);
-
-      p = variable_expand_for_file (d->name, f);
-
-      if (d->stem != 0)
-        f->stem = file_stem;
-
-      /* At this point we don't need the name anymore: free it.  */
-      free (name);
-
-      /* Parse the prerequisites and enter them into the file database.  */
-      new = enter_prereqs (split_prereqs (p), d->stem);
-
-      /* If there were no prereqs here (blank!) then throw this one out.  */
-      if (new == 0)
-        {
-          *dp = d->next;
-          free_dep (d);
-          d = *dp;
-          continue;
-        }
-
-      /* Add newly parsed prerequisites.  */
-      next = d->next;
-      *dp = new;
-      for (dp = &new->next, d = new->next; d != 0; dp = &d->next, d = d->next)
-        ;
-      *dp = next;
-      d = *dp;
-    }
-}
-
-/* Reset the updating flag.  */
-
-static void
-reset_updating (const void *item)
-{
-  struct file *f = (struct file *) item;
-  f->updating = 0;
-}
-
-/* For each dependency of each file, make the 'struct dep' point
-   at the appropriate 'struct file' (which may have to be created).
-
-   Also mark the files depended on by .PRECIOUS, .PHONY, .SILENT,
-   and various other special targets.  */
-
-void
-snap_deps (void)
-{
-  struct file *f;
-  struct file *f2;
-  struct dep *d;
-
-  /* Remember that we've done this.  Once we start snapping deps we can no
-     longer define new targets.  */
-  snapped_deps = 1;
-
-  /* Perform second expansion and enter each dependency name as a file.  We
-     must use hash_dump() here because within these loops we likely add new
-     files to the table, possibly causing an in-situ table expansion.
-
-     We only need to do this if second_expansion has been defined; if it
-     hasn't then all deps were expanded as the makefile was read in.  If we
-     ever change make to be able to unset .SECONDARY_EXPANSION this will have
-     to change.  */
-
-  if (second_expansion)
-    {
-      struct file **file_slot_0 = (struct file **) hash_dump (&files, 0, 0);
-      struct file **file_end = file_slot_0 + files.ht_fill;
-      struct file **file_slot;
-      const char *suffixes;
-
-      /* Expand .SUFFIXES: its prerequisites are used for $$* calc.  */
-      f = lookup_file (".SUFFIXES");
-      suffixes = f ? f->name : 0;
-      for (; f != 0; f = f->prev)
-        expand_deps (f);
-
-      /* For every target that's not .SUFFIXES, expand its prerequisites.  */
-
-      for (file_slot = file_slot_0; file_slot < file_end; file_slot++)
-        for (f = *file_slot; f != 0; f = f->prev)
-          if (f->name != suffixes)
-            expand_deps (f);
-      free (file_slot_0);
-    }
-  else
-    /* We're not doing second expansion, so reset updating.  */
-    hash_map (&files, reset_updating);
-
-  /* Now manage all the special targets.  */
-
-  for (f = lookup_file (".PRECIOUS"); f != 0; f = f->prev)
-    for (d = f->deps; d != 0; d = d->next)
-      for (f2 = d->file; f2 != 0; f2 = f2->prev)
-        f2->precious = 1;
-
-  for (f = lookup_file (".LOW_RESOLUTION_TIME"); f != 0; f = f->prev)
-    for (d = f->deps; d != 0; d = d->next)
-      for (f2 = d->file; f2 != 0; f2 = f2->prev)
-        f2->low_resolution_time = 1;
-
-  for (f = lookup_file (".PHONY"); f != 0; f = f->prev)
-    for (d = f->deps; d != 0; d = d->next)
-      for (f2 = d->file; f2 != 0; f2 = f2->prev)
-        {
-          /* Mark this file as phony nonexistent target.  */
-          f2->phony = 1;
-          f2->is_target = 1;
-          f2->last_mtime = NONEXISTENT_MTIME;
-          f2->mtime_before_update = NONEXISTENT_MTIME;
-        }
-
-  for (f = lookup_file (".INTERMEDIATE"); f != 0; f = f->prev)
-    /* Mark .INTERMEDIATE deps as intermediate files.  */
-    for (d = f->deps; d != 0; d = d->next)
-      for (f2 = d->file; f2 != 0; f2 = f2->prev)
-        f2->intermediate = 1;
-    /* .INTERMEDIATE with no deps does nothing.
-       Marking all files as intermediates is useless since the goal targets
-       would be deleted after they are built.  */
-
-  for (f = lookup_file (".SECONDARY"); f != 0; f = f->prev)
-    /* Mark .SECONDARY deps as both intermediate and secondary.  */
-    if (f->deps)
-      for (d = f->deps; d != 0; d = d->next)
-        for (f2 = d->file; f2 != 0; f2 = f2->prev)
-          f2->intermediate = f2->secondary = 1;
-    /* .SECONDARY with no deps listed marks *all* files that way.  */
-    else
-      {
-        all_secondary = 1;
-        hash_map (&files, set_intermediate);
-      }
-
-  f = lookup_file (".EXPORT_ALL_VARIABLES");
-  if (f != 0 && f->is_target)
-    export_all_variables = 1;
-
-  f = lookup_file (".IGNORE");
-  if (f != 0 && f->is_target)
-    {
-      if (f->deps == 0)
-        ignore_errors_flag = 1;
-      else
-        for (d = f->deps; d != 0; d = d->next)
-          for (f2 = d->file; f2 != 0; f2 = f2->prev)
-            f2->command_flags |= COMMANDS_NOERROR;
-    }
-
-  f = lookup_file (".SILENT");
-  if (f != 0 && f->is_target)
-    {
-      if (f->deps == 0)
-        silent_flag = 1;
-      else
-        for (d = f->deps; d != 0; d = d->next)
-          for (f2 = d->file; f2 != 0; f2 = f2->prev)
-            f2->command_flags |= COMMANDS_SILENT;
-    }
-
-  f = lookup_file (".NOTPARALLEL");
-  if (f != 0 && f->is_target)
-    not_parallel = 1;
-
-#ifndef NO_MINUS_C_MINUS_O
-  /* If .POSIX was defined, remove OUTPUT_OPTION to comply.  */
-  /* This needs more work: what if the user sets this in the makefile?
-  if (posix_pedantic)
-    define_variable_cname ("OUTPUT_OPTION", "", o_default, 1);
-  */
-#endif
-}
-
-/* Set the 'command_state' member of FILE and all its 'also_make's.  */
-
-void
-set_command_state (struct file *file, enum cmd_state state)
-{
-  struct dep *d;
-
-  file->command_state = state;
-
-  for (d = file->also_make; d != 0; d = d->next)
-    d->file->command_state = state;
-}
-
-/* Convert an external file timestamp to internal form.  */
-
-FILE_TIMESTAMP
-file_timestamp_cons (const char *fname, time_t stamp, long int ns)
-{
-  int offset = ORDINARY_MTIME_MIN + (FILE_TIMESTAMP_HI_RES ? ns : 0);
-  FILE_TIMESTAMP s = stamp;
-  FILE_TIMESTAMP product = (FILE_TIMESTAMP) s << FILE_TIMESTAMP_LO_BITS;
-  FILE_TIMESTAMP ts = product + offset;
-
-  if (! (s <= FILE_TIMESTAMP_S (ORDINARY_MTIME_MAX)
-         && product <= ts && ts <= ORDINARY_MTIME_MAX))
-    {
-      char buf[FILE_TIMESTAMP_PRINT_LEN_BOUND + 1];
-      const char *f = fname ? fname : _("Current time");
-      ts = s <= OLD_MTIME ? ORDINARY_MTIME_MIN : ORDINARY_MTIME_MAX;
-      file_timestamp_sprintf (buf, ts);
-      OSS (error, NILF,
-           _("%s: Timestamp out of range; substituting %s"), f, buf);
-    }
-
-  return ts;
-}
-
-/* Return the current time as a file timestamp, setting *RESOLUTION to
-   its resolution.  */
-FILE_TIMESTAMP
-file_timestamp_now (int *resolution)
-{
-  int r;
-  time_t s;
-  int ns;
-
-  /* Don't bother with high-resolution clocks if file timestamps have
-     only one-second resolution.  The code below should work, but it's
-     not worth the hassle of debugging it on hosts where it fails.  */
-#if FILE_TIMESTAMP_HI_RES
-# if HAVE_CLOCK_GETTIME && defined CLOCK_REALTIME
-  {
-    struct timespec timespec;
-    if (clock_gettime (CLOCK_REALTIME, &timespec) == 0)
-      {
-        r = 1;
-        s = timespec.tv_sec;
-        ns = timespec.tv_nsec;
-        goto got_time;
-      }
-  }
-# endif
-# if HAVE_GETTIMEOFDAY
-  {
-    struct timeval timeval;
-    if (gettimeofday (&timeval, 0) == 0)
-      {
-        r = 1000;
-        s = timeval.tv_sec;
-        ns = timeval.tv_usec * 1000;
-        goto got_time;
-      }
-  }
-# endif
-#endif
-
-  r = 1000000000;
-  s = time ((time_t *) 0);
-  ns = 0;
-
-#if FILE_TIMESTAMP_HI_RES
- got_time:
-#endif
-  *resolution = r;
-  return file_timestamp_cons (0, s, ns);
-}
-
-/* Place into the buffer P a printable representation of the file
-   timestamp TS.  */
-void
-file_timestamp_sprintf (char *p, FILE_TIMESTAMP ts)
-{
-  time_t t = FILE_TIMESTAMP_S (ts);
-  struct tm *tm = localtime (&t);
-
-  if (tm)
-    sprintf (p, "%04d-%02d-%02d %02d:%02d:%02d",
-             tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
-             tm->tm_hour, tm->tm_min, tm->tm_sec);
-  else if (t < 0)
-    sprintf (p, "%ld", (long) t);
-  else
-    sprintf (p, "%lu", (unsigned long) t);
-  p += strlen (p);
-
-  /* Append nanoseconds as a fraction, but remove trailing zeros.  We don't
-     know the actual timestamp resolution, since clock_getres applies only to
-     local times, whereas this timestamp might come from a remote filesystem.
-     So removing trailing zeros is the best guess that we can do.  */
-  sprintf (p, ".%09d", FILE_TIMESTAMP_NS (ts));
-  p += strlen (p) - 1;
-  while (*p == '0')
-    p--;
-  p += *p != '.';
-
-  *p = '\0';
-}
-
-/* Print the data base of files.  */
-
-void
-print_prereqs (const struct dep *deps)
-{
-  const struct dep *ood = 0;
-
-  /* Print all normal dependencies; note any order-only deps.  */
-  for (; deps != 0; deps = deps->next)
-    if (! deps->ignore_mtime)
-      printf (" %s", dep_name (deps));
-    else if (! ood)
-      ood = deps;
-
-  /* Print order-only deps, if we have any.  */
-  if (ood)
-    {
-      printf (" | %s", dep_name (ood));
-      for (ood = ood->next; ood != 0; ood = ood->next)
-        if (ood->ignore_mtime)
-          printf (" %s", dep_name (ood));
-    }
-
-  putchar ('\n');
-}
-
-static void
-print_file (const void *item)
-{
-  const struct file *f = item;
-
-  /* If we're not using builtin targets, don't show them.
-
-     Ideally we'd be able to delete them altogether but currently there's no
-     facility to ever delete a file once it's been added.  */
-  if (no_builtin_rules_flag && f->builtin)
-    return;
-
-  putchar ('\n');
-
-  if (f->cmds && f->cmds->recipe_prefix != cmd_prefix)
-    {
-      fputs (".RECIPEPREFIX = ", stdout);
-      cmd_prefix = f->cmds->recipe_prefix;
-      if (cmd_prefix != RECIPEPREFIX_DEFAULT)
-        putchar (cmd_prefix);
-      putchar ('\n');
-    }
-
-  if (f->variables != 0)
-    print_target_variables (f);
-
-  if (!f->is_target)
-    puts (_("# Not a target:"));
-  printf ("%s:%s", f->name, f->double_colon ? ":" : "");
-  print_prereqs (f->deps);
-
-  if (f->precious)
-    puts (_("#  Precious file (prerequisite of .PRECIOUS)."));
-  if (f->phony)
-    puts (_("#  Phony target (prerequisite of .PHONY)."));
-  if (f->cmd_target)
-    puts (_("#  Command line target."));
-  if (f->dontcare)
-    puts (_("#  A default, MAKEFILES, or -include/sinclude makefile."));
-  if (f->builtin)
-    puts (_("#  Builtin rule"));
-  puts (f->tried_implicit
-        ? _("#  Implicit rule search has been done.")
-        : _("#  Implicit rule search has not been done."));
-  if (f->stem != 0)
-    printf (_("#  Implicit/static pattern stem: '%s'\n"), f->stem);
-  if (f->intermediate)
-    puts (_("#  File is an intermediate prerequisite."));
-  if (f->also_make != 0)
-    {
-      const struct dep *d;
-      fputs (_("#  Also makes:"), stdout);
-      for (d = f->also_make; d != 0; d = d->next)
-        printf (" %s", dep_name (d));
-      putchar ('\n');
-    }
-  if (f->last_mtime == UNKNOWN_MTIME)
-    puts (_("#  Modification time never checked."));
-  else if (f->last_mtime == NONEXISTENT_MTIME)
-    puts (_("#  File does not exist."));
-  else if (f->last_mtime == OLD_MTIME)
-    puts (_("#  File is very old."));
-  else
-    {
-      char buf[FILE_TIMESTAMP_PRINT_LEN_BOUND + 1];
-      file_timestamp_sprintf (buf, f->last_mtime);
-      printf (_("#  Last modified %s\n"), buf);
-    }
-  puts (f->updated
-        ? _("#  File has been updated.") : _("#  File has not been updated."));
-  switch (f->command_state)
-    {
-    case cs_running:
-      puts (_("#  Recipe currently running (THIS IS A BUG)."));
-      break;
-    case cs_deps_running:
-      puts (_("#  Dependencies recipe running (THIS IS A BUG)."));
-      break;
-    case cs_not_started:
-    case cs_finished:
-      switch (f->update_status)
-        {
-        case us_none:
-          break;
-        case us_success:
-          puts (_("#  Successfully updated."));
-          break;
-        case us_question:
-          assert (question_flag);
-          puts (_("#  Needs to be updated (-q is set)."));
-          break;
-        case us_failed:
-          puts (_("#  Failed to be updated."));
-          break;
-        }
-      break;
-    default:
-      puts (_("#  Invalid value in 'command_state' member!"));
-      fflush (stdout);
-      fflush (stderr);
-      abort ();
-    }
-
-  if (f->variables != 0)
-    print_file_variables (f);
-
-  if (f->cmds != 0)
-    print_commands (f->cmds);
-
-  if (f->prev)
-    print_file ((const void *) f->prev);
-}
-
-void
-print_file_data_base (void)
-{
-  puts (_("\n# Files"));
-
-  hash_map (&files, print_file);
-
-  fputs (_("\n# files hash-table stats:\n# "), stdout);
-  hash_print_stats (&files, stdout);
-}
-
-/* Verify the integrity of the data base of files.  */
-
-#define VERIFY_CACHED(_p,_n) \
-    do{                                                                       \
-        if (_p->_n && _p->_n[0] && !strcache_iscached (_p->_n))               \
-          error (NULL, strlen (_p->name) + CSTRLEN (# _n) + strlen (_p->_n),  \
-                 _("%s: Field '%s' not cached: %s"), _p->name, # _n, _p->_n); \
-    }while(0)
-
-static void
-verify_file (const void *item)
-{
-  const struct file *f = item;
-  const struct dep *d;
-
-  VERIFY_CACHED (f, name);
-  VERIFY_CACHED (f, hname);
-  VERIFY_CACHED (f, vpath);
-  VERIFY_CACHED (f, stem);
-
-  /* Check the deps.  */
-  for (d = f->deps; d != 0; d = d->next)
-    {
-      if (! d->need_2nd_expansion)
-        VERIFY_CACHED (d, name);
-      VERIFY_CACHED (d, stem);
-    }
-}
-
-void
-verify_file_data_base (void)
-{
-  hash_map (&files, verify_file);
-}
-
-#define EXPANSION_INCREMENT(_l)  ((((_l) / 500) + 1) * 500)
-
-char *
-build_target_list (char *value)
-{
-  static unsigned long last_targ_count = 0;
-
-  if (files.ht_fill != last_targ_count)
-    {
-      unsigned long max = EXPANSION_INCREMENT (strlen (value));
-      unsigned long len;
-      char *p;
-      struct file **fp = (struct file **) files.ht_vec;
-      struct file **end = &fp[files.ht_size];
-
-      /* Make sure we have at least MAX bytes in the allocated buffer.  */
-      value = xrealloc (value, max);
-
-      p = value;
-      len = 0;
-      for (; fp < end; ++fp)
-        if (!HASH_VACANT (*fp) && (*fp)->is_target)
-          {
-            struct file *f = *fp;
-            int l = strlen (f->name);
-
-            len += l + 1;
-            if (len > max)
-              {
-                unsigned long off = p - value;
-
-                max += EXPANSION_INCREMENT (l + 1);
-                value = xrealloc (value, max);
-                p = &value[off];
-              }
-
-            memcpy (p, f->name, l);
-            p += l;
-            *(p++) = ' ';
-          }
-      *(p-1) = '\0';
-
-      last_targ_count = files.ht_fill;
-    }
-
-  return value;
-}
-
-void
-init_hash_files (void)
-{
-  hash_init (&files, 1000, file_hash_1, file_hash_2, file_hash_cmp);
-}
-
-/* EOF */
diff --git a/filedef.h b/filedef.h
deleted file mode 100644
index 7de6ac0..0000000
--- a/filedef.h
+++ /dev/null
@@ -1,212 +0,0 @@
-/* Definition of target file data structures for GNU Make.
-Copyright (C) 1988-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-
-/* Structure that represents the info on one file
-   that the makefile says how to make.
-   All of these are chained together through 'next'.  */
-
-#include "hash.h"
-
-struct file
-  {
-    const char *name;
-    const char *hname;          /* Hashed filename */
-    const char *vpath;          /* VPATH/vpath pathname */
-    struct dep *deps;           /* all dependencies, including duplicates */
-    struct commands *cmds;      /* Commands to execute for this target.  */
-    const char *stem;           /* Implicit stem, if an implicit
-                                   rule has been used */
-    struct dep *also_make;      /* Targets that are made by making this.  */
-    struct file *prev;          /* Previous entry for same file name;
-                                   used when there are multiple double-colon
-                                   entries for the same file.  */
-    struct file *last;          /* Last entry for the same file name.  */
-
-    /* File that this file was renamed to.  After any time that a
-       file could be renamed, call 'check_renamed' (below).  */
-    struct file *renamed;
-
-    /* List of variable sets used for this file.  */
-    struct variable_set_list *variables;
-
-    /* Pattern-specific variable reference for this target, or null if there
-       isn't one.  Also see the pat_searched flag, below.  */
-    struct variable_set_list *pat_variables;
-
-    /* Immediate dependent that caused this target to be remade,
-       or nil if there isn't one.  */
-    struct file *parent;
-
-    /* For a double-colon entry, this is the first double-colon entry for
-       the same file.  Otherwise this is null.  */
-    struct file *double_colon;
-
-    FILE_TIMESTAMP last_mtime;  /* File's modtime, if already known.  */
-    FILE_TIMESTAMP mtime_before_update; /* File's modtime before any updating
-                                           has been performed.  */
-    unsigned int considered;    /* equal to 'considered' if file has been
-                                   considered on current scan of goal chain */
-    int command_flags;          /* Flags OR'd in for cmds; see commands.h.  */
-    enum update_status          /* Status of the last attempt to update.  */
-      {
-        us_success = 0,         /* Successfully updated.  Must be 0!  */
-        us_none,                /* No attempt to update has been made.  */
-        us_question,            /* Needs to be updated (-q is is set).  */
-        us_failed               /* Update failed.  */
-      } update_status ENUM_BITFIELD (2);
-    enum cmd_state              /* State of the commands.  */
-      {
-        cs_not_started = 0,     /* Not yet started.  Must be 0!  */
-        cs_deps_running,        /* Dep commands running.  */
-        cs_running,             /* Commands running.  */
-        cs_finished             /* Commands finished.  */
-      } command_state ENUM_BITFIELD (2);
-
-    unsigned int builtin:1;     /* True if the file is a builtin rule. */
-    unsigned int precious:1;    /* Non-0 means don't delete file on quit */
-    unsigned int loaded:1;      /* True if the file is a loaded object. */
-    unsigned int low_resolution_time:1; /* Nonzero if this file's time stamp
-                                           has only one-second resolution.  */
-    unsigned int tried_implicit:1; /* Nonzero if have searched
-                                      for implicit rule for making
-                                      this file; don't search again.  */
-    unsigned int updating:1;    /* Nonzero while updating deps of this file */
-    unsigned int updated:1;     /* Nonzero if this file has been remade.  */
-    unsigned int is_target:1;   /* Nonzero if file is described as target.  */
-    unsigned int cmd_target:1;  /* Nonzero if file was given on cmd line.  */
-    unsigned int phony:1;       /* Nonzero if this is a phony file
-                                   i.e., a prerequisite of .PHONY.  */
-    unsigned int intermediate:1;/* Nonzero if this is an intermediate file.  */
-    unsigned int secondary:1;   /* Nonzero means remove_intermediates should
-                                   not delete it.  */
-    unsigned int dontcare:1;    /* Nonzero if no complaint is to be made if
-                                   this target cannot be remade.  */
-    unsigned int ignore_vpath:1;/* Nonzero if we threw out VPATH name.  */
-    unsigned int pat_searched:1;/* Nonzero if we already searched for
-                                   pattern-specific variables.  */
-    unsigned int no_diag:1;     /* True if the file failed to update and no
-                                   diagnostics has been issued (dontcare). */
-  };
-
-
-extern struct file *default_file;
-
-
-struct file *lookup_file (const char *name);
-struct file *enter_file (const char *name);
-struct dep *split_prereqs (char *prereqstr);
-struct dep *enter_prereqs (struct dep *prereqs, const char *stem);
-void remove_intermediates (int sig);
-void snap_deps (void);
-void rename_file (struct file *file, const char *name);
-void rehash_file (struct file *file, const char *name);
-void set_command_state (struct file *file, enum cmd_state state);
-void notice_finished_file (struct file *file);
-void init_hash_files (void);
-void verify_file_data_base (void);
-char *build_target_list (char *old_list);
-void print_prereqs (const struct dep *deps);
-void print_file_data_base (void);
-int try_implicit_rule (struct file *file, unsigned int depth);
-int stemlen_compare (const void *v1, const void *v2);
-
-#if FILE_TIMESTAMP_HI_RES
-# define FILE_TIMESTAMP_STAT_MODTIME(fname, st) \
-    file_timestamp_cons (fname, (st).st_mtime, (st).ST_MTIM_NSEC)
-#else
-# define FILE_TIMESTAMP_STAT_MODTIME(fname, st) \
-    file_timestamp_cons (fname, (st).st_mtime, 0)
-#endif
-
-/* If FILE_TIMESTAMP is 64 bits (or more), use nanosecond resolution.
-   (Multiply by 2**30 instead of by 10**9 to save time at the cost of
-   slightly decreasing the number of available timestamps.)  With
-   64-bit FILE_TIMESTAMP, this stops working on 2514-05-30 01:53:04
-   UTC, but by then uintmax_t should be larger than 64 bits.  */
-#define FILE_TIMESTAMPS_PER_S (FILE_TIMESTAMP_HI_RES ? 1000000000 : 1)
-#define FILE_TIMESTAMP_LO_BITS (FILE_TIMESTAMP_HI_RES ? 30 : 0)
-
-#define FILE_TIMESTAMP_S(ts) (((ts) - ORDINARY_MTIME_MIN) \
-                              >> FILE_TIMESTAMP_LO_BITS)
-#define FILE_TIMESTAMP_NS(ts) ((int) (((ts) - ORDINARY_MTIME_MIN) \
-                                      & ((1 << FILE_TIMESTAMP_LO_BITS) - 1)))
-
-/* Upper bound on length of string "YYYY-MM-DD HH:MM:SS.NNNNNNNNN"
-   representing a file timestamp.  The upper bound is not necessarily 29,
-   since the year might be less than -999 or greater than 9999.
-
-   Subtract one for the sign bit if in case file timestamps can be negative;
-   subtract FLOOR_LOG2_SECONDS_PER_YEAR to yield an upper bound on how many
-   file timestamp bits might affect the year;
-   302 / 1000 is log10 (2) rounded up;
-   add one for integer division truncation;
-   add one more for a minus sign if file timestamps can be negative;
-   add 4 to allow for any 4-digit epoch year (e.g. 1970);
-   add 25 to allow for "-MM-DD HH:MM:SS.NNNNNNNNN".  */
-#define FLOOR_LOG2_SECONDS_PER_YEAR 24
-#define FILE_TIMESTAMP_PRINT_LEN_BOUND \
-  (((sizeof (FILE_TIMESTAMP) * CHAR_BIT - 1 - FLOOR_LOG2_SECONDS_PER_YEAR) \
-    * 302 / 1000) \
-   + 1 + 1 + 4 + 25)
-
-FILE_TIMESTAMP file_timestamp_cons (char const *, time_t, long int);
-FILE_TIMESTAMP file_timestamp_now (int *);
-void file_timestamp_sprintf (char *p, FILE_TIMESTAMP ts);
-
-/* Return the mtime of file F (a struct file *), caching it.
-   The value is NONEXISTENT_MTIME if the file does not exist.  */
-#define file_mtime(f) file_mtime_1 ((f), 1)
-/* Return the mtime of file F (a struct file *), caching it.
-   Don't search using vpath for the file--if it doesn't actually exist,
-   we don't find it.
-   The value is NONEXISTENT_MTIME if the file does not exist.  */
-#define file_mtime_no_search(f) file_mtime_1 ((f), 0)
-FILE_TIMESTAMP f_mtime (struct file *file, int search);
-#define file_mtime_1(f, v) \
-  ((f)->last_mtime == UNKNOWN_MTIME ? f_mtime ((f), v) : (f)->last_mtime)
-
-/* Special timestamp values.  */
-
-/* The file's timestamp is not yet known.  */
-#define UNKNOWN_MTIME 0
-
-/* The file does not exist.  */
-#define NONEXISTENT_MTIME 1
-
-/* The file does not exist, and we assume that it is older than any
-   actual file.  */
-#define OLD_MTIME 2
-
-/* The smallest and largest ordinary timestamps.  */
-#define ORDINARY_MTIME_MIN (OLD_MTIME + 1)
-#define ORDINARY_MTIME_MAX ((FILE_TIMESTAMP_S (NEW_MTIME) \
-                             << FILE_TIMESTAMP_LO_BITS) \
-                            + ORDINARY_MTIME_MIN + FILE_TIMESTAMPS_PER_S - 1)
-
-/* Modtime value to use for 'infinitely new'.  We used to get the current time
-   from the system and use that whenever we wanted 'new'.  But that causes
-   trouble when the machine running make and the machine holding a file have
-   different ideas about what time it is; and can also lose for 'force'
-   targets, which need to be considered newer than anything that depends on
-   them, even if said dependents' modtimes are in the future.  */
-#define NEW_MTIME INTEGER_TYPE_MAXIMUM (FILE_TIMESTAMP)
-
-#define check_renamed(file) \
-  while ((file)->renamed != 0) (file) = (file)->renamed /* No ; here.  */
-
-/* Have we snapped deps yet?  */
-extern int snapped_deps;
diff --git a/function.c b/function.c
deleted file mode 100644
index a22352f..0000000
--- a/function.c
+++ /dev/null
@@ -1,2691 +0,0 @@
-/* Builtin function expansion for GNU Make.
-Copyright (C) 1988-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-#include "filedef.h"
-#include "variable.h"
-#include "dep.h"
-#include "job.h"
-#include "os.h"
-#include "commands.h"
-#include "debug.h"
-
-#ifdef _AMIGA
-#include "amiga.h"
-#endif
-
-
-struct function_table_entry
-  {
-    union {
-      char *(*func_ptr) (char *output, char **argv, const char *fname);
-      gmk_func_ptr alloc_func_ptr;
-    } fptr;
-    const char *name;
-    unsigned char len;
-    unsigned char minimum_args;
-    unsigned char maximum_args;
-    unsigned char expand_args:1;
-    unsigned char alloc_fn:1;
-  };
-
-static unsigned long
-function_table_entry_hash_1 (const void *keyv)
-{
-  const struct function_table_entry *key = keyv;
-  return_STRING_N_HASH_1 (key->name, key->len);
-}
-
-static unsigned long
-function_table_entry_hash_2 (const void *keyv)
-{
-  const struct function_table_entry *key = keyv;
-  return_STRING_N_HASH_2 (key->name, key->len);
-}
-
-static int
-function_table_entry_hash_cmp (const void *xv, const void *yv)
-{
-  const struct function_table_entry *x = xv;
-  const struct function_table_entry *y = yv;
-  int result = x->len - y->len;
-  if (result)
-    return result;
-  return_STRING_N_COMPARE (x->name, y->name, x->len);
-}
-
-static struct hash_table function_table;
-
-
-/* Store into VARIABLE_BUFFER at O the result of scanning TEXT and replacing
-   each occurrence of SUBST with REPLACE. TEXT is null-terminated.  SLEN is
-   the length of SUBST and RLEN is the length of REPLACE.  If BY_WORD is
-   nonzero, substitutions are done only on matches which are complete
-   whitespace-delimited words.  */
-
-char *
-subst_expand (char *o, const char *text, const char *subst, const char *replace,
-              unsigned int slen, unsigned int rlen, int by_word)
-{
-  const char *t = text;
-  const char *p;
-
-  if (slen == 0 && !by_word)
-    {
-      /* The first occurrence of "" in any string is its end.  */
-      o = variable_buffer_output (o, t, strlen (t));
-      if (rlen > 0)
-        o = variable_buffer_output (o, replace, rlen);
-      return o;
-    }
-
-  do
-    {
-      if (by_word && slen == 0)
-        /* When matching by words, the empty string should match
-           the end of each word, rather than the end of the whole text.  */
-        p = end_of_token (next_token (t));
-      else
-        {
-          p = strstr (t, subst);
-          if (p == 0)
-            {
-              /* No more matches.  Output everything left on the end.  */
-              o = variable_buffer_output (o, t, strlen (t));
-              return o;
-            }
-        }
-
-      /* Output everything before this occurrence of the string to replace.  */
-      if (p > t)
-        o = variable_buffer_output (o, t, p - t);
-
-      /* If we're substituting only by fully matched words,
-         or only at the ends of words, check that this case qualifies.  */
-      if (by_word
-          && ((p > text && !ISSPACE (p[-1]))
-              || ! STOP_SET (p[slen], MAP_SPACE|MAP_NUL)))
-        /* Struck out.  Output the rest of the string that is
-           no longer to be replaced.  */
-        o = variable_buffer_output (o, subst, slen);
-      else if (rlen > 0)
-        /* Output the replacement string.  */
-        o = variable_buffer_output (o, replace, rlen);
-
-      /* Advance T past the string to be replaced.  */
-      t = p + slen;
-    } while (*t != '\0');
-
-  return o;
-}
-
-
-/* Store into VARIABLE_BUFFER at O the result of scanning TEXT
-   and replacing strings matching PATTERN with REPLACE.
-   If PATTERN_PERCENT is not nil, PATTERN has already been
-   run through find_percent, and PATTERN_PERCENT is the result.
-   If REPLACE_PERCENT is not nil, REPLACE has already been
-   run through find_percent, and REPLACE_PERCENT is the result.
-   Note that we expect PATTERN_PERCENT and REPLACE_PERCENT to point to the
-   character _AFTER_ the %, not to the % itself.
-*/
-
-char *
-patsubst_expand_pat (char *o, const char *text,
-                     const char *pattern, const char *replace,
-                     const char *pattern_percent, const char *replace_percent)
-{
-  unsigned int pattern_prepercent_len, pattern_postpercent_len;
-  unsigned int replace_prepercent_len, replace_postpercent_len;
-  const char *t;
-  unsigned int len;
-  int doneany = 0;
-
-  /* Record the length of REPLACE before and after the % so we don't have to
-     compute these lengths more than once.  */
-  if (replace_percent)
-    {
-      replace_prepercent_len = replace_percent - replace - 1;
-      replace_postpercent_len = strlen (replace_percent);
-    }
-  else
-    {
-      replace_prepercent_len = strlen (replace);
-      replace_postpercent_len = 0;
-    }
-
-  if (!pattern_percent)
-    /* With no % in the pattern, this is just a simple substitution.  */
-    return subst_expand (o, text, pattern, replace,
-                         strlen (pattern), strlen (replace), 1);
-
-  /* Record the length of PATTERN before and after the %
-     so we don't have to compute it more than once.  */
-  pattern_prepercent_len = pattern_percent - pattern - 1;
-  pattern_postpercent_len = strlen (pattern_percent);
-
-  while ((t = find_next_token (&text, &len)) != 0)
-    {
-      int fail = 0;
-
-      /* Is it big enough to match?  */
-      if (len < pattern_prepercent_len + pattern_postpercent_len)
-        fail = 1;
-
-      /* Does the prefix match? */
-      if (!fail && pattern_prepercent_len > 0
-          && (*t != *pattern
-              || t[pattern_prepercent_len - 1] != pattern_percent[-2]
-              || !strneq (t + 1, pattern + 1, pattern_prepercent_len - 1)))
-        fail = 1;
-
-      /* Does the suffix match? */
-      if (!fail && pattern_postpercent_len > 0
-          && (t[len - 1] != pattern_percent[pattern_postpercent_len - 1]
-              || t[len - pattern_postpercent_len] != *pattern_percent
-              || !strneq (&t[len - pattern_postpercent_len],
-                          pattern_percent, pattern_postpercent_len - 1)))
-        fail = 1;
-
-      if (fail)
-        /* It didn't match.  Output the string.  */
-        o = variable_buffer_output (o, t, len);
-      else
-        {
-          /* It matched.  Output the replacement.  */
-
-          /* Output the part of the replacement before the %.  */
-          o = variable_buffer_output (o, replace, replace_prepercent_len);
-
-          if (replace_percent != 0)
-            {
-              /* Output the part of the matched string that
-                 matched the % in the pattern.  */
-              o = variable_buffer_output (o, t + pattern_prepercent_len,
-                                          len - (pattern_prepercent_len
-                                                 + pattern_postpercent_len));
-              /* Output the part of the replacement after the %.  */
-              o = variable_buffer_output (o, replace_percent,
-                                          replace_postpercent_len);
-            }
-        }
-
-      /* Output a space, but not if the replacement is "".  */
-      if (fail || replace_prepercent_len > 0
-          || (replace_percent != 0 && len + replace_postpercent_len > 0))
-        {
-          o = variable_buffer_output (o, " ", 1);
-          doneany = 1;
-        }
-    }
-  if (doneany)
-    /* Kill the last space.  */
-    --o;
-
-  return o;
-}
-
-/* Store into VARIABLE_BUFFER at O the result of scanning TEXT
-   and replacing strings matching PATTERN with REPLACE.
-   If PATTERN_PERCENT is not nil, PATTERN has already been
-   run through find_percent, and PATTERN_PERCENT is the result.
-   If REPLACE_PERCENT is not nil, REPLACE has already been
-   run through find_percent, and REPLACE_PERCENT is the result.
-   Note that we expect PATTERN_PERCENT and REPLACE_PERCENT to point to the
-   character _AFTER_ the %, not to the % itself.
-*/
-
-char *
-patsubst_expand (char *o, const char *text, char *pattern, char *replace)
-{
-  const char *pattern_percent = find_percent (pattern);
-  const char *replace_percent = find_percent (replace);
-
-  /* If there's a percent in the pattern or replacement skip it.  */
-  if (replace_percent)
-    ++replace_percent;
-  if (pattern_percent)
-    ++pattern_percent;
-
-  return patsubst_expand_pat (o, text, pattern, replace,
-                              pattern_percent, replace_percent);
-}
-
-
-/* Look up a function by name.  */
-
-static const struct function_table_entry *
-lookup_function (const char *s)
-{
-  struct function_table_entry function_table_entry_key;
-  const char *e = s;
-
-  while (STOP_SET (*e, MAP_USERFUNC))
-    e++;
-
-  if (e == s || !STOP_SET(*e, MAP_NUL|MAP_SPACE))
-    return NULL;
-
-  function_table_entry_key.name = s;
-  function_table_entry_key.len = e - s;
-
-  return hash_find_item (&function_table, &function_table_entry_key);
-}
-
-
-/* Return 1 if PATTERN matches STR, 0 if not.  */
-
-int
-pattern_matches (const char *pattern, const char *percent, const char *str)
-{
-  unsigned int sfxlen, strlength;
-
-  if (percent == 0)
-    {
-      unsigned int len = strlen (pattern) + 1;
-      char *new_chars = alloca (len);
-      memcpy (new_chars, pattern, len);
-      percent = find_percent (new_chars);
-      if (percent == 0)
-        return streq (new_chars, str);
-      pattern = new_chars;
-    }
-
-  sfxlen = strlen (percent + 1);
-  strlength = strlen (str);
-
-  if (strlength < (percent - pattern) + sfxlen
-      || !strneq (pattern, str, percent - pattern))
-    return 0;
-
-  return !strcmp (percent + 1, str + (strlength - sfxlen));
-}
-
-
-/* Find the next comma or ENDPAREN (counting nested STARTPAREN and
-   ENDPARENtheses), starting at PTR before END.  Return a pointer to
-   next character.
-
-   If no next argument is found, return NULL.
-*/
-
-static char *
-find_next_argument (char startparen, char endparen,
-                    const char *ptr, const char *end)
-{
-  int count = 0;
-
-  for (; ptr < end; ++ptr)
-    if (!STOP_SET (*ptr, MAP_VARSEP|MAP_COMMA))
-      continue;
-
-    else if (*ptr == startparen)
-      ++count;
-
-    else if (*ptr == endparen)
-      {
-        --count;
-        if (count < 0)
-          return NULL;
-      }
-
-    else if (*ptr == ',' && !count)
-      return (char *)ptr;
-
-  /* We didn't find anything.  */
-  return NULL;
-}
-
-
-/* Glob-expand LINE.  The returned pointer is
-   only good until the next call to string_glob.  */
-
-static char *
-string_glob (char *line)
-{
-  static char *result = 0;
-  static unsigned int length;
-  struct nameseq *chain;
-  unsigned int idx;
-
-  chain = PARSE_FILE_SEQ (&line, struct nameseq, MAP_NUL, NULL,
-                          /* We do not want parse_file_seq to strip './'s.
-                             That would break examples like:
-                             $(patsubst ./%.c,obj/%.o,$(wildcard ./?*.c)).  */
-                          PARSEFS_NOSTRIP|PARSEFS_NOCACHE|PARSEFS_EXISTS);
-
-  if (result == 0)
-    {
-      length = 100;
-      result = xmalloc (100);
-    }
-
-  idx = 0;
-  while (chain != 0)
-    {
-      struct nameseq *next = chain->next;
-      unsigned int len = strlen (chain->name);
-
-      if (idx + len + 1 > length)
-        {
-          length += (len + 1) * 2;
-          result = xrealloc (result, length);
-        }
-      memcpy (&result[idx], chain->name, len);
-      idx += len;
-      result[idx++] = ' ';
-
-      /* Because we used PARSEFS_NOCACHE above, we have to free() NAME.  */
-      free ((char *)chain->name);
-      free (chain);
-      chain = next;
-    }
-
-  /* Kill the last space and terminate the string.  */
-  if (idx == 0)
-    result[0] = '\0';
-  else
-    result[idx - 1] = '\0';
-
-  return result;
-}
-
-/*
-  Builtin functions
- */
-
-static char *
-func_patsubst (char *o, char **argv, const char *funcname UNUSED)
-{
-  o = patsubst_expand (o, argv[2], argv[0], argv[1]);
-  return o;
-}
-
-
-static char *
-func_join (char *o, char **argv, const char *funcname UNUSED)
-{
-  int doneany = 0;
-
-  /* Write each word of the first argument directly followed
-     by the corresponding word of the second argument.
-     If the two arguments have a different number of words,
-     the excess words are just output separated by blanks.  */
-  const char *tp;
-  const char *pp;
-  const char *list1_iterator = argv[0];
-  const char *list2_iterator = argv[1];
-  do
-    {
-      unsigned int len1, len2;
-
-      tp = find_next_token (&list1_iterator, &len1);
-      if (tp != 0)
-        o = variable_buffer_output (o, tp, len1);
-
-      pp = find_next_token (&list2_iterator, &len2);
-      if (pp != 0)
-        o = variable_buffer_output (o, pp, len2);
-
-      if (tp != 0 || pp != 0)
-        {
-          o = variable_buffer_output (o, " ", 1);
-          doneany = 1;
-        }
-    }
-  while (tp != 0 || pp != 0);
-  if (doneany)
-    /* Kill the last blank.  */
-    --o;
-
-  return o;
-}
-
-
-static char *
-func_origin (char *o, char **argv, const char *funcname UNUSED)
-{
-  /* Expand the argument.  */
-  struct variable *v = lookup_variable (argv[0], strlen (argv[0]));
-  if (v == 0)
-    o = variable_buffer_output (o, "undefined", 9);
-  else
-    switch (v->origin)
-      {
-      default:
-      case o_invalid:
-        abort ();
-        break;
-      case o_default:
-        o = variable_buffer_output (o, "default", 7);
-        break;
-      case o_env:
-        o = variable_buffer_output (o, "environment", 11);
-        break;
-      case o_file:
-        o = variable_buffer_output (o, "file", 4);
-        break;
-      case o_env_override:
-        o = variable_buffer_output (o, "environment override", 20);
-        break;
-      case o_command:
-        o = variable_buffer_output (o, "command line", 12);
-        break;
-      case o_override:
-        o = variable_buffer_output (o, "override", 8);
-        break;
-      case o_automatic:
-        o = variable_buffer_output (o, "automatic", 9);
-        break;
-      }
-
-  return o;
-}
-
-static char *
-func_flavor (char *o, char **argv, const char *funcname UNUSED)
-{
-  struct variable *v = lookup_variable (argv[0], strlen (argv[0]));
-
-  if (v == 0)
-    o = variable_buffer_output (o, "undefined", 9);
-  else
-    if (v->recursive)
-      o = variable_buffer_output (o, "recursive", 9);
-    else
-      o = variable_buffer_output (o, "simple", 6);
-
-  return o;
-}
-
-
-static char *
-func_notdir_suffix (char *o, char **argv, const char *funcname)
-{
-  /* Expand the argument.  */
-  const char *list_iterator = argv[0];
-  const char *p2;
-  int doneany =0;
-  unsigned int len=0;
-
-  int is_suffix = funcname[0] == 's';
-  int is_notdir = !is_suffix;
-  int stop = MAP_DIRSEP | (is_suffix ? MAP_DOT : 0);
-#ifdef VMS
-  /* For VMS list_iterator points to a comma separated list. To use the common
-     [find_]next_token, create a local copy and replace the commas with
-     spaces. Obviously, there is a problem if there is a ',' in the VMS filename
-     (can only happen on ODS5), the same problem as with spaces in filenames,
-     which seems to be present in make on all platforms. */
-  char *vms_list_iterator = alloca(strlen(list_iterator) + 1);
-  int i;
-  for (i = 0; list_iterator[i]; i++)
-    if (list_iterator[i] == ',')
-      vms_list_iterator[i] = ' ';
-    else
-      vms_list_iterator[i] = list_iterator[i];
-  vms_list_iterator[i] = list_iterator[i];
-  while ((p2 = find_next_token((const char**) &vms_list_iterator, &len)) != 0)
-#else
-  while ((p2 = find_next_token (&list_iterator, &len)) != 0)
-#endif
-    {
-      const char *p = p2 + len - 1;
-
-      while (p >= p2 && ! STOP_SET (*p, stop))
-        --p;
-
-      if (p >= p2)
-        {
-          if (is_notdir)
-            ++p;
-          else if (*p != '.')
-            continue;
-          o = variable_buffer_output (o, p, len - (p - p2));
-        }
-#ifdef HAVE_DOS_PATHS
-      /* Handle the case of "d:foo/bar".  */
-      else if (is_notdir && p2[0] && p2[1] == ':')
-        {
-          p = p2 + 2;
-          o = variable_buffer_output (o, p, len - (p - p2));
-        }
-#endif
-      else if (is_notdir)
-        o = variable_buffer_output (o, p2, len);
-
-      if (is_notdir || p >= p2)
-        {
-#ifdef VMS
-          if (vms_comma_separator)
-            o = variable_buffer_output (o, ",", 1);
-          else
-#endif
-          o = variable_buffer_output (o, " ", 1);
-
-          doneany = 1;
-        }
-    }
-
-  if (doneany)
-    /* Kill last space.  */
-    --o;
-
-  return o;
-}
-
-
-static char *
-func_basename_dir (char *o, char **argv, const char *funcname)
-{
-  /* Expand the argument.  */
-  const char *p3 = argv[0];
-  const char *p2;
-  int doneany = 0;
-  unsigned int len = 0;
-
-  int is_basename = funcname[0] == 'b';
-  int is_dir = !is_basename;
-  int stop = MAP_DIRSEP | (is_basename ? MAP_DOT : 0) | MAP_NUL;
-#ifdef VMS
-  /* As in func_notdir_suffix ... */
-  char *vms_p3 = alloca (strlen(p3) + 1);
-  int i;
-  for (i = 0; p3[i]; i++)
-    if (p3[i] == ',')
-      vms_p3[i] = ' ';
-    else
-      vms_p3[i] = p3[i];
-  vms_p3[i] = p3[i];
-  while ((p2 = find_next_token((const char**) &vms_p3, &len)) != 0)
-#else
-  while ((p2 = find_next_token (&p3, &len)) != 0)
-#endif
-    {
-      const char *p = p2 + len - 1;
-      while (p >= p2 && ! STOP_SET (*p, stop))
-        --p;
-
-      if (p >= p2 && (is_dir))
-        o = variable_buffer_output (o, p2, ++p - p2);
-      else if (p >= p2 && (*p == '.'))
-        o = variable_buffer_output (o, p2, p - p2);
-#ifdef HAVE_DOS_PATHS
-      /* Handle the "d:foobar" case */
-      else if (p2[0] && p2[1] == ':' && is_dir)
-        o = variable_buffer_output (o, p2, 2);
-#endif
-      else if (is_dir)
-#ifdef VMS
-        {
-          extern int vms_report_unix_paths;
-          if (vms_report_unix_paths)
-            o = variable_buffer_output (o, "./", 2);
-          else
-            o = variable_buffer_output (o, "[]", 2);
-        }
-#else
-#ifndef _AMIGA
-      o = variable_buffer_output (o, "./", 2);
-#else
-      ; /* Just a nop...  */
-#endif /* AMIGA */
-#endif /* !VMS */
-      else
-        /* The entire name is the basename.  */
-        o = variable_buffer_output (o, p2, len);
-
-#ifdef VMS
-      if (vms_comma_separator)
-        o = variable_buffer_output (o, ",", 1);
-      else
-#endif
-        o = variable_buffer_output (o, " ", 1);
-
-      doneany = 1;
-    }
-
-  if (doneany)
-    /* Kill last space.  */
-    --o;
-
-  return o;
-}
-
-static char *
-func_addsuffix_addprefix (char *o, char **argv, const char *funcname)
-{
-  int fixlen = strlen (argv[0]);
-  const char *list_iterator = argv[1];
-  int is_addprefix = funcname[3] == 'p';
-  int is_addsuffix = !is_addprefix;
-
-  int doneany = 0;
-  const char *p;
-  unsigned int len;
-
-  while ((p = find_next_token (&list_iterator, &len)) != 0)
-    {
-      if (is_addprefix)
-        o = variable_buffer_output (o, argv[0], fixlen);
-      o = variable_buffer_output (o, p, len);
-      if (is_addsuffix)
-        o = variable_buffer_output (o, argv[0], fixlen);
-      o = variable_buffer_output (o, " ", 1);
-      doneany = 1;
-    }
-
-  if (doneany)
-    /* Kill last space.  */
-    --o;
-
-  return o;
-}
-
-static char *
-func_subst (char *o, char **argv, const char *funcname UNUSED)
-{
-  o = subst_expand (o, argv[2], argv[0], argv[1], strlen (argv[0]),
-                    strlen (argv[1]), 0);
-
-  return o;
-}
-
-
-static char *
-func_firstword (char *o, char **argv, const char *funcname UNUSED)
-{
-  unsigned int i;
-  const char *words = argv[0];    /* Use a temp variable for find_next_token */
-  const char *p = find_next_token (&words, &i);
-
-  if (p != 0)
-    o = variable_buffer_output (o, p, i);
-
-  return o;
-}
-
-static char *
-func_lastword (char *o, char **argv, const char *funcname UNUSED)
-{
-  unsigned int i;
-  const char *words = argv[0];    /* Use a temp variable for find_next_token */
-  const char *p = NULL;
-  const char *t;
-
-  while ((t = find_next_token (&words, &i)))
-    p = t;
-
-  if (p != 0)
-    o = variable_buffer_output (o, p, i);
-
-  return o;
-}
-
-static char *
-func_words (char *o, char **argv, const char *funcname UNUSED)
-{
-  int i = 0;
-  const char *word_iterator = argv[0];
-  char buf[20];
-
-  while (find_next_token (&word_iterator, NULL) != 0)
-    ++i;
-
-  sprintf (buf, "%d", i);
-  o = variable_buffer_output (o, buf, strlen (buf));
-
-  return o;
-}
-
-/* Set begpp to point to the first non-whitespace character of the string,
- * and endpp to point to the last non-whitespace character of the string.
- * If the string is empty or contains nothing but whitespace, endpp will be
- * begpp-1.
- */
-char *
-strip_whitespace (const char **begpp, const char **endpp)
-{
-  while (*begpp <= *endpp && ISSPACE (**begpp))
-    (*begpp) ++;
-  while (*endpp >= *begpp && ISSPACE (**endpp))
-    (*endpp) --;
-  return (char *)*begpp;
-}
-
-static void
-check_numeric (const char *s, const char *msg)
-{
-  const char *end = s + strlen (s) - 1;
-  const char *beg = s;
-  strip_whitespace (&s, &end);
-
-  for (; s <= end; ++s)
-    if (!ISDIGIT (*s))  /* ISDIGIT only evals its arg once: see makeint.h.  */
-      break;
-
-  if (s <= end || end - beg < 0)
-    OSS (fatal, *expanding_var, "%s: '%s'", msg, beg);
-}
-
-
-
-static char *
-func_word (char *o, char **argv, const char *funcname UNUSED)
-{
-  const char *end_p;
-  const char *p;
-  int i;
-
-  /* Check the first argument.  */
-  check_numeric (argv[0], _("non-numeric first argument to 'word' function"));
-  i = atoi (argv[0]);
-
-  if (i == 0)
-    O (fatal, *expanding_var,
-       _("first argument to 'word' function must be greater than 0"));
-
-  end_p = argv[1];
-  while ((p = find_next_token (&end_p, 0)) != 0)
-    if (--i == 0)
-      break;
-
-  if (i == 0)
-    o = variable_buffer_output (o, p, end_p - p);
-
-  return o;
-}
-
-static char *
-func_wordlist (char *o, char **argv, const char *funcname UNUSED)
-{
-  int start, count;
-
-  /* Check the arguments.  */
-  check_numeric (argv[0],
-                 _("non-numeric first argument to 'wordlist' function"));
-  check_numeric (argv[1],
-                 _("non-numeric second argument to 'wordlist' function"));
-
-  start = atoi (argv[0]);
-  if (start < 1)
-    ON (fatal, *expanding_var,
-        "invalid first argument to 'wordlist' function: '%d'", start);
-
-  count = atoi (argv[1]) - start + 1;
-
-  if (count > 0)
-    {
-      const char *p;
-      const char *end_p = argv[2];
-
-      /* Find the beginning of the "start"th word.  */
-      while (((p = find_next_token (&end_p, 0)) != 0) && --start)
-        ;
-
-      if (p)
-        {
-          /* Find the end of the "count"th word from start.  */
-          while (--count && (find_next_token (&end_p, 0) != 0))
-            ;
-
-          /* Return the stuff in the middle.  */
-          o = variable_buffer_output (o, p, end_p - p);
-        }
-    }
-
-  return o;
-}
-
-static char *
-func_findstring (char *o, char **argv, const char *funcname UNUSED)
-{
-  /* Find the first occurrence of the first string in the second.  */
-  if (strstr (argv[1], argv[0]) != 0)
-    o = variable_buffer_output (o, argv[0], strlen (argv[0]));
-
-  return o;
-}
-
-static char *
-func_foreach (char *o, char **argv, const char *funcname UNUSED)
-{
-  /* expand only the first two.  */
-  char *varname = expand_argument (argv[0], NULL);
-  char *list = expand_argument (argv[1], NULL);
-  const char *body = argv[2];
-
-  int doneany = 0;
-  const char *list_iterator = list;
-  const char *p;
-  unsigned int len;
-  struct variable *var;
-
-  /* Clean up the variable name by removing whitespace.  */
-  char *vp = next_token (varname);
-  end_of_token (vp)[0] = '\0';
-
-  push_new_variable_scope ();
-  var = define_variable (vp, strlen (vp), "", o_automatic, 0);
-
-  /* loop through LIST,  put the value in VAR and expand BODY */
-  while ((p = find_next_token (&list_iterator, &len)) != 0)
-    {
-      char *result = 0;
-
-      free (var->value);
-      var->value = xstrndup (p, len);
-
-      result = allocated_variable_expand (body);
-
-      o = variable_buffer_output (o, result, strlen (result));
-      o = variable_buffer_output (o, " ", 1);
-      doneany = 1;
-      free (result);
-    }
-
-  if (doneany)
-    /* Kill the last space.  */
-    --o;
-
-  pop_variable_scope ();
-  free (varname);
-  free (list);
-
-  return o;
-}
-
-struct a_word
-{
-  struct a_word *next;
-  struct a_word *chain;
-  char *str;
-  int length;
-  int matched;
-};
-
-static unsigned long
-a_word_hash_1 (const void *key)
-{
-  return_STRING_HASH_1 (((struct a_word const *) key)->str);
-}
-
-static unsigned long
-a_word_hash_2 (const void *key)
-{
-  return_STRING_HASH_2 (((struct a_word const *) key)->str);
-}
-
-static int
-a_word_hash_cmp (const void *x, const void *y)
-{
-  int result = ((struct a_word const *) x)->length - ((struct a_word const *) y)->length;
-  if (result)
-    return result;
-  return_STRING_COMPARE (((struct a_word const *) x)->str,
-                         ((struct a_word const *) y)->str);
-}
-
-struct a_pattern
-{
-  struct a_pattern *next;
-  char *str;
-  char *percent;
-  int length;
-};
-
-static char *
-func_filter_filterout (char *o, char **argv, const char *funcname)
-{
-  struct a_word *wordhead;
-  struct a_word **wordtail;
-  struct a_word *wp;
-  struct a_pattern *pathead;
-  struct a_pattern **pattail;
-  struct a_pattern *pp;
-
-  struct hash_table a_word_table;
-  int is_filter = funcname[CSTRLEN ("filter")] == '\0';
-  const char *pat_iterator = argv[0];
-  const char *word_iterator = argv[1];
-  int literals = 0;
-  int words = 0;
-  int hashing = 0;
-  char *p;
-  unsigned int len;
-
-  /* Chop ARGV[0] up into patterns to match against the words.
-     We don't need to preserve it because our caller frees all the
-     argument memory anyway.  */
-
-  pattail = &pathead;
-  while ((p = find_next_token (&pat_iterator, &len)) != 0)
-    {
-      struct a_pattern *pat = alloca (sizeof (struct a_pattern));
-
-      *pattail = pat;
-      pattail = &pat->next;
-
-      if (*pat_iterator != '\0')
-        ++pat_iterator;
-
-      pat->str = p;
-      p[len] = '\0';
-      pat->percent = find_percent (p);
-      if (pat->percent == 0)
-        literals++;
-
-      /* find_percent() might shorten the string so LEN is wrong.  */
-      pat->length = strlen (pat->str);
-    }
-  *pattail = 0;
-
-  /* Chop ARGV[1] up into words to match against the patterns.  */
-
-  wordtail = &wordhead;
-  while ((p = find_next_token (&word_iterator, &len)) != 0)
-    {
-      struct a_word *word = alloca (sizeof (struct a_word));
-
-      *wordtail = word;
-      wordtail = &word->next;
-
-      if (*word_iterator != '\0')
-        ++word_iterator;
-
-      p[len] = '\0';
-      word->str = p;
-      word->length = len;
-      word->matched = 0;
-      word->chain = 0;
-      words++;
-    }
-  *wordtail = 0;
-
-  /* Only use a hash table if arg list lengths justifies the cost.  */
-  hashing = (literals >= 2 && (literals * words) >= 10);
-  if (hashing)
-    {
-      hash_init (&a_word_table, words, a_word_hash_1, a_word_hash_2,
-                 a_word_hash_cmp);
-      for (wp = wordhead; wp != 0; wp = wp->next)
-        {
-          struct a_word *owp = hash_insert (&a_word_table, wp);
-          if (owp)
-            wp->chain = owp;
-        }
-    }
-
-  if (words)
-    {
-      int doneany = 0;
-
-      /* Run each pattern through the words, killing words.  */
-      for (pp = pathead; pp != 0; pp = pp->next)
-        {
-          if (pp->percent)
-            for (wp = wordhead; wp != 0; wp = wp->next)
-              wp->matched |= pattern_matches (pp->str, pp->percent, wp->str);
-          else if (hashing)
-            {
-              struct a_word a_word_key;
-              a_word_key.str = pp->str;
-              a_word_key.length = pp->length;
-              wp = hash_find_item (&a_word_table, &a_word_key);
-              while (wp)
-                {
-                  wp->matched |= 1;
-                  wp = wp->chain;
-                }
-            }
-          else
-            for (wp = wordhead; wp != 0; wp = wp->next)
-              wp->matched |= (wp->length == pp->length
-                              && strneq (pp->str, wp->str, wp->length));
-        }
-
-      /* Output the words that matched (or didn't, for filter-out).  */
-      for (wp = wordhead; wp != 0; wp = wp->next)
-        if (is_filter ? wp->matched : !wp->matched)
-          {
-            o = variable_buffer_output (o, wp->str, strlen (wp->str));
-            o = variable_buffer_output (o, " ", 1);
-            doneany = 1;
-          }
-
-      if (doneany)
-        /* Kill the last space.  */
-        --o;
-    }
-
-  if (hashing)
-    hash_free (&a_word_table, 0);
-
-  return o;
-}
-
-
-static char *
-func_strip (char *o, char **argv, const char *funcname UNUSED)
-{
-  const char *p = argv[0];
-  int doneany = 0;
-
-  while (*p != '\0')
-    {
-      int i=0;
-      const char *word_start;
-
-      NEXT_TOKEN (p);
-      word_start = p;
-      for (i=0; *p != '\0' && !ISSPACE (*p); ++p, ++i)
-        {}
-      if (!i)
-        break;
-      o = variable_buffer_output (o, word_start, i);
-      o = variable_buffer_output (o, " ", 1);
-      doneany = 1;
-    }
-
-  if (doneany)
-    /* Kill the last space.  */
-    --o;
-
-  return o;
-}
-
-/*
-  Print a warning or fatal message.
-*/
-static char *
-func_error (char *o, char **argv, const char *funcname)
-{
-  char **argvp;
-  char *msg, *p;
-  int len;
-
-  /* The arguments will be broken on commas.  Rather than create yet
-     another special case where function arguments aren't broken up,
-     just create a format string that puts them back together.  */
-  for (len=0, argvp=argv; *argvp != 0; ++argvp)
-    len += strlen (*argvp) + 2;
-
-  p = msg = alloca (len + 1);
-  msg[0] = '\0';
-
-  for (argvp=argv; argvp[1] != 0; ++argvp)
-    {
-      strcpy (p, *argvp);
-      p += strlen (*argvp);
-      *(p++) = ',';
-      *(p++) = ' ';
-    }
-  strcpy (p, *argvp);
-
-  switch (*funcname)
-    {
-    case 'e':
-      OS (fatal, reading_file, "%s", msg);
-
-    case 'w':
-      OS (error, reading_file, "%s", msg);
-      break;
-
-    case 'i':
-      outputs (0, msg);
-      outputs (0, "\n");
-      break;
-
-    default:
-      OS (fatal, *expanding_var, "Internal error: func_error: '%s'", funcname);
-    }
-
-  /* The warning function expands to the empty string.  */
-  return o;
-}
-
-
-/*
-  chop argv[0] into words, and sort them.
- */
-static char *
-func_sort (char *o, char **argv, const char *funcname UNUSED)
-{
-  const char *t;
-  char **words;
-  int wordi;
-  char *p;
-  unsigned int len;
-
-  /* Find the maximum number of words we'll have.  */
-  t = argv[0];
-  wordi = 0;
-  while ((p = find_next_token (&t, NULL)) != 0)
-    {
-      ++t;
-      ++wordi;
-    }
-
-  words = xmalloc ((wordi == 0 ? 1 : wordi) * sizeof (char *));
-
-  /* Now assign pointers to each string in the array.  */
-  t = argv[0];
-  wordi = 0;
-  while ((p = find_next_token (&t, &len)) != 0)
-    {
-      ++t;
-      p[len] = '\0';
-      words[wordi++] = p;
-    }
-
-  if (wordi)
-    {
-      int i;
-
-      /* Now sort the list of words.  */
-      qsort (words, wordi, sizeof (char *), alpha_compare);
-
-      /* Now write the sorted list, uniquified.  */
-      for (i = 0; i < wordi; ++i)
-        {
-          len = strlen (words[i]);
-          if (i == wordi - 1 || strlen (words[i + 1]) != len
-              || strcmp (words[i], words[i + 1]))
-            {
-              o = variable_buffer_output (o, words[i], len);
-              o = variable_buffer_output (o, " ", 1);
-            }
-        }
-
-      /* Kill the last space.  */
-      --o;
-    }
-
-  free (words);
-
-  return o;
-}
-
-/*
-  $(if condition,true-part[,false-part])
-
-  CONDITION is false iff it evaluates to an empty string.  White
-  space before and after condition are stripped before evaluation.
-
-  If CONDITION is true, then TRUE-PART is evaluated, otherwise FALSE-PART is
-  evaluated (if it exists).  Because only one of the two PARTs is evaluated,
-  you can use $(if ...) to create side-effects (with $(shell ...), for
-  example).
-*/
-
-static char *
-func_if (char *o, char **argv, const char *funcname UNUSED)
-{
-  const char *begp = argv[0];
-  const char *endp = begp + strlen (argv[0]) - 1;
-  int result = 0;
-
-  /* Find the result of the condition: if we have a value, and it's not
-     empty, the condition is true.  If we don't have a value, or it's the
-     empty string, then it's false.  */
-
-  strip_whitespace (&begp, &endp);
-
-  if (begp <= endp)
-    {
-      char *expansion = expand_argument (begp, endp+1);
-
-      result = expansion[0] != '\0';
-      free (expansion);
-    }
-
-  /* If the result is true (1) we want to eval the first argument, and if
-     it's false (0) we want to eval the second.  If the argument doesn't
-     exist we do nothing, otherwise expand it and add to the buffer.  */
-
-  argv += 1 + !result;
-
-  if (*argv)
-    {
-      char *expansion = expand_argument (*argv, NULL);
-
-      o = variable_buffer_output (o, expansion, strlen (expansion));
-
-      free (expansion);
-    }
-
-  return o;
-}
-
-/*
-  $(or condition1[,condition2[,condition3[...]]])
-
-  A CONDITION is false iff it evaluates to an empty string.  White
-  space before and after CONDITION are stripped before evaluation.
-
-  CONDITION1 is evaluated.  If it's true, then this is the result of
-  expansion.  If it's false, CONDITION2 is evaluated, and so on.  If none of
-  the conditions are true, the expansion is the empty string.
-
-  Once a CONDITION is true no further conditions are evaluated
-  (short-circuiting).
-*/
-
-static char *
-func_or (char *o, char **argv, const char *funcname UNUSED)
-{
-  for ( ; *argv ; ++argv)
-    {
-      const char *begp = *argv;
-      const char *endp = begp + strlen (*argv) - 1;
-      char *expansion;
-      int result = 0;
-
-      /* Find the result of the condition: if it's false keep going.  */
-
-      strip_whitespace (&begp, &endp);
-
-      if (begp > endp)
-        continue;
-
-      expansion = expand_argument (begp, endp+1);
-      result = strlen (expansion);
-
-      /* If the result is false keep going.  */
-      if (!result)
-        {
-          free (expansion);
-          continue;
-        }
-
-      /* It's true!  Keep this result and return.  */
-      o = variable_buffer_output (o, expansion, result);
-      free (expansion);
-      break;
-    }
-
-  return o;
-}
-
-/*
-  $(and condition1[,condition2[,condition3[...]]])
-
-  A CONDITION is false iff it evaluates to an empty string.  White
-  space before and after CONDITION are stripped before evaluation.
-
-  CONDITION1 is evaluated.  If it's false, then this is the result of
-  expansion.  If it's true, CONDITION2 is evaluated, and so on.  If all of
-  the conditions are true, the expansion is the result of the last condition.
-
-  Once a CONDITION is false no further conditions are evaluated
-  (short-circuiting).
-*/
-
-static char *
-func_and (char *o, char **argv, const char *funcname UNUSED)
-{
-  char *expansion;
-
-  while (1)
-    {
-      const char *begp = *argv;
-      const char *endp = begp + strlen (*argv) - 1;
-      int result;
-
-      /* An empty condition is always false.  */
-      strip_whitespace (&begp, &endp);
-      if (begp > endp)
-        return o;
-
-      expansion = expand_argument (begp, endp+1);
-      result = strlen (expansion);
-
-      /* If the result is false, stop here: we're done.  */
-      if (!result)
-        break;
-
-      /* Otherwise the result is true.  If this is the last one, keep this
-         result and quit.  Otherwise go on to the next one!  */
-
-      if (*(++argv))
-        free (expansion);
-      else
-        {
-          o = variable_buffer_output (o, expansion, result);
-          break;
-        }
-    }
-
-  free (expansion);
-
-  return o;
-}
-
-static char *
-func_wildcard (char *o, char **argv, const char *funcname UNUSED)
-{
-#ifdef _AMIGA
-   o = wildcard_expansion (argv[0], o);
-#else
-   char *p = string_glob (argv[0]);
-   o = variable_buffer_output (o, p, strlen (p));
-#endif
-   return o;
-}
-
-/*
-  $(eval <makefile string>)
-
-  Always resolves to the empty string.
-
-  Treat the arguments as a segment of makefile, and parse them.
-*/
-
-static char *
-func_eval (char *o, char **argv, const char *funcname UNUSED)
-{
-  char *buf;
-  unsigned int len;
-
-  /* Eval the buffer.  Pop the current variable buffer setting so that the
-     eval'd code can use its own without conflicting.  */
-
-  install_variable_buffer (&buf, &len);
-
-  eval_buffer (argv[0], NULL);
-
-  restore_variable_buffer (buf, len);
-
-  return o;
-}
-
-
-static char *
-func_value (char *o, char **argv, const char *funcname UNUSED)
-{
-  /* Look up the variable.  */
-  struct variable *v = lookup_variable (argv[0], strlen (argv[0]));
-
-  /* Copy its value into the output buffer without expanding it.  */
-  if (v)
-    o = variable_buffer_output (o, v->value, strlen (v->value));
-
-  return o;
-}
-
-/*
-  \r is replaced on UNIX as well. Is this desirable?
- */
-static void
-fold_newlines (char *buffer, unsigned int *length, int trim_newlines)
-{
-  char *dst = buffer;
-  char *src = buffer;
-  char *last_nonnl = buffer - 1;
-  src[*length] = 0;
-  for (; *src != '\0'; ++src)
-    {
-      if (src[0] == '\r' && src[1] == '\n')
-        continue;
-      if (*src == '\n')
-        {
-          *dst++ = ' ';
-        }
-      else
-        {
-          last_nonnl = dst;
-          *dst++ = *src;
-        }
-    }
-
-  if (!trim_newlines && (last_nonnl < (dst - 2)))
-    last_nonnl = dst - 2;
-
-  *(++last_nonnl) = '\0';
-  *length = last_nonnl - buffer;
-}
-
-pid_t shell_function_pid = 0;
-static int shell_function_completed;
-
-void
-shell_completed (int exit_code, int exit_sig)
-{
-  char buf[256];
-
-  shell_function_pid = 0;
-  if (exit_sig == 0 && exit_code == 127)
-    shell_function_completed = -1;
-  else
-    shell_function_completed = 1;
-
-  if (exit_code == 0 && exit_sig > 0)
-    exit_code = 128 + exit_sig;
-
-  sprintf (buf, "%d", exit_code);
-  define_variable_cname (".SHELLSTATUS", buf, o_override, 0);
-}
-
-#ifdef WINDOWS32
-/*untested*/
-
-#include <windows.h>
-#include <io.h>
-#include "sub_proc.h"
-
-
-int
-windows32_openpipe (int *pipedes, int errfd, pid_t *pid_p, char **command_argv, char **envp)
-{
-  SECURITY_ATTRIBUTES saAttr;
-  HANDLE hIn = INVALID_HANDLE_VALUE;
-  HANDLE hErr = INVALID_HANDLE_VALUE;
-  HANDLE hChildOutRd;
-  HANDLE hChildOutWr;
-  HANDLE hProcess, tmpIn, tmpErr;
-  DWORD e;
-
-  /* Set status for return.  */
-  pipedes[0] = pipedes[1] = -1;
-  *pid_p = (pid_t)-1;
-
-  saAttr.nLength = sizeof (SECURITY_ATTRIBUTES);
-  saAttr.bInheritHandle = TRUE;
-  saAttr.lpSecurityDescriptor = NULL;
-
-  /* Standard handles returned by GetStdHandle can be NULL or
-     INVALID_HANDLE_VALUE if the parent process closed them.  If that
-     happens, we open the null device and pass its handle to
-     process_begin below as the corresponding handle to inherit.  */
-  tmpIn = GetStdHandle (STD_INPUT_HANDLE);
-  if (DuplicateHandle (GetCurrentProcess (), tmpIn,
-                       GetCurrentProcess (), &hIn,
-                       0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE)
-    {
-      e = GetLastError ();
-      if (e == ERROR_INVALID_HANDLE)
-        {
-          tmpIn = CreateFile ("NUL", GENERIC_READ,
-                              FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
-                              OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
-          if (tmpIn != INVALID_HANDLE_VALUE
-              && DuplicateHandle (GetCurrentProcess (), tmpIn,
-                                  GetCurrentProcess (), &hIn,
-                                  0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE)
-            CloseHandle (tmpIn);
-        }
-      if (hIn == INVALID_HANDLE_VALUE)
-        {
-          ON (error, NILF,
-              _("windows32_openpipe: DuplicateHandle(In) failed (e=%ld)\n"), e);
-          return -1;
-        }
-    }
-  tmpErr = (HANDLE)_get_osfhandle (errfd);
-  if (DuplicateHandle (GetCurrentProcess (), tmpErr,
-                       GetCurrentProcess (), &hErr,
-                       0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE)
-    {
-      e = GetLastError ();
-      if (e == ERROR_INVALID_HANDLE)
-        {
-          tmpErr = CreateFile ("NUL", GENERIC_WRITE,
-                               FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
-                               OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
-          if (tmpErr != INVALID_HANDLE_VALUE
-              && DuplicateHandle (GetCurrentProcess (), tmpErr,
-                                  GetCurrentProcess (), &hErr,
-                                  0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE)
-            CloseHandle (tmpErr);
-        }
-      if (hErr == INVALID_HANDLE_VALUE)
-        {
-          ON (error, NILF,
-              _("windows32_openpipe: DuplicateHandle(Err) failed (e=%ld)\n"), e);
-          return -1;
-        }
-    }
-
-  if (! CreatePipe (&hChildOutRd, &hChildOutWr, &saAttr, 0))
-    {
-      ON (error, NILF, _("CreatePipe() failed (e=%ld)\n"), GetLastError());
-      return -1;
-    }
-
-  hProcess = process_init_fd (hIn, hChildOutWr, hErr);
-
-  if (!hProcess)
-    {
-      O (error, NILF, _("windows32_openpipe(): process_init_fd() failed\n"));
-      return -1;
-    }
-
-  /* make sure that CreateProcess() has Path it needs */
-  sync_Path_environment ();
-  /* 'sync_Path_environment' may realloc 'environ', so take note of
-     the new value.  */
-  envp = environ;
-
-  if (! process_begin (hProcess, command_argv, envp, command_argv[0], NULL))
-    {
-      /* register process for wait */
-      process_register (hProcess);
-
-      /* set the pid for returning to caller */
-      *pid_p = (pid_t) hProcess;
-
-      /* set up to read data from child */
-      pipedes[0] = _open_osfhandle ((intptr_t) hChildOutRd, O_RDONLY);
-
-      /* this will be closed almost right away */
-      pipedes[1] = _open_osfhandle ((intptr_t) hChildOutWr, O_APPEND);
-      return 0;
-    }
-  else
-    {
-      /* reap/cleanup the failed process */
-      process_cleanup (hProcess);
-
-      /* close handles which were duplicated, they weren't used */
-      if (hIn != INVALID_HANDLE_VALUE)
-        CloseHandle (hIn);
-      if (hErr != INVALID_HANDLE_VALUE)
-        CloseHandle (hErr);
-
-      /* close pipe handles, they won't be used */
-      CloseHandle (hChildOutRd);
-      CloseHandle (hChildOutWr);
-
-      return -1;
-    }
-}
-#endif
-
-
-#ifdef __MSDOS__
-FILE *
-msdos_openpipe (int* pipedes, int *pidp, char *text)
-{
-  FILE *fpipe=0;
-  /* MSDOS can't fork, but it has 'popen'.  */
-  struct variable *sh = lookup_variable ("SHELL", 5);
-  int e;
-  extern int dos_command_running, dos_status;
-
-  /* Make sure not to bother processing an empty line.  */
-  NEXT_TOKEN (text);
-  if (*text == '\0')
-    return 0;
-
-  if (sh)
-    {
-      char buf[PATH_MAX + 7];
-      /* This makes sure $SHELL value is used by $(shell), even
-         though the target environment is not passed to it.  */
-      sprintf (buf, "SHELL=%s", sh->value);
-      putenv (buf);
-    }
-
-  e = errno;
-  errno = 0;
-  dos_command_running = 1;
-  dos_status = 0;
-  /* If dos_status becomes non-zero, it means the child process
-     was interrupted by a signal, like SIGINT or SIGQUIT.  See
-     fatal_error_signal in commands.c.  */
-  fpipe = popen (text, "rt");
-  dos_command_running = 0;
-  if (!fpipe || dos_status)
-    {
-      pipedes[0] = -1;
-      *pidp = -1;
-      if (dos_status)
-        errno = EINTR;
-      else if (errno == 0)
-        errno = ENOMEM;
-      if (fpipe)
-        pclose (fpipe);
-      shell_completed (127, 0);
-    }
-  else
-    {
-      pipedes[0] = fileno (fpipe);
-      *pidp = 42; /* Yes, the Meaning of Life, the Universe, and Everything! */
-      errno = e;
-    }
-  return fpipe;
-}
-#endif
-
-/*
-  Do shell spawning, with the naughty bits for different OSes.
- */
-
-#ifdef VMS
-
-/* VMS can't do $(shell ...)  */
-
-char *
-func_shell_base (char *o, char **argv, int trim_newlines)
-{
-  fprintf (stderr, "This platform does not support shell\n");
-  die (MAKE_TROUBLE);
-  return NULL;
-}
-
-#define func_shell 0
-
-#else
-#ifndef _AMIGA
-char *
-func_shell_base (char *o, char **argv, int trim_newlines)
-{
-  char *batch_filename = NULL;
-  int errfd;
-#ifdef __MSDOS__
-  FILE *fpipe;
-#endif
-  char **command_argv;
-  const char *error_prefix;
-  char **envp;
-  int pipedes[2];
-  pid_t pid;
-
-#ifndef __MSDOS__
-#ifdef WINDOWS32
-  /* Reset just_print_flag.  This is needed on Windows when batch files
-     are used to run the commands, because we normally refrain from
-     creating batch files under -n.  */
-  int j_p_f = just_print_flag;
-  just_print_flag = 0;
-#endif
-
-  /* Construct the argument list.  */
-  command_argv = construct_command_argv (argv[0], NULL, NULL, 0,
-                                         &batch_filename);
-  if (command_argv == 0)
-    {
-#ifdef WINDOWS32
-      just_print_flag = j_p_f;
-#endif
-      return o;
-    }
-#endif /* !__MSDOS__ */
-
-  /* Using a target environment for 'shell' loses in cases like:
-       export var = $(shell echo foobie)
-       bad := $(var)
-     because target_environment hits a loop trying to expand $(var) to put it
-     in the environment.  This is even more confusing when 'var' was not
-     explicitly exported, but just appeared in the calling environment.
-
-     See Savannah bug #10593.
-
-  envp = target_environment (NULL);
-  */
-
-  envp = environ;
-
-  /* For error messages.  */
-  if (reading_file && reading_file->filenm)
-    {
-      char *p = alloca (strlen (reading_file->filenm)+11+4);
-      sprintf (p, "%s:%lu: ", reading_file->filenm,
-               reading_file->lineno + reading_file->offset);
-      error_prefix = p;
-    }
-  else
-    error_prefix = "";
-
-  /* Set up the output in case the shell writes something.  */
-  output_start ();
-
-  errfd = (output_context && output_context->err >= 0
-           ? output_context->err : FD_STDERR);
-
-#if defined(__MSDOS__)
-  fpipe = msdos_openpipe (pipedes, &pid, argv[0]);
-  if (pipedes[0] < 0)
-    {
-      perror_with_name (error_prefix, "pipe");
-      return o;
-    }
-
-#elif defined(WINDOWS32)
-  windows32_openpipe (pipedes, errfd, &pid, command_argv, envp);
-  /* Restore the value of just_print_flag.  */
-  just_print_flag = j_p_f;
-
-  if (pipedes[0] < 0)
-    {
-      /* Open of the pipe failed, mark as failed execution.  */
-      shell_completed (127, 0);
-      perror_with_name (error_prefix, "pipe");
-      return o;
-    }
-
-#else
-  if (pipe (pipedes) < 0)
-    {
-      perror_with_name (error_prefix, "pipe");
-      return o;
-    }
-
-  /* Close handles that are unnecessary for the child process.  */
-  fd_noinherit (pipedes[1]);
-  fd_noinherit (pipedes[0]);
-
-  {
-    struct output out;
-    out.syncout = 1;
-    out.out = pipedes[1];
-    out.err = errfd;
-
-    pid = child_execute_job (&out, 1, command_argv, envp);
-  }
-
-  if (pid < 0)
-    {
-      perror_with_name (error_prefix, "fork");
-      return o;
-    }
-#endif
-
-  {
-    char *buffer;
-    unsigned int maxlen, i;
-    int cc;
-
-    /* Record the PID for reap_children.  */
-    shell_function_pid = pid;
-#ifndef  __MSDOS__
-    shell_function_completed = 0;
-
-    /* Free the storage only the child needed.  */
-    free (command_argv[0]);
-    free (command_argv);
-
-    /* Close the write side of the pipe.  We test for -1, since
-       pipedes[1] is -1 on MS-Windows, and some versions of MS
-       libraries barf when 'close' is called with -1.  */
-    if (pipedes[1] >= 0)
-      close (pipedes[1]);
-#endif
-
-    /* Set up and read from the pipe.  */
-
-    maxlen = 200;
-    buffer = xmalloc (maxlen + 1);
-
-    /* Read from the pipe until it gets EOF.  */
-    for (i = 0; ; i += cc)
-      {
-        if (i == maxlen)
-          {
-            maxlen += 512;
-            buffer = xrealloc (buffer, maxlen + 1);
-          }
-
-        EINTRLOOP (cc, read (pipedes[0], &buffer[i], maxlen - i));
-        if (cc <= 0)
-          break;
-      }
-    buffer[i] = '\0';
-
-    /* Close the read side of the pipe.  */
-#ifdef  __MSDOS__
-    if (fpipe)
-      {
-        int st = pclose (fpipe);
-        shell_completed (st, 0);
-      }
-#else
-    (void) close (pipedes[0]);
-#endif
-
-    /* Loop until child_handler or reap_children()  sets
-       shell_function_completed to the status of our child shell.  */
-    while (shell_function_completed == 0)
-      reap_children (1, 0);
-
-    if (batch_filename)
-      {
-        DB (DB_VERBOSE, (_("Cleaning up temporary batch file %s\n"),
-                         batch_filename));
-        remove (batch_filename);
-        free (batch_filename);
-      }
-    shell_function_pid = 0;
-
-    /* shell_completed() will set shell_function_completed to 1 when the
-       child dies normally, or to -1 if it dies with status 127, which is
-       most likely an exec fail.  */
-
-    if (shell_function_completed == -1)
-      {
-        /* This likely means that the execvp failed, so we should just
-           write the error message in the pipe from the child.  */
-        fputs (buffer, stderr);
-        fflush (stderr);
-      }
-    else
-      {
-        /* The child finished normally.  Replace all newlines in its output
-           with spaces, and put that in the variable output buffer.  */
-        fold_newlines (buffer, &i, trim_newlines);
-        o = variable_buffer_output (o, buffer, i);
-      }
-
-    free (buffer);
-  }
-
-  return o;
-}
-
-#else   /* _AMIGA */
-
-/* Do the Amiga version of func_shell.  */
-
-char *
-func_shell_base (char *o, char **argv, int trim_newlines)
-{
-  /* Amiga can't fork nor spawn, but I can start a program with
-     redirection of my choice.  However, this means that we
-     don't have an opportunity to reopen stdout to trap it.  Thus,
-     we save our own stdout onto a new descriptor and dup a temp
-     file's descriptor onto our stdout temporarily.  After we
-     spawn the shell program, we dup our own stdout back to the
-     stdout descriptor.  The buffer reading is the same as above,
-     except that we're now reading from a file.  */
-
-#include <dos/dos.h>
-#include <proto/dos.h>
-
-  BPTR child_stdout;
-  char tmp_output[FILENAME_MAX];
-  unsigned int maxlen = 200, i;
-  int cc;
-  char * buffer, * ptr;
-  char ** aptr;
-  int len = 0;
-  char* batch_filename = NULL;
-
-  /* Construct the argument list.  */
-  command_argv = construct_command_argv (argv[0], NULL, NULL, 0,
-                                         &batch_filename);
-  if (command_argv == 0)
-    return o;
-
-  /* Note the mktemp() is a security hole, but this only runs on Amiga.
-     Ideally we would use get_tmpfile(), but this uses a special Open(), not
-     fopen(), and I'm not familiar enough with the code to mess with it.  */
-  strcpy (tmp_output, "t:MakeshXXXXXXXX");
-  mktemp (tmp_output);
-  child_stdout = Open (tmp_output, MODE_NEWFILE);
-
-  for (aptr=command_argv; *aptr; aptr++)
-    len += strlen (*aptr) + 1;
-
-  buffer = xmalloc (len + 1);
-  ptr = buffer;
-
-  for (aptr=command_argv; *aptr; aptr++)
-    {
-      strcpy (ptr, *aptr);
-      ptr += strlen (ptr) + 1;
-      *ptr ++ = ' ';
-      *ptr = 0;
-    }
-
-  ptr[-1] = '\n';
-
-  Execute (buffer, NULL, child_stdout);
-  free (buffer);
-
-  Close (child_stdout);
-
-  child_stdout = Open (tmp_output, MODE_OLDFILE);
-
-  buffer = xmalloc (maxlen);
-  i = 0;
-  do
-    {
-      if (i == maxlen)
-        {
-          maxlen += 512;
-          buffer = xrealloc (buffer, maxlen + 1);
-        }
-
-      cc = Read (child_stdout, &buffer[i], maxlen - i);
-      if (cc > 0)
-        i += cc;
-    } while (cc > 0);
-
-  Close (child_stdout);
-
-  fold_newlines (buffer, &i, trim_newlines);
-  o = variable_buffer_output (o, buffer, i);
-  free (buffer);
-  return o;
-}
-#endif  /* _AMIGA */
-
-static char *
-func_shell (char *o, char **argv, const char *funcname UNUSED)
-{
-  return func_shell_base (o, argv, 1);
-}
-#endif  /* !VMS */
-
-#ifdef EXPERIMENTAL
-
-/*
-  equality. Return is string-boolean, i.e., the empty string is false.
- */
-static char *
-func_eq (char *o, char **argv, char *funcname UNUSED)
-{
-  int result = ! strcmp (argv[0], argv[1]);
-  o = variable_buffer_output (o,  result ? "1" : "", result);
-  return o;
-}
-
-
-/*
-  string-boolean not operator.
- */
-static char *
-func_not (char *o, char **argv, char *funcname UNUSED)
-{
-  const char *s = argv[0];
-  int result = 0;
-  NEXT_TOKEN (s);
-  result = ! (*s);
-  o = variable_buffer_output (o,  result ? "1" : "", result);
-  return o;
-}
-#endif
-
-
-#ifdef HAVE_DOS_PATHS
-# ifdef __CYGWIN__
-#  define IS_ABSOLUTE(n) ((n[0] && n[1] == ':') || STOP_SET (n[0], MAP_DIRSEP))
-# else
-#  define IS_ABSOLUTE(n) (n[0] && n[1] == ':')
-# endif
-# define ROOT_LEN 3
-#else
-#define IS_ABSOLUTE(n) (n[0] == '/')
-#define ROOT_LEN 1
-#endif
-
-/* Return the absolute name of file NAME which does not contain any '.',
-   '..' components nor any repeated path separators ('/').   */
-
-static char *
-abspath (const char *name, char *apath)
-{
-  char *dest;
-  const char *start, *end, *apath_limit;
-  unsigned long root_len = ROOT_LEN;
-
-  if (name[0] == '\0' || apath == NULL)
-    return NULL;
-
-  apath_limit = apath + GET_PATH_MAX;
-
-  if (!IS_ABSOLUTE(name))
-    {
-      /* It is unlikely we would make it until here but just to make sure. */
-      if (!starting_directory)
-        return NULL;
-
-      strcpy (apath, starting_directory);
-
-#ifdef HAVE_DOS_PATHS
-      if (STOP_SET (name[0], MAP_DIRSEP))
-        {
-          if (STOP_SET (name[1], MAP_DIRSEP))
-            {
-              /* A UNC.  Don't prepend a drive letter.  */
-              apath[0] = name[0];
-              apath[1] = name[1];
-              root_len = 2;
-            }
-          /* We have /foo, an absolute file name except for the drive
-             letter.  Assume the missing drive letter is the current
-             drive, which we can get if we remove from starting_directory
-             everything past the root directory.  */
-          apath[root_len] = '\0';
-        }
-#endif
-
-      dest = strchr (apath, '\0');
-    }
-  else
-    {
-#if defined(__CYGWIN__) && defined(HAVE_DOS_PATHS)
-      if (STOP_SET (name[0], MAP_DIRSEP))
-        root_len = 1;
-#endif
-      strncpy (apath, name, root_len);
-      apath[root_len] = '\0';
-      dest = apath + root_len;
-      /* Get past the root, since we already copied it.  */
-      name += root_len;
-#ifdef HAVE_DOS_PATHS
-      if (! STOP_SET (apath[root_len - 1], MAP_DIRSEP))
-        {
-          /* Convert d:foo into d:./foo and increase root_len.  */
-          apath[2] = '.';
-          apath[3] = '/';
-          dest++;
-          root_len++;
-          /* strncpy above copied one character too many.  */
-          name--;
-        }
-      else
-        apath[root_len - 1] = '/'; /* make sure it's a forward slash */
-#endif
-    }
-
-  for (start = end = name; *start != '\0'; start = end)
-    {
-      unsigned long len;
-
-      /* Skip sequence of multiple path-separators.  */
-      while (STOP_SET (*start, MAP_DIRSEP))
-        ++start;
-
-      /* Find end of path component.  */
-      for (end = start; ! STOP_SET (*end, MAP_DIRSEP|MAP_NUL); ++end)
-        ;
-
-      len = end - start;
-
-      if (len == 0)
-        break;
-      else if (len == 1 && start[0] == '.')
-        /* nothing */;
-      else if (len == 2 && start[0] == '.' && start[1] == '.')
-        {
-          /* Back up to previous component, ignore if at root already.  */
-          if (dest > apath + root_len)
-            for (--dest; ! STOP_SET (dest[-1], MAP_DIRSEP); --dest)
-              ;
-        }
-      else
-        {
-          if (! STOP_SET (dest[-1], MAP_DIRSEP))
-            *dest++ = '/';
-
-          if (dest + len >= apath_limit)
-            return NULL;
-
-          dest = memcpy (dest, start, len);
-          dest += len;
-          *dest = '\0';
-        }
-    }
-
-  /* Unless it is root strip trailing separator.  */
-  if (dest > apath + root_len && STOP_SET (dest[-1], MAP_DIRSEP))
-    --dest;
-
-  *dest = '\0';
-
-  return apath;
-}
-
-
-static char *
-func_realpath (char *o, char **argv, const char *funcname UNUSED)
-{
-  /* Expand the argument.  */
-  const char *p = argv[0];
-  const char *path = 0;
-  int doneany = 0;
-  unsigned int len = 0;
-
-  while ((path = find_next_token (&p, &len)) != 0)
-    {
-      if (len < GET_PATH_MAX)
-        {
-          char *rp;
-          struct stat st;
-          PATH_VAR (in);
-          PATH_VAR (out);
-
-          strncpy (in, path, len);
-          in[len] = '\0';
-
-#ifdef HAVE_REALPATH
-          ENULLLOOP (rp, realpath (in, out));
-#else
-          rp = abspath (in, out);
-#endif
-
-          if (rp)
-            {
-              int r;
-              EINTRLOOP (r, stat (out, &st));
-              if (r == 0)
-                {
-                  o = variable_buffer_output (o, out, strlen (out));
-                  o = variable_buffer_output (o, " ", 1);
-                  doneany = 1;
-                }
-            }
-        }
-    }
-
-  /* Kill last space.  */
-  if (doneany)
-    --o;
-
-  return o;
-}
-
-static char *
-func_file (char *o, char **argv, const char *funcname UNUSED)
-{
-  char *fn = argv[0];
-
-  if (fn[0] == '>')
-    {
-      FILE *fp;
-      const char *mode = "w";
-
-      /* We are writing a file.  */
-      ++fn;
-      if (fn[0] == '>')
-        {
-          mode = "a";
-          ++fn;
-        }
-      NEXT_TOKEN (fn);
-
-      if (fn[0] == '\0')
-        O (fatal, *expanding_var, _("file: missing filename"));
-
-      ENULLLOOP (fp, fopen (fn, mode));
-      if (fp == NULL)
-        OSS (fatal, reading_file, _("open: %s: %s"), fn, strerror (errno));
-
-      if (argv[1])
-        {
-          int l = strlen (argv[1]);
-          int nl = l == 0 || argv[1][l-1] != '\n';
-
-          if (fputs (argv[1], fp) == EOF || (nl && fputc ('\n', fp) == EOF))
-            OSS (fatal, reading_file, _("write: %s: %s"), fn, strerror (errno));
-        }
-      if (fclose (fp))
-        OSS (fatal, reading_file, _("close: %s: %s"), fn, strerror (errno));
-    }
-  else if (fn[0] == '<')
-    {
-      char *preo = o;
-      FILE *fp;
-
-      ++fn;
-      NEXT_TOKEN (fn);
-      if (fn[0] == '\0')
-        O (fatal, *expanding_var, _("file: missing filename"));
-
-      if (argv[1])
-        O (fatal, *expanding_var, _("file: too many arguments"));
-
-      ENULLLOOP (fp, fopen (fn, "r"));
-      if (fp == NULL)
-        {
-          if (errno == ENOENT)
-            return o;
-          OSS (fatal, reading_file, _("open: %s: %s"), fn, strerror (errno));
-        }
-
-      while (1)
-        {
-          char buf[1024];
-          size_t l = fread (buf, 1, sizeof (buf), fp);
-          if (l > 0)
-            o = variable_buffer_output (o, buf, l);
-
-          if (ferror (fp))
-            if (errno != EINTR)
-              OSS (fatal, reading_file, _("read: %s: %s"), fn, strerror (errno));
-          if (feof (fp))
-            break;
-        }
-      if (fclose (fp))
-        OSS (fatal, reading_file, _("close: %s: %s"), fn, strerror (errno));
-
-      /* Remove trailing newline.  */
-      if (o > preo && o[-1] == '\n')
-        if (--o > preo && o[-1] == '\r')
-          --o;
-    }
-  else
-    OS (fatal, *expanding_var, _("file: invalid file operation: %s"), fn);
-
-  return o;
-}
-
-static char *
-func_abspath (char *o, char **argv, const char *funcname UNUSED)
-{
-  /* Expand the argument.  */
-  const char *p = argv[0];
-  const char *path = 0;
-  int doneany = 0;
-  unsigned int len = 0;
-
-  while ((path = find_next_token (&p, &len)) != 0)
-    {
-      if (len < GET_PATH_MAX)
-        {
-          PATH_VAR (in);
-          PATH_VAR (out);
-
-          strncpy (in, path, len);
-          in[len] = '\0';
-
-          if (abspath (in, out))
-            {
-              o = variable_buffer_output (o, out, strlen (out));
-              o = variable_buffer_output (o, " ", 1);
-              doneany = 1;
-            }
-        }
-    }
-
-  /* Kill last space.  */
-  if (doneany)
-    --o;
-
-  return o;
-}
-
-/* Lookup table for builtin functions.
-
-   This doesn't have to be sorted; we use a straight lookup.  We might gain
-   some efficiency by moving most often used functions to the start of the
-   table.
-
-   If MAXIMUM_ARGS is 0, that means there is no maximum and all
-   comma-separated values are treated as arguments.
-
-   EXPAND_ARGS means that all arguments should be expanded before invocation.
-   Functions that do namespace tricks (foreach) don't automatically expand.  */
-
-static char *func_call (char *o, char **argv, const char *funcname);
-
-#define FT_ENTRY(_name, _min, _max, _exp, _func) \
-  { { (_func) }, STRING_SIZE_TUPLE(_name), (_min), (_max), (_exp), 0 }
-
-static struct function_table_entry function_table_init[] =
-{
- /*         Name            MIN MAX EXP? Function */
-  FT_ENTRY ("abspath",       0,  1,  1,  func_abspath),
-  FT_ENTRY ("addprefix",     2,  2,  1,  func_addsuffix_addprefix),
-  FT_ENTRY ("addsuffix",     2,  2,  1,  func_addsuffix_addprefix),
-  FT_ENTRY ("basename",      0,  1,  1,  func_basename_dir),
-  FT_ENTRY ("dir",           0,  1,  1,  func_basename_dir),
-  FT_ENTRY ("notdir",        0,  1,  1,  func_notdir_suffix),
-  FT_ENTRY ("subst",         3,  3,  1,  func_subst),
-  FT_ENTRY ("suffix",        0,  1,  1,  func_notdir_suffix),
-  FT_ENTRY ("filter",        2,  2,  1,  func_filter_filterout),
-  FT_ENTRY ("filter-out",    2,  2,  1,  func_filter_filterout),
-  FT_ENTRY ("findstring",    2,  2,  1,  func_findstring),
-  FT_ENTRY ("firstword",     0,  1,  1,  func_firstword),
-  FT_ENTRY ("flavor",        0,  1,  1,  func_flavor),
-  FT_ENTRY ("join",          2,  2,  1,  func_join),
-  FT_ENTRY ("lastword",      0,  1,  1,  func_lastword),
-  FT_ENTRY ("patsubst",      3,  3,  1,  func_patsubst),
-  FT_ENTRY ("realpath",      0,  1,  1,  func_realpath),
-  FT_ENTRY ("shell",         0,  1,  1,  func_shell),
-  FT_ENTRY ("sort",          0,  1,  1,  func_sort),
-  FT_ENTRY ("strip",         0,  1,  1,  func_strip),
-  FT_ENTRY ("wildcard",      0,  1,  1,  func_wildcard),
-  FT_ENTRY ("word",          2,  2,  1,  func_word),
-  FT_ENTRY ("wordlist",      3,  3,  1,  func_wordlist),
-  FT_ENTRY ("words",         0,  1,  1,  func_words),
-  FT_ENTRY ("origin",        0,  1,  1,  func_origin),
-  FT_ENTRY ("foreach",       3,  3,  0,  func_foreach),
-  FT_ENTRY ("call",          1,  0,  1,  func_call),
-  FT_ENTRY ("info",          0,  1,  1,  func_error),
-  FT_ENTRY ("error",         0,  1,  1,  func_error),
-  FT_ENTRY ("warning",       0,  1,  1,  func_error),
-  FT_ENTRY ("if",            2,  3,  0,  func_if),
-  FT_ENTRY ("or",            1,  0,  0,  func_or),
-  FT_ENTRY ("and",           1,  0,  0,  func_and),
-  FT_ENTRY ("value",         0,  1,  1,  func_value),
-  FT_ENTRY ("eval",          0,  1,  1,  func_eval),
-  FT_ENTRY ("file",          1,  2,  1,  func_file),
-#ifdef EXPERIMENTAL
-  FT_ENTRY ("eq",            2,  2,  1,  func_eq),
-  FT_ENTRY ("not",           0,  1,  1,  func_not),
-#endif
-};
-
-#define FUNCTION_TABLE_ENTRIES (sizeof (function_table_init) / sizeof (struct function_table_entry))
-
-
-/* These must come after the definition of function_table.  */
-
-static char *
-expand_builtin_function (char *o, int argc, char **argv,
-                         const struct function_table_entry *entry_p)
-{
-  char *p;
-
-  if (argc < (int)entry_p->minimum_args)
-    fatal (*expanding_var, strlen (entry_p->name),
-           _("insufficient number of arguments (%d) to function '%s'"),
-           argc, entry_p->name);
-
-  /* I suppose technically some function could do something with no arguments,
-     but so far no internal ones do, so just test it for all functions here
-     rather than in each one.  We can change it later if necessary.  */
-
-  if (!argc && !entry_p->alloc_fn)
-    return o;
-
-  if (!entry_p->fptr.func_ptr)
-    OS (fatal, *expanding_var,
-        _("unimplemented on this platform: function '%s'"), entry_p->name);
-
-  if (!entry_p->alloc_fn)
-    return entry_p->fptr.func_ptr (o, argv, entry_p->name);
-
-  /* This function allocates memory and returns it to us.
-     Write it to the variable buffer, then free it.  */
-
-  p = entry_p->fptr.alloc_func_ptr (entry_p->name, argc, argv);
-  if (p)
-    {
-      o = variable_buffer_output (o, p, strlen (p));
-      free (p);
-    }
-
-  return o;
-}
-
-/* Check for a function invocation in *STRINGP.  *STRINGP points at the
-   opening ( or { and is not null-terminated.  If a function invocation
-   is found, expand it into the buffer at *OP, updating *OP, incrementing
-   *STRINGP past the reference and returning nonzero.  If not, return zero.  */
-
-int
-handle_function (char **op, const char **stringp)
-{
-  const struct function_table_entry *entry_p;
-  char openparen = (*stringp)[0];
-  char closeparen = openparen == '(' ? ')' : '}';
-  const char *beg;
-  const char *end;
-  int count = 0;
-  char *abeg = NULL;
-  char **argv, **argvp;
-  int nargs;
-
-  beg = *stringp + 1;
-
-  entry_p = lookup_function (beg);
-
-  if (!entry_p)
-    return 0;
-
-  /* We found a builtin function.  Find the beginning of its arguments (skip
-     whitespace after the name).  */
-
-  beg += entry_p->len;
-  NEXT_TOKEN (beg);
-
-  /* Find the end of the function invocation, counting nested use of
-     whichever kind of parens we use.  Since we're looking, count commas
-     to get a rough estimate of how many arguments we might have.  The
-     count might be high, but it'll never be low.  */
-
-  for (nargs=1, end=beg; *end != '\0'; ++end)
-    if (!STOP_SET (*end, MAP_VARSEP|MAP_COMMA))
-      continue;
-    else if (*end == ',')
-      ++nargs;
-    else if (*end == openparen)
-      ++count;
-    else if (*end == closeparen && --count < 0)
-      break;
-
-  if (count >= 0)
-    fatal (*expanding_var, strlen (entry_p->name),
-           _("unterminated call to function '%s': missing '%c'"),
-           entry_p->name, closeparen);
-
-  *stringp = end;
-
-  /* Get some memory to store the arg pointers.  */
-  argvp = argv = alloca (sizeof (char *) * (nargs + 2));
-
-  /* Chop the string into arguments, then a nul.  As soon as we hit
-     MAXIMUM_ARGS (if it's >0) assume the rest of the string is part of the
-     last argument.
-
-     If we're expanding, store pointers to the expansion of each one.  If
-     not, make a duplicate of the string and point into that, nul-terminating
-     each argument.  */
-
-  if (entry_p->expand_args)
-    {
-      const char *p;
-      for (p=beg, nargs=0; p <= end; ++argvp)
-        {
-          const char *next;
-
-          ++nargs;
-
-          if (nargs == entry_p->maximum_args
-              || (! (next = find_next_argument (openparen, closeparen, p, end))))
-            next = end;
-
-          *argvp = expand_argument (p, next);
-          p = next + 1;
-        }
-    }
-  else
-    {
-      int len = end - beg;
-      char *p, *aend;
-
-      abeg = xmalloc (len+1);
-      memcpy (abeg, beg, len);
-      abeg[len] = '\0';
-      aend = abeg + len;
-
-      for (p=abeg, nargs=0; p <= aend; ++argvp)
-        {
-          char *next;
-
-          ++nargs;
-
-          if (nargs == entry_p->maximum_args
-              || (! (next = find_next_argument (openparen, closeparen, p, aend))))
-            next = aend;
-
-          *argvp = p;
-          *next = '\0';
-          p = next + 1;
-        }
-    }
-  *argvp = NULL;
-
-  /* Finally!  Run the function...  */
-  *op = expand_builtin_function (*op, nargs, argv, entry_p);
-
-  /* Free memory.  */
-  if (entry_p->expand_args)
-    for (argvp=argv; *argvp != 0; ++argvp)
-      free (*argvp);
-  else
-    free (abeg);
-
-  return 1;
-}
-
-
-/* User-defined functions.  Expand the first argument as either a builtin
-   function or a make variable, in the context of the rest of the arguments
-   assigned to $1, $2, ... $N.  $0 is the name of the function.  */
-
-static char *
-func_call (char *o, char **argv, const char *funcname UNUSED)
-{
-  static int max_args = 0;
-  char *fname;
-  char *body;
-  int flen;
-  int i;
-  int saved_args;
-  const struct function_table_entry *entry_p;
-  struct variable *v;
-
-  /* Clean up the name of the variable to be invoked.  */
-  fname = next_token (argv[0]);
-  end_of_token (fname)[0] = '\0';
-
-  /* Calling nothing is a no-op */
-  if (*fname == '\0')
-    return o;
-
-  /* Are we invoking a builtin function?  */
-
-  entry_p = lookup_function (fname);
-  if (entry_p)
-    {
-      /* How many arguments do we have?  */
-      for (i=0; argv[i+1]; ++i)
-        ;
-      return expand_builtin_function (o, i, argv+1, entry_p);
-    }
-
-  /* Not a builtin, so the first argument is the name of a variable to be
-     expanded and interpreted as a function.  Find it.  */
-  flen = strlen (fname);
-
-  v = lookup_variable (fname, flen);
-
-  if (v == 0)
-    warn_undefined (fname, flen);
-
-  if (v == 0 || *v->value == '\0')
-    return o;
-
-  body = alloca (flen + 4);
-  body[0] = '$';
-  body[1] = '(';
-  memcpy (body + 2, fname, flen);
-  body[flen+2] = ')';
-  body[flen+3] = '\0';
-
-  /* Set up arguments $(1) .. $(N).  $(0) is the function name.  */
-
-  push_new_variable_scope ();
-
-  for (i=0; *argv; ++i, ++argv)
-    {
-      char num[11];
-
-      sprintf (num, "%d", i);
-      define_variable (num, strlen (num), *argv, o_automatic, 0);
-    }
-
-  /* If the number of arguments we have is < max_args, it means we're inside
-     a recursive invocation of $(call ...).  Fill in the remaining arguments
-     in the new scope with the empty value, to hide them from this
-     invocation.  */
-
-  for (; i < max_args; ++i)
-    {
-      char num[11];
-
-      sprintf (num, "%d", i);
-      define_variable (num, strlen (num), "", o_automatic, 0);
-    }
-
-  /* Expand the body in the context of the arguments, adding the result to
-     the variable buffer.  */
-
-  v->exp_count = EXP_COUNT_MAX;
-
-  saved_args = max_args;
-  max_args = i;
-  o = variable_expand_string (o, body, flen+3);
-  max_args = saved_args;
-
-  v->exp_count = 0;
-
-  pop_variable_scope ();
-
-  return o + strlen (o);
-}
-
-void
-define_new_function (const floc *flocp, const char *name,
-                     unsigned int min, unsigned int max, unsigned int flags,
-                     gmk_func_ptr func)
-{
-  const char *e = name;
-  struct function_table_entry *ent;
-  size_t len;
-
-  while (STOP_SET (*e, MAP_USERFUNC))
-    e++;
-  len = e - name;
-
-  if (len == 0)
-    O (fatal, flocp, _("Empty function name"));
-  if (*name == '.' || *e != '\0')
-    OS (fatal, flocp, _("Invalid function name: %s"), name);
-  if (len > 255)
-    OS (fatal, flocp, _("Function name too long: %s"), name);
-  if (min > 255)
-    ONS (fatal, flocp,
-         _("Invalid minimum argument count (%u) for function %s"), min, name);
-  if (max > 255 || (max && max < min))
-    ONS (fatal, flocp,
-         _("Invalid maximum argument count (%u) for function %s"), max, name);
-
-  ent = xmalloc (sizeof (struct function_table_entry));
-  ent->name = name;
-  ent->len = len;
-  ent->minimum_args = min;
-  ent->maximum_args = max;
-  ent->expand_args = ANY_SET(flags, GMK_FUNC_NOEXPAND) ? 0 : 1;
-  ent->alloc_fn = 1;
-  ent->fptr.alloc_func_ptr = func;
-
-  hash_insert (&function_table, ent);
-}
-
-void
-hash_init_function_table (void)
-{
-  hash_init (&function_table, FUNCTION_TABLE_ENTRIES * 2,
-             function_table_entry_hash_1, function_table_entry_hash_2,
-             function_table_entry_hash_cmp);
-  hash_load (&function_table, function_table_init,
-             FUNCTION_TABLE_ENTRIES, sizeof (struct function_table_entry));
-}
diff --git a/getloadavg.c b/getloadavg.c
deleted file mode 100644
index 663a7de..0000000
--- a/getloadavg.c
+++ /dev/null
@@ -1,1026 +0,0 @@
-/* Get the system load averages.
-Copyright (C) 1985-2017 Free Software Foundation, Inc.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-/* Compile-time symbols that this file uses:
-
-   HAVE_PSTAT_GETDYNAMIC	Define this if your system has the
-                                pstat_getdynamic function.  I think it
-				is unique to HPUX9.  The best way to get the
-				definition is through the AC_FUNC_GETLOADAVG
-				macro that comes with autoconf 2.13 or newer.
-				If that isn't an option, then just put
-				AC_CHECK_FUNCS(pstat_getdynamic) in your
-				configure.in file.
-   FIXUP_KERNEL_SYMBOL_ADDR()	Adjust address in returned struct nlist.
-   KERNEL_FILE			Pathname of the kernel to nlist.
-   LDAV_CVT()			Scale the load average from the kernel.
-				Returns a double.
-   LDAV_SYMBOL			Name of kernel symbol giving load average.
-   LOAD_AVE_TYPE		Type of the load average array in the kernel.
-				Must be defined unless one of
-				apollo, DGUX, NeXT, or UMAX is defined;
-                                or we have libkstat;
-				otherwise, no load average is available.
-   NLIST_STRUCT			Include nlist.h, not a.out.h, and
-				the nlist n_name element is a pointer,
-				not an array.
-   HAVE_STRUCT_NLIST_N_UN_N_NAME struct nlist has an n_un member, not n_name.
-   LINUX_LDAV_FILE		[__linux__]: File containing load averages.
-
-   Specific system predefines this file uses, aside from setting
-   default values if not emacs:
-
-   apollo
-   BSD				Real BSD, not just BSD-like.
-   convex
-   DGUX
-   eunice			UNIX emulator under VMS.
-   hpux
-   __MSDOS__			No-op for MSDOS.
-   NeXT
-   sgi
-   sequent			Sequent Dynix 3.x.x (BSD)
-   _SEQUENT_			Sequent DYNIX/ptx 1.x.x (SYSV)
-   sony_news                    NEWS-OS (works at least for 4.1C)
-   UMAX
-   UMAX4_3
-   VMS
-   WINDOWS32			No-op for Windows95/NT.
-   __linux__			Linux: assumes /proc filesystem mounted.
-   				Support from Michael K. Johnson.
-   __NetBSD__			NetBSD: assumes /kern filesystem mounted.
-
-   In addition, to avoid nesting many #ifdefs, we internally set
-   LDAV_DONE to indicate that the load average has been computed.
-
-   We also #define LDAV_PRIVILEGED if a program will require
-   special installation to be able to call getloadavg.  */
-
-/* This should always be first.  */
-#ifdef HAVE_CONFIG_H
-# include <config.h>
-#endif
-
-#include <sys/types.h>
-
-/* Both the Emacs and non-Emacs sections want this.  Some
-   configuration files' definitions for the LOAD_AVE_CVT macro (like
-   sparc.h's) use macros like FSCALE, defined here.  */
-#if defined (unix) || defined (__unix)
-# include <sys/param.h>
-#endif
-
-
-/* Exclude all the code except the test program at the end
-   if the system has its own 'getloadavg' function.
-
-   The declaration of 'errno' is needed by the test program
-   as well as the function itself, so it comes first.  */
-
-#include <errno.h>
-
-#ifndef errno
-extern int errno;
-#endif
-
-#if HAVE_LOCALE_H
-# include <locale.h>
-#endif
-#if !HAVE_SETLOCALE
-# define setlocale(Category, Locale) /* empty */
-#endif
-
-#ifndef HAVE_GETLOADAVG
-
-
-/* The existing Emacs configuration files define a macro called
-   LOAD_AVE_CVT, which accepts a value of type LOAD_AVE_TYPE, and
-   returns the load average multiplied by 100.  What we actually want
-   is a macro called LDAV_CVT, which returns the load average as an
-   unmultiplied double.
-
-   For backwards compatibility, we'll define LDAV_CVT in terms of
-   LOAD_AVE_CVT, but future machine config files should just define
-   LDAV_CVT directly.  */
-
-# if !defined(LDAV_CVT) && defined(LOAD_AVE_CVT)
-#  define LDAV_CVT(n) (LOAD_AVE_CVT (n) / 100.0)
-# endif
-
-# if !defined (BSD) && defined (ultrix)
-/* Ultrix behaves like BSD on Vaxen.  */
-#  define BSD
-# endif
-
-# ifdef NeXT
-/* NeXT in the 2.{0,1,2} releases defines BSD in <sys/param.h>, which
-   conflicts with the definition understood in this file, that this
-   really is BSD. */
-#  undef BSD
-
-/* NeXT defines FSCALE in <sys/param.h>.  However, we take FSCALE being
-   defined to mean that the nlist method should be used, which is not true.  */
-#  undef FSCALE
-# endif
-
-/* Same issues as for NeXT apply to the HURD-based GNU system.  */
-# ifdef __GNU__
-#  undef BSD
-#  undef FSCALE
-# endif /* __GNU__ */
-
-/* Set values that are different from the defaults, which are
-   set a little farther down with #ifndef.  */
-
-
-/* Some shorthands.  */
-
-# if defined (HPUX) && !defined (hpux)
-#  define hpux
-# endif
-
-# if defined (__hpux) && !defined (hpux)
-#  define hpux
-# endif
-
-# if defined (__sun) && !defined (sun)
-#  define sun
-# endif
-
-# if defined(hp300) && !defined(hpux)
-#  define MORE_BSD
-# endif
-
-# if defined(ultrix) && defined(mips)
-#  define decstation
-# endif
-
-# if defined (__SVR4) && !defined (SVR4)
-#  define SVR4
-# endif
-
-# if (defined(sun) && defined(SVR4)) || defined (SOLARIS2)
-#  define SUNOS_5
-# endif
-
-# if defined (__osf__) && (defined (__alpha) || defined (__alpha__))
-#  define OSF_ALPHA
-#  include <sys/mbuf.h>
-#  include <sys/socket.h>
-#  include <net/route.h>
-#  include <sys/table.h>
-# endif
-
-# if defined (__osf__) && (defined (mips) || defined (__mips__))
-#  define OSF_MIPS
-#  include <sys/table.h>
-# endif
-
-/* UTek's /bin/cc on the 4300 has no architecture specific cpp define by
-   default, but _MACH_IND_SYS_TYPES is defined in <sys/types.h>.  Combine
-   that with a couple of other things and we'll have a unique match.  */
-# if !defined (tek4300) && defined (unix) && defined (m68k) && defined (mc68000) && defined (mc68020) && defined (_MACH_IND_SYS_TYPES)
-#  define tek4300			/* Define by emacs, but not by other users.  */
-# endif
-
-/* AC_FUNC_GETLOADAVG thinks QNX is SVR4, but it isn't. */
-# if defined(__QNX__)
-#  undef SVR4
-# endif
-
-/* VAX C can't handle multi-line #ifs, or lines longer than 256 chars.  */
-# ifndef LOAD_AVE_TYPE
-
-#  ifdef MORE_BSD
-#   define LOAD_AVE_TYPE long
-#  endif
-
-#  ifdef sun
-#   define LOAD_AVE_TYPE long
-#  endif
-
-#  ifdef decstation
-#   define LOAD_AVE_TYPE long
-#  endif
-
-#  ifdef _SEQUENT_
-#   define LOAD_AVE_TYPE long
-#  endif
-
-#  ifdef sgi
-#   define LOAD_AVE_TYPE long
-#  endif
-
-#  ifdef SVR4
-#   define LOAD_AVE_TYPE long
-#  endif
-
-#  ifdef sony_news
-#   define LOAD_AVE_TYPE long
-#  endif
-
-#  ifdef sequent
-#   define LOAD_AVE_TYPE long
-#  endif
-
-#  ifdef OSF_ALPHA
-#   define LOAD_AVE_TYPE long
-#  endif
-
-#  if defined (ardent) && defined (titan)
-#   define LOAD_AVE_TYPE long
-#  endif
-
-#  ifdef tek4300
-#   define LOAD_AVE_TYPE long
-#  endif
-
-#  if defined(alliant) && defined(i860) /* Alliant FX/2800 */
-#   define LOAD_AVE_TYPE long
-#  endif
-
-#  ifdef _AIX
-#   define LOAD_AVE_TYPE long
-#  endif
-
-#  ifdef convex
-#   define LOAD_AVE_TYPE double
-#   ifndef LDAV_CVT
-#    define LDAV_CVT(n) (n)
-#   endif
-#  endif
-
-# endif /* No LOAD_AVE_TYPE.  */
-
-# ifdef OSF_ALPHA
-/* <sys/param.h> defines an incorrect value for FSCALE on Alpha OSF/1,
-   according to ghazi@noc.rutgers.edu.  */
-#  undef FSCALE
-#  define FSCALE 1024.0
-# endif
-
-# if defined(alliant) && defined(i860) /* Alliant FX/2800 */
-/* <sys/param.h> defines an incorrect value for FSCALE on an
-   Alliant FX/2800 Concentrix 2.2, according to ghazi@noc.rutgers.edu.  */
-#  undef FSCALE
-#  define FSCALE 100.0
-# endif
-
-
-# ifndef	FSCALE
-
-/* SunOS and some others define FSCALE in sys/param.h.  */
-
-#  ifdef MORE_BSD
-#   define FSCALE 2048.0
-#  endif
-
-#  if defined(MIPS) || defined(SVR4) || defined(decstation)
-#   define FSCALE 256
-#  endif
-
-#  if defined (sgi) || defined (sequent)
-/* Sometimes both MIPS and sgi are defined, so FSCALE was just defined
-   above under #ifdef MIPS.  But we want the sgi value.  */
-#   undef FSCALE
-#   define	FSCALE 1000.0
-#  endif
-
-#  if defined (ardent) && defined (titan)
-#   define FSCALE 65536.0
-#  endif
-
-#  ifdef tek4300
-#   define FSCALE 100.0
-#  endif
-
-#  ifdef _AIX
-#   define FSCALE 65536.0
-#  endif
-
-# endif	/* Not FSCALE.  */
-
-# if !defined (LDAV_CVT) && defined (FSCALE)
-#  define	LDAV_CVT(n) (((double) (n)) / FSCALE)
-# endif
-
-
-# if defined(sgi) || (defined(mips) && !defined(BSD))
-#  define FIXUP_KERNEL_SYMBOL_ADDR(nl) ((nl)[0].n_value &= ~(1 << 31))
-# endif
-
-
-# if !defined (KERNEL_FILE) && defined (sequent)
-#  define KERNEL_FILE "/dynix"
-# endif
-
-# if !defined (KERNEL_FILE) && defined (hpux)
-#  define KERNEL_FILE "/hp-ux"
-# endif
-
-# if !defined(KERNEL_FILE) && (defined(_SEQUENT_) || defined(MIPS) || defined(SVR4) || defined(ISC) || defined (sgi) || (defined (ardent) && defined (titan)))
-#  define KERNEL_FILE "/unix"
-# endif
-
-
-# if !defined (LDAV_SYMBOL) && defined (alliant)
-#  define LDAV_SYMBOL "_Loadavg"
-# endif
-
-# if !defined(LDAV_SYMBOL) && ((defined(hpux) && !defined(hp9000s300)) || defined(_SEQUENT_) || defined(SVR4) || defined(ISC) || defined(sgi) || (defined (ardent) && defined (titan)) || defined (_AIX))
-#  define LDAV_SYMBOL "avenrun"
-# endif
-
-# ifdef HAVE_UNISTD_H
-#  include <unistd.h>
-# endif
-
-# include <stdio.h>
-
-/* LOAD_AVE_TYPE should only get defined if we're going to use the
-   nlist method.  */
-# if !defined(LOAD_AVE_TYPE) && (defined(BSD) || defined(LDAV_CVT) || defined(KERNEL_FILE) || defined(LDAV_SYMBOL)) && !defined(__riscos__)
-#  define LOAD_AVE_TYPE double
-# endif
-
-# ifdef LOAD_AVE_TYPE
-
-#  ifndef VMS
-#   ifndef __linux__
-#    ifdef HAVE_NLIST_H
-#     include <nlist.h>
-#    else
-#     include <a.out.h>
-#    endif
-
-#    ifdef SUNOS_5
-#     include <fcntl.h>
-#     include <kvm.h>
-#     include <kstat.h>
-#    endif
-
-#    if defined (hpux) && defined (HAVE_PSTAT_GETDYNAMIC)
-#     include <sys/pstat.h>
-#    endif
-
-#    ifndef KERNEL_FILE
-#     define KERNEL_FILE "/vmunix"
-#    endif /* KERNEL_FILE */
-
-#    ifndef LDAV_SYMBOL
-#     define LDAV_SYMBOL "_avenrun"
-#    endif /* LDAV_SYMBOL */
-#   endif /* __linux__ */
-
-#  else /* VMS */
-
-#   ifndef eunice
-#    include <iodef.h>
-#    include <descrip.h>
-#   else /* eunice */
-#    include <vms/iodef.h>
-#   endif /* eunice */
-#  endif /* VMS */
-
-#  ifndef LDAV_CVT
-#   define LDAV_CVT(n) ((double) (n))
-#  endif /* !LDAV_CVT */
-
-# endif /* LOAD_AVE_TYPE */
-
-# if defined(__GNU__) && !defined (NeXT)
-/* Note that NeXT Openstep defines __GNU__ even though it should not.  */
-/* GNU system acts much like NeXT, for load average purposes,
-   but not exactly.  */
-#  define NeXT
-#  define host_self mach_host_self
-# endif
-
-# ifdef NeXT
-#  ifdef HAVE_MACH_MACH_H
-#   include <mach/mach.h>
-#  else
-#   include <mach.h>
-#  endif
-# endif /* NeXT */
-
-# ifdef sgi
-#  include <sys/sysmp.h>
-# endif /* sgi */
-
-# ifdef UMAX
-#  include <stdio.h>
-#  include <signal.h>
-#  include <sys/time.h>
-#  include <sys/wait.h>
-#  include <sys/syscall.h>
-
-#  ifdef UMAX_43
-#   include <machine/cpu.h>
-#   include <inq_stats/statistics.h>
-#   include <inq_stats/sysstats.h>
-#   include <inq_stats/cpustats.h>
-#   include <inq_stats/procstats.h>
-#  else /* Not UMAX_43.  */
-#   include <sys/sysdefs.h>
-#   include <sys/statistics.h>
-#   include <sys/sysstats.h>
-#   include <sys/cpudefs.h>
-#   include <sys/cpustats.h>
-#   include <sys/procstats.h>
-#  endif /* Not UMAX_43.  */
-# endif /* UMAX */
-
-# ifdef DGUX
-#  include <sys/dg_sys_info.h>
-# endif
-
-# if defined(HAVE_FCNTL_H) || defined(_POSIX_VERSION)
-#  include <fcntl.h>
-# else
-#  include <sys/file.h>
-# endif
-
-
-/* Avoid static vars inside a function since in HPUX they dump as pure.  */
-
-# ifdef NeXT
-static processor_set_t default_set;
-static int getloadavg_initialized;
-# endif /* NeXT */
-
-# ifdef UMAX
-static unsigned int cpus = 0;
-static unsigned int samples;
-# endif /* UMAX */
-
-# ifdef DGUX
-static struct dg_sys_info_load_info load_info;	/* what-a-mouthful! */
-# endif /* DGUX */
-
-#if !defined(HAVE_LIBKSTAT) && defined(LOAD_AVE_TYPE)
-/* File descriptor open to /dev/kmem or VMS load ave driver.  */
-static int channel;
-/* Nonzero iff channel is valid.  */
-static int getloadavg_initialized;
-/* Offset in kmem to seek to read load average, or 0 means invalid.  */
-static long offset;
-
-#if !defined(VMS) && !defined(sgi) && !defined(__linux__)
-static struct nlist nl[2];
-#endif /* Not VMS or sgi */
-
-#ifdef SUNOS_5
-static kvm_t *kd;
-#endif /* SUNOS_5 */
-
-#endif /* LOAD_AVE_TYPE && !HAVE_LIBKSTAT */
-
-/* Put the 1 minute, 5 minute and 15 minute load averages
-   into the first NELEM elements of LOADAVG.
-   Return the number written (never more than 3, but may be less than NELEM),
-   or -1 if an error occurred.  */
-
-int
-getloadavg (double loadavg[], int nelem)
-{
-  int elem = 0;			/* Return value.  */
-
-# ifdef NO_GET_LOAD_AVG
-#  define LDAV_DONE
-  /* Set errno to zero to indicate that there was no particular error;
-     this function just can't work at all on this system.  */
-  errno = 0;
-  elem = -1;
-# endif
-
-# if !defined (LDAV_DONE) && defined (HAVE_LIBKSTAT)
-/* Use libkstat because we don't have to be root.  */
-#  define LDAV_DONE
-  kstat_ctl_t *kc;
-  kstat_t *ksp;
-  kstat_named_t *kn;
-
-  kc = kstat_open ();
-  if (kc == 0)
-    return -1;
-  ksp = kstat_lookup (kc, "unix", 0, "system_misc");
-  if (ksp == 0 )
-    return -1;
-  if (kstat_read (kc, ksp, 0) == -1)
-    return -1;
-
-
-  kn = kstat_data_lookup (ksp, "avenrun_1min");
-  if (kn == 0)
-    {
-      /* Return -1 if no load average information is available.  */
-      nelem = 0;
-      elem = -1;
-    }
-
-  if (nelem >= 1)
-    loadavg[elem++] = (double) kn->value.ul/FSCALE;
-
-  if (nelem >= 2)
-    {
-      kn = kstat_data_lookup (ksp, "avenrun_5min");
-      if (kn != 0)
-	{
-	  loadavg[elem++] = (double) kn->value.ul/FSCALE;
-
-	  if (nelem >= 3)
-	    {
-	      kn = kstat_data_lookup (ksp, "avenrun_15min");
-	      if (kn != 0)
-		loadavg[elem++] = (double) kn->value.ul/FSCALE;
-	    }
-	}
-    }
-
-  kstat_close (kc);
-# endif /* HAVE_LIBKSTAT */
-
-# if !defined (LDAV_DONE) && defined (hpux) && defined (HAVE_PSTAT_GETDYNAMIC)
-/* Use pstat_getdynamic() because we don't have to be root.  */
-#  define LDAV_DONE
-#  undef LOAD_AVE_TYPE
-
-  struct pst_dynamic dyn_info;
-  if (pstat_getdynamic (&dyn_info, sizeof (dyn_info), 0, 0) < 0)
-    return -1;
-  if (nelem > 0)
-    loadavg[elem++] = dyn_info.psd_avg_1_min;
-  if (nelem > 1)
-    loadavg[elem++] = dyn_info.psd_avg_5_min;
-  if (nelem > 2)
-    loadavg[elem++] = dyn_info.psd_avg_15_min;
-
-# endif /* hpux && HAVE_PSTAT_GETDYNAMIC */
-
-# if !defined (LDAV_DONE) && defined (__linux__)
-#  define LDAV_DONE
-#  undef LOAD_AVE_TYPE
-
-#  ifndef LINUX_LDAV_FILE
-#   define LINUX_LDAV_FILE "/proc/loadavg"
-#  endif
-
-  char ldavgbuf[40];
-  double load_ave[3];
-  int fd, count;
-
-  fd = open (LINUX_LDAV_FILE, O_RDONLY);
-  if (fd == -1)
-    return -1;
-  count = read (fd, ldavgbuf, 40);
-  (void) close (fd);
-  if (count <= 0)
-    return -1;
-
-  /* The following sscanf must use the C locale.  */
-  setlocale (LC_NUMERIC, "C");
-  count = sscanf (ldavgbuf, "%lf %lf %lf",
-		  &load_ave[0], &load_ave[1], &load_ave[2]);
-  setlocale (LC_NUMERIC, "");
-  if (count < 1)
-    return -1;
-
-  for (elem = 0; elem < nelem && elem < count; elem++)
-    loadavg[elem] = load_ave[elem];
-
-  return elem;
-
-# endif /* __linux__ */
-
-# if !defined (LDAV_DONE) && defined (__NetBSD__)
-#  define LDAV_DONE
-#  undef LOAD_AVE_TYPE
-
-#  ifndef NETBSD_LDAV_FILE
-#   define NETBSD_LDAV_FILE "/kern/loadavg"
-#  endif
-
-  unsigned long int load_ave[3], scale;
-  int count;
-  FILE *fp;
-
-  fp = fopen (NETBSD_LDAV_FILE, "r");
-  if (fp == NULL)
-    return -1;
-  count = fscanf (fp, "%lu %lu %lu %lu\n",
-		  &load_ave[0], &load_ave[1], &load_ave[2],
-		  &scale);
-  (void) fclose (fp);
-  if (count != 4)
-    return -1;
-
-  for (elem = 0; elem < nelem; elem++)
-    loadavg[elem] = (double) load_ave[elem] / (double) scale;
-
-  return elem;
-
-# endif /* __NetBSD__ */
-
-# if !defined (LDAV_DONE) && defined (NeXT)
-#  define LDAV_DONE
-  /* The NeXT code was adapted from iscreen 3.2.  */
-
-  host_t host;
-  struct processor_set_basic_info info;
-  unsigned info_count;
-
-  /* We only know how to get the 1-minute average for this system,
-     so even if the caller asks for more than 1, we only return 1.  */
-
-  if (!getloadavg_initialized)
-    {
-      if (processor_set_default (host_self (), &default_set) == KERN_SUCCESS)
-	getloadavg_initialized = 1;
-    }
-
-  if (getloadavg_initialized)
-    {
-      info_count = PROCESSOR_SET_BASIC_INFO_COUNT;
-      if (processor_set_info (default_set, PROCESSOR_SET_BASIC_INFO, &host,
-			      (processor_set_info_t) &info, &info_count)
-	  != KERN_SUCCESS)
-	getloadavg_initialized = 0;
-      else
-	{
-	  if (nelem > 0)
-	    loadavg[elem++] = (double) info.load_average / LOAD_SCALE;
-	}
-    }
-
-  if (!getloadavg_initialized)
-    return -1;
-# endif /* NeXT */
-
-# if !defined (LDAV_DONE) && defined (UMAX)
-#  define LDAV_DONE
-/* UMAX 4.2, which runs on the Encore Multimax multiprocessor, does not
-   have a /dev/kmem.  Information about the workings of the running kernel
-   can be gathered with inq_stats system calls.
-   We only know how to get the 1-minute average for this system.  */
-
-  struct proc_summary proc_sum_data;
-  struct stat_descr proc_info;
-  double load;
-  register unsigned int i, j;
-
-  if (cpus == 0)
-    {
-      register unsigned int c, i;
-      struct cpu_config conf;
-      struct stat_descr desc;
-
-      desc.sd_next = 0;
-      desc.sd_subsys = SUBSYS_CPU;
-      desc.sd_type = CPUTYPE_CONFIG;
-      desc.sd_addr = (char *) &conf;
-      desc.sd_size = sizeof conf;
-
-      if (inq_stats (1, &desc))
-	return -1;
-
-      c = 0;
-      for (i = 0; i < conf.config_maxclass; ++i)
-	{
-	  struct class_stats stats;
-	  memset (&stats, '\0', sizeof stats);
-
-	  desc.sd_type = CPUTYPE_CLASS;
-	  desc.sd_objid = i;
-	  desc.sd_addr = (char *) &stats;
-	  desc.sd_size = sizeof stats;
-
-	  if (inq_stats (1, &desc))
-	    return -1;
-
-	  c += stats.class_numcpus;
-	}
-      cpus = c;
-      samples = cpus < 2 ? 3 : (2 * cpus / 3);
-    }
-
-  proc_info.sd_next = 0;
-  proc_info.sd_subsys = SUBSYS_PROC;
-  proc_info.sd_type = PROCTYPE_SUMMARY;
-  proc_info.sd_addr = (char *) &proc_sum_data;
-  proc_info.sd_size = sizeof (struct proc_summary);
-  proc_info.sd_sizeused = 0;
-
-  if (inq_stats (1, &proc_info) != 0)
-    return -1;
-
-  load = proc_sum_data.ps_nrunnable;
-  j = 0;
-  for (i = samples - 1; i > 0; --i)
-    {
-      load += proc_sum_data.ps_nrun[j];
-      if (j++ == PS_NRUNSIZE)
-	j = 0;
-    }
-
-  if (nelem > 0)
-    loadavg[elem++] = load / samples / cpus;
-# endif /* UMAX */
-
-# if !defined (LDAV_DONE) && defined (DGUX)
-#  define LDAV_DONE
-  /* This call can return -1 for an error, but with good args
-     it's not supposed to fail.  The first argument is for no
-     apparent reason of type 'long int *'.  */
-  dg_sys_info ((long int *) &load_info,
-	       DG_SYS_INFO_LOAD_INFO_TYPE,
-	       DG_SYS_INFO_LOAD_VERSION_0);
-
-  if (nelem > 0)
-    loadavg[elem++] = load_info.one_minute;
-  if (nelem > 1)
-    loadavg[elem++] = load_info.five_minute;
-  if (nelem > 2)
-    loadavg[elem++] = load_info.fifteen_minute;
-# endif /* DGUX */
-
-# if !defined (LDAV_DONE) && defined (apollo)
-#  define LDAV_DONE
-/* Apollo code from lisch@mentorg.com (Ray Lischner).
-
-   This system call is not documented.  The load average is obtained as
-   three long integers, for the load average over the past minute,
-   five minutes, and fifteen minutes.  Each value is a scaled integer,
-   with 16 bits of integer part and 16 bits of fraction part.
-
-   I'm not sure which operating system first supported this system call,
-   but I know that SR10.2 supports it.  */
-
-  extern void proc1_$get_loadav ();
-  unsigned long load_ave[3];
-
-  proc1_$get_loadav (load_ave);
-
-  if (nelem > 0)
-    loadavg[elem++] = load_ave[0] / 65536.0;
-  if (nelem > 1)
-    loadavg[elem++] = load_ave[1] / 65536.0;
-  if (nelem > 2)
-    loadavg[elem++] = load_ave[2] / 65536.0;
-# endif /* apollo */
-
-# if !defined (LDAV_DONE) && defined (OSF_MIPS)
-#  define LDAV_DONE
-
-  struct tbl_loadavg load_ave;
-  table (TBL_LOADAVG, 0, &load_ave, 1, sizeof (load_ave));
-  loadavg[elem++]
-    = (load_ave.tl_lscale == 0
-       ? load_ave.tl_avenrun.d[0]
-       : (load_ave.tl_avenrun.l[0] / (double) load_ave.tl_lscale));
-# endif	/* OSF_MIPS */
-
-# if !defined (LDAV_DONE) && (defined (__MSDOS__) || defined (WINDOWS32))
-#  define LDAV_DONE
-
-  /* A faithful emulation is going to have to be saved for a rainy day.  */
-  for ( ; elem < nelem; elem++)
-    {
-      loadavg[elem] = 0.0;
-    }
-# endif  /* __MSDOS__ || WINDOWS32 */
-
-# if !defined (LDAV_DONE) && defined (OSF_ALPHA)
-#  define LDAV_DONE
-
-  struct tbl_loadavg load_ave;
-  table (TBL_LOADAVG, 0, &load_ave, 1, sizeof (load_ave));
-  for (elem = 0; elem < nelem; elem++)
-    loadavg[elem]
-      = (load_ave.tl_lscale == 0
-       ? load_ave.tl_avenrun.d[elem]
-       : (load_ave.tl_avenrun.l[elem] / (double) load_ave.tl_lscale));
-# endif /* OSF_ALPHA */
-
-# if !defined (LDAV_DONE) && defined (VMS)
-  /* VMS specific code -- read from the Load Ave driver.  */
-
-  LOAD_AVE_TYPE load_ave[3];
-  static int getloadavg_initialized = 0;
-#  ifdef eunice
-  struct
-  {
-    int dsc$w_length;
-    char *dsc$a_pointer;
-  } descriptor;
-#  endif
-
-  /* Ensure that there is a channel open to the load ave device.  */
-  if (!getloadavg_initialized)
-    {
-      /* Attempt to open the channel.  */
-#  ifdef eunice
-      descriptor.dsc$w_length = 18;
-      descriptor.dsc$a_pointer = "$$VMS_LOAD_AVERAGE";
-#  else
-      $DESCRIPTOR (descriptor, "LAV0:");
-#  endif
-      if (sys$assign (&descriptor, &channel, 0, 0) & 1)
-	getloadavg_initialized = 1;
-    }
-
-  /* Read the load average vector.  */
-  if (getloadavg_initialized
-      && !(sys$qiow (0, channel, IO$_READVBLK, 0, 0, 0,
-		     load_ave, 12, 0, 0, 0, 0) & 1))
-    {
-      sys$dassgn (channel);
-      getloadavg_initialized = 0;
-    }
-
-  if (!getloadavg_initialized)
-    return -1;
-# endif /* VMS */
-
-# if !defined (LDAV_DONE) && defined(LOAD_AVE_TYPE) && !defined(VMS)
-
-  /* UNIX-specific code -- read the average from /dev/kmem.  */
-
-#  define LDAV_PRIVILEGED		/* This code requires special installation.  */
-
-  LOAD_AVE_TYPE load_ave[3];
-
-  /* Get the address of LDAV_SYMBOL.  */
-  if (offset == 0)
-    {
-#  ifndef sgi
-#   ifndef NLIST_STRUCT
-      strcpy (nl[0].n_name, LDAV_SYMBOL);
-      strcpy (nl[1].n_name, "");
-#   else /* NLIST_STRUCT */
-#    ifdef HAVE_STRUCT_NLIST_N_UN_N_NAME
-      nl[0].n_un.n_name = LDAV_SYMBOL;
-      nl[1].n_un.n_name = 0;
-#    else /* not HAVE_STRUCT_NLIST_N_UN_N_NAME */
-      nl[0].n_name = LDAV_SYMBOL;
-      nl[1].n_name = 0;
-#    endif /* not HAVE_STRUCT_NLIST_N_UN_N_NAME */
-#   endif /* NLIST_STRUCT */
-
-#   ifndef SUNOS_5
-      if (
-#    if !(defined (_AIX) && !defined (ps2))
-	  nlist (KERNEL_FILE, nl)
-#    else  /* _AIX */
-	  knlist (nl, 1, sizeof (nl[0]))
-#    endif
-	  >= 0)
-	  /* Omit "&& nl[0].n_type != 0 " -- it breaks on Sun386i.  */
-	  {
-#    ifdef FIXUP_KERNEL_SYMBOL_ADDR
-	    FIXUP_KERNEL_SYMBOL_ADDR (nl);
-#    endif
-	    offset = nl[0].n_value;
-	  }
-#   endif /* !SUNOS_5 */
-#  else  /* sgi */
-      int ldav_off;
-
-      ldav_off = sysmp (MP_KERNADDR, MPKA_AVENRUN);
-      if (ldav_off != -1)
-	offset = (long) ldav_off & 0x7fffffff;
-#  endif /* sgi */
-    }
-
-  /* Make sure we have /dev/kmem open.  */
-  if (!getloadavg_initialized)
-    {
-#  ifndef SUNOS_5
-      channel = open ("/dev/kmem", 0);
-      if (channel >= 0)
-	{
-	  /* Set the channel to close on exec, so it does not
-	     litter any child's descriptor table.  */
-#   ifdef F_SETFD
-#    ifndef FD_CLOEXEC
-#     define FD_CLOEXEC 1
-#    endif
-	  (void) fcntl (channel, F_SETFD, FD_CLOEXEC);
-#   endif
-	  getloadavg_initialized = 1;
-	}
-#  else /* SUNOS_5 */
-      /* We pass 0 for the kernel, corefile, and swapfile names
-	 to use the currently running kernel.  */
-      kd = kvm_open (0, 0, 0, O_RDONLY, 0);
-      if (kd != 0)
-	{
-	  /* nlist the currently running kernel.  */
-	  kvm_nlist (kd, nl);
-	  offset = nl[0].n_value;
-	  getloadavg_initialized = 1;
-	}
-#  endif /* SUNOS_5 */
-    }
-
-  /* If we can, get the load average values.  */
-  if (offset && getloadavg_initialized)
-    {
-      /* Try to read the load.  */
-#  ifndef SUNOS_5
-      if (lseek (channel, offset, 0) == -1L
-	  || read (channel, (char *) load_ave, sizeof (load_ave))
-	  != sizeof (load_ave))
-	{
-	  close (channel);
-	  getloadavg_initialized = 0;
-	}
-#  else  /* SUNOS_5 */
-      if (kvm_read (kd, offset, (char *) load_ave, sizeof (load_ave))
-	  != sizeof (load_ave))
-        {
-          kvm_close (kd);
-          getloadavg_initialized = 0;
-	}
-#  endif /* SUNOS_5 */
-    }
-
-  if (offset == 0 || !getloadavg_initialized)
-    return -1;
-# endif /* LOAD_AVE_TYPE and not VMS */
-
-# if !defined (LDAV_DONE) && defined (LOAD_AVE_TYPE) /* Including VMS.  */
-  if (nelem > 0)
-    loadavg[elem++] = LDAV_CVT (load_ave[0]);
-  if (nelem > 1)
-    loadavg[elem++] = LDAV_CVT (load_ave[1]);
-  if (nelem > 2)
-    loadavg[elem++] = LDAV_CVT (load_ave[2]);
-
-#  define LDAV_DONE
-# endif /* !LDAV_DONE && LOAD_AVE_TYPE */
-
-# ifdef LDAV_DONE
-  return elem;
-# else
-  /* Set errno to zero to indicate that there was no particular error;
-     this function just can't work at all on this system.  */
-  errno = 0;
-  return -1;
-# endif
-}
-
-#endif /* ! HAVE_GETLOADAVG */
-
-#ifdef TEST
-#include "makeint.h"
-
-int
-main (int argc, char **argv)
-{
-  int naptime = 0;
-
-  if (argc > 1)
-    naptime = atoi (argv[1]);
-
-  while (1)
-    {
-      double avg[3];
-      int loads;
-
-      errno = 0;		/* Don't be misled if it doesn't set errno.  */
-      loads = getloadavg (avg, 3);
-      if (loads == -1)
-	{
-	  perror ("Error getting load average");
-	  exit (1);
-	}
-      if (loads > 0)
-	printf ("1-minute: %f  ", avg[0]);
-      if (loads > 1)
-	printf ("5-minute: %f  ", avg[1]);
-      if (loads > 2)
-	printf ("15-minute: %f  ", avg[2]);
-      if (loads > 0)
-	putchar ('\n');
-
-      if (naptime == 0)
-	break;
-      sleep (naptime);
-    }
-
-  exit (0);
-}
-#endif /* TEST */
diff --git a/getopt.c b/getopt.c
deleted file mode 100644
index 5d4b89e..0000000
--- a/getopt.c
+++ /dev/null
@@ -1,1026 +0,0 @@
-/* Getopt for GNU.
-NOTE: getopt is now part of the C library, so if you don't know what
-"Keep this file name-space clean" means, talk to drepper@gnu.org
-before changing it!
-
-Copyright (C) 1987-2017 Free Software Foundation, Inc.
-
-NOTE: The canonical source of this file is maintained with the GNU C Library.
-Bugs can be reported to bug-glibc@gnu.org.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.
-   Ditto for AIX 3.2 and <stdlib.h>.  */
-#ifndef _NO_PROTO
-# define _NO_PROTO
-#endif
-
-#ifdef HAVE_CONFIG_H
-# include <config.h>
-#endif
-
-#if !defined __STDC__ || !__STDC__
-/* This is a separate conditional since some stdc systems
-   reject `defined (const)'.  */
-# ifndef const
-#  define const
-# endif
-#endif
-
-#include <stdio.h>
-
-/* Comment out all this code if we are using the GNU C Library, and are not
-   actually compiling the library itself.  This code is part of the GNU C
-   Library, but also included in many other GNU distributions.  Compiling
-   and linking in this code is a waste when using the GNU C library
-   (especially if it is a shared library).  Rather than having every GNU
-   program understand `configure --with-gnu-libc' and omit the object files,
-   it is simpler to just do this in the source for each such file.  */
-
-#define GETOPT_INTERFACE_VERSION 2
-#if !defined _LIBC && defined __GLIBC__ && __GLIBC__ >= 2
-# include <gnu-versions.h>
-# if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION
-#  define ELIDE_CODE
-# endif
-#endif
-
-#ifndef ELIDE_CODE
-
-
-/* This needs to come after some library #include
-   to get __GNU_LIBRARY__ defined.  */
-#ifdef	__GNU_LIBRARY__
-/* Don't include stdlib.h for non-GNU C libraries because some of them
-   contain conflicting prototypes for getopt.  */
-# include <stdlib.h>
-# include <unistd.h>
-#endif	/* GNU C library.  */
-
-#ifdef VMS
-# include <unixlib.h>
-# if HAVE_STRING_H - 0
-#  include <string.h>
-# endif
-#endif
-
-/* This is for other GNU distributions with internationalized messages.
-   When compiling libc, the _ macro is predefined.  */
-#include "gettext.h"
-#define _(msgid)    gettext (msgid)
-
-
-/* This version of `getopt' appears to the caller like standard Unix 'getopt'
-   but it behaves differently for the user, since it allows the user
-   to intersperse the options with the other arguments.
-
-   As `getopt' works, it permutes the elements of ARGV so that,
-   when it is done, all the options precede everything else.  Thus
-   all application programs are extended to handle flexible argument order.
-
-   Setting the environment variable POSIXLY_CORRECT disables permutation.
-   Then the behavior is completely standard.
-
-   GNU application programs can use a third alternative mode in which
-   they can distinguish the relative order of options and other arguments.  */
-
-#include "getopt.h"
-
-/* For communication from `getopt' to the caller.
-   When `getopt' finds an option that takes an argument,
-   the argument value is returned here.
-   Also, when `ordering' is RETURN_IN_ORDER,
-   each non-option ARGV-element is returned here.  */
-
-char *optarg = NULL;
-
-/* Index in ARGV of the next element to be scanned.
-   This is used for communication to and from the caller
-   and for communication between successive calls to `getopt'.
-
-   On entry to `getopt', zero means this is the first call; initialize.
-
-   When `getopt' returns -1, this is the index of the first of the
-   non-option elements that the caller should itself scan.
-
-   Otherwise, `optind' communicates from one call to the next
-   how much of ARGV has been scanned so far.  */
-
-/* 1003.2 says this must be 1 before any call.  */
-int optind = 1;
-
-/* Formerly, initialization of getopt depended on optind==0, which
-   causes problems with re-calling getopt as programs generally don't
-   know that. */
-
-int __getopt_initialized = 0;
-
-/* The next char to be scanned in the option-element
-   in which the last option character we returned was found.
-   This allows us to pick up the scan where we left off.
-
-   If this is zero, or a null string, it means resume the scan
-   by advancing to the next ARGV-element.  */
-
-static char *nextchar;
-
-/* Callers store zero here to inhibit the error message
-   for unrecognized options.  */
-
-int opterr = 1;
-
-/* Set to an option character which was unrecognized.
-   This must be initialized on some systems to avoid linking in the
-   system's own getopt implementation.  */
-
-int optopt = '?';
-
-/* Describe how to deal with options that follow non-option ARGV-elements.
-
-   If the caller did not specify anything,
-   the default is REQUIRE_ORDER if the environment variable
-   POSIXLY_CORRECT is defined, PERMUTE otherwise.
-
-   REQUIRE_ORDER means don't recognize them as options;
-   stop option processing when the first non-option is seen.
-   This is what Unix does.
-   This mode of operation is selected by either setting the environment
-   variable POSIXLY_CORRECT, or using `+' as the first character
-   of the list of option characters.
-
-   PERMUTE is the default.  We permute the contents of ARGV as we scan,
-   so that eventually all the non-options are at the end.  This allows options
-   to be given in any order, even with programs that were not written to
-   expect this.
-
-   RETURN_IN_ORDER is an option available to programs that were written
-   to expect options and other ARGV-elements in any order and that care about
-   the ordering of the two.  We describe each non-option ARGV-element
-   as if it were the argument of an option with character code 1.
-   Using `-' as the first character of the list of option characters
-   selects this mode of operation.
-
-   The special argument `--' forces an end of option-scanning regardless
-   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
-   `--' can cause `getopt' to return -1 with `optind' != ARGC.  */
-
-static enum
-{
-  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
-} ordering;
-
-/* Value of POSIXLY_CORRECT environment variable.  */
-static char *posixly_correct;
-
-#ifdef	__GNU_LIBRARY__
-/* We want to avoid inclusion of string.h with non-GNU libraries
-   because there are many ways it can cause trouble.
-   On some systems, it contains special magic macros that don't work
-   in GCC.  */
-# include <string.h>
-# define my_index	strchr
-#else
-
-# if HAVE_STRING_H
-#  include <string.h>
-# else
-#  include <strings.h>
-# endif
-
-/* Avoid depending on library functions or files
-   whose names are inconsistent.  */
-
-#ifndef getenv
-extern char *getenv ();
-#endif
-
-static char *
-my_index (const char *str, int chr)
-{
-  while (*str)
-    {
-      if (*str == chr)
-	return (char *) str;
-      str++;
-    }
-  return 0;
-}
-
-/* If using GCC, we can safely declare strlen this way.
-   If not using GCC, it is ok not to declare it.  */
-#ifdef __GNUC__
-/* Note that Motorola Delta 68k R3V7 comes with GCC but not stddef.h.
-   That was relevant to code that was here before.  */
-# if (!defined __STDC__ || !__STDC__) && !defined strlen
-/* gcc with -traditional declares the built-in strlen to return int,
-   and has done so at least since version 2.4.5. -- rms.  */
-extern int strlen (const char *);
-# endif /* not __STDC__ */
-#endif /* __GNUC__ */
-
-#endif /* not __GNU_LIBRARY__ */
-
-/* Handle permutation of arguments.  */
-
-/* Describe the part of ARGV that contains non-options that have
-   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
-   `last_nonopt' is the index after the last of them.  */
-
-static int first_nonopt;
-static int last_nonopt;
-
-#ifdef _LIBC
-/* Bash 2.0 gives us an environment variable containing flags
-   indicating ARGV elements that should not be considered arguments.  */
-
-/* Defined in getopt_init.c  */
-extern char *__getopt_nonoption_flags;
-
-static int nonoption_flags_max_len;
-static int nonoption_flags_len;
-
-static int original_argc;
-static char *const *original_argv;
-
-/* Make sure the environment variable bash 2.0 puts in the environment
-   is valid for the getopt call we must make sure that the ARGV passed
-   to getopt is that one passed to the process.  */
-static void __attribute__ ((unused))
-store_args_and_env (int argc, char *const *argv)
-{
-  /* XXX This is no good solution.  We should rather copy the args so
-     that we can compare them later.  But we must not use malloc(3).  */
-  original_argc = argc;
-  original_argv = argv;
-}
-# ifdef text_set_element
-text_set_element (__libc_subinit, store_args_and_env);
-# endif /* text_set_element */
-
-# define SWAP_FLAGS(ch1, ch2) \
-  if (nonoption_flags_len > 0)						      \
-    {									      \
-      char __tmp = __getopt_nonoption_flags[ch1];			      \
-      __getopt_nonoption_flags[ch1] = __getopt_nonoption_flags[ch2];	      \
-      __getopt_nonoption_flags[ch2] = __tmp;				      \
-    }
-#else	/* !_LIBC */
-# define SWAP_FLAGS(ch1, ch2)
-#endif	/* _LIBC */
-
-/* Exchange two adjacent subsequences of ARGV.
-   One subsequence is elements [first_nonopt,last_nonopt)
-   which contains all the non-options that have been skipped so far.
-   The other is elements [last_nonopt,optind), which contains all
-   the options processed since those non-options were skipped.
-
-   `first_nonopt' and `last_nonopt' are relocated so that they describe
-   the new indices of the non-options in ARGV after they are moved.  */
-
-#if defined __STDC__ && __STDC__
-static void exchange (char **);
-#endif
-
-static void
-exchange (char **argv)
-{
-  int bottom = first_nonopt;
-  int middle = last_nonopt;
-  int top = optind;
-  char *tem;
-
-  /* Exchange the shorter segment with the far end of the longer segment.
-     That puts the shorter segment into the right place.
-     It leaves the longer segment in the right place overall,
-     but it consists of two parts that need to be swapped next.  */
-
-#ifdef _LIBC
-  /* First make sure the handling of the `__getopt_nonoption_flags'
-     string can work normally.  Our top argument must be in the range
-     of the string.  */
-  if (nonoption_flags_len > 0 && top >= nonoption_flags_max_len)
-    {
-      /* We must extend the array.  The user plays games with us and
-	 presents new arguments.  */
-      char *new_str = malloc (top + 1);
-      if (new_str == NULL)
-	nonoption_flags_len = nonoption_flags_max_len = 0;
-      else
-	{
-	  memset (__mempcpy (new_str, __getopt_nonoption_flags,
-			     nonoption_flags_max_len),
-		  '\0', top + 1 - nonoption_flags_max_len);
-	  nonoption_flags_max_len = top + 1;
-	  __getopt_nonoption_flags = new_str;
-	}
-    }
-#endif
-
-  while (top > middle && middle > bottom)
-    {
-      if (top - middle > middle - bottom)
-	{
-	  /* Bottom segment is the short one.  */
-	  int len = middle - bottom;
-	  register int i;
-
-	  /* Swap it with the top part of the top segment.  */
-	  for (i = 0; i < len; i++)
-	    {
-	      tem = argv[bottom + i];
-	      argv[bottom + i] = argv[top - (middle - bottom) + i];
-	      argv[top - (middle - bottom) + i] = tem;
-	      SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);
-	    }
-	  /* Exclude the moved bottom segment from further swapping.  */
-	  top -= len;
-	}
-      else
-	{
-	  /* Top segment is the short one.  */
-	  int len = top - middle;
-	  register int i;
-
-	  /* Swap it with the bottom part of the bottom segment.  */
-	  for (i = 0; i < len; i++)
-	    {
-	      tem = argv[bottom + i];
-	      argv[bottom + i] = argv[middle + i];
-	      argv[middle + i] = tem;
-	      SWAP_FLAGS (bottom + i, middle + i);
-	    }
-	  /* Exclude the moved top segment from further swapping.  */
-	  bottom += len;
-	}
-    }
-
-  /* Update records for the slots the non-options now occupy.  */
-
-  first_nonopt += (optind - last_nonopt);
-  last_nonopt = optind;
-}
-
-/* Initialize the internal data when the first call is made.  */
-
-#if defined __STDC__ && __STDC__
-static const char *_getopt_initialize (int, char *const *, const char *);
-#endif
-static const char *
-_getopt_initialize (int argc, char *const *argv, const char *optstring)
-{
-  /* Start processing options with ARGV-element 1 (since ARGV-element 0
-     is the program name); the sequence of previously skipped
-     non-option ARGV-elements is empty.  */
-
-  first_nonopt = last_nonopt = optind;
-
-  nextchar = NULL;
-
-  posixly_correct = getenv ("POSIXLY_CORRECT");
-
-  /* Determine how to handle the ordering of options and nonoptions.  */
-
-  if (optstring[0] == '-')
-    {
-      ordering = RETURN_IN_ORDER;
-      ++optstring;
-    }
-  else if (optstring[0] == '+')
-    {
-      ordering = REQUIRE_ORDER;
-      ++optstring;
-    }
-  else if (posixly_correct != NULL)
-    ordering = REQUIRE_ORDER;
-  else
-    ordering = PERMUTE;
-
-#ifdef _LIBC
-  if (posixly_correct == NULL
-      && argc == original_argc && argv == original_argv)
-    {
-      if (nonoption_flags_max_len == 0)
-	{
-	  if (__getopt_nonoption_flags == NULL
-	      || __getopt_nonoption_flags[0] == '\0')
-	    nonoption_flags_max_len = -1;
-	  else
-	    {
-	      const char *orig_str = __getopt_nonoption_flags;
-	      int len = nonoption_flags_max_len = strlen (orig_str);
-	      if (nonoption_flags_max_len < argc)
-		nonoption_flags_max_len = argc;
-	      __getopt_nonoption_flags =
-		(char *) malloc (nonoption_flags_max_len);
-	      if (__getopt_nonoption_flags == NULL)
-		nonoption_flags_max_len = -1;
-	      else
-		memset (__mempcpy (__getopt_nonoption_flags, orig_str, len),
-			'\0', nonoption_flags_max_len - len);
-	    }
-	}
-      nonoption_flags_len = nonoption_flags_max_len;
-    }
-  else
-    nonoption_flags_len = 0;
-#endif
-
-  return optstring;
-}
-
-/* Scan elements of ARGV (whose length is ARGC) for option characters
-   given in OPTSTRING.
-
-   If an element of ARGV starts with '-', and is not exactly "-" or "--",
-   then it is an option element.  The characters of this element
-   (aside from the initial '-') are option characters.  If `getopt'
-   is called repeatedly, it returns successively each of the option characters
-   from each of the option elements.
-
-   If `getopt' finds another option character, it returns that character,
-   updating `optind' and `nextchar' so that the next call to `getopt' can
-   resume the scan with the following option character or ARGV-element.
-
-   If there are no more option characters, `getopt' returns -1.
-   Then `optind' is the index in ARGV of the first ARGV-element
-   that is not an option.  (The ARGV-elements have been permuted
-   so that those that are not options now come last.)
-
-   OPTSTRING is a string containing the legitimate option characters.
-   If an option character is seen that is not listed in OPTSTRING,
-   return '?' after printing an error message.  If you set `opterr' to
-   zero, the error message is suppressed but we still return '?'.
-
-   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
-   so the following text in the same ARGV-element, or the text of the following
-   ARGV-element, is returned in `optarg'.  Two colons mean an option that
-   wants an optional arg; if there is text in the current ARGV-element,
-   it is returned in `optarg', otherwise `optarg' is set to zero.
-
-   If OPTSTRING starts with `-' or `+', it requests different methods of
-   handling the non-option ARGV-elements.
-   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
-
-   Long-named options begin with `--' instead of `-'.
-   Their names may be abbreviated as long as the abbreviation is unique
-   or is an exact match for some defined option.  If they have an
-   argument, it follows the option name in the same ARGV-element, separated
-   from the option name by a `=', or else the in next ARGV-element.
-   When `getopt' finds a long-named option, it returns 0 if that option's
-   `flag' field is nonzero, the value of the option's `val' field
-   if the `flag' field is zero.
-
-   The elements of ARGV aren't really const, because we permute them.
-   But we pretend they're const in the prototype to be compatible
-   with other systems.
-
-   LONGOPTS is a vector of `struct option' terminated by an
-   element containing a name which is zero.
-
-   LONGIND returns the index in LONGOPT of the long-named option found.
-   It is only valid when a long-named option has been found by the most
-   recent call.
-
-   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
-   long-named options.  */
-
-int
-_getopt_internal (int argc, char *const *argv, const char *optstring,
-                  const struct option *longopts, int *longind, int long_only)
-{
-  optarg = NULL;
-
-  if (optind == 0 || !__getopt_initialized)
-    {
-      if (optind == 0)
-	optind = 1;	/* Don't scan ARGV[0], the program name.  */
-      optstring = _getopt_initialize (argc, argv, optstring);
-      __getopt_initialized = 1;
-    }
-
-  /* Test whether ARGV[optind] points to a non-option argument.
-     Either it does not have option syntax, or there is an environment flag
-     from the shell indicating it is not an option.  The later information
-     is only used when the used in the GNU libc.  */
-#ifdef _LIBC
-# define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0'	      \
-		      || (optind < nonoption_flags_len			      \
-			  && __getopt_nonoption_flags[optind] == '1'))
-#else
-# define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0')
-#endif
-
-  if (nextchar == NULL || *nextchar == '\0')
-    {
-      /* Advance to the next ARGV-element.  */
-
-      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been
-	 moved back by the user (who may also have changed the arguments).  */
-      if (last_nonopt > optind)
-	last_nonopt = optind;
-      if (first_nonopt > optind)
-	first_nonopt = optind;
-
-      if (ordering == PERMUTE)
-	{
-	  /* If we have just processed some options following some non-options,
-	     exchange them so that the options come first.  */
-
-	  if (first_nonopt != last_nonopt && last_nonopt != optind)
-	    exchange ((char **) argv);
-	  else if (last_nonopt != optind)
-	    first_nonopt = optind;
-
-	  /* Skip any additional non-options
-	     and extend the range of non-options previously skipped.  */
-
-	  while (optind < argc && NONOPTION_P)
-	    optind++;
-	  last_nonopt = optind;
-	}
-
-      /* The special ARGV-element `--' means premature end of options.
-	 Skip it like a null option,
-	 then exchange with previous non-options as if it were an option,
-	 then skip everything else like a non-option.  */
-
-      if (optind != argc && !strcmp (argv[optind], "--"))
-	{
-	  optind++;
-
-	  if (first_nonopt != last_nonopt && last_nonopt != optind)
-	    exchange ((char **) argv);
-	  else if (first_nonopt == last_nonopt)
-	    first_nonopt = optind;
-	  last_nonopt = argc;
-
-	  optind = argc;
-	}
-
-      /* If we have done all the ARGV-elements, stop the scan
-	 and back over any non-options that we skipped and permuted.  */
-
-      if (optind == argc)
-	{
-	  /* Set the next-arg-index to point at the non-options
-	     that we previously skipped, so the caller will digest them.  */
-	  if (first_nonopt != last_nonopt)
-	    optind = first_nonopt;
-	  return -1;
-	}
-
-      /* If we have come to a non-option and did not permute it,
-	 either stop the scan or describe it to the caller and pass it by.  */
-
-      if (NONOPTION_P)
-	{
-	  if (ordering == REQUIRE_ORDER)
-	    return -1;
-	  optarg = argv[optind++];
-	  return 1;
-	}
-
-      /* We have found another option-ARGV-element.
-	 Skip the initial punctuation.  */
-
-      nextchar = (argv[optind] + 1
-		  + (longopts != NULL && argv[optind][1] == '-'));
-    }
-
-  /* Decode the current option-ARGV-element.  */
-
-  /* Check whether the ARGV-element is a long option.
-
-     If long_only and the ARGV-element has the form "-f", where f is
-     a valid short option, don't consider it an abbreviated form of
-     a long option that starts with f.  Otherwise there would be no
-     way to give the -f short option.
-
-     On the other hand, if there's a long option "fubar" and
-     the ARGV-element is "-fu", do consider that an abbreviation of
-     the long option, just like "--fu", and not "-f" with arg "u".
-
-     This distinction seems to be the most useful approach.  */
-
-  if (longopts != NULL
-      && (argv[optind][1] == '-'
-	  || (long_only && (argv[optind][2] || !my_index (optstring, argv[optind][1])))))
-    {
-      char *nameend;
-      const struct option *p;
-      const struct option *pfound = NULL;
-      int exact = 0;
-      int ambig = 0;
-      int indfound = -1;
-      int option_index;
-
-      for (nameend = nextchar; *nameend && *nameend != '='; nameend++)
-	/* Do nothing.  */ ;
-
-      /* Test all long options for either exact match
-	 or abbreviated matches.  */
-      for (p = longopts, option_index = 0; p->name; p++, option_index++)
-	if (!strncmp (p->name, nextchar, nameend - nextchar))
-	  {
-	    if ((unsigned int) (nameend - nextchar)
-		== (unsigned int) strlen (p->name))
-	      {
-		/* Exact match found.  */
-		pfound = p;
-		indfound = option_index;
-		exact = 1;
-		break;
-	      }
-	    else if (pfound == NULL)
-	      {
-		/* First nonexact match found.  */
-		pfound = p;
-		indfound = option_index;
-	      }
-	    else
-	      /* Second or later nonexact match found.  */
-	      ambig = 1;
-	  }
-
-      if (ambig && !exact)
-	{
-	  if (opterr)
-	    fprintf (stderr, _("%s: option '%s' is ambiguous\n"),
-		     argv[0], argv[optind]);
-	  nextchar += strlen (nextchar);
-	  optind++;
-	  optopt = 0;
-	  return '?';
-	}
-
-      if (pfound != NULL)
-	{
-	  option_index = indfound;
-	  optind++;
-	  if (*nameend)
-	    {
-	      /* Don't test has_arg with >, because some C compilers don't
-		 allow it to be used on enums.  */
-	      if (pfound->has_arg)
-		optarg = nameend + 1;
-	      else
-		{
-		  if (opterr)
-		   if (argv[optind - 1][1] == '-')
-		    /* --option */
-		    fprintf (stderr,
-		     _("%s: option '--%s' doesn't allow an argument\n"),
-		     argv[0], pfound->name);
-		   else
-		    /* +option or -option */
-		    fprintf (stderr,
-		     _("%s: option '%c%s' doesn't allow an argument\n"),
-		     argv[0], argv[optind - 1][0], pfound->name);
-
-		  nextchar += strlen (nextchar);
-
-		  optopt = pfound->val;
-		  return '?';
-		}
-	    }
-	  else if (pfound->has_arg == 1)
-	    {
-	      if (optind < argc)
-		optarg = argv[optind++];
-	      else
-		{
-		  if (opterr)
-		    fprintf (stderr,
-			   _("%s: option '%s' requires an argument\n"),
-			   argv[0], argv[optind - 1]);
-		  nextchar += strlen (nextchar);
-		  optopt = pfound->val;
-		  return optstring[0] == ':' ? ':' : '?';
-		}
-	    }
-	  nextchar += strlen (nextchar);
-	  if (longind != NULL)
-	    *longind = option_index;
-	  if (pfound->flag)
-	    {
-	      *(pfound->flag) = pfound->val;
-	      return 0;
-	    }
-	  return pfound->val;
-	}
-
-      /* Can't find it as a long option.  If this is not getopt_long_only,
-	 or the option starts with '--' or is not a valid short
-	 option, then it's an error.
-	 Otherwise interpret it as a short option.  */
-      if (!long_only || argv[optind][1] == '-'
-	  || my_index (optstring, *nextchar) == NULL)
-	{
-	  if (opterr)
-	    {
-	      if (argv[optind][1] == '-')
-		/* --option */
-		fprintf (stderr, _("%s: unrecognized option '--%s'\n"),
-			 argv[0], nextchar);
-	      else
-		/* +option or -option */
-		fprintf (stderr, _("%s: unrecognized option '%c%s'\n"),
-			 argv[0], argv[optind][0], nextchar);
-	    }
-	  nextchar = (char *) "";
-	  optind++;
-	  optopt = 0;
-	  return '?';
-	}
-    }
-
-  /* Look at and handle the next short option-character.  */
-
-  {
-    char c = *nextchar++;
-    char *temp = my_index (optstring, c);
-
-    /* Increment `optind' when we start to process its last character.  */
-    if (*nextchar == '\0')
-      ++optind;
-
-    if (temp == NULL || c == ':')
-      {
-	if (opterr)
-	  {
-	    if (posixly_correct)
-	      /* 1003.2 specifies the format of this message.  */
-	      fprintf (stderr, _("%s: illegal option -- %c\n"),
-		       argv[0], c);
-	    else
-	      fprintf (stderr, _("%s: invalid option -- %c\n"),
-		       argv[0], c);
-	  }
-	optopt = c;
-	return '?';
-      }
-    /* Convenience. Treat POSIX -W foo same as long option --foo */
-    if (temp[0] == 'W' && temp[1] == ';')
-      {
-	char *nameend;
-	const struct option *p;
-	const struct option *pfound = NULL;
-	int exact = 0;
-	int ambig = 0;
-	int indfound = 0;
-	int option_index;
-
-	/* This is an option that requires an argument.  */
-	if (*nextchar != '\0')
-	  {
-	    optarg = nextchar;
-	    /* If we end this ARGV-element by taking the rest as an arg,
-	       we must advance to the next element now.  */
-	    optind++;
-	  }
-	else if (optind == argc)
-	  {
-	    if (opterr)
-	      {
-		/* 1003.2 specifies the format of this message.  */
-		fprintf (stderr, _("%s: option requires an argument -- %c\n"),
-			 argv[0], c);
-	      }
-	    optopt = c;
-	    if (optstring[0] == ':')
-	      c = ':';
-	    else
-	      c = '?';
-	    return c;
-	  }
-	else
-	  /* We already incremented `optind' once;
-	     increment it again when taking next ARGV-elt as argument.  */
-	  optarg = argv[optind++];
-
-	/* optarg is now the argument, see if it's in the
-	   table of longopts.  */
-
-	for (nextchar = nameend = optarg; *nameend && *nameend != '='; nameend++)
-	  /* Do nothing.  */ ;
-
-	/* Test all long options for either exact match
-	   or abbreviated matches.  */
-	for (p = longopts, option_index = 0; p->name; p++, option_index++)
-	  if (!strncmp (p->name, nextchar, nameend - nextchar))
-	    {
-	      if ((unsigned int) (nameend - nextchar) == strlen (p->name))
-		{
-		  /* Exact match found.  */
-		  pfound = p;
-		  indfound = option_index;
-		  exact = 1;
-		  break;
-		}
-	      else if (pfound == NULL)
-		{
-		  /* First nonexact match found.  */
-		  pfound = p;
-		  indfound = option_index;
-		}
-	      else
-		/* Second or later nonexact match found.  */
-		ambig = 1;
-	    }
-	if (ambig && !exact)
-	  {
-	    if (opterr)
-	      fprintf (stderr, _("%s: option '-W %s' is ambiguous\n"),
-		       argv[0], argv[optind]);
-	    nextchar += strlen (nextchar);
-	    optind++;
-	    return '?';
-	  }
-	if (pfound != NULL)
-	  {
-	    option_index = indfound;
-	    if (*nameend)
-	      {
-		/* Don't test has_arg with >, because some C compilers don't
-		   allow it to be used on enums.  */
-		if (pfound->has_arg)
-		  optarg = nameend + 1;
-		else
-		  {
-		    if (opterr)
-		      fprintf (stderr, _("\
-%s: option '-W %s' doesn't allow an argument\n"),
-			       argv[0], pfound->name);
-
-		    nextchar += strlen (nextchar);
-		    return '?';
-		  }
-	      }
-	    else if (pfound->has_arg == 1)
-	      {
-		if (optind < argc)
-		  optarg = argv[optind++];
-		else
-		  {
-		    if (opterr)
-		      fprintf (stderr,
-			       _("%s: option '%s' requires an argument\n"),
-			       argv[0], argv[optind - 1]);
-		    nextchar += strlen (nextchar);
-		    return optstring[0] == ':' ? ':' : '?';
-		  }
-	      }
-	    nextchar += strlen (nextchar);
-	    if (longind != NULL)
-	      *longind = option_index;
-	    if (pfound->flag)
-	      {
-		*(pfound->flag) = pfound->val;
-		return 0;
-	      }
-	    return pfound->val;
-	  }
-	  nextchar = NULL;
-	  return 'W';	/* Let the application handle it.   */
-      }
-    if (temp[1] == ':')
-      {
-	if (temp[2] == ':')
-	  {
-	    /* This is an option that accepts an argument optionally.  */
-	    if (*nextchar != '\0')
-	      {
-		optarg = nextchar;
-		optind++;
-	      }
-	    else
-	      optarg = NULL;
-	    nextchar = NULL;
-	  }
-	else
-	  {
-	    /* This is an option that requires an argument.  */
-	    if (*nextchar != '\0')
-	      {
-		optarg = nextchar;
-		/* If we end this ARGV-element by taking the rest as an arg,
-		   we must advance to the next element now.  */
-		optind++;
-	      }
-	    else if (optind == argc)
-	      {
-		if (opterr)
-		  {
-		    /* 1003.2 specifies the format of this message.  */
-		    fprintf (stderr,
-			   _("%s: option requires an argument -- %c\n"),
-			   argv[0], c);
-		  }
-		optopt = c;
-		if (optstring[0] == ':')
-		  c = ':';
-		else
-		  c = '?';
-	      }
-	    else
-	      /* We already incremented `optind' once;
-		 increment it again when taking next ARGV-elt as argument.  */
-	      optarg = argv[optind++];
-	    nextchar = NULL;
-	  }
-      }
-    return c;
-  }
-}
-
-int
-getopt (int argc, char *const *argv, const char *optstring)
-{
-  return _getopt_internal (argc, argv, optstring,
-			   (const struct option *) 0,
-			   (int *) 0,
-			   0);
-}
-
-#endif	/* Not ELIDE_CODE.  */
-
-#ifdef TEST
-
-/* Compile with -DTEST to make an executable for use in testing
-   the above definition of `getopt'.  */
-
-int
-main (int argc, char **argv)
-{
-  int c;
-  int digit_optind = 0;
-
-  while (1)
-    {
-      int this_option_optind = optind ? optind : 1;
-
-      c = getopt (argc, argv, "abc:d:0123456789");
-      if (c == -1)
-	break;
-
-      switch (c)
-	{
-	case '0':
-	case '1':
-	case '2':
-	case '3':
-	case '4':
-	case '5':
-	case '6':
-	case '7':
-	case '8':
-	case '9':
-	  if (digit_optind != 0 && digit_optind != this_option_optind)
-	    printf ("digits occur in two different argv-elements.\n");
-	  digit_optind = this_option_optind;
-	  printf ("option %c\n", c);
-	  break;
-
-	case 'a':
-	  printf ("option a\n");
-	  break;
-
-	case 'b':
-	  printf ("option b\n");
-	  break;
-
-	case 'c':
-	  printf ("option c with value '%s'\n", optarg);
-	  break;
-
-	case '?':
-	  break;
-
-	default:
-	  printf ("?? getopt returned character code 0%o ??\n", c);
-	}
-    }
-
-  if (optind < argc)
-    {
-      printf ("non-option ARGV-elements: ");
-      while (optind < argc)
-	printf ("%s ", argv[optind++]);
-      printf ("\n");
-    }
-
-  exit (0);
-}
-
-#endif /* TEST */
diff --git a/getopt.h b/getopt.h
deleted file mode 100644
index bb756fa..0000000
--- a/getopt.h
+++ /dev/null
@@ -1,130 +0,0 @@
-/* Declarations for getopt.
-Copyright (C) 1989-2017 Free Software Foundation, Inc.
-
-NOTE: The canonical source of this file is maintained with the GNU C Library.
-Bugs can be reported to bug-glibc@gnu.org.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#ifndef _GETOPT_H
-#define _GETOPT_H 1
-
-#ifdef	__cplusplus
-extern "C" {
-#endif
-
-/* For communication from `getopt' to the caller.
-   When `getopt' finds an option that takes an argument,
-   the argument value is returned here.
-   Also, when `ordering' is RETURN_IN_ORDER,
-   each non-option ARGV-element is returned here.  */
-
-extern char *optarg;
-
-/* Index in ARGV of the next element to be scanned.
-   This is used for communication to and from the caller
-   and for communication between successive calls to `getopt'.
-
-   On entry to `getopt', zero means this is the first call; initialize.
-
-   When `getopt' returns -1, this is the index of the first of the
-   non-option elements that the caller should itself scan.
-
-   Otherwise, `optind' communicates from one call to the next
-   how much of ARGV has been scanned so far.  */
-
-extern int optind;
-
-/* Callers store zero here to inhibit the error message `getopt' prints
-   for unrecognized options.  */
-
-extern int opterr;
-
-/* Set to an option character which was unrecognized.  */
-
-extern int optopt;
-
-/* Describe the long-named options requested by the application.
-   The LONG_OPTIONS argument to getopt_long or getopt_long_only is a vector
-   of `struct option' terminated by an element containing a name which is
-   zero.
-
-   The field `has_arg' is:
-   no_argument		(or 0) if the option does not take an argument,
-   required_argument	(or 1) if the option requires an argument,
-   optional_argument 	(or 2) if the option takes an optional argument.
-
-   If the field `flag' is not NULL, it points to a variable that is set
-   to the value given in the field `val' when the option is found, but
-   left unchanged if the option is not found.
-
-   To have a long-named option do something other than set an `int' to
-   a compiled-in constant, such as set a value from `optarg', set the
-   option's `flag' field to zero and its `val' field to a nonzero
-   value (the equivalent single-letter option character, if there is
-   one).  For long options that have a zero `flag' field, `getopt'
-   returns the contents of the `val' field.  */
-
-struct option
-{
-#if defined (__STDC__) && __STDC__
-  const char *name;
-#else
-  char *name;
-#endif
-  /* has_arg can't be an enum because some compilers complain about
-     type mismatches in all the code that assumes it is an int.  */
-  int has_arg;
-  int *flag;
-  int val;
-};
-
-/* Names for the values of the `has_arg' field of `struct option'.  */
-
-#define	no_argument		0
-#define required_argument	1
-#define optional_argument	2
-
-#if defined (__STDC__) && __STDC__
-#ifdef __GNU_LIBRARY__
-/* Many other libraries have conflicting prototypes for getopt, with
-   differences in the consts, in stdlib.h.  To avoid compilation
-   errors, only prototype getopt for the GNU C library.  */
-extern int getopt (int argc, char *const *argv, const char *shortopts);
-#else /* not __GNU_LIBRARY__ */
-extern int getopt ();
-#endif /* __GNU_LIBRARY__ */
-extern int getopt_long (int argc, char *const *argv, const char *shortopts,
-		        const struct option *longopts, int *longind);
-extern int getopt_long_only (int argc, char *const *argv,
-			     const char *shortopts,
-		             const struct option *longopts, int *longind);
-
-/* Internal only.  Users should not call this directly.  */
-extern int _getopt_internal (int argc, char *const *argv,
-			     const char *shortopts,
-		             const struct option *longopts, int *longind,
-			     int long_only);
-#else /* not __STDC__ */
-extern int getopt ();
-extern int getopt_long ();
-extern int getopt_long_only ();
-
-extern int _getopt_internal ();
-#endif /* __STDC__ */
-
-#ifdef	__cplusplus
-}
-#endif
-
-#endif /* getopt.h */
diff --git a/getopt1.c b/getopt1.c
deleted file mode 100644
index 5d0240a..0000000
--- a/getopt1.c
+++ /dev/null
@@ -1,176 +0,0 @@
-/* getopt_long and getopt_long_only entry points for GNU getopt.
-Copyright (C) 1987-1994, 1996-2017 Free Software Foundation, Inc.
-
-NOTE: The canonical source of this file is maintained with the GNU C Library.
-Bugs can be reported to bug-glibc@gnu.org.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "getopt.h"
-
-#if !defined __STDC__ || !__STDC__
-/* This is a separate conditional since some stdc systems
-   reject `defined (const)'.  */
-#ifndef const
-#define const
-#endif
-#endif
-
-#include <stdio.h>
-
-/* Comment out all this code if we are using the GNU C Library, and are not
-   actually compiling the library itself.  This code is part of the GNU C
-   Library, but also included in many other GNU distributions.  Compiling
-   and linking in this code is a waste when using the GNU C library
-   (especially if it is a shared library).  Rather than having every GNU
-   program understand `configure --with-gnu-libc' and omit the object files,
-   it is simpler to just do this in the source for each such file.  */
-
-#define GETOPT_INTERFACE_VERSION 2
-#if !defined _LIBC && defined __GLIBC__ && __GLIBC__ >= 2
-#include <gnu-versions.h>
-#if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION
-#define ELIDE_CODE
-#endif
-#endif
-
-#ifndef ELIDE_CODE
-
-
-/* This needs to come after some library #include
-   to get __GNU_LIBRARY__ defined.  */
-#ifdef __GNU_LIBRARY__
-#include <stdlib.h>
-#endif
-
-#ifndef	NULL
-#define NULL 0
-#endif
-
-int
-getopt_long (int argc, char *const *argv, const char *options,
-             const struct option *long_options, int *opt_index)
-{
-  return _getopt_internal (argc, argv, options, long_options, opt_index, 0);
-}
-
-/* Like getopt_long, but '-' as well as '--' can indicate a long option.
-   If an option that starts with '-' (not '--') doesn't match a long option,
-   but does match a short option, it is parsed as a short option
-   instead.  */
-
-int
-getopt_long_only (int argc, char *const *argv, const char *options,
-                  const struct option *long_options, int *opt_index)
-{
-  return _getopt_internal (argc, argv, options, long_options, opt_index, 1);
-}
-
-
-#endif	/* Not ELIDE_CODE.  */
-
-#ifdef TEST
-
-#include <stdio.h>
-
-int
-main (int argc, char **argv)
-{
-  int c;
-  int digit_optind = 0;
-
-  while (1)
-    {
-      int this_option_optind = optind ? optind : 1;
-      int option_index = 0;
-      static struct option long_options[] =
-      {
-	{"add", 1, 0, 0},
-	{"append", 0, 0, 0},
-	{"delete", 1, 0, 0},
-	{"verbose", 0, 0, 0},
-	{"create", 0, 0, 0},
-	{"file", 1, 0, 0},
-	{0, 0, 0, 0}
-      };
-
-      c = getopt_long (argc, argv, "abc:d:0123456789",
-		       long_options, &option_index);
-      if (c == -1)
-	break;
-
-      switch (c)
-	{
-	case 0:
-	  printf ("option %s", long_options[option_index].name);
-	  if (optarg)
-	    printf (" with arg %s", optarg);
-	  printf ("\n");
-	  break;
-
-	case '0':
-	case '1':
-	case '2':
-	case '3':
-	case '4':
-	case '5':
-	case '6':
-	case '7':
-	case '8':
-	case '9':
-	  if (digit_optind != 0 && digit_optind != this_option_optind)
-	    printf ("digits occur in two different argv-elements.\n");
-	  digit_optind = this_option_optind;
-	  printf ("option %c\n", c);
-	  break;
-
-	case 'a':
-	  printf ("option a\n");
-	  break;
-
-	case 'b':
-	  printf ("option b\n");
-	  break;
-
-	case 'c':
-	  printf ("option c with value '%s'\n", optarg);
-	  break;
-
-	case 'd':
-	  printf ("option d with value '%s'\n", optarg);
-	  break;
-
-	case '?':
-	  break;
-
-	default:
-	  printf ("?? getopt returned character code 0%o ??\n", c);
-	}
-    }
-
-  if (optind < argc)
-    {
-      printf ("non-option ARGV-elements: ");
-      while (optind < argc)
-	printf ("%s ", argv[optind++]);
-      printf ("\n");
-    }
-
-  exit (0);
-}
-
-#endif /* TEST */
diff --git a/gettext.h b/gettext.h
deleted file mode 100644
index 10992fb..0000000
--- a/gettext.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/* Convenience header for conditional use of GNU <libintl.h>.
-Copyright (C) 1995-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#ifndef _LIBGETTEXT_H
-#define _LIBGETTEXT_H 1
-
-/* NLS can be disabled through the configure --disable-nls option.  */
-#if ENABLE_NLS
-
-/* Get declarations of GNU message catalog functions.  */
-# include <libintl.h>
-
-#else
-
-/* Disabled NLS.
-   The casts to 'const char *' serve the purpose of producing warnings
-   for invalid uses of the value returned from these functions.
-   On pre-ANSI systems without 'const', the config.h file is supposed to
-   contain "#define const".  */
-# define gettext(Msgid) ((const char *) (Msgid))
-# define dgettext(Domainname, Msgid) ((const char *) (Msgid))
-# define dcgettext(Domainname, Msgid, Category) ((const char *) (Msgid))
-# define ngettext(Msgid1, Msgid2, N) \
-    ((N) == 1 ? (const char *) (Msgid1) : (const char *) (Msgid2))
-# define dngettext(Domainname, Msgid1, Msgid2, N) \
-    ((N) == 1 ? (const char *) (Msgid1) : (const char *) (Msgid2))
-# define dcngettext(Domainname, Msgid1, Msgid2, N, Category) \
-    ((N) == 1 ? (const char *) (Msgid1) : (const char *) (Msgid2))
-# define textdomain(Domainname) ((const char *) (Domainname))
-# define bindtextdomain(Domainname, Dirname) ((const char *) (Dirname))
-# define bind_textdomain_codeset(Domainname, Codeset) ((const char *) (Codeset))
-
-#endif
-
-/* A pseudo function call that serves as a marker for the automated
-   extraction of messages, but does not call gettext().  The run-time
-   translation is done at a different place in the code.
-   The argument, String, should be a literal string.  Concatenated strings
-   and other string expressions won't work.
-   The macro's expansion is not parenthesized, so that it is suitable as
-   initializer for static 'char[]' or 'const char[]' variables.  */
-#define gettext_noop(String) String
-
-#endif /* _LIBGETTEXT_H */
diff --git a/gmk-default.scm b/gmk-default.scm
deleted file mode 100644
index a827cae..0000000
--- a/gmk-default.scm
+++ /dev/null
@@ -1,53 +0,0 @@
-;; Contents of the (gnu make) Guile module
-;; Copyright (C) 2011-2017 Free Software Foundation, Inc.
-;; This file is part of GNU Make.
-;;
-;; GNU Make is free software; you can redistribute it and/or modify it under
-;; the terms of the GNU General Public License as published by the Free
-;; Software Foundation; either version 3 of the License, or (at your option)
-;; any later version.
-;;
-;; GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-;; WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
-;; FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
-;; details.
-;;
-;; You should have received a copy of the GNU General Public License along
-;; with this program.  If not, see <http://www.gnu.org/licenses/>.
-
-(define (to-string-maybe x)
-  (cond
-   ;; In GNU make, "false" is the empty string
-   ((or (not x)
-        (unspecified? x)
-        (variable? x)
-        (null? x)
-        (and (string? x) (string-null? x)))
-    #f)
-   ;; We want something not false... not sure about this
-   ((eq? x #t) "#t")
-   ;; Basics
-   ((or (symbol? x) (number? x))
-    (object->string x))
-   ((char? x)
-    (string x))
-   ;; Printable string (no special characters)
-   ((and (string? x) (string-every char-set:printing x))
-    x)
-   ;; No idea: fail
-   (else (error "Unknown object:" x))))
-
-(define (obj-to-str x)
-  (let ((acc '()))
-    (define (walk x)
-      (cond ((pair? x) (walk (car x)) (walk (cdr x)))
-            ((to-string-maybe x) => (lambda (s) (set! acc (cons s acc))))))
-    (walk x)
-    (string-join (reverse! acc))))
-
-;; Return the value of the GNU make variable V
-(define (gmk-var v)
-  (gmk-expand (format #f "$(~a)" (obj-to-str v))))
-
-;; Export the public interfaces
-(export gmk-expand gmk-eval gmk-var)
diff --git a/gnumake.h b/gnumake.h
deleted file mode 100644
index c1a44ec..0000000
--- a/gnumake.h
+++ /dev/null
@@ -1,79 +0,0 @@
-/* External interfaces usable by dynamic objects loaded into GNU Make.
-   --THIS API IS A "TECHNOLOGY PREVIEW" ONLY.  IT IS NOT A STABLE INTERFACE--
-
-Copyright (C) 2013-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#ifndef _GNUMAKE_H_
-#define _GNUMAKE_H_
-
-/* Specify the location of elements read from makefiles.  */
-typedef struct
-  {
-    const char *filenm;
-    unsigned long lineno;
-  } gmk_floc;
-
-typedef char *(*gmk_func_ptr)(const char *nm, unsigned int argc, char **argv);
-
-#ifdef _WIN32
-# ifdef GMK_BUILDING_MAKE
-#  define GMK_EXPORT  __declspec(dllexport)
-# else
-#  define GMK_EXPORT  __declspec(dllimport)
-# endif
-#else
-# define GMK_EXPORT
-#endif
-
-/* Free memory returned by the gmk_expand() function.  */
-GMK_EXPORT void gmk_free (char *str);
-
-/* Allocate memory in GNU make's context.  */
-GMK_EXPORT char *gmk_alloc (unsigned int len);
-
-/* Run $(eval ...) on the provided string BUFFER.  */
-GMK_EXPORT void gmk_eval (const char *buffer, const gmk_floc *floc);
-
-/* Run GNU make expansion on the provided string STR.
-   Returns an allocated buffer that the caller must free with gmk_free().  */
-GMK_EXPORT char *gmk_expand (const char *str);
-
-/* Register a new GNU make function NAME (maximum of 255 chars long).
-   When the function is expanded in the makefile, FUNC will be invoked with
-   the appropriate arguments.
-
-   The return value of FUNC must be either NULL, in which case it expands to
-   the empty string, or a pointer to the result of the expansion in a string
-   created by gmk_alloc().  GNU make will free the memory when it's done.
-
-   MIN_ARGS is the minimum number of arguments the function requires.
-   MAX_ARGS is the maximum number of arguments (or 0 if there's no maximum).
-   MIN_ARGS and MAX_ARGS may not exceed 255.
-
-   The FLAGS value may be GMK_FUNC_DEFAULT, or one or more of the following
-   flags OR'd together:
-
-     GMK_FUNC_NOEXPAND: the arguments to the function will be not be expanded
-                        before FUNC is called.
-*/
-GMK_EXPORT void gmk_add_function (const char *name, gmk_func_ptr func,
-                                  unsigned int min_args, unsigned int max_args,
-                                  unsigned int flags);
-
-#define GMK_FUNC_DEFAULT    0x00
-#define GMK_FUNC_NOEXPAND   0x01
-
-#endif  /* _GNUMAKE_H_ */
diff --git a/guile.c b/guile.c
deleted file mode 100644
index a593666..0000000
--- a/guile.c
+++ /dev/null
@@ -1,159 +0,0 @@
-/* GNU Guile interface for GNU Make.
-Copyright (C) 2011-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-
-#ifdef HAVE_GUILE
-
-#include "gnumake.h"
-
-#include "debug.h"
-#include "filedef.h"
-#include "dep.h"
-#include "variable.h"
-
-#include <libguile.h>
-
-/* Pre-2.0 versions of Guile don't have a typedef for gsubr function types.  */
-#if SCM_MAJOR_VERSION < 2
-# define GSUBR_TYPE         SCM (*) ()
-/* Guile 1.x doesn't really support i18n.  */
-# define EVAL_STRING(_s)    scm_c_eval_string (_s)
-#else
-# define GSUBR_TYPE         scm_t_subr
-# define EVAL_STRING(_s)    scm_eval_string (scm_from_utf8_string (_s))
-#endif
-
-static SCM make_mod = SCM_EOL;
-static SCM obj_to_str = SCM_EOL;
-
-/* Convert an SCM object into a string.  */
-static char *
-cvt_scm_to_str (SCM obj)
-{
-  return scm_to_locale_string (scm_call_1 (obj_to_str, obj));
-}
-
-/* Perform the GNU make expansion function.  */
-static SCM
-guile_expand_wrapper (SCM obj)
-{
-  char *str = cvt_scm_to_str (obj);
-  SCM ret;
-  char *res;
-
-  DB (DB_BASIC, (_("guile: Expanding '%s'\n"), str));
-  res = gmk_expand (str);
-  ret = scm_from_locale_string (res);
-
-  free (str);
-  free (res);
-
-  return ret;
-}
-
-/* Perform the GNU make eval function.  */
-static SCM
-guile_eval_wrapper (SCM obj)
-{
-  char *str = cvt_scm_to_str (obj);
-
-  DB (DB_BASIC, (_("guile: Evaluating '%s'\n"), str));
-  gmk_eval (str, 0);
-
-  return SCM_BOOL_F;
-}
-
-/* Invoked by scm_c_define_module(), in the context of the GNU make module.  */
-static void
-guile_define_module (void *data UNUSED)
-{
-/* Ingest the predefined Guile module for GNU make.  */
-#include "gmk-default.h"
-
-  /* Register a subr for GNU make's eval capability.  */
-  scm_c_define_gsubr ("gmk-expand", 1, 0, 0, (GSUBR_TYPE) guile_expand_wrapper);
-
-  /* Register a subr for GNU make's eval capability.  */
-  scm_c_define_gsubr ("gmk-eval", 1, 0, 0, (GSUBR_TYPE) guile_eval_wrapper);
-
-  /* Define the rest of the module.  */
-  scm_c_eval_string (GUILE_module_defn);
-}
-
-/* Initialize the GNU make Guile module.  */
-static void *
-guile_init (void *arg UNUSED)
-{
-  /* Define the module.  */
-  make_mod = scm_c_define_module ("gnu make", guile_define_module, NULL);
-
-  /* Get a reference to the object-to-string translator, for later.  */
-  obj_to_str = scm_variable_ref (scm_c_module_lookup (make_mod, "obj-to-str"));
-
-  /* Import the GNU make module exports into the generic space.  */
-  scm_c_eval_string ("(use-modules (gnu make))");
-
-  return NULL;
-}
-
-static void *
-internal_guile_eval (void *arg)
-{
-  return cvt_scm_to_str (EVAL_STRING (arg));
-}
-
-/* This is the function registered with make  */
-static char *
-func_guile (const char *funcname UNUSED, unsigned int argc UNUSED, char **argv)
-{
-  static int init = 0;
-
-  if (! init)
-    {
-      /* Initialize the Guile interpreter.  */
-      scm_with_guile (guile_init, NULL);
-      init = 1;
-    }
-
-  if (argv[0] && argv[0][0] != '\0')
-    return scm_with_guile (internal_guile_eval, argv[0]);
-
-  return NULL;
-}
-
-/* ----- Public interface ----- */
-
-/* We could send the flocp to define_new_function(), but since guile is
-   "kind of" built-in, that didn't seem so useful.  */
-int
-guile_gmake_setup (const floc *flocp UNUSED)
-{
-  /* Create a make function "guile".  */
-  gmk_add_function ("guile", func_guile, 0, 1, GMK_FUNC_DEFAULT);
-
-  return 1;
-}
-
-#else
-
-int
-guile_gmake_setup (const floc *flocp UNUSED)
-{
-  return 1;
-}
-
-#endif
diff --git a/hash.c b/hash.c
deleted file mode 100644
index c138aaf..0000000
--- a/hash.c
+++ /dev/null
@@ -1,477 +0,0 @@
-/* hash.c -- hash table maintenance
-Copyright (C) 1995, 1999, 2002, 2010 Free Software Foundation, Inc.
-Written by Greg McGary <gkm@gnu.org> <greg@mcgary.org>
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-#include "hash.h"
-
-#define	CALLOC(t, n) ((t *) xcalloc (sizeof (t) * (n)))
-#define MALLOC(t, n) ((t *) xmalloc (sizeof (t) * (n)))
-#define REALLOC(o, t, n) ((t *) xrealloc ((o), sizeof (t) * (n)))
-#define CLONE(o, t, n) ((t *) memcpy (MALLOC (t, (n)), (o), sizeof (t) * (n)))
-
-static void hash_rehash __P((struct hash_table* ht));
-static unsigned long round_up_2 __P((unsigned long rough));
-
-/* Implement double hashing with open addressing.  The table size is
-   always a power of two.  The secondary ('increment') hash function
-   is forced to return an odd-value, in order to be relatively prime
-   to the table size.  This guarantees that the increment can
-   potentially hit every slot in the table during collision
-   resolution.  */
-
-void *hash_deleted_item = &hash_deleted_item;
-
-/* Force the table size to be a power of two, possibly rounding up the
-   given size.  */
-
-void
-hash_init (struct hash_table *ht, unsigned long size,
-           hash_func_t hash_1, hash_func_t hash_2, hash_cmp_func_t hash_cmp)
-{
-  ht->ht_size = round_up_2 (size);
-  ht->ht_empty_slots = ht->ht_size;
-  ht->ht_vec = (void**) CALLOC (struct token *, ht->ht_size);
-  if (ht->ht_vec == 0)
-    {
-      fprintf (stderr, _("can't allocate %lu bytes for hash table: memory exhausted"),
-	       ht->ht_size * (unsigned long) sizeof (struct token *));
-      exit (MAKE_TROUBLE);
-    }
-
-  ht->ht_capacity = ht->ht_size - (ht->ht_size / 16); /* 93.75% loading factor */
-  ht->ht_fill = 0;
-  ht->ht_collisions = 0;
-  ht->ht_lookups = 0;
-  ht->ht_rehashes = 0;
-  ht->ht_hash_1 = hash_1;
-  ht->ht_hash_2 = hash_2;
-  ht->ht_compare = hash_cmp;
-}
-
-/* Load an array of items into 'ht'.  */
-
-void
-hash_load (struct hash_table *ht, void *item_table,
-           unsigned long cardinality, unsigned long size)
-{
-  char *items = (char *) item_table;
-  while (cardinality--)
-    {
-      hash_insert (ht, items);
-      items += size;
-    }
-}
-
-/* Returns the address of the table slot matching 'key'.  If 'key' is
-   not found, return the address of an empty slot suitable for
-   inserting 'key'.  The caller is responsible for incrementing
-   ht_fill on insertion.  */
-
-void **
-hash_find_slot (struct hash_table *ht, const void *key)
-{
-  void **slot;
-  void **deleted_slot = 0;
-  unsigned int hash_2 = 0;
-  unsigned int hash_1 = (*ht->ht_hash_1) (key);
-
-  ht->ht_lookups++;
-  for (;;)
-    {
-      hash_1 &= (ht->ht_size - 1);
-      slot = &ht->ht_vec[hash_1];
-
-      if (*slot == 0)
-	return (deleted_slot ? deleted_slot : slot);
-      if (*slot == hash_deleted_item)
-	{
-	  if (deleted_slot == 0)
-	    deleted_slot = slot;
-	}
-      else
-	{
-	  if (key == *slot)
-	    return slot;
-	  if ((*ht->ht_compare) (key, *slot) == 0)
-	    return slot;
-	  ht->ht_collisions++;
-	}
-      if (!hash_2)
-	  hash_2 = (*ht->ht_hash_2) (key) | 1;
-      hash_1 += hash_2;
-    }
-}
-
-void *
-hash_find_item (struct hash_table *ht, const void *key)
-{
-  void **slot = hash_find_slot (ht, key);
-  return ((HASH_VACANT (*slot)) ? 0 : *slot);
-}
-
-void *
-hash_insert (struct hash_table *ht, const void *item)
-{
-  void **slot = hash_find_slot (ht, item);
-  const void *old_item = *slot;
-  hash_insert_at (ht, item, slot);
-  return (void *)((HASH_VACANT (old_item)) ? 0 : old_item);
-}
-
-void *
-hash_insert_at (struct hash_table *ht, const void *item, const void *slot)
-{
-  const void *old_item = *(void **) slot;
-  if (HASH_VACANT (old_item))
-    {
-      ht->ht_fill++;
-      if (old_item == 0)
-	ht->ht_empty_slots--;
-      old_item = item;
-    }
-  *(void const **) slot = item;
-  if (ht->ht_empty_slots < ht->ht_size - ht->ht_capacity)
-    {
-      hash_rehash (ht);
-      return (void *) hash_find_slot (ht, item);
-    }
-  else
-    return (void *) slot;
-}
-
-void *
-hash_delete (struct hash_table *ht, const void *item)
-{
-  void **slot = hash_find_slot (ht, item);
-  return hash_delete_at (ht, slot);
-}
-
-void *
-hash_delete_at (struct hash_table *ht, const void *slot)
-{
-  void *item = *(void **) slot;
-  if (!HASH_VACANT (item))
-    {
-      *(void const **) slot = hash_deleted_item;
-      ht->ht_fill--;
-      return item;
-    }
-  else
-    return 0;
-}
-
-void
-hash_free_items (struct hash_table *ht)
-{
-  void **vec = ht->ht_vec;
-  void **end = &vec[ht->ht_size];
-  for (; vec < end; vec++)
-    {
-      void *item = *vec;
-      if (!HASH_VACANT (item))
-	free (item);
-      *vec = 0;
-    }
-  ht->ht_fill = 0;
-  ht->ht_empty_slots = ht->ht_size;
-}
-
-void
-hash_delete_items (struct hash_table *ht)
-{
-  void **vec = ht->ht_vec;
-  void **end = &vec[ht->ht_size];
-  for (; vec < end; vec++)
-    *vec = 0;
-  ht->ht_fill = 0;
-  ht->ht_collisions = 0;
-  ht->ht_lookups = 0;
-  ht->ht_rehashes = 0;
-  ht->ht_empty_slots = ht->ht_size;
-}
-
-void
-hash_free (struct hash_table *ht, int free_items)
-{
-  if (free_items)
-    hash_free_items (ht);
-  else
-    {
-      ht->ht_fill = 0;
-      ht->ht_empty_slots = ht->ht_size;
-    }
-  free (ht->ht_vec);
-  ht->ht_vec = 0;
-  ht->ht_capacity = 0;
-}
-
-void
-hash_map (struct hash_table *ht, hash_map_func_t map)
-{
-  void **slot;
-  void **end = &ht->ht_vec[ht->ht_size];
-
-  for (slot = ht->ht_vec; slot < end; slot++)
-    {
-      if (!HASH_VACANT (*slot))
-	(*map) (*slot);
-    }
-}
-
-void
-hash_map_arg (struct hash_table *ht, hash_map_arg_func_t map, void *arg)
-{
-  void **slot;
-  void **end = &ht->ht_vec[ht->ht_size];
-
-  for (slot = ht->ht_vec; slot < end; slot++)
-    {
-      if (!HASH_VACANT (*slot))
-	(*map) (*slot, arg);
-    }
-}
-
-/* Double the size of the hash table in the event of overflow... */
-
-static void
-hash_rehash (struct hash_table *ht)
-{
-  unsigned long old_ht_size = ht->ht_size;
-  void **old_vec = ht->ht_vec;
-  void **ovp;
-
-  if (ht->ht_fill >= ht->ht_capacity)
-    {
-      ht->ht_size *= 2;
-      ht->ht_capacity = ht->ht_size - (ht->ht_size >> 4);
-    }
-  ht->ht_rehashes++;
-  ht->ht_vec = (void **) CALLOC (struct token *, ht->ht_size);
-
-  for (ovp = old_vec; ovp < &old_vec[old_ht_size]; ovp++)
-    {
-      if (! HASH_VACANT (*ovp))
-	{
-	  void **slot = hash_find_slot (ht, *ovp);
-	  *slot = *ovp;
-	}
-    }
-  ht->ht_empty_slots = ht->ht_size - ht->ht_fill;
-  free (old_vec);
-}
-
-void
-hash_print_stats (struct hash_table *ht, FILE *out_FILE)
-{
-  fprintf (out_FILE, _("Load=%lu/%lu=%.0f%%, "), ht->ht_fill, ht->ht_size,
-	   100.0 * (double) ht->ht_fill / (double) ht->ht_size);
-  fprintf (out_FILE, _("Rehash=%u, "), ht->ht_rehashes);
-  fprintf (out_FILE, _("Collisions=%lu/%lu=%.0f%%"), ht->ht_collisions, ht->ht_lookups,
-	   (ht->ht_lookups
-	    ? (100.0 * (double) ht->ht_collisions / (double) ht->ht_lookups)
-	    : 0));
-}
-
-/* Dump all items into a NULL-terminated vector.  Use the
-   user-supplied vector, or malloc one.  */
-
-void **
-hash_dump (struct hash_table *ht, void **vector_0, qsort_cmp_t compare)
-{
-  void **vector;
-  void **slot;
-  void **end = &ht->ht_vec[ht->ht_size];
-
-  if (vector_0 == 0)
-    vector_0 = MALLOC (void *, ht->ht_fill + 1);
-  vector = vector_0;
-
-  for (slot = ht->ht_vec; slot < end; slot++)
-    if (!HASH_VACANT (*slot))
-      *vector++ = *slot;
-  *vector = 0;
-
-  if (compare)
-    qsort (vector_0, ht->ht_fill, sizeof (void *), compare);
-  return vector_0;
-}
-
-/* Round a given number up to the nearest power of 2. */
-
-static unsigned long
-round_up_2 (unsigned long n)
-{
-  n |= (n >> 1);
-  n |= (n >> 2);
-  n |= (n >> 4);
-  n |= (n >> 8);
-  n |= (n >> 16);
-
-#if !defined(HAVE_LIMITS_H) || ULONG_MAX > 4294967295
-  /* We only need this on systems where unsigned long is >32 bits.  */
-  n |= (n >> 32);
-#endif
-
-  return n + 1;
-}
-
-#define rol32(v, n) \
-	((v) << (n) | ((v) >> (32 - (n))))
-
-/* jhash_mix -- mix 3 32-bit values reversibly. */
-#define jhash_mix(a, b, c)                      \
-{                                               \
-        a -= c;  a ^= rol32(c, 4);  c += b;     \
-        b -= a;  b ^= rol32(a, 6);  a += c;     \
-        c -= b;  c ^= rol32(b, 8);  b += a;     \
-        a -= c;  a ^= rol32(c, 16); c += b;     \
-        b -= a;  b ^= rol32(a, 19); a += c;     \
-        c -= b;  c ^= rol32(b, 4);  b += a;     \
-}
-
-/* jhash_final - final mixing of 3 32-bit values (a,b,c) into c */
-#define jhash_final(a, b, c)                    \
-{                                               \
-        c ^= b; c -= rol32(b, 14);              \
-        a ^= c; a -= rol32(c, 11);              \
-        b ^= a; b -= rol32(a, 25);              \
-        c ^= b; c -= rol32(b, 16);              \
-        a ^= c; a -= rol32(c, 4);               \
-        b ^= a; b -= rol32(a, 14);              \
-        c ^= b; c -= rol32(b, 24);              \
-}
-
-/* An arbitrary initial parameter */
-#define JHASH_INITVAL           0xdeadbeef
-
-#define sum_get_unaligned_32(r, p)              \
-  do {                                          \
-    unsigned int val;                           \
-    memcpy(&val, (p), 4);                       \
-    r += val;                                   \
-  } while(0);
-
-unsigned jhash(unsigned const char *k, int length)
-{
-  unsigned int a, b, c;
-
-  /* Set up the internal state */
-  a = b = c = JHASH_INITVAL + length;
-
-  /* All but the last block: affect some 32 bits of (a,b,c) */
-  while (length > 12) {
-    sum_get_unaligned_32(a, k);
-    sum_get_unaligned_32(b, k + 4);
-    sum_get_unaligned_32(c, k + 8);
-    jhash_mix(a, b, c);
-    length -= 12;
-    k += 12;
-  }
-
-  if (!length)
-    return c;
-
-  if (length > 8)
-    {
-      sum_get_unaligned_32(a, k);
-      length -= 4;
-      k += 4;
-    }
-  if (length > 4)
-    {
-      sum_get_unaligned_32(b, k);
-      length -= 4;
-      k += 4;
-    }
-
-  if (length == 4)
-    c += (unsigned)k[3]<<24;
-  if (length >= 3)
-    c += (unsigned)k[2]<<16;
-  if (length >= 2)
-    c += (unsigned)k[1]<<8;
-  c += k[0];
-  jhash_final(a, b, c);
-  return c;
-}
-
-#ifdef WORDS_BIGENDIAN
-/* The ifs are ordered from the first byte in memory to the last.  */
-#define sum_up_to_nul(r, p, flag)         \
-  do {                                    \
-    unsigned int val;                     \
-    memcpy(&val, (p), 4);                 \
-    if ((val & 0xFF000000) == 0)          \
-      flag = 1;                           \
-    else if ((val & 0xFF0000) == 0)       \
-      r += val & ~0xFFFF, flag = 1;       \
-    else if ((val & 0xFF00) == 0)         \
-      r += val & ~0xFF, flag = 1;         \
-    else                                  \
-      r += val, flag = (val & 0xFF) == 0; \
-  } while (0)
-#else
-/* First detect the presence of zeroes.  If there is none, we can
-   sum the 4 bytes directly.  Otherwise, the ifs are ordered as in the
-   big endian case, from the first byte in memory to the last.  */
-#define sum_up_to_nul(r, p, flag)                   \
-  do {                                              \
-    unsigned int val;                               \
-    unsigned int zeroes;                            \
-    memcpy(&val, (p), 4);                           \
-    zeroes = ((val - 0x01010101) & ~val);           \
-    if (!(zeroes & 0x80808080))                     \
-      r += val;                                     \
-    else if ((val & 0xFF) == 0)                     \
-      flag = 1;                                     \
-    else if ((val & 0xFF00) == 0)                   \
-      r += val & 0xFF, flag = 1;                    \
-    else if ((val & 0xFF0000) == 0)                 \
-      r += val & 0xFFFF, flag = 1;                  \
-    else                                            \
-      r += val, flag = 1;                           \
-  } while (0)
-#endif
-
-unsigned jhash_string(unsigned const char *k)
-{
-  unsigned int a, b, c;
-  unsigned int have_nul = 0;
-  unsigned const char *start = k;
-
-  /* Set up the internal state */
-  a = b = c = JHASH_INITVAL;
-
-  /* All but the last block: affect some 32 bits of (a,b,c) */
-  for (;;) {
-    sum_up_to_nul(a, k, have_nul);
-    if (have_nul)
-      break;
-    k += 4;
-    sum_up_to_nul(b, k, have_nul);
-    if (have_nul)
-      break;
-    k += 4;
-    sum_up_to_nul(c, k, have_nul);
-    if (have_nul)
-      break;
-    k += 4;
-    jhash_mix(a, b, c);
-  }
-
-  jhash_final(a, b, c);
-  return c + (k - start);
-}
diff --git a/hash.h b/hash.h
deleted file mode 100644
index 667d650..0000000
--- a/hash.h
+++ /dev/null
@@ -1,234 +0,0 @@
-/* hash.h -- decls for hash table
-Copyright (C) 1995, 1999, 2002, 2010 Free Software Foundation, Inc.
-Written by Greg McGary <gkm@gnu.org> <greg@mcgary.org>
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#ifndef _hash_h_
-#define _hash_h_
-
-#include <stdio.h>
-#include <ctype.h>
-
-#if defined __cplusplus || (defined __STDC__ && __STDC__) || defined WINDOWS32
-# if !defined __GLIBC__ || !defined __P
-#  undef	__P
-#  define __P(protos)	protos
-# endif
-#else /* Not C++ or ANSI C.  */
-# undef	__P
-# define __P(protos)	()
-/* We can get away without defining 'const' here only because in this file
-   it is used only inside the prototype for 'fnmatch', which is elided in
-   non-ANSI C where 'const' is problematical.  */
-#endif /* C++ or ANSI C.  */
-
-typedef unsigned long (*hash_func_t) __P((void const *key));
-typedef int (*hash_cmp_func_t) __P((void const *x, void const *y));
-typedef void (*hash_map_func_t) __P((void const *item));
-typedef void (*hash_map_arg_func_t) __P((void const *item, void *arg));
-
-struct hash_table
-{
-  void **ht_vec;
-  hash_func_t ht_hash_1;	/* primary hash function */
-  hash_func_t ht_hash_2;	/* secondary hash function */
-  hash_cmp_func_t ht_compare;	/* comparison function */
-  unsigned long ht_size;	/* total number of slots (power of 2) */
-  unsigned long ht_capacity;	/* usable slots, limited by loading-factor */
-  unsigned long ht_fill;	/* items in table */
-  unsigned long ht_empty_slots;	/* empty slots not including deleted slots */
-  unsigned long ht_collisions;	/* # of failed calls to comparison function */
-  unsigned long ht_lookups;	/* # of queries */
-  unsigned int ht_rehashes;	/* # of times we've expanded table */
-};
-
-typedef int (*qsort_cmp_t) __P((void const *, void const *));
-
-void hash_init __P((struct hash_table *ht, unsigned long size,
-		    hash_func_t hash_1, hash_func_t hash_2, hash_cmp_func_t hash_cmp));
-void hash_load __P((struct hash_table *ht, void *item_table,
-		    unsigned long cardinality, unsigned long size));
-void **hash_find_slot __P((struct hash_table *ht, void const *key));
-void *hash_find_item __P((struct hash_table *ht, void const *key));
-void *hash_insert __P((struct hash_table *ht, const void *item));
-void *hash_insert_at __P((struct hash_table *ht, const void *item, void const *slot));
-void *hash_delete __P((struct hash_table *ht, void const *item));
-void *hash_delete_at __P((struct hash_table *ht, void const *slot));
-void hash_delete_items __P((struct hash_table *ht));
-void hash_free_items __P((struct hash_table *ht));
-void hash_free __P((struct hash_table *ht, int free_items));
-void hash_map __P((struct hash_table *ht, hash_map_func_t map));
-void hash_map_arg __P((struct hash_table *ht, hash_map_arg_func_t map, void *arg));
-void hash_print_stats __P((struct hash_table *ht, FILE *out_FILE));
-void **hash_dump __P((struct hash_table *ht, void **vector_0, qsort_cmp_t compare));
-
-extern unsigned jhash(unsigned char const *key, int n);
-extern unsigned jhash_string(unsigned char const *key);
-
-extern void *hash_deleted_item;
-#define HASH_VACANT(item) ((item) == 0 || (void *) (item) == hash_deleted_item)
-
-
-/* hash and comparison macros for case-sensitive string keys. */
-
-/* Due to the strcache, it's not uncommon for the string pointers to
-   be identical.  Take advantage of that to short-circuit string compares.  */
-
-#define STRING_HASH_1(KEY, RESULT) do { \
-  unsigned char const *_key_ = (unsigned char const *) (KEY); \
-  (RESULT) += jhash_string(_key_); \
-} while (0)
-#define return_STRING_HASH_1(KEY) do { \
-  unsigned long _result_ = 0; \
-  STRING_HASH_1 ((KEY), _result_); \
-  return _result_; \
-} while (0)
-
-/* No need for a second hash because jhash already provides
-   pretty good results.  However, do evaluate the arguments
-   to avoid warnings.  */
-#define STRING_HASH_2(KEY, RESULT) do { \
-  (void)(KEY); \
-} while (0)
-#define return_STRING_HASH_2(KEY) do { \
-  unsigned long _result_ = 0; \
-  STRING_HASH_2 ((KEY), _result_); \
-  return _result_; \
-} while (0)
-
-#define STRING_COMPARE(X, Y, RESULT) do { \
-    RESULT = (X) == (Y) ? 0 : strcmp ((X), (Y)); \
-} while (0)
-#define return_STRING_COMPARE(X, Y) do { \
-  return (X) == (Y) ? 0 : strcmp ((X), (Y)); \
-} while (0)
-
-
-#define STRING_N_HASH_1(KEY, N, RESULT) do { \
-  unsigned char const *_key_ = (unsigned char const *) (KEY); \
-  (RESULT) += jhash(_key_, N); \
-} while (0)
-
-#define return_STRING_N_HASH_1(KEY, N) do { \
-  unsigned long _result_ = 0; \
-  STRING_N_HASH_1 ((KEY), (N), _result_); \
-  return _result_; \
-} while (0)
-
-/* No need for a second hash because jhash already provides
-   pretty good results.  However, do evaluate the arguments
-   to avoid warnings.  */
-#define STRING_N_HASH_2(KEY, N, RESULT) do { \
-  (void)(KEY); \
-  (void)(N); \
-} while (0)
-
-#define return_STRING_N_HASH_2(KEY, N) do { \
-  unsigned long _result_ = 0; \
-  STRING_N_HASH_2 ((KEY), (N), _result_); \
-  return _result_; \
-} while (0)
-
-#define STRING_N_COMPARE(X, Y, N, RESULT) do { \
-  RESULT = (X) == (Y) ? 0 : memcmp ((X), (Y), (N)); \
-} while (0)
-#define return_STRING_N_COMPARE(X, Y, N) do { \
-  return (X) == (Y) ? 0 : memcmp ((X), (Y), (N)); \
-} while (0)
-
-#ifdef HAVE_CASE_INSENSITIVE_FS
-
-/* hash and comparison macros for case-insensitive string _key_s. */
-
-#define ISTRING_HASH_1(KEY, RESULT) do { \
-  unsigned char const *_key_ = (unsigned char const *) (KEY) - 1; \
-  while (*++_key_) \
-    (RESULT) += ((isupper (*_key_) ? tolower (*_key_) : *_key_) << (_key_[1] & 0xf)); \
-} while (0)
-#define return_ISTRING_HASH_1(KEY) do { \
-  unsigned long _result_ = 0; \
-  ISTRING_HASH_1 ((KEY), _result_); \
-  return _result_; \
-} while (0)
-
-#define ISTRING_HASH_2(KEY, RESULT) do { \
-  unsigned char const *_key_ = (unsigned char const *) (KEY) - 1; \
-  while (*++_key_) \
-    (RESULT) += ((isupper (*_key_) ? tolower (*_key_) : *_key_) << (_key_[1] & 0x7)); \
-} while (0)
-#define return_ISTRING_HASH_2(KEY) do { \
-  unsigned long _result_ = 0; \
-  ISTRING_HASH_2 ((KEY), _result_); \
-  return _result_; \
-} while (0)
-
-#define ISTRING_COMPARE(X, Y, RESULT) do { \
-  RESULT = (X) == (Y) ? 0 : strcasecmp ((X), (Y)); \
-} while (0)
-#define return_ISTRING_COMPARE(X, Y) do { \
-  return (X) == (Y) ? 0 : strcasecmp ((X), (Y)); \
-} while (0)
-
-#else
-
-#define ISTRING_HASH_1(KEY, RESULT) STRING_HASH_1 ((KEY), (RESULT))
-#define return_ISTRING_HASH_1(KEY) return_STRING_HASH_1 (KEY)
-
-#define ISTRING_HASH_2(KEY, RESULT) STRING_HASH_2 ((KEY), (RESULT))
-#define return_ISTRING_HASH_2(KEY) return_STRING_HASH_2 (KEY)
-
-#define ISTRING_COMPARE(X, Y, RESULT) STRING_COMPARE ((X), (Y), (RESULT))
-#define return_ISTRING_COMPARE(X, Y) return_STRING_COMPARE ((X), (Y))
-
-#endif
-
-/* hash and comparison macros for integer _key_s. */
-
-#define INTEGER_HASH_1(KEY, RESULT) do { \
-  (RESULT) += ((unsigned long)(KEY)); \
-} while (0)
-#define return_INTEGER_HASH_1(KEY) do { \
-  unsigned long _result_ = 0; \
-  INTEGER_HASH_1 ((KEY), _result_); \
-  return _result_; \
-} while (0)
-
-#define INTEGER_HASH_2(KEY, RESULT) do { \
-  (RESULT) += ~((unsigned long)(KEY)); \
-} while (0)
-#define return_INTEGER_HASH_2(KEY) do { \
-  unsigned long _result_ = 0; \
-  INTEGER_HASH_2 ((KEY), _result_); \
-  return _result_; \
-} while (0)
-
-#define INTEGER_COMPARE(X, Y, RESULT) do { \
-  (RESULT) = X - Y; \
-} while (0)
-#define return_INTEGER_COMPARE(X, Y) do { \
-  int _result_; \
-  INTEGER_COMPARE (X, Y, _result_); \
-  return _result_; \
-} while (0)
-
-/* hash and comparison macros for address keys. */
-
-#define ADDRESS_HASH_1(KEY, RESULT) INTEGER_HASH_1 (((unsigned long)(KEY)) >> 3, (RESULT))
-#define ADDRESS_HASH_2(KEY, RESULT) INTEGER_HASH_2 (((unsigned long)(KEY)) >> 3, (RESULT))
-#define ADDRESS_COMPARE(X, Y, RESULT) INTEGER_COMPARE ((X), (Y), (RESULT))
-#define return_ADDRESS_HASH_1(KEY) return_INTEGER_HASH_1 (((unsigned long)(KEY)) >> 3)
-#define return_ADDRESS_HASH_2(KEY) return_INTEGER_HASH_2 (((unsigned long)(KEY)) >> 3)
-#define return_ADDRESS_COMPARE(X, Y) return_INTEGER_COMPARE ((X), (Y))
-
-#endif /* not _hash_h_ */
diff --git a/implicit.c b/implicit.c
deleted file mode 100644
index e5046a4..0000000
--- a/implicit.c
+++ /dev/null
@@ -1,999 +0,0 @@
-/* Implicit rule searching for GNU Make.
-Copyright (C) 1988-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-#include "filedef.h"
-#include "rule.h"
-#include "dep.h"
-#include "debug.h"
-#include "variable.h"
-#include "job.h"      /* struct child, used inside commands.h */
-#include "commands.h" /* set_file_variables */
-
-static int pattern_search (struct file *file, int archive,
-                           unsigned int depth, unsigned int recursions);
-
-/* For a FILE which has no commands specified, try to figure out some
-   from the implicit pattern rules.
-   Returns 1 if a suitable implicit rule was found,
-   after modifying FILE to contain the appropriate commands and deps,
-   or returns 0 if no implicit rule was found.  */
-
-int
-try_implicit_rule (struct file *file, unsigned int depth)
-{
-  DBF (DB_IMPLICIT, _("Looking for an implicit rule for '%s'.\n"));
-
-  /* The order of these searches was previously reversed.  My logic now is
-     that since the non-archive search uses more information in the target
-     (the archive search omits the archive name), it is more specific and
-     should come first.  */
-
-  if (pattern_search (file, 0, depth, 0))
-    return 1;
-
-#ifndef NO_ARCHIVES
-  /* If this is an archive member reference, use just the
-     archive member name to search for implicit rules.  */
-  if (ar_name (file->name))
-    {
-      DBF (DB_IMPLICIT,
-           _("Looking for archive-member implicit rule for '%s'.\n"));
-      if (pattern_search (file, 1, depth, 0))
-        return 1;
-    }
-#endif
-
-  return 0;
-}
-
-
-/* Scans the BUFFER for the next word with whitespace as a separator.
-   Returns the pointer to the beginning of the word. LENGTH hold the
-   length of the word.  */
-
-static const char *
-get_next_word (const char *buffer, unsigned int *length)
-{
-  const char *p = buffer, *beg;
-  char c;
-
-  /* Skip any leading whitespace.  */
-  NEXT_TOKEN (p);
-
-  beg = p;
-  c = *(p++);
-
-  if (c == '\0')
-    return 0;
-
-
-  /* We already found the first value of "c", above.  */
-  while (1)
-    {
-      char closeparen;
-      int count;
-
-      switch (c)
-        {
-        case '\0':
-        case ' ':
-        case '\t':
-          goto done_word;
-
-        case '$':
-          c = *(p++);
-          if (c == '$')
-            break;
-
-          /* This is a variable reference, so read it to the matching
-             close paren.  */
-
-          if (c == '(')
-            closeparen = ')';
-          else if (c == '{')
-            closeparen = '}';
-          else
-            /* This is a single-letter variable reference.  */
-            break;
-
-          for (count = 0; *p != '\0'; ++p)
-            {
-              if (*p == c)
-                ++count;
-              else if (*p == closeparen && --count < 0)
-                {
-                  ++p;
-                  break;
-                }
-            }
-          break;
-
-        case '|':
-          goto done;
-
-        default:
-          break;
-        }
-
-      c = *(p++);
-    }
- done_word:
-  --p;
-
- done:
-  if (length)
-    *length = p - beg;
-
-  return beg;
-}
-
-/* This structure stores information about the expanded prerequisites for a
-   pattern rule.  NAME is always set to the strcache'd name of the prereq.
-   FILE and PATTERN will be set for intermediate files only.  IGNORE_MTIME is
-   copied from the prerequisite we expanded.
- */
-struct patdeps
-  {
-    const char *name;
-    const char *pattern;
-    struct file *file;
-    unsigned int ignore_mtime : 1;
-  };
-
-/* This structure stores information about pattern rules that we need
-   to try.
-*/
-struct tryrule
-  {
-    struct rule *rule;
-
-    /* Index of the target in this rule that matched the file. */
-    unsigned int matches;
-
-    /* Stem length for this match. */
-    unsigned int stemlen;
-
-    /* Definition order of this rule. Used to implement stable sort.*/
-    unsigned int order;
-
-    /* Nonzero if the LASTSLASH logic was used in matching this rule. */
-    char checked_lastslash;
-  };
-
-int
-stemlen_compare (const void *v1, const void *v2)
-{
-  const struct tryrule *r1 = v1;
-  const struct tryrule *r2 = v2;
-  int r = r1->stemlen - r2->stemlen;
-  return r != 0 ? r : (int)(r1->order - r2->order);
-}
-
-/* Search the pattern rules for a rule with an existing dependency to make
-   FILE.  If a rule is found, the appropriate commands and deps are put in FILE
-   and 1 is returned.  If not, 0 is returned.
-
-   If ARCHIVE is nonzero, FILE->name is of the form "LIB(MEMBER)".  A rule for
-   "(MEMBER)" will be searched for, and "(MEMBER)" will not be chopped up into
-   directory and filename parts.
-
-   If an intermediate file is found by pattern search, the intermediate file
-   is set up as a target by the recursive call and is also made a dependency
-   of FILE.
-
-   DEPTH is used for debugging messages.  */
-
-static int
-pattern_search (struct file *file, int archive,
-                unsigned int depth, unsigned int recursions)
-{
-  /* Filename we are searching for a rule for.  */
-  const char *filename = archive ? strchr (file->name, '(') : file->name;
-
-  /* Length of FILENAME.  */
-  unsigned int namelen = strlen (filename);
-
-  /* The last slash in FILENAME (or nil if there is none).  */
-  const char *lastslash;
-
-  /* This is a file-object used as an argument in
-     recursive calls.  It never contains any data
-     except during a recursive call.  */
-  struct file *int_file = 0;
-
-  /* List of dependencies found recursively.  */
-  unsigned int max_deps = max_pattern_deps;
-  struct patdeps *deplist = xmalloc (max_deps * sizeof (struct patdeps));
-  struct patdeps *pat = deplist;
-
-  /* Names of possible dependencies are constructed in this buffer.  */
-  char *depname = alloca (namelen + max_pattern_dep_length);
-
-  /* The start and length of the stem of FILENAME for the current rule.  */
-  const char *stem = 0;
-  unsigned int stemlen = 0;
-  unsigned int fullstemlen = 0;
-
-  /* Buffer in which we store all the rules that are possibly applicable.  */
-  struct tryrule *tryrules = xmalloc (num_pattern_rules * max_pattern_targets
-                                      * sizeof (struct tryrule));
-
-  /* Number of valid elements in TRYRULES.  */
-  unsigned int nrules;
-
-  /* The index in TRYRULES of the rule we found.  */
-  unsigned int foundrule;
-
-  /* Nonzero if should consider intermediate files as dependencies.  */
-  int intermed_ok;
-
-  /* Nonzero if we have initialized file variables for this target.  */
-  int file_vars_initialized = 0;
-
-  /* Nonzero if we have matched a pattern-rule target
-     that is not just '%'.  */
-  int specific_rule_matched = 0;
-
-  unsigned int ri;  /* uninit checks OK */
-  struct rule *rule;
-
-  char *pathdir = NULL;
-  unsigned long pathlen;
-
-  PATH_VAR (stem_str); /* @@ Need to get rid of stem, stemlen, etc. */
-
-#ifndef NO_ARCHIVES
-  if (archive || ar_name (filename))
-    lastslash = 0;
-  else
-#endif
-    {
-      /* Set LASTSLASH to point at the last slash in FILENAME
-         but not counting any slash at the end.  (foo/bar/ counts as
-         bar/ in directory foo/, not empty in directory foo/bar/.)  */
-      lastslash = strrchr (filename, '/');
-#ifdef VMS
-      if (lastslash == NULL)
-        lastslash = strrchr (filename, ']');
-      if (lastslash == NULL)
-        lastslash = strrchr (filename, '>');
-      if (lastslash == NULL)
-        lastslash = strrchr (filename, ':');
-#endif
-#ifdef HAVE_DOS_PATHS
-      /* Handle backslashes (possibly mixed with forward slashes)
-         and the case of "d:file".  */
-      {
-        char *bslash = strrchr (filename, '\\');
-        if (lastslash == 0 || bslash > lastslash)
-          lastslash = bslash;
-        if (lastslash == 0 && filename[0] && filename[1] == ':')
-          lastslash = filename + 1;
-      }
-#endif
-      if (lastslash != 0 && lastslash[1] == '\0')
-        lastslash = 0;
-    }
-
-  pathlen = lastslash - filename + 1;
-
-  /* First see which pattern rules match this target and may be considered.
-     Put them in TRYRULES.  */
-
-  nrules = 0;
-  for (rule = pattern_rules; rule != 0; rule = rule->next)
-    {
-      unsigned int ti;
-
-      /* If the pattern rule has deps but no commands, ignore it.
-         Users cancel built-in rules by redefining them without commands.  */
-      if (rule->deps != 0 && rule->cmds == 0)
-        continue;
-
-      /* If this rule is in use by a parent pattern_search,
-         don't use it here.  */
-      if (rule->in_use)
-        {
-          DBS (DB_IMPLICIT, (_("Avoiding implicit rule recursion.\n")));
-          continue;
-        }
-
-      for (ti = 0; ti < rule->num; ++ti)
-        {
-          const char *target = rule->targets[ti];
-          const char *suffix = rule->suffixes[ti];
-          char check_lastslash;
-
-          /* Rules that can match any filename and are not terminal
-             are ignored if we're recursing, so that they cannot be
-             intermediate files.  */
-          if (recursions > 0 && target[1] == '\0' && !rule->terminal)
-            continue;
-
-          if (rule->lens[ti] > namelen)
-            /* It can't possibly match.  */
-            continue;
-
-          /* From the lengths of the filename and the pattern parts,
-             find the stem: the part of the filename that matches the %.  */
-          stem = filename + (suffix - target - 1);
-          stemlen = namelen - rule->lens[ti] + 1;
-
-          /* Set CHECK_LASTSLASH if FILENAME contains a directory
-             prefix and the target pattern does not contain a slash.  */
-
-          check_lastslash = 0;
-          if (lastslash)
-            {
-#ifdef VMS
-              check_lastslash = strpbrk (target, "/]>:") == NULL;
-#else
-              check_lastslash = strchr (target, '/') == 0;
-#endif
-#ifdef HAVE_DOS_PATHS
-              /* Didn't find it yet: check for DOS-type directories.  */
-              if (check_lastslash)
-                {
-                  char *b = strchr (target, '\\');
-                  check_lastslash = !(b || (target[0] && target[1] == ':'));
-                }
-#endif
-            }
-          if (check_lastslash)
-            {
-              /* If so, don't include the directory prefix in STEM here.  */
-              if (pathlen > stemlen)
-                continue;
-              stemlen -= pathlen;
-              stem += pathlen;
-            }
-
-          /* Check that the rule pattern matches the text before the stem.  */
-          if (check_lastslash)
-            {
-              if (stem > (lastslash + 1)
-                  && !strneq (target, lastslash + 1, stem - lastslash - 1))
-                continue;
-            }
-          else if (stem > filename
-                   && !strneq (target, filename, stem - filename))
-            continue;
-
-          /* Check that the rule pattern matches the text after the stem.
-             We could test simply use streq, but this way we compare the
-             first two characters immediately.  This saves time in the very
-             common case where the first character matches because it is a
-             period.  */
-          if (*suffix != stem[stemlen]
-              || (*suffix != '\0' && !streq (&suffix[1], &stem[stemlen + 1])))
-            continue;
-
-          /* Record if we match a rule that not all filenames will match.  */
-          if (target[1] != '\0')
-            specific_rule_matched = 1;
-
-          /* A rule with no dependencies and no commands exists solely to set
-             specific_rule_matched when it matches.  Don't try to use it.  */
-          if (rule->deps == 0 && rule->cmds == 0)
-            continue;
-
-          /* Record this rule in TRYRULES and the index of the matching
-             target in MATCHES.  If several targets of the same rule match,
-             that rule will be in TRYRULES more than once.  */
-          tryrules[nrules].rule = rule;
-          tryrules[nrules].matches = ti;
-          tryrules[nrules].stemlen = stemlen + (check_lastslash ? pathlen : 0);
-          tryrules[nrules].order = nrules;
-          tryrules[nrules].checked_lastslash = check_lastslash;
-          ++nrules;
-        }
-    }
-
-  /* Bail out early if we haven't found any rules. */
-  if (nrules == 0)
-    goto done;
-
-  /* Sort the rules to place matches with the shortest stem first. This
-     way the most specific rules will be tried first. */
-  if (nrules > 1)
-    qsort (tryrules, nrules, sizeof (struct tryrule), stemlen_compare);
-
-  /* If we have found a matching rule that won't match all filenames,
-     retroactively reject any non-"terminal" rules that do always match.  */
-  if (specific_rule_matched)
-    for (ri = 0; ri < nrules; ++ri)
-      if (!tryrules[ri].rule->terminal)
-        {
-          unsigned int j;
-          for (j = 0; j < tryrules[ri].rule->num; ++j)
-            if (tryrules[ri].rule->targets[j][1] == '\0')
-              {
-                tryrules[ri].rule = 0;
-                break;
-              }
-        }
-
-  /* Try each rule once without intermediate files, then once with them.  */
-  for (intermed_ok = 0; intermed_ok < 2; ++intermed_ok)
-    {
-      pat = deplist;
-
-      /* Try each pattern rule till we find one that applies.  If it does,
-         expand its dependencies (as substituted) and chain them in DEPS.  */
-      for (ri = 0; ri < nrules; ri++)
-        {
-          struct dep *dep;
-          char check_lastslash;
-          unsigned int failed = 0;
-          int file_variables_set = 0;
-          unsigned int deps_found = 0;
-          /* NPTR points to the part of the prereq we haven't processed.  */
-          const char *nptr = 0;
-          const char *dir = NULL;
-          int order_only = 0;
-          unsigned int matches;
-
-          rule = tryrules[ri].rule;
-
-          /* RULE is nil when we discover that a rule, already placed in
-             TRYRULES, should not be applied.  */
-          if (rule == 0)
-            continue;
-
-          /* Reject any terminal rules if we're looking to make intermediate
-             files.  */
-          if (intermed_ok && rule->terminal)
-            continue;
-
-          /* From the lengths of the filename and the matching pattern parts,
-             find the stem: the part of the filename that matches the %.  */
-          matches = tryrules[ri].matches;
-          stem = filename + (rule->suffixes[matches]
-                             - rule->targets[matches]) - 1;
-          stemlen = (namelen - rule->lens[matches]) + 1;
-          check_lastslash = tryrules[ri].checked_lastslash;
-          if (check_lastslash)
-            {
-              stem += pathlen;
-              stemlen -= pathlen;
-
-              /* We need to add the directory prefix, so set it up.  */
-              if (! pathdir)
-                {
-                  pathdir = alloca (pathlen + 1);
-                  memcpy (pathdir, filename, pathlen);
-                  pathdir[pathlen] = '\0';
-                }
-              dir = pathdir;
-            }
-
-          if (stemlen > GET_PATH_MAX)
-            {
-              DBS (DB_IMPLICIT, (_("Stem too long: '%.*s'.\n"),
-                                 (int) stemlen, stem));
-              continue;
-            }
-
-          DBS (DB_IMPLICIT, (_("Trying pattern rule with stem '%.*s'.\n"),
-                             (int) stemlen, stem));
-
-          strncpy (stem_str, stem, stemlen);
-          stem_str[stemlen] = '\0';
-
-          /* If there are no prerequisites, then this rule matches.  */
-          if (rule->deps == 0)
-            break;
-
-          /* Temporary assign STEM to file->stem (needed to set file
-             variables below).   */
-          file->stem = stem_str;
-
-          /* Mark this rule as in use so a recursive pattern_search won't try
-             to use it.  */
-          rule->in_use = 1;
-
-          /* Try each prerequisite; see if it exists or can be created.  We'll
-             build a list of prereq info in DEPLIST.  Due to 2nd expansion we
-             may have to process multiple prereqs for a single dep entry.  */
-
-          pat = deplist;
-          dep = rule->deps;
-          nptr = dep_name (dep);
-          while (1)
-            {
-              struct dep *dl, *d;
-              char *p;
-
-              /* If we're out of name to parse, start the next prereq.  */
-              if (! nptr)
-                {
-                  dep = dep->next;
-                  if (dep == 0)
-                    break;
-                  nptr = dep_name (dep);
-                }
-
-              /* If we don't need a second expansion, just replace the %.  */
-              if (! dep->need_2nd_expansion)
-                {
-                  p = strchr (nptr, '%');
-                  if (p == 0)
-                    strcpy (depname, nptr);
-                  else
-                    {
-                      char *o = depname;
-                      if (check_lastslash)
-                        {
-                          memcpy (o, filename, pathlen);
-                          o += pathlen;
-                        }
-                      memcpy (o, nptr, p - nptr);
-                      o += p - nptr;
-                      memcpy (o, stem_str, stemlen);
-                      o += stemlen;
-                      strcpy (o, p + 1);
-                    }
-
-                  /* Parse the expanded string.  It might have wildcards.  */
-                  p = depname;
-                  dl = PARSE_SIMPLE_SEQ (&p, struct dep);
-                  for (d = dl; d != NULL; d = d->next)
-                    {
-                      ++deps_found;
-                      d->ignore_mtime = dep->ignore_mtime;
-                    }
-
-                  /* We've used up this dep, so next time get a new one.  */
-                  nptr = 0;
-                }
-
-              /* We have to perform second expansion on this prereq.  In an
-                 ideal world we would take the dependency line, substitute the
-                 stem, re-expand the whole line and chop it into individual
-                 prerequisites.  Unfortunately this won't work because of the
-                 "check_lastslash" twist.  Instead, we will have to go word by
-                 word, taking $()'s into account.  For each word we will
-                 substitute the stem, re-expand, chop it up, and, if
-                 check_lastslash != 0, add the directory part to each
-                 resulting prerequisite.  */
-              else
-                {
-                  int add_dir = 0;
-                  unsigned int len;
-                  struct dep **dptr;
-
-                  nptr = get_next_word (nptr, &len);
-                  if (nptr == 0)
-                    continue;
-
-                  /* See this is a transition to order-only prereqs.  */
-                  if (! order_only && len == 1 && nptr[0] == '|')
-                    {
-                      order_only = 1;
-                      nptr += len;
-                      continue;
-                    }
-
-                  /* If the dependency name has %, substitute the stem.  If we
-                     just replace % with the stem value then later, when we do
-                     the 2nd expansion, we will re-expand this stem value
-                     again.  This is not good if you have certain characters
-                     in your stem (like $).
-
-                     Instead, we will replace % with $* and allow the second
-                     expansion to take care of it for us.  This way (since $*
-                     is a simple variable) there won't be additional
-                     re-expansion of the stem.  */
-
-                  p = lindex (nptr, nptr + len, '%');
-                  if (p == 0)
-                    {
-                      memcpy (depname, nptr, len);
-                      depname[len] = '\0';
-                    }
-                  else
-                    {
-                      unsigned int i = p - nptr;
-                      memcpy (depname, nptr, i);
-                      memcpy (depname + i, "$*", 2);
-                      memcpy (depname + i + 2, p + 1, len - i - 1);
-                      depname[len + 2 - 1] = '\0';
-
-                      if (check_lastslash)
-                        add_dir = 1;
-                    }
-
-                  /* Set up for the next word.  */
-                  nptr += len;
-
-                  /* Initialize and set file variables if we haven't already
-                     done so. */
-                  if (!file_vars_initialized)
-                    {
-                      initialize_file_variables (file, 0);
-                      set_file_variables (file);
-                      file_vars_initialized = 1;
-                    }
-                  /* Update the stem value in $* for this rule.  */
-                  else if (!file_variables_set)
-                    {
-                      define_variable_for_file (
-                        "*", 1, file->stem, o_automatic, 0, file);
-                      file_variables_set = 1;
-                    }
-
-                  /* Perform the 2nd expansion.  */
-                  p = variable_expand_for_file (depname, file);
-                  dptr = &dl;
-
-                  /* Parse the results into a deps list.  */
-                  do
-                    {
-                      /* Parse the expanded string. */
-                      struct dep *dp = PARSE_FILE_SEQ (&p, struct dep,
-                                                       order_only ? MAP_NUL : MAP_PIPE,
-                                                       add_dir ? dir : NULL, PARSEFS_NONE);
-                      *dptr = dp;
-
-                      for (d = dp; d != NULL; d = d->next)
-                        {
-                          ++deps_found;
-                          if (order_only)
-                            d->ignore_mtime = 1;
-                          dptr = &d->next;
-                        }
-
-                      /* If we stopped due to an order-only token, note it.  */
-                      if (*p == '|')
-                        {
-                          order_only = 1;
-                          ++p;
-                        }
-                    }
-                  while (*p != '\0');
-                }
-
-              /* If there are more than max_pattern_deps prerequisites (due to
-                 2nd expansion), reset it and realloc the arrays.  */
-
-              if (deps_found > max_deps)
-                {
-                  unsigned int l = pat - deplist;
-                  /* This might have changed due to recursion.  */
-                  max_pattern_deps = MAX(max_pattern_deps, deps_found);
-                  max_deps = max_pattern_deps;
-                  deplist = xrealloc (deplist,
-                                      max_deps * sizeof (struct patdeps));
-                  pat = deplist + l;
-                }
-
-              /* Go through the nameseq and handle each as a prereq name.  */
-              for (d = dl; d != 0; d = d->next)
-                {
-                  struct dep *expl_d;
-                  int is_rule = d->name == dep_name (dep);
-
-                  if (file_impossible_p (d->name))
-                    {
-                      /* If this prereq has already been ruled "impossible",
-                         then the rule fails.  Don't bother trying it on the
-                         second pass either since we know that will fail.  */
-                      DBS (DB_IMPLICIT,
-                           (is_rule
-                            ? _("Rejecting impossible rule prerequisite '%s'.\n")
-                            : _("Rejecting impossible implicit prerequisite '%s'.\n"),
-                            d->name));
-                      tryrules[ri].rule = 0;
-
-                      failed = 1;
-                      break;
-                    }
-
-                  memset (pat, '\0', sizeof (struct patdeps));
-                  pat->ignore_mtime = d->ignore_mtime;
-
-                  DBS (DB_IMPLICIT,
-                       (is_rule
-                        ? _("Trying rule prerequisite '%s'.\n")
-                        : _("Trying implicit prerequisite '%s'.\n"), d->name));
-
-                  /* If this prereq is also explicitly mentioned for FILE,
-                     skip all tests below since it must be built no matter
-                     which implicit rule we choose. */
-
-                  for (expl_d = file->deps; expl_d != 0; expl_d = expl_d->next)
-                    if (streq (dep_name (expl_d), d->name))
-                      break;
-                  if (expl_d != 0)
-                    {
-                      (pat++)->name = d->name;
-                      continue;
-                    }
-
-                  /* The DEP->changed flag says that this dependency resides
-                     in a nonexistent directory.  So we normally can skip
-                     looking for the file.  However, if CHECK_LASTSLASH is
-                     set, then the dependency file we are actually looking for
-                     is in a different directory (the one gotten by prepending
-                     FILENAME's directory), so it might actually exist.  */
-
-                  /* @@ dep->changed check is disabled. */
-                  if (lookup_file (d->name) != 0
-                      /*|| ((!dep->changed || check_lastslash) && */
-                      || file_exists_p (d->name))
-                    {
-                      (pat++)->name = d->name;
-                      continue;
-                    }
-
-                  /* This code, given FILENAME = "lib/foo.o", dependency name
-                     "lib/foo.c", and VPATH=src, searches for
-                     "src/lib/foo.c".  */
-                  {
-                    const char *vname = vpath_search (d->name, 0, NULL, NULL);
-                    if (vname)
-                      {
-                        DBS (DB_IMPLICIT,
-                             (_("Found prerequisite '%s' as VPATH '%s'\n"),
-                              d->name, vname));
-                        (pat++)->name = d->name;
-                        continue;
-                      }
-                  }
-
-                  /* We could not find the file in any place we should look.
-                     Try to make this dependency as an intermediate file, but
-                     only on the second pass.  */
-
-                  if (intermed_ok)
-                    {
-                      DBS (DB_IMPLICIT,
-                           (_("Looking for a rule with intermediate file '%s'.\n"),
-                            d->name));
-
-                      if (int_file == 0)
-                        int_file = alloca (sizeof (struct file));
-                      memset (int_file, '\0', sizeof (struct file));
-                      int_file->name = d->name;
-
-                      if (pattern_search (int_file,
-                                          0,
-                                          depth + 1,
-                                          recursions + 1))
-                        {
-                          pat->pattern = int_file->name;
-                          int_file->name = d->name;
-                          pat->file = int_file;
-                          int_file = 0;
-                          (pat++)->name = d->name;
-                          continue;
-                        }
-
-                      /* If we have tried to find P as an intermediate file
-                         and failed, mark that name as impossible so we won't
-                         go through the search again later.  */
-                      if (int_file->variables)
-                        free_variable_set (int_file->variables);
-                      if (int_file->pat_variables)
-                        free_variable_set (int_file->pat_variables);
-                      file_impossible (d->name);
-                    }
-
-                  /* A dependency of this rule does not exist. Therefore, this
-                     rule fails.  */
-                  failed = 1;
-                  break;
-                }
-
-              /* Free the ns chain.  */
-              free_dep_chain (dl);
-
-              if (failed)
-                break;
-            }
-
-          /* Reset the stem in FILE. */
-
-          file->stem = 0;
-
-          /* This rule is no longer 'in use' for recursive searches.  */
-          rule->in_use = 0;
-
-          if (! failed)
-            /* This pattern rule does apply.  Stop looking for one.  */
-            break;
-
-          /* This pattern rule does not apply.  Keep looking.  */
-        }
-
-      /* If we found an applicable rule without intermediate files, don't try
-         with them.  */
-      if (ri < nrules)
-        break;
-
-      rule = 0;
-    }
-
-  /* RULE is nil if the loop went through the list but everything failed.  */
-  if (rule == 0)
-    goto done;
-
-  foundrule = ri;
-
-  /* If we are recursing, store the pattern that matched FILENAME in
-     FILE->name for use in upper levels.  */
-
-  if (recursions > 0)
-    /* Kludge-o-matic */
-    file->name = rule->targets[tryrules[foundrule].matches];
-
-  /* DEPLIST lists the prerequisites for the rule we found.  This includes the
-     intermediate files, if any.  Convert them into entries on the deps-chain
-     of FILE.  */
-
-  while (pat-- > deplist)
-    {
-      struct dep *dep;
-      const char *s;
-
-      if (pat->file != 0)
-        {
-          /* If we need to use an intermediate file, make sure it is entered
-             as a target, with the info that was found for it in the recursive
-             pattern_search call.  We know that the intermediate file did not
-             already exist as a target; therefore we can assume that the deps
-             and cmds of F below are null before we change them.  */
-
-          struct file *imf = pat->file;
-          struct file *f = lookup_file (imf->name);
-
-          /* We don't want to delete an intermediate file that happened
-             to be a prerequisite of some (other) target. Mark it as
-             secondary.  We don't want it to be precious as that disables
-             DELETE_ON_ERROR etc.  */
-          if (f != 0)
-            f->secondary = 1;
-          else
-            f = enter_file (imf->name);
-
-          f->deps = imf->deps;
-          f->cmds = imf->cmds;
-          f->stem = imf->stem;
-          f->variables = imf->variables;
-          f->pat_variables = imf->pat_variables;
-          f->pat_searched = imf->pat_searched;
-          f->also_make = imf->also_make;
-          f->is_target = 1;
-          f->intermediate = 1;
-          f->tried_implicit = 1;
-
-          imf = lookup_file (pat->pattern);
-          if (imf != 0 && imf->precious)
-            f->precious = 1;
-
-          for (dep = f->deps; dep != 0; dep = dep->next)
-            {
-              dep->file = enter_file (dep->name);
-              dep->name = 0;
-              dep->file->tried_implicit |= dep->changed;
-            }
-        }
-
-      dep = alloc_dep ();
-      dep->ignore_mtime = pat->ignore_mtime;
-      s = strcache_add (pat->name);
-      if (recursions)
-        dep->name = s;
-      else
-        {
-          dep->file = lookup_file (s);
-          if (dep->file == 0)
-            dep->file = enter_file (s);
-        }
-
-      if (pat->file == 0 && tryrules[foundrule].rule->terminal)
-        {
-          /* If the file actually existed (was not an intermediate file), and
-             the rule that found it was a terminal one, then we want to mark
-             the found file so that it will not have implicit rule search done
-             for it.  If we are not entering a 'struct file' for it now, we
-             indicate this with the 'changed' flag.  */
-          if (dep->file == 0)
-            dep->changed = 1;
-          else
-            dep->file->tried_implicit = 1;
-        }
-
-      dep->next = file->deps;
-      file->deps = dep;
-    }
-
-  if (!tryrules[foundrule].checked_lastslash)
-    {
-      /* Always allocate new storage, since STEM might be on the stack for an
-         intermediate file.  */
-      file->stem = strcache_add_len (stem, stemlen);
-      fullstemlen = stemlen;
-    }
-  else
-    {
-      int dirlen = (lastslash + 1) - filename;
-      char *sp;
-
-      /* We want to prepend the directory from
-         the original FILENAME onto the stem.  */
-      fullstemlen = dirlen + stemlen;
-      sp = alloca (fullstemlen + 1);
-      memcpy (sp, filename, dirlen);
-      memcpy (sp + dirlen, stem, stemlen);
-      sp[fullstemlen] = '\0';
-      file->stem = strcache_add (sp);
-    }
-
-  file->cmds = rule->cmds;
-  file->is_target = 1;
-
-  /* Set precious flag. */
-  {
-    struct file *f = lookup_file (rule->targets[tryrules[foundrule].matches]);
-    if (f && f->precious)
-      file->precious = 1;
-  }
-
-  /* If this rule builds other targets, too, put the others into FILE's
-     'also_make' member.  */
-
-  if (rule->num > 1)
-    for (ri = 0; ri < rule->num; ++ri)
-      if (ri != tryrules[foundrule].matches)
-        {
-          char *nm = alloca (rule->lens[ri] + fullstemlen + 1);
-          char *p = nm;
-          struct file *f;
-          struct dep *new = alloc_dep ();
-
-          /* GKM FIMXE: handle '|' here too */
-          memcpy (p, rule->targets[ri],
-                  rule->suffixes[ri] - rule->targets[ri] - 1);
-          p += rule->suffixes[ri] - rule->targets[ri] - 1;
-          memcpy (p, file->stem, fullstemlen);
-          p += fullstemlen;
-          memcpy (p, rule->suffixes[ri],
-                  rule->lens[ri] - (rule->suffixes[ri] - rule->targets[ri])+1);
-          new->name = strcache_add (nm);
-          new->file = enter_file (new->name);
-          new->next = file->also_make;
-
-          /* Set precious flag. */
-          f = lookup_file (rule->targets[ri]);
-          if (f && f->precious)
-            new->file->precious = 1;
-
-          /* Set the is_target flag so that this file is not treated as
-             intermediate by the pattern rule search algorithm and
-             file_exists_p cannot pick it up yet.  */
-          new->file->is_target = 1;
-
-          file->also_make = new;
-        }
-
- done:
-  free (tryrules);
-  free (deplist);
-
-  return rule != 0;
-}
diff --git a/job.c b/job.c
deleted file mode 100644
index a13aada..0000000
--- a/job.c
+++ /dev/null
@@ -1,3613 +0,0 @@
-/* Job execution and handling for GNU Make.
-Copyright (C) 1988-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-
-#include <assert.h>
-
-#include "job.h"
-#include "debug.h"
-#include "filedef.h"
-#include "commands.h"
-#include "variable.h"
-#include "os.h"
-
-#include <string.h>
-
-/* Default shell to use.  */
-#ifdef WINDOWS32
-#ifdef HAVE_STRINGS_H
-#include <strings.h>	/* for strcasecmp, strncasecmp */
-#endif
-#include <windows.h>
-
-const char *default_shell = "sh.exe";
-int no_default_sh_exe = 1;
-int batch_mode_shell = 1;
-HANDLE main_thread;
-
-#elif defined (_AMIGA)
-
-const char *default_shell = "";
-extern int MyExecute (char **);
-int batch_mode_shell = 0;
-
-#elif defined (__MSDOS__)
-
-/* The default shell is a pointer so we can change it if Makefile
-   says so.  It is without an explicit path so we get a chance
-   to search the $PATH for it (since MSDOS doesn't have standard
-   directories we could trust).  */
-const char *default_shell = "command.com";
-int batch_mode_shell = 0;
-
-#elif defined (__EMX__)
-
-const char *default_shell = "/bin/sh";
-int batch_mode_shell = 0;
-
-#elif defined (VMS)
-
-# include <descrip.h>
-# include <stsdef.h>
-const char *default_shell = "";
-int batch_mode_shell = 0;
-
-#define strsignal vms_strsignal
-char * vms_strsignal (int status);
-
-#ifndef C_FACILITY_NO
-# define C_FACILITY_NO 0x350000
-#endif
-#ifndef VMS_POSIX_EXIT_MASK
-# define VMS_POSIX_EXIT_MASK (C_FACILITY_NO | 0xA000)
-#endif
-
-#else
-
-const char *default_shell = "/bin/sh";
-int batch_mode_shell = 0;
-
-#endif
-
-#ifdef __MSDOS__
-# include <process.h>
-static int execute_by_shell;
-static int dos_pid = 123;
-int dos_status;
-int dos_command_running;
-#endif /* __MSDOS__ */
-
-#ifdef _AMIGA
-# include <proto/dos.h>
-static int amiga_pid = 123;
-static int amiga_status;
-static char amiga_bname[32];
-static int amiga_batch_file;
-#endif /* Amiga.  */
-
-#ifdef VMS
-# ifndef __GNUC__
-#   include <processes.h>
-# endif
-# include <starlet.h>
-# include <lib$routines.h>
-static void vmsWaitForChildren (int *);
-#endif
-
-#ifdef WINDOWS32
-# include <windows.h>
-# include <io.h>
-# include <process.h>
-# include "sub_proc.h"
-# include "w32err.h"
-# include "pathstuff.h"
-# define WAIT_NOHANG 1
-#endif /* WINDOWS32 */
-
-#ifdef __EMX__
-# include <process.h>
-#endif
-
-#if defined (HAVE_SYS_WAIT_H) || defined (HAVE_UNION_WAIT)
-# include <sys/wait.h>
-#endif
-
-#ifdef HAVE_WAITPID
-# define WAIT_NOHANG(status)    waitpid (-1, (status), WNOHANG)
-#else   /* Don't have waitpid.  */
-# ifdef HAVE_WAIT3
-#  ifndef wait3
-extern int wait3 ();
-#  endif
-#  define WAIT_NOHANG(status)   wait3 ((status), WNOHANG, (struct rusage *) 0)
-# endif /* Have wait3.  */
-#endif /* Have waitpid.  */
-
-#if !defined (wait) && !defined (POSIX)
-int wait ();
-#endif
-
-#ifndef HAVE_UNION_WAIT
-
-# define WAIT_T int
-
-# ifndef WTERMSIG
-#  define WTERMSIG(x) ((x) & 0x7f)
-# endif
-# ifndef WCOREDUMP
-#  define WCOREDUMP(x) ((x) & 0x80)
-# endif
-# ifndef WEXITSTATUS
-#  define WEXITSTATUS(x) (((x) >> 8) & 0xff)
-# endif
-# ifndef WIFSIGNALED
-#  define WIFSIGNALED(x) (WTERMSIG (x) != 0)
-# endif
-# ifndef WIFEXITED
-#  define WIFEXITED(x) (WTERMSIG (x) == 0)
-# endif
-
-#else   /* Have 'union wait'.  */
-
-# define WAIT_T union wait
-# ifndef WTERMSIG
-#  define WTERMSIG(x) ((x).w_termsig)
-# endif
-# ifndef WCOREDUMP
-#  define WCOREDUMP(x) ((x).w_coredump)
-# endif
-# ifndef WEXITSTATUS
-#  define WEXITSTATUS(x) ((x).w_retcode)
-# endif
-# ifndef WIFSIGNALED
-#  define WIFSIGNALED(x) (WTERMSIG(x) != 0)
-# endif
-# ifndef WIFEXITED
-#  define WIFEXITED(x) (WTERMSIG(x) == 0)
-# endif
-
-#endif  /* Don't have 'union wait'.  */
-
-#if !defined(HAVE_UNISTD_H) && !defined(WINDOWS32)
-int dup2 ();
-int execve ();
-void _exit ();
-# ifndef VMS
-int geteuid ();
-int getegid ();
-int setgid ();
-int getgid ();
-# endif
-#endif
-
-/* Different systems have different requirements for pid_t.
-   Plus we have to support gettext string translation... Argh.  */
-static const char *
-pid2str (pid_t pid)
-{
-  static char pidstring[100];
-#if defined(WINDOWS32) && (__GNUC__ > 3 || _MSC_VER > 1300)
-  /* %Id is only needed for 64-builds, which were not supported by
-      older versions of Windows compilers.  */
-  sprintf (pidstring, "%Id", pid);
-#else
-  sprintf (pidstring, "%lu", (unsigned long) pid);
-#endif
-  return pidstring;
-}
-
-#ifndef HAVE_GETLOADAVG
-int getloadavg (double loadavg[], int nelem);
-#endif
-
-static void free_child (struct child *);
-static void start_job_command (struct child *child);
-static int load_too_high (void);
-static int job_next_command (struct child *);
-static int start_waiting_job (struct child *);
-
-/* Chain of all live (or recently deceased) children.  */
-
-struct child *children = 0;
-
-/* Number of children currently running.  */
-
-unsigned int job_slots_used = 0;
-
-/* Nonzero if the 'good' standard input is in use.  */
-
-static int good_stdin_used = 0;
-
-/* Chain of children waiting to run until the load average goes down.  */
-
-static struct child *waiting_jobs = 0;
-
-/* Non-zero if we use a *real* shell (always so on Unix).  */
-
-int unixy_shell = 1;
-
-/* Number of jobs started in the current second.  */
-
-unsigned long job_counter = 0;
-
-/* Number of jobserver tokens this instance is currently using.  */
-
-unsigned int jobserver_tokens = 0;
-
-
-#ifdef WINDOWS32
-/*
- * The macro which references this function is defined in makeint.h.
- */
-int
-w32_kill (pid_t pid, int sig)
-{
-  return ((process_kill ((HANDLE)pid, sig) == TRUE) ? 0 : -1);
-}
-
-/* This function creates a temporary file name with an extension specified
- * by the unixy arg.
- * Return an xmalloc'ed string of a newly created temp file and its
- * file descriptor, or die.  */
-static char *
-create_batch_file (char const *base, int unixy, int *fd)
-{
-  const char *const ext = unixy ? "sh" : "bat";
-  const char *error_string = NULL;
-  char temp_path[MAXPATHLEN]; /* need to know its length */
-  unsigned path_size = GetTempPath (sizeof temp_path, temp_path);
-  int path_is_dot = 0;
-  /* The following variable is static so we won't try to reuse a name
-     that was generated a little while ago, because that file might
-     not be on disk yet, since we use FILE_ATTRIBUTE_TEMPORARY below,
-     which tells the OS it doesn't need to flush the cache to disk.
-     If the file is not yet on disk, we might think the name is
-     available, while it really isn't.  This happens in parallel
-     builds, where Make doesn't wait for one job to finish before it
-     launches the next one.  */
-  static unsigned uniq = 0;
-  static int second_loop = 0;
-  const unsigned sizemax = strlen (base) + strlen (ext) + 10;
-
-  if (path_size == 0)
-    {
-      path_size = GetCurrentDirectory (sizeof temp_path, temp_path);
-      path_is_dot = 1;
-    }
-
-  ++uniq;
-  if (uniq >= 0x10000 && !second_loop)
-    {
-      /* If we already had 64K batch files in this
-         process, make a second loop through the numbers,
-         looking for free slots, i.e. files that were
-         deleted in the meantime.  */
-      second_loop = 1;
-      uniq = 1;
-    }
-  while (path_size > 0 &&
-         path_size + sizemax < sizeof temp_path &&
-         !(uniq >= 0x10000 && second_loop))
-    {
-      unsigned size = sprintf (temp_path + path_size,
-                               "%s%s-%x.%s",
-                               temp_path[path_size - 1] == '\\' ? "" : "\\",
-                               base, uniq, ext);
-      HANDLE h = CreateFile (temp_path,  /* file name */
-                             GENERIC_READ | GENERIC_WRITE, /* desired access */
-                             0,                            /* no share mode */
-                             NULL,                         /* default security attributes */
-                             CREATE_NEW,                   /* creation disposition */
-                             FILE_ATTRIBUTE_NORMAL |       /* flags and attributes */
-                             FILE_ATTRIBUTE_TEMPORARY,     /* we'll delete it */
-                             NULL);                        /* no template file */
-
-      if (h == INVALID_HANDLE_VALUE)
-        {
-          const DWORD er = GetLastError ();
-
-          if (er == ERROR_FILE_EXISTS || er == ERROR_ALREADY_EXISTS)
-            {
-              ++uniq;
-              if (uniq == 0x10000 && !second_loop)
-                {
-                  second_loop = 1;
-                  uniq = 1;
-                }
-            }
-
-          /* the temporary path is not guaranteed to exist */
-          else if (path_is_dot == 0)
-            {
-              path_size = GetCurrentDirectory (sizeof temp_path, temp_path);
-              path_is_dot = 1;
-            }
-
-          else
-            {
-              error_string = map_windows32_error_to_string (er);
-              break;
-            }
-        }
-      else
-        {
-          const unsigned final_size = path_size + size + 1;
-          char *const path = xmalloc (final_size);
-          memcpy (path, temp_path, final_size);
-          *fd = _open_osfhandle ((intptr_t)h, 0);
-          if (unixy)
-            {
-              char *p;
-              int ch;
-              for (p = path; (ch = *p) != 0; ++p)
-                if (ch == '\\')
-                  *p = '/';
-            }
-          return path; /* good return */
-        }
-    }
-
-  *fd = -1;
-  if (error_string == NULL)
-    error_string = _("Cannot create a temporary file\n");
-  O (fatal, NILF, error_string);
-
-  /* not reached */
-  return NULL;
-}
-#endif /* WINDOWS32 */
-
-#ifdef __EMX__
-/* returns whether path is assumed to be a unix like shell. */
-int
-_is_unixy_shell (const char *path)
-{
-  /* list of non unix shells */
-  const char *known_os2shells[] = {
-    "cmd.exe",
-    "cmd",
-    "4os2.exe",
-    "4os2",
-    "4dos.exe",
-    "4dos",
-    "command.com",
-    "command",
-    NULL
-  };
-
-  /* find the rightmost '/' or '\\' */
-  const char *name = strrchr (path, '/');
-  const char *p = strrchr (path, '\\');
-  unsigned i;
-
-  if (name && p)    /* take the max */
-    name = (name > p) ? name : p;
-  else if (p)       /* name must be 0 */
-    name = p;
-  else if (!name)   /* name and p must be 0 */
-    name = path;
-
-  if (*name == '/' || *name == '\\') name++;
-
-  i = 0;
-  while (known_os2shells[i] != NULL)
-    {
-      if (strcasecmp (name, known_os2shells[i]) == 0)
-        return 0; /* not a unix shell */
-      i++;
-    }
-
-  /* in doubt assume a unix like shell */
-  return 1;
-}
-#endif /* __EMX__ */
-
-/* determines whether path looks to be a Bourne-like shell. */
-int
-is_bourne_compatible_shell (const char *path)
-{
-  /* List of known POSIX (or POSIX-ish) shells.  */
-  static const char *unix_shells[] = {
-    "sh",
-    "bash",
-    "ksh",
-    "rksh",
-    "zsh",
-    "ash",
-    "dash",
-    NULL
-  };
-  const char **s;
-
-  /* find the rightmost '/' or '\\' */
-  const char *name = strrchr (path, '/');
-  char *p = strrchr (path, '\\');
-
-  if (name && p)    /* take the max */
-    name = (name > p) ? name : p;
-  else if (p)       /* name must be 0 */
-    name = p;
-  else if (!name)   /* name and p must be 0 */
-    name = path;
-
-  if (*name == '/' || *name == '\\')
-    ++name;
-
-  /* this should be able to deal with extensions on Windows-like systems */
-  for (s = unix_shells; *s != NULL; ++s)
-    {
-#if defined(WINDOWS32) || defined(__MSDOS__)
-      unsigned int len = strlen (*s);
-      if ((strlen (name) >= len && STOP_SET (name[len], MAP_DOT|MAP_NUL))
-          && strncasecmp (name, *s, len) == 0)
-#else
-      if (strcmp (name, *s) == 0)
-#endif
-        return 1; /* a known unix-style shell */
-    }
-
-  /* if not on the list, assume it's not a Bourne-like shell */
-  return 0;
-}
-
-#ifdef POSIX
-extern sigset_t fatal_signal_set;
-
-static void
-block_sigs ()
-{
-  sigprocmask (SIG_BLOCK, &fatal_signal_set, (sigset_t *) 0);
-}
-
-static void
-unblock_sigs ()
-{
-  sigprocmask (SIG_UNBLOCK, &fatal_signal_set, (sigset_t *) 0);
-}
-
-void
-unblock_all_sigs ()
-{
-  sigset_t empty;
-  sigemptyset (&empty);
-  sigprocmask (SIG_SETMASK, &empty, (sigset_t *) 0);
-}
-
-#elif defined(HAVE_SIGSETMASK)
-
-extern int fatal_signal_mask;
-
-static void
-block_sigs ()
-{
-  sigblock (fatal_signal_mask);
-}
-
-static void
-unblock_sigs ()
-{
-  sigsetmask (siggetmask (0) & ~fatal_signal_mask)
-}
-
-void
-unblock_all_sigs ()
-{
-  sigsetmask (0);
-}
-
-#else
-
-#define block_sigs()
-#define unblock_sigs()
-
-void
-unblock_all_sigs ()
-{
-}
-
-#endif
-
-/* Write an error message describing the exit status given in
-   EXIT_CODE, EXIT_SIG, and COREDUMP, for the target TARGET_NAME.
-   Append "(ignored)" if IGNORED is nonzero.  */
-
-static void
-child_error (struct child *child,
-             int exit_code, int exit_sig, int coredump, int ignored)
-{
-  const char *pre = "*** ";
-  const char *post = "";
-  const char *dump = "";
-  const struct file *f = child->file;
-  const floc *flocp = &f->cmds->fileinfo;
-  const char *nm;
-  size_t l;
-
-  if (ignored && silent_flag)
-    return;
-
-  if (exit_sig && coredump)
-    dump = _(" (core dumped)");
-
-  if (ignored)
-    {
-      pre = "";
-      post = _(" (ignored)");
-    }
-
-  if (! flocp->filenm)
-    nm = _("<builtin>");
-  else
-    {
-      /* We can't use the standard <FILE>:<LINENO> syntax here because
-         Emacs misinterprets it and matches a bogus filename in the compile
-         buffer.  */
-      char *a = alloca (strlen (flocp->filenm) + 6 + INTSTR_LENGTH + 1);
-      sprintf (a, "%s;%lu", flocp->filenm, flocp->lineno + flocp->offset);
-      nm = a;
-    }
-
-  l = strlen (pre) + strlen (nm) + strlen (f->name) + strlen (post);
-
-  OUTPUT_SET (&child->output);
-
-  show_goal_error ();
-
-  if (exit_sig == 0)
-    error (NILF, l + INTSTR_LENGTH,
-           _("%s[%s: %s] Error %d%s"), pre, nm, f->name, exit_code, post);
-  else
-    {
-      const char *s = strsignal (exit_sig);
-      error (NILF, l + strlen (s) + strlen (dump),
-             "%s[%s: %s] %s%s%s", pre, nm, f->name, s, dump, post);
-    }
-
-  OUTPUT_UNSET ();
-}
-
-
-/* Handle a dead child.  This handler may or may not ever be installed.
-
-   If we're using the jobserver feature without pselect(), we need it.
-   First, installing it ensures the read will interrupt on SIGCHLD.  Second,
-   we close the dup'd read FD to ensure we don't enter another blocking read
-   without reaping all the dead children.  In this case we don't need the
-   dead_children count.
-
-   If we don't have either waitpid or wait3, then make is unreliable, but we
-   use the dead_children count to reap children as best we can.  */
-
-static unsigned int dead_children = 0;
-
-RETSIGTYPE
-child_handler (int sig UNUSED)
-{
-  ++dead_children;
-
-  jobserver_signal ();
-
-#ifdef __EMX__
-  /* The signal handler must called only once! */
-  signal (SIGCHLD, SIG_DFL);
-#endif
-}
-
-extern pid_t shell_function_pid;
-
-/* Reap all dead children, storing the returned status and the new command
-   state ('cs_finished') in the 'file' member of the 'struct child' for the
-   dead child, and removing the child from the chain.  In addition, if BLOCK
-   nonzero, we block in this function until we've reaped at least one
-   complete child, waiting for it to die if necessary.  If ERR is nonzero,
-   print an error message first.  */
-
-void
-reap_children (int block, int err)
-{
-#ifndef WINDOWS32
-  WAIT_T status;
-#endif
-  /* Initially, assume we have some.  */
-  int reap_more = 1;
-
-#ifdef WAIT_NOHANG
-# define REAP_MORE reap_more
-#else
-# define REAP_MORE dead_children
-#endif
-
-  /* As long as:
-
-       We have at least one child outstanding OR a shell function in progress,
-         AND
-       We're blocking for a complete child OR there are more children to reap
-
-     we'll keep reaping children.  */
-
-  while ((children != 0 || shell_function_pid != 0)
-         && (block || REAP_MORE))
-    {
-      unsigned int remote = 0;
-      pid_t pid;
-      int exit_code, exit_sig, coredump;
-      struct child *lastc, *c;
-      int child_failed;
-      int any_remote, any_local;
-      int dontcare;
-
-      if (err && block)
-        {
-          static int printed = 0;
-
-          /* We might block for a while, so let the user know why.
-             Only print this message once no matter how many jobs are left.  */
-          fflush (stdout);
-          if (!printed)
-            O (error, NILF, _("*** Waiting for unfinished jobs...."));
-          printed = 1;
-        }
-
-      /* We have one less dead child to reap.  As noted in
-         child_handler() above, this count is completely unimportant for
-         all modern, POSIX-y systems that support wait3() or waitpid().
-         The rest of this comment below applies only to early, broken
-         pre-POSIX systems.  We keep the count only because... it's there...
-
-         The test and decrement are not atomic; if it is compiled into:
-                register = dead_children - 1;
-                dead_children = register;
-         a SIGCHLD could come between the two instructions.
-         child_handler increments dead_children.
-         The second instruction here would lose that increment.  But the
-         only effect of dead_children being wrong is that we might wait
-         longer than necessary to reap a child, and lose some parallelism;
-         and we might print the "Waiting for unfinished jobs" message above
-         when not necessary.  */
-
-      if (dead_children > 0)
-        --dead_children;
-
-      any_remote = 0;
-      any_local = shell_function_pid != 0;
-      for (c = children; c != 0; c = c->next)
-        {
-          any_remote |= c->remote;
-          any_local |= ! c->remote;
-          DB (DB_JOBS, (_("Live child %p (%s) PID %s %s\n"),
-                        c, c->file->name, pid2str (c->pid),
-                        c->remote ? _(" (remote)") : ""));
-#ifdef VMS
-          break;
-#endif
-        }
-
-      /* First, check for remote children.  */
-      if (any_remote)
-        pid = remote_status (&exit_code, &exit_sig, &coredump, 0);
-      else
-        pid = 0;
-
-      if (pid > 0)
-        /* We got a remote child.  */
-        remote = 1;
-      else if (pid < 0)
-        {
-          /* A remote status command failed miserably.  Punt.  */
-        remote_status_lose:
-          pfatal_with_name ("remote_status");
-        }
-      else
-        {
-          /* No remote children.  Check for local children.  */
-#if !defined(__MSDOS__) && !defined(_AMIGA) && !defined(WINDOWS32)
-          if (any_local)
-            {
-#ifdef VMS
-              /* Todo: This needs more untangling multi-process support */
-              /* Just do single child process support now */
-              vmsWaitForChildren (&status);
-              pid = c->pid;
-
-              /* VMS failure status can not be fully translated */
-              status = $VMS_STATUS_SUCCESS (c->cstatus) ? 0 : (1 << 8);
-
-              /* A Posix failure can be exactly translated */
-              if ((c->cstatus & VMS_POSIX_EXIT_MASK) == VMS_POSIX_EXIT_MASK)
-                status = (c->cstatus >> 3 & 255) << 8;
-#else
-#ifdef WAIT_NOHANG
-              if (!block)
-                pid = WAIT_NOHANG (&status);
-              else
-#endif
-                EINTRLOOP (pid, wait (&status));
-#endif /* !VMS */
-            }
-          else
-            pid = 0;
-
-          if (pid < 0)
-            {
-              /* The wait*() failed miserably.  Punt.  */
-              pfatal_with_name ("wait");
-            }
-          else if (pid > 0)
-            {
-              /* We got a child exit; chop the status word up.  */
-              exit_code = WEXITSTATUS (status);
-              exit_sig = WIFSIGNALED (status) ? WTERMSIG (status) : 0;
-              coredump = WCOREDUMP (status);
-
-              /* If we have started jobs in this second, remove one.  */
-              if (job_counter)
-                --job_counter;
-            }
-          else
-            {
-              /* No local children are dead.  */
-              reap_more = 0;
-
-              if (!block || !any_remote)
-                break;
-
-              /* Now try a blocking wait for a remote child.  */
-              pid = remote_status (&exit_code, &exit_sig, &coredump, 1);
-              if (pid < 0)
-                goto remote_status_lose;
-              else if (pid == 0)
-                /* No remote children either.  Finally give up.  */
-                break;
-
-              /* We got a remote child.  */
-              remote = 1;
-            }
-#endif /* !__MSDOS__, !Amiga, !WINDOWS32.  */
-
-#ifdef __MSDOS__
-          /* Life is very different on MSDOS.  */
-          pid = dos_pid - 1;
-          status = dos_status;
-          exit_code = WEXITSTATUS (status);
-          if (exit_code == 0xff)
-            exit_code = -1;
-          exit_sig = WIFSIGNALED (status) ? WTERMSIG (status) : 0;
-          coredump = 0;
-#endif /* __MSDOS__ */
-#ifdef _AMIGA
-          /* Same on Amiga */
-          pid = amiga_pid - 1;
-          status = amiga_status;
-          exit_code = amiga_status;
-          exit_sig = 0;
-          coredump = 0;
-#endif /* _AMIGA */
-#ifdef WINDOWS32
-          {
-            HANDLE hPID;
-            HANDLE hcTID, hcPID;
-            DWORD dwWaitStatus = 0;
-            exit_code = 0;
-            exit_sig = 0;
-            coredump = 0;
-
-            /* Record the thread ID of the main process, so that we
-               could suspend it in the signal handler.  */
-            if (!main_thread)
-              {
-                hcTID = GetCurrentThread ();
-                hcPID = GetCurrentProcess ();
-                if (!DuplicateHandle (hcPID, hcTID, hcPID, &main_thread, 0,
-                                      FALSE, DUPLICATE_SAME_ACCESS))
-                  {
-                    DWORD e = GetLastError ();
-                    fprintf (stderr,
-                             "Determine main thread ID (Error %ld: %s)\n",
-                             e, map_windows32_error_to_string (e));
-                  }
-                else
-                  DB (DB_VERBOSE, ("Main thread handle = %p\n", main_thread));
-              }
-
-            /* wait for anything to finish */
-            hPID = process_wait_for_any (block, &dwWaitStatus);
-            if (hPID)
-              {
-                /* was an error found on this process? */
-                int werr = process_last_err (hPID);
-
-                /* get exit data */
-                exit_code = process_exit_code (hPID);
-
-                /* the extra tests of exit_code are here to prevent
-                   map_windows32_error_to_string from calling 'fatal',
-                   which will then call reap_children again */
-                if (werr && exit_code > 0 && exit_code < WSABASEERR)
-                  fprintf (stderr, "make (e=%d): %s", exit_code,
-                           map_windows32_error_to_string (exit_code));
-
-                /* signal */
-                exit_sig = process_signal (hPID);
-
-                /* cleanup process */
-                process_cleanup (hPID);
-
-                coredump = 0;
-              }
-            else if (dwWaitStatus == WAIT_FAILED)
-              {
-                /* The WaitForMultipleObjects() failed miserably.  Punt.  */
-                pfatal_with_name ("WaitForMultipleObjects");
-              }
-            else if (dwWaitStatus == WAIT_TIMEOUT)
-              {
-                /* No child processes are finished.  Give up waiting. */
-                reap_more = 0;
-                break;
-              }
-
-            pid = (pid_t) hPID;
-          }
-#endif /* WINDOWS32 */
-        }
-
-      /* Check if this is the child of the 'shell' function.  */
-      if (!remote && pid == shell_function_pid)
-        {
-          shell_completed (exit_code, exit_sig);
-          break;
-        }
-
-      /* Search for a child matching the deceased one.  */
-      lastc = 0;
-      for (c = children; c != 0; lastc = c, c = c->next)
-        if (c->pid == pid && c->remote == remote)
-          break;
-
-      if (c == 0)
-        /* An unknown child died.
-           Ignore it; it was inherited from our invoker.  */
-        continue;
-
-      /* Determine the failure status: 0 for success, 1 for updating target in
-         question mode, 2 for anything else.  */
-      if (exit_sig == 0 && exit_code == 0)
-        child_failed = MAKE_SUCCESS;
-      else if (exit_sig == 0 && exit_code == 1 && question_flag && c->recursive)
-        child_failed = MAKE_TROUBLE;
-      else
-        child_failed = MAKE_FAILURE;
-
-      DB (DB_JOBS, (child_failed
-                    ? _("Reaping losing child %p PID %s %s\n")
-                    : _("Reaping winning child %p PID %s %s\n"),
-                    c, pid2str (c->pid), c->remote ? _(" (remote)") : ""));
-
-      if (c->sh_batch_file)
-        {
-          int rm_status;
-
-          DB (DB_JOBS, (_("Cleaning up temp batch file %s\n"),
-                        c->sh_batch_file));
-
-          errno = 0;
-          rm_status = remove (c->sh_batch_file);
-          if (rm_status)
-            DB (DB_JOBS, (_("Cleaning up temp batch file %s failed (%d)\n"),
-                          c->sh_batch_file, errno));
-
-          /* all done with memory */
-          free (c->sh_batch_file);
-          c->sh_batch_file = NULL;
-        }
-
-      /* If this child had the good stdin, say it is now free.  */
-      if (c->good_stdin)
-        good_stdin_used = 0;
-
-      dontcare = c->dontcare;
-
-      if (child_failed && !c->noerror && !ignore_errors_flag)
-        {
-          /* The commands failed.  Write an error message,
-             delete non-precious targets, and abort.  */
-          static int delete_on_error = -1;
-
-          if (!dontcare && child_failed == MAKE_FAILURE)
-            child_error (c, exit_code, exit_sig, coredump, 0);
-
-          c->file->update_status = child_failed == MAKE_FAILURE ? us_failed : us_question;
-          if (delete_on_error == -1)
-            {
-              struct file *f = lookup_file (".DELETE_ON_ERROR");
-              delete_on_error = f != 0 && f->is_target;
-            }
-          if (exit_sig != 0 || delete_on_error)
-            delete_child_targets (c);
-        }
-      else
-        {
-          if (child_failed)
-            {
-              /* The commands failed, but we don't care.  */
-              child_error (c, exit_code, exit_sig, coredump, 1);
-              child_failed = 0;
-            }
-
-          /* If there are more commands to run, try to start them.  */
-          if (job_next_command (c))
-            {
-              if (handling_fatal_signal)
-                {
-                  /* Never start new commands while we are dying.
-                     Since there are more commands that wanted to be run,
-                     the target was not completely remade.  So we treat
-                     this as if a command had failed.  */
-                  c->file->update_status = us_failed;
-                }
-              else
-                {
-#ifndef NO_OUTPUT_SYNC
-                  /* If we're sync'ing per line, write the previous line's
-                     output before starting the next one.  */
-                  if (output_sync == OUTPUT_SYNC_LINE)
-                    output_dump (&c->output);
-#endif
-                  /* Check again whether to start remotely.
-                     Whether or not we want to changes over time.
-                     Also, start_remote_job may need state set up
-                     by start_remote_job_p.  */
-                  c->remote = start_remote_job_p (0);
-                  start_job_command (c);
-                  /* Fatal signals are left blocked in case we were
-                     about to put that child on the chain.  But it is
-                     already there, so it is safe for a fatal signal to
-                     arrive now; it will clean up this child's targets.  */
-                  unblock_sigs ();
-                  if (c->file->command_state == cs_running)
-                    /* We successfully started the new command.
-                       Loop to reap more children.  */
-                    continue;
-                }
-
-              if (c->file->update_status != us_success)
-                /* We failed to start the commands.  */
-                delete_child_targets (c);
-            }
-          else
-            /* There are no more commands.  We got through them all
-               without an unignored error.  Now the target has been
-               successfully updated.  */
-            c->file->update_status = us_success;
-        }
-
-      /* When we get here, all the commands for c->file are finished.  */
-
-#ifndef NO_OUTPUT_SYNC
-      /* Synchronize any remaining parallel output.  */
-      output_dump (&c->output);
-#endif
-
-      /* At this point c->file->update_status is success or failed.  But
-         c->file->command_state is still cs_running if all the commands
-         ran; notice_finish_file looks for cs_running to tell it that
-         it's interesting to check the file's modtime again now.  */
-
-      if (! handling_fatal_signal)
-        /* Notice if the target of the commands has been changed.
-           This also propagates its values for command_state and
-           update_status to its also_make files.  */
-        notice_finished_file (c->file);
-
-      DB (DB_JOBS, (_("Removing child %p PID %s%s from chain.\n"),
-                    c, pid2str (c->pid), c->remote ? _(" (remote)") : ""));
-
-      /* Block fatal signals while frobnicating the list, so that
-         children and job_slots_used are always consistent.  Otherwise
-         a fatal signal arriving after the child is off the chain and
-         before job_slots_used is decremented would believe a child was
-         live and call reap_children again.  */
-      block_sigs ();
-
-      /* There is now another slot open.  */
-      if (job_slots_used > 0)
-        --job_slots_used;
-
-      /* Remove the child from the chain and free it.  */
-      if (lastc == 0)
-        children = c->next;
-      else
-        lastc->next = c->next;
-
-      free_child (c);
-
-      unblock_sigs ();
-
-      /* If the job failed, and the -k flag was not given, die,
-         unless we are already in the process of dying.  */
-      if (!err && child_failed && !dontcare && !keep_going_flag &&
-          /* fatal_error_signal will die with the right signal.  */
-          !handling_fatal_signal)
-        die (child_failed);
-
-      /* Only block for one child.  */
-      block = 0;
-    }
-
-  return;
-}
-
-/* Free the storage allocated for CHILD.  */
-
-static void
-free_child (struct child *child)
-{
-  output_close (&child->output);
-
-  if (!jobserver_tokens)
-    ONS (fatal, NILF, "INTERNAL: Freeing child %p (%s) but no tokens left!\n",
-         child, child->file->name);
-
-  /* If we're using the jobserver and this child is not the only outstanding
-     job, put a token back into the pipe for it.  */
-
-  if (jobserver_enabled () && jobserver_tokens > 1)
-    {
-      jobserver_release (1);
-      DB (DB_JOBS, (_("Released token for child %p (%s).\n"),
-                    child, child->file->name));
-    }
-
-  --jobserver_tokens;
-
-  if (handling_fatal_signal) /* Don't bother free'ing if about to die.  */
-    return;
-
-  if (child->command_lines != 0)
-    {
-      unsigned int i;
-      for (i = 0; i < child->file->cmds->ncommand_lines; ++i)
-        free (child->command_lines[i]);
-      free (child->command_lines);
-    }
-
-  if (child->environment != 0)
-    {
-      char **ep = child->environment;
-      while (*ep != 0)
-        free (*ep++);
-      free (child->environment);
-    }
-
-  free (child);
-}
-
-
-/* Start a job to run the commands specified in CHILD.
-   CHILD is updated to reflect the commands and ID of the child process.
-
-   NOTE: On return fatal signals are blocked!  The caller is responsible
-   for calling 'unblock_sigs', once the new child is safely on the chain so
-   it can be cleaned up in the event of a fatal signal.  */
-
-static void
-start_job_command (struct child *child)
-{
-  int flags;
-  char *p;
-#ifdef VMS
-  char *argv;
-#else
-  char **argv;
-#endif
-
-  /* If we have a completely empty commandset, stop now.  */
-  if (!child->command_ptr)
-    goto next_command;
-
-  /* Combine the flags parsed for the line itself with
-     the flags specified globally for this target.  */
-  flags = (child->file->command_flags
-           | child->file->cmds->lines_flags[child->command_line - 1]);
-
-  p = child->command_ptr;
-  child->noerror = ((flags & COMMANDS_NOERROR) != 0);
-
-  while (*p != '\0')
-    {
-      if (*p == '@')
-        flags |= COMMANDS_SILENT;
-      else if (*p == '+')
-        flags |= COMMANDS_RECURSE;
-      else if (*p == '-')
-        child->noerror = 1;
-      /* Don't skip newlines.  */
-      else if (!ISBLANK (*p))
-        break;
-      ++p;
-    }
-
-  child->recursive = ((flags & COMMANDS_RECURSE) != 0);
-
-  /* Update the file's command flags with any new ones we found.  We only
-     keep the COMMANDS_RECURSE setting.  Even this isn't 100% correct; we are
-     now marking more commands recursive than should be in the case of
-     multiline define/endef scripts where only one line is marked "+".  In
-     order to really fix this, we'll have to keep a lines_flags for every
-     actual line, after expansion.  */
-  child->file->cmds->lines_flags[child->command_line - 1] |= flags & COMMANDS_RECURSE;
-
-  /* POSIX requires that a recipe prefix after a backslash-newline should
-     be ignored.  Remove it now so the output is correct.  */
-  {
-    char prefix = child->file->cmds->recipe_prefix;
-    char *p1, *p2;
-    p1 = p2 = p;
-    while (*p1 != '\0')
-      {
-        *(p2++) = *p1;
-        if (p1[0] == '\n' && p1[1] == prefix)
-          ++p1;
-        ++p1;
-      }
-    *p2 = *p1;
-  }
-
-  /* Figure out an argument list from this command line.  */
-  {
-    char *end = 0;
-#ifdef VMS
-    /* Skip any leading whitespace */
-    while (*p)
-      {
-        if (!ISSPACE (*p))
-          {
-            if (*p != '\\')
-              break;
-            if ((p[1] != '\n') && (p[1] != 'n') && (p[1] != 't'))
-              break;
-          }
-        p++;
-      }
-
-    argv = p;
-    /* Although construct_command_argv contains some code for VMS, it was/is
-       not called/used.  Please note, for VMS argv is a string (not an array
-       of strings) which contains the complete command line, which for
-       multi-line variables still includes the newlines.  So detect newlines
-       and set 'end' (which is used for child->command_ptr) instead of
-       (re-)writing construct_command_argv */
-    if (!one_shell)
-      {
-        char *s = p;
-        int instring = 0;
-        while (*s)
-          {
-            if (*s == '"')
-              instring = !instring;
-            else if (*s == '\\' && !instring && *(s+1) != 0)
-              s++;
-            else if (*s == '\n' && !instring)
-              {
-                end = s;
-                break;
-              }
-            ++s;
-          }
-      }
-#else
-    argv = construct_command_argv (p, &end, child->file,
-                                   child->file->cmds->lines_flags[child->command_line - 1],
-                                   &child->sh_batch_file);
-#endif
-    if (end == NULL)
-      child->command_ptr = NULL;
-    else
-      {
-        *end++ = '\0';
-        child->command_ptr = end;
-      }
-  }
-
-  /* If -q was given, say that updating 'failed' if there was any text on the
-     command line, or 'succeeded' otherwise.  The exit status of 1 tells the
-     user that -q is saying 'something to do'; the exit status for a random
-     error is 2.  */
-  if (argv != 0 && question_flag && !(flags & COMMANDS_RECURSE))
-    {
-#ifndef VMS
-      free (argv[0]);
-      free (argv);
-#endif
-#ifdef VMS
-      /* On VMS, argv[0] can be a null string here */
-      if (argv[0] != 0)
-        {
-#endif
-          child->file->update_status = us_question;
-          notice_finished_file (child->file);
-          return;
-#ifdef VMS
-        }
-#endif
-    }
-
-  if (touch_flag && !(flags & COMMANDS_RECURSE))
-    {
-      /* Go on to the next command.  It might be the recursive one.
-         We construct ARGV only to find the end of the command line.  */
-#ifndef VMS
-      if (argv)
-        {
-          free (argv[0]);
-          free (argv);
-        }
-#endif
-      argv = 0;
-    }
-
-  if (argv == 0)
-    {
-    next_command:
-#ifdef __MSDOS__
-      execute_by_shell = 0;   /* in case construct_command_argv sets it */
-#endif
-      /* This line has no commands.  Go to the next.  */
-      if (job_next_command (child))
-        start_job_command (child);
-      else
-        {
-          /* No more commands.  Make sure we're "running"; we might not be if
-             (e.g.) all commands were skipped due to -n.  */
-          set_command_state (child->file, cs_running);
-          child->file->update_status = us_success;
-          notice_finished_file (child->file);
-        }
-
-      OUTPUT_UNSET();
-      return;
-    }
-
-  /* Are we going to synchronize this command's output?  Do so if either we're
-     in SYNC_RECURSE mode or this command is not recursive.  We'll also check
-     output_sync separately below in case it changes due to error.  */
-  child->output.syncout = output_sync && (output_sync == OUTPUT_SYNC_RECURSE
-                                          || !(flags & COMMANDS_RECURSE));
-
-  OUTPUT_SET (&child->output);
-
-#ifndef NO_OUTPUT_SYNC
-  if (! child->output.syncout)
-    /* We don't want to sync this command: to avoid misordered
-       output ensure any already-synced content is written.  */
-    output_dump (&child->output);
-#endif
-
-  /* Print the command if appropriate.  */
-  if (just_print_flag || trace_flag
-      || (!(flags & COMMANDS_SILENT) && !silent_flag))
-    OS (message, 0, "%s", p);
-
-  /* Tell update_goal_chain that a command has been started on behalf of
-     this target.  It is important that this happens here and not in
-     reap_children (where we used to do it), because reap_children might be
-     reaping children from a different target.  We want this increment to
-     guaranteedly indicate that a command was started for the dependency
-     chain (i.e., update_file recursion chain) we are processing.  */
-
-  ++commands_started;
-
-  /* Optimize an empty command.  People use this for timestamp rules,
-     so avoid forking a useless shell.  Do this after we increment
-     commands_started so make still treats this special case as if it
-     performed some action (makes a difference as to what messages are
-     printed, etc.  */
-
-#if !defined(VMS) && !defined(_AMIGA)
-  if (
-#if defined __MSDOS__ || defined (__EMX__)
-      unixy_shell       /* the test is complicated and we already did it */
-#else
-      (argv[0] && is_bourne_compatible_shell (argv[0]))
-#endif
-      && (argv[1] && argv[1][0] == '-'
-        &&
-            ((argv[1][1] == 'c' && argv[1][2] == '\0')
-          ||
-             (argv[1][1] == 'e' && argv[1][2] == 'c' && argv[1][3] == '\0')))
-      && (argv[2] && argv[2][0] == ':' && argv[2][1] == '\0')
-      && argv[3] == NULL)
-    {
-      free (argv[0]);
-      free (argv);
-      goto next_command;
-    }
-#endif  /* !VMS && !_AMIGA */
-
-  /* If -n was given, recurse to get the next line in the sequence.  */
-
-  if (just_print_flag && !(flags & COMMANDS_RECURSE))
-    {
-#ifndef VMS
-      free (argv[0]);
-      free (argv);
-#endif
-      goto next_command;
-    }
-
-  /* We're sure we're going to invoke a command: set up the output.  */
-  output_start ();
-
-  /* Flush the output streams so they won't have things written twice.  */
-
-  fflush (stdout);
-  fflush (stderr);
-
-  /* Decide whether to give this child the 'good' standard input
-     (one that points to the terminal or whatever), or the 'bad' one
-     that points to the read side of a broken pipe.  */
-
-  child->good_stdin = !good_stdin_used;
-  if (child->good_stdin)
-    good_stdin_used = 1;
-
-  child->deleted = 0;
-
-#ifndef _AMIGA
-  /* Set up the environment for the child.  */
-  if (child->environment == 0)
-    child->environment = target_environment (child->file);
-#endif
-
-#if !defined(__MSDOS__) && !defined(_AMIGA) && !defined(WINDOWS32)
-
-#ifndef VMS
-  /* start_waiting_job has set CHILD->remote if we can start a remote job.  */
-  if (child->remote)
-    {
-      int is_remote, id, used_stdin;
-      if (start_remote_job (argv, child->environment,
-                            child->good_stdin ? 0 : get_bad_stdin (),
-                            &is_remote, &id, &used_stdin))
-        /* Don't give up; remote execution may fail for various reasons.  If
-           so, simply run the job locally.  */
-        goto run_local;
-      else
-        {
-          if (child->good_stdin && !used_stdin)
-            {
-              child->good_stdin = 0;
-              good_stdin_used = 0;
-            }
-          child->remote = is_remote;
-          child->pid = id;
-        }
-    }
-  else
-#endif /* !VMS */
-    {
-      /* Fork the child process.  */
-
-      char **parent_environ;
-
-    run_local:
-      block_sigs ();
-
-      child->remote = 0;
-
-#ifdef VMS
-      if (!child_execute_job (child, argv))
-        {
-          /* Fork failed!  */
-          perror_with_name ("fork", "");
-          goto error;
-        }
-
-#else
-
-      parent_environ = environ;
-
-      jobserver_pre_child (flags & COMMANDS_RECURSE);
-
-      child->pid = child_execute_job (&child->output, child->good_stdin, argv, child->environment);
-
-      environ = parent_environ; /* Restore value child may have clobbered.  */
-      jobserver_post_child (flags & COMMANDS_RECURSE);
-
-      if (child->pid < 0)
-        {
-          /* Fork failed!  */
-          unblock_sigs ();
-          perror_with_name ("fork", "");
-          goto error;
-        }
-#endif /* !VMS */
-    }
-
-#else   /* __MSDOS__ or Amiga or WINDOWS32 */
-#ifdef __MSDOS__
-  {
-    int proc_return;
-
-    block_sigs ();
-    dos_status = 0;
-
-    /* We call 'system' to do the job of the SHELL, since stock DOS
-       shell is too dumb.  Our 'system' knows how to handle long
-       command lines even if pipes/redirection is needed; it will only
-       call COMMAND.COM when its internal commands are used.  */
-    if (execute_by_shell)
-      {
-        char *cmdline = argv[0];
-        /* We don't have a way to pass environment to 'system',
-           so we need to save and restore ours, sigh...  */
-        char **parent_environ = environ;
-
-        environ = child->environment;
-
-        /* If we have a *real* shell, tell 'system' to call
-           it to do everything for us.  */
-        if (unixy_shell)
-          {
-            /* A *real* shell on MSDOS may not support long
-               command lines the DJGPP way, so we must use 'system'.  */
-            cmdline = argv[2];  /* get past "shell -c" */
-          }
-
-        dos_command_running = 1;
-        proc_return = system (cmdline);
-        environ = parent_environ;
-        execute_by_shell = 0;   /* for the next time */
-      }
-    else
-      {
-        dos_command_running = 1;
-        proc_return = spawnvpe (P_WAIT, argv[0], argv, child->environment);
-      }
-
-    /* Need to unblock signals before turning off
-       dos_command_running, so that child's signals
-       will be treated as such (see fatal_error_signal).  */
-    unblock_sigs ();
-    dos_command_running = 0;
-
-    /* If the child got a signal, dos_status has its
-       high 8 bits set, so be careful not to alter them.  */
-    if (proc_return == -1)
-      dos_status |= 0xff;
-    else
-      dos_status |= (proc_return & 0xff);
-    ++dead_children;
-    child->pid = dos_pid++;
-  }
-#endif /* __MSDOS__ */
-#ifdef _AMIGA
-  amiga_status = MyExecute (argv);
-
-  ++dead_children;
-  child->pid = amiga_pid++;
-  if (amiga_batch_file)
-  {
-     amiga_batch_file = 0;
-     DeleteFile (amiga_bname);        /* Ignore errors.  */
-  }
-#endif  /* Amiga */
-#ifdef WINDOWS32
-  {
-      HANDLE hPID;
-      char* arg0;
-      int outfd = FD_STDOUT;
-      int errfd = FD_STDERR;
-
-      /* make UNC paths safe for CreateProcess -- backslash format */
-      arg0 = argv[0];
-      if (arg0 && arg0[0] == '/' && arg0[1] == '/')
-        for ( ; arg0 && *arg0; arg0++)
-          if (*arg0 == '/')
-            *arg0 = '\\';
-
-      /* make sure CreateProcess() has Path it needs */
-      sync_Path_environment ();
-
-#ifndef NO_OUTPUT_SYNC
-      /* Divert child output if output_sync in use.  */
-      if (child->output.syncout)
-        {
-          if (child->output.out >= 0)
-            outfd = child->output.out;
-          if (child->output.err >= 0)
-            errfd = child->output.err;
-        }
-#else
-      outfd = errfd = -1;
-#endif
-      hPID = process_easy (argv, child->environment, outfd, errfd);
-
-      if (hPID != INVALID_HANDLE_VALUE)
-        child->pid = (pid_t) hPID;
-      else
-        {
-          int i;
-          unblock_sigs ();
-          fprintf (stderr,
-                   _("process_easy() failed to launch process (e=%ld)\n"),
-                   process_last_err (hPID));
-          for (i = 0; argv[i]; i++)
-            fprintf (stderr, "%s ", argv[i]);
-          fprintf (stderr, _("\nCounted %d args in failed launch\n"), i);
-          goto error;
-        }
-  }
-#endif /* WINDOWS32 */
-#endif  /* __MSDOS__ or Amiga or WINDOWS32 */
-
-  /* Bump the number of jobs started in this second.  */
-  ++job_counter;
-
-  /* We are the parent side.  Set the state to
-     say the commands are running and return.  */
-
-  set_command_state (child->file, cs_running);
-
-  /* Free the storage used by the child's argument list.  */
-#ifndef VMS
-  free (argv[0]);
-  free (argv);
-#endif
-
-  OUTPUT_UNSET();
-  return;
-
- error:
-  child->file->update_status = us_failed;
-  notice_finished_file (child->file);
-  OUTPUT_UNSET();
-}
-
-/* Try to start a child running.
-   Returns nonzero if the child was started (and maybe finished), or zero if
-   the load was too high and the child was put on the 'waiting_jobs' chain.  */
-
-static int
-start_waiting_job (struct child *c)
-{
-  struct file *f = c->file;
-
-  /* If we can start a job remotely, we always want to, and don't care about
-     the local load average.  We record that the job should be started
-     remotely in C->remote for start_job_command to test.  */
-
-  c->remote = start_remote_job_p (1);
-
-  /* If we are running at least one job already and the load average
-     is too high, make this one wait.  */
-  if (!c->remote
-      && ((job_slots_used > 0 && load_too_high ())
-#ifdef WINDOWS32
-          || process_table_full ()
-#endif
-          ))
-    {
-      /* Put this child on the chain of children waiting for the load average
-         to go down.  */
-      set_command_state (f, cs_running);
-      c->next = waiting_jobs;
-      waiting_jobs = c;
-      return 0;
-    }
-
-  /* Start the first command; reap_children will run later command lines.  */
-  start_job_command (c);
-
-  switch (f->command_state)
-    {
-    case cs_running:
-      c->next = children;
-      DB (DB_JOBS, (_("Putting child %p (%s) PID %s%s on the chain.\n"),
-                    c, c->file->name, pid2str (c->pid),
-                    c->remote ? _(" (remote)") : ""));
-      children = c;
-      /* One more job slot is in use.  */
-      ++job_slots_used;
-      unblock_sigs ();
-      break;
-
-    case cs_not_started:
-      /* All the command lines turned out to be empty.  */
-      f->update_status = us_success;
-      /* FALLTHROUGH */
-
-    case cs_finished:
-      notice_finished_file (f);
-      free_child (c);
-      break;
-
-    default:
-      assert (f->command_state == cs_finished);
-      break;
-    }
-
-  return 1;
-}
-
-/* Create a 'struct child' for FILE and start its commands running.  */
-
-void
-new_job (struct file *file)
-{
-  struct commands *cmds = file->cmds;
-  struct child *c;
-  char **lines;
-  unsigned int i;
-
-  /* Let any previously decided-upon jobs that are waiting
-     for the load to go down start before this new one.  */
-  start_waiting_jobs ();
-
-  /* Reap any children that might have finished recently.  */
-  reap_children (0, 0);
-
-  /* Chop the commands up into lines if they aren't already.  */
-  chop_commands (cmds);
-
-  /* Start the command sequence, record it in a new
-     'struct child', and add that to the chain.  */
-
-  c = xcalloc (sizeof (struct child));
-  output_init (&c->output);
-
-  c->file = file;
-  c->sh_batch_file = NULL;
-
-  /* Cache dontcare flag because file->dontcare can be changed once we
-     return. Check dontcare inheritance mechanism for details.  */
-  c->dontcare = file->dontcare;
-
-  /* Start saving output in case the expansion uses $(info ...) etc.  */
-  OUTPUT_SET (&c->output);
-
-  /* Expand the command lines and store the results in LINES.  */
-  lines = xmalloc (cmds->ncommand_lines * sizeof (char *));
-  for (i = 0; i < cmds->ncommand_lines; ++i)
-    {
-      /* Collapse backslash-newline combinations that are inside variable
-         or function references.  These are left alone by the parser so
-         that they will appear in the echoing of commands (where they look
-         nice); and collapsed by construct_command_argv when it tokenizes.
-         But letting them survive inside function invocations loses because
-         we don't want the functions to see them as part of the text.  */
-
-      char *in, *out, *ref;
-
-      /* IN points to where in the line we are scanning.
-         OUT points to where in the line we are writing.
-         When we collapse a backslash-newline combination,
-         IN gets ahead of OUT.  */
-
-      in = out = cmds->command_lines[i];
-      while ((ref = strchr (in, '$')) != 0)
-        {
-          ++ref;                /* Move past the $.  */
-
-          if (out != in)
-            /* Copy the text between the end of the last chunk
-               we processed (where IN points) and the new chunk
-               we are about to process (where REF points).  */
-            memmove (out, in, ref - in);
-
-          /* Move both pointers past the boring stuff.  */
-          out += ref - in;
-          in = ref;
-
-          if (*ref == '(' || *ref == '{')
-            {
-              char openparen = *ref;
-              char closeparen = openparen == '(' ? ')' : '}';
-              char *outref;
-              int count;
-              char *p;
-
-              *out++ = *in++;   /* Copy OPENPAREN.  */
-              outref = out;
-              /* IN now points past the opening paren or brace.
-                 Count parens or braces until it is matched.  */
-              count = 0;
-              while (*in != '\0')
-                {
-                  if (*in == closeparen && --count < 0)
-                    break;
-                  else if (*in == '\\' && in[1] == '\n')
-                    {
-                      /* We have found a backslash-newline inside a
-                         variable or function reference.  Eat it and
-                         any following whitespace.  */
-
-                      int quoted = 0;
-                      for (p = in - 1; p > ref && *p == '\\'; --p)
-                        quoted = !quoted;
-
-                      if (quoted)
-                        /* There were two or more backslashes, so this is
-                           not really a continuation line.  We don't collapse
-                           the quoting backslashes here as is done in
-                           collapse_continuations, because the line will
-                           be collapsed again after expansion.  */
-                        *out++ = *in++;
-                      else
-                        {
-                          /* Skip the backslash, newline, and whitespace.  */
-                          in += 2;
-                          NEXT_TOKEN (in);
-
-                          /* Discard any preceding whitespace that has
-                             already been written to the output.  */
-                          while (out > outref && ISBLANK (out[-1]))
-                            --out;
-
-                          /* Replace it all with a single space.  */
-                          *out++ = ' ';
-                        }
-                    }
-                  else
-                    {
-                      if (*in == openparen)
-                        ++count;
-
-                      *out++ = *in++;
-                    }
-                }
-            }
-        }
-
-      /* There are no more references in this line to worry about.
-         Copy the remaining uninteresting text to the output.  */
-      if (out != in)
-        memmove (out, in, strlen (in) + 1);
-
-      /* Finally, expand the line.  */
-      cmds->fileinfo.offset = i;
-      lines[i] = allocated_variable_expand_for_file (cmds->command_lines[i],
-                                                     file);
-    }
-
-  cmds->fileinfo.offset = 0;
-  c->command_lines = lines;
-
-  /* Fetch the first command line to be run.  */
-  job_next_command (c);
-
-  /* Wait for a job slot to be freed up.  If we allow an infinite number
-     don't bother; also job_slots will == 0 if we're using the jobserver.  */
-
-  if (job_slots != 0)
-    while (job_slots_used == job_slots)
-      reap_children (1, 0);
-
-#ifdef MAKE_JOBSERVER
-  /* If we are controlling multiple jobs make sure we have a token before
-     starting the child. */
-
-  /* This can be inefficient.  There's a decent chance that this job won't
-     actually have to run any subprocesses: the command script may be empty
-     or otherwise optimized away.  It would be nice if we could defer
-     obtaining a token until just before we need it, in start_job_command.
-     To do that we'd need to keep track of whether we'd already obtained a
-     token (since start_job_command is called for each line of the job, not
-     just once).  Also more thought needs to go into the entire algorithm;
-     this is where the old parallel job code waits, so...  */
-
-  else if (jobserver_enabled ())
-    while (1)
-      {
-        int got_token;
-
-        DB (DB_JOBS, ("Need a job token; we %shave children\n",
-                      children ? "" : "don't "));
-
-        /* If we don't already have a job started, use our "free" token.  */
-        if (!jobserver_tokens)
-          break;
-
-        /* Prepare for jobserver token acquisition.  */
-        jobserver_pre_acquire ();
-
-        /* Reap anything that's currently waiting.  */
-        reap_children (0, 0);
-
-        /* Kick off any jobs we have waiting for an opportunity that
-           can run now (i.e., waiting for load). */
-        start_waiting_jobs ();
-
-        /* If our "free" slot is available, use it; we don't need a token.  */
-        if (!jobserver_tokens)
-          break;
-
-        /* There must be at least one child already, or we have no business
-           waiting for a token. */
-        if (!children)
-          O (fatal, NILF, "INTERNAL: no children as we go to sleep on read\n");
-
-        /* Get a token.  */
-        got_token = jobserver_acquire (waiting_jobs != NULL);
-
-        /* If we got one, we're done here.  */
-        if (got_token == 1)
-          {
-            DB (DB_JOBS, (_("Obtained token for child %p (%s).\n"),
-                          c, c->file->name));
-            break;
-          }
-      }
-#endif
-
-  ++jobserver_tokens;
-
-  /* Trace the build.
-     Use message here so that changes to working directories are logged.  */
-  if (trace_flag)
-    {
-      char *newer = allocated_variable_expand_for_file ("$?", c->file);
-      const char *nm;
-
-      if (! cmds->fileinfo.filenm)
-        nm = _("<builtin>");
-      else
-        {
-          char *n = alloca (strlen (cmds->fileinfo.filenm) + 1 + 11 + 1);
-          sprintf (n, "%s:%lu", cmds->fileinfo.filenm, cmds->fileinfo.lineno);
-          nm = n;
-        }
-
-      if (newer[0] == '\0')
-        OSS (message, 0,
-             _("%s: target '%s' does not exist"), nm, c->file->name);
-      else
-        OSSS (message, 0,
-              _("%s: update target '%s' due to: %s"), nm, c->file->name, newer);
-
-      free (newer);
-    }
-
-  /* The job is now primed.  Start it running.
-     (This will notice if there is in fact no recipe.)  */
-  start_waiting_job (c);
-
-  if (job_slots == 1 || not_parallel)
-    /* Since there is only one job slot, make things run linearly.
-       Wait for the child to die, setting the state to 'cs_finished'.  */
-    while (file->command_state == cs_running)
-      reap_children (1, 0);
-
-  OUTPUT_UNSET ();
-  return;
-}
-
-/* Move CHILD's pointers to the next command for it to execute.
-   Returns nonzero if there is another command.  */
-
-static int
-job_next_command (struct child *child)
-{
-  while (child->command_ptr == 0 || *child->command_ptr == '\0')
-    {
-      /* There are no more lines in the expansion of this line.  */
-      if (child->command_line == child->file->cmds->ncommand_lines)
-        {
-          /* There are no more lines to be expanded.  */
-          child->command_ptr = 0;
-          child->file->cmds->fileinfo.offset = 0;
-          return 0;
-        }
-      else
-        /* Get the next line to run.  */
-        child->command_ptr = child->command_lines[child->command_line++];
-    }
-
-  child->file->cmds->fileinfo.offset = child->command_line - 1;
-  return 1;
-}
-
-/* Determine if the load average on the system is too high to start a new job.
-
-   On systems which provide /proc/loadavg (e.g., Linux), we use an idea
-   provided by Sven C. Dack <sven.c.dack@sky.com>: retrieve the current number
-   of processes the kernel is running and, if it's greater than the requested
-   load we don't allow another job to start.  We allow a job to start with
-   equal processes since one of those will be for make itself, which will then
-   pause waiting for jobs to clear.
-
-   Otherwise, we obtain the system load average and compare that.
-
-   The system load average is only recomputed once every N (N>=1) seconds.
-   However, a very parallel make can easily start tens or even hundreds of
-   jobs in a second, which brings the system to its knees for a while until
-   that first batch of jobs clears out.
-
-   To avoid this we use a weighted algorithm to try to account for jobs which
-   have been started since the last second, and guess what the load average
-   would be now if it were computed.
-
-   This algorithm was provided by Thomas Riedl <thomas.riedl@siemens.com>,
-   based on load average being recomputed once per second, which is
-   (apparently) how Solaris operates.  Linux recomputes only once every 5
-   seconds, but Linux is handled by the /proc/loadavg algorithm above.
-
-   Thomas writes:
-
-!      calculate something load-oid and add to the observed sys.load,
-!      so that latter can catch up:
-!      - every job started increases jobctr;
-!      - every dying job decreases a positive jobctr;
-!      - the jobctr value gets zeroed every change of seconds,
-!        after its value*weight_b is stored into the 'backlog' value last_sec
-!      - weight_a times the sum of jobctr and last_sec gets
-!        added to the observed sys.load.
-!
-!      The two weights have been tried out on 24 and 48 proc. Sun Solaris-9
-!      machines, using a several-thousand-jobs-mix of cpp, cc, cxx and smallish
-!      sub-shelled commands (rm, echo, sed...) for tests.
-!      lowering the 'direct influence' factor weight_a (e.g. to 0.1)
-!      resulted in significant excession of the load limit, raising it
-!      (e.g. to 0.5) took bad to small, fast-executing jobs and didn't
-!      reach the limit in most test cases.
-!
-!      lowering the 'history influence' weight_b (e.g. to 0.1) resulted in
-!      exceeding the limit for longer-running stuff (compile jobs in
-!      the .5 to 1.5 sec. range),raising it (e.g. to 0.5) overrepresented
-!      small jobs' effects.
-
- */
-
-#define LOAD_WEIGHT_A           0.25
-#define LOAD_WEIGHT_B           0.25
-
-static int
-load_too_high (void)
-{
-#if defined(__MSDOS__) || defined(VMS) || defined(_AMIGA) || defined(__riscos__)
-  return 1;
-#else
-  static double last_sec;
-  static time_t last_now;
-  static int proc_fd = -2;
-  double load, guess;
-  time_t now;
-
-#ifdef WINDOWS32
-  /* sub_proc.c is limited in the number of objects it can wait for. */
-  if (process_table_full ())
-    return 1;
-#endif
-
-  if (max_load_average < 0)
-    return 0;
-
-  /* If we haven't tried to open /proc/loadavg, try now.  */
-#define LOADAVG "/proc/loadavg"
-  if (proc_fd == -2)
-    {
-      EINTRLOOP (proc_fd, open (LOADAVG, O_RDONLY));
-      if (proc_fd < 0)
-        DB (DB_JOBS, ("Using system load detection method.\n"));
-      else
-        {
-          DB (DB_JOBS, ("Using " LOADAVG " load detection method.\n"));
-          fd_noinherit (proc_fd);
-        }
-    }
-
-  /* Try to read /proc/loadavg if we managed to open it.  */
-  if (proc_fd >= 0)
-    {
-      int r;
-
-      EINTRLOOP (r, lseek (proc_fd, 0, SEEK_SET));
-      if (r >= 0)
-        {
-#define PROC_LOADAVG_SIZE 64
-          char avg[PROC_LOADAVG_SIZE+1];
-
-          EINTRLOOP (r, read (proc_fd, avg, PROC_LOADAVG_SIZE));
-          if (r >= 0)
-            {
-              const char *p;
-
-              /* The syntax of /proc/loadavg is:
-                    <1m> <5m> <15m> <running>/<total> <pid>
-                 The load is considered too high if there are more jobs
-                 running than the requested average.  */
-
-              avg[r] = '\0';
-              p = strchr (avg, ' ');
-              if (p)
-                p = strchr (p+1, ' ');
-              if (p)
-                p = strchr (p+1, ' ');
-
-              if (p && ISDIGIT(p[1]))
-                {
-                  int cnt = atoi (p+1);
-                  DB (DB_JOBS, ("Running: system = %d / make = %u (max requested = %f)\n",
-                                cnt, job_slots_used, max_load_average));
-                  return (double)cnt > max_load_average;
-                }
-
-              DB (DB_JOBS, ("Failed to parse " LOADAVG ": %s\n", avg));
-            }
-        }
-
-      /* If we got here, something went wrong.  Give up on this method.  */
-      if (r < 0)
-        DB (DB_JOBS, ("Failed to read " LOADAVG ": %s\n", strerror (errno)));
-
-      close (proc_fd);
-      proc_fd = -1;
-    }
-
-  /* Find the real system load average.  */
-  make_access ();
-  if (getloadavg (&load, 1) != 1)
-    {
-      static int lossage = -1;
-      /* Complain only once for the same error.  */
-      if (lossage == -1 || errno != lossage)
-        {
-          if (errno == 0)
-            /* An errno value of zero means getloadavg is just unsupported.  */
-            O (error, NILF,
-               _("cannot enforce load limits on this operating system"));
-          else
-            perror_with_name (_("cannot enforce load limit: "), "getloadavg");
-        }
-      lossage = errno;
-      load = 0;
-    }
-  user_access ();
-
-  /* If we're in a new second zero the counter and correct the backlog
-     value.  Only keep the backlog for one extra second; after that it's 0.  */
-  now = time (NULL);
-  if (last_now < now)
-    {
-      if (last_now == now - 1)
-        last_sec = LOAD_WEIGHT_B * job_counter;
-      else
-        last_sec = 0.0;
-
-      job_counter = 0;
-      last_now = now;
-    }
-
-  /* Try to guess what the load would be right now.  */
-  guess = load + (LOAD_WEIGHT_A * (job_counter + last_sec));
-
-  DB (DB_JOBS, ("Estimated system load = %f (actual = %f) (max requested = %f)\n",
-                guess, load, max_load_average));
-
-  return guess >= max_load_average;
-#endif
-}
-
-/* Start jobs that are waiting for the load to be lower.  */
-
-void
-start_waiting_jobs (void)
-{
-  struct child *job;
-
-  if (waiting_jobs == 0)
-    return;
-
-  do
-    {
-      /* Check for recently deceased descendants.  */
-      reap_children (0, 0);
-
-      /* Take a job off the waiting list.  */
-      job = waiting_jobs;
-      waiting_jobs = job->next;
-
-      /* Try to start that job.  We break out of the loop as soon
-         as start_waiting_job puts one back on the waiting list.  */
-    }
-  while (start_waiting_job (job) && waiting_jobs != 0);
-
-  return;
-}
-
-#ifndef WINDOWS32
-
-/* EMX: Start a child process. This function returns the new pid.  */
-# if defined __EMX__
-int
-child_execute_job (struct output *out, int good_stdin, char **argv, char **envp)
-{
-  int pid;
-  int fdin = good_stdin ? FD_STDIN : get_bad_stdin ();
-  int fdout = FD_STDOUT;
-  int fderr = FD_STDERR;
-  int save_fdin = -1;
-  int save_fdout = -1;
-  int save_fderr = -1;
-
-  /* Divert child output if we want to capture output.  */
-  if (out && out->syncout)
-    {
-      if (out->out >= 0)
-        fdout = out->out;
-      if (out->err >= 0)
-        fderr = out->err;
-    }
-
-  /* For each FD which needs to be redirected first make a dup of the standard
-     FD to save and mark it close on exec so our child won't see it.  Then
-     dup2() the standard FD to the redirect FD, and also mark the redirect FD
-     as close on exec. */
-  if (fdin != FD_STDIN)
-    {
-      save_fdin = dup (FD_STDIN);
-      if (save_fdin < 0)
-        O (fatal, NILF, _("no more file handles: could not duplicate stdin\n"));
-      fd_noinherit (save_fdin);
-
-      dup2 (fdin, FD_STDIN);
-      fd_noinherit (fdin);
-    }
-
-  if (fdout != FD_STDOUT)
-    {
-      save_fdout = dup (FD_STDOUT);
-      if (save_fdout < 0)
-        O (fatal, NILF,
-           _("no more file handles: could not duplicate stdout\n"));
-      fd_noinherit (save_fdout);
-
-      dup2 (fdout, FD_STDOUT);
-      fd_noinherit (fdout);
-    }
-
-  if (fderr != FD_STDERR)
-    {
-      if (fderr != fdout)
-        {
-          save_fderr = dup (FD_STDERR);
-          if (save_fderr < 0)
-            O (fatal, NILF,
-               _("no more file handles: could not duplicate stderr\n"));
-          fd_noinherit (save_fderr);
-        }
-
-      dup2 (fderr, FD_STDERR);
-      fd_noinherit (fderr);
-    }
-
-  /* Run the command.  */
-  pid = exec_command (argv, envp);
-
-  /* Restore stdout/stdin/stderr of the parent and close temporary FDs.  */
-  if (save_fdin >= 0)
-    {
-      if (dup2 (save_fdin, FD_STDIN) != FD_STDIN)
-        O (fatal, NILF, _("Could not restore stdin\n"));
-      else
-        close (save_fdin);
-    }
-
-  if (save_fdout >= 0)
-    {
-      if (dup2 (save_fdout, FD_STDOUT) != FD_STDOUT)
-        O (fatal, NILF, _("Could not restore stdout\n"));
-      else
-        close (save_fdout);
-    }
-
-  if (save_fderr >= 0)
-    {
-      if (dup2 (save_fderr, FD_STDERR) != FD_STDERR)
-        O (fatal, NILF, _("Could not restore stderr\n"));
-      else
-        close (save_fderr);
-    }
-
-  return pid;
-}
-
-#elif !defined (_AMIGA) && !defined (__MSDOS__) && !defined (VMS)
-
-/* POSIX:
-   Create a child process executing the command in ARGV.
-   ENVP is the environment of the new program.  Returns the PID or -1.  */
-int
-child_execute_job (struct output *out, int good_stdin, char **argv, char **envp)
-{
-  const int fdin = good_stdin ? FD_STDIN : get_bad_stdin ();
-  int fdout = FD_STDOUT;
-  int fderr = FD_STDERR;
-  int r;
-  int pid;
-
-  /* Divert child output if we want to capture it.  */
-  if (out && out->syncout)
-    {
-      if (out->out >= 0)
-        fdout = out->out;
-      if (out->err >= 0)
-        fderr = out->err;
-    }
-
-  pid = vfork();
-  if (pid != 0)
-    return pid;
-
-  /* We are the child.  */
-  unblock_all_sigs ();
-
-#ifdef SET_STACK_SIZE
-  /* Reset limits, if necessary.  */
-  if (stack_limit.rlim_cur)
-    setrlimit (RLIMIT_STACK, &stack_limit);
-#endif
-
-  /* For any redirected FD, dup2() it to the standard FD.
-     They are all marked close-on-exec already.  */
-  if (fdin >= 0 && fdin != FD_STDIN)
-    EINTRLOOP (r, dup2 (fdin, FD_STDIN));
-  if (fdout != FD_STDOUT)
-    EINTRLOOP (r, dup2 (fdout, FD_STDOUT));
-  if (fderr != FD_STDERR)
-    EINTRLOOP (r, dup2 (fderr, FD_STDERR));
-
-  /* Run the command.  */
-  exec_command (argv, envp);
-}
-#endif /* !AMIGA && !__MSDOS__ && !VMS */
-#endif /* !WINDOWS32 */
-
-#ifndef _AMIGA
-/* Replace the current process with one running the command in ARGV,
-   with environment ENVP.  This function does not return.  */
-
-/* EMX: This function returns the pid of the child process.  */
-# ifdef __EMX__
-int
-# else
-void
-# endif
-exec_command (char **argv, char **envp)
-{
-#ifdef VMS
-  /* to work around a problem with signals and execve: ignore them */
-#ifdef SIGCHLD
-  signal (SIGCHLD,SIG_IGN);
-#endif
-  /* Run the program.  */
-  execve (argv[0], argv, envp);
-  perror_with_name ("execve: ", argv[0]);
-  _exit (EXIT_FAILURE);
-#else
-#ifdef WINDOWS32
-  HANDLE hPID;
-  HANDLE hWaitPID;
-  int exit_code = EXIT_FAILURE;
-
-  /* make sure CreateProcess() has Path it needs */
-  sync_Path_environment ();
-
-  /* launch command */
-  hPID = process_easy (argv, envp, -1, -1);
-
-  /* make sure launch ok */
-  if (hPID == INVALID_HANDLE_VALUE)
-    {
-      int i;
-      fprintf (stderr, _("process_easy() failed to launch process (e=%ld)\n"),
-               process_last_err (hPID));
-      for (i = 0; argv[i]; i++)
-          fprintf (stderr, "%s ", argv[i]);
-      fprintf (stderr, _("\nCounted %d args in failed launch\n"), i);
-      exit (EXIT_FAILURE);
-    }
-
-  /* wait and reap last child */
-  hWaitPID = process_wait_for_any (1, 0);
-  while (hWaitPID)
-    {
-      /* was an error found on this process? */
-      int err = process_last_err (hWaitPID);
-
-      /* get exit data */
-      exit_code = process_exit_code (hWaitPID);
-
-      if (err)
-          fprintf (stderr, "make (e=%d, rc=%d): %s",
-                   err, exit_code, map_windows32_error_to_string (err));
-
-      /* cleanup process */
-      process_cleanup (hWaitPID);
-
-      /* expect to find only last pid, warn about other pids reaped */
-      if (hWaitPID == hPID)
-          break;
-      else
-        {
-          char *pidstr = xstrdup (pid2str ((pid_t)hWaitPID));
-
-          fprintf (stderr,
-                   _("make reaped child pid %s, still waiting for pid %s\n"),
-                   pidstr, pid2str ((pid_t)hPID));
-          free (pidstr);
-        }
-    }
-
-  /* return child's exit code as our exit code */
-  exit (exit_code);
-
-#else  /* !WINDOWS32 */
-
-# ifdef __EMX__
-  int pid;
-# endif
-
-  /* Be the user, permanently.  */
-  child_access ();
-
-# ifdef __EMX__
-  /* Run the program.  */
-  pid = spawnvpe (P_NOWAIT, argv[0], argv, envp);
-  if (pid >= 0)
-    return pid;
-
-  /* the file might have a strange shell extension */
-  if (errno == ENOENT)
-    errno = ENOEXEC;
-
-# else
-  /* Run the program.  */
-  environ = envp;
-  execvp (argv[0], argv);
-
-# endif /* !__EMX__ */
-
-  switch (errno)
-    {
-    case ENOENT:
-      /* We are in the child: don't use the output buffer.
-         It's not right to run fprintf() here!  */
-      if (makelevel == 0)
-        fprintf (stderr, _("%s: %s: Command not found\n"), program, argv[0]);
-      else
-        fprintf (stderr, _("%s[%u]: %s: Command not found\n"),
-                 program, makelevel, argv[0]);
-      break;
-    case ENOEXEC:
-      {
-        /* The file is not executable.  Try it as a shell script.  */
-        const char *shell;
-        char **new_argv;
-        int argc;
-        int i=1;
-
-# ifdef __EMX__
-        /* Do not use $SHELL from the environment */
-        struct variable *p = lookup_variable ("SHELL", 5);
-        if (p)
-          shell = p->value;
-        else
-          shell = 0;
-# else
-        shell = getenv ("SHELL");
-# endif
-        if (shell == 0)
-          shell = default_shell;
-
-        argc = 1;
-        while (argv[argc] != 0)
-          ++argc;
-
-# ifdef __EMX__
-        if (!unixy_shell)
-          ++argc;
-# endif
-
-        new_argv = alloca ((1 + argc + 1) * sizeof (char *));
-        new_argv[0] = (char *)shell;
-
-# ifdef __EMX__
-        if (!unixy_shell)
-          {
-            new_argv[1] = "/c";
-            ++i;
-            --argc;
-          }
-# endif
-
-        new_argv[i] = argv[0];
-        while (argc > 0)
-          {
-            new_argv[i + argc] = argv[argc];
-            --argc;
-          }
-
-# ifdef __EMX__
-        pid = spawnvpe (P_NOWAIT, shell, new_argv, envp);
-        if (pid >= 0)
-          break;
-# else
-        execvp (shell, new_argv);
-# endif
-        if (errno == ENOENT)
-          OS (error, NILF, _("%s: Shell program not found"), shell);
-        else
-          perror_with_name ("execvp: ", shell);
-        break;
-      }
-
-# ifdef __EMX__
-    case EINVAL:
-      /* this nasty error was driving me nuts :-( */
-      O (error, NILF, _("spawnvpe: environment space might be exhausted"));
-      /* FALLTHROUGH */
-# endif
-
-    default:
-      perror_with_name ("execvp: ", argv[0]);
-      break;
-    }
-
-# ifdef __EMX__
-  return pid;
-# else
-  _exit (127);
-# endif
-#endif /* !WINDOWS32 */
-#endif /* !VMS */
-}
-#else /* On Amiga */
-void
-exec_command (char **argv)
-{
-  MyExecute (argv);
-}
-
-void clean_tmp (void)
-{
-  DeleteFile (amiga_bname);
-}
-
-#endif /* On Amiga */
-
-#ifndef VMS
-/* Figure out the argument list necessary to run LINE as a command.  Try to
-   avoid using a shell.  This routine handles only ' quoting, and " quoting
-   when no backslash, $ or ' characters are seen in the quotes.  Starting
-   quotes may be escaped with a backslash.  If any of the characters in
-   sh_chars is seen, or any of the builtin commands listed in sh_cmds
-   is the first word of a line, the shell is used.
-
-   If RESTP is not NULL, *RESTP is set to point to the first newline in LINE.
-   If *RESTP is NULL, newlines will be ignored.
-
-   SHELL is the shell to use, or nil to use the default shell.
-   IFS is the value of $IFS, or nil (meaning the default).
-
-   FLAGS is the value of lines_flags for this command line.  It is
-   used in the WINDOWS32 port to check whether + or $(MAKE) were found
-   in this command line, in which case the effect of just_print_flag
-   is overridden.  */
-
-static char **
-construct_command_argv_internal (char *line, char **restp, const char *shell,
-                                 const char *shellflags, const char *ifs,
-                                 int flags, char **batch_filename UNUSED)
-{
-#ifdef __MSDOS__
-  /* MSDOS supports both the stock DOS shell and ports of Unixy shells.
-     We call 'system' for anything that requires ''slow'' processing,
-     because DOS shells are too dumb.  When $SHELL points to a real
-     (unix-style) shell, 'system' just calls it to do everything.  When
-     $SHELL points to a DOS shell, 'system' does most of the work
-     internally, calling the shell only for its internal commands.
-     However, it looks on the $PATH first, so you can e.g. have an
-     external command named 'mkdir'.
-
-     Since we call 'system', certain characters and commands below are
-     actually not specific to COMMAND.COM, but to the DJGPP implementation
-     of 'system'.  In particular:
-
-       The shell wildcard characters are in DOS_CHARS because they will
-       not be expanded if we call the child via 'spawnXX'.
-
-       The ';' is in DOS_CHARS, because our 'system' knows how to run
-       multiple commands on a single line.
-
-       DOS_CHARS also include characters special to 4DOS/NDOS, so we
-       won't have to tell one from another and have one more set of
-       commands and special characters.  */
-  static const char *sh_chars_dos = "*?[];|<>%^&()";
-  static const char *sh_cmds_dos[] =
-    { "break", "call", "cd", "chcp", "chdir", "cls", "copy", "ctty", "date",
-      "del", "dir", "echo", "erase", "exit", "for", "goto", "if", "md",
-      "mkdir", "path", "pause", "prompt", "rd", "rmdir", "rem", "ren",
-      "rename", "set", "shift", "time", "type", "ver", "verify", "vol", ":",
-      0 };
-
-  static const char *sh_chars_sh = "#;\"*?[]&|<>(){}$`^";
-  static const char *sh_cmds_sh[] =
-    { "cd", "echo", "eval", "exec", "exit", "login", "logout", "set", "umask",
-      "wait", "while", "for", "case", "if", ":", ".", "break", "continue",
-      "export", "read", "readonly", "shift", "times", "trap", "switch",
-      "unset", "ulimit", "command", 0 };
-
-  const char *sh_chars;
-  const char **sh_cmds;
-
-#elif defined (__EMX__)
-  static const char *sh_chars_dos = "*?[];|<>%^&()";
-  static const char *sh_cmds_dos[] =
-    { "break", "call", "cd", "chcp", "chdir", "cls", "copy", "ctty", "date",
-      "del", "dir", "echo", "erase", "exit", "for", "goto", "if", "md",
-      "mkdir", "path", "pause", "prompt", "rd", "rmdir", "rem", "ren",
-      "rename", "set", "shift", "time", "type", "ver", "verify", "vol", ":",
-      0 };
-
-  static const char *sh_chars_os2 = "*?[];|<>%^()\"'&";
-  static const char *sh_cmds_os2[] =
-    { "call", "cd", "chcp", "chdir", "cls", "copy", "date", "del", "detach",
-      "dir", "echo", "endlocal", "erase", "exit", "for", "goto", "if", "keys",
-      "md", "mkdir", "move", "path", "pause", "prompt", "rd", "rem", "ren",
-      "rename", "rmdir", "set", "setlocal", "shift", "start", "time", "type",
-      "ver", "verify", "vol", ":", 0 };
-
-  static const char *sh_chars_sh = "#;\"*?[]&|<>(){}$`^~'";
-  static const char *sh_cmds_sh[] =
-    { "echo", "cd", "eval", "exec", "exit", "login", "logout", "set", "umask",
-      "wait", "while", "for", "case", "if", ":", ".", "break", "continue",
-      "export", "read", "readonly", "shift", "times", "trap", "switch",
-      "unset", "command", 0 };
-
-  const char *sh_chars;
-  const char **sh_cmds;
-
-#elif defined (_AMIGA)
-  static const char *sh_chars = "#;\"|<>()?*$`";
-  static const char *sh_cmds[] =
-    { "cd", "eval", "if", "delete", "echo", "copy", "rename", "set", "setenv",
-      "date", "makedir", "skip", "else", "endif", "path", "prompt", "unset",
-      "unsetenv", "version", "command", 0 };
-
-#elif defined (WINDOWS32)
-  /* We used to have a double quote (") in sh_chars_dos[] below, but
-     that caused any command line with quoted file names be run
-     through a temporary batch file, which introduces command-line
-     limit of 4K charcaters imposed by cmd.exe.  Since CreateProcess
-     can handle quoted file names just fine, removing the quote lifts
-     the limit from a very frequent use case, because using quoted
-     file names is commonplace on MS-Windows.  */
-  static const char *sh_chars_dos = "|&<>";
-  static const char *sh_cmds_dos[] =
-    { "assoc", "break", "call", "cd", "chcp", "chdir", "cls", "color", "copy",
-      "ctty", "date", "del", "dir", "echo", "echo.", "endlocal", "erase",
-      "exit", "for", "ftype", "goto", "if", "if", "md", "mkdir", "move",
-      "path", "pause", "prompt", "rd", "rem", "ren", "rename", "rmdir",
-      "set", "setlocal", "shift", "time", "title", "type", "ver", "verify",
-      "vol", ":", 0 };
-
-  static const char *sh_chars_sh = "#;\"*?[]&|<>(){}$`^";
-  static const char *sh_cmds_sh[] =
-    { "cd", "eval", "exec", "exit", "login", "logout", "set", "umask", "wait",
-      "while", "for", "case", "if", ":", ".", "break", "continue", "export",
-      "read", "readonly", "shift", "times", "trap", "switch", "test", "command",
-#ifdef BATCH_MODE_ONLY_SHELL
-      "echo",
-#endif
-      0 };
-
-  const char *sh_chars;
-  const char **sh_cmds;
-#elif defined(__riscos__)
-  static const char *sh_chars = "";
-  static const char *sh_cmds[] = { 0 };
-#else  /* must be UNIX-ish */
-  static const char *sh_chars = "#;\"*?[]&|<>(){}$`^~!";
-  static const char *sh_cmds[] =
-    { ".", ":", "break", "case", "cd", "command", "continue", "eval", "exec",
-      "exit", "export", "for", "if", "login", "logout", "read", "readonly",
-      "set", "shift", "switch", "test", "times", "trap", "ulimit", "umask",
-      "unset", "wait", "while", 0 };
-
-# ifdef HAVE_DOS_PATHS
-  /* This is required if the MSYS/Cygwin ports (which do not define
-     WINDOWS32) are compiled with HAVE_DOS_PATHS defined, which uses
-     sh_chars_sh directly (see below).  The value must be identical
-     to that of sh_chars immediately above.  */
-  static const char *sh_chars_sh =  "#;\"*?[]&|<>(){}$`^~!";
-# endif  /* HAVE_DOS_PATHS */
-#endif
-  int i;
-  char *p;
-#ifndef NDEBUG
-  char *end;
-#endif
-  char *ap;
-  const char *cap;
-  const char *cp;
-  int instring, word_has_equals, seen_nonequals, last_argument_was_empty;
-  char **new_argv = 0;
-  char *argstr = 0;
-#ifdef WINDOWS32
-  int slow_flag = 0;
-
-  if (!unixy_shell)
-    {
-      sh_cmds = sh_cmds_dos;
-      sh_chars = sh_chars_dos;
-    }
-  else
-    {
-      sh_cmds = sh_cmds_sh;
-      sh_chars = sh_chars_sh;
-    }
-#endif /* WINDOWS32 */
-
-  if (restp != NULL)
-    *restp = NULL;
-
-  /* Make sure not to bother processing an empty line but stop at newline.  */
-  while (ISBLANK (*line))
-    ++line;
-  if (*line == '\0')
-    return 0;
-
-  if (shellflags == 0)
-    shellflags = posix_pedantic ? "-ec" : "-c";
-
-  /* See if it is safe to parse commands internally.  */
-  if (shell == 0)
-    shell = default_shell;
-#ifdef WINDOWS32
-  else if (strcmp (shell, default_shell))
-  {
-    char *s1 = _fullpath (NULL, shell, 0);
-    char *s2 = _fullpath (NULL, default_shell, 0);
-
-    slow_flag = strcmp ((s1 ? s1 : ""), (s2 ? s2 : ""));
-
-    free (s1);
-    free (s2);
-  }
-  if (slow_flag)
-    goto slow;
-#else  /* not WINDOWS32 */
-#if defined (__MSDOS__) || defined (__EMX__)
-  else if (strcasecmp (shell, default_shell))
-    {
-      extern int _is_unixy_shell (const char *_path);
-
-      DB (DB_BASIC, (_("$SHELL changed (was '%s', now '%s')\n"),
-                     default_shell, shell));
-      unixy_shell = _is_unixy_shell (shell);
-      /* we must allocate a copy of shell: construct_command_argv() will free
-       * shell after this function returns.  */
-      default_shell = xstrdup (shell);
-    }
-  if (unixy_shell)
-    {
-      sh_chars = sh_chars_sh;
-      sh_cmds  = sh_cmds_sh;
-    }
-  else
-    {
-      sh_chars = sh_chars_dos;
-      sh_cmds  = sh_cmds_dos;
-# ifdef __EMX__
-      if (_osmode == OS2_MODE)
-        {
-          sh_chars = sh_chars_os2;
-          sh_cmds = sh_cmds_os2;
-        }
-# endif
-    }
-#else  /* !__MSDOS__ */
-  else if (strcmp (shell, default_shell))
-    goto slow;
-#endif /* !__MSDOS__ && !__EMX__ */
-#endif /* not WINDOWS32 */
-
-  if (ifs)
-    for (cap = ifs; *cap != '\0'; ++cap)
-      if (*cap != ' ' && *cap != '\t' && *cap != '\n')
-        goto slow;
-
-  if (shellflags)
-    if (shellflags[0] != '-'
-        || ((shellflags[1] != 'c' || shellflags[2] != '\0')
-            && (shellflags[1] != 'e' || shellflags[2] != 'c' || shellflags[3] != '\0')))
-      goto slow;
-
-  i = strlen (line) + 1;
-
-  /* More than 1 arg per character is impossible.  */
-  new_argv = xmalloc (i * sizeof (char *));
-
-  /* All the args can fit in a buffer as big as LINE is.   */
-  ap = new_argv[0] = argstr = xmalloc (i);
-#ifndef NDEBUG
-  end = ap + i;
-#endif
-
-  /* I is how many complete arguments have been found.  */
-  i = 0;
-  instring = word_has_equals = seen_nonequals = last_argument_was_empty = 0;
-  for (p = line; *p != '\0'; ++p)
-    {
-      assert (ap <= end);
-
-      if (instring)
-        {
-          /* Inside a string, just copy any char except a closing quote
-             or a backslash-newline combination.  */
-          if (*p == instring)
-            {
-              instring = 0;
-              if (ap == new_argv[0] || *(ap-1) == '\0')
-                last_argument_was_empty = 1;
-            }
-          else if (*p == '\\' && p[1] == '\n')
-            {
-              /* Backslash-newline is handled differently depending on what
-                 kind of string we're in: inside single-quoted strings you
-                 keep them; in double-quoted strings they disappear.  For
-                 DOS/Windows/OS2, if we don't have a POSIX shell, we keep the
-                 pre-POSIX behavior of removing the backslash-newline.  */
-              if (instring == '"'
-#if defined (__MSDOS__) || defined (__EMX__) || defined (WINDOWS32)
-                  || !unixy_shell
-#endif
-                  )
-                ++p;
-              else
-                {
-                  *(ap++) = *(p++);
-                  *(ap++) = *p;
-                }
-            }
-          else if (*p == '\n' && restp != NULL)
-            {
-              /* End of the command line.  */
-              *restp = p;
-              goto end_of_line;
-            }
-          /* Backslash, $, and ` are special inside double quotes.
-             If we see any of those, punt.
-             But on MSDOS, if we use COMMAND.COM, double and single
-             quotes have the same effect.  */
-          else if (instring == '"' && strchr ("\\$`", *p) != 0 && unixy_shell)
-            goto slow;
-#ifdef WINDOWS32
-          /* Quoted wildcard characters must be passed quoted to the
-             command, so give up the fast route.  */
-          else if (instring == '"' && strchr ("*?", *p) != 0 && !unixy_shell)
-            goto slow;
-          else if (instring == '"' && strncmp (p, "\\\"", 2) == 0)
-            *ap++ = *++p;
-#endif
-          else
-            *ap++ = *p;
-        }
-      else if (strchr (sh_chars, *p) != 0)
-        /* Not inside a string, but it's a special char.  */
-        goto slow;
-      else if (one_shell && *p == '\n')
-        /* In .ONESHELL mode \n is a separator like ; or && */
-        goto slow;
-#ifdef  __MSDOS__
-      else if (*p == '.' && p[1] == '.' && p[2] == '.' && p[3] != '.')
-        /* '...' is a wildcard in DJGPP.  */
-        goto slow;
-#endif
-      else
-        /* Not a special char.  */
-        switch (*p)
-          {
-          case '=':
-            /* Equals is a special character in leading words before the
-               first word with no equals sign in it.  This is not the case
-               with sh -k, but we never get here when using nonstandard
-               shell flags.  */
-            if (! seen_nonequals && unixy_shell)
-              goto slow;
-            word_has_equals = 1;
-            *ap++ = '=';
-            break;
-
-          case '\\':
-            /* Backslash-newline has special case handling, ref POSIX.
-               We're in the fastpath, so emulate what the shell would do.  */
-            if (p[1] == '\n')
-              {
-                /* Throw out the backslash and newline.  */
-                ++p;
-
-                /* At the beginning of the argument, skip any whitespace other
-                   than newline before the start of the next word.  */
-                if (ap == new_argv[i])
-                  while (ISBLANK (p[1]))
-                    ++p;
-              }
-#ifdef WINDOWS32
-            /* Backslash before whitespace is not special if our shell
-               is not Unixy.  */
-            else if (ISSPACE (p[1]) && !unixy_shell)
-              {
-                *ap++ = *p;
-                break;
-              }
-#endif
-            else if (p[1] != '\0')
-              {
-#ifdef HAVE_DOS_PATHS
-                /* Only remove backslashes before characters special to Unixy
-                   shells.  All other backslashes are copied verbatim, since
-                   they are probably DOS-style directory separators.  This
-                   still leaves a small window for problems, but at least it
-                   should work for the vast majority of naive users.  */
-
-#ifdef __MSDOS__
-                /* A dot is only special as part of the "..."
-                   wildcard.  */
-                if (strneq (p + 1, ".\\.\\.", 5))
-                  {
-                    *ap++ = '.';
-                    *ap++ = '.';
-                    p += 4;
-                  }
-                else
-#endif
-                  if (p[1] != '\\' && p[1] != '\''
-                      && !ISSPACE (p[1])
-                      && strchr (sh_chars_sh, p[1]) == 0)
-                    /* back up one notch, to copy the backslash */
-                    --p;
-#endif  /* HAVE_DOS_PATHS */
-
-                /* Copy and skip the following char.  */
-                *ap++ = *++p;
-              }
-            break;
-
-          case '\'':
-          case '"':
-            instring = *p;
-            break;
-
-          case '\n':
-            if (restp != NULL)
-              {
-                /* End of the command line.  */
-                *restp = p;
-                goto end_of_line;
-              }
-            else
-              /* Newlines are not special.  */
-              *ap++ = '\n';
-            break;
-
-          case ' ':
-          case '\t':
-            /* We have the end of an argument.
-               Terminate the text of the argument.  */
-            *ap++ = '\0';
-            new_argv[++i] = ap;
-            last_argument_was_empty = 0;
-
-            /* Update SEEN_NONEQUALS, which tells us if every word
-               heretofore has contained an '='.  */
-            seen_nonequals |= ! word_has_equals;
-            if (word_has_equals && ! seen_nonequals)
-              /* An '=' in a word before the first
-                 word without one is magical.  */
-              goto slow;
-            word_has_equals = 0; /* Prepare for the next word.  */
-
-            /* If this argument is the command name,
-               see if it is a built-in shell command.
-               If so, have the shell handle it.  */
-            if (i == 1)
-              {
-                int j;
-                for (j = 0; sh_cmds[j] != 0; ++j)
-                  {
-                    if (streq (sh_cmds[j], new_argv[0]))
-                      goto slow;
-#if defined(__EMX__) || defined(WINDOWS32)
-                    /* Non-Unix shells are case insensitive.  */
-                    if (!unixy_shell
-                        && strcasecmp (sh_cmds[j], new_argv[0]) == 0)
-                      goto slow;
-#endif
-                  }
-              }
-
-            /* Skip whitespace chars, but not newlines.  */
-            while (ISBLANK (p[1]))
-              ++p;
-            break;
-
-          default:
-            *ap++ = *p;
-            break;
-          }
-    }
- end_of_line:
-
-  if (instring)
-    /* Let the shell deal with an unterminated quote.  */
-    goto slow;
-
-  /* Terminate the last argument and the argument list.  */
-
-  *ap = '\0';
-  if (new_argv[i][0] != '\0' || last_argument_was_empty)
-    ++i;
-  new_argv[i] = 0;
-
-  if (i == 1)
-    {
-      int j;
-      for (j = 0; sh_cmds[j] != 0; ++j)
-        if (streq (sh_cmds[j], new_argv[0]))
-          goto slow;
-    }
-
-  if (new_argv[0] == 0)
-    {
-      /* Line was empty.  */
-      free (argstr);
-      free (new_argv);
-      return 0;
-    }
-
-  return new_argv;
-
- slow:;
-  /* We must use the shell.  */
-
-  if (new_argv != 0)
-    {
-      /* Free the old argument list we were working on.  */
-      free (argstr);
-      free (new_argv);
-    }
-
-#ifdef __MSDOS__
-  execute_by_shell = 1; /* actually, call 'system' if shell isn't unixy */
-#endif
-
-#ifdef _AMIGA
-  {
-    char *ptr;
-    char *buffer;
-    char *dptr;
-
-    buffer = xmalloc (strlen (line)+1);
-
-    ptr = line;
-    for (dptr=buffer; *ptr; )
-    {
-      if (*ptr == '\\' && ptr[1] == '\n')
-        ptr += 2;
-      else if (*ptr == '@') /* Kludge: multiline commands */
-      {
-        ptr += 2;
-        *dptr++ = '\n';
-      }
-      else
-        *dptr++ = *ptr++;
-    }
-    *dptr = 0;
-
-    new_argv = xmalloc (2 * sizeof (char *));
-    new_argv[0] = buffer;
-    new_argv[1] = 0;
-  }
-#else   /* Not Amiga  */
-#ifdef WINDOWS32
-  /*
-   * Not eating this whitespace caused things like
-   *
-   *    sh -c "\n"
-   *
-   * which gave the shell fits. I think we have to eat
-   * whitespace here, but this code should be considered
-   * suspicious if things start failing....
-   */
-
-  /* Make sure not to bother processing an empty line.  */
-  NEXT_TOKEN (line);
-  if (*line == '\0')
-    return 0;
-#endif /* WINDOWS32 */
-
-  {
-    /* SHELL may be a multi-word command.  Construct a command line
-       "$(SHELL) $(.SHELLFLAGS) LINE", with all special chars in LINE escaped.
-       Then recurse, expanding this command line to get the final
-       argument list.  */
-
-    char *new_line;
-    unsigned int shell_len = strlen (shell);
-    unsigned int line_len = strlen (line);
-    unsigned int sflags_len = shellflags ? strlen (shellflags) : 0;
-#ifdef WINDOWS32
-    char *command_ptr = NULL; /* used for batch_mode_shell mode */
-#endif
-
-# ifdef __EMX__ /* is this necessary? */
-    if (!unixy_shell && shellflags)
-      shellflags[0] = '/'; /* "/c" */
-# endif
-
-    /* In .ONESHELL mode we are allowed to throw the entire current
-        recipe string at a single shell and trust that the user
-        has configured the shell and shell flags, and formatted
-        the string, appropriately. */
-    if (one_shell)
-      {
-        /* If the shell is Bourne compatible, we must remove and ignore
-           interior special chars [@+-] because they're meaningless to
-           the shell itself. If, however, we're in .ONESHELL mode and
-           have changed SHELL to something non-standard, we should
-           leave those alone because they could be part of the
-           script. In this case we must also leave in place
-           any leading [@+-] for the same reason.  */
-
-        /* Remove and ignore interior prefix chars [@+-] because they're
-             meaningless given a single shell. */
-#if defined __MSDOS__ || defined (__EMX__)
-        if (unixy_shell)     /* the test is complicated and we already did it */
-#else
-        if (is_bourne_compatible_shell (shell)
-#ifdef WINDOWS32
-            /* If we didn't find any sh.exe, don't behave is if we did!  */
-            && !no_default_sh_exe
-#endif
-            )
-#endif
-          {
-            const char *f = line;
-            char *t = line;
-
-            /* Copy the recipe, removing and ignoring interior prefix chars
-               [@+-]: they're meaningless in .ONESHELL mode.  */
-            while (f[0] != '\0')
-              {
-                int esc = 0;
-
-                /* This is the start of a new recipe line.  Skip whitespace
-                   and prefix characters but not newlines.  */
-                while (ISBLANK (*f) || *f == '-' || *f == '@' || *f == '+')
-                  ++f;
-
-                /* Copy until we get to the next logical recipe line.  */
-                while (*f != '\0')
-                  {
-                    *(t++) = *(f++);
-                    if (f[-1] == '\\')
-                      esc = !esc;
-                    else
-                      {
-                        /* On unescaped newline, we're done with this line.  */
-                        if (f[-1] == '\n' && ! esc)
-                          break;
-
-                        /* Something else: reset the escape sequence.  */
-                        esc = 0;
-                      }
-                  }
-              }
-            *t = '\0';
-          }
-#ifdef WINDOWS32
-        else    /* non-Posix shell (cmd.exe etc.) */
-          {
-            const char *f = line;
-            char *t = line;
-            char *tstart = t;
-            int temp_fd;
-            FILE* batch = NULL;
-            int id = GetCurrentProcessId ();
-            PATH_VAR(fbuf);
-
-            /* Generate a file name for the temporary batch file.  */
-            sprintf (fbuf, "make%d", id);
-            *batch_filename = create_batch_file (fbuf, 0, &temp_fd);
-            DB (DB_JOBS, (_("Creating temporary batch file %s\n"),
-                          *batch_filename));
-
-            /* Create a FILE object for the batch file, and write to it the
-               commands to be executed.  Put the batch file in TEXT mode.  */
-            _setmode (temp_fd, _O_TEXT);
-            batch = _fdopen (temp_fd, "wt");
-            fputs ("@echo off\n", batch);
-            DB (DB_JOBS, (_("Batch file contents:\n\t@echo off\n")));
-
-            /* Copy the recipe, removing and ignoring interior prefix chars
-               [@+-]: they're meaningless in .ONESHELL mode.  */
-            while (*f != '\0')
-              {
-                /* This is the start of a new recipe line.  Skip whitespace
-                   and prefix characters but not newlines.  */
-                while (ISBLANK (*f) || *f == '-' || *f == '@' || *f == '+')
-                  ++f;
-
-                /* Copy until we get to the next logical recipe line.  */
-                while (*f != '\0')
-                  {
-                    /* Remove the escaped newlines in the command, and the
-                       blanks that follow them.  Windows shells cannot handle
-                       escaped newlines.  */
-                    if (*f == '\\' && f[1] == '\n')
-                      {
-                        f += 2;
-                        while (ISBLANK (*f))
-                          ++f;
-                      }
-                    *(t++) = *(f++);
-                    /* On an unescaped newline, we're done with this
-                       line.  */
-                    if (f[-1] == '\n')
-                      break;
-                  }
-                /* Write another line into the batch file.  */
-                if (t > tstart)
-                  {
-                    char c = *t;
-                    *t = '\0';
-                    fputs (tstart, batch);
-                    DB (DB_JOBS, ("\t%s", tstart));
-                    tstart = t;
-                    *t = c;
-                  }
-              }
-            DB (DB_JOBS, ("\n"));
-            fclose (batch);
-
-            /* Create an argv list for the shell command line that
-               will run the batch file.  */
-            new_argv = xmalloc (2 * sizeof (char *));
-            new_argv[0] = xstrdup (*batch_filename);
-            new_argv[1] = NULL;
-            return new_argv;
-          }
-#endif /* WINDOWS32 */
-        /* Create an argv list for the shell command line.  */
-        {
-          int n = 0;
-
-          new_argv = xmalloc ((4 + sflags_len/2) * sizeof (char *));
-          new_argv[n++] = xstrdup (shell);
-
-          /* Chop up the shellflags (if any) and assign them.  */
-          if (! shellflags)
-            new_argv[n++] = xstrdup ("");
-          else
-            {
-              const char *s = shellflags;
-              char *t;
-              unsigned int len;
-              while ((t = find_next_token (&s, &len)) != 0)
-                new_argv[n++] = xstrndup (t, len);
-            }
-
-          /* Set the command to invoke.  */
-          new_argv[n++] = line;
-          new_argv[n++] = NULL;
-        }
-        return new_argv;
-      }
-
-    new_line = xmalloc ((shell_len*2) + 1 + sflags_len + 1
-                        + (line_len*2) + 1);
-    ap = new_line;
-    /* Copy SHELL, escaping any characters special to the shell.  If
-       we don't escape them, construct_command_argv_internal will
-       recursively call itself ad nauseam, or until stack overflow,
-       whichever happens first.  */
-    for (cp = shell; *cp != '\0'; ++cp)
-      {
-        if (strchr (sh_chars, *cp) != 0)
-          *(ap++) = '\\';
-        *(ap++) = *cp;
-      }
-    *(ap++) = ' ';
-    if (shellflags)
-      memcpy (ap, shellflags, sflags_len);
-    ap += sflags_len;
-    *(ap++) = ' ';
-#ifdef WINDOWS32
-    command_ptr = ap;
-#endif
-    for (p = line; *p != '\0'; ++p)
-      {
-        if (restp != NULL && *p == '\n')
-          {
-            *restp = p;
-            break;
-          }
-        else if (*p == '\\' && p[1] == '\n')
-          {
-            /* POSIX says we keep the backslash-newline.  If we don't have a
-               POSIX shell on DOS/Windows/OS2, mimic the pre-POSIX behavior
-               and remove the backslash/newline.  */
-#if defined (__MSDOS__) || defined (__EMX__) || defined (WINDOWS32)
-# define PRESERVE_BSNL  unixy_shell
-#else
-# define PRESERVE_BSNL  1
-#endif
-            if (PRESERVE_BSNL)
-              {
-                *(ap++) = '\\';
-                /* Only non-batch execution needs another backslash,
-                   because it will be passed through a recursive
-                   invocation of this function.  */
-                if (!batch_mode_shell)
-                  *(ap++) = '\\';
-                *(ap++) = '\n';
-              }
-            ++p;
-            continue;
-          }
-
-        /* DOS shells don't know about backslash-escaping.  */
-        if (unixy_shell && !batch_mode_shell &&
-            (*p == '\\' || *p == '\'' || *p == '"'
-             || ISSPACE (*p)
-             || strchr (sh_chars, *p) != 0))
-          *ap++ = '\\';
-#ifdef __MSDOS__
-        else if (unixy_shell && strneq (p, "...", 3))
-          {
-            /* The case of '...' wildcard again.  */
-            strcpy (ap, "\\.\\.\\");
-            ap += 5;
-            p  += 2;
-          }
-#endif
-        *ap++ = *p;
-      }
-    if (ap == new_line + shell_len + sflags_len + 2)
-      {
-        /* Line was empty.  */
-        free (new_line);
-        return 0;
-      }
-    *ap = '\0';
-
-#ifdef WINDOWS32
-    /* Some shells do not work well when invoked as 'sh -c xxx' to run a
-       command line (e.g. Cygnus GNUWIN32 sh.exe on WIN32 systems).  In these
-       cases, run commands via a script file.  */
-    if (just_print_flag && !(flags & COMMANDS_RECURSE))
-      {
-        /* Need to allocate new_argv, although it's unused, because
-           start_job_command will want to free it and its 0'th element.  */
-        new_argv = xmalloc (2 * sizeof (char *));
-        new_argv[0] = xstrdup ("");
-        new_argv[1] = NULL;
-      }
-    else if ((no_default_sh_exe || batch_mode_shell) && batch_filename)
-      {
-        int temp_fd;
-        FILE* batch = NULL;
-        int id = GetCurrentProcessId ();
-        PATH_VAR (fbuf);
-
-        /* create a file name */
-        sprintf (fbuf, "make%d", id);
-        *batch_filename = create_batch_file (fbuf, unixy_shell, &temp_fd);
-
-        DB (DB_JOBS, (_("Creating temporary batch file %s\n"),
-                      *batch_filename));
-
-        /* Create a FILE object for the batch file, and write to it the
-           commands to be executed.  Put the batch file in TEXT mode.  */
-        _setmode (temp_fd, _O_TEXT);
-        batch = _fdopen (temp_fd, "wt");
-        if (!unixy_shell)
-          fputs ("@echo off\n", batch);
-        fputs (command_ptr, batch);
-        fputc ('\n', batch);
-        fclose (batch);
-        DB (DB_JOBS, (_("Batch file contents:%s\n\t%s\n"),
-                      !unixy_shell ? "\n\t@echo off" : "", command_ptr));
-
-        /* create argv */
-        new_argv = xmalloc (3 * sizeof (char *));
-        if (unixy_shell)
-          {
-            new_argv[0] = xstrdup (shell);
-            new_argv[1] = *batch_filename; /* only argv[0] gets freed later */
-          }
-        else
-          {
-            new_argv[0] = xstrdup (*batch_filename);
-            new_argv[1] = NULL;
-          }
-        new_argv[2] = NULL;
-      }
-    else
-#endif /* WINDOWS32 */
-
-    if (unixy_shell)
-      new_argv = construct_command_argv_internal (new_line, 0, 0, 0, 0,
-                                                  flags, 0);
-
-#ifdef __EMX__
-    else if (!unixy_shell)
-      {
-        /* new_line is local, must not be freed therefore
-           We use line here instead of new_line because we run the shell
-           manually.  */
-        size_t line_len = strlen (line);
-        char *p = new_line;
-        char *q = new_line;
-        memcpy (new_line, line, line_len + 1);
-        /* Replace all backslash-newline combination and also following tabs.
-           Important: stop at the first '\n' because that's what the loop above
-           did. The next line starting at restp[0] will be executed during the
-           next call of this function. */
-        while (*q != '\0' && *q != '\n')
-          {
-            if (q[0] == '\\' && q[1] == '\n')
-              q += 2; /* remove '\\' and '\n' */
-            else
-              *p++ = *q++;
-          }
-        *p = '\0';
-
-# ifndef NO_CMD_DEFAULT
-        if (strnicmp (new_line, "echo", 4) == 0
-            && (new_line[4] == ' ' || new_line[4] == '\t'))
-          {
-            /* the builtin echo command: handle it separately */
-            size_t echo_len = line_len - 5;
-            char *echo_line = new_line + 5;
-
-            /* special case: echo 'x="y"'
-               cmd works this way: a string is printed as is, i.e., no quotes
-               are removed. But autoconf uses a command like echo 'x="y"' to
-               determine whether make works. autoconf expects the output x="y"
-               so we will do exactly that.
-               Note: if we do not allow cmd to be the default shell
-               we do not need this kind of voodoo */
-            if (echo_line[0] == '\''
-                && echo_line[echo_len - 1] == '\''
-                && strncmp (echo_line + 1, "ac_maketemp=",
-                            strlen ("ac_maketemp=")) == 0)
-              {
-                /* remove the enclosing quotes */
-                memmove (echo_line, echo_line + 1, echo_len - 2);
-                echo_line[echo_len - 2] = '\0';
-              }
-          }
-# endif
-
-        {
-          /* Let the shell decide what to do. Put the command line into the
-             2nd command line argument and hope for the best ;-)  */
-          size_t sh_len = strlen (shell);
-
-          /* exactly 3 arguments + NULL */
-          new_argv = xmalloc (4 * sizeof (char *));
-          /* Exactly strlen(shell) + strlen("/c") + strlen(line) + 3 times
-             the trailing '\0' */
-          new_argv[0] = xmalloc (sh_len + line_len + 5);
-          memcpy (new_argv[0], shell, sh_len + 1);
-          new_argv[1] = new_argv[0] + sh_len + 1;
-          memcpy (new_argv[1], "/c", 3);
-          new_argv[2] = new_argv[1] + 3;
-          memcpy (new_argv[2], new_line, line_len + 1);
-          new_argv[3] = NULL;
-        }
-      }
-#elif defined(__MSDOS__)
-    else
-      {
-        /* With MSDOS shells, we must construct the command line here
-           instead of recursively calling ourselves, because we
-           cannot backslash-escape the special characters (see above).  */
-        new_argv = xmalloc (sizeof (char *));
-        line_len = strlen (new_line) - shell_len - sflags_len - 2;
-        new_argv[0] = xmalloc (line_len + 1);
-        strncpy (new_argv[0],
-                 new_line + shell_len + sflags_len + 2, line_len);
-        new_argv[0][line_len] = '\0';
-      }
-#else
-    else
-      fatal (NILF, CSTRLEN (__FILE__) + INTSTR_LENGTH,
-             _("%s (line %d) Bad shell context (!unixy && !batch_mode_shell)\n"),
-            __FILE__, __LINE__);
-#endif
-
-    free (new_line);
-  }
-#endif  /* ! AMIGA */
-
-  return new_argv;
-}
-#endif /* !VMS */
-
-/* Figure out the argument list necessary to run LINE as a command.  Try to
-   avoid using a shell.  This routine handles only ' quoting, and " quoting
-   when no backslash, $ or ' characters are seen in the quotes.  Starting
-   quotes may be escaped with a backslash.  If any of the characters in
-   sh_chars is seen, or any of the builtin commands listed in sh_cmds
-   is the first word of a line, the shell is used.
-
-   If RESTP is not NULL, *RESTP is set to point to the first newline in LINE.
-   If *RESTP is NULL, newlines will be ignored.
-
-   FILE is the target whose commands these are.  It is used for
-   variable expansion for $(SHELL) and $(IFS).  */
-
-char **
-construct_command_argv (char *line, char **restp, struct file *file,
-                        int cmd_flags, char **batch_filename)
-{
-  char *shell, *ifs, *shellflags;
-  char **argv;
-
-#ifdef VMS
-  char *cptr;
-  int argc;
-
-  argc = 0;
-  cptr = line;
-  for (;;)
-    {
-      while ((*cptr != 0) && (ISSPACE (*cptr)))
-        cptr++;
-      if (*cptr == 0)
-        break;
-      while ((*cptr != 0) && (!ISSPACE (*cptr)))
-        cptr++;
-      argc++;
-    }
-
-  argv = xmalloc (argc * sizeof (char *));
-  if (argv == 0)
-    abort ();
-
-  cptr = line;
-  argc = 0;
-  for (;;)
-    {
-      while ((*cptr != 0) && (ISSPACE (*cptr)))
-        cptr++;
-      if (*cptr == 0)
-        break;
-      DB (DB_JOBS, ("argv[%d] = [%s]\n", argc, cptr));
-      argv[argc++] = cptr;
-      while ((*cptr != 0) && (!ISSPACE (*cptr)))
-        cptr++;
-      if (*cptr != 0)
-        *cptr++ = 0;
-    }
-#else
-  {
-    /* Turn off --warn-undefined-variables while we expand SHELL and IFS.  */
-    int save = warn_undefined_variables_flag;
-    warn_undefined_variables_flag = 0;
-
-    shell = allocated_variable_expand_for_file ("$(SHELL)", file);
-#ifdef WINDOWS32
-    /*
-     * Convert to forward slashes so that construct_command_argv_internal()
-     * is not confused.
-     */
-    if (shell)
-      {
-        char *p = w32ify (shell, 0);
-        strcpy (shell, p);
-      }
-#endif
-#ifdef __EMX__
-    {
-      static const char *unixroot = NULL;
-      static const char *last_shell = "";
-      static int init = 0;
-      if (init == 0)
-        {
-          unixroot = getenv ("UNIXROOT");
-          /* unixroot must be NULL or not empty */
-          if (unixroot && unixroot[0] == '\0') unixroot = NULL;
-          init = 1;
-        }
-
-      /* if we have an unixroot drive and if shell is not default_shell
-         (which means it's either cmd.exe or the test has already been
-         performed) and if shell is an absolute path without drive letter,
-         try whether it exists e.g.: if "/bin/sh" does not exist use
-         "$UNIXROOT/bin/sh" instead.  */
-      if (unixroot && shell && strcmp (shell, last_shell) != 0
-          && (shell[0] == '/' || shell[0] == '\\'))
-        {
-          /* trying a new shell, check whether it exists */
-          size_t size = strlen (shell);
-          char *buf = xmalloc (size + 7);
-          memcpy (buf, shell, size);
-          memcpy (buf + size, ".exe", 5); /* including the trailing '\0' */
-          if (access (shell, F_OK) != 0 && access (buf, F_OK) != 0)
-            {
-              /* try the same for the unixroot drive */
-              memmove (buf + 2, buf, size + 5);
-              buf[0] = unixroot[0];
-              buf[1] = unixroot[1];
-              if (access (buf, F_OK) == 0)
-                /* we have found a shell! */
-                /* free(shell); */
-                shell = buf;
-              else
-                free (buf);
-            }
-          else
-            free (buf);
-        }
-    }
-#endif /* __EMX__ */
-
-    shellflags = allocated_variable_expand_for_file ("$(.SHELLFLAGS)", file);
-    ifs = allocated_variable_expand_for_file ("$(IFS)", file);
-
-    warn_undefined_variables_flag = save;
-  }
-
-  argv = construct_command_argv_internal (line, restp, shell, shellflags, ifs,
-                                          cmd_flags, batch_filename);
-
-  free (shell);
-  free (shellflags);
-  free (ifs);
-#endif /* !VMS */
-  return argv;
-}
-
-#if !defined(HAVE_DUP2) && !defined(_AMIGA)
-int
-dup2 (int old, int new)
-{
-  int fd;
-
-  (void) close (new);
-  EINTRLOOP (fd, dup (old));
-  if (fd != new)
-    {
-      (void) close (fd);
-      errno = EMFILE;
-      return -1;
-    }
-
-  return fd;
-}
-#endif /* !HAVE_DUP2 && !_AMIGA */
-
-/* On VMS systems, include special VMS functions.  */
-
-#ifdef VMS
-#include "vmsjobs.c"
-#endif
diff --git a/job.h b/job.h
deleted file mode 100644
index 0b7730b..0000000
--- a/job.h
+++ /dev/null
@@ -1,79 +0,0 @@
-/* Definitions for managing subprocesses in GNU Make.
-Copyright (C) 1992-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "output.h"
-
-/* Structure describing a running or dead child process.  */
-
-struct child
-  {
-    struct child *next;         /* Link in the chain.  */
-
-    struct file *file;          /* File being remade.  */
-
-    char **environment;         /* Environment for commands.  */
-    char *sh_batch_file;        /* Script file for shell commands */
-    char **command_lines;       /* Array of variable-expanded cmd lines.  */
-    char *command_ptr;          /* Ptr into command_lines[command_line].  */
-
-#ifdef VMS
-    char *comname;              /* Temporary command file name */
-    int efn;                    /* Completion event flag number */
-    int cstatus;                /* Completion status */
-    int vms_launch_status;      /* non-zero if lib$spawn, etc failed */
-#endif
-
-    unsigned int  command_line; /* Index into command_lines.  */
-    struct output output;       /* Output for this child.  */
-    pid_t         pid;          /* Child process's ID number.  */
-    unsigned int  remote:1;     /* Nonzero if executing remotely.  */
-    unsigned int  noerror:1;    /* Nonzero if commands contained a '-'.  */
-    unsigned int  good_stdin:1; /* Nonzero if this child has a good stdin.  */
-    unsigned int  deleted:1;    /* Nonzero if targets have been deleted.  */
-    unsigned int  recursive:1;  /* Nonzero for recursive command ('+' etc.)  */
-    unsigned int  dontcare:1;   /* Saved dontcare flag.  */
-  };
-
-extern struct child *children;
-
-/* A signal handler for SIGCHLD, if needed.  */
-RETSIGTYPE child_handler (int sig);
-int is_bourne_compatible_shell(const char *path);
-void new_job (struct file *file);
-void reap_children (int block, int err);
-void start_waiting_jobs (void);
-
-char **construct_command_argv (char *line, char **restp, struct file *file,
-                               int cmd_flags, char** batch_file);
-
-#ifdef VMS
-int child_execute_job (struct child *child, char *argv);
-#else
-int child_execute_job (struct output *out, int good_stdin, char **argv, char **envp);
-#endif
-
-#ifdef _AMIGA
-void exec_command (char **argv) __attribute__ ((noreturn));
-#elif defined(__EMX__)
-int exec_command (char **argv, char **envp);
-#else
-void exec_command (char **argv, char **envp) __attribute__ ((noreturn));
-#endif
-
-void unblock_all_sigs (void);
-
-extern unsigned int job_slots_used;
-extern unsigned int jobserver_tokens;
diff --git a/load.c b/load.c
deleted file mode 100644
index 814764d..0000000
--- a/load.c
+++ /dev/null
@@ -1,267 +0,0 @@
-/* Loading dynamic objects for GNU Make.
-Copyright (C) 2012-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-
-#if MAKE_LOAD
-
-#include <string.h>
-#include <ctype.h>
-#include <stdlib.h>
-#include <dlfcn.h>
-#include <errno.h>
-
-#define SYMBOL_EXTENSION        "_gmk_setup"
-
-#include "debug.h"
-#include "filedef.h"
-#include "variable.h"
-
-/* Tru64 V4.0 does not have this flag */
-#ifndef RTLD_GLOBAL
-# define RTLD_GLOBAL 0
-#endif
-
-struct load_list
-  {
-    struct load_list *next;
-    const char *name;
-    void *dlp;
-  };
-
-static struct load_list *loaded_syms = NULL;
-
-static load_func_t
-load_object (const floc *flocp, int noerror, const char *ldname,
-             const char *symname)
-{
-  static void *global_dl = NULL;
-  load_func_t symp;
-
-  if (! global_dl)
-    {
-      global_dl = dlopen (NULL, RTLD_NOW|RTLD_GLOBAL);
-      if (! global_dl)
-        {
-          const char *err = dlerror ();
-          OS (fatal, flocp, _("Failed to open global symbol table: %s"), err);
-        }
-    }
-
-  symp = (load_func_t) dlsym (global_dl, symname);
-  if (! symp)
-    {
-      struct load_list *new;
-      void *dlp = NULL;
-
-    /* If the path has no "/", try the current directory first.  */
-      if (! strchr (ldname, '/')
-#ifdef HAVE_DOS_PATHS
-          && ! strchr (ldname, '\\')
-#endif
-         )
-        dlp = dlopen (concat (2, "./", ldname), RTLD_LAZY|RTLD_GLOBAL);
-
-      /* If we haven't opened it yet, try the default search path.  */
-      if (! dlp)
-        dlp = dlopen (ldname, RTLD_LAZY|RTLD_GLOBAL);
-
-      /* Still no?  Then fail.  */
-      if (! dlp)
-        {
-          const char *err = dlerror ();
-          if (noerror)
-            DB (DB_BASIC, ("%s", err));
-          else
-            OS (error, flocp, "%s", err);
-          return NULL;
-        }
-
-      /* Assert that the GPL license symbol is defined.  */
-      symp = (load_func_t) dlsym (dlp, "plugin_is_GPL_compatible");
-      if (! symp)
-        OS (fatal, flocp,
-             _("Loaded object %s is not declared to be GPL compatible"),
-             ldname);
-
-      symp = (load_func_t) dlsym (dlp, symname);
-      if (! symp)
-        {
-          const char *err = dlerror ();
-          OSSS (fatal, flocp, _("Failed to load symbol %s from %s: %s"),
-                symname, ldname, err);
-        }
-
-      /* Add this symbol to a trivial lookup table.  This is not efficient but
-         it's highly unlikely we'll be loading lots of objects, and we only
-         need it to look them up on unload, if we rebuild them.  */
-      new = xmalloc (sizeof (struct load_list));
-      new->name = xstrdup (ldname);
-      new->dlp = dlp;
-      new->next = loaded_syms;
-      loaded_syms = new;
-    }
-
-  return symp;
-}
-
-int
-load_file (const floc *flocp, const char **ldname, int noerror)
-{
-  int nmlen = strlen (*ldname);
-  char *new = alloca (nmlen + CSTRLEN (SYMBOL_EXTENSION) + 1);
-  char *symname = NULL;
-  char *loaded;
-  const char *fp;
-  int r;
-  load_func_t symp;
-
-  /* Break the input into an object file name and a symbol name.  If no symbol
-     name was provided, compute one from the object file name.  */
-  fp = strchr (*ldname, '(');
-  if (fp)
-    {
-      const char *ep;
-
-      /* There's an open paren, so see if there's a close paren: if so use
-         that as the symbol name.  We can't have whitespace: it would have
-         been chopped up before this function is called.  */
-      ep = strchr (fp+1, ')');
-      if (ep && ep[1] == '\0')
-        {
-          int l = fp - *ldname;;
-
-          ++fp;
-          if (fp == ep)
-            OS (fatal, flocp, _("Empty symbol name for load: %s"), *ldname);
-
-          /* Make a copy of the ldname part.  */
-          memcpy (new, *ldname, l);
-          new[l] = '\0';
-          *ldname = new;
-          nmlen = l;
-
-          /* Make a copy of the symbol name part.  */
-          symname = new + l + 1;
-          memcpy (symname, fp, ep - fp);
-          symname[ep - fp] = '\0';
-        }
-    }
-
-  /* Add this name to the string cache so it can be reused later.  */
-  *ldname = strcache_add (*ldname);
-
-  /* If this object has been loaded, we're done.  */
-  loaded = allocated_variable_expand ("$(.LOADED)");
-  fp = strstr (loaded, *ldname);
-  r = fp && (fp==loaded || fp[-1]==' ') && (fp[nmlen]=='\0' || fp[nmlen]==' ');
-  if (r)
-    goto exit;
-
-  /* If we didn't find a symbol name yet, construct it from the ldname.  */
-  if (! symname)
-    {
-      char *p = new;
-
-      fp = strrchr (*ldname, '/');
-#ifdef HAVE_DOS_PATHS
-      if (fp)
-        {
-          const char *fp2 = strchr (fp, '\\');
-
-          if (fp2 > fp)
-            fp = fp2;
-        }
-      else
-        fp = strrchr (*ldname, '\\');
-      /* The (improbable) case of d:foo.  */
-      if (fp && *fp && fp[1] == ':')
-        fp++;
-#endif
-      if (!fp)
-        fp = *ldname;
-      else
-        ++fp;
-      while (isalnum (*fp) || *fp == '_')
-        *(p++) = *(fp++);
-      strcpy (p, SYMBOL_EXTENSION);
-      symname = new;
-    }
-
-  DB (DB_VERBOSE, (_("Loading symbol %s from %s\n"), symname, *ldname));
-
-  /* Load it!  */
-  symp = load_object (flocp, noerror, *ldname, symname);
-  if (! symp)
-    return 0;
-
-  /* Invoke the symbol.  */
-  r = (*symp) (flocp);
-
-  /* If it succeeded, add the load file to the loaded variable.  */
-  if (r > 0)
-    {
-      size_t loadlen = strlen (loaded);
-      char *newval = alloca (loadlen + strlen (*ldname) + 2);
-      /* Don't add a space if it's empty.  */
-      if (loadlen)
-        {
-          memcpy (newval, loaded, loadlen);
-          newval[loadlen++] = ' ';
-        }
-      strcpy (&newval[loadlen], *ldname);
-      do_variable_definition (flocp, ".LOADED", newval, o_default, f_simple, 0);
-    }
-
- exit:
-  free (loaded);
-  return r;
-}
-
-void
-unload_file (const char *name)
-{
-  struct load_list *d;
-
-  for (d = loaded_syms; d != NULL; d = d->next)
-    if (streq (d->name, name) && d->dlp)
-      {
-        if (dlclose (d->dlp))
-          perror_with_name ("dlclose", d->name);
-        d->dlp = NULL;
-        break;
-      }
-}
-
-#else
-
-int
-load_file (const floc *flocp, const char **ldname UNUSED, int noerror)
-{
-  if (! noerror)
-    O (fatal, flocp,
-       _("The 'load' operation is not supported on this platform."));
-
-  return 0;
-}
-
-void
-unload_file (const char *name UNUSED)
-{
-  O (fatal, NILF, "INTERNAL: Cannot unload when load is not supported!");
-}
-
-#endif  /* MAKE_LOAD */
diff --git a/loadapi.c b/loadapi.c
deleted file mode 100644
index db61e77..0000000
--- a/loadapi.c
+++ /dev/null
@@ -1,82 +0,0 @@
-/* API for GNU Make dynamic objects.
-Copyright (C) 2013-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-
-#include "filedef.h"
-#include "variable.h"
-#include "dep.h"
-
-/* Allocate a buffer in our context, so we can free it.  */
-char *
-gmk_alloc (unsigned int len)
-{
-  return xmalloc (len);
-}
-
-/* Free a buffer returned by gmk_expand().  */
-void
-gmk_free (char *s)
-{
-  free (s);
-}
-
-/* Evaluate a buffer as make syntax.
-   Ideally eval_buffer() will take const char *, but not yet.  */
-void
-gmk_eval (const char *buffer, const gmk_floc *gfloc)
-{
-  /* Preserve existing variable buffer context.  */
-  char *pbuf;
-  unsigned int plen;
-  char *s;
-  floc fl;
-  floc *flp;
-
-  if (gfloc)
-    {
-      fl.filenm = gfloc->filenm;
-      fl.lineno = gfloc->lineno;
-      fl.offset = 0;
-      flp = &fl;
-    }
-  else
-    flp = NULL;
-
-  install_variable_buffer (&pbuf, &plen);
-
-  s = xstrdup (buffer);
-  eval_buffer (s, flp);
-  free (s);
-
-  restore_variable_buffer (pbuf, plen);
-}
-
-/* Expand a string and return an allocated buffer.
-   Caller must call gmk_free() with this buffer.  */
-char *
-gmk_expand (const char *ref)
-{
-  return allocated_variable_expand (ref);
-}
-
-/* Register a function to be called from makefiles.  */
-void
-gmk_add_function (const char *name, gmk_func_ptr func,
-                  unsigned int min, unsigned int max, unsigned int flags)
-{
-  define_new_function (reading_file, name, min, max, flags, func);
-}
diff --git a/main.c b/main.c
deleted file mode 100644
index 9fa2c84..0000000
--- a/main.c
+++ /dev/null
@@ -1,3503 +0,0 @@
-/* Argument parsing and main program of GNU Make.
-Copyright (C) 1988-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-#include "os.h"
-#include "filedef.h"
-#include "dep.h"
-#include "variable.h"
-#include "job.h"
-#include "commands.h"
-#include "rule.h"
-#include "debug.h"
-#include "getopt.h"
-
-#include <assert.h>
-#ifdef _AMIGA
-# include <dos/dos.h>
-# include <proto/dos.h>
-#endif
-#ifdef WINDOWS32
-# include <windows.h>
-# include <io.h>
-#ifdef HAVE_STRINGS_H
-# include <strings.h>	/* for strcasecmp */
-#endif
-# include "pathstuff.h"
-# include "sub_proc.h"
-# include "w32err.h"
-#endif
-#ifdef __EMX__
-# include <sys/types.h>
-# include <sys/wait.h>
-#endif
-#ifdef HAVE_FCNTL_H
-# include <fcntl.h>
-#endif
-
-#ifdef _AMIGA
-int __stack = 20000; /* Make sure we have 20K of stack space */
-#endif
-#ifdef VMS
-int vms_use_mcr_command = 0;
-int vms_always_use_cmd_file = 0;
-int vms_gnv_shell = 0;
-int vms_legacy_behavior = 0;
-int vms_comma_separator = 0;
-int vms_unix_simulation = 0;
-int vms_report_unix_paths = 0;
-
-/* Evaluates if a VMS environment option is set, only look at first character */
-static int
-get_vms_env_flag (const char *name, int default_value)
-{
-char * value;
-char x;
-
-  value = getenv (name);
-  if (value == NULL)
-    return default_value;
-
-  x = toupper (value[0]);
-  switch (x)
-    {
-    case '1':
-    case 'T':
-    case 'E':
-      return 1;
-      break;
-    case '0':
-    case 'F':
-    case 'D':
-      return 0;
-    }
-}
-#endif
-
-#if defined HAVE_WAITPID || defined HAVE_WAIT3
-# define HAVE_WAIT_NOHANG
-#endif
-
-#ifndef HAVE_UNISTD_H
-int chdir ();
-#endif
-#ifndef STDC_HEADERS
-# ifndef sun                    /* Sun has an incorrect decl in a header.  */
-void exit (int) __attribute__ ((noreturn));
-# endif
-double atof ();
-#endif
-
-static void clean_jobserver (int status);
-static void print_data_base (void);
-static void print_version (void);
-static void decode_switches (int argc, const char **argv, int env);
-static void decode_env_switches (const char *envar, unsigned int len);
-static struct variable *define_makeflags (int all, int makefile);
-static char *quote_for_env (char *out, const char *in);
-static void initialize_global_hash_tables (void);
-
-
-/* The structure that describes an accepted command switch.  */
-
-struct command_switch
-  {
-    int c;                      /* The switch character.  */
-
-    enum                        /* Type of the value.  */
-      {
-        flag,                   /* Turn int flag on.  */
-        flag_off,               /* Turn int flag off.  */
-        string,                 /* One string per invocation.  */
-        strlist,                /* One string per switch.  */
-        filename,               /* A string containing a file name.  */
-        positive_int,           /* A positive integer.  */
-        floating,               /* A floating-point number (double).  */
-        ignore                  /* Ignored.  */
-      } type;
-
-    void *value_ptr;    /* Pointer to the value-holding variable.  */
-
-    unsigned int env:1;         /* Can come from MAKEFLAGS.  */
-    unsigned int toenv:1;       /* Should be put in MAKEFLAGS.  */
-    unsigned int no_makefile:1; /* Don't propagate when remaking makefiles.  */
-
-    const void *noarg_value;    /* Pointer to value used if no arg given.  */
-    const void *default_value;  /* Pointer to default value.  */
-
-    const char *long_name;      /* Long option name.  */
-  };
-
-/* True if C is a switch value that corresponds to a short option.  */
-
-#define short_option(c) ((c) <= CHAR_MAX)
-
-/* The structure used to hold the list of strings given
-   in command switches of a type that takes strlist arguments.  */
-
-struct stringlist
-  {
-    const char **list;  /* Nil-terminated list of strings.  */
-    unsigned int idx;   /* Index into above.  */
-    unsigned int max;   /* Number of pointers allocated.  */
-  };
-
-
-/* The recognized command switches.  */
-
-/* Nonzero means do extra verification (that may slow things down).  */
-
-int verify_flag;
-
-/* Nonzero means do not print commands to be executed (-s).  */
-
-int silent_flag;
-static const int default_silent_flag = 0;
-
-/* Nonzero means just touch the files
-   that would appear to need remaking (-t)  */
-
-int touch_flag;
-
-/* Nonzero means just print what commands would need to be executed,
-   don't actually execute them (-n).  */
-
-int just_print_flag;
-
-/* Print debugging info (--debug).  */
-
-static struct stringlist *db_flags = 0;
-static int debug_flag = 0;
-
-int db_level = 0;
-
-/* Synchronize output (--output-sync).  */
-
-char *output_sync_option = 0;
-
-#ifdef WINDOWS32
-/* Suspend make in main for a short time to allow debugger to attach */
-
-int suspend_flag = 0;
-#endif
-
-/* Environment variables override makefile definitions.  */
-
-int env_overrides = 0;
-
-/* Nonzero means ignore status codes returned by commands
-   executed to remake files.  Just treat them all as successful (-i).  */
-
-int ignore_errors_flag = 0;
-
-/* Nonzero means don't remake anything, just print the data base
-   that results from reading the makefile (-p).  */
-
-int print_data_base_flag = 0;
-
-/* Nonzero means don't remake anything; just return a nonzero status
-   if the specified targets are not up to date (-q).  */
-
-int question_flag = 0;
-
-/* Nonzero means do not use any of the builtin rules (-r) / variables (-R).  */
-
-int no_builtin_rules_flag = 0;
-int no_builtin_variables_flag = 0;
-
-/* Nonzero means keep going even if remaking some file fails (-k).  */
-
-int keep_going_flag;
-static const int default_keep_going_flag = 0;
-
-/* Nonzero means check symlink mtimes.  */
-
-int check_symlink_flag = 0;
-
-/* Nonzero means print directory before starting and when done (-w).  */
-
-int print_directory_flag = 0;
-
-/* Nonzero means ignore print_directory_flag and never print the directory.
-   This is necessary because print_directory_flag is set implicitly.  */
-
-int inhibit_print_directory_flag = 0;
-
-/* Nonzero means print version information.  */
-
-int print_version_flag = 0;
-
-/* List of makefiles given with -f switches.  */
-
-static struct stringlist *makefiles = 0;
-
-/* Size of the stack when we started.  */
-
-#ifdef SET_STACK_SIZE
-struct rlimit stack_limit;
-#endif
-
-
-/* Number of job slots for parallelism.  */
-
-unsigned int job_slots;
-
-#define INVALID_JOB_SLOTS (-1)
-static unsigned int master_job_slots = 0;
-static int arg_job_slots = INVALID_JOB_SLOTS;
-
-static const int default_job_slots = INVALID_JOB_SLOTS;
-
-/* Value of job_slots that means no limit.  */
-
-static const int inf_jobs = 0;
-
-/* Authorization for the jobserver.  */
-
-static char *jobserver_auth = NULL;
-
-/* Handle for the mutex used on Windows to synchronize output of our
-   children under -O.  */
-
-char *sync_mutex = NULL;
-
-/* Maximum load average at which multiple jobs will be run.
-   Negative values mean unlimited, while zero means limit to
-   zero load (which could be useful to start infinite jobs remotely
-   but one at a time locally).  */
-double max_load_average = -1.0;
-double default_load_average = -1.0;
-
-/* List of directories given with -C switches.  */
-
-static struct stringlist *directories = 0;
-
-/* List of include directories given with -I switches.  */
-
-static struct stringlist *include_directories = 0;
-
-/* List of files given with -o switches.  */
-
-static struct stringlist *old_files = 0;
-
-/* List of files given with -W switches.  */
-
-static struct stringlist *new_files = 0;
-
-/* List of strings to be eval'd.  */
-static struct stringlist *eval_strings = 0;
-
-/* If nonzero, we should just print usage and exit.  */
-
-static int print_usage_flag = 0;
-
-/* If nonzero, we should print a warning message
-   for each reference to an undefined variable.  */
-
-int warn_undefined_variables_flag;
-
-/* If nonzero, always build all targets, regardless of whether
-   they appear out of date or not.  */
-
-static int always_make_set = 0;
-int always_make_flag = 0;
-
-/* If nonzero, we're in the "try to rebuild makefiles" phase.  */
-
-int rebuilding_makefiles = 0;
-
-/* Remember the original value of the SHELL variable, from the environment.  */
-
-struct variable shell_var;
-
-/* This character introduces a command: it's the first char on the line.  */
-
-char cmd_prefix = '\t';
-
-
-/* The usage output.  We write it this way to make life easier for the
-   translators, especially those trying to translate to right-to-left
-   languages like Hebrew.  */
-
-static const char *const usage[] =
-  {
-    N_("Options:\n"),
-    N_("\
-  -b, -m                      Ignored for compatibility.\n"),
-    N_("\
-  -B, --always-make           Unconditionally make all targets.\n"),
-    N_("\
-  -C DIRECTORY, --directory=DIRECTORY\n\
-                              Change to DIRECTORY before doing anything.\n"),
-    N_("\
-  -d                          Print lots of debugging information.\n"),
-    N_("\
-  --debug[=FLAGS]             Print various types of debugging information.\n"),
-    N_("\
-  -e, --environment-overrides\n\
-                              Environment variables override makefiles.\n"),
-    N_("\
-  -E STRING, --eval=STRING    Evaluate STRING as a makefile statement.\n"),
-    N_("\
-  -f FILE, --file=FILE, --makefile=FILE\n\
-                              Read FILE as a makefile.\n"),
-    N_("\
-  -h, --help                  Print this message and exit.\n"),
-    N_("\
-  -i, --ignore-errors         Ignore errors from recipes.\n"),
-    N_("\
-  -I DIRECTORY, --include-dir=DIRECTORY\n\
-                              Search DIRECTORY for included makefiles.\n"),
-    N_("\
-  -j [N], --jobs[=N]          Allow N jobs at once; infinite jobs with no arg.\n"),
-    N_("\
-  -k, --keep-going            Keep going when some targets can't be made.\n"),
-    N_("\
-  -l [N], --load-average[=N], --max-load[=N]\n\
-                              Don't start multiple jobs unless load is below N.\n"),
-    N_("\
-  -L, --check-symlink-times   Use the latest mtime between symlinks and target.\n"),
-    N_("\
-  -n, --just-print, --dry-run, --recon\n\
-                              Don't actually run any recipe; just print them.\n"),
-    N_("\
-  -o FILE, --old-file=FILE, --assume-old=FILE\n\
-                              Consider FILE to be very old and don't remake it.\n"),
-    N_("\
-  -O[TYPE], --output-sync[=TYPE]\n\
-                              Synchronize output of parallel jobs by TYPE.\n"),
-    N_("\
-  -p, --print-data-base       Print make's internal database.\n"),
-    N_("\
-  -q, --question              Run no recipe; exit status says if up to date.\n"),
-    N_("\
-  -r, --no-builtin-rules      Disable the built-in implicit rules.\n"),
-    N_("\
-  -R, --no-builtin-variables  Disable the built-in variable settings.\n"),
-    N_("\
-  -s, --silent, --quiet       Don't echo recipes.\n"),
-    N_("\
-  --no-silent                 Echo recipes (disable --silent mode).\n"),
-    N_("\
-  -S, --no-keep-going, --stop\n\
-                              Turns off -k.\n"),
-    N_("\
-  -t, --touch                 Touch targets instead of remaking them.\n"),
-    N_("\
-  --trace                     Print tracing information.\n"),
-    N_("\
-  -v, --version               Print the version number of make and exit.\n"),
-    N_("\
-  -w, --print-directory       Print the current directory.\n"),
-    N_("\
-  --no-print-directory        Turn off -w, even if it was turned on implicitly.\n"),
-    N_("\
-  -W FILE, --what-if=FILE, --new-file=FILE, --assume-new=FILE\n\
-                              Consider FILE to be infinitely new.\n"),
-    N_("\
-  --warn-undefined-variables  Warn when an undefined variable is referenced.\n"),
-    NULL
-  };
-
-/* The table of command switches.
-   Order matters here: this is the order MAKEFLAGS will be constructed.
-   So be sure all simple flags (single char, no argument) come first.  */
-
-static const struct command_switch switches[] =
-  {
-    { 'b', ignore, 0, 0, 0, 0, 0, 0, 0 },
-    { 'B', flag, &always_make_set, 1, 1, 0, 0, 0, "always-make" },
-    { 'd', flag, &debug_flag, 1, 1, 0, 0, 0, 0 },
-#ifdef WINDOWS32
-    { 'D', flag, &suspend_flag, 1, 1, 0, 0, 0, "suspend-for-debug" },
-#endif
-    { 'e', flag, &env_overrides, 1, 1, 0, 0, 0, "environment-overrides", },
-    { 'E', strlist, &eval_strings, 1, 0, 0, 0, 0, "eval" },
-    { 'h', flag, &print_usage_flag, 0, 0, 0, 0, 0, "help" },
-    { 'i', flag, &ignore_errors_flag, 1, 1, 0, 0, 0, "ignore-errors" },
-    { 'k', flag, &keep_going_flag, 1, 1, 0, 0, &default_keep_going_flag,
-      "keep-going" },
-    { 'L', flag, &check_symlink_flag, 1, 1, 0, 0, 0, "check-symlink-times" },
-    { 'm', ignore, 0, 0, 0, 0, 0, 0, 0 },
-    { 'n', flag, &just_print_flag, 1, 1, 1, 0, 0, "just-print" },
-    { 'p', flag, &print_data_base_flag, 1, 1, 0, 0, 0, "print-data-base" },
-    { 'q', flag, &question_flag, 1, 1, 1, 0, 0, "question" },
-    { 'r', flag, &no_builtin_rules_flag, 1, 1, 0, 0, 0, "no-builtin-rules" },
-    { 'R', flag, &no_builtin_variables_flag, 1, 1, 0, 0, 0,
-      "no-builtin-variables" },
-    { 's', flag, &silent_flag, 1, 1, 0, 0, &default_silent_flag, "silent" },
-    { 'S', flag_off, &keep_going_flag, 1, 1, 0, 0, &default_keep_going_flag,
-      "no-keep-going" },
-    { 't', flag, &touch_flag, 1, 1, 1, 0, 0, "touch" },
-    { 'v', flag, &print_version_flag, 1, 1, 0, 0, 0, "version" },
-    { 'w', flag, &print_directory_flag, 1, 1, 0, 0, 0, "print-directory" },
-
-    /* These options take arguments.  */
-    { 'C', filename, &directories, 0, 0, 0, 0, 0, "directory" },
-    { 'f', filename, &makefiles, 0, 0, 0, 0, 0, "file" },
-    { 'I', filename, &include_directories, 1, 1, 0, 0, 0,
-      "include-dir" },
-    { 'j', positive_int, &arg_job_slots, 1, 1, 0, &inf_jobs, &default_job_slots,
-      "jobs" },
-    { 'l', floating, &max_load_average, 1, 1, 0, &default_load_average,
-      &default_load_average, "load-average" },
-    { 'o', filename, &old_files, 0, 0, 0, 0, 0, "old-file" },
-    { 'O', string, &output_sync_option, 1, 1, 0, "target", 0, "output-sync" },
-    { 'W', filename, &new_files, 0, 0, 0, 0, 0, "what-if" },
-
-    /* These are long-style options.  */
-    { CHAR_MAX+1, strlist, &db_flags, 1, 1, 0, "basic", 0, "debug" },
-    { CHAR_MAX+2, string, &jobserver_auth, 1, 1, 0, 0, 0, "jobserver-auth" },
-    { CHAR_MAX+3, flag, &trace_flag, 1, 1, 0, 0, 0, "trace" },
-    { CHAR_MAX+4, flag, &inhibit_print_directory_flag, 1, 1, 0, 0, 0,
-      "no-print-directory" },
-    { CHAR_MAX+5, flag, &warn_undefined_variables_flag, 1, 1, 0, 0, 0,
-      "warn-undefined-variables" },
-    { CHAR_MAX+7, string, &sync_mutex, 1, 1, 0, 0, 0, "sync-mutex" },
-    { CHAR_MAX+8, flag_off, &silent_flag, 1, 1, 0, 0, &default_silent_flag, "no-silent" },
-    { CHAR_MAX+9, string, &jobserver_auth, 1, 0, 0, 0, 0, "jobserver-fds" },
-    { 0, 0, 0, 0, 0, 0, 0, 0, 0 }
-  };
-
-/* Secondary long names for options.  */
-
-static struct option long_option_aliases[] =
-  {
-    { "quiet",          no_argument,            0, 's' },
-    { "stop",           no_argument,            0, 'S' },
-    { "new-file",       required_argument,      0, 'W' },
-    { "assume-new",     required_argument,      0, 'W' },
-    { "assume-old",     required_argument,      0, 'o' },
-    { "max-load",       optional_argument,      0, 'l' },
-    { "dry-run",        no_argument,            0, 'n' },
-    { "recon",          no_argument,            0, 'n' },
-    { "makefile",       required_argument,      0, 'f' },
-  };
-
-/* List of goal targets.  */
-
-static struct goaldep *goals, *lastgoal;
-
-/* List of variables which were defined on the command line
-   (or, equivalently, in MAKEFLAGS).  */
-
-struct command_variable
-  {
-    struct command_variable *next;
-    struct variable *variable;
-  };
-static struct command_variable *command_variables;
-
-/* The name we were invoked with.  */
-
-const char *program;
-
-/* Our current directory before processing any -C options.  */
-
-char *directory_before_chdir;
-
-/* Our current directory after processing all -C options.  */
-
-char *starting_directory;
-
-/* Value of the MAKELEVEL variable at startup (or 0).  */
-
-unsigned int makelevel;
-
-/* Pointer to the value of the .DEFAULT_GOAL special variable.
-   The value will be the name of the goal to remake if the command line
-   does not override it.  It can be set by the makefile, or else it's
-   the first target defined in the makefile whose name does not start
-   with '.'.  */
-
-struct variable * default_goal_var;
-
-/* Pointer to structure for the file .DEFAULT
-   whose commands are used for any file that has none of its own.
-   This is zero if the makefiles do not define .DEFAULT.  */
-
-struct file *default_file;
-
-/* Nonzero if we have seen the magic '.POSIX' target.
-   This turns on pedantic compliance with POSIX.2.  */
-
-int posix_pedantic;
-
-/* Nonzero if we have seen the '.SECONDEXPANSION' target.
-   This turns on secondary expansion of prerequisites.  */
-
-int second_expansion;
-
-/* Nonzero if we have seen the '.ONESHELL' target.
-   This causes the entire recipe to be handed to SHELL
-   as a single string, potentially containing newlines.  */
-
-int one_shell;
-
-/* One of OUTPUT_SYNC_* if the "--output-sync" option was given.  This
-   attempts to synchronize the output of parallel jobs such that the results
-   of each job stay together.  */
-
-int output_sync = OUTPUT_SYNC_NONE;
-
-/* Nonzero if the "--trace" option was given.  */
-
-int trace_flag = 0;
-
-/* Nonzero if we have seen the '.NOTPARALLEL' target.
-   This turns off parallel builds for this invocation of make.  */
-
-int not_parallel;
-
-/* Nonzero if some rule detected clock skew; we keep track so (a) we only
-   print one warning about it during the run, and (b) we can print a final
-   warning at the end of the run. */
-
-int clock_skew_detected;
-
-/* Map of possible stop characters for searching strings.  */
-#ifndef UCHAR_MAX
-# define UCHAR_MAX 255
-#endif
-unsigned short stopchar_map[UCHAR_MAX + 1] = {0};
-
-/* If output-sync is enabled we'll collect all the output generated due to
-   options, while reading makefiles, etc.  */
-
-struct output make_sync;
-
-
-/* Mask of signals that are being caught with fatal_error_signal.  */
-
-#if defined(POSIX)
-sigset_t fatal_signal_set;
-#elif defined(HAVE_SIGSETMASK)
-int fatal_signal_mask;
-#endif
-
-#if !HAVE_DECL_BSD_SIGNAL && !defined bsd_signal
-# if !defined HAVE_SIGACTION
-#  define bsd_signal signal
-# else
-typedef RETSIGTYPE (*bsd_signal_ret_t) (int);
-
-static bsd_signal_ret_t
-bsd_signal (int sig, bsd_signal_ret_t func)
-{
-  struct sigaction act, oact;
-  act.sa_handler = func;
-  act.sa_flags = SA_RESTART;
-  sigemptyset (&act.sa_mask);
-  sigaddset (&act.sa_mask, sig);
-  if (sigaction (sig, &act, &oact) != 0)
-    return SIG_ERR;
-  return oact.sa_handler;
-}
-# endif
-#endif
-
-static void
-initialize_global_hash_tables (void)
-{
-  init_hash_global_variable_set ();
-  strcache_init ();
-  init_hash_files ();
-  hash_init_directories ();
-  hash_init_function_table ();
-}
-
-/* This character map locate stop chars when parsing GNU makefiles.
-   Each element is true if we should stop parsing on that character.  */
-
-static void
-initialize_stopchar_map (void)
-{
-  int i;
-
-  stopchar_map[(int)'\0'] = MAP_NUL;
-  stopchar_map[(int)'#'] = MAP_COMMENT;
-  stopchar_map[(int)';'] = MAP_SEMI;
-  stopchar_map[(int)'='] = MAP_EQUALS;
-  stopchar_map[(int)':'] = MAP_COLON;
-  stopchar_map[(int)'|'] = MAP_PIPE;
-  stopchar_map[(int)'.'] = MAP_DOT | MAP_USERFUNC;
-  stopchar_map[(int)','] = MAP_COMMA;
-  stopchar_map[(int)'('] = MAP_VARSEP;
-  stopchar_map[(int)'{'] = MAP_VARSEP;
-  stopchar_map[(int)'}'] = MAP_VARSEP;
-  stopchar_map[(int)')'] = MAP_VARSEP;
-  stopchar_map[(int)'$'] = MAP_VARIABLE;
-
-  stopchar_map[(int)'-'] = MAP_USERFUNC;
-  stopchar_map[(int)'_'] = MAP_USERFUNC;
-
-  stopchar_map[(int)' '] = MAP_BLANK;
-  stopchar_map[(int)'\t'] = MAP_BLANK;
-
-  stopchar_map[(int)'/'] = MAP_DIRSEP;
-#if defined(VMS)
-  stopchar_map[(int)':'] |= MAP_DIRSEP;
-  stopchar_map[(int)']'] |= MAP_DIRSEP;
-  stopchar_map[(int)'>'] |= MAP_DIRSEP;
-#elif defined(HAVE_DOS_PATHS)
-  stopchar_map[(int)'\\'] |= MAP_DIRSEP;
-#endif
-
-  for (i = 1; i <= UCHAR_MAX; ++i)
-    {
-      if (isspace (i) && NONE_SET (stopchar_map[i], MAP_BLANK))
-        /* Don't mark blank characters as newline characters.  */
-        stopchar_map[i] |= MAP_NEWLINE;
-      else if (isalnum (i))
-        stopchar_map[i] |= MAP_USERFUNC;
-    }
-}
-
-static const char *
-expand_command_line_file (const char *name)
-{
-  const char *cp;
-  char *expanded = 0;
-
-  if (name[0] == '\0')
-    O (fatal, NILF, _("empty string invalid as file name"));
-
-  if (name[0] == '~')
-    {
-      expanded = tilde_expand (name);
-      if (expanded && expanded[0] != '\0')
-        name = expanded;
-    }
-
-  /* This is also done in parse_file_seq, so this is redundant
-     for names read from makefiles.  It is here for names passed
-     on the command line.  */
-  while (name[0] == '.' && name[1] == '/')
-    {
-      name += 2;
-      while (name[0] == '/')
-        /* Skip following slashes: ".//foo" is "foo", not "/foo".  */
-        ++name;
-    }
-
-  if (name[0] == '\0')
-    {
-      /* Nothing else but one or more "./", maybe plus slashes!  */
-      name = "./";
-    }
-
-  cp = strcache_add (name);
-
-  free (expanded);
-
-  return cp;
-}
-
-/* Toggle -d on receipt of SIGUSR1.  */
-
-#ifdef SIGUSR1
-static RETSIGTYPE
-debug_signal_handler (int sig UNUSED)
-{
-  db_level = db_level ? DB_NONE : DB_BASIC;
-}
-#endif
-
-static void
-decode_debug_flags (void)
-{
-  const char **pp;
-
-  if (debug_flag)
-    db_level = DB_ALL;
-
-  if (db_flags)
-    for (pp=db_flags->list; *pp; ++pp)
-      {
-        const char *p = *pp;
-
-        while (1)
-          {
-            switch (tolower (p[0]))
-              {
-              case 'a':
-                db_level |= DB_ALL;
-                break;
-              case 'b':
-                db_level |= DB_BASIC;
-                break;
-              case 'i':
-                db_level |= DB_BASIC | DB_IMPLICIT;
-                break;
-              case 'j':
-                db_level |= DB_JOBS;
-                break;
-              case 'm':
-                db_level |= DB_BASIC | DB_MAKEFILES;
-                break;
-              case 'n':
-                db_level = 0;
-                break;
-              case 'v':
-                db_level |= DB_BASIC | DB_VERBOSE;
-                break;
-              default:
-                OS (fatal, NILF,
-                    _("unknown debug level specification '%s'"), p);
-              }
-
-            while (*(++p) != '\0')
-              if (*p == ',' || *p == ' ')
-                {
-                  ++p;
-                  break;
-                }
-
-            if (*p == '\0')
-              break;
-          }
-      }
-
-  if (db_level)
-    verify_flag = 1;
-
-  if (! db_level)
-    debug_flag = 0;
-}
-
-static void
-decode_output_sync_flags (void)
-{
-#ifdef NO_OUTPUT_SYNC
-  output_sync = OUTPUT_SYNC_NONE;
-#else
-  if (output_sync_option)
-    {
-      if (streq (output_sync_option, "none"))
-        output_sync = OUTPUT_SYNC_NONE;
-      else if (streq (output_sync_option, "line"))
-        output_sync = OUTPUT_SYNC_LINE;
-      else if (streq (output_sync_option, "target"))
-        output_sync = OUTPUT_SYNC_TARGET;
-      else if (streq (output_sync_option, "recurse"))
-        output_sync = OUTPUT_SYNC_RECURSE;
-      else
-        OS (fatal, NILF,
-            _("unknown output-sync type '%s'"), output_sync_option);
-    }
-
-  if (sync_mutex)
-    RECORD_SYNC_MUTEX (sync_mutex);
-#endif
-}
-
-#ifdef WINDOWS32
-
-#ifndef NO_OUTPUT_SYNC
-
-/* This is called from start_job_command when it detects that
-   output_sync option is in effect.  The handle to the synchronization
-   mutex is passed, as a string, to sub-makes via the --sync-mutex
-   command-line argument.  */
-void
-prepare_mutex_handle_string (sync_handle_t handle)
-{
-  if (!sync_mutex)
-    {
-      /* Prepare the mutex handle string for our children.  */
-      /* 2 hex digits per byte + 2 characters for "0x" + null.  */
-      sync_mutex = xmalloc ((2 * sizeof (sync_handle_t)) + 2 + 1);
-      sprintf (sync_mutex, "0x%Ix", handle);
-      define_makeflags (1, 0);
-    }
-}
-
-#endif  /* NO_OUTPUT_SYNC */
-
-/*
- * HANDLE runtime exceptions by avoiding a requestor on the GUI. Capture
- * exception and print it to stderr instead.
- *
- * If ! DB_VERBOSE, just print a simple message and exit.
- * If DB_VERBOSE, print a more verbose message.
- * If compiled for DEBUG, let exception pass through to GUI so that
- *   debuggers can attach.
- */
-LONG WINAPI
-handle_runtime_exceptions (struct _EXCEPTION_POINTERS *exinfo)
-{
-  PEXCEPTION_RECORD exrec = exinfo->ExceptionRecord;
-  LPSTR cmdline = GetCommandLine ();
-  LPSTR prg = strtok (cmdline, " ");
-  CHAR errmsg[1024];
-#ifdef USE_EVENT_LOG
-  HANDLE hEventSource;
-  LPTSTR lpszStrings[1];
-#endif
-
-  if (! ISDB (DB_VERBOSE))
-    {
-      sprintf (errmsg,
-               _("%s: Interrupt/Exception caught (code = 0x%lx, addr = 0x%p)\n"),
-               prg, exrec->ExceptionCode, exrec->ExceptionAddress);
-      fprintf (stderr, errmsg);
-      exit (255);
-    }
-
-  sprintf (errmsg,
-           _("\nUnhandled exception filter called from program %s\nExceptionCode = %lx\nExceptionFlags = %lx\nExceptionAddress = 0x%p\n"),
-           prg, exrec->ExceptionCode, exrec->ExceptionFlags,
-           exrec->ExceptionAddress);
-
-  if (exrec->ExceptionCode == EXCEPTION_ACCESS_VIOLATION
-      && exrec->NumberParameters >= 2)
-    sprintf (&errmsg[strlen(errmsg)],
-             (exrec->ExceptionInformation[0]
-              ? _("Access violation: write operation at address 0x%p\n")
-              : _("Access violation: read operation at address 0x%p\n")),
-             (PVOID)exrec->ExceptionInformation[1]);
-
-  /* turn this on if we want to put stuff in the event log too */
-#ifdef USE_EVENT_LOG
-  hEventSource = RegisterEventSource (NULL, "GNU Make");
-  lpszStrings[0] = errmsg;
-
-  if (hEventSource != NULL)
-    {
-      ReportEvent (hEventSource,         /* handle of event source */
-                   EVENTLOG_ERROR_TYPE,  /* event type */
-                   0,                    /* event category */
-                   0,                    /* event ID */
-                   NULL,                 /* current user's SID */
-                   1,                    /* strings in lpszStrings */
-                   0,                    /* no bytes of raw data */
-                   lpszStrings,          /* array of error strings */
-                   NULL);                /* no raw data */
-
-      (VOID) DeregisterEventSource (hEventSource);
-    }
-#endif
-
-  /* Write the error to stderr too */
-  fprintf (stderr, errmsg);
-
-#ifdef DEBUG
-  return EXCEPTION_CONTINUE_SEARCH;
-#else
-  exit (255);
-  return (255); /* not reached */
-#endif
-}
-
-/*
- * On WIN32 systems we don't have the luxury of a /bin directory that
- * is mapped globally to every drive mounted to the system. Since make could
- * be invoked from any drive, and we don't want to propagate /bin/sh
- * to every single drive. Allow ourselves a chance to search for
- * a value for default shell here (if the default path does not exist).
- */
-
-int
-find_and_set_default_shell (const char *token)
-{
-  int sh_found = 0;
-  char *atoken = 0;
-  const char *search_token;
-  const char *tokend;
-  PATH_VAR(sh_path);
-  extern const char *default_shell;
-
-  if (!token)
-    search_token = default_shell;
-  else
-    search_token = atoken = xstrdup (token);
-
-  /* If the user explicitly requests the DOS cmd shell, obey that request.
-     However, make sure that's what they really want by requiring the value
-     of SHELL either equal, or have a final path element of, "cmd" or
-     "cmd.exe" case-insensitive.  */
-  tokend = search_token + strlen (search_token) - 3;
-  if (((tokend == search_token
-        || (tokend > search_token
-            && (tokend[-1] == '/' || tokend[-1] == '\\')))
-       && !strcasecmp (tokend, "cmd"))
-      || ((tokend - 4 == search_token
-           || (tokend - 4 > search_token
-               && (tokend[-5] == '/' || tokend[-5] == '\\')))
-          && !strcasecmp (tokend - 4, "cmd.exe")))
-    {
-      batch_mode_shell = 1;
-      unixy_shell = 0;
-      sprintf (sh_path, "%s", search_token);
-      default_shell = xstrdup (w32ify (sh_path, 0));
-      DB (DB_VERBOSE, (_("find_and_set_shell() setting default_shell = %s\n"),
-                       default_shell));
-      sh_found = 1;
-    }
-  else if (!no_default_sh_exe
-           && (token == NULL || !strcmp (search_token, default_shell)))
-    {
-      /* no new information, path already set or known */
-      sh_found = 1;
-    }
-  else if (_access (search_token, 0) == 0)
-    {
-      /* search token path was found */
-      sprintf (sh_path, "%s", search_token);
-      default_shell = xstrdup (w32ify (sh_path, 0));
-      DB (DB_VERBOSE, (_("find_and_set_shell() setting default_shell = %s\n"),
-                       default_shell));
-      sh_found = 1;
-    }
-  else
-    {
-      char *p;
-      struct variable *v = lookup_variable (STRING_SIZE_TUPLE ("PATH"));
-
-      /* Search Path for shell */
-      if (v && v->value)
-        {
-          char *ep;
-
-          p  = v->value;
-          ep = strchr (p, PATH_SEPARATOR_CHAR);
-
-          while (ep && *ep)
-            {
-              *ep = '\0';
-
-              sprintf (sh_path, "%s/%s", p, search_token);
-              if (_access (sh_path, 0) == 0)
-                {
-                  default_shell = xstrdup (w32ify (sh_path, 0));
-                  sh_found = 1;
-                  *ep = PATH_SEPARATOR_CHAR;
-
-                  /* terminate loop */
-                  p += strlen (p);
-                }
-              else
-                {
-                  *ep = PATH_SEPARATOR_CHAR;
-                  p = ++ep;
-                }
-
-              ep = strchr (p, PATH_SEPARATOR_CHAR);
-            }
-
-          /* be sure to check last element of Path */
-          if (p && *p)
-            {
-              sprintf (sh_path, "%s/%s", p, search_token);
-              if (_access (sh_path, 0) == 0)
-                {
-                  default_shell = xstrdup (w32ify (sh_path, 0));
-                  sh_found = 1;
-                }
-            }
-
-          if (sh_found)
-            DB (DB_VERBOSE,
-                (_("find_and_set_shell() path search set default_shell = %s\n"),
-                 default_shell));
-        }
-    }
-
-  /* naive test */
-  if (!unixy_shell && sh_found
-      && (strstr (default_shell, "sh") || strstr (default_shell, "SH")))
-    {
-      unixy_shell = 1;
-      batch_mode_shell = 0;
-    }
-
-#ifdef BATCH_MODE_ONLY_SHELL
-  batch_mode_shell = 1;
-#endif
-
-  free (atoken);
-
-  return (sh_found);
-}
-#endif  /* WINDOWS32 */
-
-#ifdef __MSDOS__
-static void
-msdos_return_to_initial_directory (void)
-{
-  if (directory_before_chdir)
-    chdir (directory_before_chdir);
-}
-#endif  /* __MSDOS__ */
-
-static void
-reset_jobserver (void)
-{
-  jobserver_clear ();
-  free (jobserver_auth);
-  jobserver_auth = NULL;
-}
-
-#ifdef _AMIGA
-int
-main (int argc, char **argv)
-#else
-int
-main (int argc, char **argv, char **envp)
-#endif
-{
-  static char *stdin_nm = 0;
-  int makefile_status = MAKE_SUCCESS;
-  struct goaldep *read_files;
-  PATH_VAR (current_directory);
-  unsigned int restarts = 0;
-  unsigned int syncing = 0;
-  int argv_slots;
-#ifdef WINDOWS32
-  const char *unix_path = NULL;
-  const char *windows32_path = NULL;
-
-  SetUnhandledExceptionFilter (handle_runtime_exceptions);
-
-  /* start off assuming we have no shell */
-  unixy_shell = 0;
-  no_default_sh_exe = 1;
-#endif
-
-  output_init (&make_sync);
-
-  initialize_stopchar_map();
-
-#ifdef SET_STACK_SIZE
- /* Get rid of any avoidable limit on stack size.  */
-  {
-    struct rlimit rlim;
-
-    /* Set the stack limit huge so that alloca does not fail.  */
-    if (getrlimit (RLIMIT_STACK, &rlim) == 0
-        && rlim.rlim_cur > 0 && rlim.rlim_cur < rlim.rlim_max)
-      {
-        stack_limit = rlim;
-        rlim.rlim_cur = rlim.rlim_max;
-        setrlimit (RLIMIT_STACK, &rlim);
-      }
-    else
-      stack_limit.rlim_cur = 0;
-  }
-#endif
-
-  /* Needed for OS/2 */
-  initialize_main (&argc, &argv);
-
-#ifdef MAKE_MAINTAINER_MODE
-  /* In maintainer mode we always enable verification.  */
-  verify_flag = 1;
-#endif
-
-#if defined (__MSDOS__) && !defined (_POSIX_SOURCE)
-  /* Request the most powerful version of 'system', to
-     make up for the dumb default shell.  */
-  __system_flags = (__system_redirect
-                    | __system_use_shell
-                    | __system_allow_multiple_cmds
-                    | __system_allow_long_cmds
-                    | __system_handle_null_commands
-                    | __system_emulate_chdir);
-
-#endif
-
-  /* Set up gettext/internationalization support.  */
-  setlocale (LC_ALL, "");
-  /* The cast to void shuts up compiler warnings on systems that
-     disable NLS.  */
-  (void)bindtextdomain (PACKAGE, LOCALEDIR);
-  (void)textdomain (PACKAGE);
-
-#ifdef  POSIX
-  sigemptyset (&fatal_signal_set);
-#define ADD_SIG(sig)    sigaddset (&fatal_signal_set, sig)
-#else
-#ifdef  HAVE_SIGSETMASK
-  fatal_signal_mask = 0;
-#define ADD_SIG(sig)    fatal_signal_mask |= sigmask (sig)
-#else
-#define ADD_SIG(sig)    (void)sig
-#endif
-#endif
-
-#define FATAL_SIG(sig)                                                        \
-  if (bsd_signal (sig, fatal_error_signal) == SIG_IGN)                        \
-    bsd_signal (sig, SIG_IGN);                                                \
-  else                                                                        \
-    ADD_SIG (sig);
-
-#ifdef SIGHUP
-  FATAL_SIG (SIGHUP);
-#endif
-#ifdef SIGQUIT
-  FATAL_SIG (SIGQUIT);
-#endif
-  FATAL_SIG (SIGINT);
-  FATAL_SIG (SIGTERM);
-
-#ifdef __MSDOS__
-  /* Windows 9X delivers FP exceptions in child programs to their
-     parent!  We don't want Make to die when a child divides by zero,
-     so we work around that lossage by catching SIGFPE.  */
-  FATAL_SIG (SIGFPE);
-#endif
-
-#ifdef  SIGDANGER
-  FATAL_SIG (SIGDANGER);
-#endif
-#ifdef SIGXCPU
-  FATAL_SIG (SIGXCPU);
-#endif
-#ifdef SIGXFSZ
-  FATAL_SIG (SIGXFSZ);
-#endif
-
-#undef  FATAL_SIG
-
-  /* Do not ignore the child-death signal.  This must be done before
-     any children could possibly be created; otherwise, the wait
-     functions won't work on systems with the SVR4 ECHILD brain
-     damage, if our invoker is ignoring this signal.  */
-
-#ifdef HAVE_WAIT_NOHANG
-# if defined SIGCHLD
-  (void) bsd_signal (SIGCHLD, SIG_DFL);
-# endif
-# if defined SIGCLD && SIGCLD != SIGCHLD
-  (void) bsd_signal (SIGCLD, SIG_DFL);
-# endif
-#endif
-
-  output_init (NULL);
-
-  /* Figure out where this program lives.  */
-
-  if (argv[0] == 0)
-    argv[0] = (char *)"";
-  if (argv[0][0] == '\0')
-    program = "make";
-  else
-    {
-#if defined(HAVE_DOS_PATHS)
-      const char* start = argv[0];
-
-      /* Skip an initial drive specifier if present.  */
-      if (isalpha ((unsigned char)start[0]) && start[1] == ':')
-        start += 2;
-
-      if (start[0] == '\0')
-        program = "make";
-      else
-        {
-          program = start + strlen (start);
-          while (program > start && ! STOP_SET (program[-1], MAP_DIRSEP))
-            --program;
-
-          /* Remove the .exe extension if present.  */
-          {
-            size_t len = strlen (program);
-            if (len > 4 && streq (&program[len - 4], ".exe"))
-              program = xstrndup (program, len - 4);
-          }
-        }
-#elif defined(VMS)
-      set_program_name (argv[0]);
-      program = program_name;
-      {
-        const char *shell;
-        char pwdbuf[256];
-        char *pwd;
-        shell = getenv ("SHELL");
-        if (shell != NULL)
-          vms_gnv_shell = 1;
-
-        /* Need to know if CRTL set to report UNIX paths.  Use getcwd as
-           it works on all versions of VMS. */
-        pwd = getcwd(pwdbuf, 256);
-        if (pwd[0] == '/')
-          vms_report_unix_paths = 1;
-
-        vms_use_mcr_command = get_vms_env_flag ("GNV$MAKE_USE_MCR", 0);
-
-        vms_always_use_cmd_file = get_vms_env_flag ("GNV$MAKE_USE_CMD_FILE", 0);
-
-        /* Legacy behavior is on VMS is older behavior that needed to be
-           changed to be compatible with standard make behavior.
-           For now only completely disable when running under a Bash shell.
-           TODO: Update VMS built in recipes and macros to not need this
-           behavior, at which time the default may change. */
-        vms_legacy_behavior = get_vms_env_flag ("GNV$MAKE_OLD_VMS",
-                                                !vms_gnv_shell);
-
-        /* VMS was changed to use a comma separator in the past, but that is
-           incompatible with built in functions that expect space separated
-           lists.  Allow this to be selectively turned off. */
-        vms_comma_separator = get_vms_env_flag ("GNV$MAKE_COMMA",
-                                                vms_legacy_behavior);
-
-        /* Some Posix shell syntax options are incompatible with VMS syntax.
-           VMS requires double quotes for strings and escapes quotes
-           differently.  When this option is active, VMS will try
-           to simulate Posix shell simulations instead of using
-           VMS DCL behavior. */
-        vms_unix_simulation = get_vms_env_flag ("GNV$MAKE_SHELL_SIM",
-                                                !vms_legacy_behavior);
-
-      }
-      if (need_vms_symbol () && !vms_use_mcr_command)
-        create_foreign_command (program_name, argv[0]);
-#else
-      program = strrchr (argv[0], '/');
-      if (program == 0)
-        program = argv[0];
-      else
-        ++program;
-#endif
-    }
-
-  /* Set up to access user data (files).  */
-  user_access ();
-
-  initialize_global_hash_tables ();
-
-  /* Figure out where we are.  */
-
-#ifdef WINDOWS32
-  if (getcwd_fs (current_directory, GET_PATH_MAX) == 0)
-#else
-  if (getcwd (current_directory, GET_PATH_MAX) == 0)
-#endif
-    {
-#ifdef  HAVE_GETCWD
-      perror_with_name ("getcwd", "");
-#else
-      OS (error, NILF, "getwd: %s", current_directory);
-#endif
-      current_directory[0] = '\0';
-      directory_before_chdir = 0;
-    }
-  else
-    directory_before_chdir = xstrdup (current_directory);
-
-#ifdef  __MSDOS__
-  /* Make sure we will return to the initial directory, come what may.  */
-  atexit (msdos_return_to_initial_directory);
-#endif
-
-  /* Initialize the special variables.  */
-  define_variable_cname (".VARIABLES", "", o_default, 0)->special = 1;
-  /* define_variable_cname (".TARGETS", "", o_default, 0)->special = 1; */
-  define_variable_cname (".RECIPEPREFIX", "", o_default, 0)->special = 1;
-  define_variable_cname (".SHELLFLAGS", "-c", o_default, 0);
-  define_variable_cname (".LOADED", "", o_default, 0);
-
-  /* Set up .FEATURES
-     Use a separate variable because define_variable_cname() is a macro and
-     some compilers (MSVC) don't like conditionals in macros.  */
-  {
-    const char *features = "target-specific order-only second-expansion"
-                           " else-if shortest-stem undefine oneshell nocomment"
-#ifndef NO_ARCHIVES
-                           " archives"
-#endif
-#ifdef MAKE_JOBSERVER
-                           " jobserver"
-#endif
-#ifndef NO_OUTPUT_SYNC
-                           " output-sync"
-#endif
-#ifdef MAKE_SYMLINKS
-                           " check-symlink"
-#endif
-#ifdef HAVE_GUILE
-                           " guile"
-#endif
-#ifdef MAKE_LOAD
-                           " load"
-#endif
-                           ;
-
-    define_variable_cname (".FEATURES", features, o_default, 0);
-  }
-
-  /* Configure GNU Guile support */
-  guile_gmake_setup (NILF);
-
-  /* Read in variables from the environment.  It is important that this be
-     done before $(MAKE) is figured out so its definitions will not be
-     from the environment.  */
-
-#ifndef _AMIGA
-  {
-    unsigned int i;
-
-    for (i = 0; envp[i] != 0; ++i)
-      {
-        struct variable *v;
-        const char *ep = envp[i];
-        /* By default, export all variables culled from the environment.  */
-        enum variable_export export = v_export;
-        unsigned int len;
-
-        while (! STOP_SET (*ep, MAP_EQUALS))
-          ++ep;
-
-        /* If there's no equals sign it's a malformed environment.  Ignore.  */
-        if (*ep == '\0')
-          continue;
-
-#ifdef WINDOWS32
-        if (!unix_path && strneq (envp[i], "PATH=", 5))
-          unix_path = ep+1;
-        else if (!strnicmp (envp[i], "Path=", 5))
-          {
-            if (!windows32_path)
-              windows32_path = ep+1;
-            /* PATH gets defined after the loop exits.  */
-            continue;
-          }
-#endif
-
-        /* Length of the variable name, and skip the '='.  */
-        len = ep++ - envp[i];
-
-        /* If this is MAKE_RESTARTS, check to see if the "already printed
-           the enter statement" flag is set.  */
-        if (len == 13 && strneq (envp[i], "MAKE_RESTARTS", 13))
-          {
-            if (*ep == '-')
-              {
-                OUTPUT_TRACED ();
-                ++ep;
-              }
-            restarts = (unsigned int) atoi (ep);
-            export = v_noexport;
-          }
-
-        v = define_variable (envp[i], len, ep, o_env, 1);
-
-        /* POSIX says the value of SHELL set in the makefile won't change the
-           value of SHELL given to subprocesses.  */
-        if (streq (v->name, "SHELL"))
-          {
-#ifndef __MSDOS__
-            export = v_noexport;
-#endif
-            shell_var.name = xstrdup ("SHELL");
-            shell_var.length = 5;
-            shell_var.value = xstrdup (ep);
-          }
-
-        v->export = export;
-      }
-  }
-#ifdef WINDOWS32
-    /* If we didn't find a correctly spelled PATH we define PATH as
-     * either the first misspelled value or an empty string
-     */
-    if (!unix_path)
-      define_variable_cname ("PATH", windows32_path ? windows32_path : "",
-                             o_env, 1)->export = v_export;
-#endif
-#else /* For Amiga, read the ENV: device, ignoring all dirs */
-    {
-        BPTR env, file, old;
-        char buffer[1024];
-        int len;
-        __aligned struct FileInfoBlock fib;
-
-        env = Lock ("ENV:", ACCESS_READ);
-        if (env)
-          {
-            old = CurrentDir (DupLock (env));
-            Examine (env, &fib);
-
-            while (ExNext (env, &fib))
-              {
-                if (fib.fib_DirEntryType < 0) /* File */
-                  {
-                    /* Define an empty variable. It will be filled in
-                       variable_lookup(). Makes startup quite a bit faster. */
-                    define_variable (fib.fib_FileName,
-                                     strlen (fib.fib_FileName),
-                                     "", o_env, 1)->export = v_export;
-                  }
-              }
-            UnLock (env);
-            UnLock (CurrentDir (old));
-          }
-    }
-#endif
-
-  /* Decode the switches.  */
-  decode_env_switches (STRING_SIZE_TUPLE ("GNUMAKEFLAGS"));
-
-  /* Clear GNUMAKEFLAGS to avoid duplication.  */
-  define_variable_cname ("GNUMAKEFLAGS", "", o_env, 0);
-
-  decode_env_switches (STRING_SIZE_TUPLE ("MAKEFLAGS"));
-
-#if 0
-  /* People write things like:
-        MFLAGS="CC=gcc -pipe" "CFLAGS=-g"
-     and we set the -p, -i and -e switches.  Doesn't seem quite right.  */
-  decode_env_switches (STRING_SIZE_TUPLE ("MFLAGS"));
-#endif
-
-  /* In output sync mode we need to sync any output generated by reading the
-     makefiles, such as in $(info ...) or stderr from $(shell ...) etc.  */
-
-  syncing = make_sync.syncout = (output_sync == OUTPUT_SYNC_LINE
-                                 || output_sync == OUTPUT_SYNC_TARGET);
-  OUTPUT_SET (&make_sync);
-
-  /* Parse the command line options.  Remember the job slots set this way.  */
-  {
-    int env_slots = arg_job_slots;
-    arg_job_slots = INVALID_JOB_SLOTS;
-
-    decode_switches (argc, (const char **)argv, 0);
-    argv_slots = arg_job_slots;
-
-    if (arg_job_slots == INVALID_JOB_SLOTS)
-      arg_job_slots = env_slots;
-  }
-
-  /* Set a variable specifying whether stdout/stdin is hooked to a TTY.  */
-#ifdef HAVE_ISATTY
-  if (isatty (fileno (stdout)))
-    if (! lookup_variable (STRING_SIZE_TUPLE ("MAKE_TERMOUT")))
-      {
-        const char *tty = TTYNAME (fileno (stdout));
-        define_variable_cname ("MAKE_TERMOUT", tty ? tty : DEFAULT_TTYNAME,
-                               o_default, 0)->export = v_export;
-      }
-  if (isatty (fileno (stderr)))
-    if (! lookup_variable (STRING_SIZE_TUPLE ("MAKE_TERMERR")))
-      {
-        const char *tty = TTYNAME (fileno (stderr));
-        define_variable_cname ("MAKE_TERMERR", tty ? tty : DEFAULT_TTYNAME,
-                               o_default, 0)->export = v_export;
-      }
-#endif
-
-  /* Reset in case the switches changed our minds.  */
-  syncing = (output_sync == OUTPUT_SYNC_LINE
-             || output_sync == OUTPUT_SYNC_TARGET);
-
-  if (make_sync.syncout && ! syncing)
-    output_close (&make_sync);
-
-  make_sync.syncout = syncing;
-  OUTPUT_SET (&make_sync);
-
-  /* Figure out the level of recursion.  */
-  {
-    struct variable *v = lookup_variable (STRING_SIZE_TUPLE (MAKELEVEL_NAME));
-    if (v && v->value[0] != '\0' && v->value[0] != '-')
-      makelevel = (unsigned int) atoi (v->value);
-    else
-      makelevel = 0;
-  }
-
-#ifdef WINDOWS32
-  if (suspend_flag)
-    {
-      fprintf (stderr, "%s (pid = %ld)\n", argv[0], GetCurrentProcessId ());
-      fprintf (stderr, _("%s is suspending for 30 seconds..."), argv[0]);
-      Sleep (30 * 1000);
-      fprintf (stderr, _("done sleep(30). Continuing.\n"));
-    }
-#endif
-
-  /* Set always_make_flag if -B was given and we've not restarted already.  */
-  always_make_flag = always_make_set && (restarts == 0);
-
-  /* Print version information, and exit.  */
-  if (print_version_flag)
-    {
-      print_version ();
-      die (MAKE_SUCCESS);
-    }
-
-  if (ISDB (DB_BASIC))
-    print_version ();
-
-#ifndef VMS
-  /* Set the "MAKE_COMMAND" variable to the name we were invoked with.
-     (If it is a relative pathname with a slash, prepend our directory name
-     so the result will run the same program regardless of the current dir.
-     If it is a name with no slash, we can only hope that PATH did not
-     find it in the current directory.)  */
-#ifdef WINDOWS32
-  /*
-   * Convert from backslashes to forward slashes for
-   * programs like sh which don't like them. Shouldn't
-   * matter if the path is one way or the other for
-   * CreateProcess().
-   */
-  if (strpbrk (argv[0], "/:\\") || strstr (argv[0], "..")
-      || strneq (argv[0], "//", 2))
-    argv[0] = xstrdup (w32ify (argv[0], 1));
-#else /* WINDOWS32 */
-#if defined (__MSDOS__) || defined (__EMX__)
-  if (strchr (argv[0], '\\'))
-    {
-      char *p;
-
-      argv[0] = xstrdup (argv[0]);
-      for (p = argv[0]; *p; p++)
-        if (*p == '\\')
-          *p = '/';
-    }
-  /* If argv[0] is not in absolute form, prepend the current
-     directory.  This can happen when Make is invoked by another DJGPP
-     program that uses a non-absolute name.  */
-  if (current_directory[0] != '\0'
-      && argv[0] != 0
-      && (argv[0][0] != '/' && (argv[0][0] == '\0' || argv[0][1] != ':'))
-# ifdef __EMX__
-      /* do not prepend cwd if argv[0] contains no '/', e.g. "make" */
-      && (strchr (argv[0], '/') != 0 || strchr (argv[0], '\\') != 0)
-# endif
-      )
-    argv[0] = xstrdup (concat (3, current_directory, "/", argv[0]));
-#else  /* !__MSDOS__ */
-  if (current_directory[0] != '\0'
-      && argv[0] != 0 && argv[0][0] != '/' && strchr (argv[0], '/') != 0
-#ifdef HAVE_DOS_PATHS
-      && (argv[0][0] != '\\' && (!argv[0][0] || argv[0][1] != ':'))
-      && strchr (argv[0], '\\') != 0
-#endif
-      )
-    argv[0] = xstrdup (concat (3, current_directory, "/", argv[0]));
-#endif /* !__MSDOS__ */
-#endif /* WINDOWS32 */
-#endif
-
-  /* We may move, but until we do, here we are.  */
-  starting_directory = current_directory;
-
-  /* Validate the arg_job_slots configuration before we define MAKEFLAGS so
-     users get an accurate value in their makefiles.
-     At this point arg_job_slots is the argv setting, if there is one, else
-     the MAKEFLAGS env setting, if there is one.  */
-
-  if (jobserver_auth)
-    {
-      /* We're a child in an existing jobserver group.  */
-      if (argv_slots == INVALID_JOB_SLOTS)
-        {
-          /* There's no -j option on the command line: check authorization.  */
-          if (jobserver_parse_auth (jobserver_auth))
-            {
-              /* Success!  Use the jobserver.  */
-              goto job_setup_complete;
-            }
-
-          /* Oops: we have jobserver-auth but it's invalid :(.  */
-          O (error, NILF, _("warning: jobserver unavailable: using -j1.  Add '+' to parent make rule."));
-          arg_job_slots = 1;
-        }
-
-      /* The user provided a -j setting on the command line so use it: we're
-         the master make of a new jobserver group.  */
-      else if (!restarts)
-        ON (error, NILF,
-            _("warning: -j%d forced in submake: resetting jobserver mode."),
-            argv_slots);
-
-      /* We can't use our parent's jobserver, so reset.  */
-      reset_jobserver ();
-    }
-
- job_setup_complete:
-
-  /* The extra indirection through $(MAKE_COMMAND) is done
-     for hysterical raisins.  */
-
-#ifdef VMS
-  if (vms_use_mcr_command)
-    define_variable_cname ("MAKE_COMMAND", vms_command (argv[0]), o_default, 0);
-  else
-    define_variable_cname ("MAKE_COMMAND", program, o_default, 0);
-#else
-  define_variable_cname ("MAKE_COMMAND", argv[0], o_default, 0);
-#endif
-  define_variable_cname ("MAKE", "$(MAKE_COMMAND)", o_default, 1);
-
-  if (command_variables != 0)
-    {
-      struct command_variable *cv;
-      struct variable *v;
-      unsigned int len = 0;
-      char *value, *p;
-
-      /* Figure out how much space will be taken up by the command-line
-         variable definitions.  */
-      for (cv = command_variables; cv != 0; cv = cv->next)
-        {
-          v = cv->variable;
-          len += 2 * strlen (v->name);
-          if (! v->recursive)
-            ++len;
-          ++len;
-          len += 2 * strlen (v->value);
-          ++len;
-        }
-
-      /* Now allocate a buffer big enough and fill it.  */
-      p = value = alloca (len);
-      for (cv = command_variables; cv != 0; cv = cv->next)
-        {
-          v = cv->variable;
-          p = quote_for_env (p, v->name);
-          if (! v->recursive)
-            *p++ = ':';
-          *p++ = '=';
-          p = quote_for_env (p, v->value);
-          *p++ = ' ';
-        }
-      p[-1] = '\0';             /* Kill the final space and terminate.  */
-
-      /* Define an unchangeable variable with a name that no POSIX.2
-         makefile could validly use for its own variable.  */
-      define_variable_cname ("-*-command-variables-*-", value, o_automatic, 0);
-
-      /* Define the variable; this will not override any user definition.
-         Normally a reference to this variable is written into the value of
-         MAKEFLAGS, allowing the user to override this value to affect the
-         exported value of MAKEFLAGS.  In POSIX-pedantic mode, we cannot
-         allow the user's setting of MAKEOVERRIDES to affect MAKEFLAGS, so
-         a reference to this hidden variable is written instead. */
-      define_variable_cname ("MAKEOVERRIDES", "${-*-command-variables-*-}",
-                             o_env, 1);
-#ifdef VMS
-      vms_export_dcl_symbol ("MAKEOVERRIDES", "${-*-command-variables-*-}");
-#endif
-    }
-
-  /* If there were -C flags, move ourselves about.  */
-  if (directories != 0)
-    {
-      unsigned int i;
-      for (i = 0; directories->list[i] != 0; ++i)
-        {
-          const char *dir = directories->list[i];
-#ifdef WINDOWS32
-          /* WINDOWS32 chdir() doesn't work if the directory has a trailing '/'
-             But allow -C/ just in case someone wants that.  */
-          {
-            char *p = (char *)dir + strlen (dir) - 1;
-            while (p > dir && (p[0] == '/' || p[0] == '\\'))
-              --p;
-            p[1] = '\0';
-          }
-#endif
-          if (chdir (dir) < 0)
-            pfatal_with_name (dir);
-        }
-    }
-
-#ifdef WINDOWS32
-  /*
-   * THIS BLOCK OF CODE MUST COME AFTER chdir() CALL ABOVE IN ORDER
-   * TO NOT CONFUSE THE DEPENDENCY CHECKING CODE IN implicit.c.
-   *
-   * The functions in dir.c can incorrectly cache information for "."
-   * before we have changed directory and this can cause file
-   * lookups to fail because the current directory (.) was pointing
-   * at the wrong place when it was first evaluated.
-   */
-   no_default_sh_exe = !find_and_set_default_shell (NULL);
-#endif /* WINDOWS32 */
-
-  /* Except under -s, always do -w in sub-makes and under -C.  */
-  if (!silent_flag && (directories != 0 || makelevel > 0))
-    print_directory_flag = 1;
-
-  /* Let the user disable that with --no-print-directory.  */
-  if (inhibit_print_directory_flag)
-    print_directory_flag = 0;
-
-  /* If -R was given, set -r too (doesn't make sense otherwise!)  */
-  if (no_builtin_variables_flag)
-    no_builtin_rules_flag = 1;
-
-  /* Construct the list of include directories to search.  */
-
-  construct_include_path (include_directories == 0
-                          ? 0 : include_directories->list);
-
-  /* If we chdir'ed, figure out where we are now.  */
-  if (directories)
-    {
-#ifdef WINDOWS32
-      if (getcwd_fs (current_directory, GET_PATH_MAX) == 0)
-#else
-      if (getcwd (current_directory, GET_PATH_MAX) == 0)
-#endif
-        {
-#ifdef  HAVE_GETCWD
-          perror_with_name ("getcwd", "");
-#else
-          OS (error, NILF, "getwd: %s", current_directory);
-#endif
-          starting_directory = 0;
-        }
-      else
-        starting_directory = current_directory;
-    }
-
-  define_variable_cname ("CURDIR", current_directory, o_file, 0);
-
-  /* Read any stdin makefiles into temporary files.  */
-
-  if (makefiles != 0)
-    {
-      unsigned int i;
-      for (i = 0; i < makefiles->idx; ++i)
-        if (makefiles->list[i][0] == '-' && makefiles->list[i][1] == '\0')
-          {
-            /* This makefile is standard input.  Since we may re-exec
-               and thus re-read the makefiles, we read standard input
-               into a temporary file and read from that.  */
-            FILE *outfile;
-            char *template;
-            const char *tmpdir;
-
-            if (stdin_nm)
-              O (fatal, NILF,
-                 _("Makefile from standard input specified twice."));
-
-#ifdef VMS
-# define DEFAULT_TMPDIR     "/sys$scratch/"
-#else
-# ifdef P_tmpdir
-#  define DEFAULT_TMPDIR    P_tmpdir
-# else
-#  define DEFAULT_TMPDIR    "/tmp"
-# endif
-#endif
-#define DEFAULT_TMPFILE     "GmXXXXXX"
-
-            if (((tmpdir = getenv ("TMPDIR")) == NULL || *tmpdir == '\0')
-#if defined (__MSDOS__) || defined (WINDOWS32) || defined (__EMX__)
-                /* These are also used commonly on these platforms.  */
-                && ((tmpdir = getenv ("TEMP")) == NULL || *tmpdir == '\0')
-                && ((tmpdir = getenv ("TMP")) == NULL || *tmpdir == '\0')
-#endif
-               )
-              tmpdir = DEFAULT_TMPDIR;
-
-            template = alloca (strlen (tmpdir) + CSTRLEN (DEFAULT_TMPFILE) + 2);
-            strcpy (template, tmpdir);
-
-#ifdef HAVE_DOS_PATHS
-            if (strchr ("/\\", template[strlen (template) - 1]) == NULL)
-              strcat (template, "/");
-#else
-# ifndef VMS
-            if (template[strlen (template) - 1] != '/')
-              strcat (template, "/");
-# endif /* !VMS */
-#endif /* !HAVE_DOS_PATHS */
-
-            strcat (template, DEFAULT_TMPFILE);
-            outfile = get_tmpfile (&stdin_nm, template);
-            if (outfile == 0)
-              pfatal_with_name (_("fopen (temporary file)"));
-            while (!feof (stdin) && ! ferror (stdin))
-              {
-                char buf[2048];
-                unsigned int n = fread (buf, 1, sizeof (buf), stdin);
-                if (n > 0 && fwrite (buf, 1, n, outfile) != n)
-                  pfatal_with_name (_("fwrite (temporary file)"));
-              }
-            fclose (outfile);
-
-            /* Replace the name that read_all_makefiles will
-               see with the name of the temporary file.  */
-            makefiles->list[i] = strcache_add (stdin_nm);
-
-            /* Make sure the temporary file will not be remade.  */
-            {
-              struct file *f = enter_file (strcache_add (stdin_nm));
-              f->updated = 1;
-              f->update_status = us_success;
-              f->command_state = cs_finished;
-              /* Can't be intermediate, or it'll be removed too early for
-                 make re-exec.  */
-              f->intermediate = 0;
-              f->dontcare = 0;
-            }
-          }
-    }
-
-#ifndef __EMX__ /* Don't use a SIGCHLD handler for OS/2 */
-#if !defined(HAVE_WAIT_NOHANG) || defined(MAKE_JOBSERVER)
-  /* Set up to handle children dying.  This must be done before
-     reading in the makefiles so that 'shell' function calls will work.
-
-     If we don't have a hanging wait we have to fall back to old, broken
-     functionality here and rely on the signal handler and counting
-     children.
-
-     If we're using the jobs pipe we need a signal handler so that SIGCHLD is
-     not ignored; we need it to interrupt the read(2) of the jobserver pipe if
-     we're waiting for a token.
-
-     If none of these are true, we don't need a signal handler at all.  */
-  {
-# if defined SIGCHLD
-    bsd_signal (SIGCHLD, child_handler);
-# endif
-# if defined SIGCLD && SIGCLD != SIGCHLD
-    bsd_signal (SIGCLD, child_handler);
-# endif
-  }
-
-#ifdef HAVE_PSELECT
-  /* If we have pselect() then we need to block SIGCHLD so it's deferred.  */
-  {
-    sigset_t block;
-    sigemptyset (&block);
-    sigaddset (&block, SIGCHLD);
-    if (sigprocmask (SIG_SETMASK, &block, NULL) < 0)
-      pfatal_with_name ("sigprocmask(SIG_SETMASK, SIGCHLD)");
-  }
-#endif
-
-#endif
-#endif
-
-  /* Let the user send us SIGUSR1 to toggle the -d flag during the run.  */
-#ifdef SIGUSR1
-  bsd_signal (SIGUSR1, debug_signal_handler);
-#endif
-
-  /* Define the initial list of suffixes for old-style rules.  */
-  set_default_suffixes ();
-
-  /* Define the file rules for the built-in suffix rules.  These will later
-     be converted into pattern rules.  We used to do this in
-     install_default_implicit_rules, but since that happens after reading
-     makefiles, it results in the built-in pattern rules taking precedence
-     over makefile-specified suffix rules, which is wrong.  */
-  install_default_suffix_rules ();
-
-  /* Define some internal and special variables.  */
-  define_automatic_variables ();
-
-  /* Set up the MAKEFLAGS and MFLAGS variables for makefiles to see.
-     Initialize it to be exported but allow the makefile to reset it.  */
-  define_makeflags (0, 0)->export = v_export;
-
-  /* Define the default variables.  */
-  define_default_variables ();
-
-  default_file = enter_file (strcache_add (".DEFAULT"));
-
-  default_goal_var = define_variable_cname (".DEFAULT_GOAL", "", o_file, 0);
-
-  /* Evaluate all strings provided with --eval.
-     Also set up the $(-*-eval-flags-*-) variable.  */
-
-  if (eval_strings)
-    {
-      char *p, *value;
-      unsigned int i;
-      unsigned int len = (CSTRLEN ("--eval=") + 1) * eval_strings->idx;
-
-      for (i = 0; i < eval_strings->idx; ++i)
-        {
-          p = xstrdup (eval_strings->list[i]);
-          len += 2 * strlen (p);
-          eval_buffer (p, NULL);
-          free (p);
-        }
-
-      p = value = alloca (len);
-      for (i = 0; i < eval_strings->idx; ++i)
-        {
-          strcpy (p, "--eval=");
-          p += CSTRLEN ("--eval=");
-          p = quote_for_env (p, eval_strings->list[i]);
-          *(p++) = ' ';
-        }
-      p[-1] = '\0';
-
-      define_variable_cname ("-*-eval-flags-*-", value, o_automatic, 0);
-    }
-
-  /* Read all the makefiles.  */
-
-  read_files = read_all_makefiles (makefiles == 0 ? 0 : makefiles->list);
-
-#ifdef WINDOWS32
-  /* look one last time after reading all Makefiles */
-  if (no_default_sh_exe)
-    no_default_sh_exe = !find_and_set_default_shell (NULL);
-#endif /* WINDOWS32 */
-
-#if defined (__MSDOS__) || defined (__EMX__) || defined (VMS)
-  /* We need to know what kind of shell we will be using.  */
-  {
-    extern int _is_unixy_shell (const char *_path);
-    struct variable *shv = lookup_variable (STRING_SIZE_TUPLE ("SHELL"));
-    extern int unixy_shell;
-    extern const char *default_shell;
-
-    if (shv && *shv->value)
-      {
-        char *shell_path = recursively_expand (shv);
-
-        if (shell_path && _is_unixy_shell (shell_path))
-          unixy_shell = 1;
-        else
-          unixy_shell = 0;
-        if (shell_path)
-          default_shell = shell_path;
-      }
-  }
-#endif /* __MSDOS__ || __EMX__ */
-
-  {
-    int old_builtin_rules_flag = no_builtin_rules_flag;
-    int old_builtin_variables_flag = no_builtin_variables_flag;
-    int old_arg_job_slots = arg_job_slots;
-
-    arg_job_slots = INVALID_JOB_SLOTS;
-
-    /* Decode switches again, for variables set by the makefile.  */
-    decode_env_switches (STRING_SIZE_TUPLE ("GNUMAKEFLAGS"));
-
-    /* Clear GNUMAKEFLAGS to avoid duplication.  */
-    define_variable_cname ("GNUMAKEFLAGS", "", o_override, 0);
-
-    decode_env_switches (STRING_SIZE_TUPLE ("MAKEFLAGS"));
-#if 0
-    decode_env_switches (STRING_SIZE_TUPLE ("MFLAGS"));
-#endif
-
-    /* If -j is not set in the makefile, or it was set on the command line,
-       reset to use the previous value.  */
-    if (arg_job_slots == INVALID_JOB_SLOTS || argv_slots != INVALID_JOB_SLOTS)
-      arg_job_slots = old_arg_job_slots;
-
-    else if (jobserver_auth)
-      {
-        /* Makefile MAKEFLAGS set -j, but we already have a jobserver.
-           Make us the master of a new jobserver group.  */
-        if (!restarts)
-          ON (error, NILF,
-              _("warning: -j%d forced in makefile: resetting jobserver mode."),
-              arg_job_slots);
-
-        /* We can't use our parent's jobserver, so reset.  */
-        reset_jobserver ();
-      }
-
-    /* Reset in case the switches changed our mind.  */
-    syncing = (output_sync == OUTPUT_SYNC_LINE
-               || output_sync == OUTPUT_SYNC_TARGET);
-
-    if (make_sync.syncout && ! syncing)
-      output_close (&make_sync);
-
-    make_sync.syncout = syncing;
-    OUTPUT_SET (&make_sync);
-
-    /* If we've disabled builtin rules, get rid of them.  */
-    if (no_builtin_rules_flag && ! old_builtin_rules_flag)
-      {
-        if (suffix_file->builtin)
-          {
-            free_dep_chain (suffix_file->deps);
-            suffix_file->deps = 0;
-          }
-        define_variable_cname ("SUFFIXES", "", o_default, 0);
-      }
-
-    /* If we've disabled builtin variables, get rid of them.  */
-    if (no_builtin_variables_flag && ! old_builtin_variables_flag)
-      undefine_default_variables ();
-  }
-
-  /* Final jobserver configuration.
-
-     If we have jobserver_auth then we are a client in an existing jobserver
-     group, that's already been verified OK above.  If we don't have
-     jobserver_auth and jobserver is enabled, then start a new jobserver.
-
-     arg_job_slots = INVALID_JOB_SLOTS if we don't want -j in MAKEFLAGS
-
-     arg_job_slots = # of jobs of parallelism
-
-     job_slots = 0 for no limits on jobs, or when limiting via jobserver.
-
-     job_slots = 1 for standard non-parallel mode.
-
-     job_slots >1 for old-style parallelism without jobservers.  */
-
-  if (jobserver_auth)
-    job_slots = 0;
-  else if (arg_job_slots == INVALID_JOB_SLOTS)
-    job_slots = 1;
-  else
-    job_slots = arg_job_slots;
-
-#if defined (__MSDOS__) || defined (__EMX__) || defined (VMS)
-  if (job_slots != 1
-# ifdef __EMX__
-      && _osmode != OS2_MODE /* turn off -j if we are in DOS mode */
-# endif
-      )
-    {
-      O (error, NILF,
-         _("Parallel jobs (-j) are not supported on this platform."));
-      O (error, NILF, _("Resetting to single job (-j1) mode."));
-      arg_job_slots = INVALID_JOB_SLOTS;
-      job_slots = 1;
-    }
-#endif
-
-  /* If we have >1 slot at this point, then we're a top-level make.
-     Set up the jobserver.
-
-     Every make assumes that it always has one job it can run.  For the
-     submakes it's the token they were given by their parent.  For the top
-     make, we just subtract one from the number the user wants.  */
-
-  if (job_slots > 1 && jobserver_setup (job_slots - 1))
-    {
-      /* Fill in the jobserver_auth for our children.  */
-      jobserver_auth = jobserver_get_auth ();
-
-      if (jobserver_auth)
-        {
-          /* We're using the jobserver so set job_slots to 0.  */
-          master_job_slots = job_slots;
-          job_slots = 0;
-        }
-    }
-
-  /* If we're not using parallel jobs, then we don't need output sync.
-     This is so people can enable output sync in GNUMAKEFLAGS or similar, but
-     not have it take effect unless parallel builds are enabled.  */
-  if (syncing && job_slots == 1)
-    {
-      OUTPUT_UNSET ();
-      output_close (&make_sync);
-      syncing = 0;
-      output_sync = OUTPUT_SYNC_NONE;
-    }
-
-#ifndef MAKE_SYMLINKS
-  if (check_symlink_flag)
-    {
-      O (error, NILF, _("Symbolic links not supported: disabling -L."));
-      check_symlink_flag = 0;
-    }
-#endif
-
-  /* Set up MAKEFLAGS and MFLAGS again, so they will be right.  */
-
-  define_makeflags (1, 0);
-
-  /* Make each 'struct goaldep' point at the 'struct file' for the file
-     depended on.  Also do magic for special targets.  */
-
-  snap_deps ();
-
-  /* Convert old-style suffix rules to pattern rules.  It is important to
-     do this before installing the built-in pattern rules below, so that
-     makefile-specified suffix rules take precedence over built-in pattern
-     rules.  */
-
-  convert_to_pattern ();
-
-  /* Install the default implicit pattern rules.
-     This used to be done before reading the makefiles.
-     But in that case, built-in pattern rules were in the chain
-     before user-defined ones, so they matched first.  */
-
-  install_default_implicit_rules ();
-
-  /* Compute implicit rule limits.  */
-
-  count_implicit_rule_limits ();
-
-  /* Construct the listings of directories in VPATH lists.  */
-
-  build_vpath_lists ();
-
-  /* Mark files given with -o flags as very old and as having been updated
-     already, and files given with -W flags as brand new (time-stamp as far
-     as possible into the future).  If restarts is set we'll do -W later.  */
-
-  if (old_files != 0)
-    {
-      const char **p;
-      for (p = old_files->list; *p != 0; ++p)
-        {
-          struct file *f = enter_file (*p);
-          f->last_mtime = f->mtime_before_update = OLD_MTIME;
-          f->updated = 1;
-          f->update_status = us_success;
-          f->command_state = cs_finished;
-        }
-    }
-
-  if (!restarts && new_files != 0)
-    {
-      const char **p;
-      for (p = new_files->list; *p != 0; ++p)
-        {
-          struct file *f = enter_file (*p);
-          f->last_mtime = f->mtime_before_update = NEW_MTIME;
-        }
-    }
-
-  /* Initialize the remote job module.  */
-  remote_setup ();
-
-  /* Dump any output we've collected.  */
-
-  OUTPUT_UNSET ();
-  output_close (&make_sync);
-
-  if (read_files)
-    {
-      /* Update any makefiles if necessary.  */
-
-      FILE_TIMESTAMP *makefile_mtimes;
-      char **aargv = NULL;
-      const char **nargv;
-      int nargc;
-      enum update_status status;
-
-      DB (DB_BASIC, (_("Updating makefiles....\n")));
-
-      {
-        struct goaldep *d;
-        unsigned int num_mkfiles = 0;
-        for (d = read_files; d != NULL; d = d->next)
-          ++num_mkfiles;
-
-        makefile_mtimes = alloca (num_mkfiles * sizeof (FILE_TIMESTAMP));
-      }
-
-      /* Remove any makefiles we don't want to try to update.  Record the
-         current modtimes of the others so we can compare them later.  */
-      {
-        struct goaldep *d = read_files;
-        struct goaldep *last = NULL;
-        unsigned int mm_idx = 0;
-
-        while (d != 0)
-          {
-            struct file *f;
-
-            for (f = d->file->double_colon; f != NULL; f = f->prev)
-              if (f->deps == 0 && f->cmds != 0)
-                break;
-
-            if (f)
-              {
-                /* This makefile is a :: target with commands, but no
-                   dependencies.  So, it will always be remade.  This might
-                   well cause an infinite loop, so don't try to remake it.
-                   (This will only happen if your makefiles are written
-                   exceptionally stupidly; but if you work for Athena, that's
-                   how you write your makefiles.)  */
-
-                DB (DB_VERBOSE,
-                    (_("Makefile '%s' might loop; not remaking it.\n"),
-                     f->name));
-
-                if (last)
-                  last->next = d->next;
-                else
-                  read_files = d->next;
-
-                /* Free the storage.  */
-                free_goaldep (d);
-
-                d = last ? last->next : read_files;
-              }
-            else
-              {
-                makefile_mtimes[mm_idx++] = file_mtime_no_search (d->file);
-                last = d;
-                d = d->next;
-              }
-          }
-      }
-
-      /* Set up 'MAKEFLAGS' specially while remaking makefiles.  */
-      define_makeflags (1, 1);
-
-      {
-        int orig_db_level = db_level;
-
-        if (! ISDB (DB_MAKEFILES))
-          db_level = DB_NONE;
-
-        rebuilding_makefiles = 1;
-        status = update_goal_chain (read_files);
-        rebuilding_makefiles = 0;
-
-        db_level = orig_db_level;
-      }
-
-      switch (status)
-        {
-        case us_question:
-          /* The only way this can happen is if the user specified -q and asked
-             for one of the makefiles to be remade as a target on the command
-             line.  Since we're not actually updating anything with -q we can
-             treat this as "did nothing".  */
-
-        case us_none:
-          /* Did nothing.  */
-          break;
-
-        case us_failed:
-          /* Failed to update.  Figure out if we care.  */
-          {
-            /* Nonzero if any makefile was successfully remade.  */
-            int any_remade = 0;
-            /* Nonzero if any makefile we care about failed
-               in updating or could not be found at all.  */
-            int any_failed = 0;
-            unsigned int i;
-            struct goaldep *d;
-
-            for (i = 0, d = read_files; d != 0; ++i, d = d->next)
-              {
-                if (d->file->updated)
-                  {
-                    /* This makefile was updated.  */
-                    if (d->file->update_status == us_success)
-                      {
-                        /* It was successfully updated.  */
-                        any_remade |= (file_mtime_no_search (d->file)
-                                       != makefile_mtimes[i]);
-                      }
-                    else if (! (d->flags & RM_DONTCARE))
-                      {
-                        FILE_TIMESTAMP mtime;
-                        /* The update failed and this makefile was not
-                           from the MAKEFILES variable, so we care.  */
-                        OS (error, NILF, _("Failed to remake makefile '%s'."),
-                            d->file->name);
-                        mtime = file_mtime_no_search (d->file);
-                        any_remade |= (mtime != NONEXISTENT_MTIME
-                                       && mtime != makefile_mtimes[i]);
-                        makefile_status = MAKE_FAILURE;
-                      }
-                  }
-                else
-                  /* This makefile was not found at all.  */
-                  if (! (d->flags & RM_DONTCARE))
-                    {
-                      const char *dnm = dep_name (d);
-                      size_t l = strlen (dnm);
-
-                      /* This is a makefile we care about.  See how much.  */
-                      if (d->flags & RM_INCLUDED)
-                        /* An included makefile.  We don't need to die, but we
-                           do want to complain.  */
-                        error (NILF, l,
-                               _("Included makefile '%s' was not found."), dnm);
-                      else
-                        {
-                          /* A normal makefile.  We must die later.  */
-                          error (NILF, l,
-                                 _("Makefile '%s' was not found"), dnm);
-                          any_failed = 1;
-                        }
-                    }
-              }
-
-            if (any_remade)
-              goto re_exec;
-            if (any_failed)
-              die (MAKE_FAILURE);
-            break;
-          }
-
-        case us_success:
-        re_exec:
-          /* Updated successfully.  Re-exec ourselves.  */
-
-          remove_intermediates (0);
-
-          if (print_data_base_flag)
-            print_data_base ();
-
-          clean_jobserver (0);
-
-          if (makefiles != 0)
-            {
-              /* These names might have changed.  */
-              int i, j = 0;
-              for (i = 1; i < argc; ++i)
-                if (strneq (argv[i], "-f", 2)) /* XXX */
-                  {
-                    if (argv[i][2] == '\0')
-                      /* This cast is OK since we never modify argv.  */
-                      argv[++i] = (char *) makefiles->list[j];
-                    else
-                      argv[i] = xstrdup (concat (2, "-f", makefiles->list[j]));
-                    ++j;
-                  }
-            }
-
-          /* Add -o option for the stdin temporary file, if necessary.  */
-          nargc = argc;
-          if (stdin_nm)
-            {
-              void *m = xmalloc ((nargc + 2) * sizeof (char *));
-              aargv = m;
-              memcpy (aargv, argv, argc * sizeof (char *));
-              aargv[nargc++] = xstrdup (concat (2, "-o", stdin_nm));
-              aargv[nargc] = 0;
-              nargv = m;
-            }
-          else
-            nargv = (const char**)argv;
-
-          if (directories != 0 && directories->idx > 0)
-            {
-              int bad = 1;
-              if (directory_before_chdir != 0)
-                {
-                  if (chdir (directory_before_chdir) < 0)
-                      perror_with_name ("chdir", "");
-                  else
-                    bad = 0;
-                }
-              if (bad)
-                O (fatal, NILF,
-                   _("Couldn't change back to original directory."));
-            }
-
-          ++restarts;
-
-          if (ISDB (DB_BASIC))
-            {
-              const char **p;
-              printf (_("Re-executing[%u]:"), restarts);
-              for (p = nargv; *p != 0; ++p)
-                printf (" %s", *p);
-              putchar ('\n');
-              fflush (stdout);
-            }
-
-#ifndef _AMIGA
-          {
-            char **p;
-            for (p = environ; *p != 0; ++p)
-              {
-                if (strneq (*p, MAKELEVEL_NAME "=", MAKELEVEL_LENGTH+1))
-                  {
-                    *p = alloca (40);
-                    sprintf (*p, "%s=%u", MAKELEVEL_NAME, makelevel);
-#ifdef VMS
-                    vms_putenv_symbol (*p);
-#endif
-                  }
-                else if (strneq (*p, "MAKE_RESTARTS=", CSTRLEN ("MAKE_RESTARTS=")))
-                  {
-                    *p = alloca (40);
-                    sprintf (*p, "MAKE_RESTARTS=%s%u",
-                             OUTPUT_IS_TRACED () ? "-" : "", restarts);
-                    restarts = 0;
-                  }
-              }
-          }
-#else /* AMIGA */
-          {
-            char buffer[256];
-
-            sprintf (buffer, "%u", makelevel);
-            SetVar (MAKELEVEL_NAME, buffer, -1, GVF_GLOBAL_ONLY);
-
-            sprintf (buffer, "%s%u", OUTPUT_IS_TRACED () ? "-" : "", restarts);
-            SetVar ("MAKE_RESTARTS", buffer, -1, GVF_GLOBAL_ONLY);
-            restarts = 0;
-          }
-#endif
-
-          /* If we didn't set the restarts variable yet, add it.  */
-          if (restarts)
-            {
-              char *b = alloca (40);
-              sprintf (b, "MAKE_RESTARTS=%s%u",
-                       OUTPUT_IS_TRACED () ? "-" : "", restarts);
-              putenv (b);
-            }
-
-          fflush (stdout);
-          fflush (stderr);
-
-#ifdef _AMIGA
-          exec_command (nargv);
-          exit (0);
-#elif defined (__EMX__)
-          {
-            /* It is not possible to use execve() here because this
-               would cause the parent process to be terminated with
-               exit code 0 before the child process has been terminated.
-               Therefore it may be the best solution simply to spawn the
-               child process including all file handles and to wait for its
-               termination. */
-            int pid;
-            int r;
-            pid = child_execute_job (NULL, 1, nargv, environ);
-
-            /* is this loop really necessary? */
-            do {
-              pid = wait (&r);
-            } while (pid <= 0);
-            /* use the exit code of the child process */
-            exit (WIFEXITED(r) ? WEXITSTATUS(r) : EXIT_FAILURE);
-          }
-#else
-#ifdef SET_STACK_SIZE
-          /* Reset limits, if necessary.  */
-          if (stack_limit.rlim_cur)
-            setrlimit (RLIMIT_STACK, &stack_limit);
-#endif
-          exec_command ((char **)nargv, environ);
-#endif
-          free (aargv);
-          break;
-        }
-    }
-
-  /* Set up 'MAKEFLAGS' again for the normal targets.  */
-  define_makeflags (1, 0);
-
-  /* Set always_make_flag if -B was given.  */
-  always_make_flag = always_make_set;
-
-  /* If restarts is set we haven't set up -W files yet, so do that now.  */
-  if (restarts && new_files != 0)
-    {
-      const char **p;
-      for (p = new_files->list; *p != 0; ++p)
-        {
-          struct file *f = enter_file (*p);
-          f->last_mtime = f->mtime_before_update = NEW_MTIME;
-        }
-    }
-
-  /* If there is a temp file from reading a makefile from stdin, get rid of
-     it now.  */
-  if (stdin_nm && unlink (stdin_nm) < 0 && errno != ENOENT)
-    perror_with_name (_("unlink (temporary file): "), stdin_nm);
-
-  /* If there were no command-line goals, use the default.  */
-  if (goals == 0)
-    {
-      char *p;
-
-      if (default_goal_var->recursive)
-        p = variable_expand (default_goal_var->value);
-      else
-        {
-          p = variable_buffer_output (variable_buffer, default_goal_var->value,
-                                      strlen (default_goal_var->value));
-          *p = '\0';
-          p = variable_buffer;
-        }
-
-      if (*p != '\0')
-        {
-          struct file *f = lookup_file (p);
-
-          /* If .DEFAULT_GOAL is a non-existent target, enter it into the
-             table and let the standard logic sort it out. */
-          if (f == 0)
-            {
-              struct nameseq *ns;
-
-              ns = PARSE_SIMPLE_SEQ (&p, struct nameseq);
-              if (ns)
-                {
-                  /* .DEFAULT_GOAL should contain one target. */
-                  if (ns->next != 0)
-                    O (fatal, NILF,
-                       _(".DEFAULT_GOAL contains more than one target"));
-
-                  f = enter_file (strcache_add (ns->name));
-
-                  ns->name = 0; /* It was reused by enter_file(). */
-                  free_ns_chain (ns);
-                }
-            }
-
-          if (f)
-            {
-              goals = alloc_goaldep ();
-              goals->file = f;
-            }
-        }
-    }
-  else
-    lastgoal->next = 0;
-
-
-  if (!goals)
-    {
-      struct variable *v = lookup_variable (STRING_SIZE_TUPLE ("MAKEFILE_LIST"));
-      if (v && v->value && v->value[0] != '\0')
-        O (fatal, NILF, _("No targets"));
-
-      O (fatal, NILF, _("No targets specified and no makefile found"));
-    }
-
-  /* Update the goals.  */
-
-  DB (DB_BASIC, (_("Updating goal targets....\n")));
-
-  {
-    switch (update_goal_chain (goals))
-    {
-      case us_none:
-        /* Nothing happened.  */
-        /* FALLTHROUGH */
-      case us_success:
-        /* Keep the previous result.  */
-        break;
-      case us_question:
-        /* We are under -q and would run some commands.  */
-        makefile_status = MAKE_TROUBLE;
-        break;
-      case us_failed:
-        /* Updating failed.  POSIX.2 specifies exit status >1 for this; */
-        makefile_status = MAKE_FAILURE;
-        break;
-    }
-
-    /* If we detected some clock skew, generate one last warning */
-    if (clock_skew_detected)
-      O (error, NILF,
-         _("warning:  Clock skew detected.  Your build may be incomplete."));
-
-    /* Exit.  */
-    die (makefile_status);
-  }
-
-  /* NOTREACHED */
-  exit (MAKE_SUCCESS);
-}
-
-/* Parsing of arguments, decoding of switches.  */
-
-static char options[1 + sizeof (switches) / sizeof (switches[0]) * 3];
-static struct option long_options[(sizeof (switches) / sizeof (switches[0])) +
-                                  (sizeof (long_option_aliases) /
-                                   sizeof (long_option_aliases[0]))];
-
-/* Fill in the string and vector for getopt.  */
-static void
-init_switches (void)
-{
-  char *p;
-  unsigned int c;
-  unsigned int i;
-
-  if (options[0] != '\0')
-    /* Already done.  */
-    return;
-
-  p = options;
-
-  /* Return switch and non-switch args in order, regardless of
-     POSIXLY_CORRECT.  Non-switch args are returned as option 1.  */
-  *p++ = '-';
-
-  for (i = 0; switches[i].c != '\0'; ++i)
-    {
-      long_options[i].name = (switches[i].long_name == 0 ? "" :
-                              switches[i].long_name);
-      long_options[i].flag = 0;
-      long_options[i].val = switches[i].c;
-      if (short_option (switches[i].c))
-        *p++ = switches[i].c;
-      switch (switches[i].type)
-        {
-        case flag:
-        case flag_off:
-        case ignore:
-          long_options[i].has_arg = no_argument;
-          break;
-
-        case string:
-        case strlist:
-        case filename:
-        case positive_int:
-        case floating:
-          if (short_option (switches[i].c))
-            *p++ = ':';
-          if (switches[i].noarg_value != 0)
-            {
-              if (short_option (switches[i].c))
-                *p++ = ':';
-              long_options[i].has_arg = optional_argument;
-            }
-          else
-            long_options[i].has_arg = required_argument;
-          break;
-        }
-    }
-  *p = '\0';
-  for (c = 0; c < (sizeof (long_option_aliases) /
-                   sizeof (long_option_aliases[0]));
-       ++c)
-    long_options[i++] = long_option_aliases[c];
-  long_options[i].name = 0;
-}
-
-
-/* Non-option argument.  It might be a variable definition.  */
-static void
-handle_non_switch_argument (const char *arg, int env)
-{
-  struct variable *v;
-
-  if (arg[0] == '-' && arg[1] == '\0')
-    /* Ignore plain '-' for compatibility.  */
-    return;
-
-#ifdef VMS
-  {
-    /* VMS DCL quoting can result in foo="bar baz" showing up here.
-       Need to remove the double quotes from the value. */
-    char * eq_ptr;
-    char * new_arg;
-    eq_ptr = strchr (arg, '=');
-    if ((eq_ptr != NULL) && (eq_ptr[1] == '"'))
-      {
-         int len;
-         int seg1;
-         int seg2;
-         len = strlen(arg);
-         new_arg = alloca(len);
-         seg1 = eq_ptr - arg + 1;
-         strncpy(new_arg, arg, (seg1));
-         seg2 = len - seg1 - 1;
-         strncpy(&new_arg[seg1], &eq_ptr[2], seg2);
-         new_arg[seg1 + seg2] = 0;
-         if (new_arg[seg1 + seg2 - 1] == '"')
-           new_arg[seg1 + seg2 - 1] = 0;
-         arg = new_arg;
-      }
-  }
-#endif
-  v = try_variable_definition (0, arg, o_command, 0);
-  if (v != 0)
-    {
-      /* It is indeed a variable definition.  If we don't already have this
-         one, record a pointer to the variable for later use in
-         define_makeflags.  */
-      struct command_variable *cv;
-
-      for (cv = command_variables; cv != 0; cv = cv->next)
-        if (cv->variable == v)
-          break;
-
-      if (! cv)
-        {
-          cv = xmalloc (sizeof (*cv));
-          cv->variable = v;
-          cv->next = command_variables;
-          command_variables = cv;
-        }
-    }
-  else if (! env)
-    {
-      /* Not an option or variable definition; it must be a goal
-         target!  Enter it as a file and add it to the dep chain of
-         goals.  */
-      struct file *f = enter_file (strcache_add (expand_command_line_file (arg)));
-      f->cmd_target = 1;
-
-      if (goals == 0)
-        {
-          goals = alloc_goaldep ();
-          lastgoal = goals;
-        }
-      else
-        {
-          lastgoal->next = alloc_goaldep ();
-          lastgoal = lastgoal->next;
-        }
-
-      lastgoal->file = f;
-
-      {
-        /* Add this target name to the MAKECMDGOALS variable. */
-        struct variable *gv;
-        const char *value;
-
-        gv = lookup_variable (STRING_SIZE_TUPLE ("MAKECMDGOALS"));
-        if (gv == 0)
-          value = f->name;
-        else
-          {
-            /* Paste the old and new values together */
-            unsigned int oldlen, newlen;
-            char *vp;
-
-            oldlen = strlen (gv->value);
-            newlen = strlen (f->name);
-            vp = alloca (oldlen + 1 + newlen + 1);
-            memcpy (vp, gv->value, oldlen);
-            vp[oldlen] = ' ';
-            memcpy (&vp[oldlen + 1], f->name, newlen + 1);
-            value = vp;
-          }
-        define_variable_cname ("MAKECMDGOALS", value, o_default, 0);
-      }
-    }
-}
-
-/* Print a nice usage method.  */
-
-static void
-print_usage (int bad)
-{
-  const char *const *cpp;
-  FILE *usageto;
-
-  if (print_version_flag)
-    print_version ();
-
-  usageto = bad ? stderr : stdout;
-
-  fprintf (usageto, _("Usage: %s [options] [target] ...\n"), program);
-
-  for (cpp = usage; *cpp; ++cpp)
-    fputs (_(*cpp), usageto);
-
-  if (!remote_description || *remote_description == '\0')
-    fprintf (usageto, _("\nThis program built for %s\n"), make_host);
-  else
-    fprintf (usageto, _("\nThis program built for %s (%s)\n"),
-             make_host, remote_description);
-
-  fprintf (usageto, _("Report bugs to <bug-make@gnu.org>\n"));
-}
-
-/* Decode switches from ARGC and ARGV.
-   They came from the environment if ENV is nonzero.  */
-
-static void
-decode_switches (int argc, const char **argv, int env)
-{
-  int bad = 0;
-  const struct command_switch *cs;
-  struct stringlist *sl;
-  int c;
-
-  /* getopt does most of the parsing for us.
-     First, get its vectors set up.  */
-
-  init_switches ();
-
-  /* Let getopt produce error messages for the command line,
-     but not for options from the environment.  */
-  opterr = !env;
-  /* Reset getopt's state.  */
-  optind = 0;
-
-  while (optind < argc)
-    {
-      const char *coptarg;
-
-      /* Parse the next argument.  */
-      c = getopt_long (argc, (char*const*)argv, options, long_options, NULL);
-      coptarg = optarg;
-      if (c == EOF)
-        /* End of arguments, or "--" marker seen.  */
-        break;
-      else if (c == 1)
-        /* An argument not starting with a dash.  */
-        handle_non_switch_argument (coptarg, env);
-      else if (c == '?')
-        /* Bad option.  We will print a usage message and die later.
-           But continue to parse the other options so the user can
-           see all he did wrong.  */
-        bad = 1;
-      else
-        for (cs = switches; cs->c != '\0'; ++cs)
-          if (cs->c == c)
-            {
-              /* Whether or not we will actually do anything with
-                 this switch.  We test this individually inside the
-                 switch below rather than just once outside it, so that
-                 options which are to be ignored still consume args.  */
-              int doit = !env || cs->env;
-
-              switch (cs->type)
-                {
-                default:
-                  abort ();
-
-                case ignore:
-                  break;
-
-                case flag:
-                case flag_off:
-                  if (doit)
-                    *(int *) cs->value_ptr = cs->type == flag;
-                  break;
-
-                case string:
-                case strlist:
-                case filename:
-                  if (!doit)
-                    break;
-
-                  if (! coptarg)
-                    coptarg = xstrdup (cs->noarg_value);
-                  else if (*coptarg == '\0')
-                    {
-                      char opt[2] = "c";
-                      const char *op = opt;
-
-                      if (short_option (cs->c))
-                        opt[0] = cs->c;
-                      else
-                        op = cs->long_name;
-
-                      error (NILF, strlen (op),
-                             _("the '%s%s' option requires a non-empty string argument"),
-                             short_option (cs->c) ? "-" : "--", op);
-                      bad = 1;
-                      break;
-                    }
-
-                  if (cs->type == string)
-                    {
-                      char **val = (char **)cs->value_ptr;
-                      free (*val);
-                      *val = xstrdup (coptarg);
-                      break;
-                    }
-
-                  sl = *(struct stringlist **) cs->value_ptr;
-                  if (sl == 0)
-                    {
-                      sl = xmalloc (sizeof (struct stringlist));
-                      sl->max = 5;
-                      sl->idx = 0;
-                      sl->list = xmalloc (5 * sizeof (char *));
-                      *(struct stringlist **) cs->value_ptr = sl;
-                    }
-                  else if (sl->idx == sl->max - 1)
-                    {
-                      sl->max += 5;
-                      /* MSVC erroneously warns without a cast here.  */
-                      sl->list = xrealloc ((void *)sl->list,
-                                           sl->max * sizeof (char *));
-                    }
-                  if (cs->type == filename)
-                    sl->list[sl->idx++] = expand_command_line_file (coptarg);
-                  else
-                    sl->list[sl->idx++] = xstrdup (coptarg);
-                  sl->list[sl->idx] = 0;
-                  break;
-
-                case positive_int:
-                  /* See if we have an option argument; if we do require that
-                     it's all digits, not something like "10foo".  */
-                  if (coptarg == 0 && argc > optind)
-                    {
-                      const char *cp;
-                      for (cp=argv[optind]; ISDIGIT (cp[0]); ++cp)
-                        ;
-                      if (cp[0] == '\0')
-                        coptarg = argv[optind++];
-                    }
-
-                  if (!doit)
-                    break;
-
-                  if (coptarg)
-                    {
-                      int i = atoi (coptarg);
-                      const char *cp;
-
-                      /* Yes, I realize we're repeating this in some cases.  */
-                      for (cp = coptarg; ISDIGIT (cp[0]); ++cp)
-                        ;
-
-                      if (i < 1 || cp[0] != '\0')
-                        {
-                          error (NILF, 0,
-                                 _("the '-%c' option requires a positive integer argument"),
-                                 cs->c);
-                          bad = 1;
-                        }
-                      else
-                        *(unsigned int *) cs->value_ptr = i;
-                    }
-                  else
-                    *(unsigned int *) cs->value_ptr
-                      = *(unsigned int *) cs->noarg_value;
-                  break;
-
-                case floating:
-                  if (coptarg == 0 && optind < argc
-                      && (ISDIGIT (argv[optind][0]) || argv[optind][0] == '.'))
-                    coptarg = argv[optind++];
-
-                  if (doit)
-                    *(double *) cs->value_ptr
-                      = (coptarg != 0 ? atof (coptarg)
-                         : *(double *) cs->noarg_value);
-
-                  break;
-                }
-
-              /* We've found the switch.  Stop looking.  */
-              break;
-            }
-    }
-
-  /* There are no more options according to getting getopt, but there may
-     be some arguments left.  Since we have asked for non-option arguments
-     to be returned in order, this only happens when there is a "--"
-     argument to prevent later arguments from being options.  */
-  while (optind < argc)
-    handle_non_switch_argument (argv[optind++], env);
-
-  if (!env && (bad || print_usage_flag))
-    {
-      print_usage (bad);
-      die (bad ? MAKE_FAILURE : MAKE_SUCCESS);
-    }
-
-  /* If there are any options that need to be decoded do it now.  */
-  decode_debug_flags ();
-  decode_output_sync_flags ();
-}
-
-/* Decode switches from environment variable ENVAR (which is LEN chars long).
-   We do this by chopping the value into a vector of words, prepending a
-   dash to the first word if it lacks one, and passing the vector to
-   decode_switches.  */
-
-static void
-decode_env_switches (const char *envar, unsigned int len)
-{
-  char *varref = alloca (2 + len + 2);
-  char *value, *p, *buf;
-  int argc;
-  const char **argv;
-
-  /* Get the variable's value.  */
-  varref[0] = '$';
-  varref[1] = '(';
-  memcpy (&varref[2], envar, len);
-  varref[2 + len] = ')';
-  varref[2 + len + 1] = '\0';
-  value = variable_expand (varref);
-
-  /* Skip whitespace, and check for an empty value.  */
-  NEXT_TOKEN (value);
-  len = strlen (value);
-  if (len == 0)
-    return;
-
-  /* Allocate a vector that is definitely big enough.  */
-  argv = alloca ((1 + len + 1) * sizeof (char *));
-
-  /* getopt will look at the arguments starting at ARGV[1].
-     Prepend a spacer word.  */
-  argv[0] = 0;
-  argc = 1;
-
-  /* We need a buffer to copy the value into while we split it into words
-     and unquote it.  Set up in case we need to prepend a dash later.  */
-  buf = alloca (1 + len + 1);
-  buf[0] = '-';
-  p = buf+1;
-  argv[argc] = p;
-  while (*value != '\0')
-    {
-      if (*value == '\\' && value[1] != '\0')
-        ++value;                /* Skip the backslash.  */
-      else if (ISBLANK (*value))
-        {
-          /* End of the word.  */
-          *p++ = '\0';
-          argv[++argc] = p;
-          do
-            ++value;
-          while (ISBLANK (*value));
-          continue;
-        }
-      *p++ = *value++;
-    }
-  *p = '\0';
-  argv[++argc] = 0;
-  assert (p < buf + len + 2);
-
-  if (argv[1][0] != '-' && strchr (argv[1], '=') == 0)
-    /* The first word doesn't start with a dash and isn't a variable
-       definition, so add a dash.  */
-    argv[1] = buf;
-
-  /* Parse those words.  */
-  decode_switches (argc, argv, 1);
-}
-
-/* Quote the string IN so that it will be interpreted as a single word with
-   no magic by decode_env_switches; also double dollar signs to avoid
-   variable expansion in make itself.  Write the result into OUT, returning
-   the address of the next character to be written.
-   Allocating space for OUT twice the length of IN is always sufficient.  */
-
-static char *
-quote_for_env (char *out, const char *in)
-{
-  while (*in != '\0')
-    {
-      if (*in == '$')
-        *out++ = '$';
-      else if (ISBLANK (*in) || *in == '\\')
-        *out++ = '\\';
-      *out++ = *in++;
-    }
-
-  return out;
-}
-
-/* Define the MAKEFLAGS and MFLAGS variables to reflect the settings of the
-   command switches.  Include options with args if ALL is nonzero.
-   Don't include options with the 'no_makefile' flag set if MAKEFILE.  */
-
-static struct variable *
-define_makeflags (int all, int makefile)
-{
-  const char ref[] = "$(MAKEOVERRIDES)";
-  const char posixref[] = "$(-*-command-variables-*-)";
-  const char evalref[] = "$(-*-eval-flags-*-)";
-  const struct command_switch *cs;
-  char *flagstring;
-  char *p;
-
-  /* We will construct a linked list of 'struct flag's describing
-     all the flags which need to go in MAKEFLAGS.  Then, once we
-     know how many there are and their lengths, we can put them all
-     together in a string.  */
-
-  struct flag
-    {
-      struct flag *next;
-      const struct command_switch *cs;
-      const char *arg;
-    };
-  struct flag *flags = 0;
-  struct flag *last = 0;
-  unsigned int flagslen = 0;
-#define ADD_FLAG(ARG, LEN) \
-  do {                                                                        \
-    struct flag *new = alloca (sizeof (struct flag));                         \
-    new->cs = cs;                                                             \
-    new->arg = (ARG);                                                         \
-    new->next = 0;                                                            \
-    if (! flags)                                                              \
-      flags = new;                                                            \
-    else                                                                      \
-      last->next = new;                                                       \
-    last = new;                                                               \
-    if (new->arg == 0)                                                        \
-      /* Just a single flag letter: " -x"  */                                 \
-      flagslen += 3;                                                          \
-    else                                                                      \
-      /* " -xfoo", plus space to escape "foo".  */                            \
-      flagslen += 1 + 1 + 1 + (3 * (LEN));                                    \
-    if (!short_option (cs->c))                                                \
-      /* This switch has no single-letter version, so we use the long.  */    \
-      flagslen += 2 + strlen (cs->long_name);                                 \
-  } while (0)
-
-  for (cs = switches; cs->c != '\0'; ++cs)
-    if (cs->toenv && (!makefile || !cs->no_makefile))
-      switch (cs->type)
-        {
-        case ignore:
-          break;
-
-        case flag:
-        case flag_off:
-          if ((!*(int *) cs->value_ptr) == (cs->type == flag_off)
-              && (cs->default_value == 0
-                  || *(int *) cs->value_ptr != *(int *) cs->default_value))
-            ADD_FLAG (0, 0);
-          break;
-
-        case positive_int:
-          if (all)
-            {
-              if ((cs->default_value != 0
-                   && (*(unsigned int *) cs->value_ptr
-                       == *(unsigned int *) cs->default_value)))
-                break;
-              else if (cs->noarg_value != 0
-                       && (*(unsigned int *) cs->value_ptr ==
-                           *(unsigned int *) cs->noarg_value))
-                ADD_FLAG ("", 0); /* Optional value omitted; see below.  */
-              else
-                {
-                  char *buf = alloca (30);
-                  sprintf (buf, "%u", *(unsigned int *) cs->value_ptr);
-                  ADD_FLAG (buf, strlen (buf));
-                }
-            }
-          break;
-
-        case floating:
-          if (all)
-            {
-              if (cs->default_value != 0
-                  && (*(double *) cs->value_ptr
-                      == *(double *) cs->default_value))
-                break;
-              else if (cs->noarg_value != 0
-                       && (*(double *) cs->value_ptr
-                           == *(double *) cs->noarg_value))
-                ADD_FLAG ("", 0); /* Optional value omitted; see below.  */
-              else
-                {
-                  char *buf = alloca (100);
-                  sprintf (buf, "%g", *(double *) cs->value_ptr);
-                  ADD_FLAG (buf, strlen (buf));
-                }
-            }
-          break;
-
-        case string:
-          if (all)
-            {
-              p = *((char **)cs->value_ptr);
-              if (p)
-                ADD_FLAG (p, strlen (p));
-            }
-          break;
-
-        case filename:
-        case strlist:
-          if (all)
-            {
-              struct stringlist *sl = *(struct stringlist **) cs->value_ptr;
-              if (sl != 0)
-                {
-                  unsigned int i;
-                  for (i = 0; i < sl->idx; ++i)
-                    ADD_FLAG (sl->list[i], strlen (sl->list[i]));
-                }
-            }
-          break;
-
-        default:
-          abort ();
-        }
-
-#undef  ADD_FLAG
-
-  /* Four more for the possible " -- ", plus variable references.  */
-  flagslen += 4 + CSTRLEN (posixref) + 1 + CSTRLEN (evalref) + 1;
-
-  /* Construct the value in FLAGSTRING.
-     We allocate enough space for a preceding dash and trailing null.  */
-  flagstring = alloca (1 + flagslen + 1);
-  memset (flagstring, '\0', 1 + flagslen + 1);
-  p = flagstring;
-
-  /* Start with a dash, for MFLAGS.  */
-  *p++ = '-';
-
-  /* Add simple options as a group.  */
-  while (flags != 0 && !flags->arg && short_option (flags->cs->c))
-    {
-      *p++ = flags->cs->c;
-      flags = flags->next;
-    }
-
-  /* Now add more complex flags: ones with options and/or long names.  */
-  while (flags)
-    {
-      *p++ = ' ';
-      *p++ = '-';
-
-      /* Add the flag letter or name to the string.  */
-      if (short_option (flags->cs->c))
-        *p++ = flags->cs->c;
-      else
-        {
-          /* Long options require a double-dash.  */
-          *p++ = '-';
-          strcpy (p, flags->cs->long_name);
-          p += strlen (p);
-        }
-      /* An omitted optional argument has an ARG of "".  */
-      if (flags->arg && flags->arg[0] != '\0')
-        {
-          if (!short_option (flags->cs->c))
-            /* Long options require '='.  */
-            *p++ = '=';
-          p = quote_for_env (p, flags->arg);
-        }
-      flags = flags->next;
-    }
-
-  /* If no flags at all, get rid of the initial dash.  */
-  if (p == &flagstring[1])
-    {
-      flagstring[0] = '\0';
-      p = flagstring;
-    }
-
-  /* Define MFLAGS before appending variable definitions.  Omit an initial
-     empty dash.  Since MFLAGS is not parsed for flags, there is no reason to
-     override any makefile redefinition.  */
-  define_variable_cname ("MFLAGS",
-                         flagstring + (flagstring[0] == '-' && flagstring[1] == ' ' ? 2 : 0),
-                         o_env, 1);
-
-  /* Write a reference to -*-eval-flags-*-, which contains all the --eval
-     flag options.  */
-  if (eval_strings)
-    {
-      *p++ = ' ';
-      memcpy (p, evalref, CSTRLEN (evalref));
-      p += CSTRLEN (evalref);
-    }
-
-  if (all && command_variables)
-    {
-      /* Write a reference to $(MAKEOVERRIDES), which contains all the
-         command-line variable definitions.  Separate the variables from the
-         switches with a "--" arg.  */
-
-      strcpy (p, " -- ");
-      p += 4;
-
-      /* Copy in the string.  */
-      if (posix_pedantic)
-        {
-          memcpy (p, posixref, CSTRLEN (posixref));
-          p += CSTRLEN (posixref);
-        }
-      else
-        {
-          memcpy (p, ref, CSTRLEN (ref));
-          p += CSTRLEN (ref);
-        }
-    }
-
-  /* If there is a leading dash, omit it.  */
-  if (flagstring[0] == '-')
-    ++flagstring;
-
-  /* This used to use o_env, but that lost when a makefile defined MAKEFLAGS.
-     Makefiles set MAKEFLAGS to add switches, but we still want to redefine
-     its value with the full set of switches.  Then we used o_file, but that
-     lost when users added -e, causing a previous MAKEFLAGS env. var. to take
-     precedence over the new one.  Of course, an override or command
-     definition will still take precedence.  */
-  return define_variable_cname ("MAKEFLAGS", flagstring,
-                                env_overrides ? o_env_override : o_file, 1);
-}
-
-/* Print version information.  */
-
-static void
-print_version (void)
-{
-  static int printed_version = 0;
-
-  const char *precede = print_data_base_flag ? "# " : "";
-
-  if (printed_version)
-    /* Do it only once.  */
-    return;
-
-  printf ("%sGNU Make %s\n", precede, version_string);
-
-  if (!remote_description || *remote_description == '\0')
-    printf (_("%sBuilt for %s\n"), precede, make_host);
-  else
-    printf (_("%sBuilt for %s (%s)\n"),
-            precede, make_host, remote_description);
-
-  /* Print this untranslated.  The coding standards recommend translating the
-     (C) to the copyright symbol, but this string is going to change every
-     year, and none of the rest of it should be translated (including the
-     word "Copyright"), so it hardly seems worth it.  */
-
-  printf ("%sCopyright (C) 1988-2017 Free Software Foundation, Inc.\n",
-          precede);
-
-  printf (_("%sLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n\
-%sThis is free software: you are free to change and redistribute it.\n\
-%sThere is NO WARRANTY, to the extent permitted by law.\n"),
-            precede, precede, precede);
-
-  printed_version = 1;
-
-  /* Flush stdout so the user doesn't have to wait to see the
-     version information while make thinks about things.  */
-  fflush (stdout);
-}
-
-/* Print a bunch of information about this and that.  */
-
-static void
-print_data_base (void)
-{
-  time_t when = time ((time_t *) 0);
-
-  print_version ();
-
-  printf (_("\n# Make data base, printed on %s"), ctime (&when));
-
-  print_variable_data_base ();
-  print_dir_data_base ();
-  print_rule_data_base ();
-  print_file_data_base ();
-  print_vpath_data_base ();
-  strcache_print_stats ("#");
-
-  when = time ((time_t *) 0);
-  printf (_("\n# Finished Make data base on %s\n"), ctime (&when));
-}
-
-static void
-clean_jobserver (int status)
-{
-  /* Sanity: have we written all our jobserver tokens back?  If our
-     exit status is 2 that means some kind of syntax error; we might not
-     have written all our tokens so do that now.  If tokens are left
-     after any other error code, that's bad.  */
-
-  if (jobserver_enabled() && jobserver_tokens)
-    {
-      if (status != 2)
-        ON (error, NILF,
-            "INTERNAL: Exiting with %u jobserver tokens (should be 0)!",
-            jobserver_tokens);
-      else
-        /* Don't write back the "free" token */
-        while (--jobserver_tokens)
-          jobserver_release (0);
-    }
-
-
-  /* Sanity: If we're the master, were all the tokens written back?  */
-
-  if (master_job_slots)
-    {
-      /* We didn't write one for ourself, so start at 1.  */
-      unsigned int tokens = 1 + jobserver_acquire_all ();
-
-      if (tokens != master_job_slots)
-        ONN (error, NILF,
-             "INTERNAL: Exiting with %u jobserver tokens available; should be %u!",
-             tokens, master_job_slots);
-
-      reset_jobserver ();
-    }
-}
-
-/* Exit with STATUS, cleaning up as necessary.  */
-
-void
-die (int status)
-{
-  static char dying = 0;
-
-  if (!dying)
-    {
-      int err;
-
-      dying = 1;
-
-      if (print_version_flag)
-        print_version ();
-
-      /* Wait for children to die.  */
-      err = (status != 0);
-      while (job_slots_used > 0)
-        reap_children (1, err);
-
-      /* Let the remote job module clean up its state.  */
-      remote_cleanup ();
-
-      /* Remove the intermediate files.  */
-      remove_intermediates (0);
-
-      if (print_data_base_flag)
-        print_data_base ();
-
-      if (verify_flag)
-        verify_file_data_base ();
-
-      clean_jobserver (status);
-
-      if (output_context)
-        {
-          /* die() might be called in a recipe output context due to an
-             $(error ...) function.  */
-          output_close (output_context);
-
-          if (output_context != &make_sync)
-            output_close (&make_sync);
-
-          OUTPUT_UNSET ();
-        }
-
-      output_close (NULL);
-
-      /* Try to move back to the original directory.  This is essential on
-         MS-DOS (where there is really only one process), and on Unix it
-         puts core files in the original directory instead of the -C
-         directory.  Must wait until after remove_intermediates(), or unlinks
-         of relative pathnames fail.  */
-      if (directory_before_chdir != 0)
-        {
-          /* If it fails we don't care: shut up GCC.  */
-          int _x UNUSED;
-          _x = chdir (directory_before_chdir);
-        }
-    }
-
-  exit (status);
-}
diff --git a/maintMakefile b/maintMakefile
index 19a154f..c9e552e 100644
--- a/maintMakefile
+++ b/maintMakefile
@@ -36,7 +36,7 @@ AM_CPPFLAGS += $(MAKE_MAINTAINER_MODE)
 # -Wwrite-strings
 
 TEMPLATES = README README.DOS README.W32 README.OS2 \
-	    config.ami configh.dos config.h.W32 config.h-vms
+	    src/config.ami src/configh.dos src/config.h.W32 src/config.h-vms
 
 # Create preprocessor output files--GCC specific!
 %.i : %.c
@@ -53,19 +53,22 @@ $(TEMPLATES) : % : %.template Makefile
 
 # Construct Makefiles by adding on dependencies, etc.
 #
+srccvt = $(patsubst src/%,$$(src)%,$(filter %.c,$1))
 Basic.mk: Basic.mk.template .dep_segment Makefile
 	rm -f $@
 	sed -e 's@%VERSION%@$(VERSION)@g' \
-	    -e 's@%make_SOURCES%@$(filter %.c,$(make_SRCS))@g' \
-	    -e 's@%glob_SOURCES%@$(filter %.c,$(glob_SRCS))@g' \
-	    -e 's@%w32_SOURCES%@$(filter %.c,$(w32_SRCS))@g' \
-	    -e 's@%vms_SOURCES%@$(filter %.c,$(vms_SRCS))@g' \
-	    -e 's@%amiga_SOURCES%@$(filter %.c,$(amiga_SRCS))@g' \
+	    -e 's@%make_SOURCES%@$(call srccvt,$(make_SRCS))@g' \
+	    -e 's@%glob_SOURCES%@$(patsubst glob/%,$$(glob)%,$(filter %.c,$(glob_SRCS)))@g' \
+	    -e 's@%loadavg_SOURCES%@$(call srccvt,$(loadavg_SRCS))@g' \
+	    -e 's@%alloca_SOURCES%@$(call srccvt,$(alloca_SRCS))@g' \
+	    -e 's@%w32_SOURCES%@$(call srccvt,$(w32_SRCS))@g' \
+	    -e 's@%vms_SOURCES%@$(call srccvt,$(vms_SRCS))@g' \
+	    -e 's@%amiga_SOURCES%@$(call srccvt,$(amiga_SRCS))@g' \
 	  $< > $@
 	echo >>$@; echo '# --------------- DEPENDENCIES' >>$@; echo '#' >>$@; \
-	sed -e 's@^\([^ ]*\)\.o:@$$(OUTDIR)/\1.$$(OBJEXT):@' \
+	sed -e 's@^\([^ ]*\)\.o:@$$(OUTDIR)\1.$$(OBJEXT):@' \
 	    -e 's@\([^ ]*\.[ch]\)@$$(SRCDIR)/\1@g' \
-	    -e 's@$$(SRCDIR)/config.h@$$(OUTDIR)/config.h@g' \
+	    -e 's@$$(SRCDIR)/src/config.h@$$(OUTDIR)src/config.h@g' \
 	  $(word 2,$^) >>$@
 	chmod a-w $@
 
@@ -73,7 +76,7 @@ Basic.mk: Basic.mk.template .dep_segment Makefile
 #
 build.sh.in: build.template Makefile
 	rm -f $@
-	sed -e 's@%objs%@$(patsubst %.o,%.$${OBJEXT},$(filter-out remote-%,$(make_OBJECTS)))@g' \
+	sed -e 's@%objs%@$(patsubst %.o,%.$${OBJEXT},$(filter-out src/remote-%,$(make_OBJECTS)))@g' \
 	    -e 's@%globobjs%@$(patsubst %.c,%.$${OBJEXT},$(filter %.c,$(glob_SRCS)))@g' \
 	  $< > $@
 	chmod a-w+x $@
@@ -84,10 +87,10 @@ build.sh.in: build.template Makefile
 # Automake used to have a --generate-deps flag but it's gone now, so we have
 # to do it ourselves.
 #
-DEP_FILES := $(wildcard $(DEPDIR)/*.Po)
+DEP_FILES := $(wildcard src/$(DEPDIR)/*.Po)
 .dep_segment: Makefile.am maintMakefile $(DEP_FILES)
 	rm -f $@
-	(for f in $(DEPDIR)/*.Po; do \
+	(for f in src/$(DEPDIR)/*.Po; do \
 	   echo ""; \
 	   echo "# $$f"; \
 	   sed	-e '/^[^:]*\.[ch] *:/d' \
@@ -157,7 +160,7 @@ move_if_change =  if test -r $(target) && cmp -s $(target).t $(target); then \
 #   ftp://tiger.informatik.hu-berlin.de/pub/po/maint/
 
 po_wget_flags =	--recursive --level=1 --no-directories --no-check-certificate
-po_repo = http://translationproject.org/latest/$(PACKAGE)
+po_repo = https://translationproject.org/latest/$(PACKAGE)
 po_sync = translationproject.org::tp/latest/$(PACKAGE)/
 
 .PHONY: do-po-update po-update
@@ -182,8 +185,8 @@ po-update:
 # with each of the files that belongs to some other package and is
 # regularly updated from the specified URL.
 
-cvs-url = http://savannah.gnu.org/cgi-bin/viewcvs/~checkout~
-git-url = http://git.savannah.gnu.org/cgit
+cvs-url = https://savannah.gnu.org/cgi-bin/viewcvs/~checkout~
+git-url = https://git.savannah.gnu.org/cgit
 target = $(patsubst get-%,%,$@)
 
 config-url = $(git-url)/config.git/plain/$(patsubst get-config/%,%,$@)
@@ -231,22 +234,51 @@ check-alt-config: \
 # Trick GNU make so it doesn't run the submake as a recursive make.
 NR_MAKE = $(MAKE)
 
-# Check builds both with build.sh and with make
+# Check builds both with build.sh and with make and with Basic.mk
 checkcfg.%: distdir
 	@echo "Building $@ (output in checkcfg.$*.log)"
-	@exec >'checkcfg.$*.log' 2>&1; \
+	exec >'checkcfg.$*.log' 2>&1; \
 	   rm -rf $(distdir)/_build \
 	&& mkdir $(distdir)/_build \
 	&& cd $(distdir)/_build \
 	&& echo "Testing configure with $(subst ^,=,$*)" \
 	&& ../configure --srcdir=.. $(subst ^,=,$*) \
-		$(AM_DISTCHECK_CONFIGURE_FLAGS) $(DISTCHECK_CONFIGURE_FLAGS) \
-		CFLAGS='$(AM_CFLAGS)' \
+		$(AM_DISTCHECK_CONFIGURE_FLAGS) $(DISTCHECK_CONFIGURE_FLAGS)
+	exec >>'checkcfg.$*.log' 2>&1; \
+	   cd $(distdir)/_build \
 	&& ./build.sh \
 	&& ./make $(AM_MAKEFLAGS) check \
-	&& rm -f *.o make \
-	&& $(NR_MAKE) $(AM_MAKEFLAGS) \
-	&& ./make $(AM_MAKEFLAGS) check
+	&& ./make $(AM_MAKEFLAGS) clean
+	exec >>'checkcfg.$*.log' 2>&1; \
+	   cd $(distdir)/_build \
+	&& $(NR_MAKE) $(AM_MAKEFLAGS) CFLAGS='$(AM_CFLAGS)' \
+	&& ./make $(AM_MAKEFLAGS) check \
+	&& ./make $(AM_MAKEFLAGS) clean
+
+# Try the different build methods
+checkcfg.basicmk: checkcfg.% : distdir
+	@echo "Building $@ (output in checkcfg.$*.log)"
+	exec >'checkcfg.$*.log' 2>&1; \
+	   rm -rf $(distdir)/_build \
+	&& mkdir $(distdir)/_build \
+	&& cd $(distdir)/_build \
+	&& echo "Testing Basic.mk SRCDIR=.." \
+	&& ../configure --srcdir=.. \
+		$(AM_DISTCHECK_CONFIGURE_FLAGS) $(DISTCHECK_CONFIGURE_FLAGS)
+	exec >>'checkcfg.$*.log' 2>&1; \
+	   cd $(distdir)/_build \
+	&& $(NR_MAKE) $(AM_MAKEFLAGS) -f ../Basic.mk CFLAGS='$(AM_CFLAGS)' SRCDIR=.. \
+	&& ./make $(AM_MAKEFLAGS) -f ../Basic.mk SRCDIR=.. check \
+	&& ./make $(AM_MAKEFLAGS) -f ../Basic.mk SRCDIR=.. clean
+	exec >>'checkcfg.$*.log' 2>&1; \
+	   echo "Testing Basic.mk SRCDIR=." \
+	&& rm -rf $(distdir)/_build \
+	&& cd $(distdir) \
+	&& ./configure \
+		$(AM_DISTCHECK_CONFIGURE_FLAGS) $(DISTCHECK_CONFIGURE_FLAGS) \
+	&& $(NR_MAKE) $(AM_MAKEFLAGS) -f Basic.mk CFLAGS='$(AM_CFLAGS)' \
+	&& ./make $(AM_MAKEFLAGS) -f Basic.mk check \
+	&& ./make $(AM_MAKEFLAGS) -f Basic.mk clean
 
 
 ## --------------- ##
@@ -273,11 +305,11 @@ changelog-check:
 	fi
 
 # Verify that all source files using _() are listed in po/POTFILES.in.
-# Ignore makeint.h; it defines _().
+# Ignore src/makeint.h; it defines _().
 po-check:
 	if test -f po/POTFILES.in; then \
 	  grep '^[^#]' po/POTFILES.in | sort > $@-1; \
-	  $(PERL) -wn -e 'if (/\b_\(/) { $$ARGV eq "./makeint.h" || print "$$ARGV\n" and close ARGV }' `find . -name '*.[ch]'` | sed 's,^\./,,' | sort > $@-2; \
+	  $(PERL) -wn -e 'if (/\b_\(/) { $$ARGV eq "./src/makeint.h" || print "$$ARGV\n" and close ARGV }' `find . -name '*.[ch]'` | sed 's,^\./,,' | sort > $@-2; \
 	  diff -u $@-1 $@-2 || exit 1; \
 	  rm -f $@-1 $@-2; \
 	fi
diff --git a/make.1 b/make.1
deleted file mode 100644
index 031321e..0000000
--- a/make.1
+++ /dev/null
@@ -1,379 +0,0 @@
-.TH MAKE 1 "28 February 2016" "GNU" "User Commands"
-.SH NAME
-make \- GNU make utility to maintain groups of programs
-.SH SYNOPSIS
-.B make
-[\fIOPTION\fR]... [\fITARGET\fR]...
-.SH DESCRIPTION
-.LP
-The
-.I make
-utility will determine automatically which pieces of a large program need to
-be recompiled, and issue the commands to recompile them.  The manual describes
-the GNU implementation of
-.BR make ,
-which was written by Richard Stallman and Roland McGrath, and is currently
-maintained by Paul Smith.  Our examples show C programs, since they are very
-common, but you can use
-.B make
-with any programming language whose compiler can be run with a shell command.
-In fact,
-.B make
-is not limited to programs.  You can use it to describe any task where some
-files must be updated automatically from others whenever the others change.
-.LP
-To prepare to use
-.BR make ,
-you must write a file called the
-.I makefile
-that describes the relationships among files in your program, and the states
-the commands for updating each file.  In a program, typically the executable
-file is updated from object files, which are in turn made by compiling source
-files.
-.LP
-Once a suitable makefile exists, each time you change some source files,
-this simple shell command:
-.sp 1
-.RS
-.B make
-.RE
-.sp 1
-suffices to perform all necessary recompilations.
-The
-.B make
-program uses the makefile description and the last-modification times of the
-files to decide which of the files need to be updated.  For each of those
-files, it issues the commands recorded in the makefile.
-.LP
-.B make
-executes commands in the
-.I makefile
-to update one or more target
-.IR names ,
-where
-.I name
-is typically a program.
-If no
-.B \-f
-option is present,
-.B make
-will look for the makefiles
-.IR GNUmakefile ,
-.IR makefile ,
-and
-.IR Makefile ,
-in that order.
-.LP
-Normally you should call your makefile either
-.I makefile
-or
-.IR Makefile .
-(We recommend
-.I Makefile
-because it appears prominently near the beginning of a directory
-listing, right near other important files such as
-.IR  README .)
-The first name checked,
-.IR GNUmakefile ,
-is not recommended for most makefiles.  You should use this name if you have a
-makefile that is specific to GNU
-.BR make ,
-and will not be understood by other versions of
-.BR make .
-If
-.I makefile
-is '\-', the standard input is read.
-.LP
-.B make
-updates a target if it depends on prerequisite files
-that have been modified since the target was last modified,
-or if the target does not exist.
-.SH OPTIONS
-.sp 1
-.TP 0.5i
-\fB\-b\fR, \fB\-m\fR
-These options are ignored for compatibility with other versions of
-.BR make .
-.TP 0.5i
-\fB\-B\fR, \fB\-\-always\-make\fR
-Unconditionally make all targets.
-.TP 0.5i
-\fB\-C\fR \fIdir\fR, \fB\-\-directory\fR=\fIdir\fR
-Change to directory
-.I dir
-before reading the makefiles or doing anything else.
-If multiple
-.B \-C
-options are specified, each is interpreted relative to the
-previous one:
-.BR "\-C " /
-.BR "\-C " etc
-is equivalent to
-.BR "\-C " /etc.
-This is typically used with recursive invocations of
-.BR make .
-.TP 0.5i
-.B \-d
-Print debugging information in addition to normal processing.
-The debugging information says which files are being considered for
-remaking, which file-times are being compared and with what results,
-which files actually need to be remade, which implicit rules are
-considered and which are applied---everything interesting about how
-.B make
-decides what to do.
-.TP 0.5i
-.BI \-\-debug "[=FLAGS]"
-Print debugging information in addition to normal processing.
-If the
-.I FLAGS
-are omitted, then the behavior is the same as if
-.B \-d
-was specified.
-.I FLAGS
-may be
-.I a
-for all debugging output (same as using
-.BR \-d ),
-.I b
-for basic debugging,
-.I v
-for more verbose basic debugging,
-.I i
-for showing implicit rules,
-.I j
-for details on invocation of commands, and
-.I m
-for debugging while remaking makefiles.  Use
-.I n
-to disable all previous debugging flags.
-.TP 0.5i
-\fB\-e\fR, \fB\-\-environment\-overrides\fR
-Give variables taken from the environment precedence over variables
-from makefiles.
-.TP 0.5i
-\fB\-E\fR \fIstring\fR, \fB\-\-eval\fR \fIstring\fR
-Interpret \fIstring\fR using the \fBeval\fR function, before parsing any
-makefiles.
-.TP 0.5i
-\fB\-f\fR \fIfile\fR, \fB\-\-file\fR=\fIfile\fR, \fB\-\-makefile\fR=\fIFILE\fR
-Use
-.I file
-as a makefile.
-.TP 0.5i
-\fB\-i\fR, \fB\-\-ignore\-errors\fR
-Ignore all errors in commands executed to remake files.
-.TP 0.5i
-\fB\-I\fR \fIdir\fR, \fB\-\-include\-dir\fR=\fIdir\fR
-Specifies a directory
-.I dir
-to search for included makefiles.
-If several
-.B \-I
-options are used to specify several directories, the directories are
-searched in the order specified.
-Unlike the arguments to other flags of
-.BR make ,
-directories given with
-.B \-I
-flags may come directly after the flag:
-.BI \-I dir
-is allowed, as well as
-.B \-I
-.IR dir .
-This syntax is allowed for compatibility with the C
-preprocessor's
-.B \-I
-flag.
-.TP 0.5i
-\fB\-j\fR [\fIjobs\fR], \fB\-\-jobs\fR[=\fIjobs\fR]
-Specifies the number of
-.I jobs
-(commands) to run simultaneously.
-If there is more than one
-.B \-j
-option, the last one is effective.
-If the
-.B \-j
-option is given without an argument,
-.BR make
-will not limit the number of jobs that can run simultaneously.
-.TP 0.5i
-\fB\-k\fR, \fB\-\-keep\-going\fR
-Continue as much as possible after an error.
-While the target that failed, and those that depend on it, cannot
-be remade, the other dependencies of these targets can be processed
-all the same.
-.TP 0.5i
-\fB\-l\fR [\fIload\fR], \fB\-\-load\-average\fR[=\fIload\fR]
-Specifies that no new jobs (commands) should be started if there are
-others jobs running and the load average is at least
-.I load
-(a floating-point number).
-With no argument, removes a previous load limit.
-.TP 0.5i
-\fB\-L\fR, \fB\-\-check\-symlink\-times\fR
-Use the latest mtime between symlinks and target.
-.TP 0.5i
-\fB\-n\fR, \fB\-\-just\-print\fR, \fB\-\-dry\-run\fR, \fB\-\-recon\fR
-Print the commands that would be executed, but do not execute them (except in
-certain circumstances).
-.TP 0.5i
-\fB\-o\fR \fIfile\fR, \fB\-\-old\-file\fR=\fIfile\fR, \fB\-\-assume\-old\fR=\fIfile\fR
-Do not remake the file
-.I file
-even if it is older than its dependencies, and do not remake anything
-on account of changes in
-.IR file .
-Essentially the file is treated as very old and its rules are ignored.
-.TP 0.5i
-\fB\-O\fR[\fItype\fR], \fB\-\-output\-sync\fR[=\fItype\fR]
-When running multiple jobs in parallel with \fB-j\fR, ensure the output of
-each job is collected together rather than interspersed with output from
-other jobs.  If
-.I type
-is not specified or is
-.B target
-the output from the entire recipe for each target is grouped together.  If
-.I type
-is
-.B line
-the output from each command line within a recipe is grouped together.
-If
-.I type
-is
-.B recurse
-output from an entire recursive make is grouped together.  If
-.I type
-is
-.B none
-output synchronization is disabled.
-.TP 0.5i
-\fB\-p\fR, \fB\-\-print\-data\-base\fR
-Print the data base (rules and variable values) that results from
-reading the makefiles; then execute as usual or as otherwise
-specified.
-This also prints the version information given by the
-.B \-v
-switch (see below).
-To print the data base without trying to remake any files, use
-.IR "make \-p \-f/dev/null" .
-.TP 0.5i
-\fB\-q\fR, \fB\-\-question\fR
-``Question mode''.
-Do not run any commands, or print anything; just return an exit status
-that is zero if the specified targets are already up to date, nonzero
-otherwise.
-.TP 0.5i
-\fB\-r\fR, \fB\-\-no\-builtin\-rules\fR
-Eliminate use of the built\-in implicit rules.
-Also clear out the default list of suffixes for suffix rules.
-.TP 0.5i
-\fB\-R\fR, \fB\-\-no\-builtin\-variables\fR
-Don't define any built\-in variables.
-.TP 0.5i
-\fB\-s\fR, \fB\-\-silent\fR, \fB\-\-quiet\fR
-Silent operation; do not print the commands as they are executed.
-.TP 0.5i
-.B \-\-no\-silent
-Cancel the effect of the \fB\-s\fR option.
-.TP 0.5i
-\fB\-S\fR, \fB\-\-no\-keep\-going\fR, \fB\-\-stop\fR
-Cancel the effect of the
-.B \-k
-option.
-.TP 0.5i
-\fB\-t\fR, \fB\-\-touch\fR
-Touch files (mark them up to date without really changing them)
-instead of running their commands.
-This is used to pretend that the commands were done, in order to fool
-future invocations of
-.BR make .
-.TP 0.5i
-.B \-\-trace
-Information about the disposition of each target is printed (why the target is
-being rebuilt and what commands are run to rebuild it).
-.TP 0.5i
-\fB\-v\fR, \fB\-\-version\fR
-Print the version of the
-.B make
-program plus a copyright, a list of authors and a notice that there
-is no warranty.
-.TP 0.5i
-\fB\-w\fR, \fB\-\-print\-directory\fR
-Print a message containing the working directory
-before and after other processing.
-This may be useful for tracking down errors from complicated nests of
-recursive
-.B make
-commands.
-.TP 0.5i
-.B \-\-no\-print\-directory
-Turn off
-.BR \-w ,
-even if it was turned on implicitly.
-.TP 0.5i
-\fB\-W\fR \fIfile\fR, \fB\-\-what\-if\fR=\fIfile\fR, \fB\-\-new\-file\fR=\fIfile\fR, \fB\-\-assume\-new\fR=\fIfile\fR
-Pretend that the target
-.I file
-has just been modified.
-When used with the
-.B \-n
-flag, this shows you what would happen if you were to modify that file.
-Without
-.BR \-n ,
-it is almost the same as running a
-.I touch
-command on the given file before running
-.BR make ,
-except that the modification time is changed only in the imagination of
-.BR make .
-.TP 0.5i
-.B \-\-warn\-undefined\-variables
-Warn when an undefined variable is referenced.
-.SH "EXIT STATUS"
-GNU
-.B make
-exits with a status of zero if all makefiles were successfully parsed
-and no targets that were built failed.  A status of one will be returned
-if the
-.B \-q
-flag was used and
-.B make
-determines that a target needs to be rebuilt.  A status of two will be
-returned if any errors were encountered.
-.SH "SEE ALSO"
-The full documentation for
-.B make
-is maintained as a Texinfo manual.  If the
-.B info
-and
-.B make
-programs are properly installed at your site, the command
-.IP
-.B info make
-.PP
-should give you access to the complete manual.
-.SH BUGS
-See the chapter ``Problems and Bugs'' in
-.IR "The GNU Make Manual" .
-.SH AUTHOR
-This manual page contributed by Dennis Morse of Stanford University.
-Further updates contributed by Mike Frysinger.  It has been reworked by Roland
-McGrath.  Maintained by Paul Smith.
-.SH "COPYRIGHT"
-Copyright \(co 1992-1993, 1996-2017 Free Software Foundation, Inc.
-This file is part of
-.IR "GNU make" .
-.LP
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-.LP
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-.LP
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see
-.IR http://www.gnu.org/licenses/ .
diff --git a/makefile.vms b/makefile.vms
deleted file mode 100644
index 6670a0b..0000000
--- a/makefile.vms
+++ /dev/null
@@ -1,180 +0,0 @@
-# -*-Makefile-*- to build GNU make on VMS
-#
-# Copyright (C) 1996-2017 Free Software Foundation, Inc.
-# This file is part of GNU Make.
-#
-# GNU Make is free software; you can redistribute it and/or modify it under
-# the terms of the GNU General Public License as published by the Free Software
-# Foundation; either version 3 of the License, or (at your option) any later
-# version.
-#
-# GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
-# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
-# details.
-#
-# You should have received a copy of the GNU General Public License along with
-# this program.  If not, see <http://www.gnu.org/licenses/>.
-
-# VMS extensions from GNU Make 3.60 imported by
-#  Klaus Kmpf (kkaempf@rmi.de)
-# Modified for version 3.78.1 by Hartmut.Becker@compaq.com.
-# Modified for version 3.80 by zinser@decus.de
-# Modified for versions 3.81, 3.99.90 by Hartmut Becker
-
-CC = cc
-CP = copy
-
-%.obj: %.c
-	$(CC) $(CFLAGS)/obj=$@ $<
-#
-#	Makefile for GNU Make
-#
-
-ifeq ($(CC),cc)
-cinclude = /nested=none/include=([],[.glob])
-cprefix = /prefix=(all,except=(glob,globfree))
-cwarn = /standard=relaxed/warn=(disable=questcompare)
-CFLAGS = $(defines) $(cinclude)$(cprefix)$(cwarn)
-else
-CFLAGS = $(defines) $(cinclude)
-endif
-#LDFLAGS = /deb
-LDFLAGS =
-
-ifeq ($(CC),cc)
-defines = /define=("unlink=remove","HAVE_CONFIG_H","VMS","allocated_variable_expand_for_file=alloc_var_expand_for_file")
-else
-ifeq ($(ARCH),VAX)
-defines = /define=("HAVE_CONFIG_H","GCC_IS_NATIVE","VAX")
-else
-defines = /define=("HAVE_CONFIG_H","GCC_IS_NATIVE")
-endif
-endif
-
-LOAD_AVG = /define="NO_LDAV"
-
-# If you don't want archive support, comment these out.
-ARCHIVES = ,ar.obj,arscan.obj
-ARCHIVES_SRC = ar.c arscan.c
-
-# If your system needs extra libraries loaded in, define them here.
-# System V probably need -lPW for alloca.
-# if on vax, uncomment the following line
-#LOADLIBES = ,c.opt/opt
-ifeq ($(CC),cc)
-#LOADLIBES =,sys$$library:vaxcrtl.olb/lib
-CRT0 =
-else
-LOADLIBES =,gnu_cc_library:libgcc.olb/lib
-endif
-
-# If your system doesn't have alloca, or the one provided is bad,
-# get it from the Emacs distribution and define these.
-#ALLOCA = ,alloca.obj
-#ALLOCASRC = alloca.c
-
-# If there are remote execution facilities defined,
-# enable them with switches here (see remote-*.c).
-REMOTE =
-
-# Any extra object files your system needs.
-extras = ,signame.obj,remote-stub.obj,vmsfunctions.obj,vmsify.obj
-#,directory.obj
-# as an alternative:
-glob = ,[.glob]glob.obj,[.glob]fnmatch.obj
-getopt = ,getopt.obj,getopt1.obj
-# Directory to install 'make' in.
-bindir = []
-# Directory to install the man page in.
-mandir = []
-# Number to put on the man page filename.
-manext = 1
-
-guile = ,guile.obj
-
-objs = commands.obj,job.obj,output.obj,dir.obj,file.obj,misc.obj,hash.obj,\
-       load.obj,main.obj,read.obj,remake.obj,rule.obj,implicit.obj,\
-       default.obj,variable.obj,expand.obj,function.obj,strcache.obj,\
-       vpath.obj,version.obj,vms_progname.obj,vms_exit.obj,\
-       vms_export_symbol.obj$(guile)$(ARCHIVES)$(extras)$(getopt)$(glob)
-
-srcs = commands.c job.c output.c dir.c file.c misc.c guile.c hash.c \
-	load.c main.c read.c remake.c rule.c implicit.c \
-	default.c variable.c expand.c function.c strcache.c \
-	vpath.c version.c vmsfunctions.c vmsify.c vms_progname.c vms_exit.c \
-	vms_export_symbol.c $(ARCHIVES_SRC) $(ALLOCASRC) \
-	commands.h dep.h filedef.h job.h output.h makeint.h rule.h variable.h
-
-
-.PHONY: all doc
-all: config.h make.exe
-
-doc: make.info make.dvi
-
-
-make.exe: $(objs)
-	$(LD)$(LDFLAGS)/exe=$@ $^$(LOADLIBES)$(CRT0)
-
-.PHONY: clean realclean
-clean:
-	-purge [...]
-	-$(RM) make.exe;,*.obj;
-	-$(RM) [.glob]*.obj;
-
-ar.obj: ar.c makeint.h config.h gnumake.h gettext.h filedef.h hash.h dep.h \
-     [.glob]fnmatch.h
-arscan.obj: arscan.c makeint.h config.h gnumake.h gettext.h
-commands.obj: commands.c makeint.h config.h gnumake.h gettext.h filedef.h \
-     hash.h dep.h variable.h job.h output.h commands.h
-default.obj: default.c makeint.h config.h gnumake.h gettext.h filedef.h \
-     hash.h variable.h rule.h dep.h job.h output.h commands.h
-dir.obj: dir.c makeint.h config.h gnumake.h gettext.h hash.h filedef.h \
-     dep.h [.glob]glob.h
-expand.obj: expand.c makeint.h config.h gnumake.h gettext.h filedef.h \
-     hash.h job.h output.h commands.h variable.h rule.h
-file.obj: file.c makeint.h config.h gnumake.h gettext.h filedef.h hash.h \
-     dep.h job.h output.h commands.h variable.h debug.h
-[.glob]fnmatch.obj: [.glob]fnmatch.c config.h [.glob]fnmatch.h
-function.obj: function.c makeint.h config.h gnumake.h gettext.h filedef.h \
-     hash.h variable.h dep.h job.h output.h commands.h debug.h
-getopt.obj: getopt.c config.h gettext.h getopt.h
-getopt1.obj: getopt1.c config.h getopt.h
-[.glob]glob.obj: [.glob]glob.c config.h [.glob]fnmatch.h [.glob]glob.h
-guile.obj: guile.c makeint.h config.h gnumake.h gettext.h
-hash.obj: hash.c makeint.h config.h gnumake.h gettext.h hash.h
-implicit.obj: implicit.c makeint.h config.h gnumake.h gettext.h filedef.h \
-     hash.h rule.h dep.h debug.h variable.h job.h output.h commands.h
-job.obj: job.c makeint.h config.h gnumake.h gettext.h job.h output.h debug.h \
-     filedef.h hash.h commands.h variable.h debug.h vmsjobs.c
-load.obj: load.c makeint.h config.h gnumake.h gettext.h
-main.obj: main.c makeint.h config.h gnumake.h gettext.h filedef.h hash.h \
-     dep.h variable.h job.h output.h commands.h rule.h debug.h getopt.h
-misc.obj: misc.c makeint.h config.h gnumake.h gettext.h filedef.h hash.h \
-     dep.h debug.h
-output.obj: output.c makeint.h config.h gnumake.h gettext.h job.h output.h
-read.obj: read.c makeint.h config.h gnumake.h gettext.h [.glob]glob.h \
-     filedef.h hash.h dep.h job.h output.h commands.h variable.h rule.h \
-     debug.h
-remake.obj: remake.c makeint.h config.h gnumake.h gettext.h filedef.h \
-     hash.h job.h output.h commands.h dep.h variable.h debug.h
-remote-stub.obj: remote-stub.c makeint.h config.h gnumake.h gettext.h \
-     filedef.h hash.h job.h output.h commands.h
-rule.obj: rule.c makeint.h config.h gnumake.h gettext.h filedef.h hash.h \
-     dep.h job.h output.h commands.h variable.h rule.h
-signame.obj: signame.c makeint.h config.h gnumake.h gettext.h
-strcache.obj: strcache.c makeint.h config.h gnumake.h gettext.h hash.h
-variable.obj: variable.c makeint.h config.h gnumake.h gettext.h filedef.h \
-     hash.h dep.h job.h output.h commands.h variable.h rule.h
-version.obj: version.c config.h
-vmsfunctions.obj: vmsfunctions.c makeint.h config.h gnumake.h gettext.h \
-     debug.h job.h output.h vmsdir.h
-vmsify.obj: vmsify.c
-vpath.obj: vpath.c makeint.h config.h gnumake.h gettext.h filedef.h hash.h \
-     variable.h
-vms_progname.obj: vms_progname.c
-vms_exit.obj: vms_exit.c
-vms_export_symbol.obj: vms_export_symbol.c
-
-config.h: config.h-vms
-	$(CP) $< $@
diff --git a/makeint.h b/makeint.h
deleted file mode 100644
index 2adab63..0000000
--- a/makeint.h
+++ /dev/null
@@ -1,794 +0,0 @@
-/* Miscellaneous global declarations and portability cruft for GNU Make.
-Copyright (C) 1988-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-/* We use <config.h> instead of "config.h" so that a compilation
-   using -I. -I$srcdir will use ./config.h rather than $srcdir/config.h
-   (which it would do because makeint.h was found in $srcdir).  */
-#include <config.h>
-#undef  HAVE_CONFIG_H
-#define HAVE_CONFIG_H 1
-
-/* Specify we want GNU source code.  This must be defined before any
-   system headers are included.  */
-
-#define _GNU_SOURCE 1
-
-/* AIX requires this to be the first thing in the file.  */
-#if HAVE_ALLOCA_H
-# include <alloca.h>
-#else
-# ifdef _AIX
- #pragma alloca
-# else
-#  if !defined(__GNUC__) && !defined(WINDOWS32)
-#   ifndef alloca /* predefined by HP cc +Olibcalls */
-char *alloca ();
-#   endif
-#  endif
-# endif
-#endif
-
-/* Disable assert() unless we're a maintainer.
-   Some asserts are compute-intensive.  */
-#ifndef MAKE_MAINTAINER_MODE
-# define NDEBUG 1
-#endif
-
-/* Include the externally-visible content.
-   Be sure to use the local one, and not one installed on the system.
-   Define GMK_BUILDING_MAKE for proper selection of dllexport/dllimport
-   declarations for MS-Windows.  */
-#ifdef WINDOWS32
-# define GMK_BUILDING_MAKE
-#endif
-#include "gnumake.h"
-
-#ifdef  CRAY
-/* This must happen before #include <signal.h> so
-   that the declaration therein is changed.  */
-# define signal bsdsignal
-#endif
-
-/* If we're compiling for the dmalloc debugger, turn off string inlining.  */
-#if defined(HAVE_DMALLOC_H) && defined(__GNUC__)
-# define __NO_STRING_INLINES
-#endif
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <signal.h>
-#include <stdio.h>
-#include <ctype.h>
-
-#ifdef HAVE_SYS_TIMEB_H
-/* SCO 3.2 "devsys 4.2" has a prototype for 'ftime' in <time.h> that bombs
-   unless <sys/timeb.h> has been included first.  */
-# include <sys/timeb.h>
-#endif
-#if TIME_WITH_SYS_TIME
-# include <sys/time.h>
-# include <time.h>
-#else
-# if HAVE_SYS_TIME_H
-#  include <sys/time.h>
-# else
-#  include <time.h>
-# endif
-#endif
-
-#include <errno.h>
-
-#ifndef errno
-extern int errno;
-#endif
-
-#ifdef __VMS
-/* In strict ANSI mode, VMS compilers should not be defining the
-   VMS macro.  Define it here instead of a bulk edit for the correct code.
- */
-# ifndef VMS
-#  define VMS
-# endif
-#endif
-
-#ifdef  HAVE_UNISTD_H
-# include <unistd.h>
-/* Ultrix's unistd.h always defines _POSIX_VERSION, but you only get
-   POSIX.1 behavior with 'cc -YPOSIX', which predefines POSIX itself!  */
-# if defined (_POSIX_VERSION) && !defined (ultrix) && !defined (VMS)
-#  define POSIX 1
-# endif
-#endif
-
-/* Some systems define _POSIX_VERSION but are not really POSIX.1.  */
-#if (defined (butterfly) || defined (__arm) || (defined (__mips) && defined (_SYSTYPE_SVR3)) || (defined (sequent) && defined (i386)))
-# undef POSIX
-#endif
-
-#if !defined (POSIX) && defined (_AIX) && defined (_POSIX_SOURCE)
-# define POSIX 1
-#endif
-
-#ifndef RETSIGTYPE
-# define RETSIGTYPE     void
-#endif
-
-#ifndef sigmask
-# define sigmask(sig)   (1 << ((sig) - 1))
-#endif
-
-#ifndef HAVE_SA_RESTART
-# define SA_RESTART 0
-#endif
-
-#ifdef HAVE_VFORK_H
-# include <vfork.h>
-#endif
-
-#ifdef  HAVE_LIMITS_H
-# include <limits.h>
-#endif
-#ifdef  HAVE_SYS_PARAM_H
-# include <sys/param.h>
-#endif
-
-#ifndef PATH_MAX
-# ifndef POSIX
-#  define PATH_MAX      MAXPATHLEN
-# endif
-#endif
-#ifndef MAXPATHLEN
-# define MAXPATHLEN 1024
-#endif
-
-#ifdef  PATH_MAX
-# define GET_PATH_MAX   PATH_MAX
-# define PATH_VAR(var)  char var[PATH_MAX+1]
-#else
-# define NEED_GET_PATH_MAX 1
-# define GET_PATH_MAX   (get_path_max ())
-# define PATH_VAR(var)  char *var = alloca (GET_PATH_MAX+1)
-unsigned int get_path_max (void);
-#endif
-
-#ifndef CHAR_BIT
-# define CHAR_BIT 8
-#endif
-
-#ifndef USHRT_MAX
-# define USHRT_MAX 65535
-#endif
-
-/* Nonzero if the integer type T is signed.
-   Use <= to avoid GCC warnings about always-false expressions.  */
-#define INTEGER_TYPE_SIGNED(t) ((t) -1 <= 0)
-
-/* The minimum and maximum values for the integer type T.
-   Use ~ (t) 0, not -1, for portability to 1's complement hosts.  */
-#define INTEGER_TYPE_MINIMUM(t) \
-  (! INTEGER_TYPE_SIGNED (t) ? (t) 0 : ~ (t) 0 << (sizeof (t) * CHAR_BIT - 1))
-#define INTEGER_TYPE_MAXIMUM(t) (~ (t) 0 - INTEGER_TYPE_MINIMUM (t))
-
-#ifndef CHAR_MAX
-# define CHAR_MAX INTEGER_TYPE_MAXIMUM (char)
-#endif
-
-#ifdef STAT_MACROS_BROKEN
-# ifdef S_ISREG
-#  undef S_ISREG
-# endif
-# ifdef S_ISDIR
-#  undef S_ISDIR
-# endif
-#endif  /* STAT_MACROS_BROKEN.  */
-
-#ifndef S_ISREG
-# define S_ISREG(mode)  (((mode) & S_IFMT) == S_IFREG)
-#endif
-#ifndef S_ISDIR
-# define S_ISDIR(mode)  (((mode) & S_IFMT) == S_IFDIR)
-#endif
-
-#ifdef VMS
-# include <fcntl.h>
-# include <types.h>
-# include <unixlib.h>
-# include <unixio.h>
-# include <perror.h>
-/* Needed to use alloca on VMS.  */
-# include <builtins.h>
-
-extern int vms_use_mcr_command;
-extern int vms_always_use_cmd_file;
-extern int vms_gnv_shell;
-extern int vms_comma_separator;
-extern int vms_legacy_behavior;
-extern int vms_unix_simulation;
-#endif
-
-#ifndef __attribute__
-/* This feature is available in gcc versions 2.5 and later.  */
-# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 5) || __STRICT_ANSI__
-#  define __attribute__(x)
-# endif
-/* The __-protected variants of 'format' and 'printf' attributes
-   are accepted by gcc versions 2.6.4 (effectively 2.7) and later.  */
-# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7)
-#  define __format__ format
-#  define __printf__ printf
-# endif
-#endif
-#define UNUSED  __attribute__ ((unused))
-
-#if defined (STDC_HEADERS) || defined (__GNU_LIBRARY__)
-# include <stdlib.h>
-# include <string.h>
-# define ANSI_STRING 1
-#else   /* No standard headers.  */
-# ifdef HAVE_STRING_H
-#  include <string.h>
-#  define ANSI_STRING 1
-# else
-#  include <strings.h>
-# endif
-# ifdef HAVE_MEMORY_H
-#  include <memory.h>
-# endif
-# ifdef HAVE_STDLIB_H
-#  include <stdlib.h>
-# else
-void *malloc (int);
-void *realloc (void *, int);
-void free (void *);
-
-void abort (void) __attribute__ ((noreturn));
-void exit (int) __attribute__ ((noreturn));
-# endif /* HAVE_STDLIB_H.  */
-
-#endif /* Standard headers.  */
-
-/* These should be in stdlib.h.  Make sure we have them.  */
-#ifndef EXIT_SUCCESS
-# define EXIT_SUCCESS 0
-#endif
-#ifndef EXIT_FAILURE
-# define EXIT_FAILURE 1
-#endif
-
-#ifndef  ANSI_STRING
-
-/* SCO Xenix has a buggy macro definition in <string.h>.  */
-#undef  strerror
-#if !defined(__DECC)
-char *strerror (int errnum);
-#endif
-
-#endif  /* !ANSI_STRING.  */
-#undef  ANSI_STRING
-
-#if HAVE_INTTYPES_H
-# include <inttypes.h>
-#endif
-#if HAVE_STDINT_H
-# include <stdint.h>
-#endif
-#define FILE_TIMESTAMP uintmax_t
-
-#if !defined(HAVE_STRSIGNAL)
-char *strsignal (int signum);
-#endif
-
-#if defined(HAVE_UMASK)
-# define UMASK(_m)  umask (_m)
-# define MODE_T     mode_t
-#else
-# define UMASK(_m)  0
-# define MODE_T     int
-#endif
-
-/* ISDIGIT offers the following features:
-   - Its arg may be any int or unsigned int; it need not be an unsigned char.
-   - It's guaranteed to evaluate its argument exactly once.
-      NOTE!  Make relies on this behavior, don't change it!
-   - It's typically faster.
-   POSIX 1003.2-1992 section 2.5.2.1 page 50 lines 1556-1558 says that
-   only '0' through '9' are digits.  Prefer ISDIGIT to isdigit() unless
-   it's important to use the locale's definition of 'digit' even when the
-   host does not conform to POSIX.  */
-#define ISDIGIT(c) ((unsigned) (c) - '0' <= 9)
-
-/* Test if two strings are equal. Is this worthwhile?  Should be profiled.  */
-#define streq(a, b) \
-   ((a) == (b) || \
-    (*(a) == *(b) && (*(a) == '\0' || !strcmp ((a) + 1, (b) + 1))))
-
-/* Test if two strings are equal, but match case-insensitively on systems
-   which have case-insensitive filesystems.  Should only be used for
-   filenames!  */
-#ifdef HAVE_CASE_INSENSITIVE_FS
-# define patheq(a, b) \
-    ((a) == (b) \
-     || (tolower((unsigned char)*(a)) == tolower((unsigned char)*(b)) \
-         && (*(a) == '\0' || !strcasecmp ((a) + 1, (b) + 1))))
-#else
-# define patheq(a, b) streq(a, b)
-#endif
-
-#define strneq(a, b, l) (strncmp ((a), (b), (l)) == 0)
-
-#if defined(__GNUC__) || defined(ENUM_BITFIELDS)
-# define ENUM_BITFIELD(bits)    :bits
-#else
-# define ENUM_BITFIELD(bits)
-#endif
-
-/* Handle gettext and locales.  */
-
-#if HAVE_LOCALE_H
-# include <locale.h>
-#else
-# define setlocale(category, locale)
-#endif
-
-#include <gettext.h>
-
-#define _(msgid)            gettext (msgid)
-#define N_(msgid)           gettext_noop (msgid)
-#define S_(msg1,msg2,num)   ngettext (msg1,msg2,num)
-
-/* This is needed for getcwd() and chdir(), on some W32 systems.  */
-#if defined(HAVE_DIRECT_H)
-# include <direct.h>
-#endif
-
-#ifdef WINDOWS32
-# include <fcntl.h>
-# include <malloc.h>
-# define pipe(_p)        _pipe((_p), 512, O_BINARY)
-# define kill(_pid,_sig) w32_kill((_pid),(_sig))
-/* MSVC and Watcom C don't have ftruncate.  */
-# if defined(_MSC_VER) || defined(__WATCOMC__)
-#  define ftruncate(_fd,_len) _chsize(_fd,_len)
-# endif
-/* MinGW64 doesn't have _S_ISDIR.  */
-# ifndef _S_ISDIR
-#  define _S_ISDIR(m)  S_ISDIR(m)
-# endif
-
-void sync_Path_environment (void);
-int w32_kill (pid_t pid, int sig);
-int find_and_set_default_shell (const char *token);
-
-/* indicates whether or not we have Bourne shell */
-extern int no_default_sh_exe;
-
-/* is default_shell unixy? */
-extern int unixy_shell;
-
-/* We don't have a preferred fixed value for LOCALEDIR.  */
-# ifndef LOCALEDIR
-#  define LOCALEDIR NULL
-# endif
-
-/* Include only the minimal stuff from windows.h.   */
-# define WIN32_LEAN_AND_MEAN
-#endif  /* WINDOWS32 */
-
-#define ANY_SET(_v,_m)  (((_v)&(_m)) != 0)
-#define NONE_SET(_v,_m) (! ANY_SET ((_v),(_m)))
-
-#define MAP_NUL         0x0001
-#define MAP_BLANK       0x0002
-#define MAP_NEWLINE     0x0004
-#define MAP_COMMENT     0x0008
-#define MAP_SEMI        0x0010
-#define MAP_EQUALS      0x0020
-#define MAP_COLON       0x0040
-#define MAP_VARSEP      0x0080
-#define MAP_PIPE        0x0100
-#define MAP_DOT         0x0200
-#define MAP_COMMA       0x0400
-
-/* These are the valid characters for a user-defined function.  */
-#define MAP_USERFUNC    0x2000
-/* This means not only a '$', but skip the variable reference.  */
-#define MAP_VARIABLE    0x4000
-/* The set of characters which are directory separators is OS-specific.  */
-#define MAP_DIRSEP      0x8000
-
-#ifdef VMS
-# define MAP_VMSCOMMA   MAP_COMMA
-#else
-# define MAP_VMSCOMMA   0x0000
-#endif
-
-#define MAP_SPACE       (MAP_BLANK|MAP_NEWLINE)
-
-/* Handle other OSs.
-   To overcome an issue parsing paths in a DOS/Windows environment when
-   built in a unix based environment, override the PATH_SEPARATOR_CHAR
-   definition unless being built for Cygwin. */
-#if defined(HAVE_DOS_PATHS) && !defined(__CYGWIN__)
-# undef PATH_SEPARATOR_CHAR
-# define PATH_SEPARATOR_CHAR ';'
-# define MAP_PATHSEP    MAP_SEMI
-#elif !defined(PATH_SEPARATOR_CHAR)
-# if defined (VMS)
-#  define PATH_SEPARATOR_CHAR (vms_comma_separator ? ',' : ':')
-#  define MAP_PATHSEP    (vms_comma_separator ? MAP_COMMA : MAP_SEMI)
-# else
-#  define PATH_SEPARATOR_CHAR ':'
-#  define MAP_PATHSEP    MAP_COLON
-# endif
-#elif PATH_SEPARATOR_CHAR == ':'
-# define MAP_PATHSEP     MAP_COLON
-#elif PATH_SEPARATOR_CHAR == ';'
-# define MAP_PATHSEP     MAP_SEMI
-#elif PATH_SEPARATOR_CHAR == ','
-# define MAP_PATHSEP     MAP_COMMA
-#else
-# error "Unknown PATH_SEPARATOR_CHAR"
-#endif
-
-#define STOP_SET(_v,_m) ANY_SET(stopchar_map[(unsigned char)(_v)],(_m))
-
-#define ISBLANK(c)      STOP_SET((c),MAP_BLANK)
-#define ISSPACE(c)      STOP_SET((c),MAP_SPACE)
-#define NEXT_TOKEN(s)   while (ISSPACE (*(s))) ++(s)
-#define END_OF_TOKEN(s) while (! STOP_SET (*(s), MAP_SPACE|MAP_NUL)) ++(s)
-
-#if defined(HAVE_SYS_RESOURCE_H) && defined(HAVE_GETRLIMIT) && defined(HAVE_SETRLIMIT)
-# define SET_STACK_SIZE
-#endif
-#ifdef SET_STACK_SIZE
-# include <sys/resource.h>
-extern struct rlimit stack_limit;
-#endif
-
-#include <glob.h>
-
-#define NILF ((floc *)0)
-
-#define CSTRLEN(_s)           (sizeof (_s)-1)
-#define STRING_SIZE_TUPLE(_s) (_s), CSTRLEN(_s)
-
-/* The number of bytes needed to represent the largest integer as a string.  */
-#define INTSTR_LENGTH         CSTRLEN ("18446744073709551616")
-
-#define DEFAULT_TTYNAME "true"
-#ifdef HAVE_TTYNAME
-# define TTYNAME(_f) ttyname (_f)
-#else
-# define TTYNAME(_f) DEFAULT_TTYNAME
-#endif
-
-
-
-/* Specify the location of elements read from makefiles.  */
-typedef struct
-  {
-    const char *filenm;
-    unsigned long lineno;
-    unsigned long offset;
-  } floc;
-
-const char *concat (unsigned int, ...);
-void message (int prefix, size_t length, const char *fmt, ...)
-              __attribute__ ((__format__ (__printf__, 3, 4)));
-void error (const floc *flocp, size_t length, const char *fmt, ...)
-            __attribute__ ((__format__ (__printf__, 3, 4)));
-void fatal (const floc *flocp, size_t length, const char *fmt, ...)
-            __attribute__ ((noreturn, __format__ (__printf__, 3, 4)));
-void out_of_memory () __attribute__((noreturn));
-
-/* When adding macros to this list be sure to update the value of
-   XGETTEXT_OPTIONS in the po/Makevars file.  */
-#define O(_t,_a,_f)           _t((_a), 0, (_f))
-#define OS(_t,_a,_f,_s)       _t((_a), strlen (_s), (_f), (_s))
-#define OSS(_t,_a,_f,_s1,_s2) _t((_a), strlen (_s1) + strlen (_s2), \
-                                 (_f), (_s1), (_s2))
-#define OSSS(_t,_a,_f,_s1,_s2,_s3) _t((_a), strlen (_s1) + strlen (_s2) + strlen (_s3), \
-                                      (_f), (_s1), (_s2), (_s3))
-#define ON(_t,_a,_f,_n)       _t((_a), INTSTR_LENGTH, (_f), (_n))
-#define ONN(_t,_a,_f,_n1,_n2) _t((_a), INTSTR_LENGTH*2, (_f), (_n1), (_n2))
-
-#define OSN(_t,_a,_f,_s,_n)   _t((_a), strlen (_s) + INTSTR_LENGTH, \
-                                 (_f), (_s), (_n))
-#define ONS(_t,_a,_f,_n,_s)   _t((_a), INTSTR_LENGTH + strlen (_s), \
-                                 (_f), (_n), (_s))
-
-void die (int) __attribute__ ((noreturn));
-void pfatal_with_name (const char *) __attribute__ ((noreturn));
-void perror_with_name (const char *, const char *);
-#define xstrlen(_s) ((_s)==NULL ? 0 : strlen (_s))
-void *xmalloc (unsigned int);
-void *xcalloc (unsigned int);
-void *xrealloc (void *, unsigned int);
-char *xstrdup (const char *);
-char *xstrndup (const char *, unsigned int);
-char *find_next_token (const char **, unsigned int *);
-char *next_token (const char *);
-char *end_of_token (const char *);
-void collapse_continuations (char *);
-char *lindex (const char *, const char *, int);
-int alpha_compare (const void *, const void *);
-void print_spaces (unsigned int);
-char *find_percent (char *);
-const char *find_percent_cached (const char **);
-FILE *get_tmpfile (char **, const char *);
-
-#ifndef NO_ARCHIVES
-int ar_name (const char *);
-void ar_parse_name (const char *, char **, char **);
-int ar_touch (const char *);
-time_t ar_member_date (const char *);
-
-typedef long int (*ar_member_func_t) (int desc, const char *mem, int truncated,
-                                      long int hdrpos, long int datapos,
-                                      long int size, long int date, int uid,
-                                      int gid, unsigned int mode,
-                                      const void *arg);
-
-long int ar_scan (const char *archive, ar_member_func_t function, const void *arg);
-int ar_name_equal (const char *name, const char *mem, int truncated);
-#ifndef VMS
-int ar_member_touch (const char *arname, const char *memname);
-#endif
-#endif
-
-int dir_file_exists_p (const char *, const char *);
-int file_exists_p (const char *);
-int file_impossible_p (const char *);
-void file_impossible (const char *);
-const char *dir_name (const char *);
-void print_dir_data_base (void);
-void dir_setup_glob (glob_t *);
-void hash_init_directories (void);
-
-void define_default_variables (void);
-void undefine_default_variables (void);
-void set_default_suffixes (void);
-void install_default_suffix_rules (void);
-void install_default_implicit_rules (void);
-
-void build_vpath_lists (void);
-void construct_vpath_list (char *pattern, char *dirpath);
-const char *vpath_search (const char *file, FILE_TIMESTAMP *mtime_ptr,
-                          unsigned int* vpath_index, unsigned int* path_index);
-int gpath_search (const char *file, unsigned int len);
-
-void construct_include_path (const char **arg_dirs);
-
-void user_access (void);
-void make_access (void);
-void child_access (void);
-
-char *strip_whitespace (const char **begpp, const char **endpp);
-
-void show_goal_error (void);
-
-/* String caching  */
-void strcache_init (void);
-void strcache_print_stats (const char *prefix);
-int strcache_iscached (const char *str);
-const char *strcache_add (const char *str);
-const char *strcache_add_len (const char *str, unsigned int len);
-
-/* Guile support  */
-int guile_gmake_setup (const floc *flocp);
-
-/* Loadable object support.  Sets to the strcached name of the loaded file.  */
-typedef int (*load_func_t)(const floc *flocp);
-int load_file (const floc *flocp, const char **filename, int noerror);
-void unload_file (const char *name);
-
-/* We omit these declarations on non-POSIX systems which define _POSIX_VERSION,
-   because such systems often declare them in header files anyway.  */
-
-#if !defined (__GNU_LIBRARY__) && !defined (POSIX) && !defined (_POSIX_VERSION) && !defined(WINDOWS32)
-
-long int atol ();
-# ifndef VMS
-long int lseek ();
-# endif
-
-# ifdef  HAVE_GETCWD
-#  if !defined(VMS) && !defined(__DECC)
-char *getcwd ();
-#  endif
-# else
-char *getwd ();
-#  define getcwd(buf, len)       getwd (buf)
-# endif
-
-#endif  /* Not GNU C library or POSIX.  */
-
-#if !HAVE_STRCASECMP
-# if HAVE_STRICMP
-#  define strcasecmp stricmp
-# elif HAVE_STRCMPI
-#  define strcasecmp strcmpi
-# else
-/* Create our own, in misc.c */
-int strcasecmp (const char *s1, const char *s2);
-# endif
-#endif
-
-#if !HAVE_STRNCASECMP
-# if HAVE_STRNICMP
-#  define strncasecmp strnicmp
-# elif HAVE_STRNCMPI
-#  define strncasecmp strncmpi
-# else
-/* Create our own, in misc.c */
-int strncasecmp (const char *s1, const char *s2, int n);
-# endif
-#endif
-
-#define OUTPUT_SYNC_NONE    0
-#define OUTPUT_SYNC_LINE    1
-#define OUTPUT_SYNC_TARGET  2
-#define OUTPUT_SYNC_RECURSE 3
-
-/* Non-GNU systems may not declare this in unistd.h.  */
-extern char **environ;
-
-extern const floc *reading_file;
-extern const floc **expanding_var;
-
-extern unsigned short stopchar_map[];
-
-extern int just_print_flag, silent_flag, ignore_errors_flag, keep_going_flag;
-extern int print_data_base_flag, question_flag, touch_flag, always_make_flag;
-extern int env_overrides, no_builtin_rules_flag, no_builtin_variables_flag;
-extern int print_version_flag, print_directory_flag, check_symlink_flag;
-extern int warn_undefined_variables_flag, trace_flag, posix_pedantic;
-extern int not_parallel, second_expansion, clock_skew_detected;
-extern int rebuilding_makefiles, one_shell, output_sync, verify_flag;
-
-extern const char *default_shell;
-
-/* can we run commands via 'sh -c xxx' or must we use batch files? */
-extern int batch_mode_shell;
-
-/* Resetting the command script introduction prefix character.  */
-#define RECIPEPREFIX_NAME          ".RECIPEPREFIX"
-#define RECIPEPREFIX_DEFAULT       '\t'
-extern char cmd_prefix;
-
-extern unsigned int job_slots;
-extern double max_load_average;
-
-extern const char *program;
-
-#ifdef VMS
-const char *vms_command (const char *argv0);
-const char *vms_progname (const char *argv0);
-
-void vms_exit (int);
-# define _exit(foo) vms_exit(foo)
-# define exit(foo) vms_exit(foo)
-
-extern char *program_name;
-
-void
-set_program_name (const char *arv0);
-
-int
-need_vms_symbol (void);
-
-int
-create_foreign_command (const char *command, const char *image);
-
-int
-vms_export_dcl_symbol (const char *name, const char *value);
-
-int
-vms_putenv_symbol (const char *string);
-
-void
-vms_restore_symbol (const char *string);
-
-#endif
-
-void remote_setup (void);
-void remote_cleanup (void);
-int start_remote_job_p (int);
-int start_remote_job (char **, char **, int, int *, int *, int *);
-int remote_status (int *, int *, int *, int);
-void block_remote_children (void);
-void unblock_remote_children (void);
-int remote_kill (int id, int sig);
-void print_variable_data_base (void);
-void print_vpath_data_base (void);
-
-extern char *starting_directory;
-extern unsigned int makelevel;
-extern char *version_string, *remote_description, *make_host;
-
-extern unsigned int commands_started;
-
-extern int handling_fatal_signal;
-
-
-#ifndef MIN
-#define MIN(_a,_b) ((_a)<(_b)?(_a):(_b))
-#endif
-#ifndef MAX
-#define MAX(_a,_b) ((_a)>(_b)?(_a):(_b))
-#endif
-
-
-#define MAKE_SUCCESS 0
-#define MAKE_TROUBLE 1
-#define MAKE_FAILURE 2
-
-/* Set up heap debugging library dmalloc.  */
-
-#ifdef HAVE_DMALLOC_H
-#include <dmalloc.h>
-#endif
-
-#ifndef initialize_main
-# ifdef __EMX__
-#  define initialize_main(pargc, pargv) \
-                          { _wildcard(pargc, pargv); _response(pargc, pargv); }
-# else
-#  define initialize_main(pargc, pargv)
-# endif
-#endif
-
-#ifdef __EMX__
-# if !defined chdir
-#  define chdir _chdir2
-# endif
-# if !defined getcwd
-#  define getcwd _getcwd2
-# endif
-
-/* NO_CHDIR2 causes make not to use _chdir2() and _getcwd2() instead of
-   chdir() and getcwd(). This avoids some error messages for the
-   make testsuite but restricts the drive letter support. */
-# ifdef NO_CHDIR2
-#  warning NO_CHDIR2: usage of drive letters restricted
-#  undef chdir
-#  undef getcwd
-# endif
-#endif
-
-#ifndef initialize_main
-# define initialize_main(pargc, pargv)
-#endif
-
-
-/* Some systems (like Solaris, PTX, etc.) do not support the SA_RESTART flag
-   properly according to POSIX.  So, we try to wrap common system calls with
-   checks for EINTR.  Note that there are still plenty of system calls that
-   can fail with EINTR but this, reportedly, gets the vast majority of
-   failure cases.  If you still experience failures you'll need to either get
-   a system where SA_RESTART works, or you need to avoid -j.  */
-
-#define EINTRLOOP(_v,_c)   while (((_v)=_c)==-1 && errno==EINTR)
-
-/* While system calls that return integers are pretty consistent about
-   returning -1 on failure and setting errno in that case, functions that
-   return pointers are not always so well behaved.  Sometimes they return
-   NULL for expected behavior: one good example is readdir() which returns
-   NULL at the end of the directory--and _doesn't_ reset errno.  So, we have
-   to do it ourselves here.  */
-
-#define ENULLLOOP(_v,_c)   do { errno = 0; (_v) = _c; } \
-                           while((_v)==0 && errno==EINTR)
diff --git a/misc.c b/misc.c
deleted file mode 100644
index 441db8d..0000000
--- a/misc.c
+++ /dev/null
@@ -1,761 +0,0 @@
-/* Miscellaneous generic support functions for GNU Make.
-Copyright (C) 1988-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-#include "filedef.h"
-#include "dep.h"
-#include "debug.h"
-
-/* GNU make no longer supports pre-ANSI89 environments.  */
-
-#include <stdarg.h>
-
-#ifdef WINDOWS32
-# include <io.h>
-#endif
-
-#ifdef HAVE_FCNTL_H
-# include <fcntl.h>
-#else
-# include <sys/file.h>
-#endif
-
-/* Compare strings *S1 and *S2.
-   Return negative if the first is less, positive if it is greater,
-   zero if they are equal.  */
-
-int
-alpha_compare (const void *v1, const void *v2)
-{
-  const char *s1 = *((char **)v1);
-  const char *s2 = *((char **)v2);
-
-  if (*s1 != *s2)
-    return *s1 - *s2;
-  return strcmp (s1, s2);
-}
-
-/* Discard each backslash-newline combination from LINE.
-   Backslash-backslash-newline combinations become backslash-newlines.
-   This is done by copying the text at LINE into itself.  */
-
-void
-collapse_continuations (char *line)
-{
-  char *out = line;
-  char *in = line;
-  char *q;
-
-  q = strchr(in, '\n');
-  if (q == 0)
-    return;
-
-  do
-    {
-      char *p = q;
-      int i;
-      int out_line_length;
-
-      if (q > line && q[-1] == '\\')
-        {
-          /* Search for more backslashes.  */
-          i = -2;
-          while (&p[i] >= line && p[i] == '\\')
-            --i;
-          ++i;
-        }
-      else
-        i = 0;
-
-      /* The number of backslashes is now -I, keep half of them.  */
-      out_line_length = (p - in) + i - i/2;
-      if (out != in)
-        memmove (out, in, out_line_length);
-      out += out_line_length;
-
-      /* When advancing IN, skip the newline too.  */
-      in = q + 1;
-
-      if (i & 1)
-        {
-          /* Backslash/newline handling:
-             In traditional GNU make all trailing whitespace, consecutive
-             backslash/newlines, and any leading non-newline whitespace on the
-             next line is reduced to a single space.
-             In POSIX, each backslash/newline and is replaced by a space.  */
-          while (ISBLANK (*in))
-            ++in;
-          if (! posix_pedantic)
-            while (out > line && ISBLANK (out[-1]))
-              --out;
-          *out++ = ' ';
-        }
-      else
-        {
-          /* If the newline isn't quoted, put it in the output.  */
-          *out++ = '\n';
-        }
-
-      q = strchr(in, '\n');
-    }
-  while (q);
-
-  memmove(out, in, strlen(in) + 1);
-}
-
-/* Print N spaces (used in debug for target-depth).  */
-
-void
-print_spaces (unsigned int n)
-{
-  while (n-- > 0)
-    putchar (' ');
-}
-
-
-/* Return a string whose contents concatenate the NUM strings provided
-   This string lives in static, re-used memory.  */
-
-const char *
-concat (unsigned int num, ...)
-{
-  static unsigned int rlen = 0;
-  static char *result = NULL;
-  unsigned int ri = 0;
-  va_list args;
-
-  va_start (args, num);
-
-  while (num-- > 0)
-    {
-      const char *s = va_arg (args, const char *);
-      unsigned int l = xstrlen (s);
-
-      if (l == 0)
-        continue;
-
-      if (ri + l > rlen)
-        {
-          rlen = ((rlen ? rlen : 60) + l) * 2;
-          result = xrealloc (result, rlen);
-        }
-
-      memcpy (result + ri, s, l);
-      ri += l;
-    }
-
-  va_end (args);
-
-  /* Get some more memory if we don't have enough space for the
-     terminating '\0'.   */
-  if (ri == rlen)
-    {
-      rlen = (rlen ? rlen : 60) * 2;
-      result = xrealloc (result, rlen);
-    }
-
-  result[ri] = '\0';
-
-  return result;
-}
-
-
-#ifndef HAVE_STRERROR
-#undef  strerror
-char *
-strerror (int errnum)
-{
-  extern int errno, sys_nerr;
-#ifndef __DECC
-  extern char *sys_errlist[];
-#endif
-  static char buf[] = "Unknown error 12345678901234567890";
-
-  if (errno < sys_nerr)
-    return sys_errlist[errnum];
-
-  sprintf (buf, _("Unknown error %d"), errnum);
-  return buf;
-}
-#endif
-
-/* Like malloc but get fatal error if memory is exhausted.  */
-/* Don't bother if we're using dmalloc; it provides these for us.  */
-
-#ifndef HAVE_DMALLOC_H
-
-#undef xmalloc
-#undef xcalloc
-#undef xrealloc
-#undef xstrdup
-
-void *
-xmalloc (unsigned int size)
-{
-  /* Make sure we don't allocate 0, for pre-ISO implementations.  */
-  void *result = malloc (size ? size : 1);
-  if (result == 0)
-    out_of_memory ();
-  return result;
-}
-
-
-void *
-xcalloc (unsigned int size)
-{
-  /* Make sure we don't allocate 0, for pre-ISO implementations.  */
-  void *result = calloc (size ? size : 1, 1);
-  if (result == 0)
-    out_of_memory ();
-  return result;
-}
-
-
-void *
-xrealloc (void *ptr, unsigned int size)
-{
-  void *result;
-
-  /* Some older implementations of realloc() don't conform to ISO.  */
-  if (! size)
-    size = 1;
-  result = ptr ? realloc (ptr, size) : malloc (size);
-  if (result == 0)
-    out_of_memory ();
-  return result;
-}
-
-
-char *
-xstrdup (const char *ptr)
-{
-  char *result;
-
-#ifdef HAVE_STRDUP
-  result = strdup (ptr);
-#else
-  result = malloc (strlen (ptr) + 1);
-#endif
-
-  if (result == 0)
-    out_of_memory ();
-
-#ifdef HAVE_STRDUP
-  return result;
-#else
-  return strcpy (result, ptr);
-#endif
-}
-
-#endif  /* HAVE_DMALLOC_H */
-
-char *
-xstrndup (const char *str, unsigned int length)
-{
-  char *result;
-
-#ifdef HAVE_STRNDUP
-  result = strndup (str, length);
-  if (result == 0)
-    out_of_memory ();
-#else
-  result = xmalloc (length + 1);
-  if (length > 0)
-    strncpy (result, str, length);
-  result[length] = '\0';
-#endif
-
-  return result;
-}
-
-
-/* Limited INDEX:
-   Search through the string STRING, which ends at LIMIT, for the character C.
-   Returns a pointer to the first occurrence, or nil if none is found.
-   Like INDEX except that the string searched ends where specified
-   instead of at the first null.  */
-
-char *
-lindex (const char *s, const char *limit, int c)
-{
-  while (s < limit)
-    if (*s++ == c)
-      return (char *)(s - 1);
-
-  return 0;
-}
-
-/* Return the address of the first whitespace or null in the string S.  */
-
-char *
-end_of_token (const char *s)
-{
-  END_OF_TOKEN (s);
-  return (char *)s;
-}
-
-/* Return the address of the first nonwhitespace or null in the string S.  */
-
-char *
-next_token (const char *s)
-{
-  NEXT_TOKEN (s);
-  return (char *)s;
-}
-
-/* Find the next token in PTR; return the address of it, and store the length
-   of the token into *LENGTHPTR if LENGTHPTR is not nil.  Set *PTR to the end
-   of the token, so this function can be called repeatedly in a loop.  */
-
-char *
-find_next_token (const char **ptr, unsigned int *lengthptr)
-{
-  const char *p = next_token (*ptr);
-
-  if (*p == '\0')
-    return 0;
-
-  *ptr = end_of_token (p);
-  if (lengthptr != 0)
-    *lengthptr = *ptr - p;
-
-  return (char *)p;
-}
-
-
-/* Copy a chain of 'struct dep'.  For 2nd expansion deps, dup the name.  */
-
-struct dep *
-copy_dep_chain (const struct dep *d)
-{
-  struct dep *firstnew = 0;
-  struct dep *lastnew = 0;
-
-  while (d != 0)
-    {
-      struct dep *c = xmalloc (sizeof (struct dep));
-      memcpy (c, d, sizeof (struct dep));
-
-      if (c->need_2nd_expansion)
-        c->name = xstrdup (c->name);
-
-      c->next = 0;
-      if (firstnew == 0)
-        firstnew = lastnew = c;
-      else
-        lastnew = lastnew->next = c;
-
-      d = d->next;
-    }
-
-  return firstnew;
-}
-
-/* Free a chain of struct nameseq.
-   For struct dep chains use free_dep_chain.  */
-
-void
-free_ns_chain (struct nameseq *ns)
-{
-  while (ns != 0)
-    {
-      struct nameseq *t = ns;
-      ns = ns->next;
-      free_ns (t);
-    }
-}
-
-
-/* Provide support for temporary files.  */
-
-#ifndef HAVE_STDLIB_H
-# ifdef HAVE_MKSTEMP
-int mkstemp (char *template);
-# else
-char *mktemp (char *template);
-# endif
-#endif
-
-FILE *
-get_tmpfile (char **name, const char *template)
-{
-  FILE *file;
-#ifdef HAVE_FDOPEN
-  int fd;
-#endif
-
-  /* Preserve the current umask, and set a restrictive one for temp files.  */
-  MODE_T mask = UMASK (0077);
-
-#if defined(HAVE_MKSTEMP) || defined(HAVE_MKTEMP)
-# define TEMPLATE_LEN   strlen (template)
-#else
-# define TEMPLATE_LEN   L_tmpnam
-#endif
-  *name = xmalloc (TEMPLATE_LEN + 1);
-  strcpy (*name, template);
-
-#if defined(HAVE_MKSTEMP) && defined(HAVE_FDOPEN)
-  /* It's safest to use mkstemp(), if we can.  */
-  EINTRLOOP (fd, mkstemp (*name));
-  if (fd == -1)
-    file = NULL;
-  else
-    file = fdopen (fd, "w");
-#else
-# ifdef HAVE_MKTEMP
-  (void) mktemp (*name);
-# else
-  (void) tmpnam (*name);
-# endif
-
-# ifdef HAVE_FDOPEN
-  /* Can't use mkstemp(), but guard against a race condition.  */
-  EINTRLOOP (fd, open (*name, O_CREAT|O_EXCL|O_WRONLY, 0600));
-  if (fd == -1)
-    return 0;
-  file = fdopen (fd, "w");
-# else
-  /* Not secure, but what can we do?  */
-  file = fopen (*name, "w");
-# endif
-#endif
-
-  UMASK (mask);
-
-  return file;
-}
-
-
-#if !HAVE_STRCASECMP && !HAVE_STRICMP && !HAVE_STRCMPI
-/* If we don't have strcasecmp() (from POSIX), or anything that can substitute
-   for it, define our own version.  */
-
-int
-strcasecmp (const char *s1, const char *s2)
-{
-  while (1)
-    {
-      int c1 = (int) *(s1++);
-      int c2 = (int) *(s2++);
-
-      if (isalpha (c1))
-        c1 = tolower (c1);
-      if (isalpha (c2))
-        c2 = tolower (c2);
-
-      if (c1 != '\0' && c1 == c2)
-        continue;
-
-      return (c1 - c2);
-    }
-}
-#endif
-
-#if !HAVE_STRNCASECMP && !HAVE_STRNICMP && !HAVE_STRNCMPI
-/* If we don't have strncasecmp() (from POSIX), or anything that can
-   substitute for it, define our own version.  */
-
-int
-strncasecmp (const char *s1, const char *s2, int n)
-{
-  while (n-- > 0)
-    {
-      int c1 = (int) *(s1++);
-      int c2 = (int) *(s2++);
-
-      if (isalpha (c1))
-        c1 = tolower (c1);
-      if (isalpha (c2))
-        c2 = tolower (c2);
-
-      if (c1 != '\0' && c1 == c2)
-        continue;
-
-      return (c1 - c2);
-    }
-
-  return 0;
-}
-#endif
-
-#ifdef  GETLOADAVG_PRIVILEGED
-
-#ifdef POSIX
-
-/* Hopefully if a system says it's POSIX.1 and has the setuid and setgid
-   functions, they work as POSIX.1 says.  Some systems (Alpha OSF/1 1.2,
-   for example) which claim to be POSIX.1 also have the BSD setreuid and
-   setregid functions, but they don't work as in BSD and only the POSIX.1
-   way works.  */
-
-#undef HAVE_SETREUID
-#undef HAVE_SETREGID
-
-#else   /* Not POSIX.  */
-
-/* Some POSIX.1 systems have the seteuid and setegid functions.  In a
-   POSIX-like system, they are the best thing to use.  However, some
-   non-POSIX systems have them too but they do not work in the POSIX style
-   and we must use setreuid and setregid instead.  */
-
-#undef HAVE_SETEUID
-#undef HAVE_SETEGID
-
-#endif  /* POSIX.  */
-
-#ifndef HAVE_UNISTD_H
-extern int getuid (), getgid (), geteuid (), getegid ();
-extern int setuid (), setgid ();
-#ifdef HAVE_SETEUID
-extern int seteuid ();
-#else
-#ifdef  HAVE_SETREUID
-extern int setreuid ();
-#endif  /* Have setreuid.  */
-#endif  /* Have seteuid.  */
-#ifdef HAVE_SETEGID
-extern int setegid ();
-#else
-#ifdef  HAVE_SETREGID
-extern int setregid ();
-#endif  /* Have setregid.  */
-#endif  /* Have setegid.  */
-#endif  /* No <unistd.h>.  */
-
-/* Keep track of the user and group IDs for user- and make- access.  */
-static int user_uid = -1, user_gid = -1, make_uid = -1, make_gid = -1;
-#define access_inited   (user_uid != -1)
-static enum { make, user } current_access;
-
-
-/* Under -d, write a message describing the current IDs.  */
-
-static void
-log_access (const char *flavor)
-{
-  if (! ISDB (DB_JOBS))
-    return;
-
-  /* All the other debugging messages go to stdout,
-     but we write this one to stderr because it might be
-     run in a child fork whose stdout is piped.  */
-
-  fprintf (stderr, _("%s: user %lu (real %lu), group %lu (real %lu)\n"),
-           flavor, (unsigned long) geteuid (), (unsigned long) getuid (),
-           (unsigned long) getegid (), (unsigned long) getgid ());
-  fflush (stderr);
-}
-
-
-static void
-init_access (void)
-{
-#ifndef VMS
-  user_uid = getuid ();
-  user_gid = getgid ();
-
-  make_uid = geteuid ();
-  make_gid = getegid ();
-
-  /* Do these ever fail?  */
-  if (user_uid == -1 || user_gid == -1 || make_uid == -1 || make_gid == -1)
-    pfatal_with_name ("get{e}[gu]id");
-
-  log_access (_("Initialized access"));
-
-  current_access = make;
-#endif
-}
-
-#endif  /* GETLOADAVG_PRIVILEGED */
-
-/* Give the process appropriate permissions for access to
-   user data (i.e., to stat files, or to spawn a child process).  */
-void
-user_access (void)
-{
-#ifdef  GETLOADAVG_PRIVILEGED
-
-  if (!access_inited)
-    init_access ();
-
-  if (current_access == user)
-    return;
-
-  /* We are in "make access" mode.  This means that the effective user and
-     group IDs are those of make (if it was installed setuid or setgid).
-     We now want to set the effective user and group IDs to the real IDs,
-     which are the IDs of the process that exec'd make.  */
-
-#ifdef  HAVE_SETEUID
-
-  /* Modern systems have the seteuid/setegid calls which set only the
-     effective IDs, which is ideal.  */
-
-  if (seteuid (user_uid) < 0)
-    pfatal_with_name ("user_access: seteuid");
-
-#else   /* Not HAVE_SETEUID.  */
-
-#ifndef HAVE_SETREUID
-
-  /* System V has only the setuid/setgid calls to set user/group IDs.
-     There is an effective ID, which can be set by setuid/setgid.
-     It can be set (unless you are root) only to either what it already is
-     (returned by geteuid/getegid, now in make_uid/make_gid),
-     the real ID (return by getuid/getgid, now in user_uid/user_gid),
-     or the saved set ID (what the effective ID was before this set-ID
-     executable (make) was exec'd).  */
-
-  if (setuid (user_uid) < 0)
-    pfatal_with_name ("user_access: setuid");
-
-#else   /* HAVE_SETREUID.  */
-
-  /* In 4BSD, the setreuid/setregid calls set both the real and effective IDs.
-     They may be set to themselves or each other.  So you have two alternatives
-     at any one time.  If you use setuid/setgid, the effective will be set to
-     the real, leaving only one alternative.  Using setreuid/setregid, however,
-     you can toggle between your two alternatives by swapping the values in a
-     single setreuid or setregid call.  */
-
-  if (setreuid (make_uid, user_uid) < 0)
-    pfatal_with_name ("user_access: setreuid");
-
-#endif  /* Not HAVE_SETREUID.  */
-#endif  /* HAVE_SETEUID.  */
-
-#ifdef  HAVE_SETEGID
-  if (setegid (user_gid) < 0)
-    pfatal_with_name ("user_access: setegid");
-#else
-#ifndef HAVE_SETREGID
-  if (setgid (user_gid) < 0)
-    pfatal_with_name ("user_access: setgid");
-#else
-  if (setregid (make_gid, user_gid) < 0)
-    pfatal_with_name ("user_access: setregid");
-#endif
-#endif
-
-  current_access = user;
-
-  log_access (_("User access"));
-
-#endif  /* GETLOADAVG_PRIVILEGED */
-}
-
-/* Give the process appropriate permissions for access to
-   make data (i.e., the load average).  */
-void
-make_access (void)
-{
-#ifdef  GETLOADAVG_PRIVILEGED
-
-  if (!access_inited)
-    init_access ();
-
-  if (current_access == make)
-    return;
-
-  /* See comments in user_access, above.  */
-
-#ifdef  HAVE_SETEUID
-  if (seteuid (make_uid) < 0)
-    pfatal_with_name ("make_access: seteuid");
-#else
-#ifndef HAVE_SETREUID
-  if (setuid (make_uid) < 0)
-    pfatal_with_name ("make_access: setuid");
-#else
-  if (setreuid (user_uid, make_uid) < 0)
-    pfatal_with_name ("make_access: setreuid");
-#endif
-#endif
-
-#ifdef  HAVE_SETEGID
-  if (setegid (make_gid) < 0)
-    pfatal_with_name ("make_access: setegid");
-#else
-#ifndef HAVE_SETREGID
-  if (setgid (make_gid) < 0)
-    pfatal_with_name ("make_access: setgid");
-#else
-  if (setregid (user_gid, make_gid) < 0)
-    pfatal_with_name ("make_access: setregid");
-#endif
-#endif
-
-  current_access = make;
-
-  log_access (_("Make access"));
-
-#endif  /* GETLOADAVG_PRIVILEGED */
-}
-
-/* Give the process appropriate permissions for a child process.
-   This is like user_access, but you can't get back to make_access.  */
-void
-child_access (void)
-{
-#ifdef  GETLOADAVG_PRIVILEGED
-
-  if (!access_inited)
-    abort ();
-
-  /* Set both the real and effective UID and GID to the user's.
-     They cannot be changed back to make's.  */
-
-#ifndef HAVE_SETREUID
-  if (setuid (user_uid) < 0)
-    pfatal_with_name ("child_access: setuid");
-#else
-  if (setreuid (user_uid, user_uid) < 0)
-    pfatal_with_name ("child_access: setreuid");
-#endif
-
-#ifndef HAVE_SETREGID
-  if (setgid (user_gid) < 0)
-    pfatal_with_name ("child_access: setgid");
-#else
-  if (setregid (user_gid, user_gid) < 0)
-    pfatal_with_name ("child_access: setregid");
-#endif
-
-  log_access (_("Child access"));
-
-#endif  /* GETLOADAVG_PRIVILEGED */
-}
-
-#ifdef NEED_GET_PATH_MAX
-unsigned int
-get_path_max (void)
-{
-  static unsigned int value;
-
-  if (value == 0)
-    {
-      long int x = pathconf ("/", _PC_PATH_MAX);
-      if (x > 0)
-        value = x;
-      else
-        return MAXPATHLEN;
-    }
-
-  return value;
-}
-#endif
diff --git a/mk/Amiga.mk b/mk/Amiga.mk
index fe2a1f6..180cc78 100644
--- a/mk/Amiga.mk
+++ b/mk/Amiga.mk
@@ -20,16 +20,19 @@
 
 CC = sc
 LD = $(CC) Link
+
 RM = delete
 MKDIR = makedir
+CP = copy
+CP.cmd = $(CP) $< To $@
 
 CPPFLAGS =
 CFLAGS =
 LDFLAGS =
 
-prog_SOURCES += alloca.c getloadavg.c $(glob_SOURCES) $(amiga_SOURCES)
+prog_SOURCES += $(alloca_SOURCES) $(loadavg_SOURCES) $(glob_SOURCES) $(amiga_SOURCES)
 
-extra_CPPFLAGS = IDir "" IDir $(SRCDIR)/glob
+extra_CPPFLAGS = IDir $(OUTDIR)src IDir $(SRCDIR)/src IDir $(SRCDIR)/glob
 
 C_SOURCE =
 OUTPUT_OPTION =
@@ -37,5 +40,5 @@ LDFLAGS = From LIB:cres.o
 LDLIBS = Lib LIB:sc.lib LIB:amiga.lib
 LINK_OUTPUT = To $@
 
-$(OUTDIR)/config.h: $(SRCDIR)/config.ami
-	copy $< To $@
+$(OUTDIR)src/config.h: $(SRCDIR)/src/config.ami
+	$(CP.cmd)
diff --git a/mk/Posix.mk.in b/mk/Posix.mk.in
new file mode 100644
index 0000000..45951f2
--- /dev/null
+++ b/mk/Posix.mk.in
@@ -0,0 +1,27 @@
+# GNU -*-Makefile-*- to build GNU make on POSIX systems
+#
+# POSIX overrides for use with Basic.mk.
+#
+# Copyright (C) 2017 Free Software Foundation, Inc.
+# This file is part of GNU Make.
+#
+# GNU Make is free software; you can redistribute it and/or modify it under
+# the terms of the GNU General Public License as published by the Free Software
+# Foundation; either version 3 of the License, or (at your option) any later
+# version.
+#
+# GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+# details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program.  If not, see <http://www.gnu.org/licenses/>.
+
+# Very little is needed here since the default Basic.mk assumes POSIX
+
+prog_SOURCES += $(posix_SOURCES)
+
+extra_CPPFLAGS += @GUILE_CFLAGS@ @GLOBINC@
+extra_LDFLAGS += @AM_LDFLAGS@
+LDLIBS += @GUILE_LIBS@ @LIBOBJS@ @GETLOADAVG_LIBS@ @GLOBLIB@ @ALLOCA@ @LIBINTL@ @LIBS@
diff --git a/mk/VMS.mk b/mk/VMS.mk
new file mode 100644
index 0000000..a436239
--- /dev/null
+++ b/mk/VMS.mk
@@ -0,0 +1,91 @@
+# GNU -*-Makefile-*- to build GNU make on VMS
+#
+# VMS overrides for use with Basic.mk.
+#
+# Copyright (C) 2017 Free Software Foundation, Inc.
+# This file is part of GNU Make.
+#
+# GNU Make is free software; you can redistribute it and/or modify it under
+# the terms of the GNU General Public License as published by the Free Software
+# Foundation; either version 3 of the License, or (at your option) any later
+# version.
+#
+# GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+# details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program.  If not, see <http://www.gnu.org/licenses/>.
+
+src = [.src]
+glob = [.glob]
+SRCDIR = []
+
+OBJEXT = .obj
+EXEEXT = .exe
+
+CP = copy
+MKDIR = create/dir
+RM = delete
+
+e =
+s = $e $e
+c = ,
+
+defs = HAVE_CONFIG_H
+
+ifeq ($(CC),cc)
+defs += VMS unlink=remove allocated_variable_expand_for_file=alloc_var_expand_for_file
+else
+defs += GCC_IS_NATIVE
+ifeq ($(ARCH),VAX)
+defs += VAX
+endif
+endif
+
+extra_CPPFLAGS = /define=($(subst $s,$c,$(patsubst %,"%",$(defs))))
+
+cinclude = /nested=none/include=($(src),$(glob))
+ifeq ($(CC),cc)
+cprefix = /prefix=(all,except=(glob,globfree))
+cwarn = /standard=relaxed/warn=(disable=questcompare)
+endif
+
+extra_CFLAGS = $(cinclude)$(cprefix)$(cwarn)
+
+#extra_LDFLAGS = /deb
+extra_LDFLAGS =
+
+# If your system needs extra libraries loaded in, define them here.
+# System V probably need -lPW for alloca.
+# if on vax, uncomment the following line
+#LDLIBS = ,c.opt/opt
+ifeq ($(CC),cc)
+#LDLIBS =,sys$$library:vaxcrtl.olb/lib
+else
+LDLIBS =,gnu_cc_library:libgcc.olb/lib
+endif
+
+# If your system doesn't have alloca, or the one provided is bad,
+# uncomment this
+#ALLOCA = $(alloca_SOURCES)
+
+prog_SOURCES += $(ALLOCA) $(glob_SOURCES) $(vms_SOURCES)
+
+COMPILE.cmd = $(CC) $(extra_CFLAGS)$(CFLAGS)/obj=$@ $(extra_CPPFLAGS)$(CPPFLAGS) $<
+
+LINK.cmd = $(LD)$(extra_LDFLAGS)$(LDFLAGS)/exe=$@ $(subst $s,$c,$^)$(LDLIBS)
+
+# Don't know how to do this
+CHECK.cmd =
+
+define RM.cmd
+	-purge [...]
+	-$(RM) $(PROG);
+	-$(RM) $(src)*.$(OBJEXT);
+endef
+
+
+$(OUTDIR)$(src)config.h: $(SRCDIR)$(src)config.h.W32
+	$(CP.cmd)
diff --git a/mk/Windows32.mk b/mk/Windows32.mk
index 8848827..fb64317 100644
--- a/mk/Windows32.mk
+++ b/mk/Windows32.mk
@@ -1,6 +1,6 @@
 # GNU -*-Makefile-*- to build GNU make on Windows
 #
-# Windows overrides for use with Makebase.mk.
+# Windows overrides for use with Basic.mk.
 #
 # Copyright (C) 2017 Free Software Foundation, Inc.
 # This file is part of GNU Make.
@@ -25,7 +25,7 @@ TARGET_TYPE = release
 TOOLCHAIN = msvc
 
 
-prog_SOURCES += getloadavg.c $(glob_SOURCES) $(w32_SOURCES)
+prog_SOURCES += $(loadavg_SOURCES) $(glob_SOURCES) $(w32_SOURCES)
 
 w32_LIBS = kernel32 user32 gdi32 winspool comdlg32 advapi32 shell32 ole32 \
 	   oleaut32 uuid odbc32 odbccp32
@@ -39,7 +39,7 @@ msvc_CC = cl.exe
 msvc_LD = link.exe
 
 msvc_CPPFLAGS = /DHAVE_CONFIG_H /DWINDOWS32 /DWIN32 /D_CONSOLE
-msvc_CPPFLAGS += /I$(OUTDIR) /I$(SRCDIR) /I$(SRCDIR)/glob /I$(SRCDIR)/w32/include
+msvc_CPPFLAGS += /I$(OUTDIR)src /I$(SRCDIR)/src /I$(SRCDIR)/glob /I$(SRCDIR)/src/w32/include
 
 msvc_CFLAGS = /nologo /MT /W4 /EHsc
 msvc_CFLAGS += /FR$(OUTDIR) /Fp$(BASE_PROG).pch /Fd$(BASE_PROG).pdb
@@ -52,11 +52,11 @@ msvc_C_SOURCE = /c
 msvc_OUTPUT_OPTION = /Fo$@
 msvc_LINK_OUTPUT = /OUT:$@
 
-release_msvc_OUTDIR = ./WinRel
+release_msvc_OUTDIR = ./WinRel/
 release_msvc_CPPFLAGS = /D NDEBUG
 release_msvc_CFLAGS = /O2
 
-debug_msvc_OUTDIR = ./WinDebug
+debug_msvc_OUTDIR = ./WinDebug/
 debug_msvc_CPPFLAGS = /D _DEBUG
 debug_msvc_CFLAGS = /Zi /Od
 debug_msvc_LDFLAGS = /DEBUG
@@ -65,10 +65,10 @@ debug_msvc_LDFLAGS = /DEBUG
 gcc_CC = gcc
 gcc_LD = $(gcc_CC)
 
-release_gcc_OUTDIR = ./GccRel
-debug_gcc_OUTDIR = ./GccDebug
+release_gcc_OUTDIR = ./GccRel/
+debug_gcc_OUTDIR = ./GccDebug/
 
-gcc_CPPFLAGS = -DHAVE_CONFIG_H -I$(OBJDIR) -I$(SRCDIR) -I$(SRCDIR)/glob -I$(SRCDIR)/w32/include
+gcc_CPPFLAGS = -DHAVE_CONFIG_H -I$(OUTDIR)src -I$(SRCDIR)/src -I$(SRCDIR)/glob -I$(SRCDIR)/src/w32/include
 gcc_CFLAGS = -mthreads -Wall -std=gnu99 -gdwarf-2 -g3
 gcc_LDFLAGS = -mthreads -gdwarf-2 -g3
 gcc_LDLIBS = $(addprefix -l,$(w32_libs))
@@ -86,8 +86,14 @@ LINK.cmd = $(LD) $(extra_LDFLAGS) $(LDFLAGS) $(TARGET_ARCH) $^ $(LDLIBS) $(LINK_
 
 CHECK.cmd = cmd /c cd tests \& .\run_make_tests.bat -make ../$(PROG)
 
-MKDIR.cmd = cmd /c mkdir $(subst /,\\,$@)
-RM.cmd = cmd /c del /F /Q $(subst /,\\,$(OBJECTS) $(PROG))
+MKDIR = cmd /c mkdir
+MKDIR.cmd = $(MKDIR) $(subst /,\\,$@)
+
+RM = cmd /c del /F /Q
+RM.cmd = $(RM) $(subst /,\\,$(OBJECTS) $(PROG))
+
+CP = cmd /c copy /Y
+CP.cmd = $(CP) $(subst /,\\,$< $@)
 
 CC = $($(TOOLCHAIN)_CC)
 LD = $($(TOOLCHAIN)_LD)
@@ -104,7 +110,7 @@ EXEEXT	= .exe
 _CUSTOM = $($(TOOLCHAIN)_$1) $($(TARGET_TYPE)_$1) $($(TARGET_TYPE)_$(TOOLCHAIN)_$1)
 
 # I'm not sure why this builds gnumake rather than make...?
-PROG = $(OUTDIR)/gnumake$(EXEEXT)
+PROG = $(OUTDIR)gnumake$(EXEEXT)
 BASE_PROG = $(basename $(PROG))
 
 extra_CPPFLAGS = $(call _CUSTOM,CPPFLAGS)
@@ -112,5 +118,5 @@ extra_CFLAGS = $(call _CUSTOM,CFLAGS)
 extra_LDFLAGS = $(call _CUSTOM,LDFLAGS)
 LDLIBS = $(call _CUSTOM,LDLIBS)
 
-$(OUTDIR)/config.h: $(SRCDIR)/config.h.W32
-	cmd /c copy /Y $(subst /,\\,$< $@)
+$(OUTDIR)src/config.h: $(SRCDIR)/src/config.h.W32
+	$(CP.cmd)
diff --git a/mk/msdosdjgpp.mk b/mk/msdosdjgpp.mk
index a9dd250..7d61793 100644
--- a/mk/msdosdjgpp.mk
+++ b/mk/msdosdjgpp.mk
@@ -1,6 +1,6 @@
 # GNU -*-Makefile-*- to build GNU make on MS-DOS with DJGPP
 #
-# MS-DOS overrides for use with Makebase.mk.
+# MS-DOS overrides for use with Basic.mk.
 #
 # Copyright (C) 2017 Free Software Foundation, Inc.
 # This file is part of GNU Make.
@@ -23,12 +23,22 @@ EXEEXT = .exe
 
 CC = gcc
 
-prog_SOURCES += getloadavg.c $(glob_SOURCES)
+prog_SOURCES += $(loadavg_SOURCES) $(glob_SOURCES)
 
-extra_CPPFLAGS += -I$(SRCDIR)/glob -DINCLUDEDIR=\"c:/djgpp/include\" -DLIBDIR=\"c:/djgpp/lib\"
+INCLUDEDIR = c:/djgpp/include
+LIBDIR = c:/djgpp/lib
+LOCALEDIR = c:/djgpp/share
 
-MKDIR.cmd = command.com /c mkdir $(subst /,\\,$@)
-RM.cmd = command.com /c del /F /Q $(subst /,\\,$(OBJECTS) $(PROG))
+extra_CPPFLAGS = -I$(SRCDIR)/glob
 
-$(OUTDIR)/config.h: $(SRCDIR)/configh.dos
-	command.com /c copy /Y $(subst /,\\,$< $@)
+MKDIR = command.com /c mkdir
+MKDIR.cmd = $(MKDIR) $(subst /,\\,$@)
+
+RM = command.com /c del /F /Q
+RM.cmd = $(RM) $(subst /,\\,$(OBJECTS) $(PROG))
+
+CP = command.com /c copy /Y
+CP.cmd = $(CP) $(subst /,\\,$< $@)
+
+$(OUTDIR)src/config.h: $(SRCDIR)/src/configh.dos
+	$(CP.cmd)
diff --git a/os.h b/os.h
deleted file mode 100644
index b68b005..0000000
--- a/os.h
+++ /dev/null
@@ -1,93 +0,0 @@
-/* Declarations for operating system interfaces for GNU Make.
-Copyright (C) 2016-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-
-/* This section provides OS-specific functions to support the jobserver.  */
-
-#ifdef MAKE_JOBSERVER
-
-/* Returns 1 if the jobserver is enabled, else 0.  */
-unsigned int jobserver_enabled (void);
-
-/* Called in the master instance to set up the jobserver initially.  */
-unsigned int jobserver_setup (int job_slots);
-
-/* Called in a child instance to connect to the jobserver.  */
-unsigned int jobserver_parse_auth (const char* auth);
-
-/* Returns an allocated buffer used to pass to child instances.  */
-char *jobserver_get_auth (void);
-
-/* Clear this instance's jobserver configuration.  */
-void jobserver_clear (void);
-
-/* Recover all the jobserver tokens and return the number we got.  */
-unsigned int jobserver_acquire_all (void);
-
-/* Release a jobserver token.  If it fails and is_fatal is 1, fatal.  */
-void jobserver_release (int is_fatal);
-
-/* Notify the jobserver that a child exited.  */
-void jobserver_signal (void);
-
-/* Get ready to start a non-recursive child.  */
-void jobserver_pre_child (int);
-
-/* Complete starting a non-recursive child.  */
-void jobserver_post_child (int);
-
-/* Set up to acquire a new token.  */
-void jobserver_pre_acquire (void);
-
-/* Wait until we can acquire a jobserver token.
-   TIMEOUT is 1 if we have other jobs waiting for the load to go down;
-   in this case we won't wait forever, so we can check the load.
-   Returns 1 if we got a token, or 0 if we stopped waiting due to a child
-   exiting or a timeout.    */
-unsigned int jobserver_acquire (int timeout);
-
-#else
-
-#define jobserver_enabled()         (0)
-#define jobserver_setup(_slots)     (0)
-#define jobserver_parse_auth(_auth) (0)
-#define jobserver_get_auth()        (NULL)
-#define jobserver_clear()           (void)(0)
-#define jobserver_release(_fatal)   (void)(0)
-#define jobserver_acquire_all()     (0)
-#define jobserver_signal()          (void)(0)
-#define jobserver_pre_child(_r)     (void)(0)
-#define jobserver_post_child(_r)    (void)(0)
-#define jobserver_pre_acquire()     (void)(0)
-#define jobserver_acquire(_tmout)   (0)
-
-#endif
-
-/* Create a "bad" file descriptor for stdin when parallel jobs are run.  */
-#if defined(VMS) || defined(WINDOWS32) || defined(_AMIGA) || defined(__MSDOS__)
-# define get_bad_stdin() (-1)
-#else
-int get_bad_stdin (void);
-#endif
-
-/* Set a file descriptor to close/not close in a subprocess.  */
-#if defined(VMS) || defined(_AMIGA) || defined(__MSDOS__)
-# define fd_inherit(_i)   0
-# define fd_noinherit(_i) 0
-#else
-void fd_inherit (int);
-void fd_noinherit (int);
-#endif
diff --git a/output.c b/output.c
deleted file mode 100644
index 93b3dc7..0000000
--- a/output.c
+++ /dev/null
@@ -1,702 +0,0 @@
-/* Output to stdout / stderr for GNU make
-Copyright (C) 2013-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-#include "os.h"
-#include "output.h"
-
-/* GNU make no longer supports pre-ANSI89 environments.  */
-
-#include <assert.h>
-#include <stdio.h>
-#include <stdarg.h>
-
-#ifdef HAVE_UNISTD_H
-# include <unistd.h>
-#endif
-
-#ifdef HAVE_FCNTL_H
-# include <fcntl.h>
-#else
-# include <sys/file.h>
-#endif
-
-#ifdef WINDOWS32
-# include <windows.h>
-# include <io.h>
-# include "sub_proc.h"
-#endif /* WINDOWS32 */
-
-struct output *output_context = NULL;
-unsigned int stdio_traced = 0;
-
-#define OUTPUT_NONE (-1)
-
-#define OUTPUT_ISSET(_out) ((_out)->out >= 0 || (_out)->err >= 0)
-
-#ifdef HAVE_FCNTL_H
-# define STREAM_OK(_s) ((fcntl (fileno (_s), F_GETFD) != -1) || (errno != EBADF))
-#else
-# define STREAM_OK(_s) 1
-#endif
-
-/* Write a BUFFER of size LEN to file descriptor FD.
-   Handle EINTR and other short writes.  If we get an error, ignore it.  */
-int
-output_write (int fd, const void *buffer, size_t len)
-{
-  const char *msg = buffer;
-  while (1)
-    {
-      ssize_t r;
-
-      EINTRLOOP (r, write (fd, msg, len));
-
-      if (r < 0 || (size_t)r == len)
-        return r;
-
-      len -= r;
-      msg += r;
-    }
-}
-
-/* Write a string to the current STDOUT or STDERR.  */
-static void
-_outputs (struct output *out, int is_err, const char *msg)
-{
-  if (! out || ! out->syncout)
-    {
-      FILE *f = is_err ? stderr : stdout;
-      fputs (msg, f);
-      fflush (f);
-    }
-  else
-    {
-      int fd = is_err ? out->err : out->out;
-      int len = strlen (msg);
-      int r;
-      EINTRLOOP (r, lseek (fd, 0, SEEK_END));
-      output_write (fd, msg, len);
-    }
-}
-
-/* Write a message indicating that we've just entered or
-   left (according to ENTERING) the current directory.  */
-
-static int
-log_working_directory (int entering)
-{
-  static char *buf = NULL;
-  static unsigned int len = 0;
-  unsigned int need;
-  const char *fmt;
-  char *p;
-
-  /* Get enough space for the longest possible output.  */
-  need = strlen (program) + INTSTR_LENGTH + 2 + 1;
-  if (starting_directory)
-    need += strlen (starting_directory);
-
-  /* Use entire sentences to give the translators a fighting chance.  */
-  if (makelevel == 0)
-    if (starting_directory == 0)
-      if (entering)
-        fmt = _("%s: Entering an unknown directory\n");
-      else
-        fmt = _("%s: Leaving an unknown directory\n");
-    else
-      if (entering)
-        fmt = _("%s: Entering directory '%s'\n");
-      else
-        fmt = _("%s: Leaving directory '%s'\n");
-  else
-    if (starting_directory == 0)
-      if (entering)
-        fmt = _("%s[%u]: Entering an unknown directory\n");
-      else
-        fmt = _("%s[%u]: Leaving an unknown directory\n");
-    else
-      if (entering)
-        fmt = _("%s[%u]: Entering directory '%s'\n");
-      else
-        fmt = _("%s[%u]: Leaving directory '%s'\n");
-
-  need += strlen (fmt);
-
-  if (need > len)
-    {
-      buf = xrealloc (buf, need);
-      len = need;
-    }
-
-  p = buf;
-  if (print_data_base_flag)
-    {
-      *(p++) = '#';
-      *(p++) = ' ';
-    }
-
-  if (makelevel == 0)
-    if (starting_directory == 0)
-      sprintf (p, fmt , program);
-    else
-      sprintf (p, fmt, program, starting_directory);
-  else if (starting_directory == 0)
-    sprintf (p, fmt, program, makelevel);
-  else
-    sprintf (p, fmt, program, makelevel, starting_directory);
-
-  _outputs (NULL, 0, buf);
-
-  return 1;
-}
-
-/* Set a file descriptor to be in O_APPEND mode.
-   If it fails, just ignore it.  */
-
-static void
-set_append_mode (int fd)
-{
-#if defined(F_GETFL) && defined(F_SETFL) && defined(O_APPEND)
-  int flags = fcntl (fd, F_GETFL, 0);
-  if (flags >= 0)
-    {
-      int r;
-      EINTRLOOP(r, fcntl (fd, F_SETFL, flags | O_APPEND));
-    }
-#endif
-}
-
-
-#ifndef NO_OUTPUT_SYNC
-
-/* Semaphore for use in -j mode with output_sync. */
-static sync_handle_t sync_handle = -1;
-
-#define FD_NOT_EMPTY(_f) ((_f) != OUTPUT_NONE && lseek ((_f), 0, SEEK_END) > 0)
-
-/* Set up the sync handle.  Disables output_sync on error.  */
-static int
-sync_init (void)
-{
-  int combined_output = 0;
-
-#ifdef WINDOWS32
-  if ((!STREAM_OK (stdout) && !STREAM_OK (stderr))
-      || (sync_handle = create_mutex ()) == -1)
-    {
-      perror_with_name ("output-sync suppressed: ", "stderr");
-      output_sync = 0;
-    }
-  else
-    {
-      combined_output = same_stream (stdout, stderr);
-      prepare_mutex_handle_string (sync_handle);
-    }
-
-#else
-  if (STREAM_OK (stdout))
-    {
-      struct stat stbuf_o, stbuf_e;
-
-      sync_handle = fileno (stdout);
-      combined_output = (fstat (fileno (stdout), &stbuf_o) == 0
-                         && fstat (fileno (stderr), &stbuf_e) == 0
-                         && stbuf_o.st_dev == stbuf_e.st_dev
-                         && stbuf_o.st_ino == stbuf_e.st_ino);
-    }
-  else if (STREAM_OK (stderr))
-    sync_handle = fileno (stderr);
-  else
-    {
-      perror_with_name ("output-sync suppressed: ", "stderr");
-      output_sync = 0;
-    }
-#endif
-
-  return combined_output;
-}
-
-/* Support routine for output_sync() */
-static void
-pump_from_tmp (int from, FILE *to)
-{
-  static char buffer[8192];
-
-#ifdef WINDOWS32
-  int prev_mode;
-
-  /* "from" is opened by open_tmpfd, which does it in binary mode, so
-     we need the mode of "to" to match that.  */
-  prev_mode = _setmode (fileno (to), _O_BINARY);
-#endif
-
-  if (lseek (from, 0, SEEK_SET) == -1)
-    perror ("lseek()");
-
-  while (1)
-    {
-      int len;
-      EINTRLOOP (len, read (from, buffer, sizeof (buffer)));
-      if (len < 0)
-        perror ("read()");
-      if (len <= 0)
-        break;
-      if (fwrite (buffer, len, 1, to) < 1)
-        {
-          perror ("fwrite()");
-          break;
-        }
-      fflush (to);
-    }
-
-#ifdef WINDOWS32
-  /* Switch "to" back to its original mode, so that log messages by
-     Make have the same EOL format as without --output-sync.  */
-  _setmode (fileno (to), prev_mode);
-#endif
-}
-
-/* Obtain the lock for writing output.  */
-static void *
-acquire_semaphore (void)
-{
-  static struct flock fl;
-
-  fl.l_type = F_WRLCK;
-  fl.l_whence = SEEK_SET;
-  fl.l_start = 0;
-  fl.l_len = 1;
-  if (fcntl (sync_handle, F_SETLKW, &fl) != -1)
-    return &fl;
-  perror ("fcntl()");
-  return NULL;
-}
-
-/* Release the lock for writing output.  */
-static void
-release_semaphore (void *sem)
-{
-  struct flock *flp = (struct flock *)sem;
-  flp->l_type = F_UNLCK;
-  if (fcntl (sync_handle, F_SETLKW, flp) == -1)
-    perror ("fcntl()");
-}
-
-/* Returns a file descriptor to a temporary file.  The file is automatically
-   closed/deleted on exit.  Don't use a FILE* stream.  */
-int
-output_tmpfd (void)
-{
-  MODE_T mask = UMASK (0077);
-  int fd = -1;
-  FILE *tfile = tmpfile ();
-
-  if (! tfile)
-    pfatal_with_name ("tmpfile");
-
-  /* Create a duplicate so we can close the stream.  */
-  fd = dup (fileno (tfile));
-  if (fd < 0)
-    pfatal_with_name ("dup");
-
-  fclose (tfile);
-
-  set_append_mode (fd);
-
-  UMASK (mask);
-
-  return fd;
-}
-
-/* Adds file descriptors to the child structure to support output_sync; one
-   for stdout and one for stderr as long as they are open.  If stdout and
-   stderr share a device they can share a temp file too.
-   Will reset output_sync on error.  */
-static void
-setup_tmpfile (struct output *out)
-{
-  /* Is make's stdout going to the same place as stderr?  */
-  static int combined_output = -1;
-
-  if (combined_output < 0)
-    combined_output = sync_init ();
-
-  if (STREAM_OK (stdout))
-    {
-      int fd = output_tmpfd ();
-      if (fd < 0)
-        goto error;
-      fd_noinherit (fd);
-      out->out = fd;
-    }
-
-  if (STREAM_OK (stderr))
-    {
-      if (out->out != OUTPUT_NONE && combined_output)
-        out->err = out->out;
-      else
-        {
-          int fd = output_tmpfd ();
-          if (fd < 0)
-            goto error;
-          fd_noinherit (fd);
-          out->err = fd;
-        }
-    }
-
-  return;
-
-  /* If we failed to create a temp file, disable output sync going forward.  */
- error:
-  output_close (out);
-  output_sync = OUTPUT_SYNC_NONE;
-}
-
-/* Synchronize the output of jobs in -j mode to keep the results of
-   each job together. This is done by holding the results in temp files,
-   one for stdout and potentially another for stderr, and only releasing
-   them to "real" stdout/stderr when a semaphore can be obtained. */
-
-void
-output_dump (struct output *out)
-{
-  int outfd_not_empty = FD_NOT_EMPTY (out->out);
-  int errfd_not_empty = FD_NOT_EMPTY (out->err);
-
-  if (outfd_not_empty || errfd_not_empty)
-    {
-      int traced = 0;
-
-      /* Try to acquire the semaphore.  If it fails, dump the output
-         unsynchronized; still better than silently discarding it.
-         We want to keep this lock for as little time as possible.  */
-      void *sem = acquire_semaphore ();
-
-      /* Log the working directory for this dump.  */
-      if (print_directory_flag && output_sync != OUTPUT_SYNC_RECURSE)
-        traced = log_working_directory (1);
-
-      if (outfd_not_empty)
-        pump_from_tmp (out->out, stdout);
-      if (errfd_not_empty && out->err != out->out)
-        pump_from_tmp (out->err, stderr);
-
-      if (traced)
-        log_working_directory (0);
-
-      /* Exit the critical section.  */
-      if (sem)
-        release_semaphore (sem);
-
-      /* Truncate and reset the output, in case we use it again.  */
-      if (out->out != OUTPUT_NONE)
-        {
-          int e;
-          lseek (out->out, 0, SEEK_SET);
-          EINTRLOOP (e, ftruncate (out->out, 0));
-        }
-      if (out->err != OUTPUT_NONE && out->err != out->out)
-        {
-          int e;
-          lseek (out->err, 0, SEEK_SET);
-          EINTRLOOP (e, ftruncate (out->err, 0));
-        }
-    }
-}
-#endif /* NO_OUTPUT_SYNC */
-
-
-/* This code is stolen from gnulib.
-   If/when we abandon the requirement to work with K&R compilers, we can
-   remove this (and perhaps other parts of GNU make!) and migrate to using
-   gnulib directly.
-
-   This is called only through atexit(), which means die() has already been
-   invoked.  So, call exit() here directly.  Apparently that works...?
-*/
-
-/* Close standard output, exiting with status 'exit_failure' on failure.
-   If a program writes *anything* to stdout, that program should close
-   stdout and make sure that it succeeds before exiting.  Otherwise,
-   suppose that you go to the extreme of checking the return status
-   of every function that does an explicit write to stdout.  The last
-   printf can succeed in writing to the internal stream buffer, and yet
-   the fclose(stdout) could still fail (due e.g., to a disk full error)
-   when it tries to write out that buffered data.  Thus, you would be
-   left with an incomplete output file and the offending program would
-   exit successfully.  Even calling fflush is not always sufficient,
-   since some file systems (NFS and CODA) buffer written/flushed data
-   until an actual close call.
-
-   Besides, it's wasteful to check the return value from every call
-   that writes to stdout -- just let the internal stream state record
-   the failure.  That's what the ferror test is checking below.
-
-   It's important to detect such failures and exit nonzero because many
-   tools (most notably 'make' and other build-management systems) depend
-   on being able to detect failure in other tools via their exit status.  */
-
-static void
-close_stdout (void)
-{
-  int prev_fail = ferror (stdout);
-  int fclose_fail = fclose (stdout);
-
-  if (prev_fail || fclose_fail)
-    {
-      if (fclose_fail)
-        perror_with_name (_("write error: stdout"), "");
-      else
-        O (error, NILF, _("write error: stdout"));
-      exit (MAKE_TROUBLE);
-    }
-}
-
-
-void
-output_init (struct output *out)
-{
-  if (out)
-    {
-      out->out = out->err = OUTPUT_NONE;
-      out->syncout = !!output_sync;
-      return;
-    }
-
-  /* Configure this instance of make.  Be sure stdout is line-buffered.  */
-
-#ifdef HAVE_SETVBUF
-# ifdef SETVBUF_REVERSED
-  setvbuf (stdout, _IOLBF, xmalloc (BUFSIZ), BUFSIZ);
-# else  /* setvbuf not reversed.  */
-  /* Some buggy systems lose if we pass 0 instead of allocating ourselves.  */
-  setvbuf (stdout, 0, _IOLBF, BUFSIZ);
-# endif /* setvbuf reversed.  */
-#elif HAVE_SETLINEBUF
-  setlinebuf (stdout);
-#endif  /* setlinebuf missing.  */
-
-  /* Force stdout/stderr into append mode.  This ensures parallel jobs won't
-     lose output due to overlapping writes.  */
-  set_append_mode (fileno (stdout));
-  set_append_mode (fileno (stderr));
-
-#ifdef HAVE_ATEXIT
-  if (STREAM_OK (stdout))
-    atexit (close_stdout);
-#endif
-}
-
-void
-output_close (struct output *out)
-{
-  if (! out)
-    {
-      if (stdio_traced)
-        log_working_directory (0);
-      return;
-    }
-
-#ifndef NO_OUTPUT_SYNC
-  output_dump (out);
-#endif
-
-  if (out->out >= 0)
-    close (out->out);
-  if (out->err >= 0 && out->err != out->out)
-    close (out->err);
-
-  output_init (out);
-}
-
-/* We're about to generate output: be sure it's set up.  */
-void
-output_start (void)
-{
-#ifndef NO_OUTPUT_SYNC
-  /* If we're syncing output make sure the temporary file is set up.  */
-  if (output_context && output_context->syncout)
-    if (! OUTPUT_ISSET(output_context))
-      setup_tmpfile (output_context);
-#endif
-
-  /* If we're not syncing this output per-line or per-target, make sure we emit
-     the "Entering..." message where appropriate.  */
-  if (output_sync == OUTPUT_SYNC_NONE || output_sync == OUTPUT_SYNC_RECURSE)
-    if (! stdio_traced && print_directory_flag)
-      stdio_traced = log_working_directory (1);
-}
-
-void
-outputs (int is_err, const char *msg)
-{
-  if (! msg || *msg == '\0')
-    return;
-
-  output_start ();
-
-  _outputs (output_context, is_err, msg);
-}
-
-
-static struct fmtstring
-  {
-    char *buffer;
-    size_t size;
-  } fmtbuf = { NULL, 0 };
-
-static char *
-get_buffer (size_t need)
-{
-  /* Make sure we have room.  NEED includes space for \0.  */
-  if (need > fmtbuf.size)
-    {
-      fmtbuf.size += need * 2;
-      fmtbuf.buffer = xrealloc (fmtbuf.buffer, fmtbuf.size);
-    }
-
-  fmtbuf.buffer[need-1] = '\0';
-
-  return fmtbuf.buffer;
-}
-
-/* Print a message on stdout.  */
-
-void
-message (int prefix, size_t len, const char *fmt, ...)
-{
-  va_list args;
-  char *p;
-
-  len += strlen (fmt) + strlen (program) + INTSTR_LENGTH + 4 + 1 + 1;
-  p = get_buffer (len);
-
-  if (prefix)
-    {
-      if (makelevel == 0)
-        sprintf (p, "%s: ", program);
-      else
-        sprintf (p, "%s[%u]: ", program, makelevel);
-      p += strlen (p);
-    }
-
-  va_start (args, fmt);
-  vsprintf (p, fmt, args);
-  va_end (args);
-
-  strcat (p, "\n");
-
-  assert (fmtbuf.buffer[len-1] == '\0');
-  outputs (0, fmtbuf.buffer);
-}
-
-/* Print an error message.  */
-
-void
-error (const floc *flocp, size_t len, const char *fmt, ...)
-{
-  va_list args;
-  char *p;
-
-  len += (strlen (fmt) + strlen (program)
-          + (flocp && flocp->filenm ? strlen (flocp->filenm) : 0)
-          + INTSTR_LENGTH + 4 + 1 + 1);
-  p = get_buffer (len);
-
-  if (flocp && flocp->filenm)
-    sprintf (p, "%s:%lu: ", flocp->filenm, flocp->lineno + flocp->offset);
-  else if (makelevel == 0)
-    sprintf (p, "%s: ", program);
-  else
-    sprintf (p, "%s[%u]: ", program, makelevel);
-  p += strlen (p);
-
-  va_start (args, fmt);
-  vsprintf (p, fmt, args);
-  va_end (args);
-
-  strcat (p, "\n");
-
-  assert (fmtbuf.buffer[len-1] == '\0');
-  outputs (1, fmtbuf.buffer);
-}
-
-/* Print an error message and exit.  */
-
-void
-fatal (const floc *flocp, size_t len, const char *fmt, ...)
-{
-  va_list args;
-  const char *stop = _(".  Stop.\n");
-  char *p;
-
-  len += (strlen (fmt) + strlen (program)
-          + (flocp && flocp->filenm ? strlen (flocp->filenm) : 0)
-          + INTSTR_LENGTH + 8 + strlen (stop) + 1);
-  p = get_buffer (len);
-
-  if (flocp && flocp->filenm)
-    sprintf (p, "%s:%lu: *** ", flocp->filenm, flocp->lineno + flocp->offset);
-  else if (makelevel == 0)
-    sprintf (p, "%s: *** ", program);
-  else
-    sprintf (p, "%s[%u]: *** ", program, makelevel);
-  p += strlen (p);
-
-  va_start (args, fmt);
-  vsprintf (p, fmt, args);
-  va_end (args);
-
-  strcat (p, stop);
-
-  assert (fmtbuf.buffer[len-1] == '\0');
-  outputs (1, fmtbuf.buffer);
-
-  die (MAKE_FAILURE);
-}
-
-/* Print an error message from errno.  */
-
-void
-perror_with_name (const char *str, const char *name)
-{
-  const char *err = strerror (errno);
-  OSSS (error, NILF, _("%s%s: %s"), str, name, err);
-}
-
-/* Print an error message from errno and exit.  */
-
-void
-pfatal_with_name (const char *name)
-{
-  const char *err = strerror (errno);
-  OSS (fatal, NILF, _("%s: %s"), name, err);
-
-  /* NOTREACHED */
-}
-
-/* Print a message about out of memory (not using more heap) and exit.
-   Our goal here is to be sure we don't try to allocate more memory, which
-   means we don't want to use string translations or normal cleanup.  */
-
-void
-out_of_memory ()
-{
-  output_write (FD_STDOUT, program, strlen (program));
-  output_write (FD_STDOUT, STRING_SIZE_TUPLE (": *** virtual memory exhausted\n"));
-  exit (MAKE_FAILURE);
-}
diff --git a/output.h b/output.h
deleted file mode 100644
index 8adec4a..0000000
--- a/output.h
+++ /dev/null
@@ -1,106 +0,0 @@
-/* Output to stdout / stderr for GNU make
-Copyright (C) 2013-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-struct output
-  {
-    int out;
-    int err;
-    unsigned int syncout:1;     /* True if we want to synchronize output.  */
- };
-
-extern struct output *output_context;
-extern unsigned int stdio_traced;
-
-#define FD_STDIN  (fileno (stdin))
-#define FD_STDOUT (fileno (stdout))
-#define FD_STDERR (fileno (stderr))
-
-#define OUTPUT_SET(_new)    do{ output_context = (_new)->syncout ? (_new) : NULL; }while(0)
-#define OUTPUT_UNSET()      do{ output_context = NULL; }while(0)
-
-#define OUTPUT_TRACED()     do{ stdio_traced = 1; }while(0)
-#define OUTPUT_IS_TRACED()  (!!stdio_traced)
-
-/* Write a buffer directly to the given file descriptor.
-   This handles errors etc.  */
-int output_write (int fd, const void *buffer, size_t len);
-
-/* Initialize and close a child output structure: if NULL do this program's
-   output (this should only be done once).  */
-void output_init (struct output *out);
-void output_close (struct output *out);
-
-/* In situations where output may be about to be displayed but we're not
-   sure if we've set it up yet, call this.  */
-void output_start (void);
-
-/* Show a message on stdout or stderr.  Will start the output if needed.  */
-void outputs (int is_err, const char *msg);
-
-#if defined(HAVE_FCNTL_H)
-# include <fcntl.h>
-#elif defined(HAVE_SYS_FILE_H)
-# include <sys/file.h>
-#endif
-
-#ifdef NO_OUTPUT_SYNC
-# define RECORD_SYNC_MUTEX(m) \
-    O (error, NILF,                                                    \
-       _("-O[TYPE] (--output-sync[=TYPE]) is not configured for this build."));
-#else
-int output_tmpfd (void);
-/* Dump any child output content to stdout, and reset it.  */
-void output_dump (struct output *out);
-
-# ifdef WINDOWS32
-/* For emulations in w32/compat/posixfcn.c.  */
-#  define F_GETFD 1
-#  define F_SETLKW 2
-/* Implementation note: None of the values of l_type below can be zero
-   -- they are compared with a static instance of the struct, so zero
-   means unknown/invalid, see w32/compat/posixfcn.c. */
-#  define F_WRLCK 1
-#  define F_UNLCK 2
-
-struct flock
-  {
-    short l_type;
-    short l_whence;
-    off_t l_start;
-    off_t l_len;
-    pid_t l_pid;
-  };
-
-/* This type is actually a HANDLE, but we want to avoid including
-   windows.h as much as possible.  */
-typedef intptr_t sync_handle_t;
-
-/* Public functions emulated/provided in posixfcn.c.  */
-int fcntl (intptr_t fd, int cmd, ...);
-intptr_t create_mutex (void);
-int same_stream (FILE *f1, FILE *f2);
-
-#  define RECORD_SYNC_MUTEX(m) record_sync_mutex(m)
-void record_sync_mutex (const char *str);
-void prepare_mutex_handle_string (intptr_t hdl);
-# else  /* !WINDOWS32 */
-
-typedef int sync_handle_t;      /* file descriptor */
-
-#  define RECORD_SYNC_MUTEX(m) (void)(m)
-
-# endif
-#endif  /* !NO_OUTPUT_SYNC */
diff --git a/po/POTFILES.in b/po/POTFILES.in
index 214fdf1..87f6fcd 100644
--- a/po/POTFILES.in
+++ b/po/POTFILES.in
@@ -15,33 +15,33 @@
 # You should have received a copy of the GNU General Public License along with
 # this program.  If not, see <http://www.gnu.org/licenses/>.
 
-ar.c
-arscan.c
-commands.c
-dir.c
-expand.c
-file.c
-function.c
-getopt.c
-guile.c
-hash.c
-implicit.c
-job.c
-load.c
-main.c
-misc.c
-output.c
-output.h
-posixos.c
-read.c
-remake.c
-remote-cstms.c
-rule.c
-signame.c
-strcache.c
-variable.c
-variable.h
-vmsfunctions.c
-vmsjobs.c
-vpath.c
-w32/w32os.c
+src/ar.c
+src/arscan.c
+src/commands.c
+src/dir.c
+src/expand.c
+src/file.c
+src/function.c
+src/getopt.c
+src/guile.c
+src/hash.c
+src/implicit.c
+src/job.c
+src/load.c
+src/main.c
+src/misc.c
+src/output.c
+src/output.h
+src/posixos.c
+src/read.c
+src/remake.c
+src/remote-cstms.c
+src/rule.c
+src/signame.c
+src/strcache.c
+src/variable.c
+src/variable.h
+src/vmsfunctions.c
+src/vmsjobs.c
+src/vpath.c
+src/w32/w32os.c
diff --git a/posixos.c b/posixos.c
deleted file mode 100644
index 1c18daf..0000000
--- a/posixos.c
+++ /dev/null
@@ -1,512 +0,0 @@
-/* POSIX-based operating system interface for GNU Make.
-Copyright (C) 2016-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-
-#include <stdio.h>
-
-#ifdef HAVE_FCNTL_H
-# include <fcntl.h>
-#elif defined(HAVE_SYS_FILE_H)
-# include <sys/file.h>
-#endif
-
-#if defined(HAVE_PSELECT) && defined(HAVE_SYS_SELECT_H)
-# include <sys/select.h>
-#endif
-
-#include "debug.h"
-#include "job.h"
-#include "os.h"
-
-#ifdef MAKE_JOBSERVER
-
-/* This section provides OS-specific functions to support the jobserver.  */
-
-/* These track the state of the jobserver pipe.  Passed to child instances.  */
-static int job_fds[2] = { -1, -1 };
-
-/* Used to signal read() that a SIGCHLD happened.  Always CLOEXEC.
-   If we use pselect() this will never be created and always -1.
- */
-static int job_rfd = -1;
-
-/* Token written to the pipe (could be any character...)  */
-static char token = '+';
-
-static int
-make_job_rfd (void)
-{
-#ifdef HAVE_PSELECT
-  /* Pretend we succeeded.  */
-  return 0;
-#else
-  EINTRLOOP (job_rfd, dup (job_fds[0]));
-  if (job_rfd >= 0)
-    fd_noinherit (job_rfd);
-
-  return job_rfd;
-#endif
-}
-
-static void
-set_blocking (int fd, int blocking)
-{
-  // If we're not using pselect() don't change the blocking
-#ifdef HAVE_PSELECT
-  int flags;
-  EINTRLOOP (flags, fcntl (fd, F_GETFL));
-  if (flags >= 0)
-    {
-      int r;
-      flags = blocking ? (flags & ~O_NONBLOCK) : (flags | O_NONBLOCK);
-      EINTRLOOP (r, fcntl (fd, F_SETFL, flags));
-      if (r < 0)
-        pfatal_with_name ("fcntl(O_NONBLOCK)");
-    }
-#endif
-}
-
-unsigned int
-jobserver_setup (int slots)
-{
-  int r;
-
-  EINTRLOOP (r, pipe (job_fds));
-  if (r < 0)
-    pfatal_with_name (_("creating jobs pipe"));
-
-  /* By default we don't send the job pipe FDs to our children.
-     See jobserver_pre_child() and jobserver_post_child().  */
-  fd_noinherit (job_fds[0]);
-  fd_noinherit (job_fds[1]);
-
-  if (make_job_rfd () < 0)
-    pfatal_with_name (_("duping jobs pipe"));
-
-  while (slots--)
-    {
-      EINTRLOOP (r, write (job_fds[1], &token, 1));
-      if (r != 1)
-        pfatal_with_name (_("init jobserver pipe"));
-    }
-
-  /* When using pselect() we want the read to be non-blocking.  */
-  set_blocking (job_fds[0], 0);
-
-  return 1;
-}
-
-unsigned int
-jobserver_parse_auth (const char *auth)
-{
-  /* Given the command-line parameter, parse it.  */
-  if (sscanf (auth, "%d,%d", &job_fds[0], &job_fds[1]) != 2)
-    OS (fatal, NILF,
-        _("internal error: invalid --jobserver-auth string '%s'"), auth);
-
-  DB (DB_JOBS,
-      (_("Jobserver client (fds %d,%d)\n"), job_fds[0], job_fds[1]));
-
-#ifdef HAVE_FCNTL_H
-# define FD_OK(_f) (fcntl ((_f), F_GETFD) != -1)
-#else
-# define FD_OK(_f) 1
-#endif
-
-  /* Make sure our pipeline is valid, and (possibly) create a duplicate pipe,
-     that will be closed in the SIGCHLD handler.  If this fails with EBADF,
-     the parent has closed the pipe on us because it didn't think we were a
-     submake.  If so, warn and default to -j1.  */
-
-  if (!FD_OK (job_fds[0]) || !FD_OK (job_fds[1]) || make_job_rfd () < 0)
-    {
-      if (errno != EBADF)
-        pfatal_with_name (_("jobserver pipeline"));
-
-      job_fds[0] = job_fds[1] = -1;
-
-      return 0;
-    }
-
-  /* When using pselect() we want the read to be non-blocking.  */
-  set_blocking (job_fds[0], 0);
-
-  return 1;
-}
-
-char *
-jobserver_get_auth (void)
-{
-  char *auth = xmalloc ((INTSTR_LENGTH * 2) + 2);
-  sprintf (auth, "%d,%d", job_fds[0], job_fds[1]);
-  return auth;
-}
-
-unsigned int
-jobserver_enabled (void)
-{
-  return job_fds[0] >= 0;
-}
-
-void
-jobserver_clear (void)
-{
-  if (job_fds[0] >= 0)
-    close (job_fds[0]);
-  if (job_fds[1] >= 0)
-    close (job_fds[1]);
-  if (job_rfd >= 0)
-    close (job_rfd);
-
-  job_fds[0] = job_fds[1] = job_rfd = -1;
-}
-
-void
-jobserver_release (int is_fatal)
-{
-  int r;
-  EINTRLOOP (r, write (job_fds[1], &token, 1));
-  if (r != 1)
-    {
-      if (is_fatal)
-        pfatal_with_name (_("write jobserver"));
-      perror_with_name ("write", "");
-    }
-}
-
-unsigned int
-jobserver_acquire_all (void)
-{
-  unsigned int tokens = 0;
-
-  /* Use blocking reads to wait for all outstanding jobs.  */
-  set_blocking (job_fds[0], 1);
-
-  /* Close the write side, so the read() won't hang forever.  */
-  close (job_fds[1]);
-  job_fds[1] = -1;
-
-  while (1)
-    {
-      char intake;
-      int r;
-      EINTRLOOP (r, read (job_fds[0], &intake, 1));
-      if (r != 1)
-        return tokens;
-      ++tokens;
-    }
-}
-
-/* Prepare the jobserver to start a child process.  */
-void
-jobserver_pre_child (int recursive)
-{
-  if (recursive && job_fds[0] >= 0)
-    {
-      fd_inherit (job_fds[0]);
-      fd_inherit (job_fds[1]);
-    }
-}
-
-/* Reconfigure the jobserver after starting a child process.  */
-void
-jobserver_post_child (int recursive)
-{
-  if (recursive && job_fds[0] >= 0)
-    {
-      fd_noinherit (job_fds[0]);
-      fd_noinherit (job_fds[1]);
-    }
-}
-
-void
-jobserver_signal (void)
-{
-  if (job_rfd >= 0)
-    {
-      close (job_rfd);
-      job_rfd = -1;
-    }
-}
-
-void
-jobserver_pre_acquire (void)
-{
-  /* Make sure we have a dup'd FD.  */
-  if (job_rfd < 0 && job_fds[0] >= 0 && make_job_rfd () < 0)
-    pfatal_with_name (_("duping jobs pipe"));
-}
-
-#ifdef HAVE_PSELECT
-
-/* Use pselect() to atomically wait for both a signal and a file descriptor.
-   It also provides a timeout facility so we don't need to use SIGALRM.
-
-   This method relies on the fact that SIGCHLD will be blocked everywhere,
-   and only unblocked (atomically) within the pselect() call, so we can
-   never miss a SIGCHLD.
- */
-unsigned int
-jobserver_acquire (int timeout)
-{
-  struct timespec spec;
-  struct timespec *specp = NULL;
-  sigset_t empty;
-
-  sigemptyset (&empty);
-
-  if (timeout)
-    {
-      /* Alarm after one second (is this too granular?)  */
-      spec.tv_sec = 1;
-      spec.tv_nsec = 0;
-      specp = &spec;
-    }
-
-  while (1)
-    {
-      fd_set readfds;
-      int r;
-      char intake;
-
-      FD_ZERO (&readfds);
-      FD_SET (job_fds[0], &readfds);
-
-      r = pselect (job_fds[0]+1, &readfds, NULL, NULL, specp, &empty);
-      if (r < 0)
-        switch (errno)
-          {
-          case EINTR:
-            /* SIGCHLD will show up as an EINTR.  */
-            return 0;
-
-          case EBADF:
-            /* Someone closed the jobs pipe.
-               That shouldn't happen but if it does we're done.  */
-              O (fatal, NILF, _("job server shut down"));
-
-          default:
-            pfatal_with_name (_("pselect jobs pipe"));
-          }
-
-      if (r == 0)
-        /* Timeout.  */
-        return 0;
-
-      /* The read FD is ready: read it!  This is non-blocking.  */
-      EINTRLOOP (r, read (job_fds[0], &intake, 1));
-
-      if (r < 0)
-        {
-          /* Someone sniped our token!  Try again.  */
-          if (errno == EAGAIN)
-            continue;
-
-          pfatal_with_name (_("read jobs pipe"));
-        }
-
-      /* read() should never return 0: only the master make can reap all the
-         tokens and close the write side...??  */
-      return r > 0;
-    }
-}
-
-#else
-
-/* This method uses a "traditional" UNIX model for waiting on both a signal
-   and a file descriptor.  However, it's complex and since we have a SIGCHLD
-   handler installed we need to check ALL system calls for EINTR: painful!
-
-   Read a token.  As long as there's no token available we'll block.  We
-   enable interruptible system calls before the read(2) so that if we get a
-   SIGCHLD while we're waiting, we'll return with EINTR and we can process the
-   death(s) and return tokens to the free pool.
-
-   Once we return from the read, we immediately reinstate restartable system
-   calls.  This allows us to not worry about checking for EINTR on all the
-   other system calls in the program.
-
-   There is one other twist: there is a span between the time reap_children()
-   does its last check for dead children and the time the read(2) call is
-   entered, below, where if a child dies we won't notice.  This is extremely
-   serious as it could cause us to deadlock, given the right set of events.
-
-   To avoid this, we do the following: before we reap_children(), we dup(2)
-   the read FD on the jobserver pipe.  The read(2) call below uses that new
-   FD.  In the signal handler, we close that FD.  That way, if a child dies
-   during the section mentioned above, the read(2) will be invoked with an
-   invalid FD and will return immediately with EBADF.  */
-
-static RETSIGTYPE
-job_noop (int sig UNUSED)
-{
-}
-
-/* Set the child handler action flags to FLAGS.  */
-static void
-set_child_handler_action_flags (int set_handler, int set_alarm)
-{
-  struct sigaction sa;
-
-#ifdef __EMX__
-  /* The child handler must be turned off here.  */
-  signal (SIGCHLD, SIG_DFL);
-#endif
-
-  memset (&sa, '\0', sizeof sa);
-  sa.sa_handler = child_handler;
-  sa.sa_flags = set_handler ? 0 : SA_RESTART;
-
-#if defined SIGCHLD
-  if (sigaction (SIGCHLD, &sa, NULL) < 0)
-    pfatal_with_name ("sigaction: SIGCHLD");
-#endif
-
-#if defined SIGCLD && SIGCLD != SIGCHLD
-  if (sigaction (SIGCLD, &sa, NULL) < 0)
-    pfatal_with_name ("sigaction: SIGCLD");
-#endif
-
-#if defined SIGALRM
-  if (set_alarm)
-    {
-      /* If we're about to enter the read(), set an alarm to wake up in a
-         second so we can check if the load has dropped and we can start more
-         work.  On the way out, turn off the alarm and set SIG_DFL.  */
-      if (set_handler)
-        {
-          sa.sa_handler = job_noop;
-          sa.sa_flags = 0;
-          if (sigaction (SIGALRM, &sa, NULL) < 0)
-            pfatal_with_name ("sigaction: SIGALRM");
-          alarm (1);
-        }
-      else
-        {
-          alarm (0);
-          sa.sa_handler = SIG_DFL;
-          sa.sa_flags = 0;
-          if (sigaction (SIGALRM, &sa, NULL) < 0)
-            pfatal_with_name ("sigaction: SIGALRM");
-        }
-    }
-#endif
-}
-
-unsigned int
-jobserver_acquire (int timeout)
-{
-  char intake;
-  int got_token;
-  int saved_errno;
-
-  /* Set interruptible system calls, and read() for a job token.  */
-  set_child_handler_action_flags (1, timeout);
-
-  EINTRLOOP (got_token, read (job_rfd, &intake, 1));
-  saved_errno = errno;
-
-  set_child_handler_action_flags (0, timeout);
-
-  if (got_token == 1)
-    return 1;
-
-  /* If the error _wasn't_ expected (EINTR or EBADF), fatal.  Otherwise,
-     go back and reap_children(), and try again.  */
-  errno = saved_errno;
-
-  if (errno != EINTR && errno != EBADF)
-    pfatal_with_name (_("read jobs pipe"));
-
-  if (errno == EBADF)
-    DB (DB_JOBS, ("Read returned EBADF.\n"));
-
-  return 0;
-}
-
-#endif /* HAVE_PSELECT */
-
-#endif /* MAKE_JOBSERVER */
-
-/* Create a "bad" file descriptor for stdin when parallel jobs are run.  */
-int
-get_bad_stdin (void)
-{
-  static int bad_stdin = -1;
-
-  /* Set up a bad standard input that reads from a broken pipe.  */
-
-  if (bad_stdin == -1)
-    {
-      /* Make a file descriptor that is the read end of a broken pipe.
-         This will be used for some children's standard inputs.  */
-      int pd[2];
-      if (pipe (pd) == 0)
-        {
-          /* Close the write side.  */
-          (void) close (pd[1]);
-          /* Save the read side.  */
-          bad_stdin = pd[0];
-
-          /* Set the descriptor to close on exec, so it does not litter any
-             child's descriptor table.  When it is dup2'd onto descriptor 0,
-             that descriptor will not close on exec.  */
-          fd_noinherit (bad_stdin);
-        }
-    }
-
-  return bad_stdin;
-}
-
-/* Set file descriptors to be inherited / not inherited by subprocesses.  */
-
-#if !defined(F_SETFD) || !defined(F_GETFD)
-void fd_inherit (int fd) {}
-void fd_noinherit (int fd) {}
-
-#else
-
-# ifndef FD_CLOEXEC
-#  define FD_CLOEXEC 1
-# endif
-
-void
-fd_inherit (int fd)
-{
-  int flags;
-  EINTRLOOP (flags, fcntl (fd, F_GETFD));
-  if (flags >= 0)
-    {
-      int r;
-      flags &= ~FD_CLOEXEC;
-      EINTRLOOP (r, fcntl (fd, F_SETFD, flags));
-    }
-}
-
-void
-fd_noinherit (int fd)
-{
-    int flags;
-    EINTRLOOP(flags, fcntl(fd, F_GETFD));
-    if (flags >= 0)
-      {
-        int r;
-        flags |= FD_CLOEXEC;
-        EINTRLOOP(r, fcntl(fd, F_SETFD, flags));
-      }
-}
-#endif
diff --git a/prepare_w32.bat b/prepare_w32.bat
deleted file mode 100644
index 7591e27..0000000
--- a/prepare_w32.bat
+++ /dev/null
@@ -1,6 +0,0 @@
-@echo off
-@echo Windows32 SCM build preparation of config.h.W32 and NMakefile.
-if not exist config.h.W32 copy config.h.W32.template config.h.W32
-if not exist config.h copy config.h.W32 config.h
-if not exist NMakefile copy NMakefile.template NMakefile
-@echo Preparation complete.  Run build_w32.bat to compile and link.
diff --git a/read.c b/read.c
deleted file mode 100644
index db1a42d..0000000
--- a/read.c
+++ /dev/null
@@ -1,3394 +0,0 @@
-/* Reading and parsing of makefiles for GNU Make.
-Copyright (C) 1988-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-
-#include <assert.h>
-
-#include "filedef.h"
-#include "dep.h"
-#include "job.h"
-#include "os.h"
-#include "commands.h"
-#include "variable.h"
-#include "rule.h"
-#include "debug.h"
-#include "hash.h"
-
-
-#ifdef WINDOWS32
-#include <windows.h>
-#include "sub_proc.h"
-#else  /* !WINDOWS32 */
-#ifndef _AMIGA
-#ifndef VMS
-#include <pwd.h>
-#else
-struct passwd *getpwnam (char *name);
-#endif
-#endif
-#endif /* !WINDOWS32 */
-
-/* A 'struct ebuffer' controls the origin of the makefile we are currently
-   eval'ing.
-*/
-
-struct ebuffer
-  {
-    char *buffer;       /* Start of the current line in the buffer.  */
-    char *bufnext;      /* Start of the next line in the buffer.  */
-    char *bufstart;     /* Start of the entire buffer.  */
-    unsigned int size;  /* Malloc'd size of buffer. */
-    FILE *fp;           /* File, or NULL if this is an internal buffer.  */
-    floc floc;          /* Info on the file in fp (if any).  */
-  };
-
-/* Track the modifiers we can have on variable assignments */
-
-struct vmodifiers
-  {
-    unsigned int assign_v:1;
-    unsigned int define_v:1;
-    unsigned int undefine_v:1;
-    unsigned int export_v:1;
-    unsigned int override_v:1;
-    unsigned int private_v:1;
-  };
-
-/* Types of "words" that can be read in a makefile.  */
-enum make_word_type
-  {
-     w_bogus, w_eol, w_static, w_variable, w_colon, w_dcolon, w_semicolon,
-     w_varassign
-  };
-
-
-/* A 'struct conditionals' contains the information describing
-   all the active conditionals in a makefile.
-
-   The global variable 'conditionals' contains the conditionals
-   information for the current makefile.  It is initialized from
-   the static structure 'toplevel_conditionals' and is later changed
-   to new structures for included makefiles.  */
-
-struct conditionals
-  {
-    unsigned int if_cmds;       /* Depth of conditional nesting.  */
-    unsigned int allocated;     /* Elts allocated in following arrays.  */
-    char *ignoring;             /* Are we ignoring or interpreting?
-                                   0=interpreting, 1=not yet interpreted,
-                                   2=already interpreted */
-    char *seen_else;            /* Have we already seen an 'else'?  */
-  };
-
-static struct conditionals toplevel_conditionals;
-static struct conditionals *conditionals = &toplevel_conditionals;
-
-
-/* Default directories to search for include files in  */
-
-static const char *default_include_directories[] =
-  {
-#if defined(WINDOWS32) && !defined(INCLUDEDIR)
-/* This completely up to the user when they install MSVC or other packages.
-   This is defined as a placeholder.  */
-# define INCLUDEDIR "."
-#endif
-    INCLUDEDIR,
-#ifndef _AMIGA
-    "/usr/gnu/include",
-    "/usr/local/include",
-    "/usr/include",
-#endif
-    0
-  };
-
-/* List of directories to search for include files in  */
-
-static const char **include_directories;
-
-/* Maximum length of an element of the above.  */
-
-static unsigned int max_incl_len;
-
-/* The filename and pointer to line number of the
-   makefile currently being read in.  */
-
-const floc *reading_file = 0;
-
-/* The chain of files read by read_all_makefiles.  */
-
-static struct goaldep *read_files = 0;
-
-static struct goaldep *eval_makefile (const char *filename, int flags);
-static void eval (struct ebuffer *buffer, int flags);
-
-static long readline (struct ebuffer *ebuf);
-static void do_undefine (char *name, enum variable_origin origin,
-                         struct ebuffer *ebuf);
-static struct variable *do_define (char *name, enum variable_origin origin,
-                                   struct ebuffer *ebuf);
-static int conditional_line (char *line, int len, const floc *flocp);
-static void record_files (struct nameseq *filenames, const char *pattern,
-                          const char *pattern_percent, char *depstr,
-                          unsigned int cmds_started, char *commands,
-                          unsigned int commands_idx, int two_colon,
-                          char prefix, const floc *flocp);
-static void record_target_var (struct nameseq *filenames, char *defn,
-                               enum variable_origin origin,
-                               struct vmodifiers *vmod,
-                               const floc *flocp);
-static enum make_word_type get_next_mword (char *buffer, char *delim,
-                                           char **startp, unsigned int *length);
-static void remove_comments (char *line);
-static char *find_map_unquote (char *string, int map);
-static char *find_char_unquote (char *string, int stop);
-static char *unescape_char (char *string, int c);
-
-
-/* Compare a word, both length and contents.
-   P must point to the word to be tested, and WLEN must be the length.
-*/
-#define word1eq(s)      (wlen == CSTRLEN (s) && strneq (s, p, CSTRLEN (s)))
-
-
-/* Read in all the makefiles and return a chain of targets to rebuild.  */
-
-struct goaldep *
-read_all_makefiles (const char **makefiles)
-{
-  unsigned int num_makefiles = 0;
-
-  /* Create *_LIST variables, to hold the makefiles, targets, and variables
-     we will be reading. */
-
-  define_variable_cname ("MAKEFILE_LIST", "", o_file, 0);
-
-  DB (DB_BASIC, (_("Reading makefiles...\n")));
-
-  /* If there's a non-null variable MAKEFILES, its value is a list of
-     files to read first thing.  But don't let it prevent reading the
-     default makefiles and don't let the default goal come from there.  */
-
-  {
-    char *value;
-    char *name, *p;
-    unsigned int length;
-
-    {
-      /* Turn off --warn-undefined-variables while we expand MAKEFILES.  */
-      int save = warn_undefined_variables_flag;
-      warn_undefined_variables_flag = 0;
-
-      value = allocated_variable_expand ("$(MAKEFILES)");
-
-      warn_undefined_variables_flag = save;
-    }
-
-    /* Set NAME to the start of next token and LENGTH to its length.
-       MAKEFILES is updated for finding remaining tokens.  */
-    p = value;
-
-    while ((name = find_next_token ((const char **)&p, &length)) != 0)
-      {
-        if (*p != '\0')
-          *p++ = '\0';
-        eval_makefile (strcache_add (name), RM_NO_DEFAULT_GOAL|RM_INCLUDED|RM_DONTCARE);
-      }
-
-    free (value);
-  }
-
-  /* Read makefiles specified with -f switches.  */
-
-  if (makefiles != 0)
-    while (*makefiles != 0)
-      {
-        struct goaldep *d = eval_makefile (*makefiles, 0);
-
-        if (errno)
-          perror_with_name ("", *makefiles);
-
-        /* Reuse the storage allocated for the read_file.  */
-        *makefiles = dep_name (d);
-        ++num_makefiles;
-        ++makefiles;
-      }
-
-  /* If there were no -f switches, try the default names.  */
-
-  if (num_makefiles == 0)
-    {
-      static const char *default_makefiles[] =
-#ifdef VMS
-        /* all lower case since readdir() (the vms version) 'lowercasifies' */
-        /* TODO: Above is not always true, this needs more work */
-        { "makefile.vms", "gnumakefile", "makefile", 0 };
-#else
-#ifdef _AMIGA
-        { "GNUmakefile", "Makefile", "SMakefile", 0 };
-#else /* !Amiga && !VMS */
-#ifdef WINDOWS32
-        { "GNUmakefile", "makefile", "Makefile", "makefile.mak", 0 };
-#else /* !Amiga && !VMS && !WINDOWS32 */
-        { "GNUmakefile", "makefile", "Makefile", 0 };
-#endif /* !Amiga && !VMS && !WINDOWS32 */
-#endif /* AMIGA */
-#endif /* VMS */
-      const char **p = default_makefiles;
-      while (*p != 0 && !file_exists_p (*p))
-        ++p;
-
-      if (*p != 0)
-        {
-          eval_makefile (*p, 0);
-          if (errno)
-            perror_with_name ("", *p);
-        }
-      else
-        {
-          /* No default makefile was found.  Add the default makefiles to the
-             'read_files' chain so they will be updated if possible.  */
-          struct goaldep *tail = read_files;
-          /* Add them to the tail, after any MAKEFILES variable makefiles.  */
-          while (tail != 0 && tail->next != 0)
-            tail = tail->next;
-          for (p = default_makefiles; *p != 0; ++p)
-            {
-              struct goaldep *d = alloc_goaldep ();
-              d->file = enter_file (strcache_add (*p));
-              /* Tell update_goal_chain to bail out as soon as this file is
-                 made, and main not to die if we can't make this file.  */
-              d->flags = RM_DONTCARE;
-              if (tail == 0)
-                read_files = d;
-              else
-                tail->next = d;
-              tail = d;
-            }
-          if (tail != 0)
-            tail->next = 0;
-        }
-    }
-
-  return read_files;
-}
-
-/* Install a new conditional and return the previous one.  */
-
-static struct conditionals *
-install_conditionals (struct conditionals *new)
-{
-  struct conditionals *save = conditionals;
-
-  memset (new, '\0', sizeof (*new));
-  conditionals = new;
-
-  return save;
-}
-
-/* Free the current conditionals and reinstate a saved one.  */
-
-static void
-restore_conditionals (struct conditionals *saved)
-{
-  /* Free any space allocated by conditional_line.  */
-  free (conditionals->ignoring);
-  free (conditionals->seen_else);
-
-  /* Restore state.  */
-  conditionals = saved;
-}
-
-static struct goaldep *
-eval_makefile (const char *filename, int flags)
-{
-  struct goaldep *deps;
-  struct ebuffer ebuf;
-  const floc *curfile;
-  char *expanded = 0;
-
-  /* Create a new goaldep entry.  */
-  deps = alloc_goaldep ();
-  deps->next = read_files;
-  read_files = deps;
-
-  ebuf.floc.filenm = filename; /* Use the original file name.  */
-  ebuf.floc.lineno = 1;
-  ebuf.floc.offset = 0;
-
-  if (ISDB (DB_VERBOSE))
-    {
-      printf (_("Reading makefile '%s'"), filename);
-      if (flags & RM_NO_DEFAULT_GOAL)
-        printf (_(" (no default goal)"));
-      if (flags & RM_INCLUDED)
-        printf (_(" (search path)"));
-      if (flags & RM_DONTCARE)
-        printf (_(" (don't care)"));
-      if (flags & RM_NO_TILDE)
-        printf (_(" (no ~ expansion)"));
-      puts ("...");
-    }
-
-  /* First, get a stream to read.  */
-
-  /* Expand ~ in FILENAME unless it came from 'include',
-     in which case it was already done.  */
-  if (!(flags & RM_NO_TILDE) && filename[0] == '~')
-    {
-      expanded = tilde_expand (filename);
-      if (expanded != 0)
-        filename = expanded;
-    }
-
-  errno = 0;
-  ENULLLOOP (ebuf.fp, fopen (filename, "r"));
-  deps->error = errno;
-
-  /* Check for unrecoverable errors: out of mem or FILE slots.  */
-  switch (deps->error)
-    {
-#ifdef EMFILE
-    case EMFILE:
-#endif
-#ifdef ENFILE
-    case ENFILE:
-#endif
-    case ENOMEM:
-      {
-        const char *err = strerror (deps->error);
-        OS (fatal, reading_file, "%s", err);
-      }
-    }
-
-  /* If the makefile wasn't found and it's either a makefile from
-     the 'MAKEFILES' variable or an included makefile,
-     search the included makefile search path for this makefile.  */
-  if (ebuf.fp == 0 && (flags & RM_INCLUDED) && *filename != '/')
-    {
-      unsigned int i;
-      for (i = 0; include_directories[i] != 0; ++i)
-        {
-          const char *included = concat (3, include_directories[i],
-                                         "/", filename);
-          ebuf.fp = fopen (included, "r");
-          if (ebuf.fp)
-            {
-              filename = included;
-              break;
-            }
-        }
-    }
-
-  /* Enter the final name for this makefile as a goaldep.  */
-  filename = strcache_add (filename);
-  deps->file = lookup_file (filename);
-  if (deps->file == 0)
-    deps->file = enter_file (filename);
-  filename = deps->file->name;
-  deps->flags = flags;
-
-  free (expanded);
-
-  if (ebuf.fp == 0)
-    {
-      /* The makefile can't be read at all, give up entirely.
-         If we did some searching errno has the error from the last attempt,
-         rather from FILENAME itself: recover the more accurate one.  */
-      errno = deps->error;
-      deps->file->last_mtime = NONEXISTENT_MTIME;
-      return deps;
-    }
-
-  /* Success; clear errno.  */
-  deps->error = 0;
-
-  /* Avoid leaking the makefile to children.  */
-  fd_noinherit (fileno (ebuf.fp));
-
-  /* Add this makefile to the list. */
-  do_variable_definition (&ebuf.floc, "MAKEFILE_LIST", filename, o_file,
-                          f_append_value, 0);
-
-  /* Evaluate the makefile */
-
-  ebuf.size = 200;
-  ebuf.buffer = ebuf.bufnext = ebuf.bufstart = xmalloc (ebuf.size);
-
-  curfile = reading_file;
-  reading_file = &ebuf.floc;
-
-  eval (&ebuf, !(flags & RM_NO_DEFAULT_GOAL));
-
-  reading_file = curfile;
-
-  fclose (ebuf.fp);
-
-  free (ebuf.bufstart);
-  alloca (0);
-
-  errno = 0;
-  return deps;
-}
-
-void
-eval_buffer (char *buffer, const floc *flocp)
-{
-  struct ebuffer ebuf;
-  struct conditionals *saved;
-  struct conditionals new;
-  const floc *curfile;
-
-  /* Evaluate the buffer */
-
-  ebuf.size = strlen (buffer);
-  ebuf.buffer = ebuf.bufnext = ebuf.bufstart = buffer;
-  ebuf.fp = NULL;
-
-  if (flocp)
-    ebuf.floc = *flocp;
-  else if (reading_file)
-    ebuf.floc = *reading_file;
-  else
-    {
-      ebuf.floc.filenm = NULL;
-      ebuf.floc.lineno = 1;
-      ebuf.floc.offset = 0;
-    }
-
-  curfile = reading_file;
-  reading_file = &ebuf.floc;
-
-  saved = install_conditionals (&new);
-
-  eval (&ebuf, 1);
-
-  restore_conditionals (saved);
-
-  reading_file = curfile;
-
-  alloca (0);
-}
-
-/* Check LINE to see if it's a variable assignment or undefine.
-
-   It might use one of the modifiers "export", "override", "private", or it
-   might be one of the conditional tokens like "ifdef", "include", etc.
-
-   If it's not a variable assignment or undefine, VMOD.V_ASSIGN is 0.
-   Returns LINE.
-
-   Returns a pointer to the first non-modifier character, and sets VMOD
-   based on the modifiers found if any, plus V_ASSIGN is 1.
- */
-static char *
-parse_var_assignment (const char *line, struct vmodifiers *vmod)
-{
-  const char *p;
-  memset (vmod, '\0', sizeof (*vmod));
-
-  /* Find the start of the next token.  If there isn't one we're done.  */
-  NEXT_TOKEN (line);
-  if (*line == '\0')
-    return (char *)line;
-
-  p = line;
-  while (1)
-    {
-      int wlen;
-      const char *p2;
-      struct variable v;
-
-      p2 = parse_variable_definition (p, &v);
-
-      /* If this is a variable assignment, we're done.  */
-      if (p2)
-        break;
-
-      /* It's not a variable; see if it's a modifier.  */
-      p2 = end_of_token (p);
-      wlen = p2 - p;
-
-      if (word1eq ("export"))
-        vmod->export_v = 1;
-      else if (word1eq ("override"))
-        vmod->override_v = 1;
-      else if (word1eq ("private"))
-        vmod->private_v = 1;
-      else if (word1eq ("define"))
-        {
-          /* We can't have modifiers after 'define' */
-          vmod->define_v = 1;
-          p = next_token (p2);
-          break;
-        }
-      else if (word1eq ("undefine"))
-        {
-          /* We can't have modifiers after 'undefine' */
-          vmod->undefine_v = 1;
-          p = next_token (p2);
-          break;
-        }
-      else
-        /* Not a variable or modifier: this is not a variable assignment.  */
-        return (char *)line;
-
-      /* It was a modifier.  Try the next word.  */
-      p = next_token (p2);
-      if (*p == '\0')
-        return (char *)line;
-    }
-
-  /* Found a variable assignment or undefine.  */
-  vmod->assign_v = 1;
-  return (char *)p;
-}
-
-
-/* Read file FILENAME as a makefile and add its contents to the data base.
-
-   SET_DEFAULT is true if we are allowed to set the default goal.  */
-
-static void
-eval (struct ebuffer *ebuf, int set_default)
-{
-  char *collapsed = 0;
-  unsigned int collapsed_length = 0;
-  unsigned int commands_len = 200;
-  char *commands;
-  unsigned int commands_idx = 0;
-  unsigned int cmds_started, tgts_started;
-  int ignoring = 0, in_ignored_define = 0;
-  int no_targets = 0;           /* Set when reading a rule without targets.  */
-  struct nameseq *filenames = 0;
-  char *depstr = 0;
-  long nlines = 0;
-  int two_colon = 0;
-  char prefix = cmd_prefix;
-  const char *pattern = 0;
-  const char *pattern_percent;
-  floc *fstart;
-  floc fi;
-
-#define record_waiting_files()                                                \
-  do                                                                          \
-    {                                                                         \
-      if (filenames != 0)                                                     \
-        {                                                                     \
-          fi.lineno = tgts_started;                                           \
-          fi.offset = 0;                                                      \
-          record_files (filenames, pattern, pattern_percent, depstr,          \
-                        cmds_started, commands, commands_idx, two_colon,      \
-                        prefix, &fi);                                         \
-          filenames = 0;                                                      \
-        }                                                                     \
-      commands_idx = 0;                                                       \
-      no_targets = 0;                                                         \
-      pattern = 0;                                                            \
-    } while (0)
-
-  pattern_percent = 0;
-  cmds_started = tgts_started = 1;
-
-  fstart = &ebuf->floc;
-  fi.filenm = ebuf->floc.filenm;
-
-  /* Loop over lines in the file.
-     The strategy is to accumulate target names in FILENAMES, dependencies
-     in DEPS and commands in COMMANDS.  These are used to define a rule
-     when the start of the next rule (or eof) is encountered.
-
-     When you see a "continue" in the loop below, that means we are moving on
-     to the next line.  If you see record_waiting_files(), then the statement
-     we are parsing also finishes the previous rule.  */
-
-  commands = xmalloc (200);
-
-  while (1)
-    {
-      unsigned int linelen;
-      char *line;
-      unsigned int wlen;
-      char *p;
-      char *p2;
-      struct vmodifiers vmod;
-
-      /* At the top of this loop, we are starting a brand new line.  */
-      /* Grab the next line to be evaluated */
-      ebuf->floc.lineno += nlines;
-      nlines = readline (ebuf);
-
-      /* If there is nothing left to eval, we're done.  */
-      if (nlines < 0)
-        break;
-
-      line = ebuf->buffer;
-
-      /* If this is the first line, check for a UTF-8 BOM and skip it.  */
-      if (ebuf->floc.lineno == 1 && line[0] == (char)0xEF
-          && line[1] == (char)0xBB && line[2] == (char)0xBF)
-        {
-          line += 3;
-          if (ISDB(DB_BASIC))
-            {
-              if (ebuf->floc.filenm)
-                printf (_("Skipping UTF-8 BOM in makefile '%s'\n"),
-                        ebuf->floc.filenm);
-              else
-                printf (_("Skipping UTF-8 BOM in makefile buffer\n"));
-            }
-        }
-
-      /* If this line is empty, skip it.  */
-      if (line[0] == '\0')
-        continue;
-
-      linelen = strlen (line);
-
-      /* Check for a shell command line first.
-         If it is not one, we can stop treating cmd_prefix specially.  */
-      if (line[0] == cmd_prefix)
-        {
-          if (no_targets)
-            /* Ignore the commands in a rule with no targets.  */
-            continue;
-
-          /* If there is no preceding rule line, don't treat this line
-             as a command, even though it begins with a recipe prefix.
-             SunOS 4 make appears to behave this way.  */
-
-          if (filenames != 0)
-            {
-              if (ignoring)
-                /* Yep, this is a shell command, and we don't care.  */
-                continue;
-
-              if (commands_idx == 0)
-                cmds_started = ebuf->floc.lineno;
-
-              /* Append this command line to the line being accumulated.
-                 Skip the initial command prefix character.  */
-              if (linelen + commands_idx > commands_len)
-                {
-                  commands_len = (linelen + commands_idx) * 2;
-                  commands = xrealloc (commands, commands_len);
-                }
-              memcpy (&commands[commands_idx], line + 1, linelen - 1);
-              commands_idx += linelen - 1;
-              commands[commands_idx++] = '\n';
-              continue;
-            }
-        }
-
-      /* This line is not a shell command line.  Don't worry about whitespace.
-         Get more space if we need it; we don't need to preserve the current
-         contents of the buffer.  */
-
-      if (collapsed_length < linelen+1)
-        {
-          collapsed_length = linelen+1;
-          free (collapsed);
-          /* Don't need xrealloc: we don't need to preserve the content.  */
-          collapsed = xmalloc (collapsed_length);
-        }
-      strcpy (collapsed, line);
-      /* Collapse continuation lines.  */
-      collapse_continuations (collapsed);
-      remove_comments (collapsed);
-
-      /* Get rid if starting space (including formfeed, vtab, etc.)  */
-      p = collapsed;
-      NEXT_TOKEN (p);
-
-      /* See if this is a variable assignment.  We need to do this early, to
-         allow variables with names like 'ifdef', 'export', 'private', etc.  */
-      p = parse_var_assignment (p, &vmod);
-      if (vmod.assign_v)
-        {
-          struct variable *v;
-          enum variable_origin origin = vmod.override_v ? o_override : o_file;
-
-          /* If we're ignoring then we're done now.  */
-          if (ignoring)
-            {
-              if (vmod.define_v)
-                in_ignored_define = 1;
-              continue;
-            }
-
-          /* Variable assignment ends the previous rule.  */
-          record_waiting_files ();
-
-          if (vmod.undefine_v)
-          {
-            do_undefine (p, origin, ebuf);
-            continue;
-          }
-          else if (vmod.define_v)
-            v = do_define (p, origin, ebuf);
-          else
-            v = try_variable_definition (fstart, p, origin, 0);
-
-          assert (v != NULL);
-
-          if (vmod.export_v)
-            v->export = v_export;
-          if (vmod.private_v)
-            v->private_var = 1;
-
-          /* This line has been dealt with.  */
-          continue;
-        }
-
-      /* If this line is completely empty, ignore it.  */
-      if (*p == '\0')
-        continue;
-
-      p2 = end_of_token (p);
-      wlen = p2 - p;
-      NEXT_TOKEN (p2);
-
-      /* If we're in an ignored define, skip this line (but maybe get out).  */
-      if (in_ignored_define)
-        {
-          /* See if this is an endef line (plus optional comment).  */
-          if (word1eq ("endef") && STOP_SET (*p2, MAP_COMMENT|MAP_NUL))
-            in_ignored_define = 0;
-
-          continue;
-        }
-
-      /* Check for conditional state changes.  */
-      {
-        int i = conditional_line (p, wlen, fstart);
-        if (i != -2)
-          {
-            if (i == -1)
-              O (fatal, fstart, _("invalid syntax in conditional"));
-
-            ignoring = i;
-            continue;
-          }
-      }
-
-      /* Nothing to see here... move along.  */
-      if (ignoring)
-        continue;
-
-      /* Manage the "export" keyword used outside of variable assignment
-         as well as "unexport".  */
-      if (word1eq ("export") || word1eq ("unexport"))
-        {
-          int exporting = *p == 'u' ? 0 : 1;
-
-          /* Export/unexport ends the previous rule.  */
-          record_waiting_files ();
-
-          /* (un)export by itself causes everything to be (un)exported. */
-          if (*p2 == '\0')
-            export_all_variables = exporting;
-          else
-            {
-              unsigned int l;
-              const char *cp;
-              char *ap;
-
-              /* Expand the line so we can use indirect and constructed
-                 variable names in an (un)export command.  */
-              cp = ap = allocated_variable_expand (p2);
-
-              for (p = find_next_token (&cp, &l); p != 0;
-                   p = find_next_token (&cp, &l))
-                {
-                  struct variable *v = lookup_variable (p, l);
-                  if (v == 0)
-                    v = define_variable_global (p, l, "", o_file, 0, fstart);
-                  v->export = exporting ? v_export : v_noexport;
-                }
-
-              free (ap);
-            }
-          continue;
-        }
-
-      /* Handle the special syntax for vpath.  */
-      if (word1eq ("vpath"))
-        {
-          const char *cp;
-          char *vpat;
-          unsigned int l;
-
-          /* vpath ends the previous rule.  */
-          record_waiting_files ();
-
-          cp = variable_expand (p2);
-          p = find_next_token (&cp, &l);
-          if (p != 0)
-            {
-              vpat = xstrndup (p, l);
-              p = find_next_token (&cp, &l);
-              /* No searchpath means remove all previous
-                 selective VPATH's with the same pattern.  */
-            }
-          else
-            /* No pattern means remove all previous selective VPATH's.  */
-            vpat = 0;
-          construct_vpath_list (vpat, p);
-          free (vpat);
-
-          continue;
-        }
-
-      /* Handle include and variants.  */
-      if (word1eq ("include") || word1eq ("-include") || word1eq ("sinclude"))
-        {
-          /* We have found an 'include' line specifying a nested
-             makefile to be read at this point.  */
-          struct conditionals *save;
-          struct conditionals new_conditionals;
-          struct nameseq *files;
-          /* "-include" (vs "include") says no error if the file does not
-             exist.  "sinclude" is an alias for this from SGI.  */
-          int noerror = (p[0] != 'i');
-
-          /* Include ends the previous rule.  */
-          record_waiting_files ();
-
-          p = allocated_variable_expand (p2);
-
-          /* If no filenames, it's a no-op.  */
-          if (*p == '\0')
-            {
-              free (p);
-              continue;
-            }
-
-          /* Parse the list of file names.  Don't expand archive references!  */
-          p2 = p;
-          files = PARSE_FILE_SEQ (&p2, struct nameseq, MAP_NUL, NULL,
-                                  PARSEFS_NOAR);
-          free (p);
-
-          /* Save the state of conditionals and start
-             the included makefile with a clean slate.  */
-          save = install_conditionals (&new_conditionals);
-
-          /* Record the rules that are waiting so they will determine
-             the default goal before those in the included makefile.  */
-          record_waiting_files ();
-
-          /* Read each included makefile.  */
-          while (files != 0)
-            {
-              struct nameseq *next = files->next;
-              int flags = (RM_INCLUDED | RM_NO_TILDE
-                           | (noerror ? RM_DONTCARE : 0)
-                           | (set_default ? 0 : RM_NO_DEFAULT_GOAL));
-
-              struct goaldep *d = eval_makefile (files->name, flags);
-
-              if (errno)
-                d->floc = *fstart;
-
-              free_ns (files);
-              files = next;
-            }
-
-          /* Restore conditional state.  */
-          restore_conditionals (save);
-
-          continue;
-        }
-
-      /* Handle the load operations.  */
-      if (word1eq ("load") || word1eq ("-load"))
-        {
-          /* A 'load' line specifies a dynamic object to load.  */
-          struct nameseq *files;
-          int noerror = (p[0] == '-');
-
-          /* Load ends the previous rule.  */
-          record_waiting_files ();
-
-          p = allocated_variable_expand (p2);
-
-          /* If no filenames, it's a no-op.  */
-          if (*p == '\0')
-            {
-              free (p);
-              continue;
-            }
-
-          /* Parse the list of file names.
-             Don't expand archive references or strip "./"  */
-          p2 = p;
-          files = PARSE_FILE_SEQ (&p2, struct nameseq, MAP_NUL, NULL,
-                                  PARSEFS_NOAR);
-          free (p);
-
-          /* Load each file.  */
-          while (files != 0)
-            {
-              struct nameseq *next = files->next;
-              const char *name = files->name;
-              struct goaldep *deps;
-              int r;
-
-              /* Load the file.  0 means failure.  */
-              r = load_file (&ebuf->floc, &name, noerror);
-              if (! r && ! noerror)
-                OS (fatal, &ebuf->floc, _("%s: failed to load"), name);
-
-              free_ns (files);
-              files = next;
-
-              /* Return of -1 means a special load: don't rebuild it.  */
-              if (r == -1)
-                continue;
-
-              /* It succeeded, so add it to the list "to be rebuilt".  */
-              deps = alloc_goaldep ();
-              deps->next = read_files;
-              read_files = deps;
-              deps->file = lookup_file (name);
-              if (deps->file == 0)
-                deps->file = enter_file (name);
-              deps->file->loaded = 1;
-            }
-
-          continue;
-        }
-
-      /* This line starts with a tab but was not caught above because there
-         was no preceding target, and the line might have been usable as a
-         variable definition.  But now we know it is definitely lossage.  */
-      if (line[0] == cmd_prefix)
-        O (fatal, fstart, _("recipe commences before first target"));
-
-      /* This line describes some target files.  This is complicated by
-         the existence of target-specific variables, because we can't
-         expand the entire line until we know if we have one or not.  So
-         we expand the line word by word until we find the first ':',
-         then check to see if it's a target-specific variable.
-
-         In this algorithm, 'lb_next' will point to the beginning of the
-         unexpanded parts of the input buffer, while 'p2' points to the
-         parts of the expanded buffer we haven't searched yet. */
-
-      {
-        enum make_word_type wtype;
-        char *cmdleft, *semip, *lb_next;
-        unsigned int plen = 0;
-        char *colonp;
-        const char *end, *beg; /* Helpers for whitespace stripping. */
-
-        /* Record the previous rule.  */
-
-        record_waiting_files ();
-        tgts_started = fstart->lineno;
-
-        /* Search the line for an unquoted ; that is not after an
-           unquoted #.  */
-        cmdleft = find_map_unquote (line, MAP_SEMI|MAP_COMMENT|MAP_VARIABLE);
-        if (cmdleft != 0 && *cmdleft == '#')
-          {
-            /* We found a comment before a semicolon.  */
-            *cmdleft = '\0';
-            cmdleft = 0;
-          }
-        else if (cmdleft != 0)
-          /* Found one.  Cut the line short there before expanding it.  */
-          *(cmdleft++) = '\0';
-        semip = cmdleft;
-
-        collapse_continuations (line);
-
-        /* We can't expand the entire line, since if it's a per-target
-           variable we don't want to expand it.  So, walk from the
-           beginning, expanding as we go, and looking for "interesting"
-           chars.  The first word is always expandable.  */
-        wtype = get_next_mword (line, NULL, &lb_next, &wlen);
-        switch (wtype)
-          {
-          case w_eol:
-            if (cmdleft != 0)
-              O (fatal, fstart, _("missing rule before recipe"));
-            /* This line contained something but turned out to be nothing
-               but whitespace (a comment?).  */
-            continue;
-
-          case w_colon:
-          case w_dcolon:
-            /* We accept and ignore rules without targets for
-               compatibility with SunOS 4 make.  */
-            no_targets = 1;
-            continue;
-
-          default:
-            break;
-          }
-
-        p2 = variable_expand_string (NULL, lb_next, wlen);
-
-        while (1)
-          {
-            lb_next += wlen;
-            if (cmdleft == 0)
-              {
-                /* Look for a semicolon in the expanded line.  */
-                cmdleft = find_char_unquote (p2, ';');
-
-                if (cmdleft != 0)
-                  {
-                    unsigned long p2_off = p2 - variable_buffer;
-                    unsigned long cmd_off = cmdleft - variable_buffer;
-                    char *pend = p2 + strlen (p2);
-
-                    /* Append any remnants of lb, then cut the line short
-                       at the semicolon.  */
-                    *cmdleft = '\0';
-
-                    /* One school of thought says that you shouldn't expand
-                       here, but merely copy, since now you're beyond a ";"
-                       and into a command script.  However, the old parser
-                       expanded the whole line, so we continue that for
-                       backwards-compatibility.  Also, it wouldn't be
-                       entirely consistent, since we do an unconditional
-                       expand below once we know we don't have a
-                       target-specific variable. */
-                    (void)variable_expand_string (pend, lb_next, (long)-1);
-                    lb_next += strlen (lb_next);
-                    p2 = variable_buffer + p2_off;
-                    cmdleft = variable_buffer + cmd_off + 1;
-                  }
-              }
-
-            colonp = find_char_unquote (p2, ':');
-#ifdef HAVE_DOS_PATHS
-            /* The drive spec brain-damage strikes again...  */
-            /* Note that the only separators of targets in this context
-               are whitespace and a left paren.  If others are possible,
-               they should be added to the string in the call to index.  */
-            while (colonp && (colonp[1] == '/' || colonp[1] == '\\') &&
-                   colonp > p2 && isalpha ((unsigned char)colonp[-1]) &&
-                   (colonp == p2 + 1 || strchr (" \t(", colonp[-2]) != 0))
-              colonp = find_char_unquote (colonp + 1, ':');
-#endif
-            if (colonp != 0)
-              break;
-
-            wtype = get_next_mword (lb_next, NULL, &lb_next, &wlen);
-            if (wtype == w_eol)
-              break;
-
-            p2 += strlen (p2);
-            *(p2++) = ' ';
-            p2 = variable_expand_string (p2, lb_next, wlen);
-            /* We don't need to worry about cmdleft here, because if it was
-               found in the variable_buffer the entire buffer has already
-               been expanded... we'll never get here.  */
-          }
-
-        p2 = next_token (variable_buffer);
-
-        /* If the word we're looking at is EOL, see if there's _anything_
-           on the line.  If not, a variable expanded to nothing, so ignore
-           it.  If so, we can't parse this line so punt.  */
-        if (wtype == w_eol)
-          {
-            if (*p2 == '\0')
-              continue;
-
-            /* There's no need to be ivory-tower about this: check for
-               one of the most common bugs found in makefiles...  */
-            if (cmd_prefix == '\t' && strneq (line, "        ", 8))
-              O (fatal, fstart, _("missing separator (did you mean TAB instead of 8 spaces?)"));
-            else
-              O (fatal, fstart, _("missing separator"));
-          }
-
-        /* Make the colon the end-of-string so we know where to stop
-           looking for targets.  Start there again once we're done.  */
-        *colonp = '\0';
-        filenames = PARSE_SIMPLE_SEQ (&p2, struct nameseq);
-        *colonp = ':';
-        p2 = colonp;
-
-        if (!filenames)
-          {
-            /* We accept and ignore rules without targets for
-               compatibility with SunOS 4 make.  */
-            no_targets = 1;
-            continue;
-          }
-        /* This should never be possible; we handled it above.  */
-        assert (*p2 != '\0');
-        ++p2;
-
-        /* Is this a one-colon or two-colon entry?  */
-        two_colon = *p2 == ':';
-        if (two_colon)
-          p2++;
-
-        /* Test to see if it's a target-specific variable.  Copy the rest
-           of the buffer over, possibly temporarily (we'll expand it later
-           if it's not a target-specific variable).  PLEN saves the length
-           of the unparsed section of p2, for later.  */
-        if (*lb_next != '\0')
-          {
-            unsigned int l = p2 - variable_buffer;
-            plen = strlen (p2);
-            variable_buffer_output (p2+plen, lb_next, strlen (lb_next)+1);
-            p2 = variable_buffer + l;
-          }
-
-        p2 = parse_var_assignment (p2, &vmod);
-        if (vmod.assign_v)
-          {
-            /* If there was a semicolon found, add it back, plus anything
-               after it.  */
-            if (semip)
-              {
-                unsigned int l = p2 - variable_buffer;
-                *(--semip) = ';';
-                collapse_continuations (semip);
-                variable_buffer_output (p2 + strlen (p2),
-                                        semip, strlen (semip)+1);
-                p2 = variable_buffer + l;
-              }
-            record_target_var (filenames, p2,
-                               vmod.override_v ? o_override : o_file,
-                               &vmod, fstart);
-            filenames = 0;
-            continue;
-          }
-
-        /* This is a normal target, _not_ a target-specific variable.
-           Unquote any = in the dependency list.  */
-        find_char_unquote (lb_next, '=');
-
-        /* Remember the command prefix for this target.  */
-        prefix = cmd_prefix;
-
-        /* We have some targets, so don't ignore the following commands.  */
-        no_targets = 0;
-
-        /* Expand the dependencies, etc.  */
-        if (*lb_next != '\0')
-          {
-            unsigned int l = p2 - variable_buffer;
-            (void) variable_expand_string (p2 + plen, lb_next, (long)-1);
-            p2 = variable_buffer + l;
-
-            /* Look for a semicolon in the expanded line.  */
-            if (cmdleft == 0)
-              {
-                cmdleft = find_char_unquote (p2, ';');
-                if (cmdleft != 0)
-                  *(cmdleft++) = '\0';
-              }
-          }
-
-        /* Is this a static pattern rule: 'target: %targ: %dep; ...'?  */
-        p = strchr (p2, ':');
-        while (p != 0 && p[-1] == '\\')
-          {
-            char *q = &p[-1];
-            int backslash = 0;
-            while (*q-- == '\\')
-              backslash = !backslash;
-            if (backslash)
-              p = strchr (p + 1, ':');
-            else
-              break;
-          }
-#ifdef _AMIGA
-        /* Here, the situation is quite complicated. Let's have a look
-           at a couple of targets:
-
-           install: dev:make
-
-           dev:make: make
-
-           dev:make:: xyz
-
-           The rule is that it's only a target, if there are TWO :'s
-           OR a space around the :.
-        */
-        if (p && !(ISSPACE (p[1]) || !p[1] || ISSPACE (p[-1])))
-          p = 0;
-#endif
-#ifdef HAVE_DOS_PATHS
-        {
-          int check_again;
-          do {
-            check_again = 0;
-            /* For DOS-style paths, skip a "C:\..." or a "C:/..." */
-            if (p != 0 && (p[1] == '\\' || p[1] == '/') &&
-                isalpha ((unsigned char)p[-1]) &&
-                (p == p2 + 1 || strchr (" \t:(", p[-2]) != 0)) {
-              p = strchr (p + 1, ':');
-              check_again = 1;
-            }
-          } while (check_again);
-        }
-#endif
-        if (p != 0)
-          {
-            struct nameseq *target;
-            target = PARSE_FILE_SEQ (&p2, struct nameseq, MAP_COLON, NULL,
-                                     PARSEFS_NOGLOB);
-            ++p2;
-            if (target == 0)
-              O (fatal, fstart, _("missing target pattern"));
-            else if (target->next != 0)
-              O (fatal, fstart, _("multiple target patterns"));
-            pattern_percent = find_percent_cached (&target->name);
-            pattern = target->name;
-            if (pattern_percent == 0)
-              O (fatal, fstart, _("target pattern contains no '%%'"));
-            free_ns (target);
-          }
-        else
-          pattern = 0;
-
-        /* Strip leading and trailing whitespaces. */
-        beg = p2;
-        end = beg + strlen (beg) - 1;
-        strip_whitespace (&beg, &end);
-
-        /* Put all the prerequisites here; they'll be parsed later.  */
-        if (beg <= end && *beg != '\0')
-          depstr = xstrndup (beg, end - beg + 1);
-        else
-          depstr = 0;
-
-        commands_idx = 0;
-        if (cmdleft != 0)
-          {
-            /* Semicolon means rest of line is a command.  */
-            unsigned int l = strlen (cmdleft);
-
-            cmds_started = fstart->lineno;
-
-            /* Add this command line to the buffer.  */
-            if (l + 2 > commands_len)
-              {
-                commands_len = (l + 2) * 2;
-                commands = xrealloc (commands, commands_len);
-              }
-            memcpy (commands, cmdleft, l);
-            commands_idx += l;
-            commands[commands_idx++] = '\n';
-          }
-
-        /* Determine if this target should be made default. We used to do
-           this in record_files() but because of the delayed target recording
-           and because preprocessor directives are legal in target's commands
-           it is too late. Consider this fragment for example:
-
-           foo:
-
-           ifeq ($(.DEFAULT_GOAL),foo)
-              ...
-           endif
-
-           Because the target is not recorded until after ifeq directive is
-           evaluated the .DEFAULT_GOAL does not contain foo yet as one
-           would expect. Because of this we have to move the logic here.  */
-
-        if (set_default && default_goal_var->value[0] == '\0')
-          {
-            struct dep *d;
-            struct nameseq *t = filenames;
-
-            for (; t != 0; t = t->next)
-              {
-                int reject = 0;
-                const char *name = t->name;
-
-                /* We have nothing to do if this is an implicit rule. */
-                if (strchr (name, '%') != 0)
-                  break;
-
-                /* See if this target's name does not start with a '.',
-                   unless it contains a slash.  */
-                if (*name == '.' && strchr (name, '/') == 0
-#ifdef HAVE_DOS_PATHS
-                    && strchr (name, '\\') == 0
-#endif
-                    )
-                  continue;
-
-
-                /* If this file is a suffix, don't let it be
-                   the default goal file.  */
-                for (d = suffix_file->deps; d != 0; d = d->next)
-                  {
-                    struct dep *d2;
-                    if (*dep_name (d) != '.' && streq (name, dep_name (d)))
-                      {
-                        reject = 1;
-                        break;
-                      }
-                    for (d2 = suffix_file->deps; d2 != 0; d2 = d2->next)
-                      {
-                        unsigned int l = strlen (dep_name (d2));
-                        if (!strneq (name, dep_name (d2), l))
-                          continue;
-                        if (streq (name + l, dep_name (d)))
-                          {
-                            reject = 1;
-                            break;
-                          }
-                      }
-
-                    if (reject)
-                      break;
-                  }
-
-                if (!reject)
-                  {
-                    define_variable_global (".DEFAULT_GOAL", 13, t->name,
-                                            o_file, 0, NILF);
-                    break;
-                  }
-              }
-          }
-
-        continue;
-      }
-
-      /* We get here except in the case that we just read a rule line.
-         Record now the last rule we read, so following spurious
-         commands are properly diagnosed.  */
-      record_waiting_files ();
-    }
-
-#undef word1eq
-
-  if (conditionals->if_cmds)
-    O (fatal, fstart, _("missing 'endif'"));
-
-  /* At eof, record the last rule.  */
-  record_waiting_files ();
-
-  free (collapsed);
-  free (commands);
-}
-
-
-/* Remove comments from LINE.
-   This will also remove backslashes that escape things.
-   It ignores comment characters that appear inside variable references.  */
-
-static void
-remove_comments (char *line)
-{
-  char *comment;
-
-  comment = find_map_unquote (line, MAP_COMMENT|MAP_VARIABLE);
-
-  if (comment != 0)
-    /* Cut off the line at the #.  */
-    *comment = '\0';
-}
-
-/* Execute a 'undefine' directive.
-   The undefine line has already been read, and NAME is the name of
-   the variable to be undefined. */
-
-static void
-do_undefine (char *name, enum variable_origin origin, struct ebuffer *ebuf)
-{
-  char *p, *var;
-
-  /* Expand the variable name and find the beginning (NAME) and end.  */
-  var = allocated_variable_expand (name);
-  name = next_token (var);
-  if (*name == '\0')
-    O (fatal, &ebuf->floc, _("empty variable name"));
-  p = name + strlen (name) - 1;
-  while (p > name && ISBLANK (*p))
-    --p;
-  p[1] = '\0';
-
-  undefine_variable_global (name, p - name + 1, origin);
-  free (var);
-}
-
-/* Execute a 'define' directive.
-   The first line has already been read, and NAME is the name of
-   the variable to be defined.  The following lines remain to be read.  */
-
-static struct variable *
-do_define (char *name, enum variable_origin origin, struct ebuffer *ebuf)
-{
-  struct variable *v;
-  struct variable var;
-  floc defstart;
-  int nlevels = 1;
-  unsigned int length = 100;
-  char *definition = xmalloc (length);
-  unsigned int idx = 0;
-  char *p, *n;
-
-  defstart = ebuf->floc;
-
-  p = parse_variable_definition (name, &var);
-  if (p == NULL)
-    /* No assignment token, so assume recursive.  */
-    var.flavor = f_recursive;
-  else
-    {
-      if (var.value[0] != '\0')
-        O (error, &defstart, _("extraneous text after 'define' directive"));
-
-      /* Chop the string before the assignment token to get the name.  */
-      var.name[var.length] = '\0';
-    }
-
-  /* Expand the variable name and find the beginning (NAME) and end.  */
-  n = allocated_variable_expand (name);
-  name = next_token (n);
-  if (name[0] == '\0')
-    O (fatal, &defstart, _("empty variable name"));
-  p = name + strlen (name) - 1;
-  while (p > name && ISBLANK (*p))
-    --p;
-  p[1] = '\0';
-
-  /* Now read the value of the variable.  */
-  while (1)
-    {
-      unsigned int len;
-      char *line;
-      long nlines = readline (ebuf);
-
-      /* If there is nothing left to be eval'd, there's no 'endef'!!  */
-      if (nlines < 0)
-        O (fatal, &defstart, _("missing 'endef', unterminated 'define'"));
-
-      ebuf->floc.lineno += nlines;
-      line = ebuf->buffer;
-
-      collapse_continuations (line);
-
-      /* If the line doesn't begin with a tab, test to see if it introduces
-         another define, or ends one.  Stop if we find an 'endef' */
-      if (line[0] != cmd_prefix)
-        {
-          p = next_token (line);
-          len = strlen (p);
-
-          /* If this is another 'define', increment the level count.  */
-          if ((len == 6 || (len > 6 && ISBLANK (p[6])))
-              && strneq (p, "define", 6))
-            ++nlevels;
-
-          /* If this is an 'endef', decrement the count.  If it's now 0,
-             we've found the last one.  */
-          else if ((len == 5 || (len > 5 && ISBLANK (p[5])))
-                   && strneq (p, "endef", 5))
-            {
-              p += 5;
-              remove_comments (p);
-              if (*(next_token (p)) != '\0')
-                O (error, &ebuf->floc,
-                   _("extraneous text after 'endef' directive"));
-
-              if (--nlevels == 0)
-                break;
-            }
-        }
-
-      /* Add this line to the variable definition.  */
-      len = strlen (line);
-      if (idx + len + 1 > length)
-        {
-          length = (idx + len) * 2;
-          definition = xrealloc (definition, length + 1);
-        }
-
-      memcpy (&definition[idx], line, len);
-      idx += len;
-      /* Separate lines with a newline.  */
-      definition[idx++] = '\n';
-    }
-
-  /* We've got what we need; define the variable.  */
-  if (idx == 0)
-    definition[0] = '\0';
-  else
-    definition[idx - 1] = '\0';
-
-  v = do_variable_definition (&defstart, name,
-                              definition, origin, var.flavor, 0);
-  free (definition);
-  free (n);
-  return (v);
-}
-
-/* Interpret conditional commands "ifdef", "ifndef", "ifeq",
-   "ifneq", "else" and "endif".
-   LINE is the input line, with the command as its first word.
-
-   FILENAME and LINENO are the filename and line number in the
-   current makefile.  They are used for error messages.
-
-   Value is -2 if the line is not a conditional at all,
-   -1 if the line is an invalid conditional,
-   0 if following text should be interpreted,
-   1 if following text should be ignored.  */
-
-static int
-conditional_line (char *line, int len, const floc *flocp)
-{
-  const char *cmdname;
-  enum { c_ifdef, c_ifndef, c_ifeq, c_ifneq, c_else, c_endif } cmdtype;
-  unsigned int i;
-  unsigned int o;
-
-  /* Compare a word, both length and contents. */
-#define word1eq(s)      (len == CSTRLEN (s) && strneq (s, line, CSTRLEN (s)))
-#define chkword(s, t)   if (word1eq (s)) { cmdtype = (t); cmdname = (s); }
-
-  /* Make sure this line is a conditional.  */
-  chkword ("ifdef", c_ifdef)
-  else chkword ("ifndef", c_ifndef)
-  else chkword ("ifeq", c_ifeq)
-  else chkword ("ifneq", c_ifneq)
-  else chkword ("else", c_else)
-  else chkword ("endif", c_endif)
-  else
-    return -2;
-
-  /* Found one: skip past it and any whitespace after it.  */
-  line += len;
-  NEXT_TOKEN (line);
-
-#define EXTRATEXT() OS (error, flocp, _("extraneous text after '%s' directive"), cmdname)
-#define EXTRACMD()  OS (fatal, flocp, _("extraneous '%s'"), cmdname)
-
-  /* An 'endif' cannot contain extra text, and reduces the if-depth by 1  */
-  if (cmdtype == c_endif)
-    {
-      if (*line != '\0')
-        EXTRATEXT ();
-
-      if (!conditionals->if_cmds)
-        EXTRACMD ();
-
-      --conditionals->if_cmds;
-
-      goto DONE;
-    }
-
-  /* An 'else' statement can either be simple, or it can have another
-     conditional after it.  */
-  if (cmdtype == c_else)
-    {
-      const char *p;
-
-      if (!conditionals->if_cmds)
-        EXTRACMD ();
-
-      o = conditionals->if_cmds - 1;
-
-      if (conditionals->seen_else[o])
-        O (fatal, flocp, _("only one 'else' per conditional"));
-
-      /* Change the state of ignorance.  */
-      switch (conditionals->ignoring[o])
-        {
-          case 0:
-            /* We've just been interpreting.  Never do it again.  */
-            conditionals->ignoring[o] = 2;
-            break;
-          case 1:
-            /* We've never interpreted yet.  Maybe this time!  */
-            conditionals->ignoring[o] = 0;
-            break;
-        }
-
-      /* It's a simple 'else'.  */
-      if (*line == '\0')
-        {
-          conditionals->seen_else[o] = 1;
-          goto DONE;
-        }
-
-      /* The 'else' has extra text.  That text must be another conditional
-         and cannot be an 'else' or 'endif'.  */
-
-      /* Find the length of the next word.  */
-      for (p = line+1; ! STOP_SET (*p, MAP_SPACE|MAP_NUL); ++p)
-        ;
-      len = p - line;
-
-      /* If it's 'else' or 'endif' or an illegal conditional, fail.  */
-      if (word1eq ("else") || word1eq ("endif")
-          || conditional_line (line, len, flocp) < 0)
-        EXTRATEXT ();
-      else
-        {
-          /* conditional_line() created a new level of conditional.
-             Raise it back to this level.  */
-          if (conditionals->ignoring[o] < 2)
-            conditionals->ignoring[o] = conditionals->ignoring[o+1];
-          --conditionals->if_cmds;
-        }
-
-      goto DONE;
-    }
-
-  if (conditionals->allocated == 0)
-    {
-      conditionals->allocated = 5;
-      conditionals->ignoring = xmalloc (conditionals->allocated);
-      conditionals->seen_else = xmalloc (conditionals->allocated);
-    }
-
-  o = conditionals->if_cmds++;
-  if (conditionals->if_cmds > conditionals->allocated)
-    {
-      conditionals->allocated += 5;
-      conditionals->ignoring = xrealloc (conditionals->ignoring,
-                                         conditionals->allocated);
-      conditionals->seen_else = xrealloc (conditionals->seen_else,
-                                          conditionals->allocated);
-    }
-
-  /* Record that we have seen an 'if...' but no 'else' so far.  */
-  conditionals->seen_else[o] = 0;
-
-  /* Search through the stack to see if we're already ignoring.  */
-  for (i = 0; i < o; ++i)
-    if (conditionals->ignoring[i])
-      {
-        /* We are already ignoring, so just push a level to match the next
-           "else" or "endif", and keep ignoring.  We don't want to expand
-           variables in the condition.  */
-        conditionals->ignoring[o] = 1;
-        return 1;
-      }
-
-  if (cmdtype == c_ifdef || cmdtype == c_ifndef)
-    {
-      char *var;
-      struct variable *v;
-      char *p;
-
-      /* Expand the thing we're looking up, so we can use indirect and
-         constructed variable names.  */
-      var = allocated_variable_expand (line);
-
-      /* Make sure there's only one variable name to test.  */
-      p = end_of_token (var);
-      i = p - var;
-      NEXT_TOKEN (p);
-      if (*p != '\0')
-        return -1;
-
-      var[i] = '\0';
-      v = lookup_variable (var, i);
-
-      conditionals->ignoring[o] =
-        ((v != 0 && *v->value != '\0') == (cmdtype == c_ifndef));
-
-      free (var);
-    }
-  else
-    {
-      /* "ifeq" or "ifneq".  */
-      char *s1, *s2;
-      unsigned int l;
-      char termin = *line == '(' ? ',' : *line;
-
-      if (termin != ',' && termin != '"' && termin != '\'')
-        return -1;
-
-      s1 = ++line;
-      /* Find the end of the first string.  */
-      if (termin == ',')
-        {
-          int count = 0;
-          for (; *line != '\0'; ++line)
-            if (*line == '(')
-              ++count;
-            else if (*line == ')')
-              --count;
-            else if (*line == ',' && count <= 0)
-              break;
-        }
-      else
-        while (*line != '\0' && *line != termin)
-          ++line;
-
-      if (*line == '\0')
-        return -1;
-
-      if (termin == ',')
-        {
-          /* Strip blanks after the first string.  */
-          char *p = line++;
-          while (ISBLANK (p[-1]))
-            --p;
-          *p = '\0';
-        }
-      else
-        *line++ = '\0';
-
-      s2 = variable_expand (s1);
-      /* We must allocate a new copy of the expanded string because
-         variable_expand re-uses the same buffer.  */
-      l = strlen (s2);
-      s1 = alloca (l + 1);
-      memcpy (s1, s2, l + 1);
-
-      if (termin != ',')
-        /* Find the start of the second string.  */
-        NEXT_TOKEN (line);
-
-      termin = termin == ',' ? ')' : *line;
-      if (termin != ')' && termin != '"' && termin != '\'')
-        return -1;
-
-      /* Find the end of the second string.  */
-      if (termin == ')')
-        {
-          int count = 0;
-          s2 = next_token (line);
-          for (line = s2; *line != '\0'; ++line)
-            {
-              if (*line == '(')
-                ++count;
-              else if (*line == ')')
-                {
-                  if (count <= 0)
-                    break;
-                  else
-                    --count;
-                }
-            }
-        }
-      else
-        {
-          ++line;
-          s2 = line;
-          while (*line != '\0' && *line != termin)
-            ++line;
-        }
-
-      if (*line == '\0')
-        return -1;
-
-      *(line++) = '\0';
-      NEXT_TOKEN (line);
-      if (*line != '\0')
-        EXTRATEXT ();
-
-      s2 = variable_expand (s2);
-      conditionals->ignoring[o] = (streq (s1, s2) == (cmdtype == c_ifneq));
-    }
-
- DONE:
-  /* Search through the stack to see if we're ignoring.  */
-  for (i = 0; i < conditionals->if_cmds; ++i)
-    if (conditionals->ignoring[i])
-      return 1;
-  return 0;
-}
-
-
-/* Record target-specific variable values for files FILENAMES.
-   TWO_COLON is nonzero if a double colon was used.
-
-   The links of FILENAMES are freed, and so are any names in it
-   that are not incorporated into other data structures.
-
-   If the target is a pattern, add the variable to the pattern-specific
-   variable value list.  */
-
-static void
-record_target_var (struct nameseq *filenames, char *defn,
-                   enum variable_origin origin, struct vmodifiers *vmod,
-                   const floc *flocp)
-{
-  struct nameseq *nextf;
-  struct variable_set_list *global;
-
-  global = current_variable_set_list;
-
-  /* If the variable is an append version, store that but treat it as a
-     normal recursive variable.  */
-
-  for (; filenames != 0; filenames = nextf)
-    {
-      struct variable *v;
-      const char *name = filenames->name;
-      const char *percent;
-      struct pattern_var *p;
-
-      nextf = filenames->next;
-      free_ns (filenames);
-
-      /* If it's a pattern target, then add it to the pattern-specific
-         variable list.  */
-      percent = find_percent_cached (&name);
-      if (percent)
-        {
-          /* Get a reference for this pattern-specific variable struct.  */
-          p = create_pattern_var (name, percent);
-          p->variable.fileinfo = *flocp;
-          /* I don't think this can fail since we already determined it was a
-             variable definition.  */
-          v = assign_variable_definition (&p->variable, defn);
-          assert (v != 0);
-
-          v->origin = origin;
-          if (v->flavor == f_simple)
-            v->value = allocated_variable_expand (v->value);
-          else
-            v->value = xstrdup (v->value);
-        }
-      else
-        {
-          struct file *f;
-
-          /* Get a file reference for this file, and initialize it.
-             We don't want to just call enter_file() because that allocates a
-             new entry if the file is a double-colon, which we don't want in
-             this situation.  */
-          f = lookup_file (name);
-          if (!f)
-            f = enter_file (strcache_add (name));
-          else if (f->double_colon)
-            f = f->double_colon;
-
-          initialize_file_variables (f, 1);
-
-          current_variable_set_list = f->variables;
-          v = try_variable_definition (flocp, defn, origin, 1);
-          if (!v)
-            O (fatal, flocp, _("Malformed target-specific variable definition"));
-          current_variable_set_list = global;
-        }
-
-      /* Set up the variable to be *-specific.  */
-      v->per_target = 1;
-      v->private_var = vmod->private_v;
-      v->export = vmod->export_v ? v_export : v_default;
-
-      /* If it's not an override, check to see if there was a command-line
-         setting.  If so, reset the value.  */
-      if (v->origin != o_override)
-        {
-          struct variable *gv;
-          int len = strlen (v->name);
-
-          gv = lookup_variable (v->name, len);
-          if (gv && v != gv
-              && (gv->origin == o_env_override || gv->origin == o_command))
-            {
-              free (v->value);
-              v->value = xstrdup (gv->value);
-              v->origin = gv->origin;
-              v->recursive = gv->recursive;
-              v->append = 0;
-            }
-        }
-    }
-}
-
-/* Record a description line for files FILENAMES,
-   with dependencies DEPS, commands to execute described
-   by COMMANDS and COMMANDS_IDX, coming from FILENAME:COMMANDS_STARTED.
-   TWO_COLON is nonzero if a double colon was used.
-   If not nil, PATTERN is the '%' pattern to make this
-   a static pattern rule, and PATTERN_PERCENT is a pointer
-   to the '%' within it.
-
-   The links of FILENAMES are freed, and so are any names in it
-   that are not incorporated into other data structures.  */
-
-static void
-record_files (struct nameseq *filenames, const char *pattern,
-              const char *pattern_percent, char *depstr,
-              unsigned int cmds_started, char *commands,
-              unsigned int commands_idx, int two_colon,
-              char prefix, const floc *flocp)
-{
-  struct commands *cmds;
-  struct dep *deps;
-  const char *implicit_percent;
-  const char *name;
-
-  /* If we've already snapped deps, that means we're in an eval being
-     resolved after the makefiles have been read in.  We can't add more rules
-     at this time, since they won't get snapped and we'll get core dumps.
-     See Savannah bug # 12124.  */
-  if (snapped_deps)
-    O (fatal, flocp, _("prerequisites cannot be defined in recipes"));
-
-  /* Determine if this is a pattern rule or not.  */
-  name = filenames->name;
-  implicit_percent = find_percent_cached (&name);
-
-  /* If there's a recipe, set up a struct for it.  */
-  if (commands_idx > 0)
-    {
-      cmds = xmalloc (sizeof (struct commands));
-      cmds->fileinfo.filenm = flocp->filenm;
-      cmds->fileinfo.lineno = cmds_started;
-      cmds->fileinfo.offset = 0;
-      cmds->commands = xstrndup (commands, commands_idx);
-      cmds->command_lines = 0;
-      cmds->recipe_prefix = prefix;
-    }
-  else
-     cmds = 0;
-
-  /* If there's a prereq string then parse it--unless it's eligible for 2nd
-     expansion: if so, snap_deps() will do it.  */
-  if (depstr == 0)
-    deps = 0;
-  else
-    {
-      depstr = unescape_char (depstr, ':');
-      if (second_expansion && strchr (depstr, '$'))
-        {
-          deps = alloc_dep ();
-          deps->name = depstr;
-          deps->need_2nd_expansion = 1;
-          deps->staticpattern = pattern != 0;
-        }
-      else
-        {
-          deps = split_prereqs (depstr);
-          free (depstr);
-
-          /* We'll enter static pattern prereqs later when we have the stem.
-             We don't want to enter pattern rules at all so that we don't
-             think that they ought to exist (make manual "Implicit Rule Search
-             Algorithm", item 5c).  */
-          if (! pattern && ! implicit_percent)
-            deps = enter_prereqs (deps, NULL);
-        }
-    }
-
-  /* For implicit rules, _all_ the targets must have a pattern.  That means we
-     can test the first one to see if we're working with an implicit rule; if
-     so we handle it specially. */
-
-  if (implicit_percent)
-    {
-      struct nameseq *nextf;
-      const char **targets, **target_pats;
-      unsigned int c;
-
-      if (pattern != 0)
-        O (fatal, flocp, _("mixed implicit and static pattern rules"));
-
-      /* Count the targets to create an array of target names.
-         We already have the first one.  */
-      nextf = filenames->next;
-      free_ns (filenames);
-      filenames = nextf;
-
-      for (c = 1; nextf; ++c, nextf = nextf->next)
-        ;
-      targets = xmalloc (c * sizeof (const char *));
-      target_pats = xmalloc (c * sizeof (const char *));
-
-      targets[0] = name;
-      target_pats[0] = implicit_percent;
-
-      c = 1;
-      while (filenames)
-        {
-          name = filenames->name;
-          implicit_percent = find_percent_cached (&name);
-
-          if (implicit_percent == 0)
-            O (fatal, flocp, _("mixed implicit and normal rules"));
-
-          targets[c] = name;
-          target_pats[c] = implicit_percent;
-          ++c;
-
-          nextf = filenames->next;
-          free_ns (filenames);
-          filenames = nextf;
-        }
-
-      create_pattern_rule (targets, target_pats, c, two_colon, deps, cmds, 1);
-
-      return;
-    }
-
-
-  /* Walk through each target and create it in the database.
-     We already set up the first target, above.  */
-  while (1)
-    {
-      struct nameseq *nextf = filenames->next;
-      struct file *f;
-      struct dep *this = 0;
-
-      free_ns (filenames);
-
-      /* Check for special targets.  Do it here instead of, say, snap_deps()
-         so that we can immediately use the value.  */
-      if (!posix_pedantic && streq (name, ".POSIX"))
-        {
-          posix_pedantic = 1;
-          define_variable_cname (".SHELLFLAGS", "-ec", o_default, 0);
-          /* These default values are based on IEEE Std 1003.1-2008.
-             It requires '-O 1' for [CF]FLAGS, but GCC doesn't allow space
-             between -O and the number so omit it here.  */
-          define_variable_cname ("ARFLAGS", "-rv", o_default, 0);
-          define_variable_cname ("CC", "c99", o_default, 0);
-          define_variable_cname ("CFLAGS", "-O1", o_default, 0);
-          define_variable_cname ("FC", "fort77", o_default, 0);
-          define_variable_cname ("FFLAGS", "-O1", o_default, 0);
-          define_variable_cname ("SCCSGETFLAGS", "-s", o_default, 0);
-        }
-      else if (!second_expansion && streq (name, ".SECONDEXPANSION"))
-        second_expansion = 1;
-#if !defined (__MSDOS__) && !defined (__EMX__)
-      else if (!one_shell && streq (name, ".ONESHELL"))
-        one_shell = 1;
-#endif
-
-      /* If this is a static pattern rule:
-         'targets: target%pattern: prereq%pattern; recipe',
-         make sure the pattern matches this target name.  */
-      if (pattern && !pattern_matches (pattern, pattern_percent, name))
-        OS (error, flocp,
-            _("target '%s' doesn't match the target pattern"), name);
-      else if (deps)
-        /* If there are multiple targets, copy the chain DEPS for all but the
-           last one.  It is not safe for the same deps to go in more than one
-           place in the database.  */
-        this = nextf != 0 ? copy_dep_chain (deps) : deps;
-
-      /* Find or create an entry in the file database for this target.  */
-      if (!two_colon)
-        {
-          /* Single-colon.  Combine this rule with the file's existing record,
-             if any.  */
-          f = enter_file (strcache_add (name));
-          if (f->double_colon)
-            OS (fatal, flocp,
-                _("target file '%s' has both : and :: entries"), f->name);
-
-          /* If CMDS == F->CMDS, this target was listed in this rule
-             more than once.  Just give a warning since this is harmless.  */
-          if (cmds != 0 && cmds == f->cmds)
-            OS (error, flocp,
-                _("target '%s' given more than once in the same rule"),
-                f->name);
-
-          /* Check for two single-colon entries both with commands.
-             Check is_target so that we don't lose on files such as .c.o
-             whose commands were preinitialized.  */
-          else if (cmds != 0 && f->cmds != 0 && f->is_target)
-            {
-              size_t l = strlen (f->name);
-              error (&cmds->fileinfo, l,
-                     _("warning: overriding recipe for target '%s'"),
-                     f->name);
-              error (&f->cmds->fileinfo, l,
-                     _("warning: ignoring old recipe for target '%s'"),
-                     f->name);
-            }
-
-          /* Defining .DEFAULT with no deps or cmds clears it.  */
-          if (f == default_file && this == 0 && cmds == 0)
-            f->cmds = 0;
-          if (cmds != 0)
-            f->cmds = cmds;
-
-          /* Defining .SUFFIXES with no dependencies clears out the list of
-             suffixes.  */
-          if (f == suffix_file && this == 0)
-            {
-              free_dep_chain (f->deps);
-              f->deps = 0;
-            }
-        }
-      else
-        {
-          /* Double-colon.  Make a new record even if there already is one.  */
-          f = lookup_file (name);
-
-          /* Check for both : and :: rules.  Check is_target so we don't lose
-             on default suffix rules or makefiles.  */
-          if (f != 0 && f->is_target && !f->double_colon)
-            OS (fatal, flocp,
-                _("target file '%s' has both : and :: entries"), f->name);
-
-          f = enter_file (strcache_add (name));
-          /* If there was an existing entry and it was a double-colon entry,
-             enter_file will have returned a new one, making it the prev
-             pointer of the old one, and setting its double_colon pointer to
-             the first one.  */
-          if (f->double_colon == 0)
-            /* This is the first entry for this name, so we must set its
-               double_colon pointer to itself.  */
-            f->double_colon = f;
-
-          f->cmds = cmds;
-        }
-
-      f->is_target = 1;
-
-      /* If this is a static pattern rule, set the stem to the part of its
-         name that matched the '%' in the pattern, so you can use $* in the
-         commands.  If we didn't do it before, enter the prereqs now.  */
-      if (pattern)
-        {
-          static const char *percent = "%";
-          char *buffer = variable_expand ("");
-          char *o = patsubst_expand_pat (buffer, name, pattern, percent,
-                                         pattern_percent+1, percent+1);
-          f->stem = strcache_add_len (buffer, o - buffer);
-          if (this)
-            {
-              if (! this->need_2nd_expansion)
-                this = enter_prereqs (this, f->stem);
-              else
-                this->stem = f->stem;
-            }
-        }
-
-      /* Add the dependencies to this file entry.  */
-      if (this != 0)
-        {
-          /* Add the file's old deps and the new ones in THIS together.  */
-          if (f->deps == 0)
-            f->deps = this;
-          else if (cmds != 0)
-            {
-              struct dep *d = this;
-
-              /* If this rule has commands, put these deps first.  */
-              while (d->next != 0)
-                d = d->next;
-
-              d->next = f->deps;
-              f->deps = this;
-            }
-          else
-            {
-              struct dep *d = f->deps;
-
-              /* A rule without commands: put its prereqs at the end.  */
-              while (d->next != 0)
-                d = d->next;
-
-              d->next = this;
-            }
-        }
-
-      name = f->name;
-
-      /* All done!  Set up for the next one.  */
-      if (nextf == 0)
-        break;
-
-      filenames = nextf;
-
-      /* Reduce escaped percents.  If there are any unescaped it's an error  */
-      name = filenames->name;
-      if (find_percent_cached (&name))
-        O (error, flocp,
-           _("*** mixed implicit and normal rules: deprecated syntax"));
-    }
-}
-
-/* Search STRING for an unquoted STOPMAP.
-   Backslashes quote elements from STOPMAP and backslash.
-   Quoting backslashes are removed from STRING by compacting it into itself.
-   Returns a pointer to the first unquoted STOPCHAR if there is one, or nil if
-   there are none.
-
-   If MAP_VARIABLE is set, then the complete contents of variable references
-   are skipped, even if the contain STOPMAP characters.  */
-
-static char *
-find_map_unquote (char *string, int stopmap)
-{
-  unsigned int string_len = 0;
-  char *p = string;
-
-  /* Always stop on NUL.  */
-  stopmap |= MAP_NUL;
-
-  while (1)
-    {
-      while (! STOP_SET (*p, stopmap))
-        ++p;
-
-      if (*p == '\0')
-        break;
-
-      /* If we stopped due to a variable reference, skip over its contents.  */
-      if (*p == '$')
-        {
-          char openparen = p[1];
-
-          /* Check if '$' is the last character in the string.  */
-          if (openparen == '\0')
-            break;
-
-          p += 2;
-
-          /* Skip the contents of a non-quoted, multi-char variable ref.  */
-          if (openparen == '(' || openparen == '{')
-            {
-              unsigned int pcount = 1;
-              char closeparen = (openparen == '(' ? ')' : '}');
-
-              while (*p)
-                {
-                  if (*p == openparen)
-                    ++pcount;
-                  else if (*p == closeparen)
-                    if (--pcount == 0)
-                      {
-                        ++p;
-                        break;
-                      }
-                  ++p;
-                }
-            }
-
-          /* Skipped the variable reference: look for STOPCHARS again.  */
-          continue;
-        }
-
-      if (p > string && p[-1] == '\\')
-        {
-          /* Search for more backslashes.  */
-          int i = -2;
-          while (&p[i] >= string && p[i] == '\\')
-            --i;
-          ++i;
-          /* Only compute the length if really needed.  */
-          if (string_len == 0)
-            string_len = strlen (string);
-          /* The number of backslashes is now -I.
-             Copy P over itself to swallow half of them.  */
-          memmove (&p[i], &p[i/2], (string_len - (p - string)) - (i/2) + 1);
-          p += i/2;
-          if (i % 2 == 0)
-            /* All the backslashes quoted each other; the STOPCHAR was
-               unquoted.  */
-            return p;
-
-          /* The STOPCHAR was quoted by a backslash.  Look for another.  */
-        }
-      else
-        /* No backslash in sight.  */
-        return p;
-    }
-
-  /* Never hit a STOPCHAR or blank (with BLANK nonzero).  */
-  return 0;
-}
-
-static char *
-find_char_unquote (char *string, int stop)
-{
-  unsigned int string_len = 0;
-  char *p = string;
-
-  while (1)
-    {
-      p = strchr(p, stop);
-
-      if (!p)
-        return NULL;
-
-      if (p > string && p[-1] == '\\')
-        {
-          /* Search for more backslashes.  */
-          int i = -2;
-          while (&p[i] >= string && p[i] == '\\')
-            --i;
-          ++i;
-          /* Only compute the length if really needed.  */
-          if (string_len == 0)
-            string_len = strlen (string);
-          /* The number of backslashes is now -I.
-             Copy P over itself to swallow half of them.  */
-          memmove (&p[i], &p[i/2], (string_len - (p - string)) - (i/2) + 1);
-          p += i/2;
-          if (i % 2 == 0)
-            /* All the backslashes quoted each other; the STOPCHAR was
-               unquoted.  */
-            return p;
-
-          /* The STOPCHAR was quoted by a backslash.  Look for another.  */
-        }
-      else
-        /* No backslash in sight.  */
-        return p;
-    }
-}
-
-/* Unescape a character in a string.  The string is compressed onto itself.  */
-
-static char *
-unescape_char (char *string, int c)
-{
-  char *p = string;
-  char *s = string;
-
-  while (*s != '\0')
-    {
-      if (*s == '\\')
-        {
-          char *e = s;
-          int l;
-
-          /* We found a backslash.  See if it's escaping our character.  */
-          while (*e == '\\')
-            ++e;
-          l = e - s;
-
-          if (*e != c || l%2 == 0)
-            {
-              /* It's not; just take it all without unescaping.  */
-              memmove (p, s, l);
-              p += l;
-
-              // If we hit the end of the string, we're done
-              if (*e == '\0')
-                break;
-            }
-          else if (l > 1)
-            {
-              /* It is, and there's >1 backslash.  Take half of them.  */
-              l /= 2;
-              memmove (p, s, l);
-              p += l;
-            }
-
-          s = e;
-        }
-
-      *(p++) = *(s++);
-    }
-
-  *p = '\0';
-  return string;
-}
-
-/* Search PATTERN for an unquoted % and handle quoting.  */
-
-char *
-find_percent (char *pattern)
-{
-  return find_char_unquote (pattern, '%');
-}
-
-/* Search STRING for an unquoted % and handle quoting.  Returns a pointer to
-   the % or NULL if no % was found.
-   This version is used with strings in the string cache: if there's a need to
-   modify the string a new version will be added to the string cache and
-   *STRING will be set to that.  */
-
-const char *
-find_percent_cached (const char **string)
-{
-  const char *p = *string;
-  char *new = 0;
-  int slen = 0;
-
-  /* If the first char is a % return now.  This lets us avoid extra tests
-     inside the loop.  */
-  if (*p == '%')
-    return p;
-
-  while (1)
-    {
-      p = strchr(p, '%');
-
-      if (!p)
-        break;
-
-      /* See if this % is escaped with a backslash; if not we're done.  */
-      if (p[-1] != '\\')
-        break;
-
-      {
-        /* Search for more backslashes.  */
-        char *pv;
-        int i = -2;
-
-        while (&p[i] >= *string && p[i] == '\\')
-          --i;
-        ++i;
-
-        /* At this point we know we'll need to allocate a new string.
-           Make a copy if we haven't yet done so.  */
-        if (! new)
-          {
-            slen = strlen (*string);
-            new = alloca (slen + 1);
-            memcpy (new, *string, slen + 1);
-            p = new + (p - *string);
-            *string = new;
-          }
-
-        /* At this point *string, p, and new all point into the same string.
-           Get a non-const version of p so we can modify new.  */
-        pv = new + (p - *string);
-
-        /* The number of backslashes is now -I.
-           Copy P over itself to swallow half of them.  */
-        memmove (&pv[i], &pv[i/2], (slen - (pv - new)) - (i/2) + 1);
-        p += i/2;
-
-        /* If the backslashes quoted each other; the % was unquoted.  */
-        if (i % 2 == 0)
-          break;
-      }
-    }
-
-  /* If we had to change STRING, add it to the strcache.  */
-  if (new)
-    {
-      *string = strcache_add (*string);
-      if (p)
-	p = *string + (p - new);
-    }
-
-  /* If we didn't find a %, return NULL.  Otherwise return a ptr to it.  */
-  return p;
-}
-
-/* Find the next line of text in an eval buffer, combining continuation lines
-   into one line.
-   Return the number of actual lines read (> 1 if continuation lines).
-   Returns -1 if there's nothing left in the buffer.
-
-   After this function, ebuf->buffer points to the first character of the
-   line we just found.
- */
-
-/* Read a line of text from a STRING.
-   Since we aren't really reading from a file, don't bother with linenumbers.
- */
-
-static long
-readstring (struct ebuffer *ebuf)
-{
-  char *eol;
-
-  /* If there is nothing left in this buffer, return 0.  */
-  if (ebuf->bufnext >= ebuf->bufstart + ebuf->size)
-    return -1;
-
-  /* Set up a new starting point for the buffer, and find the end of the
-     next logical line (taking into account backslash/newline pairs).  */
-
-  eol = ebuf->buffer = ebuf->bufnext;
-
-  while (1)
-    {
-      int backslash = 0;
-      const char *bol = eol;
-      const char *p;
-
-      /* Find the next newline.  At EOS, stop.  */
-      p = eol = strchr (eol , '\n');
-      if (!eol)
-        {
-          ebuf->bufnext = ebuf->bufstart + ebuf->size + 1;
-          return 0;
-        }
-
-      /* Found a newline; if it's escaped continue; else we're done.  */
-      while (p > bol && *(--p) == '\\')
-        backslash = !backslash;
-      if (!backslash)
-        break;
-      ++eol;
-    }
-
-  /* Overwrite the newline char.  */
-  *eol = '\0';
-  ebuf->bufnext = eol+1;
-
-  return 0;
-}
-
-static long
-readline (struct ebuffer *ebuf)
-{
-  char *p;
-  char *end;
-  char *start;
-  long nlines = 0;
-
-  /* The behaviors between string and stream buffers are different enough to
-     warrant different functions.  Do the Right Thing.  */
-
-  if (!ebuf->fp)
-    return readstring (ebuf);
-
-  /* When reading from a file, we always start over at the beginning of the
-     buffer for each new line.  */
-
-  p = start = ebuf->bufstart;
-  end = p + ebuf->size;
-  *p = '\0';
-
-  while (fgets (p, (int)(end - p), ebuf->fp) != 0)
-    {
-      char *p2;
-      unsigned long len;
-      int backslash;
-
-      len = strlen (p);
-      if (len == 0)
-        {
-          /* This only happens when the first thing on the line is a '\0'.
-             It is a pretty hopeless case, but (wonder of wonders) Athena
-             lossage strikes again!  (xmkmf puts NULs in its makefiles.)
-             There is nothing really to be done; we synthesize a newline so
-             the following line doesn't appear to be part of this line.  */
-          O (error, &ebuf->floc,
-             _("warning: NUL character seen; rest of line ignored"));
-          p[0] = '\n';
-          len = 1;
-        }
-
-      /* Jump past the text we just read.  */
-      p += len;
-
-      /* If the last char isn't a newline, the whole line didn't fit into the
-         buffer.  Get some more buffer and try again.  */
-      if (p[-1] != '\n')
-        goto more_buffer;
-
-      /* We got a newline, so add one to the count of lines.  */
-      ++nlines;
-
-#if !defined(WINDOWS32) && !defined(__MSDOS__) && !defined(__EMX__)
-      /* Check to see if the line was really ended with CRLF; if so ignore
-         the CR.  */
-      if ((p - start) > 1 && p[-2] == '\r')
-        {
-          --p;
-          memmove (p-1, p, strlen (p) + 1);
-        }
-#endif
-
-      backslash = 0;
-      for (p2 = p - 2; p2 >= start; --p2)
-        {
-          if (*p2 != '\\')
-            break;
-          backslash = !backslash;
-        }
-
-      if (!backslash)
-        {
-          p[-1] = '\0';
-          break;
-        }
-
-      /* It was a backslash/newline combo.  If we have more space, read
-         another line.  */
-      if (end - p >= 80)
-        continue;
-
-      /* We need more space at the end of our buffer, so realloc it.
-         Make sure to preserve the current offset of p.  */
-    more_buffer:
-      {
-        unsigned long off = p - start;
-        ebuf->size *= 2;
-        start = ebuf->buffer = ebuf->bufstart = xrealloc (start, ebuf->size);
-        p = start + off;
-        end = start + ebuf->size;
-        *p = '\0';
-      }
-    }
-
-  if (ferror (ebuf->fp))
-    pfatal_with_name (ebuf->floc.filenm);
-
-  /* If we found some lines, return how many.
-     If we didn't, but we did find _something_, that indicates we read the last
-     line of a file with no final newline; return 1.
-     If we read nothing, we're at EOF; return -1.  */
-
-  return nlines ? nlines : p == ebuf->bufstart ? -1 : 1;
-}
-
-/* Parse the next "makefile word" from the input buffer, and return info
-   about it.
-
-   A "makefile word" is one of:
-
-     w_bogus        Should never happen
-     w_eol          End of input
-     w_static       A static word; cannot be expanded
-     w_variable     A word containing one or more variables/functions
-     w_colon        A colon
-     w_dcolon       A double-colon
-     w_semicolon    A semicolon
-     w_varassign    A variable assignment operator (=, :=, ::=, +=, ?=, or !=)
-
-   Note that this function is only used when reading certain parts of the
-   makefile.  Don't use it where special rules hold sway (RHS of a variable,
-   in a command list, etc.)  */
-
-static enum make_word_type
-get_next_mword (char *buffer, char *delim, char **startp, unsigned int *length)
-{
-  enum make_word_type wtype;
-  char *p = buffer, *beg;
-  char c;
-
-  /* Skip any leading whitespace.  */
-  while (ISBLANK (*p))
-    ++p;
-
-  beg = p;
-  c = *(p++);
-
-  /* Look at the start of the word to see if it's simple.  */
-  switch (c)
-    {
-    case '\0':
-      wtype = w_eol;
-      goto done;
-
-    case ';':
-      wtype = w_semicolon;
-      goto done;
-
-    case '=':
-      wtype = w_varassign;
-      goto done;
-
-    case ':':
-      if (*p == '=')
-        {
-          ++p;
-          wtype = w_varassign; /* := */
-        }
-      else if (*p == ':')
-        {
-          ++p;
-          if (p[1] == '=')
-            {
-              ++p;
-              wtype = w_varassign; /* ::= */
-            }
-          else
-            wtype = w_dcolon;
-        }
-      else
-        wtype = w_colon;
-      goto done;
-
-    case '+':
-    case '?':
-    case '!':
-      if (*p == '=')
-        {
-          ++p;
-          wtype = w_varassign; /* += or ?= or != */
-          goto done;
-        }
-      /* FALLTHROUGH */
-
-    default:
-      if (delim && strchr (delim, c))
-        {
-          wtype = w_static;
-          goto done;
-        }
-    }
-
-  /* This is some non-operator word.  A word consists of the longest
-     string of characters that doesn't contain whitespace, one of [:=#],
-     or [?+!]=, or one of the chars in the DELIM string.  */
-
-  /* We start out assuming a static word; if we see a variable we'll
-     adjust our assumptions then.  */
-  wtype = w_static;
-
-  /* We already found the first value of "c", above.  */
-  while (1)
-    {
-      char closeparen;
-      int count;
-
-      switch (c)
-        {
-        case '\0':
-        case ' ':
-        case '\t':
-        case '=':
-          goto done_word;
-
-        case ':':
-#ifdef HAVE_DOS_PATHS
-          /* A word CAN include a colon in its drive spec.  The drive
-             spec is allowed either at the beginning of a word, or as part
-             of the archive member name, like in "libfoo.a(d:/foo/bar.o)".  */
-          if (!(p - beg >= 2
-                && (*p == '/' || *p == '\\') && isalpha ((unsigned char)p[-2])
-                && (p - beg == 2 || p[-3] == '(')))
-#endif
-          goto done_word;
-
-        case '$':
-          c = *(p++);
-          if (c == '$')
-            break;
-          if (c == '\0')
-            goto done_word;
-
-          /* This is a variable reference, so note that it's expandable.
-             Then read it to the matching close paren.  */
-          wtype = w_variable;
-
-          if (c == '(')
-            closeparen = ')';
-          else if (c == '{')
-            closeparen = '}';
-          else
-            /* This is a single-letter variable reference.  */
-            break;
-
-          for (count=0; *p != '\0'; ++p)
-            {
-              if (*p == c)
-                ++count;
-              else if (*p == closeparen && --count < 0)
-                {
-                  ++p;
-                  break;
-                }
-            }
-          break;
-
-        case '?':
-        case '+':
-          if (*p == '=')
-            goto done_word;
-          break;
-
-        case '\\':
-          switch (*p)
-            {
-            case ':':
-            case ';':
-            case '=':
-            case '\\':
-              ++p;
-              break;
-            }
-          break;
-
-        default:
-          if (delim && strchr (delim, c))
-            goto done_word;
-          break;
-        }
-
-      c = *(p++);
-    }
- done_word:
-  --p;
-
- done:
-  if (startp)
-    *startp = beg;
-  if (length)
-    *length = p - beg;
-  return wtype;
-}
-
-/* Construct the list of include directories
-   from the arguments and the default list.  */
-
-void
-construct_include_path (const char **arg_dirs)
-{
-#ifdef VAXC             /* just don't ask ... */
-  stat_t stbuf;
-#else
-  struct stat stbuf;
-#endif
-  const char **dirs;
-  const char **cpp;
-  unsigned int idx;
-
-  /* Compute the number of pointers we need in the table.  */
-  idx = sizeof (default_include_directories) / sizeof (const char *);
-  if (arg_dirs)
-    for (cpp = arg_dirs; *cpp != 0; ++cpp)
-      ++idx;
-
-#ifdef  __MSDOS__
-  /* Add one for $DJDIR.  */
-  ++idx;
-#endif
-
-  dirs = xmalloc (idx * sizeof (const char *));
-
-  idx = 0;
-  max_incl_len = 0;
-
-  /* First consider any dirs specified with -I switches.
-     Ignore any that don't exist.  Remember the maximum string length.  */
-
-  if (arg_dirs)
-    while (*arg_dirs != 0)
-      {
-        const char *dir = *(arg_dirs++);
-        char *expanded = 0;
-        int e;
-
-        if (dir[0] == '~')
-          {
-            expanded = tilde_expand (dir);
-            if (expanded != 0)
-              dir = expanded;
-          }
-
-        EINTRLOOP (e, stat (dir, &stbuf));
-        if (e == 0 && S_ISDIR (stbuf.st_mode))
-          {
-            unsigned int len = strlen (dir);
-            /* If dir name is written with trailing slashes, discard them.  */
-            while (len > 1 && dir[len - 1] == '/')
-              --len;
-            if (len > max_incl_len)
-              max_incl_len = len;
-            dirs[idx++] = strcache_add_len (dir, len);
-          }
-
-        free (expanded);
-      }
-
-  /* Now add the standard default dirs at the end.  */
-
-#ifdef  __MSDOS__
-  {
-    /* The environment variable $DJDIR holds the root of the DJGPP directory
-       tree; add ${DJDIR}/include.  */
-    struct variable *djdir = lookup_variable ("DJDIR", 5);
-
-    if (djdir)
-      {
-        unsigned int len = strlen (djdir->value) + 8;
-        char *defdir = alloca (len + 1);
-
-        strcat (strcpy (defdir, djdir->value), "/include");
-        dirs[idx++] = strcache_add (defdir);
-
-        if (len > max_incl_len)
-          max_incl_len = len;
-      }
-  }
-#endif
-
-  for (cpp = default_include_directories; *cpp != 0; ++cpp)
-    {
-      int e;
-
-      EINTRLOOP (e, stat (*cpp, &stbuf));
-      if (e == 0 && S_ISDIR (stbuf.st_mode))
-        {
-          unsigned int len = strlen (*cpp);
-          /* If dir name is written with trailing slashes, discard them.  */
-          while (len > 1 && (*cpp)[len - 1] == '/')
-            --len;
-          if (len > max_incl_len)
-            max_incl_len = len;
-          dirs[idx++] = strcache_add_len (*cpp, len);
-        }
-    }
-
-  dirs[idx] = 0;
-
-  /* Now add each dir to the .INCLUDE_DIRS variable.  */
-
-  for (cpp = dirs; *cpp != 0; ++cpp)
-    do_variable_definition (NILF, ".INCLUDE_DIRS", *cpp,
-                            o_default, f_append, 0);
-
-  include_directories = dirs;
-}
-
-/* Expand ~ or ~USER at the beginning of NAME.
-   Return a newly malloc'd string or 0.  */
-
-char *
-tilde_expand (const char *name)
-{
-#ifndef VMS
-  if (name[1] == '/' || name[1] == '\0')
-    {
-      char *home_dir;
-      int is_variable;
-
-      {
-        /* Turn off --warn-undefined-variables while we expand HOME.  */
-        int save = warn_undefined_variables_flag;
-        warn_undefined_variables_flag = 0;
-
-        home_dir = allocated_variable_expand ("$(HOME)");
-
-        warn_undefined_variables_flag = save;
-      }
-
-      is_variable = home_dir[0] != '\0';
-      if (!is_variable)
-        {
-          free (home_dir);
-          home_dir = getenv ("HOME");
-        }
-# if !defined(_AMIGA) && !defined(WINDOWS32)
-      if (home_dir == 0 || home_dir[0] == '\0')
-        {
-          char *logname = getlogin ();
-          home_dir = 0;
-          if (logname != 0)
-            {
-              struct passwd *p = getpwnam (logname);
-              if (p != 0)
-                home_dir = p->pw_dir;
-            }
-        }
-# endif /* !AMIGA && !WINDOWS32 */
-      if (home_dir != 0)
-        {
-          char *new = xstrdup (concat (2, home_dir, name + 1));
-          if (is_variable)
-            free (home_dir);
-          return new;
-        }
-    }
-# if !defined(_AMIGA) && !defined(WINDOWS32)
-  else
-    {
-      struct passwd *pwent;
-      char *userend = strchr (name + 1, '/');
-      if (userend != 0)
-        *userend = '\0';
-      pwent = getpwnam (name + 1);
-      if (pwent != 0)
-        {
-          if (userend == 0)
-            return xstrdup (pwent->pw_dir);
-          else
-            return xstrdup (concat (3, pwent->pw_dir, "/", userend + 1));
-        }
-      else if (userend != 0)
-        *userend = '/';
-    }
-# endif /* !AMIGA && !WINDOWS32 */
-#endif /* !VMS */
-  return 0;
-}
-
-/* Parse a string into a sequence of filenames represented as a chain of
-   struct nameseq's and return that chain.  Optionally expand the strings via
-   glob().
-
-   The string is passed as STRINGP, the address of a string pointer.
-   The string pointer is updated to point at the first character
-   not parsed, which either is a null char or equals STOPCHAR.
-
-   SIZE is how big to construct chain elements.
-   This is useful if we want them actually to be other structures
-   that have room for additional info.
-
-   PREFIX, if non-null, is added to the beginning of each filename.
-
-   FLAGS allows one or more of the following bitflags to be set:
-        PARSEFS_NOSTRIP - Do no strip './'s off the beginning
-        PARSEFS_NOAR    - Do not check filenames for archive references
-        PARSEFS_NOGLOB  - Do not expand globbing characters
-        PARSEFS_EXISTS  - Only return globbed files that actually exist
-                          (cannot also set NOGLOB)
-        PARSEFS_NOCACHE - Do not add filenames to the strcache (caller frees)
-  */
-
-void *
-parse_file_seq (char **stringp, unsigned int size, int stopmap,
-                const char *prefix, int flags)
-{
-  /* tmp points to tmpbuf after the prefix, if any.
-     tp is the end of the buffer. */
-  static char *tmpbuf = NULL;
-
-  int cachep = NONE_SET (flags, PARSEFS_NOCACHE);
-
-  struct nameseq *new = 0;
-  struct nameseq **newp = &new;
-#define NEWELT(_n)  do { \
-                        const char *__n = (_n); \
-                        *newp = xcalloc (size); \
-                        (*newp)->name = (cachep ? strcache_add (__n) : xstrdup (__n)); \
-                        newp = &(*newp)->next; \
-                    } while(0)
-
-  char *p;
-  glob_t gl;
-  char *tp;
-  int findmap = stopmap|MAP_VMSCOMMA|MAP_BLANK|MAP_NUL;
-
-  /* Always stop on NUL.  */
-  stopmap |= MAP_NUL;
-
-  if (size < sizeof (struct nameseq))
-    size = sizeof (struct nameseq);
-
-  if (NONE_SET (flags, PARSEFS_NOGLOB))
-    dir_setup_glob (&gl);
-
-  /* Get enough temporary space to construct the largest possible target.  */
-  {
-    static int tmpbuf_len = 0;
-    int l = strlen (*stringp) + 1;
-    if (l > tmpbuf_len)
-      {
-        tmpbuf = xrealloc (tmpbuf, l);
-        tmpbuf_len = l;
-      }
-  }
-  tp = tmpbuf;
-
-  /* Parse STRING.  P will always point to the end of the parsed content.  */
-  p = *stringp;
-  while (1)
-    {
-      const char *name;
-      const char **nlist = 0;
-      char *tildep = 0;
-      int globme = 1;
-#ifndef NO_ARCHIVES
-      char *arname = 0;
-      char *memname = 0;
-#endif
-      char *s;
-      int nlen;
-      int i;
-
-      /* Skip whitespace; at the end of the string or STOPCHAR we're done.  */
-      NEXT_TOKEN (p);
-      if (STOP_SET (*p, stopmap))
-        break;
-
-      /* There are names left, so find the end of the next name.
-         Throughout this iteration S points to the start.  */
-      s = p;
-      p = find_map_unquote (p, findmap);
-
-#ifdef VMS
-        /* convert comma separated list to space separated */
-      if (p && *p == ',')
-        *p =' ';
-#endif
-#ifdef _AMIGA
-      /* If we stopped due to a device name, skip it.  */
-      if (p && p != s+1 && p[0] == ':')
-        p = find_map_unquote (p+1, findmap);
-#endif
-#ifdef HAVE_DOS_PATHS
-      /* If we stopped due to a drive specifier, skip it.
-         Tokens separated by spaces are treated as separate paths since make
-         doesn't allow path names with spaces.  */
-      if (p && p == s+1 && p[0] == ':'
-          && isalpha ((unsigned char)s[0]) && STOP_SET (p[1], MAP_DIRSEP))
-        p = find_map_unquote (p+1, findmap);
-#endif
-
-      if (!p)
-        p = s + strlen (s);
-
-      /* Strip leading "this directory" references.  */
-      if (NONE_SET (flags, PARSEFS_NOSTRIP))
-#ifdef VMS
-        /* Skip leading '[]'s. should only be one set or bug somwhere else */
-        if (p - s > 2 && s[0] == '[' && s[1] == ']')
-            s += 2;
-        /* Skip leading '<>'s. should only be one set or bug somwhere else */
-        if (p - s > 2 && s[0] == '<' && s[1] == '>')
-            s += 2;
-#endif
-        /* Skip leading './'s.  */
-        while (p - s > 2 && s[0] == '.' && s[1] == '/')
-          {
-            /* Skip "./" and all following slashes.  */
-            s += 2;
-            while (*s == '/')
-              ++s;
-          }
-
-      /* Extract the filename just found, and skip it.
-         Set NAME to the string, and NLEN to its length.  */
-
-      if (s == p)
-        {
-        /* The name was stripped to empty ("./"). */
-#if defined(_AMIGA)
-          /* PDS-- This cannot be right!! */
-          tp[0] = '\0';
-          nlen = 0;
-#else
-          tp[0] = '.';
-          tp[1] = '/';
-          tp[2] = '\0';
-          nlen = 2;
-#endif
-        }
-      else
-        {
-#ifdef VMS
-/* VMS filenames can have a ':' in them but they have to be '\'ed but we need
- *  to remove this '\' before we can use the filename.
- * xstrdup called because S may be read-only string constant.
- */
-          char *n = tp;
-          while (s < p)
-            {
-              if (s[0] == '\\' && s[1] == ':')
-                ++s;
-              *(n++) = *(s++);
-            }
-          n[0] = '\0';
-          nlen = strlen (tp);
-#else
-          nlen = p - s;
-          memcpy (tp, s, nlen);
-          tp[nlen] = '\0';
-#endif
-        }
-
-      /* At this point, TP points to the element and NLEN is its length.  */
-
-#ifndef NO_ARCHIVES
-      /* If this is the start of an archive group that isn't complete, set up
-         to add the archive prefix for future files.  A file list like:
-         "libf.a(x.o y.o z.o)" needs to be expanded as:
-         "libf.a(x.o) libf.a(y.o) libf.a(z.o)"
-
-         TP == TMP means we're not already in an archive group.  Ignore
-         something starting with '(', as that cannot actually be an
-         archive-member reference (and treating it as such results in an empty
-         file name, which causes much lossage).  Also if it ends in ")" then
-         it's a complete reference so we don't need to treat it specially.
-
-         Finally, note that archive groups must end with ')' as the last
-         character, so ensure there's some word ending like that before
-         considering this an archive group.  */
-      if (NONE_SET (flags, PARSEFS_NOAR)
-          && tp == tmpbuf && tp[0] != '(' && tp[nlen-1] != ')')
-        {
-          char *n = strchr (tp, '(');
-          if (n)
-            {
-              /* This looks like the first element in an open archive group.
-                 A valid group MUST have ')' as the last character.  */
-              const char *e = p;
-              do
-                {
-                  const char *o = e;
-                  NEXT_TOKEN (e);
-                  /* Find the end of this word.  We don't want to unquote and
-                     we don't care about quoting since we're looking for the
-                     last char in the word. */
-                  while (! STOP_SET (*e, findmap))
-                    ++e;
-                  /* If we didn't move, we're done now.  */
-                  if (e == o)
-                    break;
-                  if (e[-1] == ')')
-                    {
-                      /* Found the end, so this is the first element in an
-                         open archive group.  It looks like "lib(mem".
-                         Reset TP past the open paren.  */
-                      nlen -= (n + 1) - tp;
-                      tp = n + 1;
-
-                      /* We can stop looking now.  */
-                      break;
-                    }
-                }
-              while (*e != '\0');
-
-              /* If we have just "lib(", part of something like "lib( a b)",
-                 go to the next item.  */
-              if (! nlen)
-                continue;
-            }
-        }
-
-      /* If we are inside an archive group, make sure it has an end.  */
-      if (tp > tmpbuf)
-        {
-          if (tp[nlen-1] == ')')
-            {
-              /* This is the natural end; reset TP.  */
-              tp = tmpbuf;
-
-              /* This is just ")", something like "lib(a b )": skip it.  */
-              if (nlen == 1)
-                continue;
-            }
-          else
-            {
-              /* Not the end, so add a "fake" end.  */
-              tp[nlen++] = ')';
-              tp[nlen] = '\0';
-            }
-        }
-#endif
-
-      /* If we're not globbing we're done: add it to the end of the chain.
-         Go to the next item in the string.  */
-      if (ANY_SET (flags, PARSEFS_NOGLOB))
-        {
-          NEWELT (concat (2, prefix, tmpbuf));
-          continue;
-        }
-
-      /* If we get here we know we're doing glob expansion.
-         TP is a string in tmpbuf.  NLEN is no longer used.
-         We may need to do more work: after this NAME will be set.  */
-      name = tmpbuf;
-
-      /* Expand tilde if applicable.  */
-      if (tmpbuf[0] == '~')
-        {
-          tildep = tilde_expand (tmpbuf);
-          if (tildep != 0)
-            name = tildep;
-        }
-
-#ifndef NO_ARCHIVES
-      /* If NAME is an archive member reference replace it with the archive
-         file name, and save the member name in MEMNAME.  We will glob on the
-         archive name and then reattach MEMNAME later.  */
-      if (NONE_SET (flags, PARSEFS_NOAR) && ar_name (name))
-        {
-          ar_parse_name (name, &arname, &memname);
-          name = arname;
-        }
-#endif /* !NO_ARCHIVES */
-
-      /* glob() is expensive: don't call it unless we need to.  */
-      if (NONE_SET (flags, PARSEFS_EXISTS) && strpbrk (name, "?*[") == NULL)
-        {
-          globme = 0;
-          i = 1;
-          nlist = &name;
-        }
-      else
-        switch (glob (name, GLOB_NOSORT|GLOB_ALTDIRFUNC, NULL, &gl))
-          {
-          case GLOB_NOSPACE:
-            out_of_memory ();
-
-          case 0:
-            /* Success.  */
-            i = gl.gl_pathc;
-            nlist = (const char **)gl.gl_pathv;
-            break;
-
-          case GLOB_NOMATCH:
-            /* If we want only existing items, skip this one.  */
-            if (ANY_SET (flags, PARSEFS_EXISTS))
-              {
-                i = 0;
-                break;
-              }
-            /* FALLTHROUGH */
-
-          default:
-            /* By default keep this name.  */
-            i = 1;
-            nlist = &name;
-            break;
-          }
-
-      /* For each matched element, add it to the list.  */
-      while (i-- > 0)
-#ifndef NO_ARCHIVES
-        if (memname != 0)
-          {
-            /* Try to glob on MEMNAME within the archive.  */
-            struct nameseq *found = ar_glob (nlist[i], memname, size);
-            if (! found)
-              /* No matches.  Use MEMNAME as-is.  */
-              NEWELT (concat (5, prefix, nlist[i], "(", memname, ")"));
-            else
-              {
-                /* We got a chain of items.  Attach them.  */
-                if (*newp)
-                  (*newp)->next = found;
-                else
-                  *newp = found;
-
-                /* Find and set the new end.  Massage names if necessary.  */
-                while (1)
-                  {
-                    if (! cachep)
-                      found->name = xstrdup (concat (2, prefix, name));
-                    else if (prefix)
-                      found->name = strcache_add (concat (2, prefix, name));
-
-                    if (found->next == 0)
-                      break;
-
-                    found = found->next;
-                  }
-                newp = &found->next;
-              }
-          }
-        else
-#endif /* !NO_ARCHIVES */
-          NEWELT (concat (2, prefix, nlist[i]));
-
-      if (globme)
-        globfree (&gl);
-
-#ifndef NO_ARCHIVES
-      free (arname);
-#endif
-
-      free (tildep);
-    }
-
-  *stringp = p;
-  return new;
-}
diff --git a/remake.c b/remake.c
deleted file mode 100644
index b4bf1cb..0000000
--- a/remake.c
+++ /dev/null
@@ -1,1755 +0,0 @@
-/* Basic dependency engine for GNU Make.
-Copyright (C) 1988-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-#include "filedef.h"
-#include "job.h"
-#include "commands.h"
-#include "dep.h"
-#include "variable.h"
-#include "debug.h"
-
-#include <assert.h>
-
-#ifdef HAVE_FCNTL_H
-#include <fcntl.h>
-#else
-#include <sys/file.h>
-#endif
-
-#ifdef VMS
-#include <starlet.h>
-#endif
-#ifdef WINDOWS32
-#include <io.h>
-#endif
-
-
-/* The test for circular dependencies is based on the 'updating' bit in
-   'struct file'.  However, double colon targets have separate 'struct
-   file's; make sure we always use the base of the double colon chain. */
-
-#define start_updating(_f)  (((_f)->double_colon ? (_f)->double_colon : (_f))\
-                             ->updating = 1)
-#define finish_updating(_f) (((_f)->double_colon ? (_f)->double_colon : (_f))\
-                             ->updating = 0)
-#define is_updating(_f)     (((_f)->double_colon ? (_f)->double_colon : (_f))\
-                             ->updating)
-
-
-/* Incremented when a command is started (under -n, when one would be).  */
-unsigned int commands_started = 0;
-
-/* Set to the goal dependency.  Mostly needed for remaking makefiles.  */
-static struct goaldep *goal_list;
-static struct dep *goal_dep;
-
-/* Current value for pruning the scan of the goal chain.
-   All files start with considered == 0.  */
-static unsigned int considered = 0;
-
-static enum update_status update_file (struct file *file, unsigned int depth);
-static enum update_status update_file_1 (struct file *file, unsigned int depth);
-static enum update_status check_dep (struct file *file, unsigned int depth,
-                                     FILE_TIMESTAMP this_mtime, int *must_make);
-static enum update_status touch_file (struct file *file);
-static void remake_file (struct file *file);
-static FILE_TIMESTAMP name_mtime (const char *name);
-static const char *library_search (const char *lib, FILE_TIMESTAMP *mtime_ptr);
-
-
-/* Remake all the goals in the 'struct dep' chain GOALS.  Return -1 if nothing
-   was done, 0 if all goals were updated successfully, or 1 if a goal failed.
-
-   If rebuilding_makefiles is nonzero, these goals are makefiles, so -t, -q,
-   and -n should be disabled for them unless they were also command-line
-   targets, and we should only make one goal at a time and return as soon as
-   one goal whose 'changed' member is nonzero is successfully made.  */
-
-enum update_status
-update_goal_chain (struct goaldep *goaldeps)
-{
-  int t = touch_flag, q = question_flag, n = just_print_flag;
-  enum update_status status = us_none;
-
-  /* Duplicate the chain so we can remove things from it.  */
-
-  struct dep *goals = copy_dep_chain ((struct dep *)goaldeps);
-
-  goal_list = rebuilding_makefiles ? goaldeps : NULL;
-
-#define MTIME(file) (rebuilding_makefiles ? file_mtime_no_search (file) \
-                     : file_mtime (file))
-
-  /* Start a fresh batch of consideration.  */
-  ++considered;
-
-  /* Update all the goals until they are all finished.  */
-
-  while (goals != 0)
-    {
-      struct dep *g, *lastgoal;
-
-      /* Start jobs that are waiting for the load to go down.  */
-
-      start_waiting_jobs ();
-
-      /* Wait for a child to die.  */
-
-      reap_children (1, 0);
-
-      lastgoal = 0;
-      g = goals;
-      while (g != 0)
-        {
-          /* Iterate over all double-colon entries for this file.  */
-          struct file *file;
-          int stop = 0, any_not_updated = 0;
-
-          goal_dep = g;
-
-          for (file = g->file->double_colon ? g->file->double_colon : g->file;
-               file != NULL;
-               file = file->prev)
-            {
-              unsigned int ocommands_started;
-              enum update_status fail;
-
-              file->dontcare = ANY_SET (g->flags, RM_DONTCARE);
-
-              check_renamed (file);
-              if (rebuilding_makefiles)
-                {
-                  if (file->cmd_target)
-                    {
-                      touch_flag = t;
-                      question_flag = q;
-                      just_print_flag = n;
-                    }
-                  else
-                    touch_flag = question_flag = just_print_flag = 0;
-                }
-
-              /* Save the old value of 'commands_started' so we can compare
-                 later.  It will be incremented when any commands are
-                 actually run.  */
-              ocommands_started = commands_started;
-
-              fail = update_file (file, rebuilding_makefiles ? 1 : 0);
-              check_renamed (file);
-
-              /* Set the goal's 'changed' flag if any commands were started
-                 by calling update_file above.  We check this flag below to
-                 decide when to give an "up to date" diagnostic.  */
-              if (commands_started > ocommands_started)
-                g->changed = 1;
-
-              stop = 0;
-              if ((fail || file->updated) && status < us_question)
-                {
-                  /* We updated this goal.  Update STATUS and decide whether
-                     to stop.  */
-                  if (file->update_status)
-                    {
-                      /* Updating failed, or -q triggered.  The STATUS value
-                         tells our caller which.  */
-                      status = file->update_status;
-                      /* If -q just triggered, stop immediately.  It doesn't
-                         matter how much more we run, since we already know
-                         the answer to return.  */
-                      stop = (question_flag && !keep_going_flag
-                              && !rebuilding_makefiles);
-                    }
-                  else
-                    {
-                      FILE_TIMESTAMP mtime = MTIME (file);
-                      check_renamed (file);
-
-                      if (file->updated && g->changed &&
-                           mtime != file->mtime_before_update)
-                        {
-                          /* Updating was done.  If this is a makefile and
-                             just_print_flag or question_flag is set (meaning
-                             -n or -q was given and this file was specified
-                             as a command-line target), don't change STATUS.
-                             If STATUS is changed, we will get re-exec'd, and
-                             enter an infinite loop.  */
-                          if (!rebuilding_makefiles
-                              || (!just_print_flag && !question_flag))
-                            status = us_success;
-                          if (rebuilding_makefiles && file->dontcare)
-                            /* This is a default makefile; stop remaking.  */
-                            stop = 1;
-                        }
-                    }
-                }
-
-              /* Keep track if any double-colon entry is not finished.
-                 When they are all finished, the goal is finished.  */
-              any_not_updated |= !file->updated;
-
-              file->dontcare = 0;
-
-              if (stop)
-                break;
-            }
-
-          /* Reset FILE since it is null at the end of the loop.  */
-          file = g->file;
-
-          if (stop || !any_not_updated)
-            {
-              /* If we have found nothing whatever to do for the goal,
-                 print a message saying nothing needs doing.  */
-
-              if (!rebuilding_makefiles
-                  /* If the update_status is success, we updated successfully
-                     or not at all.  G->changed will have been set above if
-                     any commands were actually started for this goal.  */
-                  && file->update_status == us_success && !g->changed
-                  /* Never give a message under -s or -q.  */
-                  && !silent_flag && !question_flag)
-                OS (message, 1, ((file->phony || file->cmds == 0)
-                                 ? _("Nothing to be done for '%s'.")
-                                 : _("'%s' is up to date.")),
-                    file->name);
-
-              /* This goal is finished.  Remove it from the chain.  */
-              if (lastgoal == 0)
-                goals = g->next;
-              else
-                lastgoal->next = g->next;
-
-              /* Free the storage.  */
-              free (g);
-
-              g = lastgoal == 0 ? goals : lastgoal->next;
-
-              if (stop)
-                break;
-            }
-          else
-            {
-              lastgoal = g;
-              g = g->next;
-            }
-        }
-
-      /* If we reached the end of the dependency graph update CONSIDERED
-         for the next pass.  */
-      if (g == 0)
-        ++considered;
-    }
-
-  if (rebuilding_makefiles)
-    {
-      touch_flag = t;
-      question_flag = q;
-      just_print_flag = n;
-    }
-
-  return status;
-}
-
-/* If we're rebuilding an included makefile that failed, and we care
-   about errors, show an error message the first time.  */
-
-void
-show_goal_error (void)
-{
-  struct goaldep *goal;
-
-  if ((goal_dep->flags & (RM_INCLUDED|RM_DONTCARE)) != RM_INCLUDED)
-    return;
-
-  for (goal = goal_list; goal; goal = goal->next)
-    if (goal_dep->file == goal->file)
-      {
-        if (goal->error)
-          {
-            OSS (error, &goal->floc, "%s: %s",
-                 goal->file->name, strerror ((int)goal->error));
-            goal->error = 0;
-          }
-        return;
-      }
-}
-
-/* If FILE is not up to date, execute the commands for it.
-   Return 0 if successful, non-0 if unsuccessful;
-   but with some flag settings, just call 'exit' if unsuccessful.
-
-   DEPTH is the depth in recursions of this function.
-   We increment it during the consideration of our dependencies,
-   then decrement it again after finding out whether this file
-   is out of date.
-
-   If there are multiple double-colon entries for FILE,
-   each is considered in turn.  */
-
-static enum update_status
-update_file (struct file *file, unsigned int depth)
-{
-  enum update_status status = us_success;
-  struct file *f;
-
-  f = file->double_colon ? file->double_colon : file;
-
-  /* Prune the dependency graph: if we've already been here on _this_
-     pass through the dependency graph, we don't have to go any further.
-     We won't reap_children until we start the next pass, so no state
-     change is possible below here until then.  */
-  if (f->considered == considered)
-    {
-      /* Check for the case where a target has been tried and failed but
-         the diagnostics haven't been issued. If we need the diagnostics
-         then we will have to continue. */
-      if (!(f->updated && f->update_status > us_none
-            && !f->dontcare && f->no_diag))
-        {
-          DBF (DB_VERBOSE, _("Pruning file '%s'.\n"));
-          return f->command_state == cs_finished ? f->update_status : us_success;
-        }
-    }
-
-  /* This loop runs until we start commands for a double colon rule, or until
-     the chain is exhausted. */
-  for (; f != 0; f = f->prev)
-    {
-      enum update_status new;
-
-      f->considered = considered;
-
-      new = update_file_1 (f, depth);
-      check_renamed (f);
-
-      /* Clean up any alloca() used during the update.  */
-      alloca (0);
-
-      /* If we got an error, don't bother with double_colon etc.  */
-      if (new && !keep_going_flag)
-        return new;
-
-      if (f->command_state == cs_running
-          || f->command_state == cs_deps_running)
-        /* Don't run other :: rules for this target until
-           this rule is finished.  */
-        return us_success;
-
-      if (new > status)
-        status = new;
-    }
-
-  return status;
-}
-
-/* Show a message stating the target failed to build.  */
-
-static void
-complain (struct file *file)
-{
-  /* If this file has no_diag set then it means we tried to update it
-     before in the dontcare mode and failed. The target that actually
-     failed is not necessarily this file but could be one of its direct
-     or indirect dependencies. So traverse this file's dependencies and
-     find the one that actually caused the failure. */
-
-  struct dep *d;
-
-  for (d = file->deps; d != 0; d = d->next)
-    {
-      if (d->file->updated && d->file->update_status > us_none && file->no_diag)
-        {
-          complain (d->file);
-          break;
-        }
-    }
-
-  if (d == 0)
-    {
-      show_goal_error ();
-
-      /* Didn't find any dependencies to complain about. */
-      if (file->parent)
-        {
-          size_t l = strlen (file->name) + strlen (file->parent->name) + 4;
-          const char *m = _("%sNo rule to make target '%s', needed by '%s'%s");
-
-          if (!keep_going_flag)
-            fatal (NILF, l, m, "", file->name, file->parent->name, "");
-
-          error (NILF, l, m, "*** ", file->name, file->parent->name, ".");
-        }
-      else
-        {
-          size_t l = strlen (file->name) + 4;
-          const char *m = _("%sNo rule to make target '%s'%s");
-
-          if (!keep_going_flag)
-            fatal (NILF, l, m, "", file->name, "");
-
-          error (NILF, l, m, "*** ", file->name, ".");
-        }
-
-      file->no_diag = 0;
-    }
-}
-
-/* Consider a single 'struct file' and update it as appropriate.
-   Return 0 on success, or non-0 on failure.  */
-
-static enum update_status
-update_file_1 (struct file *file, unsigned int depth)
-{
-  enum update_status dep_status = us_success;
-  FILE_TIMESTAMP this_mtime;
-  int noexist, must_make, deps_changed;
-  struct file *ofile;
-  struct dep *d, *ad;
-  struct dep amake;
-  int running = 0;
-
-  DBF (DB_VERBOSE, _("Considering target file '%s'.\n"));
-
-  if (file->updated)
-    {
-      if (file->update_status > us_none)
-        {
-          DBF (DB_VERBOSE,
-               _("Recently tried and failed to update file '%s'.\n"));
-
-          /* If the file we tried to make is marked no_diag then no message
-             was printed about it when it failed during the makefile rebuild.
-             If we're trying to build it again in the normal rebuild, print a
-             message now.  */
-          if (file->no_diag && !file->dontcare)
-              complain (file);
-
-          return file->update_status;
-        }
-
-      DBF (DB_VERBOSE, _("File '%s' was considered already.\n"));
-      return 0;
-    }
-
-  switch (file->command_state)
-    {
-    case cs_not_started:
-    case cs_deps_running:
-      break;
-    case cs_running:
-      DBF (DB_VERBOSE, _("Still updating file '%s'.\n"));
-      return 0;
-    case cs_finished:
-      DBF (DB_VERBOSE, _("Finished updating file '%s'.\n"));
-      return file->update_status;
-    default:
-      abort ();
-    }
-
-  /* Determine whether the diagnostics will be issued should this update
-     fail. */
-  file->no_diag = file->dontcare;
-
-  ++depth;
-
-  /* Notice recursive update of the same file.  */
-  start_updating (file);
-
-  /* We might change file if we find a different one via vpath;
-     remember this one to turn off updating.  */
-  ofile = file;
-
-  /* Looking at the file's modtime beforehand allows the possibility
-     that its name may be changed by a VPATH search, and thus it may
-     not need an implicit rule.  If this were not done, the file
-     might get implicit commands that apply to its initial name, only
-     to have that name replaced with another found by VPATH search.  */
-
-  this_mtime = file_mtime (file);
-  check_renamed (file);
-  noexist = this_mtime == NONEXISTENT_MTIME;
-  if (noexist)
-    DBF (DB_BASIC, _("File '%s' does not exist.\n"));
-  else if (ORDINARY_MTIME_MIN <= this_mtime && this_mtime <= ORDINARY_MTIME_MAX
-           && file->low_resolution_time)
-    {
-      /* Avoid spurious rebuilds due to low resolution time stamps.  */
-      int ns = FILE_TIMESTAMP_NS (this_mtime);
-      if (ns != 0)
-        OS (error, NILF,
-            _("*** Warning: .LOW_RESOLUTION_TIME file '%s' has a high resolution time stamp"),
-            file->name);
-      this_mtime += FILE_TIMESTAMPS_PER_S - 1 - ns;
-    }
-
-  must_make = noexist;
-
-  /* If file was specified as a target with no commands,
-     come up with some default commands.  */
-
-  if (!file->phony && file->cmds == 0 && !file->tried_implicit)
-    {
-      if (try_implicit_rule (file, depth))
-        DBF (DB_IMPLICIT, _("Found an implicit rule for '%s'.\n"));
-      else
-        DBF (DB_IMPLICIT, _("No implicit rule found for '%s'.\n"));
-      file->tried_implicit = 1;
-    }
-  if (file->cmds == 0 && !file->is_target
-      && default_file != 0 && default_file->cmds != 0)
-    {
-      DBF (DB_IMPLICIT, _("Using default recipe for '%s'.\n"));
-      file->cmds = default_file->cmds;
-    }
-
-  /* Update all non-intermediate files we depend on, if necessary, and see
-     whether any of them is more recent than this file.  We need to walk our
-     deps, AND the deps of any also_make targets to ensure everything happens
-     in the correct order.  */
-
-  amake.file = file;
-  amake.next = file->also_make;
-  ad = &amake;
-  while (ad)
-    {
-      struct dep *lastd = 0;
-
-      /* Find the deps we're scanning */
-      d = ad->file->deps;
-      ad = ad->next;
-
-      while (d)
-        {
-          enum update_status new;
-          FILE_TIMESTAMP mtime;
-          int maybe_make;
-          int dontcare = 0;
-
-          check_renamed (d->file);
-
-          mtime = file_mtime (d->file);
-          check_renamed (d->file);
-
-          if (is_updating (d->file))
-            {
-              OSS (error, NILF, _("Circular %s <- %s dependency dropped."),
-                   file->name, d->file->name);
-              /* We cannot free D here because our the caller will still have
-                 a reference to it when we were called recursively via
-                 check_dep below.  */
-              if (lastd == 0)
-                file->deps = d->next;
-              else
-                lastd->next = d->next;
-              d = d->next;
-              continue;
-            }
-
-          d->file->parent = file;
-          maybe_make = must_make;
-
-          /* Inherit dontcare flag from our parent. */
-          if (rebuilding_makefiles)
-            {
-              dontcare = d->file->dontcare;
-              d->file->dontcare = file->dontcare;
-            }
-
-          new = check_dep (d->file, depth, this_mtime, &maybe_make);
-          if (new > dep_status)
-            dep_status = new;
-
-          /* Restore original dontcare flag. */
-          if (rebuilding_makefiles)
-            d->file->dontcare = dontcare;
-
-          if (! d->ignore_mtime)
-            must_make = maybe_make;
-
-          check_renamed (d->file);
-
-          {
-            struct file *f = d->file;
-            if (f->double_colon)
-              f = f->double_colon;
-            do
-              {
-                running |= (f->command_state == cs_running
-                            || f->command_state == cs_deps_running);
-                f = f->prev;
-              }
-            while (f != 0);
-          }
-
-          if (dep_status && !keep_going_flag)
-            break;
-
-          if (!running)
-            /* The prereq is considered changed if the timestamp has changed
-               while it was built, OR it doesn't exist.  */
-            d->changed = ((file_mtime (d->file) != mtime)
-                          || (mtime == NONEXISTENT_MTIME));
-
-          lastd = d;
-          d = d->next;
-        }
-    }
-
-  /* Now we know whether this target needs updating.
-     If it does, update all the intermediate files we depend on.  */
-
-  if (must_make || always_make_flag)
-    {
-      for (d = file->deps; d != 0; d = d->next)
-        if (d->file->intermediate)
-          {
-            enum update_status new;
-            int dontcare = 0;
-
-            FILE_TIMESTAMP mtime = file_mtime (d->file);
-            check_renamed (d->file);
-            d->file->parent = file;
-
-            /* Inherit dontcare flag from our parent. */
-            if (rebuilding_makefiles)
-              {
-                dontcare = d->file->dontcare;
-                d->file->dontcare = file->dontcare;
-              }
-
-            /* We may have already considered this file, when we didn't know
-               we'd need to update it.  Force update_file() to consider it and
-               not prune it.  */
-            d->file->considered = 0;
-
-            new = update_file (d->file, depth);
-            if (new > dep_status)
-              dep_status = new;
-
-            /* Restore original dontcare flag. */
-            if (rebuilding_makefiles)
-              d->file->dontcare = dontcare;
-
-            check_renamed (d->file);
-
-            {
-              struct file *f = d->file;
-              if (f->double_colon)
-                f = f->double_colon;
-              do
-                {
-                  running |= (f->command_state == cs_running
-                              || f->command_state == cs_deps_running);
-                  f = f->prev;
-                }
-              while (f != 0);
-            }
-
-            if (dep_status && !keep_going_flag)
-              break;
-
-            if (!running)
-              d->changed = ((file->phony && file->cmds != 0)
-                            || file_mtime (d->file) != mtime);
-          }
-    }
-
-  finish_updating (file);
-  finish_updating (ofile);
-
-  DBF (DB_VERBOSE, _("Finished prerequisites of target file '%s'.\n"));
-
-  if (running)
-    {
-      set_command_state (file, cs_deps_running);
-      --depth;
-      DBF (DB_VERBOSE, _("The prerequisites of '%s' are being made.\n"));
-      return 0;
-    }
-
-  /* If any dependency failed, give up now.  */
-
-  if (dep_status)
-    {
-      /* I'm not sure if we can't just assign dep_status...  */
-      file->update_status = dep_status == us_none ? us_failed : dep_status;
-      notice_finished_file (file);
-
-      --depth;
-
-      DBF (DB_VERBOSE, _("Giving up on target file '%s'.\n"));
-
-      if (depth == 0 && keep_going_flag
-          && !just_print_flag && !question_flag)
-        OS (error, NILF,
-            _("Target '%s' not remade because of errors."), file->name);
-
-      return dep_status;
-    }
-
-  if (file->command_state == cs_deps_running)
-    /* The commands for some deps were running on the last iteration, but
-       they have finished now.  Reset the command_state to not_started to
-       simplify later bookkeeping.  It is important that we do this only
-       when the prior state was cs_deps_running, because that prior state
-       was definitely propagated to FILE's also_make's by set_command_state
-       (called above), but in another state an also_make may have
-       independently changed to finished state, and we would confuse that
-       file's bookkeeping (updated, but not_started is bogus state).  */
-    set_command_state (file, cs_not_started);
-
-  /* Now record which prerequisites are more
-     recent than this file, so we can define $?.  */
-
-  deps_changed = 0;
-  for (d = file->deps; d != 0; d = d->next)
-    {
-      FILE_TIMESTAMP d_mtime = file_mtime (d->file);
-      check_renamed (d->file);
-
-      if (! d->ignore_mtime)
-        {
-#if 1
-          /* %%% In version 4, remove this code completely to
-           implement not remaking deps if their deps are newer
-           than their parents.  */
-          if (d_mtime == NONEXISTENT_MTIME && !d->file->intermediate)
-            /* We must remake if this dep does not
-               exist and is not intermediate.  */
-            must_make = 1;
-#endif
-
-          /* Set DEPS_CHANGED if this dep actually changed.  */
-          deps_changed |= d->changed;
-        }
-
-      /* Set D->changed if either this dep actually changed,
-         or its dependent, FILE, is older or does not exist.  */
-      d->changed |= noexist || d_mtime > this_mtime;
-
-      if (!noexist && ISDB (DB_BASIC|DB_VERBOSE))
-        {
-          const char *fmt = 0;
-
-          if (d->ignore_mtime)
-            {
-              if (ISDB (DB_VERBOSE))
-                fmt = _("Prerequisite '%s' is order-only for target '%s'.\n");
-            }
-          else if (d_mtime == NONEXISTENT_MTIME)
-            {
-              if (ISDB (DB_BASIC))
-                fmt = _("Prerequisite '%s' of target '%s' does not exist.\n");
-            }
-          else if (d->changed)
-            {
-              if (ISDB (DB_BASIC))
-                fmt = _("Prerequisite '%s' is newer than target '%s'.\n");
-            }
-          else if (ISDB (DB_VERBOSE))
-            fmt = _("Prerequisite '%s' is older than target '%s'.\n");
-
-          if (fmt)
-            {
-              print_spaces (depth);
-              printf (fmt, dep_name (d), file->name);
-              fflush (stdout);
-            }
-        }
-    }
-
-  /* Here depth returns to the value it had when we were called.  */
-  depth--;
-
-  if (file->double_colon && file->deps == 0)
-    {
-      must_make = 1;
-      DBF (DB_BASIC,
-           _("Target '%s' is double-colon and has no prerequisites.\n"));
-    }
-  else if (!noexist && file->is_target && !deps_changed && file->cmds == 0
-           && !always_make_flag)
-    {
-      must_make = 0;
-      DBF (DB_VERBOSE,
-           _("No recipe for '%s' and no prerequisites actually changed.\n"));
-    }
-  else if (!must_make && file->cmds != 0 && always_make_flag)
-    {
-      must_make = 1;
-      DBF (DB_VERBOSE, _("Making '%s' due to always-make flag.\n"));
-    }
-
-  if (!must_make)
-    {
-      if (ISDB (DB_VERBOSE))
-        {
-          print_spaces (depth);
-          printf (_("No need to remake target '%s'"), file->name);
-          if (!streq (file->name, file->hname))
-              printf (_("; using VPATH name '%s'"), file->hname);
-          puts (".");
-          fflush (stdout);
-        }
-
-      notice_finished_file (file);
-
-      /* Since we don't need to remake the file, convert it to use the
-         VPATH filename if we found one.  hfile will be either the
-         local name if no VPATH or the VPATH name if one was found.  */
-
-      while (file)
-        {
-          file->name = file->hname;
-          file = file->prev;
-        }
-
-      return 0;
-    }
-
-  DBF (DB_BASIC, _("Must remake target '%s'.\n"));
-
-  /* It needs to be remade.  If it's VPATH and not reset via GPATH, toss the
-     VPATH.  */
-  if (!streq (file->name, file->hname))
-    {
-      DB (DB_BASIC, (_("  Ignoring VPATH name '%s'.\n"), file->hname));
-      file->ignore_vpath = 1;
-    }
-
-  /* Now, take appropriate actions to remake the file.  */
-  remake_file (file);
-
-  if (file->command_state != cs_finished)
-    {
-      DBF (DB_VERBOSE, _("Recipe of '%s' is being run.\n"));
-      return 0;
-    }
-
-  switch (file->update_status)
-    {
-    case us_failed:
-      DBF (DB_BASIC, _("Failed to remake target file '%s'.\n"));
-      break;
-    case us_success:
-      DBF (DB_BASIC, _("Successfully remade target file '%s'.\n"));
-      break;
-    case us_question:
-      DBF (DB_BASIC, _("Target file '%s' needs to be remade under -q.\n"));
-      break;
-    case us_none:
-      break;
-    }
-
-  file->updated = 1;
-  return file->update_status;
-}
-
-/* Set FILE's 'updated' flag and re-check its mtime and the mtime's of all
-   files listed in its 'also_make' member.  Under -t, this function also
-   touches FILE.
-
-   On return, FILE->update_status will no longer be us_none if it was.  */
-
-void
-notice_finished_file (struct file *file)
-{
-  struct dep *d;
-  int ran = file->command_state == cs_running;
-  int touched = 0;
-
-  file->command_state = cs_finished;
-  file->updated = 1;
-
-  if (touch_flag
-      /* The update status will be:
-           us_success   if 0 or more commands (+ or ${MAKE}) were run and won;
-           us_none      if this target was not remade;
-           >us_none     if some commands were run and lost.
-         We touch the target if it has commands which either were not run
-         or won when they ran (i.e. status is 0).  */
-      && file->update_status == us_success)
-    {
-      if (file->cmds != 0 && file->cmds->any_recurse)
-        {
-          /* If all the command lines were recursive,
-             we don't want to do the touching.  */
-          unsigned int i;
-          for (i = 0; i < file->cmds->ncommand_lines; ++i)
-            if (!(file->cmds->lines_flags[i] & COMMANDS_RECURSE))
-              goto have_nonrecursing;
-        }
-      else
-        {
-        have_nonrecursing:
-          if (file->phony)
-            file->update_status = us_success;
-          /* According to POSIX, -t doesn't affect targets with no cmds.  */
-          else if (file->cmds != 0)
-            {
-              /* Should set file's modification date and do nothing else.  */
-              file->update_status = touch_file (file);
-
-              /* Pretend we ran a real touch command, to suppress the
-                 "'foo' is up to date" message.  */
-              commands_started++;
-
-              /* Request for the timestamp to be updated (and distributed
-                 to the double-colon entries). Simply setting ran=1 would
-                 almost have done the trick, but messes up with the also_make
-                 updating logic below.  */
-              touched = 1;
-            }
-        }
-    }
-
-  if (file->mtime_before_update == UNKNOWN_MTIME)
-    file->mtime_before_update = file->last_mtime;
-
-  if ((ran && !file->phony) || touched)
-    {
-      int i = 0;
-
-      /* If -n, -t, or -q and all the commands are recursive, we ran them so
-         really check the target's mtime again.  Otherwise, assume the target
-         would have been updated. */
-
-      if ((question_flag || just_print_flag || touch_flag) && file->cmds)
-        {
-          for (i = file->cmds->ncommand_lines; i > 0; --i)
-            if (! (file->cmds->lines_flags[i-1] & COMMANDS_RECURSE))
-              break;
-        }
-
-      /* If there were no commands at all, it's always new. */
-
-      else if (file->is_target && file->cmds == 0)
-        i = 1;
-
-      file->last_mtime = i == 0 ? UNKNOWN_MTIME : NEW_MTIME;
-    }
-
-  if (file->double_colon)
-    {
-      /* If this is a double colon rule and it is the last one to be
-         updated, propagate the change of modification time to all the
-         double-colon entries for this file.
-
-         We do it on the last update because it is important to handle
-         individual entries as separate rules with separate timestamps
-         while they are treated as targets and then as one rule with the
-         unified timestamp when they are considered as a prerequisite
-         of some target.  */
-
-      struct file *f;
-      FILE_TIMESTAMP max_mtime = file->last_mtime;
-
-      /* Check that all rules were updated and at the same time find
-         the max timestamp.  We assume UNKNOWN_MTIME is newer then
-         any other value.  */
-      for (f = file->double_colon; f != 0 && f->updated; f = f->prev)
-        if (max_mtime != UNKNOWN_MTIME
-            && (f->last_mtime == UNKNOWN_MTIME || f->last_mtime > max_mtime))
-          max_mtime = f->last_mtime;
-
-      if (f == 0)
-        for (f = file->double_colon; f != 0; f = f->prev)
-          f->last_mtime = max_mtime;
-    }
-
-  if (ran && file->update_status != us_none)
-    /* We actually tried to update FILE, which has
-       updated its also_make's as well (if it worked).
-       If it didn't work, it wouldn't work again for them.
-       So mark them as updated with the same status.  */
-    for (d = file->also_make; d != 0; d = d->next)
-      {
-        d->file->command_state = cs_finished;
-        d->file->updated = 1;
-        d->file->update_status = file->update_status;
-
-        if (ran && !d->file->phony)
-          /* Fetch the new modification time.
-             We do this instead of just invalidating the cached time
-             so that a vpath_search can happen.  Otherwise, it would
-             never be done because the target is already updated.  */
-          f_mtime (d->file, 0);
-      }
-  else if (file->update_status == us_none)
-    /* Nothing was done for FILE, but it needed nothing done.
-       So mark it now as "succeeded".  */
-    file->update_status = us_success;
-}
-
-/* Check whether another file (whose mtime is THIS_MTIME) needs updating on
-   account of a dependency which is file FILE.  If it does, store 1 in
-   *MUST_MAKE_PTR.  In the process, update any non-intermediate files that
-   FILE depends on (including FILE itself).  Return nonzero if any updating
-   failed.  */
-
-static enum update_status
-check_dep (struct file *file, unsigned int depth,
-           FILE_TIMESTAMP this_mtime, int *must_make_ptr)
-{
-  struct file *ofile;
-  struct dep *d;
-  enum update_status dep_status = us_success;
-
-  ++depth;
-  start_updating (file);
-
-  /* We might change file if we find a different one via vpath;
-     remember this one to turn off updating.  */
-  ofile = file;
-
-  if (file->phony || !file->intermediate)
-    {
-      /* If this is a non-intermediate file, update it and record whether it
-         is newer than THIS_MTIME.  */
-      FILE_TIMESTAMP mtime;
-      dep_status = update_file (file, depth);
-      check_renamed (file);
-      mtime = file_mtime (file);
-      check_renamed (file);
-      if (mtime == NONEXISTENT_MTIME || mtime > this_mtime)
-        *must_make_ptr = 1;
-    }
-  else
-    {
-      /* FILE is an intermediate file.  */
-      FILE_TIMESTAMP mtime;
-
-      if (!file->phony && file->cmds == 0 && !file->tried_implicit)
-        {
-          if (try_implicit_rule (file, depth))
-            DBF (DB_IMPLICIT, _("Found an implicit rule for '%s'.\n"));
-          else
-            DBF (DB_IMPLICIT, _("No implicit rule found for '%s'.\n"));
-          file->tried_implicit = 1;
-        }
-      if (file->cmds == 0 && !file->is_target
-          && default_file != 0 && default_file->cmds != 0)
-        {
-          DBF (DB_IMPLICIT, _("Using default commands for '%s'.\n"));
-          file->cmds = default_file->cmds;
-        }
-
-      check_renamed (file);
-      mtime = file_mtime (file);
-      check_renamed (file);
-      if (mtime != NONEXISTENT_MTIME && mtime > this_mtime)
-        /* If the intermediate file actually exists and is newer, then we
-           should remake from it.  */
-        *must_make_ptr = 1;
-      else
-        {
-          /* Otherwise, update all non-intermediate files we depend on, if
-             necessary, and see whether any of them is more recent than the
-             file on whose behalf we are checking.  */
-          struct dep *ld;
-          int deps_running = 0;
-
-          /* If this target is not running, set it's state so that we check it
-             fresh.  It could be it was checked as part of an order-only
-             prerequisite and so wasn't rebuilt then, but should be now.  */
-          if (file->command_state != cs_running)
-            {
-              /* If the target was waiting for a dependency it has to be
-                 reconsidered, as that dependency might have finished.  */
-              if (file->command_state == cs_deps_running)
-                file->considered = 0;
-
-              set_command_state (file, cs_not_started);
-            }
-
-          ld = 0;
-          d = file->deps;
-          while (d != 0)
-            {
-              enum update_status new;
-              int maybe_make;
-
-              if (is_updating (d->file))
-                {
-                  OSS (error, NILF, _("Circular %s <- %s dependency dropped."),
-                       file->name, d->file->name);
-                  if (ld == 0)
-                    {
-                      file->deps = d->next;
-                      free_dep (d);
-                      d = file->deps;
-                    }
-                  else
-                    {
-                      ld->next = d->next;
-                      free_dep (d);
-                      d = ld->next;
-                    }
-                  continue;
-                }
-
-              d->file->parent = file;
-              maybe_make = *must_make_ptr;
-              new = check_dep (d->file, depth, this_mtime, &maybe_make);
-              if (new > dep_status)
-                dep_status = new;
-
-              if (! d->ignore_mtime)
-                *must_make_ptr = maybe_make;
-              check_renamed (d->file);
-              if (dep_status && !keep_going_flag)
-                break;
-
-              if (d->file->command_state == cs_running
-                  || d->file->command_state == cs_deps_running)
-                deps_running = 1;
-
-              ld = d;
-              d = d->next;
-            }
-
-          if (deps_running)
-            /* Record that some of FILE's deps are still being made.
-               This tells the upper levels to wait on processing it until the
-               commands are finished.  */
-            set_command_state (file, cs_deps_running);
-        }
-    }
-
-  finish_updating (file);
-  finish_updating (ofile);
-
-  return dep_status;
-}
-
-/* Touch FILE.  Return us_success if successful, us_failed if not.  */
-
-#define TOUCH_ERROR(call) do{ perror_with_name ((call), file->name);    \
-                              return us_failed; }while(0)
-
-static enum update_status
-touch_file (struct file *file)
-{
-  if (!silent_flag)
-    OS (message, 0, "touch %s", file->name);
-
-  /* Print-only (-n) takes precedence over touch (-t).  */
-  if (just_print_flag)
-    return us_success;
-
-#ifndef NO_ARCHIVES
-  if (ar_name (file->name))
-    return ar_touch (file->name) ? us_failed : us_success;
-  else
-#endif
-    {
-      int fd;
-
-      EINTRLOOP (fd, open (file->name, O_RDWR | O_CREAT, 0666));
-      if (fd < 0)
-        TOUCH_ERROR ("touch: open: ");
-      else
-        {
-          struct stat statbuf;
-          char buf = 'x';
-          int e;
-
-          EINTRLOOP (e, fstat (fd, &statbuf));
-          if (e < 0)
-            TOUCH_ERROR ("touch: fstat: ");
-          /* Rewrite character 0 same as it already is.  */
-          EINTRLOOP (e, read (fd, &buf, 1));
-          if (e < 0)
-            TOUCH_ERROR ("touch: read: ");
-          {
-            off_t o;
-            EINTRLOOP (o, lseek (fd, 0L, 0));
-            if (o < 0L)
-              TOUCH_ERROR ("touch: lseek: ");
-          }
-          EINTRLOOP (e, write (fd, &buf, 1));
-          if (e < 0)
-            TOUCH_ERROR ("touch: write: ");
-
-          /* If file length was 0, we just changed it, so change it back.  */
-          if (statbuf.st_size == 0)
-            {
-              (void) close (fd);
-              EINTRLOOP (fd, open (file->name, O_RDWR | O_TRUNC, 0666));
-              if (fd < 0)
-                TOUCH_ERROR ("touch: open: ");
-            }
-          (void) close (fd);
-        }
-    }
-
-  return us_success;
-}
-
-/* Having checked and updated the dependencies of FILE,
-   do whatever is appropriate to remake FILE itself.
-   Return the status from executing FILE's commands.  */
-
-static void
-remake_file (struct file *file)
-{
-  if (file->cmds == 0)
-    {
-      if (file->phony)
-        /* Phony target.  Pretend it succeeded.  */
-        file->update_status = us_success;
-      else if (file->is_target)
-        /* This is a nonexistent target file we cannot make.
-           Pretend it was successfully remade.  */
-        file->update_status = us_success;
-      else
-        {
-          /* This is a dependency file we cannot remake.  Fail.  */
-          if (!rebuilding_makefiles || !file->dontcare)
-            complain (file);
-          file->update_status = us_failed;
-        }
-    }
-  else
-    {
-      chop_commands (file->cmds);
-
-      /* The normal case: start some commands.  */
-      if (!touch_flag || file->cmds->any_recurse)
-        {
-          execute_file_commands (file);
-          return;
-        }
-
-      /* This tells notice_finished_file it is ok to touch the file.  */
-      file->update_status = us_success;
-    }
-
-  /* This does the touching under -t.  */
-  notice_finished_file (file);
-}
-
-/* Return the mtime of a file, given a 'struct file'.
-   Caches the time in the struct file to avoid excess stat calls.
-
-   If the file is not found, and SEARCH is nonzero, VPATH searching and
-   replacement is done.  If that fails, a library (-lLIBNAME) is tried and
-   the library's actual name (/lib/libLIBNAME.a, etc.) is substituted into
-   FILE.  */
-
-FILE_TIMESTAMP
-f_mtime (struct file *file, int search)
-{
-  FILE_TIMESTAMP mtime;
-  int propagate_timestamp;
-
-  /* File's mtime is not known; must get it from the system.  */
-
-#ifndef NO_ARCHIVES
-  if (ar_name (file->name))
-    {
-      /* This file is an archive-member reference.  */
-
-      char *arname, *memname;
-      struct file *arfile;
-      time_t member_date;
-
-      /* Find the archive's name.  */
-      ar_parse_name (file->name, &arname, &memname);
-
-      /* Find the modification time of the archive itself.
-         Also allow for its name to be changed via VPATH search.  */
-      arfile = lookup_file (arname);
-      if (arfile == 0)
-        arfile = enter_file (strcache_add (arname));
-      mtime = f_mtime (arfile, search);
-      check_renamed (arfile);
-      if (search && strcmp (arfile->hname, arname))
-        {
-          /* The archive's name has changed.
-             Change the archive-member reference accordingly.  */
-
-          char *name;
-          unsigned int arlen, memlen;
-
-          arlen = strlen (arfile->hname);
-          memlen = strlen (memname);
-
-          name = alloca (arlen + 1 + memlen + 2);
-          memcpy (name, arfile->hname, arlen);
-          name[arlen] = '(';
-          memcpy (name + arlen + 1, memname, memlen);
-          name[arlen + 1 + memlen] = ')';
-          name[arlen + 1 + memlen + 1] = '\0';
-
-          /* If the archive was found with GPATH, make the change permanent;
-             otherwise defer it until later.  */
-          if (arfile->name == arfile->hname)
-            rename_file (file, strcache_add (name));
-          else
-            rehash_file (file, strcache_add (name));
-          check_renamed (file);
-        }
-
-      free (arname);
-
-      file->low_resolution_time = 1;
-
-      if (mtime == NONEXISTENT_MTIME)
-        /* The archive doesn't exist, so its members don't exist either.  */
-        return NONEXISTENT_MTIME;
-
-      member_date = ar_member_date (file->hname);
-      mtime = (member_date == (time_t) -1
-               ? NONEXISTENT_MTIME
-               : file_timestamp_cons (file->hname, member_date, 0));
-    }
-  else
-#endif
-    {
-      mtime = name_mtime (file->name);
-
-      if (mtime == NONEXISTENT_MTIME && search && !file->ignore_vpath)
-        {
-          /* If name_mtime failed, search VPATH.  */
-          const char *name = vpath_search (file->name, &mtime, NULL, NULL);
-          if (name
-              /* Last resort, is it a library (-lxxx)?  */
-              || (file->name[0] == '-' && file->name[1] == 'l'
-                  && (name = library_search (file->name, &mtime)) != 0))
-            {
-              int name_len;
-
-              if (mtime != UNKNOWN_MTIME)
-                /* vpath_search and library_search store UNKNOWN_MTIME
-                   if they didn't need to do a stat call for their work.  */
-                file->last_mtime = mtime;
-
-              /* If we found it in VPATH, see if it's in GPATH too; if so,
-                 change the name right now; if not, defer until after the
-                 dependencies are updated. */
-#ifndef VMS
-              name_len = strlen (name) - strlen (file->name) - 1;
-#else
-              name_len = strlen (name) - strlen (file->name);
-              if (name[name_len - 1] == '/')
-                  name_len--;
-#endif
-              if (gpath_search (name, name_len))
-                {
-                  rename_file (file, name);
-                  check_renamed (file);
-                  return file_mtime (file);
-                }
-
-              rehash_file (file, name);
-              check_renamed (file);
-              /* If the result of a vpath search is -o or -W, preserve it.
-                 Otherwise, find the mtime of the resulting file.  */
-              if (mtime != OLD_MTIME && mtime != NEW_MTIME)
-                mtime = name_mtime (name);
-            }
-        }
-    }
-
-  /* Files can have bogus timestamps that nothing newly made will be
-     "newer" than.  Updating their dependents could just result in loops.
-     So notify the user of the anomaly with a warning.
-
-     We only need to do this once, for now. */
-
-  if (!clock_skew_detected
-      && mtime != NONEXISTENT_MTIME && mtime != NEW_MTIME
-      && !file->updated)
-    {
-      static FILE_TIMESTAMP adjusted_now;
-
-      FILE_TIMESTAMP adjusted_mtime = mtime;
-
-#if defined(WINDOWS32) || defined(__MSDOS__)
-      /* Experimentation has shown that FAT filesystems can set file times
-         up to 3 seconds into the future!  Play it safe.  */
-
-#define FAT_ADJ_OFFSET  (FILE_TIMESTAMP) 3
-
-      FILE_TIMESTAMP adjustment = FAT_ADJ_OFFSET << FILE_TIMESTAMP_LO_BITS;
-      if (ORDINARY_MTIME_MIN + adjustment <= adjusted_mtime)
-        adjusted_mtime -= adjustment;
-#elif defined(__EMX__)
-      /* FAT filesystems round time to the nearest even second!
-         Allow for any file (NTFS or FAT) to perhaps suffer from this
-         brain damage.  */
-      FILE_TIMESTAMP adjustment = (((FILE_TIMESTAMP_S (adjusted_mtime) & 1) == 0
-                     && FILE_TIMESTAMP_NS (adjusted_mtime) == 0)
-                    ? (FILE_TIMESTAMP) 1 << FILE_TIMESTAMP_LO_BITS
-                    : 0);
-#endif
-
-      /* If the file's time appears to be in the future, update our
-         concept of the present and try once more.  */
-      if (adjusted_now < adjusted_mtime)
-        {
-          int resolution;
-          FILE_TIMESTAMP now = file_timestamp_now (&resolution);
-          adjusted_now = now + (resolution - 1);
-          if (adjusted_now < adjusted_mtime)
-            {
-              double from_now =
-                (FILE_TIMESTAMP_S (mtime) - FILE_TIMESTAMP_S (now)
-                 + ((FILE_TIMESTAMP_NS (mtime) - FILE_TIMESTAMP_NS (now))
-                    / 1e9));
-              char from_now_string[100];
-
-              if (from_now >= 99 && from_now <= ULONG_MAX)
-                sprintf (from_now_string, "%lu", (unsigned long) from_now);
-              else
-                sprintf (from_now_string, "%.2g", from_now);
-              OSS (error, NILF,
-                   _("Warning: File '%s' has modification time %s s in the future"),
-                   file->name, from_now_string);
-              clock_skew_detected = 1;
-            }
-        }
-    }
-
-  /* Store the mtime into all the entries for this file for which it is safe
-     to do so: avoid propagating timestamps to double-colon rules that haven't
-     been examined so they're run or not based on the pre-update timestamp.  */
-  if (file->double_colon)
-    file = file->double_colon;
-
-  propagate_timestamp = file->updated;
-  do
-    {
-      /* If this file is not implicit but it is intermediate then it was
-         made so by the .INTERMEDIATE target.  If this file has never
-         been built by us but was found now, it existed before make
-         started.  So, turn off the intermediate bit so make doesn't
-         delete it, since it didn't create it.  */
-      if (mtime != NONEXISTENT_MTIME && file->command_state == cs_not_started
-          && !file->tried_implicit && file->intermediate)
-        file->intermediate = 0;
-
-      if (file->updated == propagate_timestamp)
-        file->last_mtime = mtime;
-      file = file->prev;
-    }
-  while (file != 0);
-
-  return mtime;
-}
-
-
-/* Return the mtime of the file or archive-member reference NAME.  */
-
-/* First, we check with stat().  If the file does not exist, then we return
-   NONEXISTENT_MTIME.  If it does, and the symlink check flag is set, then
-   examine each indirection of the symlink and find the newest mtime.
-   This causes one duplicate stat() when -L is being used, but the code is
-   much cleaner.  */
-
-static FILE_TIMESTAMP
-name_mtime (const char *name)
-{
-  FILE_TIMESTAMP mtime;
-  struct stat st;
-  int e;
-
-#if defined(WINDOWS32)
-  {
-    char tem[MAXPATHLEN], *tstart, *tend;
-    const char *p = name + strlen (name);
-
-    /* Remove any trailing slashes and "."/"..".  MS-Windows stat
-       fails on valid directories if NAME ends in a slash, and we need
-       to emulate the Posix behavior where stat on "foo/" or "foo/."
-       succeeds ONLY if "foo" is a directory. */
-    if (p > name)
-      {
-	memcpy (tem, name, p - name + 1);
-	tstart = tem;
-	if (tstart[1] == ':')
-	  tstart += 2;
-	tend = tem + (p - name - 1);
-	if (*tend == '.' && tend > tstart)
-	  tend--;
-	if (*tend == '.' && tend > tstart)
-	  tend--;
-	for ( ; tend > tstart && (*tend == '/' || *tend == '\\'); tend--)
-	  *tend = '\0';
-      }
-    else
-      {
-	tem[0] = '\0';
-	tend = &tem[0];
-      }
-
-    e = stat (tem, &st);
-    if (e == 0 && !_S_ISDIR (st.st_mode) && tend < tem + (p - name - 1))
-      {
-	errno = ENOTDIR;
-	e = -1;
-      }
-  }
-#else
-  EINTRLOOP (e, stat (name, &st));
-#endif
-  if (e == 0)
-    mtime = FILE_TIMESTAMP_STAT_MODTIME (name, st);
-  else if (errno == ENOENT || errno == ENOTDIR)
-    mtime = NONEXISTENT_MTIME;
-  else
-    {
-      perror_with_name ("stat: ", name);
-      return NONEXISTENT_MTIME;
-    }
-
-  /* If we get here we either found it, or it doesn't exist.
-     If it doesn't exist see if we can use a symlink mtime instead.  */
-
-#ifdef MAKE_SYMLINKS
-#ifndef S_ISLNK
-# define S_ISLNK(_m)     (((_m)&S_IFMT)==S_IFLNK)
-#endif
-  if (check_symlink_flag && strlen (name) <= GET_PATH_MAX)
-    {
-      PATH_VAR (lpath);
-
-      /* Check each symbolic link segment (if any).  Find the latest mtime
-         amongst all of them (and the target file of course).
-         Note that we have already successfully dereferenced all the links
-         above.  So, if we run into any error trying to lstat(), or
-         readlink(), or whatever, something bizarre-o happened.  Just give up
-         and use whatever mtime we've already computed at that point.  */
-      strcpy (lpath, name);
-      while (1)
-        {
-          FILE_TIMESTAMP ltime;
-          PATH_VAR (lbuf);
-          long llen;
-          char *p;
-
-          EINTRLOOP (e, lstat (lpath, &st));
-          if (e)
-            {
-              /* Just take what we have so far.  */
-              if (errno != ENOENT && errno != ENOTDIR)
-                perror_with_name ("lstat: ", lpath);
-              break;
-            }
-
-          /* If this is not a symlink, we're done (we started with the real
-             file's mtime so we don't need to test it again).  */
-          if (!S_ISLNK (st.st_mode))
-            break;
-
-          /* If this mtime is newer than what we had, keep the new one.  */
-          ltime = FILE_TIMESTAMP_STAT_MODTIME (lpath, st);
-          if (ltime > mtime)
-            mtime = ltime;
-
-          /* Set up to check the file pointed to by this link.  */
-          EINTRLOOP (llen, readlink (lpath, lbuf, GET_PATH_MAX));
-          if (llen < 0)
-            {
-              /* Eh?  Just take what we have.  */
-              perror_with_name ("readlink: ", lpath);
-              break;
-            }
-          lbuf[llen] = '\0';
-
-          /* If the target is fully-qualified or the source is just a
-             filename, then the new path is the target.  Otherwise it's the
-             source directory plus the target.  */
-          if (lbuf[0] == '/' || (p = strrchr (lpath, '/')) == NULL)
-            strcpy (lpath, lbuf);
-          else if ((p - lpath) + llen + 2 > GET_PATH_MAX)
-            /* Eh?  Path too long!  Again, just go with what we have.  */
-            break;
-          else
-            /* Create the next step in the symlink chain.  */
-            strcpy (p+1, lbuf);
-        }
-    }
-#endif
-
-  return mtime;
-}
-
-
-/* Search for a library file specified as -lLIBNAME, searching for a
-   suitable library file in the system library directories and the VPATH
-   directories.  */
-
-static const char *
-library_search (const char *lib, FILE_TIMESTAMP *mtime_ptr)
-{
-  static const char *dirs[] =
-    {
-#ifndef _AMIGA
-      "/lib",
-      "/usr/lib",
-#endif
-#if defined(WINDOWS32) && !defined(LIBDIR)
-/*
- * This is completely up to the user at product install time. Just define
- * a placeholder.
- */
-#define LIBDIR "."
-#endif
-      LIBDIR,                   /* Defined by configuration.  */
-      0
-    };
-
-  const char *file = 0;
-  char *libpatterns;
-  FILE_TIMESTAMP mtime;
-
-  /* Loop variables for the libpatterns value.  */
-  char *p;
-  const char *p2;
-  unsigned int len;
-  unsigned int liblen;
-
-  /* Information about the earliest (in the vpath sequence) match.  */
-  unsigned int best_vpath = 0, best_path = 0;
-
-  const char **dp;
-
-  libpatterns = xstrdup (variable_expand ("$(.LIBPATTERNS)"));
-
-  /* Skip the '-l'.  */
-  lib += 2;
-  liblen = strlen (lib);
-
-  /* Loop through all the patterns in .LIBPATTERNS, and search on each one.
-     To implement the linker-compatible behavior we have to search through
-     all entries in .LIBPATTERNS and choose the "earliest" one.  */
-  p2 = libpatterns;
-  while ((p = find_next_token (&p2, &len)) != 0)
-    {
-      static char *buf = NULL;
-      static unsigned int buflen = 0;
-      static int libdir_maxlen = -1;
-      static unsigned int std_dirs = 0;
-      char *libbuf = variable_expand ("");
-
-      /* Expand the pattern using LIB as a replacement.  */
-      {
-        char c = p[len];
-        char *p3, *p4;
-
-        p[len] = '\0';
-        p3 = find_percent (p);
-        if (!p3)
-          {
-            /* Give a warning if there is no pattern.  */
-            OS (error, NILF,
-                _(".LIBPATTERNS element '%s' is not a pattern"), p);
-            p[len] = c;
-            continue;
-          }
-        p4 = variable_buffer_output (libbuf, p, p3-p);
-        p4 = variable_buffer_output (p4, lib, liblen);
-        p4 = variable_buffer_output (p4, p3+1, len - (p3-p));
-        p[len] = c;
-      }
-
-      /* Look first for 'libNAME.a' in the current directory.  */
-      mtime = name_mtime (libbuf);
-      if (mtime != NONEXISTENT_MTIME)
-        {
-          if (mtime_ptr != 0)
-            *mtime_ptr = mtime;
-          file = strcache_add (libbuf);
-          /* This by definition will have the best index, so stop now.  */
-          break;
-        }
-
-      /* Now try VPATH search on that.  */
-
-      {
-        unsigned int vpath_index, path_index;
-        const char* f = vpath_search (libbuf, mtime_ptr ? &mtime : NULL,
-                                      &vpath_index, &path_index);
-        if (f)
-          {
-            /* If we have a better match, record it.  */
-            if (file == 0 ||
-                vpath_index < best_vpath ||
-                (vpath_index == best_vpath && path_index < best_path))
-              {
-                file = f;
-                best_vpath = vpath_index;
-                best_path = path_index;
-
-                if (mtime_ptr != 0)
-                  *mtime_ptr = mtime;
-              }
-          }
-      }
-
-      /* Now try the standard set of directories.  */
-
-      if (!buflen)
-        {
-          for (dp = dirs; *dp != 0; ++dp)
-            {
-              int l = strlen (*dp);
-              if (l > libdir_maxlen)
-                libdir_maxlen = l;
-              std_dirs++;
-            }
-          buflen = strlen (libbuf);
-          buf = xmalloc (libdir_maxlen + buflen + 2);
-        }
-      else if (buflen < strlen (libbuf))
-        {
-          buflen = strlen (libbuf);
-          buf = xrealloc (buf, libdir_maxlen + buflen + 2);
-        }
-
-      {
-        /* Use the last std_dirs index for standard directories. This
-           was it will always be greater than the VPATH index.  */
-        unsigned int vpath_index = ~((unsigned int)0) - std_dirs;
-
-        for (dp = dirs; *dp != 0; ++dp)
-          {
-            sprintf (buf, "%s/%s", *dp, libbuf);
-            mtime = name_mtime (buf);
-            if (mtime != NONEXISTENT_MTIME)
-              {
-                if (file == 0 || vpath_index < best_vpath)
-                  {
-                    file = strcache_add (buf);
-                    best_vpath = vpath_index;
-
-                    if (mtime_ptr != 0)
-                      *mtime_ptr = mtime;
-                  }
-              }
-
-            vpath_index++;
-          }
-      }
-
-    }
-
-  free (libpatterns);
-  return file;
-}
diff --git a/remote-cstms.c b/remote-cstms.c
deleted file mode 100644
index dea0276..0000000
--- a/remote-cstms.c
+++ /dev/null
@@ -1,300 +0,0 @@
-/* GNU Make remote job exportation interface to the Customs daemon.
-   THIS CODE IS NOT SUPPORTED BY THE GNU PROJECT.
-   Please do not send bug reports or questions about it to
-   the Make maintainers.
-
-Copyright (C) 1988-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-#include "filedef.h"
-#include "commands.h"
-#include "job.h"
-#include "debug.h"
-
-#include <sys/time.h>
-#include <netdb.h>
-
-#include "customs.h"
-
-char *remote_description = "Customs";
-
-/* File name of the Customs 'export' client command.
-   A full path name can be used to avoid some path-searching overhead.  */
-#define EXPORT_COMMAND  "/usr/local/bin/export"
-
-/* ExportPermit gotten by start_remote_job_p, and used by start_remote_job.  */
-static ExportPermit permit;
-
-/* Normalized path name of the current directory.  */
-static char *normalized_cwd;
-
-/* Call once at startup even if no commands are run.  */
-
-void
-remote_setup (void)
-{
-}
-
-/* Called before exit.  */
-
-void
-remote_cleanup (void)
-{
-}
-
-/* Return nonzero if the next job should be done remotely.  */
-
-int
-start_remote_job_p (int first_p)
-{
-  static int inited = 0;
-  int status;
-  int njobs;
-
-  if (!inited)
-    {
-      /* Allow the user to turn off job exportation (useful while he is
-         debugging Customs, for example).  */
-      if (getenv ("GNU_MAKE_NO_CUSTOMS") != 0)
-        {
-          inited = -1;
-          return 0;
-        }
-
-      /* For secure Customs, make is installed setuid root and
-         Customs requires a privileged source port be used.  */
-      make_access ();
-
-      if (ISDB (DB_JOBS))
-        Rpc_Debug (1);
-
-      /* Ping the daemon once to see if it is there.  */
-      inited = Customs_Ping () == RPC_SUCCESS ? 1 : -1;
-
-      /* Return to normal user access.  */
-      user_access ();
-
-      if (starting_directory == 0)
-        /* main couldn't figure it out.  */
-        inited = -1;
-      else
-        {
-          /* Normalize the current directory path name to something
-             that should work on all machines exported to.  */
-
-          normalized_cwd = xmalloc (GET_PATH_MAX);
-          strcpy (normalized_cwd, starting_directory);
-          if (Customs_NormPath (normalized_cwd, GET_PATH_MAX) < 0)
-            /* Path normalization failure means using Customs
-               won't work, but it's not really an error.  */
-            inited = -1;
-        }
-    }
-
-  if (inited < 0)
-    return 0;
-
-  njobs = job_slots_used;
-  if (!first_p)
-    njobs -= 1;         /* correction for being called from reap_children() */
-
-  /* the first job should run locally, or, if the -l flag is given, we use
-     that as clue as to how many local jobs should be scheduled locally */
-  if (max_load_average < 0 && njobs == 0 || njobs < max_load_average)
-     return 0;
-
-  status = Customs_Host (EXPORT_SAME, &permit);
-  if (status != RPC_SUCCESS)
-    {
-      DB (DB_JOBS, (_("Customs won't export: %s\n"),
-                    Rpc_ErrorMessage (status)));
-      return 0;
-    }
-
-  return !CUSTOMS_FAIL (&permit.addr);
-}
-
-/* Start a remote job running the command in ARGV, with environment from
-   ENVP.  It gets standard input from STDIN_FD.  On failure, return
-   nonzero.  On success, return zero, and set *USED_STDIN to nonzero if it
-   will actually use STDIN_FD, zero if not, set *ID_PTR to a unique
-   identification, and set *IS_REMOTE to nonzero if the job is remote, zero
-   if it is local (meaning *ID_PTR is a process ID).  */
-
-int
-start_remote_job (char **argv, char **envp, int stdin_fd,
-                  int *is_remote, int *id_ptr, int *used_stdin)
-{
-  char waybill[MAX_DATA_SIZE], msg[128];
-  struct hostent *host;
-  struct timeval timeout;
-  struct sockaddr_in sin;
-  int len;
-  int retsock, retport, sock;
-  Rpc_Stat status;
-  int pid;
-
-  /* Create the return socket.  */
-  retsock = Rpc_UdpCreate (True, 0);
-  if (retsock < 0)
-    {
-      O (error, NILF, "exporting: Couldn't create return socket.");
-      return 1;
-    }
-
-  /* Get the return socket's port number.  */
-  len = sizeof (sin);
-  if (getsockname (retsock, (struct sockaddr *) &sin, &len) < 0)
-    {
-      (void) close (retsock);
-      perror_with_name ("exporting: ", "getsockname");
-      return 1;
-    }
-  retport = sin.sin_port;
-
-  /* Create the TCP socket for talking to the remote child.  */
-  sock = Rpc_TcpCreate (False, 0);
-
-  /* Create a WayBill to give to the server.  */
-  len = Customs_MakeWayBill (&permit, normalized_cwd, argv[0], argv,
-                             envp, retport, waybill);
-
-  /* Modify the waybill as if the remote child had done 'child_access ()'.  */
-  {
-    WayBill *wb = (WayBill *) waybill;
-    wb->ruid = wb->euid;
-    wb->rgid = wb->egid;
-  }
-
-  /* Send the request to the server, timing out in 20 seconds.  */
-  timeout.tv_usec = 0;
-  timeout.tv_sec = 20;
-  sin.sin_family = AF_INET;
-  sin.sin_port = htons (Customs_Port ());
-  sin.sin_addr = permit.addr;
-  status = Rpc_Call (sock, &sin, (Rpc_Proc) CUSTOMS_IMPORT,
-                     len, (Rpc_Opaque) waybill,
-                     sizeof (msg), (Rpc_Opaque) msg,
-                     1, &timeout);
-
-  host = gethostbyaddr ((char *)&permit.addr, sizeof(permit.addr), AF_INET);
-
-  {
-    const char *hnm = host ? host->h_name : inet_ntoa (permit.addr);
-    size_t hlen = strlen (hnm);
-
-    if (status != RPC_SUCCESS)
-      {
-        const char *err = Rpc_ErrorMessage (status);
-        (void) close (retsock);
-        (void) close (sock);
-        error (NILF, hlen + strlen (err),
-               "exporting to %s: %s", hnm, err);
-        return 1;
-      }
-    else if (msg[0] != 'O' || msg[1] != 'k' || msg[2] != '\0')
-      {
-        (void) close (retsock);
-        (void) close (sock);
-        error (NILF, hlen + strlen (msg), "exporting to %s: %s", hnm, msg);
-        return 1;
-      }
-    else
-      {
-        error (NILF, hlen + INTSTR_LENGTH,
-               "*** exported to %s (id %u)", hnm, permit.id);
-      }
-
-    fflush (stdout);
-    fflush (stderr);
-  }
-
-  pid = vfork ();
-  if (pid < 0)
-    {
-      /* The fork failed!  */
-      perror_with_name ("fork", "");
-      return 1;
-    }
-  else if (pid == 0)
-    {
-      /* Child side.  Run 'export' to handle the connection.  */
-      static char sock_buf[20], retsock_buf[20], id_buf[20];
-      static char *new_argv[6] =
-        { EXPORT_COMMAND, "-id", sock_buf, retsock_buf, id_buf, 0 };
-
-      /* Set up the arguments.  */
-      (void) sprintf (sock_buf, "%d", sock);
-      (void) sprintf (retsock_buf, "%d", retsock);
-      (void) sprintf (id_buf, "%x", permit.id);
-
-      /* Get the right stdin.  */
-      if (stdin_fd != 0)
-        (void) dup2 (stdin_fd, 0);
-
-      /* Unblock signals in the child.  */
-      unblock_all_sigs ();
-
-      /* Run the command.  */
-      exec_command (new_argv, envp);
-    }
-
-  /* Parent side.  Return the 'export' process's ID.  */
-  (void) close (retsock);
-  (void) close (sock);
-  *is_remote = 0;
-  *id_ptr = pid;
-  *used_stdin = 1;
-  return 0;
-}
-
-/* Get the status of a dead remote child.  Block waiting for one to die
-   if BLOCK is nonzero.  Set *EXIT_CODE_PTR to the exit status, *SIGNAL_PTR
-   to the termination signal or zero if it exited normally, and *COREDUMP_PTR
-   nonzero if it dumped core.  Return the ID of the child that died,
-   0 if we would have to block and !BLOCK, or < 0 if there were none.  */
-
-int
-remote_status (int *exit_code_ptr, int *signal_ptr, int *coredump_ptr,
-               int block)
-{
-  return -1;
-}
-
-/* Block asynchronous notification of remote child death.
-   If this notification is done by raising the child termination
-   signal, do not block that signal.  */
-void
-block_remote_children (void)
-{
-  return;
-}
-
-/* Restore asynchronous notification of remote child death.
-   If this is done by raising the child termination signal,
-   do not unblock that signal.  */
-void
-unblock_remote_children (void)
-{
-  return;
-}
-
-/* Send signal SIG to child ID.  Return 0 if successful, -1 if not.  */
-int
-remote_kill (int id, int sig)
-{
-  return -1;
-}
diff --git a/remote-stub.c b/remote-stub.c
deleted file mode 100644
index 02c7a88..0000000
--- a/remote-stub.c
+++ /dev/null
@@ -1,99 +0,0 @@
-/* Template for the remote job exportation interface to GNU Make.
-Copyright (C) 1988-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-#include "filedef.h"
-#include "job.h"
-#include "commands.h"
-
-
-char *remote_description = 0;
-
-/* Call once at startup even if no commands are run.  */
-
-void
-remote_setup (void)
-{
-}
-
-/* Called before exit.  */
-
-void
-remote_cleanup (void)
-{
-}
-
-/* Return nonzero if the next job should be done remotely.  */
-
-int
-start_remote_job_p (int first_p UNUSED)
-{
-  return 0;
-}
-
-/* Start a remote job running the command in ARGV,
-   with environment from ENVP.  It gets standard input from STDIN_FD.  On
-   failure, return nonzero.  On success, return zero, and set *USED_STDIN
-   to nonzero if it will actually use STDIN_FD, zero if not, set *ID_PTR to
-   a unique identification, and set *IS_REMOTE to zero if the job is local,
-   nonzero if it is remote (meaning *ID_PTR is a process ID).  */
-
-int
-start_remote_job (char **argv UNUSED, char **envp UNUSED, int stdin_fd UNUSED,
-                  int *is_remote UNUSED, int *id_ptr UNUSED,
-                  int *used_stdin UNUSED)
-{
-  return -1;
-}
-
-/* Get the status of a dead remote child.  Block waiting for one to die
-   if BLOCK is nonzero.  Set *EXIT_CODE_PTR to the exit status, *SIGNAL_PTR
-   to the termination signal or zero if it exited normally, and *COREDUMP_PTR
-   nonzero if it dumped core.  Return the ID of the child that died,
-   0 if we would have to block and !BLOCK, or < 0 if there were none.  */
-
-int
-remote_status (int *exit_code_ptr UNUSED, int *signal_ptr UNUSED,
-               int *coredump_ptr UNUSED, int block UNUSED)
-{
-  errno = ECHILD;
-  return -1;
-}
-
-/* Block asynchronous notification of remote child death.
-   If this notification is done by raising the child termination
-   signal, do not block that signal.  */
-void
-block_remote_children (void)
-{
-  return;
-}
-
-/* Restore asynchronous notification of remote child death.
-   If this is done by raising the child termination signal,
-   do not unblock that signal.  */
-void
-unblock_remote_children (void)
-{
-  return;
-}
-
-/* Send signal SIG to child ID.  Return 0 if successful, -1 if not.  */
-int
-remote_kill (int id UNUSED, int sig UNUSED)
-{
-  return -1;
-}
diff --git a/rule.c b/rule.c
deleted file mode 100644
index 1fe77e1..0000000
--- a/rule.c
+++ /dev/null
@@ -1,526 +0,0 @@
-/* Pattern and suffix rule internals for GNU Make.
-Copyright (C) 1988-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-
-#include <assert.h>
-
-#include "filedef.h"
-#include "dep.h"
-#include "job.h"
-#include "commands.h"
-#include "variable.h"
-#include "rule.h"
-
-static void freerule (struct rule *rule, struct rule *lastrule);
-
-/* Chain of all pattern rules.  */
-
-struct rule *pattern_rules;
-
-/* Pointer to last rule in the chain, so we can add onto the end.  */
-
-struct rule *last_pattern_rule;
-
-/* Number of rules in the chain.  */
-
-unsigned int num_pattern_rules;
-
-/* Maximum number of target patterns of any pattern rule.  */
-
-unsigned int max_pattern_targets;
-
-/* Maximum number of dependencies of any pattern rule.  */
-
-unsigned int max_pattern_deps;
-
-/* Maximum length of the name of a dependencies of any pattern rule.  */
-
-unsigned int max_pattern_dep_length;
-
-/* Pointer to structure for the file .SUFFIXES
-   whose dependencies are the suffixes to be searched.  */
-
-struct file *suffix_file;
-
-/* Maximum length of a suffix.  */
-
-unsigned int maxsuffix;
-
-/* Compute the maximum dependency length and maximum number of
-   dependencies of all implicit rules.  Also sets the subdir
-   flag for a rule when appropriate, possibly removing the rule
-   completely when appropriate.  */
-
-void
-count_implicit_rule_limits (void)
-{
-  char *name;
-  int namelen;
-  struct rule *rule;
-
-  num_pattern_rules = max_pattern_targets = max_pattern_deps = 0;
-  max_pattern_dep_length = 0;
-
-  name = 0;
-  namelen = 0;
-  rule = pattern_rules;
-  while (rule != 0)
-    {
-      unsigned int ndeps = 0;
-      struct dep *dep;
-      struct rule *next = rule->next;
-
-      ++num_pattern_rules;
-
-      if (rule->num > max_pattern_targets)
-        max_pattern_targets = rule->num;
-
-      for (dep = rule->deps; dep != 0; dep = dep->next)
-        {
-          const char *dname = dep_name (dep);
-          unsigned int len = strlen (dname);
-
-#ifdef VMS
-          const char *p = strrchr (dname, ']');
-          const char *p2;
-          if (p == 0)
-            p = strrchr (dname, ':');
-          p2 = p != 0 ? strchr (dname, '%') : 0;
-#else
-          const char *p = strrchr (dname, '/');
-          const char *p2 = p != 0 ? strchr (dname, '%') : 0;
-#endif
-          ndeps++;
-
-          if (len > max_pattern_dep_length)
-            max_pattern_dep_length = len;
-
-          if (p != 0 && p2 > p)
-            {
-              /* There is a slash before the % in the dep name.
-                 Extract the directory name.  */
-              if (p == dname)
-                ++p;
-              if (p - dname > namelen)
-                {
-                  namelen = p - dname;
-                  name = xrealloc (name, namelen + 1);
-                }
-              memcpy (name, dname, p - dname);
-              name[p - dname] = '\0';
-
-              /* In the deps of an implicit rule the 'changed' flag
-                 actually indicates that the dependency is in a
-                 nonexistent subdirectory.  */
-
-              dep->changed = !dir_file_exists_p (name, "");
-            }
-          else
-            /* This dependency does not reside in a subdirectory.  */
-            dep->changed = 0;
-        }
-
-      if (ndeps > max_pattern_deps)
-        max_pattern_deps = ndeps;
-
-      rule = next;
-    }
-
-  free (name);
-}
-
-/* Create a pattern rule from a suffix rule.
-   TARGET is the target suffix; SOURCE is the source suffix.
-   CMDS are the commands.
-   If TARGET is nil, it means the target pattern should be '(%.o)'.
-   If SOURCE is nil, it means there should be no deps.  */
-
-static void
-convert_suffix_rule (const char *target, const char *source,
-                     struct commands *cmds)
-{
-  const char **names, **percents;
-  struct dep *deps;
-
-  names = xmalloc (sizeof (const char *));
-  percents = xmalloc (sizeof (const char *));
-
-  if (target == 0)
-    {
-      /* Special case: TARGET being nil means we are defining a '.X.a' suffix
-         rule; the target pattern is always '(%.o)'.  */
-#ifdef VMS
-      *names = strcache_add_len ("(%.obj)", 7);
-#else
-      *names = strcache_add_len ("(%.o)", 5);
-#endif
-      *percents = *names + 1;
-    }
-  else
-    {
-      /* Construct the target name.  */
-      unsigned int len = strlen (target);
-      char *p = alloca (1 + len + 1);
-      p[0] = '%';
-      memcpy (p + 1, target, len + 1);
-      *names = strcache_add_len (p, len + 1);
-      *percents = *names;
-    }
-
-  if (source == 0)
-    deps = 0;
-  else
-    {
-      /* Construct the dependency name.  */
-      unsigned int len = strlen (source);
-      char *p = alloca (1 + len + 1);
-      p[0] = '%';
-      memcpy (p + 1, source, len + 1);
-      deps = alloc_dep ();
-      deps->name = strcache_add_len (p, len + 1);
-    }
-
-  create_pattern_rule (names, percents, 1, 0, deps, cmds, 0);
-}
-
-/* Convert old-style suffix rules to pattern rules.
-   All rules for the suffixes on the .SUFFIXES list are converted and added to
-   the chain of pattern rules.  */
-
-void
-convert_to_pattern (void)
-{
-  struct dep *d, *d2;
-  char *rulename;
-
-  /* We will compute every potential suffix rule (.x.y) from the list of
-     suffixes in the .SUFFIXES target's dependencies and see if it exists.
-     First find the longest of the suffixes.  */
-
-  maxsuffix = 0;
-  for (d = suffix_file->deps; d != 0; d = d->next)
-    {
-      unsigned int l = strlen (dep_name (d));
-      if (l > maxsuffix)
-        maxsuffix = l;
-    }
-
-  /* Space to construct the suffix rule target name.  */
-  rulename = alloca ((maxsuffix * 2) + 1);
-
-  for (d = suffix_file->deps; d != 0; d = d->next)
-    {
-      unsigned int slen;
-
-      /* Make a rule that is just the suffix, with no deps or commands.
-         This rule exists solely to disqualify match-anything rules.  */
-      convert_suffix_rule (dep_name (d), 0, 0);
-
-      if (d->file->cmds != 0)
-        /* Record a pattern for this suffix's null-suffix rule.  */
-        convert_suffix_rule ("", dep_name (d), d->file->cmds);
-
-      /* Add every other suffix to this one and see if it exists as a
-         two-suffix rule.  */
-      slen = strlen (dep_name (d));
-      memcpy (rulename, dep_name (d), slen);
-
-      for (d2 = suffix_file->deps; d2 != 0; d2 = d2->next)
-        {
-          struct file *f;
-          unsigned int s2len;
-
-          s2len = strlen (dep_name (d2));
-
-          /* Can't build something from itself.  */
-          if (slen == s2len && streq (dep_name (d), dep_name (d2)))
-            continue;
-
-          memcpy (rulename + slen, dep_name (d2), s2len + 1);
-          f = lookup_file (rulename);
-          if (f == 0 || f->cmds == 0)
-            continue;
-
-          if (s2len == 2 && rulename[slen] == '.' && rulename[slen + 1] == 'a')
-            /* A suffix rule '.X.a:' generates the pattern rule '(%.o): %.X'.
-               It also generates a normal '%.a: %.X' rule below.  */
-            convert_suffix_rule (NULL, /* Indicates '(%.o)'.  */
-                                 dep_name (d),
-                                 f->cmds);
-
-          /* The suffix rule '.X.Y:' is converted
-             to the pattern rule '%.Y: %.X'.  */
-          convert_suffix_rule (dep_name (d2), dep_name (d), f->cmds);
-        }
-    }
-}
-
-
-/* Install the pattern rule RULE (whose fields have been filled in) at the end
-   of the list (so that any rules previously defined will take precedence).
-   If this rule duplicates a previous one (identical target and dependencies),
-   the old one is replaced if OVERRIDE is nonzero, otherwise this new one is
-   thrown out.  When an old rule is replaced, the new one is put at the end of
-   the list.  Return nonzero if RULE is used; zero if not.  */
-
-static int
-new_pattern_rule (struct rule *rule, int override)
-{
-  struct rule *r, *lastrule;
-  unsigned int i, j;
-
-  rule->in_use = 0;
-  rule->terminal = 0;
-
-  rule->next = 0;
-
-  /* Search for an identical rule.  */
-  lastrule = 0;
-  for (r = pattern_rules; r != 0; lastrule = r, r = r->next)
-    for (i = 0; i < rule->num; ++i)
-      {
-        for (j = 0; j < r->num; ++j)
-          if (!streq (rule->targets[i], r->targets[j]))
-            break;
-        /* If all the targets matched...  */
-        if (j == r->num)
-          {
-            struct dep *d, *d2;
-            for (d = rule->deps, d2 = r->deps;
-                 d != 0 && d2 != 0; d = d->next, d2 = d2->next)
-              if (!streq (dep_name (d), dep_name (d2)))
-                break;
-            if (d == 0 && d2 == 0)
-              {
-                /* All the dependencies matched.  */
-                if (override)
-                  {
-                    /* Remove the old rule.  */
-                    freerule (r, lastrule);
-                    /* Install the new one.  */
-                    if (pattern_rules == 0)
-                      pattern_rules = rule;
-                    else
-                      last_pattern_rule->next = rule;
-                    last_pattern_rule = rule;
-
-                    /* We got one.  Stop looking.  */
-                    goto matched;
-                  }
-                else
-                  {
-                    /* The old rule stays intact.  Destroy the new one.  */
-                    freerule (rule, (struct rule *) 0);
-                    return 0;
-                  }
-              }
-          }
-      }
-
- matched:;
-
-  if (r == 0)
-    {
-      /* There was no rule to replace.  */
-      if (pattern_rules == 0)
-        pattern_rules = rule;
-      else
-        last_pattern_rule->next = rule;
-      last_pattern_rule = rule;
-    }
-
-  return 1;
-}
-
-
-/* Install an implicit pattern rule based on the three text strings
-   in the structure P points to.  These strings come from one of
-   the arrays of default implicit pattern rules.
-   TERMINAL specifies what the 'terminal' field of the rule should be.  */
-
-void
-install_pattern_rule (struct pspec *p, int terminal)
-{
-  struct rule *r;
-  const char *ptr;
-
-  r = xmalloc (sizeof (struct rule));
-
-  r->num = 1;
-  r->targets = xmalloc (sizeof (const char *));
-  r->suffixes = xmalloc (sizeof (const char *));
-  r->lens = xmalloc (sizeof (unsigned int));
-
-  r->lens[0] = strlen (p->target);
-  r->targets[0] = p->target;
-  r->suffixes[0] = find_percent_cached (&r->targets[0]);
-  assert (r->suffixes[0] != NULL);
-  ++r->suffixes[0];
-
-  ptr = p->dep;
-  r->deps = PARSE_SIMPLE_SEQ ((char **)&ptr, struct dep);
-
-  if (new_pattern_rule (r, 0))
-    {
-      r->terminal = terminal;
-      r->cmds = xmalloc (sizeof (struct commands));
-      r->cmds->fileinfo.filenm = 0;
-      r->cmds->fileinfo.lineno = 0;
-      r->cmds->fileinfo.offset = 0;
-      /* These will all be string literals, but we malloc space for them
-         anyway because somebody might want to free them later.  */
-      r->cmds->commands = xstrdup (p->commands);
-      r->cmds->command_lines = 0;
-      r->cmds->recipe_prefix = RECIPEPREFIX_DEFAULT;
-    }
-}
-
-
-/* Free all the storage used in RULE and take it out of the
-   pattern_rules chain.  LASTRULE is the rule whose next pointer
-   points to RULE.  */
-
-static void
-freerule (struct rule *rule, struct rule *lastrule)
-{
-  struct rule *next = rule->next;
-
-  free_dep_chain (rule->deps);
-
-  /* MSVC erroneously warns without a cast here.  */
-  free ((void *)rule->targets);
-  free ((void *)rule->suffixes);
-  free (rule->lens);
-
-  /* We can't free the storage for the commands because there
-     are ways that they could be in more than one place:
-       * If the commands came from a suffix rule, they could also be in
-       the 'struct file's for other suffix rules or plain targets given
-       on the same makefile line.
-       * If two suffixes that together make a two-suffix rule were each
-       given twice in the .SUFFIXES list, and in the proper order, two
-       identical pattern rules would be created and the second one would
-       be discarded here, but both would contain the same 'struct commands'
-       pointer from the 'struct file' for the suffix rule.  */
-
-  free (rule);
-
-  if (pattern_rules == rule)
-    if (lastrule != 0)
-      abort ();
-    else
-      pattern_rules = next;
-  else if (lastrule != 0)
-    lastrule->next = next;
-  if (last_pattern_rule == rule)
-    last_pattern_rule = lastrule;
-}
-
-/* Create a new pattern rule with the targets in the nil-terminated array
-   TARGETS.  TARGET_PERCENTS is an array of pointers to the % in each element
-   of TARGETS.  N is the number of items in the array (not counting the nil
-   element).  The new rule has dependencies DEPS and commands from COMMANDS.
-   It is a terminal rule if TERMINAL is nonzero.  This rule overrides
-   identical rules with different commands if OVERRIDE is nonzero.
-
-   The storage for TARGETS and its elements and TARGET_PERCENTS is used and
-   must not be freed until the rule is destroyed.  */
-
-void
-create_pattern_rule (const char **targets, const char **target_percents,
-                     unsigned int n, int terminal, struct dep *deps,
-                     struct commands *commands, int override)
-{
-  unsigned int i;
-  struct rule *r = xmalloc (sizeof (struct rule));
-
-  r->num = n;
-  r->cmds = commands;
-  r->deps = deps;
-  r->targets = targets;
-  r->suffixes = target_percents;
-  r->lens = xmalloc (n * sizeof (unsigned int));
-
-  for (i = 0; i < n; ++i)
-    {
-      r->lens[i] = strlen (targets[i]);
-      assert (r->suffixes[i] != NULL);
-      ++r->suffixes[i];
-    }
-
-  if (new_pattern_rule (r, override))
-    r->terminal = terminal;
-}
-
-/* Print the data base of rules.  */
-
-static void                     /* Useful to call from gdb.  */
-print_rule (struct rule *r)
-{
-  unsigned int i;
-
-  for (i = 0; i < r->num; ++i)
-    {
-      fputs (r->targets[i], stdout);
-      putchar ((i + 1 == r->num) ? ':' : ' ');
-    }
-  if (r->terminal)
-    putchar (':');
-
-  print_prereqs (r->deps);
-
-  if (r->cmds != 0)
-    print_commands (r->cmds);
-}
-
-void
-print_rule_data_base (void)
-{
-  unsigned int rules, terminal;
-  struct rule *r;
-
-  puts (_("\n# Implicit Rules"));
-
-  rules = terminal = 0;
-  for (r = pattern_rules; r != 0; r = r->next)
-    {
-      ++rules;
-
-      putchar ('\n');
-      print_rule (r);
-
-      if (r->terminal)
-        ++terminal;
-    }
-
-  if (rules == 0)
-    puts (_("\n# No implicit rules."));
-  else
-    {
-      printf (_("\n# %u implicit rules, %u (%.1f%%) terminal."),
-              rules, terminal, (double) terminal / (double) rules * 100.0);
-    }
-
-  if (num_pattern_rules != rules)
-    {
-      /* This can happen if a fatal error was detected while reading the
-         makefiles and thus count_implicit_rule_limits wasn't called yet.  */
-      if (num_pattern_rules != 0)
-        ONN (fatal, NILF, _("BUG: num_pattern_rules is wrong!  %u != %u"),
-             num_pattern_rules, rules);
-    }
-}
diff --git a/rule.h b/rule.h
deleted file mode 100644
index b6adc9a..0000000
--- a/rule.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/* Definitions for using pattern rules in GNU Make.
-Copyright (C) 1988-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-
-/* Structure used for pattern (implicit) rules.  */
-
-struct rule
-  {
-    struct rule *next;
-    const char **targets;       /* Targets of the rule.  */
-    unsigned int *lens;         /* Lengths of each target.  */
-    const char **suffixes;      /* Suffixes (after '%') of each target.  */
-    struct dep *deps;           /* Dependencies of the rule.  */
-    struct commands *cmds;      /* Commands to execute.  */
-    unsigned short num;         /* Number of targets.  */
-    char terminal;              /* If terminal (double-colon).  */
-    char in_use;                /* If in use by a parent pattern_search.  */
-  };
-
-/* For calling install_pattern_rule.  */
-struct pspec
-  {
-    const char *target, *dep, *commands;
-  };
-
-
-extern struct rule *pattern_rules;
-extern struct rule *last_pattern_rule;
-extern unsigned int num_pattern_rules;
-
-extern unsigned int max_pattern_deps;
-extern unsigned int max_pattern_targets;
-extern unsigned int max_pattern_dep_length;
-
-extern struct file *suffix_file;
-extern unsigned int maxsuffix;
-
-
-void count_implicit_rule_limits (void);
-void convert_to_pattern (void);
-void install_pattern_rule (struct pspec *p, int terminal);
-void create_pattern_rule (const char **targets, const char **target_percents,
-                          unsigned int num, int terminal, struct dep *deps,
-                          struct commands *commands, int override);
-void print_rule_data_base (void);
diff --git a/signame.c b/signame.c
deleted file mode 100644
index 9ee00e2..0000000
--- a/signame.c
+++ /dev/null
@@ -1,254 +0,0 @@
-/* Convert between signal names and numbers.
-Copyright (C) 1990-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-
-/* If the system provides strsignal, we don't need it. */
-
-#if !HAVE_STRSIGNAL
-
-/* If the system provides sys_siglist, we'll use that.
-   Otherwise create our own.
- */
-
-#if !HAVE_DECL_SYS_SIGLIST
-
-/* Some systems do not define NSIG in <signal.h>.  */
-#ifndef NSIG
-#ifdef  _NSIG
-#define NSIG    _NSIG
-#else
-#define NSIG    32
-#endif
-#endif
-
-/* There is too much variation in Sys V signal numbers and names, so
-   we must initialize them at runtime.  */
-
-static const char *undoc;
-
-static const char *sys_siglist[NSIG];
-
-/* Table of abbreviations for signals.  Note:  A given number can
-   appear more than once with different abbreviations.  */
-#define SIG_TABLE_SIZE  (NSIG*2)
-
-typedef struct
-  {
-    int number;
-    const char *abbrev;
-  } num_abbrev;
-
-static num_abbrev sig_table[SIG_TABLE_SIZE];
-
-/* Number of elements of sig_table used.  */
-static int sig_table_nelts = 0;
-
-/* Enter signal number NUMBER into the tables with ABBREV and NAME.  */
-
-static void
-init_sig (int number, const char *abbrev, const char *name)
-{
-  /* If this value is ever greater than NSIG it seems like it'd be a bug in
-     the system headers, but... better safe than sorry.  We know, for
-     example, that this isn't always true on VMS.  */
-
-  if (number >= 0 && number < NSIG)
-    sys_siglist[number] = name;
-
-  if (sig_table_nelts < SIG_TABLE_SIZE)
-    {
-      sig_table[sig_table_nelts].number = number;
-      sig_table[sig_table_nelts++].abbrev = abbrev;
-    }
-}
-
-static int
-signame_init (void)
-{
-  int i;
-
-  undoc = xstrdup (_("unknown signal"));
-
-  /* Initialize signal names.  */
-  for (i = 0; i < NSIG; i++)
-    sys_siglist[i] = undoc;
-
-  /* Initialize signal names.  */
-#if defined (SIGHUP)
-  init_sig (SIGHUP, "HUP", _("Hangup"));
-#endif
-#if defined (SIGINT)
-  init_sig (SIGINT, "INT", _("Interrupt"));
-#endif
-#if defined (SIGQUIT)
-  init_sig (SIGQUIT, "QUIT", _("Quit"));
-#endif
-#if defined (SIGILL)
-  init_sig (SIGILL, "ILL", _("Illegal Instruction"));
-#endif
-#if defined (SIGTRAP)
-  init_sig (SIGTRAP, "TRAP", _("Trace/breakpoint trap"));
-#endif
-  /* If SIGIOT == SIGABRT, we want to print it as SIGABRT because
-     SIGABRT is in ANSI and POSIX.1 and SIGIOT isn't.  */
-#if defined (SIGABRT)
-  init_sig (SIGABRT, "ABRT", _("Aborted"));
-#endif
-#if defined (SIGIOT)
-  init_sig (SIGIOT, "IOT", _("IOT trap"));
-#endif
-#if defined (SIGEMT)
-  init_sig (SIGEMT, "EMT", _("EMT trap"));
-#endif
-#if defined (SIGFPE)
-  init_sig (SIGFPE, "FPE", _("Floating point exception"));
-#endif
-#if defined (SIGKILL)
-  init_sig (SIGKILL, "KILL", _("Killed"));
-#endif
-#if defined (SIGBUS)
-  init_sig (SIGBUS, "BUS", _("Bus error"));
-#endif
-#if defined (SIGSEGV)
-  init_sig (SIGSEGV, "SEGV", _("Segmentation fault"));
-#endif
-#if defined (SIGSYS)
-  init_sig (SIGSYS, "SYS", _("Bad system call"));
-#endif
-#if defined (SIGPIPE)
-  init_sig (SIGPIPE, "PIPE", _("Broken pipe"));
-#endif
-#if defined (SIGALRM)
-  init_sig (SIGALRM, "ALRM", _("Alarm clock"));
-#endif
-#if defined (SIGTERM)
-  init_sig (SIGTERM, "TERM", _("Terminated"));
-#endif
-#if defined (SIGUSR1)
-  init_sig (SIGUSR1, "USR1", _("User defined signal 1"));
-#endif
-#if defined (SIGUSR2)
-  init_sig (SIGUSR2, "USR2", _("User defined signal 2"));
-#endif
-  /* If SIGCLD == SIGCHLD, we want to print it as SIGCHLD because that
-     is what is in POSIX.1.  */
-#if defined (SIGCHLD)
-  init_sig (SIGCHLD, "CHLD", _("Child exited"));
-#endif
-#if defined (SIGCLD)
-  init_sig (SIGCLD, "CLD", _("Child exited"));
-#endif
-#if defined (SIGPWR)
-  init_sig (SIGPWR, "PWR", _("Power failure"));
-#endif
-#if defined (SIGTSTP)
-  init_sig (SIGTSTP, "TSTP", _("Stopped"));
-#endif
-#if defined (SIGTTIN)
-  init_sig (SIGTTIN, "TTIN", _("Stopped (tty input)"));
-#endif
-#if defined (SIGTTOU)
-  init_sig (SIGTTOU, "TTOU", _("Stopped (tty output)"));
-#endif
-#if defined (SIGSTOP)
-  init_sig (SIGSTOP, "STOP", _("Stopped (signal)"));
-#endif
-#if defined (SIGXCPU)
-  init_sig (SIGXCPU, "XCPU", _("CPU time limit exceeded"));
-#endif
-#if defined (SIGXFSZ)
-  init_sig (SIGXFSZ, "XFSZ", _("File size limit exceeded"));
-#endif
-#if defined (SIGVTALRM)
-  init_sig (SIGVTALRM, "VTALRM", _("Virtual timer expired"));
-#endif
-#if defined (SIGPROF)
-  init_sig (SIGPROF, "PROF", _("Profiling timer expired"));
-#endif
-#if defined (SIGWINCH)
-  /* "Window size changed" might be more accurate, but even if that
-     is all that it means now, perhaps in the future it will be
-     extended to cover other kinds of window changes.  */
-  init_sig (SIGWINCH, "WINCH", _("Window changed"));
-#endif
-#if defined (SIGCONT)
-  init_sig (SIGCONT, "CONT", _("Continued"));
-#endif
-#if defined (SIGURG)
-  init_sig (SIGURG, "URG", _("Urgent I/O condition"));
-#endif
-#if defined (SIGIO)
-  /* "I/O pending" has also been suggested.  A disadvantage is that signal
-     only happens when the process has asked for it, not every time I/O is
-     pending.  Another disadvantage is the confusion from giving it a
-     different name than under Unix.  */
-  init_sig (SIGIO, "IO", _("I/O possible"));
-#endif
-#if defined (SIGWIND)
-  init_sig (SIGWIND, "WIND", _("SIGWIND"));
-#endif
-#if defined (SIGPHONE)
-  init_sig (SIGPHONE, "PHONE", _("SIGPHONE"));
-#endif
-#if defined (SIGPOLL)
-  init_sig (SIGPOLL, "POLL", _("I/O possible"));
-#endif
-#if defined (SIGLOST)
-  init_sig (SIGLOST, "LOST", _("Resource lost"));
-#endif
-#if defined (SIGDANGER)
-  init_sig (SIGDANGER, "DANGER", _("Danger signal"));
-#endif
-#if defined (SIGINFO)
-  init_sig (SIGINFO, "INFO", _("Information request"));
-#endif
-#if defined (SIGNOFP)
-  init_sig (SIGNOFP, "NOFP", _("Floating point co-processor not available"));
-#endif
-
-  return 1;
-}
-
-#endif  /* HAVE_DECL_SYS_SIGLIST */
-
-
-char *
-strsignal (int sig)
-{
-  static char buf[] = "Signal 12345678901234567890";
-
-#if ! HAVE_DECL_SYS_SIGLIST
-# if HAVE_DECL__SYS_SIGLIST
-#  define sys_siglist _sys_siglist
-# elif HAVE_DECL___SYS_SIGLIST
-#  define sys_siglist __sys_siglist
-# else
-  static char sig_initted = 0;
-
-  if (!sig_initted)
-    sig_initted = signame_init ();
-# endif
-#endif
-
-  if (sig > 0 && sig < NSIG)
-    return (char *) sys_siglist[sig];
-
-  sprintf (buf, "Signal %d", sig);
-  return buf;
-}
-
-#endif  /* HAVE_STRSIGNAL */
diff --git a/src/alloca.c b/src/alloca.c
new file mode 100644
index 0000000..02ac921
--- /dev/null
+++ b/src/alloca.c
@@ -0,0 +1,503 @@
+/* alloca.c -- allocate automatically reclaimed memory
+   (Mostly) portable public-domain implementation -- D A Gwyn
+
+   This implementation of the PWB library alloca function,
+   which is used to allocate space off the run-time stack so
+   that it is automatically reclaimed upon procedure exit,
+   was inspired by discussions with J. Q. Johnson of Cornell.
+   J.Otto Tennant <jot@cray.com> contributed the Cray support.
+
+   There are some preprocessor constants that can
+   be defined when compiling for your specific system, for
+   improved efficiency; however, the defaults should be okay.
+
+   The general concept of this implementation is to keep
+   track of all alloca-allocated blocks, and reclaim any
+   that are found to be deeper in the stack than the current
+   invocation.  This heuristic does not reclaim storage as
+   soon as it becomes invalid, but it will do so eventually.
+
+   As a special case, alloca(0) reclaims storage without
+   allocating any.  It is a good idea to use alloca(0) in
+   your main control loop, etc. to force garbage collection.  */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+
+#ifdef emacs
+#include "blockinput.h"
+#endif
+
+/* If compiling with GCC 2, this file's not needed.  */
+#if !defined (__GNUC__) || __GNUC__ < 2
+
+/* If someone has defined alloca as a macro,
+   there must be some other way alloca is supposed to work.  */
+#ifndef alloca
+
+#ifdef emacs
+#ifdef static
+/* actually, only want this if static is defined as ""
+   -- this is for usg, in which emacs must undefine static
+   in order to make unexec workable
+   */
+#ifndef STACK_DIRECTION
+you
+lose
+-- must know STACK_DIRECTION at compile-time
+#endif /* STACK_DIRECTION undefined */
+#endif /* static */
+#endif /* emacs */
+
+/* If your stack is a linked list of frames, you have to
+   provide an "address metric" ADDRESS_FUNCTION macro.  */
+
+#if defined (CRAY) && defined (CRAY_STACKSEG_END)
+long i00afunc ();
+#define ADDRESS_FUNCTION(arg) (char *) i00afunc (&(arg))
+#else
+#define ADDRESS_FUNCTION(arg) &(arg)
+#endif
+
+#if __STDC__
+typedef void *pointer;
+#else
+typedef char *pointer;
+#endif
+
+#ifndef NULL
+#define	NULL	0
+#endif
+
+/* Different portions of Emacs need to call different versions of
+   malloc.  The Emacs executable needs alloca to call xmalloc, because
+   ordinary malloc isn't protected from input signals.  On the other
+   hand, the utilities in lib-src need alloca to call malloc; some of
+   them are very simple, and don't have an xmalloc routine.
+
+   Non-Emacs programs expect this to call use xmalloc.
+
+   Callers below should use malloc.  */
+
+#ifndef emacs
+#define malloc xmalloc
+#endif
+extern pointer malloc ();
+
+/* Define STACK_DIRECTION if you know the direction of stack
+   growth for your system; otherwise it will be automatically
+   deduced at run-time.
+
+   STACK_DIRECTION > 0 => grows toward higher addresses
+   STACK_DIRECTION < 0 => grows toward lower addresses
+   STACK_DIRECTION = 0 => direction of growth unknown  */
+
+#ifndef STACK_DIRECTION
+#define	STACK_DIRECTION	0	/* Direction unknown.  */
+#endif
+
+#if STACK_DIRECTION != 0
+
+#define	STACK_DIR	STACK_DIRECTION	/* Known at compile-time.  */
+
+#else /* STACK_DIRECTION == 0; need run-time code.  */
+
+static int stack_dir;		/* 1 or -1 once known.  */
+#define	STACK_DIR	stack_dir
+
+static void
+find_stack_direction (void)
+{
+  static char *addr = NULL;	/* Address of first 'dummy', once known.  */
+  auto char dummy;		/* To get stack address.  */
+
+  if (addr == NULL)
+    {				/* Initial entry.  */
+      addr = ADDRESS_FUNCTION (dummy);
+
+      find_stack_direction ();	/* Recurse once.  */
+    }
+  else
+    {
+      /* Second entry.  */
+      if (ADDRESS_FUNCTION (dummy) > addr)
+	stack_dir = 1;		/* Stack grew upward.  */
+      else
+	stack_dir = -1;		/* Stack grew downward.  */
+    }
+}
+
+#endif /* STACK_DIRECTION == 0 */
+
+/* An "alloca header" is used to:
+   (a) chain together all alloca'ed blocks;
+   (b) keep track of stack depth.
+
+   It is very important that sizeof(header) agree with malloc
+   alignment chunk size.  The following default should work okay.  */
+
+#ifndef	ALIGN_SIZE
+#define	ALIGN_SIZE	sizeof(double)
+#endif
+
+typedef union hdr
+{
+  char align[ALIGN_SIZE];	/* To force sizeof(header).  */
+  struct
+    {
+      union hdr *next;		/* For chaining headers.  */
+      char *deep;		/* For stack depth measure.  */
+    } h;
+} header;
+
+static header *last_alloca_header = NULL;	/* -> last alloca header.  */
+
+/* Return a pointer to at least SIZE bytes of storage,
+   which will be automatically reclaimed upon exit from
+   the procedure that called alloca.  Originally, this space
+   was supposed to be taken from the current stack frame of the
+   caller, but that method cannot be made to work for some
+   implementations of C, for example under Gould's UTX/32.  */
+
+pointer
+alloca (unsigned size)
+{
+  auto char probe;		/* Probes stack depth: */
+  register char *depth = ADDRESS_FUNCTION (probe);
+
+#if STACK_DIRECTION == 0
+  if (STACK_DIR == 0)		/* Unknown growth direction.  */
+    find_stack_direction ();
+#endif
+
+  /* Reclaim garbage, defined as all alloca'd storage that
+     was allocated from deeper in the stack than currently.  */
+
+  {
+    register header *hp;	/* Traverses linked list.  */
+
+#ifdef emacs
+    BLOCK_INPUT;
+#endif
+
+    for (hp = last_alloca_header; hp != NULL;)
+      if ((STACK_DIR > 0 && hp->h.deep > depth)
+	  || (STACK_DIR < 0 && hp->h.deep < depth))
+	{
+	  register header *np = hp->h.next;
+
+	  free ((pointer) hp);	/* Collect garbage.  */
+
+	  hp = np;		/* -> next header.  */
+	}
+      else
+	break;			/* Rest are not deeper.  */
+
+    last_alloca_header = hp;	/* -> last valid storage.  */
+
+#ifdef emacs
+    UNBLOCK_INPUT;
+#endif
+  }
+
+  if (size == 0)
+    return NULL;		/* No allocation required.  */
+
+  /* Allocate combined header + user data storage.  */
+
+  {
+    register pointer new = malloc (sizeof (header) + size);
+    /* Address of header.  */
+
+    if (new == 0)
+      abort();
+
+    ((header *) new)->h.next = last_alloca_header;
+    ((header *) new)->h.deep = depth;
+
+    last_alloca_header = (header *) new;
+
+    /* User storage begins just after header.  */
+
+    return (pointer) ((char *) new + sizeof (header));
+  }
+}
+
+#if defined (CRAY) && defined (CRAY_STACKSEG_END)
+
+#ifdef DEBUG_I00AFUNC
+#include <stdio.h>
+#endif
+
+#ifndef CRAY_STACK
+#define CRAY_STACK
+#ifndef CRAY2
+/* Stack structures for CRAY-1, CRAY X-MP, and CRAY Y-MP */
+struct stack_control_header
+  {
+    long shgrow:32;		/* Number of times stack has grown.  */
+    long shaseg:32;		/* Size of increments to stack.  */
+    long shhwm:32;		/* High water mark of stack.  */
+    long shsize:32;		/* Current size of stack (all segments).  */
+  };
+
+/* The stack segment linkage control information occurs at
+   the high-address end of a stack segment.  (The stack
+   grows from low addresses to high addresses.)  The initial
+   part of the stack segment linkage control information is
+   0200 (octal) words.  This provides for register storage
+   for the routine which overflows the stack.  */
+
+struct stack_segment_linkage
+  {
+    long ss[0200];		/* 0200 overflow words.  */
+    long sssize:32;		/* Number of words in this segment.  */
+    long ssbase:32;		/* Offset to stack base.  */
+    long:32;
+    long sspseg:32;		/* Offset to linkage control of previous
+				   segment of stack.  */
+    long:32;
+    long sstcpt:32;		/* Pointer to task common address block.  */
+    long sscsnm;		/* Private control structure number for
+				   microtasking.  */
+    long ssusr1;		/* Reserved for user.  */
+    long ssusr2;		/* Reserved for user.  */
+    long sstpid;		/* Process ID for pid based multi-tasking.  */
+    long ssgvup;		/* Pointer to multitasking thread giveup.  */
+    long sscray[7];		/* Reserved for Cray Research.  */
+    long ssa0;
+    long ssa1;
+    long ssa2;
+    long ssa3;
+    long ssa4;
+    long ssa5;
+    long ssa6;
+    long ssa7;
+    long sss0;
+    long sss1;
+    long sss2;
+    long sss3;
+    long sss4;
+    long sss5;
+    long sss6;
+    long sss7;
+  };
+
+#else /* CRAY2 */
+/* The following structure defines the vector of words
+   returned by the STKSTAT library routine.  */
+struct stk_stat
+  {
+    long now;			/* Current total stack size.  */
+    long maxc;			/* Amount of contiguous space which would
+				   be required to satisfy the maximum
+				   stack demand to date.  */
+    long high_water;		/* Stack high-water mark.  */
+    long overflows;		/* Number of stack overflow ($STKOFEN) calls.  */
+    long hits;			/* Number of internal buffer hits.  */
+    long extends;		/* Number of block extensions.  */
+    long stko_mallocs;		/* Block allocations by $STKOFEN.  */
+    long underflows;		/* Number of stack underflow calls ($STKRETN).  */
+    long stko_free;		/* Number of deallocations by $STKRETN.  */
+    long stkm_free;		/* Number of deallocations by $STKMRET.  */
+    long segments;		/* Current number of stack segments.  */
+    long maxs;			/* Maximum number of stack segments so far.  */
+    long pad_size;		/* Stack pad size.  */
+    long current_address;	/* Current stack segment address.  */
+    long current_size;		/* Current stack segment size.  This
+				   number is actually corrupted by STKSTAT to
+				   include the fifteen word trailer area.  */
+    long initial_address;	/* Address of initial segment.  */
+    long initial_size;		/* Size of initial segment.  */
+  };
+
+/* The following structure describes the data structure which trails
+   any stack segment.  I think that the description in 'asdef' is
+   out of date.  I only describe the parts that I am sure about.  */
+
+struct stk_trailer
+  {
+    long this_address;		/* Address of this block.  */
+    long this_size;		/* Size of this block (does not include
+				   this trailer).  */
+    long unknown2;
+    long unknown3;
+    long link;			/* Address of trailer block of previous
+				   segment.  */
+    long unknown5;
+    long unknown6;
+    long unknown7;
+    long unknown8;
+    long unknown9;
+    long unknown10;
+    long unknown11;
+    long unknown12;
+    long unknown13;
+    long unknown14;
+  };
+
+#endif /* CRAY2 */
+#endif /* not CRAY_STACK */
+
+#ifdef CRAY2
+/* Determine a "stack measure" for an arbitrary ADDRESS.
+   I doubt that "lint" will like this much.  */
+
+static long
+i00afunc (long *address)
+{
+  struct stk_stat status;
+  struct stk_trailer *trailer;
+  long *block, size;
+  long result = 0;
+
+  /* We want to iterate through all of the segments.  The first
+     step is to get the stack status structure.  We could do this
+     more quickly and more directly, perhaps, by referencing the
+     $LM00 common block, but I know that this works.  */
+
+  STKSTAT (&status);
+
+  /* Set up the iteration.  */
+
+  trailer = (struct stk_trailer *) (status.current_address
+				    + status.current_size
+				    - 15);
+
+  /* There must be at least one stack segment.  Therefore it is
+     a fatal error if "trailer" is null.  */
+
+  if (trailer == 0)
+    abort ();
+
+  /* Discard segments that do not contain our argument address.  */
+
+  while (trailer != 0)
+    {
+      block = (long *) trailer->this_address;
+      size = trailer->this_size;
+      if (block == 0 || size == 0)
+	abort ();
+      trailer = (struct stk_trailer *) trailer->link;
+      if ((block <= address) && (address < (block + size)))
+	break;
+    }
+
+  /* Set the result to the offset in this segment and add the sizes
+     of all predecessor segments.  */
+
+  result = address - block;
+
+  if (trailer == 0)
+    {
+      return result;
+    }
+
+  do
+    {
+      if (trailer->this_size <= 0)
+	abort ();
+      result += trailer->this_size;
+      trailer = (struct stk_trailer *) trailer->link;
+    }
+  while (trailer != 0);
+
+  /* We are done.  Note that if you present a bogus address (one
+     not in any segment), you will get a different number back, formed
+     from subtracting the address of the first block.  This is probably
+     not what you want.  */
+
+  return (result);
+}
+
+#else /* not CRAY2 */
+/* Stack address function for a CRAY-1, CRAY X-MP, or CRAY Y-MP.
+   Determine the number of the cell within the stack,
+   given the address of the cell.  The purpose of this
+   routine is to linearize, in some sense, stack addresses
+   for alloca.  */
+
+static long
+i00afunc (long address)
+{
+  long stkl = 0;
+
+  long size, pseg, this_segment, stack;
+  long result = 0;
+
+  struct stack_segment_linkage *ssptr;
+
+  /* Register B67 contains the address of the end of the
+     current stack segment.  If you (as a subprogram) store
+     your registers on the stack and find that you are past
+     the contents of B67, you have overflowed the segment.
+
+     B67 also points to the stack segment linkage control
+     area, which is what we are really interested in.  */
+
+  stkl = CRAY_STACKSEG_END ();
+  ssptr = (struct stack_segment_linkage *) stkl;
+
+  /* If one subtracts 'size' from the end of the segment,
+     one has the address of the first word of the segment.
+
+     If this is not the first segment, 'pseg' will be
+     nonzero.  */
+
+  pseg = ssptr->sspseg;
+  size = ssptr->sssize;
+
+  this_segment = stkl - size;
+
+  /* It is possible that calling this routine itself caused
+     a stack overflow.  Discard stack segments which do not
+     contain the target address.  */
+
+  while (!(this_segment <= address && address <= stkl))
+    {
+#ifdef DEBUG_I00AFUNC
+      fprintf (stderr, "%011o %011o %011o\n", this_segment, address, stkl);
+#endif
+      if (pseg == 0)
+	break;
+      stkl = stkl - pseg;
+      ssptr = (struct stack_segment_linkage *) stkl;
+      size = ssptr->sssize;
+      pseg = ssptr->sspseg;
+      this_segment = stkl - size;
+    }
+
+  result = address - this_segment;
+
+  /* If you subtract pseg from the current end of the stack,
+     you get the address of the previous stack segment's end.
+     This seems a little convoluted to me, but I'll bet you save
+     a cycle somewhere.  */
+
+  while (pseg != 0)
+    {
+#ifdef DEBUG_I00AFUNC
+      fprintf (stderr, "%011o %011o\n", pseg, size);
+#endif
+      stkl = stkl - pseg;
+      ssptr = (struct stack_segment_linkage *) stkl;
+      size = ssptr->sssize;
+      pseg = ssptr->sspseg;
+      result += size;
+    }
+  return (result);
+}
+
+#endif /* not CRAY2 */
+#endif /* CRAY */
+
+#endif /* no alloca */
+#endif /* not GCC version 2 */
diff --git a/src/amiga.c b/src/amiga.c
new file mode 100644
index 0000000..c1b31db
--- /dev/null
+++ b/src/amiga.c
@@ -0,0 +1,117 @@
+/* Running commands on Amiga
+Copyright (C) 1995-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+#include "variable.h"
+#include "amiga.h"
+#include <assert.h>
+#include <exec/memory.h>
+#include <dos/dostags.h>
+#include <proto/exec.h>
+#include <proto/dos.h>
+
+static const char Amiga_version[] = "$VER: Make 3.74.3 (12.05.96) \n"
+                    "Amiga Port by A. Digulla (digulla@home.lake.de)";
+
+int
+MyExecute (char **argv)
+{
+    char * buffer, * ptr;
+    char ** aptr;
+    int len = 0;
+    int status;
+
+    for (aptr=argv; *aptr; aptr++)
+    {
+        len += strlen (*aptr) + 4;
+    }
+
+    buffer = AllocMem (len, MEMF_ANY);
+
+    if (!buffer)
+      O (fatal, NILF, "MyExecute: Cannot allocate space for calling a command\n");
+
+    ptr = buffer;
+
+    for (aptr=argv; *aptr; aptr++)
+    {
+        if (((*aptr)[0] == ';' && !(*aptr)[1]))
+        {
+            *ptr ++ = '"';
+            strcpy (ptr, *aptr);
+            ptr += strlen (ptr);
+            *ptr ++ = '"';
+        }
+        else if ((*aptr)[0] == '@' && (*aptr)[1] == '@' && !(*aptr)[2])
+        {
+            *ptr ++ = '\n';
+            continue;
+        }
+        else
+        {
+            strcpy (ptr, *aptr);
+            ptr += strlen (ptr);
+        }
+        *ptr ++ = ' ';
+        *ptr = 0;
+    }
+
+    ptr[-1] = '\n';
+
+    status = SystemTags (buffer,
+        SYS_UserShell, TRUE,
+        TAG_END);
+
+    FreeMem (buffer, len);
+
+    if (SetSignal (0L,0L) & SIGBREAKF_CTRL_C)
+        status = 20;
+
+    /* Warnings don't count */
+    if (status == 5)
+        status = 0;
+
+    return status;
+}
+
+char *
+wildcard_expansion (char *wc, char *o)
+{
+#   define PATH_SIZE    1024
+    struct AnchorPath * apath;
+
+    if ( (apath = AllocMem (sizeof (struct AnchorPath) + PATH_SIZE,
+            MEMF_CLEAR))
+        )
+    {
+        apath->ap_Strlen = PATH_SIZE;
+
+        if (MatchFirst (wc, apath) == 0)
+        {
+            do
+            {
+                o = variable_buffer_output (o, apath->ap_Buf,
+                        strlen (apath->ap_Buf));
+                o = variable_buffer_output (o, " ",1);
+            } while (MatchNext (apath) == 0);
+        }
+
+        MatchEnd (apath);
+        FreeMem (apath, sizeof (struct AnchorPath) + PATH_SIZE);
+    }
+
+    return o;
+}
diff --git a/src/amiga.h b/src/amiga.h
new file mode 100644
index 0000000..940bc3a
--- /dev/null
+++ b/src/amiga.h
@@ -0,0 +1,18 @@
+/* Definitions for amiga specific things
+Copyright (C) 1995-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+int MyExecute (char ** argv);
+char * wildcard_expansion (char * wc, char * o);
diff --git a/src/ar.c b/src/ar.c
new file mode 100644
index 0000000..65ea01c
--- /dev/null
+++ b/src/ar.c
@@ -0,0 +1,328 @@
+/* Interface to 'ar' archives for GNU Make.
+Copyright (C) 1988-2017 Free Software Foundation, Inc.
+
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+
+#ifndef NO_ARCHIVES
+
+#include "filedef.h"
+#include "dep.h"
+#include <fnmatch.h>
+
+/* Return nonzero if NAME is an archive-member reference, zero if not.  An
+   archive-member reference is a name like 'lib(member)' where member is a
+   non-empty string.
+   If a name like 'lib((entry))' is used, a fatal error is signaled at
+   the attempt to use this unsupported feature.  */
+
+int
+ar_name (const char *name)
+{
+  const char *p = strchr (name, '(');
+  const char *end;
+
+  if (p == 0 || p == name)
+    return 0;
+
+  end = p + strlen (p) - 1;
+  if (*end != ')' || end == p + 1)
+    return 0;
+
+  if (p[1] == '(' && end[-1] == ')')
+    OS (fatal, NILF, _("attempt to use unsupported feature: '%s'"), name);
+
+  return 1;
+}
+
+
+/* Parse the archive-member reference NAME into the archive and member names.
+   Creates one allocated string containing both names, pointed to by ARNAME_P.
+   MEMNAME_P points to the member.  */
+
+void
+ar_parse_name (const char *name, char **arname_p, char **memname_p)
+{
+  char *p;
+
+  *arname_p = xstrdup (name);
+  p = strchr (*arname_p, '(');
+  *(p++) = '\0';
+  p[strlen (p) - 1] = '\0';
+  *memname_p = p;
+}
+
+
+/* This function is called by 'ar_scan' to find which member to look at.  */
+
+/* ARGSUSED */
+static long int
+ar_member_date_1 (int desc UNUSED, const char *mem, int truncated,
+                  long int hdrpos UNUSED, long int datapos UNUSED,
+                  long int size UNUSED, long int date,
+                  int uid UNUSED, int gid UNUSED, unsigned int mode UNUSED,
+                  const void *name)
+{
+  return ar_name_equal (name, mem, truncated) ? date : 0;
+}
+
+/* Return the modtime of NAME.  */
+
+time_t
+ar_member_date (const char *name)
+{
+  char *arname;
+  char *memname;
+  long int val;
+
+  ar_parse_name (name, &arname, &memname);
+
+  /* Make sure we know the modtime of the archive itself because we are
+     likely to be called just before commands to remake a member are run,
+     and they will change the archive itself.
+
+     But we must be careful not to enter_file the archive itself if it does
+     not exist, because pattern_search assumes that files found in the data
+     base exist or can be made.  */
+  {
+    struct file *arfile;
+    arfile = lookup_file (arname);
+    if (arfile == 0 && file_exists_p (arname))
+      arfile = enter_file (strcache_add (arname));
+
+    if (arfile != 0)
+      (void) f_mtime (arfile, 0);
+  }
+
+  val = ar_scan (arname, ar_member_date_1, memname);
+
+  free (arname);
+
+  return (val <= 0 ? (time_t) -1 : (time_t) val);
+}
+
+/* Set the archive-member NAME's modtime to now.  */
+
+#ifdef VMS
+int
+ar_touch (const char *name)
+{
+  O (error, NILF, _("touch archive member is not available on VMS"));
+  return -1;
+}
+#else
+int
+ar_touch (const char *name)
+{
+  char *arname, *memname;
+  int val;
+
+  ar_parse_name (name, &arname, &memname);
+
+  /* Make sure we know the modtime of the archive itself before we
+     touch the member, since this will change the archive modtime.  */
+  {
+    struct file *arfile;
+    arfile = enter_file (strcache_add (arname));
+    f_mtime (arfile, 0);
+  }
+
+  val = 1;
+  switch (ar_member_touch (arname, memname))
+    {
+    case -1:
+      OS (error, NILF, _("touch: Archive '%s' does not exist"), arname);
+      break;
+    case -2:
+      OS (error, NILF, _("touch: '%s' is not a valid archive"), arname);
+      break;
+    case -3:
+      perror_with_name ("touch: ", arname);
+      break;
+    case 1:
+      OSS (error, NILF,
+           _("touch: Member '%s' does not exist in '%s'"), memname, arname);
+      break;
+    case 0:
+      val = 0;
+      break;
+    default:
+      OS (error, NILF,
+          _("touch: Bad return code from ar_member_touch on '%s'"), name);
+    }
+
+  free (arname);
+
+  return val;
+}
+#endif /* !VMS */
+
+/* State of an 'ar_glob' run, passed to 'ar_glob_match'.  */
+
+/* On VMS, (object) modules in libraries do not have suffixes. That is, to
+   find a match for a pattern, the pattern must not have any suffix. So the
+   suffix of the pattern is saved and the pattern is stripped (ar_glob).
+   If there is a match and the match, which is a module name, is added to
+   the chain, the saved suffix is added back to construct a source filename
+   (ar_glob_match). */
+
+struct ar_glob_state
+  {
+    const char *arname;
+    const char *pattern;
+#ifdef VMS
+    char *suffix;
+#endif
+    unsigned int size;
+    struct nameseq *chain;
+    unsigned int n;
+  };
+
+/* This function is called by 'ar_scan' to match one archive
+   element against the pattern in STATE.  */
+
+static long int
+ar_glob_match (int desc UNUSED, const char *mem, int truncated UNUSED,
+               long int hdrpos UNUSED, long int datapos UNUSED,
+               long int size UNUSED, long int date UNUSED, int uid UNUSED,
+               int gid UNUSED, unsigned int mode UNUSED, const void *arg)
+{
+  struct ar_glob_state *state = (struct ar_glob_state *)arg;
+
+  if (fnmatch (state->pattern, mem, FNM_PATHNAME|FNM_PERIOD) == 0)
+    {
+      /* We have a match.  Add it to the chain.  */
+      struct nameseq *new = xcalloc (state->size);
+#ifdef VMS
+      if (state->suffix)
+        new->name = strcache_add(
+            concat(5, state->arname, "(", mem, state->suffix, ")"));
+      else
+#endif
+        new->name = strcache_add(concat(4, state->arname, "(", mem, ")"));
+      new->next = state->chain;
+      state->chain = new;
+      ++state->n;
+    }
+
+  return 0L;
+}
+
+/* Return nonzero if PATTERN contains any metacharacters.
+   Metacharacters can be quoted with backslashes if QUOTE is nonzero.  */
+static int
+ar_glob_pattern_p (const char *pattern, int quote)
+{
+  const char *p;
+  int opened = 0;
+
+  for (p = pattern; *p != '\0'; ++p)
+    switch (*p)
+      {
+      case '?':
+      case '*':
+        return 1;
+
+      case '\\':
+        if (quote)
+          ++p;
+        break;
+
+      case '[':
+        opened = 1;
+        break;
+
+      case ']':
+        if (opened)
+          return 1;
+        break;
+      }
+
+  return 0;
+}
+
+/* Glob for MEMBER_PATTERN in archive ARNAME.
+   Return a malloc'd chain of matching elements (or nil if none).  */
+
+struct nameseq *
+ar_glob (const char *arname, const char *member_pattern, unsigned int size)
+{
+  struct ar_glob_state state;
+  struct nameseq *n;
+  const char **names;
+  unsigned int i;
+#ifdef VMS
+  char *vms_member_pattern;
+#endif
+  if (! ar_glob_pattern_p (member_pattern, 1))
+    return 0;
+
+  /* Scan the archive for matches.
+     ar_glob_match will accumulate them in STATE.chain.  */
+  state.arname = arname;
+  state.pattern = member_pattern;
+#ifdef VMS
+    {
+      /* In a copy of the pattern, find the suffix, save it and  remove it from
+         the pattern */
+      char *lastdot;
+      vms_member_pattern = xstrdup(member_pattern);
+      lastdot = strrchr(vms_member_pattern, '.');
+      state.suffix = lastdot;
+      if (lastdot)
+        {
+          state.suffix = xstrdup(lastdot);
+          *lastdot = 0;
+        }
+      state.pattern = vms_member_pattern;
+    }
+#endif
+  state.size = size;
+  state.chain = 0;
+  state.n = 0;
+  ar_scan (arname, ar_glob_match, &state);
+
+#ifdef VMS
+  /* Deallocate any duplicated string */
+  free(vms_member_pattern);
+  if (state.suffix)
+    {
+      free(state.suffix);
+    }
+#endif
+
+  if (state.chain == 0)
+    return 0;
+
+  /* Now put the names into a vector for sorting.  */
+  names = alloca (state.n * sizeof (const char *));
+  i = 0;
+  for (n = state.chain; n != 0; n = n->next)
+    names[i++] = n->name;
+
+  /* Sort them alphabetically.  */
+  /* MSVC erroneously warns without a cast here.  */
+  qsort ((void *)names, i, sizeof (*names), alpha_compare);
+
+  /* Put them back into the chain in the sorted order.  */
+  i = 0;
+  for (n = state.chain; n != 0; n = n->next)
+    n->name = names[i++];
+
+  return state.chain;
+}
+
+#endif  /* Not NO_ARCHIVES.  */
diff --git a/src/arscan.c b/src/arscan.c
new file mode 100644
index 0000000..af3c96f
--- /dev/null
+++ b/src/arscan.c
@@ -0,0 +1,959 @@
+/* Library function for scanning an archive file.
+Copyright (C) 1987-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+
+#ifdef TEST
+/* Hack, the real error() routine eventually pulls in die from main.c */
+#define error(a, b, c, d)
+#endif
+
+#ifdef HAVE_FCNTL_H
+#include <fcntl.h>
+#else
+#include <sys/file.h>
+#endif
+
+#ifndef NO_ARCHIVES
+
+#ifdef VMS
+#include <lbrdef.h>
+#include <mhddef.h>
+#include <credef.h>
+#include <descrip.h>
+#include <ctype.h>
+#include <ssdef.h>
+#include <stsdef.h>
+#include <rmsdef.h>
+
+/* This symbol should be present in lbrdef.h. */
+#ifndef LBR$_HDRTRUNC
+#pragma extern_model save
+#pragma extern_model globalvalue
+extern unsigned int LBR$_HDRTRUNC;
+#pragma extern_model restore
+#endif
+
+#include <unixlib.h>
+#include <lbr$routines.h>
+
+const char *
+vmsify (const char *name, int type);
+
+/* Time conversion from VMS to Unix
+   Conversion from local time (stored in library) to GMT (needed for gmake)
+   Note: The tm_gmtoff element is a VMS extension to the ANSI standard. */
+static time_t
+vms_time_to_unix(void *vms_time)
+{
+  struct tm *tmp;
+  time_t unix_time;
+
+  unix_time = decc$fix_time(vms_time);
+  tmp = localtime(&unix_time);
+  unix_time -= tmp->tm_gmtoff;
+
+  return unix_time;
+}
+
+
+/* VMS library routines need static variables for callback */
+static void *VMS_lib_idx;
+
+static const void *VMS_saved_arg;
+
+static long int (*VMS_function) ();
+
+static long int VMS_function_ret;
+
+
+/* This is a callback procedure for lib$get_index */
+static int
+VMS_get_member_info(struct dsc$descriptor_s *module, unsigned long *rfa)
+{
+  int status, i;
+  const int truncated = 0; /* Member name may be truncated */
+  time_t member_date; /* Member date */
+  char *filename;
+  unsigned int buffer_length; /* Actual buffer length */
+
+  /* Unused constants - Make does not actually use most of these */
+  const int file_desc = -1; /* archive file descriptor for reading the data */
+  const int header_position = 0; /* Header position */
+  const int data_position = 0; /* Data position in file */
+  const int data_size = 0; /* Data size */
+  const int uid = 0; /* member gid */
+  const int gid = 0; /* member gid */
+  const int mode = 0; /* member protection mode */
+  /* End of unused constants */
+
+  static struct dsc$descriptor_s bufdesc =
+    { 0, DSC$K_DTYPE_T, DSC$K_CLASS_S, NULL };
+
+  /* Only need the module definition */
+  struct mhddef *mhd;
+
+  /* If a previous callback is non-zero, just return that status */
+  if (VMS_function_ret)
+    {
+      return SS$_NORMAL;
+    }
+
+  /* lbr_set_module returns more than just the module header. So allocate
+     a buffer which is big enough: the maximum LBR$C_MAXHDRSIZ. That's at
+     least bigger than the size of struct mhddef.
+     If the request is too small, a buffer truncated warning is issued so
+     it can be reissued with a larger buffer.
+     We do not care if the buffer is truncated, so that is still a success. */
+  mhd = xmalloc(LBR$C_MAXHDRSIZ);
+  bufdesc.dsc$a_pointer = (char *) mhd;
+  bufdesc.dsc$w_length = LBR$C_MAXHDRSIZ;
+
+  status = lbr$set_module(&VMS_lib_idx, rfa, &bufdesc, &buffer_length, 0);
+
+  if ((status != LBR$_HDRTRUNC) && !$VMS_STATUS_SUCCESS(status))
+    {
+      ON(error, NILF,
+          _("lbr$set_module() failed to extract module info, status = %d"),
+          status);
+
+      lbr$close(&VMS_lib_idx);
+
+      return status;
+    }
+
+#ifdef TEST
+  /* When testing this code, it is useful to know the length returned */
+  printf ("Input length = %d, actual = %u\n",
+          bufdesc.dsc$w_length, buffer_length);
+#endif
+
+  /* Conversion from VMS time to C time.
+     VMS defectlet - mhddef is sub-optimal, for the time, it has a 32 bit
+     longword, mhd$l_datim, and a 32 bit fill instead of two longwords, or
+     equivalent. */
+  member_date = vms_time_to_unix(&mhd->mhd$l_datim);
+  free(mhd);
+
+  /* Here we have a problem.  The module name on VMS does not have
+     a file type, but the filename pattern in the "VMS_saved_arg"
+     may have one.
+     But only the method being called knows how to interpret the
+     filename pattern.
+     There are currently two different formats being used.
+     This means that we need a VMS specific code in those methods
+     to handle it. */
+  filename = xmalloc(module->dsc$w_length + 1);
+
+  /* TODO: We may need an option to preserve the case of the module
+     For now force the module name to lower case */
+  for (i = 0; i < module->dsc$w_length; i++)
+    filename[i] = _tolower((unsigned char )module->dsc$a_pointer[i]);
+
+  filename[i] = '\0';
+
+  VMS_function_ret = (*VMS_function)(file_desc, filename, truncated,
+      header_position, data_position, data_size, member_date, uid, gid, mode,
+      VMS_saved_arg);
+
+  free(filename);
+  return SS$_NORMAL;
+}
+
+
+/* Takes three arguments ARCHIVE, FUNCTION and ARG.
+
+   Open the archive named ARCHIVE, find its members one by one,
+   and for each one call FUNCTION with the following arguments:
+     archive file descriptor for reading the data,
+     member name,
+     member name might be truncated flag,
+     member header position in file,
+     member data position in file,
+     member data size,
+     member date,
+     member uid,
+     member gid,
+     member protection mode,
+     ARG.
+
+   NOTE: on VMS systems, only name, date, and arg are meaningful!
+
+   The descriptor is poised to read the data of the member
+   when FUNCTION is called.  It does not matter how much
+   data FUNCTION reads.
+
+   If FUNCTION returns nonzero, we immediately return
+   what FUNCTION returned.
+
+   Returns -1 if archive does not exist,
+   Returns -2 if archive has invalid format.
+   Returns 0 if have scanned successfully.  */
+
+long int
+ar_scan (const char *archive, ar_member_func_t function, const void *varg)
+{
+  char *vms_archive;
+
+  static struct dsc$descriptor_s libdesc =
+    { 0, DSC$K_DTYPE_T, DSC$K_CLASS_S, NULL };
+
+  const unsigned long func = LBR$C_READ;
+  const unsigned long type = LBR$C_TYP_UNK;
+  const unsigned long index = 1;
+  unsigned long lib_idx;
+  int status;
+
+  VMS_saved_arg = varg;
+
+  /* Null archive string can show up in test and cause an access violation */
+  if (archive == NULL)
+    {
+      /* Null filenames do not exist */
+      return -1;
+    }
+
+  /* archive path name must be in VMS format */
+  vms_archive = (char *) vmsify(archive, 0);
+
+  status = lbr$ini_control(&VMS_lib_idx, &func, &type, 0);
+
+  if (!$VMS_STATUS_SUCCESS(status))
+    {
+      ON(error, NILF, _("lbr$ini_control() failed with status = %d"), status);
+      return -2;
+    }
+
+  libdesc.dsc$a_pointer = vms_archive;
+  libdesc.dsc$w_length = strlen(vms_archive);
+
+  status = lbr$open(&VMS_lib_idx, &libdesc, 0, NULL, 0, NULL, 0);
+
+  if (!$VMS_STATUS_SUCCESS(status))
+    {
+
+      /* TODO: A library format failure could mean that this is a file
+         generated by the GNU AR utility and in that case, we need to
+         take the UNIX codepath.  This will also take a change to the
+         GNV AR wrapper program. */
+
+      switch (status)
+        {
+      case RMS$_FNF:
+        /* Archive does not exist */
+        return -1;
+      default:
+#ifndef TEST
+        OSN(error, NILF,
+            _("unable to open library '%s' to lookup member status %d"),
+            archive, status);
+#endif
+        /* For library format errors, specification says to return -2 */
+        return -2;
+        }
+    }
+
+  VMS_function = function;
+
+  /* Clear the return status, as we are supposed to stop calling the
+     callback function if it becomes non-zero, and this is a static
+     variable. */
+  VMS_function_ret = 0;
+
+  status = lbr$get_index(&VMS_lib_idx, &index, VMS_get_member_info, NULL, 0);
+
+  lbr$close(&VMS_lib_idx);
+
+  /* Unless a failure occurred in the lbr$ routines, return the
+     the status from the 'function' routine. */
+  if ($VMS_STATUS_SUCCESS(status))
+    {
+      return VMS_function_ret;
+    }
+
+  /* This must be something wrong with the library and an error
+     message should already have been printed. */
+  return -2;
+}
+
+#else /* !VMS */
+
+/* SCO Unix's compiler defines both of these.  */
+#ifdef  M_UNIX
+#undef  M_XENIX
+#endif
+
+/* On the sun386i and in System V rel 3, ar.h defines two different archive
+   formats depending upon whether you have defined PORTAR (normal) or PORT5AR
+   (System V Release 1).  There is no default, one or the other must be defined
+   to have a nonzero value.  */
+
+#if (!defined (PORTAR) || PORTAR == 0) && (!defined (PORT5AR) || PORT5AR == 0)
+#undef  PORTAR
+#ifdef M_XENIX
+/* According to Jim Sievert <jas1@rsvl.unisys.com>, for SCO XENIX defining
+   PORTAR to 1 gets the wrong archive format, and defining it to 0 gets the
+   right one.  */
+#define PORTAR 0
+#else
+#define PORTAR 1
+#endif
+#endif
+
+/* On AIX, define these symbols to be sure to get both archive formats.
+   AIX 4.3 introduced the "big" archive format to support 64-bit object
+   files, so on AIX 4.3 systems we need to support both the "normal" and
+   "big" archive formats.  An archive's format is indicated in the
+   "fl_magic" field of the "FL_HDR" structure.  For a normal archive,
+   this field will be the string defined by the AIAMAG symbol.  For a
+   "big" archive, it will be the string defined by the AIAMAGBIG symbol
+   (at least on AIX it works this way).
+
+   Note: we'll define these symbols regardless of which AIX version
+   we're compiling on, but this is okay since we'll use the new symbols
+   only if they're present.  */
+#ifdef _AIX
+# define __AR_SMALL__
+# define __AR_BIG__
+#endif
+
+#ifndef WINDOWS32
+# if !defined (__ANDROID__) && !defined (__BEOS__)
+#  include <ar.h>
+# else
+   /* These platforms don't have <ar.h> but have archives in the same format
+    * as many other Unices.  This was taken from GNU binutils for BeOS.
+    */
+#  define ARMAG "!<arch>\n"     /* String that begins an archive file.  */
+#  define SARMAG 8              /* Size of that string.  */
+#  define ARFMAG "`\n"          /* String in ar_fmag at end of each header.  */
+struct ar_hdr
+  {
+    char ar_name[16];           /* Member file name, sometimes / terminated. */
+    char ar_date[12];           /* File date, decimal seconds since Epoch.  */
+    char ar_uid[6], ar_gid[6];  /* User and group IDs, in ASCII decimal.  */
+    char ar_mode[8];            /* File mode, in ASCII octal.  */
+    char ar_size[10];           /* File size, in ASCII decimal.  */
+    char ar_fmag[2];            /* Always contains ARFMAG.  */
+  };
+# endif
+# define TOCHAR(_m)     (_m)
+#else
+/* These should allow us to read Windows (VC++) libraries (according to Frank
+ * Libbrecht <frankl@abzx.belgium.hp.com>)
+ */
+# include <windows.h>
+# include <windef.h>
+# include <io.h>
+# define ARMAG      IMAGE_ARCHIVE_START
+# define SARMAG     IMAGE_ARCHIVE_START_SIZE
+# define ar_hdr     _IMAGE_ARCHIVE_MEMBER_HEADER
+# define ar_name    Name
+# define ar_mode    Mode
+# define ar_size    Size
+# define ar_date    Date
+# define ar_uid     UserID
+# define ar_gid     GroupID
+/* In Windows the member names have type BYTE so we must cast them.  */
+# define TOCHAR(_m)     ((char *)(_m))
+#endif
+
+/* Cray's <ar.h> apparently defines this.  */
+#ifndef AR_HDR_SIZE
+# define   AR_HDR_SIZE  (sizeof (struct ar_hdr))
+#endif
+
+#include "output.h"
+
+/* Takes three arguments ARCHIVE, FUNCTION and ARG.
+
+   Open the archive named ARCHIVE, find its members one by one,
+   and for each one call FUNCTION with the following arguments:
+     archive file descriptor for reading the data,
+     member name,
+     member name might be truncated flag,
+     member header position in file,
+     member data position in file,
+     member data size,
+     member date,
+     member uid,
+     member gid,
+     member protection mode,
+     ARG.
+
+   The descriptor is poised to read the data of the member
+   when FUNCTION is called.  It does not matter how much
+   data FUNCTION reads.
+
+   If FUNCTION returns nonzero, we immediately return
+   what FUNCTION returned.
+
+   Returns -1 if archive does not exist,
+   Returns -2 if archive has invalid format.
+   Returns 0 if have scanned successfully.  */
+
+long int
+ar_scan (const char *archive, ar_member_func_t function, const void *arg)
+{
+#ifdef AIAMAG
+  FL_HDR fl_header;
+# ifdef AIAMAGBIG
+  int big_archive = 0;
+  FL_HDR_BIG fl_header_big;
+# endif
+#endif
+  char *namemap = 0;
+  int desc = open (archive, O_RDONLY, 0);
+  if (desc < 0)
+    return -1;
+
+#ifdef SARMAG
+  {
+    char buf[SARMAG];
+    int nread;
+    EINTRLOOP (nread, read (desc, buf, SARMAG));
+    if (nread != SARMAG || memcmp (buf, ARMAG, SARMAG))
+      goto invalid;
+  }
+#else
+#ifdef AIAMAG
+  {
+    int nread;
+    EINTRLOOP (nread, read (desc, &fl_header, FL_HSZ));
+    if (nread != FL_HSZ)
+      goto invalid;
+
+#ifdef AIAMAGBIG
+    /* If this is a "big" archive, then set the flag and
+       re-read the header into the "big" structure. */
+    if (!memcmp (fl_header.fl_magic, AIAMAGBIG, SAIAMAG))
+      {
+        off_t o;
+
+        big_archive = 1;
+
+        /* seek back to beginning of archive */
+        EINTRLOOP (o, lseek (desc, 0, 0));
+        if (o < 0)
+          goto invalid;
+
+        /* re-read the header into the "big" structure */
+        EINTRLOOP (nread, read (desc, &fl_header_big, FL_HSZ_BIG));
+        if (nread != FL_HSZ_BIG)
+          goto invalid;
+      }
+    else
+#endif
+       /* Check to make sure this is a "normal" archive. */
+      if (memcmp (fl_header.fl_magic, AIAMAG, SAIAMAG))
+        goto invalid;
+  }
+#else
+  {
+#ifndef M_XENIX
+    int buf;
+#else
+    unsigned short int buf;
+#endif
+    int nread;
+    EINTRLOOP (nread, read (desc, &buf, sizeof (buf)));
+    if (nread != sizeof (buf) || buf != ARMAG)
+      goto invalid;
+  }
+#endif
+#endif
+
+  /* Now find the members one by one.  */
+  {
+#ifdef SARMAG
+    long int member_offset = SARMAG;
+#else
+#ifdef AIAMAG
+    long int member_offset;
+    long int last_member_offset;
+
+#ifdef AIAMAGBIG
+    if ( big_archive )
+      {
+        sscanf (fl_header_big.fl_fstmoff, "%20ld", &member_offset);
+        sscanf (fl_header_big.fl_lstmoff, "%20ld", &last_member_offset);
+      }
+    else
+#endif
+      {
+        sscanf (fl_header.fl_fstmoff, "%12ld", &member_offset);
+        sscanf (fl_header.fl_lstmoff, "%12ld", &last_member_offset);
+      }
+
+    if (member_offset == 0)
+      {
+        /* Empty archive.  */
+        close (desc);
+        return 0;
+      }
+#else
+#ifndef M_XENIX
+    long int member_offset = sizeof (int);
+#else   /* Xenix.  */
+    long int member_offset = sizeof (unsigned short int);
+#endif  /* Not Xenix.  */
+#endif
+#endif
+
+    while (1)
+      {
+        int nread;
+        struct ar_hdr member_header;
+#ifdef AIAMAGBIG
+        struct ar_hdr_big member_header_big;
+#endif
+#ifdef AIAMAG
+# define ARNAME_MAX 255
+        char name[ARNAME_MAX + 1];
+        int name_len;
+        long int dateval;
+        int uidval, gidval;
+        long int data_offset;
+#else
+# define ARNAME_MAX (int)sizeof(member_header.ar_name)
+        char namebuf[ARNAME_MAX + 1];
+        char *name;
+        int is_namemap;         /* Nonzero if this entry maps long names.  */
+        int long_name = 0;
+#endif
+        long int eltsize;
+        unsigned int eltmode;
+        long int fnval;
+        off_t o;
+
+        EINTRLOOP (o, lseek (desc, member_offset, 0));
+        if (o < 0)
+          goto invalid;
+
+#ifdef AIAMAG
+#define       AR_MEMHDR_SZ(x) (sizeof(x) - sizeof (x._ar_name))
+
+#ifdef AIAMAGBIG
+        if (big_archive)
+          {
+            EINTRLOOP (nread, read (desc, &member_header_big,
+                                    AR_MEMHDR_SZ(member_header_big)));
+
+            if (nread != AR_MEMHDR_SZ(member_header_big))
+              goto invalid;
+
+            sscanf (member_header_big.ar_namlen, "%4d", &name_len);
+            if (name_len < 1 || name_len > ARNAME_MAX)
+              goto invalid;
+
+            EINTRLOOP (nread, read (desc, name, name_len));
+            if (nread != name_len)
+              goto invalid;
+
+            name[name_len] = '\0';
+
+            sscanf (member_header_big.ar_date, "%12ld", &dateval);
+            sscanf (member_header_big.ar_uid, "%12d", &uidval);
+            sscanf (member_header_big.ar_gid, "%12d", &gidval);
+            sscanf (member_header_big.ar_mode, "%12o", &eltmode);
+            sscanf (member_header_big.ar_size, "%20ld", &eltsize);
+
+            data_offset = (member_offset + AR_MEMHDR_SZ(member_header_big)
+                           + name_len + 2);
+          }
+        else
+#endif
+          {
+            EINTRLOOP (nread, read (desc, &member_header,
+                                    AR_MEMHDR_SZ(member_header)));
+
+            if (nread != AR_MEMHDR_SZ(member_header))
+              goto invalid;
+
+            sscanf (member_header.ar_namlen, "%4d", &name_len);
+            if (name_len < 1 || name_len > ARNAME_MAX)
+              goto invalid;
+
+            EINTRLOOP (nread, read (desc, name, name_len));
+            if (nread != name_len)
+              goto invalid;
+
+            name[name_len] = '\0';
+
+            sscanf (member_header.ar_date, "%12ld", &dateval);
+            sscanf (member_header.ar_uid, "%12d", &uidval);
+            sscanf (member_header.ar_gid, "%12d", &gidval);
+            sscanf (member_header.ar_mode, "%12o", &eltmode);
+            sscanf (member_header.ar_size, "%12ld", &eltsize);
+
+            data_offset = (member_offset + AR_MEMHDR_SZ(member_header)
+                           + name_len + 2);
+          }
+        data_offset += data_offset % 2;
+
+        fnval =
+          (*function) (desc, name, 0,
+                       member_offset, data_offset, eltsize,
+                       dateval, uidval, gidval,
+                       eltmode, arg);
+
+#else   /* Not AIAMAG.  */
+        EINTRLOOP (nread, read (desc, &member_header, AR_HDR_SIZE));
+        if (nread == 0)
+          /* No data left means end of file; that is OK.  */
+          break;
+
+        if (nread != AR_HDR_SIZE
+#if defined(ARFMAG) || defined(ARFZMAG)
+            || (
+# ifdef ARFMAG
+                memcmp (member_header.ar_fmag, ARFMAG, 2)
+# else
+                1
+# endif
+                &&
+# ifdef ARFZMAG
+                memcmp (member_header.ar_fmag, ARFZMAG, 2)
+# else
+                1
+# endif
+               )
+#endif
+            )
+          goto invalid;
+
+        name = namebuf;
+        memcpy (name, member_header.ar_name, sizeof member_header.ar_name);
+        {
+          char *p = name + sizeof member_header.ar_name;
+          do
+            *p = '\0';
+          while (p > name && *--p == ' ');
+
+#ifndef AIAMAG
+          /* If the member name is "//" or "ARFILENAMES/" this may be
+             a list of file name mappings.  The maximum file name
+             length supported by the standard archive format is 14
+             characters.  This member will actually always be the
+             first or second entry in the archive, but we don't check
+             that.  */
+          is_namemap = (!strcmp (name, "//")
+                        || !strcmp (name, "ARFILENAMES/"));
+#endif  /* Not AIAMAG. */
+
+          /* On some systems, there is a slash after each member name.  */
+          if (*p == '/')
+            *p = '\0';
+
+#ifndef AIAMAG
+          /* If the member name starts with a space or a slash, this
+             is an index into the file name mappings (used by GNU ar).
+             Otherwise if the member name looks like #1/NUMBER the
+             real member name appears in the element data (used by
+             4.4BSD).  */
+          if (! is_namemap
+              && (name[0] == ' ' || name[0] == '/')
+              && namemap != 0)
+            {
+              int name_off = atoi (name + 1);
+              if (name_off < 1 || name_off > ARNAME_MAX)
+                goto invalid;
+
+              name = namemap + name_off;
+              long_name = 1;
+            }
+          else if (name[0] == '#'
+                   && name[1] == '1'
+                   && name[2] == '/')
+            {
+              int name_len = atoi (name + 3);
+              if (name_len < 1 || name_len > ARNAME_MAX)
+                goto invalid;
+
+              name = alloca (name_len + 1);
+              EINTRLOOP (nread, read (desc, name, name_len));
+              if (nread != name_len)
+                goto invalid;
+
+              name[name_len] = '\0';
+
+              long_name = 1;
+            }
+#endif /* Not AIAMAG. */
+        }
+
+#ifndef M_XENIX
+        sscanf (TOCHAR (member_header.ar_mode), "%o", &eltmode);
+        eltsize = atol (TOCHAR (member_header.ar_size));
+#else   /* Xenix.  */
+        eltmode = (unsigned short int) member_header.ar_mode;
+        eltsize = member_header.ar_size;
+#endif  /* Not Xenix.  */
+
+        fnval =
+          (*function) (desc, name, ! long_name, member_offset,
+                       member_offset + AR_HDR_SIZE, eltsize,
+#ifndef M_XENIX
+                       atol (TOCHAR (member_header.ar_date)),
+                       atoi (TOCHAR (member_header.ar_uid)),
+                       atoi (TOCHAR (member_header.ar_gid)),
+#else   /* Xenix.  */
+                       member_header.ar_date,
+                       member_header.ar_uid,
+                       member_header.ar_gid,
+#endif  /* Not Xenix.  */
+                       eltmode, arg);
+
+#endif  /* AIAMAG.  */
+
+        if (fnval)
+          {
+            (void) close (desc);
+            return fnval;
+          }
+
+#ifdef AIAMAG
+        if (member_offset == last_member_offset)
+          /* End of the chain.  */
+          break;
+
+#ifdef AIAMAGBIG
+        if (big_archive)
+         sscanf (member_header_big.ar_nxtmem, "%20ld", &member_offset);
+        else
+#endif
+          sscanf (member_header.ar_nxtmem, "%12ld", &member_offset);
+
+        if (lseek (desc, member_offset, 0) != member_offset)
+          goto invalid;
+#else
+
+        /* If this member maps archive names, we must read it in.  The
+           name map will always precede any members whose names must
+           be mapped.  */
+        if (is_namemap)
+          {
+            char *clear;
+            char *limit;
+
+            namemap = alloca (eltsize);
+            EINTRLOOP (nread, read (desc, namemap, eltsize));
+            if (nread != eltsize)
+              goto invalid;
+
+            /* The names are separated by newlines.  Some formats have
+               a trailing slash.  Null terminate the strings for
+               convenience.  */
+            limit = namemap + eltsize;
+            for (clear = namemap; clear < limit; clear++)
+              {
+                if (*clear == '\n')
+                  {
+                    *clear = '\0';
+                    if (clear[-1] == '/')
+                      clear[-1] = '\0';
+                  }
+              }
+
+            is_namemap = 0;
+          }
+
+        member_offset += AR_HDR_SIZE + eltsize;
+        if (member_offset % 2 != 0)
+          member_offset++;
+#endif
+      }
+  }
+
+  close (desc);
+  return 0;
+
+ invalid:
+  close (desc);
+  return -2;
+}
+#endif /* !VMS */
+
+/* Return nonzero iff NAME matches MEM.
+   If TRUNCATED is nonzero, MEM may be truncated to
+   sizeof (struct ar_hdr.ar_name) - 1.  */
+
+int
+ar_name_equal (const char *name, const char *mem, int truncated)
+{
+  const char *p;
+
+  p = strrchr (name, '/');
+  if (p != 0)
+    name = p + 1;
+
+#ifndef VMS
+  if (truncated)
+    {
+#ifdef AIAMAG
+      /* TRUNCATED should never be set on this system.  */
+      abort ();
+#else
+      struct ar_hdr hdr;
+#if !defined (__hpux) && !defined (cray)
+      return strneq (name, mem, sizeof (hdr.ar_name) - 1);
+#else
+      return strneq (name, mem, sizeof (hdr.ar_name) - 2);
+#endif /* !__hpux && !cray */
+#endif /* !AIAMAG */
+    }
+
+  return !strcmp (name, mem);
+#else
+  /* VMS members do not have suffixes, but the filenames usually
+     have.
+     Do we need to strip VMS disk/directory format paths?
+
+     Most VMS compilers etc. by default are case insensitive
+     but produce uppercase external names, incl. module names.
+     However the VMS librarian (ar) and the linker by default
+     are case sensitive: they take what they get, usually
+     uppercase names. So for the non-default settings of the
+     compilers etc. there is a need to have a case sensitive
+     mode. */
+  {
+    int len;
+    len = strlen(mem);
+    int match;
+    char *dot;
+    if ((dot=strrchr(name,'.')))
+      match = (len == dot - name) && !strncasecmp(name, mem, len);
+    else
+      match = !strcasecmp (name, mem);
+    return match;
+  }
+#endif /* !VMS */
+}
+
+#ifndef VMS
+/* ARGSUSED */
+static long int
+ar_member_pos (int desc UNUSED, const char *mem, int truncated,
+               long int hdrpos, long int datapos UNUSED, long int size UNUSED,
+               long int date UNUSED, int uid UNUSED, int gid UNUSED,
+               unsigned int mode UNUSED, const void *name)
+{
+  if (!ar_name_equal (name, mem, truncated))
+    return 0;
+  return hdrpos;
+}
+
+/* Set date of member MEMNAME in archive ARNAME to current time.
+   Returns 0 if successful,
+   -1 if file ARNAME does not exist,
+   -2 if not a valid archive,
+   -3 if other random system call error (including file read-only),
+   1 if valid but member MEMNAME does not exist.  */
+
+int
+ar_member_touch (const char *arname, const char *memname)
+{
+  long int pos = ar_scan (arname, ar_member_pos, memname);
+  int fd;
+  struct ar_hdr ar_hdr;
+  off_t o;
+  int r;
+  unsigned int ui;
+  struct stat statbuf;
+
+  if (pos < 0)
+    return (int) pos;
+  if (!pos)
+    return 1;
+
+  EINTRLOOP (fd, open (arname, O_RDWR, 0666));
+  if (fd < 0)
+    return -3;
+  /* Read in this member's header */
+  EINTRLOOP (o, lseek (fd, pos, 0));
+  if (o < 0)
+    goto lose;
+  EINTRLOOP (r, read (fd, &ar_hdr, AR_HDR_SIZE));
+  if (r != AR_HDR_SIZE)
+    goto lose;
+  /* Write back the header, thus touching the archive file.  */
+  EINTRLOOP (o, lseek (fd, pos, 0));
+  if (o < 0)
+    goto lose;
+  r = output_write (fd, &ar_hdr, AR_HDR_SIZE);
+  if (r != AR_HDR_SIZE)
+    goto lose;
+  /* The file's mtime is the time we we want.  */
+  EINTRLOOP (r, fstat (fd, &statbuf));
+  if (r < 0)
+    goto lose;
+#if defined(ARFMAG) || defined(ARFZMAG) || defined(AIAMAG) || defined(WINDOWS32)
+  /* Advance member's time to that time */
+  for (ui = 0; ui < sizeof ar_hdr.ar_date; ui++)
+    ar_hdr.ar_date[ui] = ' ';
+  sprintf (TOCHAR (ar_hdr.ar_date), "%lu", (long unsigned) statbuf.st_mtime);
+#ifdef AIAMAG
+  ar_hdr.ar_date[strlen (ar_hdr.ar_date)] = ' ';
+#endif
+#else
+  ar_hdr.ar_date = statbuf.st_mtime;
+#endif
+  /* Write back this member's header */
+  EINTRLOOP (o, lseek (fd, pos, 0));
+  if (o < 0)
+    goto lose;
+  r = output_write (fd, &ar_hdr, AR_HDR_SIZE);
+  if (r != AR_HDR_SIZE)
+    goto lose;
+  close (fd);
+  return 0;
+
+ lose:
+  r = errno;
+  close (fd);
+  errno = r;
+  return -3;
+}
+#endif
+
+#ifdef TEST
+
+long int
+describe_member (int desc, const char *name, int truncated,
+                 long int hdrpos, long int datapos, long int size,
+                 long int date, int uid, int gid, unsigned int mode,
+                 const void *arg)
+{
+  extern char *ctime ();
+
+  printf (_("Member '%s'%s: %ld bytes at %ld (%ld).\n"),
+          name, truncated ? _(" (name might be truncated)") : "",
+          size, hdrpos, datapos);
+  printf (_("  Date %s"), ctime (&date));
+  printf (_("  uid = %d, gid = %d, mode = 0%o.\n"), uid, gid, mode);
+
+  return 0;
+}
+
+int
+main (int argc, char **argv)
+{
+  ar_scan (argv[1], describe_member, NULL);
+  return 0;
+}
+
+#endif  /* TEST.  */
+#endif  /* NO_ARCHIVES.  */
diff --git a/src/commands.c b/src/commands.c
new file mode 100644
index 0000000..75a9d2d
--- /dev/null
+++ b/src/commands.c
@@ -0,0 +1,710 @@
+/* Command processing for GNU Make.
+Copyright (C) 1988-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+#include "filedef.h"
+#include "dep.h"
+#include "variable.h"
+#include "job.h"
+#include "commands.h"
+#ifdef WINDOWS32
+#include <windows.h>
+#include "w32err.h"
+#endif
+
+#if VMS
+# define FILE_LIST_SEPARATOR (vms_comma_separator ? ',' : ' ')
+#else
+# define FILE_LIST_SEPARATOR ' '
+#endif
+
+#ifndef HAVE_UNISTD_H
+int getpid ();
+#endif
+
+
+static unsigned long
+dep_hash_1 (const void *key)
+{
+  const struct dep *d = key;
+  return_STRING_HASH_1 (dep_name (d));
+}
+
+static unsigned long
+dep_hash_2 (const void *key)
+{
+  const struct dep *d = key;
+  return_STRING_HASH_2 (dep_name (d));
+}
+
+static int
+dep_hash_cmp (const void *x, const void *y)
+{
+  const struct dep *dx = x;
+  const struct dep *dy = y;
+  return strcmp (dep_name (dx), dep_name (dy));
+}
+
+/* Set FILE's automatic variables up.  */
+
+void
+set_file_variables (struct file *file)
+{
+  struct dep *d;
+  const char *at, *percent, *star, *less;
+
+#ifndef NO_ARCHIVES
+  /* If the target is an archive member 'lib(member)',
+     then $@ is 'lib' and $% is 'member'.  */
+
+  if (ar_name (file->name))
+    {
+      unsigned int len;
+      const char *cp;
+      char *p;
+
+      cp = strchr (file->name, '(');
+      p = alloca (cp - file->name + 1);
+      memcpy (p, file->name, cp - file->name);
+      p[cp - file->name] = '\0';
+      at = p;
+      len = strlen (cp + 1);
+      p = alloca (len);
+      memcpy (p, cp + 1, len - 1);
+      p[len - 1] = '\0';
+      percent = p;
+    }
+  else
+#endif  /* NO_ARCHIVES.  */
+    {
+      at = file->name;
+      percent = "";
+    }
+
+  /* $* is the stem from an implicit or static pattern rule.  */
+  if (file->stem == 0)
+    {
+      /* In Unix make, $* is set to the target name with
+         any suffix in the .SUFFIXES list stripped off for
+         explicit rules.  We store this in the 'stem' member.  */
+      const char *name;
+      unsigned int len;
+
+#ifndef NO_ARCHIVES
+      if (ar_name (file->name))
+        {
+          name = strchr (file->name, '(') + 1;
+          len = strlen (name) - 1;
+        }
+      else
+#endif
+        {
+          name = file->name;
+          len = strlen (name);
+        }
+
+      for (d = enter_file (strcache_add (".SUFFIXES"))->deps; d ; d = d->next)
+        {
+          unsigned int slen = strlen (dep_name (d));
+          if (len > slen && strneq (dep_name (d), name + (len - slen), slen))
+            {
+              file->stem = strcache_add_len (name, len - slen);
+              break;
+            }
+        }
+      if (d == 0)
+        file->stem = "";
+    }
+  star = file->stem;
+
+  /* $< is the first not order-only dependency.  */
+  less = "";
+  for (d = file->deps; d != 0; d = d->next)
+    if (!d->ignore_mtime)
+      {
+        if (!d->need_2nd_expansion)
+          less = dep_name (d);
+        break;
+      }
+
+  if (file->cmds == default_file->cmds)
+    /* This file got its commands from .DEFAULT.
+       In this case $< is the same as $@.  */
+    less = at;
+
+#define DEFINE_VARIABLE(name, len, value) \
+  (void) define_variable_for_file (name,len,value,o_automatic,0,file)
+
+  /* Define the variables.  */
+
+  DEFINE_VARIABLE ("<", 1, less);
+  DEFINE_VARIABLE ("*", 1, star);
+  DEFINE_VARIABLE ("@", 1, at);
+  DEFINE_VARIABLE ("%", 1, percent);
+
+  /* Compute the values for $^, $+, $?, and $|.  */
+
+  {
+    static char *plus_value=0, *bar_value=0, *qmark_value=0;
+    static unsigned int plus_max=0, bar_max=0, qmark_max=0;
+
+    unsigned int qmark_len, plus_len, bar_len;
+    char *cp;
+    char *caret_value;
+    char *qp;
+    char *bp;
+    unsigned int len;
+
+    struct hash_table dep_hash;
+    void **slot;
+
+    /* Compute first the value for $+, which is supposed to contain
+       duplicate dependencies as they were listed in the makefile.  */
+
+    plus_len = 0;
+    bar_len = 0;
+    for (d = file->deps; d != 0; d = d->next)
+      {
+        if (!d->need_2nd_expansion)
+          {
+            if (d->ignore_mtime)
+              bar_len += strlen (dep_name (d)) + 1;
+            else
+              plus_len += strlen (dep_name (d)) + 1;
+          }
+      }
+
+    if (bar_len == 0)
+      bar_len++;
+
+    if (plus_len == 0)
+      plus_len++;
+
+    if (plus_len > plus_max)
+      plus_value = xrealloc (plus_value, plus_max = plus_len);
+
+    cp = plus_value;
+
+    qmark_len = plus_len + 1;   /* Will be this or less.  */
+    for (d = file->deps; d != 0; d = d->next)
+      if (! d->ignore_mtime && ! d->need_2nd_expansion)
+        {
+          const char *c = dep_name (d);
+
+#ifndef NO_ARCHIVES
+          if (ar_name (c))
+            {
+              c = strchr (c, '(') + 1;
+              len = strlen (c) - 1;
+            }
+          else
+#endif
+            len = strlen (c);
+
+          memcpy (cp, c, len);
+          cp += len;
+          *cp++ = FILE_LIST_SEPARATOR;
+          if (! (d->changed || always_make_flag))
+            qmark_len -= len + 1;       /* Don't space in $? for this one.  */
+        }
+
+    /* Kill the last space and define the variable.  */
+
+    cp[cp > plus_value ? -1 : 0] = '\0';
+    DEFINE_VARIABLE ("+", 1, plus_value);
+
+    /* Compute the values for $^, $?, and $|.  */
+
+    cp = caret_value = plus_value; /* Reuse the buffer; it's big enough.  */
+
+    if (qmark_len > qmark_max)
+      qmark_value = xrealloc (qmark_value, qmark_max = qmark_len);
+    qp = qmark_value;
+
+    if (bar_len > bar_max)
+      bar_value = xrealloc (bar_value, bar_max = bar_len);
+    bp = bar_value;
+
+    /* Make sure that no dependencies are repeated in $^, $?, and $|.  It
+       would be natural to combine the next two loops but we can't do it
+       because of a situation where we have two dep entries, the first
+       is order-only and the second is normal (see below).  */
+
+    hash_init (&dep_hash, 500, dep_hash_1, dep_hash_2, dep_hash_cmp);
+
+    for (d = file->deps; d != 0; d = d->next)
+      {
+        if (d->need_2nd_expansion)
+          continue;
+
+        slot = hash_find_slot (&dep_hash, d);
+        if (HASH_VACANT (*slot))
+          hash_insert_at (&dep_hash, d, slot);
+        else
+          {
+            /* Check if the two prerequisites have different ignore_mtime.
+               If so then we need to "upgrade" one that is order-only.  */
+
+            struct dep* hd = (struct dep*) *slot;
+
+            if (d->ignore_mtime != hd->ignore_mtime)
+              d->ignore_mtime = hd->ignore_mtime = 0;
+          }
+      }
+
+    for (d = file->deps; d != 0; d = d->next)
+      {
+        const char *c;
+
+        if (d->need_2nd_expansion || hash_find_item (&dep_hash, d) != d)
+          continue;
+
+        c = dep_name (d);
+#ifndef NO_ARCHIVES
+        if (ar_name (c))
+          {
+            c = strchr (c, '(') + 1;
+            len = strlen (c) - 1;
+          }
+        else
+#endif
+          len = strlen (c);
+
+        if (d->ignore_mtime)
+          {
+            memcpy (bp, c, len);
+            bp += len;
+            *bp++ = FILE_LIST_SEPARATOR;
+          }
+        else
+          {
+            memcpy (cp, c, len);
+            cp += len;
+            *cp++ = FILE_LIST_SEPARATOR;
+            if (d->changed || always_make_flag)
+              {
+                memcpy (qp, c, len);
+                qp += len;
+                *qp++ = FILE_LIST_SEPARATOR;
+              }
+          }
+      }
+
+    hash_free (&dep_hash, 0);
+
+    /* Kill the last spaces and define the variables.  */
+
+    cp[cp > caret_value ? -1 : 0] = '\0';
+    DEFINE_VARIABLE ("^", 1, caret_value);
+
+    qp[qp > qmark_value ? -1 : 0] = '\0';
+    DEFINE_VARIABLE ("?", 1, qmark_value);
+
+    bp[bp > bar_value ? -1 : 0] = '\0';
+    DEFINE_VARIABLE ("|", 1, bar_value);
+  }
+
+#undef  DEFINE_VARIABLE
+}
+
+/* Chop CMDS up into individual command lines if necessary.
+   Also set the 'lines_flags' and 'any_recurse' members.  */
+
+void
+chop_commands (struct commands *cmds)
+{
+  unsigned int nlines, idx;
+  char **lines;
+
+  /* If we don't have any commands,
+     or we already parsed them, never mind.  */
+
+  if (!cmds || cmds->command_lines != 0)
+    return;
+
+  /* Chop CMDS->commands up into lines in CMDS->command_lines.  */
+
+  if (one_shell)
+    {
+      int l = strlen (cmds->commands);
+
+      nlines = 1;
+      lines = xmalloc (nlines * sizeof (char *));
+      lines[0] = xstrdup (cmds->commands);
+
+      /* Strip the trailing newline.  */
+      if (l > 0 && lines[0][l-1] == '\n')
+        lines[0][l-1] = '\0';
+    }
+  else
+    {
+      const char *p;
+
+      nlines = 5;
+      lines = xmalloc (nlines * sizeof (char *));
+      idx = 0;
+      p = cmds->commands;
+      while (*p != '\0')
+        {
+          const char *end = p;
+        find_end:;
+          end = strchr (end, '\n');
+          if (end == 0)
+            end = p + strlen (p);
+          else if (end > p && end[-1] == '\\')
+            {
+              int backslash = 1;
+              const char *b;
+              for (b = end - 2; b >= p && *b == '\\'; --b)
+                backslash = !backslash;
+              if (backslash)
+                {
+                  ++end;
+                  goto find_end;
+                }
+            }
+
+          if (idx == nlines)
+            {
+              nlines += 2;
+              lines = xrealloc (lines, nlines * sizeof (char *));
+            }
+          lines[idx++] = xstrndup (p, end - p);
+          p = end;
+          if (*p != '\0')
+            ++p;
+        }
+
+      if (idx != nlines)
+        {
+          nlines = idx;
+          lines = xrealloc (lines, nlines * sizeof (char *));
+        }
+    }
+
+  /* Finally, set the corresponding CMDS->lines_flags elements and the
+     CMDS->any_recurse flag.  */
+
+  if (nlines > USHRT_MAX)
+    ON (fatal, &cmds->fileinfo, _("Recipe has too many lines (%ud)"), nlines);
+
+  cmds->ncommand_lines = nlines;
+  cmds->command_lines = lines;
+
+  cmds->any_recurse = 0;
+  cmds->lines_flags = xmalloc (nlines);
+
+  for (idx = 0; idx < nlines; ++idx)
+    {
+      unsigned char flags = 0;
+      const char *p = lines[idx];
+
+      while (ISBLANK (*p) || *p == '-' || *p == '@' || *p == '+')
+        switch (*(p++))
+          {
+          case '+':
+            flags |= COMMANDS_RECURSE;
+            break;
+          case '@':
+            flags |= COMMANDS_SILENT;
+            break;
+          case '-':
+            flags |= COMMANDS_NOERROR;
+            break;
+          }
+
+      /* If no explicit '+' was given, look for MAKE variable references.  */
+      if (!(flags & COMMANDS_RECURSE)
+          && (strstr (p, "$(MAKE)") != 0 || strstr (p, "${MAKE}") != 0))
+        flags |= COMMANDS_RECURSE;
+
+      cmds->lines_flags[idx] = flags;
+      cmds->any_recurse |= flags & COMMANDS_RECURSE ? 1 : 0;
+    }
+}
+
+/* Execute the commands to remake FILE.  If they are currently executing,
+   return or have already finished executing, just return.  Otherwise,
+   fork off a child process to run the first command line in the sequence.  */
+
+void
+execute_file_commands (struct file *file)
+{
+  const char *p;
+
+  /* Don't go through all the preparations if
+     the commands are nothing but whitespace.  */
+
+  for (p = file->cmds->commands; *p != '\0'; ++p)
+    if (!ISSPACE (*p) && *p != '-' && *p != '@' && *p != '+')
+      break;
+  if (*p == '\0')
+    {
+      /* If there are no commands, assume everything worked.  */
+      set_command_state (file, cs_running);
+      file->update_status = us_success;
+      notice_finished_file (file);
+      return;
+    }
+
+  /* First set the automatic variables according to this file.  */
+
+  initialize_file_variables (file, 0);
+
+  set_file_variables (file);
+
+  /* If this is a loaded dynamic object, unload it before remaking.
+     Some systems don't support overwriting a loaded object.  */
+  if (file->loaded)
+    unload_file (file->name);
+
+  /* Start the commands running.  */
+  new_job (file);
+}
+
+/* This is set while we are inside fatal_error_signal,
+   so things can avoid nonreentrant operations.  */
+
+int handling_fatal_signal = 0;
+
+/* Handle fatal signals.  */
+
+RETSIGTYPE
+fatal_error_signal (int sig)
+{
+#ifdef __MSDOS__
+  extern int dos_status, dos_command_running;
+
+  if (dos_command_running)
+    {
+      /* That was the child who got the signal, not us.  */
+      dos_status |= (sig << 8);
+      return;
+    }
+  remove_intermediates (1);
+  exit (EXIT_FAILURE);
+#else /* not __MSDOS__ */
+#ifdef _AMIGA
+  remove_intermediates (1);
+  if (sig == SIGINT)
+     fputs (_("*** Break.\n"), stderr);
+
+  exit (10);
+#else /* not Amiga */
+#ifdef WINDOWS32
+  extern HANDLE main_thread;
+
+  /* Windows creates a sperate thread for handling Ctrl+C, so we need
+     to suspend the main thread, or else we will have race conditions
+     when both threads call reap_children.  */
+  if (main_thread)
+    {
+      DWORD susp_count = SuspendThread (main_thread);
+
+      if (susp_count != 0)
+        fprintf (stderr, "SuspendThread: suspend count = %ld\n", susp_count);
+      else if (susp_count == (DWORD)-1)
+        {
+          DWORD ierr = GetLastError ();
+
+          fprintf (stderr, "SuspendThread: error %ld: %s\n",
+                   ierr, map_windows32_error_to_string (ierr));
+        }
+    }
+#endif
+  handling_fatal_signal = 1;
+
+  /* Set the handling for this signal to the default.
+     It is blocked now while we run this handler.  */
+  signal (sig, SIG_DFL);
+
+  /* A termination signal won't be sent to the entire
+     process group, but it means we want to kill the children.  */
+
+  if (sig == SIGTERM)
+    {
+      struct child *c;
+      for (c = children; c != 0; c = c->next)
+        if (!c->remote)
+          (void) kill (c->pid, SIGTERM);
+    }
+
+  /* If we got a signal that means the user
+     wanted to kill make, remove pending targets.  */
+
+  if (sig == SIGTERM || sig == SIGINT
+#ifdef SIGHUP
+    || sig == SIGHUP
+#endif
+#ifdef SIGQUIT
+    || sig == SIGQUIT
+#endif
+    )
+    {
+      struct child *c;
+
+      /* Remote children won't automatically get signals sent
+         to the process group, so we must send them.  */
+      for (c = children; c != 0; c = c->next)
+        if (c->remote)
+          (void) remote_kill (c->pid, sig);
+
+      for (c = children; c != 0; c = c->next)
+        delete_child_targets (c);
+
+      /* Clean up the children.  We don't just use the call below because
+         we don't want to print the "Waiting for children" message.  */
+      while (job_slots_used > 0)
+        reap_children (1, 0);
+    }
+  else
+    /* Wait for our children to die.  */
+    while (job_slots_used > 0)
+      reap_children (1, 1);
+
+  /* Delete any non-precious intermediate files that were made.  */
+
+  remove_intermediates (1);
+
+#ifdef SIGQUIT
+  if (sig == SIGQUIT)
+    /* We don't want to send ourselves SIGQUIT, because it will
+       cause a core dump.  Just exit instead.  */
+    exit (MAKE_TROUBLE);
+#endif
+
+#ifdef WINDOWS32
+  if (main_thread)
+    CloseHandle (main_thread);
+  /* Cannot call W32_kill with a pid (it needs a handle).  The exit
+     status of 130 emulates what happens in Bash.  */
+  exit (130);
+#else
+  /* Signal the same code; this time it will really be fatal.  The signal
+     will be unblocked when we return and arrive then to kill us.  */
+  if (kill (getpid (), sig) < 0)
+    pfatal_with_name ("kill");
+#endif /* not WINDOWS32 */
+#endif /* not Amiga */
+#endif /* not __MSDOS__  */
+}
+
+/* Delete FILE unless it's precious or not actually a file (phony),
+   and it has changed on disk since we last stat'd it.  */
+
+static void
+delete_target (struct file *file, const char *on_behalf_of)
+{
+  struct stat st;
+  int e;
+
+  if (file->precious || file->phony)
+    return;
+
+#ifndef NO_ARCHIVES
+  if (ar_name (file->name))
+    {
+      time_t file_date = (file->last_mtime == NONEXISTENT_MTIME
+                          ? (time_t) -1
+                          : (time_t) FILE_TIMESTAMP_S (file->last_mtime));
+      if (ar_member_date (file->name) != file_date)
+        {
+          if (on_behalf_of)
+            OSS (error, NILF,
+                 _("*** [%s] Archive member '%s' may be bogus; not deleted"),
+                 on_behalf_of, file->name);
+          else
+            OS (error, NILF,
+                _("*** Archive member '%s' may be bogus; not deleted"),
+                file->name);
+        }
+      return;
+    }
+#endif
+
+  EINTRLOOP (e, stat (file->name, &st));
+  if (e == 0
+      && S_ISREG (st.st_mode)
+      && FILE_TIMESTAMP_STAT_MODTIME (file->name, st) != file->last_mtime)
+    {
+      if (on_behalf_of)
+        OSS (error, NILF,
+             _("*** [%s] Deleting file '%s'"), on_behalf_of, file->name);
+      else
+        OS (error, NILF, _("*** Deleting file '%s'"), file->name);
+      if (unlink (file->name) < 0
+          && errno != ENOENT)   /* It disappeared; so what.  */
+        perror_with_name ("unlink: ", file->name);
+    }
+}
+
+
+/* Delete all non-precious targets of CHILD unless they were already deleted.
+   Set the flag in CHILD to say they've been deleted.  */
+
+void
+delete_child_targets (struct child *child)
+{
+  struct dep *d;
+
+  if (child->deleted)
+    return;
+
+  /* Delete the target file if it changed.  */
+  delete_target (child->file, NULL);
+
+  /* Also remove any non-precious targets listed in the 'also_make' member.  */
+  for (d = child->file->also_make; d != 0; d = d->next)
+    delete_target (d->file, child->file->name);
+
+  child->deleted = 1;
+}
+
+/* Print out the commands in CMDS.  */
+
+void
+print_commands (const struct commands *cmds)
+{
+  const char *s;
+
+  fputs (_("#  recipe to execute"), stdout);
+
+  if (cmds->fileinfo.filenm == 0)
+    puts (_(" (built-in):"));
+  else
+    printf (_(" (from '%s', line %lu):\n"),
+            cmds->fileinfo.filenm, cmds->fileinfo.lineno);
+
+  s = cmds->commands;
+  while (*s != '\0')
+    {
+      const char *end;
+      int bs;
+
+      /* Print one full logical recipe line: find a non-escaped newline.  */
+      for (end = s, bs = 0; *end != '\0'; ++end)
+        {
+          if (*end == '\n' && !bs)
+            break;
+
+          bs = *end == '\\' ? !bs : 0;
+        }
+
+      printf ("%c%.*s\n", cmd_prefix, (int) (end - s), s);
+
+      s = end + (end[0] == '\n');
+    }
+}
diff --git a/src/commands.h b/src/commands.h
new file mode 100644
index 0000000..5983829
--- /dev/null
+++ b/src/commands.h
@@ -0,0 +1,42 @@
+/* Definition of data structures describing shell commands for GNU Make.
+Copyright (C) 1988-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Structure that gives the commands to make a file
+   and information about where these commands came from.  */
+
+struct commands
+  {
+    floc fileinfo;              /* Where commands were defined.  */
+    char *commands;             /* Commands text.  */
+    char **command_lines;       /* Commands chopped up into lines.  */
+    unsigned char *lines_flags; /* One set of flag bits for each line.  */
+    unsigned short ncommand_lines;/* Number of command lines.  */
+    char recipe_prefix;         /* Recipe prefix for this command set.  */
+    unsigned int any_recurse:1; /* Nonzero if any 'lines_flags' elt has */
+                                /* the COMMANDS_RECURSE bit set.  */
+  };
+
+/* Bits in 'lines_flags'.  */
+#define COMMANDS_RECURSE        1 /* Recurses: + or $(MAKE).  */
+#define COMMANDS_SILENT         2 /* Silent: @.  */
+#define COMMANDS_NOERROR        4 /* No errors: -.  */
+
+RETSIGTYPE fatal_error_signal (int sig);
+void execute_file_commands (struct file *file);
+void print_commands (const struct commands *cmds);
+void delete_child_targets (struct child *child);
+void chop_commands (struct commands *cmds);
+void set_file_variables (struct file *file);
diff --git a/src/config.ami.template b/src/config.ami.template
new file mode 100644
index 0000000..8141f0d
--- /dev/null
+++ b/src/config.ami.template
@@ -0,0 +1,340 @@
+/* config.h -- hand-massaged for Amiga                                  -*-C-*-
+Copyright (C) 1995-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Define if on AIX 3.
+   System headers sometimes define this.
+   We just want to avoid a redefinition error message.  */
+#ifndef _ALL_SOURCE
+/* #undef _ALL_SOURCE */
+#endif
+
+/* Define if using alloca.c.  */
+#define C_ALLOCA
+
+/* Define if the closedir function returns void instead of int.  */
+/* #undef CLOSEDIR_VOID */
+
+/* Define to empty if the keyword does not work.  */
+/* #undef const */
+
+/* Define to one of _getb67, GETB67, getb67 for Cray-2 and Cray-YMP systems.
+   This function is required for alloca.c support on those systems.  */
+/* #undef CRAY_STACKSEG_END */
+
+/* Define for DGUX with <sys/dg_sys_info.h>.  */
+/* #undef DGUX */
+
+/* Define if the 'getloadavg' function needs to be run setuid or setgid.  */
+/* #undef GETLOADAVG_PRIVILEGED */
+
+/* Define to 'unsigned long' or 'unsigned long long'
+   if <inttypes.h> doesn't define.  */
+#define uintmax_t unsigned long
+
+/* Define to 'int' if <sys/types.h> doesn't define.  */
+#define gid_t int
+
+/* Define if you have alloca, as a function or macro.  */
+/* #undef HAVE_ALLOCA */
+
+/* Define if you have <alloca.h> and it should be used (not on Ultrix).  */
+/* #undef HAVE_ALLOCA_H */
+
+/* Define if your system has a working fnmatch function.  */
+/* #undef HAVE_FNMATCH */
+
+/* Define if your system has its own 'getloadavg' function.  */
+/* #undef HAVE_GETLOADAVG */
+
+/* Define if you have the getmntent function.  */
+/* #undef HAVE_GETMNTENT */
+
+/* Embed GNU Guile support */
+/* #undef HAVE_GUILE */
+
+/* Define if the 'long double' type works.  */
+/* #undef HAVE_LONG_DOUBLE */
+
+/* Define if you support file names longer than 14 characters.  */
+#define HAVE_LONG_FILE_NAMES 1
+
+/* Define if you have a working 'mmap' system call.  */
+/* #undef HAVE_MMAP */
+
+/* Define if system calls automatically restart after interruption
+   by a signal.  */
+/* #undef HAVE_RESTARTABLE_SYSCALLS */
+
+/* Define if your struct stat has st_blksize.  */
+/* #undef HAVE_ST_BLKSIZE */
+
+/* Define if your struct stat has st_blocks.  */
+/* #undef HAVE_ST_BLOCKS */
+
+/* Define if you have the strcoll function and it is properly defined.  */
+#define HAVE_STRCOLL 1
+
+/* Define if your struct stat has st_rdev.  */
+#define HAVE_ST_RDEV 1
+
+/* Define if you have the strftime function.  */
+#define HAVE_STRFTIME 1
+
+/* Define if you have <sys/wait.h> that is POSIX.1 compatible.  */
+/* #undef HAVE_SYS_WAIT_H */
+
+/* Define if your struct tm has tm_zone.  */
+/* #undef HAVE_TM_ZONE */
+
+/* Define if you don't have tm_zone but do have the external array
+   tzname.  */
+#define HAVE_TZNAME 1
+
+/* Define if you have <unistd.h>.  */
+#define HAVE_UNISTD_H 1
+
+/* Define if utime(file, NULL) sets file's timestamp to the present.  */
+/* #undef HAVE_UTIME_NULL */
+
+/* Define if you have the wait3 system call.  */
+/* #undef HAVE_WAIT3 */
+
+/* Define if on MINIX.  */
+/* #undef _MINIX */
+
+/* Define if your struct nlist has an n_un member.  */
+/* #undef NLIST_NAME_UNION */
+
+/* Define if you have <nlist.h>.  */
+/* #undef NLIST_STRUCT */
+
+/* Define if your C compiler doesn't accept -c and -o together.  */
+/* #undef NO_MINUS_C_MINUS_O */
+
+/* Define to 'int' if <sys/types.h> doesn't define.  */
+#define pid_t int
+
+/* Define if the system does not provide POSIX.1 features except
+   with this defined.  */
+/* #undef _POSIX_1_SOURCE */
+
+/* Define if you need to in order for stat and other things to work.  */
+/* #undef _POSIX_SOURCE */
+
+/* Define as the return type of signal handlers (int or void).  */
+#define RETSIGTYPE void
+
+/* Define if the setvbuf function takes the buffering type as its second
+   argument and the buffer pointer as the third, as on System V
+   before release 3.  */
+/* #undef SETVBUF_REVERSED */
+
+/* If using the C implementation of alloca, define if you know the
+   direction of stack growth for your system; otherwise it will be
+   automatically deduced at run-time.
+        STACK_DIRECTION > 0 => grows toward higher addresses
+        STACK_DIRECTION < 0 => grows toward lower addresses
+        STACK_DIRECTION = 0 => direction of growth unknown
+ */
+#define STACK_DIRECTION -1
+
+/* Define if the 'S_IS*' macros in <sys/stat.h> do not work properly.  */
+/* #undef STAT_MACROS_BROKEN */
+
+/* Define if you have the ANSI C header files.  */
+#define STDC_HEADERS
+
+/* Define on System V Release 4.  */
+/* #undef SVR4 */
+
+/* Define if 'sys_siglist' is declared by <signal.h>.  */
+/* #undef SYS_SIGLIST_DECLARED */
+
+/* Define to 'int' if <sys/types.h> doesn't define.  */
+#define uid_t int
+
+/* Define for Encore UMAX.  */
+/* #undef UMAX */
+
+/* Define for Encore UMAX 4.3 that has <inq_status/cpustats.h>
+   instead of <sys/cpustats.h>.  */
+/* #undef UMAX4_3 */
+
+/* Name of this package (needed by automake) */
+#define PACKAGE "%PACKAGE%"
+
+/* Version of this package (needed by automake) */
+#define VERSION "%VERSION%"
+
+/* Define to the name of the SCCS 'get' command.  */
+#define SCCS_GET "get"
+
+/* Define this if the SCCS 'get' command understands the '-G<file>' option.  */
+/* #undef SCCS_GET_MINUS_G */
+
+/* Define this to enable job server support in GNU make.  */
+/* #undef MAKE_JOBSERVER */
+
+/* Define to be the nanoseconds member of struct stat's st_mtim,
+   if it exists.  */
+/* #undef ST_MTIM_NSEC */
+
+/* Define this if the C library defines the variable 'sys_siglist'.  */
+/* #undef HAVE_SYS_SIGLIST */
+
+/* Define this if the C library defines the variable '_sys_siglist'.  */
+/* #undef HAVE__SYS_SIGLIST */
+
+/* Define this if you have the 'union wait' type in <sys/wait.h>.  */
+/* #undef HAVE_UNION_WAIT */
+
+/* Define if you have the dup2 function.  */
+/* #undef HAVE_DUP2 */
+
+/* Define if you have the getcwd function.  */
+#define HAVE_GETCWD 1
+
+/* Define if you have the getgroups function.  */
+/* #undef HAVE_GETGROUPS */
+
+/* Define if you have the gethostbyname function.  */
+/* #undef HAVE_GETHOSTBYNAME */
+
+/* Define if you have the gethostname function.  */
+/* #undef HAVE_GETHOSTNAME */
+
+/* Define if you have the memmove function.  */
+#define HAVE_MEMMOVE 1
+
+/* Define if you have the mktemp function.  */
+#define HAVE_MKTEMP 1
+
+/* Define if you have the psignal function.  */
+/* #undef HAVE_PSIGNAL */
+
+/* Define if you have the pstat_getdynamic function.  */
+/* #undef HAVE_PSTAT_GETDYNAMIC */
+
+/* Define if you have the setegid function.  */
+/* #undef HAVE_SETEGID */
+
+/* Define if you have the seteuid function.  */
+/* #undef HAVE_SETEUID */
+
+/* Define if you have the setlinebuf function.  */
+/* #undef HAVE_SETLINEBUF */
+
+/* Define if you have the setregid function.  */
+/* #undef HAVE_SETREGID */
+
+/* Define if you have the setreuid function.  */
+/* #undef HAVE_SETREUID */
+
+/* Define if you have the sigsetmask function.  */
+/* #undef HAVE_SIGSETMASK */
+
+/* Define if you have the socket function.  */
+/* #undef HAVE_SOCKET */
+
+/* Define to 1 if you have the strcasecmp function.  */
+/* #undef HAVE_STRCASECMP */
+
+/* Define to 1 if you have the strcmpi function.  */
+/* #undef HAVE_STRCMPI */
+
+/* Define to 1 if you have the stricmp function.  */
+/* #undef HAVE_STRICMP */
+
+/* Define if you have the strerror function.  */
+#define HAVE_STRERROR 1
+
+/* Define if you have the strsignal function.  */
+/* #undef HAVE_STRSIGNAL */
+
+/* Define if you have the wait3 function.  */
+/* #undef HAVE_WAIT3 */
+
+/* Define if you have the waitpid function.  */
+/* #undef HAVE_WAITPID */
+
+/* Define if you have the <dirent.h> header file.  */
+#define HAVE_DIRENT_H 1
+
+/* Define if you have the <fcntl.h> header file.  */
+#define HAVE_FCNTL_H 1
+
+/* Define if you have the <limits.h> header file.  */
+#define HAVE_LIMITS_H 1
+
+/* Define if you have the <mach/mach.h> header file.  */
+/* #undef HAVE_MACH_MACH_H */
+
+/* Define if you have the <memory.h> header file.  */
+/* #undef HAVE_MEMORY_H */
+
+/* Define if you have the <ndir.h> header file.  */
+/* #undef HAVE_NDIR_H */
+
+/* Define if you have the <stdlib.h> header file.  */
+/* #undef HAVE_STDLIB_H */
+
+/* Define if you have the <string.h> header file.  */
+#define HAVE_STRING_H 1
+
+/* Define if you have the <sys/dir.h> header file.  */
+#define HAVE_SYS_DIR_H 1
+
+/* Define if you have the <sys/ndir.h> header file.  */
+/* #undef HAVE_SYS_NDIR_H */
+
+/* Define if you have the <sys/param.h> header file.  */
+/* #undef HAVE_SYS_PARAM_H */
+
+/* Define if you have the <sys/timeb.h> header file.  */
+/* #undef HAVE_SYS_TIMEB_H */
+
+/* Define if you have the <sys/wait.h> header file.  */
+/* #undef HAVE_SYS_WAIT_H */
+
+/* Define if you have the <unistd.h> header file.  */
+#define HAVE_UNISTD_H 1
+
+/* Define if you have the dgc library (-ldgc).  */
+/* #undef HAVE_LIBDGC */
+
+/* Define if you have the kstat library (-lkstat).  */
+/* #undef HAVE_LIBKSTAT */
+
+/* Define to 1 if you have the `isatty' function. */
+/* #undef HAVE_ISATTY */
+
+/* Define to 1 if you have the `ttyname' function. */
+/* #undef HAVE_TTYNAME */
+
+/* Define if you have the sun library (-lsun).  */
+/* #undef HAVE_LIBSUN */
+
+/* Output sync sypport */
+#define NO_OUTPUT_SYNC
+
+/* Define for Case Insensitve behavior */
+#define HAVE_CASE_INSENSITIVE_FS
+
+/* Build host information. */
+#define MAKE_HOST "Amiga"
+
+/* Define to `int' if <sys/types.h> does not define. */
+#define ssize_t int
diff --git a/src/config.h-vms.template b/src/config.h-vms.template
new file mode 100644
index 0000000..3cb9a74
--- /dev/null
+++ b/src/config.h-vms.template
@@ -0,0 +1,436 @@
+/* config.h-vms. Generated by hand by Klaus Kmpf <kkaempf@rmi.de>      -*-C-*-
+
+Copyright (C) 1996-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* config.h.  Generated automatically by configure.  */
+/* config.h.in.  Generated automatically from configure.ac by autoheader.  */
+
+/* Pull in types.h here to get __CRTL_VER defined for old versions of the
+   compiler which don't define it. */
+#ifdef __DECC
+# include <types.h>
+#endif
+
+/* Define to 1 if on AIX 3.
+   System headers sometimes define this.
+   We just want to avoid a redefinition error message.  */
+#ifndef _ALL_SOURCE
+/* #undef _ALL_SOURCE */
+#endif
+
+/* Define to 1 if NLS is requested.  */
+/* #undef ENABLE_NLS */
+
+/* Define as 1 if you have dcgettext.  */
+/* #undef HAVE_DCGETTEXT */
+
+/* Define as 1 if you have gettext and don't want to use GNU gettext.  */
+/* #undef HAVE_GETTEXT */
+
+/* Embed GNU Guile support */
+/* #undef HAVE_GUILE */
+
+/* Define to 1 if your locale.h file contains LC_MESSAGES.  */
+/* #undef HAVE_LC_MESSAGES */
+
+/* Define to the installation directory for locales.  */
+#define LOCALEDIR ""
+
+/* Define as 1 if you have the stpcpy function.  */
+/* #undef HAVE_STPCPY */
+
+/* Define to 1 if the closedir function returns void instead of int.  */
+/* #undef CLOSEDIR_VOID */
+
+/* Define to empty if the keyword does not work.  */
+/* #undef const */
+
+/* Define to one of _getb67, GETB67, getb67 for Cray-2 and Cray-YMP systems.
+   This function is required for alloca.c support on those systems.  */
+/* #undef CRAY_STACKSEG_END */
+
+/* Define for DGUX with <sys/dg_sys_info.h>.  */
+/* #undef DGUX */
+
+/* Define to 1 if the 'getloadavg' function needs to be run setuid or setgid.  */
+/* #undef GETLOADAVG_PRIVILEGED */
+
+/* Define to 'unsigned long' or 'unsigned long long'
+   if <inttypes.h> doesn't define.  */
+#define uintmax_t unsigned long
+
+/* Define to 'int' if <sys/types.h> doesn't define.  */
+/* #undef gid_t */
+
+/* Define to 1 if you have alloca, as a function or macro.  */
+#define HAVE_ALLOCA 1
+
+/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).  */
+/* #undef HAVE_ALLOCA_H */
+
+/* Define to 1 if you have the fdopen function.  */
+#define HAVE_FDOPEN 1
+
+/* Define to 1 if your system has a working fnmatch function.  */
+/* #undef HAVE_FNMATCH */
+
+/* Define to 1 if your system has its own 'getloadavg' function.  */
+/* #undef HAVE_GETLOADAVG */
+
+/* Define to 1 if you have the getmntent function.  */
+/* #undef HAVE_GETMNTENT */
+
+/* Define to 1 if the 'long double' type works.  */
+/* #undef HAVE_LONG_DOUBLE */
+
+/* Define to 1 if you support file names longer than 14 characters.  */
+#define HAVE_LONG_FILE_NAMES 1
+
+/* Define to 1 if you have a working 'mmap' system call.  */
+/* #undef HAVE_MMAP */
+
+/* Define to 1 if system calls automatically restart after interruption
+   by a signal.  */
+/* #undef HAVE_RESTARTABLE_SYSCALLS */
+
+/* Define to 1 if your struct stat has st_blksize.  */
+/* #undef HAVE_ST_BLKSIZE */
+
+/* Define to 1 if your struct stat has st_blocks.  */
+/* #undef HAVE_ST_BLOCKS */
+
+/* Define to 1 if you have the strcoll function and it is properly defined.  */
+/* #undef HAVE_STRCOLL */
+
+/* Define to 1 if you have the strncasecmp' function. */
+#if __CRTL_VER >= 70000000
+#define HAVE_STRNCASECMP 1
+#endif
+
+/* Define to 1 if your struct stat has st_rdev.  */
+/* #undef HAVE_ST_RDEV */
+
+/* Define to 1 if you have the strftime function.  */
+/* #undef HAVE_STRFTIME */
+
+/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible.  */
+/* #undef HAVE_SYS_WAIT_H */
+
+/* Define to 1 if your struct tm has tm_zone.  */
+/* #undef HAVE_TM_ZONE */
+
+/* Define to 1 if you don't have tm_zone but do have the external array
+   tzname.  */
+/* #undef HAVE_TZNAME */
+
+/* Define to 1 if you have <unistd.h>.  */
+#ifdef __DECC
+#define HAVE_UNISTD_H 1
+#endif
+
+/* Define to 1 if utime(file, NULL) sets file's timestamp to the present.  */
+/* #undef HAVE_UTIME_NULL */
+
+/* Define to 1 if you have the wait3 system call.  */
+/* #undef HAVE_WAIT3 */
+
+/* Define to 1 if on MINIX.  */
+/* #undef _MINIX */
+
+/* Define to 1 if your struct nlist has an n_un member.  */
+/* #undef NLIST_NAME_UNION */
+
+/* Define to 1 if you have <nlist.h>.  */
+/* #undef NLIST_STRUCT */
+
+/* Define to 1 if your C compiler doesn't accept -c and -o together.  */
+/* #undef NO_MINUS_C_MINUS_O */
+
+/* Define to 'int' if <sys/types.h> doesn't define.  */
+/* I assume types.h is available for all 5.0 cc/cxx compilers */
+#if __DECC_VER < 50090000
+#define pid_t int
+#endif
+
+/* Define to 1 if the system does not provide POSIX.1 features except
+   with this defined.  */
+/* #undef _POSIX_1_SOURCE */
+
+/* Define to 1 if you need to in order for stat and other things to work.  */
+/* #undef _POSIX_SOURCE */
+
+/* Define as the return type of signal handlers (int or void).  */
+#define RETSIGTYPE void
+
+/* Define to 1 if the setvbuf function takes the buffering type as its second
+   argument and the buffer pointer as the third, as on System V
+   before release 3.  */
+/* #undef SETVBUF_REVERSED */
+
+/* If using the C implementation of alloca, define if you know the
+   direction of stack growth for your system; otherwise it will be
+   automatically deduced at run-time.
+        STACK_DIRECTION > 0 => grows toward higher addresses
+        STACK_DIRECTION < 0 => grows toward lower addresses
+        STACK_DIRECTION = 0 => direction of growth unknown
+ */
+/* #undef STACK_DIRECTION */
+
+/* Define to 1 if the 'S_IS*' macros in <sys/stat.h> do not work properly.  */
+/* #undef STAT_MACROS_BROKEN */
+
+/* Define to 1 if you have the ANSI C header files.  */
+/* #undef STDC_HEADERS */
+
+/* Define on System V Release 4.  */
+/* #undef SVR4 */
+
+/* Define to 1 if 'sys_siglist' is declared by <signal.h>.  */
+/* #undef SYS_SIGLIST_DECLARED */
+
+/* Define to 'int' if <sys/types.h> doesn't define.  */
+#if __DECC_VER < 50090000
+#define uid_t int
+#endif
+
+/* Define for Encore UMAX.  */
+/* #undef UMAX */
+
+/* Define for Encore UMAX 4.3 that has <inq_status/cpustats.h>
+   instead of <sys/cpustats.h>.  */
+/* #undef UMAX4_3 */
+
+/* Name of this package (needed by automake) */
+#define PACKAGE "%PACKAGE%"
+
+/* Version of this package (needed by automake) */
+#define VERSION "%VERSION%"
+
+/* Define to the name of the SCCS 'get' command.  */
+/* #undef SCCS_GET */
+
+/* Define this if the SCCS 'get' command understands the '-G<file>' option.  */
+/* #undef SCCS_GET_MINUS_G */
+
+/* Define this to enable job server support in GNU make.  */
+/* #undef MAKE_JOBSERVER */
+
+/* Define to be the nanoseconds member of struct stat's st_mtim,
+   if it exists.  */
+/* #undef ST_MTIM_NSEC */
+
+/* Define to 1 if the C library defines the variable 'sys_siglist'.  */
+/* #undefine HAVE_SYS_SIGLIST */
+
+/* Define to 1 if the C library defines the variable '_sys_siglist'.  */
+/* #undef HAVE__SYS_SIGLIST */
+
+/* Define to 1 if you have the 'union wait' type in <sys/wait.h>.  */
+/* #undef HAVE_UNION_WAIT */
+
+/* Define to 1 if you have the dup2 function.  */
+#define HAVE_DUP2 1
+
+/* Define to 1 if you have the getcwd function.  */
+#define HAVE_GETCWD 1
+
+/* Define to 1 if you have the getgroups function.  */
+/* #undef HAVE_GETGROUPS */
+
+/* Define to 1 if you have the gethostbyname function.  */
+/* #undef HAVE_GETHOSTBYNAME */
+
+/* Define to 1 if you have the gethostname function.  */
+/* #undef HAVE_GETHOSTNAME */
+
+/* Define to 1 if you have the memmove function.  */
+#define HAVE_MEMMOVE 1
+
+/* Define to 1 if you have the mktemp function.  */
+#define HAVE_MKTEMP 1
+
+/* Define to 1 if you have the psignal function.  */
+/* #undef HAVE_PSIGNAL */
+
+/* Define to 1 if you have the pstat_getdynamic function.  */
+/* #undef HAVE_PSTAT_GETDYNAMIC */
+
+/* Define to 1 if you have the setegid function.  */
+/* #undef HAVE_SETEGID */
+
+/* Define to 1 if you have the seteuid function.  */
+/* #undef HAVE_SETEUID */
+
+/* Define to 1 if you have the setlinebuf function.  */
+/* #undef HAVE_SETLINEBUF */
+
+/* Define to 1 if you have the setregid function.  */
+/* #undefine HAVE_SETREGID */
+
+/* Define to 1 if you have the setreuid function.  */
+/* #define HAVE_SETREUID */
+
+/* Define to 1 if you have the sigsetmask function.  */
+#define HAVE_SIGSETMASK 1
+
+/* Define to 1 if you have the socket function.  */
+/* #undef HAVE_SOCKET */
+
+/* Define to 1 if you have the strcasecmp function.  */
+#define HAVE_STRCASECMP 1
+
+/* Define to 1 if you have the strcmpi function.  */
+/* #undef HAVE_STRCMPI */
+
+/* Define to 1 if you have the stricmp function.  */
+/* #undef HAVE_STRICMP */
+
+/* Define to 1 if you have the strerror function.  */
+#define HAVE_STRERROR 1
+
+/* Define to 1 if you have the strsignal function.  */
+/* #undef HAVE_STRSIGNAL */
+
+/* Define to 1 if you have the wait3 function.  */
+/* #undef HAVE_WAIT3 */
+
+/* Define to 1 if you have the waitpid function.  */
+/* #undef HAVE_WAITPID */
+
+/* Define to 1 if you have the <dirent.h> header file.  */
+#define HAVE_DIRENT_H 1
+
+/* Define to 1 if you have the <fcntl.h> header file.  */
+#ifdef __DECC
+#define HAVE_FCNTL_H 1
+#endif
+
+/* Define to 1 if you have the <limits.h> header file.  */
+#define HAVE_LIMITS_H 1
+
+/* Define to 1 if you have the <mach/mach.h> header file.  */
+/* #undef HAVE_MACH_MACH_H */
+
+/* Define to 1 if you have the <memory.h> header file.  */
+/* #undef HAVE_MEMORY_H */
+
+/* Define to 1 if you have the <ndir.h> header file.  */
+/* #undef HAVE_NDIR_H */
+
+/* Define to 1 if you have the <stdlib.h> header file.  */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <string.h> header file.  */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/dir.h> header file.  */
+/* #undef HAVE_SYS_DIR_H */
+
+/* Define to 1 if you have the <sys/ndir.h> header file.  */
+/* #undef HAVE_SYS_NDIR_H */
+
+/* Define to 1 if you have the <sys/param.h> header file.  */
+/* #undef HAVE_SYS_PARAM_H */
+
+/* Define to 1 if you have the <sys/timeb.h> header file.  */
+#ifndef __GNUC__
+#define HAVE_SYS_TIMEB_H 1
+#endif
+
+/* Define to 1 if you have the <sys/wait.h> header file.  */
+/* #undef HAVE_SYS_WAIT_H */
+
+/* Define to 1 if you have the dgc library (-ldgc).  */
+/* #undef HAVE_LIBDGC */
+
+/* Define to 1 if you have the kstat library (-lkstat).  */
+/* #undef HAVE_LIBKSTAT *
+
+/* Define to 1 if you have the sun library (-lsun).  */
+/* #undef HAVE_LIBSUN */
+
+/* Define to 1 if you have the `isatty' function. */
+/* #undef HAVE_ISATTY */
+
+/* Define to 1 if you have the `ttyname' function. */
+/* #undef HAVE_TTYNAME */
+
+/* Use high resolution file timestamps if nonzero. */
+#define FILE_TIMESTAMP_HI_RES 0
+
+/* Define for case insensitve filenames */
+#define HAVE_CASE_INSENSITIVE_FS 1
+
+/* VMS specific, define it if you want to use case sensitive targets */
+/* #undef WANT_CASE_SENSITIVE_TARGETS */
+
+/* VMS specific, V7.0 has opendir() and friends, so it's undefined */
+/* If you want to use non-VMS code for opendir() etc. on V7.0 and greater
+   define the first or both macros AND change the compile command to get the
+   non-VMS versions linked: (prefix=(all,except=(opendir,...  */
+/* #undef HAVE_VMSDIR_H */
+/* #undef _DIRENT_HAVE_D_NAMLEN */
+
+/* On older systems without 7.0 backport of CRTL use non-VMS code for opendir() etc. */
+#if __CRTL_VER < 70000000
+# define HAVE_VMSDIR_H 1
+#endif
+
+#if defined(HAVE_VMSDIR_H) && defined(HAVE_DIRENT_H)
+#undef HAVE_DIRENT_H
+#endif
+
+#define HAVE_STDLIB_H 1
+#define INCLUDEDIR "sys$sysroot:[syslib]"
+#define LIBDIR "sys$sysroot:[syslib]"
+
+/* Don't use RTL functions of OpenVMS */
+#ifdef __DECC
+#include <stdio.h>
+#include <unistd.h>
+#define getopt   gnu_getopt
+#define optarg   gnu_optarg
+#define optopt   gnu_optopt
+#define optind   gnu_optind
+#define opterr   gnu_opterr
+#define globfree gnu_globfree
+#define glob     gnu_glob
+#endif
+
+/* Define if using alloca.c.  */
+/* #undef C_ALLOCA */
+/* maybe this should be placed into makeint.h */
+#if     defined(__VAX) && defined(__DECC)
+#define alloca(n)       __ALLOCA(n)
+#endif
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+/* #  undef WORDS_BIGENDIAN */
+
+/* Output sync sypport */
+#define NO_OUTPUT_SYNC
+
+/* Define to 1 to write even short single-line actions into a VMS/DCL command
+   file; this also enables exporting make environment variables into the
+   (sub-)process, which executes the action.
+   The usual make rules apply whether a shell variable - here a DCL symbol or
+   VMS logical [see CRTL getenv()] - is added to the make environment and
+   is exported. */
+#define USE_DCL_COM_FILE 1
+
+/* Build host information. */
+#define MAKE_HOST "VMS"
diff --git a/src/config.h.W32.template b/src/config.h.W32.template
new file mode 100644
index 0000000..4b5da00
--- /dev/null
+++ b/src/config.h.W32.template
@@ -0,0 +1,541 @@
+/* config.h.W32 -- hand-massaged config.h file for Windows builds       -*-C-*-
+
+Copyright (C) 1996-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Suppress some Visual C++ warnings.
+   Maybe after the code cleanup for ISO C we can remove some/all of these.  */
+#if _MSC_VER > 1000
+# pragma warning(disable:4100) /* unreferenced formal parameter */
+# pragma warning(disable:4102) /* unreferenced label */
+# pragma warning(disable:4127) /* conditional expression is constant */
+# pragma warning(disable:4131) /* uses old-style declarator */
+# pragma warning(disable:4702) /* unreachable code */
+# define _CRT_SECURE_NO_WARNINGS  /* function or variable may be unsafe */
+# define _CRT_NONSTDC_NO_WARNINGS /* functions w/o a leading underscore */
+#endif
+
+/* Define to 1 if the 'closedir' function returns void instead of 'int'. */
+/* #undef CLOSEDIR_VOID */
+
+/* Define to one of '_getb67', 'GETB67', 'getb67' for Cray-2 and Cray-YMP
+   systems. This function is required for 'alloca.c' support on those systems.
+   */
+/* #undef CRAY_STACKSEG_END */
+
+/* Define to 1 if using 'alloca.c'. */
+/* #undef C_ALLOCA */
+
+/* Define to 1 if using 'getloadavg.c'. */
+#define C_GETLOADAVG 1
+
+/* Define to 1 for DGUX with <sys/dg_sys_info.h>. */
+/* #undef DGUX */
+
+/* Define to 1 if translation of program messages to the user's native
+   language is requested. */
+/* #undef ENABLE_NLS */
+
+/* Use high resolution file timestamps if nonzero. */
+#define FILE_TIMESTAMP_HI_RES 0
+
+/* Define to 1 if the 'getloadavg' function needs to be run setuid or setgid.
+   */
+/* #undef GETLOADAVG_PRIVILEGED */
+
+/* Define to 1 if you have 'alloca', as a function or macro. */
+#define HAVE_ALLOCA 1
+
+/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
+   */
+/* #undef HAVE_ALLOCA_H */
+
+/* Define to 1 if you have the 'atexit' function. */
+#define HAVE_ATEXIT 1
+
+/* Use case insensitive file names */
+/* #undef HAVE_CASE_INSENSITIVE_FS */
+
+/* Define to 1 if you have the clock_gettime function. */
+/* #undef HAVE_CLOCK_GETTIME */
+
+/* Embed GNU Guile support.  Windows build sets this on the
+   compilation command line.  */
+/* #undef HAVE_GUILE */
+
+/* Define if the GNU dcgettext() function is already present or preinstalled.
+   */
+/* #undef HAVE_DCGETTEXT */
+
+/* Define to 1 if you have the declaration of 'bsd_signal', and to 0 if you
+   don't. */
+#define HAVE_DECL_BSD_SIGNAL 0
+
+/* Define to 1 if you have the declaration of 'sys_siglist', and to 0 if you
+   don't. */
+#define HAVE_DECL_SYS_SIGLIST 0
+
+/* Define to 1 if you have the declaration of '_sys_siglist', and to 0 if you
+   don't. */
+#define HAVE_DECL__SYS_SIGLIST 0
+
+/* Define to 1 if you have the declaration of '__sys_siglist', and to 0 if you
+   don't. */
+#define HAVE_DECL___SYS_SIGLIST 0
+
+/* Define to 1 if you have the <dirent.h> header file, and it defines 'DIR'.
+   */
+#define HAVE_DIRENT_H 1
+
+/* Define to 1 if you have the <direct.h> header file, and it defines getcwd()
+   and chdir().
+   */
+#if (defined(_MSC_VER) || defined(__BORLANDC__)) && !defined(__INTERIX)
+# define HAVE_DIRECT_H 1
+#endif
+
+/* Use platform specific coding */
+#define HAVE_DOS_PATHS 1
+
+/* Define to 1 if you have the 'dup2' function. */
+#define HAVE_DUP2 1
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#define HAVE_FCNTL_H 1
+
+/* Define to 1 if you have the 'fdopen' function. */
+#ifdef __MINGW32__
+#define HAVE_FDOPEN 1
+#endif
+
+/* Define to 1 if you have the 'fileno' function. */
+#define HAVE_FILENO 1
+
+/* Define to 1 if you have the 'getcwd' function.  */
+#define HAVE_GETCWD 1
+
+/* Define to 1 if you have the 'getgroups' function. */
+/* #undef HAVE_GETGROUPS */
+
+/* Define to 1 if you have the 'gethostbyname' function. */
+/* #undef HAVE_GETHOSTBYNAME */
+
+/* Define to 1 if you have the 'gethostname' function. */
+/* #undef HAVE_GETHOSTNAME */
+
+/* Define to 1 if you have the 'getloadavg' function. */
+/* #undef HAVE_GETLOADAVG */
+
+/* Define to 1 if you have the 'getrlimit' function. */
+/* #undef HAVE_GETRLIMIT */
+
+/* Define if the GNU gettext() function is already present or preinstalled. */
+/* #undef HAVE_GETTEXT */
+
+/* Define to 1 if you have a standard gettimeofday function */
+#ifdef __MINGW32__
+#define HAVE_GETTIMEOFDAY 1
+#endif
+
+/* Define if you have the iconv() function. */
+/* #undef HAVE_ICONV */
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#ifdef __MINGW32__
+#define HAVE_INTTYPES_H 1
+#endif
+
+/* Define to 1 if you have the 'dgc' library (-ldgc). */
+/* #undef HAVE_LIBDGC */
+
+/* Define to 1 if you have the 'kstat' library (-lkstat). */
+/* #undef HAVE_LIBKSTAT */
+
+/* Define to 1 if you have the <limits.h> header file. */
+#define HAVE_LIMITS_H 1
+
+/* Define to 1 if you have the <locale.h> header file. */
+/*#define HAVE_LOCALE_H 1*/
+
+/* Define to 1 if you have the 'lstat' function. */
+/* #undef HAVE_LSTAT */
+
+/* Define to 1 if you have the <mach/mach.h> header file. */
+/* #undef HAVE_MACH_MACH_H */
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the 'mkstemp' function. */
+/* #undef HAVE_MKSTEMP */
+
+/* Define to 1 if you have the 'mktemp' function. */
+#define HAVE_MKTEMP 1
+
+/* Define to 1 if you have the <ndir.h> header file, and it defines 'DIR'. */
+/* #undef HAVE_NDIR_H */
+
+/* Define to 1 if you have the <nlist.h> header file. */
+/* #undef HAVE_NLIST_H */
+
+/* Define to 1 if you have the 'pipe' function. */
+/* #undef HAVE_PIPE */
+
+/* Define to 1 if you have the 'pstat_getdynamic' function. */
+/* #undef HAVE_PSTAT_GETDYNAMIC */
+
+/* Define to 1 if you have the 'readlink' function. */
+/* #undef HAVE_READLINK */
+
+/* Define to 1 if you have the 'realpath' function. */
+/* #undef HAVE_REALPATH */
+
+/* Define to 1 if <signal.h> defines the SA_RESTART constant. */
+/* #undef HAVE_SA_RESTART */
+
+/* Define to 1 if you have the 'setegid' function. */
+/* #undef HAVE_SETEGID */
+
+/* Define to 1 if you have the 'seteuid' function. */
+/* #undef HAVE_SETEUID */
+
+/* Define to 1 if you have the 'setlinebuf' function. */
+/* #undef HAVE_SETLINEBUF */
+
+/* Define to 1 if you have the 'setlocale' function. */
+/*#define HAVE_SETLOCALE 1*/
+
+/* Define to 1 if you have the 'setregid' function. */
+/* #undef HAVE_SETREGID */
+
+/* Define to 1 if you have the 'setreuid' function. */
+/* #undef HAVE_SETREUID */
+
+/* Define to 1 if you have the 'setrlimit' function. */
+/* #undef HAVE_SETRLIMIT */
+
+/* Define to 1 if you have the 'setvbuf' function. */
+#define HAVE_SETVBUF 1
+
+/* Define to 1 if you have the 'sigaction' function. */
+/* #undef HAVE_SIGACTION */
+
+/* Define to 1 if you have the 'sigsetmask' function. */
+/* #undef HAVE_SIGSETMASK */
+
+/* Define to 1 if you have the 'socket' function. */
+/* #undef HAVE_SOCKET */
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#ifdef __MINGW32__
+#define HAVE_STDINT_H 1
+#endif
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the 'strcasecmp' function. */
+#ifdef __MINGW32__
+#define HAVE_STRCASECMP 1
+#endif
+
+/* Define to 1 if you have the 'strcmpi' function. */
+#define HAVE_STRCMPI 1
+
+/* Define to 1 if you have the 'strcoll' function and it is properly defined.
+   */
+#define HAVE_STRCOLL 1
+
+/* Define to 1 if you have the 'strdup' function. */
+#define HAVE_STRDUP 1
+
+/* Define to 1 if you have the 'strerror' function. */
+#define HAVE_STRERROR 1
+
+/* Define to 1 if you have the 'stricmp' function. */
+#define HAVE_STRICMP 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#ifdef __MINGW32__
+#define HAVE_STRINGS_H 1
+#endif
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the 'strncasecmp' function. */
+#ifdef __MINGW32__
+#define HAVE_STRNCASECMP 1
+#endif
+
+/* Define to 1 if you have the 'strncmpi' function. */
+/* #undef HAVE_STRNCMPI */
+
+/* Define to 1 if you have the 'strndup' function. */
+/* #undef HAVE_STRNDUP */
+
+/* Define to 1 if you have the 'strnicmp' function. */
+#ifdef __MINGW32__
+#define HAVE_STRNICMP 1
+#endif
+
+/* Define to 1 if you have the 'strsignal' function. */
+/* #undef HAVE_STRSIGNAL */
+
+/* Define to 1 if you have the `isatty' function. */
+#define HAVE_ISATTY 1
+
+/* Define to 1 if you have the `ttyname' function. */
+#define HAVE_TTYNAME 1
+char *ttyname (int);
+
+/* Define to 1 if 'n_un.n_name' is a member of 'struct nlist'. */
+/* #undef HAVE_STRUCT_NLIST_N_UN_N_NAME */
+
+/* Define to 1 if you have the <sys/dir.h> header file, and it defines 'DIR'.
+   */
+/* #undef HAVE_SYS_DIR_H */
+
+/* Define to 1 if you have the <sys/ndir.h> header file, and it defines 'DIR'.
+   */
+/* #undef HAVE_SYS_NDIR_H */
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#ifdef __MINGW32__
+#define HAVE_SYS_PARAM_H 1
+#endif
+
+/* Define to 1 if you have the <sys/resource.h> header file. */
+/* #undef HAVE_SYS_RESOURCE_H */
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/timeb.h> header file. */
+#define HAVE_SYS_TIMEB_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#ifdef __MINGW32__
+#define HAVE_SYS_TIME_H 1
+#endif
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <sys/wait.h> header file. */
+/* #undef HAVE_SYS_WAIT_H */
+
+/* Define to 1 if you have the \'union wait' type in <sys/wait.h>. */
+/* #undef HAVE_UNION_WAIT */
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#ifdef __MINGW32__
+#define HAVE_UNISTD_H 1
+#endif
+
+/* Define to 1 if you have the 'wait3' function. */
+/* #undef HAVE_WAIT3 */
+
+/* Define to 1 if you have the 'waitpid' function. */
+/* #undef HAVE_WAITPID */
+
+/* Build host information. */
+#define MAKE_HOST "Windows32"
+
+/* Define to 1 to enable job server support in GNU make. */
+#define MAKE_JOBSERVER 1
+
+/* Define to 1 to enable 'load' support in GNU make. */
+#define MAKE_LOAD 1
+
+/* Define to 1 to enable symbolic link timestamp checking. */
+/* #undef MAKE_SYMLINKS */
+
+/* Define to 1 if your 'struct nlist' has an 'n_un' member. Obsolete, depend
+   on 'HAVE_STRUCT_NLIST_N_UN_N_NAME */
+/* #undef NLIST_NAME_UNION */
+
+/* Define to 1 if struct nlist.n_name is a pointer rather than an array. */
+/* #undef NLIST_STRUCT */
+
+/* Define to 1 if your C compiler doesn't accept -c and -o together. */
+/* #undef NO_MINUS_C_MINUS_O */
+
+/* Name of this package (needed by automake) */
+#define PACKAGE "%PACKAGE%"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "bug-make@gnu.org"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "GNU make"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL "http://www.gnu.org/software/make/"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "%VERSION%"
+
+/* Define to the character that separates directories in PATH. */
+#define PATH_SEPARATOR_CHAR ';'
+
+/* Define as the return type of signal handlers ('int' or 'void'). */
+#define RETSIGTYPE void
+
+/* Define to the name of the SCCS 'get' command. */
+#define SCCS_GET "echo no sccs get"
+
+/* Define this if the SCCS 'get' command understands the '-G<file>' option. */
+/* #undef SCCS_GET_MINUS_G */
+
+/* Define to 1 if the 'setvbuf' function takes the buffering type as its
+   second argument and the buffer pointer as the third, as on System V before
+   release 3. */
+/* #undef SETVBUF_REVERSED */
+
+/* If using the C implementation of alloca, define if you know the
+   direction of stack growth for your system; otherwise it will be
+   automatically deduced at run time.
+        STACK_DIRECTION > 0 => grows toward higher addresses
+        STACK_DIRECTION < 0 => grows toward lower addresses
+        STACK_DIRECTION = 0 => direction of growth unknown */
+/* #undef STACK_DIRECTION */
+
+/* Define to 1 if the 'S_IS*' macros in <sys/stat.h> do not work properly. */
+/* #undef STAT_MACROS_BROKEN */
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define if struct stat contains a nanoseconds field */
+/* #undef ST_MTIM_NSEC */
+
+/* Define to 1 on System V Release 4. */
+/* #undef SVR4 */
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#ifdef __MINGW32__
+#define TIME_WITH_SYS_TIME 1
+#endif
+
+/* Define to 1 for Encore UMAX. */
+/* #undef UMAX */
+
+/* Define to 1 for Encore UMAX 4.3 that has <inq_status/cpustats.h> instead of
+   <sys/cpustats.h>. */
+/* #undef UMAX4_3 */
+
+/* Version number of package */
+#define VERSION "%VERSION%"
+
+/* Define if using the dmalloc debugging malloc package */
+/* #undef WITH_DMALLOC */
+
+/* Define to 1 if on AIX 3.
+   System headers sometimes define this.
+   We just want to avoid a redefinition error message.  */
+#ifndef _ALL_SOURCE
+/* # undef _ALL_SOURCE */
+#endif
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+/* #  undef WORDS_BIGENDIAN */
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+/* #undef _FILE_OFFSET_BITS */
+
+/* Define for large files, on AIX-style hosts. */
+/* #undef _LARGE_FILES */
+
+/* Define to 1 if on MINIX. */
+/* #undef _MINIX */
+
+/* Define to 2 if the system does not provide POSIX.1 features except with
+   this defined. */
+/* #undef _POSIX_1_SOURCE */
+
+/* Define to 1 if you need to in order for 'stat' and other things to work. */
+/* #undef _POSIX_SOURCE */
+
+/* Define to empty if 'const' does not conform to ANSI C. */
+/* #undef const */
+
+#include <sys/types.h>
+
+/* Define to 'int' if <sys/types.h> doesn't define. */
+#define gid_t int
+
+/* Define to 'int' if <sys/types.h> does not define. */
+/* GCC 4.x reportedly defines pid_t.  */
+#ifndef _PID_T_
+#ifdef _WIN64
+#define pid_t __int64
+#else
+#define pid_t int
+#endif
+#endif
+
+/* Define to `int' if <sys/types.h> does not define. */
+#define ssize_t int
+
+/* Define to 'int' if <sys/types.h> doesn't define. */
+#define uid_t int
+
+/* Define uintmax_t if not defined in <stdint.h> or <inttypes.h>. */
+#if !HAVE_STDINT_H && !HAVE_INTTYPES_H
+#define uintmax_t unsigned long
+#endif
+
+/* Define if you have <sys/wait.h> that is POSIX.1 compatible.  */
+/* #undef HAVE_SYS_WAIT_H */
+
+/* Define to the installation directory for locales.  */
+#define LOCALEDIR ""
+
+/*
+ * Refer to README.W32 for info on the following settings
+ */
+
+
+/*
+ * If you have a shell that does not grok 'sh -c quoted-command-line'
+ * correctly, you need this setting. Please see below for specific
+ * shell support.
+ */
+/*#define BATCH_MODE_ONLY_SHELL 1 */
+
+/*
+ * Define if you have the Cygnus "Cygwin" GNU Windows32 tool set.
+ * Do NOT define BATCH_MODE_ONLY_SHELL if you define HAVE_CYGWIN_SHELL
+ */
+/*#define HAVE_CYGWIN_SHELL 1 */
+
+/*
+ * Define if you have the MKS tool set or shell. Do NOT define
+ * BATCH_MODE_ONLY_SHELL if you define HAVE_MKS_SHELL
+ */
+/*#define HAVE_MKS_SHELL 1 */
+
+/*
+ * Enforce the mutual exclusivity restriction.
+ */
+#ifdef HAVE_MKS_SHELL
+#undef BATCH_MODE_ONLY_SHELL
+#endif
+
+#ifdef HAVE_CYGWIN_SHELL
+#undef BATCH_MODE_ONLY_SHELL
+#endif
diff --git a/src/configh.dos.template b/src/configh.dos.template
new file mode 100644
index 0000000..72c501c
--- /dev/null
+++ b/src/configh.dos.template
@@ -0,0 +1,116 @@
+/* configh.dos -- hand-massaged config.h file for MS-DOS builds         -*-C-*-
+
+Copyright (C) 1994-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Include this header to make __DJGPP_MINOR__ available because DJGPP ports
+   of GCC 4.3.0 and later no longer do it automatically.  */
+#include <sys/version.h>
+
+/* Many things are defined already by a system header.  */
+#include <sys/config.h>
+
+#if __DJGPP__ > 2 || __DJGPP_MINOR__ > 1
+
+/* Define to 1 if 'sys_siglist' is declared by <signal.h> or <unistd.h>. */
+# define SYS_SIGLIST_DECLARED 1
+
+/* Define to 1 if the C library defines the variable '_sys_siglist'.  */
+# define HAVE_DECL_SYS_SIGLIST 1
+
+#else
+
+/* Define NSIG.  */
+# define NSIG SIGMAX
+
+#endif
+
+/* Use high resolution file timestamps if nonzero. */
+#define FILE_TIMESTAMP_HI_RES 0
+
+/* Define to 1 if you have 'alloca', as a function or macro. */
+#define HAVE_ALLOCA 1
+
+/* Define to 1 if you have the fdopen function.  */
+#define HAVE_FDOPEN 1
+
+/* Define to 1 if you have the 'getgroups' function. */
+#define HAVE_GETGROUPS 1
+
+/* Define to 1 if you have the <memory.h> header file.  */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the mkstemp function.  */
+#define HAVE_MKSTEMP 1
+
+/* Define to 1 if you have the 'mktemp' function. */
+#define HAVE_MKTEMP 1
+
+/* Define to 1 if you have the 'setlinebuf' function. */
+#define HAVE_SETLINEBUF 1
+
+/* Define to 1 if you have the 'setvbuf' function. */
+#define HAVE_SETVBUF 1
+
+#define SCCS_GET "get"
+
+/* Define to 'unsigned long' or 'unsigned long long'
+   if <inttypes.h> doesn't define.  */
+#define uintmax_t unsigned long long
+
+/* Define the type of the first arg to select().  */
+#define fd_set_size_t int
+
+/* Define to 1 if you have the select function.  */
+#define HAVE_SELECT 1
+
+/* Define to 1 if you have the stricmp function.  */
+#define HAVE_STRICMP 1
+
+/* Define to 1 if you have the 'strncasecmp' function. */
+#define HAVE_STRNCASECMP 1
+
+/* Name of the package */
+#define PACKAGE "%PACKAGE%"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "bug-%PACKAGE%@gnu.org"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "GNU %PACKAGE%"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "GNU %PACKAGE% %VERSION%"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "%PACKAGE%"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "%VERSION%"
+
+/* Output sync sypport */
+#define NO_OUTPUT_SYNC
+
+/* Version number of package */
+#define VERSION "%VERSION%"
+
+/* Build host information. */
+#define MAKE_HOST "i386-pc-msdosdjgpp"
+
+/* Grok DOS paths (drive specs and backslash path element separators) */
+#define HAVE_DOS_PATHS
+
+/* Define to `int' if <sys/types.h> does not define. */
+#define ssize_t int
diff --git a/src/debug.h b/src/debug.h
new file mode 100644
index 0000000..2213c95
--- /dev/null
+++ b/src/debug.h
@@ -0,0 +1,39 @@
+/* Debugging macros and interface.
+Copyright (C) 1999-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#define DB_NONE         (0x000)
+#define DB_BASIC        (0x001)
+#define DB_VERBOSE      (0x002)
+#define DB_JOBS         (0x004)
+#define DB_IMPLICIT     (0x008)
+#define DB_MAKEFILES    (0x100)
+
+#define DB_ALL          (0xfff)
+
+extern int db_level;
+
+#define ISDB(_l)    ((_l)&db_level)
+
+/* When adding macros to this list be sure to update the value of
+   XGETTEXT_OPTIONS in the po/Makevars file.  */
+#define DBS(_l,_x)  do{ if(ISDB(_l)) {print_spaces (depth); \
+                                      printf _x; fflush (stdout);} }while(0)
+
+#define DBF(_l,_x)  do{ if(ISDB(_l)) {print_spaces (depth); \
+                                      printf (_x, file->name); \
+                                      fflush (stdout);} }while(0)
+
+#define DB(_l,_x)   do{ if(ISDB(_l)) {printf _x; fflush (stdout);} }while(0)
diff --git a/src/default.c b/src/default.c
new file mode 100644
index 0000000..483339f
--- /dev/null
+++ b/src/default.c
@@ -0,0 +1,757 @@
+/* Data base of default implicit rules for GNU Make.
+Copyright (C) 1988-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+
+#include <assert.h>
+
+#include "filedef.h"
+#include "variable.h"
+#include "rule.h"
+#include "dep.h"
+#include "job.h"
+#include "commands.h"
+
+/* Define GCC_IS_NATIVE if gcc is the native development environment on
+   your system (gcc/bison/flex vs cc/yacc/lex).  */
+#if defined(__MSDOS__) || defined(__EMX__)
+# define GCC_IS_NATIVE
+#endif
+
+
+/* This is the default list of suffixes for suffix rules.
+   '.s' must come last, so that a '.o' file will be made from
+   a '.c' or '.p' or ... file rather than from a .s file.  */
+
+static char default_suffixes[]
+#ifdef VMS
+  /* VMS should include all UNIX/POSIX + some VMS extensions */
+  = ".out .exe .a .olb .hlb .tlb .mlb .ln .o .obj .c .cxx .cc .cpp .pas .p \
+.for .f .r .y .l .ym .yl .mar .s .ss .i .ii .mod .sym .def .h .info .dvi \
+.tex .texinfo .texi .txinfo .mem .hlp .brn .rnh .rno .rnt .rnx .w .ch .cweb \
+.web .com .sh .elc .el";
+#elif defined(__EMX__)
+  = ".out .a .ln .o .c .cc .C .cpp .p .f .F .m .r .y .l .ym .yl .s .S \
+.mod .sym .def .h .info .dvi .tex .texinfo .texi .txinfo \
+.w .ch .web .sh .elc .el .obj .exe .dll .lib";
+#else
+  = ".out .a .ln .o .c .cc .C .cpp .p .f .F .m .r .y .l .ym .yl .s .S \
+.mod .sym .def .h .info .dvi .tex .texinfo .texi .txinfo \
+.w .ch .web .sh .elc .el";
+#endif
+
+static struct pspec default_pattern_rules[] =
+  {
+#ifdef VMS
+    { "(%)", "%",
+        "@if f$$search(\"$@\") .eqs. \"\" then $(LIBRARY)/CREATE/"
+         "$(or "
+          "$(patsubst %,TEXT,$(filter %.tlb %.TLB,$@)),"
+          "$(patsubst %,HELP,$(filter %.hlb %.HLB,$@)),"
+          "$(patsubst %,MACRO,$(filter %.mlb %.MLB,$@)),"
+          "$(and "
+           "$(patsubst %,SHARE,$(filter %.olb %.OLB,$@)),"
+           "$(patsubst %,SHARE,$(filter %.exe %.EXE,$<))),"
+          "OBJECT)"
+         " $@\n"
+        "$(AR) $(ARFLAGS) $@ $<" },
+
+#else
+    { "(%)", "%",
+        "$(AR) $(ARFLAGS) $@ $<" },
+#endif
+    /* The X.out rules are only in BSD's default set because
+       BSD Make has no null-suffix rules, so 'foo.out' and
+       'foo' are the same thing.  */
+#ifdef VMS
+    { "%.exe", "%",
+        "$(CP) $< $@" },
+
+#endif
+    { "%.out", "%",
+        "@rm -f $@ \n cp $< $@" },
+
+    /* Syntax is "ctangle foo.w foo.ch foo.c".  */
+    { "%.c", "%.w %.ch",
+        "$(CTANGLE) $^ $@" },
+    { "%.tex", "%.w %.ch",
+        "$(CWEAVE) $^ $@" },
+
+    { 0, 0, 0 }
+  };
+
+static struct pspec default_terminal_rules[] =
+  {
+#ifdef VMS
+
+    /* RCS.  */
+    { "%", "%$$5lv", /* Multinet style */
+        "if f$$search(\"$@\") .nes. \"\" then +$(CHECKOUT,v)" },
+    { "%", "[.$$rcs]%$$5lv", /* Multinet style */
+        "if f$$search(\"$@\") .nes. \"\" then +$(CHECKOUT,v)" },
+    { "%", "%_v", /* Normal style */
+        "if f$$search(\"$@\") .nes. \"\" then +$(CHECKOUT,v)" },
+    { "%", "[.rcs]%_v", /* Normal style */
+        "if f$$search(\"$@\") .nes. \"\" then +$(CHECKOUT,v)" },
+
+    /* SCCS.  */
+        /* ain't no SCCS on vms */
+
+#else
+    /* RCS.  */
+    { "%", "%,v",
+        "$(CHECKOUT,v)" },
+    { "%", "RCS/%,v",
+        "$(CHECKOUT,v)" },
+    { "%", "RCS/%",
+        "$(CHECKOUT,v)" },
+
+    /* SCCS.  */
+    { "%", "s.%",
+        "$(GET) $(GFLAGS) $(SCCS_OUTPUT_OPTION) $<" },
+    { "%", "SCCS/s.%",
+        "$(GET) $(GFLAGS) $(SCCS_OUTPUT_OPTION) $<" },
+#endif /* !VMS */
+    { 0, 0, 0 }
+  };
+
+static const char *default_suffix_rules[] =
+  {
+#ifdef VMS
+    ".o",
+    "$(LINK.obj) $^ $(LOADLIBES) $(LDLIBS) -o $@",
+    ".obj",
+    "$(LINK.obj) $^ $(LOADLIBES) $(LDLIBS) -o $@",
+    ".s",
+    "$(LINK.s) $^ $(LOADLIBES) $(LDLIBS) -o $@",
+    ".S",
+    "$(LINK.S) $^ $(LOADLIBES) $(LDLIBS) -o $@",
+    ".c",
+    "$(LINK.c) $^ $(LOADLIBES) $(LDLIBS) -o $@",
+    ".cc",
+    "$(LINK.cc) $^ $(LOADLIBES) $(LDLIBS) -o $@",
+    ".C",
+    "$(LINK.C) $^ $(LOADLIBES) $(LDLIBS) -o $@",
+    ".cpp",
+    "$(LINK.cpp) $^ $(LOADLIBES) $(LDLIBS) -o $@",
+    ".f",
+    "$(LINK.f) $^ $(LOADLIBES) $(LDLIBS) -o $@",
+    ".m",
+    "$(LINK.m) $^ $(LOADLIBES) $(LDLIBS) -o $@",
+    ".p",
+    "$(LINK.p) $^ $(LOADLIBES) $(LDLIBS) -o $@",
+    ".F",
+    "$(LINK.F) $^ $(LOADLIBES) $(LDLIBS) -o $@",
+    ".r",
+    "$(LINK.r) $^ $(LOADLIBES) $(LDLIBS) -o $@",
+    ".mod",
+    "$(COMPILE.mod) -o $@ -e $@ $^",
+
+    ".def.sym",
+    "$(COMPILE.def) -o $@ $<",
+
+    ".sh",
+    "copy $< >$@",
+
+    ".obj.exe",
+    "$(LINK.obj) $^ $(LOADLIBES) $(LDLIBS) $(CRT0) /exe=$@",
+    ".mar.exe",
+    "$(COMPILE.mar) $^ \n $(LINK.obj) $(subst .mar,.obj,$^) $(LOADLIBES) $(LDLIBS) $(CRT0) /exe=$@",
+    ".s.o",
+    "$(COMPILE.s) -o $@ $<",
+    ".s.exe",
+    "$(COMPILE.s) $^ \n $(LINK.obj) $(subst .s,.obj,$^) $(LOADLIBES) $(LDLIBS) $(CRT0) /exe=$@",
+    ".c.exe",
+    "$(COMPILE.c) $^ \n $(LINK.obj) $(subst .c,.obj,$^) $(LOADLIBES) $(LDLIBS) $(CRT0) /exe=$@",
+    ".cc.exe",
+#ifdef GCC_IS_NATIVE
+    "$(COMPILE.cc) $^ \n $(LINK.obj) $(CXXSTARTUP),sys$$disk:[]$(subst .cc,.obj,$^) $(LOADLIBES) $(LXLIBS) $(LDLIBS) $(CXXRT0) /exe=$@",
+#else
+    "$(COMPILE.cc) $^ \n $(CXXLINK.obj) $(subst .cc,.obj,$^) $(LOADLIBES) $(LXLIBS) $(LDLIBS) $(CXXRT0) /exe=$@",
+    ".cxx.exe",
+    "$(COMPILE.cxx) $^ \n $(CXXLINK.obj) $(subst .cxx,.obj,$^) $(LOADLIBES) $(LXLIBS) $(LDLIBS) $(CXXRT0) /exe=$@",
+#endif
+    ".for.exe",
+    "$(COMPILE.for) $^ \n $(LINK.obj) $(subst .for,.obj,$^) $(LOADLIBES) $(LDLIBS) /exe=$@",
+    ".pas.exe",
+    "$(COMPILE.pas) $^ \n $(LINK.obj) $(subst .pas,.obj,$^) $(LOADLIBES) $(LDLIBS) /exe=$@",
+
+    ".com",
+    "copy $< >$@",
+
+    ".mar.obj",
+    "$(COMPILE.mar) /obj=$@ $<",
+    ".s.obj",
+    "$(COMPILE.s) /obj=$@ $<",
+    ".ss.obj",
+    "$(COMPILE.s) /obj=$@ $<",
+    ".c.i",
+    "$(COMPILE.c)/prep /list=$@ $<",
+    ".c.s",
+    "$(COMPILE.c)/noobj/machine /list=$@ $<",
+    ".i.s",
+    "$(COMPILE.c)/noprep/noobj/machine /list=$@ $<",
+    ".c.obj",
+    "$(COMPILE.c) /obj=$@ $<",
+    ".c.o",
+    "$(COMPILE.c) /obj=$@ $<",
+    ".cc.ii",
+    "$(COMPILE.cc)/prep /list=$@ $<",
+    ".cc.ss",
+    "$(COMPILE.cc)/noobj/machine /list=$@ $<",
+    ".ii.ss",
+    "$(COMPILE.cc)/noprep/noobj/machine /list=$@ $<",
+    ".cc.obj",
+    "$(COMPILE.cc) /obj=$@ $<",
+    ".cc.o",
+    "$(COMPILE.cc) /obj=$@ $<",
+    ".cxx.obj",
+    "$(COMPILE.cxx) /obj=$@ $<",
+    ".cxx.o",
+    "$(COMPILE.cxx) /obj=$@ $<",
+    ".for.obj",
+    "$(COMPILE.for) /obj=$@ $<",
+    ".for.o",
+    "$(COMPILE.for) /obj=$@ $<",
+    ".pas.obj",
+    "$(COMPILE.pas) /obj=$@ $<",
+    ".pas.o",
+    "$(COMPILE.pas) /obj=$@ $<",
+
+    ".y.c",
+    "$(YACC.y) $< \n rename y_tab.c $@",
+    ".l.c",
+    "$(LEX.l) $< \n rename lexyy.c $@",
+
+    ".texinfo.info",
+    "$(MAKEINFO) $<",
+
+    ".tex.dvi",
+    "$(TEX) $<",
+
+    ".cpp.o",
+    "$(COMPILE.cpp) $(OUTPUT_OPTION) $<",
+    ".f.o",
+    "$(COMPILE.f) $(OUTPUT_OPTION) $<",
+    ".m.o",
+    "$(COMPILE.m) $(OUTPUT_OPTION) $<",
+    ".p.o",
+    "$(COMPILE.p) $(OUTPUT_OPTION) $<",
+    ".r.o",
+    "$(COMPILE.r) $(OUTPUT_OPTION) $<",
+    ".mod.o",
+    "$(COMPILE.mod) -o $@ $<",
+
+    ".c.ln",
+    "$(LINT.c) -C$* $<",
+    ".y.ln",
+    "$(YACC.y) $< \n rename y_tab.c $@",
+
+    ".l.ln",
+    "@$(RM) $*.c\n $(LEX.l) $< > $*.c\n$(LINT.c) -i $*.c -o $@\n $(RM) $*.c",
+
+#else /* ! VMS */
+
+    ".o",
+    "$(LINK.o) $^ $(LOADLIBES) $(LDLIBS) -o $@",
+    ".s",
+    "$(LINK.s) $^ $(LOADLIBES) $(LDLIBS) -o $@",
+    ".S",
+    "$(LINK.S) $^ $(LOADLIBES) $(LDLIBS) -o $@",
+    ".c",
+    "$(LINK.c) $^ $(LOADLIBES) $(LDLIBS) -o $@",
+    ".cc",
+    "$(LINK.cc) $^ $(LOADLIBES) $(LDLIBS) -o $@",
+    ".C",
+    "$(LINK.C) $^ $(LOADLIBES) $(LDLIBS) -o $@",
+    ".cpp",
+    "$(LINK.cpp) $^ $(LOADLIBES) $(LDLIBS) -o $@",
+    ".f",
+    "$(LINK.f) $^ $(LOADLIBES) $(LDLIBS) -o $@",
+    ".m",
+    "$(LINK.m) $^ $(LOADLIBES) $(LDLIBS) -o $@",
+    ".p",
+    "$(LINK.p) $^ $(LOADLIBES) $(LDLIBS) -o $@",
+    ".F",
+    "$(LINK.F) $^ $(LOADLIBES) $(LDLIBS) -o $@",
+    ".r",
+    "$(LINK.r) $^ $(LOADLIBES) $(LDLIBS) -o $@",
+    ".mod",
+    "$(COMPILE.mod) -o $@ -e $@ $^",
+
+    ".def.sym",
+    "$(COMPILE.def) -o $@ $<",
+
+    ".sh",
+    "cat $< >$@ \n chmod a+x $@",
+
+    ".s.o",
+    "$(COMPILE.s) -o $@ $<",
+    ".S.o",
+    "$(COMPILE.S) -o $@ $<",
+    ".c.o",
+    "$(COMPILE.c) $(OUTPUT_OPTION) $<",
+    ".cc.o",
+    "$(COMPILE.cc) $(OUTPUT_OPTION) $<",
+    ".C.o",
+    "$(COMPILE.C) $(OUTPUT_OPTION) $<",
+    ".cpp.o",
+    "$(COMPILE.cpp) $(OUTPUT_OPTION) $<",
+    ".f.o",
+    "$(COMPILE.f) $(OUTPUT_OPTION) $<",
+    ".m.o",
+    "$(COMPILE.m) $(OUTPUT_OPTION) $<",
+    ".p.o",
+    "$(COMPILE.p) $(OUTPUT_OPTION) $<",
+    ".F.o",
+    "$(COMPILE.F) $(OUTPUT_OPTION) $<",
+    ".r.o",
+    "$(COMPILE.r) $(OUTPUT_OPTION) $<",
+    ".mod.o",
+    "$(COMPILE.mod) -o $@ $<",
+
+    ".c.ln",
+    "$(LINT.c) -C$* $<",
+    ".y.ln",
+#ifndef __MSDOS__
+    "$(YACC.y) $< \n $(LINT.c) -C$* y.tab.c \n $(RM) y.tab.c",
+#else
+    "$(YACC.y) $< \n $(LINT.c) -C$* y_tab.c \n $(RM) y_tab.c",
+#endif
+    ".l.ln",
+    "@$(RM) $*.c\n $(LEX.l) $< > $*.c\n$(LINT.c) -i $*.c -o $@\n $(RM) $*.c",
+
+    ".y.c",
+#ifndef __MSDOS__
+    "$(YACC.y) $< \n mv -f y.tab.c $@",
+#else
+    "$(YACC.y) $< \n mv -f y_tab.c $@",
+#endif
+    ".l.c",
+    "@$(RM) $@ \n $(LEX.l) $< > $@",
+    ".ym.m",
+    "$(YACC.m) $< \n mv -f y.tab.c $@",
+    ".lm.m",
+    "@$(RM) $@ \n $(LEX.m) $< > $@",
+
+    ".F.f",
+    "$(PREPROCESS.F) $(OUTPUT_OPTION) $<",
+    ".r.f",
+    "$(PREPROCESS.r) $(OUTPUT_OPTION) $<",
+
+    /* This might actually make lex.yy.c if there's no %R% directive in $*.l,
+       but in that case why were you trying to make $*.r anyway?  */
+    ".l.r",
+    "$(LEX.l) $< > $@ \n mv -f lex.yy.r $@",
+
+    ".S.s",
+    "$(PREPROCESS.S) $< > $@",
+
+    ".texinfo.info",
+    "$(MAKEINFO) $(MAKEINFO_FLAGS) $< -o $@",
+
+    ".texi.info",
+    "$(MAKEINFO) $(MAKEINFO_FLAGS) $< -o $@",
+
+    ".txinfo.info",
+    "$(MAKEINFO) $(MAKEINFO_FLAGS) $< -o $@",
+
+    ".tex.dvi",
+    "$(TEX) $<",
+
+    ".texinfo.dvi",
+    "$(TEXI2DVI) $(TEXI2DVI_FLAGS) $<",
+
+    ".texi.dvi",
+    "$(TEXI2DVI) $(TEXI2DVI_FLAGS) $<",
+
+    ".txinfo.dvi",
+    "$(TEXI2DVI) $(TEXI2DVI_FLAGS) $<",
+
+    ".w.c",
+    "$(CTANGLE) $< - $@",       /* The '-' says there is no '.ch' file.  */
+
+    ".web.p",
+    "$(TANGLE) $<",
+
+    ".w.tex",
+    "$(CWEAVE) $< - $@",        /* The '-' says there is no '.ch' file.  */
+
+    ".web.tex",
+    "$(WEAVE) $<",
+
+#endif /* !VMS */
+
+    0, 0,
+  };
+
+static const char *default_variables[] =
+  {
+#ifdef VMS
+#ifdef __ALPHA
+    "ARCH", "ALPHA",
+#endif
+#ifdef __ia64
+    "ARCH", "IA64",
+#endif
+#ifdef __VAX
+    "ARCH", "VAX",
+#endif
+    "AR", "library",
+    "LIBRARY", "library",
+    "ARFLAGS", "/replace",
+    "AS", "macro",
+    "MACRO", "macro",
+#ifdef GCC_IS_NATIVE
+    "CC", "gcc",
+#else
+    "CC", "cc",
+#endif
+    "CD", "builtin_cd",
+    "ECHO", "builtin_echo",
+#ifdef GCC_IS_NATIVE
+    "C++", "gcc/plus",
+    "CXX", "gcc/plus",
+#else
+    "C++", "cxx",
+    "CXX", "cxx",
+#ifndef __ia64
+    "CXXLD", "cxxlink",
+    "CXXLINK", "cxxlink",
+#else
+    /* CXXLINK is not used on VMS/IA64 */
+    "CXXLD", "link",
+    "CXXLINK", "link",
+#endif
+#endif
+    "CO", "co",
+    "CPP", "$(CC) /preprocess_only",
+    "FC", "fortran",
+    /* System V uses these, so explicit rules using them should work.
+       However, there is no way to make implicit rules use them and FC.  */
+    "F77", "$(FC)",
+    "F77FLAGS", "$(FFLAGS)",
+    "LD", "link",
+    "LEX", "lex",
+    "PC", "pascal",
+    "YACC", "bison/yacc",
+    "YFLAGS", "/Define/Verbose",
+    "BISON", "bison",
+    "MAKEINFO", "makeinfo",
+    "TEX", "tex",
+    "TEXINDEX", "texindex",
+
+    "RM", "delete/nolog",
+
+    "CSTARTUP", "",
+#ifdef GCC_IS_NATIVE
+    "CRT0", ",sys$$library:vaxcrtl.olb/lib,gnu_cc_library:crt0.obj",
+    "CXXSTARTUP", "gnu_cc_library:crtbegin.obj",
+    "CXXRT0", ",sys$$library:vaxcrtl.olb/lib,gnu_cc_library:crtend.obj,gnu_cc_library:gxx_main.obj",
+    "LXLIBS", ",gnu_cc_library:libstdcxx.olb/lib,gnu_cc_library:libgccplus.olb/lib",
+    "LDLIBS", ",gnu_cc_library:libgcc.olb/lib",
+#else
+    "CRT0", "",
+    "CXXSTARTUP", "",
+    "CXXRT0", "",
+    "LXLIBS", "",
+    "LDLIBS", "",
+#endif
+
+    "LINK.o", "$(LD) $(LDFLAGS)",
+    "LINK.obj", "$(LD) $(LDFLAGS)",
+#ifndef GCC_IS_NATIVE
+    "CXXLINK.obj", "$(CXXLD) $(LDFLAGS)",
+    "COMPILE.cxx", "$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
+#endif
+    "COMPILE.c", "$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
+    "LINK.c", "$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
+    "COMPILE.m", "$(OBJC) $(OBJCFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
+    "LINK.m", "$(OBJC) $(OBJCFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
+    "COMPILE.cc", "$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
+    "COMPILE.C", "$(COMPILE.cc)",
+    "COMPILE.cpp", "$(COMPILE.cc)",
+    "LINK.C", "$(LINK.cc)",
+    "LINK.cpp", "$(LINK.cc)",
+    "YACC.y", "$(YACC) $(YFLAGS)",
+    "LEX.l", "$(LEX) $(LFLAGS)",
+    "YACC.m", "$(YACC) $(YFLAGS)",
+    "LEX.m", "$(LEX) $(LFLAGS) -t",
+    "COMPILE.for", "$(FC) $(FFLAGS) $(TARGET_ARCH)",
+    "COMPILE.f", "$(FC) $(FFLAGS) $(TARGET_ARCH) -c",
+    "LINK.f", "$(FC) $(FFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
+    "COMPILE.F", "$(FC) $(FFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
+    "LINK.F", "$(FC) $(FFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
+    "COMPILE.r", "$(FC) $(FFLAGS) $(RFLAGS) $(TARGET_ARCH) -c",
+    "LINK.r", "$(FC) $(FFLAGS) $(RFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
+    "COMPILE.pas", "$(PC) $(PFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
+    "COMPILE.def", "$(M2C) $(M2FLAGS) $(DEFFLAGS) $(TARGET_ARCH)",
+    "COMPILE.mod", "$(M2C) $(M2FLAGS) $(MODFLAGS) $(TARGET_ARCH)",
+    "COMPILE.p", "$(PC) $(PFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
+    "LINK.p", "$(PC) $(PFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
+    "COMPILE.mar", "$(MACRO) $(MACROFLAGS)",
+    "COMPILE.s", "$(AS) $(ASFLAGS) $(TARGET_MACH)",
+    "LINK.S", "$(CC) $(ASFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_MACH)",
+    "COMPILE.S", "$(CC) $(ASFLAGS) $(CPPFLAGS) $(TARGET_MACH) -c",
+    "PREPROCESS.S", "$(CC) -E $(CPPFLAGS)",
+    "PREPROCESS.F", "$(FC) $(FFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -F",
+    "PREPROCESS.r", "$(FC) $(FFLAGS) $(RFLAGS) $(TARGET_ARCH) -F",
+    "LINT.c", "$(LINT) $(LINTFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
+
+    "MV", "rename/new_version",
+    "CP", "copy",
+    ".LIBPATTERNS", "%.olb lib%.a",
+
+#else /* !VMS */
+
+    "AR", "ar",
+    "ARFLAGS", "rv",
+    "AS", "as",
+#ifdef GCC_IS_NATIVE
+    "CC", "gcc",
+# ifdef __MSDOS__
+    "CXX", "gpp",       /* g++ is an invalid name on MSDOS */
+# else
+    "CXX", "gcc",
+# endif /* __MSDOS__ */
+    "OBJC", "gcc",
+#else
+    "CC", "cc",
+    "CXX", "g++",
+    "OBJC", "cc",
+#endif
+
+    /* This expands to $(CO) $(COFLAGS) $< $@ if $@ does not exist,
+       and to the empty string if $@ does exist.  */
+    "CHECKOUT,v", "+$(if $(wildcard $@),,$(CO) $(COFLAGS) $< $@)",
+    "CO", "co",
+    "COFLAGS", "",
+
+    "CPP", "$(CC) -E",
+#ifdef  CRAY
+    "CF77PPFLAGS", "-P",
+    "CF77PP", "/lib/cpp",
+    "CFT", "cft77",
+    "CF", "cf77",
+    "FC", "$(CF)",
+#else   /* Not CRAY.  */
+#ifdef  _IBMR2
+    "FC", "xlf",
+#else
+#ifdef  __convex__
+    "FC", "fc",
+#else
+    "FC", "f77",
+#endif /* __convex__ */
+#endif /* _IBMR2 */
+    /* System V uses these, so explicit rules using them should work.
+       However, there is no way to make implicit rules use them and FC.  */
+    "F77", "$(FC)",
+    "F77FLAGS", "$(FFLAGS)",
+#endif  /* Cray.  */
+    "GET", SCCS_GET,
+    "LD", "ld",
+#ifdef GCC_IS_NATIVE
+    "LEX", "flex",
+#else
+    "LEX", "lex",
+#endif
+    "LINT", "lint",
+    "M2C", "m2c",
+#ifdef  pyr
+    "PC", "pascal",
+#else
+#ifdef  CRAY
+    "PC", "PASCAL",
+    "SEGLDR", "segldr",
+#else
+    "PC", "pc",
+#endif  /* CRAY.  */
+#endif  /* pyr.  */
+#ifdef GCC_IS_NATIVE
+    "YACC", "bison -y",
+#else
+    "YACC", "yacc",     /* Or "bison -y"  */
+#endif
+    "MAKEINFO", "makeinfo",
+    "TEX", "tex",
+    "TEXI2DVI", "texi2dvi",
+    "WEAVE", "weave",
+    "CWEAVE", "cweave",
+    "TANGLE", "tangle",
+    "CTANGLE", "ctangle",
+
+    "RM", "rm -f",
+
+    "LINK.o", "$(CC) $(LDFLAGS) $(TARGET_ARCH)",
+    "COMPILE.c", "$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
+    "LINK.c", "$(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
+    "COMPILE.m", "$(OBJC) $(OBJCFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
+    "LINK.m", "$(OBJC) $(OBJCFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
+    "COMPILE.cc", "$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
+#ifndef HAVE_CASE_INSENSITIVE_FS
+    /* On case-insensitive filesystems, treat *.C files as *.c files,
+       to avoid erroneously compiling C sources as C++, which will
+       probably fail.  */
+    "COMPILE.C", "$(COMPILE.cc)",
+#else
+    "COMPILE.C", "$(COMPILE.c)",
+#endif
+    "COMPILE.cpp", "$(COMPILE.cc)",
+    "LINK.cc", "$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
+#ifndef HAVE_CASE_INSENSITIVE_FS
+    "LINK.C", "$(LINK.cc)",
+#else
+    "LINK.C", "$(LINK.c)",
+#endif
+    "LINK.cpp", "$(LINK.cc)",
+    "YACC.y", "$(YACC) $(YFLAGS)",
+    "LEX.l", "$(LEX) $(LFLAGS) -t",
+    "YACC.m", "$(YACC) $(YFLAGS)",
+    "LEX.m", "$(LEX) $(LFLAGS) -t",
+    "COMPILE.f", "$(FC) $(FFLAGS) $(TARGET_ARCH) -c",
+    "LINK.f", "$(FC) $(FFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
+    "COMPILE.F", "$(FC) $(FFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
+    "LINK.F", "$(FC) $(FFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
+    "COMPILE.r", "$(FC) $(FFLAGS) $(RFLAGS) $(TARGET_ARCH) -c",
+    "LINK.r", "$(FC) $(FFLAGS) $(RFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
+    "COMPILE.def", "$(M2C) $(M2FLAGS) $(DEFFLAGS) $(TARGET_ARCH)",
+    "COMPILE.mod", "$(M2C) $(M2FLAGS) $(MODFLAGS) $(TARGET_ARCH)",
+    "COMPILE.p", "$(PC) $(PFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c",
+    "LINK.p", "$(PC) $(PFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)",
+    "LINK.s", "$(CC) $(ASFLAGS) $(LDFLAGS) $(TARGET_MACH)",
+    "COMPILE.s", "$(AS) $(ASFLAGS) $(TARGET_MACH)",
+    "LINK.S", "$(CC) $(ASFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_MACH)",
+    "COMPILE.S", "$(CC) $(ASFLAGS) $(CPPFLAGS) $(TARGET_MACH) -c",
+    "PREPROCESS.S", "$(CC) -E $(CPPFLAGS)",
+    "PREPROCESS.F", "$(FC) $(FFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -F",
+    "PREPROCESS.r", "$(FC) $(FFLAGS) $(RFLAGS) $(TARGET_ARCH) -F",
+    "LINT.c", "$(LINT) $(LINTFLAGS) $(CPPFLAGS) $(TARGET_ARCH)",
+
+#ifndef NO_MINUS_C_MINUS_O
+    "OUTPUT_OPTION", "-o $@",
+#endif
+
+#ifdef  SCCS_GET_MINUS_G
+    "SCCS_OUTPUT_OPTION", "-G$@",
+#endif
+
+#if defined(_AMIGA)
+    ".LIBPATTERNS", "%.lib",
+#elif defined(__MSDOS__)
+    ".LIBPATTERNS", "lib%.a $(DJDIR)/lib/lib%.a",
+#elif defined(__APPLE__)
+    ".LIBPATTERNS", "lib%.dylib lib%.a",
+#elif defined(__CYGWIN__) || defined(WINDOWS32)
+    ".LIBPATTERNS", "lib%.dll.a %.dll.a lib%.a %.lib lib%.dll %.dll",
+#else
+    ".LIBPATTERNS", "lib%.so lib%.a",
+#endif
+
+#endif /* !VMS */
+    /* Make this assignment to avoid undefined variable warnings.  */
+    "GNUMAKEFLAGS", "",
+    0, 0
+  };
+
+/* Set up the default .SUFFIXES list.  */
+
+void
+set_default_suffixes (void)
+{
+  suffix_file = enter_file (strcache_add (".SUFFIXES"));
+  suffix_file->builtin = 1;
+
+  if (no_builtin_rules_flag)
+    define_variable_cname ("SUFFIXES", "", o_default, 0);
+  else
+    {
+      struct dep *d;
+      const char *p = default_suffixes;
+      suffix_file->deps = enter_prereqs (PARSE_SIMPLE_SEQ ((char **)&p, struct dep),
+                                         NULL);
+      for (d = suffix_file->deps; d; d = d->next)
+        d->file->builtin = 1;
+
+      define_variable_cname ("SUFFIXES", default_suffixes, o_default, 0);
+    }
+}
+
+/* Enter the default suffix rules as file rules.  This used to be done in
+   install_default_implicit_rules, but that loses because we want the
+   suffix rules installed before reading makefiles, and the pattern rules
+   installed after.  */
+
+void
+install_default_suffix_rules (void)
+{
+  const char **s;
+
+  if (no_builtin_rules_flag)
+    return;
+
+  for (s = default_suffix_rules; *s != 0; s += 2)
+    {
+      struct file *f = enter_file (strcache_add (s[0]));
+      /* This function should run before any makefile is parsed.  */
+      assert (f->cmds == 0);
+      f->cmds = xmalloc (sizeof (struct commands));
+      f->cmds->fileinfo.filenm = 0;
+      f->cmds->commands = xstrdup (s[1]);
+      f->cmds->command_lines = 0;
+      f->cmds->recipe_prefix = RECIPEPREFIX_DEFAULT;
+      f->builtin = 1;
+    }
+}
+
+
+/* Install the default pattern rules.  */
+
+void
+install_default_implicit_rules (void)
+{
+  struct pspec *p;
+
+  if (no_builtin_rules_flag)
+    return;
+
+  for (p = default_pattern_rules; p->target != 0; ++p)
+    install_pattern_rule (p, 0);
+
+  for (p = default_terminal_rules; p->target != 0; ++p)
+    install_pattern_rule (p, 1);
+}
+
+void
+define_default_variables (void)
+{
+  const char **s;
+
+  if (no_builtin_variables_flag)
+    return;
+
+  for (s = default_variables; *s != 0; s += 2)
+    define_variable (s[0], strlen (s[0]), s[1], o_default, 1);
+}
+
+void
+undefine_default_variables (void)
+{
+  const char **s;
+
+  for (s = default_variables; *s != 0; s += 2)
+    undefine_variable_global (s[0], strlen (s[0]), o_default);
+}
diff --git a/src/dep.h b/src/dep.h
new file mode 100644
index 0000000..99d3f88
--- /dev/null
+++ b/src/dep.h
@@ -0,0 +1,131 @@
+/* Definitions of dependency data structures for GNU Make.
+Copyright (C) 1988-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+
+/* Structure used in chains of names, for parsing and globbing.  */
+
+#define NAMESEQ(_t)     \
+    _t *next;           \
+    const char *name
+
+struct nameseq
+  {
+    NAMESEQ (struct nameseq);
+  };
+
+/* Flag bits for the second argument to 'read_makefile'.
+   These flags are saved in the 'flags' field of each
+   'struct goaldep' in the chain returned by 'read_all_makefiles'.  */
+
+#define RM_NO_DEFAULT_GOAL      (1 << 0) /* Do not set default goal.  */
+#define RM_INCLUDED             (1 << 1) /* Search makefile search path.  */
+#define RM_DONTCARE             (1 << 2) /* No error if it doesn't exist.  */
+#define RM_NO_TILDE             (1 << 3) /* Don't expand ~ in file name.  */
+#define RM_NOFLAG               0
+
+/* Structure representing one dependency of a file.
+   Each struct file's 'deps' points to a chain of these, through 'next'.
+   'stem' is the stem for this dep line of static pattern rule or NULL.  */
+
+#define DEP(_t)                                 \
+    NAMESEQ (_t);                               \
+    struct file *file;                          \
+    const char *stem;                           \
+    unsigned short flags : 8;                   \
+    unsigned short changed : 1;                 \
+    unsigned short ignore_mtime : 1;            \
+    unsigned short staticpattern : 1;           \
+    unsigned short need_2nd_expansion : 1
+
+struct dep
+  {
+    DEP (struct dep);
+  };
+
+/* Structure representing one goal.
+   The goals to be built constitute a chain of these, chained through 'next'.
+   'stem' is not used, but it's simpler to include and ignore it.  */
+
+struct goaldep
+  {
+    DEP (struct goaldep);
+    unsigned short error;
+    floc floc;
+  };
+
+/* Options for parsing lists of filenames.  */
+
+#define PARSEFS_NONE    0x0000
+#define PARSEFS_NOSTRIP 0x0001
+#define PARSEFS_NOAR    0x0002
+#define PARSEFS_NOGLOB  0x0004
+#define PARSEFS_EXISTS  0x0008
+#define PARSEFS_NOCACHE 0x0010
+
+#define PARSE_FILE_SEQ(_s,_t,_c,_p,_f) \
+            (_t *)parse_file_seq ((_s),sizeof (_t),(_c),(_p),(_f))
+#define PARSE_SIMPLE_SEQ(_s,_t) \
+            (_t *)parse_file_seq ((_s),sizeof (_t),MAP_NUL,NULL,PARSEFS_NONE)
+
+#ifdef VMS
+void *parse_file_seq ();
+#else
+void *parse_file_seq (char **stringp, unsigned int size,
+                      int stopmap, const char *prefix, int flags);
+#endif
+
+char *tilde_expand (const char *name);
+
+#ifndef NO_ARCHIVES
+struct nameseq *ar_glob (const char *arname, const char *member_pattern, unsigned int size);
+#endif
+
+#define dep_name(d)        ((d)->name ? (d)->name : (d)->file->name)
+
+#define alloc_seq_elt(_t)   xcalloc (sizeof (_t))
+void free_ns_chain (struct nameseq *n);
+
+#if defined(MAKE_MAINTAINER_MODE) && defined(__GNUC__)
+/* Use inline to get real type-checking.  */
+#define SI static inline
+SI struct nameseq *alloc_ns()      { return alloc_seq_elt (struct nameseq); }
+SI struct dep *alloc_dep()         { return alloc_seq_elt (struct dep); }
+SI struct goaldep *alloc_goaldep() { return alloc_seq_elt (struct goaldep); }
+
+SI void free_ns(struct nameseq *n)      { free (n); }
+SI void free_dep(struct dep *d)         { free_ns ((struct nameseq *)d); }
+SI void free_goaldep(struct goaldep *g) { free_dep ((struct dep *)g); }
+
+SI void free_dep_chain(struct dep *d)      { free_ns_chain((struct nameseq *)d); }
+SI void free_goal_chain(struct goaldep *g) { free_dep_chain((struct dep *)g); }
+#else
+# define alloc_ns()          alloc_seq_elt (struct nameseq)
+# define alloc_dep()         alloc_seq_elt (struct dep)
+# define alloc_goaldep()     alloc_seq_elt (struct goaldep)
+
+# define free_ns(_n)         free (_n)
+# define free_dep(_d)        free_ns (_d)
+# define free_goaldep(_g)    free_dep (_g)
+
+# define free_dep_chain(_d)  free_ns_chain ((struct nameseq *)(_d))
+# define free_goal_chain(_g) free_ns_chain ((struct nameseq *)(_g))
+#endif
+
+struct dep *copy_dep_chain (const struct dep *d);
+
+struct goaldep *read_all_makefiles (const char **makefiles);
+void eval_buffer (char *buffer, const floc *floc);
+enum update_status update_goal_chain (struct goaldep *goals);
diff --git a/src/dir.c b/src/dir.c
new file mode 100644
index 0000000..c343e4c
--- /dev/null
+++ b/src/dir.c
@@ -0,0 +1,1346 @@
+/* Directory hashing for GNU Make.
+Copyright (C) 1988-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+#include "hash.h"
+#include "filedef.h"
+#include "dep.h"
+
+#ifdef  HAVE_DIRENT_H
+# include <dirent.h>
+# define NAMLEN(dirent) strlen((dirent)->d_name)
+# ifdef VMS
+/* its prototype is in vmsdir.h, which is not needed for HAVE_DIRENT_H */
+const char *vmsify (const char *name, int type);
+# endif
+#else
+# define dirent direct
+# define NAMLEN(dirent) (dirent)->d_namlen
+# ifdef HAVE_SYS_NDIR_H
+#  include <sys/ndir.h>
+# endif
+# ifdef HAVE_SYS_DIR_H
+#  include <sys/dir.h>
+# endif
+# ifdef HAVE_NDIR_H
+#  include <ndir.h>
+# endif
+# ifdef HAVE_VMSDIR_H
+#  include "vmsdir.h"
+# endif /* HAVE_VMSDIR_H */
+#endif
+
+/* In GNU systems, <dirent.h> defines this macro for us.  */
+#ifdef _D_NAMLEN
+# undef NAMLEN
+# define NAMLEN(d) _D_NAMLEN(d)
+#endif
+
+#if (defined (POSIX) || defined (VMS) || defined (WINDOWS32)) && !defined (__GNU_LIBRARY__)
+/* Posix does not require that the d_ino field be present, and some
+   systems do not provide it. */
+# define REAL_DIR_ENTRY(dp) 1
+# define FAKE_DIR_ENTRY(dp)
+#else
+# define REAL_DIR_ENTRY(dp) (dp->d_ino != 0)
+# define FAKE_DIR_ENTRY(dp) (dp->d_ino = 1)
+#endif /* POSIX */
+
+#ifdef __MSDOS__
+#include <ctype.h>
+#include <fcntl.h>
+
+/* If it's MSDOS that doesn't have _USE_LFN, disable LFN support.  */
+#ifndef _USE_LFN
+#define _USE_LFN 0
+#endif
+
+static const char *
+dosify (const char *filename)
+{
+  static char dos_filename[14];
+  char *df;
+  int i;
+
+  if (filename == 0 || _USE_LFN)
+    return filename;
+
+  /* FIXME: what about filenames which violate
+     8+3 constraints, like "config.h.in", or ".emacs"?  */
+  if (strpbrk (filename, "\"*+,;<=>?[\\]|") != 0)
+    return filename;
+
+  df = dos_filename;
+
+  /* First, transform the name part.  */
+  for (i = 0; i < 8 && ! STOP_SET (*filename, MAP_DOT|MAP_NUL); ++i)
+    *df++ = tolower ((unsigned char)*filename++);
+
+  /* Now skip to the next dot.  */
+  while (! STOP_SET (*filename, MAP_DOT|MAP_NUL))
+    ++filename;
+  if (*filename != '\0')
+    {
+      *df++ = *filename++;
+      for (i = 0; i < 3 && ! STOP_SET (*filename, MAP_DOT|MAP_NUL); ++i)
+        *df++ = tolower ((unsigned char)*filename++);
+    }
+
+  /* Look for more dots.  */
+  while (! STOP_SET (*filename, MAP_DOT|MAP_NUL))
+    ++filename;
+  if (*filename == '.')
+    return filename;
+  *df = 0;
+  return dos_filename;
+}
+#endif /* __MSDOS__ */
+
+#ifdef WINDOWS32
+#include "pathstuff.h"
+#endif
+
+#ifdef _AMIGA
+#include <ctype.h>
+#endif
+
+#ifdef HAVE_CASE_INSENSITIVE_FS
+static const char *
+downcase (const char *filename)
+{
+  static PATH_VAR (new_filename);
+  char *df;
+
+  if (filename == 0)
+    return 0;
+
+  df = new_filename;
+  while (*filename != '\0')
+    {
+      *df++ = tolower ((unsigned char)*filename);
+      ++filename;
+    }
+
+  *df = 0;
+
+  return new_filename;
+}
+#endif /* HAVE_CASE_INSENSITIVE_FS */
+
+#ifdef VMS
+
+static char *
+downcase_inplace(char *filename)
+{
+  char *name;
+  name = filename;
+  while (*name != '\0')
+    {
+      *name = tolower ((unsigned char)*name);
+      ++name;
+    }
+  return filename;
+}
+
+#ifndef _USE_STD_STAT
+/* VMS 8.2 fixed the VMS stat output to have unique st_dev and st_ino
+   when _USE_STD_STAT is used on the compile line.
+
+   Prior to _USE_STD_STAT support, the st_dev is a pointer to thread
+   static memory containing the device of the last filename looked up.
+
+   Todo: find out if the ino_t still needs to be faked on a directory.
+ */
+
+/* Define this if the older VMS_INO_T is needed */
+#define VMS_INO_T 1
+
+static int
+vms_hash (const char *name)
+{
+  int h = 0;
+
+  while (*name)
+    {
+      unsigned char uc = *name;
+      int g;
+#ifdef HAVE_CASE_INSENSITIVE_FS
+      h = (h << 4) + (isupper (uc) ? tolower (uc) : uc);
+#else
+      h = (h << 4) + uc;
+#endif
+      name++;
+      g = h & 0xf0000000;
+      if (g)
+        {
+          h = h ^ (g >> 24);
+          h = h ^ g;
+        }
+    }
+  return h;
+}
+
+/* fake stat entry for a directory */
+static int
+vmsstat_dir (const char *name, struct stat *st)
+{
+  char *s;
+  int h;
+  DIR *dir;
+
+  dir = opendir (name);
+  if (dir == 0)
+    return -1;
+  closedir (dir);
+  s = strchr (name, ':');       /* find device */
+  if (s)
+    {
+      /* to keep the compiler happy we said "const char *name", now we cheat */
+      *s++ = 0;
+      st->st_dev = (char *)vms_hash (name);
+      h = vms_hash (s);
+      *(s-1) = ':';
+    }
+  else
+    {
+      st->st_dev = 0;
+      h = vms_hash (name);
+    }
+
+  st->st_ino[0] = h & 0xff;
+  st->st_ino[1] = h & 0xff00;
+  st->st_ino[2] = h >> 16;
+
+  return 0;
+}
+
+# define stat(__path, __sbuf) vmsstat_dir (__path, __sbuf)
+
+#endif /* _USE_STD_STAT */
+#endif /* VMS */
+
+/* Hash table of directories.  */
+
+#ifndef DIRECTORY_BUCKETS
+#define DIRECTORY_BUCKETS 199
+#endif
+
+struct directory_contents
+  {
+    dev_t dev;                  /* Device and inode numbers of this dir.  */
+#ifdef WINDOWS32
+    /* Inode means nothing on WINDOWS32. Even file key information is
+     * unreliable because it is random per file open and undefined for remote
+     * filesystems. The most unique attribute I can come up with is the fully
+     * qualified name of the directory. Beware though, this is also
+     * unreliable. I'm open to suggestion on a better way to emulate inode.  */
+    char *path_key;
+    time_t ctime;
+    time_t mtime;        /* controls check for stale directory cache */
+    int fs_flags;     /* FS_FAT, FS_NTFS, ... */
+# define FS_FAT      0x1
+# define FS_NTFS     0x2
+# define FS_UNKNOWN  0x4
+#else
+# ifdef VMS_INO_T
+    ino_t ino[3];
+# else
+    ino_t ino;
+# endif
+#endif /* WINDOWS32 */
+    struct hash_table dirfiles; /* Files in this directory.  */
+    DIR *dirstream;             /* Stream reading this directory.  */
+  };
+
+static unsigned long
+directory_contents_hash_1 (const void *key_0)
+{
+  const struct directory_contents *key = key_0;
+  unsigned long hash;
+
+#ifdef WINDOWS32
+  hash = 0;
+  ISTRING_HASH_1 (key->path_key, hash);
+  hash ^= ((unsigned int) key->dev << 4) ^ (unsigned int) key->ctime;
+#else
+# ifdef VMS_INO_T
+  hash = (((unsigned int) key->dev << 4)
+          ^ ((unsigned int) key->ino[0]
+             + (unsigned int) key->ino[1]
+             + (unsigned int) key->ino[2]));
+# else
+  hash = ((unsigned int) key->dev << 4) ^ (unsigned int) key->ino;
+# endif
+#endif /* WINDOWS32 */
+  return hash;
+}
+
+static unsigned long
+directory_contents_hash_2 (const void *key_0)
+{
+  const struct directory_contents *key = key_0;
+  unsigned long hash;
+
+#ifdef WINDOWS32
+  hash = 0;
+  ISTRING_HASH_2 (key->path_key, hash);
+  hash ^= ((unsigned int) key->dev << 4) ^ (unsigned int) ~key->ctime;
+#else
+# ifdef VMS_INO_T
+  hash = (((unsigned int) key->dev << 4)
+          ^ ~((unsigned int) key->ino[0]
+              + (unsigned int) key->ino[1]
+              + (unsigned int) key->ino[2]));
+# else
+  hash = ((unsigned int) key->dev << 4) ^ (unsigned int) ~key->ino;
+# endif
+#endif /* WINDOWS32 */
+
+  return hash;
+}
+
+/* Sometimes it's OK to use subtraction to get this value:
+     result = X - Y;
+   But, if we're not sure of the type of X and Y they may be too large for an
+   int (on a 64-bit system for example).  So, use ?: instead.
+   See Savannah bug #15534.
+
+   NOTE!  This macro has side-effects!
+*/
+
+#define MAKECMP(_x,_y)  ((_x)<(_y)?-1:((_x)==(_y)?0:1))
+
+static int
+directory_contents_hash_cmp (const void *xv, const void *yv)
+{
+  const struct directory_contents *x = xv;
+  const struct directory_contents *y = yv;
+  int result;
+
+#ifdef WINDOWS32
+  ISTRING_COMPARE (x->path_key, y->path_key, result);
+  if (result)
+    return result;
+  result = MAKECMP(x->ctime, y->ctime);
+  if (result)
+    return result;
+#else
+# ifdef VMS_INO_T
+  result = MAKECMP(x->ino[0], y->ino[0]);
+  if (result)
+    return result;
+  result = MAKECMP(x->ino[1], y->ino[1]);
+  if (result)
+    return result;
+  result = MAKECMP(x->ino[2], y->ino[2]);
+  if (result)
+    return result;
+# else
+  result = MAKECMP(x->ino, y->ino);
+  if (result)
+    return result;
+# endif
+#endif /* WINDOWS32 */
+
+  return MAKECMP(x->dev, y->dev);
+}
+
+/* Table of directory contents hashed by device and inode number.  */
+static struct hash_table directory_contents;
+
+struct directory
+  {
+    const char *name;                   /* Name of the directory.  */
+
+    /* The directory's contents.  This data may be shared by several
+       entries in the hash table, which refer to the same directory
+       (identified uniquely by 'dev' and 'ino') under different names.  */
+    struct directory_contents *contents;
+  };
+
+static unsigned long
+directory_hash_1 (const void *key)
+{
+  return_ISTRING_HASH_1 (((const struct directory *) key)->name);
+}
+
+static unsigned long
+directory_hash_2 (const void *key)
+{
+  return_ISTRING_HASH_2 (((const struct directory *) key)->name);
+}
+
+static int
+directory_hash_cmp (const void *x, const void *y)
+{
+  return_ISTRING_COMPARE (((const struct directory *) x)->name,
+                          ((const struct directory *) y)->name);
+}
+
+/* Table of directories hashed by name.  */
+static struct hash_table directories;
+
+/* Never have more than this many directories open at once.  */
+
+#define MAX_OPEN_DIRECTORIES 10
+
+static unsigned int open_directories = 0;
+
+
+/* Hash table of files in each directory.  */
+
+struct dirfile
+  {
+    const char *name;           /* Name of the file.  */
+    size_t length;
+    short impossible;           /* This file is impossible.  */
+  };
+
+static unsigned long
+dirfile_hash_1 (const void *key)
+{
+  return_ISTRING_HASH_1 (((struct dirfile const *) key)->name);
+}
+
+static unsigned long
+dirfile_hash_2 (const void *key)
+{
+  return_ISTRING_HASH_2 (((struct dirfile const *) key)->name);
+}
+
+static int
+dirfile_hash_cmp (const void *xv, const void *yv)
+{
+  const struct dirfile *x = xv;
+  const struct dirfile *y = yv;
+  int result = x->length - y->length;
+  if (result)
+    return result;
+  return_ISTRING_COMPARE (x->name, y->name);
+}
+
+#ifndef DIRFILE_BUCKETS
+#define DIRFILE_BUCKETS 107
+#endif
+
+static int dir_contents_file_exists_p (struct directory_contents *dir,
+                                       const char *filename);
+static struct directory *find_directory (const char *name);
+
+/* Find the directory named NAME and return its 'struct directory'.  */
+
+static struct directory *
+find_directory (const char *name)
+{
+  struct directory *dir;
+  struct directory **dir_slot;
+  struct directory dir_key;
+
+  dir_key.name = name;
+  dir_slot = (struct directory **) hash_find_slot (&directories, &dir_key);
+  dir = *dir_slot;
+
+  if (HASH_VACANT (dir))
+    {
+      /* The directory was not found.  Create a new entry for it.  */
+      const char *p = name + strlen (name);
+      struct stat st;
+      int r;
+
+      dir = xmalloc (sizeof (struct directory));
+#if defined(HAVE_CASE_INSENSITIVE_FS) && defined(VMS)
+      /* Todo: Why is this only needed on VMS? */
+      {
+        char *lname = downcase_inplace (xstrdup (name));
+        dir->name = strcache_add_len (lname, p - name);
+        free (lname);
+      }
+#else
+      dir->name = strcache_add_len (name, p - name);
+#endif
+      hash_insert_at (&directories, dir, dir_slot);
+      /* The directory is not in the name hash table.
+         Find its device and inode numbers, and look it up by them.  */
+
+#if defined(WINDOWS32)
+      {
+        char tem[MAXPATHLEN], *tstart, *tend;
+
+        /* Remove any trailing slashes.  Windows32 stat fails even on
+           valid directories if they end in a slash. */
+        memcpy (tem, name, p - name + 1);
+        tstart = tem;
+        if (tstart[1] == ':')
+          tstart += 2;
+        for (tend = tem + (p - name - 1);
+             tend > tstart && (*tend == '/' || *tend == '\\');
+             tend--)
+          *tend = '\0';
+
+        r = stat (tem, &st);
+      }
+#else
+      EINTRLOOP (r, stat (name, &st));
+#endif
+
+      if (r < 0)
+        {
+        /* Couldn't stat the directory.  Mark this by
+           setting the 'contents' member to a nil pointer.  */
+          dir->contents = 0;
+        }
+      else
+        {
+          /* Search the contents hash table; device and inode are the key.  */
+
+#ifdef WINDOWS32
+          char *w32_path;
+#endif
+          struct directory_contents *dc;
+          struct directory_contents **dc_slot;
+          struct directory_contents dc_key;
+
+          dc_key.dev = st.st_dev;
+#ifdef WINDOWS32
+          dc_key.path_key = w32_path = w32ify (name, 1);
+          dc_key.ctime = st.st_ctime;
+#else
+# ifdef VMS_INO_T
+          dc_key.ino[0] = st.st_ino[0];
+          dc_key.ino[1] = st.st_ino[1];
+          dc_key.ino[2] = st.st_ino[2];
+# else
+          dc_key.ino = st.st_ino;
+# endif
+#endif
+          dc_slot = (struct directory_contents **) hash_find_slot (&directory_contents, &dc_key);
+          dc = *dc_slot;
+
+          if (HASH_VACANT (dc))
+            {
+              /* Nope; this really is a directory we haven't seen before.  */
+#ifdef WINDOWS32
+              char  fs_label[BUFSIZ];
+              char  fs_type[BUFSIZ];
+              unsigned long  fs_serno;
+              unsigned long  fs_flags;
+              unsigned long  fs_len;
+#endif
+              dc = (struct directory_contents *)
+                xmalloc (sizeof (struct directory_contents));
+
+              /* Enter it in the contents hash table.  */
+              dc->dev = st.st_dev;
+#ifdef WINDOWS32
+              dc->path_key = xstrdup (w32_path);
+              dc->ctime = st.st_ctime;
+              dc->mtime = st.st_mtime;
+
+              /* NTFS is the only WINDOWS32 filesystem that bumps mtime on a
+                 directory when files are added/deleted from a directory.  */
+              w32_path[3] = '\0';
+              if (GetVolumeInformation (w32_path, fs_label, sizeof (fs_label),
+                                        &fs_serno, &fs_len, &fs_flags, fs_type,
+                                        sizeof (fs_type)) == FALSE)
+                dc->fs_flags = FS_UNKNOWN;
+              else if (!strcmp (fs_type, "FAT"))
+                dc->fs_flags = FS_FAT;
+              else if (!strcmp (fs_type, "NTFS"))
+                dc->fs_flags = FS_NTFS;
+              else
+                dc->fs_flags = FS_UNKNOWN;
+#else
+# ifdef VMS_INO_T
+              dc->ino[0] = st.st_ino[0];
+              dc->ino[1] = st.st_ino[1];
+              dc->ino[2] = st.st_ino[2];
+# else
+              dc->ino = st.st_ino;
+# endif
+#endif /* WINDOWS32 */
+              hash_insert_at (&directory_contents, dc, dc_slot);
+              ENULLLOOP (dc->dirstream, opendir (name));
+              if (dc->dirstream == 0)
+                /* Couldn't open the directory.  Mark this by setting the
+                   'files' member to a nil pointer.  */
+                dc->dirfiles.ht_vec = 0;
+              else
+                {
+                  hash_init (&dc->dirfiles, DIRFILE_BUCKETS,
+                             dirfile_hash_1, dirfile_hash_2, dirfile_hash_cmp);
+                  /* Keep track of how many directories are open.  */
+                  ++open_directories;
+                  if (open_directories == MAX_OPEN_DIRECTORIES)
+                    /* We have too many directories open already.
+                       Read the entire directory and then close it.  */
+                    dir_contents_file_exists_p (dc, 0);
+                }
+            }
+
+          /* Point the name-hashed entry for DIR at its contents data.  */
+          dir->contents = dc;
+        }
+    }
+
+  return dir;
+}
+
+/* Return 1 if the name FILENAME is entered in DIR's hash table.
+   FILENAME must contain no slashes.  */
+
+static int
+dir_contents_file_exists_p (struct directory_contents *dir,
+                            const char *filename)
+{
+  struct dirfile *df;
+  struct dirent *d;
+#ifdef WINDOWS32
+  struct stat st;
+  int rehash = 0;
+#endif
+
+  if (dir == 0 || dir->dirfiles.ht_vec == 0)
+    /* The directory could not be stat'd or opened.  */
+    return 0;
+
+#ifdef __MSDOS__
+  filename = dosify (filename);
+#endif
+
+#ifdef HAVE_CASE_INSENSITIVE_FS
+  filename = downcase (filename);
+#endif
+
+#ifdef __EMX__
+  if (filename != 0)
+    _fnlwr (filename); /* lower case for FAT drives */
+#endif
+  if (filename != 0)
+    {
+      struct dirfile dirfile_key;
+
+      if (*filename == '\0')
+        {
+          /* Checking if the directory exists.  */
+          return 1;
+        }
+      dirfile_key.name = filename;
+      dirfile_key.length = strlen (filename);
+      df = hash_find_item (&dir->dirfiles, &dirfile_key);
+      if (df)
+        return !df->impossible;
+    }
+
+  /* The file was not found in the hashed list.
+     Try to read the directory further.  */
+
+  if (dir->dirstream == 0)
+    {
+#ifdef WINDOWS32
+      /*
+       * Check to see if directory has changed since last read. FAT
+       * filesystems force a rehash always as mtime does not change
+       * on directories (ugh!).
+       */
+      if (dir->path_key)
+        {
+          if ((dir->fs_flags & FS_FAT) != 0)
+            {
+              dir->mtime = time ((time_t *) 0);
+              rehash = 1;
+            }
+          else if (stat (dir->path_key, &st) == 0 && st.st_mtime > dir->mtime)
+            {
+              /* reset date stamp to show most recent re-process.  */
+              dir->mtime = st.st_mtime;
+              rehash = 1;
+            }
+
+          /* If it has been already read in, all done.  */
+          if (!rehash)
+            return 0;
+
+          /* make sure directory can still be opened; if not return.  */
+          dir->dirstream = opendir (dir->path_key);
+          if (!dir->dirstream)
+            return 0;
+        }
+      else
+#endif
+        /* The directory has been all read in.  */
+        return 0;
+    }
+
+  while (1)
+    {
+      /* Enter the file in the hash table.  */
+      unsigned int len;
+      struct dirfile dirfile_key;
+      struct dirfile **dirfile_slot;
+
+      ENULLLOOP (d, readdir (dir->dirstream));
+      if (d == 0)
+        {
+          if (errno)
+            pfatal_with_name ("INTERNAL: readdir");
+          break;
+        }
+
+#if defined(VMS) && defined(HAVE_DIRENT_H)
+      /* In VMS we get file versions too, which have to be stripped off.
+         Some versions of VMS return versions on Unix files even when
+         the feature option to strip them is set.  */
+      {
+        char *p = strrchr (d->d_name, ';');
+        if (p)
+          *p = '\0';
+      }
+#endif
+      if (!REAL_DIR_ENTRY (d))
+        continue;
+
+      len = NAMLEN (d);
+      dirfile_key.name = d->d_name;
+      dirfile_key.length = len;
+      dirfile_slot = (struct dirfile **) hash_find_slot (&dir->dirfiles, &dirfile_key);
+#ifdef WINDOWS32
+      /*
+       * If re-reading a directory, don't cache files that have
+       * already been discovered.
+       */
+      if (! rehash || HASH_VACANT (*dirfile_slot))
+#endif
+        {
+          df = xmalloc (sizeof (struct dirfile));
+#if defined(HAVE_CASE_INSENSITIVE_FS) && defined(VMS)
+          /* TODO: Why is this only needed on VMS? */
+          df->name = strcache_add_len (downcase_inplace (d->d_name), len);
+#else
+          df->name = strcache_add_len (d->d_name, len);
+#endif
+          df->length = len;
+          df->impossible = 0;
+          hash_insert_at (&dir->dirfiles, df, dirfile_slot);
+        }
+      /* Check if the name matches the one we're searching for.  */
+      if (filename != 0 && patheq (d->d_name, filename))
+        return 1;
+    }
+
+  /* If the directory has been completely read in,
+     close the stream and reset the pointer to nil.  */
+  if (d == 0)
+    {
+      --open_directories;
+      closedir (dir->dirstream);
+      dir->dirstream = 0;
+    }
+  return 0;
+}
+
+/* Return 1 if the name FILENAME in directory DIRNAME
+   is entered in the dir hash table.
+   FILENAME must contain no slashes.  */
+
+int
+dir_file_exists_p (const char *dirname, const char *filename)
+{
+#ifdef VMS
+  if ((filename != NULL) && (dirname != NULL))
+    {
+      int want_vmsify;
+      want_vmsify = (strpbrk (dirname, ":<[") != NULL);
+      if (want_vmsify)
+        filename = vmsify (filename, 0);
+    }
+#endif
+  return dir_contents_file_exists_p (find_directory (dirname)->contents,
+                                     filename);
+}
+
+/* Return 1 if the file named NAME exists.  */
+
+int
+file_exists_p (const char *name)
+{
+  const char *dirend;
+  const char *dirname;
+  const char *slash;
+
+#ifndef NO_ARCHIVES
+  if (ar_name (name))
+    return ar_member_date (name) != (time_t) -1;
+#endif
+
+  dirend = strrchr (name, '/');
+#ifdef VMS
+  if (dirend == 0)
+    {
+      dirend = strrchr (name, ']');
+      dirend == NULL ? dirend : dirend++;
+    }
+  if (dirend == 0)
+    {
+      dirend = strrchr (name, '>');
+      dirend == NULL ? dirend : dirend++;
+    }
+  if (dirend == 0)
+    {
+      dirend = strrchr (name, ':');
+      dirend == NULL ? dirend : dirend++;
+    }
+#endif /* VMS */
+#ifdef HAVE_DOS_PATHS
+  /* Forward and backslashes might be mixed.  We need the rightmost one.  */
+  {
+    const char *bslash = strrchr (name, '\\');
+    if (!dirend || bslash > dirend)
+      dirend = bslash;
+    /* The case of "d:file".  */
+    if (!dirend && name[0] && name[1] == ':')
+      dirend = name + 1;
+  }
+#endif /* HAVE_DOS_PATHS */
+  if (dirend == 0)
+#ifndef _AMIGA
+    return dir_file_exists_p (".", name);
+#else /* !AMIGA */
+    return dir_file_exists_p ("", name);
+#endif /* AMIGA */
+
+  slash = dirend;
+  if (dirend == name)
+    dirname = "/";
+  else
+    {
+      char *p;
+#ifdef HAVE_DOS_PATHS
+  /* d:/ and d: are *very* different...  */
+      if (dirend < name + 3 && name[1] == ':' &&
+          (*dirend == '/' || *dirend == '\\' || *dirend == ':'))
+        dirend++;
+#endif
+      p = alloca (dirend - name + 1);
+      memcpy (p, name, dirend - name);
+      p[dirend - name] = '\0';
+      dirname = p;
+    }
+#ifdef VMS
+  if (*slash == '/')
+    slash++;
+#else
+  slash++;
+#endif
+  return dir_file_exists_p (dirname, slash);
+}
+
+/* Mark FILENAME as 'impossible' for 'file_impossible_p'.
+   This means an attempt has been made to search for FILENAME
+   as an intermediate file, and it has failed.  */
+
+void
+file_impossible (const char *filename)
+{
+  const char *dirend;
+  const char *p = filename;
+  struct directory *dir;
+  struct dirfile *new;
+
+  dirend = strrchr (p, '/');
+#ifdef VMS
+  if (dirend == NULL)
+    {
+      dirend = strrchr (p, ']');
+      dirend == NULL ? dirend : dirend++;
+    }
+  if (dirend == NULL)
+    {
+      dirend = strrchr (p, '>');
+      dirend == NULL ? dirend : dirend++;
+    }
+  if (dirend == NULL)
+    {
+      dirend = strrchr (p, ':');
+      dirend == NULL ? dirend : dirend++;
+    }
+#endif
+#ifdef HAVE_DOS_PATHS
+  /* Forward and backslashes might be mixed.  We need the rightmost one.  */
+  {
+    const char *bslash = strrchr (p, '\\');
+    if (!dirend || bslash > dirend)
+      dirend = bslash;
+    /* The case of "d:file".  */
+    if (!dirend && p[0] && p[1] == ':')
+      dirend = p + 1;
+  }
+#endif /* HAVE_DOS_PATHS */
+  if (dirend == 0)
+#ifdef _AMIGA
+    dir = find_directory ("");
+#else /* !AMIGA */
+    dir = find_directory (".");
+#endif /* AMIGA */
+  else
+    {
+      const char *dirname;
+      const char *slash = dirend;
+      if (dirend == p)
+        dirname = "/";
+      else
+        {
+          char *cp;
+#ifdef HAVE_DOS_PATHS
+          /* d:/ and d: are *very* different...  */
+          if (dirend < p + 3 && p[1] == ':' &&
+              (*dirend == '/' || *dirend == '\\' || *dirend == ':'))
+            dirend++;
+#endif
+          cp = alloca (dirend - p + 1);
+          memcpy (cp, p, dirend - p);
+          cp[dirend - p] = '\0';
+          dirname = cp;
+        }
+      dir = find_directory (dirname);
+#ifdef VMS
+      if (*slash == '/')
+        filename = p = slash + 1;
+      else
+        filename = p = slash;
+#else
+      filename = p = slash + 1;
+#endif
+    }
+
+  if (dir->contents == 0)
+    /* The directory could not be stat'd.  We allocate a contents
+       structure for it, but leave it out of the contents hash table.  */
+    dir->contents = xcalloc (sizeof (struct directory_contents));
+
+  if (dir->contents->dirfiles.ht_vec == 0)
+    {
+      hash_init (&dir->contents->dirfiles, DIRFILE_BUCKETS,
+                 dirfile_hash_1, dirfile_hash_2, dirfile_hash_cmp);
+    }
+
+  /* Make a new entry and put it in the table.  */
+
+  new = xmalloc (sizeof (struct dirfile));
+  new->length = strlen (filename);
+#if defined(HAVE_CASE_INSENSITIVE_FS) && defined(VMS)
+  /* todo: Why is this only needed on VMS? */
+  new->name = strcache_add_len (downcase (filename), new->length);
+#else
+  new->name = strcache_add_len (filename, new->length);
+#endif
+  new->impossible = 1;
+  hash_insert (&dir->contents->dirfiles, new);
+}
+
+/* Return nonzero if FILENAME has been marked impossible.  */
+
+int
+file_impossible_p (const char *filename)
+{
+  const char *dirend;
+  struct directory_contents *dir;
+  struct dirfile *dirfile;
+  struct dirfile dirfile_key;
+#ifdef VMS
+  int want_vmsify = 0;
+#endif
+
+  dirend = strrchr (filename, '/');
+#ifdef VMS
+  if (dirend == NULL)
+    {
+      want_vmsify = (strpbrk (filename, "]>:^") != NULL);
+      dirend = strrchr (filename, ']');
+    }
+  if (dirend == NULL && want_vmsify)
+    dirend = strrchr (filename, '>');
+  if (dirend == NULL && want_vmsify)
+    dirend = strrchr (filename, ':');
+#endif
+#ifdef HAVE_DOS_PATHS
+  /* Forward and backslashes might be mixed.  We need the rightmost one.  */
+  {
+    const char *bslash = strrchr (filename, '\\');
+    if (!dirend || bslash > dirend)
+      dirend = bslash;
+    /* The case of "d:file".  */
+    if (!dirend && filename[0] && filename[1] == ':')
+      dirend = filename + 1;
+  }
+#endif /* HAVE_DOS_PATHS */
+  if (dirend == 0)
+#ifdef _AMIGA
+    dir = find_directory ("")->contents;
+#else /* !AMIGA */
+    dir = find_directory (".")->contents;
+#endif /* AMIGA */
+  else
+    {
+      const char *dirname;
+      const char *slash = dirend;
+      if (dirend == filename)
+        dirname = "/";
+      else
+        {
+          char *cp;
+#ifdef HAVE_DOS_PATHS
+          /* d:/ and d: are *very* different...  */
+          if (dirend < filename + 3 && filename[1] == ':' &&
+              (*dirend == '/' || *dirend == '\\' || *dirend == ':'))
+            dirend++;
+#endif
+          cp = alloca (dirend - filename + 1);
+          memcpy (cp, filename, dirend - filename);
+          cp[dirend - filename] = '\0';
+          dirname = cp;
+        }
+      dir = find_directory (dirname)->contents;
+#ifdef VMS
+      if (*slash == '/')
+        filename = slash + 1;
+      else
+        filename = slash;
+#else
+      filename = slash + 1;
+#endif
+    }
+
+  if (dir == 0 || dir->dirfiles.ht_vec == 0)
+    /* There are no files entered for this directory.  */
+    return 0;
+
+#ifdef __MSDOS__
+  filename = dosify (filename);
+#endif
+#ifdef HAVE_CASE_INSENSITIVE_FS
+  filename = downcase (filename);
+#endif
+#ifdef VMS
+  if (want_vmsify)
+    filename = vmsify (filename, 1);
+#endif
+
+  dirfile_key.name = filename;
+  dirfile_key.length = strlen (filename);
+  dirfile = hash_find_item (&dir->dirfiles, &dirfile_key);
+  if (dirfile)
+    return dirfile->impossible;
+
+  return 0;
+}
+
+/* Return the already allocated name in the
+   directory hash table that matches DIR.  */
+
+const char *
+dir_name (const char *dir)
+{
+  return find_directory (dir)->name;
+}
+
+/* Print the data base of directories.  */
+
+void
+print_dir_data_base (void)
+{
+  unsigned int files;
+  unsigned int impossible;
+  struct directory **dir_slot;
+  struct directory **dir_end;
+
+  puts (_("\n# Directories\n"));
+
+  files = impossible = 0;
+
+  dir_slot = (struct directory **) directories.ht_vec;
+  dir_end = dir_slot + directories.ht_size;
+  for ( ; dir_slot < dir_end; dir_slot++)
+    {
+      struct directory *dir = *dir_slot;
+      if (! HASH_VACANT (dir))
+        {
+          if (dir->contents == 0)
+            printf (_("# %s: could not be stat'd.\n"), dir->name);
+          else if (dir->contents->dirfiles.ht_vec == 0)
+            {
+#ifdef WINDOWS32
+              printf (_("# %s (key %s, mtime %I64u): could not be opened.\n"),
+                      dir->name, dir->contents->path_key,
+                      (unsigned long long)dir->contents->mtime);
+#else  /* WINDOWS32 */
+#ifdef VMS_INO_T
+              printf (_("# %s (device %d, inode [%d,%d,%d]): could not be opened.\n"),
+                      dir->name, dir->contents->dev,
+                      dir->contents->ino[0], dir->contents->ino[1],
+                      dir->contents->ino[2]);
+#else
+              printf (_("# %s (device %ld, inode %ld): could not be opened.\n"),
+                      dir->name, (long int) dir->contents->dev,
+                      (long int) dir->contents->ino);
+#endif
+#endif /* WINDOWS32 */
+            }
+          else
+            {
+              unsigned int f = 0;
+              unsigned int im = 0;
+              struct dirfile **files_slot;
+              struct dirfile **files_end;
+
+              files_slot = (struct dirfile **) dir->contents->dirfiles.ht_vec;
+              files_end = files_slot + dir->contents->dirfiles.ht_size;
+              for ( ; files_slot < files_end; files_slot++)
+                {
+                  struct dirfile *df = *files_slot;
+                  if (! HASH_VACANT (df))
+                    {
+                      if (df->impossible)
+                        ++im;
+                      else
+                        ++f;
+                    }
+                }
+#ifdef WINDOWS32
+              printf (_("# %s (key %s, mtime %I64u): "),
+                      dir->name, dir->contents->path_key,
+                      (unsigned long long)dir->contents->mtime);
+#else  /* WINDOWS32 */
+#ifdef VMS_INO_T
+              printf (_("# %s (device %d, inode [%d,%d,%d]): "),
+                      dir->name, dir->contents->dev,
+                      dir->contents->ino[0], dir->contents->ino[1],
+                      dir->contents->ino[2]);
+#else
+              printf (_("# %s (device %ld, inode %ld): "),
+                      dir->name,
+                      (long)dir->contents->dev, (long)dir->contents->ino);
+#endif
+#endif /* WINDOWS32 */
+              if (f == 0)
+                fputs (_("No"), stdout);
+              else
+                printf ("%u", f);
+              fputs (_(" files, "), stdout);
+              if (im == 0)
+                fputs (_("no"), stdout);
+              else
+                printf ("%u", im);
+              fputs (_(" impossibilities"), stdout);
+              if (dir->contents->dirstream == 0)
+                puts (".");
+              else
+                puts (_(" so far."));
+              files += f;
+              impossible += im;
+            }
+        }
+    }
+
+  fputs ("\n# ", stdout);
+  if (files == 0)
+    fputs (_("No"), stdout);
+  else
+    printf ("%u", files);
+  fputs (_(" files, "), stdout);
+  if (impossible == 0)
+    fputs (_("no"), stdout);
+  else
+    printf ("%u", impossible);
+  printf (_(" impossibilities in %lu directories.\n"), directories.ht_fill);
+}
+
+/* Hooks for globbing.  */
+
+/* Structure describing state of iterating through a directory hash table.  */
+
+struct dirstream
+  {
+    struct directory_contents *contents; /* The directory being read.  */
+    struct dirfile **dirfile_slot; /* Current slot in table.  */
+  };
+
+/* Forward declarations.  */
+static __ptr_t open_dirstream (const char *);
+static struct dirent *read_dirstream (__ptr_t);
+
+static __ptr_t
+open_dirstream (const char *directory)
+{
+  struct dirstream *new;
+  struct directory *dir = find_directory (directory);
+
+  if (dir->contents == 0 || dir->contents->dirfiles.ht_vec == 0)
+    /* DIR->contents is nil if the directory could not be stat'd.
+       DIR->contents->dirfiles is nil if it could not be opened.  */
+    return 0;
+
+  /* Read all the contents of the directory now.  There is no benefit
+     in being lazy, since glob will want to see every file anyway.  */
+
+  dir_contents_file_exists_p (dir->contents, 0);
+
+  new = xmalloc (sizeof (struct dirstream));
+  new->contents = dir->contents;
+  new->dirfile_slot = (struct dirfile **) new->contents->dirfiles.ht_vec;
+
+  return (__ptr_t) new;
+}
+
+static struct dirent *
+read_dirstream (__ptr_t stream)
+{
+  static char *buf;
+  static unsigned int bufsz;
+
+  struct dirstream *const ds = (struct dirstream *) stream;
+  struct directory_contents *dc = ds->contents;
+  struct dirfile **dirfile_end = (struct dirfile **) dc->dirfiles.ht_vec + dc->dirfiles.ht_size;
+
+  while (ds->dirfile_slot < dirfile_end)
+    {
+      struct dirfile *df = *ds->dirfile_slot++;
+      if (! HASH_VACANT (df) && !df->impossible)
+        {
+          /* The glob interface wants a 'struct dirent', so mock one up.  */
+          struct dirent *d;
+          unsigned int len = df->length + 1;
+          unsigned int sz = sizeof (*d) - sizeof (d->d_name) + len;
+          if (sz > bufsz)
+            {
+              bufsz *= 2;
+              if (sz > bufsz)
+                bufsz = sz;
+              buf = xrealloc (buf, bufsz);
+            }
+          d = (struct dirent *) buf;
+#ifdef __MINGW32__
+# if __MINGW32_MAJOR_VERSION < 3 || (__MINGW32_MAJOR_VERSION == 3 && \
+                                     __MINGW32_MINOR_VERSION == 0)
+          d->d_name = xmalloc (len);
+# endif
+#endif
+          FAKE_DIR_ENTRY (d);
+#ifdef _DIRENT_HAVE_D_NAMLEN
+          d->d_namlen = len - 1;
+#endif
+#ifdef _DIRENT_HAVE_D_TYPE
+          d->d_type = DT_UNKNOWN;
+#endif
+          memcpy (d->d_name, df->name, len);
+          return d;
+        }
+    }
+
+  return 0;
+}
+
+/* On 64 bit ReliantUNIX (5.44 and above) in LFS mode, stat() is actually a
+ * macro for stat64().  If stat is a macro, make a local wrapper function to
+ * invoke it.
+ *
+ * On MS-Windows, stat() "succeeds" for foo/bar/. where foo/bar is a
+ * regular file; fix that here.
+ */
+#if !defined(stat) && !defined(WINDOWS32) || defined(VMS)
+# ifndef VMS
+#  ifndef HAVE_SYS_STAT_H
+int stat (const char *path, struct stat *sbuf);
+#  endif
+# else
+    /* We are done with the fake stat.  Go back to the real stat */
+#   ifdef stat
+#     undef stat
+#   endif
+# endif
+# define local_stat stat
+#else
+static int
+local_stat (const char *path, struct stat *buf)
+{
+  int e;
+#ifdef WINDOWS32
+  size_t plen = strlen (path);
+
+  /* Make sure the parent of "." exists and is a directory, not a
+     file.  This is because 'stat' on Windows normalizes the argument
+     foo/. => foo without checking first that foo is a directory.  */
+  if (plen > 1 && path[plen - 1] == '.'
+      && (path[plen - 2] == '/' || path[plen - 2] == '\\'))
+    {
+      char parent[MAXPATHLEN];
+
+      strncpy (parent, path, plen - 2);
+      parent[plen - 2] = '\0';
+      if (stat (parent, buf) < 0 || !_S_ISDIR (buf->st_mode))
+        return -1;
+    }
+#endif
+
+  EINTRLOOP (e, stat (path, buf));
+  return e;
+}
+#endif
+
+/* Similarly for lstat.  */
+#if !defined(lstat) && !defined(WINDOWS32) || defined(VMS)
+# ifndef VMS
+#  ifndef HAVE_SYS_STAT_H
+int lstat (const char *path, struct stat *sbuf);
+#  endif
+# else
+    /* We are done with the fake lstat.  Go back to the real lstat */
+#   ifdef lstat
+#     undef lstat
+#   endif
+# endif
+# define local_lstat lstat
+#elif defined(WINDOWS32)
+/* Windows doesn't support lstat().  */
+# define local_lstat local_stat
+#else
+static int
+local_lstat (const char *path, struct stat *buf)
+{
+  int e;
+  EINTRLOOP (e, lstat (path, buf));
+  return e;
+}
+#endif
+
+void
+dir_setup_glob (glob_t *gl)
+{
+  gl->gl_opendir = open_dirstream;
+  gl->gl_readdir = read_dirstream;
+  gl->gl_closedir = free;
+  gl->gl_lstat = local_lstat;
+  gl->gl_stat = local_stat;
+}
+
+void
+hash_init_directories (void)
+{
+  hash_init (&directories, DIRECTORY_BUCKETS,
+             directory_hash_1, directory_hash_2, directory_hash_cmp);
+  hash_init (&directory_contents, DIRECTORY_BUCKETS,
+             directory_contents_hash_1, directory_contents_hash_2,
+             directory_contents_hash_cmp);
+}
diff --git a/src/expand.c b/src/expand.c
new file mode 100644
index 0000000..3341f9e
--- /dev/null
+++ b/src/expand.c
@@ -0,0 +1,597 @@
+/* Variable expansion functions for GNU Make.
+Copyright (C) 1988-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+
+#include <assert.h>
+
+#include "filedef.h"
+#include "job.h"
+#include "commands.h"
+#include "variable.h"
+#include "rule.h"
+
+/* Initially, any errors reported when expanding strings will be reported
+   against the file where the error appears.  */
+const floc **expanding_var = &reading_file;
+
+/* The next two describe the variable output buffer.
+   This buffer is used to hold the variable-expansion of a line of the
+   makefile.  It is made bigger with realloc whenever it is too small.
+   variable_buffer_length is the size currently allocated.
+   variable_buffer is the address of the buffer.
+
+   For efficiency, it's guaranteed that the buffer will always have
+   VARIABLE_BUFFER_ZONE extra bytes allocated.  This allows you to add a few
+   extra chars without having to call a function.  Note you should never use
+   these bytes unless you're _sure_ you have room (you know when the buffer
+   length was last checked.  */
+
+#define VARIABLE_BUFFER_ZONE    5
+
+static unsigned int variable_buffer_length;
+char *variable_buffer;
+
+/* Subroutine of variable_expand and friends:
+   The text to add is LENGTH chars starting at STRING to the variable_buffer.
+   The text is added to the buffer at PTR, and the updated pointer into
+   the buffer is returned as the value.  Thus, the value returned by
+   each call to variable_buffer_output should be the first argument to
+   the following call.  */
+
+char *
+variable_buffer_output (char *ptr, const char *string, unsigned int length)
+{
+  unsigned int newlen = length + (ptr - variable_buffer);
+
+  if ((newlen + VARIABLE_BUFFER_ZONE) > variable_buffer_length)
+    {
+      unsigned int offset = ptr - variable_buffer;
+      variable_buffer_length = (newlen + 100 > 2 * variable_buffer_length
+                                ? newlen + 100
+                                : 2 * variable_buffer_length);
+      variable_buffer = xrealloc (variable_buffer, variable_buffer_length);
+      ptr = variable_buffer + offset;
+    }
+
+  memcpy (ptr, string, length);
+  return ptr + length;
+}
+
+/* Return a pointer to the beginning of the variable buffer.  */
+
+static char *
+initialize_variable_output (void)
+{
+  /* If we don't have a variable output buffer yet, get one.  */
+
+  if (variable_buffer == 0)
+    {
+      variable_buffer_length = 200;
+      variable_buffer = xmalloc (variable_buffer_length);
+      variable_buffer[0] = '\0';
+    }
+
+  return variable_buffer;
+}
+
+/* Recursively expand V.  The returned string is malloc'd.  */
+
+static char *allocated_variable_append (const struct variable *v);
+
+char *
+recursively_expand_for_file (struct variable *v, struct file *file)
+{
+  char *value;
+  const floc *this_var;
+  const floc **saved_varp;
+  struct variable_set_list *save = 0;
+  int set_reading = 0;
+
+  /* Don't install a new location if this location is empty.
+     This can happen for command-line variables, builtin variables, etc.  */
+  saved_varp = expanding_var;
+  if (v->fileinfo.filenm)
+    {
+      this_var = &v->fileinfo;
+      expanding_var = &this_var;
+    }
+
+  /* If we have no other file-reading context, use the variable's context. */
+  if (!reading_file)
+    {
+      set_reading = 1;
+      reading_file = &v->fileinfo;
+    }
+
+  if (v->expanding)
+    {
+      if (!v->exp_count)
+        /* Expanding V causes infinite recursion.  Lose.  */
+        OS (fatal, *expanding_var,
+            _("Recursive variable '%s' references itself (eventually)"),
+            v->name);
+      --v->exp_count;
+    }
+
+  if (file)
+    {
+      save = current_variable_set_list;
+      current_variable_set_list = file->variables;
+    }
+
+  v->expanding = 1;
+  if (v->append)
+    value = allocated_variable_append (v);
+  else
+    value = allocated_variable_expand (v->value);
+  v->expanding = 0;
+
+  if (set_reading)
+    reading_file = 0;
+
+  if (file)
+    current_variable_set_list = save;
+
+  expanding_var = saved_varp;
+
+  return value;
+}
+
+/* Expand a simple reference to variable NAME, which is LENGTH chars long.  */
+
+#ifdef __GNUC__
+__inline
+#endif
+static char *
+reference_variable (char *o, const char *name, unsigned int length)
+{
+  struct variable *v;
+  char *value;
+
+  v = lookup_variable (name, length);
+
+  if (v == 0)
+    warn_undefined (name, length);
+
+  /* If there's no variable by that name or it has no value, stop now.  */
+  if (v == 0 || (*v->value == '\0' && !v->append))
+    return o;
+
+  value = (v->recursive ? recursively_expand (v) : v->value);
+
+  o = variable_buffer_output (o, value, strlen (value));
+
+  if (v->recursive)
+    free (value);
+
+  return o;
+}
+
+/* Scan STRING for variable references and expansion-function calls.  Only
+   LENGTH bytes of STRING are actually scanned.  If LENGTH is -1, scan until
+   a null byte is found.
+
+   Write the results to LINE, which must point into 'variable_buffer'.  If
+   LINE is NULL, start at the beginning of the buffer.
+   Return a pointer to LINE, or to the beginning of the buffer if LINE is
+   NULL.
+ */
+char *
+variable_expand_string (char *line, const char *string, long length)
+{
+  struct variable *v;
+  const char *p, *p1;
+  char *save;
+  char *o;
+  unsigned int line_offset;
+
+  if (!line)
+    line = initialize_variable_output ();
+  o = line;
+  line_offset = line - variable_buffer;
+
+  if (length == 0)
+    {
+      variable_buffer_output (o, "", 1);
+      return (variable_buffer);
+    }
+
+  /* We need a copy of STRING: due to eval, it's possible that it will get
+     freed as we process it (it might be the value of a variable that's reset
+     for example).  Also having a nil-terminated string is handy.  */
+  save = length < 0 ? xstrdup (string) : xstrndup (string, length);
+  p = save;
+
+  while (1)
+    {
+      /* Copy all following uninteresting chars all at once to the
+         variable output buffer, and skip them.  Uninteresting chars end
+         at the next $ or the end of the input.  */
+
+      p1 = strchr (p, '$');
+
+      o = variable_buffer_output (o, p, p1 != 0 ? (unsigned int)(p1 - p) : strlen (p) + 1);
+
+      if (p1 == 0)
+        break;
+      p = p1 + 1;
+
+      /* Dispatch on the char that follows the $.  */
+
+      switch (*p)
+        {
+        case '$':
+        case '\0':
+          /* $$ or $ at the end of the string means output one $ to the
+             variable output buffer.  */
+          o = variable_buffer_output (o, p1, 1);
+          break;
+
+        case '(':
+        case '{':
+          /* $(...) or ${...} is the general case of substitution.  */
+          {
+            char openparen = *p;
+            char closeparen = (openparen == '(') ? ')' : '}';
+            const char *begp;
+            const char *beg = p + 1;
+            char *op;
+            char *abeg = NULL;
+            const char *end, *colon;
+
+            op = o;
+            begp = p;
+            if (handle_function (&op, &begp))
+              {
+                o = op;
+                p = begp;
+                break;
+              }
+
+            /* Is there a variable reference inside the parens or braces?
+               If so, expand it before expanding the entire reference.  */
+
+            end = strchr (beg, closeparen);
+            if (end == 0)
+              /* Unterminated variable reference.  */
+              O (fatal, *expanding_var, _("unterminated variable reference"));
+            p1 = lindex (beg, end, '$');
+            if (p1 != 0)
+              {
+                /* BEG now points past the opening paren or brace.
+                   Count parens or braces until it is matched.  */
+                int count = 0;
+                for (p = beg; *p != '\0'; ++p)
+                  {
+                    if (*p == openparen)
+                      ++count;
+                    else if (*p == closeparen && --count < 0)
+                      break;
+                  }
+                /* If COUNT is >= 0, there were unmatched opening parens
+                   or braces, so we go to the simple case of a variable name
+                   such as '$($(a)'.  */
+                if (count < 0)
+                  {
+                    abeg = expand_argument (beg, p); /* Expand the name.  */
+                    beg = abeg;
+                    end = strchr (beg, '\0');
+                  }
+              }
+            else
+              /* Advance P to the end of this reference.  After we are
+                 finished expanding this one, P will be incremented to
+                 continue the scan.  */
+              p = end;
+
+            /* This is not a reference to a built-in function and
+               any variable references inside are now expanded.
+               Is the resultant text a substitution reference?  */
+
+            colon = lindex (beg, end, ':');
+            if (colon)
+              {
+                /* This looks like a substitution reference: $(FOO:A=B).  */
+                const char *subst_beg = colon + 1;
+                const char *subst_end = lindex (subst_beg, end, '=');
+                if (subst_end == 0)
+                  /* There is no = in sight.  Punt on the substitution
+                     reference and treat this as a variable name containing
+                     a colon, in the code below.  */
+                  colon = 0;
+                else
+                  {
+                    const char *replace_beg = subst_end + 1;
+                    const char *replace_end = end;
+
+                    /* Extract the variable name before the colon
+                       and look up that variable.  */
+                    v = lookup_variable (beg, colon - beg);
+                    if (v == 0)
+                      warn_undefined (beg, colon - beg);
+
+                    /* If the variable is not empty, perform the
+                       substitution.  */
+                    if (v != 0 && *v->value != '\0')
+                      {
+                        char *pattern, *replace, *ppercent, *rpercent;
+                        char *value = (v->recursive
+                                       ? recursively_expand (v)
+                                       : v->value);
+
+                        /* Copy the pattern and the replacement.  Add in an
+                           extra % at the beginning to use in case there
+                           isn't one in the pattern.  */
+                        pattern = alloca (subst_end - subst_beg + 2);
+                        *(pattern++) = '%';
+                        memcpy (pattern, subst_beg, subst_end - subst_beg);
+                        pattern[subst_end - subst_beg] = '\0';
+
+                        replace = alloca (replace_end - replace_beg + 2);
+                        *(replace++) = '%';
+                        memcpy (replace, replace_beg,
+                               replace_end - replace_beg);
+                        replace[replace_end - replace_beg] = '\0';
+
+                        /* Look for %.  Set the percent pointers properly
+                           based on whether we find one or not.  */
+                        ppercent = find_percent (pattern);
+                        if (ppercent)
+                          {
+                            ++ppercent;
+                            rpercent = find_percent (replace);
+                            if (rpercent)
+                              ++rpercent;
+                          }
+                        else
+                          {
+                            ppercent = pattern;
+                            rpercent = replace;
+                            --pattern;
+                            --replace;
+                          }
+
+                        o = patsubst_expand_pat (o, value, pattern, replace,
+                                                 ppercent, rpercent);
+
+                        if (v->recursive)
+                          free (value);
+                      }
+                  }
+              }
+
+            if (colon == 0)
+              /* This is an ordinary variable reference.
+                 Look up the value of the variable.  */
+                o = reference_variable (o, beg, end - beg);
+
+            free (abeg);
+          }
+          break;
+
+        default:
+          if (ISSPACE (p[-1]))
+            break;
+
+          /* A $ followed by a random char is a variable reference:
+             $a is equivalent to $(a).  */
+          o = reference_variable (o, p, 1);
+
+          break;
+        }
+
+      if (*p == '\0')
+        break;
+
+      ++p;
+    }
+
+  free (save);
+
+  variable_buffer_output (o, "", 1);
+  return (variable_buffer + line_offset);
+}
+
+/* Scan LINE for variable references and expansion-function calls.
+   Build in 'variable_buffer' the result of expanding the references and calls.
+   Return the address of the resulting string, which is null-terminated
+   and is valid only until the next time this function is called.  */
+
+char *
+variable_expand (const char *line)
+{
+  return variable_expand_string (NULL, line, (long)-1);
+}
+
+/* Expand an argument for an expansion function.
+   The text starting at STR and ending at END is variable-expanded
+   into a null-terminated string that is returned as the value.
+   This is done without clobbering 'variable_buffer' or the current
+   variable-expansion that is in progress.  */
+
+char *
+expand_argument (const char *str, const char *end)
+{
+  char *tmp, *alloc = NULL;
+  char *r;
+
+  if (str == end)
+    return xstrdup ("");
+
+  if (!end || *end == '\0')
+    return allocated_variable_expand (str);
+
+  if (end - str + 1 > 1000)
+    tmp = alloc = xmalloc (end - str + 1);
+  else
+    tmp = alloca (end - str + 1);
+
+  memcpy (tmp, str, end - str);
+  tmp[end - str] = '\0';
+
+  r = allocated_variable_expand (tmp);
+
+  free (alloc);
+
+  return r;
+}
+
+/* Expand LINE for FILE.  Error messages refer to the file and line where
+   FILE's commands were found.  Expansion uses FILE's variable set list.  */
+
+char *
+variable_expand_for_file (const char *line, struct file *file)
+{
+  char *result;
+  struct variable_set_list *savev;
+  const floc *savef;
+
+  if (file == 0)
+    return variable_expand (line);
+
+  savev = current_variable_set_list;
+  current_variable_set_list = file->variables;
+
+  savef = reading_file;
+  if (file->cmds && file->cmds->fileinfo.filenm)
+    reading_file = &file->cmds->fileinfo;
+  else
+    reading_file = 0;
+
+  result = variable_expand (line);
+
+  current_variable_set_list = savev;
+  reading_file = savef;
+
+  return result;
+}
+
+/* Like allocated_variable_expand, but for += target-specific variables.
+   First recursively construct the variable value from its appended parts in
+   any upper variable sets.  Then expand the resulting value.  */
+
+static char *
+variable_append (const char *name, unsigned int length,
+                 const struct variable_set_list *set, int local)
+{
+  const struct variable *v;
+  char *buf = 0;
+  int nextlocal;
+
+  /* If there's nothing left to check, return the empty buffer.  */
+  if (!set)
+    return initialize_variable_output ();
+
+  /* If this set is local and the next is not a parent, then next is local.  */
+  nextlocal = local && set->next_is_parent == 0;
+
+  /* Try to find the variable in this variable set.  */
+  v = lookup_variable_in_set (name, length, set->set);
+
+  /* If there isn't one, or this one is private, try the set above us.  */
+  if (!v || (!local && v->private_var))
+    return variable_append (name, length, set->next, nextlocal);
+
+  /* If this variable type is append, first get any upper values.
+     If not, initialize the buffer.  */
+  if (v->append)
+    buf = variable_append (name, length, set->next, nextlocal);
+  else
+    buf = initialize_variable_output ();
+
+  /* Append this value to the buffer, and return it.
+     If we already have a value, first add a space.  */
+  if (buf > variable_buffer)
+    buf = variable_buffer_output (buf, " ", 1);
+
+  /* Either expand it or copy it, depending.  */
+  if (! v->recursive)
+    return variable_buffer_output (buf, v->value, strlen (v->value));
+
+  buf = variable_expand_string (buf, v->value, strlen (v->value));
+  return (buf + strlen (buf));
+}
+
+
+static char *
+allocated_variable_append (const struct variable *v)
+{
+  char *val;
+
+  /* Construct the appended variable value.  */
+
+  char *obuf = variable_buffer;
+  unsigned int olen = variable_buffer_length;
+
+  variable_buffer = 0;
+
+  val = variable_append (v->name, strlen (v->name),
+                         current_variable_set_list, 1);
+  variable_buffer_output (val, "", 1);
+  val = variable_buffer;
+
+  variable_buffer = obuf;
+  variable_buffer_length = olen;
+
+  return val;
+}
+
+/* Like variable_expand_for_file, but the returned string is malloc'd.
+   This function is called a lot.  It wants to be efficient.  */
+
+char *
+allocated_variable_expand_for_file (const char *line, struct file *file)
+{
+  char *value;
+
+  char *obuf = variable_buffer;
+  unsigned int olen = variable_buffer_length;
+
+  variable_buffer = 0;
+
+  value = variable_expand_for_file (line, file);
+
+  variable_buffer = obuf;
+  variable_buffer_length = olen;
+
+  return value;
+}
+
+/* Install a new variable_buffer context, returning the current one for
+   safe-keeping.  */
+
+void
+install_variable_buffer (char **bufp, unsigned int *lenp)
+{
+  *bufp = variable_buffer;
+  *lenp = variable_buffer_length;
+
+  variable_buffer = 0;
+  initialize_variable_output ();
+}
+
+/* Restore a previously-saved variable_buffer setting (free the current one).
+ */
+
+void
+restore_variable_buffer (char *buf, unsigned int len)
+{
+  free (variable_buffer);
+
+  variable_buffer = buf;
+  variable_buffer_length = len;
+}
diff --git a/src/file.c b/src/file.c
new file mode 100644
index 0000000..fe58eba
--- /dev/null
+++ b/src/file.c
@@ -0,0 +1,1148 @@
+/* Target file management for GNU Make.
+Copyright (C) 1988-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+
+#include <assert.h>
+
+#include "filedef.h"
+#include "dep.h"
+#include "job.h"
+#include "commands.h"
+#include "variable.h"
+#include "debug.h"
+#include "hash.h"
+
+
+/* Remember whether snap_deps has been invoked: we need this to be sure we
+   don't add new rules (via $(eval ...)) afterwards.  In the future it would
+   be nice to support this, but it means we'd need to re-run snap_deps() or
+   at least its functionality... it might mean changing snap_deps() to be run
+   per-file, so we can invoke it after the eval... or remembering which files
+   in the hash have been snapped (a new boolean flag?) and having snap_deps()
+   only work on files which have not yet been snapped. */
+int snapped_deps = 0;
+
+/* Hash table of files the makefile knows how to make.  */
+
+static unsigned long
+file_hash_1 (const void *key)
+{
+  return_ISTRING_HASH_1 (((struct file const *) key)->hname);
+}
+
+static unsigned long
+file_hash_2 (const void *key)
+{
+  return_ISTRING_HASH_2 (((struct file const *) key)->hname);
+}
+
+static int
+file_hash_cmp (const void *x, const void *y)
+{
+  return_ISTRING_COMPARE (((struct file const *) x)->hname,
+                          ((struct file const *) y)->hname);
+}
+
+static struct hash_table files;
+
+/* Whether or not .SECONDARY with no prerequisites was given.  */
+static int all_secondary = 0;
+
+/* Access the hash table of all file records.
+   lookup_file  given a name, return the struct file * for that name,
+                or nil if there is none.
+*/
+
+struct file *
+lookup_file (const char *name)
+{
+  struct file *f;
+  struct file file_key;
+#ifdef VMS
+  int want_vmsify;
+#ifndef WANT_CASE_SENSITIVE_TARGETS
+  char *lname;
+#endif
+#endif
+
+  assert (*name != '\0');
+
+  /* This is also done in parse_file_seq, so this is redundant
+     for names read from makefiles.  It is here for names passed
+     on the command line.  */
+#ifdef VMS
+   want_vmsify = (strpbrk (name, "]>:^") != NULL);
+# ifndef WANT_CASE_SENSITIVE_TARGETS
+  if (*name != '.')
+    {
+      const char *n;
+      char *ln;
+      lname = xstrdup (name);
+      for (n = name, ln = lname; *n != '\0'; ++n, ++ln)
+        *ln = isupper ((unsigned char)*n) ? tolower ((unsigned char)*n) : *n;
+      *ln = '\0';
+      name = lname;
+    }
+# endif
+
+  while (name[0] == '[' && name[1] == ']' && name[2] != '\0')
+      name += 2;
+  while (name[0] == '<' && name[1] == '>' && name[2] != '\0')
+      name += 2;
+#endif
+  while (name[0] == '.'
+#ifdef HAVE_DOS_PATHS
+         && (name[1] == '/' || name[1] == '\\')
+#else
+         && name[1] == '/'
+#endif
+         && name[2] != '\0')
+    {
+      name += 2;
+      while (*name == '/'
+#ifdef HAVE_DOS_PATHS
+             || *name == '\\'
+#endif
+             )
+        /* Skip following slashes: ".//foo" is "foo", not "/foo".  */
+        ++name;
+    }
+
+  if (*name == '\0')
+    {
+      /* It was all slashes after a dot.  */
+#if defined(_AMIGA)
+      name = "";
+#else
+      name = "./";
+#endif
+#if defined(VMS)
+      /* TODO - This section is probably not needed. */
+      if (want_vmsify)
+        name = "[]";
+#endif
+    }
+  file_key.hname = name;
+  f = hash_find_item (&files, &file_key);
+#if defined(VMS) && !defined(WANT_CASE_SENSITIVE_TARGETS)
+  if (*name != '.')
+    free (lname);
+#endif
+
+  return f;
+}
+
+/* Look up a file record for file NAME and return it.
+   Create a new record if one doesn't exist.  NAME will be stored in the
+   new record so it should be constant or in the strcache etc.
+ */
+
+struct file *
+enter_file (const char *name)
+{
+  struct file *f;
+  struct file *new;
+  struct file **file_slot;
+  struct file file_key;
+
+  assert (*name != '\0');
+  assert (! verify_flag || strcache_iscached (name));
+
+#if defined(VMS) && !defined(WANT_CASE_SENSITIVE_TARGETS)
+  if (*name != '.')
+    {
+      const char *n;
+      char *lname, *ln;
+      lname = xstrdup (name);
+      for (n = name, ln = lname; *n != '\0'; ++n, ++ln)
+        if (isupper ((unsigned char)*n))
+          *ln = tolower ((unsigned char)*n);
+        else
+          *ln = *n;
+
+      *ln = '\0';
+      name = strcache_add (lname);
+      free (lname);
+    }
+#endif
+
+  file_key.hname = name;
+  file_slot = (struct file **) hash_find_slot (&files, &file_key);
+  f = *file_slot;
+  if (! HASH_VACANT (f) && !f->double_colon)
+    {
+      f->builtin = 0;
+      return f;
+    }
+
+  new = xcalloc (sizeof (struct file));
+  new->name = new->hname = name;
+  new->update_status = us_none;
+
+  if (HASH_VACANT (f))
+    {
+      new->last = new;
+      hash_insert_at (&files, new, file_slot);
+    }
+  else
+    {
+      /* There is already a double-colon entry for this file.  */
+      new->double_colon = f;
+      f->last->prev = new;
+      f->last = new;
+    }
+
+  return new;
+}
+
+/* Rehash FILE to NAME.  This is not as simple as resetting
+   the 'hname' member, since it must be put in a new hash bucket,
+   and possibly merged with an existing file called NAME.  */
+
+void
+rehash_file (struct file *from_file, const char *to_hname)
+{
+  struct file file_key;
+  struct file **file_slot;
+  struct file *to_file;
+  struct file *deleted_file;
+  struct file *f;
+
+  /* If it's already that name, we're done.  */
+  from_file->builtin = 0;
+  file_key.hname = to_hname;
+  if (! file_hash_cmp (from_file, &file_key))
+    return;
+
+  /* Find the end of the renamed list for the "from" file.  */
+  file_key.hname = from_file->hname;
+  while (from_file->renamed != 0)
+    from_file = from_file->renamed;
+  if (file_hash_cmp (from_file, &file_key))
+    /* hname changed unexpectedly!! */
+    abort ();
+
+  /* Remove the "from" file from the hash.  */
+  deleted_file = hash_delete (&files, from_file);
+  if (deleted_file != from_file)
+    /* from_file isn't the one stored in files */
+    abort ();
+
+  /* Find where the newly renamed file will go in the hash.  */
+  file_key.hname = to_hname;
+  file_slot = (struct file **) hash_find_slot (&files, &file_key);
+  to_file = *file_slot;
+
+  /* Change the hash name for this file.  */
+  from_file->hname = to_hname;
+  for (f = from_file->double_colon; f != 0; f = f->prev)
+    f->hname = to_hname;
+
+  /* If the new name doesn't exist yet just set it to the renamed file.  */
+  if (HASH_VACANT (to_file))
+    {
+      hash_insert_at (&files, from_file, file_slot);
+      return;
+    }
+
+  /* TO_FILE already exists under TO_HNAME.
+     We must retain TO_FILE and merge FROM_FILE into it.  */
+
+  if (from_file->cmds != 0)
+    {
+      if (to_file->cmds == 0)
+        to_file->cmds = from_file->cmds;
+      else if (from_file->cmds != to_file->cmds)
+        {
+          size_t l = strlen (from_file->name);
+          /* We have two sets of commands.  We will go with the
+             one given in the rule explicitly mentioning this name,
+             but give a message to let the user know what's going on.  */
+          if (to_file->cmds->fileinfo.filenm != 0)
+            error (&from_file->cmds->fileinfo,
+                   l + strlen (to_file->cmds->fileinfo.filenm) + INTSTR_LENGTH,
+                   _("Recipe was specified for file '%s' at %s:%lu,"),
+                   from_file->name, to_file->cmds->fileinfo.filenm,
+                   to_file->cmds->fileinfo.lineno);
+          else
+            error (&from_file->cmds->fileinfo, l,
+                   _("Recipe for file '%s' was found by implicit rule search,"),
+                   from_file->name);
+          l += strlen (to_hname);
+          error (&from_file->cmds->fileinfo, l,
+                 _("but '%s' is now considered the same file as '%s'."),
+                 from_file->name, to_hname);
+          error (&from_file->cmds->fileinfo, l,
+                 _("Recipe for '%s' will be ignored in favor of the one for '%s'."),
+                 to_hname, from_file->name);
+        }
+    }
+
+  /* Merge the dependencies of the two files.  */
+
+  if (to_file->deps == 0)
+    to_file->deps = from_file->deps;
+  else
+    {
+      struct dep *deps = to_file->deps;
+      while (deps->next != 0)
+        deps = deps->next;
+      deps->next = from_file->deps;
+    }
+
+  merge_variable_set_lists (&to_file->variables, from_file->variables);
+
+  if (to_file->double_colon && from_file->is_target && !from_file->double_colon)
+    OSS (fatal, NILF, _("can't rename single-colon '%s' to double-colon '%s'"),
+         from_file->name, to_hname);
+  if (!to_file->double_colon  && from_file->double_colon)
+    {
+      if (to_file->is_target)
+        OSS (fatal, NILF,
+             _("can't rename double-colon '%s' to single-colon '%s'"),
+             from_file->name, to_hname);
+      else
+        to_file->double_colon = from_file->double_colon;
+    }
+
+  if (from_file->last_mtime > to_file->last_mtime)
+    /* %%% Kludge so -W wins on a file that gets vpathized.  */
+    to_file->last_mtime = from_file->last_mtime;
+
+  to_file->mtime_before_update = from_file->mtime_before_update;
+
+#define MERGE(field) to_file->field |= from_file->field
+  MERGE (precious);
+  MERGE (tried_implicit);
+  MERGE (updating);
+  MERGE (updated);
+  MERGE (is_target);
+  MERGE (cmd_target);
+  MERGE (phony);
+  MERGE (loaded);
+  MERGE (ignore_vpath);
+#undef MERGE
+
+  to_file->builtin = 0;
+  from_file->renamed = to_file;
+}
+
+/* Rename FILE to NAME.  This is not as simple as resetting
+   the 'name' member, since it must be put in a new hash bucket,
+   and possibly merged with an existing file called NAME.  */
+
+void
+rename_file (struct file *from_file, const char *to_hname)
+{
+  rehash_file (from_file, to_hname);
+  while (from_file)
+    {
+      from_file->name = from_file->hname;
+      from_file = from_file->prev;
+    }
+}
+
+/* Remove all nonprecious intermediate files.
+   If SIG is nonzero, this was caused by a fatal signal,
+   meaning that a different message will be printed, and
+   the message will go to stderr rather than stdout.  */
+
+void
+remove_intermediates (int sig)
+{
+  struct file **file_slot;
+  struct file **file_end;
+  int doneany = 0;
+
+  /* If there's no way we will ever remove anything anyway, punt early.  */
+  if (question_flag || touch_flag || all_secondary)
+    return;
+
+  if (sig && just_print_flag)
+    return;
+
+  file_slot = (struct file **) files.ht_vec;
+  file_end = file_slot + files.ht_size;
+  for ( ; file_slot < file_end; file_slot++)
+    if (! HASH_VACANT (*file_slot))
+      {
+        struct file *f = *file_slot;
+        /* Is this file eligible for automatic deletion?
+           Yes, IFF: it's marked intermediate, it's not secondary, it wasn't
+           given on the command line, and it's either a -include makefile or
+           it's not precious.  */
+        if (f->intermediate && (f->dontcare || !f->precious)
+            && !f->secondary && !f->cmd_target)
+          {
+            int status;
+            if (f->update_status == us_none)
+              /* If nothing would have created this file yet,
+                 don't print an "rm" command for it.  */
+              continue;
+            if (just_print_flag)
+              status = 0;
+            else
+              {
+                status = unlink (f->name);
+                if (status < 0 && errno == ENOENT)
+                  continue;
+              }
+            if (!f->dontcare)
+              {
+                if (sig)
+                  OS (error, NILF,
+                      _("*** Deleting intermediate file '%s'"), f->name);
+                else
+                  {
+                    if (! doneany)
+                      DB (DB_BASIC, (_("Removing intermediate files...\n")));
+                    if (!silent_flag)
+                      {
+                        if (! doneany)
+                          {
+                            fputs ("rm ", stdout);
+                            doneany = 1;
+                          }
+                        else
+                          putchar (' ');
+                        fputs (f->name, stdout);
+                        fflush (stdout);
+                      }
+                  }
+                if (status < 0)
+                  perror_with_name ("unlink: ", f->name);
+              }
+          }
+      }
+
+  if (doneany && !sig)
+    {
+      putchar ('\n');
+      fflush (stdout);
+    }
+}
+
+/* Given a string containing prerequisites (fully expanded), break it up into
+   a struct dep list.  Enter each of these prereqs into the file database.
+ */
+struct dep *
+split_prereqs (char *p)
+{
+  struct dep *new = PARSE_FILE_SEQ (&p, struct dep, MAP_PIPE, NULL,
+                                    PARSEFS_NONE);
+
+  if (*p)
+    {
+      /* Files that follow '|' are "order-only" prerequisites that satisfy the
+         dependency by existing: their modification times are irrelevant.  */
+      struct dep *ood;
+
+      ++p;
+      ood = PARSE_SIMPLE_SEQ (&p, struct dep);
+
+      if (! new)
+        new = ood;
+      else
+        {
+          struct dep *dp;
+          for (dp = new; dp->next != NULL; dp = dp->next)
+            ;
+          dp->next = ood;
+        }
+
+      for (; ood != NULL; ood = ood->next)
+        ood->ignore_mtime = 1;
+    }
+
+  return new;
+}
+
+/* Given a list of prerequisites, enter them into the file database.
+   If STEM is set then first expand patterns using STEM.  */
+struct dep *
+enter_prereqs (struct dep *deps, const char *stem)
+{
+  struct dep *d1;
+
+  if (deps == 0)
+    return 0;
+
+  /* If we have a stem, expand the %'s.  We use patsubst_expand to translate
+     the prerequisites' patterns into plain prerequisite names.  */
+  if (stem)
+    {
+      const char *pattern = "%";
+      char *buffer = variable_expand ("");
+      struct dep *dp = deps, *dl = 0;
+
+      while (dp != 0)
+        {
+          char *percent;
+          int nl = strlen (dp->name) + 1;
+          char *nm = alloca (nl);
+          memcpy (nm, dp->name, nl);
+          percent = find_percent (nm);
+          if (percent)
+            {
+              char *o;
+
+              /* We have to handle empty stems specially, because that
+                 would be equivalent to $(patsubst %,dp->name,) which
+                 will always be empty.  */
+              if (stem[0] == '\0')
+                {
+                  memmove (percent, percent+1, strlen (percent));
+                  o = variable_buffer_output (buffer, nm, strlen (nm) + 1);
+                }
+              else
+                o = patsubst_expand_pat (buffer, stem, pattern, nm,
+                                         pattern+1, percent+1);
+
+              /* If the name expanded to the empty string, ignore it.  */
+              if (buffer[0] == '\0')
+                {
+                  struct dep *df = dp;
+                  if (dp == deps)
+                    dp = deps = deps->next;
+                  else
+                    dp = dl->next = dp->next;
+                  free_dep (df);
+                  continue;
+                }
+
+              /* Save the name.  */
+              dp->name = strcache_add_len (buffer, o - buffer);
+            }
+          dp->stem = stem;
+          dp->staticpattern = 1;
+          dl = dp;
+          dp = dp->next;
+        }
+    }
+
+  /* Enter them as files, unless they need a 2nd expansion.  */
+  for (d1 = deps; d1 != 0; d1 = d1->next)
+    {
+      if (d1->need_2nd_expansion)
+        continue;
+
+      d1->file = lookup_file (d1->name);
+      if (d1->file == 0)
+        d1->file = enter_file (d1->name);
+      d1->staticpattern = 0;
+      d1->name = 0;
+    }
+
+  return deps;
+}
+
+/* Set the intermediate flag.  */
+
+static void
+set_intermediate (const void *item)
+{
+  struct file *f = (struct file *) item;
+  f->intermediate = 1;
+}
+
+/* Expand and parse each dependency line. */
+static void
+expand_deps (struct file *f)
+{
+  struct dep *d;
+  struct dep **dp;
+  const char *file_stem = f->stem;
+  int initialized = 0;
+
+  f->updating = 0;
+
+  /* Walk through the dependencies.  For any dependency that needs 2nd
+     expansion, expand it then insert the result into the list.  */
+  dp = &f->deps;
+  d = f->deps;
+  while (d != 0)
+    {
+      char *p;
+      struct dep *new, *next;
+      char *name = (char *)d->name;
+
+      if (! d->name || ! d->need_2nd_expansion)
+        {
+          /* This one is all set already.  */
+          dp = &d->next;
+          d = d->next;
+          continue;
+        }
+
+      /* If it's from a static pattern rule, convert the patterns into
+         "$*" so they'll expand properly.  */
+      if (d->staticpattern)
+        {
+          char *o = variable_expand ("");
+          o = subst_expand (o, name, "%", "$*", 1, 2, 0);
+          *o = '\0';
+          free (name);
+          d->name = name = xstrdup (variable_buffer);
+          d->staticpattern = 0;
+        }
+
+      /* We're going to do second expansion so initialize file variables for
+         the file. Since the stem for static pattern rules comes from
+         individual dep lines, we will temporarily set f->stem to d->stem.  */
+      if (!initialized)
+        {
+          initialize_file_variables (f, 0);
+          initialized = 1;
+        }
+
+      if (d->stem != 0)
+        f->stem = d->stem;
+
+      set_file_variables (f);
+
+      p = variable_expand_for_file (d->name, f);
+
+      if (d->stem != 0)
+        f->stem = file_stem;
+
+      /* At this point we don't need the name anymore: free it.  */
+      free (name);
+
+      /* Parse the prerequisites and enter them into the file database.  */
+      new = enter_prereqs (split_prereqs (p), d->stem);
+
+      /* If there were no prereqs here (blank!) then throw this one out.  */
+      if (new == 0)
+        {
+          *dp = d->next;
+          free_dep (d);
+          d = *dp;
+          continue;
+        }
+
+      /* Add newly parsed prerequisites.  */
+      next = d->next;
+      *dp = new;
+      for (dp = &new->next, d = new->next; d != 0; dp = &d->next, d = d->next)
+        ;
+      *dp = next;
+      d = *dp;
+    }
+}
+
+/* Reset the updating flag.  */
+
+static void
+reset_updating (const void *item)
+{
+  struct file *f = (struct file *) item;
+  f->updating = 0;
+}
+
+/* For each dependency of each file, make the 'struct dep' point
+   at the appropriate 'struct file' (which may have to be created).
+
+   Also mark the files depended on by .PRECIOUS, .PHONY, .SILENT,
+   and various other special targets.  */
+
+void
+snap_deps (void)
+{
+  struct file *f;
+  struct file *f2;
+  struct dep *d;
+
+  /* Remember that we've done this.  Once we start snapping deps we can no
+     longer define new targets.  */
+  snapped_deps = 1;
+
+  /* Perform second expansion and enter each dependency name as a file.  We
+     must use hash_dump() here because within these loops we likely add new
+     files to the table, possibly causing an in-situ table expansion.
+
+     We only need to do this if second_expansion has been defined; if it
+     hasn't then all deps were expanded as the makefile was read in.  If we
+     ever change make to be able to unset .SECONDARY_EXPANSION this will have
+     to change.  */
+
+  if (second_expansion)
+    {
+      struct file **file_slot_0 = (struct file **) hash_dump (&files, 0, 0);
+      struct file **file_end = file_slot_0 + files.ht_fill;
+      struct file **file_slot;
+      const char *suffixes;
+
+      /* Expand .SUFFIXES: its prerequisites are used for $$* calc.  */
+      f = lookup_file (".SUFFIXES");
+      suffixes = f ? f->name : 0;
+      for (; f != 0; f = f->prev)
+        expand_deps (f);
+
+      /* For every target that's not .SUFFIXES, expand its prerequisites.  */
+
+      for (file_slot = file_slot_0; file_slot < file_end; file_slot++)
+        for (f = *file_slot; f != 0; f = f->prev)
+          if (f->name != suffixes)
+            expand_deps (f);
+      free (file_slot_0);
+    }
+  else
+    /* We're not doing second expansion, so reset updating.  */
+    hash_map (&files, reset_updating);
+
+  /* Now manage all the special targets.  */
+
+  for (f = lookup_file (".PRECIOUS"); f != 0; f = f->prev)
+    for (d = f->deps; d != 0; d = d->next)
+      for (f2 = d->file; f2 != 0; f2 = f2->prev)
+        f2->precious = 1;
+
+  for (f = lookup_file (".LOW_RESOLUTION_TIME"); f != 0; f = f->prev)
+    for (d = f->deps; d != 0; d = d->next)
+      for (f2 = d->file; f2 != 0; f2 = f2->prev)
+        f2->low_resolution_time = 1;
+
+  for (f = lookup_file (".PHONY"); f != 0; f = f->prev)
+    for (d = f->deps; d != 0; d = d->next)
+      for (f2 = d->file; f2 != 0; f2 = f2->prev)
+        {
+          /* Mark this file as phony nonexistent target.  */
+          f2->phony = 1;
+          f2->is_target = 1;
+          f2->last_mtime = NONEXISTENT_MTIME;
+          f2->mtime_before_update = NONEXISTENT_MTIME;
+        }
+
+  for (f = lookup_file (".INTERMEDIATE"); f != 0; f = f->prev)
+    /* Mark .INTERMEDIATE deps as intermediate files.  */
+    for (d = f->deps; d != 0; d = d->next)
+      for (f2 = d->file; f2 != 0; f2 = f2->prev)
+        f2->intermediate = 1;
+    /* .INTERMEDIATE with no deps does nothing.
+       Marking all files as intermediates is useless since the goal targets
+       would be deleted after they are built.  */
+
+  for (f = lookup_file (".SECONDARY"); f != 0; f = f->prev)
+    /* Mark .SECONDARY deps as both intermediate and secondary.  */
+    if (f->deps)
+      for (d = f->deps; d != 0; d = d->next)
+        for (f2 = d->file; f2 != 0; f2 = f2->prev)
+          f2->intermediate = f2->secondary = 1;
+    /* .SECONDARY with no deps listed marks *all* files that way.  */
+    else
+      {
+        all_secondary = 1;
+        hash_map (&files, set_intermediate);
+      }
+
+  f = lookup_file (".EXPORT_ALL_VARIABLES");
+  if (f != 0 && f->is_target)
+    export_all_variables = 1;
+
+  f = lookup_file (".IGNORE");
+  if (f != 0 && f->is_target)
+    {
+      if (f->deps == 0)
+        ignore_errors_flag = 1;
+      else
+        for (d = f->deps; d != 0; d = d->next)
+          for (f2 = d->file; f2 != 0; f2 = f2->prev)
+            f2->command_flags |= COMMANDS_NOERROR;
+    }
+
+  f = lookup_file (".SILENT");
+  if (f != 0 && f->is_target)
+    {
+      if (f->deps == 0)
+        silent_flag = 1;
+      else
+        for (d = f->deps; d != 0; d = d->next)
+          for (f2 = d->file; f2 != 0; f2 = f2->prev)
+            f2->command_flags |= COMMANDS_SILENT;
+    }
+
+  f = lookup_file (".NOTPARALLEL");
+  if (f != 0 && f->is_target)
+    not_parallel = 1;
+
+#ifndef NO_MINUS_C_MINUS_O
+  /* If .POSIX was defined, remove OUTPUT_OPTION to comply.  */
+  /* This needs more work: what if the user sets this in the makefile?
+  if (posix_pedantic)
+    define_variable_cname ("OUTPUT_OPTION", "", o_default, 1);
+  */
+#endif
+}
+
+/* Set the 'command_state' member of FILE and all its 'also_make's.  */
+
+void
+set_command_state (struct file *file, enum cmd_state state)
+{
+  struct dep *d;
+
+  file->command_state = state;
+
+  for (d = file->also_make; d != 0; d = d->next)
+    d->file->command_state = state;
+}
+
+/* Convert an external file timestamp to internal form.  */
+
+FILE_TIMESTAMP
+file_timestamp_cons (const char *fname, time_t stamp, long int ns)
+{
+  int offset = ORDINARY_MTIME_MIN + (FILE_TIMESTAMP_HI_RES ? ns : 0);
+  FILE_TIMESTAMP s = stamp;
+  FILE_TIMESTAMP product = (FILE_TIMESTAMP) s << FILE_TIMESTAMP_LO_BITS;
+  FILE_TIMESTAMP ts = product + offset;
+
+  if (! (s <= FILE_TIMESTAMP_S (ORDINARY_MTIME_MAX)
+         && product <= ts && ts <= ORDINARY_MTIME_MAX))
+    {
+      char buf[FILE_TIMESTAMP_PRINT_LEN_BOUND + 1];
+      const char *f = fname ? fname : _("Current time");
+      ts = s <= OLD_MTIME ? ORDINARY_MTIME_MIN : ORDINARY_MTIME_MAX;
+      file_timestamp_sprintf (buf, ts);
+      OSS (error, NILF,
+           _("%s: Timestamp out of range; substituting %s"), f, buf);
+    }
+
+  return ts;
+}
+
+/* Return the current time as a file timestamp, setting *RESOLUTION to
+   its resolution.  */
+FILE_TIMESTAMP
+file_timestamp_now (int *resolution)
+{
+  int r;
+  time_t s;
+  int ns;
+
+  /* Don't bother with high-resolution clocks if file timestamps have
+     only one-second resolution.  The code below should work, but it's
+     not worth the hassle of debugging it on hosts where it fails.  */
+#if FILE_TIMESTAMP_HI_RES
+# if HAVE_CLOCK_GETTIME && defined CLOCK_REALTIME
+  {
+    struct timespec timespec;
+    if (clock_gettime (CLOCK_REALTIME, &timespec) == 0)
+      {
+        r = 1;
+        s = timespec.tv_sec;
+        ns = timespec.tv_nsec;
+        goto got_time;
+      }
+  }
+# endif
+# if HAVE_GETTIMEOFDAY
+  {
+    struct timeval timeval;
+    if (gettimeofday (&timeval, 0) == 0)
+      {
+        r = 1000;
+        s = timeval.tv_sec;
+        ns = timeval.tv_usec * 1000;
+        goto got_time;
+      }
+  }
+# endif
+#endif
+
+  r = 1000000000;
+  s = time ((time_t *) 0);
+  ns = 0;
+
+#if FILE_TIMESTAMP_HI_RES
+ got_time:
+#endif
+  *resolution = r;
+  return file_timestamp_cons (0, s, ns);
+}
+
+/* Place into the buffer P a printable representation of the file
+   timestamp TS.  */
+void
+file_timestamp_sprintf (char *p, FILE_TIMESTAMP ts)
+{
+  time_t t = FILE_TIMESTAMP_S (ts);
+  struct tm *tm = localtime (&t);
+
+  if (tm)
+    sprintf (p, "%04d-%02d-%02d %02d:%02d:%02d",
+             tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
+             tm->tm_hour, tm->tm_min, tm->tm_sec);
+  else if (t < 0)
+    sprintf (p, "%ld", (long) t);
+  else
+    sprintf (p, "%lu", (unsigned long) t);
+  p += strlen (p);
+
+  /* Append nanoseconds as a fraction, but remove trailing zeros.  We don't
+     know the actual timestamp resolution, since clock_getres applies only to
+     local times, whereas this timestamp might come from a remote filesystem.
+     So removing trailing zeros is the best guess that we can do.  */
+  sprintf (p, ".%09d", FILE_TIMESTAMP_NS (ts));
+  p += strlen (p) - 1;
+  while (*p == '0')
+    p--;
+  p += *p != '.';
+
+  *p = '\0';
+}
+
+/* Print the data base of files.  */
+
+void
+print_prereqs (const struct dep *deps)
+{
+  const struct dep *ood = 0;
+
+  /* Print all normal dependencies; note any order-only deps.  */
+  for (; deps != 0; deps = deps->next)
+    if (! deps->ignore_mtime)
+      printf (" %s", dep_name (deps));
+    else if (! ood)
+      ood = deps;
+
+  /* Print order-only deps, if we have any.  */
+  if (ood)
+    {
+      printf (" | %s", dep_name (ood));
+      for (ood = ood->next; ood != 0; ood = ood->next)
+        if (ood->ignore_mtime)
+          printf (" %s", dep_name (ood));
+    }
+
+  putchar ('\n');
+}
+
+static void
+print_file (const void *item)
+{
+  const struct file *f = item;
+
+  /* If we're not using builtin targets, don't show them.
+
+     Ideally we'd be able to delete them altogether but currently there's no
+     facility to ever delete a file once it's been added.  */
+  if (no_builtin_rules_flag && f->builtin)
+    return;
+
+  putchar ('\n');
+
+  if (f->cmds && f->cmds->recipe_prefix != cmd_prefix)
+    {
+      fputs (".RECIPEPREFIX = ", stdout);
+      cmd_prefix = f->cmds->recipe_prefix;
+      if (cmd_prefix != RECIPEPREFIX_DEFAULT)
+        putchar (cmd_prefix);
+      putchar ('\n');
+    }
+
+  if (f->variables != 0)
+    print_target_variables (f);
+
+  if (!f->is_target)
+    puts (_("# Not a target:"));
+  printf ("%s:%s", f->name, f->double_colon ? ":" : "");
+  print_prereqs (f->deps);
+
+  if (f->precious)
+    puts (_("#  Precious file (prerequisite of .PRECIOUS)."));
+  if (f->phony)
+    puts (_("#  Phony target (prerequisite of .PHONY)."));
+  if (f->cmd_target)
+    puts (_("#  Command line target."));
+  if (f->dontcare)
+    puts (_("#  A default, MAKEFILES, or -include/sinclude makefile."));
+  if (f->builtin)
+    puts (_("#  Builtin rule"));
+  puts (f->tried_implicit
+        ? _("#  Implicit rule search has been done.")
+        : _("#  Implicit rule search has not been done."));
+  if (f->stem != 0)
+    printf (_("#  Implicit/static pattern stem: '%s'\n"), f->stem);
+  if (f->intermediate)
+    puts (_("#  File is an intermediate prerequisite."));
+  if (f->also_make != 0)
+    {
+      const struct dep *d;
+      fputs (_("#  Also makes:"), stdout);
+      for (d = f->also_make; d != 0; d = d->next)
+        printf (" %s", dep_name (d));
+      putchar ('\n');
+    }
+  if (f->last_mtime == UNKNOWN_MTIME)
+    puts (_("#  Modification time never checked."));
+  else if (f->last_mtime == NONEXISTENT_MTIME)
+    puts (_("#  File does not exist."));
+  else if (f->last_mtime == OLD_MTIME)
+    puts (_("#  File is very old."));
+  else
+    {
+      char buf[FILE_TIMESTAMP_PRINT_LEN_BOUND + 1];
+      file_timestamp_sprintf (buf, f->last_mtime);
+      printf (_("#  Last modified %s\n"), buf);
+    }
+  puts (f->updated
+        ? _("#  File has been updated.") : _("#  File has not been updated."));
+  switch (f->command_state)
+    {
+    case cs_running:
+      puts (_("#  Recipe currently running (THIS IS A BUG)."));
+      break;
+    case cs_deps_running:
+      puts (_("#  Dependencies recipe running (THIS IS A BUG)."));
+      break;
+    case cs_not_started:
+    case cs_finished:
+      switch (f->update_status)
+        {
+        case us_none:
+          break;
+        case us_success:
+          puts (_("#  Successfully updated."));
+          break;
+        case us_question:
+          assert (question_flag);
+          puts (_("#  Needs to be updated (-q is set)."));
+          break;
+        case us_failed:
+          puts (_("#  Failed to be updated."));
+          break;
+        }
+      break;
+    default:
+      puts (_("#  Invalid value in 'command_state' member!"));
+      fflush (stdout);
+      fflush (stderr);
+      abort ();
+    }
+
+  if (f->variables != 0)
+    print_file_variables (f);
+
+  if (f->cmds != 0)
+    print_commands (f->cmds);
+
+  if (f->prev)
+    print_file ((const void *) f->prev);
+}
+
+void
+print_file_data_base (void)
+{
+  puts (_("\n# Files"));
+
+  hash_map (&files, print_file);
+
+  fputs (_("\n# files hash-table stats:\n# "), stdout);
+  hash_print_stats (&files, stdout);
+}
+
+/* Verify the integrity of the data base of files.  */
+
+#define VERIFY_CACHED(_p,_n) \
+    do{                                                                       \
+        if (_p->_n && _p->_n[0] && !strcache_iscached (_p->_n))               \
+          error (NULL, strlen (_p->name) + CSTRLEN (# _n) + strlen (_p->_n),  \
+                 _("%s: Field '%s' not cached: %s"), _p->name, # _n, _p->_n); \
+    }while(0)
+
+static void
+verify_file (const void *item)
+{
+  const struct file *f = item;
+  const struct dep *d;
+
+  VERIFY_CACHED (f, name);
+  VERIFY_CACHED (f, hname);
+  VERIFY_CACHED (f, vpath);
+  VERIFY_CACHED (f, stem);
+
+  /* Check the deps.  */
+  for (d = f->deps; d != 0; d = d->next)
+    {
+      if (! d->need_2nd_expansion)
+        VERIFY_CACHED (d, name);
+      VERIFY_CACHED (d, stem);
+    }
+}
+
+void
+verify_file_data_base (void)
+{
+  hash_map (&files, verify_file);
+}
+
+#define EXPANSION_INCREMENT(_l)  ((((_l) / 500) + 1) * 500)
+
+char *
+build_target_list (char *value)
+{
+  static unsigned long last_targ_count = 0;
+
+  if (files.ht_fill != last_targ_count)
+    {
+      unsigned long max = EXPANSION_INCREMENT (strlen (value));
+      unsigned long len;
+      char *p;
+      struct file **fp = (struct file **) files.ht_vec;
+      struct file **end = &fp[files.ht_size];
+
+      /* Make sure we have at least MAX bytes in the allocated buffer.  */
+      value = xrealloc (value, max);
+
+      p = value;
+      len = 0;
+      for (; fp < end; ++fp)
+        if (!HASH_VACANT (*fp) && (*fp)->is_target)
+          {
+            struct file *f = *fp;
+            int l = strlen (f->name);
+
+            len += l + 1;
+            if (len > max)
+              {
+                unsigned long off = p - value;
+
+                max += EXPANSION_INCREMENT (l + 1);
+                value = xrealloc (value, max);
+                p = &value[off];
+              }
+
+            memcpy (p, f->name, l);
+            p += l;
+            *(p++) = ' ';
+          }
+      *(p-1) = '\0';
+
+      last_targ_count = files.ht_fill;
+    }
+
+  return value;
+}
+
+void
+init_hash_files (void)
+{
+  hash_init (&files, 1000, file_hash_1, file_hash_2, file_hash_cmp);
+}
+
+/* EOF */
diff --git a/src/filedef.h b/src/filedef.h
new file mode 100644
index 0000000..7de6ac0
--- /dev/null
+++ b/src/filedef.h
@@ -0,0 +1,212 @@
+/* Definition of target file data structures for GNU Make.
+Copyright (C) 1988-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+
+/* Structure that represents the info on one file
+   that the makefile says how to make.
+   All of these are chained together through 'next'.  */
+
+#include "hash.h"
+
+struct file
+  {
+    const char *name;
+    const char *hname;          /* Hashed filename */
+    const char *vpath;          /* VPATH/vpath pathname */
+    struct dep *deps;           /* all dependencies, including duplicates */
+    struct commands *cmds;      /* Commands to execute for this target.  */
+    const char *stem;           /* Implicit stem, if an implicit
+                                   rule has been used */
+    struct dep *also_make;      /* Targets that are made by making this.  */
+    struct file *prev;          /* Previous entry for same file name;
+                                   used when there are multiple double-colon
+                                   entries for the same file.  */
+    struct file *last;          /* Last entry for the same file name.  */
+
+    /* File that this file was renamed to.  After any time that a
+       file could be renamed, call 'check_renamed' (below).  */
+    struct file *renamed;
+
+    /* List of variable sets used for this file.  */
+    struct variable_set_list *variables;
+
+    /* Pattern-specific variable reference for this target, or null if there
+       isn't one.  Also see the pat_searched flag, below.  */
+    struct variable_set_list *pat_variables;
+
+    /* Immediate dependent that caused this target to be remade,
+       or nil if there isn't one.  */
+    struct file *parent;
+
+    /* For a double-colon entry, this is the first double-colon entry for
+       the same file.  Otherwise this is null.  */
+    struct file *double_colon;
+
+    FILE_TIMESTAMP last_mtime;  /* File's modtime, if already known.  */
+    FILE_TIMESTAMP mtime_before_update; /* File's modtime before any updating
+                                           has been performed.  */
+    unsigned int considered;    /* equal to 'considered' if file has been
+                                   considered on current scan of goal chain */
+    int command_flags;          /* Flags OR'd in for cmds; see commands.h.  */
+    enum update_status          /* Status of the last attempt to update.  */
+      {
+        us_success = 0,         /* Successfully updated.  Must be 0!  */
+        us_none,                /* No attempt to update has been made.  */
+        us_question,            /* Needs to be updated (-q is is set).  */
+        us_failed               /* Update failed.  */
+      } update_status ENUM_BITFIELD (2);
+    enum cmd_state              /* State of the commands.  */
+      {
+        cs_not_started = 0,     /* Not yet started.  Must be 0!  */
+        cs_deps_running,        /* Dep commands running.  */
+        cs_running,             /* Commands running.  */
+        cs_finished             /* Commands finished.  */
+      } command_state ENUM_BITFIELD (2);
+
+    unsigned int builtin:1;     /* True if the file is a builtin rule. */
+    unsigned int precious:1;    /* Non-0 means don't delete file on quit */
+    unsigned int loaded:1;      /* True if the file is a loaded object. */
+    unsigned int low_resolution_time:1; /* Nonzero if this file's time stamp
+                                           has only one-second resolution.  */
+    unsigned int tried_implicit:1; /* Nonzero if have searched
+                                      for implicit rule for making
+                                      this file; don't search again.  */
+    unsigned int updating:1;    /* Nonzero while updating deps of this file */
+    unsigned int updated:1;     /* Nonzero if this file has been remade.  */
+    unsigned int is_target:1;   /* Nonzero if file is described as target.  */
+    unsigned int cmd_target:1;  /* Nonzero if file was given on cmd line.  */
+    unsigned int phony:1;       /* Nonzero if this is a phony file
+                                   i.e., a prerequisite of .PHONY.  */
+    unsigned int intermediate:1;/* Nonzero if this is an intermediate file.  */
+    unsigned int secondary:1;   /* Nonzero means remove_intermediates should
+                                   not delete it.  */
+    unsigned int dontcare:1;    /* Nonzero if no complaint is to be made if
+                                   this target cannot be remade.  */
+    unsigned int ignore_vpath:1;/* Nonzero if we threw out VPATH name.  */
+    unsigned int pat_searched:1;/* Nonzero if we already searched for
+                                   pattern-specific variables.  */
+    unsigned int no_diag:1;     /* True if the file failed to update and no
+                                   diagnostics has been issued (dontcare). */
+  };
+
+
+extern struct file *default_file;
+
+
+struct file *lookup_file (const char *name);
+struct file *enter_file (const char *name);
+struct dep *split_prereqs (char *prereqstr);
+struct dep *enter_prereqs (struct dep *prereqs, const char *stem);
+void remove_intermediates (int sig);
+void snap_deps (void);
+void rename_file (struct file *file, const char *name);
+void rehash_file (struct file *file, const char *name);
+void set_command_state (struct file *file, enum cmd_state state);
+void notice_finished_file (struct file *file);
+void init_hash_files (void);
+void verify_file_data_base (void);
+char *build_target_list (char *old_list);
+void print_prereqs (const struct dep *deps);
+void print_file_data_base (void);
+int try_implicit_rule (struct file *file, unsigned int depth);
+int stemlen_compare (const void *v1, const void *v2);
+
+#if FILE_TIMESTAMP_HI_RES
+# define FILE_TIMESTAMP_STAT_MODTIME(fname, st) \
+    file_timestamp_cons (fname, (st).st_mtime, (st).ST_MTIM_NSEC)
+#else
+# define FILE_TIMESTAMP_STAT_MODTIME(fname, st) \
+    file_timestamp_cons (fname, (st).st_mtime, 0)
+#endif
+
+/* If FILE_TIMESTAMP is 64 bits (or more), use nanosecond resolution.
+   (Multiply by 2**30 instead of by 10**9 to save time at the cost of
+   slightly decreasing the number of available timestamps.)  With
+   64-bit FILE_TIMESTAMP, this stops working on 2514-05-30 01:53:04
+   UTC, but by then uintmax_t should be larger than 64 bits.  */
+#define FILE_TIMESTAMPS_PER_S (FILE_TIMESTAMP_HI_RES ? 1000000000 : 1)
+#define FILE_TIMESTAMP_LO_BITS (FILE_TIMESTAMP_HI_RES ? 30 : 0)
+
+#define FILE_TIMESTAMP_S(ts) (((ts) - ORDINARY_MTIME_MIN) \
+                              >> FILE_TIMESTAMP_LO_BITS)
+#define FILE_TIMESTAMP_NS(ts) ((int) (((ts) - ORDINARY_MTIME_MIN) \
+                                      & ((1 << FILE_TIMESTAMP_LO_BITS) - 1)))
+
+/* Upper bound on length of string "YYYY-MM-DD HH:MM:SS.NNNNNNNNN"
+   representing a file timestamp.  The upper bound is not necessarily 29,
+   since the year might be less than -999 or greater than 9999.
+
+   Subtract one for the sign bit if in case file timestamps can be negative;
+   subtract FLOOR_LOG2_SECONDS_PER_YEAR to yield an upper bound on how many
+   file timestamp bits might affect the year;
+   302 / 1000 is log10 (2) rounded up;
+   add one for integer division truncation;
+   add one more for a minus sign if file timestamps can be negative;
+   add 4 to allow for any 4-digit epoch year (e.g. 1970);
+   add 25 to allow for "-MM-DD HH:MM:SS.NNNNNNNNN".  */
+#define FLOOR_LOG2_SECONDS_PER_YEAR 24
+#define FILE_TIMESTAMP_PRINT_LEN_BOUND \
+  (((sizeof (FILE_TIMESTAMP) * CHAR_BIT - 1 - FLOOR_LOG2_SECONDS_PER_YEAR) \
+    * 302 / 1000) \
+   + 1 + 1 + 4 + 25)
+
+FILE_TIMESTAMP file_timestamp_cons (char const *, time_t, long int);
+FILE_TIMESTAMP file_timestamp_now (int *);
+void file_timestamp_sprintf (char *p, FILE_TIMESTAMP ts);
+
+/* Return the mtime of file F (a struct file *), caching it.
+   The value is NONEXISTENT_MTIME if the file does not exist.  */
+#define file_mtime(f) file_mtime_1 ((f), 1)
+/* Return the mtime of file F (a struct file *), caching it.
+   Don't search using vpath for the file--if it doesn't actually exist,
+   we don't find it.
+   The value is NONEXISTENT_MTIME if the file does not exist.  */
+#define file_mtime_no_search(f) file_mtime_1 ((f), 0)
+FILE_TIMESTAMP f_mtime (struct file *file, int search);
+#define file_mtime_1(f, v) \
+  ((f)->last_mtime == UNKNOWN_MTIME ? f_mtime ((f), v) : (f)->last_mtime)
+
+/* Special timestamp values.  */
+
+/* The file's timestamp is not yet known.  */
+#define UNKNOWN_MTIME 0
+
+/* The file does not exist.  */
+#define NONEXISTENT_MTIME 1
+
+/* The file does not exist, and we assume that it is older than any
+   actual file.  */
+#define OLD_MTIME 2
+
+/* The smallest and largest ordinary timestamps.  */
+#define ORDINARY_MTIME_MIN (OLD_MTIME + 1)
+#define ORDINARY_MTIME_MAX ((FILE_TIMESTAMP_S (NEW_MTIME) \
+                             << FILE_TIMESTAMP_LO_BITS) \
+                            + ORDINARY_MTIME_MIN + FILE_TIMESTAMPS_PER_S - 1)
+
+/* Modtime value to use for 'infinitely new'.  We used to get the current time
+   from the system and use that whenever we wanted 'new'.  But that causes
+   trouble when the machine running make and the machine holding a file have
+   different ideas about what time it is; and can also lose for 'force'
+   targets, which need to be considered newer than anything that depends on
+   them, even if said dependents' modtimes are in the future.  */
+#define NEW_MTIME INTEGER_TYPE_MAXIMUM (FILE_TIMESTAMP)
+
+#define check_renamed(file) \
+  while ((file)->renamed != 0) (file) = (file)->renamed /* No ; here.  */
+
+/* Have we snapped deps yet?  */
+extern int snapped_deps;
diff --git a/src/function.c b/src/function.c
new file mode 100644
index 0000000..a22352f
--- /dev/null
+++ b/src/function.c
@@ -0,0 +1,2691 @@
+/* Builtin function expansion for GNU Make.
+Copyright (C) 1988-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+#include "filedef.h"
+#include "variable.h"
+#include "dep.h"
+#include "job.h"
+#include "os.h"
+#include "commands.h"
+#include "debug.h"
+
+#ifdef _AMIGA
+#include "amiga.h"
+#endif
+
+
+struct function_table_entry
+  {
+    union {
+      char *(*func_ptr) (char *output, char **argv, const char *fname);
+      gmk_func_ptr alloc_func_ptr;
+    } fptr;
+    const char *name;
+    unsigned char len;
+    unsigned char minimum_args;
+    unsigned char maximum_args;
+    unsigned char expand_args:1;
+    unsigned char alloc_fn:1;
+  };
+
+static unsigned long
+function_table_entry_hash_1 (const void *keyv)
+{
+  const struct function_table_entry *key = keyv;
+  return_STRING_N_HASH_1 (key->name, key->len);
+}
+
+static unsigned long
+function_table_entry_hash_2 (const void *keyv)
+{
+  const struct function_table_entry *key = keyv;
+  return_STRING_N_HASH_2 (key->name, key->len);
+}
+
+static int
+function_table_entry_hash_cmp (const void *xv, const void *yv)
+{
+  const struct function_table_entry *x = xv;
+  const struct function_table_entry *y = yv;
+  int result = x->len - y->len;
+  if (result)
+    return result;
+  return_STRING_N_COMPARE (x->name, y->name, x->len);
+}
+
+static struct hash_table function_table;
+
+
+/* Store into VARIABLE_BUFFER at O the result of scanning TEXT and replacing
+   each occurrence of SUBST with REPLACE. TEXT is null-terminated.  SLEN is
+   the length of SUBST and RLEN is the length of REPLACE.  If BY_WORD is
+   nonzero, substitutions are done only on matches which are complete
+   whitespace-delimited words.  */
+
+char *
+subst_expand (char *o, const char *text, const char *subst, const char *replace,
+              unsigned int slen, unsigned int rlen, int by_word)
+{
+  const char *t = text;
+  const char *p;
+
+  if (slen == 0 && !by_word)
+    {
+      /* The first occurrence of "" in any string is its end.  */
+      o = variable_buffer_output (o, t, strlen (t));
+      if (rlen > 0)
+        o = variable_buffer_output (o, replace, rlen);
+      return o;
+    }
+
+  do
+    {
+      if (by_word && slen == 0)
+        /* When matching by words, the empty string should match
+           the end of each word, rather than the end of the whole text.  */
+        p = end_of_token (next_token (t));
+      else
+        {
+          p = strstr (t, subst);
+          if (p == 0)
+            {
+              /* No more matches.  Output everything left on the end.  */
+              o = variable_buffer_output (o, t, strlen (t));
+              return o;
+            }
+        }
+
+      /* Output everything before this occurrence of the string to replace.  */
+      if (p > t)
+        o = variable_buffer_output (o, t, p - t);
+
+      /* If we're substituting only by fully matched words,
+         or only at the ends of words, check that this case qualifies.  */
+      if (by_word
+          && ((p > text && !ISSPACE (p[-1]))
+              || ! STOP_SET (p[slen], MAP_SPACE|MAP_NUL)))
+        /* Struck out.  Output the rest of the string that is
+           no longer to be replaced.  */
+        o = variable_buffer_output (o, subst, slen);
+      else if (rlen > 0)
+        /* Output the replacement string.  */
+        o = variable_buffer_output (o, replace, rlen);
+
+      /* Advance T past the string to be replaced.  */
+      t = p + slen;
+    } while (*t != '\0');
+
+  return o;
+}
+
+
+/* Store into VARIABLE_BUFFER at O the result of scanning TEXT
+   and replacing strings matching PATTERN with REPLACE.
+   If PATTERN_PERCENT is not nil, PATTERN has already been
+   run through find_percent, and PATTERN_PERCENT is the result.
+   If REPLACE_PERCENT is not nil, REPLACE has already been
+   run through find_percent, and REPLACE_PERCENT is the result.
+   Note that we expect PATTERN_PERCENT and REPLACE_PERCENT to point to the
+   character _AFTER_ the %, not to the % itself.
+*/
+
+char *
+patsubst_expand_pat (char *o, const char *text,
+                     const char *pattern, const char *replace,
+                     const char *pattern_percent, const char *replace_percent)
+{
+  unsigned int pattern_prepercent_len, pattern_postpercent_len;
+  unsigned int replace_prepercent_len, replace_postpercent_len;
+  const char *t;
+  unsigned int len;
+  int doneany = 0;
+
+  /* Record the length of REPLACE before and after the % so we don't have to
+     compute these lengths more than once.  */
+  if (replace_percent)
+    {
+      replace_prepercent_len = replace_percent - replace - 1;
+      replace_postpercent_len = strlen (replace_percent);
+    }
+  else
+    {
+      replace_prepercent_len = strlen (replace);
+      replace_postpercent_len = 0;
+    }
+
+  if (!pattern_percent)
+    /* With no % in the pattern, this is just a simple substitution.  */
+    return subst_expand (o, text, pattern, replace,
+                         strlen (pattern), strlen (replace), 1);
+
+  /* Record the length of PATTERN before and after the %
+     so we don't have to compute it more than once.  */
+  pattern_prepercent_len = pattern_percent - pattern - 1;
+  pattern_postpercent_len = strlen (pattern_percent);
+
+  while ((t = find_next_token (&text, &len)) != 0)
+    {
+      int fail = 0;
+
+      /* Is it big enough to match?  */
+      if (len < pattern_prepercent_len + pattern_postpercent_len)
+        fail = 1;
+
+      /* Does the prefix match? */
+      if (!fail && pattern_prepercent_len > 0
+          && (*t != *pattern
+              || t[pattern_prepercent_len - 1] != pattern_percent[-2]
+              || !strneq (t + 1, pattern + 1, pattern_prepercent_len - 1)))
+        fail = 1;
+
+      /* Does the suffix match? */
+      if (!fail && pattern_postpercent_len > 0
+          && (t[len - 1] != pattern_percent[pattern_postpercent_len - 1]
+              || t[len - pattern_postpercent_len] != *pattern_percent
+              || !strneq (&t[len - pattern_postpercent_len],
+                          pattern_percent, pattern_postpercent_len - 1)))
+        fail = 1;
+
+      if (fail)
+        /* It didn't match.  Output the string.  */
+        o = variable_buffer_output (o, t, len);
+      else
+        {
+          /* It matched.  Output the replacement.  */
+
+          /* Output the part of the replacement before the %.  */
+          o = variable_buffer_output (o, replace, replace_prepercent_len);
+
+          if (replace_percent != 0)
+            {
+              /* Output the part of the matched string that
+                 matched the % in the pattern.  */
+              o = variable_buffer_output (o, t + pattern_prepercent_len,
+                                          len - (pattern_prepercent_len
+                                                 + pattern_postpercent_len));
+              /* Output the part of the replacement after the %.  */
+              o = variable_buffer_output (o, replace_percent,
+                                          replace_postpercent_len);
+            }
+        }
+
+      /* Output a space, but not if the replacement is "".  */
+      if (fail || replace_prepercent_len > 0
+          || (replace_percent != 0 && len + replace_postpercent_len > 0))
+        {
+          o = variable_buffer_output (o, " ", 1);
+          doneany = 1;
+        }
+    }
+  if (doneany)
+    /* Kill the last space.  */
+    --o;
+
+  return o;
+}
+
+/* Store into VARIABLE_BUFFER at O the result of scanning TEXT
+   and replacing strings matching PATTERN with REPLACE.
+   If PATTERN_PERCENT is not nil, PATTERN has already been
+   run through find_percent, and PATTERN_PERCENT is the result.
+   If REPLACE_PERCENT is not nil, REPLACE has already been
+   run through find_percent, and REPLACE_PERCENT is the result.
+   Note that we expect PATTERN_PERCENT and REPLACE_PERCENT to point to the
+   character _AFTER_ the %, not to the % itself.
+*/
+
+char *
+patsubst_expand (char *o, const char *text, char *pattern, char *replace)
+{
+  const char *pattern_percent = find_percent (pattern);
+  const char *replace_percent = find_percent (replace);
+
+  /* If there's a percent in the pattern or replacement skip it.  */
+  if (replace_percent)
+    ++replace_percent;
+  if (pattern_percent)
+    ++pattern_percent;
+
+  return patsubst_expand_pat (o, text, pattern, replace,
+                              pattern_percent, replace_percent);
+}
+
+
+/* Look up a function by name.  */
+
+static const struct function_table_entry *
+lookup_function (const char *s)
+{
+  struct function_table_entry function_table_entry_key;
+  const char *e = s;
+
+  while (STOP_SET (*e, MAP_USERFUNC))
+    e++;
+
+  if (e == s || !STOP_SET(*e, MAP_NUL|MAP_SPACE))
+    return NULL;
+
+  function_table_entry_key.name = s;
+  function_table_entry_key.len = e - s;
+
+  return hash_find_item (&function_table, &function_table_entry_key);
+}
+
+
+/* Return 1 if PATTERN matches STR, 0 if not.  */
+
+int
+pattern_matches (const char *pattern, const char *percent, const char *str)
+{
+  unsigned int sfxlen, strlength;
+
+  if (percent == 0)
+    {
+      unsigned int len = strlen (pattern) + 1;
+      char *new_chars = alloca (len);
+      memcpy (new_chars, pattern, len);
+      percent = find_percent (new_chars);
+      if (percent == 0)
+        return streq (new_chars, str);
+      pattern = new_chars;
+    }
+
+  sfxlen = strlen (percent + 1);
+  strlength = strlen (str);
+
+  if (strlength < (percent - pattern) + sfxlen
+      || !strneq (pattern, str, percent - pattern))
+    return 0;
+
+  return !strcmp (percent + 1, str + (strlength - sfxlen));
+}
+
+
+/* Find the next comma or ENDPAREN (counting nested STARTPAREN and
+   ENDPARENtheses), starting at PTR before END.  Return a pointer to
+   next character.
+
+   If no next argument is found, return NULL.
+*/
+
+static char *
+find_next_argument (char startparen, char endparen,
+                    const char *ptr, const char *end)
+{
+  int count = 0;
+
+  for (; ptr < end; ++ptr)
+    if (!STOP_SET (*ptr, MAP_VARSEP|MAP_COMMA))
+      continue;
+
+    else if (*ptr == startparen)
+      ++count;
+
+    else if (*ptr == endparen)
+      {
+        --count;
+        if (count < 0)
+          return NULL;
+      }
+
+    else if (*ptr == ',' && !count)
+      return (char *)ptr;
+
+  /* We didn't find anything.  */
+  return NULL;
+}
+
+
+/* Glob-expand LINE.  The returned pointer is
+   only good until the next call to string_glob.  */
+
+static char *
+string_glob (char *line)
+{
+  static char *result = 0;
+  static unsigned int length;
+  struct nameseq *chain;
+  unsigned int idx;
+
+  chain = PARSE_FILE_SEQ (&line, struct nameseq, MAP_NUL, NULL,
+                          /* We do not want parse_file_seq to strip './'s.
+                             That would break examples like:
+                             $(patsubst ./%.c,obj/%.o,$(wildcard ./?*.c)).  */
+                          PARSEFS_NOSTRIP|PARSEFS_NOCACHE|PARSEFS_EXISTS);
+
+  if (result == 0)
+    {
+      length = 100;
+      result = xmalloc (100);
+    }
+
+  idx = 0;
+  while (chain != 0)
+    {
+      struct nameseq *next = chain->next;
+      unsigned int len = strlen (chain->name);
+
+      if (idx + len + 1 > length)
+        {
+          length += (len + 1) * 2;
+          result = xrealloc (result, length);
+        }
+      memcpy (&result[idx], chain->name, len);
+      idx += len;
+      result[idx++] = ' ';
+
+      /* Because we used PARSEFS_NOCACHE above, we have to free() NAME.  */
+      free ((char *)chain->name);
+      free (chain);
+      chain = next;
+    }
+
+  /* Kill the last space and terminate the string.  */
+  if (idx == 0)
+    result[0] = '\0';
+  else
+    result[idx - 1] = '\0';
+
+  return result;
+}
+
+/*
+  Builtin functions
+ */
+
+static char *
+func_patsubst (char *o, char **argv, const char *funcname UNUSED)
+{
+  o = patsubst_expand (o, argv[2], argv[0], argv[1]);
+  return o;
+}
+
+
+static char *
+func_join (char *o, char **argv, const char *funcname UNUSED)
+{
+  int doneany = 0;
+
+  /* Write each word of the first argument directly followed
+     by the corresponding word of the second argument.
+     If the two arguments have a different number of words,
+     the excess words are just output separated by blanks.  */
+  const char *tp;
+  const char *pp;
+  const char *list1_iterator = argv[0];
+  const char *list2_iterator = argv[1];
+  do
+    {
+      unsigned int len1, len2;
+
+      tp = find_next_token (&list1_iterator, &len1);
+      if (tp != 0)
+        o = variable_buffer_output (o, tp, len1);
+
+      pp = find_next_token (&list2_iterator, &len2);
+      if (pp != 0)
+        o = variable_buffer_output (o, pp, len2);
+
+      if (tp != 0 || pp != 0)
+        {
+          o = variable_buffer_output (o, " ", 1);
+          doneany = 1;
+        }
+    }
+  while (tp != 0 || pp != 0);
+  if (doneany)
+    /* Kill the last blank.  */
+    --o;
+
+  return o;
+}
+
+
+static char *
+func_origin (char *o, char **argv, const char *funcname UNUSED)
+{
+  /* Expand the argument.  */
+  struct variable *v = lookup_variable (argv[0], strlen (argv[0]));
+  if (v == 0)
+    o = variable_buffer_output (o, "undefined", 9);
+  else
+    switch (v->origin)
+      {
+      default:
+      case o_invalid:
+        abort ();
+        break;
+      case o_default:
+        o = variable_buffer_output (o, "default", 7);
+        break;
+      case o_env:
+        o = variable_buffer_output (o, "environment", 11);
+        break;
+      case o_file:
+        o = variable_buffer_output (o, "file", 4);
+        break;
+      case o_env_override:
+        o = variable_buffer_output (o, "environment override", 20);
+        break;
+      case o_command:
+        o = variable_buffer_output (o, "command line", 12);
+        break;
+      case o_override:
+        o = variable_buffer_output (o, "override", 8);
+        break;
+      case o_automatic:
+        o = variable_buffer_output (o, "automatic", 9);
+        break;
+      }
+
+  return o;
+}
+
+static char *
+func_flavor (char *o, char **argv, const char *funcname UNUSED)
+{
+  struct variable *v = lookup_variable (argv[0], strlen (argv[0]));
+
+  if (v == 0)
+    o = variable_buffer_output (o, "undefined", 9);
+  else
+    if (v->recursive)
+      o = variable_buffer_output (o, "recursive", 9);
+    else
+      o = variable_buffer_output (o, "simple", 6);
+
+  return o;
+}
+
+
+static char *
+func_notdir_suffix (char *o, char **argv, const char *funcname)
+{
+  /* Expand the argument.  */
+  const char *list_iterator = argv[0];
+  const char *p2;
+  int doneany =0;
+  unsigned int len=0;
+
+  int is_suffix = funcname[0] == 's';
+  int is_notdir = !is_suffix;
+  int stop = MAP_DIRSEP | (is_suffix ? MAP_DOT : 0);
+#ifdef VMS
+  /* For VMS list_iterator points to a comma separated list. To use the common
+     [find_]next_token, create a local copy and replace the commas with
+     spaces. Obviously, there is a problem if there is a ',' in the VMS filename
+     (can only happen on ODS5), the same problem as with spaces in filenames,
+     which seems to be present in make on all platforms. */
+  char *vms_list_iterator = alloca(strlen(list_iterator) + 1);
+  int i;
+  for (i = 0; list_iterator[i]; i++)
+    if (list_iterator[i] == ',')
+      vms_list_iterator[i] = ' ';
+    else
+      vms_list_iterator[i] = list_iterator[i];
+  vms_list_iterator[i] = list_iterator[i];
+  while ((p2 = find_next_token((const char**) &vms_list_iterator, &len)) != 0)
+#else
+  while ((p2 = find_next_token (&list_iterator, &len)) != 0)
+#endif
+    {
+      const char *p = p2 + len - 1;
+
+      while (p >= p2 && ! STOP_SET (*p, stop))
+        --p;
+
+      if (p >= p2)
+        {
+          if (is_notdir)
+            ++p;
+          else if (*p != '.')
+            continue;
+          o = variable_buffer_output (o, p, len - (p - p2));
+        }
+#ifdef HAVE_DOS_PATHS
+      /* Handle the case of "d:foo/bar".  */
+      else if (is_notdir && p2[0] && p2[1] == ':')
+        {
+          p = p2 + 2;
+          o = variable_buffer_output (o, p, len - (p - p2));
+        }
+#endif
+      else if (is_notdir)
+        o = variable_buffer_output (o, p2, len);
+
+      if (is_notdir || p >= p2)
+        {
+#ifdef VMS
+          if (vms_comma_separator)
+            o = variable_buffer_output (o, ",", 1);
+          else
+#endif
+          o = variable_buffer_output (o, " ", 1);
+
+          doneany = 1;
+        }
+    }
+
+  if (doneany)
+    /* Kill last space.  */
+    --o;
+
+  return o;
+}
+
+
+static char *
+func_basename_dir (char *o, char **argv, const char *funcname)
+{
+  /* Expand the argument.  */
+  const char *p3 = argv[0];
+  const char *p2;
+  int doneany = 0;
+  unsigned int len = 0;
+
+  int is_basename = funcname[0] == 'b';
+  int is_dir = !is_basename;
+  int stop = MAP_DIRSEP | (is_basename ? MAP_DOT : 0) | MAP_NUL;
+#ifdef VMS
+  /* As in func_notdir_suffix ... */
+  char *vms_p3 = alloca (strlen(p3) + 1);
+  int i;
+  for (i = 0; p3[i]; i++)
+    if (p3[i] == ',')
+      vms_p3[i] = ' ';
+    else
+      vms_p3[i] = p3[i];
+  vms_p3[i] = p3[i];
+  while ((p2 = find_next_token((const char**) &vms_p3, &len)) != 0)
+#else
+  while ((p2 = find_next_token (&p3, &len)) != 0)
+#endif
+    {
+      const char *p = p2 + len - 1;
+      while (p >= p2 && ! STOP_SET (*p, stop))
+        --p;
+
+      if (p >= p2 && (is_dir))
+        o = variable_buffer_output (o, p2, ++p - p2);
+      else if (p >= p2 && (*p == '.'))
+        o = variable_buffer_output (o, p2, p - p2);
+#ifdef HAVE_DOS_PATHS
+      /* Handle the "d:foobar" case */
+      else if (p2[0] && p2[1] == ':' && is_dir)
+        o = variable_buffer_output (o, p2, 2);
+#endif
+      else if (is_dir)
+#ifdef VMS
+        {
+          extern int vms_report_unix_paths;
+          if (vms_report_unix_paths)
+            o = variable_buffer_output (o, "./", 2);
+          else
+            o = variable_buffer_output (o, "[]", 2);
+        }
+#else
+#ifndef _AMIGA
+      o = variable_buffer_output (o, "./", 2);
+#else
+      ; /* Just a nop...  */
+#endif /* AMIGA */
+#endif /* !VMS */
+      else
+        /* The entire name is the basename.  */
+        o = variable_buffer_output (o, p2, len);
+
+#ifdef VMS
+      if (vms_comma_separator)
+        o = variable_buffer_output (o, ",", 1);
+      else
+#endif
+        o = variable_buffer_output (o, " ", 1);
+
+      doneany = 1;
+    }
+
+  if (doneany)
+    /* Kill last space.  */
+    --o;
+
+  return o;
+}
+
+static char *
+func_addsuffix_addprefix (char *o, char **argv, const char *funcname)
+{
+  int fixlen = strlen (argv[0]);
+  const char *list_iterator = argv[1];
+  int is_addprefix = funcname[3] == 'p';
+  int is_addsuffix = !is_addprefix;
+
+  int doneany = 0;
+  const char *p;
+  unsigned int len;
+
+  while ((p = find_next_token (&list_iterator, &len)) != 0)
+    {
+      if (is_addprefix)
+        o = variable_buffer_output (o, argv[0], fixlen);
+      o = variable_buffer_output (o, p, len);
+      if (is_addsuffix)
+        o = variable_buffer_output (o, argv[0], fixlen);
+      o = variable_buffer_output (o, " ", 1);
+      doneany = 1;
+    }
+
+  if (doneany)
+    /* Kill last space.  */
+    --o;
+
+  return o;
+}
+
+static char *
+func_subst (char *o, char **argv, const char *funcname UNUSED)
+{
+  o = subst_expand (o, argv[2], argv[0], argv[1], strlen (argv[0]),
+                    strlen (argv[1]), 0);
+
+  return o;
+}
+
+
+static char *
+func_firstword (char *o, char **argv, const char *funcname UNUSED)
+{
+  unsigned int i;
+  const char *words = argv[0];    /* Use a temp variable for find_next_token */
+  const char *p = find_next_token (&words, &i);
+
+  if (p != 0)
+    o = variable_buffer_output (o, p, i);
+
+  return o;
+}
+
+static char *
+func_lastword (char *o, char **argv, const char *funcname UNUSED)
+{
+  unsigned int i;
+  const char *words = argv[0];    /* Use a temp variable for find_next_token */
+  const char *p = NULL;
+  const char *t;
+
+  while ((t = find_next_token (&words, &i)))
+    p = t;
+
+  if (p != 0)
+    o = variable_buffer_output (o, p, i);
+
+  return o;
+}
+
+static char *
+func_words (char *o, char **argv, const char *funcname UNUSED)
+{
+  int i = 0;
+  const char *word_iterator = argv[0];
+  char buf[20];
+
+  while (find_next_token (&word_iterator, NULL) != 0)
+    ++i;
+
+  sprintf (buf, "%d", i);
+  o = variable_buffer_output (o, buf, strlen (buf));
+
+  return o;
+}
+
+/* Set begpp to point to the first non-whitespace character of the string,
+ * and endpp to point to the last non-whitespace character of the string.
+ * If the string is empty or contains nothing but whitespace, endpp will be
+ * begpp-1.
+ */
+char *
+strip_whitespace (const char **begpp, const char **endpp)
+{
+  while (*begpp <= *endpp && ISSPACE (**begpp))
+    (*begpp) ++;
+  while (*endpp >= *begpp && ISSPACE (**endpp))
+    (*endpp) --;
+  return (char *)*begpp;
+}
+
+static void
+check_numeric (const char *s, const char *msg)
+{
+  const char *end = s + strlen (s) - 1;
+  const char *beg = s;
+  strip_whitespace (&s, &end);
+
+  for (; s <= end; ++s)
+    if (!ISDIGIT (*s))  /* ISDIGIT only evals its arg once: see makeint.h.  */
+      break;
+
+  if (s <= end || end - beg < 0)
+    OSS (fatal, *expanding_var, "%s: '%s'", msg, beg);
+}
+
+
+
+static char *
+func_word (char *o, char **argv, const char *funcname UNUSED)
+{
+  const char *end_p;
+  const char *p;
+  int i;
+
+  /* Check the first argument.  */
+  check_numeric (argv[0], _("non-numeric first argument to 'word' function"));
+  i = atoi (argv[0]);
+
+  if (i == 0)
+    O (fatal, *expanding_var,
+       _("first argument to 'word' function must be greater than 0"));
+
+  end_p = argv[1];
+  while ((p = find_next_token (&end_p, 0)) != 0)
+    if (--i == 0)
+      break;
+
+  if (i == 0)
+    o = variable_buffer_output (o, p, end_p - p);
+
+  return o;
+}
+
+static char *
+func_wordlist (char *o, char **argv, const char *funcname UNUSED)
+{
+  int start, count;
+
+  /* Check the arguments.  */
+  check_numeric (argv[0],
+                 _("non-numeric first argument to 'wordlist' function"));
+  check_numeric (argv[1],
+                 _("non-numeric second argument to 'wordlist' function"));
+
+  start = atoi (argv[0]);
+  if (start < 1)
+    ON (fatal, *expanding_var,
+        "invalid first argument to 'wordlist' function: '%d'", start);
+
+  count = atoi (argv[1]) - start + 1;
+
+  if (count > 0)
+    {
+      const char *p;
+      const char *end_p = argv[2];
+
+      /* Find the beginning of the "start"th word.  */
+      while (((p = find_next_token (&end_p, 0)) != 0) && --start)
+        ;
+
+      if (p)
+        {
+          /* Find the end of the "count"th word from start.  */
+          while (--count && (find_next_token (&end_p, 0) != 0))
+            ;
+
+          /* Return the stuff in the middle.  */
+          o = variable_buffer_output (o, p, end_p - p);
+        }
+    }
+
+  return o;
+}
+
+static char *
+func_findstring (char *o, char **argv, const char *funcname UNUSED)
+{
+  /* Find the first occurrence of the first string in the second.  */
+  if (strstr (argv[1], argv[0]) != 0)
+    o = variable_buffer_output (o, argv[0], strlen (argv[0]));
+
+  return o;
+}
+
+static char *
+func_foreach (char *o, char **argv, const char *funcname UNUSED)
+{
+  /* expand only the first two.  */
+  char *varname = expand_argument (argv[0], NULL);
+  char *list = expand_argument (argv[1], NULL);
+  const char *body = argv[2];
+
+  int doneany = 0;
+  const char *list_iterator = list;
+  const char *p;
+  unsigned int len;
+  struct variable *var;
+
+  /* Clean up the variable name by removing whitespace.  */
+  char *vp = next_token (varname);
+  end_of_token (vp)[0] = '\0';
+
+  push_new_variable_scope ();
+  var = define_variable (vp, strlen (vp), "", o_automatic, 0);
+
+  /* loop through LIST,  put the value in VAR and expand BODY */
+  while ((p = find_next_token (&list_iterator, &len)) != 0)
+    {
+      char *result = 0;
+
+      free (var->value);
+      var->value = xstrndup (p, len);
+
+      result = allocated_variable_expand (body);
+
+      o = variable_buffer_output (o, result, strlen (result));
+      o = variable_buffer_output (o, " ", 1);
+      doneany = 1;
+      free (result);
+    }
+
+  if (doneany)
+    /* Kill the last space.  */
+    --o;
+
+  pop_variable_scope ();
+  free (varname);
+  free (list);
+
+  return o;
+}
+
+struct a_word
+{
+  struct a_word *next;
+  struct a_word *chain;
+  char *str;
+  int length;
+  int matched;
+};
+
+static unsigned long
+a_word_hash_1 (const void *key)
+{
+  return_STRING_HASH_1 (((struct a_word const *) key)->str);
+}
+
+static unsigned long
+a_word_hash_2 (const void *key)
+{
+  return_STRING_HASH_2 (((struct a_word const *) key)->str);
+}
+
+static int
+a_word_hash_cmp (const void *x, const void *y)
+{
+  int result = ((struct a_word const *) x)->length - ((struct a_word const *) y)->length;
+  if (result)
+    return result;
+  return_STRING_COMPARE (((struct a_word const *) x)->str,
+                         ((struct a_word const *) y)->str);
+}
+
+struct a_pattern
+{
+  struct a_pattern *next;
+  char *str;
+  char *percent;
+  int length;
+};
+
+static char *
+func_filter_filterout (char *o, char **argv, const char *funcname)
+{
+  struct a_word *wordhead;
+  struct a_word **wordtail;
+  struct a_word *wp;
+  struct a_pattern *pathead;
+  struct a_pattern **pattail;
+  struct a_pattern *pp;
+
+  struct hash_table a_word_table;
+  int is_filter = funcname[CSTRLEN ("filter")] == '\0';
+  const char *pat_iterator = argv[0];
+  const char *word_iterator = argv[1];
+  int literals = 0;
+  int words = 0;
+  int hashing = 0;
+  char *p;
+  unsigned int len;
+
+  /* Chop ARGV[0] up into patterns to match against the words.
+     We don't need to preserve it because our caller frees all the
+     argument memory anyway.  */
+
+  pattail = &pathead;
+  while ((p = find_next_token (&pat_iterator, &len)) != 0)
+    {
+      struct a_pattern *pat = alloca (sizeof (struct a_pattern));
+
+      *pattail = pat;
+      pattail = &pat->next;
+
+      if (*pat_iterator != '\0')
+        ++pat_iterator;
+
+      pat->str = p;
+      p[len] = '\0';
+      pat->percent = find_percent (p);
+      if (pat->percent == 0)
+        literals++;
+
+      /* find_percent() might shorten the string so LEN is wrong.  */
+      pat->length = strlen (pat->str);
+    }
+  *pattail = 0;
+
+  /* Chop ARGV[1] up into words to match against the patterns.  */
+
+  wordtail = &wordhead;
+  while ((p = find_next_token (&word_iterator, &len)) != 0)
+    {
+      struct a_word *word = alloca (sizeof (struct a_word));
+
+      *wordtail = word;
+      wordtail = &word->next;
+
+      if (*word_iterator != '\0')
+        ++word_iterator;
+
+      p[len] = '\0';
+      word->str = p;
+      word->length = len;
+      word->matched = 0;
+      word->chain = 0;
+      words++;
+    }
+  *wordtail = 0;
+
+  /* Only use a hash table if arg list lengths justifies the cost.  */
+  hashing = (literals >= 2 && (literals * words) >= 10);
+  if (hashing)
+    {
+      hash_init (&a_word_table, words, a_word_hash_1, a_word_hash_2,
+                 a_word_hash_cmp);
+      for (wp = wordhead; wp != 0; wp = wp->next)
+        {
+          struct a_word *owp = hash_insert (&a_word_table, wp);
+          if (owp)
+            wp->chain = owp;
+        }
+    }
+
+  if (words)
+    {
+      int doneany = 0;
+
+      /* Run each pattern through the words, killing words.  */
+      for (pp = pathead; pp != 0; pp = pp->next)
+        {
+          if (pp->percent)
+            for (wp = wordhead; wp != 0; wp = wp->next)
+              wp->matched |= pattern_matches (pp->str, pp->percent, wp->str);
+          else if (hashing)
+            {
+              struct a_word a_word_key;
+              a_word_key.str = pp->str;
+              a_word_key.length = pp->length;
+              wp = hash_find_item (&a_word_table, &a_word_key);
+              while (wp)
+                {
+                  wp->matched |= 1;
+                  wp = wp->chain;
+                }
+            }
+          else
+            for (wp = wordhead; wp != 0; wp = wp->next)
+              wp->matched |= (wp->length == pp->length
+                              && strneq (pp->str, wp->str, wp->length));
+        }
+
+      /* Output the words that matched (or didn't, for filter-out).  */
+      for (wp = wordhead; wp != 0; wp = wp->next)
+        if (is_filter ? wp->matched : !wp->matched)
+          {
+            o = variable_buffer_output (o, wp->str, strlen (wp->str));
+            o = variable_buffer_output (o, " ", 1);
+            doneany = 1;
+          }
+
+      if (doneany)
+        /* Kill the last space.  */
+        --o;
+    }
+
+  if (hashing)
+    hash_free (&a_word_table, 0);
+
+  return o;
+}
+
+
+static char *
+func_strip (char *o, char **argv, const char *funcname UNUSED)
+{
+  const char *p = argv[0];
+  int doneany = 0;
+
+  while (*p != '\0')
+    {
+      int i=0;
+      const char *word_start;
+
+      NEXT_TOKEN (p);
+      word_start = p;
+      for (i=0; *p != '\0' && !ISSPACE (*p); ++p, ++i)
+        {}
+      if (!i)
+        break;
+      o = variable_buffer_output (o, word_start, i);
+      o = variable_buffer_output (o, " ", 1);
+      doneany = 1;
+    }
+
+  if (doneany)
+    /* Kill the last space.  */
+    --o;
+
+  return o;
+}
+
+/*
+  Print a warning or fatal message.
+*/
+static char *
+func_error (char *o, char **argv, const char *funcname)
+{
+  char **argvp;
+  char *msg, *p;
+  int len;
+
+  /* The arguments will be broken on commas.  Rather than create yet
+     another special case where function arguments aren't broken up,
+     just create a format string that puts them back together.  */
+  for (len=0, argvp=argv; *argvp != 0; ++argvp)
+    len += strlen (*argvp) + 2;
+
+  p = msg = alloca (len + 1);
+  msg[0] = '\0';
+
+  for (argvp=argv; argvp[1] != 0; ++argvp)
+    {
+      strcpy (p, *argvp);
+      p += strlen (*argvp);
+      *(p++) = ',';
+      *(p++) = ' ';
+    }
+  strcpy (p, *argvp);
+
+  switch (*funcname)
+    {
+    case 'e':
+      OS (fatal, reading_file, "%s", msg);
+
+    case 'w':
+      OS (error, reading_file, "%s", msg);
+      break;
+
+    case 'i':
+      outputs (0, msg);
+      outputs (0, "\n");
+      break;
+
+    default:
+      OS (fatal, *expanding_var, "Internal error: func_error: '%s'", funcname);
+    }
+
+  /* The warning function expands to the empty string.  */
+  return o;
+}
+
+
+/*
+  chop argv[0] into words, and sort them.
+ */
+static char *
+func_sort (char *o, char **argv, const char *funcname UNUSED)
+{
+  const char *t;
+  char **words;
+  int wordi;
+  char *p;
+  unsigned int len;
+
+  /* Find the maximum number of words we'll have.  */
+  t = argv[0];
+  wordi = 0;
+  while ((p = find_next_token (&t, NULL)) != 0)
+    {
+      ++t;
+      ++wordi;
+    }
+
+  words = xmalloc ((wordi == 0 ? 1 : wordi) * sizeof (char *));
+
+  /* Now assign pointers to each string in the array.  */
+  t = argv[0];
+  wordi = 0;
+  while ((p = find_next_token (&t, &len)) != 0)
+    {
+      ++t;
+      p[len] = '\0';
+      words[wordi++] = p;
+    }
+
+  if (wordi)
+    {
+      int i;
+
+      /* Now sort the list of words.  */
+      qsort (words, wordi, sizeof (char *), alpha_compare);
+
+      /* Now write the sorted list, uniquified.  */
+      for (i = 0; i < wordi; ++i)
+        {
+          len = strlen (words[i]);
+          if (i == wordi - 1 || strlen (words[i + 1]) != len
+              || strcmp (words[i], words[i + 1]))
+            {
+              o = variable_buffer_output (o, words[i], len);
+              o = variable_buffer_output (o, " ", 1);
+            }
+        }
+
+      /* Kill the last space.  */
+      --o;
+    }
+
+  free (words);
+
+  return o;
+}
+
+/*
+  $(if condition,true-part[,false-part])
+
+  CONDITION is false iff it evaluates to an empty string.  White
+  space before and after condition are stripped before evaluation.
+
+  If CONDITION is true, then TRUE-PART is evaluated, otherwise FALSE-PART is
+  evaluated (if it exists).  Because only one of the two PARTs is evaluated,
+  you can use $(if ...) to create side-effects (with $(shell ...), for
+  example).
+*/
+
+static char *
+func_if (char *o, char **argv, const char *funcname UNUSED)
+{
+  const char *begp = argv[0];
+  const char *endp = begp + strlen (argv[0]) - 1;
+  int result = 0;
+
+  /* Find the result of the condition: if we have a value, and it's not
+     empty, the condition is true.  If we don't have a value, or it's the
+     empty string, then it's false.  */
+
+  strip_whitespace (&begp, &endp);
+
+  if (begp <= endp)
+    {
+      char *expansion = expand_argument (begp, endp+1);
+
+      result = expansion[0] != '\0';
+      free (expansion);
+    }
+
+  /* If the result is true (1) we want to eval the first argument, and if
+     it's false (0) we want to eval the second.  If the argument doesn't
+     exist we do nothing, otherwise expand it and add to the buffer.  */
+
+  argv += 1 + !result;
+
+  if (*argv)
+    {
+      char *expansion = expand_argument (*argv, NULL);
+
+      o = variable_buffer_output (o, expansion, strlen (expansion));
+
+      free (expansion);
+    }
+
+  return o;
+}
+
+/*
+  $(or condition1[,condition2[,condition3[...]]])
+
+  A CONDITION is false iff it evaluates to an empty string.  White
+  space before and after CONDITION are stripped before evaluation.
+
+  CONDITION1 is evaluated.  If it's true, then this is the result of
+  expansion.  If it's false, CONDITION2 is evaluated, and so on.  If none of
+  the conditions are true, the expansion is the empty string.
+
+  Once a CONDITION is true no further conditions are evaluated
+  (short-circuiting).
+*/
+
+static char *
+func_or (char *o, char **argv, const char *funcname UNUSED)
+{
+  for ( ; *argv ; ++argv)
+    {
+      const char *begp = *argv;
+      const char *endp = begp + strlen (*argv) - 1;
+      char *expansion;
+      int result = 0;
+
+      /* Find the result of the condition: if it's false keep going.  */
+
+      strip_whitespace (&begp, &endp);
+
+      if (begp > endp)
+        continue;
+
+      expansion = expand_argument (begp, endp+1);
+      result = strlen (expansion);
+
+      /* If the result is false keep going.  */
+      if (!result)
+        {
+          free (expansion);
+          continue;
+        }
+
+      /* It's true!  Keep this result and return.  */
+      o = variable_buffer_output (o, expansion, result);
+      free (expansion);
+      break;
+    }
+
+  return o;
+}
+
+/*
+  $(and condition1[,condition2[,condition3[...]]])
+
+  A CONDITION is false iff it evaluates to an empty string.  White
+  space before and after CONDITION are stripped before evaluation.
+
+  CONDITION1 is evaluated.  If it's false, then this is the result of
+  expansion.  If it's true, CONDITION2 is evaluated, and so on.  If all of
+  the conditions are true, the expansion is the result of the last condition.
+
+  Once a CONDITION is false no further conditions are evaluated
+  (short-circuiting).
+*/
+
+static char *
+func_and (char *o, char **argv, const char *funcname UNUSED)
+{
+  char *expansion;
+
+  while (1)
+    {
+      const char *begp = *argv;
+      const char *endp = begp + strlen (*argv) - 1;
+      int result;
+
+      /* An empty condition is always false.  */
+      strip_whitespace (&begp, &endp);
+      if (begp > endp)
+        return o;
+
+      expansion = expand_argument (begp, endp+1);
+      result = strlen (expansion);
+
+      /* If the result is false, stop here: we're done.  */
+      if (!result)
+        break;
+
+      /* Otherwise the result is true.  If this is the last one, keep this
+         result and quit.  Otherwise go on to the next one!  */
+
+      if (*(++argv))
+        free (expansion);
+      else
+        {
+          o = variable_buffer_output (o, expansion, result);
+          break;
+        }
+    }
+
+  free (expansion);
+
+  return o;
+}
+
+static char *
+func_wildcard (char *o, char **argv, const char *funcname UNUSED)
+{
+#ifdef _AMIGA
+   o = wildcard_expansion (argv[0], o);
+#else
+   char *p = string_glob (argv[0]);
+   o = variable_buffer_output (o, p, strlen (p));
+#endif
+   return o;
+}
+
+/*
+  $(eval <makefile string>)
+
+  Always resolves to the empty string.
+
+  Treat the arguments as a segment of makefile, and parse them.
+*/
+
+static char *
+func_eval (char *o, char **argv, const char *funcname UNUSED)
+{
+  char *buf;
+  unsigned int len;
+
+  /* Eval the buffer.  Pop the current variable buffer setting so that the
+     eval'd code can use its own without conflicting.  */
+
+  install_variable_buffer (&buf, &len);
+
+  eval_buffer (argv[0], NULL);
+
+  restore_variable_buffer (buf, len);
+
+  return o;
+}
+
+
+static char *
+func_value (char *o, char **argv, const char *funcname UNUSED)
+{
+  /* Look up the variable.  */
+  struct variable *v = lookup_variable (argv[0], strlen (argv[0]));
+
+  /* Copy its value into the output buffer without expanding it.  */
+  if (v)
+    o = variable_buffer_output (o, v->value, strlen (v->value));
+
+  return o;
+}
+
+/*
+  \r is replaced on UNIX as well. Is this desirable?
+ */
+static void
+fold_newlines (char *buffer, unsigned int *length, int trim_newlines)
+{
+  char *dst = buffer;
+  char *src = buffer;
+  char *last_nonnl = buffer - 1;
+  src[*length] = 0;
+  for (; *src != '\0'; ++src)
+    {
+      if (src[0] == '\r' && src[1] == '\n')
+        continue;
+      if (*src == '\n')
+        {
+          *dst++ = ' ';
+        }
+      else
+        {
+          last_nonnl = dst;
+          *dst++ = *src;
+        }
+    }
+
+  if (!trim_newlines && (last_nonnl < (dst - 2)))
+    last_nonnl = dst - 2;
+
+  *(++last_nonnl) = '\0';
+  *length = last_nonnl - buffer;
+}
+
+pid_t shell_function_pid = 0;
+static int shell_function_completed;
+
+void
+shell_completed (int exit_code, int exit_sig)
+{
+  char buf[256];
+
+  shell_function_pid = 0;
+  if (exit_sig == 0 && exit_code == 127)
+    shell_function_completed = -1;
+  else
+    shell_function_completed = 1;
+
+  if (exit_code == 0 && exit_sig > 0)
+    exit_code = 128 + exit_sig;
+
+  sprintf (buf, "%d", exit_code);
+  define_variable_cname (".SHELLSTATUS", buf, o_override, 0);
+}
+
+#ifdef WINDOWS32
+/*untested*/
+
+#include <windows.h>
+#include <io.h>
+#include "sub_proc.h"
+
+
+int
+windows32_openpipe (int *pipedes, int errfd, pid_t *pid_p, char **command_argv, char **envp)
+{
+  SECURITY_ATTRIBUTES saAttr;
+  HANDLE hIn = INVALID_HANDLE_VALUE;
+  HANDLE hErr = INVALID_HANDLE_VALUE;
+  HANDLE hChildOutRd;
+  HANDLE hChildOutWr;
+  HANDLE hProcess, tmpIn, tmpErr;
+  DWORD e;
+
+  /* Set status for return.  */
+  pipedes[0] = pipedes[1] = -1;
+  *pid_p = (pid_t)-1;
+
+  saAttr.nLength = sizeof (SECURITY_ATTRIBUTES);
+  saAttr.bInheritHandle = TRUE;
+  saAttr.lpSecurityDescriptor = NULL;
+
+  /* Standard handles returned by GetStdHandle can be NULL or
+     INVALID_HANDLE_VALUE if the parent process closed them.  If that
+     happens, we open the null device and pass its handle to
+     process_begin below as the corresponding handle to inherit.  */
+  tmpIn = GetStdHandle (STD_INPUT_HANDLE);
+  if (DuplicateHandle (GetCurrentProcess (), tmpIn,
+                       GetCurrentProcess (), &hIn,
+                       0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE)
+    {
+      e = GetLastError ();
+      if (e == ERROR_INVALID_HANDLE)
+        {
+          tmpIn = CreateFile ("NUL", GENERIC_READ,
+                              FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
+                              OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+          if (tmpIn != INVALID_HANDLE_VALUE
+              && DuplicateHandle (GetCurrentProcess (), tmpIn,
+                                  GetCurrentProcess (), &hIn,
+                                  0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE)
+            CloseHandle (tmpIn);
+        }
+      if (hIn == INVALID_HANDLE_VALUE)
+        {
+          ON (error, NILF,
+              _("windows32_openpipe: DuplicateHandle(In) failed (e=%ld)\n"), e);
+          return -1;
+        }
+    }
+  tmpErr = (HANDLE)_get_osfhandle (errfd);
+  if (DuplicateHandle (GetCurrentProcess (), tmpErr,
+                       GetCurrentProcess (), &hErr,
+                       0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE)
+    {
+      e = GetLastError ();
+      if (e == ERROR_INVALID_HANDLE)
+        {
+          tmpErr = CreateFile ("NUL", GENERIC_WRITE,
+                               FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
+                               OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+          if (tmpErr != INVALID_HANDLE_VALUE
+              && DuplicateHandle (GetCurrentProcess (), tmpErr,
+                                  GetCurrentProcess (), &hErr,
+                                  0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE)
+            CloseHandle (tmpErr);
+        }
+      if (hErr == INVALID_HANDLE_VALUE)
+        {
+          ON (error, NILF,
+              _("windows32_openpipe: DuplicateHandle(Err) failed (e=%ld)\n"), e);
+          return -1;
+        }
+    }
+
+  if (! CreatePipe (&hChildOutRd, &hChildOutWr, &saAttr, 0))
+    {
+      ON (error, NILF, _("CreatePipe() failed (e=%ld)\n"), GetLastError());
+      return -1;
+    }
+
+  hProcess = process_init_fd (hIn, hChildOutWr, hErr);
+
+  if (!hProcess)
+    {
+      O (error, NILF, _("windows32_openpipe(): process_init_fd() failed\n"));
+      return -1;
+    }
+
+  /* make sure that CreateProcess() has Path it needs */
+  sync_Path_environment ();
+  /* 'sync_Path_environment' may realloc 'environ', so take note of
+     the new value.  */
+  envp = environ;
+
+  if (! process_begin (hProcess, command_argv, envp, command_argv[0], NULL))
+    {
+      /* register process for wait */
+      process_register (hProcess);
+
+      /* set the pid for returning to caller */
+      *pid_p = (pid_t) hProcess;
+
+      /* set up to read data from child */
+      pipedes[0] = _open_osfhandle ((intptr_t) hChildOutRd, O_RDONLY);
+
+      /* this will be closed almost right away */
+      pipedes[1] = _open_osfhandle ((intptr_t) hChildOutWr, O_APPEND);
+      return 0;
+    }
+  else
+    {
+      /* reap/cleanup the failed process */
+      process_cleanup (hProcess);
+
+      /* close handles which were duplicated, they weren't used */
+      if (hIn != INVALID_HANDLE_VALUE)
+        CloseHandle (hIn);
+      if (hErr != INVALID_HANDLE_VALUE)
+        CloseHandle (hErr);
+
+      /* close pipe handles, they won't be used */
+      CloseHandle (hChildOutRd);
+      CloseHandle (hChildOutWr);
+
+      return -1;
+    }
+}
+#endif
+
+
+#ifdef __MSDOS__
+FILE *
+msdos_openpipe (int* pipedes, int *pidp, char *text)
+{
+  FILE *fpipe=0;
+  /* MSDOS can't fork, but it has 'popen'.  */
+  struct variable *sh = lookup_variable ("SHELL", 5);
+  int e;
+  extern int dos_command_running, dos_status;
+
+  /* Make sure not to bother processing an empty line.  */
+  NEXT_TOKEN (text);
+  if (*text == '\0')
+    return 0;
+
+  if (sh)
+    {
+      char buf[PATH_MAX + 7];
+      /* This makes sure $SHELL value is used by $(shell), even
+         though the target environment is not passed to it.  */
+      sprintf (buf, "SHELL=%s", sh->value);
+      putenv (buf);
+    }
+
+  e = errno;
+  errno = 0;
+  dos_command_running = 1;
+  dos_status = 0;
+  /* If dos_status becomes non-zero, it means the child process
+     was interrupted by a signal, like SIGINT or SIGQUIT.  See
+     fatal_error_signal in commands.c.  */
+  fpipe = popen (text, "rt");
+  dos_command_running = 0;
+  if (!fpipe || dos_status)
+    {
+      pipedes[0] = -1;
+      *pidp = -1;
+      if (dos_status)
+        errno = EINTR;
+      else if (errno == 0)
+        errno = ENOMEM;
+      if (fpipe)
+        pclose (fpipe);
+      shell_completed (127, 0);
+    }
+  else
+    {
+      pipedes[0] = fileno (fpipe);
+      *pidp = 42; /* Yes, the Meaning of Life, the Universe, and Everything! */
+      errno = e;
+    }
+  return fpipe;
+}
+#endif
+
+/*
+  Do shell spawning, with the naughty bits for different OSes.
+ */
+
+#ifdef VMS
+
+/* VMS can't do $(shell ...)  */
+
+char *
+func_shell_base (char *o, char **argv, int trim_newlines)
+{
+  fprintf (stderr, "This platform does not support shell\n");
+  die (MAKE_TROUBLE);
+  return NULL;
+}
+
+#define func_shell 0
+
+#else
+#ifndef _AMIGA
+char *
+func_shell_base (char *o, char **argv, int trim_newlines)
+{
+  char *batch_filename = NULL;
+  int errfd;
+#ifdef __MSDOS__
+  FILE *fpipe;
+#endif
+  char **command_argv;
+  const char *error_prefix;
+  char **envp;
+  int pipedes[2];
+  pid_t pid;
+
+#ifndef __MSDOS__
+#ifdef WINDOWS32
+  /* Reset just_print_flag.  This is needed on Windows when batch files
+     are used to run the commands, because we normally refrain from
+     creating batch files under -n.  */
+  int j_p_f = just_print_flag;
+  just_print_flag = 0;
+#endif
+
+  /* Construct the argument list.  */
+  command_argv = construct_command_argv (argv[0], NULL, NULL, 0,
+                                         &batch_filename);
+  if (command_argv == 0)
+    {
+#ifdef WINDOWS32
+      just_print_flag = j_p_f;
+#endif
+      return o;
+    }
+#endif /* !__MSDOS__ */
+
+  /* Using a target environment for 'shell' loses in cases like:
+       export var = $(shell echo foobie)
+       bad := $(var)
+     because target_environment hits a loop trying to expand $(var) to put it
+     in the environment.  This is even more confusing when 'var' was not
+     explicitly exported, but just appeared in the calling environment.
+
+     See Savannah bug #10593.
+
+  envp = target_environment (NULL);
+  */
+
+  envp = environ;
+
+  /* For error messages.  */
+  if (reading_file && reading_file->filenm)
+    {
+      char *p = alloca (strlen (reading_file->filenm)+11+4);
+      sprintf (p, "%s:%lu: ", reading_file->filenm,
+               reading_file->lineno + reading_file->offset);
+      error_prefix = p;
+    }
+  else
+    error_prefix = "";
+
+  /* Set up the output in case the shell writes something.  */
+  output_start ();
+
+  errfd = (output_context && output_context->err >= 0
+           ? output_context->err : FD_STDERR);
+
+#if defined(__MSDOS__)
+  fpipe = msdos_openpipe (pipedes, &pid, argv[0]);
+  if (pipedes[0] < 0)
+    {
+      perror_with_name (error_prefix, "pipe");
+      return o;
+    }
+
+#elif defined(WINDOWS32)
+  windows32_openpipe (pipedes, errfd, &pid, command_argv, envp);
+  /* Restore the value of just_print_flag.  */
+  just_print_flag = j_p_f;
+
+  if (pipedes[0] < 0)
+    {
+      /* Open of the pipe failed, mark as failed execution.  */
+      shell_completed (127, 0);
+      perror_with_name (error_prefix, "pipe");
+      return o;
+    }
+
+#else
+  if (pipe (pipedes) < 0)
+    {
+      perror_with_name (error_prefix, "pipe");
+      return o;
+    }
+
+  /* Close handles that are unnecessary for the child process.  */
+  fd_noinherit (pipedes[1]);
+  fd_noinherit (pipedes[0]);
+
+  {
+    struct output out;
+    out.syncout = 1;
+    out.out = pipedes[1];
+    out.err = errfd;
+
+    pid = child_execute_job (&out, 1, command_argv, envp);
+  }
+
+  if (pid < 0)
+    {
+      perror_with_name (error_prefix, "fork");
+      return o;
+    }
+#endif
+
+  {
+    char *buffer;
+    unsigned int maxlen, i;
+    int cc;
+
+    /* Record the PID for reap_children.  */
+    shell_function_pid = pid;
+#ifndef  __MSDOS__
+    shell_function_completed = 0;
+
+    /* Free the storage only the child needed.  */
+    free (command_argv[0]);
+    free (command_argv);
+
+    /* Close the write side of the pipe.  We test for -1, since
+       pipedes[1] is -1 on MS-Windows, and some versions of MS
+       libraries barf when 'close' is called with -1.  */
+    if (pipedes[1] >= 0)
+      close (pipedes[1]);
+#endif
+
+    /* Set up and read from the pipe.  */
+
+    maxlen = 200;
+    buffer = xmalloc (maxlen + 1);
+
+    /* Read from the pipe until it gets EOF.  */
+    for (i = 0; ; i += cc)
+      {
+        if (i == maxlen)
+          {
+            maxlen += 512;
+            buffer = xrealloc (buffer, maxlen + 1);
+          }
+
+        EINTRLOOP (cc, read (pipedes[0], &buffer[i], maxlen - i));
+        if (cc <= 0)
+          break;
+      }
+    buffer[i] = '\0';
+
+    /* Close the read side of the pipe.  */
+#ifdef  __MSDOS__
+    if (fpipe)
+      {
+        int st = pclose (fpipe);
+        shell_completed (st, 0);
+      }
+#else
+    (void) close (pipedes[0]);
+#endif
+
+    /* Loop until child_handler or reap_children()  sets
+       shell_function_completed to the status of our child shell.  */
+    while (shell_function_completed == 0)
+      reap_children (1, 0);
+
+    if (batch_filename)
+      {
+        DB (DB_VERBOSE, (_("Cleaning up temporary batch file %s\n"),
+                         batch_filename));
+        remove (batch_filename);
+        free (batch_filename);
+      }
+    shell_function_pid = 0;
+
+    /* shell_completed() will set shell_function_completed to 1 when the
+       child dies normally, or to -1 if it dies with status 127, which is
+       most likely an exec fail.  */
+
+    if (shell_function_completed == -1)
+      {
+        /* This likely means that the execvp failed, so we should just
+           write the error message in the pipe from the child.  */
+        fputs (buffer, stderr);
+        fflush (stderr);
+      }
+    else
+      {
+        /* The child finished normally.  Replace all newlines in its output
+           with spaces, and put that in the variable output buffer.  */
+        fold_newlines (buffer, &i, trim_newlines);
+        o = variable_buffer_output (o, buffer, i);
+      }
+
+    free (buffer);
+  }
+
+  return o;
+}
+
+#else   /* _AMIGA */
+
+/* Do the Amiga version of func_shell.  */
+
+char *
+func_shell_base (char *o, char **argv, int trim_newlines)
+{
+  /* Amiga can't fork nor spawn, but I can start a program with
+     redirection of my choice.  However, this means that we
+     don't have an opportunity to reopen stdout to trap it.  Thus,
+     we save our own stdout onto a new descriptor and dup a temp
+     file's descriptor onto our stdout temporarily.  After we
+     spawn the shell program, we dup our own stdout back to the
+     stdout descriptor.  The buffer reading is the same as above,
+     except that we're now reading from a file.  */
+
+#include <dos/dos.h>
+#include <proto/dos.h>
+
+  BPTR child_stdout;
+  char tmp_output[FILENAME_MAX];
+  unsigned int maxlen = 200, i;
+  int cc;
+  char * buffer, * ptr;
+  char ** aptr;
+  int len = 0;
+  char* batch_filename = NULL;
+
+  /* Construct the argument list.  */
+  command_argv = construct_command_argv (argv[0], NULL, NULL, 0,
+                                         &batch_filename);
+  if (command_argv == 0)
+    return o;
+
+  /* Note the mktemp() is a security hole, but this only runs on Amiga.
+     Ideally we would use get_tmpfile(), but this uses a special Open(), not
+     fopen(), and I'm not familiar enough with the code to mess with it.  */
+  strcpy (tmp_output, "t:MakeshXXXXXXXX");
+  mktemp (tmp_output);
+  child_stdout = Open (tmp_output, MODE_NEWFILE);
+
+  for (aptr=command_argv; *aptr; aptr++)
+    len += strlen (*aptr) + 1;
+
+  buffer = xmalloc (len + 1);
+  ptr = buffer;
+
+  for (aptr=command_argv; *aptr; aptr++)
+    {
+      strcpy (ptr, *aptr);
+      ptr += strlen (ptr) + 1;
+      *ptr ++ = ' ';
+      *ptr = 0;
+    }
+
+  ptr[-1] = '\n';
+
+  Execute (buffer, NULL, child_stdout);
+  free (buffer);
+
+  Close (child_stdout);
+
+  child_stdout = Open (tmp_output, MODE_OLDFILE);
+
+  buffer = xmalloc (maxlen);
+  i = 0;
+  do
+    {
+      if (i == maxlen)
+        {
+          maxlen += 512;
+          buffer = xrealloc (buffer, maxlen + 1);
+        }
+
+      cc = Read (child_stdout, &buffer[i], maxlen - i);
+      if (cc > 0)
+        i += cc;
+    } while (cc > 0);
+
+  Close (child_stdout);
+
+  fold_newlines (buffer, &i, trim_newlines);
+  o = variable_buffer_output (o, buffer, i);
+  free (buffer);
+  return o;
+}
+#endif  /* _AMIGA */
+
+static char *
+func_shell (char *o, char **argv, const char *funcname UNUSED)
+{
+  return func_shell_base (o, argv, 1);
+}
+#endif  /* !VMS */
+
+#ifdef EXPERIMENTAL
+
+/*
+  equality. Return is string-boolean, i.e., the empty string is false.
+ */
+static char *
+func_eq (char *o, char **argv, char *funcname UNUSED)
+{
+  int result = ! strcmp (argv[0], argv[1]);
+  o = variable_buffer_output (o,  result ? "1" : "", result);
+  return o;
+}
+
+
+/*
+  string-boolean not operator.
+ */
+static char *
+func_not (char *o, char **argv, char *funcname UNUSED)
+{
+  const char *s = argv[0];
+  int result = 0;
+  NEXT_TOKEN (s);
+  result = ! (*s);
+  o = variable_buffer_output (o,  result ? "1" : "", result);
+  return o;
+}
+#endif
+
+
+#ifdef HAVE_DOS_PATHS
+# ifdef __CYGWIN__
+#  define IS_ABSOLUTE(n) ((n[0] && n[1] == ':') || STOP_SET (n[0], MAP_DIRSEP))
+# else
+#  define IS_ABSOLUTE(n) (n[0] && n[1] == ':')
+# endif
+# define ROOT_LEN 3
+#else
+#define IS_ABSOLUTE(n) (n[0] == '/')
+#define ROOT_LEN 1
+#endif
+
+/* Return the absolute name of file NAME which does not contain any '.',
+   '..' components nor any repeated path separators ('/').   */
+
+static char *
+abspath (const char *name, char *apath)
+{
+  char *dest;
+  const char *start, *end, *apath_limit;
+  unsigned long root_len = ROOT_LEN;
+
+  if (name[0] == '\0' || apath == NULL)
+    return NULL;
+
+  apath_limit = apath + GET_PATH_MAX;
+
+  if (!IS_ABSOLUTE(name))
+    {
+      /* It is unlikely we would make it until here but just to make sure. */
+      if (!starting_directory)
+        return NULL;
+
+      strcpy (apath, starting_directory);
+
+#ifdef HAVE_DOS_PATHS
+      if (STOP_SET (name[0], MAP_DIRSEP))
+        {
+          if (STOP_SET (name[1], MAP_DIRSEP))
+            {
+              /* A UNC.  Don't prepend a drive letter.  */
+              apath[0] = name[0];
+              apath[1] = name[1];
+              root_len = 2;
+            }
+          /* We have /foo, an absolute file name except for the drive
+             letter.  Assume the missing drive letter is the current
+             drive, which we can get if we remove from starting_directory
+             everything past the root directory.  */
+          apath[root_len] = '\0';
+        }
+#endif
+
+      dest = strchr (apath, '\0');
+    }
+  else
+    {
+#if defined(__CYGWIN__) && defined(HAVE_DOS_PATHS)
+      if (STOP_SET (name[0], MAP_DIRSEP))
+        root_len = 1;
+#endif
+      strncpy (apath, name, root_len);
+      apath[root_len] = '\0';
+      dest = apath + root_len;
+      /* Get past the root, since we already copied it.  */
+      name += root_len;
+#ifdef HAVE_DOS_PATHS
+      if (! STOP_SET (apath[root_len - 1], MAP_DIRSEP))
+        {
+          /* Convert d:foo into d:./foo and increase root_len.  */
+          apath[2] = '.';
+          apath[3] = '/';
+          dest++;
+          root_len++;
+          /* strncpy above copied one character too many.  */
+          name--;
+        }
+      else
+        apath[root_len - 1] = '/'; /* make sure it's a forward slash */
+#endif
+    }
+
+  for (start = end = name; *start != '\0'; start = end)
+    {
+      unsigned long len;
+
+      /* Skip sequence of multiple path-separators.  */
+      while (STOP_SET (*start, MAP_DIRSEP))
+        ++start;
+
+      /* Find end of path component.  */
+      for (end = start; ! STOP_SET (*end, MAP_DIRSEP|MAP_NUL); ++end)
+        ;
+
+      len = end - start;
+
+      if (len == 0)
+        break;
+      else if (len == 1 && start[0] == '.')
+        /* nothing */;
+      else if (len == 2 && start[0] == '.' && start[1] == '.')
+        {
+          /* Back up to previous component, ignore if at root already.  */
+          if (dest > apath + root_len)
+            for (--dest; ! STOP_SET (dest[-1], MAP_DIRSEP); --dest)
+              ;
+        }
+      else
+        {
+          if (! STOP_SET (dest[-1], MAP_DIRSEP))
+            *dest++ = '/';
+
+          if (dest + len >= apath_limit)
+            return NULL;
+
+          dest = memcpy (dest, start, len);
+          dest += len;
+          *dest = '\0';
+        }
+    }
+
+  /* Unless it is root strip trailing separator.  */
+  if (dest > apath + root_len && STOP_SET (dest[-1], MAP_DIRSEP))
+    --dest;
+
+  *dest = '\0';
+
+  return apath;
+}
+
+
+static char *
+func_realpath (char *o, char **argv, const char *funcname UNUSED)
+{
+  /* Expand the argument.  */
+  const char *p = argv[0];
+  const char *path = 0;
+  int doneany = 0;
+  unsigned int len = 0;
+
+  while ((path = find_next_token (&p, &len)) != 0)
+    {
+      if (len < GET_PATH_MAX)
+        {
+          char *rp;
+          struct stat st;
+          PATH_VAR (in);
+          PATH_VAR (out);
+
+          strncpy (in, path, len);
+          in[len] = '\0';
+
+#ifdef HAVE_REALPATH
+          ENULLLOOP (rp, realpath (in, out));
+#else
+          rp = abspath (in, out);
+#endif
+
+          if (rp)
+            {
+              int r;
+              EINTRLOOP (r, stat (out, &st));
+              if (r == 0)
+                {
+                  o = variable_buffer_output (o, out, strlen (out));
+                  o = variable_buffer_output (o, " ", 1);
+                  doneany = 1;
+                }
+            }
+        }
+    }
+
+  /* Kill last space.  */
+  if (doneany)
+    --o;
+
+  return o;
+}
+
+static char *
+func_file (char *o, char **argv, const char *funcname UNUSED)
+{
+  char *fn = argv[0];
+
+  if (fn[0] == '>')
+    {
+      FILE *fp;
+      const char *mode = "w";
+
+      /* We are writing a file.  */
+      ++fn;
+      if (fn[0] == '>')
+        {
+          mode = "a";
+          ++fn;
+        }
+      NEXT_TOKEN (fn);
+
+      if (fn[0] == '\0')
+        O (fatal, *expanding_var, _("file: missing filename"));
+
+      ENULLLOOP (fp, fopen (fn, mode));
+      if (fp == NULL)
+        OSS (fatal, reading_file, _("open: %s: %s"), fn, strerror (errno));
+
+      if (argv[1])
+        {
+          int l = strlen (argv[1]);
+          int nl = l == 0 || argv[1][l-1] != '\n';
+
+          if (fputs (argv[1], fp) == EOF || (nl && fputc ('\n', fp) == EOF))
+            OSS (fatal, reading_file, _("write: %s: %s"), fn, strerror (errno));
+        }
+      if (fclose (fp))
+        OSS (fatal, reading_file, _("close: %s: %s"), fn, strerror (errno));
+    }
+  else if (fn[0] == '<')
+    {
+      char *preo = o;
+      FILE *fp;
+
+      ++fn;
+      NEXT_TOKEN (fn);
+      if (fn[0] == '\0')
+        O (fatal, *expanding_var, _("file: missing filename"));
+
+      if (argv[1])
+        O (fatal, *expanding_var, _("file: too many arguments"));
+
+      ENULLLOOP (fp, fopen (fn, "r"));
+      if (fp == NULL)
+        {
+          if (errno == ENOENT)
+            return o;
+          OSS (fatal, reading_file, _("open: %s: %s"), fn, strerror (errno));
+        }
+
+      while (1)
+        {
+          char buf[1024];
+          size_t l = fread (buf, 1, sizeof (buf), fp);
+          if (l > 0)
+            o = variable_buffer_output (o, buf, l);
+
+          if (ferror (fp))
+            if (errno != EINTR)
+              OSS (fatal, reading_file, _("read: %s: %s"), fn, strerror (errno));
+          if (feof (fp))
+            break;
+        }
+      if (fclose (fp))
+        OSS (fatal, reading_file, _("close: %s: %s"), fn, strerror (errno));
+
+      /* Remove trailing newline.  */
+      if (o > preo && o[-1] == '\n')
+        if (--o > preo && o[-1] == '\r')
+          --o;
+    }
+  else
+    OS (fatal, *expanding_var, _("file: invalid file operation: %s"), fn);
+
+  return o;
+}
+
+static char *
+func_abspath (char *o, char **argv, const char *funcname UNUSED)
+{
+  /* Expand the argument.  */
+  const char *p = argv[0];
+  const char *path = 0;
+  int doneany = 0;
+  unsigned int len = 0;
+
+  while ((path = find_next_token (&p, &len)) != 0)
+    {
+      if (len < GET_PATH_MAX)
+        {
+          PATH_VAR (in);
+          PATH_VAR (out);
+
+          strncpy (in, path, len);
+          in[len] = '\0';
+
+          if (abspath (in, out))
+            {
+              o = variable_buffer_output (o, out, strlen (out));
+              o = variable_buffer_output (o, " ", 1);
+              doneany = 1;
+            }
+        }
+    }
+
+  /* Kill last space.  */
+  if (doneany)
+    --o;
+
+  return o;
+}
+
+/* Lookup table for builtin functions.
+
+   This doesn't have to be sorted; we use a straight lookup.  We might gain
+   some efficiency by moving most often used functions to the start of the
+   table.
+
+   If MAXIMUM_ARGS is 0, that means there is no maximum and all
+   comma-separated values are treated as arguments.
+
+   EXPAND_ARGS means that all arguments should be expanded before invocation.
+   Functions that do namespace tricks (foreach) don't automatically expand.  */
+
+static char *func_call (char *o, char **argv, const char *funcname);
+
+#define FT_ENTRY(_name, _min, _max, _exp, _func) \
+  { { (_func) }, STRING_SIZE_TUPLE(_name), (_min), (_max), (_exp), 0 }
+
+static struct function_table_entry function_table_init[] =
+{
+ /*         Name            MIN MAX EXP? Function */
+  FT_ENTRY ("abspath",       0,  1,  1,  func_abspath),
+  FT_ENTRY ("addprefix",     2,  2,  1,  func_addsuffix_addprefix),
+  FT_ENTRY ("addsuffix",     2,  2,  1,  func_addsuffix_addprefix),
+  FT_ENTRY ("basename",      0,  1,  1,  func_basename_dir),
+  FT_ENTRY ("dir",           0,  1,  1,  func_basename_dir),
+  FT_ENTRY ("notdir",        0,  1,  1,  func_notdir_suffix),
+  FT_ENTRY ("subst",         3,  3,  1,  func_subst),
+  FT_ENTRY ("suffix",        0,  1,  1,  func_notdir_suffix),
+  FT_ENTRY ("filter",        2,  2,  1,  func_filter_filterout),
+  FT_ENTRY ("filter-out",    2,  2,  1,  func_filter_filterout),
+  FT_ENTRY ("findstring",    2,  2,  1,  func_findstring),
+  FT_ENTRY ("firstword",     0,  1,  1,  func_firstword),
+  FT_ENTRY ("flavor",        0,  1,  1,  func_flavor),
+  FT_ENTRY ("join",          2,  2,  1,  func_join),
+  FT_ENTRY ("lastword",      0,  1,  1,  func_lastword),
+  FT_ENTRY ("patsubst",      3,  3,  1,  func_patsubst),
+  FT_ENTRY ("realpath",      0,  1,  1,  func_realpath),
+  FT_ENTRY ("shell",         0,  1,  1,  func_shell),
+  FT_ENTRY ("sort",          0,  1,  1,  func_sort),
+  FT_ENTRY ("strip",         0,  1,  1,  func_strip),
+  FT_ENTRY ("wildcard",      0,  1,  1,  func_wildcard),
+  FT_ENTRY ("word",          2,  2,  1,  func_word),
+  FT_ENTRY ("wordlist",      3,  3,  1,  func_wordlist),
+  FT_ENTRY ("words",         0,  1,  1,  func_words),
+  FT_ENTRY ("origin",        0,  1,  1,  func_origin),
+  FT_ENTRY ("foreach",       3,  3,  0,  func_foreach),
+  FT_ENTRY ("call",          1,  0,  1,  func_call),
+  FT_ENTRY ("info",          0,  1,  1,  func_error),
+  FT_ENTRY ("error",         0,  1,  1,  func_error),
+  FT_ENTRY ("warning",       0,  1,  1,  func_error),
+  FT_ENTRY ("if",            2,  3,  0,  func_if),
+  FT_ENTRY ("or",            1,  0,  0,  func_or),
+  FT_ENTRY ("and",           1,  0,  0,  func_and),
+  FT_ENTRY ("value",         0,  1,  1,  func_value),
+  FT_ENTRY ("eval",          0,  1,  1,  func_eval),
+  FT_ENTRY ("file",          1,  2,  1,  func_file),
+#ifdef EXPERIMENTAL
+  FT_ENTRY ("eq",            2,  2,  1,  func_eq),
+  FT_ENTRY ("not",           0,  1,  1,  func_not),
+#endif
+};
+
+#define FUNCTION_TABLE_ENTRIES (sizeof (function_table_init) / sizeof (struct function_table_entry))
+
+
+/* These must come after the definition of function_table.  */
+
+static char *
+expand_builtin_function (char *o, int argc, char **argv,
+                         const struct function_table_entry *entry_p)
+{
+  char *p;
+
+  if (argc < (int)entry_p->minimum_args)
+    fatal (*expanding_var, strlen (entry_p->name),
+           _("insufficient number of arguments (%d) to function '%s'"),
+           argc, entry_p->name);
+
+  /* I suppose technically some function could do something with no arguments,
+     but so far no internal ones do, so just test it for all functions here
+     rather than in each one.  We can change it later if necessary.  */
+
+  if (!argc && !entry_p->alloc_fn)
+    return o;
+
+  if (!entry_p->fptr.func_ptr)
+    OS (fatal, *expanding_var,
+        _("unimplemented on this platform: function '%s'"), entry_p->name);
+
+  if (!entry_p->alloc_fn)
+    return entry_p->fptr.func_ptr (o, argv, entry_p->name);
+
+  /* This function allocates memory and returns it to us.
+     Write it to the variable buffer, then free it.  */
+
+  p = entry_p->fptr.alloc_func_ptr (entry_p->name, argc, argv);
+  if (p)
+    {
+      o = variable_buffer_output (o, p, strlen (p));
+      free (p);
+    }
+
+  return o;
+}
+
+/* Check for a function invocation in *STRINGP.  *STRINGP points at the
+   opening ( or { and is not null-terminated.  If a function invocation
+   is found, expand it into the buffer at *OP, updating *OP, incrementing
+   *STRINGP past the reference and returning nonzero.  If not, return zero.  */
+
+int
+handle_function (char **op, const char **stringp)
+{
+  const struct function_table_entry *entry_p;
+  char openparen = (*stringp)[0];
+  char closeparen = openparen == '(' ? ')' : '}';
+  const char *beg;
+  const char *end;
+  int count = 0;
+  char *abeg = NULL;
+  char **argv, **argvp;
+  int nargs;
+
+  beg = *stringp + 1;
+
+  entry_p = lookup_function (beg);
+
+  if (!entry_p)
+    return 0;
+
+  /* We found a builtin function.  Find the beginning of its arguments (skip
+     whitespace after the name).  */
+
+  beg += entry_p->len;
+  NEXT_TOKEN (beg);
+
+  /* Find the end of the function invocation, counting nested use of
+     whichever kind of parens we use.  Since we're looking, count commas
+     to get a rough estimate of how many arguments we might have.  The
+     count might be high, but it'll never be low.  */
+
+  for (nargs=1, end=beg; *end != '\0'; ++end)
+    if (!STOP_SET (*end, MAP_VARSEP|MAP_COMMA))
+      continue;
+    else if (*end == ',')
+      ++nargs;
+    else if (*end == openparen)
+      ++count;
+    else if (*end == closeparen && --count < 0)
+      break;
+
+  if (count >= 0)
+    fatal (*expanding_var, strlen (entry_p->name),
+           _("unterminated call to function '%s': missing '%c'"),
+           entry_p->name, closeparen);
+
+  *stringp = end;
+
+  /* Get some memory to store the arg pointers.  */
+  argvp = argv = alloca (sizeof (char *) * (nargs + 2));
+
+  /* Chop the string into arguments, then a nul.  As soon as we hit
+     MAXIMUM_ARGS (if it's >0) assume the rest of the string is part of the
+     last argument.
+
+     If we're expanding, store pointers to the expansion of each one.  If
+     not, make a duplicate of the string and point into that, nul-terminating
+     each argument.  */
+
+  if (entry_p->expand_args)
+    {
+      const char *p;
+      for (p=beg, nargs=0; p <= end; ++argvp)
+        {
+          const char *next;
+
+          ++nargs;
+
+          if (nargs == entry_p->maximum_args
+              || (! (next = find_next_argument (openparen, closeparen, p, end))))
+            next = end;
+
+          *argvp = expand_argument (p, next);
+          p = next + 1;
+        }
+    }
+  else
+    {
+      int len = end - beg;
+      char *p, *aend;
+
+      abeg = xmalloc (len+1);
+      memcpy (abeg, beg, len);
+      abeg[len] = '\0';
+      aend = abeg + len;
+
+      for (p=abeg, nargs=0; p <= aend; ++argvp)
+        {
+          char *next;
+
+          ++nargs;
+
+          if (nargs == entry_p->maximum_args
+              || (! (next = find_next_argument (openparen, closeparen, p, aend))))
+            next = aend;
+
+          *argvp = p;
+          *next = '\0';
+          p = next + 1;
+        }
+    }
+  *argvp = NULL;
+
+  /* Finally!  Run the function...  */
+  *op = expand_builtin_function (*op, nargs, argv, entry_p);
+
+  /* Free memory.  */
+  if (entry_p->expand_args)
+    for (argvp=argv; *argvp != 0; ++argvp)
+      free (*argvp);
+  else
+    free (abeg);
+
+  return 1;
+}
+
+
+/* User-defined functions.  Expand the first argument as either a builtin
+   function or a make variable, in the context of the rest of the arguments
+   assigned to $1, $2, ... $N.  $0 is the name of the function.  */
+
+static char *
+func_call (char *o, char **argv, const char *funcname UNUSED)
+{
+  static int max_args = 0;
+  char *fname;
+  char *body;
+  int flen;
+  int i;
+  int saved_args;
+  const struct function_table_entry *entry_p;
+  struct variable *v;
+
+  /* Clean up the name of the variable to be invoked.  */
+  fname = next_token (argv[0]);
+  end_of_token (fname)[0] = '\0';
+
+  /* Calling nothing is a no-op */
+  if (*fname == '\0')
+    return o;
+
+  /* Are we invoking a builtin function?  */
+
+  entry_p = lookup_function (fname);
+  if (entry_p)
+    {
+      /* How many arguments do we have?  */
+      for (i=0; argv[i+1]; ++i)
+        ;
+      return expand_builtin_function (o, i, argv+1, entry_p);
+    }
+
+  /* Not a builtin, so the first argument is the name of a variable to be
+     expanded and interpreted as a function.  Find it.  */
+  flen = strlen (fname);
+
+  v = lookup_variable (fname, flen);
+
+  if (v == 0)
+    warn_undefined (fname, flen);
+
+  if (v == 0 || *v->value == '\0')
+    return o;
+
+  body = alloca (flen + 4);
+  body[0] = '$';
+  body[1] = '(';
+  memcpy (body + 2, fname, flen);
+  body[flen+2] = ')';
+  body[flen+3] = '\0';
+
+  /* Set up arguments $(1) .. $(N).  $(0) is the function name.  */
+
+  push_new_variable_scope ();
+
+  for (i=0; *argv; ++i, ++argv)
+    {
+      char num[11];
+
+      sprintf (num, "%d", i);
+      define_variable (num, strlen (num), *argv, o_automatic, 0);
+    }
+
+  /* If the number of arguments we have is < max_args, it means we're inside
+     a recursive invocation of $(call ...).  Fill in the remaining arguments
+     in the new scope with the empty value, to hide them from this
+     invocation.  */
+
+  for (; i < max_args; ++i)
+    {
+      char num[11];
+
+      sprintf (num, "%d", i);
+      define_variable (num, strlen (num), "", o_automatic, 0);
+    }
+
+  /* Expand the body in the context of the arguments, adding the result to
+     the variable buffer.  */
+
+  v->exp_count = EXP_COUNT_MAX;
+
+  saved_args = max_args;
+  max_args = i;
+  o = variable_expand_string (o, body, flen+3);
+  max_args = saved_args;
+
+  v->exp_count = 0;
+
+  pop_variable_scope ();
+
+  return o + strlen (o);
+}
+
+void
+define_new_function (const floc *flocp, const char *name,
+                     unsigned int min, unsigned int max, unsigned int flags,
+                     gmk_func_ptr func)
+{
+  const char *e = name;
+  struct function_table_entry *ent;
+  size_t len;
+
+  while (STOP_SET (*e, MAP_USERFUNC))
+    e++;
+  len = e - name;
+
+  if (len == 0)
+    O (fatal, flocp, _("Empty function name"));
+  if (*name == '.' || *e != '\0')
+    OS (fatal, flocp, _("Invalid function name: %s"), name);
+  if (len > 255)
+    OS (fatal, flocp, _("Function name too long: %s"), name);
+  if (min > 255)
+    ONS (fatal, flocp,
+         _("Invalid minimum argument count (%u) for function %s"), min, name);
+  if (max > 255 || (max && max < min))
+    ONS (fatal, flocp,
+         _("Invalid maximum argument count (%u) for function %s"), max, name);
+
+  ent = xmalloc (sizeof (struct function_table_entry));
+  ent->name = name;
+  ent->len = len;
+  ent->minimum_args = min;
+  ent->maximum_args = max;
+  ent->expand_args = ANY_SET(flags, GMK_FUNC_NOEXPAND) ? 0 : 1;
+  ent->alloc_fn = 1;
+  ent->fptr.alloc_func_ptr = func;
+
+  hash_insert (&function_table, ent);
+}
+
+void
+hash_init_function_table (void)
+{
+  hash_init (&function_table, FUNCTION_TABLE_ENTRIES * 2,
+             function_table_entry_hash_1, function_table_entry_hash_2,
+             function_table_entry_hash_cmp);
+  hash_load (&function_table, function_table_init,
+             FUNCTION_TABLE_ENTRIES, sizeof (struct function_table_entry));
+}
diff --git a/src/getloadavg.c b/src/getloadavg.c
new file mode 100644
index 0000000..663a7de
--- /dev/null
+++ b/src/getloadavg.c
@@ -0,0 +1,1026 @@
+/* Get the system load averages.
+Copyright (C) 1985-2017 Free Software Foundation, Inc.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Compile-time symbols that this file uses:
+
+   HAVE_PSTAT_GETDYNAMIC	Define this if your system has the
+                                pstat_getdynamic function.  I think it
+				is unique to HPUX9.  The best way to get the
+				definition is through the AC_FUNC_GETLOADAVG
+				macro that comes with autoconf 2.13 or newer.
+				If that isn't an option, then just put
+				AC_CHECK_FUNCS(pstat_getdynamic) in your
+				configure.in file.
+   FIXUP_KERNEL_SYMBOL_ADDR()	Adjust address in returned struct nlist.
+   KERNEL_FILE			Pathname of the kernel to nlist.
+   LDAV_CVT()			Scale the load average from the kernel.
+				Returns a double.
+   LDAV_SYMBOL			Name of kernel symbol giving load average.
+   LOAD_AVE_TYPE		Type of the load average array in the kernel.
+				Must be defined unless one of
+				apollo, DGUX, NeXT, or UMAX is defined;
+                                or we have libkstat;
+				otherwise, no load average is available.
+   NLIST_STRUCT			Include nlist.h, not a.out.h, and
+				the nlist n_name element is a pointer,
+				not an array.
+   HAVE_STRUCT_NLIST_N_UN_N_NAME struct nlist has an n_un member, not n_name.
+   LINUX_LDAV_FILE		[__linux__]: File containing load averages.
+
+   Specific system predefines this file uses, aside from setting
+   default values if not emacs:
+
+   apollo
+   BSD				Real BSD, not just BSD-like.
+   convex
+   DGUX
+   eunice			UNIX emulator under VMS.
+   hpux
+   __MSDOS__			No-op for MSDOS.
+   NeXT
+   sgi
+   sequent			Sequent Dynix 3.x.x (BSD)
+   _SEQUENT_			Sequent DYNIX/ptx 1.x.x (SYSV)
+   sony_news                    NEWS-OS (works at least for 4.1C)
+   UMAX
+   UMAX4_3
+   VMS
+   WINDOWS32			No-op for Windows95/NT.
+   __linux__			Linux: assumes /proc filesystem mounted.
+   				Support from Michael K. Johnson.
+   __NetBSD__			NetBSD: assumes /kern filesystem mounted.
+
+   In addition, to avoid nesting many #ifdefs, we internally set
+   LDAV_DONE to indicate that the load average has been computed.
+
+   We also #define LDAV_PRIVILEGED if a program will require
+   special installation to be able to call getloadavg.  */
+
+/* This should always be first.  */
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <sys/types.h>
+
+/* Both the Emacs and non-Emacs sections want this.  Some
+   configuration files' definitions for the LOAD_AVE_CVT macro (like
+   sparc.h's) use macros like FSCALE, defined here.  */
+#if defined (unix) || defined (__unix)
+# include <sys/param.h>
+#endif
+
+
+/* Exclude all the code except the test program at the end
+   if the system has its own 'getloadavg' function.
+
+   The declaration of 'errno' is needed by the test program
+   as well as the function itself, so it comes first.  */
+
+#include <errno.h>
+
+#ifndef errno
+extern int errno;
+#endif
+
+#if HAVE_LOCALE_H
+# include <locale.h>
+#endif
+#if !HAVE_SETLOCALE
+# define setlocale(Category, Locale) /* empty */
+#endif
+
+#ifndef HAVE_GETLOADAVG
+
+
+/* The existing Emacs configuration files define a macro called
+   LOAD_AVE_CVT, which accepts a value of type LOAD_AVE_TYPE, and
+   returns the load average multiplied by 100.  What we actually want
+   is a macro called LDAV_CVT, which returns the load average as an
+   unmultiplied double.
+
+   For backwards compatibility, we'll define LDAV_CVT in terms of
+   LOAD_AVE_CVT, but future machine config files should just define
+   LDAV_CVT directly.  */
+
+# if !defined(LDAV_CVT) && defined(LOAD_AVE_CVT)
+#  define LDAV_CVT(n) (LOAD_AVE_CVT (n) / 100.0)
+# endif
+
+# if !defined (BSD) && defined (ultrix)
+/* Ultrix behaves like BSD on Vaxen.  */
+#  define BSD
+# endif
+
+# ifdef NeXT
+/* NeXT in the 2.{0,1,2} releases defines BSD in <sys/param.h>, which
+   conflicts with the definition understood in this file, that this
+   really is BSD. */
+#  undef BSD
+
+/* NeXT defines FSCALE in <sys/param.h>.  However, we take FSCALE being
+   defined to mean that the nlist method should be used, which is not true.  */
+#  undef FSCALE
+# endif
+
+/* Same issues as for NeXT apply to the HURD-based GNU system.  */
+# ifdef __GNU__
+#  undef BSD
+#  undef FSCALE
+# endif /* __GNU__ */
+
+/* Set values that are different from the defaults, which are
+   set a little farther down with #ifndef.  */
+
+
+/* Some shorthands.  */
+
+# if defined (HPUX) && !defined (hpux)
+#  define hpux
+# endif
+
+# if defined (__hpux) && !defined (hpux)
+#  define hpux
+# endif
+
+# if defined (__sun) && !defined (sun)
+#  define sun
+# endif
+
+# if defined(hp300) && !defined(hpux)
+#  define MORE_BSD
+# endif
+
+# if defined(ultrix) && defined(mips)
+#  define decstation
+# endif
+
+# if defined (__SVR4) && !defined (SVR4)
+#  define SVR4
+# endif
+
+# if (defined(sun) && defined(SVR4)) || defined (SOLARIS2)
+#  define SUNOS_5
+# endif
+
+# if defined (__osf__) && (defined (__alpha) || defined (__alpha__))
+#  define OSF_ALPHA
+#  include <sys/mbuf.h>
+#  include <sys/socket.h>
+#  include <net/route.h>
+#  include <sys/table.h>
+# endif
+
+# if defined (__osf__) && (defined (mips) || defined (__mips__))
+#  define OSF_MIPS
+#  include <sys/table.h>
+# endif
+
+/* UTek's /bin/cc on the 4300 has no architecture specific cpp define by
+   default, but _MACH_IND_SYS_TYPES is defined in <sys/types.h>.  Combine
+   that with a couple of other things and we'll have a unique match.  */
+# if !defined (tek4300) && defined (unix) && defined (m68k) && defined (mc68000) && defined (mc68020) && defined (_MACH_IND_SYS_TYPES)
+#  define tek4300			/* Define by emacs, but not by other users.  */
+# endif
+
+/* AC_FUNC_GETLOADAVG thinks QNX is SVR4, but it isn't. */
+# if defined(__QNX__)
+#  undef SVR4
+# endif
+
+/* VAX C can't handle multi-line #ifs, or lines longer than 256 chars.  */
+# ifndef LOAD_AVE_TYPE
+
+#  ifdef MORE_BSD
+#   define LOAD_AVE_TYPE long
+#  endif
+
+#  ifdef sun
+#   define LOAD_AVE_TYPE long
+#  endif
+
+#  ifdef decstation
+#   define LOAD_AVE_TYPE long
+#  endif
+
+#  ifdef _SEQUENT_
+#   define LOAD_AVE_TYPE long
+#  endif
+
+#  ifdef sgi
+#   define LOAD_AVE_TYPE long
+#  endif
+
+#  ifdef SVR4
+#   define LOAD_AVE_TYPE long
+#  endif
+
+#  ifdef sony_news
+#   define LOAD_AVE_TYPE long
+#  endif
+
+#  ifdef sequent
+#   define LOAD_AVE_TYPE long
+#  endif
+
+#  ifdef OSF_ALPHA
+#   define LOAD_AVE_TYPE long
+#  endif
+
+#  if defined (ardent) && defined (titan)
+#   define LOAD_AVE_TYPE long
+#  endif
+
+#  ifdef tek4300
+#   define LOAD_AVE_TYPE long
+#  endif
+
+#  if defined(alliant) && defined(i860) /* Alliant FX/2800 */
+#   define LOAD_AVE_TYPE long
+#  endif
+
+#  ifdef _AIX
+#   define LOAD_AVE_TYPE long
+#  endif
+
+#  ifdef convex
+#   define LOAD_AVE_TYPE double
+#   ifndef LDAV_CVT
+#    define LDAV_CVT(n) (n)
+#   endif
+#  endif
+
+# endif /* No LOAD_AVE_TYPE.  */
+
+# ifdef OSF_ALPHA
+/* <sys/param.h> defines an incorrect value for FSCALE on Alpha OSF/1,
+   according to ghazi@noc.rutgers.edu.  */
+#  undef FSCALE
+#  define FSCALE 1024.0
+# endif
+
+# if defined(alliant) && defined(i860) /* Alliant FX/2800 */
+/* <sys/param.h> defines an incorrect value for FSCALE on an
+   Alliant FX/2800 Concentrix 2.2, according to ghazi@noc.rutgers.edu.  */
+#  undef FSCALE
+#  define FSCALE 100.0
+# endif
+
+
+# ifndef	FSCALE
+
+/* SunOS and some others define FSCALE in sys/param.h.  */
+
+#  ifdef MORE_BSD
+#   define FSCALE 2048.0
+#  endif
+
+#  if defined(MIPS) || defined(SVR4) || defined(decstation)
+#   define FSCALE 256
+#  endif
+
+#  if defined (sgi) || defined (sequent)
+/* Sometimes both MIPS and sgi are defined, so FSCALE was just defined
+   above under #ifdef MIPS.  But we want the sgi value.  */
+#   undef FSCALE
+#   define	FSCALE 1000.0
+#  endif
+
+#  if defined (ardent) && defined (titan)
+#   define FSCALE 65536.0
+#  endif
+
+#  ifdef tek4300
+#   define FSCALE 100.0
+#  endif
+
+#  ifdef _AIX
+#   define FSCALE 65536.0
+#  endif
+
+# endif	/* Not FSCALE.  */
+
+# if !defined (LDAV_CVT) && defined (FSCALE)
+#  define	LDAV_CVT(n) (((double) (n)) / FSCALE)
+# endif
+
+
+# if defined(sgi) || (defined(mips) && !defined(BSD))
+#  define FIXUP_KERNEL_SYMBOL_ADDR(nl) ((nl)[0].n_value &= ~(1 << 31))
+# endif
+
+
+# if !defined (KERNEL_FILE) && defined (sequent)
+#  define KERNEL_FILE "/dynix"
+# endif
+
+# if !defined (KERNEL_FILE) && defined (hpux)
+#  define KERNEL_FILE "/hp-ux"
+# endif
+
+# if !defined(KERNEL_FILE) && (defined(_SEQUENT_) || defined(MIPS) || defined(SVR4) || defined(ISC) || defined (sgi) || (defined (ardent) && defined (titan)))
+#  define KERNEL_FILE "/unix"
+# endif
+
+
+# if !defined (LDAV_SYMBOL) && defined (alliant)
+#  define LDAV_SYMBOL "_Loadavg"
+# endif
+
+# if !defined(LDAV_SYMBOL) && ((defined(hpux) && !defined(hp9000s300)) || defined(_SEQUENT_) || defined(SVR4) || defined(ISC) || defined(sgi) || (defined (ardent) && defined (titan)) || defined (_AIX))
+#  define LDAV_SYMBOL "avenrun"
+# endif
+
+# ifdef HAVE_UNISTD_H
+#  include <unistd.h>
+# endif
+
+# include <stdio.h>
+
+/* LOAD_AVE_TYPE should only get defined if we're going to use the
+   nlist method.  */
+# if !defined(LOAD_AVE_TYPE) && (defined(BSD) || defined(LDAV_CVT) || defined(KERNEL_FILE) || defined(LDAV_SYMBOL)) && !defined(__riscos__)
+#  define LOAD_AVE_TYPE double
+# endif
+
+# ifdef LOAD_AVE_TYPE
+
+#  ifndef VMS
+#   ifndef __linux__
+#    ifdef HAVE_NLIST_H
+#     include <nlist.h>
+#    else
+#     include <a.out.h>
+#    endif
+
+#    ifdef SUNOS_5
+#     include <fcntl.h>
+#     include <kvm.h>
+#     include <kstat.h>
+#    endif
+
+#    if defined (hpux) && defined (HAVE_PSTAT_GETDYNAMIC)
+#     include <sys/pstat.h>
+#    endif
+
+#    ifndef KERNEL_FILE
+#     define KERNEL_FILE "/vmunix"
+#    endif /* KERNEL_FILE */
+
+#    ifndef LDAV_SYMBOL
+#     define LDAV_SYMBOL "_avenrun"
+#    endif /* LDAV_SYMBOL */
+#   endif /* __linux__ */
+
+#  else /* VMS */
+
+#   ifndef eunice
+#    include <iodef.h>
+#    include <descrip.h>
+#   else /* eunice */
+#    include <vms/iodef.h>
+#   endif /* eunice */
+#  endif /* VMS */
+
+#  ifndef LDAV_CVT
+#   define LDAV_CVT(n) ((double) (n))
+#  endif /* !LDAV_CVT */
+
+# endif /* LOAD_AVE_TYPE */
+
+# if defined(__GNU__) && !defined (NeXT)
+/* Note that NeXT Openstep defines __GNU__ even though it should not.  */
+/* GNU system acts much like NeXT, for load average purposes,
+   but not exactly.  */
+#  define NeXT
+#  define host_self mach_host_self
+# endif
+
+# ifdef NeXT
+#  ifdef HAVE_MACH_MACH_H
+#   include <mach/mach.h>
+#  else
+#   include <mach.h>
+#  endif
+# endif /* NeXT */
+
+# ifdef sgi
+#  include <sys/sysmp.h>
+# endif /* sgi */
+
+# ifdef UMAX
+#  include <stdio.h>
+#  include <signal.h>
+#  include <sys/time.h>
+#  include <sys/wait.h>
+#  include <sys/syscall.h>
+
+#  ifdef UMAX_43
+#   include <machine/cpu.h>
+#   include <inq_stats/statistics.h>
+#   include <inq_stats/sysstats.h>
+#   include <inq_stats/cpustats.h>
+#   include <inq_stats/procstats.h>
+#  else /* Not UMAX_43.  */
+#   include <sys/sysdefs.h>
+#   include <sys/statistics.h>
+#   include <sys/sysstats.h>
+#   include <sys/cpudefs.h>
+#   include <sys/cpustats.h>
+#   include <sys/procstats.h>
+#  endif /* Not UMAX_43.  */
+# endif /* UMAX */
+
+# ifdef DGUX
+#  include <sys/dg_sys_info.h>
+# endif
+
+# if defined(HAVE_FCNTL_H) || defined(_POSIX_VERSION)
+#  include <fcntl.h>
+# else
+#  include <sys/file.h>
+# endif
+
+
+/* Avoid static vars inside a function since in HPUX they dump as pure.  */
+
+# ifdef NeXT
+static processor_set_t default_set;
+static int getloadavg_initialized;
+# endif /* NeXT */
+
+# ifdef UMAX
+static unsigned int cpus = 0;
+static unsigned int samples;
+# endif /* UMAX */
+
+# ifdef DGUX
+static struct dg_sys_info_load_info load_info;	/* what-a-mouthful! */
+# endif /* DGUX */
+
+#if !defined(HAVE_LIBKSTAT) && defined(LOAD_AVE_TYPE)
+/* File descriptor open to /dev/kmem or VMS load ave driver.  */
+static int channel;
+/* Nonzero iff channel is valid.  */
+static int getloadavg_initialized;
+/* Offset in kmem to seek to read load average, or 0 means invalid.  */
+static long offset;
+
+#if !defined(VMS) && !defined(sgi) && !defined(__linux__)
+static struct nlist nl[2];
+#endif /* Not VMS or sgi */
+
+#ifdef SUNOS_5
+static kvm_t *kd;
+#endif /* SUNOS_5 */
+
+#endif /* LOAD_AVE_TYPE && !HAVE_LIBKSTAT */
+
+/* Put the 1 minute, 5 minute and 15 minute load averages
+   into the first NELEM elements of LOADAVG.
+   Return the number written (never more than 3, but may be less than NELEM),
+   or -1 if an error occurred.  */
+
+int
+getloadavg (double loadavg[], int nelem)
+{
+  int elem = 0;			/* Return value.  */
+
+# ifdef NO_GET_LOAD_AVG
+#  define LDAV_DONE
+  /* Set errno to zero to indicate that there was no particular error;
+     this function just can't work at all on this system.  */
+  errno = 0;
+  elem = -1;
+# endif
+
+# if !defined (LDAV_DONE) && defined (HAVE_LIBKSTAT)
+/* Use libkstat because we don't have to be root.  */
+#  define LDAV_DONE
+  kstat_ctl_t *kc;
+  kstat_t *ksp;
+  kstat_named_t *kn;
+
+  kc = kstat_open ();
+  if (kc == 0)
+    return -1;
+  ksp = kstat_lookup (kc, "unix", 0, "system_misc");
+  if (ksp == 0 )
+    return -1;
+  if (kstat_read (kc, ksp, 0) == -1)
+    return -1;
+
+
+  kn = kstat_data_lookup (ksp, "avenrun_1min");
+  if (kn == 0)
+    {
+      /* Return -1 if no load average information is available.  */
+      nelem = 0;
+      elem = -1;
+    }
+
+  if (nelem >= 1)
+    loadavg[elem++] = (double) kn->value.ul/FSCALE;
+
+  if (nelem >= 2)
+    {
+      kn = kstat_data_lookup (ksp, "avenrun_5min");
+      if (kn != 0)
+	{
+	  loadavg[elem++] = (double) kn->value.ul/FSCALE;
+
+	  if (nelem >= 3)
+	    {
+	      kn = kstat_data_lookup (ksp, "avenrun_15min");
+	      if (kn != 0)
+		loadavg[elem++] = (double) kn->value.ul/FSCALE;
+	    }
+	}
+    }
+
+  kstat_close (kc);
+# endif /* HAVE_LIBKSTAT */
+
+# if !defined (LDAV_DONE) && defined (hpux) && defined (HAVE_PSTAT_GETDYNAMIC)
+/* Use pstat_getdynamic() because we don't have to be root.  */
+#  define LDAV_DONE
+#  undef LOAD_AVE_TYPE
+
+  struct pst_dynamic dyn_info;
+  if (pstat_getdynamic (&dyn_info, sizeof (dyn_info), 0, 0) < 0)
+    return -1;
+  if (nelem > 0)
+    loadavg[elem++] = dyn_info.psd_avg_1_min;
+  if (nelem > 1)
+    loadavg[elem++] = dyn_info.psd_avg_5_min;
+  if (nelem > 2)
+    loadavg[elem++] = dyn_info.psd_avg_15_min;
+
+# endif /* hpux && HAVE_PSTAT_GETDYNAMIC */
+
+# if !defined (LDAV_DONE) && defined (__linux__)
+#  define LDAV_DONE
+#  undef LOAD_AVE_TYPE
+
+#  ifndef LINUX_LDAV_FILE
+#   define LINUX_LDAV_FILE "/proc/loadavg"
+#  endif
+
+  char ldavgbuf[40];
+  double load_ave[3];
+  int fd, count;
+
+  fd = open (LINUX_LDAV_FILE, O_RDONLY);
+  if (fd == -1)
+    return -1;
+  count = read (fd, ldavgbuf, 40);
+  (void) close (fd);
+  if (count <= 0)
+    return -1;
+
+  /* The following sscanf must use the C locale.  */
+  setlocale (LC_NUMERIC, "C");
+  count = sscanf (ldavgbuf, "%lf %lf %lf",
+		  &load_ave[0], &load_ave[1], &load_ave[2]);
+  setlocale (LC_NUMERIC, "");
+  if (count < 1)
+    return -1;
+
+  for (elem = 0; elem < nelem && elem < count; elem++)
+    loadavg[elem] = load_ave[elem];
+
+  return elem;
+
+# endif /* __linux__ */
+
+# if !defined (LDAV_DONE) && defined (__NetBSD__)
+#  define LDAV_DONE
+#  undef LOAD_AVE_TYPE
+
+#  ifndef NETBSD_LDAV_FILE
+#   define NETBSD_LDAV_FILE "/kern/loadavg"
+#  endif
+
+  unsigned long int load_ave[3], scale;
+  int count;
+  FILE *fp;
+
+  fp = fopen (NETBSD_LDAV_FILE, "r");
+  if (fp == NULL)
+    return -1;
+  count = fscanf (fp, "%lu %lu %lu %lu\n",
+		  &load_ave[0], &load_ave[1], &load_ave[2],
+		  &scale);
+  (void) fclose (fp);
+  if (count != 4)
+    return -1;
+
+  for (elem = 0; elem < nelem; elem++)
+    loadavg[elem] = (double) load_ave[elem] / (double) scale;
+
+  return elem;
+
+# endif /* __NetBSD__ */
+
+# if !defined (LDAV_DONE) && defined (NeXT)
+#  define LDAV_DONE
+  /* The NeXT code was adapted from iscreen 3.2.  */
+
+  host_t host;
+  struct processor_set_basic_info info;
+  unsigned info_count;
+
+  /* We only know how to get the 1-minute average for this system,
+     so even if the caller asks for more than 1, we only return 1.  */
+
+  if (!getloadavg_initialized)
+    {
+      if (processor_set_default (host_self (), &default_set) == KERN_SUCCESS)
+	getloadavg_initialized = 1;
+    }
+
+  if (getloadavg_initialized)
+    {
+      info_count = PROCESSOR_SET_BASIC_INFO_COUNT;
+      if (processor_set_info (default_set, PROCESSOR_SET_BASIC_INFO, &host,
+			      (processor_set_info_t) &info, &info_count)
+	  != KERN_SUCCESS)
+	getloadavg_initialized = 0;
+      else
+	{
+	  if (nelem > 0)
+	    loadavg[elem++] = (double) info.load_average / LOAD_SCALE;
+	}
+    }
+
+  if (!getloadavg_initialized)
+    return -1;
+# endif /* NeXT */
+
+# if !defined (LDAV_DONE) && defined (UMAX)
+#  define LDAV_DONE
+/* UMAX 4.2, which runs on the Encore Multimax multiprocessor, does not
+   have a /dev/kmem.  Information about the workings of the running kernel
+   can be gathered with inq_stats system calls.
+   We only know how to get the 1-minute average for this system.  */
+
+  struct proc_summary proc_sum_data;
+  struct stat_descr proc_info;
+  double load;
+  register unsigned int i, j;
+
+  if (cpus == 0)
+    {
+      register unsigned int c, i;
+      struct cpu_config conf;
+      struct stat_descr desc;
+
+      desc.sd_next = 0;
+      desc.sd_subsys = SUBSYS_CPU;
+      desc.sd_type = CPUTYPE_CONFIG;
+      desc.sd_addr = (char *) &conf;
+      desc.sd_size = sizeof conf;
+
+      if (inq_stats (1, &desc))
+	return -1;
+
+      c = 0;
+      for (i = 0; i < conf.config_maxclass; ++i)
+	{
+	  struct class_stats stats;
+	  memset (&stats, '\0', sizeof stats);
+
+	  desc.sd_type = CPUTYPE_CLASS;
+	  desc.sd_objid = i;
+	  desc.sd_addr = (char *) &stats;
+	  desc.sd_size = sizeof stats;
+
+	  if (inq_stats (1, &desc))
+	    return -1;
+
+	  c += stats.class_numcpus;
+	}
+      cpus = c;
+      samples = cpus < 2 ? 3 : (2 * cpus / 3);
+    }
+
+  proc_info.sd_next = 0;
+  proc_info.sd_subsys = SUBSYS_PROC;
+  proc_info.sd_type = PROCTYPE_SUMMARY;
+  proc_info.sd_addr = (char *) &proc_sum_data;
+  proc_info.sd_size = sizeof (struct proc_summary);
+  proc_info.sd_sizeused = 0;
+
+  if (inq_stats (1, &proc_info) != 0)
+    return -1;
+
+  load = proc_sum_data.ps_nrunnable;
+  j = 0;
+  for (i = samples - 1; i > 0; --i)
+    {
+      load += proc_sum_data.ps_nrun[j];
+      if (j++ == PS_NRUNSIZE)
+	j = 0;
+    }
+
+  if (nelem > 0)
+    loadavg[elem++] = load / samples / cpus;
+# endif /* UMAX */
+
+# if !defined (LDAV_DONE) && defined (DGUX)
+#  define LDAV_DONE
+  /* This call can return -1 for an error, but with good args
+     it's not supposed to fail.  The first argument is for no
+     apparent reason of type 'long int *'.  */
+  dg_sys_info ((long int *) &load_info,
+	       DG_SYS_INFO_LOAD_INFO_TYPE,
+	       DG_SYS_INFO_LOAD_VERSION_0);
+
+  if (nelem > 0)
+    loadavg[elem++] = load_info.one_minute;
+  if (nelem > 1)
+    loadavg[elem++] = load_info.five_minute;
+  if (nelem > 2)
+    loadavg[elem++] = load_info.fifteen_minute;
+# endif /* DGUX */
+
+# if !defined (LDAV_DONE) && defined (apollo)
+#  define LDAV_DONE
+/* Apollo code from lisch@mentorg.com (Ray Lischner).
+
+   This system call is not documented.  The load average is obtained as
+   three long integers, for the load average over the past minute,
+   five minutes, and fifteen minutes.  Each value is a scaled integer,
+   with 16 bits of integer part and 16 bits of fraction part.
+
+   I'm not sure which operating system first supported this system call,
+   but I know that SR10.2 supports it.  */
+
+  extern void proc1_$get_loadav ();
+  unsigned long load_ave[3];
+
+  proc1_$get_loadav (load_ave);
+
+  if (nelem > 0)
+    loadavg[elem++] = load_ave[0] / 65536.0;
+  if (nelem > 1)
+    loadavg[elem++] = load_ave[1] / 65536.0;
+  if (nelem > 2)
+    loadavg[elem++] = load_ave[2] / 65536.0;
+# endif /* apollo */
+
+# if !defined (LDAV_DONE) && defined (OSF_MIPS)
+#  define LDAV_DONE
+
+  struct tbl_loadavg load_ave;
+  table (TBL_LOADAVG, 0, &load_ave, 1, sizeof (load_ave));
+  loadavg[elem++]
+    = (load_ave.tl_lscale == 0
+       ? load_ave.tl_avenrun.d[0]
+       : (load_ave.tl_avenrun.l[0] / (double) load_ave.tl_lscale));
+# endif	/* OSF_MIPS */
+
+# if !defined (LDAV_DONE) && (defined (__MSDOS__) || defined (WINDOWS32))
+#  define LDAV_DONE
+
+  /* A faithful emulation is going to have to be saved for a rainy day.  */
+  for ( ; elem < nelem; elem++)
+    {
+      loadavg[elem] = 0.0;
+    }
+# endif  /* __MSDOS__ || WINDOWS32 */
+
+# if !defined (LDAV_DONE) && defined (OSF_ALPHA)
+#  define LDAV_DONE
+
+  struct tbl_loadavg load_ave;
+  table (TBL_LOADAVG, 0, &load_ave, 1, sizeof (load_ave));
+  for (elem = 0; elem < nelem; elem++)
+    loadavg[elem]
+      = (load_ave.tl_lscale == 0
+       ? load_ave.tl_avenrun.d[elem]
+       : (load_ave.tl_avenrun.l[elem] / (double) load_ave.tl_lscale));
+# endif /* OSF_ALPHA */
+
+# if !defined (LDAV_DONE) && defined (VMS)
+  /* VMS specific code -- read from the Load Ave driver.  */
+
+  LOAD_AVE_TYPE load_ave[3];
+  static int getloadavg_initialized = 0;
+#  ifdef eunice
+  struct
+  {
+    int dsc$w_length;
+    char *dsc$a_pointer;
+  } descriptor;
+#  endif
+
+  /* Ensure that there is a channel open to the load ave device.  */
+  if (!getloadavg_initialized)
+    {
+      /* Attempt to open the channel.  */
+#  ifdef eunice
+      descriptor.dsc$w_length = 18;
+      descriptor.dsc$a_pointer = "$$VMS_LOAD_AVERAGE";
+#  else
+      $DESCRIPTOR (descriptor, "LAV0:");
+#  endif
+      if (sys$assign (&descriptor, &channel, 0, 0) & 1)
+	getloadavg_initialized = 1;
+    }
+
+  /* Read the load average vector.  */
+  if (getloadavg_initialized
+      && !(sys$qiow (0, channel, IO$_READVBLK, 0, 0, 0,
+		     load_ave, 12, 0, 0, 0, 0) & 1))
+    {
+      sys$dassgn (channel);
+      getloadavg_initialized = 0;
+    }
+
+  if (!getloadavg_initialized)
+    return -1;
+# endif /* VMS */
+
+# if !defined (LDAV_DONE) && defined(LOAD_AVE_TYPE) && !defined(VMS)
+
+  /* UNIX-specific code -- read the average from /dev/kmem.  */
+
+#  define LDAV_PRIVILEGED		/* This code requires special installation.  */
+
+  LOAD_AVE_TYPE load_ave[3];
+
+  /* Get the address of LDAV_SYMBOL.  */
+  if (offset == 0)
+    {
+#  ifndef sgi
+#   ifndef NLIST_STRUCT
+      strcpy (nl[0].n_name, LDAV_SYMBOL);
+      strcpy (nl[1].n_name, "");
+#   else /* NLIST_STRUCT */
+#    ifdef HAVE_STRUCT_NLIST_N_UN_N_NAME
+      nl[0].n_un.n_name = LDAV_SYMBOL;
+      nl[1].n_un.n_name = 0;
+#    else /* not HAVE_STRUCT_NLIST_N_UN_N_NAME */
+      nl[0].n_name = LDAV_SYMBOL;
+      nl[1].n_name = 0;
+#    endif /* not HAVE_STRUCT_NLIST_N_UN_N_NAME */
+#   endif /* NLIST_STRUCT */
+
+#   ifndef SUNOS_5
+      if (
+#    if !(defined (_AIX) && !defined (ps2))
+	  nlist (KERNEL_FILE, nl)
+#    else  /* _AIX */
+	  knlist (nl, 1, sizeof (nl[0]))
+#    endif
+	  >= 0)
+	  /* Omit "&& nl[0].n_type != 0 " -- it breaks on Sun386i.  */
+	  {
+#    ifdef FIXUP_KERNEL_SYMBOL_ADDR
+	    FIXUP_KERNEL_SYMBOL_ADDR (nl);
+#    endif
+	    offset = nl[0].n_value;
+	  }
+#   endif /* !SUNOS_5 */
+#  else  /* sgi */
+      int ldav_off;
+
+      ldav_off = sysmp (MP_KERNADDR, MPKA_AVENRUN);
+      if (ldav_off != -1)
+	offset = (long) ldav_off & 0x7fffffff;
+#  endif /* sgi */
+    }
+
+  /* Make sure we have /dev/kmem open.  */
+  if (!getloadavg_initialized)
+    {
+#  ifndef SUNOS_5
+      channel = open ("/dev/kmem", 0);
+      if (channel >= 0)
+	{
+	  /* Set the channel to close on exec, so it does not
+	     litter any child's descriptor table.  */
+#   ifdef F_SETFD
+#    ifndef FD_CLOEXEC
+#     define FD_CLOEXEC 1
+#    endif
+	  (void) fcntl (channel, F_SETFD, FD_CLOEXEC);
+#   endif
+	  getloadavg_initialized = 1;
+	}
+#  else /* SUNOS_5 */
+      /* We pass 0 for the kernel, corefile, and swapfile names
+	 to use the currently running kernel.  */
+      kd = kvm_open (0, 0, 0, O_RDONLY, 0);
+      if (kd != 0)
+	{
+	  /* nlist the currently running kernel.  */
+	  kvm_nlist (kd, nl);
+	  offset = nl[0].n_value;
+	  getloadavg_initialized = 1;
+	}
+#  endif /* SUNOS_5 */
+    }
+
+  /* If we can, get the load average values.  */
+  if (offset && getloadavg_initialized)
+    {
+      /* Try to read the load.  */
+#  ifndef SUNOS_5
+      if (lseek (channel, offset, 0) == -1L
+	  || read (channel, (char *) load_ave, sizeof (load_ave))
+	  != sizeof (load_ave))
+	{
+	  close (channel);
+	  getloadavg_initialized = 0;
+	}
+#  else  /* SUNOS_5 */
+      if (kvm_read (kd, offset, (char *) load_ave, sizeof (load_ave))
+	  != sizeof (load_ave))
+        {
+          kvm_close (kd);
+          getloadavg_initialized = 0;
+	}
+#  endif /* SUNOS_5 */
+    }
+
+  if (offset == 0 || !getloadavg_initialized)
+    return -1;
+# endif /* LOAD_AVE_TYPE and not VMS */
+
+# if !defined (LDAV_DONE) && defined (LOAD_AVE_TYPE) /* Including VMS.  */
+  if (nelem > 0)
+    loadavg[elem++] = LDAV_CVT (load_ave[0]);
+  if (nelem > 1)
+    loadavg[elem++] = LDAV_CVT (load_ave[1]);
+  if (nelem > 2)
+    loadavg[elem++] = LDAV_CVT (load_ave[2]);
+
+#  define LDAV_DONE
+# endif /* !LDAV_DONE && LOAD_AVE_TYPE */
+
+# ifdef LDAV_DONE
+  return elem;
+# else
+  /* Set errno to zero to indicate that there was no particular error;
+     this function just can't work at all on this system.  */
+  errno = 0;
+  return -1;
+# endif
+}
+
+#endif /* ! HAVE_GETLOADAVG */
+
+#ifdef TEST
+#include "makeint.h"
+
+int
+main (int argc, char **argv)
+{
+  int naptime = 0;
+
+  if (argc > 1)
+    naptime = atoi (argv[1]);
+
+  while (1)
+    {
+      double avg[3];
+      int loads;
+
+      errno = 0;		/* Don't be misled if it doesn't set errno.  */
+      loads = getloadavg (avg, 3);
+      if (loads == -1)
+	{
+	  perror ("Error getting load average");
+	  exit (1);
+	}
+      if (loads > 0)
+	printf ("1-minute: %f  ", avg[0]);
+      if (loads > 1)
+	printf ("5-minute: %f  ", avg[1]);
+      if (loads > 2)
+	printf ("15-minute: %f  ", avg[2]);
+      if (loads > 0)
+	putchar ('\n');
+
+      if (naptime == 0)
+	break;
+      sleep (naptime);
+    }
+
+  exit (0);
+}
+#endif /* TEST */
diff --git a/src/getopt.c b/src/getopt.c
new file mode 100644
index 0000000..5d4b89e
--- /dev/null
+++ b/src/getopt.c
@@ -0,0 +1,1026 @@
+/* Getopt for GNU.
+NOTE: getopt is now part of the C library, so if you don't know what
+"Keep this file name-space clean" means, talk to drepper@gnu.org
+before changing it!
+
+Copyright (C) 1987-2017 Free Software Foundation, Inc.
+
+NOTE: The canonical source of this file is maintained with the GNU C Library.
+Bugs can be reported to bug-glibc@gnu.org.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.
+   Ditto for AIX 3.2 and <stdlib.h>.  */
+#ifndef _NO_PROTO
+# define _NO_PROTO
+#endif
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#if !defined __STDC__ || !__STDC__
+/* This is a separate conditional since some stdc systems
+   reject `defined (const)'.  */
+# ifndef const
+#  define const
+# endif
+#endif
+
+#include <stdio.h>
+
+/* Comment out all this code if we are using the GNU C Library, and are not
+   actually compiling the library itself.  This code is part of the GNU C
+   Library, but also included in many other GNU distributions.  Compiling
+   and linking in this code is a waste when using the GNU C library
+   (especially if it is a shared library).  Rather than having every GNU
+   program understand `configure --with-gnu-libc' and omit the object files,
+   it is simpler to just do this in the source for each such file.  */
+
+#define GETOPT_INTERFACE_VERSION 2
+#if !defined _LIBC && defined __GLIBC__ && __GLIBC__ >= 2
+# include <gnu-versions.h>
+# if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION
+#  define ELIDE_CODE
+# endif
+#endif
+
+#ifndef ELIDE_CODE
+
+
+/* This needs to come after some library #include
+   to get __GNU_LIBRARY__ defined.  */
+#ifdef	__GNU_LIBRARY__
+/* Don't include stdlib.h for non-GNU C libraries because some of them
+   contain conflicting prototypes for getopt.  */
+# include <stdlib.h>
+# include <unistd.h>
+#endif	/* GNU C library.  */
+
+#ifdef VMS
+# include <unixlib.h>
+# if HAVE_STRING_H - 0
+#  include <string.h>
+# endif
+#endif
+
+/* This is for other GNU distributions with internationalized messages.
+   When compiling libc, the _ macro is predefined.  */
+#include "gettext.h"
+#define _(msgid)    gettext (msgid)
+
+
+/* This version of `getopt' appears to the caller like standard Unix 'getopt'
+   but it behaves differently for the user, since it allows the user
+   to intersperse the options with the other arguments.
+
+   As `getopt' works, it permutes the elements of ARGV so that,
+   when it is done, all the options precede everything else.  Thus
+   all application programs are extended to handle flexible argument order.
+
+   Setting the environment variable POSIXLY_CORRECT disables permutation.
+   Then the behavior is completely standard.
+
+   GNU application programs can use a third alternative mode in which
+   they can distinguish the relative order of options and other arguments.  */
+
+#include "getopt.h"
+
+/* For communication from `getopt' to the caller.
+   When `getopt' finds an option that takes an argument,
+   the argument value is returned here.
+   Also, when `ordering' is RETURN_IN_ORDER,
+   each non-option ARGV-element is returned here.  */
+
+char *optarg = NULL;
+
+/* Index in ARGV of the next element to be scanned.
+   This is used for communication to and from the caller
+   and for communication between successive calls to `getopt'.
+
+   On entry to `getopt', zero means this is the first call; initialize.
+
+   When `getopt' returns -1, this is the index of the first of the
+   non-option elements that the caller should itself scan.
+
+   Otherwise, `optind' communicates from one call to the next
+   how much of ARGV has been scanned so far.  */
+
+/* 1003.2 says this must be 1 before any call.  */
+int optind = 1;
+
+/* Formerly, initialization of getopt depended on optind==0, which
+   causes problems with re-calling getopt as programs generally don't
+   know that. */
+
+int __getopt_initialized = 0;
+
+/* The next char to be scanned in the option-element
+   in which the last option character we returned was found.
+   This allows us to pick up the scan where we left off.
+
+   If this is zero, or a null string, it means resume the scan
+   by advancing to the next ARGV-element.  */
+
+static char *nextchar;
+
+/* Callers store zero here to inhibit the error message
+   for unrecognized options.  */
+
+int opterr = 1;
+
+/* Set to an option character which was unrecognized.
+   This must be initialized on some systems to avoid linking in the
+   system's own getopt implementation.  */
+
+int optopt = '?';
+
+/* Describe how to deal with options that follow non-option ARGV-elements.
+
+   If the caller did not specify anything,
+   the default is REQUIRE_ORDER if the environment variable
+   POSIXLY_CORRECT is defined, PERMUTE otherwise.
+
+   REQUIRE_ORDER means don't recognize them as options;
+   stop option processing when the first non-option is seen.
+   This is what Unix does.
+   This mode of operation is selected by either setting the environment
+   variable POSIXLY_CORRECT, or using `+' as the first character
+   of the list of option characters.
+
+   PERMUTE is the default.  We permute the contents of ARGV as we scan,
+   so that eventually all the non-options are at the end.  This allows options
+   to be given in any order, even with programs that were not written to
+   expect this.
+
+   RETURN_IN_ORDER is an option available to programs that were written
+   to expect options and other ARGV-elements in any order and that care about
+   the ordering of the two.  We describe each non-option ARGV-element
+   as if it were the argument of an option with character code 1.
+   Using `-' as the first character of the list of option characters
+   selects this mode of operation.
+
+   The special argument `--' forces an end of option-scanning regardless
+   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
+   `--' can cause `getopt' to return -1 with `optind' != ARGC.  */
+
+static enum
+{
+  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
+} ordering;
+
+/* Value of POSIXLY_CORRECT environment variable.  */
+static char *posixly_correct;
+
+#ifdef	__GNU_LIBRARY__
+/* We want to avoid inclusion of string.h with non-GNU libraries
+   because there are many ways it can cause trouble.
+   On some systems, it contains special magic macros that don't work
+   in GCC.  */
+# include <string.h>
+# define my_index	strchr
+#else
+
+# if HAVE_STRING_H
+#  include <string.h>
+# else
+#  include <strings.h>
+# endif
+
+/* Avoid depending on library functions or files
+   whose names are inconsistent.  */
+
+#ifndef getenv
+extern char *getenv ();
+#endif
+
+static char *
+my_index (const char *str, int chr)
+{
+  while (*str)
+    {
+      if (*str == chr)
+	return (char *) str;
+      str++;
+    }
+  return 0;
+}
+
+/* If using GCC, we can safely declare strlen this way.
+   If not using GCC, it is ok not to declare it.  */
+#ifdef __GNUC__
+/* Note that Motorola Delta 68k R3V7 comes with GCC but not stddef.h.
+   That was relevant to code that was here before.  */
+# if (!defined __STDC__ || !__STDC__) && !defined strlen
+/* gcc with -traditional declares the built-in strlen to return int,
+   and has done so at least since version 2.4.5. -- rms.  */
+extern int strlen (const char *);
+# endif /* not __STDC__ */
+#endif /* __GNUC__ */
+
+#endif /* not __GNU_LIBRARY__ */
+
+/* Handle permutation of arguments.  */
+
+/* Describe the part of ARGV that contains non-options that have
+   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
+   `last_nonopt' is the index after the last of them.  */
+
+static int first_nonopt;
+static int last_nonopt;
+
+#ifdef _LIBC
+/* Bash 2.0 gives us an environment variable containing flags
+   indicating ARGV elements that should not be considered arguments.  */
+
+/* Defined in getopt_init.c  */
+extern char *__getopt_nonoption_flags;
+
+static int nonoption_flags_max_len;
+static int nonoption_flags_len;
+
+static int original_argc;
+static char *const *original_argv;
+
+/* Make sure the environment variable bash 2.0 puts in the environment
+   is valid for the getopt call we must make sure that the ARGV passed
+   to getopt is that one passed to the process.  */
+static void __attribute__ ((unused))
+store_args_and_env (int argc, char *const *argv)
+{
+  /* XXX This is no good solution.  We should rather copy the args so
+     that we can compare them later.  But we must not use malloc(3).  */
+  original_argc = argc;
+  original_argv = argv;
+}
+# ifdef text_set_element
+text_set_element (__libc_subinit, store_args_and_env);
+# endif /* text_set_element */
+
+# define SWAP_FLAGS(ch1, ch2) \
+  if (nonoption_flags_len > 0)						      \
+    {									      \
+      char __tmp = __getopt_nonoption_flags[ch1];			      \
+      __getopt_nonoption_flags[ch1] = __getopt_nonoption_flags[ch2];	      \
+      __getopt_nonoption_flags[ch2] = __tmp;				      \
+    }
+#else	/* !_LIBC */
+# define SWAP_FLAGS(ch1, ch2)
+#endif	/* _LIBC */
+
+/* Exchange two adjacent subsequences of ARGV.
+   One subsequence is elements [first_nonopt,last_nonopt)
+   which contains all the non-options that have been skipped so far.
+   The other is elements [last_nonopt,optind), which contains all
+   the options processed since those non-options were skipped.
+
+   `first_nonopt' and `last_nonopt' are relocated so that they describe
+   the new indices of the non-options in ARGV after they are moved.  */
+
+#if defined __STDC__ && __STDC__
+static void exchange (char **);
+#endif
+
+static void
+exchange (char **argv)
+{
+  int bottom = first_nonopt;
+  int middle = last_nonopt;
+  int top = optind;
+  char *tem;
+
+  /* Exchange the shorter segment with the far end of the longer segment.
+     That puts the shorter segment into the right place.
+     It leaves the longer segment in the right place overall,
+     but it consists of two parts that need to be swapped next.  */
+
+#ifdef _LIBC
+  /* First make sure the handling of the `__getopt_nonoption_flags'
+     string can work normally.  Our top argument must be in the range
+     of the string.  */
+  if (nonoption_flags_len > 0 && top >= nonoption_flags_max_len)
+    {
+      /* We must extend the array.  The user plays games with us and
+	 presents new arguments.  */
+      char *new_str = malloc (top + 1);
+      if (new_str == NULL)
+	nonoption_flags_len = nonoption_flags_max_len = 0;
+      else
+	{
+	  memset (__mempcpy (new_str, __getopt_nonoption_flags,
+			     nonoption_flags_max_len),
+		  '\0', top + 1 - nonoption_flags_max_len);
+	  nonoption_flags_max_len = top + 1;
+	  __getopt_nonoption_flags = new_str;
+	}
+    }
+#endif
+
+  while (top > middle && middle > bottom)
+    {
+      if (top - middle > middle - bottom)
+	{
+	  /* Bottom segment is the short one.  */
+	  int len = middle - bottom;
+	  register int i;
+
+	  /* Swap it with the top part of the top segment.  */
+	  for (i = 0; i < len; i++)
+	    {
+	      tem = argv[bottom + i];
+	      argv[bottom + i] = argv[top - (middle - bottom) + i];
+	      argv[top - (middle - bottom) + i] = tem;
+	      SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);
+	    }
+	  /* Exclude the moved bottom segment from further swapping.  */
+	  top -= len;
+	}
+      else
+	{
+	  /* Top segment is the short one.  */
+	  int len = top - middle;
+	  register int i;
+
+	  /* Swap it with the bottom part of the bottom segment.  */
+	  for (i = 0; i < len; i++)
+	    {
+	      tem = argv[bottom + i];
+	      argv[bottom + i] = argv[middle + i];
+	      argv[middle + i] = tem;
+	      SWAP_FLAGS (bottom + i, middle + i);
+	    }
+	  /* Exclude the moved top segment from further swapping.  */
+	  bottom += len;
+	}
+    }
+
+  /* Update records for the slots the non-options now occupy.  */
+
+  first_nonopt += (optind - last_nonopt);
+  last_nonopt = optind;
+}
+
+/* Initialize the internal data when the first call is made.  */
+
+#if defined __STDC__ && __STDC__
+static const char *_getopt_initialize (int, char *const *, const char *);
+#endif
+static const char *
+_getopt_initialize (int argc, char *const *argv, const char *optstring)
+{
+  /* Start processing options with ARGV-element 1 (since ARGV-element 0
+     is the program name); the sequence of previously skipped
+     non-option ARGV-elements is empty.  */
+
+  first_nonopt = last_nonopt = optind;
+
+  nextchar = NULL;
+
+  posixly_correct = getenv ("POSIXLY_CORRECT");
+
+  /* Determine how to handle the ordering of options and nonoptions.  */
+
+  if (optstring[0] == '-')
+    {
+      ordering = RETURN_IN_ORDER;
+      ++optstring;
+    }
+  else if (optstring[0] == '+')
+    {
+      ordering = REQUIRE_ORDER;
+      ++optstring;
+    }
+  else if (posixly_correct != NULL)
+    ordering = REQUIRE_ORDER;
+  else
+    ordering = PERMUTE;
+
+#ifdef _LIBC
+  if (posixly_correct == NULL
+      && argc == original_argc && argv == original_argv)
+    {
+      if (nonoption_flags_max_len == 0)
+	{
+	  if (__getopt_nonoption_flags == NULL
+	      || __getopt_nonoption_flags[0] == '\0')
+	    nonoption_flags_max_len = -1;
+	  else
+	    {
+	      const char *orig_str = __getopt_nonoption_flags;
+	      int len = nonoption_flags_max_len = strlen (orig_str);
+	      if (nonoption_flags_max_len < argc)
+		nonoption_flags_max_len = argc;
+	      __getopt_nonoption_flags =
+		(char *) malloc (nonoption_flags_max_len);
+	      if (__getopt_nonoption_flags == NULL)
+		nonoption_flags_max_len = -1;
+	      else
+		memset (__mempcpy (__getopt_nonoption_flags, orig_str, len),
+			'\0', nonoption_flags_max_len - len);
+	    }
+	}
+      nonoption_flags_len = nonoption_flags_max_len;
+    }
+  else
+    nonoption_flags_len = 0;
+#endif
+
+  return optstring;
+}
+
+/* Scan elements of ARGV (whose length is ARGC) for option characters
+   given in OPTSTRING.
+
+   If an element of ARGV starts with '-', and is not exactly "-" or "--",
+   then it is an option element.  The characters of this element
+   (aside from the initial '-') are option characters.  If `getopt'
+   is called repeatedly, it returns successively each of the option characters
+   from each of the option elements.
+
+   If `getopt' finds another option character, it returns that character,
+   updating `optind' and `nextchar' so that the next call to `getopt' can
+   resume the scan with the following option character or ARGV-element.
+
+   If there are no more option characters, `getopt' returns -1.
+   Then `optind' is the index in ARGV of the first ARGV-element
+   that is not an option.  (The ARGV-elements have been permuted
+   so that those that are not options now come last.)
+
+   OPTSTRING is a string containing the legitimate option characters.
+   If an option character is seen that is not listed in OPTSTRING,
+   return '?' after printing an error message.  If you set `opterr' to
+   zero, the error message is suppressed but we still return '?'.
+
+   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
+   so the following text in the same ARGV-element, or the text of the following
+   ARGV-element, is returned in `optarg'.  Two colons mean an option that
+   wants an optional arg; if there is text in the current ARGV-element,
+   it is returned in `optarg', otherwise `optarg' is set to zero.
+
+   If OPTSTRING starts with `-' or `+', it requests different methods of
+   handling the non-option ARGV-elements.
+   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
+
+   Long-named options begin with `--' instead of `-'.
+   Their names may be abbreviated as long as the abbreviation is unique
+   or is an exact match for some defined option.  If they have an
+   argument, it follows the option name in the same ARGV-element, separated
+   from the option name by a `=', or else the in next ARGV-element.
+   When `getopt' finds a long-named option, it returns 0 if that option's
+   `flag' field is nonzero, the value of the option's `val' field
+   if the `flag' field is zero.
+
+   The elements of ARGV aren't really const, because we permute them.
+   But we pretend they're const in the prototype to be compatible
+   with other systems.
+
+   LONGOPTS is a vector of `struct option' terminated by an
+   element containing a name which is zero.
+
+   LONGIND returns the index in LONGOPT of the long-named option found.
+   It is only valid when a long-named option has been found by the most
+   recent call.
+
+   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
+   long-named options.  */
+
+int
+_getopt_internal (int argc, char *const *argv, const char *optstring,
+                  const struct option *longopts, int *longind, int long_only)
+{
+  optarg = NULL;
+
+  if (optind == 0 || !__getopt_initialized)
+    {
+      if (optind == 0)
+	optind = 1;	/* Don't scan ARGV[0], the program name.  */
+      optstring = _getopt_initialize (argc, argv, optstring);
+      __getopt_initialized = 1;
+    }
+
+  /* Test whether ARGV[optind] points to a non-option argument.
+     Either it does not have option syntax, or there is an environment flag
+     from the shell indicating it is not an option.  The later information
+     is only used when the used in the GNU libc.  */
+#ifdef _LIBC
+# define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0'	      \
+		      || (optind < nonoption_flags_len			      \
+			  && __getopt_nonoption_flags[optind] == '1'))
+#else
+# define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0')
+#endif
+
+  if (nextchar == NULL || *nextchar == '\0')
+    {
+      /* Advance to the next ARGV-element.  */
+
+      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been
+	 moved back by the user (who may also have changed the arguments).  */
+      if (last_nonopt > optind)
+	last_nonopt = optind;
+      if (first_nonopt > optind)
+	first_nonopt = optind;
+
+      if (ordering == PERMUTE)
+	{
+	  /* If we have just processed some options following some non-options,
+	     exchange them so that the options come first.  */
+
+	  if (first_nonopt != last_nonopt && last_nonopt != optind)
+	    exchange ((char **) argv);
+	  else if (last_nonopt != optind)
+	    first_nonopt = optind;
+
+	  /* Skip any additional non-options
+	     and extend the range of non-options previously skipped.  */
+
+	  while (optind < argc && NONOPTION_P)
+	    optind++;
+	  last_nonopt = optind;
+	}
+
+      /* The special ARGV-element `--' means premature end of options.
+	 Skip it like a null option,
+	 then exchange with previous non-options as if it were an option,
+	 then skip everything else like a non-option.  */
+
+      if (optind != argc && !strcmp (argv[optind], "--"))
+	{
+	  optind++;
+
+	  if (first_nonopt != last_nonopt && last_nonopt != optind)
+	    exchange ((char **) argv);
+	  else if (first_nonopt == last_nonopt)
+	    first_nonopt = optind;
+	  last_nonopt = argc;
+
+	  optind = argc;
+	}
+
+      /* If we have done all the ARGV-elements, stop the scan
+	 and back over any non-options that we skipped and permuted.  */
+
+      if (optind == argc)
+	{
+	  /* Set the next-arg-index to point at the non-options
+	     that we previously skipped, so the caller will digest them.  */
+	  if (first_nonopt != last_nonopt)
+	    optind = first_nonopt;
+	  return -1;
+	}
+
+      /* If we have come to a non-option and did not permute it,
+	 either stop the scan or describe it to the caller and pass it by.  */
+
+      if (NONOPTION_P)
+	{
+	  if (ordering == REQUIRE_ORDER)
+	    return -1;
+	  optarg = argv[optind++];
+	  return 1;
+	}
+
+      /* We have found another option-ARGV-element.
+	 Skip the initial punctuation.  */
+
+      nextchar = (argv[optind] + 1
+		  + (longopts != NULL && argv[optind][1] == '-'));
+    }
+
+  /* Decode the current option-ARGV-element.  */
+
+  /* Check whether the ARGV-element is a long option.
+
+     If long_only and the ARGV-element has the form "-f", where f is
+     a valid short option, don't consider it an abbreviated form of
+     a long option that starts with f.  Otherwise there would be no
+     way to give the -f short option.
+
+     On the other hand, if there's a long option "fubar" and
+     the ARGV-element is "-fu", do consider that an abbreviation of
+     the long option, just like "--fu", and not "-f" with arg "u".
+
+     This distinction seems to be the most useful approach.  */
+
+  if (longopts != NULL
+      && (argv[optind][1] == '-'
+	  || (long_only && (argv[optind][2] || !my_index (optstring, argv[optind][1])))))
+    {
+      char *nameend;
+      const struct option *p;
+      const struct option *pfound = NULL;
+      int exact = 0;
+      int ambig = 0;
+      int indfound = -1;
+      int option_index;
+
+      for (nameend = nextchar; *nameend && *nameend != '='; nameend++)
+	/* Do nothing.  */ ;
+
+      /* Test all long options for either exact match
+	 or abbreviated matches.  */
+      for (p = longopts, option_index = 0; p->name; p++, option_index++)
+	if (!strncmp (p->name, nextchar, nameend - nextchar))
+	  {
+	    if ((unsigned int) (nameend - nextchar)
+		== (unsigned int) strlen (p->name))
+	      {
+		/* Exact match found.  */
+		pfound = p;
+		indfound = option_index;
+		exact = 1;
+		break;
+	      }
+	    else if (pfound == NULL)
+	      {
+		/* First nonexact match found.  */
+		pfound = p;
+		indfound = option_index;
+	      }
+	    else
+	      /* Second or later nonexact match found.  */
+	      ambig = 1;
+	  }
+
+      if (ambig && !exact)
+	{
+	  if (opterr)
+	    fprintf (stderr, _("%s: option '%s' is ambiguous\n"),
+		     argv[0], argv[optind]);
+	  nextchar += strlen (nextchar);
+	  optind++;
+	  optopt = 0;
+	  return '?';
+	}
+
+      if (pfound != NULL)
+	{
+	  option_index = indfound;
+	  optind++;
+	  if (*nameend)
+	    {
+	      /* Don't test has_arg with >, because some C compilers don't
+		 allow it to be used on enums.  */
+	      if (pfound->has_arg)
+		optarg = nameend + 1;
+	      else
+		{
+		  if (opterr)
+		   if (argv[optind - 1][1] == '-')
+		    /* --option */
+		    fprintf (stderr,
+		     _("%s: option '--%s' doesn't allow an argument\n"),
+		     argv[0], pfound->name);
+		   else
+		    /* +option or -option */
+		    fprintf (stderr,
+		     _("%s: option '%c%s' doesn't allow an argument\n"),
+		     argv[0], argv[optind - 1][0], pfound->name);
+
+		  nextchar += strlen (nextchar);
+
+		  optopt = pfound->val;
+		  return '?';
+		}
+	    }
+	  else if (pfound->has_arg == 1)
+	    {
+	      if (optind < argc)
+		optarg = argv[optind++];
+	      else
+		{
+		  if (opterr)
+		    fprintf (stderr,
+			   _("%s: option '%s' requires an argument\n"),
+			   argv[0], argv[optind - 1]);
+		  nextchar += strlen (nextchar);
+		  optopt = pfound->val;
+		  return optstring[0] == ':' ? ':' : '?';
+		}
+	    }
+	  nextchar += strlen (nextchar);
+	  if (longind != NULL)
+	    *longind = option_index;
+	  if (pfound->flag)
+	    {
+	      *(pfound->flag) = pfound->val;
+	      return 0;
+	    }
+	  return pfound->val;
+	}
+
+      /* Can't find it as a long option.  If this is not getopt_long_only,
+	 or the option starts with '--' or is not a valid short
+	 option, then it's an error.
+	 Otherwise interpret it as a short option.  */
+      if (!long_only || argv[optind][1] == '-'
+	  || my_index (optstring, *nextchar) == NULL)
+	{
+	  if (opterr)
+	    {
+	      if (argv[optind][1] == '-')
+		/* --option */
+		fprintf (stderr, _("%s: unrecognized option '--%s'\n"),
+			 argv[0], nextchar);
+	      else
+		/* +option or -option */
+		fprintf (stderr, _("%s: unrecognized option '%c%s'\n"),
+			 argv[0], argv[optind][0], nextchar);
+	    }
+	  nextchar = (char *) "";
+	  optind++;
+	  optopt = 0;
+	  return '?';
+	}
+    }
+
+  /* Look at and handle the next short option-character.  */
+
+  {
+    char c = *nextchar++;
+    char *temp = my_index (optstring, c);
+
+    /* Increment `optind' when we start to process its last character.  */
+    if (*nextchar == '\0')
+      ++optind;
+
+    if (temp == NULL || c == ':')
+      {
+	if (opterr)
+	  {
+	    if (posixly_correct)
+	      /* 1003.2 specifies the format of this message.  */
+	      fprintf (stderr, _("%s: illegal option -- %c\n"),
+		       argv[0], c);
+	    else
+	      fprintf (stderr, _("%s: invalid option -- %c\n"),
+		       argv[0], c);
+	  }
+	optopt = c;
+	return '?';
+      }
+    /* Convenience. Treat POSIX -W foo same as long option --foo */
+    if (temp[0] == 'W' && temp[1] == ';')
+      {
+	char *nameend;
+	const struct option *p;
+	const struct option *pfound = NULL;
+	int exact = 0;
+	int ambig = 0;
+	int indfound = 0;
+	int option_index;
+
+	/* This is an option that requires an argument.  */
+	if (*nextchar != '\0')
+	  {
+	    optarg = nextchar;
+	    /* If we end this ARGV-element by taking the rest as an arg,
+	       we must advance to the next element now.  */
+	    optind++;
+	  }
+	else if (optind == argc)
+	  {
+	    if (opterr)
+	      {
+		/* 1003.2 specifies the format of this message.  */
+		fprintf (stderr, _("%s: option requires an argument -- %c\n"),
+			 argv[0], c);
+	      }
+	    optopt = c;
+	    if (optstring[0] == ':')
+	      c = ':';
+	    else
+	      c = '?';
+	    return c;
+	  }
+	else
+	  /* We already incremented `optind' once;
+	     increment it again when taking next ARGV-elt as argument.  */
+	  optarg = argv[optind++];
+
+	/* optarg is now the argument, see if it's in the
+	   table of longopts.  */
+
+	for (nextchar = nameend = optarg; *nameend && *nameend != '='; nameend++)
+	  /* Do nothing.  */ ;
+
+	/* Test all long options for either exact match
+	   or abbreviated matches.  */
+	for (p = longopts, option_index = 0; p->name; p++, option_index++)
+	  if (!strncmp (p->name, nextchar, nameend - nextchar))
+	    {
+	      if ((unsigned int) (nameend - nextchar) == strlen (p->name))
+		{
+		  /* Exact match found.  */
+		  pfound = p;
+		  indfound = option_index;
+		  exact = 1;
+		  break;
+		}
+	      else if (pfound == NULL)
+		{
+		  /* First nonexact match found.  */
+		  pfound = p;
+		  indfound = option_index;
+		}
+	      else
+		/* Second or later nonexact match found.  */
+		ambig = 1;
+	    }
+	if (ambig && !exact)
+	  {
+	    if (opterr)
+	      fprintf (stderr, _("%s: option '-W %s' is ambiguous\n"),
+		       argv[0], argv[optind]);
+	    nextchar += strlen (nextchar);
+	    optind++;
+	    return '?';
+	  }
+	if (pfound != NULL)
+	  {
+	    option_index = indfound;
+	    if (*nameend)
+	      {
+		/* Don't test has_arg with >, because some C compilers don't
+		   allow it to be used on enums.  */
+		if (pfound->has_arg)
+		  optarg = nameend + 1;
+		else
+		  {
+		    if (opterr)
+		      fprintf (stderr, _("\
+%s: option '-W %s' doesn't allow an argument\n"),
+			       argv[0], pfound->name);
+
+		    nextchar += strlen (nextchar);
+		    return '?';
+		  }
+	      }
+	    else if (pfound->has_arg == 1)
+	      {
+		if (optind < argc)
+		  optarg = argv[optind++];
+		else
+		  {
+		    if (opterr)
+		      fprintf (stderr,
+			       _("%s: option '%s' requires an argument\n"),
+			       argv[0], argv[optind - 1]);
+		    nextchar += strlen (nextchar);
+		    return optstring[0] == ':' ? ':' : '?';
+		  }
+	      }
+	    nextchar += strlen (nextchar);
+	    if (longind != NULL)
+	      *longind = option_index;
+	    if (pfound->flag)
+	      {
+		*(pfound->flag) = pfound->val;
+		return 0;
+	      }
+	    return pfound->val;
+	  }
+	  nextchar = NULL;
+	  return 'W';	/* Let the application handle it.   */
+      }
+    if (temp[1] == ':')
+      {
+	if (temp[2] == ':')
+	  {
+	    /* This is an option that accepts an argument optionally.  */
+	    if (*nextchar != '\0')
+	      {
+		optarg = nextchar;
+		optind++;
+	      }
+	    else
+	      optarg = NULL;
+	    nextchar = NULL;
+	  }
+	else
+	  {
+	    /* This is an option that requires an argument.  */
+	    if (*nextchar != '\0')
+	      {
+		optarg = nextchar;
+		/* If we end this ARGV-element by taking the rest as an arg,
+		   we must advance to the next element now.  */
+		optind++;
+	      }
+	    else if (optind == argc)
+	      {
+		if (opterr)
+		  {
+		    /* 1003.2 specifies the format of this message.  */
+		    fprintf (stderr,
+			   _("%s: option requires an argument -- %c\n"),
+			   argv[0], c);
+		  }
+		optopt = c;
+		if (optstring[0] == ':')
+		  c = ':';
+		else
+		  c = '?';
+	      }
+	    else
+	      /* We already incremented `optind' once;
+		 increment it again when taking next ARGV-elt as argument.  */
+	      optarg = argv[optind++];
+	    nextchar = NULL;
+	  }
+      }
+    return c;
+  }
+}
+
+int
+getopt (int argc, char *const *argv, const char *optstring)
+{
+  return _getopt_internal (argc, argv, optstring,
+			   (const struct option *) 0,
+			   (int *) 0,
+			   0);
+}
+
+#endif	/* Not ELIDE_CODE.  */
+
+#ifdef TEST
+
+/* Compile with -DTEST to make an executable for use in testing
+   the above definition of `getopt'.  */
+
+int
+main (int argc, char **argv)
+{
+  int c;
+  int digit_optind = 0;
+
+  while (1)
+    {
+      int this_option_optind = optind ? optind : 1;
+
+      c = getopt (argc, argv, "abc:d:0123456789");
+      if (c == -1)
+	break;
+
+      switch (c)
+	{
+	case '0':
+	case '1':
+	case '2':
+	case '3':
+	case '4':
+	case '5':
+	case '6':
+	case '7':
+	case '8':
+	case '9':
+	  if (digit_optind != 0 && digit_optind != this_option_optind)
+	    printf ("digits occur in two different argv-elements.\n");
+	  digit_optind = this_option_optind;
+	  printf ("option %c\n", c);
+	  break;
+
+	case 'a':
+	  printf ("option a\n");
+	  break;
+
+	case 'b':
+	  printf ("option b\n");
+	  break;
+
+	case 'c':
+	  printf ("option c with value '%s'\n", optarg);
+	  break;
+
+	case '?':
+	  break;
+
+	default:
+	  printf ("?? getopt returned character code 0%o ??\n", c);
+	}
+    }
+
+  if (optind < argc)
+    {
+      printf ("non-option ARGV-elements: ");
+      while (optind < argc)
+	printf ("%s ", argv[optind++]);
+      printf ("\n");
+    }
+
+  exit (0);
+}
+
+#endif /* TEST */
diff --git a/src/getopt.h b/src/getopt.h
new file mode 100644
index 0000000..bb756fa
--- /dev/null
+++ b/src/getopt.h
@@ -0,0 +1,130 @@
+/* Declarations for getopt.
+Copyright (C) 1989-2017 Free Software Foundation, Inc.
+
+NOTE: The canonical source of this file is maintained with the GNU C Library.
+Bugs can be reported to bug-glibc@gnu.org.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef _GETOPT_H
+#define _GETOPT_H 1
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+/* For communication from `getopt' to the caller.
+   When `getopt' finds an option that takes an argument,
+   the argument value is returned here.
+   Also, when `ordering' is RETURN_IN_ORDER,
+   each non-option ARGV-element is returned here.  */
+
+extern char *optarg;
+
+/* Index in ARGV of the next element to be scanned.
+   This is used for communication to and from the caller
+   and for communication between successive calls to `getopt'.
+
+   On entry to `getopt', zero means this is the first call; initialize.
+
+   When `getopt' returns -1, this is the index of the first of the
+   non-option elements that the caller should itself scan.
+
+   Otherwise, `optind' communicates from one call to the next
+   how much of ARGV has been scanned so far.  */
+
+extern int optind;
+
+/* Callers store zero here to inhibit the error message `getopt' prints
+   for unrecognized options.  */
+
+extern int opterr;
+
+/* Set to an option character which was unrecognized.  */
+
+extern int optopt;
+
+/* Describe the long-named options requested by the application.
+   The LONG_OPTIONS argument to getopt_long or getopt_long_only is a vector
+   of `struct option' terminated by an element containing a name which is
+   zero.
+
+   The field `has_arg' is:
+   no_argument		(or 0) if the option does not take an argument,
+   required_argument	(or 1) if the option requires an argument,
+   optional_argument 	(or 2) if the option takes an optional argument.
+
+   If the field `flag' is not NULL, it points to a variable that is set
+   to the value given in the field `val' when the option is found, but
+   left unchanged if the option is not found.
+
+   To have a long-named option do something other than set an `int' to
+   a compiled-in constant, such as set a value from `optarg', set the
+   option's `flag' field to zero and its `val' field to a nonzero
+   value (the equivalent single-letter option character, if there is
+   one).  For long options that have a zero `flag' field, `getopt'
+   returns the contents of the `val' field.  */
+
+struct option
+{
+#if defined (__STDC__) && __STDC__
+  const char *name;
+#else
+  char *name;
+#endif
+  /* has_arg can't be an enum because some compilers complain about
+     type mismatches in all the code that assumes it is an int.  */
+  int has_arg;
+  int *flag;
+  int val;
+};
+
+/* Names for the values of the `has_arg' field of `struct option'.  */
+
+#define	no_argument		0
+#define required_argument	1
+#define optional_argument	2
+
+#if defined (__STDC__) && __STDC__
+#ifdef __GNU_LIBRARY__
+/* Many other libraries have conflicting prototypes for getopt, with
+   differences in the consts, in stdlib.h.  To avoid compilation
+   errors, only prototype getopt for the GNU C library.  */
+extern int getopt (int argc, char *const *argv, const char *shortopts);
+#else /* not __GNU_LIBRARY__ */
+extern int getopt ();
+#endif /* __GNU_LIBRARY__ */
+extern int getopt_long (int argc, char *const *argv, const char *shortopts,
+		        const struct option *longopts, int *longind);
+extern int getopt_long_only (int argc, char *const *argv,
+			     const char *shortopts,
+		             const struct option *longopts, int *longind);
+
+/* Internal only.  Users should not call this directly.  */
+extern int _getopt_internal (int argc, char *const *argv,
+			     const char *shortopts,
+		             const struct option *longopts, int *longind,
+			     int long_only);
+#else /* not __STDC__ */
+extern int getopt ();
+extern int getopt_long ();
+extern int getopt_long_only ();
+
+extern int _getopt_internal ();
+#endif /* __STDC__ */
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif /* getopt.h */
diff --git a/src/getopt1.c b/src/getopt1.c
new file mode 100644
index 0000000..5d0240a
--- /dev/null
+++ b/src/getopt1.c
@@ -0,0 +1,176 @@
+/* getopt_long and getopt_long_only entry points for GNU getopt.
+Copyright (C) 1987-1994, 1996-2017 Free Software Foundation, Inc.
+
+NOTE: The canonical source of this file is maintained with the GNU C Library.
+Bugs can be reported to bug-glibc@gnu.org.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "getopt.h"
+
+#if !defined __STDC__ || !__STDC__
+/* This is a separate conditional since some stdc systems
+   reject `defined (const)'.  */
+#ifndef const
+#define const
+#endif
+#endif
+
+#include <stdio.h>
+
+/* Comment out all this code if we are using the GNU C Library, and are not
+   actually compiling the library itself.  This code is part of the GNU C
+   Library, but also included in many other GNU distributions.  Compiling
+   and linking in this code is a waste when using the GNU C library
+   (especially if it is a shared library).  Rather than having every GNU
+   program understand `configure --with-gnu-libc' and omit the object files,
+   it is simpler to just do this in the source for each such file.  */
+
+#define GETOPT_INTERFACE_VERSION 2
+#if !defined _LIBC && defined __GLIBC__ && __GLIBC__ >= 2
+#include <gnu-versions.h>
+#if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION
+#define ELIDE_CODE
+#endif
+#endif
+
+#ifndef ELIDE_CODE
+
+
+/* This needs to come after some library #include
+   to get __GNU_LIBRARY__ defined.  */
+#ifdef __GNU_LIBRARY__
+#include <stdlib.h>
+#endif
+
+#ifndef	NULL
+#define NULL 0
+#endif
+
+int
+getopt_long (int argc, char *const *argv, const char *options,
+             const struct option *long_options, int *opt_index)
+{
+  return _getopt_internal (argc, argv, options, long_options, opt_index, 0);
+}
+
+/* Like getopt_long, but '-' as well as '--' can indicate a long option.
+   If an option that starts with '-' (not '--') doesn't match a long option,
+   but does match a short option, it is parsed as a short option
+   instead.  */
+
+int
+getopt_long_only (int argc, char *const *argv, const char *options,
+                  const struct option *long_options, int *opt_index)
+{
+  return _getopt_internal (argc, argv, options, long_options, opt_index, 1);
+}
+
+
+#endif	/* Not ELIDE_CODE.  */
+
+#ifdef TEST
+
+#include <stdio.h>
+
+int
+main (int argc, char **argv)
+{
+  int c;
+  int digit_optind = 0;
+
+  while (1)
+    {
+      int this_option_optind = optind ? optind : 1;
+      int option_index = 0;
+      static struct option long_options[] =
+      {
+	{"add", 1, 0, 0},
+	{"append", 0, 0, 0},
+	{"delete", 1, 0, 0},
+	{"verbose", 0, 0, 0},
+	{"create", 0, 0, 0},
+	{"file", 1, 0, 0},
+	{0, 0, 0, 0}
+      };
+
+      c = getopt_long (argc, argv, "abc:d:0123456789",
+		       long_options, &option_index);
+      if (c == -1)
+	break;
+
+      switch (c)
+	{
+	case 0:
+	  printf ("option %s", long_options[option_index].name);
+	  if (optarg)
+	    printf (" with arg %s", optarg);
+	  printf ("\n");
+	  break;
+
+	case '0':
+	case '1':
+	case '2':
+	case '3':
+	case '4':
+	case '5':
+	case '6':
+	case '7':
+	case '8':
+	case '9':
+	  if (digit_optind != 0 && digit_optind != this_option_optind)
+	    printf ("digits occur in two different argv-elements.\n");
+	  digit_optind = this_option_optind;
+	  printf ("option %c\n", c);
+	  break;
+
+	case 'a':
+	  printf ("option a\n");
+	  break;
+
+	case 'b':
+	  printf ("option b\n");
+	  break;
+
+	case 'c':
+	  printf ("option c with value '%s'\n", optarg);
+	  break;
+
+	case 'd':
+	  printf ("option d with value '%s'\n", optarg);
+	  break;
+
+	case '?':
+	  break;
+
+	default:
+	  printf ("?? getopt returned character code 0%o ??\n", c);
+	}
+    }
+
+  if (optind < argc)
+    {
+      printf ("non-option ARGV-elements: ");
+      while (optind < argc)
+	printf ("%s ", argv[optind++]);
+      printf ("\n");
+    }
+
+  exit (0);
+}
+
+#endif /* TEST */
diff --git a/src/gettext.h b/src/gettext.h
new file mode 100644
index 0000000..10992fb
--- /dev/null
+++ b/src/gettext.h
@@ -0,0 +1,57 @@
+/* Convenience header for conditional use of GNU <libintl.h>.
+Copyright (C) 1995-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef _LIBGETTEXT_H
+#define _LIBGETTEXT_H 1
+
+/* NLS can be disabled through the configure --disable-nls option.  */
+#if ENABLE_NLS
+
+/* Get declarations of GNU message catalog functions.  */
+# include <libintl.h>
+
+#else
+
+/* Disabled NLS.
+   The casts to 'const char *' serve the purpose of producing warnings
+   for invalid uses of the value returned from these functions.
+   On pre-ANSI systems without 'const', the config.h file is supposed to
+   contain "#define const".  */
+# define gettext(Msgid) ((const char *) (Msgid))
+# define dgettext(Domainname, Msgid) ((const char *) (Msgid))
+# define dcgettext(Domainname, Msgid, Category) ((const char *) (Msgid))
+# define ngettext(Msgid1, Msgid2, N) \
+    ((N) == 1 ? (const char *) (Msgid1) : (const char *) (Msgid2))
+# define dngettext(Domainname, Msgid1, Msgid2, N) \
+    ((N) == 1 ? (const char *) (Msgid1) : (const char *) (Msgid2))
+# define dcngettext(Domainname, Msgid1, Msgid2, N, Category) \
+    ((N) == 1 ? (const char *) (Msgid1) : (const char *) (Msgid2))
+# define textdomain(Domainname) ((const char *) (Domainname))
+# define bindtextdomain(Domainname, Dirname) ((const char *) (Dirname))
+# define bind_textdomain_codeset(Domainname, Codeset) ((const char *) (Codeset))
+
+#endif
+
+/* A pseudo function call that serves as a marker for the automated
+   extraction of messages, but does not call gettext().  The run-time
+   translation is done at a different place in the code.
+   The argument, String, should be a literal string.  Concatenated strings
+   and other string expressions won't work.
+   The macro's expansion is not parenthesized, so that it is suitable as
+   initializer for static 'char[]' or 'const char[]' variables.  */
+#define gettext_noop(String) String
+
+#endif /* _LIBGETTEXT_H */
diff --git a/src/gmk-default.scm b/src/gmk-default.scm
new file mode 100644
index 0000000..a827cae
--- /dev/null
+++ b/src/gmk-default.scm
@@ -0,0 +1,53 @@
+;; Contents of the (gnu make) Guile module
+;; Copyright (C) 2011-2017 Free Software Foundation, Inc.
+;; This file is part of GNU Make.
+;;
+;; GNU Make is free software; you can redistribute it and/or modify it under
+;; the terms of the GNU General Public License as published by the Free
+;; Software Foundation; either version 3 of the License, or (at your option)
+;; any later version.
+;;
+;; GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+;; WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+;; FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+;; details.
+;;
+;; You should have received a copy of the GNU General Public License along
+;; with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+(define (to-string-maybe x)
+  (cond
+   ;; In GNU make, "false" is the empty string
+   ((or (not x)
+        (unspecified? x)
+        (variable? x)
+        (null? x)
+        (and (string? x) (string-null? x)))
+    #f)
+   ;; We want something not false... not sure about this
+   ((eq? x #t) "#t")
+   ;; Basics
+   ((or (symbol? x) (number? x))
+    (object->string x))
+   ((char? x)
+    (string x))
+   ;; Printable string (no special characters)
+   ((and (string? x) (string-every char-set:printing x))
+    x)
+   ;; No idea: fail
+   (else (error "Unknown object:" x))))
+
+(define (obj-to-str x)
+  (let ((acc '()))
+    (define (walk x)
+      (cond ((pair? x) (walk (car x)) (walk (cdr x)))
+            ((to-string-maybe x) => (lambda (s) (set! acc (cons s acc))))))
+    (walk x)
+    (string-join (reverse! acc))))
+
+;; Return the value of the GNU make variable V
+(define (gmk-var v)
+  (gmk-expand (format #f "$(~a)" (obj-to-str v))))
+
+;; Export the public interfaces
+(export gmk-expand gmk-eval gmk-var)
diff --git a/src/gnumake.h b/src/gnumake.h
new file mode 100644
index 0000000..c1a44ec
--- /dev/null
+++ b/src/gnumake.h
@@ -0,0 +1,79 @@
+/* External interfaces usable by dynamic objects loaded into GNU Make.
+   --THIS API IS A "TECHNOLOGY PREVIEW" ONLY.  IT IS NOT A STABLE INTERFACE--
+
+Copyright (C) 2013-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef _GNUMAKE_H_
+#define _GNUMAKE_H_
+
+/* Specify the location of elements read from makefiles.  */
+typedef struct
+  {
+    const char *filenm;
+    unsigned long lineno;
+  } gmk_floc;
+
+typedef char *(*gmk_func_ptr)(const char *nm, unsigned int argc, char **argv);
+
+#ifdef _WIN32
+# ifdef GMK_BUILDING_MAKE
+#  define GMK_EXPORT  __declspec(dllexport)
+# else
+#  define GMK_EXPORT  __declspec(dllimport)
+# endif
+#else
+# define GMK_EXPORT
+#endif
+
+/* Free memory returned by the gmk_expand() function.  */
+GMK_EXPORT void gmk_free (char *str);
+
+/* Allocate memory in GNU make's context.  */
+GMK_EXPORT char *gmk_alloc (unsigned int len);
+
+/* Run $(eval ...) on the provided string BUFFER.  */
+GMK_EXPORT void gmk_eval (const char *buffer, const gmk_floc *floc);
+
+/* Run GNU make expansion on the provided string STR.
+   Returns an allocated buffer that the caller must free with gmk_free().  */
+GMK_EXPORT char *gmk_expand (const char *str);
+
+/* Register a new GNU make function NAME (maximum of 255 chars long).
+   When the function is expanded in the makefile, FUNC will be invoked with
+   the appropriate arguments.
+
+   The return value of FUNC must be either NULL, in which case it expands to
+   the empty string, or a pointer to the result of the expansion in a string
+   created by gmk_alloc().  GNU make will free the memory when it's done.
+
+   MIN_ARGS is the minimum number of arguments the function requires.
+   MAX_ARGS is the maximum number of arguments (or 0 if there's no maximum).
+   MIN_ARGS and MAX_ARGS may not exceed 255.
+
+   The FLAGS value may be GMK_FUNC_DEFAULT, or one or more of the following
+   flags OR'd together:
+
+     GMK_FUNC_NOEXPAND: the arguments to the function will be not be expanded
+                        before FUNC is called.
+*/
+GMK_EXPORT void gmk_add_function (const char *name, gmk_func_ptr func,
+                                  unsigned int min_args, unsigned int max_args,
+                                  unsigned int flags);
+
+#define GMK_FUNC_DEFAULT    0x00
+#define GMK_FUNC_NOEXPAND   0x01
+
+#endif  /* _GNUMAKE_H_ */
diff --git a/src/guile.c b/src/guile.c
new file mode 100644
index 0000000..a593666
--- /dev/null
+++ b/src/guile.c
@@ -0,0 +1,159 @@
+/* GNU Guile interface for GNU Make.
+Copyright (C) 2011-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+
+#ifdef HAVE_GUILE
+
+#include "gnumake.h"
+
+#include "debug.h"
+#include "filedef.h"
+#include "dep.h"
+#include "variable.h"
+
+#include <libguile.h>
+
+/* Pre-2.0 versions of Guile don't have a typedef for gsubr function types.  */
+#if SCM_MAJOR_VERSION < 2
+# define GSUBR_TYPE         SCM (*) ()
+/* Guile 1.x doesn't really support i18n.  */
+# define EVAL_STRING(_s)    scm_c_eval_string (_s)
+#else
+# define GSUBR_TYPE         scm_t_subr
+# define EVAL_STRING(_s)    scm_eval_string (scm_from_utf8_string (_s))
+#endif
+
+static SCM make_mod = SCM_EOL;
+static SCM obj_to_str = SCM_EOL;
+
+/* Convert an SCM object into a string.  */
+static char *
+cvt_scm_to_str (SCM obj)
+{
+  return scm_to_locale_string (scm_call_1 (obj_to_str, obj));
+}
+
+/* Perform the GNU make expansion function.  */
+static SCM
+guile_expand_wrapper (SCM obj)
+{
+  char *str = cvt_scm_to_str (obj);
+  SCM ret;
+  char *res;
+
+  DB (DB_BASIC, (_("guile: Expanding '%s'\n"), str));
+  res = gmk_expand (str);
+  ret = scm_from_locale_string (res);
+
+  free (str);
+  free (res);
+
+  return ret;
+}
+
+/* Perform the GNU make eval function.  */
+static SCM
+guile_eval_wrapper (SCM obj)
+{
+  char *str = cvt_scm_to_str (obj);
+
+  DB (DB_BASIC, (_("guile: Evaluating '%s'\n"), str));
+  gmk_eval (str, 0);
+
+  return SCM_BOOL_F;
+}
+
+/* Invoked by scm_c_define_module(), in the context of the GNU make module.  */
+static void
+guile_define_module (void *data UNUSED)
+{
+/* Ingest the predefined Guile module for GNU make.  */
+#include "gmk-default.h"
+
+  /* Register a subr for GNU make's eval capability.  */
+  scm_c_define_gsubr ("gmk-expand", 1, 0, 0, (GSUBR_TYPE) guile_expand_wrapper);
+
+  /* Register a subr for GNU make's eval capability.  */
+  scm_c_define_gsubr ("gmk-eval", 1, 0, 0, (GSUBR_TYPE) guile_eval_wrapper);
+
+  /* Define the rest of the module.  */
+  scm_c_eval_string (GUILE_module_defn);
+}
+
+/* Initialize the GNU make Guile module.  */
+static void *
+guile_init (void *arg UNUSED)
+{
+  /* Define the module.  */
+  make_mod = scm_c_define_module ("gnu make", guile_define_module, NULL);
+
+  /* Get a reference to the object-to-string translator, for later.  */
+  obj_to_str = scm_variable_ref (scm_c_module_lookup (make_mod, "obj-to-str"));
+
+  /* Import the GNU make module exports into the generic space.  */
+  scm_c_eval_string ("(use-modules (gnu make))");
+
+  return NULL;
+}
+
+static void *
+internal_guile_eval (void *arg)
+{
+  return cvt_scm_to_str (EVAL_STRING (arg));
+}
+
+/* This is the function registered with make  */
+static char *
+func_guile (const char *funcname UNUSED, unsigned int argc UNUSED, char **argv)
+{
+  static int init = 0;
+
+  if (! init)
+    {
+      /* Initialize the Guile interpreter.  */
+      scm_with_guile (guile_init, NULL);
+      init = 1;
+    }
+
+  if (argv[0] && argv[0][0] != '\0')
+    return scm_with_guile (internal_guile_eval, argv[0]);
+
+  return NULL;
+}
+
+/* ----- Public interface ----- */
+
+/* We could send the flocp to define_new_function(), but since guile is
+   "kind of" built-in, that didn't seem so useful.  */
+int
+guile_gmake_setup (const floc *flocp UNUSED)
+{
+  /* Create a make function "guile".  */
+  gmk_add_function ("guile", func_guile, 0, 1, GMK_FUNC_DEFAULT);
+
+  return 1;
+}
+
+#else
+
+int
+guile_gmake_setup (const floc *flocp UNUSED)
+{
+  return 1;
+}
+
+#endif
diff --git a/src/hash.c b/src/hash.c
new file mode 100644
index 0000000..c138aaf
--- /dev/null
+++ b/src/hash.c
@@ -0,0 +1,477 @@
+/* hash.c -- hash table maintenance
+Copyright (C) 1995, 1999, 2002, 2010 Free Software Foundation, Inc.
+Written by Greg McGary <gkm@gnu.org> <greg@mcgary.org>
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+#include "hash.h"
+
+#define	CALLOC(t, n) ((t *) xcalloc (sizeof (t) * (n)))
+#define MALLOC(t, n) ((t *) xmalloc (sizeof (t) * (n)))
+#define REALLOC(o, t, n) ((t *) xrealloc ((o), sizeof (t) * (n)))
+#define CLONE(o, t, n) ((t *) memcpy (MALLOC (t, (n)), (o), sizeof (t) * (n)))
+
+static void hash_rehash __P((struct hash_table* ht));
+static unsigned long round_up_2 __P((unsigned long rough));
+
+/* Implement double hashing with open addressing.  The table size is
+   always a power of two.  The secondary ('increment') hash function
+   is forced to return an odd-value, in order to be relatively prime
+   to the table size.  This guarantees that the increment can
+   potentially hit every slot in the table during collision
+   resolution.  */
+
+void *hash_deleted_item = &hash_deleted_item;
+
+/* Force the table size to be a power of two, possibly rounding up the
+   given size.  */
+
+void
+hash_init (struct hash_table *ht, unsigned long size,
+           hash_func_t hash_1, hash_func_t hash_2, hash_cmp_func_t hash_cmp)
+{
+  ht->ht_size = round_up_2 (size);
+  ht->ht_empty_slots = ht->ht_size;
+  ht->ht_vec = (void**) CALLOC (struct token *, ht->ht_size);
+  if (ht->ht_vec == 0)
+    {
+      fprintf (stderr, _("can't allocate %lu bytes for hash table: memory exhausted"),
+	       ht->ht_size * (unsigned long) sizeof (struct token *));
+      exit (MAKE_TROUBLE);
+    }
+
+  ht->ht_capacity = ht->ht_size - (ht->ht_size / 16); /* 93.75% loading factor */
+  ht->ht_fill = 0;
+  ht->ht_collisions = 0;
+  ht->ht_lookups = 0;
+  ht->ht_rehashes = 0;
+  ht->ht_hash_1 = hash_1;
+  ht->ht_hash_2 = hash_2;
+  ht->ht_compare = hash_cmp;
+}
+
+/* Load an array of items into 'ht'.  */
+
+void
+hash_load (struct hash_table *ht, void *item_table,
+           unsigned long cardinality, unsigned long size)
+{
+  char *items = (char *) item_table;
+  while (cardinality--)
+    {
+      hash_insert (ht, items);
+      items += size;
+    }
+}
+
+/* Returns the address of the table slot matching 'key'.  If 'key' is
+   not found, return the address of an empty slot suitable for
+   inserting 'key'.  The caller is responsible for incrementing
+   ht_fill on insertion.  */
+
+void **
+hash_find_slot (struct hash_table *ht, const void *key)
+{
+  void **slot;
+  void **deleted_slot = 0;
+  unsigned int hash_2 = 0;
+  unsigned int hash_1 = (*ht->ht_hash_1) (key);
+
+  ht->ht_lookups++;
+  for (;;)
+    {
+      hash_1 &= (ht->ht_size - 1);
+      slot = &ht->ht_vec[hash_1];
+
+      if (*slot == 0)
+	return (deleted_slot ? deleted_slot : slot);
+      if (*slot == hash_deleted_item)
+	{
+	  if (deleted_slot == 0)
+	    deleted_slot = slot;
+	}
+      else
+	{
+	  if (key == *slot)
+	    return slot;
+	  if ((*ht->ht_compare) (key, *slot) == 0)
+	    return slot;
+	  ht->ht_collisions++;
+	}
+      if (!hash_2)
+	  hash_2 = (*ht->ht_hash_2) (key) | 1;
+      hash_1 += hash_2;
+    }
+}
+
+void *
+hash_find_item (struct hash_table *ht, const void *key)
+{
+  void **slot = hash_find_slot (ht, key);
+  return ((HASH_VACANT (*slot)) ? 0 : *slot);
+}
+
+void *
+hash_insert (struct hash_table *ht, const void *item)
+{
+  void **slot = hash_find_slot (ht, item);
+  const void *old_item = *slot;
+  hash_insert_at (ht, item, slot);
+  return (void *)((HASH_VACANT (old_item)) ? 0 : old_item);
+}
+
+void *
+hash_insert_at (struct hash_table *ht, const void *item, const void *slot)
+{
+  const void *old_item = *(void **) slot;
+  if (HASH_VACANT (old_item))
+    {
+      ht->ht_fill++;
+      if (old_item == 0)
+	ht->ht_empty_slots--;
+      old_item = item;
+    }
+  *(void const **) slot = item;
+  if (ht->ht_empty_slots < ht->ht_size - ht->ht_capacity)
+    {
+      hash_rehash (ht);
+      return (void *) hash_find_slot (ht, item);
+    }
+  else
+    return (void *) slot;
+}
+
+void *
+hash_delete (struct hash_table *ht, const void *item)
+{
+  void **slot = hash_find_slot (ht, item);
+  return hash_delete_at (ht, slot);
+}
+
+void *
+hash_delete_at (struct hash_table *ht, const void *slot)
+{
+  void *item = *(void **) slot;
+  if (!HASH_VACANT (item))
+    {
+      *(void const **) slot = hash_deleted_item;
+      ht->ht_fill--;
+      return item;
+    }
+  else
+    return 0;
+}
+
+void
+hash_free_items (struct hash_table *ht)
+{
+  void **vec = ht->ht_vec;
+  void **end = &vec[ht->ht_size];
+  for (; vec < end; vec++)
+    {
+      void *item = *vec;
+      if (!HASH_VACANT (item))
+	free (item);
+      *vec = 0;
+    }
+  ht->ht_fill = 0;
+  ht->ht_empty_slots = ht->ht_size;
+}
+
+void
+hash_delete_items (struct hash_table *ht)
+{
+  void **vec = ht->ht_vec;
+  void **end = &vec[ht->ht_size];
+  for (; vec < end; vec++)
+    *vec = 0;
+  ht->ht_fill = 0;
+  ht->ht_collisions = 0;
+  ht->ht_lookups = 0;
+  ht->ht_rehashes = 0;
+  ht->ht_empty_slots = ht->ht_size;
+}
+
+void
+hash_free (struct hash_table *ht, int free_items)
+{
+  if (free_items)
+    hash_free_items (ht);
+  else
+    {
+      ht->ht_fill = 0;
+      ht->ht_empty_slots = ht->ht_size;
+    }
+  free (ht->ht_vec);
+  ht->ht_vec = 0;
+  ht->ht_capacity = 0;
+}
+
+void
+hash_map (struct hash_table *ht, hash_map_func_t map)
+{
+  void **slot;
+  void **end = &ht->ht_vec[ht->ht_size];
+
+  for (slot = ht->ht_vec; slot < end; slot++)
+    {
+      if (!HASH_VACANT (*slot))
+	(*map) (*slot);
+    }
+}
+
+void
+hash_map_arg (struct hash_table *ht, hash_map_arg_func_t map, void *arg)
+{
+  void **slot;
+  void **end = &ht->ht_vec[ht->ht_size];
+
+  for (slot = ht->ht_vec; slot < end; slot++)
+    {
+      if (!HASH_VACANT (*slot))
+	(*map) (*slot, arg);
+    }
+}
+
+/* Double the size of the hash table in the event of overflow... */
+
+static void
+hash_rehash (struct hash_table *ht)
+{
+  unsigned long old_ht_size = ht->ht_size;
+  void **old_vec = ht->ht_vec;
+  void **ovp;
+
+  if (ht->ht_fill >= ht->ht_capacity)
+    {
+      ht->ht_size *= 2;
+      ht->ht_capacity = ht->ht_size - (ht->ht_size >> 4);
+    }
+  ht->ht_rehashes++;
+  ht->ht_vec = (void **) CALLOC (struct token *, ht->ht_size);
+
+  for (ovp = old_vec; ovp < &old_vec[old_ht_size]; ovp++)
+    {
+      if (! HASH_VACANT (*ovp))
+	{
+	  void **slot = hash_find_slot (ht, *ovp);
+	  *slot = *ovp;
+	}
+    }
+  ht->ht_empty_slots = ht->ht_size - ht->ht_fill;
+  free (old_vec);
+}
+
+void
+hash_print_stats (struct hash_table *ht, FILE *out_FILE)
+{
+  fprintf (out_FILE, _("Load=%lu/%lu=%.0f%%, "), ht->ht_fill, ht->ht_size,
+	   100.0 * (double) ht->ht_fill / (double) ht->ht_size);
+  fprintf (out_FILE, _("Rehash=%u, "), ht->ht_rehashes);
+  fprintf (out_FILE, _("Collisions=%lu/%lu=%.0f%%"), ht->ht_collisions, ht->ht_lookups,
+	   (ht->ht_lookups
+	    ? (100.0 * (double) ht->ht_collisions / (double) ht->ht_lookups)
+	    : 0));
+}
+
+/* Dump all items into a NULL-terminated vector.  Use the
+   user-supplied vector, or malloc one.  */
+
+void **
+hash_dump (struct hash_table *ht, void **vector_0, qsort_cmp_t compare)
+{
+  void **vector;
+  void **slot;
+  void **end = &ht->ht_vec[ht->ht_size];
+
+  if (vector_0 == 0)
+    vector_0 = MALLOC (void *, ht->ht_fill + 1);
+  vector = vector_0;
+
+  for (slot = ht->ht_vec; slot < end; slot++)
+    if (!HASH_VACANT (*slot))
+      *vector++ = *slot;
+  *vector = 0;
+
+  if (compare)
+    qsort (vector_0, ht->ht_fill, sizeof (void *), compare);
+  return vector_0;
+}
+
+/* Round a given number up to the nearest power of 2. */
+
+static unsigned long
+round_up_2 (unsigned long n)
+{
+  n |= (n >> 1);
+  n |= (n >> 2);
+  n |= (n >> 4);
+  n |= (n >> 8);
+  n |= (n >> 16);
+
+#if !defined(HAVE_LIMITS_H) || ULONG_MAX > 4294967295
+  /* We only need this on systems where unsigned long is >32 bits.  */
+  n |= (n >> 32);
+#endif
+
+  return n + 1;
+}
+
+#define rol32(v, n) \
+	((v) << (n) | ((v) >> (32 - (n))))
+
+/* jhash_mix -- mix 3 32-bit values reversibly. */
+#define jhash_mix(a, b, c)                      \
+{                                               \
+        a -= c;  a ^= rol32(c, 4);  c += b;     \
+        b -= a;  b ^= rol32(a, 6);  a += c;     \
+        c -= b;  c ^= rol32(b, 8);  b += a;     \
+        a -= c;  a ^= rol32(c, 16); c += b;     \
+        b -= a;  b ^= rol32(a, 19); a += c;     \
+        c -= b;  c ^= rol32(b, 4);  b += a;     \
+}
+
+/* jhash_final - final mixing of 3 32-bit values (a,b,c) into c */
+#define jhash_final(a, b, c)                    \
+{                                               \
+        c ^= b; c -= rol32(b, 14);              \
+        a ^= c; a -= rol32(c, 11);              \
+        b ^= a; b -= rol32(a, 25);              \
+        c ^= b; c -= rol32(b, 16);              \
+        a ^= c; a -= rol32(c, 4);               \
+        b ^= a; b -= rol32(a, 14);              \
+        c ^= b; c -= rol32(b, 24);              \
+}
+
+/* An arbitrary initial parameter */
+#define JHASH_INITVAL           0xdeadbeef
+
+#define sum_get_unaligned_32(r, p)              \
+  do {                                          \
+    unsigned int val;                           \
+    memcpy(&val, (p), 4);                       \
+    r += val;                                   \
+  } while(0);
+
+unsigned jhash(unsigned const char *k, int length)
+{
+  unsigned int a, b, c;
+
+  /* Set up the internal state */
+  a = b = c = JHASH_INITVAL + length;
+
+  /* All but the last block: affect some 32 bits of (a,b,c) */
+  while (length > 12) {
+    sum_get_unaligned_32(a, k);
+    sum_get_unaligned_32(b, k + 4);
+    sum_get_unaligned_32(c, k + 8);
+    jhash_mix(a, b, c);
+    length -= 12;
+    k += 12;
+  }
+
+  if (!length)
+    return c;
+
+  if (length > 8)
+    {
+      sum_get_unaligned_32(a, k);
+      length -= 4;
+      k += 4;
+    }
+  if (length > 4)
+    {
+      sum_get_unaligned_32(b, k);
+      length -= 4;
+      k += 4;
+    }
+
+  if (length == 4)
+    c += (unsigned)k[3]<<24;
+  if (length >= 3)
+    c += (unsigned)k[2]<<16;
+  if (length >= 2)
+    c += (unsigned)k[1]<<8;
+  c += k[0];
+  jhash_final(a, b, c);
+  return c;
+}
+
+#ifdef WORDS_BIGENDIAN
+/* The ifs are ordered from the first byte in memory to the last.  */
+#define sum_up_to_nul(r, p, flag)         \
+  do {                                    \
+    unsigned int val;                     \
+    memcpy(&val, (p), 4);                 \
+    if ((val & 0xFF000000) == 0)          \
+      flag = 1;                           \
+    else if ((val & 0xFF0000) == 0)       \
+      r += val & ~0xFFFF, flag = 1;       \
+    else if ((val & 0xFF00) == 0)         \
+      r += val & ~0xFF, flag = 1;         \
+    else                                  \
+      r += val, flag = (val & 0xFF) == 0; \
+  } while (0)
+#else
+/* First detect the presence of zeroes.  If there is none, we can
+   sum the 4 bytes directly.  Otherwise, the ifs are ordered as in the
+   big endian case, from the first byte in memory to the last.  */
+#define sum_up_to_nul(r, p, flag)                   \
+  do {                                              \
+    unsigned int val;                               \
+    unsigned int zeroes;                            \
+    memcpy(&val, (p), 4);                           \
+    zeroes = ((val - 0x01010101) & ~val);           \
+    if (!(zeroes & 0x80808080))                     \
+      r += val;                                     \
+    else if ((val & 0xFF) == 0)                     \
+      flag = 1;                                     \
+    else if ((val & 0xFF00) == 0)                   \
+      r += val & 0xFF, flag = 1;                    \
+    else if ((val & 0xFF0000) == 0)                 \
+      r += val & 0xFFFF, flag = 1;                  \
+    else                                            \
+      r += val, flag = 1;                           \
+  } while (0)
+#endif
+
+unsigned jhash_string(unsigned const char *k)
+{
+  unsigned int a, b, c;
+  unsigned int have_nul = 0;
+  unsigned const char *start = k;
+
+  /* Set up the internal state */
+  a = b = c = JHASH_INITVAL;
+
+  /* All but the last block: affect some 32 bits of (a,b,c) */
+  for (;;) {
+    sum_up_to_nul(a, k, have_nul);
+    if (have_nul)
+      break;
+    k += 4;
+    sum_up_to_nul(b, k, have_nul);
+    if (have_nul)
+      break;
+    k += 4;
+    sum_up_to_nul(c, k, have_nul);
+    if (have_nul)
+      break;
+    k += 4;
+    jhash_mix(a, b, c);
+  }
+
+  jhash_final(a, b, c);
+  return c + (k - start);
+}
diff --git a/src/hash.h b/src/hash.h
new file mode 100644
index 0000000..667d650
--- /dev/null
+++ b/src/hash.h
@@ -0,0 +1,234 @@
+/* hash.h -- decls for hash table
+Copyright (C) 1995, 1999, 2002, 2010 Free Software Foundation, Inc.
+Written by Greg McGary <gkm@gnu.org> <greg@mcgary.org>
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef _hash_h_
+#define _hash_h_
+
+#include <stdio.h>
+#include <ctype.h>
+
+#if defined __cplusplus || (defined __STDC__ && __STDC__) || defined WINDOWS32
+# if !defined __GLIBC__ || !defined __P
+#  undef	__P
+#  define __P(protos)	protos
+# endif
+#else /* Not C++ or ANSI C.  */
+# undef	__P
+# define __P(protos)	()
+/* We can get away without defining 'const' here only because in this file
+   it is used only inside the prototype for 'fnmatch', which is elided in
+   non-ANSI C where 'const' is problematical.  */
+#endif /* C++ or ANSI C.  */
+
+typedef unsigned long (*hash_func_t) __P((void const *key));
+typedef int (*hash_cmp_func_t) __P((void const *x, void const *y));
+typedef void (*hash_map_func_t) __P((void const *item));
+typedef void (*hash_map_arg_func_t) __P((void const *item, void *arg));
+
+struct hash_table
+{
+  void **ht_vec;
+  hash_func_t ht_hash_1;	/* primary hash function */
+  hash_func_t ht_hash_2;	/* secondary hash function */
+  hash_cmp_func_t ht_compare;	/* comparison function */
+  unsigned long ht_size;	/* total number of slots (power of 2) */
+  unsigned long ht_capacity;	/* usable slots, limited by loading-factor */
+  unsigned long ht_fill;	/* items in table */
+  unsigned long ht_empty_slots;	/* empty slots not including deleted slots */
+  unsigned long ht_collisions;	/* # of failed calls to comparison function */
+  unsigned long ht_lookups;	/* # of queries */
+  unsigned int ht_rehashes;	/* # of times we've expanded table */
+};
+
+typedef int (*qsort_cmp_t) __P((void const *, void const *));
+
+void hash_init __P((struct hash_table *ht, unsigned long size,
+		    hash_func_t hash_1, hash_func_t hash_2, hash_cmp_func_t hash_cmp));
+void hash_load __P((struct hash_table *ht, void *item_table,
+		    unsigned long cardinality, unsigned long size));
+void **hash_find_slot __P((struct hash_table *ht, void const *key));
+void *hash_find_item __P((struct hash_table *ht, void const *key));
+void *hash_insert __P((struct hash_table *ht, const void *item));
+void *hash_insert_at __P((struct hash_table *ht, const void *item, void const *slot));
+void *hash_delete __P((struct hash_table *ht, void const *item));
+void *hash_delete_at __P((struct hash_table *ht, void const *slot));
+void hash_delete_items __P((struct hash_table *ht));
+void hash_free_items __P((struct hash_table *ht));
+void hash_free __P((struct hash_table *ht, int free_items));
+void hash_map __P((struct hash_table *ht, hash_map_func_t map));
+void hash_map_arg __P((struct hash_table *ht, hash_map_arg_func_t map, void *arg));
+void hash_print_stats __P((struct hash_table *ht, FILE *out_FILE));
+void **hash_dump __P((struct hash_table *ht, void **vector_0, qsort_cmp_t compare));
+
+extern unsigned jhash(unsigned char const *key, int n);
+extern unsigned jhash_string(unsigned char const *key);
+
+extern void *hash_deleted_item;
+#define HASH_VACANT(item) ((item) == 0 || (void *) (item) == hash_deleted_item)
+
+
+/* hash and comparison macros for case-sensitive string keys. */
+
+/* Due to the strcache, it's not uncommon for the string pointers to
+   be identical.  Take advantage of that to short-circuit string compares.  */
+
+#define STRING_HASH_1(KEY, RESULT) do { \
+  unsigned char const *_key_ = (unsigned char const *) (KEY); \
+  (RESULT) += jhash_string(_key_); \
+} while (0)
+#define return_STRING_HASH_1(KEY) do { \
+  unsigned long _result_ = 0; \
+  STRING_HASH_1 ((KEY), _result_); \
+  return _result_; \
+} while (0)
+
+/* No need for a second hash because jhash already provides
+   pretty good results.  However, do evaluate the arguments
+   to avoid warnings.  */
+#define STRING_HASH_2(KEY, RESULT) do { \
+  (void)(KEY); \
+} while (0)
+#define return_STRING_HASH_2(KEY) do { \
+  unsigned long _result_ = 0; \
+  STRING_HASH_2 ((KEY), _result_); \
+  return _result_; \
+} while (0)
+
+#define STRING_COMPARE(X, Y, RESULT) do { \
+    RESULT = (X) == (Y) ? 0 : strcmp ((X), (Y)); \
+} while (0)
+#define return_STRING_COMPARE(X, Y) do { \
+  return (X) == (Y) ? 0 : strcmp ((X), (Y)); \
+} while (0)
+
+
+#define STRING_N_HASH_1(KEY, N, RESULT) do { \
+  unsigned char const *_key_ = (unsigned char const *) (KEY); \
+  (RESULT) += jhash(_key_, N); \
+} while (0)
+
+#define return_STRING_N_HASH_1(KEY, N) do { \
+  unsigned long _result_ = 0; \
+  STRING_N_HASH_1 ((KEY), (N), _result_); \
+  return _result_; \
+} while (0)
+
+/* No need for a second hash because jhash already provides
+   pretty good results.  However, do evaluate the arguments
+   to avoid warnings.  */
+#define STRING_N_HASH_2(KEY, N, RESULT) do { \
+  (void)(KEY); \
+  (void)(N); \
+} while (0)
+
+#define return_STRING_N_HASH_2(KEY, N) do { \
+  unsigned long _result_ = 0; \
+  STRING_N_HASH_2 ((KEY), (N), _result_); \
+  return _result_; \
+} while (0)
+
+#define STRING_N_COMPARE(X, Y, N, RESULT) do { \
+  RESULT = (X) == (Y) ? 0 : memcmp ((X), (Y), (N)); \
+} while (0)
+#define return_STRING_N_COMPARE(X, Y, N) do { \
+  return (X) == (Y) ? 0 : memcmp ((X), (Y), (N)); \
+} while (0)
+
+#ifdef HAVE_CASE_INSENSITIVE_FS
+
+/* hash and comparison macros for case-insensitive string _key_s. */
+
+#define ISTRING_HASH_1(KEY, RESULT) do { \
+  unsigned char const *_key_ = (unsigned char const *) (KEY) - 1; \
+  while (*++_key_) \
+    (RESULT) += ((isupper (*_key_) ? tolower (*_key_) : *_key_) << (_key_[1] & 0xf)); \
+} while (0)
+#define return_ISTRING_HASH_1(KEY) do { \
+  unsigned long _result_ = 0; \
+  ISTRING_HASH_1 ((KEY), _result_); \
+  return _result_; \
+} while (0)
+
+#define ISTRING_HASH_2(KEY, RESULT) do { \
+  unsigned char const *_key_ = (unsigned char const *) (KEY) - 1; \
+  while (*++_key_) \
+    (RESULT) += ((isupper (*_key_) ? tolower (*_key_) : *_key_) << (_key_[1] & 0x7)); \
+} while (0)
+#define return_ISTRING_HASH_2(KEY) do { \
+  unsigned long _result_ = 0; \
+  ISTRING_HASH_2 ((KEY), _result_); \
+  return _result_; \
+} while (0)
+
+#define ISTRING_COMPARE(X, Y, RESULT) do { \
+  RESULT = (X) == (Y) ? 0 : strcasecmp ((X), (Y)); \
+} while (0)
+#define return_ISTRING_COMPARE(X, Y) do { \
+  return (X) == (Y) ? 0 : strcasecmp ((X), (Y)); \
+} while (0)
+
+#else
+
+#define ISTRING_HASH_1(KEY, RESULT) STRING_HASH_1 ((KEY), (RESULT))
+#define return_ISTRING_HASH_1(KEY) return_STRING_HASH_1 (KEY)
+
+#define ISTRING_HASH_2(KEY, RESULT) STRING_HASH_2 ((KEY), (RESULT))
+#define return_ISTRING_HASH_2(KEY) return_STRING_HASH_2 (KEY)
+
+#define ISTRING_COMPARE(X, Y, RESULT) STRING_COMPARE ((X), (Y), (RESULT))
+#define return_ISTRING_COMPARE(X, Y) return_STRING_COMPARE ((X), (Y))
+
+#endif
+
+/* hash and comparison macros for integer _key_s. */
+
+#define INTEGER_HASH_1(KEY, RESULT) do { \
+  (RESULT) += ((unsigned long)(KEY)); \
+} while (0)
+#define return_INTEGER_HASH_1(KEY) do { \
+  unsigned long _result_ = 0; \
+  INTEGER_HASH_1 ((KEY), _result_); \
+  return _result_; \
+} while (0)
+
+#define INTEGER_HASH_2(KEY, RESULT) do { \
+  (RESULT) += ~((unsigned long)(KEY)); \
+} while (0)
+#define return_INTEGER_HASH_2(KEY) do { \
+  unsigned long _result_ = 0; \
+  INTEGER_HASH_2 ((KEY), _result_); \
+  return _result_; \
+} while (0)
+
+#define INTEGER_COMPARE(X, Y, RESULT) do { \
+  (RESULT) = X - Y; \
+} while (0)
+#define return_INTEGER_COMPARE(X, Y) do { \
+  int _result_; \
+  INTEGER_COMPARE (X, Y, _result_); \
+  return _result_; \
+} while (0)
+
+/* hash and comparison macros for address keys. */
+
+#define ADDRESS_HASH_1(KEY, RESULT) INTEGER_HASH_1 (((unsigned long)(KEY)) >> 3, (RESULT))
+#define ADDRESS_HASH_2(KEY, RESULT) INTEGER_HASH_2 (((unsigned long)(KEY)) >> 3, (RESULT))
+#define ADDRESS_COMPARE(X, Y, RESULT) INTEGER_COMPARE ((X), (Y), (RESULT))
+#define return_ADDRESS_HASH_1(KEY) return_INTEGER_HASH_1 (((unsigned long)(KEY)) >> 3)
+#define return_ADDRESS_HASH_2(KEY) return_INTEGER_HASH_2 (((unsigned long)(KEY)) >> 3)
+#define return_ADDRESS_COMPARE(X, Y) return_INTEGER_COMPARE ((X), (Y))
+
+#endif /* not _hash_h_ */
diff --git a/src/implicit.c b/src/implicit.c
new file mode 100644
index 0000000..e5046a4
--- /dev/null
+++ b/src/implicit.c
@@ -0,0 +1,999 @@
+/* Implicit rule searching for GNU Make.
+Copyright (C) 1988-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+#include "filedef.h"
+#include "rule.h"
+#include "dep.h"
+#include "debug.h"
+#include "variable.h"
+#include "job.h"      /* struct child, used inside commands.h */
+#include "commands.h" /* set_file_variables */
+
+static int pattern_search (struct file *file, int archive,
+                           unsigned int depth, unsigned int recursions);
+
+/* For a FILE which has no commands specified, try to figure out some
+   from the implicit pattern rules.
+   Returns 1 if a suitable implicit rule was found,
+   after modifying FILE to contain the appropriate commands and deps,
+   or returns 0 if no implicit rule was found.  */
+
+int
+try_implicit_rule (struct file *file, unsigned int depth)
+{
+  DBF (DB_IMPLICIT, _("Looking for an implicit rule for '%s'.\n"));
+
+  /* The order of these searches was previously reversed.  My logic now is
+     that since the non-archive search uses more information in the target
+     (the archive search omits the archive name), it is more specific and
+     should come first.  */
+
+  if (pattern_search (file, 0, depth, 0))
+    return 1;
+
+#ifndef NO_ARCHIVES
+  /* If this is an archive member reference, use just the
+     archive member name to search for implicit rules.  */
+  if (ar_name (file->name))
+    {
+      DBF (DB_IMPLICIT,
+           _("Looking for archive-member implicit rule for '%s'.\n"));
+      if (pattern_search (file, 1, depth, 0))
+        return 1;
+    }
+#endif
+
+  return 0;
+}
+
+
+/* Scans the BUFFER for the next word with whitespace as a separator.
+   Returns the pointer to the beginning of the word. LENGTH hold the
+   length of the word.  */
+
+static const char *
+get_next_word (const char *buffer, unsigned int *length)
+{
+  const char *p = buffer, *beg;
+  char c;
+
+  /* Skip any leading whitespace.  */
+  NEXT_TOKEN (p);
+
+  beg = p;
+  c = *(p++);
+
+  if (c == '\0')
+    return 0;
+
+
+  /* We already found the first value of "c", above.  */
+  while (1)
+    {
+      char closeparen;
+      int count;
+
+      switch (c)
+        {
+        case '\0':
+        case ' ':
+        case '\t':
+          goto done_word;
+
+        case '$':
+          c = *(p++);
+          if (c == '$')
+            break;
+
+          /* This is a variable reference, so read it to the matching
+             close paren.  */
+
+          if (c == '(')
+            closeparen = ')';
+          else if (c == '{')
+            closeparen = '}';
+          else
+            /* This is a single-letter variable reference.  */
+            break;
+
+          for (count = 0; *p != '\0'; ++p)
+            {
+              if (*p == c)
+                ++count;
+              else if (*p == closeparen && --count < 0)
+                {
+                  ++p;
+                  break;
+                }
+            }
+          break;
+
+        case '|':
+          goto done;
+
+        default:
+          break;
+        }
+
+      c = *(p++);
+    }
+ done_word:
+  --p;
+
+ done:
+  if (length)
+    *length = p - beg;
+
+  return beg;
+}
+
+/* This structure stores information about the expanded prerequisites for a
+   pattern rule.  NAME is always set to the strcache'd name of the prereq.
+   FILE and PATTERN will be set for intermediate files only.  IGNORE_MTIME is
+   copied from the prerequisite we expanded.
+ */
+struct patdeps
+  {
+    const char *name;
+    const char *pattern;
+    struct file *file;
+    unsigned int ignore_mtime : 1;
+  };
+
+/* This structure stores information about pattern rules that we need
+   to try.
+*/
+struct tryrule
+  {
+    struct rule *rule;
+
+    /* Index of the target in this rule that matched the file. */
+    unsigned int matches;
+
+    /* Stem length for this match. */
+    unsigned int stemlen;
+
+    /* Definition order of this rule. Used to implement stable sort.*/
+    unsigned int order;
+
+    /* Nonzero if the LASTSLASH logic was used in matching this rule. */
+    char checked_lastslash;
+  };
+
+int
+stemlen_compare (const void *v1, const void *v2)
+{
+  const struct tryrule *r1 = v1;
+  const struct tryrule *r2 = v2;
+  int r = r1->stemlen - r2->stemlen;
+  return r != 0 ? r : (int)(r1->order - r2->order);
+}
+
+/* Search the pattern rules for a rule with an existing dependency to make
+   FILE.  If a rule is found, the appropriate commands and deps are put in FILE
+   and 1 is returned.  If not, 0 is returned.
+
+   If ARCHIVE is nonzero, FILE->name is of the form "LIB(MEMBER)".  A rule for
+   "(MEMBER)" will be searched for, and "(MEMBER)" will not be chopped up into
+   directory and filename parts.
+
+   If an intermediate file is found by pattern search, the intermediate file
+   is set up as a target by the recursive call and is also made a dependency
+   of FILE.
+
+   DEPTH is used for debugging messages.  */
+
+static int
+pattern_search (struct file *file, int archive,
+                unsigned int depth, unsigned int recursions)
+{
+  /* Filename we are searching for a rule for.  */
+  const char *filename = archive ? strchr (file->name, '(') : file->name;
+
+  /* Length of FILENAME.  */
+  unsigned int namelen = strlen (filename);
+
+  /* The last slash in FILENAME (or nil if there is none).  */
+  const char *lastslash;
+
+  /* This is a file-object used as an argument in
+     recursive calls.  It never contains any data
+     except during a recursive call.  */
+  struct file *int_file = 0;
+
+  /* List of dependencies found recursively.  */
+  unsigned int max_deps = max_pattern_deps;
+  struct patdeps *deplist = xmalloc (max_deps * sizeof (struct patdeps));
+  struct patdeps *pat = deplist;
+
+  /* Names of possible dependencies are constructed in this buffer.  */
+  char *depname = alloca (namelen + max_pattern_dep_length);
+
+  /* The start and length of the stem of FILENAME for the current rule.  */
+  const char *stem = 0;
+  unsigned int stemlen = 0;
+  unsigned int fullstemlen = 0;
+
+  /* Buffer in which we store all the rules that are possibly applicable.  */
+  struct tryrule *tryrules = xmalloc (num_pattern_rules * max_pattern_targets
+                                      * sizeof (struct tryrule));
+
+  /* Number of valid elements in TRYRULES.  */
+  unsigned int nrules;
+
+  /* The index in TRYRULES of the rule we found.  */
+  unsigned int foundrule;
+
+  /* Nonzero if should consider intermediate files as dependencies.  */
+  int intermed_ok;
+
+  /* Nonzero if we have initialized file variables for this target.  */
+  int file_vars_initialized = 0;
+
+  /* Nonzero if we have matched a pattern-rule target
+     that is not just '%'.  */
+  int specific_rule_matched = 0;
+
+  unsigned int ri;  /* uninit checks OK */
+  struct rule *rule;
+
+  char *pathdir = NULL;
+  unsigned long pathlen;
+
+  PATH_VAR (stem_str); /* @@ Need to get rid of stem, stemlen, etc. */
+
+#ifndef NO_ARCHIVES
+  if (archive || ar_name (filename))
+    lastslash = 0;
+  else
+#endif
+    {
+      /* Set LASTSLASH to point at the last slash in FILENAME
+         but not counting any slash at the end.  (foo/bar/ counts as
+         bar/ in directory foo/, not empty in directory foo/bar/.)  */
+      lastslash = strrchr (filename, '/');
+#ifdef VMS
+      if (lastslash == NULL)
+        lastslash = strrchr (filename, ']');
+      if (lastslash == NULL)
+        lastslash = strrchr (filename, '>');
+      if (lastslash == NULL)
+        lastslash = strrchr (filename, ':');
+#endif
+#ifdef HAVE_DOS_PATHS
+      /* Handle backslashes (possibly mixed with forward slashes)
+         and the case of "d:file".  */
+      {
+        char *bslash = strrchr (filename, '\\');
+        if (lastslash == 0 || bslash > lastslash)
+          lastslash = bslash;
+        if (lastslash == 0 && filename[0] && filename[1] == ':')
+          lastslash = filename + 1;
+      }
+#endif
+      if (lastslash != 0 && lastslash[1] == '\0')
+        lastslash = 0;
+    }
+
+  pathlen = lastslash - filename + 1;
+
+  /* First see which pattern rules match this target and may be considered.
+     Put them in TRYRULES.  */
+
+  nrules = 0;
+  for (rule = pattern_rules; rule != 0; rule = rule->next)
+    {
+      unsigned int ti;
+
+      /* If the pattern rule has deps but no commands, ignore it.
+         Users cancel built-in rules by redefining them without commands.  */
+      if (rule->deps != 0 && rule->cmds == 0)
+        continue;
+
+      /* If this rule is in use by a parent pattern_search,
+         don't use it here.  */
+      if (rule->in_use)
+        {
+          DBS (DB_IMPLICIT, (_("Avoiding implicit rule recursion.\n")));
+          continue;
+        }
+
+      for (ti = 0; ti < rule->num; ++ti)
+        {
+          const char *target = rule->targets[ti];
+          const char *suffix = rule->suffixes[ti];
+          char check_lastslash;
+
+          /* Rules that can match any filename and are not terminal
+             are ignored if we're recursing, so that they cannot be
+             intermediate files.  */
+          if (recursions > 0 && target[1] == '\0' && !rule->terminal)
+            continue;
+
+          if (rule->lens[ti] > namelen)
+            /* It can't possibly match.  */
+            continue;
+
+          /* From the lengths of the filename and the pattern parts,
+             find the stem: the part of the filename that matches the %.  */
+          stem = filename + (suffix - target - 1);
+          stemlen = namelen - rule->lens[ti] + 1;
+
+          /* Set CHECK_LASTSLASH if FILENAME contains a directory
+             prefix and the target pattern does not contain a slash.  */
+
+          check_lastslash = 0;
+          if (lastslash)
+            {
+#ifdef VMS
+              check_lastslash = strpbrk (target, "/]>:") == NULL;
+#else
+              check_lastslash = strchr (target, '/') == 0;
+#endif
+#ifdef HAVE_DOS_PATHS
+              /* Didn't find it yet: check for DOS-type directories.  */
+              if (check_lastslash)
+                {
+                  char *b = strchr (target, '\\');
+                  check_lastslash = !(b || (target[0] && target[1] == ':'));
+                }
+#endif
+            }
+          if (check_lastslash)
+            {
+              /* If so, don't include the directory prefix in STEM here.  */
+              if (pathlen > stemlen)
+                continue;
+              stemlen -= pathlen;
+              stem += pathlen;
+            }
+
+          /* Check that the rule pattern matches the text before the stem.  */
+          if (check_lastslash)
+            {
+              if (stem > (lastslash + 1)
+                  && !strneq (target, lastslash + 1, stem - lastslash - 1))
+                continue;
+            }
+          else if (stem > filename
+                   && !strneq (target, filename, stem - filename))
+            continue;
+
+          /* Check that the rule pattern matches the text after the stem.
+             We could test simply use streq, but this way we compare the
+             first two characters immediately.  This saves time in the very
+             common case where the first character matches because it is a
+             period.  */
+          if (*suffix != stem[stemlen]
+              || (*suffix != '\0' && !streq (&suffix[1], &stem[stemlen + 1])))
+            continue;
+
+          /* Record if we match a rule that not all filenames will match.  */
+          if (target[1] != '\0')
+            specific_rule_matched = 1;
+
+          /* A rule with no dependencies and no commands exists solely to set
+             specific_rule_matched when it matches.  Don't try to use it.  */
+          if (rule->deps == 0 && rule->cmds == 0)
+            continue;
+
+          /* Record this rule in TRYRULES and the index of the matching
+             target in MATCHES.  If several targets of the same rule match,
+             that rule will be in TRYRULES more than once.  */
+          tryrules[nrules].rule = rule;
+          tryrules[nrules].matches = ti;
+          tryrules[nrules].stemlen = stemlen + (check_lastslash ? pathlen : 0);
+          tryrules[nrules].order = nrules;
+          tryrules[nrules].checked_lastslash = check_lastslash;
+          ++nrules;
+        }
+    }
+
+  /* Bail out early if we haven't found any rules. */
+  if (nrules == 0)
+    goto done;
+
+  /* Sort the rules to place matches with the shortest stem first. This
+     way the most specific rules will be tried first. */
+  if (nrules > 1)
+    qsort (tryrules, nrules, sizeof (struct tryrule), stemlen_compare);
+
+  /* If we have found a matching rule that won't match all filenames,
+     retroactively reject any non-"terminal" rules that do always match.  */
+  if (specific_rule_matched)
+    for (ri = 0; ri < nrules; ++ri)
+      if (!tryrules[ri].rule->terminal)
+        {
+          unsigned int j;
+          for (j = 0; j < tryrules[ri].rule->num; ++j)
+            if (tryrules[ri].rule->targets[j][1] == '\0')
+              {
+                tryrules[ri].rule = 0;
+                break;
+              }
+        }
+
+  /* Try each rule once without intermediate files, then once with them.  */
+  for (intermed_ok = 0; intermed_ok < 2; ++intermed_ok)
+    {
+      pat = deplist;
+
+      /* Try each pattern rule till we find one that applies.  If it does,
+         expand its dependencies (as substituted) and chain them in DEPS.  */
+      for (ri = 0; ri < nrules; ri++)
+        {
+          struct dep *dep;
+          char check_lastslash;
+          unsigned int failed = 0;
+          int file_variables_set = 0;
+          unsigned int deps_found = 0;
+          /* NPTR points to the part of the prereq we haven't processed.  */
+          const char *nptr = 0;
+          const char *dir = NULL;
+          int order_only = 0;
+          unsigned int matches;
+
+          rule = tryrules[ri].rule;
+
+          /* RULE is nil when we discover that a rule, already placed in
+             TRYRULES, should not be applied.  */
+          if (rule == 0)
+            continue;
+
+          /* Reject any terminal rules if we're looking to make intermediate
+             files.  */
+          if (intermed_ok && rule->terminal)
+            continue;
+
+          /* From the lengths of the filename and the matching pattern parts,
+             find the stem: the part of the filename that matches the %.  */
+          matches = tryrules[ri].matches;
+          stem = filename + (rule->suffixes[matches]
+                             - rule->targets[matches]) - 1;
+          stemlen = (namelen - rule->lens[matches]) + 1;
+          check_lastslash = tryrules[ri].checked_lastslash;
+          if (check_lastslash)
+            {
+              stem += pathlen;
+              stemlen -= pathlen;
+
+              /* We need to add the directory prefix, so set it up.  */
+              if (! pathdir)
+                {
+                  pathdir = alloca (pathlen + 1);
+                  memcpy (pathdir, filename, pathlen);
+                  pathdir[pathlen] = '\0';
+                }
+              dir = pathdir;
+            }
+
+          if (stemlen > GET_PATH_MAX)
+            {
+              DBS (DB_IMPLICIT, (_("Stem too long: '%.*s'.\n"),
+                                 (int) stemlen, stem));
+              continue;
+            }
+
+          DBS (DB_IMPLICIT, (_("Trying pattern rule with stem '%.*s'.\n"),
+                             (int) stemlen, stem));
+
+          strncpy (stem_str, stem, stemlen);
+          stem_str[stemlen] = '\0';
+
+          /* If there are no prerequisites, then this rule matches.  */
+          if (rule->deps == 0)
+            break;
+
+          /* Temporary assign STEM to file->stem (needed to set file
+             variables below).   */
+          file->stem = stem_str;
+
+          /* Mark this rule as in use so a recursive pattern_search won't try
+             to use it.  */
+          rule->in_use = 1;
+
+          /* Try each prerequisite; see if it exists or can be created.  We'll
+             build a list of prereq info in DEPLIST.  Due to 2nd expansion we
+             may have to process multiple prereqs for a single dep entry.  */
+
+          pat = deplist;
+          dep = rule->deps;
+          nptr = dep_name (dep);
+          while (1)
+            {
+              struct dep *dl, *d;
+              char *p;
+
+              /* If we're out of name to parse, start the next prereq.  */
+              if (! nptr)
+                {
+                  dep = dep->next;
+                  if (dep == 0)
+                    break;
+                  nptr = dep_name (dep);
+                }
+
+              /* If we don't need a second expansion, just replace the %.  */
+              if (! dep->need_2nd_expansion)
+                {
+                  p = strchr (nptr, '%');
+                  if (p == 0)
+                    strcpy (depname, nptr);
+                  else
+                    {
+                      char *o = depname;
+                      if (check_lastslash)
+                        {
+                          memcpy (o, filename, pathlen);
+                          o += pathlen;
+                        }
+                      memcpy (o, nptr, p - nptr);
+                      o += p - nptr;
+                      memcpy (o, stem_str, stemlen);
+                      o += stemlen;
+                      strcpy (o, p + 1);
+                    }
+
+                  /* Parse the expanded string.  It might have wildcards.  */
+                  p = depname;
+                  dl = PARSE_SIMPLE_SEQ (&p, struct dep);
+                  for (d = dl; d != NULL; d = d->next)
+                    {
+                      ++deps_found;
+                      d->ignore_mtime = dep->ignore_mtime;
+                    }
+
+                  /* We've used up this dep, so next time get a new one.  */
+                  nptr = 0;
+                }
+
+              /* We have to perform second expansion on this prereq.  In an
+                 ideal world we would take the dependency line, substitute the
+                 stem, re-expand the whole line and chop it into individual
+                 prerequisites.  Unfortunately this won't work because of the
+                 "check_lastslash" twist.  Instead, we will have to go word by
+                 word, taking $()'s into account.  For each word we will
+                 substitute the stem, re-expand, chop it up, and, if
+                 check_lastslash != 0, add the directory part to each
+                 resulting prerequisite.  */
+              else
+                {
+                  int add_dir = 0;
+                  unsigned int len;
+                  struct dep **dptr;
+
+                  nptr = get_next_word (nptr, &len);
+                  if (nptr == 0)
+                    continue;
+
+                  /* See this is a transition to order-only prereqs.  */
+                  if (! order_only && len == 1 && nptr[0] == '|')
+                    {
+                      order_only = 1;
+                      nptr += len;
+                      continue;
+                    }
+
+                  /* If the dependency name has %, substitute the stem.  If we
+                     just replace % with the stem value then later, when we do
+                     the 2nd expansion, we will re-expand this stem value
+                     again.  This is not good if you have certain characters
+                     in your stem (like $).
+
+                     Instead, we will replace % with $* and allow the second
+                     expansion to take care of it for us.  This way (since $*
+                     is a simple variable) there won't be additional
+                     re-expansion of the stem.  */
+
+                  p = lindex (nptr, nptr + len, '%');
+                  if (p == 0)
+                    {
+                      memcpy (depname, nptr, len);
+                      depname[len] = '\0';
+                    }
+                  else
+                    {
+                      unsigned int i = p - nptr;
+                      memcpy (depname, nptr, i);
+                      memcpy (depname + i, "$*", 2);
+                      memcpy (depname + i + 2, p + 1, len - i - 1);
+                      depname[len + 2 - 1] = '\0';
+
+                      if (check_lastslash)
+                        add_dir = 1;
+                    }
+
+                  /* Set up for the next word.  */
+                  nptr += len;
+
+                  /* Initialize and set file variables if we haven't already
+                     done so. */
+                  if (!file_vars_initialized)
+                    {
+                      initialize_file_variables (file, 0);
+                      set_file_variables (file);
+                      file_vars_initialized = 1;
+                    }
+                  /* Update the stem value in $* for this rule.  */
+                  else if (!file_variables_set)
+                    {
+                      define_variable_for_file (
+                        "*", 1, file->stem, o_automatic, 0, file);
+                      file_variables_set = 1;
+                    }
+
+                  /* Perform the 2nd expansion.  */
+                  p = variable_expand_for_file (depname, file);
+                  dptr = &dl;
+
+                  /* Parse the results into a deps list.  */
+                  do
+                    {
+                      /* Parse the expanded string. */
+                      struct dep *dp = PARSE_FILE_SEQ (&p, struct dep,
+                                                       order_only ? MAP_NUL : MAP_PIPE,
+                                                       add_dir ? dir : NULL, PARSEFS_NONE);
+                      *dptr = dp;
+
+                      for (d = dp; d != NULL; d = d->next)
+                        {
+                          ++deps_found;
+                          if (order_only)
+                            d->ignore_mtime = 1;
+                          dptr = &d->next;
+                        }
+
+                      /* If we stopped due to an order-only token, note it.  */
+                      if (*p == '|')
+                        {
+                          order_only = 1;
+                          ++p;
+                        }
+                    }
+                  while (*p != '\0');
+                }
+
+              /* If there are more than max_pattern_deps prerequisites (due to
+                 2nd expansion), reset it and realloc the arrays.  */
+
+              if (deps_found > max_deps)
+                {
+                  unsigned int l = pat - deplist;
+                  /* This might have changed due to recursion.  */
+                  max_pattern_deps = MAX(max_pattern_deps, deps_found);
+                  max_deps = max_pattern_deps;
+                  deplist = xrealloc (deplist,
+                                      max_deps * sizeof (struct patdeps));
+                  pat = deplist + l;
+                }
+
+              /* Go through the nameseq and handle each as a prereq name.  */
+              for (d = dl; d != 0; d = d->next)
+                {
+                  struct dep *expl_d;
+                  int is_rule = d->name == dep_name (dep);
+
+                  if (file_impossible_p (d->name))
+                    {
+                      /* If this prereq has already been ruled "impossible",
+                         then the rule fails.  Don't bother trying it on the
+                         second pass either since we know that will fail.  */
+                      DBS (DB_IMPLICIT,
+                           (is_rule
+                            ? _("Rejecting impossible rule prerequisite '%s'.\n")
+                            : _("Rejecting impossible implicit prerequisite '%s'.\n"),
+                            d->name));
+                      tryrules[ri].rule = 0;
+
+                      failed = 1;
+                      break;
+                    }
+
+                  memset (pat, '\0', sizeof (struct patdeps));
+                  pat->ignore_mtime = d->ignore_mtime;
+
+                  DBS (DB_IMPLICIT,
+                       (is_rule
+                        ? _("Trying rule prerequisite '%s'.\n")
+                        : _("Trying implicit prerequisite '%s'.\n"), d->name));
+
+                  /* If this prereq is also explicitly mentioned for FILE,
+                     skip all tests below since it must be built no matter
+                     which implicit rule we choose. */
+
+                  for (expl_d = file->deps; expl_d != 0; expl_d = expl_d->next)
+                    if (streq (dep_name (expl_d), d->name))
+                      break;
+                  if (expl_d != 0)
+                    {
+                      (pat++)->name = d->name;
+                      continue;
+                    }
+
+                  /* The DEP->changed flag says that this dependency resides
+                     in a nonexistent directory.  So we normally can skip
+                     looking for the file.  However, if CHECK_LASTSLASH is
+                     set, then the dependency file we are actually looking for
+                     is in a different directory (the one gotten by prepending
+                     FILENAME's directory), so it might actually exist.  */
+
+                  /* @@ dep->changed check is disabled. */
+                  if (lookup_file (d->name) != 0
+                      /*|| ((!dep->changed || check_lastslash) && */
+                      || file_exists_p (d->name))
+                    {
+                      (pat++)->name = d->name;
+                      continue;
+                    }
+
+                  /* This code, given FILENAME = "lib/foo.o", dependency name
+                     "lib/foo.c", and VPATH=src, searches for
+                     "src/lib/foo.c".  */
+                  {
+                    const char *vname = vpath_search (d->name, 0, NULL, NULL);
+                    if (vname)
+                      {
+                        DBS (DB_IMPLICIT,
+                             (_("Found prerequisite '%s' as VPATH '%s'\n"),
+                              d->name, vname));
+                        (pat++)->name = d->name;
+                        continue;
+                      }
+                  }
+
+                  /* We could not find the file in any place we should look.
+                     Try to make this dependency as an intermediate file, but
+                     only on the second pass.  */
+
+                  if (intermed_ok)
+                    {
+                      DBS (DB_IMPLICIT,
+                           (_("Looking for a rule with intermediate file '%s'.\n"),
+                            d->name));
+
+                      if (int_file == 0)
+                        int_file = alloca (sizeof (struct file));
+                      memset (int_file, '\0', sizeof (struct file));
+                      int_file->name = d->name;
+
+                      if (pattern_search (int_file,
+                                          0,
+                                          depth + 1,
+                                          recursions + 1))
+                        {
+                          pat->pattern = int_file->name;
+                          int_file->name = d->name;
+                          pat->file = int_file;
+                          int_file = 0;
+                          (pat++)->name = d->name;
+                          continue;
+                        }
+
+                      /* If we have tried to find P as an intermediate file
+                         and failed, mark that name as impossible so we won't
+                         go through the search again later.  */
+                      if (int_file->variables)
+                        free_variable_set (int_file->variables);
+                      if (int_file->pat_variables)
+                        free_variable_set (int_file->pat_variables);
+                      file_impossible (d->name);
+                    }
+
+                  /* A dependency of this rule does not exist. Therefore, this
+                     rule fails.  */
+                  failed = 1;
+                  break;
+                }
+
+              /* Free the ns chain.  */
+              free_dep_chain (dl);
+
+              if (failed)
+                break;
+            }
+
+          /* Reset the stem in FILE. */
+
+          file->stem = 0;
+
+          /* This rule is no longer 'in use' for recursive searches.  */
+          rule->in_use = 0;
+
+          if (! failed)
+            /* This pattern rule does apply.  Stop looking for one.  */
+            break;
+
+          /* This pattern rule does not apply.  Keep looking.  */
+        }
+
+      /* If we found an applicable rule without intermediate files, don't try
+         with them.  */
+      if (ri < nrules)
+        break;
+
+      rule = 0;
+    }
+
+  /* RULE is nil if the loop went through the list but everything failed.  */
+  if (rule == 0)
+    goto done;
+
+  foundrule = ri;
+
+  /* If we are recursing, store the pattern that matched FILENAME in
+     FILE->name for use in upper levels.  */
+
+  if (recursions > 0)
+    /* Kludge-o-matic */
+    file->name = rule->targets[tryrules[foundrule].matches];
+
+  /* DEPLIST lists the prerequisites for the rule we found.  This includes the
+     intermediate files, if any.  Convert them into entries on the deps-chain
+     of FILE.  */
+
+  while (pat-- > deplist)
+    {
+      struct dep *dep;
+      const char *s;
+
+      if (pat->file != 0)
+        {
+          /* If we need to use an intermediate file, make sure it is entered
+             as a target, with the info that was found for it in the recursive
+             pattern_search call.  We know that the intermediate file did not
+             already exist as a target; therefore we can assume that the deps
+             and cmds of F below are null before we change them.  */
+
+          struct file *imf = pat->file;
+          struct file *f = lookup_file (imf->name);
+
+          /* We don't want to delete an intermediate file that happened
+             to be a prerequisite of some (other) target. Mark it as
+             secondary.  We don't want it to be precious as that disables
+             DELETE_ON_ERROR etc.  */
+          if (f != 0)
+            f->secondary = 1;
+          else
+            f = enter_file (imf->name);
+
+          f->deps = imf->deps;
+          f->cmds = imf->cmds;
+          f->stem = imf->stem;
+          f->variables = imf->variables;
+          f->pat_variables = imf->pat_variables;
+          f->pat_searched = imf->pat_searched;
+          f->also_make = imf->also_make;
+          f->is_target = 1;
+          f->intermediate = 1;
+          f->tried_implicit = 1;
+
+          imf = lookup_file (pat->pattern);
+          if (imf != 0 && imf->precious)
+            f->precious = 1;
+
+          for (dep = f->deps; dep != 0; dep = dep->next)
+            {
+              dep->file = enter_file (dep->name);
+              dep->name = 0;
+              dep->file->tried_implicit |= dep->changed;
+            }
+        }
+
+      dep = alloc_dep ();
+      dep->ignore_mtime = pat->ignore_mtime;
+      s = strcache_add (pat->name);
+      if (recursions)
+        dep->name = s;
+      else
+        {
+          dep->file = lookup_file (s);
+          if (dep->file == 0)
+            dep->file = enter_file (s);
+        }
+
+      if (pat->file == 0 && tryrules[foundrule].rule->terminal)
+        {
+          /* If the file actually existed (was not an intermediate file), and
+             the rule that found it was a terminal one, then we want to mark
+             the found file so that it will not have implicit rule search done
+             for it.  If we are not entering a 'struct file' for it now, we
+             indicate this with the 'changed' flag.  */
+          if (dep->file == 0)
+            dep->changed = 1;
+          else
+            dep->file->tried_implicit = 1;
+        }
+
+      dep->next = file->deps;
+      file->deps = dep;
+    }
+
+  if (!tryrules[foundrule].checked_lastslash)
+    {
+      /* Always allocate new storage, since STEM might be on the stack for an
+         intermediate file.  */
+      file->stem = strcache_add_len (stem, stemlen);
+      fullstemlen = stemlen;
+    }
+  else
+    {
+      int dirlen = (lastslash + 1) - filename;
+      char *sp;
+
+      /* We want to prepend the directory from
+         the original FILENAME onto the stem.  */
+      fullstemlen = dirlen + stemlen;
+      sp = alloca (fullstemlen + 1);
+      memcpy (sp, filename, dirlen);
+      memcpy (sp + dirlen, stem, stemlen);
+      sp[fullstemlen] = '\0';
+      file->stem = strcache_add (sp);
+    }
+
+  file->cmds = rule->cmds;
+  file->is_target = 1;
+
+  /* Set precious flag. */
+  {
+    struct file *f = lookup_file (rule->targets[tryrules[foundrule].matches]);
+    if (f && f->precious)
+      file->precious = 1;
+  }
+
+  /* If this rule builds other targets, too, put the others into FILE's
+     'also_make' member.  */
+
+  if (rule->num > 1)
+    for (ri = 0; ri < rule->num; ++ri)
+      if (ri != tryrules[foundrule].matches)
+        {
+          char *nm = alloca (rule->lens[ri] + fullstemlen + 1);
+          char *p = nm;
+          struct file *f;
+          struct dep *new = alloc_dep ();
+
+          /* GKM FIMXE: handle '|' here too */
+          memcpy (p, rule->targets[ri],
+                  rule->suffixes[ri] - rule->targets[ri] - 1);
+          p += rule->suffixes[ri] - rule->targets[ri] - 1;
+          memcpy (p, file->stem, fullstemlen);
+          p += fullstemlen;
+          memcpy (p, rule->suffixes[ri],
+                  rule->lens[ri] - (rule->suffixes[ri] - rule->targets[ri])+1);
+          new->name = strcache_add (nm);
+          new->file = enter_file (new->name);
+          new->next = file->also_make;
+
+          /* Set precious flag. */
+          f = lookup_file (rule->targets[ri]);
+          if (f && f->precious)
+            new->file->precious = 1;
+
+          /* Set the is_target flag so that this file is not treated as
+             intermediate by the pattern rule search algorithm and
+             file_exists_p cannot pick it up yet.  */
+          new->file->is_target = 1;
+
+          file->also_make = new;
+        }
+
+ done:
+  free (tryrules);
+  free (deplist);
+
+  return rule != 0;
+}
diff --git a/src/job.c b/src/job.c
new file mode 100644
index 0000000..a13aada
--- /dev/null
+++ b/src/job.c
@@ -0,0 +1,3613 @@
+/* Job execution and handling for GNU Make.
+Copyright (C) 1988-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+
+#include <assert.h>
+
+#include "job.h"
+#include "debug.h"
+#include "filedef.h"
+#include "commands.h"
+#include "variable.h"
+#include "os.h"
+
+#include <string.h>
+
+/* Default shell to use.  */
+#ifdef WINDOWS32
+#ifdef HAVE_STRINGS_H
+#include <strings.h>	/* for strcasecmp, strncasecmp */
+#endif
+#include <windows.h>
+
+const char *default_shell = "sh.exe";
+int no_default_sh_exe = 1;
+int batch_mode_shell = 1;
+HANDLE main_thread;
+
+#elif defined (_AMIGA)
+
+const char *default_shell = "";
+extern int MyExecute (char **);
+int batch_mode_shell = 0;
+
+#elif defined (__MSDOS__)
+
+/* The default shell is a pointer so we can change it if Makefile
+   says so.  It is without an explicit path so we get a chance
+   to search the $PATH for it (since MSDOS doesn't have standard
+   directories we could trust).  */
+const char *default_shell = "command.com";
+int batch_mode_shell = 0;
+
+#elif defined (__EMX__)
+
+const char *default_shell = "/bin/sh";
+int batch_mode_shell = 0;
+
+#elif defined (VMS)
+
+# include <descrip.h>
+# include <stsdef.h>
+const char *default_shell = "";
+int batch_mode_shell = 0;
+
+#define strsignal vms_strsignal
+char * vms_strsignal (int status);
+
+#ifndef C_FACILITY_NO
+# define C_FACILITY_NO 0x350000
+#endif
+#ifndef VMS_POSIX_EXIT_MASK
+# define VMS_POSIX_EXIT_MASK (C_FACILITY_NO | 0xA000)
+#endif
+
+#else
+
+const char *default_shell = "/bin/sh";
+int batch_mode_shell = 0;
+
+#endif
+
+#ifdef __MSDOS__
+# include <process.h>
+static int execute_by_shell;
+static int dos_pid = 123;
+int dos_status;
+int dos_command_running;
+#endif /* __MSDOS__ */
+
+#ifdef _AMIGA
+# include <proto/dos.h>
+static int amiga_pid = 123;
+static int amiga_status;
+static char amiga_bname[32];
+static int amiga_batch_file;
+#endif /* Amiga.  */
+
+#ifdef VMS
+# ifndef __GNUC__
+#   include <processes.h>
+# endif
+# include <starlet.h>
+# include <lib$routines.h>
+static void vmsWaitForChildren (int *);
+#endif
+
+#ifdef WINDOWS32
+# include <windows.h>
+# include <io.h>
+# include <process.h>
+# include "sub_proc.h"
+# include "w32err.h"
+# include "pathstuff.h"
+# define WAIT_NOHANG 1
+#endif /* WINDOWS32 */
+
+#ifdef __EMX__
+# include <process.h>
+#endif
+
+#if defined (HAVE_SYS_WAIT_H) || defined (HAVE_UNION_WAIT)
+# include <sys/wait.h>
+#endif
+
+#ifdef HAVE_WAITPID
+# define WAIT_NOHANG(status)    waitpid (-1, (status), WNOHANG)
+#else   /* Don't have waitpid.  */
+# ifdef HAVE_WAIT3
+#  ifndef wait3
+extern int wait3 ();
+#  endif
+#  define WAIT_NOHANG(status)   wait3 ((status), WNOHANG, (struct rusage *) 0)
+# endif /* Have wait3.  */
+#endif /* Have waitpid.  */
+
+#if !defined (wait) && !defined (POSIX)
+int wait ();
+#endif
+
+#ifndef HAVE_UNION_WAIT
+
+# define WAIT_T int
+
+# ifndef WTERMSIG
+#  define WTERMSIG(x) ((x) & 0x7f)
+# endif
+# ifndef WCOREDUMP
+#  define WCOREDUMP(x) ((x) & 0x80)
+# endif
+# ifndef WEXITSTATUS
+#  define WEXITSTATUS(x) (((x) >> 8) & 0xff)
+# endif
+# ifndef WIFSIGNALED
+#  define WIFSIGNALED(x) (WTERMSIG (x) != 0)
+# endif
+# ifndef WIFEXITED
+#  define WIFEXITED(x) (WTERMSIG (x) == 0)
+# endif
+
+#else   /* Have 'union wait'.  */
+
+# define WAIT_T union wait
+# ifndef WTERMSIG
+#  define WTERMSIG(x) ((x).w_termsig)
+# endif
+# ifndef WCOREDUMP
+#  define WCOREDUMP(x) ((x).w_coredump)
+# endif
+# ifndef WEXITSTATUS
+#  define WEXITSTATUS(x) ((x).w_retcode)
+# endif
+# ifndef WIFSIGNALED
+#  define WIFSIGNALED(x) (WTERMSIG(x) != 0)
+# endif
+# ifndef WIFEXITED
+#  define WIFEXITED(x) (WTERMSIG(x) == 0)
+# endif
+
+#endif  /* Don't have 'union wait'.  */
+
+#if !defined(HAVE_UNISTD_H) && !defined(WINDOWS32)
+int dup2 ();
+int execve ();
+void _exit ();
+# ifndef VMS
+int geteuid ();
+int getegid ();
+int setgid ();
+int getgid ();
+# endif
+#endif
+
+/* Different systems have different requirements for pid_t.
+   Plus we have to support gettext string translation... Argh.  */
+static const char *
+pid2str (pid_t pid)
+{
+  static char pidstring[100];
+#if defined(WINDOWS32) && (__GNUC__ > 3 || _MSC_VER > 1300)
+  /* %Id is only needed for 64-builds, which were not supported by
+      older versions of Windows compilers.  */
+  sprintf (pidstring, "%Id", pid);
+#else
+  sprintf (pidstring, "%lu", (unsigned long) pid);
+#endif
+  return pidstring;
+}
+
+#ifndef HAVE_GETLOADAVG
+int getloadavg (double loadavg[], int nelem);
+#endif
+
+static void free_child (struct child *);
+static void start_job_command (struct child *child);
+static int load_too_high (void);
+static int job_next_command (struct child *);
+static int start_waiting_job (struct child *);
+
+/* Chain of all live (or recently deceased) children.  */
+
+struct child *children = 0;
+
+/* Number of children currently running.  */
+
+unsigned int job_slots_used = 0;
+
+/* Nonzero if the 'good' standard input is in use.  */
+
+static int good_stdin_used = 0;
+
+/* Chain of children waiting to run until the load average goes down.  */
+
+static struct child *waiting_jobs = 0;
+
+/* Non-zero if we use a *real* shell (always so on Unix).  */
+
+int unixy_shell = 1;
+
+/* Number of jobs started in the current second.  */
+
+unsigned long job_counter = 0;
+
+/* Number of jobserver tokens this instance is currently using.  */
+
+unsigned int jobserver_tokens = 0;
+
+
+#ifdef WINDOWS32
+/*
+ * The macro which references this function is defined in makeint.h.
+ */
+int
+w32_kill (pid_t pid, int sig)
+{
+  return ((process_kill ((HANDLE)pid, sig) == TRUE) ? 0 : -1);
+}
+
+/* This function creates a temporary file name with an extension specified
+ * by the unixy arg.
+ * Return an xmalloc'ed string of a newly created temp file and its
+ * file descriptor, or die.  */
+static char *
+create_batch_file (char const *base, int unixy, int *fd)
+{
+  const char *const ext = unixy ? "sh" : "bat";
+  const char *error_string = NULL;
+  char temp_path[MAXPATHLEN]; /* need to know its length */
+  unsigned path_size = GetTempPath (sizeof temp_path, temp_path);
+  int path_is_dot = 0;
+  /* The following variable is static so we won't try to reuse a name
+     that was generated a little while ago, because that file might
+     not be on disk yet, since we use FILE_ATTRIBUTE_TEMPORARY below,
+     which tells the OS it doesn't need to flush the cache to disk.
+     If the file is not yet on disk, we might think the name is
+     available, while it really isn't.  This happens in parallel
+     builds, where Make doesn't wait for one job to finish before it
+     launches the next one.  */
+  static unsigned uniq = 0;
+  static int second_loop = 0;
+  const unsigned sizemax = strlen (base) + strlen (ext) + 10;
+
+  if (path_size == 0)
+    {
+      path_size = GetCurrentDirectory (sizeof temp_path, temp_path);
+      path_is_dot = 1;
+    }
+
+  ++uniq;
+  if (uniq >= 0x10000 && !second_loop)
+    {
+      /* If we already had 64K batch files in this
+         process, make a second loop through the numbers,
+         looking for free slots, i.e. files that were
+         deleted in the meantime.  */
+      second_loop = 1;
+      uniq = 1;
+    }
+  while (path_size > 0 &&
+         path_size + sizemax < sizeof temp_path &&
+         !(uniq >= 0x10000 && second_loop))
+    {
+      unsigned size = sprintf (temp_path + path_size,
+                               "%s%s-%x.%s",
+                               temp_path[path_size - 1] == '\\' ? "" : "\\",
+                               base, uniq, ext);
+      HANDLE h = CreateFile (temp_path,  /* file name */
+                             GENERIC_READ | GENERIC_WRITE, /* desired access */
+                             0,                            /* no share mode */
+                             NULL,                         /* default security attributes */
+                             CREATE_NEW,                   /* creation disposition */
+                             FILE_ATTRIBUTE_NORMAL |       /* flags and attributes */
+                             FILE_ATTRIBUTE_TEMPORARY,     /* we'll delete it */
+                             NULL);                        /* no template file */
+
+      if (h == INVALID_HANDLE_VALUE)
+        {
+          const DWORD er = GetLastError ();
+
+          if (er == ERROR_FILE_EXISTS || er == ERROR_ALREADY_EXISTS)
+            {
+              ++uniq;
+              if (uniq == 0x10000 && !second_loop)
+                {
+                  second_loop = 1;
+                  uniq = 1;
+                }
+            }
+
+          /* the temporary path is not guaranteed to exist */
+          else if (path_is_dot == 0)
+            {
+              path_size = GetCurrentDirectory (sizeof temp_path, temp_path);
+              path_is_dot = 1;
+            }
+
+          else
+            {
+              error_string = map_windows32_error_to_string (er);
+              break;
+            }
+        }
+      else
+        {
+          const unsigned final_size = path_size + size + 1;
+          char *const path = xmalloc (final_size);
+          memcpy (path, temp_path, final_size);
+          *fd = _open_osfhandle ((intptr_t)h, 0);
+          if (unixy)
+            {
+              char *p;
+              int ch;
+              for (p = path; (ch = *p) != 0; ++p)
+                if (ch == '\\')
+                  *p = '/';
+            }
+          return path; /* good return */
+        }
+    }
+
+  *fd = -1;
+  if (error_string == NULL)
+    error_string = _("Cannot create a temporary file\n");
+  O (fatal, NILF, error_string);
+
+  /* not reached */
+  return NULL;
+}
+#endif /* WINDOWS32 */
+
+#ifdef __EMX__
+/* returns whether path is assumed to be a unix like shell. */
+int
+_is_unixy_shell (const char *path)
+{
+  /* list of non unix shells */
+  const char *known_os2shells[] = {
+    "cmd.exe",
+    "cmd",
+    "4os2.exe",
+    "4os2",
+    "4dos.exe",
+    "4dos",
+    "command.com",
+    "command",
+    NULL
+  };
+
+  /* find the rightmost '/' or '\\' */
+  const char *name = strrchr (path, '/');
+  const char *p = strrchr (path, '\\');
+  unsigned i;
+
+  if (name && p)    /* take the max */
+    name = (name > p) ? name : p;
+  else if (p)       /* name must be 0 */
+    name = p;
+  else if (!name)   /* name and p must be 0 */
+    name = path;
+
+  if (*name == '/' || *name == '\\') name++;
+
+  i = 0;
+  while (known_os2shells[i] != NULL)
+    {
+      if (strcasecmp (name, known_os2shells[i]) == 0)
+        return 0; /* not a unix shell */
+      i++;
+    }
+
+  /* in doubt assume a unix like shell */
+  return 1;
+}
+#endif /* __EMX__ */
+
+/* determines whether path looks to be a Bourne-like shell. */
+int
+is_bourne_compatible_shell (const char *path)
+{
+  /* List of known POSIX (or POSIX-ish) shells.  */
+  static const char *unix_shells[] = {
+    "sh",
+    "bash",
+    "ksh",
+    "rksh",
+    "zsh",
+    "ash",
+    "dash",
+    NULL
+  };
+  const char **s;
+
+  /* find the rightmost '/' or '\\' */
+  const char *name = strrchr (path, '/');
+  char *p = strrchr (path, '\\');
+
+  if (name && p)    /* take the max */
+    name = (name > p) ? name : p;
+  else if (p)       /* name must be 0 */
+    name = p;
+  else if (!name)   /* name and p must be 0 */
+    name = path;
+
+  if (*name == '/' || *name == '\\')
+    ++name;
+
+  /* this should be able to deal with extensions on Windows-like systems */
+  for (s = unix_shells; *s != NULL; ++s)
+    {
+#if defined(WINDOWS32) || defined(__MSDOS__)
+      unsigned int len = strlen (*s);
+      if ((strlen (name) >= len && STOP_SET (name[len], MAP_DOT|MAP_NUL))
+          && strncasecmp (name, *s, len) == 0)
+#else
+      if (strcmp (name, *s) == 0)
+#endif
+        return 1; /* a known unix-style shell */
+    }
+
+  /* if not on the list, assume it's not a Bourne-like shell */
+  return 0;
+}
+
+#ifdef POSIX
+extern sigset_t fatal_signal_set;
+
+static void
+block_sigs ()
+{
+  sigprocmask (SIG_BLOCK, &fatal_signal_set, (sigset_t *) 0);
+}
+
+static void
+unblock_sigs ()
+{
+  sigprocmask (SIG_UNBLOCK, &fatal_signal_set, (sigset_t *) 0);
+}
+
+void
+unblock_all_sigs ()
+{
+  sigset_t empty;
+  sigemptyset (&empty);
+  sigprocmask (SIG_SETMASK, &empty, (sigset_t *) 0);
+}
+
+#elif defined(HAVE_SIGSETMASK)
+
+extern int fatal_signal_mask;
+
+static void
+block_sigs ()
+{
+  sigblock (fatal_signal_mask);
+}
+
+static void
+unblock_sigs ()
+{
+  sigsetmask (siggetmask (0) & ~fatal_signal_mask)
+}
+
+void
+unblock_all_sigs ()
+{
+  sigsetmask (0);
+}
+
+#else
+
+#define block_sigs()
+#define unblock_sigs()
+
+void
+unblock_all_sigs ()
+{
+}
+
+#endif
+
+/* Write an error message describing the exit status given in
+   EXIT_CODE, EXIT_SIG, and COREDUMP, for the target TARGET_NAME.
+   Append "(ignored)" if IGNORED is nonzero.  */
+
+static void
+child_error (struct child *child,
+             int exit_code, int exit_sig, int coredump, int ignored)
+{
+  const char *pre = "*** ";
+  const char *post = "";
+  const char *dump = "";
+  const struct file *f = child->file;
+  const floc *flocp = &f->cmds->fileinfo;
+  const char *nm;
+  size_t l;
+
+  if (ignored && silent_flag)
+    return;
+
+  if (exit_sig && coredump)
+    dump = _(" (core dumped)");
+
+  if (ignored)
+    {
+      pre = "";
+      post = _(" (ignored)");
+    }
+
+  if (! flocp->filenm)
+    nm = _("<builtin>");
+  else
+    {
+      /* We can't use the standard <FILE>:<LINENO> syntax here because
+         Emacs misinterprets it and matches a bogus filename in the compile
+         buffer.  */
+      char *a = alloca (strlen (flocp->filenm) + 6 + INTSTR_LENGTH + 1);
+      sprintf (a, "%s;%lu", flocp->filenm, flocp->lineno + flocp->offset);
+      nm = a;
+    }
+
+  l = strlen (pre) + strlen (nm) + strlen (f->name) + strlen (post);
+
+  OUTPUT_SET (&child->output);
+
+  show_goal_error ();
+
+  if (exit_sig == 0)
+    error (NILF, l + INTSTR_LENGTH,
+           _("%s[%s: %s] Error %d%s"), pre, nm, f->name, exit_code, post);
+  else
+    {
+      const char *s = strsignal (exit_sig);
+      error (NILF, l + strlen (s) + strlen (dump),
+             "%s[%s: %s] %s%s%s", pre, nm, f->name, s, dump, post);
+    }
+
+  OUTPUT_UNSET ();
+}
+
+
+/* Handle a dead child.  This handler may or may not ever be installed.
+
+   If we're using the jobserver feature without pselect(), we need it.
+   First, installing it ensures the read will interrupt on SIGCHLD.  Second,
+   we close the dup'd read FD to ensure we don't enter another blocking read
+   without reaping all the dead children.  In this case we don't need the
+   dead_children count.
+
+   If we don't have either waitpid or wait3, then make is unreliable, but we
+   use the dead_children count to reap children as best we can.  */
+
+static unsigned int dead_children = 0;
+
+RETSIGTYPE
+child_handler (int sig UNUSED)
+{
+  ++dead_children;
+
+  jobserver_signal ();
+
+#ifdef __EMX__
+  /* The signal handler must called only once! */
+  signal (SIGCHLD, SIG_DFL);
+#endif
+}
+
+extern pid_t shell_function_pid;
+
+/* Reap all dead children, storing the returned status and the new command
+   state ('cs_finished') in the 'file' member of the 'struct child' for the
+   dead child, and removing the child from the chain.  In addition, if BLOCK
+   nonzero, we block in this function until we've reaped at least one
+   complete child, waiting for it to die if necessary.  If ERR is nonzero,
+   print an error message first.  */
+
+void
+reap_children (int block, int err)
+{
+#ifndef WINDOWS32
+  WAIT_T status;
+#endif
+  /* Initially, assume we have some.  */
+  int reap_more = 1;
+
+#ifdef WAIT_NOHANG
+# define REAP_MORE reap_more
+#else
+# define REAP_MORE dead_children
+#endif
+
+  /* As long as:
+
+       We have at least one child outstanding OR a shell function in progress,
+         AND
+       We're blocking for a complete child OR there are more children to reap
+
+     we'll keep reaping children.  */
+
+  while ((children != 0 || shell_function_pid != 0)
+         && (block || REAP_MORE))
+    {
+      unsigned int remote = 0;
+      pid_t pid;
+      int exit_code, exit_sig, coredump;
+      struct child *lastc, *c;
+      int child_failed;
+      int any_remote, any_local;
+      int dontcare;
+
+      if (err && block)
+        {
+          static int printed = 0;
+
+          /* We might block for a while, so let the user know why.
+             Only print this message once no matter how many jobs are left.  */
+          fflush (stdout);
+          if (!printed)
+            O (error, NILF, _("*** Waiting for unfinished jobs...."));
+          printed = 1;
+        }
+
+      /* We have one less dead child to reap.  As noted in
+         child_handler() above, this count is completely unimportant for
+         all modern, POSIX-y systems that support wait3() or waitpid().
+         The rest of this comment below applies only to early, broken
+         pre-POSIX systems.  We keep the count only because... it's there...
+
+         The test and decrement are not atomic; if it is compiled into:
+                register = dead_children - 1;
+                dead_children = register;
+         a SIGCHLD could come between the two instructions.
+         child_handler increments dead_children.
+         The second instruction here would lose that increment.  But the
+         only effect of dead_children being wrong is that we might wait
+         longer than necessary to reap a child, and lose some parallelism;
+         and we might print the "Waiting for unfinished jobs" message above
+         when not necessary.  */
+
+      if (dead_children > 0)
+        --dead_children;
+
+      any_remote = 0;
+      any_local = shell_function_pid != 0;
+      for (c = children; c != 0; c = c->next)
+        {
+          any_remote |= c->remote;
+          any_local |= ! c->remote;
+          DB (DB_JOBS, (_("Live child %p (%s) PID %s %s\n"),
+                        c, c->file->name, pid2str (c->pid),
+                        c->remote ? _(" (remote)") : ""));
+#ifdef VMS
+          break;
+#endif
+        }
+
+      /* First, check for remote children.  */
+      if (any_remote)
+        pid = remote_status (&exit_code, &exit_sig, &coredump, 0);
+      else
+        pid = 0;
+
+      if (pid > 0)
+        /* We got a remote child.  */
+        remote = 1;
+      else if (pid < 0)
+        {
+          /* A remote status command failed miserably.  Punt.  */
+        remote_status_lose:
+          pfatal_with_name ("remote_status");
+        }
+      else
+        {
+          /* No remote children.  Check for local children.  */
+#if !defined(__MSDOS__) && !defined(_AMIGA) && !defined(WINDOWS32)
+          if (any_local)
+            {
+#ifdef VMS
+              /* Todo: This needs more untangling multi-process support */
+              /* Just do single child process support now */
+              vmsWaitForChildren (&status);
+              pid = c->pid;
+
+              /* VMS failure status can not be fully translated */
+              status = $VMS_STATUS_SUCCESS (c->cstatus) ? 0 : (1 << 8);
+
+              /* A Posix failure can be exactly translated */
+              if ((c->cstatus & VMS_POSIX_EXIT_MASK) == VMS_POSIX_EXIT_MASK)
+                status = (c->cstatus >> 3 & 255) << 8;
+#else
+#ifdef WAIT_NOHANG
+              if (!block)
+                pid = WAIT_NOHANG (&status);
+              else
+#endif
+                EINTRLOOP (pid, wait (&status));
+#endif /* !VMS */
+            }
+          else
+            pid = 0;
+
+          if (pid < 0)
+            {
+              /* The wait*() failed miserably.  Punt.  */
+              pfatal_with_name ("wait");
+            }
+          else if (pid > 0)
+            {
+              /* We got a child exit; chop the status word up.  */
+              exit_code = WEXITSTATUS (status);
+              exit_sig = WIFSIGNALED (status) ? WTERMSIG (status) : 0;
+              coredump = WCOREDUMP (status);
+
+              /* If we have started jobs in this second, remove one.  */
+              if (job_counter)
+                --job_counter;
+            }
+          else
+            {
+              /* No local children are dead.  */
+              reap_more = 0;
+
+              if (!block || !any_remote)
+                break;
+
+              /* Now try a blocking wait for a remote child.  */
+              pid = remote_status (&exit_code, &exit_sig, &coredump, 1);
+              if (pid < 0)
+                goto remote_status_lose;
+              else if (pid == 0)
+                /* No remote children either.  Finally give up.  */
+                break;
+
+              /* We got a remote child.  */
+              remote = 1;
+            }
+#endif /* !__MSDOS__, !Amiga, !WINDOWS32.  */
+
+#ifdef __MSDOS__
+          /* Life is very different on MSDOS.  */
+          pid = dos_pid - 1;
+          status = dos_status;
+          exit_code = WEXITSTATUS (status);
+          if (exit_code == 0xff)
+            exit_code = -1;
+          exit_sig = WIFSIGNALED (status) ? WTERMSIG (status) : 0;
+          coredump = 0;
+#endif /* __MSDOS__ */
+#ifdef _AMIGA
+          /* Same on Amiga */
+          pid = amiga_pid - 1;
+          status = amiga_status;
+          exit_code = amiga_status;
+          exit_sig = 0;
+          coredump = 0;
+#endif /* _AMIGA */
+#ifdef WINDOWS32
+          {
+            HANDLE hPID;
+            HANDLE hcTID, hcPID;
+            DWORD dwWaitStatus = 0;
+            exit_code = 0;
+            exit_sig = 0;
+            coredump = 0;
+
+            /* Record the thread ID of the main process, so that we
+               could suspend it in the signal handler.  */
+            if (!main_thread)
+              {
+                hcTID = GetCurrentThread ();
+                hcPID = GetCurrentProcess ();
+                if (!DuplicateHandle (hcPID, hcTID, hcPID, &main_thread, 0,
+                                      FALSE, DUPLICATE_SAME_ACCESS))
+                  {
+                    DWORD e = GetLastError ();
+                    fprintf (stderr,
+                             "Determine main thread ID (Error %ld: %s)\n",
+                             e, map_windows32_error_to_string (e));
+                  }
+                else
+                  DB (DB_VERBOSE, ("Main thread handle = %p\n", main_thread));
+              }
+
+            /* wait for anything to finish */
+            hPID = process_wait_for_any (block, &dwWaitStatus);
+            if (hPID)
+              {
+                /* was an error found on this process? */
+                int werr = process_last_err (hPID);
+
+                /* get exit data */
+                exit_code = process_exit_code (hPID);
+
+                /* the extra tests of exit_code are here to prevent
+                   map_windows32_error_to_string from calling 'fatal',
+                   which will then call reap_children again */
+                if (werr && exit_code > 0 && exit_code < WSABASEERR)
+                  fprintf (stderr, "make (e=%d): %s", exit_code,
+                           map_windows32_error_to_string (exit_code));
+
+                /* signal */
+                exit_sig = process_signal (hPID);
+
+                /* cleanup process */
+                process_cleanup (hPID);
+
+                coredump = 0;
+              }
+            else if (dwWaitStatus == WAIT_FAILED)
+              {
+                /* The WaitForMultipleObjects() failed miserably.  Punt.  */
+                pfatal_with_name ("WaitForMultipleObjects");
+              }
+            else if (dwWaitStatus == WAIT_TIMEOUT)
+              {
+                /* No child processes are finished.  Give up waiting. */
+                reap_more = 0;
+                break;
+              }
+
+            pid = (pid_t) hPID;
+          }
+#endif /* WINDOWS32 */
+        }
+
+      /* Check if this is the child of the 'shell' function.  */
+      if (!remote && pid == shell_function_pid)
+        {
+          shell_completed (exit_code, exit_sig);
+          break;
+        }
+
+      /* Search for a child matching the deceased one.  */
+      lastc = 0;
+      for (c = children; c != 0; lastc = c, c = c->next)
+        if (c->pid == pid && c->remote == remote)
+          break;
+
+      if (c == 0)
+        /* An unknown child died.
+           Ignore it; it was inherited from our invoker.  */
+        continue;
+
+      /* Determine the failure status: 0 for success, 1 for updating target in
+         question mode, 2 for anything else.  */
+      if (exit_sig == 0 && exit_code == 0)
+        child_failed = MAKE_SUCCESS;
+      else if (exit_sig == 0 && exit_code == 1 && question_flag && c->recursive)
+        child_failed = MAKE_TROUBLE;
+      else
+        child_failed = MAKE_FAILURE;
+
+      DB (DB_JOBS, (child_failed
+                    ? _("Reaping losing child %p PID %s %s\n")
+                    : _("Reaping winning child %p PID %s %s\n"),
+                    c, pid2str (c->pid), c->remote ? _(" (remote)") : ""));
+
+      if (c->sh_batch_file)
+        {
+          int rm_status;
+
+          DB (DB_JOBS, (_("Cleaning up temp batch file %s\n"),
+                        c->sh_batch_file));
+
+          errno = 0;
+          rm_status = remove (c->sh_batch_file);
+          if (rm_status)
+            DB (DB_JOBS, (_("Cleaning up temp batch file %s failed (%d)\n"),
+                          c->sh_batch_file, errno));
+
+          /* all done with memory */
+          free (c->sh_batch_file);
+          c->sh_batch_file = NULL;
+        }
+
+      /* If this child had the good stdin, say it is now free.  */
+      if (c->good_stdin)
+        good_stdin_used = 0;
+
+      dontcare = c->dontcare;
+
+      if (child_failed && !c->noerror && !ignore_errors_flag)
+        {
+          /* The commands failed.  Write an error message,
+             delete non-precious targets, and abort.  */
+          static int delete_on_error = -1;
+
+          if (!dontcare && child_failed == MAKE_FAILURE)
+            child_error (c, exit_code, exit_sig, coredump, 0);
+
+          c->file->update_status = child_failed == MAKE_FAILURE ? us_failed : us_question;
+          if (delete_on_error == -1)
+            {
+              struct file *f = lookup_file (".DELETE_ON_ERROR");
+              delete_on_error = f != 0 && f->is_target;
+            }
+          if (exit_sig != 0 || delete_on_error)
+            delete_child_targets (c);
+        }
+      else
+        {
+          if (child_failed)
+            {
+              /* The commands failed, but we don't care.  */
+              child_error (c, exit_code, exit_sig, coredump, 1);
+              child_failed = 0;
+            }
+
+          /* If there are more commands to run, try to start them.  */
+          if (job_next_command (c))
+            {
+              if (handling_fatal_signal)
+                {
+                  /* Never start new commands while we are dying.
+                     Since there are more commands that wanted to be run,
+                     the target was not completely remade.  So we treat
+                     this as if a command had failed.  */
+                  c->file->update_status = us_failed;
+                }
+              else
+                {
+#ifndef NO_OUTPUT_SYNC
+                  /* If we're sync'ing per line, write the previous line's
+                     output before starting the next one.  */
+                  if (output_sync == OUTPUT_SYNC_LINE)
+                    output_dump (&c->output);
+#endif
+                  /* Check again whether to start remotely.
+                     Whether or not we want to changes over time.
+                     Also, start_remote_job may need state set up
+                     by start_remote_job_p.  */
+                  c->remote = start_remote_job_p (0);
+                  start_job_command (c);
+                  /* Fatal signals are left blocked in case we were
+                     about to put that child on the chain.  But it is
+                     already there, so it is safe for a fatal signal to
+                     arrive now; it will clean up this child's targets.  */
+                  unblock_sigs ();
+                  if (c->file->command_state == cs_running)
+                    /* We successfully started the new command.
+                       Loop to reap more children.  */
+                    continue;
+                }
+
+              if (c->file->update_status != us_success)
+                /* We failed to start the commands.  */
+                delete_child_targets (c);
+            }
+          else
+            /* There are no more commands.  We got through them all
+               without an unignored error.  Now the target has been
+               successfully updated.  */
+            c->file->update_status = us_success;
+        }
+
+      /* When we get here, all the commands for c->file are finished.  */
+
+#ifndef NO_OUTPUT_SYNC
+      /* Synchronize any remaining parallel output.  */
+      output_dump (&c->output);
+#endif
+
+      /* At this point c->file->update_status is success or failed.  But
+         c->file->command_state is still cs_running if all the commands
+         ran; notice_finish_file looks for cs_running to tell it that
+         it's interesting to check the file's modtime again now.  */
+
+      if (! handling_fatal_signal)
+        /* Notice if the target of the commands has been changed.
+           This also propagates its values for command_state and
+           update_status to its also_make files.  */
+        notice_finished_file (c->file);
+
+      DB (DB_JOBS, (_("Removing child %p PID %s%s from chain.\n"),
+                    c, pid2str (c->pid), c->remote ? _(" (remote)") : ""));
+
+      /* Block fatal signals while frobnicating the list, so that
+         children and job_slots_used are always consistent.  Otherwise
+         a fatal signal arriving after the child is off the chain and
+         before job_slots_used is decremented would believe a child was
+         live and call reap_children again.  */
+      block_sigs ();
+
+      /* There is now another slot open.  */
+      if (job_slots_used > 0)
+        --job_slots_used;
+
+      /* Remove the child from the chain and free it.  */
+      if (lastc == 0)
+        children = c->next;
+      else
+        lastc->next = c->next;
+
+      free_child (c);
+
+      unblock_sigs ();
+
+      /* If the job failed, and the -k flag was not given, die,
+         unless we are already in the process of dying.  */
+      if (!err && child_failed && !dontcare && !keep_going_flag &&
+          /* fatal_error_signal will die with the right signal.  */
+          !handling_fatal_signal)
+        die (child_failed);
+
+      /* Only block for one child.  */
+      block = 0;
+    }
+
+  return;
+}
+
+/* Free the storage allocated for CHILD.  */
+
+static void
+free_child (struct child *child)
+{
+  output_close (&child->output);
+
+  if (!jobserver_tokens)
+    ONS (fatal, NILF, "INTERNAL: Freeing child %p (%s) but no tokens left!\n",
+         child, child->file->name);
+
+  /* If we're using the jobserver and this child is not the only outstanding
+     job, put a token back into the pipe for it.  */
+
+  if (jobserver_enabled () && jobserver_tokens > 1)
+    {
+      jobserver_release (1);
+      DB (DB_JOBS, (_("Released token for child %p (%s).\n"),
+                    child, child->file->name));
+    }
+
+  --jobserver_tokens;
+
+  if (handling_fatal_signal) /* Don't bother free'ing if about to die.  */
+    return;
+
+  if (child->command_lines != 0)
+    {
+      unsigned int i;
+      for (i = 0; i < child->file->cmds->ncommand_lines; ++i)
+        free (child->command_lines[i]);
+      free (child->command_lines);
+    }
+
+  if (child->environment != 0)
+    {
+      char **ep = child->environment;
+      while (*ep != 0)
+        free (*ep++);
+      free (child->environment);
+    }
+
+  free (child);
+}
+
+
+/* Start a job to run the commands specified in CHILD.
+   CHILD is updated to reflect the commands and ID of the child process.
+
+   NOTE: On return fatal signals are blocked!  The caller is responsible
+   for calling 'unblock_sigs', once the new child is safely on the chain so
+   it can be cleaned up in the event of a fatal signal.  */
+
+static void
+start_job_command (struct child *child)
+{
+  int flags;
+  char *p;
+#ifdef VMS
+  char *argv;
+#else
+  char **argv;
+#endif
+
+  /* If we have a completely empty commandset, stop now.  */
+  if (!child->command_ptr)
+    goto next_command;
+
+  /* Combine the flags parsed for the line itself with
+     the flags specified globally for this target.  */
+  flags = (child->file->command_flags
+           | child->file->cmds->lines_flags[child->command_line - 1]);
+
+  p = child->command_ptr;
+  child->noerror = ((flags & COMMANDS_NOERROR) != 0);
+
+  while (*p != '\0')
+    {
+      if (*p == '@')
+        flags |= COMMANDS_SILENT;
+      else if (*p == '+')
+        flags |= COMMANDS_RECURSE;
+      else if (*p == '-')
+        child->noerror = 1;
+      /* Don't skip newlines.  */
+      else if (!ISBLANK (*p))
+        break;
+      ++p;
+    }
+
+  child->recursive = ((flags & COMMANDS_RECURSE) != 0);
+
+  /* Update the file's command flags with any new ones we found.  We only
+     keep the COMMANDS_RECURSE setting.  Even this isn't 100% correct; we are
+     now marking more commands recursive than should be in the case of
+     multiline define/endef scripts where only one line is marked "+".  In
+     order to really fix this, we'll have to keep a lines_flags for every
+     actual line, after expansion.  */
+  child->file->cmds->lines_flags[child->command_line - 1] |= flags & COMMANDS_RECURSE;
+
+  /* POSIX requires that a recipe prefix after a backslash-newline should
+     be ignored.  Remove it now so the output is correct.  */
+  {
+    char prefix = child->file->cmds->recipe_prefix;
+    char *p1, *p2;
+    p1 = p2 = p;
+    while (*p1 != '\0')
+      {
+        *(p2++) = *p1;
+        if (p1[0] == '\n' && p1[1] == prefix)
+          ++p1;
+        ++p1;
+      }
+    *p2 = *p1;
+  }
+
+  /* Figure out an argument list from this command line.  */
+  {
+    char *end = 0;
+#ifdef VMS
+    /* Skip any leading whitespace */
+    while (*p)
+      {
+        if (!ISSPACE (*p))
+          {
+            if (*p != '\\')
+              break;
+            if ((p[1] != '\n') && (p[1] != 'n') && (p[1] != 't'))
+              break;
+          }
+        p++;
+      }
+
+    argv = p;
+    /* Although construct_command_argv contains some code for VMS, it was/is
+       not called/used.  Please note, for VMS argv is a string (not an array
+       of strings) which contains the complete command line, which for
+       multi-line variables still includes the newlines.  So detect newlines
+       and set 'end' (which is used for child->command_ptr) instead of
+       (re-)writing construct_command_argv */
+    if (!one_shell)
+      {
+        char *s = p;
+        int instring = 0;
+        while (*s)
+          {
+            if (*s == '"')
+              instring = !instring;
+            else if (*s == '\\' && !instring && *(s+1) != 0)
+              s++;
+            else if (*s == '\n' && !instring)
+              {
+                end = s;
+                break;
+              }
+            ++s;
+          }
+      }
+#else
+    argv = construct_command_argv (p, &end, child->file,
+                                   child->file->cmds->lines_flags[child->command_line - 1],
+                                   &child->sh_batch_file);
+#endif
+    if (end == NULL)
+      child->command_ptr = NULL;
+    else
+      {
+        *end++ = '\0';
+        child->command_ptr = end;
+      }
+  }
+
+  /* If -q was given, say that updating 'failed' if there was any text on the
+     command line, or 'succeeded' otherwise.  The exit status of 1 tells the
+     user that -q is saying 'something to do'; the exit status for a random
+     error is 2.  */
+  if (argv != 0 && question_flag && !(flags & COMMANDS_RECURSE))
+    {
+#ifndef VMS
+      free (argv[0]);
+      free (argv);
+#endif
+#ifdef VMS
+      /* On VMS, argv[0] can be a null string here */
+      if (argv[0] != 0)
+        {
+#endif
+          child->file->update_status = us_question;
+          notice_finished_file (child->file);
+          return;
+#ifdef VMS
+        }
+#endif
+    }
+
+  if (touch_flag && !(flags & COMMANDS_RECURSE))
+    {
+      /* Go on to the next command.  It might be the recursive one.
+         We construct ARGV only to find the end of the command line.  */
+#ifndef VMS
+      if (argv)
+        {
+          free (argv[0]);
+          free (argv);
+        }
+#endif
+      argv = 0;
+    }
+
+  if (argv == 0)
+    {
+    next_command:
+#ifdef __MSDOS__
+      execute_by_shell = 0;   /* in case construct_command_argv sets it */
+#endif
+      /* This line has no commands.  Go to the next.  */
+      if (job_next_command (child))
+        start_job_command (child);
+      else
+        {
+          /* No more commands.  Make sure we're "running"; we might not be if
+             (e.g.) all commands were skipped due to -n.  */
+          set_command_state (child->file, cs_running);
+          child->file->update_status = us_success;
+          notice_finished_file (child->file);
+        }
+
+      OUTPUT_UNSET();
+      return;
+    }
+
+  /* Are we going to synchronize this command's output?  Do so if either we're
+     in SYNC_RECURSE mode or this command is not recursive.  We'll also check
+     output_sync separately below in case it changes due to error.  */
+  child->output.syncout = output_sync && (output_sync == OUTPUT_SYNC_RECURSE
+                                          || !(flags & COMMANDS_RECURSE));
+
+  OUTPUT_SET (&child->output);
+
+#ifndef NO_OUTPUT_SYNC
+  if (! child->output.syncout)
+    /* We don't want to sync this command: to avoid misordered
+       output ensure any already-synced content is written.  */
+    output_dump (&child->output);
+#endif
+
+  /* Print the command if appropriate.  */
+  if (just_print_flag || trace_flag
+      || (!(flags & COMMANDS_SILENT) && !silent_flag))
+    OS (message, 0, "%s", p);
+
+  /* Tell update_goal_chain that a command has been started on behalf of
+     this target.  It is important that this happens here and not in
+     reap_children (where we used to do it), because reap_children might be
+     reaping children from a different target.  We want this increment to
+     guaranteedly indicate that a command was started for the dependency
+     chain (i.e., update_file recursion chain) we are processing.  */
+
+  ++commands_started;
+
+  /* Optimize an empty command.  People use this for timestamp rules,
+     so avoid forking a useless shell.  Do this after we increment
+     commands_started so make still treats this special case as if it
+     performed some action (makes a difference as to what messages are
+     printed, etc.  */
+
+#if !defined(VMS) && !defined(_AMIGA)
+  if (
+#if defined __MSDOS__ || defined (__EMX__)
+      unixy_shell       /* the test is complicated and we already did it */
+#else
+      (argv[0] && is_bourne_compatible_shell (argv[0]))
+#endif
+      && (argv[1] && argv[1][0] == '-'
+        &&
+            ((argv[1][1] == 'c' && argv[1][2] == '\0')
+          ||
+             (argv[1][1] == 'e' && argv[1][2] == 'c' && argv[1][3] == '\0')))
+      && (argv[2] && argv[2][0] == ':' && argv[2][1] == '\0')
+      && argv[3] == NULL)
+    {
+      free (argv[0]);
+      free (argv);
+      goto next_command;
+    }
+#endif  /* !VMS && !_AMIGA */
+
+  /* If -n was given, recurse to get the next line in the sequence.  */
+
+  if (just_print_flag && !(flags & COMMANDS_RECURSE))
+    {
+#ifndef VMS
+      free (argv[0]);
+      free (argv);
+#endif
+      goto next_command;
+    }
+
+  /* We're sure we're going to invoke a command: set up the output.  */
+  output_start ();
+
+  /* Flush the output streams so they won't have things written twice.  */
+
+  fflush (stdout);
+  fflush (stderr);
+
+  /* Decide whether to give this child the 'good' standard input
+     (one that points to the terminal or whatever), or the 'bad' one
+     that points to the read side of a broken pipe.  */
+
+  child->good_stdin = !good_stdin_used;
+  if (child->good_stdin)
+    good_stdin_used = 1;
+
+  child->deleted = 0;
+
+#ifndef _AMIGA
+  /* Set up the environment for the child.  */
+  if (child->environment == 0)
+    child->environment = target_environment (child->file);
+#endif
+
+#if !defined(__MSDOS__) && !defined(_AMIGA) && !defined(WINDOWS32)
+
+#ifndef VMS
+  /* start_waiting_job has set CHILD->remote if we can start a remote job.  */
+  if (child->remote)
+    {
+      int is_remote, id, used_stdin;
+      if (start_remote_job (argv, child->environment,
+                            child->good_stdin ? 0 : get_bad_stdin (),
+                            &is_remote, &id, &used_stdin))
+        /* Don't give up; remote execution may fail for various reasons.  If
+           so, simply run the job locally.  */
+        goto run_local;
+      else
+        {
+          if (child->good_stdin && !used_stdin)
+            {
+              child->good_stdin = 0;
+              good_stdin_used = 0;
+            }
+          child->remote = is_remote;
+          child->pid = id;
+        }
+    }
+  else
+#endif /* !VMS */
+    {
+      /* Fork the child process.  */
+
+      char **parent_environ;
+
+    run_local:
+      block_sigs ();
+
+      child->remote = 0;
+
+#ifdef VMS
+      if (!child_execute_job (child, argv))
+        {
+          /* Fork failed!  */
+          perror_with_name ("fork", "");
+          goto error;
+        }
+
+#else
+
+      parent_environ = environ;
+
+      jobserver_pre_child (flags & COMMANDS_RECURSE);
+
+      child->pid = child_execute_job (&child->output, child->good_stdin, argv, child->environment);
+
+      environ = parent_environ; /* Restore value child may have clobbered.  */
+      jobserver_post_child (flags & COMMANDS_RECURSE);
+
+      if (child->pid < 0)
+        {
+          /* Fork failed!  */
+          unblock_sigs ();
+          perror_with_name ("fork", "");
+          goto error;
+        }
+#endif /* !VMS */
+    }
+
+#else   /* __MSDOS__ or Amiga or WINDOWS32 */
+#ifdef __MSDOS__
+  {
+    int proc_return;
+
+    block_sigs ();
+    dos_status = 0;
+
+    /* We call 'system' to do the job of the SHELL, since stock DOS
+       shell is too dumb.  Our 'system' knows how to handle long
+       command lines even if pipes/redirection is needed; it will only
+       call COMMAND.COM when its internal commands are used.  */
+    if (execute_by_shell)
+      {
+        char *cmdline = argv[0];
+        /* We don't have a way to pass environment to 'system',
+           so we need to save and restore ours, sigh...  */
+        char **parent_environ = environ;
+
+        environ = child->environment;
+
+        /* If we have a *real* shell, tell 'system' to call
+           it to do everything for us.  */
+        if (unixy_shell)
+          {
+            /* A *real* shell on MSDOS may not support long
+               command lines the DJGPP way, so we must use 'system'.  */
+            cmdline = argv[2];  /* get past "shell -c" */
+          }
+
+        dos_command_running = 1;
+        proc_return = system (cmdline);
+        environ = parent_environ;
+        execute_by_shell = 0;   /* for the next time */
+      }
+    else
+      {
+        dos_command_running = 1;
+        proc_return = spawnvpe (P_WAIT, argv[0], argv, child->environment);
+      }
+
+    /* Need to unblock signals before turning off
+       dos_command_running, so that child's signals
+       will be treated as such (see fatal_error_signal).  */
+    unblock_sigs ();
+    dos_command_running = 0;
+
+    /* If the child got a signal, dos_status has its
+       high 8 bits set, so be careful not to alter them.  */
+    if (proc_return == -1)
+      dos_status |= 0xff;
+    else
+      dos_status |= (proc_return & 0xff);
+    ++dead_children;
+    child->pid = dos_pid++;
+  }
+#endif /* __MSDOS__ */
+#ifdef _AMIGA
+  amiga_status = MyExecute (argv);
+
+  ++dead_children;
+  child->pid = amiga_pid++;
+  if (amiga_batch_file)
+  {
+     amiga_batch_file = 0;
+     DeleteFile (amiga_bname);        /* Ignore errors.  */
+  }
+#endif  /* Amiga */
+#ifdef WINDOWS32
+  {
+      HANDLE hPID;
+      char* arg0;
+      int outfd = FD_STDOUT;
+      int errfd = FD_STDERR;
+
+      /* make UNC paths safe for CreateProcess -- backslash format */
+      arg0 = argv[0];
+      if (arg0 && arg0[0] == '/' && arg0[1] == '/')
+        for ( ; arg0 && *arg0; arg0++)
+          if (*arg0 == '/')
+            *arg0 = '\\';
+
+      /* make sure CreateProcess() has Path it needs */
+      sync_Path_environment ();
+
+#ifndef NO_OUTPUT_SYNC
+      /* Divert child output if output_sync in use.  */
+      if (child->output.syncout)
+        {
+          if (child->output.out >= 0)
+            outfd = child->output.out;
+          if (child->output.err >= 0)
+            errfd = child->output.err;
+        }
+#else
+      outfd = errfd = -1;
+#endif
+      hPID = process_easy (argv, child->environment, outfd, errfd);
+
+      if (hPID != INVALID_HANDLE_VALUE)
+        child->pid = (pid_t) hPID;
+      else
+        {
+          int i;
+          unblock_sigs ();
+          fprintf (stderr,
+                   _("process_easy() failed to launch process (e=%ld)\n"),
+                   process_last_err (hPID));
+          for (i = 0; argv[i]; i++)
+            fprintf (stderr, "%s ", argv[i]);
+          fprintf (stderr, _("\nCounted %d args in failed launch\n"), i);
+          goto error;
+        }
+  }
+#endif /* WINDOWS32 */
+#endif  /* __MSDOS__ or Amiga or WINDOWS32 */
+
+  /* Bump the number of jobs started in this second.  */
+  ++job_counter;
+
+  /* We are the parent side.  Set the state to
+     say the commands are running and return.  */
+
+  set_command_state (child->file, cs_running);
+
+  /* Free the storage used by the child's argument list.  */
+#ifndef VMS
+  free (argv[0]);
+  free (argv);
+#endif
+
+  OUTPUT_UNSET();
+  return;
+
+ error:
+  child->file->update_status = us_failed;
+  notice_finished_file (child->file);
+  OUTPUT_UNSET();
+}
+
+/* Try to start a child running.
+   Returns nonzero if the child was started (and maybe finished), or zero if
+   the load was too high and the child was put on the 'waiting_jobs' chain.  */
+
+static int
+start_waiting_job (struct child *c)
+{
+  struct file *f = c->file;
+
+  /* If we can start a job remotely, we always want to, and don't care about
+     the local load average.  We record that the job should be started
+     remotely in C->remote for start_job_command to test.  */
+
+  c->remote = start_remote_job_p (1);
+
+  /* If we are running at least one job already and the load average
+     is too high, make this one wait.  */
+  if (!c->remote
+      && ((job_slots_used > 0 && load_too_high ())
+#ifdef WINDOWS32
+          || process_table_full ()
+#endif
+          ))
+    {
+      /* Put this child on the chain of children waiting for the load average
+         to go down.  */
+      set_command_state (f, cs_running);
+      c->next = waiting_jobs;
+      waiting_jobs = c;
+      return 0;
+    }
+
+  /* Start the first command; reap_children will run later command lines.  */
+  start_job_command (c);
+
+  switch (f->command_state)
+    {
+    case cs_running:
+      c->next = children;
+      DB (DB_JOBS, (_("Putting child %p (%s) PID %s%s on the chain.\n"),
+                    c, c->file->name, pid2str (c->pid),
+                    c->remote ? _(" (remote)") : ""));
+      children = c;
+      /* One more job slot is in use.  */
+      ++job_slots_used;
+      unblock_sigs ();
+      break;
+
+    case cs_not_started:
+      /* All the command lines turned out to be empty.  */
+      f->update_status = us_success;
+      /* FALLTHROUGH */
+
+    case cs_finished:
+      notice_finished_file (f);
+      free_child (c);
+      break;
+
+    default:
+      assert (f->command_state == cs_finished);
+      break;
+    }
+
+  return 1;
+}
+
+/* Create a 'struct child' for FILE and start its commands running.  */
+
+void
+new_job (struct file *file)
+{
+  struct commands *cmds = file->cmds;
+  struct child *c;
+  char **lines;
+  unsigned int i;
+
+  /* Let any previously decided-upon jobs that are waiting
+     for the load to go down start before this new one.  */
+  start_waiting_jobs ();
+
+  /* Reap any children that might have finished recently.  */
+  reap_children (0, 0);
+
+  /* Chop the commands up into lines if they aren't already.  */
+  chop_commands (cmds);
+
+  /* Start the command sequence, record it in a new
+     'struct child', and add that to the chain.  */
+
+  c = xcalloc (sizeof (struct child));
+  output_init (&c->output);
+
+  c->file = file;
+  c->sh_batch_file = NULL;
+
+  /* Cache dontcare flag because file->dontcare can be changed once we
+     return. Check dontcare inheritance mechanism for details.  */
+  c->dontcare = file->dontcare;
+
+  /* Start saving output in case the expansion uses $(info ...) etc.  */
+  OUTPUT_SET (&c->output);
+
+  /* Expand the command lines and store the results in LINES.  */
+  lines = xmalloc (cmds->ncommand_lines * sizeof (char *));
+  for (i = 0; i < cmds->ncommand_lines; ++i)
+    {
+      /* Collapse backslash-newline combinations that are inside variable
+         or function references.  These are left alone by the parser so
+         that they will appear in the echoing of commands (where they look
+         nice); and collapsed by construct_command_argv when it tokenizes.
+         But letting them survive inside function invocations loses because
+         we don't want the functions to see them as part of the text.  */
+
+      char *in, *out, *ref;
+
+      /* IN points to where in the line we are scanning.
+         OUT points to where in the line we are writing.
+         When we collapse a backslash-newline combination,
+         IN gets ahead of OUT.  */
+
+      in = out = cmds->command_lines[i];
+      while ((ref = strchr (in, '$')) != 0)
+        {
+          ++ref;                /* Move past the $.  */
+
+          if (out != in)
+            /* Copy the text between the end of the last chunk
+               we processed (where IN points) and the new chunk
+               we are about to process (where REF points).  */
+            memmove (out, in, ref - in);
+
+          /* Move both pointers past the boring stuff.  */
+          out += ref - in;
+          in = ref;
+
+          if (*ref == '(' || *ref == '{')
+            {
+              char openparen = *ref;
+              char closeparen = openparen == '(' ? ')' : '}';
+              char *outref;
+              int count;
+              char *p;
+
+              *out++ = *in++;   /* Copy OPENPAREN.  */
+              outref = out;
+              /* IN now points past the opening paren or brace.
+                 Count parens or braces until it is matched.  */
+              count = 0;
+              while (*in != '\0')
+                {
+                  if (*in == closeparen && --count < 0)
+                    break;
+                  else if (*in == '\\' && in[1] == '\n')
+                    {
+                      /* We have found a backslash-newline inside a
+                         variable or function reference.  Eat it and
+                         any following whitespace.  */
+
+                      int quoted = 0;
+                      for (p = in - 1; p > ref && *p == '\\'; --p)
+                        quoted = !quoted;
+
+                      if (quoted)
+                        /* There were two or more backslashes, so this is
+                           not really a continuation line.  We don't collapse
+                           the quoting backslashes here as is done in
+                           collapse_continuations, because the line will
+                           be collapsed again after expansion.  */
+                        *out++ = *in++;
+                      else
+                        {
+                          /* Skip the backslash, newline, and whitespace.  */
+                          in += 2;
+                          NEXT_TOKEN (in);
+
+                          /* Discard any preceding whitespace that has
+                             already been written to the output.  */
+                          while (out > outref && ISBLANK (out[-1]))
+                            --out;
+
+                          /* Replace it all with a single space.  */
+                          *out++ = ' ';
+                        }
+                    }
+                  else
+                    {
+                      if (*in == openparen)
+                        ++count;
+
+                      *out++ = *in++;
+                    }
+                }
+            }
+        }
+
+      /* There are no more references in this line to worry about.
+         Copy the remaining uninteresting text to the output.  */
+      if (out != in)
+        memmove (out, in, strlen (in) + 1);
+
+      /* Finally, expand the line.  */
+      cmds->fileinfo.offset = i;
+      lines[i] = allocated_variable_expand_for_file (cmds->command_lines[i],
+                                                     file);
+    }
+
+  cmds->fileinfo.offset = 0;
+  c->command_lines = lines;
+
+  /* Fetch the first command line to be run.  */
+  job_next_command (c);
+
+  /* Wait for a job slot to be freed up.  If we allow an infinite number
+     don't bother; also job_slots will == 0 if we're using the jobserver.  */
+
+  if (job_slots != 0)
+    while (job_slots_used == job_slots)
+      reap_children (1, 0);
+
+#ifdef MAKE_JOBSERVER
+  /* If we are controlling multiple jobs make sure we have a token before
+     starting the child. */
+
+  /* This can be inefficient.  There's a decent chance that this job won't
+     actually have to run any subprocesses: the command script may be empty
+     or otherwise optimized away.  It would be nice if we could defer
+     obtaining a token until just before we need it, in start_job_command.
+     To do that we'd need to keep track of whether we'd already obtained a
+     token (since start_job_command is called for each line of the job, not
+     just once).  Also more thought needs to go into the entire algorithm;
+     this is where the old parallel job code waits, so...  */
+
+  else if (jobserver_enabled ())
+    while (1)
+      {
+        int got_token;
+
+        DB (DB_JOBS, ("Need a job token; we %shave children\n",
+                      children ? "" : "don't "));
+
+        /* If we don't already have a job started, use our "free" token.  */
+        if (!jobserver_tokens)
+          break;
+
+        /* Prepare for jobserver token acquisition.  */
+        jobserver_pre_acquire ();
+
+        /* Reap anything that's currently waiting.  */
+        reap_children (0, 0);
+
+        /* Kick off any jobs we have waiting for an opportunity that
+           can run now (i.e., waiting for load). */
+        start_waiting_jobs ();
+
+        /* If our "free" slot is available, use it; we don't need a token.  */
+        if (!jobserver_tokens)
+          break;
+
+        /* There must be at least one child already, or we have no business
+           waiting for a token. */
+        if (!children)
+          O (fatal, NILF, "INTERNAL: no children as we go to sleep on read\n");
+
+        /* Get a token.  */
+        got_token = jobserver_acquire (waiting_jobs != NULL);
+
+        /* If we got one, we're done here.  */
+        if (got_token == 1)
+          {
+            DB (DB_JOBS, (_("Obtained token for child %p (%s).\n"),
+                          c, c->file->name));
+            break;
+          }
+      }
+#endif
+
+  ++jobserver_tokens;
+
+  /* Trace the build.
+     Use message here so that changes to working directories are logged.  */
+  if (trace_flag)
+    {
+      char *newer = allocated_variable_expand_for_file ("$?", c->file);
+      const char *nm;
+
+      if (! cmds->fileinfo.filenm)
+        nm = _("<builtin>");
+      else
+        {
+          char *n = alloca (strlen (cmds->fileinfo.filenm) + 1 + 11 + 1);
+          sprintf (n, "%s:%lu", cmds->fileinfo.filenm, cmds->fileinfo.lineno);
+          nm = n;
+        }
+
+      if (newer[0] == '\0')
+        OSS (message, 0,
+             _("%s: target '%s' does not exist"), nm, c->file->name);
+      else
+        OSSS (message, 0,
+              _("%s: update target '%s' due to: %s"), nm, c->file->name, newer);
+
+      free (newer);
+    }
+
+  /* The job is now primed.  Start it running.
+     (This will notice if there is in fact no recipe.)  */
+  start_waiting_job (c);
+
+  if (job_slots == 1 || not_parallel)
+    /* Since there is only one job slot, make things run linearly.
+       Wait for the child to die, setting the state to 'cs_finished'.  */
+    while (file->command_state == cs_running)
+      reap_children (1, 0);
+
+  OUTPUT_UNSET ();
+  return;
+}
+
+/* Move CHILD's pointers to the next command for it to execute.
+   Returns nonzero if there is another command.  */
+
+static int
+job_next_command (struct child *child)
+{
+  while (child->command_ptr == 0 || *child->command_ptr == '\0')
+    {
+      /* There are no more lines in the expansion of this line.  */
+      if (child->command_line == child->file->cmds->ncommand_lines)
+        {
+          /* There are no more lines to be expanded.  */
+          child->command_ptr = 0;
+          child->file->cmds->fileinfo.offset = 0;
+          return 0;
+        }
+      else
+        /* Get the next line to run.  */
+        child->command_ptr = child->command_lines[child->command_line++];
+    }
+
+  child->file->cmds->fileinfo.offset = child->command_line - 1;
+  return 1;
+}
+
+/* Determine if the load average on the system is too high to start a new job.
+
+   On systems which provide /proc/loadavg (e.g., Linux), we use an idea
+   provided by Sven C. Dack <sven.c.dack@sky.com>: retrieve the current number
+   of processes the kernel is running and, if it's greater than the requested
+   load we don't allow another job to start.  We allow a job to start with
+   equal processes since one of those will be for make itself, which will then
+   pause waiting for jobs to clear.
+
+   Otherwise, we obtain the system load average and compare that.
+
+   The system load average is only recomputed once every N (N>=1) seconds.
+   However, a very parallel make can easily start tens or even hundreds of
+   jobs in a second, which brings the system to its knees for a while until
+   that first batch of jobs clears out.
+
+   To avoid this we use a weighted algorithm to try to account for jobs which
+   have been started since the last second, and guess what the load average
+   would be now if it were computed.
+
+   This algorithm was provided by Thomas Riedl <thomas.riedl@siemens.com>,
+   based on load average being recomputed once per second, which is
+   (apparently) how Solaris operates.  Linux recomputes only once every 5
+   seconds, but Linux is handled by the /proc/loadavg algorithm above.
+
+   Thomas writes:
+
+!      calculate something load-oid and add to the observed sys.load,
+!      so that latter can catch up:
+!      - every job started increases jobctr;
+!      - every dying job decreases a positive jobctr;
+!      - the jobctr value gets zeroed every change of seconds,
+!        after its value*weight_b is stored into the 'backlog' value last_sec
+!      - weight_a times the sum of jobctr and last_sec gets
+!        added to the observed sys.load.
+!
+!      The two weights have been tried out on 24 and 48 proc. Sun Solaris-9
+!      machines, using a several-thousand-jobs-mix of cpp, cc, cxx and smallish
+!      sub-shelled commands (rm, echo, sed...) for tests.
+!      lowering the 'direct influence' factor weight_a (e.g. to 0.1)
+!      resulted in significant excession of the load limit, raising it
+!      (e.g. to 0.5) took bad to small, fast-executing jobs and didn't
+!      reach the limit in most test cases.
+!
+!      lowering the 'history influence' weight_b (e.g. to 0.1) resulted in
+!      exceeding the limit for longer-running stuff (compile jobs in
+!      the .5 to 1.5 sec. range),raising it (e.g. to 0.5) overrepresented
+!      small jobs' effects.
+
+ */
+
+#define LOAD_WEIGHT_A           0.25
+#define LOAD_WEIGHT_B           0.25
+
+static int
+load_too_high (void)
+{
+#if defined(__MSDOS__) || defined(VMS) || defined(_AMIGA) || defined(__riscos__)
+  return 1;
+#else
+  static double last_sec;
+  static time_t last_now;
+  static int proc_fd = -2;
+  double load, guess;
+  time_t now;
+
+#ifdef WINDOWS32
+  /* sub_proc.c is limited in the number of objects it can wait for. */
+  if (process_table_full ())
+    return 1;
+#endif
+
+  if (max_load_average < 0)
+    return 0;
+
+  /* If we haven't tried to open /proc/loadavg, try now.  */
+#define LOADAVG "/proc/loadavg"
+  if (proc_fd == -2)
+    {
+      EINTRLOOP (proc_fd, open (LOADAVG, O_RDONLY));
+      if (proc_fd < 0)
+        DB (DB_JOBS, ("Using system load detection method.\n"));
+      else
+        {
+          DB (DB_JOBS, ("Using " LOADAVG " load detection method.\n"));
+          fd_noinherit (proc_fd);
+        }
+    }
+
+  /* Try to read /proc/loadavg if we managed to open it.  */
+  if (proc_fd >= 0)
+    {
+      int r;
+
+      EINTRLOOP (r, lseek (proc_fd, 0, SEEK_SET));
+      if (r >= 0)
+        {
+#define PROC_LOADAVG_SIZE 64
+          char avg[PROC_LOADAVG_SIZE+1];
+
+          EINTRLOOP (r, read (proc_fd, avg, PROC_LOADAVG_SIZE));
+          if (r >= 0)
+            {
+              const char *p;
+
+              /* The syntax of /proc/loadavg is:
+                    <1m> <5m> <15m> <running>/<total> <pid>
+                 The load is considered too high if there are more jobs
+                 running than the requested average.  */
+
+              avg[r] = '\0';
+              p = strchr (avg, ' ');
+              if (p)
+                p = strchr (p+1, ' ');
+              if (p)
+                p = strchr (p+1, ' ');
+
+              if (p && ISDIGIT(p[1]))
+                {
+                  int cnt = atoi (p+1);
+                  DB (DB_JOBS, ("Running: system = %d / make = %u (max requested = %f)\n",
+                                cnt, job_slots_used, max_load_average));
+                  return (double)cnt > max_load_average;
+                }
+
+              DB (DB_JOBS, ("Failed to parse " LOADAVG ": %s\n", avg));
+            }
+        }
+
+      /* If we got here, something went wrong.  Give up on this method.  */
+      if (r < 0)
+        DB (DB_JOBS, ("Failed to read " LOADAVG ": %s\n", strerror (errno)));
+
+      close (proc_fd);
+      proc_fd = -1;
+    }
+
+  /* Find the real system load average.  */
+  make_access ();
+  if (getloadavg (&load, 1) != 1)
+    {
+      static int lossage = -1;
+      /* Complain only once for the same error.  */
+      if (lossage == -1 || errno != lossage)
+        {
+          if (errno == 0)
+            /* An errno value of zero means getloadavg is just unsupported.  */
+            O (error, NILF,
+               _("cannot enforce load limits on this operating system"));
+          else
+            perror_with_name (_("cannot enforce load limit: "), "getloadavg");
+        }
+      lossage = errno;
+      load = 0;
+    }
+  user_access ();
+
+  /* If we're in a new second zero the counter and correct the backlog
+     value.  Only keep the backlog for one extra second; after that it's 0.  */
+  now = time (NULL);
+  if (last_now < now)
+    {
+      if (last_now == now - 1)
+        last_sec = LOAD_WEIGHT_B * job_counter;
+      else
+        last_sec = 0.0;
+
+      job_counter = 0;
+      last_now = now;
+    }
+
+  /* Try to guess what the load would be right now.  */
+  guess = load + (LOAD_WEIGHT_A * (job_counter + last_sec));
+
+  DB (DB_JOBS, ("Estimated system load = %f (actual = %f) (max requested = %f)\n",
+                guess, load, max_load_average));
+
+  return guess >= max_load_average;
+#endif
+}
+
+/* Start jobs that are waiting for the load to be lower.  */
+
+void
+start_waiting_jobs (void)
+{
+  struct child *job;
+
+  if (waiting_jobs == 0)
+    return;
+
+  do
+    {
+      /* Check for recently deceased descendants.  */
+      reap_children (0, 0);
+
+      /* Take a job off the waiting list.  */
+      job = waiting_jobs;
+      waiting_jobs = job->next;
+
+      /* Try to start that job.  We break out of the loop as soon
+         as start_waiting_job puts one back on the waiting list.  */
+    }
+  while (start_waiting_job (job) && waiting_jobs != 0);
+
+  return;
+}
+
+#ifndef WINDOWS32
+
+/* EMX: Start a child process. This function returns the new pid.  */
+# if defined __EMX__
+int
+child_execute_job (struct output *out, int good_stdin, char **argv, char **envp)
+{
+  int pid;
+  int fdin = good_stdin ? FD_STDIN : get_bad_stdin ();
+  int fdout = FD_STDOUT;
+  int fderr = FD_STDERR;
+  int save_fdin = -1;
+  int save_fdout = -1;
+  int save_fderr = -1;
+
+  /* Divert child output if we want to capture output.  */
+  if (out && out->syncout)
+    {
+      if (out->out >= 0)
+        fdout = out->out;
+      if (out->err >= 0)
+        fderr = out->err;
+    }
+
+  /* For each FD which needs to be redirected first make a dup of the standard
+     FD to save and mark it close on exec so our child won't see it.  Then
+     dup2() the standard FD to the redirect FD, and also mark the redirect FD
+     as close on exec. */
+  if (fdin != FD_STDIN)
+    {
+      save_fdin = dup (FD_STDIN);
+      if (save_fdin < 0)
+        O (fatal, NILF, _("no more file handles: could not duplicate stdin\n"));
+      fd_noinherit (save_fdin);
+
+      dup2 (fdin, FD_STDIN);
+      fd_noinherit (fdin);
+    }
+
+  if (fdout != FD_STDOUT)
+    {
+      save_fdout = dup (FD_STDOUT);
+      if (save_fdout < 0)
+        O (fatal, NILF,
+           _("no more file handles: could not duplicate stdout\n"));
+      fd_noinherit (save_fdout);
+
+      dup2 (fdout, FD_STDOUT);
+      fd_noinherit (fdout);
+    }
+
+  if (fderr != FD_STDERR)
+    {
+      if (fderr != fdout)
+        {
+          save_fderr = dup (FD_STDERR);
+          if (save_fderr < 0)
+            O (fatal, NILF,
+               _("no more file handles: could not duplicate stderr\n"));
+          fd_noinherit (save_fderr);
+        }
+
+      dup2 (fderr, FD_STDERR);
+      fd_noinherit (fderr);
+    }
+
+  /* Run the command.  */
+  pid = exec_command (argv, envp);
+
+  /* Restore stdout/stdin/stderr of the parent and close temporary FDs.  */
+  if (save_fdin >= 0)
+    {
+      if (dup2 (save_fdin, FD_STDIN) != FD_STDIN)
+        O (fatal, NILF, _("Could not restore stdin\n"));
+      else
+        close (save_fdin);
+    }
+
+  if (save_fdout >= 0)
+    {
+      if (dup2 (save_fdout, FD_STDOUT) != FD_STDOUT)
+        O (fatal, NILF, _("Could not restore stdout\n"));
+      else
+        close (save_fdout);
+    }
+
+  if (save_fderr >= 0)
+    {
+      if (dup2 (save_fderr, FD_STDERR) != FD_STDERR)
+        O (fatal, NILF, _("Could not restore stderr\n"));
+      else
+        close (save_fderr);
+    }
+
+  return pid;
+}
+
+#elif !defined (_AMIGA) && !defined (__MSDOS__) && !defined (VMS)
+
+/* POSIX:
+   Create a child process executing the command in ARGV.
+   ENVP is the environment of the new program.  Returns the PID or -1.  */
+int
+child_execute_job (struct output *out, int good_stdin, char **argv, char **envp)
+{
+  const int fdin = good_stdin ? FD_STDIN : get_bad_stdin ();
+  int fdout = FD_STDOUT;
+  int fderr = FD_STDERR;
+  int r;
+  int pid;
+
+  /* Divert child output if we want to capture it.  */
+  if (out && out->syncout)
+    {
+      if (out->out >= 0)
+        fdout = out->out;
+      if (out->err >= 0)
+        fderr = out->err;
+    }
+
+  pid = vfork();
+  if (pid != 0)
+    return pid;
+
+  /* We are the child.  */
+  unblock_all_sigs ();
+
+#ifdef SET_STACK_SIZE
+  /* Reset limits, if necessary.  */
+  if (stack_limit.rlim_cur)
+    setrlimit (RLIMIT_STACK, &stack_limit);
+#endif
+
+  /* For any redirected FD, dup2() it to the standard FD.
+     They are all marked close-on-exec already.  */
+  if (fdin >= 0 && fdin != FD_STDIN)
+    EINTRLOOP (r, dup2 (fdin, FD_STDIN));
+  if (fdout != FD_STDOUT)
+    EINTRLOOP (r, dup2 (fdout, FD_STDOUT));
+  if (fderr != FD_STDERR)
+    EINTRLOOP (r, dup2 (fderr, FD_STDERR));
+
+  /* Run the command.  */
+  exec_command (argv, envp);
+}
+#endif /* !AMIGA && !__MSDOS__ && !VMS */
+#endif /* !WINDOWS32 */
+
+#ifndef _AMIGA
+/* Replace the current process with one running the command in ARGV,
+   with environment ENVP.  This function does not return.  */
+
+/* EMX: This function returns the pid of the child process.  */
+# ifdef __EMX__
+int
+# else
+void
+# endif
+exec_command (char **argv, char **envp)
+{
+#ifdef VMS
+  /* to work around a problem with signals and execve: ignore them */
+#ifdef SIGCHLD
+  signal (SIGCHLD,SIG_IGN);
+#endif
+  /* Run the program.  */
+  execve (argv[0], argv, envp);
+  perror_with_name ("execve: ", argv[0]);
+  _exit (EXIT_FAILURE);
+#else
+#ifdef WINDOWS32
+  HANDLE hPID;
+  HANDLE hWaitPID;
+  int exit_code = EXIT_FAILURE;
+
+  /* make sure CreateProcess() has Path it needs */
+  sync_Path_environment ();
+
+  /* launch command */
+  hPID = process_easy (argv, envp, -1, -1);
+
+  /* make sure launch ok */
+  if (hPID == INVALID_HANDLE_VALUE)
+    {
+      int i;
+      fprintf (stderr, _("process_easy() failed to launch process (e=%ld)\n"),
+               process_last_err (hPID));
+      for (i = 0; argv[i]; i++)
+          fprintf (stderr, "%s ", argv[i]);
+      fprintf (stderr, _("\nCounted %d args in failed launch\n"), i);
+      exit (EXIT_FAILURE);
+    }
+
+  /* wait and reap last child */
+  hWaitPID = process_wait_for_any (1, 0);
+  while (hWaitPID)
+    {
+      /* was an error found on this process? */
+      int err = process_last_err (hWaitPID);
+
+      /* get exit data */
+      exit_code = process_exit_code (hWaitPID);
+
+      if (err)
+          fprintf (stderr, "make (e=%d, rc=%d): %s",
+                   err, exit_code, map_windows32_error_to_string (err));
+
+      /* cleanup process */
+      process_cleanup (hWaitPID);
+
+      /* expect to find only last pid, warn about other pids reaped */
+      if (hWaitPID == hPID)
+          break;
+      else
+        {
+          char *pidstr = xstrdup (pid2str ((pid_t)hWaitPID));
+
+          fprintf (stderr,
+                   _("make reaped child pid %s, still waiting for pid %s\n"),
+                   pidstr, pid2str ((pid_t)hPID));
+          free (pidstr);
+        }
+    }
+
+  /* return child's exit code as our exit code */
+  exit (exit_code);
+
+#else  /* !WINDOWS32 */
+
+# ifdef __EMX__
+  int pid;
+# endif
+
+  /* Be the user, permanently.  */
+  child_access ();
+
+# ifdef __EMX__
+  /* Run the program.  */
+  pid = spawnvpe (P_NOWAIT, argv[0], argv, envp);
+  if (pid >= 0)
+    return pid;
+
+  /* the file might have a strange shell extension */
+  if (errno == ENOENT)
+    errno = ENOEXEC;
+
+# else
+  /* Run the program.  */
+  environ = envp;
+  execvp (argv[0], argv);
+
+# endif /* !__EMX__ */
+
+  switch (errno)
+    {
+    case ENOENT:
+      /* We are in the child: don't use the output buffer.
+         It's not right to run fprintf() here!  */
+      if (makelevel == 0)
+        fprintf (stderr, _("%s: %s: Command not found\n"), program, argv[0]);
+      else
+        fprintf (stderr, _("%s[%u]: %s: Command not found\n"),
+                 program, makelevel, argv[0]);
+      break;
+    case ENOEXEC:
+      {
+        /* The file is not executable.  Try it as a shell script.  */
+        const char *shell;
+        char **new_argv;
+        int argc;
+        int i=1;
+
+# ifdef __EMX__
+        /* Do not use $SHELL from the environment */
+        struct variable *p = lookup_variable ("SHELL", 5);
+        if (p)
+          shell = p->value;
+        else
+          shell = 0;
+# else
+        shell = getenv ("SHELL");
+# endif
+        if (shell == 0)
+          shell = default_shell;
+
+        argc = 1;
+        while (argv[argc] != 0)
+          ++argc;
+
+# ifdef __EMX__
+        if (!unixy_shell)
+          ++argc;
+# endif
+
+        new_argv = alloca ((1 + argc + 1) * sizeof (char *));
+        new_argv[0] = (char *)shell;
+
+# ifdef __EMX__
+        if (!unixy_shell)
+          {
+            new_argv[1] = "/c";
+            ++i;
+            --argc;
+          }
+# endif
+
+        new_argv[i] = argv[0];
+        while (argc > 0)
+          {
+            new_argv[i + argc] = argv[argc];
+            --argc;
+          }
+
+# ifdef __EMX__
+        pid = spawnvpe (P_NOWAIT, shell, new_argv, envp);
+        if (pid >= 0)
+          break;
+# else
+        execvp (shell, new_argv);
+# endif
+        if (errno == ENOENT)
+          OS (error, NILF, _("%s: Shell program not found"), shell);
+        else
+          perror_with_name ("execvp: ", shell);
+        break;
+      }
+
+# ifdef __EMX__
+    case EINVAL:
+      /* this nasty error was driving me nuts :-( */
+      O (error, NILF, _("spawnvpe: environment space might be exhausted"));
+      /* FALLTHROUGH */
+# endif
+
+    default:
+      perror_with_name ("execvp: ", argv[0]);
+      break;
+    }
+
+# ifdef __EMX__
+  return pid;
+# else
+  _exit (127);
+# endif
+#endif /* !WINDOWS32 */
+#endif /* !VMS */
+}
+#else /* On Amiga */
+void
+exec_command (char **argv)
+{
+  MyExecute (argv);
+}
+
+void clean_tmp (void)
+{
+  DeleteFile (amiga_bname);
+}
+
+#endif /* On Amiga */
+
+#ifndef VMS
+/* Figure out the argument list necessary to run LINE as a command.  Try to
+   avoid using a shell.  This routine handles only ' quoting, and " quoting
+   when no backslash, $ or ' characters are seen in the quotes.  Starting
+   quotes may be escaped with a backslash.  If any of the characters in
+   sh_chars is seen, or any of the builtin commands listed in sh_cmds
+   is the first word of a line, the shell is used.
+
+   If RESTP is not NULL, *RESTP is set to point to the first newline in LINE.
+   If *RESTP is NULL, newlines will be ignored.
+
+   SHELL is the shell to use, or nil to use the default shell.
+   IFS is the value of $IFS, or nil (meaning the default).
+
+   FLAGS is the value of lines_flags for this command line.  It is
+   used in the WINDOWS32 port to check whether + or $(MAKE) were found
+   in this command line, in which case the effect of just_print_flag
+   is overridden.  */
+
+static char **
+construct_command_argv_internal (char *line, char **restp, const char *shell,
+                                 const char *shellflags, const char *ifs,
+                                 int flags, char **batch_filename UNUSED)
+{
+#ifdef __MSDOS__
+  /* MSDOS supports both the stock DOS shell and ports of Unixy shells.
+     We call 'system' for anything that requires ''slow'' processing,
+     because DOS shells are too dumb.  When $SHELL points to a real
+     (unix-style) shell, 'system' just calls it to do everything.  When
+     $SHELL points to a DOS shell, 'system' does most of the work
+     internally, calling the shell only for its internal commands.
+     However, it looks on the $PATH first, so you can e.g. have an
+     external command named 'mkdir'.
+
+     Since we call 'system', certain characters and commands below are
+     actually not specific to COMMAND.COM, but to the DJGPP implementation
+     of 'system'.  In particular:
+
+       The shell wildcard characters are in DOS_CHARS because they will
+       not be expanded if we call the child via 'spawnXX'.
+
+       The ';' is in DOS_CHARS, because our 'system' knows how to run
+       multiple commands on a single line.
+
+       DOS_CHARS also include characters special to 4DOS/NDOS, so we
+       won't have to tell one from another and have one more set of
+       commands and special characters.  */
+  static const char *sh_chars_dos = "*?[];|<>%^&()";
+  static const char *sh_cmds_dos[] =
+    { "break", "call", "cd", "chcp", "chdir", "cls", "copy", "ctty", "date",
+      "del", "dir", "echo", "erase", "exit", "for", "goto", "if", "md",
+      "mkdir", "path", "pause", "prompt", "rd", "rmdir", "rem", "ren",
+      "rename", "set", "shift", "time", "type", "ver", "verify", "vol", ":",
+      0 };
+
+  static const char *sh_chars_sh = "#;\"*?[]&|<>(){}$`^";
+  static const char *sh_cmds_sh[] =
+    { "cd", "echo", "eval", "exec", "exit", "login", "logout", "set", "umask",
+      "wait", "while", "for", "case", "if", ":", ".", "break", "continue",
+      "export", "read", "readonly", "shift", "times", "trap", "switch",
+      "unset", "ulimit", "command", 0 };
+
+  const char *sh_chars;
+  const char **sh_cmds;
+
+#elif defined (__EMX__)
+  static const char *sh_chars_dos = "*?[];|<>%^&()";
+  static const char *sh_cmds_dos[] =
+    { "break", "call", "cd", "chcp", "chdir", "cls", "copy", "ctty", "date",
+      "del", "dir", "echo", "erase", "exit", "for", "goto", "if", "md",
+      "mkdir", "path", "pause", "prompt", "rd", "rmdir", "rem", "ren",
+      "rename", "set", "shift", "time", "type", "ver", "verify", "vol", ":",
+      0 };
+
+  static const char *sh_chars_os2 = "*?[];|<>%^()\"'&";
+  static const char *sh_cmds_os2[] =
+    { "call", "cd", "chcp", "chdir", "cls", "copy", "date", "del", "detach",
+      "dir", "echo", "endlocal", "erase", "exit", "for", "goto", "if", "keys",
+      "md", "mkdir", "move", "path", "pause", "prompt", "rd", "rem", "ren",
+      "rename", "rmdir", "set", "setlocal", "shift", "start", "time", "type",
+      "ver", "verify", "vol", ":", 0 };
+
+  static const char *sh_chars_sh = "#;\"*?[]&|<>(){}$`^~'";
+  static const char *sh_cmds_sh[] =
+    { "echo", "cd", "eval", "exec", "exit", "login", "logout", "set", "umask",
+      "wait", "while", "for", "case", "if", ":", ".", "break", "continue",
+      "export", "read", "readonly", "shift", "times", "trap", "switch",
+      "unset", "command", 0 };
+
+  const char *sh_chars;
+  const char **sh_cmds;
+
+#elif defined (_AMIGA)
+  static const char *sh_chars = "#;\"|<>()?*$`";
+  static const char *sh_cmds[] =
+    { "cd", "eval", "if", "delete", "echo", "copy", "rename", "set", "setenv",
+      "date", "makedir", "skip", "else", "endif", "path", "prompt", "unset",
+      "unsetenv", "version", "command", 0 };
+
+#elif defined (WINDOWS32)
+  /* We used to have a double quote (") in sh_chars_dos[] below, but
+     that caused any command line with quoted file names be run
+     through a temporary batch file, which introduces command-line
+     limit of 4K charcaters imposed by cmd.exe.  Since CreateProcess
+     can handle quoted file names just fine, removing the quote lifts
+     the limit from a very frequent use case, because using quoted
+     file names is commonplace on MS-Windows.  */
+  static const char *sh_chars_dos = "|&<>";
+  static const char *sh_cmds_dos[] =
+    { "assoc", "break", "call", "cd", "chcp", "chdir", "cls", "color", "copy",
+      "ctty", "date", "del", "dir", "echo", "echo.", "endlocal", "erase",
+      "exit", "for", "ftype", "goto", "if", "if", "md", "mkdir", "move",
+      "path", "pause", "prompt", "rd", "rem", "ren", "rename", "rmdir",
+      "set", "setlocal", "shift", "time", "title", "type", "ver", "verify",
+      "vol", ":", 0 };
+
+  static const char *sh_chars_sh = "#;\"*?[]&|<>(){}$`^";
+  static const char *sh_cmds_sh[] =
+    { "cd", "eval", "exec", "exit", "login", "logout", "set", "umask", "wait",
+      "while", "for", "case", "if", ":", ".", "break", "continue", "export",
+      "read", "readonly", "shift", "times", "trap", "switch", "test", "command",
+#ifdef BATCH_MODE_ONLY_SHELL
+      "echo",
+#endif
+      0 };
+
+  const char *sh_chars;
+  const char **sh_cmds;
+#elif defined(__riscos__)
+  static const char *sh_chars = "";
+  static const char *sh_cmds[] = { 0 };
+#else  /* must be UNIX-ish */
+  static const char *sh_chars = "#;\"*?[]&|<>(){}$`^~!";
+  static const char *sh_cmds[] =
+    { ".", ":", "break", "case", "cd", "command", "continue", "eval", "exec",
+      "exit", "export", "for", "if", "login", "logout", "read", "readonly",
+      "set", "shift", "switch", "test", "times", "trap", "ulimit", "umask",
+      "unset", "wait", "while", 0 };
+
+# ifdef HAVE_DOS_PATHS
+  /* This is required if the MSYS/Cygwin ports (which do not define
+     WINDOWS32) are compiled with HAVE_DOS_PATHS defined, which uses
+     sh_chars_sh directly (see below).  The value must be identical
+     to that of sh_chars immediately above.  */
+  static const char *sh_chars_sh =  "#;\"*?[]&|<>(){}$`^~!";
+# endif  /* HAVE_DOS_PATHS */
+#endif
+  int i;
+  char *p;
+#ifndef NDEBUG
+  char *end;
+#endif
+  char *ap;
+  const char *cap;
+  const char *cp;
+  int instring, word_has_equals, seen_nonequals, last_argument_was_empty;
+  char **new_argv = 0;
+  char *argstr = 0;
+#ifdef WINDOWS32
+  int slow_flag = 0;
+
+  if (!unixy_shell)
+    {
+      sh_cmds = sh_cmds_dos;
+      sh_chars = sh_chars_dos;
+    }
+  else
+    {
+      sh_cmds = sh_cmds_sh;
+      sh_chars = sh_chars_sh;
+    }
+#endif /* WINDOWS32 */
+
+  if (restp != NULL)
+    *restp = NULL;
+
+  /* Make sure not to bother processing an empty line but stop at newline.  */
+  while (ISBLANK (*line))
+    ++line;
+  if (*line == '\0')
+    return 0;
+
+  if (shellflags == 0)
+    shellflags = posix_pedantic ? "-ec" : "-c";
+
+  /* See if it is safe to parse commands internally.  */
+  if (shell == 0)
+    shell = default_shell;
+#ifdef WINDOWS32
+  else if (strcmp (shell, default_shell))
+  {
+    char *s1 = _fullpath (NULL, shell, 0);
+    char *s2 = _fullpath (NULL, default_shell, 0);
+
+    slow_flag = strcmp ((s1 ? s1 : ""), (s2 ? s2 : ""));
+
+    free (s1);
+    free (s2);
+  }
+  if (slow_flag)
+    goto slow;
+#else  /* not WINDOWS32 */
+#if defined (__MSDOS__) || defined (__EMX__)
+  else if (strcasecmp (shell, default_shell))
+    {
+      extern int _is_unixy_shell (const char *_path);
+
+      DB (DB_BASIC, (_("$SHELL changed (was '%s', now '%s')\n"),
+                     default_shell, shell));
+      unixy_shell = _is_unixy_shell (shell);
+      /* we must allocate a copy of shell: construct_command_argv() will free
+       * shell after this function returns.  */
+      default_shell = xstrdup (shell);
+    }
+  if (unixy_shell)
+    {
+      sh_chars = sh_chars_sh;
+      sh_cmds  = sh_cmds_sh;
+    }
+  else
+    {
+      sh_chars = sh_chars_dos;
+      sh_cmds  = sh_cmds_dos;
+# ifdef __EMX__
+      if (_osmode == OS2_MODE)
+        {
+          sh_chars = sh_chars_os2;
+          sh_cmds = sh_cmds_os2;
+        }
+# endif
+    }
+#else  /* !__MSDOS__ */
+  else if (strcmp (shell, default_shell))
+    goto slow;
+#endif /* !__MSDOS__ && !__EMX__ */
+#endif /* not WINDOWS32 */
+
+  if (ifs)
+    for (cap = ifs; *cap != '\0'; ++cap)
+      if (*cap != ' ' && *cap != '\t' && *cap != '\n')
+        goto slow;
+
+  if (shellflags)
+    if (shellflags[0] != '-'
+        || ((shellflags[1] != 'c' || shellflags[2] != '\0')
+            && (shellflags[1] != 'e' || shellflags[2] != 'c' || shellflags[3] != '\0')))
+      goto slow;
+
+  i = strlen (line) + 1;
+
+  /* More than 1 arg per character is impossible.  */
+  new_argv = xmalloc (i * sizeof (char *));
+
+  /* All the args can fit in a buffer as big as LINE is.   */
+  ap = new_argv[0] = argstr = xmalloc (i);
+#ifndef NDEBUG
+  end = ap + i;
+#endif
+
+  /* I is how many complete arguments have been found.  */
+  i = 0;
+  instring = word_has_equals = seen_nonequals = last_argument_was_empty = 0;
+  for (p = line; *p != '\0'; ++p)
+    {
+      assert (ap <= end);
+
+      if (instring)
+        {
+          /* Inside a string, just copy any char except a closing quote
+             or a backslash-newline combination.  */
+          if (*p == instring)
+            {
+              instring = 0;
+              if (ap == new_argv[0] || *(ap-1) == '\0')
+                last_argument_was_empty = 1;
+            }
+          else if (*p == '\\' && p[1] == '\n')
+            {
+              /* Backslash-newline is handled differently depending on what
+                 kind of string we're in: inside single-quoted strings you
+                 keep them; in double-quoted strings they disappear.  For
+                 DOS/Windows/OS2, if we don't have a POSIX shell, we keep the
+                 pre-POSIX behavior of removing the backslash-newline.  */
+              if (instring == '"'
+#if defined (__MSDOS__) || defined (__EMX__) || defined (WINDOWS32)
+                  || !unixy_shell
+#endif
+                  )
+                ++p;
+              else
+                {
+                  *(ap++) = *(p++);
+                  *(ap++) = *p;
+                }
+            }
+          else if (*p == '\n' && restp != NULL)
+            {
+              /* End of the command line.  */
+              *restp = p;
+              goto end_of_line;
+            }
+          /* Backslash, $, and ` are special inside double quotes.
+             If we see any of those, punt.
+             But on MSDOS, if we use COMMAND.COM, double and single
+             quotes have the same effect.  */
+          else if (instring == '"' && strchr ("\\$`", *p) != 0 && unixy_shell)
+            goto slow;
+#ifdef WINDOWS32
+          /* Quoted wildcard characters must be passed quoted to the
+             command, so give up the fast route.  */
+          else if (instring == '"' && strchr ("*?", *p) != 0 && !unixy_shell)
+            goto slow;
+          else if (instring == '"' && strncmp (p, "\\\"", 2) == 0)
+            *ap++ = *++p;
+#endif
+          else
+            *ap++ = *p;
+        }
+      else if (strchr (sh_chars, *p) != 0)
+        /* Not inside a string, but it's a special char.  */
+        goto slow;
+      else if (one_shell && *p == '\n')
+        /* In .ONESHELL mode \n is a separator like ; or && */
+        goto slow;
+#ifdef  __MSDOS__
+      else if (*p == '.' && p[1] == '.' && p[2] == '.' && p[3] != '.')
+        /* '...' is a wildcard in DJGPP.  */
+        goto slow;
+#endif
+      else
+        /* Not a special char.  */
+        switch (*p)
+          {
+          case '=':
+            /* Equals is a special character in leading words before the
+               first word with no equals sign in it.  This is not the case
+               with sh -k, but we never get here when using nonstandard
+               shell flags.  */
+            if (! seen_nonequals && unixy_shell)
+              goto slow;
+            word_has_equals = 1;
+            *ap++ = '=';
+            break;
+
+          case '\\':
+            /* Backslash-newline has special case handling, ref POSIX.
+               We're in the fastpath, so emulate what the shell would do.  */
+            if (p[1] == '\n')
+              {
+                /* Throw out the backslash and newline.  */
+                ++p;
+
+                /* At the beginning of the argument, skip any whitespace other
+                   than newline before the start of the next word.  */
+                if (ap == new_argv[i])
+                  while (ISBLANK (p[1]))
+                    ++p;
+              }
+#ifdef WINDOWS32
+            /* Backslash before whitespace is not special if our shell
+               is not Unixy.  */
+            else if (ISSPACE (p[1]) && !unixy_shell)
+              {
+                *ap++ = *p;
+                break;
+              }
+#endif
+            else if (p[1] != '\0')
+              {
+#ifdef HAVE_DOS_PATHS
+                /* Only remove backslashes before characters special to Unixy
+                   shells.  All other backslashes are copied verbatim, since
+                   they are probably DOS-style directory separators.  This
+                   still leaves a small window for problems, but at least it
+                   should work for the vast majority of naive users.  */
+
+#ifdef __MSDOS__
+                /* A dot is only special as part of the "..."
+                   wildcard.  */
+                if (strneq (p + 1, ".\\.\\.", 5))
+                  {
+                    *ap++ = '.';
+                    *ap++ = '.';
+                    p += 4;
+                  }
+                else
+#endif
+                  if (p[1] != '\\' && p[1] != '\''
+                      && !ISSPACE (p[1])
+                      && strchr (sh_chars_sh, p[1]) == 0)
+                    /* back up one notch, to copy the backslash */
+                    --p;
+#endif  /* HAVE_DOS_PATHS */
+
+                /* Copy and skip the following char.  */
+                *ap++ = *++p;
+              }
+            break;
+
+          case '\'':
+          case '"':
+            instring = *p;
+            break;
+
+          case '\n':
+            if (restp != NULL)
+              {
+                /* End of the command line.  */
+                *restp = p;
+                goto end_of_line;
+              }
+            else
+              /* Newlines are not special.  */
+              *ap++ = '\n';
+            break;
+
+          case ' ':
+          case '\t':
+            /* We have the end of an argument.
+               Terminate the text of the argument.  */
+            *ap++ = '\0';
+            new_argv[++i] = ap;
+            last_argument_was_empty = 0;
+
+            /* Update SEEN_NONEQUALS, which tells us if every word
+               heretofore has contained an '='.  */
+            seen_nonequals |= ! word_has_equals;
+            if (word_has_equals && ! seen_nonequals)
+              /* An '=' in a word before the first
+                 word without one is magical.  */
+              goto slow;
+            word_has_equals = 0; /* Prepare for the next word.  */
+
+            /* If this argument is the command name,
+               see if it is a built-in shell command.
+               If so, have the shell handle it.  */
+            if (i == 1)
+              {
+                int j;
+                for (j = 0; sh_cmds[j] != 0; ++j)
+                  {
+                    if (streq (sh_cmds[j], new_argv[0]))
+                      goto slow;
+#if defined(__EMX__) || defined(WINDOWS32)
+                    /* Non-Unix shells are case insensitive.  */
+                    if (!unixy_shell
+                        && strcasecmp (sh_cmds[j], new_argv[0]) == 0)
+                      goto slow;
+#endif
+                  }
+              }
+
+            /* Skip whitespace chars, but not newlines.  */
+            while (ISBLANK (p[1]))
+              ++p;
+            break;
+
+          default:
+            *ap++ = *p;
+            break;
+          }
+    }
+ end_of_line:
+
+  if (instring)
+    /* Let the shell deal with an unterminated quote.  */
+    goto slow;
+
+  /* Terminate the last argument and the argument list.  */
+
+  *ap = '\0';
+  if (new_argv[i][0] != '\0' || last_argument_was_empty)
+    ++i;
+  new_argv[i] = 0;
+
+  if (i == 1)
+    {
+      int j;
+      for (j = 0; sh_cmds[j] != 0; ++j)
+        if (streq (sh_cmds[j], new_argv[0]))
+          goto slow;
+    }
+
+  if (new_argv[0] == 0)
+    {
+      /* Line was empty.  */
+      free (argstr);
+      free (new_argv);
+      return 0;
+    }
+
+  return new_argv;
+
+ slow:;
+  /* We must use the shell.  */
+
+  if (new_argv != 0)
+    {
+      /* Free the old argument list we were working on.  */
+      free (argstr);
+      free (new_argv);
+    }
+
+#ifdef __MSDOS__
+  execute_by_shell = 1; /* actually, call 'system' if shell isn't unixy */
+#endif
+
+#ifdef _AMIGA
+  {
+    char *ptr;
+    char *buffer;
+    char *dptr;
+
+    buffer = xmalloc (strlen (line)+1);
+
+    ptr = line;
+    for (dptr=buffer; *ptr; )
+    {
+      if (*ptr == '\\' && ptr[1] == '\n')
+        ptr += 2;
+      else if (*ptr == '@') /* Kludge: multiline commands */
+      {
+        ptr += 2;
+        *dptr++ = '\n';
+      }
+      else
+        *dptr++ = *ptr++;
+    }
+    *dptr = 0;
+
+    new_argv = xmalloc (2 * sizeof (char *));
+    new_argv[0] = buffer;
+    new_argv[1] = 0;
+  }
+#else   /* Not Amiga  */
+#ifdef WINDOWS32
+  /*
+   * Not eating this whitespace caused things like
+   *
+   *    sh -c "\n"
+   *
+   * which gave the shell fits. I think we have to eat
+   * whitespace here, but this code should be considered
+   * suspicious if things start failing....
+   */
+
+  /* Make sure not to bother processing an empty line.  */
+  NEXT_TOKEN (line);
+  if (*line == '\0')
+    return 0;
+#endif /* WINDOWS32 */
+
+  {
+    /* SHELL may be a multi-word command.  Construct a command line
+       "$(SHELL) $(.SHELLFLAGS) LINE", with all special chars in LINE escaped.
+       Then recurse, expanding this command line to get the final
+       argument list.  */
+
+    char *new_line;
+    unsigned int shell_len = strlen (shell);
+    unsigned int line_len = strlen (line);
+    unsigned int sflags_len = shellflags ? strlen (shellflags) : 0;
+#ifdef WINDOWS32
+    char *command_ptr = NULL; /* used for batch_mode_shell mode */
+#endif
+
+# ifdef __EMX__ /* is this necessary? */
+    if (!unixy_shell && shellflags)
+      shellflags[0] = '/'; /* "/c" */
+# endif
+
+    /* In .ONESHELL mode we are allowed to throw the entire current
+        recipe string at a single shell and trust that the user
+        has configured the shell and shell flags, and formatted
+        the string, appropriately. */
+    if (one_shell)
+      {
+        /* If the shell is Bourne compatible, we must remove and ignore
+           interior special chars [@+-] because they're meaningless to
+           the shell itself. If, however, we're in .ONESHELL mode and
+           have changed SHELL to something non-standard, we should
+           leave those alone because they could be part of the
+           script. In this case we must also leave in place
+           any leading [@+-] for the same reason.  */
+
+        /* Remove and ignore interior prefix chars [@+-] because they're
+             meaningless given a single shell. */
+#if defined __MSDOS__ || defined (__EMX__)
+        if (unixy_shell)     /* the test is complicated and we already did it */
+#else
+        if (is_bourne_compatible_shell (shell)
+#ifdef WINDOWS32
+            /* If we didn't find any sh.exe, don't behave is if we did!  */
+            && !no_default_sh_exe
+#endif
+            )
+#endif
+          {
+            const char *f = line;
+            char *t = line;
+
+            /* Copy the recipe, removing and ignoring interior prefix chars
+               [@+-]: they're meaningless in .ONESHELL mode.  */
+            while (f[0] != '\0')
+              {
+                int esc = 0;
+
+                /* This is the start of a new recipe line.  Skip whitespace
+                   and prefix characters but not newlines.  */
+                while (ISBLANK (*f) || *f == '-' || *f == '@' || *f == '+')
+                  ++f;
+
+                /* Copy until we get to the next logical recipe line.  */
+                while (*f != '\0')
+                  {
+                    *(t++) = *(f++);
+                    if (f[-1] == '\\')
+                      esc = !esc;
+                    else
+                      {
+                        /* On unescaped newline, we're done with this line.  */
+                        if (f[-1] == '\n' && ! esc)
+                          break;
+
+                        /* Something else: reset the escape sequence.  */
+                        esc = 0;
+                      }
+                  }
+              }
+            *t = '\0';
+          }
+#ifdef WINDOWS32
+        else    /* non-Posix shell (cmd.exe etc.) */
+          {
+            const char *f = line;
+            char *t = line;
+            char *tstart = t;
+            int temp_fd;
+            FILE* batch = NULL;
+            int id = GetCurrentProcessId ();
+            PATH_VAR(fbuf);
+
+            /* Generate a file name for the temporary batch file.  */
+            sprintf (fbuf, "make%d", id);
+            *batch_filename = create_batch_file (fbuf, 0, &temp_fd);
+            DB (DB_JOBS, (_("Creating temporary batch file %s\n"),
+                          *batch_filename));
+
+            /* Create a FILE object for the batch file, and write to it the
+               commands to be executed.  Put the batch file in TEXT mode.  */
+            _setmode (temp_fd, _O_TEXT);
+            batch = _fdopen (temp_fd, "wt");
+            fputs ("@echo off\n", batch);
+            DB (DB_JOBS, (_("Batch file contents:\n\t@echo off\n")));
+
+            /* Copy the recipe, removing and ignoring interior prefix chars
+               [@+-]: they're meaningless in .ONESHELL mode.  */
+            while (*f != '\0')
+              {
+                /* This is the start of a new recipe line.  Skip whitespace
+                   and prefix characters but not newlines.  */
+                while (ISBLANK (*f) || *f == '-' || *f == '@' || *f == '+')
+                  ++f;
+
+                /* Copy until we get to the next logical recipe line.  */
+                while (*f != '\0')
+                  {
+                    /* Remove the escaped newlines in the command, and the
+                       blanks that follow them.  Windows shells cannot handle
+                       escaped newlines.  */
+                    if (*f == '\\' && f[1] == '\n')
+                      {
+                        f += 2;
+                        while (ISBLANK (*f))
+                          ++f;
+                      }
+                    *(t++) = *(f++);
+                    /* On an unescaped newline, we're done with this
+                       line.  */
+                    if (f[-1] == '\n')
+                      break;
+                  }
+                /* Write another line into the batch file.  */
+                if (t > tstart)
+                  {
+                    char c = *t;
+                    *t = '\0';
+                    fputs (tstart, batch);
+                    DB (DB_JOBS, ("\t%s", tstart));
+                    tstart = t;
+                    *t = c;
+                  }
+              }
+            DB (DB_JOBS, ("\n"));
+            fclose (batch);
+
+            /* Create an argv list for the shell command line that
+               will run the batch file.  */
+            new_argv = xmalloc (2 * sizeof (char *));
+            new_argv[0] = xstrdup (*batch_filename);
+            new_argv[1] = NULL;
+            return new_argv;
+          }
+#endif /* WINDOWS32 */
+        /* Create an argv list for the shell command line.  */
+        {
+          int n = 0;
+
+          new_argv = xmalloc ((4 + sflags_len/2) * sizeof (char *));
+          new_argv[n++] = xstrdup (shell);
+
+          /* Chop up the shellflags (if any) and assign them.  */
+          if (! shellflags)
+            new_argv[n++] = xstrdup ("");
+          else
+            {
+              const char *s = shellflags;
+              char *t;
+              unsigned int len;
+              while ((t = find_next_token (&s, &len)) != 0)
+                new_argv[n++] = xstrndup (t, len);
+            }
+
+          /* Set the command to invoke.  */
+          new_argv[n++] = line;
+          new_argv[n++] = NULL;
+        }
+        return new_argv;
+      }
+
+    new_line = xmalloc ((shell_len*2) + 1 + sflags_len + 1
+                        + (line_len*2) + 1);
+    ap = new_line;
+    /* Copy SHELL, escaping any characters special to the shell.  If
+       we don't escape them, construct_command_argv_internal will
+       recursively call itself ad nauseam, or until stack overflow,
+       whichever happens first.  */
+    for (cp = shell; *cp != '\0'; ++cp)
+      {
+        if (strchr (sh_chars, *cp) != 0)
+          *(ap++) = '\\';
+        *(ap++) = *cp;
+      }
+    *(ap++) = ' ';
+    if (shellflags)
+      memcpy (ap, shellflags, sflags_len);
+    ap += sflags_len;
+    *(ap++) = ' ';
+#ifdef WINDOWS32
+    command_ptr = ap;
+#endif
+    for (p = line; *p != '\0'; ++p)
+      {
+        if (restp != NULL && *p == '\n')
+          {
+            *restp = p;
+            break;
+          }
+        else if (*p == '\\' && p[1] == '\n')
+          {
+            /* POSIX says we keep the backslash-newline.  If we don't have a
+               POSIX shell on DOS/Windows/OS2, mimic the pre-POSIX behavior
+               and remove the backslash/newline.  */
+#if defined (__MSDOS__) || defined (__EMX__) || defined (WINDOWS32)
+# define PRESERVE_BSNL  unixy_shell
+#else
+# define PRESERVE_BSNL  1
+#endif
+            if (PRESERVE_BSNL)
+              {
+                *(ap++) = '\\';
+                /* Only non-batch execution needs another backslash,
+                   because it will be passed through a recursive
+                   invocation of this function.  */
+                if (!batch_mode_shell)
+                  *(ap++) = '\\';
+                *(ap++) = '\n';
+              }
+            ++p;
+            continue;
+          }
+
+        /* DOS shells don't know about backslash-escaping.  */
+        if (unixy_shell && !batch_mode_shell &&
+            (*p == '\\' || *p == '\'' || *p == '"'
+             || ISSPACE (*p)
+             || strchr (sh_chars, *p) != 0))
+          *ap++ = '\\';
+#ifdef __MSDOS__
+        else if (unixy_shell && strneq (p, "...", 3))
+          {
+            /* The case of '...' wildcard again.  */
+            strcpy (ap, "\\.\\.\\");
+            ap += 5;
+            p  += 2;
+          }
+#endif
+        *ap++ = *p;
+      }
+    if (ap == new_line + shell_len + sflags_len + 2)
+      {
+        /* Line was empty.  */
+        free (new_line);
+        return 0;
+      }
+    *ap = '\0';
+
+#ifdef WINDOWS32
+    /* Some shells do not work well when invoked as 'sh -c xxx' to run a
+       command line (e.g. Cygnus GNUWIN32 sh.exe on WIN32 systems).  In these
+       cases, run commands via a script file.  */
+    if (just_print_flag && !(flags & COMMANDS_RECURSE))
+      {
+        /* Need to allocate new_argv, although it's unused, because
+           start_job_command will want to free it and its 0'th element.  */
+        new_argv = xmalloc (2 * sizeof (char *));
+        new_argv[0] = xstrdup ("");
+        new_argv[1] = NULL;
+      }
+    else if ((no_default_sh_exe || batch_mode_shell) && batch_filename)
+      {
+        int temp_fd;
+        FILE* batch = NULL;
+        int id = GetCurrentProcessId ();
+        PATH_VAR (fbuf);
+
+        /* create a file name */
+        sprintf (fbuf, "make%d", id);
+        *batch_filename = create_batch_file (fbuf, unixy_shell, &temp_fd);
+
+        DB (DB_JOBS, (_("Creating temporary batch file %s\n"),
+                      *batch_filename));
+
+        /* Create a FILE object for the batch file, and write to it the
+           commands to be executed.  Put the batch file in TEXT mode.  */
+        _setmode (temp_fd, _O_TEXT);
+        batch = _fdopen (temp_fd, "wt");
+        if (!unixy_shell)
+          fputs ("@echo off\n", batch);
+        fputs (command_ptr, batch);
+        fputc ('\n', batch);
+        fclose (batch);
+        DB (DB_JOBS, (_("Batch file contents:%s\n\t%s\n"),
+                      !unixy_shell ? "\n\t@echo off" : "", command_ptr));
+
+        /* create argv */
+        new_argv = xmalloc (3 * sizeof (char *));
+        if (unixy_shell)
+          {
+            new_argv[0] = xstrdup (shell);
+            new_argv[1] = *batch_filename; /* only argv[0] gets freed later */
+          }
+        else
+          {
+            new_argv[0] = xstrdup (*batch_filename);
+            new_argv[1] = NULL;
+          }
+        new_argv[2] = NULL;
+      }
+    else
+#endif /* WINDOWS32 */
+
+    if (unixy_shell)
+      new_argv = construct_command_argv_internal (new_line, 0, 0, 0, 0,
+                                                  flags, 0);
+
+#ifdef __EMX__
+    else if (!unixy_shell)
+      {
+        /* new_line is local, must not be freed therefore
+           We use line here instead of new_line because we run the shell
+           manually.  */
+        size_t line_len = strlen (line);
+        char *p = new_line;
+        char *q = new_line;
+        memcpy (new_line, line, line_len + 1);
+        /* Replace all backslash-newline combination and also following tabs.
+           Important: stop at the first '\n' because that's what the loop above
+           did. The next line starting at restp[0] will be executed during the
+           next call of this function. */
+        while (*q != '\0' && *q != '\n')
+          {
+            if (q[0] == '\\' && q[1] == '\n')
+              q += 2; /* remove '\\' and '\n' */
+            else
+              *p++ = *q++;
+          }
+        *p = '\0';
+
+# ifndef NO_CMD_DEFAULT
+        if (strnicmp (new_line, "echo", 4) == 0
+            && (new_line[4] == ' ' || new_line[4] == '\t'))
+          {
+            /* the builtin echo command: handle it separately */
+            size_t echo_len = line_len - 5;
+            char *echo_line = new_line + 5;
+
+            /* special case: echo 'x="y"'
+               cmd works this way: a string is printed as is, i.e., no quotes
+               are removed. But autoconf uses a command like echo 'x="y"' to
+               determine whether make works. autoconf expects the output x="y"
+               so we will do exactly that.
+               Note: if we do not allow cmd to be the default shell
+               we do not need this kind of voodoo */
+            if (echo_line[0] == '\''
+                && echo_line[echo_len - 1] == '\''
+                && strncmp (echo_line + 1, "ac_maketemp=",
+                            strlen ("ac_maketemp=")) == 0)
+              {
+                /* remove the enclosing quotes */
+                memmove (echo_line, echo_line + 1, echo_len - 2);
+                echo_line[echo_len - 2] = '\0';
+              }
+          }
+# endif
+
+        {
+          /* Let the shell decide what to do. Put the command line into the
+             2nd command line argument and hope for the best ;-)  */
+          size_t sh_len = strlen (shell);
+
+          /* exactly 3 arguments + NULL */
+          new_argv = xmalloc (4 * sizeof (char *));
+          /* Exactly strlen(shell) + strlen("/c") + strlen(line) + 3 times
+             the trailing '\0' */
+          new_argv[0] = xmalloc (sh_len + line_len + 5);
+          memcpy (new_argv[0], shell, sh_len + 1);
+          new_argv[1] = new_argv[0] + sh_len + 1;
+          memcpy (new_argv[1], "/c", 3);
+          new_argv[2] = new_argv[1] + 3;
+          memcpy (new_argv[2], new_line, line_len + 1);
+          new_argv[3] = NULL;
+        }
+      }
+#elif defined(__MSDOS__)
+    else
+      {
+        /* With MSDOS shells, we must construct the command line here
+           instead of recursively calling ourselves, because we
+           cannot backslash-escape the special characters (see above).  */
+        new_argv = xmalloc (sizeof (char *));
+        line_len = strlen (new_line) - shell_len - sflags_len - 2;
+        new_argv[0] = xmalloc (line_len + 1);
+        strncpy (new_argv[0],
+                 new_line + shell_len + sflags_len + 2, line_len);
+        new_argv[0][line_len] = '\0';
+      }
+#else
+    else
+      fatal (NILF, CSTRLEN (__FILE__) + INTSTR_LENGTH,
+             _("%s (line %d) Bad shell context (!unixy && !batch_mode_shell)\n"),
+            __FILE__, __LINE__);
+#endif
+
+    free (new_line);
+  }
+#endif  /* ! AMIGA */
+
+  return new_argv;
+}
+#endif /* !VMS */
+
+/* Figure out the argument list necessary to run LINE as a command.  Try to
+   avoid using a shell.  This routine handles only ' quoting, and " quoting
+   when no backslash, $ or ' characters are seen in the quotes.  Starting
+   quotes may be escaped with a backslash.  If any of the characters in
+   sh_chars is seen, or any of the builtin commands listed in sh_cmds
+   is the first word of a line, the shell is used.
+
+   If RESTP is not NULL, *RESTP is set to point to the first newline in LINE.
+   If *RESTP is NULL, newlines will be ignored.
+
+   FILE is the target whose commands these are.  It is used for
+   variable expansion for $(SHELL) and $(IFS).  */
+
+char **
+construct_command_argv (char *line, char **restp, struct file *file,
+                        int cmd_flags, char **batch_filename)
+{
+  char *shell, *ifs, *shellflags;
+  char **argv;
+
+#ifdef VMS
+  char *cptr;
+  int argc;
+
+  argc = 0;
+  cptr = line;
+  for (;;)
+    {
+      while ((*cptr != 0) && (ISSPACE (*cptr)))
+        cptr++;
+      if (*cptr == 0)
+        break;
+      while ((*cptr != 0) && (!ISSPACE (*cptr)))
+        cptr++;
+      argc++;
+    }
+
+  argv = xmalloc (argc * sizeof (char *));
+  if (argv == 0)
+    abort ();
+
+  cptr = line;
+  argc = 0;
+  for (;;)
+    {
+      while ((*cptr != 0) && (ISSPACE (*cptr)))
+        cptr++;
+      if (*cptr == 0)
+        break;
+      DB (DB_JOBS, ("argv[%d] = [%s]\n", argc, cptr));
+      argv[argc++] = cptr;
+      while ((*cptr != 0) && (!ISSPACE (*cptr)))
+        cptr++;
+      if (*cptr != 0)
+        *cptr++ = 0;
+    }
+#else
+  {
+    /* Turn off --warn-undefined-variables while we expand SHELL and IFS.  */
+    int save = warn_undefined_variables_flag;
+    warn_undefined_variables_flag = 0;
+
+    shell = allocated_variable_expand_for_file ("$(SHELL)", file);
+#ifdef WINDOWS32
+    /*
+     * Convert to forward slashes so that construct_command_argv_internal()
+     * is not confused.
+     */
+    if (shell)
+      {
+        char *p = w32ify (shell, 0);
+        strcpy (shell, p);
+      }
+#endif
+#ifdef __EMX__
+    {
+      static const char *unixroot = NULL;
+      static const char *last_shell = "";
+      static int init = 0;
+      if (init == 0)
+        {
+          unixroot = getenv ("UNIXROOT");
+          /* unixroot must be NULL or not empty */
+          if (unixroot && unixroot[0] == '\0') unixroot = NULL;
+          init = 1;
+        }
+
+      /* if we have an unixroot drive and if shell is not default_shell
+         (which means it's either cmd.exe or the test has already been
+         performed) and if shell is an absolute path without drive letter,
+         try whether it exists e.g.: if "/bin/sh" does not exist use
+         "$UNIXROOT/bin/sh" instead.  */
+      if (unixroot && shell && strcmp (shell, last_shell) != 0
+          && (shell[0] == '/' || shell[0] == '\\'))
+        {
+          /* trying a new shell, check whether it exists */
+          size_t size = strlen (shell);
+          char *buf = xmalloc (size + 7);
+          memcpy (buf, shell, size);
+          memcpy (buf + size, ".exe", 5); /* including the trailing '\0' */
+          if (access (shell, F_OK) != 0 && access (buf, F_OK) != 0)
+            {
+              /* try the same for the unixroot drive */
+              memmove (buf + 2, buf, size + 5);
+              buf[0] = unixroot[0];
+              buf[1] = unixroot[1];
+              if (access (buf, F_OK) == 0)
+                /* we have found a shell! */
+                /* free(shell); */
+                shell = buf;
+              else
+                free (buf);
+            }
+          else
+            free (buf);
+        }
+    }
+#endif /* __EMX__ */
+
+    shellflags = allocated_variable_expand_for_file ("$(.SHELLFLAGS)", file);
+    ifs = allocated_variable_expand_for_file ("$(IFS)", file);
+
+    warn_undefined_variables_flag = save;
+  }
+
+  argv = construct_command_argv_internal (line, restp, shell, shellflags, ifs,
+                                          cmd_flags, batch_filename);
+
+  free (shell);
+  free (shellflags);
+  free (ifs);
+#endif /* !VMS */
+  return argv;
+}
+
+#if !defined(HAVE_DUP2) && !defined(_AMIGA)
+int
+dup2 (int old, int new)
+{
+  int fd;
+
+  (void) close (new);
+  EINTRLOOP (fd, dup (old));
+  if (fd != new)
+    {
+      (void) close (fd);
+      errno = EMFILE;
+      return -1;
+    }
+
+  return fd;
+}
+#endif /* !HAVE_DUP2 && !_AMIGA */
+
+/* On VMS systems, include special VMS functions.  */
+
+#ifdef VMS
+#include "vmsjobs.c"
+#endif
diff --git a/src/job.h b/src/job.h
new file mode 100644
index 0000000..0b7730b
--- /dev/null
+++ b/src/job.h
@@ -0,0 +1,79 @@
+/* Definitions for managing subprocesses in GNU Make.
+Copyright (C) 1992-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "output.h"
+
+/* Structure describing a running or dead child process.  */
+
+struct child
+  {
+    struct child *next;         /* Link in the chain.  */
+
+    struct file *file;          /* File being remade.  */
+
+    char **environment;         /* Environment for commands.  */
+    char *sh_batch_file;        /* Script file for shell commands */
+    char **command_lines;       /* Array of variable-expanded cmd lines.  */
+    char *command_ptr;          /* Ptr into command_lines[command_line].  */
+
+#ifdef VMS
+    char *comname;              /* Temporary command file name */
+    int efn;                    /* Completion event flag number */
+    int cstatus;                /* Completion status */
+    int vms_launch_status;      /* non-zero if lib$spawn, etc failed */
+#endif
+
+    unsigned int  command_line; /* Index into command_lines.  */
+    struct output output;       /* Output for this child.  */
+    pid_t         pid;          /* Child process's ID number.  */
+    unsigned int  remote:1;     /* Nonzero if executing remotely.  */
+    unsigned int  noerror:1;    /* Nonzero if commands contained a '-'.  */
+    unsigned int  good_stdin:1; /* Nonzero if this child has a good stdin.  */
+    unsigned int  deleted:1;    /* Nonzero if targets have been deleted.  */
+    unsigned int  recursive:1;  /* Nonzero for recursive command ('+' etc.)  */
+    unsigned int  dontcare:1;   /* Saved dontcare flag.  */
+  };
+
+extern struct child *children;
+
+/* A signal handler for SIGCHLD, if needed.  */
+RETSIGTYPE child_handler (int sig);
+int is_bourne_compatible_shell(const char *path);
+void new_job (struct file *file);
+void reap_children (int block, int err);
+void start_waiting_jobs (void);
+
+char **construct_command_argv (char *line, char **restp, struct file *file,
+                               int cmd_flags, char** batch_file);
+
+#ifdef VMS
+int child_execute_job (struct child *child, char *argv);
+#else
+int child_execute_job (struct output *out, int good_stdin, char **argv, char **envp);
+#endif
+
+#ifdef _AMIGA
+void exec_command (char **argv) __attribute__ ((noreturn));
+#elif defined(__EMX__)
+int exec_command (char **argv, char **envp);
+#else
+void exec_command (char **argv, char **envp) __attribute__ ((noreturn));
+#endif
+
+void unblock_all_sigs (void);
+
+extern unsigned int job_slots_used;
+extern unsigned int jobserver_tokens;
diff --git a/src/load.c b/src/load.c
new file mode 100644
index 0000000..814764d
--- /dev/null
+++ b/src/load.c
@@ -0,0 +1,267 @@
+/* Loading dynamic objects for GNU Make.
+Copyright (C) 2012-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+
+#if MAKE_LOAD
+
+#include <string.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <dlfcn.h>
+#include <errno.h>
+
+#define SYMBOL_EXTENSION        "_gmk_setup"
+
+#include "debug.h"
+#include "filedef.h"
+#include "variable.h"
+
+/* Tru64 V4.0 does not have this flag */
+#ifndef RTLD_GLOBAL
+# define RTLD_GLOBAL 0
+#endif
+
+struct load_list
+  {
+    struct load_list *next;
+    const char *name;
+    void *dlp;
+  };
+
+static struct load_list *loaded_syms = NULL;
+
+static load_func_t
+load_object (const floc *flocp, int noerror, const char *ldname,
+             const char *symname)
+{
+  static void *global_dl = NULL;
+  load_func_t symp;
+
+  if (! global_dl)
+    {
+      global_dl = dlopen (NULL, RTLD_NOW|RTLD_GLOBAL);
+      if (! global_dl)
+        {
+          const char *err = dlerror ();
+          OS (fatal, flocp, _("Failed to open global symbol table: %s"), err);
+        }
+    }
+
+  symp = (load_func_t) dlsym (global_dl, symname);
+  if (! symp)
+    {
+      struct load_list *new;
+      void *dlp = NULL;
+
+    /* If the path has no "/", try the current directory first.  */
+      if (! strchr (ldname, '/')
+#ifdef HAVE_DOS_PATHS
+          && ! strchr (ldname, '\\')
+#endif
+         )
+        dlp = dlopen (concat (2, "./", ldname), RTLD_LAZY|RTLD_GLOBAL);
+
+      /* If we haven't opened it yet, try the default search path.  */
+      if (! dlp)
+        dlp = dlopen (ldname, RTLD_LAZY|RTLD_GLOBAL);
+
+      /* Still no?  Then fail.  */
+      if (! dlp)
+        {
+          const char *err = dlerror ();
+          if (noerror)
+            DB (DB_BASIC, ("%s", err));
+          else
+            OS (error, flocp, "%s", err);
+          return NULL;
+        }
+
+      /* Assert that the GPL license symbol is defined.  */
+      symp = (load_func_t) dlsym (dlp, "plugin_is_GPL_compatible");
+      if (! symp)
+        OS (fatal, flocp,
+             _("Loaded object %s is not declared to be GPL compatible"),
+             ldname);
+
+      symp = (load_func_t) dlsym (dlp, symname);
+      if (! symp)
+        {
+          const char *err = dlerror ();
+          OSSS (fatal, flocp, _("Failed to load symbol %s from %s: %s"),
+                symname, ldname, err);
+        }
+
+      /* Add this symbol to a trivial lookup table.  This is not efficient but
+         it's highly unlikely we'll be loading lots of objects, and we only
+         need it to look them up on unload, if we rebuild them.  */
+      new = xmalloc (sizeof (struct load_list));
+      new->name = xstrdup (ldname);
+      new->dlp = dlp;
+      new->next = loaded_syms;
+      loaded_syms = new;
+    }
+
+  return symp;
+}
+
+int
+load_file (const floc *flocp, const char **ldname, int noerror)
+{
+  int nmlen = strlen (*ldname);
+  char *new = alloca (nmlen + CSTRLEN (SYMBOL_EXTENSION) + 1);
+  char *symname = NULL;
+  char *loaded;
+  const char *fp;
+  int r;
+  load_func_t symp;
+
+  /* Break the input into an object file name and a symbol name.  If no symbol
+     name was provided, compute one from the object file name.  */
+  fp = strchr (*ldname, '(');
+  if (fp)
+    {
+      const char *ep;
+
+      /* There's an open paren, so see if there's a close paren: if so use
+         that as the symbol name.  We can't have whitespace: it would have
+         been chopped up before this function is called.  */
+      ep = strchr (fp+1, ')');
+      if (ep && ep[1] == '\0')
+        {
+          int l = fp - *ldname;;
+
+          ++fp;
+          if (fp == ep)
+            OS (fatal, flocp, _("Empty symbol name for load: %s"), *ldname);
+
+          /* Make a copy of the ldname part.  */
+          memcpy (new, *ldname, l);
+          new[l] = '\0';
+          *ldname = new;
+          nmlen = l;
+
+          /* Make a copy of the symbol name part.  */
+          symname = new + l + 1;
+          memcpy (symname, fp, ep - fp);
+          symname[ep - fp] = '\0';
+        }
+    }
+
+  /* Add this name to the string cache so it can be reused later.  */
+  *ldname = strcache_add (*ldname);
+
+  /* If this object has been loaded, we're done.  */
+  loaded = allocated_variable_expand ("$(.LOADED)");
+  fp = strstr (loaded, *ldname);
+  r = fp && (fp==loaded || fp[-1]==' ') && (fp[nmlen]=='\0' || fp[nmlen]==' ');
+  if (r)
+    goto exit;
+
+  /* If we didn't find a symbol name yet, construct it from the ldname.  */
+  if (! symname)
+    {
+      char *p = new;
+
+      fp = strrchr (*ldname, '/');
+#ifdef HAVE_DOS_PATHS
+      if (fp)
+        {
+          const char *fp2 = strchr (fp, '\\');
+
+          if (fp2 > fp)
+            fp = fp2;
+        }
+      else
+        fp = strrchr (*ldname, '\\');
+      /* The (improbable) case of d:foo.  */
+      if (fp && *fp && fp[1] == ':')
+        fp++;
+#endif
+      if (!fp)
+        fp = *ldname;
+      else
+        ++fp;
+      while (isalnum (*fp) || *fp == '_')
+        *(p++) = *(fp++);
+      strcpy (p, SYMBOL_EXTENSION);
+      symname = new;
+    }
+
+  DB (DB_VERBOSE, (_("Loading symbol %s from %s\n"), symname, *ldname));
+
+  /* Load it!  */
+  symp = load_object (flocp, noerror, *ldname, symname);
+  if (! symp)
+    return 0;
+
+  /* Invoke the symbol.  */
+  r = (*symp) (flocp);
+
+  /* If it succeeded, add the load file to the loaded variable.  */
+  if (r > 0)
+    {
+      size_t loadlen = strlen (loaded);
+      char *newval = alloca (loadlen + strlen (*ldname) + 2);
+      /* Don't add a space if it's empty.  */
+      if (loadlen)
+        {
+          memcpy (newval, loaded, loadlen);
+          newval[loadlen++] = ' ';
+        }
+      strcpy (&newval[loadlen], *ldname);
+      do_variable_definition (flocp, ".LOADED", newval, o_default, f_simple, 0);
+    }
+
+ exit:
+  free (loaded);
+  return r;
+}
+
+void
+unload_file (const char *name)
+{
+  struct load_list *d;
+
+  for (d = loaded_syms; d != NULL; d = d->next)
+    if (streq (d->name, name) && d->dlp)
+      {
+        if (dlclose (d->dlp))
+          perror_with_name ("dlclose", d->name);
+        d->dlp = NULL;
+        break;
+      }
+}
+
+#else
+
+int
+load_file (const floc *flocp, const char **ldname UNUSED, int noerror)
+{
+  if (! noerror)
+    O (fatal, flocp,
+       _("The 'load' operation is not supported on this platform."));
+
+  return 0;
+}
+
+void
+unload_file (const char *name UNUSED)
+{
+  O (fatal, NILF, "INTERNAL: Cannot unload when load is not supported!");
+}
+
+#endif  /* MAKE_LOAD */
diff --git a/src/loadapi.c b/src/loadapi.c
new file mode 100644
index 0000000..db61e77
--- /dev/null
+++ b/src/loadapi.c
@@ -0,0 +1,82 @@
+/* API for GNU Make dynamic objects.
+Copyright (C) 2013-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+
+#include "filedef.h"
+#include "variable.h"
+#include "dep.h"
+
+/* Allocate a buffer in our context, so we can free it.  */
+char *
+gmk_alloc (unsigned int len)
+{
+  return xmalloc (len);
+}
+
+/* Free a buffer returned by gmk_expand().  */
+void
+gmk_free (char *s)
+{
+  free (s);
+}
+
+/* Evaluate a buffer as make syntax.
+   Ideally eval_buffer() will take const char *, but not yet.  */
+void
+gmk_eval (const char *buffer, const gmk_floc *gfloc)
+{
+  /* Preserve existing variable buffer context.  */
+  char *pbuf;
+  unsigned int plen;
+  char *s;
+  floc fl;
+  floc *flp;
+
+  if (gfloc)
+    {
+      fl.filenm = gfloc->filenm;
+      fl.lineno = gfloc->lineno;
+      fl.offset = 0;
+      flp = &fl;
+    }
+  else
+    flp = NULL;
+
+  install_variable_buffer (&pbuf, &plen);
+
+  s = xstrdup (buffer);
+  eval_buffer (s, flp);
+  free (s);
+
+  restore_variable_buffer (pbuf, plen);
+}
+
+/* Expand a string and return an allocated buffer.
+   Caller must call gmk_free() with this buffer.  */
+char *
+gmk_expand (const char *ref)
+{
+  return allocated_variable_expand (ref);
+}
+
+/* Register a function to be called from makefiles.  */
+void
+gmk_add_function (const char *name, gmk_func_ptr func,
+                  unsigned int min, unsigned int max, unsigned int flags)
+{
+  define_new_function (reading_file, name, min, max, flags, func);
+}
diff --git a/src/main.c b/src/main.c
new file mode 100644
index 0000000..9fa2c84
--- /dev/null
+++ b/src/main.c
@@ -0,0 +1,3503 @@
+/* Argument parsing and main program of GNU Make.
+Copyright (C) 1988-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+#include "os.h"
+#include "filedef.h"
+#include "dep.h"
+#include "variable.h"
+#include "job.h"
+#include "commands.h"
+#include "rule.h"
+#include "debug.h"
+#include "getopt.h"
+
+#include <assert.h>
+#ifdef _AMIGA
+# include <dos/dos.h>
+# include <proto/dos.h>
+#endif
+#ifdef WINDOWS32
+# include <windows.h>
+# include <io.h>
+#ifdef HAVE_STRINGS_H
+# include <strings.h>	/* for strcasecmp */
+#endif
+# include "pathstuff.h"
+# include "sub_proc.h"
+# include "w32err.h"
+#endif
+#ifdef __EMX__
+# include <sys/types.h>
+# include <sys/wait.h>
+#endif
+#ifdef HAVE_FCNTL_H
+# include <fcntl.h>
+#endif
+
+#ifdef _AMIGA
+int __stack = 20000; /* Make sure we have 20K of stack space */
+#endif
+#ifdef VMS
+int vms_use_mcr_command = 0;
+int vms_always_use_cmd_file = 0;
+int vms_gnv_shell = 0;
+int vms_legacy_behavior = 0;
+int vms_comma_separator = 0;
+int vms_unix_simulation = 0;
+int vms_report_unix_paths = 0;
+
+/* Evaluates if a VMS environment option is set, only look at first character */
+static int
+get_vms_env_flag (const char *name, int default_value)
+{
+char * value;
+char x;
+
+  value = getenv (name);
+  if (value == NULL)
+    return default_value;
+
+  x = toupper (value[0]);
+  switch (x)
+    {
+    case '1':
+    case 'T':
+    case 'E':
+      return 1;
+      break;
+    case '0':
+    case 'F':
+    case 'D':
+      return 0;
+    }
+}
+#endif
+
+#if defined HAVE_WAITPID || defined HAVE_WAIT3
+# define HAVE_WAIT_NOHANG
+#endif
+
+#ifndef HAVE_UNISTD_H
+int chdir ();
+#endif
+#ifndef STDC_HEADERS
+# ifndef sun                    /* Sun has an incorrect decl in a header.  */
+void exit (int) __attribute__ ((noreturn));
+# endif
+double atof ();
+#endif
+
+static void clean_jobserver (int status);
+static void print_data_base (void);
+static void print_version (void);
+static void decode_switches (int argc, const char **argv, int env);
+static void decode_env_switches (const char *envar, unsigned int len);
+static struct variable *define_makeflags (int all, int makefile);
+static char *quote_for_env (char *out, const char *in);
+static void initialize_global_hash_tables (void);
+
+
+/* The structure that describes an accepted command switch.  */
+
+struct command_switch
+  {
+    int c;                      /* The switch character.  */
+
+    enum                        /* Type of the value.  */
+      {
+        flag,                   /* Turn int flag on.  */
+        flag_off,               /* Turn int flag off.  */
+        string,                 /* One string per invocation.  */
+        strlist,                /* One string per switch.  */
+        filename,               /* A string containing a file name.  */
+        positive_int,           /* A positive integer.  */
+        floating,               /* A floating-point number (double).  */
+        ignore                  /* Ignored.  */
+      } type;
+
+    void *value_ptr;    /* Pointer to the value-holding variable.  */
+
+    unsigned int env:1;         /* Can come from MAKEFLAGS.  */
+    unsigned int toenv:1;       /* Should be put in MAKEFLAGS.  */
+    unsigned int no_makefile:1; /* Don't propagate when remaking makefiles.  */
+
+    const void *noarg_value;    /* Pointer to value used if no arg given.  */
+    const void *default_value;  /* Pointer to default value.  */
+
+    const char *long_name;      /* Long option name.  */
+  };
+
+/* True if C is a switch value that corresponds to a short option.  */
+
+#define short_option(c) ((c) <= CHAR_MAX)
+
+/* The structure used to hold the list of strings given
+   in command switches of a type that takes strlist arguments.  */
+
+struct stringlist
+  {
+    const char **list;  /* Nil-terminated list of strings.  */
+    unsigned int idx;   /* Index into above.  */
+    unsigned int max;   /* Number of pointers allocated.  */
+  };
+
+
+/* The recognized command switches.  */
+
+/* Nonzero means do extra verification (that may slow things down).  */
+
+int verify_flag;
+
+/* Nonzero means do not print commands to be executed (-s).  */
+
+int silent_flag;
+static const int default_silent_flag = 0;
+
+/* Nonzero means just touch the files
+   that would appear to need remaking (-t)  */
+
+int touch_flag;
+
+/* Nonzero means just print what commands would need to be executed,
+   don't actually execute them (-n).  */
+
+int just_print_flag;
+
+/* Print debugging info (--debug).  */
+
+static struct stringlist *db_flags = 0;
+static int debug_flag = 0;
+
+int db_level = 0;
+
+/* Synchronize output (--output-sync).  */
+
+char *output_sync_option = 0;
+
+#ifdef WINDOWS32
+/* Suspend make in main for a short time to allow debugger to attach */
+
+int suspend_flag = 0;
+#endif
+
+/* Environment variables override makefile definitions.  */
+
+int env_overrides = 0;
+
+/* Nonzero means ignore status codes returned by commands
+   executed to remake files.  Just treat them all as successful (-i).  */
+
+int ignore_errors_flag = 0;
+
+/* Nonzero means don't remake anything, just print the data base
+   that results from reading the makefile (-p).  */
+
+int print_data_base_flag = 0;
+
+/* Nonzero means don't remake anything; just return a nonzero status
+   if the specified targets are not up to date (-q).  */
+
+int question_flag = 0;
+
+/* Nonzero means do not use any of the builtin rules (-r) / variables (-R).  */
+
+int no_builtin_rules_flag = 0;
+int no_builtin_variables_flag = 0;
+
+/* Nonzero means keep going even if remaking some file fails (-k).  */
+
+int keep_going_flag;
+static const int default_keep_going_flag = 0;
+
+/* Nonzero means check symlink mtimes.  */
+
+int check_symlink_flag = 0;
+
+/* Nonzero means print directory before starting and when done (-w).  */
+
+int print_directory_flag = 0;
+
+/* Nonzero means ignore print_directory_flag and never print the directory.
+   This is necessary because print_directory_flag is set implicitly.  */
+
+int inhibit_print_directory_flag = 0;
+
+/* Nonzero means print version information.  */
+
+int print_version_flag = 0;
+
+/* List of makefiles given with -f switches.  */
+
+static struct stringlist *makefiles = 0;
+
+/* Size of the stack when we started.  */
+
+#ifdef SET_STACK_SIZE
+struct rlimit stack_limit;
+#endif
+
+
+/* Number of job slots for parallelism.  */
+
+unsigned int job_slots;
+
+#define INVALID_JOB_SLOTS (-1)
+static unsigned int master_job_slots = 0;
+static int arg_job_slots = INVALID_JOB_SLOTS;
+
+static const int default_job_slots = INVALID_JOB_SLOTS;
+
+/* Value of job_slots that means no limit.  */
+
+static const int inf_jobs = 0;
+
+/* Authorization for the jobserver.  */
+
+static char *jobserver_auth = NULL;
+
+/* Handle for the mutex used on Windows to synchronize output of our
+   children under -O.  */
+
+char *sync_mutex = NULL;
+
+/* Maximum load average at which multiple jobs will be run.
+   Negative values mean unlimited, while zero means limit to
+   zero load (which could be useful to start infinite jobs remotely
+   but one at a time locally).  */
+double max_load_average = -1.0;
+double default_load_average = -1.0;
+
+/* List of directories given with -C switches.  */
+
+static struct stringlist *directories = 0;
+
+/* List of include directories given with -I switches.  */
+
+static struct stringlist *include_directories = 0;
+
+/* List of files given with -o switches.  */
+
+static struct stringlist *old_files = 0;
+
+/* List of files given with -W switches.  */
+
+static struct stringlist *new_files = 0;
+
+/* List of strings to be eval'd.  */
+static struct stringlist *eval_strings = 0;
+
+/* If nonzero, we should just print usage and exit.  */
+
+static int print_usage_flag = 0;
+
+/* If nonzero, we should print a warning message
+   for each reference to an undefined variable.  */
+
+int warn_undefined_variables_flag;
+
+/* If nonzero, always build all targets, regardless of whether
+   they appear out of date or not.  */
+
+static int always_make_set = 0;
+int always_make_flag = 0;
+
+/* If nonzero, we're in the "try to rebuild makefiles" phase.  */
+
+int rebuilding_makefiles = 0;
+
+/* Remember the original value of the SHELL variable, from the environment.  */
+
+struct variable shell_var;
+
+/* This character introduces a command: it's the first char on the line.  */
+
+char cmd_prefix = '\t';
+
+
+/* The usage output.  We write it this way to make life easier for the
+   translators, especially those trying to translate to right-to-left
+   languages like Hebrew.  */
+
+static const char *const usage[] =
+  {
+    N_("Options:\n"),
+    N_("\
+  -b, -m                      Ignored for compatibility.\n"),
+    N_("\
+  -B, --always-make           Unconditionally make all targets.\n"),
+    N_("\
+  -C DIRECTORY, --directory=DIRECTORY\n\
+                              Change to DIRECTORY before doing anything.\n"),
+    N_("\
+  -d                          Print lots of debugging information.\n"),
+    N_("\
+  --debug[=FLAGS]             Print various types of debugging information.\n"),
+    N_("\
+  -e, --environment-overrides\n\
+                              Environment variables override makefiles.\n"),
+    N_("\
+  -E STRING, --eval=STRING    Evaluate STRING as a makefile statement.\n"),
+    N_("\
+  -f FILE, --file=FILE, --makefile=FILE\n\
+                              Read FILE as a makefile.\n"),
+    N_("\
+  -h, --help                  Print this message and exit.\n"),
+    N_("\
+  -i, --ignore-errors         Ignore errors from recipes.\n"),
+    N_("\
+  -I DIRECTORY, --include-dir=DIRECTORY\n\
+                              Search DIRECTORY for included makefiles.\n"),
+    N_("\
+  -j [N], --jobs[=N]          Allow N jobs at once; infinite jobs with no arg.\n"),
+    N_("\
+  -k, --keep-going            Keep going when some targets can't be made.\n"),
+    N_("\
+  -l [N], --load-average[=N], --max-load[=N]\n\
+                              Don't start multiple jobs unless load is below N.\n"),
+    N_("\
+  -L, --check-symlink-times   Use the latest mtime between symlinks and target.\n"),
+    N_("\
+  -n, --just-print, --dry-run, --recon\n\
+                              Don't actually run any recipe; just print them.\n"),
+    N_("\
+  -o FILE, --old-file=FILE, --assume-old=FILE\n\
+                              Consider FILE to be very old and don't remake it.\n"),
+    N_("\
+  -O[TYPE], --output-sync[=TYPE]\n\
+                              Synchronize output of parallel jobs by TYPE.\n"),
+    N_("\
+  -p, --print-data-base       Print make's internal database.\n"),
+    N_("\
+  -q, --question              Run no recipe; exit status says if up to date.\n"),
+    N_("\
+  -r, --no-builtin-rules      Disable the built-in implicit rules.\n"),
+    N_("\
+  -R, --no-builtin-variables  Disable the built-in variable settings.\n"),
+    N_("\
+  -s, --silent, --quiet       Don't echo recipes.\n"),
+    N_("\
+  --no-silent                 Echo recipes (disable --silent mode).\n"),
+    N_("\
+  -S, --no-keep-going, --stop\n\
+                              Turns off -k.\n"),
+    N_("\
+  -t, --touch                 Touch targets instead of remaking them.\n"),
+    N_("\
+  --trace                     Print tracing information.\n"),
+    N_("\
+  -v, --version               Print the version number of make and exit.\n"),
+    N_("\
+  -w, --print-directory       Print the current directory.\n"),
+    N_("\
+  --no-print-directory        Turn off -w, even if it was turned on implicitly.\n"),
+    N_("\
+  -W FILE, --what-if=FILE, --new-file=FILE, --assume-new=FILE\n\
+                              Consider FILE to be infinitely new.\n"),
+    N_("\
+  --warn-undefined-variables  Warn when an undefined variable is referenced.\n"),
+    NULL
+  };
+
+/* The table of command switches.
+   Order matters here: this is the order MAKEFLAGS will be constructed.
+   So be sure all simple flags (single char, no argument) come first.  */
+
+static const struct command_switch switches[] =
+  {
+    { 'b', ignore, 0, 0, 0, 0, 0, 0, 0 },
+    { 'B', flag, &always_make_set, 1, 1, 0, 0, 0, "always-make" },
+    { 'd', flag, &debug_flag, 1, 1, 0, 0, 0, 0 },
+#ifdef WINDOWS32
+    { 'D', flag, &suspend_flag, 1, 1, 0, 0, 0, "suspend-for-debug" },
+#endif
+    { 'e', flag, &env_overrides, 1, 1, 0, 0, 0, "environment-overrides", },
+    { 'E', strlist, &eval_strings, 1, 0, 0, 0, 0, "eval" },
+    { 'h', flag, &print_usage_flag, 0, 0, 0, 0, 0, "help" },
+    { 'i', flag, &ignore_errors_flag, 1, 1, 0, 0, 0, "ignore-errors" },
+    { 'k', flag, &keep_going_flag, 1, 1, 0, 0, &default_keep_going_flag,
+      "keep-going" },
+    { 'L', flag, &check_symlink_flag, 1, 1, 0, 0, 0, "check-symlink-times" },
+    { 'm', ignore, 0, 0, 0, 0, 0, 0, 0 },
+    { 'n', flag, &just_print_flag, 1, 1, 1, 0, 0, "just-print" },
+    { 'p', flag, &print_data_base_flag, 1, 1, 0, 0, 0, "print-data-base" },
+    { 'q', flag, &question_flag, 1, 1, 1, 0, 0, "question" },
+    { 'r', flag, &no_builtin_rules_flag, 1, 1, 0, 0, 0, "no-builtin-rules" },
+    { 'R', flag, &no_builtin_variables_flag, 1, 1, 0, 0, 0,
+      "no-builtin-variables" },
+    { 's', flag, &silent_flag, 1, 1, 0, 0, &default_silent_flag, "silent" },
+    { 'S', flag_off, &keep_going_flag, 1, 1, 0, 0, &default_keep_going_flag,
+      "no-keep-going" },
+    { 't', flag, &touch_flag, 1, 1, 1, 0, 0, "touch" },
+    { 'v', flag, &print_version_flag, 1, 1, 0, 0, 0, "version" },
+    { 'w', flag, &print_directory_flag, 1, 1, 0, 0, 0, "print-directory" },
+
+    /* These options take arguments.  */
+    { 'C', filename, &directories, 0, 0, 0, 0, 0, "directory" },
+    { 'f', filename, &makefiles, 0, 0, 0, 0, 0, "file" },
+    { 'I', filename, &include_directories, 1, 1, 0, 0, 0,
+      "include-dir" },
+    { 'j', positive_int, &arg_job_slots, 1, 1, 0, &inf_jobs, &default_job_slots,
+      "jobs" },
+    { 'l', floating, &max_load_average, 1, 1, 0, &default_load_average,
+      &default_load_average, "load-average" },
+    { 'o', filename, &old_files, 0, 0, 0, 0, 0, "old-file" },
+    { 'O', string, &output_sync_option, 1, 1, 0, "target", 0, "output-sync" },
+    { 'W', filename, &new_files, 0, 0, 0, 0, 0, "what-if" },
+
+    /* These are long-style options.  */
+    { CHAR_MAX+1, strlist, &db_flags, 1, 1, 0, "basic", 0, "debug" },
+    { CHAR_MAX+2, string, &jobserver_auth, 1, 1, 0, 0, 0, "jobserver-auth" },
+    { CHAR_MAX+3, flag, &trace_flag, 1, 1, 0, 0, 0, "trace" },
+    { CHAR_MAX+4, flag, &inhibit_print_directory_flag, 1, 1, 0, 0, 0,
+      "no-print-directory" },
+    { CHAR_MAX+5, flag, &warn_undefined_variables_flag, 1, 1, 0, 0, 0,
+      "warn-undefined-variables" },
+    { CHAR_MAX+7, string, &sync_mutex, 1, 1, 0, 0, 0, "sync-mutex" },
+    { CHAR_MAX+8, flag_off, &silent_flag, 1, 1, 0, 0, &default_silent_flag, "no-silent" },
+    { CHAR_MAX+9, string, &jobserver_auth, 1, 0, 0, 0, 0, "jobserver-fds" },
+    { 0, 0, 0, 0, 0, 0, 0, 0, 0 }
+  };
+
+/* Secondary long names for options.  */
+
+static struct option long_option_aliases[] =
+  {
+    { "quiet",          no_argument,            0, 's' },
+    { "stop",           no_argument,            0, 'S' },
+    { "new-file",       required_argument,      0, 'W' },
+    { "assume-new",     required_argument,      0, 'W' },
+    { "assume-old",     required_argument,      0, 'o' },
+    { "max-load",       optional_argument,      0, 'l' },
+    { "dry-run",        no_argument,            0, 'n' },
+    { "recon",          no_argument,            0, 'n' },
+    { "makefile",       required_argument,      0, 'f' },
+  };
+
+/* List of goal targets.  */
+
+static struct goaldep *goals, *lastgoal;
+
+/* List of variables which were defined on the command line
+   (or, equivalently, in MAKEFLAGS).  */
+
+struct command_variable
+  {
+    struct command_variable *next;
+    struct variable *variable;
+  };
+static struct command_variable *command_variables;
+
+/* The name we were invoked with.  */
+
+const char *program;
+
+/* Our current directory before processing any -C options.  */
+
+char *directory_before_chdir;
+
+/* Our current directory after processing all -C options.  */
+
+char *starting_directory;
+
+/* Value of the MAKELEVEL variable at startup (or 0).  */
+
+unsigned int makelevel;
+
+/* Pointer to the value of the .DEFAULT_GOAL special variable.
+   The value will be the name of the goal to remake if the command line
+   does not override it.  It can be set by the makefile, or else it's
+   the first target defined in the makefile whose name does not start
+   with '.'.  */
+
+struct variable * default_goal_var;
+
+/* Pointer to structure for the file .DEFAULT
+   whose commands are used for any file that has none of its own.
+   This is zero if the makefiles do not define .DEFAULT.  */
+
+struct file *default_file;
+
+/* Nonzero if we have seen the magic '.POSIX' target.
+   This turns on pedantic compliance with POSIX.2.  */
+
+int posix_pedantic;
+
+/* Nonzero if we have seen the '.SECONDEXPANSION' target.
+   This turns on secondary expansion of prerequisites.  */
+
+int second_expansion;
+
+/* Nonzero if we have seen the '.ONESHELL' target.
+   This causes the entire recipe to be handed to SHELL
+   as a single string, potentially containing newlines.  */
+
+int one_shell;
+
+/* One of OUTPUT_SYNC_* if the "--output-sync" option was given.  This
+   attempts to synchronize the output of parallel jobs such that the results
+   of each job stay together.  */
+
+int output_sync = OUTPUT_SYNC_NONE;
+
+/* Nonzero if the "--trace" option was given.  */
+
+int trace_flag = 0;
+
+/* Nonzero if we have seen the '.NOTPARALLEL' target.
+   This turns off parallel builds for this invocation of make.  */
+
+int not_parallel;
+
+/* Nonzero if some rule detected clock skew; we keep track so (a) we only
+   print one warning about it during the run, and (b) we can print a final
+   warning at the end of the run. */
+
+int clock_skew_detected;
+
+/* Map of possible stop characters for searching strings.  */
+#ifndef UCHAR_MAX
+# define UCHAR_MAX 255
+#endif
+unsigned short stopchar_map[UCHAR_MAX + 1] = {0};
+
+/* If output-sync is enabled we'll collect all the output generated due to
+   options, while reading makefiles, etc.  */
+
+struct output make_sync;
+
+
+/* Mask of signals that are being caught with fatal_error_signal.  */
+
+#if defined(POSIX)
+sigset_t fatal_signal_set;
+#elif defined(HAVE_SIGSETMASK)
+int fatal_signal_mask;
+#endif
+
+#if !HAVE_DECL_BSD_SIGNAL && !defined bsd_signal
+# if !defined HAVE_SIGACTION
+#  define bsd_signal signal
+# else
+typedef RETSIGTYPE (*bsd_signal_ret_t) (int);
+
+static bsd_signal_ret_t
+bsd_signal (int sig, bsd_signal_ret_t func)
+{
+  struct sigaction act, oact;
+  act.sa_handler = func;
+  act.sa_flags = SA_RESTART;
+  sigemptyset (&act.sa_mask);
+  sigaddset (&act.sa_mask, sig);
+  if (sigaction (sig, &act, &oact) != 0)
+    return SIG_ERR;
+  return oact.sa_handler;
+}
+# endif
+#endif
+
+static void
+initialize_global_hash_tables (void)
+{
+  init_hash_global_variable_set ();
+  strcache_init ();
+  init_hash_files ();
+  hash_init_directories ();
+  hash_init_function_table ();
+}
+
+/* This character map locate stop chars when parsing GNU makefiles.
+   Each element is true if we should stop parsing on that character.  */
+
+static void
+initialize_stopchar_map (void)
+{
+  int i;
+
+  stopchar_map[(int)'\0'] = MAP_NUL;
+  stopchar_map[(int)'#'] = MAP_COMMENT;
+  stopchar_map[(int)';'] = MAP_SEMI;
+  stopchar_map[(int)'='] = MAP_EQUALS;
+  stopchar_map[(int)':'] = MAP_COLON;
+  stopchar_map[(int)'|'] = MAP_PIPE;
+  stopchar_map[(int)'.'] = MAP_DOT | MAP_USERFUNC;
+  stopchar_map[(int)','] = MAP_COMMA;
+  stopchar_map[(int)'('] = MAP_VARSEP;
+  stopchar_map[(int)'{'] = MAP_VARSEP;
+  stopchar_map[(int)'}'] = MAP_VARSEP;
+  stopchar_map[(int)')'] = MAP_VARSEP;
+  stopchar_map[(int)'$'] = MAP_VARIABLE;
+
+  stopchar_map[(int)'-'] = MAP_USERFUNC;
+  stopchar_map[(int)'_'] = MAP_USERFUNC;
+
+  stopchar_map[(int)' '] = MAP_BLANK;
+  stopchar_map[(int)'\t'] = MAP_BLANK;
+
+  stopchar_map[(int)'/'] = MAP_DIRSEP;
+#if defined(VMS)
+  stopchar_map[(int)':'] |= MAP_DIRSEP;
+  stopchar_map[(int)']'] |= MAP_DIRSEP;
+  stopchar_map[(int)'>'] |= MAP_DIRSEP;
+#elif defined(HAVE_DOS_PATHS)
+  stopchar_map[(int)'\\'] |= MAP_DIRSEP;
+#endif
+
+  for (i = 1; i <= UCHAR_MAX; ++i)
+    {
+      if (isspace (i) && NONE_SET (stopchar_map[i], MAP_BLANK))
+        /* Don't mark blank characters as newline characters.  */
+        stopchar_map[i] |= MAP_NEWLINE;
+      else if (isalnum (i))
+        stopchar_map[i] |= MAP_USERFUNC;
+    }
+}
+
+static const char *
+expand_command_line_file (const char *name)
+{
+  const char *cp;
+  char *expanded = 0;
+
+  if (name[0] == '\0')
+    O (fatal, NILF, _("empty string invalid as file name"));
+
+  if (name[0] == '~')
+    {
+      expanded = tilde_expand (name);
+      if (expanded && expanded[0] != '\0')
+        name = expanded;
+    }
+
+  /* This is also done in parse_file_seq, so this is redundant
+     for names read from makefiles.  It is here for names passed
+     on the command line.  */
+  while (name[0] == '.' && name[1] == '/')
+    {
+      name += 2;
+      while (name[0] == '/')
+        /* Skip following slashes: ".//foo" is "foo", not "/foo".  */
+        ++name;
+    }
+
+  if (name[0] == '\0')
+    {
+      /* Nothing else but one or more "./", maybe plus slashes!  */
+      name = "./";
+    }
+
+  cp = strcache_add (name);
+
+  free (expanded);
+
+  return cp;
+}
+
+/* Toggle -d on receipt of SIGUSR1.  */
+
+#ifdef SIGUSR1
+static RETSIGTYPE
+debug_signal_handler (int sig UNUSED)
+{
+  db_level = db_level ? DB_NONE : DB_BASIC;
+}
+#endif
+
+static void
+decode_debug_flags (void)
+{
+  const char **pp;
+
+  if (debug_flag)
+    db_level = DB_ALL;
+
+  if (db_flags)
+    for (pp=db_flags->list; *pp; ++pp)
+      {
+        const char *p = *pp;
+
+        while (1)
+          {
+            switch (tolower (p[0]))
+              {
+              case 'a':
+                db_level |= DB_ALL;
+                break;
+              case 'b':
+                db_level |= DB_BASIC;
+                break;
+              case 'i':
+                db_level |= DB_BASIC | DB_IMPLICIT;
+                break;
+              case 'j':
+                db_level |= DB_JOBS;
+                break;
+              case 'm':
+                db_level |= DB_BASIC | DB_MAKEFILES;
+                break;
+              case 'n':
+                db_level = 0;
+                break;
+              case 'v':
+                db_level |= DB_BASIC | DB_VERBOSE;
+                break;
+              default:
+                OS (fatal, NILF,
+                    _("unknown debug level specification '%s'"), p);
+              }
+
+            while (*(++p) != '\0')
+              if (*p == ',' || *p == ' ')
+                {
+                  ++p;
+                  break;
+                }
+
+            if (*p == '\0')
+              break;
+          }
+      }
+
+  if (db_level)
+    verify_flag = 1;
+
+  if (! db_level)
+    debug_flag = 0;
+}
+
+static void
+decode_output_sync_flags (void)
+{
+#ifdef NO_OUTPUT_SYNC
+  output_sync = OUTPUT_SYNC_NONE;
+#else
+  if (output_sync_option)
+    {
+      if (streq (output_sync_option, "none"))
+        output_sync = OUTPUT_SYNC_NONE;
+      else if (streq (output_sync_option, "line"))
+        output_sync = OUTPUT_SYNC_LINE;
+      else if (streq (output_sync_option, "target"))
+        output_sync = OUTPUT_SYNC_TARGET;
+      else if (streq (output_sync_option, "recurse"))
+        output_sync = OUTPUT_SYNC_RECURSE;
+      else
+        OS (fatal, NILF,
+            _("unknown output-sync type '%s'"), output_sync_option);
+    }
+
+  if (sync_mutex)
+    RECORD_SYNC_MUTEX (sync_mutex);
+#endif
+}
+
+#ifdef WINDOWS32
+
+#ifndef NO_OUTPUT_SYNC
+
+/* This is called from start_job_command when it detects that
+   output_sync option is in effect.  The handle to the synchronization
+   mutex is passed, as a string, to sub-makes via the --sync-mutex
+   command-line argument.  */
+void
+prepare_mutex_handle_string (sync_handle_t handle)
+{
+  if (!sync_mutex)
+    {
+      /* Prepare the mutex handle string for our children.  */
+      /* 2 hex digits per byte + 2 characters for "0x" + null.  */
+      sync_mutex = xmalloc ((2 * sizeof (sync_handle_t)) + 2 + 1);
+      sprintf (sync_mutex, "0x%Ix", handle);
+      define_makeflags (1, 0);
+    }
+}
+
+#endif  /* NO_OUTPUT_SYNC */
+
+/*
+ * HANDLE runtime exceptions by avoiding a requestor on the GUI. Capture
+ * exception and print it to stderr instead.
+ *
+ * If ! DB_VERBOSE, just print a simple message and exit.
+ * If DB_VERBOSE, print a more verbose message.
+ * If compiled for DEBUG, let exception pass through to GUI so that
+ *   debuggers can attach.
+ */
+LONG WINAPI
+handle_runtime_exceptions (struct _EXCEPTION_POINTERS *exinfo)
+{
+  PEXCEPTION_RECORD exrec = exinfo->ExceptionRecord;
+  LPSTR cmdline = GetCommandLine ();
+  LPSTR prg = strtok (cmdline, " ");
+  CHAR errmsg[1024];
+#ifdef USE_EVENT_LOG
+  HANDLE hEventSource;
+  LPTSTR lpszStrings[1];
+#endif
+
+  if (! ISDB (DB_VERBOSE))
+    {
+      sprintf (errmsg,
+               _("%s: Interrupt/Exception caught (code = 0x%lx, addr = 0x%p)\n"),
+               prg, exrec->ExceptionCode, exrec->ExceptionAddress);
+      fprintf (stderr, errmsg);
+      exit (255);
+    }
+
+  sprintf (errmsg,
+           _("\nUnhandled exception filter called from program %s\nExceptionCode = %lx\nExceptionFlags = %lx\nExceptionAddress = 0x%p\n"),
+           prg, exrec->ExceptionCode, exrec->ExceptionFlags,
+           exrec->ExceptionAddress);
+
+  if (exrec->ExceptionCode == EXCEPTION_ACCESS_VIOLATION
+      && exrec->NumberParameters >= 2)
+    sprintf (&errmsg[strlen(errmsg)],
+             (exrec->ExceptionInformation[0]
+              ? _("Access violation: write operation at address 0x%p\n")
+              : _("Access violation: read operation at address 0x%p\n")),
+             (PVOID)exrec->ExceptionInformation[1]);
+
+  /* turn this on if we want to put stuff in the event log too */
+#ifdef USE_EVENT_LOG
+  hEventSource = RegisterEventSource (NULL, "GNU Make");
+  lpszStrings[0] = errmsg;
+
+  if (hEventSource != NULL)
+    {
+      ReportEvent (hEventSource,         /* handle of event source */
+                   EVENTLOG_ERROR_TYPE,  /* event type */
+                   0,                    /* event category */
+                   0,                    /* event ID */
+                   NULL,                 /* current user's SID */
+                   1,                    /* strings in lpszStrings */
+                   0,                    /* no bytes of raw data */
+                   lpszStrings,          /* array of error strings */
+                   NULL);                /* no raw data */
+
+      (VOID) DeregisterEventSource (hEventSource);
+    }
+#endif
+
+  /* Write the error to stderr too */
+  fprintf (stderr, errmsg);
+
+#ifdef DEBUG
+  return EXCEPTION_CONTINUE_SEARCH;
+#else
+  exit (255);
+  return (255); /* not reached */
+#endif
+}
+
+/*
+ * On WIN32 systems we don't have the luxury of a /bin directory that
+ * is mapped globally to every drive mounted to the system. Since make could
+ * be invoked from any drive, and we don't want to propagate /bin/sh
+ * to every single drive. Allow ourselves a chance to search for
+ * a value for default shell here (if the default path does not exist).
+ */
+
+int
+find_and_set_default_shell (const char *token)
+{
+  int sh_found = 0;
+  char *atoken = 0;
+  const char *search_token;
+  const char *tokend;
+  PATH_VAR(sh_path);
+  extern const char *default_shell;
+
+  if (!token)
+    search_token = default_shell;
+  else
+    search_token = atoken = xstrdup (token);
+
+  /* If the user explicitly requests the DOS cmd shell, obey that request.
+     However, make sure that's what they really want by requiring the value
+     of SHELL either equal, or have a final path element of, "cmd" or
+     "cmd.exe" case-insensitive.  */
+  tokend = search_token + strlen (search_token) - 3;
+  if (((tokend == search_token
+        || (tokend > search_token
+            && (tokend[-1] == '/' || tokend[-1] == '\\')))
+       && !strcasecmp (tokend, "cmd"))
+      || ((tokend - 4 == search_token
+           || (tokend - 4 > search_token
+               && (tokend[-5] == '/' || tokend[-5] == '\\')))
+          && !strcasecmp (tokend - 4, "cmd.exe")))
+    {
+      batch_mode_shell = 1;
+      unixy_shell = 0;
+      sprintf (sh_path, "%s", search_token);
+      default_shell = xstrdup (w32ify (sh_path, 0));
+      DB (DB_VERBOSE, (_("find_and_set_shell() setting default_shell = %s\n"),
+                       default_shell));
+      sh_found = 1;
+    }
+  else if (!no_default_sh_exe
+           && (token == NULL || !strcmp (search_token, default_shell)))
+    {
+      /* no new information, path already set or known */
+      sh_found = 1;
+    }
+  else if (_access (search_token, 0) == 0)
+    {
+      /* search token path was found */
+      sprintf (sh_path, "%s", search_token);
+      default_shell = xstrdup (w32ify (sh_path, 0));
+      DB (DB_VERBOSE, (_("find_and_set_shell() setting default_shell = %s\n"),
+                       default_shell));
+      sh_found = 1;
+    }
+  else
+    {
+      char *p;
+      struct variable *v = lookup_variable (STRING_SIZE_TUPLE ("PATH"));
+
+      /* Search Path for shell */
+      if (v && v->value)
+        {
+          char *ep;
+
+          p  = v->value;
+          ep = strchr (p, PATH_SEPARATOR_CHAR);
+
+          while (ep && *ep)
+            {
+              *ep = '\0';
+
+              sprintf (sh_path, "%s/%s", p, search_token);
+              if (_access (sh_path, 0) == 0)
+                {
+                  default_shell = xstrdup (w32ify (sh_path, 0));
+                  sh_found = 1;
+                  *ep = PATH_SEPARATOR_CHAR;
+
+                  /* terminate loop */
+                  p += strlen (p);
+                }
+              else
+                {
+                  *ep = PATH_SEPARATOR_CHAR;
+                  p = ++ep;
+                }
+
+              ep = strchr (p, PATH_SEPARATOR_CHAR);
+            }
+
+          /* be sure to check last element of Path */
+          if (p && *p)
+            {
+              sprintf (sh_path, "%s/%s", p, search_token);
+              if (_access (sh_path, 0) == 0)
+                {
+                  default_shell = xstrdup (w32ify (sh_path, 0));
+                  sh_found = 1;
+                }
+            }
+
+          if (sh_found)
+            DB (DB_VERBOSE,
+                (_("find_and_set_shell() path search set default_shell = %s\n"),
+                 default_shell));
+        }
+    }
+
+  /* naive test */
+  if (!unixy_shell && sh_found
+      && (strstr (default_shell, "sh") || strstr (default_shell, "SH")))
+    {
+      unixy_shell = 1;
+      batch_mode_shell = 0;
+    }
+
+#ifdef BATCH_MODE_ONLY_SHELL
+  batch_mode_shell = 1;
+#endif
+
+  free (atoken);
+
+  return (sh_found);
+}
+#endif  /* WINDOWS32 */
+
+#ifdef __MSDOS__
+static void
+msdos_return_to_initial_directory (void)
+{
+  if (directory_before_chdir)
+    chdir (directory_before_chdir);
+}
+#endif  /* __MSDOS__ */
+
+static void
+reset_jobserver (void)
+{
+  jobserver_clear ();
+  free (jobserver_auth);
+  jobserver_auth = NULL;
+}
+
+#ifdef _AMIGA
+int
+main (int argc, char **argv)
+#else
+int
+main (int argc, char **argv, char **envp)
+#endif
+{
+  static char *stdin_nm = 0;
+  int makefile_status = MAKE_SUCCESS;
+  struct goaldep *read_files;
+  PATH_VAR (current_directory);
+  unsigned int restarts = 0;
+  unsigned int syncing = 0;
+  int argv_slots;
+#ifdef WINDOWS32
+  const char *unix_path = NULL;
+  const char *windows32_path = NULL;
+
+  SetUnhandledExceptionFilter (handle_runtime_exceptions);
+
+  /* start off assuming we have no shell */
+  unixy_shell = 0;
+  no_default_sh_exe = 1;
+#endif
+
+  output_init (&make_sync);
+
+  initialize_stopchar_map();
+
+#ifdef SET_STACK_SIZE
+ /* Get rid of any avoidable limit on stack size.  */
+  {
+    struct rlimit rlim;
+
+    /* Set the stack limit huge so that alloca does not fail.  */
+    if (getrlimit (RLIMIT_STACK, &rlim) == 0
+        && rlim.rlim_cur > 0 && rlim.rlim_cur < rlim.rlim_max)
+      {
+        stack_limit = rlim;
+        rlim.rlim_cur = rlim.rlim_max;
+        setrlimit (RLIMIT_STACK, &rlim);
+      }
+    else
+      stack_limit.rlim_cur = 0;
+  }
+#endif
+
+  /* Needed for OS/2 */
+  initialize_main (&argc, &argv);
+
+#ifdef MAKE_MAINTAINER_MODE
+  /* In maintainer mode we always enable verification.  */
+  verify_flag = 1;
+#endif
+
+#if defined (__MSDOS__) && !defined (_POSIX_SOURCE)
+  /* Request the most powerful version of 'system', to
+     make up for the dumb default shell.  */
+  __system_flags = (__system_redirect
+                    | __system_use_shell
+                    | __system_allow_multiple_cmds
+                    | __system_allow_long_cmds
+                    | __system_handle_null_commands
+                    | __system_emulate_chdir);
+
+#endif
+
+  /* Set up gettext/internationalization support.  */
+  setlocale (LC_ALL, "");
+  /* The cast to void shuts up compiler warnings on systems that
+     disable NLS.  */
+  (void)bindtextdomain (PACKAGE, LOCALEDIR);
+  (void)textdomain (PACKAGE);
+
+#ifdef  POSIX
+  sigemptyset (&fatal_signal_set);
+#define ADD_SIG(sig)    sigaddset (&fatal_signal_set, sig)
+#else
+#ifdef  HAVE_SIGSETMASK
+  fatal_signal_mask = 0;
+#define ADD_SIG(sig)    fatal_signal_mask |= sigmask (sig)
+#else
+#define ADD_SIG(sig)    (void)sig
+#endif
+#endif
+
+#define FATAL_SIG(sig)                                                        \
+  if (bsd_signal (sig, fatal_error_signal) == SIG_IGN)                        \
+    bsd_signal (sig, SIG_IGN);                                                \
+  else                                                                        \
+    ADD_SIG (sig);
+
+#ifdef SIGHUP
+  FATAL_SIG (SIGHUP);
+#endif
+#ifdef SIGQUIT
+  FATAL_SIG (SIGQUIT);
+#endif
+  FATAL_SIG (SIGINT);
+  FATAL_SIG (SIGTERM);
+
+#ifdef __MSDOS__
+  /* Windows 9X delivers FP exceptions in child programs to their
+     parent!  We don't want Make to die when a child divides by zero,
+     so we work around that lossage by catching SIGFPE.  */
+  FATAL_SIG (SIGFPE);
+#endif
+
+#ifdef  SIGDANGER
+  FATAL_SIG (SIGDANGER);
+#endif
+#ifdef SIGXCPU
+  FATAL_SIG (SIGXCPU);
+#endif
+#ifdef SIGXFSZ
+  FATAL_SIG (SIGXFSZ);
+#endif
+
+#undef  FATAL_SIG
+
+  /* Do not ignore the child-death signal.  This must be done before
+     any children could possibly be created; otherwise, the wait
+     functions won't work on systems with the SVR4 ECHILD brain
+     damage, if our invoker is ignoring this signal.  */
+
+#ifdef HAVE_WAIT_NOHANG
+# if defined SIGCHLD
+  (void) bsd_signal (SIGCHLD, SIG_DFL);
+# endif
+# if defined SIGCLD && SIGCLD != SIGCHLD
+  (void) bsd_signal (SIGCLD, SIG_DFL);
+# endif
+#endif
+
+  output_init (NULL);
+
+  /* Figure out where this program lives.  */
+
+  if (argv[0] == 0)
+    argv[0] = (char *)"";
+  if (argv[0][0] == '\0')
+    program = "make";
+  else
+    {
+#if defined(HAVE_DOS_PATHS)
+      const char* start = argv[0];
+
+      /* Skip an initial drive specifier if present.  */
+      if (isalpha ((unsigned char)start[0]) && start[1] == ':')
+        start += 2;
+
+      if (start[0] == '\0')
+        program = "make";
+      else
+        {
+          program = start + strlen (start);
+          while (program > start && ! STOP_SET (program[-1], MAP_DIRSEP))
+            --program;
+
+          /* Remove the .exe extension if present.  */
+          {
+            size_t len = strlen (program);
+            if (len > 4 && streq (&program[len - 4], ".exe"))
+              program = xstrndup (program, len - 4);
+          }
+        }
+#elif defined(VMS)
+      set_program_name (argv[0]);
+      program = program_name;
+      {
+        const char *shell;
+        char pwdbuf[256];
+        char *pwd;
+        shell = getenv ("SHELL");
+        if (shell != NULL)
+          vms_gnv_shell = 1;
+
+        /* Need to know if CRTL set to report UNIX paths.  Use getcwd as
+           it works on all versions of VMS. */
+        pwd = getcwd(pwdbuf, 256);
+        if (pwd[0] == '/')
+          vms_report_unix_paths = 1;
+
+        vms_use_mcr_command = get_vms_env_flag ("GNV$MAKE_USE_MCR", 0);
+
+        vms_always_use_cmd_file = get_vms_env_flag ("GNV$MAKE_USE_CMD_FILE", 0);
+
+        /* Legacy behavior is on VMS is older behavior that needed to be
+           changed to be compatible with standard make behavior.
+           For now only completely disable when running under a Bash shell.
+           TODO: Update VMS built in recipes and macros to not need this
+           behavior, at which time the default may change. */
+        vms_legacy_behavior = get_vms_env_flag ("GNV$MAKE_OLD_VMS",
+                                                !vms_gnv_shell);
+
+        /* VMS was changed to use a comma separator in the past, but that is
+           incompatible with built in functions that expect space separated
+           lists.  Allow this to be selectively turned off. */
+        vms_comma_separator = get_vms_env_flag ("GNV$MAKE_COMMA",
+                                                vms_legacy_behavior);
+
+        /* Some Posix shell syntax options are incompatible with VMS syntax.
+           VMS requires double quotes for strings and escapes quotes
+           differently.  When this option is active, VMS will try
+           to simulate Posix shell simulations instead of using
+           VMS DCL behavior. */
+        vms_unix_simulation = get_vms_env_flag ("GNV$MAKE_SHELL_SIM",
+                                                !vms_legacy_behavior);
+
+      }
+      if (need_vms_symbol () && !vms_use_mcr_command)
+        create_foreign_command (program_name, argv[0]);
+#else
+      program = strrchr (argv[0], '/');
+      if (program == 0)
+        program = argv[0];
+      else
+        ++program;
+#endif
+    }
+
+  /* Set up to access user data (files).  */
+  user_access ();
+
+  initialize_global_hash_tables ();
+
+  /* Figure out where we are.  */
+
+#ifdef WINDOWS32
+  if (getcwd_fs (current_directory, GET_PATH_MAX) == 0)
+#else
+  if (getcwd (current_directory, GET_PATH_MAX) == 0)
+#endif
+    {
+#ifdef  HAVE_GETCWD
+      perror_with_name ("getcwd", "");
+#else
+      OS (error, NILF, "getwd: %s", current_directory);
+#endif
+      current_directory[0] = '\0';
+      directory_before_chdir = 0;
+    }
+  else
+    directory_before_chdir = xstrdup (current_directory);
+
+#ifdef  __MSDOS__
+  /* Make sure we will return to the initial directory, come what may.  */
+  atexit (msdos_return_to_initial_directory);
+#endif
+
+  /* Initialize the special variables.  */
+  define_variable_cname (".VARIABLES", "", o_default, 0)->special = 1;
+  /* define_variable_cname (".TARGETS", "", o_default, 0)->special = 1; */
+  define_variable_cname (".RECIPEPREFIX", "", o_default, 0)->special = 1;
+  define_variable_cname (".SHELLFLAGS", "-c", o_default, 0);
+  define_variable_cname (".LOADED", "", o_default, 0);
+
+  /* Set up .FEATURES
+     Use a separate variable because define_variable_cname() is a macro and
+     some compilers (MSVC) don't like conditionals in macros.  */
+  {
+    const char *features = "target-specific order-only second-expansion"
+                           " else-if shortest-stem undefine oneshell nocomment"
+#ifndef NO_ARCHIVES
+                           " archives"
+#endif
+#ifdef MAKE_JOBSERVER
+                           " jobserver"
+#endif
+#ifndef NO_OUTPUT_SYNC
+                           " output-sync"
+#endif
+#ifdef MAKE_SYMLINKS
+                           " check-symlink"
+#endif
+#ifdef HAVE_GUILE
+                           " guile"
+#endif
+#ifdef MAKE_LOAD
+                           " load"
+#endif
+                           ;
+
+    define_variable_cname (".FEATURES", features, o_default, 0);
+  }
+
+  /* Configure GNU Guile support */
+  guile_gmake_setup (NILF);
+
+  /* Read in variables from the environment.  It is important that this be
+     done before $(MAKE) is figured out so its definitions will not be
+     from the environment.  */
+
+#ifndef _AMIGA
+  {
+    unsigned int i;
+
+    for (i = 0; envp[i] != 0; ++i)
+      {
+        struct variable *v;
+        const char *ep = envp[i];
+        /* By default, export all variables culled from the environment.  */
+        enum variable_export export = v_export;
+        unsigned int len;
+
+        while (! STOP_SET (*ep, MAP_EQUALS))
+          ++ep;
+
+        /* If there's no equals sign it's a malformed environment.  Ignore.  */
+        if (*ep == '\0')
+          continue;
+
+#ifdef WINDOWS32
+        if (!unix_path && strneq (envp[i], "PATH=", 5))
+          unix_path = ep+1;
+        else if (!strnicmp (envp[i], "Path=", 5))
+          {
+            if (!windows32_path)
+              windows32_path = ep+1;
+            /* PATH gets defined after the loop exits.  */
+            continue;
+          }
+#endif
+
+        /* Length of the variable name, and skip the '='.  */
+        len = ep++ - envp[i];
+
+        /* If this is MAKE_RESTARTS, check to see if the "already printed
+           the enter statement" flag is set.  */
+        if (len == 13 && strneq (envp[i], "MAKE_RESTARTS", 13))
+          {
+            if (*ep == '-')
+              {
+                OUTPUT_TRACED ();
+                ++ep;
+              }
+            restarts = (unsigned int) atoi (ep);
+            export = v_noexport;
+          }
+
+        v = define_variable (envp[i], len, ep, o_env, 1);
+
+        /* POSIX says the value of SHELL set in the makefile won't change the
+           value of SHELL given to subprocesses.  */
+        if (streq (v->name, "SHELL"))
+          {
+#ifndef __MSDOS__
+            export = v_noexport;
+#endif
+            shell_var.name = xstrdup ("SHELL");
+            shell_var.length = 5;
+            shell_var.value = xstrdup (ep);
+          }
+
+        v->export = export;
+      }
+  }
+#ifdef WINDOWS32
+    /* If we didn't find a correctly spelled PATH we define PATH as
+     * either the first misspelled value or an empty string
+     */
+    if (!unix_path)
+      define_variable_cname ("PATH", windows32_path ? windows32_path : "",
+                             o_env, 1)->export = v_export;
+#endif
+#else /* For Amiga, read the ENV: device, ignoring all dirs */
+    {
+        BPTR env, file, old;
+        char buffer[1024];
+        int len;
+        __aligned struct FileInfoBlock fib;
+
+        env = Lock ("ENV:", ACCESS_READ);
+        if (env)
+          {
+            old = CurrentDir (DupLock (env));
+            Examine (env, &fib);
+
+            while (ExNext (env, &fib))
+              {
+                if (fib.fib_DirEntryType < 0) /* File */
+                  {
+                    /* Define an empty variable. It will be filled in
+                       variable_lookup(). Makes startup quite a bit faster. */
+                    define_variable (fib.fib_FileName,
+                                     strlen (fib.fib_FileName),
+                                     "", o_env, 1)->export = v_export;
+                  }
+              }
+            UnLock (env);
+            UnLock (CurrentDir (old));
+          }
+    }
+#endif
+
+  /* Decode the switches.  */
+  decode_env_switches (STRING_SIZE_TUPLE ("GNUMAKEFLAGS"));
+
+  /* Clear GNUMAKEFLAGS to avoid duplication.  */
+  define_variable_cname ("GNUMAKEFLAGS", "", o_env, 0);
+
+  decode_env_switches (STRING_SIZE_TUPLE ("MAKEFLAGS"));
+
+#if 0
+  /* People write things like:
+        MFLAGS="CC=gcc -pipe" "CFLAGS=-g"
+     and we set the -p, -i and -e switches.  Doesn't seem quite right.  */
+  decode_env_switches (STRING_SIZE_TUPLE ("MFLAGS"));
+#endif
+
+  /* In output sync mode we need to sync any output generated by reading the
+     makefiles, such as in $(info ...) or stderr from $(shell ...) etc.  */
+
+  syncing = make_sync.syncout = (output_sync == OUTPUT_SYNC_LINE
+                                 || output_sync == OUTPUT_SYNC_TARGET);
+  OUTPUT_SET (&make_sync);
+
+  /* Parse the command line options.  Remember the job slots set this way.  */
+  {
+    int env_slots = arg_job_slots;
+    arg_job_slots = INVALID_JOB_SLOTS;
+
+    decode_switches (argc, (const char **)argv, 0);
+    argv_slots = arg_job_slots;
+
+    if (arg_job_slots == INVALID_JOB_SLOTS)
+      arg_job_slots = env_slots;
+  }
+
+  /* Set a variable specifying whether stdout/stdin is hooked to a TTY.  */
+#ifdef HAVE_ISATTY
+  if (isatty (fileno (stdout)))
+    if (! lookup_variable (STRING_SIZE_TUPLE ("MAKE_TERMOUT")))
+      {
+        const char *tty = TTYNAME (fileno (stdout));
+        define_variable_cname ("MAKE_TERMOUT", tty ? tty : DEFAULT_TTYNAME,
+                               o_default, 0)->export = v_export;
+      }
+  if (isatty (fileno (stderr)))
+    if (! lookup_variable (STRING_SIZE_TUPLE ("MAKE_TERMERR")))
+      {
+        const char *tty = TTYNAME (fileno (stderr));
+        define_variable_cname ("MAKE_TERMERR", tty ? tty : DEFAULT_TTYNAME,
+                               o_default, 0)->export = v_export;
+      }
+#endif
+
+  /* Reset in case the switches changed our minds.  */
+  syncing = (output_sync == OUTPUT_SYNC_LINE
+             || output_sync == OUTPUT_SYNC_TARGET);
+
+  if (make_sync.syncout && ! syncing)
+    output_close (&make_sync);
+
+  make_sync.syncout = syncing;
+  OUTPUT_SET (&make_sync);
+
+  /* Figure out the level of recursion.  */
+  {
+    struct variable *v = lookup_variable (STRING_SIZE_TUPLE (MAKELEVEL_NAME));
+    if (v && v->value[0] != '\0' && v->value[0] != '-')
+      makelevel = (unsigned int) atoi (v->value);
+    else
+      makelevel = 0;
+  }
+
+#ifdef WINDOWS32
+  if (suspend_flag)
+    {
+      fprintf (stderr, "%s (pid = %ld)\n", argv[0], GetCurrentProcessId ());
+      fprintf (stderr, _("%s is suspending for 30 seconds..."), argv[0]);
+      Sleep (30 * 1000);
+      fprintf (stderr, _("done sleep(30). Continuing.\n"));
+    }
+#endif
+
+  /* Set always_make_flag if -B was given and we've not restarted already.  */
+  always_make_flag = always_make_set && (restarts == 0);
+
+  /* Print version information, and exit.  */
+  if (print_version_flag)
+    {
+      print_version ();
+      die (MAKE_SUCCESS);
+    }
+
+  if (ISDB (DB_BASIC))
+    print_version ();
+
+#ifndef VMS
+  /* Set the "MAKE_COMMAND" variable to the name we were invoked with.
+     (If it is a relative pathname with a slash, prepend our directory name
+     so the result will run the same program regardless of the current dir.
+     If it is a name with no slash, we can only hope that PATH did not
+     find it in the current directory.)  */
+#ifdef WINDOWS32
+  /*
+   * Convert from backslashes to forward slashes for
+   * programs like sh which don't like them. Shouldn't
+   * matter if the path is one way or the other for
+   * CreateProcess().
+   */
+  if (strpbrk (argv[0], "/:\\") || strstr (argv[0], "..")
+      || strneq (argv[0], "//", 2))
+    argv[0] = xstrdup (w32ify (argv[0], 1));
+#else /* WINDOWS32 */
+#if defined (__MSDOS__) || defined (__EMX__)
+  if (strchr (argv[0], '\\'))
+    {
+      char *p;
+
+      argv[0] = xstrdup (argv[0]);
+      for (p = argv[0]; *p; p++)
+        if (*p == '\\')
+          *p = '/';
+    }
+  /* If argv[0] is not in absolute form, prepend the current
+     directory.  This can happen when Make is invoked by another DJGPP
+     program that uses a non-absolute name.  */
+  if (current_directory[0] != '\0'
+      && argv[0] != 0
+      && (argv[0][0] != '/' && (argv[0][0] == '\0' || argv[0][1] != ':'))
+# ifdef __EMX__
+      /* do not prepend cwd if argv[0] contains no '/', e.g. "make" */
+      && (strchr (argv[0], '/') != 0 || strchr (argv[0], '\\') != 0)
+# endif
+      )
+    argv[0] = xstrdup (concat (3, current_directory, "/", argv[0]));
+#else  /* !__MSDOS__ */
+  if (current_directory[0] != '\0'
+      && argv[0] != 0 && argv[0][0] != '/' && strchr (argv[0], '/') != 0
+#ifdef HAVE_DOS_PATHS
+      && (argv[0][0] != '\\' && (!argv[0][0] || argv[0][1] != ':'))
+      && strchr (argv[0], '\\') != 0
+#endif
+      )
+    argv[0] = xstrdup (concat (3, current_directory, "/", argv[0]));
+#endif /* !__MSDOS__ */
+#endif /* WINDOWS32 */
+#endif
+
+  /* We may move, but until we do, here we are.  */
+  starting_directory = current_directory;
+
+  /* Validate the arg_job_slots configuration before we define MAKEFLAGS so
+     users get an accurate value in their makefiles.
+     At this point arg_job_slots is the argv setting, if there is one, else
+     the MAKEFLAGS env setting, if there is one.  */
+
+  if (jobserver_auth)
+    {
+      /* We're a child in an existing jobserver group.  */
+      if (argv_slots == INVALID_JOB_SLOTS)
+        {
+          /* There's no -j option on the command line: check authorization.  */
+          if (jobserver_parse_auth (jobserver_auth))
+            {
+              /* Success!  Use the jobserver.  */
+              goto job_setup_complete;
+            }
+
+          /* Oops: we have jobserver-auth but it's invalid :(.  */
+          O (error, NILF, _("warning: jobserver unavailable: using -j1.  Add '+' to parent make rule."));
+          arg_job_slots = 1;
+        }
+
+      /* The user provided a -j setting on the command line so use it: we're
+         the master make of a new jobserver group.  */
+      else if (!restarts)
+        ON (error, NILF,
+            _("warning: -j%d forced in submake: resetting jobserver mode."),
+            argv_slots);
+
+      /* We can't use our parent's jobserver, so reset.  */
+      reset_jobserver ();
+    }
+
+ job_setup_complete:
+
+  /* The extra indirection through $(MAKE_COMMAND) is done
+     for hysterical raisins.  */
+
+#ifdef VMS
+  if (vms_use_mcr_command)
+    define_variable_cname ("MAKE_COMMAND", vms_command (argv[0]), o_default, 0);
+  else
+    define_variable_cname ("MAKE_COMMAND", program, o_default, 0);
+#else
+  define_variable_cname ("MAKE_COMMAND", argv[0], o_default, 0);
+#endif
+  define_variable_cname ("MAKE", "$(MAKE_COMMAND)", o_default, 1);
+
+  if (command_variables != 0)
+    {
+      struct command_variable *cv;
+      struct variable *v;
+      unsigned int len = 0;
+      char *value, *p;
+
+      /* Figure out how much space will be taken up by the command-line
+         variable definitions.  */
+      for (cv = command_variables; cv != 0; cv = cv->next)
+        {
+          v = cv->variable;
+          len += 2 * strlen (v->name);
+          if (! v->recursive)
+            ++len;
+          ++len;
+          len += 2 * strlen (v->value);
+          ++len;
+        }
+
+      /* Now allocate a buffer big enough and fill it.  */
+      p = value = alloca (len);
+      for (cv = command_variables; cv != 0; cv = cv->next)
+        {
+          v = cv->variable;
+          p = quote_for_env (p, v->name);
+          if (! v->recursive)
+            *p++ = ':';
+          *p++ = '=';
+          p = quote_for_env (p, v->value);
+          *p++ = ' ';
+        }
+      p[-1] = '\0';             /* Kill the final space and terminate.  */
+
+      /* Define an unchangeable variable with a name that no POSIX.2
+         makefile could validly use for its own variable.  */
+      define_variable_cname ("-*-command-variables-*-", value, o_automatic, 0);
+
+      /* Define the variable; this will not override any user definition.
+         Normally a reference to this variable is written into the value of
+         MAKEFLAGS, allowing the user to override this value to affect the
+         exported value of MAKEFLAGS.  In POSIX-pedantic mode, we cannot
+         allow the user's setting of MAKEOVERRIDES to affect MAKEFLAGS, so
+         a reference to this hidden variable is written instead. */
+      define_variable_cname ("MAKEOVERRIDES", "${-*-command-variables-*-}",
+                             o_env, 1);
+#ifdef VMS
+      vms_export_dcl_symbol ("MAKEOVERRIDES", "${-*-command-variables-*-}");
+#endif
+    }
+
+  /* If there were -C flags, move ourselves about.  */
+  if (directories != 0)
+    {
+      unsigned int i;
+      for (i = 0; directories->list[i] != 0; ++i)
+        {
+          const char *dir = directories->list[i];
+#ifdef WINDOWS32
+          /* WINDOWS32 chdir() doesn't work if the directory has a trailing '/'
+             But allow -C/ just in case someone wants that.  */
+          {
+            char *p = (char *)dir + strlen (dir) - 1;
+            while (p > dir && (p[0] == '/' || p[0] == '\\'))
+              --p;
+            p[1] = '\0';
+          }
+#endif
+          if (chdir (dir) < 0)
+            pfatal_with_name (dir);
+        }
+    }
+
+#ifdef WINDOWS32
+  /*
+   * THIS BLOCK OF CODE MUST COME AFTER chdir() CALL ABOVE IN ORDER
+   * TO NOT CONFUSE THE DEPENDENCY CHECKING CODE IN implicit.c.
+   *
+   * The functions in dir.c can incorrectly cache information for "."
+   * before we have changed directory and this can cause file
+   * lookups to fail because the current directory (.) was pointing
+   * at the wrong place when it was first evaluated.
+   */
+   no_default_sh_exe = !find_and_set_default_shell (NULL);
+#endif /* WINDOWS32 */
+
+  /* Except under -s, always do -w in sub-makes and under -C.  */
+  if (!silent_flag && (directories != 0 || makelevel > 0))
+    print_directory_flag = 1;
+
+  /* Let the user disable that with --no-print-directory.  */
+  if (inhibit_print_directory_flag)
+    print_directory_flag = 0;
+
+  /* If -R was given, set -r too (doesn't make sense otherwise!)  */
+  if (no_builtin_variables_flag)
+    no_builtin_rules_flag = 1;
+
+  /* Construct the list of include directories to search.  */
+
+  construct_include_path (include_directories == 0
+                          ? 0 : include_directories->list);
+
+  /* If we chdir'ed, figure out where we are now.  */
+  if (directories)
+    {
+#ifdef WINDOWS32
+      if (getcwd_fs (current_directory, GET_PATH_MAX) == 0)
+#else
+      if (getcwd (current_directory, GET_PATH_MAX) == 0)
+#endif
+        {
+#ifdef  HAVE_GETCWD
+          perror_with_name ("getcwd", "");
+#else
+          OS (error, NILF, "getwd: %s", current_directory);
+#endif
+          starting_directory = 0;
+        }
+      else
+        starting_directory = current_directory;
+    }
+
+  define_variable_cname ("CURDIR", current_directory, o_file, 0);
+
+  /* Read any stdin makefiles into temporary files.  */
+
+  if (makefiles != 0)
+    {
+      unsigned int i;
+      for (i = 0; i < makefiles->idx; ++i)
+        if (makefiles->list[i][0] == '-' && makefiles->list[i][1] == '\0')
+          {
+            /* This makefile is standard input.  Since we may re-exec
+               and thus re-read the makefiles, we read standard input
+               into a temporary file and read from that.  */
+            FILE *outfile;
+            char *template;
+            const char *tmpdir;
+
+            if (stdin_nm)
+              O (fatal, NILF,
+                 _("Makefile from standard input specified twice."));
+
+#ifdef VMS
+# define DEFAULT_TMPDIR     "/sys$scratch/"
+#else
+# ifdef P_tmpdir
+#  define DEFAULT_TMPDIR    P_tmpdir
+# else
+#  define DEFAULT_TMPDIR    "/tmp"
+# endif
+#endif
+#define DEFAULT_TMPFILE     "GmXXXXXX"
+
+            if (((tmpdir = getenv ("TMPDIR")) == NULL || *tmpdir == '\0')
+#if defined (__MSDOS__) || defined (WINDOWS32) || defined (__EMX__)
+                /* These are also used commonly on these platforms.  */
+                && ((tmpdir = getenv ("TEMP")) == NULL || *tmpdir == '\0')
+                && ((tmpdir = getenv ("TMP")) == NULL || *tmpdir == '\0')
+#endif
+               )
+              tmpdir = DEFAULT_TMPDIR;
+
+            template = alloca (strlen (tmpdir) + CSTRLEN (DEFAULT_TMPFILE) + 2);
+            strcpy (template, tmpdir);
+
+#ifdef HAVE_DOS_PATHS
+            if (strchr ("/\\", template[strlen (template) - 1]) == NULL)
+              strcat (template, "/");
+#else
+# ifndef VMS
+            if (template[strlen (template) - 1] != '/')
+              strcat (template, "/");
+# endif /* !VMS */
+#endif /* !HAVE_DOS_PATHS */
+
+            strcat (template, DEFAULT_TMPFILE);
+            outfile = get_tmpfile (&stdin_nm, template);
+            if (outfile == 0)
+              pfatal_with_name (_("fopen (temporary file)"));
+            while (!feof (stdin) && ! ferror (stdin))
+              {
+                char buf[2048];
+                unsigned int n = fread (buf, 1, sizeof (buf), stdin);
+                if (n > 0 && fwrite (buf, 1, n, outfile) != n)
+                  pfatal_with_name (_("fwrite (temporary file)"));
+              }
+            fclose (outfile);
+
+            /* Replace the name that read_all_makefiles will
+               see with the name of the temporary file.  */
+            makefiles->list[i] = strcache_add (stdin_nm);
+
+            /* Make sure the temporary file will not be remade.  */
+            {
+              struct file *f = enter_file (strcache_add (stdin_nm));
+              f->updated = 1;
+              f->update_status = us_success;
+              f->command_state = cs_finished;
+              /* Can't be intermediate, or it'll be removed too early for
+                 make re-exec.  */
+              f->intermediate = 0;
+              f->dontcare = 0;
+            }
+          }
+    }
+
+#ifndef __EMX__ /* Don't use a SIGCHLD handler for OS/2 */
+#if !defined(HAVE_WAIT_NOHANG) || defined(MAKE_JOBSERVER)
+  /* Set up to handle children dying.  This must be done before
+     reading in the makefiles so that 'shell' function calls will work.
+
+     If we don't have a hanging wait we have to fall back to old, broken
+     functionality here and rely on the signal handler and counting
+     children.
+
+     If we're using the jobs pipe we need a signal handler so that SIGCHLD is
+     not ignored; we need it to interrupt the read(2) of the jobserver pipe if
+     we're waiting for a token.
+
+     If none of these are true, we don't need a signal handler at all.  */
+  {
+# if defined SIGCHLD
+    bsd_signal (SIGCHLD, child_handler);
+# endif
+# if defined SIGCLD && SIGCLD != SIGCHLD
+    bsd_signal (SIGCLD, child_handler);
+# endif
+  }
+
+#ifdef HAVE_PSELECT
+  /* If we have pselect() then we need to block SIGCHLD so it's deferred.  */
+  {
+    sigset_t block;
+    sigemptyset (&block);
+    sigaddset (&block, SIGCHLD);
+    if (sigprocmask (SIG_SETMASK, &block, NULL) < 0)
+      pfatal_with_name ("sigprocmask(SIG_SETMASK, SIGCHLD)");
+  }
+#endif
+
+#endif
+#endif
+
+  /* Let the user send us SIGUSR1 to toggle the -d flag during the run.  */
+#ifdef SIGUSR1
+  bsd_signal (SIGUSR1, debug_signal_handler);
+#endif
+
+  /* Define the initial list of suffixes for old-style rules.  */
+  set_default_suffixes ();
+
+  /* Define the file rules for the built-in suffix rules.  These will later
+     be converted into pattern rules.  We used to do this in
+     install_default_implicit_rules, but since that happens after reading
+     makefiles, it results in the built-in pattern rules taking precedence
+     over makefile-specified suffix rules, which is wrong.  */
+  install_default_suffix_rules ();
+
+  /* Define some internal and special variables.  */
+  define_automatic_variables ();
+
+  /* Set up the MAKEFLAGS and MFLAGS variables for makefiles to see.
+     Initialize it to be exported but allow the makefile to reset it.  */
+  define_makeflags (0, 0)->export = v_export;
+
+  /* Define the default variables.  */
+  define_default_variables ();
+
+  default_file = enter_file (strcache_add (".DEFAULT"));
+
+  default_goal_var = define_variable_cname (".DEFAULT_GOAL", "", o_file, 0);
+
+  /* Evaluate all strings provided with --eval.
+     Also set up the $(-*-eval-flags-*-) variable.  */
+
+  if (eval_strings)
+    {
+      char *p, *value;
+      unsigned int i;
+      unsigned int len = (CSTRLEN ("--eval=") + 1) * eval_strings->idx;
+
+      for (i = 0; i < eval_strings->idx; ++i)
+        {
+          p = xstrdup (eval_strings->list[i]);
+          len += 2 * strlen (p);
+          eval_buffer (p, NULL);
+          free (p);
+        }
+
+      p = value = alloca (len);
+      for (i = 0; i < eval_strings->idx; ++i)
+        {
+          strcpy (p, "--eval=");
+          p += CSTRLEN ("--eval=");
+          p = quote_for_env (p, eval_strings->list[i]);
+          *(p++) = ' ';
+        }
+      p[-1] = '\0';
+
+      define_variable_cname ("-*-eval-flags-*-", value, o_automatic, 0);
+    }
+
+  /* Read all the makefiles.  */
+
+  read_files = read_all_makefiles (makefiles == 0 ? 0 : makefiles->list);
+
+#ifdef WINDOWS32
+  /* look one last time after reading all Makefiles */
+  if (no_default_sh_exe)
+    no_default_sh_exe = !find_and_set_default_shell (NULL);
+#endif /* WINDOWS32 */
+
+#if defined (__MSDOS__) || defined (__EMX__) || defined (VMS)
+  /* We need to know what kind of shell we will be using.  */
+  {
+    extern int _is_unixy_shell (const char *_path);
+    struct variable *shv = lookup_variable (STRING_SIZE_TUPLE ("SHELL"));
+    extern int unixy_shell;
+    extern const char *default_shell;
+
+    if (shv && *shv->value)
+      {
+        char *shell_path = recursively_expand (shv);
+
+        if (shell_path && _is_unixy_shell (shell_path))
+          unixy_shell = 1;
+        else
+          unixy_shell = 0;
+        if (shell_path)
+          default_shell = shell_path;
+      }
+  }
+#endif /* __MSDOS__ || __EMX__ */
+
+  {
+    int old_builtin_rules_flag = no_builtin_rules_flag;
+    int old_builtin_variables_flag = no_builtin_variables_flag;
+    int old_arg_job_slots = arg_job_slots;
+
+    arg_job_slots = INVALID_JOB_SLOTS;
+
+    /* Decode switches again, for variables set by the makefile.  */
+    decode_env_switches (STRING_SIZE_TUPLE ("GNUMAKEFLAGS"));
+
+    /* Clear GNUMAKEFLAGS to avoid duplication.  */
+    define_variable_cname ("GNUMAKEFLAGS", "", o_override, 0);
+
+    decode_env_switches (STRING_SIZE_TUPLE ("MAKEFLAGS"));
+#if 0
+    decode_env_switches (STRING_SIZE_TUPLE ("MFLAGS"));
+#endif
+
+    /* If -j is not set in the makefile, or it was set on the command line,
+       reset to use the previous value.  */
+    if (arg_job_slots == INVALID_JOB_SLOTS || argv_slots != INVALID_JOB_SLOTS)
+      arg_job_slots = old_arg_job_slots;
+
+    else if (jobserver_auth)
+      {
+        /* Makefile MAKEFLAGS set -j, but we already have a jobserver.
+           Make us the master of a new jobserver group.  */
+        if (!restarts)
+          ON (error, NILF,
+              _("warning: -j%d forced in makefile: resetting jobserver mode."),
+              arg_job_slots);
+
+        /* We can't use our parent's jobserver, so reset.  */
+        reset_jobserver ();
+      }
+
+    /* Reset in case the switches changed our mind.  */
+    syncing = (output_sync == OUTPUT_SYNC_LINE
+               || output_sync == OUTPUT_SYNC_TARGET);
+
+    if (make_sync.syncout && ! syncing)
+      output_close (&make_sync);
+
+    make_sync.syncout = syncing;
+    OUTPUT_SET (&make_sync);
+
+    /* If we've disabled builtin rules, get rid of them.  */
+    if (no_builtin_rules_flag && ! old_builtin_rules_flag)
+      {
+        if (suffix_file->builtin)
+          {
+            free_dep_chain (suffix_file->deps);
+            suffix_file->deps = 0;
+          }
+        define_variable_cname ("SUFFIXES", "", o_default, 0);
+      }
+
+    /* If we've disabled builtin variables, get rid of them.  */
+    if (no_builtin_variables_flag && ! old_builtin_variables_flag)
+      undefine_default_variables ();
+  }
+
+  /* Final jobserver configuration.
+
+     If we have jobserver_auth then we are a client in an existing jobserver
+     group, that's already been verified OK above.  If we don't have
+     jobserver_auth and jobserver is enabled, then start a new jobserver.
+
+     arg_job_slots = INVALID_JOB_SLOTS if we don't want -j in MAKEFLAGS
+
+     arg_job_slots = # of jobs of parallelism
+
+     job_slots = 0 for no limits on jobs, or when limiting via jobserver.
+
+     job_slots = 1 for standard non-parallel mode.
+
+     job_slots >1 for old-style parallelism without jobservers.  */
+
+  if (jobserver_auth)
+    job_slots = 0;
+  else if (arg_job_slots == INVALID_JOB_SLOTS)
+    job_slots = 1;
+  else
+    job_slots = arg_job_slots;
+
+#if defined (__MSDOS__) || defined (__EMX__) || defined (VMS)
+  if (job_slots != 1
+# ifdef __EMX__
+      && _osmode != OS2_MODE /* turn off -j if we are in DOS mode */
+# endif
+      )
+    {
+      O (error, NILF,
+         _("Parallel jobs (-j) are not supported on this platform."));
+      O (error, NILF, _("Resetting to single job (-j1) mode."));
+      arg_job_slots = INVALID_JOB_SLOTS;
+      job_slots = 1;
+    }
+#endif
+
+  /* If we have >1 slot at this point, then we're a top-level make.
+     Set up the jobserver.
+
+     Every make assumes that it always has one job it can run.  For the
+     submakes it's the token they were given by their parent.  For the top
+     make, we just subtract one from the number the user wants.  */
+
+  if (job_slots > 1 && jobserver_setup (job_slots - 1))
+    {
+      /* Fill in the jobserver_auth for our children.  */
+      jobserver_auth = jobserver_get_auth ();
+
+      if (jobserver_auth)
+        {
+          /* We're using the jobserver so set job_slots to 0.  */
+          master_job_slots = job_slots;
+          job_slots = 0;
+        }
+    }
+
+  /* If we're not using parallel jobs, then we don't need output sync.
+     This is so people can enable output sync in GNUMAKEFLAGS or similar, but
+     not have it take effect unless parallel builds are enabled.  */
+  if (syncing && job_slots == 1)
+    {
+      OUTPUT_UNSET ();
+      output_close (&make_sync);
+      syncing = 0;
+      output_sync = OUTPUT_SYNC_NONE;
+    }
+
+#ifndef MAKE_SYMLINKS
+  if (check_symlink_flag)
+    {
+      O (error, NILF, _("Symbolic links not supported: disabling -L."));
+      check_symlink_flag = 0;
+    }
+#endif
+
+  /* Set up MAKEFLAGS and MFLAGS again, so they will be right.  */
+
+  define_makeflags (1, 0);
+
+  /* Make each 'struct goaldep' point at the 'struct file' for the file
+     depended on.  Also do magic for special targets.  */
+
+  snap_deps ();
+
+  /* Convert old-style suffix rules to pattern rules.  It is important to
+     do this before installing the built-in pattern rules below, so that
+     makefile-specified suffix rules take precedence over built-in pattern
+     rules.  */
+
+  convert_to_pattern ();
+
+  /* Install the default implicit pattern rules.
+     This used to be done before reading the makefiles.
+     But in that case, built-in pattern rules were in the chain
+     before user-defined ones, so they matched first.  */
+
+  install_default_implicit_rules ();
+
+  /* Compute implicit rule limits.  */
+
+  count_implicit_rule_limits ();
+
+  /* Construct the listings of directories in VPATH lists.  */
+
+  build_vpath_lists ();
+
+  /* Mark files given with -o flags as very old and as having been updated
+     already, and files given with -W flags as brand new (time-stamp as far
+     as possible into the future).  If restarts is set we'll do -W later.  */
+
+  if (old_files != 0)
+    {
+      const char **p;
+      for (p = old_files->list; *p != 0; ++p)
+        {
+          struct file *f = enter_file (*p);
+          f->last_mtime = f->mtime_before_update = OLD_MTIME;
+          f->updated = 1;
+          f->update_status = us_success;
+          f->command_state = cs_finished;
+        }
+    }
+
+  if (!restarts && new_files != 0)
+    {
+      const char **p;
+      for (p = new_files->list; *p != 0; ++p)
+        {
+          struct file *f = enter_file (*p);
+          f->last_mtime = f->mtime_before_update = NEW_MTIME;
+        }
+    }
+
+  /* Initialize the remote job module.  */
+  remote_setup ();
+
+  /* Dump any output we've collected.  */
+
+  OUTPUT_UNSET ();
+  output_close (&make_sync);
+
+  if (read_files)
+    {
+      /* Update any makefiles if necessary.  */
+
+      FILE_TIMESTAMP *makefile_mtimes;
+      char **aargv = NULL;
+      const char **nargv;
+      int nargc;
+      enum update_status status;
+
+      DB (DB_BASIC, (_("Updating makefiles....\n")));
+
+      {
+        struct goaldep *d;
+        unsigned int num_mkfiles = 0;
+        for (d = read_files; d != NULL; d = d->next)
+          ++num_mkfiles;
+
+        makefile_mtimes = alloca (num_mkfiles * sizeof (FILE_TIMESTAMP));
+      }
+
+      /* Remove any makefiles we don't want to try to update.  Record the
+         current modtimes of the others so we can compare them later.  */
+      {
+        struct goaldep *d = read_files;
+        struct goaldep *last = NULL;
+        unsigned int mm_idx = 0;
+
+        while (d != 0)
+          {
+            struct file *f;
+
+            for (f = d->file->double_colon; f != NULL; f = f->prev)
+              if (f->deps == 0 && f->cmds != 0)
+                break;
+
+            if (f)
+              {
+                /* This makefile is a :: target with commands, but no
+                   dependencies.  So, it will always be remade.  This might
+                   well cause an infinite loop, so don't try to remake it.
+                   (This will only happen if your makefiles are written
+                   exceptionally stupidly; but if you work for Athena, that's
+                   how you write your makefiles.)  */
+
+                DB (DB_VERBOSE,
+                    (_("Makefile '%s' might loop; not remaking it.\n"),
+                     f->name));
+
+                if (last)
+                  last->next = d->next;
+                else
+                  read_files = d->next;
+
+                /* Free the storage.  */
+                free_goaldep (d);
+
+                d = last ? last->next : read_files;
+              }
+            else
+              {
+                makefile_mtimes[mm_idx++] = file_mtime_no_search (d->file);
+                last = d;
+                d = d->next;
+              }
+          }
+      }
+
+      /* Set up 'MAKEFLAGS' specially while remaking makefiles.  */
+      define_makeflags (1, 1);
+
+      {
+        int orig_db_level = db_level;
+
+        if (! ISDB (DB_MAKEFILES))
+          db_level = DB_NONE;
+
+        rebuilding_makefiles = 1;
+        status = update_goal_chain (read_files);
+        rebuilding_makefiles = 0;
+
+        db_level = orig_db_level;
+      }
+
+      switch (status)
+        {
+        case us_question:
+          /* The only way this can happen is if the user specified -q and asked
+             for one of the makefiles to be remade as a target on the command
+             line.  Since we're not actually updating anything with -q we can
+             treat this as "did nothing".  */
+
+        case us_none:
+          /* Did nothing.  */
+          break;
+
+        case us_failed:
+          /* Failed to update.  Figure out if we care.  */
+          {
+            /* Nonzero if any makefile was successfully remade.  */
+            int any_remade = 0;
+            /* Nonzero if any makefile we care about failed
+               in updating or could not be found at all.  */
+            int any_failed = 0;
+            unsigned int i;
+            struct goaldep *d;
+
+            for (i = 0, d = read_files; d != 0; ++i, d = d->next)
+              {
+                if (d->file->updated)
+                  {
+                    /* This makefile was updated.  */
+                    if (d->file->update_status == us_success)
+                      {
+                        /* It was successfully updated.  */
+                        any_remade |= (file_mtime_no_search (d->file)
+                                       != makefile_mtimes[i]);
+                      }
+                    else if (! (d->flags & RM_DONTCARE))
+                      {
+                        FILE_TIMESTAMP mtime;
+                        /* The update failed and this makefile was not
+                           from the MAKEFILES variable, so we care.  */
+                        OS (error, NILF, _("Failed to remake makefile '%s'."),
+                            d->file->name);
+                        mtime = file_mtime_no_search (d->file);
+                        any_remade |= (mtime != NONEXISTENT_MTIME
+                                       && mtime != makefile_mtimes[i]);
+                        makefile_status = MAKE_FAILURE;
+                      }
+                  }
+                else
+                  /* This makefile was not found at all.  */
+                  if (! (d->flags & RM_DONTCARE))
+                    {
+                      const char *dnm = dep_name (d);
+                      size_t l = strlen (dnm);
+
+                      /* This is a makefile we care about.  See how much.  */
+                      if (d->flags & RM_INCLUDED)
+                        /* An included makefile.  We don't need to die, but we
+                           do want to complain.  */
+                        error (NILF, l,
+                               _("Included makefile '%s' was not found."), dnm);
+                      else
+                        {
+                          /* A normal makefile.  We must die later.  */
+                          error (NILF, l,
+                                 _("Makefile '%s' was not found"), dnm);
+                          any_failed = 1;
+                        }
+                    }
+              }
+
+            if (any_remade)
+              goto re_exec;
+            if (any_failed)
+              die (MAKE_FAILURE);
+            break;
+          }
+
+        case us_success:
+        re_exec:
+          /* Updated successfully.  Re-exec ourselves.  */
+
+          remove_intermediates (0);
+
+          if (print_data_base_flag)
+            print_data_base ();
+
+          clean_jobserver (0);
+
+          if (makefiles != 0)
+            {
+              /* These names might have changed.  */
+              int i, j = 0;
+              for (i = 1; i < argc; ++i)
+                if (strneq (argv[i], "-f", 2)) /* XXX */
+                  {
+                    if (argv[i][2] == '\0')
+                      /* This cast is OK since we never modify argv.  */
+                      argv[++i] = (char *) makefiles->list[j];
+                    else
+                      argv[i] = xstrdup (concat (2, "-f", makefiles->list[j]));
+                    ++j;
+                  }
+            }
+
+          /* Add -o option for the stdin temporary file, if necessary.  */
+          nargc = argc;
+          if (stdin_nm)
+            {
+              void *m = xmalloc ((nargc + 2) * sizeof (char *));
+              aargv = m;
+              memcpy (aargv, argv, argc * sizeof (char *));
+              aargv[nargc++] = xstrdup (concat (2, "-o", stdin_nm));
+              aargv[nargc] = 0;
+              nargv = m;
+            }
+          else
+            nargv = (const char**)argv;
+
+          if (directories != 0 && directories->idx > 0)
+            {
+              int bad = 1;
+              if (directory_before_chdir != 0)
+                {
+                  if (chdir (directory_before_chdir) < 0)
+                      perror_with_name ("chdir", "");
+                  else
+                    bad = 0;
+                }
+              if (bad)
+                O (fatal, NILF,
+                   _("Couldn't change back to original directory."));
+            }
+
+          ++restarts;
+
+          if (ISDB (DB_BASIC))
+            {
+              const char **p;
+              printf (_("Re-executing[%u]:"), restarts);
+              for (p = nargv; *p != 0; ++p)
+                printf (" %s", *p);
+              putchar ('\n');
+              fflush (stdout);
+            }
+
+#ifndef _AMIGA
+          {
+            char **p;
+            for (p = environ; *p != 0; ++p)
+              {
+                if (strneq (*p, MAKELEVEL_NAME "=", MAKELEVEL_LENGTH+1))
+                  {
+                    *p = alloca (40);
+                    sprintf (*p, "%s=%u", MAKELEVEL_NAME, makelevel);
+#ifdef VMS
+                    vms_putenv_symbol (*p);
+#endif
+                  }
+                else if (strneq (*p, "MAKE_RESTARTS=", CSTRLEN ("MAKE_RESTARTS=")))
+                  {
+                    *p = alloca (40);
+                    sprintf (*p, "MAKE_RESTARTS=%s%u",
+                             OUTPUT_IS_TRACED () ? "-" : "", restarts);
+                    restarts = 0;
+                  }
+              }
+          }
+#else /* AMIGA */
+          {
+            char buffer[256];
+
+            sprintf (buffer, "%u", makelevel);
+            SetVar (MAKELEVEL_NAME, buffer, -1, GVF_GLOBAL_ONLY);
+
+            sprintf (buffer, "%s%u", OUTPUT_IS_TRACED () ? "-" : "", restarts);
+            SetVar ("MAKE_RESTARTS", buffer, -1, GVF_GLOBAL_ONLY);
+            restarts = 0;
+          }
+#endif
+
+          /* If we didn't set the restarts variable yet, add it.  */
+          if (restarts)
+            {
+              char *b = alloca (40);
+              sprintf (b, "MAKE_RESTARTS=%s%u",
+                       OUTPUT_IS_TRACED () ? "-" : "", restarts);
+              putenv (b);
+            }
+
+          fflush (stdout);
+          fflush (stderr);
+
+#ifdef _AMIGA
+          exec_command (nargv);
+          exit (0);
+#elif defined (__EMX__)
+          {
+            /* It is not possible to use execve() here because this
+               would cause the parent process to be terminated with
+               exit code 0 before the child process has been terminated.
+               Therefore it may be the best solution simply to spawn the
+               child process including all file handles and to wait for its
+               termination. */
+            int pid;
+            int r;
+            pid = child_execute_job (NULL, 1, nargv, environ);
+
+            /* is this loop really necessary? */
+            do {
+              pid = wait (&r);
+            } while (pid <= 0);
+            /* use the exit code of the child process */
+            exit (WIFEXITED(r) ? WEXITSTATUS(r) : EXIT_FAILURE);
+          }
+#else
+#ifdef SET_STACK_SIZE
+          /* Reset limits, if necessary.  */
+          if (stack_limit.rlim_cur)
+            setrlimit (RLIMIT_STACK, &stack_limit);
+#endif
+          exec_command ((char **)nargv, environ);
+#endif
+          free (aargv);
+          break;
+        }
+    }
+
+  /* Set up 'MAKEFLAGS' again for the normal targets.  */
+  define_makeflags (1, 0);
+
+  /* Set always_make_flag if -B was given.  */
+  always_make_flag = always_make_set;
+
+  /* If restarts is set we haven't set up -W files yet, so do that now.  */
+  if (restarts && new_files != 0)
+    {
+      const char **p;
+      for (p = new_files->list; *p != 0; ++p)
+        {
+          struct file *f = enter_file (*p);
+          f->last_mtime = f->mtime_before_update = NEW_MTIME;
+        }
+    }
+
+  /* If there is a temp file from reading a makefile from stdin, get rid of
+     it now.  */
+  if (stdin_nm && unlink (stdin_nm) < 0 && errno != ENOENT)
+    perror_with_name (_("unlink (temporary file): "), stdin_nm);
+
+  /* If there were no command-line goals, use the default.  */
+  if (goals == 0)
+    {
+      char *p;
+
+      if (default_goal_var->recursive)
+        p = variable_expand (default_goal_var->value);
+      else
+        {
+          p = variable_buffer_output (variable_buffer, default_goal_var->value,
+                                      strlen (default_goal_var->value));
+          *p = '\0';
+          p = variable_buffer;
+        }
+
+      if (*p != '\0')
+        {
+          struct file *f = lookup_file (p);
+
+          /* If .DEFAULT_GOAL is a non-existent target, enter it into the
+             table and let the standard logic sort it out. */
+          if (f == 0)
+            {
+              struct nameseq *ns;
+
+              ns = PARSE_SIMPLE_SEQ (&p, struct nameseq);
+              if (ns)
+                {
+                  /* .DEFAULT_GOAL should contain one target. */
+                  if (ns->next != 0)
+                    O (fatal, NILF,
+                       _(".DEFAULT_GOAL contains more than one target"));
+
+                  f = enter_file (strcache_add (ns->name));
+
+                  ns->name = 0; /* It was reused by enter_file(). */
+                  free_ns_chain (ns);
+                }
+            }
+
+          if (f)
+            {
+              goals = alloc_goaldep ();
+              goals->file = f;
+            }
+        }
+    }
+  else
+    lastgoal->next = 0;
+
+
+  if (!goals)
+    {
+      struct variable *v = lookup_variable (STRING_SIZE_TUPLE ("MAKEFILE_LIST"));
+      if (v && v->value && v->value[0] != '\0')
+        O (fatal, NILF, _("No targets"));
+
+      O (fatal, NILF, _("No targets specified and no makefile found"));
+    }
+
+  /* Update the goals.  */
+
+  DB (DB_BASIC, (_("Updating goal targets....\n")));
+
+  {
+    switch (update_goal_chain (goals))
+    {
+      case us_none:
+        /* Nothing happened.  */
+        /* FALLTHROUGH */
+      case us_success:
+        /* Keep the previous result.  */
+        break;
+      case us_question:
+        /* We are under -q and would run some commands.  */
+        makefile_status = MAKE_TROUBLE;
+        break;
+      case us_failed:
+        /* Updating failed.  POSIX.2 specifies exit status >1 for this; */
+        makefile_status = MAKE_FAILURE;
+        break;
+    }
+
+    /* If we detected some clock skew, generate one last warning */
+    if (clock_skew_detected)
+      O (error, NILF,
+         _("warning:  Clock skew detected.  Your build may be incomplete."));
+
+    /* Exit.  */
+    die (makefile_status);
+  }
+
+  /* NOTREACHED */
+  exit (MAKE_SUCCESS);
+}
+
+/* Parsing of arguments, decoding of switches.  */
+
+static char options[1 + sizeof (switches) / sizeof (switches[0]) * 3];
+static struct option long_options[(sizeof (switches) / sizeof (switches[0])) +
+                                  (sizeof (long_option_aliases) /
+                                   sizeof (long_option_aliases[0]))];
+
+/* Fill in the string and vector for getopt.  */
+static void
+init_switches (void)
+{
+  char *p;
+  unsigned int c;
+  unsigned int i;
+
+  if (options[0] != '\0')
+    /* Already done.  */
+    return;
+
+  p = options;
+
+  /* Return switch and non-switch args in order, regardless of
+     POSIXLY_CORRECT.  Non-switch args are returned as option 1.  */
+  *p++ = '-';
+
+  for (i = 0; switches[i].c != '\0'; ++i)
+    {
+      long_options[i].name = (switches[i].long_name == 0 ? "" :
+                              switches[i].long_name);
+      long_options[i].flag = 0;
+      long_options[i].val = switches[i].c;
+      if (short_option (switches[i].c))
+        *p++ = switches[i].c;
+      switch (switches[i].type)
+        {
+        case flag:
+        case flag_off:
+        case ignore:
+          long_options[i].has_arg = no_argument;
+          break;
+
+        case string:
+        case strlist:
+        case filename:
+        case positive_int:
+        case floating:
+          if (short_option (switches[i].c))
+            *p++ = ':';
+          if (switches[i].noarg_value != 0)
+            {
+              if (short_option (switches[i].c))
+                *p++ = ':';
+              long_options[i].has_arg = optional_argument;
+            }
+          else
+            long_options[i].has_arg = required_argument;
+          break;
+        }
+    }
+  *p = '\0';
+  for (c = 0; c < (sizeof (long_option_aliases) /
+                   sizeof (long_option_aliases[0]));
+       ++c)
+    long_options[i++] = long_option_aliases[c];
+  long_options[i].name = 0;
+}
+
+
+/* Non-option argument.  It might be a variable definition.  */
+static void
+handle_non_switch_argument (const char *arg, int env)
+{
+  struct variable *v;
+
+  if (arg[0] == '-' && arg[1] == '\0')
+    /* Ignore plain '-' for compatibility.  */
+    return;
+
+#ifdef VMS
+  {
+    /* VMS DCL quoting can result in foo="bar baz" showing up here.
+       Need to remove the double quotes from the value. */
+    char * eq_ptr;
+    char * new_arg;
+    eq_ptr = strchr (arg, '=');
+    if ((eq_ptr != NULL) && (eq_ptr[1] == '"'))
+      {
+         int len;
+         int seg1;
+         int seg2;
+         len = strlen(arg);
+         new_arg = alloca(len);
+         seg1 = eq_ptr - arg + 1;
+         strncpy(new_arg, arg, (seg1));
+         seg2 = len - seg1 - 1;
+         strncpy(&new_arg[seg1], &eq_ptr[2], seg2);
+         new_arg[seg1 + seg2] = 0;
+         if (new_arg[seg1 + seg2 - 1] == '"')
+           new_arg[seg1 + seg2 - 1] = 0;
+         arg = new_arg;
+      }
+  }
+#endif
+  v = try_variable_definition (0, arg, o_command, 0);
+  if (v != 0)
+    {
+      /* It is indeed a variable definition.  If we don't already have this
+         one, record a pointer to the variable for later use in
+         define_makeflags.  */
+      struct command_variable *cv;
+
+      for (cv = command_variables; cv != 0; cv = cv->next)
+        if (cv->variable == v)
+          break;
+
+      if (! cv)
+        {
+          cv = xmalloc (sizeof (*cv));
+          cv->variable = v;
+          cv->next = command_variables;
+          command_variables = cv;
+        }
+    }
+  else if (! env)
+    {
+      /* Not an option or variable definition; it must be a goal
+         target!  Enter it as a file and add it to the dep chain of
+         goals.  */
+      struct file *f = enter_file (strcache_add (expand_command_line_file (arg)));
+      f->cmd_target = 1;
+
+      if (goals == 0)
+        {
+          goals = alloc_goaldep ();
+          lastgoal = goals;
+        }
+      else
+        {
+          lastgoal->next = alloc_goaldep ();
+          lastgoal = lastgoal->next;
+        }
+
+      lastgoal->file = f;
+
+      {
+        /* Add this target name to the MAKECMDGOALS variable. */
+        struct variable *gv;
+        const char *value;
+
+        gv = lookup_variable (STRING_SIZE_TUPLE ("MAKECMDGOALS"));
+        if (gv == 0)
+          value = f->name;
+        else
+          {
+            /* Paste the old and new values together */
+            unsigned int oldlen, newlen;
+            char *vp;
+
+            oldlen = strlen (gv->value);
+            newlen = strlen (f->name);
+            vp = alloca (oldlen + 1 + newlen + 1);
+            memcpy (vp, gv->value, oldlen);
+            vp[oldlen] = ' ';
+            memcpy (&vp[oldlen + 1], f->name, newlen + 1);
+            value = vp;
+          }
+        define_variable_cname ("MAKECMDGOALS", value, o_default, 0);
+      }
+    }
+}
+
+/* Print a nice usage method.  */
+
+static void
+print_usage (int bad)
+{
+  const char *const *cpp;
+  FILE *usageto;
+
+  if (print_version_flag)
+    print_version ();
+
+  usageto = bad ? stderr : stdout;
+
+  fprintf (usageto, _("Usage: %s [options] [target] ...\n"), program);
+
+  for (cpp = usage; *cpp; ++cpp)
+    fputs (_(*cpp), usageto);
+
+  if (!remote_description || *remote_description == '\0')
+    fprintf (usageto, _("\nThis program built for %s\n"), make_host);
+  else
+    fprintf (usageto, _("\nThis program built for %s (%s)\n"),
+             make_host, remote_description);
+
+  fprintf (usageto, _("Report bugs to <bug-make@gnu.org>\n"));
+}
+
+/* Decode switches from ARGC and ARGV.
+   They came from the environment if ENV is nonzero.  */
+
+static void
+decode_switches (int argc, const char **argv, int env)
+{
+  int bad = 0;
+  const struct command_switch *cs;
+  struct stringlist *sl;
+  int c;
+
+  /* getopt does most of the parsing for us.
+     First, get its vectors set up.  */
+
+  init_switches ();
+
+  /* Let getopt produce error messages for the command line,
+     but not for options from the environment.  */
+  opterr = !env;
+  /* Reset getopt's state.  */
+  optind = 0;
+
+  while (optind < argc)
+    {
+      const char *coptarg;
+
+      /* Parse the next argument.  */
+      c = getopt_long (argc, (char*const*)argv, options, long_options, NULL);
+      coptarg = optarg;
+      if (c == EOF)
+        /* End of arguments, or "--" marker seen.  */
+        break;
+      else if (c == 1)
+        /* An argument not starting with a dash.  */
+        handle_non_switch_argument (coptarg, env);
+      else if (c == '?')
+        /* Bad option.  We will print a usage message and die later.
+           But continue to parse the other options so the user can
+           see all he did wrong.  */
+        bad = 1;
+      else
+        for (cs = switches; cs->c != '\0'; ++cs)
+          if (cs->c == c)
+            {
+              /* Whether or not we will actually do anything with
+                 this switch.  We test this individually inside the
+                 switch below rather than just once outside it, so that
+                 options which are to be ignored still consume args.  */
+              int doit = !env || cs->env;
+
+              switch (cs->type)
+                {
+                default:
+                  abort ();
+
+                case ignore:
+                  break;
+
+                case flag:
+                case flag_off:
+                  if (doit)
+                    *(int *) cs->value_ptr = cs->type == flag;
+                  break;
+
+                case string:
+                case strlist:
+                case filename:
+                  if (!doit)
+                    break;
+
+                  if (! coptarg)
+                    coptarg = xstrdup (cs->noarg_value);
+                  else if (*coptarg == '\0')
+                    {
+                      char opt[2] = "c";
+                      const char *op = opt;
+
+                      if (short_option (cs->c))
+                        opt[0] = cs->c;
+                      else
+                        op = cs->long_name;
+
+                      error (NILF, strlen (op),
+                             _("the '%s%s' option requires a non-empty string argument"),
+                             short_option (cs->c) ? "-" : "--", op);
+                      bad = 1;
+                      break;
+                    }
+
+                  if (cs->type == string)
+                    {
+                      char **val = (char **)cs->value_ptr;
+                      free (*val);
+                      *val = xstrdup (coptarg);
+                      break;
+                    }
+
+                  sl = *(struct stringlist **) cs->value_ptr;
+                  if (sl == 0)
+                    {
+                      sl = xmalloc (sizeof (struct stringlist));
+                      sl->max = 5;
+                      sl->idx = 0;
+                      sl->list = xmalloc (5 * sizeof (char *));
+                      *(struct stringlist **) cs->value_ptr = sl;
+                    }
+                  else if (sl->idx == sl->max - 1)
+                    {
+                      sl->max += 5;
+                      /* MSVC erroneously warns without a cast here.  */
+                      sl->list = xrealloc ((void *)sl->list,
+                                           sl->max * sizeof (char *));
+                    }
+                  if (cs->type == filename)
+                    sl->list[sl->idx++] = expand_command_line_file (coptarg);
+                  else
+                    sl->list[sl->idx++] = xstrdup (coptarg);
+                  sl->list[sl->idx] = 0;
+                  break;
+
+                case positive_int:
+                  /* See if we have an option argument; if we do require that
+                     it's all digits, not something like "10foo".  */
+                  if (coptarg == 0 && argc > optind)
+                    {
+                      const char *cp;
+                      for (cp=argv[optind]; ISDIGIT (cp[0]); ++cp)
+                        ;
+                      if (cp[0] == '\0')
+                        coptarg = argv[optind++];
+                    }
+
+                  if (!doit)
+                    break;
+
+                  if (coptarg)
+                    {
+                      int i = atoi (coptarg);
+                      const char *cp;
+
+                      /* Yes, I realize we're repeating this in some cases.  */
+                      for (cp = coptarg; ISDIGIT (cp[0]); ++cp)
+                        ;
+
+                      if (i < 1 || cp[0] != '\0')
+                        {
+                          error (NILF, 0,
+                                 _("the '-%c' option requires a positive integer argument"),
+                                 cs->c);
+                          bad = 1;
+                        }
+                      else
+                        *(unsigned int *) cs->value_ptr = i;
+                    }
+                  else
+                    *(unsigned int *) cs->value_ptr
+                      = *(unsigned int *) cs->noarg_value;
+                  break;
+
+                case floating:
+                  if (coptarg == 0 && optind < argc
+                      && (ISDIGIT (argv[optind][0]) || argv[optind][0] == '.'))
+                    coptarg = argv[optind++];
+
+                  if (doit)
+                    *(double *) cs->value_ptr
+                      = (coptarg != 0 ? atof (coptarg)
+                         : *(double *) cs->noarg_value);
+
+                  break;
+                }
+
+              /* We've found the switch.  Stop looking.  */
+              break;
+            }
+    }
+
+  /* There are no more options according to getting getopt, but there may
+     be some arguments left.  Since we have asked for non-option arguments
+     to be returned in order, this only happens when there is a "--"
+     argument to prevent later arguments from being options.  */
+  while (optind < argc)
+    handle_non_switch_argument (argv[optind++], env);
+
+  if (!env && (bad || print_usage_flag))
+    {
+      print_usage (bad);
+      die (bad ? MAKE_FAILURE : MAKE_SUCCESS);
+    }
+
+  /* If there are any options that need to be decoded do it now.  */
+  decode_debug_flags ();
+  decode_output_sync_flags ();
+}
+
+/* Decode switches from environment variable ENVAR (which is LEN chars long).
+   We do this by chopping the value into a vector of words, prepending a
+   dash to the first word if it lacks one, and passing the vector to
+   decode_switches.  */
+
+static void
+decode_env_switches (const char *envar, unsigned int len)
+{
+  char *varref = alloca (2 + len + 2);
+  char *value, *p, *buf;
+  int argc;
+  const char **argv;
+
+  /* Get the variable's value.  */
+  varref[0] = '$';
+  varref[1] = '(';
+  memcpy (&varref[2], envar, len);
+  varref[2 + len] = ')';
+  varref[2 + len + 1] = '\0';
+  value = variable_expand (varref);
+
+  /* Skip whitespace, and check for an empty value.  */
+  NEXT_TOKEN (value);
+  len = strlen (value);
+  if (len == 0)
+    return;
+
+  /* Allocate a vector that is definitely big enough.  */
+  argv = alloca ((1 + len + 1) * sizeof (char *));
+
+  /* getopt will look at the arguments starting at ARGV[1].
+     Prepend a spacer word.  */
+  argv[0] = 0;
+  argc = 1;
+
+  /* We need a buffer to copy the value into while we split it into words
+     and unquote it.  Set up in case we need to prepend a dash later.  */
+  buf = alloca (1 + len + 1);
+  buf[0] = '-';
+  p = buf+1;
+  argv[argc] = p;
+  while (*value != '\0')
+    {
+      if (*value == '\\' && value[1] != '\0')
+        ++value;                /* Skip the backslash.  */
+      else if (ISBLANK (*value))
+        {
+          /* End of the word.  */
+          *p++ = '\0';
+          argv[++argc] = p;
+          do
+            ++value;
+          while (ISBLANK (*value));
+          continue;
+        }
+      *p++ = *value++;
+    }
+  *p = '\0';
+  argv[++argc] = 0;
+  assert (p < buf + len + 2);
+
+  if (argv[1][0] != '-' && strchr (argv[1], '=') == 0)
+    /* The first word doesn't start with a dash and isn't a variable
+       definition, so add a dash.  */
+    argv[1] = buf;
+
+  /* Parse those words.  */
+  decode_switches (argc, argv, 1);
+}
+
+/* Quote the string IN so that it will be interpreted as a single word with
+   no magic by decode_env_switches; also double dollar signs to avoid
+   variable expansion in make itself.  Write the result into OUT, returning
+   the address of the next character to be written.
+   Allocating space for OUT twice the length of IN is always sufficient.  */
+
+static char *
+quote_for_env (char *out, const char *in)
+{
+  while (*in != '\0')
+    {
+      if (*in == '$')
+        *out++ = '$';
+      else if (ISBLANK (*in) || *in == '\\')
+        *out++ = '\\';
+      *out++ = *in++;
+    }
+
+  return out;
+}
+
+/* Define the MAKEFLAGS and MFLAGS variables to reflect the settings of the
+   command switches.  Include options with args if ALL is nonzero.
+   Don't include options with the 'no_makefile' flag set if MAKEFILE.  */
+
+static struct variable *
+define_makeflags (int all, int makefile)
+{
+  const char ref[] = "$(MAKEOVERRIDES)";
+  const char posixref[] = "$(-*-command-variables-*-)";
+  const char evalref[] = "$(-*-eval-flags-*-)";
+  const struct command_switch *cs;
+  char *flagstring;
+  char *p;
+
+  /* We will construct a linked list of 'struct flag's describing
+     all the flags which need to go in MAKEFLAGS.  Then, once we
+     know how many there are and their lengths, we can put them all
+     together in a string.  */
+
+  struct flag
+    {
+      struct flag *next;
+      const struct command_switch *cs;
+      const char *arg;
+    };
+  struct flag *flags = 0;
+  struct flag *last = 0;
+  unsigned int flagslen = 0;
+#define ADD_FLAG(ARG, LEN) \
+  do {                                                                        \
+    struct flag *new = alloca (sizeof (struct flag));                         \
+    new->cs = cs;                                                             \
+    new->arg = (ARG);                                                         \
+    new->next = 0;                                                            \
+    if (! flags)                                                              \
+      flags = new;                                                            \
+    else                                                                      \
+      last->next = new;                                                       \
+    last = new;                                                               \
+    if (new->arg == 0)                                                        \
+      /* Just a single flag letter: " -x"  */                                 \
+      flagslen += 3;                                                          \
+    else                                                                      \
+      /* " -xfoo", plus space to escape "foo".  */                            \
+      flagslen += 1 + 1 + 1 + (3 * (LEN));                                    \
+    if (!short_option (cs->c))                                                \
+      /* This switch has no single-letter version, so we use the long.  */    \
+      flagslen += 2 + strlen (cs->long_name);                                 \
+  } while (0)
+
+  for (cs = switches; cs->c != '\0'; ++cs)
+    if (cs->toenv && (!makefile || !cs->no_makefile))
+      switch (cs->type)
+        {
+        case ignore:
+          break;
+
+        case flag:
+        case flag_off:
+          if ((!*(int *) cs->value_ptr) == (cs->type == flag_off)
+              && (cs->default_value == 0
+                  || *(int *) cs->value_ptr != *(int *) cs->default_value))
+            ADD_FLAG (0, 0);
+          break;
+
+        case positive_int:
+          if (all)
+            {
+              if ((cs->default_value != 0
+                   && (*(unsigned int *) cs->value_ptr
+                       == *(unsigned int *) cs->default_value)))
+                break;
+              else if (cs->noarg_value != 0
+                       && (*(unsigned int *) cs->value_ptr ==
+                           *(unsigned int *) cs->noarg_value))
+                ADD_FLAG ("", 0); /* Optional value omitted; see below.  */
+              else
+                {
+                  char *buf = alloca (30);
+                  sprintf (buf, "%u", *(unsigned int *) cs->value_ptr);
+                  ADD_FLAG (buf, strlen (buf));
+                }
+            }
+          break;
+
+        case floating:
+          if (all)
+            {
+              if (cs->default_value != 0
+                  && (*(double *) cs->value_ptr
+                      == *(double *) cs->default_value))
+                break;
+              else if (cs->noarg_value != 0
+                       && (*(double *) cs->value_ptr
+                           == *(double *) cs->noarg_value))
+                ADD_FLAG ("", 0); /* Optional value omitted; see below.  */
+              else
+                {
+                  char *buf = alloca (100);
+                  sprintf (buf, "%g", *(double *) cs->value_ptr);
+                  ADD_FLAG (buf, strlen (buf));
+                }
+            }
+          break;
+
+        case string:
+          if (all)
+            {
+              p = *((char **)cs->value_ptr);
+              if (p)
+                ADD_FLAG (p, strlen (p));
+            }
+          break;
+
+        case filename:
+        case strlist:
+          if (all)
+            {
+              struct stringlist *sl = *(struct stringlist **) cs->value_ptr;
+              if (sl != 0)
+                {
+                  unsigned int i;
+                  for (i = 0; i < sl->idx; ++i)
+                    ADD_FLAG (sl->list[i], strlen (sl->list[i]));
+                }
+            }
+          break;
+
+        default:
+          abort ();
+        }
+
+#undef  ADD_FLAG
+
+  /* Four more for the possible " -- ", plus variable references.  */
+  flagslen += 4 + CSTRLEN (posixref) + 1 + CSTRLEN (evalref) + 1;
+
+  /* Construct the value in FLAGSTRING.
+     We allocate enough space for a preceding dash and trailing null.  */
+  flagstring = alloca (1 + flagslen + 1);
+  memset (flagstring, '\0', 1 + flagslen + 1);
+  p = flagstring;
+
+  /* Start with a dash, for MFLAGS.  */
+  *p++ = '-';
+
+  /* Add simple options as a group.  */
+  while (flags != 0 && !flags->arg && short_option (flags->cs->c))
+    {
+      *p++ = flags->cs->c;
+      flags = flags->next;
+    }
+
+  /* Now add more complex flags: ones with options and/or long names.  */
+  while (flags)
+    {
+      *p++ = ' ';
+      *p++ = '-';
+
+      /* Add the flag letter or name to the string.  */
+      if (short_option (flags->cs->c))
+        *p++ = flags->cs->c;
+      else
+        {
+          /* Long options require a double-dash.  */
+          *p++ = '-';
+          strcpy (p, flags->cs->long_name);
+          p += strlen (p);
+        }
+      /* An omitted optional argument has an ARG of "".  */
+      if (flags->arg && flags->arg[0] != '\0')
+        {
+          if (!short_option (flags->cs->c))
+            /* Long options require '='.  */
+            *p++ = '=';
+          p = quote_for_env (p, flags->arg);
+        }
+      flags = flags->next;
+    }
+
+  /* If no flags at all, get rid of the initial dash.  */
+  if (p == &flagstring[1])
+    {
+      flagstring[0] = '\0';
+      p = flagstring;
+    }
+
+  /* Define MFLAGS before appending variable definitions.  Omit an initial
+     empty dash.  Since MFLAGS is not parsed for flags, there is no reason to
+     override any makefile redefinition.  */
+  define_variable_cname ("MFLAGS",
+                         flagstring + (flagstring[0] == '-' && flagstring[1] == ' ' ? 2 : 0),
+                         o_env, 1);
+
+  /* Write a reference to -*-eval-flags-*-, which contains all the --eval
+     flag options.  */
+  if (eval_strings)
+    {
+      *p++ = ' ';
+      memcpy (p, evalref, CSTRLEN (evalref));
+      p += CSTRLEN (evalref);
+    }
+
+  if (all && command_variables)
+    {
+      /* Write a reference to $(MAKEOVERRIDES), which contains all the
+         command-line variable definitions.  Separate the variables from the
+         switches with a "--" arg.  */
+
+      strcpy (p, " -- ");
+      p += 4;
+
+      /* Copy in the string.  */
+      if (posix_pedantic)
+        {
+          memcpy (p, posixref, CSTRLEN (posixref));
+          p += CSTRLEN (posixref);
+        }
+      else
+        {
+          memcpy (p, ref, CSTRLEN (ref));
+          p += CSTRLEN (ref);
+        }
+    }
+
+  /* If there is a leading dash, omit it.  */
+  if (flagstring[0] == '-')
+    ++flagstring;
+
+  /* This used to use o_env, but that lost when a makefile defined MAKEFLAGS.
+     Makefiles set MAKEFLAGS to add switches, but we still want to redefine
+     its value with the full set of switches.  Then we used o_file, but that
+     lost when users added -e, causing a previous MAKEFLAGS env. var. to take
+     precedence over the new one.  Of course, an override or command
+     definition will still take precedence.  */
+  return define_variable_cname ("MAKEFLAGS", flagstring,
+                                env_overrides ? o_env_override : o_file, 1);
+}
+
+/* Print version information.  */
+
+static void
+print_version (void)
+{
+  static int printed_version = 0;
+
+  const char *precede = print_data_base_flag ? "# " : "";
+
+  if (printed_version)
+    /* Do it only once.  */
+    return;
+
+  printf ("%sGNU Make %s\n", precede, version_string);
+
+  if (!remote_description || *remote_description == '\0')
+    printf (_("%sBuilt for %s\n"), precede, make_host);
+  else
+    printf (_("%sBuilt for %s (%s)\n"),
+            precede, make_host, remote_description);
+
+  /* Print this untranslated.  The coding standards recommend translating the
+     (C) to the copyright symbol, but this string is going to change every
+     year, and none of the rest of it should be translated (including the
+     word "Copyright"), so it hardly seems worth it.  */
+
+  printf ("%sCopyright (C) 1988-2017 Free Software Foundation, Inc.\n",
+          precede);
+
+  printf (_("%sLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n\
+%sThis is free software: you are free to change and redistribute it.\n\
+%sThere is NO WARRANTY, to the extent permitted by law.\n"),
+            precede, precede, precede);
+
+  printed_version = 1;
+
+  /* Flush stdout so the user doesn't have to wait to see the
+     version information while make thinks about things.  */
+  fflush (stdout);
+}
+
+/* Print a bunch of information about this and that.  */
+
+static void
+print_data_base (void)
+{
+  time_t when = time ((time_t *) 0);
+
+  print_version ();
+
+  printf (_("\n# Make data base, printed on %s"), ctime (&when));
+
+  print_variable_data_base ();
+  print_dir_data_base ();
+  print_rule_data_base ();
+  print_file_data_base ();
+  print_vpath_data_base ();
+  strcache_print_stats ("#");
+
+  when = time ((time_t *) 0);
+  printf (_("\n# Finished Make data base on %s\n"), ctime (&when));
+}
+
+static void
+clean_jobserver (int status)
+{
+  /* Sanity: have we written all our jobserver tokens back?  If our
+     exit status is 2 that means some kind of syntax error; we might not
+     have written all our tokens so do that now.  If tokens are left
+     after any other error code, that's bad.  */
+
+  if (jobserver_enabled() && jobserver_tokens)
+    {
+      if (status != 2)
+        ON (error, NILF,
+            "INTERNAL: Exiting with %u jobserver tokens (should be 0)!",
+            jobserver_tokens);
+      else
+        /* Don't write back the "free" token */
+        while (--jobserver_tokens)
+          jobserver_release (0);
+    }
+
+
+  /* Sanity: If we're the master, were all the tokens written back?  */
+
+  if (master_job_slots)
+    {
+      /* We didn't write one for ourself, so start at 1.  */
+      unsigned int tokens = 1 + jobserver_acquire_all ();
+
+      if (tokens != master_job_slots)
+        ONN (error, NILF,
+             "INTERNAL: Exiting with %u jobserver tokens available; should be %u!",
+             tokens, master_job_slots);
+
+      reset_jobserver ();
+    }
+}
+
+/* Exit with STATUS, cleaning up as necessary.  */
+
+void
+die (int status)
+{
+  static char dying = 0;
+
+  if (!dying)
+    {
+      int err;
+
+      dying = 1;
+
+      if (print_version_flag)
+        print_version ();
+
+      /* Wait for children to die.  */
+      err = (status != 0);
+      while (job_slots_used > 0)
+        reap_children (1, err);
+
+      /* Let the remote job module clean up its state.  */
+      remote_cleanup ();
+
+      /* Remove the intermediate files.  */
+      remove_intermediates (0);
+
+      if (print_data_base_flag)
+        print_data_base ();
+
+      if (verify_flag)
+        verify_file_data_base ();
+
+      clean_jobserver (status);
+
+      if (output_context)
+        {
+          /* die() might be called in a recipe output context due to an
+             $(error ...) function.  */
+          output_close (output_context);
+
+          if (output_context != &make_sync)
+            output_close (&make_sync);
+
+          OUTPUT_UNSET ();
+        }
+
+      output_close (NULL);
+
+      /* Try to move back to the original directory.  This is essential on
+         MS-DOS (where there is really only one process), and on Unix it
+         puts core files in the original directory instead of the -C
+         directory.  Must wait until after remove_intermediates(), or unlinks
+         of relative pathnames fail.  */
+      if (directory_before_chdir != 0)
+        {
+          /* If it fails we don't care: shut up GCC.  */
+          int _x UNUSED;
+          _x = chdir (directory_before_chdir);
+        }
+    }
+
+  exit (status);
+}
diff --git a/src/makeint.h b/src/makeint.h
new file mode 100644
index 0000000..2adab63
--- /dev/null
+++ b/src/makeint.h
@@ -0,0 +1,794 @@
+/* Miscellaneous global declarations and portability cruft for GNU Make.
+Copyright (C) 1988-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* We use <config.h> instead of "config.h" so that a compilation
+   using -I. -I$srcdir will use ./config.h rather than $srcdir/config.h
+   (which it would do because makeint.h was found in $srcdir).  */
+#include <config.h>
+#undef  HAVE_CONFIG_H
+#define HAVE_CONFIG_H 1
+
+/* Specify we want GNU source code.  This must be defined before any
+   system headers are included.  */
+
+#define _GNU_SOURCE 1
+
+/* AIX requires this to be the first thing in the file.  */
+#if HAVE_ALLOCA_H
+# include <alloca.h>
+#else
+# ifdef _AIX
+ #pragma alloca
+# else
+#  if !defined(__GNUC__) && !defined(WINDOWS32)
+#   ifndef alloca /* predefined by HP cc +Olibcalls */
+char *alloca ();
+#   endif
+#  endif
+# endif
+#endif
+
+/* Disable assert() unless we're a maintainer.
+   Some asserts are compute-intensive.  */
+#ifndef MAKE_MAINTAINER_MODE
+# define NDEBUG 1
+#endif
+
+/* Include the externally-visible content.
+   Be sure to use the local one, and not one installed on the system.
+   Define GMK_BUILDING_MAKE for proper selection of dllexport/dllimport
+   declarations for MS-Windows.  */
+#ifdef WINDOWS32
+# define GMK_BUILDING_MAKE
+#endif
+#include "gnumake.h"
+
+#ifdef  CRAY
+/* This must happen before #include <signal.h> so
+   that the declaration therein is changed.  */
+# define signal bsdsignal
+#endif
+
+/* If we're compiling for the dmalloc debugger, turn off string inlining.  */
+#if defined(HAVE_DMALLOC_H) && defined(__GNUC__)
+# define __NO_STRING_INLINES
+#endif
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <signal.h>
+#include <stdio.h>
+#include <ctype.h>
+
+#ifdef HAVE_SYS_TIMEB_H
+/* SCO 3.2 "devsys 4.2" has a prototype for 'ftime' in <time.h> that bombs
+   unless <sys/timeb.h> has been included first.  */
+# include <sys/timeb.h>
+#endif
+#if TIME_WITH_SYS_TIME
+# include <sys/time.h>
+# include <time.h>
+#else
+# if HAVE_SYS_TIME_H
+#  include <sys/time.h>
+# else
+#  include <time.h>
+# endif
+#endif
+
+#include <errno.h>
+
+#ifndef errno
+extern int errno;
+#endif
+
+#ifdef __VMS
+/* In strict ANSI mode, VMS compilers should not be defining the
+   VMS macro.  Define it here instead of a bulk edit for the correct code.
+ */
+# ifndef VMS
+#  define VMS
+# endif
+#endif
+
+#ifdef  HAVE_UNISTD_H
+# include <unistd.h>
+/* Ultrix's unistd.h always defines _POSIX_VERSION, but you only get
+   POSIX.1 behavior with 'cc -YPOSIX', which predefines POSIX itself!  */
+# if defined (_POSIX_VERSION) && !defined (ultrix) && !defined (VMS)
+#  define POSIX 1
+# endif
+#endif
+
+/* Some systems define _POSIX_VERSION but are not really POSIX.1.  */
+#if (defined (butterfly) || defined (__arm) || (defined (__mips) && defined (_SYSTYPE_SVR3)) || (defined (sequent) && defined (i386)))
+# undef POSIX
+#endif
+
+#if !defined (POSIX) && defined (_AIX) && defined (_POSIX_SOURCE)
+# define POSIX 1
+#endif
+
+#ifndef RETSIGTYPE
+# define RETSIGTYPE     void
+#endif
+
+#ifndef sigmask
+# define sigmask(sig)   (1 << ((sig) - 1))
+#endif
+
+#ifndef HAVE_SA_RESTART
+# define SA_RESTART 0
+#endif
+
+#ifdef HAVE_VFORK_H
+# include <vfork.h>
+#endif
+
+#ifdef  HAVE_LIMITS_H
+# include <limits.h>
+#endif
+#ifdef  HAVE_SYS_PARAM_H
+# include <sys/param.h>
+#endif
+
+#ifndef PATH_MAX
+# ifndef POSIX
+#  define PATH_MAX      MAXPATHLEN
+# endif
+#endif
+#ifndef MAXPATHLEN
+# define MAXPATHLEN 1024
+#endif
+
+#ifdef  PATH_MAX
+# define GET_PATH_MAX   PATH_MAX
+# define PATH_VAR(var)  char var[PATH_MAX+1]
+#else
+# define NEED_GET_PATH_MAX 1
+# define GET_PATH_MAX   (get_path_max ())
+# define PATH_VAR(var)  char *var = alloca (GET_PATH_MAX+1)
+unsigned int get_path_max (void);
+#endif
+
+#ifndef CHAR_BIT
+# define CHAR_BIT 8
+#endif
+
+#ifndef USHRT_MAX
+# define USHRT_MAX 65535
+#endif
+
+/* Nonzero if the integer type T is signed.
+   Use <= to avoid GCC warnings about always-false expressions.  */
+#define INTEGER_TYPE_SIGNED(t) ((t) -1 <= 0)
+
+/* The minimum and maximum values for the integer type T.
+   Use ~ (t) 0, not -1, for portability to 1's complement hosts.  */
+#define INTEGER_TYPE_MINIMUM(t) \
+  (! INTEGER_TYPE_SIGNED (t) ? (t) 0 : ~ (t) 0 << (sizeof (t) * CHAR_BIT - 1))
+#define INTEGER_TYPE_MAXIMUM(t) (~ (t) 0 - INTEGER_TYPE_MINIMUM (t))
+
+#ifndef CHAR_MAX
+# define CHAR_MAX INTEGER_TYPE_MAXIMUM (char)
+#endif
+
+#ifdef STAT_MACROS_BROKEN
+# ifdef S_ISREG
+#  undef S_ISREG
+# endif
+# ifdef S_ISDIR
+#  undef S_ISDIR
+# endif
+#endif  /* STAT_MACROS_BROKEN.  */
+
+#ifndef S_ISREG
+# define S_ISREG(mode)  (((mode) & S_IFMT) == S_IFREG)
+#endif
+#ifndef S_ISDIR
+# define S_ISDIR(mode)  (((mode) & S_IFMT) == S_IFDIR)
+#endif
+
+#ifdef VMS
+# include <fcntl.h>
+# include <types.h>
+# include <unixlib.h>
+# include <unixio.h>
+# include <perror.h>
+/* Needed to use alloca on VMS.  */
+# include <builtins.h>
+
+extern int vms_use_mcr_command;
+extern int vms_always_use_cmd_file;
+extern int vms_gnv_shell;
+extern int vms_comma_separator;
+extern int vms_legacy_behavior;
+extern int vms_unix_simulation;
+#endif
+
+#ifndef __attribute__
+/* This feature is available in gcc versions 2.5 and later.  */
+# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 5) || __STRICT_ANSI__
+#  define __attribute__(x)
+# endif
+/* The __-protected variants of 'format' and 'printf' attributes
+   are accepted by gcc versions 2.6.4 (effectively 2.7) and later.  */
+# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7)
+#  define __format__ format
+#  define __printf__ printf
+# endif
+#endif
+#define UNUSED  __attribute__ ((unused))
+
+#if defined (STDC_HEADERS) || defined (__GNU_LIBRARY__)
+# include <stdlib.h>
+# include <string.h>
+# define ANSI_STRING 1
+#else   /* No standard headers.  */
+# ifdef HAVE_STRING_H
+#  include <string.h>
+#  define ANSI_STRING 1
+# else
+#  include <strings.h>
+# endif
+# ifdef HAVE_MEMORY_H
+#  include <memory.h>
+# endif
+# ifdef HAVE_STDLIB_H
+#  include <stdlib.h>
+# else
+void *malloc (int);
+void *realloc (void *, int);
+void free (void *);
+
+void abort (void) __attribute__ ((noreturn));
+void exit (int) __attribute__ ((noreturn));
+# endif /* HAVE_STDLIB_H.  */
+
+#endif /* Standard headers.  */
+
+/* These should be in stdlib.h.  Make sure we have them.  */
+#ifndef EXIT_SUCCESS
+# define EXIT_SUCCESS 0
+#endif
+#ifndef EXIT_FAILURE
+# define EXIT_FAILURE 1
+#endif
+
+#ifndef  ANSI_STRING
+
+/* SCO Xenix has a buggy macro definition in <string.h>.  */
+#undef  strerror
+#if !defined(__DECC)
+char *strerror (int errnum);
+#endif
+
+#endif  /* !ANSI_STRING.  */
+#undef  ANSI_STRING
+
+#if HAVE_INTTYPES_H
+# include <inttypes.h>
+#endif
+#if HAVE_STDINT_H
+# include <stdint.h>
+#endif
+#define FILE_TIMESTAMP uintmax_t
+
+#if !defined(HAVE_STRSIGNAL)
+char *strsignal (int signum);
+#endif
+
+#if defined(HAVE_UMASK)
+# define UMASK(_m)  umask (_m)
+# define MODE_T     mode_t
+#else
+# define UMASK(_m)  0
+# define MODE_T     int
+#endif
+
+/* ISDIGIT offers the following features:
+   - Its arg may be any int or unsigned int; it need not be an unsigned char.
+   - It's guaranteed to evaluate its argument exactly once.
+      NOTE!  Make relies on this behavior, don't change it!
+   - It's typically faster.
+   POSIX 1003.2-1992 section 2.5.2.1 page 50 lines 1556-1558 says that
+   only '0' through '9' are digits.  Prefer ISDIGIT to isdigit() unless
+   it's important to use the locale's definition of 'digit' even when the
+   host does not conform to POSIX.  */
+#define ISDIGIT(c) ((unsigned) (c) - '0' <= 9)
+
+/* Test if two strings are equal. Is this worthwhile?  Should be profiled.  */
+#define streq(a, b) \
+   ((a) == (b) || \
+    (*(a) == *(b) && (*(a) == '\0' || !strcmp ((a) + 1, (b) + 1))))
+
+/* Test if two strings are equal, but match case-insensitively on systems
+   which have case-insensitive filesystems.  Should only be used for
+   filenames!  */
+#ifdef HAVE_CASE_INSENSITIVE_FS
+# define patheq(a, b) \
+    ((a) == (b) \
+     || (tolower((unsigned char)*(a)) == tolower((unsigned char)*(b)) \
+         && (*(a) == '\0' || !strcasecmp ((a) + 1, (b) + 1))))
+#else
+# define patheq(a, b) streq(a, b)
+#endif
+
+#define strneq(a, b, l) (strncmp ((a), (b), (l)) == 0)
+
+#if defined(__GNUC__) || defined(ENUM_BITFIELDS)
+# define ENUM_BITFIELD(bits)    :bits
+#else
+# define ENUM_BITFIELD(bits)
+#endif
+
+/* Handle gettext and locales.  */
+
+#if HAVE_LOCALE_H
+# include <locale.h>
+#else
+# define setlocale(category, locale)
+#endif
+
+#include <gettext.h>
+
+#define _(msgid)            gettext (msgid)
+#define N_(msgid)           gettext_noop (msgid)
+#define S_(msg1,msg2,num)   ngettext (msg1,msg2,num)
+
+/* This is needed for getcwd() and chdir(), on some W32 systems.  */
+#if defined(HAVE_DIRECT_H)
+# include <direct.h>
+#endif
+
+#ifdef WINDOWS32
+# include <fcntl.h>
+# include <malloc.h>
+# define pipe(_p)        _pipe((_p), 512, O_BINARY)
+# define kill(_pid,_sig) w32_kill((_pid),(_sig))
+/* MSVC and Watcom C don't have ftruncate.  */
+# if defined(_MSC_VER) || defined(__WATCOMC__)
+#  define ftruncate(_fd,_len) _chsize(_fd,_len)
+# endif
+/* MinGW64 doesn't have _S_ISDIR.  */
+# ifndef _S_ISDIR
+#  define _S_ISDIR(m)  S_ISDIR(m)
+# endif
+
+void sync_Path_environment (void);
+int w32_kill (pid_t pid, int sig);
+int find_and_set_default_shell (const char *token);
+
+/* indicates whether or not we have Bourne shell */
+extern int no_default_sh_exe;
+
+/* is default_shell unixy? */
+extern int unixy_shell;
+
+/* We don't have a preferred fixed value for LOCALEDIR.  */
+# ifndef LOCALEDIR
+#  define LOCALEDIR NULL
+# endif
+
+/* Include only the minimal stuff from windows.h.   */
+# define WIN32_LEAN_AND_MEAN
+#endif  /* WINDOWS32 */
+
+#define ANY_SET(_v,_m)  (((_v)&(_m)) != 0)
+#define NONE_SET(_v,_m) (! ANY_SET ((_v),(_m)))
+
+#define MAP_NUL         0x0001
+#define MAP_BLANK       0x0002
+#define MAP_NEWLINE     0x0004
+#define MAP_COMMENT     0x0008
+#define MAP_SEMI        0x0010
+#define MAP_EQUALS      0x0020
+#define MAP_COLON       0x0040
+#define MAP_VARSEP      0x0080
+#define MAP_PIPE        0x0100
+#define MAP_DOT         0x0200
+#define MAP_COMMA       0x0400
+
+/* These are the valid characters for a user-defined function.  */
+#define MAP_USERFUNC    0x2000
+/* This means not only a '$', but skip the variable reference.  */
+#define MAP_VARIABLE    0x4000
+/* The set of characters which are directory separators is OS-specific.  */
+#define MAP_DIRSEP      0x8000
+
+#ifdef VMS
+# define MAP_VMSCOMMA   MAP_COMMA
+#else
+# define MAP_VMSCOMMA   0x0000
+#endif
+
+#define MAP_SPACE       (MAP_BLANK|MAP_NEWLINE)
+
+/* Handle other OSs.
+   To overcome an issue parsing paths in a DOS/Windows environment when
+   built in a unix based environment, override the PATH_SEPARATOR_CHAR
+   definition unless being built for Cygwin. */
+#if defined(HAVE_DOS_PATHS) && !defined(__CYGWIN__)
+# undef PATH_SEPARATOR_CHAR
+# define PATH_SEPARATOR_CHAR ';'
+# define MAP_PATHSEP    MAP_SEMI
+#elif !defined(PATH_SEPARATOR_CHAR)
+# if defined (VMS)
+#  define PATH_SEPARATOR_CHAR (vms_comma_separator ? ',' : ':')
+#  define MAP_PATHSEP    (vms_comma_separator ? MAP_COMMA : MAP_SEMI)
+# else
+#  define PATH_SEPARATOR_CHAR ':'
+#  define MAP_PATHSEP    MAP_COLON
+# endif
+#elif PATH_SEPARATOR_CHAR == ':'
+# define MAP_PATHSEP     MAP_COLON
+#elif PATH_SEPARATOR_CHAR == ';'
+# define MAP_PATHSEP     MAP_SEMI
+#elif PATH_SEPARATOR_CHAR == ','
+# define MAP_PATHSEP     MAP_COMMA
+#else
+# error "Unknown PATH_SEPARATOR_CHAR"
+#endif
+
+#define STOP_SET(_v,_m) ANY_SET(stopchar_map[(unsigned char)(_v)],(_m))
+
+#define ISBLANK(c)      STOP_SET((c),MAP_BLANK)
+#define ISSPACE(c)      STOP_SET((c),MAP_SPACE)
+#define NEXT_TOKEN(s)   while (ISSPACE (*(s))) ++(s)
+#define END_OF_TOKEN(s) while (! STOP_SET (*(s), MAP_SPACE|MAP_NUL)) ++(s)
+
+#if defined(HAVE_SYS_RESOURCE_H) && defined(HAVE_GETRLIMIT) && defined(HAVE_SETRLIMIT)
+# define SET_STACK_SIZE
+#endif
+#ifdef SET_STACK_SIZE
+# include <sys/resource.h>
+extern struct rlimit stack_limit;
+#endif
+
+#include <glob.h>
+
+#define NILF ((floc *)0)
+
+#define CSTRLEN(_s)           (sizeof (_s)-1)
+#define STRING_SIZE_TUPLE(_s) (_s), CSTRLEN(_s)
+
+/* The number of bytes needed to represent the largest integer as a string.  */
+#define INTSTR_LENGTH         CSTRLEN ("18446744073709551616")
+
+#define DEFAULT_TTYNAME "true"
+#ifdef HAVE_TTYNAME
+# define TTYNAME(_f) ttyname (_f)
+#else
+# define TTYNAME(_f) DEFAULT_TTYNAME
+#endif
+
+
+
+/* Specify the location of elements read from makefiles.  */
+typedef struct
+  {
+    const char *filenm;
+    unsigned long lineno;
+    unsigned long offset;
+  } floc;
+
+const char *concat (unsigned int, ...);
+void message (int prefix, size_t length, const char *fmt, ...)
+              __attribute__ ((__format__ (__printf__, 3, 4)));
+void error (const floc *flocp, size_t length, const char *fmt, ...)
+            __attribute__ ((__format__ (__printf__, 3, 4)));
+void fatal (const floc *flocp, size_t length, const char *fmt, ...)
+            __attribute__ ((noreturn, __format__ (__printf__, 3, 4)));
+void out_of_memory () __attribute__((noreturn));
+
+/* When adding macros to this list be sure to update the value of
+   XGETTEXT_OPTIONS in the po/Makevars file.  */
+#define O(_t,_a,_f)           _t((_a), 0, (_f))
+#define OS(_t,_a,_f,_s)       _t((_a), strlen (_s), (_f), (_s))
+#define OSS(_t,_a,_f,_s1,_s2) _t((_a), strlen (_s1) + strlen (_s2), \
+                                 (_f), (_s1), (_s2))
+#define OSSS(_t,_a,_f,_s1,_s2,_s3) _t((_a), strlen (_s1) + strlen (_s2) + strlen (_s3), \
+                                      (_f), (_s1), (_s2), (_s3))
+#define ON(_t,_a,_f,_n)       _t((_a), INTSTR_LENGTH, (_f), (_n))
+#define ONN(_t,_a,_f,_n1,_n2) _t((_a), INTSTR_LENGTH*2, (_f), (_n1), (_n2))
+
+#define OSN(_t,_a,_f,_s,_n)   _t((_a), strlen (_s) + INTSTR_LENGTH, \
+                                 (_f), (_s), (_n))
+#define ONS(_t,_a,_f,_n,_s)   _t((_a), INTSTR_LENGTH + strlen (_s), \
+                                 (_f), (_n), (_s))
+
+void die (int) __attribute__ ((noreturn));
+void pfatal_with_name (const char *) __attribute__ ((noreturn));
+void perror_with_name (const char *, const char *);
+#define xstrlen(_s) ((_s)==NULL ? 0 : strlen (_s))
+void *xmalloc (unsigned int);
+void *xcalloc (unsigned int);
+void *xrealloc (void *, unsigned int);
+char *xstrdup (const char *);
+char *xstrndup (const char *, unsigned int);
+char *find_next_token (const char **, unsigned int *);
+char *next_token (const char *);
+char *end_of_token (const char *);
+void collapse_continuations (char *);
+char *lindex (const char *, const char *, int);
+int alpha_compare (const void *, const void *);
+void print_spaces (unsigned int);
+char *find_percent (char *);
+const char *find_percent_cached (const char **);
+FILE *get_tmpfile (char **, const char *);
+
+#ifndef NO_ARCHIVES
+int ar_name (const char *);
+void ar_parse_name (const char *, char **, char **);
+int ar_touch (const char *);
+time_t ar_member_date (const char *);
+
+typedef long int (*ar_member_func_t) (int desc, const char *mem, int truncated,
+                                      long int hdrpos, long int datapos,
+                                      long int size, long int date, int uid,
+                                      int gid, unsigned int mode,
+                                      const void *arg);
+
+long int ar_scan (const char *archive, ar_member_func_t function, const void *arg);
+int ar_name_equal (const char *name, const char *mem, int truncated);
+#ifndef VMS
+int ar_member_touch (const char *arname, const char *memname);
+#endif
+#endif
+
+int dir_file_exists_p (const char *, const char *);
+int file_exists_p (const char *);
+int file_impossible_p (const char *);
+void file_impossible (const char *);
+const char *dir_name (const char *);
+void print_dir_data_base (void);
+void dir_setup_glob (glob_t *);
+void hash_init_directories (void);
+
+void define_default_variables (void);
+void undefine_default_variables (void);
+void set_default_suffixes (void);
+void install_default_suffix_rules (void);
+void install_default_implicit_rules (void);
+
+void build_vpath_lists (void);
+void construct_vpath_list (char *pattern, char *dirpath);
+const char *vpath_search (const char *file, FILE_TIMESTAMP *mtime_ptr,
+                          unsigned int* vpath_index, unsigned int* path_index);
+int gpath_search (const char *file, unsigned int len);
+
+void construct_include_path (const char **arg_dirs);
+
+void user_access (void);
+void make_access (void);
+void child_access (void);
+
+char *strip_whitespace (const char **begpp, const char **endpp);
+
+void show_goal_error (void);
+
+/* String caching  */
+void strcache_init (void);
+void strcache_print_stats (const char *prefix);
+int strcache_iscached (const char *str);
+const char *strcache_add (const char *str);
+const char *strcache_add_len (const char *str, unsigned int len);
+
+/* Guile support  */
+int guile_gmake_setup (const floc *flocp);
+
+/* Loadable object support.  Sets to the strcached name of the loaded file.  */
+typedef int (*load_func_t)(const floc *flocp);
+int load_file (const floc *flocp, const char **filename, int noerror);
+void unload_file (const char *name);
+
+/* We omit these declarations on non-POSIX systems which define _POSIX_VERSION,
+   because such systems often declare them in header files anyway.  */
+
+#if !defined (__GNU_LIBRARY__) && !defined (POSIX) && !defined (_POSIX_VERSION) && !defined(WINDOWS32)
+
+long int atol ();
+# ifndef VMS
+long int lseek ();
+# endif
+
+# ifdef  HAVE_GETCWD
+#  if !defined(VMS) && !defined(__DECC)
+char *getcwd ();
+#  endif
+# else
+char *getwd ();
+#  define getcwd(buf, len)       getwd (buf)
+# endif
+
+#endif  /* Not GNU C library or POSIX.  */
+
+#if !HAVE_STRCASECMP
+# if HAVE_STRICMP
+#  define strcasecmp stricmp
+# elif HAVE_STRCMPI
+#  define strcasecmp strcmpi
+# else
+/* Create our own, in misc.c */
+int strcasecmp (const char *s1, const char *s2);
+# endif
+#endif
+
+#if !HAVE_STRNCASECMP
+# if HAVE_STRNICMP
+#  define strncasecmp strnicmp
+# elif HAVE_STRNCMPI
+#  define strncasecmp strncmpi
+# else
+/* Create our own, in misc.c */
+int strncasecmp (const char *s1, const char *s2, int n);
+# endif
+#endif
+
+#define OUTPUT_SYNC_NONE    0
+#define OUTPUT_SYNC_LINE    1
+#define OUTPUT_SYNC_TARGET  2
+#define OUTPUT_SYNC_RECURSE 3
+
+/* Non-GNU systems may not declare this in unistd.h.  */
+extern char **environ;
+
+extern const floc *reading_file;
+extern const floc **expanding_var;
+
+extern unsigned short stopchar_map[];
+
+extern int just_print_flag, silent_flag, ignore_errors_flag, keep_going_flag;
+extern int print_data_base_flag, question_flag, touch_flag, always_make_flag;
+extern int env_overrides, no_builtin_rules_flag, no_builtin_variables_flag;
+extern int print_version_flag, print_directory_flag, check_symlink_flag;
+extern int warn_undefined_variables_flag, trace_flag, posix_pedantic;
+extern int not_parallel, second_expansion, clock_skew_detected;
+extern int rebuilding_makefiles, one_shell, output_sync, verify_flag;
+
+extern const char *default_shell;
+
+/* can we run commands via 'sh -c xxx' or must we use batch files? */
+extern int batch_mode_shell;
+
+/* Resetting the command script introduction prefix character.  */
+#define RECIPEPREFIX_NAME          ".RECIPEPREFIX"
+#define RECIPEPREFIX_DEFAULT       '\t'
+extern char cmd_prefix;
+
+extern unsigned int job_slots;
+extern double max_load_average;
+
+extern const char *program;
+
+#ifdef VMS
+const char *vms_command (const char *argv0);
+const char *vms_progname (const char *argv0);
+
+void vms_exit (int);
+# define _exit(foo) vms_exit(foo)
+# define exit(foo) vms_exit(foo)
+
+extern char *program_name;
+
+void
+set_program_name (const char *arv0);
+
+int
+need_vms_symbol (void);
+
+int
+create_foreign_command (const char *command, const char *image);
+
+int
+vms_export_dcl_symbol (const char *name, const char *value);
+
+int
+vms_putenv_symbol (const char *string);
+
+void
+vms_restore_symbol (const char *string);
+
+#endif
+
+void remote_setup (void);
+void remote_cleanup (void);
+int start_remote_job_p (int);
+int start_remote_job (char **, char **, int, int *, int *, int *);
+int remote_status (int *, int *, int *, int);
+void block_remote_children (void);
+void unblock_remote_children (void);
+int remote_kill (int id, int sig);
+void print_variable_data_base (void);
+void print_vpath_data_base (void);
+
+extern char *starting_directory;
+extern unsigned int makelevel;
+extern char *version_string, *remote_description, *make_host;
+
+extern unsigned int commands_started;
+
+extern int handling_fatal_signal;
+
+
+#ifndef MIN
+#define MIN(_a,_b) ((_a)<(_b)?(_a):(_b))
+#endif
+#ifndef MAX
+#define MAX(_a,_b) ((_a)>(_b)?(_a):(_b))
+#endif
+
+
+#define MAKE_SUCCESS 0
+#define MAKE_TROUBLE 1
+#define MAKE_FAILURE 2
+
+/* Set up heap debugging library dmalloc.  */
+
+#ifdef HAVE_DMALLOC_H
+#include <dmalloc.h>
+#endif
+
+#ifndef initialize_main
+# ifdef __EMX__
+#  define initialize_main(pargc, pargv) \
+                          { _wildcard(pargc, pargv); _response(pargc, pargv); }
+# else
+#  define initialize_main(pargc, pargv)
+# endif
+#endif
+
+#ifdef __EMX__
+# if !defined chdir
+#  define chdir _chdir2
+# endif
+# if !defined getcwd
+#  define getcwd _getcwd2
+# endif
+
+/* NO_CHDIR2 causes make not to use _chdir2() and _getcwd2() instead of
+   chdir() and getcwd(). This avoids some error messages for the
+   make testsuite but restricts the drive letter support. */
+# ifdef NO_CHDIR2
+#  warning NO_CHDIR2: usage of drive letters restricted
+#  undef chdir
+#  undef getcwd
+# endif
+#endif
+
+#ifndef initialize_main
+# define initialize_main(pargc, pargv)
+#endif
+
+
+/* Some systems (like Solaris, PTX, etc.) do not support the SA_RESTART flag
+   properly according to POSIX.  So, we try to wrap common system calls with
+   checks for EINTR.  Note that there are still plenty of system calls that
+   can fail with EINTR but this, reportedly, gets the vast majority of
+   failure cases.  If you still experience failures you'll need to either get
+   a system where SA_RESTART works, or you need to avoid -j.  */
+
+#define EINTRLOOP(_v,_c)   while (((_v)=_c)==-1 && errno==EINTR)
+
+/* While system calls that return integers are pretty consistent about
+   returning -1 on failure and setting errno in that case, functions that
+   return pointers are not always so well behaved.  Sometimes they return
+   NULL for expected behavior: one good example is readdir() which returns
+   NULL at the end of the directory--and _doesn't_ reset errno.  So, we have
+   to do it ourselves here.  */
+
+#define ENULLLOOP(_v,_c)   do { errno = 0; (_v) = _c; } \
+                           while((_v)==0 && errno==EINTR)
diff --git a/src/misc.c b/src/misc.c
new file mode 100644
index 0000000..441db8d
--- /dev/null
+++ b/src/misc.c
@@ -0,0 +1,761 @@
+/* Miscellaneous generic support functions for GNU Make.
+Copyright (C) 1988-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+#include "filedef.h"
+#include "dep.h"
+#include "debug.h"
+
+/* GNU make no longer supports pre-ANSI89 environments.  */
+
+#include <stdarg.h>
+
+#ifdef WINDOWS32
+# include <io.h>
+#endif
+
+#ifdef HAVE_FCNTL_H
+# include <fcntl.h>
+#else
+# include <sys/file.h>
+#endif
+
+/* Compare strings *S1 and *S2.
+   Return negative if the first is less, positive if it is greater,
+   zero if they are equal.  */
+
+int
+alpha_compare (const void *v1, const void *v2)
+{
+  const char *s1 = *((char **)v1);
+  const char *s2 = *((char **)v2);
+
+  if (*s1 != *s2)
+    return *s1 - *s2;
+  return strcmp (s1, s2);
+}
+
+/* Discard each backslash-newline combination from LINE.
+   Backslash-backslash-newline combinations become backslash-newlines.
+   This is done by copying the text at LINE into itself.  */
+
+void
+collapse_continuations (char *line)
+{
+  char *out = line;
+  char *in = line;
+  char *q;
+
+  q = strchr(in, '\n');
+  if (q == 0)
+    return;
+
+  do
+    {
+      char *p = q;
+      int i;
+      int out_line_length;
+
+      if (q > line && q[-1] == '\\')
+        {
+          /* Search for more backslashes.  */
+          i = -2;
+          while (&p[i] >= line && p[i] == '\\')
+            --i;
+          ++i;
+        }
+      else
+        i = 0;
+
+      /* The number of backslashes is now -I, keep half of them.  */
+      out_line_length = (p - in) + i - i/2;
+      if (out != in)
+        memmove (out, in, out_line_length);
+      out += out_line_length;
+
+      /* When advancing IN, skip the newline too.  */
+      in = q + 1;
+
+      if (i & 1)
+        {
+          /* Backslash/newline handling:
+             In traditional GNU make all trailing whitespace, consecutive
+             backslash/newlines, and any leading non-newline whitespace on the
+             next line is reduced to a single space.
+             In POSIX, each backslash/newline and is replaced by a space.  */
+          while (ISBLANK (*in))
+            ++in;
+          if (! posix_pedantic)
+            while (out > line && ISBLANK (out[-1]))
+              --out;
+          *out++ = ' ';
+        }
+      else
+        {
+          /* If the newline isn't quoted, put it in the output.  */
+          *out++ = '\n';
+        }
+
+      q = strchr(in, '\n');
+    }
+  while (q);
+
+  memmove(out, in, strlen(in) + 1);
+}
+
+/* Print N spaces (used in debug for target-depth).  */
+
+void
+print_spaces (unsigned int n)
+{
+  while (n-- > 0)
+    putchar (' ');
+}
+
+
+/* Return a string whose contents concatenate the NUM strings provided
+   This string lives in static, re-used memory.  */
+
+const char *
+concat (unsigned int num, ...)
+{
+  static unsigned int rlen = 0;
+  static char *result = NULL;
+  unsigned int ri = 0;
+  va_list args;
+
+  va_start (args, num);
+
+  while (num-- > 0)
+    {
+      const char *s = va_arg (args, const char *);
+      unsigned int l = xstrlen (s);
+
+      if (l == 0)
+        continue;
+
+      if (ri + l > rlen)
+        {
+          rlen = ((rlen ? rlen : 60) + l) * 2;
+          result = xrealloc (result, rlen);
+        }
+
+      memcpy (result + ri, s, l);
+      ri += l;
+    }
+
+  va_end (args);
+
+  /* Get some more memory if we don't have enough space for the
+     terminating '\0'.   */
+  if (ri == rlen)
+    {
+      rlen = (rlen ? rlen : 60) * 2;
+      result = xrealloc (result, rlen);
+    }
+
+  result[ri] = '\0';
+
+  return result;
+}
+
+
+#ifndef HAVE_STRERROR
+#undef  strerror
+char *
+strerror (int errnum)
+{
+  extern int errno, sys_nerr;
+#ifndef __DECC
+  extern char *sys_errlist[];
+#endif
+  static char buf[] = "Unknown error 12345678901234567890";
+
+  if (errno < sys_nerr)
+    return sys_errlist[errnum];
+
+  sprintf (buf, _("Unknown error %d"), errnum);
+  return buf;
+}
+#endif
+
+/* Like malloc but get fatal error if memory is exhausted.  */
+/* Don't bother if we're using dmalloc; it provides these for us.  */
+
+#ifndef HAVE_DMALLOC_H
+
+#undef xmalloc
+#undef xcalloc
+#undef xrealloc
+#undef xstrdup
+
+void *
+xmalloc (unsigned int size)
+{
+  /* Make sure we don't allocate 0, for pre-ISO implementations.  */
+  void *result = malloc (size ? size : 1);
+  if (result == 0)
+    out_of_memory ();
+  return result;
+}
+
+
+void *
+xcalloc (unsigned int size)
+{
+  /* Make sure we don't allocate 0, for pre-ISO implementations.  */
+  void *result = calloc (size ? size : 1, 1);
+  if (result == 0)
+    out_of_memory ();
+  return result;
+}
+
+
+void *
+xrealloc (void *ptr, unsigned int size)
+{
+  void *result;
+
+  /* Some older implementations of realloc() don't conform to ISO.  */
+  if (! size)
+    size = 1;
+  result = ptr ? realloc (ptr, size) : malloc (size);
+  if (result == 0)
+    out_of_memory ();
+  return result;
+}
+
+
+char *
+xstrdup (const char *ptr)
+{
+  char *result;
+
+#ifdef HAVE_STRDUP
+  result = strdup (ptr);
+#else
+  result = malloc (strlen (ptr) + 1);
+#endif
+
+  if (result == 0)
+    out_of_memory ();
+
+#ifdef HAVE_STRDUP
+  return result;
+#else
+  return strcpy (result, ptr);
+#endif
+}
+
+#endif  /* HAVE_DMALLOC_H */
+
+char *
+xstrndup (const char *str, unsigned int length)
+{
+  char *result;
+
+#ifdef HAVE_STRNDUP
+  result = strndup (str, length);
+  if (result == 0)
+    out_of_memory ();
+#else
+  result = xmalloc (length + 1);
+  if (length > 0)
+    strncpy (result, str, length);
+  result[length] = '\0';
+#endif
+
+  return result;
+}
+
+
+/* Limited INDEX:
+   Search through the string STRING, which ends at LIMIT, for the character C.
+   Returns a pointer to the first occurrence, or nil if none is found.
+   Like INDEX except that the string searched ends where specified
+   instead of at the first null.  */
+
+char *
+lindex (const char *s, const char *limit, int c)
+{
+  while (s < limit)
+    if (*s++ == c)
+      return (char *)(s - 1);
+
+  return 0;
+}
+
+/* Return the address of the first whitespace or null in the string S.  */
+
+char *
+end_of_token (const char *s)
+{
+  END_OF_TOKEN (s);
+  return (char *)s;
+}
+
+/* Return the address of the first nonwhitespace or null in the string S.  */
+
+char *
+next_token (const char *s)
+{
+  NEXT_TOKEN (s);
+  return (char *)s;
+}
+
+/* Find the next token in PTR; return the address of it, and store the length
+   of the token into *LENGTHPTR if LENGTHPTR is not nil.  Set *PTR to the end
+   of the token, so this function can be called repeatedly in a loop.  */
+
+char *
+find_next_token (const char **ptr, unsigned int *lengthptr)
+{
+  const char *p = next_token (*ptr);
+
+  if (*p == '\0')
+    return 0;
+
+  *ptr = end_of_token (p);
+  if (lengthptr != 0)
+    *lengthptr = *ptr - p;
+
+  return (char *)p;
+}
+
+
+/* Copy a chain of 'struct dep'.  For 2nd expansion deps, dup the name.  */
+
+struct dep *
+copy_dep_chain (const struct dep *d)
+{
+  struct dep *firstnew = 0;
+  struct dep *lastnew = 0;
+
+  while (d != 0)
+    {
+      struct dep *c = xmalloc (sizeof (struct dep));
+      memcpy (c, d, sizeof (struct dep));
+
+      if (c->need_2nd_expansion)
+        c->name = xstrdup (c->name);
+
+      c->next = 0;
+      if (firstnew == 0)
+        firstnew = lastnew = c;
+      else
+        lastnew = lastnew->next = c;
+
+      d = d->next;
+    }
+
+  return firstnew;
+}
+
+/* Free a chain of struct nameseq.
+   For struct dep chains use free_dep_chain.  */
+
+void
+free_ns_chain (struct nameseq *ns)
+{
+  while (ns != 0)
+    {
+      struct nameseq *t = ns;
+      ns = ns->next;
+      free_ns (t);
+    }
+}
+
+
+/* Provide support for temporary files.  */
+
+#ifndef HAVE_STDLIB_H
+# ifdef HAVE_MKSTEMP
+int mkstemp (char *template);
+# else
+char *mktemp (char *template);
+# endif
+#endif
+
+FILE *
+get_tmpfile (char **name, const char *template)
+{
+  FILE *file;
+#ifdef HAVE_FDOPEN
+  int fd;
+#endif
+
+  /* Preserve the current umask, and set a restrictive one for temp files.  */
+  MODE_T mask = UMASK (0077);
+
+#if defined(HAVE_MKSTEMP) || defined(HAVE_MKTEMP)
+# define TEMPLATE_LEN   strlen (template)
+#else
+# define TEMPLATE_LEN   L_tmpnam
+#endif
+  *name = xmalloc (TEMPLATE_LEN + 1);
+  strcpy (*name, template);
+
+#if defined(HAVE_MKSTEMP) && defined(HAVE_FDOPEN)
+  /* It's safest to use mkstemp(), if we can.  */
+  EINTRLOOP (fd, mkstemp (*name));
+  if (fd == -1)
+    file = NULL;
+  else
+    file = fdopen (fd, "w");
+#else
+# ifdef HAVE_MKTEMP
+  (void) mktemp (*name);
+# else
+  (void) tmpnam (*name);
+# endif
+
+# ifdef HAVE_FDOPEN
+  /* Can't use mkstemp(), but guard against a race condition.  */
+  EINTRLOOP (fd, open (*name, O_CREAT|O_EXCL|O_WRONLY, 0600));
+  if (fd == -1)
+    return 0;
+  file = fdopen (fd, "w");
+# else
+  /* Not secure, but what can we do?  */
+  file = fopen (*name, "w");
+# endif
+#endif
+
+  UMASK (mask);
+
+  return file;
+}
+
+
+#if !HAVE_STRCASECMP && !HAVE_STRICMP && !HAVE_STRCMPI
+/* If we don't have strcasecmp() (from POSIX), or anything that can substitute
+   for it, define our own version.  */
+
+int
+strcasecmp (const char *s1, const char *s2)
+{
+  while (1)
+    {
+      int c1 = (int) *(s1++);
+      int c2 = (int) *(s2++);
+
+      if (isalpha (c1))
+        c1 = tolower (c1);
+      if (isalpha (c2))
+        c2 = tolower (c2);
+
+      if (c1 != '\0' && c1 == c2)
+        continue;
+
+      return (c1 - c2);
+    }
+}
+#endif
+
+#if !HAVE_STRNCASECMP && !HAVE_STRNICMP && !HAVE_STRNCMPI
+/* If we don't have strncasecmp() (from POSIX), or anything that can
+   substitute for it, define our own version.  */
+
+int
+strncasecmp (const char *s1, const char *s2, int n)
+{
+  while (n-- > 0)
+    {
+      int c1 = (int) *(s1++);
+      int c2 = (int) *(s2++);
+
+      if (isalpha (c1))
+        c1 = tolower (c1);
+      if (isalpha (c2))
+        c2 = tolower (c2);
+
+      if (c1 != '\0' && c1 == c2)
+        continue;
+
+      return (c1 - c2);
+    }
+
+  return 0;
+}
+#endif
+
+#ifdef  GETLOADAVG_PRIVILEGED
+
+#ifdef POSIX
+
+/* Hopefully if a system says it's POSIX.1 and has the setuid and setgid
+   functions, they work as POSIX.1 says.  Some systems (Alpha OSF/1 1.2,
+   for example) which claim to be POSIX.1 also have the BSD setreuid and
+   setregid functions, but they don't work as in BSD and only the POSIX.1
+   way works.  */
+
+#undef HAVE_SETREUID
+#undef HAVE_SETREGID
+
+#else   /* Not POSIX.  */
+
+/* Some POSIX.1 systems have the seteuid and setegid functions.  In a
+   POSIX-like system, they are the best thing to use.  However, some
+   non-POSIX systems have them too but they do not work in the POSIX style
+   and we must use setreuid and setregid instead.  */
+
+#undef HAVE_SETEUID
+#undef HAVE_SETEGID
+
+#endif  /* POSIX.  */
+
+#ifndef HAVE_UNISTD_H
+extern int getuid (), getgid (), geteuid (), getegid ();
+extern int setuid (), setgid ();
+#ifdef HAVE_SETEUID
+extern int seteuid ();
+#else
+#ifdef  HAVE_SETREUID
+extern int setreuid ();
+#endif  /* Have setreuid.  */
+#endif  /* Have seteuid.  */
+#ifdef HAVE_SETEGID
+extern int setegid ();
+#else
+#ifdef  HAVE_SETREGID
+extern int setregid ();
+#endif  /* Have setregid.  */
+#endif  /* Have setegid.  */
+#endif  /* No <unistd.h>.  */
+
+/* Keep track of the user and group IDs for user- and make- access.  */
+static int user_uid = -1, user_gid = -1, make_uid = -1, make_gid = -1;
+#define access_inited   (user_uid != -1)
+static enum { make, user } current_access;
+
+
+/* Under -d, write a message describing the current IDs.  */
+
+static void
+log_access (const char *flavor)
+{
+  if (! ISDB (DB_JOBS))
+    return;
+
+  /* All the other debugging messages go to stdout,
+     but we write this one to stderr because it might be
+     run in a child fork whose stdout is piped.  */
+
+  fprintf (stderr, _("%s: user %lu (real %lu), group %lu (real %lu)\n"),
+           flavor, (unsigned long) geteuid (), (unsigned long) getuid (),
+           (unsigned long) getegid (), (unsigned long) getgid ());
+  fflush (stderr);
+}
+
+
+static void
+init_access (void)
+{
+#ifndef VMS
+  user_uid = getuid ();
+  user_gid = getgid ();
+
+  make_uid = geteuid ();
+  make_gid = getegid ();
+
+  /* Do these ever fail?  */
+  if (user_uid == -1 || user_gid == -1 || make_uid == -1 || make_gid == -1)
+    pfatal_with_name ("get{e}[gu]id");
+
+  log_access (_("Initialized access"));
+
+  current_access = make;
+#endif
+}
+
+#endif  /* GETLOADAVG_PRIVILEGED */
+
+/* Give the process appropriate permissions for access to
+   user data (i.e., to stat files, or to spawn a child process).  */
+void
+user_access (void)
+{
+#ifdef  GETLOADAVG_PRIVILEGED
+
+  if (!access_inited)
+    init_access ();
+
+  if (current_access == user)
+    return;
+
+  /* We are in "make access" mode.  This means that the effective user and
+     group IDs are those of make (if it was installed setuid or setgid).
+     We now want to set the effective user and group IDs to the real IDs,
+     which are the IDs of the process that exec'd make.  */
+
+#ifdef  HAVE_SETEUID
+
+  /* Modern systems have the seteuid/setegid calls which set only the
+     effective IDs, which is ideal.  */
+
+  if (seteuid (user_uid) < 0)
+    pfatal_with_name ("user_access: seteuid");
+
+#else   /* Not HAVE_SETEUID.  */
+
+#ifndef HAVE_SETREUID
+
+  /* System V has only the setuid/setgid calls to set user/group IDs.
+     There is an effective ID, which can be set by setuid/setgid.
+     It can be set (unless you are root) only to either what it already is
+     (returned by geteuid/getegid, now in make_uid/make_gid),
+     the real ID (return by getuid/getgid, now in user_uid/user_gid),
+     or the saved set ID (what the effective ID was before this set-ID
+     executable (make) was exec'd).  */
+
+  if (setuid (user_uid) < 0)
+    pfatal_with_name ("user_access: setuid");
+
+#else   /* HAVE_SETREUID.  */
+
+  /* In 4BSD, the setreuid/setregid calls set both the real and effective IDs.
+     They may be set to themselves or each other.  So you have two alternatives
+     at any one time.  If you use setuid/setgid, the effective will be set to
+     the real, leaving only one alternative.  Using setreuid/setregid, however,
+     you can toggle between your two alternatives by swapping the values in a
+     single setreuid or setregid call.  */
+
+  if (setreuid (make_uid, user_uid) < 0)
+    pfatal_with_name ("user_access: setreuid");
+
+#endif  /* Not HAVE_SETREUID.  */
+#endif  /* HAVE_SETEUID.  */
+
+#ifdef  HAVE_SETEGID
+  if (setegid (user_gid) < 0)
+    pfatal_with_name ("user_access: setegid");
+#else
+#ifndef HAVE_SETREGID
+  if (setgid (user_gid) < 0)
+    pfatal_with_name ("user_access: setgid");
+#else
+  if (setregid (make_gid, user_gid) < 0)
+    pfatal_with_name ("user_access: setregid");
+#endif
+#endif
+
+  current_access = user;
+
+  log_access (_("User access"));
+
+#endif  /* GETLOADAVG_PRIVILEGED */
+}
+
+/* Give the process appropriate permissions for access to
+   make data (i.e., the load average).  */
+void
+make_access (void)
+{
+#ifdef  GETLOADAVG_PRIVILEGED
+
+  if (!access_inited)
+    init_access ();
+
+  if (current_access == make)
+    return;
+
+  /* See comments in user_access, above.  */
+
+#ifdef  HAVE_SETEUID
+  if (seteuid (make_uid) < 0)
+    pfatal_with_name ("make_access: seteuid");
+#else
+#ifndef HAVE_SETREUID
+  if (setuid (make_uid) < 0)
+    pfatal_with_name ("make_access: setuid");
+#else
+  if (setreuid (user_uid, make_uid) < 0)
+    pfatal_with_name ("make_access: setreuid");
+#endif
+#endif
+
+#ifdef  HAVE_SETEGID
+  if (setegid (make_gid) < 0)
+    pfatal_with_name ("make_access: setegid");
+#else
+#ifndef HAVE_SETREGID
+  if (setgid (make_gid) < 0)
+    pfatal_with_name ("make_access: setgid");
+#else
+  if (setregid (user_gid, make_gid) < 0)
+    pfatal_with_name ("make_access: setregid");
+#endif
+#endif
+
+  current_access = make;
+
+  log_access (_("Make access"));
+
+#endif  /* GETLOADAVG_PRIVILEGED */
+}
+
+/* Give the process appropriate permissions for a child process.
+   This is like user_access, but you can't get back to make_access.  */
+void
+child_access (void)
+{
+#ifdef  GETLOADAVG_PRIVILEGED
+
+  if (!access_inited)
+    abort ();
+
+  /* Set both the real and effective UID and GID to the user's.
+     They cannot be changed back to make's.  */
+
+#ifndef HAVE_SETREUID
+  if (setuid (user_uid) < 0)
+    pfatal_with_name ("child_access: setuid");
+#else
+  if (setreuid (user_uid, user_uid) < 0)
+    pfatal_with_name ("child_access: setreuid");
+#endif
+
+#ifndef HAVE_SETREGID
+  if (setgid (user_gid) < 0)
+    pfatal_with_name ("child_access: setgid");
+#else
+  if (setregid (user_gid, user_gid) < 0)
+    pfatal_with_name ("child_access: setregid");
+#endif
+
+  log_access (_("Child access"));
+
+#endif  /* GETLOADAVG_PRIVILEGED */
+}
+
+#ifdef NEED_GET_PATH_MAX
+unsigned int
+get_path_max (void)
+{
+  static unsigned int value;
+
+  if (value == 0)
+    {
+      long int x = pathconf ("/", _PC_PATH_MAX);
+      if (x > 0)
+        value = x;
+      else
+        return MAXPATHLEN;
+    }
+
+  return value;
+}
+#endif
diff --git a/src/os.h b/src/os.h
new file mode 100644
index 0000000..b68b005
--- /dev/null
+++ b/src/os.h
@@ -0,0 +1,93 @@
+/* Declarations for operating system interfaces for GNU Make.
+Copyright (C) 2016-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+
+/* This section provides OS-specific functions to support the jobserver.  */
+
+#ifdef MAKE_JOBSERVER
+
+/* Returns 1 if the jobserver is enabled, else 0.  */
+unsigned int jobserver_enabled (void);
+
+/* Called in the master instance to set up the jobserver initially.  */
+unsigned int jobserver_setup (int job_slots);
+
+/* Called in a child instance to connect to the jobserver.  */
+unsigned int jobserver_parse_auth (const char* auth);
+
+/* Returns an allocated buffer used to pass to child instances.  */
+char *jobserver_get_auth (void);
+
+/* Clear this instance's jobserver configuration.  */
+void jobserver_clear (void);
+
+/* Recover all the jobserver tokens and return the number we got.  */
+unsigned int jobserver_acquire_all (void);
+
+/* Release a jobserver token.  If it fails and is_fatal is 1, fatal.  */
+void jobserver_release (int is_fatal);
+
+/* Notify the jobserver that a child exited.  */
+void jobserver_signal (void);
+
+/* Get ready to start a non-recursive child.  */
+void jobserver_pre_child (int);
+
+/* Complete starting a non-recursive child.  */
+void jobserver_post_child (int);
+
+/* Set up to acquire a new token.  */
+void jobserver_pre_acquire (void);
+
+/* Wait until we can acquire a jobserver token.
+   TIMEOUT is 1 if we have other jobs waiting for the load to go down;
+   in this case we won't wait forever, so we can check the load.
+   Returns 1 if we got a token, or 0 if we stopped waiting due to a child
+   exiting or a timeout.    */
+unsigned int jobserver_acquire (int timeout);
+
+#else
+
+#define jobserver_enabled()         (0)
+#define jobserver_setup(_slots)     (0)
+#define jobserver_parse_auth(_auth) (0)
+#define jobserver_get_auth()        (NULL)
+#define jobserver_clear()           (void)(0)
+#define jobserver_release(_fatal)   (void)(0)
+#define jobserver_acquire_all()     (0)
+#define jobserver_signal()          (void)(0)
+#define jobserver_pre_child(_r)     (void)(0)
+#define jobserver_post_child(_r)    (void)(0)
+#define jobserver_pre_acquire()     (void)(0)
+#define jobserver_acquire(_tmout)   (0)
+
+#endif
+
+/* Create a "bad" file descriptor for stdin when parallel jobs are run.  */
+#if defined(VMS) || defined(WINDOWS32) || defined(_AMIGA) || defined(__MSDOS__)
+# define get_bad_stdin() (-1)
+#else
+int get_bad_stdin (void);
+#endif
+
+/* Set a file descriptor to close/not close in a subprocess.  */
+#if defined(VMS) || defined(_AMIGA) || defined(__MSDOS__)
+# define fd_inherit(_i)   0
+# define fd_noinherit(_i) 0
+#else
+void fd_inherit (int);
+void fd_noinherit (int);
+#endif
diff --git a/src/output.c b/src/output.c
new file mode 100644
index 0000000..93b3dc7
--- /dev/null
+++ b/src/output.c
@@ -0,0 +1,702 @@
+/* Output to stdout / stderr for GNU make
+Copyright (C) 2013-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+#include "os.h"
+#include "output.h"
+
+/* GNU make no longer supports pre-ANSI89 environments.  */
+
+#include <assert.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
+
+#ifdef HAVE_FCNTL_H
+# include <fcntl.h>
+#else
+# include <sys/file.h>
+#endif
+
+#ifdef WINDOWS32
+# include <windows.h>
+# include <io.h>
+# include "sub_proc.h"
+#endif /* WINDOWS32 */
+
+struct output *output_context = NULL;
+unsigned int stdio_traced = 0;
+
+#define OUTPUT_NONE (-1)
+
+#define OUTPUT_ISSET(_out) ((_out)->out >= 0 || (_out)->err >= 0)
+
+#ifdef HAVE_FCNTL_H
+# define STREAM_OK(_s) ((fcntl (fileno (_s), F_GETFD) != -1) || (errno != EBADF))
+#else
+# define STREAM_OK(_s) 1
+#endif
+
+/* Write a BUFFER of size LEN to file descriptor FD.
+   Handle EINTR and other short writes.  If we get an error, ignore it.  */
+int
+output_write (int fd, const void *buffer, size_t len)
+{
+  const char *msg = buffer;
+  while (1)
+    {
+      ssize_t r;
+
+      EINTRLOOP (r, write (fd, msg, len));
+
+      if (r < 0 || (size_t)r == len)
+        return r;
+
+      len -= r;
+      msg += r;
+    }
+}
+
+/* Write a string to the current STDOUT or STDERR.  */
+static void
+_outputs (struct output *out, int is_err, const char *msg)
+{
+  if (! out || ! out->syncout)
+    {
+      FILE *f = is_err ? stderr : stdout;
+      fputs (msg, f);
+      fflush (f);
+    }
+  else
+    {
+      int fd = is_err ? out->err : out->out;
+      int len = strlen (msg);
+      int r;
+      EINTRLOOP (r, lseek (fd, 0, SEEK_END));
+      output_write (fd, msg, len);
+    }
+}
+
+/* Write a message indicating that we've just entered or
+   left (according to ENTERING) the current directory.  */
+
+static int
+log_working_directory (int entering)
+{
+  static char *buf = NULL;
+  static unsigned int len = 0;
+  unsigned int need;
+  const char *fmt;
+  char *p;
+
+  /* Get enough space for the longest possible output.  */
+  need = strlen (program) + INTSTR_LENGTH + 2 + 1;
+  if (starting_directory)
+    need += strlen (starting_directory);
+
+  /* Use entire sentences to give the translators a fighting chance.  */
+  if (makelevel == 0)
+    if (starting_directory == 0)
+      if (entering)
+        fmt = _("%s: Entering an unknown directory\n");
+      else
+        fmt = _("%s: Leaving an unknown directory\n");
+    else
+      if (entering)
+        fmt = _("%s: Entering directory '%s'\n");
+      else
+        fmt = _("%s: Leaving directory '%s'\n");
+  else
+    if (starting_directory == 0)
+      if (entering)
+        fmt = _("%s[%u]: Entering an unknown directory\n");
+      else
+        fmt = _("%s[%u]: Leaving an unknown directory\n");
+    else
+      if (entering)
+        fmt = _("%s[%u]: Entering directory '%s'\n");
+      else
+        fmt = _("%s[%u]: Leaving directory '%s'\n");
+
+  need += strlen (fmt);
+
+  if (need > len)
+    {
+      buf = xrealloc (buf, need);
+      len = need;
+    }
+
+  p = buf;
+  if (print_data_base_flag)
+    {
+      *(p++) = '#';
+      *(p++) = ' ';
+    }
+
+  if (makelevel == 0)
+    if (starting_directory == 0)
+      sprintf (p, fmt , program);
+    else
+      sprintf (p, fmt, program, starting_directory);
+  else if (starting_directory == 0)
+    sprintf (p, fmt, program, makelevel);
+  else
+    sprintf (p, fmt, program, makelevel, starting_directory);
+
+  _outputs (NULL, 0, buf);
+
+  return 1;
+}
+
+/* Set a file descriptor to be in O_APPEND mode.
+   If it fails, just ignore it.  */
+
+static void
+set_append_mode (int fd)
+{
+#if defined(F_GETFL) && defined(F_SETFL) && defined(O_APPEND)
+  int flags = fcntl (fd, F_GETFL, 0);
+  if (flags >= 0)
+    {
+      int r;
+      EINTRLOOP(r, fcntl (fd, F_SETFL, flags | O_APPEND));
+    }
+#endif
+}
+
+
+#ifndef NO_OUTPUT_SYNC
+
+/* Semaphore for use in -j mode with output_sync. */
+static sync_handle_t sync_handle = -1;
+
+#define FD_NOT_EMPTY(_f) ((_f) != OUTPUT_NONE && lseek ((_f), 0, SEEK_END) > 0)
+
+/* Set up the sync handle.  Disables output_sync on error.  */
+static int
+sync_init (void)
+{
+  int combined_output = 0;
+
+#ifdef WINDOWS32
+  if ((!STREAM_OK (stdout) && !STREAM_OK (stderr))
+      || (sync_handle = create_mutex ()) == -1)
+    {
+      perror_with_name ("output-sync suppressed: ", "stderr");
+      output_sync = 0;
+    }
+  else
+    {
+      combined_output = same_stream (stdout, stderr);
+      prepare_mutex_handle_string (sync_handle);
+    }
+
+#else
+  if (STREAM_OK (stdout))
+    {
+      struct stat stbuf_o, stbuf_e;
+
+      sync_handle = fileno (stdout);
+      combined_output = (fstat (fileno (stdout), &stbuf_o) == 0
+                         && fstat (fileno (stderr), &stbuf_e) == 0
+                         && stbuf_o.st_dev == stbuf_e.st_dev
+                         && stbuf_o.st_ino == stbuf_e.st_ino);
+    }
+  else if (STREAM_OK (stderr))
+    sync_handle = fileno (stderr);
+  else
+    {
+      perror_with_name ("output-sync suppressed: ", "stderr");
+      output_sync = 0;
+    }
+#endif
+
+  return combined_output;
+}
+
+/* Support routine for output_sync() */
+static void
+pump_from_tmp (int from, FILE *to)
+{
+  static char buffer[8192];
+
+#ifdef WINDOWS32
+  int prev_mode;
+
+  /* "from" is opened by open_tmpfd, which does it in binary mode, so
+     we need the mode of "to" to match that.  */
+  prev_mode = _setmode (fileno (to), _O_BINARY);
+#endif
+
+  if (lseek (from, 0, SEEK_SET) == -1)
+    perror ("lseek()");
+
+  while (1)
+    {
+      int len;
+      EINTRLOOP (len, read (from, buffer, sizeof (buffer)));
+      if (len < 0)
+        perror ("read()");
+      if (len <= 0)
+        break;
+      if (fwrite (buffer, len, 1, to) < 1)
+        {
+          perror ("fwrite()");
+          break;
+        }
+      fflush (to);
+    }
+
+#ifdef WINDOWS32
+  /* Switch "to" back to its original mode, so that log messages by
+     Make have the same EOL format as without --output-sync.  */
+  _setmode (fileno (to), prev_mode);
+#endif
+}
+
+/* Obtain the lock for writing output.  */
+static void *
+acquire_semaphore (void)
+{
+  static struct flock fl;
+
+  fl.l_type = F_WRLCK;
+  fl.l_whence = SEEK_SET;
+  fl.l_start = 0;
+  fl.l_len = 1;
+  if (fcntl (sync_handle, F_SETLKW, &fl) != -1)
+    return &fl;
+  perror ("fcntl()");
+  return NULL;
+}
+
+/* Release the lock for writing output.  */
+static void
+release_semaphore (void *sem)
+{
+  struct flock *flp = (struct flock *)sem;
+  flp->l_type = F_UNLCK;
+  if (fcntl (sync_handle, F_SETLKW, flp) == -1)
+    perror ("fcntl()");
+}
+
+/* Returns a file descriptor to a temporary file.  The file is automatically
+   closed/deleted on exit.  Don't use a FILE* stream.  */
+int
+output_tmpfd (void)
+{
+  MODE_T mask = UMASK (0077);
+  int fd = -1;
+  FILE *tfile = tmpfile ();
+
+  if (! tfile)
+    pfatal_with_name ("tmpfile");
+
+  /* Create a duplicate so we can close the stream.  */
+  fd = dup (fileno (tfile));
+  if (fd < 0)
+    pfatal_with_name ("dup");
+
+  fclose (tfile);
+
+  set_append_mode (fd);
+
+  UMASK (mask);
+
+  return fd;
+}
+
+/* Adds file descriptors to the child structure to support output_sync; one
+   for stdout and one for stderr as long as they are open.  If stdout and
+   stderr share a device they can share a temp file too.
+   Will reset output_sync on error.  */
+static void
+setup_tmpfile (struct output *out)
+{
+  /* Is make's stdout going to the same place as stderr?  */
+  static int combined_output = -1;
+
+  if (combined_output < 0)
+    combined_output = sync_init ();
+
+  if (STREAM_OK (stdout))
+    {
+      int fd = output_tmpfd ();
+      if (fd < 0)
+        goto error;
+      fd_noinherit (fd);
+      out->out = fd;
+    }
+
+  if (STREAM_OK (stderr))
+    {
+      if (out->out != OUTPUT_NONE && combined_output)
+        out->err = out->out;
+      else
+        {
+          int fd = output_tmpfd ();
+          if (fd < 0)
+            goto error;
+          fd_noinherit (fd);
+          out->err = fd;
+        }
+    }
+
+  return;
+
+  /* If we failed to create a temp file, disable output sync going forward.  */
+ error:
+  output_close (out);
+  output_sync = OUTPUT_SYNC_NONE;
+}
+
+/* Synchronize the output of jobs in -j mode to keep the results of
+   each job together. This is done by holding the results in temp files,
+   one for stdout and potentially another for stderr, and only releasing
+   them to "real" stdout/stderr when a semaphore can be obtained. */
+
+void
+output_dump (struct output *out)
+{
+  int outfd_not_empty = FD_NOT_EMPTY (out->out);
+  int errfd_not_empty = FD_NOT_EMPTY (out->err);
+
+  if (outfd_not_empty || errfd_not_empty)
+    {
+      int traced = 0;
+
+      /* Try to acquire the semaphore.  If it fails, dump the output
+         unsynchronized; still better than silently discarding it.
+         We want to keep this lock for as little time as possible.  */
+      void *sem = acquire_semaphore ();
+
+      /* Log the working directory for this dump.  */
+      if (print_directory_flag && output_sync != OUTPUT_SYNC_RECURSE)
+        traced = log_working_directory (1);
+
+      if (outfd_not_empty)
+        pump_from_tmp (out->out, stdout);
+      if (errfd_not_empty && out->err != out->out)
+        pump_from_tmp (out->err, stderr);
+
+      if (traced)
+        log_working_directory (0);
+
+      /* Exit the critical section.  */
+      if (sem)
+        release_semaphore (sem);
+
+      /* Truncate and reset the output, in case we use it again.  */
+      if (out->out != OUTPUT_NONE)
+        {
+          int e;
+          lseek (out->out, 0, SEEK_SET);
+          EINTRLOOP (e, ftruncate (out->out, 0));
+        }
+      if (out->err != OUTPUT_NONE && out->err != out->out)
+        {
+          int e;
+          lseek (out->err, 0, SEEK_SET);
+          EINTRLOOP (e, ftruncate (out->err, 0));
+        }
+    }
+}
+#endif /* NO_OUTPUT_SYNC */
+
+
+/* This code is stolen from gnulib.
+   If/when we abandon the requirement to work with K&R compilers, we can
+   remove this (and perhaps other parts of GNU make!) and migrate to using
+   gnulib directly.
+
+   This is called only through atexit(), which means die() has already been
+   invoked.  So, call exit() here directly.  Apparently that works...?
+*/
+
+/* Close standard output, exiting with status 'exit_failure' on failure.
+   If a program writes *anything* to stdout, that program should close
+   stdout and make sure that it succeeds before exiting.  Otherwise,
+   suppose that you go to the extreme of checking the return status
+   of every function that does an explicit write to stdout.  The last
+   printf can succeed in writing to the internal stream buffer, and yet
+   the fclose(stdout) could still fail (due e.g., to a disk full error)
+   when it tries to write out that buffered data.  Thus, you would be
+   left with an incomplete output file and the offending program would
+   exit successfully.  Even calling fflush is not always sufficient,
+   since some file systems (NFS and CODA) buffer written/flushed data
+   until an actual close call.
+
+   Besides, it's wasteful to check the return value from every call
+   that writes to stdout -- just let the internal stream state record
+   the failure.  That's what the ferror test is checking below.
+
+   It's important to detect such failures and exit nonzero because many
+   tools (most notably 'make' and other build-management systems) depend
+   on being able to detect failure in other tools via their exit status.  */
+
+static void
+close_stdout (void)
+{
+  int prev_fail = ferror (stdout);
+  int fclose_fail = fclose (stdout);
+
+  if (prev_fail || fclose_fail)
+    {
+      if (fclose_fail)
+        perror_with_name (_("write error: stdout"), "");
+      else
+        O (error, NILF, _("write error: stdout"));
+      exit (MAKE_TROUBLE);
+    }
+}
+
+
+void
+output_init (struct output *out)
+{
+  if (out)
+    {
+      out->out = out->err = OUTPUT_NONE;
+      out->syncout = !!output_sync;
+      return;
+    }
+
+  /* Configure this instance of make.  Be sure stdout is line-buffered.  */
+
+#ifdef HAVE_SETVBUF
+# ifdef SETVBUF_REVERSED
+  setvbuf (stdout, _IOLBF, xmalloc (BUFSIZ), BUFSIZ);
+# else  /* setvbuf not reversed.  */
+  /* Some buggy systems lose if we pass 0 instead of allocating ourselves.  */
+  setvbuf (stdout, 0, _IOLBF, BUFSIZ);
+# endif /* setvbuf reversed.  */
+#elif HAVE_SETLINEBUF
+  setlinebuf (stdout);
+#endif  /* setlinebuf missing.  */
+
+  /* Force stdout/stderr into append mode.  This ensures parallel jobs won't
+     lose output due to overlapping writes.  */
+  set_append_mode (fileno (stdout));
+  set_append_mode (fileno (stderr));
+
+#ifdef HAVE_ATEXIT
+  if (STREAM_OK (stdout))
+    atexit (close_stdout);
+#endif
+}
+
+void
+output_close (struct output *out)
+{
+  if (! out)
+    {
+      if (stdio_traced)
+        log_working_directory (0);
+      return;
+    }
+
+#ifndef NO_OUTPUT_SYNC
+  output_dump (out);
+#endif
+
+  if (out->out >= 0)
+    close (out->out);
+  if (out->err >= 0 && out->err != out->out)
+    close (out->err);
+
+  output_init (out);
+}
+
+/* We're about to generate output: be sure it's set up.  */
+void
+output_start (void)
+{
+#ifndef NO_OUTPUT_SYNC
+  /* If we're syncing output make sure the temporary file is set up.  */
+  if (output_context && output_context->syncout)
+    if (! OUTPUT_ISSET(output_context))
+      setup_tmpfile (output_context);
+#endif
+
+  /* If we're not syncing this output per-line or per-target, make sure we emit
+     the "Entering..." message where appropriate.  */
+  if (output_sync == OUTPUT_SYNC_NONE || output_sync == OUTPUT_SYNC_RECURSE)
+    if (! stdio_traced && print_directory_flag)
+      stdio_traced = log_working_directory (1);
+}
+
+void
+outputs (int is_err, const char *msg)
+{
+  if (! msg || *msg == '\0')
+    return;
+
+  output_start ();
+
+  _outputs (output_context, is_err, msg);
+}
+
+
+static struct fmtstring
+  {
+    char *buffer;
+    size_t size;
+  } fmtbuf = { NULL, 0 };
+
+static char *
+get_buffer (size_t need)
+{
+  /* Make sure we have room.  NEED includes space for \0.  */
+  if (need > fmtbuf.size)
+    {
+      fmtbuf.size += need * 2;
+      fmtbuf.buffer = xrealloc (fmtbuf.buffer, fmtbuf.size);
+    }
+
+  fmtbuf.buffer[need-1] = '\0';
+
+  return fmtbuf.buffer;
+}
+
+/* Print a message on stdout.  */
+
+void
+message (int prefix, size_t len, const char *fmt, ...)
+{
+  va_list args;
+  char *p;
+
+  len += strlen (fmt) + strlen (program) + INTSTR_LENGTH + 4 + 1 + 1;
+  p = get_buffer (len);
+
+  if (prefix)
+    {
+      if (makelevel == 0)
+        sprintf (p, "%s: ", program);
+      else
+        sprintf (p, "%s[%u]: ", program, makelevel);
+      p += strlen (p);
+    }
+
+  va_start (args, fmt);
+  vsprintf (p, fmt, args);
+  va_end (args);
+
+  strcat (p, "\n");
+
+  assert (fmtbuf.buffer[len-1] == '\0');
+  outputs (0, fmtbuf.buffer);
+}
+
+/* Print an error message.  */
+
+void
+error (const floc *flocp, size_t len, const char *fmt, ...)
+{
+  va_list args;
+  char *p;
+
+  len += (strlen (fmt) + strlen (program)
+          + (flocp && flocp->filenm ? strlen (flocp->filenm) : 0)
+          + INTSTR_LENGTH + 4 + 1 + 1);
+  p = get_buffer (len);
+
+  if (flocp && flocp->filenm)
+    sprintf (p, "%s:%lu: ", flocp->filenm, flocp->lineno + flocp->offset);
+  else if (makelevel == 0)
+    sprintf (p, "%s: ", program);
+  else
+    sprintf (p, "%s[%u]: ", program, makelevel);
+  p += strlen (p);
+
+  va_start (args, fmt);
+  vsprintf (p, fmt, args);
+  va_end (args);
+
+  strcat (p, "\n");
+
+  assert (fmtbuf.buffer[len-1] == '\0');
+  outputs (1, fmtbuf.buffer);
+}
+
+/* Print an error message and exit.  */
+
+void
+fatal (const floc *flocp, size_t len, const char *fmt, ...)
+{
+  va_list args;
+  const char *stop = _(".  Stop.\n");
+  char *p;
+
+  len += (strlen (fmt) + strlen (program)
+          + (flocp && flocp->filenm ? strlen (flocp->filenm) : 0)
+          + INTSTR_LENGTH + 8 + strlen (stop) + 1);
+  p = get_buffer (len);
+
+  if (flocp && flocp->filenm)
+    sprintf (p, "%s:%lu: *** ", flocp->filenm, flocp->lineno + flocp->offset);
+  else if (makelevel == 0)
+    sprintf (p, "%s: *** ", program);
+  else
+    sprintf (p, "%s[%u]: *** ", program, makelevel);
+  p += strlen (p);
+
+  va_start (args, fmt);
+  vsprintf (p, fmt, args);
+  va_end (args);
+
+  strcat (p, stop);
+
+  assert (fmtbuf.buffer[len-1] == '\0');
+  outputs (1, fmtbuf.buffer);
+
+  die (MAKE_FAILURE);
+}
+
+/* Print an error message from errno.  */
+
+void
+perror_with_name (const char *str, const char *name)
+{
+  const char *err = strerror (errno);
+  OSSS (error, NILF, _("%s%s: %s"), str, name, err);
+}
+
+/* Print an error message from errno and exit.  */
+
+void
+pfatal_with_name (const char *name)
+{
+  const char *err = strerror (errno);
+  OSS (fatal, NILF, _("%s: %s"), name, err);
+
+  /* NOTREACHED */
+}
+
+/* Print a message about out of memory (not using more heap) and exit.
+   Our goal here is to be sure we don't try to allocate more memory, which
+   means we don't want to use string translations or normal cleanup.  */
+
+void
+out_of_memory ()
+{
+  output_write (FD_STDOUT, program, strlen (program));
+  output_write (FD_STDOUT, STRING_SIZE_TUPLE (": *** virtual memory exhausted\n"));
+  exit (MAKE_FAILURE);
+}
diff --git a/src/output.h b/src/output.h
new file mode 100644
index 0000000..8adec4a
--- /dev/null
+++ b/src/output.h
@@ -0,0 +1,106 @@
+/* Output to stdout / stderr for GNU make
+Copyright (C) 2013-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+struct output
+  {
+    int out;
+    int err;
+    unsigned int syncout:1;     /* True if we want to synchronize output.  */
+ };
+
+extern struct output *output_context;
+extern unsigned int stdio_traced;
+
+#define FD_STDIN  (fileno (stdin))
+#define FD_STDOUT (fileno (stdout))
+#define FD_STDERR (fileno (stderr))
+
+#define OUTPUT_SET(_new)    do{ output_context = (_new)->syncout ? (_new) : NULL; }while(0)
+#define OUTPUT_UNSET()      do{ output_context = NULL; }while(0)
+
+#define OUTPUT_TRACED()     do{ stdio_traced = 1; }while(0)
+#define OUTPUT_IS_TRACED()  (!!stdio_traced)
+
+/* Write a buffer directly to the given file descriptor.
+   This handles errors etc.  */
+int output_write (int fd, const void *buffer, size_t len);
+
+/* Initialize and close a child output structure: if NULL do this program's
+   output (this should only be done once).  */
+void output_init (struct output *out);
+void output_close (struct output *out);
+
+/* In situations where output may be about to be displayed but we're not
+   sure if we've set it up yet, call this.  */
+void output_start (void);
+
+/* Show a message on stdout or stderr.  Will start the output if needed.  */
+void outputs (int is_err, const char *msg);
+
+#if defined(HAVE_FCNTL_H)
+# include <fcntl.h>
+#elif defined(HAVE_SYS_FILE_H)
+# include <sys/file.h>
+#endif
+
+#ifdef NO_OUTPUT_SYNC
+# define RECORD_SYNC_MUTEX(m) \
+    O (error, NILF,                                                    \
+       _("-O[TYPE] (--output-sync[=TYPE]) is not configured for this build."));
+#else
+int output_tmpfd (void);
+/* Dump any child output content to stdout, and reset it.  */
+void output_dump (struct output *out);
+
+# ifdef WINDOWS32
+/* For emulations in w32/compat/posixfcn.c.  */
+#  define F_GETFD 1
+#  define F_SETLKW 2
+/* Implementation note: None of the values of l_type below can be zero
+   -- they are compared with a static instance of the struct, so zero
+   means unknown/invalid, see w32/compat/posixfcn.c. */
+#  define F_WRLCK 1
+#  define F_UNLCK 2
+
+struct flock
+  {
+    short l_type;
+    short l_whence;
+    off_t l_start;
+    off_t l_len;
+    pid_t l_pid;
+  };
+
+/* This type is actually a HANDLE, but we want to avoid including
+   windows.h as much as possible.  */
+typedef intptr_t sync_handle_t;
+
+/* Public functions emulated/provided in posixfcn.c.  */
+int fcntl (intptr_t fd, int cmd, ...);
+intptr_t create_mutex (void);
+int same_stream (FILE *f1, FILE *f2);
+
+#  define RECORD_SYNC_MUTEX(m) record_sync_mutex(m)
+void record_sync_mutex (const char *str);
+void prepare_mutex_handle_string (intptr_t hdl);
+# else  /* !WINDOWS32 */
+
+typedef int sync_handle_t;      /* file descriptor */
+
+#  define RECORD_SYNC_MUTEX(m) (void)(m)
+
+# endif
+#endif  /* !NO_OUTPUT_SYNC */
diff --git a/src/posixos.c b/src/posixos.c
new file mode 100644
index 0000000..1c18daf
--- /dev/null
+++ b/src/posixos.c
@@ -0,0 +1,512 @@
+/* POSIX-based operating system interface for GNU Make.
+Copyright (C) 2016-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+
+#include <stdio.h>
+
+#ifdef HAVE_FCNTL_H
+# include <fcntl.h>
+#elif defined(HAVE_SYS_FILE_H)
+# include <sys/file.h>
+#endif
+
+#if defined(HAVE_PSELECT) && defined(HAVE_SYS_SELECT_H)
+# include <sys/select.h>
+#endif
+
+#include "debug.h"
+#include "job.h"
+#include "os.h"
+
+#ifdef MAKE_JOBSERVER
+
+/* This section provides OS-specific functions to support the jobserver.  */
+
+/* These track the state of the jobserver pipe.  Passed to child instances.  */
+static int job_fds[2] = { -1, -1 };
+
+/* Used to signal read() that a SIGCHLD happened.  Always CLOEXEC.
+   If we use pselect() this will never be created and always -1.
+ */
+static int job_rfd = -1;
+
+/* Token written to the pipe (could be any character...)  */
+static char token = '+';
+
+static int
+make_job_rfd (void)
+{
+#ifdef HAVE_PSELECT
+  /* Pretend we succeeded.  */
+  return 0;
+#else
+  EINTRLOOP (job_rfd, dup (job_fds[0]));
+  if (job_rfd >= 0)
+    fd_noinherit (job_rfd);
+
+  return job_rfd;
+#endif
+}
+
+static void
+set_blocking (int fd, int blocking)
+{
+  // If we're not using pselect() don't change the blocking
+#ifdef HAVE_PSELECT
+  int flags;
+  EINTRLOOP (flags, fcntl (fd, F_GETFL));
+  if (flags >= 0)
+    {
+      int r;
+      flags = blocking ? (flags & ~O_NONBLOCK) : (flags | O_NONBLOCK);
+      EINTRLOOP (r, fcntl (fd, F_SETFL, flags));
+      if (r < 0)
+        pfatal_with_name ("fcntl(O_NONBLOCK)");
+    }
+#endif
+}
+
+unsigned int
+jobserver_setup (int slots)
+{
+  int r;
+
+  EINTRLOOP (r, pipe (job_fds));
+  if (r < 0)
+    pfatal_with_name (_("creating jobs pipe"));
+
+  /* By default we don't send the job pipe FDs to our children.
+     See jobserver_pre_child() and jobserver_post_child().  */
+  fd_noinherit (job_fds[0]);
+  fd_noinherit (job_fds[1]);
+
+  if (make_job_rfd () < 0)
+    pfatal_with_name (_("duping jobs pipe"));
+
+  while (slots--)
+    {
+      EINTRLOOP (r, write (job_fds[1], &token, 1));
+      if (r != 1)
+        pfatal_with_name (_("init jobserver pipe"));
+    }
+
+  /* When using pselect() we want the read to be non-blocking.  */
+  set_blocking (job_fds[0], 0);
+
+  return 1;
+}
+
+unsigned int
+jobserver_parse_auth (const char *auth)
+{
+  /* Given the command-line parameter, parse it.  */
+  if (sscanf (auth, "%d,%d", &job_fds[0], &job_fds[1]) != 2)
+    OS (fatal, NILF,
+        _("internal error: invalid --jobserver-auth string '%s'"), auth);
+
+  DB (DB_JOBS,
+      (_("Jobserver client (fds %d,%d)\n"), job_fds[0], job_fds[1]));
+
+#ifdef HAVE_FCNTL_H
+# define FD_OK(_f) (fcntl ((_f), F_GETFD) != -1)
+#else
+# define FD_OK(_f) 1
+#endif
+
+  /* Make sure our pipeline is valid, and (possibly) create a duplicate pipe,
+     that will be closed in the SIGCHLD handler.  If this fails with EBADF,
+     the parent has closed the pipe on us because it didn't think we were a
+     submake.  If so, warn and default to -j1.  */
+
+  if (!FD_OK (job_fds[0]) || !FD_OK (job_fds[1]) || make_job_rfd () < 0)
+    {
+      if (errno != EBADF)
+        pfatal_with_name (_("jobserver pipeline"));
+
+      job_fds[0] = job_fds[1] = -1;
+
+      return 0;
+    }
+
+  /* When using pselect() we want the read to be non-blocking.  */
+  set_blocking (job_fds[0], 0);
+
+  return 1;
+}
+
+char *
+jobserver_get_auth (void)
+{
+  char *auth = xmalloc ((INTSTR_LENGTH * 2) + 2);
+  sprintf (auth, "%d,%d", job_fds[0], job_fds[1]);
+  return auth;
+}
+
+unsigned int
+jobserver_enabled (void)
+{
+  return job_fds[0] >= 0;
+}
+
+void
+jobserver_clear (void)
+{
+  if (job_fds[0] >= 0)
+    close (job_fds[0]);
+  if (job_fds[1] >= 0)
+    close (job_fds[1]);
+  if (job_rfd >= 0)
+    close (job_rfd);
+
+  job_fds[0] = job_fds[1] = job_rfd = -1;
+}
+
+void
+jobserver_release (int is_fatal)
+{
+  int r;
+  EINTRLOOP (r, write (job_fds[1], &token, 1));
+  if (r != 1)
+    {
+      if (is_fatal)
+        pfatal_with_name (_("write jobserver"));
+      perror_with_name ("write", "");
+    }
+}
+
+unsigned int
+jobserver_acquire_all (void)
+{
+  unsigned int tokens = 0;
+
+  /* Use blocking reads to wait for all outstanding jobs.  */
+  set_blocking (job_fds[0], 1);
+
+  /* Close the write side, so the read() won't hang forever.  */
+  close (job_fds[1]);
+  job_fds[1] = -1;
+
+  while (1)
+    {
+      char intake;
+      int r;
+      EINTRLOOP (r, read (job_fds[0], &intake, 1));
+      if (r != 1)
+        return tokens;
+      ++tokens;
+    }
+}
+
+/* Prepare the jobserver to start a child process.  */
+void
+jobserver_pre_child (int recursive)
+{
+  if (recursive && job_fds[0] >= 0)
+    {
+      fd_inherit (job_fds[0]);
+      fd_inherit (job_fds[1]);
+    }
+}
+
+/* Reconfigure the jobserver after starting a child process.  */
+void
+jobserver_post_child (int recursive)
+{
+  if (recursive && job_fds[0] >= 0)
+    {
+      fd_noinherit (job_fds[0]);
+      fd_noinherit (job_fds[1]);
+    }
+}
+
+void
+jobserver_signal (void)
+{
+  if (job_rfd >= 0)
+    {
+      close (job_rfd);
+      job_rfd = -1;
+    }
+}
+
+void
+jobserver_pre_acquire (void)
+{
+  /* Make sure we have a dup'd FD.  */
+  if (job_rfd < 0 && job_fds[0] >= 0 && make_job_rfd () < 0)
+    pfatal_with_name (_("duping jobs pipe"));
+}
+
+#ifdef HAVE_PSELECT
+
+/* Use pselect() to atomically wait for both a signal and a file descriptor.
+   It also provides a timeout facility so we don't need to use SIGALRM.
+
+   This method relies on the fact that SIGCHLD will be blocked everywhere,
+   and only unblocked (atomically) within the pselect() call, so we can
+   never miss a SIGCHLD.
+ */
+unsigned int
+jobserver_acquire (int timeout)
+{
+  struct timespec spec;
+  struct timespec *specp = NULL;
+  sigset_t empty;
+
+  sigemptyset (&empty);
+
+  if (timeout)
+    {
+      /* Alarm after one second (is this too granular?)  */
+      spec.tv_sec = 1;
+      spec.tv_nsec = 0;
+      specp = &spec;
+    }
+
+  while (1)
+    {
+      fd_set readfds;
+      int r;
+      char intake;
+
+      FD_ZERO (&readfds);
+      FD_SET (job_fds[0], &readfds);
+
+      r = pselect (job_fds[0]+1, &readfds, NULL, NULL, specp, &empty);
+      if (r < 0)
+        switch (errno)
+          {
+          case EINTR:
+            /* SIGCHLD will show up as an EINTR.  */
+            return 0;
+
+          case EBADF:
+            /* Someone closed the jobs pipe.
+               That shouldn't happen but if it does we're done.  */
+              O (fatal, NILF, _("job server shut down"));
+
+          default:
+            pfatal_with_name (_("pselect jobs pipe"));
+          }
+
+      if (r == 0)
+        /* Timeout.  */
+        return 0;
+
+      /* The read FD is ready: read it!  This is non-blocking.  */
+      EINTRLOOP (r, read (job_fds[0], &intake, 1));
+
+      if (r < 0)
+        {
+          /* Someone sniped our token!  Try again.  */
+          if (errno == EAGAIN)
+            continue;
+
+          pfatal_with_name (_("read jobs pipe"));
+        }
+
+      /* read() should never return 0: only the master make can reap all the
+         tokens and close the write side...??  */
+      return r > 0;
+    }
+}
+
+#else
+
+/* This method uses a "traditional" UNIX model for waiting on both a signal
+   and a file descriptor.  However, it's complex and since we have a SIGCHLD
+   handler installed we need to check ALL system calls for EINTR: painful!
+
+   Read a token.  As long as there's no token available we'll block.  We
+   enable interruptible system calls before the read(2) so that if we get a
+   SIGCHLD while we're waiting, we'll return with EINTR and we can process the
+   death(s) and return tokens to the free pool.
+
+   Once we return from the read, we immediately reinstate restartable system
+   calls.  This allows us to not worry about checking for EINTR on all the
+   other system calls in the program.
+
+   There is one other twist: there is a span between the time reap_children()
+   does its last check for dead children and the time the read(2) call is
+   entered, below, where if a child dies we won't notice.  This is extremely
+   serious as it could cause us to deadlock, given the right set of events.
+
+   To avoid this, we do the following: before we reap_children(), we dup(2)
+   the read FD on the jobserver pipe.  The read(2) call below uses that new
+   FD.  In the signal handler, we close that FD.  That way, if a child dies
+   during the section mentioned above, the read(2) will be invoked with an
+   invalid FD and will return immediately with EBADF.  */
+
+static RETSIGTYPE
+job_noop (int sig UNUSED)
+{
+}
+
+/* Set the child handler action flags to FLAGS.  */
+static void
+set_child_handler_action_flags (int set_handler, int set_alarm)
+{
+  struct sigaction sa;
+
+#ifdef __EMX__
+  /* The child handler must be turned off here.  */
+  signal (SIGCHLD, SIG_DFL);
+#endif
+
+  memset (&sa, '\0', sizeof sa);
+  sa.sa_handler = child_handler;
+  sa.sa_flags = set_handler ? 0 : SA_RESTART;
+
+#if defined SIGCHLD
+  if (sigaction (SIGCHLD, &sa, NULL) < 0)
+    pfatal_with_name ("sigaction: SIGCHLD");
+#endif
+
+#if defined SIGCLD && SIGCLD != SIGCHLD
+  if (sigaction (SIGCLD, &sa, NULL) < 0)
+    pfatal_with_name ("sigaction: SIGCLD");
+#endif
+
+#if defined SIGALRM
+  if (set_alarm)
+    {
+      /* If we're about to enter the read(), set an alarm to wake up in a
+         second so we can check if the load has dropped and we can start more
+         work.  On the way out, turn off the alarm and set SIG_DFL.  */
+      if (set_handler)
+        {
+          sa.sa_handler = job_noop;
+          sa.sa_flags = 0;
+          if (sigaction (SIGALRM, &sa, NULL) < 0)
+            pfatal_with_name ("sigaction: SIGALRM");
+          alarm (1);
+        }
+      else
+        {
+          alarm (0);
+          sa.sa_handler = SIG_DFL;
+          sa.sa_flags = 0;
+          if (sigaction (SIGALRM, &sa, NULL) < 0)
+            pfatal_with_name ("sigaction: SIGALRM");
+        }
+    }
+#endif
+}
+
+unsigned int
+jobserver_acquire (int timeout)
+{
+  char intake;
+  int got_token;
+  int saved_errno;
+
+  /* Set interruptible system calls, and read() for a job token.  */
+  set_child_handler_action_flags (1, timeout);
+
+  EINTRLOOP (got_token, read (job_rfd, &intake, 1));
+  saved_errno = errno;
+
+  set_child_handler_action_flags (0, timeout);
+
+  if (got_token == 1)
+    return 1;
+
+  /* If the error _wasn't_ expected (EINTR or EBADF), fatal.  Otherwise,
+     go back and reap_children(), and try again.  */
+  errno = saved_errno;
+
+  if (errno != EINTR && errno != EBADF)
+    pfatal_with_name (_("read jobs pipe"));
+
+  if (errno == EBADF)
+    DB (DB_JOBS, ("Read returned EBADF.\n"));
+
+  return 0;
+}
+
+#endif /* HAVE_PSELECT */
+
+#endif /* MAKE_JOBSERVER */
+
+/* Create a "bad" file descriptor for stdin when parallel jobs are run.  */
+int
+get_bad_stdin (void)
+{
+  static int bad_stdin = -1;
+
+  /* Set up a bad standard input that reads from a broken pipe.  */
+
+  if (bad_stdin == -1)
+    {
+      /* Make a file descriptor that is the read end of a broken pipe.
+         This will be used for some children's standard inputs.  */
+      int pd[2];
+      if (pipe (pd) == 0)
+        {
+          /* Close the write side.  */
+          (void) close (pd[1]);
+          /* Save the read side.  */
+          bad_stdin = pd[0];
+
+          /* Set the descriptor to close on exec, so it does not litter any
+             child's descriptor table.  When it is dup2'd onto descriptor 0,
+             that descriptor will not close on exec.  */
+          fd_noinherit (bad_stdin);
+        }
+    }
+
+  return bad_stdin;
+}
+
+/* Set file descriptors to be inherited / not inherited by subprocesses.  */
+
+#if !defined(F_SETFD) || !defined(F_GETFD)
+void fd_inherit (int fd) {}
+void fd_noinherit (int fd) {}
+
+#else
+
+# ifndef FD_CLOEXEC
+#  define FD_CLOEXEC 1
+# endif
+
+void
+fd_inherit (int fd)
+{
+  int flags;
+  EINTRLOOP (flags, fcntl (fd, F_GETFD));
+  if (flags >= 0)
+    {
+      int r;
+      flags &= ~FD_CLOEXEC;
+      EINTRLOOP (r, fcntl (fd, F_SETFD, flags));
+    }
+}
+
+void
+fd_noinherit (int fd)
+{
+    int flags;
+    EINTRLOOP(flags, fcntl(fd, F_GETFD));
+    if (flags >= 0)
+      {
+        int r;
+        flags |= FD_CLOEXEC;
+        EINTRLOOP(r, fcntl(fd, F_SETFD, flags));
+      }
+}
+#endif
diff --git a/src/read.c b/src/read.c
new file mode 100644
index 0000000..db1a42d
--- /dev/null
+++ b/src/read.c
@@ -0,0 +1,3394 @@
+/* Reading and parsing of makefiles for GNU Make.
+Copyright (C) 1988-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+
+#include <assert.h>
+
+#include "filedef.h"
+#include "dep.h"
+#include "job.h"
+#include "os.h"
+#include "commands.h"
+#include "variable.h"
+#include "rule.h"
+#include "debug.h"
+#include "hash.h"
+
+
+#ifdef WINDOWS32
+#include <windows.h>
+#include "sub_proc.h"
+#else  /* !WINDOWS32 */
+#ifndef _AMIGA
+#ifndef VMS
+#include <pwd.h>
+#else
+struct passwd *getpwnam (char *name);
+#endif
+#endif
+#endif /* !WINDOWS32 */
+
+/* A 'struct ebuffer' controls the origin of the makefile we are currently
+   eval'ing.
+*/
+
+struct ebuffer
+  {
+    char *buffer;       /* Start of the current line in the buffer.  */
+    char *bufnext;      /* Start of the next line in the buffer.  */
+    char *bufstart;     /* Start of the entire buffer.  */
+    unsigned int size;  /* Malloc'd size of buffer. */
+    FILE *fp;           /* File, or NULL if this is an internal buffer.  */
+    floc floc;          /* Info on the file in fp (if any).  */
+  };
+
+/* Track the modifiers we can have on variable assignments */
+
+struct vmodifiers
+  {
+    unsigned int assign_v:1;
+    unsigned int define_v:1;
+    unsigned int undefine_v:1;
+    unsigned int export_v:1;
+    unsigned int override_v:1;
+    unsigned int private_v:1;
+  };
+
+/* Types of "words" that can be read in a makefile.  */
+enum make_word_type
+  {
+     w_bogus, w_eol, w_static, w_variable, w_colon, w_dcolon, w_semicolon,
+     w_varassign
+  };
+
+
+/* A 'struct conditionals' contains the information describing
+   all the active conditionals in a makefile.
+
+   The global variable 'conditionals' contains the conditionals
+   information for the current makefile.  It is initialized from
+   the static structure 'toplevel_conditionals' and is later changed
+   to new structures for included makefiles.  */
+
+struct conditionals
+  {
+    unsigned int if_cmds;       /* Depth of conditional nesting.  */
+    unsigned int allocated;     /* Elts allocated in following arrays.  */
+    char *ignoring;             /* Are we ignoring or interpreting?
+                                   0=interpreting, 1=not yet interpreted,
+                                   2=already interpreted */
+    char *seen_else;            /* Have we already seen an 'else'?  */
+  };
+
+static struct conditionals toplevel_conditionals;
+static struct conditionals *conditionals = &toplevel_conditionals;
+
+
+/* Default directories to search for include files in  */
+
+static const char *default_include_directories[] =
+  {
+#if defined(WINDOWS32) && !defined(INCLUDEDIR)
+/* This completely up to the user when they install MSVC or other packages.
+   This is defined as a placeholder.  */
+# define INCLUDEDIR "."
+#endif
+    INCLUDEDIR,
+#ifndef _AMIGA
+    "/usr/gnu/include",
+    "/usr/local/include",
+    "/usr/include",
+#endif
+    0
+  };
+
+/* List of directories to search for include files in  */
+
+static const char **include_directories;
+
+/* Maximum length of an element of the above.  */
+
+static unsigned int max_incl_len;
+
+/* The filename and pointer to line number of the
+   makefile currently being read in.  */
+
+const floc *reading_file = 0;
+
+/* The chain of files read by read_all_makefiles.  */
+
+static struct goaldep *read_files = 0;
+
+static struct goaldep *eval_makefile (const char *filename, int flags);
+static void eval (struct ebuffer *buffer, int flags);
+
+static long readline (struct ebuffer *ebuf);
+static void do_undefine (char *name, enum variable_origin origin,
+                         struct ebuffer *ebuf);
+static struct variable *do_define (char *name, enum variable_origin origin,
+                                   struct ebuffer *ebuf);
+static int conditional_line (char *line, int len, const floc *flocp);
+static void record_files (struct nameseq *filenames, const char *pattern,
+                          const char *pattern_percent, char *depstr,
+                          unsigned int cmds_started, char *commands,
+                          unsigned int commands_idx, int two_colon,
+                          char prefix, const floc *flocp);
+static void record_target_var (struct nameseq *filenames, char *defn,
+                               enum variable_origin origin,
+                               struct vmodifiers *vmod,
+                               const floc *flocp);
+static enum make_word_type get_next_mword (char *buffer, char *delim,
+                                           char **startp, unsigned int *length);
+static void remove_comments (char *line);
+static char *find_map_unquote (char *string, int map);
+static char *find_char_unquote (char *string, int stop);
+static char *unescape_char (char *string, int c);
+
+
+/* Compare a word, both length and contents.
+   P must point to the word to be tested, and WLEN must be the length.
+*/
+#define word1eq(s)      (wlen == CSTRLEN (s) && strneq (s, p, CSTRLEN (s)))
+
+
+/* Read in all the makefiles and return a chain of targets to rebuild.  */
+
+struct goaldep *
+read_all_makefiles (const char **makefiles)
+{
+  unsigned int num_makefiles = 0;
+
+  /* Create *_LIST variables, to hold the makefiles, targets, and variables
+     we will be reading. */
+
+  define_variable_cname ("MAKEFILE_LIST", "", o_file, 0);
+
+  DB (DB_BASIC, (_("Reading makefiles...\n")));
+
+  /* If there's a non-null variable MAKEFILES, its value is a list of
+     files to read first thing.  But don't let it prevent reading the
+     default makefiles and don't let the default goal come from there.  */
+
+  {
+    char *value;
+    char *name, *p;
+    unsigned int length;
+
+    {
+      /* Turn off --warn-undefined-variables while we expand MAKEFILES.  */
+      int save = warn_undefined_variables_flag;
+      warn_undefined_variables_flag = 0;
+
+      value = allocated_variable_expand ("$(MAKEFILES)");
+
+      warn_undefined_variables_flag = save;
+    }
+
+    /* Set NAME to the start of next token and LENGTH to its length.
+       MAKEFILES is updated for finding remaining tokens.  */
+    p = value;
+
+    while ((name = find_next_token ((const char **)&p, &length)) != 0)
+      {
+        if (*p != '\0')
+          *p++ = '\0';
+        eval_makefile (strcache_add (name), RM_NO_DEFAULT_GOAL|RM_INCLUDED|RM_DONTCARE);
+      }
+
+    free (value);
+  }
+
+  /* Read makefiles specified with -f switches.  */
+
+  if (makefiles != 0)
+    while (*makefiles != 0)
+      {
+        struct goaldep *d = eval_makefile (*makefiles, 0);
+
+        if (errno)
+          perror_with_name ("", *makefiles);
+
+        /* Reuse the storage allocated for the read_file.  */
+        *makefiles = dep_name (d);
+        ++num_makefiles;
+        ++makefiles;
+      }
+
+  /* If there were no -f switches, try the default names.  */
+
+  if (num_makefiles == 0)
+    {
+      static const char *default_makefiles[] =
+#ifdef VMS
+        /* all lower case since readdir() (the vms version) 'lowercasifies' */
+        /* TODO: Above is not always true, this needs more work */
+        { "makefile.vms", "gnumakefile", "makefile", 0 };
+#else
+#ifdef _AMIGA
+        { "GNUmakefile", "Makefile", "SMakefile", 0 };
+#else /* !Amiga && !VMS */
+#ifdef WINDOWS32
+        { "GNUmakefile", "makefile", "Makefile", "makefile.mak", 0 };
+#else /* !Amiga && !VMS && !WINDOWS32 */
+        { "GNUmakefile", "makefile", "Makefile", 0 };
+#endif /* !Amiga && !VMS && !WINDOWS32 */
+#endif /* AMIGA */
+#endif /* VMS */
+      const char **p = default_makefiles;
+      while (*p != 0 && !file_exists_p (*p))
+        ++p;
+
+      if (*p != 0)
+        {
+          eval_makefile (*p, 0);
+          if (errno)
+            perror_with_name ("", *p);
+        }
+      else
+        {
+          /* No default makefile was found.  Add the default makefiles to the
+             'read_files' chain so they will be updated if possible.  */
+          struct goaldep *tail = read_files;
+          /* Add them to the tail, after any MAKEFILES variable makefiles.  */
+          while (tail != 0 && tail->next != 0)
+            tail = tail->next;
+          for (p = default_makefiles; *p != 0; ++p)
+            {
+              struct goaldep *d = alloc_goaldep ();
+              d->file = enter_file (strcache_add (*p));
+              /* Tell update_goal_chain to bail out as soon as this file is
+                 made, and main not to die if we can't make this file.  */
+              d->flags = RM_DONTCARE;
+              if (tail == 0)
+                read_files = d;
+              else
+                tail->next = d;
+              tail = d;
+            }
+          if (tail != 0)
+            tail->next = 0;
+        }
+    }
+
+  return read_files;
+}
+
+/* Install a new conditional and return the previous one.  */
+
+static struct conditionals *
+install_conditionals (struct conditionals *new)
+{
+  struct conditionals *save = conditionals;
+
+  memset (new, '\0', sizeof (*new));
+  conditionals = new;
+
+  return save;
+}
+
+/* Free the current conditionals and reinstate a saved one.  */
+
+static void
+restore_conditionals (struct conditionals *saved)
+{
+  /* Free any space allocated by conditional_line.  */
+  free (conditionals->ignoring);
+  free (conditionals->seen_else);
+
+  /* Restore state.  */
+  conditionals = saved;
+}
+
+static struct goaldep *
+eval_makefile (const char *filename, int flags)
+{
+  struct goaldep *deps;
+  struct ebuffer ebuf;
+  const floc *curfile;
+  char *expanded = 0;
+
+  /* Create a new goaldep entry.  */
+  deps = alloc_goaldep ();
+  deps->next = read_files;
+  read_files = deps;
+
+  ebuf.floc.filenm = filename; /* Use the original file name.  */
+  ebuf.floc.lineno = 1;
+  ebuf.floc.offset = 0;
+
+  if (ISDB (DB_VERBOSE))
+    {
+      printf (_("Reading makefile '%s'"), filename);
+      if (flags & RM_NO_DEFAULT_GOAL)
+        printf (_(" (no default goal)"));
+      if (flags & RM_INCLUDED)
+        printf (_(" (search path)"));
+      if (flags & RM_DONTCARE)
+        printf (_(" (don't care)"));
+      if (flags & RM_NO_TILDE)
+        printf (_(" (no ~ expansion)"));
+      puts ("...");
+    }
+
+  /* First, get a stream to read.  */
+
+  /* Expand ~ in FILENAME unless it came from 'include',
+     in which case it was already done.  */
+  if (!(flags & RM_NO_TILDE) && filename[0] == '~')
+    {
+      expanded = tilde_expand (filename);
+      if (expanded != 0)
+        filename = expanded;
+    }
+
+  errno = 0;
+  ENULLLOOP (ebuf.fp, fopen (filename, "r"));
+  deps->error = errno;
+
+  /* Check for unrecoverable errors: out of mem or FILE slots.  */
+  switch (deps->error)
+    {
+#ifdef EMFILE
+    case EMFILE:
+#endif
+#ifdef ENFILE
+    case ENFILE:
+#endif
+    case ENOMEM:
+      {
+        const char *err = strerror (deps->error);
+        OS (fatal, reading_file, "%s", err);
+      }
+    }
+
+  /* If the makefile wasn't found and it's either a makefile from
+     the 'MAKEFILES' variable or an included makefile,
+     search the included makefile search path for this makefile.  */
+  if (ebuf.fp == 0 && (flags & RM_INCLUDED) && *filename != '/')
+    {
+      unsigned int i;
+      for (i = 0; include_directories[i] != 0; ++i)
+        {
+          const char *included = concat (3, include_directories[i],
+                                         "/", filename);
+          ebuf.fp = fopen (included, "r");
+          if (ebuf.fp)
+            {
+              filename = included;
+              break;
+            }
+        }
+    }
+
+  /* Enter the final name for this makefile as a goaldep.  */
+  filename = strcache_add (filename);
+  deps->file = lookup_file (filename);
+  if (deps->file == 0)
+    deps->file = enter_file (filename);
+  filename = deps->file->name;
+  deps->flags = flags;
+
+  free (expanded);
+
+  if (ebuf.fp == 0)
+    {
+      /* The makefile can't be read at all, give up entirely.
+         If we did some searching errno has the error from the last attempt,
+         rather from FILENAME itself: recover the more accurate one.  */
+      errno = deps->error;
+      deps->file->last_mtime = NONEXISTENT_MTIME;
+      return deps;
+    }
+
+  /* Success; clear errno.  */
+  deps->error = 0;
+
+  /* Avoid leaking the makefile to children.  */
+  fd_noinherit (fileno (ebuf.fp));
+
+  /* Add this makefile to the list. */
+  do_variable_definition (&ebuf.floc, "MAKEFILE_LIST", filename, o_file,
+                          f_append_value, 0);
+
+  /* Evaluate the makefile */
+
+  ebuf.size = 200;
+  ebuf.buffer = ebuf.bufnext = ebuf.bufstart = xmalloc (ebuf.size);
+
+  curfile = reading_file;
+  reading_file = &ebuf.floc;
+
+  eval (&ebuf, !(flags & RM_NO_DEFAULT_GOAL));
+
+  reading_file = curfile;
+
+  fclose (ebuf.fp);
+
+  free (ebuf.bufstart);
+  alloca (0);
+
+  errno = 0;
+  return deps;
+}
+
+void
+eval_buffer (char *buffer, const floc *flocp)
+{
+  struct ebuffer ebuf;
+  struct conditionals *saved;
+  struct conditionals new;
+  const floc *curfile;
+
+  /* Evaluate the buffer */
+
+  ebuf.size = strlen (buffer);
+  ebuf.buffer = ebuf.bufnext = ebuf.bufstart = buffer;
+  ebuf.fp = NULL;
+
+  if (flocp)
+    ebuf.floc = *flocp;
+  else if (reading_file)
+    ebuf.floc = *reading_file;
+  else
+    {
+      ebuf.floc.filenm = NULL;
+      ebuf.floc.lineno = 1;
+      ebuf.floc.offset = 0;
+    }
+
+  curfile = reading_file;
+  reading_file = &ebuf.floc;
+
+  saved = install_conditionals (&new);
+
+  eval (&ebuf, 1);
+
+  restore_conditionals (saved);
+
+  reading_file = curfile;
+
+  alloca (0);
+}
+
+/* Check LINE to see if it's a variable assignment or undefine.
+
+   It might use one of the modifiers "export", "override", "private", or it
+   might be one of the conditional tokens like "ifdef", "include", etc.
+
+   If it's not a variable assignment or undefine, VMOD.V_ASSIGN is 0.
+   Returns LINE.
+
+   Returns a pointer to the first non-modifier character, and sets VMOD
+   based on the modifiers found if any, plus V_ASSIGN is 1.
+ */
+static char *
+parse_var_assignment (const char *line, struct vmodifiers *vmod)
+{
+  const char *p;
+  memset (vmod, '\0', sizeof (*vmod));
+
+  /* Find the start of the next token.  If there isn't one we're done.  */
+  NEXT_TOKEN (line);
+  if (*line == '\0')
+    return (char *)line;
+
+  p = line;
+  while (1)
+    {
+      int wlen;
+      const char *p2;
+      struct variable v;
+
+      p2 = parse_variable_definition (p, &v);
+
+      /* If this is a variable assignment, we're done.  */
+      if (p2)
+        break;
+
+      /* It's not a variable; see if it's a modifier.  */
+      p2 = end_of_token (p);
+      wlen = p2 - p;
+
+      if (word1eq ("export"))
+        vmod->export_v = 1;
+      else if (word1eq ("override"))
+        vmod->override_v = 1;
+      else if (word1eq ("private"))
+        vmod->private_v = 1;
+      else if (word1eq ("define"))
+        {
+          /* We can't have modifiers after 'define' */
+          vmod->define_v = 1;
+          p = next_token (p2);
+          break;
+        }
+      else if (word1eq ("undefine"))
+        {
+          /* We can't have modifiers after 'undefine' */
+          vmod->undefine_v = 1;
+          p = next_token (p2);
+          break;
+        }
+      else
+        /* Not a variable or modifier: this is not a variable assignment.  */
+        return (char *)line;
+
+      /* It was a modifier.  Try the next word.  */
+      p = next_token (p2);
+      if (*p == '\0')
+        return (char *)line;
+    }
+
+  /* Found a variable assignment or undefine.  */
+  vmod->assign_v = 1;
+  return (char *)p;
+}
+
+
+/* Read file FILENAME as a makefile and add its contents to the data base.
+
+   SET_DEFAULT is true if we are allowed to set the default goal.  */
+
+static void
+eval (struct ebuffer *ebuf, int set_default)
+{
+  char *collapsed = 0;
+  unsigned int collapsed_length = 0;
+  unsigned int commands_len = 200;
+  char *commands;
+  unsigned int commands_idx = 0;
+  unsigned int cmds_started, tgts_started;
+  int ignoring = 0, in_ignored_define = 0;
+  int no_targets = 0;           /* Set when reading a rule without targets.  */
+  struct nameseq *filenames = 0;
+  char *depstr = 0;
+  long nlines = 0;
+  int two_colon = 0;
+  char prefix = cmd_prefix;
+  const char *pattern = 0;
+  const char *pattern_percent;
+  floc *fstart;
+  floc fi;
+
+#define record_waiting_files()                                                \
+  do                                                                          \
+    {                                                                         \
+      if (filenames != 0)                                                     \
+        {                                                                     \
+          fi.lineno = tgts_started;                                           \
+          fi.offset = 0;                                                      \
+          record_files (filenames, pattern, pattern_percent, depstr,          \
+                        cmds_started, commands, commands_idx, two_colon,      \
+                        prefix, &fi);                                         \
+          filenames = 0;                                                      \
+        }                                                                     \
+      commands_idx = 0;                                                       \
+      no_targets = 0;                                                         \
+      pattern = 0;                                                            \
+    } while (0)
+
+  pattern_percent = 0;
+  cmds_started = tgts_started = 1;
+
+  fstart = &ebuf->floc;
+  fi.filenm = ebuf->floc.filenm;
+
+  /* Loop over lines in the file.
+     The strategy is to accumulate target names in FILENAMES, dependencies
+     in DEPS and commands in COMMANDS.  These are used to define a rule
+     when the start of the next rule (or eof) is encountered.
+
+     When you see a "continue" in the loop below, that means we are moving on
+     to the next line.  If you see record_waiting_files(), then the statement
+     we are parsing also finishes the previous rule.  */
+
+  commands = xmalloc (200);
+
+  while (1)
+    {
+      unsigned int linelen;
+      char *line;
+      unsigned int wlen;
+      char *p;
+      char *p2;
+      struct vmodifiers vmod;
+
+      /* At the top of this loop, we are starting a brand new line.  */
+      /* Grab the next line to be evaluated */
+      ebuf->floc.lineno += nlines;
+      nlines = readline (ebuf);
+
+      /* If there is nothing left to eval, we're done.  */
+      if (nlines < 0)
+        break;
+
+      line = ebuf->buffer;
+
+      /* If this is the first line, check for a UTF-8 BOM and skip it.  */
+      if (ebuf->floc.lineno == 1 && line[0] == (char)0xEF
+          && line[1] == (char)0xBB && line[2] == (char)0xBF)
+        {
+          line += 3;
+          if (ISDB(DB_BASIC))
+            {
+              if (ebuf->floc.filenm)
+                printf (_("Skipping UTF-8 BOM in makefile '%s'\n"),
+                        ebuf->floc.filenm);
+              else
+                printf (_("Skipping UTF-8 BOM in makefile buffer\n"));
+            }
+        }
+
+      /* If this line is empty, skip it.  */
+      if (line[0] == '\0')
+        continue;
+
+      linelen = strlen (line);
+
+      /* Check for a shell command line first.
+         If it is not one, we can stop treating cmd_prefix specially.  */
+      if (line[0] == cmd_prefix)
+        {
+          if (no_targets)
+            /* Ignore the commands in a rule with no targets.  */
+            continue;
+
+          /* If there is no preceding rule line, don't treat this line
+             as a command, even though it begins with a recipe prefix.
+             SunOS 4 make appears to behave this way.  */
+
+          if (filenames != 0)
+            {
+              if (ignoring)
+                /* Yep, this is a shell command, and we don't care.  */
+                continue;
+
+              if (commands_idx == 0)
+                cmds_started = ebuf->floc.lineno;
+
+              /* Append this command line to the line being accumulated.
+                 Skip the initial command prefix character.  */
+              if (linelen + commands_idx > commands_len)
+                {
+                  commands_len = (linelen + commands_idx) * 2;
+                  commands = xrealloc (commands, commands_len);
+                }
+              memcpy (&commands[commands_idx], line + 1, linelen - 1);
+              commands_idx += linelen - 1;
+              commands[commands_idx++] = '\n';
+              continue;
+            }
+        }
+
+      /* This line is not a shell command line.  Don't worry about whitespace.
+         Get more space if we need it; we don't need to preserve the current
+         contents of the buffer.  */
+
+      if (collapsed_length < linelen+1)
+        {
+          collapsed_length = linelen+1;
+          free (collapsed);
+          /* Don't need xrealloc: we don't need to preserve the content.  */
+          collapsed = xmalloc (collapsed_length);
+        }
+      strcpy (collapsed, line);
+      /* Collapse continuation lines.  */
+      collapse_continuations (collapsed);
+      remove_comments (collapsed);
+
+      /* Get rid if starting space (including formfeed, vtab, etc.)  */
+      p = collapsed;
+      NEXT_TOKEN (p);
+
+      /* See if this is a variable assignment.  We need to do this early, to
+         allow variables with names like 'ifdef', 'export', 'private', etc.  */
+      p = parse_var_assignment (p, &vmod);
+      if (vmod.assign_v)
+        {
+          struct variable *v;
+          enum variable_origin origin = vmod.override_v ? o_override : o_file;
+
+          /* If we're ignoring then we're done now.  */
+          if (ignoring)
+            {
+              if (vmod.define_v)
+                in_ignored_define = 1;
+              continue;
+            }
+
+          /* Variable assignment ends the previous rule.  */
+          record_waiting_files ();
+
+          if (vmod.undefine_v)
+          {
+            do_undefine (p, origin, ebuf);
+            continue;
+          }
+          else if (vmod.define_v)
+            v = do_define (p, origin, ebuf);
+          else
+            v = try_variable_definition (fstart, p, origin, 0);
+
+          assert (v != NULL);
+
+          if (vmod.export_v)
+            v->export = v_export;
+          if (vmod.private_v)
+            v->private_var = 1;
+
+          /* This line has been dealt with.  */
+          continue;
+        }
+
+      /* If this line is completely empty, ignore it.  */
+      if (*p == '\0')
+        continue;
+
+      p2 = end_of_token (p);
+      wlen = p2 - p;
+      NEXT_TOKEN (p2);
+
+      /* If we're in an ignored define, skip this line (but maybe get out).  */
+      if (in_ignored_define)
+        {
+          /* See if this is an endef line (plus optional comment).  */
+          if (word1eq ("endef") && STOP_SET (*p2, MAP_COMMENT|MAP_NUL))
+            in_ignored_define = 0;
+
+          continue;
+        }
+
+      /* Check for conditional state changes.  */
+      {
+        int i = conditional_line (p, wlen, fstart);
+        if (i != -2)
+          {
+            if (i == -1)
+              O (fatal, fstart, _("invalid syntax in conditional"));
+
+            ignoring = i;
+            continue;
+          }
+      }
+
+      /* Nothing to see here... move along.  */
+      if (ignoring)
+        continue;
+
+      /* Manage the "export" keyword used outside of variable assignment
+         as well as "unexport".  */
+      if (word1eq ("export") || word1eq ("unexport"))
+        {
+          int exporting = *p == 'u' ? 0 : 1;
+
+          /* Export/unexport ends the previous rule.  */
+          record_waiting_files ();
+
+          /* (un)export by itself causes everything to be (un)exported. */
+          if (*p2 == '\0')
+            export_all_variables = exporting;
+          else
+            {
+              unsigned int l;
+              const char *cp;
+              char *ap;
+
+              /* Expand the line so we can use indirect and constructed
+                 variable names in an (un)export command.  */
+              cp = ap = allocated_variable_expand (p2);
+
+              for (p = find_next_token (&cp, &l); p != 0;
+                   p = find_next_token (&cp, &l))
+                {
+                  struct variable *v = lookup_variable (p, l);
+                  if (v == 0)
+                    v = define_variable_global (p, l, "", o_file, 0, fstart);
+                  v->export = exporting ? v_export : v_noexport;
+                }
+
+              free (ap);
+            }
+          continue;
+        }
+
+      /* Handle the special syntax for vpath.  */
+      if (word1eq ("vpath"))
+        {
+          const char *cp;
+          char *vpat;
+          unsigned int l;
+
+          /* vpath ends the previous rule.  */
+          record_waiting_files ();
+
+          cp = variable_expand (p2);
+          p = find_next_token (&cp, &l);
+          if (p != 0)
+            {
+              vpat = xstrndup (p, l);
+              p = find_next_token (&cp, &l);
+              /* No searchpath means remove all previous
+                 selective VPATH's with the same pattern.  */
+            }
+          else
+            /* No pattern means remove all previous selective VPATH's.  */
+            vpat = 0;
+          construct_vpath_list (vpat, p);
+          free (vpat);
+
+          continue;
+        }
+
+      /* Handle include and variants.  */
+      if (word1eq ("include") || word1eq ("-include") || word1eq ("sinclude"))
+        {
+          /* We have found an 'include' line specifying a nested
+             makefile to be read at this point.  */
+          struct conditionals *save;
+          struct conditionals new_conditionals;
+          struct nameseq *files;
+          /* "-include" (vs "include") says no error if the file does not
+             exist.  "sinclude" is an alias for this from SGI.  */
+          int noerror = (p[0] != 'i');
+
+          /* Include ends the previous rule.  */
+          record_waiting_files ();
+
+          p = allocated_variable_expand (p2);
+
+          /* If no filenames, it's a no-op.  */
+          if (*p == '\0')
+            {
+              free (p);
+              continue;
+            }
+
+          /* Parse the list of file names.  Don't expand archive references!  */
+          p2 = p;
+          files = PARSE_FILE_SEQ (&p2, struct nameseq, MAP_NUL, NULL,
+                                  PARSEFS_NOAR);
+          free (p);
+
+          /* Save the state of conditionals and start
+             the included makefile with a clean slate.  */
+          save = install_conditionals (&new_conditionals);
+
+          /* Record the rules that are waiting so they will determine
+             the default goal before those in the included makefile.  */
+          record_waiting_files ();
+
+          /* Read each included makefile.  */
+          while (files != 0)
+            {
+              struct nameseq *next = files->next;
+              int flags = (RM_INCLUDED | RM_NO_TILDE
+                           | (noerror ? RM_DONTCARE : 0)
+                           | (set_default ? 0 : RM_NO_DEFAULT_GOAL));
+
+              struct goaldep *d = eval_makefile (files->name, flags);
+
+              if (errno)
+                d->floc = *fstart;
+
+              free_ns (files);
+              files = next;
+            }
+
+          /* Restore conditional state.  */
+          restore_conditionals (save);
+
+          continue;
+        }
+
+      /* Handle the load operations.  */
+      if (word1eq ("load") || word1eq ("-load"))
+        {
+          /* A 'load' line specifies a dynamic object to load.  */
+          struct nameseq *files;
+          int noerror = (p[0] == '-');
+
+          /* Load ends the previous rule.  */
+          record_waiting_files ();
+
+          p = allocated_variable_expand (p2);
+
+          /* If no filenames, it's a no-op.  */
+          if (*p == '\0')
+            {
+              free (p);
+              continue;
+            }
+
+          /* Parse the list of file names.
+             Don't expand archive references or strip "./"  */
+          p2 = p;
+          files = PARSE_FILE_SEQ (&p2, struct nameseq, MAP_NUL, NULL,
+                                  PARSEFS_NOAR);
+          free (p);
+
+          /* Load each file.  */
+          while (files != 0)
+            {
+              struct nameseq *next = files->next;
+              const char *name = files->name;
+              struct goaldep *deps;
+              int r;
+
+              /* Load the file.  0 means failure.  */
+              r = load_file (&ebuf->floc, &name, noerror);
+              if (! r && ! noerror)
+                OS (fatal, &ebuf->floc, _("%s: failed to load"), name);
+
+              free_ns (files);
+              files = next;
+
+              /* Return of -1 means a special load: don't rebuild it.  */
+              if (r == -1)
+                continue;
+
+              /* It succeeded, so add it to the list "to be rebuilt".  */
+              deps = alloc_goaldep ();
+              deps->next = read_files;
+              read_files = deps;
+              deps->file = lookup_file (name);
+              if (deps->file == 0)
+                deps->file = enter_file (name);
+              deps->file->loaded = 1;
+            }
+
+          continue;
+        }
+
+      /* This line starts with a tab but was not caught above because there
+         was no preceding target, and the line might have been usable as a
+         variable definition.  But now we know it is definitely lossage.  */
+      if (line[0] == cmd_prefix)
+        O (fatal, fstart, _("recipe commences before first target"));
+
+      /* This line describes some target files.  This is complicated by
+         the existence of target-specific variables, because we can't
+         expand the entire line until we know if we have one or not.  So
+         we expand the line word by word until we find the first ':',
+         then check to see if it's a target-specific variable.
+
+         In this algorithm, 'lb_next' will point to the beginning of the
+         unexpanded parts of the input buffer, while 'p2' points to the
+         parts of the expanded buffer we haven't searched yet. */
+
+      {
+        enum make_word_type wtype;
+        char *cmdleft, *semip, *lb_next;
+        unsigned int plen = 0;
+        char *colonp;
+        const char *end, *beg; /* Helpers for whitespace stripping. */
+
+        /* Record the previous rule.  */
+
+        record_waiting_files ();
+        tgts_started = fstart->lineno;
+
+        /* Search the line for an unquoted ; that is not after an
+           unquoted #.  */
+        cmdleft = find_map_unquote (line, MAP_SEMI|MAP_COMMENT|MAP_VARIABLE);
+        if (cmdleft != 0 && *cmdleft == '#')
+          {
+            /* We found a comment before a semicolon.  */
+            *cmdleft = '\0';
+            cmdleft = 0;
+          }
+        else if (cmdleft != 0)
+          /* Found one.  Cut the line short there before expanding it.  */
+          *(cmdleft++) = '\0';
+        semip = cmdleft;
+
+        collapse_continuations (line);
+
+        /* We can't expand the entire line, since if it's a per-target
+           variable we don't want to expand it.  So, walk from the
+           beginning, expanding as we go, and looking for "interesting"
+           chars.  The first word is always expandable.  */
+        wtype = get_next_mword (line, NULL, &lb_next, &wlen);
+        switch (wtype)
+          {
+          case w_eol:
+            if (cmdleft != 0)
+              O (fatal, fstart, _("missing rule before recipe"));
+            /* This line contained something but turned out to be nothing
+               but whitespace (a comment?).  */
+            continue;
+
+          case w_colon:
+          case w_dcolon:
+            /* We accept and ignore rules without targets for
+               compatibility with SunOS 4 make.  */
+            no_targets = 1;
+            continue;
+
+          default:
+            break;
+          }
+
+        p2 = variable_expand_string (NULL, lb_next, wlen);
+
+        while (1)
+          {
+            lb_next += wlen;
+            if (cmdleft == 0)
+              {
+                /* Look for a semicolon in the expanded line.  */
+                cmdleft = find_char_unquote (p2, ';');
+
+                if (cmdleft != 0)
+                  {
+                    unsigned long p2_off = p2 - variable_buffer;
+                    unsigned long cmd_off = cmdleft - variable_buffer;
+                    char *pend = p2 + strlen (p2);
+
+                    /* Append any remnants of lb, then cut the line short
+                       at the semicolon.  */
+                    *cmdleft = '\0';
+
+                    /* One school of thought says that you shouldn't expand
+                       here, but merely copy, since now you're beyond a ";"
+                       and into a command script.  However, the old parser
+                       expanded the whole line, so we continue that for
+                       backwards-compatibility.  Also, it wouldn't be
+                       entirely consistent, since we do an unconditional
+                       expand below once we know we don't have a
+                       target-specific variable. */
+                    (void)variable_expand_string (pend, lb_next, (long)-1);
+                    lb_next += strlen (lb_next);
+                    p2 = variable_buffer + p2_off;
+                    cmdleft = variable_buffer + cmd_off + 1;
+                  }
+              }
+
+            colonp = find_char_unquote (p2, ':');
+#ifdef HAVE_DOS_PATHS
+            /* The drive spec brain-damage strikes again...  */
+            /* Note that the only separators of targets in this context
+               are whitespace and a left paren.  If others are possible,
+               they should be added to the string in the call to index.  */
+            while (colonp && (colonp[1] == '/' || colonp[1] == '\\') &&
+                   colonp > p2 && isalpha ((unsigned char)colonp[-1]) &&
+                   (colonp == p2 + 1 || strchr (" \t(", colonp[-2]) != 0))
+              colonp = find_char_unquote (colonp + 1, ':');
+#endif
+            if (colonp != 0)
+              break;
+
+            wtype = get_next_mword (lb_next, NULL, &lb_next, &wlen);
+            if (wtype == w_eol)
+              break;
+
+            p2 += strlen (p2);
+            *(p2++) = ' ';
+            p2 = variable_expand_string (p2, lb_next, wlen);
+            /* We don't need to worry about cmdleft here, because if it was
+               found in the variable_buffer the entire buffer has already
+               been expanded... we'll never get here.  */
+          }
+
+        p2 = next_token (variable_buffer);
+
+        /* If the word we're looking at is EOL, see if there's _anything_
+           on the line.  If not, a variable expanded to nothing, so ignore
+           it.  If so, we can't parse this line so punt.  */
+        if (wtype == w_eol)
+          {
+            if (*p2 == '\0')
+              continue;
+
+            /* There's no need to be ivory-tower about this: check for
+               one of the most common bugs found in makefiles...  */
+            if (cmd_prefix == '\t' && strneq (line, "        ", 8))
+              O (fatal, fstart, _("missing separator (did you mean TAB instead of 8 spaces?)"));
+            else
+              O (fatal, fstart, _("missing separator"));
+          }
+
+        /* Make the colon the end-of-string so we know where to stop
+           looking for targets.  Start there again once we're done.  */
+        *colonp = '\0';
+        filenames = PARSE_SIMPLE_SEQ (&p2, struct nameseq);
+        *colonp = ':';
+        p2 = colonp;
+
+        if (!filenames)
+          {
+            /* We accept and ignore rules without targets for
+               compatibility with SunOS 4 make.  */
+            no_targets = 1;
+            continue;
+          }
+        /* This should never be possible; we handled it above.  */
+        assert (*p2 != '\0');
+        ++p2;
+
+        /* Is this a one-colon or two-colon entry?  */
+        two_colon = *p2 == ':';
+        if (two_colon)
+          p2++;
+
+        /* Test to see if it's a target-specific variable.  Copy the rest
+           of the buffer over, possibly temporarily (we'll expand it later
+           if it's not a target-specific variable).  PLEN saves the length
+           of the unparsed section of p2, for later.  */
+        if (*lb_next != '\0')
+          {
+            unsigned int l = p2 - variable_buffer;
+            plen = strlen (p2);
+            variable_buffer_output (p2+plen, lb_next, strlen (lb_next)+1);
+            p2 = variable_buffer + l;
+          }
+
+        p2 = parse_var_assignment (p2, &vmod);
+        if (vmod.assign_v)
+          {
+            /* If there was a semicolon found, add it back, plus anything
+               after it.  */
+            if (semip)
+              {
+                unsigned int l = p2 - variable_buffer;
+                *(--semip) = ';';
+                collapse_continuations (semip);
+                variable_buffer_output (p2 + strlen (p2),
+                                        semip, strlen (semip)+1);
+                p2 = variable_buffer + l;
+              }
+            record_target_var (filenames, p2,
+                               vmod.override_v ? o_override : o_file,
+                               &vmod, fstart);
+            filenames = 0;
+            continue;
+          }
+
+        /* This is a normal target, _not_ a target-specific variable.
+           Unquote any = in the dependency list.  */
+        find_char_unquote (lb_next, '=');
+
+        /* Remember the command prefix for this target.  */
+        prefix = cmd_prefix;
+
+        /* We have some targets, so don't ignore the following commands.  */
+        no_targets = 0;
+
+        /* Expand the dependencies, etc.  */
+        if (*lb_next != '\0')
+          {
+            unsigned int l = p2 - variable_buffer;
+            (void) variable_expand_string (p2 + plen, lb_next, (long)-1);
+            p2 = variable_buffer + l;
+
+            /* Look for a semicolon in the expanded line.  */
+            if (cmdleft == 0)
+              {
+                cmdleft = find_char_unquote (p2, ';');
+                if (cmdleft != 0)
+                  *(cmdleft++) = '\0';
+              }
+          }
+
+        /* Is this a static pattern rule: 'target: %targ: %dep; ...'?  */
+        p = strchr (p2, ':');
+        while (p != 0 && p[-1] == '\\')
+          {
+            char *q = &p[-1];
+            int backslash = 0;
+            while (*q-- == '\\')
+              backslash = !backslash;
+            if (backslash)
+              p = strchr (p + 1, ':');
+            else
+              break;
+          }
+#ifdef _AMIGA
+        /* Here, the situation is quite complicated. Let's have a look
+           at a couple of targets:
+
+           install: dev:make
+
+           dev:make: make
+
+           dev:make:: xyz
+
+           The rule is that it's only a target, if there are TWO :'s
+           OR a space around the :.
+        */
+        if (p && !(ISSPACE (p[1]) || !p[1] || ISSPACE (p[-1])))
+          p = 0;
+#endif
+#ifdef HAVE_DOS_PATHS
+        {
+          int check_again;
+          do {
+            check_again = 0;
+            /* For DOS-style paths, skip a "C:\..." or a "C:/..." */
+            if (p != 0 && (p[1] == '\\' || p[1] == '/') &&
+                isalpha ((unsigned char)p[-1]) &&
+                (p == p2 + 1 || strchr (" \t:(", p[-2]) != 0)) {
+              p = strchr (p + 1, ':');
+              check_again = 1;
+            }
+          } while (check_again);
+        }
+#endif
+        if (p != 0)
+          {
+            struct nameseq *target;
+            target = PARSE_FILE_SEQ (&p2, struct nameseq, MAP_COLON, NULL,
+                                     PARSEFS_NOGLOB);
+            ++p2;
+            if (target == 0)
+              O (fatal, fstart, _("missing target pattern"));
+            else if (target->next != 0)
+              O (fatal, fstart, _("multiple target patterns"));
+            pattern_percent = find_percent_cached (&target->name);
+            pattern = target->name;
+            if (pattern_percent == 0)
+              O (fatal, fstart, _("target pattern contains no '%%'"));
+            free_ns (target);
+          }
+        else
+          pattern = 0;
+
+        /* Strip leading and trailing whitespaces. */
+        beg = p2;
+        end = beg + strlen (beg) - 1;
+        strip_whitespace (&beg, &end);
+
+        /* Put all the prerequisites here; they'll be parsed later.  */
+        if (beg <= end && *beg != '\0')
+          depstr = xstrndup (beg, end - beg + 1);
+        else
+          depstr = 0;
+
+        commands_idx = 0;
+        if (cmdleft != 0)
+          {
+            /* Semicolon means rest of line is a command.  */
+            unsigned int l = strlen (cmdleft);
+
+            cmds_started = fstart->lineno;
+
+            /* Add this command line to the buffer.  */
+            if (l + 2 > commands_len)
+              {
+                commands_len = (l + 2) * 2;
+                commands = xrealloc (commands, commands_len);
+              }
+            memcpy (commands, cmdleft, l);
+            commands_idx += l;
+            commands[commands_idx++] = '\n';
+          }
+
+        /* Determine if this target should be made default. We used to do
+           this in record_files() but because of the delayed target recording
+           and because preprocessor directives are legal in target's commands
+           it is too late. Consider this fragment for example:
+
+           foo:
+
+           ifeq ($(.DEFAULT_GOAL),foo)
+              ...
+           endif
+
+           Because the target is not recorded until after ifeq directive is
+           evaluated the .DEFAULT_GOAL does not contain foo yet as one
+           would expect. Because of this we have to move the logic here.  */
+
+        if (set_default && default_goal_var->value[0] == '\0')
+          {
+            struct dep *d;
+            struct nameseq *t = filenames;
+
+            for (; t != 0; t = t->next)
+              {
+                int reject = 0;
+                const char *name = t->name;
+
+                /* We have nothing to do if this is an implicit rule. */
+                if (strchr (name, '%') != 0)
+                  break;
+
+                /* See if this target's name does not start with a '.',
+                   unless it contains a slash.  */
+                if (*name == '.' && strchr (name, '/') == 0
+#ifdef HAVE_DOS_PATHS
+                    && strchr (name, '\\') == 0
+#endif
+                    )
+                  continue;
+
+
+                /* If this file is a suffix, don't let it be
+                   the default goal file.  */
+                for (d = suffix_file->deps; d != 0; d = d->next)
+                  {
+                    struct dep *d2;
+                    if (*dep_name (d) != '.' && streq (name, dep_name (d)))
+                      {
+                        reject = 1;
+                        break;
+                      }
+                    for (d2 = suffix_file->deps; d2 != 0; d2 = d2->next)
+                      {
+                        unsigned int l = strlen (dep_name (d2));
+                        if (!strneq (name, dep_name (d2), l))
+                          continue;
+                        if (streq (name + l, dep_name (d)))
+                          {
+                            reject = 1;
+                            break;
+                          }
+                      }
+
+                    if (reject)
+                      break;
+                  }
+
+                if (!reject)
+                  {
+                    define_variable_global (".DEFAULT_GOAL", 13, t->name,
+                                            o_file, 0, NILF);
+                    break;
+                  }
+              }
+          }
+
+        continue;
+      }
+
+      /* We get here except in the case that we just read a rule line.
+         Record now the last rule we read, so following spurious
+         commands are properly diagnosed.  */
+      record_waiting_files ();
+    }
+
+#undef word1eq
+
+  if (conditionals->if_cmds)
+    O (fatal, fstart, _("missing 'endif'"));
+
+  /* At eof, record the last rule.  */
+  record_waiting_files ();
+
+  free (collapsed);
+  free (commands);
+}
+
+
+/* Remove comments from LINE.
+   This will also remove backslashes that escape things.
+   It ignores comment characters that appear inside variable references.  */
+
+static void
+remove_comments (char *line)
+{
+  char *comment;
+
+  comment = find_map_unquote (line, MAP_COMMENT|MAP_VARIABLE);
+
+  if (comment != 0)
+    /* Cut off the line at the #.  */
+    *comment = '\0';
+}
+
+/* Execute a 'undefine' directive.
+   The undefine line has already been read, and NAME is the name of
+   the variable to be undefined. */
+
+static void
+do_undefine (char *name, enum variable_origin origin, struct ebuffer *ebuf)
+{
+  char *p, *var;
+
+  /* Expand the variable name and find the beginning (NAME) and end.  */
+  var = allocated_variable_expand (name);
+  name = next_token (var);
+  if (*name == '\0')
+    O (fatal, &ebuf->floc, _("empty variable name"));
+  p = name + strlen (name) - 1;
+  while (p > name && ISBLANK (*p))
+    --p;
+  p[1] = '\0';
+
+  undefine_variable_global (name, p - name + 1, origin);
+  free (var);
+}
+
+/* Execute a 'define' directive.
+   The first line has already been read, and NAME is the name of
+   the variable to be defined.  The following lines remain to be read.  */
+
+static struct variable *
+do_define (char *name, enum variable_origin origin, struct ebuffer *ebuf)
+{
+  struct variable *v;
+  struct variable var;
+  floc defstart;
+  int nlevels = 1;
+  unsigned int length = 100;
+  char *definition = xmalloc (length);
+  unsigned int idx = 0;
+  char *p, *n;
+
+  defstart = ebuf->floc;
+
+  p = parse_variable_definition (name, &var);
+  if (p == NULL)
+    /* No assignment token, so assume recursive.  */
+    var.flavor = f_recursive;
+  else
+    {
+      if (var.value[0] != '\0')
+        O (error, &defstart, _("extraneous text after 'define' directive"));
+
+      /* Chop the string before the assignment token to get the name.  */
+      var.name[var.length] = '\0';
+    }
+
+  /* Expand the variable name and find the beginning (NAME) and end.  */
+  n = allocated_variable_expand (name);
+  name = next_token (n);
+  if (name[0] == '\0')
+    O (fatal, &defstart, _("empty variable name"));
+  p = name + strlen (name) - 1;
+  while (p > name && ISBLANK (*p))
+    --p;
+  p[1] = '\0';
+
+  /* Now read the value of the variable.  */
+  while (1)
+    {
+      unsigned int len;
+      char *line;
+      long nlines = readline (ebuf);
+
+      /* If there is nothing left to be eval'd, there's no 'endef'!!  */
+      if (nlines < 0)
+        O (fatal, &defstart, _("missing 'endef', unterminated 'define'"));
+
+      ebuf->floc.lineno += nlines;
+      line = ebuf->buffer;
+
+      collapse_continuations (line);
+
+      /* If the line doesn't begin with a tab, test to see if it introduces
+         another define, or ends one.  Stop if we find an 'endef' */
+      if (line[0] != cmd_prefix)
+        {
+          p = next_token (line);
+          len = strlen (p);
+
+          /* If this is another 'define', increment the level count.  */
+          if ((len == 6 || (len > 6 && ISBLANK (p[6])))
+              && strneq (p, "define", 6))
+            ++nlevels;
+
+          /* If this is an 'endef', decrement the count.  If it's now 0,
+             we've found the last one.  */
+          else if ((len == 5 || (len > 5 && ISBLANK (p[5])))
+                   && strneq (p, "endef", 5))
+            {
+              p += 5;
+              remove_comments (p);
+              if (*(next_token (p)) != '\0')
+                O (error, &ebuf->floc,
+                   _("extraneous text after 'endef' directive"));
+
+              if (--nlevels == 0)
+                break;
+            }
+        }
+
+      /* Add this line to the variable definition.  */
+      len = strlen (line);
+      if (idx + len + 1 > length)
+        {
+          length = (idx + len) * 2;
+          definition = xrealloc (definition, length + 1);
+        }
+
+      memcpy (&definition[idx], line, len);
+      idx += len;
+      /* Separate lines with a newline.  */
+      definition[idx++] = '\n';
+    }
+
+  /* We've got what we need; define the variable.  */
+  if (idx == 0)
+    definition[0] = '\0';
+  else
+    definition[idx - 1] = '\0';
+
+  v = do_variable_definition (&defstart, name,
+                              definition, origin, var.flavor, 0);
+  free (definition);
+  free (n);
+  return (v);
+}
+
+/* Interpret conditional commands "ifdef", "ifndef", "ifeq",
+   "ifneq", "else" and "endif".
+   LINE is the input line, with the command as its first word.
+
+   FILENAME and LINENO are the filename and line number in the
+   current makefile.  They are used for error messages.
+
+   Value is -2 if the line is not a conditional at all,
+   -1 if the line is an invalid conditional,
+   0 if following text should be interpreted,
+   1 if following text should be ignored.  */
+
+static int
+conditional_line (char *line, int len, const floc *flocp)
+{
+  const char *cmdname;
+  enum { c_ifdef, c_ifndef, c_ifeq, c_ifneq, c_else, c_endif } cmdtype;
+  unsigned int i;
+  unsigned int o;
+
+  /* Compare a word, both length and contents. */
+#define word1eq(s)      (len == CSTRLEN (s) && strneq (s, line, CSTRLEN (s)))
+#define chkword(s, t)   if (word1eq (s)) { cmdtype = (t); cmdname = (s); }
+
+  /* Make sure this line is a conditional.  */
+  chkword ("ifdef", c_ifdef)
+  else chkword ("ifndef", c_ifndef)
+  else chkword ("ifeq", c_ifeq)
+  else chkword ("ifneq", c_ifneq)
+  else chkword ("else", c_else)
+  else chkword ("endif", c_endif)
+  else
+    return -2;
+
+  /* Found one: skip past it and any whitespace after it.  */
+  line += len;
+  NEXT_TOKEN (line);
+
+#define EXTRATEXT() OS (error, flocp, _("extraneous text after '%s' directive"), cmdname)
+#define EXTRACMD()  OS (fatal, flocp, _("extraneous '%s'"), cmdname)
+
+  /* An 'endif' cannot contain extra text, and reduces the if-depth by 1  */
+  if (cmdtype == c_endif)
+    {
+      if (*line != '\0')
+        EXTRATEXT ();
+
+      if (!conditionals->if_cmds)
+        EXTRACMD ();
+
+      --conditionals->if_cmds;
+
+      goto DONE;
+    }
+
+  /* An 'else' statement can either be simple, or it can have another
+     conditional after it.  */
+  if (cmdtype == c_else)
+    {
+      const char *p;
+
+      if (!conditionals->if_cmds)
+        EXTRACMD ();
+
+      o = conditionals->if_cmds - 1;
+
+      if (conditionals->seen_else[o])
+        O (fatal, flocp, _("only one 'else' per conditional"));
+
+      /* Change the state of ignorance.  */
+      switch (conditionals->ignoring[o])
+        {
+          case 0:
+            /* We've just been interpreting.  Never do it again.  */
+            conditionals->ignoring[o] = 2;
+            break;
+          case 1:
+            /* We've never interpreted yet.  Maybe this time!  */
+            conditionals->ignoring[o] = 0;
+            break;
+        }
+
+      /* It's a simple 'else'.  */
+      if (*line == '\0')
+        {
+          conditionals->seen_else[o] = 1;
+          goto DONE;
+        }
+
+      /* The 'else' has extra text.  That text must be another conditional
+         and cannot be an 'else' or 'endif'.  */
+
+      /* Find the length of the next word.  */
+      for (p = line+1; ! STOP_SET (*p, MAP_SPACE|MAP_NUL); ++p)
+        ;
+      len = p - line;
+
+      /* If it's 'else' or 'endif' or an illegal conditional, fail.  */
+      if (word1eq ("else") || word1eq ("endif")
+          || conditional_line (line, len, flocp) < 0)
+        EXTRATEXT ();
+      else
+        {
+          /* conditional_line() created a new level of conditional.
+             Raise it back to this level.  */
+          if (conditionals->ignoring[o] < 2)
+            conditionals->ignoring[o] = conditionals->ignoring[o+1];
+          --conditionals->if_cmds;
+        }
+
+      goto DONE;
+    }
+
+  if (conditionals->allocated == 0)
+    {
+      conditionals->allocated = 5;
+      conditionals->ignoring = xmalloc (conditionals->allocated);
+      conditionals->seen_else = xmalloc (conditionals->allocated);
+    }
+
+  o = conditionals->if_cmds++;
+  if (conditionals->if_cmds > conditionals->allocated)
+    {
+      conditionals->allocated += 5;
+      conditionals->ignoring = xrealloc (conditionals->ignoring,
+                                         conditionals->allocated);
+      conditionals->seen_else = xrealloc (conditionals->seen_else,
+                                          conditionals->allocated);
+    }
+
+  /* Record that we have seen an 'if...' but no 'else' so far.  */
+  conditionals->seen_else[o] = 0;
+
+  /* Search through the stack to see if we're already ignoring.  */
+  for (i = 0; i < o; ++i)
+    if (conditionals->ignoring[i])
+      {
+        /* We are already ignoring, so just push a level to match the next
+           "else" or "endif", and keep ignoring.  We don't want to expand
+           variables in the condition.  */
+        conditionals->ignoring[o] = 1;
+        return 1;
+      }
+
+  if (cmdtype == c_ifdef || cmdtype == c_ifndef)
+    {
+      char *var;
+      struct variable *v;
+      char *p;
+
+      /* Expand the thing we're looking up, so we can use indirect and
+         constructed variable names.  */
+      var = allocated_variable_expand (line);
+
+      /* Make sure there's only one variable name to test.  */
+      p = end_of_token (var);
+      i = p - var;
+      NEXT_TOKEN (p);
+      if (*p != '\0')
+        return -1;
+
+      var[i] = '\0';
+      v = lookup_variable (var, i);
+
+      conditionals->ignoring[o] =
+        ((v != 0 && *v->value != '\0') == (cmdtype == c_ifndef));
+
+      free (var);
+    }
+  else
+    {
+      /* "ifeq" or "ifneq".  */
+      char *s1, *s2;
+      unsigned int l;
+      char termin = *line == '(' ? ',' : *line;
+
+      if (termin != ',' && termin != '"' && termin != '\'')
+        return -1;
+
+      s1 = ++line;
+      /* Find the end of the first string.  */
+      if (termin == ',')
+        {
+          int count = 0;
+          for (; *line != '\0'; ++line)
+            if (*line == '(')
+              ++count;
+            else if (*line == ')')
+              --count;
+            else if (*line == ',' && count <= 0)
+              break;
+        }
+      else
+        while (*line != '\0' && *line != termin)
+          ++line;
+
+      if (*line == '\0')
+        return -1;
+
+      if (termin == ',')
+        {
+          /* Strip blanks after the first string.  */
+          char *p = line++;
+          while (ISBLANK (p[-1]))
+            --p;
+          *p = '\0';
+        }
+      else
+        *line++ = '\0';
+
+      s2 = variable_expand (s1);
+      /* We must allocate a new copy of the expanded string because
+         variable_expand re-uses the same buffer.  */
+      l = strlen (s2);
+      s1 = alloca (l + 1);
+      memcpy (s1, s2, l + 1);
+
+      if (termin != ',')
+        /* Find the start of the second string.  */
+        NEXT_TOKEN (line);
+
+      termin = termin == ',' ? ')' : *line;
+      if (termin != ')' && termin != '"' && termin != '\'')
+        return -1;
+
+      /* Find the end of the second string.  */
+      if (termin == ')')
+        {
+          int count = 0;
+          s2 = next_token (line);
+          for (line = s2; *line != '\0'; ++line)
+            {
+              if (*line == '(')
+                ++count;
+              else if (*line == ')')
+                {
+                  if (count <= 0)
+                    break;
+                  else
+                    --count;
+                }
+            }
+        }
+      else
+        {
+          ++line;
+          s2 = line;
+          while (*line != '\0' && *line != termin)
+            ++line;
+        }
+
+      if (*line == '\0')
+        return -1;
+
+      *(line++) = '\0';
+      NEXT_TOKEN (line);
+      if (*line != '\0')
+        EXTRATEXT ();
+
+      s2 = variable_expand (s2);
+      conditionals->ignoring[o] = (streq (s1, s2) == (cmdtype == c_ifneq));
+    }
+
+ DONE:
+  /* Search through the stack to see if we're ignoring.  */
+  for (i = 0; i < conditionals->if_cmds; ++i)
+    if (conditionals->ignoring[i])
+      return 1;
+  return 0;
+}
+
+
+/* Record target-specific variable values for files FILENAMES.
+   TWO_COLON is nonzero if a double colon was used.
+
+   The links of FILENAMES are freed, and so are any names in it
+   that are not incorporated into other data structures.
+
+   If the target is a pattern, add the variable to the pattern-specific
+   variable value list.  */
+
+static void
+record_target_var (struct nameseq *filenames, char *defn,
+                   enum variable_origin origin, struct vmodifiers *vmod,
+                   const floc *flocp)
+{
+  struct nameseq *nextf;
+  struct variable_set_list *global;
+
+  global = current_variable_set_list;
+
+  /* If the variable is an append version, store that but treat it as a
+     normal recursive variable.  */
+
+  for (; filenames != 0; filenames = nextf)
+    {
+      struct variable *v;
+      const char *name = filenames->name;
+      const char *percent;
+      struct pattern_var *p;
+
+      nextf = filenames->next;
+      free_ns (filenames);
+
+      /* If it's a pattern target, then add it to the pattern-specific
+         variable list.  */
+      percent = find_percent_cached (&name);
+      if (percent)
+        {
+          /* Get a reference for this pattern-specific variable struct.  */
+          p = create_pattern_var (name, percent);
+          p->variable.fileinfo = *flocp;
+          /* I don't think this can fail since we already determined it was a
+             variable definition.  */
+          v = assign_variable_definition (&p->variable, defn);
+          assert (v != 0);
+
+          v->origin = origin;
+          if (v->flavor == f_simple)
+            v->value = allocated_variable_expand (v->value);
+          else
+            v->value = xstrdup (v->value);
+        }
+      else
+        {
+          struct file *f;
+
+          /* Get a file reference for this file, and initialize it.
+             We don't want to just call enter_file() because that allocates a
+             new entry if the file is a double-colon, which we don't want in
+             this situation.  */
+          f = lookup_file (name);
+          if (!f)
+            f = enter_file (strcache_add (name));
+          else if (f->double_colon)
+            f = f->double_colon;
+
+          initialize_file_variables (f, 1);
+
+          current_variable_set_list = f->variables;
+          v = try_variable_definition (flocp, defn, origin, 1);
+          if (!v)
+            O (fatal, flocp, _("Malformed target-specific variable definition"));
+          current_variable_set_list = global;
+        }
+
+      /* Set up the variable to be *-specific.  */
+      v->per_target = 1;
+      v->private_var = vmod->private_v;
+      v->export = vmod->export_v ? v_export : v_default;
+
+      /* If it's not an override, check to see if there was a command-line
+         setting.  If so, reset the value.  */
+      if (v->origin != o_override)
+        {
+          struct variable *gv;
+          int len = strlen (v->name);
+
+          gv = lookup_variable (v->name, len);
+          if (gv && v != gv
+              && (gv->origin == o_env_override || gv->origin == o_command))
+            {
+              free (v->value);
+              v->value = xstrdup (gv->value);
+              v->origin = gv->origin;
+              v->recursive = gv->recursive;
+              v->append = 0;
+            }
+        }
+    }
+}
+
+/* Record a description line for files FILENAMES,
+   with dependencies DEPS, commands to execute described
+   by COMMANDS and COMMANDS_IDX, coming from FILENAME:COMMANDS_STARTED.
+   TWO_COLON is nonzero if a double colon was used.
+   If not nil, PATTERN is the '%' pattern to make this
+   a static pattern rule, and PATTERN_PERCENT is a pointer
+   to the '%' within it.
+
+   The links of FILENAMES are freed, and so are any names in it
+   that are not incorporated into other data structures.  */
+
+static void
+record_files (struct nameseq *filenames, const char *pattern,
+              const char *pattern_percent, char *depstr,
+              unsigned int cmds_started, char *commands,
+              unsigned int commands_idx, int two_colon,
+              char prefix, const floc *flocp)
+{
+  struct commands *cmds;
+  struct dep *deps;
+  const char *implicit_percent;
+  const char *name;
+
+  /* If we've already snapped deps, that means we're in an eval being
+     resolved after the makefiles have been read in.  We can't add more rules
+     at this time, since they won't get snapped and we'll get core dumps.
+     See Savannah bug # 12124.  */
+  if (snapped_deps)
+    O (fatal, flocp, _("prerequisites cannot be defined in recipes"));
+
+  /* Determine if this is a pattern rule or not.  */
+  name = filenames->name;
+  implicit_percent = find_percent_cached (&name);
+
+  /* If there's a recipe, set up a struct for it.  */
+  if (commands_idx > 0)
+    {
+      cmds = xmalloc (sizeof (struct commands));
+      cmds->fileinfo.filenm = flocp->filenm;
+      cmds->fileinfo.lineno = cmds_started;
+      cmds->fileinfo.offset = 0;
+      cmds->commands = xstrndup (commands, commands_idx);
+      cmds->command_lines = 0;
+      cmds->recipe_prefix = prefix;
+    }
+  else
+     cmds = 0;
+
+  /* If there's a prereq string then parse it--unless it's eligible for 2nd
+     expansion: if so, snap_deps() will do it.  */
+  if (depstr == 0)
+    deps = 0;
+  else
+    {
+      depstr = unescape_char (depstr, ':');
+      if (second_expansion && strchr (depstr, '$'))
+        {
+          deps = alloc_dep ();
+          deps->name = depstr;
+          deps->need_2nd_expansion = 1;
+          deps->staticpattern = pattern != 0;
+        }
+      else
+        {
+          deps = split_prereqs (depstr);
+          free (depstr);
+
+          /* We'll enter static pattern prereqs later when we have the stem.
+             We don't want to enter pattern rules at all so that we don't
+             think that they ought to exist (make manual "Implicit Rule Search
+             Algorithm", item 5c).  */
+          if (! pattern && ! implicit_percent)
+            deps = enter_prereqs (deps, NULL);
+        }
+    }
+
+  /* For implicit rules, _all_ the targets must have a pattern.  That means we
+     can test the first one to see if we're working with an implicit rule; if
+     so we handle it specially. */
+
+  if (implicit_percent)
+    {
+      struct nameseq *nextf;
+      const char **targets, **target_pats;
+      unsigned int c;
+
+      if (pattern != 0)
+        O (fatal, flocp, _("mixed implicit and static pattern rules"));
+
+      /* Count the targets to create an array of target names.
+         We already have the first one.  */
+      nextf = filenames->next;
+      free_ns (filenames);
+      filenames = nextf;
+
+      for (c = 1; nextf; ++c, nextf = nextf->next)
+        ;
+      targets = xmalloc (c * sizeof (const char *));
+      target_pats = xmalloc (c * sizeof (const char *));
+
+      targets[0] = name;
+      target_pats[0] = implicit_percent;
+
+      c = 1;
+      while (filenames)
+        {
+          name = filenames->name;
+          implicit_percent = find_percent_cached (&name);
+
+          if (implicit_percent == 0)
+            O (fatal, flocp, _("mixed implicit and normal rules"));
+
+          targets[c] = name;
+          target_pats[c] = implicit_percent;
+          ++c;
+
+          nextf = filenames->next;
+          free_ns (filenames);
+          filenames = nextf;
+        }
+
+      create_pattern_rule (targets, target_pats, c, two_colon, deps, cmds, 1);
+
+      return;
+    }
+
+
+  /* Walk through each target and create it in the database.
+     We already set up the first target, above.  */
+  while (1)
+    {
+      struct nameseq *nextf = filenames->next;
+      struct file *f;
+      struct dep *this = 0;
+
+      free_ns (filenames);
+
+      /* Check for special targets.  Do it here instead of, say, snap_deps()
+         so that we can immediately use the value.  */
+      if (!posix_pedantic && streq (name, ".POSIX"))
+        {
+          posix_pedantic = 1;
+          define_variable_cname (".SHELLFLAGS", "-ec", o_default, 0);
+          /* These default values are based on IEEE Std 1003.1-2008.
+             It requires '-O 1' for [CF]FLAGS, but GCC doesn't allow space
+             between -O and the number so omit it here.  */
+          define_variable_cname ("ARFLAGS", "-rv", o_default, 0);
+          define_variable_cname ("CC", "c99", o_default, 0);
+          define_variable_cname ("CFLAGS", "-O1", o_default, 0);
+          define_variable_cname ("FC", "fort77", o_default, 0);
+          define_variable_cname ("FFLAGS", "-O1", o_default, 0);
+          define_variable_cname ("SCCSGETFLAGS", "-s", o_default, 0);
+        }
+      else if (!second_expansion && streq (name, ".SECONDEXPANSION"))
+        second_expansion = 1;
+#if !defined (__MSDOS__) && !defined (__EMX__)
+      else if (!one_shell && streq (name, ".ONESHELL"))
+        one_shell = 1;
+#endif
+
+      /* If this is a static pattern rule:
+         'targets: target%pattern: prereq%pattern; recipe',
+         make sure the pattern matches this target name.  */
+      if (pattern && !pattern_matches (pattern, pattern_percent, name))
+        OS (error, flocp,
+            _("target '%s' doesn't match the target pattern"), name);
+      else if (deps)
+        /* If there are multiple targets, copy the chain DEPS for all but the
+           last one.  It is not safe for the same deps to go in more than one
+           place in the database.  */
+        this = nextf != 0 ? copy_dep_chain (deps) : deps;
+
+      /* Find or create an entry in the file database for this target.  */
+      if (!two_colon)
+        {
+          /* Single-colon.  Combine this rule with the file's existing record,
+             if any.  */
+          f = enter_file (strcache_add (name));
+          if (f->double_colon)
+            OS (fatal, flocp,
+                _("target file '%s' has both : and :: entries"), f->name);
+
+          /* If CMDS == F->CMDS, this target was listed in this rule
+             more than once.  Just give a warning since this is harmless.  */
+          if (cmds != 0 && cmds == f->cmds)
+            OS (error, flocp,
+                _("target '%s' given more than once in the same rule"),
+                f->name);
+
+          /* Check for two single-colon entries both with commands.
+             Check is_target so that we don't lose on files such as .c.o
+             whose commands were preinitialized.  */
+          else if (cmds != 0 && f->cmds != 0 && f->is_target)
+            {
+              size_t l = strlen (f->name);
+              error (&cmds->fileinfo, l,
+                     _("warning: overriding recipe for target '%s'"),
+                     f->name);
+              error (&f->cmds->fileinfo, l,
+                     _("warning: ignoring old recipe for target '%s'"),
+                     f->name);
+            }
+
+          /* Defining .DEFAULT with no deps or cmds clears it.  */
+          if (f == default_file && this == 0 && cmds == 0)
+            f->cmds = 0;
+          if (cmds != 0)
+            f->cmds = cmds;
+
+          /* Defining .SUFFIXES with no dependencies clears out the list of
+             suffixes.  */
+          if (f == suffix_file && this == 0)
+            {
+              free_dep_chain (f->deps);
+              f->deps = 0;
+            }
+        }
+      else
+        {
+          /* Double-colon.  Make a new record even if there already is one.  */
+          f = lookup_file (name);
+
+          /* Check for both : and :: rules.  Check is_target so we don't lose
+             on default suffix rules or makefiles.  */
+          if (f != 0 && f->is_target && !f->double_colon)
+            OS (fatal, flocp,
+                _("target file '%s' has both : and :: entries"), f->name);
+
+          f = enter_file (strcache_add (name));
+          /* If there was an existing entry and it was a double-colon entry,
+             enter_file will have returned a new one, making it the prev
+             pointer of the old one, and setting its double_colon pointer to
+             the first one.  */
+          if (f->double_colon == 0)
+            /* This is the first entry for this name, so we must set its
+               double_colon pointer to itself.  */
+            f->double_colon = f;
+
+          f->cmds = cmds;
+        }
+
+      f->is_target = 1;
+
+      /* If this is a static pattern rule, set the stem to the part of its
+         name that matched the '%' in the pattern, so you can use $* in the
+         commands.  If we didn't do it before, enter the prereqs now.  */
+      if (pattern)
+        {
+          static const char *percent = "%";
+          char *buffer = variable_expand ("");
+          char *o = patsubst_expand_pat (buffer, name, pattern, percent,
+                                         pattern_percent+1, percent+1);
+          f->stem = strcache_add_len (buffer, o - buffer);
+          if (this)
+            {
+              if (! this->need_2nd_expansion)
+                this = enter_prereqs (this, f->stem);
+              else
+                this->stem = f->stem;
+            }
+        }
+
+      /* Add the dependencies to this file entry.  */
+      if (this != 0)
+        {
+          /* Add the file's old deps and the new ones in THIS together.  */
+          if (f->deps == 0)
+            f->deps = this;
+          else if (cmds != 0)
+            {
+              struct dep *d = this;
+
+              /* If this rule has commands, put these deps first.  */
+              while (d->next != 0)
+                d = d->next;
+
+              d->next = f->deps;
+              f->deps = this;
+            }
+          else
+            {
+              struct dep *d = f->deps;
+
+              /* A rule without commands: put its prereqs at the end.  */
+              while (d->next != 0)
+                d = d->next;
+
+              d->next = this;
+            }
+        }
+
+      name = f->name;
+
+      /* All done!  Set up for the next one.  */
+      if (nextf == 0)
+        break;
+
+      filenames = nextf;
+
+      /* Reduce escaped percents.  If there are any unescaped it's an error  */
+      name = filenames->name;
+      if (find_percent_cached (&name))
+        O (error, flocp,
+           _("*** mixed implicit and normal rules: deprecated syntax"));
+    }
+}
+
+/* Search STRING for an unquoted STOPMAP.
+   Backslashes quote elements from STOPMAP and backslash.
+   Quoting backslashes are removed from STRING by compacting it into itself.
+   Returns a pointer to the first unquoted STOPCHAR if there is one, or nil if
+   there are none.
+
+   If MAP_VARIABLE is set, then the complete contents of variable references
+   are skipped, even if the contain STOPMAP characters.  */
+
+static char *
+find_map_unquote (char *string, int stopmap)
+{
+  unsigned int string_len = 0;
+  char *p = string;
+
+  /* Always stop on NUL.  */
+  stopmap |= MAP_NUL;
+
+  while (1)
+    {
+      while (! STOP_SET (*p, stopmap))
+        ++p;
+
+      if (*p == '\0')
+        break;
+
+      /* If we stopped due to a variable reference, skip over its contents.  */
+      if (*p == '$')
+        {
+          char openparen = p[1];
+
+          /* Check if '$' is the last character in the string.  */
+          if (openparen == '\0')
+            break;
+
+          p += 2;
+
+          /* Skip the contents of a non-quoted, multi-char variable ref.  */
+          if (openparen == '(' || openparen == '{')
+            {
+              unsigned int pcount = 1;
+              char closeparen = (openparen == '(' ? ')' : '}');
+
+              while (*p)
+                {
+                  if (*p == openparen)
+                    ++pcount;
+                  else if (*p == closeparen)
+                    if (--pcount == 0)
+                      {
+                        ++p;
+                        break;
+                      }
+                  ++p;
+                }
+            }
+
+          /* Skipped the variable reference: look for STOPCHARS again.  */
+          continue;
+        }
+
+      if (p > string && p[-1] == '\\')
+        {
+          /* Search for more backslashes.  */
+          int i = -2;
+          while (&p[i] >= string && p[i] == '\\')
+            --i;
+          ++i;
+          /* Only compute the length if really needed.  */
+          if (string_len == 0)
+            string_len = strlen (string);
+          /* The number of backslashes is now -I.
+             Copy P over itself to swallow half of them.  */
+          memmove (&p[i], &p[i/2], (string_len - (p - string)) - (i/2) + 1);
+          p += i/2;
+          if (i % 2 == 0)
+            /* All the backslashes quoted each other; the STOPCHAR was
+               unquoted.  */
+            return p;
+
+          /* The STOPCHAR was quoted by a backslash.  Look for another.  */
+        }
+      else
+        /* No backslash in sight.  */
+        return p;
+    }
+
+  /* Never hit a STOPCHAR or blank (with BLANK nonzero).  */
+  return 0;
+}
+
+static char *
+find_char_unquote (char *string, int stop)
+{
+  unsigned int string_len = 0;
+  char *p = string;
+
+  while (1)
+    {
+      p = strchr(p, stop);
+
+      if (!p)
+        return NULL;
+
+      if (p > string && p[-1] == '\\')
+        {
+          /* Search for more backslashes.  */
+          int i = -2;
+          while (&p[i] >= string && p[i] == '\\')
+            --i;
+          ++i;
+          /* Only compute the length if really needed.  */
+          if (string_len == 0)
+            string_len = strlen (string);
+          /* The number of backslashes is now -I.
+             Copy P over itself to swallow half of them.  */
+          memmove (&p[i], &p[i/2], (string_len - (p - string)) - (i/2) + 1);
+          p += i/2;
+          if (i % 2 == 0)
+            /* All the backslashes quoted each other; the STOPCHAR was
+               unquoted.  */
+            return p;
+
+          /* The STOPCHAR was quoted by a backslash.  Look for another.  */
+        }
+      else
+        /* No backslash in sight.  */
+        return p;
+    }
+}
+
+/* Unescape a character in a string.  The string is compressed onto itself.  */
+
+static char *
+unescape_char (char *string, int c)
+{
+  char *p = string;
+  char *s = string;
+
+  while (*s != '\0')
+    {
+      if (*s == '\\')
+        {
+          char *e = s;
+          int l;
+
+          /* We found a backslash.  See if it's escaping our character.  */
+          while (*e == '\\')
+            ++e;
+          l = e - s;
+
+          if (*e != c || l%2 == 0)
+            {
+              /* It's not; just take it all without unescaping.  */
+              memmove (p, s, l);
+              p += l;
+
+              // If we hit the end of the string, we're done
+              if (*e == '\0')
+                break;
+            }
+          else if (l > 1)
+            {
+              /* It is, and there's >1 backslash.  Take half of them.  */
+              l /= 2;
+              memmove (p, s, l);
+              p += l;
+            }
+
+          s = e;
+        }
+
+      *(p++) = *(s++);
+    }
+
+  *p = '\0';
+  return string;
+}
+
+/* Search PATTERN for an unquoted % and handle quoting.  */
+
+char *
+find_percent (char *pattern)
+{
+  return find_char_unquote (pattern, '%');
+}
+
+/* Search STRING for an unquoted % and handle quoting.  Returns a pointer to
+   the % or NULL if no % was found.
+   This version is used with strings in the string cache: if there's a need to
+   modify the string a new version will be added to the string cache and
+   *STRING will be set to that.  */
+
+const char *
+find_percent_cached (const char **string)
+{
+  const char *p = *string;
+  char *new = 0;
+  int slen = 0;
+
+  /* If the first char is a % return now.  This lets us avoid extra tests
+     inside the loop.  */
+  if (*p == '%')
+    return p;
+
+  while (1)
+    {
+      p = strchr(p, '%');
+
+      if (!p)
+        break;
+
+      /* See if this % is escaped with a backslash; if not we're done.  */
+      if (p[-1] != '\\')
+        break;
+
+      {
+        /* Search for more backslashes.  */
+        char *pv;
+        int i = -2;
+
+        while (&p[i] >= *string && p[i] == '\\')
+          --i;
+        ++i;
+
+        /* At this point we know we'll need to allocate a new string.
+           Make a copy if we haven't yet done so.  */
+        if (! new)
+          {
+            slen = strlen (*string);
+            new = alloca (slen + 1);
+            memcpy (new, *string, slen + 1);
+            p = new + (p - *string);
+            *string = new;
+          }
+
+        /* At this point *string, p, and new all point into the same string.
+           Get a non-const version of p so we can modify new.  */
+        pv = new + (p - *string);
+
+        /* The number of backslashes is now -I.
+           Copy P over itself to swallow half of them.  */
+        memmove (&pv[i], &pv[i/2], (slen - (pv - new)) - (i/2) + 1);
+        p += i/2;
+
+        /* If the backslashes quoted each other; the % was unquoted.  */
+        if (i % 2 == 0)
+          break;
+      }
+    }
+
+  /* If we had to change STRING, add it to the strcache.  */
+  if (new)
+    {
+      *string = strcache_add (*string);
+      if (p)
+	p = *string + (p - new);
+    }
+
+  /* If we didn't find a %, return NULL.  Otherwise return a ptr to it.  */
+  return p;
+}
+
+/* Find the next line of text in an eval buffer, combining continuation lines
+   into one line.
+   Return the number of actual lines read (> 1 if continuation lines).
+   Returns -1 if there's nothing left in the buffer.
+
+   After this function, ebuf->buffer points to the first character of the
+   line we just found.
+ */
+
+/* Read a line of text from a STRING.
+   Since we aren't really reading from a file, don't bother with linenumbers.
+ */
+
+static long
+readstring (struct ebuffer *ebuf)
+{
+  char *eol;
+
+  /* If there is nothing left in this buffer, return 0.  */
+  if (ebuf->bufnext >= ebuf->bufstart + ebuf->size)
+    return -1;
+
+  /* Set up a new starting point for the buffer, and find the end of the
+     next logical line (taking into account backslash/newline pairs).  */
+
+  eol = ebuf->buffer = ebuf->bufnext;
+
+  while (1)
+    {
+      int backslash = 0;
+      const char *bol = eol;
+      const char *p;
+
+      /* Find the next newline.  At EOS, stop.  */
+      p = eol = strchr (eol , '\n');
+      if (!eol)
+        {
+          ebuf->bufnext = ebuf->bufstart + ebuf->size + 1;
+          return 0;
+        }
+
+      /* Found a newline; if it's escaped continue; else we're done.  */
+      while (p > bol && *(--p) == '\\')
+        backslash = !backslash;
+      if (!backslash)
+        break;
+      ++eol;
+    }
+
+  /* Overwrite the newline char.  */
+  *eol = '\0';
+  ebuf->bufnext = eol+1;
+
+  return 0;
+}
+
+static long
+readline (struct ebuffer *ebuf)
+{
+  char *p;
+  char *end;
+  char *start;
+  long nlines = 0;
+
+  /* The behaviors between string and stream buffers are different enough to
+     warrant different functions.  Do the Right Thing.  */
+
+  if (!ebuf->fp)
+    return readstring (ebuf);
+
+  /* When reading from a file, we always start over at the beginning of the
+     buffer for each new line.  */
+
+  p = start = ebuf->bufstart;
+  end = p + ebuf->size;
+  *p = '\0';
+
+  while (fgets (p, (int)(end - p), ebuf->fp) != 0)
+    {
+      char *p2;
+      unsigned long len;
+      int backslash;
+
+      len = strlen (p);
+      if (len == 0)
+        {
+          /* This only happens when the first thing on the line is a '\0'.
+             It is a pretty hopeless case, but (wonder of wonders) Athena
+             lossage strikes again!  (xmkmf puts NULs in its makefiles.)
+             There is nothing really to be done; we synthesize a newline so
+             the following line doesn't appear to be part of this line.  */
+          O (error, &ebuf->floc,
+             _("warning: NUL character seen; rest of line ignored"));
+          p[0] = '\n';
+          len = 1;
+        }
+
+      /* Jump past the text we just read.  */
+      p += len;
+
+      /* If the last char isn't a newline, the whole line didn't fit into the
+         buffer.  Get some more buffer and try again.  */
+      if (p[-1] != '\n')
+        goto more_buffer;
+
+      /* We got a newline, so add one to the count of lines.  */
+      ++nlines;
+
+#if !defined(WINDOWS32) && !defined(__MSDOS__) && !defined(__EMX__)
+      /* Check to see if the line was really ended with CRLF; if so ignore
+         the CR.  */
+      if ((p - start) > 1 && p[-2] == '\r')
+        {
+          --p;
+          memmove (p-1, p, strlen (p) + 1);
+        }
+#endif
+
+      backslash = 0;
+      for (p2 = p - 2; p2 >= start; --p2)
+        {
+          if (*p2 != '\\')
+            break;
+          backslash = !backslash;
+        }
+
+      if (!backslash)
+        {
+          p[-1] = '\0';
+          break;
+        }
+
+      /* It was a backslash/newline combo.  If we have more space, read
+         another line.  */
+      if (end - p >= 80)
+        continue;
+
+      /* We need more space at the end of our buffer, so realloc it.
+         Make sure to preserve the current offset of p.  */
+    more_buffer:
+      {
+        unsigned long off = p - start;
+        ebuf->size *= 2;
+        start = ebuf->buffer = ebuf->bufstart = xrealloc (start, ebuf->size);
+        p = start + off;
+        end = start + ebuf->size;
+        *p = '\0';
+      }
+    }
+
+  if (ferror (ebuf->fp))
+    pfatal_with_name (ebuf->floc.filenm);
+
+  /* If we found some lines, return how many.
+     If we didn't, but we did find _something_, that indicates we read the last
+     line of a file with no final newline; return 1.
+     If we read nothing, we're at EOF; return -1.  */
+
+  return nlines ? nlines : p == ebuf->bufstart ? -1 : 1;
+}
+
+/* Parse the next "makefile word" from the input buffer, and return info
+   about it.
+
+   A "makefile word" is one of:
+
+     w_bogus        Should never happen
+     w_eol          End of input
+     w_static       A static word; cannot be expanded
+     w_variable     A word containing one or more variables/functions
+     w_colon        A colon
+     w_dcolon       A double-colon
+     w_semicolon    A semicolon
+     w_varassign    A variable assignment operator (=, :=, ::=, +=, ?=, or !=)
+
+   Note that this function is only used when reading certain parts of the
+   makefile.  Don't use it where special rules hold sway (RHS of a variable,
+   in a command list, etc.)  */
+
+static enum make_word_type
+get_next_mword (char *buffer, char *delim, char **startp, unsigned int *length)
+{
+  enum make_word_type wtype;
+  char *p = buffer, *beg;
+  char c;
+
+  /* Skip any leading whitespace.  */
+  while (ISBLANK (*p))
+    ++p;
+
+  beg = p;
+  c = *(p++);
+
+  /* Look at the start of the word to see if it's simple.  */
+  switch (c)
+    {
+    case '\0':
+      wtype = w_eol;
+      goto done;
+
+    case ';':
+      wtype = w_semicolon;
+      goto done;
+
+    case '=':
+      wtype = w_varassign;
+      goto done;
+
+    case ':':
+      if (*p == '=')
+        {
+          ++p;
+          wtype = w_varassign; /* := */
+        }
+      else if (*p == ':')
+        {
+          ++p;
+          if (p[1] == '=')
+            {
+              ++p;
+              wtype = w_varassign; /* ::= */
+            }
+          else
+            wtype = w_dcolon;
+        }
+      else
+        wtype = w_colon;
+      goto done;
+
+    case '+':
+    case '?':
+    case '!':
+      if (*p == '=')
+        {
+          ++p;
+          wtype = w_varassign; /* += or ?= or != */
+          goto done;
+        }
+      /* FALLTHROUGH */
+
+    default:
+      if (delim && strchr (delim, c))
+        {
+          wtype = w_static;
+          goto done;
+        }
+    }
+
+  /* This is some non-operator word.  A word consists of the longest
+     string of characters that doesn't contain whitespace, one of [:=#],
+     or [?+!]=, or one of the chars in the DELIM string.  */
+
+  /* We start out assuming a static word; if we see a variable we'll
+     adjust our assumptions then.  */
+  wtype = w_static;
+
+  /* We already found the first value of "c", above.  */
+  while (1)
+    {
+      char closeparen;
+      int count;
+
+      switch (c)
+        {
+        case '\0':
+        case ' ':
+        case '\t':
+        case '=':
+          goto done_word;
+
+        case ':':
+#ifdef HAVE_DOS_PATHS
+          /* A word CAN include a colon in its drive spec.  The drive
+             spec is allowed either at the beginning of a word, or as part
+             of the archive member name, like in "libfoo.a(d:/foo/bar.o)".  */
+          if (!(p - beg >= 2
+                && (*p == '/' || *p == '\\') && isalpha ((unsigned char)p[-2])
+                && (p - beg == 2 || p[-3] == '(')))
+#endif
+          goto done_word;
+
+        case '$':
+          c = *(p++);
+          if (c == '$')
+            break;
+          if (c == '\0')
+            goto done_word;
+
+          /* This is a variable reference, so note that it's expandable.
+             Then read it to the matching close paren.  */
+          wtype = w_variable;
+
+          if (c == '(')
+            closeparen = ')';
+          else if (c == '{')
+            closeparen = '}';
+          else
+            /* This is a single-letter variable reference.  */
+            break;
+
+          for (count=0; *p != '\0'; ++p)
+            {
+              if (*p == c)
+                ++count;
+              else if (*p == closeparen && --count < 0)
+                {
+                  ++p;
+                  break;
+                }
+            }
+          break;
+
+        case '?':
+        case '+':
+          if (*p == '=')
+            goto done_word;
+          break;
+
+        case '\\':
+          switch (*p)
+            {
+            case ':':
+            case ';':
+            case '=':
+            case '\\':
+              ++p;
+              break;
+            }
+          break;
+
+        default:
+          if (delim && strchr (delim, c))
+            goto done_word;
+          break;
+        }
+
+      c = *(p++);
+    }
+ done_word:
+  --p;
+
+ done:
+  if (startp)
+    *startp = beg;
+  if (length)
+    *length = p - beg;
+  return wtype;
+}
+
+/* Construct the list of include directories
+   from the arguments and the default list.  */
+
+void
+construct_include_path (const char **arg_dirs)
+{
+#ifdef VAXC             /* just don't ask ... */
+  stat_t stbuf;
+#else
+  struct stat stbuf;
+#endif
+  const char **dirs;
+  const char **cpp;
+  unsigned int idx;
+
+  /* Compute the number of pointers we need in the table.  */
+  idx = sizeof (default_include_directories) / sizeof (const char *);
+  if (arg_dirs)
+    for (cpp = arg_dirs; *cpp != 0; ++cpp)
+      ++idx;
+
+#ifdef  __MSDOS__
+  /* Add one for $DJDIR.  */
+  ++idx;
+#endif
+
+  dirs = xmalloc (idx * sizeof (const char *));
+
+  idx = 0;
+  max_incl_len = 0;
+
+  /* First consider any dirs specified with -I switches.
+     Ignore any that don't exist.  Remember the maximum string length.  */
+
+  if (arg_dirs)
+    while (*arg_dirs != 0)
+      {
+        const char *dir = *(arg_dirs++);
+        char *expanded = 0;
+        int e;
+
+        if (dir[0] == '~')
+          {
+            expanded = tilde_expand (dir);
+            if (expanded != 0)
+              dir = expanded;
+          }
+
+        EINTRLOOP (e, stat (dir, &stbuf));
+        if (e == 0 && S_ISDIR (stbuf.st_mode))
+          {
+            unsigned int len = strlen (dir);
+            /* If dir name is written with trailing slashes, discard them.  */
+            while (len > 1 && dir[len - 1] == '/')
+              --len;
+            if (len > max_incl_len)
+              max_incl_len = len;
+            dirs[idx++] = strcache_add_len (dir, len);
+          }
+
+        free (expanded);
+      }
+
+  /* Now add the standard default dirs at the end.  */
+
+#ifdef  __MSDOS__
+  {
+    /* The environment variable $DJDIR holds the root of the DJGPP directory
+       tree; add ${DJDIR}/include.  */
+    struct variable *djdir = lookup_variable ("DJDIR", 5);
+
+    if (djdir)
+      {
+        unsigned int len = strlen (djdir->value) + 8;
+        char *defdir = alloca (len + 1);
+
+        strcat (strcpy (defdir, djdir->value), "/include");
+        dirs[idx++] = strcache_add (defdir);
+
+        if (len > max_incl_len)
+          max_incl_len = len;
+      }
+  }
+#endif
+
+  for (cpp = default_include_directories; *cpp != 0; ++cpp)
+    {
+      int e;
+
+      EINTRLOOP (e, stat (*cpp, &stbuf));
+      if (e == 0 && S_ISDIR (stbuf.st_mode))
+        {
+          unsigned int len = strlen (*cpp);
+          /* If dir name is written with trailing slashes, discard them.  */
+          while (len > 1 && (*cpp)[len - 1] == '/')
+            --len;
+          if (len > max_incl_len)
+            max_incl_len = len;
+          dirs[idx++] = strcache_add_len (*cpp, len);
+        }
+    }
+
+  dirs[idx] = 0;
+
+  /* Now add each dir to the .INCLUDE_DIRS variable.  */
+
+  for (cpp = dirs; *cpp != 0; ++cpp)
+    do_variable_definition (NILF, ".INCLUDE_DIRS", *cpp,
+                            o_default, f_append, 0);
+
+  include_directories = dirs;
+}
+
+/* Expand ~ or ~USER at the beginning of NAME.
+   Return a newly malloc'd string or 0.  */
+
+char *
+tilde_expand (const char *name)
+{
+#ifndef VMS
+  if (name[1] == '/' || name[1] == '\0')
+    {
+      char *home_dir;
+      int is_variable;
+
+      {
+        /* Turn off --warn-undefined-variables while we expand HOME.  */
+        int save = warn_undefined_variables_flag;
+        warn_undefined_variables_flag = 0;
+
+        home_dir = allocated_variable_expand ("$(HOME)");
+
+        warn_undefined_variables_flag = save;
+      }
+
+      is_variable = home_dir[0] != '\0';
+      if (!is_variable)
+        {
+          free (home_dir);
+          home_dir = getenv ("HOME");
+        }
+# if !defined(_AMIGA) && !defined(WINDOWS32)
+      if (home_dir == 0 || home_dir[0] == '\0')
+        {
+          char *logname = getlogin ();
+          home_dir = 0;
+          if (logname != 0)
+            {
+              struct passwd *p = getpwnam (logname);
+              if (p != 0)
+                home_dir = p->pw_dir;
+            }
+        }
+# endif /* !AMIGA && !WINDOWS32 */
+      if (home_dir != 0)
+        {
+          char *new = xstrdup (concat (2, home_dir, name + 1));
+          if (is_variable)
+            free (home_dir);
+          return new;
+        }
+    }
+# if !defined(_AMIGA) && !defined(WINDOWS32)
+  else
+    {
+      struct passwd *pwent;
+      char *userend = strchr (name + 1, '/');
+      if (userend != 0)
+        *userend = '\0';
+      pwent = getpwnam (name + 1);
+      if (pwent != 0)
+        {
+          if (userend == 0)
+            return xstrdup (pwent->pw_dir);
+          else
+            return xstrdup (concat (3, pwent->pw_dir, "/", userend + 1));
+        }
+      else if (userend != 0)
+        *userend = '/';
+    }
+# endif /* !AMIGA && !WINDOWS32 */
+#endif /* !VMS */
+  return 0;
+}
+
+/* Parse a string into a sequence of filenames represented as a chain of
+   struct nameseq's and return that chain.  Optionally expand the strings via
+   glob().
+
+   The string is passed as STRINGP, the address of a string pointer.
+   The string pointer is updated to point at the first character
+   not parsed, which either is a null char or equals STOPCHAR.
+
+   SIZE is how big to construct chain elements.
+   This is useful if we want them actually to be other structures
+   that have room for additional info.
+
+   PREFIX, if non-null, is added to the beginning of each filename.
+
+   FLAGS allows one or more of the following bitflags to be set:
+        PARSEFS_NOSTRIP - Do no strip './'s off the beginning
+        PARSEFS_NOAR    - Do not check filenames for archive references
+        PARSEFS_NOGLOB  - Do not expand globbing characters
+        PARSEFS_EXISTS  - Only return globbed files that actually exist
+                          (cannot also set NOGLOB)
+        PARSEFS_NOCACHE - Do not add filenames to the strcache (caller frees)
+  */
+
+void *
+parse_file_seq (char **stringp, unsigned int size, int stopmap,
+                const char *prefix, int flags)
+{
+  /* tmp points to tmpbuf after the prefix, if any.
+     tp is the end of the buffer. */
+  static char *tmpbuf = NULL;
+
+  int cachep = NONE_SET (flags, PARSEFS_NOCACHE);
+
+  struct nameseq *new = 0;
+  struct nameseq **newp = &new;
+#define NEWELT(_n)  do { \
+                        const char *__n = (_n); \
+                        *newp = xcalloc (size); \
+                        (*newp)->name = (cachep ? strcache_add (__n) : xstrdup (__n)); \
+                        newp = &(*newp)->next; \
+                    } while(0)
+
+  char *p;
+  glob_t gl;
+  char *tp;
+  int findmap = stopmap|MAP_VMSCOMMA|MAP_BLANK|MAP_NUL;
+
+  /* Always stop on NUL.  */
+  stopmap |= MAP_NUL;
+
+  if (size < sizeof (struct nameseq))
+    size = sizeof (struct nameseq);
+
+  if (NONE_SET (flags, PARSEFS_NOGLOB))
+    dir_setup_glob (&gl);
+
+  /* Get enough temporary space to construct the largest possible target.  */
+  {
+    static int tmpbuf_len = 0;
+    int l = strlen (*stringp) + 1;
+    if (l > tmpbuf_len)
+      {
+        tmpbuf = xrealloc (tmpbuf, l);
+        tmpbuf_len = l;
+      }
+  }
+  tp = tmpbuf;
+
+  /* Parse STRING.  P will always point to the end of the parsed content.  */
+  p = *stringp;
+  while (1)
+    {
+      const char *name;
+      const char **nlist = 0;
+      char *tildep = 0;
+      int globme = 1;
+#ifndef NO_ARCHIVES
+      char *arname = 0;
+      char *memname = 0;
+#endif
+      char *s;
+      int nlen;
+      int i;
+
+      /* Skip whitespace; at the end of the string or STOPCHAR we're done.  */
+      NEXT_TOKEN (p);
+      if (STOP_SET (*p, stopmap))
+        break;
+
+      /* There are names left, so find the end of the next name.
+         Throughout this iteration S points to the start.  */
+      s = p;
+      p = find_map_unquote (p, findmap);
+
+#ifdef VMS
+        /* convert comma separated list to space separated */
+      if (p && *p == ',')
+        *p =' ';
+#endif
+#ifdef _AMIGA
+      /* If we stopped due to a device name, skip it.  */
+      if (p && p != s+1 && p[0] == ':')
+        p = find_map_unquote (p+1, findmap);
+#endif
+#ifdef HAVE_DOS_PATHS
+      /* If we stopped due to a drive specifier, skip it.
+         Tokens separated by spaces are treated as separate paths since make
+         doesn't allow path names with spaces.  */
+      if (p && p == s+1 && p[0] == ':'
+          && isalpha ((unsigned char)s[0]) && STOP_SET (p[1], MAP_DIRSEP))
+        p = find_map_unquote (p+1, findmap);
+#endif
+
+      if (!p)
+        p = s + strlen (s);
+
+      /* Strip leading "this directory" references.  */
+      if (NONE_SET (flags, PARSEFS_NOSTRIP))
+#ifdef VMS
+        /* Skip leading '[]'s. should only be one set or bug somwhere else */
+        if (p - s > 2 && s[0] == '[' && s[1] == ']')
+            s += 2;
+        /* Skip leading '<>'s. should only be one set or bug somwhere else */
+        if (p - s > 2 && s[0] == '<' && s[1] == '>')
+            s += 2;
+#endif
+        /* Skip leading './'s.  */
+        while (p - s > 2 && s[0] == '.' && s[1] == '/')
+          {
+            /* Skip "./" and all following slashes.  */
+            s += 2;
+            while (*s == '/')
+              ++s;
+          }
+
+      /* Extract the filename just found, and skip it.
+         Set NAME to the string, and NLEN to its length.  */
+
+      if (s == p)
+        {
+        /* The name was stripped to empty ("./"). */
+#if defined(_AMIGA)
+          /* PDS-- This cannot be right!! */
+          tp[0] = '\0';
+          nlen = 0;
+#else
+          tp[0] = '.';
+          tp[1] = '/';
+          tp[2] = '\0';
+          nlen = 2;
+#endif
+        }
+      else
+        {
+#ifdef VMS
+/* VMS filenames can have a ':' in them but they have to be '\'ed but we need
+ *  to remove this '\' before we can use the filename.
+ * xstrdup called because S may be read-only string constant.
+ */
+          char *n = tp;
+          while (s < p)
+            {
+              if (s[0] == '\\' && s[1] == ':')
+                ++s;
+              *(n++) = *(s++);
+            }
+          n[0] = '\0';
+          nlen = strlen (tp);
+#else
+          nlen = p - s;
+          memcpy (tp, s, nlen);
+          tp[nlen] = '\0';
+#endif
+        }
+
+      /* At this point, TP points to the element and NLEN is its length.  */
+
+#ifndef NO_ARCHIVES
+      /* If this is the start of an archive group that isn't complete, set up
+         to add the archive prefix for future files.  A file list like:
+         "libf.a(x.o y.o z.o)" needs to be expanded as:
+         "libf.a(x.o) libf.a(y.o) libf.a(z.o)"
+
+         TP == TMP means we're not already in an archive group.  Ignore
+         something starting with '(', as that cannot actually be an
+         archive-member reference (and treating it as such results in an empty
+         file name, which causes much lossage).  Also if it ends in ")" then
+         it's a complete reference so we don't need to treat it specially.
+
+         Finally, note that archive groups must end with ')' as the last
+         character, so ensure there's some word ending like that before
+         considering this an archive group.  */
+      if (NONE_SET (flags, PARSEFS_NOAR)
+          && tp == tmpbuf && tp[0] != '(' && tp[nlen-1] != ')')
+        {
+          char *n = strchr (tp, '(');
+          if (n)
+            {
+              /* This looks like the first element in an open archive group.
+                 A valid group MUST have ')' as the last character.  */
+              const char *e = p;
+              do
+                {
+                  const char *o = e;
+                  NEXT_TOKEN (e);
+                  /* Find the end of this word.  We don't want to unquote and
+                     we don't care about quoting since we're looking for the
+                     last char in the word. */
+                  while (! STOP_SET (*e, findmap))
+                    ++e;
+                  /* If we didn't move, we're done now.  */
+                  if (e == o)
+                    break;
+                  if (e[-1] == ')')
+                    {
+                      /* Found the end, so this is the first element in an
+                         open archive group.  It looks like "lib(mem".
+                         Reset TP past the open paren.  */
+                      nlen -= (n + 1) - tp;
+                      tp = n + 1;
+
+                      /* We can stop looking now.  */
+                      break;
+                    }
+                }
+              while (*e != '\0');
+
+              /* If we have just "lib(", part of something like "lib( a b)",
+                 go to the next item.  */
+              if (! nlen)
+                continue;
+            }
+        }
+
+      /* If we are inside an archive group, make sure it has an end.  */
+      if (tp > tmpbuf)
+        {
+          if (tp[nlen-1] == ')')
+            {
+              /* This is the natural end; reset TP.  */
+              tp = tmpbuf;
+
+              /* This is just ")", something like "lib(a b )": skip it.  */
+              if (nlen == 1)
+                continue;
+            }
+          else
+            {
+              /* Not the end, so add a "fake" end.  */
+              tp[nlen++] = ')';
+              tp[nlen] = '\0';
+            }
+        }
+#endif
+
+      /* If we're not globbing we're done: add it to the end of the chain.
+         Go to the next item in the string.  */
+      if (ANY_SET (flags, PARSEFS_NOGLOB))
+        {
+          NEWELT (concat (2, prefix, tmpbuf));
+          continue;
+        }
+
+      /* If we get here we know we're doing glob expansion.
+         TP is a string in tmpbuf.  NLEN is no longer used.
+         We may need to do more work: after this NAME will be set.  */
+      name = tmpbuf;
+
+      /* Expand tilde if applicable.  */
+      if (tmpbuf[0] == '~')
+        {
+          tildep = tilde_expand (tmpbuf);
+          if (tildep != 0)
+            name = tildep;
+        }
+
+#ifndef NO_ARCHIVES
+      /* If NAME is an archive member reference replace it with the archive
+         file name, and save the member name in MEMNAME.  We will glob on the
+         archive name and then reattach MEMNAME later.  */
+      if (NONE_SET (flags, PARSEFS_NOAR) && ar_name (name))
+        {
+          ar_parse_name (name, &arname, &memname);
+          name = arname;
+        }
+#endif /* !NO_ARCHIVES */
+
+      /* glob() is expensive: don't call it unless we need to.  */
+      if (NONE_SET (flags, PARSEFS_EXISTS) && strpbrk (name, "?*[") == NULL)
+        {
+          globme = 0;
+          i = 1;
+          nlist = &name;
+        }
+      else
+        switch (glob (name, GLOB_NOSORT|GLOB_ALTDIRFUNC, NULL, &gl))
+          {
+          case GLOB_NOSPACE:
+            out_of_memory ();
+
+          case 0:
+            /* Success.  */
+            i = gl.gl_pathc;
+            nlist = (const char **)gl.gl_pathv;
+            break;
+
+          case GLOB_NOMATCH:
+            /* If we want only existing items, skip this one.  */
+            if (ANY_SET (flags, PARSEFS_EXISTS))
+              {
+                i = 0;
+                break;
+              }
+            /* FALLTHROUGH */
+
+          default:
+            /* By default keep this name.  */
+            i = 1;
+            nlist = &name;
+            break;
+          }
+
+      /* For each matched element, add it to the list.  */
+      while (i-- > 0)
+#ifndef NO_ARCHIVES
+        if (memname != 0)
+          {
+            /* Try to glob on MEMNAME within the archive.  */
+            struct nameseq *found = ar_glob (nlist[i], memname, size);
+            if (! found)
+              /* No matches.  Use MEMNAME as-is.  */
+              NEWELT (concat (5, prefix, nlist[i], "(", memname, ")"));
+            else
+              {
+                /* We got a chain of items.  Attach them.  */
+                if (*newp)
+                  (*newp)->next = found;
+                else
+                  *newp = found;
+
+                /* Find and set the new end.  Massage names if necessary.  */
+                while (1)
+                  {
+                    if (! cachep)
+                      found->name = xstrdup (concat (2, prefix, name));
+                    else if (prefix)
+                      found->name = strcache_add (concat (2, prefix, name));
+
+                    if (found->next == 0)
+                      break;
+
+                    found = found->next;
+                  }
+                newp = &found->next;
+              }
+          }
+        else
+#endif /* !NO_ARCHIVES */
+          NEWELT (concat (2, prefix, nlist[i]));
+
+      if (globme)
+        globfree (&gl);
+
+#ifndef NO_ARCHIVES
+      free (arname);
+#endif
+
+      free (tildep);
+    }
+
+  *stringp = p;
+  return new;
+}
diff --git a/src/remake.c b/src/remake.c
new file mode 100644
index 0000000..b4bf1cb
--- /dev/null
+++ b/src/remake.c
@@ -0,0 +1,1755 @@
+/* Basic dependency engine for GNU Make.
+Copyright (C) 1988-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+#include "filedef.h"
+#include "job.h"
+#include "commands.h"
+#include "dep.h"
+#include "variable.h"
+#include "debug.h"
+
+#include <assert.h>
+
+#ifdef HAVE_FCNTL_H
+#include <fcntl.h>
+#else
+#include <sys/file.h>
+#endif
+
+#ifdef VMS
+#include <starlet.h>
+#endif
+#ifdef WINDOWS32
+#include <io.h>
+#endif
+
+
+/* The test for circular dependencies is based on the 'updating' bit in
+   'struct file'.  However, double colon targets have separate 'struct
+   file's; make sure we always use the base of the double colon chain. */
+
+#define start_updating(_f)  (((_f)->double_colon ? (_f)->double_colon : (_f))\
+                             ->updating = 1)
+#define finish_updating(_f) (((_f)->double_colon ? (_f)->double_colon : (_f))\
+                             ->updating = 0)
+#define is_updating(_f)     (((_f)->double_colon ? (_f)->double_colon : (_f))\
+                             ->updating)
+
+
+/* Incremented when a command is started (under -n, when one would be).  */
+unsigned int commands_started = 0;
+
+/* Set to the goal dependency.  Mostly needed for remaking makefiles.  */
+static struct goaldep *goal_list;
+static struct dep *goal_dep;
+
+/* Current value for pruning the scan of the goal chain.
+   All files start with considered == 0.  */
+static unsigned int considered = 0;
+
+static enum update_status update_file (struct file *file, unsigned int depth);
+static enum update_status update_file_1 (struct file *file, unsigned int depth);
+static enum update_status check_dep (struct file *file, unsigned int depth,
+                                     FILE_TIMESTAMP this_mtime, int *must_make);
+static enum update_status touch_file (struct file *file);
+static void remake_file (struct file *file);
+static FILE_TIMESTAMP name_mtime (const char *name);
+static const char *library_search (const char *lib, FILE_TIMESTAMP *mtime_ptr);
+
+
+/* Remake all the goals in the 'struct dep' chain GOALS.  Return -1 if nothing
+   was done, 0 if all goals were updated successfully, or 1 if a goal failed.
+
+   If rebuilding_makefiles is nonzero, these goals are makefiles, so -t, -q,
+   and -n should be disabled for them unless they were also command-line
+   targets, and we should only make one goal at a time and return as soon as
+   one goal whose 'changed' member is nonzero is successfully made.  */
+
+enum update_status
+update_goal_chain (struct goaldep *goaldeps)
+{
+  int t = touch_flag, q = question_flag, n = just_print_flag;
+  enum update_status status = us_none;
+
+  /* Duplicate the chain so we can remove things from it.  */
+
+  struct dep *goals = copy_dep_chain ((struct dep *)goaldeps);
+
+  goal_list = rebuilding_makefiles ? goaldeps : NULL;
+
+#define MTIME(file) (rebuilding_makefiles ? file_mtime_no_search (file) \
+                     : file_mtime (file))
+
+  /* Start a fresh batch of consideration.  */
+  ++considered;
+
+  /* Update all the goals until they are all finished.  */
+
+  while (goals != 0)
+    {
+      struct dep *g, *lastgoal;
+
+      /* Start jobs that are waiting for the load to go down.  */
+
+      start_waiting_jobs ();
+
+      /* Wait for a child to die.  */
+
+      reap_children (1, 0);
+
+      lastgoal = 0;
+      g = goals;
+      while (g != 0)
+        {
+          /* Iterate over all double-colon entries for this file.  */
+          struct file *file;
+          int stop = 0, any_not_updated = 0;
+
+          goal_dep = g;
+
+          for (file = g->file->double_colon ? g->file->double_colon : g->file;
+               file != NULL;
+               file = file->prev)
+            {
+              unsigned int ocommands_started;
+              enum update_status fail;
+
+              file->dontcare = ANY_SET (g->flags, RM_DONTCARE);
+
+              check_renamed (file);
+              if (rebuilding_makefiles)
+                {
+                  if (file->cmd_target)
+                    {
+                      touch_flag = t;
+                      question_flag = q;
+                      just_print_flag = n;
+                    }
+                  else
+                    touch_flag = question_flag = just_print_flag = 0;
+                }
+
+              /* Save the old value of 'commands_started' so we can compare
+                 later.  It will be incremented when any commands are
+                 actually run.  */
+              ocommands_started = commands_started;
+
+              fail = update_file (file, rebuilding_makefiles ? 1 : 0);
+              check_renamed (file);
+
+              /* Set the goal's 'changed' flag if any commands were started
+                 by calling update_file above.  We check this flag below to
+                 decide when to give an "up to date" diagnostic.  */
+              if (commands_started > ocommands_started)
+                g->changed = 1;
+
+              stop = 0;
+              if ((fail || file->updated) && status < us_question)
+                {
+                  /* We updated this goal.  Update STATUS and decide whether
+                     to stop.  */
+                  if (file->update_status)
+                    {
+                      /* Updating failed, or -q triggered.  The STATUS value
+                         tells our caller which.  */
+                      status = file->update_status;
+                      /* If -q just triggered, stop immediately.  It doesn't
+                         matter how much more we run, since we already know
+                         the answer to return.  */
+                      stop = (question_flag && !keep_going_flag
+                              && !rebuilding_makefiles);
+                    }
+                  else
+                    {
+                      FILE_TIMESTAMP mtime = MTIME (file);
+                      check_renamed (file);
+
+                      if (file->updated && g->changed &&
+                           mtime != file->mtime_before_update)
+                        {
+                          /* Updating was done.  If this is a makefile and
+                             just_print_flag or question_flag is set (meaning
+                             -n or -q was given and this file was specified
+                             as a command-line target), don't change STATUS.
+                             If STATUS is changed, we will get re-exec'd, and
+                             enter an infinite loop.  */
+                          if (!rebuilding_makefiles
+                              || (!just_print_flag && !question_flag))
+                            status = us_success;
+                          if (rebuilding_makefiles && file->dontcare)
+                            /* This is a default makefile; stop remaking.  */
+                            stop = 1;
+                        }
+                    }
+                }
+
+              /* Keep track if any double-colon entry is not finished.
+                 When they are all finished, the goal is finished.  */
+              any_not_updated |= !file->updated;
+
+              file->dontcare = 0;
+
+              if (stop)
+                break;
+            }
+
+          /* Reset FILE since it is null at the end of the loop.  */
+          file = g->file;
+
+          if (stop || !any_not_updated)
+            {
+              /* If we have found nothing whatever to do for the goal,
+                 print a message saying nothing needs doing.  */
+
+              if (!rebuilding_makefiles
+                  /* If the update_status is success, we updated successfully
+                     or not at all.  G->changed will have been set above if
+                     any commands were actually started for this goal.  */
+                  && file->update_status == us_success && !g->changed
+                  /* Never give a message under -s or -q.  */
+                  && !silent_flag && !question_flag)
+                OS (message, 1, ((file->phony || file->cmds == 0)
+                                 ? _("Nothing to be done for '%s'.")
+                                 : _("'%s' is up to date.")),
+                    file->name);
+
+              /* This goal is finished.  Remove it from the chain.  */
+              if (lastgoal == 0)
+                goals = g->next;
+              else
+                lastgoal->next = g->next;
+
+              /* Free the storage.  */
+              free (g);
+
+              g = lastgoal == 0 ? goals : lastgoal->next;
+
+              if (stop)
+                break;
+            }
+          else
+            {
+              lastgoal = g;
+              g = g->next;
+            }
+        }
+
+      /* If we reached the end of the dependency graph update CONSIDERED
+         for the next pass.  */
+      if (g == 0)
+        ++considered;
+    }
+
+  if (rebuilding_makefiles)
+    {
+      touch_flag = t;
+      question_flag = q;
+      just_print_flag = n;
+    }
+
+  return status;
+}
+
+/* If we're rebuilding an included makefile that failed, and we care
+   about errors, show an error message the first time.  */
+
+void
+show_goal_error (void)
+{
+  struct goaldep *goal;
+
+  if ((goal_dep->flags & (RM_INCLUDED|RM_DONTCARE)) != RM_INCLUDED)
+    return;
+
+  for (goal = goal_list; goal; goal = goal->next)
+    if (goal_dep->file == goal->file)
+      {
+        if (goal->error)
+          {
+            OSS (error, &goal->floc, "%s: %s",
+                 goal->file->name, strerror ((int)goal->error));
+            goal->error = 0;
+          }
+        return;
+      }
+}
+
+/* If FILE is not up to date, execute the commands for it.
+   Return 0 if successful, non-0 if unsuccessful;
+   but with some flag settings, just call 'exit' if unsuccessful.
+
+   DEPTH is the depth in recursions of this function.
+   We increment it during the consideration of our dependencies,
+   then decrement it again after finding out whether this file
+   is out of date.
+
+   If there are multiple double-colon entries for FILE,
+   each is considered in turn.  */
+
+static enum update_status
+update_file (struct file *file, unsigned int depth)
+{
+  enum update_status status = us_success;
+  struct file *f;
+
+  f = file->double_colon ? file->double_colon : file;
+
+  /* Prune the dependency graph: if we've already been here on _this_
+     pass through the dependency graph, we don't have to go any further.
+     We won't reap_children until we start the next pass, so no state
+     change is possible below here until then.  */
+  if (f->considered == considered)
+    {
+      /* Check for the case where a target has been tried and failed but
+         the diagnostics haven't been issued. If we need the diagnostics
+         then we will have to continue. */
+      if (!(f->updated && f->update_status > us_none
+            && !f->dontcare && f->no_diag))
+        {
+          DBF (DB_VERBOSE, _("Pruning file '%s'.\n"));
+          return f->command_state == cs_finished ? f->update_status : us_success;
+        }
+    }
+
+  /* This loop runs until we start commands for a double colon rule, or until
+     the chain is exhausted. */
+  for (; f != 0; f = f->prev)
+    {
+      enum update_status new;
+
+      f->considered = considered;
+
+      new = update_file_1 (f, depth);
+      check_renamed (f);
+
+      /* Clean up any alloca() used during the update.  */
+      alloca (0);
+
+      /* If we got an error, don't bother with double_colon etc.  */
+      if (new && !keep_going_flag)
+        return new;
+
+      if (f->command_state == cs_running
+          || f->command_state == cs_deps_running)
+        /* Don't run other :: rules for this target until
+           this rule is finished.  */
+        return us_success;
+
+      if (new > status)
+        status = new;
+    }
+
+  return status;
+}
+
+/* Show a message stating the target failed to build.  */
+
+static void
+complain (struct file *file)
+{
+  /* If this file has no_diag set then it means we tried to update it
+     before in the dontcare mode and failed. The target that actually
+     failed is not necessarily this file but could be one of its direct
+     or indirect dependencies. So traverse this file's dependencies and
+     find the one that actually caused the failure. */
+
+  struct dep *d;
+
+  for (d = file->deps; d != 0; d = d->next)
+    {
+      if (d->file->updated && d->file->update_status > us_none && file->no_diag)
+        {
+          complain (d->file);
+          break;
+        }
+    }
+
+  if (d == 0)
+    {
+      show_goal_error ();
+
+      /* Didn't find any dependencies to complain about. */
+      if (file->parent)
+        {
+          size_t l = strlen (file->name) + strlen (file->parent->name) + 4;
+          const char *m = _("%sNo rule to make target '%s', needed by '%s'%s");
+
+          if (!keep_going_flag)
+            fatal (NILF, l, m, "", file->name, file->parent->name, "");
+
+          error (NILF, l, m, "*** ", file->name, file->parent->name, ".");
+        }
+      else
+        {
+          size_t l = strlen (file->name) + 4;
+          const char *m = _("%sNo rule to make target '%s'%s");
+
+          if (!keep_going_flag)
+            fatal (NILF, l, m, "", file->name, "");
+
+          error (NILF, l, m, "*** ", file->name, ".");
+        }
+
+      file->no_diag = 0;
+    }
+}
+
+/* Consider a single 'struct file' and update it as appropriate.
+   Return 0 on success, or non-0 on failure.  */
+
+static enum update_status
+update_file_1 (struct file *file, unsigned int depth)
+{
+  enum update_status dep_status = us_success;
+  FILE_TIMESTAMP this_mtime;
+  int noexist, must_make, deps_changed;
+  struct file *ofile;
+  struct dep *d, *ad;
+  struct dep amake;
+  int running = 0;
+
+  DBF (DB_VERBOSE, _("Considering target file '%s'.\n"));
+
+  if (file->updated)
+    {
+      if (file->update_status > us_none)
+        {
+          DBF (DB_VERBOSE,
+               _("Recently tried and failed to update file '%s'.\n"));
+
+          /* If the file we tried to make is marked no_diag then no message
+             was printed about it when it failed during the makefile rebuild.
+             If we're trying to build it again in the normal rebuild, print a
+             message now.  */
+          if (file->no_diag && !file->dontcare)
+              complain (file);
+
+          return file->update_status;
+        }
+
+      DBF (DB_VERBOSE, _("File '%s' was considered already.\n"));
+      return 0;
+    }
+
+  switch (file->command_state)
+    {
+    case cs_not_started:
+    case cs_deps_running:
+      break;
+    case cs_running:
+      DBF (DB_VERBOSE, _("Still updating file '%s'.\n"));
+      return 0;
+    case cs_finished:
+      DBF (DB_VERBOSE, _("Finished updating file '%s'.\n"));
+      return file->update_status;
+    default:
+      abort ();
+    }
+
+  /* Determine whether the diagnostics will be issued should this update
+     fail. */
+  file->no_diag = file->dontcare;
+
+  ++depth;
+
+  /* Notice recursive update of the same file.  */
+  start_updating (file);
+
+  /* We might change file if we find a different one via vpath;
+     remember this one to turn off updating.  */
+  ofile = file;
+
+  /* Looking at the file's modtime beforehand allows the possibility
+     that its name may be changed by a VPATH search, and thus it may
+     not need an implicit rule.  If this were not done, the file
+     might get implicit commands that apply to its initial name, only
+     to have that name replaced with another found by VPATH search.  */
+
+  this_mtime = file_mtime (file);
+  check_renamed (file);
+  noexist = this_mtime == NONEXISTENT_MTIME;
+  if (noexist)
+    DBF (DB_BASIC, _("File '%s' does not exist.\n"));
+  else if (ORDINARY_MTIME_MIN <= this_mtime && this_mtime <= ORDINARY_MTIME_MAX
+           && file->low_resolution_time)
+    {
+      /* Avoid spurious rebuilds due to low resolution time stamps.  */
+      int ns = FILE_TIMESTAMP_NS (this_mtime);
+      if (ns != 0)
+        OS (error, NILF,
+            _("*** Warning: .LOW_RESOLUTION_TIME file '%s' has a high resolution time stamp"),
+            file->name);
+      this_mtime += FILE_TIMESTAMPS_PER_S - 1 - ns;
+    }
+
+  must_make = noexist;
+
+  /* If file was specified as a target with no commands,
+     come up with some default commands.  */
+
+  if (!file->phony && file->cmds == 0 && !file->tried_implicit)
+    {
+      if (try_implicit_rule (file, depth))
+        DBF (DB_IMPLICIT, _("Found an implicit rule for '%s'.\n"));
+      else
+        DBF (DB_IMPLICIT, _("No implicit rule found for '%s'.\n"));
+      file->tried_implicit = 1;
+    }
+  if (file->cmds == 0 && !file->is_target
+      && default_file != 0 && default_file->cmds != 0)
+    {
+      DBF (DB_IMPLICIT, _("Using default recipe for '%s'.\n"));
+      file->cmds = default_file->cmds;
+    }
+
+  /* Update all non-intermediate files we depend on, if necessary, and see
+     whether any of them is more recent than this file.  We need to walk our
+     deps, AND the deps of any also_make targets to ensure everything happens
+     in the correct order.  */
+
+  amake.file = file;
+  amake.next = file->also_make;
+  ad = &amake;
+  while (ad)
+    {
+      struct dep *lastd = 0;
+
+      /* Find the deps we're scanning */
+      d = ad->file->deps;
+      ad = ad->next;
+
+      while (d)
+        {
+          enum update_status new;
+          FILE_TIMESTAMP mtime;
+          int maybe_make;
+          int dontcare = 0;
+
+          check_renamed (d->file);
+
+          mtime = file_mtime (d->file);
+          check_renamed (d->file);
+
+          if (is_updating (d->file))
+            {
+              OSS (error, NILF, _("Circular %s <- %s dependency dropped."),
+                   file->name, d->file->name);
+              /* We cannot free D here because our the caller will still have
+                 a reference to it when we were called recursively via
+                 check_dep below.  */
+              if (lastd == 0)
+                file->deps = d->next;
+              else
+                lastd->next = d->next;
+              d = d->next;
+              continue;
+            }
+
+          d->file->parent = file;
+          maybe_make = must_make;
+
+          /* Inherit dontcare flag from our parent. */
+          if (rebuilding_makefiles)
+            {
+              dontcare = d->file->dontcare;
+              d->file->dontcare = file->dontcare;
+            }
+
+          new = check_dep (d->file, depth, this_mtime, &maybe_make);
+          if (new > dep_status)
+            dep_status = new;
+
+          /* Restore original dontcare flag. */
+          if (rebuilding_makefiles)
+            d->file->dontcare = dontcare;
+
+          if (! d->ignore_mtime)
+            must_make = maybe_make;
+
+          check_renamed (d->file);
+
+          {
+            struct file *f = d->file;
+            if (f->double_colon)
+              f = f->double_colon;
+            do
+              {
+                running |= (f->command_state == cs_running
+                            || f->command_state == cs_deps_running);
+                f = f->prev;
+              }
+            while (f != 0);
+          }
+
+          if (dep_status && !keep_going_flag)
+            break;
+
+          if (!running)
+            /* The prereq is considered changed if the timestamp has changed
+               while it was built, OR it doesn't exist.  */
+            d->changed = ((file_mtime (d->file) != mtime)
+                          || (mtime == NONEXISTENT_MTIME));
+
+          lastd = d;
+          d = d->next;
+        }
+    }
+
+  /* Now we know whether this target needs updating.
+     If it does, update all the intermediate files we depend on.  */
+
+  if (must_make || always_make_flag)
+    {
+      for (d = file->deps; d != 0; d = d->next)
+        if (d->file->intermediate)
+          {
+            enum update_status new;
+            int dontcare = 0;
+
+            FILE_TIMESTAMP mtime = file_mtime (d->file);
+            check_renamed (d->file);
+            d->file->parent = file;
+
+            /* Inherit dontcare flag from our parent. */
+            if (rebuilding_makefiles)
+              {
+                dontcare = d->file->dontcare;
+                d->file->dontcare = file->dontcare;
+              }
+
+            /* We may have already considered this file, when we didn't know
+               we'd need to update it.  Force update_file() to consider it and
+               not prune it.  */
+            d->file->considered = 0;
+
+            new = update_file (d->file, depth);
+            if (new > dep_status)
+              dep_status = new;
+
+            /* Restore original dontcare flag. */
+            if (rebuilding_makefiles)
+              d->file->dontcare = dontcare;
+
+            check_renamed (d->file);
+
+            {
+              struct file *f = d->file;
+              if (f->double_colon)
+                f = f->double_colon;
+              do
+                {
+                  running |= (f->command_state == cs_running
+                              || f->command_state == cs_deps_running);
+                  f = f->prev;
+                }
+              while (f != 0);
+            }
+
+            if (dep_status && !keep_going_flag)
+              break;
+
+            if (!running)
+              d->changed = ((file->phony && file->cmds != 0)
+                            || file_mtime (d->file) != mtime);
+          }
+    }
+
+  finish_updating (file);
+  finish_updating (ofile);
+
+  DBF (DB_VERBOSE, _("Finished prerequisites of target file '%s'.\n"));
+
+  if (running)
+    {
+      set_command_state (file, cs_deps_running);
+      --depth;
+      DBF (DB_VERBOSE, _("The prerequisites of '%s' are being made.\n"));
+      return 0;
+    }
+
+  /* If any dependency failed, give up now.  */
+
+  if (dep_status)
+    {
+      /* I'm not sure if we can't just assign dep_status...  */
+      file->update_status = dep_status == us_none ? us_failed : dep_status;
+      notice_finished_file (file);
+
+      --depth;
+
+      DBF (DB_VERBOSE, _("Giving up on target file '%s'.\n"));
+
+      if (depth == 0 && keep_going_flag
+          && !just_print_flag && !question_flag)
+        OS (error, NILF,
+            _("Target '%s' not remade because of errors."), file->name);
+
+      return dep_status;
+    }
+
+  if (file->command_state == cs_deps_running)
+    /* The commands for some deps were running on the last iteration, but
+       they have finished now.  Reset the command_state to not_started to
+       simplify later bookkeeping.  It is important that we do this only
+       when the prior state was cs_deps_running, because that prior state
+       was definitely propagated to FILE's also_make's by set_command_state
+       (called above), but in another state an also_make may have
+       independently changed to finished state, and we would confuse that
+       file's bookkeeping (updated, but not_started is bogus state).  */
+    set_command_state (file, cs_not_started);
+
+  /* Now record which prerequisites are more
+     recent than this file, so we can define $?.  */
+
+  deps_changed = 0;
+  for (d = file->deps; d != 0; d = d->next)
+    {
+      FILE_TIMESTAMP d_mtime = file_mtime (d->file);
+      check_renamed (d->file);
+
+      if (! d->ignore_mtime)
+        {
+#if 1
+          /* %%% In version 4, remove this code completely to
+           implement not remaking deps if their deps are newer
+           than their parents.  */
+          if (d_mtime == NONEXISTENT_MTIME && !d->file->intermediate)
+            /* We must remake if this dep does not
+               exist and is not intermediate.  */
+            must_make = 1;
+#endif
+
+          /* Set DEPS_CHANGED if this dep actually changed.  */
+          deps_changed |= d->changed;
+        }
+
+      /* Set D->changed if either this dep actually changed,
+         or its dependent, FILE, is older or does not exist.  */
+      d->changed |= noexist || d_mtime > this_mtime;
+
+      if (!noexist && ISDB (DB_BASIC|DB_VERBOSE))
+        {
+          const char *fmt = 0;
+
+          if (d->ignore_mtime)
+            {
+              if (ISDB (DB_VERBOSE))
+                fmt = _("Prerequisite '%s' is order-only for target '%s'.\n");
+            }
+          else if (d_mtime == NONEXISTENT_MTIME)
+            {
+              if (ISDB (DB_BASIC))
+                fmt = _("Prerequisite '%s' of target '%s' does not exist.\n");
+            }
+          else if (d->changed)
+            {
+              if (ISDB (DB_BASIC))
+                fmt = _("Prerequisite '%s' is newer than target '%s'.\n");
+            }
+          else if (ISDB (DB_VERBOSE))
+            fmt = _("Prerequisite '%s' is older than target '%s'.\n");
+
+          if (fmt)
+            {
+              print_spaces (depth);
+              printf (fmt, dep_name (d), file->name);
+              fflush (stdout);
+            }
+        }
+    }
+
+  /* Here depth returns to the value it had when we were called.  */
+  depth--;
+
+  if (file->double_colon && file->deps == 0)
+    {
+      must_make = 1;
+      DBF (DB_BASIC,
+           _("Target '%s' is double-colon and has no prerequisites.\n"));
+    }
+  else if (!noexist && file->is_target && !deps_changed && file->cmds == 0
+           && !always_make_flag)
+    {
+      must_make = 0;
+      DBF (DB_VERBOSE,
+           _("No recipe for '%s' and no prerequisites actually changed.\n"));
+    }
+  else if (!must_make && file->cmds != 0 && always_make_flag)
+    {
+      must_make = 1;
+      DBF (DB_VERBOSE, _("Making '%s' due to always-make flag.\n"));
+    }
+
+  if (!must_make)
+    {
+      if (ISDB (DB_VERBOSE))
+        {
+          print_spaces (depth);
+          printf (_("No need to remake target '%s'"), file->name);
+          if (!streq (file->name, file->hname))
+              printf (_("; using VPATH name '%s'"), file->hname);
+          puts (".");
+          fflush (stdout);
+        }
+
+      notice_finished_file (file);
+
+      /* Since we don't need to remake the file, convert it to use the
+         VPATH filename if we found one.  hfile will be either the
+         local name if no VPATH or the VPATH name if one was found.  */
+
+      while (file)
+        {
+          file->name = file->hname;
+          file = file->prev;
+        }
+
+      return 0;
+    }
+
+  DBF (DB_BASIC, _("Must remake target '%s'.\n"));
+
+  /* It needs to be remade.  If it's VPATH and not reset via GPATH, toss the
+     VPATH.  */
+  if (!streq (file->name, file->hname))
+    {
+      DB (DB_BASIC, (_("  Ignoring VPATH name '%s'.\n"), file->hname));
+      file->ignore_vpath = 1;
+    }
+
+  /* Now, take appropriate actions to remake the file.  */
+  remake_file (file);
+
+  if (file->command_state != cs_finished)
+    {
+      DBF (DB_VERBOSE, _("Recipe of '%s' is being run.\n"));
+      return 0;
+    }
+
+  switch (file->update_status)
+    {
+    case us_failed:
+      DBF (DB_BASIC, _("Failed to remake target file '%s'.\n"));
+      break;
+    case us_success:
+      DBF (DB_BASIC, _("Successfully remade target file '%s'.\n"));
+      break;
+    case us_question:
+      DBF (DB_BASIC, _("Target file '%s' needs to be remade under -q.\n"));
+      break;
+    case us_none:
+      break;
+    }
+
+  file->updated = 1;
+  return file->update_status;
+}
+
+/* Set FILE's 'updated' flag and re-check its mtime and the mtime's of all
+   files listed in its 'also_make' member.  Under -t, this function also
+   touches FILE.
+
+   On return, FILE->update_status will no longer be us_none if it was.  */
+
+void
+notice_finished_file (struct file *file)
+{
+  struct dep *d;
+  int ran = file->command_state == cs_running;
+  int touched = 0;
+
+  file->command_state = cs_finished;
+  file->updated = 1;
+
+  if (touch_flag
+      /* The update status will be:
+           us_success   if 0 or more commands (+ or ${MAKE}) were run and won;
+           us_none      if this target was not remade;
+           >us_none     if some commands were run and lost.
+         We touch the target if it has commands which either were not run
+         or won when they ran (i.e. status is 0).  */
+      && file->update_status == us_success)
+    {
+      if (file->cmds != 0 && file->cmds->any_recurse)
+        {
+          /* If all the command lines were recursive,
+             we don't want to do the touching.  */
+          unsigned int i;
+          for (i = 0; i < file->cmds->ncommand_lines; ++i)
+            if (!(file->cmds->lines_flags[i] & COMMANDS_RECURSE))
+              goto have_nonrecursing;
+        }
+      else
+        {
+        have_nonrecursing:
+          if (file->phony)
+            file->update_status = us_success;
+          /* According to POSIX, -t doesn't affect targets with no cmds.  */
+          else if (file->cmds != 0)
+            {
+              /* Should set file's modification date and do nothing else.  */
+              file->update_status = touch_file (file);
+
+              /* Pretend we ran a real touch command, to suppress the
+                 "'foo' is up to date" message.  */
+              commands_started++;
+
+              /* Request for the timestamp to be updated (and distributed
+                 to the double-colon entries). Simply setting ran=1 would
+                 almost have done the trick, but messes up with the also_make
+                 updating logic below.  */
+              touched = 1;
+            }
+        }
+    }
+
+  if (file->mtime_before_update == UNKNOWN_MTIME)
+    file->mtime_before_update = file->last_mtime;
+
+  if ((ran && !file->phony) || touched)
+    {
+      int i = 0;
+
+      /* If -n, -t, or -q and all the commands are recursive, we ran them so
+         really check the target's mtime again.  Otherwise, assume the target
+         would have been updated. */
+
+      if ((question_flag || just_print_flag || touch_flag) && file->cmds)
+        {
+          for (i = file->cmds->ncommand_lines; i > 0; --i)
+            if (! (file->cmds->lines_flags[i-1] & COMMANDS_RECURSE))
+              break;
+        }
+
+      /* If there were no commands at all, it's always new. */
+
+      else if (file->is_target && file->cmds == 0)
+        i = 1;
+
+      file->last_mtime = i == 0 ? UNKNOWN_MTIME : NEW_MTIME;
+    }
+
+  if (file->double_colon)
+    {
+      /* If this is a double colon rule and it is the last one to be
+         updated, propagate the change of modification time to all the
+         double-colon entries for this file.
+
+         We do it on the last update because it is important to handle
+         individual entries as separate rules with separate timestamps
+         while they are treated as targets and then as one rule with the
+         unified timestamp when they are considered as a prerequisite
+         of some target.  */
+
+      struct file *f;
+      FILE_TIMESTAMP max_mtime = file->last_mtime;
+
+      /* Check that all rules were updated and at the same time find
+         the max timestamp.  We assume UNKNOWN_MTIME is newer then
+         any other value.  */
+      for (f = file->double_colon; f != 0 && f->updated; f = f->prev)
+        if (max_mtime != UNKNOWN_MTIME
+            && (f->last_mtime == UNKNOWN_MTIME || f->last_mtime > max_mtime))
+          max_mtime = f->last_mtime;
+
+      if (f == 0)
+        for (f = file->double_colon; f != 0; f = f->prev)
+          f->last_mtime = max_mtime;
+    }
+
+  if (ran && file->update_status != us_none)
+    /* We actually tried to update FILE, which has
+       updated its also_make's as well (if it worked).
+       If it didn't work, it wouldn't work again for them.
+       So mark them as updated with the same status.  */
+    for (d = file->also_make; d != 0; d = d->next)
+      {
+        d->file->command_state = cs_finished;
+        d->file->updated = 1;
+        d->file->update_status = file->update_status;
+
+        if (ran && !d->file->phony)
+          /* Fetch the new modification time.
+             We do this instead of just invalidating the cached time
+             so that a vpath_search can happen.  Otherwise, it would
+             never be done because the target is already updated.  */
+          f_mtime (d->file, 0);
+      }
+  else if (file->update_status == us_none)
+    /* Nothing was done for FILE, but it needed nothing done.
+       So mark it now as "succeeded".  */
+    file->update_status = us_success;
+}
+
+/* Check whether another file (whose mtime is THIS_MTIME) needs updating on
+   account of a dependency which is file FILE.  If it does, store 1 in
+   *MUST_MAKE_PTR.  In the process, update any non-intermediate files that
+   FILE depends on (including FILE itself).  Return nonzero if any updating
+   failed.  */
+
+static enum update_status
+check_dep (struct file *file, unsigned int depth,
+           FILE_TIMESTAMP this_mtime, int *must_make_ptr)
+{
+  struct file *ofile;
+  struct dep *d;
+  enum update_status dep_status = us_success;
+
+  ++depth;
+  start_updating (file);
+
+  /* We might change file if we find a different one via vpath;
+     remember this one to turn off updating.  */
+  ofile = file;
+
+  if (file->phony || !file->intermediate)
+    {
+      /* If this is a non-intermediate file, update it and record whether it
+         is newer than THIS_MTIME.  */
+      FILE_TIMESTAMP mtime;
+      dep_status = update_file (file, depth);
+      check_renamed (file);
+      mtime = file_mtime (file);
+      check_renamed (file);
+      if (mtime == NONEXISTENT_MTIME || mtime > this_mtime)
+        *must_make_ptr = 1;
+    }
+  else
+    {
+      /* FILE is an intermediate file.  */
+      FILE_TIMESTAMP mtime;
+
+      if (!file->phony && file->cmds == 0 && !file->tried_implicit)
+        {
+          if (try_implicit_rule (file, depth))
+            DBF (DB_IMPLICIT, _("Found an implicit rule for '%s'.\n"));
+          else
+            DBF (DB_IMPLICIT, _("No implicit rule found for '%s'.\n"));
+          file->tried_implicit = 1;
+        }
+      if (file->cmds == 0 && !file->is_target
+          && default_file != 0 && default_file->cmds != 0)
+        {
+          DBF (DB_IMPLICIT, _("Using default commands for '%s'.\n"));
+          file->cmds = default_file->cmds;
+        }
+
+      check_renamed (file);
+      mtime = file_mtime (file);
+      check_renamed (file);
+      if (mtime != NONEXISTENT_MTIME && mtime > this_mtime)
+        /* If the intermediate file actually exists and is newer, then we
+           should remake from it.  */
+        *must_make_ptr = 1;
+      else
+        {
+          /* Otherwise, update all non-intermediate files we depend on, if
+             necessary, and see whether any of them is more recent than the
+             file on whose behalf we are checking.  */
+          struct dep *ld;
+          int deps_running = 0;
+
+          /* If this target is not running, set it's state so that we check it
+             fresh.  It could be it was checked as part of an order-only
+             prerequisite and so wasn't rebuilt then, but should be now.  */
+          if (file->command_state != cs_running)
+            {
+              /* If the target was waiting for a dependency it has to be
+                 reconsidered, as that dependency might have finished.  */
+              if (file->command_state == cs_deps_running)
+                file->considered = 0;
+
+              set_command_state (file, cs_not_started);
+            }
+
+          ld = 0;
+          d = file->deps;
+          while (d != 0)
+            {
+              enum update_status new;
+              int maybe_make;
+
+              if (is_updating (d->file))
+                {
+                  OSS (error, NILF, _("Circular %s <- %s dependency dropped."),
+                       file->name, d->file->name);
+                  if (ld == 0)
+                    {
+                      file->deps = d->next;
+                      free_dep (d);
+                      d = file->deps;
+                    }
+                  else
+                    {
+                      ld->next = d->next;
+                      free_dep (d);
+                      d = ld->next;
+                    }
+                  continue;
+                }
+
+              d->file->parent = file;
+              maybe_make = *must_make_ptr;
+              new = check_dep (d->file, depth, this_mtime, &maybe_make);
+              if (new > dep_status)
+                dep_status = new;
+
+              if (! d->ignore_mtime)
+                *must_make_ptr = maybe_make;
+              check_renamed (d->file);
+              if (dep_status && !keep_going_flag)
+                break;
+
+              if (d->file->command_state == cs_running
+                  || d->file->command_state == cs_deps_running)
+                deps_running = 1;
+
+              ld = d;
+              d = d->next;
+            }
+
+          if (deps_running)
+            /* Record that some of FILE's deps are still being made.
+               This tells the upper levels to wait on processing it until the
+               commands are finished.  */
+            set_command_state (file, cs_deps_running);
+        }
+    }
+
+  finish_updating (file);
+  finish_updating (ofile);
+
+  return dep_status;
+}
+
+/* Touch FILE.  Return us_success if successful, us_failed if not.  */
+
+#define TOUCH_ERROR(call) do{ perror_with_name ((call), file->name);    \
+                              return us_failed; }while(0)
+
+static enum update_status
+touch_file (struct file *file)
+{
+  if (!silent_flag)
+    OS (message, 0, "touch %s", file->name);
+
+  /* Print-only (-n) takes precedence over touch (-t).  */
+  if (just_print_flag)
+    return us_success;
+
+#ifndef NO_ARCHIVES
+  if (ar_name (file->name))
+    return ar_touch (file->name) ? us_failed : us_success;
+  else
+#endif
+    {
+      int fd;
+
+      EINTRLOOP (fd, open (file->name, O_RDWR | O_CREAT, 0666));
+      if (fd < 0)
+        TOUCH_ERROR ("touch: open: ");
+      else
+        {
+          struct stat statbuf;
+          char buf = 'x';
+          int e;
+
+          EINTRLOOP (e, fstat (fd, &statbuf));
+          if (e < 0)
+            TOUCH_ERROR ("touch: fstat: ");
+          /* Rewrite character 0 same as it already is.  */
+          EINTRLOOP (e, read (fd, &buf, 1));
+          if (e < 0)
+            TOUCH_ERROR ("touch: read: ");
+          {
+            off_t o;
+            EINTRLOOP (o, lseek (fd, 0L, 0));
+            if (o < 0L)
+              TOUCH_ERROR ("touch: lseek: ");
+          }
+          EINTRLOOP (e, write (fd, &buf, 1));
+          if (e < 0)
+            TOUCH_ERROR ("touch: write: ");
+
+          /* If file length was 0, we just changed it, so change it back.  */
+          if (statbuf.st_size == 0)
+            {
+              (void) close (fd);
+              EINTRLOOP (fd, open (file->name, O_RDWR | O_TRUNC, 0666));
+              if (fd < 0)
+                TOUCH_ERROR ("touch: open: ");
+            }
+          (void) close (fd);
+        }
+    }
+
+  return us_success;
+}
+
+/* Having checked and updated the dependencies of FILE,
+   do whatever is appropriate to remake FILE itself.
+   Return the status from executing FILE's commands.  */
+
+static void
+remake_file (struct file *file)
+{
+  if (file->cmds == 0)
+    {
+      if (file->phony)
+        /* Phony target.  Pretend it succeeded.  */
+        file->update_status = us_success;
+      else if (file->is_target)
+        /* This is a nonexistent target file we cannot make.
+           Pretend it was successfully remade.  */
+        file->update_status = us_success;
+      else
+        {
+          /* This is a dependency file we cannot remake.  Fail.  */
+          if (!rebuilding_makefiles || !file->dontcare)
+            complain (file);
+          file->update_status = us_failed;
+        }
+    }
+  else
+    {
+      chop_commands (file->cmds);
+
+      /* The normal case: start some commands.  */
+      if (!touch_flag || file->cmds->any_recurse)
+        {
+          execute_file_commands (file);
+          return;
+        }
+
+      /* This tells notice_finished_file it is ok to touch the file.  */
+      file->update_status = us_success;
+    }
+
+  /* This does the touching under -t.  */
+  notice_finished_file (file);
+}
+
+/* Return the mtime of a file, given a 'struct file'.
+   Caches the time in the struct file to avoid excess stat calls.
+
+   If the file is not found, and SEARCH is nonzero, VPATH searching and
+   replacement is done.  If that fails, a library (-lLIBNAME) is tried and
+   the library's actual name (/lib/libLIBNAME.a, etc.) is substituted into
+   FILE.  */
+
+FILE_TIMESTAMP
+f_mtime (struct file *file, int search)
+{
+  FILE_TIMESTAMP mtime;
+  int propagate_timestamp;
+
+  /* File's mtime is not known; must get it from the system.  */
+
+#ifndef NO_ARCHIVES
+  if (ar_name (file->name))
+    {
+      /* This file is an archive-member reference.  */
+
+      char *arname, *memname;
+      struct file *arfile;
+      time_t member_date;
+
+      /* Find the archive's name.  */
+      ar_parse_name (file->name, &arname, &memname);
+
+      /* Find the modification time of the archive itself.
+         Also allow for its name to be changed via VPATH search.  */
+      arfile = lookup_file (arname);
+      if (arfile == 0)
+        arfile = enter_file (strcache_add (arname));
+      mtime = f_mtime (arfile, search);
+      check_renamed (arfile);
+      if (search && strcmp (arfile->hname, arname))
+        {
+          /* The archive's name has changed.
+             Change the archive-member reference accordingly.  */
+
+          char *name;
+          unsigned int arlen, memlen;
+
+          arlen = strlen (arfile->hname);
+          memlen = strlen (memname);
+
+          name = alloca (arlen + 1 + memlen + 2);
+          memcpy (name, arfile->hname, arlen);
+          name[arlen] = '(';
+          memcpy (name + arlen + 1, memname, memlen);
+          name[arlen + 1 + memlen] = ')';
+          name[arlen + 1 + memlen + 1] = '\0';
+
+          /* If the archive was found with GPATH, make the change permanent;
+             otherwise defer it until later.  */
+          if (arfile->name == arfile->hname)
+            rename_file (file, strcache_add (name));
+          else
+            rehash_file (file, strcache_add (name));
+          check_renamed (file);
+        }
+
+      free (arname);
+
+      file->low_resolution_time = 1;
+
+      if (mtime == NONEXISTENT_MTIME)
+        /* The archive doesn't exist, so its members don't exist either.  */
+        return NONEXISTENT_MTIME;
+
+      member_date = ar_member_date (file->hname);
+      mtime = (member_date == (time_t) -1
+               ? NONEXISTENT_MTIME
+               : file_timestamp_cons (file->hname, member_date, 0));
+    }
+  else
+#endif
+    {
+      mtime = name_mtime (file->name);
+
+      if (mtime == NONEXISTENT_MTIME && search && !file->ignore_vpath)
+        {
+          /* If name_mtime failed, search VPATH.  */
+          const char *name = vpath_search (file->name, &mtime, NULL, NULL);
+          if (name
+              /* Last resort, is it a library (-lxxx)?  */
+              || (file->name[0] == '-' && file->name[1] == 'l'
+                  && (name = library_search (file->name, &mtime)) != 0))
+            {
+              int name_len;
+
+              if (mtime != UNKNOWN_MTIME)
+                /* vpath_search and library_search store UNKNOWN_MTIME
+                   if they didn't need to do a stat call for their work.  */
+                file->last_mtime = mtime;
+
+              /* If we found it in VPATH, see if it's in GPATH too; if so,
+                 change the name right now; if not, defer until after the
+                 dependencies are updated. */
+#ifndef VMS
+              name_len = strlen (name) - strlen (file->name) - 1;
+#else
+              name_len = strlen (name) - strlen (file->name);
+              if (name[name_len - 1] == '/')
+                  name_len--;
+#endif
+              if (gpath_search (name, name_len))
+                {
+                  rename_file (file, name);
+                  check_renamed (file);
+                  return file_mtime (file);
+                }
+
+              rehash_file (file, name);
+              check_renamed (file);
+              /* If the result of a vpath search is -o or -W, preserve it.
+                 Otherwise, find the mtime of the resulting file.  */
+              if (mtime != OLD_MTIME && mtime != NEW_MTIME)
+                mtime = name_mtime (name);
+            }
+        }
+    }
+
+  /* Files can have bogus timestamps that nothing newly made will be
+     "newer" than.  Updating their dependents could just result in loops.
+     So notify the user of the anomaly with a warning.
+
+     We only need to do this once, for now. */
+
+  if (!clock_skew_detected
+      && mtime != NONEXISTENT_MTIME && mtime != NEW_MTIME
+      && !file->updated)
+    {
+      static FILE_TIMESTAMP adjusted_now;
+
+      FILE_TIMESTAMP adjusted_mtime = mtime;
+
+#if defined(WINDOWS32) || defined(__MSDOS__)
+      /* Experimentation has shown that FAT filesystems can set file times
+         up to 3 seconds into the future!  Play it safe.  */
+
+#define FAT_ADJ_OFFSET  (FILE_TIMESTAMP) 3
+
+      FILE_TIMESTAMP adjustment = FAT_ADJ_OFFSET << FILE_TIMESTAMP_LO_BITS;
+      if (ORDINARY_MTIME_MIN + adjustment <= adjusted_mtime)
+        adjusted_mtime -= adjustment;
+#elif defined(__EMX__)
+      /* FAT filesystems round time to the nearest even second!
+         Allow for any file (NTFS or FAT) to perhaps suffer from this
+         brain damage.  */
+      FILE_TIMESTAMP adjustment = (((FILE_TIMESTAMP_S (adjusted_mtime) & 1) == 0
+                     && FILE_TIMESTAMP_NS (adjusted_mtime) == 0)
+                    ? (FILE_TIMESTAMP) 1 << FILE_TIMESTAMP_LO_BITS
+                    : 0);
+#endif
+
+      /* If the file's time appears to be in the future, update our
+         concept of the present and try once more.  */
+      if (adjusted_now < adjusted_mtime)
+        {
+          int resolution;
+          FILE_TIMESTAMP now = file_timestamp_now (&resolution);
+          adjusted_now = now + (resolution - 1);
+          if (adjusted_now < adjusted_mtime)
+            {
+              double from_now =
+                (FILE_TIMESTAMP_S (mtime) - FILE_TIMESTAMP_S (now)
+                 + ((FILE_TIMESTAMP_NS (mtime) - FILE_TIMESTAMP_NS (now))
+                    / 1e9));
+              char from_now_string[100];
+
+              if (from_now >= 99 && from_now <= ULONG_MAX)
+                sprintf (from_now_string, "%lu", (unsigned long) from_now);
+              else
+                sprintf (from_now_string, "%.2g", from_now);
+              OSS (error, NILF,
+                   _("Warning: File '%s' has modification time %s s in the future"),
+                   file->name, from_now_string);
+              clock_skew_detected = 1;
+            }
+        }
+    }
+
+  /* Store the mtime into all the entries for this file for which it is safe
+     to do so: avoid propagating timestamps to double-colon rules that haven't
+     been examined so they're run or not based on the pre-update timestamp.  */
+  if (file->double_colon)
+    file = file->double_colon;
+
+  propagate_timestamp = file->updated;
+  do
+    {
+      /* If this file is not implicit but it is intermediate then it was
+         made so by the .INTERMEDIATE target.  If this file has never
+         been built by us but was found now, it existed before make
+         started.  So, turn off the intermediate bit so make doesn't
+         delete it, since it didn't create it.  */
+      if (mtime != NONEXISTENT_MTIME && file->command_state == cs_not_started
+          && !file->tried_implicit && file->intermediate)
+        file->intermediate = 0;
+
+      if (file->updated == propagate_timestamp)
+        file->last_mtime = mtime;
+      file = file->prev;
+    }
+  while (file != 0);
+
+  return mtime;
+}
+
+
+/* Return the mtime of the file or archive-member reference NAME.  */
+
+/* First, we check with stat().  If the file does not exist, then we return
+   NONEXISTENT_MTIME.  If it does, and the symlink check flag is set, then
+   examine each indirection of the symlink and find the newest mtime.
+   This causes one duplicate stat() when -L is being used, but the code is
+   much cleaner.  */
+
+static FILE_TIMESTAMP
+name_mtime (const char *name)
+{
+  FILE_TIMESTAMP mtime;
+  struct stat st;
+  int e;
+
+#if defined(WINDOWS32)
+  {
+    char tem[MAXPATHLEN], *tstart, *tend;
+    const char *p = name + strlen (name);
+
+    /* Remove any trailing slashes and "."/"..".  MS-Windows stat
+       fails on valid directories if NAME ends in a slash, and we need
+       to emulate the Posix behavior where stat on "foo/" or "foo/."
+       succeeds ONLY if "foo" is a directory. */
+    if (p > name)
+      {
+	memcpy (tem, name, p - name + 1);
+	tstart = tem;
+	if (tstart[1] == ':')
+	  tstart += 2;
+	tend = tem + (p - name - 1);
+	if (*tend == '.' && tend > tstart)
+	  tend--;
+	if (*tend == '.' && tend > tstart)
+	  tend--;
+	for ( ; tend > tstart && (*tend == '/' || *tend == '\\'); tend--)
+	  *tend = '\0';
+      }
+    else
+      {
+	tem[0] = '\0';
+	tend = &tem[0];
+      }
+
+    e = stat (tem, &st);
+    if (e == 0 && !_S_ISDIR (st.st_mode) && tend < tem + (p - name - 1))
+      {
+	errno = ENOTDIR;
+	e = -1;
+      }
+  }
+#else
+  EINTRLOOP (e, stat (name, &st));
+#endif
+  if (e == 0)
+    mtime = FILE_TIMESTAMP_STAT_MODTIME (name, st);
+  else if (errno == ENOENT || errno == ENOTDIR)
+    mtime = NONEXISTENT_MTIME;
+  else
+    {
+      perror_with_name ("stat: ", name);
+      return NONEXISTENT_MTIME;
+    }
+
+  /* If we get here we either found it, or it doesn't exist.
+     If it doesn't exist see if we can use a symlink mtime instead.  */
+
+#ifdef MAKE_SYMLINKS
+#ifndef S_ISLNK
+# define S_ISLNK(_m)     (((_m)&S_IFMT)==S_IFLNK)
+#endif
+  if (check_symlink_flag && strlen (name) <= GET_PATH_MAX)
+    {
+      PATH_VAR (lpath);
+
+      /* Check each symbolic link segment (if any).  Find the latest mtime
+         amongst all of them (and the target file of course).
+         Note that we have already successfully dereferenced all the links
+         above.  So, if we run into any error trying to lstat(), or
+         readlink(), or whatever, something bizarre-o happened.  Just give up
+         and use whatever mtime we've already computed at that point.  */
+      strcpy (lpath, name);
+      while (1)
+        {
+          FILE_TIMESTAMP ltime;
+          PATH_VAR (lbuf);
+          long llen;
+          char *p;
+
+          EINTRLOOP (e, lstat (lpath, &st));
+          if (e)
+            {
+              /* Just take what we have so far.  */
+              if (errno != ENOENT && errno != ENOTDIR)
+                perror_with_name ("lstat: ", lpath);
+              break;
+            }
+
+          /* If this is not a symlink, we're done (we started with the real
+             file's mtime so we don't need to test it again).  */
+          if (!S_ISLNK (st.st_mode))
+            break;
+
+          /* If this mtime is newer than what we had, keep the new one.  */
+          ltime = FILE_TIMESTAMP_STAT_MODTIME (lpath, st);
+          if (ltime > mtime)
+            mtime = ltime;
+
+          /* Set up to check the file pointed to by this link.  */
+          EINTRLOOP (llen, readlink (lpath, lbuf, GET_PATH_MAX));
+          if (llen < 0)
+            {
+              /* Eh?  Just take what we have.  */
+              perror_with_name ("readlink: ", lpath);
+              break;
+            }
+          lbuf[llen] = '\0';
+
+          /* If the target is fully-qualified or the source is just a
+             filename, then the new path is the target.  Otherwise it's the
+             source directory plus the target.  */
+          if (lbuf[0] == '/' || (p = strrchr (lpath, '/')) == NULL)
+            strcpy (lpath, lbuf);
+          else if ((p - lpath) + llen + 2 > GET_PATH_MAX)
+            /* Eh?  Path too long!  Again, just go with what we have.  */
+            break;
+          else
+            /* Create the next step in the symlink chain.  */
+            strcpy (p+1, lbuf);
+        }
+    }
+#endif
+
+  return mtime;
+}
+
+
+/* Search for a library file specified as -lLIBNAME, searching for a
+   suitable library file in the system library directories and the VPATH
+   directories.  */
+
+static const char *
+library_search (const char *lib, FILE_TIMESTAMP *mtime_ptr)
+{
+  static const char *dirs[] =
+    {
+#ifndef _AMIGA
+      "/lib",
+      "/usr/lib",
+#endif
+#if defined(WINDOWS32) && !defined(LIBDIR)
+/*
+ * This is completely up to the user at product install time. Just define
+ * a placeholder.
+ */
+#define LIBDIR "."
+#endif
+      LIBDIR,                   /* Defined by configuration.  */
+      0
+    };
+
+  const char *file = 0;
+  char *libpatterns;
+  FILE_TIMESTAMP mtime;
+
+  /* Loop variables for the libpatterns value.  */
+  char *p;
+  const char *p2;
+  unsigned int len;
+  unsigned int liblen;
+
+  /* Information about the earliest (in the vpath sequence) match.  */
+  unsigned int best_vpath = 0, best_path = 0;
+
+  const char **dp;
+
+  libpatterns = xstrdup (variable_expand ("$(.LIBPATTERNS)"));
+
+  /* Skip the '-l'.  */
+  lib += 2;
+  liblen = strlen (lib);
+
+  /* Loop through all the patterns in .LIBPATTERNS, and search on each one.
+     To implement the linker-compatible behavior we have to search through
+     all entries in .LIBPATTERNS and choose the "earliest" one.  */
+  p2 = libpatterns;
+  while ((p = find_next_token (&p2, &len)) != 0)
+    {
+      static char *buf = NULL;
+      static unsigned int buflen = 0;
+      static int libdir_maxlen = -1;
+      static unsigned int std_dirs = 0;
+      char *libbuf = variable_expand ("");
+
+      /* Expand the pattern using LIB as a replacement.  */
+      {
+        char c = p[len];
+        char *p3, *p4;
+
+        p[len] = '\0';
+        p3 = find_percent (p);
+        if (!p3)
+          {
+            /* Give a warning if there is no pattern.  */
+            OS (error, NILF,
+                _(".LIBPATTERNS element '%s' is not a pattern"), p);
+            p[len] = c;
+            continue;
+          }
+        p4 = variable_buffer_output (libbuf, p, p3-p);
+        p4 = variable_buffer_output (p4, lib, liblen);
+        p4 = variable_buffer_output (p4, p3+1, len - (p3-p));
+        p[len] = c;
+      }
+
+      /* Look first for 'libNAME.a' in the current directory.  */
+      mtime = name_mtime (libbuf);
+      if (mtime != NONEXISTENT_MTIME)
+        {
+          if (mtime_ptr != 0)
+            *mtime_ptr = mtime;
+          file = strcache_add (libbuf);
+          /* This by definition will have the best index, so stop now.  */
+          break;
+        }
+
+      /* Now try VPATH search on that.  */
+
+      {
+        unsigned int vpath_index, path_index;
+        const char* f = vpath_search (libbuf, mtime_ptr ? &mtime : NULL,
+                                      &vpath_index, &path_index);
+        if (f)
+          {
+            /* If we have a better match, record it.  */
+            if (file == 0 ||
+                vpath_index < best_vpath ||
+                (vpath_index == best_vpath && path_index < best_path))
+              {
+                file = f;
+                best_vpath = vpath_index;
+                best_path = path_index;
+
+                if (mtime_ptr != 0)
+                  *mtime_ptr = mtime;
+              }
+          }
+      }
+
+      /* Now try the standard set of directories.  */
+
+      if (!buflen)
+        {
+          for (dp = dirs; *dp != 0; ++dp)
+            {
+              int l = strlen (*dp);
+              if (l > libdir_maxlen)
+                libdir_maxlen = l;
+              std_dirs++;
+            }
+          buflen = strlen (libbuf);
+          buf = xmalloc (libdir_maxlen + buflen + 2);
+        }
+      else if (buflen < strlen (libbuf))
+        {
+          buflen = strlen (libbuf);
+          buf = xrealloc (buf, libdir_maxlen + buflen + 2);
+        }
+
+      {
+        /* Use the last std_dirs index for standard directories. This
+           was it will always be greater than the VPATH index.  */
+        unsigned int vpath_index = ~((unsigned int)0) - std_dirs;
+
+        for (dp = dirs; *dp != 0; ++dp)
+          {
+            sprintf (buf, "%s/%s", *dp, libbuf);
+            mtime = name_mtime (buf);
+            if (mtime != NONEXISTENT_MTIME)
+              {
+                if (file == 0 || vpath_index < best_vpath)
+                  {
+                    file = strcache_add (buf);
+                    best_vpath = vpath_index;
+
+                    if (mtime_ptr != 0)
+                      *mtime_ptr = mtime;
+                  }
+              }
+
+            vpath_index++;
+          }
+      }
+
+    }
+
+  free (libpatterns);
+  return file;
+}
diff --git a/src/remote-cstms.c b/src/remote-cstms.c
new file mode 100644
index 0000000..dea0276
--- /dev/null
+++ b/src/remote-cstms.c
@@ -0,0 +1,300 @@
+/* GNU Make remote job exportation interface to the Customs daemon.
+   THIS CODE IS NOT SUPPORTED BY THE GNU PROJECT.
+   Please do not send bug reports or questions about it to
+   the Make maintainers.
+
+Copyright (C) 1988-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+#include "filedef.h"
+#include "commands.h"
+#include "job.h"
+#include "debug.h"
+
+#include <sys/time.h>
+#include <netdb.h>
+
+#include "customs.h"
+
+char *remote_description = "Customs";
+
+/* File name of the Customs 'export' client command.
+   A full path name can be used to avoid some path-searching overhead.  */
+#define EXPORT_COMMAND  "/usr/local/bin/export"
+
+/* ExportPermit gotten by start_remote_job_p, and used by start_remote_job.  */
+static ExportPermit permit;
+
+/* Normalized path name of the current directory.  */
+static char *normalized_cwd;
+
+/* Call once at startup even if no commands are run.  */
+
+void
+remote_setup (void)
+{
+}
+
+/* Called before exit.  */
+
+void
+remote_cleanup (void)
+{
+}
+
+/* Return nonzero if the next job should be done remotely.  */
+
+int
+start_remote_job_p (int first_p)
+{
+  static int inited = 0;
+  int status;
+  int njobs;
+
+  if (!inited)
+    {
+      /* Allow the user to turn off job exportation (useful while he is
+         debugging Customs, for example).  */
+      if (getenv ("GNU_MAKE_NO_CUSTOMS") != 0)
+        {
+          inited = -1;
+          return 0;
+        }
+
+      /* For secure Customs, make is installed setuid root and
+         Customs requires a privileged source port be used.  */
+      make_access ();
+
+      if (ISDB (DB_JOBS))
+        Rpc_Debug (1);
+
+      /* Ping the daemon once to see if it is there.  */
+      inited = Customs_Ping () == RPC_SUCCESS ? 1 : -1;
+
+      /* Return to normal user access.  */
+      user_access ();
+
+      if (starting_directory == 0)
+        /* main couldn't figure it out.  */
+        inited = -1;
+      else
+        {
+          /* Normalize the current directory path name to something
+             that should work on all machines exported to.  */
+
+          normalized_cwd = xmalloc (GET_PATH_MAX);
+          strcpy (normalized_cwd, starting_directory);
+          if (Customs_NormPath (normalized_cwd, GET_PATH_MAX) < 0)
+            /* Path normalization failure means using Customs
+               won't work, but it's not really an error.  */
+            inited = -1;
+        }
+    }
+
+  if (inited < 0)
+    return 0;
+
+  njobs = job_slots_used;
+  if (!first_p)
+    njobs -= 1;         /* correction for being called from reap_children() */
+
+  /* the first job should run locally, or, if the -l flag is given, we use
+     that as clue as to how many local jobs should be scheduled locally */
+  if (max_load_average < 0 && njobs == 0 || njobs < max_load_average)
+     return 0;
+
+  status = Customs_Host (EXPORT_SAME, &permit);
+  if (status != RPC_SUCCESS)
+    {
+      DB (DB_JOBS, (_("Customs won't export: %s\n"),
+                    Rpc_ErrorMessage (status)));
+      return 0;
+    }
+
+  return !CUSTOMS_FAIL (&permit.addr);
+}
+
+/* Start a remote job running the command in ARGV, with environment from
+   ENVP.  It gets standard input from STDIN_FD.  On failure, return
+   nonzero.  On success, return zero, and set *USED_STDIN to nonzero if it
+   will actually use STDIN_FD, zero if not, set *ID_PTR to a unique
+   identification, and set *IS_REMOTE to nonzero if the job is remote, zero
+   if it is local (meaning *ID_PTR is a process ID).  */
+
+int
+start_remote_job (char **argv, char **envp, int stdin_fd,
+                  int *is_remote, int *id_ptr, int *used_stdin)
+{
+  char waybill[MAX_DATA_SIZE], msg[128];
+  struct hostent *host;
+  struct timeval timeout;
+  struct sockaddr_in sin;
+  int len;
+  int retsock, retport, sock;
+  Rpc_Stat status;
+  int pid;
+
+  /* Create the return socket.  */
+  retsock = Rpc_UdpCreate (True, 0);
+  if (retsock < 0)
+    {
+      O (error, NILF, "exporting: Couldn't create return socket.");
+      return 1;
+    }
+
+  /* Get the return socket's port number.  */
+  len = sizeof (sin);
+  if (getsockname (retsock, (struct sockaddr *) &sin, &len) < 0)
+    {
+      (void) close (retsock);
+      perror_with_name ("exporting: ", "getsockname");
+      return 1;
+    }
+  retport = sin.sin_port;
+
+  /* Create the TCP socket for talking to the remote child.  */
+  sock = Rpc_TcpCreate (False, 0);
+
+  /* Create a WayBill to give to the server.  */
+  len = Customs_MakeWayBill (&permit, normalized_cwd, argv[0], argv,
+                             envp, retport, waybill);
+
+  /* Modify the waybill as if the remote child had done 'child_access ()'.  */
+  {
+    WayBill *wb = (WayBill *) waybill;
+    wb->ruid = wb->euid;
+    wb->rgid = wb->egid;
+  }
+
+  /* Send the request to the server, timing out in 20 seconds.  */
+  timeout.tv_usec = 0;
+  timeout.tv_sec = 20;
+  sin.sin_family = AF_INET;
+  sin.sin_port = htons (Customs_Port ());
+  sin.sin_addr = permit.addr;
+  status = Rpc_Call (sock, &sin, (Rpc_Proc) CUSTOMS_IMPORT,
+                     len, (Rpc_Opaque) waybill,
+                     sizeof (msg), (Rpc_Opaque) msg,
+                     1, &timeout);
+
+  host = gethostbyaddr ((char *)&permit.addr, sizeof(permit.addr), AF_INET);
+
+  {
+    const char *hnm = host ? host->h_name : inet_ntoa (permit.addr);
+    size_t hlen = strlen (hnm);
+
+    if (status != RPC_SUCCESS)
+      {
+        const char *err = Rpc_ErrorMessage (status);
+        (void) close (retsock);
+        (void) close (sock);
+        error (NILF, hlen + strlen (err),
+               "exporting to %s: %s", hnm, err);
+        return 1;
+      }
+    else if (msg[0] != 'O' || msg[1] != 'k' || msg[2] != '\0')
+      {
+        (void) close (retsock);
+        (void) close (sock);
+        error (NILF, hlen + strlen (msg), "exporting to %s: %s", hnm, msg);
+        return 1;
+      }
+    else
+      {
+        error (NILF, hlen + INTSTR_LENGTH,
+               "*** exported to %s (id %u)", hnm, permit.id);
+      }
+
+    fflush (stdout);
+    fflush (stderr);
+  }
+
+  pid = vfork ();
+  if (pid < 0)
+    {
+      /* The fork failed!  */
+      perror_with_name ("fork", "");
+      return 1;
+    }
+  else if (pid == 0)
+    {
+      /* Child side.  Run 'export' to handle the connection.  */
+      static char sock_buf[20], retsock_buf[20], id_buf[20];
+      static char *new_argv[6] =
+        { EXPORT_COMMAND, "-id", sock_buf, retsock_buf, id_buf, 0 };
+
+      /* Set up the arguments.  */
+      (void) sprintf (sock_buf, "%d", sock);
+      (void) sprintf (retsock_buf, "%d", retsock);
+      (void) sprintf (id_buf, "%x", permit.id);
+
+      /* Get the right stdin.  */
+      if (stdin_fd != 0)
+        (void) dup2 (stdin_fd, 0);
+
+      /* Unblock signals in the child.  */
+      unblock_all_sigs ();
+
+      /* Run the command.  */
+      exec_command (new_argv, envp);
+    }
+
+  /* Parent side.  Return the 'export' process's ID.  */
+  (void) close (retsock);
+  (void) close (sock);
+  *is_remote = 0;
+  *id_ptr = pid;
+  *used_stdin = 1;
+  return 0;
+}
+
+/* Get the status of a dead remote child.  Block waiting for one to die
+   if BLOCK is nonzero.  Set *EXIT_CODE_PTR to the exit status, *SIGNAL_PTR
+   to the termination signal or zero if it exited normally, and *COREDUMP_PTR
+   nonzero if it dumped core.  Return the ID of the child that died,
+   0 if we would have to block and !BLOCK, or < 0 if there were none.  */
+
+int
+remote_status (int *exit_code_ptr, int *signal_ptr, int *coredump_ptr,
+               int block)
+{
+  return -1;
+}
+
+/* Block asynchronous notification of remote child death.
+   If this notification is done by raising the child termination
+   signal, do not block that signal.  */
+void
+block_remote_children (void)
+{
+  return;
+}
+
+/* Restore asynchronous notification of remote child death.
+   If this is done by raising the child termination signal,
+   do not unblock that signal.  */
+void
+unblock_remote_children (void)
+{
+  return;
+}
+
+/* Send signal SIG to child ID.  Return 0 if successful, -1 if not.  */
+int
+remote_kill (int id, int sig)
+{
+  return -1;
+}
diff --git a/src/remote-stub.c b/src/remote-stub.c
new file mode 100644
index 0000000..02c7a88
--- /dev/null
+++ b/src/remote-stub.c
@@ -0,0 +1,99 @@
+/* Template for the remote job exportation interface to GNU Make.
+Copyright (C) 1988-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+#include "filedef.h"
+#include "job.h"
+#include "commands.h"
+
+
+char *remote_description = 0;
+
+/* Call once at startup even if no commands are run.  */
+
+void
+remote_setup (void)
+{
+}
+
+/* Called before exit.  */
+
+void
+remote_cleanup (void)
+{
+}
+
+/* Return nonzero if the next job should be done remotely.  */
+
+int
+start_remote_job_p (int first_p UNUSED)
+{
+  return 0;
+}
+
+/* Start a remote job running the command in ARGV,
+   with environment from ENVP.  It gets standard input from STDIN_FD.  On
+   failure, return nonzero.  On success, return zero, and set *USED_STDIN
+   to nonzero if it will actually use STDIN_FD, zero if not, set *ID_PTR to
+   a unique identification, and set *IS_REMOTE to zero if the job is local,
+   nonzero if it is remote (meaning *ID_PTR is a process ID).  */
+
+int
+start_remote_job (char **argv UNUSED, char **envp UNUSED, int stdin_fd UNUSED,
+                  int *is_remote UNUSED, int *id_ptr UNUSED,
+                  int *used_stdin UNUSED)
+{
+  return -1;
+}
+
+/* Get the status of a dead remote child.  Block waiting for one to die
+   if BLOCK is nonzero.  Set *EXIT_CODE_PTR to the exit status, *SIGNAL_PTR
+   to the termination signal or zero if it exited normally, and *COREDUMP_PTR
+   nonzero if it dumped core.  Return the ID of the child that died,
+   0 if we would have to block and !BLOCK, or < 0 if there were none.  */
+
+int
+remote_status (int *exit_code_ptr UNUSED, int *signal_ptr UNUSED,
+               int *coredump_ptr UNUSED, int block UNUSED)
+{
+  errno = ECHILD;
+  return -1;
+}
+
+/* Block asynchronous notification of remote child death.
+   If this notification is done by raising the child termination
+   signal, do not block that signal.  */
+void
+block_remote_children (void)
+{
+  return;
+}
+
+/* Restore asynchronous notification of remote child death.
+   If this is done by raising the child termination signal,
+   do not unblock that signal.  */
+void
+unblock_remote_children (void)
+{
+  return;
+}
+
+/* Send signal SIG to child ID.  Return 0 if successful, -1 if not.  */
+int
+remote_kill (int id UNUSED, int sig UNUSED)
+{
+  return -1;
+}
diff --git a/src/rule.c b/src/rule.c
new file mode 100644
index 0000000..1fe77e1
--- /dev/null
+++ b/src/rule.c
@@ -0,0 +1,526 @@
+/* Pattern and suffix rule internals for GNU Make.
+Copyright (C) 1988-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+
+#include <assert.h>
+
+#include "filedef.h"
+#include "dep.h"
+#include "job.h"
+#include "commands.h"
+#include "variable.h"
+#include "rule.h"
+
+static void freerule (struct rule *rule, struct rule *lastrule);
+
+/* Chain of all pattern rules.  */
+
+struct rule *pattern_rules;
+
+/* Pointer to last rule in the chain, so we can add onto the end.  */
+
+struct rule *last_pattern_rule;
+
+/* Number of rules in the chain.  */
+
+unsigned int num_pattern_rules;
+
+/* Maximum number of target patterns of any pattern rule.  */
+
+unsigned int max_pattern_targets;
+
+/* Maximum number of dependencies of any pattern rule.  */
+
+unsigned int max_pattern_deps;
+
+/* Maximum length of the name of a dependencies of any pattern rule.  */
+
+unsigned int max_pattern_dep_length;
+
+/* Pointer to structure for the file .SUFFIXES
+   whose dependencies are the suffixes to be searched.  */
+
+struct file *suffix_file;
+
+/* Maximum length of a suffix.  */
+
+unsigned int maxsuffix;
+
+/* Compute the maximum dependency length and maximum number of
+   dependencies of all implicit rules.  Also sets the subdir
+   flag for a rule when appropriate, possibly removing the rule
+   completely when appropriate.  */
+
+void
+count_implicit_rule_limits (void)
+{
+  char *name;
+  int namelen;
+  struct rule *rule;
+
+  num_pattern_rules = max_pattern_targets = max_pattern_deps = 0;
+  max_pattern_dep_length = 0;
+
+  name = 0;
+  namelen = 0;
+  rule = pattern_rules;
+  while (rule != 0)
+    {
+      unsigned int ndeps = 0;
+      struct dep *dep;
+      struct rule *next = rule->next;
+
+      ++num_pattern_rules;
+
+      if (rule->num > max_pattern_targets)
+        max_pattern_targets = rule->num;
+
+      for (dep = rule->deps; dep != 0; dep = dep->next)
+        {
+          const char *dname = dep_name (dep);
+          unsigned int len = strlen (dname);
+
+#ifdef VMS
+          const char *p = strrchr (dname, ']');
+          const char *p2;
+          if (p == 0)
+            p = strrchr (dname, ':');
+          p2 = p != 0 ? strchr (dname, '%') : 0;
+#else
+          const char *p = strrchr (dname, '/');
+          const char *p2 = p != 0 ? strchr (dname, '%') : 0;
+#endif
+          ndeps++;
+
+          if (len > max_pattern_dep_length)
+            max_pattern_dep_length = len;
+
+          if (p != 0 && p2 > p)
+            {
+              /* There is a slash before the % in the dep name.
+                 Extract the directory name.  */
+              if (p == dname)
+                ++p;
+              if (p - dname > namelen)
+                {
+                  namelen = p - dname;
+                  name = xrealloc (name, namelen + 1);
+                }
+              memcpy (name, dname, p - dname);
+              name[p - dname] = '\0';
+
+              /* In the deps of an implicit rule the 'changed' flag
+                 actually indicates that the dependency is in a
+                 nonexistent subdirectory.  */
+
+              dep->changed = !dir_file_exists_p (name, "");
+            }
+          else
+            /* This dependency does not reside in a subdirectory.  */
+            dep->changed = 0;
+        }
+
+      if (ndeps > max_pattern_deps)
+        max_pattern_deps = ndeps;
+
+      rule = next;
+    }
+
+  free (name);
+}
+
+/* Create a pattern rule from a suffix rule.
+   TARGET is the target suffix; SOURCE is the source suffix.
+   CMDS are the commands.
+   If TARGET is nil, it means the target pattern should be '(%.o)'.
+   If SOURCE is nil, it means there should be no deps.  */
+
+static void
+convert_suffix_rule (const char *target, const char *source,
+                     struct commands *cmds)
+{
+  const char **names, **percents;
+  struct dep *deps;
+
+  names = xmalloc (sizeof (const char *));
+  percents = xmalloc (sizeof (const char *));
+
+  if (target == 0)
+    {
+      /* Special case: TARGET being nil means we are defining a '.X.a' suffix
+         rule; the target pattern is always '(%.o)'.  */
+#ifdef VMS
+      *names = strcache_add_len ("(%.obj)", 7);
+#else
+      *names = strcache_add_len ("(%.o)", 5);
+#endif
+      *percents = *names + 1;
+    }
+  else
+    {
+      /* Construct the target name.  */
+      unsigned int len = strlen (target);
+      char *p = alloca (1 + len + 1);
+      p[0] = '%';
+      memcpy (p + 1, target, len + 1);
+      *names = strcache_add_len (p, len + 1);
+      *percents = *names;
+    }
+
+  if (source == 0)
+    deps = 0;
+  else
+    {
+      /* Construct the dependency name.  */
+      unsigned int len = strlen (source);
+      char *p = alloca (1 + len + 1);
+      p[0] = '%';
+      memcpy (p + 1, source, len + 1);
+      deps = alloc_dep ();
+      deps->name = strcache_add_len (p, len + 1);
+    }
+
+  create_pattern_rule (names, percents, 1, 0, deps, cmds, 0);
+}
+
+/* Convert old-style suffix rules to pattern rules.
+   All rules for the suffixes on the .SUFFIXES list are converted and added to
+   the chain of pattern rules.  */
+
+void
+convert_to_pattern (void)
+{
+  struct dep *d, *d2;
+  char *rulename;
+
+  /* We will compute every potential suffix rule (.x.y) from the list of
+     suffixes in the .SUFFIXES target's dependencies and see if it exists.
+     First find the longest of the suffixes.  */
+
+  maxsuffix = 0;
+  for (d = suffix_file->deps; d != 0; d = d->next)
+    {
+      unsigned int l = strlen (dep_name (d));
+      if (l > maxsuffix)
+        maxsuffix = l;
+    }
+
+  /* Space to construct the suffix rule target name.  */
+  rulename = alloca ((maxsuffix * 2) + 1);
+
+  for (d = suffix_file->deps; d != 0; d = d->next)
+    {
+      unsigned int slen;
+
+      /* Make a rule that is just the suffix, with no deps or commands.
+         This rule exists solely to disqualify match-anything rules.  */
+      convert_suffix_rule (dep_name (d), 0, 0);
+
+      if (d->file->cmds != 0)
+        /* Record a pattern for this suffix's null-suffix rule.  */
+        convert_suffix_rule ("", dep_name (d), d->file->cmds);
+
+      /* Add every other suffix to this one and see if it exists as a
+         two-suffix rule.  */
+      slen = strlen (dep_name (d));
+      memcpy (rulename, dep_name (d), slen);
+
+      for (d2 = suffix_file->deps; d2 != 0; d2 = d2->next)
+        {
+          struct file *f;
+          unsigned int s2len;
+
+          s2len = strlen (dep_name (d2));
+
+          /* Can't build something from itself.  */
+          if (slen == s2len && streq (dep_name (d), dep_name (d2)))
+            continue;
+
+          memcpy (rulename + slen, dep_name (d2), s2len + 1);
+          f = lookup_file (rulename);
+          if (f == 0 || f->cmds == 0)
+            continue;
+
+          if (s2len == 2 && rulename[slen] == '.' && rulename[slen + 1] == 'a')
+            /* A suffix rule '.X.a:' generates the pattern rule '(%.o): %.X'.
+               It also generates a normal '%.a: %.X' rule below.  */
+            convert_suffix_rule (NULL, /* Indicates '(%.o)'.  */
+                                 dep_name (d),
+                                 f->cmds);
+
+          /* The suffix rule '.X.Y:' is converted
+             to the pattern rule '%.Y: %.X'.  */
+          convert_suffix_rule (dep_name (d2), dep_name (d), f->cmds);
+        }
+    }
+}
+
+
+/* Install the pattern rule RULE (whose fields have been filled in) at the end
+   of the list (so that any rules previously defined will take precedence).
+   If this rule duplicates a previous one (identical target and dependencies),
+   the old one is replaced if OVERRIDE is nonzero, otherwise this new one is
+   thrown out.  When an old rule is replaced, the new one is put at the end of
+   the list.  Return nonzero if RULE is used; zero if not.  */
+
+static int
+new_pattern_rule (struct rule *rule, int override)
+{
+  struct rule *r, *lastrule;
+  unsigned int i, j;
+
+  rule->in_use = 0;
+  rule->terminal = 0;
+
+  rule->next = 0;
+
+  /* Search for an identical rule.  */
+  lastrule = 0;
+  for (r = pattern_rules; r != 0; lastrule = r, r = r->next)
+    for (i = 0; i < rule->num; ++i)
+      {
+        for (j = 0; j < r->num; ++j)
+          if (!streq (rule->targets[i], r->targets[j]))
+            break;
+        /* If all the targets matched...  */
+        if (j == r->num)
+          {
+            struct dep *d, *d2;
+            for (d = rule->deps, d2 = r->deps;
+                 d != 0 && d2 != 0; d = d->next, d2 = d2->next)
+              if (!streq (dep_name (d), dep_name (d2)))
+                break;
+            if (d == 0 && d2 == 0)
+              {
+                /* All the dependencies matched.  */
+                if (override)
+                  {
+                    /* Remove the old rule.  */
+                    freerule (r, lastrule);
+                    /* Install the new one.  */
+                    if (pattern_rules == 0)
+                      pattern_rules = rule;
+                    else
+                      last_pattern_rule->next = rule;
+                    last_pattern_rule = rule;
+
+                    /* We got one.  Stop looking.  */
+                    goto matched;
+                  }
+                else
+                  {
+                    /* The old rule stays intact.  Destroy the new one.  */
+                    freerule (rule, (struct rule *) 0);
+                    return 0;
+                  }
+              }
+          }
+      }
+
+ matched:;
+
+  if (r == 0)
+    {
+      /* There was no rule to replace.  */
+      if (pattern_rules == 0)
+        pattern_rules = rule;
+      else
+        last_pattern_rule->next = rule;
+      last_pattern_rule = rule;
+    }
+
+  return 1;
+}
+
+
+/* Install an implicit pattern rule based on the three text strings
+   in the structure P points to.  These strings come from one of
+   the arrays of default implicit pattern rules.
+   TERMINAL specifies what the 'terminal' field of the rule should be.  */
+
+void
+install_pattern_rule (struct pspec *p, int terminal)
+{
+  struct rule *r;
+  const char *ptr;
+
+  r = xmalloc (sizeof (struct rule));
+
+  r->num = 1;
+  r->targets = xmalloc (sizeof (const char *));
+  r->suffixes = xmalloc (sizeof (const char *));
+  r->lens = xmalloc (sizeof (unsigned int));
+
+  r->lens[0] = strlen (p->target);
+  r->targets[0] = p->target;
+  r->suffixes[0] = find_percent_cached (&r->targets[0]);
+  assert (r->suffixes[0] != NULL);
+  ++r->suffixes[0];
+
+  ptr = p->dep;
+  r->deps = PARSE_SIMPLE_SEQ ((char **)&ptr, struct dep);
+
+  if (new_pattern_rule (r, 0))
+    {
+      r->terminal = terminal;
+      r->cmds = xmalloc (sizeof (struct commands));
+      r->cmds->fileinfo.filenm = 0;
+      r->cmds->fileinfo.lineno = 0;
+      r->cmds->fileinfo.offset = 0;
+      /* These will all be string literals, but we malloc space for them
+         anyway because somebody might want to free them later.  */
+      r->cmds->commands = xstrdup (p->commands);
+      r->cmds->command_lines = 0;
+      r->cmds->recipe_prefix = RECIPEPREFIX_DEFAULT;
+    }
+}
+
+
+/* Free all the storage used in RULE and take it out of the
+   pattern_rules chain.  LASTRULE is the rule whose next pointer
+   points to RULE.  */
+
+static void
+freerule (struct rule *rule, struct rule *lastrule)
+{
+  struct rule *next = rule->next;
+
+  free_dep_chain (rule->deps);
+
+  /* MSVC erroneously warns without a cast here.  */
+  free ((void *)rule->targets);
+  free ((void *)rule->suffixes);
+  free (rule->lens);
+
+  /* We can't free the storage for the commands because there
+     are ways that they could be in more than one place:
+       * If the commands came from a suffix rule, they could also be in
+       the 'struct file's for other suffix rules or plain targets given
+       on the same makefile line.
+       * If two suffixes that together make a two-suffix rule were each
+       given twice in the .SUFFIXES list, and in the proper order, two
+       identical pattern rules would be created and the second one would
+       be discarded here, but both would contain the same 'struct commands'
+       pointer from the 'struct file' for the suffix rule.  */
+
+  free (rule);
+
+  if (pattern_rules == rule)
+    if (lastrule != 0)
+      abort ();
+    else
+      pattern_rules = next;
+  else if (lastrule != 0)
+    lastrule->next = next;
+  if (last_pattern_rule == rule)
+    last_pattern_rule = lastrule;
+}
+
+/* Create a new pattern rule with the targets in the nil-terminated array
+   TARGETS.  TARGET_PERCENTS is an array of pointers to the % in each element
+   of TARGETS.  N is the number of items in the array (not counting the nil
+   element).  The new rule has dependencies DEPS and commands from COMMANDS.
+   It is a terminal rule if TERMINAL is nonzero.  This rule overrides
+   identical rules with different commands if OVERRIDE is nonzero.
+
+   The storage for TARGETS and its elements and TARGET_PERCENTS is used and
+   must not be freed until the rule is destroyed.  */
+
+void
+create_pattern_rule (const char **targets, const char **target_percents,
+                     unsigned int n, int terminal, struct dep *deps,
+                     struct commands *commands, int override)
+{
+  unsigned int i;
+  struct rule *r = xmalloc (sizeof (struct rule));
+
+  r->num = n;
+  r->cmds = commands;
+  r->deps = deps;
+  r->targets = targets;
+  r->suffixes = target_percents;
+  r->lens = xmalloc (n * sizeof (unsigned int));
+
+  for (i = 0; i < n; ++i)
+    {
+      r->lens[i] = strlen (targets[i]);
+      assert (r->suffixes[i] != NULL);
+      ++r->suffixes[i];
+    }
+
+  if (new_pattern_rule (r, override))
+    r->terminal = terminal;
+}
+
+/* Print the data base of rules.  */
+
+static void                     /* Useful to call from gdb.  */
+print_rule (struct rule *r)
+{
+  unsigned int i;
+
+  for (i = 0; i < r->num; ++i)
+    {
+      fputs (r->targets[i], stdout);
+      putchar ((i + 1 == r->num) ? ':' : ' ');
+    }
+  if (r->terminal)
+    putchar (':');
+
+  print_prereqs (r->deps);
+
+  if (r->cmds != 0)
+    print_commands (r->cmds);
+}
+
+void
+print_rule_data_base (void)
+{
+  unsigned int rules, terminal;
+  struct rule *r;
+
+  puts (_("\n# Implicit Rules"));
+
+  rules = terminal = 0;
+  for (r = pattern_rules; r != 0; r = r->next)
+    {
+      ++rules;
+
+      putchar ('\n');
+      print_rule (r);
+
+      if (r->terminal)
+        ++terminal;
+    }
+
+  if (rules == 0)
+    puts (_("\n# No implicit rules."));
+  else
+    {
+      printf (_("\n# %u implicit rules, %u (%.1f%%) terminal."),
+              rules, terminal, (double) terminal / (double) rules * 100.0);
+    }
+
+  if (num_pattern_rules != rules)
+    {
+      /* This can happen if a fatal error was detected while reading the
+         makefiles and thus count_implicit_rule_limits wasn't called yet.  */
+      if (num_pattern_rules != 0)
+        ONN (fatal, NILF, _("BUG: num_pattern_rules is wrong!  %u != %u"),
+             num_pattern_rules, rules);
+    }
+}
diff --git a/src/rule.h b/src/rule.h
new file mode 100644
index 0000000..b6adc9a
--- /dev/null
+++ b/src/rule.h
@@ -0,0 +1,58 @@
+/* Definitions for using pattern rules in GNU Make.
+Copyright (C) 1988-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+
+/* Structure used for pattern (implicit) rules.  */
+
+struct rule
+  {
+    struct rule *next;
+    const char **targets;       /* Targets of the rule.  */
+    unsigned int *lens;         /* Lengths of each target.  */
+    const char **suffixes;      /* Suffixes (after '%') of each target.  */
+    struct dep *deps;           /* Dependencies of the rule.  */
+    struct commands *cmds;      /* Commands to execute.  */
+    unsigned short num;         /* Number of targets.  */
+    char terminal;              /* If terminal (double-colon).  */
+    char in_use;                /* If in use by a parent pattern_search.  */
+  };
+
+/* For calling install_pattern_rule.  */
+struct pspec
+  {
+    const char *target, *dep, *commands;
+  };
+
+
+extern struct rule *pattern_rules;
+extern struct rule *last_pattern_rule;
+extern unsigned int num_pattern_rules;
+
+extern unsigned int max_pattern_deps;
+extern unsigned int max_pattern_targets;
+extern unsigned int max_pattern_dep_length;
+
+extern struct file *suffix_file;
+extern unsigned int maxsuffix;
+
+
+void count_implicit_rule_limits (void);
+void convert_to_pattern (void);
+void install_pattern_rule (struct pspec *p, int terminal);
+void create_pattern_rule (const char **targets, const char **target_percents,
+                          unsigned int num, int terminal, struct dep *deps,
+                          struct commands *commands, int override);
+void print_rule_data_base (void);
diff --git a/src/signame.c b/src/signame.c
new file mode 100644
index 0000000..9ee00e2
--- /dev/null
+++ b/src/signame.c
@@ -0,0 +1,254 @@
+/* Convert between signal names and numbers.
+Copyright (C) 1990-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+
+/* If the system provides strsignal, we don't need it. */
+
+#if !HAVE_STRSIGNAL
+
+/* If the system provides sys_siglist, we'll use that.
+   Otherwise create our own.
+ */
+
+#if !HAVE_DECL_SYS_SIGLIST
+
+/* Some systems do not define NSIG in <signal.h>.  */
+#ifndef NSIG
+#ifdef  _NSIG
+#define NSIG    _NSIG
+#else
+#define NSIG    32
+#endif
+#endif
+
+/* There is too much variation in Sys V signal numbers and names, so
+   we must initialize them at runtime.  */
+
+static const char *undoc;
+
+static const char *sys_siglist[NSIG];
+
+/* Table of abbreviations for signals.  Note:  A given number can
+   appear more than once with different abbreviations.  */
+#define SIG_TABLE_SIZE  (NSIG*2)
+
+typedef struct
+  {
+    int number;
+    const char *abbrev;
+  } num_abbrev;
+
+static num_abbrev sig_table[SIG_TABLE_SIZE];
+
+/* Number of elements of sig_table used.  */
+static int sig_table_nelts = 0;
+
+/* Enter signal number NUMBER into the tables with ABBREV and NAME.  */
+
+static void
+init_sig (int number, const char *abbrev, const char *name)
+{
+  /* If this value is ever greater than NSIG it seems like it'd be a bug in
+     the system headers, but... better safe than sorry.  We know, for
+     example, that this isn't always true on VMS.  */
+
+  if (number >= 0 && number < NSIG)
+    sys_siglist[number] = name;
+
+  if (sig_table_nelts < SIG_TABLE_SIZE)
+    {
+      sig_table[sig_table_nelts].number = number;
+      sig_table[sig_table_nelts++].abbrev = abbrev;
+    }
+}
+
+static int
+signame_init (void)
+{
+  int i;
+
+  undoc = xstrdup (_("unknown signal"));
+
+  /* Initialize signal names.  */
+  for (i = 0; i < NSIG; i++)
+    sys_siglist[i] = undoc;
+
+  /* Initialize signal names.  */
+#if defined (SIGHUP)
+  init_sig (SIGHUP, "HUP", _("Hangup"));
+#endif
+#if defined (SIGINT)
+  init_sig (SIGINT, "INT", _("Interrupt"));
+#endif
+#if defined (SIGQUIT)
+  init_sig (SIGQUIT, "QUIT", _("Quit"));
+#endif
+#if defined (SIGILL)
+  init_sig (SIGILL, "ILL", _("Illegal Instruction"));
+#endif
+#if defined (SIGTRAP)
+  init_sig (SIGTRAP, "TRAP", _("Trace/breakpoint trap"));
+#endif
+  /* If SIGIOT == SIGABRT, we want to print it as SIGABRT because
+     SIGABRT is in ANSI and POSIX.1 and SIGIOT isn't.  */
+#if defined (SIGABRT)
+  init_sig (SIGABRT, "ABRT", _("Aborted"));
+#endif
+#if defined (SIGIOT)
+  init_sig (SIGIOT, "IOT", _("IOT trap"));
+#endif
+#if defined (SIGEMT)
+  init_sig (SIGEMT, "EMT", _("EMT trap"));
+#endif
+#if defined (SIGFPE)
+  init_sig (SIGFPE, "FPE", _("Floating point exception"));
+#endif
+#if defined (SIGKILL)
+  init_sig (SIGKILL, "KILL", _("Killed"));
+#endif
+#if defined (SIGBUS)
+  init_sig (SIGBUS, "BUS", _("Bus error"));
+#endif
+#if defined (SIGSEGV)
+  init_sig (SIGSEGV, "SEGV", _("Segmentation fault"));
+#endif
+#if defined (SIGSYS)
+  init_sig (SIGSYS, "SYS", _("Bad system call"));
+#endif
+#if defined (SIGPIPE)
+  init_sig (SIGPIPE, "PIPE", _("Broken pipe"));
+#endif
+#if defined (SIGALRM)
+  init_sig (SIGALRM, "ALRM", _("Alarm clock"));
+#endif
+#if defined (SIGTERM)
+  init_sig (SIGTERM, "TERM", _("Terminated"));
+#endif
+#if defined (SIGUSR1)
+  init_sig (SIGUSR1, "USR1", _("User defined signal 1"));
+#endif
+#if defined (SIGUSR2)
+  init_sig (SIGUSR2, "USR2", _("User defined signal 2"));
+#endif
+  /* If SIGCLD == SIGCHLD, we want to print it as SIGCHLD because that
+     is what is in POSIX.1.  */
+#if defined (SIGCHLD)
+  init_sig (SIGCHLD, "CHLD", _("Child exited"));
+#endif
+#if defined (SIGCLD)
+  init_sig (SIGCLD, "CLD", _("Child exited"));
+#endif
+#if defined (SIGPWR)
+  init_sig (SIGPWR, "PWR", _("Power failure"));
+#endif
+#if defined (SIGTSTP)
+  init_sig (SIGTSTP, "TSTP", _("Stopped"));
+#endif
+#if defined (SIGTTIN)
+  init_sig (SIGTTIN, "TTIN", _("Stopped (tty input)"));
+#endif
+#if defined (SIGTTOU)
+  init_sig (SIGTTOU, "TTOU", _("Stopped (tty output)"));
+#endif
+#if defined (SIGSTOP)
+  init_sig (SIGSTOP, "STOP", _("Stopped (signal)"));
+#endif
+#if defined (SIGXCPU)
+  init_sig (SIGXCPU, "XCPU", _("CPU time limit exceeded"));
+#endif
+#if defined (SIGXFSZ)
+  init_sig (SIGXFSZ, "XFSZ", _("File size limit exceeded"));
+#endif
+#if defined (SIGVTALRM)
+  init_sig (SIGVTALRM, "VTALRM", _("Virtual timer expired"));
+#endif
+#if defined (SIGPROF)
+  init_sig (SIGPROF, "PROF", _("Profiling timer expired"));
+#endif
+#if defined (SIGWINCH)
+  /* "Window size changed" might be more accurate, but even if that
+     is all that it means now, perhaps in the future it will be
+     extended to cover other kinds of window changes.  */
+  init_sig (SIGWINCH, "WINCH", _("Window changed"));
+#endif
+#if defined (SIGCONT)
+  init_sig (SIGCONT, "CONT", _("Continued"));
+#endif
+#if defined (SIGURG)
+  init_sig (SIGURG, "URG", _("Urgent I/O condition"));
+#endif
+#if defined (SIGIO)
+  /* "I/O pending" has also been suggested.  A disadvantage is that signal
+     only happens when the process has asked for it, not every time I/O is
+     pending.  Another disadvantage is the confusion from giving it a
+     different name than under Unix.  */
+  init_sig (SIGIO, "IO", _("I/O possible"));
+#endif
+#if defined (SIGWIND)
+  init_sig (SIGWIND, "WIND", _("SIGWIND"));
+#endif
+#if defined (SIGPHONE)
+  init_sig (SIGPHONE, "PHONE", _("SIGPHONE"));
+#endif
+#if defined (SIGPOLL)
+  init_sig (SIGPOLL, "POLL", _("I/O possible"));
+#endif
+#if defined (SIGLOST)
+  init_sig (SIGLOST, "LOST", _("Resource lost"));
+#endif
+#if defined (SIGDANGER)
+  init_sig (SIGDANGER, "DANGER", _("Danger signal"));
+#endif
+#if defined (SIGINFO)
+  init_sig (SIGINFO, "INFO", _("Information request"));
+#endif
+#if defined (SIGNOFP)
+  init_sig (SIGNOFP, "NOFP", _("Floating point co-processor not available"));
+#endif
+
+  return 1;
+}
+
+#endif  /* HAVE_DECL_SYS_SIGLIST */
+
+
+char *
+strsignal (int sig)
+{
+  static char buf[] = "Signal 12345678901234567890";
+
+#if ! HAVE_DECL_SYS_SIGLIST
+# if HAVE_DECL__SYS_SIGLIST
+#  define sys_siglist _sys_siglist
+# elif HAVE_DECL___SYS_SIGLIST
+#  define sys_siglist __sys_siglist
+# else
+  static char sig_initted = 0;
+
+  if (!sig_initted)
+    sig_initted = signame_init ();
+# endif
+#endif
+
+  if (sig > 0 && sig < NSIG)
+    return (char *) sys_siglist[sig];
+
+  sprintf (buf, "Signal %d", sig);
+  return buf;
+}
+
+#endif  /* HAVE_STRSIGNAL */
diff --git a/src/strcache.c b/src/strcache.c
new file mode 100644
index 0000000..19f43c9
--- /dev/null
+++ b/src/strcache.c
@@ -0,0 +1,330 @@
+/* Constant string caching for GNU Make.
+Copyright (C) 2006-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+
+#include <stddef.h>
+#include <assert.h>
+
+#include "hash.h"
+
+/* A string cached here will never be freed, so we don't need to worry about
+   reference counting.  We just store the string, and then remember it in a
+   hash so it can be looked up again. */
+
+typedef unsigned short int sc_buflen_t;
+
+struct strcache {
+  struct strcache *next;    /* The next block of strings.  Must be first!  */
+  sc_buflen_t end;          /* Offset to the beginning of free space.  */
+  sc_buflen_t bytesfree;    /* Free space left in this buffer.  */
+  sc_buflen_t count;        /* # of strings in this buffer (for stats).  */
+  char buffer[1];           /* The buffer comes after this.  */
+};
+
+/* The size (in bytes) of each cache buffer.
+   Try to pick something that will map well into the heap.
+   This must be able to be represented by a short int (<=65535).  */
+#define CACHE_BUFFER_BASE       (8192)
+#define CACHE_BUFFER_ALLOC(_s)  ((_s) - (2 * sizeof (size_t)))
+#define CACHE_BUFFER_OFFSET     (offsetof (struct strcache, buffer))
+#define CACHE_BUFFER_SIZE(_s)   (CACHE_BUFFER_ALLOC(_s) - CACHE_BUFFER_OFFSET)
+#define BUFSIZE                 CACHE_BUFFER_SIZE (CACHE_BUFFER_BASE)
+
+static struct strcache *strcache = NULL;
+static struct strcache *fullcache = NULL;
+
+static unsigned long total_buffers = 0;
+static unsigned long total_strings = 0;
+static unsigned long total_size = 0;
+
+/* Add a new buffer to the cache.  Add it at the front to reduce search time.
+   This can also increase the overhead, since it's less likely that older
+   buffers will be filled in.  However, GNU make has so many smaller strings
+   that this doesn't seem to be much of an issue in practice.
+ */
+static struct strcache *
+new_cache (struct strcache **head, sc_buflen_t buflen)
+{
+  struct strcache *new = xmalloc (buflen + CACHE_BUFFER_OFFSET);
+  new->end = 0;
+  new->count = 0;
+  new->bytesfree = buflen;
+
+  new->next = *head;
+  *head = new;
+
+  ++total_buffers;
+  return new;
+}
+
+static const char *
+copy_string (struct strcache *sp, const char *str, unsigned int len)
+{
+  /* Add the string to this cache.  */
+  char *res = &sp->buffer[sp->end];
+
+  memmove (res, str, len);
+  res[len++] = '\0';
+  sp->end += len;
+  sp->bytesfree -= len;
+  ++sp->count;
+
+  return res;
+}
+
+static const char *
+add_string (const char *str, unsigned int len)
+{
+  const char *res;
+  struct strcache *sp;
+  struct strcache **spp = &strcache;
+  /* We need space for the nul char.  */
+  unsigned int sz = len + 1;
+
+  ++total_strings;
+  total_size += sz;
+
+  /* If the string we want is too large to fit into a single buffer, then
+     no existing cache is large enough.  Add it directly to the fullcache.  */
+  if (sz > BUFSIZE)
+    {
+      sp = new_cache (&fullcache, sz);
+      return copy_string (sp, str, len);
+    }
+
+  /* Find the first cache with enough free space.  */
+  for (; *spp != NULL; spp = &(*spp)->next)
+    if ((*spp)->bytesfree > sz)
+      break;
+  sp = *spp;
+
+  /* If nothing is big enough, make a new cache at the front.  */
+  if (sp == NULL)
+    {
+      sp = new_cache (&strcache, BUFSIZE);
+      spp = &strcache;
+    }
+
+  /* Add the string to this cache.  */
+  res = copy_string (sp, str, len);
+
+  /* If the amount free in this cache is less than the average string size,
+     consider it full and move it to the full list.  */
+  if (total_strings > 20 && sp->bytesfree < (total_size / total_strings) + 1)
+    {
+      *spp = sp->next;
+      sp->next = fullcache;
+      fullcache = sp;
+    }
+
+  return res;
+}
+
+/* For strings too large for the strcache, we just save them in a list.  */
+struct hugestring {
+  struct hugestring *next;  /* The next string.  */
+  char buffer[1];           /* The string.  */
+};
+
+static struct hugestring *hugestrings = NULL;
+
+static const char *
+add_hugestring (const char *str, unsigned int len)
+{
+  struct hugestring *new = xmalloc (sizeof (struct hugestring) + len);
+  memcpy (new->buffer, str, len);
+  new->buffer[len] = '\0';
+
+  new->next = hugestrings;
+  hugestrings = new;
+
+  return new->buffer;
+}
+
+/* Hash table of strings in the cache.  */
+
+static unsigned long
+str_hash_1 (const void *key)
+{
+  return_ISTRING_HASH_1 ((const char *) key);
+}
+
+static unsigned long
+str_hash_2 (const void *key)
+{
+  return_ISTRING_HASH_2 ((const char *) key);
+}
+
+static int
+str_hash_cmp (const void *x, const void *y)
+{
+  return_ISTRING_COMPARE ((const char *) x, (const char *) y);
+}
+
+static struct hash_table strings;
+static unsigned long total_adds = 0;
+
+static const char *
+add_hash (const char *str, unsigned int len)
+{
+  char *const *slot;
+  const char *key;
+
+  /* If it's too large for the string cache, just copy it.
+     We don't bother trying to match these.  */
+  if (len > USHRT_MAX - 1)
+    return add_hugestring (str, len);
+
+  /* Look up the string in the hash.  If it's there, return it.  */
+  slot = (char *const *) hash_find_slot (&strings, str);
+  key = *slot;
+
+  /* Count the total number of add operations we performed.  */
+  ++total_adds;
+
+  if (!HASH_VACANT (key))
+    return key;
+
+  /* Not there yet so add it to a buffer, then into the hash table.  */
+  key = add_string (str, len);
+  hash_insert_at (&strings, key, slot);
+  return key;
+}
+
+/* Returns true if the string is in the cache; false if not.  */
+int
+strcache_iscached (const char *str)
+{
+  struct strcache *sp;
+
+  for (sp = strcache; sp != 0; sp = sp->next)
+    if (str >= sp->buffer && str < sp->buffer + sp->end)
+      return 1;
+  for (sp = fullcache; sp != 0; sp = sp->next)
+    if (str >= sp->buffer && str < sp->buffer + sp->end)
+      return 1;
+
+  {
+    struct hugestring *hp;
+    for (hp = hugestrings; hp != 0; hp = hp->next)
+      if (str == hp->buffer)
+        return 1;
+  }
+
+  return 0;
+}
+
+/* If the string is already in the cache, return a pointer to the cached
+   version.  If not, add it then return a pointer to the cached version.
+   Note we do NOT take control of the string passed in.  */
+const char *
+strcache_add (const char *str)
+{
+  return add_hash (str, strlen (str));
+}
+
+const char *
+strcache_add_len (const char *str, unsigned int len)
+{
+  /* If we're not given a nul-terminated string we have to create one, because
+     the hashing functions expect it.  */
+  if (str[len] != '\0')
+    {
+      char *key = alloca (len + 1);
+      memcpy (key, str, len);
+      key[len] = '\0';
+      str = key;
+    }
+
+  return add_hash (str, len);
+}
+
+void
+strcache_init (void)
+{
+  hash_init (&strings, 8000, str_hash_1, str_hash_2, str_hash_cmp);
+}
+
+
+/* Generate some stats output.  */
+
+void
+strcache_print_stats (const char *prefix)
+{
+  const struct strcache *sp;
+  unsigned long numbuffs = 0, fullbuffs = 0;
+  unsigned long totfree = 0, maxfree = 0, minfree = BUFSIZE;
+
+  if (! strcache)
+    {
+      printf (_("\n%s No strcache buffers\n"), prefix);
+      return;
+    }
+
+  /* Count the first buffer separately since it's not full.  */
+  for (sp = strcache->next; sp != NULL; sp = sp->next)
+    {
+      sc_buflen_t bf = sp->bytesfree;
+
+      totfree += bf;
+      maxfree = (bf > maxfree ? bf : maxfree);
+      minfree = (bf < minfree ? bf : minfree);
+
+      ++numbuffs;
+    }
+  for (sp = fullcache; sp != NULL; sp = sp->next)
+    {
+      sc_buflen_t bf = sp->bytesfree;
+
+      totfree += bf;
+      maxfree = (bf > maxfree ? bf : maxfree);
+      minfree = (bf < minfree ? bf : minfree);
+
+      ++numbuffs;
+      ++fullbuffs;
+    }
+
+  /* Make sure we didn't lose any buffers.  */
+  assert (total_buffers == numbuffs + 1);
+
+  printf (_("\n%s strcache buffers: %lu (%lu) / strings = %lu / storage = %lu B / avg = %lu B\n"),
+          prefix, numbuffs + 1, fullbuffs, total_strings, total_size,
+          (total_size / total_strings));
+
+  printf (_("%s current buf: size = %hu B / used = %hu B / count = %hu / avg = %hu B\n"),
+          prefix, (sc_buflen_t)BUFSIZE, strcache->end, strcache->count,
+          (strcache->end / strcache->count));
+
+  if (numbuffs)
+    {
+      /* Show information about non-current buffers.  */
+      unsigned long sz = total_size - strcache->end;
+      unsigned long cnt = total_strings - strcache->count;
+      sc_buflen_t avgfree = totfree / numbuffs;
+
+      printf (_("%s other used: total = %lu B / count = %lu / avg = %lu B\n"),
+              prefix, sz, cnt, sz / cnt);
+
+      printf (_("%s other free: total = %lu B / max = %lu B / min = %lu B / avg = %hu B\n"),
+              prefix, totfree, maxfree, minfree, avgfree);
+    }
+
+  printf (_("\n%s strcache performance: lookups = %lu / hit rate = %lu%%\n"),
+          prefix, total_adds, (long unsigned)(100.0 * (total_adds - total_strings) / total_adds));
+  fputs (_("# hash-table stats:\n# "), stdout);
+  hash_print_stats (&strings, stdout);
+}
diff --git a/src/variable.c b/src/variable.c
new file mode 100644
index 0000000..2c68cea
--- /dev/null
+++ b/src/variable.c
@@ -0,0 +1,1822 @@
+/* Internals of variables for GNU Make.
+Copyright (C) 1988-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+
+#include <assert.h>
+
+#include "filedef.h"
+#include "dep.h"
+#include "job.h"
+#include "commands.h"
+#include "variable.h"
+#include "rule.h"
+#ifdef WINDOWS32
+#include "pathstuff.h"
+#endif
+#include "hash.h"
+
+/* Incremented every time we add or remove a global variable.  */
+static unsigned long variable_changenum;
+
+/* Chain of all pattern-specific variables.  */
+
+static struct pattern_var *pattern_vars;
+
+/* Pointer to the last struct in the pack of a specific size, from 1 to 255.*/
+
+static struct pattern_var *last_pattern_vars[256];
+
+/* Create a new pattern-specific variable struct. The new variable is
+   inserted into the PATTERN_VARS list in the shortest patterns first
+   order to support the shortest stem matching (the variables are
+   matched in the reverse order so the ones with the longest pattern
+   will be considered first). Variables with the same pattern length
+   are inserted in the definition order. */
+
+struct pattern_var *
+create_pattern_var (const char *target, const char *suffix)
+{
+  unsigned int len = strlen (target);
+  struct pattern_var *p = xcalloc (sizeof (struct pattern_var));
+
+  if (pattern_vars != 0)
+    {
+      if (len < 256 && last_pattern_vars[len] != 0)
+        {
+          p->next = last_pattern_vars[len]->next;
+          last_pattern_vars[len]->next = p;
+        }
+      else
+        {
+          /* Find the position where we can insert this variable. */
+          struct pattern_var **v;
+
+          for (v = &pattern_vars; ; v = &(*v)->next)
+            {
+              /* Insert at the end of the pack so that patterns with the
+                 same length appear in the order they were defined .*/
+
+              if (*v == 0 || (*v)->len > len)
+                {
+                  p->next = *v;
+                  *v = p;
+                  break;
+                }
+            }
+        }
+    }
+  else
+    {
+      pattern_vars = p;
+      p->next = 0;
+    }
+
+  p->target = target;
+  p->len = len;
+  p->suffix = suffix + 1;
+
+  if (len < 256)
+    last_pattern_vars[len] = p;
+
+  return p;
+}
+
+/* Look up a target in the pattern-specific variable list.  */
+
+static struct pattern_var *
+lookup_pattern_var (struct pattern_var *start, const char *target)
+{
+  struct pattern_var *p;
+  unsigned int targlen = strlen (target);
+
+  for (p = start ? start->next : pattern_vars; p != 0; p = p->next)
+    {
+      const char *stem;
+      unsigned int stemlen;
+
+      if (p->len > targlen)
+        /* It can't possibly match.  */
+        continue;
+
+      /* From the lengths of the filename and the pattern parts,
+         find the stem: the part of the filename that matches the %.  */
+      stem = target + (p->suffix - p->target - 1);
+      stemlen = targlen - p->len + 1;
+
+      /* Compare the text in the pattern before the stem, if any.  */
+      if (stem > target && !strneq (p->target, target, stem - target))
+        continue;
+
+      /* Compare the text in the pattern after the stem, if any.
+         We could test simply using streq, but this way we compare the
+         first two characters immediately.  This saves time in the very
+         common case where the first character matches because it is a
+         period.  */
+      if (*p->suffix == stem[stemlen]
+          && (*p->suffix == '\0' || streq (&p->suffix[1], &stem[stemlen+1])))
+        break;
+    }
+
+  return p;
+}
+
+/* Hash table of all global variable definitions.  */
+
+static unsigned long
+variable_hash_1 (const void *keyv)
+{
+  struct variable const *key = (struct variable const *) keyv;
+  return_STRING_N_HASH_1 (key->name, key->length);
+}
+
+static unsigned long
+variable_hash_2 (const void *keyv)
+{
+  struct variable const *key = (struct variable const *) keyv;
+  return_STRING_N_HASH_2 (key->name, key->length);
+}
+
+static int
+variable_hash_cmp (const void *xv, const void *yv)
+{
+  struct variable const *x = (struct variable const *) xv;
+  struct variable const *y = (struct variable const *) yv;
+  int result = x->length - y->length;
+  if (result)
+    return result;
+  return_STRING_N_COMPARE (x->name, y->name, x->length);
+}
+
+#ifndef VARIABLE_BUCKETS
+#define VARIABLE_BUCKETS                523
+#endif
+#ifndef PERFILE_VARIABLE_BUCKETS
+#define PERFILE_VARIABLE_BUCKETS        23
+#endif
+#ifndef SMALL_SCOPE_VARIABLE_BUCKETS
+#define SMALL_SCOPE_VARIABLE_BUCKETS    13
+#endif
+
+static struct variable_set global_variable_set;
+static struct variable_set_list global_setlist
+  = { 0, &global_variable_set, 0 };
+struct variable_set_list *current_variable_set_list = &global_setlist;
+
+/* Implement variables.  */
+
+void
+init_hash_global_variable_set (void)
+{
+  hash_init (&global_variable_set.table, VARIABLE_BUCKETS,
+             variable_hash_1, variable_hash_2, variable_hash_cmp);
+}
+
+/* Define variable named NAME with value VALUE in SET.  VALUE is copied.
+   LENGTH is the length of NAME, which does not need to be null-terminated.
+   ORIGIN specifies the origin of the variable (makefile, command line
+   or environment).
+   If RECURSIVE is nonzero a flag is set in the variable saying
+   that it should be recursively re-expanded.  */
+
+struct variable *
+define_variable_in_set (const char *name, unsigned int length,
+                        const char *value, enum variable_origin origin,
+                        int recursive, struct variable_set *set,
+                        const floc *flocp)
+{
+  struct variable *v;
+  struct variable **var_slot;
+  struct variable var_key;
+
+  if (set == NULL)
+    set = &global_variable_set;
+
+  var_key.name = (char *) name;
+  var_key.length = length;
+  var_slot = (struct variable **) hash_find_slot (&set->table, &var_key);
+  v = *var_slot;
+
+#ifdef VMS
+  /* VMS does not populate envp[] with DCL symbols and logical names which
+     historically are mapped to environent variables.
+     If the variable is not yet defined, then we need to check if getenv()
+     can find it.  Do not do this for origin == o_env to avoid infinte
+     recursion */
+  if (HASH_VACANT (v) && (origin != o_env))
+    {
+      struct variable * vms_variable;
+      char * vname = alloca (length + 1);
+      char * vvalue;
+
+      strncpy (vname, name, length);
+      vvalue = getenv(vname);
+
+      /* Values starting with '$' are probably foreign commands.
+         We want to treat them as Shell aliases and not look them up here */
+      if ((vvalue != NULL) && (vvalue[0] != '$'))
+        {
+          vms_variable =  lookup_variable(name, length);
+          /* Refresh the slot */
+          var_slot = (struct variable **) hash_find_slot (&set->table,
+                                                          &var_key);
+          v = *var_slot;
+        }
+    }
+#endif
+
+  if (env_overrides && origin == o_env)
+    origin = o_env_override;
+
+  if (! HASH_VACANT (v))
+    {
+      if (env_overrides && v->origin == o_env)
+        /* V came from in the environment.  Since it was defined
+           before the switches were parsed, it wasn't affected by -e.  */
+        v->origin = o_env_override;
+
+      /* A variable of this name is already defined.
+         If the old definition is from a stronger source
+         than this one, don't redefine it.  */
+      if ((int) origin >= (int) v->origin)
+        {
+          free (v->value);
+          v->value = xstrdup (value);
+          if (flocp != 0)
+            v->fileinfo = *flocp;
+          else
+            v->fileinfo.filenm = 0;
+          v->origin = origin;
+          v->recursive = recursive;
+        }
+      return v;
+    }
+
+  /* Create a new variable definition and add it to the hash table.  */
+
+  v = xmalloc (sizeof (struct variable));
+  v->name = xstrndup (name, length);
+  v->length = length;
+  hash_insert_at (&set->table, v, var_slot);
+  if (set == &global_variable_set)
+    ++variable_changenum;
+
+  v->value = xstrdup (value);
+  if (flocp != 0)
+    v->fileinfo = *flocp;
+  else
+    v->fileinfo.filenm = 0;
+  v->origin = origin;
+  v->recursive = recursive;
+  v->special = 0;
+  v->expanding = 0;
+  v->exp_count = 0;
+  v->per_target = 0;
+  v->append = 0;
+  v->private_var = 0;
+  v->export = v_default;
+
+  v->exportable = 1;
+  if (*name != '_' && (*name < 'A' || *name > 'Z')
+      && (*name < 'a' || *name > 'z'))
+    v->exportable = 0;
+  else
+    {
+      for (++name; *name != '\0'; ++name)
+        if (*name != '_' && (*name < 'a' || *name > 'z')
+            && (*name < 'A' || *name > 'Z') && !ISDIGIT(*name))
+          break;
+
+      if (*name != '\0')
+        v->exportable = 0;
+    }
+
+  return v;
+}
+
+
+/* Undefine variable named NAME in SET. LENGTH is the length of NAME, which
+   does not need to be null-terminated. ORIGIN specifies the origin of the
+   variable (makefile, command line or environment). */
+
+static void
+free_variable_name_and_value (const void *item)
+{
+  struct variable *v = (struct variable *) item;
+  free (v->name);
+  free (v->value);
+}
+
+void
+free_variable_set (struct variable_set_list *list)
+{
+  hash_map (&list->set->table, free_variable_name_and_value);
+  hash_free (&list->set->table, 1);
+  free (list->set);
+  free (list);
+}
+
+void
+undefine_variable_in_set (const char *name, unsigned int length,
+                          enum variable_origin origin,
+                          struct variable_set *set)
+{
+  struct variable *v;
+  struct variable **var_slot;
+  struct variable var_key;
+
+  if (set == NULL)
+    set = &global_variable_set;
+
+  var_key.name = (char *) name;
+  var_key.length = length;
+  var_slot = (struct variable **) hash_find_slot (&set->table, &var_key);
+
+  if (env_overrides && origin == o_env)
+    origin = o_env_override;
+
+  v = *var_slot;
+  if (! HASH_VACANT (v))
+    {
+      if (env_overrides && v->origin == o_env)
+        /* V came from in the environment.  Since it was defined
+           before the switches were parsed, it wasn't affected by -e.  */
+        v->origin = o_env_override;
+
+      /* Undefine only if this undefinition is from an equal or stronger
+         source than the variable definition.  */
+      if ((int) origin >= (int) v->origin)
+        {
+          hash_delete_at (&set->table, var_slot);
+          free_variable_name_and_value (v);
+          free (v);
+          if (set == &global_variable_set)
+            ++variable_changenum;
+        }
+    }
+}
+
+/* If the variable passed in is "special", handle its special nature.
+   Currently there are two such variables, both used for introspection:
+   .VARIABLES expands to a list of all the variables defined in this instance
+   of make.
+   .TARGETS expands to a list of all the targets defined in this
+   instance of make.
+   Returns the variable reference passed in.  */
+
+#define EXPANSION_INCREMENT(_l)  ((((_l) / 500) + 1) * 500)
+
+static struct variable *
+lookup_special_var (struct variable *var)
+{
+  static unsigned long last_changenum = 0;
+
+
+  /* This one actually turns out to be very hard, due to the way the parser
+     records targets.  The way it works is that target information is collected
+     internally until make knows the target is completely specified.  It unitl
+     it sees that some new construct (a new target or variable) is defined that
+     it knows the previous one is done.  In short, this means that if you do
+     this:
+
+       all:
+
+       TARGS := $(.TARGETS)
+
+     then $(TARGS) won't contain "all", because it's not until after the
+     variable is created that the previous target is completed.
+
+     Changing this would be a major pain.  I think a less complex way to do it
+     would be to pre-define the target files as soon as the first line is
+     parsed, then come back and do the rest of the definition as now.  That
+     would allow $(.TARGETS) to be correct without a major change to the way
+     the parser works.
+
+  if (streq (var->name, ".TARGETS"))
+    var->value = build_target_list (var->value);
+  else
+  */
+
+  if (variable_changenum != last_changenum && streq (var->name, ".VARIABLES"))
+    {
+      unsigned long max = EXPANSION_INCREMENT (strlen (var->value));
+      unsigned long len;
+      char *p;
+      struct variable **vp = (struct variable **) global_variable_set.table.ht_vec;
+      struct variable **end = &vp[global_variable_set.table.ht_size];
+
+      /* Make sure we have at least MAX bytes in the allocated buffer.  */
+      var->value = xrealloc (var->value, max);
+
+      /* Walk through the hash of variables, constructing a list of names.  */
+      p = var->value;
+      len = 0;
+      for (; vp < end; ++vp)
+        if (!HASH_VACANT (*vp))
+          {
+            struct variable *v = *vp;
+            int l = v->length;
+
+            len += l + 1;
+            if (len > max)
+              {
+                unsigned long off = p - var->value;
+
+                max += EXPANSION_INCREMENT (l + 1);
+                var->value = xrealloc (var->value, max);
+                p = &var->value[off];
+              }
+
+            memcpy (p, v->name, l);
+            p += l;
+            *(p++) = ' ';
+          }
+      *(p-1) = '\0';
+
+      /* Remember the current variable change number.  */
+      last_changenum = variable_changenum;
+    }
+
+  return var;
+}
+
+
+/* Lookup a variable whose name is a string starting at NAME
+   and with LENGTH chars.  NAME need not be null-terminated.
+   Returns address of the 'struct variable' containing all info
+   on the variable, or nil if no such variable is defined.  */
+
+struct variable *
+lookup_variable (const char *name, unsigned int length)
+{
+  const struct variable_set_list *setlist;
+  struct variable var_key;
+  int is_parent = 0;
+
+  var_key.name = (char *) name;
+  var_key.length = length;
+
+  for (setlist = current_variable_set_list;
+       setlist != 0; setlist = setlist->next)
+    {
+      const struct variable_set *set = setlist->set;
+      struct variable *v;
+
+      v = (struct variable *) hash_find_item ((struct hash_table *) &set->table, &var_key);
+      if (v && (!is_parent || !v->private_var))
+        return v->special ? lookup_special_var (v) : v;
+
+      is_parent |= setlist->next_is_parent;
+    }
+
+#ifdef VMS
+  /* VMS does not populate envp[] with DCL symbols and logical names which
+     historically are mapped to enviroment varables and returned by getenv() */
+  {
+    char *vname = alloca (length + 1);
+    char *value;
+    strncpy (vname, name, length);
+    vname[length] = 0;
+    value = getenv (vname);
+    if (value != 0)
+      {
+        char *sptr;
+        int scnt;
+
+        sptr = value;
+        scnt = 0;
+
+        while ((sptr = strchr (sptr, '$')))
+          {
+            scnt++;
+            sptr++;
+          }
+
+        if (scnt > 0)
+          {
+            char *nvalue;
+            char *nptr;
+
+            nvalue = alloca (strlen (value) + scnt + 1);
+            sptr = value;
+            nptr = nvalue;
+
+            while (*sptr)
+              {
+                if (*sptr == '$')
+                  {
+                    *nptr++ = '$';
+                    *nptr++ = '$';
+                  }
+                else
+                  {
+                    *nptr++ = *sptr;
+                  }
+                sptr++;
+              }
+
+            *nptr = '\0';
+            return define_variable (vname, length, nvalue, o_env, 1);
+
+          }
+
+        return define_variable (vname, length, value, o_env, 1);
+      }
+  }
+#endif /* VMS */
+
+  return 0;
+}
+
+/* Lookup a variable whose name is a string starting at NAME
+   and with LENGTH chars in set SET.  NAME need not be null-terminated.
+   Returns address of the 'struct variable' containing all info
+   on the variable, or nil if no such variable is defined.  */
+
+struct variable *
+lookup_variable_in_set (const char *name, unsigned int length,
+                        const struct variable_set *set)
+{
+  struct variable var_key;
+
+  var_key.name = (char *) name;
+  var_key.length = length;
+
+  return (struct variable *) hash_find_item ((struct hash_table *) &set->table, &var_key);
+}
+
+/* Initialize FILE's variable set list.  If FILE already has a variable set
+   list, the topmost variable set is left intact, but the the rest of the
+   chain is replaced with FILE->parent's setlist.  If FILE is a double-colon
+   rule, then we will use the "root" double-colon target's variable set as the
+   parent of FILE's variable set.
+
+   If we're READING a makefile, don't do the pattern variable search now,
+   since the pattern variable might not have been defined yet.  */
+
+void
+initialize_file_variables (struct file *file, int reading)
+{
+  struct variable_set_list *l = file->variables;
+
+  if (l == 0)
+    {
+      l = (struct variable_set_list *)
+        xmalloc (sizeof (struct variable_set_list));
+      l->set = xmalloc (sizeof (struct variable_set));
+      hash_init (&l->set->table, PERFILE_VARIABLE_BUCKETS,
+                 variable_hash_1, variable_hash_2, variable_hash_cmp);
+      file->variables = l;
+    }
+
+  /* If this is a double-colon, then our "parent" is the "root" target for
+     this double-colon rule.  Since that rule has the same name, parent,
+     etc. we can just use its variables as the "next" for ours.  */
+
+  if (file->double_colon && file->double_colon != file)
+    {
+      initialize_file_variables (file->double_colon, reading);
+      l->next = file->double_colon->variables;
+      l->next_is_parent = 0;
+      return;
+    }
+
+  if (file->parent == 0)
+    l->next = &global_setlist;
+  else
+    {
+      initialize_file_variables (file->parent, reading);
+      l->next = file->parent->variables;
+    }
+  l->next_is_parent = 1;
+
+  /* If we're not reading makefiles and we haven't looked yet, see if
+     we can find pattern variables for this target.  */
+
+  if (!reading && !file->pat_searched)
+    {
+      struct pattern_var *p;
+
+      p = lookup_pattern_var (0, file->name);
+      if (p != 0)
+        {
+          struct variable_set_list *global = current_variable_set_list;
+
+          /* We found at least one.  Set up a new variable set to accumulate
+             all the pattern variables that match this target.  */
+
+          file->pat_variables = create_new_variable_set ();
+          current_variable_set_list = file->pat_variables;
+
+          do
+            {
+              /* We found one, so insert it into the set.  */
+
+              struct variable *v;
+
+              if (p->variable.flavor == f_simple)
+                {
+                  v = define_variable_loc (
+                    p->variable.name, strlen (p->variable.name),
+                    p->variable.value, p->variable.origin,
+                    0, &p->variable.fileinfo);
+
+                  v->flavor = f_simple;
+                }
+              else
+                {
+                  v = do_variable_definition (
+                    &p->variable.fileinfo, p->variable.name,
+                    p->variable.value, p->variable.origin,
+                    p->variable.flavor, 1);
+                }
+
+              /* Also mark it as a per-target and copy export status. */
+              v->per_target = p->variable.per_target;
+              v->export = p->variable.export;
+              v->private_var = p->variable.private_var;
+            }
+          while ((p = lookup_pattern_var (p, file->name)) != 0);
+
+          current_variable_set_list = global;
+        }
+      file->pat_searched = 1;
+    }
+
+  /* If we have a pattern variable match, set it up.  */
+
+  if (file->pat_variables != 0)
+    {
+      file->pat_variables->next = l->next;
+      file->pat_variables->next_is_parent = l->next_is_parent;
+      l->next = file->pat_variables;
+      l->next_is_parent = 0;
+    }
+}
+
+/* Pop the top set off the current variable set list,
+   and free all its storage.  */
+
+struct variable_set_list *
+create_new_variable_set (void)
+{
+  struct variable_set_list *setlist;
+  struct variable_set *set;
+
+  set = xmalloc (sizeof (struct variable_set));
+  hash_init (&set->table, SMALL_SCOPE_VARIABLE_BUCKETS,
+             variable_hash_1, variable_hash_2, variable_hash_cmp);
+
+  setlist = (struct variable_set_list *)
+    xmalloc (sizeof (struct variable_set_list));
+  setlist->set = set;
+  setlist->next = current_variable_set_list;
+  setlist->next_is_parent = 0;
+
+  return setlist;
+}
+
+/* Create a new variable set and push it on the current setlist.
+   If we're pushing a global scope (that is, the current scope is the global
+   scope) then we need to "push" it the other way: file variable sets point
+   directly to the global_setlist so we need to replace that with the new one.
+ */
+
+struct variable_set_list *
+push_new_variable_scope (void)
+{
+  current_variable_set_list = create_new_variable_set ();
+  if (current_variable_set_list->next == &global_setlist)
+    {
+      /* It was the global, so instead of new -> &global we want to replace
+         &global with the new one and have &global -> new, with current still
+         pointing to &global  */
+      struct variable_set *set = current_variable_set_list->set;
+      current_variable_set_list->set = global_setlist.set;
+      global_setlist.set = set;
+      current_variable_set_list->next = global_setlist.next;
+      global_setlist.next = current_variable_set_list;
+      current_variable_set_list = &global_setlist;
+    }
+  return (current_variable_set_list);
+}
+
+void
+pop_variable_scope (void)
+{
+  struct variable_set_list *setlist;
+  struct variable_set *set;
+
+  /* Can't call this if there's no scope to pop!  */
+  assert (current_variable_set_list->next != NULL);
+
+  if (current_variable_set_list != &global_setlist)
+    {
+      /* We're not pointing to the global setlist, so pop this one.  */
+      setlist = current_variable_set_list;
+      set = setlist->set;
+      current_variable_set_list = setlist->next;
+    }
+  else
+    {
+      /* This set is the one in the global_setlist, but there is another global
+         set beyond that.  We want to copy that set to global_setlist, then
+         delete what used to be in global_setlist.  */
+      setlist = global_setlist.next;
+      set = global_setlist.set;
+      global_setlist.set = setlist->set;
+      global_setlist.next = setlist->next;
+      global_setlist.next_is_parent = setlist->next_is_parent;
+    }
+
+  /* Free the one we no longer need.  */
+  free (setlist);
+  hash_map (&set->table, free_variable_name_and_value);
+  hash_free (&set->table, 1);
+  free (set);
+}
+
+/* Merge FROM_SET into TO_SET, freeing unused storage in FROM_SET.  */
+
+static void
+merge_variable_sets (struct variable_set *to_set,
+                     struct variable_set *from_set)
+{
+  struct variable **from_var_slot = (struct variable **) from_set->table.ht_vec;
+  struct variable **from_var_end = from_var_slot + from_set->table.ht_size;
+
+  int inc = to_set == &global_variable_set ? 1 : 0;
+
+  for ( ; from_var_slot < from_var_end; from_var_slot++)
+    if (! HASH_VACANT (*from_var_slot))
+      {
+        struct variable *from_var = *from_var_slot;
+        struct variable **to_var_slot
+          = (struct variable **) hash_find_slot (&to_set->table, *from_var_slot);
+        if (HASH_VACANT (*to_var_slot))
+          {
+            hash_insert_at (&to_set->table, from_var, to_var_slot);
+            variable_changenum += inc;
+          }
+        else
+          {
+            /* GKM FIXME: delete in from_set->table */
+            free (from_var->value);
+            free (from_var);
+          }
+      }
+}
+
+/* Merge SETLIST1 into SETLIST0, freeing unused storage in SETLIST1.  */
+
+void
+merge_variable_set_lists (struct variable_set_list **setlist0,
+                          struct variable_set_list *setlist1)
+{
+  struct variable_set_list *to = *setlist0;
+  struct variable_set_list *last0 = 0;
+
+  /* If there's nothing to merge, stop now.  */
+  if (!setlist1)
+    return;
+
+  /* This loop relies on the fact that all setlists terminate with the global
+     setlist (before NULL).  If that's not true, arguably we SHOULD die.  */
+  if (to)
+    while (setlist1 != &global_setlist && to != &global_setlist)
+      {
+        struct variable_set_list *from = setlist1;
+        setlist1 = setlist1->next;
+
+        merge_variable_sets (to->set, from->set);
+
+        last0 = to;
+        to = to->next;
+      }
+
+  if (setlist1 != &global_setlist)
+    {
+      if (last0 == 0)
+        *setlist0 = setlist1;
+      else
+        last0->next = setlist1;
+    }
+}
+
+/* Define the automatic variables, and record the addresses
+   of their structures so we can change their values quickly.  */
+
+void
+define_automatic_variables (void)
+{
+  struct variable *v;
+  char buf[200];
+
+  sprintf (buf, "%u", makelevel);
+  define_variable_cname (MAKELEVEL_NAME, buf, o_env, 0);
+
+  sprintf (buf, "%s%s%s",
+           version_string,
+           (remote_description == 0 || remote_description[0] == '\0')
+           ? "" : "-",
+           (remote_description == 0 || remote_description[0] == '\0')
+           ? "" : remote_description);
+  define_variable_cname ("MAKE_VERSION", buf, o_default, 0);
+  define_variable_cname ("MAKE_HOST", make_host, o_default, 0);
+
+#ifdef  __MSDOS__
+  /* Allow to specify a special shell just for Make,
+     and use $COMSPEC as the default $SHELL when appropriate.  */
+  {
+    static char shell_str[] = "SHELL";
+    const int shlen = sizeof (shell_str) - 1;
+    struct variable *mshp = lookup_variable ("MAKESHELL", 9);
+    struct variable *comp = lookup_variable ("COMSPEC", 7);
+
+    /* $(MAKESHELL) overrides $(SHELL) even if -e is in effect.  */
+    if (mshp)
+      (void) define_variable (shell_str, shlen,
+                              mshp->value, o_env_override, 0);
+    else if (comp)
+      {
+        /* $(COMSPEC) shouldn't override $(SHELL).  */
+        struct variable *shp = lookup_variable (shell_str, shlen);
+
+        if (!shp)
+          (void) define_variable (shell_str, shlen, comp->value, o_env, 0);
+      }
+  }
+#elif defined(__EMX__)
+  {
+    static char shell_str[] = "SHELL";
+    const int shlen = sizeof (shell_str) - 1;
+    struct variable *shell = lookup_variable (shell_str, shlen);
+    struct variable *replace = lookup_variable ("MAKESHELL", 9);
+
+    /* if $MAKESHELL is defined in the environment assume o_env_override */
+    if (replace && *replace->value && replace->origin == o_env)
+      replace->origin = o_env_override;
+
+    /* if $MAKESHELL is not defined use $SHELL but only if the variable
+       did not come from the environment */
+    if (!replace || !*replace->value)
+      if (shell && *shell->value && (shell->origin == o_env
+          || shell->origin == o_env_override))
+        {
+          /* overwrite whatever we got from the environment */
+          free (shell->value);
+          shell->value = xstrdup (default_shell);
+          shell->origin = o_default;
+        }
+
+    /* Some people do not like cmd to be used as the default
+       if $SHELL is not defined in the Makefile.
+       With -DNO_CMD_DEFAULT you can turn off this behaviour */
+# ifndef NO_CMD_DEFAULT
+    /* otherwise use $COMSPEC */
+    if (!replace || !*replace->value)
+      replace = lookup_variable ("COMSPEC", 7);
+
+    /* otherwise use $OS2_SHELL */
+    if (!replace || !*replace->value)
+      replace = lookup_variable ("OS2_SHELL", 9);
+# else
+#   warning NO_CMD_DEFAULT: GNU make will not use CMD.EXE as default shell
+# endif
+
+    if (replace && *replace->value)
+      /* overwrite $SHELL */
+      (void) define_variable (shell_str, shlen, replace->value,
+                              replace->origin, 0);
+    else
+      /* provide a definition if there is none */
+      (void) define_variable (shell_str, shlen, default_shell,
+                              o_default, 0);
+  }
+
+#endif
+
+  /* This won't override any definition, but it will provide one if there
+     isn't one there.  */
+  v = define_variable_cname ("SHELL", default_shell, o_default, 0);
+#ifdef __MSDOS__
+  v->export = v_export;  /*  Export always SHELL.  */
+#endif
+
+  /* On MSDOS we do use SHELL from environment, since it isn't a standard
+     environment variable on MSDOS, so whoever sets it, does that on purpose.
+     On OS/2 we do not use SHELL from environment but we have already handled
+     that problem above. */
+#if !defined(__MSDOS__) && !defined(__EMX__)
+  /* Don't let SHELL come from the environment.  */
+  if (*v->value == '\0' || v->origin == o_env || v->origin == o_env_override)
+    {
+      free (v->value);
+      v->origin = o_file;
+      v->value = xstrdup (default_shell);
+    }
+#endif
+
+  /* Make sure MAKEFILES gets exported if it is set.  */
+  v = define_variable_cname ("MAKEFILES", "", o_default, 0);
+  v->export = v_ifset;
+
+  /* Define the magic D and F variables in terms of
+     the automatic variables they are variations of.  */
+
+#if defined(__MSDOS__) || defined(WINDOWS32)
+  /* For consistency, remove the trailing backslash as well as slash.  */
+  define_variable_cname ("@D", "$(patsubst %/,%,$(patsubst %\\,%,$(dir $@)))",
+                         o_automatic, 1);
+  define_variable_cname ("%D", "$(patsubst %/,%,$(patsubst %\\,%,$(dir $%)))",
+                         o_automatic, 1);
+  define_variable_cname ("*D", "$(patsubst %/,%,$(patsubst %\\,%,$(dir $*)))",
+                         o_automatic, 1);
+  define_variable_cname ("<D", "$(patsubst %/,%,$(patsubst %\\,%,$(dir $<)))",
+                         o_automatic, 1);
+  define_variable_cname ("?D", "$(patsubst %/,%,$(patsubst %\\,%,$(dir $?)))",
+                         o_automatic, 1);
+  define_variable_cname ("^D", "$(patsubst %/,%,$(patsubst %\\,%,$(dir $^)))",
+                         o_automatic, 1);
+  define_variable_cname ("+D", "$(patsubst %/,%,$(patsubst %\\,%,$(dir $+)))",
+                         o_automatic, 1);
+#else  /* not __MSDOS__, not WINDOWS32 */
+  define_variable_cname ("@D", "$(patsubst %/,%,$(dir $@))", o_automatic, 1);
+  define_variable_cname ("%D", "$(patsubst %/,%,$(dir $%))", o_automatic, 1);
+  define_variable_cname ("*D", "$(patsubst %/,%,$(dir $*))", o_automatic, 1);
+  define_variable_cname ("<D", "$(patsubst %/,%,$(dir $<))", o_automatic, 1);
+  define_variable_cname ("?D", "$(patsubst %/,%,$(dir $?))", o_automatic, 1);
+  define_variable_cname ("^D", "$(patsubst %/,%,$(dir $^))", o_automatic, 1);
+  define_variable_cname ("+D", "$(patsubst %/,%,$(dir $+))", o_automatic, 1);
+#endif
+  define_variable_cname ("@F", "$(notdir $@)", o_automatic, 1);
+  define_variable_cname ("%F", "$(notdir $%)", o_automatic, 1);
+  define_variable_cname ("*F", "$(notdir $*)", o_automatic, 1);
+  define_variable_cname ("<F", "$(notdir $<)", o_automatic, 1);
+  define_variable_cname ("?F", "$(notdir $?)", o_automatic, 1);
+  define_variable_cname ("^F", "$(notdir $^)", o_automatic, 1);
+  define_variable_cname ("+F", "$(notdir $+)", o_automatic, 1);
+}
+
+int export_all_variables;
+
+/* Create a new environment for FILE's commands.
+   If FILE is nil, this is for the 'shell' function.
+   The child's MAKELEVEL variable is incremented.  */
+
+char **
+target_environment (struct file *file)
+{
+  struct variable_set_list *set_list;
+  struct variable_set_list *s;
+  struct hash_table table;
+  struct variable **v_slot;
+  struct variable **v_end;
+  struct variable makelevel_key;
+  char **result_0;
+  char **result;
+
+  if (file == 0)
+    set_list = current_variable_set_list;
+  else
+    set_list = file->variables;
+
+  hash_init (&table, VARIABLE_BUCKETS,
+             variable_hash_1, variable_hash_2, variable_hash_cmp);
+
+  /* Run through all the variable sets in the list,
+     accumulating variables in TABLE.  */
+  for (s = set_list; s != 0; s = s->next)
+    {
+      struct variable_set *set = s->set;
+      v_slot = (struct variable **) set->table.ht_vec;
+      v_end = v_slot + set->table.ht_size;
+      for ( ; v_slot < v_end; v_slot++)
+        if (! HASH_VACANT (*v_slot))
+          {
+            struct variable **new_slot;
+            struct variable *v = *v_slot;
+
+            /* If this is a per-target variable and it hasn't been touched
+               already then look up the global version and take its export
+               value.  */
+            if (v->per_target && v->export == v_default)
+              {
+                struct variable *gv;
+
+                gv = lookup_variable_in_set (v->name, strlen (v->name),
+                                             &global_variable_set);
+                if (gv)
+                  v->export = gv->export;
+              }
+
+            switch (v->export)
+              {
+              case v_default:
+                if (v->origin == o_default || v->origin == o_automatic)
+                  /* Only export default variables by explicit request.  */
+                  continue;
+
+                /* The variable doesn't have a name that can be exported.  */
+                if (! v->exportable)
+                  continue;
+
+                if (! export_all_variables
+                    && v->origin != o_command
+                    && v->origin != o_env && v->origin != o_env_override)
+                  continue;
+                break;
+
+              case v_export:
+                break;
+
+              case v_noexport:
+                {
+                  /* If this is the SHELL variable and it's not exported,
+                     then add the value from our original environment, if
+                     the original environment defined a value for SHELL.  */
+                  if (streq (v->name, "SHELL") && shell_var.value)
+                    {
+                      v = &shell_var;
+                      break;
+                    }
+                  continue;
+                }
+
+              case v_ifset:
+                if (v->origin == o_default)
+                  continue;
+                break;
+              }
+
+            new_slot = (struct variable **) hash_find_slot (&table, v);
+            if (HASH_VACANT (*new_slot))
+              hash_insert_at (&table, v, new_slot);
+          }
+    }
+
+  makelevel_key.name = (char *)MAKELEVEL_NAME;
+  makelevel_key.length = MAKELEVEL_LENGTH;
+  hash_delete (&table, &makelevel_key);
+
+  result = result_0 = xmalloc ((table.ht_fill + 2) * sizeof (char *));
+
+  v_slot = (struct variable **) table.ht_vec;
+  v_end = v_slot + table.ht_size;
+  for ( ; v_slot < v_end; v_slot++)
+    if (! HASH_VACANT (*v_slot))
+      {
+        struct variable *v = *v_slot;
+
+        /* If V is recursively expanded and didn't come from the environment,
+           expand its value.  If it came from the environment, it should
+           go back into the environment unchanged.  */
+        if (v->recursive
+            && v->origin != o_env && v->origin != o_env_override)
+          {
+            char *value = recursively_expand_for_file (v, file);
+#ifdef WINDOWS32
+            if (strcmp (v->name, "Path") == 0 ||
+                strcmp (v->name, "PATH") == 0)
+              convert_Path_to_windows32 (value, ';');
+#endif
+            *result++ = xstrdup (concat (3, v->name, "=", value));
+            free (value);
+          }
+        else
+          {
+#ifdef WINDOWS32
+            if (strcmp (v->name, "Path") == 0 ||
+                strcmp (v->name, "PATH") == 0)
+              convert_Path_to_windows32 (v->value, ';');
+#endif
+            *result++ = xstrdup (concat (3, v->name, "=", v->value));
+          }
+      }
+
+  *result = xmalloc (100);
+  sprintf (*result, "%s=%u", MAKELEVEL_NAME, makelevel + 1);
+  *++result = 0;
+
+  hash_free (&table, 0);
+
+  return result_0;
+}
+
+static struct variable *
+set_special_var (struct variable *var)
+{
+  if (streq (var->name, RECIPEPREFIX_NAME))
+    {
+      /* The user is resetting the command introduction prefix.  This has to
+         happen immediately, so that subsequent rules are interpreted
+         properly.  */
+      cmd_prefix = var->value[0]=='\0' ? RECIPEPREFIX_DEFAULT : var->value[0];
+    }
+
+  return var;
+}
+
+/* Given a string, shell-execute it and return a malloc'ed string of the
+ * result. This removes only ONE newline (if any) at the end, for maximum
+ * compatibility with the *BSD makes.  If it fails, returns NULL. */
+
+static char *
+shell_result (const char *p)
+{
+  char *buf;
+  unsigned int len;
+  char *args[2];
+  char *result;
+
+  install_variable_buffer (&buf, &len);
+
+  args[0] = (char *) p;
+  args[1] = NULL;
+  variable_buffer_output (func_shell_base (variable_buffer, args, 0), "\0", 1);
+  result = strdup (variable_buffer);
+
+  restore_variable_buffer (buf, len);
+  return result;
+}
+
+/* Given a variable, a value, and a flavor, define the variable.
+   See the try_variable_definition() function for details on the parameters. */
+
+struct variable *
+do_variable_definition (const floc *flocp, const char *varname,
+                        const char *value, enum variable_origin origin,
+                        enum variable_flavor flavor, int target_var)
+{
+  const char *p;
+  char *alloc_value = NULL;
+  struct variable *v;
+  int append = 0;
+  int conditional = 0;
+
+  /* Calculate the variable's new value in VALUE.  */
+
+  switch (flavor)
+    {
+    default:
+    case f_bogus:
+      /* Should not be possible.  */
+      abort ();
+    case f_simple:
+      /* A simple variable definition "var := value".  Expand the value.
+         We have to allocate memory since otherwise it'll clobber the
+         variable buffer, and we may still need that if we're looking at a
+         target-specific variable.  */
+      p = alloc_value = allocated_variable_expand (value);
+      break;
+    case f_shell:
+      {
+        /* A shell definition "var != value".  Expand value, pass it to
+           the shell, and store the result in recursively-expanded var. */
+        char *q = allocated_variable_expand (value);
+        p = alloc_value = shell_result (q);
+        free (q);
+        flavor = f_recursive;
+        break;
+      }
+    case f_conditional:
+      /* A conditional variable definition "var ?= value".
+         The value is set IFF the variable is not defined yet. */
+      v = lookup_variable (varname, strlen (varname));
+      if (v)
+        goto done;
+
+      conditional = 1;
+      flavor = f_recursive;
+      /* FALLTHROUGH */
+    case f_recursive:
+      /* A recursive variable definition "var = value".
+         The value is used verbatim.  */
+      p = value;
+      break;
+    case f_append:
+    case f_append_value:
+      {
+        /* If we have += but we're in a target variable context, we want to
+           append only with other variables in the context of this target.  */
+        if (target_var)
+          {
+            append = 1;
+            v = lookup_variable_in_set (varname, strlen (varname),
+                                        current_variable_set_list->set);
+
+            /* Don't append from the global set if a previous non-appending
+               target-specific variable definition exists. */
+            if (v && !v->append)
+              append = 0;
+          }
+        else
+          v = lookup_variable (varname, strlen (varname));
+
+        if (v == 0)
+          {
+            /* There was no old value.
+               This becomes a normal recursive definition.  */
+            p = value;
+            flavor = f_recursive;
+          }
+        else
+          {
+            /* Paste the old and new values together in VALUE.  */
+
+            unsigned int oldlen, vallen;
+            const char *val;
+            char *tp = NULL;
+
+            val = value;
+            if (v->recursive)
+              /* The previous definition of the variable was recursive.
+                 The new value is the unexpanded old and new values.  */
+              flavor = f_recursive;
+            else if (flavor != f_append_value)
+              /* The previous definition of the variable was simple.
+                 The new value comes from the old value, which was expanded
+                 when it was set; and from the expanded new value.  Allocate
+                 memory for the expansion as we may still need the rest of the
+                 buffer if we're looking at a target-specific variable.  */
+              val = tp = allocated_variable_expand (val);
+
+            /* If the new value is empty, nothing to do.  */
+            vallen = strlen (val);
+            if (!vallen)
+              {
+                alloc_value = tp;
+                goto done;
+              }
+
+            oldlen = strlen (v->value);
+            p = alloc_value = xmalloc (oldlen + 1 + vallen + 1);
+
+            if (oldlen)
+              {
+                memcpy (alloc_value, v->value, oldlen);
+                alloc_value[oldlen] = ' ';
+                ++oldlen;
+              }
+
+            memcpy (&alloc_value[oldlen], val, vallen + 1);
+
+            free (tp);
+          }
+        break;
+      }
+    }
+
+#ifdef __MSDOS__
+  /* Many Unix Makefiles include a line saying "SHELL=/bin/sh", but
+     non-Unix systems don't conform to this default configuration (in
+     fact, most of them don't even have '/bin').  On the other hand,
+     $SHELL in the environment, if set, points to the real pathname of
+     the shell.
+     Therefore, we generally won't let lines like "SHELL=/bin/sh" from
+     the Makefile override $SHELL from the environment.  But first, we
+     look for the basename of the shell in the directory where SHELL=
+     points, and along the $PATH; if it is found in any of these places,
+     we define $SHELL to be the actual pathname of the shell.  Thus, if
+     you have bash.exe installed as d:/unix/bash.exe, and d:/unix is on
+     your $PATH, then SHELL=/usr/local/bin/bash will have the effect of
+     defining SHELL to be "d:/unix/bash.exe".  */
+  if ((origin == o_file || origin == o_override)
+      && strcmp (varname, "SHELL") == 0)
+    {
+      PATH_VAR (shellpath);
+      extern char * __dosexec_find_on_path (const char *, char *[], char *);
+
+      /* See if we can find "/bin/sh.exe", "/bin/sh.com", etc.  */
+      if (__dosexec_find_on_path (p, NULL, shellpath))
+        {
+          char *tp;
+
+          for (tp = shellpath; *tp; tp++)
+            if (*tp == '\\')
+              *tp = '/';
+
+          v = define_variable_loc (varname, strlen (varname),
+                                   shellpath, origin, flavor == f_recursive,
+                                   flocp);
+        }
+      else
+        {
+          const char *shellbase, *bslash;
+          struct variable *pathv = lookup_variable ("PATH", 4);
+          char *path_string;
+          char *fake_env[2];
+          size_t pathlen = 0;
+
+          shellbase = strrchr (p, '/');
+          bslash = strrchr (p, '\\');
+          if (!shellbase || bslash > shellbase)
+            shellbase = bslash;
+          if (!shellbase && p[1] == ':')
+            shellbase = p + 1;
+          if (shellbase)
+            shellbase++;
+          else
+            shellbase = p;
+
+          /* Search for the basename of the shell (with standard
+             executable extensions) along the $PATH.  */
+          if (pathv)
+            pathlen = strlen (pathv->value);
+          path_string = xmalloc (5 + pathlen + 2 + 1);
+          /* On MSDOS, current directory is considered as part of $PATH.  */
+          sprintf (path_string, "PATH=.;%s", pathv ? pathv->value : "");
+          fake_env[0] = path_string;
+          fake_env[1] = 0;
+          if (__dosexec_find_on_path (shellbase, fake_env, shellpath))
+            {
+              char *tp;
+
+              for (tp = shellpath; *tp; tp++)
+                if (*tp == '\\')
+                  *tp = '/';
+
+              v = define_variable_loc (varname, strlen (varname),
+                                       shellpath, origin,
+                                       flavor == f_recursive, flocp);
+            }
+          else
+            v = lookup_variable (varname, strlen (varname));
+
+          free (path_string);
+        }
+    }
+  else
+#endif /* __MSDOS__ */
+#ifdef WINDOWS32
+  if ((origin == o_file || origin == o_override || origin == o_command)
+      && streq (varname, "SHELL"))
+    {
+      extern const char *default_shell;
+
+      /* Call shell locator function. If it returns TRUE, then
+         set no_default_sh_exe to indicate sh was found and
+         set new value for SHELL variable.  */
+
+      if (find_and_set_default_shell (p))
+        {
+          v = define_variable_in_set (varname, strlen (varname), default_shell,
+                                      origin, flavor == f_recursive,
+                                      (target_var
+                                       ? current_variable_set_list->set
+                                       : NULL),
+                                      flocp);
+          no_default_sh_exe = 0;
+        }
+      else
+        {
+          char *tp = alloc_value;
+
+          alloc_value = allocated_variable_expand (p);
+
+          if (find_and_set_default_shell (alloc_value))
+            {
+              v = define_variable_in_set (varname, strlen (varname), p,
+                                          origin, flavor == f_recursive,
+                                          (target_var
+                                           ? current_variable_set_list->set
+                                           : NULL),
+                                          flocp);
+              no_default_sh_exe = 0;
+            }
+          else
+            v = lookup_variable (varname, strlen (varname));
+
+          free (tp);
+        }
+    }
+  else
+    v = NULL;
+
+  /* If not $SHELL, or if $SHELL points to a program we didn't find,
+     just process this variable "as usual".  */
+  if (!v)
+#endif
+
+  /* If we are defining variables inside an $(eval ...), we might have a
+     different variable context pushed, not the global context (maybe we're
+     inside a $(call ...) or something.  Since this function is only ever
+     invoked in places where we want to define globally visible variables,
+     make sure we define this variable in the global set.  */
+
+  v = define_variable_in_set (varname, strlen (varname), p,
+                              origin, flavor == f_recursive,
+                              (target_var
+                               ? current_variable_set_list->set : NULL),
+                              flocp);
+  v->append = append;
+  v->conditional = conditional;
+
+ done:
+  free (alloc_value);
+  return v->special ? set_special_var (v) : v;
+}
+
+/* Parse P (a null-terminated string) as a variable definition.
+
+   If it is not a variable definition, return NULL and the contents of *VAR
+   are undefined, except NAME is set to the first non-space character or NIL.
+
+   If it is a variable definition, return a pointer to the char after the
+   assignment token and set the following fields (only) of *VAR:
+    name   : name of the variable (ALWAYS SET) (NOT NUL-TERMINATED!)
+    length : length of the variable name
+    value  : value of the variable (nul-terminated)
+    flavor : flavor of the variable
+   Other values in *VAR are unchanged.
+  */
+
+char *
+parse_variable_definition (const char *p, struct variable *var)
+{
+  int wspace = 0;
+  const char *e = NULL;
+
+  NEXT_TOKEN (p);
+  var->name = (char *)p;
+  var->length = 0;
+
+  while (1)
+    {
+      int c = *p++;
+
+      /* If we find a comment or EOS, it's not a variable definition.  */
+      if (STOP_SET (c, MAP_COMMENT|MAP_NUL))
+        return NULL;
+
+      if (c == '$')
+        {
+          /* This begins a variable expansion reference.  Make sure we don't
+             treat chars inside the reference as assignment tokens.  */
+          char closeparen;
+          unsigned int count;
+
+          c = *p++;
+          if (c == '(')
+            closeparen = ')';
+          else if (c == '{')
+            closeparen = '}';
+          else if (c == '\0')
+            return NULL;
+          else
+            /* '$$' or '$X'.  Either way, nothing special to do here.  */
+            continue;
+
+          /* P now points past the opening paren or brace.
+             Count parens or braces until it is matched.  */
+          for (count = 1; *p != '\0'; ++p)
+            {
+              if (*p == closeparen && --count == 0)
+                {
+                  ++p;
+                  break;
+                }
+              if (*p == c)
+                ++count;
+            }
+          continue;
+        }
+
+      /* If we find whitespace skip it, and remember we found it.  */
+      if (ISBLANK (c))
+        {
+          wspace = 1;
+          e = p - 1;
+          NEXT_TOKEN (p);
+          c = *p;
+          if (c == '\0')
+            return NULL;
+          ++p;
+        }
+
+
+      if (c == '=')
+        {
+          var->flavor = f_recursive;
+          if (! e)
+            e = p - 1;
+          break;
+        }
+
+      /* Match assignment variants (:=, +=, ?=, !=)  */
+      if (*p == '=')
+        {
+          switch (c)
+            {
+              case ':':
+                var->flavor = f_simple;
+                break;
+              case '+':
+                var->flavor = f_append;
+                break;
+              case '?':
+                var->flavor = f_conditional;
+                break;
+              case '!':
+                var->flavor = f_shell;
+                break;
+              default:
+                /* If we skipped whitespace, non-assignments means no var.  */
+                if (wspace)
+                  return NULL;
+
+                /* Might be assignment, or might be $= or #=.  Check.  */
+                continue;
+            }
+          if (! e)
+            e = p - 1;
+          ++p;
+          break;
+        }
+
+      /* Check for POSIX ::= syntax  */
+      if (c == ':')
+        {
+          /* A colon other than :=/::= is not a variable defn.  */
+          if (*p != ':' || p[1] != '=')
+            return NULL;
+
+          /* POSIX allows ::= to be the same as GNU make's := */
+          var->flavor = f_simple;
+          if (! e)
+            e = p - 1;
+          p += 2;
+          break;
+        }
+
+      /* If we skipped whitespace, non-assignments means no var.  */
+      if (wspace)
+        return NULL;
+    }
+
+  var->length = e - var->name;
+  var->value = next_token (p);
+  return (char *)p;
+}
+
+/* Try to interpret LINE (a null-terminated string) as a variable definition.
+
+   If LINE was recognized as a variable definition, a pointer to its 'struct
+   variable' is returned.  If LINE is not a variable definition, NULL is
+   returned.  */
+
+struct variable *
+assign_variable_definition (struct variable *v, const char *line)
+{
+  char *name;
+
+  if (!parse_variable_definition (line, v))
+    return NULL;
+
+  /* Expand the name, so "$(foo)bar = baz" works.  */
+  name = alloca (v->length + 1);
+  memcpy (name, v->name, v->length);
+  name[v->length] = '\0';
+  v->name = allocated_variable_expand (name);
+
+  if (v->name[0] == '\0')
+    O (fatal, &v->fileinfo, _("empty variable name"));
+
+  return v;
+}
+
+/* Try to interpret LINE (a null-terminated string) as a variable definition.
+
+   ORIGIN may be o_file, o_override, o_env, o_env_override,
+   or o_command specifying that the variable definition comes
+   from a makefile, an override directive, the environment with
+   or without the -e switch, or the command line.
+
+   See the comments for assign_variable_definition().
+
+   If LINE was recognized as a variable definition, a pointer to its 'struct
+   variable' is returned.  If LINE is not a variable definition, NULL is
+   returned.  */
+
+struct variable *
+try_variable_definition (const floc *flocp, const char *line,
+                         enum variable_origin origin, int target_var)
+{
+  struct variable v;
+  struct variable *vp;
+
+  if (flocp != 0)
+    v.fileinfo = *flocp;
+  else
+    v.fileinfo.filenm = 0;
+
+  if (!assign_variable_definition (&v, line))
+    return 0;
+
+  vp = do_variable_definition (flocp, v.name, v.value,
+                               origin, v.flavor, target_var);
+
+  free (v.name);
+
+  return vp;
+}
+
+/* Print information for variable V, prefixing it with PREFIX.  */
+
+static void
+print_variable (const void *item, void *arg)
+{
+  const struct variable *v = item;
+  const char *prefix = arg;
+  const char *origin;
+
+  switch (v->origin)
+    {
+    case o_automatic:
+      origin = _("automatic");
+      break;
+    case o_default:
+      origin = _("default");
+      break;
+    case o_env:
+      origin = _("environment");
+      break;
+    case o_file:
+      origin = _("makefile");
+      break;
+    case o_env_override:
+      origin = _("environment under -e");
+      break;
+    case o_command:
+      origin = _("command line");
+      break;
+    case o_override:
+      origin = _("'override' directive");
+      break;
+    case o_invalid:
+    default:
+      abort ();
+    }
+  fputs ("# ", stdout);
+  fputs (origin, stdout);
+  if (v->private_var)
+    fputs (" private", stdout);
+  if (v->fileinfo.filenm)
+    printf (_(" (from '%s', line %lu)"),
+            v->fileinfo.filenm, v->fileinfo.lineno + v->fileinfo.offset);
+  putchar ('\n');
+  fputs (prefix, stdout);
+
+  /* Is this a 'define'?  */
+  if (v->recursive && strchr (v->value, '\n') != 0)
+    printf ("define %s\n%s\nendef\n", v->name, v->value);
+  else
+    {
+      char *p;
+
+      printf ("%s %s= ", v->name, v->recursive ? v->append ? "+" : "" : ":");
+
+      /* Check if the value is just whitespace.  */
+      p = next_token (v->value);
+      if (p != v->value && *p == '\0')
+        /* All whitespace.  */
+        printf ("$(subst ,,%s)", v->value);
+      else if (v->recursive)
+        fputs (v->value, stdout);
+      else
+        /* Double up dollar signs.  */
+        for (p = v->value; *p != '\0'; ++p)
+          {
+            if (*p == '$')
+              putchar ('$');
+            putchar (*p);
+          }
+      putchar ('\n');
+    }
+}
+
+
+static void
+print_auto_variable (const void *item, void *arg)
+{
+  const struct variable *v = item;
+
+  if (v->origin == o_automatic)
+    print_variable (item, arg);
+}
+
+
+static void
+print_noauto_variable (const void *item, void *arg)
+{
+  const struct variable *v = item;
+
+  if (v->origin != o_automatic)
+    print_variable (item, arg);
+}
+
+
+/* Print all the variables in SET.  PREFIX is printed before
+   the actual variable definitions (everything else is comments).  */
+
+static void
+print_variable_set (struct variable_set *set, const char *prefix, int pauto)
+{
+  hash_map_arg (&set->table, (pauto ? print_auto_variable : print_variable),
+                (void *)prefix);
+
+  fputs (_("# variable set hash-table stats:\n"), stdout);
+  fputs ("# ", stdout);
+  hash_print_stats (&set->table, stdout);
+  putc ('\n', stdout);
+}
+
+/* Print the data base of variables.  */
+
+void
+print_variable_data_base (void)
+{
+  puts (_("\n# Variables\n"));
+
+  print_variable_set (&global_variable_set, "", 0);
+
+  puts (_("\n# Pattern-specific Variable Values"));
+
+  {
+    struct pattern_var *p;
+    unsigned int rules = 0;
+
+    for (p = pattern_vars; p != 0; p = p->next)
+      {
+        ++rules;
+        printf ("\n%s :\n", p->target);
+        print_variable (&p->variable, (void *)"# ");
+      }
+
+    if (rules == 0)
+      puts (_("\n# No pattern-specific variable values."));
+    else
+      printf (_("\n# %u pattern-specific variable values"), rules);
+  }
+}
+
+
+/* Print all the local variables of FILE.  */
+
+void
+print_file_variables (const struct file *file)
+{
+  if (file->variables != 0)
+    print_variable_set (file->variables->set, "# ", 1);
+}
+
+void
+print_target_variables (const struct file *file)
+{
+  if (file->variables != 0)
+    {
+      int l = strlen (file->name);
+      char *t = alloca (l + 3);
+
+      strcpy (t, file->name);
+      t[l] = ':';
+      t[l+1] = ' ';
+      t[l+2] = '\0';
+
+      hash_map_arg (&file->variables->set->table, print_noauto_variable, t);
+    }
+}
+
+#ifdef WINDOWS32
+void
+sync_Path_environment (void)
+{
+  char *path = allocated_variable_expand ("$(PATH)");
+  static char *environ_path = NULL;
+
+  if (!path)
+    return;
+
+  /* If done this before, free the previous entry before allocating new one.  */
+  free (environ_path);
+
+  /* Create something WINDOWS32 world can grok.  */
+  convert_Path_to_windows32 (path, ';');
+  environ_path = xstrdup (concat (3, "PATH", "=", path));
+  putenv (environ_path);
+  free (path);
+}
+#endif
diff --git a/src/variable.h b/src/variable.h
new file mode 100644
index 0000000..12aea39
--- /dev/null
+++ b/src/variable.h
@@ -0,0 +1,237 @@
+/* Definitions for using variables in GNU Make.
+Copyright (C) 1988-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "hash.h"
+
+/* Codes in a variable definition saying where the definition came from.
+   Increasing numeric values signify less-overridable definitions.  */
+enum variable_origin
+  {
+    o_default,          /* Variable from the default set.  */
+    o_env,              /* Variable from environment.  */
+    o_file,             /* Variable given in a makefile.  */
+    o_env_override,     /* Variable from environment, if -e.  */
+    o_command,          /* Variable given by user.  */
+    o_override,         /* Variable from an 'override' directive.  */
+    o_automatic,        /* Automatic variable -- cannot be set.  */
+    o_invalid           /* Core dump time.  */
+  };
+
+enum variable_flavor
+  {
+    f_bogus,            /* Bogus (error) */
+    f_simple,           /* Simple definition (:= or ::=) */
+    f_recursive,        /* Recursive definition (=) */
+    f_append,           /* Appending definition (+=) */
+    f_conditional,      /* Conditional definition (?=) */
+    f_shell,            /* Shell assignment (!=) */
+    f_append_value      /* Append unexpanded value */
+  };
+
+/* Structure that represents one variable definition.
+   Each bucket of the hash table is a chain of these,
+   chained through 'next'.  */
+
+#define EXP_COUNT_BITS  15      /* This gets all the bitfields into 32 bits */
+#define EXP_COUNT_MAX   ((1<<EXP_COUNT_BITS)-1)
+
+struct variable
+  {
+    char *name;                 /* Variable name.  */
+    char *value;                /* Variable value.  */
+    floc fileinfo;              /* Where the variable was defined.  */
+    int length;                 /* strlen (name) */
+    unsigned int recursive:1;   /* Gets recursively re-evaluated.  */
+    unsigned int append:1;      /* Nonzero if an appending target-specific
+                                   variable.  */
+    unsigned int conditional:1; /* Nonzero if set with a ?=. */
+    unsigned int per_target:1;  /* Nonzero if a target-specific variable.  */
+    unsigned int special:1;     /* Nonzero if this is a special variable.  */
+    unsigned int exportable:1;  /* Nonzero if the variable _could_ be
+                                   exported.  */
+    unsigned int expanding:1;   /* Nonzero if currently being expanded.  */
+    unsigned int private_var:1; /* Nonzero avoids inheritance of this
+                                   target-specific variable.  */
+    unsigned int exp_count:EXP_COUNT_BITS;
+                                /* If >1, allow this many self-referential
+                                   expansions.  */
+    enum variable_flavor
+      flavor ENUM_BITFIELD (3); /* Variable flavor.  */
+    enum variable_origin
+      origin ENUM_BITFIELD (3); /* Variable origin.  */
+    enum variable_export
+      {
+        v_export,               /* Export this variable.  */
+        v_noexport,             /* Don't export this variable.  */
+        v_ifset,                /* Export it if it has a non-default value.  */
+        v_default               /* Decide in target_environment.  */
+      } export ENUM_BITFIELD (2);
+  };
+
+/* Structure that represents a variable set.  */
+
+struct variable_set
+  {
+    struct hash_table table;    /* Hash table of variables.  */
+  };
+
+/* Structure that represents a list of variable sets.  */
+
+struct variable_set_list
+  {
+    struct variable_set_list *next;     /* Link in the chain.  */
+    struct variable_set *set;           /* Variable set.  */
+    int next_is_parent;                 /* True if next is a parent target.  */
+  };
+
+/* Structure used for pattern-specific variables.  */
+
+struct pattern_var
+  {
+    struct pattern_var *next;
+    const char *suffix;
+    const char *target;
+    unsigned int len;
+    struct variable variable;
+  };
+
+extern char *variable_buffer;
+extern struct variable_set_list *current_variable_set_list;
+extern struct variable *default_goal_var;
+extern struct variable shell_var;
+
+/* expand.c */
+char *variable_buffer_output (char *ptr, const char *string, unsigned int length);
+char *variable_expand (const char *line);
+char *variable_expand_for_file (const char *line, struct file *file);
+char *allocated_variable_expand_for_file (const char *line, struct file *file);
+#define allocated_variable_expand(line) \
+  allocated_variable_expand_for_file (line, (struct file *) 0)
+char *expand_argument (const char *str, const char *end);
+char *variable_expand_string (char *line, const char *string, long length);
+void install_variable_buffer (char **bufp, unsigned int *lenp);
+void restore_variable_buffer (char *buf, unsigned int len);
+
+/* function.c */
+int handle_function (char **op, const char **stringp);
+int pattern_matches (const char *pattern, const char *percent, const char *str);
+char *subst_expand (char *o, const char *text, const char *subst,
+                    const char *replace, unsigned int slen, unsigned int rlen,
+                    int by_word);
+char *patsubst_expand_pat (char *o, const char *text, const char *pattern,
+                           const char *replace, const char *pattern_percent,
+                           const char *replace_percent);
+char *patsubst_expand (char *o, const char *text, char *pattern, char *replace);
+char *func_shell_base (char *o, char **argv, int trim_newlines);
+void shell_completed (int exit_code, int exit_sig);
+
+/* expand.c */
+char *recursively_expand_for_file (struct variable *v, struct file *file);
+#define recursively_expand(v)   recursively_expand_for_file (v, NULL)
+
+/* variable.c */
+struct variable_set_list *create_new_variable_set (void);
+void free_variable_set (struct variable_set_list *);
+struct variable_set_list *push_new_variable_scope (void);
+void pop_variable_scope (void);
+void define_automatic_variables (void);
+void initialize_file_variables (struct file *file, int reading);
+void print_file_variables (const struct file *file);
+void print_target_variables (const struct file *file);
+void merge_variable_set_lists (struct variable_set_list **to_list,
+                               struct variable_set_list *from_list);
+struct variable *do_variable_definition (const floc *flocp,
+                                         const char *name, const char *value,
+                                         enum variable_origin origin,
+                                         enum variable_flavor flavor,
+                                         int target_var);
+char *parse_variable_definition (const char *line,
+                                 struct variable *v);
+struct variable *assign_variable_definition (struct variable *v, const char *line);
+struct variable *try_variable_definition (const floc *flocp, const char *line,
+                                          enum variable_origin origin,
+                                          int target_var);
+void init_hash_global_variable_set (void);
+void hash_init_function_table (void);
+void define_new_function(const floc *flocp, const char *name,
+                         unsigned int min, unsigned int max, unsigned int flags,
+                         gmk_func_ptr func);
+struct variable *lookup_variable (const char *name, unsigned int length);
+struct variable *lookup_variable_in_set (const char *name, unsigned int length,
+                                         const struct variable_set *set);
+
+struct variable *define_variable_in_set (const char *name, unsigned int length,
+                                         const char *value,
+                                         enum variable_origin origin,
+                                         int recursive,
+                                         struct variable_set *set,
+                                         const floc *flocp);
+
+/* Define a variable in the current variable set.  */
+
+#define define_variable(n,l,v,o,r) \
+          define_variable_in_set((n),(l),(v),(o),(r),\
+                                 current_variable_set_list->set,NILF)
+
+/* Define a variable with a constant name in the current variable set.  */
+
+#define define_variable_cname(n,v,o,r) \
+          define_variable_in_set((n),(sizeof (n) - 1),(v),(o),(r),\
+                                 current_variable_set_list->set,NILF)
+
+/* Define a variable with a location in the current variable set.  */
+
+#define define_variable_loc(n,l,v,o,r,f) \
+          define_variable_in_set((n),(l),(v),(o),(r),\
+                                 current_variable_set_list->set,(f))
+
+/* Define a variable with a location in the global variable set.  */
+
+#define define_variable_global(n,l,v,o,r,f) \
+          define_variable_in_set((n),(l),(v),(o),(r),NULL,(f))
+
+/* Define a variable in FILE's variable set.  */
+
+#define define_variable_for_file(n,l,v,o,r,f) \
+          define_variable_in_set((n),(l),(v),(o),(r),(f)->variables->set,NILF)
+
+void undefine_variable_in_set (const char *name, unsigned int length,
+                               enum variable_origin origin,
+                               struct variable_set *set);
+
+/* Remove variable from the current variable set. */
+
+#define undefine_variable_global(n,l,o) \
+          undefine_variable_in_set((n),(l),(o),NULL)
+
+/* Warn that NAME is an undefined variable.  */
+
+#define warn_undefined(n,l) do{\
+                              if (warn_undefined_variables_flag)        \
+                                error (reading_file, (l),               \
+                                       _("warning: undefined variable '%.*s'"), \
+                                       (int)(l), (n));                  \
+                              }while(0)
+
+char **target_environment (struct file *file);
+
+struct pattern_var *create_pattern_var (const char *target,
+                                        const char *suffix);
+
+extern int export_all_variables;
+
+#define MAKELEVEL_NAME "MAKELEVEL"
+#define MAKELEVEL_LENGTH (CSTRLEN (MAKELEVEL_NAME))
diff --git a/src/version.c b/src/version.c
new file mode 100644
index 0000000..039d5ab
--- /dev/null
+++ b/src/version.c
@@ -0,0 +1,33 @@
+/* Record version and build host architecture for GNU make.
+Copyright (C) 1988-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* We use <config.h> instead of "config.h" so that a compilation
+   using -I. -I$srcdir will use ./config.h rather than $srcdir/config.h
+   (which it would do because makeint.h was found in $srcdir).  */
+#include <config.h>
+
+#ifndef MAKE_HOST
+# define MAKE_HOST "unknown"
+#endif
+
+const char *version_string = VERSION;
+const char *make_host = MAKE_HOST;
+
+/*
+  Local variables:
+  version-control: never
+  End:
+ */
diff --git a/src/vms_exit.c b/src/vms_exit.c
new file mode 100644
index 0000000..988ac8a
--- /dev/null
+++ b/src/vms_exit.c
@@ -0,0 +1,95 @@
+/* vms_exit.c
+ *
+ * Wrapper for the VMS exit() command to tranlate UNIX codes to be
+ * encoded for POSIX, but also have VMS severity levels.
+ * The posix_exit() variant only sets a severity level for status code 1.
+ *
+ * Author: John E. Malmberg
+ */
+
+/* Copyright (C) 2014-2017 Free Software Foundation, Inc.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+
+/* Per copyright assignment agreement with the Free Software Foundation
+   this software may be available under under other license agreements
+   and copyrights. */
+
+#include <makeint.h>
+
+#include <stsdef.h>
+void
+decc$exit (int status);
+#ifndef C_FACILITY_NO
+# define C_FACILITY_NO 0x350000
+#endif
+
+/* Lowest legal non-success VMS exit code is 8 */
+/* GNU make only defines codes 0, 1, 2 */
+/* So assume any exit code > 8 is a VMS exit code */
+
+#ifndef MAX_EXPECTED_EXIT_CODE
+# define MAX_EXPECTED_EXIT_CODE 7
+#endif
+
+/* Build a Posix Exit with VMS severity */
+void
+vms_exit (int status)
+{
+  int vms_status;
+  /* Fake the __posix_exit with severity added */
+  /* Undocumented correct way to do this. */
+  vms_status = 0;
+
+  /* The default DECC definition is not compatible with doing a POSIX_EXIT */
+  /* So fix it. */
+  if (status == EXIT_FAILURE)
+    status = MAKE_FAILURE;
+
+  /* Trivial case exit success */
+  if (status == 0)
+    decc$exit (STS$K_SUCCESS);
+
+  /* Is this a VMS status then just take it */
+  if (status > MAX_EXPECTED_EXIT_CODE)
+    {
+      /* Make sure that the message inhibit is set since message has */
+      /* already been displayed. */
+      vms_status = status | STS$M_INHIB_MSG;
+      decc$exit (vms_status);
+    }
+
+  /* Unix status codes are limited to 1 byte, so anything larger */
+  /* is a probably a VMS exit code and needs to be passed through */
+  /* A lower value can be set for a macro. */
+  /* Status 0 is always passed through as it is converted to SS$_NORMAL */
+  /* Always set the message inhibit bit */
+  vms_status = C_FACILITY_NO | 0xA000 | STS$M_INHIB_MSG;
+  vms_status |= (status << 3);
+
+  /* STS$K_ERROR is for status that stops makefile that a simple */
+  /* Rerun of the makefile will not fix. */
+
+  if (status == MAKE_FAILURE)
+    vms_status |= STS$K_ERROR;
+  else if (status == MAKE_TROUBLE)
+    {
+      /* Make trouble is for when make was told to do nothing and */
+      /* found that a target was not up to date.  Since a second */
+      /* of make will produce the same condition, this is of */
+      /* Error severity */
+      vms_status |= STS$K_ERROR;
+    }
+  decc$exit (vms_status);
+}
diff --git a/src/vms_export_symbol.c b/src/vms_export_symbol.c
new file mode 100644
index 0000000..38daf12
--- /dev/null
+++ b/src/vms_export_symbol.c
@@ -0,0 +1,527 @@
+/* File: vms_export_symbol.c
+ *
+ * Some programs need special environment variables deported as DCL
+ * DCL symbols.
+ */
+
+/* Copyright (C) 2014-2017 Free Software Foundation, Inc.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+
+/* Per copyright assignment agreement with the Free Software Foundation
+   this software may be available under under other license agreements
+   and copyrights. */
+
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+
+#include <descrip.h>
+#include <stsdef.h>
+#include <ssdef.h>
+#include <unixlib.h>
+#include <libclidef.h>
+
+#pragma member_alignment save
+#pragma nomember_alignment longword
+struct item_list_3
+{
+  unsigned short len;
+  unsigned short code;
+  void * bufadr;
+  unsigned short * retlen;
+};
+
+
+#pragma member_alignment
+
+int
+LIB$GET_SYMBOL (const struct dsc$descriptor_s * symbol,
+                struct dsc$descriptor_s * value,
+                unsigned short * value_len,
+                const unsigned long * table);
+
+int
+LIB$SET_SYMBOL (const struct dsc$descriptor_s * symbol,
+                const struct dsc$descriptor_s * value,
+                const unsigned long * table);
+
+int
+LIB$DELETE_SYMBOL (const struct dsc$descriptor_s * symbol,
+                   const unsigned long * table);
+
+#define MAX_DCL_SYMBOL_LEN (255)
+#if __CRTL_VER >= 70302000 && !defined(__VAX)
+# define MAX_DCL_SYMBOL_VALUE (8192)
+#else
+# define MAX_DCL_SYMBOL_VALUE (1024)
+#endif
+
+struct dcl_symbol
+{
+  struct dcl_symbol * link;
+  struct dsc$descriptor_s name_desc;
+  struct dsc$descriptor_s value_desc;
+  char name[MAX_DCL_SYMBOL_LEN + 1];    /* + 1 byte for null terminator */
+  char value[MAX_DCL_SYMBOL_VALUE +1];  /* + 1 byte for null terminator */
+  char pad[3]; /* Pad structure to longword allignment */
+};
+
+static struct dcl_symbol * vms_dcl_symbol_head = NULL;
+
+/* Restore symbol state to original condition. */
+static unsigned long
+clear_dcl_symbol (struct dcl_symbol * symbol)
+{
+
+  const unsigned long symtbl = LIB$K_CLI_LOCAL_SYM;
+  int status;
+
+  if (symbol->value_desc.dsc$w_length == (unsigned short)-1)
+    status = LIB$DELETE_SYMBOL (&symbol->name_desc, &symtbl);
+  else
+    status = LIB$SET_SYMBOL (&symbol->name_desc,
+                             &symbol->value_desc, &symtbl);
+  return status;
+}
+
+
+/* Restore all exported symbols to their original conditions */
+static void
+clear_exported_symbols (void)
+{
+
+  struct dcl_symbol * symbol;
+
+  symbol = vms_dcl_symbol_head;
+
+  /* Walk the list of symbols.  This is done durring exit,
+   * so no need to free memory.
+   */
+  while (symbol != NULL)
+  {
+    clear_dcl_symbol (symbol);
+    symbol = symbol->link;
+  }
+
+}
+
+
+/* Restore the symbol back to the original value
+ * symbol name is either a plain name or of the form "symbol=name" where
+ * the name portion is ignored.
+ */
+void
+vms_restore_symbol (const char * string)
+{
+
+  struct dcl_symbol * symbol;
+  char name[MAX_DCL_SYMBOL_LEN + 1];
+  int status;
+  char * value;
+  int name_len;
+
+  symbol = vms_dcl_symbol_head;
+
+  /* Isolate the name from the value */
+  value = strchr (string, '=');
+  if (value != NULL)
+    {
+      /* Copy the name from the string */
+      name_len = (value - string);
+    }
+  else
+    name_len = strlen (string);
+
+  if (name_len > MAX_DCL_SYMBOL_LEN)
+    name_len = MAX_DCL_SYMBOL_LEN;
+
+  strncpy (name, string, name_len);
+  name[name_len] = 0;
+
+  /* Walk the list of symbols.  The saved symbol is not freed
+   * symbols are likely to be overwritten multiple times, so this
+   * saves time in saving them each time.
+   */
+  while (symbol != NULL)
+    {
+      int result;
+      result = strcmp (symbol->name, name);
+      if (result == 0)
+        {
+          clear_dcl_symbol (symbol);
+          break;
+        }
+      symbol = symbol->link;
+    }
+}
+
+int
+vms_export_dcl_symbol (const char * name, const char * value)
+{
+
+  struct dcl_symbol * symbol;
+  struct dcl_symbol * next;
+  struct dcl_symbol * link;
+  int found;
+  const unsigned long symtbl = LIB$K_CLI_LOCAL_SYM;
+  struct dsc$descriptor_s value_desc;
+  int string_len;
+  int status;
+  char new_value[MAX_DCL_SYMBOL_VALUE + 1];
+  char * dollarp;
+
+  next = vms_dcl_symbol_head;
+  link = vms_dcl_symbol_head;
+
+  /* Is symbol already exported? */
+  found = 0;
+  while ((found == 0) && (link != NULL))
+    {
+      int x;
+      found = !strncasecmp (link->name, name, MAX_DCL_SYMBOL_LEN);
+      if (found)
+        symbol = link;
+      next = link;
+      link = link->link;
+    }
+
+  /* New symbol, set it up */
+  if (found == 0)
+    {
+      symbol = malloc (sizeof (struct dcl_symbol));
+      if (symbol == NULL)
+        return SS$_INSFMEM;
+
+      /* Construct the symbol descriptor, used for both saving
+       * the old symbol and creating the new symbol.
+       */
+      symbol->name_desc.dsc$w_length = strlen (name);
+      if (symbol->name_desc.dsc$w_length > MAX_DCL_SYMBOL_LEN)
+        symbol->name_desc.dsc$w_length = MAX_DCL_SYMBOL_LEN;
+
+      strncpy (symbol->name, name, symbol->name_desc.dsc$w_length);
+      symbol->name[symbol->name_desc.dsc$w_length] = 0;
+      symbol->name_desc.dsc$a_pointer = symbol->name;
+      symbol->name_desc.dsc$b_dtype = DSC$K_DTYPE_T;
+      symbol->name_desc.dsc$b_class = DSC$K_CLASS_S;
+
+      /* construct the value descriptor, used only for saving
+       * the old symbol.
+       */
+      symbol->value_desc.dsc$a_pointer = symbol->value;
+      symbol->value_desc.dsc$w_length = MAX_DCL_SYMBOL_VALUE;
+      symbol->value_desc.dsc$b_dtype = DSC$K_DTYPE_T;
+      symbol->value_desc.dsc$b_class = DSC$K_CLASS_S;
+    }
+
+  if (found == 0)
+    {
+      unsigned long old_symtbl;
+      unsigned short value_len;
+
+      /* Look up the symbol */
+      status = LIB$GET_SYMBOL (&symbol->name_desc, &symbol->value_desc,
+                               &value_len, &old_symtbl);
+      if (!$VMS_STATUS_SUCCESS (status))
+        value_len = (unsigned short)-1;
+      else if (old_symtbl != symtbl)
+        value_len = (unsigned short)-1;
+
+      symbol->value_desc.dsc$w_length = value_len;
+
+      /* Store it away */
+      if (value_len != (unsigned short) -1)
+        symbol->value[value_len] = 0;
+
+      /* Make sure atexit scheduled */
+      if (vms_dcl_symbol_head == NULL)
+        {
+          vms_dcl_symbol_head = symbol;
+          atexit (clear_exported_symbols);
+        }
+      else
+        {
+          /* Extend the chain */
+          next->link = symbol;
+        }
+    }
+
+  /* Create or replace a symbol */
+  value_desc.dsc$a_pointer = new_value;
+  string_len = strlen (value);
+  if (string_len > MAX_DCL_SYMBOL_VALUE)
+    string_len = MAX_DCL_SYMBOL_VALUE;
+
+  strncpy (new_value, value, string_len);
+  new_value[string_len] = 0;
+
+  /* Special handling for GNU Make.  GNU Make doubles the dollar signs
+   * in environment variables read in from getenv().  Make exports symbols
+   * with the dollar signs already doubled.  So all $$ must be converted
+   * back to $.
+   * If the first $ is not doubled, then do not convert at all.
+   */
+  dollarp = strchr (new_value, '$');
+  while (dollarp && dollarp[1] == '$')
+    {
+      int left;
+      dollarp++;
+      left = string_len - (dollarp - new_value - 1);
+      string_len--;
+      if (left > 0)
+        {
+          memmove (dollarp, &dollarp[1], left);
+          dollarp = strchr (&dollarp[1], '$');
+        }
+      else
+        {
+          /* Ended with $$, simple case */
+          dollarp[1] = 0;
+          break;
+        }
+    }
+  value_desc.dsc$w_length = string_len;
+  value_desc.dsc$b_dtype = DSC$K_DTYPE_T;
+  value_desc.dsc$b_class = DSC$K_CLASS_S;
+  status = LIB$SET_SYMBOL (&symbol->name_desc, &value_desc, &symtbl);
+  return status;
+}
+
+/* export a DCL symbol using a string in the same syntax as putenv */
+int
+vms_putenv_symbol (const char * string)
+{
+
+  char name[MAX_DCL_SYMBOL_LEN + 1];
+  int status;
+  char * value;
+  int name_len;
+
+  /* Isolate the name from the value */
+  value = strchr (string, '=');
+  if (value == NULL)
+    {
+      errno = EINVAL;
+      return -1;
+    }
+
+  /* Copy the name from the string */
+  name_len = (value - string);
+  if (name_len > MAX_DCL_SYMBOL_LEN)
+    name_len = MAX_DCL_SYMBOL_LEN;
+
+  strncpy (name, string, name_len);
+  name[name_len] = 0;
+
+  /* Skip past the "=" */
+  value++;
+
+  /* Export the symbol */
+  status = vms_export_dcl_symbol (name, value);
+
+  /* Convert the error to Unix format */
+  if (!$VMS_STATUS_SUCCESS (status))
+    {
+      errno = EVMSERR;
+      vaxc$errno = status;
+      return -1;
+    }
+  return 0;
+}
+
+#if __CRTL_VER >= 70301000
+# define transpath_parm transpath
+#else
+static char transpath[MAX_DCL_SYMBOL_VALUE];
+#endif
+
+/* Helper callback routine for converting Unix paths to VMS */
+static int
+to_vms_action (char * vms_spec, int flag, char * transpath_parm)
+{
+  strncpy (transpath, vms_spec, MAX_DCL_SYMBOL_VALUE - 1);
+  transpath[MAX_DCL_SYMBOL_VALUE - 1] = 0;
+  return 0;
+}
+
+#ifdef __DECC
+# pragma message save
+  /* Undocumented extra parameter use triggers a ptrmismatch warning */
+# pragma message disable ptrmismatch
+#endif
+
+/* Create a foreign command only visible to children */
+int
+create_foreign_command (const char * command, const char * image)
+{
+  char vms_command[MAX_DCL_SYMBOL_VALUE + 1];
+  int status;
+
+  vms_command[0] = '$';
+  vms_command[1] = 0;
+  if (image[0] == '/')
+    {
+#if __CRTL_VER >= 70301000
+      /* Current decc$to_vms is reentrant */
+      decc$to_vms (image, to_vms_action, 0, 1, &vms_command[1]);
+#else
+      /* Older decc$to_vms is not reentrant */
+      decc$to_vms (image, to_vms_action, 0, 1);
+      strncpy (&vms_command[1], transpath, MAX_DCL_SYMBOL_VALUE - 1);
+      vms_command[MAX_DCL_SYMBOL_VALUE] = 0;
+#endif
+    }
+  else
+    {
+      strncpy (&vms_command[1], image, MAX_DCL_SYMBOL_VALUE - 1);
+      vms_command[MAX_DCL_SYMBOL_VALUE] = 0;
+    }
+  status = vms_export_dcl_symbol (command, vms_command);
+
+  return status;
+}
+#ifdef __DECC
+# pragma message restore
+#endif
+
+
+#ifdef DEBUG
+
+int
+main(int argc, char ** argv, char **env)
+{
+
+  char value[MAX_DCL_SYMBOL_VALUE +1];
+  int status = 0;
+  int putenv_status;
+  int vms_status;
+  struct dsc$descriptor_s name_desc;
+  struct dsc$descriptor_s value_desc;
+  const unsigned long symtbl = LIB$K_CLI_LOCAL_SYM;
+  unsigned short value_len;
+  unsigned long old_symtbl;
+  int result;
+  const char * vms_command = "vms_export_symbol";
+  const char * vms_image = "test_image.exe";
+  const char * vms_symbol1 = "test_symbol1";
+  const char * value1 = "test_value1";
+  const char * vms_symbol2 = "test_symbol2";
+  const char * putenv_string = "test_symbol2=value2";
+  const char * value2 = "value2";
+
+  /* Test creating a foreign command */
+  vms_status = create_foreign_command (vms_command, vms_image);
+  if (!$VMS_STATUS_SUCCESS (vms_status))
+    {
+      printf("Create foreign command failed: %d\n", vms_status);
+      status = 1;
+    }
+
+  name_desc.dsc$a_pointer = (char *)vms_command;
+  name_desc.dsc$w_length = strlen (vms_command);
+  name_desc.dsc$b_dtype = DSC$K_DTYPE_T;
+  name_desc.dsc$b_class = DSC$K_CLASS_S;
+
+  value_desc.dsc$a_pointer = value;
+  value_desc.dsc$w_length = MAX_DCL_SYMBOL_VALUE;
+  value_desc.dsc$b_dtype = DSC$K_DTYPE_T;
+  value_desc.dsc$b_class = DSC$K_CLASS_S;
+
+  vms_status = LIB$GET_SYMBOL (&name_desc, &value_desc,
+                               &value_len, &old_symtbl);
+  if (!$VMS_STATUS_SUCCESS (vms_status))
+    {
+      printf ("lib$get_symbol for command failed: %d\n", vms_status);
+      status = 1;
+    }
+
+  value[value_len] = 0;
+  result = strncasecmp (&value[1], vms_image, value_len - 1);
+  if (result != 0)
+    {
+      printf ("create_foreign_command failed!  expected '%s', got '%s'\n",
+              vms_image, &value[1]);
+      status = 1;
+    }
+
+  /* Test exporting a symbol */
+  vms_status = vms_export_dcl_symbol (vms_symbol1, value1);
+  if (!$VMS_STATUS_SUCCESS (vms_status))
+    {
+      printf ("vms_export_dcl_symbol for command failed: %d\n", vms_status);
+      status = 1;
+    }
+
+  name_desc.dsc$a_pointer = (char *)vms_symbol1;
+  name_desc.dsc$w_length = strlen (vms_symbol1);
+  vms_status = LIB$GET_SYMBOL(&name_desc, &value_desc,
+                              &value_len, &old_symtbl);
+  if (!$VMS_STATUS_SUCCESS(vms_status))
+    {
+      printf ("lib$get_symbol for command failed: %d\n", vms_status);
+      status = 1;
+    }
+
+  value[value_len] = 0;
+  result = strncmp (value, value1, value_len);
+  if (result != 0)
+    {
+      printf ("vms_export_dcl_symbol failed!  expected '%s', got '%s'\n",
+              value1, value);
+      status = 1;
+    }
+
+  /* Test putenv for DCL symbols */
+  putenv_status = vms_putenv_symbol (putenv_string);
+  if (putenv_status != 0)
+    {
+      perror ("vms_putenv_symbol");
+      status = 1;
+    }
+
+  name_desc.dsc$a_pointer = (char *)vms_symbol2;
+  name_desc.dsc$w_length = strlen(vms_symbol2);
+  vms_status = LIB$GET_SYMBOL (&name_desc, &value_desc,
+                               &value_len, &old_symtbl);
+  if (!$VMS_STATUS_SUCCESS (vms_status))
+    {
+      printf ("lib$get_symbol for command failed: %d\n", vms_status);
+      status = 1;
+    }
+
+  value[value_len] = 0;
+  result = strncmp (value, value2, value_len);
+  if (result != 0)
+  {
+    printf ("vms_putenv_symbol failed!  expected '%s', got '%s'\n",
+            value2, value);
+    status = 1;
+  }
+
+  vms_restore_symbol (putenv_string);
+  vms_status = LIB$GET_SYMBOL (&name_desc, &value_desc,
+                               &value_len, &old_symtbl);
+  if ($VMS_STATUS_SUCCESS (vms_status))
+    {
+      printf ("lib$get_symbol for command succeeded, should have failed\n");
+      status = 1;
+    }
+
+  exit (status);
+}
+
+#endif
diff --git a/src/vms_progname.c b/src/vms_progname.c
new file mode 100644
index 0000000..47d12a7
--- /dev/null
+++ b/src/vms_progname.c
@@ -0,0 +1,463 @@
+/* File: vms_progname.c
+ *
+ * This module provides a fixup of the program name.
+ *
+ * This module is designed to be a plug in replacement for the
+ * progname module used by many GNU utilities with a few enhancements
+ * needed for GNU Make.
+ *
+ * It does not support the HAVE_DECL_PROGRAM_INVOCATION_* macros at this
+ * time.
+ *
+ * Make sure that the program_name string is set as close as possible to
+ *    what the original command was given.
+ *
+ * When run from DCL, The argv[0] element is initialized with an absolute
+ * path name.  The decc$ feature logical names can control the format
+ * of this pathname.  In some cases it causes the UNIX format name to be
+ * formatted incorrectly.
+ *
+ * This DCL provided name is usually incompatible with what is expected to
+ * be provided by Unix programs and needs to be replaced.
+ *
+ * When run from an exec() call, the argv[0] element is initialized by the
+ * program.  This name is compatible with what is expected to be provided
+ * by Unix programs and should be passed through unchanged.
+ *
+ * The DCL provided name can be detected because it always contains the
+ * device name.
+ *
+ * DCL examples:
+ *    devname:[dir]program.exe;1         Normal VMS - remove path and .EXE;n
+ *    devname:[dir]facility$program.exe;1   Facility also needs removal.
+ *    /devname/dir/program.exe
+ *    /DISK$VOLUME/dir/program.exe.1     Bug version should not be there.
+ *    /DISK$VOLUME/dir/program.          Bug Period should not be there.
+ *
+ */
+
+/* Copyright (C) 2014-2017 Free Software Foundation, Inc.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+
+/* Per copyright assignment agreement with the Free Software Foundation
+   this software may be available under under other license agreements
+   and copyrights. */
+
+
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdlib.h>
+
+#include <descrip.h>
+#include <dvidef.h>
+#include <efndef.h>
+#include <fscndef.h>
+#include <stsdef.h>
+
+#ifdef USE_PROGNAME_H
+# include "progname.h"
+#endif
+
+#pragma member_alignment save
+#pragma nomember_alignment longword
+struct item_list_3
+{
+  unsigned short len;
+  unsigned short code;
+  void * bufadr;
+  unsigned short * retlen;
+};
+
+struct filescan_itmlst_2
+{
+  unsigned short length;
+  unsigned short itmcode;
+  char * component;
+};
+
+#pragma member_alignment
+
+int
+SYS$GETDVIW (unsigned long efn,
+             unsigned short chan,
+             const struct dsc$descriptor_s * devnam,
+             const struct item_list_3 * itmlst,
+             void * iosb,
+             void (* astadr)(unsigned long),
+             unsigned long astprm,
+             void * nullarg);
+
+int
+SYS$FILESCAN (const struct dsc$descriptor_s * srcstr,
+              struct filescan_itmlst_2 * valuelist,
+              unsigned long * fldflags,
+              struct dsc$descriptor_s *auxout,
+              unsigned short * retlen);
+
+/* String containing name the program is called with.
+   To be initialized by main().  */
+
+const char *program_name = NULL;
+
+static int internal_need_vms_symbol = 0;
+
+static char vms_new_nam[256];
+
+int
+need_vms_symbol (void)
+{
+  return internal_need_vms_symbol;
+}
+
+
+void
+set_program_name (const char *argv0)
+{
+  int status;
+  int result;
+
+#ifdef DEBUG
+  printf ("original argv0 = %s\n", argv0);
+#endif
+
+  /* Posix requires non-NULL argv[0] */
+  if (argv0 == NULL)
+    {
+      fputs ("A NULL argv[0] was passed through an exec system call.\n",
+             stderr);
+      abort ();
+    }
+
+  program_name = argv0;
+  result = 0;
+  internal_need_vms_symbol = 0;
+
+  /* If the path name starts with a /, then it is an absolute path         */
+  /* that may have been generated by the CRTL instead of the command name  */
+  /* If it is the device name between the slashes, then this was likely    */
+  /* from the run command and needs to be fixed up.                        */
+  /* If the DECC$POSIX_COMPLIANT_PATHNAMES is set to 2, then it is the     */
+  /* DISK$VOLUME that will be present, and it will still need to be fixed. */
+  if (argv0[0] == '/')
+    {
+      char * nextslash;
+      int length;
+      struct item_list_3 itemlist[3];
+      unsigned short dvi_iosb[4];
+      char alldevnam[64];
+      unsigned short alldevnam_len;
+      struct dsc$descriptor_s devname_dsc;
+      char diskvolnam[256];
+      unsigned short diskvolnam_len;
+
+      internal_need_vms_symbol = 1;
+
+       /* Get some information about the disk */
+      /*--------------------------------------*/
+      itemlist[0].len = (sizeof alldevnam) - 1;
+      itemlist[0].code = DVI$_ALLDEVNAM;
+      itemlist[0].bufadr = alldevnam;
+      itemlist[0].retlen = &alldevnam_len;
+      itemlist[1].len = (sizeof diskvolnam) - 1 - 5;
+      itemlist[1].code = DVI$_VOLNAM;
+      itemlist[1].bufadr = &diskvolnam[5];
+      itemlist[1].retlen = &diskvolnam_len;
+      itemlist[2].len = 0;
+      itemlist[2].code = 0;
+
+      /* Add the prefix for the volume name. */
+      /* SYS$GETDVI will append the volume name to this */
+      strcpy (diskvolnam, "DISK$");
+
+      nextslash = strchr (&argv0[1], '/');
+      if (nextslash != NULL)
+        {
+          length = nextslash - argv0 - 1;
+
+          /* Cast needed for HP C compiler diagnostic */
+          devname_dsc.dsc$a_pointer = (char *)&argv0[1];
+          devname_dsc.dsc$w_length = length;
+          devname_dsc.dsc$b_dtype = DSC$K_DTYPE_T;
+          devname_dsc.dsc$b_class = DSC$K_CLASS_S;
+
+          status = SYS$GETDVIW (EFN$C_ENF, 0, &devname_dsc, itemlist,
+                                dvi_iosb, NULL, 0, 0);
+          if (!$VMS_STATUS_SUCCESS (status))
+            {
+              /* If the sys$getdviw fails, then this path was passed by */
+              /* An exec() program and not from DCL, so do nothing */
+              /* An example is "/tmp/program" where tmp: does not exist */
+#ifdef DEBUG
+              printf ("sys$getdviw failed with status %d\n", status);
+#endif
+              result = 0;
+             }
+           else if (!$VMS_STATUS_SUCCESS (dvi_iosb[0]))
+             {
+#ifdef DEBUG
+                printf ("sys$getdviw failed with iosb %d\n", dvi_iosb[0]);
+#endif
+                result = 0;
+              }
+            else
+              {
+                char * devnam;
+                int devnam_len;
+                char argv_dev[64];
+
+                /* Null terminate the returned alldevnam */
+                alldevnam[alldevnam_len] = 0;
+                devnam = alldevnam;
+                devnam_len = alldevnam_len;
+
+                /* Need to skip past any leading underscore */
+                if (devnam[0] == '_')
+                  {
+                    devnam++;
+                    devnam_len--;
+                  }
+
+                /* And remove the trailing colon */
+                if (devnam[devnam_len - 1] == ':')
+                  {
+                    devnam_len--;
+                    devnam[devnam_len] = 0;
+                  }
+
+                /* Null terminate the returned volnam */
+                diskvolnam_len += 5;
+                diskvolnam[diskvolnam_len] = 0;
+
+                /* Check first for normal CRTL behavior */
+                if (devnam_len == length)
+                  {
+                    strncpy (vms_new_nam, &argv0[1], length);
+                    vms_new_nam[length] = 0;
+                    result = (strcasecmp (devnam, vms_new_nam) == 0);
+                  }
+
+                /* If we have not got a match, check for POSIX Compliant */
+                /* behavior.  To be more accurate, we could also check */
+                /* to see if that feature is active. */
+                if ((result == 0) && (diskvolnam_len == length))
+                  {
+                    strncpy (vms_new_nam, &argv0[1], length);
+                    vms_new_nam[length] = 0;
+                    result = (strcasecmp (diskvolnam, vms_new_nam) == 0);
+                  }
+              }
+        }
+      }
+    else
+      {
+        /* The path did not start with a slash, so it could be VMS format */
+        /* If it is vms format, it has a volume/device in it as it must   */
+        /* be an absolute path */
+        struct dsc$descriptor_s path_desc;
+        int status;
+        unsigned long field_flags;
+        struct filescan_itmlst_2 item_list[5];
+        char * volume;
+        char * name;
+        int name_len;
+        char * ext;
+
+        path_desc.dsc$a_pointer = (char *)argv0; /* cast ok */
+        path_desc.dsc$w_length = strlen (argv0);
+        path_desc.dsc$b_dtype = DSC$K_DTYPE_T;
+        path_desc.dsc$b_class = DSC$K_CLASS_S;
+
+        /* Don't actually need to initialize anything buf itmcode */
+        /* I just do not like uninitialized input values */
+
+        /* Sanity check, this must be the same length as input */
+        item_list[0].itmcode = FSCN$_FILESPEC;
+        item_list[0].length = 0;
+        item_list[0].component = NULL;
+
+        /* If the device is present, then it if a VMS spec */
+        item_list[1].itmcode = FSCN$_DEVICE;
+        item_list[1].length = 0;
+        item_list[1].component = NULL;
+
+        /* we need the program name and type */
+        item_list[2].itmcode = FSCN$_NAME;
+        item_list[2].length = 0;
+        item_list[2].component = NULL;
+
+        item_list[3].itmcode = FSCN$_TYPE;
+        item_list[3].length = 0;
+        item_list[3].component = NULL;
+
+        /* End the list */
+        item_list[4].itmcode = 0;
+        item_list[4].length = 0;
+        item_list[4].component = NULL;
+
+        status = SYS$FILESCAN ((const struct dsc$descriptor_s *)&path_desc,
+                               item_list, &field_flags, NULL, NULL);
+
+
+        if ($VMS_STATUS_SUCCESS (status) &&
+           (item_list[0].length == path_desc.dsc$w_length) &&
+           (item_list[1].length != 0))
+          {
+
+            char * dollar;
+            int keep_ext;
+            int i;
+
+            /* We need the filescan to be successful, */
+            /* same length as input, and a volume to be present */
+            internal_need_vms_symbol = 1;
+
+            /* We will assume that we only get to this path on a version */
+            /* of VMS that does not support the EFS character set */
+
+            /* There may be a xxx$ prefix on the image name.  Linux */
+            /* programs do not handle that well, so strip the prefix */
+            name = item_list[2].component;
+            name_len = item_list[2].length;
+            dollar = strrchr (name, '$');
+            if (dollar != NULL)
+              {
+                dollar++;
+                name_len = name_len - (dollar - name);
+                name = dollar;
+              }
+
+            strncpy (vms_new_nam, name, name_len);
+            vms_new_nam[name_len] = 0;
+
+            /* Commit to using the new name */
+            program_name = vms_new_nam;
+
+            /* We only keep the extension if it is not ".exe" */
+            keep_ext = 0;
+            ext = item_list[3].component;
+
+            if (item_list[3].length != 1)
+              {
+                keep_ext = 1;
+                if (item_list[3].length == 4)
+                  {
+                    if ((ext[1] == 'e' || ext[1] == 'E') &&
+                        (ext[2] == 'x' || ext[2] == 'X') &&
+                        (ext[3] == 'e' || ext[3] == 'E'))
+                      keep_ext = 0;
+                  }
+              }
+
+            if (keep_ext == 1)
+              strncpy (&vms_new_nam[name_len], ext, item_list[3].length);
+          }
+      }
+
+    if (result)
+      {
+        char * lastslash;
+        char * dollar;
+        char * dotexe;
+        char * lastdot;
+        char * extension;
+
+        /* This means it is probably the name from a DCL command */
+        /* Find the last slash which separates the file from the */
+        /* path. */
+        lastslash = strrchr (argv0, '/');
+
+        if (lastslash != NULL) {
+            int i;
+
+            lastslash++;
+
+            /* There may be a xxx$ prefix on the image name.  Linux */
+            /* programs do not handle that well, so strip the prefix */
+            dollar = strrchr (lastslash, '$');
+
+            if (dollar != NULL) {
+                dollar++;
+                lastslash = dollar;
+            }
+
+            strcpy (vms_new_nam, lastslash);
+
+            /* In UNIX mode + EFS character set, there should not be a */
+            /* version present, as it is not possible when parsing to  */
+            /* tell if it is a version or part of the UNIX filename as */
+            /* UNIX programs use numeric extensions for many reasons.  */
+
+            lastdot = strrchr (vms_new_nam, '.');
+            if (lastdot != NULL) {
+                int i;
+
+                i = 1;
+                while (isdigit (lastdot[i])) {
+                    i++;
+                }
+                if (lastdot[i] == 0) {
+                    *lastdot = 0;
+                }
+            }
+
+            /* Find the .exe on the name (case insenstive) and toss it */
+            dotexe = strrchr (vms_new_nam, '.');
+            if (dotexe != NULL) {
+                if ((dotexe[1] == 'e' || dotexe[1] == 'E') &&
+                    (dotexe[2] == 'x' || dotexe[2] == 'X') &&
+                    (dotexe[3] == 'e' || dotexe[3] == 'E') &&
+                    (dotexe[4] == 0)) {
+
+                    *dotexe = 0;
+                } else {
+                     /* Also need to handle a null extension because of a */
+                     /* CRTL bug. */
+                     if (dotexe[1] == 0) {
+                         *dotexe = 0;
+                    }
+                }
+            }
+
+            /* Commit to new name */
+            program_name = vms_new_nam;
+
+        } else {
+            /* There is no way that the code should ever get here */
+            /* As we already verified that the '/' was present */
+            fprintf (stderr, "Sanity failure somewhere we lost a '/'\n");
+        }
+    }
+}
+
+#ifdef DEBUG
+
+int
+main (int argc, char ** argv, char **env)
+{
+
+  char command[1024];
+
+  set_program_name (argv[0]);
+
+  printf ("modified argv[0] = %s\n", program_name);
+
+  return 0;
+}
+#endif
diff --git a/src/vmsdir.h b/src/vmsdir.h
new file mode 100644
index 0000000..f1d52d6
--- /dev/null
+++ b/src/vmsdir.h
@@ -0,0 +1,76 @@
+/* dirent.h for vms
+Copyright (C) 1996-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef VMSDIR_H
+#define VMSDIR_H
+
+#include <rms.h>
+
+#define	MAXNAMLEN	255
+
+#ifndef __DECC
+#if !defined (__GNUC__) && !defined (__ALPHA)
+typedef unsigned long u_long;
+typedef unsigned short u_short;
+#endif
+#endif
+
+struct direct
+{
+  off_t d_off;
+  u_long d_fileno;
+  u_short d_reclen;
+  u_short d_namlen;
+  char d_name[MAXNAMLEN + 1];
+};
+
+#undef DIRSIZ
+#define DIRSIZ(dp)		\
+  (((sizeof (struct direct)	\
+     - (MAXNAMLEN+1)		\
+     + ((dp)->d_namlen+1))	\
+    + 3) & ~3)
+
+#define d_ino	d_fileno		/* compatibility */
+
+
+/*
+ * Definitions for library routines operating on directories.
+ */
+
+typedef struct DIR
+{
+  struct direct dir;
+  char d_result[MAXNAMLEN + 1];
+#if defined (__ALPHA) || defined (__DECC)
+  struct FAB fab;
+#else
+  struct fabdef fab;
+#endif
+} DIR;
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+#define rewinddir(dirp)	seekdir((dirp), (long)0)
+
+DIR *opendir ();
+struct direct *readdir (DIR *dfd);
+int closedir (DIR *dfd);
+const char *vmsify (const char *name, int type);
+
+#endif /* VMSDIR_H */
diff --git a/src/vmsfunctions.c b/src/vmsfunctions.c
new file mode 100644
index 0000000..356524d
--- /dev/null
+++ b/src/vmsfunctions.c
@@ -0,0 +1,226 @@
+/* VMS functions
+Copyright (C) 1996-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+#include "debug.h"
+#include "job.h"
+
+#include <ctype.h>
+#include <string.h>
+
+#ifdef __DECC
+#include <starlet.h>
+#endif
+
+#include <rms.h>
+#include "vmsdir.h"
+
+#ifdef HAVE_VMSDIR_H
+
+DIR *
+opendir (char *dspec)
+{
+  struct DIR *dir  = xcalloc (sizeof (struct DIR));
+  struct NAM *dnam = xmalloc (sizeof (struct NAM));
+  struct FAB *dfab = &dir->fab;
+  char *searchspec = xmalloc (MAXNAMLEN + 1);
+
+  *dfab = cc$rms_fab;
+  *dnam = cc$rms_nam;
+  sprintf (searchspec, "%s*.*;", dspec);
+
+  dfab->fab$l_fna = searchspec;
+  dfab->fab$b_fns = strlen (searchspec);
+  dfab->fab$l_nam = dnam;
+
+  *dnam = cc$rms_nam;
+  dnam->nam$l_esa = searchspec;
+  dnam->nam$b_ess = MAXNAMLEN;
+
+  if (! (sys$parse (dfab) & 1))
+    {
+      free (dir);
+      free (dnam);
+      free (searchspec);
+      return (NULL);
+    }
+
+  return dir;
+}
+
+#define uppercasify(str) \
+  do \
+    { \
+      char *tmp; \
+      for (tmp = (str); *tmp != '\0'; tmp++) \
+        if (islower ((unsigned char)*tmp)) \
+          *tmp = toupper ((unsigned char)*tmp); \
+    } \
+  while (0)
+
+struct direct *
+readdir (DIR *dir)
+{
+  struct FAB *dfab = &dir->fab;
+  struct NAM *dnam = (struct NAM *)(dfab->fab$l_nam);
+  struct direct *dentry = &dir->dir;
+  int i;
+
+  memset (dentry, 0, sizeof *dentry);
+
+  dnam->nam$l_rsa = dir->d_result;
+  dnam->nam$b_rss = MAXNAMLEN;
+
+  DB (DB_VERBOSE, ("."));
+
+  if (!((i = sys$search (dfab)) & 1))
+    {
+      DB (DB_VERBOSE, (_("sys$search() failed with %d\n"), i));
+      return (NULL);
+    }
+
+  dentry->d_off = 0;
+  if (dnam->nam$w_fid == 0)
+    dentry->d_fileno = 1;
+  else
+    dentry->d_fileno = dnam->nam$w_fid[0] + (dnam->nam$w_fid[1] << 16);
+
+  dentry->d_reclen = sizeof (struct direct);
+  dentry->d_namlen = dnam->nam$b_name + dnam->nam$b_type;
+  strncpy (dentry->d_name, dnam->nam$l_name, dentry->d_namlen);
+  dentry->d_name[dentry->d_namlen] = '\0';
+
+#ifdef HAVE_CASE_INSENSITIVE_FS
+  uppercasify (dentry->d_name);
+#endif
+
+  return (dentry);
+}
+
+int
+closedir (DIR *dir)
+{
+  if (dir != NULL)
+    {
+      struct FAB *dfab = &dir->fab;
+      struct NAM *dnam = (struct NAM *)(dfab->fab$l_nam);
+      if (dnam != NULL)
+        free (dnam->nam$l_esa);
+      free (dnam);
+      free (dir);
+    }
+
+  return 0;
+}
+#endif /* compiled for OpenVMS prior to V7.x */
+
+/* Argv0 will be a full vms file specification, like
+   node$dka100:[utils.gnumake]make.exe;47
+   prefix it with "mcr " to make it a vms command, executable for DCL. */
+const char *
+vms_command(const char* argv0)
+{
+  size_t l = strlen(argv0) + 1;
+  char* s = xmalloc(l + 4);
+  memcpy(s, "mcr ", 4);
+  memcpy(s+4, argv0, l);
+  return s;
+}
+
+/* Argv0 aka argv[0] will be a full vms file specification, like
+   node$dka100:[utils.gnumake]make.exe;47, set up by the CRTL.
+   The vms progname should be ^^^^, the file name without
+   file type .exe and ;version.
+   Use sys$parse to get the name part of the file specification. That is
+   in the above example, pick up "make" and return a copy of that string.
+   If something goes wrong in sys$parse (unlikely, this is a VMS/CRTL supplied
+   file specification) or if there is an empty name part (not easy to produce,
+   but it is possible) just return "make".
+   Somes notes ...
+   NAM[L]$M_SYNCHK requests a syntax check, only.
+   NAM is for ODS2 names (shorter parts, output usually converted to UPPERCASE).
+   NAML is for ODS2/ODS5 names (longer parts, output unchanged).
+   NAM$M_NO_SHORT_UPCASE may not be available for older versions of VMS.
+   NAML is not available on older versions of VMS (NAML$C_BID not defined).
+   argv[0] on older versions of VMS (no extended parse style and no
+   CRTL feature DECC$ARGV_PARSE_STYLE) is always in lowercase. */
+const char *
+vms_progname(const char* argv0)
+{
+  int status;
+  static struct FAB fab;
+  char *progname;
+  const char *fallback = "make";
+
+#ifdef NAML$C_BID
+  static char esa[NAML$C_MAXRSS];
+  static struct NAML naml;
+#else
+  static char esa[NAM$C_MAXRSS];
+  static struct NAM nam;
+#endif
+
+  fab = cc$rms_fab;
+  fab.fab$l_fna = (char*)argv0;
+  fab.fab$b_fns = strlen(argv0);
+
+#ifdef NAML$C_BID
+  fab.fab$l_naml = &naml;
+  naml = cc$rms_naml;
+  naml.naml$l_long_expand = esa;
+  naml.naml$l_long_expand_alloc = NAML$C_MAXRSS;
+  naml.naml$b_nop = NAML$M_SYNCHK;
+  naml.naml$l_input_flags = NAML$M_NO_SHORT_OUTPUT;
+#else
+  fab.fab$l_nam = &nam;
+  nam = cc$rms_nam;
+  nam.nam$l_esa = esa;
+  nam.nam$b_ess = NAM$C_MAXRSS;
+# ifdef NAM$M_NO_SHORT_UPCASE
+  nam.nam$b_nop = NAM$M_SYNCHK | NAM$M_NO_SHORT_UPCASE;
+# else
+  nam.nam$b_nop = NAM$M_SYNCHK;
+# endif
+#endif
+
+  status = sys$parse(&fab);
+  if (!(status & 1))
+    return fallback;
+
+#ifdef NAML$C_BID
+  if (naml.naml$l_long_name_size == 0)
+    return fallback;
+  progname = xmalloc(naml.naml$l_long_name_size + 1);
+  memcpy(progname, naml.naml$l_long_name, naml.naml$l_long_name_size);
+  progname[naml.naml$l_long_name_size] = '\0';
+#else
+  if (nam.nam$b_name == 0)
+    return fallback;
+  progname = xmalloc(nam.nam$b_name + 1);
+# ifdef NAM$M_NO_SHORT_UPCASE
+  memcpy(progname, nam.nam$l_name, nam.nam$b_name);
+# else
+    {
+      int i;
+      for (i = 0; i < nam.nam$b_name; i++)
+        progname[i] = tolower(nam.nam$l_name[i]);
+    }
+# endif
+  progname[nam.nam$b_name] = '\0';
+#endif
+
+  return progname;
+}
diff --git a/src/vmsify.c b/src/vmsify.c
new file mode 100644
index 0000000..249aa06
--- /dev/null
+++ b/src/vmsify.c
@@ -0,0 +1,1005 @@
+/* vmsify.c -- Module for vms <-> unix file name conversion
+Copyright (C) 1996-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Written by Klaus Kmpf (kkaempf@progis.de)
+   of proGIS Software, Aachen, Germany */
+
+
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+
+#include "makeint.h"
+
+#if VMS
+#include <unixlib.h>
+#include <stdlib.h>
+#include <jpidef.h>
+#include <descrip.h>
+#include <uaidef.h>
+#include <ssdef.h>
+#include <starlet.h>
+#include <lib$routines.h>
+/* Initialize a string descriptor (struct dsc$descriptor_s) for an
+   arbitrary string.   ADDR is a pointer to the first character
+   of the string, and LEN is the length of the string. */
+
+#define INIT_DSC_S(dsc, addr, len) do { \
+  (dsc).dsc$b_dtype = DSC$K_DTYPE_T;    \
+  (dsc).dsc$b_class = DSC$K_CLASS_S;    \
+  (dsc).dsc$w_length = (len);           \
+  (dsc).dsc$a_pointer = (addr);         \
+} while (0)
+
+/* Initialize a string descriptor (struct dsc$descriptor_s) for a
+   NUL-terminated string.  S is a pointer to the string; the length
+   is determined by calling strlen(). */
+
+#define INIT_DSC_CSTRING(dsc, s) INIT_DSC_S(dsc, s, strlen(s))
+#endif
+
+/*
+  copy 'from' to 'to' up to but not including 'upto'
+  return 0 if eos on from
+  return 1 if upto found
+
+  return 'to' at last char + 1
+  return 'from' at match + 1 or eos if no match
+
+  if as_dir == 1, change all '.' to '_'
+  else change all '.' but the last to '_'
+*/
+
+static int
+copyto (char **to, const char **from, char upto, int as_dir)
+{
+  const char *s;
+
+  s = strrchr (*from, '.');
+
+  while (**from)
+    {
+      if (**from == upto)
+	{
+	  do
+	    {
+	      (*from)++;
+	    }
+	  while (**from == upto);
+	  return 1;
+	}
+      if (**from == '.')
+	{
+	  if ((as_dir == 1)
+	      || (*from != s))
+	    **to = '_';
+	  else
+	    **to = '.';
+	}
+      else
+	{
+#ifdef HAVE_CASE_INSENSITIVE_FS
+	  if (isupper ((unsigned char)**from))
+	    **to = tolower ((unsigned char)**from);
+	  else
+#endif
+	    **to = **from;
+	}
+      (*to)++;
+      (*from)++;
+    }
+
+  return 0;
+}
+
+
+/*
+  get translation of logical name
+
+*/
+
+static char *
+trnlog (const char *name)
+{
+  int stat;
+  static char reslt[1024];
+  $DESCRIPTOR (reslt_dsc, reslt);
+  short resltlen;
+  struct dsc$descriptor_s name_dsc;
+  char *s;
+
+  /*
+   * the string isn't changed, but there is no string descriptor with
+   * "const char *dsc$a_pointer"
+   */
+  INIT_DSC_CSTRING (name_dsc, (char *)name);
+
+  stat = lib$sys_trnlog (&name_dsc, &resltlen, &reslt_dsc);
+
+  if ((stat&1) == 0)
+    {
+      return "";
+    }
+  if (stat == SS$_NOTRAN)
+    {
+      return "";
+    }
+  reslt[resltlen] = '\0';
+
+  s = xmalloc (resltlen+1);
+  strcpy (s, reslt);
+  return s;
+}
+
+static char *
+showall (char *s)
+{
+  static char t[512];
+  char *pt;
+
+  pt = t;
+  if (strchr (s, '\\') == 0)
+    return s;
+  while (*s)
+    {
+      if (*s == '\\')
+	{
+	  *pt++ = *s;
+	}
+      *pt++ = *s++;
+    }
+  return pt;
+}
+
+
+enum namestate { N_START, N_DEVICE, N_OPEN, N_DOT, N_CLOSED, N_DONE };
+
+/*
+  convert unix style name to vms style
+  type = 0 -> name is a full name (directory and filename part)
+  type = 1 -> name is a directory
+  type = 2 -> name is a filename without directory
+
+  The following conversions are applied
+			(0)		(1)			(2)
+	input		full name	dir name		file name
+
+1	./		<cwd>		[]			<current directory>.dir
+2	../		<home of cwd>	<home of cwd>		<home of cwd>.dir
+
+3	//		<dev of cwd>:	<dev of cwd>:[000000]	<dev of cwd>:000000.dir
+4	//a		a:		a:			a:
+5	//a/		a:		a:			a:000000.dir
+
+9	/		[000000]	[000000]		000000.dir
+10	/a		[000000]a	[a]			[000000]a
+11	/a/		[a]		[a]			[000000]a.dir
+12	/a/b		[a]b		[a.b]			[a]b
+13	/a/b/		[a.b]		[a.b]			[a]b.dir
+14	/a/b/c		[a.b]c		[a.b.c]			[a.b]c
+15	/a/b/c/		[a.b.c]		[a.b.c]			[a.b]c.dir
+
+16	a		a		[.a]			a
+17	a/		[.a]		[.a]			a.dir
+18	a/b		[.a]b		[.a.b]			[.a]b
+19	a/b/		[.a.b]		[.a.b]			[.a]b.dir
+20	a/b/c		[.a.b]c		[.a.b.c]		[.a.b]c
+21	a/b/c/		[.a.b.c]	[.a.b.c]		[.a.b]c.dir
+
+22	a.b.c		a_b.c		[.a_b_c]		a_b_c.dir
+
+23	[x][y]z		[x.y]z		[x.y]z			[x.y]z
+24	[x][.y]z	[x.y]z		[x.y]z			[x.y]z
+
+25  filenames with '$'  are left unchanged if they contain no '/'
+25  filenames with ':' are left unchanged
+26  filenames with a single pair of '[' ']' are left unchanged
+
+  The input string is not written to.  The result is also const because
+  it's a static buffer; we don't want to change it.
+*/
+
+const char *
+vmsify (const char *name, int type)
+{
+/* max 255 device
+   max 39 directory
+   max 39 filename
+   max 39 filetype
+   max 5 version
+*/
+/* todo: VMSMAXPATHLEN is defined for ODS2 names: it needs to be adjusted. */
+#define VMSMAXPATHLEN 512
+
+  enum namestate nstate;
+  static char vmsname[VMSMAXPATHLEN+1];
+  const char *fptr;
+  const char *t;
+  char *vptr;
+  int as_dir;
+  int count;
+  const char *s;
+  const char *s1;
+  const char *s2;
+
+  if (name == 0)
+    return 0;
+  fptr = name;
+  vptr = vmsname;
+  nstate = N_START;
+
+  /* case 25a */
+  t = strpbrk (name, "$:");
+
+  if (t != 0)
+    {
+//      const char *s1;
+//      const char *s2;
+
+      if (type == 1)
+        {
+          s1 = strchr (t+1, '[');
+          s2 = strchr (t+1, ']');
+        }
+
+      if (*t == '$')
+        {
+          if (strchr (name, '/') == 0)
+            {
+              strcpy (vmsname, name);
+              if ((type == 1) && (s1 != 0) && (s2 == 0))
+                strcat (vmsname, "]");
+              return vmsname;
+            }
+        }
+      else
+        {
+          strcpy (vmsname, name);
+          if ((type == 1) && (s1 != 0) && (s2 == 0))
+            strcat (vmsname, "]");
+          return vmsname;
+        }
+    }
+
+  /* case 26 */
+  t = strchr (name, '[');
+
+  if (t != 0)
+    {
+//      const char *s;
+//      const char *s1 = strchr (t+1, '[');
+      s1 = strchr (t+1, '[');
+      if (s1 == 0)
+	{
+          strcpy (vmsname, name);
+	  if ((type == 1) && (strchr (t+1, ']') == 0))
+            strcat (vmsname, "]");
+          return vmsname;
+	}
+      s1--;
+      if (*s1 != ']')
+	{
+          strcpy (vmsname, name);
+	  return vmsname;		/* not ][, keep unchanged */
+	}
+
+      /* we have ][ */
+
+      s = name;
+
+      /* s  -> starting char
+	 s1 -> ending ']'  */
+      do
+	{
+	  strncpy (vptr, s, s1-s);	/* copy up to but not including ']' */
+	  vptr += s1-s;
+	  if (*s1 == 0)
+	    break;
+	  s = s1 + 1;			/* s -> char behind ']' */
+	  if (*s != '[')		/* was '][' ? */
+	    break;			/* no, last ] found, exit */
+	  s++;
+	  if (*s != '.')
+	    *vptr++ = '.';
+	  s1 = strchr (s, ']');
+	  if (s1 == 0)			/* no closing ] */
+	    s1 = s + strlen (s);
+	}
+      while (1);
+
+      *vptr++ = ']';
+
+      fptr = s;
+
+    }
+  else		/* no [ in name */
+    {
+      int state = 0;
+      int rooted = 1;	/* flag if logical is rooted, else insert [000000] */
+
+      do
+	{
+      switch (state)
+	{
+	  case 0:				/* start of loop */
+	    if (*fptr == '/')
+	      {
+		fptr++;
+		state = 1;
+	      }
+	    else if (*fptr == '.')
+	      {
+		fptr++;
+		state = 10;
+	      }
+	    else
+	      state = 2;
+	    break;
+
+	  case 1:				/* '/' at start */
+	    if (*fptr == '/')
+	      {
+		fptr++;
+		state = 3;
+	      }
+	    else
+	      state = 4;
+	    break;
+
+	  case 2:				/* no '/' at start */
+            {
+            const char *s = strchr (fptr, '/');
+	    if (s == 0)			/* no '/' (16) */
+	      {
+		if (type == 1)
+		  {
+		    strcpy (vptr, "[.");
+		    vptr += 2;
+		  }
+		copyto (&vptr, &fptr, 0, (type==1));
+		if (type == 1)
+		  *vptr++ = ']';
+		state = -1;
+	      }
+	    else			/* found '/' (17..21) */
+	      {
+		if ((type == 2)
+		    && (*(s+1) == 0))	/* 17(2) */
+		  {
+		    copyto (&vptr, &fptr, '/', 1);
+		    state = 7;
+		  }
+		else
+		  {
+		    strcpy (vptr, "[.");
+		    vptr += 2;
+		    copyto (&vptr, &fptr, '/', 1);
+		    nstate = N_OPEN;
+		    state = 9;
+		  }
+	      }
+	    break;
+            }
+
+	  case 3:				/* '//' at start */
+            {
+//            const char *s;
+//            const char *s1;
+            char *vp;
+	    while (*fptr == '/')	/* collapse all '/' */
+	      fptr++;
+	    if (*fptr == 0)		/* just // */
+	      {
+		char cwdbuf[VMSMAXPATHLEN+1];
+
+		s1 = getcwd(cwdbuf, VMSMAXPATHLEN);
+		if (s1 == 0)
+		  {
+                    vmsname[0] = '\0';
+		    return vmsname;	/* FIXME, err getcwd */
+		  }
+		s = strchr (s1, ':');
+		if (s == 0)
+		  {
+                    vmsname[0] = '\0';
+		    return vmsname;	/* FIXME, err no device */
+		  }
+		strncpy (vptr, s1, s-s1+1);
+		vptr += s-s1+1;
+		state = -1;
+		break;
+	      }
+
+	    s = vptr;
+
+	    if (copyto (&vptr, &fptr, '/', 1) == 0)	/* copy device part */
+	      {
+		*vptr++ = ':';
+		state = -1;
+		break;
+	      }
+	    *vptr = ':';
+	    nstate = N_DEVICE;
+	    if (*fptr == 0)	/* just '//a/' */
+	      {
+		strcpy (vptr+1, "[000000]");
+		vptr += 9;
+		state = -1;
+		break;
+	      }
+	    *vptr = 0;
+				/* check logical for [000000] insertion */
+	    vp = trnlog (s);
+	    if (*vp != '\0')
+	      {			/* found translation */
+		for (;;)	/* loop over all nested logicals */
+		  {
+		    char *vp2 = vp + strlen (vp) - 1;
+		    if (*vp2 == ':')	/* translation ends in ':' */
+		      {
+			vp2 = trnlog (vp);
+			free (vp);
+			if (*vp2 == 0)
+			  {
+			    rooted = 0;
+			    break;
+			  }
+			vp = vp2;
+			continue;	/* next iteration */
+		      }
+		    if (*vp2 == ']')	/* translation ends in ']' */
+		      {
+			if (*(vp2-1) == '.')	/* ends in '.]' */
+			  {
+			    if (strncmp (fptr, "000000", 6) != 0)
+			      rooted = 0;
+			  }
+			else
+			  {
+			    strcpy (vmsname, s1);
+			    vp = strchr (vmsname, ']');
+			    *vp = '.';
+			    nstate = N_DOT;
+			    vptr = vp;
+			  }
+		      }
+		    break;
+		  }
+		free (vp);
+	      }
+	    else
+	      rooted = 0;
+
+	    if (*vptr == 0)
+	      {
+		nstate = N_DEVICE;
+	        *vptr++ = ':';
+	      }
+	    else
+	      vptr++;
+
+	    if (rooted == 0)
+	      {
+		nstate = N_DOT;
+	        strcpy (vptr, "[000000.");
+		vptr += 8;
+		vp = vptr-1;
+	      }
+	    else
+	      vp = 0;
+
+            /* vp-> '.' after 000000 or NULL */
+
+	    s = strchr (fptr, '/');
+	    if (s == 0)
+	      {				/* no next '/' */
+		if (*(vptr-1) == '.')
+		  *(vptr-1) = ']';
+		else if (rooted == 0)
+		  *vptr++ = ']';
+		copyto (&vptr, &fptr, 0, (type == 1));
+		state = -1;
+		break;
+	      }
+	    else
+	      {
+		while (*(s+1) == '/')	/* skip multiple '/' */
+		  s++;
+	      }
+
+	    if ((rooted != 0)
+	        && (*(vptr-1) != '.'))
+	      {
+		*vptr++ = '[';
+		nstate = N_DOT;
+	      }
+	    else
+	      if ((nstate == N_DOT)
+		 && (vp != 0)
+		 && (*(s+1) == 0))
+		{
+		  if (type == 2)
+		    {
+		      *vp = ']';
+		      nstate = N_CLOSED;
+		    }
+		}
+	    state = 9;
+	    break;
+            }
+	  case 4:				/* single '/' at start (9..15) */
+	    if (*fptr == 0)
+	      state = 5;
+	    else
+	      state = 6;
+	    break;
+
+	  case 5:				/* just '/' at start (9) */
+	    if (type != 2)
+	      {
+	        *vptr++ = '[';
+		nstate = N_OPEN;
+	      }
+	    strcpy (vptr, "000000");
+	    vptr += 6;
+	    if (type == 2)
+	      state = 7;
+	    else
+	      state = 8;
+	    break;
+
+	  case 6:		/* chars following '/' at start 10..15 */
+            {
+            const char *s;
+	    *vptr++ = '[';
+	    nstate = N_OPEN;
+	    s = strchr (fptr, '/');
+	    if (s == 0)			/* 10 */
+	      {
+		if (type != 1)
+		  {
+		    strcpy (vptr, "000000]");
+		    vptr += 7;
+		  }
+		copyto (&vptr, &fptr, 0, (type == 1));
+		if (type == 1)
+		  {
+		    *vptr++ = ']';
+		  }
+		state = -1;
+	      }
+	    else			/* 11..15 */
+	      {
+		if ( (type == 2)
+		   && (*(s+1) == 0))	/* 11(2) */
+		  {
+		    strcpy (vptr, "000000]");
+		    nstate = N_CLOSED;
+		    vptr += 7;
+		  }
+		copyto (&vptr, &fptr, '/', (*(vptr-1) != ']'));
+		state = 9;
+	      }
+	    break;
+            }
+
+	  case 7:				/* add '.dir' and exit */
+	    if ((nstate == N_OPEN)
+		|| (nstate == N_DOT))
+	      {
+		char *vp = vptr-1;
+		while (vp > vmsname)
+		  {
+		    if (*vp == ']')
+		      {
+			break;
+		      }
+		    if (*vp == '.')
+		      {
+			*vp = ']';
+			break;
+		      }
+		    vp--;
+		  }
+	      }
+	    strcpy (vptr, ".dir");
+	    vptr += 4;
+	    state = -1;
+	    break;
+
+	  case 8:				/* add ']' and exit */
+	    *vptr++ = ']';
+	    state = -1;
+	    break;
+
+	  case 9:			/* 17..21, fptr -> 1st '/' + 1 */
+            {
+            const char *s;
+	    if (*fptr == 0)
+	      {
+		if (type == 2)
+		  {
+		    state = 7;
+		  }
+		else
+		  state = 8;
+		break;
+	      }
+	    s = strchr (fptr, '/');
+	    if (s == 0)
+	      {
+		if (type != 1)
+		  {
+		    if (nstate == N_OPEN)
+		      {
+			*vptr++ = ']';
+			nstate = N_CLOSED;
+		      }
+		    as_dir = 0;
+		  }
+		else
+		  {
+		    if (nstate == N_OPEN)
+		      {
+			*vptr++ = '.';
+			nstate = N_DOT;
+		      }
+		    as_dir = 1;
+		  }
+	      }
+	    else
+	      {
+		while (*(s+1) == '/')
+		  s++;
+		if ( (type == 2)
+		    && (*(s+1) == 0))		/* 19(2), 21(2)*/
+		  {
+		    if (nstate != N_CLOSED)
+		      {
+			*vptr++ = ']';
+			nstate = N_CLOSED;
+		      }
+		    as_dir = 1;
+		  }
+		else
+		  {
+		    if (nstate == N_OPEN)
+		      {
+			*vptr++ = '.';
+			nstate = N_DOT;
+		      }
+		    as_dir = 1;
+		  }
+	      }
+	    if ( (*fptr == '.')			/* check for '..' or '../' */
+		&& (*(fptr+1) == '.')
+		&& ((*(fptr+2) == '/')
+		    || (*(fptr+2) == 0)) )
+	      {
+                char *vp;
+		fptr += 2;
+		if (*fptr == '/')
+		  {
+		    do
+		      {
+			fptr++;
+		      }
+		    while (*fptr == '/');
+		  }
+		else if (*fptr == 0)
+		  type = 1;
+		vptr--;				/* vptr -> '.' or ']' */
+		vp = vptr;
+		for (;;)
+		  {
+		    vp--;
+		    if (*vp == '.')		/* one back */
+		      {
+			vptr = vp;
+			nstate = N_OPEN;
+			break;
+		      }
+		    if (*vp == '[')		/* top level reached */
+		      {
+			if (*fptr == 0)
+			  {
+			    strcpy (vp, "[000000]");
+			    vptr = vp + 8;
+			    nstate = N_CLOSED;
+			    s = 0;
+			    break;
+			  }
+			else
+			  {
+			    vptr = vp+1;
+			    nstate = N_OPEN;
+			    break;
+			  }
+		      }
+		  }
+	      }
+	    else
+	      {
+		copyto (&vptr, &fptr, '/', as_dir);
+		if (nstate == N_DOT)
+		  nstate = N_OPEN;
+	      }
+	    if (s == 0)
+	      {					/* 18,20 */
+		if (type == 1)
+		  *vptr++ = ']';
+		state = -1;
+	      }
+	    else
+	      {
+		if (*(s+1) == 0)
+		  {
+		    if (type == 2)		/* 19,21 */
+		      {
+		        state = 7;
+		      }
+		    else
+		      {
+			*vptr++ = ']';
+			state = -1;
+		      }
+		  }
+	      }
+	    break;
+            }
+
+	  case 10:				/* 1,2 first is '.' */
+	    if (*fptr == '.')
+	      {
+		fptr++;
+		state = 11;
+	      }
+	    else
+	      state = 12;
+	    break;
+
+	  case 11:				/* 2, '..' at start */
+	    count = 1;
+	    if (*fptr != 0)
+	      {
+		if (*fptr != '/')		/* got ..xxx */
+		  {
+                    strcpy (vmsname, name);
+		    return vmsname;
+		  }
+		do				/* got ../ */
+		  {
+		    fptr++;
+		    while (*fptr == '/') fptr++;
+		    if (*fptr != '.')
+		      break;
+		    if (*(fptr+1) != '.')
+		      break;
+		    fptr += 2;
+		    if ((*fptr == 0)
+			|| (*fptr == '/'))
+		      count++;
+		  }
+		while (*fptr == '/');
+	      }
+	    {					/* got '..' or '../' */
+              char *vp;
+	      char cwdbuf[VMSMAXPATHLEN+1];
+
+	      vp = getcwd(cwdbuf, VMSMAXPATHLEN);
+	      if (vp == 0)
+		{
+                  vmsname[0] = '\0';
+		  return vmsname;    /* FIXME, err getcwd */
+		}
+	      strcpy (vptr, vp);
+	      vp = strchr (vptr, ']');
+	      if (vp != 0)
+		{
+		  nstate = N_OPEN;
+		  while (vp > vptr)
+		    {
+		      vp--;
+		      if (*vp == '[')
+			{
+			  vp++;
+			  strcpy (vp, "000000]");
+			  state = -1;
+			  break;
+			}
+		      else if (*vp == '.')
+			{
+			  if (--count == 0)
+			    {
+			      if (*fptr == 0)	/* had '..' or '../' */
+				{
+				  *vp++ = ']';
+				  state = -1;
+				}
+			      else			/* had '../xxx' */
+				{
+				  state = 9;
+				}
+			      *vp = '\0';
+			      break;
+			    }
+			}
+		    }
+		}
+	      vptr += strlen (vptr);
+	    }
+	    break;
+
+	  case 12:				/* 1, '.' at start */
+	    if (*fptr != 0)
+	      {
+		if (*fptr != '/')
+		  {
+                    strcpy (vmsname, name);
+		    return vmsname;
+		  }
+		while (*fptr == '/')
+		  fptr++;
+	      }
+
+	    {
+              char *vp;
+	      char cwdbuf[VMSMAXPATHLEN+1];
+
+	      vp = getcwd(cwdbuf, VMSMAXPATHLEN);
+	      if (vp == 0)
+		{
+                  vmsname[0] = '\0';
+		  return vmsname;    /*FIXME, err getcwd */
+		}
+	      strcpy (vptr, vp);
+            }
+            if (*fptr == 0)
+              {
+                state = -1;
+                break;
+              }
+            else
+              {
+                char *vp = strchr (vptr, ']');
+                if (vp == 0)
+                  {
+                    state = -1;
+                    break;
+                  }
+                *vp = '\0';
+                nstate = N_OPEN;
+                vptr += strlen (vptr);
+                state = 9;
+              }
+	    break;
+	}
+
+	}
+      while (state > 0);
+
+
+    }
+
+
+  /* directory conversion done
+     fptr -> filename part of input string
+     vptr -> free space in vmsname
+  */
+
+  *vptr++ = 0;
+
+  return vmsname;
+}
+
+
+
+/*
+  convert from vms-style to unix-style
+
+  dev:[dir1.dir2]	//dev/dir1/dir2/
+*/
+
+const char *
+unixify (const char *name)
+{
+  static char piece[512];
+  const char *s;
+  char *p;
+
+  if (strchr (name, '/') != 0)		/* already in unix style */
+    {
+      strcpy (piece, name);
+      return piece;
+    }
+
+  p = piece;
+  *p = 0;
+
+  /* device part */
+
+  s = strchr (name, ':');
+
+  if (s != 0)
+    {
+      int l = s - name;
+      *p++ = '/';
+      *p++ = '/';
+      strncpy (p, name, l);
+      p += l;
+    }
+
+  /* directory part */
+
+  *p++ = '/';
+  s = strchr (name, '[');
+
+  if (s != 0)
+    {
+      s++;
+      switch (*s)
+        {
+	  case ']':		/* [] */
+	    strcat (p, "./");
+	    break;
+	  case '-':		/* [- */
+	    strcat (p, "../");
+	    break;
+	  case '.':
+	    strcat (p, "./");	/* [. */
+	    break;
+	  default:
+	    s--;
+	    break;
+        }
+      s++;
+      while (*s)
+        {
+	  if (*s == '.')
+	    *p++ = '/';
+	  else
+	    *p++ = *s;
+	  s++;
+	  if (*s == ']')
+	    {
+	      s++;
+	      break;
+	    }
+        }
+      if (*s != 0)		/* more after ']' ?? */
+        {
+	  if (*(p-1) != '/')
+	    *p++ = '/';
+	  strcpy (p, s);		/* copy it anyway */
+        }
+    }
+
+  else		/* no '[' anywhere */
+
+    {
+      *p++ = 0;
+    }
+
+  /* force end with '/' */
+
+  if (*(p-1) != '/')
+    *p++ = '/';
+  *p = 0;
+
+  return piece;
+}
+
+/* EOF */
diff --git a/src/vmsjobs.c b/src/vmsjobs.c
new file mode 100644
index 0000000..717861d
--- /dev/null
+++ b/src/vmsjobs.c
@@ -0,0 +1,1468 @@
+/* --------------- Moved here from job.c ---------------
+   This file must be #included in job.c, as it accesses static functions.
+
+Copyright (C) 1996-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <string.h>
+#include <descrip.h>
+#include <clidef.h>
+
+/* TODO - VMS specific header file conditionally included in makeint.h */
+
+#include <stsdef.h>
+#include <ssdef.h>
+void
+decc$exit (int status);
+
+/* Lowest legal non-success VMS exit code is 8 */
+/* GNU make only defines codes 0, 1, 2 */
+/* So assume any exit code > 8 is a VMS exit code */
+
+#ifndef MAX_EXPECTED_EXIT_CODE
+# define MAX_EXPECTED_EXIT_CODE 7
+#endif
+
+
+#if __CRTL_VER >= 70302000 && !defined(__VAX)
+# define MAX_DCL_LINE_LENGTH 4095
+# define MAX_DCL_CMD_LINE_LENGTH 8192
+#else
+# define MAX_DCL_LINE_LENGTH 255
+# define MAX_DCL_CMD_LINE_LENGTH 1024
+#endif
+#define MAX_DCL_TOKEN_LENGTH 255
+#define MAX_DCL_TOKENS 127
+
+enum auto_pipe { nopipe, add_pipe, dcl_pipe };
+
+char *vmsify (char *name, int type);
+
+static int vms_jobsefnmask = 0;
+
+/* returns whether path is assumed to be a unix like shell. */
+int
+_is_unixy_shell (const char *path)
+{
+  return vms_gnv_shell;
+}
+
+#define VMS_GETMSG_MAX 256
+static char vms_strsignal_text[VMS_GETMSG_MAX + 2];
+
+char *
+vms_strsignal (int status)
+{
+  if (status <= MAX_EXPECTED_EXIT_CODE)
+    sprintf (vms_strsignal_text, "lib$spawn returned %x", status);
+  else
+    {
+      int vms_status;
+      unsigned short * msg_len;
+      unsigned char out[4];
+      vms_status = SYS$GETMSG (status, &msg_len,
+                               vms_strsignal_text, 7, *out);
+    }
+
+  return vms_strsignal_text;
+}
+
+
+/* Wait for nchildren children to terminate */
+static void
+vmsWaitForChildren (int *status)
+{
+  while (1)
+    {
+      if (!vms_jobsefnmask)
+        {
+          *status = 0;
+          return;
+        }
+
+      *status = sys$wflor (32, vms_jobsefnmask);
+    }
+  return;
+}
+
+static int ctrlYPressed= 0;
+/* This is called at main or AST level. It is at AST level for DONTWAITFORCHILD
+   and at main level otherwise. In any case it is called when a child process
+   terminated. At AST level it won't get interrupted by anything except a
+   inner mode level AST.
+*/
+static int
+vmsHandleChildTerm (struct child *child)
+{
+  int exit_code;
+  struct child *lastc, *c;
+  int child_failed;
+
+  /* The child efn is 0 when a built-in or null command is executed
+     successfully with out actually creating a child.
+  */
+  if (child->efn > 0)
+  {
+    vms_jobsefnmask &= ~(1 << (child->efn - 32));
+
+    lib$free_ef (&child->efn);
+  }
+  if (child->comname)
+    {
+      if (!ISDB (DB_JOBS) && !ctrlYPressed)
+        unlink (child->comname);
+      free (child->comname);
+    }
+
+  (void) sigblock (fatal_signal_mask);
+
+  /* First check to see if this is a POSIX exit status and handle */
+  if ((child->cstatus & VMS_POSIX_EXIT_MASK) == VMS_POSIX_EXIT_MASK)
+    {
+      exit_code = (child->cstatus >> 3) & 255;
+      if (exit_code != MAKE_SUCCESS)
+        child_failed = 1;
+    }
+  else
+    {
+      child_failed = !$VMS_STATUS_SUCCESS (child->cstatus);
+      if (child_failed)
+        exit_code = child->cstatus;
+    }
+
+  /* Search for a child matching the deceased one.  */
+  lastc = 0;
+#if defined(RECURSIVEJOBS)
+  /* I've had problems with recursive stuff and process handling */
+  for (c = children; c != 0 && c != child; lastc = c, c = c->next)
+    ;
+#else
+  c = child;
+#endif
+
+  if ($VMS_STATUS_SUCCESS (child->vms_launch_status))
+    {
+      /* Convert VMS success status to 0 for UNIX code to be happy */
+      child->vms_launch_status = 0;
+    }
+
+  /* Set the state flag to say the commands have finished.  */
+  c->file->command_state = cs_finished;
+  notice_finished_file (c->file);
+
+  (void) sigsetmask (sigblock (0) & ~(fatal_signal_mask));
+
+  return 1;
+}
+
+/* VMS:
+   Spawn a process executing the command in ARGV and return its pid. */
+
+/* local helpers to make ctrl+c and ctrl+y working, see below */
+#include <iodef.h>
+#include <libclidef.h>
+#include <ssdef.h>
+
+static int ctrlMask= LIB$M_CLI_CTRLY;
+static int oldCtrlMask;
+static int setupYAstTried= 0;
+static unsigned short int chan= 0;
+
+static void
+reEnableAst(void)
+{
+  lib$enable_ctrl (&oldCtrlMask,0);
+}
+
+static int
+astYHandler (void)
+{
+  struct child *c;
+  for (c = children; c != 0; c = c->next)
+    sys$delprc (&c->pid, 0, 0);
+  ctrlYPressed= 1;
+  kill (getpid(),SIGQUIT);
+  return SS$_NORMAL;
+}
+
+static void
+tryToSetupYAst(void)
+{
+  $DESCRIPTOR(inputDsc,"SYS$COMMAND");
+  int     status;
+  struct {
+    short int       status, count;
+    int     dvi;
+  } iosb;
+  unsigned short int loc_chan;
+
+  setupYAstTried++;
+
+  if (chan)
+    loc_chan= chan;
+  else
+    {
+      status= sys$assign(&inputDsc,&loc_chan,0,0);
+      if (!(status&SS$_NORMAL))
+        {
+          lib$signal(status);
+          return;
+        }
+    }
+  status= sys$qiow (0, loc_chan, IO$_SETMODE|IO$M_CTRLYAST,&iosb,0,0,
+                    astYHandler,0,0,0,0,0);
+  if (status==SS$_NORMAL)
+    status= iosb.status;
+  if (status!=SS$_NORMAL)
+    {
+      if (!chan)
+        sys$dassgn(loc_chan);
+      if (status!=SS$_ILLIOFUNC && status!=SS$_NOPRIV)
+        lib$signal(status);
+      return;
+    }
+
+  /* called from AST handler ? */
+  if (setupYAstTried>1)
+    return;
+  if (atexit(reEnableAst))
+    fprintf (stderr,
+             _("-warning, you may have to re-enable CTRL-Y handling from DCL.\n"));
+  status= lib$disable_ctrl (&ctrlMask, &oldCtrlMask);
+  if (!(status&SS$_NORMAL))
+    {
+      lib$signal(status);
+      return;
+    }
+  if (!chan)
+    chan = loc_chan;
+}
+
+/* Check if a token is too long */
+#define INC_TOKEN_LEN_OR_RETURN(x) {token->length++; \
+  if (token->length >= MAX_DCL_TOKEN_LENGTH) \
+    { token->cmd_errno = ERANGE; return x; }}
+
+#define INC_TOKEN_LEN_OR_BREAK {token->length++; \
+  if (token->length >= MAX_DCL_TOKEN_LENGTH) \
+    { token->cmd_errno = ERANGE; break; }}
+
+#define ADD_TOKEN_LEN_OR_RETURN(add_len, x) {token->length += add_len; \
+  if (token->length >= MAX_DCL_TOKEN_LENGTH) \
+    { token->cmd_errno = ERANGE; return x; }}
+
+/* Check if we are out of space for more tokens */
+#define V_NEXT_TOKEN { if (cmd_tkn_index < MAX_DCL_TOKENS) \
+  cmd_tokens[++cmd_tkn_index] = NULL; \
+  else { token.cmd_errno = E2BIG; break; } \
+  token.length = 0;}
+
+
+#define UPDATE_TOKEN {cmd_tokens[cmd_tkn_index] = strdup(token.text); \
+  V_NEXT_TOKEN;}
+
+#define EOS_ERROR(x) { if (*x == 0) { token->cmd_errno = ERANGE; break; }}
+
+struct token_info
+  {
+    char *text;       /* Parsed text */
+    int length;       /* Length of parsed text */
+    char *src;        /* Pointer to source text */
+    int cmd_errno;    /* Error status of parse */
+    int use_cmd_file; /* Force use of a command file */
+  };
+
+
+/* Extract a Posix single quoted string from input line */
+static char *
+posix_parse_sq (struct token_info *token)
+{
+  /* A Posix quoted string with no expansion unless in a string
+     Unix simulation means no lexical functions present.
+  */
+  char * q;
+  char * p;
+  q = token->text;
+  p = token->src;
+
+  *q++ = '"';
+  p++;
+  INC_TOKEN_LEN_OR_RETURN (p);
+
+  while (*p != '\'' && (token->length < MAX_DCL_TOKEN_LENGTH))
+    {
+      EOS_ERROR (p);
+      if (*p == '"')
+        {
+          /* Embedded double quotes need to be doubled */
+          *q++ = '"';
+          INC_TOKEN_LEN_OR_BREAK;
+          *q = '"';
+        }
+      else
+        *q = *p;
+
+      q++;
+      p++;
+      INC_TOKEN_LEN_OR_BREAK;
+    }
+  *q++ = '"';
+  p++;
+  INC_TOKEN_LEN_OR_RETURN (p);
+  *q = 0;
+  return p;
+}
+
+/* Extract a Posix double quoted string from input line */
+static char *
+posix_parse_dq (struct token_info *token)
+{
+  /* Unix mode:  Any imbedded \" becomes doubled.
+                 \t is tab, \\, \$ leading character stripped.
+                 $ character replaced with \' unless escaped.
+  */
+  char * q;
+  char * p;
+  q = token->text;
+  p = token->src;
+  *q++ = *p++;
+  INC_TOKEN_LEN_OR_RETURN (p);
+  while (*p != 0)
+    {
+      if (*p == '\\')
+        {
+          switch(p[1])
+            {
+            case 't':     /* Convert tabs */
+              *q = '\t';
+              p++;
+              break;
+            case '\\':     /* Just remove leading backslash */
+            case '$':
+              p++;
+              *q = *p;
+              break;
+            case '"':
+              p++;
+              *q = *p;
+              *q++ = '"';
+              INC_TOKEN_LEN_OR_BREAK;
+            default:      /* Pass through unchanged */
+              *q++ = *p++;
+              INC_TOKEN_LEN_OR_BREAK;
+            }
+          INC_TOKEN_LEN_OR_BREAK;
+        }
+      else if (*p == '$' && isalpha (p[1]))
+        {
+          /* A symbol we should be able to substitute */
+          *q++ = '\'';
+          INC_TOKEN_LEN_OR_BREAK;
+          *q = '\'';
+          INC_TOKEN_LEN_OR_BREAK;
+          token->use_cmd_file = 1;
+        }
+      else
+        {
+          *q = *p;
+          INC_TOKEN_LEN_OR_BREAK;
+          if (*p == '"')
+            {
+              p++;
+              q++;
+              break;
+            }
+        }
+      p++;
+      q++;
+    }
+  *q = 0;
+  return p;
+}
+
+/* Extract a VMS quoted string or substitution string from input line */
+static char *
+vms_parse_quotes (struct token_info *token)
+{
+  /* VMS mode, the \' means that a symbol substitution is starting
+     so while you might think you can just copy until the next
+     \'.  Unfortunately the substitution can be a lexical function
+     which can contain embedded strings and lexical functions.
+     Messy, so both types need to be handled together.
+  */
+  char * q;
+  char * p;
+  q = token->text;
+  p = token->src;
+  int parse_level[MAX_DCL_TOKENS + 1];
+  int nest = 0;
+
+  parse_level[0] = *p;
+  if (parse_level[0] == '\'')
+    token->use_cmd_file = 1;
+
+  *q++ = *p++;
+  INC_TOKEN_LEN_OR_RETURN (p);
+
+
+  /* Copy everything until after the next single quote at nest == 0 */
+  while (token->length < MAX_DCL_TOKEN_LENGTH)
+    {
+      EOS_ERROR (p);
+      *q = *p;
+      INC_TOKEN_LEN_OR_BREAK;
+      if ((*p == parse_level[nest]) && (p[1] != '"'))
+        {
+          if (nest == 0)
+            {
+              *q++ = *p++;
+              break;
+            }
+          nest--;
+        }
+      else
+        {
+          switch(*p)
+            {
+            case '\\':
+              /* Handle continuation on to next line */
+              if (p[1] != '\n')
+                break;
+              p++;
+              p++;
+              *q = *p;
+              break;
+            case '(':
+              /* Parenthesis only in single quote level */
+              if (parse_level[nest] == '\'')
+                {
+                  nest++;
+                  parse_level[nest] == ')';
+                }
+              break;
+            case '"':
+              /* Double quotes only in parenthesis */
+              if (parse_level[nest] == ')')
+                {
+                  nest++;
+                  parse_level[nest] == '"';
+                }
+              break;
+            case '\'':
+              /* Symbol substitution ony in double quotes */
+              if ((p[1] == '\'') && (parse_level[nest] == '"'))
+                {
+                  nest++;
+                  parse_level[nest] == '\'';
+                  *p++ = *q++;
+                  token->use_cmd_file = 1;
+                  INC_TOKEN_LEN_OR_BREAK;
+                  break;
+                }
+              *q = *p;
+            }
+        }
+      p++;
+      q++;
+      /* Pass through doubled double quotes */
+      if ((*p == '"') && (p[1] == '"') && (parse_level[nest] == '"'))
+      {
+        *p++ = *q++;
+        INC_TOKEN_LEN_OR_BREAK;
+        *p++ = *q++;
+        INC_TOKEN_LEN_OR_BREAK;
+      }
+    }
+  *q = 0;
+  return p;
+}
+
+/* Extract a $ string from the input line */
+static char *
+posix_parse_dollar (struct token_info *token)
+{
+  /* $foo becomes 'foo' */
+  char * q;
+  char * p;
+  q = token->text;
+  p = token->src;
+  token->use_cmd_file = 1;
+
+  p++;
+  *q++ = '\'';
+  INC_TOKEN_LEN_OR_RETURN (p);
+
+  while ((isalnum (*p)) || (*p == '_'))
+    {
+      *q++ = *p++;
+      INC_TOKEN_LEN_OR_BREAK;
+    }
+  *q++ = '\'';
+  while (1)
+    {
+      INC_TOKEN_LEN_OR_BREAK;
+      break;
+    }
+  *q = 0;
+  return p;
+}
+
+const char *vms_filechars = "0123456789abcdefghijklmnopqrstuvwxyz" \
+   "ABCDEFGHIJKLMNOPQRSTUVWXYZ[]<>:/_-.$";
+
+/* Simple text copy */
+static char *
+parse_text (struct token_info *token, int assignment_hack)
+{
+  char * q;
+  char * p;
+  int str_len;
+  q = token->text;
+  p = token->src;
+
+  /* If assignment hack, then this text needs to be double quoted. */
+  if (vms_unix_simulation && (assignment_hack == 2))
+    {
+      *q++ = '"';
+      INC_TOKEN_LEN_OR_RETURN (p);
+    }
+
+  *q++ = *p++;
+  INC_TOKEN_LEN_OR_RETURN (p);
+
+  while (*p != 0)
+    {
+      str_len = strspn (p, vms_filechars);
+      if (str_len == 0)
+        {
+          /* Pass through backslash escapes in Unix simulation
+             probably will not work anyway.
+             All any character after a ^ otherwise to support EFS.
+          */
+          if (vms_unix_simulation && (p[0] == '\\') && (p[1] != 0))
+            str_len = 2;
+          else if ((p[0] == '^') && (p[1] != 0))
+            str_len = 2;
+          else if (!vms_unix_simulation && (p[0] == ';'))
+            str_len = 1;
+
+          if (str_len == 0)
+            {
+              /* If assignment hack, then this needs to be double quoted. */
+              if (vms_unix_simulation && (assignment_hack == 2))
+              {
+                *q++ = '"';
+                INC_TOKEN_LEN_OR_RETURN (p);
+              }
+              *q = 0;
+              return p;
+            }
+        }
+      if (str_len > 0)
+        {
+          ADD_TOKEN_LEN_OR_RETURN (str_len, p);
+          strncpy (q, p, str_len);
+          p += str_len;
+          q += str_len;
+          *q = 0;
+        }
+    }
+  /* If assignment hack, then this text needs to be double quoted. */
+  if (vms_unix_simulation && (assignment_hack == 2))
+    {
+      *q++ = '"';
+      INC_TOKEN_LEN_OR_RETURN (p);
+    }
+  return p;
+}
+
+/* single character copy */
+static char *
+parse_char (struct token_info *token, int count)
+{
+  char * q;
+  char * p;
+  q = token->text;
+  p = token->src;
+
+  while (count > 0)
+    {
+      *q++ = *p++;
+      INC_TOKEN_LEN_OR_RETURN (p);
+      count--;
+    }
+  *q = 0;
+  return p;
+}
+
+/* Build a command string from the collected tokens
+   and process built-ins now
+*/
+static struct dsc$descriptor_s *
+build_vms_cmd (char **cmd_tokens,
+               enum auto_pipe use_pipe_cmd,
+               int append_token)
+{
+  struct dsc$descriptor_s *cmd_dsc;
+  int cmd_tkn_index;
+  char * cmd;
+  int cmd_len;
+  int semicolon_seen;
+
+  cmd_tkn_index = 0;
+  cmd_dsc = xmalloc (sizeof (struct dsc$descriptor_s));
+
+  /* Empty command? */
+  if (cmd_tokens[0] == NULL)
+    {
+      cmd_dsc->dsc$a_pointer = NULL;
+      cmd_dsc->dsc$w_length = 0;
+      return cmd_dsc;
+    }
+
+  /* Max DCL command + 1 extra token and trailing space */
+  cmd = xmalloc (MAX_DCL_CMD_LINE_LENGTH + 256);
+
+  cmd[0] = '$';
+  cmd[1] = 0;
+  cmd_len = 1;
+
+  /* Handle real or auto-pipe */
+  if (use_pipe_cmd == add_pipe)
+    {
+      /* We need to auto convert to a pipe command */
+      strcat (cmd, "pipe ");
+      cmd_len += 5;
+    }
+
+  semicolon_seen = 0;
+  while (cmd_tokens[cmd_tkn_index] != NULL)
+    {
+
+      /* Check for buffer overflow */
+      if (cmd_len > MAX_DCL_CMD_LINE_LENGTH)
+        {
+          errno = E2BIG;
+          break;
+        }
+
+      /* Eliminate double ';' */
+      if (semicolon_seen && (cmd_tokens[cmd_tkn_index][0] == ';'))
+        {
+          semicolon_seen = 0;
+          free (cmd_tokens[cmd_tkn_index++]);
+          if (cmd_tokens[cmd_tkn_index] == NULL)
+            break;
+        }
+
+      /* Special handling for CD built-in */
+      if (strncmp (cmd_tokens[cmd_tkn_index], "builtin_cd", 11) == 0)
+        {
+          int result;
+          semicolon_seen = 0;
+          free (cmd_tokens[cmd_tkn_index]);
+          cmd_tkn_index++;
+          if (cmd_tokens[cmd_tkn_index] == NULL)
+            break;
+          DB(DB_JOBS, (_("BUILTIN CD %s\n"), cmd_tokens[cmd_tkn_index]));
+
+          /* TODO: chdir fails with some valid syntaxes */
+          result = chdir (cmd_tokens[cmd_tkn_index]);
+          if (result != 0)
+            {
+              /* TODO: Handle failure better */
+              free (cmd);
+              while (cmd_tokens[cmd_tkn_index] == NULL)
+                free (cmd_tokens[cmd_tkn_index++]);
+              cmd_dsc->dsc$w_length = -1;
+              cmd_dsc->dsc$a_pointer = NULL;
+              return cmd_dsc;
+            }
+        }
+      else if (strncmp (cmd_tokens[cmd_tkn_index], "exit", 5) == 0)
+        {
+          /* Copy the exit command */
+          semicolon_seen = 0;
+          strcpy (&cmd[cmd_len], cmd_tokens[cmd_tkn_index]);
+          cmd_len += strlen (cmd_tokens[cmd_tkn_index]);
+          free (cmd_tokens[cmd_tkn_index++]);
+          if (cmd_len > MAX_DCL_CMD_LINE_LENGTH)
+            {
+              errno = E2BIG;
+              break;
+            }
+
+          /* Optional whitespace */
+          if (isspace (cmd_tokens[cmd_tkn_index][0]))
+            {
+              strcpy (&cmd[cmd_len], cmd_tokens[cmd_tkn_index]);
+              cmd_len += strlen (cmd_tokens[cmd_tkn_index]);
+              free (cmd_tokens[cmd_tkn_index++]);
+              if (cmd_len > MAX_DCL_CMD_LINE_LENGTH)
+              {
+                errno = E2BIG;
+                break;
+              }
+            }
+
+          /* There should be a status, but it is optional */
+          if (cmd_tokens[cmd_tkn_index][0] == ';')
+            continue;
+
+          /* If Unix simulation, add '((' */
+          if (vms_unix_simulation)
+            {
+              strcpy (&cmd[cmd_len], "((");
+              cmd_len += 2;
+              if (cmd_len > MAX_DCL_CMD_LINE_LENGTH)
+                {
+                  errno = E2BIG;
+                  break;
+                }
+            }
+
+          /* Add the parameter */
+          strcpy (&cmd[cmd_len], cmd_tokens[cmd_tkn_index]);
+          cmd_len += strlen (cmd_tokens[cmd_tkn_index]);
+          free (cmd_tokens[cmd_tkn_index++]);
+          if (cmd_len > MAX_DCL_CMD_LINE_LENGTH)
+            {
+              errno = E2BIG;
+              break;
+            }
+
+          /* Add " * 8) .and. %x7f8) .or. %x1035a002" */
+          if (vms_unix_simulation)
+            {
+              const char *end_str = " * 8) .and. %x7f8) .or. %x1035a002";
+              strcpy (&cmd[cmd_len], end_str);
+              cmd_len += strlen (end_str);
+              if (cmd_len > MAX_DCL_CMD_LINE_LENGTH)
+                {
+                  errno = E2BIG;
+                  break;
+                }
+            }
+          continue;
+        }
+
+      /* auto pipe needs spaces before semicolon */
+      if (use_pipe_cmd == add_pipe)
+        if (cmd_tokens[cmd_tkn_index][0] == ';')
+          {
+            cmd[cmd_len++] = ' ';
+            semicolon_seen = 1;
+            if (cmd_len > MAX_DCL_CMD_LINE_LENGTH)
+              {
+                errno = E2BIG;
+                break;
+              }
+          }
+        else
+          {
+            char ch;
+            ch = cmd_tokens[cmd_tkn_index][0];
+            if (!(ch == ' ' || ch == '\t'))
+              semicolon_seen = 0;
+          }
+
+      strcpy (&cmd[cmd_len], cmd_tokens[cmd_tkn_index]);
+      cmd_len += strlen (cmd_tokens[cmd_tkn_index]);
+
+      free (cmd_tokens[cmd_tkn_index++]);
+
+      /* Skip the append tokens if they exist */
+      if (cmd_tkn_index == append_token)
+        {
+          free (cmd_tokens[cmd_tkn_index++]);
+          if (isspace (cmd_tokens[cmd_tkn_index][0]))
+            free (cmd_tokens[cmd_tkn_index++]);
+          free (cmd_tokens[cmd_tkn_index++]);
+        }
+    }
+
+  cmd[cmd_len] = 0;
+  cmd_dsc->dsc$w_length = cmd_len;
+  cmd_dsc->dsc$a_pointer = cmd;
+  cmd_dsc->dsc$b_dtype = DSC$K_DTYPE_T;
+  cmd_dsc->dsc$b_class = DSC$K_CLASS_S;
+
+  return cmd_dsc;
+}
+
+int
+child_execute_job (struct child *child, char *argv)
+{
+  int i;
+
+  static struct dsc$descriptor_s *cmd_dsc;
+  static struct dsc$descriptor_s pnamedsc;
+  int spflags = CLI$M_NOWAIT;
+  int status;
+  int comnamelen;
+  char procname[100];
+
+  char *p;
+  char *cmd_tokens[(MAX_DCL_TOKENS * 2) + 1]; /* whitespace does not count */
+  char token_str[MAX_DCL_TOKEN_LENGTH + 1];
+  struct token_info token;
+  int cmd_tkn_index;
+  int paren_level = 0;
+  enum auto_pipe use_pipe_cmd = nopipe;
+  int append_token = -1;
+  char *append_file = NULL;
+  int unix_echo_cmd = 0;  /* Special handle Unix echo command */
+  int assignment_hack = 0; /* Handle x=y command as piped command */
+
+  /* Parse IO redirection.  */
+
+  child->comname = NULL;
+
+  DB (DB_JOBS, ("child_execute_job (%s)\n", argv));
+
+  while (isspace ((unsigned char)*argv))
+    argv++;
+
+  if (*argv == 0)
+    {
+      /* Only a built-in or a null command - Still need to run term AST */
+      child->cstatus = VMS_POSIX_EXIT_MASK;
+      child->vms_launch_status = SS$_NORMAL;
+      /* TODO what is this "magic number" */
+      child->pid = 270163; /* Special built-in */
+      child->efn = 0;
+      vmsHandleChildTerm (child);
+      return 1;
+    }
+
+  sprintf (procname, "GMAKE_%05x", getpid () & 0xfffff);
+  pnamedsc.dsc$w_length = strlen (procname);
+  pnamedsc.dsc$a_pointer = procname;
+  pnamedsc.dsc$b_dtype = DSC$K_DTYPE_T;
+  pnamedsc.dsc$b_class = DSC$K_CLASS_S;
+
+  /* Old */
+  /* Handle comments and redirection.
+     For ONESHELL, the redirection must be on the first line. Any other
+     redirection token is handled by DCL, that is, the pipe command with
+     redirection can be used, but it should not be used on the first line
+     for ONESHELL. */
+
+  /* VMS parser notes:
+     1. A token is any of DCL verbs, qualifiers, parameters, or punctuation.
+     2. Only MAX_DCL_TOKENS per line in both one line or command file mode.
+     3. Each token limited to MAC_DCL_TOKEN_LENGTH
+     4. If the line to DCL is greater than MAX_DCL_LINE_LENGTH then a
+        command file must be used.
+     5. Currently a command file must be used symbol substitution is to
+        be performed.
+     6. Currently limiting command files to 2 * MAX_DCL_TOKENS.
+
+     Build both a command file token list and command line token list
+     until it is determined that the command line limits are exceeded.
+  */
+
+  cmd_tkn_index = 0;
+  cmd_tokens[cmd_tkn_index] = NULL;
+  p = argv;
+
+  token.text = token_str;
+  token.length = 0;
+  token.cmd_errno = 0;
+  token.use_cmd_file = 0;
+
+  while (*p != 0)
+    {
+      /* We can not build this command so give up */
+      if (token.cmd_errno != 0)
+        break;
+
+      token.src = p;
+
+      switch (*p)
+        {
+        case '\'':
+          if (vms_unix_simulation || unix_echo_cmd)
+            {
+              p = posix_parse_sq (&token);
+              UPDATE_TOKEN;
+              break;
+            }
+
+          /* VMS mode, the \' means that a symbol substitution is starting
+             so while you might think you can just copy until the next
+             \'.  Unfortunately the substitution can be a lexical function
+             which can contain embedded strings and lexical functions.
+             Messy.
+          */
+          p = vms_parse_quotes (&token);
+          UPDATE_TOKEN;
+          break;
+        case '"':
+          if (vms_unix_simulation)
+            {
+              p = posix_parse_dq (&token);
+              UPDATE_TOKEN;
+              break;
+            }
+
+          /* VMS quoted string, can contain lexical functions with
+             quoted strings and nested lexical functions.
+          */
+          p = vms_parse_quotes (&token);
+          UPDATE_TOKEN;
+          break;
+
+        case '$':
+          if (vms_unix_simulation)
+            {
+              p = posix_parse_dollar (&token);
+              UPDATE_TOKEN;
+              break;
+            }
+
+          /* Otherwise nothing special */
+          p = parse_text (&token, 0);
+          UPDATE_TOKEN;
+          break;
+        case '\\':
+          if (p[1] == '\n')
+            {
+              /* Line continuation, remove it */
+              p += 2;
+              break;
+            }
+
+          /* Ordinary character otherwise */
+          if (assignment_hack != 0)
+            assignment_hack++;
+          if (assignment_hack > 2)
+            {
+              assignment_hack = 0;          /* Reset */
+              if (use_pipe_cmd == nopipe)   /* force pipe use */
+                use_pipe_cmd = add_pipe;
+              token_str[0] = ';';              /* add ; token */
+              token_str[1] = 0;
+              UPDATE_TOKEN;
+            }
+          p = parse_text (&token, assignment_hack);
+          UPDATE_TOKEN;
+          break;
+        case '!':
+        case '#':
+          /* Unix '#' is VMS '!' which comments out the rest of the line.
+             Historically the rest of the line has been skipped.
+             Not quite the right thing to do, as the f$verify lexical
+             function works in comments.  But this helps keep the line
+             lengths short.
+          */
+          unix_echo_cmd = 0;
+          while (*p != '\n' && *p != 0)
+            p++;
+          break;
+        case '(':
+          /* Subshell, equation, or lexical function argument start */
+          p = parse_char (&token, 1);
+          UPDATE_TOKEN;
+          paren_level++;
+          break;
+        case ')':
+          /* Close out a paren level */
+          p = parse_char (&token, 1);
+          UPDATE_TOKEN;
+          paren_level--;
+          /* TODO: Should we diagnose if paren_level goes negative? */
+          break;
+        case '&':
+          if (isalpha (p[1]) && !vms_unix_simulation)
+            {
+              /* VMS symbol substitution */
+              p = parse_text (&token, 0);
+              token.use_cmd_file = 1;
+              UPDATE_TOKEN;
+              break;
+            }
+          if (use_pipe_cmd == nopipe)
+            use_pipe_cmd = add_pipe;
+          if (p[1] != '&')
+            p = parse_char (&token, 1);
+          else
+            p = parse_char (&token, 2);
+          UPDATE_TOKEN;
+          break;
+        case '|':
+          if (use_pipe_cmd == nopipe)
+            use_pipe_cmd = add_pipe;
+          if (p[1] != '|')
+            p = parse_char (&token, 1);
+          else
+            p = parse_char (&token, 2);
+          UPDATE_TOKEN;
+          break;
+        case ';':
+          /* Separator - convert to a pipe command. */
+          unix_echo_cmd = 0;
+        case '<':
+          if (use_pipe_cmd == nopipe)
+            use_pipe_cmd = add_pipe;
+          p = parse_char (&token, 1);
+          UPDATE_TOKEN;
+          break;
+        case '>':
+          if (use_pipe_cmd == nopipe)
+            use_pipe_cmd = add_pipe;
+          if (p[1] == '>')
+            {
+              /* Parsing would have been simple until support for the >>
+                 append redirect was added.
+                 Implementation needs:
+                 * if not exist output file create empty
+                 * open/append gnv$make_temp??? output_file
+                 * define/user sys$output gnv$make_temp???
+                 ** And all this done before the command previously tokenized.
+                 * command previously tokenized
+                 * close gnv$make_temp???
+              */
+              p = parse_char (&token, 2);
+              append_token = cmd_tkn_index;
+              token.use_cmd_file = 1;
+            }
+          else
+            p = parse_char (&token, 1);
+          UPDATE_TOKEN;
+          break;
+        case '/':
+          /* Unix path or VMS option start, read until non-path symbol */
+          if (assignment_hack != 0)
+            assignment_hack++;
+          if (assignment_hack > 2)
+            {
+              assignment_hack = 0;          /* Reset */
+              if (use_pipe_cmd == nopipe)   /* force pipe use */
+                use_pipe_cmd = add_pipe;
+              token_str[0] = ';';              /* add ; token */
+              token_str[1] = 0;
+              UPDATE_TOKEN;
+            }
+          p = parse_text (&token, assignment_hack);
+          UPDATE_TOKEN;
+          break;
+        case ':':
+          if ((p[1] == 0) || isspace (p[1]))
+            {
+              /* Unix Null command - treat as comment until next command */
+              unix_echo_cmd = 0;
+              p++;
+              while (*p != 0)
+                {
+                  if (*p == ';')
+                    {
+                      /* Remove Null command from pipeline */
+                      p++;
+                      break;
+                    }
+                  p++;
+                }
+              break;
+            }
+
+          /* String assignment */
+          /* := :== or : */
+          if (p[1] != '=')
+            p = parse_char (&token, 1);
+          else if (p[2] != '=')
+            p = parse_char (&token, 2);
+          else
+            p = parse_char (&token, 3);
+          UPDATE_TOKEN;
+          break;
+        case '=':
+          /* = or == */
+          /* If this is not an echo statement, this could be a shell
+             assignment.  VMS requires the target to be quoted if it
+             is not a macro substitution */
+          if (!unix_echo_cmd && vms_unix_simulation && (assignment_hack == 0))
+            assignment_hack = 1;
+          if (p[1] != '=')
+            p = parse_char (&token, 1);
+          else
+            p = parse_char (&token, 2);
+          UPDATE_TOKEN;
+          break;
+        case '+':
+        case '-':
+        case '*':
+          p = parse_char (&token, 1);
+          UPDATE_TOKEN;
+          break;
+        case '.':
+          /* .xxx. operation, VMS does not require the trailing . */
+          p = parse_text (&token, 0);
+          UPDATE_TOKEN;
+          break;
+        default:
+          /* Skip repetitive whitespace */
+          if (isspace (*p))
+            {
+              p = parse_char (&token, 1);
+
+              /* Force to a space or a tab */
+              if ((token_str[0] != ' ') ||
+                  (token_str[0] != '\t'))
+                token_str[0] = ' ';
+              UPDATE_TOKEN;
+
+              while (isspace (*p))
+                p++;
+              if (assignment_hack != 0)
+                assignment_hack++;
+              break;
+            }
+
+          if (assignment_hack != 0)
+            assignment_hack++;
+          if (assignment_hack > 2)
+            {
+              assignment_hack = 0;          /* Reset */
+              if (use_pipe_cmd == nopipe)   /* force pipe use */
+                use_pipe_cmd = add_pipe;
+              token_str[0] = ';';              /* add ; token */
+              token_str[1] = 0;
+              UPDATE_TOKEN;
+            }
+          p = parse_text (&token, assignment_hack);
+          if (strncasecmp (token.text, "echo", 4) == 0)
+            unix_echo_cmd = 1;
+          else if (strncasecmp (token.text, "pipe", 4) == 0)
+            use_pipe_cmd = dcl_pipe;
+          UPDATE_TOKEN;
+          break;
+        }
+    }
+
+  /* End up here with a list of tokens to build a command line.
+     Deal with errors detected during parsing.
+   */
+  if (token.cmd_errno != 0)
+    {
+      while (cmd_tokens[cmd_tkn_index] == NULL)
+        free (cmd_tokens[cmd_tkn_index++]);
+      child->cstatus = VMS_POSIX_EXIT_MASK | (MAKE_TROUBLE << 3);
+      child->vms_launch_status = SS$_ABORT;
+      /* TODO what is this "magic number" */
+      child->pid = 270163; /* Special built-in */
+      child->efn = 0;
+      errno = token.cmd_errno;
+      return 0;
+    }
+
+  /* Save any redirection to append file */
+  if (append_token != -1)
+    {
+      int file_token;
+      char * lastdot;
+      char * lastdir;
+      char * raw_append_file;
+      file_token = append_token;
+      file_token++;
+      if (isspace (cmd_tokens[file_token][0]))
+        file_token++;
+      raw_append_file = vmsify (cmd_tokens[file_token], 0);
+      /* VMS DCL needs a trailing dot if null file extension */
+      lastdot = strrchr(raw_append_file, '.');
+      lastdir = strrchr(raw_append_file, ']');
+      if (lastdir == NULL)
+        lastdir = strrchr(raw_append_file, '>');
+      if (lastdir == NULL)
+        lastdir = strrchr(raw_append_file, ':');
+      if ((lastdot == NULL) || (lastdot > lastdir))
+        {
+          append_file = xmalloc (strlen (raw_append_file) + 1);
+          strcpy (append_file, raw_append_file);
+          strcat (append_file, ".");
+        }
+      else
+        append_file = strdup(raw_append_file);
+    }
+
+  cmd_dsc = build_vms_cmd (cmd_tokens, use_pipe_cmd, append_token);
+  if (cmd_dsc->dsc$a_pointer == NULL)
+    {
+      if (cmd_dsc->dsc$w_length < 0)
+        {
+          free (cmd_dsc);
+          child->cstatus = VMS_POSIX_EXIT_MASK | (MAKE_TROUBLE << 3);
+          child->vms_launch_status = SS$_ABORT;
+          /* TODO what is this "magic number" */
+          child->pid = 270163; /* Special built-in */
+          child->efn = 0;
+          return 0;
+        }
+
+      /* Only a built-in or a null command - Still need to run term AST */
+      free (cmd_dsc);
+      child->cstatus = VMS_POSIX_EXIT_MASK;
+      child->vms_launch_status = SS$_NORMAL;
+      /* TODO what is this "magic number" */
+      child->pid = 270163; /* Special built-in */
+      child->efn = 0;
+      vmsHandleChildTerm (child);
+      return 1;
+    }
+
+  if (cmd_dsc->dsc$w_length > MAX_DCL_LINE_LENGTH)
+    token.use_cmd_file = 1;
+
+  DB(DB_JOBS, (_("DCL: %s\n"), cmd_dsc->dsc$a_pointer));
+
+  /* Enforce the creation of a command file if "vms_always_use_cmd_file" is
+     non-zero.
+     Further, this way DCL reads the input stream and therefore does
+     'forced' symbol substitution, which it doesn't do for one-liners when
+     they are 'lib$spawn'ed.
+
+     Otherwise the behavior is:
+
+     Create a *.com file if either the command is too long for
+     lib$spawn, or if a redirect appending to a file is desired, or
+     symbol substitition.
+  */
+
+  if (vms_always_use_cmd_file || token.use_cmd_file)
+    {
+      FILE *outfile;
+      int cmd_len;
+
+      outfile = get_tmpfile (&child->comname,
+                             "sys$scratch:gnv$make_cmdXXXXXX.com");
+      /*                      123456789012345678901234567890 */
+      if (outfile == 0)
+        pfatal_with_name (_("fopen (temporary file)"));
+      comnamelen = strlen (child->comname);
+
+      /* The whole DCL "script" is executed as one action, and it behaves as
+         any DCL "script", that is errors stop it but warnings do not. Usually
+         the command on the last line, defines the exit code.  However, with
+         redirections there is a prolog and possibly an epilog to implement
+         the redirection.  Both are part of the script which is actually
+         executed. So if the redirection encounters an error in the prolog,
+         the user actions will not run; if in the epilog, the user actions
+         ran, but output is not captured. In both error cases, the error of
+         redirection is passed back and not the exit code of the actions. The
+         user should be able to enable DCL "script" verification with "set
+         verify". However, the prolog and epilog commands are not shown. Also,
+         if output redirection is used, the verification output is redirected
+         into that file as well. */
+      fprintf (outfile, "$ gnv$$make_verify = \"''f$verify(0)'\"\n");
+      fprintf (outfile, "$ gnv$$make_pid = f$getjpi(\"\",\"pid\")\n");
+      fprintf (outfile, "$ on error then $ goto gnv$$make_error\n");
+
+      /* Handle append redirection */
+      if (append_file != NULL)
+        {
+          /* If file does not exist, create it */
+          fprintf (outfile,
+                   "$ gnv$$make_al = \"gnv$$make_append''gnv$$make_pid'\"\n");
+          fprintf (outfile,
+                   "$ if f$search(\"%s\") .eqs. \"\" then create %s\n",
+                   append_file, append_file);
+
+          fprintf (outfile,
+                   "$ open/append 'gnv$$make_al' %s\n", append_file);
+
+          /* define sys$output to that file */
+          fprintf (outfile,
+                   "$ define/user sys$output 'gnv$$make_al'\n");
+          DB (DB_JOBS, (_("Append output to %s\n"), append_file));
+          free(append_file);
+        }
+
+      fprintf (outfile, "$ gnv$$make_verify = f$verify(gnv$$make_verify)\n");
+
+      /* TODO:
+         Only for ONESHELL there will be several commands separated by
+         '\n'. But there can always be multiple continuation lines.
+      */
+
+      fprintf (outfile, "%s\n", cmd_dsc->dsc$a_pointer);
+      fprintf (outfile, "$ gnv$$make_status_2 = $status\n");
+      fprintf (outfile, "$ goto gnv$$make_exit\n");
+
+      /* Exit and clean up */
+      fprintf (outfile, "$ gnv$$make_error: ! 'f$verify(0)\n");
+      fprintf (outfile, "$ gnv$$make_status_2 = $status\n");
+
+      if (append_token != -1)
+        {
+          fprintf (outfile, "$ deassign sys$output\n");
+          fprintf (outfile, "$ close 'gnv$$make_al'\n");
+
+          DB (DB_JOBS,
+              (_("Append %.*s and cleanup\n"), comnamelen-3, child->comname));
+        }
+      fprintf (outfile, "$ gnv$$make_exit: ! 'f$verify(0)\n");
+      fprintf (outfile,
+             "$ exit 'gnv$$make_status_2' + (0*f$verify(gnv$$make_verify))\n");
+
+      fclose (outfile);
+
+      free (cmd_dsc->dsc$a_pointer);
+      cmd_dsc->dsc$a_pointer = xmalloc (256 + 4);
+      sprintf (cmd_dsc->dsc$a_pointer, "$ @%s", child->comname);
+      cmd_dsc->dsc$w_length = strlen (cmd_dsc->dsc$a_pointer);
+
+      DB (DB_JOBS, (_("Executing %s instead\n"), child->comname));
+    }
+
+  child->efn = 0;
+  while (child->efn < 32 || child->efn > 63)
+    {
+      status = LIB$GET_EF ((unsigned long *)&child->efn);
+      if (!$VMS_STATUS_SUCCESS (status))
+        {
+          if (child->comname)
+            {
+              if (!ISDB (DB_JOBS))
+                unlink (child->comname);
+              free (child->comname);
+            }
+          return 0;
+        }
+    }
+
+  SYS$CLREF (child->efn);
+
+  vms_jobsefnmask |= (1 << (child->efn - 32));
+
+  /* Export the child environment into DCL symbols */
+  if (child->environment != 0)
+    {
+      char **ep = child->environment;
+      while (*ep != 0)
+        {
+          vms_putenv_symbol (*ep);
+          *ep++;
+        }
+    }
+
+  /*
+    LIB$SPAWN  [command-string]
+    [,input-file]
+    [,output-file]
+    [,flags]
+    [,process-name]
+    [,process-id] [,completion-status-address] [,byte-integer-event-flag-num]
+    [,AST-address] [,varying-AST-argument]
+    [,prompt-string] [,cli] [,table]
+  */
+
+#ifndef DONTWAITFORCHILD
+  /*
+   * Code to make ctrl+c and ctrl+y working.
+   * The problem starts with the synchronous case where after lib$spawn is
+   * called any input will go to the child. But with input re-directed,
+   * both control characters won't make it to any of the programs, neither
+   * the spawning nor to the spawned one. Hence the caller needs to spawn
+   * with CLI$M_NOWAIT to NOT give up the input focus. A sys$waitfr
+   * has to follow to simulate the wanted synchronous behaviour.
+   * The next problem is ctrl+y which isn't caught by the crtl and
+   * therefore isn't converted to SIGQUIT (for a signal handler which is
+   * already established). The only way to catch ctrl+y, is an AST
+   * assigned to the input channel. But ctrl+y handling of DCL needs to be
+   * disabled, otherwise it will handle it. Not to mention the previous
+   * ctrl+y handling of DCL needs to be re-established before make exits.
+   * One more: At the time of LIB$SPAWN signals are blocked. SIGQUIT will
+   * make it to the signal handler after the child "normally" terminates.
+   * This isn't enough. It seems reasonable for simple command lines like
+   * a 'cc foobar.c' spawned in a subprocess but it is unacceptable for
+   * spawning make. Therefore we need to abort the process in the AST.
+   *
+   * Prior to the spawn it is checked if an AST is already set up for
+   * ctrl+y, if not one is set up for a channel to SYS$COMMAND. In general
+   * this will work except if make is run in a batch environment, but there
+   * nobody can press ctrl+y. During the setup the DCL handling of ctrl+y
+   * is disabled and an exit handler is established to re-enable it.
+   * If the user interrupts with ctrl+y, the assigned AST will fire, force
+   * an abort to the subprocess and signal SIGQUIT, which will be caught by
+   * the already established handler and will bring us back to common code.
+   * After the spawn (now /nowait) a sys$waitfr simulates the /wait and
+   * enables the ctrl+y be delivered to this code. And the ctrl+c too,
+   * which the crtl converts to SIGINT and which is caught by the common
+   * signal handler. Because signals were blocked before entering this code
+   * sys$waitfr will always complete and the SIGQUIT will be processed after
+   * it (after termination of the current block, somewhere in common code).
+   * And SIGINT too will be delayed. That is ctrl+c can only abort when the
+   * current command completes. Anyway it's better than nothing :-)
+   */
+
+  if (!setupYAstTried)
+    tryToSetupYAst();
+  child->vms_launch_status = lib$spawn (cmd_dsc,               /* cmd-string */
+                     NULL, /* input-file */
+                     NULL, /* output-file */
+                     &spflags,                                 /* flags */
+                     &pnamedsc,                                /* proc name */
+                     &child->pid, &child->cstatus, &child->efn,
+                     0, 0,
+                     0, 0, 0);
+
+  status = child->vms_launch_status;
+  if ($VMS_STATUS_SUCCESS (status))
+    {
+      status = sys$waitfr (child->efn);
+      vmsHandleChildTerm (child);
+    }
+#else
+  child->vms_launch_status = lib$spawn (cmd_dsc,
+                      NULL,
+                      NULL,
+                      &spflags,
+                      &pnamedsc,
+                      &child->pid, &child->cstatus, &child->efn,
+                      vmsHandleChildTerm, child,
+                      0, 0, 0);
+   status = child->vms_launch_status;
+#endif
+
+  /* Free the pointer if not a command file */
+  if (!vms_always_use_cmd_file && !token.use_cmd_file)
+    free (cmd_dsc->dsc$a_pointer);
+  free (cmd_dsc);
+
+  if (!$VMS_STATUS_SUCCESS (status))
+    {
+      switch (status)
+        {
+        case SS$_EXQUOTA:
+          errno = EPROCLIM;
+          break;
+        default:
+          errno = EFAIL;
+        }
+    }
+
+  /* Restore the VMS symbols that were changed */
+  if (child->environment != 0)
+    {
+      char **ep = child->environment;
+      while (*ep != 0)
+        {
+          vms_restore_symbol (*ep);
+          *ep++;
+        }
+    }
+
+  return (status & 1);
+}
diff --git a/src/vpath.c b/src/vpath.c
new file mode 100644
index 0000000..1649664
--- /dev/null
+++ b/src/vpath.c
@@ -0,0 +1,637 @@
+/* Implementation of pattern-matching file search paths for GNU Make.
+Copyright (C) 1988-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+#include "filedef.h"
+#include "variable.h"
+#ifdef WINDOWS32
+#include "pathstuff.h"
+#endif
+
+
+/* Structure used to represent a selective VPATH searchpath.  */
+
+struct vpath
+  {
+    struct vpath *next; /* Pointer to next struct in the linked list.  */
+    const char *pattern;/* The pattern to match.  */
+    const char *percent;/* Pointer into 'pattern' where the '%' is.  */
+    unsigned int patlen;/* Length of the pattern.  */
+    const char **searchpath; /* Null-terminated list of directories.  */
+    unsigned int maxlen;/* Maximum length of any entry in the list.  */
+  };
+
+/* Linked-list of all selective VPATHs.  */
+
+static struct vpath *vpaths;
+
+/* Structure for the general VPATH given in the variable.  */
+
+static struct vpath *general_vpath;
+
+/* Structure for GPATH given in the variable.  */
+
+static struct vpath *gpaths;
+
+
+/* Reverse the chain of selective VPATH lists so they will be searched in the
+   order given in the makefiles and construct the list from the VPATH
+   variable.  */
+
+void
+build_vpath_lists (void)
+{
+  struct vpath *new = 0;
+  struct vpath *old, *nexto;
+  char *p;
+
+  /* Reverse the chain.  */
+  for (old = vpaths; old != 0; old = nexto)
+    {
+      nexto = old->next;
+      old->next = new;
+      new = old;
+    }
+
+  vpaths = new;
+
+  /* If there is a VPATH variable with a nonnull value, construct the
+     general VPATH list from it.  We use variable_expand rather than just
+     calling lookup_variable so that it will be recursively expanded.  */
+
+  {
+    /* Turn off --warn-undefined-variables while we expand SHELL and IFS.  */
+    int save = warn_undefined_variables_flag;
+    warn_undefined_variables_flag = 0;
+
+    p = variable_expand ("$(strip $(VPATH))");
+
+    warn_undefined_variables_flag = save;
+  }
+
+  if (*p != '\0')
+    {
+      /* Save the list of vpaths.  */
+      struct vpath *save_vpaths = vpaths;
+      char gp[] = "%";
+
+      /* Empty 'vpaths' so the new one will have no next, and 'vpaths'
+         will still be nil if P contains no existing directories.  */
+      vpaths = 0;
+
+      /* Parse P.  */
+      construct_vpath_list (gp, p);
+
+      /* Store the created path as the general path,
+         and restore the old list of vpaths.  */
+      general_vpath = vpaths;
+      vpaths = save_vpaths;
+    }
+
+  /* If there is a GPATH variable with a nonnull value, construct the
+     GPATH list from it.  We use variable_expand rather than just
+     calling lookup_variable so that it will be recursively expanded.  */
+
+  {
+    /* Turn off --warn-undefined-variables while we expand SHELL and IFS.  */
+    int save = warn_undefined_variables_flag;
+    warn_undefined_variables_flag = 0;
+
+    p = variable_expand ("$(strip $(GPATH))");
+
+    warn_undefined_variables_flag = save;
+  }
+
+  if (*p != '\0')
+    {
+      /* Save the list of vpaths.  */
+      struct vpath *save_vpaths = vpaths;
+      char gp[] = "%";
+
+      /* Empty 'vpaths' so the new one will have no next, and 'vpaths'
+         will still be nil if P contains no existing directories.  */
+      vpaths = 0;
+
+      /* Parse P.  */
+      construct_vpath_list (gp, p);
+
+      /* Store the created path as the GPATH,
+         and restore the old list of vpaths.  */
+      gpaths = vpaths;
+      vpaths = save_vpaths;
+    }
+}
+
+/* Construct the VPATH listing for the PATTERN and DIRPATH given.
+
+   This function is called to generate selective VPATH lists and also for
+   the general VPATH list (which is in fact just a selective VPATH that
+   is applied to everything).  The returned pointer is either put in the
+   linked list of all selective VPATH lists or in the GENERAL_VPATH
+   variable.
+
+   If DIRPATH is nil, remove all previous listings with the same
+   pattern.  If PATTERN is nil, remove all VPATH listings.  Existing
+   and readable directories that are not "." given in the DIRPATH
+   separated by the path element separator (defined in makeint.h) are
+   loaded into the directory hash table if they are not there already
+   and put in the VPATH searchpath for the given pattern with trailing
+   slashes stripped off if present (and if the directory is not the
+   root, "/").  The length of the longest entry in the list is put in
+   the structure as well.  The new entry will be at the head of the
+   VPATHS chain.  */
+
+void
+construct_vpath_list (char *pattern, char *dirpath)
+{
+  unsigned int elem;
+  char *p;
+  const char **vpath;
+  unsigned int maxvpath;
+  unsigned int maxelem;
+  const char *percent = NULL;
+
+  if (pattern != 0)
+    percent = find_percent (pattern);
+
+  if (dirpath == 0)
+    {
+      /* Remove matching listings.  */
+      struct vpath *path, *lastpath;
+
+      lastpath = 0;
+      path = vpaths;
+      while (path != 0)
+        {
+          struct vpath *next = path->next;
+
+          if (pattern == 0
+              || (((percent == 0 && path->percent == 0)
+                   || (percent - pattern == path->percent - path->pattern))
+                  && streq (pattern, path->pattern)))
+            {
+              /* Remove it from the linked list.  */
+              if (lastpath == 0)
+                vpaths = path->next;
+              else
+                lastpath->next = next;
+
+              /* Free its unused storage.  */
+              /* MSVC erroneously warns without a cast here.  */
+              free ((void *)path->searchpath);
+              free (path);
+            }
+          else
+            lastpath = path;
+
+          path = next;
+        }
+
+      return;
+    }
+
+#ifdef WINDOWS32
+    convert_vpath_to_windows32 (dirpath, ';');
+#endif
+
+  /* Skip over any initial separators and blanks.  */
+  while (STOP_SET (*dirpath, MAP_BLANK|MAP_PATHSEP))
+    ++dirpath;
+
+  /* Figure out the maximum number of VPATH entries and put it in
+     MAXELEM.  We start with 2, one before the first separator and one
+     nil (the list terminator) and increment our estimated number for
+     each separator or blank we find.  */
+  maxelem = 2;
+  p = dirpath;
+  while (*p != '\0')
+    if (STOP_SET (*p++, MAP_BLANK|MAP_PATHSEP))
+      ++maxelem;
+
+  vpath = xmalloc (maxelem * sizeof (const char *));
+  maxvpath = 0;
+
+  elem = 0;
+  p = dirpath;
+  while (*p != '\0')
+    {
+      char *v;
+      unsigned int len;
+
+      /* Find the end of this entry.  */
+      v = p;
+      while (*p != '\0'
+#if defined(HAVE_DOS_PATHS) && (PATH_SEPARATOR_CHAR == ':')
+             /* Platforms whose PATH_SEPARATOR_CHAR is ':' and which
+                also define HAVE_DOS_PATHS would like us to recognize
+                colons after the drive letter in the likes of
+                "D:/foo/bar:C:/xyzzy".  */
+             && (*p != PATH_SEPARATOR_CHAR
+                 || (p == v + 1 && (p[1] == '/' || p[1] == '\\')))
+#else
+             && *p != PATH_SEPARATOR_CHAR
+#endif
+             && !ISBLANK (*p))
+        ++p;
+
+      len = p - v;
+      /* Make sure there's no trailing slash,
+         but still allow "/" as a directory.  */
+#if defined(__MSDOS__) || defined(__EMX__) || defined(HAVE_DOS_PATHS)
+      /* We need also to leave alone a trailing slash in "d:/".  */
+      if (len > 3 || (len > 1 && v[1] != ':'))
+#endif
+      if (len > 1 && p[-1] == '/')
+        --len;
+
+      /* Put the directory on the vpath list.  */
+      if (len > 1 || *v != '.')
+        {
+          vpath[elem++] = dir_name (strcache_add_len (v, len));
+          if (len > maxvpath)
+            maxvpath = len;
+        }
+
+      /* Skip over separators and blanks between entries.  */
+      while (STOP_SET (*p, MAP_BLANK|MAP_PATHSEP))
+        ++p;
+    }
+
+  if (elem > 0)
+    {
+      struct vpath *path;
+      /* ELEM is now incremented one element past the last
+         entry, to where the nil-pointer terminator goes.
+         Usually this is maxelem - 1.  If not, shrink down.  */
+      if (elem < (maxelem - 1))
+        vpath = xrealloc (vpath, (elem+1) * sizeof (const char *));
+
+      /* Put the nil-pointer terminator on the end of the VPATH list.  */
+      vpath[elem] = NULL;
+
+      /* Construct the vpath structure and put it into the linked list.  */
+      path = xmalloc (sizeof (struct vpath));
+      path->searchpath = vpath;
+      path->maxlen = maxvpath;
+      path->next = vpaths;
+      vpaths = path;
+
+      /* Set up the members.  */
+      path->pattern = strcache_add (pattern);
+      path->patlen = strlen (pattern);
+      path->percent = percent ? path->pattern + (percent - pattern) : 0;
+    }
+  else
+    /* There were no entries, so free whatever space we allocated.  */
+    /* MSVC erroneously warns without a cast here.  */
+    free ((void *)vpath);
+}
+
+/* Search the GPATH list for a pathname string that matches the one passed
+   in.  If it is found, return 1.  Otherwise we return 0.  */
+
+int
+gpath_search (const char *file, unsigned int len)
+{
+  if (gpaths && (len <= gpaths->maxlen))
+    {
+      const char **gp;
+      for (gp = gpaths->searchpath; *gp != NULL; ++gp)
+        if (strneq (*gp, file, len) && (*gp)[len] == '\0')
+          return 1;
+    }
+
+  return 0;
+}
+
+
+/* Search the given VPATH list for a directory where the name pointed to by
+   FILE exists.  If it is found, we return a cached name of the existing file
+   and set *MTIME_PTR (if MTIME_PTR is not NULL) to its modtime (or zero if no
+   stat call was done). Also set the matching directory index in PATH_INDEX
+   if it is not NULL. Otherwise we return NULL.  */
+
+static const char *
+selective_vpath_search (struct vpath *path, const char *file,
+                        FILE_TIMESTAMP *mtime_ptr, unsigned int* path_index)
+{
+  int not_target;
+  char *name;
+  const char *n;
+  const char *filename;
+  const char **vpath = path->searchpath;
+  unsigned int maxvpath = path->maxlen;
+  unsigned int i;
+  unsigned int flen, name_dplen;
+  int exists = 0;
+
+  /* Find out if *FILE is a target.
+     If and only if it is NOT a target, we will accept prospective
+     files that don't exist but are mentioned in a makefile.  */
+  {
+    struct file *f = lookup_file (file);
+    not_target = f == 0 || !f->is_target;
+  }
+
+  flen = strlen (file);
+
+  /* Split *FILE into a directory prefix and a name-within-directory.
+     NAME_DPLEN gets the length of the prefix; FILENAME gets the pointer to
+     the name-within-directory and FLEN is its length.  */
+
+  n = strrchr (file, '/');
+#ifdef HAVE_DOS_PATHS
+  /* We need the rightmost slash or backslash.  */
+  {
+    const char *bslash = strrchr (file, '\\');
+    if (!n || bslash > n)
+      n = bslash;
+  }
+#endif
+  name_dplen = n != 0 ? n - file : 0;
+  filename = name_dplen > 0 ? n + 1 : file;
+  if (name_dplen > 0)
+    flen -= name_dplen + 1;
+
+  /* Get enough space for the biggest VPATH entry, a slash, the directory
+     prefix that came with FILE, another slash (although this one may not
+     always be necessary), the filename, and a null terminator.  */
+  name = alloca (maxvpath + 1 + name_dplen + 1 + flen + 1);
+
+  /* Try each VPATH entry.  */
+  for (i = 0; vpath[i] != 0; ++i)
+    {
+      int exists_in_cache = 0;
+      char *p = name;
+      unsigned int vlen = strlen (vpath[i]);
+
+      /* Put the next VPATH entry into NAME at P and increment P past it.  */
+      memcpy (p, vpath[i], vlen);
+      p += vlen;
+
+      /* Add the directory prefix already in *FILE.  */
+      if (name_dplen > 0)
+        {
+#ifndef VMS
+          *p++ = '/';
+#else
+          /* VMS: if this is not in VMS format, treat as Unix format */
+          if ((*p != ':') && (*p != ']') && (*p != '>'))
+            *p++ = '/';
+#endif
+          memcpy (p, file, name_dplen);
+          p += name_dplen;
+        }
+
+#ifdef HAVE_DOS_PATHS
+      /* Cause the next if to treat backslash and slash alike.  */
+      if (p != name && p[-1] == '\\' )
+        p[-1] = '/';
+#endif
+      /* Now add the name-within-directory at the end of NAME.  */
+#ifndef VMS
+      if (p != name && p[-1] != '/')
+        {
+          *p = '/';
+          memcpy (p + 1, filename, flen + 1);
+        }
+      else
+#else
+      /* VMS use a slash if no directory terminator present */
+      if (p != name && p[-1] != '/' && p[-1] != ':' &&
+          p[-1] != '>' && p[-1] != ']')
+        {
+          *p = '/';
+          memcpy (p + 1, filename, flen + 1);
+        }
+      else
+#endif
+        memcpy (p, filename, flen + 1);
+
+      /* Check if the file is mentioned in a makefile.  If *FILE is not
+         a target, that is enough for us to decide this file exists.
+         If *FILE is a target, then the file must be mentioned in the
+         makefile also as a target to be chosen.
+
+         The restriction that *FILE must not be a target for a
+         makefile-mentioned file to be chosen was added by an
+         inadequately commented change in July 1990; I am not sure off
+         hand what problem it fixes.
+
+         In December 1993 I loosened this restriction to allow a file
+         to be chosen if it is mentioned as a target in a makefile.  This
+         seem logical.
+
+         Special handling for -W / -o: make sure we preserve the special
+         values here.  Actually this whole thing is a little bogus: I think
+         we should ditch the name/hname thing and look into the renamed
+         capability that already exists for files: that is, have a new struct
+         file* entry for the VPATH-found file, and set the renamed field if
+         we use it.
+      */
+      {
+        struct file *f = lookup_file (name);
+        if (f != 0)
+          {
+            exists = not_target || f->is_target;
+            if (exists && mtime_ptr
+                && (f->last_mtime == OLD_MTIME || f->last_mtime == NEW_MTIME))
+              {
+                *mtime_ptr = f->last_mtime;
+                mtime_ptr = 0;
+              }
+          }
+      }
+
+      if (!exists)
+        {
+          /* That file wasn't mentioned in the makefile.
+             See if it actually exists.  */
+
+#ifdef VMS
+          /* For VMS syntax just use the original vpath */
+          if (*p != '/')
+            exists_in_cache = exists = dir_file_exists_p (vpath[i], filename);
+          else
+#endif
+            {
+              /* Clobber a null into the name at the last slash.
+                 Now NAME is the name of the directory to look in.  */
+              *p = '\0';
+              /* We know the directory is in the hash table now because either
+                 construct_vpath_list or the code just above put it there.
+                 Does the file we seek exist in it?  */
+              exists_in_cache = exists = dir_file_exists_p (name, filename);
+            }
+        }
+
+      if (exists)
+        {
+          /* The file is in the directory cache.
+             Now check that it actually exists in the filesystem.
+             The cache may be out of date.  When vpath thinks a file
+             exists, but stat fails for it, confusion results in the
+             higher levels.  */
+
+          struct stat st;
+
+#ifndef VMS
+          /* Put the slash back in NAME.  */
+          *p = '/';
+#else
+          /* If the slash was removed, put it back */
+          if (*p == 0)
+            *p = '/';
+#endif
+
+          if (exists_in_cache)  /* Makefile-mentioned file need not exist.  */
+            {
+              int e;
+
+              EINTRLOOP (e, stat (name, &st)); /* Does it really exist?  */
+              if (e != 0)
+                {
+                  exists = 0;
+                  continue;
+                }
+
+              /* Store the modtime into *MTIME_PTR for the caller.  */
+              if (mtime_ptr != 0)
+                {
+                  *mtime_ptr = FILE_TIMESTAMP_STAT_MODTIME (name, st);
+                  mtime_ptr = 0;
+                }
+            }
+
+          /* We have found a file.
+             If we get here and mtime_ptr hasn't been set, record
+             UNKNOWN_MTIME to indicate this.  */
+          if (mtime_ptr != 0)
+            *mtime_ptr = UNKNOWN_MTIME;
+
+          /* Store the name we found and return it.  */
+
+          if (path_index)
+            *path_index = i;
+
+          return strcache_add_len (name, (p + 1 - name) + flen);
+        }
+    }
+
+  return 0;
+}
+
+
+/* Search the VPATH list whose pattern matches FILE for a directory where FILE
+   exists.  If it is found, return the cached name of an existing file, and
+   set *MTIME_PTR (if MTIME_PTR is not NULL) to its modtime (or zero if no
+   stat call was done). Also set the matching directory index in VPATH_INDEX
+   and PATH_INDEX if they are not NULL.  Otherwise we return 0.  */
+
+const char *
+vpath_search (const char *file, FILE_TIMESTAMP *mtime_ptr,
+              unsigned int* vpath_index, unsigned int* path_index)
+{
+  struct vpath *v;
+
+  /* If there are no VPATH entries or FILENAME starts at the root,
+     there is nothing we can do.  */
+
+  if (file[0] == '/'
+#ifdef HAVE_DOS_PATHS
+      || file[0] == '\\' || file[1] == ':'
+#endif
+      || (vpaths == 0 && general_vpath == 0))
+    return 0;
+
+  if (vpath_index)
+    {
+      *vpath_index = 0;
+      *path_index = 0;
+    }
+
+  for (v = vpaths; v != 0; v = v->next)
+    {
+      if (pattern_matches (v->pattern, v->percent, file))
+        {
+          const char *p = selective_vpath_search (
+            v, file, mtime_ptr, path_index);
+          if (p)
+            return p;
+        }
+
+      if (vpath_index)
+        ++*vpath_index;
+    }
+
+
+  if (general_vpath != 0)
+    {
+      const char *p = selective_vpath_search (
+        general_vpath, file, mtime_ptr, path_index);
+      if (p)
+        return p;
+    }
+
+  return 0;
+}
+
+
+
+
+/* Print the data base of VPATH search paths.  */
+
+void
+print_vpath_data_base (void)
+{
+  unsigned int nvpaths;
+  struct vpath *v;
+
+  puts (_("\n# VPATH Search Paths\n"));
+
+  nvpaths = 0;
+  for (v = vpaths; v != 0; v = v->next)
+    {
+      unsigned int i;
+
+      ++nvpaths;
+
+      printf ("vpath %s ", v->pattern);
+
+      for (i = 0; v->searchpath[i] != 0; ++i)
+        printf ("%s%c", v->searchpath[i],
+                v->searchpath[i + 1] == 0 ? '\n' : PATH_SEPARATOR_CHAR);
+    }
+
+  if (vpaths == 0)
+    puts (_("# No 'vpath' search paths."));
+  else
+    printf (_("\n# %u 'vpath' search paths.\n"), nvpaths);
+
+  if (general_vpath == 0)
+    puts (_("\n# No general ('VPATH' variable) search path."));
+  else
+    {
+      const char **path = general_vpath->searchpath;
+      unsigned int i;
+
+      fputs (_("\n# General ('VPATH' variable) search path:\n# "), stdout);
+
+      for (i = 0; path[i] != 0; ++i)
+        printf ("%s%c", path[i],
+                path[i + 1] == 0 ? '\n' : PATH_SEPARATOR_CHAR);
+    }
+}
diff --git a/src/w32/compat/dirent.c b/src/w32/compat/dirent.c
new file mode 100644
index 0000000..8c9fd48
--- /dev/null
+++ b/src/w32/compat/dirent.c
@@ -0,0 +1,188 @@
+/* Directory entry code for Window platforms.
+Copyright (C) 1996-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+
+#include <config.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <string.h>
+#include <stdlib.h>
+#include "dirent.h"
+
+
+DIR*
+opendir(const char* pDirName)
+{
+        struct stat sb;
+        DIR*    pDir;
+        char*   pEndDirName;
+        int     nBufferLen;
+
+        /* sanity checks */
+        if (!pDirName) {
+                errno = EINVAL;
+                return NULL;
+        }
+        if (stat(pDirName, &sb) != 0) {
+                errno = ENOENT;
+                return NULL;
+        }
+        if ((sb.st_mode & S_IFMT) != S_IFDIR) {
+                errno = ENOTDIR;
+                return NULL;
+        }
+
+        /* allocate a DIR structure to return */
+        pDir = (DIR *) malloc(sizeof (DIR));
+
+        if (!pDir)
+                return NULL;
+
+        /* input directory name length */
+        nBufferLen = strlen(pDirName);
+
+        /* copy input directory name to DIR buffer */
+        strcpy(pDir->dir_pDirectoryName, pDirName);
+
+        /* point to end of the copied directory name */
+        pEndDirName = &pDir->dir_pDirectoryName[nBufferLen - 1];
+
+        /* if directory name did not end in '/' or '\', add '/' */
+        if ((*pEndDirName != '/') && (*pEndDirName != '\\')) {
+                pEndDirName++;
+                *pEndDirName = '/';
+        }
+
+        /* now append the wildcard character to the buffer */
+        pEndDirName++;
+        *pEndDirName = '*';
+        pEndDirName++;
+        *pEndDirName = '\0';
+
+        /* other values defaulted */
+        pDir->dir_nNumFiles = 0;
+        pDir->dir_hDirHandle = INVALID_HANDLE_VALUE;
+        pDir->dir_ulCookie = __DIRENT_COOKIE;
+
+        return pDir;
+}
+
+void
+closedir(DIR *pDir)
+{
+        /* got a valid pointer? */
+        if (!pDir) {
+                errno = EINVAL;
+                return;
+        }
+
+        /* sanity check that this is a DIR pointer */
+        if (pDir->dir_ulCookie != __DIRENT_COOKIE) {
+                errno = EINVAL;
+                return;
+        }
+
+        /* close the WINDOWS32 directory handle */
+        if (pDir->dir_hDirHandle != INVALID_HANDLE_VALUE)
+                FindClose(pDir->dir_hDirHandle);
+
+        free(pDir);
+
+        return;
+}
+
+struct dirent *
+readdir(DIR* pDir)
+{
+        WIN32_FIND_DATA wfdFindData;
+
+        if (!pDir) {
+                errno = EINVAL;
+                return NULL;
+        }
+
+        /* sanity check that this is a DIR pointer */
+        if (pDir->dir_ulCookie != __DIRENT_COOKIE) {
+                errno = EINVAL;
+                return NULL;
+        }
+
+        if (pDir->dir_nNumFiles == 0) {
+                pDir->dir_hDirHandle = FindFirstFile(pDir->dir_pDirectoryName, &wfdFindData);
+                if (pDir->dir_hDirHandle == INVALID_HANDLE_VALUE)
+                        return NULL;
+        } else if (!FindNextFile(pDir->dir_hDirHandle, &wfdFindData))
+                        return NULL;
+
+        /* bump count for next call to readdir() */
+        pDir->dir_nNumFiles++;
+
+        /* fill in struct dirent values */
+        pDir->dir_sdReturn.d_ino = (ino_t)-1;
+        strcpy(pDir->dir_sdReturn.d_name, wfdFindData.cFileName);
+
+        return &pDir->dir_sdReturn;
+}
+
+void
+rewinddir(DIR* pDir)
+{
+        if (!pDir) {
+                errno = EINVAL;
+                return;
+        }
+
+        /* sanity check that this is a DIR pointer */
+        if (pDir->dir_ulCookie != __DIRENT_COOKIE) {
+                errno = EINVAL;
+                return;
+        }
+
+        /* close the WINDOWS32 directory handle */
+        if (pDir->dir_hDirHandle != INVALID_HANDLE_VALUE)
+                if (!FindClose(pDir->dir_hDirHandle))
+                        errno = EBADF;
+
+        /* reset members which control readdir() */
+        pDir->dir_hDirHandle = INVALID_HANDLE_VALUE;
+        pDir->dir_nNumFiles = 0;
+
+        return;
+}
+
+void
+seekdir(DIR* pDir, long nPosition)
+{
+        if (!pDir)
+                return;
+
+        /* sanity check that this is a DIR pointer */
+        if (pDir->dir_ulCookie != __DIRENT_COOKIE)
+                return;
+
+        /* go back to beginning of directory */
+        rewinddir(pDir);
+
+        /* loop until we have found position we care about */
+        for (--nPosition; nPosition && readdir(pDir); nPosition--);
+
+        /* flag invalid nPosition value */
+        if (nPosition)
+                errno = EINVAL;
+
+        return;
+}
diff --git a/src/w32/compat/posixfcn.c b/src/w32/compat/posixfcn.c
new file mode 100644
index 0000000..7b9a577
--- /dev/null
+++ b/src/w32/compat/posixfcn.c
@@ -0,0 +1,486 @@
+/* Replacements for Posix functions and Posix functionality for MS-Windows.
+
+Copyright (C) 2013-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <string.h>
+#include <io.h>
+#include <stdarg.h>
+#include <errno.h>
+#include <windows.h>
+
+#include "dlfcn.h"
+
+#include "makeint.h"
+#include "job.h"
+
+#ifndef NO_OUTPUT_SYNC
+/* Support for OUTPUT_SYNC and related functionality.  */
+
+/* Emulation of fcntl that supports only F_GETFD and F_SETLKW.  */
+int
+fcntl (intptr_t fd, int cmd, ...)
+{
+  va_list ap;
+
+  va_start (ap, cmd);
+
+  switch (cmd)
+    {
+      case F_GETFD:
+        va_end (ap);
+        /* Could have used GetHandleInformation, but that isn't
+           supported on Windows 9X.  */
+        if (_get_osfhandle (fd) == -1)
+          return -1;
+        return 0;
+      case F_SETLKW:
+        {
+          void *buf = va_arg (ap, void *);
+          struct flock *fl = (struct flock *)buf;
+          HANDLE hmutex = (HANDLE)fd;
+          static struct flock last_fl;
+          short last_type = last_fl.l_type;
+
+          va_end (ap);
+
+          if (hmutex == INVALID_HANDLE_VALUE || !hmutex)
+            return -1;
+
+          last_fl = *fl;
+
+          switch (fl->l_type)
+            {
+
+              case F_WRLCK:
+                {
+                  DWORD result;
+
+                  if (last_type == F_WRLCK)
+                    {
+                      /* Don't call WaitForSingleObject if we already
+                         own the mutex, because doing so will require
+                         us to call ReleaseMutex an equal number of
+                         times, before the mutex is actually
+                         released.  */
+                      return 0;
+                    }
+
+                  result = WaitForSingleObject (hmutex, INFINITE);
+                  switch (result)
+                    {
+                      case WAIT_OBJECT_0:
+                        /* We don't care if the mutex owner crashed or
+                           exited.  */
+                      case WAIT_ABANDONED:
+                        return 0;
+                      case WAIT_FAILED:
+                      case WAIT_TIMEOUT: /* cannot happen, really */
+                        {
+                          DWORD err = GetLastError ();
+
+                          /* Invalidate the last command.  */
+                          memset (&last_fl, 0, sizeof (last_fl));
+
+                          switch (err)
+                            {
+                              case ERROR_INVALID_HANDLE:
+                              case ERROR_INVALID_FUNCTION:
+                                errno = EINVAL;
+                                return -1;
+                              default:
+                                errno = EDEADLOCK;
+                                return -1;
+                            }
+                        }
+                    }
+                }
+              case F_UNLCK:
+                {
+                  /* FIXME: Perhaps we should call ReleaseMutex
+                     repatedly until it errors out, to make sure the
+                     mutext is released even if we somehow managed to
+                     to take ownership multiple times?  */
+                  BOOL status = ReleaseMutex (hmutex);
+
+                  if (status)
+                    return 0;
+                  else
+                    {
+                      DWORD err = GetLastError ();
+
+                      if (err == ERROR_NOT_OWNER)
+                        errno = EPERM;
+                      else
+                        {
+                          memset (&last_fl, 0, sizeof (last_fl));
+                          errno = EINVAL;
+                        }
+                      return -1;
+                    }
+                }
+              default:
+                errno = ENOSYS;
+                return -1;
+            }
+        }
+      default:
+        errno = ENOSYS;
+        va_end (ap);
+        return -1;
+    }
+}
+
+static intptr_t mutex_handle = -1;
+
+/* Record in a static variable the mutex handle we were requested to
+   use.  That nameless mutex was created by the top-level Make, and
+   its handle was passed to us via inheritance.  The value of that
+   handle is passed via the command-line arguments, so that we know
+   which handle to use.  */
+void
+record_sync_mutex (const char *str)
+{
+  char *endp;
+  intptr_t hmutex = strtol (str, &endp, 16);
+
+  if (*endp == '\0')
+    mutex_handle = hmutex;
+  else
+    {
+      mutex_handle = -1;
+      errno = EINVAL;
+    }
+}
+
+/* Create a new mutex or reuse one created by our parent.  */
+intptr_t
+create_mutex (void)
+{
+  SECURITY_ATTRIBUTES secattr;
+  intptr_t hmutex = -1;
+
+  /* If we have a mutex handle passed from the parent Make, just use
+     that.  */
+  if (mutex_handle > 0)
+    return mutex_handle;
+
+  /* We are the top-level Make, and we want the handle to be inherited
+     by our child processes.  */
+  secattr.nLength = sizeof (secattr);
+  secattr.lpSecurityDescriptor = NULL; /* use default security descriptor */
+  secattr.bInheritHandle = TRUE;
+
+  hmutex = (intptr_t)CreateMutex (&secattr, FALSE, NULL);
+  if (!hmutex)
+    {
+      DWORD err = GetLastError ();
+
+      fprintf (stderr, "CreateMutex: error %lu\n", err);
+      errno = ENOLCK;
+      hmutex = -1;
+    }
+
+  mutex_handle = hmutex;
+  return hmutex;
+}
+
+/* Return non-zero if F1 and F2 are 2 streams representing the same
+   file or pipe or device.  */
+int
+same_stream (FILE *f1, FILE *f2)
+{
+  HANDLE fh1 = (HANDLE)_get_osfhandle (fileno (f1));
+  HANDLE fh2 = (HANDLE)_get_osfhandle (fileno (f2));
+
+  /* Invalid file descriptors get treated as different streams.  */
+  if (fh1 && fh1 != INVALID_HANDLE_VALUE
+      && fh2 && fh2 != INVALID_HANDLE_VALUE)
+    {
+      if (fh1 == fh2)
+        return 1;
+      else
+        {
+          DWORD ftyp1 = GetFileType (fh1), ftyp2 = GetFileType (fh2);
+
+          if (ftyp1 != ftyp2
+              || ftyp1 == FILE_TYPE_UNKNOWN || ftyp2 == FILE_TYPE_UNKNOWN)
+            return 0;
+          else if (ftyp1 == FILE_TYPE_CHAR)
+            {
+              /* For character devices, check if they both refer to a
+                 console.  This loses if both handles refer to the
+                 null device (FIXME!), but in that case we don't care
+                 in the context of Make.  */
+              DWORD conmode1, conmode2;
+
+              /* Each process on Windows can have at most 1 console,
+                 so if both handles are for the console device, they
+                 are the same.  We also compare the console mode to
+                 distinguish between stdin and stdout/stderr.  */
+              if (GetConsoleMode (fh1, &conmode1)
+                  && GetConsoleMode (fh2, &conmode2)
+                  && conmode1 == conmode2)
+                return 1;
+            }
+          else
+            {
+              /* For disk files and pipes, compare their unique
+                 attributes.  */
+              BY_HANDLE_FILE_INFORMATION bhfi1, bhfi2;
+
+              /* Pipes get zero in the volume serial number, but do
+                 appear to have meaningful information in file index
+                 attributes.  We test file attributes as well, for a
+                 good measure.  */
+              if (GetFileInformationByHandle (fh1, &bhfi1)
+                  && GetFileInformationByHandle (fh2, &bhfi2))
+                return (bhfi1.dwVolumeSerialNumber == bhfi2.dwVolumeSerialNumber
+                        && bhfi1.nFileIndexLow == bhfi2.nFileIndexLow
+                        && bhfi1.nFileIndexHigh == bhfi2.nFileIndexHigh
+                        && bhfi1.dwFileAttributes == bhfi2.dwFileAttributes);
+            }
+        }
+    }
+  return 0;
+}
+
+/* A replacement for tmpfile, since the MSVCRT implementation creates
+   the file in the root directory of the current drive, which might
+   not be writable by our user.  Most of the code borrowed from
+   create_batch_file, see job.c.  */
+FILE *
+tmpfile (void)
+{
+  char temp_path[MAXPATHLEN];
+  unsigned path_size = GetTempPath (sizeof temp_path, temp_path);
+  int path_is_dot = 0;
+  /* The following variable is static so we won't try to reuse a name
+     that was generated a little while ago, because that file might
+     not be on disk yet, since we use FILE_ATTRIBUTE_TEMPORARY below,
+     which tells the OS it doesn't need to flush the cache to disk.
+     If the file is not yet on disk, we might think the name is
+     available, while it really isn't.  This happens in parallel
+     builds, where Make doesn't wait for one job to finish before it
+     launches the next one.  */
+  static unsigned uniq = 0;
+  static int second_loop = 0;
+  const char base[] = "gmake_tmpf";
+  const unsigned sizemax = sizeof base - 1 + 4 + 10 + 10;
+  unsigned pid = GetCurrentProcessId ();
+
+  if (path_size == 0)
+    {
+      path_size = GetCurrentDirectory (sizeof temp_path, temp_path);
+      path_is_dot = 1;
+    }
+
+  ++uniq;
+  if (uniq >= 0x10000 && !second_loop)
+    {
+      /* If we already had 64K batch files in this
+         process, make a second loop through the numbers,
+         looking for free slots, i.e. files that were
+         deleted in the meantime.  */
+      second_loop = 1;
+      uniq = 1;
+    }
+  while (path_size > 0 &&
+         path_size + sizemax < sizeof temp_path &&
+         !(uniq >= 0x10000 && second_loop))
+    {
+      HANDLE h;
+
+      sprintf (temp_path + path_size,
+               "%s%s%u-%x.tmp",
+               temp_path[path_size - 1] == '\\' ? "" : "\\",
+               base, pid, uniq);
+      h = CreateFile (temp_path,  /* file name */
+                      GENERIC_READ | GENERIC_WRITE | DELETE, /* desired access */
+                      FILE_SHARE_READ | FILE_SHARE_WRITE,    /* share mode */
+                      NULL,                                  /* default security attributes */
+                      CREATE_NEW,                            /* creation disposition */
+                      FILE_ATTRIBUTE_NORMAL |                /* flags and attributes */
+                      FILE_ATTRIBUTE_TEMPORARY |
+                      FILE_FLAG_DELETE_ON_CLOSE,
+                      NULL);                                 /* no template file */
+
+      if (h == INVALID_HANDLE_VALUE)
+        {
+          const DWORD er = GetLastError ();
+
+          if (er == ERROR_FILE_EXISTS || er == ERROR_ALREADY_EXISTS)
+            {
+              ++uniq;
+              if (uniq == 0x10000 && !second_loop)
+                {
+                  second_loop = 1;
+                  uniq = 1;
+                }
+            }
+
+          /* The temporary path is not guaranteed to exist, or might
+             not be writable by user.  Use the current directory as
+             fallback.  */
+          else if (path_is_dot == 0)
+            {
+              path_size = GetCurrentDirectory (sizeof temp_path, temp_path);
+              path_is_dot = 1;
+            }
+
+          else
+            {
+              errno = EACCES;
+              break;
+            }
+        }
+      else
+        {
+          int fd = _open_osfhandle ((intptr_t)h, 0);
+
+          return _fdopen (fd, "w+b");
+        }
+    }
+
+  if (uniq >= 0x10000)
+    errno = EEXIST;
+  return NULL;
+}
+
+#endif  /* !NO_OUTPUT_SYNC */
+
+#if MAKE_LOAD
+
+/* Support for dynamic loading of objects.  */
+
+
+static DWORD last_err;
+
+void *
+dlopen (const char *file, int mode)
+{
+  char dllfn[MAX_PATH], *p;
+  HANDLE dllhandle;
+
+  if ((mode & ~(RTLD_LAZY | RTLD_NOW | RTLD_GLOBAL)) != 0)
+    {
+      errno = EINVAL;
+      last_err = ERROR_INVALID_PARAMETER;
+      return NULL;
+    }
+
+  if (!file)
+    dllhandle = GetModuleHandle (NULL);
+  else
+    {
+      /* MSDN says to be sure to use backslashes in the DLL file name.  */
+      strcpy (dllfn, file);
+      for (p = dllfn; *p; p++)
+        if (*p == '/')
+          *p = '\\';
+
+      dllhandle = LoadLibrary (dllfn);
+    }
+  if (!dllhandle)
+    last_err = GetLastError ();
+
+  return dllhandle;
+}
+
+char *
+dlerror (void)
+{
+  static char errbuf[1024];
+  DWORD ret;
+
+  if (!last_err)
+    return NULL;
+
+  ret = FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM
+                       | FORMAT_MESSAGE_IGNORE_INSERTS,
+                       NULL, last_err, 0, errbuf, sizeof (errbuf), NULL);
+  while (ret > 0 && (errbuf[ret - 1] == '\n' || errbuf[ret - 1] == '\r'))
+    --ret;
+
+  errbuf[ret] = '\0';
+  if (!ret)
+    sprintf (errbuf, "Error code %lu", last_err);
+
+  last_err = 0;
+  return errbuf;
+}
+
+void *
+dlsym (void *handle, const char *name)
+{
+  FARPROC addr = NULL;
+
+  if (!handle || handle == INVALID_HANDLE_VALUE)
+    {
+      last_err = ERROR_INVALID_PARAMETER;
+      return NULL;
+    }
+
+  addr = GetProcAddress (handle, name);
+  if (!addr)
+    last_err = GetLastError ();
+
+  return (void *)addr;
+}
+
+int
+dlclose (void *handle)
+{
+  if (!handle || handle == INVALID_HANDLE_VALUE)
+    return -1;
+  if (!FreeLibrary (handle))
+    return -1;
+
+  return 0;
+}
+
+
+#endif  /* MAKE_LOAD */
+
+
+/* MS runtime's isatty returns non-zero for any character device,
+   including the null device, which is not what we want.  */
+int
+isatty (int fd)
+{
+  HANDLE fh = (HANDLE) _get_osfhandle (fd);
+  DWORD con_mode;
+
+  if (fh == INVALID_HANDLE_VALUE)
+    {
+      errno = EBADF;
+      return 0;
+    }
+  if (GetConsoleMode (fh, &con_mode))
+    return 1;
+
+  errno = ENOTTY;
+  return 0;
+}
+
+char *
+ttyname (int fd)
+{
+  /* This "knows" that Make only asks about stdout and stderr.  A more
+     sophisticated implementation should test whether FD is open for
+     input or output.  We can do that by looking at the mode returned
+     by GetConsoleMode.  */
+  return "CONOUT$";
+}
diff --git a/src/w32/include/dirent.h b/src/w32/include/dirent.h
new file mode 100644
index 0000000..ea817f1
--- /dev/null
+++ b/src/w32/include/dirent.h
@@ -0,0 +1,58 @@
+/* Windows version of dirent.h
+Copyright (C) 1996-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef _DIRENT_H
+#define _DIRENT_H
+
+#ifdef __MINGW32__
+# include <windows.h>
+# include_next <dirent.h>
+#else
+
+#include <stdlib.h>
+#include <windows.h>
+#include <limits.h>
+#include <sys/types.h>
+
+#ifndef NAME_MAX
+#define NAME_MAX 255
+#endif
+
+#define __DIRENT_COOKIE 0xfefeabab
+
+
+struct dirent
+{
+  ino_t d_ino;                  /* unused - no equivalent on WINDOWS32 */
+  char d_name[NAME_MAX+1];
+};
+
+typedef struct dir_struct {
+        ULONG   dir_ulCookie;
+        HANDLE  dir_hDirHandle;
+        DWORD   dir_nNumFiles;
+        char    dir_pDirectoryName[NAME_MAX+1];
+        struct dirent dir_sdReturn;
+} DIR;
+
+DIR *opendir(const char *);
+struct dirent *readdir(DIR *);
+void rewinddir(DIR *);
+void closedir(DIR *);
+void seekdir(DIR *, long);
+
+#endif  /* !__MINGW32__ */
+#endif
diff --git a/src/w32/include/dlfcn.h b/src/w32/include/dlfcn.h
new file mode 100644
index 0000000..55c5f20
--- /dev/null
+++ b/src/w32/include/dlfcn.h
@@ -0,0 +1,29 @@
+/* dlfcn.h replacement for MS-Windows build.
+Copyright (C) 2013-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef DLFCN_H
+#define DLFCN_H
+
+#define RTLD_LAZY   1
+#define RTLD_NOW    2
+#define RTLD_GLOBAL 4
+
+extern void *dlopen (const char *, int);
+extern void *dlsym (void *, const char *);
+extern char *dlerror (void);
+extern int   dlclose (void *);
+
+#endif  /* DLFCN_H */
diff --git a/src/w32/include/pathstuff.h b/src/w32/include/pathstuff.h
new file mode 100644
index 0000000..6f3615d
--- /dev/null
+++ b/src/w32/include/pathstuff.h
@@ -0,0 +1,25 @@
+/* Definitions for Windows path manipulation.
+Copyright (C) 1996-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef _PATHSTUFF_H
+#define _PATHSTUFF_H
+
+char *convert_Path_to_windows32(char *Path, char to_delim);
+char *convert_vpath_to_windows32(char *Path, char to_delim);
+char *w32ify(const char *file, int resolve);
+char *getcwd_fs(char *buf, int len);
+
+#endif
diff --git a/src/w32/include/sub_proc.h b/src/w32/include/sub_proc.h
new file mode 100644
index 0000000..b3147bd
--- /dev/null
+++ b/src/w32/include/sub_proc.h
@@ -0,0 +1,64 @@
+/* Definitions for Windows process invocation.
+Copyright (C) 1996-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef SUB_PROC_H
+#define SUB_PROC_H
+
+/*
+ * Component Name:
+ *
+ * $Date$
+ *
+ * $Source$
+ *
+ * $Id$
+ */
+
+#define EXTERN_DECL(entry, args) extern entry args
+#define VOID_DECL void
+
+EXTERN_DECL(HANDLE process_init, (VOID_DECL));
+EXTERN_DECL(HANDLE process_init_fd, (HANDLE stdinh, HANDLE stdouth,
+                                     HANDLE stderrh));
+EXTERN_DECL(long process_begin, (HANDLE proc, char **argv, char **envp,
+                                 char *exec_path, char *as_user));
+EXTERN_DECL(long process_pipe_io, (HANDLE proc, char *stdin_data,
+                                   int stdin_data_len));
+EXTERN_DECL(long process_file_io, (HANDLE proc));
+EXTERN_DECL(void process_cleanup, (HANDLE proc));
+EXTERN_DECL(HANDLE process_wait_for_any, (int block, DWORD* pdwWaitStatus));
+EXTERN_DECL(void process_register, (HANDLE proc));
+EXTERN_DECL(HANDLE process_easy, (char** argv, char** env,
+                                  int outfd, int errfd));
+EXTERN_DECL(BOOL process_kill, (HANDLE proc, int signal));
+EXTERN_DECL(BOOL process_table_full, (VOID_DECL));
+EXTERN_DECL(int process_table_usable_size, (VOID_DECL));
+EXTERN_DECL(int process_table_actual_size, (VOID_DECL));
+EXTERN_DECL(DWORD process_set_handles, (HANDLE *handles));
+EXTERN_DECL(DWORD process_wait_for_multiple_objects, (DWORD, const HANDLE*, BOOL, DWORD));
+
+/* support routines */
+EXTERN_DECL(long process_errno, (HANDLE proc));
+EXTERN_DECL(long process_last_err, (HANDLE proc));
+EXTERN_DECL(long process_exit_code, (HANDLE proc));
+EXTERN_DECL(long process_signal, (HANDLE proc));
+EXTERN_DECL(char * process_outbuf, (HANDLE proc));
+EXTERN_DECL(char * process_errbuf, (HANDLE proc));
+EXTERN_DECL(int process_outcnt, (HANDLE proc));
+EXTERN_DECL(int process_errcnt, (HANDLE proc));
+EXTERN_DECL(void process_pipes, (HANDLE proc, int pipes[3]));
+
+#endif
diff --git a/src/w32/include/w32err.h b/src/w32/include/w32err.h
new file mode 100644
index 0000000..7a40607
--- /dev/null
+++ b/src/w32/include/w32err.h
@@ -0,0 +1,26 @@
+/* Definitions for Windows error handling.
+Copyright (C) 1996-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef _W32ERR_H_
+#define _W32ERR_H_
+
+#ifndef EXTERN_DECL
+#define EXTERN_DECL(entry, args) entry args
+#endif
+
+EXTERN_DECL(const char * map_windows32_error_to_string, (DWORD error));
+
+#endif /* !_W32ERR_H */
diff --git a/src/w32/pathstuff.c b/src/w32/pathstuff.c
new file mode 100644
index 0000000..82450de
--- /dev/null
+++ b/src/w32/pathstuff.c
@@ -0,0 +1,266 @@
+/* Path conversion for Windows pathnames.
+Copyright (C) 1996-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+#include <string.h>
+#include <stdlib.h>
+#include "pathstuff.h"
+
+/*
+ * Convert delimiter separated vpath to Canonical format.
+ */
+char *
+convert_vpath_to_windows32(char *Path, char to_delim)
+{
+    char *etok;            /* token separator for old Path */
+
+        /*
+         * Convert all spaces to delimiters. Note that pathnames which
+         * contain blanks get trounced here. Use 8.3 format as a workaround.
+         */
+        for (etok = Path; etok && *etok; etok++)
+                if (ISBLANK ((unsigned char) *etok))
+                        *etok = to_delim;
+
+        return (convert_Path_to_windows32(Path, to_delim));
+}
+
+/*
+ * Convert delimiter separated path to Canonical format.
+ */
+char *
+convert_Path_to_windows32(char *Path, char to_delim)
+{
+    char *etok;            /* token separator for old Path */
+    char *p;            /* points to element of old Path */
+
+    /* is this a multi-element Path ? */
+    /* FIXME: Perhaps use ":;\"" in strpbrk to convert all quotes to
+       delimiters as well, as a way to handle quoted directories in
+       PATH?  */
+    for (p = Path, etok = strpbrk(p, ":;");
+         etok;
+         etok = strpbrk(p, ":;"))
+        if ((etok - p) == 1) {
+            if (*(etok - 1) == ';' ||
+                *(etok - 1) == ':') {
+                etok[-1] = to_delim;
+                etok[0] = to_delim;
+                p = ++etok;
+                continue;    /* ignore empty bucket */
+            } else if (!isalpha ((unsigned char) *p)) {
+                /* found one to count, handle things like '.' */
+                *etok = to_delim;
+                p = ++etok;
+            } else if ((*etok == ':') && (etok = strpbrk(etok+1, ":;"))) {
+                /* found one to count, handle drive letter */
+                *etok = to_delim;
+                p = ++etok;
+            } else
+                /* all finished, force abort */
+                p += strlen(p);
+        } else if (*p == '"') { /* a quoted directory */
+            for (p++; *p && *p != '"'; p++) /* skip quoted part */
+                ;
+            etok = strpbrk(p, ":;");        /* find next delimiter */
+            if (etok) {
+                *etok = to_delim;
+                p = ++etok;
+            } else
+                p += strlen(p);
+        } else {
+            /* found another one, no drive letter */
+            *etok = to_delim;
+            p = ++etok;
+        }
+
+    return Path;
+}
+
+/*
+ * Convert to forward slashes. Resolve to full pathname optionally
+ */
+char *
+w32ify(const char *filename, int resolve)
+{
+    static char w32_path[FILENAME_MAX];
+    char *p;
+
+    if (resolve)
+        _fullpath(w32_path, filename, sizeof (w32_path));
+    else
+        strncpy(w32_path, filename, sizeof (w32_path));
+
+    for (p = w32_path; p && *p; p++)
+        if (*p == '\\')
+            *p = '/';
+
+    return w32_path;
+}
+
+char *
+getcwd_fs(char* buf, int len)
+{
+        char *p = getcwd(buf, len);
+
+        if (p) {
+                char *q = w32ify(buf, 0);
+                strncpy(buf, q, len);
+        }
+
+        return p;
+}
+
+#ifdef unused
+/*
+ * Convert delimiter separated pathnames (e.g. PATH) or single file pathname
+ * (e.g. c:/foo, c:\bar) to NutC format. If we are handed a string that
+ * _NutPathToNutc() fails to convert, just return the path we were handed
+ * and assume the caller will know what to do with it (It was probably
+ * a mistake to try and convert it anyway due to some of the bizarre things
+ * that might look like pathnames in makefiles).
+ */
+char *
+convert_path_to_nutc(char *path)
+{
+    int  count;            /* count of path elements */
+    char *nutc_path;     /* new NutC path */
+    int  nutc_path_len;    /* length of buffer to allocate for new path */
+    char *pathp;        /* pointer to nutc_path used to build it */
+    char *etok;            /* token separator for old path */
+    char *p;            /* points to element of old path */
+    char sep;            /* what flavor of separator used in old path */
+    char *rval;
+
+    /* is this a multi-element path ? */
+    for (p = path, etok = strpbrk(p, ":;"), count = 0;
+         etok;
+         etok = strpbrk(p, ":;"))
+        if ((etok - p) == 1) {
+            if (*(etok - 1) == ';' ||
+                *(etok - 1) == ':') {
+                p = ++etok;
+                continue;    /* ignore empty bucket */
+            } else if (etok = strpbrk(etok+1, ":;"))
+                /* found one to count, handle drive letter */
+                p = ++etok, count++;
+            else
+                /* all finished, force abort */
+                p += strlen(p);
+        } else
+            /* found another one, no drive letter */
+            p = ++etok, count++;
+
+    if (count) {
+        count++;    /* x1;x2;x3 <- need to count x3 */
+
+        /*
+         * Hazard a guess on how big the buffer needs to be.
+         * We have to convert things like c:/foo to /c=/foo.
+         */
+        nutc_path_len = strlen(path) + (count*2) + 1;
+        nutc_path = xmalloc(nutc_path_len);
+        pathp = nutc_path;
+        *pathp = '\0';
+
+        /*
+         * Loop through PATH and convert one elemnt of the path at at
+         * a time. Single file pathnames will fail this and fall
+         * to the logic below loop.
+         */
+        for (p = path, etok = strpbrk(p, ":;");
+             etok;
+             etok = strpbrk(p, ":;")) {
+
+            /* don't trip up on device specifiers or empty path slots */
+            if ((etok - p) == 1)
+                if (*(etok - 1) == ';' ||
+                    *(etok - 1) == ':') {
+                    p = ++etok;
+                    continue;
+                } else if ((etok = strpbrk(etok+1, ":;")) == NULL)
+                    break;    /* thing found was a WINDOWS32 pathname */
+
+            /* save separator */
+            sep = *etok;
+
+            /* terminate the current path element -- temporarily */
+            *etok = '\0';
+
+#ifdef __NUTC__
+            /* convert to NutC format */
+            if (_NutPathToNutc(p, pathp, 0) == FALSE) {
+                free(nutc_path);
+                rval = savestring(path, strlen(path));
+                return rval;
+            }
+#else
+            *pathp++ = '/';
+            *pathp++ = p[0];
+            *pathp++ = '=';
+            *pathp++ = '/';
+            strcpy(pathp, &p[2]);
+#endif
+
+            pathp += strlen(pathp);
+            *pathp++ = ':';     /* use Unix style path separtor for new path */
+            *pathp   = '\0'; /* make sure we are null terminaed */
+
+            /* restore path separator */
+            *etok = sep;
+
+            /* point p to first char of next path element */
+            p = ++etok;
+
+        }
+    } else {
+        nutc_path_len = strlen(path) + 3;
+        nutc_path = xmalloc(nutc_path_len);
+        pathp = nutc_path;
+        *pathp = '\0';
+        p = path;
+    }
+
+    /*
+      * OK, here we handle the last element in PATH (e.g. c of a;b;c)
+     * or the path was a single filename and will be converted
+     * here. Note, testing p here assures that we don't trip up
+     * on paths like a;b; which have trailing delimiter followed by
+     * nothing.
+     */
+    if (*p != '\0') {
+#ifdef __NUTC__
+        if (_NutPathToNutc(p, pathp, 0) == FALSE) {
+            free(nutc_path);
+            rval = savestring(path, strlen(path));
+            return rval;
+        }
+#else
+        *pathp++ = '/';
+        *pathp++ = p[0];
+        *pathp++ = '=';
+        *pathp++ = '/';
+        strcpy(pathp, &p[2]);
+#endif
+    } else
+        *(pathp-1) = '\0'; /* we're already done, don't leave trailing : */
+
+    rval = savestring(nutc_path, strlen(nutc_path));
+    free(nutc_path);
+    return rval;
+}
+
+#endif
diff --git a/src/w32/subproc/misc.c b/src/w32/subproc/misc.c
new file mode 100644
index 0000000..6e7ac9a
--- /dev/null
+++ b/src/w32/subproc/misc.c
@@ -0,0 +1,83 @@
+/* Process handling for Windows
+Copyright (C) 1996-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include <string.h>
+#include <windows.h>
+#include "proc.h"
+
+
+/*
+ * Description:  Convert a NULL string terminated UNIX environment block to
+ *              an environment block suitable for a windows32 system call
+ *
+ * Returns:  TRUE= success, FALSE=fail
+ *
+ * Notes/Dependencies:  the environment block is sorted in case-insensitive
+ *      order, is double-null terminated, and is a char *, not a char **
+ */
+int _cdecl compare(const void *a1, const void *a2)
+{
+        return _stricoll(*((char**)a1),*((char**)a2));
+}
+bool_t
+arr2envblk(char **arr, char **envblk_out, int *envsize_needed)
+{
+        char **tmp;
+        int size_needed;
+        int arrcnt;
+        char *ptr;
+
+        arrcnt = 0;
+        while (arr[arrcnt]) {
+                arrcnt++;
+        }
+
+        tmp = (char**) calloc(arrcnt + 1, sizeof(char *));
+        if (!tmp) {
+                return FALSE;
+        }
+
+        arrcnt = 0;
+        size_needed = *envsize_needed = 0;
+        while (arr[arrcnt]) {
+                tmp[arrcnt] = arr[arrcnt];
+                size_needed += strlen(arr[arrcnt]) + 1;
+                arrcnt++;
+        }
+        size_needed++;
+        *envsize_needed = size_needed;
+
+        qsort((void *) tmp, (size_t) arrcnt, sizeof (char*), compare);
+
+        ptr = *envblk_out = calloc(size_needed, 1);
+        if (!ptr) {
+                free(tmp);
+                return FALSE;
+        }
+
+        arrcnt = 0;
+        while (tmp[arrcnt]) {
+                strcpy(ptr, tmp[arrcnt]);
+                ptr += strlen(tmp[arrcnt]) + 1;
+                arrcnt++;
+        }
+
+        free(tmp);
+        return TRUE;
+}
diff --git a/src/w32/subproc/proc.h b/src/w32/subproc/proc.h
new file mode 100644
index 0000000..ef2972d
--- /dev/null
+++ b/src/w32/subproc/proc.h
@@ -0,0 +1,29 @@
+/* Definitions for Windows
+Copyright (C) 1996-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef  _PROC_H
+#define _PROC_H
+
+typedef int bool_t;
+
+#define E_SCALL         101
+#define E_IO            102
+#define E_NO_MEM        103
+#define E_FORK          104
+
+extern bool_t arr2envblk(char **arr, char **envblk_out, int *envsize_needed);
+
+#endif
diff --git a/src/w32/subproc/sub_proc.c b/src/w32/subproc/sub_proc.c
new file mode 100644
index 0000000..e8552be
--- /dev/null
+++ b/src/w32/subproc/sub_proc.c
@@ -0,0 +1,1565 @@
+/* Process handling for Windows.
+Copyright (C) 1996-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <assert.h>
+#include <config.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <io.h>         /* for _get_osfhandle */
+#ifdef _MSC_VER
+# include <stddef.h>    /* for intptr_t */
+#else
+# include <stdint.h>
+#endif
+#include <string.h>
+#include <process.h>  /* for msvc _beginthreadex, _endthreadex */
+#include <signal.h>
+#include <windows.h>
+
+#include "makeint.h"
+#include "filedef.h"
+#include "variable.h"
+#include "sub_proc.h"
+#include "proc.h"
+#include "w32err.h"
+#include "debug.h"
+#include "os.h"
+
+#define GMAKE_MAXIMUM_WAIT_OBJECTS (MAXIMUM_WAIT_OBJECTS * MAXIMUM_WAIT_OBJECTS)
+
+/* We need to move these special-case return codes out-of-band */
+#define GMAKE_WAIT_TIMEOUT      0xFFFF0102L
+#define GMAKE_WAIT_ABANDONED_0  0x00080000L
+
+static char *make_command_line(char *shell_name, char *exec_path, char **argv);
+
+typedef struct sub_process_t {
+        intptr_t sv_stdin[2];
+        intptr_t sv_stdout[2];
+        intptr_t sv_stderr[2];
+        int using_pipes;
+        char *inp;
+        DWORD incnt;
+        char * volatile outp;
+        volatile DWORD outcnt;
+        char * volatile errp;
+        volatile DWORD errcnt;
+        pid_t pid;
+        int exit_code;
+        int signal;
+        long last_err;
+        long lerrno;
+} sub_process;
+
+/* keep track of children so we can implement a waitpid-like routine */
+static sub_process *proc_array[GMAKE_MAXIMUM_WAIT_OBJECTS];
+static int proc_index = 0;
+static int fake_exits_pending = 0;
+
+/*
+ * Address the scalability limit intrisic to WaitForMultipleOjects by
+ * calling WaitForMultipleObjects on 64 element chunks of the input
+ * array with 0 timeout.  Exit with an appropriately conditioned result
+ * or repeat again every 10 ms if no handle has signaled and the
+ * requested timeout was not zero.
+ */
+DWORD process_wait_for_multiple_objects(
+  DWORD nCount,
+  const HANDLE *lpHandles,
+  BOOL bWaitAll,
+  DWORD dwMilliseconds
+)
+{
+  assert(nCount <= GMAKE_MAXIMUM_WAIT_OBJECTS);
+
+  if (nCount <= MAXIMUM_WAIT_OBJECTS) {
+    DWORD retVal =  WaitForMultipleObjects(nCount, lpHandles, bWaitAll, dwMilliseconds);
+    return (retVal == WAIT_TIMEOUT) ? GMAKE_WAIT_TIMEOUT : retVal;
+  } else {
+    for (;;) {
+      DWORD objectCount = nCount;
+      int blockCount  = 0;
+      DWORD retVal;
+
+      assert(bWaitAll == FALSE); /* This logic only works for this use case */
+      assert(dwMilliseconds == 0 || dwMilliseconds == INFINITE); /* No support for timeouts */
+
+      for (; objectCount > 0; blockCount++) {
+	DWORD n = objectCount <= MAXIMUM_WAIT_OBJECTS ? objectCount : MAXIMUM_WAIT_OBJECTS;
+	objectCount -= n;
+	retVal = WaitForMultipleObjects(n, &lpHandles[blockCount * MAXIMUM_WAIT_OBJECTS],
+					    FALSE, 0);
+	switch (retVal) {
+	  case WAIT_TIMEOUT:
+	    retVal = GMAKE_WAIT_TIMEOUT;
+	    continue;
+	    break;
+	  case WAIT_FAILED:
+	    fprintf(stderr,"WaitForMultipleOjbects failed waiting with error %d\n", GetLastError());
+	    break;
+	  default:
+	    if (retVal >= WAIT_ABANDONED_0) {
+	      assert(retVal < WAIT_ABANDONED_0 + MAXIMUM_WAIT_OBJECTS);
+	      retVal += blockCount * MAXIMUM_WAIT_OBJECTS - WAIT_ABANDONED_0 + GMAKE_WAIT_ABANDONED_0;
+	    } else {
+	      assert(retVal < WAIT_OBJECT_0 + MAXIMUM_WAIT_OBJECTS);
+	      retVal += blockCount * MAXIMUM_WAIT_OBJECTS;
+	    }
+	    break;
+	}
+
+	return retVal;
+
+      }
+
+      if (dwMilliseconds == 0) return retVal;
+
+      Sleep(10);  /* Sleep for 10 ms */
+    }
+  }
+}
+
+/*
+ * Fill a HANDLE list with handles to wait for.
+ */
+DWORD
+process_set_handles(HANDLE *handles)
+{
+    DWORD count = 0;
+    int i;
+
+    /* Build array of handles to wait for */
+    for (i = 0; i < proc_index; i++) {
+        /* Don't wait on child processes that have already finished */
+        if (fake_exits_pending && proc_array[i]->exit_code)
+            continue;
+
+        handles[count++] = (HANDLE) proc_array[i]->pid;
+    }
+
+    return count;
+}
+
+/*
+ * When a process has been waited for, adjust the wait state
+ * array so that we don't wait for it again
+ */
+static void
+process_adjust_wait_state(sub_process* pproc)
+{
+        int i;
+
+        if (!proc_index)
+                return;
+
+        for (i = 0; i < proc_index; i++)
+                if (proc_array[i]->pid == pproc->pid)
+                        break;
+
+        if (i < proc_index) {
+                proc_index--;
+                if (i != proc_index)
+                        memmove(&proc_array[i], &proc_array[i+1],
+                                (proc_index-i) * sizeof(sub_process*));
+                proc_array[proc_index] = NULL;
+        }
+}
+
+/*
+ * Waits for any of the registered child processes to finish.
+ */
+static sub_process *
+process_wait_for_any_private(int block, DWORD* pdwWaitStatus)
+{
+        HANDLE handles[GMAKE_MAXIMUM_WAIT_OBJECTS];
+        DWORD retval, which;
+        int i;
+
+        if (!proc_index)
+                return NULL;
+
+        /* build array of handles to wait for */
+        for (i = 0; i < proc_index; i++) {
+                handles[i] = (HANDLE) proc_array[i]->pid;
+
+                if (fake_exits_pending && proc_array[i]->exit_code)
+                        break;
+        }
+
+        /* wait for someone to exit */
+        if (!fake_exits_pending) {
+                retval = process_wait_for_multiple_objects(proc_index, handles, FALSE, (block ? INFINITE : 0));
+                which = retval - WAIT_OBJECT_0;
+        } else {
+                fake_exits_pending--;
+                retval = !WAIT_FAILED;
+                which = i;
+        }
+
+        /* If the pointer is not NULL, set the wait status result variable. */
+        if (pdwWaitStatus)
+                *pdwWaitStatus = (retval == GMAKE_WAIT_TIMEOUT) ? WAIT_TIMEOUT : retval;
+
+        /* return pointer to process */
+        if ((retval == GMAKE_WAIT_TIMEOUT) || (retval == WAIT_FAILED)) {
+                return NULL;
+        }
+        else {
+                sub_process* pproc = proc_array[which];
+                process_adjust_wait_state(pproc);
+                return pproc;
+        }
+}
+
+/*
+ * Terminate a process.
+ */
+BOOL
+process_kill(HANDLE proc, int signal)
+{
+        sub_process* pproc = (sub_process*) proc;
+        pproc->signal = signal;
+        return (TerminateProcess((HANDLE) pproc->pid, signal));
+}
+
+/*
+ * Returns true when we have no more available slots in our process table.
+ */
+BOOL
+process_table_full()
+{
+  extern int shell_function_pid;
+
+  /* Reserve slots for jobserver_semaphore if we have one and the shell function if not active */
+  return(proc_index >= GMAKE_MAXIMUM_WAIT_OBJECTS - jobserver_enabled() - (shell_function_pid == 0));
+}
+
+/*
+ * Returns the maximum number of job slots we can support when using the jobserver.
+ */
+int
+process_table_usable_size()
+{
+  /* Reserve slots for jobserver_semaphore and shell function */
+  return(GMAKE_MAXIMUM_WAIT_OBJECTS - 2);
+}
+
+/*
+ * Returns the actual size of the process table.
+ */
+int
+process_table_actual_size()
+{
+  return(GMAKE_MAXIMUM_WAIT_OBJECTS);
+}
+
+/*
+ * Use this function to register processes you wish to wait for by
+ * calling process_file_io(NULL) or process_wait_any(). This must be done
+ * because it is possible for callers of this library to reuse the same
+ * handle for multiple processes launches :-(
+ */
+void
+process_register(HANDLE proc)
+{
+  assert(proc_index < GMAKE_MAXIMUM_WAIT_OBJECTS);
+  proc_array[proc_index++] = (sub_process *) proc;
+}
+
+/*
+ * Public function which works kind of like waitpid(). Wait for any
+ * of the children to die and return results. To call this function,
+ * you must do 1 of things:
+ *
+ *      x = process_easy(...);
+ *
+ * or
+ *
+ *      x = process_init_fd();
+ *      process_register(x);
+ *
+ * or
+ *
+ *      x = process_init();
+ *      process_register(x);
+ *
+ * You must NOT then call process_pipe_io() because this function is
+ * not capable of handling automatic notification of any child
+ * death.
+ */
+
+HANDLE
+process_wait_for_any(int block, DWORD* pdwWaitStatus)
+{
+        sub_process* pproc = process_wait_for_any_private(block, pdwWaitStatus);
+
+        if (!pproc)
+                return NULL;
+        else {
+                /*
+                 * Ouch! can't tell caller if this fails directly. Caller
+                 * will have to use process_last_err()
+                 */
+                (void) process_file_io(pproc);
+                return ((HANDLE) pproc);
+        }
+}
+
+long
+process_signal(HANDLE proc)
+{
+        if (proc == INVALID_HANDLE_VALUE) return 0;
+        return (((sub_process *)proc)->signal);
+}
+
+long
+process_last_err(HANDLE proc)
+{
+        if (proc == INVALID_HANDLE_VALUE) return ERROR_INVALID_HANDLE;
+        return (((sub_process *)proc)->last_err);
+}
+
+long
+process_exit_code(HANDLE proc)
+{
+        if (proc == INVALID_HANDLE_VALUE) return EXIT_FAILURE;
+        return (((sub_process *)proc)->exit_code);
+}
+
+/*
+2006-02:
+All the following functions are currently unused.
+All of them would crash gmake if called with argument INVALID_HANDLE_VALUE.
+Hence whoever wants to use one of this functions must invent and implement
+a reasonable error handling for this function.
+
+char *
+process_outbuf(HANDLE proc)
+{
+        return (((sub_process *)proc)->outp);
+}
+
+char *
+process_errbuf(HANDLE proc)
+{
+        return (((sub_process *)proc)->errp);
+}
+
+int
+process_outcnt(HANDLE proc)
+{
+        return (((sub_process *)proc)->outcnt);
+}
+
+int
+process_errcnt(HANDLE proc)
+{
+        return (((sub_process *)proc)->errcnt);
+}
+
+void
+process_pipes(HANDLE proc, int pipes[3])
+{
+        pipes[0] = ((sub_process *)proc)->sv_stdin[0];
+        pipes[1] = ((sub_process *)proc)->sv_stdout[0];
+        pipes[2] = ((sub_process *)proc)->sv_stderr[0];
+        return;
+}
+*/
+
+        HANDLE
+process_init()
+{
+        sub_process *pproc;
+        /*
+         * open file descriptors for attaching stdin/stdout/sterr
+         */
+        HANDLE stdin_pipes[2];
+        HANDLE stdout_pipes[2];
+        HANDLE stderr_pipes[2];
+        SECURITY_ATTRIBUTES inherit;
+        BYTE sd[SECURITY_DESCRIPTOR_MIN_LENGTH];
+
+        pproc = malloc(sizeof(*pproc));
+        memset(pproc, 0, sizeof(*pproc));
+
+        /* We can't use NULL for lpSecurityDescriptor because that
+           uses the default security descriptor of the calling process.
+           Instead we use a security descriptor with no DACL.  This
+           allows nonrestricted access to the associated objects. */
+
+        if (!InitializeSecurityDescriptor((PSECURITY_DESCRIPTOR)(&sd),
+                                          SECURITY_DESCRIPTOR_REVISION)) {
+                pproc->last_err = GetLastError();
+                pproc->lerrno = E_SCALL;
+                return((HANDLE)pproc);
+        }
+
+        inherit.nLength = sizeof(inherit);
+        inherit.lpSecurityDescriptor = (PSECURITY_DESCRIPTOR)(&sd);
+        inherit.bInheritHandle = TRUE;
+
+        // By convention, parent gets pipe[0], and child gets pipe[1]
+        // This means the READ side of stdin pipe goes into pipe[1]
+        // and the WRITE side of the stdout and stderr pipes go into pipe[1]
+        if (CreatePipe( &stdin_pipes[1], &stdin_pipes[0], &inherit, 0) == FALSE ||
+        CreatePipe( &stdout_pipes[0], &stdout_pipes[1], &inherit, 0) == FALSE ||
+        CreatePipe( &stderr_pipes[0], &stderr_pipes[1], &inherit, 0) == FALSE) {
+
+                pproc->last_err = GetLastError();
+                pproc->lerrno = E_SCALL;
+                return((HANDLE)pproc);
+        }
+
+        //
+        // Mark the parent sides of the pipes as non-inheritable
+        //
+        if (SetHandleInformation(stdin_pipes[0],
+                                HANDLE_FLAG_INHERIT, 0) == FALSE ||
+                SetHandleInformation(stdout_pipes[0],
+                                HANDLE_FLAG_INHERIT, 0) == FALSE ||
+                SetHandleInformation(stderr_pipes[0],
+                                HANDLE_FLAG_INHERIT, 0) == FALSE) {
+
+                pproc->last_err = GetLastError();
+                pproc->lerrno = E_SCALL;
+                return((HANDLE)pproc);
+        }
+        pproc->sv_stdin[0]  = (intptr_t) stdin_pipes[0];
+        pproc->sv_stdin[1]  = (intptr_t) stdin_pipes[1];
+        pproc->sv_stdout[0] = (intptr_t) stdout_pipes[0];
+        pproc->sv_stdout[1] = (intptr_t) stdout_pipes[1];
+        pproc->sv_stderr[0] = (intptr_t) stderr_pipes[0];
+        pproc->sv_stderr[1] = (intptr_t) stderr_pipes[1];
+
+        pproc->using_pipes = 1;
+
+        pproc->lerrno = 0;
+
+        return((HANDLE)pproc);
+}
+
+
+        HANDLE
+process_init_fd(HANDLE stdinh, HANDLE stdouth, HANDLE stderrh)
+{
+        sub_process *pproc;
+
+        pproc = malloc(sizeof(*pproc));
+        if (pproc) {
+                memset(pproc, 0, sizeof(*pproc));
+
+                /*
+                 * Just pass the provided file handles to the 'child
+                 * side' of the pipe, bypassing pipes altogether.
+                 */
+                pproc->sv_stdin[1]  = (intptr_t) stdinh;
+                pproc->sv_stdout[1] = (intptr_t) stdouth;
+                pproc->sv_stderr[1] = (intptr_t) stderrh;
+
+                pproc->last_err = pproc->lerrno = 0;
+        }
+
+        return((HANDLE)pproc);
+}
+
+
+static HANDLE
+find_file(const char *exec_path, const char *path_var,
+          char *full_fname, DWORD full_len)
+{
+        HANDLE exec_handle;
+        char *fname;
+        char *ext;
+        DWORD req_len;
+        int i;
+        static const char *extensions[] =
+          /* Should .com come before no-extension case?  */
+          { ".exe", ".cmd", ".bat", "", ".com", NULL };
+
+        fname = xmalloc(strlen(exec_path) + 5);
+        strcpy(fname, exec_path);
+        ext = fname + strlen(fname);
+
+        for (i = 0; extensions[i]; i++) {
+                strcpy(ext, extensions[i]);
+                if (((req_len = SearchPath (path_var, fname, NULL, full_len,
+                                            full_fname, NULL)) > 0
+                     /* For compatibility with previous code, which
+                        used OpenFile, and with Windows operation in
+                        general, also look in various default
+                        locations, such as Windows directory and
+                        Windows System directory.  Warning: this also
+                        searches PATH in the Make's environment, which
+                        might not be what the Makefile wants, but it
+                        seems to be OK as a fallback, after the
+                        previous SearchPath failed to find on child's
+                        PATH.  */
+                     || (req_len = SearchPath (NULL, fname, NULL, full_len,
+                                               full_fname, NULL)) > 0)
+                    && req_len <= full_len
+                    && (exec_handle =
+                                CreateFile(full_fname,
+                                           GENERIC_READ,
+                                           FILE_SHARE_READ | FILE_SHARE_WRITE,
+                                           NULL,
+                                           OPEN_EXISTING,
+                                           FILE_ATTRIBUTE_NORMAL,
+                                           NULL)) != INVALID_HANDLE_VALUE) {
+                        free(fname);
+                        return(exec_handle);
+                }
+        }
+
+        free(fname);
+        return INVALID_HANDLE_VALUE;
+}
+
+/*
+ * Return non-zero of FNAME specifies a batch file and its name
+ * includes embedded whitespace.
+ */
+
+static int
+batch_file_with_spaces(const char *fname)
+{
+        size_t fnlen = strlen(fname);
+
+        return (fnlen > 4
+                && (_strnicmp(fname + fnlen - 4, ".bat", 4) == 0
+                    || _strnicmp(fname + fnlen - 4, ".cmd", 4) == 0)
+                /* The set of characters in the 2nd arg to strpbrk
+                   should be the same one used by make_command_line
+                   below to decide whether an argv[] element needs
+                   quoting.  */
+                && strpbrk(fname, " \t") != NULL);
+}
+
+
+/*
+ * Description:   Create the child process to be helped
+ *
+ * Returns: success <=> 0
+ *
+ * Notes/Dependencies:
+ */
+long
+process_begin(
+        HANDLE proc,
+        char **argv,
+        char **envp,
+        char *exec_path,
+        char *as_user)
+{
+        sub_process *pproc = (sub_process *)proc;
+        char *shell_name = 0;
+        int file_not_found=0;
+        HANDLE exec_handle;
+        char exec_fname[MAX_PATH];
+        const char *path_var = NULL;
+        char **ep;
+        char buf[MAX_PATH];
+        DWORD bytes_returned;
+        DWORD flags;
+        char *command_line;
+        STARTUPINFO startInfo;
+        PROCESS_INFORMATION procInfo;
+        char *envblk=NULL;
+        int envsize_needed = 0;
+        int pass_null_exec_path = 0;
+
+        /*
+         *  Shell script detection...  if the exec_path starts with #! then
+         *  we want to exec shell-script-name exec-path, not just exec-path
+         *  NT doesn't recognize #!/bin/sh or #!/etc/Tivoli/bin/perl.  We do not
+         *  hard-code the path to the shell or perl or whatever:  Instead, we
+         *  assume it's in the path somewhere (generally, the NT tools
+         *  bin directory)
+         */
+
+        /* Use the Makefile's value of PATH to look for the program to
+           execute, because it could be different from Make's PATH
+           (e.g., if the target sets its own value.  */
+        if (envp)
+                for (ep = envp; *ep; ep++) {
+                        if (strncmp (*ep, "PATH=", 5) == 0
+                            || strncmp (*ep, "Path=", 5) == 0) {
+                                path_var = *ep + 5;
+                                break;
+                        }
+                }
+        exec_handle = find_file(exec_path, path_var,
+                                exec_fname, sizeof(exec_fname));
+
+        /*
+         * If we couldn't open the file, just assume that Windows will be
+         * somehow able to find and execute it.  If the first character
+         * of the command is '/', assume they set SHELL to a Unixy shell
+         * that have some magic mounts known only to it, and run the whole
+         * command via $SHELL -c "COMMAND" instead.
+         */
+        if (exec_handle == INVALID_HANDLE_VALUE) {
+                if (exec_path[0] == '/') {
+                        char *new_argv0;
+                        char **argvi = argv;
+                        int arglen = 0;
+
+                        strcpy(buf, variable_expand ("$(SHELL)"));
+                        shell_name = &buf[0];
+                        strcpy(exec_fname, "-c");
+                        /* Construct a single command string in argv[0].  */
+                        while (*argvi) {
+                                arglen += strlen(*argvi) + 1;
+                                argvi++;
+                        }
+                        new_argv0 = xmalloc(arglen + 1);
+                        new_argv0[0] = '\0';
+                        for (argvi = argv; *argvi; argvi++) {
+                                strcat(new_argv0, *argvi);
+                                strcat(new_argv0, " ");
+                        }
+                        /* Remove the extra blank at the end.  */
+                        new_argv0[arglen-1] = '\0';
+                        free(argv[0]);
+                        argv[0] = new_argv0;
+                        argv[1] = NULL;
+                }
+                else
+                        file_not_found++;
+        }
+        else {
+                /* Attempt to read the first line of the file */
+                if (ReadFile( exec_handle,
+                                buf, sizeof(buf) - 1, /* leave room for trailing NULL */
+                                &bytes_returned, 0) == FALSE || bytes_returned < 2) {
+
+                        pproc->last_err = GetLastError();
+                        pproc->lerrno = E_IO;
+                        CloseHandle(exec_handle);
+                        return(-1);
+                }
+                if (buf[0] == '#' && buf[1] == '!') {
+                        /*
+                         *  This is a shell script...  Change the command line from
+                         *      exec_path args to shell_name exec_path args
+                         */
+                        char *p;
+
+                        /*  Make sure buf is NULL terminated */
+                        buf[bytes_returned] = 0;
+                        /*
+                         * Depending on the file system type, etc. the first line
+                         * of the shell script may end with newline or newline-carriage-return
+                         * Whatever it ends with, cut it off.
+                         */
+                        p= strchr(buf, '\n');
+                        if (p)
+                                *p = 0;
+                        p = strchr(buf, '\r');
+                        if (p)
+                                *p = 0;
+
+                        /*
+                         *  Find base name of shell
+                         */
+                        shell_name = strrchr( buf, '/');
+                        if (shell_name) {
+                                shell_name++;
+                        } else {
+                                shell_name = &buf[2];/* skipping "#!" */
+                        }
+
+                }
+                CloseHandle(exec_handle);
+        }
+
+        flags = 0;
+
+        if (file_not_found)
+                command_line = make_command_line( shell_name, exec_path, argv);
+        else {
+                /* If exec_fname includes whitespace, CreateProcess
+                   behaves erratically and unreliably, and often fails
+                   if argv[0] also includes whitespace (and thus will
+                   be quoted by make_command_line below).  So in that
+                   case, we don't pass exec_fname as the 1st arg to
+                   CreateProcess, but instead replace argv[0] with
+                   exec_fname (to keep its leading directories and
+                   extension as found by find_file), and pass NULL to
+                   CreateProcess as its 1st arg.  This works around
+                   the bugs in CreateProcess, which are probably
+                   caused by its passing the command to cmd.exe with
+                   some incorrect quoting.  */
+                if (!shell_name
+                    && batch_file_with_spaces(exec_fname)
+                    && _stricmp(exec_path, argv[0]) == 0) {
+                        char *new_argv, *p;
+                        char **argvi;
+                        int arglen, i;
+                        pass_null_exec_path = 1;
+                        /* Rewrite argv[] replacing argv[0] with exec_fname.  */
+                        for (argvi = argv + 1, arglen = strlen(exec_fname) + 1;
+                             *argvi;
+                             argvi++) {
+                                arglen += strlen(*argvi) + 1;
+                        }
+                        new_argv = xmalloc(arglen);
+                        p = strcpy(new_argv, exec_fname) + strlen(exec_fname) + 1;
+                        for (argvi = argv + 1, i = 1; *argvi; argvi++, i++) {
+                                strcpy(p, *argvi);
+                                argv[i] = p;
+                                p += strlen(*argvi) + 1;
+                        }
+                        argv[i] = NULL;
+                        free (argv[0]);
+                        argv[0] = new_argv;
+                }
+                command_line = make_command_line( shell_name, exec_fname, argv);
+        }
+
+        if ( command_line == NULL ) {
+                pproc->last_err = 0;
+                pproc->lerrno = E_NO_MEM;
+                return(-1);
+        }
+
+        if (envp) {
+                if (arr2envblk(envp, &envblk, &envsize_needed) == FALSE) {
+                        pproc->lerrno = E_NO_MEM;
+                        free( command_line );
+                        if ((pproc->last_err == ERROR_INVALID_PARAMETER
+                             || pproc->last_err == ERROR_MORE_DATA)
+                            && envsize_needed > 32*1024) {
+                                fprintf (stderr, "CreateProcess failed, probably because environment is too large (%d bytes).\n",
+                                         envsize_needed);
+                        }
+                        pproc->last_err = 0;
+                        return(-1);
+                }
+        }
+
+        if (shell_name || file_not_found || pass_null_exec_path) {
+                exec_path = 0;  /* Search for the program in %Path% */
+        } else {
+                exec_path = exec_fname;
+        }
+
+        /*
+         *  Set up inherited stdin, stdout, stderr for child
+         */
+        memset(&startInfo, '\0', sizeof(startInfo));
+        GetStartupInfo(&startInfo);
+        startInfo.dwFlags = STARTF_USESTDHANDLES;
+        startInfo.lpReserved = 0;
+        startInfo.cbReserved2 = 0;
+        startInfo.lpReserved2 = 0;
+        startInfo.hStdInput = (HANDLE)pproc->sv_stdin[1];
+        startInfo.hStdOutput = (HANDLE)pproc->sv_stdout[1];
+        startInfo.hStdError = (HANDLE)pproc->sv_stderr[1];
+
+        if (as_user) {
+                free(envblk);
+                return -1;
+        } else {
+                DB (DB_JOBS, ("CreateProcess(%s,%s,...)\n",
+                        exec_path ? exec_path : "NULL",
+                        command_line ? command_line : "NULL"));
+                if (CreateProcess(
+                        exec_path,
+                        command_line,
+                        NULL,
+                        0, /* default security attributes for thread */
+                        TRUE, /* inherit handles (e.g. helper pipes, oserv socket) */
+                        flags,
+                        envblk,
+                        0, /* default starting directory */
+                        &startInfo,
+                        &procInfo) == FALSE) {
+
+                        pproc->last_err = GetLastError();
+                        pproc->lerrno = E_FORK;
+                        fprintf(stderr, "process_begin: CreateProcess(%s, %s, ...) failed.\n",
+                                exec_path ? exec_path : "NULL", command_line);
+                        free(envblk);
+                        free( command_line );
+                        return(-1);
+                }
+        }
+
+        pproc->pid = (pid_t)procInfo.hProcess;
+        /* Close the thread handle -- we'll just watch the process */
+        CloseHandle(procInfo.hThread);
+
+        /* Close the halves of the pipes we don't need */
+        if ((HANDLE)pproc->sv_stdin[1] != INVALID_HANDLE_VALUE)
+          CloseHandle((HANDLE)pproc->sv_stdin[1]);
+        if ((HANDLE)pproc->sv_stdout[1] != INVALID_HANDLE_VALUE)
+          CloseHandle((HANDLE)pproc->sv_stdout[1]);
+        if ((HANDLE)pproc->sv_stderr[1] != INVALID_HANDLE_VALUE)
+          CloseHandle((HANDLE)pproc->sv_stderr[1]);
+        pproc->sv_stdin[1] = 0;
+        pproc->sv_stdout[1] = 0;
+        pproc->sv_stderr[1] = 0;
+
+        free( command_line );
+        free(envblk);
+        pproc->lerrno=0;
+        return 0;
+}
+
+
+
+#if 0   /* unused */
+static DWORD
+proc_stdin_thread(sub_process *pproc)
+{
+        DWORD in_done;
+        for (;;) {
+                if (WriteFile( (HANDLE) pproc->sv_stdin[0], pproc->inp, pproc->incnt,
+                                         &in_done, NULL) == FALSE)
+                        _endthreadex(0);
+                // This if should never be true for anonymous pipes, but gives
+                // us a chance to change I/O mechanisms later
+                if (in_done < pproc->incnt) {
+                        pproc->incnt -= in_done;
+                        pproc->inp += in_done;
+                } else {
+                        _endthreadex(0);
+                }
+        }
+        return 0; // for compiler warnings only.. not reached
+}
+
+static DWORD
+proc_stdout_thread(sub_process *pproc)
+{
+        DWORD bufsize = 1024;
+        char c;
+        DWORD nread;
+        pproc->outp = malloc(bufsize);
+        if (pproc->outp == NULL)
+                _endthreadex(0);
+        pproc->outcnt = 0;
+
+        for (;;) {
+                if (ReadFile( (HANDLE)pproc->sv_stdout[0], &c, 1, &nread, NULL)
+                                        == FALSE) {
+/*                      map_windows32_error_to_string(GetLastError());*/
+                        _endthreadex(0);
+                }
+                if (nread == 0)
+                        _endthreadex(0);
+                if (pproc->outcnt + nread > bufsize) {
+                        bufsize += nread + 512;
+                        pproc->outp = realloc(pproc->outp, bufsize);
+                        if (pproc->outp == NULL) {
+                                pproc->outcnt = 0;
+                                _endthreadex(0);
+                        }
+                }
+                pproc->outp[pproc->outcnt++] = c;
+        }
+        return 0;
+}
+
+static DWORD
+proc_stderr_thread(sub_process *pproc)
+{
+        DWORD bufsize = 1024;
+        char c;
+        DWORD nread;
+        pproc->errp = malloc(bufsize);
+        if (pproc->errp == NULL)
+                _endthreadex(0);
+        pproc->errcnt = 0;
+
+        for (;;) {
+                if (ReadFile( (HANDLE)pproc->sv_stderr[0], &c, 1, &nread, NULL) == FALSE) {
+                        map_windows32_error_to_string(GetLastError());
+                        _endthreadex(0);
+                }
+                if (nread == 0)
+                        _endthreadex(0);
+                if (pproc->errcnt + nread > bufsize) {
+                        bufsize += nread + 512;
+                        pproc->errp = realloc(pproc->errp, bufsize);
+                        if (pproc->errp == NULL) {
+                                pproc->errcnt = 0;
+                                _endthreadex(0);
+                        }
+                }
+                pproc->errp[pproc->errcnt++] = c;
+        }
+        return 0;
+}
+
+
+/*
+ * Purpose: collects output from child process and returns results
+ *
+ * Description:
+ *
+ * Returns:
+ *
+ * Notes/Dependencies:
+ */
+        long
+process_pipe_io(
+        HANDLE proc,
+        char *stdin_data,
+        int stdin_data_len)
+{
+        sub_process *pproc = (sub_process *)proc;
+        bool_t stdin_eof = FALSE, stdout_eof = FALSE, stderr_eof = FALSE;
+        HANDLE childhand = (HANDLE) pproc->pid;
+        HANDLE tStdin = NULL, tStdout = NULL, tStderr = NULL;
+        unsigned int dwStdin, dwStdout, dwStderr;
+        HANDLE wait_list[4];
+        DWORD wait_count;
+        DWORD wait_return;
+        HANDLE ready_hand;
+        bool_t child_dead = FALSE;
+        BOOL GetExitCodeResult;
+
+        /*
+         *  Create stdin thread, if needed
+         */
+        pproc->inp = stdin_data;
+        pproc->incnt = stdin_data_len;
+        if (!pproc->inp) {
+                stdin_eof = TRUE;
+                CloseHandle((HANDLE)pproc->sv_stdin[0]);
+                pproc->sv_stdin[0] = 0;
+        } else {
+                tStdin = (HANDLE) _beginthreadex( 0, 1024,
+                        (unsigned (__stdcall *) (void *))proc_stdin_thread,
+                                                  pproc, 0, &dwStdin);
+                if (tStdin == 0) {
+                        pproc->last_err = GetLastError();
+                        pproc->lerrno = E_SCALL;
+                        goto done;
+                }
+        }
+
+        /*
+         *   Assume child will produce stdout and stderr
+         */
+        tStdout = (HANDLE) _beginthreadex( 0, 1024,
+                (unsigned (__stdcall *) (void *))proc_stdout_thread, pproc, 0,
+                &dwStdout);
+        tStderr = (HANDLE) _beginthreadex( 0, 1024,
+                (unsigned (__stdcall *) (void *))proc_stderr_thread, pproc, 0,
+                &dwStderr);
+
+        if (tStdout == 0 || tStderr == 0) {
+
+                pproc->last_err = GetLastError();
+                pproc->lerrno = E_SCALL;
+                goto done;
+        }
+
+
+        /*
+         *  Wait for all I/O to finish and for the child process to exit
+         */
+
+        while (!stdin_eof || !stdout_eof || !stderr_eof || !child_dead) {
+                wait_count = 0;
+                if (!stdin_eof) {
+                        wait_list[wait_count++] = tStdin;
+                }
+                if (!stdout_eof) {
+                        wait_list[wait_count++] = tStdout;
+                }
+                if (!stderr_eof) {
+                        wait_list[wait_count++] = tStderr;
+                }
+                if (!child_dead) {
+                        wait_list[wait_count++] = childhand;
+                }
+
+                wait_return = WaitForMultipleObjects(wait_count, wait_list,
+                         FALSE, /* don't wait for all: one ready will do */
+                         child_dead? 1000 :INFINITE); /* after the child dies, subthreads have
+                                one second to collect all remaining output */
+
+                if (wait_return == WAIT_FAILED) {
+/*                      map_windows32_error_to_string(GetLastError());*/
+                        pproc->last_err = GetLastError();
+                        pproc->lerrno = E_SCALL;
+                        goto done;
+                }
+
+                ready_hand = wait_list[wait_return - WAIT_OBJECT_0];
+
+                if (ready_hand == tStdin) {
+                        CloseHandle((HANDLE)pproc->sv_stdin[0]);
+                        pproc->sv_stdin[0] = 0;
+                        CloseHandle(tStdin);
+                        tStdin = 0;
+                        stdin_eof = TRUE;
+
+                } else if (ready_hand == tStdout) {
+
+                        CloseHandle((HANDLE)pproc->sv_stdout[0]);
+                        pproc->sv_stdout[0] = 0;
+                        CloseHandle(tStdout);
+                        tStdout = 0;
+                        stdout_eof = TRUE;
+
+                } else if (ready_hand == tStderr) {
+
+                        CloseHandle((HANDLE)pproc->sv_stderr[0]);
+                        pproc->sv_stderr[0] = 0;
+                        CloseHandle(tStderr);
+                        tStderr = 0;
+                        stderr_eof = TRUE;
+
+                } else if (ready_hand == childhand) {
+
+                        DWORD ierr;
+                        GetExitCodeResult = GetExitCodeProcess(childhand, &ierr);
+                        if (ierr == CONTROL_C_EXIT) {
+                                pproc->signal = SIGINT;
+                        } else {
+                                pproc->exit_code = ierr;
+                        }
+                        if (GetExitCodeResult == FALSE) {
+                                pproc->last_err = GetLastError();
+                                pproc->lerrno = E_SCALL;
+                                goto done;
+                        }
+                        child_dead = TRUE;
+
+                } else {
+
+                        /* ?? Got back a handle we didn't query ?? */
+                        pproc->last_err = 0;
+                        pproc->lerrno = E_FAIL;
+                        goto done;
+                }
+        }
+
+ done:
+        if (tStdin != 0)
+                CloseHandle(tStdin);
+        if (tStdout != 0)
+                CloseHandle(tStdout);
+        if (tStderr != 0)
+                CloseHandle(tStderr);
+
+        if (pproc->lerrno)
+                return(-1);
+        else
+                return(0);
+
+}
+#endif  /* unused */
+
+/*
+ * Purpose: collects output from child process and returns results
+ *
+ * Description:
+ *
+ * Returns:
+ *
+ * Notes/Dependencies:
+ */
+        long
+process_file_io(
+        HANDLE proc)
+{
+        sub_process *pproc;
+        HANDLE childhand;
+        DWORD wait_return;
+        BOOL GetExitCodeResult;
+        DWORD ierr;
+
+        if (proc == NULL)
+                pproc = process_wait_for_any_private(1, 0);
+        else
+                pproc = (sub_process *)proc;
+
+        /* some sort of internal error */
+        if (!pproc)
+                return -1;
+
+        childhand = (HANDLE) pproc->pid;
+
+        /*
+         * This function is poorly named, and could also be used just to wait
+         * for child death if you're doing your own pipe I/O.  If that is
+         * the case, close the pipe handles here.
+         */
+        if (pproc->sv_stdin[0]) {
+                CloseHandle((HANDLE)pproc->sv_stdin[0]);
+                pproc->sv_stdin[0] = 0;
+        }
+        if (pproc->sv_stdout[0]) {
+                CloseHandle((HANDLE)pproc->sv_stdout[0]);
+                pproc->sv_stdout[0] = 0;
+        }
+        if (pproc->sv_stderr[0]) {
+                CloseHandle((HANDLE)pproc->sv_stderr[0]);
+                pproc->sv_stderr[0] = 0;
+        }
+
+        /*
+         *  Wait for the child process to exit
+         */
+
+        wait_return = WaitForSingleObject(childhand, INFINITE);
+
+        if (wait_return != WAIT_OBJECT_0) {
+/*              map_windows32_error_to_string(GetLastError());*/
+                pproc->last_err = GetLastError();
+                pproc->lerrno = E_SCALL;
+                goto done2;
+        }
+
+        GetExitCodeResult = GetExitCodeProcess(childhand, &ierr);
+        if (ierr == CONTROL_C_EXIT) {
+                pproc->signal = SIGINT;
+        } else {
+                pproc->exit_code = ierr;
+        }
+        if (GetExitCodeResult == FALSE) {
+                pproc->last_err = GetLastError();
+                pproc->lerrno = E_SCALL;
+        }
+
+done2:
+        if (pproc->lerrno)
+                return(-1);
+        else
+                return(0);
+
+}
+
+/*
+ * Description:  Clean up any leftover handles, etc.  It is up to the
+ * caller to manage and free the input, output, and stderr buffers.
+ */
+        void
+process_cleanup(
+        HANDLE proc)
+{
+        sub_process *pproc = (sub_process *)proc;
+        int i;
+
+        if (pproc->using_pipes) {
+                for (i= 0; i <= 1; i++) {
+                        if ((HANDLE)pproc->sv_stdin[i]
+                            && (HANDLE)pproc->sv_stdin[i] != INVALID_HANDLE_VALUE)
+                                CloseHandle((HANDLE)pproc->sv_stdin[i]);
+                        if ((HANDLE)pproc->sv_stdout[i]
+                            && (HANDLE)pproc->sv_stdout[i] != INVALID_HANDLE_VALUE)
+                                CloseHandle((HANDLE)pproc->sv_stdout[i]);
+                        if ((HANDLE)pproc->sv_stderr[i]
+                            && (HANDLE)pproc->sv_stderr[i] != INVALID_HANDLE_VALUE)
+                                CloseHandle((HANDLE)pproc->sv_stderr[i]);
+                }
+        }
+        if ((HANDLE)pproc->pid)
+                CloseHandle((HANDLE)pproc->pid);
+
+        free(pproc);
+}
+
+
+/*
+ * Description:
+ *       Create a command line buffer to pass to CreateProcess
+ *
+ * Returns:  the buffer or NULL for failure
+ *      Shell case:  sh_name a:/full/path/to/script argv[1] argv[2] ...
+ *      Otherwise:   argv[0] argv[1] argv[2] ...
+ *
+ * Notes/Dependencies:
+ *   CreateProcess does not take an argv, so this command creates a
+ *   command line for the executable.
+ */
+
+static char *
+make_command_line( char *shell_name, char *full_exec_path, char **argv)
+{
+        int             argc = 0;
+        char**          argvi;
+        int*            enclose_in_quotes = NULL;
+        int*            enclose_in_quotes_i;
+        unsigned int    bytes_required = 0;
+        char*           command_line;
+        char*           command_line_i;
+        int have_sh = 0; /* HAVE_CYGWIN_SHELL */
+        int cygwin_mode = 0; /* HAVE_CYGWIN_SHELL */
+
+#ifdef HAVE_CYGWIN_SHELL
+        cygwin_mode = 1;
+#endif
+
+        if (shell_name && full_exec_path) {
+                have_sh = cygwin_mode && strstr(full_exec_path, "sh.exe");
+                bytes_required
+                  = strlen(shell_name) + 1 + strlen(full_exec_path);
+                /*
+                 * Skip argv[0] if any, when shell_name is given.
+                 * The special case of "-c" in full_exec_path means
+                 * argv[0] is not the shell name, but the command string
+                 * to pass to the shell.
+                 */
+                if (*argv && strcmp(full_exec_path, "-c")) argv++;
+                /*
+                 * Add one for the intervening space.
+                 */
+                if (*argv) bytes_required++;
+        }
+
+        argvi = argv;
+        while (*(argvi++)) argc++;
+
+        if (argc) {
+                enclose_in_quotes = (int*) calloc(1, argc * sizeof(int));
+
+                if (!enclose_in_quotes) {
+                        return NULL;
+                }
+        }
+
+        /* We have to make one pass through each argv[i] to see if we need
+         * to enclose it in ", so we might as well figure out how much
+         * memory we'll need on the same pass.
+         */
+
+        argvi = argv;
+        enclose_in_quotes_i = enclose_in_quotes;
+        while(*argvi) {
+                char* p = *argvi;
+                unsigned int backslash_count = 0;
+
+                /*
+                 * We have to enclose empty arguments in ".
+                 */
+                if (!(*p)) *enclose_in_quotes_i = 1;
+
+                while(*p) {
+                        switch (*p) {
+                        case '\"':
+                                /*
+                                 * We have to insert a backslash for each "
+                                 * and each \ that precedes the ".
+                                 */
+                                bytes_required += (backslash_count + 1);
+                                backslash_count = 0;
+                                break;
+
+#if !defined(HAVE_MKS_SHELL) && !defined(HAVE_CYGWIN_SHELL)
+                        case '\\':
+                                backslash_count++;
+                                break;
+#endif
+        /*
+         * At one time we set *enclose_in_quotes_i for '*' or '?' to suppress
+         * wildcard expansion in programs linked with MSVC's SETARGV.OBJ so
+         * that argv in always equals argv out. This was removed.  Say you have
+         * such a program named glob.exe.  You enter
+         * glob '*'
+         * at the sh command prompt.  Obviously the intent is to make glob do the
+         * wildcarding instead of sh.  If we set *enclose_in_quotes_i for '*' or '?',
+         * then the command line that glob would see would be
+         * glob "*"
+         * and the _setargv in SETARGV.OBJ would _not_ expand the *.
+         */
+                        case ' ':
+                        case '\t':
+                                *enclose_in_quotes_i = 1;
+                                /* fall through */
+
+                        default:
+                                backslash_count = 0;
+                                break;
+                        }
+
+                        /*
+                         * Add one for each character in argv[i].
+                         */
+                        bytes_required++;
+
+                        p++;
+                }
+
+                if (*enclose_in_quotes_i) {
+                        /*
+                         * Add one for each enclosing ",
+                         * and one for each \ that precedes the
+                         * closing ".
+                         */
+                        bytes_required += (backslash_count + 2);
+                }
+
+                /*
+                 * Add one for the intervening space.
+                 */
+                if (*(++argvi)) bytes_required++;
+                enclose_in_quotes_i++;
+        }
+
+        /*
+         * Add one for the terminating NULL.
+         */
+        bytes_required++;
+
+        command_line = (char*) malloc(bytes_required);
+
+        if (!command_line) {
+                free(enclose_in_quotes);
+                return NULL;
+        }
+
+        command_line_i = command_line;
+
+        if (shell_name && full_exec_path) {
+                while(*shell_name) {
+                        *(command_line_i++) = *(shell_name++);
+                }
+
+                *(command_line_i++) = ' ';
+
+                while(*full_exec_path) {
+                        *(command_line_i++) = *(full_exec_path++);
+                }
+
+                if (*argv) {
+                        *(command_line_i++) = ' ';
+                }
+        }
+
+        argvi = argv;
+        enclose_in_quotes_i = enclose_in_quotes;
+
+        while(*argvi) {
+                char* p = *argvi;
+                unsigned int backslash_count = 0;
+
+                if (*enclose_in_quotes_i) {
+                        *(command_line_i++) = '\"';
+                }
+
+                while(*p) {
+                        if (*p == '\"') {
+                                if (cygwin_mode && have_sh) { /* HAVE_CYGWIN_SHELL */
+                                        /* instead of a \", cygwin likes "" */
+                                        *(command_line_i++) = '\"';
+                                } else {
+
+                                /*
+                                 * We have to insert a backslash for the "
+                                 * and each \ that precedes the ".
+                                 */
+                                backslash_count++;
+
+                                while(backslash_count) {
+                                        *(command_line_i++) = '\\';
+                                        backslash_count--;
+                                };
+                                }
+#if !defined(HAVE_MKS_SHELL) && !defined(HAVE_CYGWIN_SHELL)
+                        } else if (*p == '\\') {
+                                backslash_count++;
+                        } else {
+                                backslash_count = 0;
+#endif
+                        }
+
+                        /*
+                         * Copy the character.
+                         */
+                        *(command_line_i++) = *(p++);
+                }
+
+                if (*enclose_in_quotes_i) {
+#if !defined(HAVE_MKS_SHELL) && !defined(HAVE_CYGWIN_SHELL)
+                        /*
+                         * Add one \ for each \ that precedes the
+                         * closing ".
+                         */
+                        while(backslash_count--) {
+                                *(command_line_i++) = '\\';
+                        };
+#endif
+                        *(command_line_i++) = '\"';
+                }
+
+                /*
+                 * Append an intervening space.
+                 */
+                if (*(++argvi)) {
+                        *(command_line_i++) = ' ';
+                }
+
+                enclose_in_quotes_i++;
+        }
+
+        /*
+         * Append the terminating NULL.
+         */
+        *command_line_i = '\0';
+
+        free(enclose_in_quotes);
+        return command_line;
+}
+
+/*
+ * Description: Given an argv and optional envp, launch the process
+ *              using the default stdin, stdout, and stderr handles.
+ *              Also, register process so that process_wait_for_any_private()
+ *              can be used via process_file_io(NULL) or
+ *              process_wait_for_any().
+ *
+ * Returns:
+ *
+ * Notes/Dependencies:
+ */
+HANDLE
+process_easy(
+        char **argv,
+        char **envp,
+        int outfd,
+        int errfd)
+{
+  HANDLE hIn = INVALID_HANDLE_VALUE;
+  HANDLE hOut = INVALID_HANDLE_VALUE;
+  HANDLE hErr = INVALID_HANDLE_VALUE;
+  HANDLE hProcess, tmpIn, tmpOut, tmpErr;
+  DWORD e;
+
+  if (process_table_full()) {
+        DB (DB_JOBS, ("process_easy: All process slots used up\n"));
+        return INVALID_HANDLE_VALUE;
+  }
+  /* Standard handles returned by GetStdHandle can be NULL or
+     INVALID_HANDLE_VALUE if the parent process closed them.  If that
+     happens, we open the null device and pass its handle to
+     CreateProcess as the corresponding handle to inherit.  */
+  tmpIn = GetStdHandle(STD_INPUT_HANDLE);
+  if (DuplicateHandle(GetCurrentProcess(),
+                      tmpIn,
+                      GetCurrentProcess(),
+                      &hIn,
+                      0,
+                      TRUE,
+                      DUPLICATE_SAME_ACCESS) == FALSE) {
+    if ((e = GetLastError()) == ERROR_INVALID_HANDLE) {
+      tmpIn = CreateFile("NUL", GENERIC_READ,
+                         FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
+                         OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+      if (tmpIn != INVALID_HANDLE_VALUE
+          && DuplicateHandle(GetCurrentProcess(),
+                             tmpIn,
+                             GetCurrentProcess(),
+                             &hIn,
+                             0,
+                             TRUE,
+                             DUPLICATE_SAME_ACCESS) == FALSE)
+        CloseHandle(tmpIn);
+    }
+    if (hIn == INVALID_HANDLE_VALUE) {
+      fprintf(stderr, "process_easy: DuplicateHandle(In) failed (e=%ld)\n", e);
+      return INVALID_HANDLE_VALUE;
+    }
+  }
+  if (outfd >= 0)
+    tmpOut = (HANDLE)_get_osfhandle (outfd);
+  else
+    tmpOut = GetStdHandle (STD_OUTPUT_HANDLE);
+  if (DuplicateHandle(GetCurrentProcess(),
+                      tmpOut,
+                      GetCurrentProcess(),
+                      &hOut,
+                      0,
+                      TRUE,
+                      DUPLICATE_SAME_ACCESS) == FALSE) {
+    if ((e = GetLastError()) == ERROR_INVALID_HANDLE) {
+      tmpOut = CreateFile("NUL", GENERIC_WRITE,
+                          FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
+                          OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+      if (tmpOut != INVALID_HANDLE_VALUE
+          && DuplicateHandle(GetCurrentProcess(),
+                             tmpOut,
+                             GetCurrentProcess(),
+                             &hOut,
+                             0,
+                             TRUE,
+                             DUPLICATE_SAME_ACCESS) == FALSE)
+        CloseHandle(tmpOut);
+    }
+    if (hOut == INVALID_HANDLE_VALUE) {
+      fprintf(stderr, "process_easy: DuplicateHandle(Out) failed (e=%ld)\n", e);
+      return INVALID_HANDLE_VALUE;
+    }
+  }
+  if (errfd >= 0)
+    tmpErr = (HANDLE)_get_osfhandle (errfd);
+  else
+    tmpErr = GetStdHandle(STD_ERROR_HANDLE);
+  if (DuplicateHandle(GetCurrentProcess(),
+                      tmpErr,
+                      GetCurrentProcess(),
+                      &hErr,
+                      0,
+                      TRUE,
+                      DUPLICATE_SAME_ACCESS) == FALSE) {
+    if ((e = GetLastError()) == ERROR_INVALID_HANDLE) {
+      tmpErr = CreateFile("NUL", GENERIC_WRITE,
+                          FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
+                          OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+      if (tmpErr != INVALID_HANDLE_VALUE
+          && DuplicateHandle(GetCurrentProcess(),
+                             tmpErr,
+                             GetCurrentProcess(),
+                             &hErr,
+                             0,
+                             TRUE,
+                             DUPLICATE_SAME_ACCESS) == FALSE)
+        CloseHandle(tmpErr);
+    }
+    if (hErr == INVALID_HANDLE_VALUE) {
+      fprintf(stderr, "process_easy: DuplicateHandle(Err) failed (e=%ld)\n", e);
+      return INVALID_HANDLE_VALUE;
+    }
+  }
+
+  hProcess = process_init_fd(hIn, hOut, hErr);
+
+  if (process_begin(hProcess, argv, envp, argv[0], NULL)) {
+    fake_exits_pending++;
+    /* process_begin() failed: make a note of that.  */
+    if (!((sub_process*) hProcess)->last_err)
+      ((sub_process*) hProcess)->last_err = -1;
+    ((sub_process*) hProcess)->exit_code = process_last_err(hProcess);
+
+    /* close up unused handles */
+    if (hIn != INVALID_HANDLE_VALUE)
+      CloseHandle(hIn);
+    if (hOut != INVALID_HANDLE_VALUE)
+      CloseHandle(hOut);
+    if (hErr != INVALID_HANDLE_VALUE)
+      CloseHandle(hErr);
+  }
+
+  process_register(hProcess);
+
+  return hProcess;
+}
diff --git a/src/w32/subproc/w32err.c b/src/w32/subproc/w32err.c
new file mode 100644
index 0000000..16537d2
--- /dev/null
+++ b/src/w32/subproc/w32err.c
@@ -0,0 +1,85 @@
+/* Error handling for Windows
+Copyright (C) 1996-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <stdlib.h>
+#include <windows.h>
+#include "makeint.h"
+#include "w32err.h"
+
+/*
+ * Description: the windows32 version of perror()
+ *
+ * Returns:  a pointer to a static error
+ *
+ * Notes/Dependencies:  I got this from
+ *      comp.os.ms-windows.programmer.win32
+ */
+const char *
+map_windows32_error_to_string (DWORD ercode) {
+/*
+ * We used to have an MSVC-specific '__declspec (thread)' qualifier
+ * here, with the following comment:
+ *
+ * __declspec (thread) necessary if you will use multiple threads on MSVC
+ *
+ * However, Make was never multithreaded on Windows (except when
+ * Ctrl-C is hit, in which case the main thread is stopped
+ * immediately, so it doesn't matter in this context).  The functions
+ * on sub_proc.c that started and stopped additional threads were
+ * never used, and are now #ifdef'ed away.  Until we need more than
+ * one thread, we have no problems with the following buffer being
+ * static.  (If and when we do need it to be in thread-local storage,
+ * the corresponding GCC qualifier is '__thread'.)
+ */
+    static char szMessageBuffer[128];
+        /* Fill message buffer with a default message in
+         * case FormatMessage fails
+         */
+    wsprintf (szMessageBuffer, "Error %ld\n", ercode);
+
+        /*
+         *  Special code for winsock error handling.
+         */
+        if (ercode > WSABASEERR) {
+#if 0
+                HMODULE hModule = GetModuleHandle("wsock32");
+                if (hModule != NULL) {
+                        FormatMessage(FORMAT_MESSAGE_FROM_HMODULE,
+                                hModule,
+                                ercode,
+                                LANG_NEUTRAL,
+                                szMessageBuffer,
+                                sizeof(szMessageBuffer),
+                                NULL);
+                        FreeLibrary(hModule);
+                }
+#else
+                O (fatal, NILF, szMessageBuffer);
+#endif
+        } else {
+                /*
+                 *  Default system message handling
+                 */
+                FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
+                        NULL,
+                        ercode,
+                        LANG_NEUTRAL,
+                        szMessageBuffer,
+                        sizeof(szMessageBuffer),
+                        NULL);
+        }
+    return szMessageBuffer;
+}
diff --git a/src/w32/w32os.c b/src/w32/w32os.c
new file mode 100644
index 0000000..0023e79
--- /dev/null
+++ b/src/w32/w32os.c
@@ -0,0 +1,218 @@
+/* Windows32-based operating system interface for GNU Make.
+Copyright (C) 2016-2017 Free Software Foundation, Inc.
+This file is part of GNU Make.
+
+GNU Make is free software; you can redistribute it and/or modify it under the
+terms of the GNU General Public License as published by the Free Software
+Foundation; either version 3 of the License, or (at your option) any later
+version.
+
+GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
+A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along with
+this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include "makeint.h"
+
+#include <stdio.h>
+#include <string.h>
+
+#include <windows.h>
+#include <process.h>
+#include <io.h>
+#include "pathstuff.h"
+#include "sub_proc.h"
+#include "w32err.h"
+#include "os.h"
+#include "debug.h"
+
+/* This section provides OS-specific functions to support the jobserver.  */
+
+static char jobserver_semaphore_name[MAX_PATH + 1];
+static HANDLE jobserver_semaphore = NULL;
+
+unsigned int
+jobserver_setup (int slots)
+{
+  /* sub_proc.c is limited in the number of objects it can wait for. */
+
+  if (slots > process_table_usable_size())
+    {
+      slots = process_table_usable_size();
+      DB (DB_JOBS, (_("Jobserver slots limited to %d\n"), slots));
+    }
+
+  sprintf (jobserver_semaphore_name, "gmake_semaphore_%d", _getpid ());
+
+  jobserver_semaphore = CreateSemaphore (
+      NULL,                           /* Use default security descriptor */
+      slots,                          /* Initial count */
+      slots,                          /* Maximum count */
+      jobserver_semaphore_name);      /* Semaphore name */
+
+  if (jobserver_semaphore == NULL)
+    {
+      DWORD err = GetLastError ();
+      const char *estr = map_windows32_error_to_string (err);
+      ONS (fatal, NILF,
+           _("creating jobserver semaphore: (Error %ld: %s)"), err, estr);
+    }
+
+  return 1;
+}
+
+unsigned int
+jobserver_parse_auth (const char *auth)
+{
+  jobserver_semaphore = OpenSemaphore (
+      SEMAPHORE_ALL_ACCESS,   /* Semaphore access setting */
+      FALSE,                  /* Child processes DON'T inherit */
+      auth);                  /* Semaphore name */
+
+  if (jobserver_semaphore == NULL)
+    {
+      DWORD err = GetLastError ();
+      const char *estr = map_windows32_error_to_string (err);
+      fatal (NILF, strlen (auth) + INTSTR_LENGTH + strlen (estr),
+             _("internal error: unable to open jobserver semaphore '%s': (Error %ld: %s)"),
+             auth, err, estr);
+    }
+  DB (DB_JOBS, (_("Jobserver client (semaphore %s)\n"), auth));
+
+  return 1;
+}
+
+char *
+jobserver_get_auth ()
+{
+  return xstrdup (jobserver_semaphore_name);
+}
+
+unsigned int
+jobserver_enabled ()
+{
+  return jobserver_semaphore != NULL;
+}
+
+/* Close jobserver semaphore */
+void
+jobserver_clear ()
+{
+  if (jobserver_semaphore != NULL)
+    {
+      CloseHandle (jobserver_semaphore);
+      jobserver_semaphore = NULL;
+    }
+}
+
+void
+jobserver_release (int is_fatal)
+{
+  if (! ReleaseSemaphore (
+          jobserver_semaphore,    /* handle to semaphore */
+          1,                      /* increase count by one */
+          NULL))                  /* not interested in previous count */
+    {
+      if (is_fatal)
+        {
+          DWORD err = GetLastError ();
+          const char *estr = map_windows32_error_to_string (err);
+          ONS (fatal, NILF,
+               _("release jobserver semaphore: (Error %ld: %s)"), err, estr);
+        }
+      perror_with_name ("release_jobserver_semaphore", "");
+    }
+}
+
+unsigned int
+jobserver_acquire_all ()
+{
+  unsigned int tokens = 0;
+  while (1)
+    {
+      DWORD dwEvent = WaitForSingleObject (
+          jobserver_semaphore,    /* Handle to semaphore */
+          0);                     /* DON'T wait on semaphore */
+
+      if (dwEvent != WAIT_OBJECT_0)
+        return tokens;
+
+      ++tokens;
+    }
+}
+
+void
+jobserver_signal ()
+{
+}
+
+void jobserver_pre_child (int recursive)
+{
+}
+
+void jobserver_post_child (int recursive)
+{
+}
+
+void
+jobserver_pre_acquire ()
+{
+}
+
+/* Returns 1 if we got a token, or 0 if a child has completed.
+   The Windows implementation doesn't support load detection.  */
+unsigned int
+jobserver_acquire (int timeout)
+{
+    HANDLE *handles;
+    DWORD dwHandleCount;
+    DWORD dwEvent;
+
+    handles = xmalloc(process_table_actual_size() * sizeof(HANDLE));
+
+    /* Add jobserver semaphore to first slot. */
+    handles[0] = jobserver_semaphore;
+
+    /* Build array of handles to wait for.  */
+    dwHandleCount = 1 + process_set_handles (&handles[1]);
+
+    dwEvent = process_wait_for_multiple_objects (
+        dwHandleCount,  /* number of objects in array */
+        handles,        /* array of objects */
+        FALSE,          /* wait for any object */
+        INFINITE);      /* wait until object is signalled */
+
+    free(handles);
+
+    if (dwEvent == WAIT_FAILED)
+      {
+        DWORD err = GetLastError ();
+        const char *estr = map_windows32_error_to_string (err);
+        ONS (fatal, NILF,
+             _("semaphore or child process wait: (Error %ld: %s)"),
+             err, estr);
+      }
+
+    /* WAIT_OBJECT_0 indicates that the semaphore was signalled.  */
+    return dwEvent == WAIT_OBJECT_0;
+}
+
+void
+fd_inherit(int fd)
+{
+  HANDLE fh = (HANDLE)_get_osfhandle(fd);
+
+  if (fh && fh != INVALID_HANDLE_VALUE)
+        SetHandleInformation(fh, HANDLE_FLAG_INHERIT, 1);
+}
+
+void
+fd_noinherit(int fd)
+{
+  HANDLE fh = (HANDLE)_get_osfhandle(fd);
+
+  if (fh && fh != INVALID_HANDLE_VALUE)
+        SetHandleInformation(fh, HANDLE_FLAG_INHERIT, 0);
+}
diff --git a/strcache.c b/strcache.c
deleted file mode 100644
index 19f43c9..0000000
--- a/strcache.c
+++ /dev/null
@@ -1,330 +0,0 @@
-/* Constant string caching for GNU Make.
-Copyright (C) 2006-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-
-#include <stddef.h>
-#include <assert.h>
-
-#include "hash.h"
-
-/* A string cached here will never be freed, so we don't need to worry about
-   reference counting.  We just store the string, and then remember it in a
-   hash so it can be looked up again. */
-
-typedef unsigned short int sc_buflen_t;
-
-struct strcache {
-  struct strcache *next;    /* The next block of strings.  Must be first!  */
-  sc_buflen_t end;          /* Offset to the beginning of free space.  */
-  sc_buflen_t bytesfree;    /* Free space left in this buffer.  */
-  sc_buflen_t count;        /* # of strings in this buffer (for stats).  */
-  char buffer[1];           /* The buffer comes after this.  */
-};
-
-/* The size (in bytes) of each cache buffer.
-   Try to pick something that will map well into the heap.
-   This must be able to be represented by a short int (<=65535).  */
-#define CACHE_BUFFER_BASE       (8192)
-#define CACHE_BUFFER_ALLOC(_s)  ((_s) - (2 * sizeof (size_t)))
-#define CACHE_BUFFER_OFFSET     (offsetof (struct strcache, buffer))
-#define CACHE_BUFFER_SIZE(_s)   (CACHE_BUFFER_ALLOC(_s) - CACHE_BUFFER_OFFSET)
-#define BUFSIZE                 CACHE_BUFFER_SIZE (CACHE_BUFFER_BASE)
-
-static struct strcache *strcache = NULL;
-static struct strcache *fullcache = NULL;
-
-static unsigned long total_buffers = 0;
-static unsigned long total_strings = 0;
-static unsigned long total_size = 0;
-
-/* Add a new buffer to the cache.  Add it at the front to reduce search time.
-   This can also increase the overhead, since it's less likely that older
-   buffers will be filled in.  However, GNU make has so many smaller strings
-   that this doesn't seem to be much of an issue in practice.
- */
-static struct strcache *
-new_cache (struct strcache **head, sc_buflen_t buflen)
-{
-  struct strcache *new = xmalloc (buflen + CACHE_BUFFER_OFFSET);
-  new->end = 0;
-  new->count = 0;
-  new->bytesfree = buflen;
-
-  new->next = *head;
-  *head = new;
-
-  ++total_buffers;
-  return new;
-}
-
-static const char *
-copy_string (struct strcache *sp, const char *str, unsigned int len)
-{
-  /* Add the string to this cache.  */
-  char *res = &sp->buffer[sp->end];
-
-  memmove (res, str, len);
-  res[len++] = '\0';
-  sp->end += len;
-  sp->bytesfree -= len;
-  ++sp->count;
-
-  return res;
-}
-
-static const char *
-add_string (const char *str, unsigned int len)
-{
-  const char *res;
-  struct strcache *sp;
-  struct strcache **spp = &strcache;
-  /* We need space for the nul char.  */
-  unsigned int sz = len + 1;
-
-  ++total_strings;
-  total_size += sz;
-
-  /* If the string we want is too large to fit into a single buffer, then
-     no existing cache is large enough.  Add it directly to the fullcache.  */
-  if (sz > BUFSIZE)
-    {
-      sp = new_cache (&fullcache, sz);
-      return copy_string (sp, str, len);
-    }
-
-  /* Find the first cache with enough free space.  */
-  for (; *spp != NULL; spp = &(*spp)->next)
-    if ((*spp)->bytesfree > sz)
-      break;
-  sp = *spp;
-
-  /* If nothing is big enough, make a new cache at the front.  */
-  if (sp == NULL)
-    {
-      sp = new_cache (&strcache, BUFSIZE);
-      spp = &strcache;
-    }
-
-  /* Add the string to this cache.  */
-  res = copy_string (sp, str, len);
-
-  /* If the amount free in this cache is less than the average string size,
-     consider it full and move it to the full list.  */
-  if (total_strings > 20 && sp->bytesfree < (total_size / total_strings) + 1)
-    {
-      *spp = sp->next;
-      sp->next = fullcache;
-      fullcache = sp;
-    }
-
-  return res;
-}
-
-/* For strings too large for the strcache, we just save them in a list.  */
-struct hugestring {
-  struct hugestring *next;  /* The next string.  */
-  char buffer[1];           /* The string.  */
-};
-
-static struct hugestring *hugestrings = NULL;
-
-static const char *
-add_hugestring (const char *str, unsigned int len)
-{
-  struct hugestring *new = xmalloc (sizeof (struct hugestring) + len);
-  memcpy (new->buffer, str, len);
-  new->buffer[len] = '\0';
-
-  new->next = hugestrings;
-  hugestrings = new;
-
-  return new->buffer;
-}
-
-/* Hash table of strings in the cache.  */
-
-static unsigned long
-str_hash_1 (const void *key)
-{
-  return_ISTRING_HASH_1 ((const char *) key);
-}
-
-static unsigned long
-str_hash_2 (const void *key)
-{
-  return_ISTRING_HASH_2 ((const char *) key);
-}
-
-static int
-str_hash_cmp (const void *x, const void *y)
-{
-  return_ISTRING_COMPARE ((const char *) x, (const char *) y);
-}
-
-static struct hash_table strings;
-static unsigned long total_adds = 0;
-
-static const char *
-add_hash (const char *str, unsigned int len)
-{
-  char *const *slot;
-  const char *key;
-
-  /* If it's too large for the string cache, just copy it.
-     We don't bother trying to match these.  */
-  if (len > USHRT_MAX - 1)
-    return add_hugestring (str, len);
-
-  /* Look up the string in the hash.  If it's there, return it.  */
-  slot = (char *const *) hash_find_slot (&strings, str);
-  key = *slot;
-
-  /* Count the total number of add operations we performed.  */
-  ++total_adds;
-
-  if (!HASH_VACANT (key))
-    return key;
-
-  /* Not there yet so add it to a buffer, then into the hash table.  */
-  key = add_string (str, len);
-  hash_insert_at (&strings, key, slot);
-  return key;
-}
-
-/* Returns true if the string is in the cache; false if not.  */
-int
-strcache_iscached (const char *str)
-{
-  struct strcache *sp;
-
-  for (sp = strcache; sp != 0; sp = sp->next)
-    if (str >= sp->buffer && str < sp->buffer + sp->end)
-      return 1;
-  for (sp = fullcache; sp != 0; sp = sp->next)
-    if (str >= sp->buffer && str < sp->buffer + sp->end)
-      return 1;
-
-  {
-    struct hugestring *hp;
-    for (hp = hugestrings; hp != 0; hp = hp->next)
-      if (str == hp->buffer)
-        return 1;
-  }
-
-  return 0;
-}
-
-/* If the string is already in the cache, return a pointer to the cached
-   version.  If not, add it then return a pointer to the cached version.
-   Note we do NOT take control of the string passed in.  */
-const char *
-strcache_add (const char *str)
-{
-  return add_hash (str, strlen (str));
-}
-
-const char *
-strcache_add_len (const char *str, unsigned int len)
-{
-  /* If we're not given a nul-terminated string we have to create one, because
-     the hashing functions expect it.  */
-  if (str[len] != '\0')
-    {
-      char *key = alloca (len + 1);
-      memcpy (key, str, len);
-      key[len] = '\0';
-      str = key;
-    }
-
-  return add_hash (str, len);
-}
-
-void
-strcache_init (void)
-{
-  hash_init (&strings, 8000, str_hash_1, str_hash_2, str_hash_cmp);
-}
-
-
-/* Generate some stats output.  */
-
-void
-strcache_print_stats (const char *prefix)
-{
-  const struct strcache *sp;
-  unsigned long numbuffs = 0, fullbuffs = 0;
-  unsigned long totfree = 0, maxfree = 0, minfree = BUFSIZE;
-
-  if (! strcache)
-    {
-      printf (_("\n%s No strcache buffers\n"), prefix);
-      return;
-    }
-
-  /* Count the first buffer separately since it's not full.  */
-  for (sp = strcache->next; sp != NULL; sp = sp->next)
-    {
-      sc_buflen_t bf = sp->bytesfree;
-
-      totfree += bf;
-      maxfree = (bf > maxfree ? bf : maxfree);
-      minfree = (bf < minfree ? bf : minfree);
-
-      ++numbuffs;
-    }
-  for (sp = fullcache; sp != NULL; sp = sp->next)
-    {
-      sc_buflen_t bf = sp->bytesfree;
-
-      totfree += bf;
-      maxfree = (bf > maxfree ? bf : maxfree);
-      minfree = (bf < minfree ? bf : minfree);
-
-      ++numbuffs;
-      ++fullbuffs;
-    }
-
-  /* Make sure we didn't lose any buffers.  */
-  assert (total_buffers == numbuffs + 1);
-
-  printf (_("\n%s strcache buffers: %lu (%lu) / strings = %lu / storage = %lu B / avg = %lu B\n"),
-          prefix, numbuffs + 1, fullbuffs, total_strings, total_size,
-          (total_size / total_strings));
-
-  printf (_("%s current buf: size = %hu B / used = %hu B / count = %hu / avg = %hu B\n"),
-          prefix, (sc_buflen_t)BUFSIZE, strcache->end, strcache->count,
-          (strcache->end / strcache->count));
-
-  if (numbuffs)
-    {
-      /* Show information about non-current buffers.  */
-      unsigned long sz = total_size - strcache->end;
-      unsigned long cnt = total_strings - strcache->count;
-      sc_buflen_t avgfree = totfree / numbuffs;
-
-      printf (_("%s other used: total = %lu B / count = %lu / avg = %lu B\n"),
-              prefix, sz, cnt, sz / cnt);
-
-      printf (_("%s other free: total = %lu B / max = %lu B / min = %lu B / avg = %hu B\n"),
-              prefix, totfree, maxfree, minfree, avgfree);
-    }
-
-  printf (_("\n%s strcache performance: lookups = %lu / hit rate = %lu%%\n"),
-          prefix, total_adds, (long unsigned)(100.0 * (total_adds - total_strings) / total_adds));
-  fputs (_("# hash-table stats:\n# "), stdout);
-  hash_print_stats (&strings, stdout);
-}
diff --git a/tests/run_make_tests.pl b/tests/run_make_tests.pl
index de96047..cd8a643 100644
--- a/tests/run_make_tests.pl
+++ b/tests/run_make_tests.pl
@@ -96,7 +96,7 @@ sub valid_option
 
    if ($option =~ /^-srcdir$/i) {
        $srcdir = shift @argv;
-       if (! -f "$srcdir/gnumake.h") {
+       if (! -f "$srcdir/src/gnumake.h") {
            print "$option $srcdir: Not a valid GNU make source directory.\n";
            exit 0;
        }
@@ -457,7 +457,7 @@ sub set_more_defaults
    if (! $srcdir) {
        $make_path =~ /^(.*$pathsep)?/;
        my $d = $1 || '../';
-       -f "${d}gnumake.h" and $srcdir = $d;
+       -f "${d}/src/gnumake.h" and $srcdir = $d;
    }
 
    # Not with the make program, so see if we can get it out of the makefile
@@ -466,7 +466,7 @@ sub set_more_defaults
        $_ = <MF>;
        close(MF);
        /^abs_srcdir\s*=\s*(.*?)\s*$/m;
-       -f "$1/gnumake.h" and $srcdir = $1;
+       -f "$1/src/gnumake.h" and $srcdir = $1;
    }
 
    # Get Purify log info--if any.
diff --git a/tests/scripts/features/load b/tests/scripts/features/load
index dcc1cdf..56f80e2 100644
--- a/tests/scripts/features/load
+++ b/tests/scripts/features/load
@@ -46,7 +46,7 @@ close($F) or die "close: testload.c: $!\n";
 
 # Make sure we can compile
 
-my $sobuild = "$CONFIG_FLAGS{CC} ".($srcdir? "-I$srcdir":'')." $CONFIG_FLAGS{CPPFLAGS} $CONFIG_FLAGS{CFLAGS} -shared -fPIC $CONFIG_FLAGS{LDFLAGS} -o testload.so testload.c";
+my $sobuild = "$CONFIG_FLAGS{CC} ".($srcdir? "-I$srcdir/src":'')." $CONFIG_FLAGS{CPPFLAGS} $CONFIG_FLAGS{CFLAGS} -shared -fPIC $CONFIG_FLAGS{LDFLAGS} -o testload.so testload.c";
 
 my $clog = `$sobuild 2>&1`;
 if ($? != 0) {
diff --git a/tests/scripts/features/loadapi b/tests/scripts/features/loadapi
index acc3c78..c889557 100644
--- a/tests/scripts/features/loadapi
+++ b/tests/scripts/features/loadapi
@@ -80,7 +80,7 @@ close($F) or die "close: testapi.c: $!\n";
 
 # Make sure we can compile
 
-my $sobuild = "$CONFIG_FLAGS{CC} ".($srcdir? "-I$srcdir":'')." $CONFIG_FLAGS{CPPFLAGS} $CONFIG_FLAGS{CFLAGS} -shared -fPIC $CONFIG_FLAGS{LDFLAGS} -o testapi.so testapi.c";
+my $sobuild = "$CONFIG_FLAGS{CC} ".($srcdir? "-I$srcdir/src":'')." $CONFIG_FLAGS{CPPFLAGS} $CONFIG_FLAGS{CFLAGS} -shared -fPIC $CONFIG_FLAGS{LDFLAGS} -o testapi.so testapi.c";
 
 my $clog = `$sobuild 2>&1`;
 if ($? != 0) {
diff --git a/variable.c b/variable.c
deleted file mode 100644
index 2c68cea..0000000
--- a/variable.c
+++ /dev/null
@@ -1,1822 +0,0 @@
-/* Internals of variables for GNU Make.
-Copyright (C) 1988-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-
-#include <assert.h>
-
-#include "filedef.h"
-#include "dep.h"
-#include "job.h"
-#include "commands.h"
-#include "variable.h"
-#include "rule.h"
-#ifdef WINDOWS32
-#include "pathstuff.h"
-#endif
-#include "hash.h"
-
-/* Incremented every time we add or remove a global variable.  */
-static unsigned long variable_changenum;
-
-/* Chain of all pattern-specific variables.  */
-
-static struct pattern_var *pattern_vars;
-
-/* Pointer to the last struct in the pack of a specific size, from 1 to 255.*/
-
-static struct pattern_var *last_pattern_vars[256];
-
-/* Create a new pattern-specific variable struct. The new variable is
-   inserted into the PATTERN_VARS list in the shortest patterns first
-   order to support the shortest stem matching (the variables are
-   matched in the reverse order so the ones with the longest pattern
-   will be considered first). Variables with the same pattern length
-   are inserted in the definition order. */
-
-struct pattern_var *
-create_pattern_var (const char *target, const char *suffix)
-{
-  unsigned int len = strlen (target);
-  struct pattern_var *p = xcalloc (sizeof (struct pattern_var));
-
-  if (pattern_vars != 0)
-    {
-      if (len < 256 && last_pattern_vars[len] != 0)
-        {
-          p->next = last_pattern_vars[len]->next;
-          last_pattern_vars[len]->next = p;
-        }
-      else
-        {
-          /* Find the position where we can insert this variable. */
-          struct pattern_var **v;
-
-          for (v = &pattern_vars; ; v = &(*v)->next)
-            {
-              /* Insert at the end of the pack so that patterns with the
-                 same length appear in the order they were defined .*/
-
-              if (*v == 0 || (*v)->len > len)
-                {
-                  p->next = *v;
-                  *v = p;
-                  break;
-                }
-            }
-        }
-    }
-  else
-    {
-      pattern_vars = p;
-      p->next = 0;
-    }
-
-  p->target = target;
-  p->len = len;
-  p->suffix = suffix + 1;
-
-  if (len < 256)
-    last_pattern_vars[len] = p;
-
-  return p;
-}
-
-/* Look up a target in the pattern-specific variable list.  */
-
-static struct pattern_var *
-lookup_pattern_var (struct pattern_var *start, const char *target)
-{
-  struct pattern_var *p;
-  unsigned int targlen = strlen (target);
-
-  for (p = start ? start->next : pattern_vars; p != 0; p = p->next)
-    {
-      const char *stem;
-      unsigned int stemlen;
-
-      if (p->len > targlen)
-        /* It can't possibly match.  */
-        continue;
-
-      /* From the lengths of the filename and the pattern parts,
-         find the stem: the part of the filename that matches the %.  */
-      stem = target + (p->suffix - p->target - 1);
-      stemlen = targlen - p->len + 1;
-
-      /* Compare the text in the pattern before the stem, if any.  */
-      if (stem > target && !strneq (p->target, target, stem - target))
-        continue;
-
-      /* Compare the text in the pattern after the stem, if any.
-         We could test simply using streq, but this way we compare the
-         first two characters immediately.  This saves time in the very
-         common case where the first character matches because it is a
-         period.  */
-      if (*p->suffix == stem[stemlen]
-          && (*p->suffix == '\0' || streq (&p->suffix[1], &stem[stemlen+1])))
-        break;
-    }
-
-  return p;
-}
-
-/* Hash table of all global variable definitions.  */
-
-static unsigned long
-variable_hash_1 (const void *keyv)
-{
-  struct variable const *key = (struct variable const *) keyv;
-  return_STRING_N_HASH_1 (key->name, key->length);
-}
-
-static unsigned long
-variable_hash_2 (const void *keyv)
-{
-  struct variable const *key = (struct variable const *) keyv;
-  return_STRING_N_HASH_2 (key->name, key->length);
-}
-
-static int
-variable_hash_cmp (const void *xv, const void *yv)
-{
-  struct variable const *x = (struct variable const *) xv;
-  struct variable const *y = (struct variable const *) yv;
-  int result = x->length - y->length;
-  if (result)
-    return result;
-  return_STRING_N_COMPARE (x->name, y->name, x->length);
-}
-
-#ifndef VARIABLE_BUCKETS
-#define VARIABLE_BUCKETS                523
-#endif
-#ifndef PERFILE_VARIABLE_BUCKETS
-#define PERFILE_VARIABLE_BUCKETS        23
-#endif
-#ifndef SMALL_SCOPE_VARIABLE_BUCKETS
-#define SMALL_SCOPE_VARIABLE_BUCKETS    13
-#endif
-
-static struct variable_set global_variable_set;
-static struct variable_set_list global_setlist
-  = { 0, &global_variable_set, 0 };
-struct variable_set_list *current_variable_set_list = &global_setlist;
-
-/* Implement variables.  */
-
-void
-init_hash_global_variable_set (void)
-{
-  hash_init (&global_variable_set.table, VARIABLE_BUCKETS,
-             variable_hash_1, variable_hash_2, variable_hash_cmp);
-}
-
-/* Define variable named NAME with value VALUE in SET.  VALUE is copied.
-   LENGTH is the length of NAME, which does not need to be null-terminated.
-   ORIGIN specifies the origin of the variable (makefile, command line
-   or environment).
-   If RECURSIVE is nonzero a flag is set in the variable saying
-   that it should be recursively re-expanded.  */
-
-struct variable *
-define_variable_in_set (const char *name, unsigned int length,
-                        const char *value, enum variable_origin origin,
-                        int recursive, struct variable_set *set,
-                        const floc *flocp)
-{
-  struct variable *v;
-  struct variable **var_slot;
-  struct variable var_key;
-
-  if (set == NULL)
-    set = &global_variable_set;
-
-  var_key.name = (char *) name;
-  var_key.length = length;
-  var_slot = (struct variable **) hash_find_slot (&set->table, &var_key);
-  v = *var_slot;
-
-#ifdef VMS
-  /* VMS does not populate envp[] with DCL symbols and logical names which
-     historically are mapped to environent variables.
-     If the variable is not yet defined, then we need to check if getenv()
-     can find it.  Do not do this for origin == o_env to avoid infinte
-     recursion */
-  if (HASH_VACANT (v) && (origin != o_env))
-    {
-      struct variable * vms_variable;
-      char * vname = alloca (length + 1);
-      char * vvalue;
-
-      strncpy (vname, name, length);
-      vvalue = getenv(vname);
-
-      /* Values starting with '$' are probably foreign commands.
-         We want to treat them as Shell aliases and not look them up here */
-      if ((vvalue != NULL) && (vvalue[0] != '$'))
-        {
-          vms_variable =  lookup_variable(name, length);
-          /* Refresh the slot */
-          var_slot = (struct variable **) hash_find_slot (&set->table,
-                                                          &var_key);
-          v = *var_slot;
-        }
-    }
-#endif
-
-  if (env_overrides && origin == o_env)
-    origin = o_env_override;
-
-  if (! HASH_VACANT (v))
-    {
-      if (env_overrides && v->origin == o_env)
-        /* V came from in the environment.  Since it was defined
-           before the switches were parsed, it wasn't affected by -e.  */
-        v->origin = o_env_override;
-
-      /* A variable of this name is already defined.
-         If the old definition is from a stronger source
-         than this one, don't redefine it.  */
-      if ((int) origin >= (int) v->origin)
-        {
-          free (v->value);
-          v->value = xstrdup (value);
-          if (flocp != 0)
-            v->fileinfo = *flocp;
-          else
-            v->fileinfo.filenm = 0;
-          v->origin = origin;
-          v->recursive = recursive;
-        }
-      return v;
-    }
-
-  /* Create a new variable definition and add it to the hash table.  */
-
-  v = xmalloc (sizeof (struct variable));
-  v->name = xstrndup (name, length);
-  v->length = length;
-  hash_insert_at (&set->table, v, var_slot);
-  if (set == &global_variable_set)
-    ++variable_changenum;
-
-  v->value = xstrdup (value);
-  if (flocp != 0)
-    v->fileinfo = *flocp;
-  else
-    v->fileinfo.filenm = 0;
-  v->origin = origin;
-  v->recursive = recursive;
-  v->special = 0;
-  v->expanding = 0;
-  v->exp_count = 0;
-  v->per_target = 0;
-  v->append = 0;
-  v->private_var = 0;
-  v->export = v_default;
-
-  v->exportable = 1;
-  if (*name != '_' && (*name < 'A' || *name > 'Z')
-      && (*name < 'a' || *name > 'z'))
-    v->exportable = 0;
-  else
-    {
-      for (++name; *name != '\0'; ++name)
-        if (*name != '_' && (*name < 'a' || *name > 'z')
-            && (*name < 'A' || *name > 'Z') && !ISDIGIT(*name))
-          break;
-
-      if (*name != '\0')
-        v->exportable = 0;
-    }
-
-  return v;
-}
-
-
-/* Undefine variable named NAME in SET. LENGTH is the length of NAME, which
-   does not need to be null-terminated. ORIGIN specifies the origin of the
-   variable (makefile, command line or environment). */
-
-static void
-free_variable_name_and_value (const void *item)
-{
-  struct variable *v = (struct variable *) item;
-  free (v->name);
-  free (v->value);
-}
-
-void
-free_variable_set (struct variable_set_list *list)
-{
-  hash_map (&list->set->table, free_variable_name_and_value);
-  hash_free (&list->set->table, 1);
-  free (list->set);
-  free (list);
-}
-
-void
-undefine_variable_in_set (const char *name, unsigned int length,
-                          enum variable_origin origin,
-                          struct variable_set *set)
-{
-  struct variable *v;
-  struct variable **var_slot;
-  struct variable var_key;
-
-  if (set == NULL)
-    set = &global_variable_set;
-
-  var_key.name = (char *) name;
-  var_key.length = length;
-  var_slot = (struct variable **) hash_find_slot (&set->table, &var_key);
-
-  if (env_overrides && origin == o_env)
-    origin = o_env_override;
-
-  v = *var_slot;
-  if (! HASH_VACANT (v))
-    {
-      if (env_overrides && v->origin == o_env)
-        /* V came from in the environment.  Since it was defined
-           before the switches were parsed, it wasn't affected by -e.  */
-        v->origin = o_env_override;
-
-      /* Undefine only if this undefinition is from an equal or stronger
-         source than the variable definition.  */
-      if ((int) origin >= (int) v->origin)
-        {
-          hash_delete_at (&set->table, var_slot);
-          free_variable_name_and_value (v);
-          free (v);
-          if (set == &global_variable_set)
-            ++variable_changenum;
-        }
-    }
-}
-
-/* If the variable passed in is "special", handle its special nature.
-   Currently there are two such variables, both used for introspection:
-   .VARIABLES expands to a list of all the variables defined in this instance
-   of make.
-   .TARGETS expands to a list of all the targets defined in this
-   instance of make.
-   Returns the variable reference passed in.  */
-
-#define EXPANSION_INCREMENT(_l)  ((((_l) / 500) + 1) * 500)
-
-static struct variable *
-lookup_special_var (struct variable *var)
-{
-  static unsigned long last_changenum = 0;
-
-
-  /* This one actually turns out to be very hard, due to the way the parser
-     records targets.  The way it works is that target information is collected
-     internally until make knows the target is completely specified.  It unitl
-     it sees that some new construct (a new target or variable) is defined that
-     it knows the previous one is done.  In short, this means that if you do
-     this:
-
-       all:
-
-       TARGS := $(.TARGETS)
-
-     then $(TARGS) won't contain "all", because it's not until after the
-     variable is created that the previous target is completed.
-
-     Changing this would be a major pain.  I think a less complex way to do it
-     would be to pre-define the target files as soon as the first line is
-     parsed, then come back and do the rest of the definition as now.  That
-     would allow $(.TARGETS) to be correct without a major change to the way
-     the parser works.
-
-  if (streq (var->name, ".TARGETS"))
-    var->value = build_target_list (var->value);
-  else
-  */
-
-  if (variable_changenum != last_changenum && streq (var->name, ".VARIABLES"))
-    {
-      unsigned long max = EXPANSION_INCREMENT (strlen (var->value));
-      unsigned long len;
-      char *p;
-      struct variable **vp = (struct variable **) global_variable_set.table.ht_vec;
-      struct variable **end = &vp[global_variable_set.table.ht_size];
-
-      /* Make sure we have at least MAX bytes in the allocated buffer.  */
-      var->value = xrealloc (var->value, max);
-
-      /* Walk through the hash of variables, constructing a list of names.  */
-      p = var->value;
-      len = 0;
-      for (; vp < end; ++vp)
-        if (!HASH_VACANT (*vp))
-          {
-            struct variable *v = *vp;
-            int l = v->length;
-
-            len += l + 1;
-            if (len > max)
-              {
-                unsigned long off = p - var->value;
-
-                max += EXPANSION_INCREMENT (l + 1);
-                var->value = xrealloc (var->value, max);
-                p = &var->value[off];
-              }
-
-            memcpy (p, v->name, l);
-            p += l;
-            *(p++) = ' ';
-          }
-      *(p-1) = '\0';
-
-      /* Remember the current variable change number.  */
-      last_changenum = variable_changenum;
-    }
-
-  return var;
-}
-
-
-/* Lookup a variable whose name is a string starting at NAME
-   and with LENGTH chars.  NAME need not be null-terminated.
-   Returns address of the 'struct variable' containing all info
-   on the variable, or nil if no such variable is defined.  */
-
-struct variable *
-lookup_variable (const char *name, unsigned int length)
-{
-  const struct variable_set_list *setlist;
-  struct variable var_key;
-  int is_parent = 0;
-
-  var_key.name = (char *) name;
-  var_key.length = length;
-
-  for (setlist = current_variable_set_list;
-       setlist != 0; setlist = setlist->next)
-    {
-      const struct variable_set *set = setlist->set;
-      struct variable *v;
-
-      v = (struct variable *) hash_find_item ((struct hash_table *) &set->table, &var_key);
-      if (v && (!is_parent || !v->private_var))
-        return v->special ? lookup_special_var (v) : v;
-
-      is_parent |= setlist->next_is_parent;
-    }
-
-#ifdef VMS
-  /* VMS does not populate envp[] with DCL symbols and logical names which
-     historically are mapped to enviroment varables and returned by getenv() */
-  {
-    char *vname = alloca (length + 1);
-    char *value;
-    strncpy (vname, name, length);
-    vname[length] = 0;
-    value = getenv (vname);
-    if (value != 0)
-      {
-        char *sptr;
-        int scnt;
-
-        sptr = value;
-        scnt = 0;
-
-        while ((sptr = strchr (sptr, '$')))
-          {
-            scnt++;
-            sptr++;
-          }
-
-        if (scnt > 0)
-          {
-            char *nvalue;
-            char *nptr;
-
-            nvalue = alloca (strlen (value) + scnt + 1);
-            sptr = value;
-            nptr = nvalue;
-
-            while (*sptr)
-              {
-                if (*sptr == '$')
-                  {
-                    *nptr++ = '$';
-                    *nptr++ = '$';
-                  }
-                else
-                  {
-                    *nptr++ = *sptr;
-                  }
-                sptr++;
-              }
-
-            *nptr = '\0';
-            return define_variable (vname, length, nvalue, o_env, 1);
-
-          }
-
-        return define_variable (vname, length, value, o_env, 1);
-      }
-  }
-#endif /* VMS */
-
-  return 0;
-}
-
-/* Lookup a variable whose name is a string starting at NAME
-   and with LENGTH chars in set SET.  NAME need not be null-terminated.
-   Returns address of the 'struct variable' containing all info
-   on the variable, or nil if no such variable is defined.  */
-
-struct variable *
-lookup_variable_in_set (const char *name, unsigned int length,
-                        const struct variable_set *set)
-{
-  struct variable var_key;
-
-  var_key.name = (char *) name;
-  var_key.length = length;
-
-  return (struct variable *) hash_find_item ((struct hash_table *) &set->table, &var_key);
-}
-
-/* Initialize FILE's variable set list.  If FILE already has a variable set
-   list, the topmost variable set is left intact, but the the rest of the
-   chain is replaced with FILE->parent's setlist.  If FILE is a double-colon
-   rule, then we will use the "root" double-colon target's variable set as the
-   parent of FILE's variable set.
-
-   If we're READING a makefile, don't do the pattern variable search now,
-   since the pattern variable might not have been defined yet.  */
-
-void
-initialize_file_variables (struct file *file, int reading)
-{
-  struct variable_set_list *l = file->variables;
-
-  if (l == 0)
-    {
-      l = (struct variable_set_list *)
-        xmalloc (sizeof (struct variable_set_list));
-      l->set = xmalloc (sizeof (struct variable_set));
-      hash_init (&l->set->table, PERFILE_VARIABLE_BUCKETS,
-                 variable_hash_1, variable_hash_2, variable_hash_cmp);
-      file->variables = l;
-    }
-
-  /* If this is a double-colon, then our "parent" is the "root" target for
-     this double-colon rule.  Since that rule has the same name, parent,
-     etc. we can just use its variables as the "next" for ours.  */
-
-  if (file->double_colon && file->double_colon != file)
-    {
-      initialize_file_variables (file->double_colon, reading);
-      l->next = file->double_colon->variables;
-      l->next_is_parent = 0;
-      return;
-    }
-
-  if (file->parent == 0)
-    l->next = &global_setlist;
-  else
-    {
-      initialize_file_variables (file->parent, reading);
-      l->next = file->parent->variables;
-    }
-  l->next_is_parent = 1;
-
-  /* If we're not reading makefiles and we haven't looked yet, see if
-     we can find pattern variables for this target.  */
-
-  if (!reading && !file->pat_searched)
-    {
-      struct pattern_var *p;
-
-      p = lookup_pattern_var (0, file->name);
-      if (p != 0)
-        {
-          struct variable_set_list *global = current_variable_set_list;
-
-          /* We found at least one.  Set up a new variable set to accumulate
-             all the pattern variables that match this target.  */
-
-          file->pat_variables = create_new_variable_set ();
-          current_variable_set_list = file->pat_variables;
-
-          do
-            {
-              /* We found one, so insert it into the set.  */
-
-              struct variable *v;
-
-              if (p->variable.flavor == f_simple)
-                {
-                  v = define_variable_loc (
-                    p->variable.name, strlen (p->variable.name),
-                    p->variable.value, p->variable.origin,
-                    0, &p->variable.fileinfo);
-
-                  v->flavor = f_simple;
-                }
-              else
-                {
-                  v = do_variable_definition (
-                    &p->variable.fileinfo, p->variable.name,
-                    p->variable.value, p->variable.origin,
-                    p->variable.flavor, 1);
-                }
-
-              /* Also mark it as a per-target and copy export status. */
-              v->per_target = p->variable.per_target;
-              v->export = p->variable.export;
-              v->private_var = p->variable.private_var;
-            }
-          while ((p = lookup_pattern_var (p, file->name)) != 0);
-
-          current_variable_set_list = global;
-        }
-      file->pat_searched = 1;
-    }
-
-  /* If we have a pattern variable match, set it up.  */
-
-  if (file->pat_variables != 0)
-    {
-      file->pat_variables->next = l->next;
-      file->pat_variables->next_is_parent = l->next_is_parent;
-      l->next = file->pat_variables;
-      l->next_is_parent = 0;
-    }
-}
-
-/* Pop the top set off the current variable set list,
-   and free all its storage.  */
-
-struct variable_set_list *
-create_new_variable_set (void)
-{
-  struct variable_set_list *setlist;
-  struct variable_set *set;
-
-  set = xmalloc (sizeof (struct variable_set));
-  hash_init (&set->table, SMALL_SCOPE_VARIABLE_BUCKETS,
-             variable_hash_1, variable_hash_2, variable_hash_cmp);
-
-  setlist = (struct variable_set_list *)
-    xmalloc (sizeof (struct variable_set_list));
-  setlist->set = set;
-  setlist->next = current_variable_set_list;
-  setlist->next_is_parent = 0;
-
-  return setlist;
-}
-
-/* Create a new variable set and push it on the current setlist.
-   If we're pushing a global scope (that is, the current scope is the global
-   scope) then we need to "push" it the other way: file variable sets point
-   directly to the global_setlist so we need to replace that with the new one.
- */
-
-struct variable_set_list *
-push_new_variable_scope (void)
-{
-  current_variable_set_list = create_new_variable_set ();
-  if (current_variable_set_list->next == &global_setlist)
-    {
-      /* It was the global, so instead of new -> &global we want to replace
-         &global with the new one and have &global -> new, with current still
-         pointing to &global  */
-      struct variable_set *set = current_variable_set_list->set;
-      current_variable_set_list->set = global_setlist.set;
-      global_setlist.set = set;
-      current_variable_set_list->next = global_setlist.next;
-      global_setlist.next = current_variable_set_list;
-      current_variable_set_list = &global_setlist;
-    }
-  return (current_variable_set_list);
-}
-
-void
-pop_variable_scope (void)
-{
-  struct variable_set_list *setlist;
-  struct variable_set *set;
-
-  /* Can't call this if there's no scope to pop!  */
-  assert (current_variable_set_list->next != NULL);
-
-  if (current_variable_set_list != &global_setlist)
-    {
-      /* We're not pointing to the global setlist, so pop this one.  */
-      setlist = current_variable_set_list;
-      set = setlist->set;
-      current_variable_set_list = setlist->next;
-    }
-  else
-    {
-      /* This set is the one in the global_setlist, but there is another global
-         set beyond that.  We want to copy that set to global_setlist, then
-         delete what used to be in global_setlist.  */
-      setlist = global_setlist.next;
-      set = global_setlist.set;
-      global_setlist.set = setlist->set;
-      global_setlist.next = setlist->next;
-      global_setlist.next_is_parent = setlist->next_is_parent;
-    }
-
-  /* Free the one we no longer need.  */
-  free (setlist);
-  hash_map (&set->table, free_variable_name_and_value);
-  hash_free (&set->table, 1);
-  free (set);
-}
-
-/* Merge FROM_SET into TO_SET, freeing unused storage in FROM_SET.  */
-
-static void
-merge_variable_sets (struct variable_set *to_set,
-                     struct variable_set *from_set)
-{
-  struct variable **from_var_slot = (struct variable **) from_set->table.ht_vec;
-  struct variable **from_var_end = from_var_slot + from_set->table.ht_size;
-
-  int inc = to_set == &global_variable_set ? 1 : 0;
-
-  for ( ; from_var_slot < from_var_end; from_var_slot++)
-    if (! HASH_VACANT (*from_var_slot))
-      {
-        struct variable *from_var = *from_var_slot;
-        struct variable **to_var_slot
-          = (struct variable **) hash_find_slot (&to_set->table, *from_var_slot);
-        if (HASH_VACANT (*to_var_slot))
-          {
-            hash_insert_at (&to_set->table, from_var, to_var_slot);
-            variable_changenum += inc;
-          }
-        else
-          {
-            /* GKM FIXME: delete in from_set->table */
-            free (from_var->value);
-            free (from_var);
-          }
-      }
-}
-
-/* Merge SETLIST1 into SETLIST0, freeing unused storage in SETLIST1.  */
-
-void
-merge_variable_set_lists (struct variable_set_list **setlist0,
-                          struct variable_set_list *setlist1)
-{
-  struct variable_set_list *to = *setlist0;
-  struct variable_set_list *last0 = 0;
-
-  /* If there's nothing to merge, stop now.  */
-  if (!setlist1)
-    return;
-
-  /* This loop relies on the fact that all setlists terminate with the global
-     setlist (before NULL).  If that's not true, arguably we SHOULD die.  */
-  if (to)
-    while (setlist1 != &global_setlist && to != &global_setlist)
-      {
-        struct variable_set_list *from = setlist1;
-        setlist1 = setlist1->next;
-
-        merge_variable_sets (to->set, from->set);
-
-        last0 = to;
-        to = to->next;
-      }
-
-  if (setlist1 != &global_setlist)
-    {
-      if (last0 == 0)
-        *setlist0 = setlist1;
-      else
-        last0->next = setlist1;
-    }
-}
-
-/* Define the automatic variables, and record the addresses
-   of their structures so we can change their values quickly.  */
-
-void
-define_automatic_variables (void)
-{
-  struct variable *v;
-  char buf[200];
-
-  sprintf (buf, "%u", makelevel);
-  define_variable_cname (MAKELEVEL_NAME, buf, o_env, 0);
-
-  sprintf (buf, "%s%s%s",
-           version_string,
-           (remote_description == 0 || remote_description[0] == '\0')
-           ? "" : "-",
-           (remote_description == 0 || remote_description[0] == '\0')
-           ? "" : remote_description);
-  define_variable_cname ("MAKE_VERSION", buf, o_default, 0);
-  define_variable_cname ("MAKE_HOST", make_host, o_default, 0);
-
-#ifdef  __MSDOS__
-  /* Allow to specify a special shell just for Make,
-     and use $COMSPEC as the default $SHELL when appropriate.  */
-  {
-    static char shell_str[] = "SHELL";
-    const int shlen = sizeof (shell_str) - 1;
-    struct variable *mshp = lookup_variable ("MAKESHELL", 9);
-    struct variable *comp = lookup_variable ("COMSPEC", 7);
-
-    /* $(MAKESHELL) overrides $(SHELL) even if -e is in effect.  */
-    if (mshp)
-      (void) define_variable (shell_str, shlen,
-                              mshp->value, o_env_override, 0);
-    else if (comp)
-      {
-        /* $(COMSPEC) shouldn't override $(SHELL).  */
-        struct variable *shp = lookup_variable (shell_str, shlen);
-
-        if (!shp)
-          (void) define_variable (shell_str, shlen, comp->value, o_env, 0);
-      }
-  }
-#elif defined(__EMX__)
-  {
-    static char shell_str[] = "SHELL";
-    const int shlen = sizeof (shell_str) - 1;
-    struct variable *shell = lookup_variable (shell_str, shlen);
-    struct variable *replace = lookup_variable ("MAKESHELL", 9);
-
-    /* if $MAKESHELL is defined in the environment assume o_env_override */
-    if (replace && *replace->value && replace->origin == o_env)
-      replace->origin = o_env_override;
-
-    /* if $MAKESHELL is not defined use $SHELL but only if the variable
-       did not come from the environment */
-    if (!replace || !*replace->value)
-      if (shell && *shell->value && (shell->origin == o_env
-          || shell->origin == o_env_override))
-        {
-          /* overwrite whatever we got from the environment */
-          free (shell->value);
-          shell->value = xstrdup (default_shell);
-          shell->origin = o_default;
-        }
-
-    /* Some people do not like cmd to be used as the default
-       if $SHELL is not defined in the Makefile.
-       With -DNO_CMD_DEFAULT you can turn off this behaviour */
-# ifndef NO_CMD_DEFAULT
-    /* otherwise use $COMSPEC */
-    if (!replace || !*replace->value)
-      replace = lookup_variable ("COMSPEC", 7);
-
-    /* otherwise use $OS2_SHELL */
-    if (!replace || !*replace->value)
-      replace = lookup_variable ("OS2_SHELL", 9);
-# else
-#   warning NO_CMD_DEFAULT: GNU make will not use CMD.EXE as default shell
-# endif
-
-    if (replace && *replace->value)
-      /* overwrite $SHELL */
-      (void) define_variable (shell_str, shlen, replace->value,
-                              replace->origin, 0);
-    else
-      /* provide a definition if there is none */
-      (void) define_variable (shell_str, shlen, default_shell,
-                              o_default, 0);
-  }
-
-#endif
-
-  /* This won't override any definition, but it will provide one if there
-     isn't one there.  */
-  v = define_variable_cname ("SHELL", default_shell, o_default, 0);
-#ifdef __MSDOS__
-  v->export = v_export;  /*  Export always SHELL.  */
-#endif
-
-  /* On MSDOS we do use SHELL from environment, since it isn't a standard
-     environment variable on MSDOS, so whoever sets it, does that on purpose.
-     On OS/2 we do not use SHELL from environment but we have already handled
-     that problem above. */
-#if !defined(__MSDOS__) && !defined(__EMX__)
-  /* Don't let SHELL come from the environment.  */
-  if (*v->value == '\0' || v->origin == o_env || v->origin == o_env_override)
-    {
-      free (v->value);
-      v->origin = o_file;
-      v->value = xstrdup (default_shell);
-    }
-#endif
-
-  /* Make sure MAKEFILES gets exported if it is set.  */
-  v = define_variable_cname ("MAKEFILES", "", o_default, 0);
-  v->export = v_ifset;
-
-  /* Define the magic D and F variables in terms of
-     the automatic variables they are variations of.  */
-
-#if defined(__MSDOS__) || defined(WINDOWS32)
-  /* For consistency, remove the trailing backslash as well as slash.  */
-  define_variable_cname ("@D", "$(patsubst %/,%,$(patsubst %\\,%,$(dir $@)))",
-                         o_automatic, 1);
-  define_variable_cname ("%D", "$(patsubst %/,%,$(patsubst %\\,%,$(dir $%)))",
-                         o_automatic, 1);
-  define_variable_cname ("*D", "$(patsubst %/,%,$(patsubst %\\,%,$(dir $*)))",
-                         o_automatic, 1);
-  define_variable_cname ("<D", "$(patsubst %/,%,$(patsubst %\\,%,$(dir $<)))",
-                         o_automatic, 1);
-  define_variable_cname ("?D", "$(patsubst %/,%,$(patsubst %\\,%,$(dir $?)))",
-                         o_automatic, 1);
-  define_variable_cname ("^D", "$(patsubst %/,%,$(patsubst %\\,%,$(dir $^)))",
-                         o_automatic, 1);
-  define_variable_cname ("+D", "$(patsubst %/,%,$(patsubst %\\,%,$(dir $+)))",
-                         o_automatic, 1);
-#else  /* not __MSDOS__, not WINDOWS32 */
-  define_variable_cname ("@D", "$(patsubst %/,%,$(dir $@))", o_automatic, 1);
-  define_variable_cname ("%D", "$(patsubst %/,%,$(dir $%))", o_automatic, 1);
-  define_variable_cname ("*D", "$(patsubst %/,%,$(dir $*))", o_automatic, 1);
-  define_variable_cname ("<D", "$(patsubst %/,%,$(dir $<))", o_automatic, 1);
-  define_variable_cname ("?D", "$(patsubst %/,%,$(dir $?))", o_automatic, 1);
-  define_variable_cname ("^D", "$(patsubst %/,%,$(dir $^))", o_automatic, 1);
-  define_variable_cname ("+D", "$(patsubst %/,%,$(dir $+))", o_automatic, 1);
-#endif
-  define_variable_cname ("@F", "$(notdir $@)", o_automatic, 1);
-  define_variable_cname ("%F", "$(notdir $%)", o_automatic, 1);
-  define_variable_cname ("*F", "$(notdir $*)", o_automatic, 1);
-  define_variable_cname ("<F", "$(notdir $<)", o_automatic, 1);
-  define_variable_cname ("?F", "$(notdir $?)", o_automatic, 1);
-  define_variable_cname ("^F", "$(notdir $^)", o_automatic, 1);
-  define_variable_cname ("+F", "$(notdir $+)", o_automatic, 1);
-}
-
-int export_all_variables;
-
-/* Create a new environment for FILE's commands.
-   If FILE is nil, this is for the 'shell' function.
-   The child's MAKELEVEL variable is incremented.  */
-
-char **
-target_environment (struct file *file)
-{
-  struct variable_set_list *set_list;
-  struct variable_set_list *s;
-  struct hash_table table;
-  struct variable **v_slot;
-  struct variable **v_end;
-  struct variable makelevel_key;
-  char **result_0;
-  char **result;
-
-  if (file == 0)
-    set_list = current_variable_set_list;
-  else
-    set_list = file->variables;
-
-  hash_init (&table, VARIABLE_BUCKETS,
-             variable_hash_1, variable_hash_2, variable_hash_cmp);
-
-  /* Run through all the variable sets in the list,
-     accumulating variables in TABLE.  */
-  for (s = set_list; s != 0; s = s->next)
-    {
-      struct variable_set *set = s->set;
-      v_slot = (struct variable **) set->table.ht_vec;
-      v_end = v_slot + set->table.ht_size;
-      for ( ; v_slot < v_end; v_slot++)
-        if (! HASH_VACANT (*v_slot))
-          {
-            struct variable **new_slot;
-            struct variable *v = *v_slot;
-
-            /* If this is a per-target variable and it hasn't been touched
-               already then look up the global version and take its export
-               value.  */
-            if (v->per_target && v->export == v_default)
-              {
-                struct variable *gv;
-
-                gv = lookup_variable_in_set (v->name, strlen (v->name),
-                                             &global_variable_set);
-                if (gv)
-                  v->export = gv->export;
-              }
-
-            switch (v->export)
-              {
-              case v_default:
-                if (v->origin == o_default || v->origin == o_automatic)
-                  /* Only export default variables by explicit request.  */
-                  continue;
-
-                /* The variable doesn't have a name that can be exported.  */
-                if (! v->exportable)
-                  continue;
-
-                if (! export_all_variables
-                    && v->origin != o_command
-                    && v->origin != o_env && v->origin != o_env_override)
-                  continue;
-                break;
-
-              case v_export:
-                break;
-
-              case v_noexport:
-                {
-                  /* If this is the SHELL variable and it's not exported,
-                     then add the value from our original environment, if
-                     the original environment defined a value for SHELL.  */
-                  if (streq (v->name, "SHELL") && shell_var.value)
-                    {
-                      v = &shell_var;
-                      break;
-                    }
-                  continue;
-                }
-
-              case v_ifset:
-                if (v->origin == o_default)
-                  continue;
-                break;
-              }
-
-            new_slot = (struct variable **) hash_find_slot (&table, v);
-            if (HASH_VACANT (*new_slot))
-              hash_insert_at (&table, v, new_slot);
-          }
-    }
-
-  makelevel_key.name = (char *)MAKELEVEL_NAME;
-  makelevel_key.length = MAKELEVEL_LENGTH;
-  hash_delete (&table, &makelevel_key);
-
-  result = result_0 = xmalloc ((table.ht_fill + 2) * sizeof (char *));
-
-  v_slot = (struct variable **) table.ht_vec;
-  v_end = v_slot + table.ht_size;
-  for ( ; v_slot < v_end; v_slot++)
-    if (! HASH_VACANT (*v_slot))
-      {
-        struct variable *v = *v_slot;
-
-        /* If V is recursively expanded and didn't come from the environment,
-           expand its value.  If it came from the environment, it should
-           go back into the environment unchanged.  */
-        if (v->recursive
-            && v->origin != o_env && v->origin != o_env_override)
-          {
-            char *value = recursively_expand_for_file (v, file);
-#ifdef WINDOWS32
-            if (strcmp (v->name, "Path") == 0 ||
-                strcmp (v->name, "PATH") == 0)
-              convert_Path_to_windows32 (value, ';');
-#endif
-            *result++ = xstrdup (concat (3, v->name, "=", value));
-            free (value);
-          }
-        else
-          {
-#ifdef WINDOWS32
-            if (strcmp (v->name, "Path") == 0 ||
-                strcmp (v->name, "PATH") == 0)
-              convert_Path_to_windows32 (v->value, ';');
-#endif
-            *result++ = xstrdup (concat (3, v->name, "=", v->value));
-          }
-      }
-
-  *result = xmalloc (100);
-  sprintf (*result, "%s=%u", MAKELEVEL_NAME, makelevel + 1);
-  *++result = 0;
-
-  hash_free (&table, 0);
-
-  return result_0;
-}
-
-static struct variable *
-set_special_var (struct variable *var)
-{
-  if (streq (var->name, RECIPEPREFIX_NAME))
-    {
-      /* The user is resetting the command introduction prefix.  This has to
-         happen immediately, so that subsequent rules are interpreted
-         properly.  */
-      cmd_prefix = var->value[0]=='\0' ? RECIPEPREFIX_DEFAULT : var->value[0];
-    }
-
-  return var;
-}
-
-/* Given a string, shell-execute it and return a malloc'ed string of the
- * result. This removes only ONE newline (if any) at the end, for maximum
- * compatibility with the *BSD makes.  If it fails, returns NULL. */
-
-static char *
-shell_result (const char *p)
-{
-  char *buf;
-  unsigned int len;
-  char *args[2];
-  char *result;
-
-  install_variable_buffer (&buf, &len);
-
-  args[0] = (char *) p;
-  args[1] = NULL;
-  variable_buffer_output (func_shell_base (variable_buffer, args, 0), "\0", 1);
-  result = strdup (variable_buffer);
-
-  restore_variable_buffer (buf, len);
-  return result;
-}
-
-/* Given a variable, a value, and a flavor, define the variable.
-   See the try_variable_definition() function for details on the parameters. */
-
-struct variable *
-do_variable_definition (const floc *flocp, const char *varname,
-                        const char *value, enum variable_origin origin,
-                        enum variable_flavor flavor, int target_var)
-{
-  const char *p;
-  char *alloc_value = NULL;
-  struct variable *v;
-  int append = 0;
-  int conditional = 0;
-
-  /* Calculate the variable's new value in VALUE.  */
-
-  switch (flavor)
-    {
-    default:
-    case f_bogus:
-      /* Should not be possible.  */
-      abort ();
-    case f_simple:
-      /* A simple variable definition "var := value".  Expand the value.
-         We have to allocate memory since otherwise it'll clobber the
-         variable buffer, and we may still need that if we're looking at a
-         target-specific variable.  */
-      p = alloc_value = allocated_variable_expand (value);
-      break;
-    case f_shell:
-      {
-        /* A shell definition "var != value".  Expand value, pass it to
-           the shell, and store the result in recursively-expanded var. */
-        char *q = allocated_variable_expand (value);
-        p = alloc_value = shell_result (q);
-        free (q);
-        flavor = f_recursive;
-        break;
-      }
-    case f_conditional:
-      /* A conditional variable definition "var ?= value".
-         The value is set IFF the variable is not defined yet. */
-      v = lookup_variable (varname, strlen (varname));
-      if (v)
-        goto done;
-
-      conditional = 1;
-      flavor = f_recursive;
-      /* FALLTHROUGH */
-    case f_recursive:
-      /* A recursive variable definition "var = value".
-         The value is used verbatim.  */
-      p = value;
-      break;
-    case f_append:
-    case f_append_value:
-      {
-        /* If we have += but we're in a target variable context, we want to
-           append only with other variables in the context of this target.  */
-        if (target_var)
-          {
-            append = 1;
-            v = lookup_variable_in_set (varname, strlen (varname),
-                                        current_variable_set_list->set);
-
-            /* Don't append from the global set if a previous non-appending
-               target-specific variable definition exists. */
-            if (v && !v->append)
-              append = 0;
-          }
-        else
-          v = lookup_variable (varname, strlen (varname));
-
-        if (v == 0)
-          {
-            /* There was no old value.
-               This becomes a normal recursive definition.  */
-            p = value;
-            flavor = f_recursive;
-          }
-        else
-          {
-            /* Paste the old and new values together in VALUE.  */
-
-            unsigned int oldlen, vallen;
-            const char *val;
-            char *tp = NULL;
-
-            val = value;
-            if (v->recursive)
-              /* The previous definition of the variable was recursive.
-                 The new value is the unexpanded old and new values.  */
-              flavor = f_recursive;
-            else if (flavor != f_append_value)
-              /* The previous definition of the variable was simple.
-                 The new value comes from the old value, which was expanded
-                 when it was set; and from the expanded new value.  Allocate
-                 memory for the expansion as we may still need the rest of the
-                 buffer if we're looking at a target-specific variable.  */
-              val = tp = allocated_variable_expand (val);
-
-            /* If the new value is empty, nothing to do.  */
-            vallen = strlen (val);
-            if (!vallen)
-              {
-                alloc_value = tp;
-                goto done;
-              }
-
-            oldlen = strlen (v->value);
-            p = alloc_value = xmalloc (oldlen + 1 + vallen + 1);
-
-            if (oldlen)
-              {
-                memcpy (alloc_value, v->value, oldlen);
-                alloc_value[oldlen] = ' ';
-                ++oldlen;
-              }
-
-            memcpy (&alloc_value[oldlen], val, vallen + 1);
-
-            free (tp);
-          }
-        break;
-      }
-    }
-
-#ifdef __MSDOS__
-  /* Many Unix Makefiles include a line saying "SHELL=/bin/sh", but
-     non-Unix systems don't conform to this default configuration (in
-     fact, most of them don't even have '/bin').  On the other hand,
-     $SHELL in the environment, if set, points to the real pathname of
-     the shell.
-     Therefore, we generally won't let lines like "SHELL=/bin/sh" from
-     the Makefile override $SHELL from the environment.  But first, we
-     look for the basename of the shell in the directory where SHELL=
-     points, and along the $PATH; if it is found in any of these places,
-     we define $SHELL to be the actual pathname of the shell.  Thus, if
-     you have bash.exe installed as d:/unix/bash.exe, and d:/unix is on
-     your $PATH, then SHELL=/usr/local/bin/bash will have the effect of
-     defining SHELL to be "d:/unix/bash.exe".  */
-  if ((origin == o_file || origin == o_override)
-      && strcmp (varname, "SHELL") == 0)
-    {
-      PATH_VAR (shellpath);
-      extern char * __dosexec_find_on_path (const char *, char *[], char *);
-
-      /* See if we can find "/bin/sh.exe", "/bin/sh.com", etc.  */
-      if (__dosexec_find_on_path (p, NULL, shellpath))
-        {
-          char *tp;
-
-          for (tp = shellpath; *tp; tp++)
-            if (*tp == '\\')
-              *tp = '/';
-
-          v = define_variable_loc (varname, strlen (varname),
-                                   shellpath, origin, flavor == f_recursive,
-                                   flocp);
-        }
-      else
-        {
-          const char *shellbase, *bslash;
-          struct variable *pathv = lookup_variable ("PATH", 4);
-          char *path_string;
-          char *fake_env[2];
-          size_t pathlen = 0;
-
-          shellbase = strrchr (p, '/');
-          bslash = strrchr (p, '\\');
-          if (!shellbase || bslash > shellbase)
-            shellbase = bslash;
-          if (!shellbase && p[1] == ':')
-            shellbase = p + 1;
-          if (shellbase)
-            shellbase++;
-          else
-            shellbase = p;
-
-          /* Search for the basename of the shell (with standard
-             executable extensions) along the $PATH.  */
-          if (pathv)
-            pathlen = strlen (pathv->value);
-          path_string = xmalloc (5 + pathlen + 2 + 1);
-          /* On MSDOS, current directory is considered as part of $PATH.  */
-          sprintf (path_string, "PATH=.;%s", pathv ? pathv->value : "");
-          fake_env[0] = path_string;
-          fake_env[1] = 0;
-          if (__dosexec_find_on_path (shellbase, fake_env, shellpath))
-            {
-              char *tp;
-
-              for (tp = shellpath; *tp; tp++)
-                if (*tp == '\\')
-                  *tp = '/';
-
-              v = define_variable_loc (varname, strlen (varname),
-                                       shellpath, origin,
-                                       flavor == f_recursive, flocp);
-            }
-          else
-            v = lookup_variable (varname, strlen (varname));
-
-          free (path_string);
-        }
-    }
-  else
-#endif /* __MSDOS__ */
-#ifdef WINDOWS32
-  if ((origin == o_file || origin == o_override || origin == o_command)
-      && streq (varname, "SHELL"))
-    {
-      extern const char *default_shell;
-
-      /* Call shell locator function. If it returns TRUE, then
-         set no_default_sh_exe to indicate sh was found and
-         set new value for SHELL variable.  */
-
-      if (find_and_set_default_shell (p))
-        {
-          v = define_variable_in_set (varname, strlen (varname), default_shell,
-                                      origin, flavor == f_recursive,
-                                      (target_var
-                                       ? current_variable_set_list->set
-                                       : NULL),
-                                      flocp);
-          no_default_sh_exe = 0;
-        }
-      else
-        {
-          char *tp = alloc_value;
-
-          alloc_value = allocated_variable_expand (p);
-
-          if (find_and_set_default_shell (alloc_value))
-            {
-              v = define_variable_in_set (varname, strlen (varname), p,
-                                          origin, flavor == f_recursive,
-                                          (target_var
-                                           ? current_variable_set_list->set
-                                           : NULL),
-                                          flocp);
-              no_default_sh_exe = 0;
-            }
-          else
-            v = lookup_variable (varname, strlen (varname));
-
-          free (tp);
-        }
-    }
-  else
-    v = NULL;
-
-  /* If not $SHELL, or if $SHELL points to a program we didn't find,
-     just process this variable "as usual".  */
-  if (!v)
-#endif
-
-  /* If we are defining variables inside an $(eval ...), we might have a
-     different variable context pushed, not the global context (maybe we're
-     inside a $(call ...) or something.  Since this function is only ever
-     invoked in places where we want to define globally visible variables,
-     make sure we define this variable in the global set.  */
-
-  v = define_variable_in_set (varname, strlen (varname), p,
-                              origin, flavor == f_recursive,
-                              (target_var
-                               ? current_variable_set_list->set : NULL),
-                              flocp);
-  v->append = append;
-  v->conditional = conditional;
-
- done:
-  free (alloc_value);
-  return v->special ? set_special_var (v) : v;
-}
-
-/* Parse P (a null-terminated string) as a variable definition.
-
-   If it is not a variable definition, return NULL and the contents of *VAR
-   are undefined, except NAME is set to the first non-space character or NIL.
-
-   If it is a variable definition, return a pointer to the char after the
-   assignment token and set the following fields (only) of *VAR:
-    name   : name of the variable (ALWAYS SET) (NOT NUL-TERMINATED!)
-    length : length of the variable name
-    value  : value of the variable (nul-terminated)
-    flavor : flavor of the variable
-   Other values in *VAR are unchanged.
-  */
-
-char *
-parse_variable_definition (const char *p, struct variable *var)
-{
-  int wspace = 0;
-  const char *e = NULL;
-
-  NEXT_TOKEN (p);
-  var->name = (char *)p;
-  var->length = 0;
-
-  while (1)
-    {
-      int c = *p++;
-
-      /* If we find a comment or EOS, it's not a variable definition.  */
-      if (STOP_SET (c, MAP_COMMENT|MAP_NUL))
-        return NULL;
-
-      if (c == '$')
-        {
-          /* This begins a variable expansion reference.  Make sure we don't
-             treat chars inside the reference as assignment tokens.  */
-          char closeparen;
-          unsigned int count;
-
-          c = *p++;
-          if (c == '(')
-            closeparen = ')';
-          else if (c == '{')
-            closeparen = '}';
-          else if (c == '\0')
-            return NULL;
-          else
-            /* '$$' or '$X'.  Either way, nothing special to do here.  */
-            continue;
-
-          /* P now points past the opening paren or brace.
-             Count parens or braces until it is matched.  */
-          for (count = 1; *p != '\0'; ++p)
-            {
-              if (*p == closeparen && --count == 0)
-                {
-                  ++p;
-                  break;
-                }
-              if (*p == c)
-                ++count;
-            }
-          continue;
-        }
-
-      /* If we find whitespace skip it, and remember we found it.  */
-      if (ISBLANK (c))
-        {
-          wspace = 1;
-          e = p - 1;
-          NEXT_TOKEN (p);
-          c = *p;
-          if (c == '\0')
-            return NULL;
-          ++p;
-        }
-
-
-      if (c == '=')
-        {
-          var->flavor = f_recursive;
-          if (! e)
-            e = p - 1;
-          break;
-        }
-
-      /* Match assignment variants (:=, +=, ?=, !=)  */
-      if (*p == '=')
-        {
-          switch (c)
-            {
-              case ':':
-                var->flavor = f_simple;
-                break;
-              case '+':
-                var->flavor = f_append;
-                break;
-              case '?':
-                var->flavor = f_conditional;
-                break;
-              case '!':
-                var->flavor = f_shell;
-                break;
-              default:
-                /* If we skipped whitespace, non-assignments means no var.  */
-                if (wspace)
-                  return NULL;
-
-                /* Might be assignment, or might be $= or #=.  Check.  */
-                continue;
-            }
-          if (! e)
-            e = p - 1;
-          ++p;
-          break;
-        }
-
-      /* Check for POSIX ::= syntax  */
-      if (c == ':')
-        {
-          /* A colon other than :=/::= is not a variable defn.  */
-          if (*p != ':' || p[1] != '=')
-            return NULL;
-
-          /* POSIX allows ::= to be the same as GNU make's := */
-          var->flavor = f_simple;
-          if (! e)
-            e = p - 1;
-          p += 2;
-          break;
-        }
-
-      /* If we skipped whitespace, non-assignments means no var.  */
-      if (wspace)
-        return NULL;
-    }
-
-  var->length = e - var->name;
-  var->value = next_token (p);
-  return (char *)p;
-}
-
-/* Try to interpret LINE (a null-terminated string) as a variable definition.
-
-   If LINE was recognized as a variable definition, a pointer to its 'struct
-   variable' is returned.  If LINE is not a variable definition, NULL is
-   returned.  */
-
-struct variable *
-assign_variable_definition (struct variable *v, const char *line)
-{
-  char *name;
-
-  if (!parse_variable_definition (line, v))
-    return NULL;
-
-  /* Expand the name, so "$(foo)bar = baz" works.  */
-  name = alloca (v->length + 1);
-  memcpy (name, v->name, v->length);
-  name[v->length] = '\0';
-  v->name = allocated_variable_expand (name);
-
-  if (v->name[0] == '\0')
-    O (fatal, &v->fileinfo, _("empty variable name"));
-
-  return v;
-}
-
-/* Try to interpret LINE (a null-terminated string) as a variable definition.
-
-   ORIGIN may be o_file, o_override, o_env, o_env_override,
-   or o_command specifying that the variable definition comes
-   from a makefile, an override directive, the environment with
-   or without the -e switch, or the command line.
-
-   See the comments for assign_variable_definition().
-
-   If LINE was recognized as a variable definition, a pointer to its 'struct
-   variable' is returned.  If LINE is not a variable definition, NULL is
-   returned.  */
-
-struct variable *
-try_variable_definition (const floc *flocp, const char *line,
-                         enum variable_origin origin, int target_var)
-{
-  struct variable v;
-  struct variable *vp;
-
-  if (flocp != 0)
-    v.fileinfo = *flocp;
-  else
-    v.fileinfo.filenm = 0;
-
-  if (!assign_variable_definition (&v, line))
-    return 0;
-
-  vp = do_variable_definition (flocp, v.name, v.value,
-                               origin, v.flavor, target_var);
-
-  free (v.name);
-
-  return vp;
-}
-
-/* Print information for variable V, prefixing it with PREFIX.  */
-
-static void
-print_variable (const void *item, void *arg)
-{
-  const struct variable *v = item;
-  const char *prefix = arg;
-  const char *origin;
-
-  switch (v->origin)
-    {
-    case o_automatic:
-      origin = _("automatic");
-      break;
-    case o_default:
-      origin = _("default");
-      break;
-    case o_env:
-      origin = _("environment");
-      break;
-    case o_file:
-      origin = _("makefile");
-      break;
-    case o_env_override:
-      origin = _("environment under -e");
-      break;
-    case o_command:
-      origin = _("command line");
-      break;
-    case o_override:
-      origin = _("'override' directive");
-      break;
-    case o_invalid:
-    default:
-      abort ();
-    }
-  fputs ("# ", stdout);
-  fputs (origin, stdout);
-  if (v->private_var)
-    fputs (" private", stdout);
-  if (v->fileinfo.filenm)
-    printf (_(" (from '%s', line %lu)"),
-            v->fileinfo.filenm, v->fileinfo.lineno + v->fileinfo.offset);
-  putchar ('\n');
-  fputs (prefix, stdout);
-
-  /* Is this a 'define'?  */
-  if (v->recursive && strchr (v->value, '\n') != 0)
-    printf ("define %s\n%s\nendef\n", v->name, v->value);
-  else
-    {
-      char *p;
-
-      printf ("%s %s= ", v->name, v->recursive ? v->append ? "+" : "" : ":");
-
-      /* Check if the value is just whitespace.  */
-      p = next_token (v->value);
-      if (p != v->value && *p == '\0')
-        /* All whitespace.  */
-        printf ("$(subst ,,%s)", v->value);
-      else if (v->recursive)
-        fputs (v->value, stdout);
-      else
-        /* Double up dollar signs.  */
-        for (p = v->value; *p != '\0'; ++p)
-          {
-            if (*p == '$')
-              putchar ('$');
-            putchar (*p);
-          }
-      putchar ('\n');
-    }
-}
-
-
-static void
-print_auto_variable (const void *item, void *arg)
-{
-  const struct variable *v = item;
-
-  if (v->origin == o_automatic)
-    print_variable (item, arg);
-}
-
-
-static void
-print_noauto_variable (const void *item, void *arg)
-{
-  const struct variable *v = item;
-
-  if (v->origin != o_automatic)
-    print_variable (item, arg);
-}
-
-
-/* Print all the variables in SET.  PREFIX is printed before
-   the actual variable definitions (everything else is comments).  */
-
-static void
-print_variable_set (struct variable_set *set, const char *prefix, int pauto)
-{
-  hash_map_arg (&set->table, (pauto ? print_auto_variable : print_variable),
-                (void *)prefix);
-
-  fputs (_("# variable set hash-table stats:\n"), stdout);
-  fputs ("# ", stdout);
-  hash_print_stats (&set->table, stdout);
-  putc ('\n', stdout);
-}
-
-/* Print the data base of variables.  */
-
-void
-print_variable_data_base (void)
-{
-  puts (_("\n# Variables\n"));
-
-  print_variable_set (&global_variable_set, "", 0);
-
-  puts (_("\n# Pattern-specific Variable Values"));
-
-  {
-    struct pattern_var *p;
-    unsigned int rules = 0;
-
-    for (p = pattern_vars; p != 0; p = p->next)
-      {
-        ++rules;
-        printf ("\n%s :\n", p->target);
-        print_variable (&p->variable, (void *)"# ");
-      }
-
-    if (rules == 0)
-      puts (_("\n# No pattern-specific variable values."));
-    else
-      printf (_("\n# %u pattern-specific variable values"), rules);
-  }
-}
-
-
-/* Print all the local variables of FILE.  */
-
-void
-print_file_variables (const struct file *file)
-{
-  if (file->variables != 0)
-    print_variable_set (file->variables->set, "# ", 1);
-}
-
-void
-print_target_variables (const struct file *file)
-{
-  if (file->variables != 0)
-    {
-      int l = strlen (file->name);
-      char *t = alloca (l + 3);
-
-      strcpy (t, file->name);
-      t[l] = ':';
-      t[l+1] = ' ';
-      t[l+2] = '\0';
-
-      hash_map_arg (&file->variables->set->table, print_noauto_variable, t);
-    }
-}
-
-#ifdef WINDOWS32
-void
-sync_Path_environment (void)
-{
-  char *path = allocated_variable_expand ("$(PATH)");
-  static char *environ_path = NULL;
-
-  if (!path)
-    return;
-
-  /* If done this before, free the previous entry before allocating new one.  */
-  free (environ_path);
-
-  /* Create something WINDOWS32 world can grok.  */
-  convert_Path_to_windows32 (path, ';');
-  environ_path = xstrdup (concat (3, "PATH", "=", path));
-  putenv (environ_path);
-  free (path);
-}
-#endif
diff --git a/variable.h b/variable.h
deleted file mode 100644
index 12aea39..0000000
--- a/variable.h
+++ /dev/null
@@ -1,237 +0,0 @@
-/* Definitions for using variables in GNU Make.
-Copyright (C) 1988-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "hash.h"
-
-/* Codes in a variable definition saying where the definition came from.
-   Increasing numeric values signify less-overridable definitions.  */
-enum variable_origin
-  {
-    o_default,          /* Variable from the default set.  */
-    o_env,              /* Variable from environment.  */
-    o_file,             /* Variable given in a makefile.  */
-    o_env_override,     /* Variable from environment, if -e.  */
-    o_command,          /* Variable given by user.  */
-    o_override,         /* Variable from an 'override' directive.  */
-    o_automatic,        /* Automatic variable -- cannot be set.  */
-    o_invalid           /* Core dump time.  */
-  };
-
-enum variable_flavor
-  {
-    f_bogus,            /* Bogus (error) */
-    f_simple,           /* Simple definition (:= or ::=) */
-    f_recursive,        /* Recursive definition (=) */
-    f_append,           /* Appending definition (+=) */
-    f_conditional,      /* Conditional definition (?=) */
-    f_shell,            /* Shell assignment (!=) */
-    f_append_value      /* Append unexpanded value */
-  };
-
-/* Structure that represents one variable definition.
-   Each bucket of the hash table is a chain of these,
-   chained through 'next'.  */
-
-#define EXP_COUNT_BITS  15      /* This gets all the bitfields into 32 bits */
-#define EXP_COUNT_MAX   ((1<<EXP_COUNT_BITS)-1)
-
-struct variable
-  {
-    char *name;                 /* Variable name.  */
-    char *value;                /* Variable value.  */
-    floc fileinfo;              /* Where the variable was defined.  */
-    int length;                 /* strlen (name) */
-    unsigned int recursive:1;   /* Gets recursively re-evaluated.  */
-    unsigned int append:1;      /* Nonzero if an appending target-specific
-                                   variable.  */
-    unsigned int conditional:1; /* Nonzero if set with a ?=. */
-    unsigned int per_target:1;  /* Nonzero if a target-specific variable.  */
-    unsigned int special:1;     /* Nonzero if this is a special variable.  */
-    unsigned int exportable:1;  /* Nonzero if the variable _could_ be
-                                   exported.  */
-    unsigned int expanding:1;   /* Nonzero if currently being expanded.  */
-    unsigned int private_var:1; /* Nonzero avoids inheritance of this
-                                   target-specific variable.  */
-    unsigned int exp_count:EXP_COUNT_BITS;
-                                /* If >1, allow this many self-referential
-                                   expansions.  */
-    enum variable_flavor
-      flavor ENUM_BITFIELD (3); /* Variable flavor.  */
-    enum variable_origin
-      origin ENUM_BITFIELD (3); /* Variable origin.  */
-    enum variable_export
-      {
-        v_export,               /* Export this variable.  */
-        v_noexport,             /* Don't export this variable.  */
-        v_ifset,                /* Export it if it has a non-default value.  */
-        v_default               /* Decide in target_environment.  */
-      } export ENUM_BITFIELD (2);
-  };
-
-/* Structure that represents a variable set.  */
-
-struct variable_set
-  {
-    struct hash_table table;    /* Hash table of variables.  */
-  };
-
-/* Structure that represents a list of variable sets.  */
-
-struct variable_set_list
-  {
-    struct variable_set_list *next;     /* Link in the chain.  */
-    struct variable_set *set;           /* Variable set.  */
-    int next_is_parent;                 /* True if next is a parent target.  */
-  };
-
-/* Structure used for pattern-specific variables.  */
-
-struct pattern_var
-  {
-    struct pattern_var *next;
-    const char *suffix;
-    const char *target;
-    unsigned int len;
-    struct variable variable;
-  };
-
-extern char *variable_buffer;
-extern struct variable_set_list *current_variable_set_list;
-extern struct variable *default_goal_var;
-extern struct variable shell_var;
-
-/* expand.c */
-char *variable_buffer_output (char *ptr, const char *string, unsigned int length);
-char *variable_expand (const char *line);
-char *variable_expand_for_file (const char *line, struct file *file);
-char *allocated_variable_expand_for_file (const char *line, struct file *file);
-#define allocated_variable_expand(line) \
-  allocated_variable_expand_for_file (line, (struct file *) 0)
-char *expand_argument (const char *str, const char *end);
-char *variable_expand_string (char *line, const char *string, long length);
-void install_variable_buffer (char **bufp, unsigned int *lenp);
-void restore_variable_buffer (char *buf, unsigned int len);
-
-/* function.c */
-int handle_function (char **op, const char **stringp);
-int pattern_matches (const char *pattern, const char *percent, const char *str);
-char *subst_expand (char *o, const char *text, const char *subst,
-                    const char *replace, unsigned int slen, unsigned int rlen,
-                    int by_word);
-char *patsubst_expand_pat (char *o, const char *text, const char *pattern,
-                           const char *replace, const char *pattern_percent,
-                           const char *replace_percent);
-char *patsubst_expand (char *o, const char *text, char *pattern, char *replace);
-char *func_shell_base (char *o, char **argv, int trim_newlines);
-void shell_completed (int exit_code, int exit_sig);
-
-/* expand.c */
-char *recursively_expand_for_file (struct variable *v, struct file *file);
-#define recursively_expand(v)   recursively_expand_for_file (v, NULL)
-
-/* variable.c */
-struct variable_set_list *create_new_variable_set (void);
-void free_variable_set (struct variable_set_list *);
-struct variable_set_list *push_new_variable_scope (void);
-void pop_variable_scope (void);
-void define_automatic_variables (void);
-void initialize_file_variables (struct file *file, int reading);
-void print_file_variables (const struct file *file);
-void print_target_variables (const struct file *file);
-void merge_variable_set_lists (struct variable_set_list **to_list,
-                               struct variable_set_list *from_list);
-struct variable *do_variable_definition (const floc *flocp,
-                                         const char *name, const char *value,
-                                         enum variable_origin origin,
-                                         enum variable_flavor flavor,
-                                         int target_var);
-char *parse_variable_definition (const char *line,
-                                 struct variable *v);
-struct variable *assign_variable_definition (struct variable *v, const char *line);
-struct variable *try_variable_definition (const floc *flocp, const char *line,
-                                          enum variable_origin origin,
-                                          int target_var);
-void init_hash_global_variable_set (void);
-void hash_init_function_table (void);
-void define_new_function(const floc *flocp, const char *name,
-                         unsigned int min, unsigned int max, unsigned int flags,
-                         gmk_func_ptr func);
-struct variable *lookup_variable (const char *name, unsigned int length);
-struct variable *lookup_variable_in_set (const char *name, unsigned int length,
-                                         const struct variable_set *set);
-
-struct variable *define_variable_in_set (const char *name, unsigned int length,
-                                         const char *value,
-                                         enum variable_origin origin,
-                                         int recursive,
-                                         struct variable_set *set,
-                                         const floc *flocp);
-
-/* Define a variable in the current variable set.  */
-
-#define define_variable(n,l,v,o,r) \
-          define_variable_in_set((n),(l),(v),(o),(r),\
-                                 current_variable_set_list->set,NILF)
-
-/* Define a variable with a constant name in the current variable set.  */
-
-#define define_variable_cname(n,v,o,r) \
-          define_variable_in_set((n),(sizeof (n) - 1),(v),(o),(r),\
-                                 current_variable_set_list->set,NILF)
-
-/* Define a variable with a location in the current variable set.  */
-
-#define define_variable_loc(n,l,v,o,r,f) \
-          define_variable_in_set((n),(l),(v),(o),(r),\
-                                 current_variable_set_list->set,(f))
-
-/* Define a variable with a location in the global variable set.  */
-
-#define define_variable_global(n,l,v,o,r,f) \
-          define_variable_in_set((n),(l),(v),(o),(r),NULL,(f))
-
-/* Define a variable in FILE's variable set.  */
-
-#define define_variable_for_file(n,l,v,o,r,f) \
-          define_variable_in_set((n),(l),(v),(o),(r),(f)->variables->set,NILF)
-
-void undefine_variable_in_set (const char *name, unsigned int length,
-                               enum variable_origin origin,
-                               struct variable_set *set);
-
-/* Remove variable from the current variable set. */
-
-#define undefine_variable_global(n,l,o) \
-          undefine_variable_in_set((n),(l),(o),NULL)
-
-/* Warn that NAME is an undefined variable.  */
-
-#define warn_undefined(n,l) do{\
-                              if (warn_undefined_variables_flag)        \
-                                error (reading_file, (l),               \
-                                       _("warning: undefined variable '%.*s'"), \
-                                       (int)(l), (n));                  \
-                              }while(0)
-
-char **target_environment (struct file *file);
-
-struct pattern_var *create_pattern_var (const char *target,
-                                        const char *suffix);
-
-extern int export_all_variables;
-
-#define MAKELEVEL_NAME "MAKELEVEL"
-#define MAKELEVEL_LENGTH (CSTRLEN (MAKELEVEL_NAME))
diff --git a/version.c b/version.c
deleted file mode 100644
index 039d5ab..0000000
--- a/version.c
+++ /dev/null
@@ -1,33 +0,0 @@
-/* Record version and build host architecture for GNU make.
-Copyright (C) 1988-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-/* We use <config.h> instead of "config.h" so that a compilation
-   using -I. -I$srcdir will use ./config.h rather than $srcdir/config.h
-   (which it would do because makeint.h was found in $srcdir).  */
-#include <config.h>
-
-#ifndef MAKE_HOST
-# define MAKE_HOST "unknown"
-#endif
-
-const char *version_string = VERSION;
-const char *make_host = MAKE_HOST;
-
-/*
-  Local variables:
-  version-control: never
-  End:
- */
diff --git a/vms_exit.c b/vms_exit.c
deleted file mode 100644
index 988ac8a..0000000
--- a/vms_exit.c
+++ /dev/null
@@ -1,95 +0,0 @@
-/* vms_exit.c
- *
- * Wrapper for the VMS exit() command to tranlate UNIX codes to be
- * encoded for POSIX, but also have VMS severity levels.
- * The posix_exit() variant only sets a severity level for status code 1.
- *
- * Author: John E. Malmberg
- */
-
-/* Copyright (C) 2014-2017 Free Software Foundation, Inc.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-
-/* Per copyright assignment agreement with the Free Software Foundation
-   this software may be available under under other license agreements
-   and copyrights. */
-
-#include <makeint.h>
-
-#include <stsdef.h>
-void
-decc$exit (int status);
-#ifndef C_FACILITY_NO
-# define C_FACILITY_NO 0x350000
-#endif
-
-/* Lowest legal non-success VMS exit code is 8 */
-/* GNU make only defines codes 0, 1, 2 */
-/* So assume any exit code > 8 is a VMS exit code */
-
-#ifndef MAX_EXPECTED_EXIT_CODE
-# define MAX_EXPECTED_EXIT_CODE 7
-#endif
-
-/* Build a Posix Exit with VMS severity */
-void
-vms_exit (int status)
-{
-  int vms_status;
-  /* Fake the __posix_exit with severity added */
-  /* Undocumented correct way to do this. */
-  vms_status = 0;
-
-  /* The default DECC definition is not compatible with doing a POSIX_EXIT */
-  /* So fix it. */
-  if (status == EXIT_FAILURE)
-    status = MAKE_FAILURE;
-
-  /* Trivial case exit success */
-  if (status == 0)
-    decc$exit (STS$K_SUCCESS);
-
-  /* Is this a VMS status then just take it */
-  if (status > MAX_EXPECTED_EXIT_CODE)
-    {
-      /* Make sure that the message inhibit is set since message has */
-      /* already been displayed. */
-      vms_status = status | STS$M_INHIB_MSG;
-      decc$exit (vms_status);
-    }
-
-  /* Unix status codes are limited to 1 byte, so anything larger */
-  /* is a probably a VMS exit code and needs to be passed through */
-  /* A lower value can be set for a macro. */
-  /* Status 0 is always passed through as it is converted to SS$_NORMAL */
-  /* Always set the message inhibit bit */
-  vms_status = C_FACILITY_NO | 0xA000 | STS$M_INHIB_MSG;
-  vms_status |= (status << 3);
-
-  /* STS$K_ERROR is for status that stops makefile that a simple */
-  /* Rerun of the makefile will not fix. */
-
-  if (status == MAKE_FAILURE)
-    vms_status |= STS$K_ERROR;
-  else if (status == MAKE_TROUBLE)
-    {
-      /* Make trouble is for when make was told to do nothing and */
-      /* found that a target was not up to date.  Since a second */
-      /* of make will produce the same condition, this is of */
-      /* Error severity */
-      vms_status |= STS$K_ERROR;
-    }
-  decc$exit (vms_status);
-}
diff --git a/vms_export_symbol.c b/vms_export_symbol.c
deleted file mode 100644
index 38daf12..0000000
--- a/vms_export_symbol.c
+++ /dev/null
@@ -1,527 +0,0 @@
-/* File: vms_export_symbol.c
- *
- * Some programs need special environment variables deported as DCL
- * DCL symbols.
- */
-
-/* Copyright (C) 2014-2017 Free Software Foundation, Inc.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-
-/* Per copyright assignment agreement with the Free Software Foundation
-   this software may be available under under other license agreements
-   and copyrights. */
-
-
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-#include <errno.h>
-
-#include <descrip.h>
-#include <stsdef.h>
-#include <ssdef.h>
-#include <unixlib.h>
-#include <libclidef.h>
-
-#pragma member_alignment save
-#pragma nomember_alignment longword
-struct item_list_3
-{
-  unsigned short len;
-  unsigned short code;
-  void * bufadr;
-  unsigned short * retlen;
-};
-
-
-#pragma member_alignment
-
-int
-LIB$GET_SYMBOL (const struct dsc$descriptor_s * symbol,
-                struct dsc$descriptor_s * value,
-                unsigned short * value_len,
-                const unsigned long * table);
-
-int
-LIB$SET_SYMBOL (const struct dsc$descriptor_s * symbol,
-                const struct dsc$descriptor_s * value,
-                const unsigned long * table);
-
-int
-LIB$DELETE_SYMBOL (const struct dsc$descriptor_s * symbol,
-                   const unsigned long * table);
-
-#define MAX_DCL_SYMBOL_LEN (255)
-#if __CRTL_VER >= 70302000 && !defined(__VAX)
-# define MAX_DCL_SYMBOL_VALUE (8192)
-#else
-# define MAX_DCL_SYMBOL_VALUE (1024)
-#endif
-
-struct dcl_symbol
-{
-  struct dcl_symbol * link;
-  struct dsc$descriptor_s name_desc;
-  struct dsc$descriptor_s value_desc;
-  char name[MAX_DCL_SYMBOL_LEN + 1];    /* + 1 byte for null terminator */
-  char value[MAX_DCL_SYMBOL_VALUE +1];  /* + 1 byte for null terminator */
-  char pad[3]; /* Pad structure to longword allignment */
-};
-
-static struct dcl_symbol * vms_dcl_symbol_head = NULL;
-
-/* Restore symbol state to original condition. */
-static unsigned long
-clear_dcl_symbol (struct dcl_symbol * symbol)
-{
-
-  const unsigned long symtbl = LIB$K_CLI_LOCAL_SYM;
-  int status;
-
-  if (symbol->value_desc.dsc$w_length == (unsigned short)-1)
-    status = LIB$DELETE_SYMBOL (&symbol->name_desc, &symtbl);
-  else
-    status = LIB$SET_SYMBOL (&symbol->name_desc,
-                             &symbol->value_desc, &symtbl);
-  return status;
-}
-
-
-/* Restore all exported symbols to their original conditions */
-static void
-clear_exported_symbols (void)
-{
-
-  struct dcl_symbol * symbol;
-
-  symbol = vms_dcl_symbol_head;
-
-  /* Walk the list of symbols.  This is done durring exit,
-   * so no need to free memory.
-   */
-  while (symbol != NULL)
-  {
-    clear_dcl_symbol (symbol);
-    symbol = symbol->link;
-  }
-
-}
-
-
-/* Restore the symbol back to the original value
- * symbol name is either a plain name or of the form "symbol=name" where
- * the name portion is ignored.
- */
-void
-vms_restore_symbol (const char * string)
-{
-
-  struct dcl_symbol * symbol;
-  char name[MAX_DCL_SYMBOL_LEN + 1];
-  int status;
-  char * value;
-  int name_len;
-
-  symbol = vms_dcl_symbol_head;
-
-  /* Isolate the name from the value */
-  value = strchr (string, '=');
-  if (value != NULL)
-    {
-      /* Copy the name from the string */
-      name_len = (value - string);
-    }
-  else
-    name_len = strlen (string);
-
-  if (name_len > MAX_DCL_SYMBOL_LEN)
-    name_len = MAX_DCL_SYMBOL_LEN;
-
-  strncpy (name, string, name_len);
-  name[name_len] = 0;
-
-  /* Walk the list of symbols.  The saved symbol is not freed
-   * symbols are likely to be overwritten multiple times, so this
-   * saves time in saving them each time.
-   */
-  while (symbol != NULL)
-    {
-      int result;
-      result = strcmp (symbol->name, name);
-      if (result == 0)
-        {
-          clear_dcl_symbol (symbol);
-          break;
-        }
-      symbol = symbol->link;
-    }
-}
-
-int
-vms_export_dcl_symbol (const char * name, const char * value)
-{
-
-  struct dcl_symbol * symbol;
-  struct dcl_symbol * next;
-  struct dcl_symbol * link;
-  int found;
-  const unsigned long symtbl = LIB$K_CLI_LOCAL_SYM;
-  struct dsc$descriptor_s value_desc;
-  int string_len;
-  int status;
-  char new_value[MAX_DCL_SYMBOL_VALUE + 1];
-  char * dollarp;
-
-  next = vms_dcl_symbol_head;
-  link = vms_dcl_symbol_head;
-
-  /* Is symbol already exported? */
-  found = 0;
-  while ((found == 0) && (link != NULL))
-    {
-      int x;
-      found = !strncasecmp (link->name, name, MAX_DCL_SYMBOL_LEN);
-      if (found)
-        symbol = link;
-      next = link;
-      link = link->link;
-    }
-
-  /* New symbol, set it up */
-  if (found == 0)
-    {
-      symbol = malloc (sizeof (struct dcl_symbol));
-      if (symbol == NULL)
-        return SS$_INSFMEM;
-
-      /* Construct the symbol descriptor, used for both saving
-       * the old symbol and creating the new symbol.
-       */
-      symbol->name_desc.dsc$w_length = strlen (name);
-      if (symbol->name_desc.dsc$w_length > MAX_DCL_SYMBOL_LEN)
-        symbol->name_desc.dsc$w_length = MAX_DCL_SYMBOL_LEN;
-
-      strncpy (symbol->name, name, symbol->name_desc.dsc$w_length);
-      symbol->name[symbol->name_desc.dsc$w_length] = 0;
-      symbol->name_desc.dsc$a_pointer = symbol->name;
-      symbol->name_desc.dsc$b_dtype = DSC$K_DTYPE_T;
-      symbol->name_desc.dsc$b_class = DSC$K_CLASS_S;
-
-      /* construct the value descriptor, used only for saving
-       * the old symbol.
-       */
-      symbol->value_desc.dsc$a_pointer = symbol->value;
-      symbol->value_desc.dsc$w_length = MAX_DCL_SYMBOL_VALUE;
-      symbol->value_desc.dsc$b_dtype = DSC$K_DTYPE_T;
-      symbol->value_desc.dsc$b_class = DSC$K_CLASS_S;
-    }
-
-  if (found == 0)
-    {
-      unsigned long old_symtbl;
-      unsigned short value_len;
-
-      /* Look up the symbol */
-      status = LIB$GET_SYMBOL (&symbol->name_desc, &symbol->value_desc,
-                               &value_len, &old_symtbl);
-      if (!$VMS_STATUS_SUCCESS (status))
-        value_len = (unsigned short)-1;
-      else if (old_symtbl != symtbl)
-        value_len = (unsigned short)-1;
-
-      symbol->value_desc.dsc$w_length = value_len;
-
-      /* Store it away */
-      if (value_len != (unsigned short) -1)
-        symbol->value[value_len] = 0;
-
-      /* Make sure atexit scheduled */
-      if (vms_dcl_symbol_head == NULL)
-        {
-          vms_dcl_symbol_head = symbol;
-          atexit (clear_exported_symbols);
-        }
-      else
-        {
-          /* Extend the chain */
-          next->link = symbol;
-        }
-    }
-
-  /* Create or replace a symbol */
-  value_desc.dsc$a_pointer = new_value;
-  string_len = strlen (value);
-  if (string_len > MAX_DCL_SYMBOL_VALUE)
-    string_len = MAX_DCL_SYMBOL_VALUE;
-
-  strncpy (new_value, value, string_len);
-  new_value[string_len] = 0;
-
-  /* Special handling for GNU Make.  GNU Make doubles the dollar signs
-   * in environment variables read in from getenv().  Make exports symbols
-   * with the dollar signs already doubled.  So all $$ must be converted
-   * back to $.
-   * If the first $ is not doubled, then do not convert at all.
-   */
-  dollarp = strchr (new_value, '$');
-  while (dollarp && dollarp[1] == '$')
-    {
-      int left;
-      dollarp++;
-      left = string_len - (dollarp - new_value - 1);
-      string_len--;
-      if (left > 0)
-        {
-          memmove (dollarp, &dollarp[1], left);
-          dollarp = strchr (&dollarp[1], '$');
-        }
-      else
-        {
-          /* Ended with $$, simple case */
-          dollarp[1] = 0;
-          break;
-        }
-    }
-  value_desc.dsc$w_length = string_len;
-  value_desc.dsc$b_dtype = DSC$K_DTYPE_T;
-  value_desc.dsc$b_class = DSC$K_CLASS_S;
-  status = LIB$SET_SYMBOL (&symbol->name_desc, &value_desc, &symtbl);
-  return status;
-}
-
-/* export a DCL symbol using a string in the same syntax as putenv */
-int
-vms_putenv_symbol (const char * string)
-{
-
-  char name[MAX_DCL_SYMBOL_LEN + 1];
-  int status;
-  char * value;
-  int name_len;
-
-  /* Isolate the name from the value */
-  value = strchr (string, '=');
-  if (value == NULL)
-    {
-      errno = EINVAL;
-      return -1;
-    }
-
-  /* Copy the name from the string */
-  name_len = (value - string);
-  if (name_len > MAX_DCL_SYMBOL_LEN)
-    name_len = MAX_DCL_SYMBOL_LEN;
-
-  strncpy (name, string, name_len);
-  name[name_len] = 0;
-
-  /* Skip past the "=" */
-  value++;
-
-  /* Export the symbol */
-  status = vms_export_dcl_symbol (name, value);
-
-  /* Convert the error to Unix format */
-  if (!$VMS_STATUS_SUCCESS (status))
-    {
-      errno = EVMSERR;
-      vaxc$errno = status;
-      return -1;
-    }
-  return 0;
-}
-
-#if __CRTL_VER >= 70301000
-# define transpath_parm transpath
-#else
-static char transpath[MAX_DCL_SYMBOL_VALUE];
-#endif
-
-/* Helper callback routine for converting Unix paths to VMS */
-static int
-to_vms_action (char * vms_spec, int flag, char * transpath_parm)
-{
-  strncpy (transpath, vms_spec, MAX_DCL_SYMBOL_VALUE - 1);
-  transpath[MAX_DCL_SYMBOL_VALUE - 1] = 0;
-  return 0;
-}
-
-#ifdef __DECC
-# pragma message save
-  /* Undocumented extra parameter use triggers a ptrmismatch warning */
-# pragma message disable ptrmismatch
-#endif
-
-/* Create a foreign command only visible to children */
-int
-create_foreign_command (const char * command, const char * image)
-{
-  char vms_command[MAX_DCL_SYMBOL_VALUE + 1];
-  int status;
-
-  vms_command[0] = '$';
-  vms_command[1] = 0;
-  if (image[0] == '/')
-    {
-#if __CRTL_VER >= 70301000
-      /* Current decc$to_vms is reentrant */
-      decc$to_vms (image, to_vms_action, 0, 1, &vms_command[1]);
-#else
-      /* Older decc$to_vms is not reentrant */
-      decc$to_vms (image, to_vms_action, 0, 1);
-      strncpy (&vms_command[1], transpath, MAX_DCL_SYMBOL_VALUE - 1);
-      vms_command[MAX_DCL_SYMBOL_VALUE] = 0;
-#endif
-    }
-  else
-    {
-      strncpy (&vms_command[1], image, MAX_DCL_SYMBOL_VALUE - 1);
-      vms_command[MAX_DCL_SYMBOL_VALUE] = 0;
-    }
-  status = vms_export_dcl_symbol (command, vms_command);
-
-  return status;
-}
-#ifdef __DECC
-# pragma message restore
-#endif
-
-
-#ifdef DEBUG
-
-int
-main(int argc, char ** argv, char **env)
-{
-
-  char value[MAX_DCL_SYMBOL_VALUE +1];
-  int status = 0;
-  int putenv_status;
-  int vms_status;
-  struct dsc$descriptor_s name_desc;
-  struct dsc$descriptor_s value_desc;
-  const unsigned long symtbl = LIB$K_CLI_LOCAL_SYM;
-  unsigned short value_len;
-  unsigned long old_symtbl;
-  int result;
-  const char * vms_command = "vms_export_symbol";
-  const char * vms_image = "test_image.exe";
-  const char * vms_symbol1 = "test_symbol1";
-  const char * value1 = "test_value1";
-  const char * vms_symbol2 = "test_symbol2";
-  const char * putenv_string = "test_symbol2=value2";
-  const char * value2 = "value2";
-
-  /* Test creating a foreign command */
-  vms_status = create_foreign_command (vms_command, vms_image);
-  if (!$VMS_STATUS_SUCCESS (vms_status))
-    {
-      printf("Create foreign command failed: %d\n", vms_status);
-      status = 1;
-    }
-
-  name_desc.dsc$a_pointer = (char *)vms_command;
-  name_desc.dsc$w_length = strlen (vms_command);
-  name_desc.dsc$b_dtype = DSC$K_DTYPE_T;
-  name_desc.dsc$b_class = DSC$K_CLASS_S;
-
-  value_desc.dsc$a_pointer = value;
-  value_desc.dsc$w_length = MAX_DCL_SYMBOL_VALUE;
-  value_desc.dsc$b_dtype = DSC$K_DTYPE_T;
-  value_desc.dsc$b_class = DSC$K_CLASS_S;
-
-  vms_status = LIB$GET_SYMBOL (&name_desc, &value_desc,
-                               &value_len, &old_symtbl);
-  if (!$VMS_STATUS_SUCCESS (vms_status))
-    {
-      printf ("lib$get_symbol for command failed: %d\n", vms_status);
-      status = 1;
-    }
-
-  value[value_len] = 0;
-  result = strncasecmp (&value[1], vms_image, value_len - 1);
-  if (result != 0)
-    {
-      printf ("create_foreign_command failed!  expected '%s', got '%s'\n",
-              vms_image, &value[1]);
-      status = 1;
-    }
-
-  /* Test exporting a symbol */
-  vms_status = vms_export_dcl_symbol (vms_symbol1, value1);
-  if (!$VMS_STATUS_SUCCESS (vms_status))
-    {
-      printf ("vms_export_dcl_symbol for command failed: %d\n", vms_status);
-      status = 1;
-    }
-
-  name_desc.dsc$a_pointer = (char *)vms_symbol1;
-  name_desc.dsc$w_length = strlen (vms_symbol1);
-  vms_status = LIB$GET_SYMBOL(&name_desc, &value_desc,
-                              &value_len, &old_symtbl);
-  if (!$VMS_STATUS_SUCCESS(vms_status))
-    {
-      printf ("lib$get_symbol for command failed: %d\n", vms_status);
-      status = 1;
-    }
-
-  value[value_len] = 0;
-  result = strncmp (value, value1, value_len);
-  if (result != 0)
-    {
-      printf ("vms_export_dcl_symbol failed!  expected '%s', got '%s'\n",
-              value1, value);
-      status = 1;
-    }
-
-  /* Test putenv for DCL symbols */
-  putenv_status = vms_putenv_symbol (putenv_string);
-  if (putenv_status != 0)
-    {
-      perror ("vms_putenv_symbol");
-      status = 1;
-    }
-
-  name_desc.dsc$a_pointer = (char *)vms_symbol2;
-  name_desc.dsc$w_length = strlen(vms_symbol2);
-  vms_status = LIB$GET_SYMBOL (&name_desc, &value_desc,
-                               &value_len, &old_symtbl);
-  if (!$VMS_STATUS_SUCCESS (vms_status))
-    {
-      printf ("lib$get_symbol for command failed: %d\n", vms_status);
-      status = 1;
-    }
-
-  value[value_len] = 0;
-  result = strncmp (value, value2, value_len);
-  if (result != 0)
-  {
-    printf ("vms_putenv_symbol failed!  expected '%s', got '%s'\n",
-            value2, value);
-    status = 1;
-  }
-
-  vms_restore_symbol (putenv_string);
-  vms_status = LIB$GET_SYMBOL (&name_desc, &value_desc,
-                               &value_len, &old_symtbl);
-  if ($VMS_STATUS_SUCCESS (vms_status))
-    {
-      printf ("lib$get_symbol for command succeeded, should have failed\n");
-      status = 1;
-    }
-
-  exit (status);
-}
-
-#endif
diff --git a/vms_progname.c b/vms_progname.c
deleted file mode 100644
index 47d12a7..0000000
--- a/vms_progname.c
+++ /dev/null
@@ -1,463 +0,0 @@
-/* File: vms_progname.c
- *
- * This module provides a fixup of the program name.
- *
- * This module is designed to be a plug in replacement for the
- * progname module used by many GNU utilities with a few enhancements
- * needed for GNU Make.
- *
- * It does not support the HAVE_DECL_PROGRAM_INVOCATION_* macros at this
- * time.
- *
- * Make sure that the program_name string is set as close as possible to
- *    what the original command was given.
- *
- * When run from DCL, The argv[0] element is initialized with an absolute
- * path name.  The decc$ feature logical names can control the format
- * of this pathname.  In some cases it causes the UNIX format name to be
- * formatted incorrectly.
- *
- * This DCL provided name is usually incompatible with what is expected to
- * be provided by Unix programs and needs to be replaced.
- *
- * When run from an exec() call, the argv[0] element is initialized by the
- * program.  This name is compatible with what is expected to be provided
- * by Unix programs and should be passed through unchanged.
- *
- * The DCL provided name can be detected because it always contains the
- * device name.
- *
- * DCL examples:
- *    devname:[dir]program.exe;1         Normal VMS - remove path and .EXE;n
- *    devname:[dir]facility$program.exe;1   Facility also needs removal.
- *    /devname/dir/program.exe
- *    /DISK$VOLUME/dir/program.exe.1     Bug version should not be there.
- *    /DISK$VOLUME/dir/program.          Bug Period should not be there.
- *
- */
-
-/* Copyright (C) 2014-2017 Free Software Foundation, Inc.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-
-/* Per copyright assignment agreement with the Free Software Foundation
-   this software may be available under under other license agreements
-   and copyrights. */
-
-
-#ifdef HAVE_CONFIG_H
-# include "config.h"
-#endif
-
-#include <stdio.h>
-#include <string.h>
-#include <ctype.h>
-#include <stdlib.h>
-
-#include <descrip.h>
-#include <dvidef.h>
-#include <efndef.h>
-#include <fscndef.h>
-#include <stsdef.h>
-
-#ifdef USE_PROGNAME_H
-# include "progname.h"
-#endif
-
-#pragma member_alignment save
-#pragma nomember_alignment longword
-struct item_list_3
-{
-  unsigned short len;
-  unsigned short code;
-  void * bufadr;
-  unsigned short * retlen;
-};
-
-struct filescan_itmlst_2
-{
-  unsigned short length;
-  unsigned short itmcode;
-  char * component;
-};
-
-#pragma member_alignment
-
-int
-SYS$GETDVIW (unsigned long efn,
-             unsigned short chan,
-             const struct dsc$descriptor_s * devnam,
-             const struct item_list_3 * itmlst,
-             void * iosb,
-             void (* astadr)(unsigned long),
-             unsigned long astprm,
-             void * nullarg);
-
-int
-SYS$FILESCAN (const struct dsc$descriptor_s * srcstr,
-              struct filescan_itmlst_2 * valuelist,
-              unsigned long * fldflags,
-              struct dsc$descriptor_s *auxout,
-              unsigned short * retlen);
-
-/* String containing name the program is called with.
-   To be initialized by main().  */
-
-const char *program_name = NULL;
-
-static int internal_need_vms_symbol = 0;
-
-static char vms_new_nam[256];
-
-int
-need_vms_symbol (void)
-{
-  return internal_need_vms_symbol;
-}
-
-
-void
-set_program_name (const char *argv0)
-{
-  int status;
-  int result;
-
-#ifdef DEBUG
-  printf ("original argv0 = %s\n", argv0);
-#endif
-
-  /* Posix requires non-NULL argv[0] */
-  if (argv0 == NULL)
-    {
-      fputs ("A NULL argv[0] was passed through an exec system call.\n",
-             stderr);
-      abort ();
-    }
-
-  program_name = argv0;
-  result = 0;
-  internal_need_vms_symbol = 0;
-
-  /* If the path name starts with a /, then it is an absolute path         */
-  /* that may have been generated by the CRTL instead of the command name  */
-  /* If it is the device name between the slashes, then this was likely    */
-  /* from the run command and needs to be fixed up.                        */
-  /* If the DECC$POSIX_COMPLIANT_PATHNAMES is set to 2, then it is the     */
-  /* DISK$VOLUME that will be present, and it will still need to be fixed. */
-  if (argv0[0] == '/')
-    {
-      char * nextslash;
-      int length;
-      struct item_list_3 itemlist[3];
-      unsigned short dvi_iosb[4];
-      char alldevnam[64];
-      unsigned short alldevnam_len;
-      struct dsc$descriptor_s devname_dsc;
-      char diskvolnam[256];
-      unsigned short diskvolnam_len;
-
-      internal_need_vms_symbol = 1;
-
-       /* Get some information about the disk */
-      /*--------------------------------------*/
-      itemlist[0].len = (sizeof alldevnam) - 1;
-      itemlist[0].code = DVI$_ALLDEVNAM;
-      itemlist[0].bufadr = alldevnam;
-      itemlist[0].retlen = &alldevnam_len;
-      itemlist[1].len = (sizeof diskvolnam) - 1 - 5;
-      itemlist[1].code = DVI$_VOLNAM;
-      itemlist[1].bufadr = &diskvolnam[5];
-      itemlist[1].retlen = &diskvolnam_len;
-      itemlist[2].len = 0;
-      itemlist[2].code = 0;
-
-      /* Add the prefix for the volume name. */
-      /* SYS$GETDVI will append the volume name to this */
-      strcpy (diskvolnam, "DISK$");
-
-      nextslash = strchr (&argv0[1], '/');
-      if (nextslash != NULL)
-        {
-          length = nextslash - argv0 - 1;
-
-          /* Cast needed for HP C compiler diagnostic */
-          devname_dsc.dsc$a_pointer = (char *)&argv0[1];
-          devname_dsc.dsc$w_length = length;
-          devname_dsc.dsc$b_dtype = DSC$K_DTYPE_T;
-          devname_dsc.dsc$b_class = DSC$K_CLASS_S;
-
-          status = SYS$GETDVIW (EFN$C_ENF, 0, &devname_dsc, itemlist,
-                                dvi_iosb, NULL, 0, 0);
-          if (!$VMS_STATUS_SUCCESS (status))
-            {
-              /* If the sys$getdviw fails, then this path was passed by */
-              /* An exec() program and not from DCL, so do nothing */
-              /* An example is "/tmp/program" where tmp: does not exist */
-#ifdef DEBUG
-              printf ("sys$getdviw failed with status %d\n", status);
-#endif
-              result = 0;
-             }
-           else if (!$VMS_STATUS_SUCCESS (dvi_iosb[0]))
-             {
-#ifdef DEBUG
-                printf ("sys$getdviw failed with iosb %d\n", dvi_iosb[0]);
-#endif
-                result = 0;
-              }
-            else
-              {
-                char * devnam;
-                int devnam_len;
-                char argv_dev[64];
-
-                /* Null terminate the returned alldevnam */
-                alldevnam[alldevnam_len] = 0;
-                devnam = alldevnam;
-                devnam_len = alldevnam_len;
-
-                /* Need to skip past any leading underscore */
-                if (devnam[0] == '_')
-                  {
-                    devnam++;
-                    devnam_len--;
-                  }
-
-                /* And remove the trailing colon */
-                if (devnam[devnam_len - 1] == ':')
-                  {
-                    devnam_len--;
-                    devnam[devnam_len] = 0;
-                  }
-
-                /* Null terminate the returned volnam */
-                diskvolnam_len += 5;
-                diskvolnam[diskvolnam_len] = 0;
-
-                /* Check first for normal CRTL behavior */
-                if (devnam_len == length)
-                  {
-                    strncpy (vms_new_nam, &argv0[1], length);
-                    vms_new_nam[length] = 0;
-                    result = (strcasecmp (devnam, vms_new_nam) == 0);
-                  }
-
-                /* If we have not got a match, check for POSIX Compliant */
-                /* behavior.  To be more accurate, we could also check */
-                /* to see if that feature is active. */
-                if ((result == 0) && (diskvolnam_len == length))
-                  {
-                    strncpy (vms_new_nam, &argv0[1], length);
-                    vms_new_nam[length] = 0;
-                    result = (strcasecmp (diskvolnam, vms_new_nam) == 0);
-                  }
-              }
-        }
-      }
-    else
-      {
-        /* The path did not start with a slash, so it could be VMS format */
-        /* If it is vms format, it has a volume/device in it as it must   */
-        /* be an absolute path */
-        struct dsc$descriptor_s path_desc;
-        int status;
-        unsigned long field_flags;
-        struct filescan_itmlst_2 item_list[5];
-        char * volume;
-        char * name;
-        int name_len;
-        char * ext;
-
-        path_desc.dsc$a_pointer = (char *)argv0; /* cast ok */
-        path_desc.dsc$w_length = strlen (argv0);
-        path_desc.dsc$b_dtype = DSC$K_DTYPE_T;
-        path_desc.dsc$b_class = DSC$K_CLASS_S;
-
-        /* Don't actually need to initialize anything buf itmcode */
-        /* I just do not like uninitialized input values */
-
-        /* Sanity check, this must be the same length as input */
-        item_list[0].itmcode = FSCN$_FILESPEC;
-        item_list[0].length = 0;
-        item_list[0].component = NULL;
-
-        /* If the device is present, then it if a VMS spec */
-        item_list[1].itmcode = FSCN$_DEVICE;
-        item_list[1].length = 0;
-        item_list[1].component = NULL;
-
-        /* we need the program name and type */
-        item_list[2].itmcode = FSCN$_NAME;
-        item_list[2].length = 0;
-        item_list[2].component = NULL;
-
-        item_list[3].itmcode = FSCN$_TYPE;
-        item_list[3].length = 0;
-        item_list[3].component = NULL;
-
-        /* End the list */
-        item_list[4].itmcode = 0;
-        item_list[4].length = 0;
-        item_list[4].component = NULL;
-
-        status = SYS$FILESCAN ((const struct dsc$descriptor_s *)&path_desc,
-                               item_list, &field_flags, NULL, NULL);
-
-
-        if ($VMS_STATUS_SUCCESS (status) &&
-           (item_list[0].length == path_desc.dsc$w_length) &&
-           (item_list[1].length != 0))
-          {
-
-            char * dollar;
-            int keep_ext;
-            int i;
-
-            /* We need the filescan to be successful, */
-            /* same length as input, and a volume to be present */
-            internal_need_vms_symbol = 1;
-
-            /* We will assume that we only get to this path on a version */
-            /* of VMS that does not support the EFS character set */
-
-            /* There may be a xxx$ prefix on the image name.  Linux */
-            /* programs do not handle that well, so strip the prefix */
-            name = item_list[2].component;
-            name_len = item_list[2].length;
-            dollar = strrchr (name, '$');
-            if (dollar != NULL)
-              {
-                dollar++;
-                name_len = name_len - (dollar - name);
-                name = dollar;
-              }
-
-            strncpy (vms_new_nam, name, name_len);
-            vms_new_nam[name_len] = 0;
-
-            /* Commit to using the new name */
-            program_name = vms_new_nam;
-
-            /* We only keep the extension if it is not ".exe" */
-            keep_ext = 0;
-            ext = item_list[3].component;
-
-            if (item_list[3].length != 1)
-              {
-                keep_ext = 1;
-                if (item_list[3].length == 4)
-                  {
-                    if ((ext[1] == 'e' || ext[1] == 'E') &&
-                        (ext[2] == 'x' || ext[2] == 'X') &&
-                        (ext[3] == 'e' || ext[3] == 'E'))
-                      keep_ext = 0;
-                  }
-              }
-
-            if (keep_ext == 1)
-              strncpy (&vms_new_nam[name_len], ext, item_list[3].length);
-          }
-      }
-
-    if (result)
-      {
-        char * lastslash;
-        char * dollar;
-        char * dotexe;
-        char * lastdot;
-        char * extension;
-
-        /* This means it is probably the name from a DCL command */
-        /* Find the last slash which separates the file from the */
-        /* path. */
-        lastslash = strrchr (argv0, '/');
-
-        if (lastslash != NULL) {
-            int i;
-
-            lastslash++;
-
-            /* There may be a xxx$ prefix on the image name.  Linux */
-            /* programs do not handle that well, so strip the prefix */
-            dollar = strrchr (lastslash, '$');
-
-            if (dollar != NULL) {
-                dollar++;
-                lastslash = dollar;
-            }
-
-            strcpy (vms_new_nam, lastslash);
-
-            /* In UNIX mode + EFS character set, there should not be a */
-            /* version present, as it is not possible when parsing to  */
-            /* tell if it is a version or part of the UNIX filename as */
-            /* UNIX programs use numeric extensions for many reasons.  */
-
-            lastdot = strrchr (vms_new_nam, '.');
-            if (lastdot != NULL) {
-                int i;
-
-                i = 1;
-                while (isdigit (lastdot[i])) {
-                    i++;
-                }
-                if (lastdot[i] == 0) {
-                    *lastdot = 0;
-                }
-            }
-
-            /* Find the .exe on the name (case insenstive) and toss it */
-            dotexe = strrchr (vms_new_nam, '.');
-            if (dotexe != NULL) {
-                if ((dotexe[1] == 'e' || dotexe[1] == 'E') &&
-                    (dotexe[2] == 'x' || dotexe[2] == 'X') &&
-                    (dotexe[3] == 'e' || dotexe[3] == 'E') &&
-                    (dotexe[4] == 0)) {
-
-                    *dotexe = 0;
-                } else {
-                     /* Also need to handle a null extension because of a */
-                     /* CRTL bug. */
-                     if (dotexe[1] == 0) {
-                         *dotexe = 0;
-                    }
-                }
-            }
-
-            /* Commit to new name */
-            program_name = vms_new_nam;
-
-        } else {
-            /* There is no way that the code should ever get here */
-            /* As we already verified that the '/' was present */
-            fprintf (stderr, "Sanity failure somewhere we lost a '/'\n");
-        }
-    }
-}
-
-#ifdef DEBUG
-
-int
-main (int argc, char ** argv, char **env)
-{
-
-  char command[1024];
-
-  set_program_name (argv[0]);
-
-  printf ("modified argv[0] = %s\n", program_name);
-
-  return 0;
-}
-#endif
diff --git a/vmsdir.h b/vmsdir.h
deleted file mode 100644
index f1d52d6..0000000
--- a/vmsdir.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/* dirent.h for vms
-Copyright (C) 1996-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#ifndef VMSDIR_H
-#define VMSDIR_H
-
-#include <rms.h>
-
-#define	MAXNAMLEN	255
-
-#ifndef __DECC
-#if !defined (__GNUC__) && !defined (__ALPHA)
-typedef unsigned long u_long;
-typedef unsigned short u_short;
-#endif
-#endif
-
-struct direct
-{
-  off_t d_off;
-  u_long d_fileno;
-  u_short d_reclen;
-  u_short d_namlen;
-  char d_name[MAXNAMLEN + 1];
-};
-
-#undef DIRSIZ
-#define DIRSIZ(dp)		\
-  (((sizeof (struct direct)	\
-     - (MAXNAMLEN+1)		\
-     + ((dp)->d_namlen+1))	\
-    + 3) & ~3)
-
-#define d_ino	d_fileno		/* compatibility */
-
-
-/*
- * Definitions for library routines operating on directories.
- */
-
-typedef struct DIR
-{
-  struct direct dir;
-  char d_result[MAXNAMLEN + 1];
-#if defined (__ALPHA) || defined (__DECC)
-  struct FAB fab;
-#else
-  struct fabdef fab;
-#endif
-} DIR;
-
-#ifndef NULL
-#define NULL 0
-#endif
-
-#define rewinddir(dirp)	seekdir((dirp), (long)0)
-
-DIR *opendir ();
-struct direct *readdir (DIR *dfd);
-int closedir (DIR *dfd);
-const char *vmsify (const char *name, int type);
-
-#endif /* VMSDIR_H */
diff --git a/vmsfunctions.c b/vmsfunctions.c
deleted file mode 100644
index 356524d..0000000
--- a/vmsfunctions.c
+++ /dev/null
@@ -1,226 +0,0 @@
-/* VMS functions
-Copyright (C) 1996-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-#include "debug.h"
-#include "job.h"
-
-#include <ctype.h>
-#include <string.h>
-
-#ifdef __DECC
-#include <starlet.h>
-#endif
-
-#include <rms.h>
-#include "vmsdir.h"
-
-#ifdef HAVE_VMSDIR_H
-
-DIR *
-opendir (char *dspec)
-{
-  struct DIR *dir  = xcalloc (sizeof (struct DIR));
-  struct NAM *dnam = xmalloc (sizeof (struct NAM));
-  struct FAB *dfab = &dir->fab;
-  char *searchspec = xmalloc (MAXNAMLEN + 1);
-
-  *dfab = cc$rms_fab;
-  *dnam = cc$rms_nam;
-  sprintf (searchspec, "%s*.*;", dspec);
-
-  dfab->fab$l_fna = searchspec;
-  dfab->fab$b_fns = strlen (searchspec);
-  dfab->fab$l_nam = dnam;
-
-  *dnam = cc$rms_nam;
-  dnam->nam$l_esa = searchspec;
-  dnam->nam$b_ess = MAXNAMLEN;
-
-  if (! (sys$parse (dfab) & 1))
-    {
-      free (dir);
-      free (dnam);
-      free (searchspec);
-      return (NULL);
-    }
-
-  return dir;
-}
-
-#define uppercasify(str) \
-  do \
-    { \
-      char *tmp; \
-      for (tmp = (str); *tmp != '\0'; tmp++) \
-        if (islower ((unsigned char)*tmp)) \
-          *tmp = toupper ((unsigned char)*tmp); \
-    } \
-  while (0)
-
-struct direct *
-readdir (DIR *dir)
-{
-  struct FAB *dfab = &dir->fab;
-  struct NAM *dnam = (struct NAM *)(dfab->fab$l_nam);
-  struct direct *dentry = &dir->dir;
-  int i;
-
-  memset (dentry, 0, sizeof *dentry);
-
-  dnam->nam$l_rsa = dir->d_result;
-  dnam->nam$b_rss = MAXNAMLEN;
-
-  DB (DB_VERBOSE, ("."));
-
-  if (!((i = sys$search (dfab)) & 1))
-    {
-      DB (DB_VERBOSE, (_("sys$search() failed with %d\n"), i));
-      return (NULL);
-    }
-
-  dentry->d_off = 0;
-  if (dnam->nam$w_fid == 0)
-    dentry->d_fileno = 1;
-  else
-    dentry->d_fileno = dnam->nam$w_fid[0] + (dnam->nam$w_fid[1] << 16);
-
-  dentry->d_reclen = sizeof (struct direct);
-  dentry->d_namlen = dnam->nam$b_name + dnam->nam$b_type;
-  strncpy (dentry->d_name, dnam->nam$l_name, dentry->d_namlen);
-  dentry->d_name[dentry->d_namlen] = '\0';
-
-#ifdef HAVE_CASE_INSENSITIVE_FS
-  uppercasify (dentry->d_name);
-#endif
-
-  return (dentry);
-}
-
-int
-closedir (DIR *dir)
-{
-  if (dir != NULL)
-    {
-      struct FAB *dfab = &dir->fab;
-      struct NAM *dnam = (struct NAM *)(dfab->fab$l_nam);
-      if (dnam != NULL)
-        free (dnam->nam$l_esa);
-      free (dnam);
-      free (dir);
-    }
-
-  return 0;
-}
-#endif /* compiled for OpenVMS prior to V7.x */
-
-/* Argv0 will be a full vms file specification, like
-   node$dka100:[utils.gnumake]make.exe;47
-   prefix it with "mcr " to make it a vms command, executable for DCL. */
-const char *
-vms_command(const char* argv0)
-{
-  size_t l = strlen(argv0) + 1;
-  char* s = xmalloc(l + 4);
-  memcpy(s, "mcr ", 4);
-  memcpy(s+4, argv0, l);
-  return s;
-}
-
-/* Argv0 aka argv[0] will be a full vms file specification, like
-   node$dka100:[utils.gnumake]make.exe;47, set up by the CRTL.
-   The vms progname should be ^^^^, the file name without
-   file type .exe and ;version.
-   Use sys$parse to get the name part of the file specification. That is
-   in the above example, pick up "make" and return a copy of that string.
-   If something goes wrong in sys$parse (unlikely, this is a VMS/CRTL supplied
-   file specification) or if there is an empty name part (not easy to produce,
-   but it is possible) just return "make".
-   Somes notes ...
-   NAM[L]$M_SYNCHK requests a syntax check, only.
-   NAM is for ODS2 names (shorter parts, output usually converted to UPPERCASE).
-   NAML is for ODS2/ODS5 names (longer parts, output unchanged).
-   NAM$M_NO_SHORT_UPCASE may not be available for older versions of VMS.
-   NAML is not available on older versions of VMS (NAML$C_BID not defined).
-   argv[0] on older versions of VMS (no extended parse style and no
-   CRTL feature DECC$ARGV_PARSE_STYLE) is always in lowercase. */
-const char *
-vms_progname(const char* argv0)
-{
-  int status;
-  static struct FAB fab;
-  char *progname;
-  const char *fallback = "make";
-
-#ifdef NAML$C_BID
-  static char esa[NAML$C_MAXRSS];
-  static struct NAML naml;
-#else
-  static char esa[NAM$C_MAXRSS];
-  static struct NAM nam;
-#endif
-
-  fab = cc$rms_fab;
-  fab.fab$l_fna = (char*)argv0;
-  fab.fab$b_fns = strlen(argv0);
-
-#ifdef NAML$C_BID
-  fab.fab$l_naml = &naml;
-  naml = cc$rms_naml;
-  naml.naml$l_long_expand = esa;
-  naml.naml$l_long_expand_alloc = NAML$C_MAXRSS;
-  naml.naml$b_nop = NAML$M_SYNCHK;
-  naml.naml$l_input_flags = NAML$M_NO_SHORT_OUTPUT;
-#else
-  fab.fab$l_nam = &nam;
-  nam = cc$rms_nam;
-  nam.nam$l_esa = esa;
-  nam.nam$b_ess = NAM$C_MAXRSS;
-# ifdef NAM$M_NO_SHORT_UPCASE
-  nam.nam$b_nop = NAM$M_SYNCHK | NAM$M_NO_SHORT_UPCASE;
-# else
-  nam.nam$b_nop = NAM$M_SYNCHK;
-# endif
-#endif
-
-  status = sys$parse(&fab);
-  if (!(status & 1))
-    return fallback;
-
-#ifdef NAML$C_BID
-  if (naml.naml$l_long_name_size == 0)
-    return fallback;
-  progname = xmalloc(naml.naml$l_long_name_size + 1);
-  memcpy(progname, naml.naml$l_long_name, naml.naml$l_long_name_size);
-  progname[naml.naml$l_long_name_size] = '\0';
-#else
-  if (nam.nam$b_name == 0)
-    return fallback;
-  progname = xmalloc(nam.nam$b_name + 1);
-# ifdef NAM$M_NO_SHORT_UPCASE
-  memcpy(progname, nam.nam$l_name, nam.nam$b_name);
-# else
-    {
-      int i;
-      for (i = 0; i < nam.nam$b_name; i++)
-        progname[i] = tolower(nam.nam$l_name[i]);
-    }
-# endif
-  progname[nam.nam$b_name] = '\0';
-#endif
-
-  return progname;
-}
diff --git a/vmsify.c b/vmsify.c
deleted file mode 100644
index 249aa06..0000000
--- a/vmsify.c
+++ /dev/null
@@ -1,1005 +0,0 @@
-/* vmsify.c -- Module for vms <-> unix file name conversion
-Copyright (C) 1996-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-/* Written by Klaus Kmpf (kkaempf@progis.de)
-   of proGIS Software, Aachen, Germany */
-
-
-#include <stdio.h>
-#include <string.h>
-#include <ctype.h>
-
-#include "makeint.h"
-
-#if VMS
-#include <unixlib.h>
-#include <stdlib.h>
-#include <jpidef.h>
-#include <descrip.h>
-#include <uaidef.h>
-#include <ssdef.h>
-#include <starlet.h>
-#include <lib$routines.h>
-/* Initialize a string descriptor (struct dsc$descriptor_s) for an
-   arbitrary string.   ADDR is a pointer to the first character
-   of the string, and LEN is the length of the string. */
-
-#define INIT_DSC_S(dsc, addr, len) do { \
-  (dsc).dsc$b_dtype = DSC$K_DTYPE_T;    \
-  (dsc).dsc$b_class = DSC$K_CLASS_S;    \
-  (dsc).dsc$w_length = (len);           \
-  (dsc).dsc$a_pointer = (addr);         \
-} while (0)
-
-/* Initialize a string descriptor (struct dsc$descriptor_s) for a
-   NUL-terminated string.  S is a pointer to the string; the length
-   is determined by calling strlen(). */
-
-#define INIT_DSC_CSTRING(dsc, s) INIT_DSC_S(dsc, s, strlen(s))
-#endif
-
-/*
-  copy 'from' to 'to' up to but not including 'upto'
-  return 0 if eos on from
-  return 1 if upto found
-
-  return 'to' at last char + 1
-  return 'from' at match + 1 or eos if no match
-
-  if as_dir == 1, change all '.' to '_'
-  else change all '.' but the last to '_'
-*/
-
-static int
-copyto (char **to, const char **from, char upto, int as_dir)
-{
-  const char *s;
-
-  s = strrchr (*from, '.');
-
-  while (**from)
-    {
-      if (**from == upto)
-	{
-	  do
-	    {
-	      (*from)++;
-	    }
-	  while (**from == upto);
-	  return 1;
-	}
-      if (**from == '.')
-	{
-	  if ((as_dir == 1)
-	      || (*from != s))
-	    **to = '_';
-	  else
-	    **to = '.';
-	}
-      else
-	{
-#ifdef HAVE_CASE_INSENSITIVE_FS
-	  if (isupper ((unsigned char)**from))
-	    **to = tolower ((unsigned char)**from);
-	  else
-#endif
-	    **to = **from;
-	}
-      (*to)++;
-      (*from)++;
-    }
-
-  return 0;
-}
-
-
-/*
-  get translation of logical name
-
-*/
-
-static char *
-trnlog (const char *name)
-{
-  int stat;
-  static char reslt[1024];
-  $DESCRIPTOR (reslt_dsc, reslt);
-  short resltlen;
-  struct dsc$descriptor_s name_dsc;
-  char *s;
-
-  /*
-   * the string isn't changed, but there is no string descriptor with
-   * "const char *dsc$a_pointer"
-   */
-  INIT_DSC_CSTRING (name_dsc, (char *)name);
-
-  stat = lib$sys_trnlog (&name_dsc, &resltlen, &reslt_dsc);
-
-  if ((stat&1) == 0)
-    {
-      return "";
-    }
-  if (stat == SS$_NOTRAN)
-    {
-      return "";
-    }
-  reslt[resltlen] = '\0';
-
-  s = xmalloc (resltlen+1);
-  strcpy (s, reslt);
-  return s;
-}
-
-static char *
-showall (char *s)
-{
-  static char t[512];
-  char *pt;
-
-  pt = t;
-  if (strchr (s, '\\') == 0)
-    return s;
-  while (*s)
-    {
-      if (*s == '\\')
-	{
-	  *pt++ = *s;
-	}
-      *pt++ = *s++;
-    }
-  return pt;
-}
-
-
-enum namestate { N_START, N_DEVICE, N_OPEN, N_DOT, N_CLOSED, N_DONE };
-
-/*
-  convert unix style name to vms style
-  type = 0 -> name is a full name (directory and filename part)
-  type = 1 -> name is a directory
-  type = 2 -> name is a filename without directory
-
-  The following conversions are applied
-			(0)		(1)			(2)
-	input		full name	dir name		file name
-
-1	./		<cwd>		[]			<current directory>.dir
-2	../		<home of cwd>	<home of cwd>		<home of cwd>.dir
-
-3	//		<dev of cwd>:	<dev of cwd>:[000000]	<dev of cwd>:000000.dir
-4	//a		a:		a:			a:
-5	//a/		a:		a:			a:000000.dir
-
-9	/		[000000]	[000000]		000000.dir
-10	/a		[000000]a	[a]			[000000]a
-11	/a/		[a]		[a]			[000000]a.dir
-12	/a/b		[a]b		[a.b]			[a]b
-13	/a/b/		[a.b]		[a.b]			[a]b.dir
-14	/a/b/c		[a.b]c		[a.b.c]			[a.b]c
-15	/a/b/c/		[a.b.c]		[a.b.c]			[a.b]c.dir
-
-16	a		a		[.a]			a
-17	a/		[.a]		[.a]			a.dir
-18	a/b		[.a]b		[.a.b]			[.a]b
-19	a/b/		[.a.b]		[.a.b]			[.a]b.dir
-20	a/b/c		[.a.b]c		[.a.b.c]		[.a.b]c
-21	a/b/c/		[.a.b.c]	[.a.b.c]		[.a.b]c.dir
-
-22	a.b.c		a_b.c		[.a_b_c]		a_b_c.dir
-
-23	[x][y]z		[x.y]z		[x.y]z			[x.y]z
-24	[x][.y]z	[x.y]z		[x.y]z			[x.y]z
-
-25  filenames with '$'  are left unchanged if they contain no '/'
-25  filenames with ':' are left unchanged
-26  filenames with a single pair of '[' ']' are left unchanged
-
-  The input string is not written to.  The result is also const because
-  it's a static buffer; we don't want to change it.
-*/
-
-const char *
-vmsify (const char *name, int type)
-{
-/* max 255 device
-   max 39 directory
-   max 39 filename
-   max 39 filetype
-   max 5 version
-*/
-/* todo: VMSMAXPATHLEN is defined for ODS2 names: it needs to be adjusted. */
-#define VMSMAXPATHLEN 512
-
-  enum namestate nstate;
-  static char vmsname[VMSMAXPATHLEN+1];
-  const char *fptr;
-  const char *t;
-  char *vptr;
-  int as_dir;
-  int count;
-  const char *s;
-  const char *s1;
-  const char *s2;
-
-  if (name == 0)
-    return 0;
-  fptr = name;
-  vptr = vmsname;
-  nstate = N_START;
-
-  /* case 25a */
-  t = strpbrk (name, "$:");
-
-  if (t != 0)
-    {
-//      const char *s1;
-//      const char *s2;
-
-      if (type == 1)
-        {
-          s1 = strchr (t+1, '[');
-          s2 = strchr (t+1, ']');
-        }
-
-      if (*t == '$')
-        {
-          if (strchr (name, '/') == 0)
-            {
-              strcpy (vmsname, name);
-              if ((type == 1) && (s1 != 0) && (s2 == 0))
-                strcat (vmsname, "]");
-              return vmsname;
-            }
-        }
-      else
-        {
-          strcpy (vmsname, name);
-          if ((type == 1) && (s1 != 0) && (s2 == 0))
-            strcat (vmsname, "]");
-          return vmsname;
-        }
-    }
-
-  /* case 26 */
-  t = strchr (name, '[');
-
-  if (t != 0)
-    {
-//      const char *s;
-//      const char *s1 = strchr (t+1, '[');
-      s1 = strchr (t+1, '[');
-      if (s1 == 0)
-	{
-          strcpy (vmsname, name);
-	  if ((type == 1) && (strchr (t+1, ']') == 0))
-            strcat (vmsname, "]");
-          return vmsname;
-	}
-      s1--;
-      if (*s1 != ']')
-	{
-          strcpy (vmsname, name);
-	  return vmsname;		/* not ][, keep unchanged */
-	}
-
-      /* we have ][ */
-
-      s = name;
-
-      /* s  -> starting char
-	 s1 -> ending ']'  */
-      do
-	{
-	  strncpy (vptr, s, s1-s);	/* copy up to but not including ']' */
-	  vptr += s1-s;
-	  if (*s1 == 0)
-	    break;
-	  s = s1 + 1;			/* s -> char behind ']' */
-	  if (*s != '[')		/* was '][' ? */
-	    break;			/* no, last ] found, exit */
-	  s++;
-	  if (*s != '.')
-	    *vptr++ = '.';
-	  s1 = strchr (s, ']');
-	  if (s1 == 0)			/* no closing ] */
-	    s1 = s + strlen (s);
-	}
-      while (1);
-
-      *vptr++ = ']';
-
-      fptr = s;
-
-    }
-  else		/* no [ in name */
-    {
-      int state = 0;
-      int rooted = 1;	/* flag if logical is rooted, else insert [000000] */
-
-      do
-	{
-      switch (state)
-	{
-	  case 0:				/* start of loop */
-	    if (*fptr == '/')
-	      {
-		fptr++;
-		state = 1;
-	      }
-	    else if (*fptr == '.')
-	      {
-		fptr++;
-		state = 10;
-	      }
-	    else
-	      state = 2;
-	    break;
-
-	  case 1:				/* '/' at start */
-	    if (*fptr == '/')
-	      {
-		fptr++;
-		state = 3;
-	      }
-	    else
-	      state = 4;
-	    break;
-
-	  case 2:				/* no '/' at start */
-            {
-            const char *s = strchr (fptr, '/');
-	    if (s == 0)			/* no '/' (16) */
-	      {
-		if (type == 1)
-		  {
-		    strcpy (vptr, "[.");
-		    vptr += 2;
-		  }
-		copyto (&vptr, &fptr, 0, (type==1));
-		if (type == 1)
-		  *vptr++ = ']';
-		state = -1;
-	      }
-	    else			/* found '/' (17..21) */
-	      {
-		if ((type == 2)
-		    && (*(s+1) == 0))	/* 17(2) */
-		  {
-		    copyto (&vptr, &fptr, '/', 1);
-		    state = 7;
-		  }
-		else
-		  {
-		    strcpy (vptr, "[.");
-		    vptr += 2;
-		    copyto (&vptr, &fptr, '/', 1);
-		    nstate = N_OPEN;
-		    state = 9;
-		  }
-	      }
-	    break;
-            }
-
-	  case 3:				/* '//' at start */
-            {
-//            const char *s;
-//            const char *s1;
-            char *vp;
-	    while (*fptr == '/')	/* collapse all '/' */
-	      fptr++;
-	    if (*fptr == 0)		/* just // */
-	      {
-		char cwdbuf[VMSMAXPATHLEN+1];
-
-		s1 = getcwd(cwdbuf, VMSMAXPATHLEN);
-		if (s1 == 0)
-		  {
-                    vmsname[0] = '\0';
-		    return vmsname;	/* FIXME, err getcwd */
-		  }
-		s = strchr (s1, ':');
-		if (s == 0)
-		  {
-                    vmsname[0] = '\0';
-		    return vmsname;	/* FIXME, err no device */
-		  }
-		strncpy (vptr, s1, s-s1+1);
-		vptr += s-s1+1;
-		state = -1;
-		break;
-	      }
-
-	    s = vptr;
-
-	    if (copyto (&vptr, &fptr, '/', 1) == 0)	/* copy device part */
-	      {
-		*vptr++ = ':';
-		state = -1;
-		break;
-	      }
-	    *vptr = ':';
-	    nstate = N_DEVICE;
-	    if (*fptr == 0)	/* just '//a/' */
-	      {
-		strcpy (vptr+1, "[000000]");
-		vptr += 9;
-		state = -1;
-		break;
-	      }
-	    *vptr = 0;
-				/* check logical for [000000] insertion */
-	    vp = trnlog (s);
-	    if (*vp != '\0')
-	      {			/* found translation */
-		for (;;)	/* loop over all nested logicals */
-		  {
-		    char *vp2 = vp + strlen (vp) - 1;
-		    if (*vp2 == ':')	/* translation ends in ':' */
-		      {
-			vp2 = trnlog (vp);
-			free (vp);
-			if (*vp2 == 0)
-			  {
-			    rooted = 0;
-			    break;
-			  }
-			vp = vp2;
-			continue;	/* next iteration */
-		      }
-		    if (*vp2 == ']')	/* translation ends in ']' */
-		      {
-			if (*(vp2-1) == '.')	/* ends in '.]' */
-			  {
-			    if (strncmp (fptr, "000000", 6) != 0)
-			      rooted = 0;
-			  }
-			else
-			  {
-			    strcpy (vmsname, s1);
-			    vp = strchr (vmsname, ']');
-			    *vp = '.';
-			    nstate = N_DOT;
-			    vptr = vp;
-			  }
-		      }
-		    break;
-		  }
-		free (vp);
-	      }
-	    else
-	      rooted = 0;
-
-	    if (*vptr == 0)
-	      {
-		nstate = N_DEVICE;
-	        *vptr++ = ':';
-	      }
-	    else
-	      vptr++;
-
-	    if (rooted == 0)
-	      {
-		nstate = N_DOT;
-	        strcpy (vptr, "[000000.");
-		vptr += 8;
-		vp = vptr-1;
-	      }
-	    else
-	      vp = 0;
-
-            /* vp-> '.' after 000000 or NULL */
-
-	    s = strchr (fptr, '/');
-	    if (s == 0)
-	      {				/* no next '/' */
-		if (*(vptr-1) == '.')
-		  *(vptr-1) = ']';
-		else if (rooted == 0)
-		  *vptr++ = ']';
-		copyto (&vptr, &fptr, 0, (type == 1));
-		state = -1;
-		break;
-	      }
-	    else
-	      {
-		while (*(s+1) == '/')	/* skip multiple '/' */
-		  s++;
-	      }
-
-	    if ((rooted != 0)
-	        && (*(vptr-1) != '.'))
-	      {
-		*vptr++ = '[';
-		nstate = N_DOT;
-	      }
-	    else
-	      if ((nstate == N_DOT)
-		 && (vp != 0)
-		 && (*(s+1) == 0))
-		{
-		  if (type == 2)
-		    {
-		      *vp = ']';
-		      nstate = N_CLOSED;
-		    }
-		}
-	    state = 9;
-	    break;
-            }
-	  case 4:				/* single '/' at start (9..15) */
-	    if (*fptr == 0)
-	      state = 5;
-	    else
-	      state = 6;
-	    break;
-
-	  case 5:				/* just '/' at start (9) */
-	    if (type != 2)
-	      {
-	        *vptr++ = '[';
-		nstate = N_OPEN;
-	      }
-	    strcpy (vptr, "000000");
-	    vptr += 6;
-	    if (type == 2)
-	      state = 7;
-	    else
-	      state = 8;
-	    break;
-
-	  case 6:		/* chars following '/' at start 10..15 */
-            {
-            const char *s;
-	    *vptr++ = '[';
-	    nstate = N_OPEN;
-	    s = strchr (fptr, '/');
-	    if (s == 0)			/* 10 */
-	      {
-		if (type != 1)
-		  {
-		    strcpy (vptr, "000000]");
-		    vptr += 7;
-		  }
-		copyto (&vptr, &fptr, 0, (type == 1));
-		if (type == 1)
-		  {
-		    *vptr++ = ']';
-		  }
-		state = -1;
-	      }
-	    else			/* 11..15 */
-	      {
-		if ( (type == 2)
-		   && (*(s+1) == 0))	/* 11(2) */
-		  {
-		    strcpy (vptr, "000000]");
-		    nstate = N_CLOSED;
-		    vptr += 7;
-		  }
-		copyto (&vptr, &fptr, '/', (*(vptr-1) != ']'));
-		state = 9;
-	      }
-	    break;
-            }
-
-	  case 7:				/* add '.dir' and exit */
-	    if ((nstate == N_OPEN)
-		|| (nstate == N_DOT))
-	      {
-		char *vp = vptr-1;
-		while (vp > vmsname)
-		  {
-		    if (*vp == ']')
-		      {
-			break;
-		      }
-		    if (*vp == '.')
-		      {
-			*vp = ']';
-			break;
-		      }
-		    vp--;
-		  }
-	      }
-	    strcpy (vptr, ".dir");
-	    vptr += 4;
-	    state = -1;
-	    break;
-
-	  case 8:				/* add ']' and exit */
-	    *vptr++ = ']';
-	    state = -1;
-	    break;
-
-	  case 9:			/* 17..21, fptr -> 1st '/' + 1 */
-            {
-            const char *s;
-	    if (*fptr == 0)
-	      {
-		if (type == 2)
-		  {
-		    state = 7;
-		  }
-		else
-		  state = 8;
-		break;
-	      }
-	    s = strchr (fptr, '/');
-	    if (s == 0)
-	      {
-		if (type != 1)
-		  {
-		    if (nstate == N_OPEN)
-		      {
-			*vptr++ = ']';
-			nstate = N_CLOSED;
-		      }
-		    as_dir = 0;
-		  }
-		else
-		  {
-		    if (nstate == N_OPEN)
-		      {
-			*vptr++ = '.';
-			nstate = N_DOT;
-		      }
-		    as_dir = 1;
-		  }
-	      }
-	    else
-	      {
-		while (*(s+1) == '/')
-		  s++;
-		if ( (type == 2)
-		    && (*(s+1) == 0))		/* 19(2), 21(2)*/
-		  {
-		    if (nstate != N_CLOSED)
-		      {
-			*vptr++ = ']';
-			nstate = N_CLOSED;
-		      }
-		    as_dir = 1;
-		  }
-		else
-		  {
-		    if (nstate == N_OPEN)
-		      {
-			*vptr++ = '.';
-			nstate = N_DOT;
-		      }
-		    as_dir = 1;
-		  }
-	      }
-	    if ( (*fptr == '.')			/* check for '..' or '../' */
-		&& (*(fptr+1) == '.')
-		&& ((*(fptr+2) == '/')
-		    || (*(fptr+2) == 0)) )
-	      {
-                char *vp;
-		fptr += 2;
-		if (*fptr == '/')
-		  {
-		    do
-		      {
-			fptr++;
-		      }
-		    while (*fptr == '/');
-		  }
-		else if (*fptr == 0)
-		  type = 1;
-		vptr--;				/* vptr -> '.' or ']' */
-		vp = vptr;
-		for (;;)
-		  {
-		    vp--;
-		    if (*vp == '.')		/* one back */
-		      {
-			vptr = vp;
-			nstate = N_OPEN;
-			break;
-		      }
-		    if (*vp == '[')		/* top level reached */
-		      {
-			if (*fptr == 0)
-			  {
-			    strcpy (vp, "[000000]");
-			    vptr = vp + 8;
-			    nstate = N_CLOSED;
-			    s = 0;
-			    break;
-			  }
-			else
-			  {
-			    vptr = vp+1;
-			    nstate = N_OPEN;
-			    break;
-			  }
-		      }
-		  }
-	      }
-	    else
-	      {
-		copyto (&vptr, &fptr, '/', as_dir);
-		if (nstate == N_DOT)
-		  nstate = N_OPEN;
-	      }
-	    if (s == 0)
-	      {					/* 18,20 */
-		if (type == 1)
-		  *vptr++ = ']';
-		state = -1;
-	      }
-	    else
-	      {
-		if (*(s+1) == 0)
-		  {
-		    if (type == 2)		/* 19,21 */
-		      {
-		        state = 7;
-		      }
-		    else
-		      {
-			*vptr++ = ']';
-			state = -1;
-		      }
-		  }
-	      }
-	    break;
-            }
-
-	  case 10:				/* 1,2 first is '.' */
-	    if (*fptr == '.')
-	      {
-		fptr++;
-		state = 11;
-	      }
-	    else
-	      state = 12;
-	    break;
-
-	  case 11:				/* 2, '..' at start */
-	    count = 1;
-	    if (*fptr != 0)
-	      {
-		if (*fptr != '/')		/* got ..xxx */
-		  {
-                    strcpy (vmsname, name);
-		    return vmsname;
-		  }
-		do				/* got ../ */
-		  {
-		    fptr++;
-		    while (*fptr == '/') fptr++;
-		    if (*fptr != '.')
-		      break;
-		    if (*(fptr+1) != '.')
-		      break;
-		    fptr += 2;
-		    if ((*fptr == 0)
-			|| (*fptr == '/'))
-		      count++;
-		  }
-		while (*fptr == '/');
-	      }
-	    {					/* got '..' or '../' */
-              char *vp;
-	      char cwdbuf[VMSMAXPATHLEN+1];
-
-	      vp = getcwd(cwdbuf, VMSMAXPATHLEN);
-	      if (vp == 0)
-		{
-                  vmsname[0] = '\0';
-		  return vmsname;    /* FIXME, err getcwd */
-		}
-	      strcpy (vptr, vp);
-	      vp = strchr (vptr, ']');
-	      if (vp != 0)
-		{
-		  nstate = N_OPEN;
-		  while (vp > vptr)
-		    {
-		      vp--;
-		      if (*vp == '[')
-			{
-			  vp++;
-			  strcpy (vp, "000000]");
-			  state = -1;
-			  break;
-			}
-		      else if (*vp == '.')
-			{
-			  if (--count == 0)
-			    {
-			      if (*fptr == 0)	/* had '..' or '../' */
-				{
-				  *vp++ = ']';
-				  state = -1;
-				}
-			      else			/* had '../xxx' */
-				{
-				  state = 9;
-				}
-			      *vp = '\0';
-			      break;
-			    }
-			}
-		    }
-		}
-	      vptr += strlen (vptr);
-	    }
-	    break;
-
-	  case 12:				/* 1, '.' at start */
-	    if (*fptr != 0)
-	      {
-		if (*fptr != '/')
-		  {
-                    strcpy (vmsname, name);
-		    return vmsname;
-		  }
-		while (*fptr == '/')
-		  fptr++;
-	      }
-
-	    {
-              char *vp;
-	      char cwdbuf[VMSMAXPATHLEN+1];
-
-	      vp = getcwd(cwdbuf, VMSMAXPATHLEN);
-	      if (vp == 0)
-		{
-                  vmsname[0] = '\0';
-		  return vmsname;    /*FIXME, err getcwd */
-		}
-	      strcpy (vptr, vp);
-            }
-            if (*fptr == 0)
-              {
-                state = -1;
-                break;
-              }
-            else
-              {
-                char *vp = strchr (vptr, ']');
-                if (vp == 0)
-                  {
-                    state = -1;
-                    break;
-                  }
-                *vp = '\0';
-                nstate = N_OPEN;
-                vptr += strlen (vptr);
-                state = 9;
-              }
-	    break;
-	}
-
-	}
-      while (state > 0);
-
-
-    }
-
-
-  /* directory conversion done
-     fptr -> filename part of input string
-     vptr -> free space in vmsname
-  */
-
-  *vptr++ = 0;
-
-  return vmsname;
-}
-
-
-
-/*
-  convert from vms-style to unix-style
-
-  dev:[dir1.dir2]	//dev/dir1/dir2/
-*/
-
-const char *
-unixify (const char *name)
-{
-  static char piece[512];
-  const char *s;
-  char *p;
-
-  if (strchr (name, '/') != 0)		/* already in unix style */
-    {
-      strcpy (piece, name);
-      return piece;
-    }
-
-  p = piece;
-  *p = 0;
-
-  /* device part */
-
-  s = strchr (name, ':');
-
-  if (s != 0)
-    {
-      int l = s - name;
-      *p++ = '/';
-      *p++ = '/';
-      strncpy (p, name, l);
-      p += l;
-    }
-
-  /* directory part */
-
-  *p++ = '/';
-  s = strchr (name, '[');
-
-  if (s != 0)
-    {
-      s++;
-      switch (*s)
-        {
-	  case ']':		/* [] */
-	    strcat (p, "./");
-	    break;
-	  case '-':		/* [- */
-	    strcat (p, "../");
-	    break;
-	  case '.':
-	    strcat (p, "./");	/* [. */
-	    break;
-	  default:
-	    s--;
-	    break;
-        }
-      s++;
-      while (*s)
-        {
-	  if (*s == '.')
-	    *p++ = '/';
-	  else
-	    *p++ = *s;
-	  s++;
-	  if (*s == ']')
-	    {
-	      s++;
-	      break;
-	    }
-        }
-      if (*s != 0)		/* more after ']' ?? */
-        {
-	  if (*(p-1) != '/')
-	    *p++ = '/';
-	  strcpy (p, s);		/* copy it anyway */
-        }
-    }
-
-  else		/* no '[' anywhere */
-
-    {
-      *p++ = 0;
-    }
-
-  /* force end with '/' */
-
-  if (*(p-1) != '/')
-    *p++ = '/';
-  *p = 0;
-
-  return piece;
-}
-
-/* EOF */
diff --git a/vmsjobs.c b/vmsjobs.c
deleted file mode 100644
index 717861d..0000000
--- a/vmsjobs.c
+++ /dev/null
@@ -1,1468 +0,0 @@
-/* --------------- Moved here from job.c ---------------
-   This file must be #included in job.c, as it accesses static functions.
-
-Copyright (C) 1996-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include <string.h>
-#include <descrip.h>
-#include <clidef.h>
-
-/* TODO - VMS specific header file conditionally included in makeint.h */
-
-#include <stsdef.h>
-#include <ssdef.h>
-void
-decc$exit (int status);
-
-/* Lowest legal non-success VMS exit code is 8 */
-/* GNU make only defines codes 0, 1, 2 */
-/* So assume any exit code > 8 is a VMS exit code */
-
-#ifndef MAX_EXPECTED_EXIT_CODE
-# define MAX_EXPECTED_EXIT_CODE 7
-#endif
-
-
-#if __CRTL_VER >= 70302000 && !defined(__VAX)
-# define MAX_DCL_LINE_LENGTH 4095
-# define MAX_DCL_CMD_LINE_LENGTH 8192
-#else
-# define MAX_DCL_LINE_LENGTH 255
-# define MAX_DCL_CMD_LINE_LENGTH 1024
-#endif
-#define MAX_DCL_TOKEN_LENGTH 255
-#define MAX_DCL_TOKENS 127
-
-enum auto_pipe { nopipe, add_pipe, dcl_pipe };
-
-char *vmsify (char *name, int type);
-
-static int vms_jobsefnmask = 0;
-
-/* returns whether path is assumed to be a unix like shell. */
-int
-_is_unixy_shell (const char *path)
-{
-  return vms_gnv_shell;
-}
-
-#define VMS_GETMSG_MAX 256
-static char vms_strsignal_text[VMS_GETMSG_MAX + 2];
-
-char *
-vms_strsignal (int status)
-{
-  if (status <= MAX_EXPECTED_EXIT_CODE)
-    sprintf (vms_strsignal_text, "lib$spawn returned %x", status);
-  else
-    {
-      int vms_status;
-      unsigned short * msg_len;
-      unsigned char out[4];
-      vms_status = SYS$GETMSG (status, &msg_len,
-                               vms_strsignal_text, 7, *out);
-    }
-
-  return vms_strsignal_text;
-}
-
-
-/* Wait for nchildren children to terminate */
-static void
-vmsWaitForChildren (int *status)
-{
-  while (1)
-    {
-      if (!vms_jobsefnmask)
-        {
-          *status = 0;
-          return;
-        }
-
-      *status = sys$wflor (32, vms_jobsefnmask);
-    }
-  return;
-}
-
-static int ctrlYPressed= 0;
-/* This is called at main or AST level. It is at AST level for DONTWAITFORCHILD
-   and at main level otherwise. In any case it is called when a child process
-   terminated. At AST level it won't get interrupted by anything except a
-   inner mode level AST.
-*/
-static int
-vmsHandleChildTerm (struct child *child)
-{
-  int exit_code;
-  struct child *lastc, *c;
-  int child_failed;
-
-  /* The child efn is 0 when a built-in or null command is executed
-     successfully with out actually creating a child.
-  */
-  if (child->efn > 0)
-  {
-    vms_jobsefnmask &= ~(1 << (child->efn - 32));
-
-    lib$free_ef (&child->efn);
-  }
-  if (child->comname)
-    {
-      if (!ISDB (DB_JOBS) && !ctrlYPressed)
-        unlink (child->comname);
-      free (child->comname);
-    }
-
-  (void) sigblock (fatal_signal_mask);
-
-  /* First check to see if this is a POSIX exit status and handle */
-  if ((child->cstatus & VMS_POSIX_EXIT_MASK) == VMS_POSIX_EXIT_MASK)
-    {
-      exit_code = (child->cstatus >> 3) & 255;
-      if (exit_code != MAKE_SUCCESS)
-        child_failed = 1;
-    }
-  else
-    {
-      child_failed = !$VMS_STATUS_SUCCESS (child->cstatus);
-      if (child_failed)
-        exit_code = child->cstatus;
-    }
-
-  /* Search for a child matching the deceased one.  */
-  lastc = 0;
-#if defined(RECURSIVEJOBS)
-  /* I've had problems with recursive stuff and process handling */
-  for (c = children; c != 0 && c != child; lastc = c, c = c->next)
-    ;
-#else
-  c = child;
-#endif
-
-  if ($VMS_STATUS_SUCCESS (child->vms_launch_status))
-    {
-      /* Convert VMS success status to 0 for UNIX code to be happy */
-      child->vms_launch_status = 0;
-    }
-
-  /* Set the state flag to say the commands have finished.  */
-  c->file->command_state = cs_finished;
-  notice_finished_file (c->file);
-
-  (void) sigsetmask (sigblock (0) & ~(fatal_signal_mask));
-
-  return 1;
-}
-
-/* VMS:
-   Spawn a process executing the command in ARGV and return its pid. */
-
-/* local helpers to make ctrl+c and ctrl+y working, see below */
-#include <iodef.h>
-#include <libclidef.h>
-#include <ssdef.h>
-
-static int ctrlMask= LIB$M_CLI_CTRLY;
-static int oldCtrlMask;
-static int setupYAstTried= 0;
-static unsigned short int chan= 0;
-
-static void
-reEnableAst(void)
-{
-  lib$enable_ctrl (&oldCtrlMask,0);
-}
-
-static int
-astYHandler (void)
-{
-  struct child *c;
-  for (c = children; c != 0; c = c->next)
-    sys$delprc (&c->pid, 0, 0);
-  ctrlYPressed= 1;
-  kill (getpid(),SIGQUIT);
-  return SS$_NORMAL;
-}
-
-static void
-tryToSetupYAst(void)
-{
-  $DESCRIPTOR(inputDsc,"SYS$COMMAND");
-  int     status;
-  struct {
-    short int       status, count;
-    int     dvi;
-  } iosb;
-  unsigned short int loc_chan;
-
-  setupYAstTried++;
-
-  if (chan)
-    loc_chan= chan;
-  else
-    {
-      status= sys$assign(&inputDsc,&loc_chan,0,0);
-      if (!(status&SS$_NORMAL))
-        {
-          lib$signal(status);
-          return;
-        }
-    }
-  status= sys$qiow (0, loc_chan, IO$_SETMODE|IO$M_CTRLYAST,&iosb,0,0,
-                    astYHandler,0,0,0,0,0);
-  if (status==SS$_NORMAL)
-    status= iosb.status;
-  if (status!=SS$_NORMAL)
-    {
-      if (!chan)
-        sys$dassgn(loc_chan);
-      if (status!=SS$_ILLIOFUNC && status!=SS$_NOPRIV)
-        lib$signal(status);
-      return;
-    }
-
-  /* called from AST handler ? */
-  if (setupYAstTried>1)
-    return;
-  if (atexit(reEnableAst))
-    fprintf (stderr,
-             _("-warning, you may have to re-enable CTRL-Y handling from DCL.\n"));
-  status= lib$disable_ctrl (&ctrlMask, &oldCtrlMask);
-  if (!(status&SS$_NORMAL))
-    {
-      lib$signal(status);
-      return;
-    }
-  if (!chan)
-    chan = loc_chan;
-}
-
-/* Check if a token is too long */
-#define INC_TOKEN_LEN_OR_RETURN(x) {token->length++; \
-  if (token->length >= MAX_DCL_TOKEN_LENGTH) \
-    { token->cmd_errno = ERANGE; return x; }}
-
-#define INC_TOKEN_LEN_OR_BREAK {token->length++; \
-  if (token->length >= MAX_DCL_TOKEN_LENGTH) \
-    { token->cmd_errno = ERANGE; break; }}
-
-#define ADD_TOKEN_LEN_OR_RETURN(add_len, x) {token->length += add_len; \
-  if (token->length >= MAX_DCL_TOKEN_LENGTH) \
-    { token->cmd_errno = ERANGE; return x; }}
-
-/* Check if we are out of space for more tokens */
-#define V_NEXT_TOKEN { if (cmd_tkn_index < MAX_DCL_TOKENS) \
-  cmd_tokens[++cmd_tkn_index] = NULL; \
-  else { token.cmd_errno = E2BIG; break; } \
-  token.length = 0;}
-
-
-#define UPDATE_TOKEN {cmd_tokens[cmd_tkn_index] = strdup(token.text); \
-  V_NEXT_TOKEN;}
-
-#define EOS_ERROR(x) { if (*x == 0) { token->cmd_errno = ERANGE; break; }}
-
-struct token_info
-  {
-    char *text;       /* Parsed text */
-    int length;       /* Length of parsed text */
-    char *src;        /* Pointer to source text */
-    int cmd_errno;    /* Error status of parse */
-    int use_cmd_file; /* Force use of a command file */
-  };
-
-
-/* Extract a Posix single quoted string from input line */
-static char *
-posix_parse_sq (struct token_info *token)
-{
-  /* A Posix quoted string with no expansion unless in a string
-     Unix simulation means no lexical functions present.
-  */
-  char * q;
-  char * p;
-  q = token->text;
-  p = token->src;
-
-  *q++ = '"';
-  p++;
-  INC_TOKEN_LEN_OR_RETURN (p);
-
-  while (*p != '\'' && (token->length < MAX_DCL_TOKEN_LENGTH))
-    {
-      EOS_ERROR (p);
-      if (*p == '"')
-        {
-          /* Embedded double quotes need to be doubled */
-          *q++ = '"';
-          INC_TOKEN_LEN_OR_BREAK;
-          *q = '"';
-        }
-      else
-        *q = *p;
-
-      q++;
-      p++;
-      INC_TOKEN_LEN_OR_BREAK;
-    }
-  *q++ = '"';
-  p++;
-  INC_TOKEN_LEN_OR_RETURN (p);
-  *q = 0;
-  return p;
-}
-
-/* Extract a Posix double quoted string from input line */
-static char *
-posix_parse_dq (struct token_info *token)
-{
-  /* Unix mode:  Any imbedded \" becomes doubled.
-                 \t is tab, \\, \$ leading character stripped.
-                 $ character replaced with \' unless escaped.
-  */
-  char * q;
-  char * p;
-  q = token->text;
-  p = token->src;
-  *q++ = *p++;
-  INC_TOKEN_LEN_OR_RETURN (p);
-  while (*p != 0)
-    {
-      if (*p == '\\')
-        {
-          switch(p[1])
-            {
-            case 't':     /* Convert tabs */
-              *q = '\t';
-              p++;
-              break;
-            case '\\':     /* Just remove leading backslash */
-            case '$':
-              p++;
-              *q = *p;
-              break;
-            case '"':
-              p++;
-              *q = *p;
-              *q++ = '"';
-              INC_TOKEN_LEN_OR_BREAK;
-            default:      /* Pass through unchanged */
-              *q++ = *p++;
-              INC_TOKEN_LEN_OR_BREAK;
-            }
-          INC_TOKEN_LEN_OR_BREAK;
-        }
-      else if (*p == '$' && isalpha (p[1]))
-        {
-          /* A symbol we should be able to substitute */
-          *q++ = '\'';
-          INC_TOKEN_LEN_OR_BREAK;
-          *q = '\'';
-          INC_TOKEN_LEN_OR_BREAK;
-          token->use_cmd_file = 1;
-        }
-      else
-        {
-          *q = *p;
-          INC_TOKEN_LEN_OR_BREAK;
-          if (*p == '"')
-            {
-              p++;
-              q++;
-              break;
-            }
-        }
-      p++;
-      q++;
-    }
-  *q = 0;
-  return p;
-}
-
-/* Extract a VMS quoted string or substitution string from input line */
-static char *
-vms_parse_quotes (struct token_info *token)
-{
-  /* VMS mode, the \' means that a symbol substitution is starting
-     so while you might think you can just copy until the next
-     \'.  Unfortunately the substitution can be a lexical function
-     which can contain embedded strings and lexical functions.
-     Messy, so both types need to be handled together.
-  */
-  char * q;
-  char * p;
-  q = token->text;
-  p = token->src;
-  int parse_level[MAX_DCL_TOKENS + 1];
-  int nest = 0;
-
-  parse_level[0] = *p;
-  if (parse_level[0] == '\'')
-    token->use_cmd_file = 1;
-
-  *q++ = *p++;
-  INC_TOKEN_LEN_OR_RETURN (p);
-
-
-  /* Copy everything until after the next single quote at nest == 0 */
-  while (token->length < MAX_DCL_TOKEN_LENGTH)
-    {
-      EOS_ERROR (p);
-      *q = *p;
-      INC_TOKEN_LEN_OR_BREAK;
-      if ((*p == parse_level[nest]) && (p[1] != '"'))
-        {
-          if (nest == 0)
-            {
-              *q++ = *p++;
-              break;
-            }
-          nest--;
-        }
-      else
-        {
-          switch(*p)
-            {
-            case '\\':
-              /* Handle continuation on to next line */
-              if (p[1] != '\n')
-                break;
-              p++;
-              p++;
-              *q = *p;
-              break;
-            case '(':
-              /* Parenthesis only in single quote level */
-              if (parse_level[nest] == '\'')
-                {
-                  nest++;
-                  parse_level[nest] == ')';
-                }
-              break;
-            case '"':
-              /* Double quotes only in parenthesis */
-              if (parse_level[nest] == ')')
-                {
-                  nest++;
-                  parse_level[nest] == '"';
-                }
-              break;
-            case '\'':
-              /* Symbol substitution ony in double quotes */
-              if ((p[1] == '\'') && (parse_level[nest] == '"'))
-                {
-                  nest++;
-                  parse_level[nest] == '\'';
-                  *p++ = *q++;
-                  token->use_cmd_file = 1;
-                  INC_TOKEN_LEN_OR_BREAK;
-                  break;
-                }
-              *q = *p;
-            }
-        }
-      p++;
-      q++;
-      /* Pass through doubled double quotes */
-      if ((*p == '"') && (p[1] == '"') && (parse_level[nest] == '"'))
-      {
-        *p++ = *q++;
-        INC_TOKEN_LEN_OR_BREAK;
-        *p++ = *q++;
-        INC_TOKEN_LEN_OR_BREAK;
-      }
-    }
-  *q = 0;
-  return p;
-}
-
-/* Extract a $ string from the input line */
-static char *
-posix_parse_dollar (struct token_info *token)
-{
-  /* $foo becomes 'foo' */
-  char * q;
-  char * p;
-  q = token->text;
-  p = token->src;
-  token->use_cmd_file = 1;
-
-  p++;
-  *q++ = '\'';
-  INC_TOKEN_LEN_OR_RETURN (p);
-
-  while ((isalnum (*p)) || (*p == '_'))
-    {
-      *q++ = *p++;
-      INC_TOKEN_LEN_OR_BREAK;
-    }
-  *q++ = '\'';
-  while (1)
-    {
-      INC_TOKEN_LEN_OR_BREAK;
-      break;
-    }
-  *q = 0;
-  return p;
-}
-
-const char *vms_filechars = "0123456789abcdefghijklmnopqrstuvwxyz" \
-   "ABCDEFGHIJKLMNOPQRSTUVWXYZ[]<>:/_-.$";
-
-/* Simple text copy */
-static char *
-parse_text (struct token_info *token, int assignment_hack)
-{
-  char * q;
-  char * p;
-  int str_len;
-  q = token->text;
-  p = token->src;
-
-  /* If assignment hack, then this text needs to be double quoted. */
-  if (vms_unix_simulation && (assignment_hack == 2))
-    {
-      *q++ = '"';
-      INC_TOKEN_LEN_OR_RETURN (p);
-    }
-
-  *q++ = *p++;
-  INC_TOKEN_LEN_OR_RETURN (p);
-
-  while (*p != 0)
-    {
-      str_len = strspn (p, vms_filechars);
-      if (str_len == 0)
-        {
-          /* Pass through backslash escapes in Unix simulation
-             probably will not work anyway.
-             All any character after a ^ otherwise to support EFS.
-          */
-          if (vms_unix_simulation && (p[0] == '\\') && (p[1] != 0))
-            str_len = 2;
-          else if ((p[0] == '^') && (p[1] != 0))
-            str_len = 2;
-          else if (!vms_unix_simulation && (p[0] == ';'))
-            str_len = 1;
-
-          if (str_len == 0)
-            {
-              /* If assignment hack, then this needs to be double quoted. */
-              if (vms_unix_simulation && (assignment_hack == 2))
-              {
-                *q++ = '"';
-                INC_TOKEN_LEN_OR_RETURN (p);
-              }
-              *q = 0;
-              return p;
-            }
-        }
-      if (str_len > 0)
-        {
-          ADD_TOKEN_LEN_OR_RETURN (str_len, p);
-          strncpy (q, p, str_len);
-          p += str_len;
-          q += str_len;
-          *q = 0;
-        }
-    }
-  /* If assignment hack, then this text needs to be double quoted. */
-  if (vms_unix_simulation && (assignment_hack == 2))
-    {
-      *q++ = '"';
-      INC_TOKEN_LEN_OR_RETURN (p);
-    }
-  return p;
-}
-
-/* single character copy */
-static char *
-parse_char (struct token_info *token, int count)
-{
-  char * q;
-  char * p;
-  q = token->text;
-  p = token->src;
-
-  while (count > 0)
-    {
-      *q++ = *p++;
-      INC_TOKEN_LEN_OR_RETURN (p);
-      count--;
-    }
-  *q = 0;
-  return p;
-}
-
-/* Build a command string from the collected tokens
-   and process built-ins now
-*/
-static struct dsc$descriptor_s *
-build_vms_cmd (char **cmd_tokens,
-               enum auto_pipe use_pipe_cmd,
-               int append_token)
-{
-  struct dsc$descriptor_s *cmd_dsc;
-  int cmd_tkn_index;
-  char * cmd;
-  int cmd_len;
-  int semicolon_seen;
-
-  cmd_tkn_index = 0;
-  cmd_dsc = xmalloc (sizeof (struct dsc$descriptor_s));
-
-  /* Empty command? */
-  if (cmd_tokens[0] == NULL)
-    {
-      cmd_dsc->dsc$a_pointer = NULL;
-      cmd_dsc->dsc$w_length = 0;
-      return cmd_dsc;
-    }
-
-  /* Max DCL command + 1 extra token and trailing space */
-  cmd = xmalloc (MAX_DCL_CMD_LINE_LENGTH + 256);
-
-  cmd[0] = '$';
-  cmd[1] = 0;
-  cmd_len = 1;
-
-  /* Handle real or auto-pipe */
-  if (use_pipe_cmd == add_pipe)
-    {
-      /* We need to auto convert to a pipe command */
-      strcat (cmd, "pipe ");
-      cmd_len += 5;
-    }
-
-  semicolon_seen = 0;
-  while (cmd_tokens[cmd_tkn_index] != NULL)
-    {
-
-      /* Check for buffer overflow */
-      if (cmd_len > MAX_DCL_CMD_LINE_LENGTH)
-        {
-          errno = E2BIG;
-          break;
-        }
-
-      /* Eliminate double ';' */
-      if (semicolon_seen && (cmd_tokens[cmd_tkn_index][0] == ';'))
-        {
-          semicolon_seen = 0;
-          free (cmd_tokens[cmd_tkn_index++]);
-          if (cmd_tokens[cmd_tkn_index] == NULL)
-            break;
-        }
-
-      /* Special handling for CD built-in */
-      if (strncmp (cmd_tokens[cmd_tkn_index], "builtin_cd", 11) == 0)
-        {
-          int result;
-          semicolon_seen = 0;
-          free (cmd_tokens[cmd_tkn_index]);
-          cmd_tkn_index++;
-          if (cmd_tokens[cmd_tkn_index] == NULL)
-            break;
-          DB(DB_JOBS, (_("BUILTIN CD %s\n"), cmd_tokens[cmd_tkn_index]));
-
-          /* TODO: chdir fails with some valid syntaxes */
-          result = chdir (cmd_tokens[cmd_tkn_index]);
-          if (result != 0)
-            {
-              /* TODO: Handle failure better */
-              free (cmd);
-              while (cmd_tokens[cmd_tkn_index] == NULL)
-                free (cmd_tokens[cmd_tkn_index++]);
-              cmd_dsc->dsc$w_length = -1;
-              cmd_dsc->dsc$a_pointer = NULL;
-              return cmd_dsc;
-            }
-        }
-      else if (strncmp (cmd_tokens[cmd_tkn_index], "exit", 5) == 0)
-        {
-          /* Copy the exit command */
-          semicolon_seen = 0;
-          strcpy (&cmd[cmd_len], cmd_tokens[cmd_tkn_index]);
-          cmd_len += strlen (cmd_tokens[cmd_tkn_index]);
-          free (cmd_tokens[cmd_tkn_index++]);
-          if (cmd_len > MAX_DCL_CMD_LINE_LENGTH)
-            {
-              errno = E2BIG;
-              break;
-            }
-
-          /* Optional whitespace */
-          if (isspace (cmd_tokens[cmd_tkn_index][0]))
-            {
-              strcpy (&cmd[cmd_len], cmd_tokens[cmd_tkn_index]);
-              cmd_len += strlen (cmd_tokens[cmd_tkn_index]);
-              free (cmd_tokens[cmd_tkn_index++]);
-              if (cmd_len > MAX_DCL_CMD_LINE_LENGTH)
-              {
-                errno = E2BIG;
-                break;
-              }
-            }
-
-          /* There should be a status, but it is optional */
-          if (cmd_tokens[cmd_tkn_index][0] == ';')
-            continue;
-
-          /* If Unix simulation, add '((' */
-          if (vms_unix_simulation)
-            {
-              strcpy (&cmd[cmd_len], "((");
-              cmd_len += 2;
-              if (cmd_len > MAX_DCL_CMD_LINE_LENGTH)
-                {
-                  errno = E2BIG;
-                  break;
-                }
-            }
-
-          /* Add the parameter */
-          strcpy (&cmd[cmd_len], cmd_tokens[cmd_tkn_index]);
-          cmd_len += strlen (cmd_tokens[cmd_tkn_index]);
-          free (cmd_tokens[cmd_tkn_index++]);
-          if (cmd_len > MAX_DCL_CMD_LINE_LENGTH)
-            {
-              errno = E2BIG;
-              break;
-            }
-
-          /* Add " * 8) .and. %x7f8) .or. %x1035a002" */
-          if (vms_unix_simulation)
-            {
-              const char *end_str = " * 8) .and. %x7f8) .or. %x1035a002";
-              strcpy (&cmd[cmd_len], end_str);
-              cmd_len += strlen (end_str);
-              if (cmd_len > MAX_DCL_CMD_LINE_LENGTH)
-                {
-                  errno = E2BIG;
-                  break;
-                }
-            }
-          continue;
-        }
-
-      /* auto pipe needs spaces before semicolon */
-      if (use_pipe_cmd == add_pipe)
-        if (cmd_tokens[cmd_tkn_index][0] == ';')
-          {
-            cmd[cmd_len++] = ' ';
-            semicolon_seen = 1;
-            if (cmd_len > MAX_DCL_CMD_LINE_LENGTH)
-              {
-                errno = E2BIG;
-                break;
-              }
-          }
-        else
-          {
-            char ch;
-            ch = cmd_tokens[cmd_tkn_index][0];
-            if (!(ch == ' ' || ch == '\t'))
-              semicolon_seen = 0;
-          }
-
-      strcpy (&cmd[cmd_len], cmd_tokens[cmd_tkn_index]);
-      cmd_len += strlen (cmd_tokens[cmd_tkn_index]);
-
-      free (cmd_tokens[cmd_tkn_index++]);
-
-      /* Skip the append tokens if they exist */
-      if (cmd_tkn_index == append_token)
-        {
-          free (cmd_tokens[cmd_tkn_index++]);
-          if (isspace (cmd_tokens[cmd_tkn_index][0]))
-            free (cmd_tokens[cmd_tkn_index++]);
-          free (cmd_tokens[cmd_tkn_index++]);
-        }
-    }
-
-  cmd[cmd_len] = 0;
-  cmd_dsc->dsc$w_length = cmd_len;
-  cmd_dsc->dsc$a_pointer = cmd;
-  cmd_dsc->dsc$b_dtype = DSC$K_DTYPE_T;
-  cmd_dsc->dsc$b_class = DSC$K_CLASS_S;
-
-  return cmd_dsc;
-}
-
-int
-child_execute_job (struct child *child, char *argv)
-{
-  int i;
-
-  static struct dsc$descriptor_s *cmd_dsc;
-  static struct dsc$descriptor_s pnamedsc;
-  int spflags = CLI$M_NOWAIT;
-  int status;
-  int comnamelen;
-  char procname[100];
-
-  char *p;
-  char *cmd_tokens[(MAX_DCL_TOKENS * 2) + 1]; /* whitespace does not count */
-  char token_str[MAX_DCL_TOKEN_LENGTH + 1];
-  struct token_info token;
-  int cmd_tkn_index;
-  int paren_level = 0;
-  enum auto_pipe use_pipe_cmd = nopipe;
-  int append_token = -1;
-  char *append_file = NULL;
-  int unix_echo_cmd = 0;  /* Special handle Unix echo command */
-  int assignment_hack = 0; /* Handle x=y command as piped command */
-
-  /* Parse IO redirection.  */
-
-  child->comname = NULL;
-
-  DB (DB_JOBS, ("child_execute_job (%s)\n", argv));
-
-  while (isspace ((unsigned char)*argv))
-    argv++;
-
-  if (*argv == 0)
-    {
-      /* Only a built-in or a null command - Still need to run term AST */
-      child->cstatus = VMS_POSIX_EXIT_MASK;
-      child->vms_launch_status = SS$_NORMAL;
-      /* TODO what is this "magic number" */
-      child->pid = 270163; /* Special built-in */
-      child->efn = 0;
-      vmsHandleChildTerm (child);
-      return 1;
-    }
-
-  sprintf (procname, "GMAKE_%05x", getpid () & 0xfffff);
-  pnamedsc.dsc$w_length = strlen (procname);
-  pnamedsc.dsc$a_pointer = procname;
-  pnamedsc.dsc$b_dtype = DSC$K_DTYPE_T;
-  pnamedsc.dsc$b_class = DSC$K_CLASS_S;
-
-  /* Old */
-  /* Handle comments and redirection.
-     For ONESHELL, the redirection must be on the first line. Any other
-     redirection token is handled by DCL, that is, the pipe command with
-     redirection can be used, but it should not be used on the first line
-     for ONESHELL. */
-
-  /* VMS parser notes:
-     1. A token is any of DCL verbs, qualifiers, parameters, or punctuation.
-     2. Only MAX_DCL_TOKENS per line in both one line or command file mode.
-     3. Each token limited to MAC_DCL_TOKEN_LENGTH
-     4. If the line to DCL is greater than MAX_DCL_LINE_LENGTH then a
-        command file must be used.
-     5. Currently a command file must be used symbol substitution is to
-        be performed.
-     6. Currently limiting command files to 2 * MAX_DCL_TOKENS.
-
-     Build both a command file token list and command line token list
-     until it is determined that the command line limits are exceeded.
-  */
-
-  cmd_tkn_index = 0;
-  cmd_tokens[cmd_tkn_index] = NULL;
-  p = argv;
-
-  token.text = token_str;
-  token.length = 0;
-  token.cmd_errno = 0;
-  token.use_cmd_file = 0;
-
-  while (*p != 0)
-    {
-      /* We can not build this command so give up */
-      if (token.cmd_errno != 0)
-        break;
-
-      token.src = p;
-
-      switch (*p)
-        {
-        case '\'':
-          if (vms_unix_simulation || unix_echo_cmd)
-            {
-              p = posix_parse_sq (&token);
-              UPDATE_TOKEN;
-              break;
-            }
-
-          /* VMS mode, the \' means that a symbol substitution is starting
-             so while you might think you can just copy until the next
-             \'.  Unfortunately the substitution can be a lexical function
-             which can contain embedded strings and lexical functions.
-             Messy.
-          */
-          p = vms_parse_quotes (&token);
-          UPDATE_TOKEN;
-          break;
-        case '"':
-          if (vms_unix_simulation)
-            {
-              p = posix_parse_dq (&token);
-              UPDATE_TOKEN;
-              break;
-            }
-
-          /* VMS quoted string, can contain lexical functions with
-             quoted strings and nested lexical functions.
-          */
-          p = vms_parse_quotes (&token);
-          UPDATE_TOKEN;
-          break;
-
-        case '$':
-          if (vms_unix_simulation)
-            {
-              p = posix_parse_dollar (&token);
-              UPDATE_TOKEN;
-              break;
-            }
-
-          /* Otherwise nothing special */
-          p = parse_text (&token, 0);
-          UPDATE_TOKEN;
-          break;
-        case '\\':
-          if (p[1] == '\n')
-            {
-              /* Line continuation, remove it */
-              p += 2;
-              break;
-            }
-
-          /* Ordinary character otherwise */
-          if (assignment_hack != 0)
-            assignment_hack++;
-          if (assignment_hack > 2)
-            {
-              assignment_hack = 0;          /* Reset */
-              if (use_pipe_cmd == nopipe)   /* force pipe use */
-                use_pipe_cmd = add_pipe;
-              token_str[0] = ';';              /* add ; token */
-              token_str[1] = 0;
-              UPDATE_TOKEN;
-            }
-          p = parse_text (&token, assignment_hack);
-          UPDATE_TOKEN;
-          break;
-        case '!':
-        case '#':
-          /* Unix '#' is VMS '!' which comments out the rest of the line.
-             Historically the rest of the line has been skipped.
-             Not quite the right thing to do, as the f$verify lexical
-             function works in comments.  But this helps keep the line
-             lengths short.
-          */
-          unix_echo_cmd = 0;
-          while (*p != '\n' && *p != 0)
-            p++;
-          break;
-        case '(':
-          /* Subshell, equation, or lexical function argument start */
-          p = parse_char (&token, 1);
-          UPDATE_TOKEN;
-          paren_level++;
-          break;
-        case ')':
-          /* Close out a paren level */
-          p = parse_char (&token, 1);
-          UPDATE_TOKEN;
-          paren_level--;
-          /* TODO: Should we diagnose if paren_level goes negative? */
-          break;
-        case '&':
-          if (isalpha (p[1]) && !vms_unix_simulation)
-            {
-              /* VMS symbol substitution */
-              p = parse_text (&token, 0);
-              token.use_cmd_file = 1;
-              UPDATE_TOKEN;
-              break;
-            }
-          if (use_pipe_cmd == nopipe)
-            use_pipe_cmd = add_pipe;
-          if (p[1] != '&')
-            p = parse_char (&token, 1);
-          else
-            p = parse_char (&token, 2);
-          UPDATE_TOKEN;
-          break;
-        case '|':
-          if (use_pipe_cmd == nopipe)
-            use_pipe_cmd = add_pipe;
-          if (p[1] != '|')
-            p = parse_char (&token, 1);
-          else
-            p = parse_char (&token, 2);
-          UPDATE_TOKEN;
-          break;
-        case ';':
-          /* Separator - convert to a pipe command. */
-          unix_echo_cmd = 0;
-        case '<':
-          if (use_pipe_cmd == nopipe)
-            use_pipe_cmd = add_pipe;
-          p = parse_char (&token, 1);
-          UPDATE_TOKEN;
-          break;
-        case '>':
-          if (use_pipe_cmd == nopipe)
-            use_pipe_cmd = add_pipe;
-          if (p[1] == '>')
-            {
-              /* Parsing would have been simple until support for the >>
-                 append redirect was added.
-                 Implementation needs:
-                 * if not exist output file create empty
-                 * open/append gnv$make_temp??? output_file
-                 * define/user sys$output gnv$make_temp???
-                 ** And all this done before the command previously tokenized.
-                 * command previously tokenized
-                 * close gnv$make_temp???
-              */
-              p = parse_char (&token, 2);
-              append_token = cmd_tkn_index;
-              token.use_cmd_file = 1;
-            }
-          else
-            p = parse_char (&token, 1);
-          UPDATE_TOKEN;
-          break;
-        case '/':
-          /* Unix path or VMS option start, read until non-path symbol */
-          if (assignment_hack != 0)
-            assignment_hack++;
-          if (assignment_hack > 2)
-            {
-              assignment_hack = 0;          /* Reset */
-              if (use_pipe_cmd == nopipe)   /* force pipe use */
-                use_pipe_cmd = add_pipe;
-              token_str[0] = ';';              /* add ; token */
-              token_str[1] = 0;
-              UPDATE_TOKEN;
-            }
-          p = parse_text (&token, assignment_hack);
-          UPDATE_TOKEN;
-          break;
-        case ':':
-          if ((p[1] == 0) || isspace (p[1]))
-            {
-              /* Unix Null command - treat as comment until next command */
-              unix_echo_cmd = 0;
-              p++;
-              while (*p != 0)
-                {
-                  if (*p == ';')
-                    {
-                      /* Remove Null command from pipeline */
-                      p++;
-                      break;
-                    }
-                  p++;
-                }
-              break;
-            }
-
-          /* String assignment */
-          /* := :== or : */
-          if (p[1] != '=')
-            p = parse_char (&token, 1);
-          else if (p[2] != '=')
-            p = parse_char (&token, 2);
-          else
-            p = parse_char (&token, 3);
-          UPDATE_TOKEN;
-          break;
-        case '=':
-          /* = or == */
-          /* If this is not an echo statement, this could be a shell
-             assignment.  VMS requires the target to be quoted if it
-             is not a macro substitution */
-          if (!unix_echo_cmd && vms_unix_simulation && (assignment_hack == 0))
-            assignment_hack = 1;
-          if (p[1] != '=')
-            p = parse_char (&token, 1);
-          else
-            p = parse_char (&token, 2);
-          UPDATE_TOKEN;
-          break;
-        case '+':
-        case '-':
-        case '*':
-          p = parse_char (&token, 1);
-          UPDATE_TOKEN;
-          break;
-        case '.':
-          /* .xxx. operation, VMS does not require the trailing . */
-          p = parse_text (&token, 0);
-          UPDATE_TOKEN;
-          break;
-        default:
-          /* Skip repetitive whitespace */
-          if (isspace (*p))
-            {
-              p = parse_char (&token, 1);
-
-              /* Force to a space or a tab */
-              if ((token_str[0] != ' ') ||
-                  (token_str[0] != '\t'))
-                token_str[0] = ' ';
-              UPDATE_TOKEN;
-
-              while (isspace (*p))
-                p++;
-              if (assignment_hack != 0)
-                assignment_hack++;
-              break;
-            }
-
-          if (assignment_hack != 0)
-            assignment_hack++;
-          if (assignment_hack > 2)
-            {
-              assignment_hack = 0;          /* Reset */
-              if (use_pipe_cmd == nopipe)   /* force pipe use */
-                use_pipe_cmd = add_pipe;
-              token_str[0] = ';';              /* add ; token */
-              token_str[1] = 0;
-              UPDATE_TOKEN;
-            }
-          p = parse_text (&token, assignment_hack);
-          if (strncasecmp (token.text, "echo", 4) == 0)
-            unix_echo_cmd = 1;
-          else if (strncasecmp (token.text, "pipe", 4) == 0)
-            use_pipe_cmd = dcl_pipe;
-          UPDATE_TOKEN;
-          break;
-        }
-    }
-
-  /* End up here with a list of tokens to build a command line.
-     Deal with errors detected during parsing.
-   */
-  if (token.cmd_errno != 0)
-    {
-      while (cmd_tokens[cmd_tkn_index] == NULL)
-        free (cmd_tokens[cmd_tkn_index++]);
-      child->cstatus = VMS_POSIX_EXIT_MASK | (MAKE_TROUBLE << 3);
-      child->vms_launch_status = SS$_ABORT;
-      /* TODO what is this "magic number" */
-      child->pid = 270163; /* Special built-in */
-      child->efn = 0;
-      errno = token.cmd_errno;
-      return 0;
-    }
-
-  /* Save any redirection to append file */
-  if (append_token != -1)
-    {
-      int file_token;
-      char * lastdot;
-      char * lastdir;
-      char * raw_append_file;
-      file_token = append_token;
-      file_token++;
-      if (isspace (cmd_tokens[file_token][0]))
-        file_token++;
-      raw_append_file = vmsify (cmd_tokens[file_token], 0);
-      /* VMS DCL needs a trailing dot if null file extension */
-      lastdot = strrchr(raw_append_file, '.');
-      lastdir = strrchr(raw_append_file, ']');
-      if (lastdir == NULL)
-        lastdir = strrchr(raw_append_file, '>');
-      if (lastdir == NULL)
-        lastdir = strrchr(raw_append_file, ':');
-      if ((lastdot == NULL) || (lastdot > lastdir))
-        {
-          append_file = xmalloc (strlen (raw_append_file) + 1);
-          strcpy (append_file, raw_append_file);
-          strcat (append_file, ".");
-        }
-      else
-        append_file = strdup(raw_append_file);
-    }
-
-  cmd_dsc = build_vms_cmd (cmd_tokens, use_pipe_cmd, append_token);
-  if (cmd_dsc->dsc$a_pointer == NULL)
-    {
-      if (cmd_dsc->dsc$w_length < 0)
-        {
-          free (cmd_dsc);
-          child->cstatus = VMS_POSIX_EXIT_MASK | (MAKE_TROUBLE << 3);
-          child->vms_launch_status = SS$_ABORT;
-          /* TODO what is this "magic number" */
-          child->pid = 270163; /* Special built-in */
-          child->efn = 0;
-          return 0;
-        }
-
-      /* Only a built-in or a null command - Still need to run term AST */
-      free (cmd_dsc);
-      child->cstatus = VMS_POSIX_EXIT_MASK;
-      child->vms_launch_status = SS$_NORMAL;
-      /* TODO what is this "magic number" */
-      child->pid = 270163; /* Special built-in */
-      child->efn = 0;
-      vmsHandleChildTerm (child);
-      return 1;
-    }
-
-  if (cmd_dsc->dsc$w_length > MAX_DCL_LINE_LENGTH)
-    token.use_cmd_file = 1;
-
-  DB(DB_JOBS, (_("DCL: %s\n"), cmd_dsc->dsc$a_pointer));
-
-  /* Enforce the creation of a command file if "vms_always_use_cmd_file" is
-     non-zero.
-     Further, this way DCL reads the input stream and therefore does
-     'forced' symbol substitution, which it doesn't do for one-liners when
-     they are 'lib$spawn'ed.
-
-     Otherwise the behavior is:
-
-     Create a *.com file if either the command is too long for
-     lib$spawn, or if a redirect appending to a file is desired, or
-     symbol substitition.
-  */
-
-  if (vms_always_use_cmd_file || token.use_cmd_file)
-    {
-      FILE *outfile;
-      int cmd_len;
-
-      outfile = get_tmpfile (&child->comname,
-                             "sys$scratch:gnv$make_cmdXXXXXX.com");
-      /*                      123456789012345678901234567890 */
-      if (outfile == 0)
-        pfatal_with_name (_("fopen (temporary file)"));
-      comnamelen = strlen (child->comname);
-
-      /* The whole DCL "script" is executed as one action, and it behaves as
-         any DCL "script", that is errors stop it but warnings do not. Usually
-         the command on the last line, defines the exit code.  However, with
-         redirections there is a prolog and possibly an epilog to implement
-         the redirection.  Both are part of the script which is actually
-         executed. So if the redirection encounters an error in the prolog,
-         the user actions will not run; if in the epilog, the user actions
-         ran, but output is not captured. In both error cases, the error of
-         redirection is passed back and not the exit code of the actions. The
-         user should be able to enable DCL "script" verification with "set
-         verify". However, the prolog and epilog commands are not shown. Also,
-         if output redirection is used, the verification output is redirected
-         into that file as well. */
-      fprintf (outfile, "$ gnv$$make_verify = \"''f$verify(0)'\"\n");
-      fprintf (outfile, "$ gnv$$make_pid = f$getjpi(\"\",\"pid\")\n");
-      fprintf (outfile, "$ on error then $ goto gnv$$make_error\n");
-
-      /* Handle append redirection */
-      if (append_file != NULL)
-        {
-          /* If file does not exist, create it */
-          fprintf (outfile,
-                   "$ gnv$$make_al = \"gnv$$make_append''gnv$$make_pid'\"\n");
-          fprintf (outfile,
-                   "$ if f$search(\"%s\") .eqs. \"\" then create %s\n",
-                   append_file, append_file);
-
-          fprintf (outfile,
-                   "$ open/append 'gnv$$make_al' %s\n", append_file);
-
-          /* define sys$output to that file */
-          fprintf (outfile,
-                   "$ define/user sys$output 'gnv$$make_al'\n");
-          DB (DB_JOBS, (_("Append output to %s\n"), append_file));
-          free(append_file);
-        }
-
-      fprintf (outfile, "$ gnv$$make_verify = f$verify(gnv$$make_verify)\n");
-
-      /* TODO:
-         Only for ONESHELL there will be several commands separated by
-         '\n'. But there can always be multiple continuation lines.
-      */
-
-      fprintf (outfile, "%s\n", cmd_dsc->dsc$a_pointer);
-      fprintf (outfile, "$ gnv$$make_status_2 = $status\n");
-      fprintf (outfile, "$ goto gnv$$make_exit\n");
-
-      /* Exit and clean up */
-      fprintf (outfile, "$ gnv$$make_error: ! 'f$verify(0)\n");
-      fprintf (outfile, "$ gnv$$make_status_2 = $status\n");
-
-      if (append_token != -1)
-        {
-          fprintf (outfile, "$ deassign sys$output\n");
-          fprintf (outfile, "$ close 'gnv$$make_al'\n");
-
-          DB (DB_JOBS,
-              (_("Append %.*s and cleanup\n"), comnamelen-3, child->comname));
-        }
-      fprintf (outfile, "$ gnv$$make_exit: ! 'f$verify(0)\n");
-      fprintf (outfile,
-             "$ exit 'gnv$$make_status_2' + (0*f$verify(gnv$$make_verify))\n");
-
-      fclose (outfile);
-
-      free (cmd_dsc->dsc$a_pointer);
-      cmd_dsc->dsc$a_pointer = xmalloc (256 + 4);
-      sprintf (cmd_dsc->dsc$a_pointer, "$ @%s", child->comname);
-      cmd_dsc->dsc$w_length = strlen (cmd_dsc->dsc$a_pointer);
-
-      DB (DB_JOBS, (_("Executing %s instead\n"), child->comname));
-    }
-
-  child->efn = 0;
-  while (child->efn < 32 || child->efn > 63)
-    {
-      status = LIB$GET_EF ((unsigned long *)&child->efn);
-      if (!$VMS_STATUS_SUCCESS (status))
-        {
-          if (child->comname)
-            {
-              if (!ISDB (DB_JOBS))
-                unlink (child->comname);
-              free (child->comname);
-            }
-          return 0;
-        }
-    }
-
-  SYS$CLREF (child->efn);
-
-  vms_jobsefnmask |= (1 << (child->efn - 32));
-
-  /* Export the child environment into DCL symbols */
-  if (child->environment != 0)
-    {
-      char **ep = child->environment;
-      while (*ep != 0)
-        {
-          vms_putenv_symbol (*ep);
-          *ep++;
-        }
-    }
-
-  /*
-    LIB$SPAWN  [command-string]
-    [,input-file]
-    [,output-file]
-    [,flags]
-    [,process-name]
-    [,process-id] [,completion-status-address] [,byte-integer-event-flag-num]
-    [,AST-address] [,varying-AST-argument]
-    [,prompt-string] [,cli] [,table]
-  */
-
-#ifndef DONTWAITFORCHILD
-  /*
-   * Code to make ctrl+c and ctrl+y working.
-   * The problem starts with the synchronous case where after lib$spawn is
-   * called any input will go to the child. But with input re-directed,
-   * both control characters won't make it to any of the programs, neither
-   * the spawning nor to the spawned one. Hence the caller needs to spawn
-   * with CLI$M_NOWAIT to NOT give up the input focus. A sys$waitfr
-   * has to follow to simulate the wanted synchronous behaviour.
-   * The next problem is ctrl+y which isn't caught by the crtl and
-   * therefore isn't converted to SIGQUIT (for a signal handler which is
-   * already established). The only way to catch ctrl+y, is an AST
-   * assigned to the input channel. But ctrl+y handling of DCL needs to be
-   * disabled, otherwise it will handle it. Not to mention the previous
-   * ctrl+y handling of DCL needs to be re-established before make exits.
-   * One more: At the time of LIB$SPAWN signals are blocked. SIGQUIT will
-   * make it to the signal handler after the child "normally" terminates.
-   * This isn't enough. It seems reasonable for simple command lines like
-   * a 'cc foobar.c' spawned in a subprocess but it is unacceptable for
-   * spawning make. Therefore we need to abort the process in the AST.
-   *
-   * Prior to the spawn it is checked if an AST is already set up for
-   * ctrl+y, if not one is set up for a channel to SYS$COMMAND. In general
-   * this will work except if make is run in a batch environment, but there
-   * nobody can press ctrl+y. During the setup the DCL handling of ctrl+y
-   * is disabled and an exit handler is established to re-enable it.
-   * If the user interrupts with ctrl+y, the assigned AST will fire, force
-   * an abort to the subprocess and signal SIGQUIT, which will be caught by
-   * the already established handler and will bring us back to common code.
-   * After the spawn (now /nowait) a sys$waitfr simulates the /wait and
-   * enables the ctrl+y be delivered to this code. And the ctrl+c too,
-   * which the crtl converts to SIGINT and which is caught by the common
-   * signal handler. Because signals were blocked before entering this code
-   * sys$waitfr will always complete and the SIGQUIT will be processed after
-   * it (after termination of the current block, somewhere in common code).
-   * And SIGINT too will be delayed. That is ctrl+c can only abort when the
-   * current command completes. Anyway it's better than nothing :-)
-   */
-
-  if (!setupYAstTried)
-    tryToSetupYAst();
-  child->vms_launch_status = lib$spawn (cmd_dsc,               /* cmd-string */
-                     NULL, /* input-file */
-                     NULL, /* output-file */
-                     &spflags,                                 /* flags */
-                     &pnamedsc,                                /* proc name */
-                     &child->pid, &child->cstatus, &child->efn,
-                     0, 0,
-                     0, 0, 0);
-
-  status = child->vms_launch_status;
-  if ($VMS_STATUS_SUCCESS (status))
-    {
-      status = sys$waitfr (child->efn);
-      vmsHandleChildTerm (child);
-    }
-#else
-  child->vms_launch_status = lib$spawn (cmd_dsc,
-                      NULL,
-                      NULL,
-                      &spflags,
-                      &pnamedsc,
-                      &child->pid, &child->cstatus, &child->efn,
-                      vmsHandleChildTerm, child,
-                      0, 0, 0);
-   status = child->vms_launch_status;
-#endif
-
-  /* Free the pointer if not a command file */
-  if (!vms_always_use_cmd_file && !token.use_cmd_file)
-    free (cmd_dsc->dsc$a_pointer);
-  free (cmd_dsc);
-
-  if (!$VMS_STATUS_SUCCESS (status))
-    {
-      switch (status)
-        {
-        case SS$_EXQUOTA:
-          errno = EPROCLIM;
-          break;
-        default:
-          errno = EFAIL;
-        }
-    }
-
-  /* Restore the VMS symbols that were changed */
-  if (child->environment != 0)
-    {
-      char **ep = child->environment;
-      while (*ep != 0)
-        {
-          vms_restore_symbol (*ep);
-          *ep++;
-        }
-    }
-
-  return (status & 1);
-}
diff --git a/vpath.c b/vpath.c
deleted file mode 100644
index 1649664..0000000
--- a/vpath.c
+++ /dev/null
@@ -1,637 +0,0 @@
-/* Implementation of pattern-matching file search paths for GNU Make.
-Copyright (C) 1988-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-#include "filedef.h"
-#include "variable.h"
-#ifdef WINDOWS32
-#include "pathstuff.h"
-#endif
-
-
-/* Structure used to represent a selective VPATH searchpath.  */
-
-struct vpath
-  {
-    struct vpath *next; /* Pointer to next struct in the linked list.  */
-    const char *pattern;/* The pattern to match.  */
-    const char *percent;/* Pointer into 'pattern' where the '%' is.  */
-    unsigned int patlen;/* Length of the pattern.  */
-    const char **searchpath; /* Null-terminated list of directories.  */
-    unsigned int maxlen;/* Maximum length of any entry in the list.  */
-  };
-
-/* Linked-list of all selective VPATHs.  */
-
-static struct vpath *vpaths;
-
-/* Structure for the general VPATH given in the variable.  */
-
-static struct vpath *general_vpath;
-
-/* Structure for GPATH given in the variable.  */
-
-static struct vpath *gpaths;
-
-
-/* Reverse the chain of selective VPATH lists so they will be searched in the
-   order given in the makefiles and construct the list from the VPATH
-   variable.  */
-
-void
-build_vpath_lists (void)
-{
-  struct vpath *new = 0;
-  struct vpath *old, *nexto;
-  char *p;
-
-  /* Reverse the chain.  */
-  for (old = vpaths; old != 0; old = nexto)
-    {
-      nexto = old->next;
-      old->next = new;
-      new = old;
-    }
-
-  vpaths = new;
-
-  /* If there is a VPATH variable with a nonnull value, construct the
-     general VPATH list from it.  We use variable_expand rather than just
-     calling lookup_variable so that it will be recursively expanded.  */
-
-  {
-    /* Turn off --warn-undefined-variables while we expand SHELL and IFS.  */
-    int save = warn_undefined_variables_flag;
-    warn_undefined_variables_flag = 0;
-
-    p = variable_expand ("$(strip $(VPATH))");
-
-    warn_undefined_variables_flag = save;
-  }
-
-  if (*p != '\0')
-    {
-      /* Save the list of vpaths.  */
-      struct vpath *save_vpaths = vpaths;
-      char gp[] = "%";
-
-      /* Empty 'vpaths' so the new one will have no next, and 'vpaths'
-         will still be nil if P contains no existing directories.  */
-      vpaths = 0;
-
-      /* Parse P.  */
-      construct_vpath_list (gp, p);
-
-      /* Store the created path as the general path,
-         and restore the old list of vpaths.  */
-      general_vpath = vpaths;
-      vpaths = save_vpaths;
-    }
-
-  /* If there is a GPATH variable with a nonnull value, construct the
-     GPATH list from it.  We use variable_expand rather than just
-     calling lookup_variable so that it will be recursively expanded.  */
-
-  {
-    /* Turn off --warn-undefined-variables while we expand SHELL and IFS.  */
-    int save = warn_undefined_variables_flag;
-    warn_undefined_variables_flag = 0;
-
-    p = variable_expand ("$(strip $(GPATH))");
-
-    warn_undefined_variables_flag = save;
-  }
-
-  if (*p != '\0')
-    {
-      /* Save the list of vpaths.  */
-      struct vpath *save_vpaths = vpaths;
-      char gp[] = "%";
-
-      /* Empty 'vpaths' so the new one will have no next, and 'vpaths'
-         will still be nil if P contains no existing directories.  */
-      vpaths = 0;
-
-      /* Parse P.  */
-      construct_vpath_list (gp, p);
-
-      /* Store the created path as the GPATH,
-         and restore the old list of vpaths.  */
-      gpaths = vpaths;
-      vpaths = save_vpaths;
-    }
-}
-
-/* Construct the VPATH listing for the PATTERN and DIRPATH given.
-
-   This function is called to generate selective VPATH lists and also for
-   the general VPATH list (which is in fact just a selective VPATH that
-   is applied to everything).  The returned pointer is either put in the
-   linked list of all selective VPATH lists or in the GENERAL_VPATH
-   variable.
-
-   If DIRPATH is nil, remove all previous listings with the same
-   pattern.  If PATTERN is nil, remove all VPATH listings.  Existing
-   and readable directories that are not "." given in the DIRPATH
-   separated by the path element separator (defined in makeint.h) are
-   loaded into the directory hash table if they are not there already
-   and put in the VPATH searchpath for the given pattern with trailing
-   slashes stripped off if present (and if the directory is not the
-   root, "/").  The length of the longest entry in the list is put in
-   the structure as well.  The new entry will be at the head of the
-   VPATHS chain.  */
-
-void
-construct_vpath_list (char *pattern, char *dirpath)
-{
-  unsigned int elem;
-  char *p;
-  const char **vpath;
-  unsigned int maxvpath;
-  unsigned int maxelem;
-  const char *percent = NULL;
-
-  if (pattern != 0)
-    percent = find_percent (pattern);
-
-  if (dirpath == 0)
-    {
-      /* Remove matching listings.  */
-      struct vpath *path, *lastpath;
-
-      lastpath = 0;
-      path = vpaths;
-      while (path != 0)
-        {
-          struct vpath *next = path->next;
-
-          if (pattern == 0
-              || (((percent == 0 && path->percent == 0)
-                   || (percent - pattern == path->percent - path->pattern))
-                  && streq (pattern, path->pattern)))
-            {
-              /* Remove it from the linked list.  */
-              if (lastpath == 0)
-                vpaths = path->next;
-              else
-                lastpath->next = next;
-
-              /* Free its unused storage.  */
-              /* MSVC erroneously warns without a cast here.  */
-              free ((void *)path->searchpath);
-              free (path);
-            }
-          else
-            lastpath = path;
-
-          path = next;
-        }
-
-      return;
-    }
-
-#ifdef WINDOWS32
-    convert_vpath_to_windows32 (dirpath, ';');
-#endif
-
-  /* Skip over any initial separators and blanks.  */
-  while (STOP_SET (*dirpath, MAP_BLANK|MAP_PATHSEP))
-    ++dirpath;
-
-  /* Figure out the maximum number of VPATH entries and put it in
-     MAXELEM.  We start with 2, one before the first separator and one
-     nil (the list terminator) and increment our estimated number for
-     each separator or blank we find.  */
-  maxelem = 2;
-  p = dirpath;
-  while (*p != '\0')
-    if (STOP_SET (*p++, MAP_BLANK|MAP_PATHSEP))
-      ++maxelem;
-
-  vpath = xmalloc (maxelem * sizeof (const char *));
-  maxvpath = 0;
-
-  elem = 0;
-  p = dirpath;
-  while (*p != '\0')
-    {
-      char *v;
-      unsigned int len;
-
-      /* Find the end of this entry.  */
-      v = p;
-      while (*p != '\0'
-#if defined(HAVE_DOS_PATHS) && (PATH_SEPARATOR_CHAR == ':')
-             /* Platforms whose PATH_SEPARATOR_CHAR is ':' and which
-                also define HAVE_DOS_PATHS would like us to recognize
-                colons after the drive letter in the likes of
-                "D:/foo/bar:C:/xyzzy".  */
-             && (*p != PATH_SEPARATOR_CHAR
-                 || (p == v + 1 && (p[1] == '/' || p[1] == '\\')))
-#else
-             && *p != PATH_SEPARATOR_CHAR
-#endif
-             && !ISBLANK (*p))
-        ++p;
-
-      len = p - v;
-      /* Make sure there's no trailing slash,
-         but still allow "/" as a directory.  */
-#if defined(__MSDOS__) || defined(__EMX__) || defined(HAVE_DOS_PATHS)
-      /* We need also to leave alone a trailing slash in "d:/".  */
-      if (len > 3 || (len > 1 && v[1] != ':'))
-#endif
-      if (len > 1 && p[-1] == '/')
-        --len;
-
-      /* Put the directory on the vpath list.  */
-      if (len > 1 || *v != '.')
-        {
-          vpath[elem++] = dir_name (strcache_add_len (v, len));
-          if (len > maxvpath)
-            maxvpath = len;
-        }
-
-      /* Skip over separators and blanks between entries.  */
-      while (STOP_SET (*p, MAP_BLANK|MAP_PATHSEP))
-        ++p;
-    }
-
-  if (elem > 0)
-    {
-      struct vpath *path;
-      /* ELEM is now incremented one element past the last
-         entry, to where the nil-pointer terminator goes.
-         Usually this is maxelem - 1.  If not, shrink down.  */
-      if (elem < (maxelem - 1))
-        vpath = xrealloc (vpath, (elem+1) * sizeof (const char *));
-
-      /* Put the nil-pointer terminator on the end of the VPATH list.  */
-      vpath[elem] = NULL;
-
-      /* Construct the vpath structure and put it into the linked list.  */
-      path = xmalloc (sizeof (struct vpath));
-      path->searchpath = vpath;
-      path->maxlen = maxvpath;
-      path->next = vpaths;
-      vpaths = path;
-
-      /* Set up the members.  */
-      path->pattern = strcache_add (pattern);
-      path->patlen = strlen (pattern);
-      path->percent = percent ? path->pattern + (percent - pattern) : 0;
-    }
-  else
-    /* There were no entries, so free whatever space we allocated.  */
-    /* MSVC erroneously warns without a cast here.  */
-    free ((void *)vpath);
-}
-
-/* Search the GPATH list for a pathname string that matches the one passed
-   in.  If it is found, return 1.  Otherwise we return 0.  */
-
-int
-gpath_search (const char *file, unsigned int len)
-{
-  if (gpaths && (len <= gpaths->maxlen))
-    {
-      const char **gp;
-      for (gp = gpaths->searchpath; *gp != NULL; ++gp)
-        if (strneq (*gp, file, len) && (*gp)[len] == '\0')
-          return 1;
-    }
-
-  return 0;
-}
-
-
-/* Search the given VPATH list for a directory where the name pointed to by
-   FILE exists.  If it is found, we return a cached name of the existing file
-   and set *MTIME_PTR (if MTIME_PTR is not NULL) to its modtime (or zero if no
-   stat call was done). Also set the matching directory index in PATH_INDEX
-   if it is not NULL. Otherwise we return NULL.  */
-
-static const char *
-selective_vpath_search (struct vpath *path, const char *file,
-                        FILE_TIMESTAMP *mtime_ptr, unsigned int* path_index)
-{
-  int not_target;
-  char *name;
-  const char *n;
-  const char *filename;
-  const char **vpath = path->searchpath;
-  unsigned int maxvpath = path->maxlen;
-  unsigned int i;
-  unsigned int flen, name_dplen;
-  int exists = 0;
-
-  /* Find out if *FILE is a target.
-     If and only if it is NOT a target, we will accept prospective
-     files that don't exist but are mentioned in a makefile.  */
-  {
-    struct file *f = lookup_file (file);
-    not_target = f == 0 || !f->is_target;
-  }
-
-  flen = strlen (file);
-
-  /* Split *FILE into a directory prefix and a name-within-directory.
-     NAME_DPLEN gets the length of the prefix; FILENAME gets the pointer to
-     the name-within-directory and FLEN is its length.  */
-
-  n = strrchr (file, '/');
-#ifdef HAVE_DOS_PATHS
-  /* We need the rightmost slash or backslash.  */
-  {
-    const char *bslash = strrchr (file, '\\');
-    if (!n || bslash > n)
-      n = bslash;
-  }
-#endif
-  name_dplen = n != 0 ? n - file : 0;
-  filename = name_dplen > 0 ? n + 1 : file;
-  if (name_dplen > 0)
-    flen -= name_dplen + 1;
-
-  /* Get enough space for the biggest VPATH entry, a slash, the directory
-     prefix that came with FILE, another slash (although this one may not
-     always be necessary), the filename, and a null terminator.  */
-  name = alloca (maxvpath + 1 + name_dplen + 1 + flen + 1);
-
-  /* Try each VPATH entry.  */
-  for (i = 0; vpath[i] != 0; ++i)
-    {
-      int exists_in_cache = 0;
-      char *p = name;
-      unsigned int vlen = strlen (vpath[i]);
-
-      /* Put the next VPATH entry into NAME at P and increment P past it.  */
-      memcpy (p, vpath[i], vlen);
-      p += vlen;
-
-      /* Add the directory prefix already in *FILE.  */
-      if (name_dplen > 0)
-        {
-#ifndef VMS
-          *p++ = '/';
-#else
-          /* VMS: if this is not in VMS format, treat as Unix format */
-          if ((*p != ':') && (*p != ']') && (*p != '>'))
-            *p++ = '/';
-#endif
-          memcpy (p, file, name_dplen);
-          p += name_dplen;
-        }
-
-#ifdef HAVE_DOS_PATHS
-      /* Cause the next if to treat backslash and slash alike.  */
-      if (p != name && p[-1] == '\\' )
-        p[-1] = '/';
-#endif
-      /* Now add the name-within-directory at the end of NAME.  */
-#ifndef VMS
-      if (p != name && p[-1] != '/')
-        {
-          *p = '/';
-          memcpy (p + 1, filename, flen + 1);
-        }
-      else
-#else
-      /* VMS use a slash if no directory terminator present */
-      if (p != name && p[-1] != '/' && p[-1] != ':' &&
-          p[-1] != '>' && p[-1] != ']')
-        {
-          *p = '/';
-          memcpy (p + 1, filename, flen + 1);
-        }
-      else
-#endif
-        memcpy (p, filename, flen + 1);
-
-      /* Check if the file is mentioned in a makefile.  If *FILE is not
-         a target, that is enough for us to decide this file exists.
-         If *FILE is a target, then the file must be mentioned in the
-         makefile also as a target to be chosen.
-
-         The restriction that *FILE must not be a target for a
-         makefile-mentioned file to be chosen was added by an
-         inadequately commented change in July 1990; I am not sure off
-         hand what problem it fixes.
-
-         In December 1993 I loosened this restriction to allow a file
-         to be chosen if it is mentioned as a target in a makefile.  This
-         seem logical.
-
-         Special handling for -W / -o: make sure we preserve the special
-         values here.  Actually this whole thing is a little bogus: I think
-         we should ditch the name/hname thing and look into the renamed
-         capability that already exists for files: that is, have a new struct
-         file* entry for the VPATH-found file, and set the renamed field if
-         we use it.
-      */
-      {
-        struct file *f = lookup_file (name);
-        if (f != 0)
-          {
-            exists = not_target || f->is_target;
-            if (exists && mtime_ptr
-                && (f->last_mtime == OLD_MTIME || f->last_mtime == NEW_MTIME))
-              {
-                *mtime_ptr = f->last_mtime;
-                mtime_ptr = 0;
-              }
-          }
-      }
-
-      if (!exists)
-        {
-          /* That file wasn't mentioned in the makefile.
-             See if it actually exists.  */
-
-#ifdef VMS
-          /* For VMS syntax just use the original vpath */
-          if (*p != '/')
-            exists_in_cache = exists = dir_file_exists_p (vpath[i], filename);
-          else
-#endif
-            {
-              /* Clobber a null into the name at the last slash.
-                 Now NAME is the name of the directory to look in.  */
-              *p = '\0';
-              /* We know the directory is in the hash table now because either
-                 construct_vpath_list or the code just above put it there.
-                 Does the file we seek exist in it?  */
-              exists_in_cache = exists = dir_file_exists_p (name, filename);
-            }
-        }
-
-      if (exists)
-        {
-          /* The file is in the directory cache.
-             Now check that it actually exists in the filesystem.
-             The cache may be out of date.  When vpath thinks a file
-             exists, but stat fails for it, confusion results in the
-             higher levels.  */
-
-          struct stat st;
-
-#ifndef VMS
-          /* Put the slash back in NAME.  */
-          *p = '/';
-#else
-          /* If the slash was removed, put it back */
-          if (*p == 0)
-            *p = '/';
-#endif
-
-          if (exists_in_cache)  /* Makefile-mentioned file need not exist.  */
-            {
-              int e;
-
-              EINTRLOOP (e, stat (name, &st)); /* Does it really exist?  */
-              if (e != 0)
-                {
-                  exists = 0;
-                  continue;
-                }
-
-              /* Store the modtime into *MTIME_PTR for the caller.  */
-              if (mtime_ptr != 0)
-                {
-                  *mtime_ptr = FILE_TIMESTAMP_STAT_MODTIME (name, st);
-                  mtime_ptr = 0;
-                }
-            }
-
-          /* We have found a file.
-             If we get here and mtime_ptr hasn't been set, record
-             UNKNOWN_MTIME to indicate this.  */
-          if (mtime_ptr != 0)
-            *mtime_ptr = UNKNOWN_MTIME;
-
-          /* Store the name we found and return it.  */
-
-          if (path_index)
-            *path_index = i;
-
-          return strcache_add_len (name, (p + 1 - name) + flen);
-        }
-    }
-
-  return 0;
-}
-
-
-/* Search the VPATH list whose pattern matches FILE for a directory where FILE
-   exists.  If it is found, return the cached name of an existing file, and
-   set *MTIME_PTR (if MTIME_PTR is not NULL) to its modtime (or zero if no
-   stat call was done). Also set the matching directory index in VPATH_INDEX
-   and PATH_INDEX if they are not NULL.  Otherwise we return 0.  */
-
-const char *
-vpath_search (const char *file, FILE_TIMESTAMP *mtime_ptr,
-              unsigned int* vpath_index, unsigned int* path_index)
-{
-  struct vpath *v;
-
-  /* If there are no VPATH entries or FILENAME starts at the root,
-     there is nothing we can do.  */
-
-  if (file[0] == '/'
-#ifdef HAVE_DOS_PATHS
-      || file[0] == '\\' || file[1] == ':'
-#endif
-      || (vpaths == 0 && general_vpath == 0))
-    return 0;
-
-  if (vpath_index)
-    {
-      *vpath_index = 0;
-      *path_index = 0;
-    }
-
-  for (v = vpaths; v != 0; v = v->next)
-    {
-      if (pattern_matches (v->pattern, v->percent, file))
-        {
-          const char *p = selective_vpath_search (
-            v, file, mtime_ptr, path_index);
-          if (p)
-            return p;
-        }
-
-      if (vpath_index)
-        ++*vpath_index;
-    }
-
-
-  if (general_vpath != 0)
-    {
-      const char *p = selective_vpath_search (
-        general_vpath, file, mtime_ptr, path_index);
-      if (p)
-        return p;
-    }
-
-  return 0;
-}
-
-
-
-
-/* Print the data base of VPATH search paths.  */
-
-void
-print_vpath_data_base (void)
-{
-  unsigned int nvpaths;
-  struct vpath *v;
-
-  puts (_("\n# VPATH Search Paths\n"));
-
-  nvpaths = 0;
-  for (v = vpaths; v != 0; v = v->next)
-    {
-      unsigned int i;
-
-      ++nvpaths;
-
-      printf ("vpath %s ", v->pattern);
-
-      for (i = 0; v->searchpath[i] != 0; ++i)
-        printf ("%s%c", v->searchpath[i],
-                v->searchpath[i + 1] == 0 ? '\n' : PATH_SEPARATOR_CHAR);
-    }
-
-  if (vpaths == 0)
-    puts (_("# No 'vpath' search paths."));
-  else
-    printf (_("\n# %u 'vpath' search paths.\n"), nvpaths);
-
-  if (general_vpath == 0)
-    puts (_("\n# No general ('VPATH' variable) search path."));
-  else
-    {
-      const char **path = general_vpath->searchpath;
-      unsigned int i;
-
-      fputs (_("\n# General ('VPATH' variable) search path:\n# "), stdout);
-
-      for (i = 0; path[i] != 0; ++i)
-        printf ("%s%c", path[i],
-                path[i + 1] == 0 ? '\n' : PATH_SEPARATOR_CHAR);
-    }
-}
diff --git a/w32/compat/dirent.c b/w32/compat/dirent.c
deleted file mode 100644
index 8c9fd48..0000000
--- a/w32/compat/dirent.c
+++ /dev/null
@@ -1,188 +0,0 @@
-/* Directory entry code for Window platforms.
-Copyright (C) 1996-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-
-#include <config.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <errno.h>
-#include <string.h>
-#include <stdlib.h>
-#include "dirent.h"
-
-
-DIR*
-opendir(const char* pDirName)
-{
-        struct stat sb;
-        DIR*    pDir;
-        char*   pEndDirName;
-        int     nBufferLen;
-
-        /* sanity checks */
-        if (!pDirName) {
-                errno = EINVAL;
-                return NULL;
-        }
-        if (stat(pDirName, &sb) != 0) {
-                errno = ENOENT;
-                return NULL;
-        }
-        if ((sb.st_mode & S_IFMT) != S_IFDIR) {
-                errno = ENOTDIR;
-                return NULL;
-        }
-
-        /* allocate a DIR structure to return */
-        pDir = (DIR *) malloc(sizeof (DIR));
-
-        if (!pDir)
-                return NULL;
-
-        /* input directory name length */
-        nBufferLen = strlen(pDirName);
-
-        /* copy input directory name to DIR buffer */
-        strcpy(pDir->dir_pDirectoryName, pDirName);
-
-        /* point to end of the copied directory name */
-        pEndDirName = &pDir->dir_pDirectoryName[nBufferLen - 1];
-
-        /* if directory name did not end in '/' or '\', add '/' */
-        if ((*pEndDirName != '/') && (*pEndDirName != '\\')) {
-                pEndDirName++;
-                *pEndDirName = '/';
-        }
-
-        /* now append the wildcard character to the buffer */
-        pEndDirName++;
-        *pEndDirName = '*';
-        pEndDirName++;
-        *pEndDirName = '\0';
-
-        /* other values defaulted */
-        pDir->dir_nNumFiles = 0;
-        pDir->dir_hDirHandle = INVALID_HANDLE_VALUE;
-        pDir->dir_ulCookie = __DIRENT_COOKIE;
-
-        return pDir;
-}
-
-void
-closedir(DIR *pDir)
-{
-        /* got a valid pointer? */
-        if (!pDir) {
-                errno = EINVAL;
-                return;
-        }
-
-        /* sanity check that this is a DIR pointer */
-        if (pDir->dir_ulCookie != __DIRENT_COOKIE) {
-                errno = EINVAL;
-                return;
-        }
-
-        /* close the WINDOWS32 directory handle */
-        if (pDir->dir_hDirHandle != INVALID_HANDLE_VALUE)
-                FindClose(pDir->dir_hDirHandle);
-
-        free(pDir);
-
-        return;
-}
-
-struct dirent *
-readdir(DIR* pDir)
-{
-        WIN32_FIND_DATA wfdFindData;
-
-        if (!pDir) {
-                errno = EINVAL;
-                return NULL;
-        }
-
-        /* sanity check that this is a DIR pointer */
-        if (pDir->dir_ulCookie != __DIRENT_COOKIE) {
-                errno = EINVAL;
-                return NULL;
-        }
-
-        if (pDir->dir_nNumFiles == 0) {
-                pDir->dir_hDirHandle = FindFirstFile(pDir->dir_pDirectoryName, &wfdFindData);
-                if (pDir->dir_hDirHandle == INVALID_HANDLE_VALUE)
-                        return NULL;
-        } else if (!FindNextFile(pDir->dir_hDirHandle, &wfdFindData))
-                        return NULL;
-
-        /* bump count for next call to readdir() */
-        pDir->dir_nNumFiles++;
-
-        /* fill in struct dirent values */
-        pDir->dir_sdReturn.d_ino = (ino_t)-1;
-        strcpy(pDir->dir_sdReturn.d_name, wfdFindData.cFileName);
-
-        return &pDir->dir_sdReturn;
-}
-
-void
-rewinddir(DIR* pDir)
-{
-        if (!pDir) {
-                errno = EINVAL;
-                return;
-        }
-
-        /* sanity check that this is a DIR pointer */
-        if (pDir->dir_ulCookie != __DIRENT_COOKIE) {
-                errno = EINVAL;
-                return;
-        }
-
-        /* close the WINDOWS32 directory handle */
-        if (pDir->dir_hDirHandle != INVALID_HANDLE_VALUE)
-                if (!FindClose(pDir->dir_hDirHandle))
-                        errno = EBADF;
-
-        /* reset members which control readdir() */
-        pDir->dir_hDirHandle = INVALID_HANDLE_VALUE;
-        pDir->dir_nNumFiles = 0;
-
-        return;
-}
-
-void
-seekdir(DIR* pDir, long nPosition)
-{
-        if (!pDir)
-                return;
-
-        /* sanity check that this is a DIR pointer */
-        if (pDir->dir_ulCookie != __DIRENT_COOKIE)
-                return;
-
-        /* go back to beginning of directory */
-        rewinddir(pDir);
-
-        /* loop until we have found position we care about */
-        for (--nPosition; nPosition && readdir(pDir); nPosition--);
-
-        /* flag invalid nPosition value */
-        if (nPosition)
-                errno = EINVAL;
-
-        return;
-}
diff --git a/w32/compat/posixfcn.c b/w32/compat/posixfcn.c
deleted file mode 100644
index 7b9a577..0000000
--- a/w32/compat/posixfcn.c
+++ /dev/null
@@ -1,486 +0,0 @@
-/* Replacements for Posix functions and Posix functionality for MS-Windows.
-
-Copyright (C) 2013-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include <string.h>
-#include <io.h>
-#include <stdarg.h>
-#include <errno.h>
-#include <windows.h>
-
-#include "dlfcn.h"
-
-#include "makeint.h"
-#include "job.h"
-
-#ifndef NO_OUTPUT_SYNC
-/* Support for OUTPUT_SYNC and related functionality.  */
-
-/* Emulation of fcntl that supports only F_GETFD and F_SETLKW.  */
-int
-fcntl (intptr_t fd, int cmd, ...)
-{
-  va_list ap;
-
-  va_start (ap, cmd);
-
-  switch (cmd)
-    {
-      case F_GETFD:
-        va_end (ap);
-        /* Could have used GetHandleInformation, but that isn't
-           supported on Windows 9X.  */
-        if (_get_osfhandle (fd) == -1)
-          return -1;
-        return 0;
-      case F_SETLKW:
-        {
-          void *buf = va_arg (ap, void *);
-          struct flock *fl = (struct flock *)buf;
-          HANDLE hmutex = (HANDLE)fd;
-          static struct flock last_fl;
-          short last_type = last_fl.l_type;
-
-          va_end (ap);
-
-          if (hmutex == INVALID_HANDLE_VALUE || !hmutex)
-            return -1;
-
-          last_fl = *fl;
-
-          switch (fl->l_type)
-            {
-
-              case F_WRLCK:
-                {
-                  DWORD result;
-
-                  if (last_type == F_WRLCK)
-                    {
-                      /* Don't call WaitForSingleObject if we already
-                         own the mutex, because doing so will require
-                         us to call ReleaseMutex an equal number of
-                         times, before the mutex is actually
-                         released.  */
-                      return 0;
-                    }
-
-                  result = WaitForSingleObject (hmutex, INFINITE);
-                  switch (result)
-                    {
-                      case WAIT_OBJECT_0:
-                        /* We don't care if the mutex owner crashed or
-                           exited.  */
-                      case WAIT_ABANDONED:
-                        return 0;
-                      case WAIT_FAILED:
-                      case WAIT_TIMEOUT: /* cannot happen, really */
-                        {
-                          DWORD err = GetLastError ();
-
-                          /* Invalidate the last command.  */
-                          memset (&last_fl, 0, sizeof (last_fl));
-
-                          switch (err)
-                            {
-                              case ERROR_INVALID_HANDLE:
-                              case ERROR_INVALID_FUNCTION:
-                                errno = EINVAL;
-                                return -1;
-                              default:
-                                errno = EDEADLOCK;
-                                return -1;
-                            }
-                        }
-                    }
-                }
-              case F_UNLCK:
-                {
-                  /* FIXME: Perhaps we should call ReleaseMutex
-                     repatedly until it errors out, to make sure the
-                     mutext is released even if we somehow managed to
-                     to take ownership multiple times?  */
-                  BOOL status = ReleaseMutex (hmutex);
-
-                  if (status)
-                    return 0;
-                  else
-                    {
-                      DWORD err = GetLastError ();
-
-                      if (err == ERROR_NOT_OWNER)
-                        errno = EPERM;
-                      else
-                        {
-                          memset (&last_fl, 0, sizeof (last_fl));
-                          errno = EINVAL;
-                        }
-                      return -1;
-                    }
-                }
-              default:
-                errno = ENOSYS;
-                return -1;
-            }
-        }
-      default:
-        errno = ENOSYS;
-        va_end (ap);
-        return -1;
-    }
-}
-
-static intptr_t mutex_handle = -1;
-
-/* Record in a static variable the mutex handle we were requested to
-   use.  That nameless mutex was created by the top-level Make, and
-   its handle was passed to us via inheritance.  The value of that
-   handle is passed via the command-line arguments, so that we know
-   which handle to use.  */
-void
-record_sync_mutex (const char *str)
-{
-  char *endp;
-  intptr_t hmutex = strtol (str, &endp, 16);
-
-  if (*endp == '\0')
-    mutex_handle = hmutex;
-  else
-    {
-      mutex_handle = -1;
-      errno = EINVAL;
-    }
-}
-
-/* Create a new mutex or reuse one created by our parent.  */
-intptr_t
-create_mutex (void)
-{
-  SECURITY_ATTRIBUTES secattr;
-  intptr_t hmutex = -1;
-
-  /* If we have a mutex handle passed from the parent Make, just use
-     that.  */
-  if (mutex_handle > 0)
-    return mutex_handle;
-
-  /* We are the top-level Make, and we want the handle to be inherited
-     by our child processes.  */
-  secattr.nLength = sizeof (secattr);
-  secattr.lpSecurityDescriptor = NULL; /* use default security descriptor */
-  secattr.bInheritHandle = TRUE;
-
-  hmutex = (intptr_t)CreateMutex (&secattr, FALSE, NULL);
-  if (!hmutex)
-    {
-      DWORD err = GetLastError ();
-
-      fprintf (stderr, "CreateMutex: error %lu\n", err);
-      errno = ENOLCK;
-      hmutex = -1;
-    }
-
-  mutex_handle = hmutex;
-  return hmutex;
-}
-
-/* Return non-zero if F1 and F2 are 2 streams representing the same
-   file or pipe or device.  */
-int
-same_stream (FILE *f1, FILE *f2)
-{
-  HANDLE fh1 = (HANDLE)_get_osfhandle (fileno (f1));
-  HANDLE fh2 = (HANDLE)_get_osfhandle (fileno (f2));
-
-  /* Invalid file descriptors get treated as different streams.  */
-  if (fh1 && fh1 != INVALID_HANDLE_VALUE
-      && fh2 && fh2 != INVALID_HANDLE_VALUE)
-    {
-      if (fh1 == fh2)
-        return 1;
-      else
-        {
-          DWORD ftyp1 = GetFileType (fh1), ftyp2 = GetFileType (fh2);
-
-          if (ftyp1 != ftyp2
-              || ftyp1 == FILE_TYPE_UNKNOWN || ftyp2 == FILE_TYPE_UNKNOWN)
-            return 0;
-          else if (ftyp1 == FILE_TYPE_CHAR)
-            {
-              /* For character devices, check if they both refer to a
-                 console.  This loses if both handles refer to the
-                 null device (FIXME!), but in that case we don't care
-                 in the context of Make.  */
-              DWORD conmode1, conmode2;
-
-              /* Each process on Windows can have at most 1 console,
-                 so if both handles are for the console device, they
-                 are the same.  We also compare the console mode to
-                 distinguish between stdin and stdout/stderr.  */
-              if (GetConsoleMode (fh1, &conmode1)
-                  && GetConsoleMode (fh2, &conmode2)
-                  && conmode1 == conmode2)
-                return 1;
-            }
-          else
-            {
-              /* For disk files and pipes, compare their unique
-                 attributes.  */
-              BY_HANDLE_FILE_INFORMATION bhfi1, bhfi2;
-
-              /* Pipes get zero in the volume serial number, but do
-                 appear to have meaningful information in file index
-                 attributes.  We test file attributes as well, for a
-                 good measure.  */
-              if (GetFileInformationByHandle (fh1, &bhfi1)
-                  && GetFileInformationByHandle (fh2, &bhfi2))
-                return (bhfi1.dwVolumeSerialNumber == bhfi2.dwVolumeSerialNumber
-                        && bhfi1.nFileIndexLow == bhfi2.nFileIndexLow
-                        && bhfi1.nFileIndexHigh == bhfi2.nFileIndexHigh
-                        && bhfi1.dwFileAttributes == bhfi2.dwFileAttributes);
-            }
-        }
-    }
-  return 0;
-}
-
-/* A replacement for tmpfile, since the MSVCRT implementation creates
-   the file in the root directory of the current drive, which might
-   not be writable by our user.  Most of the code borrowed from
-   create_batch_file, see job.c.  */
-FILE *
-tmpfile (void)
-{
-  char temp_path[MAXPATHLEN];
-  unsigned path_size = GetTempPath (sizeof temp_path, temp_path);
-  int path_is_dot = 0;
-  /* The following variable is static so we won't try to reuse a name
-     that was generated a little while ago, because that file might
-     not be on disk yet, since we use FILE_ATTRIBUTE_TEMPORARY below,
-     which tells the OS it doesn't need to flush the cache to disk.
-     If the file is not yet on disk, we might think the name is
-     available, while it really isn't.  This happens in parallel
-     builds, where Make doesn't wait for one job to finish before it
-     launches the next one.  */
-  static unsigned uniq = 0;
-  static int second_loop = 0;
-  const char base[] = "gmake_tmpf";
-  const unsigned sizemax = sizeof base - 1 + 4 + 10 + 10;
-  unsigned pid = GetCurrentProcessId ();
-
-  if (path_size == 0)
-    {
-      path_size = GetCurrentDirectory (sizeof temp_path, temp_path);
-      path_is_dot = 1;
-    }
-
-  ++uniq;
-  if (uniq >= 0x10000 && !second_loop)
-    {
-      /* If we already had 64K batch files in this
-         process, make a second loop through the numbers,
-         looking for free slots, i.e. files that were
-         deleted in the meantime.  */
-      second_loop = 1;
-      uniq = 1;
-    }
-  while (path_size > 0 &&
-         path_size + sizemax < sizeof temp_path &&
-         !(uniq >= 0x10000 && second_loop))
-    {
-      HANDLE h;
-
-      sprintf (temp_path + path_size,
-               "%s%s%u-%x.tmp",
-               temp_path[path_size - 1] == '\\' ? "" : "\\",
-               base, pid, uniq);
-      h = CreateFile (temp_path,  /* file name */
-                      GENERIC_READ | GENERIC_WRITE | DELETE, /* desired access */
-                      FILE_SHARE_READ | FILE_SHARE_WRITE,    /* share mode */
-                      NULL,                                  /* default security attributes */
-                      CREATE_NEW,                            /* creation disposition */
-                      FILE_ATTRIBUTE_NORMAL |                /* flags and attributes */
-                      FILE_ATTRIBUTE_TEMPORARY |
-                      FILE_FLAG_DELETE_ON_CLOSE,
-                      NULL);                                 /* no template file */
-
-      if (h == INVALID_HANDLE_VALUE)
-        {
-          const DWORD er = GetLastError ();
-
-          if (er == ERROR_FILE_EXISTS || er == ERROR_ALREADY_EXISTS)
-            {
-              ++uniq;
-              if (uniq == 0x10000 && !second_loop)
-                {
-                  second_loop = 1;
-                  uniq = 1;
-                }
-            }
-
-          /* The temporary path is not guaranteed to exist, or might
-             not be writable by user.  Use the current directory as
-             fallback.  */
-          else if (path_is_dot == 0)
-            {
-              path_size = GetCurrentDirectory (sizeof temp_path, temp_path);
-              path_is_dot = 1;
-            }
-
-          else
-            {
-              errno = EACCES;
-              break;
-            }
-        }
-      else
-        {
-          int fd = _open_osfhandle ((intptr_t)h, 0);
-
-          return _fdopen (fd, "w+b");
-        }
-    }
-
-  if (uniq >= 0x10000)
-    errno = EEXIST;
-  return NULL;
-}
-
-#endif  /* !NO_OUTPUT_SYNC */
-
-#if MAKE_LOAD
-
-/* Support for dynamic loading of objects.  */
-
-
-static DWORD last_err;
-
-void *
-dlopen (const char *file, int mode)
-{
-  char dllfn[MAX_PATH], *p;
-  HANDLE dllhandle;
-
-  if ((mode & ~(RTLD_LAZY | RTLD_NOW | RTLD_GLOBAL)) != 0)
-    {
-      errno = EINVAL;
-      last_err = ERROR_INVALID_PARAMETER;
-      return NULL;
-    }
-
-  if (!file)
-    dllhandle = GetModuleHandle (NULL);
-  else
-    {
-      /* MSDN says to be sure to use backslashes in the DLL file name.  */
-      strcpy (dllfn, file);
-      for (p = dllfn; *p; p++)
-        if (*p == '/')
-          *p = '\\';
-
-      dllhandle = LoadLibrary (dllfn);
-    }
-  if (!dllhandle)
-    last_err = GetLastError ();
-
-  return dllhandle;
-}
-
-char *
-dlerror (void)
-{
-  static char errbuf[1024];
-  DWORD ret;
-
-  if (!last_err)
-    return NULL;
-
-  ret = FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM
-                       | FORMAT_MESSAGE_IGNORE_INSERTS,
-                       NULL, last_err, 0, errbuf, sizeof (errbuf), NULL);
-  while (ret > 0 && (errbuf[ret - 1] == '\n' || errbuf[ret - 1] == '\r'))
-    --ret;
-
-  errbuf[ret] = '\0';
-  if (!ret)
-    sprintf (errbuf, "Error code %lu", last_err);
-
-  last_err = 0;
-  return errbuf;
-}
-
-void *
-dlsym (void *handle, const char *name)
-{
-  FARPROC addr = NULL;
-
-  if (!handle || handle == INVALID_HANDLE_VALUE)
-    {
-      last_err = ERROR_INVALID_PARAMETER;
-      return NULL;
-    }
-
-  addr = GetProcAddress (handle, name);
-  if (!addr)
-    last_err = GetLastError ();
-
-  return (void *)addr;
-}
-
-int
-dlclose (void *handle)
-{
-  if (!handle || handle == INVALID_HANDLE_VALUE)
-    return -1;
-  if (!FreeLibrary (handle))
-    return -1;
-
-  return 0;
-}
-
-
-#endif  /* MAKE_LOAD */
-
-
-/* MS runtime's isatty returns non-zero for any character device,
-   including the null device, which is not what we want.  */
-int
-isatty (int fd)
-{
-  HANDLE fh = (HANDLE) _get_osfhandle (fd);
-  DWORD con_mode;
-
-  if (fh == INVALID_HANDLE_VALUE)
-    {
-      errno = EBADF;
-      return 0;
-    }
-  if (GetConsoleMode (fh, &con_mode))
-    return 1;
-
-  errno = ENOTTY;
-  return 0;
-}
-
-char *
-ttyname (int fd)
-{
-  /* This "knows" that Make only asks about stdout and stderr.  A more
-     sophisticated implementation should test whether FD is open for
-     input or output.  We can do that by looking at the mode returned
-     by GetConsoleMode.  */
-  return "CONOUT$";
-}
diff --git a/w32/include/dirent.h b/w32/include/dirent.h
deleted file mode 100644
index ea817f1..0000000
--- a/w32/include/dirent.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/* Windows version of dirent.h
-Copyright (C) 1996-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#ifndef _DIRENT_H
-#define _DIRENT_H
-
-#ifdef __MINGW32__
-# include <windows.h>
-# include_next <dirent.h>
-#else
-
-#include <stdlib.h>
-#include <windows.h>
-#include <limits.h>
-#include <sys/types.h>
-
-#ifndef NAME_MAX
-#define NAME_MAX 255
-#endif
-
-#define __DIRENT_COOKIE 0xfefeabab
-
-
-struct dirent
-{
-  ino_t d_ino;                  /* unused - no equivalent on WINDOWS32 */
-  char d_name[NAME_MAX+1];
-};
-
-typedef struct dir_struct {
-        ULONG   dir_ulCookie;
-        HANDLE  dir_hDirHandle;
-        DWORD   dir_nNumFiles;
-        char    dir_pDirectoryName[NAME_MAX+1];
-        struct dirent dir_sdReturn;
-} DIR;
-
-DIR *opendir(const char *);
-struct dirent *readdir(DIR *);
-void rewinddir(DIR *);
-void closedir(DIR *);
-void seekdir(DIR *, long);
-
-#endif  /* !__MINGW32__ */
-#endif
diff --git a/w32/include/dlfcn.h b/w32/include/dlfcn.h
deleted file mode 100644
index 55c5f20..0000000
--- a/w32/include/dlfcn.h
+++ /dev/null
@@ -1,29 +0,0 @@
-/* dlfcn.h replacement for MS-Windows build.
-Copyright (C) 2013-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#ifndef DLFCN_H
-#define DLFCN_H
-
-#define RTLD_LAZY   1
-#define RTLD_NOW    2
-#define RTLD_GLOBAL 4
-
-extern void *dlopen (const char *, int);
-extern void *dlsym (void *, const char *);
-extern char *dlerror (void);
-extern int   dlclose (void *);
-
-#endif  /* DLFCN_H */
diff --git a/w32/include/pathstuff.h b/w32/include/pathstuff.h
deleted file mode 100644
index 6f3615d..0000000
--- a/w32/include/pathstuff.h
+++ /dev/null
@@ -1,25 +0,0 @@
-/* Definitions for Windows path manipulation.
-Copyright (C) 1996-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#ifndef _PATHSTUFF_H
-#define _PATHSTUFF_H
-
-char *convert_Path_to_windows32(char *Path, char to_delim);
-char *convert_vpath_to_windows32(char *Path, char to_delim);
-char *w32ify(const char *file, int resolve);
-char *getcwd_fs(char *buf, int len);
-
-#endif
diff --git a/w32/include/sub_proc.h b/w32/include/sub_proc.h
deleted file mode 100644
index b3147bd..0000000
--- a/w32/include/sub_proc.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/* Definitions for Windows process invocation.
-Copyright (C) 1996-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#ifndef SUB_PROC_H
-#define SUB_PROC_H
-
-/*
- * Component Name:
- *
- * $Date$
- *
- * $Source$
- *
- * $Id$
- */
-
-#define EXTERN_DECL(entry, args) extern entry args
-#define VOID_DECL void
-
-EXTERN_DECL(HANDLE process_init, (VOID_DECL));
-EXTERN_DECL(HANDLE process_init_fd, (HANDLE stdinh, HANDLE stdouth,
-                                     HANDLE stderrh));
-EXTERN_DECL(long process_begin, (HANDLE proc, char **argv, char **envp,
-                                 char *exec_path, char *as_user));
-EXTERN_DECL(long process_pipe_io, (HANDLE proc, char *stdin_data,
-                                   int stdin_data_len));
-EXTERN_DECL(long process_file_io, (HANDLE proc));
-EXTERN_DECL(void process_cleanup, (HANDLE proc));
-EXTERN_DECL(HANDLE process_wait_for_any, (int block, DWORD* pdwWaitStatus));
-EXTERN_DECL(void process_register, (HANDLE proc));
-EXTERN_DECL(HANDLE process_easy, (char** argv, char** env,
-                                  int outfd, int errfd));
-EXTERN_DECL(BOOL process_kill, (HANDLE proc, int signal));
-EXTERN_DECL(BOOL process_table_full, (VOID_DECL));
-EXTERN_DECL(int process_table_usable_size, (VOID_DECL));
-EXTERN_DECL(int process_table_actual_size, (VOID_DECL));
-EXTERN_DECL(DWORD process_set_handles, (HANDLE *handles));
-EXTERN_DECL(DWORD process_wait_for_multiple_objects, (DWORD, const HANDLE*, BOOL, DWORD));
-
-/* support routines */
-EXTERN_DECL(long process_errno, (HANDLE proc));
-EXTERN_DECL(long process_last_err, (HANDLE proc));
-EXTERN_DECL(long process_exit_code, (HANDLE proc));
-EXTERN_DECL(long process_signal, (HANDLE proc));
-EXTERN_DECL(char * process_outbuf, (HANDLE proc));
-EXTERN_DECL(char * process_errbuf, (HANDLE proc));
-EXTERN_DECL(int process_outcnt, (HANDLE proc));
-EXTERN_DECL(int process_errcnt, (HANDLE proc));
-EXTERN_DECL(void process_pipes, (HANDLE proc, int pipes[3]));
-
-#endif
diff --git a/w32/include/w32err.h b/w32/include/w32err.h
deleted file mode 100644
index 7a40607..0000000
--- a/w32/include/w32err.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/* Definitions for Windows error handling.
-Copyright (C) 1996-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#ifndef _W32ERR_H_
-#define _W32ERR_H_
-
-#ifndef EXTERN_DECL
-#define EXTERN_DECL(entry, args) entry args
-#endif
-
-EXTERN_DECL(const char * map_windows32_error_to_string, (DWORD error));
-
-#endif /* !_W32ERR_H */
diff --git a/w32/pathstuff.c b/w32/pathstuff.c
deleted file mode 100644
index 82450de..0000000
--- a/w32/pathstuff.c
+++ /dev/null
@@ -1,266 +0,0 @@
-/* Path conversion for Windows pathnames.
-Copyright (C) 1996-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-#include <string.h>
-#include <stdlib.h>
-#include "pathstuff.h"
-
-/*
- * Convert delimiter separated vpath to Canonical format.
- */
-char *
-convert_vpath_to_windows32(char *Path, char to_delim)
-{
-    char *etok;            /* token separator for old Path */
-
-        /*
-         * Convert all spaces to delimiters. Note that pathnames which
-         * contain blanks get trounced here. Use 8.3 format as a workaround.
-         */
-        for (etok = Path; etok && *etok; etok++)
-                if (ISBLANK ((unsigned char) *etok))
-                        *etok = to_delim;
-
-        return (convert_Path_to_windows32(Path, to_delim));
-}
-
-/*
- * Convert delimiter separated path to Canonical format.
- */
-char *
-convert_Path_to_windows32(char *Path, char to_delim)
-{
-    char *etok;            /* token separator for old Path */
-    char *p;            /* points to element of old Path */
-
-    /* is this a multi-element Path ? */
-    /* FIXME: Perhaps use ":;\"" in strpbrk to convert all quotes to
-       delimiters as well, as a way to handle quoted directories in
-       PATH?  */
-    for (p = Path, etok = strpbrk(p, ":;");
-         etok;
-         etok = strpbrk(p, ":;"))
-        if ((etok - p) == 1) {
-            if (*(etok - 1) == ';' ||
-                *(etok - 1) == ':') {
-                etok[-1] = to_delim;
-                etok[0] = to_delim;
-                p = ++etok;
-                continue;    /* ignore empty bucket */
-            } else if (!isalpha ((unsigned char) *p)) {
-                /* found one to count, handle things like '.' */
-                *etok = to_delim;
-                p = ++etok;
-            } else if ((*etok == ':') && (etok = strpbrk(etok+1, ":;"))) {
-                /* found one to count, handle drive letter */
-                *etok = to_delim;
-                p = ++etok;
-            } else
-                /* all finished, force abort */
-                p += strlen(p);
-        } else if (*p == '"') { /* a quoted directory */
-            for (p++; *p && *p != '"'; p++) /* skip quoted part */
-                ;
-            etok = strpbrk(p, ":;");        /* find next delimiter */
-            if (etok) {
-                *etok = to_delim;
-                p = ++etok;
-            } else
-                p += strlen(p);
-        } else {
-            /* found another one, no drive letter */
-            *etok = to_delim;
-            p = ++etok;
-        }
-
-    return Path;
-}
-
-/*
- * Convert to forward slashes. Resolve to full pathname optionally
- */
-char *
-w32ify(const char *filename, int resolve)
-{
-    static char w32_path[FILENAME_MAX];
-    char *p;
-
-    if (resolve)
-        _fullpath(w32_path, filename, sizeof (w32_path));
-    else
-        strncpy(w32_path, filename, sizeof (w32_path));
-
-    for (p = w32_path; p && *p; p++)
-        if (*p == '\\')
-            *p = '/';
-
-    return w32_path;
-}
-
-char *
-getcwd_fs(char* buf, int len)
-{
-        char *p = getcwd(buf, len);
-
-        if (p) {
-                char *q = w32ify(buf, 0);
-                strncpy(buf, q, len);
-        }
-
-        return p;
-}
-
-#ifdef unused
-/*
- * Convert delimiter separated pathnames (e.g. PATH) or single file pathname
- * (e.g. c:/foo, c:\bar) to NutC format. If we are handed a string that
- * _NutPathToNutc() fails to convert, just return the path we were handed
- * and assume the caller will know what to do with it (It was probably
- * a mistake to try and convert it anyway due to some of the bizarre things
- * that might look like pathnames in makefiles).
- */
-char *
-convert_path_to_nutc(char *path)
-{
-    int  count;            /* count of path elements */
-    char *nutc_path;     /* new NutC path */
-    int  nutc_path_len;    /* length of buffer to allocate for new path */
-    char *pathp;        /* pointer to nutc_path used to build it */
-    char *etok;            /* token separator for old path */
-    char *p;            /* points to element of old path */
-    char sep;            /* what flavor of separator used in old path */
-    char *rval;
-
-    /* is this a multi-element path ? */
-    for (p = path, etok = strpbrk(p, ":;"), count = 0;
-         etok;
-         etok = strpbrk(p, ":;"))
-        if ((etok - p) == 1) {
-            if (*(etok - 1) == ';' ||
-                *(etok - 1) == ':') {
-                p = ++etok;
-                continue;    /* ignore empty bucket */
-            } else if (etok = strpbrk(etok+1, ":;"))
-                /* found one to count, handle drive letter */
-                p = ++etok, count++;
-            else
-                /* all finished, force abort */
-                p += strlen(p);
-        } else
-            /* found another one, no drive letter */
-            p = ++etok, count++;
-
-    if (count) {
-        count++;    /* x1;x2;x3 <- need to count x3 */
-
-        /*
-         * Hazard a guess on how big the buffer needs to be.
-         * We have to convert things like c:/foo to /c=/foo.
-         */
-        nutc_path_len = strlen(path) + (count*2) + 1;
-        nutc_path = xmalloc(nutc_path_len);
-        pathp = nutc_path;
-        *pathp = '\0';
-
-        /*
-         * Loop through PATH and convert one elemnt of the path at at
-         * a time. Single file pathnames will fail this and fall
-         * to the logic below loop.
-         */
-        for (p = path, etok = strpbrk(p, ":;");
-             etok;
-             etok = strpbrk(p, ":;")) {
-
-            /* don't trip up on device specifiers or empty path slots */
-            if ((etok - p) == 1)
-                if (*(etok - 1) == ';' ||
-                    *(etok - 1) == ':') {
-                    p = ++etok;
-                    continue;
-                } else if ((etok = strpbrk(etok+1, ":;")) == NULL)
-                    break;    /* thing found was a WINDOWS32 pathname */
-
-            /* save separator */
-            sep = *etok;
-
-            /* terminate the current path element -- temporarily */
-            *etok = '\0';
-
-#ifdef __NUTC__
-            /* convert to NutC format */
-            if (_NutPathToNutc(p, pathp, 0) == FALSE) {
-                free(nutc_path);
-                rval = savestring(path, strlen(path));
-                return rval;
-            }
-#else
-            *pathp++ = '/';
-            *pathp++ = p[0];
-            *pathp++ = '=';
-            *pathp++ = '/';
-            strcpy(pathp, &p[2]);
-#endif
-
-            pathp += strlen(pathp);
-            *pathp++ = ':';     /* use Unix style path separtor for new path */
-            *pathp   = '\0'; /* make sure we are null terminaed */
-
-            /* restore path separator */
-            *etok = sep;
-
-            /* point p to first char of next path element */
-            p = ++etok;
-
-        }
-    } else {
-        nutc_path_len = strlen(path) + 3;
-        nutc_path = xmalloc(nutc_path_len);
-        pathp = nutc_path;
-        *pathp = '\0';
-        p = path;
-    }
-
-    /*
-      * OK, here we handle the last element in PATH (e.g. c of a;b;c)
-     * or the path was a single filename and will be converted
-     * here. Note, testing p here assures that we don't trip up
-     * on paths like a;b; which have trailing delimiter followed by
-     * nothing.
-     */
-    if (*p != '\0') {
-#ifdef __NUTC__
-        if (_NutPathToNutc(p, pathp, 0) == FALSE) {
-            free(nutc_path);
-            rval = savestring(path, strlen(path));
-            return rval;
-        }
-#else
-        *pathp++ = '/';
-        *pathp++ = p[0];
-        *pathp++ = '=';
-        *pathp++ = '/';
-        strcpy(pathp, &p[2]);
-#endif
-    } else
-        *(pathp-1) = '\0'; /* we're already done, don't leave trailing : */
-
-    rval = savestring(nutc_path, strlen(nutc_path));
-    free(nutc_path);
-    return rval;
-}
-
-#endif
diff --git a/w32/subproc/misc.c b/w32/subproc/misc.c
deleted file mode 100644
index 6e7ac9a..0000000
--- a/w32/subproc/misc.c
+++ /dev/null
@@ -1,83 +0,0 @@
-/* Process handling for Windows
-Copyright (C) 1996-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include <config.h>
-#include <stddef.h>
-#include <stdlib.h>
-#include <string.h>
-#include <windows.h>
-#include "proc.h"
-
-
-/*
- * Description:  Convert a NULL string terminated UNIX environment block to
- *              an environment block suitable for a windows32 system call
- *
- * Returns:  TRUE= success, FALSE=fail
- *
- * Notes/Dependencies:  the environment block is sorted in case-insensitive
- *      order, is double-null terminated, and is a char *, not a char **
- */
-int _cdecl compare(const void *a1, const void *a2)
-{
-        return _stricoll(*((char**)a1),*((char**)a2));
-}
-bool_t
-arr2envblk(char **arr, char **envblk_out, int *envsize_needed)
-{
-        char **tmp;
-        int size_needed;
-        int arrcnt;
-        char *ptr;
-
-        arrcnt = 0;
-        while (arr[arrcnt]) {
-                arrcnt++;
-        }
-
-        tmp = (char**) calloc(arrcnt + 1, sizeof(char *));
-        if (!tmp) {
-                return FALSE;
-        }
-
-        arrcnt = 0;
-        size_needed = *envsize_needed = 0;
-        while (arr[arrcnt]) {
-                tmp[arrcnt] = arr[arrcnt];
-                size_needed += strlen(arr[arrcnt]) + 1;
-                arrcnt++;
-        }
-        size_needed++;
-        *envsize_needed = size_needed;
-
-        qsort((void *) tmp, (size_t) arrcnt, sizeof (char*), compare);
-
-        ptr = *envblk_out = calloc(size_needed, 1);
-        if (!ptr) {
-                free(tmp);
-                return FALSE;
-        }
-
-        arrcnt = 0;
-        while (tmp[arrcnt]) {
-                strcpy(ptr, tmp[arrcnt]);
-                ptr += strlen(tmp[arrcnt]) + 1;
-                arrcnt++;
-        }
-
-        free(tmp);
-        return TRUE;
-}
diff --git a/w32/subproc/proc.h b/w32/subproc/proc.h
deleted file mode 100644
index ef2972d..0000000
--- a/w32/subproc/proc.h
+++ /dev/null
@@ -1,29 +0,0 @@
-/* Definitions for Windows
-Copyright (C) 1996-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#ifndef  _PROC_H
-#define _PROC_H
-
-typedef int bool_t;
-
-#define E_SCALL         101
-#define E_IO            102
-#define E_NO_MEM        103
-#define E_FORK          104
-
-extern bool_t arr2envblk(char **arr, char **envblk_out, int *envsize_needed);
-
-#endif
diff --git a/w32/subproc/sub_proc.c b/w32/subproc/sub_proc.c
deleted file mode 100644
index e8552be..0000000
--- a/w32/subproc/sub_proc.c
+++ /dev/null
@@ -1,1565 +0,0 @@
-/* Process handling for Windows.
-Copyright (C) 1996-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include <assert.h>
-#include <config.h>
-#include <stdlib.h>
-#include <stdio.h>
-#include <io.h>         /* for _get_osfhandle */
-#ifdef _MSC_VER
-# include <stddef.h>    /* for intptr_t */
-#else
-# include <stdint.h>
-#endif
-#include <string.h>
-#include <process.h>  /* for msvc _beginthreadex, _endthreadex */
-#include <signal.h>
-#include <windows.h>
-
-#include "makeint.h"
-#include "filedef.h"
-#include "variable.h"
-#include "sub_proc.h"
-#include "proc.h"
-#include "w32err.h"
-#include "debug.h"
-#include "os.h"
-
-#define GMAKE_MAXIMUM_WAIT_OBJECTS (MAXIMUM_WAIT_OBJECTS * MAXIMUM_WAIT_OBJECTS)
-
-/* We need to move these special-case return codes out-of-band */
-#define GMAKE_WAIT_TIMEOUT      0xFFFF0102L
-#define GMAKE_WAIT_ABANDONED_0  0x00080000L
-
-static char *make_command_line(char *shell_name, char *exec_path, char **argv);
-
-typedef struct sub_process_t {
-        intptr_t sv_stdin[2];
-        intptr_t sv_stdout[2];
-        intptr_t sv_stderr[2];
-        int using_pipes;
-        char *inp;
-        DWORD incnt;
-        char * volatile outp;
-        volatile DWORD outcnt;
-        char * volatile errp;
-        volatile DWORD errcnt;
-        pid_t pid;
-        int exit_code;
-        int signal;
-        long last_err;
-        long lerrno;
-} sub_process;
-
-/* keep track of children so we can implement a waitpid-like routine */
-static sub_process *proc_array[GMAKE_MAXIMUM_WAIT_OBJECTS];
-static int proc_index = 0;
-static int fake_exits_pending = 0;
-
-/*
- * Address the scalability limit intrisic to WaitForMultipleOjects by
- * calling WaitForMultipleObjects on 64 element chunks of the input
- * array with 0 timeout.  Exit with an appropriately conditioned result
- * or repeat again every 10 ms if no handle has signaled and the
- * requested timeout was not zero.
- */
-DWORD process_wait_for_multiple_objects(
-  DWORD nCount,
-  const HANDLE *lpHandles,
-  BOOL bWaitAll,
-  DWORD dwMilliseconds
-)
-{
-  assert(nCount <= GMAKE_MAXIMUM_WAIT_OBJECTS);
-
-  if (nCount <= MAXIMUM_WAIT_OBJECTS) {
-    DWORD retVal =  WaitForMultipleObjects(nCount, lpHandles, bWaitAll, dwMilliseconds);
-    return (retVal == WAIT_TIMEOUT) ? GMAKE_WAIT_TIMEOUT : retVal;
-  } else {
-    for (;;) {
-      DWORD objectCount = nCount;
-      int blockCount  = 0;
-      DWORD retVal;
-
-      assert(bWaitAll == FALSE); /* This logic only works for this use case */
-      assert(dwMilliseconds == 0 || dwMilliseconds == INFINITE); /* No support for timeouts */
-
-      for (; objectCount > 0; blockCount++) {
-	DWORD n = objectCount <= MAXIMUM_WAIT_OBJECTS ? objectCount : MAXIMUM_WAIT_OBJECTS;
-	objectCount -= n;
-	retVal = WaitForMultipleObjects(n, &lpHandles[blockCount * MAXIMUM_WAIT_OBJECTS],
-					    FALSE, 0);
-	switch (retVal) {
-	  case WAIT_TIMEOUT:
-	    retVal = GMAKE_WAIT_TIMEOUT;
-	    continue;
-	    break;
-	  case WAIT_FAILED:
-	    fprintf(stderr,"WaitForMultipleOjbects failed waiting with error %d\n", GetLastError());
-	    break;
-	  default:
-	    if (retVal >= WAIT_ABANDONED_0) {
-	      assert(retVal < WAIT_ABANDONED_0 + MAXIMUM_WAIT_OBJECTS);
-	      retVal += blockCount * MAXIMUM_WAIT_OBJECTS - WAIT_ABANDONED_0 + GMAKE_WAIT_ABANDONED_0;
-	    } else {
-	      assert(retVal < WAIT_OBJECT_0 + MAXIMUM_WAIT_OBJECTS);
-	      retVal += blockCount * MAXIMUM_WAIT_OBJECTS;
-	    }
-	    break;
-	}
-
-	return retVal;
-
-      }
-
-      if (dwMilliseconds == 0) return retVal;
-
-      Sleep(10);  /* Sleep for 10 ms */
-    }
-  }
-}
-
-/*
- * Fill a HANDLE list with handles to wait for.
- */
-DWORD
-process_set_handles(HANDLE *handles)
-{
-    DWORD count = 0;
-    int i;
-
-    /* Build array of handles to wait for */
-    for (i = 0; i < proc_index; i++) {
-        /* Don't wait on child processes that have already finished */
-        if (fake_exits_pending && proc_array[i]->exit_code)
-            continue;
-
-        handles[count++] = (HANDLE) proc_array[i]->pid;
-    }
-
-    return count;
-}
-
-/*
- * When a process has been waited for, adjust the wait state
- * array so that we don't wait for it again
- */
-static void
-process_adjust_wait_state(sub_process* pproc)
-{
-        int i;
-
-        if (!proc_index)
-                return;
-
-        for (i = 0; i < proc_index; i++)
-                if (proc_array[i]->pid == pproc->pid)
-                        break;
-
-        if (i < proc_index) {
-                proc_index--;
-                if (i != proc_index)
-                        memmove(&proc_array[i], &proc_array[i+1],
-                                (proc_index-i) * sizeof(sub_process*));
-                proc_array[proc_index] = NULL;
-        }
-}
-
-/*
- * Waits for any of the registered child processes to finish.
- */
-static sub_process *
-process_wait_for_any_private(int block, DWORD* pdwWaitStatus)
-{
-        HANDLE handles[GMAKE_MAXIMUM_WAIT_OBJECTS];
-        DWORD retval, which;
-        int i;
-
-        if (!proc_index)
-                return NULL;
-
-        /* build array of handles to wait for */
-        for (i = 0; i < proc_index; i++) {
-                handles[i] = (HANDLE) proc_array[i]->pid;
-
-                if (fake_exits_pending && proc_array[i]->exit_code)
-                        break;
-        }
-
-        /* wait for someone to exit */
-        if (!fake_exits_pending) {
-                retval = process_wait_for_multiple_objects(proc_index, handles, FALSE, (block ? INFINITE : 0));
-                which = retval - WAIT_OBJECT_0;
-        } else {
-                fake_exits_pending--;
-                retval = !WAIT_FAILED;
-                which = i;
-        }
-
-        /* If the pointer is not NULL, set the wait status result variable. */
-        if (pdwWaitStatus)
-                *pdwWaitStatus = (retval == GMAKE_WAIT_TIMEOUT) ? WAIT_TIMEOUT : retval;
-
-        /* return pointer to process */
-        if ((retval == GMAKE_WAIT_TIMEOUT) || (retval == WAIT_FAILED)) {
-                return NULL;
-        }
-        else {
-                sub_process* pproc = proc_array[which];
-                process_adjust_wait_state(pproc);
-                return pproc;
-        }
-}
-
-/*
- * Terminate a process.
- */
-BOOL
-process_kill(HANDLE proc, int signal)
-{
-        sub_process* pproc = (sub_process*) proc;
-        pproc->signal = signal;
-        return (TerminateProcess((HANDLE) pproc->pid, signal));
-}
-
-/*
- * Returns true when we have no more available slots in our process table.
- */
-BOOL
-process_table_full()
-{
-  extern int shell_function_pid;
-
-  /* Reserve slots for jobserver_semaphore if we have one and the shell function if not active */
-  return(proc_index >= GMAKE_MAXIMUM_WAIT_OBJECTS - jobserver_enabled() - (shell_function_pid == 0));
-}
-
-/*
- * Returns the maximum number of job slots we can support when using the jobserver.
- */
-int
-process_table_usable_size()
-{
-  /* Reserve slots for jobserver_semaphore and shell function */
-  return(GMAKE_MAXIMUM_WAIT_OBJECTS - 2);
-}
-
-/*
- * Returns the actual size of the process table.
- */
-int
-process_table_actual_size()
-{
-  return(GMAKE_MAXIMUM_WAIT_OBJECTS);
-}
-
-/*
- * Use this function to register processes you wish to wait for by
- * calling process_file_io(NULL) or process_wait_any(). This must be done
- * because it is possible for callers of this library to reuse the same
- * handle for multiple processes launches :-(
- */
-void
-process_register(HANDLE proc)
-{
-  assert(proc_index < GMAKE_MAXIMUM_WAIT_OBJECTS);
-  proc_array[proc_index++] = (sub_process *) proc;
-}
-
-/*
- * Public function which works kind of like waitpid(). Wait for any
- * of the children to die and return results. To call this function,
- * you must do 1 of things:
- *
- *      x = process_easy(...);
- *
- * or
- *
- *      x = process_init_fd();
- *      process_register(x);
- *
- * or
- *
- *      x = process_init();
- *      process_register(x);
- *
- * You must NOT then call process_pipe_io() because this function is
- * not capable of handling automatic notification of any child
- * death.
- */
-
-HANDLE
-process_wait_for_any(int block, DWORD* pdwWaitStatus)
-{
-        sub_process* pproc = process_wait_for_any_private(block, pdwWaitStatus);
-
-        if (!pproc)
-                return NULL;
-        else {
-                /*
-                 * Ouch! can't tell caller if this fails directly. Caller
-                 * will have to use process_last_err()
-                 */
-                (void) process_file_io(pproc);
-                return ((HANDLE) pproc);
-        }
-}
-
-long
-process_signal(HANDLE proc)
-{
-        if (proc == INVALID_HANDLE_VALUE) return 0;
-        return (((sub_process *)proc)->signal);
-}
-
-long
-process_last_err(HANDLE proc)
-{
-        if (proc == INVALID_HANDLE_VALUE) return ERROR_INVALID_HANDLE;
-        return (((sub_process *)proc)->last_err);
-}
-
-long
-process_exit_code(HANDLE proc)
-{
-        if (proc == INVALID_HANDLE_VALUE) return EXIT_FAILURE;
-        return (((sub_process *)proc)->exit_code);
-}
-
-/*
-2006-02:
-All the following functions are currently unused.
-All of them would crash gmake if called with argument INVALID_HANDLE_VALUE.
-Hence whoever wants to use one of this functions must invent and implement
-a reasonable error handling for this function.
-
-char *
-process_outbuf(HANDLE proc)
-{
-        return (((sub_process *)proc)->outp);
-}
-
-char *
-process_errbuf(HANDLE proc)
-{
-        return (((sub_process *)proc)->errp);
-}
-
-int
-process_outcnt(HANDLE proc)
-{
-        return (((sub_process *)proc)->outcnt);
-}
-
-int
-process_errcnt(HANDLE proc)
-{
-        return (((sub_process *)proc)->errcnt);
-}
-
-void
-process_pipes(HANDLE proc, int pipes[3])
-{
-        pipes[0] = ((sub_process *)proc)->sv_stdin[0];
-        pipes[1] = ((sub_process *)proc)->sv_stdout[0];
-        pipes[2] = ((sub_process *)proc)->sv_stderr[0];
-        return;
-}
-*/
-
-        HANDLE
-process_init()
-{
-        sub_process *pproc;
-        /*
-         * open file descriptors for attaching stdin/stdout/sterr
-         */
-        HANDLE stdin_pipes[2];
-        HANDLE stdout_pipes[2];
-        HANDLE stderr_pipes[2];
-        SECURITY_ATTRIBUTES inherit;
-        BYTE sd[SECURITY_DESCRIPTOR_MIN_LENGTH];
-
-        pproc = malloc(sizeof(*pproc));
-        memset(pproc, 0, sizeof(*pproc));
-
-        /* We can't use NULL for lpSecurityDescriptor because that
-           uses the default security descriptor of the calling process.
-           Instead we use a security descriptor with no DACL.  This
-           allows nonrestricted access to the associated objects. */
-
-        if (!InitializeSecurityDescriptor((PSECURITY_DESCRIPTOR)(&sd),
-                                          SECURITY_DESCRIPTOR_REVISION)) {
-                pproc->last_err = GetLastError();
-                pproc->lerrno = E_SCALL;
-                return((HANDLE)pproc);
-        }
-
-        inherit.nLength = sizeof(inherit);
-        inherit.lpSecurityDescriptor = (PSECURITY_DESCRIPTOR)(&sd);
-        inherit.bInheritHandle = TRUE;
-
-        // By convention, parent gets pipe[0], and child gets pipe[1]
-        // This means the READ side of stdin pipe goes into pipe[1]
-        // and the WRITE side of the stdout and stderr pipes go into pipe[1]
-        if (CreatePipe( &stdin_pipes[1], &stdin_pipes[0], &inherit, 0) == FALSE ||
-        CreatePipe( &stdout_pipes[0], &stdout_pipes[1], &inherit, 0) == FALSE ||
-        CreatePipe( &stderr_pipes[0], &stderr_pipes[1], &inherit, 0) == FALSE) {
-
-                pproc->last_err = GetLastError();
-                pproc->lerrno = E_SCALL;
-                return((HANDLE)pproc);
-        }
-
-        //
-        // Mark the parent sides of the pipes as non-inheritable
-        //
-        if (SetHandleInformation(stdin_pipes[0],
-                                HANDLE_FLAG_INHERIT, 0) == FALSE ||
-                SetHandleInformation(stdout_pipes[0],
-                                HANDLE_FLAG_INHERIT, 0) == FALSE ||
-                SetHandleInformation(stderr_pipes[0],
-                                HANDLE_FLAG_INHERIT, 0) == FALSE) {
-
-                pproc->last_err = GetLastError();
-                pproc->lerrno = E_SCALL;
-                return((HANDLE)pproc);
-        }
-        pproc->sv_stdin[0]  = (intptr_t) stdin_pipes[0];
-        pproc->sv_stdin[1]  = (intptr_t) stdin_pipes[1];
-        pproc->sv_stdout[0] = (intptr_t) stdout_pipes[0];
-        pproc->sv_stdout[1] = (intptr_t) stdout_pipes[1];
-        pproc->sv_stderr[0] = (intptr_t) stderr_pipes[0];
-        pproc->sv_stderr[1] = (intptr_t) stderr_pipes[1];
-
-        pproc->using_pipes = 1;
-
-        pproc->lerrno = 0;
-
-        return((HANDLE)pproc);
-}
-
-
-        HANDLE
-process_init_fd(HANDLE stdinh, HANDLE stdouth, HANDLE stderrh)
-{
-        sub_process *pproc;
-
-        pproc = malloc(sizeof(*pproc));
-        if (pproc) {
-                memset(pproc, 0, sizeof(*pproc));
-
-                /*
-                 * Just pass the provided file handles to the 'child
-                 * side' of the pipe, bypassing pipes altogether.
-                 */
-                pproc->sv_stdin[1]  = (intptr_t) stdinh;
-                pproc->sv_stdout[1] = (intptr_t) stdouth;
-                pproc->sv_stderr[1] = (intptr_t) stderrh;
-
-                pproc->last_err = pproc->lerrno = 0;
-        }
-
-        return((HANDLE)pproc);
-}
-
-
-static HANDLE
-find_file(const char *exec_path, const char *path_var,
-          char *full_fname, DWORD full_len)
-{
-        HANDLE exec_handle;
-        char *fname;
-        char *ext;
-        DWORD req_len;
-        int i;
-        static const char *extensions[] =
-          /* Should .com come before no-extension case?  */
-          { ".exe", ".cmd", ".bat", "", ".com", NULL };
-
-        fname = xmalloc(strlen(exec_path) + 5);
-        strcpy(fname, exec_path);
-        ext = fname + strlen(fname);
-
-        for (i = 0; extensions[i]; i++) {
-                strcpy(ext, extensions[i]);
-                if (((req_len = SearchPath (path_var, fname, NULL, full_len,
-                                            full_fname, NULL)) > 0
-                     /* For compatibility with previous code, which
-                        used OpenFile, and with Windows operation in
-                        general, also look in various default
-                        locations, such as Windows directory and
-                        Windows System directory.  Warning: this also
-                        searches PATH in the Make's environment, which
-                        might not be what the Makefile wants, but it
-                        seems to be OK as a fallback, after the
-                        previous SearchPath failed to find on child's
-                        PATH.  */
-                     || (req_len = SearchPath (NULL, fname, NULL, full_len,
-                                               full_fname, NULL)) > 0)
-                    && req_len <= full_len
-                    && (exec_handle =
-                                CreateFile(full_fname,
-                                           GENERIC_READ,
-                                           FILE_SHARE_READ | FILE_SHARE_WRITE,
-                                           NULL,
-                                           OPEN_EXISTING,
-                                           FILE_ATTRIBUTE_NORMAL,
-                                           NULL)) != INVALID_HANDLE_VALUE) {
-                        free(fname);
-                        return(exec_handle);
-                }
-        }
-
-        free(fname);
-        return INVALID_HANDLE_VALUE;
-}
-
-/*
- * Return non-zero of FNAME specifies a batch file and its name
- * includes embedded whitespace.
- */
-
-static int
-batch_file_with_spaces(const char *fname)
-{
-        size_t fnlen = strlen(fname);
-
-        return (fnlen > 4
-                && (_strnicmp(fname + fnlen - 4, ".bat", 4) == 0
-                    || _strnicmp(fname + fnlen - 4, ".cmd", 4) == 0)
-                /* The set of characters in the 2nd arg to strpbrk
-                   should be the same one used by make_command_line
-                   below to decide whether an argv[] element needs
-                   quoting.  */
-                && strpbrk(fname, " \t") != NULL);
-}
-
-
-/*
- * Description:   Create the child process to be helped
- *
- * Returns: success <=> 0
- *
- * Notes/Dependencies:
- */
-long
-process_begin(
-        HANDLE proc,
-        char **argv,
-        char **envp,
-        char *exec_path,
-        char *as_user)
-{
-        sub_process *pproc = (sub_process *)proc;
-        char *shell_name = 0;
-        int file_not_found=0;
-        HANDLE exec_handle;
-        char exec_fname[MAX_PATH];
-        const char *path_var = NULL;
-        char **ep;
-        char buf[MAX_PATH];
-        DWORD bytes_returned;
-        DWORD flags;
-        char *command_line;
-        STARTUPINFO startInfo;
-        PROCESS_INFORMATION procInfo;
-        char *envblk=NULL;
-        int envsize_needed = 0;
-        int pass_null_exec_path = 0;
-
-        /*
-         *  Shell script detection...  if the exec_path starts with #! then
-         *  we want to exec shell-script-name exec-path, not just exec-path
-         *  NT doesn't recognize #!/bin/sh or #!/etc/Tivoli/bin/perl.  We do not
-         *  hard-code the path to the shell or perl or whatever:  Instead, we
-         *  assume it's in the path somewhere (generally, the NT tools
-         *  bin directory)
-         */
-
-        /* Use the Makefile's value of PATH to look for the program to
-           execute, because it could be different from Make's PATH
-           (e.g., if the target sets its own value.  */
-        if (envp)
-                for (ep = envp; *ep; ep++) {
-                        if (strncmp (*ep, "PATH=", 5) == 0
-                            || strncmp (*ep, "Path=", 5) == 0) {
-                                path_var = *ep + 5;
-                                break;
-                        }
-                }
-        exec_handle = find_file(exec_path, path_var,
-                                exec_fname, sizeof(exec_fname));
-
-        /*
-         * If we couldn't open the file, just assume that Windows will be
-         * somehow able to find and execute it.  If the first character
-         * of the command is '/', assume they set SHELL to a Unixy shell
-         * that have some magic mounts known only to it, and run the whole
-         * command via $SHELL -c "COMMAND" instead.
-         */
-        if (exec_handle == INVALID_HANDLE_VALUE) {
-                if (exec_path[0] == '/') {
-                        char *new_argv0;
-                        char **argvi = argv;
-                        int arglen = 0;
-
-                        strcpy(buf, variable_expand ("$(SHELL)"));
-                        shell_name = &buf[0];
-                        strcpy(exec_fname, "-c");
-                        /* Construct a single command string in argv[0].  */
-                        while (*argvi) {
-                                arglen += strlen(*argvi) + 1;
-                                argvi++;
-                        }
-                        new_argv0 = xmalloc(arglen + 1);
-                        new_argv0[0] = '\0';
-                        for (argvi = argv; *argvi; argvi++) {
-                                strcat(new_argv0, *argvi);
-                                strcat(new_argv0, " ");
-                        }
-                        /* Remove the extra blank at the end.  */
-                        new_argv0[arglen-1] = '\0';
-                        free(argv[0]);
-                        argv[0] = new_argv0;
-                        argv[1] = NULL;
-                }
-                else
-                        file_not_found++;
-        }
-        else {
-                /* Attempt to read the first line of the file */
-                if (ReadFile( exec_handle,
-                                buf, sizeof(buf) - 1, /* leave room for trailing NULL */
-                                &bytes_returned, 0) == FALSE || bytes_returned < 2) {
-
-                        pproc->last_err = GetLastError();
-                        pproc->lerrno = E_IO;
-                        CloseHandle(exec_handle);
-                        return(-1);
-                }
-                if (buf[0] == '#' && buf[1] == '!') {
-                        /*
-                         *  This is a shell script...  Change the command line from
-                         *      exec_path args to shell_name exec_path args
-                         */
-                        char *p;
-
-                        /*  Make sure buf is NULL terminated */
-                        buf[bytes_returned] = 0;
-                        /*
-                         * Depending on the file system type, etc. the first line
-                         * of the shell script may end with newline or newline-carriage-return
-                         * Whatever it ends with, cut it off.
-                         */
-                        p= strchr(buf, '\n');
-                        if (p)
-                                *p = 0;
-                        p = strchr(buf, '\r');
-                        if (p)
-                                *p = 0;
-
-                        /*
-                         *  Find base name of shell
-                         */
-                        shell_name = strrchr( buf, '/');
-                        if (shell_name) {
-                                shell_name++;
-                        } else {
-                                shell_name = &buf[2];/* skipping "#!" */
-                        }
-
-                }
-                CloseHandle(exec_handle);
-        }
-
-        flags = 0;
-
-        if (file_not_found)
-                command_line = make_command_line( shell_name, exec_path, argv);
-        else {
-                /* If exec_fname includes whitespace, CreateProcess
-                   behaves erratically and unreliably, and often fails
-                   if argv[0] also includes whitespace (and thus will
-                   be quoted by make_command_line below).  So in that
-                   case, we don't pass exec_fname as the 1st arg to
-                   CreateProcess, but instead replace argv[0] with
-                   exec_fname (to keep its leading directories and
-                   extension as found by find_file), and pass NULL to
-                   CreateProcess as its 1st arg.  This works around
-                   the bugs in CreateProcess, which are probably
-                   caused by its passing the command to cmd.exe with
-                   some incorrect quoting.  */
-                if (!shell_name
-                    && batch_file_with_spaces(exec_fname)
-                    && _stricmp(exec_path, argv[0]) == 0) {
-                        char *new_argv, *p;
-                        char **argvi;
-                        int arglen, i;
-                        pass_null_exec_path = 1;
-                        /* Rewrite argv[] replacing argv[0] with exec_fname.  */
-                        for (argvi = argv + 1, arglen = strlen(exec_fname) + 1;
-                             *argvi;
-                             argvi++) {
-                                arglen += strlen(*argvi) + 1;
-                        }
-                        new_argv = xmalloc(arglen);
-                        p = strcpy(new_argv, exec_fname) + strlen(exec_fname) + 1;
-                        for (argvi = argv + 1, i = 1; *argvi; argvi++, i++) {
-                                strcpy(p, *argvi);
-                                argv[i] = p;
-                                p += strlen(*argvi) + 1;
-                        }
-                        argv[i] = NULL;
-                        free (argv[0]);
-                        argv[0] = new_argv;
-                }
-                command_line = make_command_line( shell_name, exec_fname, argv);
-        }
-
-        if ( command_line == NULL ) {
-                pproc->last_err = 0;
-                pproc->lerrno = E_NO_MEM;
-                return(-1);
-        }
-
-        if (envp) {
-                if (arr2envblk(envp, &envblk, &envsize_needed) == FALSE) {
-                        pproc->lerrno = E_NO_MEM;
-                        free( command_line );
-                        if ((pproc->last_err == ERROR_INVALID_PARAMETER
-                             || pproc->last_err == ERROR_MORE_DATA)
-                            && envsize_needed > 32*1024) {
-                                fprintf (stderr, "CreateProcess failed, probably because environment is too large (%d bytes).\n",
-                                         envsize_needed);
-                        }
-                        pproc->last_err = 0;
-                        return(-1);
-                }
-        }
-
-        if (shell_name || file_not_found || pass_null_exec_path) {
-                exec_path = 0;  /* Search for the program in %Path% */
-        } else {
-                exec_path = exec_fname;
-        }
-
-        /*
-         *  Set up inherited stdin, stdout, stderr for child
-         */
-        memset(&startInfo, '\0', sizeof(startInfo));
-        GetStartupInfo(&startInfo);
-        startInfo.dwFlags = STARTF_USESTDHANDLES;
-        startInfo.lpReserved = 0;
-        startInfo.cbReserved2 = 0;
-        startInfo.lpReserved2 = 0;
-        startInfo.hStdInput = (HANDLE)pproc->sv_stdin[1];
-        startInfo.hStdOutput = (HANDLE)pproc->sv_stdout[1];
-        startInfo.hStdError = (HANDLE)pproc->sv_stderr[1];
-
-        if (as_user) {
-                free(envblk);
-                return -1;
-        } else {
-                DB (DB_JOBS, ("CreateProcess(%s,%s,...)\n",
-                        exec_path ? exec_path : "NULL",
-                        command_line ? command_line : "NULL"));
-                if (CreateProcess(
-                        exec_path,
-                        command_line,
-                        NULL,
-                        0, /* default security attributes for thread */
-                        TRUE, /* inherit handles (e.g. helper pipes, oserv socket) */
-                        flags,
-                        envblk,
-                        0, /* default starting directory */
-                        &startInfo,
-                        &procInfo) == FALSE) {
-
-                        pproc->last_err = GetLastError();
-                        pproc->lerrno = E_FORK;
-                        fprintf(stderr, "process_begin: CreateProcess(%s, %s, ...) failed.\n",
-                                exec_path ? exec_path : "NULL", command_line);
-                        free(envblk);
-                        free( command_line );
-                        return(-1);
-                }
-        }
-
-        pproc->pid = (pid_t)procInfo.hProcess;
-        /* Close the thread handle -- we'll just watch the process */
-        CloseHandle(procInfo.hThread);
-
-        /* Close the halves of the pipes we don't need */
-        if ((HANDLE)pproc->sv_stdin[1] != INVALID_HANDLE_VALUE)
-          CloseHandle((HANDLE)pproc->sv_stdin[1]);
-        if ((HANDLE)pproc->sv_stdout[1] != INVALID_HANDLE_VALUE)
-          CloseHandle((HANDLE)pproc->sv_stdout[1]);
-        if ((HANDLE)pproc->sv_stderr[1] != INVALID_HANDLE_VALUE)
-          CloseHandle((HANDLE)pproc->sv_stderr[1]);
-        pproc->sv_stdin[1] = 0;
-        pproc->sv_stdout[1] = 0;
-        pproc->sv_stderr[1] = 0;
-
-        free( command_line );
-        free(envblk);
-        pproc->lerrno=0;
-        return 0;
-}
-
-
-
-#if 0   /* unused */
-static DWORD
-proc_stdin_thread(sub_process *pproc)
-{
-        DWORD in_done;
-        for (;;) {
-                if (WriteFile( (HANDLE) pproc->sv_stdin[0], pproc->inp, pproc->incnt,
-                                         &in_done, NULL) == FALSE)
-                        _endthreadex(0);
-                // This if should never be true for anonymous pipes, but gives
-                // us a chance to change I/O mechanisms later
-                if (in_done < pproc->incnt) {
-                        pproc->incnt -= in_done;
-                        pproc->inp += in_done;
-                } else {
-                        _endthreadex(0);
-                }
-        }
-        return 0; // for compiler warnings only.. not reached
-}
-
-static DWORD
-proc_stdout_thread(sub_process *pproc)
-{
-        DWORD bufsize = 1024;
-        char c;
-        DWORD nread;
-        pproc->outp = malloc(bufsize);
-        if (pproc->outp == NULL)
-                _endthreadex(0);
-        pproc->outcnt = 0;
-
-        for (;;) {
-                if (ReadFile( (HANDLE)pproc->sv_stdout[0], &c, 1, &nread, NULL)
-                                        == FALSE) {
-/*                      map_windows32_error_to_string(GetLastError());*/
-                        _endthreadex(0);
-                }
-                if (nread == 0)
-                        _endthreadex(0);
-                if (pproc->outcnt + nread > bufsize) {
-                        bufsize += nread + 512;
-                        pproc->outp = realloc(pproc->outp, bufsize);
-                        if (pproc->outp == NULL) {
-                                pproc->outcnt = 0;
-                                _endthreadex(0);
-                        }
-                }
-                pproc->outp[pproc->outcnt++] = c;
-        }
-        return 0;
-}
-
-static DWORD
-proc_stderr_thread(sub_process *pproc)
-{
-        DWORD bufsize = 1024;
-        char c;
-        DWORD nread;
-        pproc->errp = malloc(bufsize);
-        if (pproc->errp == NULL)
-                _endthreadex(0);
-        pproc->errcnt = 0;
-
-        for (;;) {
-                if (ReadFile( (HANDLE)pproc->sv_stderr[0], &c, 1, &nread, NULL) == FALSE) {
-                        map_windows32_error_to_string(GetLastError());
-                        _endthreadex(0);
-                }
-                if (nread == 0)
-                        _endthreadex(0);
-                if (pproc->errcnt + nread > bufsize) {
-                        bufsize += nread + 512;
-                        pproc->errp = realloc(pproc->errp, bufsize);
-                        if (pproc->errp == NULL) {
-                                pproc->errcnt = 0;
-                                _endthreadex(0);
-                        }
-                }
-                pproc->errp[pproc->errcnt++] = c;
-        }
-        return 0;
-}
-
-
-/*
- * Purpose: collects output from child process and returns results
- *
- * Description:
- *
- * Returns:
- *
- * Notes/Dependencies:
- */
-        long
-process_pipe_io(
-        HANDLE proc,
-        char *stdin_data,
-        int stdin_data_len)
-{
-        sub_process *pproc = (sub_process *)proc;
-        bool_t stdin_eof = FALSE, stdout_eof = FALSE, stderr_eof = FALSE;
-        HANDLE childhand = (HANDLE) pproc->pid;
-        HANDLE tStdin = NULL, tStdout = NULL, tStderr = NULL;
-        unsigned int dwStdin, dwStdout, dwStderr;
-        HANDLE wait_list[4];
-        DWORD wait_count;
-        DWORD wait_return;
-        HANDLE ready_hand;
-        bool_t child_dead = FALSE;
-        BOOL GetExitCodeResult;
-
-        /*
-         *  Create stdin thread, if needed
-         */
-        pproc->inp = stdin_data;
-        pproc->incnt = stdin_data_len;
-        if (!pproc->inp) {
-                stdin_eof = TRUE;
-                CloseHandle((HANDLE)pproc->sv_stdin[0]);
-                pproc->sv_stdin[0] = 0;
-        } else {
-                tStdin = (HANDLE) _beginthreadex( 0, 1024,
-                        (unsigned (__stdcall *) (void *))proc_stdin_thread,
-                                                  pproc, 0, &dwStdin);
-                if (tStdin == 0) {
-                        pproc->last_err = GetLastError();
-                        pproc->lerrno = E_SCALL;
-                        goto done;
-                }
-        }
-
-        /*
-         *   Assume child will produce stdout and stderr
-         */
-        tStdout = (HANDLE) _beginthreadex( 0, 1024,
-                (unsigned (__stdcall *) (void *))proc_stdout_thread, pproc, 0,
-                &dwStdout);
-        tStderr = (HANDLE) _beginthreadex( 0, 1024,
-                (unsigned (__stdcall *) (void *))proc_stderr_thread, pproc, 0,
-                &dwStderr);
-
-        if (tStdout == 0 || tStderr == 0) {
-
-                pproc->last_err = GetLastError();
-                pproc->lerrno = E_SCALL;
-                goto done;
-        }
-
-
-        /*
-         *  Wait for all I/O to finish and for the child process to exit
-         */
-
-        while (!stdin_eof || !stdout_eof || !stderr_eof || !child_dead) {
-                wait_count = 0;
-                if (!stdin_eof) {
-                        wait_list[wait_count++] = tStdin;
-                }
-                if (!stdout_eof) {
-                        wait_list[wait_count++] = tStdout;
-                }
-                if (!stderr_eof) {
-                        wait_list[wait_count++] = tStderr;
-                }
-                if (!child_dead) {
-                        wait_list[wait_count++] = childhand;
-                }
-
-                wait_return = WaitForMultipleObjects(wait_count, wait_list,
-                         FALSE, /* don't wait for all: one ready will do */
-                         child_dead? 1000 :INFINITE); /* after the child dies, subthreads have
-                                one second to collect all remaining output */
-
-                if (wait_return == WAIT_FAILED) {
-/*                      map_windows32_error_to_string(GetLastError());*/
-                        pproc->last_err = GetLastError();
-                        pproc->lerrno = E_SCALL;
-                        goto done;
-                }
-
-                ready_hand = wait_list[wait_return - WAIT_OBJECT_0];
-
-                if (ready_hand == tStdin) {
-                        CloseHandle((HANDLE)pproc->sv_stdin[0]);
-                        pproc->sv_stdin[0] = 0;
-                        CloseHandle(tStdin);
-                        tStdin = 0;
-                        stdin_eof = TRUE;
-
-                } else if (ready_hand == tStdout) {
-
-                        CloseHandle((HANDLE)pproc->sv_stdout[0]);
-                        pproc->sv_stdout[0] = 0;
-                        CloseHandle(tStdout);
-                        tStdout = 0;
-                        stdout_eof = TRUE;
-
-                } else if (ready_hand == tStderr) {
-
-                        CloseHandle((HANDLE)pproc->sv_stderr[0]);
-                        pproc->sv_stderr[0] = 0;
-                        CloseHandle(tStderr);
-                        tStderr = 0;
-                        stderr_eof = TRUE;
-
-                } else if (ready_hand == childhand) {
-
-                        DWORD ierr;
-                        GetExitCodeResult = GetExitCodeProcess(childhand, &ierr);
-                        if (ierr == CONTROL_C_EXIT) {
-                                pproc->signal = SIGINT;
-                        } else {
-                                pproc->exit_code = ierr;
-                        }
-                        if (GetExitCodeResult == FALSE) {
-                                pproc->last_err = GetLastError();
-                                pproc->lerrno = E_SCALL;
-                                goto done;
-                        }
-                        child_dead = TRUE;
-
-                } else {
-
-                        /* ?? Got back a handle we didn't query ?? */
-                        pproc->last_err = 0;
-                        pproc->lerrno = E_FAIL;
-                        goto done;
-                }
-        }
-
- done:
-        if (tStdin != 0)
-                CloseHandle(tStdin);
-        if (tStdout != 0)
-                CloseHandle(tStdout);
-        if (tStderr != 0)
-                CloseHandle(tStderr);
-
-        if (pproc->lerrno)
-                return(-1);
-        else
-                return(0);
-
-}
-#endif  /* unused */
-
-/*
- * Purpose: collects output from child process and returns results
- *
- * Description:
- *
- * Returns:
- *
- * Notes/Dependencies:
- */
-        long
-process_file_io(
-        HANDLE proc)
-{
-        sub_process *pproc;
-        HANDLE childhand;
-        DWORD wait_return;
-        BOOL GetExitCodeResult;
-        DWORD ierr;
-
-        if (proc == NULL)
-                pproc = process_wait_for_any_private(1, 0);
-        else
-                pproc = (sub_process *)proc;
-
-        /* some sort of internal error */
-        if (!pproc)
-                return -1;
-
-        childhand = (HANDLE) pproc->pid;
-
-        /*
-         * This function is poorly named, and could also be used just to wait
-         * for child death if you're doing your own pipe I/O.  If that is
-         * the case, close the pipe handles here.
-         */
-        if (pproc->sv_stdin[0]) {
-                CloseHandle((HANDLE)pproc->sv_stdin[0]);
-                pproc->sv_stdin[0] = 0;
-        }
-        if (pproc->sv_stdout[0]) {
-                CloseHandle((HANDLE)pproc->sv_stdout[0]);
-                pproc->sv_stdout[0] = 0;
-        }
-        if (pproc->sv_stderr[0]) {
-                CloseHandle((HANDLE)pproc->sv_stderr[0]);
-                pproc->sv_stderr[0] = 0;
-        }
-
-        /*
-         *  Wait for the child process to exit
-         */
-
-        wait_return = WaitForSingleObject(childhand, INFINITE);
-
-        if (wait_return != WAIT_OBJECT_0) {
-/*              map_windows32_error_to_string(GetLastError());*/
-                pproc->last_err = GetLastError();
-                pproc->lerrno = E_SCALL;
-                goto done2;
-        }
-
-        GetExitCodeResult = GetExitCodeProcess(childhand, &ierr);
-        if (ierr == CONTROL_C_EXIT) {
-                pproc->signal = SIGINT;
-        } else {
-                pproc->exit_code = ierr;
-        }
-        if (GetExitCodeResult == FALSE) {
-                pproc->last_err = GetLastError();
-                pproc->lerrno = E_SCALL;
-        }
-
-done2:
-        if (pproc->lerrno)
-                return(-1);
-        else
-                return(0);
-
-}
-
-/*
- * Description:  Clean up any leftover handles, etc.  It is up to the
- * caller to manage and free the input, output, and stderr buffers.
- */
-        void
-process_cleanup(
-        HANDLE proc)
-{
-        sub_process *pproc = (sub_process *)proc;
-        int i;
-
-        if (pproc->using_pipes) {
-                for (i= 0; i <= 1; i++) {
-                        if ((HANDLE)pproc->sv_stdin[i]
-                            && (HANDLE)pproc->sv_stdin[i] != INVALID_HANDLE_VALUE)
-                                CloseHandle((HANDLE)pproc->sv_stdin[i]);
-                        if ((HANDLE)pproc->sv_stdout[i]
-                            && (HANDLE)pproc->sv_stdout[i] != INVALID_HANDLE_VALUE)
-                                CloseHandle((HANDLE)pproc->sv_stdout[i]);
-                        if ((HANDLE)pproc->sv_stderr[i]
-                            && (HANDLE)pproc->sv_stderr[i] != INVALID_HANDLE_VALUE)
-                                CloseHandle((HANDLE)pproc->sv_stderr[i]);
-                }
-        }
-        if ((HANDLE)pproc->pid)
-                CloseHandle((HANDLE)pproc->pid);
-
-        free(pproc);
-}
-
-
-/*
- * Description:
- *       Create a command line buffer to pass to CreateProcess
- *
- * Returns:  the buffer or NULL for failure
- *      Shell case:  sh_name a:/full/path/to/script argv[1] argv[2] ...
- *      Otherwise:   argv[0] argv[1] argv[2] ...
- *
- * Notes/Dependencies:
- *   CreateProcess does not take an argv, so this command creates a
- *   command line for the executable.
- */
-
-static char *
-make_command_line( char *shell_name, char *full_exec_path, char **argv)
-{
-        int             argc = 0;
-        char**          argvi;
-        int*            enclose_in_quotes = NULL;
-        int*            enclose_in_quotes_i;
-        unsigned int    bytes_required = 0;
-        char*           command_line;
-        char*           command_line_i;
-        int have_sh = 0; /* HAVE_CYGWIN_SHELL */
-        int cygwin_mode = 0; /* HAVE_CYGWIN_SHELL */
-
-#ifdef HAVE_CYGWIN_SHELL
-        cygwin_mode = 1;
-#endif
-
-        if (shell_name && full_exec_path) {
-                have_sh = cygwin_mode && strstr(full_exec_path, "sh.exe");
-                bytes_required
-                  = strlen(shell_name) + 1 + strlen(full_exec_path);
-                /*
-                 * Skip argv[0] if any, when shell_name is given.
-                 * The special case of "-c" in full_exec_path means
-                 * argv[0] is not the shell name, but the command string
-                 * to pass to the shell.
-                 */
-                if (*argv && strcmp(full_exec_path, "-c")) argv++;
-                /*
-                 * Add one for the intervening space.
-                 */
-                if (*argv) bytes_required++;
-        }
-
-        argvi = argv;
-        while (*(argvi++)) argc++;
-
-        if (argc) {
-                enclose_in_quotes = (int*) calloc(1, argc * sizeof(int));
-
-                if (!enclose_in_quotes) {
-                        return NULL;
-                }
-        }
-
-        /* We have to make one pass through each argv[i] to see if we need
-         * to enclose it in ", so we might as well figure out how much
-         * memory we'll need on the same pass.
-         */
-
-        argvi = argv;
-        enclose_in_quotes_i = enclose_in_quotes;
-        while(*argvi) {
-                char* p = *argvi;
-                unsigned int backslash_count = 0;
-
-                /*
-                 * We have to enclose empty arguments in ".
-                 */
-                if (!(*p)) *enclose_in_quotes_i = 1;
-
-                while(*p) {
-                        switch (*p) {
-                        case '\"':
-                                /*
-                                 * We have to insert a backslash for each "
-                                 * and each \ that precedes the ".
-                                 */
-                                bytes_required += (backslash_count + 1);
-                                backslash_count = 0;
-                                break;
-
-#if !defined(HAVE_MKS_SHELL) && !defined(HAVE_CYGWIN_SHELL)
-                        case '\\':
-                                backslash_count++;
-                                break;
-#endif
-        /*
-         * At one time we set *enclose_in_quotes_i for '*' or '?' to suppress
-         * wildcard expansion in programs linked with MSVC's SETARGV.OBJ so
-         * that argv in always equals argv out. This was removed.  Say you have
-         * such a program named glob.exe.  You enter
-         * glob '*'
-         * at the sh command prompt.  Obviously the intent is to make glob do the
-         * wildcarding instead of sh.  If we set *enclose_in_quotes_i for '*' or '?',
-         * then the command line that glob would see would be
-         * glob "*"
-         * and the _setargv in SETARGV.OBJ would _not_ expand the *.
-         */
-                        case ' ':
-                        case '\t':
-                                *enclose_in_quotes_i = 1;
-                                /* fall through */
-
-                        default:
-                                backslash_count = 0;
-                                break;
-                        }
-
-                        /*
-                         * Add one for each character in argv[i].
-                         */
-                        bytes_required++;
-
-                        p++;
-                }
-
-                if (*enclose_in_quotes_i) {
-                        /*
-                         * Add one for each enclosing ",
-                         * and one for each \ that precedes the
-                         * closing ".
-                         */
-                        bytes_required += (backslash_count + 2);
-                }
-
-                /*
-                 * Add one for the intervening space.
-                 */
-                if (*(++argvi)) bytes_required++;
-                enclose_in_quotes_i++;
-        }
-
-        /*
-         * Add one for the terminating NULL.
-         */
-        bytes_required++;
-
-        command_line = (char*) malloc(bytes_required);
-
-        if (!command_line) {
-                free(enclose_in_quotes);
-                return NULL;
-        }
-
-        command_line_i = command_line;
-
-        if (shell_name && full_exec_path) {
-                while(*shell_name) {
-                        *(command_line_i++) = *(shell_name++);
-                }
-
-                *(command_line_i++) = ' ';
-
-                while(*full_exec_path) {
-                        *(command_line_i++) = *(full_exec_path++);
-                }
-
-                if (*argv) {
-                        *(command_line_i++) = ' ';
-                }
-        }
-
-        argvi = argv;
-        enclose_in_quotes_i = enclose_in_quotes;
-
-        while(*argvi) {
-                char* p = *argvi;
-                unsigned int backslash_count = 0;
-
-                if (*enclose_in_quotes_i) {
-                        *(command_line_i++) = '\"';
-                }
-
-                while(*p) {
-                        if (*p == '\"') {
-                                if (cygwin_mode && have_sh) { /* HAVE_CYGWIN_SHELL */
-                                        /* instead of a \", cygwin likes "" */
-                                        *(command_line_i++) = '\"';
-                                } else {
-
-                                /*
-                                 * We have to insert a backslash for the "
-                                 * and each \ that precedes the ".
-                                 */
-                                backslash_count++;
-
-                                while(backslash_count) {
-                                        *(command_line_i++) = '\\';
-                                        backslash_count--;
-                                };
-                                }
-#if !defined(HAVE_MKS_SHELL) && !defined(HAVE_CYGWIN_SHELL)
-                        } else if (*p == '\\') {
-                                backslash_count++;
-                        } else {
-                                backslash_count = 0;
-#endif
-                        }
-
-                        /*
-                         * Copy the character.
-                         */
-                        *(command_line_i++) = *(p++);
-                }
-
-                if (*enclose_in_quotes_i) {
-#if !defined(HAVE_MKS_SHELL) && !defined(HAVE_CYGWIN_SHELL)
-                        /*
-                         * Add one \ for each \ that precedes the
-                         * closing ".
-                         */
-                        while(backslash_count--) {
-                                *(command_line_i++) = '\\';
-                        };
-#endif
-                        *(command_line_i++) = '\"';
-                }
-
-                /*
-                 * Append an intervening space.
-                 */
-                if (*(++argvi)) {
-                        *(command_line_i++) = ' ';
-                }
-
-                enclose_in_quotes_i++;
-        }
-
-        /*
-         * Append the terminating NULL.
-         */
-        *command_line_i = '\0';
-
-        free(enclose_in_quotes);
-        return command_line;
-}
-
-/*
- * Description: Given an argv and optional envp, launch the process
- *              using the default stdin, stdout, and stderr handles.
- *              Also, register process so that process_wait_for_any_private()
- *              can be used via process_file_io(NULL) or
- *              process_wait_for_any().
- *
- * Returns:
- *
- * Notes/Dependencies:
- */
-HANDLE
-process_easy(
-        char **argv,
-        char **envp,
-        int outfd,
-        int errfd)
-{
-  HANDLE hIn = INVALID_HANDLE_VALUE;
-  HANDLE hOut = INVALID_HANDLE_VALUE;
-  HANDLE hErr = INVALID_HANDLE_VALUE;
-  HANDLE hProcess, tmpIn, tmpOut, tmpErr;
-  DWORD e;
-
-  if (process_table_full()) {
-        DB (DB_JOBS, ("process_easy: All process slots used up\n"));
-        return INVALID_HANDLE_VALUE;
-  }
-  /* Standard handles returned by GetStdHandle can be NULL or
-     INVALID_HANDLE_VALUE if the parent process closed them.  If that
-     happens, we open the null device and pass its handle to
-     CreateProcess as the corresponding handle to inherit.  */
-  tmpIn = GetStdHandle(STD_INPUT_HANDLE);
-  if (DuplicateHandle(GetCurrentProcess(),
-                      tmpIn,
-                      GetCurrentProcess(),
-                      &hIn,
-                      0,
-                      TRUE,
-                      DUPLICATE_SAME_ACCESS) == FALSE) {
-    if ((e = GetLastError()) == ERROR_INVALID_HANDLE) {
-      tmpIn = CreateFile("NUL", GENERIC_READ,
-                         FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
-                         OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
-      if (tmpIn != INVALID_HANDLE_VALUE
-          && DuplicateHandle(GetCurrentProcess(),
-                             tmpIn,
-                             GetCurrentProcess(),
-                             &hIn,
-                             0,
-                             TRUE,
-                             DUPLICATE_SAME_ACCESS) == FALSE)
-        CloseHandle(tmpIn);
-    }
-    if (hIn == INVALID_HANDLE_VALUE) {
-      fprintf(stderr, "process_easy: DuplicateHandle(In) failed (e=%ld)\n", e);
-      return INVALID_HANDLE_VALUE;
-    }
-  }
-  if (outfd >= 0)
-    tmpOut = (HANDLE)_get_osfhandle (outfd);
-  else
-    tmpOut = GetStdHandle (STD_OUTPUT_HANDLE);
-  if (DuplicateHandle(GetCurrentProcess(),
-                      tmpOut,
-                      GetCurrentProcess(),
-                      &hOut,
-                      0,
-                      TRUE,
-                      DUPLICATE_SAME_ACCESS) == FALSE) {
-    if ((e = GetLastError()) == ERROR_INVALID_HANDLE) {
-      tmpOut = CreateFile("NUL", GENERIC_WRITE,
-                          FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
-                          OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
-      if (tmpOut != INVALID_HANDLE_VALUE
-          && DuplicateHandle(GetCurrentProcess(),
-                             tmpOut,
-                             GetCurrentProcess(),
-                             &hOut,
-                             0,
-                             TRUE,
-                             DUPLICATE_SAME_ACCESS) == FALSE)
-        CloseHandle(tmpOut);
-    }
-    if (hOut == INVALID_HANDLE_VALUE) {
-      fprintf(stderr, "process_easy: DuplicateHandle(Out) failed (e=%ld)\n", e);
-      return INVALID_HANDLE_VALUE;
-    }
-  }
-  if (errfd >= 0)
-    tmpErr = (HANDLE)_get_osfhandle (errfd);
-  else
-    tmpErr = GetStdHandle(STD_ERROR_HANDLE);
-  if (DuplicateHandle(GetCurrentProcess(),
-                      tmpErr,
-                      GetCurrentProcess(),
-                      &hErr,
-                      0,
-                      TRUE,
-                      DUPLICATE_SAME_ACCESS) == FALSE) {
-    if ((e = GetLastError()) == ERROR_INVALID_HANDLE) {
-      tmpErr = CreateFile("NUL", GENERIC_WRITE,
-                          FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
-                          OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
-      if (tmpErr != INVALID_HANDLE_VALUE
-          && DuplicateHandle(GetCurrentProcess(),
-                             tmpErr,
-                             GetCurrentProcess(),
-                             &hErr,
-                             0,
-                             TRUE,
-                             DUPLICATE_SAME_ACCESS) == FALSE)
-        CloseHandle(tmpErr);
-    }
-    if (hErr == INVALID_HANDLE_VALUE) {
-      fprintf(stderr, "process_easy: DuplicateHandle(Err) failed (e=%ld)\n", e);
-      return INVALID_HANDLE_VALUE;
-    }
-  }
-
-  hProcess = process_init_fd(hIn, hOut, hErr);
-
-  if (process_begin(hProcess, argv, envp, argv[0], NULL)) {
-    fake_exits_pending++;
-    /* process_begin() failed: make a note of that.  */
-    if (!((sub_process*) hProcess)->last_err)
-      ((sub_process*) hProcess)->last_err = -1;
-    ((sub_process*) hProcess)->exit_code = process_last_err(hProcess);
-
-    /* close up unused handles */
-    if (hIn != INVALID_HANDLE_VALUE)
-      CloseHandle(hIn);
-    if (hOut != INVALID_HANDLE_VALUE)
-      CloseHandle(hOut);
-    if (hErr != INVALID_HANDLE_VALUE)
-      CloseHandle(hErr);
-  }
-
-  process_register(hProcess);
-
-  return hProcess;
-}
diff --git a/w32/subproc/w32err.c b/w32/subproc/w32err.c
deleted file mode 100644
index 16537d2..0000000
--- a/w32/subproc/w32err.c
+++ /dev/null
@@ -1,85 +0,0 @@
-/* Error handling for Windows
-Copyright (C) 1996-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include <stdlib.h>
-#include <windows.h>
-#include "makeint.h"
-#include "w32err.h"
-
-/*
- * Description: the windows32 version of perror()
- *
- * Returns:  a pointer to a static error
- *
- * Notes/Dependencies:  I got this from
- *      comp.os.ms-windows.programmer.win32
- */
-const char *
-map_windows32_error_to_string (DWORD ercode) {
-/*
- * We used to have an MSVC-specific '__declspec (thread)' qualifier
- * here, with the following comment:
- *
- * __declspec (thread) necessary if you will use multiple threads on MSVC
- *
- * However, Make was never multithreaded on Windows (except when
- * Ctrl-C is hit, in which case the main thread is stopped
- * immediately, so it doesn't matter in this context).  The functions
- * on sub_proc.c that started and stopped additional threads were
- * never used, and are now #ifdef'ed away.  Until we need more than
- * one thread, we have no problems with the following buffer being
- * static.  (If and when we do need it to be in thread-local storage,
- * the corresponding GCC qualifier is '__thread'.)
- */
-    static char szMessageBuffer[128];
-        /* Fill message buffer with a default message in
-         * case FormatMessage fails
-         */
-    wsprintf (szMessageBuffer, "Error %ld\n", ercode);
-
-        /*
-         *  Special code for winsock error handling.
-         */
-        if (ercode > WSABASEERR) {
-#if 0
-                HMODULE hModule = GetModuleHandle("wsock32");
-                if (hModule != NULL) {
-                        FormatMessage(FORMAT_MESSAGE_FROM_HMODULE,
-                                hModule,
-                                ercode,
-                                LANG_NEUTRAL,
-                                szMessageBuffer,
-                                sizeof(szMessageBuffer),
-                                NULL);
-                        FreeLibrary(hModule);
-                }
-#else
-                O (fatal, NILF, szMessageBuffer);
-#endif
-        } else {
-                /*
-                 *  Default system message handling
-                 */
-                FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
-                        NULL,
-                        ercode,
-                        LANG_NEUTRAL,
-                        szMessageBuffer,
-                        sizeof(szMessageBuffer),
-                        NULL);
-        }
-    return szMessageBuffer;
-}
diff --git a/w32/w32os.c b/w32/w32os.c
deleted file mode 100644
index 0023e79..0000000
--- a/w32/w32os.c
+++ /dev/null
@@ -1,218 +0,0 @@
-/* Windows32-based operating system interface for GNU Make.
-Copyright (C) 2016-2017 Free Software Foundation, Inc.
-This file is part of GNU Make.
-
-GNU Make is free software; you can redistribute it and/or modify it under the
-terms of the GNU General Public License as published by the Free Software
-Foundation; either version 3 of the License, or (at your option) any later
-version.
-
-GNU Make is distributed in the hope that it will be useful, but WITHOUT ANY
-WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
-A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License along with
-this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "makeint.h"
-
-#include <stdio.h>
-#include <string.h>
-
-#include <windows.h>
-#include <process.h>
-#include <io.h>
-#include "pathstuff.h"
-#include "sub_proc.h"
-#include "w32err.h"
-#include "os.h"
-#include "debug.h"
-
-/* This section provides OS-specific functions to support the jobserver.  */
-
-static char jobserver_semaphore_name[MAX_PATH + 1];
-static HANDLE jobserver_semaphore = NULL;
-
-unsigned int
-jobserver_setup (int slots)
-{
-  /* sub_proc.c is limited in the number of objects it can wait for. */
-
-  if (slots > process_table_usable_size())
-    {
-      slots = process_table_usable_size();
-      DB (DB_JOBS, (_("Jobserver slots limited to %d\n"), slots));
-    }
-
-  sprintf (jobserver_semaphore_name, "gmake_semaphore_%d", _getpid ());
-
-  jobserver_semaphore = CreateSemaphore (
-      NULL,                           /* Use default security descriptor */
-      slots,                          /* Initial count */
-      slots,                          /* Maximum count */
-      jobserver_semaphore_name);      /* Semaphore name */
-
-  if (jobserver_semaphore == NULL)
-    {
-      DWORD err = GetLastError ();
-      const char *estr = map_windows32_error_to_string (err);
-      ONS (fatal, NILF,
-           _("creating jobserver semaphore: (Error %ld: %s)"), err, estr);
-    }
-
-  return 1;
-}
-
-unsigned int
-jobserver_parse_auth (const char *auth)
-{
-  jobserver_semaphore = OpenSemaphore (
-      SEMAPHORE_ALL_ACCESS,   /* Semaphore access setting */
-      FALSE,                  /* Child processes DON'T inherit */
-      auth);                  /* Semaphore name */
-
-  if (jobserver_semaphore == NULL)
-    {
-      DWORD err = GetLastError ();
-      const char *estr = map_windows32_error_to_string (err);
-      fatal (NILF, strlen (auth) + INTSTR_LENGTH + strlen (estr),
-             _("internal error: unable to open jobserver semaphore '%s': (Error %ld: %s)"),
-             auth, err, estr);
-    }
-  DB (DB_JOBS, (_("Jobserver client (semaphore %s)\n"), auth));
-
-  return 1;
-}
-
-char *
-jobserver_get_auth ()
-{
-  return xstrdup (jobserver_semaphore_name);
-}
-
-unsigned int
-jobserver_enabled ()
-{
-  return jobserver_semaphore != NULL;
-}
-
-/* Close jobserver semaphore */
-void
-jobserver_clear ()
-{
-  if (jobserver_semaphore != NULL)
-    {
-      CloseHandle (jobserver_semaphore);
-      jobserver_semaphore = NULL;
-    }
-}
-
-void
-jobserver_release (int is_fatal)
-{
-  if (! ReleaseSemaphore (
-          jobserver_semaphore,    /* handle to semaphore */
-          1,                      /* increase count by one */
-          NULL))                  /* not interested in previous count */
-    {
-      if (is_fatal)
-        {
-          DWORD err = GetLastError ();
-          const char *estr = map_windows32_error_to_string (err);
-          ONS (fatal, NILF,
-               _("release jobserver semaphore: (Error %ld: %s)"), err, estr);
-        }
-      perror_with_name ("release_jobserver_semaphore", "");
-    }
-}
-
-unsigned int
-jobserver_acquire_all ()
-{
-  unsigned int tokens = 0;
-  while (1)
-    {
-      DWORD dwEvent = WaitForSingleObject (
-          jobserver_semaphore,    /* Handle to semaphore */
-          0);                     /* DON'T wait on semaphore */
-
-      if (dwEvent != WAIT_OBJECT_0)
-        return tokens;
-
-      ++tokens;
-    }
-}
-
-void
-jobserver_signal ()
-{
-}
-
-void jobserver_pre_child (int recursive)
-{
-}
-
-void jobserver_post_child (int recursive)
-{
-}
-
-void
-jobserver_pre_acquire ()
-{
-}
-
-/* Returns 1 if we got a token, or 0 if a child has completed.
-   The Windows implementation doesn't support load detection.  */
-unsigned int
-jobserver_acquire (int timeout)
-{
-    HANDLE *handles;
-    DWORD dwHandleCount;
-    DWORD dwEvent;
-
-    handles = xmalloc(process_table_actual_size() * sizeof(HANDLE));
-
-    /* Add jobserver semaphore to first slot. */
-    handles[0] = jobserver_semaphore;
-
-    /* Build array of handles to wait for.  */
-    dwHandleCount = 1 + process_set_handles (&handles[1]);
-
-    dwEvent = process_wait_for_multiple_objects (
-        dwHandleCount,  /* number of objects in array */
-        handles,        /* array of objects */
-        FALSE,          /* wait for any object */
-        INFINITE);      /* wait until object is signalled */
-
-    free(handles);
-
-    if (dwEvent == WAIT_FAILED)
-      {
-        DWORD err = GetLastError ();
-        const char *estr = map_windows32_error_to_string (err);
-        ONS (fatal, NILF,
-             _("semaphore or child process wait: (Error %ld: %s)"),
-             err, estr);
-      }
-
-    /* WAIT_OBJECT_0 indicates that the semaphore was signalled.  */
-    return dwEvent == WAIT_OBJECT_0;
-}
-
-void
-fd_inherit(int fd)
-{
-  HANDLE fh = (HANDLE)_get_osfhandle(fd);
-
-  if (fh && fh != INVALID_HANDLE_VALUE)
-        SetHandleInformation(fh, HANDLE_FLAG_INHERIT, 1);
-}
-
-void
-fd_noinherit(int fd)
-{
-  HANDLE fh = (HANDLE)_get_osfhandle(fd);
-
-  if (fh && fh != INVALID_HANDLE_VALUE)
-        SetHandleInformation(fh, HANDLE_FLAG_INHERIT, 0);
-}
-- 
cgit v1.0-41-gc330

