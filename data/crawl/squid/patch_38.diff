----++++src/CacheDigest.cc
@@ -35,25 +35,25 @@ static void cacheDigestHashKey(const CacheDigest * cd, const cache_key * key);
 static uint32_t hashed_keys[4];
 
 void
-CacheDigest::init(int newCapacity)
+CacheDigest::init(uint64_t newCapacity)
 {
     const auto newMaskSz = CacheDigest::CalcMaskSize(newCapacity, bits_per_entry);
     assert(newCapacity &gt; 0 &amp;&amp; bits_per_entry &gt; 0);
-    assert(newMaskSz &gt; 0);
+    assert(newMaskSz != 0);
     capacity = newCapacity;
     mask_size = newMaskSz;
     mask = static_cast&lt;char *&gt;(xcalloc(mask_size,1));
     debugs(70, 2, &quot;capacity: &quot; &lt;&lt; capacity &lt;&lt; &quot; entries, bpe: &quot; &lt;&lt; bits_per_entry &lt;&lt; &quot;; size: &quot;
            &lt;&lt; mask_size &lt;&lt; &quot; bytes&quot;);
 }
 
-CacheDigest::CacheDigest(int aCapacity, int bpe) :
+CacheDigest::CacheDigest(uint64_t aCapacity, uint8_t bpe) :
+    count(0),
+    del_count(0),
+    capacity(0),
     mask(nullptr),
     mask_size(0),
-    capacity(0),
-    bits_per_entry(bpe),
-    count(0),
-    del_count(0)
+    bits_per_entry(bpe)
 {
     assert(SQUID_MD5_DIGEST_LENGTH == 16);  /* our hash functions rely on 16 byte keys */
     updateCapacity(aCapacity);
@@ -83,7 +83,7 @@ CacheDigest::clear()
 }
 
 void
-CacheDigest::updateCapacity(int newCapacity)
+CacheDigest::updateCapacity(uint64_t newCapacity)
 {
     safe_free(mask);
     init(newCapacity); // will re-init mask and mask_size
@@ -261,12 +261,12 @@ cacheDigestReport(CacheDigest * cd, const char *label, StoreEntry * e)
     storeAppendPrintf(e, &quot;%s digest: size: %d bytes\n&quot;,
                       label ? label : &quot;&quot;, stats.bit_count / 8
                      );
-    storeAppendPrintf(e, "\t entries: count: %d capacity: %d util: %d%%\n",
+    storeAppendPrintf(e, "\t entries: count: %" PRIu64 " capacity: %" PRIu64 " util: %d%%\n",
                       cd-&gt;count,
                       cd-&gt;capacity,
                       xpercentInt(cd-&gt;count, cd-&gt;capacity)
                      );
-    storeAppendPrintf(e, "\t deletion attempts: %d\n",
+    storeAppendPrintf(e, "\t deletion attempts: %" PRIu64 "\n",
                       cd-&gt;del_count
                      );
     storeAppendPrintf(e, &quot;\t bits: per entry: %d on: %d capacity: %d util: %d%%\n&quot;,
@@ -280,17 +280,18 @@ cacheDigestReport(CacheDigest * cd, const char *label, StoreEntry * e)
                      );
 }
 
-size_t
-CacheDigest::CalcMaskSize(int cap, int bpe)
+uint32_t
+CacheDigest::CalcMaskSize(uint64_t cap, uint8_t bpe)
 {
-    // XXX: might 32-bit overflow during multiply
-    return (size_t) (cap * bpe + 7) / 8;
+    uint64_t bitCount = (cap * bpe) + 7;
+    assert(bitCount &lt; INT_MAX); // dont 31-bit overflow later
+    return static_cast&lt;uint32_t&gt;(bitCount / 8);
 }
 
 static void
 cacheDigestHashKey(const CacheDigest * cd, const cache_key * key)
 {
-    const unsigned int bit_count = cd-&gt;mask_size * 8;
+    const uint32_t bit_count = cd-&gt;mask_size * 8;
     unsigned int tmp_keys[4];
     /* we must memcpy to ensure alignment */
     memcpy(tmp_keys, key, sizeof(tmp_keys));
----++++src/CacheDigest.h
@@ -21,7 +21,7 @@ class CacheDigest
 {
     MEMPROXY_CLASS(CacheDigest);
 public:
-    CacheDigest(int capacity, int bpe);
+    CacheDigest(uint64_t capacity, uint8_t bpe);
     ~CacheDigest();
 
     // NP: only used by broken unit-test
@@ -32,7 +32,7 @@ class CacheDigest
     void clear();
 
     /// changes mask size to fit newCapacity, resets bits to 0
-    void updateCapacity(int newCapacity);
+    void updateCapacity(uint64_t newCapacity);
 
     void add(const cache_key * key);
     void remove(const cache_key * key);
@@ -45,19 +45,19 @@ class CacheDigest
 
     /// calculate the size of mask required to digest up to
     /// a specified capacity and bitsize.
-    static size_t CalcMaskSize(int cap, int bpe);
+    static uint32_t CalcMaskSize(uint64_t cap, uint8_t bpe);
 
 private:
-    void init(int newCapacity);
+    void init(uint64_t newCapacity);
 
 public:
     /* public, read-only */
-    char *mask;         /* bit mask */
-    int mask_size;      /* mask size in bytes */
-    int capacity;       /* expected maximum for .count, not a hard limit */
-    int bits_per_entry;     /* number of bits allocated for each entry from capacity */
-    int count;          /* number of digested entries */
-    int del_count;      /* number of deletions performed so far */
+    uint64_t count;          /* number of digested entries */
+    uint64_t del_count;      /* number of deletions performed so far */
+    uint64_t capacity;       /* expected maximum for .count, not a hard limit */
+    char *mask;              /* bit mask */
+    uint32_t mask_size;      /* mask size in bytes */
+    int8_t bits_per_entry;   /* number of bits allocated for each entry from capacity */
 };
 
 void cacheDigestGuessStatsUpdate(CacheDigestGuessStats * stats, int real_hit, int guess_hit);
----++++src/PeerDigest.h
@@ -56,7 +56,7 @@ class DigestFetchState
     store_client *old_sc;
     HttpRequest *request;
     int offset;
-    int mask_offset;
+    uint32_t mask_offset;
     time_t start_time;
     time_t resp_time;
     time_t expires;
----++++src/peer_digest.cc
@@ -746,7 +746,7 @@ peerDigestFetchedEnough(DigestFetchState * fetch, char *buf, ssize_t size, const
     if (!reason &amp;&amp; !size) {
         if (!pd-&gt;cd)
             reason = &quot;null digest?!&quot;;
-        else if (fetch-&gt;mask_offset != (int)pd-&gt;cd-&gt;mask_size)
+        else if (fetch-&gt;mask_offset != pd-&gt;cd-&gt;mask_size)
             reason = &quot;premature end of digest?!&quot;;
         else if (!peerDigestUseful(pd))
             reason = &quot;useless digest&quot;;
----++++src/store_digest.cc
@@ -77,36 +77,63 @@ static void storeDigestRewriteResume(void);
 static void storeDigestRewriteFinish(StoreEntry * e);
 static EVH storeDigestSwapOutStep;
 static void storeDigestCBlockSwapOut(StoreEntry * e);
-static int storeDigestCalcCap(void);
-static int storeDigestResize(void);
 static void storeDigestAdd(const StoreEntry *);
 
-#endif /* USE_CACHE_DIGESTS */
-
 static void
 storeDigestRegisterWithCacheManager(void)
 {
     Mgr::RegisterAction(&quot;store_digest&quot;, &quot;Store Digest&quot;, storeDigestReport, 0, 1);
 }
 
-/*
- * PUBLIC FUNCTIONS
- */
+/// calculates digest capacity
+static uint64_t
+storeDigestCalcCap()
+{
+    /*
+     * To-Do: Bloom proved that the optimal filter utilization is 50% (half of
+     * the bits are off). However, we do not have a formula to calculate the
+     * number of _entries_ we want to pre-allocate for.
+     */
+    const uint64_t hi_cap = Store::Root().maxSize() / Config.Store.avgObjectSize;
+    const uint64_t lo_cap = 1 + Store::Root().currentSize() / Config.Store.avgObjectSize;
+    const uint64_t e_count = StoreEntry::inUseCount();
+    uint64_t cap = e_count ? e_count : hi_cap;
+    debugs(71, 2, &quot;have: &quot; &lt;&lt; e_count &lt;&lt; &quot;, want &quot; &lt;&lt; cap &lt;&lt;
+           &quot; entries; limits: [&quot; &lt;&lt; lo_cap &lt;&lt; &quot;, &quot; &lt;&lt; hi_cap &lt;&lt; &quot;]&quot;);
+
+    if (cap &lt; lo_cap)
+        cap = lo_cap;
+
+    /* do not enforce hi_cap limit, average-based estimation may be wrong
+     *if (cap &gt; hi_cap)
+     *  cap = hi_cap;
+     */
+
+    // Bug 4534: we still have to set an upper-limit at some reasonable value though.
+    // this matches cacheDigestCalcMaskSize doing (cap*bpe)+7 &lt; INT_MAX
+    const uint64_t absolute_max = (INT_MAX -8) / Config.digest.bits_per_entry;
+    if (cap &gt; absolute_max) {
+        debugs(71, DBG_CRITICAL, &quot;WARNING: Cache Digest cannot store &quot; &lt;&lt; cap &lt;&lt; &quot; entries. Limiting to &quot; &lt;&lt; absolute_max);
+        cap = absolute_max;
+    }
+
+    return cap;
+}
+#endif /* USE_CACHE_DIGESTS */
 
 void
 storeDigestInit(void)
 {
     storeDigestRegisterWithCacheManager();
 
 #if USE_CACHE_DIGESTS
-    const int cap = storeDigestCalcCap();
-
     if (!Config.onoff.digest_generation) {
         store_digest = NULL;
         debugs(71, 3, &quot;Local cache digest generation disabled&quot;);
         return;
     }
 
+    const uint64_t cap = storeDigestCalcCap();
     store_digest = new CacheDigest(cap, Config.digest.bits_per_entry);
     debugs(71, DBG_IMPORTANT, &quot;Local cache digest enabled; rebuild/rewrite every &quot; &lt;&lt;
            (int) Config.digest.rebuild_period &lt;&lt; &quot;/&quot; &lt;&lt;
@@ -291,6 +318,27 @@ storeDigestRebuildStart(void *datanotused)
     storeDigestRebuildResume();
 }
 
+/// \returns true if we actually resized the digest
+static bool
+storeDigestResize()
+{
+    const uint64_t cap = storeDigestCalcCap();
+    assert(store_digest);
+    uint64_t diff = abs(cap - store_digest-&gt;capacity);
+    debugs(71, 2, store_digest-&gt;capacity &lt;&lt; &quot; -&gt; &quot; &lt;&lt; cap &lt;&lt; &quot;; change: &quot; &lt;&lt;
+           diff &lt;&lt; &quot; (&quot; &lt;&lt; xpercentInt(diff, store_digest-&gt;capacity) &lt;&lt; &quot;%)&quot; );
+    /* avoid minor adjustments */
+
+    if (diff &lt;= store_digest-&gt;capacity / 10) {
+        debugs(71, 2, &quot;small change, will not resize.&quot;);
+        return false;
+    } else {
+        debugs(71, 2, &quot;big change, resizing.&quot;);
+        store_digest-&gt;updateCapacity(cap);
+    }
+    return true;
+}
+
 /* called be Rewrite to push Rebuild forward */
 static void
 storeDigestRebuildResume(void)
@@ -440,7 +488,7 @@ storeDigestSwapOutStep(void *data)
     assert(e);
     /* _add_ check that nothing bad happened while we were waiting @?@ @?@ */
 
-    if (sd_state.rewrite_offset + chunk_size &gt; store_digest-&gt;mask_size)
+    if (static_cast&lt;uint32_t&gt;(sd_state.rewrite_offset + chunk_size) &gt; store_digest-&gt;mask_size)
         chunk_size = store_digest-&gt;mask_size - sd_state.rewrite_offset;
 
     e-&gt;append(store_digest-&gt;mask + sd_state.rewrite_offset, chunk_size);
@@ -452,7 +500,7 @@ storeDigestSwapOutStep(void *data)
     sd_state.rewrite_offset += chunk_size;
 
     /* are we done ? */
-    if (sd_state.rewrite_offset &gt;= store_digest-&gt;mask_size)
+    if (static_cast&lt;uint32_t&gt;(sd_state.rewrite_offset) &gt;= store_digest-&gt;mask_size)
         storeDigestRewriteFinish(e);
     else
         eventAdd(&quot;storeDigestSwapOutStep&quot;, storeDigestSwapOutStep, data, 0.0, 1, false);
@@ -468,60 +516,10 @@ storeDigestCBlockSwapOut(StoreEntry * e)
     sd_state.cblock.count = htonl(store_digest-&gt;count);
     sd_state.cblock.del_count = htonl(store_digest-&gt;del_count);
     sd_state.cblock.mask_size = htonl(store_digest-&gt;mask_size);
-    sd_state.cblock.bits_per_entry = (unsigned char)
-                                     Config.digest.bits_per_entry;
+    sd_state.cblock.bits_per_entry = Config.digest.bits_per_entry;
     sd_state.cblock.hash_func_count = (unsigned char) CacheDigestHashFuncCount;
     e-&gt;append((char *) &amp;sd_state.cblock, sizeof(sd_state.cblock));
 }
 
-/* calculates digest capacity */
-static int
-storeDigestCalcCap(void)
-{
-    /*
-     * To-Do: Bloom proved that the optimal filter utilization is 50% (half of
-     * the bits are off). However, we do not have a formula to calculate the
-     * number of _entries_ we want to pre-allocate for.
-     */
-    const int hi_cap = Store::Root().maxSize() / Config.Store.avgObjectSize;
-    const int lo_cap = 1 + Store::Root().currentSize() / Config.Store.avgObjectSize;
-    const int e_count = StoreEntry::inUseCount();
-    int cap = e_count ? e_count :hi_cap;
-    debugs(71, 2, &quot;storeDigestCalcCap: have: &quot; &lt;&lt; e_count &lt;&lt; &quot;, want &quot; &lt;&lt; cap &lt;&lt;
-           &quot; entries; limits: [&quot; &lt;&lt; lo_cap &lt;&lt; &quot;, &quot; &lt;&lt; hi_cap &lt;&lt; &quot;]&quot;);
-
-    if (cap &lt; lo_cap)
-        cap = lo_cap;
-
-    /* do not enforce hi_cap limit, average-based estimation may be wrong
-     *if (cap &gt; hi_cap)
-     *  cap = hi_cap;
-     */
-    return cap;
-}
-
-/* returns true if we actually resized the digest */
-static int
-storeDigestResize(void)
-{
-    const int cap = storeDigestCalcCap();
-    int diff;
-    assert(store_digest);
-    diff = abs(cap - store_digest-&gt;capacity);
-    debugs(71, 2, &quot;storeDigestResize: &quot; &lt;&lt;
-           store_digest-&gt;capacity &lt;&lt; &quot; -&gt; &quot; &lt;&lt; cap &lt;&lt; &quot;; change: &quot; &lt;&lt;
-           diff &lt;&lt; &quot; (&quot; &lt;&lt; xpercentInt(diff, store_digest-&gt;capacity) &lt;&lt; &quot;%)&quot; );
-    /* avoid minor adjustments */
-
-    if (diff &lt;= store_digest-&gt;capacity / 10) {
-        debugs(71, 2, &quot;storeDigestResize: small change, will not resize.&quot;);
-        return 0;
-    } else {
-        debugs(71, 2, &quot;storeDigestResize: big change, resizing.&quot;);
-        store_digest-&gt;updateCapacity(cap);
-        return 1;
-    }
-}
-
 #endif /* USE_CACHE_DIGESTS */
 
----++++src/tests/stub_CacheDigest.cc
@@ -17,17 +17,17 @@ class CacheDigestGuessStats;
 class StoreEntry;
 
 #include &quot;CacheDigest.h&quot;
-CacheDigest::CacheDigest(int, int) {STUB}
+CacheDigest::CacheDigest(uint64_t, uint8_t) {STUB}
 CacheDigest::~CacheDigest() {STUB}
 CacheDigest *CacheDigest::clone() const STUB_RETVAL(nullptr)
 void CacheDigest::clear() STUB
-void CacheDigest::updateCapacity(int) STUB
+void CacheDigest::updateCapacity(uint64_t) STUB
 bool CacheDigest::contains(const cache_key *) const STUB_RETVAL(false)
 void CacheDigest::add(const cache_key *) STUB
 void CacheDigest::remove(const cache_key *) STUB
 double CacheDigest::usedMaskPercent() const STUB_RETVAL(0.0)
 void cacheDigestGuessStatsUpdate(CacheDigestGuessStats *, int, int) STUB
 void cacheDigestGuessStatsReport(const CacheDigestGuessStats *, StoreEntry *, const char *) STUB
 void cacheDigestReport(CacheDigest *, const char *, StoreEntry *) STUB
-size_t CacheDigest::CalcMaskSize(int, int) STUB_RETVAL(1)
+uint32_t CacheDigest::CalcMaskSize(uint64_t, uint8_t) STUB_RETVAL(1)
 
----++++GitHub