----++++src/client_side.cc
@@ -52,7 +52,7 @@
  * data, or sending it.
  *
  \par
- * ClientKeepAliveNextRequest will then detect the presence of data in
+ * ConnStateData::kick() will then detect the presence of data in
  * the next ClientHttpRequest, and will send it, restablishing the
  * data flow.
  */
@@ -1427,19 +1427,14 @@ ClientSocketContextPushDeferredIfNeeded(ClientSocketContext::Pointer deferredReq
      */
 }
 
-/// called when we have successfully finished writing the response
-void
-ClientSocketContext::keepaliveNextRequest()
-{
-    debugs(33, 3, &quot;ConnnStateData(&quot; &lt;&lt; http-&gt;getConn()-&gt;clientConnection &lt;&lt; &quot;), Context(&quot; &lt;&lt; clientConnection &lt;&lt; &quot;)&quot;);
-
-    // mark ourselves as completed
-    connIsFinished();
-}
-
 void
 ConnStateData::kick()
 {
+    if (!Comm::IsConnOpen(clientConnection)) {
+        debugs(33, 2, clientConnection &lt;&lt; &quot; Connection was closed&quot;);
+        return;
+    }
+
     if (pinning.pinned &amp;&amp; !Comm::IsConnOpen(pinning.serverConnection)) {
         debugs(33, 2, clientConnection &lt;&lt; &quot; Connection was pinned but server side gone. Terminating client connection&quot;);
         clientConnection-&gt;close();
@@ -1704,6 +1699,7 @@ ClientSocketContext::doClose()
 void
 ClientSocketContext::initiateClose(const char *reason)
 {
+    debugs(33, 4, clientConnection &lt;&lt; &quot; because &quot; &lt;&lt; reason);
     http-&gt;getConn()-&gt;stopSending(reason); // closes ASAP
 }
 
@@ -1760,10 +1756,9 @@ ClientSocketContext::writeComplete(const Comm::ConnectionPointer &amp;conn, char *,
 
     case STREAM_COMPLETE:
         debugs(33, 5, conn &lt;&lt; &quot; Stream complete, keepalive is &quot; &lt;&lt; http-&gt;request-&gt;flags.proxyKeepalive);
-        if (http-&gt;request-&gt;flags.proxyKeepalive)
-            keepaliveNextRequest();
-        else
-            initiateClose(&quot;STREAM_COMPLETE NOKEEPALIVE&quot;);
+        if (!http-&gt;request-&gt;flags.proxyKeepalive)
+            clientConnection-&gt;close();
+        connIsFinished();
         return;
 
     case STREAM_UNPLANNED_COMPLETE:
@@ -4717,7 +4712,7 @@ ConnStateData::clientPinnedConnectionRead(const CommIoCbParams &amp;io)
     pinning.serverConnection-&gt;close();
 
     // If we are still sending data to the client, do not close now. When we are done sending,
-    // ClientSocketContext::keepaliveNextRequest() checks pinning.serverConnection and will close.
+    // ConnStateData::kick() checks pinning.serverConnection and will close.
     // However, if we are idle, then we must close to inform the idle client and minimize races.
     if (clientIsIdle &amp;&amp; clientConnection != NULL)
         clientConnection-&gt;close();
----++++src/client_side.h
@@ -76,7 +76,6 @@ class ClientSocketContext : public RefCountable
     ~ClientSocketContext();
     bool startOfOutput() const;
     void writeComplete(const Comm::ConnectionPointer &amp;conn, char *bufnotused, size_t size, Comm::Flag errflag);
-    void keepaliveNextRequest();
 
     Comm::ConnectionPointer clientConnection; /// details about the client connection socket.
     ClientHttpRequest *http;    /* we pretend to own that job */
----++++src/servers/FtpServer.cc
@@ -1274,7 +1274,7 @@ Ftp::Server::wroteReply(const CommIoCbParams &amp;io)
         changeState(fssConnected, &quot;Ftp::Server::wroteReply&quot;);
         if (bodyParser)
             finishDechunkingRequest(false);
-        context-&gt;keepaliveNextRequest();
+        context-&gt;connIsFinished();
         return;
     }
 }
----++++src/tests/stub_client_side.cc
@@ -16,7 +16,6 @@
 //ClientSocketContext::~ClientSocketContext() STUB
 bool ClientSocketContext::startOfOutput() const STUB_RETVAL(false)
 void ClientSocketContext::writeComplete(const Comm::ConnectionPointer &amp;conn, char *bufnotused, size_t size, Comm::Flag errflag) STUB
-void ClientSocketContext::keepaliveNextRequest() STUB
 void ClientSocketContext::pullData() STUB
 int64_t ClientSocketContext::getNextRangeOffset() const STUB_RETVAL(0)
 bool ClientSocketContext::canPackMoreRanges() const STUB_RETVAL(false)
----++++GitHub