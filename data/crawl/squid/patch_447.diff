@@ -38,7 +38,7 @@ void ClientDelayConfig::dumpPoolCount(StoreEntry * entry, const char *name) cons
 {
     if (pools.size()) {
         storeAppendPrintf(entry, "%s %d\n", name, (int)pools.size());
-        for (unsigned int i = 0; i < pools.size(); i++)
+        for (unsigned int i = 0; i < pools.size(); ++i)
             pools[i].dump(entry, i);
     }
 }
@@ -51,7 +51,7 @@ void ClientDelayConfig::parsePoolCount()
     }
     unsigned short pools_;
     ConfigParser::ParseUShort(&pools_);
-    for (int i = 0; i < pools_; i++) {
+    for (int i = 0; i < pools_; ++i) {
         pools.push_back(ClientDelayPool());
     }
 }
@@ -89,7 +89,7 @@ void ClientDelayConfig::parsePoolAccess(ConfigParser &parser)
 
 void ClientDelayConfig::clean()
 {
-    for (unsigned int i = 0; i < pools.size(); i++) {
+    for (unsigned int i = 0; i < pools.size(); ++i) {
         aclDestroyAccessList(&pools[i].access);
     }
 }
@@ -66,7 +66,7 @@ ConfigParser::strtokFile(void)
                 fn = ++t;
 
                 while (*t && *t != '\"' && *t != '\'')
-                    t++;
+                    ++t;
 
                 *t = '\0';
 
@@ -144,7 +144,7 @@ ConfigParser::ParseQuotedString(String *var)
             const char * next = s+1; // may point to 0
             memmove(s, next, strlen(next) + 1);
         }
-        s++;
+        ++s;
     }
 
     if (*s != '"') {
@@ -164,15 +164,15 @@ ConfigParser::QuoteString(String &var)
     const char *s = var.termedBuf();
     bool  needQuote = false;
 
-    for (const char *l = s; !needQuote &&  *l != '\0'; l++  )
+    for (const char *l = s; !needQuote &&  *l != '\0'; ++l  )
         needQuote = !isalnum(*l);
 
     if (!needQuote)
         return s;
 
     quotedStr.clean();
     quotedStr.append('"');
-    for (; *s != '\0'; s++) {
+    for (; *s != '\0'; ++s) {
         if (*s == '"' || *s == '\\')
             quotedStr.append('\\');
         quotedStr.append(*s);
@@ -138,7 +138,7 @@ DelayConfig::dumpPoolCount(StoreEntry * entry, const char *name) const
 
     storeAppendPrintf(entry, "%s %d\n", name, DelayPools::pools());
 
-    for (i = 0; i < DelayPools::pools(); i++)
+    for (i = 0; i < DelayPools::pools(); ++i)
         DelayPools::delay_data[i].dump (entry, i);
 }
 
@@ -105,7 +105,7 @@ DelayId::DelayClient(ClientHttpRequest * http)
         return DelayId();
     }
 
-    for (pool = 0; pool < DelayPools::pools(); pool++) {
+    for (pool = 0; pool < DelayPools::pools(); ++pool) {
 
         /* pools require explicit 'allow' to assign a client into them */
         if (!DelayPools::delay_data[pool].access) {
@@ -90,7 +90,7 @@ httpHdrRangeRespSpecParseInit(HttpHdrRangeSpec * spec, const char *field, int fl
         return 0;
     }
 
-    p++;
+    ++p;
 
     /* do we have last-pos ? */
     if (p - field >= flen) {
@@ -182,7 +182,7 @@ httpHdrContRangeParseInit(HttpHdrContRange * range, const char *str)
     else if (!httpHdrRangeRespSpecParseInit(&range->spec, str, p - str))
         return 0;
 
-    p++;
+    ++p;
 
     if (*p == '*')
         range->elength = range_spec_unknown;
@@ -104,7 +104,7 @@ HttpHdrRangeSpec::parseInit(const char *field, int flen)
             if (!httpHeaderParseOffset(field, &offset))
                 return false;
 
-            p++;
+            ++p;
 
             /* do we have last-pos ? */
             if (p - field < flen) {
@@ -136,7 +136,7 @@ HttpHdrSc::parse(const String * str)
         if ((p = strchr(item, '=')) && (p - item < ilen)) {
             vlen = ilen - (p + 1 - item);
             ilen = p - item;
-            p++;
+            ++p;
         }
 
         /* decrease ilen to still match the token for ';' qualified non '=' statments */
@@ -175,7 +175,7 @@ HttpHdrSc::parse(const String * str)
             if (type != SC_OTHER)
                 debugs(90, 2, "hdr sc: ignoring duplicate control-directive: near '" << item << "' in '" << str << "'");
 
-            ScFieldsInfo[type].stat.repCount++;
+            ++ ScFieldsInfo[type].stat.repCount;
 
             continue;
         }
@@ -280,7 +280,7 @@ HttpHdrScTarget::packInto(Packer * p) const
             if (flag == SC_CONTENT)
                 packerPrintf(p, "=\"" SQUIDSTRINGPH "\"", SQUIDSTRINGPRINT(content_));
 
-            pcount++;
+            ++pcount;
         }
     }
 
@@ -340,7 +340,7 @@ httpHeaderInitModule(void)
     /* init header stats */
     assert(HttpHeaderStatCount == hoReply + 1);
 
-    for (i = 0; i < HttpHeaderStatCount; i++)
+    for (i = 0; i < HttpHeaderStatCount; ++i)
         httpHeaderStatInit(HttpHeaderStats + i, HttpHeaderStats[i].label);
 
     HttpHeaderStats[hoRequest].owner_mask = &RequestHeadersMask;
@@ -448,7 +448,7 @@ HttpHeader::clean()
         if (0 != entries.count)
             HttpHeaderStats[owner].hdrUCountDistr.count(entries.count);
 
-        HttpHeaderStats[owner].destroyedCount++;
+        ++ HttpHeaderStats[owner].destroyedCount;
 
         HttpHeaderStats[owner].busyDestroyedCount += entries.count > 0;
 
@@ -544,7 +544,7 @@ HttpHeader::parse(const char *header_start, const char *header_end)
 
     assert(header_start && header_end);
     debugs(55, 7, "parsing hdr: (" << this << ")" << std::endl << getStringPrefix(header_start, header_end));
-    HttpHeaderStats[owner].parsedCount++;
+    ++ HttpHeaderStats[owner].parsedCount;
 
     char *nulpos;
     if ((nulpos = (char*)memchr(header_start, '\0', header_end - header_start))) {
@@ -568,7 +568,7 @@ HttpHeader::parse(const char *header_start, const char *header_end)
 
             field_end = field_ptr;
 
-            field_ptr++;	/* Move to next line */
+            ++field_ptr;	/* Move to next line */
 
             if (field_end > this_line && field_end[-1] == '\r') {
                 field_end--;	/* Ignore CR LF */
@@ -733,7 +733,7 @@ HttpHeader::getEntry(HttpHeaderPos * pos) const
     assert(pos);
     assert(*pos >= HttpHeaderInitPos && *pos < (ssize_t)entries.count);
 
-    for ((*pos)++; *pos < (ssize_t)entries.count; (*pos)++) {
+    for (++(*pos); *pos < (ssize_t)entries.count; ++(*pos)) {
         if (entries.items[*pos])
             return (HttpHeaderEntry*)entries.items[*pos];
     }
@@ -900,7 +900,7 @@ HttpHeader::addEntry(HttpHeaderEntry * e)
     debugs(55, 7, HERE << this << " adding entry: " << e->id << " at " << entries.count);
 
     if (CBIT_TEST(mask, e->id))
-        Headers[e->id].stat.repCount++;
+        ++ Headers[e->id].stat.repCount;
     else
         CBIT_SET(mask, e->id);
 
@@ -922,7 +922,7 @@ HttpHeader::insertEntry(HttpHeaderEntry * e)
     debugs(55, 7, HERE << this << " adding entry: " << e->id << " at " << entries.count);
 
     if (CBIT_TEST(mask, e->id))
-        Headers[e->id].stat.repCount++;
+        ++ Headers[e->id].stat.repCount;
     else
         CBIT_SET(mask, e->id);
 
@@ -1344,7 +1344,7 @@ HttpHeader::getCc() const
         cc = NULL;
     }
 
-    HttpHeaderStats[owner].ccParsedCount++;
+    ++ HttpHeaderStats[owner].ccParsedCount;
 
     if (cc)
         httpHdrCcUpdateStats(cc, &HttpHeaderStats[owner].ccTypeDistr);
@@ -1387,7 +1387,7 @@ HttpHeader::getSc() const
 
     HttpHdrSc *sc = httpHdrScParseCreate(s);
 
-    ++HttpHeaderStats[owner].ccParsedCount;
+    ++ HttpHeaderStats[owner].ccParsedCount;
 
     if (sc)
         sc->updateStats(&HttpHeaderStats[owner].scTypeDistr);
@@ -1433,7 +1433,7 @@ HttpHeader::getAuth(http_hdr_type id, const char *auth_scheme) const
         return NULL;
 
     /* skip white space */
-    for (; field && xisspace(*field); field++);
+    for (; field && xisspace(*field); ++field);
 
     if (!*field)		/* no authorization cookie */
         return NULL;
@@ -1500,7 +1500,7 @@ HttpHeaderEntry::HttpHeaderEntry(http_hdr_type anId, const char *aName, const ch
 
     value = aValue;
 
-    Headers[id].stat.aliveCount++;
+    ++ Headers[id].stat.aliveCount;
 
     debugs(55, 9, "created HttpHeaderEntry " << this << ": '" << name << " : " << value );
 }
@@ -1533,7 +1533,7 @@ HttpHeaderEntry::parse(const char *field_start, const char *field_end)
     const char *value_start = field_start + name_len + 1;	/* skip ':' */
     /* note: value_end == field_end */
 
-    HeaderEntryParsedCount++;
+    ++ HeaderEntryParsedCount;
 
     /* do we have a valid field name within this field? */
 
@@ -1581,7 +1581,7 @@ HttpHeaderEntry::parse(const char *field_start, const char *field_end)
 
     /* trim field value */
     while (value_start < field_end && xisspace(*value_start))
-        value_start++;
+        ++value_start;
 
     while (value_start < field_end && xisspace(field_end[-1]))
         field_end--;
@@ -1599,7 +1599,7 @@ HttpHeaderEntry::parse(const char *field_start, const char *field_end)
     /* set field value */
     value.limitInit(value_start, field_end - value_start);
 
-    Headers[id].stat.seenCount++;
+    ++ Headers[id].stat.seenCount;
 
     debugs(55, 9, "parsed HttpHeaderEntry: '" << name << ": " << value << "'");
 
@@ -1653,10 +1653,10 @@ HttpHeaderEntry::getInt64() const
 static void
 httpHeaderNoteParsedEntry(http_hdr_type id, String const &context, int error)
 {
-    Headers[id].stat.parsCount++;
+    ++ Headers[id].stat.parsCount;
 
     if (error) {
-        Headers[id].stat.errCount++;
+        ++ Headers[id].stat.errCount;
         debugs(55, 2, "cannot parse hdr field: '" << Headers[id].name << ": " << context << "'");
     }
 }
@@ -1738,7 +1738,7 @@ httpHeaderStoreReport(StoreEntry * e)
     HttpHeaderStats[0].busyDestroyedCount =
         HttpHeaderStats[hoRequest].busyDestroyedCount + HttpHeaderStats[hoReply].busyDestroyedCount;
 
-    for (i = 1; i < HttpHeaderStatCount; i++) {
+    for (i = 1; i < HttpHeaderStatCount; ++i) {
         httpHeaderStatDump(HttpHeaderStats + i, e);
         storeAppendPrintf(e, "%s\n", "<br>");
     }
@@ -348,7 +348,7 @@ httpHeaderParseQuotedString(const char *start, const int len, String *val)
     while (*pos != '"' && len > (pos-start)) {
 
         if (*pos =='\r') {
-            pos++;
+            ++pos;
             if ((pos-start) > len || *pos != '\n') {
                 debugs(66, 2, HERE << "failed to parse a quoted-string header field with '\\r' octet " << (start-pos)
                        << " bytes into '" << start << "'");
@@ -358,22 +358,22 @@ httpHeaderParseQuotedString(const char *start, const int len, String *val)
         }
 
         if (*pos == '\n') {
-            pos++;
+            ++pos;
             if ( (pos-start) > len || (*pos != ' ' && *pos != '\t')) {
                 debugs(66, 2, HERE << "failed to parse multiline quoted-string header field '" << start << "'");
                 val->clean();
                 return 0;
             }
             // TODO: replace the entire LWS with a space
             val->append(" ");
-            pos++;
+            ++pos;
             debugs(66, 2, HERE << "len < pos-start => " << len << " < " << (pos-start));
             continue;
         }
 
         bool quoted = (*pos == '\\');
         if (quoted) {
-            pos++;
+            ++pos;
             if (!*pos || (pos-start) > len) {
                 debugs(66, 2, HERE << "failed to parse a quoted-string header field near '" << start << "'");
                 val->clean();
@@ -382,7 +382,7 @@ httpHeaderParseQuotedString(const char *start, const int len, String *val)
         }
         end = pos;
         while (end < (start+len) && *end != '\\' && *end != '\"' && (unsigned char)*end > 0x1F && *end != 0x7F)
-            end++;
+            ++end;
         if (((unsigned char)*end <= 0x1F && *end != '\r' && *end != '\n') || *end == 0x7F) {
             debugs(66, 2, HERE << "failed to parse a quoted-string header field with CTL octet " << (start-pos)
                    << " bytes into '" << start << "'");
@@ -510,7 +510,7 @@ HeaderManglers::HeaderManglers()
 
 HeaderManglers::~HeaderManglers()
 {
-    for (int i = 0; i < HDR_ENUM_END; i++)
+    for (int i = 0; i < HDR_ENUM_END; ++i)
         header_mangler_clean(known[i]);
 
     typedef ManglersByName::iterator MBNI;
@@ -523,7 +523,7 @@ HeaderManglers::~HeaderManglers()
 void
 HeaderManglers::dumpAccess(StoreEntry * entry, const char *name) const
 {
-    for (int i = 0; i < HDR_ENUM_END; i++) {
+    for (int i = 0; i < HDR_ENUM_END; ++i) {
         header_mangler_dump_access(entry, name, known[i],
                                    httpHeaderNameById(i));
     }
@@ -538,7 +538,7 @@ HeaderManglers::dumpAccess(StoreEntry * entry, const char *name) const
 void
 HeaderManglers::dumpReplacement(StoreEntry * entry, const char *name) const
 {
-    for (int i = 0; i < HDR_ENUM_END; i++) {
+    for (int i = 0; i < HDR_ENUM_END; ++i) {
         header_mangler_dump_replacement(entry, name, known[i],
                                         httpHeaderNameById(i));
     }
@@ -102,11 +102,11 @@ httpMsgIsolateHeaders(const char **parse_start, int l, const char **blk_start, c
 
     *blk_end = *blk_start;
 
-    for (nnl = 0; nnl == 0; (*parse_start)++) {
+    for (nnl = 0; nnl == 0; ++(*parse_start)) {
         if (**parse_start == '\r')
             (void) 0;
         else if (**parse_start == '\n')
-            nnl++;
+            ++nnl;
         else
             break;
     }
@@ -128,10 +128,10 @@ httpMsgIsolateStart(const char **parse_start, const char **blk_start, const char
     *blk_end = *blk_start + slen;
 
     while (**blk_end == '\r')   /* CR */
-        (*blk_end)++;
+        ++(*blk_end);
 
     if (**blk_end == '\n')      /* LF */
-        (*blk_end)++;
+        ++(*blk_end);
 
     *parse_start = *blk_end;
 
@@ -360,7 +360,7 @@ void HttpMsg::firstLineBuf(MemBuf& mb)
 HttpMsg *
 HttpMsg::_lock()
 {
-    lock_count++;
+    ++lock_count;
     return this;
 }
 
@@ -46,10 +46,10 @@ HttpParser::parseRequestFirstLine()
                    "Whitespace bytes received ahead of method. " <<
                    "Ignored due to relaxed_header_parser.");
         // Be tolerant of prefix spaces (other bytes are valid method values)
-        for (; req.start < bufsiz && buf[req.start] == ' '; req.start++);
+        for (; req.start < bufsiz && buf[req.start] == ' '; ++req.start);
     }
     req.end = -1;
-    for (int i = 0; i < bufsiz; i++) {
+    for (int i = 0; i < bufsiz; ++i) {
         // track first and last whitespace (SP only)
         if (buf[i] == ' ') {
             last_whitespace = i;
@@ -79,7 +79,7 @@ HttpParser::parseRequestFirstLine()
                 if (buf[i + 1] == '\n' || buf[i + 1] == '\r')
                     line_end = i - 1;
                 while (i < bufsiz - 1 && buf[i + 1] == '\r')
-                    i++;
+                    ++i;
 
                 if (buf[i + 1] == '\n') {
                     req.end = i + 1;
@@ -191,7 +191,7 @@ HttpParser::parseRequestFirstLine()
         return -1;
     }
     int maj = 0;
-    for (; i <= line_end && (isdigit(buf[i])) && maj < 65536; i++) {
+    for (; i <= line_end && (isdigit(buf[i])) && maj < 65536; ++i) {
         maj = maj * 10;
         maj = maj + (buf[i]) - '0';
     }
@@ -218,7 +218,7 @@ HttpParser::parseRequestFirstLine()
         return -1;
     }
     int min = 0;
-    for (; i <= line_end && (isdigit(buf[i])) && min < 65536; i++) {
+    for (; i <= line_end && (isdigit(buf[i])) && min < 65536; ++i) {
         min = min * 10;
         min = min + (buf[i]) - '0';
     }
@@ -314,7 +314,7 @@ HttpRequest::parseFirstLine(const char *start, const char *end)
         while (xisspace(*end)) // find prev non-space
             end--;
 
-        end++;                 // back to space
+        ++end;                 // back to space
 
         if (2 != sscanf(ver + 5, "%d.%d", &http_ver.major, &http_ver.minor)) {
             debugs(73, 1, "parseRequestLine: Invalid HTTP identifier.");
@@ -160,7 +160,7 @@ HttpRequestMethod::Configure(SquidConfig &cfg)
     while (w) {
         char *s;
 
-        for (s = w->key; *s; s++)
+        for (s = w->key; *s; ++s)
             *s = xtoupper(*s);
 
         AddExtension(w->key);
@@ -73,7 +73,7 @@ LeakFinder::addSome(void *p, const char *file, int line)
     assert(hash_lookup(table, p) == NULL);
     LeakFinderPtr *c = new LeakFinderPtr(p, file, line);
     hash_join(table, c);
-    count++;
+    ++count;
     return p;
 }
 
@@ -499,7 +499,7 @@ clientUpdateHierCounters(HierarchyLogEntry * someEntry)
     case CD_PARENT_HIT:
 
     case CD_SIBLING_HIT:
-        statCounter.cd.times_used++;
+        ++ statCounter.cd.times_used;
         break;
 #endif
 
@@ -510,21 +510,21 @@ clientUpdateHierCounters(HierarchyLogEntry * someEntry)
     case FIRST_PARENT_MISS:
 
     case CLOSEST_PARENT_MISS:
-        statCounter.icp.times_used++;
+        ++ statCounter.icp.times_used;
         i = &someEntry->ping;
 
         if (clientPingHasFinished(i))
             statCounter.icp.querySvcTime.count(tvSubUsec(i->start, i->stop));
 
         if (i->timeout)
-            statCounter.icp.query_timeouts++;
+            ++ statCounter.icp.query_timeouts;
 
         break;
 
     case CLOSEST_PARENT:
 
     case CLOSEST_DIRECT:
-        statCounter.netdb.times_used++;
+        ++ statCounter.netdb.times_used;
 
         break;
 
@@ -539,7 +539,7 @@ ClientHttpRequest::updateCounters()
     clientUpdateStatCounters(logType);
 
     if (request->errType != ERR_NONE)
-        statCounter.client_http.errors++;
+        ++ statCounter.client_http.errors;
 
     clientUpdateStatHistCounters(logType,
                                  tvSubMsec(start_time, current_time));
@@ -1976,7 +1976,7 @@ setLogUri(ClientHttpRequest * http, char const *uri, bool cleanUrl)
             while (*t) {
                 if (!xisspace(*t))
                     *q++ = *t;
-                t++;
+                ++t;
             }
             *q = '\0';
             http->log_uri = xstrndup(rfc1738_escape_unescaped(tmp_uri), MAX_URL);
@@ -3224,7 +3224,7 @@ httpAccept(const CommAcceptCbParams &params)
         commSetTcpKeepalive(params.conn->fd, s->tcp_keepalive.idle, s->tcp_keepalive.interval, s->tcp_keepalive.timeout);
     }
 
-    incoming_sockets_accepted++;
+    ++ incoming_sockets_accepted;
 
     // Socket is ready, setup the connection manager to start using it
     ConnStateData *connState = connStateCreate(params.conn, s);
@@ -3251,7 +3251,7 @@ httpAccept(const CommAcceptCbParams &params)
         ch.src_addr = params.conn->remote;
         ch.my_addr = params.conn->local;
 
-        for (unsigned int pool = 0; pool < pools.size(); pool++) {
+        for (unsigned int pool = 0; pool < pools.size(); ++pool) {
 
             /* pools require explicit 'allow' to assign a client into them */
             if (pools[pool].access) {
@@ -3450,7 +3450,7 @@ httpsAccept(const CommAcceptCbParams &params)
         commSetTcpKeepalive(params.conn->fd, s->tcp_keepalive.idle, s->tcp_keepalive.interval, s->tcp_keepalive.timeout);
     }
 
-    incoming_sockets_accepted++;
+    ++incoming_sockets_accepted;
 
     // Socket is ready, setup the connection manager to start using it
     ConnStateData *connState = connStateCreate(params.conn, s);
@@ -3621,7 +3621,7 @@ static bool
 AddOpenedHttpSocket(const Comm::ConnectionPointer &conn)
 {
     bool found = false;
-    for (int i = 0; i < NHttpSockets && !found; i++) {
+    for (int i = 0; i < NHttpSockets && !found; ++i) {
         if ((found = HttpSockets[i] < 0))
             HttpSockets[i] = conn->fd;
     }
@@ -3772,7 +3772,7 @@ clientHttpConnectionsClose(void)
 #endif
 
     // TODO see if we can drop HttpSockets array entirely */
-    for (int i = 0; i < NHttpSockets; i++) {
+    for (int i = 0; i < NHttpSockets; ++i) {
         HttpSockets[i] = -1;
     }
 
@@ -123,7 +123,7 @@ commHandleRead(int fd, void *data)
     assert(data == COMMIO_FD_READCB(fd));
     assert(ccb->active());
     /* Attempt a read */
-    statCounter.syscalls.sock.reads++;
+    ++ statCounter.syscalls.sock.reads;
     errno = 0;
     int retval;
     retval = FD_READ_METHOD(fd, ccb->buf, ccb->size);
@@ -316,7 +316,7 @@ comm_read_cancel(int fd, AsyncCall::Pointer &callback)
 int
 comm_udp_recvfrom(int fd, void *buf, size_t len, int flags, Ip::Address &from)
 {
-    statCounter.syscalls.sock.recvfroms++;
+    ++ statCounter.syscalls.sock.recvfroms;
     int x = 0;
     struct addrinfo *AI = NULL;
 
@@ -407,7 +407,7 @@ comm_local_port(int fd)
 static comm_err_t
 commBind(int s, struct addrinfo &inaddr)
 {
-    statCounter.syscalls.sock.binds++;
+    ++ statCounter.syscalls.sock.binds;
 
     if (bind(s, inaddr.ai_addr, inaddr.ai_addrlen) == 0) {
         debugs(50, 6, "commBind: bind socket FD " << s << " to " << fd_table[s].local_addr);
@@ -519,7 +519,7 @@ comm_openex(int sock_type,
 
     PROF_start(comm_open);
     /* Create socket for accepting new connections. */
-    statCounter.syscalls.sock.sockets++;
+    ++ statCounter.syscalls.sock.sockets;
 
     /* Setup the socket addrinfo details for use */
     addr.GetAddrInfo(AI);
@@ -820,7 +820,7 @@ comm_connect_addr(int sock, const Ip::Address &address)
 
     if (!F->flags.called_connect) {
         F->flags.called_connect = 1;
-        statCounter.syscalls.sock.connects++;
+        ++ statCounter.syscalls.sock.connects;
 
         x = connect(sock, AI->ai_addr, AI->ai_addrlen);
 
@@ -1055,7 +1055,7 @@ comm_close_complete(const FdeCbParams &params)
     fd_close(params.fd);		/* update fdstat */
     close(params.fd);
 
-    statCounter.syscalls.sock.closes++;
+    ++ statCounter.syscalls.sock.closes;
 
     /* When one connection closes, give accept() a chance, if need be */
     Comm::AcceptLimiter::Instance().kick();
@@ -1167,7 +1167,7 @@ comm_udp_sendto(int fd,
     struct addrinfo *AI = NULL;
 
     PROF_start(comm_udp_sendto);
-    statCounter.syscalls.sock.sendtos++;
+    ++ statCounter.syscalls.sock.sendtos;
 
     debugs(50, 3, "comm_udp_sendto: Attempt to send UDP packet to " << to_addr <<
            " using FD " << fd << " using Port " << comm_local_port(fd) );
@@ -1739,7 +1739,7 @@ commCloseAllSockets(void)
     int fd;
     fde *F = NULL;
 
-    for (fd = 0; fd <= Biggest_FD; fd++) {
+    for (fd = 0; fd <= Biggest_FD; ++fd) {
         F = &fd_table[fd];
 
         if (!F->flags.open)
@@ -1797,7 +1797,7 @@ checkTimeouts(void)
     fde *F = NULL;
     AsyncCall::Pointer callback;
 
-    for (fd = 0; fd <= Biggest_FD; fd++) {
+    for (fd = 0; fd <= Biggest_FD; ++fd) {
         F = &fd_table[fd];
 
         if (writeTimedOut(fd)) {
@@ -2100,7 +2100,7 @@ comm_open_uds(int sock_type,
 
     PROF_start(comm_open);
     /* Create socket for accepting new connections. */
-    statCounter.syscalls.sock.sockets++;
+    ++ statCounter.syscalls.sock.sockets;
 
     /* Setup the socket addrinfo details for use */
     struct addrinfo AI;
@@ -225,7 +225,7 @@ debugArg(const char *arg)
         return;
     }
 
-    for (i = 0; i < MAX_DEBUG_SECTIONS; i++)
+    for (i = 0; i < MAX_DEBUG_SECTIONS; ++i)
         Debug::Levels[i] = l;
 }
 
@@ -395,7 +395,7 @@ _db_set_syslog(const char *facility)
 
         struct syslog_facility_name *n;
 
-        for (n = syslog_facility_names; n->name; n++) {
+        for (n = syslog_facility_names; n->name; ++n) {
             if (strcmp(n->name, facility) == 0) {
                 syslog_facility = n->facility;
                 return;
@@ -427,7 +427,7 @@ Debug::parseOptions(char const *options)
         return;
     }
 
-    for (i = 0; i < MAX_DEBUG_SECTIONS; i++)
+    for (i = 0; i < MAX_DEBUG_SECTIONS; ++i)
         Debug::Levels[i] = 0;
 
     if (options) {
@@ -664,7 +664,7 @@ static const char *ctx_get_descr(Ctx ctx);
 Ctx
 ctx_enter(const char *descr)
 {
-    Ctx_Current_Level++;
+    ++Ctx_Current_Level;
 
     if (Ctx_Current_Level <= CTX_MAX_LEVEL)
         Ctx_Descrs[Ctx_Current_Level] = descr;
@@ -695,7 +695,7 @@ static void
 ctx_print(void)
 {
     /* lock so _db_print will not call us recursively */
-    Ctx_Lock++;
+    ++Ctx_Lock;
     /* ok, user saw [0,Ctx_Reported_Level] descriptions */
     /* first inform about entries popped since user saw them */
 
@@ -711,8 +711,8 @@ ctx_print(void)
 
     /* report new contexts that were pushed since last report */
     while (Ctx_Reported_Level < Ctx_Current_Level) {
-        Ctx_Reported_Level++;
-        Ctx_Valid_Level++;
+        ++Ctx_Reported_Level;
+        ++Ctx_Valid_Level;
         _db_print("ctx: enter level %2d: '%s'\n", Ctx_Reported_Level,
                   ctx_get_descr(Ctx_Reported_Level));
     }
@@ -743,7 +743,7 @@ VectorPool::stats(StoreEntry * sentry)
 
     storeAppendPrintf(sentry, "\t\tCurrent:");
 
-    for (unsigned int i = 0; i < buckets.size(); i++) {
+    for (unsigned int i = 0; i < buckets.size(); ++i) {
         storeAppendPrintf(sentry, " %d:", buckets.key_map[i]);
         buckets.values[i].stats(sentry);
     }
@@ -79,7 +79,7 @@ file_open(const char *path, int mode)
 
     fd = open(path, mode, 0644);
 
-    statCounter.syscalls.disk.opens++;
+    ++ statCounter.syscalls.disk.opens;
 
     if (fd < 0) {
         debugs(50, 3, "file_open: error opening file " << path << ": " << xstrerror());
@@ -145,7 +145,7 @@ file_close(int fd)
 
     fd_close(fd);
 
-    statCounter.syscalls.disk.closes++;
+    ++ statCounter.syscalls.disk.closes;
 
     PROF_stop(file_close);
 }
@@ -247,7 +247,7 @@ diskHandleWrite(int fd, void *notused)
 
     debugs(6, 3, "diskHandleWrite: FD " << fd << " len = " << len);
 
-    statCounter.syscalls.disk.writes++;
+    ++ statCounter.syscalls.disk.writes;
 
     fd_bytes(fd, len, FD_WRITE);
 
@@ -443,7 +443,7 @@ diskHandleRead(int fd, void *data)
 #endif
         debugs(6, 3, "diskHandleRead: FD " << fd << " seeking to offset " << ctrl_dat->offset);
         lseek(fd, ctrl_dat->offset, SEEK_SET);	/* XXX ignore return? */
-        ++statCounter.syscalls.disk.seeks;
+        ++ statCounter.syscalls.disk.seeks;
         F->disk.offset = ctrl_dat->offset;
     }
 
@@ -453,7 +453,7 @@ diskHandleRead(int fd, void *data)
     if (len > 0)
         F->disk.offset += len;
 
-    statCounter.syscalls.disk.reads++;
+    ++ statCounter.syscalls.disk.reads;
 
     fd_bytes(fd, len, FD_READ);
 
@@ -507,7 +507,7 @@ file_read(int fd, char *buf, int req_len, off_t offset, DRCB * handler, void *cl
 void
 safeunlink(const char *s, int quiet)
 {
-    statCounter.syscalls.disk.unlinks++;
+    ++ statCounter.syscalls.disk.unlinks;
 
     if (unlink(s) < 0 && !quiet)
         debugs(50, 1, "safeunlink: Couldn't delete " << s << ": " << xstrerror());
@@ -299,7 +299,7 @@ idnsAddNameserver(const char *buf)
     // TODO generate a test packet to probe this NS from EDNS size and ability.
 #endif
     debugs(78, 3, "idnsAddNameserver: Added nameserver #" << nns << " (" << A << ")");
-    nns++;
+    ++nns;
 }
 
 static void
@@ -327,7 +327,7 @@ idnsAddPathComponent(const char *buf)
     strcpy(searchpath[npc].domain, buf);
     Tolower(searchpath[npc].domain);
     debugs(78, 3, "idnsAddPathComponent: Added domain #" << npc << ": " << searchpath[npc].domain);
-    npc++;
+    ++npc;
 }
 
 
@@ -559,7 +559,7 @@ idnsParseWIN32Registry(void)
 
             if (RegQueryInfoKey(hndKey, NULL, NULL, NULL, &InterfacesCount, &MaxSubkeyLen, NULL, NULL, NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {
                 keyname = (char *) xmalloc(++MaxSubkeyLen);
-                for (i = 0; i < (int) InterfacesCount; i++) {
+                for (i = 0; i < (int) InterfacesCount; ++i) {
                     DWORD j;
                     j = MaxSubkeyLen;
                     if (RegEnumKeyEx(hndKey, i, keyname, &j, NULL, NULL, NULL, &ftLastWriteTime) == ERROR_SUCCESS) {
@@ -686,7 +686,7 @@ idnsStats(StoreEntry * sentry)
     storeAppendPrintf(sentry, "IP ADDRESS                                     # QUERIES # REPLIES\n");
     storeAppendPrintf(sentry, "---------------------------------------------- --------- ---------\n");
 
-    for (i = 0; i < nns; i++) {
+    for (i = 0; i < nns; ++i) {
         storeAppendPrintf(sentry, "%-45s %9d %9d\n",  /* Let's take the maximum: (15 IPv4/45 IPv6) */
                           nameservers[i].S.NtoA(buf,MAX_IPSTRLEN),
                           nameservers[i].nqueries,
@@ -696,18 +696,18 @@ idnsStats(StoreEntry * sentry)
     storeAppendPrintf(sentry, "\nRcode Matrix:\n");
     storeAppendPrintf(sentry, "RCODE");
 
-    for (i = 0; i < MAX_ATTEMPT; i++)
+    for (i = 0; i < MAX_ATTEMPT; ++i)
         storeAppendPrintf(sentry, " ATTEMPT%d", i + 1);
 
     storeAppendPrintf(sentry, " PROBLEM\n");
 
-    for (j = 0; j < MAX_RCODE; j++) {
+    for (j = 0; j < MAX_RCODE; ++j) {
         if (j > 10 && j < 16)
             continue; // unassigned by IANA.
 
         storeAppendPrintf(sentry, "%5d", j);
 
-        for (i = 0; i < MAX_ATTEMPT; i++)
+        for (i = 0; i < MAX_ATTEMPT; ++i)
             storeAppendPrintf(sentry, " %8d", RcodeMatrix[j][i]);
 
         storeAppendPrintf(sentry, " : %s\n",Rcodes[j]);
@@ -716,7 +716,7 @@ idnsStats(StoreEntry * sentry)
     if (npc) {
         storeAppendPrintf(sentry, "\nSearch list:\n");
 
-        for (i=0; i < npc; i++)
+        for (i=0; i < npc; ++i)
             storeAppendPrintf(sentry, "%s\n", searchpath[i].domain);
 
         storeAppendPrintf(sentry, "\n");
@@ -920,7 +920,7 @@ idnsSendQuery(idns_query * q)
                 x = comm_udp_sendto(DnsSocketA, nameservers[ns].S, q->buf, q->sz);
         }
 
-        q->nsends++;
+        ++ q->nsends;
 
         q->sent_t = current_time;
 
@@ -938,7 +938,7 @@ idnsSendQuery(idns_query * q)
         fd_bytes(DnsSocketA, x, FD_WRITE);
     }
 
-    nameservers[ns].nqueries++;
+    ++ nameservers[ns].nqueries;
     q->queue_t = current_time;
     dlinkAdd(q, &q->lru, &lru_list);
     q->pending = 1;
@@ -950,7 +950,7 @@ idnsFromKnownNameserver(Ip::Address const &from)
 {
     int i;
 
-    for (i = 0; i < nns; i++) {
+    for (i = 0; i < nns; ++i) {
         if (nameservers[i].S != from)
             continue;
 
@@ -986,7 +986,7 @@ idnsQueryID(void)
     unsigned short first_id = id;
 
     while (idnsFindQuery(id)) {
-        id++;
+        ++id;
 
         if (id == first_id) {
             debugs(78, 1, "idnsQueryID: Warning, too many pending DNS requests");
@@ -1129,7 +1129,7 @@ idnsGrokReply(const char *buf, size_t sz, int from_ns)
             // the altered NS was limiting the whole group.
             max_shared_edns = q->edns_seen;
             // may be limited by one of the others still
-            for (int i = 0; i < nns; i++)
+            for (int i = 0; i < nns; ++i)
                 max_shared_edns = min(max_shared_edns, nameservers[i].last_seen_edns);
         } else {
             nameservers[from_ns].last_seen_edns = q->edns_seen;
@@ -1168,7 +1168,7 @@ idnsGrokReply(const char *buf, size_t sz, int from_ns)
         q->rcode = -n;
         debugs(78, 3, "idnsGrokReply: error " << rfc1035ErrorMessage(n) << " (" << q->rcode << ")");
 
-        if (q->rcode == 2 && ++q->attempt < MAX_ATTEMPT) {
+        if (q->rcode == 2 && (++ q->attempt) < MAX_ATTEMPT) {
             /*
              * RCODE 2 is "Server failure - The name server was
              * unable to process this query due to a problem with
@@ -1193,9 +1193,9 @@ idnsGrokReply(const char *buf, size_t sz, int from_ns)
                 strcat(q->name, ".");
                 strcat(q->name, searchpath[q->domain].domain);
                 debugs(78, 3, "idnsGrokReply: searchpath used for " << q->name);
-                q->domain++;
+                ++ q->domain;
             } else {
-                q->attempt++;
+                ++ q->attempt;
             }
 
             rfc1035MessageDestroy(&message);
@@ -1299,7 +1299,7 @@ idnsRead(int fd, void *data)
         ns = idnsFromKnownNameserver(from);
 
         if (ns >= 0) {
-            nameservers[ns].nreplies++;
+            ++ nameservers[ns].nreplies;
         }
 
         // Before unknown_nameservers check to avoid flooding cache.log on attacks,
@@ -1458,7 +1458,7 @@ idnsRcodeCount(int rcode, int attempt)
 
     if (rcode < MAX_RCODE)
         if (attempt < MAX_ATTEMPT)
-            RcodeMatrix[rcode][attempt]++;
+            ++ RcodeMatrix[rcode][attempt];
 }
 
 /* ====================================================================== */
@@ -1553,7 +1553,7 @@ dnsInit(void)
         memDataInit(MEM_IDNS_QUERY, "idns_query", sizeof(idns_query), 0);
         memset(RcodeMatrix, '\0', sizeof(RcodeMatrix));
         idns_lookup_hash = hash_create((HASHCMP *) strcmp, 103, hash_string);
-        init++;
+        ++init;
     }
 
 #if WHEN_EDNS_RESPONSES_ARE_PARSED
@@ -1582,7 +1582,7 @@ dnsShutdown(void)
         DnsSocketB = -1;
     }
 
-    for (int i = 0; i < nns; i++) {
+    for (int i = 0; i < nns; ++i) {
         if (nsvc *vc = nameservers[i].vc) {
             if (Comm::IsConnOpen(vc->conn))
                 vc->conn->close();
@@ -1670,9 +1670,9 @@ idnsALookup(const char *name, IDNSCB * callback, void *data)
     q->xact_id.change();
     q->query_id = idnsQueryID();
 
-    for (i = 0; i < strlen(name); i++)
+    for (i = 0; i < strlen(name); ++i)
         if (name[i] == '.')
-            nd++;
+            ++nd;
 
     if (Config.onoff.res_defnames && npc > 0 && name[strlen(name)-1] != '.') {
         q->do_searchpath = 1;
@@ -1771,7 +1771,7 @@ snmp_netDnsFn(variable_list * Var, snint * ErrP)
 
     case DNS_REQ:
 
-        for (i = 0; i < nns; i++)
+        for (i = 0; i < nns; ++i)
             n += nameservers[i].nqueries;
 
         Answer = snmp_var_new_integer(Var->name, Var->name_length,
@@ -1781,7 +1781,7 @@ snmp_netDnsFn(variable_list * Var, snint * ErrP)
         break;
 
     case DNS_REP:
-        for (i = 0; i < nns; i++)
+        for (i = 0; i < nns; ++i)
             n += nameservers[i].nreplies;
 
         Answer = snmp_var_new_integer(Var->name, Var->name_length,
@@ -265,7 +265,7 @@ lookup(const char *buf)
                     continue;
                 }
                 printf(" %s", ntoabuf);
-                i++;
+                ++i;
                 aiptr = aiptr->ai_next;
             }
 
@@ -428,7 +428,7 @@ squid_res_setservers(int reset)
         if (_SQUID_RES_NSADDR_COUNT == MAXNS) {
             fprintf(stderr, "Too many -s options, only %d are allowed\n", MAXNS);
         } else {
-            _SQUID_RES_NSADDR_COUNT++;
+            ++ _SQUID_RES_NSADDR_COUNT;
             memcpy(&_SQUID_RES_NSADDR6_LIST(_SQUID_RES_NSADDR6_COUNT++), &((struct sockaddr_in6*)AI->ai_addr)->sin6_addr, sizeof(struct in6_addr));
         }
 #else
@@ -236,7 +236,7 @@ errorClean(void)
     if (error_text) {
         int i;
 
-        for (i = ERR_NONE + 1; i < error_page_count; i++)
+        for (i = ERR_NONE + 1; i < error_page_count; ++i)
             safe_free(error_text[i]);
 
         safe_free(error_text);
@@ -258,7 +258,7 @@ errorFindHardText(err_type type)
 {
     int i;
 
-    for (i = 0; i < error_hard_text_count; i++)
+    for (i = 0; i < error_hard_text_count; ++i)
         if (error_hard_text[i].type == type)
             return error_hard_text[i].text;
 
@@ -378,11 +378,14 @@ bool strHdrAcptLangGetItem(const String &hdr, char *lang, int langLen, size_t &p
 
         if (!pos) {
             /* skip any initial whitespace. */
-            while (pos < hdr.size() && xisspace(hdr[pos])) pos++;
+            while (pos < hdr.size() && xisspace(hdr[pos]))
+                ++pos;
         } else {
             // IFF we terminated the tag on whitespace or ';' we need to skip to the next ',' or end of header.
-            while (pos < hdr.size() && hdr[pos] != ',') pos++;
-            if (hdr[pos] == ',') pos++;
+            while (pos < hdr.size() && hdr[pos] != ',')
+                ++pos;
+            if (hdr[pos] == ',')
+                ++pos;
         }
 
         /*
@@ -407,9 +410,9 @@ bool strHdrAcptLangGetItem(const String &hdr, char *lang, int langLen, size_t &p
                 if (*dt != '-' && *dt != '*' && (*dt < 'a' || *dt > 'z') )
                     invalid_byte = true;
                 else
-                    dt++; // move to next destination byte.
+                    ++dt; // move to next destination byte.
             }
-            pos++;
+            ++pos;
         }
         *dt++ = '\0'; // nul-terminated the filename content string before system use.
 
@@ -519,12 +522,12 @@ errorDynamicPageInfoDestroy(ErrorDynamicPageInfo * info)
 static int
 errorPageId(const char *page_name)
 {
-    for (int i = 0; i < ERR_MAX; i++) {
+    for (int i = 0; i < ERR_MAX; ++i) {
         if (strcmp(err_type_str[i], page_name) == 0)
             return i;
     }
 
-    for (size_t j = 0; j < ErrorDynamicPages.size(); j++) {
+    for (size_t j = 0; j < ErrorDynamicPages.size(); ++j) {
         if (strcmp(ErrorDynamicPages.items[j]->page_name, page_name) == 0)
             return j + ERR_MAX;
     }
@@ -659,7 +659,7 @@ external_acl::add(ExternalACLEntry *anEntry)
     anEntry->def = this;
     hash_join(cache, anEntry);
     dlinkAdd(anEntry, &anEntry->lru, &lru_list);
-    cache_entries++;
+    ++cache_entries;
 }
 
 void
@@ -267,7 +267,7 @@ fd_open(int fd, unsigned int type, const char *desc)
     if (desc)
         xstrncpy(F->desc, desc, FD_DESC_SZ);
 
-    Number_FD++;
+    ++Number_FD;
 }
 
 void
@@ -299,7 +299,7 @@ fdDumpOpen(void)
     int i;
     fde *F;
 
-    for (i = 0; i < Squid_MaxFD; i++) {
+    for (i = 0; i < Squid_MaxFD; ++i) {
         F = &fd_table[i];
 
         if (!F->flags.open)
@@ -99,7 +99,7 @@ fde::DumpStats (StoreEntry *dumpEntry)
     storeAppendPrintf(dumpEntry, "---- ------ ---- -------- -------- --------------------- ------------------------------\n");
 #endif
 
-    for (i = 0; i < Squid_MaxFD; i++) {
+    for (i = 0; i < Squid_MaxFD; ++i) {
         fd_table[i].dumpStats(*dumpEntry, i);
     }
 }
@@ -123,6 +123,6 @@ fde::remoteAddr() const
 void
 fde::noteUse(PconnPool *pool)
 {
-    pconn.uses++;
+    ++ pconn.uses;
     pconn.pool = pool;
 }
@@ -90,7 +90,7 @@ FileMap::setBit(sfileno file_number)
 
     bitmap[file_number >> LONG_BIT_SHIFT] |= bitmask;
 
-    usedSlots_++;
+    ++usedSlots_;
 
     return file_number;
 }
@@ -135,14 +135,14 @@ FileMap::allocate(sfileno suggestion)
 
     word = suggestion >> LONG_BIT_SHIFT;
 
-    for (unsigned int count = 0; count < nwords; count++) {
+    for (unsigned int count = 0; count < nwords; ++count) {
         if (bitmap[word] != ALL_ONES)
             break;
 
         word = (word + 1) % nwords;
     }
 
-    for (unsigned char bit = 0; bit < BITS_IN_A_LONG; bit++) {
+    for (unsigned char bit = 0; bit < BITS_IN_A_LONG; ++bit) {
         suggestion = ((unsigned long) word << LONG_BIT_SHIFT) | bit;
 
         if (!testBit(suggestion)) {
@@ -854,7 +854,7 @@ FwdState::connectStart()
             if (!serverConn->getPeer())
                 serverConn->peerType = HIER_DIRECT;
 #endif
-            n_tries++;
+            ++n_tries;
             request->flags.pinned = 1;
             if (pinned_connection->pinnedAuth())
                 request->flags.auth = 1;
@@ -892,10 +892,10 @@ FwdState::connectStart()
     if (openedPconn) {
         serverConn = temp;
         debugs(17, 3, HERE << "reusing pconn " << serverConnection());
-        n_tries++;
+        ++n_tries;
 
         if (!serverConnection()->getPeer())
-            origin_tries++;
+            ++origin_tries;
 
         comm_add_close_handler(serverConnection()->fd, fwdServerClosedWrapper, this);
 
@@ -992,7 +992,7 @@ FwdState::dispatch()
 #endif
 
     if (serverConnection()->getPeer() != NULL) {
-        serverConnection()->getPeer()->stats.fetches++;
+        ++ serverConnection()->getPeer()->stats.fetches;
         request->peer_login = serverConnection()->getPeer()->login;
         request->peer_domain = serverConnection()->getPeer()->domain;
         httpStart(this);
@@ -1121,19 +1121,19 @@ fwdStats(StoreEntry * s)
     int j;
     storeAppendPrintf(s, "Status");
 
-    for (j = 0; j <= MAX_FWD_STATS_IDX; j++) {
-        storeAppendPrintf(s, "\ttry#%d", j + 1);
+    for (j = 1; j < MAX_FWD_STATS_IDX; ++j) {
+        storeAppendPrintf(s, "\ttry#%d", j);
     }
 
     storeAppendPrintf(s, "\n");
 
-    for (i = 0; i <= (int) HTTP_INVALID_HEADER; i++) {
+    for (i = 0; i <= (int) HTTP_INVALID_HEADER; ++i) {
         if (FwdReplyCodes[0][i] == 0)
             continue;
 
         storeAppendPrintf(s, "%3d", i);
 
-        for (j = 0; j <= MAX_FWD_STATS_IDX; j++) {
+        for (j = 0; j <= MAX_FWD_STATS_IDX; ++j) {
             storeAppendPrintf(s, "\t%d", FwdReplyCodes[j][i]);
         }
 
@@ -1209,7 +1209,7 @@ FwdState::logReplyStatus(int tries, http_status status)
     if (tries > MAX_FWD_STATS_IDX)
         tries = MAX_FWD_STATS_IDX;
 
-    FwdReplyCodes[tries][status]++;
+    ++ FwdReplyCodes[tries][status];
 }
 
 /**** PRIVATE NON-MEMBER FUNCTIONS ********************************************/
@@ -175,7 +175,7 @@ fqdncacheRelease(fqdncache_entry * f)
     int k;
     hash_remove_link(fqdn_table, (hash_link *) f);
 
-    for (k = 0; k < (int) f->name_count; k++)
+    for (k = 0; k < (int) f->name_count; ++k)
         safe_free(f->names[k]);
 
     debugs(35, 5, "fqdncacheRelease: Released FQDN record for '" << hashKeyStr(&f->hash) << "'.");
@@ -247,7 +247,7 @@ fqdncache_purgelru(void *notused)
 
         fqdncacheRelease(f);
 
-        removed++;
+        ++removed;
     }
 
     debugs(35, 9, "fqdncache_purgelru: removed " << removed << " entries");
@@ -440,7 +440,7 @@ fqdncacheParse(fqdncache_entry *f, const rfc1035_rr * answers, int nr, const cha
     debugs(35, 3, "fqdncacheParse: " << nr << " answers for '" << name << "'");
     assert(answers);
 
-    for (k = 0; k < nr; k++) {
+    for (k = 0; k < nr; ++k) {
         if (answers[k]._class != RFC1035_CLASS_IN)
             continue;
 
@@ -535,7 +535,7 @@ fqdncache_nbgethostbyaddr(const Ip::Address &addr, FQDNH * handler, void *handle
     generic_cbdata *c;
     addr.NtoA(name,MAX_IPSTRLEN);
     debugs(35, 4, "fqdncache_nbgethostbyaddr: Name '" << name << "'.");
-    FqdncacheStats.requests++;
+    ++FqdncacheStats.requests;
 
     if (name[0] == '\0') {
         debugs(35, 4, "fqdncache_nbgethostbyaddr: Invalid name!");
@@ -559,9 +559,9 @@ fqdncache_nbgethostbyaddr(const Ip::Address &addr, FQDNH * handler, void *handle
         debugs(35, 4, "fqdncache_nbgethostbyaddr: HIT for '" << name << "'");
 
         if (f->flags.negcached)
-            FqdncacheStats.negative_hits++;
+            ++ FqdncacheStats.negative_hits;
         else
-            FqdncacheStats.hits++;
+            ++ FqdncacheStats.hits;
 
         f->handler = handler;
 
@@ -573,7 +573,7 @@ fqdncache_nbgethostbyaddr(const Ip::Address &addr, FQDNH * handler, void *handle
     }
 
     debugs(35, 5, "fqdncache_nbgethostbyaddr: MISS for '" << name << "'");
-    FqdncacheStats.misses++;
+    ++ FqdncacheStats.misses;
     f = fqdncacheCreateEntry(name);
     f->handler = handler;
     f->handlerData = cbdataReference(handlerData);
@@ -654,7 +654,7 @@ fqdncache_gethostbyaddr(const Ip::Address &addr, int flags)
     }
 
     addr.NtoA(name,MAX_IPSTRLEN);
-    FqdncacheStats.requests++;
+    ++ FqdncacheStats.requests;
     f = fqdncache_get(name);
 
     if (NULL == f) {
@@ -663,19 +663,19 @@ fqdncache_gethostbyaddr(const Ip::Address &addr, int flags)
         fqdncacheRelease(f);
         f = NULL;
     } else if (f->flags.negcached) {
-        FqdncacheStats.negative_hits++;
+        ++ FqdncacheStats.negative_hits;
         // ignore f->error_message: the caller just checks FQDN cache presence
         return NULL;
     } else {
-        FqdncacheStats.hits++;
+        ++ FqdncacheStats.hits;
         f->lastref = squid_curtime;
         // ignore f->error_message: the caller just checks FQDN cache presence
         return f->names[0];
     }
 
     /* no entry [any more] */
 
-    FqdncacheStats.misses++;
+    ++ FqdncacheStats.misses;
 
     if (flags & FQDN_LOOKUP_IF_MISS) {
         fqdncache_nbgethostbyaddr(addr, NULL, NULL);
@@ -736,7 +736,7 @@ fqdnStats(StoreEntry * sentry)
                           ttl,
                           (int) f->name_count);
 
-        for (k = 0; k < (int) f->name_count; k++)
+        for (k = 0; k < (int) f->name_count; ++k)
             storeAppendPrintf(sentry, " %s", f->names[k]);
 
         storeAppendPrintf(sentry, "\n");
@@ -788,7 +788,7 @@ fqdncacheFreeEntry(void *data)
     fqdncache_entry *f = (fqdncache_entry *)data;
     int k;
 
-    for (k = 0; k < (int) f->name_count; k++)
+    for (k = 0; k < (int) f->name_count; ++k)
         safe_free(f->names[k]);
 
     safe_free(f->hash.key);
@@ -857,7 +857,7 @@ fqdncacheAddEntryFromHosts(char *addr, wordlist * hostnames)
     while (hostnames) {
         fce->names[j] = xstrdup(hostnames->key);
         Tolower(fce->names[j]);
-        j++;
+        ++j;
         hostnames = hostnames->next;
 
         if (j >= FQDN_MAX_NAMES)
@@ -485,8 +485,8 @@ FtpStateData::FtpStateData(FwdState *theFwdState, const Comm::ConnectionPointer
 {
     const char *url = entry->url();
     debugs(9, 3, HERE << "'" << url << "'" );
-    statCounter.server.all.requests++;
-    statCounter.server.ftp.requests++;
+    ++ statCounter.server.all.requests;
+    ++ statCounter.server.ftp.requests;
     theSize = -1;
     mdtm = -1;
 
@@ -711,7 +711,7 @@ is_month(const char *buf)
 {
     int i;
 
-    for (i = 0; i < 12; i++)
+    for (i = 0; i < 12; ++i)
         if (!strcasecmp(buf, Month[i]))
             return 1;
 
@@ -785,7 +785,7 @@ ftpListParseParts(const char *buf, struct _ftp_flags flags)
     xfree(xbuf);
 
     /* locate the Month field */
-    for (i = 3; i < n_tokens - 2; i++) {
+    for (i = 3; i < n_tokens - 2; ++i) {
         char *size = tokens[i - 1];
         char *month = tokens[i];
         char *day = tokens[i + 1];
@@ -821,7 +821,7 @@ ftpListParseParts(const char *buf, struct _ftp_flags flags)
                 copyFrom += strlen(tbuf);
 
                 while (strchr(w_space, *copyFrom))
-                    copyFrom++;
+                    ++copyFrom;
             } else {
                 /* XXX assumes a single space between date and filename
                  * suggested by:  Nathan.Bailey@cc.monash.edu.au and
@@ -862,7 +862,7 @@ ftpListParseParts(const char *buf, struct _ftp_flags flags)
             ct += strlen(tokens[2]);
 
             while (xisspace(*ct))
-                ct++;
+                ++ct;
 
             if (!*ct)
                 ct = NULL;
@@ -936,7 +936,7 @@ ftpListParseParts(const char *buf, struct _ftp_flags flags)
             ct = strstr(ct, ",");
 
             if (ct) {
-                ct++;
+                ++ct;
             }
         }
 
@@ -952,7 +952,7 @@ ftpListParseParts(const char *buf, struct _ftp_flags flags)
 
 found:
 
-    for (i = 0; i < n_tokens; i++)
+    for (i = 0; i < n_tokens; ++i)
         xfree(tokens[i]);
 
     if (!p->name)
@@ -998,7 +998,7 @@ FtpStateData::htmlifyListEntry(const char *line)
         html->init();
         html->Printf("<tr class=\"entry\"><td colspan=\"5\">%s</td></tr>\n", line);
 
-        for (p = line; *p && xisspace(*p); p++);
+        for (p = line; *p && xisspace(*p); ++p);
         if (*p && !xisspace(*p))
             flags.listformat_unknown = 1;
 
@@ -1145,7 +1145,7 @@ FtpStateData::parseListing()
     debugs(9, 3, HERE << (unsigned long int)len << " bytes to play with");
 
     line = (char *)memAllocate(MEM_4K_BUF);
-    end++;
+    ++end;
     s = sbuf;
     s += strspn(s, crlf);
 
@@ -1279,12 +1279,12 @@ FtpStateData::dataRead(const CommIoCbParams &io)
         DelayId delayId = entry->mem_obj->mostBytesAllowed();
         delayId.bytesIn(io.size);
 #endif
-        IOStats.Ftp.reads++;
+        ++ IOStats.Ftp.reads;
 
-        for (j = io.size - 1, bin = 0; j; bin++)
+        for (j = io.size - 1, bin = 0; j; ++bin)
             j >>= 1;
 
-        IOStats.Ftp.read_hist[bin]++;
+        ++ IOStats.Ftp.read_hist[bin];
     }
 
     if (io.flag != COMM_OK) {
@@ -1557,13 +1557,13 @@ escapeIAC(const char *buf)
     unsigned const char *p;
     unsigned char *r;
 
-    for (p = (unsigned const char *)buf, n = 1; *p; n++, p++)
+    for (p = (unsigned const char *)buf, n = 1; *p; ++n, ++p)
         if (*p == 255)
-            n++;
+            ++n;
 
     ret = (char *)xmalloc(n);
 
-    for (p = (unsigned const char *)buf, r=(unsigned char *)ret; *p; p++) {
+    for (p = (unsigned const char *)buf, r=(unsigned char *)ret; *p; ++p) {
         *r++ = *p;
 
         if (*p == 255)
@@ -1665,7 +1665,7 @@ FtpStateData::ftpParseControlReply(char *buf, size_t len, int *codep, size_t *us
     }
 
     debugs(9, 3, HERE << len << " bytes to play with");
-    end++;
+    ++end;
     s = sbuf;
     s += strspn(s, crlf);
 
@@ -1865,7 +1865,7 @@ ftpReadWelcome(FtpStateData * ftpState)
     debugs(9, 3, HERE);
 
     if (ftpState->flags.pasv_only)
-        ftpState->login_att++;
+        ++ ftpState->login_att;
 
     if (code == 220) {
         if (ftpState->ctrl.message) {
@@ -2099,7 +2099,7 @@ ftpReadType(FtpStateData * ftpState)
         p = path = xstrdup(ftpState->request->urlpath.termedBuf());
 
         if (*p == '/')
-            p++;
+            ++p;
 
         while (*p) {
             d = p;
@@ -2395,8 +2395,10 @@ ftpReadEPSV(FtpStateData* ftpState)
          * which means close data + control without self-destructing and re-open from scratch. */
         debugs(9, 5, HERE << "scanning: " << ftpState->ctrl.last_reply);
         buf = ftpState->ctrl.last_reply;
-        while (buf != NULL && *buf != '\0' && *buf != '\n' && *buf != '(') ++buf;
-        if (buf != NULL && *buf == '\n') ++buf;
+        while (buf != NULL && *buf != '\0' && *buf != '\n' && *buf != '(')
+            ++buf;
+        if (buf != NULL && *buf == '\n')
+            ++buf;
 
         if (buf == NULL || *buf == '\0') {
             /* handle broken server (RFC 2428 says MUST specify supported protocols in 522) */
@@ -274,7 +274,7 @@ gopher_request_parse(const HttpRequest * req, char *type_id, char *request)
         request[0] = '\0';
 
     if (path && (*path == '/'))
-        path++;
+        ++path;
 
     if (!path || !*path) {
         *type_id = GOPHER_DIRECTORY;
@@ -448,7 +448,7 @@ gopherToHTML(GopherStateData * gopherState, char *inbuf, int len)
         int left = len - (pos - inbuf);
         lpos = (char *)memchr(pos, '\n', left);
         if (lpos) {
-            lpos++;             /* Next line is after \n */
+            ++lpos;             /* Next line is after \n */
             llen = lpos - pos;
         } else {
             llen = left;
@@ -779,12 +779,12 @@ gopherReadReply(const Comm::ConnectionPointer &conn, char *buf, size_t len, comm
     if (flag == COMM_OK && len > 0) {
         AsyncCall::Pointer nil;
         commSetConnTimeout(conn, Config.Timeout.read, nil);
-        IOStats.Gopher.reads++;
+        ++IOStats.Gopher.reads;
 
-        for (clen = len - 1, bin = 0; clen; bin++)
+        for (clen = len - 1, bin = 0; clen; ++bin)
             clen >>= 1;
 
-        IOStats.Gopher.read_hist[bin]++;
+        ++IOStats.Gopher.read_hist[bin];
 
         HttpRequest *req = gopherState->fwd->request;
         if (req->hier.bodyBytesRead < 0)
@@ -921,7 +921,7 @@ gopherSendRequest(int fd, void *data)
         const char *t = strchr(gopherState->request, '?');
 
         if (t != NULL)
-            t++;		/* skip the ? */
+            ++t;		/* skip the ? */
         else
             t = "";
 
@@ -966,9 +966,9 @@ gopherStart(FwdState * fwd)
 
     debugs(10, 3, "gopherStart: " << entry->url()  );
 
-    statCounter.server.all.requests++;
+    ++ statCounter.server.all.requests;
 
-    statCounter.server.other.requests++;
+    ++ statCounter.server.other.requests;
 
     /* Parse url. */
     gopher_request_parse(fwd->request,
@@ -191,7 +191,7 @@ helperOpenServers(helper * hlp)
 
     assert(nargs <= HELPER_MAX_ARGS);
 
-    for (k = 0; k < need_new; k++) {
+    for (k = 0; k < need_new; ++k) {
         getCurrentTime();
         rfd = wfd = -1;
         pid = ipcCreate(hlp->ipc_type,
@@ -208,8 +208,8 @@ helperOpenServers(helper * hlp)
             continue;
         }
 
-        hlp->childs.n_running++;
-        hlp->childs.n_active++;
+        ++ hlp->childs.n_running;
+        ++ hlp->childs.n_active;
         CBDATA_INIT_TYPE(helper_server);
         srv = cbdataAlloc(helper_server);
         srv->hIpc = hIpc;
@@ -305,7 +305,7 @@ helperStatefulOpenServers(statefulhelper * hlp)
 
     assert(nargs <= HELPER_MAX_ARGS);
 
-    for (int k = 0; k < need_new; k++) {
+    for (int k = 0; k < need_new; ++k) {
         getCurrentTime();
         int rfd = -1;
         int wfd = -1;
@@ -324,8 +324,8 @@ helperStatefulOpenServers(statefulhelper * hlp)
             continue;
         }
 
-        hlp->childs.n_running++;
-        hlp->childs.n_active++;
+        ++ hlp->childs.n_running;
+        ++ hlp->childs.n_active;
         CBDATA_INIT_TYPE(helper_stateful_server);
         helper_stateful_server *srv = cbdataAlloc(helper_stateful_server);
         srv->hIpc = hIpc;
@@ -456,7 +456,7 @@ helperStatefulReleaseServer(helper_stateful_server * srv)
     if (!srv->flags.reserved)
         return;
 
-    srv->stats.releases++;
+    ++ srv->stats.releases;
 
     srv->flags.reserved = 0;
     if (srv->parent->OnEmptyQueue != NULL && srv->data)
@@ -727,7 +727,7 @@ helperServerFree(helper_server *srv)
         }
     }
 
-    for (i = 0; i < concurrency; i++) {
+    for (i = 0; i < concurrency; ++i) {
         if ((r = srv->requests[i])) {
             void *cbdata;
 
@@ -824,7 +824,7 @@ static void helperReturnBuffer(int request_number, helper_server * srv, helper *
 
         srv->stats.pending--;
 
-        hlp->stats.replies++;
+        ++ hlp->stats.replies;
 
         srv->answer_time = current_time;
 
@@ -905,7 +905,7 @@ helperHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t len, com
             i = strtol(msg, &msg, 10);
 
             while (*msg && xisspace(*msg))
-                msg++;
+                ++msg;
         }
 
         helperReturnBuffer(i, srv, hlp, msg, t);
@@ -999,7 +999,7 @@ helperStatefulHandleRead(const Comm::ConnectionPointer &conn, char *buf, size_t
         srv->roffset = 0;
         helperStatefulRequestFree(r);
         srv->request = NULL;
-        hlp->stats.replies++;
+        ++ hlp->stats.replies;
         srv->answer_time = current_time;
         hlp->stats.avg_svc_time =
             Math::intAverage(hlp->stats.avg_svc_time,
@@ -1045,7 +1045,7 @@ Enqueue(helper * hlp, helper_request * r)
 {
     dlink_node *link = (dlink_node *)memAllocate(MEM_DLINK_NODE);
     dlinkAddTail(r, link, &hlp->queue);
-    hlp->stats.queue_size++;
+    ++ hlp->stats.queue_size;
 
     /* do this first so idle=N has a chance to grow the child pool before it hits critical. */
     if (hlp->childs.needNew() > 0) {
@@ -1078,7 +1078,7 @@ StatefulEnqueue(statefulhelper * hlp, helper_stateful_request * r)
 {
     dlink_node *link = (dlink_node *)memAllocate(MEM_DLINK_NODE);
     dlinkAddTail(r, link, &hlp->queue);
-    hlp->stats.queue_size++;
+    ++ hlp->stats.queue_size;
 
     /* do this first so idle=N has a chance to grow the child pool before it hits critical. */
     if (hlp->childs.needNew() > 0) {
@@ -1258,7 +1258,7 @@ helperDispatch(helper_server * srv, helper_request * r)
         return;
     }
 
-    for (slot = 0; slot < (hlp->childs.concurrency ? hlp->childs.concurrency : 1); slot++) {
+    for (slot = 0; slot < (hlp->childs.concurrency ? hlp->childs.concurrency : 1); ++slot) {
         if (!srv->requests[slot]) {
             ptr = &srv->requests[slot];
             break;
@@ -1290,8 +1290,8 @@ helperDispatch(helper_server * srv, helper_request * r)
 
     debugs(84, 5, "helperDispatch: Request sent to " << hlp->id_name << " #" << srv->index + 1 << ", " << strlen(r->buf) << " bytes");
 
-    srv->stats.uses++;
-    hlp->stats.requests++;
+    ++ srv->stats.uses;
+    ++ hlp->stats.requests;
 }
 
 static void
@@ -1343,8 +1343,8 @@ helperStatefulDispatch(helper_stateful_server * srv, helper_stateful_request * r
            hlp->id_name << " #" << srv->index + 1 << ", " <<
            (int) strlen(r->buf) << " bytes");
 
-    srv->stats.uses++;
-    hlp->stats.requests++;
+    ++ srv->stats.uses;
+    ++ hlp->stats.requests;
 }
 
 
@@ -290,7 +290,7 @@ htcpHexdump(const char *tag, const char *s, int sz)
     debugs(31, 3, "htcpHexdump " << tag);
     memset(hex, '\0', 80);
 
-    for (i = 0; i < sz; i++) {
+    for (i = 0; i < sz; ++i) {
         k = i % 16;
         snprintf(&hex[k * 3], 4, " %02x", (int) *(s + i));
 
@@ -608,7 +608,7 @@ htcpSend(const char *buf, int len, Ip::Address &to)
     if (comm_udp_sendto(htcpOutgoingConn->fd, to, buf, len) < 0)
         debugs(31, 3, HERE << htcpOutgoingConn << " sendto: " << xstrerror());
     else
-        statCounter.htcp.pkts_sent++;
+        ++statCounter.htcp.pkts_sent;
 }
 
 /*
@@ -1057,7 +1057,7 @@ htcpClrStore(const htcpSpecifier * s)
     while ((e = storeGetPublicByRequest(request)) != NULL) {
         if (e != NULL) {
             htcpClrStoreEntry(e);
-            released++;
+            ++released;
         }
     }
 
@@ -1456,7 +1456,7 @@ htcpRecv(int fd, void *data)
     debugs(31, 3, "htcpRecv: FD " << fd << ", " << len << " bytes from " << from );
 
     if (len)
-        statCounter.htcp.pkts_recv++;
+        ++statCounter.htcp.pkts_recv;
 
     htcpHandleMsg(buf, len, from);
 
@@ -599,11 +599,11 @@ HttpStateData::keepaliveAccounting(HttpReply *reply)
 {
     if (flags.keepalive)
         if (_peer)
-            _peer->stats.n_keepalives_sent++;
+            ++ _peer->stats.n_keepalives_sent;
 
     if (reply->keep_alive) {
         if (_peer)
-            _peer->stats.n_keepalives_recv++;
+            ++ _peer->stats.n_keepalives_recv;
 
         if (Config.onoff.detect_broken_server_pconns
                 && reply->bodySize(request->method) == -1 && !flags.chunked) {
@@ -1099,12 +1099,12 @@ HttpStateData::readReply(const CommIoCbParams &io)
 
         kb_incr(&(statCounter.server.all.kbytes_in), len);
         kb_incr(&(statCounter.server.http.kbytes_in), len);
-        IOStats.Http.reads++;
+        ++ IOStats.Http.reads;
 
-        for (clen = len - 1, bin = 0; clen; bin++)
+        for (clen = len - 1, bin = 0; clen; ++bin)
             clen >>= 1;
 
-        IOStats.Http.read_hist[bin]++;
+        ++ IOStats.Http.read_hist[bin];
 
         // update peer response time stats (%<pt)
         const timeval &sent = request->hier.peer_http_request_sent;
@@ -2167,8 +2167,8 @@ HttpStateData::start()
         return;
     }
 
-    statCounter.server.all.requests++;
-    statCounter.server.http.requests++;
+    ++ statCounter.server.all.requests;
+    ++ statCounter.server.http.requests;
 
     /*
      * We used to set the read timeout here, but not any more.
@@ -319,10 +319,10 @@ icpUdpSend(int fd,
         }
 
         Comm::SetSelect(fd, COMM_SELECT_WRITE, icpUdpSendQueue, NULL, 0);
-        statCounter.icp.replies_queued++;
+        ++statCounter.icp.replies_queued;
     } else {
         /* don't queue it */
-        statCounter.icp.replies_dropped++;
+        ++statCounter.icp.replies_dropped;
     }
 
     return x;
@@ -625,7 +625,7 @@ icpHandleUdp(int sock, void *data)
             break;
         }
 
-        (*N)++;
+        ++(*N);
         icpCount(buf, RECV, (size_t) len, 0);
         buf[len] = '\0';
         debugs(12, 4, "icpHandleUdp: FD " << sock << ": received " <<
@@ -784,36 +784,36 @@ icpCount(void *buf, int which, size_t len, int delay)
         return;
 
     if (SENT == which) {
-        statCounter.icp.pkts_sent++;
+        ++statCounter.icp.pkts_sent;
         kb_incr(&statCounter.icp.kbytes_sent, len);
 
         if (ICP_QUERY == icp->opcode) {
-            statCounter.icp.queries_sent++;
+            ++statCounter.icp.queries_sent;
             kb_incr(&statCounter.icp.q_kbytes_sent, len);
         } else {
-            statCounter.icp.replies_sent++;
+            ++statCounter.icp.replies_sent;
             kb_incr(&statCounter.icp.r_kbytes_sent, len);
             /* this is the sent-reply service time */
             statCounter.icp.replySvcTime.count(delay);
         }
 
         if (ICP_HIT == icp->opcode)
-            statCounter.icp.hits_sent++;
+            ++statCounter.icp.hits_sent;
     } else if (RECV == which) {
-        statCounter.icp.pkts_recv++;
+        ++statCounter.icp.pkts_recv;
         kb_incr(&statCounter.icp.kbytes_recv, len);
 
         if (ICP_QUERY == icp->opcode) {
-            statCounter.icp.queries_recv++;
+            ++statCounter.icp.queries_recv;
             kb_incr(&statCounter.icp.q_kbytes_recv, len);
         } else {
-            statCounter.icp.replies_recv++;
+            ++statCounter.icp.replies_recv;
             kb_incr(&statCounter.icp.r_kbytes_recv, len);
             /* statCounter.icp.querySvcTime set in clientUpdateCounters */
         }
 
         if (ICP_HIT == icp->opcode)
-            statCounter.icp.hits_recv++;
+            ++statCounter.icp.hits_recv;
     }
 }
 
@@ -388,7 +388,7 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
     close(t3);
 
     /* Make sure all other filedescriptors are closed */
-    for (x = 3; x < SQUID_MAXFD; x++)
+    for (x = 3; x < SQUID_MAXFD; ++x)
         close(x);
 
 #if HAVE_SETSID
@@ -547,7 +547,7 @@ ipc_thread_1(void *in_params)
     si.dwFlags = STARTF_USESTDHANDLES;
 
     /* Make sure all other valid handles are not inerithable */
-    for (x = 3; x < Squid_MaxFD; x++) {
+    for (x = 3; x < Squid_MaxFD; ++x) {
         if ((F = _get_osfhandle(x)) == -1)
             continue;
 
@@ -255,7 +255,7 @@ ipcache_purgelru(void *voidnotused)
 
         ipcacheRelease(i);
 
-        removed++;
+        ++removed;
     }
 
     debugs(14, 9, "ipcache_purgelru: removed " << removed << " entries");
@@ -423,14 +423,14 @@ ipcacheParse(ipcache_entry *i, const char *inbuf)
         int j, k;
 
         i->addrs.in_addrs = static_cast<Ip::Address *>(xcalloc(ipcount, sizeof(Ip::Address)));
-        for (int l = 0; l < ipcount; l++)
+        for (int l = 0; l < ipcount; ++l)
             i->addrs.in_addrs[l].SetEmpty(); // perform same init actions as constructor would.
         i->addrs.bad_mask = (unsigned char *)xcalloc(ipcount, sizeof(unsigned char));
         memset(i->addrs.bad_mask, 0, sizeof(unsigned char) * ipcount);
 
-        for (j = 0, k = 0; k < ipcount; k++) {
+        for (j = 0, k = 0; k < ipcount; ++k) {
             if ( i->addrs.in_addrs[j] = A[k] )
-                j++;
+                ++j;
             else
                 debugs(14, 1, "ipcacheParse: Invalid IP address '" << A[k] << "' in response to '" << name << "'");
         }
@@ -492,15 +492,15 @@ ipcacheParse(ipcache_entry *i, const rfc1035_rr * answers, int nr, const char *e
     debugs(14, 3, "ipcacheParse: " << nr << " answers for '" << name << "'");
     assert(answers);
 
-    for (k = 0; k < nr; k++) {
+    for (k = 0; k < nr; ++k) {
 
         if (Ip::EnableIpv6 && answers[k].type == RFC1035_TYPE_AAAA) {
             if (answers[k].rdlength != sizeof(struct in6_addr)) {
                 debugs(14, 1, "ipcacheParse: Invalid IPv6 address in response to '" << name << "'");
                 continue;
             }
-            na++;
-            IpcacheStats.rr_aaaa++;
+            ++na;
+            ++IpcacheStats.rr_aaaa;
             continue;
         }
 
@@ -509,15 +509,15 @@ ipcacheParse(ipcache_entry *i, const rfc1035_rr * answers, int nr, const char *e
                 debugs(14, 1, "ipcacheParse: Invalid IPv4 address in response to '" << name << "'");
                 continue;
             }
-            na++;
-            IpcacheStats.rr_a++;
+            ++na;
+            ++IpcacheStats.rr_a;
             continue;
         }
 
         /* With A and AAAA, the CNAME does not necessarily come with additional records to use. */
         if (answers[k].type == RFC1035_TYPE_CNAME) {
             cname_found=1;
-            IpcacheStats.rr_cname++;
+            ++IpcacheStats.rr_cname;
             continue;
         }
 
@@ -528,16 +528,16 @@ ipcacheParse(ipcache_entry *i, const rfc1035_rr * answers, int nr, const char *e
         debugs(14, 1, "ipcacheParse: No Address records in response to '" << name << "'");
         i->error_message = xstrdup("No Address records");
         if (cname_found)
-            IpcacheStats.cname_only++;
+            ++IpcacheStats.cname_only;
         return 0;
     }
 
     i->addrs.in_addrs = static_cast<Ip::Address *>(xcalloc(na, sizeof(Ip::Address)));
-    for (int l = 0; l < na; l++)
+    for (int l = 0; l < na; ++l)
         i->addrs.in_addrs[l].SetEmpty(); // perform same init actions as constructor would.
     i->addrs.bad_mask = (unsigned char *)xcalloc(na, sizeof(unsigned char));
 
-    for (j = 0, k = 0; k < nr; k++) {
+    for (j = 0, k = 0; k < nr; ++k) {
 
         if (answers[k].type == RFC1035_TYPE_A) {
             if (answers[k].rdlength != sizeof(struct in_addr))
@@ -548,7 +548,7 @@ ipcacheParse(ipcache_entry *i, const rfc1035_rr * answers, int nr, const char *e
             i->addrs.in_addrs[j] = temp;
 
             debugs(14, 3, "ipcacheParse: " << name << " #" << j << " " << i->addrs.in_addrs[j]);
-            j++;
+            ++j;
 
         } else if (Ip::EnableIpv6 && answers[k].type == RFC1035_TYPE_AAAA) {
             if (answers[k].rdlength != sizeof(struct in6_addr))
@@ -559,7 +559,7 @@ ipcacheParse(ipcache_entry *i, const rfc1035_rr * answers, int nr, const char *e
             i->addrs.in_addrs[j] = temp;
 
             debugs(14, 3, "ipcacheParse: " << name << " #" << j << " " << i->addrs.in_addrs[j] );
-            j++;
+            ++j;
         }
         if (ttl == 0 || (int) answers[k].ttl < ttl)
             ttl = answers[k].ttl;
@@ -597,7 +597,7 @@ ipcacheHandleReply(void *data, const rfc1035_rr * answers, int na, const char *e
 {
     ipcache_entry *i;
     static_cast<generic_cbdata *>(data)->unwrap(&i);
-    IpcacheStats.replies++;
+    ++IpcacheStats.replies;
     const int age = i->age();
     statCounter.dns.svcTime.count(age);
 
@@ -640,11 +640,11 @@ ipcache_nbgethostbyname(const char *name, IPH * handler, void *handlerData)
     const ipcache_addrs *addrs = NULL;
     generic_cbdata *c;
     debugs(14, 4, "ipcache_nbgethostbyname: Name '" << name << "'.");
-    IpcacheStats.requests++;
+    ++IpcacheStats.requests;
 
     if (name == NULL || name[0] == '\0') {
         debugs(14, 4, "ipcache_nbgethostbyname: Invalid name!");
-        IpcacheStats.invalid++;
+        ++IpcacheStats.invalid;
         const DnsLookupDetails details("Invalid hostname", -1); // error, no lookup
         if (handler)
             handler(NULL, details, handlerData);
@@ -653,7 +653,7 @@ ipcache_nbgethostbyname(const char *name, IPH * handler, void *handlerData)
 
     if ((addrs = ipcacheCheckNumeric(name))) {
         debugs(14, 4, "ipcache_nbgethostbyname: BYPASS for '" << name << "' (already numeric)");
-        IpcacheStats.numeric_hits++;
+        ++IpcacheStats.numeric_hits;
         const DnsLookupDetails details(NULL, -1); // no error, no lookup
         if (handler)
             handler(addrs, details, handlerData);
@@ -674,9 +674,9 @@ ipcache_nbgethostbyname(const char *name, IPH * handler, void *handlerData)
         debugs(14, 4, "ipcache_nbgethostbyname: HIT for '" << name << "'");
 
         if (i->flags.negcached)
-            IpcacheStats.negative_hits++;
+            ++IpcacheStats.negative_hits;
         else
-            IpcacheStats.hits++;
+            ++IpcacheStats.hits;
 
         i->handler = handler;
 
@@ -688,7 +688,7 @@ ipcache_nbgethostbyname(const char *name, IPH * handler, void *handlerData)
     }
 
     debugs(14, 5, "ipcache_nbgethostbyname: MISS for '" << name << "'");
-    IpcacheStats.misses++;
+    ++IpcacheStats.misses;
     i = ipcacheCreateEntry(name);
     i->handler = handler;
     i->handlerData = cbdataReference(handlerData);
@@ -763,7 +763,7 @@ ipcache_gethostbyname(const char *name, int flags)
     ipcache_addrs *addrs;
     assert(name);
     debugs(14, 3, "ipcache_gethostbyname: '" << name  << "', flags=" << std::hex << flags);
-    IpcacheStats.requests++;
+    ++IpcacheStats.requests;
     i = ipcache_get(name);
 
     if (NULL == i) {
@@ -772,11 +772,11 @@ ipcache_gethostbyname(const char *name, int flags)
         ipcacheRelease(i);
         i = NULL;
     } else if (i->flags.negcached) {
-        IpcacheStats.negative_hits++;
+        ++IpcacheStats.negative_hits;
         // ignore i->error_message: the caller just checks IP cache presence
         return NULL;
     } else {
-        IpcacheStats.hits++;
+        ++IpcacheStats.hits;
         i->lastref = squid_curtime;
         // ignore i->error_message: the caller just checks IP cache presence
         return &i->addrs;
@@ -785,11 +785,11 @@ ipcache_gethostbyname(const char *name, int flags)
     /* no entry [any more] */
 
     if ((addrs = ipcacheCheckNumeric(name))) {
-        IpcacheStats.numeric_hits++;
+        ++IpcacheStats.numeric_hits;
         return addrs;
     }
 
-    IpcacheStats.misses++;
+    ++IpcacheStats.misses;
 
     if (flags & IP_LOOKUP_IF_MISS)
         ipcache_nbgethostbyname(name, NULL, NULL);
@@ -835,7 +835,7 @@ ipcacheStatPrint(ipcache_entry * i, StoreEntry * sentry)
 
     /** \par
      * Cached entries have IPs listed with a BNF of:   ip-address '-' ('OK'|'BAD') */
-    for (k = 0; k < count; k++) {
+    for (k = 0; k < count; ++k) {
         /* Display tidy-up: IPv6 are so big make the list vertical */
         if (k == 0)
             storeAppendPrintf(sentry, " %45.45s-%3s\n",
@@ -1011,7 +1011,7 @@ ipcacheCycleAddr(const char *name, ipcache_addrs * ia)
         ia = &i->addrs;
     }
 
-    for (k = 0; k < ia->count; k++) {
+    for (k = 0; k < ia->count; ++k) {
         if (++ia->cur == ia->count)
             ia->cur = 0;
 
@@ -1023,7 +1023,7 @@ ipcacheCycleAddr(const char *name, ipcache_addrs * ia)
         /* All bad, reset to All good */
         debugs(14, 3, "ipcacheCycleAddr: Changing ALL " << name << " addrs from BAD to OK");
 
-        for (k = 0; k < ia->count; k++)
+        for (k = 0; k < ia->count; ++k)
             ia->bad_mask[k] = 0;
 
         ia->badcount = 0;
@@ -1054,7 +1054,7 @@ ipcacheMarkBadAddr(const char *name, const Ip::Address &addr)
 
     ia = &i->addrs;
 
-    for (k = 0; k < (int) ia->count; k++) {
+    for (k = 0; k < (int) ia->count; ++k) {
         if (addr == ia->in_addrs[k] )
             break;
     }
@@ -1066,7 +1066,7 @@ ipcacheMarkBadAddr(const char *name, const Ip::Address &addr)
     /** Marks the given address as BAD */
     if (!ia->bad_mask[k]) {
         ia->bad_mask[k] = TRUE;
-        ia->badcount++;
+        ++ia->badcount;
         i->expires = min(squid_curtime + max((time_t)60, Config.negativeDnsTtl), i->expires);
         debugs(14, 2, "ipcacheMarkBadAddr: " << name << " " << addr );
     }
@@ -1091,7 +1091,7 @@ ipcacheMarkAllGood(const char *name)
     /* All bad, reset to All good */
     debugs(14, 3, "ipcacheMarkAllGood: Changing ALL " << name << " addrs to OK (" << ia->badcount << "/" << ia->count << " bad)");
 
-    for (k = 0; k < ia->count; k++)
+    for (k = 0; k < ia->count; ++k)
         ia->bad_mask[k] = 0;
 
     ia->badcount = 0;
@@ -1110,7 +1110,7 @@ ipcacheMarkGoodAddr(const char *name, const Ip::Address &addr)
 
     ia = &i->addrs;
 
-    for (k = 0; k < (int) ia->count; k++) {
+    for (k = 0; k < (int) ia->count; ++k) {
         if (addr == ia->in_addrs[k])
             break;
     }
@@ -71,7 +71,7 @@ mime_get_header_field(const char *mime, const char *name, const char *prefix)
             return NULL;
 
         while (xisspace(*p))
-            p++;
+            ++p;
 
         if (strncasecmp(p, name, namelen))
             continue;
@@ -92,11 +92,15 @@ mime_get_header_field(const char *mime, const char *name, const char *prefix)
 
         q += namelen;
 
-        if (*q == ':')
-            q++, got = 1;
+        if (*q == ':') {
+            ++q;
+            got = 1;
+        }
 
-        while (xisspace(*q))
-            q++, got = 1;
+        while (xisspace(*q)) {
+            ++q;
+            got = 1;
+        }
 
         if (got && prefix) {
             /* we could process list entries here if we had strcasestr(). */
@@ -153,7 +157,7 @@ headersEnd(const char *mime, size_t l)
             break;
         }
 
-        e++;
+        ++e;
     }
     PROF_stop(headersEnd);
 
@@ -65,7 +65,7 @@ mcastJoinGroups(const ipcache_addrs *ia, const DnsLookupDetails &, void *datanot
         return;
     }
 
-    for (i = 0; i < (int) ia->count; i++) {
+    for (i = 0; i < (int) ia->count; ++i) {
         debugs(7, 9, "Listening for ICP requests on " << ia->in_addrs[i] );
 
         if ( ! ia->in_addrs[i].IsIPv4() ) {