diff --git a/src/ChangeLog b/src/ChangeLog
index c0b4f73..f07ddc5 100644
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,3 +1,58 @@
+2014-05-03  Tim Ruehsen  <tim.ruehsen@gmx.de>
+
+	* ftp-ls.c (ftp_parse_vms_ls): Explicitly typecast strlen's output
+	* ftp.c (getftp): Prevent declaration of shadow variable
+	* html-url.c (tag_handle_base, tag_handle_form, tag_handle_link,
+	tag_handle_meta): Compiler directive to ignore unused variable
+	* html-url.h (cleanup_html_url): Add function declaration
+	* http-ntlm.c (ntlm_input, mkhash): Use ssize_t to declare variables that store
+	sizes.
+	(mkhash): Explicitly typecast output of c_toupper
+	(short_pair): Add typecasts to prevent compiler warnings
+	(ntlm-output): Fix datatypes of various variables
+	* http.c (gethttp): Prevent declaration of shadow variable err
+	(gethttp): remove unreachable code
+	(test_parse_content_disposition): Fix variable declarations and use
+	countof() macro
+	* init.c (run_command): Prevent declaration of ghost variable
+	(cmd_string, cmd_string_uppercase, cmd_file, cnd_vector,
+	cmd_directory_vector, cmd_spec_dirstruct, cmd_spec_header,
+	cmd_spec_warc_header, cmd_spec_htmlify, cmd_spec_mirror,
+	cmd_spec_prefer_family, cmd_spec_progress, cmd_spec_recursive,
+	cmd_spec_regex_type, cmd_spec_restrict_file_names, cmd_spec_report_speed,
+	cmd_spec_timeout, cmd_spec_useragent, cmd_spec_verbose): Add compiler
+	directive to ignore unused variable
+	(cleanup_html_url, spider_cleanup): Remove declarations
+	(test_commands_sorted): Cleanup code
+	(test_cmd_spec_restrict_file_names): Use correct data types
+	* iri.c (remote_to_utf8): Use more verbose variable name
+	* main.c (init_switches): Prevent declaration of ghost variable
+	* netrc.c (netrc_cleanup): Create cleanup function on common naming scheme
+	* netrc.h (netrc_cleanup): Declare function
+	* openssl.c (openssl_write, openssl_errstr): Compiler directive to ignore
+	unused parameter
+	(openssl_errstr): Explcicitly typecasr output of ASN1_STRING_length
+	* options.h (struct options): Declare includes and excludes as const char **
+	* progress.c (progress_interactive_p, progress_handle_sigwinch): Compiler
+	directive to ignore unused parameter
+	* res.c (test_is_robots_txt_url): Fix datatypes
+	* retr.c (line_terminator): Add compiler directive for ignoring unused
+	paramter. Remove unused variable.
+	* spider.h (spider_cleanup): Declare function
+	* test,c (main): declare unused paramter
+	* test.h (test_*): Declare functions
+	* url.c (url_string): Explicit typecast of password strings
+	(run_test): Declare *test, struct tests and *expected_result as const
+	(test_path_simplify, test_append_uri_pathl, test_are_urls_equal): Fix datatypes
+	* utls.c (fork_to_background): Be more verbose when errors occur
+	(dir_matches_p, test_dir_matches_p): Declare char * as const as required
+	(base64_encode, base64_decode, get_max_length): Set correct return type
+	(match_pcre_regex, match_posix_regex): Use correct datatypes and typecasts
+	(test_subdir_p): static const struct
+	* utils.h (base64_encode, base64_decode, get_max_length): Fix return type
+	* warc.c (ward_write_cdx_record): unused parameter
+	(struct hash_table *warc_cdx_dedup_table): Declare as static
+
 2014-05-01  Benjamin Goose  <gans+wget@tngtech.com>
 
 	* http.c: Fix small memory leak
diff --git a/src/css-url.c b/src/css-url.c
index f97690d..e8c4989 100644
--- a/src/css-url.c
+++ b/src/css-url.c
@@ -64,41 +64,6 @@ typedef struct yy_buffer_state *YY_BUFFER_STATE;
 extern YY_BUFFER_STATE yy_scan_bytes (const char *bytes,int len  );
 extern int yylex (void);
 
-#if 1
-const char *token_names[] = {
-  "CSSEOF",
-  "S",
-  "CDO",
-  "CDC",
-  "INCLUDES",
-  "DASHMATCH",
-  "LBRACE",
-  "PLUS",
-  "GREATER",
-  "COMMA",
-  "STRING",
-  "INVALID",
-  "IDENT",
-  "HASH",
-  "IMPORT_SYM",
-  "PAGE_SYM",
-  "MEDIA_SYM",
-  "CHARSET_SYM",
-  "IMPORTANT_SYM",
-  "EMS",
-  "EXS",
-  "LENGTH",
-  "ANGLE",
-  "TIME",
-  "FREQ",
-  "DIMENSION",
-  "PERCENTAGE",
-  "NUMBER",
-  "URI",
-  "FUNCTION"
-};
-#endif
-
 /*
   Given a detected URI token, get only the URI specified within.
   Also adjust the starting position and length of the string.
diff --git a/src/ftp-ls.c b/src/ftp-ls.c
index 1039a43..d9077a3 100644
--- a/src/ftp-ls.c
+++ b/src/ftp-ls.c
@@ -895,7 +895,8 @@ ftp_parse_vms_ls (const char *file)
               /* Protections (permissions). */
               perms = 0;
               j = 0;
-              for (i = 0; i < strlen(tok); i++)
+              /*FIXME: Should not be using the variable like this. */
+              for (i = 0; i < (int) strlen(tok); i++)
                 {
                   switch (tok[ i])
                     {
diff --git a/src/ftp.c b/src/ftp.c
index 2db98bb..25f05a4 100644
--- a/src/ftp.c
+++ b/src/ftp.c
@@ -990,15 +990,14 @@ Error in server response, closing control connection.\n"));
       if (opt.spider)
         {
           bool exists = false;
-          uerr_t res;
           struct fileinfo *f;
-          res = ftp_get_listing (u, con, &f);
+          uerr_t _res = ftp_get_listing (u, con, &f);
           /* Set the DO_RETR command flag again, because it gets unset when
              calling ftp_get_listing() and would otherwise cause an assertion
              failure earlier on when this function gets repeatedly called
              (e.g., when recursing).  */
           con->cmd |= DO_RETR;
-          if (res == RETROK)
+          if (_res == RETROK)
             {
               while (f)
                 {
@@ -1235,8 +1234,7 @@ Error in server response, closing control connection.\n"));
         {
           if (opt.unlink && file_exists_p (con->target))
             {
-              int res = unlink (con->target);
-              if (res < 0)
+              if (unlink (con->target) < 0)
                 {
                   logprintf (LOG_NOTQUIET, "%s: %s\n", con->target,
                     strerror (errno));
diff --git a/src/html-url.c b/src/html-url.c
index 1bb44b4..3c6c9b9 100644
--- a/src/html-url.c
+++ b/src/html-url.c
@@ -472,7 +472,7 @@ tag_find_urls (int tagid, struct taginfo *tag, struct map_context *ctx)
 /* Handle the BASE tag, for <base href=...>. */
 
 static void
-tag_handle_base (int tagid, struct taginfo *tag, struct map_context *ctx)
+tag_handle_base (int tagid _GL_UNUSED, struct taginfo *tag, struct map_context *ctx)
 {
   struct urlpos *base_urlpos;
   int attrind;
@@ -498,7 +498,7 @@ tag_handle_base (int tagid, struct taginfo *tag, struct map_context *ctx)
 /* Mark the URL found in <form action=...> for conversion. */
 
 static void
-tag_handle_form (int tagid, struct taginfo *tag, struct map_context *ctx)
+tag_handle_form (int tagid _GL_UNUSED, struct taginfo *tag, struct map_context *ctx)
 {
   int attrind;
   char *action = find_attr (tag, "action", &attrind);
@@ -516,7 +516,7 @@ tag_handle_form (int tagid, struct taginfo *tag, struct map_context *ctx)
    links will be followed in -p mode depends on the REL attribute.  */
 
 static void
-tag_handle_link (int tagid, struct taginfo *tag, struct map_context *ctx)
+tag_handle_link (int tagid _GL_UNUSED, struct taginfo *tag, struct map_context *ctx)
 {
   int attrind;
   char *href = find_attr (tag, "href", &attrind);
@@ -565,7 +565,7 @@ tag_handle_link (int tagid, struct taginfo *tag, struct map_context *ctx)
    refresh feature and because of robot exclusion.  */
 
 static void
-tag_handle_meta (int tagid, struct taginfo *tag, struct map_context *ctx)
+tag_handle_meta (int tagid _GL_UNUSED, struct taginfo *tag, struct map_context *ctx)
 {
   char *name = find_attr (tag, "name", NULL);
   char *http_equiv = find_attr (tag, "http-equiv", NULL);
diff --git a/src/html-url.h b/src/html-url.h
index 11fab93..81fbfdb 100644
--- a/src/html-url.h
+++ b/src/html-url.h
@@ -47,5 +47,6 @@ struct urlpos *get_urls_file (const char *);
 struct urlpos *get_urls_html (const char *, const char *, bool *, struct iri *);
 struct urlpos *append_url (const char *, int, int, struct map_context *);
 void free_urlpos (struct urlpos *);
+void cleanup_html_url (void);
 
 #endif /* HTML_URL_H */
diff --git a/src/http-ntlm.c b/src/http-ntlm.c
index 591bfb5..d9b6884 100644
--- a/src/http-ntlm.c
+++ b/src/http-ntlm.c
@@ -73,42 +73,13 @@ as that of the covered work.  */
 
 /* Define this to make the type-3 message include the NT response message */
 #define USE_NTRESPONSES 1
+
 
 /* Flag bits definitions available at on
    http://davenport.sourceforge.net/ntlm.html */
 
-#define NTLMFLAG_NEGOTIATE_UNICODE               (1<<0)
 #define NTLMFLAG_NEGOTIATE_OEM                   (1<<1)
-#define NTLMFLAG_REQUEST_TARGET                  (1<<2)
-/* unknown (1<<3) */
-#define NTLMFLAG_NEGOTIATE_SIGN                  (1<<4)
-#define NTLMFLAG_NEGOTIATE_SEAL                  (1<<5)
-#define NTLMFLAG_NEGOTIATE_DATAGRAM_STYLE        (1<<6)
-#define NTLMFLAG_NEGOTIATE_LM_KEY                (1<<7)
-#define NTLMFLAG_NEGOTIATE_NETWARE               (1<<8)
 #define NTLMFLAG_NEGOTIATE_NTLM_KEY              (1<<9)
-/* unknown (1<<10) */
-/* unknown (1<<11) */
-#define NTLMFLAG_NEGOTIATE_DOMAIN_SUPPLIED       (1<<12)
-#define NTLMFLAG_NEGOTIATE_WORKSTATION_SUPPLIED  (1<<13)
-#define NTLMFLAG_NEGOTIATE_LOCAL_CALL            (1<<14)
-#define NTLMFLAG_NEGOTIATE_ALWAYS_SIGN           (1<<15)
-#define NTLMFLAG_TARGET_TYPE_DOMAIN              (1<<16)
-#define NTLMFLAG_TARGET_TYPE_SERVER              (1<<17)
-#define NTLMFLAG_TARGET_TYPE_SHARE               (1<<18)
-#define NTLMFLAG_NEGOTIATE_NTLM2_KEY             (1<<19)
-#define NTLMFLAG_REQUEST_INIT_RESPONSE           (1<<20)
-#define NTLMFLAG_REQUEST_ACCEPT_RESPONSE         (1<<21)
-#define NTLMFLAG_REQUEST_NONNT_SESSION_KEY       (1<<22)
-#define NTLMFLAG_NEGOTIATE_TARGET_INFO           (1<<23)
-/* unknown (1<24) */
-/* unknown (1<25) */
-/* unknown (1<26) */
-/* unknown (1<27) */
-/* unknown (1<28) */
-#define NTLMFLAG_NEGOTIATE_128                   (1<<29)
-#define NTLMFLAG_NEGOTIATE_KEY_EXCHANGE          (1<<30)
-#define NTLMFLAG_NEGOTIATE_56                    (1<<31)
 
 /*
   (*) = A "security buffer" is a triplet consisting of two shorts and one
@@ -146,7 +117,7 @@ ntlm_input (struct ntlmdata *ntlm, const char *header)
          (40)    Target Information  (optional) security buffer(*)
          32 (48) start of data block
       */
-      int size;
+      ssize_t size;
       char *buffer = (char *) alloca (strlen (header));
 
       DEBUGP (("Received a type-2 NTLM message.\n"));
@@ -277,8 +248,7 @@ mkhash(const char *password,
   static const unsigned char magic[] = {
     0x4B, 0x47, 0x53, 0x21, 0x40, 0x23, 0x24, 0x25
   };
-  int i;
-  int len = strlen(password);
+  size_t i, len = strlen(password);
 
   /* make it fit at least 14 bytes */
   pw = (unsigned char *) alloca (len < 7 ? 14 : len * 2);
@@ -287,7 +257,7 @@ mkhash(const char *password,
     len = 14;
 
   for (i=0; i<len; i++)
-    pw[i] = c_toupper (password[i]);
+    pw[i] = (unsigned char) c_toupper (password[i]);
 
   for (; i<14; i++)
     pw[i] = 0;
@@ -330,13 +300,13 @@ mkhash(const char *password,
     len = strlen(password);
 
     for (i=0; i<len; i++) {
-      pw[2*i]   = password[i];
+      pw[2*i]   = (unsigned char) password[i];
       pw[2*i+1] = 0;
     }
 
 #ifdef HAVE_NETTLE
     nettle_md4_init(&MD4);
-    nettle_md4_update(&MD4, 2*len, pw);
+    nettle_md4_update(&MD4, (unsigned) (2 * len), pw);
     nettle_md4_digest(&MD4, MD4_DIGEST_SIZE, ntbuffer);
 #else
     /* create NT hashed password */
@@ -352,7 +322,7 @@ mkhash(const char *password,
 #endif
 }
 
-#define SHORTPAIR(x) ((x) & 0xff), ((x) >> 8)
+#define SHORTPAIR(x) (char) ((x) & 0xff), (char) ((x) >> 8)
 #define LONGQUARTET(x) ((x) & 0xff), (((x) >> 8)&0xff), \
   (((x) >>16)&0xff), ((x)>>24)
 
@@ -361,19 +331,19 @@ char *
 ntlm_output (struct ntlmdata *ntlm, const char *user, const char *passwd,
              bool *ready)
 {
-  const char *domain=""; /* empty */
-  const char *host=""; /* empty */
-  int domlen=strlen(domain);
-  int hostlen = strlen(host);
-  int hostoff; /* host name offset */
-  int domoff;  /* domain name offset */
-  int size;
+  const char *domain = ""; /* empty */
+  const char *host = ""; /* empty */
+  size_t domlen = strlen(domain);
+  size_t hostlen = strlen(host);
+  size_t hostoff; /* host name offset */
+  size_t domoff;  /* domain name offset */
+  size_t size;
   char *base64;
   char ntlmbuf[256]; /* enough, unless the host/domain is very long */
 
   /* point to the address of the pointer that holds the string to sent to the
      server, which is for a plain host or for a HTTP proxy */
-  char *output;
+  char *output = NULL;
 
   *ready = false;
 
@@ -386,7 +356,8 @@ ntlm_output (struct ntlmdata *ntlm, const char *user, const char *passwd,
 
   switch(ntlm->state) {
   case NTLMSTATE_TYPE1:
-  default: /* for the weird cases we (re)start here */
+  case NTLMSTATE_NONE:
+  case NTLMSTATE_LAST:
     hostoff = 32;
     domoff = hostoff + hostlen;
 
@@ -464,15 +435,15 @@ ntlm_output (struct ntlmdata *ntlm, const char *user, const char *passwd,
     */
 
   {
-    int lmrespoff;
-    int ntrespoff;
-    int useroff;
+    size_t lmrespoff;
+    size_t ntrespoff;
+    size_t useroff;
     unsigned char lmresp[0x18]; /* fixed-size */
 #ifdef USE_NTRESPONSES
     unsigned char ntresp[0x18]; /* fixed-size */
 #endif
     const char *usr;
-    int userlen;
+    size_t userlen;
 
     DEBUGP (("Creating a type-3 NTLM message.\n"));
 
@@ -482,7 +453,7 @@ ntlm_output (struct ntlmdata *ntlm, const char *user, const char *passwd,
 
     if (usr) {
       domain = user;
-      domlen = usr - domain;
+      domlen = (size_t) (usr - domain);
       usr++;
     }
     else
@@ -503,7 +474,7 @@ ntlm_output (struct ntlmdata *ntlm, const char *user, const char *passwd,
 
     /* Create the big type-3 message binary blob */
 
-    size = snprintf (ntlmbuf, sizeof(ntlmbuf),
+    size = (size_t) snprintf (ntlmbuf, sizeof(ntlmbuf),
                      "NTLMSSP%c"
                      "\x03%c%c%c" /* type-3, 32 bits */
 
@@ -586,7 +557,7 @@ ntlm_output (struct ntlmdata *ntlm, const char *user, const char *passwd,
 
     /* Make sure that the user and domain strings fit in the target buffer
        before we copy them there. */
-    if(((size_t) size + userlen + domlen) >= sizeof(ntlmbuf))
+    if((size + userlen + domlen) >= sizeof(ntlmbuf))
       return NULL;
 
     memcpy(&ntlmbuf[size], domain, domlen);
@@ -596,20 +567,20 @@ ntlm_output (struct ntlmdata *ntlm, const char *user, const char *passwd,
     size += userlen;
 
     /* we append the binary hashes to the end of the blob */
-    if(size < ((int)sizeof(ntlmbuf) - 0x18)) {
+    if(size < (sizeof(ntlmbuf) - 0x18)) {
       memcpy(&ntlmbuf[size], lmresp, 0x18);
       size += 0x18;
     }
 
 #ifdef USE_NTRESPONSES
-    if(size < ((int)sizeof(ntlmbuf) - 0x18)) {
+    if(size < (sizeof(ntlmbuf) - 0x18)) {
       memcpy(&ntlmbuf[size], ntresp, 0x18);
       size += 0x18;
     }
 #endif
 
-    ntlmbuf[56] = size & 0xff;
-    ntlmbuf[57] = size >> 8;
+    ntlmbuf[56] = (char) (size & 0xff);
+    ntlmbuf[57] = (char) (size >> 8);
 
     /* convert the binary blob into base64 */
     base64 = (char *) alloca (BASE64_LENGTH (size) + 1);
diff --git a/src/http.c b/src/http.c
index c82bbd2..b50acf4 100644
--- a/src/http.c
+++ b/src/http.c
@@ -2335,23 +2335,23 @@ read_header:
          But if we are writing a WARC file we are: we like to keep everyting.  */
       if (warc_enabled)
         {
-          int err;
+          int _err;
           type = resp_header_strdup (resp, "Content-Type");
-          err = read_response_body (hs, sock, NULL, contlen, 0,
+          _err = read_response_body (hs, sock, NULL, contlen, 0,
                                     chunked_transfer_encoding,
                                     u->url, warc_timestamp_str,
                                     warc_request_uuid, warc_ip, type,
                                     statcode, head);
           xfree_null (type);
 
-          if (err != RETRFINISHED || hs->res < 0)
+          if (_err != RETRFINISHED || hs->res < 0)
             {
               CLOSE_INVALIDATE (sock);
               request_free (req);
               xfree_null (message);
               resp_free (resp);
               xfree (head);
-              return err;
+              return _err;
             }
           else
             CLOSE_FINISH (sock);
@@ -2661,18 +2661,18 @@ read_header:
              But if we are writing a WARC file we are: we like to keep everyting.  */
           if (warc_enabled)
             {
-              int err = read_response_body (hs, sock, NULL, contlen, 0,
+              int _err = read_response_body (hs, sock, NULL, contlen, 0,
                                             chunked_transfer_encoding,
                                             u->url, warc_timestamp_str,
                                             warc_request_uuid, warc_ip, type,
                                             statcode, head);
 
-              if (err != RETRFINISHED || hs->res < 0)
+              if (_err != RETRFINISHED || hs->res < 0)
                 {
                   CLOSE_INVALIDATE (sock);
                   xfree_null (type);
                   xfree (head);
-                  return err;
+                  return _err;
                 }
               else
                 CLOSE_FINISH (sock);
@@ -2708,7 +2708,6 @@ read_header:
             {
             case HTTP_STATUS_TEMPORARY_REDIRECT:
               return NEWLOCATION_KEEP_POST;
-              break;
             case HTTP_STATUS_MOVED_PERMANENTLY:
               if (opt.method && strcasecmp (opt.method, "post") != 0)
                 return NEWLOCATION_KEEP_POST;
@@ -2719,7 +2718,6 @@ read_header:
               break;
             default:
               return NEWLOCATION;
-              break;
             }
           return NEWLOCATION;
         }
@@ -2840,18 +2838,18 @@ read_header:
          But if we are writing a WARC file we are: we like to keep everyting.  */
       if (warc_enabled)
         {
-          int err = read_response_body (hs, sock, NULL, contlen, 0,
+          int _err = read_response_body (hs, sock, NULL, contlen, 0,
                                         chunked_transfer_encoding,
                                         u->url, warc_timestamp_str,
                                         warc_request_uuid, warc_ip, type,
                                         statcode, head);
 
-          if (err != RETRFINISHED || hs->res < 0)
+          if (_err != RETRFINISHED || hs->res < 0)
             {
               CLOSE_INVALIDATE (sock);
               xfree (head);
               xfree_null (type);
-              return err;
+              return _err;
             }
           else
             CLOSE_FINISH (sock);
@@ -4070,12 +4068,12 @@ ensure_extension (struct http_stat *hs, const char *ext, int *dt)
 #ifdef TESTING
 
 const char *
-test_parse_content_disposition()
+test_parse_content_disposition(void)
 {
-  int i;
-  struct {
-    char *hdrval;
-    char *filename;
+  unsigned i;
+  static const struct {
+    const char *hdrval;
+    const char *filename;
     bool result;
   } test_array[] = {
     { "filename=\"file.ext\"", "file.ext", true },
@@ -4086,7 +4084,7 @@ test_parse_content_disposition()
     { "attachement; filename*0=\"hello\"; filename*1=\"world.txt\"", "helloworld.txt", true },
   };
 
-  for (i = 0; i < sizeof(test_array)/sizeof(test_array[0]); ++i)
+  for (i = 0; i < countof(test_array); ++i)
     {
       char *filename;
       bool res;
diff --git a/src/init.c b/src/init.c
index 7d024f8..fbef133 100644
--- a/src/init.c
+++ b/src/init.c
@@ -68,6 +68,7 @@ as that of the covered work.  */
 #include "http.h"               /* for http_cleanup */
 #include "retr.h"               /* for output_stream */
 #include "warc.h"               /* for warc_close */
+#include "spider.h"             /* for spider_cleanup */
 
 #ifdef TESTING
 #include "test.h"
@@ -862,11 +863,11 @@ setoptval (const char *com, const char *val, const char *optname)
    This is used by the `--execute' flag in main.c.  */
 
 void
-run_command (const char *opt)
+run_command (const char *cmdopt)
 {
   char *com, *val;
   int comind;
-  switch (parse_line (opt, &com, &val, &comind))
+  switch (parse_line (cmdopt, &com, &val, &comind))
     {
     case line_ok:
       if (!setval_internal (comind, com, val))
@@ -876,7 +877,7 @@ run_command (const char *opt)
       break;
     default:
       fprintf (stderr, _("%s: Invalid --execute command %s\n"),
-               exec_name, quote (opt));
+               exec_name, quote (cmdopt));
       exit (2);
     }
 }
@@ -959,7 +960,7 @@ cmd_number_inf (const char *com, const char *val, void *place)
 /* Copy (strdup) the string at COM to a new location and place a
    pointer to *PLACE.  */
 static bool
-cmd_string (const char *com, const char *val, void *place)
+cmd_string (const char *com _GL_UNUSED, const char *val, void *place)
 {
   char **pstring = (char **)place;
 
@@ -970,7 +971,7 @@ cmd_string (const char *com, const char *val, void *place)
 
 /* Like cmd_string but ensure the string is upper case.  */
 static bool
-cmd_string_uppercase (const char *com, const char *val, void *place)
+cmd_string_uppercase (const char *com _GL_UNUSED, const char *val, void *place)
 {
   char *q, **pstring;
   pstring = (char **)place;
@@ -990,7 +991,7 @@ cmd_string_uppercase (const char *com, const char *val, void *place)
    `.wgetrc'.  In that case, and if VAL begins with `~', the tilde
    gets expanded to the user's home directory.  */
 static bool
-cmd_file (const char *com, const char *val, void *place)
+cmd_file (const char *com _GL_UNUSED, const char *val, void *place)
 {
   char **pstring = (char **)place;
 
@@ -1037,7 +1038,7 @@ cmd_directory (const char *com, const char *val, void *place)
    PLACE vector is cleared instead.  */
 
 static bool
-cmd_vector (const char *com, const char *val, void *place)
+cmd_vector (const char *com _GL_UNUSED, const char *val, void *place)
 {
   char ***pvec = (char ***)place;
 
@@ -1052,7 +1053,7 @@ cmd_vector (const char *com, const char *val, void *place)
 }
 
 static bool
-cmd_directory_vector (const char *com, const char *val, void *place)
+cmd_directory_vector (const char *com _GL_UNUSED, const char *val, void *place)
 {
   char ***pvec = (char ***)place;
 
@@ -1268,7 +1269,7 @@ cmd_cert_type (const char *com, const char *val, void *place)
 static bool check_user_specified_header (const char *);
 
 static bool
-cmd_spec_dirstruct (const char *com, const char *val, void *place_ignored)
+cmd_spec_dirstruct (const char *com, const char *val, void *place_ignored _GL_UNUSED)
 {
   if (!cmd_boolean (com, val, &opt.dirstruct))
     return false;
@@ -1282,7 +1283,7 @@ cmd_spec_dirstruct (const char *com, const char *val, void *place_ignored)
 }
 
 static bool
-cmd_spec_header (const char *com, const char *val, void *place_ignored)
+cmd_spec_header (const char *com, const char *val, void *place_ignored _GL_UNUSED)
 {
   /* Empty value means reset the list of headers. */
   if (*val == '\0')
@@ -1303,7 +1304,7 @@ cmd_spec_header (const char *com, const char *val, void *place_ignored)
 }
 
 static bool
-cmd_spec_warc_header (const char *com, const char *val, void *place_ignored)
+cmd_spec_warc_header (const char *com, const char *val, void *place_ignored _GL_UNUSED)
 {
   /* Empty value means reset the list of headers. */
   if (*val == '\0')
@@ -1324,7 +1325,7 @@ cmd_spec_warc_header (const char *com, const char *val, void *place_ignored)
 }
 
 static bool
-cmd_spec_htmlify (const char *com, const char *val, void *place_ignored)
+cmd_spec_htmlify (const char *com, const char *val, void *place_ignored _GL_UNUSED)
 {
   int flag = cmd_boolean (com, val, &opt.htmlify);
   if (flag && !opt.htmlify)
@@ -1336,7 +1337,7 @@ cmd_spec_htmlify (const char *com, const char *val, void *place_ignored)
    no limit on max. recursion depth, and don't remove listings.  */
 
 static bool
-cmd_spec_mirror (const char *com, const char *val, void *place_ignored)
+cmd_spec_mirror (const char *com, const char *val, void *place_ignored _GL_UNUSED)
 {
   int mirror;
 
@@ -1358,7 +1359,7 @@ cmd_spec_mirror (const char *com, const char *val, void *place_ignored)
    "IPv4", "IPv6", and "none".  */
 
 static bool
-cmd_spec_prefer_family (const char *com, const char *val, void *place_ignored)
+cmd_spec_prefer_family (const char *com, const char *val, void *place_ignored _GL_UNUSED)
 {
   static const struct decode_item choices[] = {
     { "IPv4", prefer_ipv4 },
@@ -1377,7 +1378,7 @@ cmd_spec_prefer_family (const char *com, const char *val, void *place_ignored)
    implementation before that.  */
 
 static bool
-cmd_spec_progress (const char *com, const char *val, void *place_ignored)
+cmd_spec_progress (const char *com, const char *val, void *place_ignored _GL_UNUSED)
 {
   if (!valid_progress_implementation_p (val))
     {
@@ -1398,7 +1399,7 @@ cmd_spec_progress (const char *com, const char *val, void *place_ignored)
    is specified.  */
 
 static bool
-cmd_spec_recursive (const char *com, const char *val, void *place_ignored)
+cmd_spec_recursive (const char *com, const char *val, void *place_ignored _GL_UNUSED)
 {
   if (!cmd_boolean (com, val, &opt.recursive))
     return false;
@@ -1413,7 +1414,7 @@ cmd_spec_recursive (const char *com, const char *val, void *place_ignored)
 /* Validate --regex-type and set the choice.  */
 
 static bool
-cmd_spec_regex_type (const char *com, const char *val, void *place_ignored)
+cmd_spec_regex_type (const char *com, const char *val, void *place_ignored _GL_UNUSED)
 {
   static const struct decode_item choices[] = {
     { "posix", regex_type_posix },
@@ -1430,7 +1431,7 @@ cmd_spec_regex_type (const char *com, const char *val, void *place_ignored)
 }
 
 static bool
-cmd_spec_restrict_file_names (const char *com, const char *val, void *place_ignored)
+cmd_spec_restrict_file_names (const char *com, const char *val, void *place_ignored _GL_UNUSED)
 {
   int restrict_os = opt.restrict_files_os;
   int restrict_ctrl = opt.restrict_files_ctrl;
@@ -1484,7 +1485,7 @@ cmd_spec_restrict_file_names (const char *com, const char *val, void *place_igno
 }
 
 static bool
-cmd_spec_report_speed (const char *com, const char *val, void *place_ignored)
+cmd_spec_report_speed (const char *com, const char *val, void *place_ignored _GL_UNUSED)
 {
   opt.report_bps = strcasecmp (val, "bits") == 0;
   if (!opt.report_bps)
@@ -1513,7 +1514,7 @@ cmd_spec_secure_protocol (const char *com, const char *val, void *place)
 /* Set all three timeout values. */
 
 static bool
-cmd_spec_timeout (const char *com, const char *val, void *place_ignored)
+cmd_spec_timeout (const char *com, const char *val, void *place_ignored _GL_UNUSED)
 {
   double value;
   if (!cmd_time (com, val, &value))
@@ -1525,7 +1526,7 @@ cmd_spec_timeout (const char *com, const char *val, void *place_ignored)
 }
 
 static bool
-cmd_spec_useragent (const char *com, const char *val, void *place_ignored)
+cmd_spec_useragent (const char *com, const char *val, void *place_ignored _GL_UNUSED)
 {
   /* Disallow embedded newlines.  */
   if (strchr (val, '\n'))
@@ -1544,7 +1545,7 @@ cmd_spec_useragent (const char *com, const char *val, void *place_ignored)
    some random hackery for disallowing -q -v).  */
 
 static bool
-cmd_spec_verbose (const char *com, const char *val, void *place_ignored)
+cmd_spec_verbose (const char *com, const char *val, void *place_ignored _GL_UNUSED)
 {
   bool flag;
   if (cmd_boolean (com, val, &flag))
@@ -1697,11 +1698,6 @@ decode_string (const char *val, const struct decode_item *items, int itemcount,
   return false;
 }
 
-
-void cleanup_html_url (void);
-void spider_cleanup (void);
-
-
 /* Free the memory allocated by global variables.  */
 void
 cleanup (void)
@@ -1737,14 +1733,11 @@ cleanup (void)
   spider_cleanup ();
   host_cleanup ();
   log_cleanup ();
+  netrc_cleanup (netrc_list);
 
   for (i = 0; i < nurl; i++)
     xfree (url[i]);
 
-  {
-    extern acc_t *netrc_list;
-    free_netrc (netrc_list);
-  }
   xfree_null (opt.choose_config);
   xfree_null (opt.lfilename);
   xfree_null (opt.dir_prefix);
@@ -1794,34 +1787,27 @@ cleanup (void)
 #ifdef TESTING
 
 const char *
-test_commands_sorted()
+test_commands_sorted(void)
 {
-  int prev_idx = 0, next_idx = 1;
-  int command_count = countof (commands) - 1;
-  int cmp = 0;
-  while (next_idx <= command_count)
+  unsigned i;
+
+  for (i = 1; i < countof(commands); ++i)
     {
-      cmp = strcasecmp (commands[prev_idx].name, commands[next_idx].name);
-      if (cmp > 0)
+      if (strcasecmp (commands[i - 1].name, commands[i].name) > 0)
         {
           mu_assert ("FAILED", false);
           break;
         }
-      else
-        {
-          prev_idx ++;
-	  next_idx ++;
-        }
     }
   return NULL;
 }
 
 const char *
-test_cmd_spec_restrict_file_names()
+test_cmd_spec_restrict_file_names(void)
 {
-  int i;
-  struct {
-    char *val;
+  unsigned i;
+  static const struct {
+    const char *val;
     int expected_restrict_files_os;
     int expected_restrict_files_ctrl;
     int expected_restrict_files_case;
@@ -1833,7 +1819,7 @@ test_cmd_spec_restrict_file_names()
     { "unix,nocontrol,lowercase,", restrict_unix, false, restrict_lowercase, true },
   };
 
-  for (i = 0; i < sizeof(test_array)/sizeof(test_array[0]); ++i)
+  for (i = 0; i < countof(test_array); ++i)
     {
       bool res;
 
diff --git a/src/iri.c b/src/iri.c
index 9b16639..dcab3ea 100644
--- a/src/iri.c
+++ b/src/iri.c
@@ -256,22 +256,22 @@ idn_decode (char *host)
 /* Try to transcode string str from remote encoding to UTF-8. On success, *new
    contains the transcoded string. *new content is unspecified otherwise. */
 bool
-remote_to_utf8 (struct iri *i, const char *str, const char **new)
+remote_to_utf8 (struct iri *iri, const char *str, const char **new)
 {
   iconv_t cd;
   bool ret = false;
 
-  if (!i->uri_encoding)
+  if (!iri->uri_encoding)
     return false;
 
   /* When `i->uri_encoding' == "UTF-8" there is nothing to convert.  But we must
      test for non-ASCII symbols for correct hostname processing in `idn_encode'
      function. */
-  if (!strcmp (i->uri_encoding, "UTF-8"))
+  if (!strcmp (iri->uri_encoding, "UTF-8"))
     {
-      int i, len = strlen (str);
-      for (i = 0; i < len; i++)
-        if ((unsigned char) str[i] >= (unsigned char) '\200')
+      const char *p = str;
+      for (p = str; *p; p++)
+        if (*p < 0)
           {
             *new = strdup (str);
             return true;
@@ -279,7 +279,7 @@ remote_to_utf8 (struct iri *i, const char *str, const char **new)
       return false;
     }
 
-  cd = iconv_open ("UTF-8", i->uri_encoding);
+  cd = iconv_open ("UTF-8", iri->uri_encoding);
   if (cd == (iconv_t)(-1))
     return false;
 
diff --git a/src/main.c b/src/main.c
index 3d99a1e..29c1324 100644
--- a/src/main.c
+++ b/src/main.c
@@ -351,26 +351,26 @@ init_switches (void)
   size_t i, o = 0;
   for (i = 0; i < countof (option_data); i++)
     {
-      struct cmdline_option *opt = &option_data[i];
+      struct cmdline_option *cmdopt = &option_data[i];
       struct option *longopt;
 
-      if (!opt->long_name)
+      if (!cmdopt->long_name)
         /* The option is disabled. */
         continue;
 
       longopt = &long_options[o++];
-      longopt->name = opt->long_name;
+      longopt->name = cmdopt->long_name;
       longopt->val = i;
-      if (opt->short_name)
+      if (cmdopt->short_name)
         {
-          *p++ = opt->short_name;
-          optmap[opt->short_name - 32] = longopt - long_options;
+          *p++ = cmdopt->short_name;
+          optmap[cmdopt->short_name - 32] = longopt - long_options;
         }
-      switch (opt->type)
+      switch (cmdopt->type)
         {
         case OPT_VALUE:
           longopt->has_arg = required_argument;
-          if (opt->short_name)
+          if (cmdopt->short_name)
             *p++ = ':';
           break;
         case OPT_BOOLEAN:
@@ -384,16 +384,16 @@ init_switches (void)
              identical to "--foo", except it has opposite meaning and
              it doesn't allow an argument.  */
           longopt = &long_options[o++];
-          longopt->name = no_prefix (opt->long_name);
+          longopt->name = no_prefix (cmdopt->long_name);
           longopt->has_arg = no_argument;
           /* Mask the value so we'll be able to recognize that we're
              dealing with the false value.  */
           longopt->val = i | BOOLEAN_NEG_MARKER;
           break;
         default:
-          assert (opt->argtype != -1);
-          longopt->has_arg = opt->argtype;
-          if (opt->short_name)
+          assert (cmdopt->argtype != -1);
+          longopt->has_arg = cmdopt->argtype;
+          if (cmdopt->short_name)
             {
               if (longopt->has_arg == required_argument)
                 *p++ = ':';
@@ -979,7 +979,7 @@ There is NO WARRANTY, to the extent permitted by law.\n"), stdout) < 0)
   exit (0);
 }
 
-char *program_name; /* Needed by lib/error.c. */
+static char *program_name; /* Needed by lib/error.c. */
 char *program_argstring; /* Needed by wget_warc.c. */
 
 int
@@ -1093,7 +1093,7 @@ main (int argc, char **argv)
                              short_options, long_options, &longindex)) != -1)
     {
       int val;
-      struct cmdline_option *opt;
+      struct cmdline_option *cmdopt;
 
       /* If LONGINDEX is unchanged, it means RET is referring a short
          option.  */
@@ -1115,31 +1115,31 @@ main (int argc, char **argv)
       /* Use the retrieved value to locate the option in the
          option_data array, and to see if we're dealing with the
          negated "--no-FOO" variant of the boolean option "--foo".  */
-      opt = &option_data[val & ~BOOLEAN_NEG_MARKER];
-      switch (opt->type)
+      cmdopt = &option_data[val & ~BOOLEAN_NEG_MARKER];
+      switch (cmdopt->type)
         {
         case OPT_VALUE:
-          setoptval (opt->data, optarg, opt->long_name);
+          setoptval (cmdopt->data, optarg, cmdopt->long_name);
           break;
         case OPT_BOOLEAN:
           if (optarg)
             /* The user has specified a value -- use it. */
-            setoptval (opt->data, optarg, opt->long_name);
+            setoptval (cmdopt->data, optarg, cmdopt->long_name);
           else
             {
               /* NEG is true for `--no-FOO' style boolean options. */
               bool neg = !!(val & BOOLEAN_NEG_MARKER);
-              setoptval (opt->data, neg ? "0" : "1", opt->long_name);
+              setoptval (cmdopt->data, neg ? "0" : "1", cmdopt->long_name);
             }
           break;
         case OPT_FUNCALL:
           {
-            void (*func) (void) = (void (*) (void)) opt->data;
+            void (*func) (void) = (void (*) (void)) cmdopt->data;
             func ();
           }
           break;
         case OPT__APPEND_OUTPUT:
-          setoptval ("logfile", optarg, opt->long_name);
+          setoptval ("logfile", optarg, cmdopt->long_name);
           append_to_log = true;
           break;
         case OPT__EXECUTE:
@@ -1150,24 +1150,23 @@ main (int argc, char **argv)
             /* We support real --no-FOO flags now, but keep these
                short options for convenience and backward
                compatibility.  */
-            char *p;
             for (p = optarg; p && *p; p++)
               switch (*p)
                 {
                 case 'v':
-                  setoptval ("verbose", "0", opt->long_name);
+                  setoptval ("verbose", "0", cmdopt->long_name);
                   break;
                 case 'H':
-                  setoptval ("addhostdir", "0", opt->long_name);
+                  setoptval ("addhostdir", "0", cmdopt->long_name);
                   break;
                 case 'd':
-                  setoptval ("dirstruct", "0", opt->long_name);
+                  setoptval ("dirstruct", "0", cmdopt->long_name);
                   break;
                 case 'c':
-                  setoptval ("noclobber", "1", opt->long_name);
+                  setoptval ("noclobber", "1", cmdopt->long_name);
                   break;
                 case 'p':
-                  setoptval ("noparent", "1", opt->long_name);
+                  setoptval ("noparent", "1", cmdopt->long_name);
                   break;
                 default:
                   fprintf (stderr, _("%s: illegal option -- `-n%c'\n"),
@@ -1191,12 +1190,12 @@ main (int argc, char **argv)
               flag = (*optarg == '1' || c_tolower (*optarg) == 'y'
                       || (c_tolower (optarg[0]) == 'o'
                           && c_tolower (optarg[1]) == 'n'));
-            setoptval (opt->type == OPT__PARENT ? "noparent" : "noclobber",
-                       flag ? "0" : "1", opt->long_name);
+            setoptval (cmdopt->type == OPT__PARENT ? "noparent" : "noclobber",
+                       flag ? "0" : "1", cmdopt->long_name);
             break;
           }
         case OPT__DONT_REMOVE_LISTING:
-          setoptval ("removelisting", "0", opt->long_name);
+          setoptval ("removelisting", "0", cmdopt->long_name);
           break;
         }
 
diff --git a/src/netrc.c b/src/netrc.c
index a31e079..1e12d1d 100644
--- a/src/netrc.c
+++ b/src/netrc.c
@@ -44,10 +44,16 @@ as that of the covered work.  */
 
 #define NETRC_FILE_NAME ".netrc"
 
-acc_t *netrc_list;
+static acc_t *netrc_list;
 
 static acc_t *parse_netrc (const char *);
 
+void
+netrc_cleanup(void)
+{
+  free_netrc (netrc_list);
+}
+
 /* Return the correct user and password, given the host, user (as
    given in the URL), and password (as given in the URL).  May return
    NULL.
diff --git a/src/netrc.h b/src/netrc.h
index 03af8f7..b4bb844 100644
--- a/src/netrc.h
+++ b/src/netrc.h
@@ -42,5 +42,6 @@ typedef struct _acc_t
 
 void search_netrc (const char *, const char **, const char **, int);
 void free_netrc (acc_t *l);
+void netrc_cleanup(void);
 
 #endif /* NETRC_H */
diff --git a/src/openssl.c b/src/openssl.c
index 7c92ac0..b725a06 100644
--- a/src/openssl.c
+++ b/src/openssl.c
@@ -305,7 +305,7 @@ openssl_read (int fd, char *buf, int bufsize, void *arg)
 }
 
 static int
-openssl_write (int fd, char *buf, int bufsize, void *arg)
+openssl_write (int fd _GL_UNUSED, char *buf, int bufsize, void *arg)
 {
   int ret = 0;
   struct openssl_transport_context *ctx = arg;
@@ -347,7 +347,7 @@ openssl_peek (int fd, char *buf, int bufsize, void *arg)
 }
 
 static const char *
-openssl_errstr (int fd, void *arg)
+openssl_errstr (int fd _GL_UNUSED, void *arg)
 {
   struct openssl_transport_context *ctx = arg;
   unsigned long errcode;
@@ -689,7 +689,7 @@ ssl_check_certificate (int fd, const char *host)
                       /* Compare and check for NULL attack in ASN1_STRING */
                       if (pattern_match ((char *)name_in_utf8, host) &&
                             (strlen ((char *)name_in_utf8) ==
-                                ASN1_STRING_length (name->d.dNSName)))
+                                (size_t) ASN1_STRING_length (name->d.dNSName)))
                         {
                           OPENSSL_free (name_in_utf8);
                           break;
@@ -753,7 +753,7 @@ ssl_check_certificate (int fd, const char *host)
 
           xentry = X509_NAME_get_entry(xname,i);
           sdata = X509_NAME_ENTRY_get_data(xentry);
-          if (strlen (common_name) != ASN1_STRING_length (sdata))
+          if (strlen (common_name) != (size_t) ASN1_STRING_length (sdata))
             {
               logprintf (LOG_NOTQUIET, _("\
     %s: certificate common name is invalid (contains a NUL character).\n\
diff --git a/src/options.h b/src/options.h
index 563207f..9358e30 100644
--- a/src/options.h
+++ b/src/options.h
@@ -69,8 +69,8 @@ struct options
 
   char **accepts;		/* List of patterns to accept. */
   char **rejects;		/* List of patterns to reject. */
-  char **excludes;		/* List of excluded FTP directories. */
-  char **includes;		/* List of FTP directories to
+  const char **excludes;	/* List of excluded FTP directories. */
+  const char **includes;	/* List of FTP directories to
 				   follow. */
   bool ignore_case;		/* Whether to ignore case when
 				   matching dirs and files */
diff --git a/src/progress.c b/src/progress.c
index 02aad11..6cb22d7 100644
--- a/src/progress.c
+++ b/src/progress.c
@@ -173,7 +173,7 @@ progress_create (const char *f_download, wgint initial, wgint total)
    and current update.  */
 
 bool
-progress_interactive_p (void *progress)
+progress_interactive_p (void *progress _GL_UNUSED)
 {
   return current_impl->interactive;
 }
@@ -1162,7 +1162,7 @@ bar_set_params (const char *params)
 
 #ifdef SIGWINCH
 void
-progress_handle_sigwinch (int sig)
+progress_handle_sigwinch (int sig _GL_UNUSED)
 {
   received_sigwinch = 1;
   signal (SIGWINCH, progress_handle_sigwinch);
diff --git a/src/res.c b/src/res.c
index 50dcb56..3038229 100644
--- a/src/res.c
+++ b/src/res.c
@@ -615,11 +615,11 @@ res_cleanup (void)
 #ifdef TESTING
 
 const char *
-test_is_robots_txt_url()
+test_is_robots_txt_url(void)
 {
-  int i;
-  struct {
-    char *url;
+  unsigned i;
+  static const struct {
+    const char *url;
     bool expected_result;
   } test_array[] = {
     { "http://www.yoyodyne.com/robots.txt", true },
@@ -627,7 +627,7 @@ test_is_robots_txt_url()
     { "http://www.yoyodyne.com/somepath/robots.txt", false },
   };
 
-  for (i = 0; i < sizeof(test_array)/sizeof(test_array[0]); ++i)
+  for (i = 0; i < countof(test_array); ++i)
     {
       mu_assert ("test_is_robots_txt_url: wrong result",
                  is_robots_txt_url (test_array[i].url) == test_array[i].expected_result);
diff --git a/src/retr.c b/src/retr.c
index 135f599..3638f90 100644
--- a/src/retr.c
+++ b/src/retr.c
@@ -588,7 +588,7 @@ fd_read_hunk (int fd, hunk_terminator_t terminator, long sizehint, long maxsize)
 }
 
 static const char *
-line_terminator (const char *start, const char *peeked, int peeklen)
+line_terminator (const char *start _GL_UNUSED, const char *peeked, int peeklen)
 {
   const char *p = memchr (peeked, '\n', peeklen);
   if (p)
@@ -1005,7 +1005,6 @@ retrieve_from_file (const char *file, bool html, int *count)
   if (url_valid_scheme (url))
     {
       int dt,url_err;
-      uerr_t status;
       struct url *url_parsed = url_parse (url, &url_err, iri, true);
       if (!url_parsed)
         {
diff --git a/src/spider.h b/src/spider.h
index a563c67..bfb5328 100644
--- a/src/spider.h
+++ b/src/spider.h
@@ -34,5 +34,6 @@ as that of the covered work.  */
 #define visited_url(a,b)
 void nonexisting_url (const char *);
 void print_broken_links (void);
+void spider_cleanup (void);
 
 #endif /* SPIDER_H */
diff --git a/src/test.c b/src/test.c
index 4602314..68c4863 100644
--- a/src/test.c
+++ b/src/test.c
@@ -71,7 +71,7 @@ all_tests()
 char *program_name; /* Needed by lib/error.c. */
 
 int
-main (int argc, char *argv[])
+main (int argc _GL_UNUSED, char *argv[])
 {
   const char *result;
 
diff --git a/src/test.h b/src/test.h
index f9a3f2c..6c5976e 100644
--- a/src/test.h
+++ b/src/test.h
@@ -45,6 +45,16 @@ do { \
 
 extern int tests_run;
 
+const char *test_parse_content_disposition(void);
+const char *test_commands_sorted(void);
+const char *test_cmd_spec_restrict_file_names(void);
+const char *test_is_robots_txt_url(void);
+const char *test_path_simplify (void);
+const char *test_append_uri_pathel(void);
+const char *test_are_urls_equal(void);
+const char *test_subdir_p(void);
+const char *test_dir_matches_p(void);
+
 #endif /* TEST_H */
 
 /*
diff --git a/src/url.c b/src/url.c
index eda1f54..1edfbae 100644
--- a/src/url.c
+++ b/src/url.c
@@ -2036,7 +2036,7 @@ url_string (const struct url *url, enum url_auth_mode auth_mode)
           if (url->passwd)
             {
               if (auth_mode == URL_AUTH_HIDE_PASSWD)
-                quoted_passwd = HIDDEN_PASSWORD;
+                quoted_passwd = (char *) HIDDEN_PASSWORD;
               else
                 quoted_passwd = url_escape_allow_passthrough (url->passwd);
             }
@@ -2205,7 +2205,7 @@ ps (char *path)
 #endif
 
 static const char *
-run_test (char *test, char *expected_result, enum url_scheme scheme,
+run_test (const char *test, const char *expected_result, enum url_scheme scheme,
           bool expected_change)
 {
   char *test_copy = xstrdup (test);
@@ -2234,8 +2234,8 @@ run_test (char *test, char *expected_result, enum url_scheme scheme,
 const char *
 test_path_simplify (void)
 {
-  static struct {
-    char *test, *result;
+  static const struct {
+    const char *test, *result;
     enum url_scheme scheme;
     bool should_modify;
   } tests[] = {
@@ -2267,15 +2267,16 @@ test_path_simplify (void)
     { "a/b/../../c",            "c",            SCHEME_HTTP, true },
     { "./a/../b",               "b",            SCHEME_HTTP, true }
   };
-  int i;
+  unsigned i;
 
   for (i = 0; i < countof (tests); i++)
     {
       const char *message;
-      char *test = tests[i].test;
-      char *expected_result = tests[i].result;
+      const char *test = tests[i].test;
+      const char *expected_result = tests[i].result;
       enum url_scheme scheme = tests[i].scheme;
       bool  expected_change = tests[i].should_modify;
+
       message = run_test (test, expected_result, scheme, expected_change);
       if (message) return message;
     }
@@ -2283,19 +2284,19 @@ test_path_simplify (void)
 }
 
 const char *
-test_append_uri_pathel()
+test_append_uri_pathel(void)
 {
-  int i;
-  struct {
-    char *original_url;
-    char *input;
+  unsigned i;
+  static const struct {
+    const char *original_url;
+    const char *input;
     bool escaped;
-    char *expected_result;
+    const char *expected_result;
   } test_array[] = {
     { "http://www.yoyodyne.com/path/", "somepage.html", false, "http://www.yoyodyne.com/path/somepage.html" },
   };
 
-  for (i = 0; i < sizeof(test_array)/sizeof(test_array[0]); ++i)
+  for (i = 0; i < countof(test_array); ++i)
     {
       struct growable dest;
       const char *p = test_array[i].input;
@@ -2312,13 +2313,13 @@ test_append_uri_pathel()
   return NULL;
 }
 
-const char*
-test_are_urls_equal()
+const char *
+test_are_urls_equal(void)
 {
-  int i;
-  struct {
-    char *url1;
-    char *url2;
+  unsigned i;
+  static const struct {
+    const char *url1;
+    const char *url2;
     bool expected_result;
   } test_array[] = {
     { "http://www.adomain.com/apath/", "http://www.adomain.com/apath/",       true },
@@ -2329,7 +2330,7 @@ test_are_urls_equal()
     { "http://www.adomain.com/path%2f", "http://www.adomain.com/path/",       false },
   };
 
-  for (i = 0; i < sizeof(test_array)/sizeof(test_array[0]); ++i)
+  for (i = 0; i < countof(test_array); ++i)
     {
       mu_assert ("test_are_urls_equal: wrong result",
                  are_urls_equal (test_array[i].url1, test_array[i].url2) == test_array[i].expected_result);
diff --git a/src/utils.c b/src/utils.c
index 01be3ea..11ca75c 100644
--- a/src/utils.c
+++ b/src/utils.c
@@ -484,9 +484,12 @@ fork_to_background (void)
 
   /* child: give up the privileges and keep running. */
   setsid ();
-  freopen ("/dev/null", "r", stdin);
-  freopen ("/dev/null", "w", stdout);
-  freopen ("/dev/null", "w", stderr);
+  if (freopen ("/dev/null", "r", stdin) == NULL)
+    DEBUGP (("Failed to redirect stdin to /dev/null.\n"));
+  if (freopen ("/dev/null", "w", stdout) == NULL)
+    DEBUGP (("Failed to redirect stdout to /dev/null.\n"));
+  if (freopen ("/dev/null", "w", stderr) == NULL)
+    DEBUGP (("Failed to redirect stderr to /dev/null.\n"));
 }
 #endif /* !WINDOWS && !MSDOS */
 
@@ -957,16 +960,16 @@ subdir_p (const char *d1, const char *d2)
    first element that matches DIR, through wildcards or front comparison (as
    appropriate).  */
 static bool
-dir_matches_p (char **dirlist, const char *dir)
+dir_matches_p (const char **dirlist, const char *dir)
 {
-  char **x;
+  const char **x;
   int (*matcher) (const char *, const char *, int)
     = opt.ignore_case ? fnmatch_nocase : fnmatch;
 
   for (x = dirlist; *x; x++)
     {
       /* Remove leading '/' */
-      char *p = *x + (**x == '/');
+      const char *p = *x + (**x == '/');
       if (has_wildcards_p (p))
         {
           if (matcher (p, dir, FNM_PATHNAME) == 0)
@@ -2102,8 +2105,8 @@ xsleep (double seconds)
    This implementation does not emit newlines after 76 characters of
    base64 data.  */
 
-int
-base64_encode (const void *data, int length, char *dest)
+size_t
+base64_encode (const void *data, size_t length, char *dest)
 {
   /* Conversion table.  */
   static const char tbl[64] = {
@@ -2170,7 +2173,7 @@ base64_encode (const void *data, int length, char *dest)
 
    This function originates from Free Recode.  */
 
-int
+ssize_t
 base64_decode (const char *base64, void *dest)
 {
   /* Table of base64 values for first 128 characters.  Note that this
@@ -2283,7 +2286,7 @@ compile_posix_regex (const char *str)
   int errcode = regcomp ((regex_t *) regex, str, REG_EXTENDED | REG_NOSUB);
   if (errcode != 0)
     {
-      int errbuf_size = regerror (errcode, (regex_t *) regex, NULL, 0);
+      size_t errbuf_size = regerror (errcode, (regex_t *) regex, NULL, 0);
       char *errbuf = xmalloc (errbuf_size);
       regerror (errcode, (regex_t *) regex, errbuf, errbuf_size);
       fprintf (stderr, _("Invalid regular expression %s, %s\n"),
@@ -2301,10 +2304,10 @@ compile_posix_regex (const char *str)
 bool
 match_pcre_regex (const void *regex, const char *str)
 {
-  int l = strlen (str);
+  size_t l = strlen (str);
   int ovector[OVECCOUNT];
 
-  int rc = pcre_exec ((pcre *) regex, 0, str, l, 0, 0, ovector, OVECCOUNT);
+  int rc = pcre_exec ((pcre *) regex, 0, str, (int) l, 0, 0, ovector, OVECCOUNT);
   if (rc == PCRE_ERROR_NOMATCH)
     return false;
   else if (rc < 0)
@@ -2330,7 +2333,7 @@ match_posix_regex (const void *regex, const char *str)
     return true;
   else
     {
-      int errbuf_size = regerror (rc, opt.acceptregex, NULL, 0);
+      size_t errbuf_size = regerror (rc, opt.acceptregex, NULL, 0);
       char *errbuf = xmalloc (errbuf_size);
       regerror (rc, opt.acceptregex, errbuf, errbuf_size);
       logprintf (LOG_VERBOSE, _("Error while matching %s: %d\n"),
@@ -2426,7 +2429,7 @@ print_decimal (double number)
 
 /* Get the maximum name length for the given path. */
 /* Return 0 if length is unknown. */
-size_t
+long
 get_max_length (const char *path, int length, int name)
 {
   long ret;
@@ -2481,9 +2484,9 @@ get_max_length (const char *path, int length, int name)
 #ifdef TESTING
 
 const char *
-test_subdir_p()
+test_subdir_p(void)
 {
-  static struct {
+  static const struct {
     const char *d1;
     const char *d2;
     bool result;
@@ -2506,10 +2509,10 @@ test_subdir_p()
 }
 
 const char *
-test_dir_matches_p()
+test_dir_matches_p(void)
 {
   static struct {
-    char *dirlist[3];
+    const char *dirlist[3];
     const char *dir;
     bool result;
   } test_array[] = {
diff --git a/src/utils.h b/src/utils.h
index 7c6f2ce..e244b8a 100644
--- a/src/utils.h
+++ b/src/utils.h
@@ -139,8 +139,8 @@ void xsleep (double);
 /* How many bytes it will take to store LEN bytes in base64.  */
 #define BASE64_LENGTH(len) (4 * (((len) + 2) / 3))
 
-int base64_encode (const void *, int, char *);
-int base64_decode (const char *, void *);
+size_t base64_encode (const void *, size_t, char *);
+ssize_t base64_decode (const char *, void *);
 
 #ifdef HAVE_LIBPCRE
 void *compile_pcre_regex (const char *);
@@ -154,7 +154,7 @@ void stable_sort (void *, size_t, size_t, int (*) (const void *, const void *));
 
 const char *print_decimal (double);
 
-size_t get_max_length (const char *path, int length, int name);
+long get_max_length (const char *path, int length, int name);
 
 extern unsigned char char_prop[];
 
diff --git a/src/warc.c b/src/warc.c
index c3a5857..38ef3a1 100644
--- a/src/warc.c
+++ b/src/warc.c
@@ -108,7 +108,7 @@ static char *warc_current_filename;
 static int warc_current_file_number;
 
 /* The table of CDX records, if deduplication is enabled. */
-struct hash_table * warc_cdx_dedup_table;
+static struct hash_table * warc_cdx_dedup_table;
 
 static bool warc_start_new_file (bool meta);
 
@@ -1231,7 +1231,7 @@ static bool
 warc_write_cdx_record (const char *url, const char *timestamp_str,
                        const char *mime_type, int response_code,
                        const char *payload_digest, const char *redirect_location,
-                       off_t offset, const char *warc_filename,
+                       off_t offset, const char *warc_filename _GL_UNUSED,
                        const char *response_uuid)
 {
   /* Transform the timestamp. */
-- 
cgit v1.0-41-gc330

