@@ -101,8 +101,8 @@ int
 AIODiskIOStrategy::callback()
 {
     return 0;
+#if 0
     int i;
-    int completed = 0;
     int retval, reterr;
     FREE *freefunc;
     void *cbdata;
@@ -168,7 +168,8 @@ AIODiskIOStrategy::callback()
         }
     }
 
-    return completed;
+    return 0;
+#endif
 }
 
 void
@@ -348,8 +348,11 @@ DiskdFile::readDone(diomsg * M)
     ReadRequest::Pointer readRequest = dynamic_cast<ReadRequest *>(M->requestor);
 
     /* remove the free protection */
-    if (readRequest != NULL)
-        readRequest->unlock();
+    if (readRequest != NULL) {
+        const uint32_t lcount = readRequest->unlock();
+        if (lcount == 0)
+            debugs(79, DBG_IMPORTANT, "invariant check failed: readRequest reference count is 0");
+    }
 
     if (M->status < 0) {
         ++diskd_stats.read.fail;
@@ -372,9 +375,13 @@ DiskdFile::writeDone(diomsg *M)
     debugs(79, 3, "storeDiskdWriteDone: status " << M->status);
     assert (M->requestor);
     WriteRequest::Pointer writeRequest = dynamic_cast<WriteRequest *>(M->requestor);
+
     /* remove the free protection */
-    if (writeRequest != NULL)
-        writeRequest->unlock();
+    if (writeRequest != NULL) {
+        const uint32_t lcount = writeRequest->unlock();
+        if (lcount == 0)
+            debugs(79, DBG_IMPORTANT, "invariant check failed: writeRequest reference count is 0");
+    }
 
     if (M->status < 0) {
         errorOccured = true;
@@ -19,17 +19,13 @@ class SharedMemory
 
 public:
     void put(ssize_t);
-
     void *get(ssize_t *);
-
     void init(int ikey, int magic2);
+    SharedMemory() : nbufs(0), buf(nullptr), inuse_map(nullptr), id(0) {}
 
     int nbufs;
-
     char *buf;
-
     char *inuse_map;
-
     int id;
 };
 
@@ -468,7 +468,11 @@ _db_rotate_log(void)
         remove
         (to);
 #endif
-        rename(from, to);
+        errno = 0;
+        if (rename(from, to) == -1) {
+            const auto saved_errno = errno;
+            debugs(0, DBG_IMPORTANT, "log rotation failed: " << xstrerr(saved_errno));
+        }
     }
 
     /*
@@ -219,8 +219,13 @@ diskHandleWrite(int fd, void *)
 
     errno = 0;
 
-    if (fdd->write_q->file_offset != -1)
-        lseek(fd, fdd->write_q->file_offset, SEEK_SET); /* XXX ignore return? */
+    if (fdd->write_q->file_offset != -1) {
+        errno = 0;
+        if (lseek(fd, fdd->write_q->file_offset, SEEK_SET) == -1) {
+            debugs(50, DBG_IMPORTANT, "error in seek for fd " << fd << ": " << xstrerror());
+            // XXX: handle error?
+        }
+    }
 
     len = FD_WRITE_METHOD(fd,
                           fdd->write_q->buf + fdd->write_q->buf_offset,
@@ -421,7 +426,12 @@ diskHandleRead(int fd, void *data)
     {
 #endif
         debugs(6, 3, "diskHandleRead: FD " << fd << " seeking to offset " << ctrl_dat->offset);
-        lseek(fd, ctrl_dat->offset, SEEK_SET);  /* XXX ignore return? */
+        errno = 0;
+        if (lseek(fd, ctrl_dat->offset, SEEK_SET) == -1) {
+            // shouldn't happen, let's detect that
+            debugs(50, DBG_IMPORTANT, "error in seek for fd " << fd << ": " << xstrerror());
+            // XXX handle failures?
+        }
         ++ statCounter.syscalls.disk.seeks;
         F->disk.offset = ctrl_dat->offset;
     }
@@ -151,10 +151,23 @@ ipcCreate(int type, const char *prog, const char *const args[], const char *name
             return -1;
         }
 
-        setsockopt(fds[0], SOL_SOCKET, SO_SNDBUF, (void *) &buflen, sizeof(buflen));
-        setsockopt(fds[0], SOL_SOCKET, SO_RCVBUF, (void *) &buflen, sizeof(buflen));
-        setsockopt(fds[1], SOL_SOCKET, SO_SNDBUF, (void *) &buflen, sizeof(buflen));
-        setsockopt(fds[1], SOL_SOCKET, SO_RCVBUF, (void *) &buflen, sizeof(buflen));
+        errno = 0;
+        if (setsockopt(fds[0], SOL_SOCKET, SO_SNDBUF, (void *) &buflen, sizeof(buflen)) == -1)  {
+            debugs(54, DBG_IMPORTANT, "setsockopt failed: " << xstrerror());
+            errno = 0;
+        }
+        if (setsockopt(fds[0], SOL_SOCKET, SO_RCVBUF, (void *) &buflen, sizeof(buflen)) == -1) {
+            debugs(54, DBG_IMPORTANT, "setsockopt failed: " << xstrerror());
+            errno = 0;
+        }
+        if (setsockopt(fds[1], SOL_SOCKET, SO_SNDBUF, (void *) &buflen, sizeof(buflen)) == -1) {
+            debugs(54, DBG_IMPORTANT, "setsockopt failed: " << xstrerror());
+            errno = 0;
+        }
+        if (setsockopt(fds[1], SOL_SOCKET, SO_RCVBUF, (void *) &buflen, sizeof(buflen)) == -1) {
+            debugs(54, DBG_IMPORTANT, "setsockopt failed: " << xstrerror());
+            errno = 0;
+        }
         fd_open(prfd = pwfd = fds[0], FD_PIPE, "IPC UNIX STREAM Parent");
         fd_open(crfd = cwfd = fds[1], FD_PIPE, "IPC UNIX STREAM Parent");
         IPC_CHECK_FAIL(crfd, "child read", "UDS socket");
@@ -25,7 +25,8 @@ class ReadWriteLockStats;
 class ReadWriteLock
 {
 public:
-    // default constructor is OK because of shared memory zero-initialization
+    ReadWriteLock() : readers(0), writing(false), appending(false), readLevel(0), writeLevel(0)
+    {}
 
     bool lockShared(); ///< lock for reading or return false
     bool lockExclusive(); ///< lock for modification or return false
@@ -1492,15 +1492,23 @@ dump_peer_options(StoreEntry * sentry, CachePeer * p)
     if (p->options.htcp) {
         storeAppendPrintf(sentry, " htcp");
         if (p->options.htcp_oldsquid || p->options.htcp_no_clr || p->options.htcp_no_purge_clr || p->options.htcp_only_clr) {
-            int doneopts=0;
-            if (p->options.htcp_oldsquid)
-                storeAppendPrintf(sentry, "%soldsquid",(doneopts++>0?",":"="));
-            if (p->options.htcp_no_clr)
-                storeAppendPrintf(sentry, "%sno-clr",(doneopts++>0?",":"="));
-            if (p->options.htcp_no_purge_clr)
-                storeAppendPrintf(sentry, "%sno-purge-clr",(doneopts++>0?",":"="));
-            if (p->options.htcp_only_clr)
-                storeAppendPrintf(sentry, "%sonly-clr",(doneopts++>0?",":"="));
+            bool doneopts = false;
+            if (p->options.htcp_oldsquid) {
+                storeAppendPrintf(sentry, "oldsquid");
+                doneopts = true;
+            }
+            if (p->options.htcp_no_clr) {
+                storeAppendPrintf(sentry, "%sno-clr",(doneopts?",":"="));
+                doneopts = true;
+            }
+            if (p->options.htcp_no_purge_clr) {
+                storeAppendPrintf(sentry, "%sno-purge-clr",(doneopts?",":"="));
+                doneopts = true;
+            }
+            if (p->options.htcp_only_clr) {
+                storeAppendPrintf(sentry, "%sonly-clr",(doneopts?",":"="));
+                //doneopts = true; // uncomment if more opts are added
+            }
         }
     }
 #endif
@@ -15,16 +15,9 @@ class StoreRebuildData
 {
 public:
     StoreRebuildData() :
-        objcount(0),
-        expcount(0),
-        scancount(0),
-        clashcount(0),
-        dupcount(0),
-        cancelcount(0),
-        invalid(0),
-        badflags(0),
-        bad_log_op(0),
-        zero_object_sz(0)
+        objcount(0), expcount(0), scancount(0), clashcount(0),
+        dupcount(0), cancelcount(0), invalid(0), badflags(0),
+        bad_log_op(0), zero_object_sz(0)
     {}
 
     int objcount;       /* # objects successfully reloaded */
@@ -12,6 +12,8 @@
 
 #include "squid.h"
 
+#include <iostream>
+#include <cstdio>
 #if HAVE_PATHS_H
 #include <paths.h>
 #endif
@@ -49,24 +51,18 @@
 int
 main(int, char *[])
 {
-    char buf[UNLINK_BUF_LEN];
-    char *t;
-    int x;
-    setbuf(stdin, NULL);
-    setbuf(stdout, NULL);
+    std::string sbuf;
     close(2);
     if (open(_PATH_DEVNULL, O_RDWR) < 0) {
         ; // the irony of having to close(2) earlier is that we cannot report this failure.
     }
-
-    while (fgets(buf, sizeof(buf), stdin)) {
-        if ((t = strchr(buf, '\n')))
-            *t = '\0';
-        x = unlink(buf);
-        if (x < 0)
-            printf("ERR\n");
+    while (getline(std::cin, sbuf)) {
+        // tailing newline is removed by getline
+        const int rv = remove(sbuf.c_str());
+        if (rv < 0)
+            std::cout << "ERR" << std::endl; // endl flushes
         else
-            printf("OK\n");
+            std::cout << "OK" << std::endl;
     }
 
     return 0;